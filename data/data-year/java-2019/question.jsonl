{"hexsha": "a4cf48de469b563c0faf5017f247750722ef9e4a", "ext": "java", "lang": "Java", "content": "public class UnfollowServlet extends DendriteServlet {\n\n    private static final long serialVersionUID = -1671751304334555912L;\n\n    private boolean isTargetIdValid(final String id) {\n        final User target = new User();\n        target.setId(id);\n        return target.isInStore();\n    }\n\n    @Override\n    protected void doPost(final HttpServletRequest req,\n            final HttpServletResponse resp)\n                    throws ServletException, IOException {\n        final String targetId = req.getParameter(\"id\");\n        final boolean isTargetIdValid = isTargetIdValid(targetId);\n        if (isTargetIdValid == true) {\n            final UnfollowController controller = new UnfollowController();\n            controller.setTargetId(targetId);\n            final User source = User.getMyUser();\n            final String sourceId = source.getId();\n            controller.setSourceId(sourceId);\n            controller.enableUnfollow();\n            resp.setStatus(HttpServletResponse.SC_OK);\n        } else {\n            resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n        }\n    }\n}", "class_id": 0, "repo": "MattHeard/Dendrite", "file": "Dendrite/src/com/deuteriumlabs/dendrite/controller/UnfollowServlet.java", "last_update_at": "2019-06-15T04:02:47+00:00", "question_id": "a4cf48de469b563c0faf5017f247750722ef9e4a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class UnfollowServlet extends DendriteServlet {\n    private static final long serialVersionUID = -1671751304334555912L;\n    private boolean isTargetIdValid(final String id) {\n        final User target = new User();\n        target.setId(id);\n        return target.isInStore();\n    }\n    @Override\n    protected void doPost(final HttpServletRequest req,\n            final HttpServletResponse resp)\n                    throws ServletException, IOException {\n        final String targetId = req.getParameter(\"id\");\n        final boolean isTargetIdValid = isTargetIdValid(targetId);\n        if (isTargetIdValid == true) {\n            final UnfollowController controller = new UnfollowController();\n            controller.setTargetId(targetId);\n            final User source = User.getMyUser();\n            final String sourceId = source.getId();\n            controller.setSourceId(sourceId);\n            controller.enableUnfollow();\n            resp.setStatus(HttpServletResponse.SC_OK);\n        } else {\n            resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n        }\n    }\n"]]}
{"hexsha": "e2e5c458cf4d67fb97f5ae7d9459dcc8eddecba5", "ext": "java", "lang": "Java", "content": "@Component\npublic class N2oCustomXmlReaderV1 extends N2oStandardControlReaderV1<N2oCustomField> {\n    @Override\n    public N2oCustomField read(Element element, Namespace namespace) {\n        N2oCustomField n2oCustomField = new N2oCustomField();\n        getControlFieldDefinition(element, n2oCustomField);\n        return n2oCustomField;\n    }\n\n    @Override\n    public Class<N2oCustomField> getElementClass() {\n        return N2oCustomField.class;\n    }\n\n    @Override\n    public String getElementName() {\n        return \"custom\";\n    }\n}", "class_id": 0, "repo": "iryabov/n2o-framework", "file": "backend/n2o/n2o-config/src/main/java/net/n2oapp/framework/config/reader/control/N2oCustomXmlReaderV1.java", "last_update_at": "2019-01-09T09:32:47+00:00", "question_id": "e2e5c458cf4d67fb97f5ae7d9459dcc8eddecba5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\npublic class N2oCustomXmlReaderV1 extends N2oStandardControlReaderV1<N2oCustomField> {\n    @Override\n    public N2oCustomField read(Element element, Namespace namespace) {\n        N2oCustomField n2oCustomField = new N2oCustomField();\n        getControlFieldDefinition(element, n2oCustomField);\n        return n2oCustomField;\n    }\n    @Override\n    public Class<N2oCustomField> getElementClass() {\n        return N2oCustomField.class;\n    }\n    @Override\n    public String getElementName() {\n        return \"custom\";\n    }\n"]]}
{"hexsha": "383854c2565eb2d95e745b173b337beb09602985", "ext": "java", "lang": "Java", "content": "public class playstateinput3 implements InputProcessor {\n    playstate3 ps3;\n\n\n\n    public playstateinput3(playstate3 ps){\n        this.ps3 = ps;\n    }\n\n    @Override\n\n    public boolean keyDown(int keycode) {\n        return false;\n    }\n\n    @Override\n    public boolean keyUp(int keycode) {\n        return false;\n    }\n\n    @Override\n    public boolean keyTyped(char character) {\n        return false;\n    }\n\n    @Override\n    public boolean touchDown(int screenX, int screenY, int pointer, int button) {\n        return false;\n    }\n\n    @Override\n    public boolean touchUp(int screenX, int screenY, int pointer, int button) {\n        if(ps3.getGeri().getButtonRect().contains(screenX,screenY)) {\n            ps3.getSound2().stop();\n            ps3.getSm3().pushState(new menustate(ps3.getSm3()));}\n        if(ps3.getDeger()==ps3.getDeger2()){\n            int a= ps3.getSkor();\n            a=a+1;\n            ps3.setSkor(a);\n\n        }\n        else\n        {\n            int c=ps3.getCan();\n            if(c==5)\n            {\n                c--;\n            }\n            else if(c==4)\n            {\n                c--;\n            }\n            else if(c==3)\n            {\n                c--;\n            }\n            else if(c==2)\n            {\n                c--;\n            }\n            else if(c==1)\n            {\n                c--;\n            }\n            else if(c==0)\n            {\n                c=0;\n            }\n\n            ps3.setCan(c);\n        }\n\n\n\n        return false;\n    }\n\n    @Override\n    public boolean touchDragged(int screenX, int screenY, int pointer) {\n\n        return false;\n    }\n\n    @Override\n    public boolean mouseMoved(int screenX, int screenY) {\n        return false;\n    }\n\n    @Override\n    public boolean scrolled(int amount) {\n        return false;\n    }\n}", "class_id": 0, "repo": "nahronitem55/Reflex-Libgdx", "file": "core/src/com/metin/reflex/inputhandler/playstateinput3.java", "last_update_at": "2019-04-15T18:38:51+00:00", "question_id": "383854c2565eb2d95e745b173b337beb09602985", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class playstateinput3 implements InputProcessor {\n    playstate3 ps3;\n    public playstateinput3(playstate3 ps){\n        this.ps3 = ps;\n    }\n    @Override\n    public boolean keyDown(int keycode) {\n        return false;\n    }\n    @Override\n    public boolean keyUp(int keycode) {\n        return false;\n    }\n    @Override\n    public boolean keyTyped(char character) {\n        return false;\n    }\n    @Override\n    public boolean touchDown(int screenX, int screenY, int pointer, int button) {\n        return false;\n    }\n    @Override\n    public boolean touchUp(int screenX, int screenY, int pointer, int button) {\n        if(ps3.getGeri().getButtonRect().contains(screenX,screenY)) {\n            ps3.getSound2().stop();\n            ps3.getSm3().pushState(new menustate(ps3.getSm3()));}\n        if(ps3.getDeger()==ps3.getDeger2()){\n            int a= ps3.getSkor();\n            a=a+1;\n            ps3.setSkor(a);\n        }\n        else\n        {\n            int c=ps3.getCan();\n            if(c==5)\n            {\n                c--;\n            }\n            else if(c==4)\n            {\n                c--;\n            }\n            else if(c==3)\n            {\n                c--;\n            }\n            else if(c==2)\n            {\n                c--;\n            }\n            else if(c==1)\n            {\n                c--;\n            }\n            else if(c==0)\n            {\n                c=0;\n            }\n            ps3.setCan(c);\n        }\n        return false;\n    }\n    @Override\n    public boolean touchDragged(int screenX, int screenY, int pointer) {\n        return false;\n    }\n    @Override\n    public boolean mouseMoved(int screenX, int screenY) {\n        return false;\n    }\n    @Override\n    public boolean scrolled(int amount) {\n        return false;\n    }\n"]]}
{"hexsha": "430c367bd4f526313c7a504abd13a3a865e4ea62", "ext": "java", "lang": "Java", "content": "public class _0207CourseSchedule {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(canFinish(2, new int[][] { new int[] { 1, 0 } }));\n\t\tSystem.out.println(canFinish(2, new int[][] { new int[] { 1, 0 }, new int[] { 0, 1 } }));\n\t}\n\n\tpublic static boolean canFinish(int numCourses, int[][] prerequisites) {\n\t\tHashMap<Integer, HashSet<Integer>> adjList = new HashMap<Integer, HashSet<Integer>>();\n\t\tHashMap<Integer, Integer> adjListCount = new HashMap<Integer, Integer>();\n\t\tfor (int i = 0; i < numCourses; i++) {\n\t\t\tadjList.put(i, new HashSet<Integer>());\n\t\t\tadjListCount.put(i, 0);\n\t\t}\n\n\t\tfor (int[] prereq : prerequisites) {\n\t\t\tadjList.get(prereq[1]).add(prereq[0]);\n\t\t\tadjListCount.put(prereq[1], adjListCount.get(prereq[1]) + 1);\n\t\t}\n\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tfor (Map.Entry<Integer, Integer> entry : adjListCount.entrySet()) {\n\t\t\tif (entry.getValue() == 0) {\n\t\t\t\tq.add(entry.getKey());\n\t\t\t\tadjListCount.put(entry.getKey(), -1);\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\twhile (!q.isEmpty()) {\n\t\t\tint size = q.size();\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tInteger node = q.poll();\n\t\t\t\tcount++;\n\t\t\t\t// find all nodes with values of this node and remove adjlistcount\n\t\t\t\tfor (Map.Entry<Integer, HashSet<Integer>> entry : adjList.entrySet()) {\n\t\t\t\t\tif (entry.getValue().contains(node)) {\n\t\t\t\t\t\tentry.getValue().remove(node);\n\t\t\t\t\t\tadjListCount.put(entry.getKey(), adjListCount.get(entry.getKey()) - 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (adjListCount.get(entry.getKey()) == 0) {\n\t\t\t\t\t\tq.add(entry.getKey());\n\t\t\t\t\t\tadjListCount.put(entry.getKey(), -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\treturn count == numCourses;\n\t}\n}", "class_id": 0, "repo": "darshanhs90/Java-HackerRank", "file": "src/Dec2020Leetcode/_0207CourseSchedule.java", "last_update_at": "2019-08-09T07:31:34+00:00", "question_id": "430c367bd4f526313c7a504abd13a3a865e4ea62", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class _0207CourseSchedule {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(canFinish(2, new int[][] { new int[] { 1, 0 } }));\n\t\tSystem.out.println(canFinish(2, new int[][] { new int[] { 1, 0 }, new int[] { 0, 1 } }));\n\t}\n\tpublic static boolean canFinish(int numCourses, int[][] prerequisites) {\n\t\tHashMap<Integer, HashSet<Integer>> adjList = new HashMap<Integer, HashSet<Integer>>();\n\t\tHashMap<Integer, Integer> adjListCount = new HashMap<Integer, Integer>();\n\t\tfor (int i = 0; i < numCourses; i++) {\n\t\t\tadjList.put(i, new HashSet<Integer>());\n\t\t\tadjListCount.put(i, 0);\n\t\t}\n\t\tfor (int[] prereq : prerequisites) {\n\t\t\tadjList.get(prereq[1]).add(prereq[0]);\n\t\t\tadjListCount.put(prereq[1], adjListCount.get(prereq[1]) + 1);\n\t\t}\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tfor (Map.Entry<Integer, Integer> entry : adjListCount.entrySet()) {\n\t\t\tif (entry.getValue() == 0) {\n\t\t\t\tq.add(entry.getKey());\n\t\t\t\tadjListCount.put(entry.getKey(), -1);\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\twhile (!q.isEmpty()) {\n\t\t\tint size = q.size();\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tInteger node = q.poll();\n\t\t\t\tcount++;\n\t\t\t\t// find all nodes with values of this node and remove adjlistcount\n\t\t\t\tfor (Map.Entry<Integer, HashSet<Integer>> entry : adjList.entrySet()) {\n\t\t\t\t\tif (entry.getValue().contains(node)) {\n\t\t\t\t\t\tentry.getValue().remove(node);\n\t\t\t\t\t\tadjListCount.put(entry.getKey(), adjListCount.get(entry.getKey()) - 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (adjListCount.get(entry.getKey()) == 0) {\n\t\t\t\t\t\tq.add(entry.getKey());\n\t\t\t\t\t\tadjListCount.put(entry.getKey(), -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count == numCourses;\n\t}\n"]]}
{"hexsha": "5a8681d2f64bbaa08bd02d575411880b8fe4e259", "ext": "java", "lang": "Java", "content": "public class NoteTestPassesMatcherTest {\r\n    private static final String xpathValuesControlXML =\r\n            \"<root>\" +\r\n                    \"<outer attr=\\\"urk\\\">\" +\r\n                    \"<inner attr=\\\"urk\\\">controlDocument</inner>\" +\r\n                    \"</outer>\" +\r\n                    \"</root>\";\r\n    private static final String xpathValuesTestXML =\r\n            \"<root>\" +\r\n                    \"<outer attr=\\\"urk\\\">\" +\r\n                    \"<inner attr=\\\"ugh\\\">testDocument</inner>\" +\r\n                    \"</outer>\" +\r\n                    \"</root>\";\r\n\r\n    @Test\r\n    public void testNodeTest() throws Exception {\r\n        DocumentUtils documentUtils = new DocumentUtils(new XmlUnitProperties());\r\n\r\n        NodeTester tester = new CountingNodeTester(1);\r\n\r\n        assertThat(new NodeTest(documentUtils, xpathValuesControlXML), passesWith(tester, Node.TEXT_NODE));\r\n        try {\r\n            assertThat(new NodeTest(documentUtils, xpathValuesControlXML), passesWith(tester, Node.ELEMENT_NODE));\r\n            fail(\"Expected node test failure #1!\");\r\n        } catch (AssertionError e) {\r\n        }\r\n\r\n        NodeTest test = new NodeTest(documentUtils, new StringReader(xpathValuesTestXML));\r\n        tester = new CountingNodeTester(4);\r\n        assertThat(test, passesWith(tester, new short[] { Node.TEXT_NODE, Node.ELEMENT_NODE }));\r\n        assertThat(test, notPassesWith(tester, new short[] { Node.TEXT_NODE, Node.COMMENT_NODE }));\r\n\r\n        try {\r\n            assertThat(test, notPassesWith(tester, new short[] { Node.TEXT_NODE, Node.ELEMENT_NODE }));\r\n            fail(\"Expected node test failure #2!\");\r\n        } catch (AssertionError e) {\r\n        }\r\n\r\n        try {\r\n            assertThat(test, passesWith(tester, new short[] { Node.TEXT_NODE, Node.COMMENT_NODE }));\r\n            fail(\"Expected node test failure #3!\");\r\n        } catch (AssertionError e) {\r\n        }\r\n    }\r\n}", "class_id": 0, "repo": "twerszko/xmlunit-nsc", "file": "src/test/java/org/custommonkey/xmlunit/matchers/NoteTestPassesMatcherTest.java", "last_update_at": "2019-04-23T03:25:16+00:00", "question_id": "5a8681d2f64bbaa08bd02d575411880b8fe4e259", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NoteTestPassesMatcherTest {\r\n    private static final String xpathValuesControlXML =\r\n            \"<root>\" +\r\n                    \"<outer attr=\\\"urk\\\">\" +\r\n                    \"<inner attr=\\\"urk\\\">controlDocument</inner>\" +\r\n                    \"</outer>\" +\r\n                    \"</root>\";\r\n    private static final String xpathValuesTestXML =\r\n            \"<root>\" +\r\n                    \"<outer attr=\\\"urk\\\">\" +\r\n                    \"<inner attr=\\\"ugh\\\">testDocument</inner>\" +\r\n                    \"</outer>\" +\r\n                    \"</root>\";\r\n\r\n    @Test\r\n    public void testNodeTest() throws Exception {\r\n        DocumentUtils documentUtils = new DocumentUtils(new XmlUnitProperties());\r\n\r\n        NodeTester tester = new CountingNodeTester(1);\r\n\r\n        assertThat(new NodeTest(documentUtils, xpathValuesControlXML), passesWith(tester, Node.TEXT_NODE));\r\n        try {\r\n            assertThat(new NodeTest(documentUtils, xpathValuesControlXML), passesWith(tester, Node.ELEMENT_NODE));\r\n            fail(\"Expected node test failure #1!\");\r\n        } catch (AssertionError e) {\r\n        }\r\n\r\n        NodeTest test = new NodeTest(documentUtils, new StringReader(xpathValuesTestXML));\r\n        tester = new CountingNodeTester(4);\r\n        assertThat(test, passesWith(tester, new short[] { Node.TEXT_NODE, Node.ELEMENT_NODE }));\r\n        assertThat(test, notPassesWith(tester, new short[] { Node.TEXT_NODE, Node.COMMENT_NODE }));\r\n\r\n        try {\r\n            assertThat(test, notPassesWith(tester, new short[] { Node.TEXT_NODE, Node.ELEMENT_NODE }));\r\n            fail(\"Expected node test failure #2!\");\r\n        } catch (AssertionError e) {\r\n        }\r\n\r\n        try {\r\n            assertThat(test, passesWith(tester, new short[] { Node.TEXT_NODE, Node.COMMENT_NODE }));\r\n            fail(\"Expected node test failure #3!\");\r\n        } catch (AssertionError e) {\r\n        }\r\n    }\r\n"]]}
{"hexsha": "d2df215913367b4c103bb7a7ee7e8b8409022d69", "ext": "java", "lang": "Java", "content": "public final class ApiSignature {\n    /**\n     * API auth signature creation method using token and\n     * secret key. Uses Hash HMAC algorithm with SHA256\n     *\n     * @param token         Unique auth token provided to user\n     * @param secret        Secret key of the user\n     * @param parameters    Request parameters as key value pair\n     * @param url           Complete API url without query string or request params\n     * @param requestMethod HTTP request method for this request (GET|POST|PUT|DELETE|OPTIONS)\n     * @return base64 encoded signature\n     */\n    public static String createSignature(String token, String secret, HashMap<String, String> parameters, String url, String requestMethod) {\n        AppLog.d(\"API trace: X-Api-AuthToken : \" + token);\n        AppLog.d(\"API trace: Requested Url : \" + url + \"; Method Type : \" + requestMethod);\n\n        String longStr = requestMethod + '|' + url + \"\\n\";\n\n        // if mapData is present the sort it and add key value to the string\n        if (parameters != null) {\n            TreeMap<String, String> sortedData = new TreeMap<>(parameters);\n            for (Map.Entry<String, String> entry : sortedData.entrySet()) {\n                String key = entry.getKey();\n                String value = entry.getValue();\n                longStr += (key + value);\n            }\n        }\n\n        // trim the string\n        longStr = (longStr + token).trim();\n\n        // if secret is null then there is no need of creating th signature since signature creating needs\n        // api secret\n        if (secret != null) {\n            try {\n                final String algorithm = \"HmacSHA256\";\n                SecretKeySpec signingKey = new SecretKeySpec(secret.getBytes(), algorithm);\n                Mac mac = Mac.getInstance(algorithm);\n                mac.init(signingKey);\n                byte[] rawHmac = mac.doFinal(longStr.getBytes());\n                String hexHmacString = Utility.bytesToHex(rawHmac);\n                byte[] hexHmacByte = hexHmacString.trim().toLowerCase().getBytes();\n                return Base64.encodeToString(hexHmacByte, Base64.NO_WRAP);\n            } catch (NoSuchAlgorithmException exception) {\n                AppLog.e(exception);\n                return null;\n            } catch (InvalidKeyException exception) {\n                AppLog.e(exception);\n                return null;\n            }\n        }\n        return null;\n    }\n}", "class_id": 0, "repo": "GAURAV-POSWAL/volleynet-android", "file": "volleynet/src/main/java/com/volleynet/utils/ApiSignature.java", "last_update_at": "2019-12-13T07:28:55+00:00", "question_id": "d2df215913367b4c103bb7a7ee7e8b8409022d69", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class ApiSignature {\n    /**\n     * API auth signature creation method using token and\n     * secret key. Uses Hash HMAC algorithm with SHA256\n     *\n     * @param token         Unique auth token provided to user\n     * @param secret        Secret key of the user\n     * @param parameters    Request parameters as key value pair\n     * @param url           Complete API url without query string or request params\n     * @param requestMethod HTTP request method for this request (GET|POST|PUT|DELETE|OPTIONS)\n     * @return base64 encoded signature\n     */\n    public static String createSignature(String token, String secret, HashMap<String, String> parameters, String url, String requestMethod) {\n        AppLog.d(\"API trace: X-Api-AuthToken : \" + token);\n        AppLog.d(\"API trace: Requested Url : \" + url + \"; Method Type : \" + requestMethod);\n        String longStr = requestMethod + '|' + url + \"\\n\";\n        // if mapData is present the sort it and add key value to the string\n        if (parameters != null) {\n            TreeMap<String, String> sortedData = new TreeMap<>(parameters);\n            for (Map.Entry<String, String> entry : sortedData.entrySet()) {\n                String key = entry.getKey();\n                String value = entry.getValue();\n                longStr += (key + value);\n            }\n        }\n        // trim the string\n        longStr = (longStr + token).trim();\n        // if secret is null then there is no need of creating th signature since signature creating needs\n        // api secret\n        if (secret != null) {\n            try {\n                final String algorithm = \"HmacSHA256\";\n                SecretKeySpec signingKey = new SecretKeySpec(secret.getBytes(), algorithm);\n                Mac mac = Mac.getInstance(algorithm);\n                mac.init(signingKey);\n                byte[] rawHmac = mac.doFinal(longStr.getBytes());\n                String hexHmacString = Utility.bytesToHex(rawHmac);\n                byte[] hexHmacByte = hexHmacString.trim().toLowerCase().getBytes();\n                return Base64.encodeToString(hexHmacByte, Base64.NO_WRAP);\n            } catch (NoSuchAlgorithmException exception) {\n                AppLog.e(exception);\n                return null;\n            } catch (InvalidKeyException exception) {\n                AppLog.e(exception);\n                return null;\n            }\n        }\n        return null;\n    }\n"]]}
{"hexsha": "0778168cf8ee1719cfd0e54a0c7d8fa22860b38a", "ext": "java", "lang": "Java", "content": "@ConfigurationProperties(prefix = \"fullstop.processor\")\npublic class CloudTrailProcessingLibraryProperties {\n\n    private Map<String, String> properties = new HashMap<String, String>();\n\n    public Map<String, String> getProperties() {\n        return properties;\n    }\n\n    public void setProperties(final Map<String, String> properties) {\n        this.properties = properties;\n    }\n\n    public Properties getAsProperties() {\n        final Properties properties = new Properties();\n        properties.putAll(getProperties());\n        return properties;\n    }\n\n}", "class_id": 0, "repo": "mrandi/fullstop", "file": "fullstop-core/fullstop-processing/src/main/java/org/zalando/stups/fullstop/CloudTrailProcessingLibraryProperties.java", "last_update_at": "2019-03-04T16:19:02+00:00", "question_id": "0778168cf8ee1719cfd0e54a0c7d8fa22860b38a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ConfigurationProperties(prefix = \"fullstop.processor\")\npublic class CloudTrailProcessingLibraryProperties {\n    private Map<String, String> properties = new HashMap<String, String>();\n    public Map<String, String> getProperties() {\n        return properties;\n    }\n    public void setProperties(final Map<String, String> properties) {\n        this.properties = properties;\n    }\n    public Properties getAsProperties() {\n        final Properties properties = new Properties();\n        properties.putAll(getProperties());\n        return properties;\n    }\n"]]}
{"hexsha": "6ba0928e1a5ce8e75455db388ae7d444e0e104c1", "ext": "java", "lang": "Java", "content": "class pattern9\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner kb=new Scanner(System.in);\n\t\tSystem.out.print(\"N=\");\n\t\tint n=kb.nextInt();\n\t\tint i,j,k;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(j=1;j<i;j++)\n\t\t\t{\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t}\n\t\t\tfor(k=i;k<=n;k++)\n\t\t\t{\n\t\t\t\tSystem.out.print(k);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\n\t\tfor(i=1;i<n;i++)\n\t\t{\n\t\t\tfor(j=n-i-1;j>0;j--)\n\t\t\t{\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t}\n\t\t\tfor(k=n-i;k<=n;k++)\n\t\t\t{\n\t\t\t\tSystem.out.print(k);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}", "class_id": 0, "repo": "PramodJana/java", "file": "pattern9.java", "last_update_at": "2019-01-21T16:13:24+00:00", "question_id": "6ba0928e1a5ce8e75455db388ae7d444e0e104c1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class pattern9\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner kb=new Scanner(System.in);\n\t\tSystem.out.print(\"N=\");\n\t\tint n=kb.nextInt();\n\t\tint i,j,k;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(j=1;j<i;j++)\n\t\t\t{\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t}\n\t\t\tfor(k=i;k<=n;k++)\n\t\t\t{\n\t\t\t\tSystem.out.print(k);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tfor(i=1;i<n;i++)\n\t\t{\n\t\t\tfor(j=n-i-1;j>0;j--)\n\t\t\t{\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t}\n\t\t\tfor(k=n-i;k<=n;k++)\n\t\t\t{\n\t\t\t\tSystem.out.print(k);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n"]]}
{"hexsha": "60e7f62e86111963763b8d0f2f3de50c8c0143d3", "ext": "java", "lang": "Java", "content": "@Entity\n@NamedQueries({\n         @NamedQuery(name = Customer.FIND_BY_LOGIN, query = \"SELECT c FROM Customer c WHERE c.login = :login\"),\n         @NamedQuery(name = Customer.FIND_BY_EMAIL, query = \"SELECT c FROM Customer c WHERE c.email = :email\"),\n         @NamedQuery(name = Customer.FIND_BY_LOGIN_PASSWORD, query = \"SELECT c FROM Customer c WHERE c.login = :login AND c.password = :password\"),\n         @NamedQuery(name = Customer.FIND_BY_UUID, query = \"SELECT c FROM Customer c WHERE c.uuid = :uuid\"),\n         @NamedQuery(name = Customer.FIND_ALL, query = \"SELECT c FROM Customer c\")\n})\n@XmlRootElement\npublic class Customer implements Serializable\n{\n\n   // ======================================\n   // = Attributes =\n   // ======================================\n\n   @Id\n   @GeneratedValue(strategy = GenerationType.AUTO)\n   @Column(name = \"id\", updatable = false, nullable = false)\n   private Long id;\n   @Version\n   @Column(name = \"version\")\n   private int version;\n\n   @Column(length = 50, name = \"first_name\", nullable = false)\n   @NotNull\n   @Size(min = 2, max = 50)\n   private String firstName;\n\n   @Column(length = 50, name = \"last_name\", nullable = false)\n   @NotNull\n   @Size(min = 2, max = 50)\n   private String lastName;\n\n   @Column\n   private String telephone;\n\n   @Column\n   @Email\n   private String email;\n\n   @Column(length = 10, nullable = false)\n   @Login\n   private String login;\n\n   @Column(length = 256, nullable = false)\n   @NotNull\n   @Size(min = 1, max = 256)\n   private String password;\n\n   @Column(length = 256)\n   @Size(min = 1, max = 256)\n   private String uuid;\n\n   private UserRole role;\n\n   @Column(name = \"date_of_birth\")\n   @Temporal(TemporalType.DATE)\n   @Past\n   private Date dateOfBirth;\n\n   @Transient\n   private Integer age;\n\n   @Embedded\n   @Valid\n   private Address homeAddress = new Address();\n\n   // ======================================\n   // = Constants =\n   // ======================================\n\n   public static final String FIND_BY_LOGIN = \"Customer.findByLogin\";\n   public static final String FIND_BY_LOGIN_PASSWORD = \"Customer.findByLoginAndPassword\";\n   public static final String FIND_ALL = \"Customer.findAll\";\n   public static final String FIND_BY_EMAIL = \"Customer.findByEmail\";\n   public static final String FIND_BY_UUID = \"Customer.findByUUID\";\n\n   // ======================================\n   // = Constructors =\n   // ======================================\n\n   public Customer()\n   {\n   }\n\n   public Customer(String firstName, String lastName, String login, String plainTextPassword, String email,\n            Address address)\n   {\n      this.firstName = firstName;\n      this.lastName = lastName;\n      this.login = login;\n      this.password = digestPassword(plainTextPassword);\n      this.email = email;\n      this.homeAddress = address;\n      this.dateOfBirth = new Date();\n   }\n\n   // ======================================\n   // = Lifecycle Methods =\n   // ======================================\n\n   /**\n    * This method calculates the age of the customer\n    */\n   @PostLoad\n   @PostPersist\n   @PostUpdate\n   public void calculateAge()\n   {\n      if (dateOfBirth == null)\n      {\n         age = null;\n         return;\n      }\n\n      Calendar birth = new GregorianCalendar();\n      birth.setTime(dateOfBirth);\n      Calendar now = new GregorianCalendar();\n      now.setTime(new Date());\n      int adjust = 0;\n      if (now.get(Calendar.DAY_OF_YEAR) - birth.get(Calendar.DAY_OF_YEAR) < 0)\n      {\n         adjust = -1;\n      }\n      age = now.get(Calendar.YEAR) - birth.get(Calendar.YEAR) + adjust;\n   }\n\n   @PrePersist\n   private void digestPassword()\n   {\n      password = digestPassword(password);\n   }\n\n   // ======================================\n   // = Business methods =\n   // ======================================\n\n   /**\n    * Digest password with <code>SHA-256</code> then encode it with Base64.\n    *\n    * @param plainTextPassword the password to digest and encode\n    * @return digested password\n    */\n   public String digestPassword(String plainTextPassword)\n   {\n      try\n      {\n         MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n         md.update(plainTextPassword.getBytes(\"UTF-8\"));\n         byte[] passwordDigest = md.digest();\n         return new BASE64Encoder().encode(passwordDigest);\n      }\n      catch (Exception e)\n      {\n         throw new RuntimeException(\"Exception encoding password\", e);\n      }\n   }\n\n   // ======================================\n   // = Getters & setters =\n   // ======================================\n\n   public Long getId()\n   {\n      return this.id;\n   }\n\n   public void setId(final Long id)\n   {\n      this.id = id;\n   }\n\n   public int getVersion()\n   {\n      return this.version;\n   }\n\n   public void setVersion(final int version)\n   {\n      this.version = version;\n   }\n\n   public String getLogin()\n   {\n      return login;\n   }\n\n   public void setLogin(String login)\n   {\n      this.login = login;\n   }\n\n   public UserRole getRole()\n   {\n      return role;\n   }\n\n   public void setRole(UserRole role)\n   {\n      this.role = role;\n   }\n\n   public String getUuid()\n   {\n      return uuid;\n   }\n\n   public void setUuid(String uuid)\n   {\n      this.uuid = uuid;\n   }\n\n   public String getPassword()\n   {\n      return password;\n   }\n\n   public void setPassword(String password)\n   {\n      this.password = password;\n   }\n\n   public String getFirstName()\n   {\n      return firstName;\n   }\n\n   public void setFirstName(String firstName)\n   {\n      this.firstName = firstName;\n   }\n\n   public String getLastName()\n   {\n      return lastName;\n   }\n\n   public void setLastName(String lastName)\n   {\n      this.lastName = lastName;\n   }\n\n   public String getFullName()\n   {\n      return firstName + \" \" + lastName;\n   }\n\n   public String getTelephone()\n   {\n      return telephone;\n   }\n\n   public void setTelephone(String telephone)\n   {\n      this.telephone = telephone;\n   }\n\n   public String getEmail()\n   {\n      return email;\n   }\n\n   public void setEmail(String email)\n   {\n      this.email = email;\n   }\n\n   public Date getDateOfBirth()\n   {\n      return dateOfBirth;\n   }\n\n   public void setDateOfBirth(Date dateOfBirth)\n   {\n      this.dateOfBirth = dateOfBirth;\n   }\n\n   public Integer getAge()\n   {\n      return age;\n   }\n\n   public Address getHomeAddress()\n   {\n      return homeAddress;\n   }\n\n   public void setHomeAddress(Address homeAddress)\n   {\n      this.homeAddress = homeAddress;\n   }\n\n   // ======================================\n   // = Methods hash, equals, toString =\n   // ======================================\n\n   @Override\n   public final boolean equals(Object o)\n   {\n      if (this == o)\n         return true;\n      if (!(o instanceof Customer))\n         return false;\n      Customer customer = (Customer) o;\n      return Objects.equals(login, customer.login);\n   }\n\n   @Override\n   public final int hashCode()\n   {\n      return Objects.hash(login);\n   }\n\n   @Override\n   public String toString()\n   {\n      return firstName + ' ' + lastName + \" (\" + login + \")\";\n   }\n}", "class_id": 0, "repo": "andxu/wildfly-petstore-quickstart", "file": "src/main/java/org/agoncal/application/petstore/model/Customer.java", "last_update_at": "2019-06-06T13:32:59+00:00", "question_id": "60e7f62e86111963763b8d0f2f3de50c8c0143d3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Entity\n@NamedQueries({\n         @NamedQuery(name = Customer.FIND_BY_LOGIN, query = \"SELECT c FROM Customer c WHERE c.login = :login\"),\n         @NamedQuery(name = Customer.FIND_BY_EMAIL, query = \"SELECT c FROM Customer c WHERE c.email = :email\"),\n         @NamedQuery(name = Customer.FIND_BY_LOGIN_PASSWORD, query = \"SELECT c FROM Customer c WHERE c.login = :login AND c.password = :password\"),\n         @NamedQuery(name = Customer.FIND_BY_UUID, query = \"SELECT c FROM Customer c WHERE c.uuid = :uuid\"),\n         @NamedQuery(name = Customer.FIND_ALL, query = \"SELECT c FROM Customer c\")\n})\n@XmlRootElement\npublic class Customer implements Serializable\n{\n   // ======================================\n   // = Attributes =\n   // ======================================\n   @Id\n   @GeneratedValue(strategy = GenerationType.AUTO)\n   @Column(name = \"id\", updatable = false, nullable = false)\n   private Long id;\n   @Version\n   @Column(name = \"version\")\n   private int version;\n   @Column(length = 50, name = \"first_name\", nullable = false)\n   @NotNull\n   @Size(min = 2, max = 50)\n   private String firstName;\n   @Column(length = 50, name = \"last_name\", nullable = false)\n   @NotNull\n   @Size(min = 2, max = 50)\n   private String lastName;\n   @Column\n   private String telephone;\n   @Column\n   @Email\n   private String email;\n   @Column(length = 10, nullable = false)\n   @Login\n   private String login;\n   @Column(length = 256, nullable = false)\n   @NotNull\n   @Size(min = 1, max = 256)\n   private String password;\n   @Column(length = 256)\n   @Size(min = 1, max = 256)\n   private String uuid;\n   private UserRole role;\n   @Column(name = \"date_of_birth\")\n   @Temporal(TemporalType.DATE)\n   @Past\n   private Date dateOfBirth;\n   @Transient\n   private Integer age;\n   @Embedded\n   @Valid\n   private Address homeAddress = new Address();\n   // ======================================\n   // = Constants =\n   // ======================================\n   public static final String FIND_BY_LOGIN = \"Customer.findByLogin\";\n   public static final String FIND_BY_LOGIN_PASSWORD = \"Customer.findByLoginAndPassword\";\n   public static final String FIND_ALL = \"Customer.findAll\";\n   public static final String FIND_BY_EMAIL = \"Customer.findByEmail\";\n   public static final String FIND_BY_UUID = \"Customer.findByUUID\";\n   // ======================================\n   // = Constructors =\n   // ======================================\n   public Customer()\n   {\n   }\n   public Customer(String firstName, String lastName, String login, String plainTextPassword, String email,\n            Address address)\n   {\n      this.firstName = firstName;\n      this.lastName = lastName;\n      this.login = login;\n      this.password = digestPassword(plainTextPassword);\n      this.email = email;\n      this.homeAddress = address;\n      this.dateOfBirth = new Date();\n   }\n   // ======================================\n   // = Lifecycle Methods =\n   // ======================================\n   /**\n    * This method calculates the age of the customer\n    */\n   @PostLoad\n   @PostPersist\n   @PostUpdate\n   public void calculateAge()\n   {\n      if (dateOfBirth == null)\n      {\n         age = null;\n         return;\n      }\n      Calendar birth = new GregorianCalendar();\n      birth.setTime(dateOfBirth);\n      Calendar now = new GregorianCalendar();\n      now.setTime(new Date());\n      int adjust = 0;\n      if (now.get(Calendar.DAY_OF_YEAR) - birth.get(Calendar.DAY_OF_YEAR) < 0)\n      {\n         adjust = -1;\n      }\n      age = now.get(Calendar.YEAR) - birth.get(Calendar.YEAR) + adjust;\n   }\n   @PrePersist\n   private void digestPassword()\n   {\n      password = digestPassword(password);\n   }\n   // ======================================\n   // = Business methods =\n   // ======================================\n   /**\n    * Digest password with <code>SHA-256</code> then encode it with Base64.\n    *\n    * @param plainTextPassword the password to digest and encode\n    * @return digested password\n    */\n   public String digestPassword(String plainTextPassword)\n   {\n      try\n      {\n         MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n         md.update(plainTextPassword.getBytes(\"UTF-8\"));\n         byte[] passwordDigest = md.digest();\n         return new BASE64Encoder().encode(passwordDigest);\n      }\n      catch (Exception e)\n      {\n         throw new RuntimeException(\"Exception encoding password\", e);\n      }\n   }\n   // ======================================\n   // = Getters & setters =\n   // ======================================\n   public Long getId()\n   {\n      return this.id;\n   }\n   public void setId(final Long id)\n   {\n      this.id = id;\n   }\n   public int getVersion()\n   {\n      return this.version;\n   }\n   public void setVersion(final int version)\n   {\n      this.version = version;\n   }\n   public String getLogin()\n   {\n      return login;\n   }\n   public void setLogin(String login)\n   {\n      this.login = login;\n   }\n   public UserRole getRole()\n   {\n      return role;\n   }\n   public void setRole(UserRole role)\n   {\n      this.role = role;\n   }\n   public String getUuid()\n   {\n      return uuid;\n   }\n   public void setUuid(String uuid)\n   {\n      this.uuid = uuid;\n   }\n   public String getPassword()\n   {\n      return password;\n   }\n   public void setPassword(String password)\n   {\n      this.password = password;\n   }\n   public String getFirstName()\n   {\n      return firstName;\n   }\n   public void setFirstName(String firstName)\n   {\n      this.firstName = firstName;\n   }\n   public String getLastName()\n   {\n      return lastName;\n   }\n   public void setLastName(String lastName)\n   {\n      this.lastName = lastName;\n   }\n   public String getFullName()\n   {\n      return firstName + \" \" + lastName;\n   }\n   public String getTelephone()\n   {\n      return telephone;\n   }\n   public void setTelephone(String telephone)\n   {\n      this.telephone = telephone;\n   }\n   public String getEmail()\n   {\n      return email;\n   }\n   public void setEmail(String email)\n   {\n      this.email = email;\n   }\n   public Date getDateOfBirth()\n   {\n      return dateOfBirth;\n   }\n   public void setDateOfBirth(Date dateOfBirth)\n   {\n      this.dateOfBirth = dateOfBirth;\n   }\n   public Integer getAge()\n   {\n      return age;\n   }\n   public Address getHomeAddress()\n   {\n      return homeAddress;\n   }\n   public void setHomeAddress(Address homeAddress)\n   {\n      this.homeAddress = homeAddress;\n   }\n   // ======================================\n   // = Methods hash, equals, toString =\n   // ======================================\n   @Override\n   public final boolean equals(Object o)\n   {\n      if (this == o)\n         return true;\n      if (!(o instanceof Customer))\n         return false;\n      Customer customer = (Customer) o;\n      return Objects.equals(login, customer.login);\n   }\n   @Override\n   public final int hashCode()\n   {\n      return Objects.hash(login);\n   }\n   @Override\n   public String toString()\n   {\n      return firstName + ' ' + lastName + \" (\" + login + \")\";\n   }\n"]]}
{"hexsha": "fc1939f013d8e79b6c3887a37823ff5a31eb1d79", "ext": "java", "lang": "Java", "content": "public class LambdaHandlerTest extends AbstractRequestHandler<UserRequestTest, UserResponseTest> {\n\n    @Override\n    public void before(Context context) throws HttpException {\n        addResponseHeader(\"Access-Control-Allow-Origin\", \"*\");\n    }\n\n    @Override\n    public UserResponseTest execute(UserRequestTest input, Context context) throws HttpException {\n                            \n        UserResponseTest response = new UserResponseTest();\n        response.setId(UUID.randomUUID().toString());\n        response.setName(input.getName());\n        response.setAddress(input.getAddress());\n        \n        return response;\n    }\n\n}", "class_id": 0, "repo": "nishantverma160380/LambdaValidation", "file": "src/test/java/br/com/tdsis/lambda/forest/http/handler/LambdaHandlerTest.java", "last_update_at": "2019-10-08T15:23:01+00:00", "question_id": "fc1939f013d8e79b6c3887a37823ff5a31eb1d79", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LambdaHandlerTest extends AbstractRequestHandler<UserRequestTest, UserResponseTest> {\n    @Override\n    public void before(Context context) throws HttpException {\n        addResponseHeader(\"Access-Control-Allow-Origin\", \"*\");\n    }\n    @Override\n    public UserResponseTest execute(UserRequestTest input, Context context) throws HttpException {\n        UserResponseTest response = new UserResponseTest();\n        response.setId(UUID.randomUUID().toString());\n        response.setName(input.getName());\n        response.setAddress(input.getAddress());\n        return response;\n    }\n"]]}
{"hexsha": "a0c31dbd4eb4ecd3c4e8ed833c6b3df064333380", "ext": "java", "lang": "Java", "content": "public class TestUtil {\n\n    public static Operand operand(String key, String value) {\n        Operand operand = new Operand();\n        Field field = new Field();\n        field.setKey(key);\n        field.setValue(value);\n        operand.setField(field);\n        return operand;\n    }\n\n    public static Dispatcher dispatcher(String endpoint, Dispatcher.Type type) {\n        Dispatcher dispatcher = new Dispatcher();\n        dispatcher.setEndpoint(endpoint);\n        dispatcher.setType(type);\n        return dispatcher;\n    }\n\n    public static User user(String id) {\n        User user = new User();\n        user.setId(id);\n        return user;\n    }\n}", "class_id": 0, "repo": "ExpediaDotCom/alert-manager", "file": "service/src/test/java/com/expedia/alertmanager/service/web/TestUtil.java", "last_update_at": "2019-03-06T11:19:56+00:00", "question_id": "a0c31dbd4eb4ecd3c4e8ed833c6b3df064333380", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestUtil {\n    public static Operand operand(String key, String value) {\n        Operand operand = new Operand();\n        Field field = new Field();\n        field.setKey(key);\n        field.setValue(value);\n        operand.setField(field);\n        return operand;\n    }\n    public static Dispatcher dispatcher(String endpoint, Dispatcher.Type type) {\n        Dispatcher dispatcher = new Dispatcher();\n        dispatcher.setEndpoint(endpoint);\n        dispatcher.setType(type);\n        return dispatcher;\n    }\n    public static User user(String id) {\n        User user = new User();\n        user.setId(id);\n        return user;\n    }\n"]]}
{"hexsha": "b1df6f12d984dc0151a1b348b24c52dc7ba0cf2f", "ext": "java", "lang": "Java", "content": "public class Problem1472 {\n    static class BrowserHistory {\n        private List<String> history = new ArrayList<>();\n        private int index;\n\n        public BrowserHistory(String homepage) {\n            history.add(homepage);\n        }\n\n        public void visit(String url) {\n            index++;\n            if (index < history.size()) {\n                history = history.subList(0, index);\n            }\n            history.add(url);\n        }\n\n        public String back(int steps) {\n            index -= steps;\n            if (index < 0) {\n                index = 0;\n            }\n            return history.get(index);\n        }\n\n        public String forward(int steps) {\n            index += steps;\n            if (index >= history.size()) {\n                index = history.size() - 1;\n            }\n            return history.get(index);\n        }\n    }\n}", "class_id": 0, "repo": "fredyw/leetcode", "file": "src/main/java/leetcode/Problem1472.java", "last_update_at": "2019-07-07T02:18:28+00:00", "question_id": "b1df6f12d984dc0151a1b348b24c52dc7ba0cf2f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Problem1472 {\n    static class BrowserHistory {\n        private List<String> history = new ArrayList<>();\n        private int index;\n        public BrowserHistory(String homepage) {\n            history.add(homepage);\n        }\n        public void visit(String url) {\n            index++;\n            if (index < history.size()) {\n                history = history.subList(0, index);\n            }\n            history.add(url);\n        }\n        public String back(int steps) {\n            index -= steps;\n            if (index < 0) {\n                index = 0;\n            }\n            return history.get(index);\n        }\n        public String forward(int steps) {\n            index += steps;\n            if (index >= history.size()) {\n                index = history.size() - 1;\n            }\n            return history.get(index);\n        }\n    }\n"]]}
{"hexsha": "8e05e5d71d31cef97b2bfa5ed7703f94687f8e5d", "ext": "java", "lang": "Java", "content": "public class SessionManager {\n  // Shared Preferences\n  SharedPreferences sharedPreferences;\n\n  // Editor for Shared preferences\n  Editor editor;\n\n  // Context\n  Context _context;\n\n  // Shared preferences mode\n  int PRIVATE_MODE = 0;\n\n  String prefName;\n\n  public SessionManager(Context context, String PREF_NAME){\n    this._context = context;\n    this.prefName = PREF_NAME;\n    sharedPreferences = _context.getSharedPreferences(PREF_NAME, PRIVATE_MODE);\n    editor = sharedPreferences.edit();\n  }\n\n  public void createLoginSession(String username, String password){\n\n    if (prefName.equals(\"Teacher\")){\n\n      // Storing name in sharedPreferences\n      editor.putString(\"teacher_username\", username);\n\n      // Storing password in sharedPreferences\n      editor.putString(\"teacher_password\", password);\n\n    }\n\n    else {\n\n      editor.putString(\"student_username\", username);\n\n      // Storing password in sharedPreferences\n      editor.putString(\"student_password\", password);\n\n    }\n\n    // commit changes\n    editor.commit();\n  }\n}", "class_id": 0, "repo": "DhruvBhagadia/QueueingApp", "file": "app/src/main/java/com/djunicode/queuingapp/SessionManagement/SessionManager.java", "last_update_at": "2019-10-30T15:12:20+00:00", "question_id": "8e05e5d71d31cef97b2bfa5ed7703f94687f8e5d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SessionManager {\n  // Shared Preferences\n  SharedPreferences sharedPreferences;\n  // Editor for Shared preferences\n  Editor editor;\n  // Context\n  Context _context;\n  // Shared preferences mode\n  int PRIVATE_MODE = 0;\n  String prefName;\n  public SessionManager(Context context, String PREF_NAME){\n    this._context = context;\n    this.prefName = PREF_NAME;\n    sharedPreferences = _context.getSharedPreferences(PREF_NAME, PRIVATE_MODE);\n    editor = sharedPreferences.edit();\n  }\n  public void createLoginSession(String username, String password){\n    if (prefName.equals(\"Teacher\")){\n      // Storing name in sharedPreferences\n      editor.putString(\"teacher_username\", username);\n      // Storing password in sharedPreferences\n      editor.putString(\"teacher_password\", password);\n    }\n    else {\n      editor.putString(\"student_username\", username);\n      // Storing password in sharedPreferences\n      editor.putString(\"student_password\", password);\n    }\n    // commit changes\n    editor.commit();\n  }\n"]]}
{"hexsha": "90c0281ddbeca043629e879db96eb0b901182f6a", "ext": "java", "lang": "Java", "content": "public class BitbucketCloudApi extends BitbucketApi {\n    private final String baseUrl;\n\n    protected BitbucketCloudApi(String apiUrl, StandardUsernamePasswordCredentials credentials) {\n        super(apiUrl, credentials);\n        this.baseUrl = this.apiUrl+\"api/2.0/\";\n    }\n\n    @Nonnull\n    @Override\n    public BbUser getUser() {\n        try {\n            InputStream inputStream = request.get(baseUrl+\"user\").getContent();\n            return om.readValue(inputStream, BbCloudUser.class);\n        } catch (IOException e) {\n            throw handleException(e);\n        }\n    }\n\n    @Nonnull\n    @Override\n    public BbUser getUser(@Nonnull String userName) {\n        try {\n            InputStream inputStream = request.get(String.format(\"%s/%s\",baseUrl+\"users\", userName)).getContent();\n            return om.readValue(inputStream, BbCloudUser.class);\n        } catch (IOException e) {\n            throw handleException(e);\n        }\n    }\n\n    @Nonnull\n    @Override\n    public BbPage<BbOrg> getOrgs(int pageNumber, int pageSize) {\n        try {\n            /*\n             * Bitbucket teams API work with three roles: admin, contributor, member\n             *\n             * We default to 'contributor' role, because we only want to only list teams that have at least one repo\n             * where user has WRITE access.\n             *\n             * see: https://developer.atlassian.com/bitbucket/api/2/reference/resource/teams\n             */\n            if(pageNumber <= 0){\n                pageNumber = 1;\n            }\n\n            if(pageSize <=0){\n                pageSize = PagedResponse.DEFAULT_LIMIT;\n            }\n            InputStream inputStream = request.get(String.format(\"%s&page=%s&pagelen=%s\",baseUrl+\"teams/?role=contributor\",\n                    pageNumber,pageSize)).getContent();\n            BbPage<BbOrg> page =  om.readValue(inputStream, new TypeReference<BbCloudPage<BbCloudTeam>>(){});\n            if(pageNumber == 1){ //add user org as the first org on first page\n                BbUser user = getUser();\n                if(page instanceof BbCloudPage) {\n                    List<BbOrg> teams = new ArrayList<>();\n                    teams.add(new BbCloudTeam(user.getSlug(), user.getDisplayName(), user.getAvatar()));\n                    int newSize = page.getSize() + 1;\n                    int newPageLength = page.getLimit();\n                    if (page.getSize() > page.getLimit()) {\n                        newPageLength++;\n                    }\n                    teams.addAll(page.getValues());\n                    return new BbCloudPage<>(newPageLength, pageNumber, newSize, ((BbCloudPage) page).getNext(), teams);\n                }\n            }\n            return page;\n        } catch (IOException e) {\n            throw handleException(e);\n        }\n    }\n\n    @Nonnull\n    @Override\n    public BbOrg getOrg(@Nonnull String orgName) {\n        try {\n            BbUser user = getUser();\n            // If user org, get user and return BbCloudTeam model\n            if(orgName.equalsIgnoreCase(user.getSlug())){\n                return new BbCloudTeam(user.getSlug(), user.getDisplayName(), user.getAvatar());\n            }\n            InputStream inputStream = request.get(String.format(\"%s/%s\",baseUrl+\"teams\", orgName)).getContent();\n            return om.readValue(inputStream, BbCloudTeam.class);\n        } catch (IOException e) {\n            throw handleException(e);\n        }\n    }\n\n    @Nonnull\n    @Override\n    public BbRepo getRepo(@Nonnull String orgId, String repoSlug) {\n        try {\n            InputStream inputStream = request.get(String.format(\"%s/%s\",baseUrl+\"repositories/\"+orgId, repoSlug))\n                    .getContent();\n            return om.readValue(inputStream, BbCloudRepo.class);\n        } catch (IOException e) {\n            throw handleException(e);\n        }\n    }\n\n    @Nonnull\n    @Override\n    public BbPage<BbRepo> getRepos(@Nonnull String orgId, int pageNumber, int pageSize) {\n        try {\n            InputStream inputStream = request.get(String.format(\"%s?page=%s&limit=%s\",baseUrl+\"repositories/\"+orgId,\n                    pageNumber, pageSize)).getContent();\n            return om.readValue(inputStream, new TypeReference<BbCloudPage<BbCloudRepo>>(){});\n        } catch (IOException e) {\n            throw handleException(e);\n        }\n    }\n\n    @Nonnull\n    @Override\n    public String getContent(@Nonnull String orgId, @Nonnull String repoSlug, @Nonnull String path, @Nonnull String commitId) {\n        try {\n            InputStream inputStream = request.get(String.format(\"%s/%s/%s/src/%s/%s\",baseUrl+\"repositories\",orgId,\n                    repoSlug, commitId, path)).getContent();\n            return IOUtils.toString(inputStream);\n        } catch (IOException e) {\n            throw handleException(e);\n        }\n    }\n\n    @Nonnull\n    @Override\n    public BbSaveContentResponse saveContent(@Nonnull String orgId,\n                                             @Nonnull String repoSlug,\n                                             @Nonnull String path,\n                                             @Nonnull String content,\n                                             @Nonnull String commitMessage,\n                                             @Nullable String branch,\n                                             @Nullable String sourceBranch,\n                                             @Nullable String commitId) {\n        MultipartEntityBuilder builder = MultipartEntityBuilder.create()\n                    .addTextBody(path, content)\n                .addTextBody(\"message\", commitMessage);\n\n        if(isNotBlank(branch)){\n            builder.addTextBody(\"branch\", branch);\n        }\n\n        if(isNotBlank(commitId)){\n            builder.addTextBody(\"parents\", commitId);\n        }\n        HttpEntity entity = builder.build();\n        HttpResponse response = request.post(String.format(\"%s/%s/%s/src\",baseUrl+\"repositories\",orgId,repoSlug), entity);\n        int status = response.getStatus();\n        if(status == 201){\n            String location = response.getHeader(\"Location\");\n            if(location == null){\n                throw new ServiceException.UnexpectedErrorException(\"Location header is missing on save content response\");\n            }\n            String cid = location.substring(location.lastIndexOf(\"/\") + 1);\n            return new BbCloudSaveContentResponse(cid);\n        }else{\n            throw new ServiceException.UnexpectedErrorException(\"Failed to save file: \"+path+\" server returned status: \"+status);\n        }\n    }\n\n    @Override\n    public boolean fileExists(@Nonnull String orgId, @Nonnull String repoSlug, @Nonnull String path,  @Nonnull String branch) {\n        throw new NotImplementedException(\"Not implemented\");\n    }\n\n    @Override\n    public BbBranch getBranch(@Nonnull String orgId, @Nonnull String repoSlug, @Nonnull String branch) {\n        try {\n            HttpResponse response = request.get(String.format(\"%s/%s/refs/branches/%s?fields=target.hash,target.repository.mainbranch.name,target.repository.*,target.repository.owner.*,target.repository.owner.links.avatar.href,name\",\n                    baseUrl+\"repositories/\"+orgId,\n                    repoSlug,\n                    branch));\n            if(response.getStatus() == 404){\n                return null;\n            }\n            return om.readValue(response.getContent(), BbCloudBranch.class);\n        } catch (Exception e) {\n            throw handleException(e);\n        }\n    }\n\n    @Nonnull\n    @Override\n    public BbBranch createBranch(@Nonnull String orgId, @Nonnull String repoSlug, Map<String, String> payload) {\n        throw new NotImplementedException(\"Not implemented\");\n    }\n\n    @Override\n    public BbBranch getDefaultBranch(@Nonnull String orgId, @Nonnull String repoSlug) {\n        try {\n            InputStream inputStream = request.get(String.format(\"%s/%s/?fields=mainbranch.*,mainbranch.target.*,mainbranch.target.repository.*,mainbranch.target.repository.mainbranch.name,mainbranch.target.repository.owner.*,mainbranch.target.repository.owner.links.avatar.*\",\n                    baseUrl+\"repositories/\"+orgId,\n                    repoSlug))\n                    .getContent();\n            Map<String, BbCloudBranch> resp = om.readValue(inputStream, new TypeReference<Map<String, BbCloudBranch>>() {});\n            return resp.get(\"mainbranch\");\n        } catch (IOException e) {\n            throw handleException(e);\n        }\n\n    }\n\n    @Override\n    public boolean isEmptyRepo(@Nonnull String orgId, @Nonnull String repoSlug) {\n        throw new NotImplementedException(\"Not implemented\");\n    }\n\n    @Extension\n    public static class BitbucketCloudApiFactory extends BitbucketApiFactory {\n        @Override\n        public boolean handles(@Nonnull String scmId) {\n            return scmId.equals(BitbucketCloudScm.ID);\n        }\n\n        @Nonnull\n        @Override\n        public BitbucketApi create(@Nonnull String apiUrl, @Nonnull StandardUsernamePasswordCredentials credentials) {\n            return new BitbucketCloudApi(apiUrl, credentials);\n        }\n    }\n\n}", "class_id": 0, "repo": "Cellule/blueocean-plugin", "file": "blueocean-bitbucket-pipeline/src/main/java/io/jenkins/blueocean/blueocean_bitbucket_pipeline/cloud/BitbucketCloudApi.java", "last_update_at": "2019-02-25T05:14:35+00:00", "question_id": "90c0281ddbeca043629e879db96eb0b901182f6a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BitbucketCloudApi extends BitbucketApi {\n    private final String baseUrl;\n    protected BitbucketCloudApi(String apiUrl, StandardUsernamePasswordCredentials credentials) {\n        super(apiUrl, credentials);\n        this.baseUrl = this.apiUrl+\"api/2.0/\";\n    }\n    @Nonnull\n    @Override\n    public BbUser getUser() {\n        try {\n            InputStream inputStream = request.get(baseUrl+\"user\").getContent();\n            return om.readValue(inputStream, BbCloudUser.class);\n        } catch (IOException e) {\n            throw handleException(e);\n        }\n    }\n    @Nonnull\n    @Override\n    public BbUser getUser(@Nonnull String userName) {\n        try {\n            InputStream inputStream = request.get(String.format(\"%s/%s\",baseUrl+\"users\", userName)).getContent();\n            return om.readValue(inputStream, BbCloudUser.class);\n        } catch (IOException e) {\n            throw handleException(e);\n        }\n    }\n    @Nonnull\n    @Override\n    public BbPage<BbOrg> getOrgs(int pageNumber, int pageSize) {\n        try {\n            /*\n             * Bitbucket teams API work with three roles: admin, contributor, member\n             *\n             * We default to 'contributor' role, because we only want to only list teams that have at least one repo\n             * where user has WRITE access.\n             *\n             * see: https://developer.atlassian.com/bitbucket/api/2/reference/resource/teams\n             */\n            if(pageNumber <= 0){\n                pageNumber = 1;\n            }\n            if(pageSize <=0){\n                pageSize = PagedResponse.DEFAULT_LIMIT;\n            }\n            InputStream inputStream = request.get(String.format(\"%s&page=%s&pagelen=%s\",baseUrl+\"teams/?role=contributor\",\n                    pageNumber,pageSize)).getContent();\n            BbPage<BbOrg> page =  om.readValue(inputStream, new TypeReference<BbCloudPage<BbCloudTeam>>(){});\n            if(pageNumber == 1){ //add user org as the first org on first page\n                BbUser user = getUser();\n                if(page instanceof BbCloudPage) {\n                    List<BbOrg> teams = new ArrayList<>();\n                    teams.add(new BbCloudTeam(user.getSlug(), user.getDisplayName(), user.getAvatar()));\n                    int newSize = page.getSize() + 1;\n                    int newPageLength = page.getLimit();\n                    if (page.getSize() > page.getLimit()) {\n                        newPageLength++;\n                    }\n                    teams.addAll(page.getValues());\n                    return new BbCloudPage<>(newPageLength, pageNumber, newSize, ((BbCloudPage) page).getNext(), teams);\n                }\n            }\n            return page;\n        } catch (IOException e) {\n            throw handleException(e);\n        }\n    }\n    @Nonnull\n    @Override\n    public BbOrg getOrg(@Nonnull String orgName) {\n        try {\n            BbUser user = getUser();\n            // If user org, get user and return BbCloudTeam model\n            if(orgName.equalsIgnoreCase(user.getSlug())){\n                return new BbCloudTeam(user.getSlug(), user.getDisplayName(), user.getAvatar());\n            }\n            InputStream inputStream = request.get(String.format(\"%s/%s\",baseUrl+\"teams\", orgName)).getContent();\n            return om.readValue(inputStream, BbCloudTeam.class);\n        } catch (IOException e) {\n            throw handleException(e);\n        }\n    }\n    @Nonnull\n    @Override\n    public BbRepo getRepo(@Nonnull String orgId, String repoSlug) {\n        try {\n            InputStream inputStream = request.get(String.format(\"%s/%s\",baseUrl+\"repositories/\"+orgId, repoSlug))\n                    .getContent();\n            return om.readValue(inputStream, BbCloudRepo.class);\n        } catch (IOException e) {\n            throw handleException(e);\n        }\n    }\n    @Nonnull\n    @Override\n    public BbPage<BbRepo> getRepos(@Nonnull String orgId, int pageNumber, int pageSize) {\n        try {\n            InputStream inputStream = request.get(String.format(\"%s?page=%s&limit=%s\",baseUrl+\"repositories/\"+orgId,\n                    pageNumber, pageSize)).getContent();\n            return om.readValue(inputStream, new TypeReference<BbCloudPage<BbCloudRepo>>(){});\n        } catch (IOException e) {\n            throw handleException(e);\n        }\n    }\n    @Nonnull\n    @Override\n    public String getContent(@Nonnull String orgId, @Nonnull String repoSlug, @Nonnull String path, @Nonnull String commitId) {\n        try {\n            InputStream inputStream = request.get(String.format(\"%s/%s/%s/src/%s/%s\",baseUrl+\"repositories\",orgId,\n                    repoSlug, commitId, path)).getContent();\n            return IOUtils.toString(inputStream);\n        } catch (IOException e) {\n            throw handleException(e);\n        }\n    }\n    @Nonnull\n    @Override\n    public BbSaveContentResponse saveContent(@Nonnull String orgId,\n                                             @Nonnull String repoSlug,\n                                             @Nonnull String path,\n                                             @Nonnull String content,\n                                             @Nonnull String commitMessage,\n                                             @Nullable String branch,\n                                             @Nullable String sourceBranch,\n                                             @Nullable String commitId) {\n        MultipartEntityBuilder builder = MultipartEntityBuilder.create()\n                    .addTextBody(path, content)\n                .addTextBody(\"message\", commitMessage);\n        if(isNotBlank(branch)){\n            builder.addTextBody(\"branch\", branch);\n        }\n        if(isNotBlank(commitId)){\n            builder.addTextBody(\"parents\", commitId);\n        }\n        HttpEntity entity = builder.build();\n        HttpResponse response = request.post(String.format(\"%s/%s/%s/src\",baseUrl+\"repositories\",orgId,repoSlug), entity);\n        int status = response.getStatus();\n        if(status == 201){\n            String location = response.getHeader(\"Location\");\n            if(location == null){\n                throw new ServiceException.UnexpectedErrorException(\"Location header is missing on save content response\");\n            }\n            String cid = location.substring(location.lastIndexOf(\"/\") + 1);\n            return new BbCloudSaveContentResponse(cid);\n        }else{\n            throw new ServiceException.UnexpectedErrorException(\"Failed to save file: \"+path+\" server returned status: \"+status);\n        }\n    }\n    @Override\n    public boolean fileExists(@Nonnull String orgId, @Nonnull String repoSlug, @Nonnull String path,  @Nonnull String branch) {\n        throw new NotImplementedException(\"Not implemented\");\n    }\n    @Override\n    public BbBranch getBranch(@Nonnull String orgId, @Nonnull String repoSlug, @Nonnull String branch) {\n        try {\n            HttpResponse response = request.get(String.format(\"%s/%s/refs/branches/%s?fields=target.hash,target.repository.mainbranch.name,target.repository.*,target.repository.owner.*,target.repository.owner.links.avatar.href,name\",\n                    baseUrl+\"repositories/\"+orgId,\n                    repoSlug,\n                    branch));\n            if(response.getStatus() == 404){\n                return null;\n            }\n            return om.readValue(response.getContent(), BbCloudBranch.class);\n        } catch (Exception e) {\n            throw handleException(e);\n        }\n    }\n    @Nonnull\n    @Override\n    public BbBranch createBranch(@Nonnull String orgId, @Nonnull String repoSlug, Map<String, String> payload) {\n        throw new NotImplementedException(\"Not implemented\");\n    }\n    @Override\n    public BbBranch getDefaultBranch(@Nonnull String orgId, @Nonnull String repoSlug) {\n        try {\n            InputStream inputStream = request.get(String.format(\"%s/%s/?fields=mainbranch.*,mainbranch.target.*,mainbranch.target.repository.*,mainbranch.target.repository.mainbranch.name,mainbranch.target.repository.owner.*,mainbranch.target.repository.owner.links.avatar.*\",\n                    baseUrl+\"repositories/\"+orgId,\n                    repoSlug))\n                    .getContent();\n            Map<String, BbCloudBranch> resp = om.readValue(inputStream, new TypeReference<Map<String, BbCloudBranch>>() {});\n            return resp.get(\"mainbranch\");\n        } catch (IOException e) {\n            throw handleException(e);\n        }\n    }\n    @Override\n    public boolean isEmptyRepo(@Nonnull String orgId, @Nonnull String repoSlug) {\n        throw new NotImplementedException(\"Not implemented\");\n    }\n    @Extension\n    public static class BitbucketCloudApiFactory extends BitbucketApiFactory {\n        @Override\n        public boolean handles(@Nonnull String scmId) {\n            return scmId.equals(BitbucketCloudScm.ID);\n        }\n        @Nonnull\n        @Override\n        public BitbucketApi create(@Nonnull String apiUrl, @Nonnull StandardUsernamePasswordCredentials credentials) {\n            return new BitbucketCloudApi(apiUrl, credentials);\n        }\n    }\n"]]}
{"hexsha": "71dc8679e7c5a049927d447832b0eb8e18fa9953", "ext": "java", "lang": "Java", "content": "public final class WebUtils {\n\n    private WebUtils() {}\n\n    public static void clearCookies(@NonNull Context context) {\n        CookieManager c = CookieManager.getInstance();\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            c.removeAllCookies(null);\n        } else {\n            //noinspection deprecation\n            CookieSyncManager.createInstance(context);\n            //noinspection deprecation\n            c.removeAllCookie();\n        }\n    }\n\n    public static void clearWebStorage() {\n        WebStorage.getInstance().deleteAllData();\n    }\n\n    public static void clearHistory(@NonNull Context context,\n                                    @NonNull HistoryRepository historyRepository,\n                                    @NonNull Scheduler databaseScheduler) {\n        historyRepository.deleteHistory()\n            .subscribeOn(databaseScheduler)\n            .subscribe();\n        WebViewDatabase webViewDatabase = WebViewDatabase.getInstance(context);\n        webViewDatabase.clearFormData();\n        webViewDatabase.clearHttpAuthUsernamePassword();\n        Utils.trimCache(context);\n    }\n\n    public static void clearCache(@Nullable ConstraintWebLayout view) {\n        if (view == null) return;\n        view.clearCache(true);\n    }\n\n}", "class_id": 0, "repo": "androidovshchik/ConstraintBrowser", "file": "app/src/main/java/acr/browser/lightning/utils/WebUtils.java", "last_update_at": "2019-06-08T08:36:05+00:00", "question_id": "71dc8679e7c5a049927d447832b0eb8e18fa9953", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class WebUtils {\n    private WebUtils() {}\n    public static void clearCookies(@NonNull Context context) {\n        CookieManager c = CookieManager.getInstance();\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            c.removeAllCookies(null);\n        } else {\n            //noinspection deprecation\n            CookieSyncManager.createInstance(context);\n            //noinspection deprecation\n            c.removeAllCookie();\n        }\n    }\n    public static void clearWebStorage() {\n        WebStorage.getInstance().deleteAllData();\n    }\n    public static void clearHistory(@NonNull Context context,\n                                    @NonNull HistoryRepository historyRepository,\n                                    @NonNull Scheduler databaseScheduler) {\n        historyRepository.deleteHistory()\n            .subscribeOn(databaseScheduler)\n            .subscribe();\n        WebViewDatabase webViewDatabase = WebViewDatabase.getInstance(context);\n        webViewDatabase.clearFormData();\n        webViewDatabase.clearHttpAuthUsernamePassword();\n        Utils.trimCache(context);\n    }\n    public static void clearCache(@Nullable ConstraintWebLayout view) {\n        if (view == null) return;\n        view.clearCache(true);\n    }\n"]]}
{"hexsha": "dcd4aaf48aa52b3cacd9a090b60f56760ec87604", "ext": "java", "lang": "Java", "content": "public class SpeechToText {\n\n\tpublic String lang;\n\tprivate String apiKey;\n\t\n\t/**\n\t * @param lang language\n\t */\n\tpublic SpeechToText(String lang, String apiKey) {\n\t\tthis.lang = lang;\n\t\tthis.apiKey = apiKey;\n\t}\n\t\n\t/**\n\t * \n\t * @param speech audio file to transcribe\n\t * @return text\n\t */\n\tpublic String speechToText(File speech) {\n\t\tURLBuilder urlb = new URLBuilder(\"http://www.google.com/speech-api/v2/recognize\");\n\t\t\n\t\turlb.args.put(\"key\", apiKey);\n\t\turlb.args.put(\"lang\", lang);\n\t\t\n\t\tString transcript = null;\n\t\ttry {\n\t\t\tString resultJsonString = NetworkUtils.uploadAudioFileAndGetResult(urlb.buildUrl(), speech);\n\t\t\tSystem.out.println(resultJsonString);\n\t\t\tJSONObject resultJson = new JSONObject(resultJsonString);\n\t\t\t\n\t\t\tJSONArray resultArray = resultJson.getJSONArray(\"result\");\n\t\t\tJSONArray alternativeArray = resultArray.getJSONObject(0).getJSONArray(\"alternative\");\n\t\t\t\n\t\t\tdouble hiestConfidence = -1.0;\n\t\t\tfor (int i = 0; i < alternativeArray.length(); i++) {\n\t\t\t\tJSONObject obj = alternativeArray.getJSONObject(i);\n\n\t\t\t\tdouble currentConf = obj.getDouble(\"confidence\");\n\t\t\t\tif (currentConf > hiestConfidence) {\n\t\t\t\t\thiestConfidence = currentConf; \n\t\t\t\t\ttranscript = obj.getString(\"transcript\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn transcript;\n\t}\n}", "class_id": 0, "repo": "lukas2005/Speech-recognition-Java", "file": "src/io/github/lukas2005/speechrecognition/SpeechToText.java", "last_update_at": "2019-06-11T04:58:41+00:00", "question_id": "dcd4aaf48aa52b3cacd9a090b60f56760ec87604", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SpeechToText {\n\tpublic String lang;\n\tprivate String apiKey;\n\t\n\t/**\n\t * @param lang language\n\t */\n\tpublic SpeechToText(String lang, String apiKey) {\n\t\tthis.lang = lang;\n\t\tthis.apiKey = apiKey;\n\t}\n\t\n\t/**\n\t * \n\t * @param speech audio file to transcribe\n\t * @return text\n\t */\n\tpublic String speechToText(File speech) {\n\t\tURLBuilder urlb = new URLBuilder(\"http://www.google.com/speech-api/v2/recognize\");\n\t\t\n\t\turlb.args.put(\"key\", apiKey);\n\t\turlb.args.put(\"lang\", lang);\n\t\t\n\t\tString transcript = null;\n\t\ttry {\n\t\t\tString resultJsonString = NetworkUtils.uploadAudioFileAndGetResult(urlb.buildUrl(), speech);\n\t\t\tSystem.out.println(resultJsonString);\n\t\t\tJSONObject resultJson = new JSONObject(resultJsonString);\n\t\t\t\n\t\t\tJSONArray resultArray = resultJson.getJSONArray(\"result\");\n\t\t\tJSONArray alternativeArray = resultArray.getJSONObject(0).getJSONArray(\"alternative\");\n\t\t\t\n\t\t\tdouble hiestConfidence = -1.0;\n\t\t\tfor (int i = 0; i < alternativeArray.length(); i++) {\n\t\t\t\tJSONObject obj = alternativeArray.getJSONObject(i);\n\t\t\t\tdouble currentConf = obj.getDouble(\"confidence\");\n\t\t\t\tif (currentConf > hiestConfidence) {\n\t\t\t\t\thiestConfidence = currentConf; \n\t\t\t\t\ttranscript = obj.getString(\"transcript\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn transcript;\n\t}\n"]]}
{"hexsha": "936d97f1ec6dbfa587ccd5bec549a5ae12f0229d", "ext": "java", "lang": "Java", "content": "public class CustomAlertDialog extends AlertDialog {\n\n    private View view;\n\n    private Thread thread;\n\n    @SuppressLint(\"InflateParams\")\n    public CustomAlertDialog(@NonNull Context context, @LayoutRes int resource) {\n        super(context);\n        if (this.getWindow() != null) {\n            this.getWindow().setBackgroundDrawable(new ColorDrawable(android.graphics.Color.TRANSPARENT));\n        }\n        this.view = ((Activity) context).getLayoutInflater().inflate(resource, null);\n        this.setView(this.view, (int) getContext().getResources().getDimension(R.dimen.space_20dp), 0, (int) getContext().getResources().getDimension(R.dimen.space_20dp), 0);\n    }\n\n    public CustomAlertDialog canceled(boolean b) {\n        this.setCancelable(b);\n        return this;\n    }\n\n    public View getView() {\n        return view;\n    }\n\n    private View getV(@IdRes int id) {\n        return this.view.findViewById(id);\n    }\n\n    public TextView getTV(@IdRes int id) {\n        return this.view.findViewById(id);\n    }\n\n    public ImageView getIV(@IdRes int id) {\n        return this.view.findViewById(id);\n    }\n\n    public Button getBV(@IdRes int id) {\n        return this.view.findViewById(id);\n    }\n\n    public CustomAlertDialog setText(@IdRes int id, @StringRes int s) {\n        this.setText(id, this.getContext().getResources().getString(s));\n        return this;\n    }\n\n    public CustomAlertDialog setText(@IdRes int id, String s) {\n        this.getTV(id).setText(s);\n        return this;\n    }\n\n    public CustomAlertDialog setVisible(@IdRes int id, int visible) {\n        this.getV(id).setVisibility(visible);\n        return this;\n    }\n\n    public CustomAlertDialog setClickListener(@IdRes int id1, @IdRes int id2, View.OnClickListener listener) {\n        this.getV(id1).findViewById(id2).setOnClickListener(listener);\n        return this;\n    }\n\n    public CustomAlertDialog setClickListener(@IdRes int id, View.OnClickListener listener) {\n        this.getV(id).setOnClickListener(listener);\n        return this;\n    }\n\n    public CustomAlertDialog setDismissListener(Dialog.OnDismissListener listener) {\n        this.setOnDismissListener(listener);\n        return this;\n    }\n\n    public CustomAlertDialog mShow() {\n        this.show();\n        if (this.thread != null) {\n            this.thread.start();\n        }\n        return this;\n    }\n\n    public CustomAlertDialog setThread(Thread thread) {\n        this.thread = thread;\n        return this;\n    }\n\n    public void mDismiss() {\n        if (this.thread != null) {\n            this.thread.interrupt();\n            this.thread = null;\n        }\n        this.dismiss();\n    }\n}", "class_id": 0, "repo": "alttch/evaHI", "file": "app/src/main/java/com/altertech/evahi/dialog/obj/CustomAlertDialog.java", "last_update_at": "2019-03-17T12:36:45+00:00", "question_id": "936d97f1ec6dbfa587ccd5bec549a5ae12f0229d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CustomAlertDialog extends AlertDialog {\n    private View view;\n    private Thread thread;\n    @SuppressLint(\"InflateParams\")\n    public CustomAlertDialog(@NonNull Context context, @LayoutRes int resource) {\n        super(context);\n        if (this.getWindow() != null) {\n            this.getWindow().setBackgroundDrawable(new ColorDrawable(android.graphics.Color.TRANSPARENT));\n        }\n        this.view = ((Activity) context).getLayoutInflater().inflate(resource, null);\n        this.setView(this.view, (int) getContext().getResources().getDimension(R.dimen.space_20dp), 0, (int) getContext().getResources().getDimension(R.dimen.space_20dp), 0);\n    }\n    public CustomAlertDialog canceled(boolean b) {\n        this.setCancelable(b);\n        return this;\n    }\n    public View getView() {\n        return view;\n    }\n    private View getV(@IdRes int id) {\n        return this.view.findViewById(id);\n    }\n    public TextView getTV(@IdRes int id) {\n        return this.view.findViewById(id);\n    }\n    public ImageView getIV(@IdRes int id) {\n        return this.view.findViewById(id);\n    }\n    public Button getBV(@IdRes int id) {\n        return this.view.findViewById(id);\n    }\n    public CustomAlertDialog setText(@IdRes int id, @StringRes int s) {\n        this.setText(id, this.getContext().getResources().getString(s));\n        return this;\n    }\n    public CustomAlertDialog setText(@IdRes int id, String s) {\n        this.getTV(id).setText(s);\n        return this;\n    }\n    public CustomAlertDialog setVisible(@IdRes int id, int visible) {\n        this.getV(id).setVisibility(visible);\n        return this;\n    }\n    public CustomAlertDialog setClickListener(@IdRes int id1, @IdRes int id2, View.OnClickListener listener) {\n        this.getV(id1).findViewById(id2).setOnClickListener(listener);\n        return this;\n    }\n    public CustomAlertDialog setClickListener(@IdRes int id, View.OnClickListener listener) {\n        this.getV(id).setOnClickListener(listener);\n        return this;\n    }\n    public CustomAlertDialog setDismissListener(Dialog.OnDismissListener listener) {\n        this.setOnDismissListener(listener);\n        return this;\n    }\n    public CustomAlertDialog mShow() {\n        this.show();\n        if (this.thread != null) {\n            this.thread.start();\n        }\n        return this;\n    }\n    public CustomAlertDialog setThread(Thread thread) {\n        this.thread = thread;\n        return this;\n    }\n    public void mDismiss() {\n        if (this.thread != null) {\n            this.thread.interrupt();\n            this.thread = null;\n        }\n        this.dismiss();\n    }\n"]]}
{"hexsha": "f022bf9ba7715b08fd97ad06c4e7135dac37b831", "ext": "java", "lang": "Java", "content": "public class studentController {\n\n\tprivate static String ID, NAME, ClassGrade;\n\tprivate static Statement statement;\n\tprivate ResultSet resultCourses, resultClass;\n\n\t@FXML\n\tprivate Label lblName, lblID, lblClass;\n\t@FXML\n\tprivate TableView<Course> coursesTable;\n\t@FXML\n\tprivate TableColumn<Course, String> colCourse, colInstructor, colQuiz, colMidterm, colFinal;\n\n\tprivate ObservableList<Course> coursesList = FXCollections.observableArrayList();\n\n\tpublic static void setID(String id) {\n\t\tID = id;\n\t}\n\n\tpublic static void setName(String name) {\n\t\tNAME = name;\n\t}\n\n\tpublic static void setClassGrade(String classGrade) {\n\t\tClassGrade = classGrade;\n\t}\n\n\tpublic static void setStatement(Statement stm) {\n\t\tstatement = stm;\n\t}\n\n\t@FXML\n\tpublic void initialize() {\n\t\tgetClassGrade();\n\t\tloadCourses();\n\t\tinit_grades_table();\n\t\tinit_labels();\n\t}\n\n\tpublic void getClassGrade() {\n\t\ttry {\n\t\t\tString getClassGrade = String.format(\"select concat(class_grade, class_room) as class\"\n\t\t\t\t\t+ \" from students inner join classes using (class_id) where students.student_id = %s;\", ID);\n\t\t\tresultClass = statement.executeQuery(getClassGrade);\n\t\t\tresultClass.next();\n\t\t\tClassGrade = resultClass.getString(\"class\");\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic void init_grades_table() {\n\t\tcolCourse.setCellValueFactory(new PropertyValueFactory<>(\"courseName\"));\n\t\tcolInstructor.setCellValueFactory(new PropertyValueFactory<>(\"instructor_name\"));\n\t\tcolQuiz.setCellValueFactory(new PropertyValueFactory<>(\"quiz\"));\n\t\tcolMidterm.setCellValueFactory(new PropertyValueFactory<>(\"mid\"));\n\t\tcolFinal.setCellValueFactory(new PropertyValueFactory<>(\"fin\"));\n\t\tcoursesTable.setItems(coursesList);\n\t}\n\n\tpublic void init_labels() {\n\t\tlblName.setText(NAME);\n\t\tlblID.setText(ID);\n\t\tlblClass.setText(ClassGrade);\n\t}\n\n\tpublic void loadCourses() {\n\t\ttry {\n\t\t\tString selectClasses = String.format(\n\t\t\t\t\t\"select course_name, teacher_name, teacher_id, quiz, midterm, final from (((grade inner join students using (student_id)) inner join courses using (course_id)) inner join teaches using (class_id, course_id)) left join teachers using (teacher_id) where students.student_id = %s;\",\n\t\t\t\t\tID);\n\t\t\tresultCourses = statement.executeQuery(selectClasses);\n\n\t\t\tCourse crs;\n\t\t\tString courseName, teacherName, teacherID, quiz, mid, fin;\n\n\t\t\twhile (resultCourses.next()) {\n\t\t\t\tcourseName = resultCourses.getString(\"course_name\");\n\t\t\t\tteacherName = resultCourses.getString(\"teacher_name\");\n\t\t\t\tteacherID = resultCourses.getString(\"teacher_id\");\n\t\t\t\tquiz = resultCourses.getString(\"quiz\");\n\t\t\t\tmid = resultCourses.getString(\"midterm\");\n\t\t\t\tfin = resultCourses.getString(\"final\");\n\t\t\t\tcrs = new Course(courseName, teacherName, teacherID, quiz, mid, fin);\n\t\t\t\tcoursesList.add(crs);\n\t\t\t}\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t@FXML\n\tpublic void onLogOut() throws IOException {\n\t\tMain.switchToMain();\n\t}\n}", "class_id": 0, "repo": "alimhmdghanem/School-Management", "file": "src/student/studentController.java", "last_update_at": "2019-07-19T19:40:12+00:00", "question_id": "f022bf9ba7715b08fd97ad06c4e7135dac37b831", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class studentController {\n\tprivate static String ID, NAME, ClassGrade;\n\tprivate static Statement statement;\n\tprivate ResultSet resultCourses, resultClass;\n\t@FXML\n\tprivate Label lblName, lblID, lblClass;\n\t@FXML\n\tprivate TableView<Course> coursesTable;\n\t@FXML\n\tprivate TableColumn<Course, String> colCourse, colInstructor, colQuiz, colMidterm, colFinal;\n\tprivate ObservableList<Course> coursesList = FXCollections.observableArrayList();\n\tpublic static void setID(String id) {\n\t\tID = id;\n\t}\n\tpublic static void setName(String name) {\n\t\tNAME = name;\n\t}\n\tpublic static void setClassGrade(String classGrade) {\n\t\tClassGrade = classGrade;\n\t}\n\tpublic static void setStatement(Statement stm) {\n\t\tstatement = stm;\n\t}\n\t@FXML\n\tpublic void initialize() {\n\t\tgetClassGrade();\n\t\tloadCourses();\n\t\tinit_grades_table();\n\t\tinit_labels();\n\t}\n\tpublic void getClassGrade() {\n\t\ttry {\n\t\t\tString getClassGrade = String.format(\"select concat(class_grade, class_room) as class\"\n\t\t\t\t\t+ \" from students inner join classes using (class_id) where students.student_id = %s;\", ID);\n\t\t\tresultClass = statement.executeQuery(getClassGrade);\n\t\t\tresultClass.next();\n\t\t\tClassGrade = resultClass.getString(\"class\");\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\tpublic void init_grades_table() {\n\t\tcolCourse.setCellValueFactory(new PropertyValueFactory<>(\"courseName\"));\n\t\tcolInstructor.setCellValueFactory(new PropertyValueFactory<>(\"instructor_name\"));\n\t\tcolQuiz.setCellValueFactory(new PropertyValueFactory<>(\"quiz\"));\n\t\tcolMidterm.setCellValueFactory(new PropertyValueFactory<>(\"mid\"));\n\t\tcolFinal.setCellValueFactory(new PropertyValueFactory<>(\"fin\"));\n\t\tcoursesTable.setItems(coursesList);\n\t}\n\tpublic void init_labels() {\n\t\tlblName.setText(NAME);\n\t\tlblID.setText(ID);\n\t\tlblClass.setText(ClassGrade);\n\t}\n\tpublic void loadCourses() {\n\t\ttry {\n\t\t\tString selectClasses = String.format(\n\t\t\t\t\t\"select course_name, teacher_name, teacher_id, quiz, midterm, final from (((grade inner join students using (student_id)) inner join courses using (course_id)) inner join teaches using (class_id, course_id)) left join teachers using (teacher_id) where students.student_id = %s;\",\n\t\t\t\t\tID);\n\t\t\tresultCourses = statement.executeQuery(selectClasses);\n\t\t\tCourse crs;\n\t\t\tString courseName, teacherName, teacherID, quiz, mid, fin;\n\t\t\twhile (resultCourses.next()) {\n\t\t\t\tcourseName = resultCourses.getString(\"course_name\");\n\t\t\t\tteacherName = resultCourses.getString(\"teacher_name\");\n\t\t\t\tteacherID = resultCourses.getString(\"teacher_id\");\n\t\t\t\tquiz = resultCourses.getString(\"quiz\");\n\t\t\t\tmid = resultCourses.getString(\"midterm\");\n\t\t\t\tfin = resultCourses.getString(\"final\");\n\t\t\t\tcrs = new Course(courseName, teacherName, teacherID, quiz, mid, fin);\n\t\t\t\tcoursesList.add(crs);\n\t\t\t}\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t@FXML\n\tpublic void onLogOut() throws IOException {\n\t\tMain.switchToMain();\n\t}\n"]]}
{"hexsha": "c2b1d3ff934e9d8ea779da8367572ce7735c4fc1", "ext": "java", "lang": "Java", "content": "public class TextFileDataWriter extends DataWriter {\r\n\tprotected BufferedWriter dataWriter;\r\n\tprivate String intendedFileName;\r\n\tprivate boolean storeData;\r\n\r\n\t/**\r\n\t * Create a data writer which collects data and immediately writes them to\r\n\t * the given data file.\r\n\t * \r\n\t * @param fn\r\n\t *            name of the data file.\r\n\t */\r\n\tpublic TextFileDataWriter(String fn) {\r\n\t\tsuper();\r\n\t\tdataFileName = null;\r\n\t\tintendedFileName = fn;\r\n\t\tdataWriter = null;\r\n\t\tstoreData = true;\r\n\t\tlogSession(\"Start\");\r\n\t}\r\n\r\n\tprivate void openDataWriter() {\r\n\t\tDebug.show(Debug.FILES, \"TextFileDataWriter(): Open file \"\r\n\t\t\t\t+ intendedFileName);\r\n\t\ttry {\r\n\t\t\tdataWriter = new BufferedWriter(new FileWriter(intendedFileName));\r\n\t\t\tdataFileName = intendedFileName;\r\n\t\t\tif (!StringExt.nonEmpty(ExPar.DataFileName.getString())) {\r\n\t\t\t\tExPar.DataFileName.set(dataFileName);\r\n\t\t\t}\r\n\t\t} catch (IOException iox) {\r\n\t\t\tnew FileError(\"Can't open data file \" + intendedFileName\r\n\t\t\t\t\t+ \"\\nData are not stored!\");\r\n\t\t\tstoreData = false;\r\n\t\t}\r\n\t}\r\n\r\n\tprotected void logSession(String prefix) {\r\n\t\tExPar.setDate();\r\n\t\tString fs = ExPar.SessionDescriptorFormat.getString();\r\n\t\tif (StringExt.nonEmpty(fs)) {\r\n\t\t\ttry {\r\n\t\t\t\tFile df = new File(intendedFileName);\r\n\t\t\t\tFile sf = new File(df.getParent(), \"experiment.log\");\r\n\t\t\t\tBufferedWriter wr = new BufferedWriter(new FileWriter(\r\n\t\t\t\t\t\tsf.getPath(), true));\r\n\t\t\t\tString nl = System.getProperty(\"line.separator\");\r\n\t\t\t\twr.write(prefix + \" \" + fs + nl);\r\n\t\t\t\twr.close();\r\n\t\t\t} catch (IOException iex) {\r\n\t\t\t\tnew FileError(\r\n\t\t\t\t\t\t\"Error while trying to write experiment log file!\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Deliver a data string to this DataWriter.\r\n\t * \r\n\t * @param data\r\n\t *            the data string to be written.\r\n\t */\r\n\tpublic void store(ExDesignNode data) {\r\n\t\t// System.out.println(\"TextFileDataWriter.store() \" + data);\r\n\t\tString dt = dataStringOf(data);\r\n\t\tif (dt != null) {\r\n\t\t\tif (storeData && (dataWriter == null))\r\n\t\t\t\topenDataWriter();\r\n\t\t\tif (storeData) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tString nl = System.getProperty(\"line.separator\");\r\n\t\t\t\t\tdataWriter.write(dt + nl);\r\n\t\t\t\t\tdataWriter.flush();\r\n\t\t\t\t} catch (IOException ioex) {\r\n\t\t\t\t\tnew FileError(\"Errow while trying to write data string <\"\r\n\t\t\t\t\t\t\t+ dt + \"> to destination \" + dataFileName);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Signal this DataWriter object that data collection is complete.\r\n\t * \r\n\t * @param status\r\n\t *            the final status of the data source.\r\n\t */\r\n\tpublic void dataComplete(int status) {\r\n\t\tif (storeData && (dataWriter != null)) {\r\n\t\t\ttry {\r\n\t\t\t\tdataWriter.close();\r\n\t\t\t\tDebug.show(Debug.FILES,\r\n\t\t\t\t\t\t\"TextFileDataWriter.dataComplete(): Closed file \"\r\n\t\t\t\t\t\t\t\t+ dataFileName);\r\n\t\t\t} catch (IOException ioex) {\r\n\t\t\t\tnew FileError(\r\n\t\t\t\t\t\t\"Errow while trying to close the data destination \"\r\n\t\t\t\t\t\t\t\t+ dataFileName);\r\n\t\t\t}\r\n\t\t}\r\n\t\tlogSession(\"End\");\r\n\t}\r\n}", "class_id": 0, "repo": "manuelgentile/pxlab", "file": "pxlab/src/main/java/de/pxlab/pxl/TextFileDataWriter.java", "last_update_at": "2019-03-04T11:10:59+00:00", "question_id": "c2b1d3ff934e9d8ea779da8367572ce7735c4fc1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TextFileDataWriter extends DataWriter {\r\n\tprotected BufferedWriter dataWriter;\r\n\tprivate String intendedFileName;\r\n\tprivate boolean storeData;\r\n\r\n\t/**\r\n\t * Create a data writer which collects data and immediately writes them to\r\n\t * the given data file.\r\n\t * \r\n\t * @param fn\r\n\t *            name of the data file.\r\n\t */\r\n\tpublic TextFileDataWriter(String fn) {\r\n\t\tsuper();\r\n\t\tdataFileName = null;\r\n\t\tintendedFileName = fn;\r\n\t\tdataWriter = null;\r\n\t\tstoreData = true;\r\n\t\tlogSession(\"Start\");\r\n\t}\r\n\r\n\tprivate void openDataWriter() {\r\n\t\tDebug.show(Debug.FILES, \"TextFileDataWriter(): Open file \"\r\n\t\t\t\t+ intendedFileName);\r\n\t\ttry {\r\n\t\t\tdataWriter = new BufferedWriter(new FileWriter(intendedFileName));\r\n\t\t\tdataFileName = intendedFileName;\r\n\t\t\tif (!StringExt.nonEmpty(ExPar.DataFileName.getString())) {\r\n\t\t\t\tExPar.DataFileName.set(dataFileName);\r\n\t\t\t}\r\n\t\t} catch (IOException iox) {\r\n\t\t\tnew FileError(\"Can't open data file \" + intendedFileName\r\n\t\t\t\t\t+ \"\\nData are not stored!\");\r\n\t\t\tstoreData = false;\r\n\t\t}\r\n\t}\r\n\r\n\tprotected void logSession(String prefix) {\r\n\t\tExPar.setDate();\r\n\t\tString fs = ExPar.SessionDescriptorFormat.getString();\r\n\t\tif (StringExt.nonEmpty(fs)) {\r\n\t\t\ttry {\r\n\t\t\t\tFile df = new File(intendedFileName);\r\n\t\t\t\tFile sf = new File(df.getParent(), \"experiment.log\");\r\n\t\t\t\tBufferedWriter wr = new BufferedWriter(new FileWriter(\r\n\t\t\t\t\t\tsf.getPath(), true));\r\n\t\t\t\tString nl = System.getProperty(\"line.separator\");\r\n\t\t\t\twr.write(prefix + \" \" + fs + nl);\r\n\t\t\t\twr.close();\r\n\t\t\t} catch (IOException iex) {\r\n\t\t\t\tnew FileError(\r\n\t\t\t\t\t\t\"Error while trying to write experiment log file!\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Deliver a data string to this DataWriter.\r\n\t * \r\n\t * @param data\r\n\t *            the data string to be written.\r\n\t */\r\n\tpublic void store(ExDesignNode data) {\r\n\t\t// System.out.println(\"TextFileDataWriter.store() \" + data);\r\n\t\tString dt = dataStringOf(data);\r\n\t\tif (dt != null) {\r\n\t\t\tif (storeData && (dataWriter == null))\r\n\t\t\t\topenDataWriter();\r\n\t\t\tif (storeData) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tString nl = System.getProperty(\"line.separator\");\r\n\t\t\t\t\tdataWriter.write(dt + nl);\r\n\t\t\t\t\tdataWriter.flush();\r\n\t\t\t\t} catch (IOException ioex) {\r\n\t\t\t\t\tnew FileError(\"Errow while trying to write data string <\"\r\n\t\t\t\t\t\t\t+ dt + \"> to destination \" + dataFileName);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Signal this DataWriter object that data collection is complete.\r\n\t * \r\n\t * @param status\r\n\t *            the final status of the data source.\r\n\t */\r\n\tpublic void dataComplete(int status) {\r\n\t\tif (storeData && (dataWriter != null)) {\r\n\t\t\ttry {\r\n\t\t\t\tdataWriter.close();\r\n\t\t\t\tDebug.show(Debug.FILES,\r\n\t\t\t\t\t\t\"TextFileDataWriter.dataComplete(): Closed file \"\r\n\t\t\t\t\t\t\t\t+ dataFileName);\r\n\t\t\t} catch (IOException ioex) {\r\n\t\t\t\tnew FileError(\r\n\t\t\t\t\t\t\"Errow while trying to close the data destination \"\r\n\t\t\t\t\t\t\t\t+ dataFileName);\r\n\t\t\t}\r\n\t\t}\r\n\t\tlogSession(\"End\");\r\n\t}\r\n"]]}
{"hexsha": "68d043774c359c27a914cca3b582174bca0dddea", "ext": "java", "lang": "Java", "content": "public class hashmap {\r\n\r\n\tpublic static void main(String[] args) \r\n\t{\r\n\tHashMap<Integer, String> hm= new HashMap<Integer,String>();\r\n\thm.put(1, \"sachin\");\r\n\thm.put(2, \"ravi\");\r\n\thm.put(3, \"raj\");\r\n\t\r\n\tSystem.out.println(hm.get(1));\r\n\tSystem.out.println(hm.containsKey(3));\r\n\tfor(Entry m: hm.entrySet())\r\n\t{\r\n\t\tSystem.out.println(m.getKey()+ \" \"+m.getValue());\r\n\t}\r\n\tHashMap<Integer, Employee> emp= new HashMap<Integer,Employee>();\r\n\tEmployee e1= new Employee(1, \"raj\", \"Admin\");\r\n\tEmployee e2= new Employee(1, \"ravi\", \"testing\");\r\n\tEmployee e3= new Employee(1, \"sachin\", \"devlop\");\r\n\t\r\n\temp.put(1, e1);\r\n\temp.put(2, e2);\r\n\temp.put(3, e3);\r\n\t\r\n\tfor(Entry<Integer,Employee>m :emp.entrySet())\r\n\t{\r\n\tint key=m.getKey();\r\n\t\r\n\t\tEmployee e=m.getValue();\r\n\t\tSystem.out.println(key + \"info\");\r\n\t\tSystem.out.println(e.id+\" \"+e.name+\" \"+e.dept);\r\n\t\t\r\n\t}\r\n\t\r\n\r\n\t}\r\n\r\n}", "class_id": 0, "repo": "akashdktyagi/yantra", "file": "src/dev/backup/sachin/assignment/hashmap.java", "last_update_at": "2019-05-24T19:27:18+00:00", "question_id": "68d043774c359c27a914cca3b582174bca0dddea", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class hashmap {\r\n\r\n\tpublic static void main(String[] args) \r\n\t{\r\n\tHashMap<Integer, String> hm= new HashMap<Integer,String>();\r\n\thm.put(1, \"sachin\");\r\n\thm.put(2, \"ravi\");\r\n\thm.put(3, \"raj\");\r\n\t\r\n\tSystem.out.println(hm.get(1));\r\n\tSystem.out.println(hm.containsKey(3));\r\n\tfor(Entry m: hm.entrySet())\r\n\t{\r\n\t\tSystem.out.println(m.getKey()+ \" \"+m.getValue());\r\n\t}\r\n\tHashMap<Integer, Employee> emp= new HashMap<Integer,Employee>();\r\n\tEmployee e1= new Employee(1, \"raj\", \"Admin\");\r\n\tEmployee e2= new Employee(1, \"ravi\", \"testing\");\r\n\tEmployee e3= new Employee(1, \"sachin\", \"devlop\");\r\n\t\r\n\temp.put(1, e1);\r\n\temp.put(2, e2);\r\n\temp.put(3, e3);\r\n\t\r\n\tfor(Entry<Integer,Employee>m :emp.entrySet())\r\n\t{\r\n\tint key=m.getKey();\r\n\t\r\n\t\tEmployee e=m.getValue();\r\n\t\tSystem.out.println(key + \"info\");\r\n\t\tSystem.out.println(e.id+\" \"+e.name+\" \"+e.dept);\r\n\t\t\r\n\t}\r\n\t\r\n\r\n\t}\r\n\r\n"]]}
{"hexsha": "6050304fdf34be0dee8b071ac6c9048f2990a697", "ext": "java", "lang": "Java", "content": "class stack1\r\n{\r\n  BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); \r\n    class stack\r\n    {\r\n        int x;\r\n        void input()throws IOException\r\n        {\r\n           x=Integer.parseInt(br.readLine());\r\n        }\r\n        void disp()\r\n        {\r\n            System.out.println(x);\r\n        }\r\n        stack next;\r\n    }\r\n    stack top;//top1;\r\n    stack1()\r\n    {\r\n      //top=new stack();\r\n      top=null;\r\n      //top1=top;\r\n      \r\n    }\r\n    stack push(stack s)throws IOException\r\n    {\r\n        stack p;\r\n        p=new stack();\r\n        p.input();\r\n        p.next=s;\r\n        s=p;\r\n        return s;\r\n    }\r\n    stack pop(stack s)\r\n    {\r\n        if(s==null)\r\n       {\r\n           System.out.println(\"Nothing to pop....\");\r\n           return s;\r\n        }\r\n        System.out.println(\"Popped element:\");\r\n        s.disp();\r\n        stack p;\r\n        p=new stack();\r\n        p=s.next;\r\n        s=p;\r\n        return s;\r\n    }\r\n    void display(stack s)\r\n    {\r\n       if(s==null)\r\n       {\r\n           System.out.println(\"Nothing to display....\");\r\n           return;\r\n        }\r\n        stack p;\r\n       p=new stack();\r\n        p=s;\r\n        while(p!=null)\r\n        {\r\n            p.disp();\r\n            p=p.next;\r\n        }\r\n    }\r\n     void impl()throws IOException\r\n    {\r\n        int x;\r\n        do\r\n        {\r\n            System.out.println(\"Press 1 for Push:\");\r\n            System.out.println(\"Press 2 for Pop:\");\r\n            System.out.println(\"Press 3 for Display:\");\r\n            System.out.println(\"Press 4 for Exit:\");\r\n            System.out.println(\"Enter choice:\");\r\n            x=Integer.parseInt(br.readLine());\r\n            switch(x)\r\n            {\r\n                case 1:top= push(top);\r\n                        break;\r\n                case 2:top= pop(top);\r\n                        break;\r\n                case 3:display(top);\r\n                       break;\r\n                case 4: System.exit(0);\r\n                        break;\r\n            }\r\n        }while(true);\r\n    }\r\n}", "class_id": 0, "repo": "SayanGhoshBDA/code-backup", "file": "java_backup/my java/amlan/link/link_stack_queue/stack1.java", "last_update_at": "2019-05-08T10:09:52+00:00", "question_id": "6050304fdf34be0dee8b071ac6c9048f2990a697", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class stack1\r\n{\r\n  BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); \r\n    class stack\r\n    {\r\n        int x;\r\n        void input()throws IOException\r\n        {\r\n           x=Integer.parseInt(br.readLine());\r\n        }\r\n        void disp()\r\n        {\r\n            System.out.println(x);\r\n        }\r\n        stack next;\r\n    }\r\n    stack top;//top1;\r\n    stack1()\r\n    {\r\n      //top=new stack();\r\n      top=null;\r\n      //top1=top;\r\n      \r\n    }\r\n    stack push(stack s)throws IOException\r\n    {\r\n        stack p;\r\n        p=new stack();\r\n        p.input();\r\n        p.next=s;\r\n        s=p;\r\n        return s;\r\n    }\r\n    stack pop(stack s)\r\n    {\r\n        if(s==null)\r\n       {\r\n           System.out.println(\"Nothing to pop....\");\r\n           return s;\r\n        }\r\n        System.out.println(\"Popped element:\");\r\n        s.disp();\r\n        stack p;\r\n        p=new stack();\r\n        p=s.next;\r\n        s=p;\r\n        return s;\r\n    }\r\n    void display(stack s)\r\n    {\r\n       if(s==null)\r\n       {\r\n           System.out.println(\"Nothing to display....\");\r\n           return;\r\n        }\r\n        stack p;\r\n       p=new stack();\r\n        p=s;\r\n        while(p!=null)\r\n        {\r\n            p.disp();\r\n            p=p.next;\r\n        }\r\n    }\r\n     void impl()throws IOException\r\n    {\r\n        int x;\r\n        do\r\n        {\r\n            System.out.println(\"Press 1 for Push:\");\r\n            System.out.println(\"Press 2 for Pop:\");\r\n            System.out.println(\"Press 3 for Display:\");\r\n            System.out.println(\"Press 4 for Exit:\");\r\n            System.out.println(\"Enter choice:\");\r\n            x=Integer.parseInt(br.readLine());\r\n            switch(x)\r\n            {\r\n                case 1:top= push(top);\r\n                        break;\r\n                case 2:top= pop(top);\r\n                        break;\r\n                case 3:display(top);\r\n                       break;\r\n                case 4: System.exit(0);\r\n                        break;\r\n            }\r\n        }while(true);\r\n    }\r\n"]]}
{"hexsha": "18364d3c3b9ce3bc6900f838c173be3d2853b52b", "ext": "java", "lang": "Java", "content": "public class Grib2PDSReaderTest {\n\n\tprivate static final int EXPECTEDLENGTH = 1138; //checked\n\n\tprivate static final int TEMPLATENUMBER = 0;\n\tprivate static final int NUMBEROFCOORDINATEVALUES = 276; //unchecked\n\t\n\tprivate Grib2PDSReader pdsReader;\n\n\t@BeforeMethod\n\tpublic void prepare() throws Exception {\n\t\tpdsReader = new Grib2PDSReader();\n\t}\n\n\t@DataProvider(name = \"goodPDSDataSet\")\n\tpublic static Object[][] goodPDSDataSet() throws IOException, URISyntaxException {\n\t\tfinal int OFFSET = 13;\n\t\treturn new Object[][]{\n\t\t\t\tnew Object[]{GOOD_PDS_ARRAY(), 0, EXPECTEDLENGTH, GOOD_PDS_OBJECT()},\n\t\t\t\tnew Object[]{GOOD_PDS_ARRAY_WITH_OFFSET(OFFSET), OFFSET, EXPECTEDLENGTH, GOOD_PDS_OBJECT()}\n\t\t};\n\t}\n\t\n\tprivate static final Grib2PDS GOOD_PDS_OBJECT(){\n\t\t\n\t\t\n\t\tGrib2PDS pds = new Grib2PDS();\n\t\tpds.setLength(EXPECTEDLENGTH);\n\t\tpds.setTemplateNumber(TEMPLATENUMBER);\n\t\tpds.setNumberOfCoordinateValues(NUMBEROFCOORDINATEVALUES); \n\t\tpds.setTemplate(new HorizontalLevelTemplate());\n\t\treturn pds;\n\t}\n\t\n\tprivate static final byte[] GOOD_PDS_ARRAY() throws URISyntaxException, IOException {\n\t\tString filename = \"ecmwf-grib2-example-product-definition-section.grb\";\n\n\t\tString name = Grib2PDSReader.class.getResource(filename).toString();\n\t\tFile f = new File(Grib2PDSReader.class.getResource(filename).toURI());\n\t\tif (!f.exists()) {\n\t\t\tthrow new IOException(\"file does not exist at \" + name);\n\t\t}\n\t\tRandomAccessFile raFile = new RandomAccessFile(f, \"r\");\n\t\tFileChannel fc = raFile.getChannel();\n\t\tfc.position(0);\n\t\tByteBuffer buffer = ByteBuffer.allocate((int) raFile.length());\n\t\tfc.read(buffer);\n\t\tbuffer.rewind();\n\t\tbyte[] response = buffer.array();\n\t\traFile.close();\n\t\treturn response;\n\t};\n\t\n\tprivate static final byte[] GOOD_PDS_ARRAY_WITH_OFFSET(int offSet)\n\t\t\tthrows URISyntaxException, IOException {\n\t\tbyte[] bytes = GOOD_PDS_ARRAY();\n\t\tbyte[] response = new byte[bytes.length + offSet];\n\t\tfor (int i = 0; i < offSet; i++) {\n\t\t\tresponse[i] = (byte) 1;\n\t\t}\n\t\tfor (int counter = 0; counter < bytes.length; counter++) {\n\t\t\tresponse[offSet + counter] = bytes[counter];\n\t\t}\n\t\treturn response;\n\t}\n\t\n\t@Test(dataProvider = \"goodPDSDataSet\")\n\tpublic void testReadPDS(byte[] testArray, int headerOffSet, int expectedValue, Grib2PDS expectedResponseObject) throws BinaryNumberConversionException, IOException {\n\t\tint length = pdsReader.readSectionLength(testArray, headerOffSet);\n\t\tassertThat(length).isEqualTo(expectedValue);\n\t\t\n\t\tGrib2PDS pds = pdsReader.readPDSValues(testArray,headerOffSet);\n\t\tassertThat(pds).isNotNull();\n\t\t\n\t\tassertThat(pds.getTemplate()).isInstanceOf(ProductTemplate.class);\n\t\t//exclude datatemplate content itself, so artificial equal\n\t\tpds.setTemplate(expectedResponseObject.getTemplate());\n\t\tassertThat(pds).isEqualTo(expectedResponseObject);\n\t}\n}", "class_id": 0, "repo": "reymalahay/grib-library", "file": "src/test/java/org/meteogroup/griblibrary/grib2/Grib2PDSReaderTest.java", "last_update_at": "2019-12-06T09:35:28+00:00", "question_id": "18364d3c3b9ce3bc6900f838c173be3d2853b52b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Grib2PDSReaderTest {\n\tprivate static final int EXPECTEDLENGTH = 1138; //checked\n\tprivate static final int TEMPLATENUMBER = 0;\n\tprivate static final int NUMBEROFCOORDINATEVALUES = 276; //unchecked\n\t\n\tprivate Grib2PDSReader pdsReader;\n\t@BeforeMethod\n\tpublic void prepare() throws Exception {\n\t\tpdsReader = new Grib2PDSReader();\n\t}\n\t@DataProvider(name = \"goodPDSDataSet\")\n\tpublic static Object[][] goodPDSDataSet() throws IOException, URISyntaxException {\n\t\tfinal int OFFSET = 13;\n\t\treturn new Object[][]{\n\t\t\t\tnew Object[]{GOOD_PDS_ARRAY(), 0, EXPECTEDLENGTH, GOOD_PDS_OBJECT()},\n\t\t\t\tnew Object[]{GOOD_PDS_ARRAY_WITH_OFFSET(OFFSET), OFFSET, EXPECTEDLENGTH, GOOD_PDS_OBJECT()}\n\t\t};\n\t}\n\t\n\tprivate static final Grib2PDS GOOD_PDS_OBJECT(){\n\t\t\n\t\t\n\t\tGrib2PDS pds = new Grib2PDS();\n\t\tpds.setLength(EXPECTEDLENGTH);\n\t\tpds.setTemplateNumber(TEMPLATENUMBER);\n\t\tpds.setNumberOfCoordinateValues(NUMBEROFCOORDINATEVALUES); \n\t\tpds.setTemplate(new HorizontalLevelTemplate());\n\t\treturn pds;\n\t}\n\t\n\tprivate static final byte[] GOOD_PDS_ARRAY() throws URISyntaxException, IOException {\n\t\tString filename = \"ecmwf-grib2-example-product-definition-section.grb\";\n\t\tString name = Grib2PDSReader.class.getResource(filename).toString();\n\t\tFile f = new File(Grib2PDSReader.class.getResource(filename).toURI());\n\t\tif (!f.exists()) {\n\t\t\tthrow new IOException(\"file does not exist at \" + name);\n\t\t}\n\t\tRandomAccessFile raFile = new RandomAccessFile(f, \"r\");\n\t\tFileChannel fc = raFile.getChannel();\n\t\tfc.position(0);\n\t\tByteBuffer buffer = ByteBuffer.allocate((int) raFile.length());\n\t\tfc.read(buffer);\n\t\tbuffer.rewind();\n\t\tbyte[] response = buffer.array();\n\t\traFile.close();\n\t\treturn response;\n\t};\n\t\n\tprivate static final byte[] GOOD_PDS_ARRAY_WITH_OFFSET(int offSet)\n\t\t\tthrows URISyntaxException, IOException {\n\t\tbyte[] bytes = GOOD_PDS_ARRAY();\n\t\tbyte[] response = new byte[bytes.length + offSet];\n\t\tfor (int i = 0; i < offSet; i++) {\n\t\t\tresponse[i] = (byte) 1;\n\t\t}\n\t\tfor (int counter = 0; counter < bytes.length; counter++) {\n\t\t\tresponse[offSet + counter] = bytes[counter];\n\t\t}\n\t\treturn response;\n\t}\n\t\n\t@Test(dataProvider = \"goodPDSDataSet\")\n\tpublic void testReadPDS(byte[] testArray, int headerOffSet, int expectedValue, Grib2PDS expectedResponseObject) throws BinaryNumberConversionException, IOException {\n\t\tint length = pdsReader.readSectionLength(testArray, headerOffSet);\n\t\tassertThat(length).isEqualTo(expectedValue);\n\t\t\n\t\tGrib2PDS pds = pdsReader.readPDSValues(testArray,headerOffSet);\n\t\tassertThat(pds).isNotNull();\n\t\t\n\t\tassertThat(pds.getTemplate()).isInstanceOf(ProductTemplate.class);\n\t\t//exclude datatemplate content itself, so artificial equal\n\t\tpds.setTemplate(expectedResponseObject.getTemplate());\n\t\tassertThat(pds).isEqualTo(expectedResponseObject);\n\t}\n"]]}
{"hexsha": "684b279240abd2df9bdefaf696f4f01eae679b96", "ext": "java", "lang": "Java", "content": "public class ChannelCursor {\n\n  private static final int NOTSET=-2;\n\n  Session[] sessions;\n  Layer[] layers;\n  Channel channel;\n  int pos=NOTSET;\n\n  /**\n   * Constructs a <i>ChannelCursor</i> for the specified\n   * {@link net.sf.appia.core.Channel Channel}\n   *\n   * @param channel the cursors {@link net.sf.appia.core.Channel Channel}\n   */\n  public ChannelCursor(Channel channel) {\n    this.channel=channel;\n    this.sessions=channel.sessions;\n    this.layers=channel.getQoS().layers;\n  }\n\n  /**\n   * Go to the {@link net.sf.appia.core.Session Session} imediatly below in the\n   * {@link net.sf.appia.core.Channel Channel} stack.\n   *\n   * @throws AppiaCursorException with two possible\n   * {@link net.sf.appia.core.AppiaCursorException#type types}:\n   * {@link net.sf.appia.core.AppiaCursorException#CURSORNOTSET CURSORNOTSET},\n   * {@link net.sf.appia.core.AppiaCursorException#CURSORONBOTTOM CURSORONBOTTOM}\n   */\n  public void down() throws AppiaCursorException {\n    if (pos == NOTSET)\n       throw new AppiaCursorException(AppiaCursorException.CURSORNOTSET);\n\n    if (pos < 0)\n       throw new AppiaCursorException(AppiaCursorException.CURSORONBOTTOM);\n\n    --pos;\n  }\n\n  /**\n   * Go to the {@link net.sf.appia.core.Session Session} imediatly above in the\n   * {@link net.sf.appia.core.Channel Channel} stack.\n   *\n   * @throws AppiaCursorException with two possible\n   * {@link net.sf.appia.core.AppiaCursorException#type types}:\n   * {@link net.sf.appia.core.AppiaCursorException#CURSORNOTSET CURSORNOTSET},\n   * {@link net.sf.appia.core.AppiaCursorException#CURSORONTOP CURSORONTOP}\n   */\n  public void up() throws AppiaCursorException {\n    if (pos == NOTSET)\n       throw new AppiaCursorException(AppiaCursorException.CURSORNOTSET);\n\n    if (pos >= sessions.length)\n       throw new AppiaCursorException(AppiaCursorException.CURSORONTOP);\n\n    ++pos;\n  }\n\n  /**\n   * Go to the highest {@link net.sf.appia.core.Session Session} in the\n   * {@link net.sf.appia.core.Channel Channel} stack.\n   */\n  public void top() {\n    pos=sessions.length-1;\n  }\n\n  /**\n   * Go to the lowest {@link net.sf.appia.core.Session Session} in the\n   * {@link net.sf.appia.core.Channel Channel} stack.\n   */\n  public void bottom() {\n    pos=0;\n  }\n\n  /**\n   * Is the cursor in a valid position, is it set ?\n   *\n   * @return <i>true</i> if the cursor is within the satck, <i>false</i> otherwise\n   */\n  public boolean isPositioned() {\n    return (pos >= 0) && (pos < sessions.length);\n  }\n\n  /**\n   * Set the {@link net.sf.appia.core.Session Session} for the current position in the\n   * {@link net.sf.appia.core.Channel Channel} stack.\n   *\n   * @param session the {@link net.sf.appia.core.Session Session} to set\n   * @throws AppiaCursorException with three possible\n   * {@link net.sf.appia.core.AppiaCursorException#type types}:\n   * {@link net.sf.appia.core.AppiaCursorException#CURSORNOTSET CURSORNOTSET},\n   * {@link net.sf.appia.core.AppiaCursorException#ALREADYSET ALREADYSET},\n   * {@link net.sf.appia.core.AppiaCursorException#WRONGLAYER WRONGLAYER},\n   */\n  public void setSession(Session session) throws AppiaCursorException {\n    if (pos == NOTSET)\n       throw new AppiaCursorException(AppiaCursorException.CURSORNOTSET);\n\n    if (sessions[pos] != null)\n       throw new AppiaCursorException(AppiaCursorException.ALREADYSET,\"Session has already been Set\");\n\n    if (layers[pos].getClass() != session.getLayer().getClass())\n       throw new AppiaCursorException(AppiaCursorException.WRONGLAYER,\"Wrong Session Layer\");\n\n    sessions[pos]=session;\n  }\n\n  /**\n   * Get the current {@link net.sf.appia.core.Session Session} in the\n   * {@link net.sf.appia.core.Channel Channel} stack.\n   *\n   * @return the current {@link net.sf.appia.core.Session Session}, <i>null</i> if no\n   * {@link net.sf.appia.core.Session Session} has been set for the current position\n   * @throws AppiaCursorException with three possible\n   * {@link net.sf.appia.core.AppiaCursorException#type types}:\n   * {@link net.sf.appia.core.AppiaCursorException#CURSORNOTSET CURSORNOTSET},\n   * {@link net.sf.appia.core.AppiaCursorException#CURSORONBOTTOM CURSORONBOTTOM},\n   * {@link net.sf.appia.core.AppiaCursorException#CURSORONTOP CURSORONTOP}\n   */\n  public Session getSession() throws AppiaCursorException {\n    if (pos == NOTSET)\n       throw new AppiaCursorException(AppiaCursorException.CURSORNOTSET);\n\n    if (pos < 0)\n       throw new AppiaCursorException(AppiaCursorException.CURSORONBOTTOM);\n\n    if (pos >= sessions.length)\n       throw new AppiaCursorException(AppiaCursorException.CURSORONTOP);\n\n    return sessions[pos];\n  }\n\n  /**\n   * Get the {@link net.sf.appia.core.Layer Layer} of the {@link net.sf.appia.core.QoS QoS} stack, that\n   * corresponds to the current position in the {@link net.sf.appia.core.Channel Channel}\n   * stack.\n   *\n   * @return layer the {@link net.sf.appia.core.Layer Layer} corresponding to the current\n   * position\n   * @throws AppiaCursorException with one possible\n   * {@link net.sf.appia.core.AppiaCursorException#type type}:\n   * {@link net.sf.appia.core.AppiaCursorException#CURSORNOTSET CURSORNOTSET}\n   */\n  public Layer getLayer() throws AppiaCursorException {\n    if (pos<0)\n       throw new AppiaCursorException(AppiaCursorException.CURSORNOTSET);\n\n    return layers[pos];\n  }\n\n  /**\n   * Jumps a number of Layers. If the <i>offset</i> is positive then it will\n   * jump upwards. Otherwise it will jump downwards.\n   *\n   * @throws AppiaCursorException with two possible\n   * {@link net.sf.appia.core.AppiaCursorException#type type}:\n   * {@link net.sf.appia.core.AppiaCursorException#CURSORNOTSET CURSORNOTSET},\n   * {@link net.sf.appia.core.AppiaCursorException#INVALIDPOSITION INVALIDPOSITION}\n   */\n  public void jump(int offset) throws AppiaCursorException {\n    if (pos == NOTSET)\n      throw new AppiaCursorException(AppiaCursorException.CURSORNOTSET);\n\n    offset+=pos;\n    if ((offset < 0) || (offset >= sessions.length))\n      throw new AppiaCursorException(AppiaCursorException.INVALIDPOSITION);\n\n    pos=offset;\n  }\n\n  /**\n   * Jumps to a specified position in the Channel stack.\n   *\n   * @throws AppiaCursorException with two possible\n   * {@link net.sf.appia.core.AppiaCursorException#type type}:\n   * {@link net.sf.appia.core.AppiaCursorException#CURSORNOTSET CURSORNOTSET},\n   * {@link net.sf.appia.core.AppiaCursorException#INVALIDPOSITION INVALIDPOSITION}\n   */\n  public void jumpTo(int position) throws AppiaCursorException {\n    if (pos == NOTSET)\n      throw new AppiaCursorException(AppiaCursorException.CURSORNOTSET);\n\n    if ((position < 0) || (position >= sessions.length))\n      throw new AppiaCursorException(AppiaCursorException.INVALIDPOSITION);\n\n    pos=position;\n  }\n}", "class_id": 0, "repo": "sisbell/appia", "file": "oulipo-appia-core/src/main/java/net/sf/appia/core/ChannelCursor.java", "last_update_at": "2019-04-04T09:40:52+00:00", "question_id": "684b279240abd2df9bdefaf696f4f01eae679b96", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ChannelCursor {\n  private static final int NOTSET=-2;\n  Session[] sessions;\n  Layer[] layers;\n  Channel channel;\n  int pos=NOTSET;\n  /**\n   * Constructs a <i>ChannelCursor</i> for the specified\n   * {@link net.sf.appia.core.Channel Channel}\n   *\n   * @param channel the cursors {@link net.sf.appia.core.Channel Channel}\n   */\n  public ChannelCursor(Channel channel) {\n    this.channel=channel;\n    this.sessions=channel.sessions;\n    this.layers=channel.getQoS().layers;\n  }\n  /**\n   * Go to the {@link net.sf.appia.core.Session Session} imediatly below in the\n   * {@link net.sf.appia.core.Channel Channel} stack.\n   *\n   * @throws AppiaCursorException with two possible\n   * {@link net.sf.appia.core.AppiaCursorException#type types}:\n   * {@link net.sf.appia.core.AppiaCursorException#CURSORNOTSET CURSORNOTSET},\n   * {@link net.sf.appia.core.AppiaCursorException#CURSORONBOTTOM CURSORONBOTTOM}\n   */\n  public void down() throws AppiaCursorException {\n    if (pos == NOTSET)\n       throw new AppiaCursorException(AppiaCursorException.CURSORNOTSET);\n    if (pos < 0)\n       throw new AppiaCursorException(AppiaCursorException.CURSORONBOTTOM);\n    --pos;\n  }\n  /**\n   * Go to the {@link net.sf.appia.core.Session Session} imediatly above in the\n   * {@link net.sf.appia.core.Channel Channel} stack.\n   *\n   * @throws AppiaCursorException with two possible\n   * {@link net.sf.appia.core.AppiaCursorException#type types}:\n   * {@link net.sf.appia.core.AppiaCursorException#CURSORNOTSET CURSORNOTSET},\n   * {@link net.sf.appia.core.AppiaCursorException#CURSORONTOP CURSORONTOP}\n   */\n  public void up() throws AppiaCursorException {\n    if (pos == NOTSET)\n       throw new AppiaCursorException(AppiaCursorException.CURSORNOTSET);\n    if (pos >= sessions.length)\n       throw new AppiaCursorException(AppiaCursorException.CURSORONTOP);\n    ++pos;\n  }\n  /**\n   * Go to the highest {@link net.sf.appia.core.Session Session} in the\n   * {@link net.sf.appia.core.Channel Channel} stack.\n   */\n  public void top() {\n    pos=sessions.length-1;\n  }\n  /**\n   * Go to the lowest {@link net.sf.appia.core.Session Session} in the\n   * {@link net.sf.appia.core.Channel Channel} stack.\n   */\n  public void bottom() {\n    pos=0;\n  }\n  /**\n   * Is the cursor in a valid position, is it set ?\n   *\n   * @return <i>true</i> if the cursor is within the satck, <i>false</i> otherwise\n   */\n  public boolean isPositioned() {\n    return (pos >= 0) && (pos < sessions.length);\n  }\n  /**\n   * Set the {@link net.sf.appia.core.Session Session} for the current position in the\n   * {@link net.sf.appia.core.Channel Channel} stack.\n   *\n   * @param session the {@link net.sf.appia.core.Session Session} to set\n   * @throws AppiaCursorException with three possible\n   * {@link net.sf.appia.core.AppiaCursorException#type types}:\n   * {@link net.sf.appia.core.AppiaCursorException#CURSORNOTSET CURSORNOTSET},\n   * {@link net.sf.appia.core.AppiaCursorException#ALREADYSET ALREADYSET},\n   * {@link net.sf.appia.core.AppiaCursorException#WRONGLAYER WRONGLAYER},\n   */\n  public void setSession(Session session) throws AppiaCursorException {\n    if (pos == NOTSET)\n       throw new AppiaCursorException(AppiaCursorException.CURSORNOTSET);\n    if (sessions[pos] != null)\n       throw new AppiaCursorException(AppiaCursorException.ALREADYSET,\"Session has already been Set\");\n    if (layers[pos].getClass() != session.getLayer().getClass())\n       throw new AppiaCursorException(AppiaCursorException.WRONGLAYER,\"Wrong Session Layer\");\n    sessions[pos]=session;\n  }\n  /**\n   * Get the current {@link net.sf.appia.core.Session Session} in the\n   * {@link net.sf.appia.core.Channel Channel} stack.\n   *\n   * @return the current {@link net.sf.appia.core.Session Session}, <i>null</i> if no\n   * {@link net.sf.appia.core.Session Session} has been set for the current position\n   * @throws AppiaCursorException with three possible\n   * {@link net.sf.appia.core.AppiaCursorException#type types}:\n   * {@link net.sf.appia.core.AppiaCursorException#CURSORNOTSET CURSORNOTSET},\n   * {@link net.sf.appia.core.AppiaCursorException#CURSORONBOTTOM CURSORONBOTTOM},\n   * {@link net.sf.appia.core.AppiaCursorException#CURSORONTOP CURSORONTOP}\n   */\n  public Session getSession() throws AppiaCursorException {\n    if (pos == NOTSET)\n       throw new AppiaCursorException(AppiaCursorException.CURSORNOTSET);\n    if (pos < 0)\n       throw new AppiaCursorException(AppiaCursorException.CURSORONBOTTOM);\n    if (pos >= sessions.length)\n       throw new AppiaCursorException(AppiaCursorException.CURSORONTOP);\n    return sessions[pos];\n  }\n  /**\n   * Get the {@link net.sf.appia.core.Layer Layer} of the {@link net.sf.appia.core.QoS QoS} stack, that\n   * corresponds to the current position in the {@link net.sf.appia.core.Channel Channel}\n   * stack.\n   *\n   * @return layer the {@link net.sf.appia.core.Layer Layer} corresponding to the current\n   * position\n   * @throws AppiaCursorException with one possible\n   * {@link net.sf.appia.core.AppiaCursorException#type type}:\n   * {@link net.sf.appia.core.AppiaCursorException#CURSORNOTSET CURSORNOTSET}\n   */\n  public Layer getLayer() throws AppiaCursorException {\n    if (pos<0)\n       throw new AppiaCursorException(AppiaCursorException.CURSORNOTSET);\n    return layers[pos];\n  }\n  /**\n   * Jumps a number of Layers. If the <i>offset</i> is positive then it will\n   * jump upwards. Otherwise it will jump downwards.\n   *\n   * @throws AppiaCursorException with two possible\n   * {@link net.sf.appia.core.AppiaCursorException#type type}:\n   * {@link net.sf.appia.core.AppiaCursorException#CURSORNOTSET CURSORNOTSET},\n   * {@link net.sf.appia.core.AppiaCursorException#INVALIDPOSITION INVALIDPOSITION}\n   */\n  public void jump(int offset) throws AppiaCursorException {\n    if (pos == NOTSET)\n      throw new AppiaCursorException(AppiaCursorException.CURSORNOTSET);\n    offset+=pos;\n    if ((offset < 0) || (offset >= sessions.length))\n      throw new AppiaCursorException(AppiaCursorException.INVALIDPOSITION);\n    pos=offset;\n  }\n  /**\n   * Jumps to a specified position in the Channel stack.\n   *\n   * @throws AppiaCursorException with two possible\n   * {@link net.sf.appia.core.AppiaCursorException#type type}:\n   * {@link net.sf.appia.core.AppiaCursorException#CURSORNOTSET CURSORNOTSET},\n   * {@link net.sf.appia.core.AppiaCursorException#INVALIDPOSITION INVALIDPOSITION}\n   */\n  public void jumpTo(int position) throws AppiaCursorException {\n    if (pos == NOTSET)\n      throw new AppiaCursorException(AppiaCursorException.CURSORNOTSET);\n    if ((position < 0) || (position >= sessions.length))\n      throw new AppiaCursorException(AppiaCursorException.INVALIDPOSITION);\n    pos=position;\n  }\n"]]}
{"hexsha": "3517d91799527d2b981a09edb8bbf4c9059c7e6f", "ext": "java", "lang": "Java", "content": "public class HCF_const_call\n{\n  public static void main(String args[]) throws IOException\n  {\n      DataInputStream in=new DataInputStream(System.in);\n      System.out.println(\"enetr 1st no.\");\n      int n1=Integer.parseInt(in.readLine());\n      System.out.println(\"enetr 2nd no.\");\n      int n2=Integer.parseInt(in.readLine());\n      HCF_const h=new HCF_const(n1,n2);\n      int r=h.cal();\n      System.out.println(\"HCF = \"+r);\n    }\n}", "class_id": 0, "repo": "SayanGhoshBDA/code-backup", "file": "java_backup/my java/Mainak Roy/HCF_const_call.java", "last_update_at": "2019-05-08T10:09:52+00:00", "question_id": "3517d91799527d2b981a09edb8bbf4c9059c7e6f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HCF_const_call\n{\n  public static void main(String args[]) throws IOException\n  {\n      DataInputStream in=new DataInputStream(System.in);\n      System.out.println(\"enetr 1st no.\");\n      int n1=Integer.parseInt(in.readLine());\n      System.out.println(\"enetr 2nd no.\");\n      int n2=Integer.parseInt(in.readLine());\n      HCF_const h=new HCF_const(n1,n2);\n      int r=h.cal();\n      System.out.println(\"HCF = \"+r);\n    }\n"]]}
{"hexsha": "0101e6e78661e2797114a2be1fe852ba952bb5c0", "ext": "java", "lang": "Java", "content": "public class DimensionTest {\n\n    @After\n    public void tearDown() throws Exception {}\n\n    @Test\n    public void testAspect() {\n        AspectRatioDimension dim4x3 = new AspectRatioDimension(4, 3);\n        assertTrue(dim4x3.check(640, 480));\n        assertTrue(dim4x3.check(480, 360));\n        assertFalse(dim4x3.check(640, 360));\n        AspectRatioDimension dim16x9 = new AspectRatioDimension(16, 9);\n        assertFalse(dim16x9.check(640, 480));\n        assertFalse(dim16x9.check(480, 360));\n        assertTrue(dim16x9.check(640, 360));\n    }\n\n}", "class_id": 0, "repo": "opencmo/lot49", "file": "src/test/java/com/enremmeta/rtb/test/cases/DimensionTest.java", "last_update_at": "2019-07-04T03:57:41+00:00", "question_id": "0101e6e78661e2797114a2be1fe852ba952bb5c0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DimensionTest {\n    @After\n    public void tearDown() throws Exception {}\n    @Test\n    public void testAspect() {\n        AspectRatioDimension dim4x3 = new AspectRatioDimension(4, 3);\n        assertTrue(dim4x3.check(640, 480));\n        assertTrue(dim4x3.check(480, 360));\n        assertFalse(dim4x3.check(640, 360));\n        AspectRatioDimension dim16x9 = new AspectRatioDimension(16, 9);\n        assertFalse(dim16x9.check(640, 480));\n        assertFalse(dim16x9.check(480, 360));\n        assertTrue(dim16x9.check(640, 360));\n    }\n"]]}
{"hexsha": "abbf2824cf970392193234012de529c775bebec8", "ext": "java", "lang": "Java", "content": "public class DatabaseHelper extends OrmLiteSqliteOpenHelper {\n\n    // name of the database file for your application -- change to something appropriate for your app\n    private static final String DATABASE_NAME = \"ormlite.db\";\n    // any time you make changes to your database objects, you may have to increase the database version\n    private static final int DATABASE_VERSION = 1;\n\n    // the DAO objects\n    private Dao<AddressBook, Integer> addressBookDao = null;\n    private Dao<AddressItem, Integer> addressItemDao = null;\n    private Dao<Contact, Integer> contactDao = null;\n    private Dao<SimpleAddressItem, Integer> simpleAddressDao = null;\n\n    public DatabaseHelper(Context context) {\n        super(context, DATABASE_NAME, null, DATABASE_VERSION, R.raw.ormlite_config);\n    }\n\n    /**\n     * This is called when the database is first created. Usually you should call createTable statements here to create\n     * the tables that will store your data.\n     */\n    @Override\n    public void onCreate(SQLiteDatabase db, ConnectionSource connectionSource) {\n        try {\n            Log.i(DatabaseHelper.class.getName(), \"onCreate\");\n            TableUtils.createTable(connectionSource, AddressBook.class);\n            TableUtils.createTable(connectionSource, AddressItem.class);\n            TableUtils.createTable(connectionSource, Contact.class);\n            TableUtils.createTable(connectionSource, SimpleAddressItem.class);\n        } catch (SQLException e) {\n            Log.e(DatabaseHelper.class.getName(), \"Can't create database\", e);\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * This is called when your application is upgraded and it has a higher version number. This allows you to adjust\n     * the various data to match the new version number.\n     */\n    @Override\n    public void onUpgrade(SQLiteDatabase db, ConnectionSource connectionSource, int oldVersion, int newVersion) {\n        try {\n            Log.i(DatabaseHelper.class.getName(), \"onUpgrade\");\n            TableUtils.dropTable(connectionSource, AddressBook.class, true);\n            TableUtils.dropTable(connectionSource, AddressItem.class, true);\n            TableUtils.dropTable(connectionSource, Contact.class, true);\n            TableUtils.dropTable(connectionSource, SimpleAddressItem.class, true);\n            // after we drop the old databases, we create the new ones\n            onCreate(db, connectionSource);\n        } catch (SQLException e) {\n            Log.e(DatabaseHelper.class.getName(), \"Can't drop databases\", e);\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Returns the Database Access Object (DAO) for our AddressBook class\n     */\n    public Dao<AddressBook, Integer> getAddressBookDao() throws SQLException {\n        if (addressBookDao == null) {\n            addressBookDao = getDao(AddressBook.class);\n        }\n        return addressBookDao;\n    }\n\n    /**\n     * Returns the Database Access Object (DAO) for our AddressItem class\n     */\n    public Dao<AddressItem, Integer> getAddressItemDao() throws SQLException {\n        if (addressItemDao == null) {\n            addressItemDao = getDao(AddressItem.class);\n        }\n        return addressItemDao;\n    }\n\n    /**\n     * Returns the Database Access Object (DAO) for our Contact class\n     */\n    public Dao<Contact, Integer> getContactDao() throws SQLException {\n        if (contactDao == null) {\n            contactDao = getDao(Contact.class);\n        }\n        return contactDao;\n    }\n\n    /**\n     * Returns the Database Access Object (DAO) for our SimpleAddressItem class\n     */\n    public Dao<SimpleAddressItem, Integer> getSimpleAddressItemDao() throws SQLException {\n        if (simpleAddressDao == null) {\n            simpleAddressDao = getDao(SimpleAddressItem.class);\n        }\n        return simpleAddressDao;\n    }\n\n    /**\n     * Close the database connections and clear any cached DAOs.\n     */\n    @Override\n    public void close() {\n        super.close();\n        addressBookDao = null;\n        addressItemDao = null;\n        contactDao = null;\n        simpleAddressDao = null;\n   }\n}", "class_id": 0, "repo": "agrosner/AndroidDatabaseLibraryComparison", "file": "app/src/main/java/com/raizlabs/android/databasecomparison/ormlite/DatabaseHelper.java", "last_update_at": "2019-01-23T08:59:58+00:00", "question_id": "abbf2824cf970392193234012de529c775bebec8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DatabaseHelper extends OrmLiteSqliteOpenHelper {\n    // name of the database file for your application -- change to something appropriate for your app\n    private static final String DATABASE_NAME = \"ormlite.db\";\n    // any time you make changes to your database objects, you may have to increase the database version\n    private static final int DATABASE_VERSION = 1;\n    // the DAO objects\n    private Dao<AddressBook, Integer> addressBookDao = null;\n    private Dao<AddressItem, Integer> addressItemDao = null;\n    private Dao<Contact, Integer> contactDao = null;\n    private Dao<SimpleAddressItem, Integer> simpleAddressDao = null;\n    public DatabaseHelper(Context context) {\n        super(context, DATABASE_NAME, null, DATABASE_VERSION, R.raw.ormlite_config);\n    }\n    /**\n     * This is called when the database is first created. Usually you should call createTable statements here to create\n     * the tables that will store your data.\n     */\n    @Override\n    public void onCreate(SQLiteDatabase db, ConnectionSource connectionSource) {\n        try {\n            Log.i(DatabaseHelper.class.getName(), \"onCreate\");\n            TableUtils.createTable(connectionSource, AddressBook.class);\n            TableUtils.createTable(connectionSource, AddressItem.class);\n            TableUtils.createTable(connectionSource, Contact.class);\n            TableUtils.createTable(connectionSource, SimpleAddressItem.class);\n        } catch (SQLException e) {\n            Log.e(DatabaseHelper.class.getName(), \"Can't create database\", e);\n            throw new RuntimeException(e);\n        }\n    }\n    /**\n     * This is called when your application is upgraded and it has a higher version number. This allows you to adjust\n     * the various data to match the new version number.\n     */\n    @Override\n    public void onUpgrade(SQLiteDatabase db, ConnectionSource connectionSource, int oldVersion, int newVersion) {\n        try {\n            Log.i(DatabaseHelper.class.getName(), \"onUpgrade\");\n            TableUtils.dropTable(connectionSource, AddressBook.class, true);\n            TableUtils.dropTable(connectionSource, AddressItem.class, true);\n            TableUtils.dropTable(connectionSource, Contact.class, true);\n            TableUtils.dropTable(connectionSource, SimpleAddressItem.class, true);\n            // after we drop the old databases, we create the new ones\n            onCreate(db, connectionSource);\n        } catch (SQLException e) {\n            Log.e(DatabaseHelper.class.getName(), \"Can't drop databases\", e);\n            throw new RuntimeException(e);\n        }\n    }\n    /**\n     * Returns the Database Access Object (DAO) for our AddressBook class\n     */\n    public Dao<AddressBook, Integer> getAddressBookDao() throws SQLException {\n        if (addressBookDao == null) {\n            addressBookDao = getDao(AddressBook.class);\n        }\n        return addressBookDao;\n    }\n    /**\n     * Returns the Database Access Object (DAO) for our AddressItem class\n     */\n    public Dao<AddressItem, Integer> getAddressItemDao() throws SQLException {\n        if (addressItemDao == null) {\n            addressItemDao = getDao(AddressItem.class);\n        }\n        return addressItemDao;\n    }\n    /**\n     * Returns the Database Access Object (DAO) for our Contact class\n     */\n    public Dao<Contact, Integer> getContactDao() throws SQLException {\n        if (contactDao == null) {\n            contactDao = getDao(Contact.class);\n        }\n        return contactDao;\n    }\n    /**\n     * Returns the Database Access Object (DAO) for our SimpleAddressItem class\n     */\n    public Dao<SimpleAddressItem, Integer> getSimpleAddressItemDao() throws SQLException {\n        if (simpleAddressDao == null) {\n            simpleAddressDao = getDao(SimpleAddressItem.class);\n        }\n        return simpleAddressDao;\n    }\n    /**\n     * Close the database connections and clear any cached DAOs.\n     */\n    @Override\n    public void close() {\n        super.close();\n        addressBookDao = null;\n        addressItemDao = null;\n        contactDao = null;\n        simpleAddressDao = null;\n   }\n"]]}
{"hexsha": "1506743c83de6e6f5d55d5049dbd1dd34d803cd6", "ext": "java", "lang": "Java", "content": "@Component\n@Slf4j\npublic class JsonMarshaller {\n    private final ObjectMapper objectMapper;\n\n    public JsonMarshaller(ObjectMapper objectMapper) {\n        this.objectMapper = objectMapper;\n    }\n\n\n    public String marshal(Object object) {\n        String json = \"\";\n        try {\n            json = objectMapper.writeValueAsString(object);\n        } catch (JsonProcessingException e) {\n            log.info(e.getMessage(), e);\n        }\n\n        return json;\n    }\n\n    public <T extends Object> T unmarshal(String json, Class<?> clazz) {\n        Object object = null;\n\n        try {\n            object = objectMapper.readValue(json, clazz);\n        } catch (IOException e) {\n            log.info(e.getMessage(), e);\n        }\n\n        return (T) object;\n    }\n\n    public <T> List<T> unmarshalList(String json, Class<?> clazz) {\n        List<T> objects = new ArrayList<>();\n\n        CollectionType type = objectMapper.getTypeFactory().constructCollectionType(List.class, clazz);\n        try {\n            objects = objectMapper.readValue(json, type);\n        } catch (IOException e) {\n            log.info(e.getMessage(), e);\n        }\n\n        return objects;\n    }\n\n}", "class_id": 0, "repo": "mikebryantky/checkregister-backend", "file": "src/main/java/com/mikebryant/checkregister/config/JsonMarshaller.java", "last_update_at": "2019-11-11T00:32:00+00:00", "question_id": "1506743c83de6e6f5d55d5049dbd1dd34d803cd6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\n@Slf4j\npublic class JsonMarshaller {\n    private final ObjectMapper objectMapper;\n    public JsonMarshaller(ObjectMapper objectMapper) {\n        this.objectMapper = objectMapper;\n    }\n    public String marshal(Object object) {\n        String json = \"\";\n        try {\n            json = objectMapper.writeValueAsString(object);\n        } catch (JsonProcessingException e) {\n            log.info(e.getMessage(), e);\n        }\n        return json;\n    }\n    public <T extends Object> T unmarshal(String json, Class<?> clazz) {\n        Object object = null;\n        try {\n            object = objectMapper.readValue(json, clazz);\n        } catch (IOException e) {\n            log.info(e.getMessage(), e);\n        }\n        return (T) object;\n    }\n    public <T> List<T> unmarshalList(String json, Class<?> clazz) {\n        List<T> objects = new ArrayList<>();\n        CollectionType type = objectMapper.getTypeFactory().constructCollectionType(List.class, clazz);\n        try {\n            objects = objectMapper.readValue(json, type);\n        } catch (IOException e) {\n            log.info(e.getMessage(), e);\n        }\n        return objects;\n    }\n"]]}
{"hexsha": "be35ec8e1bcf9d063885955e73ae1e2702227622", "ext": "java", "lang": "Java", "content": "public class NgConfiguration {\n    private static final String PAGE_LOAD_TIMEOUT = \"PAGE_LOAD_TIMEOUT\";\n    private static final String WEBDRIVER_TIMEOUT = \"WEBDRIVER_TIMEOUT\";\n    private static final String ANGULAR_TIMEOUT = \"ANGULAR_TIMEOUT\";\n    private static final String PAGE_SYNC_TIMEOUT = \"PAGE_SYNC_TIMEOUT\";\n    public static final long DEFAULT_PAGE_LOAD_TIMEOUT = 10 * 1000;\n    public static final long DEFAULT_PAGE_SYNC_TIMEOUT = 11 * 1000;\n    public static final long DEFAULT_ANGULAR_TIMEOUT = 10 * 1000;\n    public static final long DEFAULT_WEBDRIVER_TIMEOUT = 11 * 1000;\n    private Properties properties;\n\n    public NgConfiguration(URL url) {\n        properties = new Properties();\n        loadConfig(url);\n    }\n\n    public long getPageLoadTimeout() {\n        return getProperty(PAGE_LOAD_TIMEOUT);\n    }\n\n    public long getPageSyncTimeout() {\n        return getProperty(PAGE_SYNC_TIMEOUT);\n    }\n\n    public long getAngularTimeout() {\n        return getProperty(ANGULAR_TIMEOUT);\n    }\n\n    public long getWebDriverTimeout() {\n        return getProperty(WEBDRIVER_TIMEOUT);\n    }\n\n    private long getProperty(String key) {\n        if (properties == null)\n            loadDefaultProperties();\n        return Long.parseLong((String) properties.get(key));\n    }\n\n    private void loadDefaultProperties() {\n        setProperty(PAGE_LOAD_TIMEOUT, DEFAULT_PAGE_LOAD_TIMEOUT);\n        setProperty(PAGE_SYNC_TIMEOUT, DEFAULT_PAGE_SYNC_TIMEOUT);\n        setProperty(ANGULAR_TIMEOUT, DEFAULT_ANGULAR_TIMEOUT);\n        setProperty(WEBDRIVER_TIMEOUT, DEFAULT_WEBDRIVER_TIMEOUT);\n    }\n\n    private void setProperty(String key, long value) {\n        properties.setProperty(key, \"\" + value);\n    }\n\n    public void loadConfig(URL url) {\n        loadDefaultProperties();\n        if (url != null)\n            try {\n                properties.load(url.openStream());\n            } catch (IOException e) {\n                new RuntimeException(e);\n            }\n    }\n}", "class_id": 0, "repo": "caarlos0-graveyard/jProtractor", "file": "src/main/java/com/jprotractor/NgConfiguration.java", "last_update_at": "2019-10-15T04:18:58+00:00", "question_id": "be35ec8e1bcf9d063885955e73ae1e2702227622", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NgConfiguration {\n    private static final String PAGE_LOAD_TIMEOUT = \"PAGE_LOAD_TIMEOUT\";\n    private static final String WEBDRIVER_TIMEOUT = \"WEBDRIVER_TIMEOUT\";\n    private static final String ANGULAR_TIMEOUT = \"ANGULAR_TIMEOUT\";\n    private static final String PAGE_SYNC_TIMEOUT = \"PAGE_SYNC_TIMEOUT\";\n    public static final long DEFAULT_PAGE_LOAD_TIMEOUT = 10 * 1000;\n    public static final long DEFAULT_PAGE_SYNC_TIMEOUT = 11 * 1000;\n    public static final long DEFAULT_ANGULAR_TIMEOUT = 10 * 1000;\n    public static final long DEFAULT_WEBDRIVER_TIMEOUT = 11 * 1000;\n    private Properties properties;\n    public NgConfiguration(URL url) {\n        properties = new Properties();\n        loadConfig(url);\n    }\n    public long getPageLoadTimeout() {\n        return getProperty(PAGE_LOAD_TIMEOUT);\n    }\n    public long getPageSyncTimeout() {\n        return getProperty(PAGE_SYNC_TIMEOUT);\n    }\n    public long getAngularTimeout() {\n        return getProperty(ANGULAR_TIMEOUT);\n    }\n    public long getWebDriverTimeout() {\n        return getProperty(WEBDRIVER_TIMEOUT);\n    }\n    private long getProperty(String key) {\n        if (properties == null)\n            loadDefaultProperties();\n        return Long.parseLong((String) properties.get(key));\n    }\n    private void loadDefaultProperties() {\n        setProperty(PAGE_LOAD_TIMEOUT, DEFAULT_PAGE_LOAD_TIMEOUT);\n        setProperty(PAGE_SYNC_TIMEOUT, DEFAULT_PAGE_SYNC_TIMEOUT);\n        setProperty(ANGULAR_TIMEOUT, DEFAULT_ANGULAR_TIMEOUT);\n        setProperty(WEBDRIVER_TIMEOUT, DEFAULT_WEBDRIVER_TIMEOUT);\n    }\n    private void setProperty(String key, long value) {\n        properties.setProperty(key, \"\" + value);\n    }\n    public void loadConfig(URL url) {\n        loadDefaultProperties();\n        if (url != null)\n            try {\n                properties.load(url.openStream());\n            } catch (IOException e) {\n                new RuntimeException(e);\n            }\n    }\n"]]}
{"hexsha": "17c1a1b635eee45481c2266cf34fcc83bf048ff1", "ext": "java", "lang": "Java", "content": "public class URIUtil {\n    \n    /**\n     * Builds a URI as a string from a set of components. Embedded parameters within\n     * the path segments are replaced with their values taken from paramValues. Matrix\n     * URI parameters are added to the end of the corresponding path segment. E.g.\n     * \n     * <pre>  pathSegments = {\"{p1}/xyzzy/{p2}\", \"{p3}\"}\n     *   matrixParams = {{\"p4\"}, {}}\n     *   paramValues = {\"p1\"=>\"v1\", \"p2\"=>\"v2\", \"p3\"=>\"v3\", \"p4\"=>\"v4\"}</pre>\n     * \n     * would result in the following URI\n     * \n     * <pre>  v1/xyzzy/v2;p4=v4/v3</pre>\n     * @return The URI resulting from merging the URI components.\n     * @param pathSegments a list of path segments\n     * @param matrixParams a list of sets of matrix parameter names\n     * @param paramValues a map of parameter name to value, values can be of any class, the object's \n     * toString method is used to render a stringified value\n     */\n    public static String buildURI(List<String> pathSegments, List<List<String>> matrixParams, Map<String, Object> paramValues) {\n        ArrayList<String> merged = new ArrayList<String>();\n        for (int i=0; i< pathSegments.size(); i++) {\n            List<String> associatedMatrixParams = matrixParams==null ? null : matrixParams.get(i);\n            PathSegment segment = new PathSegment(pathSegments.get(i), associatedMatrixParams);\n            merged.add(segment.evaluate(paramValues));\n        }\n        return concatenate(merged);\n    }\n    \n    /**\n     * Join a list of URI fragments into a URI using '/' as a separator.\n     * @param components the list of URI fragments\n     * @return the resulting URI\n     */\n    public static String concatenate(List<String> components) {\n        StringBuffer buf = new StringBuffer();\n        \n        for (int i=0; i<components.size(); i++) {\n            if (i>0 && buf.charAt(buf.length()-1)!='/' && components.get(i).charAt(0)!='/')\n                buf.append('/');\n            buf.append(components.get(i));\n        }\n        \n        return buf.toString();\n    }\n    \n    /**\n     * Add a query string to a URI\n     * @param uri the URI\n     * @param queryString the query string\n     * @throws java.net.URISyntaxException if the resulting URI is malformed\n     * @return the resulting URI\n     */\n    public static String appendQueryString(URI uri, String queryString) throws URISyntaxException {\n        URI newURI = new URI(uri.getScheme(), uri.getUserInfo(), uri.getHost(),\n                uri.getPort(), uri.getPath(), queryString, uri.getFragment());\n        return newURI.toString();\n    }\n    \n    /**\n     * Add a query string to a URI\n     * \n     * @return the resulting URI\n     * @param uri the URI\n     * @param queryString the query string\n     */\n    public static String appendQueryString(String uri, String queryString) {\n        if (queryString==null || queryString.length()==0)\n            return uri;\n        else if (uri.endsWith(\"?\"))\n            return uri+queryString;\n        else\n            return uri+\"?\"+queryString;\n    }\n    /**\n     * Builds a URI query string from a map of keys and values.\n     * @param queryParams a map of keys and their values. A value may be a <code>List</code> for repeating values.\n     * @return the resulting query string\n     */\n    public static String buildQueryString(Map<String, Object> queryParams) {\n        StringBuffer buf = new StringBuffer();\n        boolean firstParam = true;\n        try {\n            for (Map.Entry<String, Object> entry: queryParams.entrySet()) {\n                if (entry.getValue() == null)\n                    continue;\n                if (entry.getValue() instanceof List<?>) {\n                    List<?> values = (List<?>)entry.getValue();\n                    for (Object value: values) {\n                        if (!firstParam) {\n                            buf.append('&');\n                        }\n                        buf.append(entry.getKey());\n                        buf.append('=');\n                        buf.append(java.net.URLEncoder.encode(value.toString(), \"utf-8\"));\n                        firstParam = false;\n                    }\n                }\n                else {\n                    if (!firstParam) {\n                        buf.append('&');\n                    }\n                    buf.append(entry.getKey());\n                    buf.append('=');\n                    buf.append(java.net.URLEncoder.encode(entry.getValue().toString(), \"utf-8\"));\n                    firstParam = false;\n                }\n            } \n        } catch (UnsupportedEncodingException ex) {\n            ex.printStackTrace();\n        } \n        return buf.toString();\n    }\n}", "class_id": 0, "repo": "consulo/consulo-maven", "file": "plugin/src/main/java/org/jvnet/ws/wadl/util/URIUtil.java", "last_update_at": "2019-08-18T21:34:44+00:00", "question_id": "17c1a1b635eee45481c2266cf34fcc83bf048ff1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class URIUtil {\n    /**\n     * Builds a URI as a string from a set of components. Embedded parameters within\n     * the path segments are replaced with their values taken from paramValues. Matrix\n     * URI parameters are added to the end of the corresponding path segment. E.g.\n     * \n     * <pre>  pathSegments = {\"{p1}/xyzzy/{p2}\", \"{p3}\"}\n     *   matrixParams = {{\"p4\"}, {}}\n     *   paramValues = {\"p1\"=>\"v1\", \"p2\"=>\"v2\", \"p3\"=>\"v3\", \"p4\"=>\"v4\"}</pre>\n     * \n     * would result in the following URI\n     * \n     * <pre>  v1/xyzzy/v2;p4=v4/v3</pre>\n     * @return The URI resulting from merging the URI components.\n     * @param pathSegments a list of path segments\n     * @param matrixParams a list of sets of matrix parameter names\n     * @param paramValues a map of parameter name to value, values can be of any class, the object's \n     * toString method is used to render a stringified value\n     */\n    public static String buildURI(List<String> pathSegments, List<List<String>> matrixParams, Map<String, Object> paramValues) {\n        ArrayList<String> merged = new ArrayList<String>();\n        for (int i=0; i< pathSegments.size(); i++) {\n            List<String> associatedMatrixParams = matrixParams==null ? null : matrixParams.get(i);\n            PathSegment segment = new PathSegment(pathSegments.get(i), associatedMatrixParams);\n            merged.add(segment.evaluate(paramValues));\n        }\n        return concatenate(merged);\n    }\n    /**\n     * Join a list of URI fragments into a URI using '/' as a separator.\n     * @param components the list of URI fragments\n     * @return the resulting URI\n     */\n    public static String concatenate(List<String> components) {\n        StringBuffer buf = new StringBuffer();\n        for (int i=0; i<components.size(); i++) {\n            if (i>0 && buf.charAt(buf.length()-1)!='/' && components.get(i).charAt(0)!='/')\n                buf.append('/');\n            buf.append(components.get(i));\n        }\n        return buf.toString();\n    }\n    /**\n     * Add a query string to a URI\n     * @param uri the URI\n     * @param queryString the query string\n     * @throws java.net.URISyntaxException if the resulting URI is malformed\n     * @return the resulting URI\n     */\n    public static String appendQueryString(URI uri, String queryString) throws URISyntaxException {\n        URI newURI = new URI(uri.getScheme(), uri.getUserInfo(), uri.getHost(),\n                uri.getPort(), uri.getPath(), queryString, uri.getFragment());\n        return newURI.toString();\n    }\n    /**\n     * Add a query string to a URI\n     * \n     * @return the resulting URI\n     * @param uri the URI\n     * @param queryString the query string\n     */\n    public static String appendQueryString(String uri, String queryString) {\n        if (queryString==null || queryString.length()==0)\n            return uri;\n        else if (uri.endsWith(\"?\"))\n            return uri+queryString;\n        else\n            return uri+\"?\"+queryString;\n    }\n    /**\n     * Builds a URI query string from a map of keys and values.\n     * @param queryParams a map of keys and their values. A value may be a <code>List</code> for repeating values.\n     * @return the resulting query string\n     */\n    public static String buildQueryString(Map<String, Object> queryParams) {\n        StringBuffer buf = new StringBuffer();\n        boolean firstParam = true;\n        try {\n            for (Map.Entry<String, Object> entry: queryParams.entrySet()) {\n                if (entry.getValue() == null)\n                    continue;\n                if (entry.getValue() instanceof List<?>) {\n                    List<?> values = (List<?>)entry.getValue();\n                    for (Object value: values) {\n                        if (!firstParam) {\n                            buf.append('&');\n                        }\n                        buf.append(entry.getKey());\n                        buf.append('=');\n                        buf.append(java.net.URLEncoder.encode(value.toString(), \"utf-8\"));\n                        firstParam = false;\n                    }\n                }\n                else {\n                    if (!firstParam) {\n                        buf.append('&');\n                    }\n                    buf.append(entry.getKey());\n                    buf.append('=');\n                    buf.append(java.net.URLEncoder.encode(entry.getValue().toString(), \"utf-8\"));\n                    firstParam = false;\n                }\n            } \n        } catch (UnsupportedEncodingException ex) {\n            ex.printStackTrace();\n        } \n        return buf.toString();\n    }\n"]]}
{"hexsha": "bf6b88c597bbc2599d68689fd7edfb1fa27724c7", "ext": "java", "lang": "Java", "content": "public class LeadingSpan extends RelativeLineHeightSpan {\n    public LeadingSpan(float scalar) {\n        super(scalar);\n    }\n\n    @Override public void chooseHeight(CharSequence text, int start, int end, int spanstartv, int v,\n                                       Paint.FontMetricsInt metrics) {\n        // Only operate on the first line (see IconMarginSpan, DrawableMarginSpan). This will affect\n        // all following lines through the metrics parameter output\n        if (start == ((Spanned) text).getSpanStart(this)) {\n            // Don't change the state of metrics until all calculations are performed.\n            int scaledAscender = (int) scaledAscender(metrics);\n            int scaledDescender = (int) scaledDescender(metrics);\n\n            metrics.ascent = scaledAscender;\n            metrics.descent = scaledDescender;\n        }\n    }\n}", "class_id": 0, "repo": "pprathameshmore/apps-android-wikipedia", "file": "app/src/main/java/org/wikipedia/richtext/LeadingSpan.java", "last_update_at": "2019-04-21T12:25:47+00:00", "question_id": "bf6b88c597bbc2599d68689fd7edfb1fa27724c7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LeadingSpan extends RelativeLineHeightSpan {\n    public LeadingSpan(float scalar) {\n        super(scalar);\n    }\n    @Override public void chooseHeight(CharSequence text, int start, int end, int spanstartv, int v,\n                                       Paint.FontMetricsInt metrics) {\n        // Only operate on the first line (see IconMarginSpan, DrawableMarginSpan). This will affect\n        // all following lines through the metrics parameter output\n        if (start == ((Spanned) text).getSpanStart(this)) {\n            // Don't change the state of metrics until all calculations are performed.\n            int scaledAscender = (int) scaledAscender(metrics);\n            int scaledDescender = (int) scaledDescender(metrics);\n            metrics.ascent = scaledAscender;\n            metrics.descent = scaledDescender;\n        }\n    }\n"]]}
{"hexsha": "53fda02fabe1b6c43a6b6582833db1aec541d79f", "ext": "java", "lang": "Java", "content": "public class LastIndexOf extends AbstractNativeFunction {\n\n    public LastIndexOf(GlobalObject globalObject) {\n        super(globalObject, \"searchElement\");\n    }\n\n    @Override\n    public Object call(ExecutionContext context, Object self, Object... args) {\n        // 15.4.4.14\n        JSObject o = Types.toObject(context, self);\n        long len = Types.toUint32(context, o.get(context, \"length\"));\n\n        if (len == 0) {\n            return -1L;\n        }\n\n        long n = len;\n        if (args.length >= 2) {\n            if (args[1] != Types.UNDEFINED) {\n                n = Types.toInteger(context, args[1]);\n            } else {\n                n = (long)Double.NaN;  // http://es5.github.com/rev1/x15.4.4.15.html\n            }\n        }\n\n        long k = Math.min(n, len-1);\n        if (n < 0) {\n            k = (len - Math.abs(n));\n        }\n\n        while ( k >= 0 ) {\n            if (o.hasProperty(context, \"\" +k )) {\n                Object element = o.get(context, \"\"+k);\n                if ( Types.compareStrictEquality(context, args[0], element)) {\n                    return k;\n                }\n            }\n            --k;\n        }\n        \n        return -1L;\n    }\n    \n    @Override\n    public void setFileName() {\n        this.filename = \"org/dynjs/runtime/builtins/types/array/prototype/LastIndexOf.java\";\n    }\n\n    @Override\n    public void setupDebugContext() {\n        this.debugContext = \"<native function: lastIndexOf>\";\n    }\n\n}", "class_id": 0, "repo": "guilhermejccavalcanti/dynjs", "file": "src/main/java/org/dynjs/runtime/builtins/types/array/prototype/LastIndexOf.java", "last_update_at": "2019-04-22T08:49:22+00:00", "question_id": "53fda02fabe1b6c43a6b6582833db1aec541d79f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LastIndexOf extends AbstractNativeFunction {\n    public LastIndexOf(GlobalObject globalObject) {\n        super(globalObject, \"searchElement\");\n    }\n    @Override\n    public Object call(ExecutionContext context, Object self, Object... args) {\n        // 15.4.4.14\n        JSObject o = Types.toObject(context, self);\n        long len = Types.toUint32(context, o.get(context, \"length\"));\n        if (len == 0) {\n            return -1L;\n        }\n        long n = len;\n        if (args.length >= 2) {\n            if (args[1] != Types.UNDEFINED) {\n                n = Types.toInteger(context, args[1]);\n            } else {\n                n = (long)Double.NaN;  // http://es5.github.com/rev1/x15.4.4.15.html\n            }\n        }\n        long k = Math.min(n, len-1);\n        if (n < 0) {\n            k = (len - Math.abs(n));\n        }\n        while ( k >= 0 ) {\n            if (o.hasProperty(context, \"\" +k )) {\n                Object element = o.get(context, \"\"+k);\n                if ( Types.compareStrictEquality(context, args[0], element)) {\n                    return k;\n                }\n            }\n            --k;\n        }\n        return -1L;\n    }\n    @Override\n    public void setFileName() {\n        this.filename = \"org/dynjs/runtime/builtins/types/array/prototype/LastIndexOf.java\";\n    }\n    @Override\n    public void setupDebugContext() {\n        this.debugContext = \"<native function: lastIndexOf>\";\n    }\n"]]}
{"hexsha": "4fe5e7988b9ef5ef61e7f7584eafd33cd434ea44", "ext": "java", "lang": "Java", "content": "public abstract class AbstractNetty4RawSocketServer extends AbstractNetty4SocketServer {\n\n    @Override\n    protected BElement handleIncomingMessage(String channelId, Object msg) throws Exception {\n        return (BElement) msg;\n    }\n\n    @Override\n    protected void onInitChannel(SocketChannel socketChannel) {\n        Netty4RawChannelPreset.applyLengthPrepender(socketChannel);\n        Netty4RawChannelPreset.applyBElementCodec(socketChannel, //\n                getConfigs().getString(\"format\", null), //\n                getConfigs().getBoolean(\"nativeBytesEnabled\", false));\n    }\n\n    @Override\n    public final ChannelFuture send(String routingId, BElement data) {\n        Channel channel = this.getChannel(routingId);\n        if (channel != null) {\n            if (data == null) {\n                channel.close();\n            } else {\n                return channel.writeAndFlush(data).addListener(ChannelFutureListener.CLOSE);\n            }\n        }\n        return null;\n    }\n}", "class_id": 0, "repo": "gridgo/gridgo--community", "file": "connectors/gridgo-netty4/src/main/java/io/gridgo/socket/netty4/raw/AbstractNetty4RawSocketServer.java", "last_update_at": "2019-06-29T04:45:47+00:00", "question_id": "4fe5e7988b9ef5ef61e7f7584eafd33cd434ea44", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class AbstractNetty4RawSocketServer extends AbstractNetty4SocketServer {\n    @Override\n    protected BElement handleIncomingMessage(String channelId, Object msg) throws Exception {\n        return (BElement) msg;\n    }\n    @Override\n    protected void onInitChannel(SocketChannel socketChannel) {\n        Netty4RawChannelPreset.applyLengthPrepender(socketChannel);\n        Netty4RawChannelPreset.applyBElementCodec(socketChannel, //\n                getConfigs().getString(\"format\", null), //\n                getConfigs().getBoolean(\"nativeBytesEnabled\", false));\n    }\n    @Override\n    public final ChannelFuture send(String routingId, BElement data) {\n        Channel channel = this.getChannel(routingId);\n        if (channel != null) {\n            if (data == null) {\n                channel.close();\n            } else {\n                return channel.writeAndFlush(data).addListener(ChannelFutureListener.CLOSE);\n            }\n        }\n        return null;\n    }\n"]]}
{"hexsha": "d77bea1350674b6acd4fb00409b918543b03efe7", "ext": "java", "lang": "Java", "content": "public class SameTree {\n    public class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n        TreeNode(int x) { val = x; }\n    }\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        } else if (p == null) {\n            return false;\n        } else if (q == null) {\n            return false;\n        }\n        return  (p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right));\n    }\n\n    public void demo() {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(3);\n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(2);\n        root2.right = new TreeNode(3);\n        System.out.println(isSameTree(root1, root2));\n    }\n\n    public static void main(String[] args) {\n        new SameTree().demo();\n    }\n}", "class_id": 0, "repo": "shenhuaze/leetcode-java", "file": "src/main/java/com/huaze/shen/SameTree.java", "last_update_at": "2019-06-17T04:37:39+00:00", "question_id": "d77bea1350674b6acd4fb00409b918543b03efe7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SameTree {\n    public class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n        TreeNode(int x) { val = x; }\n    }\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        } else if (p == null) {\n            return false;\n        } else if (q == null) {\n            return false;\n        }\n        return  (p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right));\n    }\n    public void demo() {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(3);\n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(2);\n        root2.right = new TreeNode(3);\n        System.out.println(isSameTree(root1, root2));\n    }\n    public static void main(String[] args) {\n        new SameTree().demo();\n    }\n"]]}
{"hexsha": "4c99a12a1a0e2b68fe6840b904c1e3ed2da35850", "ext": "java", "lang": "Java", "content": "@Getter @Setter\npublic class SmsCodeService extends GeneralTokenService<SmsCodeTokenRequest, SmsCode> {\n\n    @Override\n    public SmsCode allocate(SmsCodeTokenRequest request) {\n        String key = generateCodeSeq(request.getCodeLength());\n        return new SmsCode(key, request.getCodeValidityDuration(), request.getMobilePhone());\n    }\n\n    private String generateCodeSeq(int length) {\n        final Random random = new Random();\n        char[] seq = new char[length];\n        char[] codes = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };\n        for (int i = 0; i < length; i++) {\n            seq[i] = codes[random.nextInt(codes.length)];\n        }\n\n        return new String(seq);\n    }\n\n\n}", "class_id": 0, "repo": "leatomic/watchdog", "file": "watchdog-core/src/main/java/io/watchdog/security/web/verification/sms/SmsCodeService.java", "last_update_at": "2019-09-16T07:01:45+00:00", "question_id": "4c99a12a1a0e2b68fe6840b904c1e3ed2da35850", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Getter @Setter\npublic class SmsCodeService extends GeneralTokenService<SmsCodeTokenRequest, SmsCode> {\n    @Override\n    public SmsCode allocate(SmsCodeTokenRequest request) {\n        String key = generateCodeSeq(request.getCodeLength());\n        return new SmsCode(key, request.getCodeValidityDuration(), request.getMobilePhone());\n    }\n    private String generateCodeSeq(int length) {\n        final Random random = new Random();\n        char[] seq = new char[length];\n        char[] codes = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };\n        for (int i = 0; i < length; i++) {\n            seq[i] = codes[random.nextInt(codes.length)];\n        }\n        return new String(seq);\n    }\n"]]}
{"hexsha": "a630a6063a8578224a637c0fa85ce61e8bd5650f", "ext": "java", "lang": "Java", "content": "public class AnimatorSetCompat\n{\n\n\tpublic static void playTogether(AnimatorSet animatorset, List list)\n\t{\n\t\tint j = list.size();\n\t//    0    0:aload_1         \n\t//    1    1:invokeinterface #16  <Method int List.size()>\n\t//    2    6:istore_3        \n\t\tlong l = 0L;\n\t//    3    7:lconst_0        \n\t//    4    8:lstore          4\n\t\tfor(int i = 0; i < j; i++)\n\t//*   5   10:iconst_0        \n\t//*   6   11:istore_2        \n\t//*   7   12:iload_2         \n\t//*   8   13:iload_3         \n\t//*   9   14:icmpge          54\n\t\t{\n\t\t\tAnimator animator = (Animator)list.get(i);\n\t//   10   17:aload_1         \n\t//   11   18:iload_2         \n\t//   12   19:invokeinterface #20  <Method Object List.get(int)>\n\t//   13   24:checkcast       #22  <Class Animator>\n\t//   14   27:astore          6\n\t\t\tl = Math.max(l, animator.getStartDelay() + animator.getDuration());\n\t//   15   29:lload           4\n\t//   16   31:aload           6\n\t//   17   33:invokevirtual   #26  <Method long Animator.getStartDelay()>\n\t//   18   36:aload           6\n\t//   19   38:invokevirtual   #29  <Method long Animator.getDuration()>\n\t//   20   41:ladd            \n\t//   21   42:invokestatic    #35  <Method long Math.max(long, long)>\n\t//   22   45:lstore          4\n\t\t}\n\n\t//   23   47:iload_2         \n\t//   24   48:iconst_1        \n\t//   25   49:iadd            \n\t//   26   50:istore_2        \n\t//*  27   51:goto            12\n\t\tValueAnimator valueanimator = ValueAnimator.ofInt(new int[] {\n\t\t\t0, 0\n\t\t});\n\t//   28   54:iconst_2        \n\t//   29   55:newarray        int[]\n\t//   30   57:dup             \n\t//   31   58:iconst_0        \n\t//   32   59:iconst_0        \n\t//   33   60:iastore         \n\t//   34   61:dup             \n\t//   35   62:iconst_1        \n\t//   36   63:iconst_0        \n\t//   37   64:iastore         \n\t//   38   65:invokestatic    #41  <Method ValueAnimator ValueAnimator.ofInt(int[])>\n\t//   39   68:astore          6\n\t\t((Animator) (valueanimator)).setDuration(l);\n\t//   40   70:aload           6\n\t//   41   72:lload           4\n\t//   42   74:invokevirtual   #45  <Method Animator Animator.setDuration(long)>\n\t//   43   77:pop             \n\t\tlist.add(0, ((Object) (valueanimator)));\n\t//   44   78:aload_1         \n\t//   45   79:iconst_0        \n\t//   46   80:aload           6\n\t//   47   82:invokeinterface #49  <Method void List.add(int, Object)>\n\t\tanimatorset.playTogether(((java.util.Collection) (list)));\n\t//   48   87:aload_0         \n\t//   49   88:aload_1         \n\t//   50   89:invokevirtual   #54  <Method void AnimatorSet.playTogether(java.util.Collection)>\n\t//   51   92:return          \n\t}\n}", "class_id": 0, "repo": "Andreas237/AndroidPolicyAutomation", "file": "ExtractedJars/Ibotta_com.ibotta.android/javafiles/android/support/design/animation/AnimatorSetCompat.java", "last_update_at": "2019-07-06T22:21:59+00:00", "question_id": "a630a6063a8578224a637c0fa85ce61e8bd5650f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AnimatorSetCompat\n{\n\tpublic static void playTogether(AnimatorSet animatorset, List list)\n\t{\n\t\tint j = list.size();\n\t//    0    0:aload_1         \n\t//    1    1:invokeinterface #16  <Method int List.size()>\n\t//    2    6:istore_3        \n\t\tlong l = 0L;\n\t//    3    7:lconst_0        \n\t//    4    8:lstore          4\n\t\tfor(int i = 0; i < j; i++)\n\t//*   5   10:iconst_0        \n\t//*   6   11:istore_2        \n\t//*   7   12:iload_2         \n\t//*   8   13:iload_3         \n\t//*   9   14:icmpge          54\n\t\t{\n\t\t\tAnimator animator = (Animator)list.get(i);\n\t//   10   17:aload_1         \n\t//   11   18:iload_2         \n\t//   12   19:invokeinterface #20  <Method Object List.get(int)>\n\t//   13   24:checkcast       #22  <Class Animator>\n\t//   14   27:astore          6\n\t\t\tl = Math.max(l, animator.getStartDelay() + animator.getDuration());\n\t//   15   29:lload           4\n\t//   16   31:aload           6\n\t//   17   33:invokevirtual   #26  <Method long Animator.getStartDelay()>\n\t//   18   36:aload           6\n\t//   19   38:invokevirtual   #29  <Method long Animator.getDuration()>\n\t//   20   41:ladd            \n\t//   21   42:invokestatic    #35  <Method long Math.max(long, long)>\n\t//   22   45:lstore          4\n\t\t}\n\t//   23   47:iload_2         \n\t//   24   48:iconst_1        \n\t//   25   49:iadd            \n\t//   26   50:istore_2        \n\t//*  27   51:goto            12\n\t\tValueAnimator valueanimator = ValueAnimator.ofInt(new int[] {\n\t\t\t0, 0\n\t\t});\n\t//   28   54:iconst_2        \n\t//   29   55:newarray        int[]\n\t//   30   57:dup             \n\t//   31   58:iconst_0        \n\t//   32   59:iconst_0        \n\t//   33   60:iastore         \n\t//   34   61:dup             \n\t//   35   62:iconst_1        \n\t//   36   63:iconst_0        \n\t//   37   64:iastore         \n\t//   38   65:invokestatic    #41  <Method ValueAnimator ValueAnimator.ofInt(int[])>\n\t//   39   68:astore          6\n\t\t((Animator) (valueanimator)).setDuration(l);\n\t//   40   70:aload           6\n\t//   41   72:lload           4\n\t//   42   74:invokevirtual   #45  <Method Animator Animator.setDuration(long)>\n\t//   43   77:pop             \n\t\tlist.add(0, ((Object) (valueanimator)));\n\t//   44   78:aload_1         \n\t//   45   79:iconst_0        \n\t//   46   80:aload           6\n\t//   47   82:invokeinterface #49  <Method void List.add(int, Object)>\n\t\tanimatorset.playTogether(((java.util.Collection) (list)));\n\t//   48   87:aload_0         \n\t//   49   88:aload_1         \n\t//   50   89:invokevirtual   #54  <Method void AnimatorSet.playTogether(java.util.Collection)>\n\t//   51   92:return          \n\t}\n"]]}
{"hexsha": "89e006c2e24be097b444fc1c7d7e088bdd9e3d5c", "ext": "java", "lang": "Java", "content": "public class OrbFastBarrier implements Barrier {\n  \n  private final Logger logger = LoggerFactory.getLogger(OrbFastBarrier.class);\n  \n  private OrbConfiguration orbConf;\n  private String barrierName;\n  int numOfMembers;\n  private String member;\n  private ZooKeeper zk;\n  private boolean active;\n  \n  /**\n   * Constructs an OrbFastBarrier object.\n   * \n   * @param orbConf\n   *          - OrbConfiguration\n   * @param barrierName\n   *          - The barrier's name\n   * @param numOfMembers\n   *          - The total number of expected members to join under the barrier node\n   * @param member\n   *          - A member node's name\n   * @param zk\n   *          - ZooKeeper object\n   */\n  public OrbFastBarrier(OrbConfiguration orbConf,\n                        String barrierName,\n                        int numOfMembers,\n                        String member,\n                        ZooKeeper zk) {\n    this.orbConf = orbConf;\n    this.barrierName = barrierName;\n    this.numOfMembers = numOfMembers;\n    this.member = member;\n    this.zk = zk;\n    this.active = true;\n  }\n  \n  /**\n   * This method creates a new member node under the barrier node if it does not already exist. It uses a O(n)\n   * algorithm.\n   * \n   * @exception InterruptedException\n   *              throws OrbZKFailure\n   * @exception KeeperException\n   *              throws OrbZKFailure\n   */\n  @Override\n  public void enter() throws OrbZKFailure {\n    // general path looks like: \"/barrierName/member\"\n    String memberPath = barrierName + \"/\" + member;\n    logger.debug(\"enter(): {}\", memberPath);\n    /*\n     * If this barrier is the first to enter() it will create the barrier node and firstToEnter will be the\n     * path of the barrier node. Otherwise firstToEnter will equal null.\n     */\n    String firstToEnter = ZookeeperUtils.tryToCreateNode(zk, barrierName, CreateMode.PERSISTENT);\n    ZookeeperUtils.tryToCreateNode(zk, memberPath, CreateMode.EPHEMERAL);\n    \n    if (firstToEnter != null) { // becomes the counter for this barrier\n      logger.debug(\"{} is the counter\", memberPath);\n      try {\n        BarrierWatcher bw = new BarrierWatcher(this);\n        List<String> memberList = zk.getChildren(barrierName, bw);\n        synchronized (this) {\n          while (memberList.size() < numOfMembers) {\n            // synchronized(this) {\n            this.wait(1000);\n            memberList = zk.getChildren(barrierName, bw);\n          }\n        }\n        logger.debug(\"all {} have joined, sending AllClear\", memberList.size());\n        // Everyone has joined, give the All Clear to move forward\n        ZookeeperUtils.tryToCreateNode(zk, barrierName + \"/AllClear\", CreateMode.EPHEMERAL);\n        // delete its node on they way out\n        ZookeeperUtils.deleteNodeIfEmpty(zk, memberPath);\n      } catch (KeeperException e) {\n        throw new OrbZKFailure(e);\n      } catch (InterruptedException e) {\n        throw new OrbZKFailure(e);\n      }\n    } else { // not first to enter, therefore just watches for the AllClear node\n      try {\n        logger.debug(\"{} not first to enter, waiting\", memberPath);\n        BarrierWatcher bw = new BarrierWatcher(this);\n        while (zk.exists(barrierName + \"/AllClear\", bw) == null) {\n          synchronized (this) {\n            this.wait(1000);\n          }\n        }\n        logger.debug(\"{} recvd AllClear, moving on\", memberPath);\n        // delete its node on they way out\n        ZookeeperUtils.deleteNodeIfEmpty(zk, memberPath);\n      } catch (KeeperException e) {\n        throw new OrbZKFailure(e);\n      } catch (InterruptedException e) {\n        throw new OrbZKFailure(e);\n      }\n    }\n  }\n  \n  /**\n   * Makes this inactive.\n   */\n  public void makeInactive() {\n    this.active = false;\n  }\n  \n  @Override\n  public void setOrbConf(OrbConfiguration orbConf) {\n    this.orbConf = orbConf;\n  }\n  \n  @Override\n  public OrbConfiguration getOrbConf() {\n    return orbConf;\n  }\n  \n  /**\n   * This class implements a Watcher for usage in the barrier mechanism for ZooKeeper.\n   * \n   */\n  class BarrierWatcher implements Watcher {\n    OrbFastBarrier ofb;\n    \n    /**\n     * This constructs a BarrierWatcher object given a configured OrbFastBarrier object.\n     * \n     * @param orbFastBarrier\n     */\n    public BarrierWatcher(OrbFastBarrier orbFastBarrier) {\n      this.ofb = orbFastBarrier;\n    }\n    \n    /**\n     * This method processes notifications triggered by Watchers.\n     */\n    @Override\n    public synchronized void process(WatchedEvent event) {\n      synchronized (ofb) {\n        if (OrbFastBarrier.this.active) {\n          ofb.notify();\n        }\n      }\n    }\n    \n  }\n  \n}", "class_id": 0, "repo": "AnandEmbold/biscuit_5", "file": "java/goldenorb_java/src/main/java/org/goldenorb/zookeeper/OrbFastBarrier.java", "last_update_at": "2019-07-02T11:21:17+00:00", "question_id": "89e006c2e24be097b444fc1c7d7e088bdd9e3d5c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OrbFastBarrier implements Barrier {\n  private final Logger logger = LoggerFactory.getLogger(OrbFastBarrier.class);\n  private OrbConfiguration orbConf;\n  private String barrierName;\n  int numOfMembers;\n  private String member;\n  private ZooKeeper zk;\n  private boolean active;\n  /**\n   * Constructs an OrbFastBarrier object.\n   * \n   * @param orbConf\n   *          - OrbConfiguration\n   * @param barrierName\n   *          - The barrier's name\n   * @param numOfMembers\n   *          - The total number of expected members to join under the barrier node\n   * @param member\n   *          - A member node's name\n   * @param zk\n   *          - ZooKeeper object\n   */\n  public OrbFastBarrier(OrbConfiguration orbConf,\n                        String barrierName,\n                        int numOfMembers,\n                        String member,\n                        ZooKeeper zk) {\n    this.orbConf = orbConf;\n    this.barrierName = barrierName;\n    this.numOfMembers = numOfMembers;\n    this.member = member;\n    this.zk = zk;\n    this.active = true;\n  }\n  /**\n   * This method creates a new member node under the barrier node if it does not already exist. It uses a O(n)\n   * algorithm.\n   * \n   * @exception InterruptedException\n   *              throws OrbZKFailure\n   * @exception KeeperException\n   *              throws OrbZKFailure\n   */\n  @Override\n  public void enter() throws OrbZKFailure {\n    // general path looks like: \"/barrierName/member\"\n    String memberPath = barrierName + \"/\" + member;\n    logger.debug(\"enter(): {}\", memberPath);\n    /*\n     * If this barrier is the first to enter() it will create the barrier node and firstToEnter will be the\n     * path of the barrier node. Otherwise firstToEnter will equal null.\n     */\n    String firstToEnter = ZookeeperUtils.tryToCreateNode(zk, barrierName, CreateMode.PERSISTENT);\n    ZookeeperUtils.tryToCreateNode(zk, memberPath, CreateMode.EPHEMERAL);\n    if (firstToEnter != null) { // becomes the counter for this barrier\n      logger.debug(\"{} is the counter\", memberPath);\n      try {\n        BarrierWatcher bw = new BarrierWatcher(this);\n        List<String> memberList = zk.getChildren(barrierName, bw);\n        synchronized (this) {\n          while (memberList.size() < numOfMembers) {\n            // synchronized(this) {\n            this.wait(1000);\n            memberList = zk.getChildren(barrierName, bw);\n          }\n        }\n        logger.debug(\"all {} have joined, sending AllClear\", memberList.size());\n        // Everyone has joined, give the All Clear to move forward\n        ZookeeperUtils.tryToCreateNode(zk, barrierName + \"/AllClear\", CreateMode.EPHEMERAL);\n        // delete its node on they way out\n        ZookeeperUtils.deleteNodeIfEmpty(zk, memberPath);\n      } catch (KeeperException e) {\n        throw new OrbZKFailure(e);\n      } catch (InterruptedException e) {\n        throw new OrbZKFailure(e);\n      }\n    } else { // not first to enter, therefore just watches for the AllClear node\n      try {\n        logger.debug(\"{} not first to enter, waiting\", memberPath);\n        BarrierWatcher bw = new BarrierWatcher(this);\n        while (zk.exists(barrierName + \"/AllClear\", bw) == null) {\n          synchronized (this) {\n            this.wait(1000);\n          }\n        }\n        logger.debug(\"{} recvd AllClear, moving on\", memberPath);\n        // delete its node on they way out\n        ZookeeperUtils.deleteNodeIfEmpty(zk, memberPath);\n      } catch (KeeperException e) {\n        throw new OrbZKFailure(e);\n      } catch (InterruptedException e) {\n        throw new OrbZKFailure(e);\n      }\n    }\n  }\n  /**\n   * Makes this inactive.\n   */\n  public void makeInactive() {\n    this.active = false;\n  }\n  @Override\n  public void setOrbConf(OrbConfiguration orbConf) {\n    this.orbConf = orbConf;\n  }\n  @Override\n  public OrbConfiguration getOrbConf() {\n    return orbConf;\n  }\n  /**\n   * This class implements a Watcher for usage in the barrier mechanism for ZooKeeper.\n   * \n   */\n  class BarrierWatcher implements Watcher {\n    OrbFastBarrier ofb;\n    /**\n     * This constructs a BarrierWatcher object given a configured OrbFastBarrier object.\n     * \n     * @param orbFastBarrier\n     */\n    public BarrierWatcher(OrbFastBarrier orbFastBarrier) {\n      this.ofb = orbFastBarrier;\n    }\n    /**\n     * This method processes notifications triggered by Watchers.\n     */\n    @Override\n    public synchronized void process(WatchedEvent event) {\n      synchronized (ofb) {\n        if (OrbFastBarrier.this.active) {\n          ofb.notify();\n        }\n      }\n    }\n  }\n"]]}
{"hexsha": "41ace0bfd7cc7cd91f8953724ac5e8d85518d068", "ext": "java", "lang": "Java", "content": "public class Stack<T> {\n    Node<T> top;\n\n    public Stack(){\n        this.top = null;\n    }\n\n    // This function pushes an item into the stack.\n    public void push(T value){\n        Node<T> newNode = new Node<>(value);\n        newNode.next = top;\n        this.top = newNode;\n    }\n\n    // This function removes(pops) an item from the stack.\n    public T pop(){\n        if(top == null) throw new EmptyStackException();\n        Node<T> temp = top;\n        top = temp.next;\n        return temp.value;\n    }\n\n    // This function returns the value that's at the top of the stack.\n    public T peek(){\n        if(top == null) throw new EmptyStackException();\n        return top.value;\n    }\n\n    // This function returns true is the stack is empty, otherwise false.\n    public boolean isEmpty(){\n        return top == null ? true : false;\n    }\n\n    // This function returns the string of the stack\n    public String toString(){\n        // Declare variables\n        Node<T> iterator = top;\n        StringBuilder nodeString = new StringBuilder();\n        nodeString.append(\"Stack: Top -> \");\n        while(iterator != null){\n            nodeString.append(iterator.toString());\n            nodeString.append(\" -> \");\n            iterator = iterator.next;\n        }\n        // Finished the null / also works if top is null\n        nodeString.append(\"null\");\n        return nodeString.toString();\n    }\n}", "class_id": 0, "repo": "thatsjustjohn/data-structures-and-algorithms", "file": "code-challenges401/src/main/java/code/challenges401/stacksandqueues/Stack.java", "last_update_at": "2019-06-03T21:25:29+00:00", "question_id": "41ace0bfd7cc7cd91f8953724ac5e8d85518d068", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Stack<T> {\n    Node<T> top;\n    public Stack(){\n        this.top = null;\n    }\n    // This function pushes an item into the stack.\n    public void push(T value){\n        Node<T> newNode = new Node<>(value);\n        newNode.next = top;\n        this.top = newNode;\n    }\n    // This function removes(pops) an item from the stack.\n    public T pop(){\n        if(top == null) throw new EmptyStackException();\n        Node<T> temp = top;\n        top = temp.next;\n        return temp.value;\n    }\n    // This function returns the value that's at the top of the stack.\n    public T peek(){\n        if(top == null) throw new EmptyStackException();\n        return top.value;\n    }\n    // This function returns true is the stack is empty, otherwise false.\n    public boolean isEmpty(){\n        return top == null ? true : false;\n    }\n    // This function returns the string of the stack\n    public String toString(){\n        // Declare variables\n        Node<T> iterator = top;\n        StringBuilder nodeString = new StringBuilder();\n        nodeString.append(\"Stack: Top -> \");\n        while(iterator != null){\n            nodeString.append(iterator.toString());\n            nodeString.append(\" -> \");\n            iterator = iterator.next;\n        }\n        // Finished the null / also works if top is null\n        nodeString.append(\"null\");\n        return nodeString.toString();\n    }\n"]]}
{"hexsha": "aa8d1e8b841e48ce0ee040d753ce2d033a80f61b", "ext": "java", "lang": "Java", "content": "public class JSONUtils {\n\t\n\tstatic XStream xstream = new XStream(new JettisonMappedXmlDriver(){\n\t\t\n\t\tpublic HierarchicalStreamWriter createWriter(Writer writer) {\n            return new JsonWriter(writer, JsonWriter.DROP_ROOT_MODE);\n        }\n\t\t\n\t});\n\t\n\tpublic static String toJson(Object object){\n\t\txstream.setMode(XStream.NO_REFERENCES);\n\t\tString json = xstream.toXML(object);\n        return json;\n\t}\n\t\n\tpublic static <T> T toObject(String json, Class<T> aClass){\n\t\txstream.setMode(XStream.NO_REFERENCES);\n\t\treturn (T) xstream.fromXML(json);\n\t\t\n\t}\n\n}", "class_id": 0, "repo": "regcostajr/commons-java", "file": "src/br/com/crypto/commons/json/JSONUtils.java", "last_update_at": "2019-06-25T03:32:17+00:00", "question_id": "aa8d1e8b841e48ce0ee040d753ce2d033a80f61b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class JSONUtils {\n\t\n\tstatic XStream xstream = new XStream(new JettisonMappedXmlDriver(){\n\t\t\n\t\tpublic HierarchicalStreamWriter createWriter(Writer writer) {\n            return new JsonWriter(writer, JsonWriter.DROP_ROOT_MODE);\n        }\n\t\t\n\t});\n\t\n\tpublic static String toJson(Object object){\n\t\txstream.setMode(XStream.NO_REFERENCES);\n\t\tString json = xstream.toXML(object);\n        return json;\n\t}\n\t\n\tpublic static <T> T toObject(String json, Class<T> aClass){\n\t\txstream.setMode(XStream.NO_REFERENCES);\n\t\treturn (T) xstream.fromXML(json);\n\t\t\n\t}\n"]]}
{"hexsha": "390356aa4960b6206cf134619915b00af46b2a7b", "ext": "java", "lang": "Java", "content": "public class TroveIntObjTest implements IntTestSet {\n    @Override\n    public IntMapTest putAndUpdateTest() {\n        return new TroveIntObjPutAndUpdateTest();\n    }\n\n    @Override\n    public IntMapTest twoPutOneRemoveTest() {\n        return new TroveIntObjTwoPutOneRemoveTest();\n    }\n\n    @Override\n    public IntMapTest getTest() {\n        return new TroveIntObjGetTest();\n    }\n\n    @Override\n    public IntMapTest putTest() {\n        return new TroveIntObjPutTest();\n    }\n\n    @Override\n    public IntMapTest removeTest() {\n        return new TroveIntObjRemoveTest();\n    }\n\n    @Override\n    public IntMapTest mergeTest() {\n        return new TroveIntObjMergeTest();\n    }\n\n    private static class TroveIntObjGetTest extends AbstractIntObjGetTest {\n\n        private TIntObjectHashMap<Integer> m_map;\n\n        @Override\n        public void setup(int[] keys, float fillFactor, int oneFailureOutOf) {\n            super.setup(keys, fillFactor, oneFailureOutOf);\n            m_map = new TIntObjectHashMap<>(keys.length, fillFactor);\n            for (int i = 0; i < keys.length; ++i) {\n                if (i % oneFailureOutOf != 0) m_map.put(keys[i], new Integer(keys[i]));\n            }\n        }\n\n        @Override\n        public int test() {\n            int res = 0;\n            for (int i = 0; i < m_keys.length; ++i)\n                if (m_map.get(m_keys[i]) != null) res += 1;\n            return res;\n        }\n\n    }\n\n    private static class TroveIntObjPutTest extends AbstractIntObjPutTest {\n        private TIntObjectHashMap<Integer> m_map;\n\n        @Override\n        public void setup(int[] keys, float fillFactor, int oneFailureOutOf) {\n            super.setup(keys, fillFactor, oneFailureOutOf);\n            m_map = new TIntObjectHashMap<Integer>(keys.length, fillFactor);\n        }\n\n        @Override\n        public int test() {\n            for (int j = 0; j < m_keys.length; j++) {\n                m_map.put(m_keys[j], new Integer(j));\n            }\n            return m_map.size();\n        }\n\n    }\n\n    private static class TroveIntObjPutAndUpdateTest extends AbstractIntObjPutTest {\n        private TIntObjectHashMap<Integer> m_map;\n\n        @Override\n        public void setup(int[] keys, float fillFactor, int oneFailureOutOf) {\n            super.setup(keys, fillFactor, oneFailureOutOf);\n            m_map = new TIntObjectHashMap<Integer>(keys.length, fillFactor);\n        }\n\n        @Override\n        public int test() {\n            for (int j = 0; j < m_keys.length; j++) {\n                m_map.put(m_keys[j], new Integer(j));\n            }\n            for (int i = 0; i < m_keys2.length; i++) {\n                m_map.put(m_keys2[i], new Integer(i));\n            }\n            return m_map.size();\n        }\n\n    }\n\n    private static class TroveIntObjRemoveTest extends AbstractIntObjGetTest {\n        private TIntObjectHashMap<Integer> m_map;\n\n        @Override\n        public void setup(int[] keys, float fillFactor, int oneFailureOutOf) {\n            super.setup(keys, fillFactor, oneFailureOutOf);\n            m_map = new TIntObjectHashMap<>(keys.length, fillFactor);\n            for (int j = 0; j < keys.length; j++) {\n                m_map.put(keys[j], new Integer(keys[j]));\n            }\n        }\n\n        @Override\n        public int test() {\n            for (int i = 0; i < m_keys.length; i++) {\n                m_map.remove(m_keys[i]);\n            }\n            return m_map.size();\n        }\n\n    }\n    private static class TroveIntObjTwoPutOneRemoveTest extends AbstractIntObjGetTest {\n        private TIntObjectHashMap<Integer> m_map;\n\n        @Override\n        public void setup(int[] keys, float fillFactor, int oneFailureOutOf) {\n            super.setup(keys, fillFactor, oneFailureOutOf);\n            m_map = new TIntObjectHashMap<>(keys.length, fillFactor);\n        }\n\n        @Override\n        public int test() {\n\n            int add = 0, remove = 0;\n            while (add < m_keys.length) {\n                m_map.put(m_keys[add], new Integer(add));\n                ++add;\n                m_map.put(m_keys[add], new Integer(add));\n                ++add;\n                m_map.remove(m_keys[remove++]);\n            }\n            return m_map.size();\n        }\n\n    }\n\n    private static class TroveIntObjMergeTest extends AbstractIntObjMergeTest {\n        private TIntObjectHashMap<Integer> m_map;\n        private TIntObjectHashMap<Integer> m_map2;\n\n        @Override\n        public void setup(int[] keys, float fillFactor, int oneFailureOutOf) {\n            super.setup(keys, fillFactor, oneFailureOutOf);\n            m_map = new TIntObjectHashMap<Integer>(keys.length / 2, fillFactor);\n            for (int key : m_keys) m_map.put(key, new Integer(key));\n            m_map2 = new TIntObjectHashMap<Integer>(keys.length, fillFactor);\n            for (int key : m_keys2) m_map2.put(key, new Integer(key));\n        }\n\n        @Override\n        public int test() {\n            m_map2.forEachEntry((key, val) -> {\n                if (m_map.containsKey(key)) {\n                    m_map.put(key, m_map.get(key) + val);\n                } else m_map.put(key, val);\n\n                return true;\n            });\n\n\n            return m_map.size();\n        }\n    }\n}", "class_id": 0, "repo": "mtishchuk/maptest", "file": "src/main/java/tests/intobjecttest/TroveIntObjTest.java", "last_update_at": "2019-06-10T12:27:27+00:00", "question_id": "390356aa4960b6206cf134619915b00af46b2a7b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TroveIntObjTest implements IntTestSet {\n    @Override\n    public IntMapTest putAndUpdateTest() {\n        return new TroveIntObjPutAndUpdateTest();\n    }\n    @Override\n    public IntMapTest twoPutOneRemoveTest() {\n        return new TroveIntObjTwoPutOneRemoveTest();\n    }\n    @Override\n    public IntMapTest getTest() {\n        return new TroveIntObjGetTest();\n    }\n    @Override\n    public IntMapTest putTest() {\n        return new TroveIntObjPutTest();\n    }\n    @Override\n    public IntMapTest removeTest() {\n        return new TroveIntObjRemoveTest();\n    }\n    @Override\n    public IntMapTest mergeTest() {\n        return new TroveIntObjMergeTest();\n    }\n    private static class TroveIntObjGetTest extends AbstractIntObjGetTest {\n        private TIntObjectHashMap<Integer> m_map;\n        @Override\n        public void setup(int[] keys, float fillFactor, int oneFailureOutOf) {\n            super.setup(keys, fillFactor, oneFailureOutOf);\n            m_map = new TIntObjectHashMap<>(keys.length, fillFactor);\n            for (int i = 0; i < keys.length; ++i) {\n                if (i % oneFailureOutOf != 0) m_map.put(keys[i], new Integer(keys[i]));\n            }\n        }\n        @Override\n        public int test() {\n            int res = 0;\n            for (int i = 0; i < m_keys.length; ++i)\n                if (m_map.get(m_keys[i]) != null) res += 1;\n            return res;\n        }\n    }\n    private static class TroveIntObjPutTest extends AbstractIntObjPutTest {\n        private TIntObjectHashMap<Integer> m_map;\n        @Override\n        public void setup(int[] keys, float fillFactor, int oneFailureOutOf) {\n            super.setup(keys, fillFactor, oneFailureOutOf);\n            m_map = new TIntObjectHashMap<Integer>(keys.length, fillFactor);\n        }\n        @Override\n        public int test() {\n            for (int j = 0; j < m_keys.length; j++) {\n                m_map.put(m_keys[j], new Integer(j));\n            }\n            return m_map.size();\n        }\n    }\n    private static class TroveIntObjPutAndUpdateTest extends AbstractIntObjPutTest {\n        private TIntObjectHashMap<Integer> m_map;\n        @Override\n        public void setup(int[] keys, float fillFactor, int oneFailureOutOf) {\n            super.setup(keys, fillFactor, oneFailureOutOf);\n            m_map = new TIntObjectHashMap<Integer>(keys.length, fillFactor);\n        }\n        @Override\n        public int test() {\n            for (int j = 0; j < m_keys.length; j++) {\n                m_map.put(m_keys[j], new Integer(j));\n            }\n            for (int i = 0; i < m_keys2.length; i++) {\n                m_map.put(m_keys2[i], new Integer(i));\n            }\n            return m_map.size();\n        }\n    }\n    private static class TroveIntObjRemoveTest extends AbstractIntObjGetTest {\n        private TIntObjectHashMap<Integer> m_map;\n        @Override\n        public void setup(int[] keys, float fillFactor, int oneFailureOutOf) {\n            super.setup(keys, fillFactor, oneFailureOutOf);\n            m_map = new TIntObjectHashMap<>(keys.length, fillFactor);\n            for (int j = 0; j < keys.length; j++) {\n                m_map.put(keys[j], new Integer(keys[j]));\n            }\n        }\n        @Override\n        public int test() {\n            for (int i = 0; i < m_keys.length; i++) {\n                m_map.remove(m_keys[i]);\n            }\n            return m_map.size();\n        }\n    }\n    private static class TroveIntObjTwoPutOneRemoveTest extends AbstractIntObjGetTest {\n        private TIntObjectHashMap<Integer> m_map;\n        @Override\n        public void setup(int[] keys, float fillFactor, int oneFailureOutOf) {\n            super.setup(keys, fillFactor, oneFailureOutOf);\n            m_map = new TIntObjectHashMap<>(keys.length, fillFactor);\n        }\n        @Override\n        public int test() {\n            int add = 0, remove = 0;\n            while (add < m_keys.length) {\n                m_map.put(m_keys[add], new Integer(add));\n                ++add;\n                m_map.put(m_keys[add], new Integer(add));\n                ++add;\n                m_map.remove(m_keys[remove++]);\n            }\n            return m_map.size();\n        }\n    }\n    private static class TroveIntObjMergeTest extends AbstractIntObjMergeTest {\n        private TIntObjectHashMap<Integer> m_map;\n        private TIntObjectHashMap<Integer> m_map2;\n        @Override\n        public void setup(int[] keys, float fillFactor, int oneFailureOutOf) {\n            super.setup(keys, fillFactor, oneFailureOutOf);\n            m_map = new TIntObjectHashMap<Integer>(keys.length / 2, fillFactor);\n            for (int key : m_keys) m_map.put(key, new Integer(key));\n            m_map2 = new TIntObjectHashMap<Integer>(keys.length, fillFactor);\n            for (int key : m_keys2) m_map2.put(key, new Integer(key));\n        }\n        @Override\n        public int test() {\n            m_map2.forEachEntry((key, val) -> {\n                if (m_map.containsKey(key)) {\n                    m_map.put(key, m_map.get(key) + val);\n                } else m_map.put(key, val);\n                return true;\n            });\n            return m_map.size();\n        }\n    }\n"]]}
{"hexsha": "9f3940b2af4930e3b7d82166da0c6956a27222df", "ext": "java", "lang": "Java", "content": "public class Fun extends Function{\n\tpublic Fun(final ByteBuffer b){\n\t\tsuper(b);\n\t}\n\n\tpublic Fun(final Descriptor<?> a, final Descriptor<?> b){\n\t\tsuper(OPC.OpcFun, a, b);\n\t}\n\n\tpublic Fun(final Descriptor<?>[] args){\n\t\tsuper(OPC.OpcFun, args);\n\t}\n\n\t@Override\n\tpublic final StringBuilder decompile(final int prec, final StringBuilder pout, final int mode) {\n\t\tif(prec < Descriptor.P_STMT) pout.append('(');\n\t\tpout.append(\"Fun \");\n\t\tfinal Descriptor<?> ptr = this.getDescriptor(0);\n\t\tif(ptr.dtype() == DTYPE.T) pout.append(ptr.toString());\n\t\telse ptr.decompile(Descriptor.P_SUBS, pout, mode & ~Descriptor.DECO_X);\n\t\tthis.addArguments(2, \" (\", \") \", pout, mode);\n\t\tFunction.addCompoundStatement(1, this, 1, pout, mode);\n\t\tif(prec < Descriptor.P_STMT) pout.append(')');\n\t\treturn pout;\n\t}\n\n\t@Override\n\tpublic final Descriptor<?> evaluate() {\n\t\ttry{\n\t\t\tfinal DATA<?>[] args = Descriptor.getDATAs(this.getArguments());\n\t\t\treturn BINARY.getCommon(args).add(args[0].toDescriptor(), args[1].toDescriptor());\n\t\t}catch(final MdsException e){\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\treturn Missing.NEW;\n\t\t}\n\t}\n}", "class_id": 0, "repo": "zack-vii/mdsplus", "file": "java/mdsplus-api/src/main/java/mds/data/descriptor_r/function/Fun.java", "last_update_at": "2019-09-02T13:40:23+00:00", "question_id": "9f3940b2af4930e3b7d82166da0c6956a27222df", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Fun extends Function{\n\tpublic Fun(final ByteBuffer b){\n\t\tsuper(b);\n\t}\n\tpublic Fun(final Descriptor<?> a, final Descriptor<?> b){\n\t\tsuper(OPC.OpcFun, a, b);\n\t}\n\tpublic Fun(final Descriptor<?>[] args){\n\t\tsuper(OPC.OpcFun, args);\n\t}\n\t@Override\n\tpublic final StringBuilder decompile(final int prec, final StringBuilder pout, final int mode) {\n\t\tif(prec < Descriptor.P_STMT) pout.append('(');\n\t\tpout.append(\"Fun \");\n\t\tfinal Descriptor<?> ptr = this.getDescriptor(0);\n\t\tif(ptr.dtype() == DTYPE.T) pout.append(ptr.toString());\n\t\telse ptr.decompile(Descriptor.P_SUBS, pout, mode & ~Descriptor.DECO_X);\n\t\tthis.addArguments(2, \" (\", \") \", pout, mode);\n\t\tFunction.addCompoundStatement(1, this, 1, pout, mode);\n\t\tif(prec < Descriptor.P_STMT) pout.append(')');\n\t\treturn pout;\n\t}\n\t@Override\n\tpublic final Descriptor<?> evaluate() {\n\t\ttry{\n\t\t\tfinal DATA<?>[] args = Descriptor.getDATAs(this.getArguments());\n\t\t\treturn BINARY.getCommon(args).add(args[0].toDescriptor(), args[1].toDescriptor());\n\t\t}catch(final MdsException e){\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\treturn Missing.NEW;\n\t\t}\n\t}\n"]]}
{"hexsha": "61ba8ff113176b7843d6b18dc06a80bc2331f087", "ext": "java", "lang": "Java", "content": "public class ELKITools {\r\n\r\n\t/**\r\n\t * creates an ELKI database instance from a list of given feature vectors. List\r\n\t * of feature vector must contain at least one entry.\r\n\t * \r\n\t * The database will be initialized as well.\r\n\t * \r\n\t * @param featureVectors input feature vectors\r\n\t * @return ELKI Database\r\n\t */\r\n\tpublic static Database createAndInitializeELKIDatabase(List<? extends NumericalFeatureVector> featureVectors) {\r\n\t\tObjects.requireNonNull(featureVectors);\r\n\r\n\t\tint count = featureVectors.size();\r\n\r\n\t\tif (count == 0)\r\n\t\t\tthrow new IllegalArgumentException(\r\n\t\t\t\t\t\"ELKITools.createAndInitializeELKIDatabase requires non-empty list of FV\");\r\n\r\n\t\tint dimensions = featureVectors.get(0).getSize();\r\n\r\n\t\tdouble[][] data = new double[count][dimensions];\r\n\t\tfor (int i = 0; i < count; i++) {\r\n\t\t\tdata[i] = featureVectors.get(i).getVector();\r\n\t\t}\r\n\r\n\t\tDatabaseConnection dbc = new ArrayAdapterDatabaseConnection(data);\r\n\t\tDatabase db = new StaticArrayDatabase(dbc, null);\r\n\r\n\t\t// initialize\r\n\t\tdb.initialize();\r\n\r\n\t\treturn db;\r\n\t}\r\n}", "class_id": 0, "repo": "TKnudsen/DMandML", "file": "src/main/java/com/github/TKnudsen/DMandML/model/tools/ELKITools.java", "last_update_at": "2019-04-23T15:33:45+00:00", "question_id": "61ba8ff113176b7843d6b18dc06a80bc2331f087", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ELKITools {\r\n\r\n\t/**\r\n\t * creates an ELKI database instance from a list of given feature vectors. List\r\n\t * of feature vector must contain at least one entry.\r\n\t * \r\n\t * The database will be initialized as well.\r\n\t * \r\n\t * @param featureVectors input feature vectors\r\n\t * @return ELKI Database\r\n\t */\r\n\tpublic static Database createAndInitializeELKIDatabase(List<? extends NumericalFeatureVector> featureVectors) {\r\n\t\tObjects.requireNonNull(featureVectors);\r\n\r\n\t\tint count = featureVectors.size();\r\n\r\n\t\tif (count == 0)\r\n\t\t\tthrow new IllegalArgumentException(\r\n\t\t\t\t\t\"ELKITools.createAndInitializeELKIDatabase requires non-empty list of FV\");\r\n\r\n\t\tint dimensions = featureVectors.get(0).getSize();\r\n\r\n\t\tdouble[][] data = new double[count][dimensions];\r\n\t\tfor (int i = 0; i < count; i++) {\r\n\t\t\tdata[i] = featureVectors.get(i).getVector();\r\n\t\t}\r\n\r\n\t\tDatabaseConnection dbc = new ArrayAdapterDatabaseConnection(data);\r\n\t\tDatabase db = new StaticArrayDatabase(dbc, null);\r\n\r\n\t\t// initialize\r\n\t\tdb.initialize();\r\n\r\n\t\treturn db;\r\n\t}\r\n"]]}
{"hexsha": "18e408ad48f9c79560eafb262b0e0535194da6cb", "ext": "java", "lang": "Java", "content": "public class CassandraEntireSSTableStreamReader implements IStreamReader\n{\n    private static final Logger logger = LoggerFactory.getLogger(CassandraEntireSSTableStreamReader.class);\n\n    private final TableId tableId;\n    private final StreamSession session;\n    private final StreamMessageHeader messageHeader;\n    private final CassandraStreamHeader header;\n    private final int fileSequenceNumber;\n\n    public CassandraEntireSSTableStreamReader(StreamMessageHeader messageHeader, CassandraStreamHeader streamHeader, StreamSession session)\n    {\n        if (streamHeader.format != SSTableFormat.Type.BIG && streamHeader.format != SSTableFormat.Type.BTI)\n            throw new AssertionError(\"Unsupported SSTable format \" + streamHeader.format);\n\n        if (session.getPendingRepair() != null)\n        {\n            // we should only ever be streaming pending repair sstables if the session has a pending repair id\n            if (!session.getPendingRepair().equals(messageHeader.pendingRepair))\n                throw new IllegalStateException(format(\"Stream Session & SSTable (%s) pendingRepair UUID mismatch.\", messageHeader.tableId));\n        }\n\n        this.header = streamHeader;\n        this.session = session;\n        this.messageHeader = messageHeader;\n        this.tableId = messageHeader.tableId;\n        this.fileSequenceNumber = messageHeader.sequenceNumber;\n    }\n\n    /**\n     * @param in where this reads data from\n     * @return SSTable transferred\n     * @throws IOException if reading the remote sstable fails. Will throw an RTE if local write fails.\n     */\n    @SuppressWarnings(\"resource\") // input needs to remain open, streams on top of it can't be closed\n    @Override\n    public SSTableMultiWriter read(DataInputPlus in) throws IOException\n    {\n        ColumnFamilyStore cfs = ColumnFamilyStore.getIfExists(tableId);\n        if (cfs == null)\n        {\n            // schema was dropped during streaming\n            throw new IOException(\"Table \" + tableId + \" was dropped during streaming\");\n        }\n\n        ComponentManifest manifest = header.componentManifest;\n        long totalSize = manifest.totalSize();\n\n        logger.debug(\"[Stream #{}] Started receiving sstable #{} from {}, size = {}, table = {}\",\n                     session.planId(),\n                     fileSequenceNumber,\n                     session.peer,\n                     prettyPrintMemory(totalSize),\n                     cfs.metadata());\n\n        SSTableZeroCopyWriter writer = null;\n\n        try\n        {\n            writer = createWriter(cfs, totalSize, manifest.components());\n            long bytesRead = 0;\n            for (Component component : manifest.components())\n            {\n                long length = manifest.sizeOf(component);\n\n                logger.debug(\"[Stream #{}] Started receiving {} component from {}, componentSize = {}, readBytes = {}, totalSize = {}\",\n                             session.planId(),\n                             component,\n                             session.peer,\n                             prettyPrintMemory(length),\n                             prettyPrintMemory(bytesRead),\n                             prettyPrintMemory(totalSize));\n\n                writer.writeComponent(component.type, in, length);\n                session.progress(writer.descriptor.filenameFor(component), ProgressInfo.Direction.IN, length, length);\n                bytesRead += length;\n\n                logger.debug(\"[Stream #{}] Finished receiving {} component from {}, componentSize = {}, readBytes = {}, totalSize = {}\",\n                             session.planId(),\n                             component,\n                             session.peer,\n                             prettyPrintMemory(length),\n                             prettyPrintMemory(bytesRead),\n                             prettyPrintMemory(totalSize));\n            }\n\n            UnaryOperator<StatsMetadata> transform = stats -> stats.mutateLevel(header.sstableLevel)\n                                                                   .mutateRepairedMetadata(messageHeader.repairedAt, messageHeader.pendingRepair, false);\n            String description = String.format(\"level %s and repairedAt time %s and pendingRepair %s\",\n                                               header.sstableLevel, messageHeader.repairedAt, messageHeader.pendingRepair);\n            writer.descriptor.getMetadataSerializer().mutate(writer.descriptor, description, transform);\n            return writer;\n        }\n        catch (Throwable e)\n        {\n            logger.error(\"[Stream {}] Error while reading sstable from stream for table = {}\", session.planId(), cfs.metadata(), e);\n            if (writer != null)\n                e = writer.abort(e);\n            Throwables.throwIfUnchecked(e);\n            throw new RuntimeException(e);\n        }\n    }\n\n    private File getDataDir(ColumnFamilyStore cfs, long totalSize) throws IOException\n    {\n        Directories.DataDirectory localDir = cfs.getDirectories().getWriteableLocation(totalSize);\n        if (localDir == null)\n            throw new IOException(format(\"Insufficient disk space to store %s\", prettyPrintMemory(totalSize)));\n\n        File dir = cfs.getDirectories().getLocationForDisk(cfs.getDiskBoundaries().getCorrectDiskForKey(header.firstKey));\n\n        if (dir == null)\n            return cfs.getDirectories().getDirectoryForNewSSTables();\n\n        return dir;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected SSTableZeroCopyWriter createWriter(ColumnFamilyStore cfs, long totalSize, Collection<Component> components) throws IOException\n    {\n        File dataDir = getDataDir(cfs, totalSize);\n\n        StreamReceiver streamReceiver = session.getAggregator(tableId);\n        assert streamReceiver instanceof CassandraStreamReceiver;\n\n        LifecycleNewTracker lifecycleNewTracker = CassandraStreamReceiver.fromReceiver(session.getAggregator(tableId)).createLifecycleNewTracker();\n\n        Descriptor desc = cfs.newSSTableDescriptor(dataDir, header.version, header.format);\n\n        logger.debug(\"[Table #{}] {} Components to write: {}\", cfs.metadata(), desc.filenameFor(Component.DATA), components);\n\n        return new SSTableZeroCopyWriter(desc, cfs.metadata, lifecycleNewTracker, components);\n    }\n}", "class_id": 0, "repo": "Pio1006/cassandra", "file": "src/java/org/apache/cassandra/db/streaming/CassandraEntireSSTableStreamReader.java", "last_update_at": "2019-07-24T01:03:40+00:00", "question_id": "18e408ad48f9c79560eafb262b0e0535194da6cb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CassandraEntireSSTableStreamReader implements IStreamReader\n{\n    private static final Logger logger = LoggerFactory.getLogger(CassandraEntireSSTableStreamReader.class);\n    private final TableId tableId;\n    private final StreamSession session;\n    private final StreamMessageHeader messageHeader;\n    private final CassandraStreamHeader header;\n    private final int fileSequenceNumber;\n    public CassandraEntireSSTableStreamReader(StreamMessageHeader messageHeader, CassandraStreamHeader streamHeader, StreamSession session)\n    {\n        if (streamHeader.format != SSTableFormat.Type.BIG && streamHeader.format != SSTableFormat.Type.BTI)\n            throw new AssertionError(\"Unsupported SSTable format \" + streamHeader.format);\n        if (session.getPendingRepair() != null)\n        {\n            // we should only ever be streaming pending repair sstables if the session has a pending repair id\n            if (!session.getPendingRepair().equals(messageHeader.pendingRepair))\n                throw new IllegalStateException(format(\"Stream Session & SSTable (%s) pendingRepair UUID mismatch.\", messageHeader.tableId));\n        }\n        this.header = streamHeader;\n        this.session = session;\n        this.messageHeader = messageHeader;\n        this.tableId = messageHeader.tableId;\n        this.fileSequenceNumber = messageHeader.sequenceNumber;\n    }\n    /**\n     * @param in where this reads data from\n     * @return SSTable transferred\n     * @throws IOException if reading the remote sstable fails. Will throw an RTE if local write fails.\n     */\n    @SuppressWarnings(\"resource\") // input needs to remain open, streams on top of it can't be closed\n    @Override\n    public SSTableMultiWriter read(DataInputPlus in) throws IOException\n    {\n        ColumnFamilyStore cfs = ColumnFamilyStore.getIfExists(tableId);\n        if (cfs == null)\n        {\n            // schema was dropped during streaming\n            throw new IOException(\"Table \" + tableId + \" was dropped during streaming\");\n        }\n        ComponentManifest manifest = header.componentManifest;\n        long totalSize = manifest.totalSize();\n        logger.debug(\"[Stream #{}] Started receiving sstable #{} from {}, size = {}, table = {}\",\n                     session.planId(),\n                     fileSequenceNumber,\n                     session.peer,\n                     prettyPrintMemory(totalSize),\n                     cfs.metadata());\n        SSTableZeroCopyWriter writer = null;\n        try\n        {\n            writer = createWriter(cfs, totalSize, manifest.components());\n            long bytesRead = 0;\n            for (Component component : manifest.components())\n            {\n                long length = manifest.sizeOf(component);\n                logger.debug(\"[Stream #{}] Started receiving {} component from {}, componentSize = {}, readBytes = {}, totalSize = {}\",\n                             session.planId(),\n                             component,\n                             session.peer,\n                             prettyPrintMemory(length),\n                             prettyPrintMemory(bytesRead),\n                             prettyPrintMemory(totalSize));\n                writer.writeComponent(component.type, in, length);\n                session.progress(writer.descriptor.filenameFor(component), ProgressInfo.Direction.IN, length, length);\n                bytesRead += length;\n                logger.debug(\"[Stream #{}] Finished receiving {} component from {}, componentSize = {}, readBytes = {}, totalSize = {}\",\n                             session.planId(),\n                             component,\n                             session.peer,\n                             prettyPrintMemory(length),\n                             prettyPrintMemory(bytesRead),\n                             prettyPrintMemory(totalSize));\n            }\n            UnaryOperator<StatsMetadata> transform = stats -> stats.mutateLevel(header.sstableLevel)\n                                                                   .mutateRepairedMetadata(messageHeader.repairedAt, messageHeader.pendingRepair, false);\n            String description = String.format(\"level %s and repairedAt time %s and pendingRepair %s\",\n                                               header.sstableLevel, messageHeader.repairedAt, messageHeader.pendingRepair);\n            writer.descriptor.getMetadataSerializer().mutate(writer.descriptor, description, transform);\n            return writer;\n        }\n        catch (Throwable e)\n        {\n            logger.error(\"[Stream {}] Error while reading sstable from stream for table = {}\", session.planId(), cfs.metadata(), e);\n            if (writer != null)\n                e = writer.abort(e);\n            Throwables.throwIfUnchecked(e);\n            throw new RuntimeException(e);\n        }\n    }\n    private File getDataDir(ColumnFamilyStore cfs, long totalSize) throws IOException\n    {\n        Directories.DataDirectory localDir = cfs.getDirectories().getWriteableLocation(totalSize);\n        if (localDir == null)\n            throw new IOException(format(\"Insufficient disk space to store %s\", prettyPrintMemory(totalSize)));\n        File dir = cfs.getDirectories().getLocationForDisk(cfs.getDiskBoundaries().getCorrectDiskForKey(header.firstKey));\n        if (dir == null)\n            return cfs.getDirectories().getDirectoryForNewSSTables();\n        return dir;\n    }\n    @SuppressWarnings(\"resource\")\n    protected SSTableZeroCopyWriter createWriter(ColumnFamilyStore cfs, long totalSize, Collection<Component> components) throws IOException\n    {\n        File dataDir = getDataDir(cfs, totalSize);\n        StreamReceiver streamReceiver = session.getAggregator(tableId);\n        assert streamReceiver instanceof CassandraStreamReceiver;\n        LifecycleNewTracker lifecycleNewTracker = CassandraStreamReceiver.fromReceiver(session.getAggregator(tableId)).createLifecycleNewTracker();\n        Descriptor desc = cfs.newSSTableDescriptor(dataDir, header.version, header.format);\n        logger.debug(\"[Table #{}] {} Components to write: {}\", cfs.metadata(), desc.filenameFor(Component.DATA), components);\n        return new SSTableZeroCopyWriter(desc, cfs.metadata, lifecycleNewTracker, components);\n    }\n"]]}
{"hexsha": "e854fd0b23c578a892d03de494d8765675941309", "ext": "java", "lang": "Java", "content": "@ApiModel(description = \"\")\npublic class WsdlDTO  {\n  \n  \n  @NotNull\n  private String name = null;\n  \n  \n  private String wsdlDefinition = null;\n\n  \n  /**\n   **/\n  @ApiModelProperty(required = true, value = \"\")\n  @JsonProperty(\"name\")\n  public String getName() {\n    return name;\n  }\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  \n  /**\n   **/\n  @ApiModelProperty(value = \"\")\n  @JsonProperty(\"wsdlDefinition\")\n  public String getWsdlDefinition() {\n    return wsdlDefinition;\n  }\n  public void setWsdlDefinition(String wsdlDefinition) {\n    this.wsdlDefinition = wsdlDefinition;\n  }\n\n  \n\n  @Override\n  public String toString()  {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class WsdlDTO {\\n\");\n    \n    sb.append(\"  name: \").append(name).append(\"\\n\");\n    sb.append(\"  wsdlDefinition: \").append(wsdlDefinition).append(\"\\n\");\n    sb.append(\"}\\n\");\n    return sb.toString();\n  }\n}", "class_id": 0, "repo": "lathlk/carbon-apimgt", "file": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher/src/gen/java/org/wso2/carbon/apimgt/rest/api/publisher/dto/WsdlDTO.java", "last_update_at": "2019-10-27T07:38:16+00:00", "question_id": "e854fd0b23c578a892d03de494d8765675941309", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ApiModel(description = \"\")\npublic class WsdlDTO  {\n  @NotNull\n  private String name = null;\n  private String wsdlDefinition = null;\n  /**\n   **/\n  @ApiModelProperty(required = true, value = \"\")\n  @JsonProperty(\"name\")\n  public String getName() {\n    return name;\n  }\n  public void setName(String name) {\n    this.name = name;\n  }\n  /**\n   **/\n  @ApiModelProperty(value = \"\")\n  @JsonProperty(\"wsdlDefinition\")\n  public String getWsdlDefinition() {\n    return wsdlDefinition;\n  }\n  public void setWsdlDefinition(String wsdlDefinition) {\n    this.wsdlDefinition = wsdlDefinition;\n  }\n  @Override\n  public String toString()  {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class WsdlDTO {\\n\");\n    sb.append(\"  name: \").append(name).append(\"\\n\");\n    sb.append(\"  wsdlDefinition: \").append(wsdlDefinition).append(\"\\n\");\n    sb.append(\"}\\n\");\n    return sb.toString();\n  }\n"]]}
{"hexsha": "4641d2e9a5af6f1bf0a386fc4e83e19729eae3c3", "ext": "java", "lang": "Java", "content": "public class DefaultApiKeysGenerator implements ApiKeysGenerator {\n\n\tprivate static final long serialVersionUID = -5113876047087704787L;\n\t\n\tprotected String algorithm;\n\tprotected String encoding;\n\t\n\t@Override\n\tpublic String [] generate () throws ApiKeysGeneratorException {\n\t\t\n\t\tif (Lang.isNullOrEmpty (algorithm)) {\n\t\t\talgorithm = \"HMACSHA1\";\n\t\t}\n\t\t\n\t\tif (Lang.isNullOrEmpty (encoding)) {\n\t\t\tencoding = Encodings.UTF8;\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tKeyGenerator generator = KeyGenerator.getInstance (algorithm);\n\n\t\t\tgenerator.init (120);\n\t\t\tbyte[] accessKey = generator.generateKey ().getEncoded ();\n\n\t\t\tgenerator.init (240);\n\t\t\tbyte[] secretKey = generator.generateKey ().getEncoded ();\n\n\t\t\treturn new String [] {hash (accessKey, encoding), hash (secretKey, encoding)};\n\t\t} catch (Exception ex) {\n\t\t\tthrow new ApiKeysGeneratorException (ex);\n\t\t}\n\t\t\n\t}\n\n\tpublic void setAlgorithm (String algorithm) {\n\t\tthis.algorithm = algorithm;\n\t}\n\tpublic String getAlgorithm () {\n\t\treturn algorithm;\n\t}\n\n\tpublic void setEncoding (String encoding) {\n\t\tthis.encoding = encoding;\n\t}\n\tpublic String getEncoding () {\n\t\treturn encoding;\n\t}\n\n\tprivate static String hash (byte [] key, String encoding) throws Exception {\n\t\treturn new String (Base64.encodeBase64 (key), encoding).trim ();\n\t}\n\t\n\tpublic static void main(String[] args) throws ApiKeysGeneratorException {\n\t\tString [] keys = new DefaultApiKeysGenerator ().generate ();\n\t\tSystem.out.println (keys [0]);\n\t\tSystem.out.println (keys [1]);\n\t}\n\t\n}", "class_id": 0, "repo": "bluenimble/serverless", "file": "sdks/bluenimble-jvm-sdk/src/main/java/com/bluenimble/platform/security/impls/DefaultApiKeysGenerator.java", "last_update_at": "2019-05-04T00:28:56+00:00", "question_id": "4641d2e9a5af6f1bf0a386fc4e83e19729eae3c3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DefaultApiKeysGenerator implements ApiKeysGenerator {\n\tprivate static final long serialVersionUID = -5113876047087704787L;\n\t\n\tprotected String algorithm;\n\tprotected String encoding;\n\t\n\t@Override\n\tpublic String [] generate () throws ApiKeysGeneratorException {\n\t\t\n\t\tif (Lang.isNullOrEmpty (algorithm)) {\n\t\t\talgorithm = \"HMACSHA1\";\n\t\t}\n\t\t\n\t\tif (Lang.isNullOrEmpty (encoding)) {\n\t\t\tencoding = Encodings.UTF8;\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tKeyGenerator generator = KeyGenerator.getInstance (algorithm);\n\t\t\tgenerator.init (120);\n\t\t\tbyte[] accessKey = generator.generateKey ().getEncoded ();\n\t\t\tgenerator.init (240);\n\t\t\tbyte[] secretKey = generator.generateKey ().getEncoded ();\n\t\t\treturn new String [] {hash (accessKey, encoding), hash (secretKey, encoding)};\n\t\t} catch (Exception ex) {\n\t\t\tthrow new ApiKeysGeneratorException (ex);\n\t\t}\n\t\t\n\t}\n\tpublic void setAlgorithm (String algorithm) {\n\t\tthis.algorithm = algorithm;\n\t}\n\tpublic String getAlgorithm () {\n\t\treturn algorithm;\n\t}\n\tpublic void setEncoding (String encoding) {\n\t\tthis.encoding = encoding;\n\t}\n\tpublic String getEncoding () {\n\t\treturn encoding;\n\t}\n\tprivate static String hash (byte [] key, String encoding) throws Exception {\n\t\treturn new String (Base64.encodeBase64 (key), encoding).trim ();\n\t}\n\t\n\tpublic static void main(String[] args) throws ApiKeysGeneratorException {\n\t\tString [] keys = new DefaultApiKeysGenerator ().generate ();\n\t\tSystem.out.println (keys [0]);\n\t\tSystem.out.println (keys [1]);\n\t}\n\t\n"]]}
{"hexsha": "4535051c7c3cb06e6fb1e3ce1a44f900648e6f1c", "ext": "java", "lang": "Java", "content": "public class GraphQLUIServlet extends HttpServlet {\n\n    private String graphQlPath = null;\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        ConfigurationUtil configurationUtil = ConfigurationUtil.getInstance();\n\n        if (this.graphQlPath == null) {\n            String contextPath = configurationUtil.get(\"kumuluzee.server.context-path\").orElse(\"\");\n            String path = configurationUtil.get(\"kumuluzee.graphql.mapping\").orElse(\"/graphql\");\n\n            if (contextPath.endsWith(\"/\")) {\n                contextPath = contextPath.substring(0, contextPath.length() - 1);\n            }\n\n            if (!path.startsWith(\"/\")) {\n                path = \"/\" + path;\n            }\n\n            path = contextPath + path;\n\n            try {\n                URI u = new URI(path);\n\n                if(u.isAbsolute()) {\n                    resp.getWriter().println(\"URL must be relative. Extension not initialized.\");\n                    return;\n                }\n            } catch(Exception E) {\n                resp.getWriter().println(\"Malformed url: \" + path + \". Extension not initialized.\");\n                return;\n            }\n\n            if (path.charAt(0) != '/') {\n                path = '/' + path;\n            }\n\n            graphQlPath = path;\n        }\n\n        if (req.getPathInfo() == null) {\n            // no trailing slash, redirect to trailing slash in order to fix relative requests\n            resp.sendRedirect(req.getContextPath() + req.getServletPath() + \"/\");\n            return;\n        }\n\n        if (\"/main.js\".equals(req.getPathInfo())) {\n            resp.setContentType(\"application/javascript\");\n            // inject _kumuluzee_graphql_path variable into js\n            sendFile(resp, \"main.js\", \"_kumuluzee_graphql_path = \\\"\" + graphQlPath + \"\\\";\\n\");\n        } else {\n            sendFile(resp, \"index.html\", null);\n        }\n    }\n\n    private void sendFile(HttpServletResponse resp, String file, String prepend) throws IOException {\n        InputStream in = this.getClass().getResourceAsStream(\"/html/\" + file);\n        OutputStream out = resp.getOutputStream();\n\n        if (prepend != null) {\n            out.write(prepend.getBytes());\n        }\n\n        byte[] buf = new byte[10000];\n        int length;\n        while ((length = in.read(buf)) > 0) {\n            out.write(buf, 0, length);\n        }\n\n        in.close();\n        out.close();\n    }\n}", "class_id": 0, "repo": "kumuluz/kumuluzee-graphql", "file": "graphql-ui/src/main/java/com/kumuluz/ee/graphql/ui/servlets/GraphQLUIServlet.java", "last_update_at": "2019-05-01T11:27:03+00:00", "question_id": "4535051c7c3cb06e6fb1e3ce1a44f900648e6f1c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GraphQLUIServlet extends HttpServlet {\n    private String graphQlPath = null;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        ConfigurationUtil configurationUtil = ConfigurationUtil.getInstance();\n        if (this.graphQlPath == null) {\n            String contextPath = configurationUtil.get(\"kumuluzee.server.context-path\").orElse(\"\");\n            String path = configurationUtil.get(\"kumuluzee.graphql.mapping\").orElse(\"/graphql\");\n            if (contextPath.endsWith(\"/\")) {\n                contextPath = contextPath.substring(0, contextPath.length() - 1);\n            }\n            if (!path.startsWith(\"/\")) {\n                path = \"/\" + path;\n            }\n            path = contextPath + path;\n            try {\n                URI u = new URI(path);\n                if(u.isAbsolute()) {\n                    resp.getWriter().println(\"URL must be relative. Extension not initialized.\");\n                    return;\n                }\n            } catch(Exception E) {\n                resp.getWriter().println(\"Malformed url: \" + path + \". Extension not initialized.\");\n                return;\n            }\n            if (path.charAt(0) != '/') {\n                path = '/' + path;\n            }\n            graphQlPath = path;\n        }\n        if (req.getPathInfo() == null) {\n            // no trailing slash, redirect to trailing slash in order to fix relative requests\n            resp.sendRedirect(req.getContextPath() + req.getServletPath() + \"/\");\n            return;\n        }\n        if (\"/main.js\".equals(req.getPathInfo())) {\n            resp.setContentType(\"application/javascript\");\n            // inject _kumuluzee_graphql_path variable into js\n            sendFile(resp, \"main.js\", \"_kumuluzee_graphql_path = \\\"\" + graphQlPath + \"\\\";\\n\");\n        } else {\n            sendFile(resp, \"index.html\", null);\n        }\n    }\n    private void sendFile(HttpServletResponse resp, String file, String prepend) throws IOException {\n        InputStream in = this.getClass().getResourceAsStream(\"/html/\" + file);\n        OutputStream out = resp.getOutputStream();\n        if (prepend != null) {\n            out.write(prepend.getBytes());\n        }\n        byte[] buf = new byte[10000];\n        int length;\n        while ((length = in.read(buf)) > 0) {\n            out.write(buf, 0, length);\n        }\n        in.close();\n        out.close();\n    }\n"]]}
{"hexsha": "e8fa10e616d63f166afde3879bafde0396873be0", "ext": "java", "lang": "Java", "content": "public class Main {\n\n\tpublic static void main (String[] args) throws IOException {\n\t\tNameServerProxy ns = NameServerProxy.locateNS(null);\n\t\tPyroProxy remoteobject = new PyroProxy(ns.lookup(\"ping.playfield\"));\n\t\tObject result = remoteobject.call(\"test\", 42, \"hello\", new int[]{1,2,3});\n\t\tString message = (String)result;  // cast to the type that 'pythonmethod' returns\n\t\tSystem.out.println(\"result message=\"+message);\n\t\tremoteobject.close();\n\t\tns.close();\n\t}\n\t\n}", "class_id": 0, "repo": "niccokunzmann/ping", "file": "java/ping/src/ping/Main.java", "last_update_at": "2019-08-19T08:03:00+00:00", "question_id": "e8fa10e616d63f166afde3879bafde0396873be0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Main {\n\tpublic static void main (String[] args) throws IOException {\n\t\tNameServerProxy ns = NameServerProxy.locateNS(null);\n\t\tPyroProxy remoteobject = new PyroProxy(ns.lookup(\"ping.playfield\"));\n\t\tObject result = remoteobject.call(\"test\", 42, \"hello\", new int[]{1,2,3});\n\t\tString message = (String)result;  // cast to the type that 'pythonmethod' returns\n\t\tSystem.out.println(\"result message=\"+message);\n\t\tremoteobject.close();\n\t\tns.close();\n\t}\n\t\n"]]}
{"hexsha": "df9d190287ecfb6ec430b13b7c4c37613e619845", "ext": "java", "lang": "Java", "content": "public class OperationDispatcher implements Runnable {\n    \n\tprivate static Logger logger = LoggerFactory.getLogger(OperationDispatcher.class);\n\t\n    private static final long POLLING_DELAY = 10;\n    private static final long POLLING_INTERVAL = 10;\n    \n    private final TrackerDeviceContextService contextService;\n    private final DeviceCredentials tenantCredentials;\n    private final OperationExecutor operationHelper;\n    private volatile ScheduledFuture<?> future;\n\n\n    public OperationDispatcher(DeviceCredentials tenantCredentials,  \n    \t\tTrackerDeviceContextService contextService, OperationExecutor operationHelper) throws SDKException {\n\t\tthis.tenantCredentials = tenantCredentials;\n        this.contextService = contextService;\n\t\tthis.operationHelper = operationHelper;\n    }\n    \n    public void startPolling(ScheduledExecutorService operationsExecutor) {\n        future = operationsExecutor.scheduleWithFixedDelay(this, POLLING_DELAY, POLLING_INTERVAL, SECONDS);\n    }\n\n    @Override\n    public void run() {\n        logger.trace(\"Executing queued operations\");\n        try {\n            contextService.enterContext(tenantCredentials.getTenant());\n            executePendingOps();\n            contextService.leaveContext();\n        } catch (Exception x) {\n            logger.warn(\"Error while executing operations\", x);\n        }\n    }\n\n    private void executePendingOps() throws SDKException {\n        logger.debug(\"Querying for pending operations\");\n        for (OperationRepresentation operation : getOperationsByStatus(OperationStatus.PENDING)) {\n        \t// TODO lest enter the context here \n        \tGId deviceId = operation.getDeviceId();\n        \tTrackerDevice device = ManagedObjectCache.instance().get(deviceId);\n        \tif (device == null) {\n        \t\tlogger.trace(\"Ignore operation with ID {} -> device with id {} hasn't been identified yet\", operation.getId(), deviceId);\n        \t\tcontinue; // Device hasn't been identified yet\n        \t}\n        \tcontextService.enterContext(tenantCredentials.getTenant(), device.getImei());\n        \ttry {\n        \t\toperationHelper.execute(operation, device);\n        \t} finally {\n        \t\tcontextService.leaveContext();\n        \t}\n        }\n    }\n    \n    private Iterable<OperationRepresentation> getOperationsByStatus(OperationStatus status) throws SDKException {\n        Iterable<OperationRepresentation> operationsIterable = Collections.emptyList();\n        try {\n            operationsIterable = operationHelper.getOperationsByStatusAndAgent(status);\n//            when tenant is disabled then thrown exception is BeanInstantiationException with SDKException with 401 status as a cause\n        } catch (final Exception e) {\n//            404 - someone deleted device, 401 tenant is disabled\n            switch (handleSDKException(e, 401, 404)) {\n                case OTHER_EXCEPTION:\n                    throw e;\n                case STATUS_MATCHES:\n                    if (future != null) {\n                        future.cancel(false);\n                    }\n            }\n        }\n        return operationsIterable;\n    }\n\n}", "class_id": 0, "repo": "reschrei1/cumulocity", "file": "tracker-agent/src/main/java/c8y/trackeragent/operations/OperationDispatcher.java", "last_update_at": "2019-02-22T20:58:09+00:00", "question_id": "df9d190287ecfb6ec430b13b7c4c37613e619845", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OperationDispatcher implements Runnable {\n\tprivate static Logger logger = LoggerFactory.getLogger(OperationDispatcher.class);\n\t\n    private static final long POLLING_DELAY = 10;\n    private static final long POLLING_INTERVAL = 10;\n    private final TrackerDeviceContextService contextService;\n    private final DeviceCredentials tenantCredentials;\n    private final OperationExecutor operationHelper;\n    private volatile ScheduledFuture<?> future;\n    public OperationDispatcher(DeviceCredentials tenantCredentials,  \n    \t\tTrackerDeviceContextService contextService, OperationExecutor operationHelper) throws SDKException {\n\t\tthis.tenantCredentials = tenantCredentials;\n        this.contextService = contextService;\n\t\tthis.operationHelper = operationHelper;\n    }\n    public void startPolling(ScheduledExecutorService operationsExecutor) {\n        future = operationsExecutor.scheduleWithFixedDelay(this, POLLING_DELAY, POLLING_INTERVAL, SECONDS);\n    }\n    @Override\n    public void run() {\n        logger.trace(\"Executing queued operations\");\n        try {\n            contextService.enterContext(tenantCredentials.getTenant());\n            executePendingOps();\n            contextService.leaveContext();\n        } catch (Exception x) {\n            logger.warn(\"Error while executing operations\", x);\n        }\n    }\n    private void executePendingOps() throws SDKException {\n        logger.debug(\"Querying for pending operations\");\n        for (OperationRepresentation operation : getOperationsByStatus(OperationStatus.PENDING)) {\n        \t// TODO lest enter the context here \n        \tGId deviceId = operation.getDeviceId();\n        \tTrackerDevice device = ManagedObjectCache.instance().get(deviceId);\n        \tif (device == null) {\n        \t\tlogger.trace(\"Ignore operation with ID {} -> device with id {} hasn't been identified yet\", operation.getId(), deviceId);\n        \t\tcontinue; // Device hasn't been identified yet\n        \t}\n        \tcontextService.enterContext(tenantCredentials.getTenant(), device.getImei());\n        \ttry {\n        \t\toperationHelper.execute(operation, device);\n        \t} finally {\n        \t\tcontextService.leaveContext();\n        \t}\n        }\n    }\n    private Iterable<OperationRepresentation> getOperationsByStatus(OperationStatus status) throws SDKException {\n        Iterable<OperationRepresentation> operationsIterable = Collections.emptyList();\n        try {\n            operationsIterable = operationHelper.getOperationsByStatusAndAgent(status);\n//            when tenant is disabled then thrown exception is BeanInstantiationException with SDKException with 401 status as a cause\n        } catch (final Exception e) {\n//            404 - someone deleted device, 401 tenant is disabled\n            switch (handleSDKException(e, 401, 404)) {\n                case OTHER_EXCEPTION:\n                    throw e;\n                case STATUS_MATCHES:\n                    if (future != null) {\n                        future.cancel(false);\n                    }\n            }\n        }\n        return operationsIterable;\n    }\n"]]}
{"hexsha": "3f832fd92f3dbb085aa0e555bafb95e2496d546c", "ext": "java", "lang": "Java", "content": "public class SubsetProxy  extends AbstractProxy\n{\n   private static final String PREFIX = \"sys-subset-\";\n\n\n   /**\n    * \n    */\n   public SubsetProxy() { }\n\n   /**\n    * @param h\n    * @param name\n    */\n   public SubsetProxy(IHandle h, String name)\n   {\n      super(h, decorate(name));\n   }\n\n//   public SubsetProxy(XModel m, String name)\n//   {\n//      super(m, );\n//      \n//      m.associate(name(), this);      \n//      \n//      JimaMisc.log().println(\"subset proxy: \" + name + \" -> \" + get_handle());\n//   }\n\n   private static String decorate(String name)\n   {\n      return PREFIX + name;\n   }\n   \n   private static String undecorate(String s)\n   {\n      return s.substring(PREFIX.length());\n   }\n   \n\n//   /**\n//    * @see il.ac.technion.micropatterns.jane.model.IProxy#accept(il.ac.technion.micropatterns.jane.model.IVisitor)\n//    */\n//   public void accept(IVisitor v)\n//   {\n//      v.visit(this);\n//   }\n\n   /**\n    * @see il.ac.technion.micropatterns.jane.model.IProxy#create(il.ac.technion.micropatterns.jane.model.IModelRequest)\n    */\n   public IElement create(IModelRequest mr)\n   {\n      JimaMisc.ensure(mr != null);\n      \n      XModel m = mr.model();\n      try\n      {\n         IElement result = (IElement) m.fetch(this.name());\n         return result;\n      }\n      catch (Throwable e)\n      {\n//         System.out.println(\"Error \" + e);\n//         e.printStackTrace();\n//         \n         IElement result = new SubsetElement(get_handle(), this.name());\n         return result;\n      }\n   }\n   \n   public String pretty_name()\n   {\n      return undecorate(name());\n   }\n   \n   public String toString()\n   {\n      return \"SubsetProxy(\" + pretty_name() + \", \" + get_handle() + \")\";\n   }   \n}", "class_id": 0, "repo": "imaman/micro-patterns", "file": "src/main/java/il/ac/technion/micropatterns/jane/elements/SubsetProxy.java", "last_update_at": "2019-07-15T19:30:35+00:00", "question_id": "3f832fd92f3dbb085aa0e555bafb95e2496d546c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SubsetProxy  extends AbstractProxy\n{\n   private static final String PREFIX = \"sys-subset-\";\n   /**\n    * \n    */\n   public SubsetProxy() { }\n   /**\n    * @param h\n    * @param name\n    */\n   public SubsetProxy(IHandle h, String name)\n   {\n      super(h, decorate(name));\n   }\n//   public SubsetProxy(XModel m, String name)\n//   {\n//      super(m, );\n//      \n//      m.associate(name(), this);      \n//      \n//      JimaMisc.log().println(\"subset proxy: \" + name + \" -> \" + get_handle());\n//   }\n   private static String decorate(String name)\n   {\n      return PREFIX + name;\n   }\n   private static String undecorate(String s)\n   {\n      return s.substring(PREFIX.length());\n   }\n//   /**\n//    * @see il.ac.technion.micropatterns.jane.model.IProxy#accept(il.ac.technion.micropatterns.jane.model.IVisitor)\n//    */\n//   public void accept(IVisitor v)\n//   {\n//      v.visit(this);\n//   }\n   /**\n    * @see il.ac.technion.micropatterns.jane.model.IProxy#create(il.ac.technion.micropatterns.jane.model.IModelRequest)\n    */\n   public IElement create(IModelRequest mr)\n   {\n      JimaMisc.ensure(mr != null);\n      XModel m = mr.model();\n      try\n      {\n         IElement result = (IElement) m.fetch(this.name());\n         return result;\n      }\n      catch (Throwable e)\n      {\n//         System.out.println(\"Error \" + e);\n//         e.printStackTrace();\n//         \n         IElement result = new SubsetElement(get_handle(), this.name());\n         return result;\n      }\n   }\n   public String pretty_name()\n   {\n      return undecorate(name());\n   }\n   public String toString()\n   {\n      return \"SubsetProxy(\" + pretty_name() + \", \" + get_handle() + \")\";\n   }   \n"]]}
{"hexsha": "f921f6507cad2c813014192f14a31ca2fce652a1", "ext": "java", "lang": "Java", "content": "public class ModelManager implements Model {\n    private static final Logger logger = LogsCenter.getLogger(ModelManager.class);\n\n    private final KeyboardFlashCards keyboardFlashCards;\n    private final UserPrefs userPrefs;\n    private final FilteredList<FlashCard> filteredFlashCards;\n    private final FilteredList<Deadline> filteredDeadlines;\n    private final FilteredList<Category> categoryList;\n    private FlashCardTestModel flashCardTestModel;\n    private ArrayList<Float> performance;\n\n\n    /**\n     * Initializes a ModelManager with the given keyboardFlashCards and userPrefs.\n     */\n    public ModelManager(ReadOnlyKeyboardFlashCards addressBook, ReadOnlyUserPrefs userPrefs) {\n        super();\n        requireAllNonNull(addressBook, userPrefs);\n\n        logger.fine(\"Initializing with address book: \" + addressBook + \" and user prefs \" + userPrefs);\n\n        this.keyboardFlashCards = new KeyboardFlashCards(addressBook);\n        this.userPrefs = new UserPrefs(userPrefs);\n        filteredFlashCards = new FilteredList<>(this.keyboardFlashCards.getFlashcardList());\n        filteredDeadlines = new FilteredList<>(this.keyboardFlashCards.getDeadlineList());\n        categoryList = new FilteredList<>(this.keyboardFlashCards.getCategoryList());\n        flashCardTestModel = new FlashCardTestModel(new LinkedList<>());\n        this.performance = new ArrayList<Float>();\n    }\n\n    public ModelManager() {\n        this(new KeyboardFlashCards(), new UserPrefs());\n    }\n\n    //=========== UserPrefs ==================================================================================\n\n    @Override\n    public void setUserPrefs(ReadOnlyUserPrefs userPrefs) {\n        requireNonNull(userPrefs);\n        this.userPrefs.resetData(userPrefs);\n    }\n\n    @Override\n    public ReadOnlyUserPrefs getUserPrefs() {\n        return userPrefs;\n    }\n\n    @Override\n    public GuiSettings getGuiSettings() {\n        return userPrefs.getGuiSettings();\n    }\n\n    @Override\n    public void setGuiSettings(GuiSettings guiSettings) {\n        requireNonNull(guiSettings);\n        userPrefs.setGuiSettings(guiSettings);\n    }\n\n    public void setStyleSheet(String styleSheet) {\n        userPrefs.setStyleSheet(styleSheet);\n    }\n\n    public String getStyleSheet() {\n        return userPrefs.getStyleSheet();\n    }\n\n    @Override\n    public Path getKeyboardFlashCardsFilePath() {\n        return userPrefs.getKeyboardFlashCardsFilePath();\n    }\n\n    @Override\n    public void setKeyboardFlashCardsFilePath(Path keyboardFlashCardsFilePath) {\n        requireNonNull(keyboardFlashCardsFilePath);\n        userPrefs.setKeyboardFlashCardsFilePath(keyboardFlashCardsFilePath);\n    }\n\n    //=========== KeyboardFlashCards ================================================================================\n\n    @Override\n    public void setKeyboardFlashCards(ReadOnlyKeyboardFlashCards keyboardFlashCards) {\n        this.keyboardFlashCards.resetData(keyboardFlashCards);\n    }\n\n    @Override\n    public ReadOnlyKeyboardFlashCards getKeyboardFlashCards() {\n        return keyboardFlashCards;\n    }\n\n    @Override\n    public boolean hasFlashcard(FlashCard flashCard) {\n        requireNonNull(flashCard);\n        return keyboardFlashCards.hasFlashcard(flashCard);\n    }\n\n    @Override\n    public void deleteFlashCard(FlashCard target) {\n        keyboardFlashCards.removeFlashCard(target);\n    }\n\n    //@@author shutingy\n    @Override\n    public void addFlashCard(FlashCard flashCard) {\n        keyboardFlashCards.addFlashcard(flashCard);\n        updateFilteredFlashCardList(PREDICATE_SHOW_ALL_FLASHCARDS);\n        updateFilteredCategoryList(PREDICATE_SHOW_ALL_CATEGORIES);\n    }\n\n    @Override\n    public void setFlashCard(FlashCard target, FlashCard editedFlashCard) {\n        requireAllNonNull(target, editedFlashCard);\n\n        keyboardFlashCards.setFlashcard(target, editedFlashCard);\n    }\n\n    @Override\n    public void addDeadline(Deadline deadline) {\n        keyboardFlashCards.addDeadline(deadline);\n        updateFilteredDeadlineList(PREDICATE_SHOW_ALL_DEADLINES);\n    }\n\n    @Override\n    public boolean hasDeadline(Deadline deadline) {\n        requireNonNull(deadline);\n        return keyboardFlashCards.hasDeadline(deadline);\n    }\n\n    //@@author LeonardTay748\n    @Override\n    public void editStats(int type) {\n        if (type == 0) {\n            keyboardFlashCards.addGood();\n        }\n        if (type == 1) {\n            keyboardFlashCards.addHard();\n        }\n        if (type == 2) {\n            keyboardFlashCards.addEasy();\n        }\n    }\n\n    public int[] getTestStats() {\n        return keyboardFlashCards.getStats();\n    }\n\n    @Override\n    public ArrayList<Float> getPerformance() {\n        return performance;\n    }\n\n    @Override\n    public void updatePerformance(Model model) {\n        requireNonNull(model);\n        float numGood = model.getFilteredFlashCardListNoCommit(new RatingContainsKeywordPredicate(\"good\")).size();\n        float numHard = model.getFilteredFlashCardListNoCommit(new RatingContainsKeywordPredicate(\"hard\")).size();\n        float numEasy = model.getFilteredFlashCardListNoCommit(new RatingContainsKeywordPredicate(\"easy\")).size();\n        float value;\n        if ((numEasy + numGood + numHard) == 0) {\n            value = 0;\n        } else {\n            value = ((numEasy + numGood) * 100) / (numEasy + numGood + numHard);\n        }\n        performance.add(value);\n    }\n\n    @Override\n    public void resetPerformance(Model model) {\n        requireNonNull(model);\n        performance.clear();\n    }\n\n    @Override\n    public void deleteDeadline(Deadline target) {\n        keyboardFlashCards.removeDeadline(target);\n    }\n\n    @Override\n    public void setDeadline(Deadline target, Deadline editedDeadline) {\n        requireAllNonNull(target, editedDeadline);\n        keyboardFlashCards.setDeadline(target, editedDeadline);\n    }\n\n\n    //=========== Filtered FlashCard List Accessors =============================================================\n\n    /**\n     * Returns an unmodifiable view of the list of {@code FlashCard} backed by the internal list of\n     * {@code versionedAddressBook}\n     */\n    @Override\n    public ObservableList<FlashCard> getFilteredFlashCardList() {\n        return filteredFlashCards;\n    }\n\n    @Override\n    public void updateFilteredFlashCardList(Predicate<FlashCard> predicate) {\n        requireNonNull(predicate);\n        filteredFlashCards.setPredicate(predicate);\n    }\n\n    //=========== Filtered Deadline List Accessors =============================================================\n\n    /**\n     * Returns an unmodifiable view of the list of {@code Deadline} backed by the internal list of\n     * {@code versionedAddressBook}\n     */\n    @Override\n    public ObservableList<Deadline> getFilteredDeadlineList() {\n        return filteredDeadlines;\n    }\n\n    @Override\n    public void updateFilteredDeadlineList(Predicate<Deadline> predicate) {\n        requireNonNull(predicate);\n        filteredDeadlines.setPredicate(predicate);\n    }\n\n    //@@author keiteo\n    @Override\n    public ObservableList<FlashCard> getFlashCardList() {\n        return keyboardFlashCards.getFlashcardList();\n    }\n\n    //=========== FlashCardTestModel ================================================================================\n    @Override\n    public void initializeTestModel(List<FlashCard> testList) {\n        flashCardTestModel = new FlashCardTestModel(testList);\n    }\n\n    @Override\n    public boolean hasTestFlashCard() {\n        return !flashCardTestModel.isEmpty();\n    }\n\n    @Override\n    public void setTestFlashCard() {\n        flashCardTestModel.setFlashcard();\n    }\n\n    @Override\n    public String getTestQuestion() {\n        return flashCardTestModel.getQuestion();\n    }\n\n    @Override\n    public String getTestAnswer() {\n        return flashCardTestModel.getAnswer();\n    }\n\n    @Override\n    public FlashCard getCurrentTestFlashCard() {\n        return flashCardTestModel.getCurrentFlashCard();\n    }\n\n    //@@author shutingy\n    @Override\n    public TestFlashCardPanel getTestFlashCardPanel() {\n        return flashCardTestModel.getTestFlashCardPanel();\n    }\n\n    @Override\n    public void showAnswer() {\n        flashCardTestModel.showAnswer();\n    }\n\n    //@@author LeowWB\n    @Override\n    public ObservableList<FlashCard> getFilteredFlashCardListNoCommit(Predicate<FlashCard> predicate) {\n        requireNonNull(predicate);\n        FilteredList<FlashCard> simulatedList = new FilteredList<FlashCard>(filteredFlashCards);\n        simulatedList.setPredicate(predicate);\n        return simulatedList;\n    }\n\n    //@@author shutingy\n    @Override\n    public ObservableList<Category> getCategoryList() {\n        return categoryList;\n    }\n\n    //@@author shutingy\n    @Override\n    public void updateFilteredCategoryList(Predicate<Category> predicate) {\n        requireNonNull(predicate);\n        categoryList.setPredicate(predicate);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        // short circuit if same object\n        if (obj == this) {\n            return true;\n        }\n\n        // instanceof handles nulls\n        if (!(obj instanceof ModelManager)) {\n            return false;\n        }\n\n        // state check\n        ModelManager other = (ModelManager) obj;\n        return keyboardFlashCards.equals(other.keyboardFlashCards)\n                && userPrefs.equals(other.userPrefs)\n                && filteredFlashCards.equals(other.filteredFlashCards)\n                && categoryList.equals(other.categoryList)\n                && filteredDeadlines.equals(other.filteredDeadlines)\n                && flashCardTestModel.equals(other.flashCardTestModel);\n    }\n\n}", "class_id": 0, "repo": "LeonardTay748/main", "file": "src/main/java/seedu/address/model/ModelManager.java", "last_update_at": "2019-10-03T02:45:17+00:00", "question_id": "f921f6507cad2c813014192f14a31ca2fce652a1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ModelManager implements Model {\n    private static final Logger logger = LogsCenter.getLogger(ModelManager.class);\n    private final KeyboardFlashCards keyboardFlashCards;\n    private final UserPrefs userPrefs;\n    private final FilteredList<FlashCard> filteredFlashCards;\n    private final FilteredList<Deadline> filteredDeadlines;\n    private final FilteredList<Category> categoryList;\n    private FlashCardTestModel flashCardTestModel;\n    private ArrayList<Float> performance;\n    /**\n     * Initializes a ModelManager with the given keyboardFlashCards and userPrefs.\n     */\n    public ModelManager(ReadOnlyKeyboardFlashCards addressBook, ReadOnlyUserPrefs userPrefs) {\n        super();\n        requireAllNonNull(addressBook, userPrefs);\n        logger.fine(\"Initializing with address book: \" + addressBook + \" and user prefs \" + userPrefs);\n        this.keyboardFlashCards = new KeyboardFlashCards(addressBook);\n        this.userPrefs = new UserPrefs(userPrefs);\n        filteredFlashCards = new FilteredList<>(this.keyboardFlashCards.getFlashcardList());\n        filteredDeadlines = new FilteredList<>(this.keyboardFlashCards.getDeadlineList());\n        categoryList = new FilteredList<>(this.keyboardFlashCards.getCategoryList());\n        flashCardTestModel = new FlashCardTestModel(new LinkedList<>());\n        this.performance = new ArrayList<Float>();\n    }\n    public ModelManager() {\n        this(new KeyboardFlashCards(), new UserPrefs());\n    }\n    //=========== UserPrefs ==================================================================================\n    @Override\n    public void setUserPrefs(ReadOnlyUserPrefs userPrefs) {\n        requireNonNull(userPrefs);\n        this.userPrefs.resetData(userPrefs);\n    }\n    @Override\n    public ReadOnlyUserPrefs getUserPrefs() {\n        return userPrefs;\n    }\n    @Override\n    public GuiSettings getGuiSettings() {\n        return userPrefs.getGuiSettings();\n    }\n    @Override\n    public void setGuiSettings(GuiSettings guiSettings) {\n        requireNonNull(guiSettings);\n        userPrefs.setGuiSettings(guiSettings);\n    }\n    public void setStyleSheet(String styleSheet) {\n        userPrefs.setStyleSheet(styleSheet);\n    }\n    public String getStyleSheet() {\n        return userPrefs.getStyleSheet();\n    }\n    @Override\n    public Path getKeyboardFlashCardsFilePath() {\n        return userPrefs.getKeyboardFlashCardsFilePath();\n    }\n    @Override\n    public void setKeyboardFlashCardsFilePath(Path keyboardFlashCardsFilePath) {\n        requireNonNull(keyboardFlashCardsFilePath);\n        userPrefs.setKeyboardFlashCardsFilePath(keyboardFlashCardsFilePath);\n    }\n    //=========== KeyboardFlashCards ================================================================================\n    @Override\n    public void setKeyboardFlashCards(ReadOnlyKeyboardFlashCards keyboardFlashCards) {\n        this.keyboardFlashCards.resetData(keyboardFlashCards);\n    }\n    @Override\n    public ReadOnlyKeyboardFlashCards getKeyboardFlashCards() {\n        return keyboardFlashCards;\n    }\n    @Override\n    public boolean hasFlashcard(FlashCard flashCard) {\n        requireNonNull(flashCard);\n        return keyboardFlashCards.hasFlashcard(flashCard);\n    }\n    @Override\n    public void deleteFlashCard(FlashCard target) {\n        keyboardFlashCards.removeFlashCard(target);\n    }\n    //@@author shutingy\n    @Override\n    public void addFlashCard(FlashCard flashCard) {\n        keyboardFlashCards.addFlashcard(flashCard);\n        updateFilteredFlashCardList(PREDICATE_SHOW_ALL_FLASHCARDS);\n        updateFilteredCategoryList(PREDICATE_SHOW_ALL_CATEGORIES);\n    }\n    @Override\n    public void setFlashCard(FlashCard target, FlashCard editedFlashCard) {\n        requireAllNonNull(target, editedFlashCard);\n        keyboardFlashCards.setFlashcard(target, editedFlashCard);\n    }\n    @Override\n    public void addDeadline(Deadline deadline) {\n        keyboardFlashCards.addDeadline(deadline);\n        updateFilteredDeadlineList(PREDICATE_SHOW_ALL_DEADLINES);\n    }\n    @Override\n    public boolean hasDeadline(Deadline deadline) {\n        requireNonNull(deadline);\n        return keyboardFlashCards.hasDeadline(deadline);\n    }\n    //@@author LeonardTay748\n    @Override\n    public void editStats(int type) {\n        if (type == 0) {\n            keyboardFlashCards.addGood();\n        }\n        if (type == 1) {\n            keyboardFlashCards.addHard();\n        }\n        if (type == 2) {\n            keyboardFlashCards.addEasy();\n        }\n    }\n    public int[] getTestStats() {\n        return keyboardFlashCards.getStats();\n    }\n    @Override\n    public ArrayList<Float> getPerformance() {\n        return performance;\n    }\n    @Override\n    public void updatePerformance(Model model) {\n        requireNonNull(model);\n        float numGood = model.getFilteredFlashCardListNoCommit(new RatingContainsKeywordPredicate(\"good\")).size();\n        float numHard = model.getFilteredFlashCardListNoCommit(new RatingContainsKeywordPredicate(\"hard\")).size();\n        float numEasy = model.getFilteredFlashCardListNoCommit(new RatingContainsKeywordPredicate(\"easy\")).size();\n        float value;\n        if ((numEasy + numGood + numHard) == 0) {\n            value = 0;\n        } else {\n            value = ((numEasy + numGood) * 100) / (numEasy + numGood + numHard);\n        }\n        performance.add(value);\n    }\n    @Override\n    public void resetPerformance(Model model) {\n        requireNonNull(model);\n        performance.clear();\n    }\n    @Override\n    public void deleteDeadline(Deadline target) {\n        keyboardFlashCards.removeDeadline(target);\n    }\n    @Override\n    public void setDeadline(Deadline target, Deadline editedDeadline) {\n        requireAllNonNull(target, editedDeadline);\n        keyboardFlashCards.setDeadline(target, editedDeadline);\n    }\n    //=========== Filtered FlashCard List Accessors =============================================================\n    /**\n     * Returns an unmodifiable view of the list of {@code FlashCard} backed by the internal list of\n     * {@code versionedAddressBook}\n     */\n    @Override\n    public ObservableList<FlashCard> getFilteredFlashCardList() {\n        return filteredFlashCards;\n    }\n    @Override\n    public void updateFilteredFlashCardList(Predicate<FlashCard> predicate) {\n        requireNonNull(predicate);\n        filteredFlashCards.setPredicate(predicate);\n    }\n    //=========== Filtered Deadline List Accessors =============================================================\n    /**\n     * Returns an unmodifiable view of the list of {@code Deadline} backed by the internal list of\n     * {@code versionedAddressBook}\n     */\n    @Override\n    public ObservableList<Deadline> getFilteredDeadlineList() {\n        return filteredDeadlines;\n    }\n    @Override\n    public void updateFilteredDeadlineList(Predicate<Deadline> predicate) {\n        requireNonNull(predicate);\n        filteredDeadlines.setPredicate(predicate);\n    }\n    //@@author keiteo\n    @Override\n    public ObservableList<FlashCard> getFlashCardList() {\n        return keyboardFlashCards.getFlashcardList();\n    }\n    //=========== FlashCardTestModel ================================================================================\n    @Override\n    public void initializeTestModel(List<FlashCard> testList) {\n        flashCardTestModel = new FlashCardTestModel(testList);\n    }\n    @Override\n    public boolean hasTestFlashCard() {\n        return !flashCardTestModel.isEmpty();\n    }\n    @Override\n    public void setTestFlashCard() {\n        flashCardTestModel.setFlashcard();\n    }\n    @Override\n    public String getTestQuestion() {\n        return flashCardTestModel.getQuestion();\n    }\n    @Override\n    public String getTestAnswer() {\n        return flashCardTestModel.getAnswer();\n    }\n    @Override\n    public FlashCard getCurrentTestFlashCard() {\n        return flashCardTestModel.getCurrentFlashCard();\n    }\n    //@@author shutingy\n    @Override\n    public TestFlashCardPanel getTestFlashCardPanel() {\n        return flashCardTestModel.getTestFlashCardPanel();\n    }\n    @Override\n    public void showAnswer() {\n        flashCardTestModel.showAnswer();\n    }\n    //@@author LeowWB\n    @Override\n    public ObservableList<FlashCard> getFilteredFlashCardListNoCommit(Predicate<FlashCard> predicate) {\n        requireNonNull(predicate);\n        FilteredList<FlashCard> simulatedList = new FilteredList<FlashCard>(filteredFlashCards);\n        simulatedList.setPredicate(predicate);\n        return simulatedList;\n    }\n    //@@author shutingy\n    @Override\n    public ObservableList<Category> getCategoryList() {\n        return categoryList;\n    }\n    //@@author shutingy\n    @Override\n    public void updateFilteredCategoryList(Predicate<Category> predicate) {\n        requireNonNull(predicate);\n        categoryList.setPredicate(predicate);\n    }\n    @Override\n    public boolean equals(Object obj) {\n        // short circuit if same object\n        if (obj == this) {\n            return true;\n        }\n        // instanceof handles nulls\n        if (!(obj instanceof ModelManager)) {\n            return false;\n        }\n        // state check\n        ModelManager other = (ModelManager) obj;\n        return keyboardFlashCards.equals(other.keyboardFlashCards)\n                && userPrefs.equals(other.userPrefs)\n                && filteredFlashCards.equals(other.filteredFlashCards)\n                && categoryList.equals(other.categoryList)\n                && filteredDeadlines.equals(other.filteredDeadlines)\n                && flashCardTestModel.equals(other.flashCardTestModel);\n    }\n"]]}
{"hexsha": "1da401e2657d0e2241f5d273e46bcfa6c48b49ff", "ext": "java", "lang": "Java", "content": "public class DatumUtilsTest {\n  @Test\n  public void testNewEmptySubDatum() {\n    Subscriber subscriber = new Subscriber();\n    subscriber.setDataId(\"subscriber-dataId\");\n    subscriber.setGroup(\"DEFAULT_GROUP\");\n    subscriber.setInstanceId(\"InstanceId\");\n    subscriber.setDataInfoId(\"dataInfoId\");\n    SubDatum subDatum =\n        DatumUtils.newEmptySubDatum(subscriber, \"testDc\", ValueConstants.DEFAULT_NO_DATUM_VERSION);\n    Assert.assertEquals(subDatum.getDataCenter(), \"testDc\");\n    Assert.assertEquals(subDatum.getDataInfoId(), subscriber.getDataInfoId());\n    Assert.assertEquals(subDatum.getDataId(), subscriber.getDataId());\n    Assert.assertEquals(subDatum.getInstanceId(), subscriber.getInstanceId());\n    Assert.assertEquals(subDatum.getGroup(), subscriber.getGroup());\n    Assert.assertEquals(subDatum.getVersion(), ValueConstants.DEFAULT_NO_DATUM_VERSION);\n    Assert.assertTrue(subDatum.mustGetPublishers().isEmpty());\n  }\n\n  @Test\n  public void testIntern() {\n    Map<String, DatumVersion> m = Collections.singletonMap(\"test\", DatumVersion.of(100));\n    Assert.assertEquals(DatumUtils.intern(m), m);\n  }\n\n  @Test\n  public void testDatum() {\n    Datum datum = new Datum();\n    Publisher publisher = new Publisher();\n    publisher.setRegisterId(\"testRegisterId\");\n    publisher.setCell(\"testCell\");\n    publisher.setDataList(Collections.emptyList());\n    publisher.setVersion(100);\n    publisher.setRegisterTimestamp(System.currentTimeMillis());\n    publisher.setPublishSource(PublishSource.CLIENT);\n    datum.addPublisher(publisher);\n    datum.setDataCenter(\"testDc\");\n    datum.setDataId(\"testDataId\");\n    datum.setVersion(200);\n    datum.setInstanceId(\"testInstanceId\");\n    datum.setGroup(\"testGroup\");\n    datum.setDataInfoId(\"testDataInfoId\");\n    SubDatum subDatum = DatumUtils.of(datum);\n\n    Assert.assertEquals(subDatum.getDataCenter(), datum.getDataCenter());\n    Assert.assertEquals(subDatum.getDataInfoId(), datum.getDataInfoId());\n    Assert.assertEquals(subDatum.getDataId(), datum.getDataId());\n    Assert.assertEquals(subDatum.getInstanceId(), datum.getInstanceId());\n    Assert.assertEquals(subDatum.getGroup(), datum.getGroup());\n    Assert.assertEquals(subDatum.getVersion(), datum.getVersion());\n\n    Publisher p = datum.getPubMap().get(publisher.getRegisterId());\n\n    Assert.assertEquals(p.getRegisterId(), publisher.getRegisterId());\n    Assert.assertEquals(p.getCell(), publisher.getCell());\n    Assert.assertEquals(p.getDataList(), publisher.getDataList());\n    Assert.assertEquals(p.getVersion(), publisher.getVersion());\n    Assert.assertEquals(p.getRegisterTimestamp(), publisher.getRegisterTimestamp());\n    Assert.assertEquals(p.getPublishSource(), publisher.getPublishSource());\n  }\n\n  @Test\n  public void testDataBoxListSize() {\n    DataBox box = new DataBox();\n    box.setData(\"111111111111111111111111111111111\");\n    Assert.assertEquals(33, DatumUtils.DataBoxListSize(Lists.newArrayList(box)));\n    Assert.assertEquals(0, DatumUtils.DataBoxListSize(null));\n  }\n\n  @Test\n  public void testServerDataBoxListSize() {\n    ServerDataBox box = new ServerDataBox(\"111111111111111111111111111111111\");\n    Assert.assertEquals(40, DatumUtils.ServerDataBoxListSize(Lists.newArrayList(box)));\n    Assert.assertEquals(0, DatumUtils.ServerDataBoxListSize(null));\n  }\n\n  @Test\n  public void testCompress() {\n    Datum datum = new Datum();\n    Publisher publisher = new Publisher();\n    publisher.setRegisterId(\"testRegisterId\");\n    publisher.setCell(\"testCell\");\n    publisher.setDataList(Collections.emptyList());\n    publisher.setVersion(100);\n    publisher.setRegisterTimestamp(System.currentTimeMillis());\n    publisher.setPublishSource(PublishSource.CLIENT);\n    datum.addPublisher(publisher);\n    datum.setDataCenter(\"testDc\");\n    datum.setDataId(\"testDataId\");\n    datum.setVersion(200);\n    datum.setInstanceId(\"testInstanceId\");\n    datum.setGroup(\"testGroup\");\n    datum.setDataInfoId(\"testDataInfoId\");\n    SubDatum subDatum = DatumUtils.of(datum);\n\n    SubDatum zip = DatumUtils.compressSubDatum(subDatum, CompressUtils.mustGet(\"zstd\"));\n    SubDatum unzip = DatumUtils.decompressSubDatum(zip);\n    Assert.assertEquals(1, zip.getPubNum());\n    Assert.assertEquals(1, unzip.getPubNum());\n    Assert.assertEquals(\"testRegisterId\", unzip.mustGetPublishers().get(0).getRegisterId());\n  }\n}", "class_id": 0, "repo": "stulzq/sofa-registry", "file": "server/server/shared/src/test/java/com/alipay/sofa/registry/server/shared/util/DatumUtilsTest.java", "last_update_at": "2019-05-12T10:50:04+00:00", "question_id": "1da401e2657d0e2241f5d273e46bcfa6c48b49ff", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DatumUtilsTest {\n  @Test\n  public void testNewEmptySubDatum() {\n    Subscriber subscriber = new Subscriber();\n    subscriber.setDataId(\"subscriber-dataId\");\n    subscriber.setGroup(\"DEFAULT_GROUP\");\n    subscriber.setInstanceId(\"InstanceId\");\n    subscriber.setDataInfoId(\"dataInfoId\");\n    SubDatum subDatum =\n        DatumUtils.newEmptySubDatum(subscriber, \"testDc\", ValueConstants.DEFAULT_NO_DATUM_VERSION);\n    Assert.assertEquals(subDatum.getDataCenter(), \"testDc\");\n    Assert.assertEquals(subDatum.getDataInfoId(), subscriber.getDataInfoId());\n    Assert.assertEquals(subDatum.getDataId(), subscriber.getDataId());\n    Assert.assertEquals(subDatum.getInstanceId(), subscriber.getInstanceId());\n    Assert.assertEquals(subDatum.getGroup(), subscriber.getGroup());\n    Assert.assertEquals(subDatum.getVersion(), ValueConstants.DEFAULT_NO_DATUM_VERSION);\n    Assert.assertTrue(subDatum.mustGetPublishers().isEmpty());\n  }\n  @Test\n  public void testIntern() {\n    Map<String, DatumVersion> m = Collections.singletonMap(\"test\", DatumVersion.of(100));\n    Assert.assertEquals(DatumUtils.intern(m), m);\n  }\n  @Test\n  public void testDatum() {\n    Datum datum = new Datum();\n    Publisher publisher = new Publisher();\n    publisher.setRegisterId(\"testRegisterId\");\n    publisher.setCell(\"testCell\");\n    publisher.setDataList(Collections.emptyList());\n    publisher.setVersion(100);\n    publisher.setRegisterTimestamp(System.currentTimeMillis());\n    publisher.setPublishSource(PublishSource.CLIENT);\n    datum.addPublisher(publisher);\n    datum.setDataCenter(\"testDc\");\n    datum.setDataId(\"testDataId\");\n    datum.setVersion(200);\n    datum.setInstanceId(\"testInstanceId\");\n    datum.setGroup(\"testGroup\");\n    datum.setDataInfoId(\"testDataInfoId\");\n    SubDatum subDatum = DatumUtils.of(datum);\n    Assert.assertEquals(subDatum.getDataCenter(), datum.getDataCenter());\n    Assert.assertEquals(subDatum.getDataInfoId(), datum.getDataInfoId());\n    Assert.assertEquals(subDatum.getDataId(), datum.getDataId());\n    Assert.assertEquals(subDatum.getInstanceId(), datum.getInstanceId());\n    Assert.assertEquals(subDatum.getGroup(), datum.getGroup());\n    Assert.assertEquals(subDatum.getVersion(), datum.getVersion());\n    Publisher p = datum.getPubMap().get(publisher.getRegisterId());\n    Assert.assertEquals(p.getRegisterId(), publisher.getRegisterId());\n    Assert.assertEquals(p.getCell(), publisher.getCell());\n    Assert.assertEquals(p.getDataList(), publisher.getDataList());\n    Assert.assertEquals(p.getVersion(), publisher.getVersion());\n    Assert.assertEquals(p.getRegisterTimestamp(), publisher.getRegisterTimestamp());\n    Assert.assertEquals(p.getPublishSource(), publisher.getPublishSource());\n  }\n  @Test\n  public void testDataBoxListSize() {\n    DataBox box = new DataBox();\n    box.setData(\"111111111111111111111111111111111\");\n    Assert.assertEquals(33, DatumUtils.DataBoxListSize(Lists.newArrayList(box)));\n    Assert.assertEquals(0, DatumUtils.DataBoxListSize(null));\n  }\n  @Test\n  public void testServerDataBoxListSize() {\n    ServerDataBox box = new ServerDataBox(\"111111111111111111111111111111111\");\n    Assert.assertEquals(40, DatumUtils.ServerDataBoxListSize(Lists.newArrayList(box)));\n    Assert.assertEquals(0, DatumUtils.ServerDataBoxListSize(null));\n  }\n  @Test\n  public void testCompress() {\n    Datum datum = new Datum();\n    Publisher publisher = new Publisher();\n    publisher.setRegisterId(\"testRegisterId\");\n    publisher.setCell(\"testCell\");\n    publisher.setDataList(Collections.emptyList());\n    publisher.setVersion(100);\n    publisher.setRegisterTimestamp(System.currentTimeMillis());\n    publisher.setPublishSource(PublishSource.CLIENT);\n    datum.addPublisher(publisher);\n    datum.setDataCenter(\"testDc\");\n    datum.setDataId(\"testDataId\");\n    datum.setVersion(200);\n    datum.setInstanceId(\"testInstanceId\");\n    datum.setGroup(\"testGroup\");\n    datum.setDataInfoId(\"testDataInfoId\");\n    SubDatum subDatum = DatumUtils.of(datum);\n    SubDatum zip = DatumUtils.compressSubDatum(subDatum, CompressUtils.mustGet(\"zstd\"));\n    SubDatum unzip = DatumUtils.decompressSubDatum(zip);\n    Assert.assertEquals(1, zip.getPubNum());\n    Assert.assertEquals(1, unzip.getPubNum());\n    Assert.assertEquals(\"testRegisterId\", unzip.mustGetPublishers().get(0).getRegisterId());\n  }\n"]]}
{"hexsha": "3dd92e6e3dd8d7926cc6b0042590a8765c7942e1", "ext": "java", "lang": "Java", "content": "public class MemcachedNodesManagerTest {\n\n\tprivate MemcachedClientCallback _mcc;\n\n\t@BeforeMethod\n\tpublic void beforeClass() {\n\t\t_mcc = mock(MemcachedClientCallback.class);\n\t}\n\n\t@Test(expectedExceptions = IllegalArgumentException.class)\n\tpublic void testParseWithNullShouldThrowException() {\n\t\tcreateFor(null, null, null, _mcc);\n\t}\n\n\t@Test(expectedExceptions = IllegalArgumentException.class)\n\tpublic void testParseWithEmptyStringShouldThrowException() {\n\t\tcreateFor(\"\", null, null, _mcc);\n\t}\n\n\t@Test(expectedExceptions = IllegalArgumentException.class)\n\tpublic void testSingleSimpleNodeAndFailoverNodeShouldThrowException() {\n\t\tcreateFor(\"localhost:11211\", \"n1\", null, _mcc);\n\t}\n\n\t@Test(expectedExceptions = IllegalArgumentException.class)\n\tpublic void testSingleNodeAndFailoverNodeShouldThrowException() {\n\t\tcreateFor(\"n1:localhost:11211\", \"n1\", null, _mcc);\n\t}\n\n    @Test(expectedExceptions = IllegalArgumentException.class)\n    public void testCouchbaseNodesAndFailoverNodeShouldThrowException() {\n        createFor(\"http://localhost:8091/pools\", \"n1\", null, _mcc);\n    }\n\n\t@DataProvider\n\tpublic static Object[][] nodesAndExpectedCountDataProvider() {\n\t\treturn new Object[][] {\n\t\t\t\t{ \"localhost:11211\", 1 },\n                { \"http://localhost:8091/pools\", 1},\n                { \"http://10.10.0.1:8091/pools,http://10.10.0.2:8091/pools\", 2},\n                { \"n1:localhost:11211\", 1 },\n\t\t\t\t{ \"n1:localhost:11211,n2:localhost:11212\", 2 },\n\t\t\t\t{ \"n1:localhost:11211 n2:localhost:11212\", 2 }\n\t\t};\n\t}\n\n\t@Test( dataProvider = \"nodesAndExpectedCountDataProvider\" )\n\tpublic void testCountNodes( final String memcachedNodes, final int expectedCount ) {\n\t\tfinal MemcachedNodesManager result = createFor( memcachedNodes, null, null, _mcc );\n\t\tassertNotNull(result);\n\t\tassertEquals(result.getCountNodes(),  expectedCount);\n\t}\n\n\t@DataProvider\n\tpublic static Object[][] nodesAndPrimaryNodesDataProvider() {\n\t\treturn new Object[][] {\n\t\t\t\t{ \"localhost:11211\", null, new NodeIdList() },\n                { \"http://localhost:8091/pools\", null, new NodeIdList() },\n                { \"http://10.10.0.1:8091/pools,http://10.10.0.2:8091/pools\", null, new NodeIdList() },\n\t\t\t\t{ \"n1:localhost:11211\", null, new NodeIdList(\"n1\") },\n\t\t\t\t{ \"n1:localhost:11211,n2:localhost:11212\", \"n1\", new NodeIdList(\"n2\") },\n\t\t\t\t{ \"n1:localhost:11211,n2:localhost:11212,n3:localhost:11213\", \"n1\", new NodeIdList(\"n2\", \"n3\") },\n\t\t\t\t{ \"n1:localhost:11211,n2:localhost:11212,n3:localhost:11213\", \"n1,n2\", new NodeIdList(\"n3\") }\n\t\t};\n\t}\n\n\t@Test( dataProvider = \"nodesAndPrimaryNodesDataProvider\" )\n\tpublic void testPrimaryNodes(final String memcachedNodes, final String failoverNodes, final NodeIdList expectedPrimaryNodeIds) {\n\t\tfinal MemcachedNodesManager result = createFor( memcachedNodes, failoverNodes, null, _mcc );\n\t\tassertNotNull(result);\n\t\tassertEquals(result.getPrimaryNodeIds(), expectedPrimaryNodeIds);\n\t}\n\n\t@DataProvider\n\tpublic static Object[][] nodesAndFailoverNodesDataProvider() {\n\t\treturn new Object[][] {\n\t\t\t\t{ \"localhost:11211\", null, Collections.emptyList() },\n\t\t\t\t{ \"localhost:11211\", \"\", Collections.emptyList() },\n                { \"http://localhost:8091/pools\", null, Collections.emptyList() },\n\t\t\t\t{ \"n1:localhost:11211\", null, Collections.emptyList() },\n\t\t\t\t{ \"n1:localhost:11211,n2:localhost:11212\", \"n1\", Arrays.asList(\"n1\") },\n\t\t\t\t{ \"n1:localhost:11211,n2:localhost:11212,n3:localhost:11213\", \"n1,n2\", Arrays.asList(\"n1\", \"n2\") },\n\t\t\t\t{ \"n1:localhost:11211,n2:localhost:11212,n3:localhost:11213\", \"n1 n2\", Arrays.asList(\"n1\", \"n2\") }\n\t\t};\n\t}\n\n\t@Test( dataProvider = \"nodesAndFailoverNodesDataProvider\" )\n\tpublic void testFailoverNodes(final String memcachedNodes, final String failoverNodes, final List<String> expectedFailoverNodeIds) {\n\t\tfinal MemcachedNodesManager result = createFor( memcachedNodes, failoverNodes, null, _mcc );\n\t\tassertNotNull(result);\n\t\tassertEquals(result.getFailoverNodeIds(), expectedFailoverNodeIds);\n\t}\n\n\t@DataProvider\n\tpublic static Object[][] nodesAndExpectedEncodedInSessionIdDataProvider() {\n\t\treturn new Object[][] {\n\t\t\t\t{ \"localhost:11211\", null, false },\n                { \"http://localhost:8091/pools\", null, false },\n                { \"http://10.10.0.1:8091/pools,http://10.10.0.2:8091/pools\", null, false },\n\t\t\t\t{ \"n1:localhost:11211\", null, true },\n\t\t\t\t{ \"n1:localhost:11211,n2:localhost:11212\", \"n1\", true }\n\t\t};\n\t}\n\n\t@Test( dataProvider = \"nodesAndExpectedEncodedInSessionIdDataProvider\" )\n\tpublic void testIsEncodeNodeIdInSessionId( final String memcachedNodes, final String failoverNodes, final boolean expectedIsEncodeNodeIdInSessionId ) {\n\t\tfinal MemcachedNodesManager result = createFor( memcachedNodes, null, null, _mcc );\n\t\tassertNotNull(result);\n\t\tassertEquals(result.isEncodeNodeIdInSessionId(), expectedIsEncodeNodeIdInSessionId);\n\t}\n\n\t@Test(expectedExceptions = IllegalArgumentException.class)\n\tpublic void testGetNodeIdShouldThrowExceptionForNullArgument() {\n\t\tfinal MemcachedNodesManager result = createFor( \"n1:localhost:11211\", null, null, _mcc );\n\t\tresult.getNodeId(null);\n\t}\n\n\t@DataProvider\n\tpublic static Object[][] testGetNodeIdDataProvider() {\n\t\treturn new Object[][] {\n\t\t\t\t{ \"n1:localhost:11211\", null, new InetSocketAddress(\"localhost\", 11211), \"n1\" },\n\t\t\t\t{ \"n1:localhost:11211,n2:localhost:11212\", null, new InetSocketAddress(\"localhost\", 11212), \"n2\" },\n\t\t\t\t{ \"n1:localhost:11211,n2:localhost:11212\", \"n1\", new InetSocketAddress(\"localhost\", 11211), \"n1\" }\n\t\t};\n\t}\n\n\t@Test( dataProvider = \"testGetNodeIdDataProvider\" )\n\tpublic void testGetNodeId(final String memcachedNodes, final String failoverNodes, final InetSocketAddress socketAddress, final String expectedNodeId) {\n\t\tfinal MemcachedNodesManager result = createFor( memcachedNodes, failoverNodes, null, _mcc );\n\t\tassertEquals(result.getNodeId(socketAddress), expectedNodeId);\n\t}\n\n\t/**\n\t * Test for {@link MemcachedNodesManager#getNextPrimaryNodeId(String)}.\n\t * @see NodeIdList#getNextNodeId(String)\n\t * @see NodeIdListTest#testGetNextNodeId()\n\t */\n\t@Test\n\tpublic void testGetNextPrimaryNodeId() {\n\t\tassertNull(createFor( \"n1:localhost:11211\", null, null, _mcc ).getNextPrimaryNodeId(\"n1\"));\n\t\tassertEquals(createFor( \"n1:localhost:11211,n2:localhost:11212\", null, null, _mcc ).getNextPrimaryNodeId(\"n1\"), \"n2\");\n\t}\n\n    @Test\n    public void testGetNextAvailableNodeId() {\n        assertNull(createFor( \"n1:localhost:11211\", null, null, _mcc ).getNextAvailableNodeId(\"n1\"));\n        assertEquals(createFor( \"n1:localhost:11211,n2:localhost:11212\", null, null, _mcc ).getNextAvailableNodeId(\"n1\"), \"n2\");\n\n        final MemcachedClientCallback mcc = mock(MemcachedClientCallback.class);\n        when(mcc.get(anyString())).thenReturn(null);\n        when(mcc.get(endsWith(\"n2\"))).thenThrow(new OperationTimeoutException(\"SimulatedException\"));\n        assertNull(createFor( \"n1:localhost:11211,n2:localhost:11212\", null, null, mcc).getNextAvailableNodeId(\"n1\"));\n\n        assertEquals(createFor( \"n1:localhost:11211,n2:localhost:11212,n3:localhost:11213\", null, null, mcc).getNextAvailableNodeId(\"n1\"), \"n3\");\n    }\n\n\t@DataProvider\n\tpublic static Object[][] testgGetAllMemcachedAddressesDataProvider() {\n\t\treturn new Object[][] {\n\t\t\t\t{ \"localhost:11211\", null, asList(new InetSocketAddress(\"localhost\", 11211)) },\n\t\t\t\t{ \"http://localhost:8091/pools\", null, asList(new InetSocketAddress(\"localhost\", 8091)) },\n                { \"http://10.10.0.1:8091/pools,http://10.10.0.2:8091/pools\", null,\n\t\t\t\t    asList(new InetSocketAddress(\"10.10.0.1\", 8091), new InetSocketAddress(\"10.10.0.2\", 8091)) },\n\t\t\t\t{ \"n1:localhost:11211\", null, asList(new InetSocketAddress(\"localhost\", 11211)) },\n\t\t\t\t{ \"n1:localhost:11211,n2:localhost:11212\", null, asList(new InetSocketAddress(\"localhost\", 11211), new InetSocketAddress(\"localhost\", 11212)) },\n\t\t\t\t{ \"n1:localhost:11211,n2:localhost:11212\", \"n1\", asList(new InetSocketAddress(\"localhost\", 11211), new InetSocketAddress(\"localhost\", 11212)) }\n\t\t};\n\t}\n\n\t@Test( dataProvider = \"testgGetAllMemcachedAddressesDataProvider\" )\n\tpublic void testGetAllMemcachedAddresses(final String memcachedNodes, final String failoverNodes, final Collection<InetSocketAddress> expectedSocketAddresses) {\n\t\tfinal MemcachedNodesManager result = createFor( memcachedNodes, failoverNodes, null, _mcc );\n\t\tassertEquals(result.getAllMemcachedAddresses(), expectedSocketAddresses);\n\t}\n\n\t@Test\n\tpublic void testGetSessionIdFormat() {\n\t\tfinal SessionIdFormat sessionIdFormat = createFor( \"n1:localhost:11211\", null, null, _mcc ).getSessionIdFormat();\n\t\tassertNotNull(sessionIdFormat);\n\t}\n\n    @Test\n    public void testSessionIdFormatForSingleNodeSetupShouldSupportLocking() {\n        final SessionIdFormat sessionIdFormat = createFor( \"localhost:11211\", null, StorageKeyFormat.EMPTY, _mcc ).getSessionIdFormat();\n        assertNotNull(sessionIdFormat);\n        final String sessionId = \"12345678\";\n        assertEquals(sessionIdFormat.createLockName(sessionId), \"lock:\" + sessionId);\n    }\n\n\t@Test\n\tpublic void testCreateSessionIdShouldOnlyAddNodeIdIfPresent() {\n\t\tassertEquals(createFor( \"n1:localhost:11211\", null, null, _mcc ).createSessionId(\"foo\"), \"foo-n1\" );\n\t\tassertEquals(createFor( \"localhost:11211\", null, null, _mcc ).createSessionId(\"foo\"), \"foo\" );\n\t}\n\n\t@Test\n\tpublic void testSetNodeAvailable() {\n\t\tfinal MemcachedNodesManager cut = createFor( \"n1:localhost:11211,n2:localhost:11212\", null, null, _mcc );\n\t\tassertTrue(cut.isNodeAvailable(\"n1\"));\n\t\tassertTrue(cut.isNodeAvailable(\"n2\"));\n\n\t\tcut.setNodeAvailable(\"n1\", false);\n\n\t\tassertFalse(cut.isNodeAvailable(\"n1\"));\n\t\tassertTrue(cut.isNodeAvailable(\"n2\"));\n\t}\n\n    @Test\n    public void testIsCouchbaseBucketConfig() {\n        assertTrue(createFor(\"http://10.10.0.1:8091/pools\", null, null, _mcc ).isCouchbaseBucketConfig());\n        assertTrue(createFor(\"http://10.10.0.1:8091/pools,http://10.10.0.2:8091/pools\", null, null, _mcc ).isCouchbaseBucketConfig());\n    }\n\n    @Test\n    public void testGetCouchbaseBucketURIs() throws URISyntaxException {\n        assertEquals(createFor(\"http://10.10.0.1:8091/pools\", null, null, _mcc ).getCouchbaseBucketURIs(),\n                Arrays.asList(new URI(\"http://10.10.0.1:8091/pools\")));\n        assertEquals(createFor(\"http://10.10.0.1:8091/pools,http://10.10.0.2:8091/pools\", null, null, _mcc ).getCouchbaseBucketURIs(),\n                Arrays.asList(new URI(\"http://10.10.0.1:8091/pools\"), new URI(\"http://10.10.0.2:8091/pools\")));\n    }\n\n    @Test\n    public void testChangeSessionIdForTomcatFailover() {\n        assertEquals(createFor(\"localhost:11211\", null, null, _mcc)\n                .changeSessionIdForTomcatFailover(sessionId(\"123\", null, null), null), sessionId(\"123\", null, null));\n        assertEquals(createFor(\"localhost:11211\", null, null, _mcc)\n                .changeSessionIdForTomcatFailover(sessionId(\"123\", null, \"tc1\"), \"tc2\"), sessionId(\"123\", null, \"tc2\"));\n\n        assertEquals(createFor(\"n1:localhost:11211,n2:localhost:11212\", null, null, _mcc)\n                .changeSessionIdForTomcatFailover(sessionId(\"123\", \"n1\", null), null), sessionId(\"123\", \"n1\", null));\n        assertEquals(createFor(\"n1:localhost:11211,n2:localhost:11212\", null, null, _mcc)\n                .changeSessionIdForTomcatFailover(sessionId(\"123\", \"n1\", null), \"tc2\"), sessionId(\"123\", \"n1\", \"tc2\"));\n        assertEquals(createFor(\"n1:localhost:11211,n2:localhost:11212\", null, null, _mcc)\n                .changeSessionIdForTomcatFailover(sessionId(\"123\", \"n1\", \"tc1\"), \"tc2\"), sessionId(\"123\", \"n1\", \"tc2\"));\n\n        assertEquals(createFor(\"n1:localhost:11211,n2:localhost:11212\", \"n2\", null, _mcc)\n                .changeSessionIdForTomcatFailover(sessionId(\"123\", \"n1\", null), null), sessionId(\"123\", \"n1\", null));\n        assertEquals(createFor(\"n1:localhost:11211,n2:localhost:11212\", \"n2\", null, _mcc)\n                .changeSessionIdForTomcatFailover(sessionId(\"123\", \"n1\", null), \"tc2\"), sessionId(\"123\", \"n1\", \"tc2\"));\n        assertEquals(createFor(\"n1:localhost:11211,n2:localhost:11212\", \"n2\", null, _mcc)\n                .changeSessionIdForTomcatFailover(sessionId(\"123\", \"n1\", \"tc1\"), \"tc2\"), sessionId(\"123\", \"n1\", \"tc2\"));\n\n        assertEquals(createFor(\"n1:localhost:11211,n2:localhost:11212\", \"n1\", null, _mcc)\n                .changeSessionIdForTomcatFailover(sessionId(\"123\", \"n1\", null), null), sessionId(\"123\", \"n2\", null));\n        assertEquals(createFor(\"n1:localhost:11211,n2:localhost:11212\", \"n1\", null, _mcc)\n                .changeSessionIdForTomcatFailover(sessionId(\"123\", \"n1\", null), \"tc2\"), sessionId(\"123\", \"n2\", \"tc2\"));\n        assertEquals(createFor(\"n1:localhost:11211,n2:localhost:11212\", \"n1\", null, _mcc)\n                .changeSessionIdForTomcatFailover(sessionId(\"123\", \"n1\", \"tc1\"), \"tc2\"), sessionId(\"123\", \"n2\", \"tc2\"));\n\n    }\n\n    private static String sessionId(final String plainId, final String memcachedId, final String jvmRoute) {\n        final SessionIdFormat sessionIdFormat = new SessionIdFormat();\n        final String withMemcachedId = sessionIdFormat.createSessionId(plainId, memcachedId);\n        return jvmRoute != null ? sessionIdFormat.changeJvmRoute(withMemcachedId, jvmRoute) : withMemcachedId;\n    }\n\n}", "class_id": 0, "repo": "xloye/memcached-session-manager", "file": "core/src/test/java/de/javakaffee/web/msm/MemcachedNodesManagerTest.java", "last_update_at": "2019-02-14T04:14:02+00:00", "question_id": "3dd92e6e3dd8d7926cc6b0042590a8765c7942e1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MemcachedNodesManagerTest {\n\tprivate MemcachedClientCallback _mcc;\n\t@BeforeMethod\n\tpublic void beforeClass() {\n\t\t_mcc = mock(MemcachedClientCallback.class);\n\t}\n\t@Test(expectedExceptions = IllegalArgumentException.class)\n\tpublic void testParseWithNullShouldThrowException() {\n\t\tcreateFor(null, null, null, _mcc);\n\t}\n\t@Test(expectedExceptions = IllegalArgumentException.class)\n\tpublic void testParseWithEmptyStringShouldThrowException() {\n\t\tcreateFor(\"\", null, null, _mcc);\n\t}\n\t@Test(expectedExceptions = IllegalArgumentException.class)\n\tpublic void testSingleSimpleNodeAndFailoverNodeShouldThrowException() {\n\t\tcreateFor(\"localhost:11211\", \"n1\", null, _mcc);\n\t}\n\t@Test(expectedExceptions = IllegalArgumentException.class)\n\tpublic void testSingleNodeAndFailoverNodeShouldThrowException() {\n\t\tcreateFor(\"n1:localhost:11211\", \"n1\", null, _mcc);\n\t}\n    @Test(expectedExceptions = IllegalArgumentException.class)\n    public void testCouchbaseNodesAndFailoverNodeShouldThrowException() {\n        createFor(\"http://localhost:8091/pools\", \"n1\", null, _mcc);\n    }\n\t@DataProvider\n\tpublic static Object[][] nodesAndExpectedCountDataProvider() {\n\t\treturn new Object[][] {\n\t\t\t\t{ \"localhost:11211\", 1 },\n                { \"http://localhost:8091/pools\", 1},\n                { \"http://10.10.0.1:8091/pools,http://10.10.0.2:8091/pools\", 2},\n                { \"n1:localhost:11211\", 1 },\n\t\t\t\t{ \"n1:localhost:11211,n2:localhost:11212\", 2 },\n\t\t\t\t{ \"n1:localhost:11211 n2:localhost:11212\", 2 }\n\t\t};\n\t}\n\t@Test( dataProvider = \"nodesAndExpectedCountDataProvider\" )\n\tpublic void testCountNodes( final String memcachedNodes, final int expectedCount ) {\n\t\tfinal MemcachedNodesManager result = createFor( memcachedNodes, null, null, _mcc );\n\t\tassertNotNull(result);\n\t\tassertEquals(result.getCountNodes(),  expectedCount);\n\t}\n\t@DataProvider\n\tpublic static Object[][] nodesAndPrimaryNodesDataProvider() {\n\t\treturn new Object[][] {\n\t\t\t\t{ \"localhost:11211\", null, new NodeIdList() },\n                { \"http://localhost:8091/pools\", null, new NodeIdList() },\n                { \"http://10.10.0.1:8091/pools,http://10.10.0.2:8091/pools\", null, new NodeIdList() },\n\t\t\t\t{ \"n1:localhost:11211\", null, new NodeIdList(\"n1\") },\n\t\t\t\t{ \"n1:localhost:11211,n2:localhost:11212\", \"n1\", new NodeIdList(\"n2\") },\n\t\t\t\t{ \"n1:localhost:11211,n2:localhost:11212,n3:localhost:11213\", \"n1\", new NodeIdList(\"n2\", \"n3\") },\n\t\t\t\t{ \"n1:localhost:11211,n2:localhost:11212,n3:localhost:11213\", \"n1,n2\", new NodeIdList(\"n3\") }\n\t\t};\n\t}\n\t@Test( dataProvider = \"nodesAndPrimaryNodesDataProvider\" )\n\tpublic void testPrimaryNodes(final String memcachedNodes, final String failoverNodes, final NodeIdList expectedPrimaryNodeIds) {\n\t\tfinal MemcachedNodesManager result = createFor( memcachedNodes, failoverNodes, null, _mcc );\n\t\tassertNotNull(result);\n\t\tassertEquals(result.getPrimaryNodeIds(), expectedPrimaryNodeIds);\n\t}\n\t@DataProvider\n\tpublic static Object[][] nodesAndFailoverNodesDataProvider() {\n\t\treturn new Object[][] {\n\t\t\t\t{ \"localhost:11211\", null, Collections.emptyList() },\n\t\t\t\t{ \"localhost:11211\", \"\", Collections.emptyList() },\n                { \"http://localhost:8091/pools\", null, Collections.emptyList() },\n\t\t\t\t{ \"n1:localhost:11211\", null, Collections.emptyList() },\n\t\t\t\t{ \"n1:localhost:11211,n2:localhost:11212\", \"n1\", Arrays.asList(\"n1\") },\n\t\t\t\t{ \"n1:localhost:11211,n2:localhost:11212,n3:localhost:11213\", \"n1,n2\", Arrays.asList(\"n1\", \"n2\") },\n\t\t\t\t{ \"n1:localhost:11211,n2:localhost:11212,n3:localhost:11213\", \"n1 n2\", Arrays.asList(\"n1\", \"n2\") }\n\t\t};\n\t}\n\t@Test( dataProvider = \"nodesAndFailoverNodesDataProvider\" )\n\tpublic void testFailoverNodes(final String memcachedNodes, final String failoverNodes, final List<String> expectedFailoverNodeIds) {\n\t\tfinal MemcachedNodesManager result = createFor( memcachedNodes, failoverNodes, null, _mcc );\n\t\tassertNotNull(result);\n\t\tassertEquals(result.getFailoverNodeIds(), expectedFailoverNodeIds);\n\t}\n\t@DataProvider\n\tpublic static Object[][] nodesAndExpectedEncodedInSessionIdDataProvider() {\n\t\treturn new Object[][] {\n\t\t\t\t{ \"localhost:11211\", null, false },\n                { \"http://localhost:8091/pools\", null, false },\n                { \"http://10.10.0.1:8091/pools,http://10.10.0.2:8091/pools\", null, false },\n\t\t\t\t{ \"n1:localhost:11211\", null, true },\n\t\t\t\t{ \"n1:localhost:11211,n2:localhost:11212\", \"n1\", true }\n\t\t};\n\t}\n\t@Test( dataProvider = \"nodesAndExpectedEncodedInSessionIdDataProvider\" )\n\tpublic void testIsEncodeNodeIdInSessionId( final String memcachedNodes, final String failoverNodes, final boolean expectedIsEncodeNodeIdInSessionId ) {\n\t\tfinal MemcachedNodesManager result = createFor( memcachedNodes, null, null, _mcc );\n\t\tassertNotNull(result);\n\t\tassertEquals(result.isEncodeNodeIdInSessionId(), expectedIsEncodeNodeIdInSessionId);\n\t}\n\t@Test(expectedExceptions = IllegalArgumentException.class)\n\tpublic void testGetNodeIdShouldThrowExceptionForNullArgument() {\n\t\tfinal MemcachedNodesManager result = createFor( \"n1:localhost:11211\", null, null, _mcc );\n\t\tresult.getNodeId(null);\n\t}\n\t@DataProvider\n\tpublic static Object[][] testGetNodeIdDataProvider() {\n\t\treturn new Object[][] {\n\t\t\t\t{ \"n1:localhost:11211\", null, new InetSocketAddress(\"localhost\", 11211), \"n1\" },\n\t\t\t\t{ \"n1:localhost:11211,n2:localhost:11212\", null, new InetSocketAddress(\"localhost\", 11212), \"n2\" },\n\t\t\t\t{ \"n1:localhost:11211,n2:localhost:11212\", \"n1\", new InetSocketAddress(\"localhost\", 11211), \"n1\" }\n\t\t};\n\t}\n\t@Test( dataProvider = \"testGetNodeIdDataProvider\" )\n\tpublic void testGetNodeId(final String memcachedNodes, final String failoverNodes, final InetSocketAddress socketAddress, final String expectedNodeId) {\n\t\tfinal MemcachedNodesManager result = createFor( memcachedNodes, failoverNodes, null, _mcc );\n\t\tassertEquals(result.getNodeId(socketAddress), expectedNodeId);\n\t}\n\t/**\n\t * Test for {@link MemcachedNodesManager#getNextPrimaryNodeId(String)}.\n\t * @see NodeIdList#getNextNodeId(String)\n\t * @see NodeIdListTest#testGetNextNodeId()\n\t */\n\t@Test\n\tpublic void testGetNextPrimaryNodeId() {\n\t\tassertNull(createFor( \"n1:localhost:11211\", null, null, _mcc ).getNextPrimaryNodeId(\"n1\"));\n\t\tassertEquals(createFor( \"n1:localhost:11211,n2:localhost:11212\", null, null, _mcc ).getNextPrimaryNodeId(\"n1\"), \"n2\");\n\t}\n    @Test\n    public void testGetNextAvailableNodeId() {\n        assertNull(createFor( \"n1:localhost:11211\", null, null, _mcc ).getNextAvailableNodeId(\"n1\"));\n        assertEquals(createFor( \"n1:localhost:11211,n2:localhost:11212\", null, null, _mcc ).getNextAvailableNodeId(\"n1\"), \"n2\");\n        final MemcachedClientCallback mcc = mock(MemcachedClientCallback.class);\n        when(mcc.get(anyString())).thenReturn(null);\n        when(mcc.get(endsWith(\"n2\"))).thenThrow(new OperationTimeoutException(\"SimulatedException\"));\n        assertNull(createFor( \"n1:localhost:11211,n2:localhost:11212\", null, null, mcc).getNextAvailableNodeId(\"n1\"));\n        assertEquals(createFor( \"n1:localhost:11211,n2:localhost:11212,n3:localhost:11213\", null, null, mcc).getNextAvailableNodeId(\"n1\"), \"n3\");\n    }\n\t@DataProvider\n\tpublic static Object[][] testgGetAllMemcachedAddressesDataProvider() {\n\t\treturn new Object[][] {\n\t\t\t\t{ \"localhost:11211\", null, asList(new InetSocketAddress(\"localhost\", 11211)) },\n\t\t\t\t{ \"http://localhost:8091/pools\", null, asList(new InetSocketAddress(\"localhost\", 8091)) },\n                { \"http://10.10.0.1:8091/pools,http://10.10.0.2:8091/pools\", null,\n\t\t\t\t    asList(new InetSocketAddress(\"10.10.0.1\", 8091), new InetSocketAddress(\"10.10.0.2\", 8091)) },\n\t\t\t\t{ \"n1:localhost:11211\", null, asList(new InetSocketAddress(\"localhost\", 11211)) },\n\t\t\t\t{ \"n1:localhost:11211,n2:localhost:11212\", null, asList(new InetSocketAddress(\"localhost\", 11211), new InetSocketAddress(\"localhost\", 11212)) },\n\t\t\t\t{ \"n1:localhost:11211,n2:localhost:11212\", \"n1\", asList(new InetSocketAddress(\"localhost\", 11211), new InetSocketAddress(\"localhost\", 11212)) }\n\t\t};\n\t}\n\t@Test( dataProvider = \"testgGetAllMemcachedAddressesDataProvider\" )\n\tpublic void testGetAllMemcachedAddresses(final String memcachedNodes, final String failoverNodes, final Collection<InetSocketAddress> expectedSocketAddresses) {\n\t\tfinal MemcachedNodesManager result = createFor( memcachedNodes, failoverNodes, null, _mcc );\n\t\tassertEquals(result.getAllMemcachedAddresses(), expectedSocketAddresses);\n\t}\n\t@Test\n\tpublic void testGetSessionIdFormat() {\n\t\tfinal SessionIdFormat sessionIdFormat = createFor( \"n1:localhost:11211\", null, null, _mcc ).getSessionIdFormat();\n\t\tassertNotNull(sessionIdFormat);\n\t}\n    @Test\n    public void testSessionIdFormatForSingleNodeSetupShouldSupportLocking() {\n        final SessionIdFormat sessionIdFormat = createFor( \"localhost:11211\", null, StorageKeyFormat.EMPTY, _mcc ).getSessionIdFormat();\n        assertNotNull(sessionIdFormat);\n        final String sessionId = \"12345678\";\n        assertEquals(sessionIdFormat.createLockName(sessionId), \"lock:\" + sessionId);\n    }\n\t@Test\n\tpublic void testCreateSessionIdShouldOnlyAddNodeIdIfPresent() {\n\t\tassertEquals(createFor( \"n1:localhost:11211\", null, null, _mcc ).createSessionId(\"foo\"), \"foo-n1\" );\n\t\tassertEquals(createFor( \"localhost:11211\", null, null, _mcc ).createSessionId(\"foo\"), \"foo\" );\n\t}\n\t@Test\n\tpublic void testSetNodeAvailable() {\n\t\tfinal MemcachedNodesManager cut = createFor( \"n1:localhost:11211,n2:localhost:11212\", null, null, _mcc );\n\t\tassertTrue(cut.isNodeAvailable(\"n1\"));\n\t\tassertTrue(cut.isNodeAvailable(\"n2\"));\n\t\tcut.setNodeAvailable(\"n1\", false);\n\t\tassertFalse(cut.isNodeAvailable(\"n1\"));\n\t\tassertTrue(cut.isNodeAvailable(\"n2\"));\n\t}\n    @Test\n    public void testIsCouchbaseBucketConfig() {\n        assertTrue(createFor(\"http://10.10.0.1:8091/pools\", null, null, _mcc ).isCouchbaseBucketConfig());\n        assertTrue(createFor(\"http://10.10.0.1:8091/pools,http://10.10.0.2:8091/pools\", null, null, _mcc ).isCouchbaseBucketConfig());\n    }\n    @Test\n    public void testGetCouchbaseBucketURIs() throws URISyntaxException {\n        assertEquals(createFor(\"http://10.10.0.1:8091/pools\", null, null, _mcc ).getCouchbaseBucketURIs(),\n                Arrays.asList(new URI(\"http://10.10.0.1:8091/pools\")));\n        assertEquals(createFor(\"http://10.10.0.1:8091/pools,http://10.10.0.2:8091/pools\", null, null, _mcc ).getCouchbaseBucketURIs(),\n                Arrays.asList(new URI(\"http://10.10.0.1:8091/pools\"), new URI(\"http://10.10.0.2:8091/pools\")));\n    }\n    @Test\n    public void testChangeSessionIdForTomcatFailover() {\n        assertEquals(createFor(\"localhost:11211\", null, null, _mcc)\n                .changeSessionIdForTomcatFailover(sessionId(\"123\", null, null), null), sessionId(\"123\", null, null));\n        assertEquals(createFor(\"localhost:11211\", null, null, _mcc)\n                .changeSessionIdForTomcatFailover(sessionId(\"123\", null, \"tc1\"), \"tc2\"), sessionId(\"123\", null, \"tc2\"));\n        assertEquals(createFor(\"n1:localhost:11211,n2:localhost:11212\", null, null, _mcc)\n                .changeSessionIdForTomcatFailover(sessionId(\"123\", \"n1\", null), null), sessionId(\"123\", \"n1\", null));\n        assertEquals(createFor(\"n1:localhost:11211,n2:localhost:11212\", null, null, _mcc)\n                .changeSessionIdForTomcatFailover(sessionId(\"123\", \"n1\", null), \"tc2\"), sessionId(\"123\", \"n1\", \"tc2\"));\n        assertEquals(createFor(\"n1:localhost:11211,n2:localhost:11212\", null, null, _mcc)\n                .changeSessionIdForTomcatFailover(sessionId(\"123\", \"n1\", \"tc1\"), \"tc2\"), sessionId(\"123\", \"n1\", \"tc2\"));\n        assertEquals(createFor(\"n1:localhost:11211,n2:localhost:11212\", \"n2\", null, _mcc)\n                .changeSessionIdForTomcatFailover(sessionId(\"123\", \"n1\", null), null), sessionId(\"123\", \"n1\", null));\n        assertEquals(createFor(\"n1:localhost:11211,n2:localhost:11212\", \"n2\", null, _mcc)\n                .changeSessionIdForTomcatFailover(sessionId(\"123\", \"n1\", null), \"tc2\"), sessionId(\"123\", \"n1\", \"tc2\"));\n        assertEquals(createFor(\"n1:localhost:11211,n2:localhost:11212\", \"n2\", null, _mcc)\n                .changeSessionIdForTomcatFailover(sessionId(\"123\", \"n1\", \"tc1\"), \"tc2\"), sessionId(\"123\", \"n1\", \"tc2\"));\n        assertEquals(createFor(\"n1:localhost:11211,n2:localhost:11212\", \"n1\", null, _mcc)\n                .changeSessionIdForTomcatFailover(sessionId(\"123\", \"n1\", null), null), sessionId(\"123\", \"n2\", null));\n        assertEquals(createFor(\"n1:localhost:11211,n2:localhost:11212\", \"n1\", null, _mcc)\n                .changeSessionIdForTomcatFailover(sessionId(\"123\", \"n1\", null), \"tc2\"), sessionId(\"123\", \"n2\", \"tc2\"));\n        assertEquals(createFor(\"n1:localhost:11211,n2:localhost:11212\", \"n1\", null, _mcc)\n                .changeSessionIdForTomcatFailover(sessionId(\"123\", \"n1\", \"tc1\"), \"tc2\"), sessionId(\"123\", \"n2\", \"tc2\"));\n    }\n    private static String sessionId(final String plainId, final String memcachedId, final String jvmRoute) {\n        final SessionIdFormat sessionIdFormat = new SessionIdFormat();\n        final String withMemcachedId = sessionIdFormat.createSessionId(plainId, memcachedId);\n        return jvmRoute != null ? sessionIdFormat.changeJvmRoute(withMemcachedId, jvmRoute) : withMemcachedId;\n    }\n"]]}
{"hexsha": "72654c4918164f8ff97d8d7a55a9f6c0868b81ce", "ext": "java", "lang": "Java", "content": "public class NoClassDefFoundWithClassLoaderError\n        extends\n            NoClassDefFoundError\n{\n    private static final long serialVersionUID = 1L; // helps with serialization\n\n    /**\n     * Constructs a <code>NoClassDefFoundError</code> with the specified\n     * detail message.\n     *\n     * @param className the name of the Class that could not be loaded\n     * @param msg   the detail message.\n     * @param loader the ModuleClassLoader that was used\n     */\n    public NoClassDefFoundWithClassLoaderError(\n            String            className,\n            String            msg,\n            ModuleClassLoader loader )\n    {\n        super( msg );\n\n        theClassName   = className;\n        theClassLoader = loader;\n    }\n\n    /**\n     * Obtain the name of the Class that could not be loaded.\n     * \n     * @return the name of the Class\n     */\n    public String getClassName()\n    {\n        return theClassName;\n    }\n\n    /**\n     * Obtain the ClassLoader that could not load the class.\n     * \n     * @return the ClassLoader\n     */\n    public ModuleClassLoader getModuleClassLoader()\n    {\n        return theClassLoader;\n    }\n\n    /**\n     * Convert to String representation, for debugging.\n     *\n     * @return String representation\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buf = new StringBuilder();\n        buf.append( super.toString() );\n        buf.append( \": ClassLoader of Module \" );\n        if( theClassLoader.getModule() != null ) {\n            buf.append( theClassLoader.getModule().toString() );\n        } else {\n            buf.append( \"? (\" ).append( theClassLoader.getClass().getName() ).append( \")\" );\n        }\n\n        return buf.toString();\n    }\n\n    /**\n     * Name of the Class that could not be loaded.\n     */\n    protected String theClassName;\n\n    /**\n     * The ClassLoader through which loading failed.\n     */\n    protected ModuleClassLoader theClassLoader;\n}", "class_id": 0, "repo": "diet4j/diet4j", "file": "diet4j-core/src/main/java/org/diet4j/core/NoClassDefFoundWithClassLoaderError.java", "last_update_at": "2019-11-21T13:12:55+00:00", "question_id": "72654c4918164f8ff97d8d7a55a9f6c0868b81ce", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NoClassDefFoundWithClassLoaderError\n        extends\n            NoClassDefFoundError\n{\n    private static final long serialVersionUID = 1L; // helps with serialization\n    /**\n     * Constructs a <code>NoClassDefFoundError</code> with the specified\n     * detail message.\n     *\n     * @param className the name of the Class that could not be loaded\n     * @param msg   the detail message.\n     * @param loader the ModuleClassLoader that was used\n     */\n    public NoClassDefFoundWithClassLoaderError(\n            String            className,\n            String            msg,\n            ModuleClassLoader loader )\n    {\n        super( msg );\n        theClassName   = className;\n        theClassLoader = loader;\n    }\n    /**\n     * Obtain the name of the Class that could not be loaded.\n     * \n     * @return the name of the Class\n     */\n    public String getClassName()\n    {\n        return theClassName;\n    }\n    /**\n     * Obtain the ClassLoader that could not load the class.\n     * \n     * @return the ClassLoader\n     */\n    public ModuleClassLoader getModuleClassLoader()\n    {\n        return theClassLoader;\n    }\n    /**\n     * Convert to String representation, for debugging.\n     *\n     * @return String representation\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buf = new StringBuilder();\n        buf.append( super.toString() );\n        buf.append( \": ClassLoader of Module \" );\n        if( theClassLoader.getModule() != null ) {\n            buf.append( theClassLoader.getModule().toString() );\n        } else {\n            buf.append( \"? (\" ).append( theClassLoader.getClass().getName() ).append( \")\" );\n        }\n        return buf.toString();\n    }\n    /**\n     * Name of the Class that could not be loaded.\n     */\n    protected String theClassName;\n    /**\n     * The ClassLoader through which loading failed.\n     */\n    protected ModuleClassLoader theClassLoader;\n"]]}
{"hexsha": "e4f8f6bfbc5ddd32518ca82d52fc886e32a50393", "ext": "java", "lang": "Java", "content": "public class XMLDocument extends XMLNode {\n\tprivate static final long serialVersionUID = -8106159267601656260L;\n\n\tpublic XMLDocument() {\n\t}\n\n\tpublic XMLDocument(final Node node) {\n\t\tsuper(node);\n\t}\n\n\tpublic XMLDocument(final String xml) throws SAXException, IOException, ParserConfigurationException {\n\t\tloadString(xml);\n\t}\n\n\tpublic XMLNode getDocumentElement() {\n\t\treturn new XMLNode(((Document) node_).getDocumentElement());\n\t}\n\n\tpublic void loadURL(final String urlString) throws SAXException, IOException, ParserConfigurationException {\n\t\tURL url = new URL(urlString);\n\t\tURLConnection conn = url.openConnection();\n\n\t\tnode_ = getBuilder().parse((InputStream) conn.getContent());\n\t}\n\n\tpublic void loadInputStream(final InputStream is) throws SAXException, IOException, ParserConfigurationException {\n\t\tnode_ = getBuilder().parse(is);\n\t}\n\n\tpublic void loadString(final String s) throws SAXException, IOException, ParserConfigurationException {\n\t\tloadInputStream(new ByteArrayInputStream(s.getBytes(\"UTF-8\"))); //$NON-NLS-1$\n\t}\n\n\tprivate DocumentBuilder getBuilder() throws ParserConfigurationException {\n\t\tDocumentBuilderFactory fac = DocumentBuilderFactory.newInstance();\n\t\tfac.setValidating(false);\n\t\t// fac.setNamespaceAware(true);\n\t\treturn fac.newDocumentBuilder();\n\t}\n\n\tpublic static String escapeXPathValue(final String input) {\n\t\treturn input.replace(\"'\", \"\\\\'\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\ttry {\n\t\t\treturn getXml(null);\n\t\t} catch (IOException e) {\n\t\t\treturn e.getMessage();\n\t\t}\n\t}\n}", "class_id": 0, "repo": "OpenNTF/openliberty-domino", "file": "openliberty-domino/bundles/org.openntf.openliberty.domino/src/main/java/org/openntf/openliberty/domino/util/xml/XMLDocument.java", "last_update_at": "2019-08-21T20:25:47+00:00", "question_id": "e4f8f6bfbc5ddd32518ca82d52fc886e32a50393", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class XMLDocument extends XMLNode {\n\tprivate static final long serialVersionUID = -8106159267601656260L;\n\tpublic XMLDocument() {\n\t}\n\tpublic XMLDocument(final Node node) {\n\t\tsuper(node);\n\t}\n\tpublic XMLDocument(final String xml) throws SAXException, IOException, ParserConfigurationException {\n\t\tloadString(xml);\n\t}\n\tpublic XMLNode getDocumentElement() {\n\t\treturn new XMLNode(((Document) node_).getDocumentElement());\n\t}\n\tpublic void loadURL(final String urlString) throws SAXException, IOException, ParserConfigurationException {\n\t\tURL url = new URL(urlString);\n\t\tURLConnection conn = url.openConnection();\n\t\tnode_ = getBuilder().parse((InputStream) conn.getContent());\n\t}\n\tpublic void loadInputStream(final InputStream is) throws SAXException, IOException, ParserConfigurationException {\n\t\tnode_ = getBuilder().parse(is);\n\t}\n\tpublic void loadString(final String s) throws SAXException, IOException, ParserConfigurationException {\n\t\tloadInputStream(new ByteArrayInputStream(s.getBytes(\"UTF-8\"))); //$NON-NLS-1$\n\t}\n\tprivate DocumentBuilder getBuilder() throws ParserConfigurationException {\n\t\tDocumentBuilderFactory fac = DocumentBuilderFactory.newInstance();\n\t\tfac.setValidating(false);\n\t\t// fac.setNamespaceAware(true);\n\t\treturn fac.newDocumentBuilder();\n\t}\n\tpublic static String escapeXPathValue(final String input) {\n\t\treturn input.replace(\"'\", \"\\\\'\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t}\n\t@Override\n\tpublic String toString() {\n\t\ttry {\n\t\t\treturn getXml(null);\n\t\t} catch (IOException e) {\n\t\t\treturn e.getMessage();\n\t\t}\n\t}\n"]]}
{"hexsha": "420f6cd166494f60b19c3681fe6137ac5969a80e", "ext": "java", "lang": "Java", "content": "public class DebugBridge {\n    private static AndroidDebugBridge sDebugBridge;\n\n    @SuppressWarnings(\"unused\")\n    private static String getAdbLocation() throws Exception {\n        String sdkDir = System.getenv(\"ANDROID_HOME\");\n        if (sdkDir == null || sdkDir.equalsIgnoreCase(\"\")) {\n            throw new Exception(\"ENV Variables ANDROID_HOME IS NOT SETTED\");\n        }\n\n        String toolsDir = sdkDir + File.separator + \"tools\";\n        File sdk = new File(toolsDir).getParentFile();\n\n        // check if adb is present in platform-tools\n        File platformTools = new File(sdk, \"platform-tools\");\n        File adb = new File(platformTools, SdkConstants.FN_ADB);\n        if (adb.exists()) {\n            return adb.getAbsolutePath();\n        }\n\n        // check if adb is present in the tools directory\n        adb = new File(toolsDir, SdkConstants.FN_ADB);\n        if (adb.exists()) {\n            return adb.getAbsolutePath();\n        }\n\n        // check if we're in the Android source tree where adb is in $ANDROID_HOST_OUT/bin/adb\n        String androidOut = System.getenv(\"ANDROID_HOST_OUT\");\n        if (androidOut != null) {\n            String adbLocation = androidOut + File.separator + \"bin\" + File.separator +\n                    SdkConstants.FN_ADB;\n            if (new File(adbLocation).exists()) {\n                return adbLocation;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Init.\n     */\n    public static void init() {\n        if (sDebugBridge == null) {\n            String adbLocation = null;\n            try {\n                adbLocation = getAdbLocation();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            if (adbLocation != null) {\n                AndroidDebugBridge.init(false);\n                sDebugBridge = AndroidDebugBridge.createBridge(adbLocation, false);\n                waitDeviceList(sDebugBridge);\n            }\n        }\n    }\n\n    /**\n     * Terminate.\n     */\n    public static void terminate() {\n        if (sDebugBridge != null) {\n            sDebugBridge = null;\n            AndroidDebugBridge.terminate();\n        }\n    }\n\n    /**\n     * Gets devices.\n     *\n     * @return the devices\n     */\n    public static List<IDevice> getDevices() {\n        return Arrays.asList(sDebugBridge.getDevices());\n    }\n\n    private static void waitDeviceList(AndroidDebugBridge bridge) {\n        int count = 0;\n        while (!bridge.hasInitialDeviceList()) {\n            try {\n                Thread.sleep(500);\n                count++;\n            } catch (InterruptedException ignored) {\n            }\n            if (count > 60) {\n                System.err.print(\"\u7b49\u5f85\u83b7\u53d6\u8bbe\u5907\u8d85\u65f6\");\n                break;\n            }\n        }\n    }\n\n    /**\n     * Gets device.\n     *\n     * @return the device\n     * @throws IOException the io exception\n     */\n    public static IDevice getDevice() throws IOException {\n        List<IDevice> devices = getDevices();\n        if (devices.size() == 0) {\n            throw new IOException(\"No Android devices were detected by adb.\");\n        } else if (devices.size() >= 1) {\n            return devices.get(0);\n        }\n        return null;\n    }\n\n    /**\n     * Gets device.\n     *\n     * @param index the index\n     * @return the device\n     * @throws IOException the io exception\n     */\n    public static IDevice getDevice(int index) throws IOException {\n        List<IDevice> devices = getDevices();\n        if (devices.size() == 0) {\n            throw new IOException(\"No Android devices were detected by adb.\");\n        } else if (devices.size() >= 1) {\n            return devices.get(index);\n        }\n        return null;\n    }\n}", "class_id": 0, "repo": "jerryazhu/smart-ui-framework", "file": "src/com/qa/framework/android/DebugBridge.java", "last_update_at": "2019-11-11T16:07:21+00:00", "question_id": "420f6cd166494f60b19c3681fe6137ac5969a80e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DebugBridge {\n    private static AndroidDebugBridge sDebugBridge;\n    @SuppressWarnings(\"unused\")\n    private static String getAdbLocation() throws Exception {\n        String sdkDir = System.getenv(\"ANDROID_HOME\");\n        if (sdkDir == null || sdkDir.equalsIgnoreCase(\"\")) {\n            throw new Exception(\"ENV Variables ANDROID_HOME IS NOT SETTED\");\n        }\n        String toolsDir = sdkDir + File.separator + \"tools\";\n        File sdk = new File(toolsDir).getParentFile();\n        // check if adb is present in platform-tools\n        File platformTools = new File(sdk, \"platform-tools\");\n        File adb = new File(platformTools, SdkConstants.FN_ADB);\n        if (adb.exists()) {\n            return adb.getAbsolutePath();\n        }\n        // check if adb is present in the tools directory\n        adb = new File(toolsDir, SdkConstants.FN_ADB);\n        if (adb.exists()) {\n            return adb.getAbsolutePath();\n        }\n        // check if we're in the Android source tree where adb is in $ANDROID_HOST_OUT/bin/adb\n        String androidOut = System.getenv(\"ANDROID_HOST_OUT\");\n        if (androidOut != null) {\n            String adbLocation = androidOut + File.separator + \"bin\" + File.separator +\n                    SdkConstants.FN_ADB;\n            if (new File(adbLocation).exists()) {\n                return adbLocation;\n            }\n        }\n        return null;\n    }\n    /**\n     * Init.\n     */\n    public static void init() {\n        if (sDebugBridge == null) {\n            String adbLocation = null;\n            try {\n                adbLocation = getAdbLocation();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            if (adbLocation != null) {\n                AndroidDebugBridge.init(false);\n                sDebugBridge = AndroidDebugBridge.createBridge(adbLocation, false);\n                waitDeviceList(sDebugBridge);\n            }\n        }\n    }\n    /**\n     * Terminate.\n     */\n    public static void terminate() {\n        if (sDebugBridge != null) {\n            sDebugBridge = null;\n            AndroidDebugBridge.terminate();\n        }\n    }\n    /**\n     * Gets devices.\n     *\n     * @return the devices\n     */\n    public static List<IDevice> getDevices() {\n        return Arrays.asList(sDebugBridge.getDevices());\n    }\n    private static void waitDeviceList(AndroidDebugBridge bridge) {\n        int count = 0;\n        while (!bridge.hasInitialDeviceList()) {\n            try {\n                Thread.sleep(500);\n                count++;\n            } catch (InterruptedException ignored) {\n            }\n            if (count > 60) {\n                System.err.print(\"\u7b49\u5f85\u83b7\u53d6\u8bbe\u5907\u8d85\u65f6\");\n                break;\n            }\n        }\n    }\n    /**\n     * Gets device.\n     *\n     * @return the device\n     * @throws IOException the io exception\n     */\n    public static IDevice getDevice() throws IOException {\n        List<IDevice> devices = getDevices();\n        if (devices.size() == 0) {\n            throw new IOException(\"No Android devices were detected by adb.\");\n        } else if (devices.size() >= 1) {\n            return devices.get(0);\n        }\n        return null;\n    }\n    /**\n     * Gets device.\n     *\n     * @param index the index\n     * @return the device\n     * @throws IOException the io exception\n     */\n    public static IDevice getDevice(int index) throws IOException {\n        List<IDevice> devices = getDevices();\n        if (devices.size() == 0) {\n            throw new IOException(\"No Android devices were detected by adb.\");\n        } else if (devices.size() >= 1) {\n            return devices.get(index);\n        }\n        return null;\n    }\n"]]}
{"hexsha": "a7c0c7c4d501e7bc23b6dc86e363abc43f63ad41", "ext": "java", "lang": "Java", "content": "public class Vector2D implements Serializable, Cloneable {\n\n\tprivate static final long serialVersionUID = -8279176595720850402L;\n\tprotected double length;\n\tprotected double direction;\n\tprotected Point2D.Float from;\n\tprotected Point2D.Float to;\n\n\t/**\n\t * Creates a vector with the given length and direction.\n\t * \n\t * @param length\n\t *            magnitude of vector\n\t * @param direction\n\t *            direction of vector in radians.\n\t * \n\t */\n\tpublic Vector2D(double length, double direction) {\n\t\tsuper();\n\t\tthis.length = length;\n\t\tthis.direction = radianNorm(direction);\n\t\tthis.from = new Point2D.Float(0, 0);\n\t\tsetDirection(this.direction);\n\t}\n\n\t/**\n\t * Creates a vector using two points.\n\t */\n\tpublic Vector2D(Point2D.Float from, Point2D.Float to) {\n\t\tthis.from = from;\n\t\tthis.to = to;\n\t\tlength = from.distance(to);\n\t\tsetDirection();\n\t}\n\n\t/**\n\t * Limits the radian value between 0 and 2 PI.\n\t * \n\t * @param radian\n\t * @return\n\t */\n\tprotected double radianNorm(double radian) {\n\t\tdouble r = radian / (Math.PI * 2);\n\t\tif (r < 1)\n\t\t\treturn radian;\n\t\tr = Math.floor(r);\n\t\treturn radian - r * (Math.PI * 2);\n\t}\n\n\t/**\n\t * Returns the magnitude of the vector.\n\t */\n\tpublic double getLength() {\n\t\treturn length;\n\t}\n\n\t/**\n\t * Returns the direction of the vector in radians.\n\t */\n\tpublic double getRadian() {\n\t\treturn direction;\n\t}\n\n\t/**\n\t * Returns the direction of the vector in degrees.\n\t */\n\tpublic double getDegree() {\n\t\treturn Math.toDegrees(direction);\n\t}\n\n\t/**\n\t * Sets starting point.\n\t * \n\t */\n\tpublic void setP1(float x, float y) {\n\t\tsetP1(new Point2D.Float(x, y));\n\t}\n\n\t/**\n\t * Sets starting point.\n\t * \n\t */\n\tpublic void setP1(Point2D.Float p1) {\n\t\tthis.from = p1;\n\t\tlength = from.distance(to);\n\t\tsetDirection();\n\t}\n\n\t/**\n\t * Sets end point.\n\t * \n\t */\n\tpublic void setP2(float x, float y) {\n\t\tsetP2(new Point2D.Float(x, y));\n\t}\n\n\t/**\n\t * Sets end point.\n\t * \n\t */\n\tpublic void setP2(Point2D.Float p2) {\n\t\tthis.to = p2;\n\t\tlength = from.distance(to);\n\t\tsetDirection();\n\t}\n\n\t/**\n\t * Returns starting point.\n\t */\n\tpublic Point2D.Float getP1() {\n\t\treturn from;\n\t}\n\n\t/**\n\t * Returns end point.\n\t */\n\tpublic Point2D.Float getP2() {\n\t\treturn to;\n\t}\n\n\t/**\n\t * Shifts a copy of the vector to the origo (0,0).\n\t */\n\tpublic Vector2D getOrigo() {\n\t\tPoint2D.Float p2 = new Point2D.Float(to.x - from.x, to.y - from.y);\n\t\treturn new Vector2D(new Point2D.Float(0, 0), p2);\n\t}\n\n\t/**\n\t * Shifts this vector by the given point.\n\t * \n\t * @param p\n\t */\n\tpublic void shiftWith(Point2D.Float p) {\n\t\tto.x += p.x;\n\t\tto.y += p.y;\n\t\tfrom.x += p.x;\n\t\tfrom.y += p.y;\n\t}\n\n\t/**\n\t * Calculates the direction from p1 and p2.\n\t */\n\tprotected void setDirection() {\n\t\tfloat x = to.x - from.x;\n\t\tfloat y = to.y - from.y;\n\t\tdirection = Math.atan2(x, y);\n\t\tif (direction < 0)\n\t\t\tdirection = Math.abs(direction) + Math.PI / 2;\n\t\telse if (direction < Math.PI / 2) {\n\t\t\tdirection = Math.abs(direction - Math.PI / 2);\n\t\t} else\n\t\t\tdirection = 2.5 * Math.PI - direction;\n\t}\n\n\t/**\n\t * Sets the new direction in radians.\n\t */\n\tpublic void setDirection(double rad) {\n\t\tthis.direction = radianNorm(rad);\n\t\tdouble y = Math.sin(direction) * length;\n\t\tdouble x = Math.cos(direction) * length;\n\t\tto = new Point2D.Float((float) x, (float) y);\n\t\t// System.out.println((to));\n\t\t// System.out.println(new Vector2D(from, to));\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"length: \" + length + \"; deg: \" + getDegree();\n\t}\n\n\t/**\n\t * Multiplies the vector.\n\t */\n\tpublic void multiply(double scale) {\n\t\tVector2D org = getOrigo();\n\t\tPoint2D.Float p2 = org.getP2();\n\t\tp2.x *= scale;\n\t\tp2.y *= scale;\n\t\torg.setP2(p2);\n\t\torg.shiftWith(getP1());\n\t\tsetP1(org.getP1());\n\t\tsetP2(org.getP2());\n\t}\n\n\t@Override\n\tpublic Vector2D clone() {\n\t\tVector2D v;\n\t\ttry {\n\t\t\tv = (Vector2D) super.clone();\n\t\t} catch (CloneNotSupportedException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t\tv.from = (Float) from.clone();\n\t\tv.to = (Float) to.clone();\n\t\treturn v;\n\t}\n}", "class_id": 0, "repo": "kephale/AnimalTracker", "file": "src/hu/elte/animaltracker/model/tracking/Vector2D.java", "last_update_at": "2019-10-09T17:59:18+00:00", "question_id": "a7c0c7c4d501e7bc23b6dc86e363abc43f63ad41", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Vector2D implements Serializable, Cloneable {\n\tprivate static final long serialVersionUID = -8279176595720850402L;\n\tprotected double length;\n\tprotected double direction;\n\tprotected Point2D.Float from;\n\tprotected Point2D.Float to;\n\t/**\n\t * Creates a vector with the given length and direction.\n\t * \n\t * @param length\n\t *            magnitude of vector\n\t * @param direction\n\t *            direction of vector in radians.\n\t * \n\t */\n\tpublic Vector2D(double length, double direction) {\n\t\tsuper();\n\t\tthis.length = length;\n\t\tthis.direction = radianNorm(direction);\n\t\tthis.from = new Point2D.Float(0, 0);\n\t\tsetDirection(this.direction);\n\t}\n\t/**\n\t * Creates a vector using two points.\n\t */\n\tpublic Vector2D(Point2D.Float from, Point2D.Float to) {\n\t\tthis.from = from;\n\t\tthis.to = to;\n\t\tlength = from.distance(to);\n\t\tsetDirection();\n\t}\n\t/**\n\t * Limits the radian value between 0 and 2 PI.\n\t * \n\t * @param radian\n\t * @return\n\t */\n\tprotected double radianNorm(double radian) {\n\t\tdouble r = radian / (Math.PI * 2);\n\t\tif (r < 1)\n\t\t\treturn radian;\n\t\tr = Math.floor(r);\n\t\treturn radian - r * (Math.PI * 2);\n\t}\n\t/**\n\t * Returns the magnitude of the vector.\n\t */\n\tpublic double getLength() {\n\t\treturn length;\n\t}\n\t/**\n\t * Returns the direction of the vector in radians.\n\t */\n\tpublic double getRadian() {\n\t\treturn direction;\n\t}\n\t/**\n\t * Returns the direction of the vector in degrees.\n\t */\n\tpublic double getDegree() {\n\t\treturn Math.toDegrees(direction);\n\t}\n\t/**\n\t * Sets starting point.\n\t * \n\t */\n\tpublic void setP1(float x, float y) {\n\t\tsetP1(new Point2D.Float(x, y));\n\t}\n\t/**\n\t * Sets starting point.\n\t * \n\t */\n\tpublic void setP1(Point2D.Float p1) {\n\t\tthis.from = p1;\n\t\tlength = from.distance(to);\n\t\tsetDirection();\n\t}\n\t/**\n\t * Sets end point.\n\t * \n\t */\n\tpublic void setP2(float x, float y) {\n\t\tsetP2(new Point2D.Float(x, y));\n\t}\n\t/**\n\t * Sets end point.\n\t * \n\t */\n\tpublic void setP2(Point2D.Float p2) {\n\t\tthis.to = p2;\n\t\tlength = from.distance(to);\n\t\tsetDirection();\n\t}\n\t/**\n\t * Returns starting point.\n\t */\n\tpublic Point2D.Float getP1() {\n\t\treturn from;\n\t}\n\t/**\n\t * Returns end point.\n\t */\n\tpublic Point2D.Float getP2() {\n\t\treturn to;\n\t}\n\t/**\n\t * Shifts a copy of the vector to the origo (0,0).\n\t */\n\tpublic Vector2D getOrigo() {\n\t\tPoint2D.Float p2 = new Point2D.Float(to.x - from.x, to.y - from.y);\n\t\treturn new Vector2D(new Point2D.Float(0, 0), p2);\n\t}\n\t/**\n\t * Shifts this vector by the given point.\n\t * \n\t * @param p\n\t */\n\tpublic void shiftWith(Point2D.Float p) {\n\t\tto.x += p.x;\n\t\tto.y += p.y;\n\t\tfrom.x += p.x;\n\t\tfrom.y += p.y;\n\t}\n\t/**\n\t * Calculates the direction from p1 and p2.\n\t */\n\tprotected void setDirection() {\n\t\tfloat x = to.x - from.x;\n\t\tfloat y = to.y - from.y;\n\t\tdirection = Math.atan2(x, y);\n\t\tif (direction < 0)\n\t\t\tdirection = Math.abs(direction) + Math.PI / 2;\n\t\telse if (direction < Math.PI / 2) {\n\t\t\tdirection = Math.abs(direction - Math.PI / 2);\n\t\t} else\n\t\t\tdirection = 2.5 * Math.PI - direction;\n\t}\n\t/**\n\t * Sets the new direction in radians.\n\t */\n\tpublic void setDirection(double rad) {\n\t\tthis.direction = radianNorm(rad);\n\t\tdouble y = Math.sin(direction) * length;\n\t\tdouble x = Math.cos(direction) * length;\n\t\tto = new Point2D.Float((float) x, (float) y);\n\t\t// System.out.println((to));\n\t\t// System.out.println(new Vector2D(from, to));\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn \"length: \" + length + \"; deg: \" + getDegree();\n\t}\n\t/**\n\t * Multiplies the vector.\n\t */\n\tpublic void multiply(double scale) {\n\t\tVector2D org = getOrigo();\n\t\tPoint2D.Float p2 = org.getP2();\n\t\tp2.x *= scale;\n\t\tp2.y *= scale;\n\t\torg.setP2(p2);\n\t\torg.shiftWith(getP1());\n\t\tsetP1(org.getP1());\n\t\tsetP2(org.getP2());\n\t}\n\t@Override\n\tpublic Vector2D clone() {\n\t\tVector2D v;\n\t\ttry {\n\t\t\tv = (Vector2D) super.clone();\n\t\t} catch (CloneNotSupportedException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t\tv.from = (Float) from.clone();\n\t\tv.to = (Float) to.clone();\n\t\treturn v;\n\t}\n"]]}
{"hexsha": "7c1989cc73e0ef77b697ddb4c729848c6d9e4f94", "ext": "java", "lang": "Java", "content": "@Slf4j\npublic class Iso8601DateFormat\n{\n  public static final String BASIC_FORMAT = \"yyyyMMdd'T'HHmmssZ\";\n  private static final String GMT = \"GMT\";\n\n  // 20031107T152420-0500  or\n  // 2003-11-07T15:24:20-05:00\n  private static final Pattern PATTERN_MATCH =\n    Pattern.compile(\n      \"^(?:(\\\\d{2,4})-?)?\" + // year\n      \"(?:(\\\\d{2})-?)?\" + // month\n      \"(\\\\d{2})?\" + // day of month\n      \"T?\" + // time separator\n      \"(?:(\\\\d{2}):?)?\" + // hour\n      \"(?:(\\\\d{2}):?)?\" + // minutes\n      \"(\\\\d{2})?\" + // seconds\n      \"(Z?|(?:\\\\+|-).+)?$\"); // timezone: -0500 or +08:00 or -05 or Z\n  private String pattern;\n\n  /**\n   * Creates a new Iso8601DateFormat object.\n   */\n  public Iso8601DateFormat()\n  {\n    log.debug(\"new Iso8601DateFormat()\");\n    this.pattern = BASIC_FORMAT;\n  }\n\n  /**\n   * DOCUMENT ME!\n   *\n   * @param simpleDateFormatPattern\n   *\n   * @see java.text.SimpleDateFormat\n   */\n  public Iso8601DateFormat(String simpleDateFormatPattern)\n  {\n    log.debug(\"new Iso8601DateFormat(String \" + simpleDateFormatPattern + \")\");\n    this.pattern = simpleDateFormatPattern;\n  }\n\n  /**\n   * DOCUMENTATION PENDING\n   *\n   * @param date DOCUMENTATION PENDING\n   *\n   * @return DOCUMENTATION PENDING\n   */\n  public String format(Date date)\n  {\n    log.debug(\"format(Date \" + date + \")\");\n    SimpleDateFormat sdf = null;\n    if(this.pattern == null)\n    {\n      sdf = new SimpleDateFormat();\n    }\n    else\n    {\n      sdf = new SimpleDateFormat(pattern);\n    }\n\n    return sdf.format(date);\n  }\n\n  /**\n   * DOCUMENTATION PENDING\n   *\n   * @param iso8601String DOCUMENTATION PENDING\n   *\n   * @return DOCUMENTATION PENDING\n   *\n   * @throws Iso8601FormatException DOCUMENTATION PENDING\n   */\n  public Calendar parse(String iso8601String)\n    throws Iso8601FormatException\n  {\n    log.debug(\"parse(String \" + iso8601String + \")\");\n    if(iso8601String == null)\n    {\n      throw new Iso8601FormatException(\n        \"illegal String iso8601TimeInterval argument: iso8601String == null\");\n    }\n\n    iso8601String = iso8601String.toUpperCase();\n    final Matcher matcher = PATTERN_MATCH.matcher(iso8601String);\n    if(matcher.matches())\n    {\n      if(log.isDebugEnabled())\n      {\n        for(int i = 0; i <= matcher.groupCount(); i++)\n        {\n          log.debug(i + \"=\" + matcher.group(i));\n        }\n      }\n\n      String tz = matcher.group(7);\n      Calendar cal = null;\n      if((tz != null) && (tz.length() > 0))\n      {\n        if(\"Z\".equals(tz))\n        {\n          tz = \"Zulu\";\n        }\n        else\n        {\n          tz = GMT + tz;\n        }\n\n        if(log.isDebugEnabled())\n        {\n          log.debug(\"tz=\" + tz);\n          log.debug(\"TimeZone.getID()=\" + TimeZone.getTimeZone(tz).getID());\n        }\n\n        cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(tz));\n      }\n      else\n      {\n        cal = GregorianCalendar.getInstance();\n\n        /* data must be zeroed out to counteract now behavior*/\n        cal.clear();\n      }\n\n      /* year */\n      if(matcher.group(1) != null)\n      {\n        final int year = Integer.parseInt(matcher.group(1));\n        cal.set(Calendar.YEAR, year);\n      }\n      else\n      {\n        throw new Iso8601FormatException(\"Year is required\");\n      }\n\n      /* month */\n      if(matcher.group(2) != null)\n      {\n        final int month = Integer.parseInt(matcher.group(2)) - 1; // zero based\n        cal.set(Calendar.MONTH, month);\n      }\n\n      /* date (day) */\n      if(matcher.group(3) != null)\n      {\n        final int date = Integer.parseInt(matcher.group(3));\n        cal.set(Calendar.DAY_OF_MONTH, date);\n      }\n\n      /* hour */\n      if(matcher.group(4) != null)\n      {\n        final int hour = Integer.parseInt(matcher.group(4));\n        cal.set(Calendar.HOUR_OF_DAY, hour);\n      }\n\n      /* minutes */\n      if(matcher.group(5) != null)\n      {\n        final int min = Integer.parseInt(matcher.group(5));\n        cal.set(Calendar.MINUTE, min);\n      }\n\n      /* seconds */\n      if(matcher.group(6) != null)\n      {\n        final int sec = Integer.parseInt(matcher.group(6));\n        cal.set(Calendar.SECOND, sec);\n      }\n\n      return cal;\n    }\n\n    throw new Iso8601FormatException(\"ISO8601 format could not be matched\");\n  }\n}", "class_id": 0, "repo": "RyanAFinney/sakai", "file": "samigo/samigo-qti/src/java/org/sakaiproject/tool/assessment/qti/util/Iso8601DateFormat.java", "last_update_at": "2019-08-04T22:59:41+00:00", "question_id": "7c1989cc73e0ef77b697ddb4c729848c6d9e4f94", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Slf4j\npublic class Iso8601DateFormat\n{\n  public static final String BASIC_FORMAT = \"yyyyMMdd'T'HHmmssZ\";\n  private static final String GMT = \"GMT\";\n  // 20031107T152420-0500  or\n  // 2003-11-07T15:24:20-05:00\n  private static final Pattern PATTERN_MATCH =\n    Pattern.compile(\n      \"^(?:(\\\\d{2,4})-?)?\" + // year\n      \"(?:(\\\\d{2})-?)?\" + // month\n      \"(\\\\d{2})?\" + // day of month\n      \"T?\" + // time separator\n      \"(?:(\\\\d{2}):?)?\" + // hour\n      \"(?:(\\\\d{2}):?)?\" + // minutes\n      \"(\\\\d{2})?\" + // seconds\n      \"(Z?|(?:\\\\+|-).+)?$\"); // timezone: -0500 or +08:00 or -05 or Z\n  private String pattern;\n  /**\n   * Creates a new Iso8601DateFormat object.\n   */\n  public Iso8601DateFormat()\n  {\n    log.debug(\"new Iso8601DateFormat()\");\n    this.pattern = BASIC_FORMAT;\n  }\n  /**\n   * DOCUMENT ME!\n   *\n   * @param simpleDateFormatPattern\n   *\n   * @see java.text.SimpleDateFormat\n   */\n  public Iso8601DateFormat(String simpleDateFormatPattern)\n  {\n    log.debug(\"new Iso8601DateFormat(String \" + simpleDateFormatPattern + \")\");\n    this.pattern = simpleDateFormatPattern;\n  }\n  /**\n   * DOCUMENTATION PENDING\n   *\n   * @param date DOCUMENTATION PENDING\n   *\n   * @return DOCUMENTATION PENDING\n   */\n  public String format(Date date)\n  {\n    log.debug(\"format(Date \" + date + \")\");\n    SimpleDateFormat sdf = null;\n    if(this.pattern == null)\n    {\n      sdf = new SimpleDateFormat();\n    }\n    else\n    {\n      sdf = new SimpleDateFormat(pattern);\n    }\n    return sdf.format(date);\n  }\n  /**\n   * DOCUMENTATION PENDING\n   *\n   * @param iso8601String DOCUMENTATION PENDING\n   *\n   * @return DOCUMENTATION PENDING\n   *\n   * @throws Iso8601FormatException DOCUMENTATION PENDING\n   */\n  public Calendar parse(String iso8601String)\n    throws Iso8601FormatException\n  {\n    log.debug(\"parse(String \" + iso8601String + \")\");\n    if(iso8601String == null)\n    {\n      throw new Iso8601FormatException(\n        \"illegal String iso8601TimeInterval argument: iso8601String == null\");\n    }\n    iso8601String = iso8601String.toUpperCase();\n    final Matcher matcher = PATTERN_MATCH.matcher(iso8601String);\n    if(matcher.matches())\n    {\n      if(log.isDebugEnabled())\n      {\n        for(int i = 0; i <= matcher.groupCount(); i++)\n        {\n          log.debug(i + \"=\" + matcher.group(i));\n        }\n      }\n      String tz = matcher.group(7);\n      Calendar cal = null;\n      if((tz != null) && (tz.length() > 0))\n      {\n        if(\"Z\".equals(tz))\n        {\n          tz = \"Zulu\";\n        }\n        else\n        {\n          tz = GMT + tz;\n        }\n        if(log.isDebugEnabled())\n        {\n          log.debug(\"tz=\" + tz);\n          log.debug(\"TimeZone.getID()=\" + TimeZone.getTimeZone(tz).getID());\n        }\n        cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(tz));\n      }\n      else\n      {\n        cal = GregorianCalendar.getInstance();\n        /* data must be zeroed out to counteract now behavior*/\n        cal.clear();\n      }\n      /* year */\n      if(matcher.group(1) != null)\n      {\n        final int year = Integer.parseInt(matcher.group(1));\n        cal.set(Calendar.YEAR, year);\n      }\n      else\n      {\n        throw new Iso8601FormatException(\"Year is required\");\n      }\n      /* month */\n      if(matcher.group(2) != null)\n      {\n        final int month = Integer.parseInt(matcher.group(2)) - 1; // zero based\n        cal.set(Calendar.MONTH, month);\n      }\n      /* date (day) */\n      if(matcher.group(3) != null)\n      {\n        final int date = Integer.parseInt(matcher.group(3));\n        cal.set(Calendar.DAY_OF_MONTH, date);\n      }\n      /* hour */\n      if(matcher.group(4) != null)\n      {\n        final int hour = Integer.parseInt(matcher.group(4));\n        cal.set(Calendar.HOUR_OF_DAY, hour);\n      }\n      /* minutes */\n      if(matcher.group(5) != null)\n      {\n        final int min = Integer.parseInt(matcher.group(5));\n        cal.set(Calendar.MINUTE, min);\n      }\n      /* seconds */\n      if(matcher.group(6) != null)\n      {\n        final int sec = Integer.parseInt(matcher.group(6));\n        cal.set(Calendar.SECOND, sec);\n      }\n      return cal;\n    }\n    throw new Iso8601FormatException(\"ISO8601 format could not be matched\");\n  }\n"]]}
{"hexsha": "a1daf720ce934a1a0226eb822af7054d269cb18b", "ext": "java", "lang": "Java", "content": "@Service\npublic class WechatUserInfoService extends CrudService<WechatUserInfoDao, WechatUserInfo>{\n\n\tpublic WechatUserInfo findByOpenId(String openId) {\n\t\tAssert.hasLength(openId,\"openId \u4e3a\u7a7a\");\n\t\tWechatUserInfo wechatUserInfo = new WechatUserInfo();\n\t\twechatUserInfo.setOpenid(openId);\n\t\tList<WechatUserInfo> list = this.findList(wechatUserInfo);\n\t\treturn list.size() > 0 ? list.get(0):null;\n\t}\n\t\n}", "class_id": 0, "repo": "yuchen0228/seezoon-framework-all", "file": "src/main/java/com/seezoon/framework/modules/wechat/service/WechatUserInfoService.java", "last_update_at": "2019-04-04T01:11:04+00:00", "question_id": "a1daf720ce934a1a0226eb822af7054d269cb18b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\npublic class WechatUserInfoService extends CrudService<WechatUserInfoDao, WechatUserInfo>{\n\tpublic WechatUserInfo findByOpenId(String openId) {\n\t\tAssert.hasLength(openId,\"openId \u4e3a\u7a7a\");\n\t\tWechatUserInfo wechatUserInfo = new WechatUserInfo();\n\t\twechatUserInfo.setOpenid(openId);\n\t\tList<WechatUserInfo> list = this.findList(wechatUserInfo);\n\t\treturn list.size() > 0 ? list.get(0):null;\n\t}\n\t\n"]]}
{"hexsha": "74d49e70dbafd5c3cdc1c56de75fdee66d1d2f27", "ext": "java", "lang": "Java", "content": "@SuppressWarnings({\"unused\", \"WeakerAccess\"})\npublic class PreservationActionsApiImpl extends AbstractApiCallImpl<PreservationActions, PreservationAction> implements PreservationActionsApi {\n\n    /**\n     * Default Constructor\n     *\n     * @param apiClient Configured client\n     */\n    public PreservationActionsApiImpl(ApiClient apiClient) {\n        super(apiClient, \"/preservation-actions\", PreservationActions.class, PreservationAction.class);\n    }\n\n    /**\n     * Constructor allowing for authenticated GETs\n     *\n     * @param apiClient Configured client\n     * @param authNames Authentication/Authorization schema to use\n     */\n    public PreservationActionsApiImpl(ApiClient apiClient, String[] authNames) {\n        this(apiClient);\n        this.localVarAuthNames = authNames;\n    }\n\n    @Override\n    public PreservationActions getAllPreservationActions() throws ApiException {\n        return getListingApiResponse(null, null, null, null, Collections.emptyMap()).getData();\n    }\n\n    @Override\n    public PreservationActions getPagedListOfPreservationActions(Integer offset, Integer limit) throws ApiException {\n        return getListingApiResponse(null, null, offset, limit, Collections.emptyMap()).getData();\n    }\n\n    @Override\n    public PreservationActions getPagedListOfPreservationActionsByModifiedDate(String modifiedAfter, String modifiedBefore, Integer offset, Integer limit) throws ApiException {\n        return getListingApiResponse(modifiedAfter, modifiedBefore, offset, limit, Collections.emptyMap()).getData();\n    }\n\n    @Override\n    public PreservationActions getPreservationActionsByModifiedDate(String modifiedAfter, String modifiedBefore) throws ApiException {\n        return getListingApiResponse(modifiedAfter, modifiedBefore, null, null, Collections.emptyMap()).getData();\n    }\n\n    @Override\n    public PreservationActions getPreservationActionsByTools(List<String> toolIds, String modifiedAfter, String modifiedBefore, Integer offset, Integer limit) throws ApiException {\n        return getListingApiResponse(modifiedAfter, modifiedBefore, offset, limit, getToolsFilterHeader(toolIds)).getData();\n    }\n\n    @Override\n    public PreservationActions getPreservationActionsByTypes(List<String> preservationActionTypeIds, String modifiedAfter, String modifiedBefore, Integer offset, Integer limit) throws ApiException {\n        return getListingApiResponse(modifiedAfter, modifiedBefore, offset, limit, getTypesFilterHeader(preservationActionTypeIds)).getData();\n    }\n\n    @Override\n    public PreservationActions getPreservationActionsByToolsAndTypes(List<String> toolIds, List<String> preservationActionTypeIds, String modifiedAfter, String modifiedBefore, Integer offset, Integer limit) throws ApiException {\n        Map<String, String> headers = getToolsFilterHeader(toolIds);\n        headers.putAll(getTypesFilterHeader(preservationActionTypeIds));\n        return getListingApiResponse(modifiedAfter, modifiedBefore, offset, limit, headers).getData();\n    }\n\n    @Override\n    public void getPreservationActionsAsync(List<String> toolIds, List<String> preservationActionTypeIds, String modifiedAfter, String modifiedBefore, ApiCallback<PreservationActions> callback) throws ApiException {\n        Map<String, String> headers = getToolsFilterHeader(toolIds);\n        headers.putAll(getTypesFilterHeader(preservationActionTypeIds));\n        getListingAsync(null, modifiedAfter, modifiedBefore, headers, callback);\n    }\n\n    @Override\n    public PreservationAction getPreservationActionById(String id) throws ApiException {\n        return getEntity(id, null).getData();\n    }\n\n    @Override\n    public void getPreservationActionByIdAsync(String id, ApiCallback<PreservationAction> callback) throws ApiException {\n        getEntityAsync(id, null, callback);\n    }\n\n    @Override\n    public PreservationAction updatePreservationAction(String id, PreservationAction data) throws ApiException {\n        return updateEntity(id, data).getData();\n    }\n\n    @Override\n    public void updatePreservationActionAsync(String id, PreservationAction data, ApiCallback<PreservationAction> callback) throws ApiException {\n        updateEntityAsync(id, data, callback);\n    }\n\n    @Override\n    public PreservationAction createPreservationAction(PreservationAction data) throws ApiException {\n        return createNewEntity(data).getData();\n    }\n\n    @Override\n    public void createPreservationActionAsync(PreservationAction data, ApiCallback<PreservationAction> callback) throws ApiException {\n        createNewEntityAsync(data, callback);\n    }\n\n    // --- Private internal methods\n\n    private ApiResponse<PreservationActions> getListingApiResponse(String modifiedAfter, String modifiedBefore, Integer offset, Integer limit, Map<String, String> headers) throws ApiException {\n        return getListing(null, modifiedAfter, modifiedBefore, offset, limit, headers);\n    }\n\n    private Map<String, String> getToolsFilterHeader(List<String> toolIds) {\n        return getFilterHeader(\"tool\", toolIds);\n    }\n\n    private Map<String, String> getTypesFilterHeader(List<String> preservationActionTypeIds) {\n        return getFilterHeader(\"preservation_action_type\", preservationActionTypeIds);\n    }\n\n}", "class_id": 0, "repo": "MartinSpeller/par", "file": "api/clients/java/src/main/java/org/parcore/api/client/endpoints/PreservationActionsApiImpl.java", "last_update_at": "2019-05-24T11:24:52+00:00", "question_id": "74d49e70dbafd5c3cdc1c56de75fdee66d1d2f27", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings({\"unused\", \"WeakerAccess\"})\npublic class PreservationActionsApiImpl extends AbstractApiCallImpl<PreservationActions, PreservationAction> implements PreservationActionsApi {\n    /**\n     * Default Constructor\n     *\n     * @param apiClient Configured client\n     */\n    public PreservationActionsApiImpl(ApiClient apiClient) {\n        super(apiClient, \"/preservation-actions\", PreservationActions.class, PreservationAction.class);\n    }\n    /**\n     * Constructor allowing for authenticated GETs\n     *\n     * @param apiClient Configured client\n     * @param authNames Authentication/Authorization schema to use\n     */\n    public PreservationActionsApiImpl(ApiClient apiClient, String[] authNames) {\n        this(apiClient);\n        this.localVarAuthNames = authNames;\n    }\n    @Override\n    public PreservationActions getAllPreservationActions() throws ApiException {\n        return getListingApiResponse(null, null, null, null, Collections.emptyMap()).getData();\n    }\n    @Override\n    public PreservationActions getPagedListOfPreservationActions(Integer offset, Integer limit) throws ApiException {\n        return getListingApiResponse(null, null, offset, limit, Collections.emptyMap()).getData();\n    }\n    @Override\n    public PreservationActions getPagedListOfPreservationActionsByModifiedDate(String modifiedAfter, String modifiedBefore, Integer offset, Integer limit) throws ApiException {\n        return getListingApiResponse(modifiedAfter, modifiedBefore, offset, limit, Collections.emptyMap()).getData();\n    }\n    @Override\n    public PreservationActions getPreservationActionsByModifiedDate(String modifiedAfter, String modifiedBefore) throws ApiException {\n        return getListingApiResponse(modifiedAfter, modifiedBefore, null, null, Collections.emptyMap()).getData();\n    }\n    @Override\n    public PreservationActions getPreservationActionsByTools(List<String> toolIds, String modifiedAfter, String modifiedBefore, Integer offset, Integer limit) throws ApiException {\n        return getListingApiResponse(modifiedAfter, modifiedBefore, offset, limit, getToolsFilterHeader(toolIds)).getData();\n    }\n    @Override\n    public PreservationActions getPreservationActionsByTypes(List<String> preservationActionTypeIds, String modifiedAfter, String modifiedBefore, Integer offset, Integer limit) throws ApiException {\n        return getListingApiResponse(modifiedAfter, modifiedBefore, offset, limit, getTypesFilterHeader(preservationActionTypeIds)).getData();\n    }\n    @Override\n    public PreservationActions getPreservationActionsByToolsAndTypes(List<String> toolIds, List<String> preservationActionTypeIds, String modifiedAfter, String modifiedBefore, Integer offset, Integer limit) throws ApiException {\n        Map<String, String> headers = getToolsFilterHeader(toolIds);\n        headers.putAll(getTypesFilterHeader(preservationActionTypeIds));\n        return getListingApiResponse(modifiedAfter, modifiedBefore, offset, limit, headers).getData();\n    }\n    @Override\n    public void getPreservationActionsAsync(List<String> toolIds, List<String> preservationActionTypeIds, String modifiedAfter, String modifiedBefore, ApiCallback<PreservationActions> callback) throws ApiException {\n        Map<String, String> headers = getToolsFilterHeader(toolIds);\n        headers.putAll(getTypesFilterHeader(preservationActionTypeIds));\n        getListingAsync(null, modifiedAfter, modifiedBefore, headers, callback);\n    }\n    @Override\n    public PreservationAction getPreservationActionById(String id) throws ApiException {\n        return getEntity(id, null).getData();\n    }\n    @Override\n    public void getPreservationActionByIdAsync(String id, ApiCallback<PreservationAction> callback) throws ApiException {\n        getEntityAsync(id, null, callback);\n    }\n    @Override\n    public PreservationAction updatePreservationAction(String id, PreservationAction data) throws ApiException {\n        return updateEntity(id, data).getData();\n    }\n    @Override\n    public void updatePreservationActionAsync(String id, PreservationAction data, ApiCallback<PreservationAction> callback) throws ApiException {\n        updateEntityAsync(id, data, callback);\n    }\n    @Override\n    public PreservationAction createPreservationAction(PreservationAction data) throws ApiException {\n        return createNewEntity(data).getData();\n    }\n    @Override\n    public void createPreservationActionAsync(PreservationAction data, ApiCallback<PreservationAction> callback) throws ApiException {\n        createNewEntityAsync(data, callback);\n    }\n    // --- Private internal methods\n    private ApiResponse<PreservationActions> getListingApiResponse(String modifiedAfter, String modifiedBefore, Integer offset, Integer limit, Map<String, String> headers) throws ApiException {\n        return getListing(null, modifiedAfter, modifiedBefore, offset, limit, headers);\n    }\n    private Map<String, String> getToolsFilterHeader(List<String> toolIds) {\n        return getFilterHeader(\"tool\", toolIds);\n    }\n    private Map<String, String> getTypesFilterHeader(List<String> preservationActionTypeIds) {\n        return getFilterHeader(\"preservation_action_type\", preservationActionTypeIds);\n    }\n"]]}
{"hexsha": "2978490b2682228ad2280b271b61c1caafa5da52", "ext": "java", "lang": "Java", "content": "public class SiftingAppender extends SiftingAppenderBase\n{\n\n\tpublic SiftingAppender()\n\t{\n\t//    0    0:aload_0         \n\t//    1    1:invokespecial   #9   <Method void SiftingAppenderBase()>\n\t//    2    4:return          \n\t}\n\n\tprotected boolean eventMarksEndOfLife(ILoggingEvent iloggingevent)\n\t{\n\t\tiloggingevent = ((ILoggingEvent) (iloggingevent.getMarker()));\n\t//    0    0:aload_1         \n\t//    1    1:invokeinterface #18  <Method Marker ILoggingEvent.getMarker()>\n\t//    2    6:astore_1        \n\t\tif(iloggingevent == null)\n\t//*   3    7:aload_1         \n\t//*   4    8:ifnonnull       13\n\t\t\treturn false;\n\t//    5   11:iconst_0        \n\t//    6   12:ireturn         \n\t\telse\n\t\t\treturn ((Marker) (iloggingevent)).contains(ClassicConstants.FINALIZE_SESSION_MARKER);\n\t//    7   13:aload_1         \n\t//    8   14:getstatic       #24  <Field Marker ClassicConstants.FINALIZE_SESSION_MARKER>\n\t//    9   17:invokeinterface #30  <Method boolean Marker.contains(Marker)>\n\t//   10   22:ireturn         \n\t}\n\n\tprotected volatile boolean eventMarksEndOfLife(Object obj)\n\t{\n\t\treturn eventMarksEndOfLife((ILoggingEvent)obj);\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:checkcast       #14  <Class ILoggingEvent>\n\t//    3    5:invokevirtual   #33  <Method boolean eventMarksEndOfLife(ILoggingEvent)>\n\t//    4    8:ireturn         \n\t}\n\n\tprotected long getTimestamp(ILoggingEvent iloggingevent)\n\t{\n\t\treturn iloggingevent.getTimeStamp();\n\t//    0    0:aload_1         \n\t//    1    1:invokeinterface #39  <Method long ILoggingEvent.getTimeStamp()>\n\t//    2    6:lreturn         \n\t}\n\n\tprotected volatile long getTimestamp(Object obj)\n\t{\n\t\treturn getTimestamp((ILoggingEvent)obj);\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:checkcast       #14  <Class ILoggingEvent>\n\t//    3    5:invokevirtual   #42  <Method long getTimestamp(ILoggingEvent)>\n\t//    4    8:lreturn         \n\t}\n\n\tpublic void setDiscriminator(Discriminator discriminator)\n\t{\n\t\tsuper.setDiscriminator(discriminator);\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:invokespecial   #49  <Method void SiftingAppenderBase.setDiscriminator(Discriminator)>\n\t//    3    5:return          \n\t}\n}", "class_id": 0, "repo": "Andreas237/AndroidPolicyAutomation", "file": "ExtractedJars/iRobot_com.irobot.home/javafiles/ch/qos/logback/classic/sift/SiftingAppender.java", "last_update_at": "2019-07-06T22:21:59+00:00", "question_id": "2978490b2682228ad2280b271b61c1caafa5da52", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SiftingAppender extends SiftingAppenderBase\n{\n\tpublic SiftingAppender()\n\t{\n\t//    0    0:aload_0         \n\t//    1    1:invokespecial   #9   <Method void SiftingAppenderBase()>\n\t//    2    4:return          \n\t}\n\tprotected boolean eventMarksEndOfLife(ILoggingEvent iloggingevent)\n\t{\n\t\tiloggingevent = ((ILoggingEvent) (iloggingevent.getMarker()));\n\t//    0    0:aload_1         \n\t//    1    1:invokeinterface #18  <Method Marker ILoggingEvent.getMarker()>\n\t//    2    6:astore_1        \n\t\tif(iloggingevent == null)\n\t//*   3    7:aload_1         \n\t//*   4    8:ifnonnull       13\n\t\t\treturn false;\n\t//    5   11:iconst_0        \n\t//    6   12:ireturn         \n\t\telse\n\t\t\treturn ((Marker) (iloggingevent)).contains(ClassicConstants.FINALIZE_SESSION_MARKER);\n\t//    7   13:aload_1         \n\t//    8   14:getstatic       #24  <Field Marker ClassicConstants.FINALIZE_SESSION_MARKER>\n\t//    9   17:invokeinterface #30  <Method boolean Marker.contains(Marker)>\n\t//   10   22:ireturn         \n\t}\n\tprotected volatile boolean eventMarksEndOfLife(Object obj)\n\t{\n\t\treturn eventMarksEndOfLife((ILoggingEvent)obj);\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:checkcast       #14  <Class ILoggingEvent>\n\t//    3    5:invokevirtual   #33  <Method boolean eventMarksEndOfLife(ILoggingEvent)>\n\t//    4    8:ireturn         \n\t}\n\tprotected long getTimestamp(ILoggingEvent iloggingevent)\n\t{\n\t\treturn iloggingevent.getTimeStamp();\n\t//    0    0:aload_1         \n\t//    1    1:invokeinterface #39  <Method long ILoggingEvent.getTimeStamp()>\n\t//    2    6:lreturn         \n\t}\n\tprotected volatile long getTimestamp(Object obj)\n\t{\n\t\treturn getTimestamp((ILoggingEvent)obj);\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:checkcast       #14  <Class ILoggingEvent>\n\t//    3    5:invokevirtual   #42  <Method long getTimestamp(ILoggingEvent)>\n\t//    4    8:lreturn         \n\t}\n\tpublic void setDiscriminator(Discriminator discriminator)\n\t{\n\t\tsuper.setDiscriminator(discriminator);\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:invokespecial   #49  <Method void SiftingAppenderBase.setDiscriminator(Discriminator)>\n\t//    3    5:return          \n\t}\n"]]}
{"hexsha": "2f2a3a4c61d42bfa8e018fbc184672a21036ac3c", "ext": "java", "lang": "Java", "content": "@JEIPlugin\npublic class SoundMufflerJEIPlugin implements IModPlugin {\n\n    @Override\n    public void register (IModRegistry registry) {\n        Block block = SuperSoundMuffler.blockSoundMuffler;\n        registry.addIngredientInfo(new ItemStack(SuperSoundMuffler.blockSoundMuffler, 1), ItemStack.class,\"jei.\" + block.getUnlocalizedName());\n\n        Item item = SuperSoundMuffler.itemSoundMufflerBauble;\n        registry.addIngredientInfo(new ItemStack(item, 1), ItemStack.class,\"jei.\" + item.getUnlocalizedName());\n    }\n}", "class_id": 0, "repo": "DarkPacks/SuperSoundMuffler", "file": "src/main/java/edgarallen/soundmuffler/compat/jei/SoundMufflerJEIPlugin.java", "last_update_at": "2019-08-27T15:37:19+00:00", "question_id": "2f2a3a4c61d42bfa8e018fbc184672a21036ac3c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@JEIPlugin\npublic class SoundMufflerJEIPlugin implements IModPlugin {\n    @Override\n    public void register (IModRegistry registry) {\n        Block block = SuperSoundMuffler.blockSoundMuffler;\n        registry.addIngredientInfo(new ItemStack(SuperSoundMuffler.blockSoundMuffler, 1), ItemStack.class,\"jei.\" + block.getUnlocalizedName());\n        Item item = SuperSoundMuffler.itemSoundMufflerBauble;\n        registry.addIngredientInfo(new ItemStack(item, 1), ItemStack.class,\"jei.\" + item.getUnlocalizedName());\n    }\n"]]}
{"hexsha": "7cc50de08ccf9388650a986f705d1ff8a054770e", "ext": "java", "lang": "Java", "content": "public class SdkTracker {\n\n    /** Current SDK details - may be null */\n    private volatile SdkProfile sdkProfile;\n\n    /** List of listeners for SDK loaded */\n    private final List<SdkListener> sdkListeners;\n    /** Tracks Target Data Load Status */\n\tprivate TargetLoadStatusMonitor targetLoadStatusMonitor;\n\n\t/**\n\t * Construct SdkTracker object\n\t * @param objectFactory Object factory\n\t */\n    public SdkTracker(AndworxContext objectFactory) {\n\t\tsdkListeners = new ArrayList<>();\n    }\n\n    /**\n     * Returns Information on an Android SDK installation and environment\n     * @return SdkProfile object\n     */\n\tpublic SdkProfile getSdkProfile() {\n\t\treturn sdkProfile;\n\t}\n\n\t/**\n\t * Get SDK details for given SDK location. If valid, update currentSdk field and notify SDK listeners.\n\t * @param sdkLocation SDK file system path\n\t * @return CurrentSdk object for given location\n\t */\n\tpublic SdkProfile setCurrentSdk(String sdkLocation) {\n\t\tSdkProfile trialSdk = new SdkProfile(sdkLocation);\n\t\tif (trialSdk.isValid()) {\n\t\t\tif (targetLoadStatusMonitor != null)\n\t\t\t\ttrialSdk.setTargetLoadStatusMonitor(targetLoadStatusMonitor);\n\t    \t//System.out.println(\"Notifying \" + sdkListeners.size() + \" SDK listeners\");\n\t\t\tsdkProfile = trialSdk;\n\t\t\tsynchronized(sdkListeners) {\n\t\t\t\tsdkListeners.forEach(sdkListener -> sdkListener.onLoadSdk(trialSdk));\n\t\t\t}\n\t\t}\n\t\treturn trialSdk;\n\t}\n\n\t/**\n\t * Adds listener to be notified when a valid SDK is loaded\n\t * @param sdkListener SDK listener\n\t */\n\tpublic void addSdkListener(SdkListener sdkListener) {\n\t\tsynchronized(sdkListeners) {\n\t\t\tsdkListeners.add(sdkListener);\n\t\t\tif (sdkProfile != null)\n\t\t\t\tsdkListener.onLoadSdk(sdkProfile);\n\t\t}\n\t}\n\n\t/**\n\t * Sets Target Data Load Status Monitor\n\t * @param monitor\n\t */\n\tpublic void setTargetLoadStatusMonitor(TargetLoadStatusMonitor monitor) {\n\t\tthis.targetLoadStatusMonitor = monitor;\n\t\tif (sdkProfile != null)\n\t\t\tsdkProfile.setTargetLoadStatusMonitor(monitor);\n\t}\n}", "class_id": 0, "repo": "androidworx/andworx", "file": "android-core/plugins/org.eclipse.andworx.build/src/org/eclipse/andworx/build/SdkTracker.java", "last_update_at": "2019-03-01T14:51:27+00:00", "question_id": "7cc50de08ccf9388650a986f705d1ff8a054770e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SdkTracker {\n    /** Current SDK details - may be null */\n    private volatile SdkProfile sdkProfile;\n    /** List of listeners for SDK loaded */\n    private final List<SdkListener> sdkListeners;\n    /** Tracks Target Data Load Status */\n\tprivate TargetLoadStatusMonitor targetLoadStatusMonitor;\n\t/**\n\t * Construct SdkTracker object\n\t * @param objectFactory Object factory\n\t */\n    public SdkTracker(AndworxContext objectFactory) {\n\t\tsdkListeners = new ArrayList<>();\n    }\n    /**\n     * Returns Information on an Android SDK installation and environment\n     * @return SdkProfile object\n     */\n\tpublic SdkProfile getSdkProfile() {\n\t\treturn sdkProfile;\n\t}\n\t/**\n\t * Get SDK details for given SDK location. If valid, update currentSdk field and notify SDK listeners.\n\t * @param sdkLocation SDK file system path\n\t * @return CurrentSdk object for given location\n\t */\n\tpublic SdkProfile setCurrentSdk(String sdkLocation) {\n\t\tSdkProfile trialSdk = new SdkProfile(sdkLocation);\n\t\tif (trialSdk.isValid()) {\n\t\t\tif (targetLoadStatusMonitor != null)\n\t\t\t\ttrialSdk.setTargetLoadStatusMonitor(targetLoadStatusMonitor);\n\t    \t//System.out.println(\"Notifying \" + sdkListeners.size() + \" SDK listeners\");\n\t\t\tsdkProfile = trialSdk;\n\t\t\tsynchronized(sdkListeners) {\n\t\t\t\tsdkListeners.forEach(sdkListener -> sdkListener.onLoadSdk(trialSdk));\n\t\t\t}\n\t\t}\n\t\treturn trialSdk;\n\t}\n\t/**\n\t * Adds listener to be notified when a valid SDK is loaded\n\t * @param sdkListener SDK listener\n\t */\n\tpublic void addSdkListener(SdkListener sdkListener) {\n\t\tsynchronized(sdkListeners) {\n\t\t\tsdkListeners.add(sdkListener);\n\t\t\tif (sdkProfile != null)\n\t\t\t\tsdkListener.onLoadSdk(sdkProfile);\n\t\t}\n\t}\n\t/**\n\t * Sets Target Data Load Status Monitor\n\t * @param monitor\n\t */\n\tpublic void setTargetLoadStatusMonitor(TargetLoadStatusMonitor monitor) {\n\t\tthis.targetLoadStatusMonitor = monitor;\n\t\tif (sdkProfile != null)\n\t\t\tsdkProfile.setTargetLoadStatusMonitor(monitor);\n\t}\n"]]}
{"hexsha": "67bfb6565f53947daaed60f5a55a436a7b420114", "ext": "java", "lang": "Java", "content": "public class AnnotationEmitter implements SpecialEmitter {\n\n    private static final Map<Class<?>, BiConsumer<JavaEmitterContext, Object>> value_emitters = new HashMap<>();\n\n    static {\n        value_emitters.put(Boolean.class, (ctx, value) -> ctx.printString(String.valueOf(value)));\n        value_emitters.put(Integer.class, (ctx, value) -> ctx.printString(String.valueOf(value)));\n        value_emitters.put(int[].class, (ctx, value) -> {\n            int[] values = (int[]) value;\n            ctx.printString(\"{\");\n            for (int i = 0; i < values.length; i++) {\n                if (i > 0) {\n                    ctx.printString(\", \");\n                }\n                ctx.printString(String.valueOf(values[i]));\n            }\n            ctx.printString(\"}\");\n        });\n        value_emitters.put(ArrayList.class, (ctx, value) -> {\n            List<?> list = (List<?>) value;\n            if (list.isEmpty()) {\n                ctx.printString(\"{}\");\n            } else if (list.size() == 1) {\n                emitValue(ctx, list.get(0));\n            } else {\n                ctx.printString(\"{\");\n                for (int i = 0; i < list.size(); i++) {\n                    if (i != 0) {\n                        ctx.printString(\", \");\n                    }\n                    emitValue(ctx, list.get(i));\n                }\n                ctx.printString(\"}\");\n            }\n        });\n        value_emitters.put(String.class, (ctx, value) -> {\n            ctx.printString(\"\\\"\");\n            ctx.printString(StringConstantEmitter.escape((String) value));\n            ctx.printString(\"\\\"\");\n        });\n        value_emitters.put(String[].class, (ctx, value) -> {\n            String[] values = (String[]) value;\n            ctx.printString(\"{\");\n            for (int i = 0; i < values.length; i++) {\n                if (i > 0) {\n                    ctx.printString(\", \");\n                }\n                ctx.printString(\"\\\"\");\n                ctx.printString(StringConstantEmitter.escape(values[i]));\n                ctx.printString(\"\\\"\");\n            }\n            ctx.printString(\"}\");\n        });\n        value_emitters.put(EnumConstant.class, (ctx, value) -> {\n            EnumConstant e = (EnumConstant) value;\n            ctx.emitType(e.getEnumType());\n            ctx.printString(\".\");\n            ctx.printString(e.getConstantName());\n        });\n        value_emitters.put(ClassTypeSignature.class, (ctx, value) -> ctx.emitTypeName(((ClassTypeSignature) value).getName()));\n    }\n\n    public static void emitValue(JavaEmitterContext ctx, Object value) {\n        BiConsumer<JavaEmitterContext, Object> emitter = value_emitters.get(value.getClass());\n        if (emitter == null) {\n            throw new IllegalStateException(\"Unknown annotation value type in emitter: \" + value.getClass().getName());\n        }\n        emitter.accept(ctx, value);\n    }\n\n    /**\n     * Emits the given annotation.\n     */\n    public void emit(JavaEmitterContext ctx, Annotation annotation) {\n        ctx.printString(\"@\");\n        ctx.emitType(annotation.getType().getName());\n        if (annotation.getKeys().isEmpty()) {\n            return;\n        } else if (annotation.getKeys().size() == 1 && \"value\".equals(annotation.getKeys().iterator().next())) {\n            ctx.printString(\"(\");\n            emitValue(ctx, annotation.getValue(\"value\"));\n            ctx.printString(\" \", ctx.getFormat().insert_space_before_closing_paren_in_annotation);\n            ctx.printString(\")\");\n        } else {\n            ctx.printString(\"(\");\n            boolean first = true;\n            for (String key : annotation.getKeys()) {\n                if (!first) {\n                    ctx.printString(\", \");\n                }\n                first = false;\n                ctx.printString(key);\n                ctx.printString(\" = \");\n                Object value = annotation.getValue(key);\n                emitValue(ctx, value);\n            }\n            ctx.printString(\" \", ctx.getFormat().insert_space_before_closing_paren_in_annotation);\n            ctx.printString(\")\");\n        }\n    }\n\n}", "class_id": 0, "repo": "asLody/Despector", "file": "src/main/java/org/spongepowered/despector/emitter/java/special/AnnotationEmitter.java", "last_update_at": "2019-09-11T03:20:24+00:00", "question_id": "67bfb6565f53947daaed60f5a55a436a7b420114", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AnnotationEmitter implements SpecialEmitter {\n    private static final Map<Class<?>, BiConsumer<JavaEmitterContext, Object>> value_emitters = new HashMap<>();\n    static {\n        value_emitters.put(Boolean.class, (ctx, value) -> ctx.printString(String.valueOf(value)));\n        value_emitters.put(Integer.class, (ctx, value) -> ctx.printString(String.valueOf(value)));\n        value_emitters.put(int[].class, (ctx, value) -> {\n            int[] values = (int[]) value;\n            ctx.printString(\"{\");\n            for (int i = 0; i < values.length; i++) {\n                if (i > 0) {\n                    ctx.printString(\", \");\n                }\n                ctx.printString(String.valueOf(values[i]));\n            }\n            ctx.printString(\"}\");\n        });\n        value_emitters.put(ArrayList.class, (ctx, value) -> {\n            List<?> list = (List<?>) value;\n            if (list.isEmpty()) {\n                ctx.printString(\"{}\");\n            } else if (list.size() == 1) {\n                emitValue(ctx, list.get(0));\n            } else {\n                ctx.printString(\"{\");\n                for (int i = 0; i < list.size(); i++) {\n                    if (i != 0) {\n                        ctx.printString(\", \");\n                    }\n                    emitValue(ctx, list.get(i));\n                }\n                ctx.printString(\"}\");\n            }\n        });\n        value_emitters.put(String.class, (ctx, value) -> {\n            ctx.printString(\"\\\"\");\n            ctx.printString(StringConstantEmitter.escape((String) value));\n            ctx.printString(\"\\\"\");\n        });\n        value_emitters.put(String[].class, (ctx, value) -> {\n            String[] values = (String[]) value;\n            ctx.printString(\"{\");\n            for (int i = 0; i < values.length; i++) {\n                if (i > 0) {\n                    ctx.printString(\", \");\n                }\n                ctx.printString(\"\\\"\");\n                ctx.printString(StringConstantEmitter.escape(values[i]));\n                ctx.printString(\"\\\"\");\n            }\n            ctx.printString(\"}\");\n        });\n        value_emitters.put(EnumConstant.class, (ctx, value) -> {\n            EnumConstant e = (EnumConstant) value;\n            ctx.emitType(e.getEnumType());\n            ctx.printString(\".\");\n            ctx.printString(e.getConstantName());\n        });\n        value_emitters.put(ClassTypeSignature.class, (ctx, value) -> ctx.emitTypeName(((ClassTypeSignature) value).getName()));\n    }\n    public static void emitValue(JavaEmitterContext ctx, Object value) {\n        BiConsumer<JavaEmitterContext, Object> emitter = value_emitters.get(value.getClass());\n        if (emitter == null) {\n            throw new IllegalStateException(\"Unknown annotation value type in emitter: \" + value.getClass().getName());\n        }\n        emitter.accept(ctx, value);\n    }\n    /**\n     * Emits the given annotation.\n     */\n    public void emit(JavaEmitterContext ctx, Annotation annotation) {\n        ctx.printString(\"@\");\n        ctx.emitType(annotation.getType().getName());\n        if (annotation.getKeys().isEmpty()) {\n            return;\n        } else if (annotation.getKeys().size() == 1 && \"value\".equals(annotation.getKeys().iterator().next())) {\n            ctx.printString(\"(\");\n            emitValue(ctx, annotation.getValue(\"value\"));\n            ctx.printString(\" \", ctx.getFormat().insert_space_before_closing_paren_in_annotation);\n            ctx.printString(\")\");\n        } else {\n            ctx.printString(\"(\");\n            boolean first = true;\n            for (String key : annotation.getKeys()) {\n                if (!first) {\n                    ctx.printString(\", \");\n                }\n                first = false;\n                ctx.printString(key);\n                ctx.printString(\" = \");\n                Object value = annotation.getValue(key);\n                emitValue(ctx, value);\n            }\n            ctx.printString(\" \", ctx.getFormat().insert_space_before_closing_paren_in_annotation);\n            ctx.printString(\")\");\n        }\n    }\n"]]}
{"hexsha": "3013abb6c9b614e7b89f05cfb63a130f4c3e56d7", "ext": "java", "lang": "Java", "content": "public class Hud{\r\n\tprivate int vidas;\r\n\tprivate int score;\r\n\tprivate int bombas;\r\n\tpublic static boolean x2;\r\n\t\r\n\tpublic Hud() {\r\n\t\tscore = 0;\r\n\t\tvidas = 3;\r\n\t\tx2 =false;\r\n\t\tbombas = 3;\r\n\t}\r\n\r\n\tpublic void update() {\r\n\t\t\r\n\t}\r\n\tpublic void menosBombas(){\r\n\t\tbombas--;\r\n\t}\r\n\tpublic void masBombas(){\r\n\t\tbombas++;\r\n\t}\r\n\tpublic void setX2(boolean e){\r\n\t\tx2 = e;\r\n\t}\r\n\tpublic void draw(Canvas g2d) {\r\n\t\tdibijarScore(g2d);\r\n\t\tdibijarVidas(g2d);\r\n\t\tdibijarBombas(g2d);\r\n\t}\r\n\tpublic void addScore(int valor){\r\n\t\tif(x2){\r\n\t\t\tscore +=(valor*2);\r\n\t\t}else{\r\n\t\t\tscore +=valor;\r\n\t\t}\r\n\t\t\r\n\t}\r\n\tpublic void addDa\u00f1o(int valor){\r\n\t\tvidas -=valor;\r\n\t}\r\n\tprivate void dibijarVidas(Canvas g){\r\n\t\tVector2D pos = new Vector2D(Constantes.ANCHO-Assets.nave_2.getWidth()-10,40);\r\n\t\tPaint g2 = new Paint();\r\n        g2.setTextSize(60);\r\n        g2.setColor(Color.WHITE);\r\n        g.drawText(vidas+\"X\",Constantes.ANCHO-Assets.bomba.getWidth()-90,+Assets.bomba.getHeight(),g2);\r\n\t\tg.drawBitmap(Assets.nave_2,null,new Rect((int)pos.getX(),(int)pos.getY(),(int)Assets.nave_2.getWidth()+(int)pos.getX(),(int)Assets.nave_2.getHeight()+(int)pos.getY()),g2);\r\n\t\t\r\n\t}\r\n\tprivate void dibijarBombas(Canvas g){\r\n\t\tVector2D pos = new Vector2D(Constantes.ANCHO-Assets.bomba.getWidth()-10,60+Assets.nave_2.getHeight());\r\n\t\tPaint g2 = new Paint();\r\n\t\tg2.setTextSize(60);\r\n\t\tg2.setColor(Color.WHITE);\r\n\t\tg.drawText(bombas+\"X\",Constantes.ANCHO-Assets.bomba.getWidth()-90,20+40+Assets.nave_2.getHeight(),g2);\r\n\t\tg.drawBitmap(Assets.bomba,null,new Rect((int)pos.getX(),(int)pos.getY(),(int)Assets.bomba.getWidth()+(int)pos.getX(),(int)Assets.bomba.getHeight()+(int)pos.getY()),g2);\r\n\t}\r\n\tprivate void dibijarScore(Canvas g){\r\n\t\tPaint g2 = new Paint();\r\n\t\tg2.setTextSize(60);\r\n\t\tg2.setColor(Color.WHITE);\r\n\t\tVector2D pos = new Vector2D(550,25);\r\n\t\tString e = Integer.toString(score);\r\n\r\n\t\tg.drawText(\"PTS=\"+e,50,100,g2);\r\n\t}\r\n\tpublic int getVidas(){\r\n\t\treturn vidas;\r\n\t}\r\n\tpublic int getScore(){\r\n\t\treturn score;\r\n\t}\r\n\tpublic int getSbombas(){\r\n\t\treturn bombas;\r\n\t}\r\n\tpublic void setVidas(){\r\n\t\tvidas++;\r\n\t}\r\n\tpublic void setPts1000(){\r\n\t\tif(x2){\r\n\t\t\tscore +=(5000*2);\r\n\t\t}else{\r\n\t\t\tscore +=5000;\r\n\t\t}\r\n\t}\r\n}", "class_id": 0, "repo": "TheHornios/Asteroids_Movil", "file": "estaeslabuana/objetosJuego/Hud.java", "last_update_at": "2019-05-09T15:29:25+00:00", "question_id": "3013abb6c9b614e7b89f05cfb63a130f4c3e56d7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Hud{\r\n\tprivate int vidas;\r\n\tprivate int score;\r\n\tprivate int bombas;\r\n\tpublic static boolean x2;\r\n\t\r\n\tpublic Hud() {\r\n\t\tscore = 0;\r\n\t\tvidas = 3;\r\n\t\tx2 =false;\r\n\t\tbombas = 3;\r\n\t}\r\n\r\n\tpublic void update() {\r\n\t\t\r\n\t}\r\n\tpublic void menosBombas(){\r\n\t\tbombas--;\r\n\t}\r\n\tpublic void masBombas(){\r\n\t\tbombas++;\r\n\t}\r\n\tpublic void setX2(boolean e){\r\n\t\tx2 = e;\r\n\t}\r\n\tpublic void draw(Canvas g2d) {\r\n\t\tdibijarScore(g2d);\r\n\t\tdibijarVidas(g2d);\r\n\t\tdibijarBombas(g2d);\r\n\t}\r\n\tpublic void addScore(int valor){\r\n\t\tif(x2){\r\n\t\t\tscore +=(valor*2);\r\n\t\t}else{\r\n\t\t\tscore +=valor;\r\n\t\t}\r\n\t\t\r\n\t}\r\n\tpublic void addDa\u00f1o(int valor){\r\n\t\tvidas -=valor;\r\n\t}\r\n\tprivate void dibijarVidas(Canvas g){\r\n\t\tVector2D pos = new Vector2D(Constantes.ANCHO-Assets.nave_2.getWidth()-10,40);\r\n\t\tPaint g2 = new Paint();\r\n        g2.setTextSize(60);\r\n        g2.setColor(Color.WHITE);\r\n        g.drawText(vidas+\"X\",Constantes.ANCHO-Assets.bomba.getWidth()-90,+Assets.bomba.getHeight(),g2);\r\n\t\tg.drawBitmap(Assets.nave_2,null,new Rect((int)pos.getX(),(int)pos.getY(),(int)Assets.nave_2.getWidth()+(int)pos.getX(),(int)Assets.nave_2.getHeight()+(int)pos.getY()),g2);\r\n\t\t\r\n\t}\r\n\tprivate void dibijarBombas(Canvas g){\r\n\t\tVector2D pos = new Vector2D(Constantes.ANCHO-Assets.bomba.getWidth()-10,60+Assets.nave_2.getHeight());\r\n\t\tPaint g2 = new Paint();\r\n\t\tg2.setTextSize(60);\r\n\t\tg2.setColor(Color.WHITE);\r\n\t\tg.drawText(bombas+\"X\",Constantes.ANCHO-Assets.bomba.getWidth()-90,20+40+Assets.nave_2.getHeight(),g2);\r\n\t\tg.drawBitmap(Assets.bomba,null,new Rect((int)pos.getX(),(int)pos.getY(),(int)Assets.bomba.getWidth()+(int)pos.getX(),(int)Assets.bomba.getHeight()+(int)pos.getY()),g2);\r\n\t}\r\n\tprivate void dibijarScore(Canvas g){\r\n\t\tPaint g2 = new Paint();\r\n\t\tg2.setTextSize(60);\r\n\t\tg2.setColor(Color.WHITE);\r\n\t\tVector2D pos = new Vector2D(550,25);\r\n\t\tString e = Integer.toString(score);\r\n\r\n\t\tg.drawText(\"PTS=\"+e,50,100,g2);\r\n\t}\r\n\tpublic int getVidas(){\r\n\t\treturn vidas;\r\n\t}\r\n\tpublic int getScore(){\r\n\t\treturn score;\r\n\t}\r\n\tpublic int getSbombas(){\r\n\t\treturn bombas;\r\n\t}\r\n\tpublic void setVidas(){\r\n\t\tvidas++;\r\n\t}\r\n\tpublic void setPts1000(){\r\n\t\tif(x2){\r\n\t\t\tscore +=(5000*2);\r\n\t\t}else{\r\n\t\t\tscore +=5000;\r\n\t\t}\r\n\t}\r\n"]]}
{"hexsha": "da1f15ab787bcfb841ad8898bfdd68ad26ab20ba", "ext": "java", "lang": "Java", "content": "public class GitRepositoryManagerImpl extends AbstractProjectComponent implements Disposable, GitRepositoryManager, VcsListener {\n\n  private static final Logger LOG = Logger.getInstance(GitRepositoryManager.class);\n\n  @NotNull private final AbstractVcs myVcs;\n  @NotNull private final ProjectLevelVcsManager myVcsManager;\n\n  @NotNull private final Map<VirtualFile, GitRepository> myRepositories = new HashMap<VirtualFile, GitRepository>();\n\n  @NotNull private final ReentrantReadWriteLock REPO_LOCK = new ReentrantReadWriteLock();\n  @NotNull private final GitPlatformFacade myPlatformFacade;\n\n  public GitRepositoryManagerImpl(@NotNull Project project, @NotNull GitPlatformFacade platformFacade) {\n    super(project);\n    myPlatformFacade = platformFacade;\n    myVcsManager = ProjectLevelVcsManager.getInstance(myProject);\n    myVcs = platformFacade.getVcs(myProject);\n  }\n\n  @Override\n  public void initComponent() {\n    Disposer.register(myProject, this);\n    myProject.getMessageBus().connect().subscribe(ProjectLevelVcsManager.VCS_CONFIGURATION_CHANGED, this);\n    GitRootScanner rootScanner = new GitRootScanner(myProject);\n    Disposer.register(this, rootScanner);\n  }\n\n  @Override\n  public void dispose() {\n    try {\n      REPO_LOCK.writeLock().lock();\n      myRepositories.clear();\n    }\n    finally {\n      REPO_LOCK.writeLock().unlock();\n    }\n  }\n\n  @Override\n  public void directoryMappingChanged() {\n    updateRepositoriesCollection();\n  }\n\n  @Override\n  @Nullable\n  public GitRepository getRepositoryForRoot(@Nullable VirtualFile root) {\n    if (root == null) {\n      return null;\n    }\n    try {\n      REPO_LOCK.readLock().lock();\n      return myRepositories.get(root);\n    }\n    finally {\n      REPO_LOCK.readLock().unlock();\n    }\n  }\n\n  @Override\n  @Nullable\n  public GitRepository getRepositoryForFile(@NotNull VirtualFile file) {\n    final VcsRoot vcsRoot = myVcsManager.getVcsRootObjectFor(file);\n    return getRepositoryForVcsRoot(vcsRoot, file.getPath());\n  }\n\n  @Override\n  public GitRepository getRepositoryForFile(@NotNull FilePath file) {\n    final VcsRoot vcsRoot = myVcsManager.getVcsRootObjectFor(file);\n    return getRepositoryForVcsRoot(vcsRoot, file.getPath());\n  }\n\n  @Nullable\n  private GitRepository getRepositoryForVcsRoot(VcsRoot vcsRoot, String filePath) {\n    if (vcsRoot == null) {\n      return null;\n    }\n    final AbstractVcs vcs = vcsRoot.getVcs();\n    if (!myVcs.equals(vcs)) {\n      if (vcs != null) {\n        // if null, the file is just not under version control, nothing interesting;\n        // otherwise log, because Git method is requested not for a Git-controlled file\n        LOG.info(String.format(\"getRepositoryForFile returned non-Git (%s) root for file %s\", vcs.getDisplayName(), filePath));\n      }\n      return null;\n    }\n    return getRepositoryForRoot(vcsRoot.getPath());\n  }\n\n  @Override\n  @NotNull\n  public List<GitRepository> getRepositories() {\n    try {\n      REPO_LOCK.readLock().lock();\n      return GitUtil.sortRepositories(myRepositories.values());\n    }\n    finally {\n      REPO_LOCK.readLock().unlock();\n    }\n  }\n\n  @Override\n  public boolean moreThanOneRoot() {\n    return myRepositories.size() > 1;\n  }\n\n  @Override\n  public void updateRepository(VirtualFile root) {\n    GitRepository repo = getRepositoryForRoot(root);\n    if (repo != null) {\n      repo.update();\n    }\n  }\n\n  @Override\n  public void updateAllRepositories() {\n    Map<VirtualFile, GitRepository> repositories;\n    try {\n      REPO_LOCK.readLock().lock();\n      repositories = new HashMap<VirtualFile, GitRepository>(myRepositories);\n    }\n    finally {\n      REPO_LOCK.readLock().unlock();\n    }\n\n    for (VirtualFile root : repositories.keySet()) {\n      updateRepository(root);\n    }\n  }\n\n  // note: we are not calling this method during the project startup - it is called anyway by the GitRootTracker\n  private void updateRepositoriesCollection() {\n    Map<VirtualFile, GitRepository> repositories;\n    try {\n      REPO_LOCK.readLock().lock();\n      repositories = new HashMap<VirtualFile, GitRepository>(myRepositories);\n    }\n    finally {\n      REPO_LOCK.readLock().unlock();\n    }\n\n    final VirtualFile[] roots = myVcsManager.getRootsUnderVcs(myVcs);\n      // remove repositories that are not in the roots anymore\n      for (Iterator<Map.Entry<VirtualFile, GitRepository>> iterator = repositories.entrySet().iterator(); iterator.hasNext(); ) {\n        if (!ArrayUtil.contains(iterator.next().getValue().getRoot(), roots)) {\n          iterator.remove();\n        }\n      }\n      // add GitRepositories for all roots that don't have correspondent GitRepositories yet.\n      for (VirtualFile root : roots) {\n        if (!repositories.containsKey(root)) {\n          if (gitRootOK(root)) {\n            try {\n              GitRepository repository = createGitRepository(root);\n              repositories.put(root, repository);\n            }\n            catch (GitRepoStateException e) {\n              LOG.error(\"Couldn't initialize GitRepository in \" + root.getPresentableUrl(), e);\n            }\n          }\n          else {\n            LOG.info(\"Invalid Git root: \" + root);\n          }\n        }\n      }\n\n    REPO_LOCK.writeLock().lock();\n    try {\n      myRepositories.clear();\n      myRepositories.putAll(repositories);\n    }\n    finally {\n        REPO_LOCK.writeLock().unlock();\n    }\n  }\n\n  private static boolean gitRootOK(@NotNull VirtualFile root) {\n    VirtualFile gitDir = root.findChild(GitUtil.DOT_GIT);\n    return gitDir != null && gitDir.exists();\n  }\n\n  private GitRepository createGitRepository(VirtualFile root) {\n    return GitRepositoryImpl.getFullInstance(root, myProject, myPlatformFacade, this);\n  }\n\n  @Override\n  public String toString() {\n    return \"GitRepositoryManager{myRepositories: \" + myRepositories + '}';\n  }\n\n}", "class_id": 0, "repo": "dmarcotte/intellij-community", "file": "plugins/git4idea/src/git4idea/repo/GitRepositoryManagerImpl.java", "last_update_at": "2019-03-14T10:35:19+00:00", "question_id": "da1f15ab787bcfb841ad8898bfdd68ad26ab20ba", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GitRepositoryManagerImpl extends AbstractProjectComponent implements Disposable, GitRepositoryManager, VcsListener {\n  private static final Logger LOG = Logger.getInstance(GitRepositoryManager.class);\n  @NotNull private final AbstractVcs myVcs;\n  @NotNull private final ProjectLevelVcsManager myVcsManager;\n  @NotNull private final Map<VirtualFile, GitRepository> myRepositories = new HashMap<VirtualFile, GitRepository>();\n  @NotNull private final ReentrantReadWriteLock REPO_LOCK = new ReentrantReadWriteLock();\n  @NotNull private final GitPlatformFacade myPlatformFacade;\n  public GitRepositoryManagerImpl(@NotNull Project project, @NotNull GitPlatformFacade platformFacade) {\n    super(project);\n    myPlatformFacade = platformFacade;\n    myVcsManager = ProjectLevelVcsManager.getInstance(myProject);\n    myVcs = platformFacade.getVcs(myProject);\n  }\n  @Override\n  public void initComponent() {\n    Disposer.register(myProject, this);\n    myProject.getMessageBus().connect().subscribe(ProjectLevelVcsManager.VCS_CONFIGURATION_CHANGED, this);\n    GitRootScanner rootScanner = new GitRootScanner(myProject);\n    Disposer.register(this, rootScanner);\n  }\n  @Override\n  public void dispose() {\n    try {\n      REPO_LOCK.writeLock().lock();\n      myRepositories.clear();\n    }\n    finally {\n      REPO_LOCK.writeLock().unlock();\n    }\n  }\n  @Override\n  public void directoryMappingChanged() {\n    updateRepositoriesCollection();\n  }\n  @Override\n  @Nullable\n  public GitRepository getRepositoryForRoot(@Nullable VirtualFile root) {\n    if (root == null) {\n      return null;\n    }\n    try {\n      REPO_LOCK.readLock().lock();\n      return myRepositories.get(root);\n    }\n    finally {\n      REPO_LOCK.readLock().unlock();\n    }\n  }\n  @Override\n  @Nullable\n  public GitRepository getRepositoryForFile(@NotNull VirtualFile file) {\n    final VcsRoot vcsRoot = myVcsManager.getVcsRootObjectFor(file);\n    return getRepositoryForVcsRoot(vcsRoot, file.getPath());\n  }\n  @Override\n  public GitRepository getRepositoryForFile(@NotNull FilePath file) {\n    final VcsRoot vcsRoot = myVcsManager.getVcsRootObjectFor(file);\n    return getRepositoryForVcsRoot(vcsRoot, file.getPath());\n  }\n  @Nullable\n  private GitRepository getRepositoryForVcsRoot(VcsRoot vcsRoot, String filePath) {\n    if (vcsRoot == null) {\n      return null;\n    }\n    final AbstractVcs vcs = vcsRoot.getVcs();\n    if (!myVcs.equals(vcs)) {\n      if (vcs != null) {\n        // if null, the file is just not under version control, nothing interesting;\n        // otherwise log, because Git method is requested not for a Git-controlled file\n        LOG.info(String.format(\"getRepositoryForFile returned non-Git (%s) root for file %s\", vcs.getDisplayName(), filePath));\n      }\n      return null;\n    }\n    return getRepositoryForRoot(vcsRoot.getPath());\n  }\n  @Override\n  @NotNull\n  public List<GitRepository> getRepositories() {\n    try {\n      REPO_LOCK.readLock().lock();\n      return GitUtil.sortRepositories(myRepositories.values());\n    }\n    finally {\n      REPO_LOCK.readLock().unlock();\n    }\n  }\n  @Override\n  public boolean moreThanOneRoot() {\n    return myRepositories.size() > 1;\n  }\n  @Override\n  public void updateRepository(VirtualFile root) {\n    GitRepository repo = getRepositoryForRoot(root);\n    if (repo != null) {\n      repo.update();\n    }\n  }\n  @Override\n  public void updateAllRepositories() {\n    Map<VirtualFile, GitRepository> repositories;\n    try {\n      REPO_LOCK.readLock().lock();\n      repositories = new HashMap<VirtualFile, GitRepository>(myRepositories);\n    }\n    finally {\n      REPO_LOCK.readLock().unlock();\n    }\n    for (VirtualFile root : repositories.keySet()) {\n      updateRepository(root);\n    }\n  }\n  // note: we are not calling this method during the project startup - it is called anyway by the GitRootTracker\n  private void updateRepositoriesCollection() {\n    Map<VirtualFile, GitRepository> repositories;\n    try {\n      REPO_LOCK.readLock().lock();\n      repositories = new HashMap<VirtualFile, GitRepository>(myRepositories);\n    }\n    finally {\n      REPO_LOCK.readLock().unlock();\n    }\n    final VirtualFile[] roots = myVcsManager.getRootsUnderVcs(myVcs);\n      // remove repositories that are not in the roots anymore\n      for (Iterator<Map.Entry<VirtualFile, GitRepository>> iterator = repositories.entrySet().iterator(); iterator.hasNext(); ) {\n        if (!ArrayUtil.contains(iterator.next().getValue().getRoot(), roots)) {\n          iterator.remove();\n        }\n      }\n      // add GitRepositories for all roots that don't have correspondent GitRepositories yet.\n      for (VirtualFile root : roots) {\n        if (!repositories.containsKey(root)) {\n          if (gitRootOK(root)) {\n            try {\n              GitRepository repository = createGitRepository(root);\n              repositories.put(root, repository);\n            }\n            catch (GitRepoStateException e) {\n              LOG.error(\"Couldn't initialize GitRepository in \" + root.getPresentableUrl(), e);\n            }\n          }\n          else {\n            LOG.info(\"Invalid Git root: \" + root);\n          }\n        }\n      }\n    REPO_LOCK.writeLock().lock();\n    try {\n      myRepositories.clear();\n      myRepositories.putAll(repositories);\n    }\n    finally {\n        REPO_LOCK.writeLock().unlock();\n    }\n  }\n  private static boolean gitRootOK(@NotNull VirtualFile root) {\n    VirtualFile gitDir = root.findChild(GitUtil.DOT_GIT);\n    return gitDir != null && gitDir.exists();\n  }\n  private GitRepository createGitRepository(VirtualFile root) {\n    return GitRepositoryImpl.getFullInstance(root, myProject, myPlatformFacade, this);\n  }\n  @Override\n  public String toString() {\n    return \"GitRepositoryManager{myRepositories: \" + myRepositories + '}';\n  }\n"]]}
{"hexsha": "ba4e8f72acb5a5fafb85f587d9a06ca9e8ed9f6d", "ext": "java", "lang": "Java", "content": "@PrepareForTest(FilesUtils.class)\npublic class PXConfigurationTest extends PowerMockTestCase {\n    @Test\n    public void testMergeConfigurations() throws FileNotFoundException {\n        PXConfiguration pxConfiguration = PXConfiguration.builder()\n                .appId(\"appId\")\n                .cookieKey(\"cookieKey\")\n                .authToken(\"authToken\")\n                .sensitiveRoutes(new HashSet<>(Arrays.asList(\"/profile\")))\n                .moduleMode(ModuleMode.BLOCKING)\n                .remoteConfigurationEnabled(false)\n                .validateRequestQueueInterval(1000 * 100)\n                .bypassMonitorHeader(\"X-PX-BYPASS-MONITOR\")\n                .configFilePath(\"config.json\")\n                .build();\n        PowerMock.mockStaticPartial(FilesUtils.class, \"readFile\");\n        EasyMock.expect(FilesUtils.readFile(\"config.json\")).andReturn(\"{\\n\" +\n                \"  \\\"px_module_mode\\\": 0,\\n\" +\n                \"  \\\"px_remote_configuration_interval_ms\\\": 1\\n\" +\n                \"}\\n\").times(2);\n        PowerMock.replayAll();\n        pxConfiguration.mergeConfigurations();\n        Assert.assertEquals(pxConfiguration.getModuleMode(), ModuleMode.MONITOR);\n        Assert.assertEquals(pxConfiguration.getRemoteConfigurationInterval(), 1);\n    }\n}", "class_id": 0, "repo": "or-shachar/perimeterx-java-sdk", "file": "src/test/java/com/perimeterx/models/PXConfigurationTest.java", "last_update_at": "2019-10-22T13:27:10+00:00", "question_id": "ba4e8f72acb5a5fafb85f587d9a06ca9e8ed9f6d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@PrepareForTest(FilesUtils.class)\npublic class PXConfigurationTest extends PowerMockTestCase {\n    @Test\n    public void testMergeConfigurations() throws FileNotFoundException {\n        PXConfiguration pxConfiguration = PXConfiguration.builder()\n                .appId(\"appId\")\n                .cookieKey(\"cookieKey\")\n                .authToken(\"authToken\")\n                .sensitiveRoutes(new HashSet<>(Arrays.asList(\"/profile\")))\n                .moduleMode(ModuleMode.BLOCKING)\n                .remoteConfigurationEnabled(false)\n                .validateRequestQueueInterval(1000 * 100)\n                .bypassMonitorHeader(\"X-PX-BYPASS-MONITOR\")\n                .configFilePath(\"config.json\")\n                .build();\n        PowerMock.mockStaticPartial(FilesUtils.class, \"readFile\");\n        EasyMock.expect(FilesUtils.readFile(\"config.json\")).andReturn(\"{\\n\" +\n                \"  \\\"px_module_mode\\\": 0,\\n\" +\n                \"  \\\"px_remote_configuration_interval_ms\\\": 1\\n\" +\n                \"}\\n\").times(2);\n        PowerMock.replayAll();\n        pxConfiguration.mergeConfigurations();\n        Assert.assertEquals(pxConfiguration.getModuleMode(), ModuleMode.MONITOR);\n        Assert.assertEquals(pxConfiguration.getRemoteConfigurationInterval(), 1);\n    }\n"]]}
{"hexsha": "e103f7081c1393af45c4372fcadfd297eff78a10", "ext": "java", "lang": "Java", "content": "public class tmtrafficpolicy_stats extends base_resource\n{\n\tprivate String name;\n\tprivate String clearstats;\n\tprivate Long pipolicyhits;\n\tprivate Long pipolicyhitsrate;\n\n\t/**\n\t* <pre>\n\t* The name of the TM traffic policy for which statistics will be displayed.  If not given statistics are shown for all policies.\n\t* </pre>\n\t*/\n\tpublic void set_name(String name) throws Exception{\n\t\tthis.name = name;\n\t}\n\n\t/**\n\t* <pre>\n\t* The name of the TM traffic policy for which statistics will be displayed.  If not given statistics are shown for all policies.<br> Minimum length =  1\n\t* </pre>\n\t*/\n\tpublic String get_name() throws Exception {\n\t\treturn this.name;\n\t}\n\n\t/**\n\t* <pre>\n\t* Clear the statsistics / counters\n\t* </pre>\n\t*/\n\tpublic void set_clearstats(String clearstats) throws Exception{\n\t\tthis.clearstats = clearstats;\n\t}\n\n\t/**\n\t* <pre>\n\t* Clear the statsistics / counters.<br> Possible values = basic, full\n\t* </pre>\n\t*/\n\tpublic String get_clearstats() throws Exception {\n\t\treturn this.clearstats;\n\t}\n\n\t/**\n\t* <pre>\n\t* Rate (/s) counter for pipolicyhits\n\t* </pre>\n\t*/\n\tpublic Long get_pipolicyhitsrate() throws Exception {\n\t\treturn this.pipolicyhitsrate;\n\t}\n\n\t/**\n\t* <pre>\n\t* Number of hits on the policy\n\t* </pre>\n\t*/\n\tpublic Long get_pipolicyhits() throws Exception {\n\t\treturn this.pipolicyhits;\n\t}\n\n\t/**\n\t* <pre>\n\t* converts nitro response into object and returns the object array in case of get request.\n\t* </pre>\n\t*/\n\tprotected base_resource[] get_nitro_response(nitro_service service, String response) throws Exception{\n\t\ttmtrafficpolicy_response result = (tmtrafficpolicy_response) service.get_payload_formatter().string_to_resource(tmtrafficpolicy_response.class, response);\n\t\tif(result.errorcode != 0) {\n\t\t\tif (result.errorcode == 444) {\n\t\t\t\tservice.clear_session();\n\t\t\t}\n\t\t\tif(result.severity != null)\n\t\t\t{\n\t\t\t\tif (result.severity.equals(\"ERROR\"))\n\t\t\t\t\tthrow new nitro_exception(result.message,result.errorcode);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new nitro_exception(result.message,result.errorcode);\n\t\t\t}\n\t\t}\n\t\treturn result.tmtrafficpolicy;\n\t}\n\n\t/**\n\t* <pre>\n\t* Returns the value of object identifier argument\n\t* </pre>\n\t*/\n\n\tprotected String get_object_name() {\n\t\treturn this.name;\n\t}\n\n\t/**\n\t* Use this API to fetch the statistics of all tmtrafficpolicy_stats resources that are configured on netscaler.\n\t*/\n\tpublic static tmtrafficpolicy_stats[] get(nitro_service service) throws Exception{\n\t\ttmtrafficpolicy_stats obj = new tmtrafficpolicy_stats();\n\t\ttmtrafficpolicy_stats[] response = (tmtrafficpolicy_stats[])obj.stat_resources(service);\n\t\treturn response;\n\t}\n\n\t/**\n\t* Use this API to fetch the statistics of all tmtrafficpolicy_stats resources that are configured on netscaler.\n\t*/\n\tpublic static tmtrafficpolicy_stats[] get(nitro_service service, options option) throws Exception{\n\t\ttmtrafficpolicy_stats obj = new tmtrafficpolicy_stats();\n\t\ttmtrafficpolicy_stats[] response = (tmtrafficpolicy_stats[])obj.stat_resources(service,option);\n\t\treturn response;\n\t}\n\n\t/**\n\t* Use this API to fetch statistics of tmtrafficpolicy_stats resource of given name .\n\t*/\n\tpublic static tmtrafficpolicy_stats get(nitro_service service, String name) throws Exception{\n\t\ttmtrafficpolicy_stats obj = new tmtrafficpolicy_stats();\n\t\tobj.set_name(name);\n\t\ttmtrafficpolicy_stats response = (tmtrafficpolicy_stats) obj.stat_resource(service);\n\t\treturn response;\n\t}\n\n\tpublic static class clearstatsEnum {\n\t\tpublic static final String basic = \"basic\";\n\t\tpublic static final String full = \"full\";\n\t}\n}", "class_id": 0, "repo": "netscaler/nitro", "file": "src/main/java/com/citrix/netscaler/nitro/resource/stat/tm/tmtrafficpolicy_stats.java", "last_update_at": "2019-11-03T18:43:43+00:00", "question_id": "e103f7081c1393af45c4372fcadfd297eff78a10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class tmtrafficpolicy_stats extends base_resource\n{\n\tprivate String name;\n\tprivate String clearstats;\n\tprivate Long pipolicyhits;\n\tprivate Long pipolicyhitsrate;\n\t/**\n\t* <pre>\n\t* The name of the TM traffic policy for which statistics will be displayed.  If not given statistics are shown for all policies.\n\t* </pre>\n\t*/\n\tpublic void set_name(String name) throws Exception{\n\t\tthis.name = name;\n\t}\n\t/**\n\t* <pre>\n\t* The name of the TM traffic policy for which statistics will be displayed.  If not given statistics are shown for all policies.<br> Minimum length =  1\n\t* </pre>\n\t*/\n\tpublic String get_name() throws Exception {\n\t\treturn this.name;\n\t}\n\t/**\n\t* <pre>\n\t* Clear the statsistics / counters\n\t* </pre>\n\t*/\n\tpublic void set_clearstats(String clearstats) throws Exception{\n\t\tthis.clearstats = clearstats;\n\t}\n\t/**\n\t* <pre>\n\t* Clear the statsistics / counters.<br> Possible values = basic, full\n\t* </pre>\n\t*/\n\tpublic String get_clearstats() throws Exception {\n\t\treturn this.clearstats;\n\t}\n\t/**\n\t* <pre>\n\t* Rate (/s) counter for pipolicyhits\n\t* </pre>\n\t*/\n\tpublic Long get_pipolicyhitsrate() throws Exception {\n\t\treturn this.pipolicyhitsrate;\n\t}\n\t/**\n\t* <pre>\n\t* Number of hits on the policy\n\t* </pre>\n\t*/\n\tpublic Long get_pipolicyhits() throws Exception {\n\t\treturn this.pipolicyhits;\n\t}\n\t/**\n\t* <pre>\n\t* converts nitro response into object and returns the object array in case of get request.\n\t* </pre>\n\t*/\n\tprotected base_resource[] get_nitro_response(nitro_service service, String response) throws Exception{\n\t\ttmtrafficpolicy_response result = (tmtrafficpolicy_response) service.get_payload_formatter().string_to_resource(tmtrafficpolicy_response.class, response);\n\t\tif(result.errorcode != 0) {\n\t\t\tif (result.errorcode == 444) {\n\t\t\t\tservice.clear_session();\n\t\t\t}\n\t\t\tif(result.severity != null)\n\t\t\t{\n\t\t\t\tif (result.severity.equals(\"ERROR\"))\n\t\t\t\t\tthrow new nitro_exception(result.message,result.errorcode);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new nitro_exception(result.message,result.errorcode);\n\t\t\t}\n\t\t}\n\t\treturn result.tmtrafficpolicy;\n\t}\n\t/**\n\t* <pre>\n\t* Returns the value of object identifier argument\n\t* </pre>\n\t*/\n\tprotected String get_object_name() {\n\t\treturn this.name;\n\t}\n\t/**\n\t* Use this API to fetch the statistics of all tmtrafficpolicy_stats resources that are configured on netscaler.\n\t*/\n\tpublic static tmtrafficpolicy_stats[] get(nitro_service service) throws Exception{\n\t\ttmtrafficpolicy_stats obj = new tmtrafficpolicy_stats();\n\t\ttmtrafficpolicy_stats[] response = (tmtrafficpolicy_stats[])obj.stat_resources(service);\n\t\treturn response;\n\t}\n\t/**\n\t* Use this API to fetch the statistics of all tmtrafficpolicy_stats resources that are configured on netscaler.\n\t*/\n\tpublic static tmtrafficpolicy_stats[] get(nitro_service service, options option) throws Exception{\n\t\ttmtrafficpolicy_stats obj = new tmtrafficpolicy_stats();\n\t\ttmtrafficpolicy_stats[] response = (tmtrafficpolicy_stats[])obj.stat_resources(service,option);\n\t\treturn response;\n\t}\n\t/**\n\t* Use this API to fetch statistics of tmtrafficpolicy_stats resource of given name .\n\t*/\n\tpublic static tmtrafficpolicy_stats get(nitro_service service, String name) throws Exception{\n\t\ttmtrafficpolicy_stats obj = new tmtrafficpolicy_stats();\n\t\tobj.set_name(name);\n\t\ttmtrafficpolicy_stats response = (tmtrafficpolicy_stats) obj.stat_resource(service);\n\t\treturn response;\n\t}\n\tpublic static class clearstatsEnum {\n\t\tpublic static final String basic = \"basic\";\n\t\tpublic static final String full = \"full\";\n\t}\n"]]}
{"hexsha": "7fe132c6686439330c7f049fcce4acbd711581b8", "ext": "java", "lang": "Java", "content": "public class SpringELParser extends AbstractScriptParser {\r\n\r\n    /**\r\n     * # \u53f7\r\n     */\r\n    private static final String POUND = \"#\";\r\n\r\n    /**\r\n     * \u6487\u53f7\r\n     */\r\n    private static final String apostrophe = \"'\";\r\n\r\n    private final ExpressionParser parser = new SpelExpressionParser();\r\n\r\n    private final ConcurrentHashMap<String, Expression> expCache = new ConcurrentHashMap<String, Expression>();\r\n\r\n    private static Method hash = null;\r\n\r\n    private static Method empty = null;\r\n\r\n    static {\r\n        try {\r\n            hash = CacheUtil.class.getDeclaredMethod(\"getUniqueHashStr\", new Class[]{Object.class});\r\n            empty = CacheUtil.class.getDeclaredMethod(\"isEmpty\", new Class[]{Object.class});\r\n        } catch (NoSuchMethodException e) {\r\n            e.printStackTrace();\r\n        } catch (SecurityException e) {\r\n            e.printStackTrace();\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private final ConcurrentHashMap<String, Method> funcs = new ConcurrentHashMap<String, Method>(8);\r\n\r\n    /**\r\n     * @param name   \u65b9\u6cd5\u540d\r\n     * @param method \u65b9\u6cd5\r\n     */\r\n    @Override\r\n    public void addFunction(String name, Method method) {\r\n        funcs.put(name, method);\r\n    }\r\n\r\n    @SuppressWarnings(\"unchecked\")\r\n    @Override\r\n    public <T> T getElValue(String keySpEL, Object target, Object[] arguments, Object retVal, boolean hasRetVal,\r\n                            Class<T> valueType) throws Exception {\r\n        if (valueType.equals(String.class)) {\r\n            // \u5982\u679c\u4e0d\u662f\u8868\u8fbe\u5f0f\uff0c\u76f4\u63a5\u8fd4\u56de\u5b57\u7b26\u4e32\r\n            if (keySpEL.indexOf(POUND) == -1 && keySpEL.indexOf(\"'\") == -1) {\r\n                return (T) keySpEL;\r\n            }\r\n        }\r\n        StandardEvaluationContext context = new StandardEvaluationContext();\r\n\r\n        context.registerFunction(HASH, hash);\r\n        context.registerFunction(EMPTY, empty);\r\n        Iterator<Map.Entry<String, Method>> it = funcs.entrySet().iterator();\r\n        while (it.hasNext()) {\r\n            Map.Entry<String, Method> entry = it.next();\r\n            context.registerFunction(entry.getKey(), entry.getValue());\r\n        }\r\n        context.setVariable(TARGET, target);\r\n        context.setVariable(ARGS, arguments);\r\n        if (hasRetVal) {\r\n            context.setVariable(RET_VAL, retVal);\r\n        }\r\n        Expression expression = expCache.get(keySpEL);\r\n        if (null == expression) {\r\n            expression = parser.parseExpression(keySpEL);\r\n            expCache.put(keySpEL, expression);\r\n        }\r\n        return expression.getValue(context, valueType);\r\n    }\r\n\r\n}", "class_id": 0, "repo": "godricooxx/AutoLoadCache", "file": "src/main/java/com/jarvis/cache/script/SpringELParser.java", "last_update_at": "2019-07-17T15:04:04+00:00", "question_id": "7fe132c6686439330c7f049fcce4acbd711581b8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SpringELParser extends AbstractScriptParser {\r\n\r\n    /**\r\n     * # \u53f7\r\n     */\r\n    private static final String POUND = \"#\";\r\n\r\n    /**\r\n     * \u6487\u53f7\r\n     */\r\n    private static final String apostrophe = \"'\";\r\n\r\n    private final ExpressionParser parser = new SpelExpressionParser();\r\n\r\n    private final ConcurrentHashMap<String, Expression> expCache = new ConcurrentHashMap<String, Expression>();\r\n\r\n    private static Method hash = null;\r\n\r\n    private static Method empty = null;\r\n\r\n    static {\r\n        try {\r\n            hash = CacheUtil.class.getDeclaredMethod(\"getUniqueHashStr\", new Class[]{Object.class});\r\n            empty = CacheUtil.class.getDeclaredMethod(\"isEmpty\", new Class[]{Object.class});\r\n        } catch (NoSuchMethodException e) {\r\n            e.printStackTrace();\r\n        } catch (SecurityException e) {\r\n            e.printStackTrace();\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private final ConcurrentHashMap<String, Method> funcs = new ConcurrentHashMap<String, Method>(8);\r\n\r\n    /**\r\n     * @param name   \u65b9\u6cd5\u540d\r\n     * @param method \u65b9\u6cd5\r\n     */\r\n    @Override\r\n    public void addFunction(String name, Method method) {\r\n        funcs.put(name, method);\r\n    }\r\n\r\n    @SuppressWarnings(\"unchecked\")\r\n    @Override\r\n    public <T> T getElValue(String keySpEL, Object target, Object[] arguments, Object retVal, boolean hasRetVal,\r\n                            Class<T> valueType) throws Exception {\r\n        if (valueType.equals(String.class)) {\r\n            // \u5982\u679c\u4e0d\u662f\u8868\u8fbe\u5f0f\uff0c\u76f4\u63a5\u8fd4\u56de\u5b57\u7b26\u4e32\r\n            if (keySpEL.indexOf(POUND) == -1 && keySpEL.indexOf(\"'\") == -1) {\r\n                return (T) keySpEL;\r\n            }\r\n        }\r\n        StandardEvaluationContext context = new StandardEvaluationContext();\r\n\r\n        context.registerFunction(HASH, hash);\r\n        context.registerFunction(EMPTY, empty);\r\n        Iterator<Map.Entry<String, Method>> it = funcs.entrySet().iterator();\r\n        while (it.hasNext()) {\r\n            Map.Entry<String, Method> entry = it.next();\r\n            context.registerFunction(entry.getKey(), entry.getValue());\r\n        }\r\n        context.setVariable(TARGET, target);\r\n        context.setVariable(ARGS, arguments);\r\n        if (hasRetVal) {\r\n            context.setVariable(RET_VAL, retVal);\r\n        }\r\n        Expression expression = expCache.get(keySpEL);\r\n        if (null == expression) {\r\n            expression = parser.parseExpression(keySpEL);\r\n            expCache.put(keySpEL, expression);\r\n        }\r\n        return expression.getValue(context, valueType);\r\n    }\r\n\r\n"]]}
{"hexsha": "23d45a57d49b97eced4076aa7dcdb4d8b5d08c19", "ext": "java", "lang": "Java", "content": "class dq$1\n\timplements fg$c\n{\n\n\tpublic void a()\n\t{\n\t\tdq.a(a).r();\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #16  <Field dq a>\n\t//    2    4:invokestatic    #23  <Method s dq.a(dq)>\n\t//    3    7:invokeinterface #28  <Method void s.r()>\n\t//    4   12:return          \n\t}\n\n\tfinal dq a;\n\n\tdq$1(dq dq1)\n\t{\n\t\ta = dq1;\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:putfield        #16  <Field dq a>\n\t\tsuper();\n\t//    3    5:aload_0         \n\t//    4    6:invokespecial   #19  <Method void Object()>\n\t//    5    9:return          \n\t}\n}", "class_id": 0, "repo": "Andreas237/AndroidPolicyAutomation", "file": "ExtractedJars/Health_com.huawei.health/javafiles/com/amap/api/mapcore/util/dq$1.java", "last_update_at": "2019-07-06T22:21:59+00:00", "question_id": "23d45a57d49b97eced4076aa7dcdb4d8b5d08c19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class dq$1\n\timplements fg$c\n{\n\tpublic void a()\n\t{\n\t\tdq.a(a).r();\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #16  <Field dq a>\n\t//    2    4:invokestatic    #23  <Method s dq.a(dq)>\n\t//    3    7:invokeinterface #28  <Method void s.r()>\n\t//    4   12:return          \n\t}\n\tfinal dq a;\n\tdq$1(dq dq1)\n\t{\n\t\ta = dq1;\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:putfield        #16  <Field dq a>\n\t\tsuper();\n\t//    3    5:aload_0         \n\t//    4    6:invokespecial   #19  <Method void Object()>\n\t//    5    9:return          \n\t}\n"]]}
{"hexsha": "24a13cc142348668849b4995296030b60c66fedb", "ext": "java", "lang": "Java", "content": "class AkoumHellkiteTriggeredAbility extends TriggeredAbilityImpl {\n\n    private static final String text = \"<i>Landfall</i> &mdash; Whenever a land enters the battlefield under your control, {this} deals 1 damage to any target. \"\n            + \"If that land is a Mountain, Akoum Hellkite deals 2 damage to that permanent or player instead.\";\n\n    public AkoumHellkiteTriggeredAbility() {\n        super(Zone.BATTLEFIELD, new AkoumHellkiteDamageEffect());\n    }\n\n    public AkoumHellkiteTriggeredAbility(final AkoumHellkiteTriggeredAbility ability) {\n        super(ability);\n    }\n\n    @Override\n    public AkoumHellkiteTriggeredAbility copy() {\n        return new AkoumHellkiteTriggeredAbility(this);\n    }\n\n    @Override\n    public boolean checkEventType(GameEvent event, Game game) {\n        return event.getType() == GameEvent.EventType.ENTERS_THE_BATTLEFIELD;\n    }\n\n    @Override\n    public boolean checkTrigger(GameEvent event, Game game) {\n        Permanent permanent = game.getPermanent(event.getTargetId());\n        if (permanent != null\n                && permanent.isLand()\n                && permanent.isControlledBy(getControllerId())) {\n            Permanent sourcePermanent = game.getPermanent(getSourceId());\n            if (sourcePermanent != null) {\n                for (Effect effect : getEffects()) {\n                    if (effect instanceof AkoumHellkiteDamageEffect) {\n                        effect.setTargetPointer(new FixedTarget(permanent, game));\n                    }\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public String getRule() {\n        return text;\n    }\n}", "class_id": 0, "repo": "FateRevoked/mage", "file": "Mage.Sets/src/mage/cards/a/AkoumHellkite.java", "last_update_at": "2019-07-03T07:54:28+00:00", "question_id": "24a13cc142348668849b4995296030b60c66fedb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class AkoumHellkiteTriggeredAbility extends TriggeredAbilityImpl {\n    private static final String text = \"<i>Landfall</i> &mdash; Whenever a land enters the battlefield under your control, {this} deals 1 damage to any target. \"\n            + \"If that land is a Mountain, Akoum Hellkite deals 2 damage to that permanent or player instead.\";\n    public AkoumHellkiteTriggeredAbility() {\n        super(Zone.BATTLEFIELD, new AkoumHellkiteDamageEffect());\n    }\n    public AkoumHellkiteTriggeredAbility(final AkoumHellkiteTriggeredAbility ability) {\n        super(ability);\n    }\n    @Override\n    public AkoumHellkiteTriggeredAbility copy() {\n        return new AkoumHellkiteTriggeredAbility(this);\n    }\n    @Override\n    public boolean checkEventType(GameEvent event, Game game) {\n        return event.getType() == GameEvent.EventType.ENTERS_THE_BATTLEFIELD;\n    }\n    @Override\n    public boolean checkTrigger(GameEvent event, Game game) {\n        Permanent permanent = game.getPermanent(event.getTargetId());\n        if (permanent != null\n                && permanent.isLand()\n                && permanent.isControlledBy(getControllerId())) {\n            Permanent sourcePermanent = game.getPermanent(getSourceId());\n            if (sourcePermanent != null) {\n                for (Effect effect : getEffects()) {\n                    if (effect instanceof AkoumHellkiteDamageEffect) {\n                        effect.setTargetPointer(new FixedTarget(permanent, game));\n                    }\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    @Override\n    public String getRule() {\n        return text;\n    }\n"]]}
{"hexsha": "f6a5fd02ccebe585493b09ae910314f4194d4d02", "ext": "java", "lang": "Java", "content": "public class BaseMessageStoreUnitTests extends\n    BaseMessageStoreContractTests<TestKeyMessage, TestValueMessage> {\n\n  @Override\n  protected TestMessageStore givenASubjectToTest() {\n    return this.givenASubjectToTest(new HashMap<>());\n  }\n\n  @Override\n  protected TestMessageStore givenASubjectToTest(final Map<TestKeyMessage, TestValueMessage> data) {\n    final MapKeyValueStore mapKeyValueStore = new MapKeyValueStore();\n\n    for (final TestKeyMessage key : data.keySet()) {\n      mapKeyValueStore.put(key.toByteArray(), data.get(key).toByteArray());\n    }\n    return new TestMessageStore(mapKeyValueStore, this.testFrameworkRule.getInstance(ExecutionUtils.class),\n        this.testFrameworkRule.getInstance(ProtobufUtils.class));\n  }\n\n  @Override\n  protected TestKeyMessage givenAKey() {\n    return this.testFrameworkRule.getInstance(TestKeyMessage.class);\n  }\n\n  @Override\n  protected TestValueMessage givenAValue() {\n    return this.testFrameworkRule.getInstance(TestValueMessage.class);\n  }\n\n}", "class_id": 0, "repo": "mechjacktv/mechjackbot", "file": "protobuf/src/test/java/tv/mechjack/protobuf/BaseMessageStoreUnitTests.java", "last_update_at": "2019-02-13T02:00:01+00:00", "question_id": "f6a5fd02ccebe585493b09ae910314f4194d4d02", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BaseMessageStoreUnitTests extends\n    BaseMessageStoreContractTests<TestKeyMessage, TestValueMessage> {\n  @Override\n  protected TestMessageStore givenASubjectToTest() {\n    return this.givenASubjectToTest(new HashMap<>());\n  }\n  @Override\n  protected TestMessageStore givenASubjectToTest(final Map<TestKeyMessage, TestValueMessage> data) {\n    final MapKeyValueStore mapKeyValueStore = new MapKeyValueStore();\n    for (final TestKeyMessage key : data.keySet()) {\n      mapKeyValueStore.put(key.toByteArray(), data.get(key).toByteArray());\n    }\n    return new TestMessageStore(mapKeyValueStore, this.testFrameworkRule.getInstance(ExecutionUtils.class),\n        this.testFrameworkRule.getInstance(ProtobufUtils.class));\n  }\n  @Override\n  protected TestKeyMessage givenAKey() {\n    return this.testFrameworkRule.getInstance(TestKeyMessage.class);\n  }\n  @Override\n  protected TestValueMessage givenAValue() {\n    return this.testFrameworkRule.getInstance(TestValueMessage.class);\n  }\n"]]}
{"hexsha": "aa4c3f7f2b4db7166aca700427e9a616d038a789", "ext": "java", "lang": "Java", "content": "public class FilterParser {\n\n\t// TODO @see org.odata4j.expression.ExpressionParser ... ;-)\n\n\tpublic static FilterExpression parse(String filterString) {\n\t\tResult r = nextCriteria(filterString, 0);\n\t\tFilterExpression expression = r.expression;\n\t\twhile (r.position < filterString.length()) {\n\t\t\tr = nextCriteria(filterString, r.position + 1);\n\t\t\texpression = new FilterAndOrExpression(expression, r.expression);\n\t\t}\n\t\treturn expression;\n\t}\n\n\tprivate static Result nextCriteria(String filterString, int fromIndex) {\n\t\tint indexOfNextEqualsSign = filterString.indexOf('=', fromIndex);\n\t\tassertChar(filterString, indexOfNextEqualsSign + 1, '\"');\n\n\t\tString variablePath = filterString.substring(fromIndex, indexOfNextEqualsSign);\n\n\t\tint indexOfNextNonEscapedQuote = filterString.indexOf('\\\"', indexOfNextEqualsSign + 2);\n\t\twhile (filterString.charAt(indexOfNextNonEscapedQuote - 1) == '\\\\') {\n\t\t\tindexOfNextNonEscapedQuote = filterString.indexOf('\\\"', indexOfNextNonEscapedQuote + 1);\n\t\t}\n\n\t\tString literal = filterString.substring(indexOfNextEqualsSign + 2, indexOfNextNonEscapedQuote);\n\t\tliteral = literal.replace(\"\\\\\\\"\", \"\\\"\");\n\n\t\tFilterCriteriaExpression expression = new FilterCriteriaExpression(variablePath, FilterOperator.EQUALS, literal);\n\n\t\tfromIndex = indexOfNextNonEscapedQuote + 1;\n\t\tif (fromIndex < filterString.length()) {\n\t\t\tassertChar(filterString, fromIndex, '+');\n\t\t}\n\n\t\treturn new Result(expression, fromIndex);\n\t}\n\n\tprivate static class Result {\n\t\tFilterCriteriaExpression expression;\n\t\tint position;\n\n\t\tResult(FilterCriteriaExpression expression, int position) {\n\t\t\tthis.expression = expression;\n\t\t\tthis.position = position;\n\t\t}\n\t}\n\n\tprivate static void assertChar(String string, int pos, char expectedCharacter) {\n\t\tchar charAtPos = string.charAt(pos);\n\t\tif (charAtPos != expectedCharacter) {\n\t\t\tthrow new IllegalArgumentException(\"Expected character at position \" + pos + \" to be a '\"\n\t\t\t\t\t+ expectedCharacter + \"' but instead it's a \" + charAtPos);\n\t\t}\n\t}\n\n}", "class_id": 0, "repo": "vorburger/vorburgers-blueprints", "file": "interaction-framework-api/src/main/java/ch/vorburger/blueprint/interactionframework/model/repo/FilterParser.java", "last_update_at": "2019-01-30T05:54:55+00:00", "question_id": "aa4c3f7f2b4db7166aca700427e9a616d038a789", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FilterParser {\n\t// TODO @see org.odata4j.expression.ExpressionParser ... ;-)\n\tpublic static FilterExpression parse(String filterString) {\n\t\tResult r = nextCriteria(filterString, 0);\n\t\tFilterExpression expression = r.expression;\n\t\twhile (r.position < filterString.length()) {\n\t\t\tr = nextCriteria(filterString, r.position + 1);\n\t\t\texpression = new FilterAndOrExpression(expression, r.expression);\n\t\t}\n\t\treturn expression;\n\t}\n\tprivate static Result nextCriteria(String filterString, int fromIndex) {\n\t\tint indexOfNextEqualsSign = filterString.indexOf('=', fromIndex);\n\t\tassertChar(filterString, indexOfNextEqualsSign + 1, '\"');\n\t\tString variablePath = filterString.substring(fromIndex, indexOfNextEqualsSign);\n\t\tint indexOfNextNonEscapedQuote = filterString.indexOf('\\\"', indexOfNextEqualsSign + 2);\n\t\twhile (filterString.charAt(indexOfNextNonEscapedQuote - 1) == '\\\\') {\n\t\t\tindexOfNextNonEscapedQuote = filterString.indexOf('\\\"', indexOfNextNonEscapedQuote + 1);\n\t\t}\n\t\tString literal = filterString.substring(indexOfNextEqualsSign + 2, indexOfNextNonEscapedQuote);\n\t\tliteral = literal.replace(\"\\\\\\\"\", \"\\\"\");\n\t\tFilterCriteriaExpression expression = new FilterCriteriaExpression(variablePath, FilterOperator.EQUALS, literal);\n\t\tfromIndex = indexOfNextNonEscapedQuote + 1;\n\t\tif (fromIndex < filterString.length()) {\n\t\t\tassertChar(filterString, fromIndex, '+');\n\t\t}\n\t\treturn new Result(expression, fromIndex);\n\t}\n\tprivate static class Result {\n\t\tFilterCriteriaExpression expression;\n\t\tint position;\n\t\tResult(FilterCriteriaExpression expression, int position) {\n\t\t\tthis.expression = expression;\n\t\t\tthis.position = position;\n\t\t}\n\t}\n\tprivate static void assertChar(String string, int pos, char expectedCharacter) {\n\t\tchar charAtPos = string.charAt(pos);\n\t\tif (charAtPos != expectedCharacter) {\n\t\t\tthrow new IllegalArgumentException(\"Expected character at position \" + pos + \" to be a '\"\n\t\t\t\t\t+ expectedCharacter + \"' but instead it's a \" + charAtPos);\n\t\t}\n\t}\n"]]}
{"hexsha": "27e4bf1831937dadd8cc6819de7f541347644bec", "ext": "java", "lang": "Java", "content": "public class Verlet extends AbstractODESolver {\r\n  private double[] rate1;       // stores the initial rate\r\n  private double[] rate2;       // used to compute the estimated the acceleration at x(n+1).\r\n  private int rateCounter = -1; // step has not yet been called\r\n\r\n  /**\r\n   * Constructs the velocity Verlet ODESolver for a system of ordinary  differential equations.\r\n   *\r\n   * @param ode the system of differential equations.\r\n   */\r\n  public Verlet(ODE ode) {\r\n    super(ode);\r\n  }\r\n\r\n  /**\r\n   * Initializes the ODE solver.\r\n   *\r\n   * The rate array is allocated.  The number of differential equations is\r\n   * determined by invoking getState().length on the ODE.\r\n   *\r\n   * @param stepSize\r\n   */\r\n  public void initialize(double stepSize) {\r\n    super.initialize(stepSize);\r\n    rate1 = new double[numEqn];\r\n    rate2 = new double[numEqn];\r\n    rateCounter = -1; // step has not yet been called\r\n  }\r\n\r\n  /**\r\n   * Gets the counter that records the number of times the rate has been evaluated during the current step.\r\n   *\r\n   * This method allows a model to improve its performance\r\n   * by enabling the model to determine if this is the first or second time that the rate is being evaluated.\r\n   * The Verlet algorithm first invokes the model's getRate method to update the position and\r\n   * then again to update velocity.  Because the force at the new position is computed the\r\n   * second time that getRate is invoked, a model can improve its performance if it skips the force computation\r\n   * during the first call to getRate.\r\n   *\r\n   * A typical dynamics simulation should comptute the force when rateCounter is one and stores this force\r\n   * for use during the next postion update.\r\n   *\r\n   * The Verlet algorithm will perform correctly (but more slowly) if the\r\n   * force is computed every time that getRate is invoked.\r\n   *\r\n   * @return int  the counter\r\n   */\r\n  public int getRateCounter() {\r\n    return rateCounter;\r\n  }\r\n\r\n  /**\r\n   * Steps (advances) the differential equations by the stepSize.\r\n   *\r\n   * The ODESolver invokes the ODE's getState method to obtain the initial state of the system.\r\n   * The ODESolver advances the solution and copies the new state into the\r\n   * state array at the end of the solution step.\r\n   *\r\n   * @return the step size\r\n   */\r\n  public double step() {\r\n    // state[]: x1, d x1/dt, x2, d x2/dt .... xN, d xN/dt, t\r\n    double[] state = ode.getState();\r\n    if(state.length!=numEqn) {\r\n      initialize(stepSize);\r\n    }\r\n    rateCounter = 0; // getRate has not been called\r\n    ode.getRate(state, rate1); // get the initial rate\r\n    double dt2 = stepSize*stepSize; // the step size squared\r\n    // increment the positions using the velocity and acceleration\r\n    for(int i = 0; i<numEqn-1; i += 2) {\r\n      state[i] += stepSize*rate1[i]+dt2*rate1[i+1]/2;\r\n    }\r\n    rateCounter = 1; // getRate has been called once\r\n    ode.getRate(state, rate2); // rate at the new positions\r\n    rateCounter = 2; // getRate has been called twice\r\n    for(int i = 1; i<numEqn; i += 2) {\r\n      // increment the velocities with the average rate\r\n      state[i] += stepSize*(rate1[i]+rate2[i])/2.0;\r\n    }\r\n    if(numEqn%2==1) {                              // last equation if  we have an odd number of equations\r\n      state[numEqn-1] += stepSize*rate1[numEqn-1]; // usually the independent variable\r\n    }\r\n    return stepSize;\r\n  }\r\n\r\n}", "class_id": 0, "repo": "alkaplan/junior-csx", "file": "workspace_compadre/osp/src/org/opensourcephysics/numerics/Verlet.java", "last_update_at": "2019-10-12T17:44:33+00:00", "question_id": "27e4bf1831937dadd8cc6819de7f541347644bec", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Verlet extends AbstractODESolver {\r\n  private double[] rate1;       // stores the initial rate\r\n  private double[] rate2;       // used to compute the estimated the acceleration at x(n+1).\r\n  private int rateCounter = -1; // step has not yet been called\r\n\r\n  /**\r\n   * Constructs the velocity Verlet ODESolver for a system of ordinary  differential equations.\r\n   *\r\n   * @param ode the system of differential equations.\r\n   */\r\n  public Verlet(ODE ode) {\r\n    super(ode);\r\n  }\r\n\r\n  /**\r\n   * Initializes the ODE solver.\r\n   *\r\n   * The rate array is allocated.  The number of differential equations is\r\n   * determined by invoking getState().length on the ODE.\r\n   *\r\n   * @param stepSize\r\n   */\r\n  public void initialize(double stepSize) {\r\n    super.initialize(stepSize);\r\n    rate1 = new double[numEqn];\r\n    rate2 = new double[numEqn];\r\n    rateCounter = -1; // step has not yet been called\r\n  }\r\n\r\n  /**\r\n   * Gets the counter that records the number of times the rate has been evaluated during the current step.\r\n   *\r\n   * This method allows a model to improve its performance\r\n   * by enabling the model to determine if this is the first or second time that the rate is being evaluated.\r\n   * The Verlet algorithm first invokes the model's getRate method to update the position and\r\n   * then again to update velocity.  Because the force at the new position is computed the\r\n   * second time that getRate is invoked, a model can improve its performance if it skips the force computation\r\n   * during the first call to getRate.\r\n   *\r\n   * A typical dynamics simulation should comptute the force when rateCounter is one and stores this force\r\n   * for use during the next postion update.\r\n   *\r\n   * The Verlet algorithm will perform correctly (but more slowly) if the\r\n   * force is computed every time that getRate is invoked.\r\n   *\r\n   * @return int  the counter\r\n   */\r\n  public int getRateCounter() {\r\n    return rateCounter;\r\n  }\r\n\r\n  /**\r\n   * Steps (advances) the differential equations by the stepSize.\r\n   *\r\n   * The ODESolver invokes the ODE's getState method to obtain the initial state of the system.\r\n   * The ODESolver advances the solution and copies the new state into the\r\n   * state array at the end of the solution step.\r\n   *\r\n   * @return the step size\r\n   */\r\n  public double step() {\r\n    // state[]: x1, d x1/dt, x2, d x2/dt .... xN, d xN/dt, t\r\n    double[] state = ode.getState();\r\n    if(state.length!=numEqn) {\r\n      initialize(stepSize);\r\n    }\r\n    rateCounter = 0; // getRate has not been called\r\n    ode.getRate(state, rate1); // get the initial rate\r\n    double dt2 = stepSize*stepSize; // the step size squared\r\n    // increment the positions using the velocity and acceleration\r\n    for(int i = 0; i<numEqn-1; i += 2) {\r\n      state[i] += stepSize*rate1[i]+dt2*rate1[i+1]/2;\r\n    }\r\n    rateCounter = 1; // getRate has been called once\r\n    ode.getRate(state, rate2); // rate at the new positions\r\n    rateCounter = 2; // getRate has been called twice\r\n    for(int i = 1; i<numEqn; i += 2) {\r\n      // increment the velocities with the average rate\r\n      state[i] += stepSize*(rate1[i]+rate2[i])/2.0;\r\n    }\r\n    if(numEqn%2==1) {                              // last equation if  we have an odd number of equations\r\n      state[numEqn-1] += stepSize*rate1[numEqn-1]; // usually the independent variable\r\n    }\r\n    return stepSize;\r\n  }\r\n\r\n"]]}
{"hexsha": "d9fc71398869941f6126733480bc012d12e97ca3", "ext": "java", "lang": "Java", "content": "public class Productos implements Parcelable {\r\n    private int codigoProducto;\r\n    private String descripcion, urlFoto, tipo;\r\n    private float stock, precio;\r\n\r\n    public Productos(int codigoProducto, String descripcion,String urlFoto,String tipo, float stock, float precio) {\r\n        this.codigoProducto = codigoProducto;\r\n        this.descripcion = descripcion;\r\n        this.stock = stock;\r\n        this.urlFoto=urlFoto;\r\n        this.precio = precio;\r\n        this.tipo=tipo;\r\n    }\r\n    public Productos(String descripcion, float precio, String urlFoto){\r\n        this.descripcion=descripcion;\r\n        this.precio=precio;\r\n        this.urlFoto=urlFoto;\r\n    }\r\n    public Productos(){}\r\n\r\n    protected Productos(Parcel in) {\r\n        codigoProducto = in.readInt();\r\n        descripcion = in.readString();\r\n        urlFoto = in.readString();\r\n        tipo = in.readString();\r\n        stock = in.readFloat();\r\n        precio = in.readFloat();\r\n    }\r\n\r\n    @Override\r\n    public void writeToParcel(Parcel dest, int flags) {\r\n        dest.writeInt(codigoProducto);\r\n        dest.writeString(descripcion);\r\n        dest.writeString(urlFoto);\r\n        dest.writeString(tipo);\r\n        dest.writeFloat(stock);\r\n        dest.writeFloat(precio);\r\n    }\r\n\r\n    @Override\r\n    public int describeContents() {\r\n        return 0;\r\n    }\r\n\r\n    public static final Creator<Productos> CREATOR = new Creator<Productos>() {\r\n        @Override\r\n        public Productos createFromParcel(Parcel in) {\r\n            return new Productos(in);\r\n        }\r\n\r\n        @Override\r\n        public Productos[] newArray(int size) {\r\n            return new Productos[size];\r\n        }\r\n    };\r\n\r\n    public String getUrlFoto() {\r\n        return urlFoto;\r\n    }\r\n\r\n    public void setUrlFoto(String urlFoto) {\r\n        this.urlFoto = urlFoto;\r\n    }\r\n\r\n    public String getTipo() {\r\n        return tipo;\r\n    }\r\n\r\n    public void setTipo(String tipo) {\r\n        this.tipo = tipo;\r\n    }\r\n\r\n    public int getCodigoProducto() {\r\n        return codigoProducto;\r\n    }\r\n\r\n    public void setCodigoProducto(int codigoProducto) {\r\n        this.codigoProducto = codigoProducto;\r\n    }\r\n\r\n    public String getDescripcion() {\r\n        return descripcion;\r\n    }\r\n\r\n    public void setDescripcion(String descripcion) {\r\n        this.descripcion = descripcion;\r\n    }\r\n\r\n    public float getStock() {\r\n        return stock;\r\n    }\r\n\r\n    public void setStock(float stock) {\r\n        this.stock = stock;\r\n    }\r\n\r\n    public float getPrecio() {\r\n        return precio;\r\n    }\r\n\r\n    public void setPrecio(float precio) {\r\n        this.precio = precio;\r\n    }\r\n}", "class_id": 0, "repo": "BurguerDVLPR/ApkRB", "file": "main/java/com/burguer/manrique/restabar/Pojos/Productos.java", "last_update_at": "2019-10-28T15:33:28+00:00", "question_id": "d9fc71398869941f6126733480bc012d12e97ca3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Productos implements Parcelable {\r\n    private int codigoProducto;\r\n    private String descripcion, urlFoto, tipo;\r\n    private float stock, precio;\r\n\r\n    public Productos(int codigoProducto, String descripcion,String urlFoto,String tipo, float stock, float precio) {\r\n        this.codigoProducto = codigoProducto;\r\n        this.descripcion = descripcion;\r\n        this.stock = stock;\r\n        this.urlFoto=urlFoto;\r\n        this.precio = precio;\r\n        this.tipo=tipo;\r\n    }\r\n    public Productos(String descripcion, float precio, String urlFoto){\r\n        this.descripcion=descripcion;\r\n        this.precio=precio;\r\n        this.urlFoto=urlFoto;\r\n    }\r\n    public Productos(){}\r\n\r\n    protected Productos(Parcel in) {\r\n        codigoProducto = in.readInt();\r\n        descripcion = in.readString();\r\n        urlFoto = in.readString();\r\n        tipo = in.readString();\r\n        stock = in.readFloat();\r\n        precio = in.readFloat();\r\n    }\r\n\r\n    @Override\r\n    public void writeToParcel(Parcel dest, int flags) {\r\n        dest.writeInt(codigoProducto);\r\n        dest.writeString(descripcion);\r\n        dest.writeString(urlFoto);\r\n        dest.writeString(tipo);\r\n        dest.writeFloat(stock);\r\n        dest.writeFloat(precio);\r\n    }\r\n\r\n    @Override\r\n    public int describeContents() {\r\n        return 0;\r\n    }\r\n\r\n    public static final Creator<Productos> CREATOR = new Creator<Productos>() {\r\n        @Override\r\n        public Productos createFromParcel(Parcel in) {\r\n            return new Productos(in);\r\n        }\r\n\r\n        @Override\r\n        public Productos[] newArray(int size) {\r\n            return new Productos[size];\r\n        }\r\n    };\r\n\r\n    public String getUrlFoto() {\r\n        return urlFoto;\r\n    }\r\n\r\n    public void setUrlFoto(String urlFoto) {\r\n        this.urlFoto = urlFoto;\r\n    }\r\n\r\n    public String getTipo() {\r\n        return tipo;\r\n    }\r\n\r\n    public void setTipo(String tipo) {\r\n        this.tipo = tipo;\r\n    }\r\n\r\n    public int getCodigoProducto() {\r\n        return codigoProducto;\r\n    }\r\n\r\n    public void setCodigoProducto(int codigoProducto) {\r\n        this.codigoProducto = codigoProducto;\r\n    }\r\n\r\n    public String getDescripcion() {\r\n        return descripcion;\r\n    }\r\n\r\n    public void setDescripcion(String descripcion) {\r\n        this.descripcion = descripcion;\r\n    }\r\n\r\n    public float getStock() {\r\n        return stock;\r\n    }\r\n\r\n    public void setStock(float stock) {\r\n        this.stock = stock;\r\n    }\r\n\r\n    public float getPrecio() {\r\n        return precio;\r\n    }\r\n\r\n    public void setPrecio(float precio) {\r\n        this.precio = precio;\r\n    }\r\n"]]}
{"hexsha": "fa9090ee63a587e637a8749cdb94b5675a06b008", "ext": "java", "lang": "Java", "content": "public class Appointment {\n\n    private final AppointmentPatientId patientId;\n    private final AppointmentDoctorId doctorId;\n    private final AppointmentDate date;\n    private final AppointmentTime time;\n    private final AppointmentStatus appointmentStatus;\n    private Patient patient;\n    private Doctor doctor;\n\n    /**\n     * Constructs a new {@code Appointment}. New appointments default to ACTIVE status.\n     *\n     * @param patientId A valid patientId.\n     * @param doctorId A valid doctorId.\n     * @param date A valid appointment date\n     * @param time A valid appointment time\n     */\n    public Appointment(AppointmentPatientId patientId, AppointmentDoctorId doctorId, AppointmentDate date,\n                       AppointmentTime time) {\n\n        this(patientId, doctorId, date, time, AppointmentStatus.ACTIVE);\n        //checkArgument(isValidAppointment(appointment), MESSAGE_CONSTRAINTS);\n    }\n\n    /**\n     * Constructs an {@code Appointment} with a stated status.\n     *\n     * @param patientId A valid patientId.\n     * @param doctorId A valid doctorId.\n     * @param date A valid appointment date\n     * @param time A valid appointment time\n     */\n    public Appointment(AppointmentPatientId patientId, AppointmentDoctorId doctorId, AppointmentDate date,\n                       AppointmentTime time, AppointmentStatus appointmentStatus) {\n        /**\n         * Every field must be present and not null.\n         */\n        requireAllNonNull(patientId, doctorId, date, time, appointmentStatus);\n        //checkArgument(isValidAppointment(appointment), MESSAGE_CONSTRAINTS);\n        this.patientId = patientId;\n        this.doctorId = doctorId;\n        this.date = date;\n        this.time = time;\n        this.appointmentStatus = appointmentStatus;\n    }\n\n    /**\n     * Returns true if a given string is a valid appointment.\n     */\n    public static boolean isValidAppointment(String test) {\n        return !test.trim().isEmpty();\n    }\n\n    @Override\n    public String toString() {\n        String str = \"\";\n        str += \"Appointment - \";\n        str += \"Patient ID: \" + patientId;\n        str += \" Doctor ID: \" + doctorId;\n        str += \" Date: \" + date;\n        str += \" Time: \" + time;\n        return str;\n    }\n\n    public AppointmentPatientId getPatientId() {\n        return patientId;\n    }\n\n    public AppointmentDoctorId getDoctorId() {\n        return doctorId;\n    }\n\n    public Patient getPatient() {\n        return patient;\n    }\n\n    public void setPatient(Patient patient) {\n        this.patient = patient;\n    }\n\n    public Doctor getDoctor() {\n        return doctor;\n    }\n\n    public void setDoctor(Doctor doctor) {\n        this.doctor = doctor;\n    }\n\n    public AppointmentDate getDate() {\n        return date;\n    }\n\n    public AppointmentTime getTime() {\n        return time;\n    }\n\n    public AppointmentStatus getAppointmentStatus() {\n        return appointmentStatus;\n    }\n\n    public boolean isSameAppointment(Appointment that) {\n        return this.equals(that);\n    }\n\n    /**\n     * Checks if an appointment is in the past compared to system time.\n     *\n     * @return true if the appointment is in the past.\n     */\n    public boolean isPast() {\n        LocalDateTime currentDateTime = LocalDateTime.now();\n        LocalDateTime appointmentDateTime = LocalDateTime.of(date.date, time.time);\n\n        final boolean past = appointmentDateTime.isBefore(currentDateTime);\n        return past;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        // subclasses of this class are equal to the superclass\n        if (o == null || !(o instanceof Appointment)) {\n            return false;\n        }\n\n        Appointment that = (Appointment) o;\n\n        if (!this.doctorId.equals(that.doctorId)) {\n            return false;\n        }\n\n        if (!this.patientId.equals(that.patientId)) {\n            return false;\n        }\n\n        if (!this.date.equals(that.date)) {\n            return false;\n        }\n\n        if (!this.time.equals(that.time)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(patientId, doctorId, date, time);\n    }\n}", "class_id": 0, "repo": "siyingpoof/main", "file": "src/main/java/seedu/address/model/appointment/Appointment.java", "last_update_at": "2019-12-01T08:56:51+00:00", "question_id": "fa9090ee63a587e637a8749cdb94b5675a06b008", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Appointment {\n    private final AppointmentPatientId patientId;\n    private final AppointmentDoctorId doctorId;\n    private final AppointmentDate date;\n    private final AppointmentTime time;\n    private final AppointmentStatus appointmentStatus;\n    private Patient patient;\n    private Doctor doctor;\n    /**\n     * Constructs a new {@code Appointment}. New appointments default to ACTIVE status.\n     *\n     * @param patientId A valid patientId.\n     * @param doctorId A valid doctorId.\n     * @param date A valid appointment date\n     * @param time A valid appointment time\n     */\n    public Appointment(AppointmentPatientId patientId, AppointmentDoctorId doctorId, AppointmentDate date,\n                       AppointmentTime time) {\n        this(patientId, doctorId, date, time, AppointmentStatus.ACTIVE);\n        //checkArgument(isValidAppointment(appointment), MESSAGE_CONSTRAINTS);\n    }\n    /**\n     * Constructs an {@code Appointment} with a stated status.\n     *\n     * @param patientId A valid patientId.\n     * @param doctorId A valid doctorId.\n     * @param date A valid appointment date\n     * @param time A valid appointment time\n     */\n    public Appointment(AppointmentPatientId patientId, AppointmentDoctorId doctorId, AppointmentDate date,\n                       AppointmentTime time, AppointmentStatus appointmentStatus) {\n        /**\n         * Every field must be present and not null.\n         */\n        requireAllNonNull(patientId, doctorId, date, time, appointmentStatus);\n        //checkArgument(isValidAppointment(appointment), MESSAGE_CONSTRAINTS);\n        this.patientId = patientId;\n        this.doctorId = doctorId;\n        this.date = date;\n        this.time = time;\n        this.appointmentStatus = appointmentStatus;\n    }\n    /**\n     * Returns true if a given string is a valid appointment.\n     */\n    public static boolean isValidAppointment(String test) {\n        return !test.trim().isEmpty();\n    }\n    @Override\n    public String toString() {\n        String str = \"\";\n        str += \"Appointment - \";\n        str += \"Patient ID: \" + patientId;\n        str += \" Doctor ID: \" + doctorId;\n        str += \" Date: \" + date;\n        str += \" Time: \" + time;\n        return str;\n    }\n    public AppointmentPatientId getPatientId() {\n        return patientId;\n    }\n    public AppointmentDoctorId getDoctorId() {\n        return doctorId;\n    }\n    public Patient getPatient() {\n        return patient;\n    }\n    public void setPatient(Patient patient) {\n        this.patient = patient;\n    }\n    public Doctor getDoctor() {\n        return doctor;\n    }\n    public void setDoctor(Doctor doctor) {\n        this.doctor = doctor;\n    }\n    public AppointmentDate getDate() {\n        return date;\n    }\n    public AppointmentTime getTime() {\n        return time;\n    }\n    public AppointmentStatus getAppointmentStatus() {\n        return appointmentStatus;\n    }\n    public boolean isSameAppointment(Appointment that) {\n        return this.equals(that);\n    }\n    /**\n     * Checks if an appointment is in the past compared to system time.\n     *\n     * @return true if the appointment is in the past.\n     */\n    public boolean isPast() {\n        LocalDateTime currentDateTime = LocalDateTime.now();\n        LocalDateTime appointmentDateTime = LocalDateTime.of(date.date, time.time);\n        final boolean past = appointmentDateTime.isBefore(currentDateTime);\n        return past;\n    }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        // subclasses of this class are equal to the superclass\n        if (o == null || !(o instanceof Appointment)) {\n            return false;\n        }\n        Appointment that = (Appointment) o;\n        if (!this.doctorId.equals(that.doctorId)) {\n            return false;\n        }\n        if (!this.patientId.equals(that.patientId)) {\n            return false;\n        }\n        if (!this.date.equals(that.date)) {\n            return false;\n        }\n        if (!this.time.equals(that.time)) {\n            return false;\n        }\n        return true;\n    }\n    @Override\n    public int hashCode() {\n        return Objects.hash(patientId, doctorId, date, time);\n    }\n"]]}
{"hexsha": "971e4aee24839ba31704292af155c0849bd77a1c", "ext": "java", "lang": "Java", "content": "public class Solution_96 {\n    public static void main(String[] args) {\n        Solution solution = new Solution_96().new Solution();\n    }\n\n    //leetcode submit region begin(Prohibit modification and deletion)\n    class Solution {\n        public int numTrees(int n) {\n            int[] dp = new int[n + 1];\n            dp[0] = 1;\n            dp[1] = 1;\n\n            // \u628a\u67d0\u4e2a\u6570\u5b57\u5f53\u6210root,\u5219\u5176\u7ec4\u5408\u6570\u4e3a\u5de6\u8fb9\u7684\u53ef\u80fd*\u53f3\u8fb9\u7684\u53ef\u80fd\n            for (int i = 2; i <= n; i++) {\n                for (int j = 1; j <= i; j++) {\n                    dp[i] += dp[j - 1] * dp[i - j];\n                }\n            }\n            return dp[n];\n        }\n    }\n//leetcode submit region end(Prohibit modification and deletion)\n\n}", "class_id": 0, "repo": "db117/example", "file": "leetcode/src/main/java/com/db117/example/leetcode/solution/Solution_96.java", "last_update_at": "2019-07-05T08:31:24+00:00", "question_id": "971e4aee24839ba31704292af155c0849bd77a1c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Solution_96 {\n    public static void main(String[] args) {\n        Solution solution = new Solution_96().new Solution();\n    }\n    //leetcode submit region begin(Prohibit modification and deletion)\n    class Solution {\n        public int numTrees(int n) {\n            int[] dp = new int[n + 1];\n            dp[0] = 1;\n            dp[1] = 1;\n            // \u628a\u67d0\u4e2a\u6570\u5b57\u5f53\u6210root,\u5219\u5176\u7ec4\u5408\u6570\u4e3a\u5de6\u8fb9\u7684\u53ef\u80fd*\u53f3\u8fb9\u7684\u53ef\u80fd\n            for (int i = 2; i <= n; i++) {\n                for (int j = 1; j <= i; j++) {\n                    dp[i] += dp[j - 1] * dp[i - j];\n                }\n            }\n            return dp[n];\n        }\n    }\n//leetcode submit region end(Prohibit modification and deletion)\n"]]}
{"hexsha": "ad614d4ecea52698f884507175c5038688d59d42", "ext": "java", "lang": "Java", "content": "@RunWith(MockitoJUnitRunner.class)\npublic class PodServiceTest {\n\n    @Spy\n    @InjectMocks\n    private PodService spy;\n    @Mock\n    private HostPodDao hostPodDao;\n    @Mock\n    private HostJdbcDao hostJdbcDao;\n\n    @Test\n    public void getAllPodsEnabledFromZoneTest() {\n        List<HostPodVO> hosts = new ArrayList<>();\n        Mockito.doReturn(hosts).when(hostPodDao).listByDataCenterId(Mockito.anyLong());\n\n        List<HostPodVO> result = spy.getAllPodsEnabledFromZone(0l);\n\n        Mockito.verify(hostPodDao).listByDataCenterId(Mockito.anyLong());\n        Assert.assertEquals(hosts, result);\n    }\n\n    @Test\n    public void findPodByIdTest() {\n        HostPodVO host = Mockito.mock(HostPodVO.class);\n        Mockito.doReturn(host).when(hostPodDao).findById(Mockito.anyLong());\n        HostPodVO result = spy.findPodById(0l);\n        Mockito.verify(hostPodDao).findById(Mockito.anyLong());\n        Assert.assertEquals(host, result);\n    }\n\n    @Test\n    public void isThereAnyHostOnPodDeactivatedByOurManagerTestTrue() {\n        executeIsThereAnyHostOnPodDeactivatedByOurManagerTest(true);\n    }\n\n    @Test\n    public void isThereAnyHostOnPodDeactivatedByOurManagerTestFalse() {\n        executeIsThereAnyHostOnPodDeactivatedByOurManagerTest(false);\n    }\n\n    private void executeIsThereAnyHostOnPodDeactivatedByOurManagerTest(boolean expected) {\n        Mockito.doReturn(expected).when(hostJdbcDao).isThereAnyHostOnPodDeactivatedByOurManager(Mockito.anyLong());\n        boolean result = spy.isThereAnyHostOnPodDeactivatedByOurManager(0l);\n        Mockito.verify(hostJdbcDao).isThereAnyHostOnPodDeactivatedByOurManager(Mockito.anyLong());\n        Assert.assertEquals(expected, result);\n    }\n\n}", "class_id": 0, "repo": "Autonomiccs/autonomiccs-platform", "file": "autonomic-plugin-common/src/test/java/br/com/autonomiccs/autonomic/plugin/common/services/PodServiceTest.java", "last_update_at": "2019-08-13T07:57:31+00:00", "question_id": "ad614d4ecea52698f884507175c5038688d59d42", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(MockitoJUnitRunner.class)\npublic class PodServiceTest {\n    @Spy\n    @InjectMocks\n    private PodService spy;\n    @Mock\n    private HostPodDao hostPodDao;\n    @Mock\n    private HostJdbcDao hostJdbcDao;\n    @Test\n    public void getAllPodsEnabledFromZoneTest() {\n        List<HostPodVO> hosts = new ArrayList<>();\n        Mockito.doReturn(hosts).when(hostPodDao).listByDataCenterId(Mockito.anyLong());\n        List<HostPodVO> result = spy.getAllPodsEnabledFromZone(0l);\n        Mockito.verify(hostPodDao).listByDataCenterId(Mockito.anyLong());\n        Assert.assertEquals(hosts, result);\n    }\n    @Test\n    public void findPodByIdTest() {\n        HostPodVO host = Mockito.mock(HostPodVO.class);\n        Mockito.doReturn(host).when(hostPodDao).findById(Mockito.anyLong());\n        HostPodVO result = spy.findPodById(0l);\n        Mockito.verify(hostPodDao).findById(Mockito.anyLong());\n        Assert.assertEquals(host, result);\n    }\n    @Test\n    public void isThereAnyHostOnPodDeactivatedByOurManagerTestTrue() {\n        executeIsThereAnyHostOnPodDeactivatedByOurManagerTest(true);\n    }\n    @Test\n    public void isThereAnyHostOnPodDeactivatedByOurManagerTestFalse() {\n        executeIsThereAnyHostOnPodDeactivatedByOurManagerTest(false);\n    }\n    private void executeIsThereAnyHostOnPodDeactivatedByOurManagerTest(boolean expected) {\n        Mockito.doReturn(expected).when(hostJdbcDao).isThereAnyHostOnPodDeactivatedByOurManager(Mockito.anyLong());\n        boolean result = spy.isThereAnyHostOnPodDeactivatedByOurManager(0l);\n        Mockito.verify(hostJdbcDao).isThereAnyHostOnPodDeactivatedByOurManager(Mockito.anyLong());\n        Assert.assertEquals(expected, result);\n    }\n"]]}
{"hexsha": "21367ad8ce3fdd05aafe4e9a44a618b120aff271", "ext": "java", "lang": "Java", "content": "@DisplayName(\"Separate The Numbers should\")\nclass SeparateNumbersTests {\n\n    @Test\n    @DisplayName(\"make sure input string is not empty\")\n    void makeSureInputStringIsNotEmpty() {\n        final String value = null;\n        assertThrows(IllegalArgumentException.class,\n                () -> SeparateNumbers.separateNumbers(value)\n        );\n\n        String otherValue = \"\";\n        assertThrows(IllegalArgumentException.class,\n                () -> SeparateNumbers.separateNumbers(otherValue)\n        );\n\n        String lastValue = \"abcd\";\n        assertThrows(IllegalArgumentException.class,\n                () -> SeparateNumbers.separateNumbers(lastValue)\n        );\n\n    }\n\n    @Test\n    @DisplayName(\"return YES for 'single-digit' beautiful strings\")\n    void returnYESForSingleDigitBeautifulStrings() {\n        assertEquals(\"YES 1\", SeparateNumbers.separateNumbers(\"1234\"));\n        assertEquals(\"YES 4\", SeparateNumbers.separateNumbers(\"4567\"));\n        assertEquals(\"YES 7\", SeparateNumbers.separateNumbers(\"789\"));\n        assertEquals(\"YES 2\", SeparateNumbers.separateNumbers(\"23456789\"));\n    }\n}", "class_id": 0, "repo": "SolangeUG/hacker-rank", "file": "src/test/java/org/training/java/algorithms/easy/SeparateNumbersTests.java", "last_update_at": "2019-09-01T18:45:33+00:00", "question_id": "21367ad8ce3fdd05aafe4e9a44a618b120aff271", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@DisplayName(\"Separate The Numbers should\")\nclass SeparateNumbersTests {\n    @Test\n    @DisplayName(\"make sure input string is not empty\")\n    void makeSureInputStringIsNotEmpty() {\n        final String value = null;\n        assertThrows(IllegalArgumentException.class,\n                () -> SeparateNumbers.separateNumbers(value)\n        );\n        String otherValue = \"\";\n        assertThrows(IllegalArgumentException.class,\n                () -> SeparateNumbers.separateNumbers(otherValue)\n        );\n        String lastValue = \"abcd\";\n        assertThrows(IllegalArgumentException.class,\n                () -> SeparateNumbers.separateNumbers(lastValue)\n        );\n    }\n    @Test\n    @DisplayName(\"return YES for 'single-digit' beautiful strings\")\n    void returnYESForSingleDigitBeautifulStrings() {\n        assertEquals(\"YES 1\", SeparateNumbers.separateNumbers(\"1234\"));\n        assertEquals(\"YES 4\", SeparateNumbers.separateNumbers(\"4567\"));\n        assertEquals(\"YES 7\", SeparateNumbers.separateNumbers(\"789\"));\n        assertEquals(\"YES 2\", SeparateNumbers.separateNumbers(\"23456789\"));\n    }\n"]]}
{"hexsha": "d15cf8b971881b1679401ff535080476ff4e7230", "ext": "java", "lang": "Java", "content": "@DisplayName(\"`AddDishToOrder` command should be interpreted by `OrderAggregate` and \")\npublic class AddDishToOrderTest extends OrderCommandTest {\n\n    @Override\n    @BeforeEach\n    public void setUp() {\n        super.setUp();\n        final CreateOrder createOrder = createOrderInstance();\n        final Command createOrderCommand = requestFactory.command()\n                                                         .create(createOrder);\n        commandBus.post(createOrderCommand, noOpObserver());\n    }\n\n    @Test\n    @DisplayName(\"produce `DishAddedToOrder` event\")\n    void produceEvent() {\n        final AddDishToOrder addDishToOrder = addDishToOrderInstance();\n\n        final Command addDishToOrderCommand = requestFactory.command()\n                                                            .create(addDishToOrder);\n\n        final DishAddedToOrderSubscriber dishAddedToOrderSubscriber =\n                new DishAddedToOrderSubscriber();\n\n        eventBus.register(dishAddedToOrderSubscriber);\n\n        commandBus.post(addDishToOrderCommand, noOpObserver());\n\n        final DishAddedToOrder event =\n                (DishAddedToOrder) dishAddedToOrderSubscriber.getEventMessage();\n\n        assertEquals(addDishToOrder.getOrderId(), event.getOrderId());\n        assertEquals(addDishToOrder.getDish(), event.getDish());\n    }\n\n    @Test\n    @DisplayName(\"add dish to order\")\n    void addDishToOrder() {\n        final AddDishToOrder addDishToOrder = addDishToOrderInstance();\n\n        final Command addDishToOrderCommand = requestFactory.command()\n                                                            .create(addDishToOrder);\n\n        commandBus.post(addDishToOrderCommand, noOpObserver());\n\n        final Optional<Repository> repositoryOptional = boundedContext.findRepository(Order.class);\n\n        assertTrue(repositoryOptional.isPresent());\n        assertTrue(repositoryOptional.get() instanceof OrderRepository);\n        final OrderRepository orderRepository = (OrderRepository) repositoryOptional.get();\n\n        final Order order = orderRepository.find(ORDER_ID)\n                                           .get()\n                                           .getState();\n\n        assertEquals(ORDER_ACTIVE, order.getStatus());\n        assertEquals(addDishToOrder.getOrderId(), order.getId());\n        assertEquals(addDishToOrder.getDish(), order.getDish(0));\n    }\n\n    @Test\n    @DisplayName(\"throw `DishVendorMismatch` rejection\")\n    void notAddDish() {\n        final AddDishToOrder addDishToOrder = addDishToOrderInstance(ORDER_ID, INVALID_DISH);\n        final DishVendorMismatchSubscriber dishVendorMismatchSubscriber\n                = new DishVendorMismatchSubscriber();\n        final Command addDishToOrderCommand = requestFactory.command()\n                                                            .create(addDishToOrder);\n\n        rejectionBus.register(dishVendorMismatchSubscriber);\n        assertNull(OrderTestEnv.DishVendorMismatchSubscriber.getRejection());\n\n        commandBus.post(addDishToOrderCommand, noOpObserver());\n        assertNotNull(OrderTestEnv.DishVendorMismatchSubscriber.getRejection());\n\n        final Rejections.DishVendorMismatch dishVendorMismatch\n                = OrderTestEnv.DishVendorMismatchSubscriber.getRejection();\n\n        final VendorId expected = INVALID_DISH.getId()\n                                              .getMenuId()\n                                              .getVendorId();\n        final VendorId actualVendorId = dishVendorMismatch.getVendorMismatch()\n                                                  .getActual();\n        final VendorId targetVendorId = dishVendorMismatch.getVendorMismatch()\n                                                  .getTarget();\n\n        assertEquals(expected, actualVendorId);\n        assertEquals(ORDER_ID.getVendorId(), targetVendorId);\n    }\n\n    @Test\n    @DisplayName(\"throw `CannotAddDishToNotActiveOrder` rejection\")\n    void notAddDishToNotActiveOrder() {\n        final AddDishToOrder addDishToOrder = addDishToOrderInstance();\n        final CancelOrder cancelOrder = cancelOrderInstance();\n\n        final CannotAddDishToNotActiveOrderSubscriber rejectionSubscriber\n                = new CannotAddDishToNotActiveOrderSubscriber();\n\n        final Command cancelOrderCommand = requestFactory.command()\n                                                         .create(cancelOrder);\n        final Command addDishToOrderCommand = requestFactory.command()\n                                                            .create(addDishToOrder);\n\n        rejectionBus.register(rejectionSubscriber);\n        assertNull(OrderTestEnv.CannotAddDishToNotActiveOrderSubscriber.getRejection());\n\n        commandBus.post(cancelOrderCommand, noOpObserver());\n        commandBus.post(addDishToOrderCommand, noOpObserver());\n        assertNotNull(OrderTestEnv.CannotAddDishToNotActiveOrderSubscriber.getRejection());\n\n        final Rejections.CannotAddDishToNotActiveOrder rejection\n                = OrderTestEnv.CannotAddDishToNotActiveOrderSubscriber.getRejection();\n        assertEquals(ORDER_ID, rejection.getOrderId());\n        assertEquals(DISH1.getId(), rejection.getDishId());\n    }\n}", "class_id": 0, "repo": "Java-Classes/MealOrder", "file": "api-java/src/test/java/javaclasses/mealorder/c/order/AddDishToOrderTest.java", "last_update_at": "2019-02-21T08:16:18+00:00", "question_id": "d15cf8b971881b1679401ff535080476ff4e7230", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@DisplayName(\"`AddDishToOrder` command should be interpreted by `OrderAggregate` and \")\npublic class AddDishToOrderTest extends OrderCommandTest {\n    @Override\n    @BeforeEach\n    public void setUp() {\n        super.setUp();\n        final CreateOrder createOrder = createOrderInstance();\n        final Command createOrderCommand = requestFactory.command()\n                                                         .create(createOrder);\n        commandBus.post(createOrderCommand, noOpObserver());\n    }\n    @Test\n    @DisplayName(\"produce `DishAddedToOrder` event\")\n    void produceEvent() {\n        final AddDishToOrder addDishToOrder = addDishToOrderInstance();\n        final Command addDishToOrderCommand = requestFactory.command()\n                                                            .create(addDishToOrder);\n        final DishAddedToOrderSubscriber dishAddedToOrderSubscriber =\n                new DishAddedToOrderSubscriber();\n        eventBus.register(dishAddedToOrderSubscriber);\n        commandBus.post(addDishToOrderCommand, noOpObserver());\n        final DishAddedToOrder event =\n                (DishAddedToOrder) dishAddedToOrderSubscriber.getEventMessage();\n        assertEquals(addDishToOrder.getOrderId(), event.getOrderId());\n        assertEquals(addDishToOrder.getDish(), event.getDish());\n    }\n    @Test\n    @DisplayName(\"add dish to order\")\n    void addDishToOrder() {\n        final AddDishToOrder addDishToOrder = addDishToOrderInstance();\n        final Command addDishToOrderCommand = requestFactory.command()\n                                                            .create(addDishToOrder);\n        commandBus.post(addDishToOrderCommand, noOpObserver());\n        final Optional<Repository> repositoryOptional = boundedContext.findRepository(Order.class);\n        assertTrue(repositoryOptional.isPresent());\n        assertTrue(repositoryOptional.get() instanceof OrderRepository);\n        final OrderRepository orderRepository = (OrderRepository) repositoryOptional.get();\n        final Order order = orderRepository.find(ORDER_ID)\n                                           .get()\n                                           .getState();\n        assertEquals(ORDER_ACTIVE, order.getStatus());\n        assertEquals(addDishToOrder.getOrderId(), order.getId());\n        assertEquals(addDishToOrder.getDish(), order.getDish(0));\n    }\n    @Test\n    @DisplayName(\"throw `DishVendorMismatch` rejection\")\n    void notAddDish() {\n        final AddDishToOrder addDishToOrder = addDishToOrderInstance(ORDER_ID, INVALID_DISH);\n        final DishVendorMismatchSubscriber dishVendorMismatchSubscriber\n                = new DishVendorMismatchSubscriber();\n        final Command addDishToOrderCommand = requestFactory.command()\n                                                            .create(addDishToOrder);\n        rejectionBus.register(dishVendorMismatchSubscriber);\n        assertNull(OrderTestEnv.DishVendorMismatchSubscriber.getRejection());\n        commandBus.post(addDishToOrderCommand, noOpObserver());\n        assertNotNull(OrderTestEnv.DishVendorMismatchSubscriber.getRejection());\n        final Rejections.DishVendorMismatch dishVendorMismatch\n                = OrderTestEnv.DishVendorMismatchSubscriber.getRejection();\n        final VendorId expected = INVALID_DISH.getId()\n                                              .getMenuId()\n                                              .getVendorId();\n        final VendorId actualVendorId = dishVendorMismatch.getVendorMismatch()\n                                                  .getActual();\n        final VendorId targetVendorId = dishVendorMismatch.getVendorMismatch()\n                                                  .getTarget();\n        assertEquals(expected, actualVendorId);\n        assertEquals(ORDER_ID.getVendorId(), targetVendorId);\n    }\n    @Test\n    @DisplayName(\"throw `CannotAddDishToNotActiveOrder` rejection\")\n    void notAddDishToNotActiveOrder() {\n        final AddDishToOrder addDishToOrder = addDishToOrderInstance();\n        final CancelOrder cancelOrder = cancelOrderInstance();\n        final CannotAddDishToNotActiveOrderSubscriber rejectionSubscriber\n                = new CannotAddDishToNotActiveOrderSubscriber();\n        final Command cancelOrderCommand = requestFactory.command()\n                                                         .create(cancelOrder);\n        final Command addDishToOrderCommand = requestFactory.command()\n                                                            .create(addDishToOrder);\n        rejectionBus.register(rejectionSubscriber);\n        assertNull(OrderTestEnv.CannotAddDishToNotActiveOrderSubscriber.getRejection());\n        commandBus.post(cancelOrderCommand, noOpObserver());\n        commandBus.post(addDishToOrderCommand, noOpObserver());\n        assertNotNull(OrderTestEnv.CannotAddDishToNotActiveOrderSubscriber.getRejection());\n        final Rejections.CannotAddDishToNotActiveOrder rejection\n                = OrderTestEnv.CannotAddDishToNotActiveOrderSubscriber.getRejection();\n        assertEquals(ORDER_ID, rejection.getOrderId());\n        assertEquals(DISH1.getId(), rejection.getDishId());\n    }\n"]]}
{"hexsha": "2b43cbafa860eff2cd70ed10d0f881387877be35", "ext": "java", "lang": "Java", "content": "final class DefaultMessageUpdate extends AbstractMessageRequest\n    implements MongoMessageUpdate {\n\n  private static final int UPSERT = 0;\n  private static final int MULTI_UPDATE = 1;\n\n  private static final int[][] RESERVED = new int[][] {{2, 31}};\n\n  private String fullCollectionName;\n  private final MongoMessageFlags flags = new DefaultMessageFlags();\n  private BsonDocument selector;\n  private BsonDocument update;\n\n  DefaultMessageUpdate() {\n    super(MongoMessageOpcode.UPDATE);\n  }\n\n  @Override\n  public String fullCollectionName() {\n    return fullCollectionName;\n  }\n\n  @Override\n  public void fullCollectionName(String fullCollectionName) {\n    Preconditions.checkNotNull(fullCollectionName);\n    this.fullCollectionName = fullCollectionName;\n  }\n\n  @Override\n  public BsonDocument selector() {\n    return selector;\n  }\n\n  @Override\n  public void selector(BsonDocument selector) {\n    Preconditions.checkNotNull(selector);\n    this.selector = selector;\n  }\n\n  @Override\n  public BsonDocument update() {\n    return update;\n  }\n\n  @Override\n  public void update(BsonDocument update) {\n    Preconditions.checkNotNull(update);\n    this.update = update;\n  }\n\n  @Override\n  public boolean upsert() {\n    return flags.get(UPSERT);\n  }\n\n  @Override\n  public void upsert(boolean upsert) {\n    flags.set(UPSERT, upsert);\n  }\n\n  @Override\n  public boolean multiUpdate() {\n    return flags.get(MULTI_UPDATE);\n  }\n\n  @Override\n  public void multiUpdate(boolean multiUpdate) {\n    flags.set(MULTI_UPDATE, multiUpdate);\n  }\n\n  @Override\n  protected void writeBodyTo(ByteBuffer buffer) {\n    Preconditions.checkNotNull(buffer);\n\n    for (int[] range : RESERVED)\n      for (int position = range[0]; position <= range[1]; position++)\n        assert !flags.get(position);\n\n    buffer.putInt(0);\n    buffer.put(fullCollectionName.getBytes(Charsets.UTF_8));\n    buffer.put(BsonBytes.EOO);\n    buffer.putInt(flags.mask());\n    BsonDocuments.writeTo(buffer, selector);\n    BsonDocuments.writeTo(buffer, update);\n  }\n}", "class_id": 0, "repo": "kohanyirobert/mongoroid", "file": "src/main/java/com/github/kohanyirobert/mongoroid/DefaultMessageUpdate.java", "last_update_at": "2019-04-23T03:29:09+00:00", "question_id": "2b43cbafa860eff2cd70ed10d0f881387877be35", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["final class DefaultMessageUpdate extends AbstractMessageRequest\n    implements MongoMessageUpdate {\n  private static final int UPSERT = 0;\n  private static final int MULTI_UPDATE = 1;\n  private static final int[][] RESERVED = new int[][] {{2, 31}};\n  private String fullCollectionName;\n  private final MongoMessageFlags flags = new DefaultMessageFlags();\n  private BsonDocument selector;\n  private BsonDocument update;\n  DefaultMessageUpdate() {\n    super(MongoMessageOpcode.UPDATE);\n  }\n  @Override\n  public String fullCollectionName() {\n    return fullCollectionName;\n  }\n  @Override\n  public void fullCollectionName(String fullCollectionName) {\n    Preconditions.checkNotNull(fullCollectionName);\n    this.fullCollectionName = fullCollectionName;\n  }\n  @Override\n  public BsonDocument selector() {\n    return selector;\n  }\n  @Override\n  public void selector(BsonDocument selector) {\n    Preconditions.checkNotNull(selector);\n    this.selector = selector;\n  }\n  @Override\n  public BsonDocument update() {\n    return update;\n  }\n  @Override\n  public void update(BsonDocument update) {\n    Preconditions.checkNotNull(update);\n    this.update = update;\n  }\n  @Override\n  public boolean upsert() {\n    return flags.get(UPSERT);\n  }\n  @Override\n  public void upsert(boolean upsert) {\n    flags.set(UPSERT, upsert);\n  }\n  @Override\n  public boolean multiUpdate() {\n    return flags.get(MULTI_UPDATE);\n  }\n  @Override\n  public void multiUpdate(boolean multiUpdate) {\n    flags.set(MULTI_UPDATE, multiUpdate);\n  }\n  @Override\n  protected void writeBodyTo(ByteBuffer buffer) {\n    Preconditions.checkNotNull(buffer);\n    for (int[] range : RESERVED)\n      for (int position = range[0]; position <= range[1]; position++)\n        assert !flags.get(position);\n    buffer.putInt(0);\n    buffer.put(fullCollectionName.getBytes(Charsets.UTF_8));\n    buffer.put(BsonBytes.EOO);\n    buffer.putInt(flags.mask());\n    BsonDocuments.writeTo(buffer, selector);\n    BsonDocuments.writeTo(buffer, update);\n  }\n"]]}
{"hexsha": "140cb7aeb3f796eeca7cdb3aa0b0ae777dd32e05", "ext": "java", "lang": "Java", "content": "public class TestQueryHelper\n{\n  public static Logger LOG = new Logger(TestQueryHelper.class);\n  private final QueryResourceTestClient queryClient;\n  private final ObjectMapper jsonMapper;\n  private final String broker;\n\n  @Inject\n  TestQueryHelper(\n      ObjectMapper jsonMapper,\n      QueryResourceTestClient queryClient,\n      IntegrationTestingConfig config\n  )\n  {\n    this.jsonMapper = jsonMapper;\n    this.queryClient = queryClient;\n    this.broker = config.getBrokerUrl();\n  }\n\n  public void testQueriesFromFile(String filePath, int timesToRun) throws Exception\n  {\n    testQueriesFromFile(getBrokerURL(), filePath, timesToRun);\n  }\n\n  public void testQueriesFromFile(String url, String filePath, int timesToRun) throws Exception\n  {\n    LOG.info(\"Starting query tests for [%s]\", filePath);\n    List<QueryWithResults> queries =\n        jsonMapper.readValue(\n            TestQueryHelper.class.getResourceAsStream(filePath),\n            new TypeReference<List<QueryWithResults>>()\n            {\n            }\n        );\n    testQueries(url, queries, timesToRun);\n  }\n\n  public void testQueriesFromString(String str, int timesToRun) throws Exception\n  {\n    testQueriesFromString(getBrokerURL(), str, timesToRun);\n  }\n\n  public void testQueriesFromString(String url, String str, int timesToRun) throws Exception\n  {\n    LOG.info(\"Starting query tests using\\n%s\", str);\n    List<QueryWithResults> queries =\n        jsonMapper.readValue(\n            str,\n            new TypeReference<List<QueryWithResults>>()\n            {\n            }\n        );\n    testQueries(url, queries, timesToRun);\n  }\n\n  private void testQueries(String url, List<QueryWithResults> queries, int timesToRun) throws Exception\n  {\n    for (int i = 0; i < timesToRun; i++) {\n      LOG.info(\"Starting Iteration %d\", i);\n\n      boolean failed = false;\n      for (QueryWithResults queryWithResult : queries) {\n        LOG.info(\"Running Query %s\", queryWithResult.getQuery().getType());\n        List<Map<String, Object>> result = queryClient.query(url, queryWithResult.getQuery());\n        if (!QueryResultVerifier.compareResults(result, queryWithResult.getExpectedResults())) {\n          LOG.error(\n              \"Failed while executing query %s \\n expectedResults: %s \\n actualResults : %s\",\n              queryWithResult.getQuery(),\n              jsonMapper.writeValueAsString(queryWithResult.getExpectedResults()),\n              jsonMapper.writeValueAsString(result)\n          );\n          failed = true;\n        } else {\n          LOG.info(\"Results Verified for Query %s\", queryWithResult.getQuery().getType());\n        }\n      }\n\n      if (failed) {\n        throw new ISE(\"one or more queries failed\");\n      }\n    }\n  }\n\n  private String getBrokerURL()\n  {\n    return StringUtils.format(\"%s/druid/v2?pretty\", broker);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public int countRows(String dataSource, String interval)\n  {\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(dataSource)\n                                  .aggregators(\n                                      ImmutableList.<AggregatorFactory>of(\n                                          new LongSumAggregatorFactory(\"rows\", \"count\")\n                                      )\n                                  )\n                                  .granularity(Granularities.ALL)\n                                  .intervals(interval)\n                                  .build();\n\n    List<Map<String, Object>> results = queryClient.query(getBrokerURL(), query);\n    if (results.isEmpty()) {\n      return 0;\n    } else {\n      Map<String, Object> map = (Map<String, Object>) results.get(0).get(\"result\");\n\n      return (Integer) map.get(\"rows\");\n    }\n  }\n}", "class_id": 0, "repo": "rhx-0001/incubator-druid", "file": "integration-tests/src/main/java/io/druid/testing/utils/TestQueryHelper.java", "last_update_at": "2019-05-17T08:44:00+00:00", "question_id": "140cb7aeb3f796eeca7cdb3aa0b0ae777dd32e05", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestQueryHelper\n{\n  public static Logger LOG = new Logger(TestQueryHelper.class);\n  private final QueryResourceTestClient queryClient;\n  private final ObjectMapper jsonMapper;\n  private final String broker;\n  @Inject\n  TestQueryHelper(\n      ObjectMapper jsonMapper,\n      QueryResourceTestClient queryClient,\n      IntegrationTestingConfig config\n  )\n  {\n    this.jsonMapper = jsonMapper;\n    this.queryClient = queryClient;\n    this.broker = config.getBrokerUrl();\n  }\n  public void testQueriesFromFile(String filePath, int timesToRun) throws Exception\n  {\n    testQueriesFromFile(getBrokerURL(), filePath, timesToRun);\n  }\n  public void testQueriesFromFile(String url, String filePath, int timesToRun) throws Exception\n  {\n    LOG.info(\"Starting query tests for [%s]\", filePath);\n    List<QueryWithResults> queries =\n        jsonMapper.readValue(\n            TestQueryHelper.class.getResourceAsStream(filePath),\n            new TypeReference<List<QueryWithResults>>()\n            {\n            }\n        );\n    testQueries(url, queries, timesToRun);\n  }\n  public void testQueriesFromString(String str, int timesToRun) throws Exception\n  {\n    testQueriesFromString(getBrokerURL(), str, timesToRun);\n  }\n  public void testQueriesFromString(String url, String str, int timesToRun) throws Exception\n  {\n    LOG.info(\"Starting query tests using\\n%s\", str);\n    List<QueryWithResults> queries =\n        jsonMapper.readValue(\n            str,\n            new TypeReference<List<QueryWithResults>>()\n            {\n            }\n        );\n    testQueries(url, queries, timesToRun);\n  }\n  private void testQueries(String url, List<QueryWithResults> queries, int timesToRun) throws Exception\n  {\n    for (int i = 0; i < timesToRun; i++) {\n      LOG.info(\"Starting Iteration %d\", i);\n      boolean failed = false;\n      for (QueryWithResults queryWithResult : queries) {\n        LOG.info(\"Running Query %s\", queryWithResult.getQuery().getType());\n        List<Map<String, Object>> result = queryClient.query(url, queryWithResult.getQuery());\n        if (!QueryResultVerifier.compareResults(result, queryWithResult.getExpectedResults())) {\n          LOG.error(\n              \"Failed while executing query %s \\n expectedResults: %s \\n actualResults : %s\",\n              queryWithResult.getQuery(),\n              jsonMapper.writeValueAsString(queryWithResult.getExpectedResults()),\n              jsonMapper.writeValueAsString(result)\n          );\n          failed = true;\n        } else {\n          LOG.info(\"Results Verified for Query %s\", queryWithResult.getQuery().getType());\n        }\n      }\n      if (failed) {\n        throw new ISE(\"one or more queries failed\");\n      }\n    }\n  }\n  private String getBrokerURL()\n  {\n    return StringUtils.format(\"%s/druid/v2?pretty\", broker);\n  }\n  @SuppressWarnings(\"unchecked\")\n  public int countRows(String dataSource, String interval)\n  {\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(dataSource)\n                                  .aggregators(\n                                      ImmutableList.<AggregatorFactory>of(\n                                          new LongSumAggregatorFactory(\"rows\", \"count\")\n                                      )\n                                  )\n                                  .granularity(Granularities.ALL)\n                                  .intervals(interval)\n                                  .build();\n    List<Map<String, Object>> results = queryClient.query(getBrokerURL(), query);\n    if (results.isEmpty()) {\n      return 0;\n    } else {\n      Map<String, Object> map = (Map<String, Object>) results.get(0).get(\"result\");\n      return (Integer) map.get(\"rows\");\n    }\n  }\n"]]}
{"hexsha": "b6a477a06cbb2aa840b6e6dd3130bff948ff74e3", "ext": "java", "lang": "Java", "content": "public class AjpProtocol extends AbstractAjpProtocol {\r\n    \r\n    \r\n    private static final Log log = LogFactory.getLog(AjpProtocol.class);\r\n\r\n    @Override\r\n    protected Log getLog() { return log; }\r\n\r\n\r\n    @Override\r\n    protected AbstractEndpoint.Handler getHandler() {\r\n        return cHandler;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------ Constructor\r\n\r\n\r\n    public AjpProtocol() {\r\n        endpoint = new JIoEndpoint();\r\n        cHandler = new AjpConnectionHandler(this);\r\n        ((JIoEndpoint) endpoint).setHandler(cHandler);\r\n        setSoLinger(Constants.DEFAULT_CONNECTION_LINGER);\r\n        setSoTimeout(Constants.DEFAULT_CONNECTION_TIMEOUT);\r\n        setTcpNoDelay(Constants.DEFAULT_TCP_NO_DELAY);\r\n    }\r\n\r\n    \r\n    // ----------------------------------------------------- Instance Variables\r\n\r\n    \r\n    /**\r\n     * Connection handler for AJP.\r\n     */\r\n    private AjpConnectionHandler cHandler;\r\n\r\n\r\n    // ----------------------------------------------------- JMX related methods\r\n\r\n    @Override\r\n    protected String getNamePrefix() {\r\n        return (\"ajp-bio\");\r\n    }\r\n\r\n\r\n    // --------------------------------------  AjpConnectionHandler Inner Class\r\n\r\n\r\n    protected static class AjpConnectionHandler\r\n            extends AbstractConnectionHandler implements Handler {\r\n\r\n        protected AjpProtocol proto;\r\n\r\n        protected ConcurrentHashMap<SocketWrapper<Socket>, AjpProcessor> connections =\r\n            new ConcurrentHashMap<SocketWrapper<Socket>, AjpProcessor>();\r\n\r\n        protected RecycledProcessors<AjpProcessor> recycledProcessors =\r\n            new RecycledProcessors<AjpProcessor>(this);\r\n\r\n        public AjpConnectionHandler(AjpProtocol proto) {\r\n            this.proto = proto;\r\n        }\r\n        \r\n        @Override\r\n        protected AbstractProtocol getProtocol() {\r\n            return proto;\r\n        }\r\n\r\n        @Override\r\n        protected Log getLog() {\r\n            return log;\r\n        }\r\n\r\n        @Override\r\n        public SSLImplementation getSslImplementation() {\r\n            // AJP does not support SSL\r\n            return null;\r\n        }\r\n\r\n        @Override\r\n        public void recycle() {\r\n            recycledProcessors.clear();\r\n        }\r\n        \r\n        @Override\r\n        public SocketState process(SocketWrapper<Socket> socket) {\r\n            return process(socket,SocketStatus.OPEN);\r\n        }\r\n\r\n        @Override\r\n        public SocketState process(SocketWrapper<Socket> socket, SocketStatus status) {\r\n            AjpProcessor processor = connections.remove(socket);\r\n            try {\r\n                if (processor == null) {\r\n                    processor = recycledProcessors.poll();\r\n                }\r\n                if (processor == null) {\r\n                    processor = createProcessor();\r\n                }\r\n\r\n                SocketState state = socket.isAsync()?processor.asyncDispatch(status):processor.process(socket);\r\n                if (state == SocketState.LONG) {\r\n                    connections.put(socket, processor);\r\n                    socket.setAsync(true);\r\n                    // longPoll may change socket state (e.g. to trigger a\r\n                    // complete or dispatch)\r\n                    return processor.asyncPostProcess();\r\n                } else {\r\n                    socket.setAsync(false);\r\n                    processor.recycle();\r\n                    recycledProcessors.offer(processor);\r\n                }\r\n                return state;\r\n            } catch(java.net.SocketException e) {\r\n                // SocketExceptions are normal\r\n                log.debug(sm.getString(\r\n                        \"ajpprotocol.proto.socketexception.debug\"), e);\r\n            } catch (java.io.IOException e) {\r\n                // IOExceptions are normal\r\n                log.debug(sm.getString(\r\n                        \"ajpprotocol.proto.ioexception.debug\"), e);\r\n            }\r\n            // Future developers: if you discover any other\r\n            // rare-but-nonfatal exceptions, catch them here, and log as\r\n            // above.\r\n            catch (Throwable e) {\r\n                ExceptionUtils.handleThrowable(e);\r\n                // any other exception or error is odd. Here we log it\r\n                // with \"ERROR\" level, so it will show up even on\r\n                // less-than-verbose logs.\r\n                log.error(sm.getString(\"ajpprotocol.proto.error\"), e);\r\n            }\r\n            processor.recycle();\r\n            recycledProcessors.offer(processor);\r\n            return SocketState.CLOSED;\r\n        }\r\n\r\n        protected AjpProcessor createProcessor() {\r\n            AjpProcessor processor = new AjpProcessor(proto.packetSize, (JIoEndpoint)proto.endpoint);\r\n            processor.setAdapter(proto.adapter);\r\n            processor.setTomcatAuthentication(proto.tomcatAuthentication);\r\n            processor.setRequiredSecret(proto.requiredSecret);\r\n            processor.setKeepAliveTimeout(proto.getKeepAliveTimeout());\r\n            processor.setClientCertProvider(proto.getClientCertProvider());\r\n            register(processor);\r\n            return processor;\r\n        }\r\n    }\r\n}", "class_id": 0, "repo": "forAllBright/tomcat-embed-core-7.0.16-sourcecode", "file": "org/apache/coyote/ajp/AjpProtocol.java", "last_update_at": "2019-10-14T12:39:10+00:00", "question_id": "b6a477a06cbb2aa840b6e6dd3130bff948ff74e3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AjpProtocol extends AbstractAjpProtocol {\r\n    \r\n    \r\n    private static final Log log = LogFactory.getLog(AjpProtocol.class);\r\n\r\n    @Override\r\n    protected Log getLog() { return log; }\r\n\r\n\r\n    @Override\r\n    protected AbstractEndpoint.Handler getHandler() {\r\n        return cHandler;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------ Constructor\r\n\r\n\r\n    public AjpProtocol() {\r\n        endpoint = new JIoEndpoint();\r\n        cHandler = new AjpConnectionHandler(this);\r\n        ((JIoEndpoint) endpoint).setHandler(cHandler);\r\n        setSoLinger(Constants.DEFAULT_CONNECTION_LINGER);\r\n        setSoTimeout(Constants.DEFAULT_CONNECTION_TIMEOUT);\r\n        setTcpNoDelay(Constants.DEFAULT_TCP_NO_DELAY);\r\n    }\r\n\r\n    \r\n    // ----------------------------------------------------- Instance Variables\r\n\r\n    \r\n    /**\r\n     * Connection handler for AJP.\r\n     */\r\n    private AjpConnectionHandler cHandler;\r\n\r\n\r\n    // ----------------------------------------------------- JMX related methods\r\n\r\n    @Override\r\n    protected String getNamePrefix() {\r\n        return (\"ajp-bio\");\r\n    }\r\n\r\n\r\n    // --------------------------------------  AjpConnectionHandler Inner Class\r\n\r\n\r\n    protected static class AjpConnectionHandler\r\n            extends AbstractConnectionHandler implements Handler {\r\n\r\n        protected AjpProtocol proto;\r\n\r\n        protected ConcurrentHashMap<SocketWrapper<Socket>, AjpProcessor> connections =\r\n            new ConcurrentHashMap<SocketWrapper<Socket>, AjpProcessor>();\r\n\r\n        protected RecycledProcessors<AjpProcessor> recycledProcessors =\r\n            new RecycledProcessors<AjpProcessor>(this);\r\n\r\n        public AjpConnectionHandler(AjpProtocol proto) {\r\n            this.proto = proto;\r\n        }\r\n        \r\n        @Override\r\n        protected AbstractProtocol getProtocol() {\r\n            return proto;\r\n        }\r\n\r\n        @Override\r\n        protected Log getLog() {\r\n            return log;\r\n        }\r\n\r\n        @Override\r\n        public SSLImplementation getSslImplementation() {\r\n            // AJP does not support SSL\r\n            return null;\r\n        }\r\n\r\n        @Override\r\n        public void recycle() {\r\n            recycledProcessors.clear();\r\n        }\r\n        \r\n        @Override\r\n        public SocketState process(SocketWrapper<Socket> socket) {\r\n            return process(socket,SocketStatus.OPEN);\r\n        }\r\n\r\n        @Override\r\n        public SocketState process(SocketWrapper<Socket> socket, SocketStatus status) {\r\n            AjpProcessor processor = connections.remove(socket);\r\n            try {\r\n                if (processor == null) {\r\n                    processor = recycledProcessors.poll();\r\n                }\r\n                if (processor == null) {\r\n                    processor = createProcessor();\r\n                }\r\n\r\n                SocketState state = socket.isAsync()?processor.asyncDispatch(status):processor.process(socket);\r\n                if (state == SocketState.LONG) {\r\n                    connections.put(socket, processor);\r\n                    socket.setAsync(true);\r\n                    // longPoll may change socket state (e.g. to trigger a\r\n                    // complete or dispatch)\r\n                    return processor.asyncPostProcess();\r\n                } else {\r\n                    socket.setAsync(false);\r\n                    processor.recycle();\r\n                    recycledProcessors.offer(processor);\r\n                }\r\n                return state;\r\n            } catch(java.net.SocketException e) {\r\n                // SocketExceptions are normal\r\n                log.debug(sm.getString(\r\n                        \"ajpprotocol.proto.socketexception.debug\"), e);\r\n            } catch (java.io.IOException e) {\r\n                // IOExceptions are normal\r\n                log.debug(sm.getString(\r\n                        \"ajpprotocol.proto.ioexception.debug\"), e);\r\n            }\r\n            // Future developers: if you discover any other\r\n            // rare-but-nonfatal exceptions, catch them here, and log as\r\n            // above.\r\n            catch (Throwable e) {\r\n                ExceptionUtils.handleThrowable(e);\r\n                // any other exception or error is odd. Here we log it\r\n                // with \"ERROR\" level, so it will show up even on\r\n                // less-than-verbose logs.\r\n                log.error(sm.getString(\"ajpprotocol.proto.error\"), e);\r\n            }\r\n            processor.recycle();\r\n            recycledProcessors.offer(processor);\r\n            return SocketState.CLOSED;\r\n        }\r\n\r\n        protected AjpProcessor createProcessor() {\r\n            AjpProcessor processor = new AjpProcessor(proto.packetSize, (JIoEndpoint)proto.endpoint);\r\n            processor.setAdapter(proto.adapter);\r\n            processor.setTomcatAuthentication(proto.tomcatAuthentication);\r\n            processor.setRequiredSecret(proto.requiredSecret);\r\n            processor.setKeepAliveTimeout(proto.getKeepAliveTimeout());\r\n            processor.setClientCertProvider(proto.getClientCertProvider());\r\n            register(processor);\r\n            return processor;\r\n        }\r\n    }\r\n"]]}
{"hexsha": "9eb0ea9c511874a4964887fce55de921883a147a", "ext": "java", "lang": "Java", "content": "public class ClearCaseScmProvider\n    extends AbstractScmProvider\n{\n    // ----------------------------------------------------------------------\n    // ScmProvider Implementation\n    // ----------------------------------------------------------------------\n\n    /**\n     * Contains parameters loaded from clearcase-settings.xml\n     */\n    private Settings settings;\n\n    /** {@inheritDoc} */\n    public ScmProviderRepository makeProviderScmRepository( String scmSpecificUrl, char delimiter )\n        throws ScmRepositoryException\n    {\n        settings = ClearCaseUtil.getSettings();\n        return new ClearCaseScmProviderRepository( getLogger(), scmSpecificUrl, settings );\n    }\n\n    /** {@inheritDoc} */\n    public String getScmType()\n    {\n        return \"clearcase\";\n    }\n\n    /** {@inheritDoc} */\n    public boolean requiresEditMode()\n    {\n        return true;\n    }\n\n    /** {@inheritDoc} */\n    public ChangeLogScmResult changelog( ScmProviderRepository repository, ScmFileSet fileSet,\n                                         CommandParameters parameters )\n        throws ScmException\n    {\n        ClearCaseChangeLogCommand command = new ClearCaseChangeLogCommand();\n\n        command.setLogger( getLogger() );\n\n        return (ChangeLogScmResult) command.execute( repository, fileSet, parameters );\n    }\n\n    /** {@inheritDoc} */\n    public CheckInScmResult checkin( ScmProviderRepository repository, ScmFileSet fileSet,\n                                     CommandParameters parameters )\n        throws ScmException\n    {\n        ClearCaseCheckInCommand command = new ClearCaseCheckInCommand();\n\n        command.setLogger( getLogger() );\n\n        return (CheckInScmResult) command.execute( repository, fileSet, parameters );\n    }\n\n    /** {@inheritDoc} */\n    public CheckOutScmResult checkout( ScmProviderRepository repository, ScmFileSet fileSet,\n                                       CommandParameters parameters )\n        throws ScmException\n    {\n        ClearCaseCheckOutCommand command = new ClearCaseCheckOutCommand();\n\n        command.setLogger( getLogger() );\n        command.setSettings( settings );\n\n        return (CheckOutScmResult) command.execute( repository, fileSet, parameters );\n    }\n\n    /** {@inheritDoc} */\n    protected UpdateScmResult update( ScmProviderRepository repository, ScmFileSet fileSet,\n                                      CommandParameters parameters )\n        throws ScmException\n    {\n        ClearCaseUpdateCommand command = new ClearCaseUpdateCommand();\n\n        command.setLogger( getLogger() );\n\n        return (UpdateScmResult) command.execute( repository, fileSet, parameters );\n    }\n\n    /** {@inheritDoc} */\n    public TagScmResult tag( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n        ClearCaseTagCommand command = new ClearCaseTagCommand();\n\n        command.setLogger( getLogger() );\n\n        return (TagScmResult) command.execute( repository, fileSet, parameters );\n    }\n\n    /** {@inheritDoc} */\n    protected StatusScmResult status( ScmProviderRepository repository, ScmFileSet fileSet,\n                                      CommandParameters parameters )\n        throws ScmException\n    {\n        ClearCaseStatusCommand command = new ClearCaseStatusCommand();\n\n        command.setLogger( getLogger() );\n\n        return (StatusScmResult) command.execute( repository, fileSet, parameters );\n    }\n\n    /** {@inheritDoc} */\n    protected EditScmResult edit( ScmProviderRepository repository, ScmFileSet fileSet,\n                                  CommandParameters parameters )\n        throws ScmException\n    {\n        ClearCaseEditCommand command = new ClearCaseEditCommand();\n\n        command.setLogger( getLogger() );\n\n        return (EditScmResult) command.execute( repository, fileSet, parameters );\n    }\n\n    /** {@inheritDoc} */\n    protected BlameScmResult blame( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n        ClearCaseBlameCommand command = new ClearCaseBlameCommand();\n\n        command.setLogger( getLogger() );\n\n        return (BlameScmResult) command.execute( repository, fileSet, parameters );\n    }\n}", "class_id": 0, "repo": "hazendaz/maven-scm", "file": "maven-scm-providers/maven-scm-provider-clearcase/src/main/java/org/apache/maven/scm/provider/clearcase/ClearCaseScmProvider.java", "last_update_at": "2019-06-27T07:38:41+00:00", "question_id": "9eb0ea9c511874a4964887fce55de921883a147a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ClearCaseScmProvider\n    extends AbstractScmProvider\n{\n    // ----------------------------------------------------------------------\n    // ScmProvider Implementation\n    // ----------------------------------------------------------------------\n    /**\n     * Contains parameters loaded from clearcase-settings.xml\n     */\n    private Settings settings;\n    /** {@inheritDoc} */\n    public ScmProviderRepository makeProviderScmRepository( String scmSpecificUrl, char delimiter )\n        throws ScmRepositoryException\n    {\n        settings = ClearCaseUtil.getSettings();\n        return new ClearCaseScmProviderRepository( getLogger(), scmSpecificUrl, settings );\n    }\n    /** {@inheritDoc} */\n    public String getScmType()\n    {\n        return \"clearcase\";\n    }\n    /** {@inheritDoc} */\n    public boolean requiresEditMode()\n    {\n        return true;\n    }\n    /** {@inheritDoc} */\n    public ChangeLogScmResult changelog( ScmProviderRepository repository, ScmFileSet fileSet,\n                                         CommandParameters parameters )\n        throws ScmException\n    {\n        ClearCaseChangeLogCommand command = new ClearCaseChangeLogCommand();\n        command.setLogger( getLogger() );\n        return (ChangeLogScmResult) command.execute( repository, fileSet, parameters );\n    }\n    /** {@inheritDoc} */\n    public CheckInScmResult checkin( ScmProviderRepository repository, ScmFileSet fileSet,\n                                     CommandParameters parameters )\n        throws ScmException\n    {\n        ClearCaseCheckInCommand command = new ClearCaseCheckInCommand();\n        command.setLogger( getLogger() );\n        return (CheckInScmResult) command.execute( repository, fileSet, parameters );\n    }\n    /** {@inheritDoc} */\n    public CheckOutScmResult checkout( ScmProviderRepository repository, ScmFileSet fileSet,\n                                       CommandParameters parameters )\n        throws ScmException\n    {\n        ClearCaseCheckOutCommand command = new ClearCaseCheckOutCommand();\n        command.setLogger( getLogger() );\n        command.setSettings( settings );\n        return (CheckOutScmResult) command.execute( repository, fileSet, parameters );\n    }\n    /** {@inheritDoc} */\n    protected UpdateScmResult update( ScmProviderRepository repository, ScmFileSet fileSet,\n                                      CommandParameters parameters )\n        throws ScmException\n    {\n        ClearCaseUpdateCommand command = new ClearCaseUpdateCommand();\n        command.setLogger( getLogger() );\n        return (UpdateScmResult) command.execute( repository, fileSet, parameters );\n    }\n    /** {@inheritDoc} */\n    public TagScmResult tag( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n        ClearCaseTagCommand command = new ClearCaseTagCommand();\n        command.setLogger( getLogger() );\n        return (TagScmResult) command.execute( repository, fileSet, parameters );\n    }\n    /** {@inheritDoc} */\n    protected StatusScmResult status( ScmProviderRepository repository, ScmFileSet fileSet,\n                                      CommandParameters parameters )\n        throws ScmException\n    {\n        ClearCaseStatusCommand command = new ClearCaseStatusCommand();\n        command.setLogger( getLogger() );\n        return (StatusScmResult) command.execute( repository, fileSet, parameters );\n    }\n    /** {@inheritDoc} */\n    protected EditScmResult edit( ScmProviderRepository repository, ScmFileSet fileSet,\n                                  CommandParameters parameters )\n        throws ScmException\n    {\n        ClearCaseEditCommand command = new ClearCaseEditCommand();\n        command.setLogger( getLogger() );\n        return (EditScmResult) command.execute( repository, fileSet, parameters );\n    }\n    /** {@inheritDoc} */\n    protected BlameScmResult blame( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )\n        throws ScmException\n    {\n        ClearCaseBlameCommand command = new ClearCaseBlameCommand();\n        command.setLogger( getLogger() );\n        return (BlameScmResult) command.execute( repository, fileSet, parameters );\n    }\n"]]}
{"hexsha": "68cd42ec35674e6755538ccd6a40762a85d5c7a6", "ext": "java", "lang": "Java", "content": "public class Number213 {\n    public int rob(int[] nums) {\n        int n = nums.length;\n        if (n == 1) {\n            return nums[0];\n        }\n        if (n == 2) {\n            return Math.max(nums[0], nums[1]);\n        }\n        return Math.max(process(nums, 0, n - 2), process(nums, 1, n - 1));\n    }\n\n    public int process(int[] nums, int begin, int end) {\n        int pre = nums[begin];\n        int cur = Math.max(nums[begin], nums[begin + 1]);\n        int tmp;\n        for (int i = begin + 2; i <= end; i++) {\n            tmp = cur;\n            cur = Math.max(cur, pre + nums[i]);\n            pre = tmp;\n        }\n        return cur;\n    }\n}", "class_id": 0, "repo": "IYoreI/Algorithm", "file": "Codes/yore/medium/Number213.java", "last_update_at": "2019-07-06T00:22:00+00:00", "question_id": "68cd42ec35674e6755538ccd6a40762a85d5c7a6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Number213 {\n    public int rob(int[] nums) {\n        int n = nums.length;\n        if (n == 1) {\n            return nums[0];\n        }\n        if (n == 2) {\n            return Math.max(nums[0], nums[1]);\n        }\n        return Math.max(process(nums, 0, n - 2), process(nums, 1, n - 1));\n    }\n    public int process(int[] nums, int begin, int end) {\n        int pre = nums[begin];\n        int cur = Math.max(nums[begin], nums[begin + 1]);\n        int tmp;\n        for (int i = begin + 2; i <= end; i++) {\n            tmp = cur;\n            cur = Math.max(cur, pre + nums[i]);\n            pre = tmp;\n        }\n        return cur;\n    }\n"]]}
{"hexsha": "2b26f648b10ebca13e45c211468cfe0df4123a92", "ext": "java", "lang": "Java", "content": "public class ProcessingTile\n{\n\n\tpublic ProcessingTile(String s)\n\t{\n\t//    0    0:aload_0         \n\t//    1    1:invokespecial   #25  <Method void Object()>\n\t\tmCreateTime = 0L;\n\t//    2    4:aload_0         \n\t//    3    5:lconst_0        \n\t//    4    6:putfield        #27  <Field long mCreateTime>\n\t\tsetParams(s);\n\t//    5    9:aload_0         \n\t//    6   10:aload_1         \n\t//    7   11:invokespecial   #30  <Method void setParams(String)>\n\t//    8   14:return          \n\t}\n\n\tpublic static ProcessingTile obtain(String s)\n\t{\n\t\tProcessingTile processingtile = (ProcessingTile)M_POOL.acquire();\n\t//    0    0:getstatic       #21  <Field Pools$SynchronizedPool M_POOL>\n\t//    1    3:invokevirtual   #36  <Method Object Pools$SynchronizedPool.acquire()>\n\t//    2    6:checkcast       #2   <Class ProcessingTile>\n\t//    3    9:astore_1        \n\t\tif(processingtile != null)\n\t//*   4   10:aload_1         \n\t//*   5   11:ifnull          21\n\t\t{\n\t\t\tprocessingtile.setParams(s);\n\t//    6   14:aload_1         \n\t//    7   15:aload_0         \n\t//    8   16:invokespecial   #30  <Method void setParams(String)>\n\t\t\treturn processingtile;\n\t//    9   19:aload_1         \n\t//   10   20:areturn         \n\t\t} else\n\t\t{\n\t\t\treturn new ProcessingTile(s);\n\t//   11   21:new             #2   <Class ProcessingTile>\n\t//   12   24:dup             \n\t//   13   25:aload_0         \n\t//   14   26:invokespecial   #38  <Method void ProcessingTile(String)>\n\t//   15   29:areturn         \n\t\t}\n\t}\n\n\tprivate void setParams(String s)\n\t{\n\t\tmKeyName = s;\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:putfield        #40  <Field String mKeyName>\n\t\tmCreateTime = System.currentTimeMillis() / 1000L;\n\t//    3    5:aload_0         \n\t//    4    6:invokestatic    #46  <Method long System.currentTimeMillis()>\n\t//    5    9:ldc2w           #47  <Long 1000L>\n\t//    6   12:ldiv            \n\t//    7   13:putfield        #27  <Field long mCreateTime>\n\t//    8   16:return          \n\t}\n\n\tpublic void recycle()\n\t{\n\t\tmKeyName = null;\n\t//    0    0:aload_0         \n\t//    1    1:aconst_null     \n\t//    2    2:putfield        #40  <Field String mKeyName>\n\t\tmCreateTime = 0L;\n\t//    3    5:aload_0         \n\t//    4    6:lconst_0        \n\t//    5    7:putfield        #27  <Field long mCreateTime>\n\t\tM_POOL.release(((Object) (this)));\n\t//    6   10:getstatic       #21  <Field Pools$SynchronizedPool M_POOL>\n\t//    7   13:aload_0         \n\t//    8   14:invokevirtual   #53  <Method boolean Pools$SynchronizedPool.release(Object)>\n\t//    9   17:pop             \n\t//   10   18:return          \n\t}\n\n\tprivate static final Pools.SynchronizedPool M_POOL = new Pools.SynchronizedPool(30);\n\tpublic long mCreateTime;\n\tpublic String mKeyName;\n\n\tstatic \n\t{\n\t//    0    0:new             #15  <Class Pools$SynchronizedPool>\n\t//    1    3:dup             \n\t//    2    4:bipush          30\n\t//    3    6:invokespecial   #19  <Method void Pools$SynchronizedPool(int)>\n\t//    4    9:putstatic       #21  <Field Pools$SynchronizedPool M_POOL>\n\t//*   5   12:return          \n\t}\n}", "class_id": 0, "repo": "Andreas237/AndroidPolicyAutomation", "file": "ExtractedJars/Health_com.huawei.health/javafiles/com/autonavi/ae/gmap/maploader/ProcessingTile.java", "last_update_at": "2019-07-06T22:21:59+00:00", "question_id": "2b26f648b10ebca13e45c211468cfe0df4123a92", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ProcessingTile\n{\n\tpublic ProcessingTile(String s)\n\t{\n\t//    0    0:aload_0         \n\t//    1    1:invokespecial   #25  <Method void Object()>\n\t\tmCreateTime = 0L;\n\t//    2    4:aload_0         \n\t//    3    5:lconst_0        \n\t//    4    6:putfield        #27  <Field long mCreateTime>\n\t\tsetParams(s);\n\t//    5    9:aload_0         \n\t//    6   10:aload_1         \n\t//    7   11:invokespecial   #30  <Method void setParams(String)>\n\t//    8   14:return          \n\t}\n\tpublic static ProcessingTile obtain(String s)\n\t{\n\t\tProcessingTile processingtile = (ProcessingTile)M_POOL.acquire();\n\t//    0    0:getstatic       #21  <Field Pools$SynchronizedPool M_POOL>\n\t//    1    3:invokevirtual   #36  <Method Object Pools$SynchronizedPool.acquire()>\n\t//    2    6:checkcast       #2   <Class ProcessingTile>\n\t//    3    9:astore_1        \n\t\tif(processingtile != null)\n\t//*   4   10:aload_1         \n\t//*   5   11:ifnull          21\n\t\t{\n\t\t\tprocessingtile.setParams(s);\n\t//    6   14:aload_1         \n\t//    7   15:aload_0         \n\t//    8   16:invokespecial   #30  <Method void setParams(String)>\n\t\t\treturn processingtile;\n\t//    9   19:aload_1         \n\t//   10   20:areturn         \n\t\t} else\n\t\t{\n\t\t\treturn new ProcessingTile(s);\n\t//   11   21:new             #2   <Class ProcessingTile>\n\t//   12   24:dup             \n\t//   13   25:aload_0         \n\t//   14   26:invokespecial   #38  <Method void ProcessingTile(String)>\n\t//   15   29:areturn         \n\t\t}\n\t}\n\tprivate void setParams(String s)\n\t{\n\t\tmKeyName = s;\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:putfield        #40  <Field String mKeyName>\n\t\tmCreateTime = System.currentTimeMillis() / 1000L;\n\t//    3    5:aload_0         \n\t//    4    6:invokestatic    #46  <Method long System.currentTimeMillis()>\n\t//    5    9:ldc2w           #47  <Long 1000L>\n\t//    6   12:ldiv            \n\t//    7   13:putfield        #27  <Field long mCreateTime>\n\t//    8   16:return          \n\t}\n\tpublic void recycle()\n\t{\n\t\tmKeyName = null;\n\t//    0    0:aload_0         \n\t//    1    1:aconst_null     \n\t//    2    2:putfield        #40  <Field String mKeyName>\n\t\tmCreateTime = 0L;\n\t//    3    5:aload_0         \n\t//    4    6:lconst_0        \n\t//    5    7:putfield        #27  <Field long mCreateTime>\n\t\tM_POOL.release(((Object) (this)));\n\t//    6   10:getstatic       #21  <Field Pools$SynchronizedPool M_POOL>\n\t//    7   13:aload_0         \n\t//    8   14:invokevirtual   #53  <Method boolean Pools$SynchronizedPool.release(Object)>\n\t//    9   17:pop             \n\t//   10   18:return          \n\t}\n\tprivate static final Pools.SynchronizedPool M_POOL = new Pools.SynchronizedPool(30);\n\tpublic long mCreateTime;\n\tpublic String mKeyName;\n\tstatic \n\t{\n\t//    0    0:new             #15  <Class Pools$SynchronizedPool>\n\t//    1    3:dup             \n\t//    2    4:bipush          30\n\t//    3    6:invokespecial   #19  <Method void Pools$SynchronizedPool(int)>\n\t//    4    9:putstatic       #21  <Field Pools$SynchronizedPool M_POOL>\n\t//*   5   12:return          \n\t}\n"]]}
{"hexsha": "b07c855d1039461983235df4b45d92ae11ad5b6c", "ext": "java", "lang": "Java", "content": "public class GrMapTypeFromNamedArgs extends GrMapType {\n\n  private final @NotNull LinkedHashMap<String, GrExpression> myStringEntries;\n  private final @NotNull List<Couple<GrExpression>> myOtherEntries;\n\n  private final VolatileNotNullLazyValue<List<Couple<PsiType>>> myTypesOfOtherEntries = new VolatileNotNullLazyValue<List<Couple<PsiType>>>() {\n    @NotNull\n    @Override\n    protected List<Couple<PsiType>> compute() {\n      return ContainerUtil.map(myOtherEntries, pair -> Couple.of(inferTypePreventingRecursion(pair.first), inferTypePreventingRecursion(pair.second)));\n    }\n  };\n\n  private final VolatileNotNullLazyValue<LinkedHashMap<String, PsiType>> myTypesOfStringEntries = new VolatileNotNullLazyValue<LinkedHashMap<String,PsiType>>() {\n    @NotNull\n    @Override\n    protected LinkedHashMap<String, PsiType> compute() {\n      LinkedHashMap<String, PsiType> result = new LinkedHashMap<>();\n      for (Map.Entry<String, GrExpression> entry : myStringEntries.entrySet()) {\n        result.put(entry.getKey(), inferTypePreventingRecursion(entry.getValue()));\n      }\n      return result;\n    }\n\n  };\n\n  public GrMapTypeFromNamedArgs(@NotNull PsiElement context, @NotNull GrNamedArgument[] namedArgs) {\n    this(JavaPsiFacade.getInstance(context.getProject()), context.getResolveScope(), namedArgs);\n  }\n\n  public GrMapTypeFromNamedArgs(@NotNull JavaPsiFacade facade, @NotNull GlobalSearchScope scope, @NotNull GrNamedArgument[] namedArgs) {\n    super(facade, scope);\n\n    myStringEntries = new LinkedHashMap<>();\n    myOtherEntries = new ArrayList<>();\n    for (GrNamedArgument namedArg : namedArgs) {\n      final GrArgumentLabel label = namedArg.getLabel();\n      final GrExpression expression = namedArg.getExpression();\n      if (label == null || expression == null) {\n        continue;\n      }\n\n      final String name = label.getName();\n      if (name != null) {\n        myStringEntries.put(name, expression);\n      }\n      else {\n        GrExpression labelExpression = label.getExpression();\n        if (labelExpression != null) {\n          myOtherEntries.add(Couple.of(labelExpression, expression));\n        }\n      }\n    }\n  }\n\n  @Nullable\n  @Override\n  public PsiType getTypeByStringKey(String key) {\n    GrExpression expression = myStringEntries.get(key);\n    return expression != null ? inferTypePreventingRecursion(expression) : null;\n  }\n\n  @NotNull\n  @Override\n  public Set<String> getStringKeys() {\n    return myStringEntries.keySet();\n  }\n\n  @Override\n  public boolean isEmpty() {\n    return myStringEntries.isEmpty() && myOtherEntries.isEmpty();\n  }\n\n  @Nullable\n  private PsiType inferTypePreventingRecursion(final GrExpression expression) {\n    return RecursionManager.doPreventingRecursion(expression, false,\n                                                  () -> TypesUtil.boxPrimitiveType(expression.getType(), expression.getManager(), myScope));\n  }\n\n  @NotNull\n  @Override\n  protected List<Couple<PsiType>> getOtherEntries() {\n    return myTypesOfOtherEntries.getValue();\n  }\n\n  @NotNull\n  @Override\n  protected LinkedHashMap<String, PsiType> getStringEntries() {\n    return myTypesOfStringEntries.getValue();\n  }\n\n  @Override\n  public boolean isValid() {\n    for (GrExpression expression : myStringEntries.values()) {\n      if (!expression.isValid()) return false;\n    }\n\n    for (Couple<GrExpression> entry : myOtherEntries) {\n      if (!entry.first.isValid()) return false;\n      if (!entry.second.isValid()) return false;\n    }\n\n    return true;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n\n    GrMapTypeFromNamedArgs args = (GrMapTypeFromNamedArgs)o;\n\n    if (!myStringEntries.equals(args.myStringEntries)) return false;\n    if (!myOtherEntries.equals(args.myOtherEntries)) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + myStringEntries.hashCode();\n    result = 31 * result + myOtherEntries.hashCode();\n    return result;\n  }\n}", "class_id": 0, "repo": "tgodzik/intellij-community", "file": "plugins/groovy/groovy-psi/src/org/jetbrains/plugins/groovy/lang/psi/impl/GrMapTypeFromNamedArgs.java", "last_update_at": "2019-08-02T21:11:19+00:00", "question_id": "b07c855d1039461983235df4b45d92ae11ad5b6c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GrMapTypeFromNamedArgs extends GrMapType {\n  private final @NotNull LinkedHashMap<String, GrExpression> myStringEntries;\n  private final @NotNull List<Couple<GrExpression>> myOtherEntries;\n  private final VolatileNotNullLazyValue<List<Couple<PsiType>>> myTypesOfOtherEntries = new VolatileNotNullLazyValue<List<Couple<PsiType>>>() {\n    @NotNull\n    @Override\n    protected List<Couple<PsiType>> compute() {\n      return ContainerUtil.map(myOtherEntries, pair -> Couple.of(inferTypePreventingRecursion(pair.first), inferTypePreventingRecursion(pair.second)));\n    }\n  };\n  private final VolatileNotNullLazyValue<LinkedHashMap<String, PsiType>> myTypesOfStringEntries = new VolatileNotNullLazyValue<LinkedHashMap<String,PsiType>>() {\n    @NotNull\n    @Override\n    protected LinkedHashMap<String, PsiType> compute() {\n      LinkedHashMap<String, PsiType> result = new LinkedHashMap<>();\n      for (Map.Entry<String, GrExpression> entry : myStringEntries.entrySet()) {\n        result.put(entry.getKey(), inferTypePreventingRecursion(entry.getValue()));\n      }\n      return result;\n    }\n  };\n  public GrMapTypeFromNamedArgs(@NotNull PsiElement context, @NotNull GrNamedArgument[] namedArgs) {\n    this(JavaPsiFacade.getInstance(context.getProject()), context.getResolveScope(), namedArgs);\n  }\n  public GrMapTypeFromNamedArgs(@NotNull JavaPsiFacade facade, @NotNull GlobalSearchScope scope, @NotNull GrNamedArgument[] namedArgs) {\n    super(facade, scope);\n    myStringEntries = new LinkedHashMap<>();\n    myOtherEntries = new ArrayList<>();\n    for (GrNamedArgument namedArg : namedArgs) {\n      final GrArgumentLabel label = namedArg.getLabel();\n      final GrExpression expression = namedArg.getExpression();\n      if (label == null || expression == null) {\n        continue;\n      }\n      final String name = label.getName();\n      if (name != null) {\n        myStringEntries.put(name, expression);\n      }\n      else {\n        GrExpression labelExpression = label.getExpression();\n        if (labelExpression != null) {\n          myOtherEntries.add(Couple.of(labelExpression, expression));\n        }\n      }\n    }\n  }\n  @Nullable\n  @Override\n  public PsiType getTypeByStringKey(String key) {\n    GrExpression expression = myStringEntries.get(key);\n    return expression != null ? inferTypePreventingRecursion(expression) : null;\n  }\n  @NotNull\n  @Override\n  public Set<String> getStringKeys() {\n    return myStringEntries.keySet();\n  }\n  @Override\n  public boolean isEmpty() {\n    return myStringEntries.isEmpty() && myOtherEntries.isEmpty();\n  }\n  @Nullable\n  private PsiType inferTypePreventingRecursion(final GrExpression expression) {\n    return RecursionManager.doPreventingRecursion(expression, false,\n                                                  () -> TypesUtil.boxPrimitiveType(expression.getType(), expression.getManager(), myScope));\n  }\n  @NotNull\n  @Override\n  protected List<Couple<PsiType>> getOtherEntries() {\n    return myTypesOfOtherEntries.getValue();\n  }\n  @NotNull\n  @Override\n  protected LinkedHashMap<String, PsiType> getStringEntries() {\n    return myTypesOfStringEntries.getValue();\n  }\n  @Override\n  public boolean isValid() {\n    for (GrExpression expression : myStringEntries.values()) {\n      if (!expression.isValid()) return false;\n    }\n    for (Couple<GrExpression> entry : myOtherEntries) {\n      if (!entry.first.isValid()) return false;\n      if (!entry.second.isValid()) return false;\n    }\n    return true;\n  }\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    GrMapTypeFromNamedArgs args = (GrMapTypeFromNamedArgs)o;\n    if (!myStringEntries.equals(args.myStringEntries)) return false;\n    if (!myOtherEntries.equals(args.myOtherEntries)) return false;\n    return true;\n  }\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + myStringEntries.hashCode();\n    result = 31 * result + myOtherEntries.hashCode();\n    return result;\n  }\n"]]}
{"hexsha": "4311e683ea70dba8870aafaae9986dfd03d360ca", "ext": "java", "lang": "Java", "content": "final class zzco\n\timplements com.google.android.gms.cast.Cast.ApplicationConnectionResult\n{\n\n\tpublic zzco(Status status)\n\t{\n\t\tthis(status, ((ApplicationMetadata) (null)), ((String) (null)), ((String) (null)), false);\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:aconst_null     \n\t//    3    3:aconst_null     \n\t//    4    4:aconst_null     \n\t//    5    5:iconst_0        \n\t//    6    6:invokespecial   #21  <Method void zzco(Status, ApplicationMetadata, String, String, boolean)>\n\t//    7    9:return          \n\t}\n\n\tpublic zzco(Status status, ApplicationMetadata applicationmetadata, String s, String s1, boolean flag)\n\t{\n\t//    0    0:aload_0         \n\t//    1    1:invokespecial   #25  <Method void Object()>\n\t\tzzge = status;\n\t//    2    4:aload_0         \n\t//    3    5:aload_1         \n\t//    4    6:putfield        #27  <Field Status zzge>\n\t\tzzvr = applicationmetadata;\n\t//    5    9:aload_0         \n\t//    6   10:aload_2         \n\t//    7   11:putfield        #29  <Field ApplicationMetadata zzvr>\n\t\tzzvs = s;\n\t//    8   14:aload_0         \n\t//    9   15:aload_3         \n\t//   10   16:putfield        #31  <Field String zzvs>\n\t\tzzvt = s1;\n\t//   11   19:aload_0         \n\t//   12   20:aload           4\n\t//   13   22:putfield        #33  <Field String zzvt>\n\t\tzzvu = flag;\n\t//   14   25:aload_0         \n\t//   15   26:iload           5\n\t//   16   28:putfield        #35  <Field boolean zzvu>\n\t//   17   31:return          \n\t}\n\n\tpublic final ApplicationMetadata getApplicationMetadata()\n\t{\n\t\treturn zzvr;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #29  <Field ApplicationMetadata zzvr>\n\t//    2    4:areturn         \n\t}\n\n\tpublic final String getApplicationStatus()\n\t{\n\t\treturn zzvs;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #31  <Field String zzvs>\n\t//    2    4:areturn         \n\t}\n\n\tpublic final String getSessionId()\n\t{\n\t\treturn zzvt;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #33  <Field String zzvt>\n\t//    2    4:areturn         \n\t}\n\n\tpublic final Status getStatus()\n\t{\n\t\treturn zzge;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #27  <Field Status zzge>\n\t//    2    4:areturn         \n\t}\n\n\tpublic final boolean getWasLaunched()\n\t{\n\t\treturn zzvu;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #35  <Field boolean zzvu>\n\t//    2    4:ireturn         \n\t}\n\n\tprivate final Status zzge;\n\tprivate final ApplicationMetadata zzvr;\n\tprivate final String zzvs;\n\tprivate final String zzvt;\n\tprivate final boolean zzvu;\n}", "class_id": 0, "repo": "Andreas237/AndroidPolicyAutomation", "file": "ExtractedJars/RT_News_com.rt.mobile.english/javafiles/com/google/android/gms/internal/cast/zzco.java", "last_update_at": "2019-07-06T22:21:59+00:00", "question_id": "4311e683ea70dba8870aafaae9986dfd03d360ca", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["final class zzco\n\timplements com.google.android.gms.cast.Cast.ApplicationConnectionResult\n{\n\tpublic zzco(Status status)\n\t{\n\t\tthis(status, ((ApplicationMetadata) (null)), ((String) (null)), ((String) (null)), false);\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:aconst_null     \n\t//    3    3:aconst_null     \n\t//    4    4:aconst_null     \n\t//    5    5:iconst_0        \n\t//    6    6:invokespecial   #21  <Method void zzco(Status, ApplicationMetadata, String, String, boolean)>\n\t//    7    9:return          \n\t}\n\tpublic zzco(Status status, ApplicationMetadata applicationmetadata, String s, String s1, boolean flag)\n\t{\n\t//    0    0:aload_0         \n\t//    1    1:invokespecial   #25  <Method void Object()>\n\t\tzzge = status;\n\t//    2    4:aload_0         \n\t//    3    5:aload_1         \n\t//    4    6:putfield        #27  <Field Status zzge>\n\t\tzzvr = applicationmetadata;\n\t//    5    9:aload_0         \n\t//    6   10:aload_2         \n\t//    7   11:putfield        #29  <Field ApplicationMetadata zzvr>\n\t\tzzvs = s;\n\t//    8   14:aload_0         \n\t//    9   15:aload_3         \n\t//   10   16:putfield        #31  <Field String zzvs>\n\t\tzzvt = s1;\n\t//   11   19:aload_0         \n\t//   12   20:aload           4\n\t//   13   22:putfield        #33  <Field String zzvt>\n\t\tzzvu = flag;\n\t//   14   25:aload_0         \n\t//   15   26:iload           5\n\t//   16   28:putfield        #35  <Field boolean zzvu>\n\t//   17   31:return          \n\t}\n\tpublic final ApplicationMetadata getApplicationMetadata()\n\t{\n\t\treturn zzvr;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #29  <Field ApplicationMetadata zzvr>\n\t//    2    4:areturn         \n\t}\n\tpublic final String getApplicationStatus()\n\t{\n\t\treturn zzvs;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #31  <Field String zzvs>\n\t//    2    4:areturn         \n\t}\n\tpublic final String getSessionId()\n\t{\n\t\treturn zzvt;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #33  <Field String zzvt>\n\t//    2    4:areturn         \n\t}\n\tpublic final Status getStatus()\n\t{\n\t\treturn zzge;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #27  <Field Status zzge>\n\t//    2    4:areturn         \n\t}\n\tpublic final boolean getWasLaunched()\n\t{\n\t\treturn zzvu;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #35  <Field boolean zzvu>\n\t//    2    4:ireturn         \n\t}\n\tprivate final Status zzge;\n\tprivate final ApplicationMetadata zzvr;\n\tprivate final String zzvs;\n\tprivate final String zzvt;\n\tprivate final boolean zzvu;\n"]]}
{"hexsha": "006dee7657dd444e5d5d6fe4654427c204838aba", "ext": "java", "lang": "Java", "content": "@RunWith(PowerMockRunner.class)\n@PowerMockIgnore({\"com.sun.org.apache.xerces.*\", \"javax.xml.*\", \"org.xml.*\", \"org.w3c.*\", \"com.sun.org.apache.xalan.*\"})\npublic class SampleSubscriberServletTest {\n\n  private SampleSubscriberServlet sampleSubServlet;\n  private SubscriberProps props = SubscriberProps.getInstance();\n\n  @Mock private HttpServletRequest request;\n  @Mock private HttpServletResponse response;\n\n  @Before\n  public void setUp() {\n    props =\n        SubscriberProps.getInstance(\n            System.getProperty(\n                \"org.onap.dmaap.datarouter.subscriber.properties\", \"testsubscriber.properties\"));\n    sampleSubServlet = new SampleSubscriberServlet();\n    sampleSubServlet.init();\n  }\n\n  @After\n  public void tearDown() throws Exception {\n    FileUtils.deleteDirectory(\n        new File(props.getValue(\"org.onap.dmaap.datarouter.subscriber.delivery.dir\")));\n  }\n\n  @Test\n  public void\n      Given_Request_Is_HTTP_PUT_And_Request_Header_Is_Null_Then_Unathorized_Response_Is_Generated()\n          throws Exception {\n    when(request.getHeader(\"Authorization\")).thenReturn(null);\n    sampleSubServlet.doPut(request, response);\n    verify(response).sendError(eq(HttpServletResponse.SC_UNAUTHORIZED));\n  }\n\n  @Test\n  public void\n      Given_Request_Is_HTTP_PUT_And_Request_Header_Is_Not_Authorized_Then_Forbidden_Response_Is_Generated()\n          throws Exception {\n    when(request.getHeader(\"Authorization\")).thenReturn(\"Invalid Header\");\n    sampleSubServlet.doPut(request, response);\n    verify(response).sendError(eq(HttpServletResponse.SC_FORBIDDEN));\n  }\n\n  @Test\n  public void Given_Request_Is_HTTP_PUT_Then_Request_Succeeds() throws Exception {\n    setUpSuccessfulFlow();\n    sampleSubServlet.doPut(request, response);\n    verify(response, times(2)).setStatus(eq(HttpServletResponse.SC_NO_CONTENT));\n  }\n\n  @Test\n  public void Given_Request_Is_HTTP_DELETE_Then_Request_Succeeds() throws Exception {\n    setUpSuccessfulFlow();\n    sampleSubServlet.doDelete(request, response);\n    verify(response).setStatus(eq(HttpServletResponse.SC_NO_CONTENT));\n  }\n\n  private void setUpSuccessfulFlow() throws IOException {\n    when(request.getHeader(\"Authorization\")).thenReturn(\"Basic TE9HSU46UEFTU1dPUkQ=\");\n    when(request.getPathInfo()).thenReturn(\"/publish/1/testfile\");\n    when(request.getHeader(\"X-DMAAP-DR-PUBLISH-ID\")).thenReturn(\"1\");\n    when(request.getHeader(\"X-DMAAP-DR-META\")).thenReturn(\"{\\\"Key\\\":\\\"Value\\\"}\");\n    when(request.getQueryString()).thenReturn(null);\n    ServletInputStream inStream = mock(ServletInputStream.class);\n    when(request.getInputStream()).thenReturn(inStream);\n  }\n}", "class_id": 0, "repo": "onap/dmaap-datarouter", "file": "datarouter-subscriber/src/test/java/org/onap/dmaap/datarouter/subscriber/SampleSubscriberServletTest.java", "last_update_at": "2019-09-24T11:21:32+00:00", "question_id": "006dee7657dd444e5d5d6fe4654427c204838aba", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(PowerMockRunner.class)\n@PowerMockIgnore({\"com.sun.org.apache.xerces.*\", \"javax.xml.*\", \"org.xml.*\", \"org.w3c.*\", \"com.sun.org.apache.xalan.*\"})\npublic class SampleSubscriberServletTest {\n  private SampleSubscriberServlet sampleSubServlet;\n  private SubscriberProps props = SubscriberProps.getInstance();\n  @Mock private HttpServletRequest request;\n  @Mock private HttpServletResponse response;\n  @Before\n  public void setUp() {\n    props =\n        SubscriberProps.getInstance(\n            System.getProperty(\n                \"org.onap.dmaap.datarouter.subscriber.properties\", \"testsubscriber.properties\"));\n    sampleSubServlet = new SampleSubscriberServlet();\n    sampleSubServlet.init();\n  }\n  @After\n  public void tearDown() throws Exception {\n    FileUtils.deleteDirectory(\n        new File(props.getValue(\"org.onap.dmaap.datarouter.subscriber.delivery.dir\")));\n  }\n  @Test\n  public void\n      Given_Request_Is_HTTP_PUT_And_Request_Header_Is_Null_Then_Unathorized_Response_Is_Generated()\n          throws Exception {\n    when(request.getHeader(\"Authorization\")).thenReturn(null);\n    sampleSubServlet.doPut(request, response);\n    verify(response).sendError(eq(HttpServletResponse.SC_UNAUTHORIZED));\n  }\n  @Test\n  public void\n      Given_Request_Is_HTTP_PUT_And_Request_Header_Is_Not_Authorized_Then_Forbidden_Response_Is_Generated()\n          throws Exception {\n    when(request.getHeader(\"Authorization\")).thenReturn(\"Invalid Header\");\n    sampleSubServlet.doPut(request, response);\n    verify(response).sendError(eq(HttpServletResponse.SC_FORBIDDEN));\n  }\n  @Test\n  public void Given_Request_Is_HTTP_PUT_Then_Request_Succeeds() throws Exception {\n    setUpSuccessfulFlow();\n    sampleSubServlet.doPut(request, response);\n    verify(response, times(2)).setStatus(eq(HttpServletResponse.SC_NO_CONTENT));\n  }\n  @Test\n  public void Given_Request_Is_HTTP_DELETE_Then_Request_Succeeds() throws Exception {\n    setUpSuccessfulFlow();\n    sampleSubServlet.doDelete(request, response);\n    verify(response).setStatus(eq(HttpServletResponse.SC_NO_CONTENT));\n  }\n  private void setUpSuccessfulFlow() throws IOException {\n    when(request.getHeader(\"Authorization\")).thenReturn(\"Basic TE9HSU46UEFTU1dPUkQ=\");\n    when(request.getPathInfo()).thenReturn(\"/publish/1/testfile\");\n    when(request.getHeader(\"X-DMAAP-DR-PUBLISH-ID\")).thenReturn(\"1\");\n    when(request.getHeader(\"X-DMAAP-DR-META\")).thenReturn(\"{\\\"Key\\\":\\\"Value\\\"}\");\n    when(request.getQueryString()).thenReturn(null);\n    ServletInputStream inStream = mock(ServletInputStream.class);\n    when(request.getInputStream()).thenReturn(inStream);\n  }\n"]]}
{"hexsha": "7117cb099dbb5068ecf9fb8fcac9df79992de0ce", "ext": "java", "lang": "Java", "content": "@RestController\n@RequestMapping(value = \"router/youngyedu/ym/sync\")\npublic class ZyMYoungyeduSyncController {\n\n\t@Autowired\n\tprivate YoungyeduSyncDataService dataService;\n\t@Autowired\n\tprivate YoungyeduHttpClient client;\n\t@Autowired\n\tprivate MqSender mqSender;\n\t@Autowired\n\tprivate UserChannelService ucService;\n\n\t/**\n\t * \u63d0\u9192\u8fdb\u884c\u540c\u6b65\u64cd\u4f5c\n\t *\n\t * @param id\n\t *            \u540c\u6b65id\n\t * @return {@link Value}\n\t */\n\t@MasterSlaveDataSource(type = \"M\")\n\t@RolesAllowed(anyone = true)\n\t@RequestMapping(value = \"noticeSync\", method = { RequestMethod.GET, RequestMethod.POST })\n\tpublic Value noticeSync(String id) {\n\t\tUserChannel uc = ucService.findByName(UserChannel.YOUNGEDU);\n\t\tInteger channelCode = uc == null ? null : uc.getCode();\n\n\t\tif (channelCode == null) {\n\t\t\tclient.updateVersion(id, false);\n\t\t\treturn new Value(new IllegalArgException());\n\t\t}\n\n\t\tJSONObject jsonObject = new JSONObject();\n\t\tjsonObject.put(\"classId\", id);\n\t\tjsonObject.put(\"channelCode\", channelCode);\n\n\t\tmqSender.asynSend(MqYoomathYoungyeduRegistryConstants.EX_YM_YOUNGEDU,\n\t\t\t\tMqYoomathYoungyeduRegistryConstants.RK_YM_YOUNGEDU_SYNC, MQ.builder().data(jsonObject).build());\n\n\t\tclient.updateVersion(id, true);\n\n\t\treturn new Value();\n\t}\n\n}", "class_id": 0, "repo": "wangsikai/learn", "file": "yoo-master-dc2492330d5d46b48f1ceca891e0f9f7e1593fee/module/yoomath/ym-mobile/src/main/java/com/lanking/uxb/service/youngyedu/syncdata/resource/ZyMYoungyeduSyncController.java", "last_update_at": "2019-01-20T06:19:53+00:00", "question_id": "7117cb099dbb5068ecf9fb8fcac9df79992de0ce", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RestController\n@RequestMapping(value = \"router/youngyedu/ym/sync\")\npublic class ZyMYoungyeduSyncController {\n\t@Autowired\n\tprivate YoungyeduSyncDataService dataService;\n\t@Autowired\n\tprivate YoungyeduHttpClient client;\n\t@Autowired\n\tprivate MqSender mqSender;\n\t@Autowired\n\tprivate UserChannelService ucService;\n\t/**\n\t * \u63d0\u9192\u8fdb\u884c\u540c\u6b65\u64cd\u4f5c\n\t *\n\t * @param id\n\t *            \u540c\u6b65id\n\t * @return {@link Value}\n\t */\n\t@MasterSlaveDataSource(type = \"M\")\n\t@RolesAllowed(anyone = true)\n\t@RequestMapping(value = \"noticeSync\", method = { RequestMethod.GET, RequestMethod.POST })\n\tpublic Value noticeSync(String id) {\n\t\tUserChannel uc = ucService.findByName(UserChannel.YOUNGEDU);\n\t\tInteger channelCode = uc == null ? null : uc.getCode();\n\t\tif (channelCode == null) {\n\t\t\tclient.updateVersion(id, false);\n\t\t\treturn new Value(new IllegalArgException());\n\t\t}\n\t\tJSONObject jsonObject = new JSONObject();\n\t\tjsonObject.put(\"classId\", id);\n\t\tjsonObject.put(\"channelCode\", channelCode);\n\t\tmqSender.asynSend(MqYoomathYoungyeduRegistryConstants.EX_YM_YOUNGEDU,\n\t\t\t\tMqYoomathYoungyeduRegistryConstants.RK_YM_YOUNGEDU_SYNC, MQ.builder().data(jsonObject).build());\n\t\tclient.updateVersion(id, true);\n\t\treturn new Value();\n\t}\n"]]}
{"hexsha": "22ff4bad41f25fa56cf93ed3a5ed58682bdd5b26", "ext": "java", "lang": "Java", "content": "@Ignore\npublic class BackPressureTest extends TestSuiteBase {\n\n    private static final int TIMEOUT = 200000;\n    private static final int SETUP_TIMEOUT = 60000;\n\n    private CosmosDatabase createdDatabase;\n    private CosmosContainer createdCollection;\n    private List<CosmosItemProperties> createdDocuments;\n\n    private CosmosClient client;\n\n    public String getCollectionLink() {\n        return TestUtils.getCollectionNameLink(createdDatabase.id(), createdCollection.id());\n    }\n\n    private static CosmosContainerProperties getSinglePartitionCollectionDefinition() {\n        PartitionKeyDefinition partitionKeyDef = new PartitionKeyDefinition();\n        ArrayList<String> paths = new ArrayList<String>();\n        paths.add(\"/mypk\");\n        partitionKeyDef.paths(paths);\n\n        CosmosContainerProperties collectionDefinition = new CosmosContainerProperties(UUID.randomUUID().toString(), partitionKeyDef);\n        return collectionDefinition;\n    }\n\n    @Factory(dataProvider = \"simpleClientBuildersWithDirectHttps\")\n    public BackPressureTest(CosmosClientBuilder clientBuilder) {\n        super(clientBuilder);\n    }\n\n    @Test(groups = { \"long\" }, timeOut = 3 * TIMEOUT)\n    public void readFeed() throws Exception {\n        FeedOptions options = new FeedOptions();\n        options.maxItemCount(1);\n        options.enableCrossPartitionQuery(true);\n        Flux<FeedResponse<CosmosItemProperties>> queryObservable = createdCollection.readAllItems(options);\n\n        RxDocumentClientUnderTest rxClient = (RxDocumentClientUnderTest)CosmosBridgeInternal.getAsyncDocumentClient(client);\n        rxClient.httpRequests.clear();\n\n        TestSubscriber<FeedResponse<CosmosItemProperties>> subscriber = new TestSubscriber<FeedResponse<CosmosItemProperties>>(1);\n        queryObservable.publishOn(Schedulers.elastic(), 1).subscribe(subscriber);\n        int sleepTimeInMillis = 10000; // 10 seconds\n\n        int i = 0;\n        // use a test subscriber and request for more result and sleep in between\n        while (subscriber.completions() == 0 && subscriber.getEvents().get(1).isEmpty()) {\n            TimeUnit.MILLISECONDS.sleep(sleepTimeInMillis);\n            sleepTimeInMillis /= 2;\n\n            if (sleepTimeInMillis > 1000) {\n                // validate that only one item is returned to subscriber in each iteration\n                assertThat(subscriber.valueCount() - i).isEqualTo(1);\n            }\n            // validate that only one item is returned to subscriber in each iteration\n            // validate that the difference between the number of requests to backend\n            // and the number of returned results is always less than a fixed threshold\n            assertThat(rxClient.httpRequests.size() - subscriber.valueCount())\n                .isLessThanOrEqualTo(Queues.SMALL_BUFFER_SIZE);\n\n            subscriber.requestMore(1);\n            i++;\n        }\n\n        subscriber.assertNoErrors();\n        subscriber.assertComplete();\n        assertThat(subscriber.valueCount()).isEqualTo(createdDocuments.size());\n    }\n\n    @Test(groups = { \"long\" }, timeOut = 3 * TIMEOUT)\n    public void query() throws Exception {\n        FeedOptions options = new FeedOptions();\n        options.maxItemCount(1);\n        options.enableCrossPartitionQuery(true);\n        Flux<FeedResponse<CosmosItemProperties>> queryObservable = createdCollection.queryItems(\"SELECT * from r\", options);\n\n        RxDocumentClientUnderTest rxClient = (RxDocumentClientUnderTest)CosmosBridgeInternal.getAsyncDocumentClient(client);\n        rxClient.httpRequests.clear();\n\n        TestSubscriber<FeedResponse<CosmosItemProperties>> subscriber = new TestSubscriber<FeedResponse<CosmosItemProperties>>(1);\n        queryObservable.publishOn(Schedulers.elastic(), 1).subscribe(subscriber);\n        int sleepTimeInMillis = 10000;\n\n        int i = 0;\n        // use a test subscriber and request for more result and sleep in between\n        while(subscriber.completions() == 0 && subscriber.getEvents().get(1).isEmpty()) {\n            TimeUnit.MILLISECONDS.sleep(sleepTimeInMillis);\n            sleepTimeInMillis /= 2;\n\n            if (sleepTimeInMillis > 1000) {\n                // validate that only one item is returned to subscriber in each iteration\n                assertThat(subscriber.valueCount() - i).isEqualTo(1);\n            }\n            // validate that the difference between the number of requests to backend\n            // and the number of returned results is always less than a fixed threshold\n            assertThat(rxClient.httpRequests.size() - subscriber.valueCount())\n                    .isLessThanOrEqualTo(Queues.SMALL_BUFFER_SIZE);\n\n            subscriber.requestMore(1);\n            i++;\n        }\n\n        subscriber.assertNoErrors();\n        subscriber.assertComplete();\n\n        assertThat(subscriber.valueCount()).isEqualTo(createdDocuments.size());\n    }\n\n    @BeforeClass(groups = { \"long\" }, timeOut = 2 * SETUP_TIMEOUT)\n    public void beforeClass() throws Exception {\n\n        CosmosContainerRequestOptions options = new CosmosContainerRequestOptions();\n        client = new ClientUnderTestBuilder(clientBuilder()).build();\n        createdDatabase = getSharedCosmosDatabase(client);\n\n        createdCollection = createCollection(createdDatabase, getSinglePartitionCollectionDefinition(), options, 1000);\n\n        RxDocumentClientUnderTest rxClient = (RxDocumentClientUnderTest)CosmosBridgeInternal.getAsyncDocumentClient(client);\n\n        // increase throughput to max for a single partition collection to avoid throttling\n        // for bulk insert and later queries.\n        Offer offer = rxClient.queryOffers(\n                String.format(\"SELECT * FROM r WHERE r.offerResourceId = '%s'\",\n                        createdCollection.read().block().properties().resourceId())\n                        , null).take(1).map(FeedResponse::results).single().block().get(0);\n        offer.setThroughput(6000);\n        offer = rxClient.replaceOffer(offer).single().block().getResource();\n        assertThat(offer.getThroughput()).isEqualTo(6000);\n\n        ArrayList<CosmosItemProperties> docDefList = new ArrayList<>();\n        for(int i = 0; i < 1000; i++) {\n            docDefList.add(getDocumentDefinition(i));\n        }\n\n        createdDocuments = bulkInsertBlocking(createdCollection, docDefList);\n\n        waitIfNeededForReplicasToCatchUp(clientBuilder());\n        warmUp();\n    }\n\n    private void warmUp() {\n        // ensure collection is cached\n        FeedOptions options = new FeedOptions();\n        options.enableCrossPartitionQuery(true);\n        createdCollection.queryItems(\"SELECT * from r\", options).blockFirst();\n    }\n\n    // TODO: DANOBLE: Investigate DIRECT TCP performance issue\n    // NOTE: This method requires multiple SHUTDOWN_TIMEOUT intervals\n    // SEE: https://msdata.visualstudio.com/CosmosDB/_workitems/edit/367028https://msdata.visualstudio.com/CosmosDB/_workitems/edit/367028\n\n    @AfterClass(groups = { \"long\" }, timeOut = 2 * SHUTDOWN_TIMEOUT, alwaysRun = true)\n    public void afterClass() {\n        safeDeleteCollection(createdCollection);\n        safeClose(client);\n    }\n\n    private static CosmosItemProperties getDocumentDefinition(int cnt) {\n        String uuid = UUID.randomUUID().toString();\n        CosmosItemProperties doc = new CosmosItemProperties(String.format(\"{ \"\n                + \"\\\"id\\\": \\\"%s\\\", \"\n                + \"\\\"prop\\\" : %d, \"\n                + \"\\\"mypk\\\": \\\"%s\\\", \"\n                + \"\\\"sgmts\\\": [[6519456, 1471916863], [2498434, 1455671440]]\"\n                + \"}\"\n                , uuid, cnt, uuid));\n        return doc;\n    }\n}", "class_id": 0, "repo": "christopheranderson/azure-sdk-for-java", "file": "sdk/cosmos/microsoft-azure-cosmos/src/test/java/com/azure/data/cosmos/rx/BackPressureTest.java", "last_update_at": "2019-09-25T20:09:53+00:00", "question_id": "22ff4bad41f25fa56cf93ed3a5ed58682bdd5b26", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Ignore\npublic class BackPressureTest extends TestSuiteBase {\n    private static final int TIMEOUT = 200000;\n    private static final int SETUP_TIMEOUT = 60000;\n    private CosmosDatabase createdDatabase;\n    private CosmosContainer createdCollection;\n    private List<CosmosItemProperties> createdDocuments;\n    private CosmosClient client;\n    public String getCollectionLink() {\n        return TestUtils.getCollectionNameLink(createdDatabase.id(), createdCollection.id());\n    }\n    private static CosmosContainerProperties getSinglePartitionCollectionDefinition() {\n        PartitionKeyDefinition partitionKeyDef = new PartitionKeyDefinition();\n        ArrayList<String> paths = new ArrayList<String>();\n        paths.add(\"/mypk\");\n        partitionKeyDef.paths(paths);\n        CosmosContainerProperties collectionDefinition = new CosmosContainerProperties(UUID.randomUUID().toString(), partitionKeyDef);\n        return collectionDefinition;\n    }\n    @Factory(dataProvider = \"simpleClientBuildersWithDirectHttps\")\n    public BackPressureTest(CosmosClientBuilder clientBuilder) {\n        super(clientBuilder);\n    }\n    @Test(groups = { \"long\" }, timeOut = 3 * TIMEOUT)\n    public void readFeed() throws Exception {\n        FeedOptions options = new FeedOptions();\n        options.maxItemCount(1);\n        options.enableCrossPartitionQuery(true);\n        Flux<FeedResponse<CosmosItemProperties>> queryObservable = createdCollection.readAllItems(options);\n        RxDocumentClientUnderTest rxClient = (RxDocumentClientUnderTest)CosmosBridgeInternal.getAsyncDocumentClient(client);\n        rxClient.httpRequests.clear();\n        TestSubscriber<FeedResponse<CosmosItemProperties>> subscriber = new TestSubscriber<FeedResponse<CosmosItemProperties>>(1);\n        queryObservable.publishOn(Schedulers.elastic(), 1).subscribe(subscriber);\n        int sleepTimeInMillis = 10000; // 10 seconds\n        int i = 0;\n        // use a test subscriber and request for more result and sleep in between\n        while (subscriber.completions() == 0 && subscriber.getEvents().get(1).isEmpty()) {\n            TimeUnit.MILLISECONDS.sleep(sleepTimeInMillis);\n            sleepTimeInMillis /= 2;\n            if (sleepTimeInMillis > 1000) {\n                // validate that only one item is returned to subscriber in each iteration\n                assertThat(subscriber.valueCount() - i).isEqualTo(1);\n            }\n            // validate that only one item is returned to subscriber in each iteration\n            // validate that the difference between the number of requests to backend\n            // and the number of returned results is always less than a fixed threshold\n            assertThat(rxClient.httpRequests.size() - subscriber.valueCount())\n                .isLessThanOrEqualTo(Queues.SMALL_BUFFER_SIZE);\n            subscriber.requestMore(1);\n            i++;\n        }\n        subscriber.assertNoErrors();\n        subscriber.assertComplete();\n        assertThat(subscriber.valueCount()).isEqualTo(createdDocuments.size());\n    }\n    @Test(groups = { \"long\" }, timeOut = 3 * TIMEOUT)\n    public void query() throws Exception {\n        FeedOptions options = new FeedOptions();\n        options.maxItemCount(1);\n        options.enableCrossPartitionQuery(true);\n        Flux<FeedResponse<CosmosItemProperties>> queryObservable = createdCollection.queryItems(\"SELECT * from r\", options);\n        RxDocumentClientUnderTest rxClient = (RxDocumentClientUnderTest)CosmosBridgeInternal.getAsyncDocumentClient(client);\n        rxClient.httpRequests.clear();\n        TestSubscriber<FeedResponse<CosmosItemProperties>> subscriber = new TestSubscriber<FeedResponse<CosmosItemProperties>>(1);\n        queryObservable.publishOn(Schedulers.elastic(), 1).subscribe(subscriber);\n        int sleepTimeInMillis = 10000;\n        int i = 0;\n        // use a test subscriber and request for more result and sleep in between\n        while(subscriber.completions() == 0 && subscriber.getEvents().get(1).isEmpty()) {\n            TimeUnit.MILLISECONDS.sleep(sleepTimeInMillis);\n            sleepTimeInMillis /= 2;\n            if (sleepTimeInMillis > 1000) {\n                // validate that only one item is returned to subscriber in each iteration\n                assertThat(subscriber.valueCount() - i).isEqualTo(1);\n            }\n            // validate that the difference between the number of requests to backend\n            // and the number of returned results is always less than a fixed threshold\n            assertThat(rxClient.httpRequests.size() - subscriber.valueCount())\n                    .isLessThanOrEqualTo(Queues.SMALL_BUFFER_SIZE);\n            subscriber.requestMore(1);\n            i++;\n        }\n        subscriber.assertNoErrors();\n        subscriber.assertComplete();\n        assertThat(subscriber.valueCount()).isEqualTo(createdDocuments.size());\n    }\n    @BeforeClass(groups = { \"long\" }, timeOut = 2 * SETUP_TIMEOUT)\n    public void beforeClass() throws Exception {\n        CosmosContainerRequestOptions options = new CosmosContainerRequestOptions();\n        client = new ClientUnderTestBuilder(clientBuilder()).build();\n        createdDatabase = getSharedCosmosDatabase(client);\n        createdCollection = createCollection(createdDatabase, getSinglePartitionCollectionDefinition(), options, 1000);\n        RxDocumentClientUnderTest rxClient = (RxDocumentClientUnderTest)CosmosBridgeInternal.getAsyncDocumentClient(client);\n        // increase throughput to max for a single partition collection to avoid throttling\n        // for bulk insert and later queries.\n        Offer offer = rxClient.queryOffers(\n                String.format(\"SELECT * FROM r WHERE r.offerResourceId = '%s'\",\n                        createdCollection.read().block().properties().resourceId())\n                        , null).take(1).map(FeedResponse::results).single().block().get(0);\n        offer.setThroughput(6000);\n        offer = rxClient.replaceOffer(offer).single().block().getResource();\n        assertThat(offer.getThroughput()).isEqualTo(6000);\n        ArrayList<CosmosItemProperties> docDefList = new ArrayList<>();\n        for(int i = 0; i < 1000; i++) {\n            docDefList.add(getDocumentDefinition(i));\n        }\n        createdDocuments = bulkInsertBlocking(createdCollection, docDefList);\n        waitIfNeededForReplicasToCatchUp(clientBuilder());\n        warmUp();\n    }\n    private void warmUp() {\n        // ensure collection is cached\n        FeedOptions options = new FeedOptions();\n        options.enableCrossPartitionQuery(true);\n        createdCollection.queryItems(\"SELECT * from r\", options).blockFirst();\n    }\n    // TODO: DANOBLE: Investigate DIRECT TCP performance issue\n    // NOTE: This method requires multiple SHUTDOWN_TIMEOUT intervals\n    // SEE: https://msdata.visualstudio.com/CosmosDB/_workitems/edit/367028https://msdata.visualstudio.com/CosmosDB/_workitems/edit/367028\n    @AfterClass(groups = { \"long\" }, timeOut = 2 * SHUTDOWN_TIMEOUT, alwaysRun = true)\n    public void afterClass() {\n        safeDeleteCollection(createdCollection);\n        safeClose(client);\n    }\n    private static CosmosItemProperties getDocumentDefinition(int cnt) {\n        String uuid = UUID.randomUUID().toString();\n        CosmosItemProperties doc = new CosmosItemProperties(String.format(\"{ \"\n                + \"\\\"id\\\": \\\"%s\\\", \"\n                + \"\\\"prop\\\" : %d, \"\n                + \"\\\"mypk\\\": \\\"%s\\\", \"\n                + \"\\\"sgmts\\\": [[6519456, 1471916863], [2498434, 1455671440]]\"\n                + \"}\"\n                , uuid, cnt, uuid));\n        return doc;\n    }\n"]]}
{"hexsha": "2d8246dca5218444ffecab3e4892707a1c1ff186", "ext": "java", "lang": "Java", "content": "public class RangeSumOfBST {\n\n    static int sum = 0;\n\n    static public int rangeSumBST(TreeNode root, int L, int R) {\n        int sum1 = 0;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = queue.poll();\n                if (node.getVal() >= L && node.getVal() <= R) sum1 += node.getVal();\n                if (node.getLeft() != null) queue.offer(node.getLeft());\n                if (node.getRight() != null) queue.offer(node.getRight());\n            }\n        }\n        return sum1;\n    }\n\n    static public int rangeSumBST2(TreeNode root, int L, int R) {\n\n        if (root == null) return 0;\n\n        if (root.getVal() > R) rangeSumBST2(root.getLeft(), L, R);\n        if (root.getVal() < L) rangeSumBST2(root.getRight(), L, R);\n\n        return root.getVal() + rangeSumBST2(root.getRight(), L, R) + rangeSumBST2(root.getLeft(), L, R);\n\n    }\n\n\n    static void f(TreeNode root, int L, int R) {\n        if (root == null) return;\n        f(root.getLeft(), L, R);\n        if (root.getVal() >= L && root.getVal() <= R) sum += root.getVal();\n        f(root.getRight(), L, R);\n    }\n\n    static public void main(String[] args) {\n        TreeNode root = new TreeNode(10).setLeft(new TreeNode(5).setLeft(new TreeNode(3)).setRight(new TreeNode(7)))\n                .setRight(new TreeNode(15).setRight(new TreeNode(18)));\n\n        //System.out.println(rangeSumBST(root, 7, 15));\n        System.out.println(rangeSumBST2(root, 7, 15));\n\n    }\n}", "class_id": 0, "repo": "Junhua91/tornesol", "file": "algo-study/src/main/java/com/junhua/algorithm/leetcode/datastructure/tree/RangeSumOfBST.java", "last_update_at": "2019-11-04T03:40:01+00:00", "question_id": "2d8246dca5218444ffecab3e4892707a1c1ff186", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RangeSumOfBST {\n    static int sum = 0;\n    static public int rangeSumBST(TreeNode root, int L, int R) {\n        int sum1 = 0;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = queue.poll();\n                if (node.getVal() >= L && node.getVal() <= R) sum1 += node.getVal();\n                if (node.getLeft() != null) queue.offer(node.getLeft());\n                if (node.getRight() != null) queue.offer(node.getRight());\n            }\n        }\n        return sum1;\n    }\n    static public int rangeSumBST2(TreeNode root, int L, int R) {\n        if (root == null) return 0;\n        if (root.getVal() > R) rangeSumBST2(root.getLeft(), L, R);\n        if (root.getVal() < L) rangeSumBST2(root.getRight(), L, R);\n        return root.getVal() + rangeSumBST2(root.getRight(), L, R) + rangeSumBST2(root.getLeft(), L, R);\n    }\n    static void f(TreeNode root, int L, int R) {\n        if (root == null) return;\n        f(root.getLeft(), L, R);\n        if (root.getVal() >= L && root.getVal() <= R) sum += root.getVal();\n        f(root.getRight(), L, R);\n    }\n    static public void main(String[] args) {\n        TreeNode root = new TreeNode(10).setLeft(new TreeNode(5).setLeft(new TreeNode(3)).setRight(new TreeNode(7)))\n                .setRight(new TreeNode(15).setRight(new TreeNode(18)));\n        //System.out.println(rangeSumBST(root, 7, 15));\n        System.out.println(rangeSumBST2(root, 7, 15));\n    }\n"]]}
{"hexsha": "9afab408d56361520835ce0cd1c7a97c431f9d2a", "ext": "java", "lang": "Java", "content": "@Component\n@Order(-10)\npublic class ProxyFilter implements WebFilter {\n    private final static Pattern pattern = Pattern.compile(\n            \"(2[5][0-5]|2[0-4]\\\\d|1\\\\d{2}|\\\\d{1,2})\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d{2}|\\\\d{1,2})\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d{2}|\\\\d{1,2})\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d{2}|\\\\d{1,2})\");\n    private static Logger logger = LoggerFactory.getLogger(ProxyFilter.class);\n    private static AtomicLong SessionId = new AtomicLong(0L);\n    @Override\n    public Mono<Void> filter(ServerWebExchange serverWebExchange, WebFilterChain webFilterChain) {\n        serverWebExchange.getRequest().getHeaders();\n        GrpcConManger.getInstance().addSession(new SessionInfo(SessionId.incrementAndGet(), getIp(serverWebExchange)));\n        return webFilterChain.filter(serverWebExchange);\n    }\n\n    private static String getIp(ServerWebExchange exchange){\n        String ip;\n        ip = getIpFromHead(exchange.getRequest().getHeaders());\n        if(ip != null){\n            logger.debug(\"IP:{}\", ip);\n        }\n\n        ip = getValIp(exchange.getRequest().getHeaders().get(HttpHeaders.FROM));\n        if(ip != null){\n            logger.debug(\"IP:{}\", ip);\n            return ip;\n        }\n\n        if(exchange.getRequest().getRemoteAddress() != null){\n            ip = exchange.getRequest().getRemoteAddress().getHostString();\n            logger.debug(\"IP:{}\", ip);\n            return ip;\n        }\n\n        return ConstValues.IG_IP;\n    }\n\n    private static String getIpFromHead(HttpHeaders headers){\n        String[] headNames = new String[]{\"X-Real-IP\", \"X-Forwarded-For\", \"Proxy-Client-IP\",\n                                          \"WL-Proxy-Client-IP\",\"HTTP_CLIENT_IP\",\"HTTP_X_FORWARDED_FOR\"};\n        for (String n:headNames){\n            List<String> list = headers.get(n);\n            String ip = getValIp(list);\n            if(ip != null){\n                return ip;\n            }\n        }\n\n        return null;\n    }\n\n    private static String getValIp(List<String> list){\n        if(list == null){\n            return null;\n        }\n\n        for(String ip:list){\n            if(isValidIP(ip)){\n                return ip;\n            }\n        }\n        return null;\n    }\n\n    private static boolean isValidIP(String ip){\n        if((ip == null) || ip.isEmpty()){\n            return false;\n        }\n\n        Matcher matcher = pattern.matcher(ip);\n        return matcher.matches();\n    }\n}", "class_id": 0, "repo": "ZhiYu2018/grpc", "file": "grpc-proxy/src/main/java/com/gexiang/ProxyFilter.java", "last_update_at": "2019-09-18T14:51:21+00:00", "question_id": "9afab408d56361520835ce0cd1c7a97c431f9d2a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\n@Order(-10)\npublic class ProxyFilter implements WebFilter {\n    private final static Pattern pattern = Pattern.compile(\n            \"(2[5][0-5]|2[0-4]\\\\d|1\\\\d{2}|\\\\d{1,2})\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d{2}|\\\\d{1,2})\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d{2}|\\\\d{1,2})\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d{2}|\\\\d{1,2})\");\n    private static Logger logger = LoggerFactory.getLogger(ProxyFilter.class);\n    private static AtomicLong SessionId = new AtomicLong(0L);\n    @Override\n    public Mono<Void> filter(ServerWebExchange serverWebExchange, WebFilterChain webFilterChain) {\n        serverWebExchange.getRequest().getHeaders();\n        GrpcConManger.getInstance().addSession(new SessionInfo(SessionId.incrementAndGet(), getIp(serverWebExchange)));\n        return webFilterChain.filter(serverWebExchange);\n    }\n    private static String getIp(ServerWebExchange exchange){\n        String ip;\n        ip = getIpFromHead(exchange.getRequest().getHeaders());\n        if(ip != null){\n            logger.debug(\"IP:{}\", ip);\n        }\n        ip = getValIp(exchange.getRequest().getHeaders().get(HttpHeaders.FROM));\n        if(ip != null){\n            logger.debug(\"IP:{}\", ip);\n            return ip;\n        }\n        if(exchange.getRequest().getRemoteAddress() != null){\n            ip = exchange.getRequest().getRemoteAddress().getHostString();\n            logger.debug(\"IP:{}\", ip);\n            return ip;\n        }\n        return ConstValues.IG_IP;\n    }\n    private static String getIpFromHead(HttpHeaders headers){\n        String[] headNames = new String[]{\"X-Real-IP\", \"X-Forwarded-For\", \"Proxy-Client-IP\",\n                                          \"WL-Proxy-Client-IP\",\"HTTP_CLIENT_IP\",\"HTTP_X_FORWARDED_FOR\"};\n        for (String n:headNames){\n            List<String> list = headers.get(n);\n            String ip = getValIp(list);\n            if(ip != null){\n                return ip;\n            }\n        }\n        return null;\n    }\n    private static String getValIp(List<String> list){\n        if(list == null){\n            return null;\n        }\n        for(String ip:list){\n            if(isValidIP(ip)){\n                return ip;\n            }\n        }\n        return null;\n    }\n    private static boolean isValidIP(String ip){\n        if((ip == null) || ip.isEmpty()){\n            return false;\n        }\n        Matcher matcher = pattern.matcher(ip);\n        return matcher.matches();\n    }\n"]]}
{"hexsha": "5d9065b7917c993b8a7ad8ee635ff4bebdbd5189", "ext": "java", "lang": "Java", "content": "public class MultisigAccountGraphInfoDTO {\n  @SerializedName(\"level\")\n  private Integer level = null;\n\n  @SerializedName(\"multisigEntries\")\n  private List<MultisigAccountInfoDTO> multisigEntries = new ArrayList<MultisigAccountInfoDTO>();\n\n  public MultisigAccountGraphInfoDTO level(Integer level) {\n    this.level = level;\n    return this;\n  }\n\n   /**\n   * Get level\n   * @return level\n  **/\n  @ApiModelProperty(required = true, value = \"\")\n  public Integer getLevel() {\n    return level;\n  }\n\n  public void setLevel(Integer level) {\n    this.level = level;\n  }\n\n  public MultisigAccountGraphInfoDTO multisigEntries(List<MultisigAccountInfoDTO> multisigEntries) {\n    this.multisigEntries = multisigEntries;\n    return this;\n  }\n\n  public MultisigAccountGraphInfoDTO addMultisigEntriesItem(MultisigAccountInfoDTO multisigEntriesItem) {\n    this.multisigEntries.add(multisigEntriesItem);\n    return this;\n  }\n\n   /**\n   * Get multisigEntries\n   * @return multisigEntries\n  **/\n  @ApiModelProperty(required = true, value = \"\")\n  public List<MultisigAccountInfoDTO> getMultisigEntries() {\n    return multisigEntries;\n  }\n\n  public void setMultisigEntries(List<MultisigAccountInfoDTO> multisigEntries) {\n    this.multisigEntries = multisigEntries;\n  }\n\n\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    MultisigAccountGraphInfoDTO multisigAccountGraphInfoDTO = (MultisigAccountGraphInfoDTO) o;\n    return Objects.equals(this.level, multisigAccountGraphInfoDTO.level) &&\n        Objects.equals(this.multisigEntries, multisigAccountGraphInfoDTO.multisigEntries);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(level, multisigEntries);\n  }\n\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class MultisigAccountGraphInfoDTO {\\n\");\n    \n    sb.append(\"    level: \").append(toIndentedString(level)).append(\"\\n\");\n    sb.append(\"    multisigEntries: \").append(toIndentedString(multisigEntries)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n\n}", "class_id": 0, "repo": "alexjavabraz/nem2-sdk-java", "file": "src/main/java/io/nem/sdk/infrastructure/MultisigAccountGraphInfoDTO.java", "last_update_at": "2019-02-13T22:06:16+00:00", "question_id": "5d9065b7917c993b8a7ad8ee635ff4bebdbd5189", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MultisigAccountGraphInfoDTO {\n  @SerializedName(\"level\")\n  private Integer level = null;\n  @SerializedName(\"multisigEntries\")\n  private List<MultisigAccountInfoDTO> multisigEntries = new ArrayList<MultisigAccountInfoDTO>();\n  public MultisigAccountGraphInfoDTO level(Integer level) {\n    this.level = level;\n    return this;\n  }\n   /**\n   * Get level\n   * @return level\n  **/\n  @ApiModelProperty(required = true, value = \"\")\n  public Integer getLevel() {\n    return level;\n  }\n  public void setLevel(Integer level) {\n    this.level = level;\n  }\n  public MultisigAccountGraphInfoDTO multisigEntries(List<MultisigAccountInfoDTO> multisigEntries) {\n    this.multisigEntries = multisigEntries;\n    return this;\n  }\n  public MultisigAccountGraphInfoDTO addMultisigEntriesItem(MultisigAccountInfoDTO multisigEntriesItem) {\n    this.multisigEntries.add(multisigEntriesItem);\n    return this;\n  }\n   /**\n   * Get multisigEntries\n   * @return multisigEntries\n  **/\n  @ApiModelProperty(required = true, value = \"\")\n  public List<MultisigAccountInfoDTO> getMultisigEntries() {\n    return multisigEntries;\n  }\n  public void setMultisigEntries(List<MultisigAccountInfoDTO> multisigEntries) {\n    this.multisigEntries = multisigEntries;\n  }\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    MultisigAccountGraphInfoDTO multisigAccountGraphInfoDTO = (MultisigAccountGraphInfoDTO) o;\n    return Objects.equals(this.level, multisigAccountGraphInfoDTO.level) &&\n        Objects.equals(this.multisigEntries, multisigAccountGraphInfoDTO.multisigEntries);\n  }\n  @Override\n  public int hashCode() {\n    return Objects.hash(level, multisigEntries);\n  }\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class MultisigAccountGraphInfoDTO {\\n\");\n    sb.append(\"    level: \").append(toIndentedString(level)).append(\"\\n\");\n    sb.append(\"    multisigEntries: \").append(toIndentedString(multisigEntries)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n"]]}
{"hexsha": "e18c9d1c5dde3292c983cdccb6c492213c06650a", "ext": "java", "lang": "Java", "content": "@SuppressWarnings({\"ConstantConditions\", \"Duplicates\"})\npublic class GeneratorRecipes extends RecipeProvider implements IConditionBuilder {\n\n    public GeneratorRecipes(DataGenerator generator) {\n        super(generator);\n    }\n\n    @Override\n    protected void registerRecipes(Consumer<IFinishedRecipe> consumer) {\n        registerBlockRecipes(consumer);\n        registerItemRecipes(consumer);\n    }\n\n    private void registerBlockRecipes(Consumer<IFinishedRecipe> consumer) {\n\n        ConditionalRecipe.builder()\n                .addCondition(new ConditionModuleEnabled(\"projector\"))\n                .addRecipe(\n                        ShapedRecipeBuilder.shapedRecipe(ModBlocks.MAGNETIC_PROJECTOR.get())\n                                .patternLine(\"IPI\")\n                                .patternLine(\"GRG\")\n                                .patternLine(\"IHI\")\n                                .key('P', Blocks.GLASS_PANE)\n                                .key('G', Items.GOLD_INGOT)\n                                .key('I', Items.IRON_INGOT)\n                                .key('R', ModItems.MAGNETITE.get())\n                                .key('H', Blocks.HOPPER)\n                                .addCriterion(\"has_magnetite\", hasItem(ModItems.MAGNETITE.get()))\n                                ::build\n                ).build(consumer, ModBlocks.MAGNETIC_PROJECTOR.get().getRegistryName());\n\n\n        ConditionalRecipe.builder()\n                .addCondition(new ConditionModuleEnabled(\"insulator\"))\n                .addRecipe(\n                        ShapedRecipeBuilder.shapedRecipe(ModBlocks.MAGNETIC_INSULATOR.get())\n                                .patternLine(\"MIM\")\n                                .patternLine(\"GIG\")\n                                .patternLine(\"III\")\n                                .key('G', Items.GOLD_INGOT)\n                                .key('I', Items.IRON_INGOT)\n                                .key('M', ModItems.MAGNETITE.get())\n                                .addCriterion(\"has_magnetite\", hasItem(ModItems.MAGNETITE.get()))\n                                ::build\n                ).build(consumer, ModBlocks.MAGNETIC_INSULATOR.get().getRegistryName());\n\n    }\n\n    private void registerItemRecipes(Consumer<IFinishedRecipe> consumer) {\n        addMagnetD(consumer, ModItems.MAGNET_DURABILITY_STONE.get(), Blocks.COBBLESTONE.asItem());\n        addMagnetD(consumer, ModItems.MAGNET_DURABILITY_IRON.get(), Items.IRON_INGOT);\n        addMagnetD(consumer, ModItems.MAGNET_DURABILITY_REDSTONE.get(), Items.REDSTONE);\n        addMagnetD(consumer, ModItems.MAGNET_DURABILITY_GOLD.get(), Items.GOLD_INGOT);\n        addMagnetD(consumer, ModItems.MAGNET_DURABILITY_OBSIDIAN.get(), Blocks.OBSIDIAN.asItem());\n        addMagnetD(consumer, ModItems.MAGNET_DURABILITY_LAPIS.get(), Items.LAPIS_LAZULI);\n        addMagnetD(consumer, ModItems.MAGNET_DURABILITY_DIAMOND.get(), Items.DIAMOND);\n        addMagnetD(consumer, ModItems.MAGNET_DURABILITY_EMERALD.get(), Items.EMERALD);\n        addMagnetDM(consumer, ModItems.MAGNET_MAGIC_DURABILITY_STONE.get(), ModItems.MAGNET_DURABILITY_STONE.get());\n        addMagnetDM(consumer, ModItems.MAGNET_MAGIC_DURABILITY_IRON.get(), ModItems.MAGNET_DURABILITY_IRON.get());\n        addMagnetDM(consumer, ModItems.MAGNET_MAGIC_DURABILITY_REDSTONE.get(), ModItems.MAGNET_DURABILITY_REDSTONE.get());\n        addMagnetDM(consumer, ModItems.MAGNET_MAGIC_DURABILITY_GOLD.get(), ModItems.MAGNET_DURABILITY_GOLD.get());\n        addMagnetDM(consumer, ModItems.MAGNET_MAGIC_DURABILITY_OBSIDIAN.get(), ModItems.MAGNET_DURABILITY_OBSIDIAN.get());\n        addMagnetDM(consumer, ModItems.MAGNET_MAGIC_DURABILITY_LAPIS.get(), ModItems.MAGNET_DURABILITY_LAPIS.get());\n        addMagnetDM(consumer, ModItems.MAGNET_MAGIC_DURABILITY_DIAMOND.get(), ModItems.MAGNET_DURABILITY_DIAMOND.get());\n        addMagnetDM(consumer, ModItems.MAGNET_MAGIC_DURABILITY_EMERALD.get(), ModItems.MAGNET_DURABILITY_EMERALD.get());\n\n        addMagnetE_start(consumer, ModItems.MAGNET_ENERGY_LEADSTONE.get());\n        addMagnetE(consumer, ModItems.MAGNET_ENERGY_HARDENED.get(), ModItems.MAGNET_ENERGY_LEADSTONE.get(), Blocks.OBSIDIAN.asItem(), Items.IRON_INGOT);\n        addMagnetE(consumer, ModItems.MAGNET_ENERGY_REINFORCED.get(), ModItems.MAGNET_ENERGY_HARDENED.get(), Items.GOLD_INGOT, Blocks.OBSIDIAN.asItem());\n        addMagnetE(consumer, ModItems.MAGNET_ENERGY_SIGNALUM.get(), ModItems.MAGNET_ENERGY_REINFORCED.get(), Items.REDSTONE, Items.GOLD_INGOT);\n        addMagnetE(consumer, ModItems.MAGNET_ENERGY_RESONANT.get(), ModItems.MAGNET_ENERGY_SIGNALUM.get(), Items.ENDER_PEARL, Items.DIAMOND);\n        addMagnetEM(consumer, ModItems.MAGNET_MAGIC_ENERGY_LEADSTONE.get(), ModItems.MAGNET_ENERGY_LEADSTONE.get());\n        addMagnetEM(consumer, ModItems.MAGNET_MAGIC_ENERGY_HARDENED.get(), ModItems.MAGNET_ENERGY_HARDENED.get());\n        addMagnetEM(consumer, ModItems.MAGNET_MAGIC_ENERGY_REINFORCED.get(), ModItems.MAGNET_ENERGY_REINFORCED.get());\n        addMagnetEM(consumer, ModItems.MAGNET_MAGIC_ENERGY_SIGNALUM.get(), ModItems.MAGNET_ENERGY_SIGNALUM.get());\n        addMagnetEM(consumer, ModItems.MAGNET_MAGIC_ENERGY_RESONANT.get(), ModItems.MAGNET_ENERGY_RESONANT.get());\n\n        addMagnetF(consumer, ModItems.MAGNET_FREE.get());\n        addMagnetFM(consumer, ModItems.MAGNET_MAGIC_FREE.get(), ModItems.MAGNET_FREE.get());\n\n    }\n\n    private void addMagnetD(Consumer<IFinishedRecipe> consumer, Item magnet, Item resource) {\n        ConditionalRecipe.builder()\n                .addCondition(new ConditionModuleEnabled(\"vanilla\"))\n                .addRecipe(\n                        ShapedRecipeBuilder.shapedRecipe(magnet)\n                                .patternLine(\"RIR\")\n                                .patternLine(\"I I\")\n                                .patternLine(\"M M\")\n                                .key('M', ModItems.MAGNETITE.get())\n                                .key('I', Items.IRON_INGOT)\n                                .key('R', resource)\n                                .addCriterion(\"has_magnetite\", hasItem(ModItems.MAGNETITE.get()))\n                                ::build\n                ).build(consumer, magnet.getRegistryName());\n    }\n\n    private void addMagnetDM(Consumer<IFinishedRecipe> consumer, Item magnet, Item magnetPrior) {\n        ConditionalRecipe.builder()\n                .addCondition(new ConditionModuleEnabled(\"vanilla_magic\"))\n                .addRecipe(\n                        ShapedRecipeBuilder.shapedRecipe(magnet)\n                                .patternLine(\"GEG\")\n                                .patternLine(\"RMR\")\n                                .patternLine(\"GEG\")\n                                .key('R', ModItems.MAGNETITE.get())\n                                .key('G', Items.GOLD_INGOT)\n                                .key('E', Items.ENDER_PEARL)\n                                .key('M', magnetPrior)\n                                .addCriterion(\"has_magnetite\", hasItem(ModItems.MAGNETITE.get()))\n                                ::build\n                ).build(consumer, magnet.getRegistryName());\n    }\n\n    private void addMagnetE_start(Consumer<IFinishedRecipe> consumer, Item magnet) {\n        ConditionalRecipe.builder()\n                .addCondition(new ConditionModuleEnabled(\"te\"))\n                .addRecipe(\n                        ShapedRecipeBuilder.shapedRecipe(magnet)\n                                .patternLine(\"INI\")\n                                .patternLine(\"IRI\")\n                                .patternLine(\"IGI\")\n                                .key('N', Items.GOLD_NUGGET)\n                                .key('I', Items.IRON_INGOT)\n                                .key('G', Items.GOLD_INGOT)\n                                .key('R', Items.REDSTONE)\n                                .addCriterion(\"has_redstone\", hasItem(Items.REDSTONE))\n                                ::build\n                ).build(consumer, magnet.getRegistryName());\n    }\n\n    private void addMagnetE(Consumer<IFinishedRecipe> consumer, Item magnet, Item magnetPrior, Item resourceOne, Item resourceTwo) {\n        ConditionalRecipe.builder()\n                .addCondition(new ConditionModuleEnabled(\"te\"))\n                .addRecipe(\n                        ShapedRecipeBuilder.shapedRecipe(magnet)\n                                .patternLine(\" A \")\n                                .patternLine(\"BMB\")\n                                .patternLine(\" A \")\n                                .key('M', magnetPrior)\n                                .key('A', resourceOne)\n                                .key('B', resourceTwo)\n                                .addCriterion(\"has_magnet\", hasItem(magnetPrior))\n                                ::build\n                ).build(consumer, magnet.getRegistryName());\n    }\n\n    private void addMagnetEM(Consumer<IFinishedRecipe> consumer, Item magnet, Item magnetPrior) {\n        ConditionalRecipe.builder()\n                .addCondition(new ConditionModuleEnabled(\"te_magic\"))\n                .addRecipe(\n                        ShapedRecipeBuilder.shapedRecipe(magnet)\n                                .patternLine(\"GEG\")\n                                .patternLine(\"RMR\")\n                                .patternLine(\"GEG\")\n                                .key('R', Items.REDSTONE)\n                                .key('G', Items.GOLD_INGOT)\n                                .key('E', Items.ENDER_PEARL)\n                                .key('M', magnetPrior)\n                                .addCriterion(\"has_redstone\", hasItem(Items.REDSTONE))\n                                ::build\n                ).build(consumer, magnet.getRegistryName());\n    }\n\n    private void addMagnetF(Consumer<IFinishedRecipe> consumer, Item magnet) {\n        ConditionalRecipe.builder()\n                .addCondition(new ConditionModuleEnabled(\"cursed\"))\n                .addRecipe(\n                        ShapedRecipeBuilder.shapedRecipe(magnet)\n                                .patternLine(\"DGD\")\n                                .patternLine(\"ISI\")\n                                .patternLine(\"R R\")\n                                .key('D', Items.DIAMOND)\n                                .key('G', Items.GHAST_TEAR)\n                                .key('I', Items.IRON_INGOT)\n                                .key('S', Blocks.SOUL_SAND.asItem())\n                                .key('R', ModItems.MAGNETITE.get())\n                                .addCriterion(\"has_magnetite\", hasItem(ModItems.MAGNETITE.get()))\n                                ::build\n                ).build(consumer, magnet.getRegistryName());\n    }\n\n    private void addMagnetFM(Consumer<IFinishedRecipe> consumer, Item magnet, Item magnetPrior) {\n        ConditionalRecipe.builder()\n                .addCondition(new ConditionModuleEnabled(\"cursed_magic\"))\n                .addRecipe(\n                        ShapedRecipeBuilder.shapedRecipe(magnet)\n                                .patternLine(\"GEG\")\n                                .patternLine(\"RMR\")\n                                .patternLine(\"GEG\")\n                                .key('R', ModItems.MAGNETITE.get())\n                                .key('G', Items.GOLD_INGOT)\n                                .key('E', Items.ENDER_PEARL)\n                                .key('M', magnetPrior)\n                                .addCriterion(\"has_magnetite\", hasItem(ModItems.MAGNETITE.get()))\n                                ::build\n                ).build(consumer, magnet.getRegistryName());\n    }\n\n}", "class_id": 0, "repo": "MiningMark48/Magnets", "file": "src/main/java/com/miningmark48/tieredmagnets/data/GeneratorRecipes.java", "last_update_at": "2019-07-13T17:31:59+00:00", "question_id": "e18c9d1c5dde3292c983cdccb6c492213c06650a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings({\"ConstantConditions\", \"Duplicates\"})\npublic class GeneratorRecipes extends RecipeProvider implements IConditionBuilder {\n    public GeneratorRecipes(DataGenerator generator) {\n        super(generator);\n    }\n    @Override\n    protected void registerRecipes(Consumer<IFinishedRecipe> consumer) {\n        registerBlockRecipes(consumer);\n        registerItemRecipes(consumer);\n    }\n    private void registerBlockRecipes(Consumer<IFinishedRecipe> consumer) {\n        ConditionalRecipe.builder()\n                .addCondition(new ConditionModuleEnabled(\"projector\"))\n                .addRecipe(\n                        ShapedRecipeBuilder.shapedRecipe(ModBlocks.MAGNETIC_PROJECTOR.get())\n                                .patternLine(\"IPI\")\n                                .patternLine(\"GRG\")\n                                .patternLine(\"IHI\")\n                                .key('P', Blocks.GLASS_PANE)\n                                .key('G', Items.GOLD_INGOT)\n                                .key('I', Items.IRON_INGOT)\n                                .key('R', ModItems.MAGNETITE.get())\n                                .key('H', Blocks.HOPPER)\n                                .addCriterion(\"has_magnetite\", hasItem(ModItems.MAGNETITE.get()))\n                                ::build\n                ).build(consumer, ModBlocks.MAGNETIC_PROJECTOR.get().getRegistryName());\n        ConditionalRecipe.builder()\n                .addCondition(new ConditionModuleEnabled(\"insulator\"))\n                .addRecipe(\n                        ShapedRecipeBuilder.shapedRecipe(ModBlocks.MAGNETIC_INSULATOR.get())\n                                .patternLine(\"MIM\")\n                                .patternLine(\"GIG\")\n                                .patternLine(\"III\")\n                                .key('G', Items.GOLD_INGOT)\n                                .key('I', Items.IRON_INGOT)\n                                .key('M', ModItems.MAGNETITE.get())\n                                .addCriterion(\"has_magnetite\", hasItem(ModItems.MAGNETITE.get()))\n                                ::build\n                ).build(consumer, ModBlocks.MAGNETIC_INSULATOR.get().getRegistryName());\n    }\n    private void registerItemRecipes(Consumer<IFinishedRecipe> consumer) {\n        addMagnetD(consumer, ModItems.MAGNET_DURABILITY_STONE.get(), Blocks.COBBLESTONE.asItem());\n        addMagnetD(consumer, ModItems.MAGNET_DURABILITY_IRON.get(), Items.IRON_INGOT);\n        addMagnetD(consumer, ModItems.MAGNET_DURABILITY_REDSTONE.get(), Items.REDSTONE);\n        addMagnetD(consumer, ModItems.MAGNET_DURABILITY_GOLD.get(), Items.GOLD_INGOT);\n        addMagnetD(consumer, ModItems.MAGNET_DURABILITY_OBSIDIAN.get(), Blocks.OBSIDIAN.asItem());\n        addMagnetD(consumer, ModItems.MAGNET_DURABILITY_LAPIS.get(), Items.LAPIS_LAZULI);\n        addMagnetD(consumer, ModItems.MAGNET_DURABILITY_DIAMOND.get(), Items.DIAMOND);\n        addMagnetD(consumer, ModItems.MAGNET_DURABILITY_EMERALD.get(), Items.EMERALD);\n        addMagnetDM(consumer, ModItems.MAGNET_MAGIC_DURABILITY_STONE.get(), ModItems.MAGNET_DURABILITY_STONE.get());\n        addMagnetDM(consumer, ModItems.MAGNET_MAGIC_DURABILITY_IRON.get(), ModItems.MAGNET_DURABILITY_IRON.get());\n        addMagnetDM(consumer, ModItems.MAGNET_MAGIC_DURABILITY_REDSTONE.get(), ModItems.MAGNET_DURABILITY_REDSTONE.get());\n        addMagnetDM(consumer, ModItems.MAGNET_MAGIC_DURABILITY_GOLD.get(), ModItems.MAGNET_DURABILITY_GOLD.get());\n        addMagnetDM(consumer, ModItems.MAGNET_MAGIC_DURABILITY_OBSIDIAN.get(), ModItems.MAGNET_DURABILITY_OBSIDIAN.get());\n        addMagnetDM(consumer, ModItems.MAGNET_MAGIC_DURABILITY_LAPIS.get(), ModItems.MAGNET_DURABILITY_LAPIS.get());\n        addMagnetDM(consumer, ModItems.MAGNET_MAGIC_DURABILITY_DIAMOND.get(), ModItems.MAGNET_DURABILITY_DIAMOND.get());\n        addMagnetDM(consumer, ModItems.MAGNET_MAGIC_DURABILITY_EMERALD.get(), ModItems.MAGNET_DURABILITY_EMERALD.get());\n        addMagnetE_start(consumer, ModItems.MAGNET_ENERGY_LEADSTONE.get());\n        addMagnetE(consumer, ModItems.MAGNET_ENERGY_HARDENED.get(), ModItems.MAGNET_ENERGY_LEADSTONE.get(), Blocks.OBSIDIAN.asItem(), Items.IRON_INGOT);\n        addMagnetE(consumer, ModItems.MAGNET_ENERGY_REINFORCED.get(), ModItems.MAGNET_ENERGY_HARDENED.get(), Items.GOLD_INGOT, Blocks.OBSIDIAN.asItem());\n        addMagnetE(consumer, ModItems.MAGNET_ENERGY_SIGNALUM.get(), ModItems.MAGNET_ENERGY_REINFORCED.get(), Items.REDSTONE, Items.GOLD_INGOT);\n        addMagnetE(consumer, ModItems.MAGNET_ENERGY_RESONANT.get(), ModItems.MAGNET_ENERGY_SIGNALUM.get(), Items.ENDER_PEARL, Items.DIAMOND);\n        addMagnetEM(consumer, ModItems.MAGNET_MAGIC_ENERGY_LEADSTONE.get(), ModItems.MAGNET_ENERGY_LEADSTONE.get());\n        addMagnetEM(consumer, ModItems.MAGNET_MAGIC_ENERGY_HARDENED.get(), ModItems.MAGNET_ENERGY_HARDENED.get());\n        addMagnetEM(consumer, ModItems.MAGNET_MAGIC_ENERGY_REINFORCED.get(), ModItems.MAGNET_ENERGY_REINFORCED.get());\n        addMagnetEM(consumer, ModItems.MAGNET_MAGIC_ENERGY_SIGNALUM.get(), ModItems.MAGNET_ENERGY_SIGNALUM.get());\n        addMagnetEM(consumer, ModItems.MAGNET_MAGIC_ENERGY_RESONANT.get(), ModItems.MAGNET_ENERGY_RESONANT.get());\n        addMagnetF(consumer, ModItems.MAGNET_FREE.get());\n        addMagnetFM(consumer, ModItems.MAGNET_MAGIC_FREE.get(), ModItems.MAGNET_FREE.get());\n    }\n    private void addMagnetD(Consumer<IFinishedRecipe> consumer, Item magnet, Item resource) {\n        ConditionalRecipe.builder()\n                .addCondition(new ConditionModuleEnabled(\"vanilla\"))\n                .addRecipe(\n                        ShapedRecipeBuilder.shapedRecipe(magnet)\n                                .patternLine(\"RIR\")\n                                .patternLine(\"I I\")\n                                .patternLine(\"M M\")\n                                .key('M', ModItems.MAGNETITE.get())\n                                .key('I', Items.IRON_INGOT)\n                                .key('R', resource)\n                                .addCriterion(\"has_magnetite\", hasItem(ModItems.MAGNETITE.get()))\n                                ::build\n                ).build(consumer, magnet.getRegistryName());\n    }\n    private void addMagnetDM(Consumer<IFinishedRecipe> consumer, Item magnet, Item magnetPrior) {\n        ConditionalRecipe.builder()\n                .addCondition(new ConditionModuleEnabled(\"vanilla_magic\"))\n                .addRecipe(\n                        ShapedRecipeBuilder.shapedRecipe(magnet)\n                                .patternLine(\"GEG\")\n                                .patternLine(\"RMR\")\n                                .patternLine(\"GEG\")\n                                .key('R', ModItems.MAGNETITE.get())\n                                .key('G', Items.GOLD_INGOT)\n                                .key('E', Items.ENDER_PEARL)\n                                .key('M', magnetPrior)\n                                .addCriterion(\"has_magnetite\", hasItem(ModItems.MAGNETITE.get()))\n                                ::build\n                ).build(consumer, magnet.getRegistryName());\n    }\n    private void addMagnetE_start(Consumer<IFinishedRecipe> consumer, Item magnet) {\n        ConditionalRecipe.builder()\n                .addCondition(new ConditionModuleEnabled(\"te\"))\n                .addRecipe(\n                        ShapedRecipeBuilder.shapedRecipe(magnet)\n                                .patternLine(\"INI\")\n                                .patternLine(\"IRI\")\n                                .patternLine(\"IGI\")\n                                .key('N', Items.GOLD_NUGGET)\n                                .key('I', Items.IRON_INGOT)\n                                .key('G', Items.GOLD_INGOT)\n                                .key('R', Items.REDSTONE)\n                                .addCriterion(\"has_redstone\", hasItem(Items.REDSTONE))\n                                ::build\n                ).build(consumer, magnet.getRegistryName());\n    }\n    private void addMagnetE(Consumer<IFinishedRecipe> consumer, Item magnet, Item magnetPrior, Item resourceOne, Item resourceTwo) {\n        ConditionalRecipe.builder()\n                .addCondition(new ConditionModuleEnabled(\"te\"))\n                .addRecipe(\n                        ShapedRecipeBuilder.shapedRecipe(magnet)\n                                .patternLine(\" A \")\n                                .patternLine(\"BMB\")\n                                .patternLine(\" A \")\n                                .key('M', magnetPrior)\n                                .key('A', resourceOne)\n                                .key('B', resourceTwo)\n                                .addCriterion(\"has_magnet\", hasItem(magnetPrior))\n                                ::build\n                ).build(consumer, magnet.getRegistryName());\n    }\n    private void addMagnetEM(Consumer<IFinishedRecipe> consumer, Item magnet, Item magnetPrior) {\n        ConditionalRecipe.builder()\n                .addCondition(new ConditionModuleEnabled(\"te_magic\"))\n                .addRecipe(\n                        ShapedRecipeBuilder.shapedRecipe(magnet)\n                                .patternLine(\"GEG\")\n                                .patternLine(\"RMR\")\n                                .patternLine(\"GEG\")\n                                .key('R', Items.REDSTONE)\n                                .key('G', Items.GOLD_INGOT)\n                                .key('E', Items.ENDER_PEARL)\n                                .key('M', magnetPrior)\n                                .addCriterion(\"has_redstone\", hasItem(Items.REDSTONE))\n                                ::build\n                ).build(consumer, magnet.getRegistryName());\n    }\n    private void addMagnetF(Consumer<IFinishedRecipe> consumer, Item magnet) {\n        ConditionalRecipe.builder()\n                .addCondition(new ConditionModuleEnabled(\"cursed\"))\n                .addRecipe(\n                        ShapedRecipeBuilder.shapedRecipe(magnet)\n                                .patternLine(\"DGD\")\n                                .patternLine(\"ISI\")\n                                .patternLine(\"R R\")\n                                .key('D', Items.DIAMOND)\n                                .key('G', Items.GHAST_TEAR)\n                                .key('I', Items.IRON_INGOT)\n                                .key('S', Blocks.SOUL_SAND.asItem())\n                                .key('R', ModItems.MAGNETITE.get())\n                                .addCriterion(\"has_magnetite\", hasItem(ModItems.MAGNETITE.get()))\n                                ::build\n                ).build(consumer, magnet.getRegistryName());\n    }\n    private void addMagnetFM(Consumer<IFinishedRecipe> consumer, Item magnet, Item magnetPrior) {\n        ConditionalRecipe.builder()\n                .addCondition(new ConditionModuleEnabled(\"cursed_magic\"))\n                .addRecipe(\n                        ShapedRecipeBuilder.shapedRecipe(magnet)\n                                .patternLine(\"GEG\")\n                                .patternLine(\"RMR\")\n                                .patternLine(\"GEG\")\n                                .key('R', ModItems.MAGNETITE.get())\n                                .key('G', Items.GOLD_INGOT)\n                                .key('E', Items.ENDER_PEARL)\n                                .key('M', magnetPrior)\n                                .addCriterion(\"has_magnetite\", hasItem(ModItems.MAGNETITE.get()))\n                                ::build\n                ).build(consumer, magnet.getRegistryName());\n    }\n"]]}
{"hexsha": "0816306c2537cf28670a6f8f9080b30529052468", "ext": "java", "lang": "Java", "content": "public class ExtractData\r\n{\r\n\r\n    public ExtractData(){}\r\n\r\n    public ArrayList<String> course() throws IOException\r\n    {\r\n        ArrayList<String> course = new ArrayList<String>();\r\n        //Get scanner instance\r\n        Scanner scan = new Scanner(new File(\"D:\\\\Documents\\\\UUM\\\\Sem 4\\\\Real-time Programming\\\\STIW3054\\\\rtass2\\\\Ass2pdf.csv\"));\r\n         \r\n        //Set the delimiter used in file\r\n        scan.useDelimiter(\"[;\\n]\");\r\n        String word= \" \";\r\n        \r\n\r\n        while(scan.hasNext())\r\n        {\r\n            word=scan.next();\r\n            if(!word.contains(\"BIL.\")){\r\n                if(!word.contains(\"CODE\")){\r\n                    if(!word.contains(\"COURSE\")){\r\n                        if(!word.contains(\"DATE/TIME\")){\r\n                            course.add(word);//add only data not include (BIL. , CODE , COURSE ,DATE/TIME)\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        scan.close();\r\n        return course;\r\n    }\r\n}", "class_id": 0, "repo": "AhKitt/252911-STIW3054-A182-A2", "file": "rtass2/src/main/java/com/rtass2/demo/ExtractData.java", "last_update_at": "2019-04-03T13:14:54+00:00", "question_id": "0816306c2537cf28670a6f8f9080b30529052468", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ExtractData\r\n{\r\n\r\n    public ExtractData(){}\r\n\r\n    public ArrayList<String> course() throws IOException\r\n    {\r\n        ArrayList<String> course = new ArrayList<String>();\r\n        //Get scanner instance\r\n        Scanner scan = new Scanner(new File(\"D:\\\\Documents\\\\UUM\\\\Sem 4\\\\Real-time Programming\\\\STIW3054\\\\rtass2\\\\Ass2pdf.csv\"));\r\n         \r\n        //Set the delimiter used in file\r\n        scan.useDelimiter(\"[;\\n]\");\r\n        String word= \" \";\r\n        \r\n\r\n        while(scan.hasNext())\r\n        {\r\n            word=scan.next();\r\n            if(!word.contains(\"BIL.\")){\r\n                if(!word.contains(\"CODE\")){\r\n                    if(!word.contains(\"COURSE\")){\r\n                        if(!word.contains(\"DATE/TIME\")){\r\n                            course.add(word);//add only data not include (BIL. , CODE , COURSE ,DATE/TIME)\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        scan.close();\r\n        return course;\r\n    }\r\n"]]}
{"hexsha": "b8bb6b2cb38b07114e8e23658909565c6308dd07", "ext": "java", "lang": "Java", "content": "public class FindPersonCommandParserTest {\n\n    private FindPersonCommandParser parser = new FindPersonCommandParser();\n\n    @Test\n    public void parse_emptyArg_throwsParseException() {\n        assertParseFailure(parser, \"     \", String.format(MESSAGE_INVALID_COMMAND_FORMAT,\n            FindPersonCommand.MESSAGE_USAGE));\n    }\n\n    @Test\n    public void parse_validArgs_returnsFindCommand() {\n        // no leading and trailing whitespaces\n        FindPersonCommand expectedFindPersonCommand =\n                new FindPersonCommand(new NameContainsKeywordsPredicate(Arrays.asList(\"Alice\", \"Bob\")));\n        assertParseSuccess(parser, \"Alice Bob\", expectedFindPersonCommand);\n\n        // multiple whitespaces between keywords\n        assertParseSuccess(parser, \" \\n Alice \\n \\t Bob  \\t\", expectedFindPersonCommand);\n    }\n\n}", "class_id": 0, "repo": "AY1920S1-CS2103-T08-3/main", "file": "src/test/java/seedu/system/logic/parser/FindPersonCommandParserTest.java", "last_update_at": "2019-11-14T05:44:41+00:00", "question_id": "b8bb6b2cb38b07114e8e23658909565c6308dd07", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FindPersonCommandParserTest {\n    private FindPersonCommandParser parser = new FindPersonCommandParser();\n    @Test\n    public void parse_emptyArg_throwsParseException() {\n        assertParseFailure(parser, \"     \", String.format(MESSAGE_INVALID_COMMAND_FORMAT,\n            FindPersonCommand.MESSAGE_USAGE));\n    }\n    @Test\n    public void parse_validArgs_returnsFindCommand() {\n        // no leading and trailing whitespaces\n        FindPersonCommand expectedFindPersonCommand =\n                new FindPersonCommand(new NameContainsKeywordsPredicate(Arrays.asList(\"Alice\", \"Bob\")));\n        assertParseSuccess(parser, \"Alice Bob\", expectedFindPersonCommand);\n        // multiple whitespaces between keywords\n        assertParseSuccess(parser, \" \\n Alice \\n \\t Bob  \\t\", expectedFindPersonCommand);\n    }\n"]]}
{"hexsha": "b0ac5571a153fa419266c1daafe7f8e5c6a29352", "ext": "java", "lang": "Java", "content": "public class Vlan extends VdsNetworkInterface {\n\n    private static final long serialVersionUID = -2458958954004227402L;\n\n    public Vlan() {\n    }\n\n    public Vlan(int vlanId) {\n        setVlanId(vlanId);\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n        builder.append(getName())\n                .append(\" {id=\")\n                .append(getId())\n                .append(\", vdsId=\")\n                .append(getVdsId())\n                .append(\", name=\")\n                .append(getName())\n                .append(\", networkName=\")\n                .append(getNetworkName())\n                .append(\", vlanId=\")\n                .append(getVlanId())\n                .append(\", bootProtocol=\")\n                .append(getBootProtocol())\n                .append(\", address=\")\n                .append(getAddress())\n                .append(\", subnet=\")\n                .append(getSubnet())\n                .append(\", gateway=\")\n                .append(getGateway())\n                .append(\", mtu=\")\n                .append(getMtu())\n                .append(\", bridged=\")\n                .append(isBridged())\n                .append(\", type=\")\n                .append(getType())\n                .append(\", networkImplementationDetails=\")\n                .append(getNetworkImplementationDetails())\n                .append(\"}\");\n        return builder.toString();\n    }\n}", "class_id": 0, "repo": "jbeecham/ovirt-engine", "file": "backend/manager/modules/common/src/main/java/org/ovirt/engine/core/common/businessentities/network/Vlan.java", "last_update_at": "2019-02-22T21:32:26+00:00", "question_id": "b0ac5571a153fa419266c1daafe7f8e5c6a29352", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Vlan extends VdsNetworkInterface {\n    private static final long serialVersionUID = -2458958954004227402L;\n    public Vlan() {\n    }\n    public Vlan(int vlanId) {\n        setVlanId(vlanId);\n    }\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n        builder.append(getName())\n                .append(\" {id=\")\n                .append(getId())\n                .append(\", vdsId=\")\n                .append(getVdsId())\n                .append(\", name=\")\n                .append(getName())\n                .append(\", networkName=\")\n                .append(getNetworkName())\n                .append(\", vlanId=\")\n                .append(getVlanId())\n                .append(\", bootProtocol=\")\n                .append(getBootProtocol())\n                .append(\", address=\")\n                .append(getAddress())\n                .append(\", subnet=\")\n                .append(getSubnet())\n                .append(\", gateway=\")\n                .append(getGateway())\n                .append(\", mtu=\")\n                .append(getMtu())\n                .append(\", bridged=\")\n                .append(isBridged())\n                .append(\", type=\")\n                .append(getType())\n                .append(\", networkImplementationDetails=\")\n                .append(getNetworkImplementationDetails())\n                .append(\"}\");\n        return builder.toString();\n    }\n"]]}
{"hexsha": "0f2d56bf9f383d3d665dfc69b4de68bbb210d464", "ext": "java", "lang": "Java", "content": "public class ConstraintsAspectDescriptor extends BaseConstraintsAspectDescriptor {\n  public ConstraintsAspectDescriptor() {\n  }\n\n  @Override\n  public ConstraintsDescriptor getConstraints(SAbstractConcept concept) {\n    SAbstractConcept cncpt = concept;\n    switch (conceptIndex.index(cncpt)) {\n      case 0:\n        return new AnalogCondition_Constraints();\n      case 1:\n        return new AnalogSensor_Constraints();\n      case 2:\n        return new Brick_Constraints();\n      case 3:\n        return new LogicalSensor_Constraints();\n      case 4:\n        return new State_Constraints();\n      default:\n    }\n    return new BaseConstraintsDescriptor(concept);\n  }\n  private static final ConceptSwitchIndex conceptIndex = new ConceptSwitchIndexBuilder().put(MetaIdFactory.conceptId(0x6d5f556878454ac1L, 0xba976d57e4d58942L, 0x6b9055df271b69b0L), MetaIdFactory.conceptId(0x6d5f556878454ac1L, 0xba976d57e4d58942L, 0x6b9055df271951bbL), MetaIdFactory.conceptId(0x6d5f556878454ac1L, 0xba976d57e4d58942L, 0x3c2a1b6d4a4685e1L), MetaIdFactory.conceptId(0x6d5f556878454ac1L, 0xba976d57e4d58942L, 0x6b9055df27195156L), MetaIdFactory.conceptId(0x6d5f556878454ac1L, 0xba976d57e4d58942L, 0x3c2a1b6d4a4685daL)).seal();\n}", "class_id": 0, "repo": "JAMamene/arduinoML-MPS", "file": "languages/ArduinoML/source_gen/ArduinoML/constraints/ConstraintsAspectDescriptor.java", "last_update_at": "2019-01-16T10:48:04+00:00", "question_id": "0f2d56bf9f383d3d665dfc69b4de68bbb210d464", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ConstraintsAspectDescriptor extends BaseConstraintsAspectDescriptor {\n  public ConstraintsAspectDescriptor() {\n  }\n  @Override\n  public ConstraintsDescriptor getConstraints(SAbstractConcept concept) {\n    SAbstractConcept cncpt = concept;\n    switch (conceptIndex.index(cncpt)) {\n      case 0:\n        return new AnalogCondition_Constraints();\n      case 1:\n        return new AnalogSensor_Constraints();\n      case 2:\n        return new Brick_Constraints();\n      case 3:\n        return new LogicalSensor_Constraints();\n      case 4:\n        return new State_Constraints();\n      default:\n    }\n    return new BaseConstraintsDescriptor(concept);\n  }\n  private static final ConceptSwitchIndex conceptIndex = new ConceptSwitchIndexBuilder().put(MetaIdFactory.conceptId(0x6d5f556878454ac1L, 0xba976d57e4d58942L, 0x6b9055df271b69b0L), MetaIdFactory.conceptId(0x6d5f556878454ac1L, 0xba976d57e4d58942L, 0x6b9055df271951bbL), MetaIdFactory.conceptId(0x6d5f556878454ac1L, 0xba976d57e4d58942L, 0x3c2a1b6d4a4685e1L), MetaIdFactory.conceptId(0x6d5f556878454ac1L, 0xba976d57e4d58942L, 0x6b9055df27195156L), MetaIdFactory.conceptId(0x6d5f556878454ac1L, 0xba976d57e4d58942L, 0x3c2a1b6d4a4685daL)).seal();\n"]]}
{"hexsha": "ed9e41080fdd18224044973968d161aa0d22b443", "ext": "java", "lang": "Java", "content": "public class TimesToJavaSerializer implements ToJavaSerializer<Times> {\n\n    @Override\n    public String serialize(int numberOfSpacesToIndent, Times times) {\n        StringBuffer output = new StringBuffer();\n        if (times != null) {\n            appendNewLineAndIndent(numberOfSpacesToIndent * INDENT_SIZE, output);\n            if (times.isUnlimited()) {\n                output.append(\"Times.unlimited()\");\n            } else if (times.getRemainingTimes() == 1) {\n                output.append(\"Times.once()\");\n            } else {\n                output.append(\"Times.exactly(\").append(times.getRemainingTimes()).append(\")\");\n            }\n        }\n\n        return output.toString();\n    }\n\n    private StringBuffer appendNewLineAndIndent(int numberOfSpacesToIndent, StringBuffer output) {\n        return output.append(NEW_LINE).append(Strings.padStart(\"\", numberOfSpacesToIndent, ' '));\n    }\n}", "class_id": 0, "repo": "xLitil/mockserver", "file": "mockserver-core/src/main/java/org/mockserver/client/serialization/java/TimesToJavaSerializer.java", "last_update_at": "2019-01-05T11:45:04+00:00", "question_id": "ed9e41080fdd18224044973968d161aa0d22b443", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TimesToJavaSerializer implements ToJavaSerializer<Times> {\n    @Override\n    public String serialize(int numberOfSpacesToIndent, Times times) {\n        StringBuffer output = new StringBuffer();\n        if (times != null) {\n            appendNewLineAndIndent(numberOfSpacesToIndent * INDENT_SIZE, output);\n            if (times.isUnlimited()) {\n                output.append(\"Times.unlimited()\");\n            } else if (times.getRemainingTimes() == 1) {\n                output.append(\"Times.once()\");\n            } else {\n                output.append(\"Times.exactly(\").append(times.getRemainingTimes()).append(\")\");\n            }\n        }\n        return output.toString();\n    }\n    private StringBuffer appendNewLineAndIndent(int numberOfSpacesToIndent, StringBuffer output) {\n        return output.append(NEW_LINE).append(Strings.padStart(\"\", numberOfSpacesToIndent, ' '));\n    }\n"]]}
{"hexsha": "4671840ff547f894fc86ca8d507b4562dedd301e", "ext": "java", "lang": "Java", "content": "public class CheckAll extends ICmd {\n\n    public CheckAll() {\n        super(\"checkall\", \"[radius]\", \"\u5217\u51fa\u6240\u6709\u5728\u7ebf\u73a9\u5bb6\u5468\u56f4Entity\u6570\u91cf\");\n    }\n\n    @Override\n    public boolean onCommand(CommandSender sender, String[] args) {\n        int radius = AuditPlugin.getPlugin().getConfig()\n                .getInt(\"entityCheck.radius\", 100);\n        try {\n            radius = (args != null && args.length > 0)\n                    ? Integer.parseInt(args[0]) : radius;\n        } catch (NumberFormatException e) {\n        }\n        EntityCheck c = new EntityCheck();\n        c.checkAll2(sender, radius);\n        return true;\n    }\n\n    @Override\n    public String permission() {\n        return \"xjcraft.checkall\";\n    }\n\n}", "class_id": 0, "repo": "jimliang/XJCraftAudit", "file": "src/main/java/org/jim/bukkit/audit/cmds/CheckAll.java", "last_update_at": "2019-04-25T15:13:28+00:00", "question_id": "4671840ff547f894fc86ca8d507b4562dedd301e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CheckAll extends ICmd {\n    public CheckAll() {\n        super(\"checkall\", \"[radius]\", \"\u5217\u51fa\u6240\u6709\u5728\u7ebf\u73a9\u5bb6\u5468\u56f4Entity\u6570\u91cf\");\n    }\n    @Override\n    public boolean onCommand(CommandSender sender, String[] args) {\n        int radius = AuditPlugin.getPlugin().getConfig()\n                .getInt(\"entityCheck.radius\", 100);\n        try {\n            radius = (args != null && args.length > 0)\n                    ? Integer.parseInt(args[0]) : radius;\n        } catch (NumberFormatException e) {\n        }\n        EntityCheck c = new EntityCheck();\n        c.checkAll2(sender, radius);\n        return true;\n    }\n    @Override\n    public String permission() {\n        return \"xjcraft.checkall\";\n    }\n"]]}
{"hexsha": "69c7e5570b21ad0e49f243eba08a1731cf7c11c3", "ext": "java", "lang": "Java", "content": "public class VectorTest\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tVector vector = new Vector();\n\t\t\n\t\tvector.add(\"hello\");\n\t\tvector.add(\"world\");\n\t\tvector.add(\"hello world\");\n\t\t\n\t\tfor(int i = 0; i < vector.size(); i++)\n\t\t{\n\t\t\tSystem.out.println(vector.get(i));\n\t\t}\n\t}\n}", "class_id": 0, "repo": "abadurehman/Java-learningNote", "file": "blogs/javase/Java.SE.Lesson.7_code/code/src/com/shengsiyuan3/VectorTest.java", "last_update_at": "2019-12-30T18:22:34+00:00", "question_id": "69c7e5570b21ad0e49f243eba08a1731cf7c11c3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class VectorTest\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tVector vector = new Vector();\n\t\t\n\t\tvector.add(\"hello\");\n\t\tvector.add(\"world\");\n\t\tvector.add(\"hello world\");\n\t\t\n\t\tfor(int i = 0; i < vector.size(); i++)\n\t\t{\n\t\t\tSystem.out.println(vector.get(i));\n\t\t}\n\t}\n"]]}
{"hexsha": "92d959a555c7bbbe1512cc1e8965d9e2c494c71e", "ext": "java", "lang": "Java", "content": "@Autonomous(name=\"[TEST] Mineral Sampling Test\", group = \"Tests\")\npublic class MineralSamplingTest extends LinearOpMode\n{\n    Robot robot;\n    Auto auto;\n\n    @Override\n    public void runOpMode() throws InterruptedException\n    {\n        // Initialize objects\n        robot = new Robot(hardwareMap);\n        auto = new Auto(this, robot);\n\n        GoldDetector.Position goldPos = GoldDetector.Position.NONE;\n\n        auto.initSampling();\n\n        waitForStart();\n        if(goldPos == GoldDetector.Position.NONE) {\n            goldPos = auto.attemptSampleMinerals(1000);\n        }\n\n        auto.rotate(160, 0.3);\n\n        telemetry.addData(\"Gold Mineral Position\", goldPos.toString());\n        telemetry.update();\n\n        switch (goldPos){\n            case LEFT:\n                auto.rotate(21, 0.3);\n                break;\n            case RIGHT:\n                auto.rotate(-21, 0.3);\n                break;\n        }\n\n        while (opModeIsActive());\n    }\n\n\n}", "class_id": 0, "repo": "FTC-11589/Robot-Codebase", "file": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/autonomous/testing/MineralSamplingTest.java", "last_update_at": "2019-01-08T03:05:06+00:00", "question_id": "92d959a555c7bbbe1512cc1e8965d9e2c494c71e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Autonomous(name=\"[TEST] Mineral Sampling Test\", group = \"Tests\")\npublic class MineralSamplingTest extends LinearOpMode\n{\n    Robot robot;\n    Auto auto;\n    @Override\n    public void runOpMode() throws InterruptedException\n    {\n        // Initialize objects\n        robot = new Robot(hardwareMap);\n        auto = new Auto(this, robot);\n        GoldDetector.Position goldPos = GoldDetector.Position.NONE;\n        auto.initSampling();\n        waitForStart();\n        if(goldPos == GoldDetector.Position.NONE) {\n            goldPos = auto.attemptSampleMinerals(1000);\n        }\n        auto.rotate(160, 0.3);\n        telemetry.addData(\"Gold Mineral Position\", goldPos.toString());\n        telemetry.update();\n        switch (goldPos){\n            case LEFT:\n                auto.rotate(21, 0.3);\n                break;\n            case RIGHT:\n                auto.rotate(-21, 0.3);\n                break;\n        }\n        while (opModeIsActive());\n    }\n"]]}
{"hexsha": "6c3bfd4f9f96538280371268a4ce25768261a4ce", "ext": "java", "lang": "Java", "content": "public static class SmartRecommendationCardView$a\n{\n\n\tpublic SmartRecommendationCardView$a a(int i)\n\t{\n\t\ta.c = i;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>\n\t//    2    4:iload_1         \n\t//    3    5:putfield        #29  <Field int SmartRecommendationCardView$b.c>\n\t\treturn this;\n\t//    4    8:aload_0         \n\t//    5    9:areturn         \n\t}\n\n\tpublic SmartRecommendationCardView$a a(com.irobot.home.n.b.a a1)\n\t{\n\t\ta.i = a1;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>\n\t//    2    4:aload_1         \n\t//    3    5:putfield        #34  <Field com.irobot.home.n.b$a SmartRecommendationCardView$b.i>\n\t\treturn this;\n\t//    4    8:aload_0         \n\t//    5    9:areturn         \n\t}\n\n\tpublic SmartRecommendationCardView$a a(com.irobot.home.n.b.c c1)\n\t{\n\t\ta.k = c1;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>\n\t//    2    4:aload_1         \n\t//    3    5:putfield        #39  <Field com.irobot.home.n.b$c SmartRecommendationCardView$b.k>\n\t\treturn this;\n\t//    4    8:aload_0         \n\t//    5    9:areturn         \n\t}\n\n\tpublic SmartRecommendationCardView$a a(String s)\n\t{\n\t\ta.e = s;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>\n\t//    2    4:aload_1         \n\t//    3    5:putfield        #44  <Field String SmartRecommendationCardView$b.e>\n\t\treturn this;\n\t//    4    8:aload_0         \n\t//    5    9:areturn         \n\t}\n\n\tpublic SmartRecommendationCardView a()\n\t{\n\t\tSmartRecommendationCardView smartrecommendationcardview = new SmartRecommendationCardView(b);\n\t//    0    0:new             #6   <Class SmartRecommendationCardView>\n\t//    1    3:dup             \n\t//    2    4:aload_0         \n\t//    3    5:getfield        #17  <Field Context b>\n\t//    4    8:invokespecial   #46  <Method void SmartRecommendationCardView(Context)>\n\t//    5   11:astore_1        \n\t\tSmartRecommendationCardView.a(smartrecommendationcardview, a);\n\t//    6   12:aload_1         \n\t//    7   13:aload_0         \n\t//    8   14:getfield        #23  <Field SmartRecommendationCardView$b a>\n\t//    9   17:invokestatic    #49  <Method void SmartRecommendationCardView.a(SmartRecommendationCardView, SmartRecommendationCardView$b)>\n\t\treturn smartrecommendationcardview;\n\t//   10   20:aload_1         \n\t//   11   21:areturn         \n\t}\n\n\tpublic SmartRecommendationCardView$a b(int i)\n\t{\n\t\ta.d = i;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>\n\t//    2    4:iload_1         \n\t//    3    5:putfield        #52  <Field int SmartRecommendationCardView$b.d>\n\t\treturn this;\n\t//    4    8:aload_0         \n\t//    5    9:areturn         \n\t}\n\n\tpublic SmartRecommendationCardView$a b(com.irobot.home.n.b.a a1)\n\t{\n\t\ta.j = a1;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>\n\t//    2    4:aload_1         \n\t//    3    5:putfield        #55  <Field com.irobot.home.n.b$a SmartRecommendationCardView$b.j>\n\t\treturn this;\n\t//    4    8:aload_0         \n\t//    5    9:areturn         \n\t}\n\n\tpublic SmartRecommendationCardView$a b(String s)\n\t{\n\t\ta.f = s;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>\n\t//    2    4:aload_1         \n\t//    3    5:putfield        #58  <Field String SmartRecommendationCardView$b.f>\n\t\treturn this;\n\t//    4    8:aload_0         \n\t//    5    9:areturn         \n\t}\n\n\tpublic SmartRecommendationCardView$a c(int i)\n\t{\n\t\ta.h = b.getString(i);\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>\n\t//    2    4:aload_0         \n\t//    3    5:getfield        #17  <Field Context b>\n\t//    4    8:iload_1         \n\t//    5    9:invokevirtual   #64  <Method String Context.getString(int)>\n\t//    6   12:putfield        #67  <Field String SmartRecommendationCardView$b.h>\n\t\treturn this;\n\t//    7   15:aload_0         \n\t//    8   16:areturn         \n\t}\n\n\tpublic SmartRecommendationCardView$a c(String s)\n\t{\n\t\ta.g = s;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>\n\t//    2    4:aload_1         \n\t//    3    5:putfield        #70  <Field String SmartRecommendationCardView$b.g>\n\t\treturn this;\n\t//    4    8:aload_0         \n\t//    5    9:areturn         \n\t}\n\n\tprivate final SmartRecommendationCardView$b a;\n\tprivate final Context b;\n\n\tpublic SmartRecommendationCardView$a(Context context)\n\t{\n\t//    0    0:aload_0         \n\t//    1    1:invokespecial   #15  <Method void Object()>\n\t\tb = context;\n\t//    2    4:aload_0         \n\t//    3    5:aload_1         \n\t//    4    6:putfield        #17  <Field Context b>\n\t\ta = new SmartRecommendationCardView$b(context);\n\t//    5    9:aload_0         \n\t//    6   10:new             #19  <Class SmartRecommendationCardView$b>\n\t//    7   13:dup             \n\t//    8   14:aload_1         \n\t//    9   15:invokespecial   #21  <Method void SmartRecommendationCardView$b(Context)>\n\t//   10   18:putfield        #23  <Field SmartRecommendationCardView$b a>\n\t//   11   21:return          \n\t}\n}", "class_id": 0, "repo": "Andreas237/AndroidPolicyAutomation", "file": "ExtractedJars/iRobot_com.irobot.home/javafiles/com/irobot/home/view/SmartRecommendationCardView$a.java", "last_update_at": "2019-07-06T22:21:59+00:00", "question_id": "6c3bfd4f9f96538280371268a4ce25768261a4ce", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public static class SmartRecommendationCardView$a\n{\n\tpublic SmartRecommendationCardView$a a(int i)\n\t{\n\t\ta.c = i;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>\n\t//    2    4:iload_1         \n\t//    3    5:putfield        #29  <Field int SmartRecommendationCardView$b.c>\n\t\treturn this;\n\t//    4    8:aload_0         \n\t//    5    9:areturn         \n\t}\n\tpublic SmartRecommendationCardView$a a(com.irobot.home.n.b.a a1)\n\t{\n\t\ta.i = a1;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>\n\t//    2    4:aload_1         \n\t//    3    5:putfield        #34  <Field com.irobot.home.n.b$a SmartRecommendationCardView$b.i>\n\t\treturn this;\n\t//    4    8:aload_0         \n\t//    5    9:areturn         \n\t}\n\tpublic SmartRecommendationCardView$a a(com.irobot.home.n.b.c c1)\n\t{\n\t\ta.k = c1;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>\n\t//    2    4:aload_1         \n\t//    3    5:putfield        #39  <Field com.irobot.home.n.b$c SmartRecommendationCardView$b.k>\n\t\treturn this;\n\t//    4    8:aload_0         \n\t//    5    9:areturn         \n\t}\n\tpublic SmartRecommendationCardView$a a(String s)\n\t{\n\t\ta.e = s;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>\n\t//    2    4:aload_1         \n\t//    3    5:putfield        #44  <Field String SmartRecommendationCardView$b.e>\n\t\treturn this;\n\t//    4    8:aload_0         \n\t//    5    9:areturn         \n\t}\n\tpublic SmartRecommendationCardView a()\n\t{\n\t\tSmartRecommendationCardView smartrecommendationcardview = new SmartRecommendationCardView(b);\n\t//    0    0:new             #6   <Class SmartRecommendationCardView>\n\t//    1    3:dup             \n\t//    2    4:aload_0         \n\t//    3    5:getfield        #17  <Field Context b>\n\t//    4    8:invokespecial   #46  <Method void SmartRecommendationCardView(Context)>\n\t//    5   11:astore_1        \n\t\tSmartRecommendationCardView.a(smartrecommendationcardview, a);\n\t//    6   12:aload_1         \n\t//    7   13:aload_0         \n\t//    8   14:getfield        #23  <Field SmartRecommendationCardView$b a>\n\t//    9   17:invokestatic    #49  <Method void SmartRecommendationCardView.a(SmartRecommendationCardView, SmartRecommendationCardView$b)>\n\t\treturn smartrecommendationcardview;\n\t//   10   20:aload_1         \n\t//   11   21:areturn         \n\t}\n\tpublic SmartRecommendationCardView$a b(int i)\n\t{\n\t\ta.d = i;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>\n\t//    2    4:iload_1         \n\t//    3    5:putfield        #52  <Field int SmartRecommendationCardView$b.d>\n\t\treturn this;\n\t//    4    8:aload_0         \n\t//    5    9:areturn         \n\t}\n\tpublic SmartRecommendationCardView$a b(com.irobot.home.n.b.a a1)\n\t{\n\t\ta.j = a1;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>\n\t//    2    4:aload_1         \n\t//    3    5:putfield        #55  <Field com.irobot.home.n.b$a SmartRecommendationCardView$b.j>\n\t\treturn this;\n\t//    4    8:aload_0         \n\t//    5    9:areturn         \n\t}\n\tpublic SmartRecommendationCardView$a b(String s)\n\t{\n\t\ta.f = s;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>\n\t//    2    4:aload_1         \n\t//    3    5:putfield        #58  <Field String SmartRecommendationCardView$b.f>\n\t\treturn this;\n\t//    4    8:aload_0         \n\t//    5    9:areturn         \n\t}\n\tpublic SmartRecommendationCardView$a c(int i)\n\t{\n\t\ta.h = b.getString(i);\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>\n\t//    2    4:aload_0         \n\t//    3    5:getfield        #17  <Field Context b>\n\t//    4    8:iload_1         \n\t//    5    9:invokevirtual   #64  <Method String Context.getString(int)>\n\t//    6   12:putfield        #67  <Field String SmartRecommendationCardView$b.h>\n\t\treturn this;\n\t//    7   15:aload_0         \n\t//    8   16:areturn         \n\t}\n\tpublic SmartRecommendationCardView$a c(String s)\n\t{\n\t\ta.g = s;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>\n\t//    2    4:aload_1         \n\t//    3    5:putfield        #70  <Field String SmartRecommendationCardView$b.g>\n\t\treturn this;\n\t//    4    8:aload_0         \n\t//    5    9:areturn         \n\t}\n\tprivate final SmartRecommendationCardView$b a;\n\tprivate final Context b;\n\tpublic SmartRecommendationCardView$a(Context context)\n\t{\n\t//    0    0:aload_0         \n\t//    1    1:invokespecial   #15  <Method void Object()>\n\t\tb = context;\n\t//    2    4:aload_0         \n\t//    3    5:aload_1         \n\t//    4    6:putfield        #17  <Field Context b>\n\t\ta = new SmartRecommendationCardView$b(context);\n\t//    5    9:aload_0         \n\t//    6   10:new             #19  <Class SmartRecommendationCardView$b>\n\t//    7   13:dup             \n\t//    8   14:aload_1         \n\t//    9   15:invokespecial   #21  <Method void SmartRecommendationCardView$b(Context)>\n\t//   10   18:putfield        #23  <Field SmartRecommendationCardView$b a>\n\t//   11   21:return          \n\t}\n"]]}
{"hexsha": "481d03a1becba31b033ad6c2e30ee6a23f965efc", "ext": "java", "lang": "Java", "content": "public class LM35_Example {\r\n\r\n\tpublic static void main(String[] args) throws InterruptedException {\r\n\t\t// ! [Interesting]\r\n\r\n\t\t// Instantiate a LM35 on analog pin A0, with a default analog\r\n\t\t// reference voltage of 5.0\r\n\t\tupm_lm35.LM35 sensor = new upm_lm35.LM35(0);\r\n\r\n\t\t// Every half second, sample the sensor and output the temperature\r\n\r\n\t\twhile (true) {\r\n\t\t\tSystem.out.println(\"Temperature: \" + sensor.getTemperature() + \" C\");\r\n\t\t\tThread.sleep(500);\r\n\t\t}\r\n\r\n\t\t// ! [Interesting]\r\n\t}\r\n}", "class_id": 0, "repo": "moredu/upm", "file": "examples/java/LM35_Example.java", "last_update_at": "2019-11-08T14:04:33+00:00", "question_id": "481d03a1becba31b033ad6c2e30ee6a23f965efc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LM35_Example {\r\n\r\n\tpublic static void main(String[] args) throws InterruptedException {\r\n\t\t// ! [Interesting]\r\n\r\n\t\t// Instantiate a LM35 on analog pin A0, with a default analog\r\n\t\t// reference voltage of 5.0\r\n\t\tupm_lm35.LM35 sensor = new upm_lm35.LM35(0);\r\n\r\n\t\t// Every half second, sample the sensor and output the temperature\r\n\r\n\t\twhile (true) {\r\n\t\t\tSystem.out.println(\"Temperature: \" + sensor.getTemperature() + \" C\");\r\n\t\t\tThread.sleep(500);\r\n\t\t}\r\n\r\n\t\t// ! [Interesting]\r\n\t}\r\n"]]}
{"hexsha": "b3c8a8f3660a160fee6a89d53a895196ada747b1", "ext": "java", "lang": "Java", "content": "public class TubeServiceImpl implements TubeService {\n    private final TubeRepository tubeRepository;\n    private final ModelMapper modelMapper;\n    private final ValidationUtil validationUtil;\n\n    @Inject\n    public TubeServiceImpl(TubeRepository tubeRepository, ModelMapper modelMapper, ValidationUtil validationUtil) {\n        this.tubeRepository = tubeRepository;\n        this.modelMapper = modelMapper;\n        this.validationUtil = validationUtil;\n    }\n\n    @Override\n    public void saveTube(TubeServiceModel tubeServiceModel) throws IllegalAccessException {\n        if(!this.validationUtil.isValid(tubeServiceModel)){\n            throw new IllegalAccessException(\"Required fields are missing or incorrect.\");\n        }\n\n        try{\n            TubeDetailsViewModel tubeFromDb = this.getByName(tubeServiceModel.getName());\n        }catch (NoResultException nre){\n            Tube tube = this.modelMapper.map(tubeServiceModel, Tube.class);\n            Tube savedTube = this.tubeRepository.save(tube);\n            return;\n        }\n\n        throw new IllegalArgumentException(String.format(\"Tube with name - \\\"%s\\\" already exists\", tubeServiceModel.getName()));\n    }\n\n    @Override\n    public List<TubeAllViewModel> getAll() {\n        List<Tube> tubeList = this.tubeRepository.getAll();\n\n        List<TubeAllViewModel> allViewModels = tubeList.stream()\n                .map(tube -> this.modelMapper.map(tube, TubeAllViewModel.class))\n                .collect(Collectors.toList());\n\n        return allViewModels;\n    }\n\n    @Override\n    public TubeDetailsViewModel getByName(String name) {\n        Tube tube = this.tubeRepository.findByName(name);\n        if(tube != null){\n            return this.modelMapper.map(tube, TubeDetailsViewModel.class);\n        }\n\n        return null;\n    }\n}", "class_id": 0, "repo": "kostadinlambov/Java-Web-Development-Basics-January-2019", "file": "06. 2. Java-EE-JSP-Exercise/src/main/java/metube/services/TubeServiceImpl.java", "last_update_at": "2019-04-07T23:23:44+00:00", "question_id": "b3c8a8f3660a160fee6a89d53a895196ada747b1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TubeServiceImpl implements TubeService {\n    private final TubeRepository tubeRepository;\n    private final ModelMapper modelMapper;\n    private final ValidationUtil validationUtil;\n    @Inject\n    public TubeServiceImpl(TubeRepository tubeRepository, ModelMapper modelMapper, ValidationUtil validationUtil) {\n        this.tubeRepository = tubeRepository;\n        this.modelMapper = modelMapper;\n        this.validationUtil = validationUtil;\n    }\n    @Override\n    public void saveTube(TubeServiceModel tubeServiceModel) throws IllegalAccessException {\n        if(!this.validationUtil.isValid(tubeServiceModel)){\n            throw new IllegalAccessException(\"Required fields are missing or incorrect.\");\n        }\n        try{\n            TubeDetailsViewModel tubeFromDb = this.getByName(tubeServiceModel.getName());\n        }catch (NoResultException nre){\n            Tube tube = this.modelMapper.map(tubeServiceModel, Tube.class);\n            Tube savedTube = this.tubeRepository.save(tube);\n            return;\n        }\n        throw new IllegalArgumentException(String.format(\"Tube with name - \\\"%s\\\" already exists\", tubeServiceModel.getName()));\n    }\n    @Override\n    public List<TubeAllViewModel> getAll() {\n        List<Tube> tubeList = this.tubeRepository.getAll();\n        List<TubeAllViewModel> allViewModels = tubeList.stream()\n                .map(tube -> this.modelMapper.map(tube, TubeAllViewModel.class))\n                .collect(Collectors.toList());\n        return allViewModels;\n    }\n    @Override\n    public TubeDetailsViewModel getByName(String name) {\n        Tube tube = this.tubeRepository.findByName(name);\n        if(tube != null){\n            return this.modelMapper.map(tube, TubeDetailsViewModel.class);\n        }\n        return null;\n    }\n"]]}
{"hexsha": "c711523dc51490f2eb9f0fe8625de27870a40a32", "ext": "java", "lang": "Java", "content": "@Parcel // annotation indicates class is Parcelable\npublic class Tweet {\n\n    // list out the attributes\n    public String body;\n    public long uid; // database ID for the tweet\n    public User user;\n    public String createdAt;\n    public boolean favorited;\n    public boolean retweeted;\n    public String mediaUrl;\n    public int favoriteCount;\n    public int retweetCount;\n    public int replyCount;\n\n    // deserialize the JSON\n    public static Tweet fromJSON(JSONObject jsonObject) throws JSONException {\n        Tweet tweet = new Tweet();\n\n        // extract the values from JSON\n        tweet.body = jsonObject.getString(\"text\");\n        tweet.uid = jsonObject.getLong(\"id\");\n        tweet.createdAt = getRelativeTimeAgo(jsonObject.getString(\"created_at\"));\n        tweet.user = User.fromJSON(jsonObject.getJSONObject(\"user\"));\n        tweet.favorited = jsonObject.getBoolean(\"favorited\");\n        tweet.retweeted = jsonObject.getBoolean(\"retweeted\");\n        if (jsonObject.has(\"favorite_count\")) {\n            tweet.favoriteCount = jsonObject.getInt(\"favorite_count\");\n        }\n        if (jsonObject.has(\"retweet_count\")) {\n            tweet.retweetCount = jsonObject.getInt(\"retweet_count\");\n        }\n        // This object is only available with the Premium and Enterprise tier products.\n        if (jsonObject.has(\"reply_count\")) {\n            tweet.replyCount = jsonObject.getInt(\"reply_count\");\n        }\n\n        JSONObject entities = jsonObject.getJSONObject(\"entities\");\n        // check if there is media\n        if (entities.has(\"media\")) {\n            // extract media url from the first image entity\n            tweet.mediaUrl = entities.getJSONArray(\"media\").getJSONObject(0)\n                    .getString(\"media_url_https\");\n        }\n\n        return tweet;\n    }\n\n    // getRelativeTimeAgo(\"Mon Apr 01 21:16:23 +0000 2014\");\n    public static String getRelativeTimeAgo(String rawJsonDate) {\n        String twitterFormat = \"EEE MMM dd HH:mm:ss ZZZZZ yyyy\";\n        SimpleDateFormat sf = new SimpleDateFormat(twitterFormat, Locale.ENGLISH);\n        sf.setLenient(true);\n\n        String relativeDate = \"\";\n        try {\n            long dateMillis = sf.parse(rawJsonDate).getTime();\n            relativeDate = DateUtils.getRelativeTimeSpanString(dateMillis,\n                    System.currentTimeMillis(), DateUtils.SECOND_IN_MILLIS).toString();\n        } catch (ParseException e) {\n            e.printStackTrace();\n        }\n\n        return relativeDate;\n    }\n\n    public void setFavorited(boolean favorited) {\n        this.favorited = favorited;\n    }\n\n    public void setRetweeted(boolean retweeted) {\n        this.retweeted = retweeted;\n    }\n}", "class_id": 0, "repo": "ajin12/Twitter", "file": "app/src/main/java/com/codepath/apps/restclienttemplate/models/Tweet.java", "last_update_at": "2019-07-06T07:47:02+00:00", "question_id": "c711523dc51490f2eb9f0fe8625de27870a40a32", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Parcel // annotation indicates class is Parcelable\npublic class Tweet {\n    // list out the attributes\n    public String body;\n    public long uid; // database ID for the tweet\n    public User user;\n    public String createdAt;\n    public boolean favorited;\n    public boolean retweeted;\n    public String mediaUrl;\n    public int favoriteCount;\n    public int retweetCount;\n    public int replyCount;\n    // deserialize the JSON\n    public static Tweet fromJSON(JSONObject jsonObject) throws JSONException {\n        Tweet tweet = new Tweet();\n        // extract the values from JSON\n        tweet.body = jsonObject.getString(\"text\");\n        tweet.uid = jsonObject.getLong(\"id\");\n        tweet.createdAt = getRelativeTimeAgo(jsonObject.getString(\"created_at\"));\n        tweet.user = User.fromJSON(jsonObject.getJSONObject(\"user\"));\n        tweet.favorited = jsonObject.getBoolean(\"favorited\");\n        tweet.retweeted = jsonObject.getBoolean(\"retweeted\");\n        if (jsonObject.has(\"favorite_count\")) {\n            tweet.favoriteCount = jsonObject.getInt(\"favorite_count\");\n        }\n        if (jsonObject.has(\"retweet_count\")) {\n            tweet.retweetCount = jsonObject.getInt(\"retweet_count\");\n        }\n        // This object is only available with the Premium and Enterprise tier products.\n        if (jsonObject.has(\"reply_count\")) {\n            tweet.replyCount = jsonObject.getInt(\"reply_count\");\n        }\n        JSONObject entities = jsonObject.getJSONObject(\"entities\");\n        // check if there is media\n        if (entities.has(\"media\")) {\n            // extract media url from the first image entity\n            tweet.mediaUrl = entities.getJSONArray(\"media\").getJSONObject(0)\n                    .getString(\"media_url_https\");\n        }\n        return tweet;\n    }\n    // getRelativeTimeAgo(\"Mon Apr 01 21:16:23 +0000 2014\");\n    public static String getRelativeTimeAgo(String rawJsonDate) {\n        String twitterFormat = \"EEE MMM dd HH:mm:ss ZZZZZ yyyy\";\n        SimpleDateFormat sf = new SimpleDateFormat(twitterFormat, Locale.ENGLISH);\n        sf.setLenient(true);\n        String relativeDate = \"\";\n        try {\n            long dateMillis = sf.parse(rawJsonDate).getTime();\n            relativeDate = DateUtils.getRelativeTimeSpanString(dateMillis,\n                    System.currentTimeMillis(), DateUtils.SECOND_IN_MILLIS).toString();\n        } catch (ParseException e) {\n            e.printStackTrace();\n        }\n        return relativeDate;\n    }\n    public void setFavorited(boolean favorited) {\n        this.favorited = favorited;\n    }\n    public void setRetweeted(boolean retweeted) {\n        this.retweeted = retweeted;\n    }\n"]]}
{"hexsha": "72a1754027ce6cde68357c134bba2f46e9cbe0a3", "ext": "java", "lang": "Java", "content": "public class CustomSignalInfoUnit implements SignalInfoUnitInterface {\r\n\tprivate static final Logger logger = LoggerFactory.getLogger(CustomSignalInfoUnit.class); \r\n\tprivate int cusSigId;\r\n\tprivate boolean ifNotifing;\r\n\tprivate boolean ifAlarm;\r\n\tprivate short alarmClass;\r\n\tprivate short alarmDelayBef;\r\n\tprivate short alarmDelayAft;\r\n\tprivate boolean ifDisplay;\r\n\t/* custom signal name language map */\r\n\tprivate Map<Integer, String> signalNameLangMap;\r\n\t/* custom signal unit language map */\r\n\tprivate Map<Integer, String> signalUnitLangMap;\r\n\t/* custom group language map */\r\n\tprivate Map<Integer, String> groupLangMap;\r\n\t/* custom enumerate signal language map */\r\n\tprivate Map<Integer, Map<Integer, String> > signalEnumLangMap;\r\n\t/* custom alarm info */\r\n\t\r\n\tprivate SignalInterface customSignalInterface;\r\n\tprivate Object signalValue;\r\n\t\r\n\r\n\tpublic CustomSignalInfoUnit(int cusSigId, boolean ifNotifing, boolean ifAlarm, short alarmClass,\r\n\t\t\tshort alarmDelayBef, short alarmDelayAft, boolean ifDisplay, Map<Integer, String> signalNameLangMap,\r\n\t\t\tMap<Integer, String> signalUnitLangMap, Map<Integer, String> groupLangMap,\r\n\t\t\tMap<Integer, Map<Integer, String>> signalEnumLangMap, SignalInterface customSignalInterface) {\r\n\t\tsuper();\r\n\t\tthis.cusSigId = cusSigId;\r\n\t\tthis.ifNotifing = ifNotifing;\r\n\t\tthis.ifAlarm = ifAlarm;\r\n\t\tthis.alarmClass = alarmClass;\r\n\t\tthis.alarmDelayBef = alarmDelayBef;\r\n\t\tthis.alarmDelayAft = alarmDelayAft;\r\n\t\tthis.ifDisplay = ifDisplay;\r\n\t\tthis.signalNameLangMap = signalNameLangMap;\r\n\t\tthis.signalUnitLangMap = signalUnitLangMap;\r\n\t\tthis.groupLangMap = groupLangMap;\r\n\t\tthis.signalEnumLangMap = signalEnumLangMap;\r\n\t\tthis.customSignalInterface = customSignalInterface;\r\n\t}\r\n\t\r\n\tpublic boolean isIfNotifing() {\r\n\t\treturn ifNotifing;\r\n\t}\r\n\tpublic boolean isIfAlarm() {\r\n\t\treturn ifAlarm;\r\n\t}\r\n\tpublic boolean isIfDisplay() {\r\n\t\treturn ifDisplay;\r\n\t}\r\n\tpublic Map<Integer, String> getSignalNameLangMap() {\r\n\t\treturn signalNameLangMap;\r\n\t}\r\n\tpublic Map<Integer, String> getGroupLangMap() {\r\n\t\treturn groupLangMap;\r\n\t}\r\n\tpublic Map<Integer, Map<Integer, String>> getSignalEnumLangMap() {\r\n\t\treturn signalEnumLangMap;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn \"CustomSignalInfoUnit [cusSigId=\" + cusSigId + \", ifNotifing=\" + ifNotifing + \", ifAlarm=\" + ifAlarm\r\n\t\t\t\t+ \", alarmClass=\" + alarmClass + \", alarmDelayBef=\" + alarmDelayBef + \", alarmDelayAft=\" + alarmDelayAft\r\n\t\t\t\t+ \", ifDisplay=\" + ifDisplay + \", signalNameLangMap=\" + signalNameLangMap + \", signalUnitLangMap=\"\r\n\t\t\t\t+ signalUnitLangMap + \", groupLangMap=\" + groupLangMap + \", signalEnumLangMap=\" + signalEnumLangMap\r\n\t\t\t\t+ \", customSignalInterface=\" + customSignalInterface + \", signalValue=\" + signalValue + \"]\";\r\n\t}\r\n\r\n\t@Override\r\n\tpublic boolean ifNotifying() {\r\n\t\treturn ifNotifing;\r\n\t}\r\n\t@Override\r\n\tpublic int getSignalId() {\r\n\t\treturn cusSigId;\r\n\t}\r\n\t@Override\r\n\tpublic SignalInterface getSignalInterface() {\r\n\t\treturn customSignalInterface;\r\n\t}\r\n\t@Override\r\n\tpublic boolean ifConfigDef() {\r\n\t\treturn false;\r\n\t}\r\n\t@Override\r\n\tpublic boolean ifAlarm() {\r\n\t\treturn ifAlarm;\r\n\t}\r\n\t@Override\r\n\tpublic boolean ifDisplay() {\r\n\t\treturn ifDisplay;\r\n\t}\r\n\t@Override\r\n\tpublic Map<Integer, String> getSignalUnitLangMap() {\r\n\t\treturn signalUnitLangMap;\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic boolean putSignalValue(Entry<Integer, Map.Entry<Byte, Object>> entry) {\r\n\t\tboolean ret = false;\r\n\t\ttry {\r\n\t\t\tsignalValue = entry.getValue().getValue();\r\n\t\t} catch(Exception e) {\r\n\t\t\tUtil.logger(logger, Util.ERROR, e);\r\n\t\t\tret = false;\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic boolean checkSignalValueUnformed(Byte valueType, Object value) {\r\n\t\tboolean ret = true;\r\n\t\t/* check if signal info exist */\r\n\t\tif(null == customSignalInterface) {\r\n\t\t\treturn ret;\r\n\t\t}\r\n\t\t/* check if a alarm signal */\r\n\t\tif(!ifAlarm && (valueType & BPPacket.VAL_ALARM_FLAG) != 0) {\r\n\t\t\treturn ret;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tswitch (valueType & BPPacket.VAL_TYPE_MASK) {\r\n\t\t\tcase BPPacket.VAL_TYPE_UINT32: {\r\n\t\t\t\tCustomSignalU32InfoHbn customSignalU32InfoHbn = (CustomSignalU32InfoHbn)customSignalInterface;\r\n\t\t\t\tLong v = (Long)value;\r\n\t\t\t\tif(v >= customSignalU32InfoHbn.getMinVal() && v <= customSignalU32InfoHbn.getMaxVal()) {\r\n\t\t\t\t\tret =false;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase BPPacket.VAL_TYPE_UINT16: {\r\n\t\t\t\tCustomSignalU16InfoHbn customSignalU16InfoHbn = (CustomSignalU16InfoHbn)customSignalInterface;\r\n\t\t\t\tInteger v = (Integer)value;\r\n\t\t\t\tif(v >= customSignalU16InfoHbn.getMinVal() && v <= customSignalU16InfoHbn.getMaxVal()) {\r\n\t\t\t\t\tret =false;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase BPPacket.VAL_TYPE_IINT32: {\r\n\t\t\t\tCustomSignalI32InfoHbn customSignalI32InfoHbn = (CustomSignalI32InfoHbn)customSignalInterface;\r\n\t\t\t\tInteger v = (Integer)value;\r\n\t\t\t\tif(v >= customSignalI32InfoHbn.getMinVal() && v <= customSignalI32InfoHbn.getMaxVal()) {\r\n\t\t\t\t\tret =false;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase BPPacket.VAL_TYPE_IINT16: {\r\n\t\t\t\tCustomSignalI16InfoHbn customSignalI16InfoHbn = (CustomSignalI16InfoHbn)customSignalInterface;\r\n\t\t\t\tShort v = (Short)value;\r\n\t\t\t\tif(v >= customSignalI16InfoHbn.getMinVal() && v <= customSignalI16InfoHbn.getMaxVal()) {\r\n\t\t\t\t\tret =false;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase BPPacket.VAL_TYPE_ENUM: {\r\n\t\t\t\tInteger v = (Integer)value;\r\n\t\t\t\tIterator<Map.Entry<Integer, Map<Integer, String> > > it = signalEnumLangMap.entrySet().iterator();\r\n\t\t\t\tif(it.hasNext()) {\r\n\t\t\t\t\tMap<Integer, String> signalEnumValueMap = it.next().getValue();\r\n\t\t\t\t\tif(null != signalEnumValueMap && signalEnumValueMap.containsKey(v)) {\r\n\t\t\t\t\t\tret = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase BPPacket.VAL_TYPE_FLOAT: {\r\n\t\t\t\tCustomSignalFloatInfoHbn customSignalFloatInfoHbn = (CustomSignalFloatInfoHbn)customSignalInterface;\r\n\t\t\t\tFloat v = (Float)value;\r\n\t\t\t\tif(v >= customSignalFloatInfoHbn.getMinVal() && v <= customSignalFloatInfoHbn.getMaxVal()) {\r\n\t\t\t\t\tret =false;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase BPPacket.VAL_TYPE_STRING: {\r\n\t\t\t\tString v = (String)value;\r\n\t\t\t\tif(v.length() <= BPPacket.MAX_STR_LENGTH) {\r\n\t\t\t\t\tret = false;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase BPPacket.VAL_TYPE_BOOLEAN: {\r\n\t\t\t\tif(value instanceof Boolean) {\r\n\t\t\t\t\tret = false;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tdefault:\r\n\t\t\t\t/* do nothing */\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\tUtil.logger(logger, Util.ERROR, e);\r\n\t\t\tret = true;\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\tpublic Object getSignalValue() {\r\n\t\treturn signalValue;\r\n\t}\r\n\tpublic void setSignalValue(Object signalValue) {\r\n\t\tthis.signalValue = signalValue;\r\n\t}\r\n\t@Override\r\n\tpublic short getAlarmClass() {\r\n\t\treturn alarmClass;\r\n\t}\r\n\t@Override\r\n\tpublic short getAlarmDelayBef() {\r\n\t\treturn alarmDelayBef;\r\n\t}\r\n\t@Override\r\n\tpublic short getAlarmDelayAft() {\r\n\t\treturn alarmDelayAft;\r\n\t}\r\n}", "class_id": 0, "repo": "Ansersion/BcServer", "file": "beecom_server/beecom_server/src/db/CustomSignalInfoUnit.java", "last_update_at": "2019-09-08T14:01:49+00:00", "question_id": "72a1754027ce6cde68357c134bba2f46e9cbe0a3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CustomSignalInfoUnit implements SignalInfoUnitInterface {\r\n\tprivate static final Logger logger = LoggerFactory.getLogger(CustomSignalInfoUnit.class); \r\n\tprivate int cusSigId;\r\n\tprivate boolean ifNotifing;\r\n\tprivate boolean ifAlarm;\r\n\tprivate short alarmClass;\r\n\tprivate short alarmDelayBef;\r\n\tprivate short alarmDelayAft;\r\n\tprivate boolean ifDisplay;\r\n\t/* custom signal name language map */\r\n\tprivate Map<Integer, String> signalNameLangMap;\r\n\t/* custom signal unit language map */\r\n\tprivate Map<Integer, String> signalUnitLangMap;\r\n\t/* custom group language map */\r\n\tprivate Map<Integer, String> groupLangMap;\r\n\t/* custom enumerate signal language map */\r\n\tprivate Map<Integer, Map<Integer, String> > signalEnumLangMap;\r\n\t/* custom alarm info */\r\n\t\r\n\tprivate SignalInterface customSignalInterface;\r\n\tprivate Object signalValue;\r\n\t\r\n\r\n\tpublic CustomSignalInfoUnit(int cusSigId, boolean ifNotifing, boolean ifAlarm, short alarmClass,\r\n\t\t\tshort alarmDelayBef, short alarmDelayAft, boolean ifDisplay, Map<Integer, String> signalNameLangMap,\r\n\t\t\tMap<Integer, String> signalUnitLangMap, Map<Integer, String> groupLangMap,\r\n\t\t\tMap<Integer, Map<Integer, String>> signalEnumLangMap, SignalInterface customSignalInterface) {\r\n\t\tsuper();\r\n\t\tthis.cusSigId = cusSigId;\r\n\t\tthis.ifNotifing = ifNotifing;\r\n\t\tthis.ifAlarm = ifAlarm;\r\n\t\tthis.alarmClass = alarmClass;\r\n\t\tthis.alarmDelayBef = alarmDelayBef;\r\n\t\tthis.alarmDelayAft = alarmDelayAft;\r\n\t\tthis.ifDisplay = ifDisplay;\r\n\t\tthis.signalNameLangMap = signalNameLangMap;\r\n\t\tthis.signalUnitLangMap = signalUnitLangMap;\r\n\t\tthis.groupLangMap = groupLangMap;\r\n\t\tthis.signalEnumLangMap = signalEnumLangMap;\r\n\t\tthis.customSignalInterface = customSignalInterface;\r\n\t}\r\n\t\r\n\tpublic boolean isIfNotifing() {\r\n\t\treturn ifNotifing;\r\n\t}\r\n\tpublic boolean isIfAlarm() {\r\n\t\treturn ifAlarm;\r\n\t}\r\n\tpublic boolean isIfDisplay() {\r\n\t\treturn ifDisplay;\r\n\t}\r\n\tpublic Map<Integer, String> getSignalNameLangMap() {\r\n\t\treturn signalNameLangMap;\r\n\t}\r\n\tpublic Map<Integer, String> getGroupLangMap() {\r\n\t\treturn groupLangMap;\r\n\t}\r\n\tpublic Map<Integer, Map<Integer, String>> getSignalEnumLangMap() {\r\n\t\treturn signalEnumLangMap;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn \"CustomSignalInfoUnit [cusSigId=\" + cusSigId + \", ifNotifing=\" + ifNotifing + \", ifAlarm=\" + ifAlarm\r\n\t\t\t\t+ \", alarmClass=\" + alarmClass + \", alarmDelayBef=\" + alarmDelayBef + \", alarmDelayAft=\" + alarmDelayAft\r\n\t\t\t\t+ \", ifDisplay=\" + ifDisplay + \", signalNameLangMap=\" + signalNameLangMap + \", signalUnitLangMap=\"\r\n\t\t\t\t+ signalUnitLangMap + \", groupLangMap=\" + groupLangMap + \", signalEnumLangMap=\" + signalEnumLangMap\r\n\t\t\t\t+ \", customSignalInterface=\" + customSignalInterface + \", signalValue=\" + signalValue + \"]\";\r\n\t}\r\n\r\n\t@Override\r\n\tpublic boolean ifNotifying() {\r\n\t\treturn ifNotifing;\r\n\t}\r\n\t@Override\r\n\tpublic int getSignalId() {\r\n\t\treturn cusSigId;\r\n\t}\r\n\t@Override\r\n\tpublic SignalInterface getSignalInterface() {\r\n\t\treturn customSignalInterface;\r\n\t}\r\n\t@Override\r\n\tpublic boolean ifConfigDef() {\r\n\t\treturn false;\r\n\t}\r\n\t@Override\r\n\tpublic boolean ifAlarm() {\r\n\t\treturn ifAlarm;\r\n\t}\r\n\t@Override\r\n\tpublic boolean ifDisplay() {\r\n\t\treturn ifDisplay;\r\n\t}\r\n\t@Override\r\n\tpublic Map<Integer, String> getSignalUnitLangMap() {\r\n\t\treturn signalUnitLangMap;\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic boolean putSignalValue(Entry<Integer, Map.Entry<Byte, Object>> entry) {\r\n\t\tboolean ret = false;\r\n\t\ttry {\r\n\t\t\tsignalValue = entry.getValue().getValue();\r\n\t\t} catch(Exception e) {\r\n\t\t\tUtil.logger(logger, Util.ERROR, e);\r\n\t\t\tret = false;\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic boolean checkSignalValueUnformed(Byte valueType, Object value) {\r\n\t\tboolean ret = true;\r\n\t\t/* check if signal info exist */\r\n\t\tif(null == customSignalInterface) {\r\n\t\t\treturn ret;\r\n\t\t}\r\n\t\t/* check if a alarm signal */\r\n\t\tif(!ifAlarm && (valueType & BPPacket.VAL_ALARM_FLAG) != 0) {\r\n\t\t\treturn ret;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tswitch (valueType & BPPacket.VAL_TYPE_MASK) {\r\n\t\t\tcase BPPacket.VAL_TYPE_UINT32: {\r\n\t\t\t\tCustomSignalU32InfoHbn customSignalU32InfoHbn = (CustomSignalU32InfoHbn)customSignalInterface;\r\n\t\t\t\tLong v = (Long)value;\r\n\t\t\t\tif(v >= customSignalU32InfoHbn.getMinVal() && v <= customSignalU32InfoHbn.getMaxVal()) {\r\n\t\t\t\t\tret =false;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase BPPacket.VAL_TYPE_UINT16: {\r\n\t\t\t\tCustomSignalU16InfoHbn customSignalU16InfoHbn = (CustomSignalU16InfoHbn)customSignalInterface;\r\n\t\t\t\tInteger v = (Integer)value;\r\n\t\t\t\tif(v >= customSignalU16InfoHbn.getMinVal() && v <= customSignalU16InfoHbn.getMaxVal()) {\r\n\t\t\t\t\tret =false;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase BPPacket.VAL_TYPE_IINT32: {\r\n\t\t\t\tCustomSignalI32InfoHbn customSignalI32InfoHbn = (CustomSignalI32InfoHbn)customSignalInterface;\r\n\t\t\t\tInteger v = (Integer)value;\r\n\t\t\t\tif(v >= customSignalI32InfoHbn.getMinVal() && v <= customSignalI32InfoHbn.getMaxVal()) {\r\n\t\t\t\t\tret =false;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase BPPacket.VAL_TYPE_IINT16: {\r\n\t\t\t\tCustomSignalI16InfoHbn customSignalI16InfoHbn = (CustomSignalI16InfoHbn)customSignalInterface;\r\n\t\t\t\tShort v = (Short)value;\r\n\t\t\t\tif(v >= customSignalI16InfoHbn.getMinVal() && v <= customSignalI16InfoHbn.getMaxVal()) {\r\n\t\t\t\t\tret =false;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase BPPacket.VAL_TYPE_ENUM: {\r\n\t\t\t\tInteger v = (Integer)value;\r\n\t\t\t\tIterator<Map.Entry<Integer, Map<Integer, String> > > it = signalEnumLangMap.entrySet().iterator();\r\n\t\t\t\tif(it.hasNext()) {\r\n\t\t\t\t\tMap<Integer, String> signalEnumValueMap = it.next().getValue();\r\n\t\t\t\t\tif(null != signalEnumValueMap && signalEnumValueMap.containsKey(v)) {\r\n\t\t\t\t\t\tret = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase BPPacket.VAL_TYPE_FLOAT: {\r\n\t\t\t\tCustomSignalFloatInfoHbn customSignalFloatInfoHbn = (CustomSignalFloatInfoHbn)customSignalInterface;\r\n\t\t\t\tFloat v = (Float)value;\r\n\t\t\t\tif(v >= customSignalFloatInfoHbn.getMinVal() && v <= customSignalFloatInfoHbn.getMaxVal()) {\r\n\t\t\t\t\tret =false;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase BPPacket.VAL_TYPE_STRING: {\r\n\t\t\t\tString v = (String)value;\r\n\t\t\t\tif(v.length() <= BPPacket.MAX_STR_LENGTH) {\r\n\t\t\t\t\tret = false;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase BPPacket.VAL_TYPE_BOOLEAN: {\r\n\t\t\t\tif(value instanceof Boolean) {\r\n\t\t\t\t\tret = false;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tdefault:\r\n\t\t\t\t/* do nothing */\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\tUtil.logger(logger, Util.ERROR, e);\r\n\t\t\tret = true;\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\tpublic Object getSignalValue() {\r\n\t\treturn signalValue;\r\n\t}\r\n\tpublic void setSignalValue(Object signalValue) {\r\n\t\tthis.signalValue = signalValue;\r\n\t}\r\n\t@Override\r\n\tpublic short getAlarmClass() {\r\n\t\treturn alarmClass;\r\n\t}\r\n\t@Override\r\n\tpublic short getAlarmDelayBef() {\r\n\t\treturn alarmDelayBef;\r\n\t}\r\n\t@Override\r\n\tpublic short getAlarmDelayAft() {\r\n\t\treturn alarmDelayAft;\r\n\t}\r\n"]]}
{"hexsha": "3b1ba4da378b6581930b861293808a8b08adb495", "ext": "java", "lang": "Java", "content": "@RunWith(SpringRunner.class)\n@SpringBootTest\n@ContextConfiguration(classes = CrowDemon.class)\n@TestPropertySource(locations = \"classpath:testDockerExecution.properties\")\npublic class SpringDockerExecutionIT implements IJobLogger {\n\n\tpublic static final String CONTAINER_NAME = \"SpringDockerExecutionIT\";\n\n\tprivate Logger LOG = LoggerFactory.getLogger(SpringDockerExecutionIT.class);\n\n\tpublic IDockerClientTest containerFactory;\n\n\tpublic List<String> containers = new LinkedList<>();\n\n\tpublic IDockerClient dockerClient;\n\n\tpublic ByteArrayOutputStream outStream;\n\n\tpublic ByteArrayOutputStream outErrorStream;\n\n\tpublic List<IJobLogger> logger;\n\n\tpublic CountDownLatch latch;\n\n\t@Autowired\n\tJobRepository repository;\n\n\t@Autowired\n\tJobDispatcher dispatcher;\n\n\t@Before\n\tpublic void setup() throws DockerCertificateException, DockerException, InterruptedException {\n\t\tdockerClient = DockerClientFactory.initializeDockerClient();\n\t\tcontainerFactory = DockerTestClientFactory.initializeDockerClient();\n\t\tlogger = new ArrayList<>();\n\t\tlogger.add(this);\n\t\tlatch = new CountDownLatch(1);\n\t}\n\n\t@After\n\tpublic void tearDown() {\n\t\tcontainerFactory.deleteContainers();\n\t}\n\n\t@Test\n\tpublic void testRepository_ListJobs_TwoDockerJobsAdded() {\n\t\tList<CrowConfiguration> jobs = repository.listJobs();\n\n\t\tassertEquals(Integer.valueOf(1), Integer.valueOf(jobs.size()));\n\t\tjobs.stream().forEach(j -> assertNotNull(j.getContainerName().orElse(null)));\n\t}\n\n\t@Test\n\tpublic void testExecution_ExecuteManually_OutputCorrect() throws DockerException, InterruptedException {\n\t\tOptional<CrowConfiguration> job = repository.listJobs().stream().filter(j -> \"EchoDockerContainer\".equals(j\n\t\t\t\t.getJobName().orElse(null))).findFirst();\n\t\tthis.containerFactory.runContainer(CONTAINER_NAME);\n\n\t\tthis.dispatcher.execute(JobId.of(job.get().getJobId().orElse(null)), null, logger);\n\t\tlatch.await();\n\n\t\tString output = new String(this.outStream.toByteArray());\n\t\tassertEquals(\"Hello Docker World!\\n\", output);\n\t}\n\n\t@Test\n\tpublic void testExecution_ExecuteTestExecutionManually_OutputCorrect() throws DockerException,\n\t\t\tInterruptedException {\n\t\tOptional<CrowConfiguration> job = repository.listJobs().stream().filter(j -> \"EchoDockerContainer\".equals(j\n\t\t\t\t.getJobName().orElse(null))).findFirst();\n\t\tthis.containerFactory.runContainer(CONTAINER_NAME);\n\n\t\tthis.dispatcher.testExecute(JobId.of(job.get().getJobId().orElse(null)), null, logger);\n\t\tlatch.await();\n\n\t\tString output = new String(this.outStream.toByteArray());\n\t\tassertEquals(\"Hello Docker World!\\n\", output);\n\t}\n\n\t@Override\n\tpublic void initializeLogger() {\n\t\tthis.outStream = new ByteArrayOutputStream();\n\t\tthis.outErrorStream = new ByteArrayOutputStream();\n\t}\n\n\t@Override\n\tpublic void finishLogger() {\n\t\ttry {\n\t\t\toutStream.close();\n\t\t\toutErrorStream.close();\n\t\t} catch (IOException e) {\n\t\t\tLOG.error(\"Error closing streams!\", e);\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\tlatch.countDown();\n\t}\n\n\t@Override\n\tpublic OutputStream getInfoLogConsumer() {\n\t\treturn this.outStream;\n\t}\n\n\t@Override\n\tpublic OutputStream getErrorLogConsumer() {\n\t\treturn this.outErrorStream;\n\t}\n\n}", "class_id": 0, "repo": "blacklabelops/crow", "file": "application/src/test/java/com/blacklabelops/crow/application/application/SpringDockerExecutionIT.java", "last_update_at": "2019-09-17T01:59:39+00:00", "question_id": "3b1ba4da378b6581930b861293808a8b08adb495", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(SpringRunner.class)\n@SpringBootTest\n@ContextConfiguration(classes = CrowDemon.class)\n@TestPropertySource(locations = \"classpath:testDockerExecution.properties\")\npublic class SpringDockerExecutionIT implements IJobLogger {\n\tpublic static final String CONTAINER_NAME = \"SpringDockerExecutionIT\";\n\tprivate Logger LOG = LoggerFactory.getLogger(SpringDockerExecutionIT.class);\n\tpublic IDockerClientTest containerFactory;\n\tpublic List<String> containers = new LinkedList<>();\n\tpublic IDockerClient dockerClient;\n\tpublic ByteArrayOutputStream outStream;\n\tpublic ByteArrayOutputStream outErrorStream;\n\tpublic List<IJobLogger> logger;\n\tpublic CountDownLatch latch;\n\t@Autowired\n\tJobRepository repository;\n\t@Autowired\n\tJobDispatcher dispatcher;\n\t@Before\n\tpublic void setup() throws DockerCertificateException, DockerException, InterruptedException {\n\t\tdockerClient = DockerClientFactory.initializeDockerClient();\n\t\tcontainerFactory = DockerTestClientFactory.initializeDockerClient();\n\t\tlogger = new ArrayList<>();\n\t\tlogger.add(this);\n\t\tlatch = new CountDownLatch(1);\n\t}\n\t@After\n\tpublic void tearDown() {\n\t\tcontainerFactory.deleteContainers();\n\t}\n\t@Test\n\tpublic void testRepository_ListJobs_TwoDockerJobsAdded() {\n\t\tList<CrowConfiguration> jobs = repository.listJobs();\n\t\tassertEquals(Integer.valueOf(1), Integer.valueOf(jobs.size()));\n\t\tjobs.stream().forEach(j -> assertNotNull(j.getContainerName().orElse(null)));\n\t}\n\t@Test\n\tpublic void testExecution_ExecuteManually_OutputCorrect() throws DockerException, InterruptedException {\n\t\tOptional<CrowConfiguration> job = repository.listJobs().stream().filter(j -> \"EchoDockerContainer\".equals(j\n\t\t\t\t.getJobName().orElse(null))).findFirst();\n\t\tthis.containerFactory.runContainer(CONTAINER_NAME);\n\t\tthis.dispatcher.execute(JobId.of(job.get().getJobId().orElse(null)), null, logger);\n\t\tlatch.await();\n\t\tString output = new String(this.outStream.toByteArray());\n\t\tassertEquals(\"Hello Docker World!\\n\", output);\n\t}\n\t@Test\n\tpublic void testExecution_ExecuteTestExecutionManually_OutputCorrect() throws DockerException,\n\t\t\tInterruptedException {\n\t\tOptional<CrowConfiguration> job = repository.listJobs().stream().filter(j -> \"EchoDockerContainer\".equals(j\n\t\t\t\t.getJobName().orElse(null))).findFirst();\n\t\tthis.containerFactory.runContainer(CONTAINER_NAME);\n\t\tthis.dispatcher.testExecute(JobId.of(job.get().getJobId().orElse(null)), null, logger);\n\t\tlatch.await();\n\t\tString output = new String(this.outStream.toByteArray());\n\t\tassertEquals(\"Hello Docker World!\\n\", output);\n\t}\n\t@Override\n\tpublic void initializeLogger() {\n\t\tthis.outStream = new ByteArrayOutputStream();\n\t\tthis.outErrorStream = new ByteArrayOutputStream();\n\t}\n\t@Override\n\tpublic void finishLogger() {\n\t\ttry {\n\t\t\toutStream.close();\n\t\t\toutErrorStream.close();\n\t\t} catch (IOException e) {\n\t\t\tLOG.error(\"Error closing streams!\", e);\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\tlatch.countDown();\n\t}\n\t@Override\n\tpublic OutputStream getInfoLogConsumer() {\n\t\treturn this.outStream;\n\t}\n\t@Override\n\tpublic OutputStream getErrorLogConsumer() {\n\t\treturn this.outErrorStream;\n\t}\n"]]}
{"hexsha": "ce97e1323f28c32feafdaa565129dd4c401eb343", "ext": "java", "lang": "Java", "content": "@Table(name = \"oauth_client_details\")\npublic class OAuthClientDetails {\n    @Id\n    @Column(name = \"client_id\")\n    private String clientId;\n\n    @Column(name = \"resource_ids\")\n    private String resourceIds;\n\n    @Column(name = \"client_secret\")\n    private String clientSecret;\n\n    private String scope;\n\n    @Column(name = \"authorized_grant_types\")\n    private String authorizedGrantTypes;\n\n    @Column(name = \"web_server_redirect_uri\")\n    private String webServerRedirectUri;\n\n    private String authorities;\n\n    @Column(name = \"access_token_validity\")\n    private Integer accessTokenValidity;\n\n    @Column(name = \"refresh_token_validity\")\n    private Integer refreshTokenValidity;\n\n    @Column(name = \"additional_information\")\n    private String additionalInformation;\n\n    private String autoapprove;\n\n    @Column(name = \"created_at\")\n    private Date createdAt;\n\n    @Column(name = \"updated_at\")\n    private Date updatedAt;\n\n    @Column(name = \"deleted_at\")\n    private Date deletedAt;\n\n    /**\n     * @return client_id\n     */\n    public String getClientId() {\n        return clientId;\n    }\n\n    /**\n     * @param clientId\n     */\n    public void setClientId(String clientId) {\n        this.clientId = clientId;\n    }\n\n    /**\n     * @return resource_ids\n     */\n    public String getResourceIds() {\n        return resourceIds;\n    }\n\n    /**\n     * @param resourceIds\n     */\n    public void setResourceIds(String resourceIds) {\n        this.resourceIds = resourceIds;\n    }\n\n    /**\n     * @return client_secret\n     */\n    public String getClientSecret() {\n        return clientSecret;\n    }\n\n    /**\n     * @param clientSecret\n     */\n    public void setClientSecret(String clientSecret) {\n        this.clientSecret = clientSecret;\n    }\n\n    /**\n     * @return scope\n     */\n    public String getScope() {\n        return scope;\n    }\n\n    /**\n     * @param scope\n     */\n    public void setScope(String scope) {\n        this.scope = scope;\n    }\n\n    /**\n     * @return authorized_grant_types\n     */\n    public String getAuthorizedGrantTypes() {\n        return authorizedGrantTypes;\n    }\n\n    /**\n     * @param authorizedGrantTypes\n     */\n    public void setAuthorizedGrantTypes(String authorizedGrantTypes) {\n        this.authorizedGrantTypes = authorizedGrantTypes;\n    }\n\n    /**\n     * @return web_server_redirect_uri\n     */\n    public String getWebServerRedirectUri() {\n        return webServerRedirectUri;\n    }\n\n    /**\n     * @param webServerRedirectUri\n     */\n    public void setWebServerRedirectUri(String webServerRedirectUri) {\n        this.webServerRedirectUri = webServerRedirectUri;\n    }\n\n    /**\n     * @return authorities\n     */\n    public String getAuthorities() {\n        return authorities;\n    }\n\n    /**\n     * @param authorities\n     */\n    public void setAuthorities(String authorities) {\n        this.authorities = authorities;\n    }\n\n    /**\n     * @return access_token_validity\n     */\n    public Integer getAccessTokenValidity() {\n        return accessTokenValidity;\n    }\n\n    /**\n     * @param accessTokenValidity\n     */\n    public void setAccessTokenValidity(Integer accessTokenValidity) {\n        this.accessTokenValidity = accessTokenValidity;\n    }\n\n    /**\n     * @return refresh_token_validity\n     */\n    public Integer getRefreshTokenValidity() {\n        return refreshTokenValidity;\n    }\n\n    /**\n     * @param refreshTokenValidity\n     */\n    public void setRefreshTokenValidity(Integer refreshTokenValidity) {\n        this.refreshTokenValidity = refreshTokenValidity;\n    }\n\n    /**\n     * @return additional_information\n     */\n    public String getAdditionalInformation() {\n        return additionalInformation;\n    }\n\n    /**\n     * @param additionalInformation\n     */\n    public void setAdditionalInformation(String additionalInformation) {\n        this.additionalInformation = additionalInformation;\n    }\n\n    /**\n     * @return autoapprove\n     */\n    public String getAutoapprove() {\n        return autoapprove;\n    }\n\n    /**\n     * @param autoapprove\n     */\n    public void setAutoapprove(String autoapprove) {\n        this.autoapprove = autoapprove;\n    }\n\n    /**\n     * @return created_at\n     */\n    public Date getCreatedAt() {\n        return createdAt;\n    }\n\n    /**\n     * @param createdAt\n     */\n    public void setCreatedAt(Date createdAt) {\n        this.createdAt = createdAt;\n    }\n\n    /**\n     * @return updated_at\n     */\n    public Date getUpdatedAt() {\n        return updatedAt;\n    }\n\n    /**\n     * @param updatedAt\n     */\n    public void setUpdatedAt(Date updatedAt) {\n        this.updatedAt = updatedAt;\n    }\n\n    /**\n     * @return deleted_at\n     */\n    public Date getDeletedAt() {\n        return deletedAt;\n    }\n\n    /**\n     * @param deletedAt\n     */\n    public void setDeletedAt(Date deletedAt) {\n        this.deletedAt = deletedAt;\n    }\n\n    public static ClientDetails ClientDetailsBuilder(OAuthClientDetails oAuthClientDetails){\n\n        BaseClientDetails newClientDetails = new BaseClientDetails(oAuthClientDetails.getClientId(),\n                oAuthClientDetails.getResourceIds(),\n                oAuthClientDetails.getScope(),\n                oAuthClientDetails.getAuthorizedGrantTypes(),\n                oAuthClientDetails.getAuthorities(),\n                oAuthClientDetails.getWebServerRedirectUri()\n                );\n        newClientDetails.setClientSecret(oAuthClientDetails.getClientSecret());\n//        newClientDetails.setAdditionalInformation();\n        return newClientDetails;\n    }\n}", "class_id": 0, "repo": "EtachGu/OAuth2SSO", "file": "Auth/src/main/java/com/auth/entity/OAuthClientDetails.java", "last_update_at": "2019-03-25T02:07:12+00:00", "question_id": "ce97e1323f28c32feafdaa565129dd4c401eb343", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Table(name = \"oauth_client_details\")\npublic class OAuthClientDetails {\n    @Id\n    @Column(name = \"client_id\")\n    private String clientId;\n    @Column(name = \"resource_ids\")\n    private String resourceIds;\n    @Column(name = \"client_secret\")\n    private String clientSecret;\n    private String scope;\n    @Column(name = \"authorized_grant_types\")\n    private String authorizedGrantTypes;\n    @Column(name = \"web_server_redirect_uri\")\n    private String webServerRedirectUri;\n    private String authorities;\n    @Column(name = \"access_token_validity\")\n    private Integer accessTokenValidity;\n    @Column(name = \"refresh_token_validity\")\n    private Integer refreshTokenValidity;\n    @Column(name = \"additional_information\")\n    private String additionalInformation;\n    private String autoapprove;\n    @Column(name = \"created_at\")\n    private Date createdAt;\n    @Column(name = \"updated_at\")\n    private Date updatedAt;\n    @Column(name = \"deleted_at\")\n    private Date deletedAt;\n    /**\n     * @return client_id\n     */\n    public String getClientId() {\n        return clientId;\n    }\n    /**\n     * @param clientId\n     */\n    public void setClientId(String clientId) {\n        this.clientId = clientId;\n    }\n    /**\n     * @return resource_ids\n     */\n    public String getResourceIds() {\n        return resourceIds;\n    }\n    /**\n     * @param resourceIds\n     */\n    public void setResourceIds(String resourceIds) {\n        this.resourceIds = resourceIds;\n    }\n    /**\n     * @return client_secret\n     */\n    public String getClientSecret() {\n        return clientSecret;\n    }\n    /**\n     * @param clientSecret\n     */\n    public void setClientSecret(String clientSecret) {\n        this.clientSecret = clientSecret;\n    }\n    /**\n     * @return scope\n     */\n    public String getScope() {\n        return scope;\n    }\n    /**\n     * @param scope\n     */\n    public void setScope(String scope) {\n        this.scope = scope;\n    }\n    /**\n     * @return authorized_grant_types\n     */\n    public String getAuthorizedGrantTypes() {\n        return authorizedGrantTypes;\n    }\n    /**\n     * @param authorizedGrantTypes\n     */\n    public void setAuthorizedGrantTypes(String authorizedGrantTypes) {\n        this.authorizedGrantTypes = authorizedGrantTypes;\n    }\n    /**\n     * @return web_server_redirect_uri\n     */\n    public String getWebServerRedirectUri() {\n        return webServerRedirectUri;\n    }\n    /**\n     * @param webServerRedirectUri\n     */\n    public void setWebServerRedirectUri(String webServerRedirectUri) {\n        this.webServerRedirectUri = webServerRedirectUri;\n    }\n    /**\n     * @return authorities\n     */\n    public String getAuthorities() {\n        return authorities;\n    }\n    /**\n     * @param authorities\n     */\n    public void setAuthorities(String authorities) {\n        this.authorities = authorities;\n    }\n    /**\n     * @return access_token_validity\n     */\n    public Integer getAccessTokenValidity() {\n        return accessTokenValidity;\n    }\n    /**\n     * @param accessTokenValidity\n     */\n    public void setAccessTokenValidity(Integer accessTokenValidity) {\n        this.accessTokenValidity = accessTokenValidity;\n    }\n    /**\n     * @return refresh_token_validity\n     */\n    public Integer getRefreshTokenValidity() {\n        return refreshTokenValidity;\n    }\n    /**\n     * @param refreshTokenValidity\n     */\n    public void setRefreshTokenValidity(Integer refreshTokenValidity) {\n        this.refreshTokenValidity = refreshTokenValidity;\n    }\n    /**\n     * @return additional_information\n     */\n    public String getAdditionalInformation() {\n        return additionalInformation;\n    }\n    /**\n     * @param additionalInformation\n     */\n    public void setAdditionalInformation(String additionalInformation) {\n        this.additionalInformation = additionalInformation;\n    }\n    /**\n     * @return autoapprove\n     */\n    public String getAutoapprove() {\n        return autoapprove;\n    }\n    /**\n     * @param autoapprove\n     */\n    public void setAutoapprove(String autoapprove) {\n        this.autoapprove = autoapprove;\n    }\n    /**\n     * @return created_at\n     */\n    public Date getCreatedAt() {\n        return createdAt;\n    }\n    /**\n     * @param createdAt\n     */\n    public void setCreatedAt(Date createdAt) {\n        this.createdAt = createdAt;\n    }\n    /**\n     * @return updated_at\n     */\n    public Date getUpdatedAt() {\n        return updatedAt;\n    }\n    /**\n     * @param updatedAt\n     */\n    public void setUpdatedAt(Date updatedAt) {\n        this.updatedAt = updatedAt;\n    }\n    /**\n     * @return deleted_at\n     */\n    public Date getDeletedAt() {\n        return deletedAt;\n    }\n    /**\n     * @param deletedAt\n     */\n    public void setDeletedAt(Date deletedAt) {\n        this.deletedAt = deletedAt;\n    }\n    public static ClientDetails ClientDetailsBuilder(OAuthClientDetails oAuthClientDetails){\n        BaseClientDetails newClientDetails = new BaseClientDetails(oAuthClientDetails.getClientId(),\n                oAuthClientDetails.getResourceIds(),\n                oAuthClientDetails.getScope(),\n                oAuthClientDetails.getAuthorizedGrantTypes(),\n                oAuthClientDetails.getAuthorities(),\n                oAuthClientDetails.getWebServerRedirectUri()\n                );\n        newClientDetails.setClientSecret(oAuthClientDetails.getClientSecret());\n//        newClientDetails.setAdditionalInformation();\n        return newClientDetails;\n    }\n"]]}
{"hexsha": "e0880c606fbbafdce24a11d26466e2e0ad36f48d", "ext": "java", "lang": "Java", "content": "@Slf4j\npublic final class SymbolPortfolioRecord implements WriteBytesMarshallable, StateHash {\n\n    public final long uid;\n\n    public final int symbol;\n    public final int currency;\n\n    // open positions state (for margin trades only)\n    public PortfolioPosition position = PortfolioPosition.EMPTY;\n    public long openVolume = 0;\n    public long openPriceSum = 0; //\n    public long profit = 0;\n\n    // pending orders total size\n    // increment before sending order to matching engine\n    // decrement after receiving trade confirmation from matching engine\n    public long pendingSellSize = 0;\n    public long pendingBuySize = 0;\n\n    public SymbolPortfolioRecord(long uid, int symbol, int currency) {\n        this.uid = uid;\n\n        this.symbol = symbol;\n        this.currency = currency;\n    }\n\n    public SymbolPortfolioRecord(long uid, BytesIn bytes) {\n        this.uid = uid;\n\n        this.symbol = bytes.readInt();\n        this.currency = bytes.readInt();\n        this.position = PortfolioPosition.of(bytes.readByte());\n        this.openVolume = bytes.readLong();\n        this.openPriceSum = bytes.readLong();\n        this.profit = bytes.readLong();\n        this.pendingSellSize = bytes.readLong();\n        this.pendingBuySize = bytes.readLong();\n    }\n\n\n    /**\n     * Check if portfolio is empty (no pending orders, no open trades) - can remove it from hashmap\n     *\n     * @return true if portfolio is empty (no pending orders, no open trades)\n     */\n    public boolean isEmpty() {\n        return position == PortfolioPosition.EMPTY\n                && pendingSellSize == 0\n                && pendingBuySize == 0;\n    }\n\n    public void pendingHold(OrderAction orderAction, long size) {\n        if (orderAction == OrderAction.ASK) {\n            pendingSellSize += size;\n        } else {\n            pendingBuySize += size;\n        }\n    }\n\n    public void pendingRelease(OrderAction orderAction, long size) {\n        if (orderAction == OrderAction.ASK) {\n            pendingSellSize -= size;\n        } else {\n            pendingBuySize -= size;\n        }\n\n//        if (pendingSellSize < 0 || pendingBuySize < 0) {\n//            log.error(\"uid {} : pendingSellSize:{} pendingBuySize:{}\", uid, pendingSellSize, pendingBuySize);\n//        }\n    }\n\n    public long estimateProfit(final CoreSymbolSpecification spec, final RiskEngine.LastPriceCacheRecord lastPriceCacheRecord) {\n        switch (position) {\n            case EMPTY:\n                return profit;\n            case LONG:\n                return profit + ((lastPriceCacheRecord != null && lastPriceCacheRecord.bidPrice != 0)\n                        ? (openVolume * lastPriceCacheRecord.bidPrice - openPriceSum)\n                        : spec.depositBuy * openVolume); // unknown price - no liquidity - require extra margin\n            case SHORT:\n                return profit + ((lastPriceCacheRecord != null && lastPriceCacheRecord.askPrice != Long.MAX_VALUE)\n                        ? (openPriceSum - openVolume * lastPriceCacheRecord.askPrice)\n                        : spec.depositSell * openVolume); // unknown price - no liquidity - require extra margin\n            default:\n                throw new IllegalStateException();\n        }\n    }\n\n    /**\n     * Calculate required deposit based on specification and current position/orders\n     *\n     * @param spec\n     * @return\n     */\n    public long calculateRequiredDepositForFutures(CoreSymbolSpecification spec) {\n        final long specDepositBuy = spec.depositBuy;\n        final long specDepositSell = spec.depositSell;\n\n        final long signedPosition = openVolume * position.getMultiplier();\n        final long currentRiskBuySize = pendingBuySize + signedPosition;\n        final long currentRiskSellSize = pendingSellSize - signedPosition;\n\n        final long depositBuy = specDepositBuy * currentRiskBuySize;\n        final long depositSell = specDepositSell * currentRiskSellSize;\n        // depositBuy or depositSell can be negative, but not both of them\n        return Math.max(depositBuy, depositSell);\n    }\n\n    /**\n     * Calculate required deposit based on specification and current position/orders\n     * considering extra size added to current position (or outstanding orders)\n     *\n     * @param spec   symbols specification\n     * @param action order action\n     * @param size   order size\n     * @return -1 if order will reduce current exposure (no additional margin required), otherwise full deposit for symbol position if order placed/executed\n     */\n    public long calculateRequiredDepositForOrder(final CoreSymbolSpecification spec, final OrderAction action, final long size) {\n        final long specDepositBuy = spec.depositBuy;\n        final long specDepositSell = spec.depositSell;\n\n        final long signedPosition = openVolume * position.getMultiplier();\n        final long currentRiskBuySize = pendingBuySize + signedPosition;\n        final long currentRiskSellSize = pendingSellSize - signedPosition;\n\n        long depositBuy = specDepositBuy * currentRiskBuySize;\n        long depositSell = specDepositSell * currentRiskSellSize;\n        // either depositBuy or depositSell can be negative (because of signedPosition), but not both of them\n        final long currentDeposit = Math.max(depositBuy, depositSell);\n\n        if (action == OrderAction.BID) {\n            depositBuy += spec.depositBuy * size;\n        } else {\n            depositSell += spec.depositSell * size;\n        }\n\n        // depositBuy or depositSell can be negative, but not both of them\n        final long newDeposit = Math.max(depositBuy, depositSell);\n\n        return (newDeposit <= currentDeposit) ? -1 : newDeposit;\n    }\n\n\n    /**\n     * Update portfolio for one user\n     * 1. Un-hold pending size\n     * 2. Reduce opposite position accordingly (if exists)\n     * 3. Increase forward position accordingly (if size left in the trading event)\n     */\n    public void updatePortfolioForMarginTrade(OrderAction action, long size, long price, final long commission) {\n\n        // 1. Un-hold pending size\n        pendingRelease(action, size);\n\n        // 2. Reduce opposite position accordingly (if exists)\n        final long sizeToOpen = closeCurrentPositionFutures(action, size, price);\n\n        // 3. Increase forward position accordingly (if size left in the trading event)\n        if (sizeToOpen > 0) {\n            openPositionFutures(action, sizeToOpen, price, commission);\n        }\n    }\n\n    private long closeCurrentPositionFutures(final OrderAction action, final long tradeSize, final long tradePrice) {\n\n        // log.debug(\"{} {} {} {} cur:{}-{} profit={}\", uid, action, tradeSize, tradePrice, position, totalSize, profit);\n\n        if (position == PortfolioPosition.EMPTY || position == PortfolioPosition.of(action)) {\n            // nothing to close\n            return tradeSize;\n        }\n\n        if (openVolume > tradeSize) {\n            // current position is bigger than trade size - just reduce position accordingly, don't fix profit\n            openVolume -= tradeSize;\n            openPriceSum -= tradeSize * tradePrice;\n            return 0;\n        }\n\n        // current position smaller than trade size, can close completely and calculate profit\n        profit += (openVolume * tradePrice - openPriceSum) * position.getMultiplier();\n        openPriceSum = 0;\n        position = PortfolioPosition.EMPTY;\n        final long sizeToOpen = tradeSize - openVolume;\n        openVolume = 0;\n\n        // validateInternalState();\n\n        return sizeToOpen;\n    }\n\n    private void openPositionFutures(OrderAction action, long sizeToOpen, long tradePrice, long commission) {\n        openVolume += sizeToOpen;\n        openPriceSum += tradePrice * sizeToOpen;\n        position = PortfolioPosition.of(action);\n        profit -= commission * sizeToOpen;\n\n        // validateInternalState();\n    }\n\n    @Override\n    public void writeMarshallable(BytesOut bytes) {\n        bytes.writeInt(symbol);\n        bytes.writeInt(currency);\n        bytes.writeByte((byte) position.getMultiplier());\n        bytes.writeLong(openVolume);\n        bytes.writeLong(openPriceSum);\n        bytes.writeLong(profit);\n        bytes.writeLong(pendingSellSize);\n        bytes.writeLong(pendingBuySize);\n    }\n\n    public void reset() {\n\n        // log.debug(\"records: {}, Pending B{} S{} total size: {}\", records.size(), pendingBuySize, pendingSellSize, totalSize);\n\n        pendingBuySize = 0;\n        pendingSellSize = 0;\n\n        openVolume = 0;\n        openPriceSum = 0;\n        position = PortfolioPosition.EMPTY;\n    }\n\n    public void validateInternalState() {\n        if (position == PortfolioPosition.EMPTY && (openVolume != 0 || openPriceSum != 0)) {\n            log.error(\"uid {} : position:{} totalSize:{} openPriceSum:{}\", uid, position, openVolume, openPriceSum);\n            throw new IllegalStateException();\n        }\n        if (position != PortfolioPosition.EMPTY && (openVolume <= 0 || openPriceSum <= 0)) {\n            log.error(\"uid {} : position:{} totalSize:{} openPriceSum:{}\", uid, position, openVolume, openPriceSum);\n            throw new IllegalStateException();\n        }\n\n        if (pendingSellSize < 0 || pendingBuySize < 0) {\n            log.error(\"uid {} : pendingSellSize:{} pendingBuySize:{}\", uid, pendingSellSize, pendingBuySize);\n            throw new IllegalStateException();\n        }\n    }\n\n    @Override\n    public int stateHash() {\n        return Objects.hash(symbol, currency, position.getMultiplier(), openVolume, openPriceSum, profit, pendingSellSize, pendingBuySize);\n    }\n\n    @Override\n    public String toString() {\n        return \"SPR{\" +\n                \"u\" + uid +\n                \" sym\" + symbol +\n                \" cur\" + currency +\n                \" pos\" + position +\n                \" \u03a3v=\" + openVolume +\n                \" \u03a3p=\" + openPriceSum +\n                \" pnl=\" + profit +\n                \" pendingS=\" + pendingSellSize +\n                \" pendingB=\" + pendingBuySize +\n                '}';\n    }\n}", "class_id": 0, "repo": "surfer1225/exchange-core", "file": "src/main/java/org/openpredict/exchange/beans/SymbolPortfolioRecord.java", "last_update_at": "2019-07-29T04:09:14+00:00", "question_id": "e0880c606fbbafdce24a11d26466e2e0ad36f48d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Slf4j\npublic final class SymbolPortfolioRecord implements WriteBytesMarshallable, StateHash {\n    public final long uid;\n    public final int symbol;\n    public final int currency;\n    // open positions state (for margin trades only)\n    public PortfolioPosition position = PortfolioPosition.EMPTY;\n    public long openVolume = 0;\n    public long openPriceSum = 0; //\n    public long profit = 0;\n    // pending orders total size\n    // increment before sending order to matching engine\n    // decrement after receiving trade confirmation from matching engine\n    public long pendingSellSize = 0;\n    public long pendingBuySize = 0;\n    public SymbolPortfolioRecord(long uid, int symbol, int currency) {\n        this.uid = uid;\n        this.symbol = symbol;\n        this.currency = currency;\n    }\n    public SymbolPortfolioRecord(long uid, BytesIn bytes) {\n        this.uid = uid;\n        this.symbol = bytes.readInt();\n        this.currency = bytes.readInt();\n        this.position = PortfolioPosition.of(bytes.readByte());\n        this.openVolume = bytes.readLong();\n        this.openPriceSum = bytes.readLong();\n        this.profit = bytes.readLong();\n        this.pendingSellSize = bytes.readLong();\n        this.pendingBuySize = bytes.readLong();\n    }\n    /**\n     * Check if portfolio is empty (no pending orders, no open trades) - can remove it from hashmap\n     *\n     * @return true if portfolio is empty (no pending orders, no open trades)\n     */\n    public boolean isEmpty() {\n        return position == PortfolioPosition.EMPTY\n                && pendingSellSize == 0\n                && pendingBuySize == 0;\n    }\n    public void pendingHold(OrderAction orderAction, long size) {\n        if (orderAction == OrderAction.ASK) {\n            pendingSellSize += size;\n        } else {\n            pendingBuySize += size;\n        }\n    }\n    public void pendingRelease(OrderAction orderAction, long size) {\n        if (orderAction == OrderAction.ASK) {\n            pendingSellSize -= size;\n        } else {\n            pendingBuySize -= size;\n        }\n//        if (pendingSellSize < 0 || pendingBuySize < 0) {\n//            log.error(\"uid {} : pendingSellSize:{} pendingBuySize:{}\", uid, pendingSellSize, pendingBuySize);\n//        }\n    }\n    public long estimateProfit(final CoreSymbolSpecification spec, final RiskEngine.LastPriceCacheRecord lastPriceCacheRecord) {\n        switch (position) {\n            case EMPTY:\n                return profit;\n            case LONG:\n                return profit + ((lastPriceCacheRecord != null && lastPriceCacheRecord.bidPrice != 0)\n                        ? (openVolume * lastPriceCacheRecord.bidPrice - openPriceSum)\n                        : spec.depositBuy * openVolume); // unknown price - no liquidity - require extra margin\n            case SHORT:\n                return profit + ((lastPriceCacheRecord != null && lastPriceCacheRecord.askPrice != Long.MAX_VALUE)\n                        ? (openPriceSum - openVolume * lastPriceCacheRecord.askPrice)\n                        : spec.depositSell * openVolume); // unknown price - no liquidity - require extra margin\n            default:\n                throw new IllegalStateException();\n        }\n    }\n    /**\n     * Calculate required deposit based on specification and current position/orders\n     *\n     * @param spec\n     * @return\n     */\n    public long calculateRequiredDepositForFutures(CoreSymbolSpecification spec) {\n        final long specDepositBuy = spec.depositBuy;\n        final long specDepositSell = spec.depositSell;\n        final long signedPosition = openVolume * position.getMultiplier();\n        final long currentRiskBuySize = pendingBuySize + signedPosition;\n        final long currentRiskSellSize = pendingSellSize - signedPosition;\n        final long depositBuy = specDepositBuy * currentRiskBuySize;\n        final long depositSell = specDepositSell * currentRiskSellSize;\n        // depositBuy or depositSell can be negative, but not both of them\n        return Math.max(depositBuy, depositSell);\n    }\n    /**\n     * Calculate required deposit based on specification and current position/orders\n     * considering extra size added to current position (or outstanding orders)\n     *\n     * @param spec   symbols specification\n     * @param action order action\n     * @param size   order size\n     * @return -1 if order will reduce current exposure (no additional margin required), otherwise full deposit for symbol position if order placed/executed\n     */\n    public long calculateRequiredDepositForOrder(final CoreSymbolSpecification spec, final OrderAction action, final long size) {\n        final long specDepositBuy = spec.depositBuy;\n        final long specDepositSell = spec.depositSell;\n        final long signedPosition = openVolume * position.getMultiplier();\n        final long currentRiskBuySize = pendingBuySize + signedPosition;\n        final long currentRiskSellSize = pendingSellSize - signedPosition;\n        long depositBuy = specDepositBuy * currentRiskBuySize;\n        long depositSell = specDepositSell * currentRiskSellSize;\n        // either depositBuy or depositSell can be negative (because of signedPosition), but not both of them\n        final long currentDeposit = Math.max(depositBuy, depositSell);\n        if (action == OrderAction.BID) {\n            depositBuy += spec.depositBuy * size;\n        } else {\n            depositSell += spec.depositSell * size;\n        }\n        // depositBuy or depositSell can be negative, but not both of them\n        final long newDeposit = Math.max(depositBuy, depositSell);\n        return (newDeposit <= currentDeposit) ? -1 : newDeposit;\n    }\n    /**\n     * Update portfolio for one user\n     * 1. Un-hold pending size\n     * 2. Reduce opposite position accordingly (if exists)\n     * 3. Increase forward position accordingly (if size left in the trading event)\n     */\n    public void updatePortfolioForMarginTrade(OrderAction action, long size, long price, final long commission) {\n        // 1. Un-hold pending size\n        pendingRelease(action, size);\n        // 2. Reduce opposite position accordingly (if exists)\n        final long sizeToOpen = closeCurrentPositionFutures(action, size, price);\n        // 3. Increase forward position accordingly (if size left in the trading event)\n        if (sizeToOpen > 0) {\n            openPositionFutures(action, sizeToOpen, price, commission);\n        }\n    }\n    private long closeCurrentPositionFutures(final OrderAction action, final long tradeSize, final long tradePrice) {\n        // log.debug(\"{} {} {} {} cur:{}-{} profit={}\", uid, action, tradeSize, tradePrice, position, totalSize, profit);\n        if (position == PortfolioPosition.EMPTY || position == PortfolioPosition.of(action)) {\n            // nothing to close\n            return tradeSize;\n        }\n        if (openVolume > tradeSize) {\n            // current position is bigger than trade size - just reduce position accordingly, don't fix profit\n            openVolume -= tradeSize;\n            openPriceSum -= tradeSize * tradePrice;\n            return 0;\n        }\n        // current position smaller than trade size, can close completely and calculate profit\n        profit += (openVolume * tradePrice - openPriceSum) * position.getMultiplier();\n        openPriceSum = 0;\n        position = PortfolioPosition.EMPTY;\n        final long sizeToOpen = tradeSize - openVolume;\n        openVolume = 0;\n        // validateInternalState();\n        return sizeToOpen;\n    }\n    private void openPositionFutures(OrderAction action, long sizeToOpen, long tradePrice, long commission) {\n        openVolume += sizeToOpen;\n        openPriceSum += tradePrice * sizeToOpen;\n        position = PortfolioPosition.of(action);\n        profit -= commission * sizeToOpen;\n        // validateInternalState();\n    }\n    @Override\n    public void writeMarshallable(BytesOut bytes) {\n        bytes.writeInt(symbol);\n        bytes.writeInt(currency);\n        bytes.writeByte((byte) position.getMultiplier());\n        bytes.writeLong(openVolume);\n        bytes.writeLong(openPriceSum);\n        bytes.writeLong(profit);\n        bytes.writeLong(pendingSellSize);\n        bytes.writeLong(pendingBuySize);\n    }\n    public void reset() {\n        // log.debug(\"records: {}, Pending B{} S{} total size: {}\", records.size(), pendingBuySize, pendingSellSize, totalSize);\n        pendingBuySize = 0;\n        pendingSellSize = 0;\n        openVolume = 0;\n        openPriceSum = 0;\n        position = PortfolioPosition.EMPTY;\n    }\n    public void validateInternalState() {\n        if (position == PortfolioPosition.EMPTY && (openVolume != 0 || openPriceSum != 0)) {\n            log.error(\"uid {} : position:{} totalSize:{} openPriceSum:{}\", uid, position, openVolume, openPriceSum);\n            throw new IllegalStateException();\n        }\n        if (position != PortfolioPosition.EMPTY && (openVolume <= 0 || openPriceSum <= 0)) {\n            log.error(\"uid {} : position:{} totalSize:{} openPriceSum:{}\", uid, position, openVolume, openPriceSum);\n            throw new IllegalStateException();\n        }\n        if (pendingSellSize < 0 || pendingBuySize < 0) {\n            log.error(\"uid {} : pendingSellSize:{} pendingBuySize:{}\", uid, pendingSellSize, pendingBuySize);\n            throw new IllegalStateException();\n        }\n    }\n    @Override\n    public int stateHash() {\n        return Objects.hash(symbol, currency, position.getMultiplier(), openVolume, openPriceSum, profit, pendingSellSize, pendingBuySize);\n    }\n    @Override\n    public String toString() {\n        return \"SPR{\" +\n                \"u\" + uid +\n                \" sym\" + symbol +\n                \" cur\" + currency +\n                \" pos\" + position +\n                \" \u03a3v=\" + openVolume +\n                \" \u03a3p=\" + openPriceSum +\n                \" pnl=\" + profit +\n                \" pendingS=\" + pendingSellSize +\n                \" pendingB=\" + pendingBuySize +\n                '}';\n    }\n"]]}
{"hexsha": "63a7db83f57a1d359c27d52be5eaaf01cbc7dbfd", "ext": "java", "lang": "Java", "content": "public class CVRequest extends ASN1Object {\n\n\tprivate final ASN1Integer cvRequestVersion = new ASN1Integer(1);\n\tprivate Query query = null;\n\tprivate GeneralNames requestorRef = null;\n\tprivate ASN1OctetString requestNonce = null;\n\tprivate GeneralName requestorName = null;\n\tprivate GeneralName responderName = null;\n\tprivate Extensions requestExtensions = null;\n\tprivate AlgorithmIdentifier signatureAlg = null;\n\tprivate ASN1ObjectIdentifier hashAlg = null;\n\tprivate DERUTF8String requestorText = null;\n\n\tpublic CVRequest(Query query, GeneralNames requestorRef,\n\t\t\tASN1OctetString requestNonce, GeneralName requestorName,\n\t\t\tGeneralName responderName, Extensions requestExtensions,\n\t\t\tAlgorithmIdentifier signatureAlg, ASN1ObjectIdentifier hashAlg,\n\t\t\tDERUTF8String requestorText) {\n\t\tthis.query = query;\n\t\tthis.requestorRef = requestorRef;\n\t\tthis.requestNonce = requestNonce;\n\t\tthis.requestorName = requestorName;\n\t\tthis.responderName = responderName;\n\t\tthis.requestExtensions = requestExtensions;\n\t\tthis.signatureAlg = signatureAlg;\n\t\tthis.hashAlg = hashAlg;\n\t\tthis.requestorText = requestorText;\n\t}\n\n\tprivate CVRequest(ASN1Sequence seq) {\n\t}\n\n\tpublic static CVRequest getInstance(ASN1TaggedObject obj, boolean explicit) {\n\t\treturn getInstance(ASN1Sequence.getInstance(obj, explicit));\n\t}\n\n\tpublic static CVRequest getInstance(Object obj) {\n\t\tif (obj instanceof CVRequest) {\n\t\t\treturn (CVRequest) obj;\n\t\t} else if (obj != null) {\n\t\t\treturn new CVRequest(ASN1Sequence.getInstance(obj));\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic ASN1Primitive toASN1Primitive() {\n\t\tASN1EncodableVector v = new ASN1EncodableVector();\n\t\tv.add(cvRequestVersion);\n\t\tv.add(query);\n\t\tif (requestorRef != null) {\n\t\t\tv.add(new DERTaggedObject(false, 0, requestorRef));\n\t\t}\n\t\tif (requestNonce != null) {\n\t\t\tv.add(new DERTaggedObject(false, 1, requestNonce));\n\t\t}\n\t\tif (requestorName != null) {\n\t\t\tv.add(new DERTaggedObject(false, 2, requestorName));\n\t\t}\n\t\tif (responderName != null) {\n\t\t\tv.add(new DERTaggedObject(false, 3, responderName));\n\t\t}\n\t\tif (requestExtensions != null) {\n\t\t\tv.add(new DERTaggedObject(false, 4, requestExtensions));\n\t\t}\n\t\tif (signatureAlg != null) {\n\t\t\tv.add(new DERTaggedObject(false, 5, signatureAlg));\n\t\t}\n\t\tif (hashAlg != null) {\n\t\t\tv.add(new DERTaggedObject(false, 6, hashAlg));\n\t\t}\n\t\tif (requestorText != null) {\n\t\t\tv.add(new DERTaggedObject(false, 7, requestorText));\n\t\t}\n\t\treturn new DERSequence(v);\n\t}\n\n}", "class_id": 0, "repo": "grandamp/SCVPAPI", "file": "src/org/keysupport/bc/scvp/asn1/CVRequest.java", "last_update_at": "2019-10-24T20:38:51+00:00", "question_id": "63a7db83f57a1d359c27d52be5eaaf01cbc7dbfd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CVRequest extends ASN1Object {\n\tprivate final ASN1Integer cvRequestVersion = new ASN1Integer(1);\n\tprivate Query query = null;\n\tprivate GeneralNames requestorRef = null;\n\tprivate ASN1OctetString requestNonce = null;\n\tprivate GeneralName requestorName = null;\n\tprivate GeneralName responderName = null;\n\tprivate Extensions requestExtensions = null;\n\tprivate AlgorithmIdentifier signatureAlg = null;\n\tprivate ASN1ObjectIdentifier hashAlg = null;\n\tprivate DERUTF8String requestorText = null;\n\tpublic CVRequest(Query query, GeneralNames requestorRef,\n\t\t\tASN1OctetString requestNonce, GeneralName requestorName,\n\t\t\tGeneralName responderName, Extensions requestExtensions,\n\t\t\tAlgorithmIdentifier signatureAlg, ASN1ObjectIdentifier hashAlg,\n\t\t\tDERUTF8String requestorText) {\n\t\tthis.query = query;\n\t\tthis.requestorRef = requestorRef;\n\t\tthis.requestNonce = requestNonce;\n\t\tthis.requestorName = requestorName;\n\t\tthis.responderName = responderName;\n\t\tthis.requestExtensions = requestExtensions;\n\t\tthis.signatureAlg = signatureAlg;\n\t\tthis.hashAlg = hashAlg;\n\t\tthis.requestorText = requestorText;\n\t}\n\tprivate CVRequest(ASN1Sequence seq) {\n\t}\n\tpublic static CVRequest getInstance(ASN1TaggedObject obj, boolean explicit) {\n\t\treturn getInstance(ASN1Sequence.getInstance(obj, explicit));\n\t}\n\tpublic static CVRequest getInstance(Object obj) {\n\t\tif (obj instanceof CVRequest) {\n\t\t\treturn (CVRequest) obj;\n\t\t} else if (obj != null) {\n\t\t\treturn new CVRequest(ASN1Sequence.getInstance(obj));\n\t\t}\n\t\treturn null;\n\t}\n\t@Override\n\tpublic ASN1Primitive toASN1Primitive() {\n\t\tASN1EncodableVector v = new ASN1EncodableVector();\n\t\tv.add(cvRequestVersion);\n\t\tv.add(query);\n\t\tif (requestorRef != null) {\n\t\t\tv.add(new DERTaggedObject(false, 0, requestorRef));\n\t\t}\n\t\tif (requestNonce != null) {\n\t\t\tv.add(new DERTaggedObject(false, 1, requestNonce));\n\t\t}\n\t\tif (requestorName != null) {\n\t\t\tv.add(new DERTaggedObject(false, 2, requestorName));\n\t\t}\n\t\tif (responderName != null) {\n\t\t\tv.add(new DERTaggedObject(false, 3, responderName));\n\t\t}\n\t\tif (requestExtensions != null) {\n\t\t\tv.add(new DERTaggedObject(false, 4, requestExtensions));\n\t\t}\n\t\tif (signatureAlg != null) {\n\t\t\tv.add(new DERTaggedObject(false, 5, signatureAlg));\n\t\t}\n\t\tif (hashAlg != null) {\n\t\t\tv.add(new DERTaggedObject(false, 6, hashAlg));\n\t\t}\n\t\tif (requestorText != null) {\n\t\t\tv.add(new DERTaggedObject(false, 7, requestorText));\n\t\t}\n\t\treturn new DERSequence(v);\n\t}\n"]]}
{"hexsha": "eaf86dd552a96231f8247577e3bcb7ce1ddd7801", "ext": "java", "lang": "Java", "content": "public class PressureSensor extends Subsystem {\n    // Put methods for controlling this subsystem\n    // here. Call these from Commands.\n\n    public PressureSensor() {\n\n    }\n\n    private double pressure;\n    private final double supplyVoltage = 5;\n    private final double requiredToClimb = 45;\n\n    public void findPressure() {\n        // apply a formula for turning voltage to psi value\n        // 250 (voltageOut/supplyVoltage) - 25\n        pressure = 250 * (RobotMap.pressureSensor.getAverageVoltage() / supplyVoltage) - 25;\n    }\n    public double getPressure() {\n        findPressure();\n        return pressure;\n    }\n    public boolean canClimb() {\n        return getPressure() > requiredToClimb;\n    }\n\n    @Override\n    public void initDefaultCommand() {\n        // Set the default command for a subsystem here.\n        // setDefaultCommand(new MySpecialCommand());\n    }\n}", "class_id": 0, "repo": "Arctos6135/frc-2019", "file": "src/main/java/frc/robot/subsystems/PressureSensor.java", "last_update_at": "2019-12-17T02:19:15+00:00", "question_id": "eaf86dd552a96231f8247577e3bcb7ce1ddd7801", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PressureSensor extends Subsystem {\n    // Put methods for controlling this subsystem\n    // here. Call these from Commands.\n    public PressureSensor() {\n    }\n    private double pressure;\n    private final double supplyVoltage = 5;\n    private final double requiredToClimb = 45;\n    public void findPressure() {\n        // apply a formula for turning voltage to psi value\n        // 250 (voltageOut/supplyVoltage) - 25\n        pressure = 250 * (RobotMap.pressureSensor.getAverageVoltage() / supplyVoltage) - 25;\n    }\n    public double getPressure() {\n        findPressure();\n        return pressure;\n    }\n    public boolean canClimb() {\n        return getPressure() > requiredToClimb;\n    }\n    @Override\n    public void initDefaultCommand() {\n        // Set the default command for a subsystem here.\n        // setDefaultCommand(new MySpecialCommand());\n    }\n"]]}
{"hexsha": "61af6386948720266369806342cde60c6f0f893f", "ext": "java", "lang": "Java", "content": "public class MergeSequenceTest\n{\n  @Test\n  public void testSanity() throws Exception\n  {\n    final ArrayList<TestSequence<Integer>> testSeqs = Lists.newArrayList(\n        TestSequence.create(1, 3, 5, 7, 9),\n        TestSequence.create(2, 8),\n        TestSequence.create(4, 6, 8)\n    );\n\n    MergeSequence<Integer> seq = new MergeSequence<>(Ordering.<Integer>natural(), (Sequence) Sequences.simple(testSeqs));\n    SequenceTestHelper.testAll(seq, Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 8, 9));\n\n    for (TestSequence<Integer> sequence : testSeqs) {\n      Assert.assertTrue(sequence.isClosed());\n    }\n  }\n\n  @Test\n  public void testWorksWhenBeginningOutOfOrder() throws Exception\n  {\n    final ArrayList<TestSequence<Integer>> testSeqs = Lists.newArrayList(\n        TestSequence.create(2, 8),\n        TestSequence.create(1, 3, 5, 7, 9),\n        TestSequence.create(4, 6, 8)\n    );\n\n    MergeSequence<Integer> seq = new MergeSequence<>(Ordering.<Integer>natural(), (Sequence) Sequences.simple(testSeqs));\n    SequenceTestHelper.testAll(seq, Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 8, 9));\n\n    for (TestSequence<Integer> sequence : testSeqs) {\n      Assert.assertTrue(sequence.isClosed());\n    }\n  }\n\n  @Test\n  public void testMergeEmpties() throws Exception\n  {\n    final ArrayList<TestSequence<Integer>> testSeqs = Lists.newArrayList(\n        TestSequence.create(1, 3, 5, 7, 9),\n        TestSequence.create(),\n        TestSequence.create(2, 8),\n        TestSequence.create(4, 6, 8)\n    );\n\n    MergeSequence<Integer> seq = new MergeSequence<>(Ordering.<Integer>natural(), (Sequence) Sequences.simple(testSeqs));\n    SequenceTestHelper.testAll(seq, Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 8, 9));\n\n    for (TestSequence<Integer> sequence : testSeqs) {\n      Assert.assertTrue(sequence.isClosed());\n    }\n  }\n\n  @Test\n  public void testMergeEmpties1() throws Exception\n  {\n    final ArrayList<TestSequence<Integer>> testSeqs = Lists.newArrayList(\n        TestSequence.create(),\n        TestSequence.create(1, 3, 5, 7, 9),\n        TestSequence.create(2, 8),\n        TestSequence.create(4, 6, 8)\n    );\n\n    MergeSequence<Integer> seq = new MergeSequence<>(Ordering.<Integer>natural(), (Sequence) Sequences.simple(testSeqs));\n    SequenceTestHelper.testAll(seq, Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 8, 9));\n\n    for (TestSequence<Integer> sequence : testSeqs) {\n      Assert.assertTrue(sequence.isClosed());\n    }\n  }\n\n  @Test\n  public void testMergeEmpties2() throws Exception\n  {\n    final ArrayList<TestSequence<Integer>> testSeqs = Lists.newArrayList(\n        TestSequence.create(1, 3, 5, 7, 9),\n        TestSequence.create(2, 8),\n        TestSequence.create(),\n        TestSequence.create(4, 6, 8),\n        TestSequence.create()\n    );\n\n    MergeSequence<Integer> seq = new MergeSequence<>(Ordering.<Integer>natural(), (Sequence) Sequences.simple(testSeqs));\n    SequenceTestHelper.testAll(seq, Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 8, 9));\n\n    for (TestSequence<Integer> sequence : testSeqs) {\n      Assert.assertTrue(sequence.isClosed());\n    }\n  }\n\n  @Test\n  public void testScrewsUpOnOutOfOrder() throws Exception\n  {\n    final ArrayList<TestSequence<Integer>> testSeqs = Lists.newArrayList(\n        TestSequence.create(1, 3, 5, 4, 7, 9),\n        TestSequence.create(2, 8),\n        TestSequence.create(4, 6)\n    );\n\n    MergeSequence<Integer> seq = new MergeSequence<>(Ordering.<Integer>natural(), (Sequence) Sequences.simple(testSeqs));\n    SequenceTestHelper.testAll(seq, Arrays.asList(1, 2, 3, 4, 5, 4, 6, 7, 8, 9));\n\n    for (TestSequence<Integer> sequence : testSeqs) {\n      Assert.assertTrue(sequence.isClosed());\n    }\n  }\n\n  @Test\n  public void testHierarchicalMerge() throws Exception\n  {\n    final Sequence<Integer> seq1 = new MergeSequence<>(\n        Ordering.natural(), Sequences.simple(\n        Collections.singletonList(TestSequence.create(1))\n    )\n    );\n\n    final Sequence<Integer> finalMerged = new MergeSequence<>(\n        Ordering.natural(),\n        Sequences.simple(\n            Collections.singletonList(seq1)\n        )\n    );\n\n    SequenceTestHelper.testAll(finalMerged, Collections.singletonList(1));\n  }\n\n  @Test\n  public void testMergeOne() throws Exception\n  {\n    final Sequence<Integer> mergeOne = new MergeSequence<>(\n        Ordering.natural(), Sequences.simple(\n        Collections.singletonList(TestSequence.create(1))\n    )\n    );\n\n    SequenceTestHelper.testAll(mergeOne, Collections.singletonList(1));\n  }\n\n}", "class_id": 0, "repo": "liutang123/incubator-druid", "file": "core/src/test/java/org/apache/druid/java/util/common/guava/MergeSequenceTest.java", "last_update_at": "2019-03-07T10:26:11+00:00", "question_id": "61af6386948720266369806342cde60c6f0f893f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MergeSequenceTest\n{\n  @Test\n  public void testSanity() throws Exception\n  {\n    final ArrayList<TestSequence<Integer>> testSeqs = Lists.newArrayList(\n        TestSequence.create(1, 3, 5, 7, 9),\n        TestSequence.create(2, 8),\n        TestSequence.create(4, 6, 8)\n    );\n    MergeSequence<Integer> seq = new MergeSequence<>(Ordering.<Integer>natural(), (Sequence) Sequences.simple(testSeqs));\n    SequenceTestHelper.testAll(seq, Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 8, 9));\n    for (TestSequence<Integer> sequence : testSeqs) {\n      Assert.assertTrue(sequence.isClosed());\n    }\n  }\n  @Test\n  public void testWorksWhenBeginningOutOfOrder() throws Exception\n  {\n    final ArrayList<TestSequence<Integer>> testSeqs = Lists.newArrayList(\n        TestSequence.create(2, 8),\n        TestSequence.create(1, 3, 5, 7, 9),\n        TestSequence.create(4, 6, 8)\n    );\n    MergeSequence<Integer> seq = new MergeSequence<>(Ordering.<Integer>natural(), (Sequence) Sequences.simple(testSeqs));\n    SequenceTestHelper.testAll(seq, Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 8, 9));\n    for (TestSequence<Integer> sequence : testSeqs) {\n      Assert.assertTrue(sequence.isClosed());\n    }\n  }\n  @Test\n  public void testMergeEmpties() throws Exception\n  {\n    final ArrayList<TestSequence<Integer>> testSeqs = Lists.newArrayList(\n        TestSequence.create(1, 3, 5, 7, 9),\n        TestSequence.create(),\n        TestSequence.create(2, 8),\n        TestSequence.create(4, 6, 8)\n    );\n    MergeSequence<Integer> seq = new MergeSequence<>(Ordering.<Integer>natural(), (Sequence) Sequences.simple(testSeqs));\n    SequenceTestHelper.testAll(seq, Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 8, 9));\n    for (TestSequence<Integer> sequence : testSeqs) {\n      Assert.assertTrue(sequence.isClosed());\n    }\n  }\n  @Test\n  public void testMergeEmpties1() throws Exception\n  {\n    final ArrayList<TestSequence<Integer>> testSeqs = Lists.newArrayList(\n        TestSequence.create(),\n        TestSequence.create(1, 3, 5, 7, 9),\n        TestSequence.create(2, 8),\n        TestSequence.create(4, 6, 8)\n    );\n    MergeSequence<Integer> seq = new MergeSequence<>(Ordering.<Integer>natural(), (Sequence) Sequences.simple(testSeqs));\n    SequenceTestHelper.testAll(seq, Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 8, 9));\n    for (TestSequence<Integer> sequence : testSeqs) {\n      Assert.assertTrue(sequence.isClosed());\n    }\n  }\n  @Test\n  public void testMergeEmpties2() throws Exception\n  {\n    final ArrayList<TestSequence<Integer>> testSeqs = Lists.newArrayList(\n        TestSequence.create(1, 3, 5, 7, 9),\n        TestSequence.create(2, 8),\n        TestSequence.create(),\n        TestSequence.create(4, 6, 8),\n        TestSequence.create()\n    );\n    MergeSequence<Integer> seq = new MergeSequence<>(Ordering.<Integer>natural(), (Sequence) Sequences.simple(testSeqs));\n    SequenceTestHelper.testAll(seq, Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 8, 9));\n    for (TestSequence<Integer> sequence : testSeqs) {\n      Assert.assertTrue(sequence.isClosed());\n    }\n  }\n  @Test\n  public void testScrewsUpOnOutOfOrder() throws Exception\n  {\n    final ArrayList<TestSequence<Integer>> testSeqs = Lists.newArrayList(\n        TestSequence.create(1, 3, 5, 4, 7, 9),\n        TestSequence.create(2, 8),\n        TestSequence.create(4, 6)\n    );\n    MergeSequence<Integer> seq = new MergeSequence<>(Ordering.<Integer>natural(), (Sequence) Sequences.simple(testSeqs));\n    SequenceTestHelper.testAll(seq, Arrays.asList(1, 2, 3, 4, 5, 4, 6, 7, 8, 9));\n    for (TestSequence<Integer> sequence : testSeqs) {\n      Assert.assertTrue(sequence.isClosed());\n    }\n  }\n  @Test\n  public void testHierarchicalMerge() throws Exception\n  {\n    final Sequence<Integer> seq1 = new MergeSequence<>(\n        Ordering.natural(), Sequences.simple(\n        Collections.singletonList(TestSequence.create(1))\n    )\n    );\n    final Sequence<Integer> finalMerged = new MergeSequence<>(\n        Ordering.natural(),\n        Sequences.simple(\n            Collections.singletonList(seq1)\n        )\n    );\n    SequenceTestHelper.testAll(finalMerged, Collections.singletonList(1));\n  }\n  @Test\n  public void testMergeOne() throws Exception\n  {\n    final Sequence<Integer> mergeOne = new MergeSequence<>(\n        Ordering.natural(), Sequences.simple(\n        Collections.singletonList(TestSequence.create(1))\n    )\n    );\n    SequenceTestHelper.testAll(mergeOne, Collections.singletonList(1));\n  }\n"]]}
{"hexsha": "ab028a00db13fd3589cc69066fda4680cbf7a2d7", "ext": "java", "lang": "Java", "content": "public class baekjoon_12018 {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] in = br.readLine().split(\" \");\n        int n = Integer.parseInt(in[0]); // \uacfc\ubaa9\uc218\n        int m = Integer.parseInt(in[1]); // \ub9c8\uc77c\ub9ac\uc9c0\n\n        int[] list = new int[n]; // \uacfc\ubaa9\ub2f9 \ud544\uc694 \ub9c8\uc77c\ub9ac\uc9c0\n        for(int i=0; i<n; i++) {\n            in = br.readLine().split(\" \");\n            int P = Integer.parseInt(in[0]); // \uc2e0\uccad\ud55c \uc0ac\ub78c\n            int L = Integer.parseInt(in[1]); // \uc81c\ud55c \uc778\uc6d0\n\n            in = br.readLine().split(\" \");\n            if(P<L) { // \uc5b4\ucc28\ud53c \uc790\ub9ac \ub0a8\uc74c\n                list[i]=1;\n            } else {\n                int[] pList = new int[P];\n                for(int person=0; person<P; person++) {\n                    pList[person] = Integer.parseInt(in[person]);\n                }\n                Arrays.sort(pList);\n                list[i] = pList[P-L]; // L\ubc88\uc9f8 \uc21c\uc704\ub791 \uac19\uac8c\n            }\n        }\n        Arrays.sort(list);\n\n        int solution=0;\n        for(int i=0; i<n; i++) {\n            if(m>=list[i]) {\n                m-=list[i];\n                ++solution;\n            } else break;\n        }\n        System.out.println(solution);\n    }\n}", "class_id": 0, "repo": "DoDaek/Algorithm_CE_CNU", "file": "03/week_3/acmicpc_12018_seungminJeon.java", "last_update_at": "2019-04-01T04:09:37+00:00", "question_id": "ab028a00db13fd3589cc69066fda4680cbf7a2d7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class baekjoon_12018 {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] in = br.readLine().split(\" \");\n        int n = Integer.parseInt(in[0]); // \uacfc\ubaa9\uc218\n        int m = Integer.parseInt(in[1]); // \ub9c8\uc77c\ub9ac\uc9c0\n        int[] list = new int[n]; // \uacfc\ubaa9\ub2f9 \ud544\uc694 \ub9c8\uc77c\ub9ac\uc9c0\n        for(int i=0; i<n; i++) {\n            in = br.readLine().split(\" \");\n            int P = Integer.parseInt(in[0]); // \uc2e0\uccad\ud55c \uc0ac\ub78c\n            int L = Integer.parseInt(in[1]); // \uc81c\ud55c \uc778\uc6d0\n            in = br.readLine().split(\" \");\n            if(P<L) { // \uc5b4\ucc28\ud53c \uc790\ub9ac \ub0a8\uc74c\n                list[i]=1;\n            } else {\n                int[] pList = new int[P];\n                for(int person=0; person<P; person++) {\n                    pList[person] = Integer.parseInt(in[person]);\n                }\n                Arrays.sort(pList);\n                list[i] = pList[P-L]; // L\ubc88\uc9f8 \uc21c\uc704\ub791 \uac19\uac8c\n            }\n        }\n        Arrays.sort(list);\n        int solution=0;\n        for(int i=0; i<n; i++) {\n            if(m>=list[i]) {\n                m-=list[i];\n                ++solution;\n            } else break;\n        }\n        System.out.println(solution);\n    }\n"]]}
{"hexsha": "be0261294ea05f813512d543683ec02bd0b0c489", "ext": "java", "lang": "Java", "content": "public abstract class AbstractScriptCache<K, V> implements ScriptCache<K, V> {\n\n    private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n    protected Map<K, V> cacheMap;\n    protected int cacheSize;\n\n    public AbstractScriptCache(int cacheSize) {\n        this.cacheSize = cacheSize;\n    }\n\n    @Override\n    public void put(K k, V v) {\n        ObjectsUtil.requireNonNull(v);\n        Lock lock = readWriteLock.writeLock();\n        try {\n            lock.lock();\n            cacheMap.put(k, v);\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    @Override\n    public V get(K k) {\n        Lock lock = readWriteLock.readLock();\n        try {\n            lock.lock();\n            return cacheMap.get(k);\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    @Override\n    public boolean evict(K k) {\n        if (cacheMap.containsKey(k)) {\n            Lock lock = readWriteLock.writeLock();\n            try {\n                lock.lock();\n                cacheMap.remove(k);\n                return true;\n            } finally {\n                lock.unlock();\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public void clean() {\n        Lock lock = readWriteLock.writeLock();\n        try {\n            lock.lock();\n            cacheMap.clear();\n        } finally {\n            lock.unlock();\n        }\n    }\n}", "class_id": 0, "repo": "SunMuxin/chaosblade-exec-jvm", "file": "chaosblade-exec-plugin/chaosblade-exec-plugin-jvm/src/main/java/com/alibaba/chaosblade/exec/plugin/jvm/script/base/cache/AbstractScriptCache.java", "last_update_at": "2019-07-11T02:33:07+00:00", "question_id": "be0261294ea05f813512d543683ec02bd0b0c489", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class AbstractScriptCache<K, V> implements ScriptCache<K, V> {\n    private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n    protected Map<K, V> cacheMap;\n    protected int cacheSize;\n    public AbstractScriptCache(int cacheSize) {\n        this.cacheSize = cacheSize;\n    }\n    @Override\n    public void put(K k, V v) {\n        ObjectsUtil.requireNonNull(v);\n        Lock lock = readWriteLock.writeLock();\n        try {\n            lock.lock();\n            cacheMap.put(k, v);\n        } finally {\n            lock.unlock();\n        }\n    }\n    @Override\n    public V get(K k) {\n        Lock lock = readWriteLock.readLock();\n        try {\n            lock.lock();\n            return cacheMap.get(k);\n        } finally {\n            lock.unlock();\n        }\n    }\n    @Override\n    public boolean evict(K k) {\n        if (cacheMap.containsKey(k)) {\n            Lock lock = readWriteLock.writeLock();\n            try {\n                lock.lock();\n                cacheMap.remove(k);\n                return true;\n            } finally {\n                lock.unlock();\n            }\n        }\n        return false;\n    }\n    @Override\n    public void clean() {\n        Lock lock = readWriteLock.writeLock();\n        try {\n            lock.lock();\n            cacheMap.clear();\n        } finally {\n            lock.unlock();\n        }\n    }\n"]]}
{"hexsha": "9dc33dec127558f27ce92ed64fc076de066ff090", "ext": "java", "lang": "Java", "content": "public class MediasDisplayHelper {\n\n    private static final Comparator<MediaModel> mediaModelComparator = \n    \t\t(MediaModel m1, MediaModel m2) -> \n            NaturalOrderComparator.NUMERICAL_ORDER.compare(m1.getTitle(), m2.getTitle());\n\t\n\tpublic static void addMedias(List<MediaModel> mediaModels, TilePane tilePane, int start, int end){\n\t\t/* sort model list */\n\t\tCollections.sort(mediaModels, mediaModelComparator);\n\t\t\n\t\t/* fill the panes */\n\t\tint numberMedia = 0;\n\t\tfor (int i = start; i < end; i++) {\n\t\t\tnumberMedia++;\t\t\t\n\t\t\tif (numberMedia <= Sizes.MEDIA_NUMBER_STAGE) {\n\t\t\t\ttilePane.getChildren().add(new MediaModelView(mediaModels.get(i)).getBox());\n\t\t\t}\t\t\t\n\t\t}\t\t\n\t}\n\t\n\tpublic static Stage createStage(Stage backStage, MediasDisplayController controller,\n\t\t\t                        BorderPane mainPane, String menu, int indiceStage){\n        \n\t\t/* create the Scene */\n\t\tScene scene = new Scene(mainPane);\n        String css = MediasDisplayHelper.class.getResource(PathsProject.CSS_MEDIAS_PATH).toExternalForm(); \n        scene.getStylesheets().add(css);\n\t\t\n\t\t/* create the Stage */\n\t\tStage nextStage = new Stage();\n        StageSettings.setFitScreen(nextStage, false);\n        nextStage.setScene(scene);\n\n\t\t/* set the controller */\n\t\tcontroller.setTitle(menu);\n        controller.setMediasModels(MediasDisplayHelper.listModel(159),indiceStage);\n        controller.setBackStage(backStage);\n        controller.setCurrentStage(nextStage);\n        \n        return nextStage;\n\t\t\n\t}\n\t\n\tpublic static List<MediaModel> listModel(int size){\n\t\tList<MediaModel> models = new ArrayList<>();\n\t\tfor (int i = 0; i< size; i++) {\n\t\t\tMediaModel mediaModel = new MediaModel();\n\t\t\tmediaModel.setTitle(\"Image test \"+(i+1));\n\t\t\tmediaModel.setIconPaths(Arrays.asList(\"/home/vivien/Images/coloriage-tigre-1.gif\"));\n\t\t\tmodels.add(mediaModel);\n\t\t}\n\t\treturn models;\n\t}\n\n}", "class_id": 0, "repo": "lavive/lavive.myMediaCenter", "file": "myMediaCenter.client/src/main/java/lavive/myMediaCenter/client/tools/MediasDisplayHelper.java", "last_update_at": "2019-01-12T11:49:58+00:00", "question_id": "9dc33dec127558f27ce92ed64fc076de066ff090", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MediasDisplayHelper {\n    private static final Comparator<MediaModel> mediaModelComparator = \n    \t\t(MediaModel m1, MediaModel m2) -> \n            NaturalOrderComparator.NUMERICAL_ORDER.compare(m1.getTitle(), m2.getTitle());\n\t\n\tpublic static void addMedias(List<MediaModel> mediaModels, TilePane tilePane, int start, int end){\n\t\t/* sort model list */\n\t\tCollections.sort(mediaModels, mediaModelComparator);\n\t\t\n\t\t/* fill the panes */\n\t\tint numberMedia = 0;\n\t\tfor (int i = start; i < end; i++) {\n\t\t\tnumberMedia++;\t\t\t\n\t\t\tif (numberMedia <= Sizes.MEDIA_NUMBER_STAGE) {\n\t\t\t\ttilePane.getChildren().add(new MediaModelView(mediaModels.get(i)).getBox());\n\t\t\t}\t\t\t\n\t\t}\t\t\n\t}\n\t\n\tpublic static Stage createStage(Stage backStage, MediasDisplayController controller,\n\t\t\t                        BorderPane mainPane, String menu, int indiceStage){\n\t\t/* create the Scene */\n\t\tScene scene = new Scene(mainPane);\n        String css = MediasDisplayHelper.class.getResource(PathsProject.CSS_MEDIAS_PATH).toExternalForm(); \n        scene.getStylesheets().add(css);\n\t\t\n\t\t/* create the Stage */\n\t\tStage nextStage = new Stage();\n        StageSettings.setFitScreen(nextStage, false);\n        nextStage.setScene(scene);\n\t\t/* set the controller */\n\t\tcontroller.setTitle(menu);\n        controller.setMediasModels(MediasDisplayHelper.listModel(159),indiceStage);\n        controller.setBackStage(backStage);\n        controller.setCurrentStage(nextStage);\n        return nextStage;\n\t\t\n\t}\n\t\n\tpublic static List<MediaModel> listModel(int size){\n\t\tList<MediaModel> models = new ArrayList<>();\n\t\tfor (int i = 0; i< size; i++) {\n\t\t\tMediaModel mediaModel = new MediaModel();\n\t\t\tmediaModel.setTitle(\"Image test \"+(i+1));\n\t\t\tmediaModel.setIconPaths(Arrays.asList(\"/home/vivien/Images/coloriage-tigre-1.gif\"));\n\t\t\tmodels.add(mediaModel);\n\t\t}\n\t\treturn models;\n\t}\n"]]}
{"hexsha": "72b8f431b1ecd9d9f89e91bea613ad9bdf2e9431", "ext": "java", "lang": "Java", "content": "@RunWith(Parameterized.class)\npublic class CallTypeParserImplTest {\n    private final CallTypeParserImpl callTypeParser = new CallTypeParserImpl();\n\n    private final CallType callType;\n\n    public CallTypeParserImplTest(CallType callType) {\n        this.callType = callType;\n    }\n\n    @Parameterized.Parameters\n    public static Collection<Object[]> data() {\n        return Stream.of(ServerDeviceClientCallType.values(),\n                ServerDeviceCallType.values(),\n                ServerClientCallType.values(),\n                DeviceServerCallType.values(),\n                DeviceClientServerCallType.values(),\n                ClientServerCallType.values())\n                       .flatMap(Stream::of)\n                       .map(v -> (CallType) v)\n                       .map(callType -> new Object[]{callType})\n                       .collect(Collectors.toList());\n    }\n\n    @Test\n    public void shouldFindProperCallType() throws Exception {\n        // when\n        final Optional<CallType> parseCallTypeOptional = callTypeParser.parse(callType.getValue());\n\n        // then\n        assertThat(parseCallTypeOptional).contains(callType);\n    }\n}", "class_id": 0, "repo": "magx2/jSupla", "file": "protocol/src/test/java/pl/grzeslowski/jsupla/protocol/impl/calltypes/CallTypeParserImplTest.java", "last_update_at": "2019-03-12T09:40:21+00:00", "question_id": "72b8f431b1ecd9d9f89e91bea613ad9bdf2e9431", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(Parameterized.class)\npublic class CallTypeParserImplTest {\n    private final CallTypeParserImpl callTypeParser = new CallTypeParserImpl();\n    private final CallType callType;\n    public CallTypeParserImplTest(CallType callType) {\n        this.callType = callType;\n    }\n    @Parameterized.Parameters\n    public static Collection<Object[]> data() {\n        return Stream.of(ServerDeviceClientCallType.values(),\n                ServerDeviceCallType.values(),\n                ServerClientCallType.values(),\n                DeviceServerCallType.values(),\n                DeviceClientServerCallType.values(),\n                ClientServerCallType.values())\n                       .flatMap(Stream::of)\n                       .map(v -> (CallType) v)\n                       .map(callType -> new Object[]{callType})\n                       .collect(Collectors.toList());\n    }\n    @Test\n    public void shouldFindProperCallType() throws Exception {\n        // when\n        final Optional<CallType> parseCallTypeOptional = callTypeParser.parse(callType.getValue());\n        // then\n        assertThat(parseCallTypeOptional).contains(callType);\n    }\n"]]}
{"hexsha": "965f35d7167e00e38221ad1b42e6106e70a4f179", "ext": "java", "lang": "Java", "content": "public abstract class ElFunction {\r\n\t/**\r\n\t * \u5f53\u524d\u65f6\u95f4\r\n\t * @return\r\n\t */\r\n\tpublic static Date now() {\r\n\t\treturn new Date();\r\n\t}\r\n\r\n\tpublic static boolean contains(Collection<?> container, Object element) {\r\n\t\tif (container == null || element == null) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn container.contains(element);\r\n\t}\r\n\r\n\tpublic static Object invoke(Object obj, String method)\r\n\t\t\tthrows SecurityException, NoSuchMethodException,\r\n\t\t\tIllegalArgumentException, IllegalAccessException,\r\n\t\t\tInvocationTargetException {\r\n\t\tif (obj == null || StringUtils.isBlank(method)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tClass<?> clazz = obj.getClass();\r\n\t\treturn clazz.getMethod(method).invoke(obj);\r\n\t}\r\n\r\n\tpublic static Object invoke(Object obj, String methodName, Object arg0)\r\n\t\t\tthrows SecurityException, NoSuchMethodException,\r\n\t\t\tIllegalArgumentException, IllegalAccessException,\r\n\t\t\tInvocationTargetException {\r\n\t\tif (obj == null || StringUtils.isBlank(methodName)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tClass<?> clazz = obj.getClass();\r\n\t\tMethod method;\r\n\t\tif (arg0 != null) {\r\n\t\t\tmethod = clazz.getMethod(methodName, arg0.getClass());\r\n\t\t} else {\r\n\t\t\tfor (Method m : clazz.getDeclaredMethods()) {\r\n\t\t\t\tif (m.getName().equals(methodName)\r\n\t\t\t\t\t\t&& m.getParameterTypes().length == 1) {\r\n\t\t\t\t\tmethod = m;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new NoSuchMethodException(clazz.getName() + \".\" + methodName\r\n\t\t\t\t\t+ \"(Object arg0)\");\r\n\t\t}\r\n\t\treturn method.invoke(obj, arg0);\r\n\t}\r\n\r\n\tpublic static Object invoke(Object obj, String methodName, Object arg0,\r\n\t\t\tObject arg1) throws SecurityException, NoSuchMethodException,\r\n\t\t\tIllegalArgumentException, IllegalAccessException,\r\n\t\t\tInvocationTargetException {\r\n\t\tif (obj == null || StringUtils.isBlank(methodName)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tClass<?> clazz = obj.getClass();\r\n\t\tMethod method;\r\n\t\tif (arg0 != null && arg1 != null) {\r\n\t\t\tmethod = clazz.getMethod(methodName, arg0.getClass(),\r\n\t\t\t\t\targ1.getClass());\r\n\t\t} else {\r\n\t\t\tfor (Method m : clazz.getDeclaredMethods()) {\r\n\t\t\t\tif (m.getName().equals(methodName)\r\n\t\t\t\t\t\t&& m.getParameterTypes().length == 2) {\r\n\t\t\t\t\tmethod = m;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new NoSuchMethodException(clazz.getName() + \".\" + methodName\r\n\t\t\t\t\t+ \"(Object arg0,Object arg1)\");\r\n\t\t}\r\n\t\treturn method.invoke(obj, arg0, arg1);\r\n\t}\r\n\r\n\tpublic static Object invoke(Object obj, String methodName, Object arg0,\r\n\t\t\tObject arg1, Object arg2) throws SecurityException,\r\n\t\t\tNoSuchMethodException, IllegalArgumentException,\r\n\t\t\tIllegalAccessException, InvocationTargetException {\r\n\t\tif (obj == null || StringUtils.isBlank(methodName)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tClass<?> clazz = obj.getClass();\r\n\t\tMethod method;\r\n\t\tif (arg0 != null && arg1 != null && arg2 != null) {\r\n\t\t\tmethod = clazz.getMethod(methodName, arg0.getClass(),\r\n\t\t\t\t\targ1.getClass(), arg2.getClass());\r\n\t\t} else {\r\n\t\t\tfor (Method m : clazz.getDeclaredMethods()) {\r\n\t\t\t\tif (m.getName().equals(methodName)\r\n\t\t\t\t\t\t&& m.getParameterTypes().length == 3) {\r\n\t\t\t\t\tmethod = m;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new NoSuchMethodException(clazz.getName() + \".\" + methodName\r\n\t\t\t\t\t+ \"(Object arg0,Object arg1,Object arg2)\");\r\n\t\t}\r\n\t\treturn method.invoke(obj, arg0, arg1, arg2);\r\n\t}\r\n\r\n\tpublic static Object invoke(Object obj, String methodName, Object arg0,\r\n\t\t\tObject arg1, Object arg2, Object arg3) throws SecurityException,\r\n\t\t\tNoSuchMethodException, IllegalArgumentException,\r\n\t\t\tIllegalAccessException, InvocationTargetException {\r\n\t\tif (obj == null || StringUtils.isBlank(methodName)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tClass<?> clazz = obj.getClass();\r\n\t\tMethod method;\r\n\t\tif (arg0 != null && arg1 != null && arg2 != null) {\r\n\t\t\tmethod = clazz.getMethod(methodName, arg0.getClass(),\r\n\t\t\t\t\targ1.getClass(), arg2.getClass(), arg3.getClass());\r\n\t\t} else {\r\n\t\t\tfor (Method m : clazz.getDeclaredMethods()) {\r\n\t\t\t\tif (m.getName().equals(methodName)\r\n\t\t\t\t\t\t&& m.getParameterTypes().length == 4) {\r\n\t\t\t\t\tmethod = m;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new NoSuchMethodException(clazz.getName() + \".\" + methodName\r\n\t\t\t\t\t+ \"(Object arg0,Object arg1,Object arg2,Object arg3)\");\r\n\t\t}\r\n\t\treturn method.invoke(obj, arg0, arg1, arg2, arg3);\r\n\t}\r\n}", "class_id": 0, "repo": "xrogzu/jspxcms6", "file": "src/com/jspxcms/common/web/ElFunction.java", "last_update_at": "2019-07-05T06:28:09+00:00", "question_id": "965f35d7167e00e38221ad1b42e6106e70a4f179", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class ElFunction {\r\n\t/**\r\n\t * \u5f53\u524d\u65f6\u95f4\r\n\t * @return\r\n\t */\r\n\tpublic static Date now() {\r\n\t\treturn new Date();\r\n\t}\r\n\r\n\tpublic static boolean contains(Collection<?> container, Object element) {\r\n\t\tif (container == null || element == null) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn container.contains(element);\r\n\t}\r\n\r\n\tpublic static Object invoke(Object obj, String method)\r\n\t\t\tthrows SecurityException, NoSuchMethodException,\r\n\t\t\tIllegalArgumentException, IllegalAccessException,\r\n\t\t\tInvocationTargetException {\r\n\t\tif (obj == null || StringUtils.isBlank(method)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tClass<?> clazz = obj.getClass();\r\n\t\treturn clazz.getMethod(method).invoke(obj);\r\n\t}\r\n\r\n\tpublic static Object invoke(Object obj, String methodName, Object arg0)\r\n\t\t\tthrows SecurityException, NoSuchMethodException,\r\n\t\t\tIllegalArgumentException, IllegalAccessException,\r\n\t\t\tInvocationTargetException {\r\n\t\tif (obj == null || StringUtils.isBlank(methodName)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tClass<?> clazz = obj.getClass();\r\n\t\tMethod method;\r\n\t\tif (arg0 != null) {\r\n\t\t\tmethod = clazz.getMethod(methodName, arg0.getClass());\r\n\t\t} else {\r\n\t\t\tfor (Method m : clazz.getDeclaredMethods()) {\r\n\t\t\t\tif (m.getName().equals(methodName)\r\n\t\t\t\t\t\t&& m.getParameterTypes().length == 1) {\r\n\t\t\t\t\tmethod = m;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new NoSuchMethodException(clazz.getName() + \".\" + methodName\r\n\t\t\t\t\t+ \"(Object arg0)\");\r\n\t\t}\r\n\t\treturn method.invoke(obj, arg0);\r\n\t}\r\n\r\n\tpublic static Object invoke(Object obj, String methodName, Object arg0,\r\n\t\t\tObject arg1) throws SecurityException, NoSuchMethodException,\r\n\t\t\tIllegalArgumentException, IllegalAccessException,\r\n\t\t\tInvocationTargetException {\r\n\t\tif (obj == null || StringUtils.isBlank(methodName)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tClass<?> clazz = obj.getClass();\r\n\t\tMethod method;\r\n\t\tif (arg0 != null && arg1 != null) {\r\n\t\t\tmethod = clazz.getMethod(methodName, arg0.getClass(),\r\n\t\t\t\t\targ1.getClass());\r\n\t\t} else {\r\n\t\t\tfor (Method m : clazz.getDeclaredMethods()) {\r\n\t\t\t\tif (m.getName().equals(methodName)\r\n\t\t\t\t\t\t&& m.getParameterTypes().length == 2) {\r\n\t\t\t\t\tmethod = m;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new NoSuchMethodException(clazz.getName() + \".\" + methodName\r\n\t\t\t\t\t+ \"(Object arg0,Object arg1)\");\r\n\t\t}\r\n\t\treturn method.invoke(obj, arg0, arg1);\r\n\t}\r\n\r\n\tpublic static Object invoke(Object obj, String methodName, Object arg0,\r\n\t\t\tObject arg1, Object arg2) throws SecurityException,\r\n\t\t\tNoSuchMethodException, IllegalArgumentException,\r\n\t\t\tIllegalAccessException, InvocationTargetException {\r\n\t\tif (obj == null || StringUtils.isBlank(methodName)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tClass<?> clazz = obj.getClass();\r\n\t\tMethod method;\r\n\t\tif (arg0 != null && arg1 != null && arg2 != null) {\r\n\t\t\tmethod = clazz.getMethod(methodName, arg0.getClass(),\r\n\t\t\t\t\targ1.getClass(), arg2.getClass());\r\n\t\t} else {\r\n\t\t\tfor (Method m : clazz.getDeclaredMethods()) {\r\n\t\t\t\tif (m.getName().equals(methodName)\r\n\t\t\t\t\t\t&& m.getParameterTypes().length == 3) {\r\n\t\t\t\t\tmethod = m;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new NoSuchMethodException(clazz.getName() + \".\" + methodName\r\n\t\t\t\t\t+ \"(Object arg0,Object arg1,Object arg2)\");\r\n\t\t}\r\n\t\treturn method.invoke(obj, arg0, arg1, arg2);\r\n\t}\r\n\r\n\tpublic static Object invoke(Object obj, String methodName, Object arg0,\r\n\t\t\tObject arg1, Object arg2, Object arg3) throws SecurityException,\r\n\t\t\tNoSuchMethodException, IllegalArgumentException,\r\n\t\t\tIllegalAccessException, InvocationTargetException {\r\n\t\tif (obj == null || StringUtils.isBlank(methodName)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tClass<?> clazz = obj.getClass();\r\n\t\tMethod method;\r\n\t\tif (arg0 != null && arg1 != null && arg2 != null) {\r\n\t\t\tmethod = clazz.getMethod(methodName, arg0.getClass(),\r\n\t\t\t\t\targ1.getClass(), arg2.getClass(), arg3.getClass());\r\n\t\t} else {\r\n\t\t\tfor (Method m : clazz.getDeclaredMethods()) {\r\n\t\t\t\tif (m.getName().equals(methodName)\r\n\t\t\t\t\t\t&& m.getParameterTypes().length == 4) {\r\n\t\t\t\t\tmethod = m;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new NoSuchMethodException(clazz.getName() + \".\" + methodName\r\n\t\t\t\t\t+ \"(Object arg0,Object arg1,Object arg2,Object arg3)\");\r\n\t\t}\r\n\t\treturn method.invoke(obj, arg0, arg1, arg2, arg3);\r\n\t}\r\n"]]}
{"hexsha": "1455b9b83fb36f437472bc43b5047bb280a2d23c", "ext": "java", "lang": "Java", "content": "public class StartKafkaCommand extends AbstractBaseAdminCommand implements Command {\n  private static final Logger LOGGER = LoggerFactory.getLogger(StartKafkaCommand.class);\n\n  @Option(name = \"-port\", required = false, metaVar = \"<int>\", usage = \"Port to start Kafka server on.\")\n  private int _port = KafkaStarterUtils.DEFAULT_KAFKA_PORT;\n\n  @Option(name = \"-help\", required = false, help = true, aliases = {\"-h\", \"--h\", \"--help\"}, usage = \"Print this message.\")\n  private boolean _help = false;\n\n  @Option(name = \"-brokerId\", required = false, metaVar = \"<int>\", usage = \"Kafka broker ID.\")\n  private int _brokerId = KafkaStarterUtils.DEFAULT_BROKER_ID;\n\n  @Option(name = \"-zkAddress\", required = false, metaVar = \"<string>\", usage = \"Address of Zookeeper.\")\n  private String _zkAddress = \"localhost:2181\";\n  private StreamDataServerStartable _kafkaStarter;\n\n  @Override\n  public boolean getHelp() {\n    return _help;\n  }\n\n  @Override\n  public String getName() {\n    return \"StartKafka\";\n  }\n\n  @Override\n  public String toString() {\n    return \"StartKafka -port \" + _port + \" -brokerId \" + _brokerId + \" -zkAddress \" + _zkAddress;\n  }\n\n  @Override\n  public String description() {\n    return \"Start Kafka at the specified port.\";\n  }\n\n  @Override\n  public boolean execute()\n      throws IOException {\n    try {\n      _kafkaStarter = StreamDataProvider.getServerDataStartable(KafkaStarterUtils.KAFKA_SERVER_STARTABLE_CLASS_NAME, KafkaStarterUtils.getDefaultKafkaConfiguration());\n    } catch (Exception e) {\n      throw new RuntimeException(\"Failed to start \" + KafkaStarterUtils.KAFKA_SERVER_STARTABLE_CLASS_NAME, e);\n    }\n    _kafkaStarter.start();\n\n    LOGGER.info(\"Start kafka at localhost:\" + _port + \" in thread \" + Thread.currentThread().getName());\n\n    savePID(System.getProperty(\"java.io.tmpdir\") + File.separator + \".kafka.pid\");\n    return true;\n  }\n}", "class_id": 0, "repo": "bxji/incubator-pinot", "file": "pinot-tools/src/main/java/org/apache/pinot/tools/admin/command/StartKafkaCommand.java", "last_update_at": "2019-10-10T21:41:06+00:00", "question_id": "1455b9b83fb36f437472bc43b5047bb280a2d23c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class StartKafkaCommand extends AbstractBaseAdminCommand implements Command {\n  private static final Logger LOGGER = LoggerFactory.getLogger(StartKafkaCommand.class);\n  @Option(name = \"-port\", required = false, metaVar = \"<int>\", usage = \"Port to start Kafka server on.\")\n  private int _port = KafkaStarterUtils.DEFAULT_KAFKA_PORT;\n  @Option(name = \"-help\", required = false, help = true, aliases = {\"-h\", \"--h\", \"--help\"}, usage = \"Print this message.\")\n  private boolean _help = false;\n  @Option(name = \"-brokerId\", required = false, metaVar = \"<int>\", usage = \"Kafka broker ID.\")\n  private int _brokerId = KafkaStarterUtils.DEFAULT_BROKER_ID;\n  @Option(name = \"-zkAddress\", required = false, metaVar = \"<string>\", usage = \"Address of Zookeeper.\")\n  private String _zkAddress = \"localhost:2181\";\n  private StreamDataServerStartable _kafkaStarter;\n  @Override\n  public boolean getHelp() {\n    return _help;\n  }\n  @Override\n  public String getName() {\n    return \"StartKafka\";\n  }\n  @Override\n  public String toString() {\n    return \"StartKafka -port \" + _port + \" -brokerId \" + _brokerId + \" -zkAddress \" + _zkAddress;\n  }\n  @Override\n  public String description() {\n    return \"Start Kafka at the specified port.\";\n  }\n  @Override\n  public boolean execute()\n      throws IOException {\n    try {\n      _kafkaStarter = StreamDataProvider.getServerDataStartable(KafkaStarterUtils.KAFKA_SERVER_STARTABLE_CLASS_NAME, KafkaStarterUtils.getDefaultKafkaConfiguration());\n    } catch (Exception e) {\n      throw new RuntimeException(\"Failed to start \" + KafkaStarterUtils.KAFKA_SERVER_STARTABLE_CLASS_NAME, e);\n    }\n    _kafkaStarter.start();\n    LOGGER.info(\"Start kafka at localhost:\" + _port + \" in thread \" + Thread.currentThread().getName());\n    savePID(System.getProperty(\"java.io.tmpdir\") + File.separator + \".kafka.pid\");\n    return true;\n  }\n"]]}
{"hexsha": "f72d87085fc29ac63c2ef8523592889a464a5b1d", "ext": "java", "lang": "Java", "content": "public class VMDCollisionTest {\n\n    private static final Image IMAGE_LIST = ImageUtilities.loadImage(\"test/resources/list_32.png\"); // NOI18N\n    private static final Image IMAGE_CANVAS = ImageUtilities.loadImage(\"test/resources/custom_displayable_32.png\"); // NOI18N\n    private static final Image IMAGE_COMMAND = ImageUtilities.loadImage(\"test/resources/command_16.png\"); // NOI18N\n    private static final Image IMAGE_ITEM = ImageUtilities.loadImage(\"test/resources/item_16.png\"); // NOI18N\n    private static final Image GLYPH_PRE_CODE = ImageUtilities.loadImage(\"test/resources/preCodeGlyph.png\"); // NOI18N\n    private static final Image GLYPH_POST_CODE = ImageUtilities.loadImage(\"test/resources/postCodeGlyph.png\"); // NOI18N\n    private static final Image GLYPH_CANCEL = ImageUtilities.loadImage(\"test/resources/cancelGlyph.png\"); // NOI18N\n\n    private static int nodeID = 1;\n    private static int edgeID = 1;\n\n    public static void main (String[] args) {\n        VMDGraphScene scene = new VMDGraphScene ();\n\n        String mobile = VMDTest.createNode (scene, 100, 100, IMAGE_LIST, \"menu\", \"List\", null);\n        VMDTest.createPin (scene, mobile, \"start\", IMAGE_ITEM, \"Start\", \"Element\");\n\n        String game = VMDTest.createNode (scene, 600, 100, IMAGE_CANVAS, \"gameCanvas\", \"MyCanvas\", Arrays.asList (GLYPH_PRE_CODE, GLYPH_CANCEL, GLYPH_POST_CODE));\n        VMDTest.createPin (scene, game, \"ok\", IMAGE_COMMAND, \"okCommand1\", \"Command\");\n\n        VMDTest.createEdge (scene, \"start\", game);\n        VMDTest.createEdge (scene, \"ok\", mobile);\n\n        SceneSupport.show (scene);\n    }\n\n}", "class_id": 0, "repo": "timboudreau/netbeans-contrib", "file": "visual.examples/src/main/java/test/vmd/VMDCollisionTest.java", "last_update_at": "2019-12-07T19:37:03+00:00", "question_id": "f72d87085fc29ac63c2ef8523592889a464a5b1d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class VMDCollisionTest {\n    private static final Image IMAGE_LIST = ImageUtilities.loadImage(\"test/resources/list_32.png\"); // NOI18N\n    private static final Image IMAGE_CANVAS = ImageUtilities.loadImage(\"test/resources/custom_displayable_32.png\"); // NOI18N\n    private static final Image IMAGE_COMMAND = ImageUtilities.loadImage(\"test/resources/command_16.png\"); // NOI18N\n    private static final Image IMAGE_ITEM = ImageUtilities.loadImage(\"test/resources/item_16.png\"); // NOI18N\n    private static final Image GLYPH_PRE_CODE = ImageUtilities.loadImage(\"test/resources/preCodeGlyph.png\"); // NOI18N\n    private static final Image GLYPH_POST_CODE = ImageUtilities.loadImage(\"test/resources/postCodeGlyph.png\"); // NOI18N\n    private static final Image GLYPH_CANCEL = ImageUtilities.loadImage(\"test/resources/cancelGlyph.png\"); // NOI18N\n    private static int nodeID = 1;\n    private static int edgeID = 1;\n    public static void main (String[] args) {\n        VMDGraphScene scene = new VMDGraphScene ();\n        String mobile = VMDTest.createNode (scene, 100, 100, IMAGE_LIST, \"menu\", \"List\", null);\n        VMDTest.createPin (scene, mobile, \"start\", IMAGE_ITEM, \"Start\", \"Element\");\n        String game = VMDTest.createNode (scene, 600, 100, IMAGE_CANVAS, \"gameCanvas\", \"MyCanvas\", Arrays.asList (GLYPH_PRE_CODE, GLYPH_CANCEL, GLYPH_POST_CODE));\n        VMDTest.createPin (scene, game, \"ok\", IMAGE_COMMAND, \"okCommand1\", \"Command\");\n        VMDTest.createEdge (scene, \"start\", game);\n        VMDTest.createEdge (scene, \"ok\", mobile);\n        SceneSupport.show (scene);\n    }\n"]]}
{"hexsha": "3983f0713254782b2320800fb0e18ee5303657ab", "ext": "java", "lang": "Java", "content": "public class CryptoUtils {\n\n\tpublic static byte[] makeECDSASignature(PrivateKey privateKey, String input) {\n\t\tSignature signature;\n\t\tbyte[] outputBytes = new byte[0];\n\t\ttry {\n\t\t\tsignature = Signature.getInstance(\"SHA256withECDSA\", \"BC\");\n\t\t\tsignature.initSign(privateKey);\n\t\t\tbyte[] inputBytes = input.getBytes();\n\t\t\tsignature.update(inputBytes);\n\t\t\tbyte[] signtureBytes = signature.sign();\n\t\t\toutputBytes = signtureBytes;\n\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\treturn outputBytes;\n\t}\n\n\n\tpublic static boolean verifyECDSASignature(PublicKey publicKey, byte[] data, byte[] signatureBytes) {\n\t\tSignature sig;\n\t\ttry {\n\t\t\tsig = Signature.getInstance(\"SHA256withECDSA\", \"BC\");\n\t\t\tsig.initVerify(publicKey);\n\t\t\tsig.update(data);\n\t\t\tif (!sig.verify(signatureBytes))\n\t\t\t{\n\t\t\t\t//System.out.println(\"Fail\");\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\t//System.out.println(\"Good\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} catch (NoSuchAlgorithmException | NoSuchProviderException | InvalidKeyException | SignatureException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn false;\n\n\n\t}\n\n\tpublic static String getStringFromKey(Key key) {\n\t\treturn Base64.getEncoder().encodeToString(key.getEncoded());\n\t}\n\n}", "class_id": 0, "repo": "Hephixor/blockchain", "file": "src/crypto/CryptoUtils.java", "last_update_at": "2019-01-05T14:58:22+00:00", "question_id": "3983f0713254782b2320800fb0e18ee5303657ab", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CryptoUtils {\n\tpublic static byte[] makeECDSASignature(PrivateKey privateKey, String input) {\n\t\tSignature signature;\n\t\tbyte[] outputBytes = new byte[0];\n\t\ttry {\n\t\t\tsignature = Signature.getInstance(\"SHA256withECDSA\", \"BC\");\n\t\t\tsignature.initSign(privateKey);\n\t\t\tbyte[] inputBytes = input.getBytes();\n\t\t\tsignature.update(inputBytes);\n\t\t\tbyte[] signtureBytes = signature.sign();\n\t\t\toutputBytes = signtureBytes;\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\treturn outputBytes;\n\t}\n\tpublic static boolean verifyECDSASignature(PublicKey publicKey, byte[] data, byte[] signatureBytes) {\n\t\tSignature sig;\n\t\ttry {\n\t\t\tsig = Signature.getInstance(\"SHA256withECDSA\", \"BC\");\n\t\t\tsig.initVerify(publicKey);\n\t\t\tsig.update(data);\n\t\t\tif (!sig.verify(signatureBytes))\n\t\t\t{\n\t\t\t\t//System.out.println(\"Fail\");\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\t//System.out.println(\"Good\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} catch (NoSuchAlgorithmException | NoSuchProviderException | InvalidKeyException | SignatureException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static String getStringFromKey(Key key) {\n\t\treturn Base64.getEncoder().encodeToString(key.getEncoded());\n\t}\n"]]}
{"hexsha": "e523a965e47b47658d479973dfd371d024212b45", "ext": "java", "lang": "Java", "content": "public class SelectDSL<TYPE> {\n\n    private final SliceQueryExecutor sliceQueryExecutor;\n    private final Class<TYPE> entityClass;\n    private final EntityMeta meta;\n    private final SliceType sliceType;\n\n    protected SelectDSL(SliceQueryExecutor sliceQueryExecutor, Class<TYPE> entityClass, EntityMeta meta, SliceType sliceType) {\n        this.sliceQueryExecutor = sliceQueryExecutor;\n        this.entityClass = entityClass;\n        this.meta = meta;\n        this.sliceType = sliceType;\n    }\n\n    /**\n     *\n     * Start the Select DSL with provided partition components\n     *\n     * <pre class=\"code\"><code class=\"java\">\n     *\n     *  manager.sliceQuery(ArticleRating.class)\n     *      .forSelect()\n     *      .withPartitionComponents(articleId)\n     *\n     * </code></pre>\n     *\n     * Generated CQL3 query:\n     *\n     * <br/>\n     *  SELECT * FROM article_rating WHERE article_id=...\n     *\n     * @return slice DSL\n     */\n    public SelectFromPartition<TYPE> withPartitionComponents(Object... partitionKeyComponents) {\n        final SelectFromPartition<TYPE> selectFromPartition = new SelectFromPartition<>(sliceQueryExecutor, entityClass, meta, sliceType);\n        selectFromPartition.withPartitionComponentsInternal(partitionKeyComponents);\n        return selectFromPartition;\n    }\n\n    /**\n     *\n     * Start the Select DSL with provided partition components IN\n     *\n     * <pre class=\"code\"><code class=\"java\">\n     *\n     *  manager.sliceQuery(MessageEntity.class)\n     *      .forSelect()\n     *      .withPartitionComponents(10L)\n     *      .andPartitionComponentsIN(2013, 2014)\n     *\n     * </code></pre>\n     *\n     * Generated CQL3 query:\n     *\n     * <br/>\n     *  SELECT * FROM messages WHERE user_id=10 AND year IN (2013,2014)\n     *\n     * @return slice DSL\n     */\n    public SelectWithPartition<TYPE> withPartitionComponentsIN(Object... partitionKeyComponents) {\n        final SelectWithPartition<TYPE> selectWithPartition = new SelectWithPartition<>(sliceQueryExecutor, entityClass, meta, sliceType);\n        selectWithPartition.withPartitionComponentsINInternal(partitionKeyComponents);\n        return selectWithPartition;\n    }\n\n\n}", "class_id": 0, "repo": "thitranthanh/Achilles", "file": "achilles-core/src/main/java/info/archinnov/achilles/query/slice/SelectDSL.java", "last_update_at": "2019-07-22T17:13:42+00:00", "question_id": "e523a965e47b47658d479973dfd371d024212b45", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SelectDSL<TYPE> {\n    private final SliceQueryExecutor sliceQueryExecutor;\n    private final Class<TYPE> entityClass;\n    private final EntityMeta meta;\n    private final SliceType sliceType;\n    protected SelectDSL(SliceQueryExecutor sliceQueryExecutor, Class<TYPE> entityClass, EntityMeta meta, SliceType sliceType) {\n        this.sliceQueryExecutor = sliceQueryExecutor;\n        this.entityClass = entityClass;\n        this.meta = meta;\n        this.sliceType = sliceType;\n    }\n    /**\n     *\n     * Start the Select DSL with provided partition components\n     *\n     * <pre class=\"code\"><code class=\"java\">\n     *\n     *  manager.sliceQuery(ArticleRating.class)\n     *      .forSelect()\n     *      .withPartitionComponents(articleId)\n     *\n     * </code></pre>\n     *\n     * Generated CQL3 query:\n     *\n     * <br/>\n     *  SELECT * FROM article_rating WHERE article_id=...\n     *\n     * @return slice DSL\n     */\n    public SelectFromPartition<TYPE> withPartitionComponents(Object... partitionKeyComponents) {\n        final SelectFromPartition<TYPE> selectFromPartition = new SelectFromPartition<>(sliceQueryExecutor, entityClass, meta, sliceType);\n        selectFromPartition.withPartitionComponentsInternal(partitionKeyComponents);\n        return selectFromPartition;\n    }\n    /**\n     *\n     * Start the Select DSL with provided partition components IN\n     *\n     * <pre class=\"code\"><code class=\"java\">\n     *\n     *  manager.sliceQuery(MessageEntity.class)\n     *      .forSelect()\n     *      .withPartitionComponents(10L)\n     *      .andPartitionComponentsIN(2013, 2014)\n     *\n     * </code></pre>\n     *\n     * Generated CQL3 query:\n     *\n     * <br/>\n     *  SELECT * FROM messages WHERE user_id=10 AND year IN (2013,2014)\n     *\n     * @return slice DSL\n     */\n    public SelectWithPartition<TYPE> withPartitionComponentsIN(Object... partitionKeyComponents) {\n        final SelectWithPartition<TYPE> selectWithPartition = new SelectWithPartition<>(sliceQueryExecutor, entityClass, meta, sliceType);\n        selectWithPartition.withPartitionComponentsINInternal(partitionKeyComponents);\n        return selectWithPartition;\n    }\n"]]}
{"hexsha": "351160f553b8e0247668c6e48733d4f75e0ce310", "ext": "java", "lang": "Java", "content": "public class ApacheHttpClient43EngineWithRetry extends ApacheHttpClient43Engine implements ClientHttpEngine {\n\n    private static final Logger logger = LoggerFactory.getLogger(ApacheHttpClient43EngineWithRetry.class);\n\n    @Override\n    protected HttpClient createDefaultHttpClient() {\n        logger.info(\"Bootstrapping http engine with request retry handler...\");\n        final HttpClientBuilder builder = HttpClientBuilder.create();\n        RequestConfig.Builder requestBuilder = RequestConfig.custom();\n        if(defaultProxy != null) {\n            requestBuilder.setProxy(defaultProxy);\n        }\n        builder.disableContentCompression();\n        builder.setDefaultRequestConfig(requestBuilder.build());\n\n        HttpRequestRetryHandler retryHandler = new StandardHttpRequestRetryHandler();\n        builder.setRetryHandler(retryHandler);\n        return builder.build();\n    }\n}", "class_id": 0, "repo": "goldmann/pnc", "file": "rest-api/src/main/java/org/jboss/pnc/client/ApacheHttpClient43EngineWithRetry.java", "last_update_at": "2019-02-14T12:42:17+00:00", "question_id": "351160f553b8e0247668c6e48733d4f75e0ce310", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ApacheHttpClient43EngineWithRetry extends ApacheHttpClient43Engine implements ClientHttpEngine {\n    private static final Logger logger = LoggerFactory.getLogger(ApacheHttpClient43EngineWithRetry.class);\n    @Override\n    protected HttpClient createDefaultHttpClient() {\n        logger.info(\"Bootstrapping http engine with request retry handler...\");\n        final HttpClientBuilder builder = HttpClientBuilder.create();\n        RequestConfig.Builder requestBuilder = RequestConfig.custom();\n        if(defaultProxy != null) {\n            requestBuilder.setProxy(defaultProxy);\n        }\n        builder.disableContentCompression();\n        builder.setDefaultRequestConfig(requestBuilder.build());\n        HttpRequestRetryHandler retryHandler = new StandardHttpRequestRetryHandler();\n        builder.setRetryHandler(retryHandler);\n        return builder.build();\n    }\n"]]}
{"hexsha": "22c8987d39433b3ad7ee7226f44cc795e6c54e7b", "ext": "java", "lang": "Java", "content": "public class ParseComponentTest extends ICalendarTestAbstract\n{           \n    /** Tests FREQ=YEARLY */\n    @Test\n    public void canParseYearly1()\n    {\n        String vEventString = \"BEGIN:VEVENT\" + System.lineSeparator()\n                              + \"CATEGORIES:group13\" + System.lineSeparator()\n                              + \"CREATED:20151109T082900Z\" + System.lineSeparator()\n                              + \"DESCRIPTION:Yearly1 Description\" + System.lineSeparator()\n                              + \"DTSTAMP:20151109T083000Z\" + System.lineSeparator()\n                              + \"DTSTART:20151109T100000\" + System.lineSeparator()\n                              + \"DURATION:PT1H\" + System.lineSeparator()\n                              + \"LAST-MODIFIED:20151110T183000Z\" + System.lineSeparator()\n                              + \"RRULE:FREQ=YEARLY\" + System.lineSeparator()\n                              + \"SUMMARY:Yearly1 Summary\" + System.lineSeparator()\n                              + \"UID:20151109T082900-0@jfxtras.org\" + System.lineSeparator()\n                              + \"END:VEVENT\";\n        VEvent vEvent = VEvent.parse(vEventString);\n        VEvent expectedVEvent = getYearly1();\n        assertEquals(expectedVEvent, vEvent);\n        assertEquals(vEventString, expectedVEvent.toString());\n    }\n\n    @Test\n    public void canParseDaily3()\n    {\n        String vEventString = \"BEGIN:VEVENT\" + System.lineSeparator()\n                              + \"DTEND:20151109T110000\" + System.lineSeparator()\n                              + \"DTSTAMP:20150110T080000Z\" + System.lineSeparator()\n                              + \"DTSTART:20151109T100000\" + System.lineSeparator()\n                              + \"RRULE:FREQ=DAILY;INTERVAL=3;COUNT=10;BYMONTHDAY=9,10,11,12,13,14\" + System.lineSeparator()\n                              + \"UID:20150110T080000-0@jfxtras.org\" + System.lineSeparator()\n                              + \"END:VEVENT\";\n        VEvent vEvent = VEvent.parse(vEventString);\n        VEvent expectedVEvent = getDaily3();\n        assertEquals(expectedVEvent, vEvent);\n        assertEquals(vEventString, expectedVEvent.toString());\n    }\n    \n    @Test\n    public void canIgnoreBlankLines()\n    {\n        String vEventString = \"BEGIN:VEVENT\" + System.lineSeparator()\n                              + \"DTEND:20151109T110000\" + System.lineSeparator()\n                              + \"DTSTAMP:20150110T080000Z\" + System.lineSeparator()\n                              + System.lineSeparator()\n                              + \"DTSTART:20151109T100000\" + System.lineSeparator()\n                              + \"RRULE:FREQ=DAILY;INTERVAL=3;COUNT=10;BYMONTHDAY=9,10,11,12,13,14\" + System.lineSeparator()\n                              + System.lineSeparator()\n                              + System.lineSeparator()\n                              + \"UID:20150110T080000-0@jfxtras.org\" + System.lineSeparator()\n                              + \"END:VEVENT\";\n        VEvent vEvent = VEvent.parse(vEventString);\n        VEvent expectedVEvent = getDaily3();\n        assertEquals(expectedVEvent, vEvent);\n        String vEventString2 = \"BEGIN:VEVENT\" + System.lineSeparator()\n                + \"DTEND:20151109T110000\" + System.lineSeparator()\n                + \"DTSTAMP:20150110T080000Z\" + System.lineSeparator()\n                + \"DTSTART:20151109T100000\" + System.lineSeparator()\n                + \"RRULE:FREQ=DAILY;INTERVAL=3;COUNT=10;BYMONTHDAY=9,10,11,12,13,14\" + System.lineSeparator()\n                + \"UID:20150110T080000-0@jfxtras.org\" + System.lineSeparator()\n                + \"END:VEVENT\";\n        assertEquals(vEventString2, expectedVEvent.toString());\n    }\n        \n    @Test\n    public void canParseDailyUTC()\n    {\n        String vEventString = \"BEGIN:VEVENT\" + System.lineSeparator()\n                              + \"DTSTART:20151109T100000Z\" + System.lineSeparator()\n                              + \"DTEND:20151109T110000Z\" + System.lineSeparator()\n                              + \"DTSTAMP:20150110T080000Z\" + System.lineSeparator()\n                              + \"CATEGORIES:group03\" + System.lineSeparator()\n                              + \"DESCRIPTION:DailyUTC Description\" + System.lineSeparator()\n                              + \"SUMMARY:DailyUTC Summary\" + System.lineSeparator()\n                              + \"UID:20150110T080000-0@jfxtras.org\" + System.lineSeparator()\n                              + \"RRULE:FREQ=DAILY;INTERVAL=2;UNTIL=20151201T100000Z\" + System.lineSeparator()\n                              + \"END:VEVENT\";\n        VEvent vEvent = VEvent.parse(vEventString);\n        VEvent expectedVEvent = getDailyUTC();\n        assertEquals(expectedVEvent, vEvent);\n        assertEquals(vEventString, expectedVEvent.toString());\n    }\n    \n    /** Tests FREQ=YEARLY */\n    @Test\n    public void canParseDailyWithException1()\n    {\n        String vEventString = \"BEGIN:VEVENT\" + System.lineSeparator()\n                + \"DTSTART:20151109T100000\" + System.lineSeparator()\n                + \"DURATION:PT1H30M\" + System.lineSeparator()\n                + \"DTSTAMP:20150110T080000Z\" + System.lineSeparator()\n                + \"CATEGORIES:group03\" + System.lineSeparator()\n                + \"DESCRIPTION:Daily2 Description\" + System.lineSeparator()\n                + \"SUMMARY:Daily2 Summary\" + System.lineSeparator()\n                + \"UID:20150110T080000-0@jfxtras.org\" + System.lineSeparator()\n                + \"RRULE:FREQ=DAILY;INTERVAL=3;COUNT=6\" + System.lineSeparator()\n                + \"EXDATE:20151112T100000,20151115T100000\" + System.lineSeparator()\n                + \"END:VEVENT\";\n        VEvent vEvent = VEvent.parse(vEventString);\n        VEvent expectedVEvent = getDailyWithException1();\n        assertEquals(expectedVEvent, vEvent);\n        assertEquals(vEventString, expectedVEvent.toString());\n    }\n    \n    @Test\n    public void canParseWholeDay1()\n    {\n        String vEventString = \"BEGIN:VEVENT\" + System.lineSeparator()\n                              + \"DTSTART;VALUE=DATE:20151109\" + System.lineSeparator()\n                              + \"DTEND;VALUE=DATE:20151112\" + System.lineSeparator()\n                              + \"DTSTAMP:20150110T080000Z\" + System.lineSeparator()\n                              + \"UID:20150110T080000-0@jfxtras.org\" + System.lineSeparator()\n                              + \"END:VEVENT\";\n        VEvent vEvent = VEvent.parse(vEventString);\n        VEvent expectedVEvent = getWholeDayDaily1();\n        assertEquals(expectedVEvent, vEvent);\n    }\n    \n    @Test\n    public void canParseGoogleIndividual()\n    {\n        String vEventString = \"BEGIN:VEVENT\" + System.lineSeparator()\n                + \"DTSTART:20160214T123000Z\" + System.lineSeparator()\n                + \"DTEND:20160214T150000Z\" + System.lineSeparator()\n                + \"DTSTAMP:20160214T022532Z\" + System.lineSeparator()\n                + \"UID:vpqej26mlpg3adcncqqs7t7a34@google.com\" + System.lineSeparator()\n                + \"CREATED:20160214T022513Z\" + System.lineSeparator()\n                + \"DESCRIPTION:\" + System.lineSeparator()\n                + \"LAST-MODIFIED:20160214T022513Z\" + System.lineSeparator()\n                + \"LOCATION:\" + System.lineSeparator()\n                + \"SEQUENCE:0\" + System.lineSeparator()\n                + \"STATUS:CONFIRMED\" + System.lineSeparator() // currently not supported\n                + \"SUMMARY:test1\" + System.lineSeparator()\n                + \"TRANSP:OPAQUE\" + System.lineSeparator() // currently not supported\n                + \"END:VEVENT\";\n        VEvent vEvent = VEvent.parse(vEventString);\n        VEvent expectedVEvent = getGoogleIndividual();\n        vEvent.equals(expectedVEvent);\n        assertEquals(expectedVEvent, vEvent);\n        assertEquals(vEventString, vEvent.toString());\n    }\n    \n    @Test\n    public void canParseGoogleRepeat()\n    {\n        String vEventString = \"BEGIN:VEVENT\" + System.lineSeparator()\n                + \"DTSTART;TZID=America/Los_Angeles:20160214T080000\" + System.lineSeparator()\n                + \"DTEND;TZID=America/Los_Angeles:20160214T110000\" + System.lineSeparator()\n                + \"RRULE:FREQ=WEEKLY;BYDAY=SU,TU,FR\" + System.lineSeparator()\n                + \"DTSTAMP:20160214T022532Z\" + System.lineSeparator()\n                + \"UID:im8hmpakeigu3d85j3vq9q8bcc@google.com\" + System.lineSeparator()\n                + \"CREATED:20160214T022525Z\" + System.lineSeparator()\n                + \"DESCRIPTION:\" + System.lineSeparator()\n                + \"LAST-MODIFIED:20160214T022525Z\" + System.lineSeparator()\n                + \"LOCATION:\" + System.lineSeparator()\n                + \"SEQUENCE:0\" + System.lineSeparator()\n                + \"STATUS:CONFIRMED\" + System.lineSeparator() // currently not supported\n                + \"SUMMARY:test2\" + System.lineSeparator()\n                + \"TRANSP:OPAQUE\" + System.lineSeparator() // currently not supported\n                + \"END:VEVENT\";\n        VEvent vEvent = VEvent.parse(vEventString);\n        VEvent expectedVEvent = getGoogleRepeatable();\n        assertEquals(expectedVEvent, vEvent);\n    }\n    \n    @Test\n    public void canParseGoogleRepeatWithExDates()\n    {\n        String content = \"BEGIN:VEVENT\" + System.lineSeparator()\n                + \"DTSTART;TZID=America/Los_Angeles:20160207T123000\" + System.lineSeparator()\n                + \"DTEND;TZID=America/Los_Angeles:20160207T153000\" + System.lineSeparator()\n                + \"RRULE:FREQ=DAILY;UNTIL=20160512T193000Z\" + System.lineSeparator()\n                + \"EXDATE;TZID=America/Los_Angeles:20160210T123000\" + System.lineSeparator()\n                + \"EXDATE;TZID=America/Los_Angeles:20160212T123000\" + System.lineSeparator()\n                + \"EXDATE;TZID=America/Los_Angeles:20160209T123000\" + System.lineSeparator()\n                + \"DTSTAMP:20160214T072231Z\" + System.lineSeparator()\n                + \"UID:86801l7316n97h75cefk1ruc00@google.com\" + System.lineSeparator()\n                + \"CREATED:20160214T022525Z\" + System.lineSeparator()\n                + \"DESCRIPTION:\" + System.lineSeparator()\n                + \"LAST-MODIFIED:20160214T022525Z\" + System.lineSeparator()\n                + \"LOCATION:\" + System.lineSeparator()\n                + \"SEQUENCE:0\" + System.lineSeparator()\n                + \"STATUS:CONFIRMED\" + System.lineSeparator() // currently not supported\n                + \"SUMMARY:test3\" + System.lineSeparator()\n                + \"TRANSP:OPAQUE\" + System.lineSeparator() // currently not supported\n                + \"END:VEVENT\";\n        VEvent vEvent = VEvent.parse(content);\n        VEvent expectedVEvent = getGoogleWithExceptions();\n        assertEquals(expectedVEvent, vEvent);\n    }    \n\n    @Test\n    public void canParseEmptyVevent()\n    {\n    \tString expectedContent = \"BEGIN:VEVENT\" + System.lineSeparator() +\n    \t\t\t\"END:VEVENT\";\n        VComponent vEvent = VEvent.parse(expectedContent);\n        VComponent vExpected = new VEvent();\n        assertEquals(vExpected, vEvent);\n        assertEquals(expectedContent, vEvent.toString());\n    }\n\n    @Test\n    public void canParseWithFoldedLines()\n    {\n        String vEventString = \"BEGIN:VEVENT\" + System.lineSeparator()\n                              + \"DTSTART;VALUE=DATE:20151109\" + System.lineSeparator()\n                              + \"DTEND;VALUE=DATE:20151112\" + System.lineSeparator()\n                              + \"DTSTAMP:20150110T080000Z\" + System.lineSeparator()\n                              + \"UID:20150110T080000-0@jfxtras.org\" + System.lineSeparator()\n                              + \"COMMENT:This is a multiline \" + System.lineSeparator()\n                              + \" comment.\" + System.lineSeparator()\n                              + \"DESCRIPTION:A dog ran \" + System.lineSeparator()\n                              + \"\" + System.lineSeparator() // ignore blank line\n                              + \" far away.\" + System.lineSeparator()\n                              + \"END:VEVENT\";\n        VComponent vEvent = VEvent.parse(vEventString);\n        VEvent expectedVEvent = getWholeDayDaily1()\n                .withComments(\"This is a multiline comment.\")\n                .withDescription(\"A dog ran far away.\");\n        assertEquals(expectedVEvent, vEvent);\n    }\n    \n    @Test\n    public void canParseWithSubComponent()\n    {\n        String vEventString = \"BEGIN:VEVENT\" + System.lineSeparator()\n                              + \"DTSTART;VALUE=DATE:20151109\" + System.lineSeparator()\n                              + \"DTEND;VALUE=DATE:20151112\" + System.lineSeparator()\n                              + \"DTSTAMP:20150110T080000Z\" + System.lineSeparator()\n                              + \"UID:20150110T080000-0@jfxtras.org\" + System.lineSeparator()\n                              + \"COMMENT:This is a multiline \" + System.lineSeparator()\n                              + \" comment.\" + System.lineSeparator()\n                              + \"BEGIN:VALARM\" + System.lineSeparator()\n                              + \"ACTION:DISPLAY\" + System.lineSeparator()\n                              + \"DESCRIPTION:This is a multiline \" + System.lineSeparator()\n                              + \" description.\" + System.lineSeparator()\n                              + \"TRIGGER;RELATED=START:-PT30M\" + System.lineSeparator()\n                              + \"END:VALARM\" + System.lineSeparator()\n                              + \"END:VEVENT\";\n        VComponent vEvent = VEvent.parse(vEventString);\n        VEvent expectedVEvent = getWholeDayDaily1()\n                .withComments(\"This is a multiline comment.\")\n                .withVAlarms(new VAlarm()\n                        .withAction(ActionType.DISPLAY)\n                        .withDescription(\"This is a multiline description.\")\n                        .withTrigger(new Trigger<Duration>(Duration.ofMinutes(-30))\n                                .withAlarmTrigger(new AlarmTriggerRelationship(AlarmTriggerRelationshipType.START))));\n    \n        assertEquals(expectedVEvent, vEvent);\n    }\n}", "class_id": 0, "repo": "haworth606/jfxtras", "file": "jfxtras-icalendarfx/src/test/java/jfxtras/icalendarfx/component/ParseComponentTest.java", "last_update_at": "2019-03-16T21:23:14+00:00", "question_id": "22c8987d39433b3ad7ee7226f44cc795e6c54e7b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ParseComponentTest extends ICalendarTestAbstract\n{           \n    /** Tests FREQ=YEARLY */\n    @Test\n    public void canParseYearly1()\n    {\n        String vEventString = \"BEGIN:VEVENT\" + System.lineSeparator()\n                              + \"CATEGORIES:group13\" + System.lineSeparator()\n                              + \"CREATED:20151109T082900Z\" + System.lineSeparator()\n                              + \"DESCRIPTION:Yearly1 Description\" + System.lineSeparator()\n                              + \"DTSTAMP:20151109T083000Z\" + System.lineSeparator()\n                              + \"DTSTART:20151109T100000\" + System.lineSeparator()\n                              + \"DURATION:PT1H\" + System.lineSeparator()\n                              + \"LAST-MODIFIED:20151110T183000Z\" + System.lineSeparator()\n                              + \"RRULE:FREQ=YEARLY\" + System.lineSeparator()\n                              + \"SUMMARY:Yearly1 Summary\" + System.lineSeparator()\n                              + \"UID:20151109T082900-0@jfxtras.org\" + System.lineSeparator()\n                              + \"END:VEVENT\";\n        VEvent vEvent = VEvent.parse(vEventString);\n        VEvent expectedVEvent = getYearly1();\n        assertEquals(expectedVEvent, vEvent);\n        assertEquals(vEventString, expectedVEvent.toString());\n    }\n    @Test\n    public void canParseDaily3()\n    {\n        String vEventString = \"BEGIN:VEVENT\" + System.lineSeparator()\n                              + \"DTEND:20151109T110000\" + System.lineSeparator()\n                              + \"DTSTAMP:20150110T080000Z\" + System.lineSeparator()\n                              + \"DTSTART:20151109T100000\" + System.lineSeparator()\n                              + \"RRULE:FREQ=DAILY;INTERVAL=3;COUNT=10;BYMONTHDAY=9,10,11,12,13,14\" + System.lineSeparator()\n                              + \"UID:20150110T080000-0@jfxtras.org\" + System.lineSeparator()\n                              + \"END:VEVENT\";\n        VEvent vEvent = VEvent.parse(vEventString);\n        VEvent expectedVEvent = getDaily3();\n        assertEquals(expectedVEvent, vEvent);\n        assertEquals(vEventString, expectedVEvent.toString());\n    }\n    @Test\n    public void canIgnoreBlankLines()\n    {\n        String vEventString = \"BEGIN:VEVENT\" + System.lineSeparator()\n                              + \"DTEND:20151109T110000\" + System.lineSeparator()\n                              + \"DTSTAMP:20150110T080000Z\" + System.lineSeparator()\n                              + System.lineSeparator()\n                              + \"DTSTART:20151109T100000\" + System.lineSeparator()\n                              + \"RRULE:FREQ=DAILY;INTERVAL=3;COUNT=10;BYMONTHDAY=9,10,11,12,13,14\" + System.lineSeparator()\n                              + System.lineSeparator()\n                              + System.lineSeparator()\n                              + \"UID:20150110T080000-0@jfxtras.org\" + System.lineSeparator()\n                              + \"END:VEVENT\";\n        VEvent vEvent = VEvent.parse(vEventString);\n        VEvent expectedVEvent = getDaily3();\n        assertEquals(expectedVEvent, vEvent);\n        String vEventString2 = \"BEGIN:VEVENT\" + System.lineSeparator()\n                + \"DTEND:20151109T110000\" + System.lineSeparator()\n                + \"DTSTAMP:20150110T080000Z\" + System.lineSeparator()\n                + \"DTSTART:20151109T100000\" + System.lineSeparator()\n                + \"RRULE:FREQ=DAILY;INTERVAL=3;COUNT=10;BYMONTHDAY=9,10,11,12,13,14\" + System.lineSeparator()\n                + \"UID:20150110T080000-0@jfxtras.org\" + System.lineSeparator()\n                + \"END:VEVENT\";\n        assertEquals(vEventString2, expectedVEvent.toString());\n    }\n    @Test\n    public void canParseDailyUTC()\n    {\n        String vEventString = \"BEGIN:VEVENT\" + System.lineSeparator()\n                              + \"DTSTART:20151109T100000Z\" + System.lineSeparator()\n                              + \"DTEND:20151109T110000Z\" + System.lineSeparator()\n                              + \"DTSTAMP:20150110T080000Z\" + System.lineSeparator()\n                              + \"CATEGORIES:group03\" + System.lineSeparator()\n                              + \"DESCRIPTION:DailyUTC Description\" + System.lineSeparator()\n                              + \"SUMMARY:DailyUTC Summary\" + System.lineSeparator()\n                              + \"UID:20150110T080000-0@jfxtras.org\" + System.lineSeparator()\n                              + \"RRULE:FREQ=DAILY;INTERVAL=2;UNTIL=20151201T100000Z\" + System.lineSeparator()\n                              + \"END:VEVENT\";\n        VEvent vEvent = VEvent.parse(vEventString);\n        VEvent expectedVEvent = getDailyUTC();\n        assertEquals(expectedVEvent, vEvent);\n        assertEquals(vEventString, expectedVEvent.toString());\n    }\n    /** Tests FREQ=YEARLY */\n    @Test\n    public void canParseDailyWithException1()\n    {\n        String vEventString = \"BEGIN:VEVENT\" + System.lineSeparator()\n                + \"DTSTART:20151109T100000\" + System.lineSeparator()\n                + \"DURATION:PT1H30M\" + System.lineSeparator()\n                + \"DTSTAMP:20150110T080000Z\" + System.lineSeparator()\n                + \"CATEGORIES:group03\" + System.lineSeparator()\n                + \"DESCRIPTION:Daily2 Description\" + System.lineSeparator()\n                + \"SUMMARY:Daily2 Summary\" + System.lineSeparator()\n                + \"UID:20150110T080000-0@jfxtras.org\" + System.lineSeparator()\n                + \"RRULE:FREQ=DAILY;INTERVAL=3;COUNT=6\" + System.lineSeparator()\n                + \"EXDATE:20151112T100000,20151115T100000\" + System.lineSeparator()\n                + \"END:VEVENT\";\n        VEvent vEvent = VEvent.parse(vEventString);\n        VEvent expectedVEvent = getDailyWithException1();\n        assertEquals(expectedVEvent, vEvent);\n        assertEquals(vEventString, expectedVEvent.toString());\n    }\n    @Test\n    public void canParseWholeDay1()\n    {\n        String vEventString = \"BEGIN:VEVENT\" + System.lineSeparator()\n                              + \"DTSTART;VALUE=DATE:20151109\" + System.lineSeparator()\n                              + \"DTEND;VALUE=DATE:20151112\" + System.lineSeparator()\n                              + \"DTSTAMP:20150110T080000Z\" + System.lineSeparator()\n                              + \"UID:20150110T080000-0@jfxtras.org\" + System.lineSeparator()\n                              + \"END:VEVENT\";\n        VEvent vEvent = VEvent.parse(vEventString);\n        VEvent expectedVEvent = getWholeDayDaily1();\n        assertEquals(expectedVEvent, vEvent);\n    }\n    @Test\n    public void canParseGoogleIndividual()\n    {\n        String vEventString = \"BEGIN:VEVENT\" + System.lineSeparator()\n                + \"DTSTART:20160214T123000Z\" + System.lineSeparator()\n                + \"DTEND:20160214T150000Z\" + System.lineSeparator()\n                + \"DTSTAMP:20160214T022532Z\" + System.lineSeparator()\n                + \"UID:vpqej26mlpg3adcncqqs7t7a34@google.com\" + System.lineSeparator()\n                + \"CREATED:20160214T022513Z\" + System.lineSeparator()\n                + \"DESCRIPTION:\" + System.lineSeparator()\n                + \"LAST-MODIFIED:20160214T022513Z\" + System.lineSeparator()\n                + \"LOCATION:\" + System.lineSeparator()\n                + \"SEQUENCE:0\" + System.lineSeparator()\n                + \"STATUS:CONFIRMED\" + System.lineSeparator() // currently not supported\n                + \"SUMMARY:test1\" + System.lineSeparator()\n                + \"TRANSP:OPAQUE\" + System.lineSeparator() // currently not supported\n                + \"END:VEVENT\";\n        VEvent vEvent = VEvent.parse(vEventString);\n        VEvent expectedVEvent = getGoogleIndividual();\n        vEvent.equals(expectedVEvent);\n        assertEquals(expectedVEvent, vEvent);\n        assertEquals(vEventString, vEvent.toString());\n    }\n    @Test\n    public void canParseGoogleRepeat()\n    {\n        String vEventString = \"BEGIN:VEVENT\" + System.lineSeparator()\n                + \"DTSTART;TZID=America/Los_Angeles:20160214T080000\" + System.lineSeparator()\n                + \"DTEND;TZID=America/Los_Angeles:20160214T110000\" + System.lineSeparator()\n                + \"RRULE:FREQ=WEEKLY;BYDAY=SU,TU,FR\" + System.lineSeparator()\n                + \"DTSTAMP:20160214T022532Z\" + System.lineSeparator()\n                + \"UID:im8hmpakeigu3d85j3vq9q8bcc@google.com\" + System.lineSeparator()\n                + \"CREATED:20160214T022525Z\" + System.lineSeparator()\n                + \"DESCRIPTION:\" + System.lineSeparator()\n                + \"LAST-MODIFIED:20160214T022525Z\" + System.lineSeparator()\n                + \"LOCATION:\" + System.lineSeparator()\n                + \"SEQUENCE:0\" + System.lineSeparator()\n                + \"STATUS:CONFIRMED\" + System.lineSeparator() // currently not supported\n                + \"SUMMARY:test2\" + System.lineSeparator()\n                + \"TRANSP:OPAQUE\" + System.lineSeparator() // currently not supported\n                + \"END:VEVENT\";\n        VEvent vEvent = VEvent.parse(vEventString);\n        VEvent expectedVEvent = getGoogleRepeatable();\n        assertEquals(expectedVEvent, vEvent);\n    }\n    @Test\n    public void canParseGoogleRepeatWithExDates()\n    {\n        String content = \"BEGIN:VEVENT\" + System.lineSeparator()\n                + \"DTSTART;TZID=America/Los_Angeles:20160207T123000\" + System.lineSeparator()\n                + \"DTEND;TZID=America/Los_Angeles:20160207T153000\" + System.lineSeparator()\n                + \"RRULE:FREQ=DAILY;UNTIL=20160512T193000Z\" + System.lineSeparator()\n                + \"EXDATE;TZID=America/Los_Angeles:20160210T123000\" + System.lineSeparator()\n                + \"EXDATE;TZID=America/Los_Angeles:20160212T123000\" + System.lineSeparator()\n                + \"EXDATE;TZID=America/Los_Angeles:20160209T123000\" + System.lineSeparator()\n                + \"DTSTAMP:20160214T072231Z\" + System.lineSeparator()\n                + \"UID:86801l7316n97h75cefk1ruc00@google.com\" + System.lineSeparator()\n                + \"CREATED:20160214T022525Z\" + System.lineSeparator()\n                + \"DESCRIPTION:\" + System.lineSeparator()\n                + \"LAST-MODIFIED:20160214T022525Z\" + System.lineSeparator()\n                + \"LOCATION:\" + System.lineSeparator()\n                + \"SEQUENCE:0\" + System.lineSeparator()\n                + \"STATUS:CONFIRMED\" + System.lineSeparator() // currently not supported\n                + \"SUMMARY:test3\" + System.lineSeparator()\n                + \"TRANSP:OPAQUE\" + System.lineSeparator() // currently not supported\n                + \"END:VEVENT\";\n        VEvent vEvent = VEvent.parse(content);\n        VEvent expectedVEvent = getGoogleWithExceptions();\n        assertEquals(expectedVEvent, vEvent);\n    }    \n    @Test\n    public void canParseEmptyVevent()\n    {\n    \tString expectedContent = \"BEGIN:VEVENT\" + System.lineSeparator() +\n    \t\t\t\"END:VEVENT\";\n        VComponent vEvent = VEvent.parse(expectedContent);\n        VComponent vExpected = new VEvent();\n        assertEquals(vExpected, vEvent);\n        assertEquals(expectedContent, vEvent.toString());\n    }\n    @Test\n    public void canParseWithFoldedLines()\n    {\n        String vEventString = \"BEGIN:VEVENT\" + System.lineSeparator()\n                              + \"DTSTART;VALUE=DATE:20151109\" + System.lineSeparator()\n                              + \"DTEND;VALUE=DATE:20151112\" + System.lineSeparator()\n                              + \"DTSTAMP:20150110T080000Z\" + System.lineSeparator()\n                              + \"UID:20150110T080000-0@jfxtras.org\" + System.lineSeparator()\n                              + \"COMMENT:This is a multiline \" + System.lineSeparator()\n                              + \" comment.\" + System.lineSeparator()\n                              + \"DESCRIPTION:A dog ran \" + System.lineSeparator()\n                              + \"\" + System.lineSeparator() // ignore blank line\n                              + \" far away.\" + System.lineSeparator()\n                              + \"END:VEVENT\";\n        VComponent vEvent = VEvent.parse(vEventString);\n        VEvent expectedVEvent = getWholeDayDaily1()\n                .withComments(\"This is a multiline comment.\")\n                .withDescription(\"A dog ran far away.\");\n        assertEquals(expectedVEvent, vEvent);\n    }\n    @Test\n    public void canParseWithSubComponent()\n    {\n        String vEventString = \"BEGIN:VEVENT\" + System.lineSeparator()\n                              + \"DTSTART;VALUE=DATE:20151109\" + System.lineSeparator()\n                              + \"DTEND;VALUE=DATE:20151112\" + System.lineSeparator()\n                              + \"DTSTAMP:20150110T080000Z\" + System.lineSeparator()\n                              + \"UID:20150110T080000-0@jfxtras.org\" + System.lineSeparator()\n                              + \"COMMENT:This is a multiline \" + System.lineSeparator()\n                              + \" comment.\" + System.lineSeparator()\n                              + \"BEGIN:VALARM\" + System.lineSeparator()\n                              + \"ACTION:DISPLAY\" + System.lineSeparator()\n                              + \"DESCRIPTION:This is a multiline \" + System.lineSeparator()\n                              + \" description.\" + System.lineSeparator()\n                              + \"TRIGGER;RELATED=START:-PT30M\" + System.lineSeparator()\n                              + \"END:VALARM\" + System.lineSeparator()\n                              + \"END:VEVENT\";\n        VComponent vEvent = VEvent.parse(vEventString);\n        VEvent expectedVEvent = getWholeDayDaily1()\n                .withComments(\"This is a multiline comment.\")\n                .withVAlarms(new VAlarm()\n                        .withAction(ActionType.DISPLAY)\n                        .withDescription(\"This is a multiline description.\")\n                        .withTrigger(new Trigger<Duration>(Duration.ofMinutes(-30))\n                                .withAlarmTrigger(new AlarmTriggerRelationship(AlarmTriggerRelationshipType.START))));\n        assertEquals(expectedVEvent, vEvent);\n    }\n"]]}
{"hexsha": "cd08f04da2392b2f07f4b2f9178cf5466713bc00", "ext": "java", "lang": "Java", "content": "public class FileManager {\r\n    \r\n    /**\r\n     * Internal reference to a tabbed panel\r\n     */\r\n    private JTabbedPane tabs;\r\n    \r\n    /*\r\n    * Internal reference to the font size\r\n    */\r\n    private float fontSize = (new JLabel()).getFont().getSize();\r\n    \r\n    /**\r\n     * Internal class to represent tab data\r\n     */\r\n    private class Tab {\r\n        String name;\r\n        String filepath;\r\n        JScrollPane panel;\r\n        CodeEditor editor;\r\n        boolean edited = false;\r\n        \r\n        public void setChanged(boolean changed, JTabbedPane parent){\r\n            boolean updated = changed != edited;\r\n            this.edited = changed;\r\n            this.panel.setName(this.name + (this.edited ? \"*\" : \"\"));\r\n            if(updated){\r\n                int idx = parent.indexOfComponent(this.panel);\r\n                if(idx >= 0){\r\n                    parent.setTitleAt(idx, this.panel.getName());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * List of tab data\r\n     */\r\n    private LinkedList<Tab> openTabs = new LinkedList<Tab>();\r\n    \r\n    /**\r\n     * Create a file manager\r\n     */\r\n    public FileManager(){\r\n        tabs = new JTabbedPane();\r\n        tabs.setAutoscrolls(false);\r\n    }\r\n    \r\n    /**\r\n     * Create an empty file\r\n     */\r\n    public void empty(){\r\n        open(null);\r\n    }\r\n    \r\n    public void setFontSize(float f){\r\n        this.fontSize = f;\r\n        for(Tab tab : openTabs){\r\n            tab.editor.setFont(tab.editor.getFont().deriveFont(this.fontSize));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Open a file in the editor\r\n     * @param file \r\n     */\r\n    public void open(String file){\r\n        try{\r\n            Tab t = new Tab();\r\n            t.name = null;\r\n            \r\n            try{\r\n                t.name = new File(file).getName();\r\n            }catch(Exception e){\r\n                JOptionPane.showMessageDialog(null, e.getMessage(), \"Error\", JOptionPane.ERROR_MESSAGE);\r\n            }\r\n            \r\n            t.filepath = file;\r\n            \r\n            CodeEditor editor = new CodeEditor();\r\n            editor.setFont(editor.getFont().deriveFont(fontSize));\r\n            editor.setBackground(new Color(253, 247, 225));\r\n            //First word of line colour\r\n            editor.addStyle(\"(?:^|\\\\n)\\\\s*.*?(?=(?:$|\\\\s))\", new Color(99,125,160));\r\n            //Keyword colour\r\n            editor.addStyle(\"\\\\b(?:begin|end|measure)\\\\b\", new Color(168, 23, 141));\r\n            //Label colour\r\n            editor.addStyle(\"\\\\..+\", new Color(236, 173, 135));\r\n            //String colour\r\n            editor.addStyle(\"\\\\\\\"[^\\\\r\\\\n]*?\\\\\\\"\", new Color(236, 173, 135));\r\n            //Comment colour\r\n            editor.addStyle(\"\\\\/\\\\/.*?(?=(?:\\\\n|$))\", new Color(111, 159, 147));\r\n            \r\n            JScrollPane editor_scroll = new JScrollPane(editor);\r\n            editor_scroll.getVerticalScrollBar().setUnitIncrement(16);\r\n            editor_scroll.setAutoscrolls(false);\r\n            \r\n            t.editor = editor;\r\n            t.panel = editor_scroll;\r\n            t.panel.setName(t.name);\r\n            \r\n            try{\r\n                String content = String.join(\"\\n\",Files.readAllLines(Paths.get(file)));\r\n                t.editor.setText(content);\r\n            }catch(Exception e){\r\n                JOptionPane.showMessageDialog(null, e.getMessage(), \"Error\", JOptionPane.ERROR_MESSAGE);\r\n            }\r\n            \r\n            editor.addChangeListener((str) -> {\r\n                t.setChanged(true, tabs);\r\n            });\r\n            \r\n            tabs.add(t.panel);\r\n            tabs.repaint();\r\n            \r\n            AutoComplete auto = new AutoComplete(editor);\r\n            auto.setCharactersUntilSuggestions(2);\r\n            auto.addWord(\"measure\");\r\n            auto.addWord(\"qreg\");\r\n            auto.addWord(\"creg\");\r\n            auto.addWord(\"import\");\r\n            auto.addWord(\"begin\");\r\n            auto.addWord(\"end\");\r\n            \r\n            auto.addWord(\"ccnot\");\r\n            auto.addWord(\"toffoli\");\r\n            auto.addWord(\"cnot\");\r\n            auto.addWord(\"cx\");\r\n            auto.addWord(\"cy\");\r\n            auto.addWord(\"cz\");\r\n            \r\n            openTabs.add(t);\r\n        }catch(Exception e){\r\n            JOptionPane.showMessageDialog(null, e.getMessage(), \"Error\", JOptionPane.ERROR_MESSAGE);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Save the current file\r\n     */\r\n    public void save(){\r\n        try{\r\n            int i = tabs.getSelectedIndex();\r\n            if(i < 0)\r\n                return;\r\n            Tab openTab = openTabs.get(i);\r\n            if(openTab.name == null){\r\n                //Create a file chooser\r\n                final JFileChooser fc = new JFileChooser();\r\n                //In response to a button click:\r\n                int returnVal = fc.showSaveDialog(null);\r\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\r\n                    File file = fc.getSelectedFile();\r\n                    try(PrintWriter pw = new PrintWriter(file.getAbsolutePath())){\r\n                        pw.print(openTab.editor.getText());\r\n                    }\r\n                    openTab.name = file.getName();\r\n                    openTab.filepath = file.getAbsolutePath();\r\n                    //JOptionPane.showMessageDialog(null, \"File: \" + openTab.name, \"Saved\", JOptionPane.INFORMATION_MESSAGE);\r\n                    openTab.setChanged(false, tabs);\r\n                }\r\n            }else{\r\n                try(PrintWriter pw = new PrintWriter(openTab.filepath)){\r\n                    pw.print(openTab.editor.getText());\r\n                }\r\n                //JOptionPane.showMessageDialog(null, \"File: \" + openTab.name, \"Saved\", JOptionPane.INFORMATION_MESSAGE);\r\n                openTab.setChanged(false, tabs);\r\n            }\r\n        }catch(Exception e){\r\n            JOptionPane.showMessageDialog(null, e.getMessage(), \"Error\", JOptionPane.ERROR_MESSAGE);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Close the current file\r\n     */\r\n    public void close(){\r\n        int i = tabs.getSelectedIndex();\r\n        if(i < 0)\r\n            return;\r\n        Tab openTab = openTabs.get(i);\r\n        tabs.remove(openTab.panel);\r\n        openTabs.remove(openTab);\r\n        tabs.repaint();\r\n    }\r\n    \r\n    /**\r\n     * Get the current file\r\n     * @return \r\n     */\r\n    public File getActive(){\r\n        int i = tabs.getSelectedIndex();\r\n        if(i < 0)\r\n            return null;\r\n        Tab openTab = openTabs.get(i);\r\n        return new File(openTab.filepath);\r\n    }\r\n    \r\n    /**\r\n     * Get the internal reference to the tabbed panel\r\n     * @return \r\n     */\r\n    public JTabbedPane getPanel(){\r\n        return tabs;\r\n    }\r\n    \r\n}", "class_id": 0, "repo": "qkmaxware/Qlib", "file": "src/ide/src/qlib/ide/FileManager.java", "last_update_at": "2019-03-29T22:39:00+00:00", "question_id": "cd08f04da2392b2f07f4b2f9178cf5466713bc00", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FileManager {\r\n    \r\n    /**\r\n     * Internal reference to a tabbed panel\r\n     */\r\n    private JTabbedPane tabs;\r\n    \r\n    /*\r\n    * Internal reference to the font size\r\n    */\r\n    private float fontSize = (new JLabel()).getFont().getSize();\r\n    \r\n    /**\r\n     * Internal class to represent tab data\r\n     */\r\n    private class Tab {\r\n        String name;\r\n        String filepath;\r\n        JScrollPane panel;\r\n        CodeEditor editor;\r\n        boolean edited = false;\r\n        \r\n        public void setChanged(boolean changed, JTabbedPane parent){\r\n            boolean updated = changed != edited;\r\n            this.edited = changed;\r\n            this.panel.setName(this.name + (this.edited ? \"*\" : \"\"));\r\n            if(updated){\r\n                int idx = parent.indexOfComponent(this.panel);\r\n                if(idx >= 0){\r\n                    parent.setTitleAt(idx, this.panel.getName());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * List of tab data\r\n     */\r\n    private LinkedList<Tab> openTabs = new LinkedList<Tab>();\r\n    \r\n    /**\r\n     * Create a file manager\r\n     */\r\n    public FileManager(){\r\n        tabs = new JTabbedPane();\r\n        tabs.setAutoscrolls(false);\r\n    }\r\n    \r\n    /**\r\n     * Create an empty file\r\n     */\r\n    public void empty(){\r\n        open(null);\r\n    }\r\n    \r\n    public void setFontSize(float f){\r\n        this.fontSize = f;\r\n        for(Tab tab : openTabs){\r\n            tab.editor.setFont(tab.editor.getFont().deriveFont(this.fontSize));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Open a file in the editor\r\n     * @param file \r\n     */\r\n    public void open(String file){\r\n        try{\r\n            Tab t = new Tab();\r\n            t.name = null;\r\n            \r\n            try{\r\n                t.name = new File(file).getName();\r\n            }catch(Exception e){\r\n                JOptionPane.showMessageDialog(null, e.getMessage(), \"Error\", JOptionPane.ERROR_MESSAGE);\r\n            }\r\n            \r\n            t.filepath = file;\r\n            \r\n            CodeEditor editor = new CodeEditor();\r\n            editor.setFont(editor.getFont().deriveFont(fontSize));\r\n            editor.setBackground(new Color(253, 247, 225));\r\n            //First word of line colour\r\n            editor.addStyle(\"(?:^|\\\\n)\\\\s*.*?(?=(?:$|\\\\s))\", new Color(99,125,160));\r\n            //Keyword colour\r\n            editor.addStyle(\"\\\\b(?:begin|end|measure)\\\\b\", new Color(168, 23, 141));\r\n            //Label colour\r\n            editor.addStyle(\"\\\\..+\", new Color(236, 173, 135));\r\n            //String colour\r\n            editor.addStyle(\"\\\\\\\"[^\\\\r\\\\n]*?\\\\\\\"\", new Color(236, 173, 135));\r\n            //Comment colour\r\n            editor.addStyle(\"\\\\/\\\\/.*?(?=(?:\\\\n|$))\", new Color(111, 159, 147));\r\n            \r\n            JScrollPane editor_scroll = new JScrollPane(editor);\r\n            editor_scroll.getVerticalScrollBar().setUnitIncrement(16);\r\n            editor_scroll.setAutoscrolls(false);\r\n            \r\n            t.editor = editor;\r\n            t.panel = editor_scroll;\r\n            t.panel.setName(t.name);\r\n            \r\n            try{\r\n                String content = String.join(\"\\n\",Files.readAllLines(Paths.get(file)));\r\n                t.editor.setText(content);\r\n            }catch(Exception e){\r\n                JOptionPane.showMessageDialog(null, e.getMessage(), \"Error\", JOptionPane.ERROR_MESSAGE);\r\n            }\r\n            \r\n            editor.addChangeListener((str) -> {\r\n                t.setChanged(true, tabs);\r\n            });\r\n            \r\n            tabs.add(t.panel);\r\n            tabs.repaint();\r\n            \r\n            AutoComplete auto = new AutoComplete(editor);\r\n            auto.setCharactersUntilSuggestions(2);\r\n            auto.addWord(\"measure\");\r\n            auto.addWord(\"qreg\");\r\n            auto.addWord(\"creg\");\r\n            auto.addWord(\"import\");\r\n            auto.addWord(\"begin\");\r\n            auto.addWord(\"end\");\r\n            \r\n            auto.addWord(\"ccnot\");\r\n            auto.addWord(\"toffoli\");\r\n            auto.addWord(\"cnot\");\r\n            auto.addWord(\"cx\");\r\n            auto.addWord(\"cy\");\r\n            auto.addWord(\"cz\");\r\n            \r\n            openTabs.add(t);\r\n        }catch(Exception e){\r\n            JOptionPane.showMessageDialog(null, e.getMessage(), \"Error\", JOptionPane.ERROR_MESSAGE);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Save the current file\r\n     */\r\n    public void save(){\r\n        try{\r\n            int i = tabs.getSelectedIndex();\r\n            if(i < 0)\r\n                return;\r\n            Tab openTab = openTabs.get(i);\r\n            if(openTab.name == null){\r\n                //Create a file chooser\r\n                final JFileChooser fc = new JFileChooser();\r\n                //In response to a button click:\r\n                int returnVal = fc.showSaveDialog(null);\r\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\r\n                    File file = fc.getSelectedFile();\r\n                    try(PrintWriter pw = new PrintWriter(file.getAbsolutePath())){\r\n                        pw.print(openTab.editor.getText());\r\n                    }\r\n                    openTab.name = file.getName();\r\n                    openTab.filepath = file.getAbsolutePath();\r\n                    //JOptionPane.showMessageDialog(null, \"File: \" + openTab.name, \"Saved\", JOptionPane.INFORMATION_MESSAGE);\r\n                    openTab.setChanged(false, tabs);\r\n                }\r\n            }else{\r\n                try(PrintWriter pw = new PrintWriter(openTab.filepath)){\r\n                    pw.print(openTab.editor.getText());\r\n                }\r\n                //JOptionPane.showMessageDialog(null, \"File: \" + openTab.name, \"Saved\", JOptionPane.INFORMATION_MESSAGE);\r\n                openTab.setChanged(false, tabs);\r\n            }\r\n        }catch(Exception e){\r\n            JOptionPane.showMessageDialog(null, e.getMessage(), \"Error\", JOptionPane.ERROR_MESSAGE);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Close the current file\r\n     */\r\n    public void close(){\r\n        int i = tabs.getSelectedIndex();\r\n        if(i < 0)\r\n            return;\r\n        Tab openTab = openTabs.get(i);\r\n        tabs.remove(openTab.panel);\r\n        openTabs.remove(openTab);\r\n        tabs.repaint();\r\n    }\r\n    \r\n    /**\r\n     * Get the current file\r\n     * @return \r\n     */\r\n    public File getActive(){\r\n        int i = tabs.getSelectedIndex();\r\n        if(i < 0)\r\n            return null;\r\n        Tab openTab = openTabs.get(i);\r\n        return new File(openTab.filepath);\r\n    }\r\n    \r\n    /**\r\n     * Get the internal reference to the tabbed panel\r\n     * @return \r\n     */\r\n    public JTabbedPane getPanel(){\r\n        return tabs;\r\n    }\r\n    \r\n"]]}
{"hexsha": "2a73ddc1c5aa403106ef2a42483e3664a26f5754", "ext": "java", "lang": "Java", "content": "@ParentPackage(\"default\")\n@Namespace(\"/collection/request\")\n@Component\n@Scope(\"prototype\")\npublic class CollectionRequestAccessAction extends AbstractRequestAccessController<ResourceCollection>\n        implements Preparable, PersistableLoadingAction<ResourceCollection> {\n\n    private Set<EmailType> emailTypes = new HashSet<>(EmailType.valuesWithoutConfidentialFiles());\n\n    private static final String SUCCESS_UNAUTH = \"success-unauth\";\n    private static final long serialVersionUID = -6110216327414755768L;\n    private EmailType type = EmailType.CONTACT;\n\n    @Override\n    public void prepare() {\n        getLogger().trace(\"id: {}, {}\", getId(), getPersistableClass());\n        try {\n            prepareAndLoad(this, RequestType.VIEW);\n        } catch (Throwable t) {\n            getLogger().error(\"{}\", t, t);\n        }\n        if (PersistableUtils.isNullOrTransient(getPersistable())) {\n            return;\n        }\n\n    }\n\n    @Action(value = \"{id}\", results = { @Result(name = SUCCESS, location = \"request-access.ftl\"),\n            @Result(name = SUCCESS_UNAUTH, location = \"request-access-unauthenticated.ftl\"),\n            @Result(name = ERROR, type = TdarActionSupport.FREEMARKERHTTP, location = \"/WEB-INF/content/errors/error.ftl\", params = {\n                    \"status\", \"500\" }),\n            @Result(name = INPUT, type = TdarActionSupport.FREEMARKERHTTP, location = \"/WEB-INF/content/errors/error.ftl\", params = {\n                    \"status\", \"500\" }) })\n    @HttpsOnly\n    @SkipValidation\n    @Override\n    public String execute() throws TdarActionException {\n        // if we're logged out, go to request-access-unathenticated.ftl\n        if (PersistableUtils.isNullOrTransient(getAuthenticatedUser())) {\n            return SUCCESS_UNAUTH;\n        }\n\n        return SUCCESS;\n    }\n\n    @Override\n    public boolean authorize() throws TdarActionException {\n        return true;\n    }\n\n    @Override\n    public InternalTdarRights getAdminRights() {\n        return InternalTdarRights.VIEW_ANYTHING;\n    }\n\n    @Override\n    public String getTypeNamespace() {\n        return \"collection\";\n    }\n\n    public Set<EmailType> getEmailTypes() {\n        return emailTypes;\n    }\n\n    public void setEmailTypes(Set<EmailType> emailTypes) {\n        this.emailTypes = emailTypes;\n    }\n\n    public ResourceCollection getCollection() {\n        return getPersistable();\n    }\n\n    public Class<ResourceCollection> getPersistableClass() {\n        return ResourceCollection.class;\n    }\n}", "class_id": 0, "repo": "kant/tdar", "file": "web/src/main/java/org/tdar/struts/action/collection/request/CollectionRequestAccessAction.java", "last_update_at": "2019-07-12T23:56:48+00:00", "question_id": "2a73ddc1c5aa403106ef2a42483e3664a26f5754", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ParentPackage(\"default\")\n@Namespace(\"/collection/request\")\n@Component\n@Scope(\"prototype\")\npublic class CollectionRequestAccessAction extends AbstractRequestAccessController<ResourceCollection>\n        implements Preparable, PersistableLoadingAction<ResourceCollection> {\n    private Set<EmailType> emailTypes = new HashSet<>(EmailType.valuesWithoutConfidentialFiles());\n    private static final String SUCCESS_UNAUTH = \"success-unauth\";\n    private static final long serialVersionUID = -6110216327414755768L;\n    private EmailType type = EmailType.CONTACT;\n    @Override\n    public void prepare() {\n        getLogger().trace(\"id: {}, {}\", getId(), getPersistableClass());\n        try {\n            prepareAndLoad(this, RequestType.VIEW);\n        } catch (Throwable t) {\n            getLogger().error(\"{}\", t, t);\n        }\n        if (PersistableUtils.isNullOrTransient(getPersistable())) {\n            return;\n        }\n    }\n    @Action(value = \"{id}\", results = { @Result(name = SUCCESS, location = \"request-access.ftl\"),\n            @Result(name = SUCCESS_UNAUTH, location = \"request-access-unauthenticated.ftl\"),\n            @Result(name = ERROR, type = TdarActionSupport.FREEMARKERHTTP, location = \"/WEB-INF/content/errors/error.ftl\", params = {\n                    \"status\", \"500\" }),\n            @Result(name = INPUT, type = TdarActionSupport.FREEMARKERHTTP, location = \"/WEB-INF/content/errors/error.ftl\", params = {\n                    \"status\", \"500\" }) })\n    @HttpsOnly\n    @SkipValidation\n    @Override\n    public String execute() throws TdarActionException {\n        // if we're logged out, go to request-access-unathenticated.ftl\n        if (PersistableUtils.isNullOrTransient(getAuthenticatedUser())) {\n            return SUCCESS_UNAUTH;\n        }\n        return SUCCESS;\n    }\n    @Override\n    public boolean authorize() throws TdarActionException {\n        return true;\n    }\n    @Override\n    public InternalTdarRights getAdminRights() {\n        return InternalTdarRights.VIEW_ANYTHING;\n    }\n    @Override\n    public String getTypeNamespace() {\n        return \"collection\";\n    }\n    public Set<EmailType> getEmailTypes() {\n        return emailTypes;\n    }\n    public void setEmailTypes(Set<EmailType> emailTypes) {\n        this.emailTypes = emailTypes;\n    }\n    public ResourceCollection getCollection() {\n        return getPersistable();\n    }\n    public Class<ResourceCollection> getPersistableClass() {\n        return ResourceCollection.class;\n    }\n"]]}
{"hexsha": "bbe64a90704d3e4dfa184cec1289a20e37e60ff0", "ext": "java", "lang": "Java", "content": "public class ListAllCommands {\n\n\tpublic static void run() {\n\t\tImageJ ij = new ImageJ();\n\t\tList<CommandInfo> commands = ij.command().getCommands();\n\t\tfor(CommandInfo info : commands) {\n\t\t\tSystem.out.println(info.getClassName());\n\t\t}\n\t}\n\n\tpublic static void main(String...args) { run(); }\n}", "class_id": 0, "repo": "juglab/fiji-howto", "file": "src/main/java/sc/fiji/howto/extensions/ListAllCommands.java", "last_update_at": "2019-07-04T13:12:17+00:00", "question_id": "bbe64a90704d3e4dfa184cec1289a20e37e60ff0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ListAllCommands {\n\tpublic static void run() {\n\t\tImageJ ij = new ImageJ();\n\t\tList<CommandInfo> commands = ij.command().getCommands();\n\t\tfor(CommandInfo info : commands) {\n\t\t\tSystem.out.println(info.getClassName());\n\t\t}\n\t}\n\tpublic static void main(String...args) { run(); }\n"]]}
{"hexsha": "b59cbe299a80281192c5dc7496aaa332d63488a7", "ext": "java", "lang": "Java", "content": "public class BorrowTracking {\n\tprivate LinkedList theBorrowed; //declare new linked list\n\tprivate Tree myLibrary; //deliver the Tree instance\n\t/**\n\t * This is the constructor of the BorrowTacking system\n\t * @param myLibrary need to use the Tree class to read the detailed information\n\t */\n\tpublic BorrowTracking(Tree myLibrary) {\n\t\ttheBorrowed = new LinkedList(myLibrary); //make new linked list\n\t\tthis.myLibrary = myLibrary;\n\t}\n\t/**\n\t * This method is to show whether anything be borrowed\n\t */\n\tpublic void anyBeBorrowed() {\n\t\tif (theBorrowed.isEmpty() == true) { //if nothing borrowed\n\t\t\tSystem.out.println(\"Nothing got borrowed\");\n\t\t} else { //something borrowed\n\t\t\tSystem.out.println(\"Something got borrowed\");\n\t\t}\n\t}\n\t/**\n\t * This method prints how many things are borrowed\n\t */\n\tpublic void howManyBeBorrowed() {\n\t\tSystem.out.println(\"Number of total borrowed is \"+theBorrowed.size()+\".\");\n\t}\n\t/**\n\t * This method is to set the publication to be returned\n\t * @param uniqueCode\n\t */\n\tpublic void returned(String uniqueCode) {\n\t\ttheBorrowed.deleteByCode(uniqueCode); //remove from Borrowing system\n\t\tmyLibrary.returnByCode(uniqueCode); //set publication to be not borrowed\n\t}\n\t\n\t/**\n\t * This method is to set the publication to be borrowed.\n\t * @param name who borrowed this, need to be a string.\n\t * @param uniqueCode what is the code, ISBN or ASIN of the publication, \n\t */\n\tpublic void borrow(String name, String uniqueCode) {\n\t\ttheBorrowed.insert(name, uniqueCode); //add the info to borrow tracking system\n\t\tmyLibrary.borrowByCode(uniqueCode); //set publication to be borrowed\n\t}\n\t/**\n\t * This method is to sort the borrow tracking system information by the alphabetical order of name\n\t */\n\tpublic void sort() {\n\t\ttheBorrowed.sortByName();\n\t}\n\t/**\n\t * This is to display the borrowed list information.\n\t */\n\tpublic void displayBorrowedList() {\n\t\ttheBorrowed.displayList();\n\t}\n}", "class_id": 0, "repo": "xxingDMACC/CIS152-Publication-Database-Management-System", "file": "src/personalLibraryManagement/BorrowTracking.java", "last_update_at": "2019-02-17T17:43:09+00:00", "question_id": "b59cbe299a80281192c5dc7496aaa332d63488a7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BorrowTracking {\n\tprivate LinkedList theBorrowed; //declare new linked list\n\tprivate Tree myLibrary; //deliver the Tree instance\n\t/**\n\t * This is the constructor of the BorrowTacking system\n\t * @param myLibrary need to use the Tree class to read the detailed information\n\t */\n\tpublic BorrowTracking(Tree myLibrary) {\n\t\ttheBorrowed = new LinkedList(myLibrary); //make new linked list\n\t\tthis.myLibrary = myLibrary;\n\t}\n\t/**\n\t * This method is to show whether anything be borrowed\n\t */\n\tpublic void anyBeBorrowed() {\n\t\tif (theBorrowed.isEmpty() == true) { //if nothing borrowed\n\t\t\tSystem.out.println(\"Nothing got borrowed\");\n\t\t} else { //something borrowed\n\t\t\tSystem.out.println(\"Something got borrowed\");\n\t\t}\n\t}\n\t/**\n\t * This method prints how many things are borrowed\n\t */\n\tpublic void howManyBeBorrowed() {\n\t\tSystem.out.println(\"Number of total borrowed is \"+theBorrowed.size()+\".\");\n\t}\n\t/**\n\t * This method is to set the publication to be returned\n\t * @param uniqueCode\n\t */\n\tpublic void returned(String uniqueCode) {\n\t\ttheBorrowed.deleteByCode(uniqueCode); //remove from Borrowing system\n\t\tmyLibrary.returnByCode(uniqueCode); //set publication to be not borrowed\n\t}\n\t\n\t/**\n\t * This method is to set the publication to be borrowed.\n\t * @param name who borrowed this, need to be a string.\n\t * @param uniqueCode what is the code, ISBN or ASIN of the publication, \n\t */\n\tpublic void borrow(String name, String uniqueCode) {\n\t\ttheBorrowed.insert(name, uniqueCode); //add the info to borrow tracking system\n\t\tmyLibrary.borrowByCode(uniqueCode); //set publication to be borrowed\n\t}\n\t/**\n\t * This method is to sort the borrow tracking system information by the alphabetical order of name\n\t */\n\tpublic void sort() {\n\t\ttheBorrowed.sortByName();\n\t}\n\t/**\n\t * This is to display the borrowed list information.\n\t */\n\tpublic void displayBorrowedList() {\n\t\ttheBorrowed.displayList();\n\t}\n"]]}
{"hexsha": "143228d04d41b9fd94f764e27fafdfb01c5035ef", "ext": "java", "lang": "Java", "content": "public final class ItemRegistry {\n\n\tprivate static final Map<Item, ItemProfile> registry = new IdentityHashMap<Item, ItemProfile>();\n\n\tstatic {\n\t\tfor (final Item o : GameData.getItemRegistry().typeSafeIterable())\n\t\t\tcreateProfile(o);\n\t}\n\n\tprivate static ItemProfile createProfile(final Item item) {\n\t\tfinal ItemProfile profile;\n\t\tif (item.getHasSubtypes())\n\t\t\tprofile = new MultiItemProfile(item);\n\t\telse if (item.isDamageable())\n\t\t\tprofile = new DamagableItemProfile(item);\n\t\telse\n\t\t\tprofile = new SingleItemProfile(item);\n\t\tregistry.put(item, profile);\n\t\treturn profile;\n\t}\n\t\n\tprivate static ItemProfile getProfile(final ItemStack stack) {\n\t\tfinal Item item = stack.getItem();\n\t\tItemProfile profile = registry.get(item);\n\t\tif (profile == null) {\n\t\t\tModLog.warn(\"Item registration is missing: \" + ItemStackHelper.resolveInternalName(stack));\n\t\t\tif(GameData.getItemRegistry().getId(item) == -1) {\n\t\t\t\tModLog.warn(\"Item is not registered with Forge!\");\n\t\t\t} else {\n\t\t\t\tModLog.warn(\"Looks like a late registration\");\n\t\t\t}\n\t\t\tprofile = createProfile(stack.getItem());\n\t\t}\n\t\treturn profile;\n\t}\n\n\tpublic static ItemData get(final ItemStack stack) {\n\t\treturn getProfile(stack).getItemData(stack);\n\t}\n\n\tpublic static void set(final ItemData data) {\n\t\tgetProfile(data.stack).addItemData(data);\n\t}\n\n\tpublic static RecipeData getRecipe(final ItemStack stack) {\n\t\treturn getProfile(stack).getRecipe(stack);\n\t}\n\n\tpublic static void setRecipe(final ItemStack stack, final RecipeData recipe) {\n\t\tgetProfile(stack).addRecipe(stack, recipe);\n\t}\n\n\tpublic static void removeRecipe(final ItemStack stack) {\n\t\tgetProfile(stack).removeRecipe(stack);\n\t}\n\n\tpublic static ExtractionData getExtractionData(final ItemStack stack) {\n\t\treturn getProfile(stack).getExtractionData(stack);\n\t}\n\n\tpublic static void setExtractionData(final ItemStack stack, final ExtractionData data) {\n\t\tgetProfile(stack).addExtractionData(stack, data);\n\t}\n\n\tpublic static void removeExtractionData(final ItemStack stack) {\n\t\tgetProfile(stack).removeExtractionData(stack);\n\t}\n\n\tpublic static void setBlockedFromScrapping(final ItemStack stack, final boolean flag) {\n\t\tfinal ItemData data = get(stack);\n\t\tdata.isBlockedFromScrapping = flag;\n\t\tset(data);\n\t}\n\n\tpublic static void setBlockedFromExtraction(final ItemStack stack, final boolean flag) {\n\t\tfinal ItemData data = get(stack);\n\t\tdata.isBlockedFromExtraction = flag;\n\t\tset(data);\n\t}\n\n\tpublic static void setScrapValue(final ItemStack stack, final ScrapValue value) {\n\t\tfinal ItemData data = get(stack);\n\t\tdata.value = value;\n\t\tset(data);\n\t}\n\n\tpublic static void setCompostIngredientValue(final ItemStack stack, final CompostIngredient value) {\n\t\tfinal ItemData data = get(stack);\n\t\tdata.compostValue = value;\n\t\tset(data);\n\t}\n\n\tpublic static boolean canBeScrapped(final ItemStack stack) {\n\t\treturn !getProfile(stack).getItemData(stack).isBlockedFromScrapping;\n\t}\n\n\tpublic static boolean canBeExtracted(final ItemStack stack) {\n\t\treturn !getProfile(stack).getItemData(stack).isBlockedFromExtraction;\n\t}\n\n\tpublic static boolean isRecipeIgnored(final ItemStack stack) {\n\t\tfinal ItemData data = get(stack);\n\t\treturn data.ignoreRecipe || data.isBlockedFromScrapping;\n\t}\n\n\tpublic static void setRecipeIgnored(final ItemStack stack, final boolean flag) {\n\t\tfinal ItemData data = get(stack);\n\t\tdata.ignoreRecipe = flag;\n\t\tset(data);\n\t}\n\n\tpublic static void setRecipeIgnored(final Item item, final boolean flag) {\n\t\tsetRecipeIgnored(OreDictionaryHelper.asGeneric(item), flag);\n\t}\n\n\tpublic static void setRecipeIgnored(final Block block, final boolean flag) {\n\t\tsetRecipeIgnored(Item.getItemFromBlock(block), flag);\n\t}\n\n\tpublic static boolean isScrubbedFromOutput(final ItemStack stack) {\n\t\treturn getProfile(stack).getItemData(stack).scrubFromOutput;\n\t}\n\n\tpublic static void setScrubbedFromOutput(final ItemStack stack, final boolean flag) {\n\t\tfinal ItemData data = get(stack);\n\t\tdata.scrubFromOutput = flag;\n\t\tset(data);\n\t}\n\t\n\tpublic static boolean isBlockedFromVacuum(final ItemStack stack) {\n\t\tfinal ItemData data = get(stack);\n\t\treturn data.isBlockedFromVacuum;\n\t}\n\t\n\tpublic static void setBlockedFromVacuum(final ItemStack stack, final boolean flag) {\n\t\tfinal ItemData data = get(stack);\n\t\tdata.isBlockedFromVacuum = flag;\n\t\tset(data);\n\t}\n\t\n\tpublic static void ignoreMetaFilter(final ItemStack stack) {\n\t\tgetProfile(stack).ignoreMetaFilter();\n\t}\n\n\tpublic static List<ItemData> getItemDataList() {\n\t\tfinal List<ItemData> data = new ArrayList<ItemData>();\n\t\tfor (final ItemProfile profile : registry.values())\n\t\t\tprofile.collectItemData(data);\n\t\treturn data;\n\t}\n\t\n\tpublic static final int DIAG_ITEMDATA = 0;\n\tpublic static final int DIAG_RECIPES = 1;\n\tpublic static final int DIAG_EXTRACT = 2;\n\n\tpublic static void writeDiagnostic(final Writer writer, final int what) throws Exception {\n\n\t\tswitch (what) {\n\t\tcase ItemRegistry.DIAG_ITEMDATA:\n\t\t\twriter.write(\"Item Registry:\\n\");\n\t\t\tbreak;\n\t\tcase ItemRegistry.DIAG_RECIPES:\n\t\t\twriter.write(\"Recycling Recipes:\\n\");\n\t\t\tbreak;\n\t\tcase ItemRegistry.DIAG_EXTRACT:\n\t\t\twriter.write(\"Extraction Recipes:\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\twriter.write(\"=================================================================\\n\");\n\t\tfor (final ItemProfile profile : registry.values())\n\t\t\tprofile.writeDiagnostic(writer, what);\n\t\twriter.write(\"=================================================================\\n\\n\\n\");\n\t}\n\n}", "class_id": 0, "repo": "OreCruncher/ThermalRecycling", "file": "src/main/java/org/blockartistry/mod/ThermalRecycling/data/registry/ItemRegistry.java", "last_update_at": "2019-10-06T12:02:55+00:00", "question_id": "143228d04d41b9fd94f764e27fafdfb01c5035ef", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class ItemRegistry {\n\tprivate static final Map<Item, ItemProfile> registry = new IdentityHashMap<Item, ItemProfile>();\n\tstatic {\n\t\tfor (final Item o : GameData.getItemRegistry().typeSafeIterable())\n\t\t\tcreateProfile(o);\n\t}\n\tprivate static ItemProfile createProfile(final Item item) {\n\t\tfinal ItemProfile profile;\n\t\tif (item.getHasSubtypes())\n\t\t\tprofile = new MultiItemProfile(item);\n\t\telse if (item.isDamageable())\n\t\t\tprofile = new DamagableItemProfile(item);\n\t\telse\n\t\t\tprofile = new SingleItemProfile(item);\n\t\tregistry.put(item, profile);\n\t\treturn profile;\n\t}\n\t\n\tprivate static ItemProfile getProfile(final ItemStack stack) {\n\t\tfinal Item item = stack.getItem();\n\t\tItemProfile profile = registry.get(item);\n\t\tif (profile == null) {\n\t\t\tModLog.warn(\"Item registration is missing: \" + ItemStackHelper.resolveInternalName(stack));\n\t\t\tif(GameData.getItemRegistry().getId(item) == -1) {\n\t\t\t\tModLog.warn(\"Item is not registered with Forge!\");\n\t\t\t} else {\n\t\t\t\tModLog.warn(\"Looks like a late registration\");\n\t\t\t}\n\t\t\tprofile = createProfile(stack.getItem());\n\t\t}\n\t\treturn profile;\n\t}\n\tpublic static ItemData get(final ItemStack stack) {\n\t\treturn getProfile(stack).getItemData(stack);\n\t}\n\tpublic static void set(final ItemData data) {\n\t\tgetProfile(data.stack).addItemData(data);\n\t}\n\tpublic static RecipeData getRecipe(final ItemStack stack) {\n\t\treturn getProfile(stack).getRecipe(stack);\n\t}\n\tpublic static void setRecipe(final ItemStack stack, final RecipeData recipe) {\n\t\tgetProfile(stack).addRecipe(stack, recipe);\n\t}\n\tpublic static void removeRecipe(final ItemStack stack) {\n\t\tgetProfile(stack).removeRecipe(stack);\n\t}\n\tpublic static ExtractionData getExtractionData(final ItemStack stack) {\n\t\treturn getProfile(stack).getExtractionData(stack);\n\t}\n\tpublic static void setExtractionData(final ItemStack stack, final ExtractionData data) {\n\t\tgetProfile(stack).addExtractionData(stack, data);\n\t}\n\tpublic static void removeExtractionData(final ItemStack stack) {\n\t\tgetProfile(stack).removeExtractionData(stack);\n\t}\n\tpublic static void setBlockedFromScrapping(final ItemStack stack, final boolean flag) {\n\t\tfinal ItemData data = get(stack);\n\t\tdata.isBlockedFromScrapping = flag;\n\t\tset(data);\n\t}\n\tpublic static void setBlockedFromExtraction(final ItemStack stack, final boolean flag) {\n\t\tfinal ItemData data = get(stack);\n\t\tdata.isBlockedFromExtraction = flag;\n\t\tset(data);\n\t}\n\tpublic static void setScrapValue(final ItemStack stack, final ScrapValue value) {\n\t\tfinal ItemData data = get(stack);\n\t\tdata.value = value;\n\t\tset(data);\n\t}\n\tpublic static void setCompostIngredientValue(final ItemStack stack, final CompostIngredient value) {\n\t\tfinal ItemData data = get(stack);\n\t\tdata.compostValue = value;\n\t\tset(data);\n\t}\n\tpublic static boolean canBeScrapped(final ItemStack stack) {\n\t\treturn !getProfile(stack).getItemData(stack).isBlockedFromScrapping;\n\t}\n\tpublic static boolean canBeExtracted(final ItemStack stack) {\n\t\treturn !getProfile(stack).getItemData(stack).isBlockedFromExtraction;\n\t}\n\tpublic static boolean isRecipeIgnored(final ItemStack stack) {\n\t\tfinal ItemData data = get(stack);\n\t\treturn data.ignoreRecipe || data.isBlockedFromScrapping;\n\t}\n\tpublic static void setRecipeIgnored(final ItemStack stack, final boolean flag) {\n\t\tfinal ItemData data = get(stack);\n\t\tdata.ignoreRecipe = flag;\n\t\tset(data);\n\t}\n\tpublic static void setRecipeIgnored(final Item item, final boolean flag) {\n\t\tsetRecipeIgnored(OreDictionaryHelper.asGeneric(item), flag);\n\t}\n\tpublic static void setRecipeIgnored(final Block block, final boolean flag) {\n\t\tsetRecipeIgnored(Item.getItemFromBlock(block), flag);\n\t}\n\tpublic static boolean isScrubbedFromOutput(final ItemStack stack) {\n\t\treturn getProfile(stack).getItemData(stack).scrubFromOutput;\n\t}\n\tpublic static void setScrubbedFromOutput(final ItemStack stack, final boolean flag) {\n\t\tfinal ItemData data = get(stack);\n\t\tdata.scrubFromOutput = flag;\n\t\tset(data);\n\t}\n\t\n\tpublic static boolean isBlockedFromVacuum(final ItemStack stack) {\n\t\tfinal ItemData data = get(stack);\n\t\treturn data.isBlockedFromVacuum;\n\t}\n\t\n\tpublic static void setBlockedFromVacuum(final ItemStack stack, final boolean flag) {\n\t\tfinal ItemData data = get(stack);\n\t\tdata.isBlockedFromVacuum = flag;\n\t\tset(data);\n\t}\n\t\n\tpublic static void ignoreMetaFilter(final ItemStack stack) {\n\t\tgetProfile(stack).ignoreMetaFilter();\n\t}\n\tpublic static List<ItemData> getItemDataList() {\n\t\tfinal List<ItemData> data = new ArrayList<ItemData>();\n\t\tfor (final ItemProfile profile : registry.values())\n\t\t\tprofile.collectItemData(data);\n\t\treturn data;\n\t}\n\t\n\tpublic static final int DIAG_ITEMDATA = 0;\n\tpublic static final int DIAG_RECIPES = 1;\n\tpublic static final int DIAG_EXTRACT = 2;\n\tpublic static void writeDiagnostic(final Writer writer, final int what) throws Exception {\n\t\tswitch (what) {\n\t\tcase ItemRegistry.DIAG_ITEMDATA:\n\t\t\twriter.write(\"Item Registry:\\n\");\n\t\t\tbreak;\n\t\tcase ItemRegistry.DIAG_RECIPES:\n\t\t\twriter.write(\"Recycling Recipes:\\n\");\n\t\t\tbreak;\n\t\tcase ItemRegistry.DIAG_EXTRACT:\n\t\t\twriter.write(\"Extraction Recipes:\\n\");\n\t\t\tbreak;\n\t\t}\n\t\twriter.write(\"=================================================================\\n\");\n\t\tfor (final ItemProfile profile : registry.values())\n\t\t\tprofile.writeDiagnostic(writer, what);\n\t\twriter.write(\"=================================================================\\n\\n\\n\");\n\t}\n"]]}
{"hexsha": "f55fbabaef19b27f7d4aabb8e4e1c4c45a9ad8f8", "ext": "java", "lang": "Java", "content": "public class BMI160_Example\n{\n    public static void main(String[] args) throws InterruptedException\n    {\n// ! [Interesting]\n        System.out.println(\"Initializing...\");\n\n        // Instantiate a BMI160 instance using default i2c bus and address\n        BMI160 sensor = new BMI160();\n\n        while (true)\n            {\n                // update our values from the sensor\n                sensor.update();\n\n                AbstractList<Float> dataA = sensor.getAcceleration();\n\n                System.out.println(\"Accelerometer: \"\n                                   + \"AX: \"\n                                   + dataA.get(0)\n                                   + \" AY: \"\n                                   + dataA.get(1)\n                                   + \" AZ: \"\n                                   + dataA.get(2));\n\n                AbstractList<Float> dataG = sensor.getGyroscope();\n\n                System.out.println(\"Gryoscope:     \"\n                                   + \"GX: \"\n                                   + dataG.get(0)\n                                   + \" GY: \"\n                                   + dataG.get(1)\n                                   + \" GZ: \"\n                                   + dataG.get(2));\n\n                AbstractList<Float> dataM = sensor.getMagnetometer();\n\n                System.out.println(\"Magnetometer:  \"\n                                   + \"MX: \"\n                                   + dataM.get(0)\n                                   + \" MY: \"\n                                   + dataM.get(1)\n                                   + \" MZ: \"\n                                   + dataM.get(2));\n\n                System.out.println();\n                Thread.sleep(500);\n            }\n\n// ! [Interesting]\n    }\n}", "class_id": 0, "repo": "moredu/upm", "file": "examples/java/BMI160_Example.java", "last_update_at": "2019-11-08T14:04:33+00:00", "question_id": "f55fbabaef19b27f7d4aabb8e4e1c4c45a9ad8f8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BMI160_Example\n{\n    public static void main(String[] args) throws InterruptedException\n    {\n// ! [Interesting]\n        System.out.println(\"Initializing...\");\n        // Instantiate a BMI160 instance using default i2c bus and address\n        BMI160 sensor = new BMI160();\n        while (true)\n            {\n                // update our values from the sensor\n                sensor.update();\n                AbstractList<Float> dataA = sensor.getAcceleration();\n                System.out.println(\"Accelerometer: \"\n                                   + \"AX: \"\n                                   + dataA.get(0)\n                                   + \" AY: \"\n                                   + dataA.get(1)\n                                   + \" AZ: \"\n                                   + dataA.get(2));\n                AbstractList<Float> dataG = sensor.getGyroscope();\n                System.out.println(\"Gryoscope:     \"\n                                   + \"GX: \"\n                                   + dataG.get(0)\n                                   + \" GY: \"\n                                   + dataG.get(1)\n                                   + \" GZ: \"\n                                   + dataG.get(2));\n                AbstractList<Float> dataM = sensor.getMagnetometer();\n                System.out.println(\"Magnetometer:  \"\n                                   + \"MX: \"\n                                   + dataM.get(0)\n                                   + \" MY: \"\n                                   + dataM.get(1)\n                                   + \" MZ: \"\n                                   + dataM.get(2));\n                System.out.println();\n                Thread.sleep(500);\n            }\n// ! [Interesting]\n    }\n"]]}
{"hexsha": "883fefa627eeb5eee0b3eb44b4e89c5b858bd01e", "ext": "java", "lang": "Java", "content": "public class CollectionMergeBackupOperation extends CollectionOperation implements BackupOperation {\n\n    private Collection<CollectionItem> backupItems;\n\n    public CollectionMergeBackupOperation() {\n    }\n\n    public CollectionMergeBackupOperation(String name, Collection<CollectionItem> backupItems) {\n        super(name);\n        this.backupItems = backupItems;\n    }\n\n    @Override\n    public void run() throws Exception {\n        CollectionContainer container = getOrCreateContainer();\n        if (backupItems.isEmpty()) {\n            RemoteService service = getService();\n            service.destroyDistributedObject(name);\n        } else {\n            Map<Long, CollectionItem> backupMap = container.getMap();\n            backupMap.clear();\n            for (CollectionItem backupItem : backupItems) {\n                backupMap.put(backupItem.getItemId(), backupItem);\n            }\n        }\n    }\n\n    @Override\n    public int getId() {\n        return CollectionDataSerializerHook.COLLECTION_MERGE_BACKUP;\n    }\n\n    @Override\n    protected void writeInternal(ObjectDataOutput out) throws IOException {\n        super.writeInternal(out);\n        out.writeInt(backupItems.size());\n        for (CollectionItem backupItem : backupItems) {\n            out.writeObject(backupItem);\n        }\n    }\n\n    @Override\n    protected void readInternal(ObjectDataInput in) throws IOException {\n        super.readInternal(in);\n        int size = in.readInt();\n        backupItems = new ArrayList<CollectionItem>(size);\n        for (int i = 0; i < size; i++) {\n            CollectionItem backupItem = in.readObject();\n            backupItems.add(backupItem);\n        }\n    }\n}", "class_id": 0, "repo": "df-service-e2e-test/x_khu2_9th_stress_test_5", "file": "hazelcast/src/main/java/com/hazelcast/collection/impl/collection/operations/CollectionMergeBackupOperation.java", "last_update_at": "2019-05-20T01:50:41+00:00", "question_id": "883fefa627eeb5eee0b3eb44b4e89c5b858bd01e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CollectionMergeBackupOperation extends CollectionOperation implements BackupOperation {\n    private Collection<CollectionItem> backupItems;\n    public CollectionMergeBackupOperation() {\n    }\n    public CollectionMergeBackupOperation(String name, Collection<CollectionItem> backupItems) {\n        super(name);\n        this.backupItems = backupItems;\n    }\n    @Override\n    public void run() throws Exception {\n        CollectionContainer container = getOrCreateContainer();\n        if (backupItems.isEmpty()) {\n            RemoteService service = getService();\n            service.destroyDistributedObject(name);\n        } else {\n            Map<Long, CollectionItem> backupMap = container.getMap();\n            backupMap.clear();\n            for (CollectionItem backupItem : backupItems) {\n                backupMap.put(backupItem.getItemId(), backupItem);\n            }\n        }\n    }\n    @Override\n    public int getId() {\n        return CollectionDataSerializerHook.COLLECTION_MERGE_BACKUP;\n    }\n    @Override\n    protected void writeInternal(ObjectDataOutput out) throws IOException {\n        super.writeInternal(out);\n        out.writeInt(backupItems.size());\n        for (CollectionItem backupItem : backupItems) {\n            out.writeObject(backupItem);\n        }\n    }\n    @Override\n    protected void readInternal(ObjectDataInput in) throws IOException {\n        super.readInternal(in);\n        int size = in.readInt();\n        backupItems = new ArrayList<CollectionItem>(size);\n        for (int i = 0; i < size; i++) {\n            CollectionItem backupItem = in.readObject();\n            backupItems.add(backupItem);\n        }\n    }\n"]]}
{"hexsha": "1f693c000ac2d52bbc1d7402ececd725273ffef9", "ext": "java", "lang": "Java", "content": "public class TestBench {\n\n  byte[] challenge = new byte[0];\n  private SaslServer saslServer;\n  private SaslClient saslClient;\n\n  public static void main(String[] args) throws Exception {\n    new TestBench().run();\n  }\n\n  private void run() throws Exception {\n    System.setProperty(\"java.security.krb5.conf\", \"/etc/krb5.conf\");\n\n    LoginParams serverParam = new LoginParams();\n    serverParam.put(LoginParam.PRINCIPAL, \"om/om@ATHENA.MIT.EDU\");\n    serverParam.put(LoginParam.KEYTAB, \"/tmp/om.keytab\");\n\n    LoginContext serverContext =\n        new LoginContext(LoginConfiguration.KERBEROS_CONFIG_NAME,\n            (Subject) null, null,\n            new LoginConfiguration(serverParam));\n    serverContext.login();\n    saslServer = Subject.doAs(serverContext.getSubject(),\n        (PrivilegedExceptionAction<SaslServer>) this::getSaslServer);\n\n    LoginParams clientParams = new LoginParams();\n    clientParams.put(LoginParam.PRINCIPAL, \"admin/admin@ATHENA.MIT.EDU\");\n    clientParams.put(LoginParam.KEYTAB, \"/tmp/admin.keytab\");\n\n    LoginContext clientContext =\n        new LoginContext(LoginConfiguration.KERBEROS_CONFIG_NAME,\n            (Subject) null, null,\n            new LoginConfiguration(clientParams));\n    clientContext.login();\n\n    saslClient = Subject.doAs(clientContext.getSubject(),\n        (PrivilegedExceptionAction<SaslClient>) () -> getSaslClient());\n\n    Subject.doAs(clientContext.getSubject(),\n        (PrivilegedExceptionAction<Void>) () -> {\n          challenge =\n              saslClient.evaluateChallenge(challenge);\n          return null;\n        });\n    challenge = saslServer.evaluateResponse(challenge);\n    System.out.println(saslServer.isComplete());\n    challenge = saslClient.evaluateChallenge(challenge);\n    challenge = saslServer.evaluateResponse(challenge);\n    System.out.println(saslServer.isComplete());\n    System.out.println(saslServer.getAuthorizationID());\n    return;\n\n  }\n\n  private SaslClient getSaslClient() throws SaslException {\n    Enumeration<SaslClientFactory> saslClientFactories =\n        Sasl.getSaslClientFactories();\n    while (saslClientFactories.hasMoreElements()) {\n      SaslClient saslClient = saslClientFactories.nextElement()\n          .createSaslClient(new String[] {\"GSSAPI\"}, \"\",\n              \"om\", \"om\",\n              new HashMap<String, String>(), null);\n      if (saslClient != null) {\n        return saslClient;\n      }\n    }\n    throw new IllegalArgumentException(\n        \"Can't found SaslClient implementation compatible with GSSAPI\");\n  }\n\n  private SaslServer getSaslServer() throws SaslException {\n    Enumeration<SaslServerFactory> saslServerFactories =\n        Sasl.getSaslServerFactories();\n    while (saslServerFactories.hasMoreElements()) {\n      SaslServer saslServer = saslServerFactories.nextElement()\n          .createSaslServer(\"GSSAPI\", \"om\", \"om\",\n              new HashMap<String, String>(),\n              new SaslGssCallbackHandler());\n      if (saslServer != null) {\n        return saslServer;\n      }\n    }\n    throw new IllegalArgumentException(\n        \"Can't found SaslServer implementation compatible with GSSAPI\");\n  }\n}", "class_id": 0, "repo": "elek/grpc-kerberos", "file": "library/src/test/java/net/anzix/grpc/kerberos/TestBench.java", "last_update_at": "2019-09-30T00:51:24+00:00", "question_id": "1f693c000ac2d52bbc1d7402ececd725273ffef9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestBench {\n  byte[] challenge = new byte[0];\n  private SaslServer saslServer;\n  private SaslClient saslClient;\n  public static void main(String[] args) throws Exception {\n    new TestBench().run();\n  }\n  private void run() throws Exception {\n    System.setProperty(\"java.security.krb5.conf\", \"/etc/krb5.conf\");\n    LoginParams serverParam = new LoginParams();\n    serverParam.put(LoginParam.PRINCIPAL, \"om/om@ATHENA.MIT.EDU\");\n    serverParam.put(LoginParam.KEYTAB, \"/tmp/om.keytab\");\n    LoginContext serverContext =\n        new LoginContext(LoginConfiguration.KERBEROS_CONFIG_NAME,\n            (Subject) null, null,\n            new LoginConfiguration(serverParam));\n    serverContext.login();\n    saslServer = Subject.doAs(serverContext.getSubject(),\n        (PrivilegedExceptionAction<SaslServer>) this::getSaslServer);\n    LoginParams clientParams = new LoginParams();\n    clientParams.put(LoginParam.PRINCIPAL, \"admin/admin@ATHENA.MIT.EDU\");\n    clientParams.put(LoginParam.KEYTAB, \"/tmp/admin.keytab\");\n    LoginContext clientContext =\n        new LoginContext(LoginConfiguration.KERBEROS_CONFIG_NAME,\n            (Subject) null, null,\n            new LoginConfiguration(clientParams));\n    clientContext.login();\n    saslClient = Subject.doAs(clientContext.getSubject(),\n        (PrivilegedExceptionAction<SaslClient>) () -> getSaslClient());\n    Subject.doAs(clientContext.getSubject(),\n        (PrivilegedExceptionAction<Void>) () -> {\n          challenge =\n              saslClient.evaluateChallenge(challenge);\n          return null;\n        });\n    challenge = saslServer.evaluateResponse(challenge);\n    System.out.println(saslServer.isComplete());\n    challenge = saslClient.evaluateChallenge(challenge);\n    challenge = saslServer.evaluateResponse(challenge);\n    System.out.println(saslServer.isComplete());\n    System.out.println(saslServer.getAuthorizationID());\n    return;\n  }\n  private SaslClient getSaslClient() throws SaslException {\n    Enumeration<SaslClientFactory> saslClientFactories =\n        Sasl.getSaslClientFactories();\n    while (saslClientFactories.hasMoreElements()) {\n      SaslClient saslClient = saslClientFactories.nextElement()\n          .createSaslClient(new String[] {\"GSSAPI\"}, \"\",\n              \"om\", \"om\",\n              new HashMap<String, String>(), null);\n      if (saslClient != null) {\n        return saslClient;\n      }\n    }\n    throw new IllegalArgumentException(\n        \"Can't found SaslClient implementation compatible with GSSAPI\");\n  }\n  private SaslServer getSaslServer() throws SaslException {\n    Enumeration<SaslServerFactory> saslServerFactories =\n        Sasl.getSaslServerFactories();\n    while (saslServerFactories.hasMoreElements()) {\n      SaslServer saslServer = saslServerFactories.nextElement()\n          .createSaslServer(\"GSSAPI\", \"om\", \"om\",\n              new HashMap<String, String>(),\n              new SaslGssCallbackHandler());\n      if (saslServer != null) {\n        return saslServer;\n      }\n    }\n    throw new IllegalArgumentException(\n        \"Can't found SaslServer implementation compatible with GSSAPI\");\n  }\n"]]}
{"hexsha": "ba1e9741d3b740b9893ddafbf1a7ba49afca8c8b", "ext": "java", "lang": "Java", "content": "class DateVersionSelector implements VersionSelector {\n\n    /**\n     * a version date hint\n     */\n    private final long timestamp;\n\n    /**\n     * Creates a {@code DateVersionSelector} that will select the latest\n     * version of all those that are older than the given timestamp.\n     *\n     * @param timestamp reference timestamp\n     */\n    public DateVersionSelector(String timestamp) {\n        this.timestamp = ISO8601.parse(timestamp).getTimeInMillis();\n    }\n\n    @Override\n    public NodeBuilder select(@Nonnull NodeBuilder history)\n            throws RepositoryException {\n        long latestDate = Long.MIN_VALUE;\n        NodeBuilder latestVersion = null;\n        for (String name: history.getChildNodeNames()) {\n            // OAK-1192 skip hidden child nodes\n            if (name.charAt(0) == ':') {\n                continue;\n            }\n            NodeBuilder v = history.getChildNode(name);\n            if (name.equals(JcrConstants.JCR_ROOTVERSION)\n                    || name.equals(JcrConstants.JCR_VERSIONLABELS)) {\n                // ignore root version and labels node\n                continue;\n            }\n            long c = ISO8601.parse(v.getProperty(JcrConstants.JCR_CREATED).getValue(Type.DATE)).getTimeInMillis();\n            if (c > latestDate && c <= timestamp) {\n                latestDate = c;\n                latestVersion = v;\n            } else if (c == latestDate) {\n                throw new RepositoryException(\"two versions share the same jcr:created timestamp in history:\" + history);\n            }\n        }\n        return latestVersion;\n    }\n}", "class_id": 0, "repo": "dsppraveen/jackrabbit-oak", "file": "oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/DateVersionSelector.java", "last_update_at": "2019-02-22T02:49:16+00:00", "question_id": "ba1e9741d3b740b9893ddafbf1a7ba49afca8c8b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class DateVersionSelector implements VersionSelector {\n    /**\n     * a version date hint\n     */\n    private final long timestamp;\n    /**\n     * Creates a {@code DateVersionSelector} that will select the latest\n     * version of all those that are older than the given timestamp.\n     *\n     * @param timestamp reference timestamp\n     */\n    public DateVersionSelector(String timestamp) {\n        this.timestamp = ISO8601.parse(timestamp).getTimeInMillis();\n    }\n    @Override\n    public NodeBuilder select(@Nonnull NodeBuilder history)\n            throws RepositoryException {\n        long latestDate = Long.MIN_VALUE;\n        NodeBuilder latestVersion = null;\n        for (String name: history.getChildNodeNames()) {\n            // OAK-1192 skip hidden child nodes\n            if (name.charAt(0) == ':') {\n                continue;\n            }\n            NodeBuilder v = history.getChildNode(name);\n            if (name.equals(JcrConstants.JCR_ROOTVERSION)\n                    || name.equals(JcrConstants.JCR_VERSIONLABELS)) {\n                // ignore root version and labels node\n                continue;\n            }\n            long c = ISO8601.parse(v.getProperty(JcrConstants.JCR_CREATED).getValue(Type.DATE)).getTimeInMillis();\n            if (c > latestDate && c <= timestamp) {\n                latestDate = c;\n                latestVersion = v;\n            } else if (c == latestDate) {\n                throw new RepositoryException(\"two versions share the same jcr:created timestamp in history:\" + history);\n            }\n        }\n        return latestVersion;\n    }\n"]]}
{"hexsha": "47e2f44e3d18191cb198f1d9adda29b22820cda2", "ext": "java", "lang": "Java", "content": "public class _257BinaryTreePaths{\n\tpublic static class TreeNode {\n\t\tint val;\n\t\tTreeNode left;\n\t\tTreeNode right;\n\t\tTreeNode(int x) { val = x; }\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tTreeNode tn=new TreeNode(1);\n\t\ttn.left=new TreeNode(2);\n\t\ttn.right=new TreeNode(3);\n\t\ttn.left.left=new TreeNode(4);\n\t\ttn.left.right=new TreeNode(5);\n\t\ttn.right.left=new TreeNode(6);\n\t\ttn.right.right=new TreeNode(7);\n\t\tbinaryTreePaths(tn);\n\t}\n\tstatic int[] path;\n\tstatic List<String> list;\n\tpublic static List<String> binaryTreePaths(TreeNode root) {\n\t\tpath=new int[100];\n\t\tlist=new ArrayList<String>();\n\t\tif(root==null)\n\t\t{\n\t\t\treturn list;\n\t\t}\n\t\tprintNodes(root,0);\n\t\treturn list;\n\t}\n\tprivate static void printNodes(TreeNode root, int i) {\n\t\tif(root==null)\n\t\t\treturn;\n\t\tif(root.left==null && root.right==null){\n\t\t\tpath[i]=root.val;\n\t\t\tString str=(Arrays.toString(Arrays.copyOf(path, i+1)));\n\t\t\tstr=str.replace(\", \", \"->\").replace(\"[\", \"\").replace(\"]\", \"\");\n\t\t\tlist.add(str);\n\t\t\treturn;\n\t\t}\n\t\tpath[i]=root.val;\n\t\tprintNodes(root.left, i+1);\n\t\tprintNodes(root.right, i+1);\n\t}\n\t\n\n}", "class_id": 0, "repo": "darshanhs90/Java-HackerRank", "file": "src/LeetCodePractice/_257BinaryTreePaths.java", "last_update_at": "2019-08-09T07:31:34+00:00", "question_id": "47e2f44e3d18191cb198f1d9adda29b22820cda2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class _257BinaryTreePaths{\n\tpublic static class TreeNode {\n\t\tint val;\n\t\tTreeNode left;\n\t\tTreeNode right;\n\t\tTreeNode(int x) { val = x; }\n\t}\n\tpublic static void main(String[] args) {\n\t\tTreeNode tn=new TreeNode(1);\n\t\ttn.left=new TreeNode(2);\n\t\ttn.right=new TreeNode(3);\n\t\ttn.left.left=new TreeNode(4);\n\t\ttn.left.right=new TreeNode(5);\n\t\ttn.right.left=new TreeNode(6);\n\t\ttn.right.right=new TreeNode(7);\n\t\tbinaryTreePaths(tn);\n\t}\n\tstatic int[] path;\n\tstatic List<String> list;\n\tpublic static List<String> binaryTreePaths(TreeNode root) {\n\t\tpath=new int[100];\n\t\tlist=new ArrayList<String>();\n\t\tif(root==null)\n\t\t{\n\t\t\treturn list;\n\t\t}\n\t\tprintNodes(root,0);\n\t\treturn list;\n\t}\n\tprivate static void printNodes(TreeNode root, int i) {\n\t\tif(root==null)\n\t\t\treturn;\n\t\tif(root.left==null && root.right==null){\n\t\t\tpath[i]=root.val;\n\t\t\tString str=(Arrays.toString(Arrays.copyOf(path, i+1)));\n\t\t\tstr=str.replace(\", \", \"->\").replace(\"[\", \"\").replace(\"]\", \"\");\n\t\t\tlist.add(str);\n\t\t\treturn;\n\t\t}\n\t\tpath[i]=root.val;\n\t\tprintNodes(root.left, i+1);\n\t\tprintNodes(root.right, i+1);\n\t}\n\t\n"]]}
{"hexsha": "26bdb990132c73a7b419f79d1bd19d32d26e2f67", "ext": "java", "lang": "Java", "content": "public class FreeMarkerWorker {\n\n    public static final String module = FreeMarkerWorker.class.getName();\n\n    // use soft references for this so that things from Content records don't kill all of our memory, or maybe not for performance reasons... hmmm, leave to config file...\n    public static UtilCache<String, Template> cachedTemplates = UtilCache.createUtilCache(\"template.ftl.general\", 0, 0, false);\n    protected static BeansWrapper defaultOfbizWrapper = BeansWrapper.getDefaultInstance();\n    protected static Configuration defaultOfbizConfig = makeConfiguration(defaultOfbizWrapper);\n\n    public static Configuration makeConfiguration(BeansWrapper wrapper) {\n        Configuration newConfig = new Configuration();\n\n        newConfig.setObjectWrapper(wrapper);\n        newConfig.setSharedVariable(\"Static\", wrapper.getStaticModels());\n        newConfig.setLocalizedLookup(false);\n        newConfig.setSharedVariable(\"StringUtil\", new BeanModel(StringUtil.INSTANCE, wrapper));\n        newConfig.setTemplateLoader(new FlexibleTemplateLoader());\n        newConfig.setAutoImports(UtilProperties.getProperties(\"freemarkerImports\"));\n        newConfig.setTemplateExceptionHandler(new FreeMarkerWorker.OFBizTemplateExceptionHandler());\n        try {\n            newConfig.setSetting(\"datetime_format\", \"yyyy-MM-dd HH:mm:ss.SSS\");\n            newConfig.setSetting(\"number_format\", \"0.##########\");\n        } catch (TemplateException e) {\n            Debug.logError(\"Unable to set date/time and number formats in FreeMarker: \" + e, module);\n        }\n        // Transforms properties file set up as key=transform name, property=transform class name\n        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n        Enumeration<URL> resources;\n        try {\n            resources = loader.getResources(\"freemarkerTransforms.properties\");\n        } catch (IOException e) {\n            Debug.logError(e, \"Could not load list of freemarkerTransforms.properties\", module);\n            throw UtilMisc.initCause(new InternalError(e.getMessage()), e);\n        }\n        while (resources.hasMoreElements()) {\n            URL propertyURL = resources.nextElement();\n            Debug.logInfo(\"loading properties: \" + propertyURL, module);\n            Properties props = UtilProperties.getProperties(propertyURL);\n            if (props == null || props.isEmpty()) {\n                Debug.logError(\"Unable to locate properties file \" + propertyURL, module);\n            } else {\n                loadTransforms(loader, props, newConfig);\n            }\n        }\n\n        return newConfig;\n    }\n\n    /**\n     * Protected helper method.\n     */\n    protected static void loadTransforms(ClassLoader loader, Properties props, Configuration config) {\n        for (Iterator<Object> i = props.keySet().iterator(); i.hasNext();) {\n            String key = (String) i.next();\n            String className = props.getProperty(key);\n            if (Debug.verboseOn()) {\n                Debug.logVerbose(\"Adding FTL Transform \" + key + \" with class \" + className, module);\n            }\n            try {\n                config.setSharedVariable(key, loader.loadClass(className).newInstance());\n            } catch (Exception e) {\n                Debug.logError(e, \"Could not pre-initialize dynamically loaded class: \" + className + \": \" + e, module);\n            }\n        }\n    }\n\n    /**\n     * Renders a template at the specified location.\n     * @param templateLocation Location of the template - file path or URL\n     * @param context The context Map\n     * @param outWriter The Writer to render to\n     */\n    public static void renderTemplateAtLocation(String templateLocation, Map<String, Object> context, Appendable outWriter) throws MalformedURLException, TemplateException, IOException {\n        renderTemplate(templateLocation, context, outWriter);\n    }\n\n    /**\n     * Renders a template contained in a String.\n     * @param templateLocation A unique ID for this template - used for caching\n     * @param templateString The String containing the template\n     * @param context The context Map\n     * @param outWriter The Writer to render to\n     */\n    public static void renderTemplate(String templateLocation, String templateString, Map<String, Object> context, Appendable outWriter) throws TemplateException, IOException {\n        renderTemplate(templateLocation, templateString, context, outWriter, true);\n    }\n\n    /**\n     * Renders a template contained in a String.\n     * @param templateLocation A unique ID for this template - used for caching\n     * @param templateString The String containing the template\n     * @param context The context Map\n     * @param outWriter The Writer to render to\n     * @param useCache try to get template from cache\n     */\n    public static void renderTemplate(String templateLocation, String templateString, Map<String, Object> context, Appendable outWriter, boolean useCache) throws TemplateException, IOException {\n        if (UtilValidate.isEmpty(templateString)) {\n            renderTemplate(templateLocation, context, outWriter);\n        } else {\n            renderTemplateFromString(templateString, templateLocation, context, outWriter, useCache);\n        }\n    }\n\n    /**\n     * Renders a template from a Reader.\n     * @param templateLocation A unique ID for this template - used for caching\n     * @param context The context Map\n     * @param outWriter The Writer to render to\n     */\n    public static void renderTemplate(String templateLocation, Map<String, Object> context, Appendable outWriter) throws TemplateException, IOException {\n        Template template = getTemplate(templateLocation);\n        renderTemplate(template, context, outWriter);\n    }\n\n    /**\n     * @deprecated Renamed to {@link #renderTemplateFromString(String, String, Map, Appendable, boolean)}\n     */\n    @Deprecated\n    public static Environment renderTemplateFromString(String templateString, String templateLocation, Map<String, Object> context, Appendable outWriter) throws TemplateException, IOException {\n        Template template = cachedTemplates.get(templateLocation);\n        if (template == null) {\n            synchronized (cachedTemplates) {\n                template = cachedTemplates.get(templateLocation);\n                if (template == null) {\n                    Reader templateReader = new StringReader(templateString);\n                    template = new Template(templateLocation, templateReader, defaultOfbizConfig);\n                    templateReader.close();\n                    cachedTemplates.put(templateLocation, template);\n                }\n            }\n        }\n        return renderTemplate(template, context, outWriter);\n    }\n\n    public static Environment renderTemplateFromString(String templateString, String templateLocation, Map<String, Object> context, Appendable outWriter, boolean useCache) throws TemplateException, IOException {\n        Template template = null;\n        if (useCache){\n            template = cachedTemplates.get(templateLocation);\n        }\n        if (template == null) {\n            if (useCache){\n                synchronized (cachedTemplates) {\n                    template = cachedTemplates.get(templateLocation);\n                    if (template == null) {\n                        Reader templateReader = new StringReader(templateString);\n                        template = new Template(templateLocation, templateReader, defaultOfbizConfig);\n                        templateReader.close();\n                        cachedTemplates.put(templateLocation, template);\n                    }\n                }\n            } else {\n                Reader templateReader = new StringReader(templateString);\n                template = new Template(templateLocation, templateReader, defaultOfbizConfig);\n                templateReader.close();\n            }\n        }\n\n        return renderTemplate(template, context, outWriter);\n    }\n\n    public static void clearTemplateFromCache(String templateLocation) {\n        synchronized (cachedTemplates) {\n            cachedTemplates.remove(templateLocation);\n        }\n    }\n\n    /**\n     * Renders a Template instance.\n     * @param template A Template instance\n     * @param context The context Map\n     * @param outWriter The Writer to render to\n     */\n    public static Environment renderTemplate(Template template, Map<String, Object> context, Appendable outWriter) throws TemplateException, IOException {\n        // make sure there is no \"null\" string in there as FreeMarker will try to use it\n        context.remove(\"null\");\n        // Since the template cache keeps a single instance of a Template that is shared among users,\n        // and since that Template instance is immutable, we need to create an Environment instance and\n        // use it to process the template with the user's settings.\n        //\n        // FIXME: the casting from Appendable to Writer is a temporary fix that could cause a\n        //        run time error if in the future we will pass a different class to the method\n        //        (such as a StringBuffer).\n        Environment env = template.createProcessingEnvironment(context, (Writer) outWriter);\n        applyUserSettings(env, context);\n        env.process();\n        return env;\n    }\n\n    /**\n     * Apply user settings to an Environment instance.\n     * @param env An Environment instance\n     * @param context The context Map containing the user settings\n     */\n    public static void applyUserSettings(Environment env, Map<String, Object> context) throws TemplateException {\n        Locale locale = (Locale) context.get(\"locale\");\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        env.setLocale(locale);\n\n        TimeZone timeZone = (TimeZone) context.get(\"timeZone\");\n        if (timeZone == null) {\n            timeZone = TimeZone.getDefault();\n        }\n        env.setTimeZone(timeZone);\n    }\n\n    public static Configuration getDefaultOfbizConfig() {\n        return defaultOfbizConfig;\n    }\n\n    /** Make sure to close the reader when you're done! That's why this method is private, BTW. */\n    private static Reader makeReader(String templateLocation) throws IOException {\n        if (UtilValidate.isEmpty(templateLocation)) {\n            throw new IllegalArgumentException(\"FreeMarker template location null or empty\");\n        }\n\n        URL locationUrl = null;\n        try {\n            locationUrl = FlexibleLocation.resolveLocation(templateLocation);\n        } catch (MalformedURLException e) {\n            throw new IllegalArgumentException(e.getMessage());\n        }\n        if (locationUrl == null) {\n            throw new IllegalArgumentException(\"FreeMarker file not found at location: \" + templateLocation);\n        }\n\n        InputStream locationIs = locationUrl.openStream();\n        Reader templateReader = new InputStreamReader(locationIs);\n\n        String locationProtocol = locationUrl.getProtocol();\n        if (\"file\".equals(locationProtocol) && Debug.verboseOn()) {\n            String locationFile = locationUrl.getFile();\n            int lastSlash = locationFile.lastIndexOf(\"/\");\n            String locationDir = locationFile.substring(0, lastSlash);\n            String filename = locationFile.substring(lastSlash + 1);\n            Debug.logVerbose(\"FreeMarker render: filename=\" + filename + \", locationDir=\" + locationDir, module);\n        }\n\n        return templateReader;\n    }\n\n    /**\n     * Gets a Template instance from the template cache. If the Template instance isn't\n     * found in the cache, then one will be created.\n     * @param templateLocation Location of the template - file path or URL\n     */\n    public static Template getTemplate(String templateLocation) throws TemplateException, IOException {\n        return getTemplate(templateLocation, cachedTemplates, defaultOfbizConfig);\n    }\n\n    public static Template getTemplate(String templateLocation, UtilCache<String, Template> cache, Configuration config) throws TemplateException, IOException {\n        Template template = cache.get(templateLocation);\n        if (template == null) {\n            synchronized (cache) {\n                template = cache.get(templateLocation);\n                if (template == null) {\n                    // only make the reader if we need it, and then close it right after!\n                    Reader templateReader = makeReader(templateLocation);\n                    template = new Template(templateLocation, templateReader, config);\n                    templateReader.close();\n                    cache.put(templateLocation, template);\n                }\n            }\n        }\n        return template;\n    }\n\n    public static String getArg(Map<String, ? extends Object> args, String key, Environment env) {\n        Map<String, ? extends Object> templateContext = FreeMarkerWorker.getWrappedObject(\"context\", env);\n        return getArg(args, key, templateContext);\n    }\n\n    public static String getArg(Map<String, ? extends Object> args, String key, Map<String, ? extends Object> templateContext) {\n        //SimpleScalar s = null;\n        Object o = args.get(key);\n        String returnVal = (String) unwrap(o);\n        if (returnVal == null) {\n            try {\n                if (templateContext != null) {\n                    returnVal = (String) templateContext.get(key);\n                }\n            } catch (ClassCastException e2) {\n                //return null;\n            }\n        }\n        return returnVal;\n    }\n\n    public static Object getArgObject(Map<String, ? extends Object> args, String key, Map<String, ? extends Object> templateContext) {\n        //SimpleScalar s = null;\n        Object o = args.get(key);\n        Object returnVal = unwrap(o);\n        if (returnVal == null) {\n            try {\n                if (templateContext != null) {\n                    returnVal = templateContext.get(key);\n                }\n            } catch (ClassCastException e2) {\n                //return null;\n            }\n        }\n        return returnVal;\n    }\n\n   /**\n    * Gets BeanModel from FreeMarker context and returns the object that it wraps.\n    * @param varName the name of the variable in the FreeMarker context.\n    * @param env the FreeMarker Environment\n    */\n    public static <T> T getWrappedObject(String varName, Environment env) {\n        Object obj = null;\n        try {\n            obj = env.getVariable(varName);\n            if (obj != null) {\n                if (obj == TemplateModel.NOTHING) {\n                    obj = null;\n                } else if (obj instanceof BeanModel) {\n                    BeanModel bean = (BeanModel) obj;\n                    obj = bean.getWrappedObject();\n                } else if (obj instanceof SimpleScalar) {\n                    obj = obj.toString();\n                }\n            }\n        } catch (TemplateModelException e) {\n            Debug.logInfo(e.getMessage(), module);\n        }\n        return UtilGenerics.<T>cast(obj);\n    }\n\n   /**\n    * Gets BeanModel from FreeMarker context and returns the object that it wraps.\n    * @param varName the name of the variable in the FreeMarker context.\n    * @param env the FreeMarker Environment\n    */\n    public static BeanModel getBeanModel(String varName, Environment env) {\n        BeanModel bean = null;\n        try {\n            bean = (BeanModel) env.getVariable(varName);\n        } catch (TemplateModelException e) {\n            Debug.logInfo(e.getMessage(), module);\n        }\n        return bean;\n    }\n\n    public static Object get(SimpleHash args, String key) {\n        Object o = null;\n        try {\n            o = args.get(key);\n        } catch (TemplateModelException e) {\n            Debug.logVerbose(e.getMessage(), module);\n            return null;\n        }\n\n        Object returnObj = unwrap(o);\n\n        if (returnObj == null) {\n            Object ctxObj = null;\n            try {\n                ctxObj = args.get(\"context\");\n            } catch (TemplateModelException e) {\n                Debug.logInfo(e.getMessage(), module);\n                return returnObj;\n            }\n            Map<String, ?> ctx = null;\n            if (ctxObj instanceof BeanModel) {\n                ctx = UtilGenerics.cast(((BeanModel) ctxObj).getWrappedObject());\n                returnObj = ctx.get(key);\n            }\n            /*\n            try {\n                Map templateContext = (Map) FreeMarkerWorker.getWrappedObject(\"context\", env);\n                if (templateContext != null) {\n                    returnObj = (String) templateContext.get(key);\n                }\n            } catch (ClassCastException e2) {\n                //return null;\n            }\n            */\n        }\n        return returnObj;\n    }\n\n    public static Object unwrap(Object o) {\n        Object returnObj = null;\n\n        if (o == TemplateModel.NOTHING) {\n            returnObj = null;\n        } else if (o instanceof SimpleScalar) {\n            returnObj = o.toString();\n        } else if (o instanceof BeanModel) {\n            returnObj = ((BeanModel) o).getWrappedObject();\n        }\n\n        return returnObj;\n    }\n\n    public static void checkForLoop(String path, Map<String, Object> ctx) throws IOException {\n        List<String> templateList = UtilGenerics.checkList(ctx.get(\"templateList\"));\n        if (templateList == null) {\n            templateList = FastList.newInstance();\n        } else {\n            if (templateList.contains(path)) {\n                throw new IOException(path + \" has already been visited.\");\n            }\n        }\n        templateList.add(path);\n        ctx.put(\"templateList\", templateList);\n    }\n\n    public static Map<String, Object> createEnvironmentMap(Environment env) {\n        Map<String, Object> templateRoot = FastMap.newInstance();\n        Set<String> varNames = null;\n        try {\n            varNames = UtilGenerics.checkSet(env.getKnownVariableNames());\n        } catch (TemplateModelException e1) {\n            Debug.logError(e1, \"Error getting FreeMarker variable names, will not put pass current context on to sub-content\", module);\n        }\n        if (varNames != null) {\n            for (String varName: varNames) {\n                //freemarker.ext.beans.StringModel varObj = (freemarker.ext.beans.StringModel) varNameIter.next();\n                //Object varObj =  varNameIter.next();\n                //String varName = varObj.toString();\n                templateRoot.put(varName, FreeMarkerWorker.getWrappedObject(varName, env));\n            }\n        }\n        return templateRoot;\n    }\n\n    public static void saveContextValues(Map<String, Object> context, String [] saveKeyNames, Map<String, Object> saveMap) {\n        //Map saveMap = new HashMap();\n        for (String key: saveKeyNames) {\n            Object o = context.get(key);\n            if (o instanceof Map<?, ?>) {\n                o = UtilMisc.makeMapWritable(UtilGenerics.checkMap(o));\n            } else if (o instanceof List<?>) {\n                o = UtilMisc.makeListWritable(UtilGenerics.checkList(o));\n            }\n            saveMap.put(key, o);\n        }\n    }\n\n    public static Map<String, Object> saveValues(Map<String, Object> context, String [] saveKeyNames) {\n        Map<String, Object> saveMap = FastMap.newInstance();\n        for (String key: saveKeyNames) {\n            Object o = context.get(key);\n            if (o instanceof Map<?, ?>) {\n                o = UtilMisc.makeMapWritable(UtilGenerics.checkMap(o));\n            } else if (o instanceof List<?>) {\n                o = UtilMisc.makeListWritable(UtilGenerics.checkList(o));\n            }\n            saveMap.put(key, o);\n        }\n        return saveMap;\n    }\n\n\n    public static void reloadValues(Map<String, Object> context, Map<String, Object> saveValues, Environment env) {\n        for (Map.Entry<String, Object> entry: saveValues.entrySet()) {\n            String key = entry.getKey();\n            Object o = entry.getValue();\n            if (o instanceof Map<?, ?>) {\n                context.put(key, UtilMisc.makeMapWritable(UtilGenerics.checkMap(o)));\n            } else if (o instanceof List<?>) {\n                List<Object> list = new ArrayList<Object>();\n                list.addAll(UtilGenerics.checkList(o));\n                context.put(key, list);\n            } else {\n                context.put(key, o);\n            }\n            env.setVariable(key, autoWrap(o, env));\n        }\n    }\n\n    public static void removeValues(Map<String, ?> context, String... removeKeyNames) {\n        for (String key: removeKeyNames) {\n            context.remove(key);\n        }\n    }\n\n    public static void overrideWithArgs(Map<String, Object> ctx, Map<String, Object> args) {\n        for (Map.Entry<String, Object> entry: args.entrySet()) {\n            String key = entry.getKey();\n            Object obj = entry.getValue();\n            //if (Debug.infoOn()) Debug.logInfo(\"in overrideWithArgs, key(3):\" + key + \" obj:\" + obj + \" class:\" + obj.getClass().getName() , module);\n            if (obj != null) {\n                if (obj == TemplateModel.NOTHING) {\n                    ctx.put(key, null);\n                } else {\n                    Object unwrappedObj = unwrap(obj);\n                    if (unwrappedObj == null) {\n                        unwrappedObj = obj;\n                    }\n                    ctx.put(key, unwrappedObj.toString());\n                }\n            } else {\n                ctx.put(key, null);\n            }\n        }\n    }\n\n    public static void convertContext(Map<String, Object> ctx) {\n        for (Map.Entry<String, Object> entry: ctx.entrySet()) {\n            Object obj = entry.getValue();\n            if (obj != null) {\n                Object unwrappedObj = unwrap(obj);\n                if (unwrappedObj != null) {\n                    entry.setValue(unwrappedObj);\n                }\n            }\n        }\n    }\n\n    public static void getSiteParameters(HttpServletRequest request, Map<String, Object> ctx) {\n        if (request == null) {\n            return;\n        }\n        if (ctx == null) {\n            throw new IllegalArgumentException(\"Error in getSiteParameters, context/ctx cannot be null\");\n        }\n        ServletContext servletContext = request.getSession().getServletContext();\n        String rootDir = (String)ctx.get(\"rootDir\");\n        String webSiteId = (String)ctx.get(\"webSiteId\");\n        String https = (String)ctx.get(\"https\");\n        if (UtilValidate.isEmpty(rootDir)) {\n            rootDir = servletContext.getRealPath(\"/\");\n            ctx.put(\"rootDir\", rootDir);\n        }\n        if (UtilValidate.isEmpty(webSiteId)) {\n            webSiteId = (String) servletContext.getAttribute(\"webSiteId\");\n            ctx.put(\"webSiteId\", webSiteId);\n        }\n        if (UtilValidate.isEmpty(https)) {\n            https = (String) servletContext.getAttribute(\"https\");\n            ctx.put(\"https\", https);\n        }\n    }\n\n    public static TemplateModel autoWrap(Object obj, Environment env) {\n       BeansWrapper wrapper = BeansWrapper.getDefaultInstance();\n       TemplateModel templateModelObj = null;\n       try {\n           templateModelObj = wrapper.wrap(obj);\n       } catch (TemplateModelException e) {\n           throw new RuntimeException(e.getMessage());\n       }\n       return templateModelObj;\n    }\n\n    /**\n     * OFBiz Template Source. This class is used by FlexibleTemplateLoader.\n     */\n    static class FlexibleTemplateSource {\n        protected String templateLocation = null;\n        protected Date createdDate = new Date();\n\n        protected FlexibleTemplateSource() {}\n        public FlexibleTemplateSource(String templateLocation) {\n            this.templateLocation = templateLocation;\n        }\n\n        @Override\n        public int hashCode() {\n            return templateLocation.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return obj instanceof FlexibleTemplateSource && obj.hashCode() == this.hashCode();\n        }\n\n        public String getTemplateLocation() {\n            return templateLocation;\n        }\n\n        public long getLastModified() {\n            return createdDate.getTime();\n        }\n    }\n\n    /**\n     * OFBiz Template Loader. This template loader uses the FlexibleLocation\n     * class to locate and load Freemarker templates.\n     */\n    static class FlexibleTemplateLoader implements TemplateLoader {\n        public Object findTemplateSource(String name) throws IOException {\n            return new FlexibleTemplateSource(name);\n        }\n\n        public long getLastModified(Object templateSource) {\n            FlexibleTemplateSource fts = (FlexibleTemplateSource) templateSource;\n            return fts.getLastModified();\n        }\n\n        public Reader getReader(Object templateSource, String encoding) throws IOException {\n            FlexibleTemplateSource fts = (FlexibleTemplateSource) templateSource;\n            return makeReader(fts.getTemplateLocation());\n        }\n\n        public void closeTemplateSource(Object templateSource) throws IOException {\n            // do nothing\n        }\n    }\n\n    /**\n     * OFBiz specific TemplateExceptionHandler.  Sanitizes any error messages present in\n     * the stack trace prior to printing to the output writer.\n     */\n    static class OFBizTemplateExceptionHandler implements TemplateExceptionHandler {\n        public void handleTemplateException(TemplateException te, Environment env, Writer out) throws TemplateException {\n            StringWriter tempWriter = new StringWriter();\n            PrintWriter pw = new PrintWriter(tempWriter, true);\n            te.printStackTrace(pw);\n            String stackTrace = tempWriter.toString();\n\n            StringUtil.SimpleEncoder simpleEncoder = FreeMarkerWorker.getWrappedObject(\"simpleEncoder\", env);\n            if (simpleEncoder != null) {\n                stackTrace = simpleEncoder.encode(stackTrace);\n            }\n            try {\n                out.write(stackTrace);\n            } catch (IOException e) {\n                Debug.logError(e, module);\n            }\n        }\n    }\n\n    public static String encodeDoubleQuotes(String htmlString) {\n        return htmlString.replaceAll(\"\\\"\", \"\\\\\\\\\\\"\");\n    }\n}", "class_id": 0, "repo": "jeevankarla/testnhdc", "file": "framework/base/src/org/ofbiz/base/util/template/FreeMarkerWorker.java", "last_update_at": "2019-12-26T11:51:41+00:00", "question_id": "26bdb990132c73a7b419f79d1bd19d32d26e2f67", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FreeMarkerWorker {\n    public static final String module = FreeMarkerWorker.class.getName();\n    // use soft references for this so that things from Content records don't kill all of our memory, or maybe not for performance reasons... hmmm, leave to config file...\n    public static UtilCache<String, Template> cachedTemplates = UtilCache.createUtilCache(\"template.ftl.general\", 0, 0, false);\n    protected static BeansWrapper defaultOfbizWrapper = BeansWrapper.getDefaultInstance();\n    protected static Configuration defaultOfbizConfig = makeConfiguration(defaultOfbizWrapper);\n    public static Configuration makeConfiguration(BeansWrapper wrapper) {\n        Configuration newConfig = new Configuration();\n        newConfig.setObjectWrapper(wrapper);\n        newConfig.setSharedVariable(\"Static\", wrapper.getStaticModels());\n        newConfig.setLocalizedLookup(false);\n        newConfig.setSharedVariable(\"StringUtil\", new BeanModel(StringUtil.INSTANCE, wrapper));\n        newConfig.setTemplateLoader(new FlexibleTemplateLoader());\n        newConfig.setAutoImports(UtilProperties.getProperties(\"freemarkerImports\"));\n        newConfig.setTemplateExceptionHandler(new FreeMarkerWorker.OFBizTemplateExceptionHandler());\n        try {\n            newConfig.setSetting(\"datetime_format\", \"yyyy-MM-dd HH:mm:ss.SSS\");\n            newConfig.setSetting(\"number_format\", \"0.##########\");\n        } catch (TemplateException e) {\n            Debug.logError(\"Unable to set date/time and number formats in FreeMarker: \" + e, module);\n        }\n        // Transforms properties file set up as key=transform name, property=transform class name\n        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n        Enumeration<URL> resources;\n        try {\n            resources = loader.getResources(\"freemarkerTransforms.properties\");\n        } catch (IOException e) {\n            Debug.logError(e, \"Could not load list of freemarkerTransforms.properties\", module);\n            throw UtilMisc.initCause(new InternalError(e.getMessage()), e);\n        }\n        while (resources.hasMoreElements()) {\n            URL propertyURL = resources.nextElement();\n            Debug.logInfo(\"loading properties: \" + propertyURL, module);\n            Properties props = UtilProperties.getProperties(propertyURL);\n            if (props == null || props.isEmpty()) {\n                Debug.logError(\"Unable to locate properties file \" + propertyURL, module);\n            } else {\n                loadTransforms(loader, props, newConfig);\n            }\n        }\n        return newConfig;\n    }\n    /**\n     * Protected helper method.\n     */\n    protected static void loadTransforms(ClassLoader loader, Properties props, Configuration config) {\n        for (Iterator<Object> i = props.keySet().iterator(); i.hasNext();) {\n            String key = (String) i.next();\n            String className = props.getProperty(key);\n            if (Debug.verboseOn()) {\n                Debug.logVerbose(\"Adding FTL Transform \" + key + \" with class \" + className, module);\n            }\n            try {\n                config.setSharedVariable(key, loader.loadClass(className).newInstance());\n            } catch (Exception e) {\n                Debug.logError(e, \"Could not pre-initialize dynamically loaded class: \" + className + \": \" + e, module);\n            }\n        }\n    }\n    /**\n     * Renders a template at the specified location.\n     * @param templateLocation Location of the template - file path or URL\n     * @param context The context Map\n     * @param outWriter The Writer to render to\n     */\n    public static void renderTemplateAtLocation(String templateLocation, Map<String, Object> context, Appendable outWriter) throws MalformedURLException, TemplateException, IOException {\n        renderTemplate(templateLocation, context, outWriter);\n    }\n    /**\n     * Renders a template contained in a String.\n     * @param templateLocation A unique ID for this template - used for caching\n     * @param templateString The String containing the template\n     * @param context The context Map\n     * @param outWriter The Writer to render to\n     */\n    public static void renderTemplate(String templateLocation, String templateString, Map<String, Object> context, Appendable outWriter) throws TemplateException, IOException {\n        renderTemplate(templateLocation, templateString, context, outWriter, true);\n    }\n    /**\n     * Renders a template contained in a String.\n     * @param templateLocation A unique ID for this template - used for caching\n     * @param templateString The String containing the template\n     * @param context The context Map\n     * @param outWriter The Writer to render to\n     * @param useCache try to get template from cache\n     */\n    public static void renderTemplate(String templateLocation, String templateString, Map<String, Object> context, Appendable outWriter, boolean useCache) throws TemplateException, IOException {\n        if (UtilValidate.isEmpty(templateString)) {\n            renderTemplate(templateLocation, context, outWriter);\n        } else {\n            renderTemplateFromString(templateString, templateLocation, context, outWriter, useCache);\n        }\n    }\n    /**\n     * Renders a template from a Reader.\n     * @param templateLocation A unique ID for this template - used for caching\n     * @param context The context Map\n     * @param outWriter The Writer to render to\n     */\n    public static void renderTemplate(String templateLocation, Map<String, Object> context, Appendable outWriter) throws TemplateException, IOException {\n        Template template = getTemplate(templateLocation);\n        renderTemplate(template, context, outWriter);\n    }\n    /**\n     * @deprecated Renamed to {@link #renderTemplateFromString(String, String, Map, Appendable, boolean)}\n     */\n    @Deprecated\n    public static Environment renderTemplateFromString(String templateString, String templateLocation, Map<String, Object> context, Appendable outWriter) throws TemplateException, IOException {\n        Template template = cachedTemplates.get(templateLocation);\n        if (template == null) {\n            synchronized (cachedTemplates) {\n                template = cachedTemplates.get(templateLocation);\n                if (template == null) {\n                    Reader templateReader = new StringReader(templateString);\n                    template = new Template(templateLocation, templateReader, defaultOfbizConfig);\n                    templateReader.close();\n                    cachedTemplates.put(templateLocation, template);\n                }\n            }\n        }\n        return renderTemplate(template, context, outWriter);\n    }\n    public static Environment renderTemplateFromString(String templateString, String templateLocation, Map<String, Object> context, Appendable outWriter, boolean useCache) throws TemplateException, IOException {\n        Template template = null;\n        if (useCache){\n            template = cachedTemplates.get(templateLocation);\n        }\n        if (template == null) {\n            if (useCache){\n                synchronized (cachedTemplates) {\n                    template = cachedTemplates.get(templateLocation);\n                    if (template == null) {\n                        Reader templateReader = new StringReader(templateString);\n                        template = new Template(templateLocation, templateReader, defaultOfbizConfig);\n                        templateReader.close();\n                        cachedTemplates.put(templateLocation, template);\n                    }\n                }\n            } else {\n                Reader templateReader = new StringReader(templateString);\n                template = new Template(templateLocation, templateReader, defaultOfbizConfig);\n                templateReader.close();\n            }\n        }\n        return renderTemplate(template, context, outWriter);\n    }\n    public static void clearTemplateFromCache(String templateLocation) {\n        synchronized (cachedTemplates) {\n            cachedTemplates.remove(templateLocation);\n        }\n    }\n    /**\n     * Renders a Template instance.\n     * @param template A Template instance\n     * @param context The context Map\n     * @param outWriter The Writer to render to\n     */\n    public static Environment renderTemplate(Template template, Map<String, Object> context, Appendable outWriter) throws TemplateException, IOException {\n        // make sure there is no \"null\" string in there as FreeMarker will try to use it\n        context.remove(\"null\");\n        // Since the template cache keeps a single instance of a Template that is shared among users,\n        // and since that Template instance is immutable, we need to create an Environment instance and\n        // use it to process the template with the user's settings.\n        //\n        // FIXME: the casting from Appendable to Writer is a temporary fix that could cause a\n        //        run time error if in the future we will pass a different class to the method\n        //        (such as a StringBuffer).\n        Environment env = template.createProcessingEnvironment(context, (Writer) outWriter);\n        applyUserSettings(env, context);\n        env.process();\n        return env;\n    }\n    /**\n     * Apply user settings to an Environment instance.\n     * @param env An Environment instance\n     * @param context The context Map containing the user settings\n     */\n    public static void applyUserSettings(Environment env, Map<String, Object> context) throws TemplateException {\n        Locale locale = (Locale) context.get(\"locale\");\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        env.setLocale(locale);\n        TimeZone timeZone = (TimeZone) context.get(\"timeZone\");\n        if (timeZone == null) {\n            timeZone = TimeZone.getDefault();\n        }\n        env.setTimeZone(timeZone);\n    }\n    public static Configuration getDefaultOfbizConfig() {\n        return defaultOfbizConfig;\n    }\n    /** Make sure to close the reader when you're done! That's why this method is private, BTW. */\n    private static Reader makeReader(String templateLocation) throws IOException {\n        if (UtilValidate.isEmpty(templateLocation)) {\n            throw new IllegalArgumentException(\"FreeMarker template location null or empty\");\n        }\n        URL locationUrl = null;\n        try {\n            locationUrl = FlexibleLocation.resolveLocation(templateLocation);\n        } catch (MalformedURLException e) {\n            throw new IllegalArgumentException(e.getMessage());\n        }\n        if (locationUrl == null) {\n            throw new IllegalArgumentException(\"FreeMarker file not found at location: \" + templateLocation);\n        }\n        InputStream locationIs = locationUrl.openStream();\n        Reader templateReader = new InputStreamReader(locationIs);\n        String locationProtocol = locationUrl.getProtocol();\n        if (\"file\".equals(locationProtocol) && Debug.verboseOn()) {\n            String locationFile = locationUrl.getFile();\n            int lastSlash = locationFile.lastIndexOf(\"/\");\n            String locationDir = locationFile.substring(0, lastSlash);\n            String filename = locationFile.substring(lastSlash + 1);\n            Debug.logVerbose(\"FreeMarker render: filename=\" + filename + \", locationDir=\" + locationDir, module);\n        }\n        return templateReader;\n    }\n    /**\n     * Gets a Template instance from the template cache. If the Template instance isn't\n     * found in the cache, then one will be created.\n     * @param templateLocation Location of the template - file path or URL\n     */\n    public static Template getTemplate(String templateLocation) throws TemplateException, IOException {\n        return getTemplate(templateLocation, cachedTemplates, defaultOfbizConfig);\n    }\n    public static Template getTemplate(String templateLocation, UtilCache<String, Template> cache, Configuration config) throws TemplateException, IOException {\n        Template template = cache.get(templateLocation);\n        if (template == null) {\n            synchronized (cache) {\n                template = cache.get(templateLocation);\n                if (template == null) {\n                    // only make the reader if we need it, and then close it right after!\n                    Reader templateReader = makeReader(templateLocation);\n                    template = new Template(templateLocation, templateReader, config);\n                    templateReader.close();\n                    cache.put(templateLocation, template);\n                }\n            }\n        }\n        return template;\n    }\n    public static String getArg(Map<String, ? extends Object> args, String key, Environment env) {\n        Map<String, ? extends Object> templateContext = FreeMarkerWorker.getWrappedObject(\"context\", env);\n        return getArg(args, key, templateContext);\n    }\n    public static String getArg(Map<String, ? extends Object> args, String key, Map<String, ? extends Object> templateContext) {\n        //SimpleScalar s = null;\n        Object o = args.get(key);\n        String returnVal = (String) unwrap(o);\n        if (returnVal == null) {\n            try {\n                if (templateContext != null) {\n                    returnVal = (String) templateContext.get(key);\n                }\n            } catch (ClassCastException e2) {\n                //return null;\n            }\n        }\n        return returnVal;\n    }\n    public static Object getArgObject(Map<String, ? extends Object> args, String key, Map<String, ? extends Object> templateContext) {\n        //SimpleScalar s = null;\n        Object o = args.get(key);\n        Object returnVal = unwrap(o);\n        if (returnVal == null) {\n            try {\n                if (templateContext != null) {\n                    returnVal = templateContext.get(key);\n                }\n            } catch (ClassCastException e2) {\n                //return null;\n            }\n        }\n        return returnVal;\n    }\n   /**\n    * Gets BeanModel from FreeMarker context and returns the object that it wraps.\n    * @param varName the name of the variable in the FreeMarker context.\n    * @param env the FreeMarker Environment\n    */\n    public static <T> T getWrappedObject(String varName, Environment env) {\n        Object obj = null;\n        try {\n            obj = env.getVariable(varName);\n            if (obj != null) {\n                if (obj == TemplateModel.NOTHING) {\n                    obj = null;\n                } else if (obj instanceof BeanModel) {\n                    BeanModel bean = (BeanModel) obj;\n                    obj = bean.getWrappedObject();\n                } else if (obj instanceof SimpleScalar) {\n                    obj = obj.toString();\n                }\n            }\n        } catch (TemplateModelException e) {\n            Debug.logInfo(e.getMessage(), module);\n        }\n        return UtilGenerics.<T>cast(obj);\n    }\n   /**\n    * Gets BeanModel from FreeMarker context and returns the object that it wraps.\n    * @param varName the name of the variable in the FreeMarker context.\n    * @param env the FreeMarker Environment\n    */\n    public static BeanModel getBeanModel(String varName, Environment env) {\n        BeanModel bean = null;\n        try {\n            bean = (BeanModel) env.getVariable(varName);\n        } catch (TemplateModelException e) {\n            Debug.logInfo(e.getMessage(), module);\n        }\n        return bean;\n    }\n    public static Object get(SimpleHash args, String key) {\n        Object o = null;\n        try {\n            o = args.get(key);\n        } catch (TemplateModelException e) {\n            Debug.logVerbose(e.getMessage(), module);\n            return null;\n        }\n        Object returnObj = unwrap(o);\n        if (returnObj == null) {\n            Object ctxObj = null;\n            try {\n                ctxObj = args.get(\"context\");\n            } catch (TemplateModelException e) {\n                Debug.logInfo(e.getMessage(), module);\n                return returnObj;\n            }\n            Map<String, ?> ctx = null;\n            if (ctxObj instanceof BeanModel) {\n                ctx = UtilGenerics.cast(((BeanModel) ctxObj).getWrappedObject());\n                returnObj = ctx.get(key);\n            }\n            /*\n            try {\n                Map templateContext = (Map) FreeMarkerWorker.getWrappedObject(\"context\", env);\n                if (templateContext != null) {\n                    returnObj = (String) templateContext.get(key);\n                }\n            } catch (ClassCastException e2) {\n                //return null;\n            }\n            */\n        }\n        return returnObj;\n    }\n    public static Object unwrap(Object o) {\n        Object returnObj = null;\n        if (o == TemplateModel.NOTHING) {\n            returnObj = null;\n        } else if (o instanceof SimpleScalar) {\n            returnObj = o.toString();\n        } else if (o instanceof BeanModel) {\n            returnObj = ((BeanModel) o).getWrappedObject();\n        }\n        return returnObj;\n    }\n    public static void checkForLoop(String path, Map<String, Object> ctx) throws IOException {\n        List<String> templateList = UtilGenerics.checkList(ctx.get(\"templateList\"));\n        if (templateList == null) {\n            templateList = FastList.newInstance();\n        } else {\n            if (templateList.contains(path)) {\n                throw new IOException(path + \" has already been visited.\");\n            }\n        }\n        templateList.add(path);\n        ctx.put(\"templateList\", templateList);\n    }\n    public static Map<String, Object> createEnvironmentMap(Environment env) {\n        Map<String, Object> templateRoot = FastMap.newInstance();\n        Set<String> varNames = null;\n        try {\n            varNames = UtilGenerics.checkSet(env.getKnownVariableNames());\n        } catch (TemplateModelException e1) {\n            Debug.logError(e1, \"Error getting FreeMarker variable names, will not put pass current context on to sub-content\", module);\n        }\n        if (varNames != null) {\n            for (String varName: varNames) {\n                //freemarker.ext.beans.StringModel varObj = (freemarker.ext.beans.StringModel) varNameIter.next();\n                //Object varObj =  varNameIter.next();\n                //String varName = varObj.toString();\n                templateRoot.put(varName, FreeMarkerWorker.getWrappedObject(varName, env));\n            }\n        }\n        return templateRoot;\n    }\n    public static void saveContextValues(Map<String, Object> context, String [] saveKeyNames, Map<String, Object> saveMap) {\n        //Map saveMap = new HashMap();\n        for (String key: saveKeyNames) {\n            Object o = context.get(key);\n            if (o instanceof Map<?, ?>) {\n                o = UtilMisc.makeMapWritable(UtilGenerics.checkMap(o));\n            } else if (o instanceof List<?>) {\n                o = UtilMisc.makeListWritable(UtilGenerics.checkList(o));\n            }\n            saveMap.put(key, o);\n        }\n    }\n    public static Map<String, Object> saveValues(Map<String, Object> context, String [] saveKeyNames) {\n        Map<String, Object> saveMap = FastMap.newInstance();\n        for (String key: saveKeyNames) {\n            Object o = context.get(key);\n            if (o instanceof Map<?, ?>) {\n                o = UtilMisc.makeMapWritable(UtilGenerics.checkMap(o));\n            } else if (o instanceof List<?>) {\n                o = UtilMisc.makeListWritable(UtilGenerics.checkList(o));\n            }\n            saveMap.put(key, o);\n        }\n        return saveMap;\n    }\n    public static void reloadValues(Map<String, Object> context, Map<String, Object> saveValues, Environment env) {\n        for (Map.Entry<String, Object> entry: saveValues.entrySet()) {\n            String key = entry.getKey();\n            Object o = entry.getValue();\n            if (o instanceof Map<?, ?>) {\n                context.put(key, UtilMisc.makeMapWritable(UtilGenerics.checkMap(o)));\n            } else if (o instanceof List<?>) {\n                List<Object> list = new ArrayList<Object>();\n                list.addAll(UtilGenerics.checkList(o));\n                context.put(key, list);\n            } else {\n                context.put(key, o);\n            }\n            env.setVariable(key, autoWrap(o, env));\n        }\n    }\n    public static void removeValues(Map<String, ?> context, String... removeKeyNames) {\n        for (String key: removeKeyNames) {\n            context.remove(key);\n        }\n    }\n    public static void overrideWithArgs(Map<String, Object> ctx, Map<String, Object> args) {\n        for (Map.Entry<String, Object> entry: args.entrySet()) {\n            String key = entry.getKey();\n            Object obj = entry.getValue();\n            //if (Debug.infoOn()) Debug.logInfo(\"in overrideWithArgs, key(3):\" + key + \" obj:\" + obj + \" class:\" + obj.getClass().getName() , module);\n            if (obj != null) {\n                if (obj == TemplateModel.NOTHING) {\n                    ctx.put(key, null);\n                } else {\n                    Object unwrappedObj = unwrap(obj);\n                    if (unwrappedObj == null) {\n                        unwrappedObj = obj;\n                    }\n                    ctx.put(key, unwrappedObj.toString());\n                }\n            } else {\n                ctx.put(key, null);\n            }\n        }\n    }\n    public static void convertContext(Map<String, Object> ctx) {\n        for (Map.Entry<String, Object> entry: ctx.entrySet()) {\n            Object obj = entry.getValue();\n            if (obj != null) {\n                Object unwrappedObj = unwrap(obj);\n                if (unwrappedObj != null) {\n                    entry.setValue(unwrappedObj);\n                }\n            }\n        }\n    }\n    public static void getSiteParameters(HttpServletRequest request, Map<String, Object> ctx) {\n        if (request == null) {\n            return;\n        }\n        if (ctx == null) {\n            throw new IllegalArgumentException(\"Error in getSiteParameters, context/ctx cannot be null\");\n        }\n        ServletContext servletContext = request.getSession().getServletContext();\n        String rootDir = (String)ctx.get(\"rootDir\");\n        String webSiteId = (String)ctx.get(\"webSiteId\");\n        String https = (String)ctx.get(\"https\");\n        if (UtilValidate.isEmpty(rootDir)) {\n            rootDir = servletContext.getRealPath(\"/\");\n            ctx.put(\"rootDir\", rootDir);\n        }\n        if (UtilValidate.isEmpty(webSiteId)) {\n            webSiteId = (String) servletContext.getAttribute(\"webSiteId\");\n            ctx.put(\"webSiteId\", webSiteId);\n        }\n        if (UtilValidate.isEmpty(https)) {\n            https = (String) servletContext.getAttribute(\"https\");\n            ctx.put(\"https\", https);\n        }\n    }\n    public static TemplateModel autoWrap(Object obj, Environment env) {\n       BeansWrapper wrapper = BeansWrapper.getDefaultInstance();\n       TemplateModel templateModelObj = null;\n       try {\n           templateModelObj = wrapper.wrap(obj);\n       } catch (TemplateModelException e) {\n           throw new RuntimeException(e.getMessage());\n       }\n       return templateModelObj;\n    }\n    /**\n     * OFBiz Template Source. This class is used by FlexibleTemplateLoader.\n     */\n    static class FlexibleTemplateSource {\n        protected String templateLocation = null;\n        protected Date createdDate = new Date();\n        protected FlexibleTemplateSource() {}\n        public FlexibleTemplateSource(String templateLocation) {\n            this.templateLocation = templateLocation;\n        }\n        @Override\n        public int hashCode() {\n            return templateLocation.hashCode();\n        }\n        @Override\n        public boolean equals(Object obj) {\n            return obj instanceof FlexibleTemplateSource && obj.hashCode() == this.hashCode();\n        }\n        public String getTemplateLocation() {\n            return templateLocation;\n        }\n        public long getLastModified() {\n            return createdDate.getTime();\n        }\n    }\n    /**\n     * OFBiz Template Loader. This template loader uses the FlexibleLocation\n     * class to locate and load Freemarker templates.\n     */\n    static class FlexibleTemplateLoader implements TemplateLoader {\n        public Object findTemplateSource(String name) throws IOException {\n            return new FlexibleTemplateSource(name);\n        }\n        public long getLastModified(Object templateSource) {\n            FlexibleTemplateSource fts = (FlexibleTemplateSource) templateSource;\n            return fts.getLastModified();\n        }\n        public Reader getReader(Object templateSource, String encoding) throws IOException {\n            FlexibleTemplateSource fts = (FlexibleTemplateSource) templateSource;\n            return makeReader(fts.getTemplateLocation());\n        }\n        public void closeTemplateSource(Object templateSource) throws IOException {\n            // do nothing\n        }\n    }\n    /**\n     * OFBiz specific TemplateExceptionHandler.  Sanitizes any error messages present in\n     * the stack trace prior to printing to the output writer.\n     */\n    static class OFBizTemplateExceptionHandler implements TemplateExceptionHandler {\n        public void handleTemplateException(TemplateException te, Environment env, Writer out) throws TemplateException {\n            StringWriter tempWriter = new StringWriter();\n            PrintWriter pw = new PrintWriter(tempWriter, true);\n            te.printStackTrace(pw);\n            String stackTrace = tempWriter.toString();\n            StringUtil.SimpleEncoder simpleEncoder = FreeMarkerWorker.getWrappedObject(\"simpleEncoder\", env);\n            if (simpleEncoder != null) {\n                stackTrace = simpleEncoder.encode(stackTrace);\n            }\n            try {\n                out.write(stackTrace);\n            } catch (IOException e) {\n                Debug.logError(e, module);\n            }\n        }\n    }\n    public static String encodeDoubleQuotes(String htmlString) {\n        return htmlString.replaceAll(\"\\\"\", \"\\\\\\\\\\\"\");\n    }\n"]]}
{"hexsha": "98431ce199502477d7e5d51902642e98a05b1485", "ext": "java", "lang": "Java", "content": "public class ColorSpectrum extends Display {\r\n\tpublic ExPar Color = new ExPar(COLOR, new ExParValue(new ExParExpression(\r\n\t\t\tExParExpression.GRAY)), \"Dummy bar color\");\r\n\r\n\tpublic ColorSpectrum() {\r\n\t\tsetTitleAndTopic(\"Smooth Color Spectrum\", DISPLAY_TEST_DSP | DEMO);\r\n\t}\r\n\tprivate int nLines;\r\n\tprivate int s1, x1, x2, y1, y2;\r\n\tprivate Color[] spectrum = new Color[(700 - 400) + 1];\r\n\r\n\tprotected int create() {\r\n\t\ts1 = enterDisplayElement(new Bar(Color));\r\n\t\tSpectralDistribution sd;\r\n\t\tSpectralDistribution CIEy = SpectralDistributionFactory.yCMF31();\r\n\t\tint k = 0;\r\n\t\tfor (int i = 400; i <= 700; i++) {\r\n\t\t\tsd = new SpectralDistribution(400, 701, 1, 0.0F);\r\n\t\t\tsd.setValueAt(i, 1.0);\r\n\t\t\tPxlColor c = sd.toXYZ();\r\n\t\t\tc.setY(CIEy.valueAt(i) * 80.0);\r\n\t\t\tspectrum[k++] = c.dev();\r\n\t\t}\r\n\t\treturn s1;\r\n\t}\r\n\r\n\tprotected void computeGeometry() {\r\n\t\tRectangle r = centeredRect(width, height, (int) (4 * width / 5),\r\n\t\t\t\t(int) (height / 4));\r\n\t\tnLines = r.width;\r\n\t\tx1 = r.x;\r\n\t\tx2 = r.x;\r\n\t\ty1 = r.y;\r\n\t\ty2 = r.y + r.height;\r\n\t}\r\n\r\n\t/**\r\n\t * This display has its own paint method for drawing the non-selectable\r\n\t * transition area.\r\n\t */\r\n\tpublic void show(Graphics g) {\r\n\t\tsuper.show(g);\r\n\t\t// Now draw the transition area. Positions have already been computed.\r\n\t\tif (nLines > 0) {\r\n\t\t\tint xx1 = x1;\r\n\t\t\tint xx2 = x2;\r\n\t\t\tfor (int i = 0; i < nLines; i++) {\r\n\t\t\t\tg.setColor(spectrum[(int) ((double) ((spectrum.length - 1)) * i / (double) (nLines - 1))]);\r\n\t\t\t\tg.drawLine(xx1++, y1, xx2++, y2);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}", "class_id": 0, "repo": "manuelgentile/pxlab", "file": "pxlab/src/main/java/de/pxlab/pxl/display/ColorSpectrum.java", "last_update_at": "2019-03-04T11:10:59+00:00", "question_id": "98431ce199502477d7e5d51902642e98a05b1485", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ColorSpectrum extends Display {\r\n\tpublic ExPar Color = new ExPar(COLOR, new ExParValue(new ExParExpression(\r\n\t\t\tExParExpression.GRAY)), \"Dummy bar color\");\r\n\r\n\tpublic ColorSpectrum() {\r\n\t\tsetTitleAndTopic(\"Smooth Color Spectrum\", DISPLAY_TEST_DSP | DEMO);\r\n\t}\r\n\tprivate int nLines;\r\n\tprivate int s1, x1, x2, y1, y2;\r\n\tprivate Color[] spectrum = new Color[(700 - 400) + 1];\r\n\r\n\tprotected int create() {\r\n\t\ts1 = enterDisplayElement(new Bar(Color));\r\n\t\tSpectralDistribution sd;\r\n\t\tSpectralDistribution CIEy = SpectralDistributionFactory.yCMF31();\r\n\t\tint k = 0;\r\n\t\tfor (int i = 400; i <= 700; i++) {\r\n\t\t\tsd = new SpectralDistribution(400, 701, 1, 0.0F);\r\n\t\t\tsd.setValueAt(i, 1.0);\r\n\t\t\tPxlColor c = sd.toXYZ();\r\n\t\t\tc.setY(CIEy.valueAt(i) * 80.0);\r\n\t\t\tspectrum[k++] = c.dev();\r\n\t\t}\r\n\t\treturn s1;\r\n\t}\r\n\r\n\tprotected void computeGeometry() {\r\n\t\tRectangle r = centeredRect(width, height, (int) (4 * width / 5),\r\n\t\t\t\t(int) (height / 4));\r\n\t\tnLines = r.width;\r\n\t\tx1 = r.x;\r\n\t\tx2 = r.x;\r\n\t\ty1 = r.y;\r\n\t\ty2 = r.y + r.height;\r\n\t}\r\n\r\n\t/**\r\n\t * This display has its own paint method for drawing the non-selectable\r\n\t * transition area.\r\n\t */\r\n\tpublic void show(Graphics g) {\r\n\t\tsuper.show(g);\r\n\t\t// Now draw the transition area. Positions have already been computed.\r\n\t\tif (nLines > 0) {\r\n\t\t\tint xx1 = x1;\r\n\t\t\tint xx2 = x2;\r\n\t\t\tfor (int i = 0; i < nLines; i++) {\r\n\t\t\t\tg.setColor(spectrum[(int) ((double) ((spectrum.length - 1)) * i / (double) (nLines - 1))]);\r\n\t\t\t\tg.drawLine(xx1++, y1, xx2++, y2);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n"]]}
{"hexsha": "a8a65c83d2a84f6a2d3c3d8eacc81c82424af4d4", "ext": "java", "lang": "Java", "content": "public class Displ209Test extends DisplaytagCase\n{\n\n    /**\n     * @see org.displaytag.test.DisplaytagCase#getJspName()\n     */\n    public String getJspName()\n    {\n        return \"DISPL-209.jsp\";\n    }\n\n    /**\n     * Check list index/view index values.\n     * @param jspName jsp name, with full path\n     * @throws Exception any axception thrown during test.\n     */\n    public void doTest(String jspName) throws Exception\n    {\n        WebRequest request = new GetMethodWebRequest(jspName);\n        WebResponse response = runner.getResponse(request);\n\n        ParamEncoder encoder = new ParamEncoder(\"table\");\n        request.setParameter(encoder.encodeParameterName(TableTagParameters.PARAMETER_PAGE), \"2\");\n\n        if (log.isDebugEnabled())\n        {\n            log.debug(response.getText());\n        }\n\n        WebTable[] tables = response.getTables();\n        assertEquals(\"Wrong number of tables in result.\", 1, tables.length);\n        assertEquals(\"Wrong number of rows in result.\", 4, tables[0].getRowCount());\n\n        if (log.isDebugEnabled())\n        {\n            log.debug(response.getText());\n        }\n\n        assertEquals(\"Wrong value\", \"a\", tables[0].getCellAsText(1, 0));\n        assertEquals(\"Wrong viewIndex\", \"0\", tables[0].getCellAsText(1, 1));\n        assertEquals(\"Wrong listIndex\", \"0\", tables[0].getCellAsText(1, 2));\n\n        assertEquals(\"Wrong value\", \"b\", tables[0].getCellAsText(2, 0));\n        assertEquals(\"Wrong viewIndex\", \"1\", tables[0].getCellAsText(2, 1));\n        assertEquals(\"Wrong listIndex\", \"1\", tables[0].getCellAsText(2, 2));\n\n        assertEquals(\"Wrong value\", \"c\", tables[0].getCellAsText(3, 0));\n        assertEquals(\"Wrong viewIndex\", \"2\", tables[0].getCellAsText(3, 1));\n        assertEquals(\"Wrong listIndex\", \"2\", tables[0].getCellAsText(3, 2));\n    }\n\n}", "class_id": 0, "repo": "ixsorribas/displaytag-1.2", "file": "displaytag/src/test/java/org/displaytag/jsptests/Displ209Test.java", "last_update_at": "2019-11-24T17:40:45+00:00", "question_id": "a8a65c83d2a84f6a2d3c3d8eacc81c82424af4d4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Displ209Test extends DisplaytagCase\n{\n    /**\n     * @see org.displaytag.test.DisplaytagCase#getJspName()\n     */\n    public String getJspName()\n    {\n        return \"DISPL-209.jsp\";\n    }\n    /**\n     * Check list index/view index values.\n     * @param jspName jsp name, with full path\n     * @throws Exception any axception thrown during test.\n     */\n    public void doTest(String jspName) throws Exception\n    {\n        WebRequest request = new GetMethodWebRequest(jspName);\n        WebResponse response = runner.getResponse(request);\n        ParamEncoder encoder = new ParamEncoder(\"table\");\n        request.setParameter(encoder.encodeParameterName(TableTagParameters.PARAMETER_PAGE), \"2\");\n        if (log.isDebugEnabled())\n        {\n            log.debug(response.getText());\n        }\n        WebTable[] tables = response.getTables();\n        assertEquals(\"Wrong number of tables in result.\", 1, tables.length);\n        assertEquals(\"Wrong number of rows in result.\", 4, tables[0].getRowCount());\n        if (log.isDebugEnabled())\n        {\n            log.debug(response.getText());\n        }\n        assertEquals(\"Wrong value\", \"a\", tables[0].getCellAsText(1, 0));\n        assertEquals(\"Wrong viewIndex\", \"0\", tables[0].getCellAsText(1, 1));\n        assertEquals(\"Wrong listIndex\", \"0\", tables[0].getCellAsText(1, 2));\n        assertEquals(\"Wrong value\", \"b\", tables[0].getCellAsText(2, 0));\n        assertEquals(\"Wrong viewIndex\", \"1\", tables[0].getCellAsText(2, 1));\n        assertEquals(\"Wrong listIndex\", \"1\", tables[0].getCellAsText(2, 2));\n        assertEquals(\"Wrong value\", \"c\", tables[0].getCellAsText(3, 0));\n        assertEquals(\"Wrong viewIndex\", \"2\", tables[0].getCellAsText(3, 1));\n        assertEquals(\"Wrong listIndex\", \"2\", tables[0].getCellAsText(3, 2));\n    }\n"]]}
{"hexsha": "a1da78f2a230ec67db194face8d2ebbbd4923a30", "ext": "java", "lang": "Java", "content": "public class JassFunctions {\n\n    private static final String TAG = \"JassFunctions\";\n\n    //fill CardRecog with the names of all 36 cards\n    public CardRecog[] fillCardNames(){\n        CardRecog myCard;\n        CardRecog[] myCards = new CardRecog[36];\n\n        String cardType = \"Rosen \";\n        for(int i = 0; i < 36; i++){\n            myCard = new CardRecog();\n            myCards[i] = myCard;\n            if(i == 9){\n                cardType = \"Eicheln \";\n            }\n            if(i == 18){\n                cardType = \"Schellen \";\n            }\n            if(i == 27){\n                cardType = \"Schilten \";\n            }\n\n            if(i % 9 < 5) {\n                myCards[i].setCardTitle(cardType + ((i%9) + 6));\n                myCards[i].setConfidence(0);\n            }\n            else if(i % 9 == 5){\n                myCards[i].setCardTitle(cardType + \"Under\");\n                myCards[i].setConfidence(0);\n            }\n            else if(i % 9 == 6){\n                myCards[i].setCardTitle(cardType + \"Ober\");\n                myCards[i].setConfidence(0);\n            }\n            else if(i % 9 == 7){\n                myCards[i].setCardTitle(cardType + \"K\u00f6nig\");\n                myCards[i].setConfidence(0);\n            }\n            else if(i % 9 == 8){\n                myCards[i].setCardTitle(cardType + \"Ass\");\n                myCards[i].setConfidence(0);\n            }\n            Log.d(TAG, myCards[i].getCardTitle());\n        }\n//        Test data for model from example app\n\n        myCards[27].setCardTitle(\"chair\");\n        myCards[28].setCardTitle(\"backpack\");\n        myCards[29].setCardTitle(\"book\");\n        myCards[30].setCardTitle(\"clock\");\n        myCards[31].setCardTitle(\"scissors\");\n        myCards[32].setCardTitle(\"mouse\");\n        myCards[33].setCardTitle(\"keyboard\");\n        myCards[34].setCardTitle(\"bed\");\n        myCards[35].setCardTitle(\"tv\");\n\n        return myCards;\n    }\n\n    //convert the Strings of the nine recognised cards into the norm card array (local point of view) used by the RNN\n    public int[] getNormArray(String[] recCards){\n        int[] normArray = new int[37];\n        CardRecog[] cardsNamed = fillCardNames();\n\n        //36 cards + trump\n        for (int i = 0; i < 37; i++){\n            normArray[i] = 0;\n        }\n\n        //convert recognised cards into norm array\n        for (int a = 0; a < 9; a++){\n            for (int b = 0; b < 36; b++){\n                if(cardsNamed[b].getCardTitle().equals(recCards[a])){\n                    normArray[b] = 1;\n                    break;\n                }\n            }\n        }\n        return normArray;\n    }\n\n\n}", "class_id": 0, "repo": "simi48/Ef-If_Jassen", "file": "android/app/src/main/java/org/tensorflow/lite/examples/detection/env/JassFunctions.java", "last_update_at": "2019-04-30T15:22:36+00:00", "question_id": "a1da78f2a230ec67db194face8d2ebbbd4923a30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class JassFunctions {\n    private static final String TAG = \"JassFunctions\";\n    //fill CardRecog with the names of all 36 cards\n    public CardRecog[] fillCardNames(){\n        CardRecog myCard;\n        CardRecog[] myCards = new CardRecog[36];\n        String cardType = \"Rosen \";\n        for(int i = 0; i < 36; i++){\n            myCard = new CardRecog();\n            myCards[i] = myCard;\n            if(i == 9){\n                cardType = \"Eicheln \";\n            }\n            if(i == 18){\n                cardType = \"Schellen \";\n            }\n            if(i == 27){\n                cardType = \"Schilten \";\n            }\n            if(i % 9 < 5) {\n                myCards[i].setCardTitle(cardType + ((i%9) + 6));\n                myCards[i].setConfidence(0);\n            }\n            else if(i % 9 == 5){\n                myCards[i].setCardTitle(cardType + \"Under\");\n                myCards[i].setConfidence(0);\n            }\n            else if(i % 9 == 6){\n                myCards[i].setCardTitle(cardType + \"Ober\");\n                myCards[i].setConfidence(0);\n            }\n            else if(i % 9 == 7){\n                myCards[i].setCardTitle(cardType + \"K\u00f6nig\");\n                myCards[i].setConfidence(0);\n            }\n            else if(i % 9 == 8){\n                myCards[i].setCardTitle(cardType + \"Ass\");\n                myCards[i].setConfidence(0);\n            }\n            Log.d(TAG, myCards[i].getCardTitle());\n        }\n//        Test data for model from example app\n        myCards[27].setCardTitle(\"chair\");\n        myCards[28].setCardTitle(\"backpack\");\n        myCards[29].setCardTitle(\"book\");\n        myCards[30].setCardTitle(\"clock\");\n        myCards[31].setCardTitle(\"scissors\");\n        myCards[32].setCardTitle(\"mouse\");\n        myCards[33].setCardTitle(\"keyboard\");\n        myCards[34].setCardTitle(\"bed\");\n        myCards[35].setCardTitle(\"tv\");\n        return myCards;\n    }\n    //convert the Strings of the nine recognised cards into the norm card array (local point of view) used by the RNN\n    public int[] getNormArray(String[] recCards){\n        int[] normArray = new int[37];\n        CardRecog[] cardsNamed = fillCardNames();\n        //36 cards + trump\n        for (int i = 0; i < 37; i++){\n            normArray[i] = 0;\n        }\n        //convert recognised cards into norm array\n        for (int a = 0; a < 9; a++){\n            for (int b = 0; b < 36; b++){\n                if(cardsNamed[b].getCardTitle().equals(recCards[a])){\n                    normArray[b] = 1;\n                    break;\n                }\n            }\n        }\n        return normArray;\n    }\n"]]}
{"hexsha": "da20f5758911f23636511305d40b1855af9c2d22", "ext": "java", "lang": "Java", "content": "public class RegisterDAOImpl implements lk.ijse.dep.akashStainlessSteel.dao.custom.RegisterDAO {\n\n\n    @Override\n    public boolean saveRegister(RegisterEntity registerEntity) throws Exception {\n        return CrudUtil.execute(\"INSERT INTO register VALUES (?,?,?)\",\n                registerEntity.getUserType(),\n                registerEntity.getUserName(),\n                registerEntity.getPassword()\n        );\n    }\n\n    @Override\n    public boolean deleteRegister(String userName) throws Exception {\n        CrudUtil.execute(\"DELETE FROM register WHERE userName = ?\",userName);\n        return false;\n    }\n\n    @Override\n    public boolean updateRegister(RegisterEntity registerEntity) throws Exception {\n        return CrudUtil.execute(\"UPDATE register SET password = ?,userType = ?WHERE userName =?\" ,\n                registerEntity.getPassword(),\n                registerEntity.getUserType(),\n                registerEntity.getUserName()\n\n        );\n    }\n\n    @Override\n    public List<RegisterEntity> findAllRegisters() throws Exception {\n        ResultSet resultSet = CrudUtil.execute(\"SELECT * FROM register\");\n        List<RegisterEntity> alRegisters = new ArrayList<>();\n        while (resultSet.next()){\n            alRegisters.add(new RegisterEntity(\n                    resultSet.getString(1),\n                    resultSet.getString(2),\n                    resultSet.getString(3)\n            ));\n        }\n        return alRegisters;\n    }\n\n    @Override\n    public RegisterEntity findRegister(String userName) throws Exception {\n        ResultSet resultSet = CrudUtil.execute(\"SELECT * FROM register WHERE userName =?\",userName);\n        if(resultSet.next()){\n            return new RegisterEntity(\n                    resultSet.getString(1),\n                    resultSet.getString(2),\n                    resultSet.getString(3)\n            );\n        }\n        return null;\n    }\n}", "class_id": 0, "repo": "ThilinaDGunasekara/ASSMS", "file": "src/lk/ijse/dep/akashStainlessSteel/dao/custom/impl/RegisterDAOImpl.java", "last_update_at": "2019-12-02T15:22:34+00:00", "question_id": "da20f5758911f23636511305d40b1855af9c2d22", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RegisterDAOImpl implements lk.ijse.dep.akashStainlessSteel.dao.custom.RegisterDAO {\n    @Override\n    public boolean saveRegister(RegisterEntity registerEntity) throws Exception {\n        return CrudUtil.execute(\"INSERT INTO register VALUES (?,?,?)\",\n                registerEntity.getUserType(),\n                registerEntity.getUserName(),\n                registerEntity.getPassword()\n        );\n    }\n    @Override\n    public boolean deleteRegister(String userName) throws Exception {\n        CrudUtil.execute(\"DELETE FROM register WHERE userName = ?\",userName);\n        return false;\n    }\n    @Override\n    public boolean updateRegister(RegisterEntity registerEntity) throws Exception {\n        return CrudUtil.execute(\"UPDATE register SET password = ?,userType = ?WHERE userName =?\" ,\n                registerEntity.getPassword(),\n                registerEntity.getUserType(),\n                registerEntity.getUserName()\n        );\n    }\n    @Override\n    public List<RegisterEntity> findAllRegisters() throws Exception {\n        ResultSet resultSet = CrudUtil.execute(\"SELECT * FROM register\");\n        List<RegisterEntity> alRegisters = new ArrayList<>();\n        while (resultSet.next()){\n            alRegisters.add(new RegisterEntity(\n                    resultSet.getString(1),\n                    resultSet.getString(2),\n                    resultSet.getString(3)\n            ));\n        }\n        return alRegisters;\n    }\n    @Override\n    public RegisterEntity findRegister(String userName) throws Exception {\n        ResultSet resultSet = CrudUtil.execute(\"SELECT * FROM register WHERE userName =?\",userName);\n        if(resultSet.next()){\n            return new RegisterEntity(\n                    resultSet.getString(1),\n                    resultSet.getString(2),\n                    resultSet.getString(3)\n            );\n        }\n        return null;\n    }\n"]]}
{"hexsha": "bcd7fd2887e9ee1b297d72db7f284a482dd320ac", "ext": "java", "lang": "Java", "content": "public final class TagTest {\n\n    @Test\n    public void test() throws IOException {\n        final CompoundTag compoundTag = new CompoundTag();\n\n        // Boolean value\n        final BooleanTag booleanTag = new BooleanTag(true);\n        compoundTag.put(\"A\", booleanTag);\n\n        // Boolean array value\n        final BooleanArrayTag booleanArrayTag = new BooleanArrayTag(true, false, true, true);\n        compoundTag.put(\"B\", booleanArrayTag);\n\n        // Byte value\n        final ByteTag byteTag = new ByteTag((byte) 5);\n        compoundTag.put(\"C\", byteTag);\n\n        // Byte array value\n        final ByteArrayTag byteArrayTag = new ByteArrayTag((byte) 6, (byte) 9, (byte) 20, (byte) 30);\n        compoundTag.put(\"D\", byteArrayTag);\n\n        // Char value\n        final CharTag charTag = new CharTag('C');\n        compoundTag.put(\"E\", charTag);\n\n        // Char array value\n        final CharArrayTag charArrayTag = new CharArrayTag('A', 'B', 'C', 'D');\n        compoundTag.put(\"F\", charArrayTag);\n\n        // Double value\n        final DoubleTag doubleTag = new DoubleTag(7.3);\n        compoundTag.put(\"G\", doubleTag);\n\n        // Double array value\n        final DoubleArrayTag doubleArrayTag = new DoubleArrayTag(7.3, 7.4, 5.3, 1.2);\n        compoundTag.put(\"H\", doubleArrayTag);\n\n        compoundTag.put(\"I\", new FloatTag(5.1f));\n        compoundTag.put(\"J\", new FloatArrayTag(5.1f, 5.32f));\n        compoundTag.put(\"K\", new IntTag(3));\n        compoundTag.put(\"L\", new IntArrayTag(30, 50, 60, 80));\n        compoundTag.put(\"M\", new LongTag(40));\n        compoundTag.put(\"N\", new LongArrayTag(30, 60));\n        compoundTag.put(\"O\", new ShortTag((short) 3));\n        compoundTag.put(\"P\", new ShortArrayTag((short) 3, (short) 7));\n        compoundTag.put(\"Q\", new StringTag(\"Test\"));\n        compoundTag.put(\"R\", new StringArrayTag(\"Haha\", \"Hehe\", \"Hoho\"));\n        final CompoundTag compoundTag1 = new CompoundTag();\n        compoundTag1.put(\"A\", new IntArrayTag(1000));\n        compoundTag.put(\"S\", compoundTag1);\n        final ListTag<IntTag> listTag = new ListTag<>();\n        listTag.add(new IntTag(20));\n        listTag.add(new IntTag(30));\n        compoundTag.put(\"T\", listTag);\n        final ListTag<DoubleArrayTag> listTag1 = new ListTag<>();\n        listTag1.add(new DoubleArrayTag(7.3, 7.4));\n        listTag1.add(new DoubleArrayTag(5.3, 1.2));\n        compoundTag.put(\"U\", listTag1);\n        final MapTag<IntTag, DoubleTag> intToDoubleMapTag = new MapTag<>();\n        intToDoubleMapTag.put(new IntTag(100), new DoubleTag(253.98));\n        intToDoubleMapTag.put(new IntTag(20), new DoubleTag(96035.047821));\n        compoundTag.put(\"V\", intToDoubleMapTag);\n        final MapTag<IntTag, CharTag> intToCharMapTag = new MapTag<>();\n        intToCharMapTag.put(new IntTag(100), new CharTag('B'));\n        intToCharMapTag.put(new IntTag(20), new CharTag('Q'));\n        compoundTag.put(\"W\", intToCharMapTag);\n        final MapTag<IntTag, Tag<?>> intToMixedMapTag = new MapTag<>();\n        intToMixedMapTag.put(new IntTag(100), new CharTag('B'));\n        intToMixedMapTag.put(new IntTag(20), new StringTag(\"Hallo\"));\n        intToMixedMapTag.put(new IntTag(10), new LongTag(9L));\n        intToMixedMapTag.put(new IntTag(12), new CharArrayTag('H', 'O', 'L', 'A'));\n        compoundTag.put(\"X\", intToMixedMapTag);\n\n        final NbtTagOutputStream nos = new NbtTagOutputStream(\n                new GZIPOutputStream(Files.newOutputStream(Paths.get(\"test.nbt\"))));\n        nos.write(compoundTag);\n        nos.flush();\n        nos.close();\n\n        final NbtTagInputStream nis = new NbtTagInputStream(\n                new GZIPInputStream(Files.newInputStream(Paths.get(\"test.nbt\"))));\n        final CompoundTag newCompoundTag = (CompoundTag) nis.read();\n        System.out.println(newCompoundTag);\n        nis.close();\n\n        // Boolean value\n        assertEquals(booleanTag, newCompoundTag.get(\"A\"));\n        assertEquals(booleanTag.booleanValue(), newCompoundTag.getBoolean(\"A\"));\n\n        // Boolean array value\n        assertEquals(booleanArrayTag, newCompoundTag.get(\"B\"));\n\n        // Byte value\n        assertEquals(byteTag, newCompoundTag.get(\"C\"));\n        assertEquals(byteTag.byteValue(), newCompoundTag.getByte(\"C\"));\n\n        // Byte array value\n        assertEquals(byteArrayTag, newCompoundTag.get(\"D\"));\n\n        // Char value\n        assertEquals(charTag, newCompoundTag.get(\"E\"));\n        assertEquals(charTag.charValue(), newCompoundTag.getChar(\"E\"));\n\n        // Char array value\n        assertEquals(charArrayTag, newCompoundTag.get(\"F\"));\n\n        // Double value\n        assertEquals(doubleTag, newCompoundTag.get(\"G\"));\n        assertEquals(doubleTag.doubleValue(), newCompoundTag.getDouble(\"G\"), 0.00000000001);\n\n        // Double array value\n        assertEquals(doubleArrayTag, newCompoundTag.get(\"H\"));\n\n        // The complete compound tags\n        assertEquals(compoundTag, newCompoundTag);\n    }\n}", "class_id": 0, "repo": "LanternPowered/LanternNBT", "file": "nbt/src/test/java/org/lanternpowered/nbt/TagTest.java", "last_update_at": "2019-01-22T21:02:47+00:00", "question_id": "bcd7fd2887e9ee1b297d72db7f284a482dd320ac", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class TagTest {\n    @Test\n    public void test() throws IOException {\n        final CompoundTag compoundTag = new CompoundTag();\n        // Boolean value\n        final BooleanTag booleanTag = new BooleanTag(true);\n        compoundTag.put(\"A\", booleanTag);\n        // Boolean array value\n        final BooleanArrayTag booleanArrayTag = new BooleanArrayTag(true, false, true, true);\n        compoundTag.put(\"B\", booleanArrayTag);\n        // Byte value\n        final ByteTag byteTag = new ByteTag((byte) 5);\n        compoundTag.put(\"C\", byteTag);\n        // Byte array value\n        final ByteArrayTag byteArrayTag = new ByteArrayTag((byte) 6, (byte) 9, (byte) 20, (byte) 30);\n        compoundTag.put(\"D\", byteArrayTag);\n        // Char value\n        final CharTag charTag = new CharTag('C');\n        compoundTag.put(\"E\", charTag);\n        // Char array value\n        final CharArrayTag charArrayTag = new CharArrayTag('A', 'B', 'C', 'D');\n        compoundTag.put(\"F\", charArrayTag);\n        // Double value\n        final DoubleTag doubleTag = new DoubleTag(7.3);\n        compoundTag.put(\"G\", doubleTag);\n        // Double array value\n        final DoubleArrayTag doubleArrayTag = new DoubleArrayTag(7.3, 7.4, 5.3, 1.2);\n        compoundTag.put(\"H\", doubleArrayTag);\n        compoundTag.put(\"I\", new FloatTag(5.1f));\n        compoundTag.put(\"J\", new FloatArrayTag(5.1f, 5.32f));\n        compoundTag.put(\"K\", new IntTag(3));\n        compoundTag.put(\"L\", new IntArrayTag(30, 50, 60, 80));\n        compoundTag.put(\"M\", new LongTag(40));\n        compoundTag.put(\"N\", new LongArrayTag(30, 60));\n        compoundTag.put(\"O\", new ShortTag((short) 3));\n        compoundTag.put(\"P\", new ShortArrayTag((short) 3, (short) 7));\n        compoundTag.put(\"Q\", new StringTag(\"Test\"));\n        compoundTag.put(\"R\", new StringArrayTag(\"Haha\", \"Hehe\", \"Hoho\"));\n        final CompoundTag compoundTag1 = new CompoundTag();\n        compoundTag1.put(\"A\", new IntArrayTag(1000));\n        compoundTag.put(\"S\", compoundTag1);\n        final ListTag<IntTag> listTag = new ListTag<>();\n        listTag.add(new IntTag(20));\n        listTag.add(new IntTag(30));\n        compoundTag.put(\"T\", listTag);\n        final ListTag<DoubleArrayTag> listTag1 = new ListTag<>();\n        listTag1.add(new DoubleArrayTag(7.3, 7.4));\n        listTag1.add(new DoubleArrayTag(5.3, 1.2));\n        compoundTag.put(\"U\", listTag1);\n        final MapTag<IntTag, DoubleTag> intToDoubleMapTag = new MapTag<>();\n        intToDoubleMapTag.put(new IntTag(100), new DoubleTag(253.98));\n        intToDoubleMapTag.put(new IntTag(20), new DoubleTag(96035.047821));\n        compoundTag.put(\"V\", intToDoubleMapTag);\n        final MapTag<IntTag, CharTag> intToCharMapTag = new MapTag<>();\n        intToCharMapTag.put(new IntTag(100), new CharTag('B'));\n        intToCharMapTag.put(new IntTag(20), new CharTag('Q'));\n        compoundTag.put(\"W\", intToCharMapTag);\n        final MapTag<IntTag, Tag<?>> intToMixedMapTag = new MapTag<>();\n        intToMixedMapTag.put(new IntTag(100), new CharTag('B'));\n        intToMixedMapTag.put(new IntTag(20), new StringTag(\"Hallo\"));\n        intToMixedMapTag.put(new IntTag(10), new LongTag(9L));\n        intToMixedMapTag.put(new IntTag(12), new CharArrayTag('H', 'O', 'L', 'A'));\n        compoundTag.put(\"X\", intToMixedMapTag);\n        final NbtTagOutputStream nos = new NbtTagOutputStream(\n                new GZIPOutputStream(Files.newOutputStream(Paths.get(\"test.nbt\"))));\n        nos.write(compoundTag);\n        nos.flush();\n        nos.close();\n        final NbtTagInputStream nis = new NbtTagInputStream(\n                new GZIPInputStream(Files.newInputStream(Paths.get(\"test.nbt\"))));\n        final CompoundTag newCompoundTag = (CompoundTag) nis.read();\n        System.out.println(newCompoundTag);\n        nis.close();\n        // Boolean value\n        assertEquals(booleanTag, newCompoundTag.get(\"A\"));\n        assertEquals(booleanTag.booleanValue(), newCompoundTag.getBoolean(\"A\"));\n        // Boolean array value\n        assertEquals(booleanArrayTag, newCompoundTag.get(\"B\"));\n        // Byte value\n        assertEquals(byteTag, newCompoundTag.get(\"C\"));\n        assertEquals(byteTag.byteValue(), newCompoundTag.getByte(\"C\"));\n        // Byte array value\n        assertEquals(byteArrayTag, newCompoundTag.get(\"D\"));\n        // Char value\n        assertEquals(charTag, newCompoundTag.get(\"E\"));\n        assertEquals(charTag.charValue(), newCompoundTag.getChar(\"E\"));\n        // Char array value\n        assertEquals(charArrayTag, newCompoundTag.get(\"F\"));\n        // Double value\n        assertEquals(doubleTag, newCompoundTag.get(\"G\"));\n        assertEquals(doubleTag.doubleValue(), newCompoundTag.getDouble(\"G\"), 0.00000000001);\n        // Double array value\n        assertEquals(doubleArrayTag, newCompoundTag.get(\"H\"));\n        // The complete compound tags\n        assertEquals(compoundTag, newCompoundTag);\n    }\n"]]}
{"hexsha": "313b20e3f83814f5165f90e1f4b7e6b111cc48a6", "ext": "java", "lang": "Java", "content": "public class SchemaTranslation {\n\n  private static final BiMap<TypeName, RunnerApi.Schema.AtomicType> ATOMIC_TYPE_MAPPING =\n      ImmutableBiMap.<TypeName, RunnerApi.Schema.AtomicType>builder()\n          .put(TypeName.BYTE, RunnerApi.Schema.AtomicType.BYTE)\n          .put(TypeName.INT16, RunnerApi.Schema.AtomicType.INT16)\n          .put(TypeName.INT32, RunnerApi.Schema.AtomicType.INT32)\n          .put(TypeName.INT64, RunnerApi.Schema.AtomicType.INT64)\n          .put(TypeName.FLOAT, RunnerApi.Schema.AtomicType.FLOAT)\n          .put(TypeName.DOUBLE, RunnerApi.Schema.AtomicType.DOUBLE)\n          .put(TypeName.STRING, RunnerApi.Schema.AtomicType.STRING)\n          .put(TypeName.BOOLEAN, RunnerApi.Schema.AtomicType.BOOLEAN)\n          .put(TypeName.BYTES, RunnerApi.Schema.AtomicType.BYTES)\n          .build();\n\n  private static final String URN_BEAM_LOGICAL_DATETIME = \"beam:fieldtype:datetime\";\n  private static final String URN_BEAM_LOGICAL_DECIMAL = \"beam:fieldtype:decimal\";\n\n  public static RunnerApi.Schema toProto(Schema schema) {\n    String uuid = schema.getUUID() != null ? schema.getUUID().toString() : \"\";\n    RunnerApi.Schema.Builder builder = RunnerApi.Schema.newBuilder().setId(uuid);\n    for (Field field : schema.getFields()) {\n      RunnerApi.Schema.Field protoField =\n          toProto(\n              field,\n              schema.indexOf(field.getName()),\n              schema.getEncodingPositions().get(field.getName()));\n      builder.addFields(protoField);\n    }\n    return builder.build();\n  }\n\n  private static RunnerApi.Schema.Field toProto(Field field, int fieldId, int position) {\n    return RunnerApi.Schema.Field.newBuilder()\n        .setName(field.getName())\n        .setDescription(field.getDescription())\n        .setType(toProto(field.getType()))\n        .setId(fieldId)\n        .setEncodingPosition(position)\n        .build();\n  }\n\n  private static RunnerApi.Schema.FieldType toProto(FieldType fieldType) {\n    RunnerApi.Schema.FieldType.Builder builder = RunnerApi.Schema.FieldType.newBuilder();\n    switch (fieldType.getTypeName()) {\n      case ROW:\n        builder.setRowType(\n            RunnerApi.Schema.RowType.newBuilder().setSchema(toProto(fieldType.getRowSchema())));\n        break;\n\n      case ARRAY:\n        builder.setArrayType(\n            RunnerApi.Schema.ArrayType.newBuilder()\n                .setElementType(toProto(fieldType.getCollectionElementType())));\n        break;\n\n      case MAP:\n        builder.setMapType(\n            RunnerApi.Schema.MapType.newBuilder()\n                .setKeyType(toProto(fieldType.getMapKeyType()))\n                .setValueType(toProto(fieldType.getMapValueType()))\n                .build());\n        break;\n\n      case LOGICAL_TYPE:\n        LogicalType logicalType = fieldType.getLogicalType();\n        builder.setLogicalType(\n            RunnerApi.Schema.LogicalType.newBuilder()\n                .setUrn(logicalType.getIdentifier())\n                .setArgs(logicalType.getArgument())\n                .setRepresentation(toProto(logicalType.getBaseType()))\n                .build());\n        break;\n        // Special-case for DATETIME and DECIMAL which are logical types in portable representation,\n        // but not yet in Java. (BEAM-7554)\n      case DATETIME:\n        builder.setLogicalType(\n            RunnerApi.Schema.LogicalType.newBuilder()\n                .setUrn(URN_BEAM_LOGICAL_DATETIME)\n                .setRepresentation(toProto(FieldType.INT64))\n                .build());\n        break;\n      case DECIMAL:\n        builder.setLogicalType(\n            RunnerApi.Schema.LogicalType.newBuilder()\n                .setUrn(URN_BEAM_LOGICAL_DECIMAL)\n                .setRepresentation(toProto(FieldType.BYTES))\n                .build());\n        break;\n      default:\n        builder.setAtomicType(ATOMIC_TYPE_MAPPING.get(fieldType.getTypeName()));\n        break;\n    }\n    builder.setNullable(fieldType.getNullable());\n    return builder.build();\n  }\n\n  public static Schema fromProto(RunnerApi.Schema protoSchema) {\n    Schema.Builder builder = Schema.builder();\n    Map<String, Integer> encodingLocationMap = Maps.newHashMap();\n    for (RunnerApi.Schema.Field protoField : protoSchema.getFieldsList()) {\n      Field field = fieldFromProto(protoField);\n      builder.addField(field);\n      encodingLocationMap.put(protoField.getName(), protoField.getEncodingPosition());\n    }\n    Schema schema = builder.build();\n    schema.setEncodingPositions(encodingLocationMap);\n    if (!protoSchema.getId().isEmpty()) {\n      schema.setUUID(UUID.fromString(protoSchema.getId()));\n    }\n\n    return schema;\n  }\n\n  private static Field fieldFromProto(RunnerApi.Schema.Field protoField) {\n    return Field.of(protoField.getName(), fieldTypeFromProto(protoField.getType()))\n        .withDescription(protoField.getDescription());\n  }\n\n  private static FieldType fieldTypeFromProto(RunnerApi.Schema.FieldType protoFieldType) {\n    FieldType fieldType;\n    switch (protoFieldType.getTypeInfoCase()) {\n      case ATOMIC_TYPE:\n        TypeName typeName = ATOMIC_TYPE_MAPPING.inverse().get(protoFieldType.getAtomicType());\n        fieldType = FieldType.of(typeName);\n        break;\n      case ROW_TYPE:\n        fieldType = FieldType.row(fromProto(protoFieldType.getRowType().getSchema()));\n        break;\n      case ARRAY_TYPE:\n        fieldType =\n            FieldType.array(fieldTypeFromProto(protoFieldType.getArrayType().getElementType()));\n        break;\n      case MAP_TYPE:\n        fieldType =\n            FieldType.map(\n                fieldTypeFromProto(protoFieldType.getMapType().getKeyType()),\n                fieldTypeFromProto(protoFieldType.getMapType().getValueType()));\n        break;\n      case LOGICAL_TYPE:\n        // Special-case for DATETIME and DECIMAL which are logical types in portable representation,\n        // but not yet in Java. (BEAM-7554)\n        String urn = protoFieldType.getLogicalType().getUrn();\n        if (urn.equals(URN_BEAM_LOGICAL_DATETIME)) {\n          fieldType = FieldType.DATETIME;\n        } else if (urn.equals(URN_BEAM_LOGICAL_DECIMAL)) {\n          fieldType = FieldType.DECIMAL;\n        } else {\n          // TODO: Look up logical type class by URN.\n          throw new IllegalArgumentException(\"Decoding logical types is not yet supported.\");\n        }\n        break;\n      default:\n        throw new IllegalArgumentException(\n            \"Unexpected type_info: \" + protoFieldType.getTypeInfoCase());\n    }\n\n    if (protoFieldType.getNullable()) {\n      fieldType = fieldType.withNullable(true);\n    }\n    return fieldType;\n  }\n}", "class_id": 0, "repo": "dustin12/beam", "file": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/SchemaTranslation.java", "last_update_at": "2019-10-26T12:26:16+00:00", "question_id": "313b20e3f83814f5165f90e1f4b7e6b111cc48a6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SchemaTranslation {\n  private static final BiMap<TypeName, RunnerApi.Schema.AtomicType> ATOMIC_TYPE_MAPPING =\n      ImmutableBiMap.<TypeName, RunnerApi.Schema.AtomicType>builder()\n          .put(TypeName.BYTE, RunnerApi.Schema.AtomicType.BYTE)\n          .put(TypeName.INT16, RunnerApi.Schema.AtomicType.INT16)\n          .put(TypeName.INT32, RunnerApi.Schema.AtomicType.INT32)\n          .put(TypeName.INT64, RunnerApi.Schema.AtomicType.INT64)\n          .put(TypeName.FLOAT, RunnerApi.Schema.AtomicType.FLOAT)\n          .put(TypeName.DOUBLE, RunnerApi.Schema.AtomicType.DOUBLE)\n          .put(TypeName.STRING, RunnerApi.Schema.AtomicType.STRING)\n          .put(TypeName.BOOLEAN, RunnerApi.Schema.AtomicType.BOOLEAN)\n          .put(TypeName.BYTES, RunnerApi.Schema.AtomicType.BYTES)\n          .build();\n  private static final String URN_BEAM_LOGICAL_DATETIME = \"beam:fieldtype:datetime\";\n  private static final String URN_BEAM_LOGICAL_DECIMAL = \"beam:fieldtype:decimal\";\n  public static RunnerApi.Schema toProto(Schema schema) {\n    String uuid = schema.getUUID() != null ? schema.getUUID().toString() : \"\";\n    RunnerApi.Schema.Builder builder = RunnerApi.Schema.newBuilder().setId(uuid);\n    for (Field field : schema.getFields()) {\n      RunnerApi.Schema.Field protoField =\n          toProto(\n              field,\n              schema.indexOf(field.getName()),\n              schema.getEncodingPositions().get(field.getName()));\n      builder.addFields(protoField);\n    }\n    return builder.build();\n  }\n  private static RunnerApi.Schema.Field toProto(Field field, int fieldId, int position) {\n    return RunnerApi.Schema.Field.newBuilder()\n        .setName(field.getName())\n        .setDescription(field.getDescription())\n        .setType(toProto(field.getType()))\n        .setId(fieldId)\n        .setEncodingPosition(position)\n        .build();\n  }\n  private static RunnerApi.Schema.FieldType toProto(FieldType fieldType) {\n    RunnerApi.Schema.FieldType.Builder builder = RunnerApi.Schema.FieldType.newBuilder();\n    switch (fieldType.getTypeName()) {\n      case ROW:\n        builder.setRowType(\n            RunnerApi.Schema.RowType.newBuilder().setSchema(toProto(fieldType.getRowSchema())));\n        break;\n      case ARRAY:\n        builder.setArrayType(\n            RunnerApi.Schema.ArrayType.newBuilder()\n                .setElementType(toProto(fieldType.getCollectionElementType())));\n        break;\n      case MAP:\n        builder.setMapType(\n            RunnerApi.Schema.MapType.newBuilder()\n                .setKeyType(toProto(fieldType.getMapKeyType()))\n                .setValueType(toProto(fieldType.getMapValueType()))\n                .build());\n        break;\n      case LOGICAL_TYPE:\n        LogicalType logicalType = fieldType.getLogicalType();\n        builder.setLogicalType(\n            RunnerApi.Schema.LogicalType.newBuilder()\n                .setUrn(logicalType.getIdentifier())\n                .setArgs(logicalType.getArgument())\n                .setRepresentation(toProto(logicalType.getBaseType()))\n                .build());\n        break;\n        // Special-case for DATETIME and DECIMAL which are logical types in portable representation,\n        // but not yet in Java. (BEAM-7554)\n      case DATETIME:\n        builder.setLogicalType(\n            RunnerApi.Schema.LogicalType.newBuilder()\n                .setUrn(URN_BEAM_LOGICAL_DATETIME)\n                .setRepresentation(toProto(FieldType.INT64))\n                .build());\n        break;\n      case DECIMAL:\n        builder.setLogicalType(\n            RunnerApi.Schema.LogicalType.newBuilder()\n                .setUrn(URN_BEAM_LOGICAL_DECIMAL)\n                .setRepresentation(toProto(FieldType.BYTES))\n                .build());\n        break;\n      default:\n        builder.setAtomicType(ATOMIC_TYPE_MAPPING.get(fieldType.getTypeName()));\n        break;\n    }\n    builder.setNullable(fieldType.getNullable());\n    return builder.build();\n  }\n  public static Schema fromProto(RunnerApi.Schema protoSchema) {\n    Schema.Builder builder = Schema.builder();\n    Map<String, Integer> encodingLocationMap = Maps.newHashMap();\n    for (RunnerApi.Schema.Field protoField : protoSchema.getFieldsList()) {\n      Field field = fieldFromProto(protoField);\n      builder.addField(field);\n      encodingLocationMap.put(protoField.getName(), protoField.getEncodingPosition());\n    }\n    Schema schema = builder.build();\n    schema.setEncodingPositions(encodingLocationMap);\n    if (!protoSchema.getId().isEmpty()) {\n      schema.setUUID(UUID.fromString(protoSchema.getId()));\n    }\n    return schema;\n  }\n  private static Field fieldFromProto(RunnerApi.Schema.Field protoField) {\n    return Field.of(protoField.getName(), fieldTypeFromProto(protoField.getType()))\n        .withDescription(protoField.getDescription());\n  }\n  private static FieldType fieldTypeFromProto(RunnerApi.Schema.FieldType protoFieldType) {\n    FieldType fieldType;\n    switch (protoFieldType.getTypeInfoCase()) {\n      case ATOMIC_TYPE:\n        TypeName typeName = ATOMIC_TYPE_MAPPING.inverse().get(protoFieldType.getAtomicType());\n        fieldType = FieldType.of(typeName);\n        break;\n      case ROW_TYPE:\n        fieldType = FieldType.row(fromProto(protoFieldType.getRowType().getSchema()));\n        break;\n      case ARRAY_TYPE:\n        fieldType =\n            FieldType.array(fieldTypeFromProto(protoFieldType.getArrayType().getElementType()));\n        break;\n      case MAP_TYPE:\n        fieldType =\n            FieldType.map(\n                fieldTypeFromProto(protoFieldType.getMapType().getKeyType()),\n                fieldTypeFromProto(protoFieldType.getMapType().getValueType()));\n        break;\n      case LOGICAL_TYPE:\n        // Special-case for DATETIME and DECIMAL which are logical types in portable representation,\n        // but not yet in Java. (BEAM-7554)\n        String urn = protoFieldType.getLogicalType().getUrn();\n        if (urn.equals(URN_BEAM_LOGICAL_DATETIME)) {\n          fieldType = FieldType.DATETIME;\n        } else if (urn.equals(URN_BEAM_LOGICAL_DECIMAL)) {\n          fieldType = FieldType.DECIMAL;\n        } else {\n          // TODO: Look up logical type class by URN.\n          throw new IllegalArgumentException(\"Decoding logical types is not yet supported.\");\n        }\n        break;\n      default:\n        throw new IllegalArgumentException(\n            \"Unexpected type_info: \" + protoFieldType.getTypeInfoCase());\n    }\n    if (protoFieldType.getNullable()) {\n      fieldType = fieldType.withNullable(true);\n    }\n    return fieldType;\n  }\n"]]}
{"hexsha": "d4cf654c76f1480cfb73edb861dd43f6b35a7a4e", "ext": "java", "lang": "Java", "content": "public class FindMode {\n\n    private static void recursion(TreeNode root, Map<Integer, Integer> m, int maxCount) {\n        if (root == null) return;\n        m.put(root.val, 1 + m.getOrDefault(root.val, 0));\n        recursion(root.left, m, maxCount);\n        recursion(root.right, m, maxCount);\n    }\n\n    private static int[] findMode(TreeNode root) {\n        int maxCount = 0;\n        Map<Integer, Integer> m = new HashMap<>();\n        recursion(root, m, maxCount);\n        List<Integer> r = new ArrayList<>();\n        for (Integer k: m.keySet()) {\n            if (m.get(k) > maxCount) {\n                maxCount = m.get(k);\n            }\n        }\n        for (Integer k: m.keySet()) {\n            if (m.get(k) == maxCount) {\n                r.add(k);\n            }\n        }\n        int[] result = new int[r.size()];\n        for (int i=0; i<r.size(); i++) {\n            result[i] = r.get(i);\n        }\n        return result;\n    }\n\n}", "class_id": 0, "repo": "guerbai/leetcode-with-java", "file": "src/main/java/guerbai/f501_550/FindMode.java", "last_update_at": "2019-01-05T06:38:53+00:00", "question_id": "d4cf654c76f1480cfb73edb861dd43f6b35a7a4e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FindMode {\n    private static void recursion(TreeNode root, Map<Integer, Integer> m, int maxCount) {\n        if (root == null) return;\n        m.put(root.val, 1 + m.getOrDefault(root.val, 0));\n        recursion(root.left, m, maxCount);\n        recursion(root.right, m, maxCount);\n    }\n    private static int[] findMode(TreeNode root) {\n        int maxCount = 0;\n        Map<Integer, Integer> m = new HashMap<>();\n        recursion(root, m, maxCount);\n        List<Integer> r = new ArrayList<>();\n        for (Integer k: m.keySet()) {\n            if (m.get(k) > maxCount) {\n                maxCount = m.get(k);\n            }\n        }\n        for (Integer k: m.keySet()) {\n            if (m.get(k) == maxCount) {\n                r.add(k);\n            }\n        }\n        int[] result = new int[r.size()];\n        for (int i=0; i<r.size(); i++) {\n            result[i] = r.get(i);\n        }\n        return result;\n    }\n"]]}
{"hexsha": "93a068555222aa88730159d2368fee07ec9ed1fc", "ext": "java", "lang": "Java", "content": "public class Hierarchy {\n    protected Grammar LexerRoot = null;\n    protected Grammar ParserRoot = null;\n    protected Grammar TreeParserRoot = null;\n    protected Hashtable symbols;\t// table of grammars\n    protected Hashtable files;\t// table of grammar files read in\n    protected antlr.Tool antlrTool;\n\n    public Hierarchy(antlr.Tool tool) {\n        this.antlrTool = tool;\n        LexerRoot = new Grammar(tool, \"Lexer\", null, null);\n        ParserRoot = new Grammar(tool, \"Parser\", null, null);\n        TreeParserRoot = new Grammar(tool, \"TreeParser\", null, null);\n        symbols = new Hashtable(10);\n        files = new Hashtable(10);\n\n        LexerRoot.setPredefined(true);\n        ParserRoot.setPredefined(true);\n        TreeParserRoot.setPredefined(true);\n\n        symbols.put(LexerRoot.getName(), LexerRoot);\n        symbols.put(ParserRoot.getName(), ParserRoot);\n        symbols.put(TreeParserRoot.getName(), TreeParserRoot);\n    }\n\n    public void addGrammar(Grammar gr) {\n        gr.setHierarchy(this);\n        // add grammar to hierarchy\n        symbols.put(gr.getName(), gr);\n        // add grammar to file.\n        GrammarFile f = getFile(gr.getFileName());\n        f.addGrammar(gr);\n    }\n\n    public void addGrammarFile(GrammarFile gf) {\n        files.put(gf.getName(), gf);\n    }\n\n    public void expandGrammarsInFile(String fileName) {\n        GrammarFile f = getFile(fileName);\n        for (Enumeration e = f.getGrammars().elements(); e.hasMoreElements();) {\n            Grammar g = (Grammar)e.nextElement();\n            g.expandInPlace();\n        }\n    }\n\n    public Grammar findRoot(Grammar g) {\n        if (g.getSuperGrammarName() == null) {\t\t// at root\n            return g;\n        }\n        // return root of super.\n        Grammar sg = g.getSuperGrammar();\n        if (sg == null) return g;\t\t// return this grammar if super missing\n        return findRoot(sg);\n    }\n\n    public GrammarFile getFile(String fileName) {\n        return (GrammarFile)files.get(fileName);\n    }\n\n    public Grammar getGrammar(String gr) {\n        return (Grammar)symbols.get(gr);\n    }\n\n    public static String optionsToString(IndexedVector options) {\n        String s = \"options {\" + System.getProperty(\"line.separator\");\n        for (Enumeration e = options.elements(); e.hasMoreElements();) {\n            s += (Option)e.nextElement() + System.getProperty(\"line.separator\");\n        }\n        s += \"}\" +\n            System.getProperty(\"line.separator\") +\n            System.getProperty(\"line.separator\");\n        return s;\n    }\n\n    public void readGrammarFile(String file) throws FileNotFoundException {\n        Reader grStream = new BufferedReader(new FileReader(file));\n        addGrammarFile(new GrammarFile(antlrTool, file));\n\n        // Create the simplified grammar lexer/parser\n        PreprocessorLexer ppLexer = new PreprocessorLexer(grStream);\n        ppLexer.setFilename(file);\n        Preprocessor pp = new Preprocessor(ppLexer);\n\t\tpp.setTool(antlrTool);\n        pp.setFilename(file);\n\n        // populate the hierarchy with class(es) read in\n        try {\n            pp.grammarFile(this, file);\n        }\n        catch (TokenStreamException io) {\n            antlrTool.toolError(\"Token stream error reading grammar(s):\\n\" + io);\n        }\n        catch (ANTLRException se) {\n            antlrTool.toolError(\"error reading grammar(s):\\n\" + se);\n        }\n    }\n\n    /** Return true if hierarchy is complete, false if not */\n    public boolean verifyThatHierarchyIsComplete() {\n        boolean complete = true;\n        // Make a pass to ensure all grammars are defined\n        for (Enumeration e = symbols.elements(); e.hasMoreElements();) {\n            Grammar c = (Grammar)e.nextElement();\n            if (c.getSuperGrammarName() == null) {\n                continue;\t\t// at root: ignore predefined roots\n            }\n            Grammar superG = c.getSuperGrammar();\n            if (superG == null) {\n                antlrTool.toolError(\"grammar \" + c.getSuperGrammarName() + \" not defined\");\n                complete = false;\n                symbols.remove(c.getName()); // super not defined, kill sub\n            }\n        }\n\n        if (!complete) return false;\n\n        // Make another pass to set the 'type' field of each grammar\n        // This makes it easy later to ask a grammar what its type\n        // is w/o having to search hierarchy.\n        for (Enumeration e = symbols.elements(); e.hasMoreElements();) {\n            Grammar c = (Grammar)e.nextElement();\n            if (c.getSuperGrammarName() == null) {\n                continue;\t\t// ignore predefined roots\n            }\n            c.setType(findRoot(c).getName());\n        }\n\n        return true;\n    }\n\n    public antlr.Tool getTool() {\n        return antlrTool;\n    }\n\n    public void setTool(antlr.Tool antlrTool) {\n        this.antlrTool = antlrTool;\n    }\n}", "class_id": 0, "repo": "Willian-Ribeiro/Compilador", "file": "Projeto Compilador/antlr-2.7.6/antlr/preprocessor/Hierarchy.java", "last_update_at": "2019-09-27T01:25:44+00:00", "question_id": "93a068555222aa88730159d2368fee07ec9ed1fc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Hierarchy {\n    protected Grammar LexerRoot = null;\n    protected Grammar ParserRoot = null;\n    protected Grammar TreeParserRoot = null;\n    protected Hashtable symbols;\t// table of grammars\n    protected Hashtable files;\t// table of grammar files read in\n    protected antlr.Tool antlrTool;\n    public Hierarchy(antlr.Tool tool) {\n        this.antlrTool = tool;\n        LexerRoot = new Grammar(tool, \"Lexer\", null, null);\n        ParserRoot = new Grammar(tool, \"Parser\", null, null);\n        TreeParserRoot = new Grammar(tool, \"TreeParser\", null, null);\n        symbols = new Hashtable(10);\n        files = new Hashtable(10);\n        LexerRoot.setPredefined(true);\n        ParserRoot.setPredefined(true);\n        TreeParserRoot.setPredefined(true);\n        symbols.put(LexerRoot.getName(), LexerRoot);\n        symbols.put(ParserRoot.getName(), ParserRoot);\n        symbols.put(TreeParserRoot.getName(), TreeParserRoot);\n    }\n    public void addGrammar(Grammar gr) {\n        gr.setHierarchy(this);\n        // add grammar to hierarchy\n        symbols.put(gr.getName(), gr);\n        // add grammar to file.\n        GrammarFile f = getFile(gr.getFileName());\n        f.addGrammar(gr);\n    }\n    public void addGrammarFile(GrammarFile gf) {\n        files.put(gf.getName(), gf);\n    }\n    public void expandGrammarsInFile(String fileName) {\n        GrammarFile f = getFile(fileName);\n        for (Enumeration e = f.getGrammars().elements(); e.hasMoreElements();) {\n            Grammar g = (Grammar)e.nextElement();\n            g.expandInPlace();\n        }\n    }\n    public Grammar findRoot(Grammar g) {\n        if (g.getSuperGrammarName() == null) {\t\t// at root\n            return g;\n        }\n        // return root of super.\n        Grammar sg = g.getSuperGrammar();\n        if (sg == null) return g;\t\t// return this grammar if super missing\n        return findRoot(sg);\n    }\n    public GrammarFile getFile(String fileName) {\n        return (GrammarFile)files.get(fileName);\n    }\n    public Grammar getGrammar(String gr) {\n        return (Grammar)symbols.get(gr);\n    }\n    public static String optionsToString(IndexedVector options) {\n        String s = \"options {\" + System.getProperty(\"line.separator\");\n        for (Enumeration e = options.elements(); e.hasMoreElements();) {\n            s += (Option)e.nextElement() + System.getProperty(\"line.separator\");\n        }\n        s += \"}\" +\n            System.getProperty(\"line.separator\") +\n            System.getProperty(\"line.separator\");\n        return s;\n    }\n    public void readGrammarFile(String file) throws FileNotFoundException {\n        Reader grStream = new BufferedReader(new FileReader(file));\n        addGrammarFile(new GrammarFile(antlrTool, file));\n        // Create the simplified grammar lexer/parser\n        PreprocessorLexer ppLexer = new PreprocessorLexer(grStream);\n        ppLexer.setFilename(file);\n        Preprocessor pp = new Preprocessor(ppLexer);\n\t\tpp.setTool(antlrTool);\n        pp.setFilename(file);\n        // populate the hierarchy with class(es) read in\n        try {\n            pp.grammarFile(this, file);\n        }\n        catch (TokenStreamException io) {\n            antlrTool.toolError(\"Token stream error reading grammar(s):\\n\" + io);\n        }\n        catch (ANTLRException se) {\n            antlrTool.toolError(\"error reading grammar(s):\\n\" + se);\n        }\n    }\n    /** Return true if hierarchy is complete, false if not */\n    public boolean verifyThatHierarchyIsComplete() {\n        boolean complete = true;\n        // Make a pass to ensure all grammars are defined\n        for (Enumeration e = symbols.elements(); e.hasMoreElements();) {\n            Grammar c = (Grammar)e.nextElement();\n            if (c.getSuperGrammarName() == null) {\n                continue;\t\t// at root: ignore predefined roots\n            }\n            Grammar superG = c.getSuperGrammar();\n            if (superG == null) {\n                antlrTool.toolError(\"grammar \" + c.getSuperGrammarName() + \" not defined\");\n                complete = false;\n                symbols.remove(c.getName()); // super not defined, kill sub\n            }\n        }\n        if (!complete) return false;\n        // Make another pass to set the 'type' field of each grammar\n        // This makes it easy later to ask a grammar what its type\n        // is w/o having to search hierarchy.\n        for (Enumeration e = symbols.elements(); e.hasMoreElements();) {\n            Grammar c = (Grammar)e.nextElement();\n            if (c.getSuperGrammarName() == null) {\n                continue;\t\t// ignore predefined roots\n            }\n            c.setType(findRoot(c).getName());\n        }\n        return true;\n    }\n    public antlr.Tool getTool() {\n        return antlrTool;\n    }\n    public void setTool(antlr.Tool antlrTool) {\n        this.antlrTool = antlrTool;\n    }\n"]]}
{"hexsha": "e49d2b3891f8b4208e0683d54ffa16c80af5e94c", "ext": "java", "lang": "Java", "content": "@ConfiguresHttpCommandExecutorService\npublic class JavaUrlHttpCommandExecutorServiceModule extends AbstractModule {\n\n   @Override\n   protected void configure() {\n      install(new SSLModule());\n      bind(HttpCommandExecutorService.class).to(JavaUrlHttpCommandExecutorService.class).in(Scopes.SINGLETON);\n      bind(TransformingHttpCommandExecutorService.class).to(TransformingHttpCommandExecutorServiceImpl.class).in(\n               Scopes.SINGLETON);\n   }\n\n}", "class_id": 0, "repo": "bosschaert/jclouds", "file": "core/src/main/java/org/jclouds/http/config/JavaUrlHttpCommandExecutorServiceModule.java", "last_update_at": "2019-09-11T01:13:03+00:00", "question_id": "e49d2b3891f8b4208e0683d54ffa16c80af5e94c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ConfiguresHttpCommandExecutorService\npublic class JavaUrlHttpCommandExecutorServiceModule extends AbstractModule {\n   @Override\n   protected void configure() {\n      install(new SSLModule());\n      bind(HttpCommandExecutorService.class).to(JavaUrlHttpCommandExecutorService.class).in(Scopes.SINGLETON);\n      bind(TransformingHttpCommandExecutorService.class).to(TransformingHttpCommandExecutorServiceImpl.class).in(\n               Scopes.SINGLETON);\n   }\n"]]}
{"hexsha": "6a61e7684c8fbe7d634ef3e85c8d9ec1f49a8e5f", "ext": "java", "lang": "Java", "content": "public class PDFContentProvider implements Closeable {\n\n\tprivate File file;\n\tprivate PDDocument document;\n\n\tpublic PDFContentProvider(File file) {\n\t\tthis.file = file;\n\t\tinitialize();\n\t}\n\n\tprivate void initialize() {\n\t\ttry {\n\t\t\tPDFParser parser = new PDFParser(new RandomAccessFile(file, \"r\"));\n\t\t\tparser.parse();\n\t\t\tdocument = new PDDocument(parser.getDocument());\n\t\t} catch (FileNotFoundException e) {\n\t\t\tthrow new PdfgenException(\"File was not found.\", e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new PdfgenException(\"Error while reading or parsing file.\", e);\n\t\t}\n\t}\n\n\tpublic List<BufferedImage> getAllImages() {\n\t\tList<BufferedImage> images = new ArrayList<>();\n\n\t\tfor (PDPage page : document.getPages()) {\n\t\t\timages.addAll(getImagesFromResources(page.getResources()));\n\t\t}\n\n\t\treturn images;\n\t}\n\n\tprivate List<BufferedImage> getImagesFromResources(PDResources resources) {\n\t\tList<BufferedImage> images = new ArrayList<>();\n\n\t\ttry {\n\t\t\tfor (COSName xObjectName : resources.getXObjectNames()) {\n\t\t\t\tPDXObject xObject = resources.getXObject(xObjectName);\n\n\t\t\t\tif (xObject instanceof PDFormXObject) {\n\t\t\t\t\timages.addAll(getImagesFromResources(((PDFormXObject) xObject).getResources()));\n\t\t\t\t} else if (xObject instanceof PDImageXObject) {\n\t\t\t\t\timages.add(((PDImageXObject) xObject).getImage());\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\n\t\treturn images;\n\t}\n\n\tpublic String getText() {\n\t\treturn getText(1, document.getNumberOfPages());\n\t}\n\n\tpublic String getText(int fromPage, int toPage) {\n\t\ttry {\n\t\t\tPDFTextStripper textStripper = new PDFTextStripper();\n\t\t\ttextStripper.setStartPage(fromPage);\n\t\t\ttextStripper.setEndPage(toPage);\n\n\t\t\treturn textStripper.getText(document);\n\t\t} catch (IOException e) {\n\t\t\tthrow new PdfgenException(\"Error while reading file.\", e);\n\t\t}\n\t}\n\n\tpublic int getPagesCount() {\n\t\treturn document.getNumberOfPages();\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\ttry {\n\t\t\tdocument.close();\n\t\t} catch (IOException e) {\n\t\t\tthrow new PdfgenException(\"Failed to close the file.\", e);\n\t\t}\n\t}\n}", "class_id": 0, "repo": "tratif/pdfgen", "file": "src/test/java/com/tratif/pdfgen/asserts/helpers/PDFContentProvider.java", "last_update_at": "2019-03-14T19:36:38+00:00", "question_id": "6a61e7684c8fbe7d634ef3e85c8d9ec1f49a8e5f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PDFContentProvider implements Closeable {\n\tprivate File file;\n\tprivate PDDocument document;\n\tpublic PDFContentProvider(File file) {\n\t\tthis.file = file;\n\t\tinitialize();\n\t}\n\tprivate void initialize() {\n\t\ttry {\n\t\t\tPDFParser parser = new PDFParser(new RandomAccessFile(file, \"r\"));\n\t\t\tparser.parse();\n\t\t\tdocument = new PDDocument(parser.getDocument());\n\t\t} catch (FileNotFoundException e) {\n\t\t\tthrow new PdfgenException(\"File was not found.\", e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new PdfgenException(\"Error while reading or parsing file.\", e);\n\t\t}\n\t}\n\tpublic List<BufferedImage> getAllImages() {\n\t\tList<BufferedImage> images = new ArrayList<>();\n\t\tfor (PDPage page : document.getPages()) {\n\t\t\timages.addAll(getImagesFromResources(page.getResources()));\n\t\t}\n\t\treturn images;\n\t}\n\tprivate List<BufferedImage> getImagesFromResources(PDResources resources) {\n\t\tList<BufferedImage> images = new ArrayList<>();\n\t\ttry {\n\t\t\tfor (COSName xObjectName : resources.getXObjectNames()) {\n\t\t\t\tPDXObject xObject = resources.getXObject(xObjectName);\n\t\t\t\tif (xObject instanceof PDFormXObject) {\n\t\t\t\t\timages.addAll(getImagesFromResources(((PDFormXObject) xObject).getResources()));\n\t\t\t\t} else if (xObject instanceof PDImageXObject) {\n\t\t\t\t\timages.add(((PDImageXObject) xObject).getImage());\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn images;\n\t}\n\tpublic String getText() {\n\t\treturn getText(1, document.getNumberOfPages());\n\t}\n\tpublic String getText(int fromPage, int toPage) {\n\t\ttry {\n\t\t\tPDFTextStripper textStripper = new PDFTextStripper();\n\t\t\ttextStripper.setStartPage(fromPage);\n\t\t\ttextStripper.setEndPage(toPage);\n\t\t\treturn textStripper.getText(document);\n\t\t} catch (IOException e) {\n\t\t\tthrow new PdfgenException(\"Error while reading file.\", e);\n\t\t}\n\t}\n\tpublic int getPagesCount() {\n\t\treturn document.getNumberOfPages();\n\t}\n\t@Override\n\tpublic void close() {\n\t\ttry {\n\t\t\tdocument.close();\n\t\t} catch (IOException e) {\n\t\t\tthrow new PdfgenException(\"Failed to close the file.\", e);\n\t\t}\n\t}\n"]]}
{"hexsha": "c13091d0c7466e5f8048a3bb2ad4d509bc95d48f", "ext": "java", "lang": "Java", "content": "public class BarcodeGeneratorProvider {\n\n    private static BarcodeGeneratorProvider instance;\n    private static final Logger LOGGER = Logger.getLogger(BarcodeGeneratorProvider.class.getName());\n    private final ServiceLoader<BarcodeGenerator> loader;\n    private final ConcurrentMap<String, Class<BarcodeGenerator>> barcodeGenerators;\n\n    /**\n     * Initialize this singleton.\n     */\n    private BarcodeGeneratorProvider() {\n        this.barcodeGenerators = new ConcurrentHashMap<String, Class<BarcodeGenerator>>();\n        loader = ServiceLoader.load(BarcodeGenerator.class);\n        initialize();\n    }\n\n    /**\n     * Gets the Provider.\n     *\n     * @return single instance\n     */\n    public static synchronized BarcodeGeneratorProvider getInstance() {\n        if (instance == null) {\n            instance = new BarcodeGeneratorProvider();\n            LOGGER.log(Level.INFO, \"Created new instance.\");\n        }\n        return instance;\n    }\n\n    /**\n     * Lists all names of available BarcodeGenerators.\n     *\n     * @return Set of available BarcodeGenerator names\n     */\n    public Collection<String> getAvailableBarcodeGenerators() {\n        final Set<String> res = new TreeSet<String>();\n        res.addAll(barcodeGenerators.keySet());\n        return res;\n    }\n\n    /**\n     * Instanciates a fresh copy of a BarcodeGenerator.\n     *\n     * @param id Name of Barcode ({@link #getAvailableBarcodeGenerators() })\n     * @return a fresh copy\n     * @throws BarcodeException if barcode with {@code id} is not available \n     */\n    public BarcodeGenerator getBarcodeGenerator(String id) throws BarcodeException {\n        final Class<BarcodeGenerator> clazz = barcodeGenerators.get(id);\n\n        if (clazz == null) {\n            throw new BarcodeException(\"BarcodeGenerator with \" + id + \" is not available.\");\n        }\n\n        BarcodeGenerator res = null;\n        try {\n            res = clazz.newInstance();\n        } catch (InstantiationException ex) {\n            LOGGER.log(Level.SEVERE, null, ex);\n        } catch (IllegalAccessException ex) {\n            LOGGER.log(Level.SEVERE, null, ex);\n        }\n        return res;\n    }\n\n    /**\n     * Loads all implementing Classes through ServiceLoader interface.\n     */\n    private void initialize() {\n        final Iterator<BarcodeGenerator> iterator = loader.iterator();\n        while (iterator.hasNext()) {\n            try {\n                final BarcodeGenerator bg = iterator.next();\n                final String id = bg.getId();\n                @SuppressWarnings(\"unchecked\")\n                final Class<BarcodeGenerator> clazz = (Class<BarcodeGenerator>) bg.getClass();\n                barcodeGenerators.put(id, clazz);\n                final Collection<String> addIds = bg.getAdditionalNames();\n                if (addIds != null) {\n                    for (final String addId : addIds) {\n                        barcodeGenerators.putIfAbsent(addId, clazz);\n                    }\n                }\n            } catch (ServiceConfigurationError e) {\n                LOGGER.log(Level.WARNING,\n                        \"Failed to load a BarcodeGenerator service.\", e);\n            }\n        }\n        if (LOGGER.isLoggable(Level.INFO)) {\n            LOGGER.info(\"Available BarcodeGenerators: \");\n            for (final Map.Entry<String, Class<BarcodeGenerator>> entrySet : barcodeGenerators.entrySet()) {\n                final String key = entrySet.getKey();\n                final Class<BarcodeGenerator> value = entrySet.getValue();\n                LOGGER.log(Level.INFO, \"{0} -> {1}\", new Object[]{key, value.getName()});\n            }\n        }\n    }\n}", "class_id": 0, "repo": "mbhk/barcode4j", "file": "barcode4j-light/src/main/java/org/krysalis/barcode4j/BarcodeGeneratorProvider.java", "last_update_at": "2019-06-28T22:02:45+00:00", "question_id": "c13091d0c7466e5f8048a3bb2ad4d509bc95d48f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BarcodeGeneratorProvider {\n    private static BarcodeGeneratorProvider instance;\n    private static final Logger LOGGER = Logger.getLogger(BarcodeGeneratorProvider.class.getName());\n    private final ServiceLoader<BarcodeGenerator> loader;\n    private final ConcurrentMap<String, Class<BarcodeGenerator>> barcodeGenerators;\n    /**\n     * Initialize this singleton.\n     */\n    private BarcodeGeneratorProvider() {\n        this.barcodeGenerators = new ConcurrentHashMap<String, Class<BarcodeGenerator>>();\n        loader = ServiceLoader.load(BarcodeGenerator.class);\n        initialize();\n    }\n    /**\n     * Gets the Provider.\n     *\n     * @return single instance\n     */\n    public static synchronized BarcodeGeneratorProvider getInstance() {\n        if (instance == null) {\n            instance = new BarcodeGeneratorProvider();\n            LOGGER.log(Level.INFO, \"Created new instance.\");\n        }\n        return instance;\n    }\n    /**\n     * Lists all names of available BarcodeGenerators.\n     *\n     * @return Set of available BarcodeGenerator names\n     */\n    public Collection<String> getAvailableBarcodeGenerators() {\n        final Set<String> res = new TreeSet<String>();\n        res.addAll(barcodeGenerators.keySet());\n        return res;\n    }\n    /**\n     * Instanciates a fresh copy of a BarcodeGenerator.\n     *\n     * @param id Name of Barcode ({@link #getAvailableBarcodeGenerators() })\n     * @return a fresh copy\n     * @throws BarcodeException if barcode with {@code id} is not available \n     */\n    public BarcodeGenerator getBarcodeGenerator(String id) throws BarcodeException {\n        final Class<BarcodeGenerator> clazz = barcodeGenerators.get(id);\n        if (clazz == null) {\n            throw new BarcodeException(\"BarcodeGenerator with \" + id + \" is not available.\");\n        }\n        BarcodeGenerator res = null;\n        try {\n            res = clazz.newInstance();\n        } catch (InstantiationException ex) {\n            LOGGER.log(Level.SEVERE, null, ex);\n        } catch (IllegalAccessException ex) {\n            LOGGER.log(Level.SEVERE, null, ex);\n        }\n        return res;\n    }\n    /**\n     * Loads all implementing Classes through ServiceLoader interface.\n     */\n    private void initialize() {\n        final Iterator<BarcodeGenerator> iterator = loader.iterator();\n        while (iterator.hasNext()) {\n            try {\n                final BarcodeGenerator bg = iterator.next();\n                final String id = bg.getId();\n                @SuppressWarnings(\"unchecked\")\n                final Class<BarcodeGenerator> clazz = (Class<BarcodeGenerator>) bg.getClass();\n                barcodeGenerators.put(id, clazz);\n                final Collection<String> addIds = bg.getAdditionalNames();\n                if (addIds != null) {\n                    for (final String addId : addIds) {\n                        barcodeGenerators.putIfAbsent(addId, clazz);\n                    }\n                }\n            } catch (ServiceConfigurationError e) {\n                LOGGER.log(Level.WARNING,\n                        \"Failed to load a BarcodeGenerator service.\", e);\n            }\n        }\n        if (LOGGER.isLoggable(Level.INFO)) {\n            LOGGER.info(\"Available BarcodeGenerators: \");\n            for (final Map.Entry<String, Class<BarcodeGenerator>> entrySet : barcodeGenerators.entrySet()) {\n                final String key = entrySet.getKey();\n                final Class<BarcodeGenerator> value = entrySet.getValue();\n                LOGGER.log(Level.INFO, \"{0} -> {1}\", new Object[]{key, value.getName()});\n            }\n        }\n    }\n"]]}
{"hexsha": "bbc74af564193bf70d4ec54a2c0dee0605588592", "ext": "java", "lang": "Java", "content": "public class SqliteTest {\n\n    @Before\n    public void testInitDB(){\n        Sqlite.getSqlite().initDB();\n    }\n\n    @Test\n    public void testInsertId(){\n        String sql = \"insert into roles(service, role_name, type, ping_url, metric, client_id, members, add_time) \" +\n                \"VALUES ('lzz-cpu','aaa','ping','http://',\"+1+\",'127.0.0.1','@all',1)\";\n        int id = Sqlite.getSqlite().insertId( sql );\n        System.out.println(id);\n    }\n\n    @Test\n    public void testSelectRow(){\n        String sql = \"select id from roles where role_name='0:0:0:0:0:0:0:1_null'\";\n        Map map = Sqlite.getSqlite().selectRow(sql);\n        System.out.println(map);\n    }\n\n    @Test\n    public void testSelects(){\n        String sql = \"select id from roles\";\n        List list = Sqlite.getSqlite().select( sql );\n        System.out.println( list );\n    }\n}", "class_id": 0, "repo": "hellosix/wechat-alarm", "file": "src/test/java/com/lzz/util/SqliteTest.java", "last_update_at": "2019-05-20T02:05:49+00:00", "question_id": "bbc74af564193bf70d4ec54a2c0dee0605588592", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SqliteTest {\n    @Before\n    public void testInitDB(){\n        Sqlite.getSqlite().initDB();\n    }\n    @Test\n    public void testInsertId(){\n        String sql = \"insert into roles(service, role_name, type, ping_url, metric, client_id, members, add_time) \" +\n                \"VALUES ('lzz-cpu','aaa','ping','http://',\"+1+\",'127.0.0.1','@all',1)\";\n        int id = Sqlite.getSqlite().insertId( sql );\n        System.out.println(id);\n    }\n    @Test\n    public void testSelectRow(){\n        String sql = \"select id from roles where role_name='0:0:0:0:0:0:0:1_null'\";\n        Map map = Sqlite.getSqlite().selectRow(sql);\n        System.out.println(map);\n    }\n    @Test\n    public void testSelects(){\n        String sql = \"select id from roles\";\n        List list = Sqlite.getSqlite().select( sql );\n        System.out.println( list );\n    }\n"]]}
{"hexsha": "354be56115891094a590c44f1daca45cf507d1d0", "ext": "java", "lang": "Java", "content": "@Repository(value=\"setCallColumnInfoDao\")\npublic class SetCallColumnInfoDaoImpl implements SetCallColumnInfoDao {\n\n    @Override\n    public int selectCountByDateSet(String dataSetCode) {\n\n        int count = 0;\n        String queryStr = \"SELECT COUNT(*) from analysisplatform.set_callcolumninfo WHERE show_sensitiveinfo =1 AND dataset = '\"+dataSetCode+\"'\";\n        Connection connection = MySQLConnectionBean.getInstance().getDefaultConnection(Global.DatabaseName);\n\n        try {\n            Statement statement = connection.createStatement();\n            ResultSet resultSet = statement.executeQuery(queryStr);\n\n            while (resultSet.next()){\n              count = resultSet.getInt(1);\n            }\n\n            connection.close();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n\n        return  count;\n    }\n\n    @Override\n    public List<CallColumnInfoBean> selectCallColumnInfoByDateSet(String s) {\n        return null;\n    }\n\n\n    @Override\n    public int updateCallColumnInfo(CallColumnInfoBean callColumnInfoBean) {\n        String updateStr = \"UPDATE analysisplatform.callcolumninfo SET displaylevel =? WHERE showsensitiveinfo =1 and id =?\";\n        Connection connection = MySQLConnectionBean.getInstance().getDefaultConnection(Global.DatabaseName);\n      int coutn = 0;\n        try {\n            PreparedStatement  preparedStatement = connection.prepareStatement(updateStr);\n\n            preparedStatement.setString(1,callColumnInfoBean.getDisplaylevel());\n            preparedStatement.setInt(2,callColumnInfoBean.getId());\n\n            coutn = preparedStatement.executeUpdate();\n\n            connection.close();\n        } catch (SQLException e) {\n            System.out.println(\"[\"+e.getMessage()+\"]\");\n        }\n\n        return  coutn;\n    }\n\n    @Override\n    public List<CallColumnInfoBean> selectCallColumnInfoByRoleName(String roleName) {\n        String queryStr = \"SELECT id,displaylevel,showsensitiveinfo,dataset from analysisplatform.callcolumninfo WHERE showsensitiveinfo =1 and displaylevel LIKE '%\"+roleName+\",%'\";\n        return null;//getCallColumnInfoBeanListByQueryStr(queryStr);\n    }\n\n    @Override\n    public int selectCountByDateSetAndRoleName(int id, String dataSetCode, String roleName) {\n        String queryStr = \"SELECT COUNT(*) from analysisplatform.set_callcolumn_role WHERE column_id =\"+id+\" and role ='\"+roleName+\"' and dataset ='\"+dataSetCode+\"'\";\n        return  getCount(queryStr);\n    }\n\n    @Override\n    public List<CallColumnInfoBean> selectByDateSetAndRoleName(String roleName, String dataSetCode) {\n        String queryStr = \"SELECT id,displaylevel,show_sensitiveinfo,dataset from analysisplatform.set_callcolumninfo WHERE showsensitiveinfo =1 and displaylevel LIKE '%\"+roleName+\",%' and dataset ='\"+dataSetCode+\"'\";\n\n        return null;//getCallColumnInfoBeanListByQueryStr(queryStr);\n    }\n\n\n\n    @Override\n    public List<SetCallColumnInfoBean> selectSetCallColumnInfoByDateSet(String dataSetCode) {\n\n        String queryStr = \"SELECT id,show_sensitiveinfo,dataset from analysisplatform.set_callcolumninfo WHERE show_sensitiveinfo = 1 and dataset = '\"+dataSetCode+\"'\";\n        return getCallColumnInfoBeanListByQueryStr(queryStr);\n    }\n\n    @Override\n    public int selectCountByDateSetAndRoleName(String dataSetCode, String roleName) {\n        String queryStr = \"SELECT COUNT(*) from analysisplatform.set_callcolumn_role WHERE role ='\"+roleName+\"' and dataset ='\"+dataSetCode+\"'\";\n        return  getCount(queryStr);\n    }\n\n\n    @Override\n    public boolean insertRoleNameToSetCall(int id, String rolesname, String dataSetCode) {\n        int count =0;\n        String insertStr = \"INSERT INTO analysisplatform.set_callcolumn_role (column_id,role,dataset)VALUES(?,?,?)\";\n        Connection connection = MySQLConnectionBean.getInstance().getDefaultConnection(Global.DatabaseName);\n\n        try {\n            PreparedStatement preparedStatement = connection.prepareStatement(insertStr);\n             preparedStatement.setInt(1,id);\n             preparedStatement.setString(2,rolesname);\n             preparedStatement.setString(3,dataSetCode);\n             count =preparedStatement.executeUpdate();\n\n             connection.close();\n        } catch (SQLException e) {\n            System.out.println(\"[\"+e.getMessage()+\"]\");\n        }\n\n\n        return count ==1;\n    }\n\n    @Override\n    public boolean deleteRoleNameSetCall(String rolesname, String dataSetCode) {\n        String deleteStr = \"DELETE FROM analysisplatform.set_callcolumn_role WHERE role =? AND dataset =?\";\n\n       int count = 0;\n        Connection connection = MySQLConnectionBean.getInstance().getDefaultConnection(Global.DatabaseName);\n\n        try {\n            PreparedStatement preparedStatement = connection.prepareStatement(deleteStr);\n            preparedStatement.setString(1,rolesname);\n            preparedStatement.setString(2,dataSetCode);\n            count =preparedStatement.executeUpdate();\n\n            connection.close();\n        } catch (SQLException e) {\n            System.out.println(\"[\"+e.getMessage()+\"]\");\n        }\n\n\n        return count ==1;\n    }\n\n    private int getCount(String queryStr) {\n        int count = 0;\n        Connection connection = MySQLConnectionBean.getInstance().getDefaultConnection(Global.DatabaseName);\n\n        try {\n            Statement statement = connection.createStatement();\n            ResultSet resultSet = statement.executeQuery(queryStr);\n\n            while (resultSet.next()){\n                count = resultSet.getInt(1);\n            }\n\n            connection.close();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n        return count;\n    }\n\n\n    private List<SetCallColumnInfoBean>  getCallColumnInfoBeanListByQueryStr(String queryStr) {\n        List<SetCallColumnInfoBean> setCallColumnInfoBeanList = new ArrayList<>();\n        Connection connection = MySQLConnectionBean.getInstance().getDefaultConnection(Global.DatabaseName);\n        try {\n            Statement statement = connection.createStatement();\n            ResultSet resultSet = statement.executeQuery(queryStr);\n\n            while (resultSet.next()){\n                SetCallColumnInfoBean setCallColumnInfoBean = new SetCallColumnInfoBean();\n\n                setCallColumnInfoBean.setId(resultSet.getInt(1));\n                setCallColumnInfoBean.setShow_sensitiveinfo(resultSet.getInt(2));\n                setCallColumnInfoBean.setDataset(resultSet.getString(3));\n\n                setCallColumnInfoBeanList.add(setCallColumnInfoBean);\n            }\n\n            connection.close();\n        } catch (SQLException e) {\n            System.out.println(\"[\"+e.getMessage()+\"]\");\n        }\n        return  setCallColumnInfoBeanList;\n    }\n\n}", "class_id": 0, "repo": "CECDemo/authorityManage", "file": "src/main/java/com/wbliu/cecdemo/userManager/dao/SetCallColumnInfoDaoImpl.java", "last_update_at": "2019-07-18T05:52:38+00:00", "question_id": "354be56115891094a590c44f1daca45cf507d1d0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Repository(value=\"setCallColumnInfoDao\")\npublic class SetCallColumnInfoDaoImpl implements SetCallColumnInfoDao {\n    @Override\n    public int selectCountByDateSet(String dataSetCode) {\n        int count = 0;\n        String queryStr = \"SELECT COUNT(*) from analysisplatform.set_callcolumninfo WHERE show_sensitiveinfo =1 AND dataset = '\"+dataSetCode+\"'\";\n        Connection connection = MySQLConnectionBean.getInstance().getDefaultConnection(Global.DatabaseName);\n        try {\n            Statement statement = connection.createStatement();\n            ResultSet resultSet = statement.executeQuery(queryStr);\n            while (resultSet.next()){\n              count = resultSet.getInt(1);\n            }\n            connection.close();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n        return  count;\n    }\n    @Override\n    public List<CallColumnInfoBean> selectCallColumnInfoByDateSet(String s) {\n        return null;\n    }\n    @Override\n    public int updateCallColumnInfo(CallColumnInfoBean callColumnInfoBean) {\n        String updateStr = \"UPDATE analysisplatform.callcolumninfo SET displaylevel =? WHERE showsensitiveinfo =1 and id =?\";\n        Connection connection = MySQLConnectionBean.getInstance().getDefaultConnection(Global.DatabaseName);\n      int coutn = 0;\n        try {\n            PreparedStatement  preparedStatement = connection.prepareStatement(updateStr);\n            preparedStatement.setString(1,callColumnInfoBean.getDisplaylevel());\n            preparedStatement.setInt(2,callColumnInfoBean.getId());\n            coutn = preparedStatement.executeUpdate();\n            connection.close();\n        } catch (SQLException e) {\n            System.out.println(\"[\"+e.getMessage()+\"]\");\n        }\n        return  coutn;\n    }\n    @Override\n    public List<CallColumnInfoBean> selectCallColumnInfoByRoleName(String roleName) {\n        String queryStr = \"SELECT id,displaylevel,showsensitiveinfo,dataset from analysisplatform.callcolumninfo WHERE showsensitiveinfo =1 and displaylevel LIKE '%\"+roleName+\",%'\";\n        return null;//getCallColumnInfoBeanListByQueryStr(queryStr);\n    }\n    @Override\n    public int selectCountByDateSetAndRoleName(int id, String dataSetCode, String roleName) {\n        String queryStr = \"SELECT COUNT(*) from analysisplatform.set_callcolumn_role WHERE column_id =\"+id+\" and role ='\"+roleName+\"' and dataset ='\"+dataSetCode+\"'\";\n        return  getCount(queryStr);\n    }\n    @Override\n    public List<CallColumnInfoBean> selectByDateSetAndRoleName(String roleName, String dataSetCode) {\n        String queryStr = \"SELECT id,displaylevel,show_sensitiveinfo,dataset from analysisplatform.set_callcolumninfo WHERE showsensitiveinfo =1 and displaylevel LIKE '%\"+roleName+\",%' and dataset ='\"+dataSetCode+\"'\";\n        return null;//getCallColumnInfoBeanListByQueryStr(queryStr);\n    }\n    @Override\n    public List<SetCallColumnInfoBean> selectSetCallColumnInfoByDateSet(String dataSetCode) {\n        String queryStr = \"SELECT id,show_sensitiveinfo,dataset from analysisplatform.set_callcolumninfo WHERE show_sensitiveinfo = 1 and dataset = '\"+dataSetCode+\"'\";\n        return getCallColumnInfoBeanListByQueryStr(queryStr);\n    }\n    @Override\n    public int selectCountByDateSetAndRoleName(String dataSetCode, String roleName) {\n        String queryStr = \"SELECT COUNT(*) from analysisplatform.set_callcolumn_role WHERE role ='\"+roleName+\"' and dataset ='\"+dataSetCode+\"'\";\n        return  getCount(queryStr);\n    }\n    @Override\n    public boolean insertRoleNameToSetCall(int id, String rolesname, String dataSetCode) {\n        int count =0;\n        String insertStr = \"INSERT INTO analysisplatform.set_callcolumn_role (column_id,role,dataset)VALUES(?,?,?)\";\n        Connection connection = MySQLConnectionBean.getInstance().getDefaultConnection(Global.DatabaseName);\n        try {\n            PreparedStatement preparedStatement = connection.prepareStatement(insertStr);\n             preparedStatement.setInt(1,id);\n             preparedStatement.setString(2,rolesname);\n             preparedStatement.setString(3,dataSetCode);\n             count =preparedStatement.executeUpdate();\n             connection.close();\n        } catch (SQLException e) {\n            System.out.println(\"[\"+e.getMessage()+\"]\");\n        }\n        return count ==1;\n    }\n    @Override\n    public boolean deleteRoleNameSetCall(String rolesname, String dataSetCode) {\n        String deleteStr = \"DELETE FROM analysisplatform.set_callcolumn_role WHERE role =? AND dataset =?\";\n       int count = 0;\n        Connection connection = MySQLConnectionBean.getInstance().getDefaultConnection(Global.DatabaseName);\n        try {\n            PreparedStatement preparedStatement = connection.prepareStatement(deleteStr);\n            preparedStatement.setString(1,rolesname);\n            preparedStatement.setString(2,dataSetCode);\n            count =preparedStatement.executeUpdate();\n            connection.close();\n        } catch (SQLException e) {\n            System.out.println(\"[\"+e.getMessage()+\"]\");\n        }\n        return count ==1;\n    }\n    private int getCount(String queryStr) {\n        int count = 0;\n        Connection connection = MySQLConnectionBean.getInstance().getDefaultConnection(Global.DatabaseName);\n        try {\n            Statement statement = connection.createStatement();\n            ResultSet resultSet = statement.executeQuery(queryStr);\n            while (resultSet.next()){\n                count = resultSet.getInt(1);\n            }\n            connection.close();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n        return count;\n    }\n    private List<SetCallColumnInfoBean>  getCallColumnInfoBeanListByQueryStr(String queryStr) {\n        List<SetCallColumnInfoBean> setCallColumnInfoBeanList = new ArrayList<>();\n        Connection connection = MySQLConnectionBean.getInstance().getDefaultConnection(Global.DatabaseName);\n        try {\n            Statement statement = connection.createStatement();\n            ResultSet resultSet = statement.executeQuery(queryStr);\n            while (resultSet.next()){\n                SetCallColumnInfoBean setCallColumnInfoBean = new SetCallColumnInfoBean();\n                setCallColumnInfoBean.setId(resultSet.getInt(1));\n                setCallColumnInfoBean.setShow_sensitiveinfo(resultSet.getInt(2));\n                setCallColumnInfoBean.setDataset(resultSet.getString(3));\n                setCallColumnInfoBeanList.add(setCallColumnInfoBean);\n            }\n            connection.close();\n        } catch (SQLException e) {\n            System.out.println(\"[\"+e.getMessage()+\"]\");\n        }\n        return  setCallColumnInfoBeanList;\n    }\n"]]}
{"hexsha": "a8cfa4379d00fdcd850ba80ded5a1f5e6a76858d", "ext": "java", "lang": "Java", "content": "public final class zzgy\n{\n\n\tzzgy(long l, String s, int i)\n\t{\n\t//    0    0:aload_0         \n\t//    1    1:invokespecial   #15  <Method void Object()>\n\t\tvalue = l;\n\t//    2    4:aload_0         \n\t//    3    5:lload_1         \n\t//    4    6:putfield        #17  <Field long value>\n\t\tzzajf = s;\n\t//    5    9:aload_0         \n\t//    6   10:aload_3         \n\t//    7   11:putfield        #19  <Field String zzajf>\n\t\tzzajg = i;\n\t//    8   14:aload_0         \n\t//    9   15:iload           4\n\t//   10   17:putfield        #21  <Field int zzajg>\n\t//   11   20:return          \n\t}\n\n\tpublic final boolean equals(Object obj)\n\t{\n\t\tif(obj != null)\n\t//*   0    0:aload_1         \n\t//*   1    1:ifnull          43\n\t\t{\n\t\t\tif(!(obj instanceof zzgy))\n\t//*   2    4:aload_1         \n\t//*   3    5:instanceof      #2   <Class zzgy>\n\t//*   4    8:ifne            13\n\t\t\t\treturn false;\n\t//    5   11:iconst_0        \n\t//    6   12:ireturn         \n\t\t\tobj = ((Object) ((zzgy)obj));\n\t//    7   13:aload_1         \n\t//    8   14:checkcast       #2   <Class zzgy>\n\t//    9   17:astore_1        \n\t\t\tif(((zzgy) (obj)).value == value && ((zzgy) (obj)).zzajg == zzajg)\n\t//*  10   18:aload_1         \n\t//*  11   19:getfield        #17  <Field long value>\n\t//*  12   22:aload_0         \n\t//*  13   23:getfield        #17  <Field long value>\n\t//*  14   26:lcmp            \n\t//*  15   27:ifne            43\n\t//*  16   30:aload_1         \n\t//*  17   31:getfield        #21  <Field int zzajg>\n\t//*  18   34:aload_0         \n\t//*  19   35:getfield        #21  <Field int zzajg>\n\t//*  20   38:icmpne          43\n\t\t\t\treturn true;\n\t//   21   41:iconst_1        \n\t//   22   42:ireturn         \n\t\t}\n\t\treturn false;\n\t//   23   43:iconst_0        \n\t//   24   44:ireturn         \n\t}\n\n\tpublic final int hashCode()\n\t{\n\t\treturn (int)value;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #17  <Field long value>\n\t//    2    4:l2i             \n\t//    3    5:ireturn         \n\t}\n\n\tfinal long value;\n\tfinal String zzajf;\n\tfinal int zzajg;\n}", "class_id": 0, "repo": "Andreas237/AndroidPolicyAutomation", "file": "ExtractedJars/RT_News_com.rt.mobile.english/javafiles/com/google/android/gms/internal/ads/zzgy.java", "last_update_at": "2019-07-06T22:21:59+00:00", "question_id": "a8cfa4379d00fdcd850ba80ded5a1f5e6a76858d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class zzgy\n{\n\tzzgy(long l, String s, int i)\n\t{\n\t//    0    0:aload_0         \n\t//    1    1:invokespecial   #15  <Method void Object()>\n\t\tvalue = l;\n\t//    2    4:aload_0         \n\t//    3    5:lload_1         \n\t//    4    6:putfield        #17  <Field long value>\n\t\tzzajf = s;\n\t//    5    9:aload_0         \n\t//    6   10:aload_3         \n\t//    7   11:putfield        #19  <Field String zzajf>\n\t\tzzajg = i;\n\t//    8   14:aload_0         \n\t//    9   15:iload           4\n\t//   10   17:putfield        #21  <Field int zzajg>\n\t//   11   20:return          \n\t}\n\tpublic final boolean equals(Object obj)\n\t{\n\t\tif(obj != null)\n\t//*   0    0:aload_1         \n\t//*   1    1:ifnull          43\n\t\t{\n\t\t\tif(!(obj instanceof zzgy))\n\t//*   2    4:aload_1         \n\t//*   3    5:instanceof      #2   <Class zzgy>\n\t//*   4    8:ifne            13\n\t\t\t\treturn false;\n\t//    5   11:iconst_0        \n\t//    6   12:ireturn         \n\t\t\tobj = ((Object) ((zzgy)obj));\n\t//    7   13:aload_1         \n\t//    8   14:checkcast       #2   <Class zzgy>\n\t//    9   17:astore_1        \n\t\t\tif(((zzgy) (obj)).value == value && ((zzgy) (obj)).zzajg == zzajg)\n\t//*  10   18:aload_1         \n\t//*  11   19:getfield        #17  <Field long value>\n\t//*  12   22:aload_0         \n\t//*  13   23:getfield        #17  <Field long value>\n\t//*  14   26:lcmp            \n\t//*  15   27:ifne            43\n\t//*  16   30:aload_1         \n\t//*  17   31:getfield        #21  <Field int zzajg>\n\t//*  18   34:aload_0         \n\t//*  19   35:getfield        #21  <Field int zzajg>\n\t//*  20   38:icmpne          43\n\t\t\t\treturn true;\n\t//   21   41:iconst_1        \n\t//   22   42:ireturn         \n\t\t}\n\t\treturn false;\n\t//   23   43:iconst_0        \n\t//   24   44:ireturn         \n\t}\n\tpublic final int hashCode()\n\t{\n\t\treturn (int)value;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #17  <Field long value>\n\t//    2    4:l2i             \n\t//    3    5:ireturn         \n\t}\n\tfinal long value;\n\tfinal String zzajf;\n\tfinal int zzajg;\n"]]}
{"hexsha": "0189f1401135c38ee4bd5d4ebb276d6413b9ee3b", "ext": "java", "lang": "Java", "content": "@Stateless\npublic class MedioDePagoLogic {\n\n    private static final Logger LOGGER = Logger.getLogger(MedioDePagoLogic.class.getName());\n    \n    @Inject\n    private MedioDePagoPersistence persistence;\n    \n\n    /**\n     * Crea una nueva entidad MedioDePago.\n     * @param entity La entidad de tipo MedioDePago que se va a persistir.\n     * @return La entidad luego de persistirla.\n     * @throws BusinessLogicException Si ya existe un MedioDePago con esa\n     * informacion.\n     */\n    public MedioDePagoEntity createMedioDePago(MedioDePagoEntity entity) throws BusinessLogicException {\n        LOGGER.info(\"Inicia el proceso de creacion de un nuevo medio de pago\");\n        if(persistence.findByReferencia(entity.getNumeroReferencia()) != null)\n        {\n            throw new BusinessLogicException(\"Ya existe un medio de pago con ese numero de referencia:\" + entity.getNumeroReferencia());        \n        }\n        else if(persistence.findByTipo(entity.getTipo()) != null)\n        {\n            throw new BusinessLogicException(\"Ya existe un medio de pago con ese tipo:\" + entity.getTipo());\n        }\n        persistence.create(entity);\n        LOGGER.info(\"Termina el proceso de creacion del medio de pago\");\n        return entity;\n    }\n\n    /**\n     * *\n     * Obtiene todos los MedioDePago que hay en la base de datos.\n     * @return Lista de la entidades de tipo MedioDePago.\n     */\n    public List<MedioDePagoEntity> getMediosDePago()  {\n        LOGGER.info(\"Inicia el proceso de consultar todos los medio de pago\");\n        List<MedioDePagoEntity> list = persistence.findAll();\n        LOGGER.info(\"Termina el proceso de consultar todos los medio de pago\");\n        return list;\n    }\n\n    /**\n     * Obtiene un MedioDePago con el id especificado.\n     * @param id  Identificador del medio de pago.\n     * @return El MedioDePago correspondiente a el id.\n     */\n    public MedioDePagoEntity getMedioDePago(Long id) {\n        LOGGER.log(Level.INFO,\"Inicia el proceso de consultar un medio de pago con id={0}\", id);\n        MedioDePagoEntity medio = persistence.find(id);\n        if(medio == null)\n        {\n            LOGGER.log(Level.SEVERE, \"El medio de pago con el id={0} no existe\", id);\n        }\n        return  medio;\n    }\n\n    /**\n     * Actualiza un MedioDePago con el id dado.\n     * @param id Identificador del medio de pago.\n     * @param entity Nueva informacion del MedioDePago.\n     * @return La entidad MedioDePago con la nueva informacion.\n     * @throws BusinessLogicException Excepciones por reglas de negocio.\n     */   \n    public MedioDePagoEntity updateMedioDePago(Long id, MedioDePagoEntity entity) throws BusinessLogicException {\n        LOGGER.log(Level.SEVERE, \"Inicia el proceso de actualizar un medio de pago\");\n        MedioDePagoEntity medio = persistence.find(id);\n        if(medio == null)\n        {\n            LOGGER.log(Level.SEVERE, \"El medio de pago con el id={0} no existe para ser actualizado\", entity.getId());\n        }\n        else if (persistence.findByReferencia(entity.getNumeroReferencia()) != null)\n        {\n          throw new BusinessLogicException(\"Ya existe un medio de pago con ese numero de referencia:\" + entity.getNumeroReferencia());        \n        }\n        else if(persistence.findByTipo(entity.getTipo()) != null)\n        {\n            throw new BusinessLogicException(\"Ya existe un medio de pago con ese tipo:\" + entity.getTipo());\n        }\n        persistence.update(entity);\n        return entity;\n    }\n\n    /**\n     * *\n     * Elimina un MedioDePago segun el id.\n     * @param id Identificador del MedioDePago a eliminar.\n     */\n    public void deleteMedioDePago( Long id) {\n        LOGGER.log(Level.SEVERE, \"Inicia el proceso de eliminar un cliente\");\n        MedioDePagoEntity medio = persistence.find(id); \n        if(medio == null)\n        {\n            LOGGER.log(Level.SEVERE, \"El medio de pago con el id={0} no existe para ser elimiado\", id);\n        }\n        persistence.delete(id);\n        LOGGER.log(Level.SEVERE, \"Termina el proceso de eliminar un medui de pago\");    \n    }\n\n    /**\n     * Obtiene una coleccion de las instacias de cliente asociadas a un medio de pago.\n     * @param id Identificador del medio pago.\n     * @return Coleccion de las instacias de clientes asociadas a un medio de pago.\n     */\n    public List<ClienteEntity> listClientes (Long id)\n    {\n        LOGGER.log(Level.INFO, \"Inicia proceso de consultar todos los clientes del medio de pago con id = {0}\", id);\n        return getMedioDePago(id).getClientes();\n    }\n    \n    /**\n     * Obtiene un cliente existente asociado a un medio de pago especifico.\n     * @param id Identificador del medio de pago.\n     * @param clienteId Identificador del cliente.\n     * @return La instancia de cliente asociado al medio de pago.\n     */\n    public ClienteEntity getCliente (Long id, Long clienteId){\n       LOGGER.log(Level.INFO, \"Inicia proceso de consultar un cliente que utiliza el medio de pago con id = {0}\", id);\n       List<ClienteEntity> list = getMedioDePago(id).getClientes();\n       ClienteEntity clientesEntity = new ClienteEntity();\n       clientesEntity.setId(clienteId);\n       int index = list.indexOf(clientesEntity);\n        if (index >= 0) {\n            return list.get(index);\n        }\n        return null;\n   }\n   \n    /**\n     * Asocia un cliente a un medio de pago especifico.\n     * @param id Identificador del medio de pago.\n     * @param clienteId Identificador del cliente a asociar.\n     * @return El cliente ahora asociado al medio de pago.\n     */\n   public ClienteEntity addCliente(Long id, Long clienteId){\n       MedioDePagoEntity medio = getMedioDePago(id);\n       ClienteEntity cliente = new ClienteEntity();\n       cliente.setId(clienteId);\n       medio.getClientes().add(cliente);\n       return getCliente(id, clienteId);\n   }\n   \n   /**\n    * Reeplaza la informacion de los clientes asociados al medio de pago.\n    * @param id Identificador del medio de pago.\n    * @param  list Coleccion de clientes con la nueva informacion a actualizar\n     * respecto a los clientes asociados.\n    * @return Los clientes asociados al medio de pago.\n    */\n   public List<ClienteEntity> replaceCliente (Long id, List<ClienteEntity> list){\n       MedioDePagoEntity medio = getMedioDePago(id);\n       medio.setClientes(list);\n       return medio.getClientes();\n   }\n   \n   /**\n    * Desasocia un cliente existente de un medio de pago.\n    * @param id Identificador del medio de pago\n    * @param clienteId Identificador del cliente a retirar.\n    */\n   public void removeCliente(Long id, Long clienteId){\n       MedioDePagoEntity medio = getMedioDePago(id);\n       ClienteEntity cliente = new ClienteEntity();\n       cliente.setId(clienteId);\n       medio.getClientes().remove(cliente);\n   }\n}", "class_id": 0, "repo": "Uniandes-isis2603/s1_201820_sierra", "file": "sierra-back/src/main/java/co/edu/uniandes/csw/sierra/ejb/MedioDePagoLogic.java", "last_update_at": "2019-09-23T19:18:48+00:00", "question_id": "0189f1401135c38ee4bd5d4ebb276d6413b9ee3b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Stateless\npublic class MedioDePagoLogic {\n    private static final Logger LOGGER = Logger.getLogger(MedioDePagoLogic.class.getName());\n    @Inject\n    private MedioDePagoPersistence persistence;\n    /**\n     * Crea una nueva entidad MedioDePago.\n     * @param entity La entidad de tipo MedioDePago que se va a persistir.\n     * @return La entidad luego de persistirla.\n     * @throws BusinessLogicException Si ya existe un MedioDePago con esa\n     * informacion.\n     */\n    public MedioDePagoEntity createMedioDePago(MedioDePagoEntity entity) throws BusinessLogicException {\n        LOGGER.info(\"Inicia el proceso de creacion de un nuevo medio de pago\");\n        if(persistence.findByReferencia(entity.getNumeroReferencia()) != null)\n        {\n            throw new BusinessLogicException(\"Ya existe un medio de pago con ese numero de referencia:\" + entity.getNumeroReferencia());        \n        }\n        else if(persistence.findByTipo(entity.getTipo()) != null)\n        {\n            throw new BusinessLogicException(\"Ya existe un medio de pago con ese tipo:\" + entity.getTipo());\n        }\n        persistence.create(entity);\n        LOGGER.info(\"Termina el proceso de creacion del medio de pago\");\n        return entity;\n    }\n    /**\n     * *\n     * Obtiene todos los MedioDePago que hay en la base de datos.\n     * @return Lista de la entidades de tipo MedioDePago.\n     */\n    public List<MedioDePagoEntity> getMediosDePago()  {\n        LOGGER.info(\"Inicia el proceso de consultar todos los medio de pago\");\n        List<MedioDePagoEntity> list = persistence.findAll();\n        LOGGER.info(\"Termina el proceso de consultar todos los medio de pago\");\n        return list;\n    }\n    /**\n     * Obtiene un MedioDePago con el id especificado.\n     * @param id  Identificador del medio de pago.\n     * @return El MedioDePago correspondiente a el id.\n     */\n    public MedioDePagoEntity getMedioDePago(Long id) {\n        LOGGER.log(Level.INFO,\"Inicia el proceso de consultar un medio de pago con id={0}\", id);\n        MedioDePagoEntity medio = persistence.find(id);\n        if(medio == null)\n        {\n            LOGGER.log(Level.SEVERE, \"El medio de pago con el id={0} no existe\", id);\n        }\n        return  medio;\n    }\n    /**\n     * Actualiza un MedioDePago con el id dado.\n     * @param id Identificador del medio de pago.\n     * @param entity Nueva informacion del MedioDePago.\n     * @return La entidad MedioDePago con la nueva informacion.\n     * @throws BusinessLogicException Excepciones por reglas de negocio.\n     */   \n    public MedioDePagoEntity updateMedioDePago(Long id, MedioDePagoEntity entity) throws BusinessLogicException {\n        LOGGER.log(Level.SEVERE, \"Inicia el proceso de actualizar un medio de pago\");\n        MedioDePagoEntity medio = persistence.find(id);\n        if(medio == null)\n        {\n            LOGGER.log(Level.SEVERE, \"El medio de pago con el id={0} no existe para ser actualizado\", entity.getId());\n        }\n        else if (persistence.findByReferencia(entity.getNumeroReferencia()) != null)\n        {\n          throw new BusinessLogicException(\"Ya existe un medio de pago con ese numero de referencia:\" + entity.getNumeroReferencia());        \n        }\n        else if(persistence.findByTipo(entity.getTipo()) != null)\n        {\n            throw new BusinessLogicException(\"Ya existe un medio de pago con ese tipo:\" + entity.getTipo());\n        }\n        persistence.update(entity);\n        return entity;\n    }\n    /**\n     * *\n     * Elimina un MedioDePago segun el id.\n     * @param id Identificador del MedioDePago a eliminar.\n     */\n    public void deleteMedioDePago( Long id) {\n        LOGGER.log(Level.SEVERE, \"Inicia el proceso de eliminar un cliente\");\n        MedioDePagoEntity medio = persistence.find(id); \n        if(medio == null)\n        {\n            LOGGER.log(Level.SEVERE, \"El medio de pago con el id={0} no existe para ser elimiado\", id);\n        }\n        persistence.delete(id);\n        LOGGER.log(Level.SEVERE, \"Termina el proceso de eliminar un medui de pago\");    \n    }\n    /**\n     * Obtiene una coleccion de las instacias de cliente asociadas a un medio de pago.\n     * @param id Identificador del medio pago.\n     * @return Coleccion de las instacias de clientes asociadas a un medio de pago.\n     */\n    public List<ClienteEntity> listClientes (Long id)\n    {\n        LOGGER.log(Level.INFO, \"Inicia proceso de consultar todos los clientes del medio de pago con id = {0}\", id);\n        return getMedioDePago(id).getClientes();\n    }\n    /**\n     * Obtiene un cliente existente asociado a un medio de pago especifico.\n     * @param id Identificador del medio de pago.\n     * @param clienteId Identificador del cliente.\n     * @return La instancia de cliente asociado al medio de pago.\n     */\n    public ClienteEntity getCliente (Long id, Long clienteId){\n       LOGGER.log(Level.INFO, \"Inicia proceso de consultar un cliente que utiliza el medio de pago con id = {0}\", id);\n       List<ClienteEntity> list = getMedioDePago(id).getClientes();\n       ClienteEntity clientesEntity = new ClienteEntity();\n       clientesEntity.setId(clienteId);\n       int index = list.indexOf(clientesEntity);\n        if (index >= 0) {\n            return list.get(index);\n        }\n        return null;\n   }\n    /**\n     * Asocia un cliente a un medio de pago especifico.\n     * @param id Identificador del medio de pago.\n     * @param clienteId Identificador del cliente a asociar.\n     * @return El cliente ahora asociado al medio de pago.\n     */\n   public ClienteEntity addCliente(Long id, Long clienteId){\n       MedioDePagoEntity medio = getMedioDePago(id);\n       ClienteEntity cliente = new ClienteEntity();\n       cliente.setId(clienteId);\n       medio.getClientes().add(cliente);\n       return getCliente(id, clienteId);\n   }\n   /**\n    * Reeplaza la informacion de los clientes asociados al medio de pago.\n    * @param id Identificador del medio de pago.\n    * @param  list Coleccion de clientes con la nueva informacion a actualizar\n     * respecto a los clientes asociados.\n    * @return Los clientes asociados al medio de pago.\n    */\n   public List<ClienteEntity> replaceCliente (Long id, List<ClienteEntity> list){\n       MedioDePagoEntity medio = getMedioDePago(id);\n       medio.setClientes(list);\n       return medio.getClientes();\n   }\n   /**\n    * Desasocia un cliente existente de un medio de pago.\n    * @param id Identificador del medio de pago\n    * @param clienteId Identificador del cliente a retirar.\n    */\n   public void removeCliente(Long id, Long clienteId){\n       MedioDePagoEntity medio = getMedioDePago(id);\n       ClienteEntity cliente = new ClienteEntity();\n       cliente.setId(clienteId);\n       medio.getClientes().remove(cliente);\n   }\n"]]}
{"hexsha": "e13ef3b5b38848d557b2834b678da71689547c16", "ext": "java", "lang": "Java", "content": "public class ScreenUtil {\n\n    /**\n     * \u83b7\u53d6\u5c4f\u5e55\u50cf\u7d20\n     *\n     * @param context\n     * @return widthPixels, heightPixels\n     */\n    public static int[] getPixels(Context context) {\n        WindowManager windowManager =\n                (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);\n        if (windowManager == null) return new int[]{0, 0};\n        DisplayMetrics metrics = new DisplayMetrics();\n        windowManager.getDefaultDisplay().getMetrics(metrics);\n        return new int[]{metrics.widthPixels, metrics.heightPixels};\n    }\n}", "class_id": 0, "repo": "fengjixuchui/Android-PermissionMaster", "file": "app/src/main/java/com/jeanboy/app/permissionmaster/utils/ScreenUtil.java", "last_update_at": "2019-12-26T08:49:38+00:00", "question_id": "e13ef3b5b38848d557b2834b678da71689547c16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ScreenUtil {\n    /**\n     * \u83b7\u53d6\u5c4f\u5e55\u50cf\u7d20\n     *\n     * @param context\n     * @return widthPixels, heightPixels\n     */\n    public static int[] getPixels(Context context) {\n        WindowManager windowManager =\n                (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);\n        if (windowManager == null) return new int[]{0, 0};\n        DisplayMetrics metrics = new DisplayMetrics();\n        windowManager.getDefaultDisplay().getMetrics(metrics);\n        return new int[]{metrics.widthPixels, metrics.heightPixels};\n    }\n"]]}
{"hexsha": "917400709796e064927d1b178ebdc081bcd4b3c3", "ext": "java", "lang": "Java", "content": "@Controller\n@RequestMapping(\"/mps/route\")\npublic class ZuulRouteController extends AbstractController<SysZuulRouteService,SysZuulRoute> {\n\n    @Override\n    protected String getTemplatePath() {\n        return \"ftl/mps/route/\";\n    }\n\n    @Override\n    protected QueryWrapper<SysZuulRoute> getSearchQW(String search, Model model) {\n        QueryWrapper<SysZuulRoute> qw = new QueryWrapper<SysZuulRoute>();\n        if(StringUtils.isNotBlank(search)){\n            qw.like(\"service_id\",search);\n            model.addAttribute(\"service_id\",search);\n        }\n        return qw;\n    }\n}", "class_id": 0, "repo": "thyhero/alpha", "file": "alpha-console/alpha-console-mps/src/main/java/com/geektcp/alpha/console/mps/controller/ZuulRouteController.java", "last_update_at": "2019-06-15T01:24:25+00:00", "question_id": "917400709796e064927d1b178ebdc081bcd4b3c3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Controller\n@RequestMapping(\"/mps/route\")\npublic class ZuulRouteController extends AbstractController<SysZuulRouteService,SysZuulRoute> {\n    @Override\n    protected String getTemplatePath() {\n        return \"ftl/mps/route/\";\n    }\n    @Override\n    protected QueryWrapper<SysZuulRoute> getSearchQW(String search, Model model) {\n        QueryWrapper<SysZuulRoute> qw = new QueryWrapper<SysZuulRoute>();\n        if(StringUtils.isNotBlank(search)){\n            qw.like(\"service_id\",search);\n            model.addAttribute(\"service_id\",search);\n        }\n        return qw;\n    }\n"]]}
{"hexsha": "6c8ed5d664bd30f98777278940562ce4677360c8", "ext": "java", "lang": "Java", "content": "public class StringWebResponse extends WebResponse {\n\n    private boolean fromJavascript_;\n\n    /**\n     * Creates an instance associated with the specified originating URL.\n     * @param content the content to return\n     * @param originatingURL the URL that this should be associated with\n     */\n    public StringWebResponse(final String content, final URL originatingURL) {\n        // use UTF-8 here to be sure, all chars in the string are part of the charset\n        this(content, UTF_8, originatingURL);\n    }\n\n    /**\n     * Creates an instance associated with the specified originating URL.\n     * @param content the content to return\n     * @param charset the charset used to convert the content\n     * @param originatingURL the URL that this should be associated with\n     */\n    public StringWebResponse(final String content, final Charset charset, final URL originatingURL) {\n        super(getWebResponseData(content, charset), buildWebRequest(originatingURL, charset), 0);\n    }\n\n    /**\n     * Helper method for constructors. Converts the specified string into {@link WebResponseData}\n     * with other defaults specified.\n     *\n     * @param contentString the string to be converted to a <tt>WebResponseData</tt>\n     * @return a simple <tt>WebResponseData</tt> with defaults specified\n     */\n    private static WebResponseData getWebResponseData(final String contentString, final Charset charset) {\n        final byte[] content = TextUtils.stringToByteArray(contentString, charset);\n        final List<NameValuePair> compiledHeaders = new ArrayList<>();\n        compiledHeaders.add(new NameValuePair(HttpHeader.CONTENT_TYPE, \"text/html; charset=\" + charset));\n        return new WebResponseData(content, HttpStatus.SC_OK, \"OK\", compiledHeaders);\n    }\n\n    private static WebRequest buildWebRequest(final URL originatingURL, final Charset charset) {\n        final WebRequest webRequest = new WebRequest(originatingURL, HttpMethod.GET);\n        webRequest.setCharset(charset);\n        return webRequest;\n    }\n\n    /**\n     * Returns the fromJavascript property. This is true, if the response was created\n     * from javascript (usually document.write).\n     * @return the from fromJavascript_\n     */\n    public boolean isFromJavascript() {\n        return fromJavascript_;\n    }\n\n    /**\n     * Sets the fromJavascript_ property. Set this to true, if the response was created\n     * from javascript (usually document.write).\n     * @param fromJavascript the new fromJavascript\n     */\n    public void setFromJavascript(final boolean fromJavascript) {\n        fromJavascript_ = fromJavascript;\n    }\n}", "class_id": 0, "repo": "codingotaku/htmlunit", "file": "src/main/java/com/gargoylesoftware/htmlunit/StringWebResponse.java", "last_update_at": "2019-08-29T10:21:10+00:00", "question_id": "6c8ed5d664bd30f98777278940562ce4677360c8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class StringWebResponse extends WebResponse {\n    private boolean fromJavascript_;\n    /**\n     * Creates an instance associated with the specified originating URL.\n     * @param content the content to return\n     * @param originatingURL the URL that this should be associated with\n     */\n    public StringWebResponse(final String content, final URL originatingURL) {\n        // use UTF-8 here to be sure, all chars in the string are part of the charset\n        this(content, UTF_8, originatingURL);\n    }\n    /**\n     * Creates an instance associated with the specified originating URL.\n     * @param content the content to return\n     * @param charset the charset used to convert the content\n     * @param originatingURL the URL that this should be associated with\n     */\n    public StringWebResponse(final String content, final Charset charset, final URL originatingURL) {\n        super(getWebResponseData(content, charset), buildWebRequest(originatingURL, charset), 0);\n    }\n    /**\n     * Helper method for constructors. Converts the specified string into {@link WebResponseData}\n     * with other defaults specified.\n     *\n     * @param contentString the string to be converted to a <tt>WebResponseData</tt>\n     * @return a simple <tt>WebResponseData</tt> with defaults specified\n     */\n    private static WebResponseData getWebResponseData(final String contentString, final Charset charset) {\n        final byte[] content = TextUtils.stringToByteArray(contentString, charset);\n        final List<NameValuePair> compiledHeaders = new ArrayList<>();\n        compiledHeaders.add(new NameValuePair(HttpHeader.CONTENT_TYPE, \"text/html; charset=\" + charset));\n        return new WebResponseData(content, HttpStatus.SC_OK, \"OK\", compiledHeaders);\n    }\n    private static WebRequest buildWebRequest(final URL originatingURL, final Charset charset) {\n        final WebRequest webRequest = new WebRequest(originatingURL, HttpMethod.GET);\n        webRequest.setCharset(charset);\n        return webRequest;\n    }\n    /**\n     * Returns the fromJavascript property. This is true, if the response was created\n     * from javascript (usually document.write).\n     * @return the from fromJavascript_\n     */\n    public boolean isFromJavascript() {\n        return fromJavascript_;\n    }\n    /**\n     * Sets the fromJavascript_ property. Set this to true, if the response was created\n     * from javascript (usually document.write).\n     * @param fromJavascript the new fromJavascript\n     */\n    public void setFromJavascript(final boolean fromJavascript) {\n        fromJavascript_ = fromJavascript;\n    }\n"]]}
{"hexsha": "fa4045814253d6f037396762201ba96f22972330", "ext": "java", "lang": "Java", "content": "@UseAgent\npublic class GrpcTest extends AiJarSmokeTest {\n\n  @Test\n  @TargetUri(\"/simple\")\n  public void doSimpleTest() throws Exception {\n    List<Envelope> rdList = mockedIngestion.waitForItems(\"RequestData\", 2);\n\n    Envelope rdEnvelope1 = getRequestEnvelope(rdList, \"GET /simple\");\n    Envelope rdEnvelope2 = getRequestEnvelope(rdList, \"example.Greeter/SayHello\");\n    String operationId = rdEnvelope1.getTags().get(\"ai.operation.id\");\n\n    List<Envelope> rddList =\n        mockedIngestion.waitForItemsInOperation(\"RemoteDependencyData\", 1, operationId);\n    // auto-collected grpc events are suppressed by exporter because they are noisy\n    assertEquals(0, mockedIngestion.getCountForType(\"MessageData\", operationId));\n\n    Envelope rddEnvelope = getDependencyEnvelope(rddList, \"example.Greeter/SayHello\");\n\n    RequestData rd1 = (RequestData) ((Data<?>) rdEnvelope1.getData()).getBaseData();\n    RemoteDependencyData rdd =\n        (RemoteDependencyData) ((Data<?>) rddEnvelope.getData()).getBaseData();\n\n    assertEquals(\"localhost:10203\", rdd.getTarget());\n\n    assertTrue(rd1.getProperties().isEmpty());\n    assertTrue(rd1.getSuccess());\n\n    assertTrue(rdd.getProperties().isEmpty());\n    assertTrue(rdd.getSuccess());\n\n    // TODO (trask): verify rd2\n\n    assertParentChild(rd1, rdEnvelope1, rddEnvelope, \"GET /simple\");\n    assertParentChild(\n        rdd.getId(), rddEnvelope, rdEnvelope2, \"GET /simple\", \"example.Greeter/SayHello\", false);\n  }\n\n  @Test\n  @TargetUri(\"/conversation\")\n  public void doConversationTest() throws Exception {\n    List<Envelope> rdList = mockedIngestion.waitForItems(\"RequestData\", 2);\n\n    Envelope rdEnvelope1 = getRequestEnvelope(rdList, \"GET /conversation\");\n    Envelope rdEnvelope2 = getRequestEnvelope(rdList, \"example.Greeter/Conversation\");\n    String operationId = rdEnvelope1.getTags().get(\"ai.operation.id\");\n\n    List<Envelope> rddList =\n        mockedIngestion.waitForItemsInOperation(\"RemoteDependencyData\", 1, operationId);\n    // auto-collected grpc events are suppressed by exporter because they are noisy\n    assertEquals(0, mockedIngestion.getCountForType(\"MessageData\", operationId));\n\n    Envelope rddEnvelope = getDependencyEnvelope(rddList, \"example.Greeter/Conversation\");\n\n    RequestData rd1 = (RequestData) ((Data<?>) rdEnvelope1.getData()).getBaseData();\n    RemoteDependencyData rdd =\n        (RemoteDependencyData) ((Data<?>) rddEnvelope.getData()).getBaseData();\n\n    assertEquals(\"localhost:10203\", rdd.getTarget());\n\n    assertTrue(rd1.getProperties().isEmpty());\n    assertTrue(rd1.getSuccess());\n\n    assertTrue(rdd.getProperties().isEmpty());\n    assertTrue(rdd.getSuccess());\n\n    // TODO (trask): verify rd2\n\n    assertParentChild(rd1, rdEnvelope1, rddEnvelope, \"GET /conversation\");\n    assertParentChild(\n        rdd.getId(),\n        rddEnvelope,\n        rdEnvelope2,\n        \"GET /conversation\",\n        \"example.Greeter/Conversation\",\n        false);\n  }\n\n  private static Envelope getRequestEnvelope(List<Envelope> envelopes, String name) {\n    for (Envelope envelope : envelopes) {\n      RequestData rd = (RequestData) ((Data<?>) envelope.getData()).getBaseData();\n      if (rd.getName().equals(name)) {\n        return envelope;\n      }\n    }\n    throw new IllegalStateException(\"Could not find request with name: \" + name);\n  }\n\n  private static Envelope getDependencyEnvelope(List<Envelope> envelopes, String name) {\n    for (Envelope envelope : envelopes) {\n      RemoteDependencyData rdd =\n          (RemoteDependencyData) ((Data<?>) envelope.getData()).getBaseData();\n      if (rdd.getName().equals(name)) {\n        return envelope;\n      }\n    }\n    throw new IllegalStateException(\"Could not find dependency with name: \" + name);\n  }\n}", "class_id": 0, "repo": "Microsoft/ApplicationInsights-Java", "file": "smoke-tests/apps/gRPC/src/smokeTest/java/com/microsoft/applicationinsights/smoketest/GrpcTest.java", "last_update_at": "2019-05-06T17:19:36+00:00", "question_id": "fa4045814253d6f037396762201ba96f22972330", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@UseAgent\npublic class GrpcTest extends AiJarSmokeTest {\n  @Test\n  @TargetUri(\"/simple\")\n  public void doSimpleTest() throws Exception {\n    List<Envelope> rdList = mockedIngestion.waitForItems(\"RequestData\", 2);\n    Envelope rdEnvelope1 = getRequestEnvelope(rdList, \"GET /simple\");\n    Envelope rdEnvelope2 = getRequestEnvelope(rdList, \"example.Greeter/SayHello\");\n    String operationId = rdEnvelope1.getTags().get(\"ai.operation.id\");\n    List<Envelope> rddList =\n        mockedIngestion.waitForItemsInOperation(\"RemoteDependencyData\", 1, operationId);\n    // auto-collected grpc events are suppressed by exporter because they are noisy\n    assertEquals(0, mockedIngestion.getCountForType(\"MessageData\", operationId));\n    Envelope rddEnvelope = getDependencyEnvelope(rddList, \"example.Greeter/SayHello\");\n    RequestData rd1 = (RequestData) ((Data<?>) rdEnvelope1.getData()).getBaseData();\n    RemoteDependencyData rdd =\n        (RemoteDependencyData) ((Data<?>) rddEnvelope.getData()).getBaseData();\n    assertEquals(\"localhost:10203\", rdd.getTarget());\n    assertTrue(rd1.getProperties().isEmpty());\n    assertTrue(rd1.getSuccess());\n    assertTrue(rdd.getProperties().isEmpty());\n    assertTrue(rdd.getSuccess());\n    // TODO (trask): verify rd2\n    assertParentChild(rd1, rdEnvelope1, rddEnvelope, \"GET /simple\");\n    assertParentChild(\n        rdd.getId(), rddEnvelope, rdEnvelope2, \"GET /simple\", \"example.Greeter/SayHello\", false);\n  }\n  @Test\n  @TargetUri(\"/conversation\")\n  public void doConversationTest() throws Exception {\n    List<Envelope> rdList = mockedIngestion.waitForItems(\"RequestData\", 2);\n    Envelope rdEnvelope1 = getRequestEnvelope(rdList, \"GET /conversation\");\n    Envelope rdEnvelope2 = getRequestEnvelope(rdList, \"example.Greeter/Conversation\");\n    String operationId = rdEnvelope1.getTags().get(\"ai.operation.id\");\n    List<Envelope> rddList =\n        mockedIngestion.waitForItemsInOperation(\"RemoteDependencyData\", 1, operationId);\n    // auto-collected grpc events are suppressed by exporter because they are noisy\n    assertEquals(0, mockedIngestion.getCountForType(\"MessageData\", operationId));\n    Envelope rddEnvelope = getDependencyEnvelope(rddList, \"example.Greeter/Conversation\");\n    RequestData rd1 = (RequestData) ((Data<?>) rdEnvelope1.getData()).getBaseData();\n    RemoteDependencyData rdd =\n        (RemoteDependencyData) ((Data<?>) rddEnvelope.getData()).getBaseData();\n    assertEquals(\"localhost:10203\", rdd.getTarget());\n    assertTrue(rd1.getProperties().isEmpty());\n    assertTrue(rd1.getSuccess());\n    assertTrue(rdd.getProperties().isEmpty());\n    assertTrue(rdd.getSuccess());\n    // TODO (trask): verify rd2\n    assertParentChild(rd1, rdEnvelope1, rddEnvelope, \"GET /conversation\");\n    assertParentChild(\n        rdd.getId(),\n        rddEnvelope,\n        rdEnvelope2,\n        \"GET /conversation\",\n        \"example.Greeter/Conversation\",\n        false);\n  }\n  private static Envelope getRequestEnvelope(List<Envelope> envelopes, String name) {\n    for (Envelope envelope : envelopes) {\n      RequestData rd = (RequestData) ((Data<?>) envelope.getData()).getBaseData();\n      if (rd.getName().equals(name)) {\n        return envelope;\n      }\n    }\n    throw new IllegalStateException(\"Could not find request with name: \" + name);\n  }\n  private static Envelope getDependencyEnvelope(List<Envelope> envelopes, String name) {\n    for (Envelope envelope : envelopes) {\n      RemoteDependencyData rdd =\n          (RemoteDependencyData) ((Data<?>) envelope.getData()).getBaseData();\n      if (rdd.getName().equals(name)) {\n        return envelope;\n      }\n    }\n    throw new IllegalStateException(\"Could not find dependency with name: \" + name);\n  }\n"]]}
{"hexsha": "1de105c2e58ab13258f4f9e3b1de5ea89fa6c1f0", "ext": "java", "lang": "Java", "content": "public class CaptureVideo extends javax.microedition.lcdui.Canvas implements CommandListener, WorkflowElement, ActionListener, Showable {\r\n\tprivate Capture capture;\r\n\tprivate VideoControl vidc;\r\n\tprivate Command cmStart;\r\n\tprivate Command cmStop;\r\n\tprivate Command cmCancel;\r\n\tprivate Handler handler;\r\n\r\n\tpublic static final int OK = 1;\r\n\tpublic static final int CANCEL = 2;\r\n\t\r\n\tpublic CaptureVideo() {\r\n\t\tcapture = new Capture(this);\r\n\t    cmStart = new Command(\"Start\", Command.OK, 1);\r\n\t    cmStop = new Command(\"Stop\", Command.OK, 2);\r\n\t    cmCancel = new Command(\"Cancel\", Command.CANCEL, 3);\r\n\t    addCommand(cmStart);\r\n\t    addCommand(cmCancel);\r\n\t    setCommandListener(this);\t    \r\n\t}\r\n\r\n\tpublic void setHandler(Handler handler) {\r\n\t\tthis.handler = handler;\r\n\t}\r\n\t\r\n\tprotected void showNotify() {\r\n\t\ttry {\r\n\t\t\tif (capture.state == Capture.INIT) {\r\n\t\t\t\tinitPlayer();\r\n\t\t\t\tif (!Settings.getBool(Settings.VIDEO_CAPTURE_RECORD_BEFORE_PLAY)) {\r\n\t\t\t\t\tinitRecording();\r\n\t\t\t\t}\r\n\t\t\t\tstartPlayer();\r\n\t\t\t\tcapture.state = Capture.STARTING;\r\n\t\t\t}\r\n\t\t} catch (PavoException e) {\r\n\t\t\thandle(e);\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic void commandAction(Command c, Displayable d) {\r\n\t\tif (c == cmStart) {\r\n\t\t\tremoveCommand(cmStart);\r\n\t\t\taddCommand(cmStop);\r\n\t\t\tactionPerformed(new ActionEvent(cmStart));\r\n\t\t} else if (c == cmStop) {\r\n\t\t\tactionPerformed(new ActionEvent(cmStop));\r\n\t\t} else if (c == cmCancel) {\r\n\t\t\tcapture.abortRecording();\r\n\t\t\tcapture.state = Capture.FINISHED;\r\n\t\t\thandle(new Params().set(\"result\", Handler.CANCEL));\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic synchronized void actionPerformed(ActionEvent ev) {\r\n\t\ttry {\r\n\t\t\tswitch (capture.state) {\r\n\t\t\tcase Capture.STARTING:\r\n\t\t\t\tif(Settings.getBool(Settings.VIDEO_CAPTURE_RECORD_BEFORE_PLAY)) {\r\n\t\t\t\t\tteardownPlayer();\r\n\t\t\t\t\tinitPlayer();\r\n\t\t\t\t\tinitRecording();\r\n\t\t\t\t\tstartRecording();\r\n\t\t\t\t\tstartPlayer();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstartRecording();\r\n\t\t\t\t}\r\n\t\t        capture.state = Capture.CAPTURING;\r\n\t\t\t\tbreak;\r\n\t\t\tcase Capture.CAPTURING:\r\n\t\t\t\tfinishRecording();\r\n\t\t\t\tbreak;\r\n\t\t\tcase Capture.COMMITED:\r\n\t\t\t\tfinishRecording();\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t} catch (PavoException e) {\r\n\t\t\tif(capture.state == Capture.CAPTURING || capture.state == Capture.COMMITED) {\r\n\t\t\t\ttry { capture.abortRecording();\t} catch (Exception ee) { }\r\n\t\t\t}\r\n\t\t\thandle(e);\r\n\t\t}\r\n\t}\r\n\r\n\tvoid initPlayer() throws PavoException {\r\n\t\tcapture.initPlayer(Settings.getString(Settings.DEVICE_VIDEO));\r\n\t\tvidc = (VideoControl) ((Player) capture.player).getControl(\"VideoControl\");\r\n\t\tvidc.initDisplayMode(VideoControl.USE_DIRECT_VIDEO, this);\r\n\t\ttry {vidc.setDisplayFullScreen(Settings.getBool(Settings.VIDEO_CAPTURE_FULLSCREEN));} catch (Exception e) { throw new PavoException(\"setFullscreen\", e); }\r\n\t\tvidc.setVisible(true);\r\n\t}\r\n\t\r\n\tvoid initRecording() throws PavoException {\r\n\t\tcapture.initRecordControl(Settings.getString(Settings.VIDEO_CAPTURE_DIR) + \"pavotmp.3gp\");\r\n\t\tcapture.setRecordSizeLimit(Settings.getInt(Settings.VIDEO_CAPTURE_SIZE_LIMIT));\r\n\t}\r\n\t\r\n\tvoid startPlayer() throws PavoException {\r\n\t\ttry { capture.player.start(); } catch (Exception e) { throw new PavoException(\"playerStart\", e); }\r\n\t}\r\n\t\r\n\tvoid startRecording() throws PavoException {\r\n        capture.recordControl.startRecord();\r\n\t}\r\n\t\t\r\n\tvoid teardownPlayer() {\r\n\t\tvidc.setVisible(false);\r\n\t\tcapture.stopPlayer();\r\n\t\tvidc = null;\r\n\t}\r\n\t\r\n\tvoid finishRecording() throws PavoException {\r\n\t\tif(capture.state == Capture.CAPTURING) {\r\n\t\t\tcapture.commitRecording();\t\r\n\t\t}\r\n\t\tteardownPlayer();\r\n\t\tcapture.state = Capture.FINISHED;\r\n\t\t// doing this or will get Prefetch error -14 on nokia n95\r\n\t\tjavax.microedition.lcdui.Display.getDisplay(Main.INSTANCE).setCurrent(new DummyCanvas());\r\n\t\thandle(new Params().set(\"result\", Handler.OK).set(\"content-type\", capture.getContentType()).set(\"file\", capture.getResult()));\r\n\t}\r\n\t\r\n\tprivate void handle(Params result) {\r\n\t\tif(handler != null) {\r\n\t\t\thandler.handle(result);\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate void handle(PavoException e) {\r\n\t\tConnection.sendException(this, e);\r\n\t\thandle(new Params().set(\"result\", Handler.ERROR).set(\"exception\", e));\r\n\t}\r\n\r\n\tprotected void paint(Graphics arg0) {\r\n\t}\r\n\t\r\n\tpublic void show() {\r\n\t\tjavax.microedition.lcdui.Display.getDisplay(Main.INSTANCE).setCurrent(this);\r\n\t}\r\n\t\r\n}", "class_id": 0, "repo": "ak1394/pavome-client", "file": "src-midp/me/pavo/ui/CaptureVideo.java", "last_update_at": "2019-12-04T00:33:52+00:00", "question_id": "1de105c2e58ab13258f4f9e3b1de5ea89fa6c1f0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CaptureVideo extends javax.microedition.lcdui.Canvas implements CommandListener, WorkflowElement, ActionListener, Showable {\r\n\tprivate Capture capture;\r\n\tprivate VideoControl vidc;\r\n\tprivate Command cmStart;\r\n\tprivate Command cmStop;\r\n\tprivate Command cmCancel;\r\n\tprivate Handler handler;\r\n\r\n\tpublic static final int OK = 1;\r\n\tpublic static final int CANCEL = 2;\r\n\t\r\n\tpublic CaptureVideo() {\r\n\t\tcapture = new Capture(this);\r\n\t    cmStart = new Command(\"Start\", Command.OK, 1);\r\n\t    cmStop = new Command(\"Stop\", Command.OK, 2);\r\n\t    cmCancel = new Command(\"Cancel\", Command.CANCEL, 3);\r\n\t    addCommand(cmStart);\r\n\t    addCommand(cmCancel);\r\n\t    setCommandListener(this);\t    \r\n\t}\r\n\r\n\tpublic void setHandler(Handler handler) {\r\n\t\tthis.handler = handler;\r\n\t}\r\n\t\r\n\tprotected void showNotify() {\r\n\t\ttry {\r\n\t\t\tif (capture.state == Capture.INIT) {\r\n\t\t\t\tinitPlayer();\r\n\t\t\t\tif (!Settings.getBool(Settings.VIDEO_CAPTURE_RECORD_BEFORE_PLAY)) {\r\n\t\t\t\t\tinitRecording();\r\n\t\t\t\t}\r\n\t\t\t\tstartPlayer();\r\n\t\t\t\tcapture.state = Capture.STARTING;\r\n\t\t\t}\r\n\t\t} catch (PavoException e) {\r\n\t\t\thandle(e);\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic void commandAction(Command c, Displayable d) {\r\n\t\tif (c == cmStart) {\r\n\t\t\tremoveCommand(cmStart);\r\n\t\t\taddCommand(cmStop);\r\n\t\t\tactionPerformed(new ActionEvent(cmStart));\r\n\t\t} else if (c == cmStop) {\r\n\t\t\tactionPerformed(new ActionEvent(cmStop));\r\n\t\t} else if (c == cmCancel) {\r\n\t\t\tcapture.abortRecording();\r\n\t\t\tcapture.state = Capture.FINISHED;\r\n\t\t\thandle(new Params().set(\"result\", Handler.CANCEL));\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic synchronized void actionPerformed(ActionEvent ev) {\r\n\t\ttry {\r\n\t\t\tswitch (capture.state) {\r\n\t\t\tcase Capture.STARTING:\r\n\t\t\t\tif(Settings.getBool(Settings.VIDEO_CAPTURE_RECORD_BEFORE_PLAY)) {\r\n\t\t\t\t\tteardownPlayer();\r\n\t\t\t\t\tinitPlayer();\r\n\t\t\t\t\tinitRecording();\r\n\t\t\t\t\tstartRecording();\r\n\t\t\t\t\tstartPlayer();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstartRecording();\r\n\t\t\t\t}\r\n\t\t        capture.state = Capture.CAPTURING;\r\n\t\t\t\tbreak;\r\n\t\t\tcase Capture.CAPTURING:\r\n\t\t\t\tfinishRecording();\r\n\t\t\t\tbreak;\r\n\t\t\tcase Capture.COMMITED:\r\n\t\t\t\tfinishRecording();\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t} catch (PavoException e) {\r\n\t\t\tif(capture.state == Capture.CAPTURING || capture.state == Capture.COMMITED) {\r\n\t\t\t\ttry { capture.abortRecording();\t} catch (Exception ee) { }\r\n\t\t\t}\r\n\t\t\thandle(e);\r\n\t\t}\r\n\t}\r\n\r\n\tvoid initPlayer() throws PavoException {\r\n\t\tcapture.initPlayer(Settings.getString(Settings.DEVICE_VIDEO));\r\n\t\tvidc = (VideoControl) ((Player) capture.player).getControl(\"VideoControl\");\r\n\t\tvidc.initDisplayMode(VideoControl.USE_DIRECT_VIDEO, this);\r\n\t\ttry {vidc.setDisplayFullScreen(Settings.getBool(Settings.VIDEO_CAPTURE_FULLSCREEN));} catch (Exception e) { throw new PavoException(\"setFullscreen\", e); }\r\n\t\tvidc.setVisible(true);\r\n\t}\r\n\t\r\n\tvoid initRecording() throws PavoException {\r\n\t\tcapture.initRecordControl(Settings.getString(Settings.VIDEO_CAPTURE_DIR) + \"pavotmp.3gp\");\r\n\t\tcapture.setRecordSizeLimit(Settings.getInt(Settings.VIDEO_CAPTURE_SIZE_LIMIT));\r\n\t}\r\n\t\r\n\tvoid startPlayer() throws PavoException {\r\n\t\ttry { capture.player.start(); } catch (Exception e) { throw new PavoException(\"playerStart\", e); }\r\n\t}\r\n\t\r\n\tvoid startRecording() throws PavoException {\r\n        capture.recordControl.startRecord();\r\n\t}\r\n\t\t\r\n\tvoid teardownPlayer() {\r\n\t\tvidc.setVisible(false);\r\n\t\tcapture.stopPlayer();\r\n\t\tvidc = null;\r\n\t}\r\n\t\r\n\tvoid finishRecording() throws PavoException {\r\n\t\tif(capture.state == Capture.CAPTURING) {\r\n\t\t\tcapture.commitRecording();\t\r\n\t\t}\r\n\t\tteardownPlayer();\r\n\t\tcapture.state = Capture.FINISHED;\r\n\t\t// doing this or will get Prefetch error -14 on nokia n95\r\n\t\tjavax.microedition.lcdui.Display.getDisplay(Main.INSTANCE).setCurrent(new DummyCanvas());\r\n\t\thandle(new Params().set(\"result\", Handler.OK).set(\"content-type\", capture.getContentType()).set(\"file\", capture.getResult()));\r\n\t}\r\n\t\r\n\tprivate void handle(Params result) {\r\n\t\tif(handler != null) {\r\n\t\t\thandler.handle(result);\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate void handle(PavoException e) {\r\n\t\tConnection.sendException(this, e);\r\n\t\thandle(new Params().set(\"result\", Handler.ERROR).set(\"exception\", e));\r\n\t}\r\n\r\n\tprotected void paint(Graphics arg0) {\r\n\t}\r\n\t\r\n\tpublic void show() {\r\n\t\tjavax.microedition.lcdui.Display.getDisplay(Main.INSTANCE).setCurrent(this);\r\n\t}\r\n\t\r\n"]]}
{"hexsha": "bf7162efaf1e0020b71320c90f61d2948a0517f5", "ext": "java", "lang": "Java", "content": "@Slf4j\npublic class LoggingODataErrorCallback implements ODataErrorCallback {\n\n\t/**\n\t * Called when an exception is catched in the OData service.\n\t * <p>\n\t * Simply logs the exception thrown and produces the default error response.\n\t * {@link ContainerManagedODataJPAServiceFactory#setDetailErrors(boolean)} can define how\n\t * detailed the error description will be.\n\t * <p>\n\t * You can also customize the error message by calling:\n\t * <ul>\n\t * <li>{@link ODataErrorContext#setInnerError(String)}</li>\n\t * <li>{@link ODataErrorContext#setMessage(String)}</li>\n\t * <li>{@link ODataErrorContext#setErrorCode(String)}</li>\n\t * <ul>\n\t * <p>\n\t */\n\t@Override\n\tpublic ODataResponse handleError(ODataErrorContext context) throws ODataApplicationException {\n\t\tThrowable exception = context.getException();\n\t\tlog.error(\"Handle error\", exception);\n\t\t\n\t\treturn EntityProvider.writeErrorDocument(context);\n\t}\n\n}", "class_id": 0, "repo": "Allen-1607/s4hana-ext-migrate-historical-data", "file": "core/src/main/java/com/sap/cloud/s4hana/migratehistoricaldata/odata/LoggingODataErrorCallback.java", "last_update_at": "2019-08-19T12:49:18+00:00", "question_id": "bf7162efaf1e0020b71320c90f61d2948a0517f5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Slf4j\npublic class LoggingODataErrorCallback implements ODataErrorCallback {\n\t/**\n\t * Called when an exception is catched in the OData service.\n\t * <p>\n\t * Simply logs the exception thrown and produces the default error response.\n\t * {@link ContainerManagedODataJPAServiceFactory#setDetailErrors(boolean)} can define how\n\t * detailed the error description will be.\n\t * <p>\n\t * You can also customize the error message by calling:\n\t * <ul>\n\t * <li>{@link ODataErrorContext#setInnerError(String)}</li>\n\t * <li>{@link ODataErrorContext#setMessage(String)}</li>\n\t * <li>{@link ODataErrorContext#setErrorCode(String)}</li>\n\t * <ul>\n\t * <p>\n\t */\n\t@Override\n\tpublic ODataResponse handleError(ODataErrorContext context) throws ODataApplicationException {\n\t\tThrowable exception = context.getException();\n\t\tlog.error(\"Handle error\", exception);\n\t\t\n\t\treturn EntityProvider.writeErrorDocument(context);\n\t}\n"]]}
{"hexsha": "c5f119c48b788ec270dfcd0edbc460c71dc48892", "ext": "java", "lang": "Java", "content": "public class GeofenceTransitionsJobIntentService extends JobIntentService {\r\n\r\n    private static final int JOB_ID = 573;\r\n\r\n    private static final String CHANNEL_ID = \"channel_01\";\r\n\r\n    public static final String TRANSITION = \"TRANSITION\";\r\n\r\n    /**\r\n     * Convenience method for enqueuing work in to this service.\r\n     */\r\n    public static void enqueueWork(Context context, Intent intent) {\r\n        enqueueWork(context, GeofenceTransitionsJobIntentService.class, JOB_ID, intent);\r\n    }\r\n    /**\r\n     * Handles incoming intents.\r\n     * @param intent sent by Location Services. This Intent is provided to Location\r\n     *               Services (inside a PendingIntent) when addGeofences() is called.\r\n     */\r\n    @SuppressLint(\"StringFormatInvalid\")\r\n    @Override\r\n    protected void onHandleWork(Intent intent) {\r\n        GeofencingEvent geofencingEvent = GeofencingEvent.fromIntent(intent);\r\n        if (geofencingEvent.hasError()) {\r\n            return;\r\n        }\r\n        // Get the transition type.\r\n        int geofenceTransition = geofencingEvent.getGeofenceTransition();\r\n        List<Geofence> triggeringGeofences = geofencingEvent.getTriggeringGeofences();\r\n        // Get the geofences that were triggered. A single event can trigger multiple geofences.\r\n        // Get the transition details as a String.\r\n        String geofenceTransitionDetails = getGeofenceTransitionDetails(geofenceTransition,\r\n                triggeringGeofences);\r\n        // Test that the reported transition was of interest.\r\n        switch (geofenceTransition) {\r\n            case Geofence.GEOFENCE_TRANSITION_ENTER:\r\n                sendNotification(geofenceTransitionDetails, triggeringGeofences);\r\n                startLocationService(triggeringGeofences);\r\n                break;\r\n            case Geofence.GEOFENCE_TRANSITION_EXIT:\r\n                stopLocationService();\r\n                break;\r\n            case Geofence.GEOFENCE_TRANSITION_DWELL:\r\n                stopLocationService();\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        // Send notification and log the transition details.\r\n        broadcastGeofenceTransition(triggeringGeofences, geofenceTransition);\r\n    }\r\n\r\n    /**\r\n     * Gets transition details and returns them as a formatted string.\r\n     *\r\n     * @param geofenceTransition    The ID of the geofence transition.\r\n     * @param triggeringGeofences   The geofence(s) triggered.\r\n     * @return                      The transition details formatted as String.\r\n     */\r\n    private String getGeofenceTransitionDetails(int geofenceTransition,\r\n                                                List<Geofence> triggeringGeofences) {\r\n\r\n        String geofenceTransitionString = getTransitionString(geofenceTransition);\r\n\r\n        // Get the Ids of each geofence that was triggered.\r\n        ArrayList<String> triggeringGeofencesIdsList = new ArrayList<>();\r\n        for (Geofence geofence : triggeringGeofences) {\r\n            triggeringGeofencesIdsList.add(geofence.getRequestId());\r\n        }\r\n        String triggeringGeofencesIdsString = TextUtils.join(\", \",  triggeringGeofencesIdsList);\r\n\r\n        return geofenceTransitionString + \": \" + triggeringGeofencesIdsString;\r\n    }\r\n\r\n    /**\r\n     * Posts a notification in the notification bar when a transition is detected.\r\n     * If the user clicks the notification, control goes to the MainActivity.\r\n     */\r\n    private void sendNotification(String notificationDetails, List<Geofence> geofenceList) {\r\n        ArrayList<String> fencesTriggersIdList = new ArrayList<>();\r\n        // Get an instance of the Notification manager\r\n        NotificationManager mNotificationManager =\r\n                (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\r\n\r\n        createNotificationChannel();\r\n\r\n        for(Geofence geofence : geofenceList){\r\n            fencesTriggersIdList.add(geofence.getRequestId());\r\n        }\r\n\r\n        NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)\r\n                .setSmallIcon(R.drawable.notifications_smart_parking)\r\n                .setLargeIcon(BitmapFactory.decodeResource(getResources(),\r\n                        R.drawable.notifications_smart_parking))\r\n                .setTimeoutAfter(Constants.getMinutesInMilliseconds() * 5)\r\n                .setColor(Color.GREEN)\r\n                .setContentTitle(notificationDetails)\r\n                .setContentText(getString(R.string.geofence_transition_notification_text))\r\n                .setPriority(NotificationCompat.PRIORITY_HIGH)\r\n                .setAutoCancel(true);\r\n\r\n        // Set the Channel ID for Android O.\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n            builder.setChannelId(CHANNEL_ID); // Channel ID\r\n        }\r\n        // Issue the notification\r\n        mNotificationManager.notify(0, builder.build());\r\n    }\r\n\r\n    /**\r\n     * Maps geofence transition types to their human-readable equivalents.\r\n     *\r\n     * @param transitionType    A transition type constant defined in Geofence\r\n     * @return                  A String indicating the type of transition\r\n     */\r\n    private String getTransitionString(int transitionType) {\r\n        switch (transitionType) {\r\n            case Geofence.GEOFENCE_TRANSITION_ENTER:\r\n                return getString(R.string.geofence_transition_entered);\r\n            case Geofence.GEOFENCE_TRANSITION_EXIT:\r\n                return getString(R.string.geofence_transition_exited);\r\n            case Geofence.GEOFENCE_TRANSITION_DWELL:\r\n                return getString(R.string.geofence_transition_dwell);\r\n            default:\r\n                return getString(R.string.unknown_geofence_transition);\r\n        }\r\n    }\r\n\r\n    private void createNotificationChannel() {\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n            CharSequence name = getString(R.string.channel_name);\r\n            String description = getString(R.string.channel_description);\r\n            NotificationChannel channel = new NotificationChannel(CHANNEL_ID, name,\r\n                    NotificationManager.IMPORTANCE_HIGH);\r\n            channel.setDescription(description);\r\n            NotificationManager notificationManager = getSystemService(NotificationManager.class);\r\n            notificationManager.createNotificationChannel(channel);\r\n        }\r\n    }\r\n\r\n    private void broadcastGeofenceTransition(List<Geofence> triggeringGeofences,\r\n                                             int geofenceTransition) {\r\n        Intent intent = new Intent(Constants.getBroadcastGeofenceTriggerIntent());\r\n        intent.putStringArrayListExtra(Constants.GEOFENCE_TRIGGED,\r\n                namesOfGeofencesTrigger(triggeringGeofences));\r\n        intent.putExtra(TRANSITION, geofenceTransition);\r\n        LocalBroadcastManager.getInstance(this).sendBroadcast(intent);\r\n    }\r\n\r\n    public void startLocationService(List<Geofence> triggeringGeofences) {\r\n        Intent serviceIntent = new Intent(this, LocationUpdatesService.class);\r\n        Utils.saveGeofencesTrigger(this,namesOfGeofencesTrigger(triggeringGeofences));\r\n//        serviceIntent.putStringArrayListExtra(Constants.GEOFENCE_TRIGGED,\r\n//                namesOfGeofencesTrigger(triggeringGeofences));\r\n        startService(serviceIntent);\r\n    }\r\n\r\n    public void stopLocationService() {\r\n        Intent serviceIntent = new Intent(this, LocationUpdatesService.class);\r\n        stopService(serviceIntent);\r\n    }\r\n\r\n    public ArrayList<String> namesOfGeofencesTrigger(List<Geofence> triggeringGeofences){\r\n        ArrayList<String> fencesTriggered = new ArrayList<>();\r\n        if(triggeringGeofences != null){\r\n            for(Geofence geofence : triggeringGeofences){\r\n                fencesTriggered.add(geofence.getRequestId());\r\n            }\r\n        }\r\n        return fencesTriggered;\r\n    }\r\n\r\n}", "class_id": 0, "repo": "SmartTrafficPY/smartparking", "file": "app/src/main/java/smarttraffic/smartparking/services/GeofenceTransitionsJobIntentService.java", "last_update_at": "2019-05-28T21:57:45+00:00", "question_id": "c5f119c48b788ec270dfcd0edbc460c71dc48892", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GeofenceTransitionsJobIntentService extends JobIntentService {\r\n\r\n    private static final int JOB_ID = 573;\r\n\r\n    private static final String CHANNEL_ID = \"channel_01\";\r\n\r\n    public static final String TRANSITION = \"TRANSITION\";\r\n\r\n    /**\r\n     * Convenience method for enqueuing work in to this service.\r\n     */\r\n    public static void enqueueWork(Context context, Intent intent) {\r\n        enqueueWork(context, GeofenceTransitionsJobIntentService.class, JOB_ID, intent);\r\n    }\r\n    /**\r\n     * Handles incoming intents.\r\n     * @param intent sent by Location Services. This Intent is provided to Location\r\n     *               Services (inside a PendingIntent) when addGeofences() is called.\r\n     */\r\n    @SuppressLint(\"StringFormatInvalid\")\r\n    @Override\r\n    protected void onHandleWork(Intent intent) {\r\n        GeofencingEvent geofencingEvent = GeofencingEvent.fromIntent(intent);\r\n        if (geofencingEvent.hasError()) {\r\n            return;\r\n        }\r\n        // Get the transition type.\r\n        int geofenceTransition = geofencingEvent.getGeofenceTransition();\r\n        List<Geofence> triggeringGeofences = geofencingEvent.getTriggeringGeofences();\r\n        // Get the geofences that were triggered. A single event can trigger multiple geofences.\r\n        // Get the transition details as a String.\r\n        String geofenceTransitionDetails = getGeofenceTransitionDetails(geofenceTransition,\r\n                triggeringGeofences);\r\n        // Test that the reported transition was of interest.\r\n        switch (geofenceTransition) {\r\n            case Geofence.GEOFENCE_TRANSITION_ENTER:\r\n                sendNotification(geofenceTransitionDetails, triggeringGeofences);\r\n                startLocationService(triggeringGeofences);\r\n                break;\r\n            case Geofence.GEOFENCE_TRANSITION_EXIT:\r\n                stopLocationService();\r\n                break;\r\n            case Geofence.GEOFENCE_TRANSITION_DWELL:\r\n                stopLocationService();\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        // Send notification and log the transition details.\r\n        broadcastGeofenceTransition(triggeringGeofences, geofenceTransition);\r\n    }\r\n\r\n    /**\r\n     * Gets transition details and returns them as a formatted string.\r\n     *\r\n     * @param geofenceTransition    The ID of the geofence transition.\r\n     * @param triggeringGeofences   The geofence(s) triggered.\r\n     * @return                      The transition details formatted as String.\r\n     */\r\n    private String getGeofenceTransitionDetails(int geofenceTransition,\r\n                                                List<Geofence> triggeringGeofences) {\r\n\r\n        String geofenceTransitionString = getTransitionString(geofenceTransition);\r\n\r\n        // Get the Ids of each geofence that was triggered.\r\n        ArrayList<String> triggeringGeofencesIdsList = new ArrayList<>();\r\n        for (Geofence geofence : triggeringGeofences) {\r\n            triggeringGeofencesIdsList.add(geofence.getRequestId());\r\n        }\r\n        String triggeringGeofencesIdsString = TextUtils.join(\", \",  triggeringGeofencesIdsList);\r\n\r\n        return geofenceTransitionString + \": \" + triggeringGeofencesIdsString;\r\n    }\r\n\r\n    /**\r\n     * Posts a notification in the notification bar when a transition is detected.\r\n     * If the user clicks the notification, control goes to the MainActivity.\r\n     */\r\n    private void sendNotification(String notificationDetails, List<Geofence> geofenceList) {\r\n        ArrayList<String> fencesTriggersIdList = new ArrayList<>();\r\n        // Get an instance of the Notification manager\r\n        NotificationManager mNotificationManager =\r\n                (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\r\n\r\n        createNotificationChannel();\r\n\r\n        for(Geofence geofence : geofenceList){\r\n            fencesTriggersIdList.add(geofence.getRequestId());\r\n        }\r\n\r\n        NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)\r\n                .setSmallIcon(R.drawable.notifications_smart_parking)\r\n                .setLargeIcon(BitmapFactory.decodeResource(getResources(),\r\n                        R.drawable.notifications_smart_parking))\r\n                .setTimeoutAfter(Constants.getMinutesInMilliseconds() * 5)\r\n                .setColor(Color.GREEN)\r\n                .setContentTitle(notificationDetails)\r\n                .setContentText(getString(R.string.geofence_transition_notification_text))\r\n                .setPriority(NotificationCompat.PRIORITY_HIGH)\r\n                .setAutoCancel(true);\r\n\r\n        // Set the Channel ID for Android O.\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n            builder.setChannelId(CHANNEL_ID); // Channel ID\r\n        }\r\n        // Issue the notification\r\n        mNotificationManager.notify(0, builder.build());\r\n    }\r\n\r\n    /**\r\n     * Maps geofence transition types to their human-readable equivalents.\r\n     *\r\n     * @param transitionType    A transition type constant defined in Geofence\r\n     * @return                  A String indicating the type of transition\r\n     */\r\n    private String getTransitionString(int transitionType) {\r\n        switch (transitionType) {\r\n            case Geofence.GEOFENCE_TRANSITION_ENTER:\r\n                return getString(R.string.geofence_transition_entered);\r\n            case Geofence.GEOFENCE_TRANSITION_EXIT:\r\n                return getString(R.string.geofence_transition_exited);\r\n            case Geofence.GEOFENCE_TRANSITION_DWELL:\r\n                return getString(R.string.geofence_transition_dwell);\r\n            default:\r\n                return getString(R.string.unknown_geofence_transition);\r\n        }\r\n    }\r\n\r\n    private void createNotificationChannel() {\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n            CharSequence name = getString(R.string.channel_name);\r\n            String description = getString(R.string.channel_description);\r\n            NotificationChannel channel = new NotificationChannel(CHANNEL_ID, name,\r\n                    NotificationManager.IMPORTANCE_HIGH);\r\n            channel.setDescription(description);\r\n            NotificationManager notificationManager = getSystemService(NotificationManager.class);\r\n            notificationManager.createNotificationChannel(channel);\r\n        }\r\n    }\r\n\r\n    private void broadcastGeofenceTransition(List<Geofence> triggeringGeofences,\r\n                                             int geofenceTransition) {\r\n        Intent intent = new Intent(Constants.getBroadcastGeofenceTriggerIntent());\r\n        intent.putStringArrayListExtra(Constants.GEOFENCE_TRIGGED,\r\n                namesOfGeofencesTrigger(triggeringGeofences));\r\n        intent.putExtra(TRANSITION, geofenceTransition);\r\n        LocalBroadcastManager.getInstance(this).sendBroadcast(intent);\r\n    }\r\n\r\n    public void startLocationService(List<Geofence> triggeringGeofences) {\r\n        Intent serviceIntent = new Intent(this, LocationUpdatesService.class);\r\n        Utils.saveGeofencesTrigger(this,namesOfGeofencesTrigger(triggeringGeofences));\r\n//        serviceIntent.putStringArrayListExtra(Constants.GEOFENCE_TRIGGED,\r\n//                namesOfGeofencesTrigger(triggeringGeofences));\r\n        startService(serviceIntent);\r\n    }\r\n\r\n    public void stopLocationService() {\r\n        Intent serviceIntent = new Intent(this, LocationUpdatesService.class);\r\n        stopService(serviceIntent);\r\n    }\r\n\r\n    public ArrayList<String> namesOfGeofencesTrigger(List<Geofence> triggeringGeofences){\r\n        ArrayList<String> fencesTriggered = new ArrayList<>();\r\n        if(triggeringGeofences != null){\r\n            for(Geofence geofence : triggeringGeofences){\r\n                fencesTriggered.add(geofence.getRequestId());\r\n            }\r\n        }\r\n        return fencesTriggered;\r\n    }\r\n\r\n"]]}
{"hexsha": "fb22f7167097dc1a7903e0d62185f4c1769a0a7b", "ext": "java", "lang": "Java", "content": "@RunWith(JUnit4.class)\npublic class MutateRowCallableTest {\n\n  private static final RequestContext REQUEST_CONTEXT =\n      RequestContext.create(InstanceName.of(\"fake-project\", \"fake-instance\"), \"fake-profile\");\n  private UnaryCallable<MutateRowRequest, MutateRowResponse> innerCallable;\n  private ArgumentCaptor<MutateRowRequest> innerMutation;\n  private SettableApiFuture<MutateRowResponse> innerResult;\n\n  @SuppressWarnings(\"unchecked\")\n  @Before\n  public void setUp() {\n    innerCallable = Mockito.mock(UnaryCallable.class);\n    innerMutation = ArgumentCaptor.forClass(MutateRowRequest.class);\n    innerResult = SettableApiFuture.create();\n    Mockito.when(\n            innerCallable.futureCall(innerMutation.capture(), Mockito.any(ApiCallContext.class)))\n        .thenReturn(innerResult);\n  }\n\n  @Test\n  public void testRequestConversion() {\n    MutateRowCallable callable = new MutateRowCallable(innerCallable, REQUEST_CONTEXT);\n    RowMutation outerRequest =\n        RowMutation.create(\"fake-table\", \"fake-key\")\n            .setCell(\"fake-family\", \"fake-qualifier\", 1_000, \"fake-value\");\n\n    innerResult.set(MutateRowResponse.getDefaultInstance());\n    callable.call(outerRequest);\n\n    Truth.assertThat(innerMutation.getValue()).isEqualTo(outerRequest.toProto(REQUEST_CONTEXT));\n  }\n}", "class_id": 0, "repo": "SergeyZadorozhniy/google-cloud-java", "file": "google-cloud-clients/google-cloud-bigtable/src/test/java/com/google/cloud/bigtable/data/v2/stub/MutateRowCallableTest.java", "last_update_at": "2019-01-12T12:56:11+00:00", "question_id": "fb22f7167097dc1a7903e0d62185f4c1769a0a7b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(JUnit4.class)\npublic class MutateRowCallableTest {\n  private static final RequestContext REQUEST_CONTEXT =\n      RequestContext.create(InstanceName.of(\"fake-project\", \"fake-instance\"), \"fake-profile\");\n  private UnaryCallable<MutateRowRequest, MutateRowResponse> innerCallable;\n  private ArgumentCaptor<MutateRowRequest> innerMutation;\n  private SettableApiFuture<MutateRowResponse> innerResult;\n  @SuppressWarnings(\"unchecked\")\n  @Before\n  public void setUp() {\n    innerCallable = Mockito.mock(UnaryCallable.class);\n    innerMutation = ArgumentCaptor.forClass(MutateRowRequest.class);\n    innerResult = SettableApiFuture.create();\n    Mockito.when(\n            innerCallable.futureCall(innerMutation.capture(), Mockito.any(ApiCallContext.class)))\n        .thenReturn(innerResult);\n  }\n  @Test\n  public void testRequestConversion() {\n    MutateRowCallable callable = new MutateRowCallable(innerCallable, REQUEST_CONTEXT);\n    RowMutation outerRequest =\n        RowMutation.create(\"fake-table\", \"fake-key\")\n            .setCell(\"fake-family\", \"fake-qualifier\", 1_000, \"fake-value\");\n    innerResult.set(MutateRowResponse.getDefaultInstance());\n    callable.call(outerRequest);\n    Truth.assertThat(innerMutation.getValue()).isEqualTo(outerRequest.toProto(REQUEST_CONTEXT));\n  }\n"]]}
{"hexsha": "eb780de4f5cbed5d8575942547886f0ad07cb51d", "ext": "java", "lang": "Java", "content": "@Aspect\n@Component\n@Order(0)\npublic class SplittingValuesAspect {\n\n    private final Logger logger = LoggerFactory.getLogger(SplittingValuesAspect.class);\n\n    @Autowired\n    private SelfAssessmentService selfAssessmentService;\n\n    @Autowired\n    private EconomicResultsService economicResultsService;\n\n    @Autowired\n    private SplittingValueService splittingValueService;\n\n    /**\n     * Pointcut for methods annotated with UpdateSplittingValuesHook.\n     */\n    @Pointcut(\"@annotation(eu.hermeneut.aop.annotation.UpdateSplittingValuesHook)\")\n    public void updateSplittingValuesHook() {\n    }\n\n    /**\n     * Cross-cutting method to update the SplittingValues of a SelfAssessment.\n     *\n     * @param joinPoint\n     */\n    @AfterReturning(\"updateSplittingValuesHook()\")\n    public void updateSplittingValues(JoinPoint joinPoint) {\n        logger.debug(\"Updating SplittingValues AOP...\");\n\n        SelfAssessment selfAssessment = null;\n\n        Object[] args = joinPoint.getArgs();\n\n        if (args != null && args.length > 0) {\n            //The first parameter must be the ID of the SelfAssessment\n            if (args[0] instanceof Long) {\n                selfAssessment = this.selfAssessmentService.findOne((Long) args[0]);\n            }\n        }\n\n        if (selfAssessment != null) {\n            // GET the existing SplittingValues for this SelfAssessment and update them.\n            List<SplittingValue> splittingValues = this.splittingValueService.findAllBySelfAssessmentID(selfAssessment.getId());\n\n            if (splittingValues != null && !splittingValues.isEmpty()) {\n                EconomicResults economicResults = this.economicResultsService.findOneBySelfAssessmentID(selfAssessment.getId());\n\n                if (economicResults != null) {\n                    BigDecimal intangibleCapital = economicResults.getIntangibleCapital();\n\n                    if (intangibleCapital != null) {\n                        for (SplittingValue splittingValue : splittingValues) {\n                            final CategoryType categoryType = splittingValue.getCategoryType();\n                            final SectorType sectorType = splittingValue.getSectorType();\n\n                            if (categoryType != CategoryType.DATA) {\n                                BigDecimal splitting = Calculator.calculateSplittingValue(intangibleCapital, categoryType, sectorType);\n\n                                if (splitting != null) {\n                                    splittingValue.setValue(splitting);\n                                    splittingValue = this.splittingValueService.save(splittingValue);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}", "class_id": 0, "repo": "rating-eu/rating", "file": "src/main/java/eu/hermeneut/aop/wp3/SplittingValuesAspect.java", "last_update_at": "2019-07-26T10:57:14+00:00", "question_id": "eb780de4f5cbed5d8575942547886f0ad07cb51d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Aspect\n@Component\n@Order(0)\npublic class SplittingValuesAspect {\n    private final Logger logger = LoggerFactory.getLogger(SplittingValuesAspect.class);\n    @Autowired\n    private SelfAssessmentService selfAssessmentService;\n    @Autowired\n    private EconomicResultsService economicResultsService;\n    @Autowired\n    private SplittingValueService splittingValueService;\n    /**\n     * Pointcut for methods annotated with UpdateSplittingValuesHook.\n     */\n    @Pointcut(\"@annotation(eu.hermeneut.aop.annotation.UpdateSplittingValuesHook)\")\n    public void updateSplittingValuesHook() {\n    }\n    /**\n     * Cross-cutting method to update the SplittingValues of a SelfAssessment.\n     *\n     * @param joinPoint\n     */\n    @AfterReturning(\"updateSplittingValuesHook()\")\n    public void updateSplittingValues(JoinPoint joinPoint) {\n        logger.debug(\"Updating SplittingValues AOP...\");\n        SelfAssessment selfAssessment = null;\n        Object[] args = joinPoint.getArgs();\n        if (args != null && args.length > 0) {\n            //The first parameter must be the ID of the SelfAssessment\n            if (args[0] instanceof Long) {\n                selfAssessment = this.selfAssessmentService.findOne((Long) args[0]);\n            }\n        }\n        if (selfAssessment != null) {\n            // GET the existing SplittingValues for this SelfAssessment and update them.\n            List<SplittingValue> splittingValues = this.splittingValueService.findAllBySelfAssessmentID(selfAssessment.getId());\n            if (splittingValues != null && !splittingValues.isEmpty()) {\n                EconomicResults economicResults = this.economicResultsService.findOneBySelfAssessmentID(selfAssessment.getId());\n                if (economicResults != null) {\n                    BigDecimal intangibleCapital = economicResults.getIntangibleCapital();\n                    if (intangibleCapital != null) {\n                        for (SplittingValue splittingValue : splittingValues) {\n                            final CategoryType categoryType = splittingValue.getCategoryType();\n                            final SectorType sectorType = splittingValue.getSectorType();\n                            if (categoryType != CategoryType.DATA) {\n                                BigDecimal splitting = Calculator.calculateSplittingValue(intangibleCapital, categoryType, sectorType);\n                                if (splitting != null) {\n                                    splittingValue.setValue(splitting);\n                                    splittingValue = this.splittingValueService.save(splittingValue);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n"]]}
{"hexsha": "2de57659c7f83e63d11fccd26dbb2ad9f991edc0", "ext": "java", "lang": "Java", "content": "public class Utils {\n\n\t\n\tpublic static double calculateWordDifficulty(String word)\n\t{\n\t\treturn 0;\n\t}\n\t\n\tpublic static String translateRulesToHTMLTags(Rule rule)\n\t{\n\t\tif (rule.getPresentationStyle() == Rule.HIGHLIGHT_PROBLEMATIC_PARTS || rule.getPresentationStyle() == Rule.HIGHLIGHT_WHOLE_WORD)\n\t\t{\n\t\t\treturn \"background-color\";\n\t\t}\n\t\telse if (rule.getPresentationStyle() == Rule.PAINT_PROBLEMATIC_PARTS || rule.getPresentationStyle() == Rule.PAINT_WHOLE_WORD)\n\t\t{\n\t\t\treturn \"color\";\n\t\t}\n\t\telse\n\t\t\treturn \"\"; \n\t}\n\t\n\tpublic static String rgbToHEX(java.awt.Color color)\n\t{\n\t\tString hex = Integer.toHexString(color.getRGB() & 0xffffff);\n\t\tif (hex.length() < 6) \n\t\t{\n\t\t    hex = \"0\" + hex;\n\t\t}\n\t\thex = \"#\" + hex;\n\t\treturn hex;\n\t}\n\t\n}", "class_id": 0, "repo": "mpakarlsson/ilearnrw", "file": "src/ilearnrw/textadaptation/utils/Utils.java", "last_update_at": "2019-10-24T01:39:19+00:00", "question_id": "2de57659c7f83e63d11fccd26dbb2ad9f991edc0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Utils {\n\t\n\tpublic static double calculateWordDifficulty(String word)\n\t{\n\t\treturn 0;\n\t}\n\t\n\tpublic static String translateRulesToHTMLTags(Rule rule)\n\t{\n\t\tif (rule.getPresentationStyle() == Rule.HIGHLIGHT_PROBLEMATIC_PARTS || rule.getPresentationStyle() == Rule.HIGHLIGHT_WHOLE_WORD)\n\t\t{\n\t\t\treturn \"background-color\";\n\t\t}\n\t\telse if (rule.getPresentationStyle() == Rule.PAINT_PROBLEMATIC_PARTS || rule.getPresentationStyle() == Rule.PAINT_WHOLE_WORD)\n\t\t{\n\t\t\treturn \"color\";\n\t\t}\n\t\telse\n\t\t\treturn \"\"; \n\t}\n\t\n\tpublic static String rgbToHEX(java.awt.Color color)\n\t{\n\t\tString hex = Integer.toHexString(color.getRGB() & 0xffffff);\n\t\tif (hex.length() < 6) \n\t\t{\n\t\t    hex = \"0\" + hex;\n\t\t}\n\t\thex = \"#\" + hex;\n\t\treturn hex;\n\t}\n\t\n"]]}
{"hexsha": "5543a5df229ebca97c5533caee2ff41e064fcfca", "ext": "java", "lang": "Java", "content": "@TeleOp(name = \"TankDrive TeleOp Example\", group = \"ARC\")\npublic class TankDriveTeleOpExample extends OpMode {\n\n  private static final int TICKS_PER_INCH = 1000, TICKS_PER_360 = 1440 * 4;\n  private TankDrive tankDrive;\n\n  @Override\n  public void init() {\n    DcMotor motorL = hardwareMap.dcMotor.get(\"motorL\");\n    DcMotor motorR = hardwareMap.dcMotor.get(\"motorR\");\n    motorL.setDirection(Direction.REVERSE);\n\n    tankDrive = TankDrive.fromMotors(\n        motorL, motorR, this, TICKS_PER_INCH, TICKS_PER_360);\n  }\n\n  @Override\n  public void loop() {\n    // The Y axis for gamepad sticks is reversed, negate it in use\n    tankDrive.setMovementAndRotation(-gamepad1.left_stick_y, gamepad1.left_stick_x);\n\n    telemetry.addData(\"Left stick X\", gamepad1.left_stick_x);\n    telemetry.addData(\"Left stick Y\", -gamepad1.left_stick_y);\n    telemetry.update();\n  }\n}", "class_id": 0, "repo": "LakeYin/Thunder-Rover-Ruckus-Worlds", "file": "TeamCode/src/main/java/com/andoverrobotics/core/examples/TankDriveTeleOpExample.java", "last_update_at": "2019-03-23T02:50:48+00:00", "question_id": "5543a5df229ebca97c5533caee2ff41e064fcfca", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@TeleOp(name = \"TankDrive TeleOp Example\", group = \"ARC\")\npublic class TankDriveTeleOpExample extends OpMode {\n  private static final int TICKS_PER_INCH = 1000, TICKS_PER_360 = 1440 * 4;\n  private TankDrive tankDrive;\n  @Override\n  public void init() {\n    DcMotor motorL = hardwareMap.dcMotor.get(\"motorL\");\n    DcMotor motorR = hardwareMap.dcMotor.get(\"motorR\");\n    motorL.setDirection(Direction.REVERSE);\n    tankDrive = TankDrive.fromMotors(\n        motorL, motorR, this, TICKS_PER_INCH, TICKS_PER_360);\n  }\n  @Override\n  public void loop() {\n    // The Y axis for gamepad sticks is reversed, negate it in use\n    tankDrive.setMovementAndRotation(-gamepad1.left_stick_y, gamepad1.left_stick_x);\n    telemetry.addData(\"Left stick X\", gamepad1.left_stick_x);\n    telemetry.addData(\"Left stick Y\", -gamepad1.left_stick_y);\n    telemetry.update();\n  }\n"]]}
{"hexsha": "9ade6c1dcffa6e9d0b1b4ec408dd1c7974ea5ce8", "ext": "java", "lang": "Java", "content": "public class ShoppingCartTest {\n\n\n\n\t@Test\n\tvoid testAddItem() {\n\t\tProduct productToAddForTest = new Product(\"banana\" +\n\t\t\t\"\", ProductUnit.Kilo);\n\n\n\t\tShoppingCart shoppingCart = new ShoppingCart();\n\t\tshoppingCart.addItem(productToAddForTest);\n\t\tshoppingCart.addItem(productToAddForTest);\n\t\tshoppingCart.addItem(productToAddForTest);\n\n\n\t\tint sumProductQuantities=0;\n\n\t\tfor (Map.Entry<Product, Double> entry : shoppingCart.productQuantities.entrySet()) {\n\t\t\tsumProductQuantities += entry.getValue();\n\n\t\t}\n\t\tassertThat(sumProductQuantities).isEqualTo(3);\n\n\n\t}\n\n\n}", "class_id": 0, "repo": "medhy35/tennis-kata", "file": "src/test/java/projet/esiea/model/entitiesReceiptTest/ShoppingCartTest.java", "last_update_at": "2019-03-07T10:51:06+00:00", "question_id": "9ade6c1dcffa6e9d0b1b4ec408dd1c7974ea5ce8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ShoppingCartTest {\n\t@Test\n\tvoid testAddItem() {\n\t\tProduct productToAddForTest = new Product(\"banana\" +\n\t\t\t\"\", ProductUnit.Kilo);\n\t\tShoppingCart shoppingCart = new ShoppingCart();\n\t\tshoppingCart.addItem(productToAddForTest);\n\t\tshoppingCart.addItem(productToAddForTest);\n\t\tshoppingCart.addItem(productToAddForTest);\n\t\tint sumProductQuantities=0;\n\t\tfor (Map.Entry<Product, Double> entry : shoppingCart.productQuantities.entrySet()) {\n\t\t\tsumProductQuantities += entry.getValue();\n\t\t}\n\t\tassertThat(sumProductQuantities).isEqualTo(3);\n\t}\n"]]}
{"hexsha": "6be49d6d1ca1bef57cf943da7f4580df86863d00", "ext": "java", "lang": "Java", "content": "public class AppsSettingsTests extends InstrumentationTestCase {\n    private static final boolean LOCAL_LOGV = false;\n    private static final String SETTINGS_PACKAGE = \"com.android.settings\";\n    private static final String TAG = \"AboutPhoneSettingsTest\";\n    private static final int TIMEOUT = 2000;\n    private ActivityHelper mActivityHelper = null;\n\n    private UiDevice mDevice;\n\n    private static final String[] sResourceTexts = {\n        \"Storage\",\n        \"Data usage\",\n        \"Permissions\",\n        \"App notifications\",\n        \"Open by default\",\n        \"Battery\",\n        \"Memory\"\n    };\n\n    @Override\n    public void setUp() throws Exception {\n        if (LOCAL_LOGV) {\n            Log.d(TAG, \"-------\");\n        }\n        super.setUp();\n        mDevice = UiDevice.getInstance(getInstrumentation());\n        mActivityHelper = ActivityHelper.getInstance();\n        try {\n            mDevice.setOrientationNatural();\n        } catch (RemoteException e) {\n            throw new RuntimeException(\"Failed to freeze device orientaion\", e);\n        }\n\n        // make sure we are in a clean state before starting the test\n        mDevice.pressHome();\n        Thread.sleep(TIMEOUT * 2);\n        launchAppsSettings();\n        UiObject2 view =\n                mDevice.wait(\n                        Until.findObject(By.text(\"All apps\")), TIMEOUT);\n        assertNotNull(\"Could not find Settings > Apps screen\", view);\n    }\n\n    @Override\n    protected void tearDown() throws Exception {\n        mDevice.pressBack();\n        mDevice.pressHome(); // finish settings activity\n        mDevice.waitForIdle(TIMEOUT * 2); // give UI time to finish animating\n        super.tearDown();\n    }\n\n    @MediumTest\n    public void testAppSettingsListForCalculator() {\n        UiObject2 calculator = mDevice.wait(\n                Until.findObject(By.text(\"Calculator\")), TIMEOUT);\n        calculator.click();\n        for (String setting : sResourceTexts) {\n            UiObject2 appSetting =\n                mDevice.wait(\n                        Until.findObject(By.text(setting)), TIMEOUT);\n            assertNotNull(\"Missing setting for Calculator: \" + setting, appSetting);\n            appSetting.scroll(Direction.DOWN, 10.0f);\n        }\n    }\n\n    @MediumTest\n    public void testDisablingAndEnablingSystemApp() throws Exception {\n        launchAppsSettings();\n        UiObject2 calculator = mDevice.wait(\n                Until.findObject(By.text(\"Calculator\")), TIMEOUT);\n        calculator.click();\n        mDevice.waitForIdle(TIMEOUT);\n        UiObject2 appInfoList = mDevice.wait(\n            Until.findObject(By.res(SETTINGS_PACKAGE, \"list\")), TIMEOUT);\n        appInfoList.scroll(Direction.DOWN, 100.0f);\n        UiObject2 disableButton = mDevice.wait(\n                Until.findObject(By.text(\"DISABLE\")), TIMEOUT);\n        disableButton.click();\n        mDevice.waitForIdle(TIMEOUT);\n        // Click on \"Disable App\" on dialog.\n        mDevice.wait(\n                Until.findObject(By.text(\"DISABLE APP\")), TIMEOUT).click();\n        mDevice.waitForIdle(TIMEOUT);\n        UiObject2 enableButton = mDevice.wait(\n                Until.findObject(By.text(\"ENABLE\")), TIMEOUT);\n        assertNotNull(\"App not disabled successfully\", enableButton);\n        enableButton.click();\n        mDevice.waitForIdle(TIMEOUT);\n        disableButton = mDevice.wait(\n                Until.findObject(By.text(\"DISABLE\")), TIMEOUT);\n        assertNotNull(\"App not enabled successfully\", disableButton);\n    }\n\n    private void launchAppsSettings() throws Exception {\n        Intent appsSettingsIntent = new\n                Intent(Settings.ACTION_MANAGE_APPLICATIONS_SETTINGS);\n        mActivityHelper.launchIntent(appsSettingsIntent);\n    }\n}", "class_id": 0, "repo": "faratotik-test/Resurrection_packages_apps_Settings", "file": "tests/uitests/src/com/android/settings/ui/AppsSettingsTests.java", "last_update_at": "2019-01-28T03:31:39+00:00", "question_id": "6be49d6d1ca1bef57cf943da7f4580df86863d00", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AppsSettingsTests extends InstrumentationTestCase {\n    private static final boolean LOCAL_LOGV = false;\n    private static final String SETTINGS_PACKAGE = \"com.android.settings\";\n    private static final String TAG = \"AboutPhoneSettingsTest\";\n    private static final int TIMEOUT = 2000;\n    private ActivityHelper mActivityHelper = null;\n    private UiDevice mDevice;\n    private static final String[] sResourceTexts = {\n        \"Storage\",\n        \"Data usage\",\n        \"Permissions\",\n        \"App notifications\",\n        \"Open by default\",\n        \"Battery\",\n        \"Memory\"\n    };\n    @Override\n    public void setUp() throws Exception {\n        if (LOCAL_LOGV) {\n            Log.d(TAG, \"-------\");\n        }\n        super.setUp();\n        mDevice = UiDevice.getInstance(getInstrumentation());\n        mActivityHelper = ActivityHelper.getInstance();\n        try {\n            mDevice.setOrientationNatural();\n        } catch (RemoteException e) {\n            throw new RuntimeException(\"Failed to freeze device orientaion\", e);\n        }\n        // make sure we are in a clean state before starting the test\n        mDevice.pressHome();\n        Thread.sleep(TIMEOUT * 2);\n        launchAppsSettings();\n        UiObject2 view =\n                mDevice.wait(\n                        Until.findObject(By.text(\"All apps\")), TIMEOUT);\n        assertNotNull(\"Could not find Settings > Apps screen\", view);\n    }\n    @Override\n    protected void tearDown() throws Exception {\n        mDevice.pressBack();\n        mDevice.pressHome(); // finish settings activity\n        mDevice.waitForIdle(TIMEOUT * 2); // give UI time to finish animating\n        super.tearDown();\n    }\n    @MediumTest\n    public void testAppSettingsListForCalculator() {\n        UiObject2 calculator = mDevice.wait(\n                Until.findObject(By.text(\"Calculator\")), TIMEOUT);\n        calculator.click();\n        for (String setting : sResourceTexts) {\n            UiObject2 appSetting =\n                mDevice.wait(\n                        Until.findObject(By.text(setting)), TIMEOUT);\n            assertNotNull(\"Missing setting for Calculator: \" + setting, appSetting);\n            appSetting.scroll(Direction.DOWN, 10.0f);\n        }\n    }\n    @MediumTest\n    public void testDisablingAndEnablingSystemApp() throws Exception {\n        launchAppsSettings();\n        UiObject2 calculator = mDevice.wait(\n                Until.findObject(By.text(\"Calculator\")), TIMEOUT);\n        calculator.click();\n        mDevice.waitForIdle(TIMEOUT);\n        UiObject2 appInfoList = mDevice.wait(\n            Until.findObject(By.res(SETTINGS_PACKAGE, \"list\")), TIMEOUT);\n        appInfoList.scroll(Direction.DOWN, 100.0f);\n        UiObject2 disableButton = mDevice.wait(\n                Until.findObject(By.text(\"DISABLE\")), TIMEOUT);\n        disableButton.click();\n        mDevice.waitForIdle(TIMEOUT);\n        // Click on \"Disable App\" on dialog.\n        mDevice.wait(\n                Until.findObject(By.text(\"DISABLE APP\")), TIMEOUT).click();\n        mDevice.waitForIdle(TIMEOUT);\n        UiObject2 enableButton = mDevice.wait(\n                Until.findObject(By.text(\"ENABLE\")), TIMEOUT);\n        assertNotNull(\"App not disabled successfully\", enableButton);\n        enableButton.click();\n        mDevice.waitForIdle(TIMEOUT);\n        disableButton = mDevice.wait(\n                Until.findObject(By.text(\"DISABLE\")), TIMEOUT);\n        assertNotNull(\"App not enabled successfully\", disableButton);\n    }\n    private void launchAppsSettings() throws Exception {\n        Intent appsSettingsIntent = new\n                Intent(Settings.ACTION_MANAGE_APPLICATIONS_SETTINGS);\n        mActivityHelper.launchIntent(appsSettingsIntent);\n    }\n"]]}
{"hexsha": "41514e9056b071c02de5f1eca89a0e5a059236d9", "ext": "java", "lang": "Java", "content": "public class A44_Printf {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        double sum = 0.0;\n        int sign = 1;\n        for ( int i =1; i<=n; i++, sign = -sign) {\n            sum += sign+1.0/i;\n            // i ++;\n            // sign = -sign;\n        }\n        System.out.println(sum);\n        System.out.printf(\"%.2f\",sum);\n    }\n}", "class_id": 0, "repo": "mixterjim/Learn", "file": "Java/Basics/A44_Printf.java", "last_update_at": "2019-05-01T08:24:17+00:00", "question_id": "41514e9056b071c02de5f1eca89a0e5a059236d9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class A44_Printf {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        double sum = 0.0;\n        int sign = 1;\n        for ( int i =1; i<=n; i++, sign = -sign) {\n            sum += sign+1.0/i;\n            // i ++;\n            // sign = -sign;\n        }\n        System.out.println(sum);\n        System.out.printf(\"%.2f\",sum);\n    }\n"]]}
{"hexsha": "8d65c9681c50330945f676ab475c960daedb8523", "ext": "java", "lang": "Java", "content": "public class ConstructionHelmetTeleport implements Listener {\n    @EventHandler(ignoreCancelled = true)\n    private void onInventoryClickEvent(InventoryClickEvent event) {\n        if (event.getCurrentItem() == null)\n            return;\n        if (event.getCurrentItem().getType() != Material.GOLD_HELMET)\n            return;\n        InventoryAction click = event.getAction();\n        if (!event.getCurrentItem().hasItemMeta() || !event.getCurrentItem().getItemMeta().hasDisplayName() ||\n                !event.getCurrentItem().getItemMeta().getDisplayName().equals(ChatColor.DARK_PURPLE + \"Construction Helmet\"))\n            return;\n        else if (click == InventoryAction.UNKNOWN || click == InventoryAction.NOTHING)\n            return;\n\n        event.setCancelled(true);\n        event.getClickedInventory().setItem(event.getSlot(), new ItemStack(Material.AIR));\n\n        Player player = (Player) event.getWhoClicked();\n        player.updateInventory();\n\n        String worldName = player.getLocation().getWorld().getName();\n        Dungeon dungeon = DungeonMod.getConfigManager().getDungeon(worldName);\n        if (dungeon == null)\n            return;\n        dungeon.teleportPlayerToExit(player);\n    }\n}", "class_id": 0, "repo": "Ameliorate/CivDungeons", "file": "src/main/java/pw/amel/dungeonmod/command/ConstructionHelmetTeleport.java", "last_update_at": "2019-01-05T01:56:09+00:00", "question_id": "8d65c9681c50330945f676ab475c960daedb8523", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ConstructionHelmetTeleport implements Listener {\n    @EventHandler(ignoreCancelled = true)\n    private void onInventoryClickEvent(InventoryClickEvent event) {\n        if (event.getCurrentItem() == null)\n            return;\n        if (event.getCurrentItem().getType() != Material.GOLD_HELMET)\n            return;\n        InventoryAction click = event.getAction();\n        if (!event.getCurrentItem().hasItemMeta() || !event.getCurrentItem().getItemMeta().hasDisplayName() ||\n                !event.getCurrentItem().getItemMeta().getDisplayName().equals(ChatColor.DARK_PURPLE + \"Construction Helmet\"))\n            return;\n        else if (click == InventoryAction.UNKNOWN || click == InventoryAction.NOTHING)\n            return;\n        event.setCancelled(true);\n        event.getClickedInventory().setItem(event.getSlot(), new ItemStack(Material.AIR));\n        Player player = (Player) event.getWhoClicked();\n        player.updateInventory();\n        String worldName = player.getLocation().getWorld().getName();\n        Dungeon dungeon = DungeonMod.getConfigManager().getDungeon(worldName);\n        if (dungeon == null)\n            return;\n        dungeon.teleportPlayerToExit(player);\n    }\n"]]}
{"hexsha": "0d41d003c6ce2821ac7b75dfd5367e245d0832da", "ext": "java", "lang": "Java", "content": "public class GenerateSignUtilsTest {\n\n    @Test(timeout = 100)\n    public void generateSignatureByAES() throws Exception{\n        SortedMap<String,String> sortedMap = new TreeMap<String,String>();\n        sortedMap.put(\"testKey1\",\"testvalue1\");\n        sortedMap.put(\"testvalue1\",\"testKey1\");\n        sortedMap.put(\"timeStamp\",Long.toString(1576922894903L));\n        sortedMap.put(\"you\",\"me\");\n        Assert.assertEquals(\"4fcd007d0eb88b928a2c1ffdc8ad7127aa06eafe1eec22bc809ad95a5833009f\",GenerateSignUtils.generateSignatureByAES(sortedMap));\n    }\n}", "class_id": 0, "repo": "YiBuBuHuiTou/littleTime", "file": "littleTime_service/common/src/test/java/com/cxd/littletime/common/util/GenerateSignUtilsTest.java", "last_update_at": "2019-12-14T04:48:10+00:00", "question_id": "0d41d003c6ce2821ac7b75dfd5367e245d0832da", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GenerateSignUtilsTest {\n    @Test(timeout = 100)\n    public void generateSignatureByAES() throws Exception{\n        SortedMap<String,String> sortedMap = new TreeMap<String,String>();\n        sortedMap.put(\"testKey1\",\"testvalue1\");\n        sortedMap.put(\"testvalue1\",\"testKey1\");\n        sortedMap.put(\"timeStamp\",Long.toString(1576922894903L));\n        sortedMap.put(\"you\",\"me\");\n        Assert.assertEquals(\"4fcd007d0eb88b928a2c1ffdc8ad7127aa06eafe1eec22bc809ad95a5833009f\",GenerateSignUtils.generateSignatureByAES(sortedMap));\n    }\n"]]}
{"hexsha": "553fd24b554214847d3ff9c9b63403c55f9b5b41", "ext": "java", "lang": "Java", "content": "@SuppressWarnings({\"serial\", \"EqualsWhichDoesntCheckParameterClass\", \n\t\t\"StatementWithEmptyBody\", \"KeySetIterationMayUseEntrySet\"})\npublic class NonReusingHashJoinIteratorITCase extends TestLogger {\n\t\n\tprivate static final int MEMORY_SIZE = 16000000;\t\t// total memory\n\n\tprivate static final int INPUT_1_SIZE = 20000;\n\tprivate static final int INPUT_2_SIZE = 1000;\n\n\tprivate static final long SEED1 = 561349061987311L;\n\tprivate static final long SEED2 = 231434613412342L;\n\t\n\tprivate final AbstractInvokable parentTask = new DummyInvokable();\n\n\tprivate IOManager ioManager;\n\tprivate MemoryManager memoryManager;\n\t\n\tprivate TypeSerializer<Tuple2<Integer, String>> recordSerializer;\n\tprivate TypeComparator<Tuple2<Integer, String>> record1Comparator;\n\tprivate TypeComparator<Tuple2<Integer, String>> record2Comparator;\n\tprivate TypePairComparator<Tuple2<Integer, String>, Tuple2<Integer, String>> recordPairComparator;\n\t\n\tprivate TypeSerializer<IntPair> pairSerializer;\n\tprivate TypeComparator<IntPair> pairComparator;\n\tprivate TypePairComparator<IntPair, Tuple2<Integer, String>> pairRecordPairComparator;\n\tprivate TypePairComparator<Tuple2<Integer, String>, IntPair> recordPairPairComparator;\n\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Before\n\tpublic void beforeTest() {\n\t\tthis.recordSerializer = TestData.getIntStringTupleSerializer();\n\t\t\n\t\tthis.record1Comparator = TestData.getIntStringTupleComparator();\n\t\tthis.record2Comparator = TestData.getIntStringTupleComparator();\n\t\t\n\t\tthis.recordPairComparator = new GenericPairComparator(record1Comparator, record2Comparator);\n\t\t\n\t\tthis.pairSerializer = new IntPairSerializer();\n\t\tthis.pairComparator = new TestData.IntPairComparator();\n\t\tthis.pairRecordPairComparator = new IntPairTuplePairComparator();\n\t\tthis.recordPairPairComparator = new TupleIntPairPairComparator();\n\t\t\n\t\tthis.memoryManager = new MemoryManager(MEMORY_SIZE, 1);\n\t\tthis.ioManager = new IOManagerAsync();\n\t}\n\n\t@After\n\tpublic void afterTest() throws Exception {\n\t\tif (this.ioManager != null) {\n\t\t\tthis.ioManager.close();\n\t\t\tthis.ioManager = null;\n\t\t}\n\t\t\n\t\tif (this.memoryManager != null) {\n\t\t\tAssert.assertTrue(\"Memory Leak: Not all memory has been returned to the memory manager.\",\n\t\t\t\tthis.memoryManager.verifyEmpty());\n\t\t\tthis.memoryManager.shutdown();\n\t\t\tthis.memoryManager = null;\n\t\t}\n\t}\n\n\n\t@Test\n\tpublic void testBuildFirst() {\n\t\ttry {\n\t\t\tTupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\tTupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\t\n\t\t\tfinal TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);\n\t\t\tfinal TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);\n\t\t\t\n\t\t\t// collect expected data\n\t\t\tfinal Map<Integer, Collection<TupleMatch>> expectedMatchesMap = joinTuples(\n\t\t\t\t\tcollectTupleData(input1),\n\t\t\t\t\tcollectTupleData(input2));\n\t\t\t\n\t\t\tfinal TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);\n\t\t\tfinal Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<Tuple2<Integer, String>>();\n\t\n\t\t\t// reset the generators\n\t\t\tgenerator1.reset();\n\t\t\tgenerator2.reset();\n\t\t\tinput1.reset();\n\t\t\tinput2.reset();\n\t\n\t\t\t// compare with iterator values\n\t\t\tNonReusingBuildFirstHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =\n\t\t\t\t\tnew NonReusingBuildFirstHashJoinIterator<>(\n\t\t\t\t\t\tinput1, input2, this.recordSerializer, this.record1Comparator, \n\t\t\t\t\t\tthis.recordSerializer, this.record2Comparator, this.recordPairComparator,\n\t\t\t\t\t\tthis.memoryManager, ioManager, this.parentTask, 1.0, false, false, true);\n\t\t\t\n\t\t\titerator.open();\n\n\t\t\t//noinspection StatementWithEmptyBody\n\t\t\twhile (iterator.callWithNextKey(matcher, collector));\n\t\t\t\n\t\t\titerator.close();\n\t\n\t\t\t// assert that each expected match was seen\n\t\t\tfor (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {\n\t\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\t\tAssert.fail(\"Collection for key \" + entry.getKey() + \" is not empty\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"An exception occurred during the test: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testBuildFirstWithHighNumberOfCommonKeys()\n\t{\n\t\t// the size of the left and right inputs\n\t\tfinal int INPUT_1_SIZE = 200;\n\t\tfinal int INPUT_2_SIZE = 100;\n\t\t\n\t\tfinal int INPUT_1_DUPLICATES = 10;\n\t\tfinal int INPUT_2_DUPLICATES = 2000;\n\t\tfinal int DUPLICATE_KEY = 13;\n\t\t\n\t\ttry {\n\t\t\tTupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\tTupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\t\n\t\t\tfinal TestData.TupleGeneratorIterator gen1Iter = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);\n\t\t\tfinal TestData.TupleGeneratorIterator gen2Iter = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);\n\t\t\t\n\t\t\tfinal TestData.TupleConstantValueIterator const1Iter = new TestData.TupleConstantValueIterator(DUPLICATE_KEY, \"LEFT String for Duplicate Keys\", INPUT_1_DUPLICATES);\n\t\t\tfinal TestData.TupleConstantValueIterator const2Iter = new TestData.TupleConstantValueIterator(DUPLICATE_KEY, \"RIGHT String for Duplicate Keys\", INPUT_2_DUPLICATES);\n\t\t\t\n\t\t\tfinal List<MutableObjectIterator<Tuple2<Integer, String>>> inList1 = new ArrayList<>();\n\t\t\tinList1.add(gen1Iter);\n\t\t\tinList1.add(const1Iter);\n\t\t\t\n\t\t\tfinal List<MutableObjectIterator<Tuple2<Integer, String>>> inList2 = new ArrayList<>();\n\t\t\tinList2.add(gen2Iter);\n\t\t\tinList2.add(const2Iter);\n\t\t\t\n\t\t\tMutableObjectIterator<Tuple2<Integer, String>> input1 = new UnionIterator<>(inList1);\n\t\t\tMutableObjectIterator<Tuple2<Integer, String>> input2 = new UnionIterator<>(inList2);\n\t\t\t\n\t\t\t\n\t\t\t// collect expected data\n\t\t\tfinal Map<Integer, Collection<TupleMatch>> expectedMatchesMap = joinTuples(\n\t\t\t\t\tcollectTupleData(input1),\n\t\t\t\t\tcollectTupleData(input2));\n\t\t\t\n\t\t\t// re-create the whole thing for actual processing\n\t\t\t\n\t\t\t// reset the generators and iterators\n\t\t\tgenerator1.reset();\n\t\t\tgenerator2.reset();\n\t\t\tconst1Iter.reset();\n\t\t\tconst2Iter.reset();\n\t\t\tgen1Iter.reset();\n\t\t\tgen2Iter.reset();\n\t\t\t\n\t\t\tinList1.clear();\n\t\t\tinList1.add(gen1Iter);\n\t\t\tinList1.add(const1Iter);\n\t\t\t\n\t\t\tinList2.clear();\n\t\t\tinList2.add(gen2Iter);\n\t\t\tinList2.add(const2Iter);\n\t\n\t\t\tinput1 = new UnionIterator<>(inList1);\n\t\t\tinput2 = new UnionIterator<>(inList2);\n\t\t\t\n\t\t\tfinal TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);\n\t\t\tfinal Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();\n\t\n\t\t\tNonReusingBuildFirstHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =\n\t\t\t\t\tnew NonReusingBuildFirstHashJoinIterator<>(\n\t\t\t\t\t\tinput1, input2, this.recordSerializer, this.record1Comparator, \n\t\t\t\t\t\tthis.recordSerializer, this.record2Comparator, this.recordPairComparator,\n\t\t\t\t\t\tthis.memoryManager, ioManager, this.parentTask, 1.0, false, false, true);\n\n\t\t\titerator.open();\n\t\t\t\n\t\t\twhile (iterator.callWithNextKey(matcher, collector));\n\t\t\t\n\t\t\titerator.close();\n\t\n\t\t\t// assert that each expected match was seen\n\t\t\tfor (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {\n\t\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\t\tAssert.fail(\"Collection for key \" + entry.getKey() + \" is not empty\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"An exception occurred during the test: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testBuildSecond() {\n\t\ttry {\n\t\t\tTupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\tTupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\t\n\t\t\tfinal TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);\n\t\t\tfinal TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);\n\t\t\t\n\t\t\t// collect expected data\n\t\t\tfinal Map<Integer, Collection<TupleMatch>> expectedMatchesMap = joinTuples(\n\t\t\t\t\tcollectTupleData(input1),\n\t\t\t\t\tcollectTupleData(input2));\n\t\t\t\n\t\t\tfinal TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);\n\t\t\tfinal Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();\n\t\n\t\t\t// reset the generators\n\t\t\tgenerator1.reset();\n\t\t\tgenerator2.reset();\n\t\t\tinput1.reset();\n\t\t\tinput2.reset();\n\t\n\t\t\t// compare with iterator values\t\t\t\n\t\t\tNonReusingBuildSecondHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =\n\t\t\t\tnew NonReusingBuildSecondHashJoinIterator<>(\n\t\t\t\t\tinput1, input2, this.recordSerializer, this.record1Comparator, \n\t\t\t\t\tthis.recordSerializer, this.record2Comparator, this.recordPairComparator,\n\t\t\t\t\tthis.memoryManager, ioManager, this.parentTask, 1.0, false, false, true);\n\n\t\t\titerator.open();\n\t\t\t\n\t\t\twhile (iterator.callWithNextKey(matcher, collector));\n\t\t\t\n\t\t\titerator.close();\n\t\n\t\t\t// assert that each expected match was seen\n\t\t\tfor (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {\n\t\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\t\tAssert.fail(\"Collection for key \" + entry.getKey() + \" is not empty\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"An exception occurred during the test: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testBuildSecondWithHighNumberOfCommonKeys()\n\t{\n\t\t// the size of the left and right inputs\n\t\tfinal int INPUT_1_SIZE = 200;\n\t\tfinal int INPUT_2_SIZE = 100;\n\t\t\n\t\tfinal int INPUT_1_DUPLICATES = 10;\n\t\tfinal int INPUT_2_DUPLICATES = 2000;\n\t\tfinal int DUPLICATE_KEY = 13;\n\t\t\n\t\ttry {\n\t\t\tTupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\tTupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\t\n\t\t\tfinal TestData.TupleGeneratorIterator gen1Iter = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);\n\t\t\tfinal TestData.TupleGeneratorIterator gen2Iter = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);\n\t\t\t\n\t\t\tfinal TestData.TupleConstantValueIterator const1Iter = new TestData.TupleConstantValueIterator(DUPLICATE_KEY, \"LEFT String for Duplicate Keys\", INPUT_1_DUPLICATES);\n\t\t\tfinal TestData.TupleConstantValueIterator const2Iter = new TestData.TupleConstantValueIterator(DUPLICATE_KEY, \"RIGHT String for Duplicate Keys\", INPUT_2_DUPLICATES);\n\t\t\t\n\t\t\tfinal List<MutableObjectIterator<Tuple2<Integer, String>>> inList1 = new ArrayList<>();\n\t\t\tinList1.add(gen1Iter);\n\t\t\tinList1.add(const1Iter);\n\t\t\t\n\t\t\tfinal List<MutableObjectIterator<Tuple2<Integer, String>>> inList2 = new ArrayList<>();\n\t\t\tinList2.add(gen2Iter);\n\t\t\tinList2.add(const2Iter);\n\t\t\t\n\t\t\tMutableObjectIterator<Tuple2<Integer, String>> input1 = new UnionIterator<>(inList1);\n\t\t\tMutableObjectIterator<Tuple2<Integer, String>> input2 = new UnionIterator<>(inList2);\n\t\t\t\n\t\t\t\n\t\t\t// collect expected data\n\t\t\tfinal Map<Integer, Collection<TupleMatch>> expectedMatchesMap = joinTuples(\n\t\t\t\t\tcollectTupleData(input1),\n\t\t\t\t\tcollectTupleData(input2));\n\t\t\t\n\t\t\t// re-create the whole thing for actual processing\n\t\t\t\n\t\t\t// reset the generators and iterators\n\t\t\tgenerator1.reset();\n\t\t\tgenerator2.reset();\n\t\t\tconst1Iter.reset();\n\t\t\tconst2Iter.reset();\n\t\t\tgen1Iter.reset();\n\t\t\tgen2Iter.reset();\n\t\t\t\n\t\t\tinList1.clear();\n\t\t\tinList1.add(gen1Iter);\n\t\t\tinList1.add(const1Iter);\n\t\t\t\n\t\t\tinList2.clear();\n\t\t\tinList2.add(gen2Iter);\n\t\t\tinList2.add(const2Iter);\n\t\n\t\t\tinput1 = new UnionIterator<>(inList1);\n\t\t\tinput2 = new UnionIterator<>(inList2);\n\t\t\t\n\t\t\tfinal TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);\n\t\t\tfinal Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();\n\n\t\t\tNonReusingBuildSecondHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =\n\t\t\t\tnew NonReusingBuildSecondHashJoinIterator<>(\n\t\t\t\t\tinput1, input2, this.recordSerializer, this.record1Comparator, \n\t\t\t\t\tthis.recordSerializer, this.record2Comparator, this.recordPairComparator,\n\t\t\t\t\tthis.memoryManager, ioManager, this.parentTask, 1.0, false, false, true);\n\t\t\t\n\t\t\titerator.open();\n\t\t\t\n\t\t\twhile (iterator.callWithNextKey(matcher, collector));\n\t\t\t\n\t\t\titerator.close();\n\t\n\t\t\t// assert that each expected match was seen\n\t\t\tfor (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {\n\t\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\t\tAssert.fail(\"Collection for key \" + entry.getKey() + \" is not empty\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"An exception occurred during the test: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testBuildFirstWithMixedDataTypes() {\n\t\ttry {\n\t\t\tMutableObjectIterator<IntPair> input1 = new UniformIntPairGenerator(500, 40, false);\n\t\t\t\n\t\t\tfinal TupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\tfinal TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);\n\t\t\t\n\t\t\t// collect expected data\n\t\t\tfinal Map<Integer, Collection<TupleIntPairMatch>> expectedMatchesMap = joinIntPairs(\n\t\t\t\t\tcollectIntPairData(input1),\n\t\t\t\t\tcollectTupleData(input2));\n\t\t\t\n\t\t\tfinal FlatJoinFunction<IntPair, Tuple2<Integer, String>, Tuple2<Integer, String>> matcher = new TupleIntPairMatchRemovingMatcher(expectedMatchesMap);\n\t\t\tfinal Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();\n\t\n\t\t\t// reset the generators\n\t\t\tinput1 = new UniformIntPairGenerator(500, 40, false);\n\t\t\tgenerator2.reset();\n\t\t\tinput2.reset();\n\t\n\t\t\t// compare with iterator values\n\t\t\tNonReusingBuildSecondHashJoinIterator<IntPair, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =\n\t\t\t\t\tnew NonReusingBuildSecondHashJoinIterator<>(\n\t\t\t\t\t\tinput1, input2, this.pairSerializer, this.pairComparator,\n\t\t\t\t\t\tthis.recordSerializer, this.record2Comparator, this.pairRecordPairComparator,\n\t\t\t\t\t\tthis.memoryManager, this.ioManager, this.parentTask, 1.0, false, false, true);\n\t\t\t\n\t\t\titerator.open();\n\t\t\t\n\t\t\twhile (iterator.callWithNextKey(matcher, collector));\n\t\t\t\n\t\t\titerator.close();\n\t\n\t\t\t// assert that each expected match was seen\n\t\t\tfor (Entry<Integer, Collection<TupleIntPairMatch>> entry : expectedMatchesMap.entrySet()) {\n\t\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\t\tAssert.fail(\"Collection for key \" + entry.getKey() + \" is not empty\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"An exception occurred during the test: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testBuildSecondWithMixedDataTypes() {\n\t\ttry {\n\t\t\tMutableObjectIterator<IntPair> input1 = new UniformIntPairGenerator(500, 40, false);\n\t\t\t\n\t\t\tfinal TupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\tfinal TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);\n\t\t\t\n\t\t\t// collect expected data\n\t\t\tfinal Map<Integer, Collection<TupleIntPairMatch>> expectedMatchesMap = joinIntPairs(\n\t\t\t\t\tcollectIntPairData(input1),\n\t\t\t\t\tcollectTupleData(input2));\n\t\t\t\n\t\t\tfinal FlatJoinFunction<IntPair, Tuple2<Integer, String>, Tuple2<Integer, String>> matcher = new TupleIntPairMatchRemovingMatcher(expectedMatchesMap);\n\t\t\tfinal Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();\n\t\n\t\t\t// reset the generators\n\t\t\tinput1 = new UniformIntPairGenerator(500, 40, false);\n\t\t\tgenerator2.reset();\n\t\t\tinput2.reset();\n\t\n\t\t\t// compare with iterator values\n\t\t\tNonReusingBuildFirstHashJoinIterator<IntPair, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =\n\t\t\t\t\tnew NonReusingBuildFirstHashJoinIterator<>(\n\t\t\t\t\t\tinput1, input2, this.pairSerializer, this.pairComparator, \n\t\t\t\t\t\tthis.recordSerializer, this.record2Comparator, this.recordPairPairComparator,\n\t\t\t\t\t\tthis.memoryManager, this.ioManager, this.parentTask, 1.0, false, false, true);\n\t\t\t\n\t\t\titerator.open();\n\t\t\t\n\t\t\twhile (iterator.callWithNextKey(matcher, collector));\n\t\t\t\n\t\t\titerator.close();\n\t\n\t\t\t// assert that each expected match was seen\n\t\t\tfor (Entry<Integer, Collection<TupleIntPairMatch>> entry : expectedMatchesMap.entrySet()) {\n\t\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\t\tAssert.fail(\"Collection for key \" + entry.getKey() + \" is not empty\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"An exception occurred during the test: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testBuildFirstAndProbeSideOuterJoin() {\n\t\ttry {\n\t\t\tTupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\tTupleGenerator generator2 = new TupleGenerator(SEED2, 1000, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\n\t\t\tfinal TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);\n\t\t\tfinal TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);\n\t\n\t\t\t// collect expected data\n\t\t\tfinal Map<Integer, Collection<TupleMatch>> expectedMatchesMap = rightOuterJoinTuples(\n\t\t\t\t\tcollectTupleData(input1),\n\t\t\t\t\tcollectTupleData(input2));\n\t\n\t\t\tfinal TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);\n\t\t\tfinal Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();\n\t\n\t\t\t// reset the generators\n\t\t\tgenerator1.reset();\n\t\t\tgenerator2.reset();\n\t\t\tinput1.reset();\n\t\t\tinput2.reset();\n\t\n\t\t\t// compare with iterator values\n\t\t\tNonReusingBuildFirstHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =\n\t\t\t\t\tnew NonReusingBuildFirstHashJoinIterator<>(\n\t\t\t\t\t\t\tinput1, input2, this.recordSerializer, this.record1Comparator,\n\t\t\t\t\t\t\tthis.recordSerializer, this.record2Comparator, this.recordPairComparator,\n\t\t\t\t\t\t\tthis.memoryManager, ioManager, this.parentTask, 1.0, true, false, false);\n\t\n\t\t\titerator.open();\n\t\n\t\t\twhile (iterator.callWithNextKey(matcher, collector));\n\t\n\t\t\titerator.close();\n\t\n\t\t\t// assert that each expected match was seen\n\t\t\tfor (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {\n\t\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\t\tAssert.fail(\"Collection for key \" + entry.getKey() + \" is not empty\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"An exception occurred during the test: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testBuildFirstAndBuildSideOuterJoin() {\n\t\ttry {\n\t\t\tTupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\tTupleGenerator generator2 = new TupleGenerator(SEED2, 1000, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\n\t\t\tfinal TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);\n\t\t\tfinal TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);\n\t\n\t\t\t// collect expected data\n\t\t\tfinal Map<Integer, Collection<TupleMatch>> expectedMatchesMap = leftOuterJoinTuples(\n\t\t\t\tcollectTupleData(input1),\n\t\t\t\tcollectTupleData(input2));\n\t\n\t\t\tfinal TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);\n\t\t\tfinal Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();\n\t\n\t\t\t// reset the generators\n\t\t\tgenerator1.reset();\n\t\t\tgenerator2.reset();\n\t\t\tinput1.reset();\n\t\t\tinput2.reset();\n\t\n\t\t\t// compare with iterator values\n\t\t\tNonReusingBuildFirstHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =\n\t\t\t\tnew NonReusingBuildFirstHashJoinIterator<>(\n\t\t\t\t\tinput1, input2, this.recordSerializer, this.record1Comparator,\n\t\t\t\t\tthis.recordSerializer, this.record2Comparator, this.recordPairComparator,\n\t\t\t\t\tthis.memoryManager, ioManager, this.parentTask, 1.0, false, true, false);\n\t\n\t\t\titerator.open();\n\t\n\t\t\twhile (iterator.callWithNextKey(matcher, collector));\n\t\n\t\t\titerator.close();\n\t\n\t\t\t// assert that each expected match was seen\n\t\t\tfor (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {\n\t\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\t\tAssert.fail(\"Collection for key \" + entry.getKey() + \" is not empty\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"An exception occurred during the test: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testBuildFirstAndFullOuterJoin() {\n\t\ttry {\n\t\t\tTupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\tTupleGenerator generator2 = new TupleGenerator(SEED2, 1000, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\n\t\t\tfinal TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);\n\t\t\tfinal TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);\n\t\n\t\t\t// collect expected data\n\t\t\tfinal Map<Integer, Collection<TupleMatch>> expectedMatchesMap = fullOuterJoinTuples(\n\t\t\t\tcollectTupleData(input1),\n\t\t\t\tcollectTupleData(input2));\n\t\n\t\t\tfinal TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);\n\t\t\tfinal Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();\n\t\n\t\t\t// reset the generators\n\t\t\tgenerator1.reset();\n\t\t\tgenerator2.reset();\n\t\t\tinput1.reset();\n\t\t\tinput2.reset();\n\t\n\t\t\t// compare with iterator values\n\t\t\tNonReusingBuildFirstHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =\n\t\t\t\tnew NonReusingBuildFirstHashJoinIterator<>(\n\t\t\t\t\tinput1, input2, this.recordSerializer, this.record1Comparator,\n\t\t\t\t\tthis.recordSerializer, this.record2Comparator, this.recordPairComparator,\n\t\t\t\t\tthis.memoryManager, ioManager, this.parentTask, 1.0, true, true, false);\n\t\n\t\t\titerator.open();\n\t\n\t\t\twhile (iterator.callWithNextKey(matcher, collector));\n\t\n\t\t\titerator.close();\n\t\n\t\t\t// assert that each expected match was seen\n\t\t\tfor (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {\n\t\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\t\tAssert.fail(\"Collection for key \" + entry.getKey() + \" is not empty\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"An exception occurred during the test: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testBuildSecondAndProbeSideOuterJoin() {\n\t\ttry {\n\t\t\tTupleGenerator generator1 = new TupleGenerator(SEED1, 1000, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\tTupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\n\t\t\tfinal TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);\n\t\t\tfinal TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);\n\t\n\t\t\t// collect expected data\n\t\t\tfinal Map<Integer, Collection<TupleMatch>> expectedMatchesMap = leftOuterJoinTuples(\n\t\t\t\t\tcollectTupleData(input1),\n\t\t\t\t\tcollectTupleData(input2));\n\t\n\t\t\tfinal TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);\n\t\t\tfinal Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();\n\t\n\t\t\t// reset the generators\n\t\t\tgenerator1.reset();\n\t\t\tgenerator2.reset();\n\t\t\tinput1.reset();\n\t\t\tinput2.reset();\n\t\n\t\t\t// compare with iterator values\n\t\t\tNonReusingBuildSecondHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =\n\t\t\t\t\tnew NonReusingBuildSecondHashJoinIterator<>(\n\t\t\t\t\t\t\tinput1, input2, this.recordSerializer, this.record1Comparator,\n\t\t\t\t\t\t\tthis.recordSerializer, this.record2Comparator, this.recordPairComparator,\n\t\t\t\t\t\t\tthis.memoryManager, ioManager, this.parentTask, 1.0, true, false, false);\n\t\n\t\t\titerator.open();\n\t\n\t\t\twhile (iterator.callWithNextKey(matcher, collector));\n\t\n\t\t\titerator.close();\n\t\n\t\t\t// assert that each expected match was seen\n\t\t\tfor (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {\n\t\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\t\tAssert.fail(\"Collection for key \" + entry.getKey() + \" is not empty\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"An exception occurred during the test: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testBuildSecondAndBuildSideOuterJoin() {\n\t\ttry {\n\t\t\tTupleGenerator generator1 = new TupleGenerator(SEED1, 1000, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\tTupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\n\t\t\tfinal TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);\n\t\t\tfinal TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);\n\t\n\t\t\t// collect expected data\n\t\t\tfinal Map<Integer, Collection<TupleMatch>> expectedMatchesMap = rightOuterJoinTuples(\n\t\t\t\tcollectTupleData(input1),\n\t\t\t\tcollectTupleData(input2));\n\t\n\t\t\tfinal TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);\n\t\t\tfinal Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();\n\t\n\t\t\t// reset the generators\n\t\t\tgenerator1.reset();\n\t\t\tgenerator2.reset();\n\t\t\tinput1.reset();\n\t\t\tinput2.reset();\n\t\n\t\t\t// compare with iterator values\n\t\t\tNonReusingBuildSecondHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =\n\t\t\t\tnew NonReusingBuildSecondHashJoinIterator<>(\n\t\t\t\t\tinput1, input2, this.recordSerializer, this.record1Comparator,\n\t\t\t\t\tthis.recordSerializer, this.record2Comparator, this.recordPairComparator,\n\t\t\t\t\tthis.memoryManager, ioManager, this.parentTask, 1.0, false, true, false);\n\t\n\t\t\titerator.open();\n\t\n\t\t\twhile (iterator.callWithNextKey(matcher, collector));\n\t\n\t\t\titerator.close();\n\t\n\t\t\t// assert that each expected match was seen\n\t\t\tfor (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {\n\t\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\t\tAssert.fail(\"Collection for key \" + entry.getKey() + \" is not empty\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"An exception occurred during the test: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testBuildSecondAndFullOuterJoin() {\n\t\ttry {\n\t\t\tTupleGenerator generator1 = new TupleGenerator(SEED1, 1000, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\tTupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\n\t\t\tfinal TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);\n\t\t\tfinal TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);\n\t\n\t\t\t// collect expected data\n\t\t\tfinal Map<Integer, Collection<TupleMatch>> expectedMatchesMap = fullOuterJoinTuples(\n\t\t\t\tcollectTupleData(input1),\n\t\t\t\tcollectTupleData(input2));\n\t\n\t\t\tfinal TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);\n\t\t\tfinal Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();\n\t\n\t\t\t// reset the generators\n\t\t\tgenerator1.reset();\n\t\t\tgenerator2.reset();\n\t\t\tinput1.reset();\n\t\t\tinput2.reset();\n\t\n\t\t\t// compare with iterator values\n\t\t\tNonReusingBuildSecondHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =\n\t\t\t\tnew NonReusingBuildSecondHashJoinIterator<>(\n\t\t\t\t\tinput1, input2, this.recordSerializer, this.record1Comparator,\n\t\t\t\t\tthis.recordSerializer, this.record2Comparator, this.recordPairComparator,\n\t\t\t\t\tthis.memoryManager, ioManager, this.parentTask, 1.0, true, true, false);\n\t\n\t\t\titerator.open();\n\t\n\t\t\twhile (iterator.callWithNextKey(matcher, collector));\n\t\n\t\t\titerator.close();\n\t\n\t\t\t// assert that each expected match was seen\n\t\t\tfor (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {\n\t\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\t\tAssert.fail(\"Collection for key \" + entry.getKey() + \" is not empty\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"An exception occurred during the test: \" + e.getMessage());\n\t\t}\n\t}\n\t\t\n\t// --------------------------------------------------------------------------------------------\n\t//                                    Utilities\n\t// --------------------------------------------------------------------------------------------\n\n\t\n\t\n\tpublic static Map<Integer, Collection<TupleMatch>> joinTuples(\n\t\t\tMap<Integer, Collection<String>> leftMap,\n\t\t\tMap<Integer, Collection<String>> rightMap)\n\t{\n\t\tMap<Integer, Collection<TupleMatch>> map = new HashMap<>();\n\n\t\tfor (Integer key : leftMap.keySet()) {\n\t\t\tCollection<String> leftValues = leftMap.get(key);\n\t\t\tCollection<String> rightValues = rightMap.get(key);\n\n\t\t\tif (rightValues == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!map.containsKey(key)) {\n\t\t\t\tmap.put(key, new ArrayList<TupleMatch>());\n\t\t\t}\n\n\t\t\tCollection<TupleMatch> matchedValues = map.get(key);\n\n\t\t\tfor (String leftValue : leftValues) {\n\t\t\t\tfor (String rightValue : rightValues) {\n\t\t\t\t\tmatchedValues.add(new TupleMatch(leftValue, rightValue));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn map;\n\t}\n\n\tpublic static Map<Integer, Collection<TupleMatch>> leftOuterJoinTuples(\n\t\t\tMap<Integer, Collection<String>> leftMap,\n\t\t\tMap<Integer, Collection<String>> rightMap)\n\t{\n\t\tMap<Integer, Collection<TupleMatch>> map = new HashMap<>();\n\n\t\tfor (Integer key : leftMap.keySet()) {\n\t\t\tCollection<String> leftValues = leftMap.get(key);\n\t\t\tCollection<String> rightValues = rightMap.get(key);\n\n\t\t\tif (!map.containsKey(key)) {\n\t\t\t\tmap.put(key, new ArrayList<TupleMatch>());\n\t\t\t}\n\n\t\t\tCollection<TupleMatch> matchedValues = map.get(key);\n\n\t\t\tfor (String leftValue : leftValues) {\n\t\t\t\tif(rightValues != null) {\n\t\t\t\t\tfor (String rightValue : rightValues) {\n\t\t\t\t\t\tmatchedValues.add(new TupleMatch(leftValue, rightValue));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmatchedValues.add(new TupleMatch(leftValue, null));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn map;\n\t}\n\n\tpublic static Map<Integer, Collection<TupleMatch>> rightOuterJoinTuples(\n\t\t\tMap<Integer, Collection<String>> leftMap,\n\t\t\tMap<Integer, Collection<String>> rightMap)\n\t{\n\t\tMap<Integer, Collection<TupleMatch>> map = new HashMap<>();\n\n\t\tfor (Integer key : rightMap.keySet()) {\n\t\t\tCollection<String> leftValues = leftMap.get(key);\n\t\t\tCollection<String> rightValues = rightMap.get(key);\n\n\t\t\tif (!map.containsKey(key)) {\n\t\t\t\tmap.put(key, new ArrayList<TupleMatch>());\n\t\t\t}\n\n\t\t\tCollection<TupleMatch> matchedValues = map.get(key);\n\n\t\t\tfor (String rightValue : rightValues) {\n\t\t\t\tif(leftValues != null) {\n\t\t\t\t\tfor (String leftValue : leftValues) {\n\t\t\t\t\t\tmatchedValues.add(new TupleMatch(leftValue, rightValue));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmatchedValues.add(new TupleMatch(null, rightValue));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn map;\n\t}\n\n\tpublic static Map<Integer, Collection<TupleMatch>> fullOuterJoinTuples(\n\t\tMap<Integer, Collection<String>> leftMap,\n\t\tMap<Integer, Collection<String>> rightMap)\n\t{\n\t\tMap<Integer, Collection<TupleMatch>> map = new HashMap<>();\n\n\t\tfor (Integer key : rightMap.keySet()) {\n\t\t\tCollection<String> leftValues = leftMap.get(key);\n\t\t\tCollection<String> rightValues = rightMap.get(key);\n\n\t\t\tif (!map.containsKey(key)) {\n\t\t\t\tmap.put(key, new ArrayList<TupleMatch>());\n\t\t\t}\n\n\t\t\tCollection<TupleMatch> matchedValues = map.get(key);\n\n\t\t\tfor (String rightValue : rightValues) {\n\t\t\t\tif(leftValues != null) {\n\t\t\t\t\tfor (String leftValue : leftValues) {\n\t\t\t\t\t\tmatchedValues.add(new TupleMatch(leftValue, rightValue));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmatchedValues.add(new TupleMatch(null, rightValue));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (Integer key : leftMap.keySet()) {\n\t\t\tCollection<String> leftValues = leftMap.get(key);\n\t\t\tCollection<String> rightValues = rightMap.get(key);\n\t\t\tif (rightValues == null) {\n\t\t\t\tif (!map.containsKey(key)) {\n\t\t\t\t\tmap.put(key, new ArrayList<TupleMatch>());\n\t\t\t\t}\n\n\t\t\t\tCollection<TupleMatch> matchedValues = map.get(key);\n\n\t\t\t\tfor (String leftValue : leftValues) {\n\t\t\t\t\tmatchedValues.add(new TupleMatch(leftValue, null));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn map;\n\t}\n\t\n\tpublic static Map<Integer, Collection<TupleIntPairMatch>> joinIntPairs(\n\t\t\tMap<Integer, Collection<Integer>> leftMap,\n\t\t\tMap<Integer, Collection<String>> rightMap)\n\t{\n\t\tfinal Map<Integer, Collection<TupleIntPairMatch>> map = new HashMap<>();\n\t\n\t\tfor (Integer i : leftMap.keySet()) {\n\t\t\t\n\t\t\tfinal Collection<Integer> leftValues = leftMap.get(i);\n\t\t\tfinal Collection<String> rightValues = rightMap.get(i);\n\t\n\t\t\tif (rightValues == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\tif (!map.containsKey(i)) {\n\t\t\t\tmap.put(i, new ArrayList<TupleIntPairMatch>());\n\t\t\t}\n\t\n\t\t\tfinal Collection<TupleIntPairMatch> matchedValues = map.get(i);\n\t\n\t\t\tfor (Integer v : leftValues) {\n\t\t\t\tfor (String val : rightValues) {\n\t\t\t\t\tmatchedValues.add(new TupleIntPairMatch(v, val));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn map;\n\t}\n\n\t\n\tpublic static Map<Integer, Collection<String>> collectTupleData(MutableObjectIterator<Tuple2<Integer, String>> iter)\n\tthrows Exception\n\t{\n\t\tMap<Integer, Collection<String>> map = new HashMap<>();\n\t\tTuple2<Integer, String> pair = new Tuple2<>();\n\t\t\n\t\twhile ((pair = iter.next(pair)) != null) {\n\n\t\t\tInteger key = pair.f0;\n\t\t\tif (!map.containsKey(key)) {\n\t\t\t\tmap.put(key, new ArrayList<String>());\n\t\t\t}\n\n\t\t\tCollection<String> values = map.get(key);\n\t\t\tvalues.add(pair.f1);\n\t\t}\n\n\t\treturn map;\n\t}\n\t\n\tpublic static Map<Integer, Collection<Integer>> collectIntPairData(MutableObjectIterator<IntPair> iter)\n\tthrows Exception\n\t{\n\t\tMap<Integer, Collection<Integer>> map = new HashMap<>();\n\t\tIntPair pair = new IntPair();\n\t\t\n\t\twhile ((pair = iter.next(pair)) != null) {\n\n\t\t\tfinal int key = pair.getKey();\n\t\t\tfinal int value = pair.getValue();\n\t\t\tif (!map.containsKey(key)) {\n\t\t\t\tmap.put(key, new ArrayList<Integer>());\n\t\t\t}\n\n\t\t\tCollection<Integer> values = map.get(key);\n\t\t\tvalues.add(value);\n\t\t}\n\n\t\treturn map;\n\t}\n\n\t/**\n\t * Class used for storage of the expected matches in a hash-map.\n\t */\n\tpublic static class TupleMatch {\n\t\t\n\t\tprivate final String left;\n\t\tprivate final String right;\n\n\t\tpublic TupleMatch(String left, String right) {\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tTupleMatch that = (TupleMatch) obj;\n\n\t\t\treturn (this.right == null ? that.right == null :\n\t\t\t\t\t\t\t(that.right != null && this.right.equals(that.right))) &&\n\t\t\t\t\t(this.left == null ? that.left == null :\n\t\t\t\t\t\t\t(that.left != null && this.left.equals(that.left)));\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tint hc = this.left != null ? this.left.hashCode() : 23;\n\t\t\thc = hc ^ (this.right != null ? this.right.hashCode() : 41);\n\t\t\treturn hc;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tString s = left == null ? \"<null>\" : left;\n\t\t\ts += \", \" + (right == null ? \"<null>\" : right);\n\t\t\treturn s;\n\t\t}\n\t}\n\t\n\t/**\n\t * Private class used for storage of the expected matches in a hash-map.\n\t */\n\tpublic static class TupleIntPairMatch\n\t{\n\t\tprivate final int left;\n\t\tprivate final String right;\n\n\t\tpublic TupleIntPairMatch(int left, String right) {\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tTupleIntPairMatch o = (TupleIntPairMatch) obj;\n\t\t\treturn this.left == o.left && this.right.equals(o.right);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn this.left ^ this.right.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn left + \", \" + right;\n\t\t}\n\t}\n\t\n\tstatic final class TupleMatchRemovingJoin implements FlatJoinFunction<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>>\n\t{\n\t\tprivate final Map<Integer, Collection<TupleMatch>> toRemoveFrom;\n\t\t\n\t\tprotected TupleMatchRemovingJoin(Map<Integer, Collection<TupleMatch>> map) {\n\t\t\tthis.toRemoveFrom = map;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void join(Tuple2<Integer, String> rec1, Tuple2<Integer, String> rec2, Collector<Tuple2<Integer, String>> out) throws Exception\n\t\t{\n\n\t\t\tint key = rec1 != null ? rec1.f0 : rec2.f0;\n\t\t\tString value1 = rec1 != null ? rec1.f1 : null;\n\t\t\tString value2 = rec2 != null ? rec2.f1 : null;\n\n\t\t\t//System.err.println(\"rec1 key = \"+key+\"  rec2 key= \"+rec2.f0);\n\t\t\tCollection<TupleMatch> matches = this.toRemoveFrom.get(key);\n\t\t\tif (matches == null) {\n\t\t\t\tAssert.fail(\"Match \" + key + \" - \" + value1 + \":\" + value2 + \" is unexpected.\");\n\t\t\t}\n\t\t\t\n\t\t\tAssert.assertTrue(\"Produced match was not contained: \" + key + \" - \" + value1 + \":\" + value2,\n\t\t\t\tmatches.remove(new TupleMatch(value1, value2)));\n\t\t\t\n\t\t\tif (matches.isEmpty()) {\n\t\t\t\tthis.toRemoveFrom.remove(key);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic final class TupleIntPairMatchRemovingMatcher implements FlatJoinFunction<IntPair, Tuple2<Integer, String>, Tuple2<Integer, String>>\n\t{\n\t\tprivate final Map<Integer, Collection<TupleIntPairMatch>> toRemoveFrom;\n\t\t\n\t\tprotected TupleIntPairMatchRemovingMatcher(Map<Integer, Collection<TupleIntPairMatch>> map) {\n\t\t\tthis.toRemoveFrom = map;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void join(IntPair rec1, Tuple2<Integer, String> rec2, Collector<Tuple2<Integer, String>> out) throws Exception\n\t\t{\n\t\t\tfinal int k = rec1.getKey();\n\t\t\tfinal int v = rec1.getValue(); \n\t\t\t\n\t\t\tfinal Integer key = rec2.f0;\n\t\t\tfinal String value = rec2.f1;\n\n\t\t\tAssert.assertTrue(\"Key does not match for matching IntPair Tuple combination.\", k == key);\n\t\t\t\n\t\t\tCollection<TupleIntPairMatch> matches = this.toRemoveFrom.get(key);\n\t\t\tif (matches == null) {\n\t\t\t\tAssert.fail(\"Match \" + key + \" - \" + v + \":\" + value + \" is unexpected.\");\n\t\t\t}\n\t\t\t\n\t\t\tAssert.assertTrue(\"Produced match was not contained: \" + key + \" - \" + v + \":\" + value,\n\t\t\t\tmatches.remove(new TupleIntPairMatch(v, value)));\n\t\t\t\n\t\t\tif (matches.isEmpty()) {\n\t\t\t\tthis.toRemoveFrom.remove(key);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic final class IntPairTuplePairComparator extends TypePairComparator<IntPair, Tuple2<Integer, String>>\n\t{\n\t\tprivate int reference;\n\t\t\n\t\t@Override\n\t\tpublic void setReference(IntPair reference) {\n\t\t\tthis.reference = reference.getKey();\t\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equalToReference(Tuple2<Integer, String> candidate) {\n\t\t\ttry {\n\t\t\t\treturn candidate.f0 == this.reference;\n\t\t\t} catch (NullPointerException npex) {\n\t\t\t\tthrow new NullKeyFieldException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareToReference(Tuple2<Integer, String> candidate) {\n\t\t\ttry {\n\t\t\t\treturn candidate.f0 - this.reference;\n\t\t\t} catch (NullPointerException npex) {\n\t\t\t\tthrow new NullKeyFieldException();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic final class TupleIntPairPairComparator extends TypePairComparator<Tuple2<Integer, String>, IntPair>\n\t{\n\t\tprivate int reference;\n\t\t\n\t\t@Override\n\t\tpublic void setReference(Tuple2<Integer, String> reference) {\n\t\t\tthis.reference = reference.f0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equalToReference(IntPair candidate) {\n\t\t\treturn this.reference == candidate.getKey();\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareToReference(IntPair candidate) {\n\t\t\treturn candidate.getKey() - this.reference;\n\t\t}\n\t}\n}", "class_id": 0, "repo": "madfrog2047/flink", "file": "flink-runtime/src/test/java/org/apache/flink/runtime/operators/hash/NonReusingHashJoinIteratorITCase.java", "last_update_at": "2019-10-09T01:53:15+00:00", "question_id": "553fd24b554214847d3ff9c9b63403c55f9b5b41", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings({\"serial\", \"EqualsWhichDoesntCheckParameterClass\", \n\t\t\"StatementWithEmptyBody\", \"KeySetIterationMayUseEntrySet\"})\npublic class NonReusingHashJoinIteratorITCase extends TestLogger {\n\t\n\tprivate static final int MEMORY_SIZE = 16000000;\t\t// total memory\n\tprivate static final int INPUT_1_SIZE = 20000;\n\tprivate static final int INPUT_2_SIZE = 1000;\n\tprivate static final long SEED1 = 561349061987311L;\n\tprivate static final long SEED2 = 231434613412342L;\n\t\n\tprivate final AbstractInvokable parentTask = new DummyInvokable();\n\tprivate IOManager ioManager;\n\tprivate MemoryManager memoryManager;\n\t\n\tprivate TypeSerializer<Tuple2<Integer, String>> recordSerializer;\n\tprivate TypeComparator<Tuple2<Integer, String>> record1Comparator;\n\tprivate TypeComparator<Tuple2<Integer, String>> record2Comparator;\n\tprivate TypePairComparator<Tuple2<Integer, String>, Tuple2<Integer, String>> recordPairComparator;\n\t\n\tprivate TypeSerializer<IntPair> pairSerializer;\n\tprivate TypeComparator<IntPair> pairComparator;\n\tprivate TypePairComparator<IntPair, Tuple2<Integer, String>> pairRecordPairComparator;\n\tprivate TypePairComparator<Tuple2<Integer, String>, IntPair> recordPairPairComparator;\n\t@SuppressWarnings(\"unchecked\")\n\t@Before\n\tpublic void beforeTest() {\n\t\tthis.recordSerializer = TestData.getIntStringTupleSerializer();\n\t\t\n\t\tthis.record1Comparator = TestData.getIntStringTupleComparator();\n\t\tthis.record2Comparator = TestData.getIntStringTupleComparator();\n\t\t\n\t\tthis.recordPairComparator = new GenericPairComparator(record1Comparator, record2Comparator);\n\t\t\n\t\tthis.pairSerializer = new IntPairSerializer();\n\t\tthis.pairComparator = new TestData.IntPairComparator();\n\t\tthis.pairRecordPairComparator = new IntPairTuplePairComparator();\n\t\tthis.recordPairPairComparator = new TupleIntPairPairComparator();\n\t\t\n\t\tthis.memoryManager = new MemoryManager(MEMORY_SIZE, 1);\n\t\tthis.ioManager = new IOManagerAsync();\n\t}\n\t@After\n\tpublic void afterTest() throws Exception {\n\t\tif (this.ioManager != null) {\n\t\t\tthis.ioManager.close();\n\t\t\tthis.ioManager = null;\n\t\t}\n\t\t\n\t\tif (this.memoryManager != null) {\n\t\t\tAssert.assertTrue(\"Memory Leak: Not all memory has been returned to the memory manager.\",\n\t\t\t\tthis.memoryManager.verifyEmpty());\n\t\t\tthis.memoryManager.shutdown();\n\t\t\tthis.memoryManager = null;\n\t\t}\n\t}\n\t@Test\n\tpublic void testBuildFirst() {\n\t\ttry {\n\t\t\tTupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\tTupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\t\n\t\t\tfinal TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);\n\t\t\tfinal TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);\n\t\t\t\n\t\t\t// collect expected data\n\t\t\tfinal Map<Integer, Collection<TupleMatch>> expectedMatchesMap = joinTuples(\n\t\t\t\t\tcollectTupleData(input1),\n\t\t\t\t\tcollectTupleData(input2));\n\t\t\t\n\t\t\tfinal TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);\n\t\t\tfinal Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<Tuple2<Integer, String>>();\n\t\n\t\t\t// reset the generators\n\t\t\tgenerator1.reset();\n\t\t\tgenerator2.reset();\n\t\t\tinput1.reset();\n\t\t\tinput2.reset();\n\t\n\t\t\t// compare with iterator values\n\t\t\tNonReusingBuildFirstHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =\n\t\t\t\t\tnew NonReusingBuildFirstHashJoinIterator<>(\n\t\t\t\t\t\tinput1, input2, this.recordSerializer, this.record1Comparator, \n\t\t\t\t\t\tthis.recordSerializer, this.record2Comparator, this.recordPairComparator,\n\t\t\t\t\t\tthis.memoryManager, ioManager, this.parentTask, 1.0, false, false, true);\n\t\t\t\n\t\t\titerator.open();\n\t\t\t//noinspection StatementWithEmptyBody\n\t\t\twhile (iterator.callWithNextKey(matcher, collector));\n\t\t\t\n\t\t\titerator.close();\n\t\n\t\t\t// assert that each expected match was seen\n\t\t\tfor (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {\n\t\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\t\tAssert.fail(\"Collection for key \" + entry.getKey() + \" is not empty\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"An exception occurred during the test: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testBuildFirstWithHighNumberOfCommonKeys()\n\t{\n\t\t// the size of the left and right inputs\n\t\tfinal int INPUT_1_SIZE = 200;\n\t\tfinal int INPUT_2_SIZE = 100;\n\t\t\n\t\tfinal int INPUT_1_DUPLICATES = 10;\n\t\tfinal int INPUT_2_DUPLICATES = 2000;\n\t\tfinal int DUPLICATE_KEY = 13;\n\t\t\n\t\ttry {\n\t\t\tTupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\tTupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\t\n\t\t\tfinal TestData.TupleGeneratorIterator gen1Iter = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);\n\t\t\tfinal TestData.TupleGeneratorIterator gen2Iter = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);\n\t\t\t\n\t\t\tfinal TestData.TupleConstantValueIterator const1Iter = new TestData.TupleConstantValueIterator(DUPLICATE_KEY, \"LEFT String for Duplicate Keys\", INPUT_1_DUPLICATES);\n\t\t\tfinal TestData.TupleConstantValueIterator const2Iter = new TestData.TupleConstantValueIterator(DUPLICATE_KEY, \"RIGHT String for Duplicate Keys\", INPUT_2_DUPLICATES);\n\t\t\t\n\t\t\tfinal List<MutableObjectIterator<Tuple2<Integer, String>>> inList1 = new ArrayList<>();\n\t\t\tinList1.add(gen1Iter);\n\t\t\tinList1.add(const1Iter);\n\t\t\t\n\t\t\tfinal List<MutableObjectIterator<Tuple2<Integer, String>>> inList2 = new ArrayList<>();\n\t\t\tinList2.add(gen2Iter);\n\t\t\tinList2.add(const2Iter);\n\t\t\t\n\t\t\tMutableObjectIterator<Tuple2<Integer, String>> input1 = new UnionIterator<>(inList1);\n\t\t\tMutableObjectIterator<Tuple2<Integer, String>> input2 = new UnionIterator<>(inList2);\n\t\t\t\n\t\t\t\n\t\t\t// collect expected data\n\t\t\tfinal Map<Integer, Collection<TupleMatch>> expectedMatchesMap = joinTuples(\n\t\t\t\t\tcollectTupleData(input1),\n\t\t\t\t\tcollectTupleData(input2));\n\t\t\t\n\t\t\t// re-create the whole thing for actual processing\n\t\t\t\n\t\t\t// reset the generators and iterators\n\t\t\tgenerator1.reset();\n\t\t\tgenerator2.reset();\n\t\t\tconst1Iter.reset();\n\t\t\tconst2Iter.reset();\n\t\t\tgen1Iter.reset();\n\t\t\tgen2Iter.reset();\n\t\t\t\n\t\t\tinList1.clear();\n\t\t\tinList1.add(gen1Iter);\n\t\t\tinList1.add(const1Iter);\n\t\t\t\n\t\t\tinList2.clear();\n\t\t\tinList2.add(gen2Iter);\n\t\t\tinList2.add(const2Iter);\n\t\n\t\t\tinput1 = new UnionIterator<>(inList1);\n\t\t\tinput2 = new UnionIterator<>(inList2);\n\t\t\t\n\t\t\tfinal TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);\n\t\t\tfinal Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();\n\t\n\t\t\tNonReusingBuildFirstHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =\n\t\t\t\t\tnew NonReusingBuildFirstHashJoinIterator<>(\n\t\t\t\t\t\tinput1, input2, this.recordSerializer, this.record1Comparator, \n\t\t\t\t\t\tthis.recordSerializer, this.record2Comparator, this.recordPairComparator,\n\t\t\t\t\t\tthis.memoryManager, ioManager, this.parentTask, 1.0, false, false, true);\n\t\t\titerator.open();\n\t\t\t\n\t\t\twhile (iterator.callWithNextKey(matcher, collector));\n\t\t\t\n\t\t\titerator.close();\n\t\n\t\t\t// assert that each expected match was seen\n\t\t\tfor (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {\n\t\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\t\tAssert.fail(\"Collection for key \" + entry.getKey() + \" is not empty\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"An exception occurred during the test: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testBuildSecond() {\n\t\ttry {\n\t\t\tTupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\tTupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\t\n\t\t\tfinal TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);\n\t\t\tfinal TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);\n\t\t\t\n\t\t\t// collect expected data\n\t\t\tfinal Map<Integer, Collection<TupleMatch>> expectedMatchesMap = joinTuples(\n\t\t\t\t\tcollectTupleData(input1),\n\t\t\t\t\tcollectTupleData(input2));\n\t\t\t\n\t\t\tfinal TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);\n\t\t\tfinal Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();\n\t\n\t\t\t// reset the generators\n\t\t\tgenerator1.reset();\n\t\t\tgenerator2.reset();\n\t\t\tinput1.reset();\n\t\t\tinput2.reset();\n\t\n\t\t\t// compare with iterator values\t\t\t\n\t\t\tNonReusingBuildSecondHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =\n\t\t\t\tnew NonReusingBuildSecondHashJoinIterator<>(\n\t\t\t\t\tinput1, input2, this.recordSerializer, this.record1Comparator, \n\t\t\t\t\tthis.recordSerializer, this.record2Comparator, this.recordPairComparator,\n\t\t\t\t\tthis.memoryManager, ioManager, this.parentTask, 1.0, false, false, true);\n\t\t\titerator.open();\n\t\t\t\n\t\t\twhile (iterator.callWithNextKey(matcher, collector));\n\t\t\t\n\t\t\titerator.close();\n\t\n\t\t\t// assert that each expected match was seen\n\t\t\tfor (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {\n\t\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\t\tAssert.fail(\"Collection for key \" + entry.getKey() + \" is not empty\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"An exception occurred during the test: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testBuildSecondWithHighNumberOfCommonKeys()\n\t{\n\t\t// the size of the left and right inputs\n\t\tfinal int INPUT_1_SIZE = 200;\n\t\tfinal int INPUT_2_SIZE = 100;\n\t\t\n\t\tfinal int INPUT_1_DUPLICATES = 10;\n\t\tfinal int INPUT_2_DUPLICATES = 2000;\n\t\tfinal int DUPLICATE_KEY = 13;\n\t\t\n\t\ttry {\n\t\t\tTupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\tTupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\t\n\t\t\tfinal TestData.TupleGeneratorIterator gen1Iter = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);\n\t\t\tfinal TestData.TupleGeneratorIterator gen2Iter = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);\n\t\t\t\n\t\t\tfinal TestData.TupleConstantValueIterator const1Iter = new TestData.TupleConstantValueIterator(DUPLICATE_KEY, \"LEFT String for Duplicate Keys\", INPUT_1_DUPLICATES);\n\t\t\tfinal TestData.TupleConstantValueIterator const2Iter = new TestData.TupleConstantValueIterator(DUPLICATE_KEY, \"RIGHT String for Duplicate Keys\", INPUT_2_DUPLICATES);\n\t\t\t\n\t\t\tfinal List<MutableObjectIterator<Tuple2<Integer, String>>> inList1 = new ArrayList<>();\n\t\t\tinList1.add(gen1Iter);\n\t\t\tinList1.add(const1Iter);\n\t\t\t\n\t\t\tfinal List<MutableObjectIterator<Tuple2<Integer, String>>> inList2 = new ArrayList<>();\n\t\t\tinList2.add(gen2Iter);\n\t\t\tinList2.add(const2Iter);\n\t\t\t\n\t\t\tMutableObjectIterator<Tuple2<Integer, String>> input1 = new UnionIterator<>(inList1);\n\t\t\tMutableObjectIterator<Tuple2<Integer, String>> input2 = new UnionIterator<>(inList2);\n\t\t\t\n\t\t\t\n\t\t\t// collect expected data\n\t\t\tfinal Map<Integer, Collection<TupleMatch>> expectedMatchesMap = joinTuples(\n\t\t\t\t\tcollectTupleData(input1),\n\t\t\t\t\tcollectTupleData(input2));\n\t\t\t\n\t\t\t// re-create the whole thing for actual processing\n\t\t\t\n\t\t\t// reset the generators and iterators\n\t\t\tgenerator1.reset();\n\t\t\tgenerator2.reset();\n\t\t\tconst1Iter.reset();\n\t\t\tconst2Iter.reset();\n\t\t\tgen1Iter.reset();\n\t\t\tgen2Iter.reset();\n\t\t\t\n\t\t\tinList1.clear();\n\t\t\tinList1.add(gen1Iter);\n\t\t\tinList1.add(const1Iter);\n\t\t\t\n\t\t\tinList2.clear();\n\t\t\tinList2.add(gen2Iter);\n\t\t\tinList2.add(const2Iter);\n\t\n\t\t\tinput1 = new UnionIterator<>(inList1);\n\t\t\tinput2 = new UnionIterator<>(inList2);\n\t\t\t\n\t\t\tfinal TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);\n\t\t\tfinal Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();\n\t\t\tNonReusingBuildSecondHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =\n\t\t\t\tnew NonReusingBuildSecondHashJoinIterator<>(\n\t\t\t\t\tinput1, input2, this.recordSerializer, this.record1Comparator, \n\t\t\t\t\tthis.recordSerializer, this.record2Comparator, this.recordPairComparator,\n\t\t\t\t\tthis.memoryManager, ioManager, this.parentTask, 1.0, false, false, true);\n\t\t\t\n\t\t\titerator.open();\n\t\t\t\n\t\t\twhile (iterator.callWithNextKey(matcher, collector));\n\t\t\t\n\t\t\titerator.close();\n\t\n\t\t\t// assert that each expected match was seen\n\t\t\tfor (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {\n\t\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\t\tAssert.fail(\"Collection for key \" + entry.getKey() + \" is not empty\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"An exception occurred during the test: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testBuildFirstWithMixedDataTypes() {\n\t\ttry {\n\t\t\tMutableObjectIterator<IntPair> input1 = new UniformIntPairGenerator(500, 40, false);\n\t\t\t\n\t\t\tfinal TupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\tfinal TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);\n\t\t\t\n\t\t\t// collect expected data\n\t\t\tfinal Map<Integer, Collection<TupleIntPairMatch>> expectedMatchesMap = joinIntPairs(\n\t\t\t\t\tcollectIntPairData(input1),\n\t\t\t\t\tcollectTupleData(input2));\n\t\t\t\n\t\t\tfinal FlatJoinFunction<IntPair, Tuple2<Integer, String>, Tuple2<Integer, String>> matcher = new TupleIntPairMatchRemovingMatcher(expectedMatchesMap);\n\t\t\tfinal Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();\n\t\n\t\t\t// reset the generators\n\t\t\tinput1 = new UniformIntPairGenerator(500, 40, false);\n\t\t\tgenerator2.reset();\n\t\t\tinput2.reset();\n\t\n\t\t\t// compare with iterator values\n\t\t\tNonReusingBuildSecondHashJoinIterator<IntPair, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =\n\t\t\t\t\tnew NonReusingBuildSecondHashJoinIterator<>(\n\t\t\t\t\t\tinput1, input2, this.pairSerializer, this.pairComparator,\n\t\t\t\t\t\tthis.recordSerializer, this.record2Comparator, this.pairRecordPairComparator,\n\t\t\t\t\t\tthis.memoryManager, this.ioManager, this.parentTask, 1.0, false, false, true);\n\t\t\t\n\t\t\titerator.open();\n\t\t\t\n\t\t\twhile (iterator.callWithNextKey(matcher, collector));\n\t\t\t\n\t\t\titerator.close();\n\t\n\t\t\t// assert that each expected match was seen\n\t\t\tfor (Entry<Integer, Collection<TupleIntPairMatch>> entry : expectedMatchesMap.entrySet()) {\n\t\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\t\tAssert.fail(\"Collection for key \" + entry.getKey() + \" is not empty\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"An exception occurred during the test: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testBuildSecondWithMixedDataTypes() {\n\t\ttry {\n\t\t\tMutableObjectIterator<IntPair> input1 = new UniformIntPairGenerator(500, 40, false);\n\t\t\t\n\t\t\tfinal TupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\tfinal TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);\n\t\t\t\n\t\t\t// collect expected data\n\t\t\tfinal Map<Integer, Collection<TupleIntPairMatch>> expectedMatchesMap = joinIntPairs(\n\t\t\t\t\tcollectIntPairData(input1),\n\t\t\t\t\tcollectTupleData(input2));\n\t\t\t\n\t\t\tfinal FlatJoinFunction<IntPair, Tuple2<Integer, String>, Tuple2<Integer, String>> matcher = new TupleIntPairMatchRemovingMatcher(expectedMatchesMap);\n\t\t\tfinal Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();\n\t\n\t\t\t// reset the generators\n\t\t\tinput1 = new UniformIntPairGenerator(500, 40, false);\n\t\t\tgenerator2.reset();\n\t\t\tinput2.reset();\n\t\n\t\t\t// compare with iterator values\n\t\t\tNonReusingBuildFirstHashJoinIterator<IntPair, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =\n\t\t\t\t\tnew NonReusingBuildFirstHashJoinIterator<>(\n\t\t\t\t\t\tinput1, input2, this.pairSerializer, this.pairComparator, \n\t\t\t\t\t\tthis.recordSerializer, this.record2Comparator, this.recordPairPairComparator,\n\t\t\t\t\t\tthis.memoryManager, this.ioManager, this.parentTask, 1.0, false, false, true);\n\t\t\t\n\t\t\titerator.open();\n\t\t\t\n\t\t\twhile (iterator.callWithNextKey(matcher, collector));\n\t\t\t\n\t\t\titerator.close();\n\t\n\t\t\t// assert that each expected match was seen\n\t\t\tfor (Entry<Integer, Collection<TupleIntPairMatch>> entry : expectedMatchesMap.entrySet()) {\n\t\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\t\tAssert.fail(\"Collection for key \" + entry.getKey() + \" is not empty\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"An exception occurred during the test: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testBuildFirstAndProbeSideOuterJoin() {\n\t\ttry {\n\t\t\tTupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\tTupleGenerator generator2 = new TupleGenerator(SEED2, 1000, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\n\t\t\tfinal TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);\n\t\t\tfinal TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);\n\t\n\t\t\t// collect expected data\n\t\t\tfinal Map<Integer, Collection<TupleMatch>> expectedMatchesMap = rightOuterJoinTuples(\n\t\t\t\t\tcollectTupleData(input1),\n\t\t\t\t\tcollectTupleData(input2));\n\t\n\t\t\tfinal TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);\n\t\t\tfinal Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();\n\t\n\t\t\t// reset the generators\n\t\t\tgenerator1.reset();\n\t\t\tgenerator2.reset();\n\t\t\tinput1.reset();\n\t\t\tinput2.reset();\n\t\n\t\t\t// compare with iterator values\n\t\t\tNonReusingBuildFirstHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =\n\t\t\t\t\tnew NonReusingBuildFirstHashJoinIterator<>(\n\t\t\t\t\t\t\tinput1, input2, this.recordSerializer, this.record1Comparator,\n\t\t\t\t\t\t\tthis.recordSerializer, this.record2Comparator, this.recordPairComparator,\n\t\t\t\t\t\t\tthis.memoryManager, ioManager, this.parentTask, 1.0, true, false, false);\n\t\n\t\t\titerator.open();\n\t\n\t\t\twhile (iterator.callWithNextKey(matcher, collector));\n\t\n\t\t\titerator.close();\n\t\n\t\t\t// assert that each expected match was seen\n\t\t\tfor (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {\n\t\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\t\tAssert.fail(\"Collection for key \" + entry.getKey() + \" is not empty\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"An exception occurred during the test: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testBuildFirstAndBuildSideOuterJoin() {\n\t\ttry {\n\t\t\tTupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\tTupleGenerator generator2 = new TupleGenerator(SEED2, 1000, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\n\t\t\tfinal TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);\n\t\t\tfinal TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);\n\t\n\t\t\t// collect expected data\n\t\t\tfinal Map<Integer, Collection<TupleMatch>> expectedMatchesMap = leftOuterJoinTuples(\n\t\t\t\tcollectTupleData(input1),\n\t\t\t\tcollectTupleData(input2));\n\t\n\t\t\tfinal TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);\n\t\t\tfinal Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();\n\t\n\t\t\t// reset the generators\n\t\t\tgenerator1.reset();\n\t\t\tgenerator2.reset();\n\t\t\tinput1.reset();\n\t\t\tinput2.reset();\n\t\n\t\t\t// compare with iterator values\n\t\t\tNonReusingBuildFirstHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =\n\t\t\t\tnew NonReusingBuildFirstHashJoinIterator<>(\n\t\t\t\t\tinput1, input2, this.recordSerializer, this.record1Comparator,\n\t\t\t\t\tthis.recordSerializer, this.record2Comparator, this.recordPairComparator,\n\t\t\t\t\tthis.memoryManager, ioManager, this.parentTask, 1.0, false, true, false);\n\t\n\t\t\titerator.open();\n\t\n\t\t\twhile (iterator.callWithNextKey(matcher, collector));\n\t\n\t\t\titerator.close();\n\t\n\t\t\t// assert that each expected match was seen\n\t\t\tfor (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {\n\t\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\t\tAssert.fail(\"Collection for key \" + entry.getKey() + \" is not empty\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"An exception occurred during the test: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testBuildFirstAndFullOuterJoin() {\n\t\ttry {\n\t\t\tTupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\tTupleGenerator generator2 = new TupleGenerator(SEED2, 1000, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\n\t\t\tfinal TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);\n\t\t\tfinal TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);\n\t\n\t\t\t// collect expected data\n\t\t\tfinal Map<Integer, Collection<TupleMatch>> expectedMatchesMap = fullOuterJoinTuples(\n\t\t\t\tcollectTupleData(input1),\n\t\t\t\tcollectTupleData(input2));\n\t\n\t\t\tfinal TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);\n\t\t\tfinal Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();\n\t\n\t\t\t// reset the generators\n\t\t\tgenerator1.reset();\n\t\t\tgenerator2.reset();\n\t\t\tinput1.reset();\n\t\t\tinput2.reset();\n\t\n\t\t\t// compare with iterator values\n\t\t\tNonReusingBuildFirstHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =\n\t\t\t\tnew NonReusingBuildFirstHashJoinIterator<>(\n\t\t\t\t\tinput1, input2, this.recordSerializer, this.record1Comparator,\n\t\t\t\t\tthis.recordSerializer, this.record2Comparator, this.recordPairComparator,\n\t\t\t\t\tthis.memoryManager, ioManager, this.parentTask, 1.0, true, true, false);\n\t\n\t\t\titerator.open();\n\t\n\t\t\twhile (iterator.callWithNextKey(matcher, collector));\n\t\n\t\t\titerator.close();\n\t\n\t\t\t// assert that each expected match was seen\n\t\t\tfor (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {\n\t\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\t\tAssert.fail(\"Collection for key \" + entry.getKey() + \" is not empty\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"An exception occurred during the test: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testBuildSecondAndProbeSideOuterJoin() {\n\t\ttry {\n\t\t\tTupleGenerator generator1 = new TupleGenerator(SEED1, 1000, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\tTupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\n\t\t\tfinal TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);\n\t\t\tfinal TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);\n\t\n\t\t\t// collect expected data\n\t\t\tfinal Map<Integer, Collection<TupleMatch>> expectedMatchesMap = leftOuterJoinTuples(\n\t\t\t\t\tcollectTupleData(input1),\n\t\t\t\t\tcollectTupleData(input2));\n\t\n\t\t\tfinal TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);\n\t\t\tfinal Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();\n\t\n\t\t\t// reset the generators\n\t\t\tgenerator1.reset();\n\t\t\tgenerator2.reset();\n\t\t\tinput1.reset();\n\t\t\tinput2.reset();\n\t\n\t\t\t// compare with iterator values\n\t\t\tNonReusingBuildSecondHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =\n\t\t\t\t\tnew NonReusingBuildSecondHashJoinIterator<>(\n\t\t\t\t\t\t\tinput1, input2, this.recordSerializer, this.record1Comparator,\n\t\t\t\t\t\t\tthis.recordSerializer, this.record2Comparator, this.recordPairComparator,\n\t\t\t\t\t\t\tthis.memoryManager, ioManager, this.parentTask, 1.0, true, false, false);\n\t\n\t\t\titerator.open();\n\t\n\t\t\twhile (iterator.callWithNextKey(matcher, collector));\n\t\n\t\t\titerator.close();\n\t\n\t\t\t// assert that each expected match was seen\n\t\t\tfor (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {\n\t\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\t\tAssert.fail(\"Collection for key \" + entry.getKey() + \" is not empty\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"An exception occurred during the test: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testBuildSecondAndBuildSideOuterJoin() {\n\t\ttry {\n\t\t\tTupleGenerator generator1 = new TupleGenerator(SEED1, 1000, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\tTupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\n\t\t\tfinal TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);\n\t\t\tfinal TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);\n\t\n\t\t\t// collect expected data\n\t\t\tfinal Map<Integer, Collection<TupleMatch>> expectedMatchesMap = rightOuterJoinTuples(\n\t\t\t\tcollectTupleData(input1),\n\t\t\t\tcollectTupleData(input2));\n\t\n\t\t\tfinal TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);\n\t\t\tfinal Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();\n\t\n\t\t\t// reset the generators\n\t\t\tgenerator1.reset();\n\t\t\tgenerator2.reset();\n\t\t\tinput1.reset();\n\t\t\tinput2.reset();\n\t\n\t\t\t// compare with iterator values\n\t\t\tNonReusingBuildSecondHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =\n\t\t\t\tnew NonReusingBuildSecondHashJoinIterator<>(\n\t\t\t\t\tinput1, input2, this.recordSerializer, this.record1Comparator,\n\t\t\t\t\tthis.recordSerializer, this.record2Comparator, this.recordPairComparator,\n\t\t\t\t\tthis.memoryManager, ioManager, this.parentTask, 1.0, false, true, false);\n\t\n\t\t\titerator.open();\n\t\n\t\t\twhile (iterator.callWithNextKey(matcher, collector));\n\t\n\t\t\titerator.close();\n\t\n\t\t\t// assert that each expected match was seen\n\t\t\tfor (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {\n\t\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\t\tAssert.fail(\"Collection for key \" + entry.getKey() + \" is not empty\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"An exception occurred during the test: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testBuildSecondAndFullOuterJoin() {\n\t\ttry {\n\t\t\tTupleGenerator generator1 = new TupleGenerator(SEED1, 1000, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\t\tTupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n\t\n\t\t\tfinal TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);\n\t\t\tfinal TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);\n\t\n\t\t\t// collect expected data\n\t\t\tfinal Map<Integer, Collection<TupleMatch>> expectedMatchesMap = fullOuterJoinTuples(\n\t\t\t\tcollectTupleData(input1),\n\t\t\t\tcollectTupleData(input2));\n\t\n\t\t\tfinal TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);\n\t\t\tfinal Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();\n\t\n\t\t\t// reset the generators\n\t\t\tgenerator1.reset();\n\t\t\tgenerator2.reset();\n\t\t\tinput1.reset();\n\t\t\tinput2.reset();\n\t\n\t\t\t// compare with iterator values\n\t\t\tNonReusingBuildSecondHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =\n\t\t\t\tnew NonReusingBuildSecondHashJoinIterator<>(\n\t\t\t\t\tinput1, input2, this.recordSerializer, this.record1Comparator,\n\t\t\t\t\tthis.recordSerializer, this.record2Comparator, this.recordPairComparator,\n\t\t\t\t\tthis.memoryManager, ioManager, this.parentTask, 1.0, true, true, false);\n\t\n\t\t\titerator.open();\n\t\n\t\t\twhile (iterator.callWithNextKey(matcher, collector));\n\t\n\t\t\titerator.close();\n\t\n\t\t\t// assert that each expected match was seen\n\t\t\tfor (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {\n\t\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\t\tAssert.fail(\"Collection for key \" + entry.getKey() + \" is not empty\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"An exception occurred during the test: \" + e.getMessage());\n\t\t}\n\t}\n\t\t\n\t// --------------------------------------------------------------------------------------------\n\t//                                    Utilities\n\t// --------------------------------------------------------------------------------------------\n\t\n\t\n\tpublic static Map<Integer, Collection<TupleMatch>> joinTuples(\n\t\t\tMap<Integer, Collection<String>> leftMap,\n\t\t\tMap<Integer, Collection<String>> rightMap)\n\t{\n\t\tMap<Integer, Collection<TupleMatch>> map = new HashMap<>();\n\t\tfor (Integer key : leftMap.keySet()) {\n\t\t\tCollection<String> leftValues = leftMap.get(key);\n\t\t\tCollection<String> rightValues = rightMap.get(key);\n\t\t\tif (rightValues == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!map.containsKey(key)) {\n\t\t\t\tmap.put(key, new ArrayList<TupleMatch>());\n\t\t\t}\n\t\t\tCollection<TupleMatch> matchedValues = map.get(key);\n\t\t\tfor (String leftValue : leftValues) {\n\t\t\t\tfor (String rightValue : rightValues) {\n\t\t\t\t\tmatchedValues.add(new TupleMatch(leftValue, rightValue));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}\n\tpublic static Map<Integer, Collection<TupleMatch>> leftOuterJoinTuples(\n\t\t\tMap<Integer, Collection<String>> leftMap,\n\t\t\tMap<Integer, Collection<String>> rightMap)\n\t{\n\t\tMap<Integer, Collection<TupleMatch>> map = new HashMap<>();\n\t\tfor (Integer key : leftMap.keySet()) {\n\t\t\tCollection<String> leftValues = leftMap.get(key);\n\t\t\tCollection<String> rightValues = rightMap.get(key);\n\t\t\tif (!map.containsKey(key)) {\n\t\t\t\tmap.put(key, new ArrayList<TupleMatch>());\n\t\t\t}\n\t\t\tCollection<TupleMatch> matchedValues = map.get(key);\n\t\t\tfor (String leftValue : leftValues) {\n\t\t\t\tif(rightValues != null) {\n\t\t\t\t\tfor (String rightValue : rightValues) {\n\t\t\t\t\t\tmatchedValues.add(new TupleMatch(leftValue, rightValue));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmatchedValues.add(new TupleMatch(leftValue, null));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}\n\tpublic static Map<Integer, Collection<TupleMatch>> rightOuterJoinTuples(\n\t\t\tMap<Integer, Collection<String>> leftMap,\n\t\t\tMap<Integer, Collection<String>> rightMap)\n\t{\n\t\tMap<Integer, Collection<TupleMatch>> map = new HashMap<>();\n\t\tfor (Integer key : rightMap.keySet()) {\n\t\t\tCollection<String> leftValues = leftMap.get(key);\n\t\t\tCollection<String> rightValues = rightMap.get(key);\n\t\t\tif (!map.containsKey(key)) {\n\t\t\t\tmap.put(key, new ArrayList<TupleMatch>());\n\t\t\t}\n\t\t\tCollection<TupleMatch> matchedValues = map.get(key);\n\t\t\tfor (String rightValue : rightValues) {\n\t\t\t\tif(leftValues != null) {\n\t\t\t\t\tfor (String leftValue : leftValues) {\n\t\t\t\t\t\tmatchedValues.add(new TupleMatch(leftValue, rightValue));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmatchedValues.add(new TupleMatch(null, rightValue));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}\n\tpublic static Map<Integer, Collection<TupleMatch>> fullOuterJoinTuples(\n\t\tMap<Integer, Collection<String>> leftMap,\n\t\tMap<Integer, Collection<String>> rightMap)\n\t{\n\t\tMap<Integer, Collection<TupleMatch>> map = new HashMap<>();\n\t\tfor (Integer key : rightMap.keySet()) {\n\t\t\tCollection<String> leftValues = leftMap.get(key);\n\t\t\tCollection<String> rightValues = rightMap.get(key);\n\t\t\tif (!map.containsKey(key)) {\n\t\t\t\tmap.put(key, new ArrayList<TupleMatch>());\n\t\t\t}\n\t\t\tCollection<TupleMatch> matchedValues = map.get(key);\n\t\t\tfor (String rightValue : rightValues) {\n\t\t\t\tif(leftValues != null) {\n\t\t\t\t\tfor (String leftValue : leftValues) {\n\t\t\t\t\t\tmatchedValues.add(new TupleMatch(leftValue, rightValue));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmatchedValues.add(new TupleMatch(null, rightValue));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (Integer key : leftMap.keySet()) {\n\t\t\tCollection<String> leftValues = leftMap.get(key);\n\t\t\tCollection<String> rightValues = rightMap.get(key);\n\t\t\tif (rightValues == null) {\n\t\t\t\tif (!map.containsKey(key)) {\n\t\t\t\t\tmap.put(key, new ArrayList<TupleMatch>());\n\t\t\t\t}\n\t\t\t\tCollection<TupleMatch> matchedValues = map.get(key);\n\t\t\t\tfor (String leftValue : leftValues) {\n\t\t\t\t\tmatchedValues.add(new TupleMatch(leftValue, null));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}\n\t\n\tpublic static Map<Integer, Collection<TupleIntPairMatch>> joinIntPairs(\n\t\t\tMap<Integer, Collection<Integer>> leftMap,\n\t\t\tMap<Integer, Collection<String>> rightMap)\n\t{\n\t\tfinal Map<Integer, Collection<TupleIntPairMatch>> map = new HashMap<>();\n\t\n\t\tfor (Integer i : leftMap.keySet()) {\n\t\t\t\n\t\t\tfinal Collection<Integer> leftValues = leftMap.get(i);\n\t\t\tfinal Collection<String> rightValues = rightMap.get(i);\n\t\n\t\t\tif (rightValues == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\tif (!map.containsKey(i)) {\n\t\t\t\tmap.put(i, new ArrayList<TupleIntPairMatch>());\n\t\t\t}\n\t\n\t\t\tfinal Collection<TupleIntPairMatch> matchedValues = map.get(i);\n\t\n\t\t\tfor (Integer v : leftValues) {\n\t\t\t\tfor (String val : rightValues) {\n\t\t\t\t\tmatchedValues.add(new TupleIntPairMatch(v, val));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn map;\n\t}\n\t\n\tpublic static Map<Integer, Collection<String>> collectTupleData(MutableObjectIterator<Tuple2<Integer, String>> iter)\n\tthrows Exception\n\t{\n\t\tMap<Integer, Collection<String>> map = new HashMap<>();\n\t\tTuple2<Integer, String> pair = new Tuple2<>();\n\t\t\n\t\twhile ((pair = iter.next(pair)) != null) {\n\t\t\tInteger key = pair.f0;\n\t\t\tif (!map.containsKey(key)) {\n\t\t\t\tmap.put(key, new ArrayList<String>());\n\t\t\t}\n\t\t\tCollection<String> values = map.get(key);\n\t\t\tvalues.add(pair.f1);\n\t\t}\n\t\treturn map;\n\t}\n\t\n\tpublic static Map<Integer, Collection<Integer>> collectIntPairData(MutableObjectIterator<IntPair> iter)\n\tthrows Exception\n\t{\n\t\tMap<Integer, Collection<Integer>> map = new HashMap<>();\n\t\tIntPair pair = new IntPair();\n\t\t\n\t\twhile ((pair = iter.next(pair)) != null) {\n\t\t\tfinal int key = pair.getKey();\n\t\t\tfinal int value = pair.getValue();\n\t\t\tif (!map.containsKey(key)) {\n\t\t\t\tmap.put(key, new ArrayList<Integer>());\n\t\t\t}\n\t\t\tCollection<Integer> values = map.get(key);\n\t\t\tvalues.add(value);\n\t\t}\n\t\treturn map;\n\t}\n\t/**\n\t * Class used for storage of the expected matches in a hash-map.\n\t */\n\tpublic static class TupleMatch {\n\t\t\n\t\tprivate final String left;\n\t\tprivate final String right;\n\t\tpublic TupleMatch(String left, String right) {\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tTupleMatch that = (TupleMatch) obj;\n\t\t\treturn (this.right == null ? that.right == null :\n\t\t\t\t\t\t\t(that.right != null && this.right.equals(that.right))) &&\n\t\t\t\t\t(this.left == null ? that.left == null :\n\t\t\t\t\t\t\t(that.left != null && this.left.equals(that.left)));\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tint hc = this.left != null ? this.left.hashCode() : 23;\n\t\t\thc = hc ^ (this.right != null ? this.right.hashCode() : 41);\n\t\t\treturn hc;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tString s = left == null ? \"<null>\" : left;\n\t\t\ts += \", \" + (right == null ? \"<null>\" : right);\n\t\t\treturn s;\n\t\t}\n\t}\n\t\n\t/**\n\t * Private class used for storage of the expected matches in a hash-map.\n\t */\n\tpublic static class TupleIntPairMatch\n\t{\n\t\tprivate final int left;\n\t\tprivate final String right;\n\t\tpublic TupleIntPairMatch(int left, String right) {\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tTupleIntPairMatch o = (TupleIntPairMatch) obj;\n\t\t\treturn this.left == o.left && this.right.equals(o.right);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn this.left ^ this.right.hashCode();\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn left + \", \" + right;\n\t\t}\n\t}\n\t\n\tstatic final class TupleMatchRemovingJoin implements FlatJoinFunction<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>>\n\t{\n\t\tprivate final Map<Integer, Collection<TupleMatch>> toRemoveFrom;\n\t\t\n\t\tprotected TupleMatchRemovingJoin(Map<Integer, Collection<TupleMatch>> map) {\n\t\t\tthis.toRemoveFrom = map;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void join(Tuple2<Integer, String> rec1, Tuple2<Integer, String> rec2, Collector<Tuple2<Integer, String>> out) throws Exception\n\t\t{\n\t\t\tint key = rec1 != null ? rec1.f0 : rec2.f0;\n\t\t\tString value1 = rec1 != null ? rec1.f1 : null;\n\t\t\tString value2 = rec2 != null ? rec2.f1 : null;\n\t\t\t//System.err.println(\"rec1 key = \"+key+\"  rec2 key= \"+rec2.f0);\n\t\t\tCollection<TupleMatch> matches = this.toRemoveFrom.get(key);\n\t\t\tif (matches == null) {\n\t\t\t\tAssert.fail(\"Match \" + key + \" - \" + value1 + \":\" + value2 + \" is unexpected.\");\n\t\t\t}\n\t\t\t\n\t\t\tAssert.assertTrue(\"Produced match was not contained: \" + key + \" - \" + value1 + \":\" + value2,\n\t\t\t\tmatches.remove(new TupleMatch(value1, value2)));\n\t\t\t\n\t\t\tif (matches.isEmpty()) {\n\t\t\t\tthis.toRemoveFrom.remove(key);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic final class TupleIntPairMatchRemovingMatcher implements FlatJoinFunction<IntPair, Tuple2<Integer, String>, Tuple2<Integer, String>>\n\t{\n\t\tprivate final Map<Integer, Collection<TupleIntPairMatch>> toRemoveFrom;\n\t\t\n\t\tprotected TupleIntPairMatchRemovingMatcher(Map<Integer, Collection<TupleIntPairMatch>> map) {\n\t\t\tthis.toRemoveFrom = map;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void join(IntPair rec1, Tuple2<Integer, String> rec2, Collector<Tuple2<Integer, String>> out) throws Exception\n\t\t{\n\t\t\tfinal int k = rec1.getKey();\n\t\t\tfinal int v = rec1.getValue(); \n\t\t\t\n\t\t\tfinal Integer key = rec2.f0;\n\t\t\tfinal String value = rec2.f1;\n\t\t\tAssert.assertTrue(\"Key does not match for matching IntPair Tuple combination.\", k == key);\n\t\t\t\n\t\t\tCollection<TupleIntPairMatch> matches = this.toRemoveFrom.get(key);\n\t\t\tif (matches == null) {\n\t\t\t\tAssert.fail(\"Match \" + key + \" - \" + v + \":\" + value + \" is unexpected.\");\n\t\t\t}\n\t\t\t\n\t\t\tAssert.assertTrue(\"Produced match was not contained: \" + key + \" - \" + v + \":\" + value,\n\t\t\t\tmatches.remove(new TupleIntPairMatch(v, value)));\n\t\t\t\n\t\t\tif (matches.isEmpty()) {\n\t\t\t\tthis.toRemoveFrom.remove(key);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic final class IntPairTuplePairComparator extends TypePairComparator<IntPair, Tuple2<Integer, String>>\n\t{\n\t\tprivate int reference;\n\t\t\n\t\t@Override\n\t\tpublic void setReference(IntPair reference) {\n\t\t\tthis.reference = reference.getKey();\t\n\t\t}\n\t\t@Override\n\t\tpublic boolean equalToReference(Tuple2<Integer, String> candidate) {\n\t\t\ttry {\n\t\t\t\treturn candidate.f0 == this.reference;\n\t\t\t} catch (NullPointerException npex) {\n\t\t\t\tthrow new NullKeyFieldException();\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic int compareToReference(Tuple2<Integer, String> candidate) {\n\t\t\ttry {\n\t\t\t\treturn candidate.f0 - this.reference;\n\t\t\t} catch (NullPointerException npex) {\n\t\t\t\tthrow new NullKeyFieldException();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic final class TupleIntPairPairComparator extends TypePairComparator<Tuple2<Integer, String>, IntPair>\n\t{\n\t\tprivate int reference;\n\t\t\n\t\t@Override\n\t\tpublic void setReference(Tuple2<Integer, String> reference) {\n\t\t\tthis.reference = reference.f0;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equalToReference(IntPair candidate) {\n\t\t\treturn this.reference == candidate.getKey();\n\t\t}\n\t\t@Override\n\t\tpublic int compareToReference(IntPair candidate) {\n\t\t\treturn candidate.getKey() - this.reference;\n\t\t}\n\t}\n"]]}
{"hexsha": "54e4b1574e367e57e131ee34fb2e7d6039bd4430", "ext": "java", "lang": "Java", "content": "public class NonEmptyStringUdf implements UserDefinedFunction {\n  public Object execute(Evaluator evaluator, Argument[] arguments) {\n    Object arg = arguments[0].evaluateScalar(evaluator);\n    if (arg instanceof String) {\n      String s = (String) arg;\n      if (s.length() > 0) {\n        return s;\n      }\n    }\n    return null;\n  }\n\n  public String getDescription() {\n    return \"Returns string value if non-empty.\";\n  }\n\n  public String getName() {\n    return \"NonEmptyString\";\n  }\n\n  public Type[] getParameterTypes() {\n    return new Type[] {\n      new ScalarType()\n    };\n  }\n\n  public String[] getReservedWords() {\n    return null;\n  }\n\n  public Type getReturnType(Type[] parameterTypes) {\n    return new StringType();\n  }\n\n  public Syntax getSyntax() {\n    return Syntax.Function;\n  }\n\n}", "class_id": 0, "repo": "rsim/mondrian_udf", "file": "src/java/com/eazybi/mondrian/udf/NonEmptyStringUdf.java", "last_update_at": "2019-07-22T07:33:03+00:00", "question_id": "54e4b1574e367e57e131ee34fb2e7d6039bd4430", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NonEmptyStringUdf implements UserDefinedFunction {\n  public Object execute(Evaluator evaluator, Argument[] arguments) {\n    Object arg = arguments[0].evaluateScalar(evaluator);\n    if (arg instanceof String) {\n      String s = (String) arg;\n      if (s.length() > 0) {\n        return s;\n      }\n    }\n    return null;\n  }\n  public String getDescription() {\n    return \"Returns string value if non-empty.\";\n  }\n  public String getName() {\n    return \"NonEmptyString\";\n  }\n  public Type[] getParameterTypes() {\n    return new Type[] {\n      new ScalarType()\n    };\n  }\n  public String[] getReservedWords() {\n    return null;\n  }\n  public Type getReturnType(Type[] parameterTypes) {\n    return new StringType();\n  }\n  public Syntax getSyntax() {\n    return Syntax.Function;\n  }\n"]]}
{"hexsha": "cdd33960844f9bf562cdc623853607af599feb84", "ext": "java", "lang": "Java", "content": "public class CosplayerView extends RelativeLayout {\n\n    private ImageView iconView;\n    private TextView titleView;\n    private TextView subTitleView;\n\n    public CosplayerView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    protected void onFinishInflate() {\n        super.onFinishInflate();\n\n        iconView = ((ImageView) findViewById(R.id.icon));\n        titleView = ((TextView) findViewById(android.R.id.text1));\n        subTitleView = ((TextView) findViewById(android.R.id.text2));\n    }\n\n    public void bind(Cosplayer item) {\n        titleView.setText(item.name);\n        subTitleView.setText(item.option);\n\n        final FaceApplication application = (FaceApplication) getContext().getApplicationContext();\n        Picasso.with(getContext())\n               .load(item.url)\n               .transform(new FaceTrimming(application.getFaceDetector()))\n               .memoryPolicy(MemoryPolicy.NO_STORE)\n               .into(iconView);\n    }\n}", "class_id": 0, "repo": "droibit/facedetection", "file": "app/src/main/java/com/droibit/facedetection/view/CosplayerView.java", "last_update_at": "2019-03-14T07:15:07+00:00", "question_id": "cdd33960844f9bf562cdc623853607af599feb84", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CosplayerView extends RelativeLayout {\n    private ImageView iconView;\n    private TextView titleView;\n    private TextView subTitleView;\n    public CosplayerView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n    /** {@inheritDoc} */\n    @Override\n    protected void onFinishInflate() {\n        super.onFinishInflate();\n        iconView = ((ImageView) findViewById(R.id.icon));\n        titleView = ((TextView) findViewById(android.R.id.text1));\n        subTitleView = ((TextView) findViewById(android.R.id.text2));\n    }\n    public void bind(Cosplayer item) {\n        titleView.setText(item.name);\n        subTitleView.setText(item.option);\n        final FaceApplication application = (FaceApplication) getContext().getApplicationContext();\n        Picasso.with(getContext())\n               .load(item.url)\n               .transform(new FaceTrimming(application.getFaceDetector()))\n               .memoryPolicy(MemoryPolicy.NO_STORE)\n               .into(iconView);\n    }\n"]]}
{"hexsha": "11df047728c9c9f5a030f7ddafd589c5f32a2934", "ext": "java", "lang": "Java", "content": "class Six_b {\r\n\tpublic static void main (String[] argr) {\r\n\t\tString str = \"aaabbcccccaa\";\r\n\t\tSystem.out.println(compressedString(str));\r\n\t}\r\n\r\n\tstatic String compressedString(String str) {\r\n\t\tint count = 0;\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tfor (int i = 0; i < str.length(); i++) {\r\n\t\t\tcount++;\r\n\t\t\tif (i + 1 >= str.length() || str.charAt(i) != str.charAt(i+1)) {\r\n\t\t\t\tsb.append(str.charAt(i));\r\n\t\t\t\tsb.append(count);\r\n\t\t\t\tcount = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn sb.length() > str.length() ? str : sb.toString();\r\n\t}\r\n}", "class_id": 0, "repo": "ranzeet/ctci_java", "file": "McDowel/1. Arrays & Strings/Six_b.java", "last_update_at": "2019-07-06T18:45:14+00:00", "question_id": "11df047728c9c9f5a030f7ddafd589c5f32a2934", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Six_b {\r\n\tpublic static void main (String[] argr) {\r\n\t\tString str = \"aaabbcccccaa\";\r\n\t\tSystem.out.println(compressedString(str));\r\n\t}\r\n\r\n\tstatic String compressedString(String str) {\r\n\t\tint count = 0;\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tfor (int i = 0; i < str.length(); i++) {\r\n\t\t\tcount++;\r\n\t\t\tif (i + 1 >= str.length() || str.charAt(i) != str.charAt(i+1)) {\r\n\t\t\t\tsb.append(str.charAt(i));\r\n\t\t\t\tsb.append(count);\r\n\t\t\t\tcount = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn sb.length() > str.length() ? str : sb.toString();\r\n\t}\r\n"]]}
{"hexsha": "1d89d46a7a92c46d22cf60304201d42e2b644114", "ext": "java", "lang": "Java", "content": "public class RewriteApiRequestVisitor extends SelectiveApiRequestVisitor {\n\n\tprivate static final long serialVersionUID = 1782406079539122227L;\n\t\n\tinterface Spec {\n\t\tString Rewrite\t= \"rewrite\";\n\t\tString Rules\t= \"rules\";\n\t\t\n\t\tString Endpoint\t= \"endpoint\";\n\t\tString Path\t\t= \"path\";\n\n\t\tString If \t\t= \"if\";\n\t\tString Condition= \"condition\";\n\t\tString Scope \t= \"scope\";\n\t\tString Then \t= \"then\";\n\t\tString Negate \t= \"negate\";\n\t\tString Methods \t= \"methods\";\n\t\t\n\t\tinterface Checkers {\n\t\t\tString Isnt \t= \"isnt\";\n\t\t\tString Is \t\t= \"is\";\n\t\t\tString Starts \t= \"starts\";\n\t\t\tString Ends \t= \"ends\";\n\t\t\tString Contains = \"contains\";\n\t\t\tString RegEx \t= \"regex\";\n\t\t}\n\t\tinterface Actions {\n\t\t\tString Bypass\t= \"bypass\";\n\t\t\tString Response\t= \"response\";\n\t\t\t\n\t\t\tString Append \t= \"append\";\n\t\t\tString Prepend \t= \"prepend\";\n\t\t\tString Replace \t= \"replace\";\n\t\t}\n\t}\n\t\n\tprivate static final Map<String, RewriteConditionChecker> Checkers = new HashMap<String, RewriteConditionChecker> ();\n\tstatic {\n\t\tCheckers.put (Spec.Checkers.Is, new IsConditionChecker ());\n\t\tCheckers.put (Spec.Checkers.Isnt, new IsntConditionChecker ());\n\t\tCheckers.put (Spec.Checkers.Starts, new StartsConditionChecker ());\n\t\tCheckers.put (Spec.Checkers.Ends, new EndsConditionChecker ());\n\t\tCheckers.put (Spec.Checkers.Contains, new ContainsConditionChecker ());\n\t\tCheckers.put (Spec.Checkers.RegEx, new RegExConditionChecker ());\n\t}\n\t\n\tprivate static final Map<String, RewriteAction> Actions = new HashMap<String, RewriteAction> ();\n\tstatic {\n\t\tActions.put (Spec.Actions.Bypass, new BypassAction ());\n\t\tActions.put (Spec.Actions.Response, new ResponseAction ());\n\n\t\tActions.put (Spec.Actions.Append, new AppendAction ());\n\t\tActions.put (Spec.Actions.Prepend, new PrependAction ());\n\t\tActions.put (Spec.Actions.Replace, new ReplaceAction ());\n\t}\n\t\n\tprotected ApiServer server;\n\t\n\t@Override\n\tprotected String [] endpoint (ApiRequest request, String [] endpoint) {\n\t\tJsonObject oRewrite = pickRewrite (request, Spec.Endpoint);\n\t\tif (oRewrite == null) {\n\t\t\treturn endpoint;\n\t\t}\n\t\t\n\t\t// process rules\n\t\tString [] rewriten = applyRewrite (request, Placeholder.endpoint, oRewrite, endpoint);\n\t\tif (rewriten != null) {\n\t\t\treturn rewriten;\n\t\t}\n\t\t\n\t\treturn endpoint;\n\t}\n\t\n\t@Override\n\tprotected String [] path (ApiRequest request, String [] path) {\n\t\t\n\t\t//server.tracer ().log (Level.Info, \"Rewrite with Res.Value {0}\", Lang.join (path, Lang.SLASH));\n\t\t\n\t\tJsonObject oRewrite = pickRewrite (request, Spec.Path);\n\t\tif (oRewrite == null) {\n\t\t\treturn path;\n\t\t}\n\t\t\n\t\t//server.tracer ().log (Level.Info, \"Rewrite Spec {0}\", oRewrite);\n\n\t\t// process rules\n\t\tString [] rewriten = applyRewrite (request, Placeholder.path, oRewrite, path);\n\t\tif (rewriten != null) {\n\t\t\treturn rewriten;\n\t\t}\n\t\t\n\t\treturn path;\n\t}\n\t\n\tprivate JsonObject pickRewrite (ApiRequest request, String target) {\n\t\tString spaceNs = request.getSpace ();\n\t\t\n\t\t// at the node level\n\t\tif (Lang.isNullOrEmpty (spaceNs)) {\n\t\t\treturn (JsonObject)Json.find (spec, Spec.Rewrite, target);\n\t\t}\n\t\t\n\t\t// space ns resolved\n\t\t\n\t\tApiSpace space = null;\n\t\ttry {\n\t\t\tspace = server.space (spaceNs);\n\t\t} catch (Exception ex) {\n\t\t\t// ignore. Space not found\n\t\t}\t\n\t\tif (space == null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tObject rewrite = space.getRuntime (Spec.Rewrite);\n\n\t\t//server.tracer ().log (Level.Info, \"Space Rewrite {0}\", rewrite);\n\t\t\n\t\tif (rewrite == null || !(rewrite instanceof JsonObject)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tJsonObject oRewrite = (JsonObject)rewrite;\n\t\tif (Json.isNullOrEmpty (oRewrite)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tJsonObject oTargetRewrite = Json.getObject (oRewrite, target);\n\t\tif (Json.isNullOrEmpty (oTargetRewrite)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\treturn oTargetRewrite;\n\t}\n\t\n\tprivate String [] applyRewrite (ApiRequest request, Placeholder placeholder, JsonObject oRewrite, String [] aTarget) {\n\t\t\n\t\t//server.tracer ().log (Level.Info, \"\\tApply rewrite on \", placeholder);\n\n\t\tJsonArray aRules = Json.getArray (oRewrite, Spec.Rules);\n\t\tif (Json.isNullOrEmpty (aRules)) {\n\t\t\treturn aTarget;\n\t\t}\n\t\t\n\t\t//server.tracer ().log (Level.Info, \"\\tFound {0} rules\", aRules.count ());\n\n\t\tfor (int i = 0; i < aRules.count (); i++) {\n\t\t\tJsonObject oRule = (JsonObject)aRules.get (i);\n\t\t\taTarget = applyRule (request, placeholder, oRule, aTarget);\n\t\t}\n\t\t\n\t\treturn aTarget;\n\t}\n\t\n\tprivate String [] applyRule (ApiRequest request, Placeholder placeholder, JsonObject rule, String [] aTarget) {\n\t\t\n\t\t// check methods\n\t\tJsonArray methods = Json.getArray (rule, Spec.Methods);\n\t\t\n\t\tif (!Json.isNullOrEmpty (methods) && !methods.contains (request.getVerb ().name ())) {\n\t\t\treturn aTarget;\n\t\t}\n\t\t\n\t\t// check condition\n\t\tObject oIf = rule.get (Spec.If);\n\t\t\n\t\tString condition = null;\n\t\tPlaceholder scope = placeholder;\n\t\t\n\t\tif (oIf instanceof JsonObject) {\n\t\t\tcondition = Json.getString ((JsonObject)oIf, Spec.Condition);\n\t\t\tscope = Placeholder.valueOf (Json.getString ((JsonObject)oIf, Spec.Scope, placeholder.name ()));\n\t\t} else {\n\t\t\tcondition = Json.getString (rule, Spec.If);\n\t\t}\t\t\n\t\t\n\t\t//server.tracer ().log (Level.Info, \"\\tApply rule with condition {0}\", condition);\n\n\t\tboolean apply = true;\n\t\t\n\t\tString conditionValue = null;\n\t\t\n\t\tif (!Lang.isNullOrEmpty (condition)) {\n\t\t\tint indexOfColon = condition.indexOf (Lang.COLON);\n\t\t\tif (indexOfColon > 0) {\n\t\t\t\tString checkerId \t= condition.substring (0, indexOfColon).trim ();\n\t\t\t\tconditionValue \t\t= condition.substring (indexOfColon + 1).trim ();\n\t\t\t\t\n\t\t\t\tRewriteConditionChecker checker = Checkers.get (checkerId);\n\t\t\t\tserver.tracer ().log (Level.Debug, \"\\tRule checker {0}\", checker);\n\t\t\t\t\n\t\t\t\tapply = (checker == null) || \n\t\t\t\t\t\tchecker.check (scope.equals (Placeholder.endpoint) ? request.getEndpoint () : request.getPath (), conditionValue);\n\t\t\t\t\n\t\t\t\tif (Json.getBoolean (rule, Spec.Negate, false)) {\n\t\t\t\t\tapply = !apply;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t//server.tracer ().log (Level.Info, \"\\tShould apply actions? {0}\", apply);\n\n\t\tif (!apply) {\n\t\t\treturn aTarget;\n\t\t}\n\t\t\n\t\t// apply actions\n\t\tObject then = rule.get (Spec.Then);\n\t\tif (then == null || !(then instanceof JsonObject)) {\n\t\t\treturn aTarget;\n\t\t}\n\t\t\n\t\t//server.tracer ().log (Level.Info, \"\\tApply actions {0}\", then);\n\t\t\n\t\tJsonObject actions = (JsonObject)then;\n\t\tif (Json.isNullOrEmpty (actions)) {\n\t\t\treturn aTarget;\n\t\t}\n\t\t\n\t\tIterator<String> actionIds = actions.keys ();\n\t\twhile (actionIds.hasNext ()) {\n\t\t\tString actionId = actionIds.next ();\n\t\t\t//server.tracer ().log (Level.Info, \"\\tApply action {0}\", actionId);\n\t\t\tRewriteAction action = Actions.get (actionId);\n\t\t\tif (action == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//server.tracer ().log (Level.Info, \"\\t\\t with processor {0}\", action);\n\t\t\taTarget = action.apply (request, placeholder, aTarget, actions.get (actionId), conditionValue);\n\t\t}\n\t\t\n\t\treturn aTarget;\n\t}\n\n\tpublic void setServer (ApiServer server) {\n\t\tthis.server = server;\n\t}\n\n}", "class_id": 0, "repo": "bluenimble/serverless", "file": "server/bluenimble-server/src/main/java/com/bluenimble/platform/server/visitors/impls/RewriteApiRequestVisitor.java", "last_update_at": "2019-05-04T00:28:56+00:00", "question_id": "1d89d46a7a92c46d22cf60304201d42e2b644114", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RewriteApiRequestVisitor extends SelectiveApiRequestVisitor {\n\tprivate static final long serialVersionUID = 1782406079539122227L;\n\t\n\tinterface Spec {\n\t\tString Rewrite\t= \"rewrite\";\n\t\tString Rules\t= \"rules\";\n\t\t\n\t\tString Endpoint\t= \"endpoint\";\n\t\tString Path\t\t= \"path\";\n\t\tString If \t\t= \"if\";\n\t\tString Condition= \"condition\";\n\t\tString Scope \t= \"scope\";\n\t\tString Then \t= \"then\";\n\t\tString Negate \t= \"negate\";\n\t\tString Methods \t= \"methods\";\n\t\t\n\t\tinterface Checkers {\n\t\t\tString Isnt \t= \"isnt\";\n\t\t\tString Is \t\t= \"is\";\n\t\t\tString Starts \t= \"starts\";\n\t\t\tString Ends \t= \"ends\";\n\t\t\tString Contains = \"contains\";\n\t\t\tString RegEx \t= \"regex\";\n\t\t}\n\t\tinterface Actions {\n\t\t\tString Bypass\t= \"bypass\";\n\t\t\tString Response\t= \"response\";\n\t\t\t\n\t\t\tString Append \t= \"append\";\n\t\t\tString Prepend \t= \"prepend\";\n\t\t\tString Replace \t= \"replace\";\n\t\t}\n\t}\n\t\n\tprivate static final Map<String, RewriteConditionChecker> Checkers = new HashMap<String, RewriteConditionChecker> ();\n\tstatic {\n\t\tCheckers.put (Spec.Checkers.Is, new IsConditionChecker ());\n\t\tCheckers.put (Spec.Checkers.Isnt, new IsntConditionChecker ());\n\t\tCheckers.put (Spec.Checkers.Starts, new StartsConditionChecker ());\n\t\tCheckers.put (Spec.Checkers.Ends, new EndsConditionChecker ());\n\t\tCheckers.put (Spec.Checkers.Contains, new ContainsConditionChecker ());\n\t\tCheckers.put (Spec.Checkers.RegEx, new RegExConditionChecker ());\n\t}\n\t\n\tprivate static final Map<String, RewriteAction> Actions = new HashMap<String, RewriteAction> ();\n\tstatic {\n\t\tActions.put (Spec.Actions.Bypass, new BypassAction ());\n\t\tActions.put (Spec.Actions.Response, new ResponseAction ());\n\t\tActions.put (Spec.Actions.Append, new AppendAction ());\n\t\tActions.put (Spec.Actions.Prepend, new PrependAction ());\n\t\tActions.put (Spec.Actions.Replace, new ReplaceAction ());\n\t}\n\t\n\tprotected ApiServer server;\n\t\n\t@Override\n\tprotected String [] endpoint (ApiRequest request, String [] endpoint) {\n\t\tJsonObject oRewrite = pickRewrite (request, Spec.Endpoint);\n\t\tif (oRewrite == null) {\n\t\t\treturn endpoint;\n\t\t}\n\t\t\n\t\t// process rules\n\t\tString [] rewriten = applyRewrite (request, Placeholder.endpoint, oRewrite, endpoint);\n\t\tif (rewriten != null) {\n\t\t\treturn rewriten;\n\t\t}\n\t\t\n\t\treturn endpoint;\n\t}\n\t\n\t@Override\n\tprotected String [] path (ApiRequest request, String [] path) {\n\t\t\n\t\t//server.tracer ().log (Level.Info, \"Rewrite with Res.Value {0}\", Lang.join (path, Lang.SLASH));\n\t\t\n\t\tJsonObject oRewrite = pickRewrite (request, Spec.Path);\n\t\tif (oRewrite == null) {\n\t\t\treturn path;\n\t\t}\n\t\t\n\t\t//server.tracer ().log (Level.Info, \"Rewrite Spec {0}\", oRewrite);\n\t\t// process rules\n\t\tString [] rewriten = applyRewrite (request, Placeholder.path, oRewrite, path);\n\t\tif (rewriten != null) {\n\t\t\treturn rewriten;\n\t\t}\n\t\t\n\t\treturn path;\n\t}\n\t\n\tprivate JsonObject pickRewrite (ApiRequest request, String target) {\n\t\tString spaceNs = request.getSpace ();\n\t\t\n\t\t// at the node level\n\t\tif (Lang.isNullOrEmpty (spaceNs)) {\n\t\t\treturn (JsonObject)Json.find (spec, Spec.Rewrite, target);\n\t\t}\n\t\t\n\t\t// space ns resolved\n\t\t\n\t\tApiSpace space = null;\n\t\ttry {\n\t\t\tspace = server.space (spaceNs);\n\t\t} catch (Exception ex) {\n\t\t\t// ignore. Space not found\n\t\t}\t\n\t\tif (space == null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tObject rewrite = space.getRuntime (Spec.Rewrite);\n\t\t//server.tracer ().log (Level.Info, \"Space Rewrite {0}\", rewrite);\n\t\t\n\t\tif (rewrite == null || !(rewrite instanceof JsonObject)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tJsonObject oRewrite = (JsonObject)rewrite;\n\t\tif (Json.isNullOrEmpty (oRewrite)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tJsonObject oTargetRewrite = Json.getObject (oRewrite, target);\n\t\tif (Json.isNullOrEmpty (oTargetRewrite)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\treturn oTargetRewrite;\n\t}\n\t\n\tprivate String [] applyRewrite (ApiRequest request, Placeholder placeholder, JsonObject oRewrite, String [] aTarget) {\n\t\t\n\t\t//server.tracer ().log (Level.Info, \"\\tApply rewrite on \", placeholder);\n\t\tJsonArray aRules = Json.getArray (oRewrite, Spec.Rules);\n\t\tif (Json.isNullOrEmpty (aRules)) {\n\t\t\treturn aTarget;\n\t\t}\n\t\t\n\t\t//server.tracer ().log (Level.Info, \"\\tFound {0} rules\", aRules.count ());\n\t\tfor (int i = 0; i < aRules.count (); i++) {\n\t\t\tJsonObject oRule = (JsonObject)aRules.get (i);\n\t\t\taTarget = applyRule (request, placeholder, oRule, aTarget);\n\t\t}\n\t\t\n\t\treturn aTarget;\n\t}\n\t\n\tprivate String [] applyRule (ApiRequest request, Placeholder placeholder, JsonObject rule, String [] aTarget) {\n\t\t\n\t\t// check methods\n\t\tJsonArray methods = Json.getArray (rule, Spec.Methods);\n\t\t\n\t\tif (!Json.isNullOrEmpty (methods) && !methods.contains (request.getVerb ().name ())) {\n\t\t\treturn aTarget;\n\t\t}\n\t\t\n\t\t// check condition\n\t\tObject oIf = rule.get (Spec.If);\n\t\t\n\t\tString condition = null;\n\t\tPlaceholder scope = placeholder;\n\t\t\n\t\tif (oIf instanceof JsonObject) {\n\t\t\tcondition = Json.getString ((JsonObject)oIf, Spec.Condition);\n\t\t\tscope = Placeholder.valueOf (Json.getString ((JsonObject)oIf, Spec.Scope, placeholder.name ()));\n\t\t} else {\n\t\t\tcondition = Json.getString (rule, Spec.If);\n\t\t}\t\t\n\t\t\n\t\t//server.tracer ().log (Level.Info, \"\\tApply rule with condition {0}\", condition);\n\t\tboolean apply = true;\n\t\t\n\t\tString conditionValue = null;\n\t\t\n\t\tif (!Lang.isNullOrEmpty (condition)) {\n\t\t\tint indexOfColon = condition.indexOf (Lang.COLON);\n\t\t\tif (indexOfColon > 0) {\n\t\t\t\tString checkerId \t= condition.substring (0, indexOfColon).trim ();\n\t\t\t\tconditionValue \t\t= condition.substring (indexOfColon + 1).trim ();\n\t\t\t\t\n\t\t\t\tRewriteConditionChecker checker = Checkers.get (checkerId);\n\t\t\t\tserver.tracer ().log (Level.Debug, \"\\tRule checker {0}\", checker);\n\t\t\t\t\n\t\t\t\tapply = (checker == null) || \n\t\t\t\t\t\tchecker.check (scope.equals (Placeholder.endpoint) ? request.getEndpoint () : request.getPath (), conditionValue);\n\t\t\t\t\n\t\t\t\tif (Json.getBoolean (rule, Spec.Negate, false)) {\n\t\t\t\t\tapply = !apply;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t//server.tracer ().log (Level.Info, \"\\tShould apply actions? {0}\", apply);\n\t\tif (!apply) {\n\t\t\treturn aTarget;\n\t\t}\n\t\t\n\t\t// apply actions\n\t\tObject then = rule.get (Spec.Then);\n\t\tif (then == null || !(then instanceof JsonObject)) {\n\t\t\treturn aTarget;\n\t\t}\n\t\t\n\t\t//server.tracer ().log (Level.Info, \"\\tApply actions {0}\", then);\n\t\t\n\t\tJsonObject actions = (JsonObject)then;\n\t\tif (Json.isNullOrEmpty (actions)) {\n\t\t\treturn aTarget;\n\t\t}\n\t\t\n\t\tIterator<String> actionIds = actions.keys ();\n\t\twhile (actionIds.hasNext ()) {\n\t\t\tString actionId = actionIds.next ();\n\t\t\t//server.tracer ().log (Level.Info, \"\\tApply action {0}\", actionId);\n\t\t\tRewriteAction action = Actions.get (actionId);\n\t\t\tif (action == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//server.tracer ().log (Level.Info, \"\\t\\t with processor {0}\", action);\n\t\t\taTarget = action.apply (request, placeholder, aTarget, actions.get (actionId), conditionValue);\n\t\t}\n\t\t\n\t\treturn aTarget;\n\t}\n\tpublic void setServer (ApiServer server) {\n\t\tthis.server = server;\n\t}\n"]]}
{"hexsha": "32f403095b03c2cf2dabff8ac2d2cec2981947fa", "ext": "java", "lang": "Java", "content": "@SuppressWarnings(\"Convert2streamapi\")\npublic class PbskyImpl extends RefreshLoader implements Pbsky {\n\n    final static Logger log = LoggerFactory.getLogger(PbskyImpl.class);\n\n    private List<PbsServerConfig> pbsServers;\n    private PbsCache pbsCache;\n    private PbsConnector pbsConnector;\n\n    private List<PBS> pbsky;\n    private Map<String, Queue> queuesMap;\n    private List<Job> allJobs;\n    private JobsInfo jobsInfo;\n\n    public void setPbsServers(List<PbsServerConfig> pbsServers) {\n        this.pbsServers = pbsServers;\n    }\n\n    @Override\n    public List<PbsServerConfig> getPbsServerConfigs() {\n        return pbsServers;\n    }\n\n    public void setPbsCache(PbsCache pbsCache) {\n        this.pbsCache = pbsCache;\n    }\n\n    public void setPbsConnector(PbsConnector pbsConnector) {\n        this.pbsConnector = pbsConnector;\n    }\n\n    public PbskyImpl() {\n    }\n\n    @Override\n    public List<PBS> getListOfPBS() {\n        //obsahuje checkLoad(), takze neni potreba tam, kde se volaji getListOfPBS()\n        checkLoad();\n        return pbsky;\n    }\n\n    private static PBS findPBSForServer(PbsServerConfig server, List<PBS> pbsList) {\n        if(pbsList==null) return null;\n        for (PBS p : pbsList) {\n            if (p.getServerConfig().equals(server)) {\n                return p;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    protected void load() {\n        try {\n            List<PBS> pbskyNew = new ArrayList<>();\n            Map<String, Queue> queuesMapNew = new HashMap<>();\n            List<PBS> oldPbsky = new ArrayList<>();\n            //nacti vsechno cerstve. pokud to jde, jinak si nech stara data\n            for (PbsServerConfig server : pbsServers) {\n                PBS oldData = findPBSForServer(server, pbsky);\n                try {\n                    long time = System.currentTimeMillis();\n                    PBS pbs = pbsConnector.loadData(server);\n                    time = System.currentTimeMillis()- time;\n                    if(time > 20000L) {\n                        log.warn(\"loading data from PBS {} took {} ms\", server.getHost(), time);\n                    }\n                    pbs.uprav();\n                    pbskyNew.add(pbs);\n                    log.debug(\"got new data \"+pbs);\n                    if(oldData!=null) {\n                        oldPbsky.add(oldData);\n                        log.debug(\"marked old data for clearing \"+oldData);\n                    }\n                } catch (RuntimeException ex) {\n                    log.error(\"Cannot load PBS data from server \" + server.getHost(),ex);\n                    //keep old data for that server\n                    if (oldData != null) {\n                        log.warn(\"keeping old data \" + pbsky.toString());\n                        pbskyNew.add(oldData);\n                    } else {\n                        log.warn(\"could not find old PBS data for server \" + server.getHost());\n                    }\n                }\n\n            }\n            //predpripravit nova data\n            for (PBS pbs : pbskyNew) {\n                for (Queue q : pbs.getQueues().values()) {\n                    queuesMapNew.put(q.getName(), q);\n                }\n                for (Node node : pbs.getNodesByName()) {\n                    node.setGpuJobMap(pbsCache.getGpuAlloc(node));\n                }\n            }\n            //vsechno se povedlo, mame nova data\n            //prirazeni novych dat\n            Map<String, Queue> oldQueuesMap = queuesMap;\n            synchronized (this) {\n                pbsky = pbskyNew;\n                queuesMap = queuesMapNew;\n                allJobs = null;\n                jobsInfo = null;\n            }\n            //pomoc Garbage Collectoru\n            if (oldQueuesMap != null) {\n                oldQueuesMap.clear();\n            }\n            new Uklizec(oldPbsky).start();\n        } catch (RuntimeException ex) {\n            log.error(\"Cannot load PBS\", ex);\n        }\n\n    }\n\n\n    @Override\n    synchronized public JobsInfo getJobsInfo() {\n        if (jobsInfo == null) {\n            jobsInfo = new JobsInfo(getAllJobs());\n        }\n        return jobsInfo;\n    }\n\n    private synchronized List<Job> getAllJobs() {\n        List<PBS> list = getListOfPBS();\n        if (allJobs == null) {\n            int jobCount = 0;\n            for (PBS pbs : list) {\n                jobCount += pbs.getJobsById().size();\n            }\n            ArrayList<Job> jobs = new ArrayList<>(jobCount);\n            for (PBS pbs : list) {\n                jobs.addAll(pbs.getJobsById());\n            }\n            allJobs = jobs;\n        }\n        return allJobs;\n    }\n\n    @Override\n    public Queue getQueueByName(String queueName) {\n        checkLoad();\n        return queuesMap.get(queueName);\n    }\n\n    @Override\n    public Job getJobByName(String jobName) {\n        for (PBS pbs : getListOfPBS()) {\n            Job job = pbs.getJobs().get(jobName);\n            //ignore jobs in Moved state, they are reported by another server in another state\n            if (job != null && !\"M\".equals(job.getState())) return job;\n        }\n        return null;\n    }\n\n    @Override\n    public List<Job> getSortedJobs(JobsSortOrder poradi) {\n        checkLoad();\n        List<Job> jobs = getAllJobs();\n        if(poradi==null) poradi = JobsSortOrder.Id;\n        jobs = new ArrayList<>(jobs);\n        switch (poradi) {\n            case Id:\n                jobs.sort(jobsIdComparator);\n                break;\n            case CPU:\n                jobs.sort(jobCPUComparator);\n                break;\n            case CPUTime:\n                jobs.sort(jobCPUTimeUsedComparator);\n                break;\n            case Name:\n                jobs.sort(jobNameComparator);\n                break;\n            case Queue:\n                jobs.sort(jobQueueComparator);\n                break;\n            case Ctime:\n                jobs.sort(jobCtimeComparator);\n                break;\n            case ReservedMemTotal:\n                jobs.sort(jobReservedMemTotalComparator);\n                break;\n            case UsedMem:\n                jobs.sort(jobUsedMemComparator);\n                break;\n            case User:\n                jobs.sort(jobUserComparator);\n                break;\n            case WallTime:\n                jobs.sort(jobWallTimeUsedComparator);\n                break;\n            case State:\n                jobs.sort(jobStateComparator);\n                break;\n        }\n        return jobs;\n    }\n\n    @Override\n    public List<Node> getAllNodes() {\n        int nodeCount = 0;\n        List<PBS> list = getListOfPBS();\n        for (PBS pbs : list) {\n            nodeCount += pbs.getNodesByName().size();\n        }\n        ArrayList<Node> nodes = new ArrayList<>(nodeCount);\n        for (PBS pbs : list) {\n            nodes.addAll(pbs.getNodesByName());\n        }\n        nodes.sort(nodesNameComparator);\n        return nodes;\n    }\n\n    private static User getUserByName(String userName, List<PBS> list) {\n        User u = null;\n        for (PBS pbs : list) {\n            User u2 = pbs.getUsersMap().get(userName);\n            if (u2 != null) {\n                u = (u == null ? u2 : new User(u, u2));\n            }\n        }\n        return u;\n    }\n\n    public User getUserByName(String userName) {\n        return getUserByName(userName, getListOfPBS());\n    }\n\n    @Override\n    public List<Job> getUserJobs(String userName, JobsSortOrder sort) {\n        ArrayList<Job> jobs = new ArrayList<>();\n        for (Job job : this.getSortedJobs(sort)) {\n            if (job.getUser().equals(userName)) {\n                jobs.add(job);\n            }\n        }\n        return jobs;\n    }\n\n    @Override\n    public Node getNodeByName(String nodeName) {\n        for (PBS pbs : getListOfPBS()) {\n            Node node = pbs.getNodes().get(nodeName);\n            if (node != null) return node;\n        }\n        return null;\n    }\n\n    @Override\n    public Node getNodeByFQDN(String fqdn) {\n        for (PBS pbs : getListOfPBS()) {\n            Node node = pbs.getFqdnToNodeMap().get(fqdn);\n            if (node != null) return node;\n        }\n        return null;\n    }\n\n    @Override\n    public int getJobsQueuedCount() {\n        int total = 0;\n        for (PBS pbs : getListOfPBS()) {\n            total += pbs.getJobsQueuedCount();\n        }\n        return total;\n    }\n\n    private static Set<String> getUserNames(List<PBS> list) {\n        Set<String> userNames = new TreeSet<>();\n        for (PBS pbs : list) {\n            userNames.addAll(pbs.getUsersMap().keySet());\n        }\n        return userNames;\n    }\n\n    @Override\n    public Set<String> getUserNames() {\n        return getUserNames(getListOfPBS());\n    }\n\n\n    @Override\n    public List<User> getSortedUsers(UsersSortOrder usersSortOrder) {\n        //spojit udaje ze vsech PBSek\n        List<PBS> list = getListOfPBS();\n        List<User> users = new ArrayList<>();\n        for (String userName : getUserNames(list)) {\n            users.add(getUserByName(userName, list));\n        }\n        //seradit\n        switch (usersSortOrder) {\n            case name:\n                users.sort(userNameComparator);\n                break;\n            case jobsTotal:\n                users.sort(userJobsTotalComparator);\n                break;\n            case jobsStateQ:\n                users.sort(userJobsStateQComparator);\n                break;\n            case jobsStateR:\n                users.sort(userJobsStateRComparator);\n                break;\n            case jobsStateC:\n                users.sort(userJobsStateCComparator);\n                break;\n            case jobsOther:\n                users.sort(userJobsOtherComparator);\n                break;\n            case cpusTotal:\n                users.sort(userCpusTotalComparator);\n                break;\n            case cpusStateQ:\n                users.sort(userCpusStateQComparator);\n                break;\n            case cpusStateR:\n                users.sort(userCpusStateRComparator);\n                break;\n            case cpusStateC:\n                users.sort(userCpusStateCComparator);\n                break;\n            case cpusOther:\n                users.sort(userCpusOtherComparator);\n                break;\n            case fairshare:\n                //neni zatim podle ceho tridit\n                break;\n            default:\n                throw new RuntimeException(\"unknow choice usersSortOrder=\" + usersSortOrder);\n        }\n        return users;\n    }\n\n    @SuppressWarnings(\"Convert2streamapi\")\n    @Override\n    public List<TextWithCount> getReasonsForJobsQueued(PBS pbs) {\n        HashMap<String, Integer> counters = new HashMap<>();\n            for (Job job : pbs.getJobsById()) {\n                if (\"Q\".equals(job.getState())) {\n                    String comment = job.getComment();\n                    Integer count = counters.get(comment);\n                    if (count == null) {\n                        count = 0;\n                    }\n                    counters.put(comment, count + 1);\n                }\n            }\n        List<TextWithCount> duvody = new ArrayList<>(counters.size());\n        for (String duvod : counters.keySet()) {\n            duvody.add(new TextWithCount(duvod, counters.get(duvod)));\n        }\n        Collections.sort(duvody);\n        return duvody;\n    }\n\n    private static class Uklizec extends Thread {\n        private final List<PBS> pbsky_old;\n\n        private Uklizec(List<PBS> pbsky) {\n            super(\"uklizec\");\n            this.pbsky_old = pbsky;\n        }\n\n        @Override\n        public void run() {\n            try {\n                Thread.sleep(90000);\n            } catch (InterruptedException e) {\n                log.error(\"problem v cekani\", e);\n            }\n            for (PBS pbs : pbsky_old) {\n                pbs.clear();\n            }\n            pbsky_old.clear();\n        }\n    }\n\n\n    //comparators for array sorting\n    static final Comparator<Queue> queuesPriorityComparator = (o1, o2) -> o2.getPriority() - o1.getPriority();\n\n    static Comparator<Node> nodesNameComparator = (h1, h2) -> {\n        String h1clustName = h1.getClusterName();\n        if (h1clustName == null) {\n            log.error(\"Node h1=\" + h1 + \" has no clusterName\");\n            throw new IllegalArgumentException(\"node \" + h1.getName() + \" has no clusterName\");\n        }\n        if (!h1clustName.equals(h2.getClusterName())) {\n            return h1.getClusterName().compareTo(h2.getClusterName());\n        } else {\n            int diffNumInCluster = h1.getNumInCluster() - h2.getNumInCluster();\n            if (diffNumInCluster != 0) {\n                return diffNumInCluster;\n            } else {\n                return h1.getVirtNum() - h2.getVirtNum();\n            }\n        }\n    };\n\n    static final Comparator<Job> jobsIdComparator = (j1, j2) -> {\n        //first compare server part of id, e.g. arien-pro.ics.muni.cz\n        int serverDiff = j1.getIdServer().compareTo(j2.getIdServer());\n        if (serverDiff != 0) return serverDiff;\n        //if server part is the same, compare numerical id\n        int numDiff = j1.getIdNum() - j2.getIdNum();\n        if (numDiff != 0) return numDiff;\n        //if server and id are the same, maybe job array id is different\n        int subNumDiff = j1.getIdSubNum() - j2.getIdSubNum();\n        if (subNumDiff !=0 ) return subNumDiff;\n        //if the whole ids are identical, it is Moved job, sort by server\n        return j1.getPbs().getHost().compareTo(j2.getPbs().getHost());\n    };\n\n\n    private static Comparator<Job> jobCPUComparator = (o1, o2) -> o2.getNoOfUsedCPU() - o1.getNoOfUsedCPU();\n\n    private static Comparator<Job> jobNameComparator = Comparator.comparing(Job::getJobName);\n\n    private static Comparator<Job> jobUserComparator = Comparator.comparing(Job::getUser);\n\n    private static Comparator<Job> jobCPUTimeUsedComparator = (o1, o2) -> (int) (o2.getCPUTimeUsedSec() - o1.getCPUTimeUsedSec());\n\n    private static Comparator<Job> jobWallTimeUsedComparator = (j1,j2) -> {\n        Duration d1 = j1.getWalltimeUsed();\n        if(d1==null) d1 = Duration.ZERO;\n        Duration d2 = j2.getWalltimeUsed();\n        if(d2==null) d2 = Duration.ZERO;\n        return d1.compareTo(d2);\n    };\n\n    private static Comparator<Job> jobStateComparator = Comparator.comparing(o -> JobState.valueOf(o.getState()));\n\n    private static Comparator<Job> jobQueueComparator = Comparator.comparing(Job::getQueueName);\n\n    private static Comparator<Job> jobCtimeComparator = Comparator.comparing(Job::getTimeCreated);\n\n    private static Comparator<Job> jobUsedMemComparator = (o1, o2) -> {\n        long l = o2.getUsedMemoryNum() - o1.getUsedMemoryNum();\n        return (l > 0 ? 1 : (l < 0 ? -1 : 0));\n    };\n    private static Comparator<Job> jobReservedMemTotalComparator = (o1, o2) -> {\n        long l = o2.getReservedMemoryTotalNum() - o1.getReservedMemoryTotalNum();\n        return (l > 0 ? 1 : (l < 0 ? -1 : 0));\n    };\n\n    private static Comparator<User> userNameComparator = Comparator.comparing(User::getName);\n\n    private static Comparator<User> userJobsTotalComparator = (u1, u2) -> u2.getJobsTotal() - u1.getJobsTotal();\n\n    private static Comparator<User> userJobsStateQComparator = (u1, u2) -> u2.getJobsStateQ() - u1.getJobsStateQ();\n\n    private static Comparator<User> userJobsStateRComparator = (u1, u2) -> u2.getJobsStateR() - u1.getJobsStateR();\n\n    private static Comparator<User> userJobsStateCComparator = (u1, u2) -> u2.getJobsStateC() - u1.getJobsStateC();\n\n    private static Comparator<User> userJobsOtherComparator = (u1, u2) -> u2.getJobsOther() - u1.getJobsOther();\n\n    private static Comparator<User> userCpusTotalComparator = (u1, u2) -> u2.getCpusTotal() - u1.getCpusTotal();\n\n    private static Comparator<User> userCpusStateQComparator = (u1, u2) -> u2.getCpusStateQ() - u1.getCpusStateQ();\n\n    private static Comparator<User> userCpusStateRComparator = (u1, u2) -> u2.getCpusStateR() - u1.getCpusStateR();\n\n    private static Comparator<User> userCpusStateCComparator = (u1, u2) -> u2.getCpusStateC() - u1.getCpusStateC();\n\n    private static Comparator<User> userCpusOtherComparator = (u1, u2) -> u2.getCpusOther() - u1.getCpusOther();\n\n\n}", "class_id": 0, "repo": "svobtom/metacentrum-accounting", "file": "pbsmon/src/main/java/cz/cesnet/meta/pbs/PbskyImpl.java", "last_update_at": "2019-08-16T13:45:14+00:00", "question_id": "32f403095b03c2cf2dabff8ac2d2cec2981947fa", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings(\"Convert2streamapi\")\npublic class PbskyImpl extends RefreshLoader implements Pbsky {\n    final static Logger log = LoggerFactory.getLogger(PbskyImpl.class);\n    private List<PbsServerConfig> pbsServers;\n    private PbsCache pbsCache;\n    private PbsConnector pbsConnector;\n    private List<PBS> pbsky;\n    private Map<String, Queue> queuesMap;\n    private List<Job> allJobs;\n    private JobsInfo jobsInfo;\n    public void setPbsServers(List<PbsServerConfig> pbsServers) {\n        this.pbsServers = pbsServers;\n    }\n    @Override\n    public List<PbsServerConfig> getPbsServerConfigs() {\n        return pbsServers;\n    }\n    public void setPbsCache(PbsCache pbsCache) {\n        this.pbsCache = pbsCache;\n    }\n    public void setPbsConnector(PbsConnector pbsConnector) {\n        this.pbsConnector = pbsConnector;\n    }\n    public PbskyImpl() {\n    }\n    @Override\n    public List<PBS> getListOfPBS() {\n        //obsahuje checkLoad(), takze neni potreba tam, kde se volaji getListOfPBS()\n        checkLoad();\n        return pbsky;\n    }\n    private static PBS findPBSForServer(PbsServerConfig server, List<PBS> pbsList) {\n        if(pbsList==null) return null;\n        for (PBS p : pbsList) {\n            if (p.getServerConfig().equals(server)) {\n                return p;\n            }\n        }\n        return null;\n    }\n    @Override\n    protected void load() {\n        try {\n            List<PBS> pbskyNew = new ArrayList<>();\n            Map<String, Queue> queuesMapNew = new HashMap<>();\n            List<PBS> oldPbsky = new ArrayList<>();\n            //nacti vsechno cerstve. pokud to jde, jinak si nech stara data\n            for (PbsServerConfig server : pbsServers) {\n                PBS oldData = findPBSForServer(server, pbsky);\n                try {\n                    long time = System.currentTimeMillis();\n                    PBS pbs = pbsConnector.loadData(server);\n                    time = System.currentTimeMillis()- time;\n                    if(time > 20000L) {\n                        log.warn(\"loading data from PBS {} took {} ms\", server.getHost(), time);\n                    }\n                    pbs.uprav();\n                    pbskyNew.add(pbs);\n                    log.debug(\"got new data \"+pbs);\n                    if(oldData!=null) {\n                        oldPbsky.add(oldData);\n                        log.debug(\"marked old data for clearing \"+oldData);\n                    }\n                } catch (RuntimeException ex) {\n                    log.error(\"Cannot load PBS data from server \" + server.getHost(),ex);\n                    //keep old data for that server\n                    if (oldData != null) {\n                        log.warn(\"keeping old data \" + pbsky.toString());\n                        pbskyNew.add(oldData);\n                    } else {\n                        log.warn(\"could not find old PBS data for server \" + server.getHost());\n                    }\n                }\n            }\n            //predpripravit nova data\n            for (PBS pbs : pbskyNew) {\n                for (Queue q : pbs.getQueues().values()) {\n                    queuesMapNew.put(q.getName(), q);\n                }\n                for (Node node : pbs.getNodesByName()) {\n                    node.setGpuJobMap(pbsCache.getGpuAlloc(node));\n                }\n            }\n            //vsechno se povedlo, mame nova data\n            //prirazeni novych dat\n            Map<String, Queue> oldQueuesMap = queuesMap;\n            synchronized (this) {\n                pbsky = pbskyNew;\n                queuesMap = queuesMapNew;\n                allJobs = null;\n                jobsInfo = null;\n            }\n            //pomoc Garbage Collectoru\n            if (oldQueuesMap != null) {\n                oldQueuesMap.clear();\n            }\n            new Uklizec(oldPbsky).start();\n        } catch (RuntimeException ex) {\n            log.error(\"Cannot load PBS\", ex);\n        }\n    }\n    @Override\n    synchronized public JobsInfo getJobsInfo() {\n        if (jobsInfo == null) {\n            jobsInfo = new JobsInfo(getAllJobs());\n        }\n        return jobsInfo;\n    }\n    private synchronized List<Job> getAllJobs() {\n        List<PBS> list = getListOfPBS();\n        if (allJobs == null) {\n            int jobCount = 0;\n            for (PBS pbs : list) {\n                jobCount += pbs.getJobsById().size();\n            }\n            ArrayList<Job> jobs = new ArrayList<>(jobCount);\n            for (PBS pbs : list) {\n                jobs.addAll(pbs.getJobsById());\n            }\n            allJobs = jobs;\n        }\n        return allJobs;\n    }\n    @Override\n    public Queue getQueueByName(String queueName) {\n        checkLoad();\n        return queuesMap.get(queueName);\n    }\n    @Override\n    public Job getJobByName(String jobName) {\n        for (PBS pbs : getListOfPBS()) {\n            Job job = pbs.getJobs().get(jobName);\n            //ignore jobs in Moved state, they are reported by another server in another state\n            if (job != null && !\"M\".equals(job.getState())) return job;\n        }\n        return null;\n    }\n    @Override\n    public List<Job> getSortedJobs(JobsSortOrder poradi) {\n        checkLoad();\n        List<Job> jobs = getAllJobs();\n        if(poradi==null) poradi = JobsSortOrder.Id;\n        jobs = new ArrayList<>(jobs);\n        switch (poradi) {\n            case Id:\n                jobs.sort(jobsIdComparator);\n                break;\n            case CPU:\n                jobs.sort(jobCPUComparator);\n                break;\n            case CPUTime:\n                jobs.sort(jobCPUTimeUsedComparator);\n                break;\n            case Name:\n                jobs.sort(jobNameComparator);\n                break;\n            case Queue:\n                jobs.sort(jobQueueComparator);\n                break;\n            case Ctime:\n                jobs.sort(jobCtimeComparator);\n                break;\n            case ReservedMemTotal:\n                jobs.sort(jobReservedMemTotalComparator);\n                break;\n            case UsedMem:\n                jobs.sort(jobUsedMemComparator);\n                break;\n            case User:\n                jobs.sort(jobUserComparator);\n                break;\n            case WallTime:\n                jobs.sort(jobWallTimeUsedComparator);\n                break;\n            case State:\n                jobs.sort(jobStateComparator);\n                break;\n        }\n        return jobs;\n    }\n    @Override\n    public List<Node> getAllNodes() {\n        int nodeCount = 0;\n        List<PBS> list = getListOfPBS();\n        for (PBS pbs : list) {\n            nodeCount += pbs.getNodesByName().size();\n        }\n        ArrayList<Node> nodes = new ArrayList<>(nodeCount);\n        for (PBS pbs : list) {\n            nodes.addAll(pbs.getNodesByName());\n        }\n        nodes.sort(nodesNameComparator);\n        return nodes;\n    }\n    private static User getUserByName(String userName, List<PBS> list) {\n        User u = null;\n        for (PBS pbs : list) {\n            User u2 = pbs.getUsersMap().get(userName);\n            if (u2 != null) {\n                u = (u == null ? u2 : new User(u, u2));\n            }\n        }\n        return u;\n    }\n    public User getUserByName(String userName) {\n        return getUserByName(userName, getListOfPBS());\n    }\n    @Override\n    public List<Job> getUserJobs(String userName, JobsSortOrder sort) {\n        ArrayList<Job> jobs = new ArrayList<>();\n        for (Job job : this.getSortedJobs(sort)) {\n            if (job.getUser().equals(userName)) {\n                jobs.add(job);\n            }\n        }\n        return jobs;\n    }\n    @Override\n    public Node getNodeByName(String nodeName) {\n        for (PBS pbs : getListOfPBS()) {\n            Node node = pbs.getNodes().get(nodeName);\n            if (node != null) return node;\n        }\n        return null;\n    }\n    @Override\n    public Node getNodeByFQDN(String fqdn) {\n        for (PBS pbs : getListOfPBS()) {\n            Node node = pbs.getFqdnToNodeMap().get(fqdn);\n            if (node != null) return node;\n        }\n        return null;\n    }\n    @Override\n    public int getJobsQueuedCount() {\n        int total = 0;\n        for (PBS pbs : getListOfPBS()) {\n            total += pbs.getJobsQueuedCount();\n        }\n        return total;\n    }\n    private static Set<String> getUserNames(List<PBS> list) {\n        Set<String> userNames = new TreeSet<>();\n        for (PBS pbs : list) {\n            userNames.addAll(pbs.getUsersMap().keySet());\n        }\n        return userNames;\n    }\n    @Override\n    public Set<String> getUserNames() {\n        return getUserNames(getListOfPBS());\n    }\n    @Override\n    public List<User> getSortedUsers(UsersSortOrder usersSortOrder) {\n        //spojit udaje ze vsech PBSek\n        List<PBS> list = getListOfPBS();\n        List<User> users = new ArrayList<>();\n        for (String userName : getUserNames(list)) {\n            users.add(getUserByName(userName, list));\n        }\n        //seradit\n        switch (usersSortOrder) {\n            case name:\n                users.sort(userNameComparator);\n                break;\n            case jobsTotal:\n                users.sort(userJobsTotalComparator);\n                break;\n            case jobsStateQ:\n                users.sort(userJobsStateQComparator);\n                break;\n            case jobsStateR:\n                users.sort(userJobsStateRComparator);\n                break;\n            case jobsStateC:\n                users.sort(userJobsStateCComparator);\n                break;\n            case jobsOther:\n                users.sort(userJobsOtherComparator);\n                break;\n            case cpusTotal:\n                users.sort(userCpusTotalComparator);\n                break;\n            case cpusStateQ:\n                users.sort(userCpusStateQComparator);\n                break;\n            case cpusStateR:\n                users.sort(userCpusStateRComparator);\n                break;\n            case cpusStateC:\n                users.sort(userCpusStateCComparator);\n                break;\n            case cpusOther:\n                users.sort(userCpusOtherComparator);\n                break;\n            case fairshare:\n                //neni zatim podle ceho tridit\n                break;\n            default:\n                throw new RuntimeException(\"unknow choice usersSortOrder=\" + usersSortOrder);\n        }\n        return users;\n    }\n    @SuppressWarnings(\"Convert2streamapi\")\n    @Override\n    public List<TextWithCount> getReasonsForJobsQueued(PBS pbs) {\n        HashMap<String, Integer> counters = new HashMap<>();\n            for (Job job : pbs.getJobsById()) {\n                if (\"Q\".equals(job.getState())) {\n                    String comment = job.getComment();\n                    Integer count = counters.get(comment);\n                    if (count == null) {\n                        count = 0;\n                    }\n                    counters.put(comment, count + 1);\n                }\n            }\n        List<TextWithCount> duvody = new ArrayList<>(counters.size());\n        for (String duvod : counters.keySet()) {\n            duvody.add(new TextWithCount(duvod, counters.get(duvod)));\n        }\n        Collections.sort(duvody);\n        return duvody;\n    }\n    private static class Uklizec extends Thread {\n        private final List<PBS> pbsky_old;\n        private Uklizec(List<PBS> pbsky) {\n            super(\"uklizec\");\n            this.pbsky_old = pbsky;\n        }\n        @Override\n        public void run() {\n            try {\n                Thread.sleep(90000);\n            } catch (InterruptedException e) {\n                log.error(\"problem v cekani\", e);\n            }\n            for (PBS pbs : pbsky_old) {\n                pbs.clear();\n            }\n            pbsky_old.clear();\n        }\n    }\n    //comparators for array sorting\n    static final Comparator<Queue> queuesPriorityComparator = (o1, o2) -> o2.getPriority() - o1.getPriority();\n    static Comparator<Node> nodesNameComparator = (h1, h2) -> {\n        String h1clustName = h1.getClusterName();\n        if (h1clustName == null) {\n            log.error(\"Node h1=\" + h1 + \" has no clusterName\");\n            throw new IllegalArgumentException(\"node \" + h1.getName() + \" has no clusterName\");\n        }\n        if (!h1clustName.equals(h2.getClusterName())) {\n            return h1.getClusterName().compareTo(h2.getClusterName());\n        } else {\n            int diffNumInCluster = h1.getNumInCluster() - h2.getNumInCluster();\n            if (diffNumInCluster != 0) {\n                return diffNumInCluster;\n            } else {\n                return h1.getVirtNum() - h2.getVirtNum();\n            }\n        }\n    };\n    static final Comparator<Job> jobsIdComparator = (j1, j2) -> {\n        //first compare server part of id, e.g. arien-pro.ics.muni.cz\n        int serverDiff = j1.getIdServer().compareTo(j2.getIdServer());\n        if (serverDiff != 0) return serverDiff;\n        //if server part is the same, compare numerical id\n        int numDiff = j1.getIdNum() - j2.getIdNum();\n        if (numDiff != 0) return numDiff;\n        //if server and id are the same, maybe job array id is different\n        int subNumDiff = j1.getIdSubNum() - j2.getIdSubNum();\n        if (subNumDiff !=0 ) return subNumDiff;\n        //if the whole ids are identical, it is Moved job, sort by server\n        return j1.getPbs().getHost().compareTo(j2.getPbs().getHost());\n    };\n    private static Comparator<Job> jobCPUComparator = (o1, o2) -> o2.getNoOfUsedCPU() - o1.getNoOfUsedCPU();\n    private static Comparator<Job> jobNameComparator = Comparator.comparing(Job::getJobName);\n    private static Comparator<Job> jobUserComparator = Comparator.comparing(Job::getUser);\n    private static Comparator<Job> jobCPUTimeUsedComparator = (o1, o2) -> (int) (o2.getCPUTimeUsedSec() - o1.getCPUTimeUsedSec());\n    private static Comparator<Job> jobWallTimeUsedComparator = (j1,j2) -> {\n        Duration d1 = j1.getWalltimeUsed();\n        if(d1==null) d1 = Duration.ZERO;\n        Duration d2 = j2.getWalltimeUsed();\n        if(d2==null) d2 = Duration.ZERO;\n        return d1.compareTo(d2);\n    };\n    private static Comparator<Job> jobStateComparator = Comparator.comparing(o -> JobState.valueOf(o.getState()));\n    private static Comparator<Job> jobQueueComparator = Comparator.comparing(Job::getQueueName);\n    private static Comparator<Job> jobCtimeComparator = Comparator.comparing(Job::getTimeCreated);\n    private static Comparator<Job> jobUsedMemComparator = (o1, o2) -> {\n        long l = o2.getUsedMemoryNum() - o1.getUsedMemoryNum();\n        return (l > 0 ? 1 : (l < 0 ? -1 : 0));\n    };\n    private static Comparator<Job> jobReservedMemTotalComparator = (o1, o2) -> {\n        long l = o2.getReservedMemoryTotalNum() - o1.getReservedMemoryTotalNum();\n        return (l > 0 ? 1 : (l < 0 ? -1 : 0));\n    };\n    private static Comparator<User> userNameComparator = Comparator.comparing(User::getName);\n    private static Comparator<User> userJobsTotalComparator = (u1, u2) -> u2.getJobsTotal() - u1.getJobsTotal();\n    private static Comparator<User> userJobsStateQComparator = (u1, u2) -> u2.getJobsStateQ() - u1.getJobsStateQ();\n    private static Comparator<User> userJobsStateRComparator = (u1, u2) -> u2.getJobsStateR() - u1.getJobsStateR();\n    private static Comparator<User> userJobsStateCComparator = (u1, u2) -> u2.getJobsStateC() - u1.getJobsStateC();\n    private static Comparator<User> userJobsOtherComparator = (u1, u2) -> u2.getJobsOther() - u1.getJobsOther();\n    private static Comparator<User> userCpusTotalComparator = (u1, u2) -> u2.getCpusTotal() - u1.getCpusTotal();\n    private static Comparator<User> userCpusStateQComparator = (u1, u2) -> u2.getCpusStateQ() - u1.getCpusStateQ();\n    private static Comparator<User> userCpusStateRComparator = (u1, u2) -> u2.getCpusStateR() - u1.getCpusStateR();\n    private static Comparator<User> userCpusStateCComparator = (u1, u2) -> u2.getCpusStateC() - u1.getCpusStateC();\n    private static Comparator<User> userCpusOtherComparator = (u1, u2) -> u2.getCpusOther() - u1.getCpusOther();\n"]]}
{"hexsha": "2bf17f18f2f76831470d2da405d6882568857c00", "ext": "java", "lang": "Java", "content": "public class TypesTest {\n    @Test\n    public void shouldBuildABasic200OKResponse() {\n        Response response = Types.ok(1);\n\n        assertEquals(\"200 OK\", response.status());\n        assertEquals(\"1\", response.headers().get(\"Content-Length\"));\n        assertEquals(\"text/plain; charset=utf-8\", response.headers().get(\"Content-Type\"));\n\n    }\n\n    @Test\n    public void shouldBuildA301MovedPermanentlyResponse() {\n        Response response = Types.movedPermanently(\"localhost\", \"/new-location\");\n\n        assertEquals(\"301 Moved Permanently\", response.status());\n        assertEquals(\"http://localhost/new-location\", response.headers().get(\"Location\"));\n    }\n\n    @Test\n    public void shouldBuildA400BadRequestResponse() {\n        Response response = Types.badRequest();\n\n        assertEquals(\"400 Bad Request\", response.status());\n    }\n\n    @Test\n    public void shouldBuildA404NotFoundResponse() {\n        Response response = Types.notFound();\n\n        assertEquals(\"404 Not Found\", response.status());\n    }\n\n    @Test\n    public void shouldBuildA405NotAllowedResponse() {\n        Response response = Types.methodNotAllowed(\"GET, HEAD\");\n\n        assertEquals(\"405 Method Not Allowed\", response.status());\n        assertEquals(\"GET, HEAD\", response.headers().get(\"Allow\"));\n    }\n\n    @Test\n    public void shouldBuildA500InternalServerErrorResponse() {\n        Response response = Types.internalServerError();\n\n        assertEquals(\"500 Internal Server Error\", response.status());\n    }\n}", "class_id": 0, "repo": "tpetersen0308/http-server", "file": "src/test/java/server/response/TypesTest.java", "last_update_at": "2019-07-03T14:38:49+00:00", "question_id": "2bf17f18f2f76831470d2da405d6882568857c00", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TypesTest {\n    @Test\n    public void shouldBuildABasic200OKResponse() {\n        Response response = Types.ok(1);\n        assertEquals(\"200 OK\", response.status());\n        assertEquals(\"1\", response.headers().get(\"Content-Length\"));\n        assertEquals(\"text/plain; charset=utf-8\", response.headers().get(\"Content-Type\"));\n    }\n    @Test\n    public void shouldBuildA301MovedPermanentlyResponse() {\n        Response response = Types.movedPermanently(\"localhost\", \"/new-location\");\n        assertEquals(\"301 Moved Permanently\", response.status());\n        assertEquals(\"http://localhost/new-location\", response.headers().get(\"Location\"));\n    }\n    @Test\n    public void shouldBuildA400BadRequestResponse() {\n        Response response = Types.badRequest();\n        assertEquals(\"400 Bad Request\", response.status());\n    }\n    @Test\n    public void shouldBuildA404NotFoundResponse() {\n        Response response = Types.notFound();\n        assertEquals(\"404 Not Found\", response.status());\n    }\n    @Test\n    public void shouldBuildA405NotAllowedResponse() {\n        Response response = Types.methodNotAllowed(\"GET, HEAD\");\n        assertEquals(\"405 Method Not Allowed\", response.status());\n        assertEquals(\"GET, HEAD\", response.headers().get(\"Allow\"));\n    }\n    @Test\n    public void shouldBuildA500InternalServerErrorResponse() {\n        Response response = Types.internalServerError();\n        assertEquals(\"500 Internal Server Error\", response.status());\n    }\n"]]}
{"hexsha": "0d5e8ed35c18af33a8d2435779aaa62c49a9ab44", "ext": "java", "lang": "Java", "content": "public class ConstantDoublesCurveTest {\n  private static final double Y1 = 20;\n  private static final double Y2 = 21;\n  private static final String NAME1 = \"a\";\n  private static final String NAME2 = \"b\";\n  private static final ConstantDoublesCurve CURVE = new ConstantDoublesCurve(Y1, NAME1);\n\n  @Test(expectedExceptions = UnsupportedOperationException.class)\n  public void testGetXData() {\n    CURVE.getXData();\n  }\n\n  @Test\n  public void testEqualsAndHashCode() {\n    ConstantDoublesCurve other = new ConstantDoublesCurve(Y1, NAME1);\n    assertEquals(CURVE, other);\n    assertEquals(CURVE.hashCode(), other.hashCode());\n    other = new ConstantDoublesCurve(Y2, NAME1);\n    assertFalse(CURVE.equals(other));\n    other = new ConstantDoublesCurve(Y1);\n    assertFalse(CURVE.equals(other));\n    other = new ConstantDoublesCurve(Y1, NAME2);\n    assertFalse(CURVE.equals(other));\n  }\n\n  @Test\n  public void testGetters() {\n    assertEquals(CURVE.getName(), NAME1);\n    assertEquals(CURVE.getYValue(30.1), Y1, 0);\n    assertEquals(CURVE.size(), 1);\n    assertArrayEquals(CURVE.getYData(), new Double[] {Y1});\n  }\n\n  @Test\n  public void testStaticConstruction() {\n    ConstantDoublesCurve curve = new ConstantDoublesCurve(Y1);\n    ConstantDoublesCurve other = ConstantDoublesCurve.from(Y1);\n    assertArrayEquals(curve.getYData(), other.getYData());\n    assertFalse(curve.getName().equals(other.getName()));\n    curve = new ConstantDoublesCurve(Y1, NAME1);\n    other = ConstantDoublesCurve.from(Y1, NAME1);\n    assertEquals(curve, other);\n  }\n\n  @Test\n  public void testConvert() {\n    final double eps = 1e-15;\n    final double[] x = new double[] {0, 1, 2};\n    final double[] y = new double[] {Y1, Y1, Y1};\n    final LinearInterpolator1D interpolator = new LinearInterpolator1D();\n    InterpolatedDoublesCurve other = CURVE.toInterpolatedDoublesCurve(x, interpolator);\n    assertArrayEquals(other.getXDataAsPrimitive(), x, eps);\n    assertArrayEquals(other.getYDataAsPrimitive(), y, eps);\n  }\n}", "class_id": 0, "repo": "Incapture/OG-Platform", "file": "projects/OG-Analytics/src/test/java/com/opengamma/analytics/math/curve/ConstantDoublesCurveTest.java", "last_update_at": "2019-08-22T06:50:21+00:00", "question_id": "0d5e8ed35c18af33a8d2435779aaa62c49a9ab44", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ConstantDoublesCurveTest {\n  private static final double Y1 = 20;\n  private static final double Y2 = 21;\n  private static final String NAME1 = \"a\";\n  private static final String NAME2 = \"b\";\n  private static final ConstantDoublesCurve CURVE = new ConstantDoublesCurve(Y1, NAME1);\n  @Test(expectedExceptions = UnsupportedOperationException.class)\n  public void testGetXData() {\n    CURVE.getXData();\n  }\n  @Test\n  public void testEqualsAndHashCode() {\n    ConstantDoublesCurve other = new ConstantDoublesCurve(Y1, NAME1);\n    assertEquals(CURVE, other);\n    assertEquals(CURVE.hashCode(), other.hashCode());\n    other = new ConstantDoublesCurve(Y2, NAME1);\n    assertFalse(CURVE.equals(other));\n    other = new ConstantDoublesCurve(Y1);\n    assertFalse(CURVE.equals(other));\n    other = new ConstantDoublesCurve(Y1, NAME2);\n    assertFalse(CURVE.equals(other));\n  }\n  @Test\n  public void testGetters() {\n    assertEquals(CURVE.getName(), NAME1);\n    assertEquals(CURVE.getYValue(30.1), Y1, 0);\n    assertEquals(CURVE.size(), 1);\n    assertArrayEquals(CURVE.getYData(), new Double[] {Y1});\n  }\n  @Test\n  public void testStaticConstruction() {\n    ConstantDoublesCurve curve = new ConstantDoublesCurve(Y1);\n    ConstantDoublesCurve other = ConstantDoublesCurve.from(Y1);\n    assertArrayEquals(curve.getYData(), other.getYData());\n    assertFalse(curve.getName().equals(other.getName()));\n    curve = new ConstantDoublesCurve(Y1, NAME1);\n    other = ConstantDoublesCurve.from(Y1, NAME1);\n    assertEquals(curve, other);\n  }\n  @Test\n  public void testConvert() {\n    final double eps = 1e-15;\n    final double[] x = new double[] {0, 1, 2};\n    final double[] y = new double[] {Y1, Y1, Y1};\n    final LinearInterpolator1D interpolator = new LinearInterpolator1D();\n    InterpolatedDoublesCurve other = CURVE.toInterpolatedDoublesCurve(x, interpolator);\n    assertArrayEquals(other.getXDataAsPrimitive(), x, eps);\n    assertArrayEquals(other.getYDataAsPrimitive(), y, eps);\n  }\n"]]}
{"hexsha": "c57309757218f4452d89227ab50180b8e1638380", "ext": "java", "lang": "Java", "content": "public class TaxonomyHostsAndEntryJoinMapper\n        implements PairFlatMapFunction<\n                Tuple2<String, Tuple2<Iterable<String>, Optional<TaxonomyEntry>>>,\n                String,\n                Taxonomy> {\n    private static final long serialVersionUID = -4297072275882262089L;\n\n    @Override\n    public Iterator<Tuple2<String, Taxonomy>> call(\n            Tuple2<String, Tuple2<Iterable<String>, Optional<TaxonomyEntry>>> tuple)\n            throws Exception {\n        List<Tuple2<String, Taxonomy>> result = new ArrayList<>();\n        if (tuple._2 != null && tuple._2._2.isPresent()) {\n            TaxonomyEntry entry = tuple._2._2.get();\n            Taxonomy host =\n                    new TaxonomyBuilder()\n                            .taxonId(entry.getTaxonId())\n                            .scientificName(entry.getScientificName())\n                            .commonName(entry.getCommonName())\n                            .mnemonic(entry.getMnemonic())\n                            .build();\n            for (String taxId : tuple._2._1) {\n                result.add(new Tuple2<>(taxId, host));\n            }\n        }\n        return result.iterator();\n    }\n}", "class_id": 0, "repo": "ebi-uniprot/uniprot-indexer", "file": "spark-indexer/src/main/java/org/uniprot/store/spark/indexer/taxonomy/mapper/TaxonomyHostsAndEntryJoinMapper.java", "last_update_at": "2019-07-16T00:06:12+00:00", "question_id": "c57309757218f4452d89227ab50180b8e1638380", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TaxonomyHostsAndEntryJoinMapper\n        implements PairFlatMapFunction<\n                Tuple2<String, Tuple2<Iterable<String>, Optional<TaxonomyEntry>>>,\n                String,\n                Taxonomy> {\n    private static final long serialVersionUID = -4297072275882262089L;\n    @Override\n    public Iterator<Tuple2<String, Taxonomy>> call(\n            Tuple2<String, Tuple2<Iterable<String>, Optional<TaxonomyEntry>>> tuple)\n            throws Exception {\n        List<Tuple2<String, Taxonomy>> result = new ArrayList<>();\n        if (tuple._2 != null && tuple._2._2.isPresent()) {\n            TaxonomyEntry entry = tuple._2._2.get();\n            Taxonomy host =\n                    new TaxonomyBuilder()\n                            .taxonId(entry.getTaxonId())\n                            .scientificName(entry.getScientificName())\n                            .commonName(entry.getCommonName())\n                            .mnemonic(entry.getMnemonic())\n                            .build();\n            for (String taxId : tuple._2._1) {\n                result.add(new Tuple2<>(taxId, host));\n            }\n        }\n        return result.iterator();\n    }\n"]]}
{"hexsha": "227473961d81c7fa871ac19f305a71b5be88c6bd", "ext": "java", "lang": "Java", "content": "public class AndroidEnvironment {\n    private final static String ANDWORX_HOME_PATH = \"andworx\";\n\tprivate static final String ANDWORX_HOME_ERROR = \"Error creating Andworx home directory %s\";\n\tprivate static final String REPOSITORY_FOLDER = \"libraries\";\n\tprivate static final String DEFAULT_ANDROID_HOME = System.getProperty(\"user.dir\") + File.separator + AndroidLocation.FOLDER_DOT_ANDROID;\n\n\tprivate static class FailedTargetLoadStatus implements TargetLoadStatusMonitor {\n\n\t\t@Override\n\t\tpublic LoadStatus getLoadStatus(String hashString) {\n\t\t\treturn LoadStatus.FAILED;\n\t\t}\n\t\t\n\t}\n\t\n\t/** Location of the expanded AARs stored in a Maven repository structure */ \n\tprotected File repositoryLocation;\n\t/** Android's own home location */\n\tprotected File androidHome;\n\tprivate final ILogger logger;\n\tprotected TargetLoadStatusMonitor targetLoadStatusMonitor;\n\n\tpublic AndroidEnvironment(ILogger logger) {\n\t\tthis.logger = logger;\n\t\ttargetLoadStatusMonitor = new FailedTargetLoadStatus();\n\t}\n\t\n\t/**\n\t * Returns flag set true if Android SDK is available\n\t * @return boolean\n\t */\n\tpublic boolean isValid() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns the available Android targets (both Platform and Add-ons\n\t * @return Android target collection\n\t */\n\tpublic Collection<IAndroidTarget> getAndroidTargets() { \n\t\treturn Collections.emptyList();\n    }\n\n\t/**\n\t * Returns the location of the libraries repository within Android home\n\t * @return File object\n\t */\n\tpublic File getRepositoryLocation() {\n\t\tif (repositoryLocation == null)\n\t\t\trepositoryLocation = new File(getAndworxHome(), REPOSITORY_FOLDER);\n\t\treturn repositoryLocation;\n\t}\n\n\t/**\n\t * Returns Android SDK interface to {@link RepoManager}\n\t * @return AndroidSdkHandler object or null if not available\n\t */\n\t@Nullable\n\tpublic  AndroidSdkHandler getAndroidSdkHandler() {\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * Returns closest match Target Platform to given version\n\t * @param targetHash Target platform version specified as a hash string\n\t * @return IAndroidTarget object or null if none available\n\t */\n\t@Nullable\n\tpublic IAndroidTarget getAvailableTarget(String targetHash) {\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * Returns Android's own home location. \n\t * @return File object\n\t */\n\tpublic File getAndroidHome() {\n\t\tif (androidHome == null) {\n\t\t\ttry {\n        \t/* getFolder()\n\t\t     * Returns the folder used to store android related files.\n\t\t     * If the folder is not created yet, it will be created.\n\t\t     * @return an OS specific path, terminated by a separator.\n        \t */\n\t\t\tString androidHomeDir = AndroidLocation.getFolder();\n            androidHome = new File(androidHomeDir);\n            if (!androidHome.exists()) {\n            \tif (!androidHome.mkdirs())\n            \t\tthrow new IOException(String.format(\"Cannot create path %s\", androidHome.getAbsolutePath()));\n            } else if (!androidHome.isDirectory())\n        \t\tthrow new IOException(String.format(\"Path %s is not a directory\", androidHome.getAbsolutePath()));\n\t        } catch (AndroidLocationException | IOException | SecurityException e) {\n\t        \tlogger.error(e, \"Error finding Android home\");\n\t        \t// Apply default\n\t        \tandroidHome = new File(DEFAULT_ANDROID_HOME);\n\t        }\n\t\t}\n\t\treturn androidHome;\n\t}\n\n\t/**\n\t * Returns Andworx's own home location inside Android home\n\t * @return File object\n\t */\n\tpublic File getAndworxHome() {\n    \tFile androidHomeDir = getAndroidHome();\n        File andworxHomePath = new File(androidHomeDir, ANDWORX_HOME_PATH);\n    \tif (!andworxHomePath.exists()) {\n    \t\ttry {\n    \t\t\tandworxHomePath.mkdirs();\n    \t\t} catch (SecurityException t) {\n    \t\t\tlogger.error(t, ANDWORX_HOME_ERROR, andworxHomePath);\n    \t\t}\n    \t}\n    \tif (!andworxHomePath.exists()) \n    \t\tthrow new AndworxException(String.format(ANDWORX_HOME_ERROR, andworxHomePath));\n    \treturn andworxHomePath;\n    }\n\t\n\t/**\n\t * Return Signing Configuration\n\t * @return SigningConfig object\n\t */\n\tpublic SigningConfig getDefaultDebugSigningConfig() {\n\t\tFile keystoreFile = new File(getAndroidHome(), \"debug.keystore\");\n\t\tif (!keystoreFile.exists())\n\t\t\ttry {\n\t\t\t\tKeystoreHelper.createDebugStore(\n\t\t\t\t\tnull, \n\t\t\t\t\tkeystoreFile, \n\t\t\t\t\tDefaultSigningConfig.DEFAULT_PASSWORD, \n\t\t\t\t\tDefaultSigningConfig.DEFAULT_PASSWORD, \n\t\t\t\t\tDefaultSigningConfig.DEFAULT_ALIAS, \n\t\t\t\t\tlogger);\n\t\t\t} catch (KeytoolException e) {\n\t\t\t\tthrow new AndworxException(\"Error creating debug keystore \" + keystoreFile.toString(), e);\n\t\t\t}\n\t\treturn DefaultSigningConfig.debugSigningConfig(keystoreFile);\n\t}\n\n\t/**\n\t * Returns monitor which always return FAILED load status. Replace targetLoadStatusMonitor to return actual status.\n\t * @return TargetLoadStatusMonitor\n\t */\n\tpublic TargetLoadStatusMonitor getTargetLoadStatusMonitor() {\n\t\treturn targetLoadStatusMonitor;\n\t}\n}", "class_id": 0, "repo": "androidworx/andworx", "file": "android-core/plugins/org.eclipse.andworx.build/src/org/eclipse/andworx/context/AndroidEnvironment.java", "last_update_at": "2019-03-01T14:51:27+00:00", "question_id": "227473961d81c7fa871ac19f305a71b5be88c6bd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AndroidEnvironment {\n    private final static String ANDWORX_HOME_PATH = \"andworx\";\n\tprivate static final String ANDWORX_HOME_ERROR = \"Error creating Andworx home directory %s\";\n\tprivate static final String REPOSITORY_FOLDER = \"libraries\";\n\tprivate static final String DEFAULT_ANDROID_HOME = System.getProperty(\"user.dir\") + File.separator + AndroidLocation.FOLDER_DOT_ANDROID;\n\tprivate static class FailedTargetLoadStatus implements TargetLoadStatusMonitor {\n\t\t@Override\n\t\tpublic LoadStatus getLoadStatus(String hashString) {\n\t\t\treturn LoadStatus.FAILED;\n\t\t}\n\t\t\n\t}\n\t\n\t/** Location of the expanded AARs stored in a Maven repository structure */ \n\tprotected File repositoryLocation;\n\t/** Android's own home location */\n\tprotected File androidHome;\n\tprivate final ILogger logger;\n\tprotected TargetLoadStatusMonitor targetLoadStatusMonitor;\n\tpublic AndroidEnvironment(ILogger logger) {\n\t\tthis.logger = logger;\n\t\ttargetLoadStatusMonitor = new FailedTargetLoadStatus();\n\t}\n\t\n\t/**\n\t * Returns flag set true if Android SDK is available\n\t * @return boolean\n\t */\n\tpublic boolean isValid() {\n\t\treturn false;\n\t}\n\t/**\n\t * Returns the available Android targets (both Platform and Add-ons\n\t * @return Android target collection\n\t */\n\tpublic Collection<IAndroidTarget> getAndroidTargets() { \n\t\treturn Collections.emptyList();\n    }\n\t/**\n\t * Returns the location of the libraries repository within Android home\n\t * @return File object\n\t */\n\tpublic File getRepositoryLocation() {\n\t\tif (repositoryLocation == null)\n\t\t\trepositoryLocation = new File(getAndworxHome(), REPOSITORY_FOLDER);\n\t\treturn repositoryLocation;\n\t}\n\t/**\n\t * Returns Android SDK interface to {@link RepoManager}\n\t * @return AndroidSdkHandler object or null if not available\n\t */\n\t@Nullable\n\tpublic  AndroidSdkHandler getAndroidSdkHandler() {\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * Returns closest match Target Platform to given version\n\t * @param targetHash Target platform version specified as a hash string\n\t * @return IAndroidTarget object or null if none available\n\t */\n\t@Nullable\n\tpublic IAndroidTarget getAvailableTarget(String targetHash) {\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * Returns Android's own home location. \n\t * @return File object\n\t */\n\tpublic File getAndroidHome() {\n\t\tif (androidHome == null) {\n\t\t\ttry {\n        \t/* getFolder()\n\t\t     * Returns the folder used to store android related files.\n\t\t     * If the folder is not created yet, it will be created.\n\t\t     * @return an OS specific path, terminated by a separator.\n        \t */\n\t\t\tString androidHomeDir = AndroidLocation.getFolder();\n            androidHome = new File(androidHomeDir);\n            if (!androidHome.exists()) {\n            \tif (!androidHome.mkdirs())\n            \t\tthrow new IOException(String.format(\"Cannot create path %s\", androidHome.getAbsolutePath()));\n            } else if (!androidHome.isDirectory())\n        \t\tthrow new IOException(String.format(\"Path %s is not a directory\", androidHome.getAbsolutePath()));\n\t        } catch (AndroidLocationException | IOException | SecurityException e) {\n\t        \tlogger.error(e, \"Error finding Android home\");\n\t        \t// Apply default\n\t        \tandroidHome = new File(DEFAULT_ANDROID_HOME);\n\t        }\n\t\t}\n\t\treturn androidHome;\n\t}\n\t/**\n\t * Returns Andworx's own home location inside Android home\n\t * @return File object\n\t */\n\tpublic File getAndworxHome() {\n    \tFile androidHomeDir = getAndroidHome();\n        File andworxHomePath = new File(androidHomeDir, ANDWORX_HOME_PATH);\n    \tif (!andworxHomePath.exists()) {\n    \t\ttry {\n    \t\t\tandworxHomePath.mkdirs();\n    \t\t} catch (SecurityException t) {\n    \t\t\tlogger.error(t, ANDWORX_HOME_ERROR, andworxHomePath);\n    \t\t}\n    \t}\n    \tif (!andworxHomePath.exists()) \n    \t\tthrow new AndworxException(String.format(ANDWORX_HOME_ERROR, andworxHomePath));\n    \treturn andworxHomePath;\n    }\n\t\n\t/**\n\t * Return Signing Configuration\n\t * @return SigningConfig object\n\t */\n\tpublic SigningConfig getDefaultDebugSigningConfig() {\n\t\tFile keystoreFile = new File(getAndroidHome(), \"debug.keystore\");\n\t\tif (!keystoreFile.exists())\n\t\t\ttry {\n\t\t\t\tKeystoreHelper.createDebugStore(\n\t\t\t\t\tnull, \n\t\t\t\t\tkeystoreFile, \n\t\t\t\t\tDefaultSigningConfig.DEFAULT_PASSWORD, \n\t\t\t\t\tDefaultSigningConfig.DEFAULT_PASSWORD, \n\t\t\t\t\tDefaultSigningConfig.DEFAULT_ALIAS, \n\t\t\t\t\tlogger);\n\t\t\t} catch (KeytoolException e) {\n\t\t\t\tthrow new AndworxException(\"Error creating debug keystore \" + keystoreFile.toString(), e);\n\t\t\t}\n\t\treturn DefaultSigningConfig.debugSigningConfig(keystoreFile);\n\t}\n\t/**\n\t * Returns monitor which always return FAILED load status. Replace targetLoadStatusMonitor to return actual status.\n\t * @return TargetLoadStatusMonitor\n\t */\n\tpublic TargetLoadStatusMonitor getTargetLoadStatusMonitor() {\n\t\treturn targetLoadStatusMonitor;\n\t}\n"]]}
{"hexsha": "de5fec4d9cc696e0be03e836fcbbb68328e884fc", "ext": "java", "lang": "Java", "content": "public class ChangelogStateBackendHandleTest {\n\n    @Test\n    public void testPublicConstructor() {\n        long checkpointId = 2L;\n        long materializationID = 1L;\n        long size = 2L;\n        validateHandle(\n                checkpointId,\n                materializationID,\n                size,\n                new ChangelogStateBackendHandleImpl(\n                        emptyList(),\n                        emptyList(),\n                        KeyGroupRange.of(1, 2),\n                        checkpointId,\n                        materializationID,\n                        size));\n    }\n\n    @Test\n    public void testRestore() {\n        long checkpointId = 2L;\n        long materializationID = 1L;\n        long size = 2L;\n        validateHandle(\n                checkpointId,\n                materializationID,\n                size,\n                ChangelogStateBackendHandleImpl.restore(\n                        emptyList(),\n                        emptyList(),\n                        KeyGroupRange.of(1, 2),\n                        checkpointId,\n                        materializationID,\n                        size,\n                        randomStateHandleId()));\n    }\n\n    private void validateHandle(\n            long checkpointId,\n            long materializationID,\n            long size,\n            ChangelogStateBackendHandleImpl handle) {\n        assertEquals(checkpointId, handle.getCheckpointId());\n        assertEquals(materializationID, handle.getMaterializationID());\n        assertEquals(size, handle.getCheckpointedSize());\n    }\n}", "class_id": 0, "repo": "huyuanfeng2018/flink", "file": "flink-runtime/src/test/java/org/apache/flink/runtime/state/changelog/ChangelogStateBackendHandleTest.java", "last_update_at": "2019-11-30T03:07:29+00:00", "question_id": "de5fec4d9cc696e0be03e836fcbbb68328e884fc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ChangelogStateBackendHandleTest {\n    @Test\n    public void testPublicConstructor() {\n        long checkpointId = 2L;\n        long materializationID = 1L;\n        long size = 2L;\n        validateHandle(\n                checkpointId,\n                materializationID,\n                size,\n                new ChangelogStateBackendHandleImpl(\n                        emptyList(),\n                        emptyList(),\n                        KeyGroupRange.of(1, 2),\n                        checkpointId,\n                        materializationID,\n                        size));\n    }\n    @Test\n    public void testRestore() {\n        long checkpointId = 2L;\n        long materializationID = 1L;\n        long size = 2L;\n        validateHandle(\n                checkpointId,\n                materializationID,\n                size,\n                ChangelogStateBackendHandleImpl.restore(\n                        emptyList(),\n                        emptyList(),\n                        KeyGroupRange.of(1, 2),\n                        checkpointId,\n                        materializationID,\n                        size,\n                        randomStateHandleId()));\n    }\n    private void validateHandle(\n            long checkpointId,\n            long materializationID,\n            long size,\n            ChangelogStateBackendHandleImpl handle) {\n        assertEquals(checkpointId, handle.getCheckpointId());\n        assertEquals(materializationID, handle.getMaterializationID());\n        assertEquals(size, handle.getCheckpointedSize());\n    }\n"]]}
{"hexsha": "5ccc0c023bd1bb938c08a32d0d699772cd4311c3", "ext": "java", "lang": "Java", "content": "@Service\n@Transactional(readOnly = true)\npublic class LicenseClosureProcessflowService {\n\n    @Autowired\n    private SecurityUtils securityUtils;\n\n    @Autowired\n    private LicenseConfigurationService licenseConfigurationService;\n\n    @Autowired\n    private AssignmentService assignmentService;\n\n    @Autowired\n    private PositionMasterService positionMasterService;\n\n    @Autowired\n    private LicenseProcessWorkflowService licenseProcessWorkflowService;\n\n    @Autowired\n    @Qualifier(\"workflowService\")\n    private SimpleWorkflowService<TradeLicense> licenseWorkflowService;\n\n    @Autowired\n    private LicenseUtils licenseUtils;\n\n    @Autowired\n    private LicenseAppTypeService licenseAppTypeService;\n\n    public void startClosureProcessflow(TradeLicense license) {\n        if (securityUtils.currentUserIsEmployee()) {\n            startClosureProcessByEmployee(license);\n        } else {\n            startClosureProcessByExternalUsers(license);\n        }\n    }\n\n    private void startClosureProcessByEmployee(TradeLicense license) {\n        User currentUser = securityUtils.getCurrentUser();\n        List<Assignment> assignments = assignmentService.getAllActiveEmployeeAssignmentsByEmpId(currentUser.getId());\n        Position flowInitiator = assignments.get(0).getPosition();\n\n        WorkFlowMatrix workflowMatrix = getWorkFlowMatrix(license);\n        Position processOwner = positionMasterService.getPositionById(license.getWorkflowContainer().getApproverPositionId());\n        LicenseStateInfo licenseStateInfo = new LicenseStateInfo();\n        licenseStateInfo.setOldAppType(license.getLicenseAppType().getName());\n        if (workflowMatrix.isRejectEnabled() != null && workflowMatrix.isRejectEnabled())\n            licenseStateInfo.setRejectionPosition(processOwner.getId());\n\n        if (!license.hasState())\n            license.transition().start();\n        else\n            license.transition().startNext();\n\n        license.transition()\n                .withSLA(licenseUtils.getSlaForAppType(licenseAppTypeService.getClosureLicenseApplicationType()))\n                .withSenderName(currentUser.getName())\n                .withComments(license.getWorkflowContainer().getApproverComments())\n                .withStateValue(workflowMatrix.getNextState())\n                .withDateInfo(new Date())\n                .withOwner(processOwner)\n                .withNextAction(workflowMatrix.getNextAction())\n                .withExtraInfo(licenseStateInfo)\n                .withNatureOfTask(licenseAppTypeService.getLicenseAppTypeByCode(CLOSURE_APPTYPE_CODE).getName())\n                .withInitiator(flowInitiator);\n    }\n\n    private void startClosureProcessByExternalUsers(TradeLicense license) {\n        WorkFlowMatrix workflowMatrix = getWorkFlowMatrix(license);\n        List<Assignment> assignments = licenseProcessWorkflowService.getAssignments(workflowMatrix, license.getAdminWard());\n\n        Position processOwner = assignments.get(0).getPosition();\n        LicenseStateInfo licenseStateInfo = new LicenseStateInfo();\n        licenseStateInfo.setOldAppType(license.getLicenseAppType().getName());\n        if (workflowMatrix.isRejectEnabled() != null && workflowMatrix.isRejectEnabled())\n            licenseStateInfo.setRejectionPosition(processOwner.getId());\n\n        if (!license.hasState())\n            license.transition().start();\n\n        else\n            license.transition().startNext();\n\n        license.transition()\n                .withSLA(licenseUtils.getSlaForAppType(licenseAppTypeService.getClosureLicenseApplicationType()))\n                .withSenderName(securityUtils.getCurrentUser().getName())\n                .withComments(license.getWorkflowContainer().getApproverComments())\n                .withStateValue(workflowMatrix.getNextState())\n                .withDateInfo(new Date())\n                .withOwner(processOwner)\n                .withNextAction(workflowMatrix.getNextAction())\n                .withExtraInfo(licenseStateInfo)\n                .withNatureOfTask(licenseAppTypeService.getLicenseAppTypeByCode(CLOSURE_APPTYPE_CODE).getName())\n                .withInitiator(processOwner);\n    }\n\n    public void processCancellation(TradeLicense license) {\n        User currentUser = securityUtils.getCurrentUser();\n        license.transition().end()\n                .withSenderName(currentUser.getUsername() + DELIMITER_COLON + currentUser.getName())\n                .withComments(license.getWorkflowContainer().getApproverComments())\n                .withDateInfo(new Date())\n                .withNextAction(COMPLETED);\n    }\n\n    public void processApproval(TradeLicense license) {\n        license.getWorkflowContainer().setAdditionalRule(CLOSURE_ADDITIONAL_RULE);\n        WorkFlowMatrix workflowMatrix = getWorkFlowMatrix(license);\n        User currentUser = securityUtils.getCurrentUser();\n        license.transition().end()\n                .withSenderName(currentUser.getUsername() + DELIMITER_COLON + currentUser.getName())\n                .withComments(licenseConfigurationService.digitalSignEnabled() ? WF_DIGI_SIGNED : \"Approved\")\n                .withDateInfo(new Date())\n                .withStateValue(workflowMatrix.getNextState())\n                .withNextAction(COMPLETED);\n        license.setApprovedBy(currentUser);\n    }\n\n    public void processForward(TradeLicense license) {\n        User currentUser = securityUtils.getCurrentUser();\n        WorkFlowMatrix workflowMatrix = getWorkFlowMatrix(license);\n        LicenseStateInfo licenseStateInfo = license.extraInfo();\n        if (workflowMatrix.isRejectEnabled())\n            licenseStateInfo.setRejectionPosition(license.getCurrentState().getOwnerPosition().getId());\n\n        license.transition().progressWithStateCopy()\n                .withSenderName(currentUser.getUsername() + DELIMITER_COLON + currentUser.getName())\n                .withComments(license.getWorkflowContainer().getApproverComments())\n                .withStateValue(workflowMatrix.getNextState())\n                .withDateInfo(new Date())\n                .withOwner(positionMasterService.getPositionById(license.getWorkflowContainer().getApproverPositionId()))\n                .withNextAction(workflowMatrix.getNextAction())\n                .withExtraInfo(licenseStateInfo);\n    }\n\n    public void processRejection(TradeLicense license) {\n        User currentUser = securityUtils.getCurrentUser();\n        WorkFlowMatrix workflowMatrix = getWorkFlowMatrix(license);\n        LicenseStateInfo licenseStateInfo = license.extraInfo();\n        Position processOwner;\n        if (licenseStateInfo.getRejectionPosition() != null\n                && !licenseStateInfo.getRejectionPosition().equals(license.getCurrentState().getOwnerPosition().getId()))\n            processOwner = positionMasterService.getPositionById(licenseStateInfo.getRejectionPosition());\n        else\n            processOwner = license.getCurrentState().getInitiatorPosition();\n        license.transition().progressWithStateCopy()\n                .withSenderName(currentUser.getUsername() + DELIMITER_COLON + currentUser.getName())\n                .withComments(license.getWorkflowContainer().getApproverComments())\n                .withStateValue(workflowMatrix.getNextState())\n                .withDateInfo(new Date())\n                .withOwner(processOwner)\n                .withNextAction(workflowMatrix.getNextAction())\n                .withExtraInfo(licenseStateInfo);\n    }\n\n    public WorkFlowMatrix getWorkFlowMatrix(TradeLicense tradeLicense) {\n        WorkflowContainer workflowContainer = tradeLicense.getWorkflowContainer();\n        String additionalRule = BUTTONREJECT.equals(workflowContainer.getWorkFlowAction())\n                ? CLOSURE_LICENSE_REJECT : workflowContainer.getAdditionalRule();\n        WorkFlowMatrix workflowMatrix;\n        if (tradeLicense.transitionInprogress()) {\n            State<Position> state = tradeLicense.getState();\n            workflowMatrix = this.licenseWorkflowService.getWfMatrix(\n                    tradeLicense.getStateType(), \"ANY\", null, additionalRule,\n                    workflowContainer.getCurrentState() == null ? state.getValue() : workflowContainer.getCurrentState(),\n                    null, new Date(), workflowContainer.getCurrentDesignation() == null\n                            ? \"%\" + state.getOwnerPosition().getDeptDesig().getDesignation().getName() + \"%\" :\n                            workflowContainer.getCurrentDesignation());\n        } else {\n            workflowMatrix = this.licenseWorkflowService.getWfMatrix(tradeLicense.getStateType(), null,\n                    null, workflowContainer.getAdditionalRule(), \"Start\", null, new Date(), null);\n        }\n        return workflowMatrix;\n    }\n}", "class_id": 0, "repo": "getwasim/egov-smartcity-suites-test", "file": "egov/egov-tl/src/main/java/org/egov/tl/service/LicenseClosureProcessflowService.java", "last_update_at": "2019-07-25T12:44:57+00:00", "question_id": "5ccc0c023bd1bb938c08a32d0d699772cd4311c3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\n@Transactional(readOnly = true)\npublic class LicenseClosureProcessflowService {\n    @Autowired\n    private SecurityUtils securityUtils;\n    @Autowired\n    private LicenseConfigurationService licenseConfigurationService;\n    @Autowired\n    private AssignmentService assignmentService;\n    @Autowired\n    private PositionMasterService positionMasterService;\n    @Autowired\n    private LicenseProcessWorkflowService licenseProcessWorkflowService;\n    @Autowired\n    @Qualifier(\"workflowService\")\n    private SimpleWorkflowService<TradeLicense> licenseWorkflowService;\n    @Autowired\n    private LicenseUtils licenseUtils;\n    @Autowired\n    private LicenseAppTypeService licenseAppTypeService;\n    public void startClosureProcessflow(TradeLicense license) {\n        if (securityUtils.currentUserIsEmployee()) {\n            startClosureProcessByEmployee(license);\n        } else {\n            startClosureProcessByExternalUsers(license);\n        }\n    }\n    private void startClosureProcessByEmployee(TradeLicense license) {\n        User currentUser = securityUtils.getCurrentUser();\n        List<Assignment> assignments = assignmentService.getAllActiveEmployeeAssignmentsByEmpId(currentUser.getId());\n        Position flowInitiator = assignments.get(0).getPosition();\n        WorkFlowMatrix workflowMatrix = getWorkFlowMatrix(license);\n        Position processOwner = positionMasterService.getPositionById(license.getWorkflowContainer().getApproverPositionId());\n        LicenseStateInfo licenseStateInfo = new LicenseStateInfo();\n        licenseStateInfo.setOldAppType(license.getLicenseAppType().getName());\n        if (workflowMatrix.isRejectEnabled() != null && workflowMatrix.isRejectEnabled())\n            licenseStateInfo.setRejectionPosition(processOwner.getId());\n        if (!license.hasState())\n            license.transition().start();\n        else\n            license.transition().startNext();\n        license.transition()\n                .withSLA(licenseUtils.getSlaForAppType(licenseAppTypeService.getClosureLicenseApplicationType()))\n                .withSenderName(currentUser.getName())\n                .withComments(license.getWorkflowContainer().getApproverComments())\n                .withStateValue(workflowMatrix.getNextState())\n                .withDateInfo(new Date())\n                .withOwner(processOwner)\n                .withNextAction(workflowMatrix.getNextAction())\n                .withExtraInfo(licenseStateInfo)\n                .withNatureOfTask(licenseAppTypeService.getLicenseAppTypeByCode(CLOSURE_APPTYPE_CODE).getName())\n                .withInitiator(flowInitiator);\n    }\n    private void startClosureProcessByExternalUsers(TradeLicense license) {\n        WorkFlowMatrix workflowMatrix = getWorkFlowMatrix(license);\n        List<Assignment> assignments = licenseProcessWorkflowService.getAssignments(workflowMatrix, license.getAdminWard());\n        Position processOwner = assignments.get(0).getPosition();\n        LicenseStateInfo licenseStateInfo = new LicenseStateInfo();\n        licenseStateInfo.setOldAppType(license.getLicenseAppType().getName());\n        if (workflowMatrix.isRejectEnabled() != null && workflowMatrix.isRejectEnabled())\n            licenseStateInfo.setRejectionPosition(processOwner.getId());\n        if (!license.hasState())\n            license.transition().start();\n        else\n            license.transition().startNext();\n        license.transition()\n                .withSLA(licenseUtils.getSlaForAppType(licenseAppTypeService.getClosureLicenseApplicationType()))\n                .withSenderName(securityUtils.getCurrentUser().getName())\n                .withComments(license.getWorkflowContainer().getApproverComments())\n                .withStateValue(workflowMatrix.getNextState())\n                .withDateInfo(new Date())\n                .withOwner(processOwner)\n                .withNextAction(workflowMatrix.getNextAction())\n                .withExtraInfo(licenseStateInfo)\n                .withNatureOfTask(licenseAppTypeService.getLicenseAppTypeByCode(CLOSURE_APPTYPE_CODE).getName())\n                .withInitiator(processOwner);\n    }\n    public void processCancellation(TradeLicense license) {\n        User currentUser = securityUtils.getCurrentUser();\n        license.transition().end()\n                .withSenderName(currentUser.getUsername() + DELIMITER_COLON + currentUser.getName())\n                .withComments(license.getWorkflowContainer().getApproverComments())\n                .withDateInfo(new Date())\n                .withNextAction(COMPLETED);\n    }\n    public void processApproval(TradeLicense license) {\n        license.getWorkflowContainer().setAdditionalRule(CLOSURE_ADDITIONAL_RULE);\n        WorkFlowMatrix workflowMatrix = getWorkFlowMatrix(license);\n        User currentUser = securityUtils.getCurrentUser();\n        license.transition().end()\n                .withSenderName(currentUser.getUsername() + DELIMITER_COLON + currentUser.getName())\n                .withComments(licenseConfigurationService.digitalSignEnabled() ? WF_DIGI_SIGNED : \"Approved\")\n                .withDateInfo(new Date())\n                .withStateValue(workflowMatrix.getNextState())\n                .withNextAction(COMPLETED);\n        license.setApprovedBy(currentUser);\n    }\n    public void processForward(TradeLicense license) {\n        User currentUser = securityUtils.getCurrentUser();\n        WorkFlowMatrix workflowMatrix = getWorkFlowMatrix(license);\n        LicenseStateInfo licenseStateInfo = license.extraInfo();\n        if (workflowMatrix.isRejectEnabled())\n            licenseStateInfo.setRejectionPosition(license.getCurrentState().getOwnerPosition().getId());\n        license.transition().progressWithStateCopy()\n                .withSenderName(currentUser.getUsername() + DELIMITER_COLON + currentUser.getName())\n                .withComments(license.getWorkflowContainer().getApproverComments())\n                .withStateValue(workflowMatrix.getNextState())\n                .withDateInfo(new Date())\n                .withOwner(positionMasterService.getPositionById(license.getWorkflowContainer().getApproverPositionId()))\n                .withNextAction(workflowMatrix.getNextAction())\n                .withExtraInfo(licenseStateInfo);\n    }\n    public void processRejection(TradeLicense license) {\n        User currentUser = securityUtils.getCurrentUser();\n        WorkFlowMatrix workflowMatrix = getWorkFlowMatrix(license);\n        LicenseStateInfo licenseStateInfo = license.extraInfo();\n        Position processOwner;\n        if (licenseStateInfo.getRejectionPosition() != null\n                && !licenseStateInfo.getRejectionPosition().equals(license.getCurrentState().getOwnerPosition().getId()))\n            processOwner = positionMasterService.getPositionById(licenseStateInfo.getRejectionPosition());\n        else\n            processOwner = license.getCurrentState().getInitiatorPosition();\n        license.transition().progressWithStateCopy()\n                .withSenderName(currentUser.getUsername() + DELIMITER_COLON + currentUser.getName())\n                .withComments(license.getWorkflowContainer().getApproverComments())\n                .withStateValue(workflowMatrix.getNextState())\n                .withDateInfo(new Date())\n                .withOwner(processOwner)\n                .withNextAction(workflowMatrix.getNextAction())\n                .withExtraInfo(licenseStateInfo);\n    }\n    public WorkFlowMatrix getWorkFlowMatrix(TradeLicense tradeLicense) {\n        WorkflowContainer workflowContainer = tradeLicense.getWorkflowContainer();\n        String additionalRule = BUTTONREJECT.equals(workflowContainer.getWorkFlowAction())\n                ? CLOSURE_LICENSE_REJECT : workflowContainer.getAdditionalRule();\n        WorkFlowMatrix workflowMatrix;\n        if (tradeLicense.transitionInprogress()) {\n            State<Position> state = tradeLicense.getState();\n            workflowMatrix = this.licenseWorkflowService.getWfMatrix(\n                    tradeLicense.getStateType(), \"ANY\", null, additionalRule,\n                    workflowContainer.getCurrentState() == null ? state.getValue() : workflowContainer.getCurrentState(),\n                    null, new Date(), workflowContainer.getCurrentDesignation() == null\n                            ? \"%\" + state.getOwnerPosition().getDeptDesig().getDesignation().getName() + \"%\" :\n                            workflowContainer.getCurrentDesignation());\n        } else {\n            workflowMatrix = this.licenseWorkflowService.getWfMatrix(tradeLicense.getStateType(), null,\n                    null, workflowContainer.getAdditionalRule(), \"Start\", null, new Date(), null);\n        }\n        return workflowMatrix;\n    }\n"]]}
{"hexsha": "4dcc551b3414ab7a0a365230495cc946a24752b9", "ext": "java", "lang": "Java", "content": "public class T4777949 {\n    public static void main(String... args) throws Exception {\n        new T4777949().run();\n    }\n\n    void run() throws Exception {\n        File javaFile = writeTestFile();\n        File classFile = compileTestFile(javaFile);\n\n        test(\".\", \"p.q.r.Test\", false);\n        test(\"p\", \"q.r.Test\", true);\n        test(\"p/q\", \"r.Test\", true);\n        test(\"p/q/r\", \"Test\", true);\n        test(\".\", \"p.q.r.Test.Inner\", false);\n        test(\".\", \"p.q.r.Test$Inner\", false);\n        test(\"p\", \"q.r.Test.Inner\", true);\n        test(\"p\", \"q.r.Test$Inner\", true);\n\n        if (errors > 0)\n            throw new Exception(errors + \" errors found\");\n    }\n\n    void test(String classPath, String className, boolean expectWarnings) {\n        List<Diagnostic<? extends JavaFileObject>> diags =\n            javap(Arrays.asList(\"-classpath\", classPath), Arrays.asList(className));\n        boolean foundWarnings = false;\n        for (Diagnostic<? extends JavaFileObject> d: diags) {\n            if (d.getKind() == Diagnostic.Kind.WARNING)\n                foundWarnings = true;\n        }\n    }\n\n\n    File writeTestFile() throws IOException {\n        File f = new File(\"Test.java\");\n        PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(f)));\n        out.println(\"package p.q.r;\");\n        out.println(\"class Test { class Inner { } }\");\n        out.close();\n        return f;\n    }\n\n    File compileTestFile(File f) {\n        int rc = com.sun.tools.javac.Main.compile(new String[] { \"-d\", \".\", f.getPath() });\n        if (rc != 0)\n            throw new Error(\"compilation failed. rc=\" + rc);\n        String path = f.getPath();\n        return new File(path.substring(0, path.length() - 5) + \".class\");\n    }\n\n    List<Diagnostic<? extends JavaFileObject>> javap(List<String> args, List<String> classes) {\n        DiagnosticCollector<JavaFileObject> dc = new DiagnosticCollector<JavaFileObject>();\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n        JavaFileManager fm = JavapFileManager.create(dc, pw);\n        JavapTask t = new JavapTask(pw, fm, dc, args, classes);\n        boolean ok = t.run();\n\n        List<Diagnostic<? extends JavaFileObject>> diags = dc.getDiagnostics();\n\n        if (!ok)\n            error(\"javap failed unexpectedly\");\n\n        System.err.println(\"args=\" + args + \" classes=\" + classes + \"\\n\"\n                           + diags + \"\\n\"\n                           + sw);\n\n        return diags;\n    }\n\n    void error(String msg) {\n        System.err.println(\"error: \" + msg);\n        errors++;\n    }\n\n    int errors;\n}", "class_id": 0, "repo": "SoftwareEngineeringToolDemos/type-inference", "file": "inference-framework/jsr308-langtools/test/tools/javap/T4777949.java", "last_update_at": "2019-12-07T16:13:03+00:00", "question_id": "4dcc551b3414ab7a0a365230495cc946a24752b9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class T4777949 {\n    public static void main(String... args) throws Exception {\n        new T4777949().run();\n    }\n    void run() throws Exception {\n        File javaFile = writeTestFile();\n        File classFile = compileTestFile(javaFile);\n        test(\".\", \"p.q.r.Test\", false);\n        test(\"p\", \"q.r.Test\", true);\n        test(\"p/q\", \"r.Test\", true);\n        test(\"p/q/r\", \"Test\", true);\n        test(\".\", \"p.q.r.Test.Inner\", false);\n        test(\".\", \"p.q.r.Test$Inner\", false);\n        test(\"p\", \"q.r.Test.Inner\", true);\n        test(\"p\", \"q.r.Test$Inner\", true);\n        if (errors > 0)\n            throw new Exception(errors + \" errors found\");\n    }\n    void test(String classPath, String className, boolean expectWarnings) {\n        List<Diagnostic<? extends JavaFileObject>> diags =\n            javap(Arrays.asList(\"-classpath\", classPath), Arrays.asList(className));\n        boolean foundWarnings = false;\n        for (Diagnostic<? extends JavaFileObject> d: diags) {\n            if (d.getKind() == Diagnostic.Kind.WARNING)\n                foundWarnings = true;\n        }\n    }\n    File writeTestFile() throws IOException {\n        File f = new File(\"Test.java\");\n        PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(f)));\n        out.println(\"package p.q.r;\");\n        out.println(\"class Test { class Inner { } }\");\n        out.close();\n        return f;\n    }\n    File compileTestFile(File f) {\n        int rc = com.sun.tools.javac.Main.compile(new String[] { \"-d\", \".\", f.getPath() });\n        if (rc != 0)\n            throw new Error(\"compilation failed. rc=\" + rc);\n        String path = f.getPath();\n        return new File(path.substring(0, path.length() - 5) + \".class\");\n    }\n    List<Diagnostic<? extends JavaFileObject>> javap(List<String> args, List<String> classes) {\n        DiagnosticCollector<JavaFileObject> dc = new DiagnosticCollector<JavaFileObject>();\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n        JavaFileManager fm = JavapFileManager.create(dc, pw);\n        JavapTask t = new JavapTask(pw, fm, dc, args, classes);\n        boolean ok = t.run();\n        List<Diagnostic<? extends JavaFileObject>> diags = dc.getDiagnostics();\n        if (!ok)\n            error(\"javap failed unexpectedly\");\n        System.err.println(\"args=\" + args + \" classes=\" + classes + \"\\n\"\n                           + diags + \"\\n\"\n                           + sw);\n        return diags;\n    }\n    void error(String msg) {\n        System.err.println(\"error: \" + msg);\n        errors++;\n    }\n    int errors;\n"]]}
{"hexsha": "2690577af099a835ff2c35af294eb925114821bc", "ext": "java", "lang": "Java", "content": "public class ModelServiceLoader {\n\n    /**\n     * Liefert eine Liste mit allen Algorithmen, die das {@code AdaptationAlgorithm}-Interface implementieren.\n     *\n     * @return eine Liste mit allen Adaptionsalgorithmen\n     */\n    public Collection<AdaptationAlgorithm> getAdaptAlgorithmList() {\n        ArrayList<AdaptationAlgorithm> list = new ArrayList<>();\n        ServiceLoader.load(AdaptationAlgorithm.class).iterator().forEachRemaining(list::add);\n        return list;\n    }\n\n    /**\n     * Liefert eine Liste mit allen Algorithmen, die das {@code PairingAlgorithm}-Interface implementieren.\n     *\n     * @return eine Liste mit allen Paarungsalgorithmen\n     */\n    public Collection<PairingAlgorithm> getPairAlgorithmList() {\n        ArrayList<PairingAlgorithm> list = new ArrayList<>();\n        ServiceLoader.load(PairingAlgorithm.class).iterator().forEachRemaining(list::add);\n        return list;\n    }\n\n    /**\n     * Liefert eine Liste mit allen Algorithmen, die das {@code RankingAlgorithm}-Interface implementieren.\n     *\n     * @return eine Liste mit allen Bewertungsalgorithmen\n     */\n    public Collection<RankingAlgorithm> getRankAlgorithmList() {\n        ArrayList<RankingAlgorithm> list = new ArrayList<>();\n        ServiceLoader.load(RankingAlgorithm.class).iterator().forEachRemaining(list::add);\n        return list;\n    }\n\n    /**\n     * Liefert eine Liste mit allen Bedingungen, die das {@code Condition}-Interface implementieren.\n     *\n     * @return eine Liste mit allen Bedingungen\n     */\n    public Collection<Condition> getConditionList() {\n        ArrayList<Condition> list = new ArrayList<>();\n        ServiceLoader.load(Condition.class).iterator().forEachRemaining(list::add);\n        return list;\n    }\n\n    /**\n     * Liefert eine Liste mit allen Strategien, die das {@code BaseStrategy}-Interface implementieren.\n     *\n     * @return eine Liste mit allen Basis-Strategien\n     */\n    public Collection<BaseStrategy> getBaseStrategyList() {\n        ArrayList<BaseStrategy> list = new ArrayList<>();\n        ServiceLoader.load(BaseStrategy.class).iterator().forEachRemaining(list::add);\n        return list;\n    }\n\n}", "class_id": 0, "repo": "max-97/pse", "file": "Implementierung/src/main/java/de/sswis/controller/ModelServiceLoader.java", "last_update_at": "2019-03-03T20:27:18+00:00", "question_id": "2690577af099a835ff2c35af294eb925114821bc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ModelServiceLoader {\n    /**\n     * Liefert eine Liste mit allen Algorithmen, die das {@code AdaptationAlgorithm}-Interface implementieren.\n     *\n     * @return eine Liste mit allen Adaptionsalgorithmen\n     */\n    public Collection<AdaptationAlgorithm> getAdaptAlgorithmList() {\n        ArrayList<AdaptationAlgorithm> list = new ArrayList<>();\n        ServiceLoader.load(AdaptationAlgorithm.class).iterator().forEachRemaining(list::add);\n        return list;\n    }\n    /**\n     * Liefert eine Liste mit allen Algorithmen, die das {@code PairingAlgorithm}-Interface implementieren.\n     *\n     * @return eine Liste mit allen Paarungsalgorithmen\n     */\n    public Collection<PairingAlgorithm> getPairAlgorithmList() {\n        ArrayList<PairingAlgorithm> list = new ArrayList<>();\n        ServiceLoader.load(PairingAlgorithm.class).iterator().forEachRemaining(list::add);\n        return list;\n    }\n    /**\n     * Liefert eine Liste mit allen Algorithmen, die das {@code RankingAlgorithm}-Interface implementieren.\n     *\n     * @return eine Liste mit allen Bewertungsalgorithmen\n     */\n    public Collection<RankingAlgorithm> getRankAlgorithmList() {\n        ArrayList<RankingAlgorithm> list = new ArrayList<>();\n        ServiceLoader.load(RankingAlgorithm.class).iterator().forEachRemaining(list::add);\n        return list;\n    }\n    /**\n     * Liefert eine Liste mit allen Bedingungen, die das {@code Condition}-Interface implementieren.\n     *\n     * @return eine Liste mit allen Bedingungen\n     */\n    public Collection<Condition> getConditionList() {\n        ArrayList<Condition> list = new ArrayList<>();\n        ServiceLoader.load(Condition.class).iterator().forEachRemaining(list::add);\n        return list;\n    }\n    /**\n     * Liefert eine Liste mit allen Strategien, die das {@code BaseStrategy}-Interface implementieren.\n     *\n     * @return eine Liste mit allen Basis-Strategien\n     */\n    public Collection<BaseStrategy> getBaseStrategyList() {\n        ArrayList<BaseStrategy> list = new ArrayList<>();\n        ServiceLoader.load(BaseStrategy.class).iterator().forEachRemaining(list::add);\n        return list;\n    }\n"]]}
{"hexsha": "41b8a5b94cbecdbe407aa42e43b737e27fd5674b", "ext": "java", "lang": "Java", "content": "public class HalfSigmoidValueTransformer implements ValueTransformer<Double> {\n    private double _center;\n    private double _scale;\n\n    public HalfSigmoidValueTransformer (double min, double expectedMax) {\n        _center = min;\n        _scale = expectedMax;\n    }\n\n    @Override\n    public Double transform (Double value) {\n        double scaledInput = (value-_center) / (_scale - _center);\n\n        // We only care about the top half.\n        return (1/(1+Math.exp(-scaledInput)))*2.0-1.0;\n    }\n\n    @Override\n    public Double getMaximumValue () {\n        return 1.0;\n    }\n}", "class_id": 0, "repo": "RilaShu/spatio-temporal-visualization-of-massive-web-map-logs", "file": "tile-rendering/src/main/java/com/oculusinfo/tile/rendering/transformations/value/HalfSigmoidValueTransformer.java", "last_update_at": "2019-06-13T02:29:45+00:00", "question_id": "41b8a5b94cbecdbe407aa42e43b737e27fd5674b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HalfSigmoidValueTransformer implements ValueTransformer<Double> {\n    private double _center;\n    private double _scale;\n    public HalfSigmoidValueTransformer (double min, double expectedMax) {\n        _center = min;\n        _scale = expectedMax;\n    }\n    @Override\n    public Double transform (Double value) {\n        double scaledInput = (value-_center) / (_scale - _center);\n        // We only care about the top half.\n        return (1/(1+Math.exp(-scaledInput)))*2.0-1.0;\n    }\n    @Override\n    public Double getMaximumValue () {\n        return 1.0;\n    }\n"]]}
{"hexsha": "20b41f9c57389d10ff16393c30505513d995ad2c", "ext": "java", "lang": "Java", "content": "public class OverlayHelpTreeTest {\n\n\t@Test\n    public void testSourceTOCFileThatDependsUponPreBuiltHelp() {\n\t\t//\n\t\t// We want to make sure the overlay tree will properly resolve help TOC items being \n\t\t// built from TOC_Source.xml files when that file uses <TOCREF> items that are defined\n\t\t// in a help <TOCITEM> that lives inside of a pre-built jar file.\n\t\t//\n\t\t/*\n\t\t \n\t\t \tExample makeup we will create:\n\t\t \n\t\t\t  \tPreBuild_TOC.xml\n\t\t\t  \t\n\t\t\t  \t\t<tocitem id=\"root\" target=\"fake\">\n\t\t\t  \t\t\t<tocitem id=\"child_1\" target=\"fake\" />\n\t\t\t  \t\t</tocitem>\n\t\t\t \n\t\t\t \n\t\t\t \tTOC_Source.xml \n\t\t\t \t\n\t\t\t \t\t<tocref id=\"root\">\n\t\t\t \t\t\t<tocref=\"child_1\">\n\t\t\t \t\t\t\t<tocdef id=\"child_2\" target=\"fake\" />\n\t\t\t \t\t\t</tocref>\n\t\t\t \t\t</tocref>\n\t\t  \n\t\t */\n\n\t\tTOCItemExternal root = externalItem(\"root\");\n\t\tTOCItemExternal child_1 = externalItem(root, \"child_1\");\n\n\t\tPath tocSourceFile = Paths.get(\"/fake/path_2/TOC_Source.xml\");\n\t\tString root_ID = root.getIDAttribute();\n\t\tTOCItemReference root_ref = referenceItem(root_ID, tocSourceFile);\n\n\t\tString child_1_ID = child_1.getIDAttribute();\n\t\tTOCItemReference child_1_ref = referenceItem(root_ref, child_1_ID, tocSourceFile);\n\n\t\tTOCItemDefinition child_2 = definitionItem(child_1_ref, \"child_2\", tocSourceFile);\n\n\t\tTOCItemProviderTestStub tocProvider = new TOCItemProviderTestStub();\n\t\ttocProvider.addExternal(root);\n\t\ttocProvider.addExternal(child_1);\n\t\ttocProvider.addDefinition(child_2);\n\n\t\tTOCSpyWriter spy = printOverlayTree(tocProvider, tocSourceFile);\n\n\t\tassertNodeCount(spy, 3);\n\t\tassertOrder(spy, 1, root);\n\t\tassertOrder(spy, 2, child_1);\n\t\tassertOrder(spy, 3, child_2);\n\t}\n\n\t@Test\n    public void testSourceTOCFileThatDependsUponPreBuiltHelp_MultiplePreBuiltInputs() {\n\t\t//\n\t\t// We want to make sure the overlay tree will properly resolve help TOC items being \n\t\t// built from TOC_Source.xml files when that file uses <TOCREF> items that are defined\n\t\t// in a help <TOCITEM> that lives inside of multiple pre-built jar files.\n\t\t//\n\t\t/*\n\t\t \n\t\t \tExample makeup we will create:\n\t\t \n\t\t\t  \tPreBuild_TOC.xml\n\t\t\t  \t\n\t\t\t  \t\t<tocitem id=\"root\" target=\"fake\">\n\t\t\t  \t\t\t<tocitem id=\"child_1\" target=\"fake\">\n\t\t\t  \t\t\t\t<tocitem=\"prebuilt_a_child\" target=\"fake\" />\n\t\t\t  \t\t\t</tocitem>\n\t\t\t  \t\t</tocitem>\n\t\t\t \n\t\t\t\tAnother PreBuild_TOC.xml\n\t\t\t  \t\n\t\t\t  \t\t<tocitem id=\"root\" target=\"fake\">\n\t\t\t  \t\t\t<tocitem id=\"child_1\" target=\"fake\">\n\t\t\t  \t\t\t\t<tocitem=\"prebuilt_b_child\" target=\"fake\" />\n\t\t\t  \t\t\t</tocitem>\n\t\t\t  \t\t</tocitem>\n\t\t\t \n\t\t\t \n\t\t\t \tTOC_Source.xml \n\t\t\t \t\n\t\t\t \t\t<tocref id=\"root\">\n\t\t\t \t\t\t<tocref=\"child_1\">\n\t\t\t \t\t\t\t<tocdef id=\"child_2\" target=\"fake\" />\n\t\t\t \t\t\t</tocref>\n\t\t\t \t\t</tocref>\n\t\t  \n\t\t */\n\n\t\tTOCItemExternal root_a = externalItem(\"root\");\n\t\tTOCItemExternal child_1_a = externalItem(root_a, \"child_1\");\n\t\tTOCItemExternal prebuilt_a_child = externalItem(child_1_a, \"prebuilt_a_child\");\n\n\t\t// note: same ID values, since they represent the same nodes, but from different TOC files\n\t\tTOCItemExternal root_b = externalItemAlt(null, \"root\");\n\t\tTOCItemExternal child_1_b = externalItemAlt(root_b, \"child_1\");\n\t\tTOCItemExternal prebuilt_b_child = externalItemAlt(child_1_b, \"prebuilt_b_child\");\n\n\t\tPath tocSourceFile = Paths.get(\"/fake/path_2/TOC_Source.xml\");\n\t\tString root_ID = root_a.getIDAttribute();\n\t\tTOCItemReference root_ref = referenceItem(root_ID, tocSourceFile);\n\n\t\tString child_1_ID = child_1_a.getIDAttribute();\n\t\tTOCItemReference child_1_ref = referenceItem(root_ref, child_1_ID, tocSourceFile);\n\n\t\tTOCItemDefinition child_2 = definitionItem(child_1_ref, \"child_2\", tocSourceFile);\n\n\t\tTOCItemProviderTestStub tocProvider = new TOCItemProviderTestStub();\n\t\ttocProvider.addExternal(root_a);\n\t\ttocProvider.addExternal(root_b);\n\t\ttocProvider.addExternal(child_1_a);\n\t\ttocProvider.addExternal(child_1_b);\n\t\ttocProvider.addExternal(prebuilt_a_child);\n\t\ttocProvider.addExternal(prebuilt_b_child);\n\t\ttocProvider.addDefinition(child_2);\n\n\t\tTOCSpyWriter spy = printOverlayTree(tocProvider, tocSourceFile);\n\n\t\tassertNodeCount(spy, 3);\n\t\tassertOrder(spy, 1, root_a);// could also be root_b, same ID\n\t\tassertOrder(spy, 2, child_1_a);// could also be child_1_b, same ID\n\t\tassertOrder(spy, 3, child_2);\n\n\t\t// note: prebuilt_a_child and prebuilt_b_child don't get output, since they do not have \n\t\t//       the same TOC file ID as the help file being processed (in other words, they don't\n\t\t//       live in the TOC_Source.xml being processes, so they are not part of the output).\n\t}\n\n\t@Test\n    public void testSourceTOCFileThatDependsAnotherTOCSourceFile() {\n\n\t\t/*\n\t\t \n\t\t The first source file defines attributes that the second file references.\n\t\t \n\t\t Example makeup we will create:\n\t\t\n\t\t  \tTOC_Source.xml\n\t\t  \t\n\t\t  \t\t<tocdef id=\"root\" target=\"fake\">\n\t\t  \t\t\t<tocdef id=\"child_1\" target=\"fake\" />\n\t\t  \t\t</tocdef>\n\t\t \n\t\t \n\t\t \tAnother TOC_Source.xml \n\t\t \t\n\t\t \t\t<tocref id=\"root\">\n\t\t \t\t\t<tocref=\"child_1\">\n\t\t \t\t\t\t<tocdef id=\"child_2\" target=\"fake\" />\n\t\t \t\t\t</tocref>\n\t\t \t\t</tocref>\n\t\t\n\t\t*/\n\n\t\tPath toc_1 = Paths.get(\"/fake/path_1/TOC_Source.xml\");\n\t\tTOCItemDefinition root = definitionItem(\"root\", toc_1);\n\t\tTOCItemDefinition child_1 = definitionItem(root, \"child_1\", toc_1);\n\n\t\tPath toc_2 = Paths.get(\"/fake/path_2/TOC_Source.xml\");\n\t\tString root_ID = root.getIDAttribute();\n\t\tString child_1_ID = child_1.getIDAttribute();\n\n\t\tTOCItemReference root_ref = referenceItem(root_ID, toc_2);\n\t\tTOCItemReference child_1_ref = referenceItem(root_ref, child_1_ID, toc_2);\n\t\tTOCItemDefinition child_2 = definitionItem(child_1_ref, \"child_2\", toc_2);\n\n\t\tTOCItemProviderTestStub tocProvider = new TOCItemProviderTestStub();\n\t\ttocProvider.addDefinition(root);\n\t\ttocProvider.addDefinition(child_1);\n\t\ttocProvider.addDefinition(child_2);// in the second TOC file\n\n\t\tTOCSpyWriter spy = printOverlayTree(tocProvider, toc_2);\n\n\t\tassertNodeCount(spy, 3);\n\t\tassertOrder(spy, 1, root);\n\t\tassertOrder(spy, 2, child_1);\n\t\tassertOrder(spy, 3, child_2);\n\t}\n\n//==================================================================================================\n// Inner Classes\n//==================================================================================================\n\n\tprivate TOCSpyWriter printOverlayTree(TOCItemProviderTestStub tocItemProvider, Path tocFile) {\n\n\t\t//\n\t\t// Create a test version of the LinkDatabase for the overlay tree, with test versions of\n\t\t// it's required TOC input file and HelpModuleLocation\n\t\t// \n\t\tGhidraTOCFileDummy toc = new GhidraTOCFileDummy(tocFile);\n\t\tOverlayHelpModuleLocationTestStub location = new OverlayHelpModuleLocationTestStub(toc);\n\t\tLinkDatabaseTestStub db = new LinkDatabaseTestStub(location);\n\n\t\t// This is the class we are testing!!\n\t\tOverlayHelpTree overlayHelpTree = new OverlayHelpTree(tocItemProvider, db);\n\n\t\tTOCSpyWriter spy = new TOCSpyWriter();\n\t\tString TOCID = tocFile.toUri().toString();\n\t\toverlayHelpTree.printTreeForID(spy, TOCID);\n\n\t\tSystem.out.println(spy.toString());\n\n\t\treturn spy;\n\t}\n\n\tprivate TOCItemDefinition definitionItem(String ID, Path tocSourceFile) {\n\t\treturn definitionItem(null, ID, tocSourceFile);\n\t}\n\n\tprivate TOCItemDefinition definitionItem(TOCItem parent, String ID, Path tocSourceFile) {\n\t\tString target = \"fake\";\n\t\tString sort = \"\";\n\t\tint line = 1;\n\t\treturn new TOCItemDefinition(parent, tocSourceFile, ID, ID, target, sort, line);\n\t}\n\n\tprivate TOCItemReference referenceItem(String referenceID, Path tocSourceFile) {\n\t\treturn referenceItem(null, referenceID, tocSourceFile);\n\t}\n\n\tprivate TOCItemReference referenceItem(TOCItem parent, String referenceID, Path tocSourceFile) {\n\t\treturn new TOCItemReference(parent, tocSourceFile, referenceID, 1);\n\t}\n\n\tprivate TOCItemExternal externalItem(String ID) {\n\t\treturn externalItem(null, ID);\n\t}\n\n\tprivate TOCItemExternal externalItem(TOCItem parent, String ID) {\n\t\tPath tocFile = Paths.get(\"/fake/path_1/PreBuild_TOC.xml\");\n\t\tString target = \"fake\";\n\t\tString sort = \"\";\n\t\tint line = 1;\n\t\treturn new TOCItemExternal(parent, tocFile, ID, ID, target, sort, line);\n\t}\n\n\tprivate TOCItemExternal externalItemAlt(TOCItem parent, String ID) {\n\t\tPath tocFile = Paths.get(\"/fake/path_1/PreBuild_TOC.xml\");\n\t\tString target = \"fake\";\n\t\tString sort = \"\";\n\t\tint line = 1;\n\t\treturn new TOCItemExternal(parent, tocFile, ID, ID, target, sort, line);\n\t}\n\n\tprivate void assertOrder(TOCSpyWriter spy, int ordinal, TOCItem item) {\n\t\tString ID = spy.getItem(ordinal - 1 /* make an index */);\n\t\tassertEquals(\"Did not find TOC item at expected index: \" + ordinal, item.getIDAttribute(),\n\t\t\tID);\n\t}\n\n\tprivate void assertNodeCount(TOCSpyWriter spy, int count) {\n\t\tassertEquals(\"Did not get exactly one node per TOC item input\", count, spy.getItemCount());\n\t}\n\n\tprivate class TOCSpyWriter extends PrintWriter {\n\n\t\tprivate StringWriter stringWriter;\n\n\t\tprivate List<String> tocItems = new ArrayList<>();\n\n\t\tpublic TOCSpyWriter() {\n\t\t\tsuper(new StringWriter(), true);\n\t\t\tstringWriter = ((StringWriter) out);\n\t\t}\n\n\t\tString getItem(int position) {\n\t\t\treturn tocItems.get(position);\n\t\t}\n\n\t\tint getItemCount() {\n\t\t\treturn tocItems.size();\n\t\t}\n\n\t\t@Override\n\t\tpublic void println(String s) {\n\t\t\tsuper.println(s);\n\n\t\t\ts = s.trim();\n\t\t\tif (!s.startsWith(\"<tocitem\")) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstoreDisplayAttribute(s);\n\t\t}\n\n\t\tprivate void storeDisplayAttribute(String s) {\n\t\t\t// create a pattern to pull out the display string\n\t\t\tPattern p = Pattern.compile(\".*display=\\\"(.*)\\\" toc_id.*\");\n\t\t\tMatcher matcher = p.matcher(s.trim());\n\n\t\t\tif (!matcher.matches()) {\n\t\t\t\treturn;// not a TOC item\n\t\t\t}\n\n\t\t\tString value = matcher.group(1);\n\t\t\ttocItems.add(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn stringWriter.getBuffer().toString();\n\t\t}\n\t}\n\n\tprivate class TOCItemProviderTestStub implements TOCItemProvider {\n\n\t\tMap<String, TOCItemExternal> externals = new HashMap<>();\n\t\tMap<String, TOCItemDefinition> definitions = new HashMap<>();\n\n\t\tvoid addExternal(TOCItemExternal item) {\n\t\t\tString displayText = item.getIDAttribute();\n\t\t\texternals.put(displayText, item);\n\t\t}\n\n\t\tvoid addDefinition(TOCItemDefinition item) {\n\t\t\tString ID = item.getIDAttribute();\n\t\t\tdefinitions.put(ID, item);\n\t\t}\n\n\t\t@Override\n\t\tpublic Map<String, TOCItemExternal> getTOCItemExternalsByDisplayMapping() {\n\t\t\treturn externals;\n\t\t}\n\n\t\t@Override\n\t\tpublic Map<String, TOCItemDefinition> getTOCItemDefinitionsByIDMapping() {\n\t\t\treturn definitions;\n\t\t}\n\n\t}\n\n\tprivate class LinkDatabaseTestStub extends LinkDatabase {\n\n\t\tpublic LinkDatabaseTestStub(HelpModuleLocation loc) {\n\t\t\tsuper(HelpModuleCollection.fromHelpLocations(Collections.singleton(loc)));\n\t\t}\n\n\t\t@Override\n\t\tpublic String getIDForLink(String target) {\n\t\t\treturn \"test_ID_\" + target;\n\t\t}\n\t}\n\n\tprivate class OverlayHelpModuleLocationTestStub extends HelpModuleLocationTestDouble {\n\n\t\tOverlayHelpModuleLocationTestStub(GhidraTOCFileDummy toc) {\n\t\t\tsuper(Paths.get(\"/fake/help\"));\n\t\t\tthis.sourceTOCFile = toc;\n\t\t}\n\n\t\t@Override\n\t\tprotected void loadHelpTopics() {\n\t\t\t// no! ...don't really go to the filesystem\n\t\t}\n\n\t\t@Override\n\t\tpublic GhidraTOCFile loadSourceTOCFile() {\n\t\t\treturn null;// we set this in the constructor\n\t\t}\n\n\t\t@Override\n\t\tpublic HelpSet loadHelpSet() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isHelpInputSource() {\n\t\t\treturn true;\n\t\t}\n\n\t}\n\n\tprivate class GhidraTOCFileDummy extends GhidraTOCFileTestDouble {\n\n\t\tpublic GhidraTOCFileDummy(Path path) {\n\t\t\tsuper(path);\n\t\t}\n\t}\n}", "class_id": 0, "repo": "Bugasu/ghidra", "file": "Ghidra/Framework/Help/src/test/java/help/OverlayHelpTreeTest.java", "last_update_at": "2019-12-02T20:51:49+00:00", "question_id": "20b41f9c57389d10ff16393c30505513d995ad2c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OverlayHelpTreeTest {\n\t@Test\n    public void testSourceTOCFileThatDependsUponPreBuiltHelp() {\n\t\t//\n\t\t// We want to make sure the overlay tree will properly resolve help TOC items being \n\t\t// built from TOC_Source.xml files when that file uses <TOCREF> items that are defined\n\t\t// in a help <TOCITEM> that lives inside of a pre-built jar file.\n\t\t//\n\t\t/*\n\t\t \n\t\t \tExample makeup we will create:\n\t\t \n\t\t\t  \tPreBuild_TOC.xml\n\t\t\t  \t\n\t\t\t  \t\t<tocitem id=\"root\" target=\"fake\">\n\t\t\t  \t\t\t<tocitem id=\"child_1\" target=\"fake\" />\n\t\t\t  \t\t</tocitem>\n\t\t\t \n\t\t\t \n\t\t\t \tTOC_Source.xml \n\t\t\t \t\n\t\t\t \t\t<tocref id=\"root\">\n\t\t\t \t\t\t<tocref=\"child_1\">\n\t\t\t \t\t\t\t<tocdef id=\"child_2\" target=\"fake\" />\n\t\t\t \t\t\t</tocref>\n\t\t\t \t\t</tocref>\n\t\t  \n\t\t */\n\t\tTOCItemExternal root = externalItem(\"root\");\n\t\tTOCItemExternal child_1 = externalItem(root, \"child_1\");\n\t\tPath tocSourceFile = Paths.get(\"/fake/path_2/TOC_Source.xml\");\n\t\tString root_ID = root.getIDAttribute();\n\t\tTOCItemReference root_ref = referenceItem(root_ID, tocSourceFile);\n\t\tString child_1_ID = child_1.getIDAttribute();\n\t\tTOCItemReference child_1_ref = referenceItem(root_ref, child_1_ID, tocSourceFile);\n\t\tTOCItemDefinition child_2 = definitionItem(child_1_ref, \"child_2\", tocSourceFile);\n\t\tTOCItemProviderTestStub tocProvider = new TOCItemProviderTestStub();\n\t\ttocProvider.addExternal(root);\n\t\ttocProvider.addExternal(child_1);\n\t\ttocProvider.addDefinition(child_2);\n\t\tTOCSpyWriter spy = printOverlayTree(tocProvider, tocSourceFile);\n\t\tassertNodeCount(spy, 3);\n\t\tassertOrder(spy, 1, root);\n\t\tassertOrder(spy, 2, child_1);\n\t\tassertOrder(spy, 3, child_2);\n\t}\n\t@Test\n    public void testSourceTOCFileThatDependsUponPreBuiltHelp_MultiplePreBuiltInputs() {\n\t\t//\n\t\t// We want to make sure the overlay tree will properly resolve help TOC items being \n\t\t// built from TOC_Source.xml files when that file uses <TOCREF> items that are defined\n\t\t// in a help <TOCITEM> that lives inside of multiple pre-built jar files.\n\t\t//\n\t\t/*\n\t\t \n\t\t \tExample makeup we will create:\n\t\t \n\t\t\t  \tPreBuild_TOC.xml\n\t\t\t  \t\n\t\t\t  \t\t<tocitem id=\"root\" target=\"fake\">\n\t\t\t  \t\t\t<tocitem id=\"child_1\" target=\"fake\">\n\t\t\t  \t\t\t\t<tocitem=\"prebuilt_a_child\" target=\"fake\" />\n\t\t\t  \t\t\t</tocitem>\n\t\t\t  \t\t</tocitem>\n\t\t\t \n\t\t\t\tAnother PreBuild_TOC.xml\n\t\t\t  \t\n\t\t\t  \t\t<tocitem id=\"root\" target=\"fake\">\n\t\t\t  \t\t\t<tocitem id=\"child_1\" target=\"fake\">\n\t\t\t  \t\t\t\t<tocitem=\"prebuilt_b_child\" target=\"fake\" />\n\t\t\t  \t\t\t</tocitem>\n\t\t\t  \t\t</tocitem>\n\t\t\t \n\t\t\t \n\t\t\t \tTOC_Source.xml \n\t\t\t \t\n\t\t\t \t\t<tocref id=\"root\">\n\t\t\t \t\t\t<tocref=\"child_1\">\n\t\t\t \t\t\t\t<tocdef id=\"child_2\" target=\"fake\" />\n\t\t\t \t\t\t</tocref>\n\t\t\t \t\t</tocref>\n\t\t  \n\t\t */\n\t\tTOCItemExternal root_a = externalItem(\"root\");\n\t\tTOCItemExternal child_1_a = externalItem(root_a, \"child_1\");\n\t\tTOCItemExternal prebuilt_a_child = externalItem(child_1_a, \"prebuilt_a_child\");\n\t\t// note: same ID values, since they represent the same nodes, but from different TOC files\n\t\tTOCItemExternal root_b = externalItemAlt(null, \"root\");\n\t\tTOCItemExternal child_1_b = externalItemAlt(root_b, \"child_1\");\n\t\tTOCItemExternal prebuilt_b_child = externalItemAlt(child_1_b, \"prebuilt_b_child\");\n\t\tPath tocSourceFile = Paths.get(\"/fake/path_2/TOC_Source.xml\");\n\t\tString root_ID = root_a.getIDAttribute();\n\t\tTOCItemReference root_ref = referenceItem(root_ID, tocSourceFile);\n\t\tString child_1_ID = child_1_a.getIDAttribute();\n\t\tTOCItemReference child_1_ref = referenceItem(root_ref, child_1_ID, tocSourceFile);\n\t\tTOCItemDefinition child_2 = definitionItem(child_1_ref, \"child_2\", tocSourceFile);\n\t\tTOCItemProviderTestStub tocProvider = new TOCItemProviderTestStub();\n\t\ttocProvider.addExternal(root_a);\n\t\ttocProvider.addExternal(root_b);\n\t\ttocProvider.addExternal(child_1_a);\n\t\ttocProvider.addExternal(child_1_b);\n\t\ttocProvider.addExternal(prebuilt_a_child);\n\t\ttocProvider.addExternal(prebuilt_b_child);\n\t\ttocProvider.addDefinition(child_2);\n\t\tTOCSpyWriter spy = printOverlayTree(tocProvider, tocSourceFile);\n\t\tassertNodeCount(spy, 3);\n\t\tassertOrder(spy, 1, root_a);// could also be root_b, same ID\n\t\tassertOrder(spy, 2, child_1_a);// could also be child_1_b, same ID\n\t\tassertOrder(spy, 3, child_2);\n\t\t// note: prebuilt_a_child and prebuilt_b_child don't get output, since they do not have \n\t\t//       the same TOC file ID as the help file being processed (in other words, they don't\n\t\t//       live in the TOC_Source.xml being processes, so they are not part of the output).\n\t}\n\t@Test\n    public void testSourceTOCFileThatDependsAnotherTOCSourceFile() {\n\t\t/*\n\t\t \n\t\t The first source file defines attributes that the second file references.\n\t\t \n\t\t Example makeup we will create:\n\t\t\n\t\t  \tTOC_Source.xml\n\t\t  \t\n\t\t  \t\t<tocdef id=\"root\" target=\"fake\">\n\t\t  \t\t\t<tocdef id=\"child_1\" target=\"fake\" />\n\t\t  \t\t</tocdef>\n\t\t \n\t\t \n\t\t \tAnother TOC_Source.xml \n\t\t \t\n\t\t \t\t<tocref id=\"root\">\n\t\t \t\t\t<tocref=\"child_1\">\n\t\t \t\t\t\t<tocdef id=\"child_2\" target=\"fake\" />\n\t\t \t\t\t</tocref>\n\t\t \t\t</tocref>\n\t\t\n\t\t*/\n\t\tPath toc_1 = Paths.get(\"/fake/path_1/TOC_Source.xml\");\n\t\tTOCItemDefinition root = definitionItem(\"root\", toc_1);\n\t\tTOCItemDefinition child_1 = definitionItem(root, \"child_1\", toc_1);\n\t\tPath toc_2 = Paths.get(\"/fake/path_2/TOC_Source.xml\");\n\t\tString root_ID = root.getIDAttribute();\n\t\tString child_1_ID = child_1.getIDAttribute();\n\t\tTOCItemReference root_ref = referenceItem(root_ID, toc_2);\n\t\tTOCItemReference child_1_ref = referenceItem(root_ref, child_1_ID, toc_2);\n\t\tTOCItemDefinition child_2 = definitionItem(child_1_ref, \"child_2\", toc_2);\n\t\tTOCItemProviderTestStub tocProvider = new TOCItemProviderTestStub();\n\t\ttocProvider.addDefinition(root);\n\t\ttocProvider.addDefinition(child_1);\n\t\ttocProvider.addDefinition(child_2);// in the second TOC file\n\t\tTOCSpyWriter spy = printOverlayTree(tocProvider, toc_2);\n\t\tassertNodeCount(spy, 3);\n\t\tassertOrder(spy, 1, root);\n\t\tassertOrder(spy, 2, child_1);\n\t\tassertOrder(spy, 3, child_2);\n\t}\n//==================================================================================================\n// Inner Classes\n//==================================================================================================\n\tprivate TOCSpyWriter printOverlayTree(TOCItemProviderTestStub tocItemProvider, Path tocFile) {\n\t\t//\n\t\t// Create a test version of the LinkDatabase for the overlay tree, with test versions of\n\t\t// it's required TOC input file and HelpModuleLocation\n\t\t// \n\t\tGhidraTOCFileDummy toc = new GhidraTOCFileDummy(tocFile);\n\t\tOverlayHelpModuleLocationTestStub location = new OverlayHelpModuleLocationTestStub(toc);\n\t\tLinkDatabaseTestStub db = new LinkDatabaseTestStub(location);\n\t\t// This is the class we are testing!!\n\t\tOverlayHelpTree overlayHelpTree = new OverlayHelpTree(tocItemProvider, db);\n\t\tTOCSpyWriter spy = new TOCSpyWriter();\n\t\tString TOCID = tocFile.toUri().toString();\n\t\toverlayHelpTree.printTreeForID(spy, TOCID);\n\t\tSystem.out.println(spy.toString());\n\t\treturn spy;\n\t}\n\tprivate TOCItemDefinition definitionItem(String ID, Path tocSourceFile) {\n\t\treturn definitionItem(null, ID, tocSourceFile);\n\t}\n\tprivate TOCItemDefinition definitionItem(TOCItem parent, String ID, Path tocSourceFile) {\n\t\tString target = \"fake\";\n\t\tString sort = \"\";\n\t\tint line = 1;\n\t\treturn new TOCItemDefinition(parent, tocSourceFile, ID, ID, target, sort, line);\n\t}\n\tprivate TOCItemReference referenceItem(String referenceID, Path tocSourceFile) {\n\t\treturn referenceItem(null, referenceID, tocSourceFile);\n\t}\n\tprivate TOCItemReference referenceItem(TOCItem parent, String referenceID, Path tocSourceFile) {\n\t\treturn new TOCItemReference(parent, tocSourceFile, referenceID, 1);\n\t}\n\tprivate TOCItemExternal externalItem(String ID) {\n\t\treturn externalItem(null, ID);\n\t}\n\tprivate TOCItemExternal externalItem(TOCItem parent, String ID) {\n\t\tPath tocFile = Paths.get(\"/fake/path_1/PreBuild_TOC.xml\");\n\t\tString target = \"fake\";\n\t\tString sort = \"\";\n\t\tint line = 1;\n\t\treturn new TOCItemExternal(parent, tocFile, ID, ID, target, sort, line);\n\t}\n\tprivate TOCItemExternal externalItemAlt(TOCItem parent, String ID) {\n\t\tPath tocFile = Paths.get(\"/fake/path_1/PreBuild_TOC.xml\");\n\t\tString target = \"fake\";\n\t\tString sort = \"\";\n\t\tint line = 1;\n\t\treturn new TOCItemExternal(parent, tocFile, ID, ID, target, sort, line);\n\t}\n\tprivate void assertOrder(TOCSpyWriter spy, int ordinal, TOCItem item) {\n\t\tString ID = spy.getItem(ordinal - 1 /* make an index */);\n\t\tassertEquals(\"Did not find TOC item at expected index: \" + ordinal, item.getIDAttribute(),\n\t\t\tID);\n\t}\n\tprivate void assertNodeCount(TOCSpyWriter spy, int count) {\n\t\tassertEquals(\"Did not get exactly one node per TOC item input\", count, spy.getItemCount());\n\t}\n\tprivate class TOCSpyWriter extends PrintWriter {\n\t\tprivate StringWriter stringWriter;\n\t\tprivate List<String> tocItems = new ArrayList<>();\n\t\tpublic TOCSpyWriter() {\n\t\t\tsuper(new StringWriter(), true);\n\t\t\tstringWriter = ((StringWriter) out);\n\t\t}\n\t\tString getItem(int position) {\n\t\t\treturn tocItems.get(position);\n\t\t}\n\t\tint getItemCount() {\n\t\t\treturn tocItems.size();\n\t\t}\n\t\t@Override\n\t\tpublic void println(String s) {\n\t\t\tsuper.println(s);\n\t\t\ts = s.trim();\n\t\t\tif (!s.startsWith(\"<tocitem\")) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstoreDisplayAttribute(s);\n\t\t}\n\t\tprivate void storeDisplayAttribute(String s) {\n\t\t\t// create a pattern to pull out the display string\n\t\t\tPattern p = Pattern.compile(\".*display=\\\"(.*)\\\" toc_id.*\");\n\t\t\tMatcher matcher = p.matcher(s.trim());\n\t\t\tif (!matcher.matches()) {\n\t\t\t\treturn;// not a TOC item\n\t\t\t}\n\t\t\tString value = matcher.group(1);\n\t\t\ttocItems.add(value);\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn stringWriter.getBuffer().toString();\n\t\t}\n\t}\n\tprivate class TOCItemProviderTestStub implements TOCItemProvider {\n\t\tMap<String, TOCItemExternal> externals = new HashMap<>();\n\t\tMap<String, TOCItemDefinition> definitions = new HashMap<>();\n\t\tvoid addExternal(TOCItemExternal item) {\n\t\t\tString displayText = item.getIDAttribute();\n\t\t\texternals.put(displayText, item);\n\t\t}\n\t\tvoid addDefinition(TOCItemDefinition item) {\n\t\t\tString ID = item.getIDAttribute();\n\t\t\tdefinitions.put(ID, item);\n\t\t}\n\t\t@Override\n\t\tpublic Map<String, TOCItemExternal> getTOCItemExternalsByDisplayMapping() {\n\t\t\treturn externals;\n\t\t}\n\t\t@Override\n\t\tpublic Map<String, TOCItemDefinition> getTOCItemDefinitionsByIDMapping() {\n\t\t\treturn definitions;\n\t\t}\n\t}\n\tprivate class LinkDatabaseTestStub extends LinkDatabase {\n\t\tpublic LinkDatabaseTestStub(HelpModuleLocation loc) {\n\t\t\tsuper(HelpModuleCollection.fromHelpLocations(Collections.singleton(loc)));\n\t\t}\n\t\t@Override\n\t\tpublic String getIDForLink(String target) {\n\t\t\treturn \"test_ID_\" + target;\n\t\t}\n\t}\n\tprivate class OverlayHelpModuleLocationTestStub extends HelpModuleLocationTestDouble {\n\t\tOverlayHelpModuleLocationTestStub(GhidraTOCFileDummy toc) {\n\t\t\tsuper(Paths.get(\"/fake/help\"));\n\t\t\tthis.sourceTOCFile = toc;\n\t\t}\n\t\t@Override\n\t\tprotected void loadHelpTopics() {\n\t\t\t// no! ...don't really go to the filesystem\n\t\t}\n\t\t@Override\n\t\tpublic GhidraTOCFile loadSourceTOCFile() {\n\t\t\treturn null;// we set this in the constructor\n\t\t}\n\t\t@Override\n\t\tpublic HelpSet loadHelpSet() {\n\t\t\treturn null;\n\t\t}\n\t\t@Override\n\t\tpublic boolean isHelpInputSource() {\n\t\t\treturn true;\n\t\t}\n\t}\n\tprivate class GhidraTOCFileDummy extends GhidraTOCFileTestDouble {\n\t\tpublic GhidraTOCFileDummy(Path path) {\n\t\t\tsuper(path);\n\t\t}\n\t}\n"]]}
{"hexsha": "4d597e19a9d663739698f9bb7859d31cf67b1c1c", "ext": "java", "lang": "Java", "content": "@RunWith(MockitoJUnitRunner.class)\npublic class ZapReleaseComparitorUnitTest {\n\n    private static final String DEV_BUILD = \"Dev Build\";\n\n    @Test\n    public void testComparitor() {\n        ZapReleaseComparitor zrc = new ZapReleaseComparitor();\n\n        // Test equals\n        assertTrue(zrc.compare(new ZapRelease(DEV_BUILD), new ZapRelease(DEV_BUILD)) == 0);\n        assertTrue(zrc.compare(new ZapRelease(\"2.0.0\"), new ZapRelease(\"2.0.0\")) == 0);\n        assertTrue(zrc.compare(new ZapRelease(\"2.0.alpha\"), new ZapRelease(\"2.0.alpha\")) == 0);\n        assertTrue(\n                zrc.compare(new ZapRelease(\"D-2013-01-01\"), new ZapRelease(\"D-2013-01-01\")) == 0);\n\n        // Test first more recent that second\n        assertTrue(zrc.compare(new ZapRelease(DEV_BUILD), new ZapRelease(\"D-2012-08-01\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(DEV_BUILD), new ZapRelease(\"1.4.1\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(DEV_BUILD), new ZapRelease(\"2.4.beta\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(\"2.0.0.1\"), new ZapRelease(\"2.0.0\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(\"2.0.0.1\"), new ZapRelease(\"2.0.alpha\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(\"1.4\"), new ZapRelease(\"1.3.4\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(\"2.0\"), new ZapRelease(\"1.3.4\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(\"2.0.11\"), new ZapRelease(\"2.0.5\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(\"1.4.alpha\"), new ZapRelease(\"1.3.4\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(\"D-2012-08-02\"), new ZapRelease(\"D-2012-08-01\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(\"D-2013-10-10\"), new ZapRelease(\"D-2012-01-01\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(\"D-2013-01-01\"), new ZapRelease(\"D-2012-12-31\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(\"D-2013-01-07\"), new ZapRelease(\"D-2012-12-31\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(\"D-2013-01-07\"), new ZapRelease(\"2.0.1\")) > 0);\n\n        // Test first older that second\n        assertTrue(zrc.compare(new ZapRelease(\"1.4.1\"), new ZapRelease(DEV_BUILD)) < 0);\n        assertTrue(zrc.compare(new ZapRelease(\"2.4.beta\"), new ZapRelease(DEV_BUILD)) < 0);\n        assertTrue(zrc.compare(new ZapRelease(\"2.0.0\"), new ZapRelease(\"2.0.0.1\")) < 0);\n        assertTrue(zrc.compare(new ZapRelease(\"2.0.alpha\"), new ZapRelease(\"2.0.0.1\")) < 0);\n        assertTrue(zrc.compare(new ZapRelease(\"1.3.4\"), new ZapRelease(\"1.4\")) < 0);\n        assertTrue(zrc.compare(new ZapRelease(\"1.3.4\"), new ZapRelease(\"2.0\")) < 0);\n        assertTrue(zrc.compare(new ZapRelease(\"2.0.6\"), new ZapRelease(\"2.0.12\")) < 0);\n        assertTrue(zrc.compare(new ZapRelease(\"1.3.4\"), new ZapRelease(\"1.4.alpha\")) < 0);\n        assertTrue(zrc.compare(new ZapRelease(\"D-2012-08-01\"), new ZapRelease(\"D-2012-08-02\")) < 0);\n        assertTrue(zrc.compare(new ZapRelease(\"D-2012-01-01\"), new ZapRelease(\"D-2013-10-10\")) < 0);\n        assertTrue(zrc.compare(new ZapRelease(\"D-2012-12-31\"), new ZapRelease(\"D-2013-01-01\")) < 0);\n        assertTrue(zrc.compare(new ZapRelease(\"D-2012-12-31\"), new ZapRelease(\"D-2013-01-07\")) < 0);\n        assertTrue(zrc.compare(new ZapRelease(\"2.0.1\"), new ZapRelease(\"D-2013-01-07\")) < 0);\n\n        // Bad versions\n        try {\n            zrc.compare(new ZapRelease(\"1.4.1.theta\"), new ZapRelease(\"1.4.1.alpha\"));\n            fail(\"Should have thrown an exception\");\n        } catch (IllegalArgumentException e) {\n            // worked\n        }\n        try {\n            zrc.compare(new ZapRelease(\"1.4.1.0\"), new ZapRelease(\"1.4.1.theta\"));\n            fail(\"Should have thrown an exception\");\n        } catch (IllegalArgumentException e) {\n            // worked\n        }\n    }\n}", "class_id": 0, "repo": "Diffblue-benchmarks/Zaproxy-zaproxy", "file": "zap/src/test/java/org/zaproxy/zap/control/ZapReleaseComparitorUnitTest.java", "last_update_at": "2019-09-11T07:25:44+00:00", "question_id": "4d597e19a9d663739698f9bb7859d31cf67b1c1c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(MockitoJUnitRunner.class)\npublic class ZapReleaseComparitorUnitTest {\n    private static final String DEV_BUILD = \"Dev Build\";\n    @Test\n    public void testComparitor() {\n        ZapReleaseComparitor zrc = new ZapReleaseComparitor();\n        // Test equals\n        assertTrue(zrc.compare(new ZapRelease(DEV_BUILD), new ZapRelease(DEV_BUILD)) == 0);\n        assertTrue(zrc.compare(new ZapRelease(\"2.0.0\"), new ZapRelease(\"2.0.0\")) == 0);\n        assertTrue(zrc.compare(new ZapRelease(\"2.0.alpha\"), new ZapRelease(\"2.0.alpha\")) == 0);\n        assertTrue(\n                zrc.compare(new ZapRelease(\"D-2013-01-01\"), new ZapRelease(\"D-2013-01-01\")) == 0);\n        // Test first more recent that second\n        assertTrue(zrc.compare(new ZapRelease(DEV_BUILD), new ZapRelease(\"D-2012-08-01\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(DEV_BUILD), new ZapRelease(\"1.4.1\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(DEV_BUILD), new ZapRelease(\"2.4.beta\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(\"2.0.0.1\"), new ZapRelease(\"2.0.0\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(\"2.0.0.1\"), new ZapRelease(\"2.0.alpha\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(\"1.4\"), new ZapRelease(\"1.3.4\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(\"2.0\"), new ZapRelease(\"1.3.4\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(\"2.0.11\"), new ZapRelease(\"2.0.5\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(\"1.4.alpha\"), new ZapRelease(\"1.3.4\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(\"D-2012-08-02\"), new ZapRelease(\"D-2012-08-01\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(\"D-2013-10-10\"), new ZapRelease(\"D-2012-01-01\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(\"D-2013-01-01\"), new ZapRelease(\"D-2012-12-31\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(\"D-2013-01-07\"), new ZapRelease(\"D-2012-12-31\")) > 0);\n        assertTrue(zrc.compare(new ZapRelease(\"D-2013-01-07\"), new ZapRelease(\"2.0.1\")) > 0);\n        // Test first older that second\n        assertTrue(zrc.compare(new ZapRelease(\"1.4.1\"), new ZapRelease(DEV_BUILD)) < 0);\n        assertTrue(zrc.compare(new ZapRelease(\"2.4.beta\"), new ZapRelease(DEV_BUILD)) < 0);\n        assertTrue(zrc.compare(new ZapRelease(\"2.0.0\"), new ZapRelease(\"2.0.0.1\")) < 0);\n        assertTrue(zrc.compare(new ZapRelease(\"2.0.alpha\"), new ZapRelease(\"2.0.0.1\")) < 0);\n        assertTrue(zrc.compare(new ZapRelease(\"1.3.4\"), new ZapRelease(\"1.4\")) < 0);\n        assertTrue(zrc.compare(new ZapRelease(\"1.3.4\"), new ZapRelease(\"2.0\")) < 0);\n        assertTrue(zrc.compare(new ZapRelease(\"2.0.6\"), new ZapRelease(\"2.0.12\")) < 0);\n        assertTrue(zrc.compare(new ZapRelease(\"1.3.4\"), new ZapRelease(\"1.4.alpha\")) < 0);\n        assertTrue(zrc.compare(new ZapRelease(\"D-2012-08-01\"), new ZapRelease(\"D-2012-08-02\")) < 0);\n        assertTrue(zrc.compare(new ZapRelease(\"D-2012-01-01\"), new ZapRelease(\"D-2013-10-10\")) < 0);\n        assertTrue(zrc.compare(new ZapRelease(\"D-2012-12-31\"), new ZapRelease(\"D-2013-01-01\")) < 0);\n        assertTrue(zrc.compare(new ZapRelease(\"D-2012-12-31\"), new ZapRelease(\"D-2013-01-07\")) < 0);\n        assertTrue(zrc.compare(new ZapRelease(\"2.0.1\"), new ZapRelease(\"D-2013-01-07\")) < 0);\n        // Bad versions\n        try {\n            zrc.compare(new ZapRelease(\"1.4.1.theta\"), new ZapRelease(\"1.4.1.alpha\"));\n            fail(\"Should have thrown an exception\");\n        } catch (IllegalArgumentException e) {\n            // worked\n        }\n        try {\n            zrc.compare(new ZapRelease(\"1.4.1.0\"), new ZapRelease(\"1.4.1.theta\"));\n            fail(\"Should have thrown an exception\");\n        } catch (IllegalArgumentException e) {\n            // worked\n        }\n    }\n"]]}
{"hexsha": "3b56464494cf915749fe88f0e13f48efa582dfef", "ext": "java", "lang": "Java", "content": "public class Textures {\n\n  public static void upload(BufferedImage img, int format, int tex) {\n    int width = img.getWidth();\n    int height = img.getHeight();\n    if (Visage.trace)\n      Visage.log.finest(\n          \"Uploading \" + width + \"x\" + height + \" (\" + (width * height) + \" pixel) image\");\n\n    BufferedImage unindexed = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n\n    int[] argb = new int[width * height];\n    img.getRGB(0, 0, width, height, argb, 0, width);\n\n    unindexed.setRGB(0, 0, width, height, argb, 0, width);\n    unindexed.coerceData(true);\n    unindexed.getRGB(0, 0, width, height, argb, 0, width);\n\n    IntBuffer buf = BufferUtils.createIntBuffer(width * height);\n    buf.put(argb);\n    buf.flip();\n\n    glBindTexture(GL_TEXTURE_2D, tex);\n    glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, GL_BGRA, GL_UNSIGNED_BYTE, buf);\n\n    checkGLError();\n  }\n}", "class_id": 0, "repo": "VeltPvP/Visage", "file": "src/main/java/com/surgeplay/visage/renderer/util/Textures.java", "last_update_at": "2019-12-22T14:20:57+00:00", "question_id": "3b56464494cf915749fe88f0e13f48efa582dfef", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Textures {\n  public static void upload(BufferedImage img, int format, int tex) {\n    int width = img.getWidth();\n    int height = img.getHeight();\n    if (Visage.trace)\n      Visage.log.finest(\n          \"Uploading \" + width + \"x\" + height + \" (\" + (width * height) + \" pixel) image\");\n    BufferedImage unindexed = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n    int[] argb = new int[width * height];\n    img.getRGB(0, 0, width, height, argb, 0, width);\n    unindexed.setRGB(0, 0, width, height, argb, 0, width);\n    unindexed.coerceData(true);\n    unindexed.getRGB(0, 0, width, height, argb, 0, width);\n    IntBuffer buf = BufferUtils.createIntBuffer(width * height);\n    buf.put(argb);\n    buf.flip();\n    glBindTexture(GL_TEXTURE_2D, tex);\n    glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, GL_BGRA, GL_UNSIGNED_BYTE, buf);\n    checkGLError();\n  }\n"]]}
{"hexsha": "9a3bd858301c0018a4c593722f3dc858c19ccb1e", "ext": "java", "lang": "Java", "content": "public class FeignClientScannerRegistrar implements ImportBeanDefinitionRegistrar {\n\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n        AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(FeignClientScan.class.getName()));\n        ClassPathFeignClientScanner scanner = new ClassPathFeignClientScanner(registry);\n\n        Class<?> markerInterface = annoAttrs.getClass(\"markerInterface\");\n        if (!Class.class.equals(markerInterface)) {\n            scanner.setMarkerInterface(markerInterface);\n        }\n\n        scanner.setFeignBuilderBeanName(annoAttrs.getString(\"feignBuilderRef\"));\n\n        List<String> basePackages = new ArrayList<>();\n        for (String pkg : annoAttrs.getStringArray(\"value\")) {\n            if (StringUtils.hasText(pkg)) {\n                basePackages.add(pkg);\n            }\n        }\n        for (String pkg : annoAttrs.getStringArray(\"basePackages\")) {\n            if (StringUtils.hasText(pkg)) {\n                basePackages.add(pkg);\n            }\n        }\n        scanner.registerFilters();\n        scanner.doScan(StringUtils.toStringArray(basePackages));\n    }\n\n}", "class_id": 0, "repo": "chenqiaoanying/spring-feign", "file": "src/main/java/com/caqy/feign/FeignClientScannerRegistrar.java", "last_update_at": "2019-07-10T12:45:20+00:00", "question_id": "9a3bd858301c0018a4c593722f3dc858c19ccb1e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FeignClientScannerRegistrar implements ImportBeanDefinitionRegistrar {\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n        AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(FeignClientScan.class.getName()));\n        ClassPathFeignClientScanner scanner = new ClassPathFeignClientScanner(registry);\n        Class<?> markerInterface = annoAttrs.getClass(\"markerInterface\");\n        if (!Class.class.equals(markerInterface)) {\n            scanner.setMarkerInterface(markerInterface);\n        }\n        scanner.setFeignBuilderBeanName(annoAttrs.getString(\"feignBuilderRef\"));\n        List<String> basePackages = new ArrayList<>();\n        for (String pkg : annoAttrs.getStringArray(\"value\")) {\n            if (StringUtils.hasText(pkg)) {\n                basePackages.add(pkg);\n            }\n        }\n        for (String pkg : annoAttrs.getStringArray(\"basePackages\")) {\n            if (StringUtils.hasText(pkg)) {\n                basePackages.add(pkg);\n            }\n        }\n        scanner.registerFilters();\n        scanner.doScan(StringUtils.toStringArray(basePackages));\n    }\n"]]}
{"hexsha": "c93fc34ff40a388c36c6e707f8ce7b61a178a900", "ext": "java", "lang": "Java", "content": "@TargetApi(Build.VERSION_CODES.LOLLIPOP)\npublic class PhoneLogPlugin\n    implements MethodCallHandler, PluginRegistry.RequestPermissionsResultListener {\n  private final Registrar registrar;\n  private Result pendingResult;\n\n  private PhoneLogPlugin(Registrar registrar) {\n    this.registrar = registrar;\n  }\n\n  public static void registerWith(Registrar registrar) {\n    final MethodChannel channel =\n        new MethodChannel(registrar.messenger(), \"github.com/jiajiabingcheng/phone_log\");\n    PhoneLogPlugin phoneLogPlugin = new PhoneLogPlugin(registrar);\n    channel.setMethodCallHandler(phoneLogPlugin);\n    registrar.addRequestPermissionsResultListener(phoneLogPlugin);\n  }\n\n  @Override\n  public void onMethodCall(MethodCall call, Result result) {\n    if (pendingResult != null) {\n      pendingResult.error(\"multiple_requests\", \"Cancelled by a second request.\", null);\n      pendingResult = null;\n    }\n    pendingResult = result;\n    switch (call.method) {\n      case \"checkPermission\":\n        pendingResult.success(checkPermission());\n        pendingResult = null;\n        break;\n      case \"requestPermission\":\n        requestPermission();\n        break;\n      case \"getPhoneLogs\":\n        String startDate = call.argument(\"startDate\");\n        String duration = call.argument(\"duration\");\n        fetchCallRecords(startDate, duration);\n        break;\n      default:\n        result.notImplemented();\n    }\n  }\n\n  private void requestPermission() {\n    Log.i(\"PhoneLogPlugin\", \"Requesting permission : \" + Manifest.permission.READ_CALL_LOG);\n    String[] perm = {Manifest.permission.READ_CALL_LOG};\n    registrar.activity().requestPermissions(perm, 0);\n  }\n\n  private String checkPermission() {\n    Log.i(\"PhoneLogPlugin\", \"Checking permission : \" + Manifest.permission.READ_CALL_LOG);\n    boolean isGranted =\n        PackageManager.PERMISSION_GRANTED\n            == registrar.activity().checkSelfPermission(Manifest.permission.READ_CALL_LOG);\n    if (isGranted) {\n      return \"granted\";\n    } else if (registrar\n        .activity()\n        .shouldShowRequestPermissionRationale(Manifest.permission.READ_CALL_LOG)) {\n      return \"denied\";\n    }\n    return \"deniedAndCannotRequest\";\n  }\n\n  @Override\n  public boolean onRequestPermissionsResult(int requestCode, String[] strings, int[] grantResults) {\n    boolean res = false;\n    if (requestCode == 0 && grantResults.length > 0) {\n      res = grantResults[0] == PackageManager.PERMISSION_GRANTED;\n      pendingResult.success(res);\n      pendingResult = null;\n    }\n    return res;\n  }\n\n  private static final String[] PROJECTION = {\n    CallLog.Calls.CACHED_FORMATTED_NUMBER,\n    CallLog.Calls.CACHED_MATCHED_NUMBER,\n    CallLog.Calls.TYPE,\n    CallLog.Calls.DATE,\n    CallLog.Calls.DURATION,\n  };\n\n  @TargetApi(Build.VERSION_CODES.M)\n  private void fetchCallRecords(String startDate, String duration) {\n    if (registrar.activity().checkSelfPermission(Manifest.permission.READ_CALL_LOG)\n        == PackageManager.PERMISSION_GRANTED) {\n      String selectionCondition = null;\n      if (startDate != null) {\n        selectionCondition = CallLog.Calls.DATE + \"> \" + startDate;\n      }\n      if (duration != null) {\n        String durationSelection = CallLog.Calls.DURATION + \"> \" + duration;\n        if (selectionCondition != null) {\n          selectionCondition = selectionCondition + \" AND \" + durationSelection;\n        } else {\n          selectionCondition = durationSelection;\n        }\n      }\n      Cursor cursor =\n          registrar\n              .context()\n              .getContentResolver()\n              .query(\n                  CallLog.Calls.CONTENT_URI,\n                  PROJECTION,\n                  selectionCondition,\n                  null,\n                  CallLog.Calls.DATE + \" DESC\");\n\n      try {\n        ArrayList<HashMap<String, Object>> records = getCallRecordMaps(cursor);\n        pendingResult.success(records);\n        pendingResult = null;\n      } catch (Exception e) {\n        Log.e(\"PhoneLog\", \"Error on fetching call record\" + e);\n        pendingResult.error(\"PhoneLog\", e.getMessage(), null);\n        pendingResult = null;\n      } finally {\n        if (cursor != null) {\n          cursor.close();\n        }\n      }\n\n    } else {\n      pendingResult.error(\"PhoneLog\", \"Permission is not granted\", null);\n      pendingResult = null;\n    }\n  }\n\n  /**\n   * Builds the list of call record maps from the cursor\n   *\n   * @param cursor\n   * @return the list of maps\n   */\n  private ArrayList<HashMap<String, Object>> getCallRecordMaps(Cursor cursor) {\n    ArrayList<HashMap<String, Object>> records = new ArrayList<>();\n\n    while (cursor != null && cursor.moveToNext()) {\n      CallRecord record = new CallRecord();\n      record.formattedNumber = cursor.getString(0);\n      record.number = cursor.getString(1);\n      record.callType = getCallType(cursor.getInt(2));\n\n      Date date = new Date(cursor.getLong(3));\n      Calendar cal = Calendar.getInstance();\n      cal.setTime(date);\n      record.dateYear = cal.get(Calendar.YEAR);\n      record.dateMonth = cal.get(Calendar.MONTH);\n      record.dateDay = cal.get(Calendar.DAY_OF_MONTH);\n      record.dateHour = cal.get(Calendar.HOUR_OF_DAY);\n      record.dateMinute = cal.get(Calendar.MINUTE);\n      record.dateSecond = cal.get(Calendar.SECOND);\n      record.duration = cursor.getLong(4);\n\n      records.add(record.toMap());\n    }\n    return records;\n  }\n\n  private String getCallType(int anInt) {\n    switch (anInt) {\n      case CallLog.Calls.INCOMING_TYPE:\n        return \"INCOMING_TYPE\";\n      case CallLog.Calls.OUTGOING_TYPE:\n        return \"OUTGOING_TYPE\";\n      case CallLog.Calls.MISSED_TYPE:\n        return \"MISSED_TYPE\";\n      default:\n        break;\n    }\n    return null;\n  }\n}", "class_id": 0, "repo": "ianko/flutter.plugins", "file": "packages/phone_log/android/src/main/java/com/jiajiabingcheng/phonelog/PhoneLogPlugin.java", "last_update_at": "2019-08-10T22:12:51+00:00", "question_id": "c93fc34ff40a388c36c6e707f8ce7b61a178a900", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@TargetApi(Build.VERSION_CODES.LOLLIPOP)\npublic class PhoneLogPlugin\n    implements MethodCallHandler, PluginRegistry.RequestPermissionsResultListener {\n  private final Registrar registrar;\n  private Result pendingResult;\n  private PhoneLogPlugin(Registrar registrar) {\n    this.registrar = registrar;\n  }\n  public static void registerWith(Registrar registrar) {\n    final MethodChannel channel =\n        new MethodChannel(registrar.messenger(), \"github.com/jiajiabingcheng/phone_log\");\n    PhoneLogPlugin phoneLogPlugin = new PhoneLogPlugin(registrar);\n    channel.setMethodCallHandler(phoneLogPlugin);\n    registrar.addRequestPermissionsResultListener(phoneLogPlugin);\n  }\n  @Override\n  public void onMethodCall(MethodCall call, Result result) {\n    if (pendingResult != null) {\n      pendingResult.error(\"multiple_requests\", \"Cancelled by a second request.\", null);\n      pendingResult = null;\n    }\n    pendingResult = result;\n    switch (call.method) {\n      case \"checkPermission\":\n        pendingResult.success(checkPermission());\n        pendingResult = null;\n        break;\n      case \"requestPermission\":\n        requestPermission();\n        break;\n      case \"getPhoneLogs\":\n        String startDate = call.argument(\"startDate\");\n        String duration = call.argument(\"duration\");\n        fetchCallRecords(startDate, duration);\n        break;\n      default:\n        result.notImplemented();\n    }\n  }\n  private void requestPermission() {\n    Log.i(\"PhoneLogPlugin\", \"Requesting permission : \" + Manifest.permission.READ_CALL_LOG);\n    String[] perm = {Manifest.permission.READ_CALL_LOG};\n    registrar.activity().requestPermissions(perm, 0);\n  }\n  private String checkPermission() {\n    Log.i(\"PhoneLogPlugin\", \"Checking permission : \" + Manifest.permission.READ_CALL_LOG);\n    boolean isGranted =\n        PackageManager.PERMISSION_GRANTED\n            == registrar.activity().checkSelfPermission(Manifest.permission.READ_CALL_LOG);\n    if (isGranted) {\n      return \"granted\";\n    } else if (registrar\n        .activity()\n        .shouldShowRequestPermissionRationale(Manifest.permission.READ_CALL_LOG)) {\n      return \"denied\";\n    }\n    return \"deniedAndCannotRequest\";\n  }\n  @Override\n  public boolean onRequestPermissionsResult(int requestCode, String[] strings, int[] grantResults) {\n    boolean res = false;\n    if (requestCode == 0 && grantResults.length > 0) {\n      res = grantResults[0] == PackageManager.PERMISSION_GRANTED;\n      pendingResult.success(res);\n      pendingResult = null;\n    }\n    return res;\n  }\n  private static final String[] PROJECTION = {\n    CallLog.Calls.CACHED_FORMATTED_NUMBER,\n    CallLog.Calls.CACHED_MATCHED_NUMBER,\n    CallLog.Calls.TYPE,\n    CallLog.Calls.DATE,\n    CallLog.Calls.DURATION,\n  };\n  @TargetApi(Build.VERSION_CODES.M)\n  private void fetchCallRecords(String startDate, String duration) {\n    if (registrar.activity().checkSelfPermission(Manifest.permission.READ_CALL_LOG)\n        == PackageManager.PERMISSION_GRANTED) {\n      String selectionCondition = null;\n      if (startDate != null) {\n        selectionCondition = CallLog.Calls.DATE + \"> \" + startDate;\n      }\n      if (duration != null) {\n        String durationSelection = CallLog.Calls.DURATION + \"> \" + duration;\n        if (selectionCondition != null) {\n          selectionCondition = selectionCondition + \" AND \" + durationSelection;\n        } else {\n          selectionCondition = durationSelection;\n        }\n      }\n      Cursor cursor =\n          registrar\n              .context()\n              .getContentResolver()\n              .query(\n                  CallLog.Calls.CONTENT_URI,\n                  PROJECTION,\n                  selectionCondition,\n                  null,\n                  CallLog.Calls.DATE + \" DESC\");\n      try {\n        ArrayList<HashMap<String, Object>> records = getCallRecordMaps(cursor);\n        pendingResult.success(records);\n        pendingResult = null;\n      } catch (Exception e) {\n        Log.e(\"PhoneLog\", \"Error on fetching call record\" + e);\n        pendingResult.error(\"PhoneLog\", e.getMessage(), null);\n        pendingResult = null;\n      } finally {\n        if (cursor != null) {\n          cursor.close();\n        }\n      }\n    } else {\n      pendingResult.error(\"PhoneLog\", \"Permission is not granted\", null);\n      pendingResult = null;\n    }\n  }\n  /**\n   * Builds the list of call record maps from the cursor\n   *\n   * @param cursor\n   * @return the list of maps\n   */\n  private ArrayList<HashMap<String, Object>> getCallRecordMaps(Cursor cursor) {\n    ArrayList<HashMap<String, Object>> records = new ArrayList<>();\n    while (cursor != null && cursor.moveToNext()) {\n      CallRecord record = new CallRecord();\n      record.formattedNumber = cursor.getString(0);\n      record.number = cursor.getString(1);\n      record.callType = getCallType(cursor.getInt(2));\n      Date date = new Date(cursor.getLong(3));\n      Calendar cal = Calendar.getInstance();\n      cal.setTime(date);\n      record.dateYear = cal.get(Calendar.YEAR);\n      record.dateMonth = cal.get(Calendar.MONTH);\n      record.dateDay = cal.get(Calendar.DAY_OF_MONTH);\n      record.dateHour = cal.get(Calendar.HOUR_OF_DAY);\n      record.dateMinute = cal.get(Calendar.MINUTE);\n      record.dateSecond = cal.get(Calendar.SECOND);\n      record.duration = cursor.getLong(4);\n      records.add(record.toMap());\n    }\n    return records;\n  }\n  private String getCallType(int anInt) {\n    switch (anInt) {\n      case CallLog.Calls.INCOMING_TYPE:\n        return \"INCOMING_TYPE\";\n      case CallLog.Calls.OUTGOING_TYPE:\n        return \"OUTGOING_TYPE\";\n      case CallLog.Calls.MISSED_TYPE:\n        return \"MISSED_TYPE\";\n      default:\n        break;\n    }\n    return null;\n  }\n"]]}
{"hexsha": "e7e068f6915ee3571e8252f1302a20b1be0c84ea", "ext": "java", "lang": "Java", "content": "public class NetworkAutoRefresh extends BroadcastReceiver {\n\n    private static final Logger log = LoggerFactory.getLogger(NetworkAutoRefresh.class);\n\n    public static final String ACTION_RESCAN_INDEXED_FOLDERS = \"com.archos.mediaprovider.video.NetworkAutoRefresh\";\n    public static final String ACTION_FORCE_RESCAN_INDEXED_FOLDERS = \"com.archos.mediaprovider.video.NetworkAutoRefresh_force\";\n\n    private static final String AUTO_RESCAN_ON_APP_RESTART = \"auto_rescan_on_app_restart\";\n\n    public static final String AUTO_RESCAN_STARTING_TIME_PREF = \"auto_rescan_starting_time\";\n    public static final String AUTO_RESCAN_PERIOD = \"auto_rescan_period\";\n    public static final String AUTO_RESCAN_LAST_SCAN = \"auto_rescan_last_scan\";\n    public static final String AUTO_RESCAN_ERROR = \"auto_rescan_error\";\n    public static final int AUTO_RESCAN_ERROR_UNABLE_TO_REACH_HOST = -1;\n    public static final int AUTO_RESCAN_ERROR_NO_WIFI = -2;\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n\n        if(intent.getAction().equals(Intent.ACTION_BOOT_COMPLETED)) {\n            //reset alarm on boot\n            int startingTime = PreferenceManager.getDefaultSharedPreferences(context).getInt(AUTO_RESCAN_STARTING_TIME_PREF, -1);\n            int periode = PreferenceManager.getDefaultSharedPreferences(context).getInt(AUTO_RESCAN_PERIOD,-1);\n            if(startingTime!=-1&&periode>0){\n                NetworkScannerUtil.scheduleNewRescan(context,startingTime,periode,false);\n            }\n            //start rescan if lastscan + period < current time (when has booted after scheduled time)\n        }\n        else if(intent.getAction().equals(ACTION_RESCAN_INDEXED_FOLDERS)||\n                intent.getAction().equals(ACTION_FORCE_RESCAN_INDEXED_FOLDERS)) {\n            SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(context);\n            /*\n                do not scan if auto scan and already scan lately (for example on restart of device) or if already scanning\n             */\n            if(((pref.getInt(AUTO_RESCAN_PERIOD,0)<=0)\n                    &&!intent.getAction().equals(ACTION_FORCE_RESCAN_INDEXED_FOLDERS))\n                    || com.archos.mediaprovider.video.NetworkScannerServiceVideo.isScannerAlive()\n                    ) {\n                SimpleDateFormat sdf = new SimpleDateFormat(\"MM/dd/yyyy HH:mm:ss.SSS\");\n                Date dt = new Date();\n                String S = sdf.format(dt);\n                log.debug(\"onReceive: skipping rescan : \" + S + \" period = \" + pref.getInt(AUTO_RESCAN_PERIOD, 0)+\" is scanning ? \"+String.valueOf(com.archos.mediaprovider.video.NetworkScannerReceiver.isScannerWorking()));\n                return;\n            }\n            pref.edit().putLong(AUTO_RESCAN_LAST_SCAN, System.currentTimeMillis()).commit();\n            log.debug(\"onReceive: received rescan intent\");\n            //updating\n            Cursor cursor = ShortcutDbAdapter.VIDEO.queryAllShortcuts(context);\n            List<Uri> toUpdate = new ArrayList<>();\n            if (cursor.getCount() > 0) {\n                int pathKey = cursor.getColumnIndex(ShortcutDbAdapter.KEY_PATH);\n                cursor.moveToFirst();\n                do {\n                    Uri uri = Uri.parse(cursor.getString(pathKey));\n                    toUpdate.add(uri);\n                }\n                while (cursor.moveToNext());\n            }\n            cursor.close();\n            ShortcutDbAdapter.VIDEO.close();\n            if(NetworkState.isLocalNetworkConnected(context)) {\n                PreferenceManager.getDefaultSharedPreferences(context).edit().putInt(AUTO_RESCAN_ERROR, 0).commit();//reset error\n                for (Uri uri : toUpdate) {\n                    log.debug(\"onReceive: scanning \"+uri);\n                    if(\"upnp\".equals(uri.getScheme())){ //start upnp service\n                        UpnpServiceManager.startServiceIfNeeded(context);\n                    }\n                    if(\"ftp\".equalsIgnoreCase(uri.getScheme())||\"ftps\".equals(uri.getScheme()))\n                        Session.getInstance().removeFTPClient(uri);\n                    if(\"sftp\".equalsIgnoreCase(uri.getScheme()))\n                        SFTPSession.getInstance().removeSession(uri);\n                    Intent refreshIntent = new Intent(ArchosMediaIntent.ACTION_VIDEO_SCANNER_SCAN_FILE, uri);\n                    refreshIntent.putExtra(NetworkScannerServiceVideo.RECORD_ON_FAIL_PREFERENCE, AUTO_RESCAN_ERROR);\n                    refreshIntent.putExtra(NetworkScannerServiceVideo.RECORD_END_OF_SCAN_PREFERENCE, AUTO_RESCAN_LAST_SCAN);\n                    refreshIntent.setPackage(ArchosUtils.getGlobalContext().getPackageName());\n                    context.sendBroadcast(refreshIntent);\n                }\n            }\n            else{\n                PreferenceManager.getDefaultSharedPreferences(context).edit().putInt(AUTO_RESCAN_ERROR, AUTO_RESCAN_ERROR_NO_WIFI).commit();//reset error\n                NetworkScannerServiceVideo.notifyListeners();\n            }\n            log.debug(\"onReceive: received rescan intent end\");\n        }\n    }\n    private static final AppState.OnForeGroundListener sForeGroundListener = new AppState.OnForeGroundListener() {\n        @Override\n        public void onForeGroundState(Context applicationContext, boolean foreground) {\n            if (foreground&&autoRescanAtStart(applicationContext))\n                forceRescan(applicationContext);\n        }\n    };\n    public static void init() {\n        AppState.addOnForeGroundListener(sForeGroundListener);\n    }\n\n    public static void forceRescan(Context context){\n        Intent intent = new Intent(context, NetworkAutoRefresh.class);\n        intent.setAction(ACTION_FORCE_RESCAN_INDEXED_FOLDERS);\n        intent.setPackage(ArchosUtils.getGlobalContext().getPackageName());\n        context.sendBroadcast(intent);\n    }\n\n    public static int getLastError(Context context){\n        return  PreferenceManager.getDefaultSharedPreferences(context).getInt(AUTO_RESCAN_ERROR, 0);\n    }\n    public static boolean autoRescanAtStart(Context context) {\n        return PreferenceManager.getDefaultSharedPreferences(context).getBoolean(AUTO_RESCAN_ON_APP_RESTART,false);\n    }\n    public static void setAutoRescanAtStart(Context context, boolean autoRescanAtStart) {\n        PreferenceManager.getDefaultSharedPreferences(context).edit().putBoolean(AUTO_RESCAN_ON_APP_RESTART,autoRescanAtStart).apply();\n    }\n\n    public static int getRescanPeriod(Context context) {\n        return PreferenceManager.getDefaultSharedPreferences(context).getInt(AUTO_RESCAN_PERIOD, 0);\n    }\n}", "class_id": 0, "repo": "goyourfly/NovaCustom", "file": "MediaLib/src/com/archos/mediaprovider/video/NetworkAutoRefresh.java", "last_update_at": "2019-07-07T16:08:45+00:00", "question_id": "e7e068f6915ee3571e8252f1302a20b1be0c84ea", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NetworkAutoRefresh extends BroadcastReceiver {\n    private static final Logger log = LoggerFactory.getLogger(NetworkAutoRefresh.class);\n    public static final String ACTION_RESCAN_INDEXED_FOLDERS = \"com.archos.mediaprovider.video.NetworkAutoRefresh\";\n    public static final String ACTION_FORCE_RESCAN_INDEXED_FOLDERS = \"com.archos.mediaprovider.video.NetworkAutoRefresh_force\";\n    private static final String AUTO_RESCAN_ON_APP_RESTART = \"auto_rescan_on_app_restart\";\n    public static final String AUTO_RESCAN_STARTING_TIME_PREF = \"auto_rescan_starting_time\";\n    public static final String AUTO_RESCAN_PERIOD = \"auto_rescan_period\";\n    public static final String AUTO_RESCAN_LAST_SCAN = \"auto_rescan_last_scan\";\n    public static final String AUTO_RESCAN_ERROR = \"auto_rescan_error\";\n    public static final int AUTO_RESCAN_ERROR_UNABLE_TO_REACH_HOST = -1;\n    public static final int AUTO_RESCAN_ERROR_NO_WIFI = -2;\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        if(intent.getAction().equals(Intent.ACTION_BOOT_COMPLETED)) {\n            //reset alarm on boot\n            int startingTime = PreferenceManager.getDefaultSharedPreferences(context).getInt(AUTO_RESCAN_STARTING_TIME_PREF, -1);\n            int periode = PreferenceManager.getDefaultSharedPreferences(context).getInt(AUTO_RESCAN_PERIOD,-1);\n            if(startingTime!=-1&&periode>0){\n                NetworkScannerUtil.scheduleNewRescan(context,startingTime,periode,false);\n            }\n            //start rescan if lastscan + period < current time (when has booted after scheduled time)\n        }\n        else if(intent.getAction().equals(ACTION_RESCAN_INDEXED_FOLDERS)||\n                intent.getAction().equals(ACTION_FORCE_RESCAN_INDEXED_FOLDERS)) {\n            SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(context);\n            /*\n                do not scan if auto scan and already scan lately (for example on restart of device) or if already scanning\n             */\n            if(((pref.getInt(AUTO_RESCAN_PERIOD,0)<=0)\n                    &&!intent.getAction().equals(ACTION_FORCE_RESCAN_INDEXED_FOLDERS))\n                    || com.archos.mediaprovider.video.NetworkScannerServiceVideo.isScannerAlive()\n                    ) {\n                SimpleDateFormat sdf = new SimpleDateFormat(\"MM/dd/yyyy HH:mm:ss.SSS\");\n                Date dt = new Date();\n                String S = sdf.format(dt);\n                log.debug(\"onReceive: skipping rescan : \" + S + \" period = \" + pref.getInt(AUTO_RESCAN_PERIOD, 0)+\" is scanning ? \"+String.valueOf(com.archos.mediaprovider.video.NetworkScannerReceiver.isScannerWorking()));\n                return;\n            }\n            pref.edit().putLong(AUTO_RESCAN_LAST_SCAN, System.currentTimeMillis()).commit();\n            log.debug(\"onReceive: received rescan intent\");\n            //updating\n            Cursor cursor = ShortcutDbAdapter.VIDEO.queryAllShortcuts(context);\n            List<Uri> toUpdate = new ArrayList<>();\n            if (cursor.getCount() > 0) {\n                int pathKey = cursor.getColumnIndex(ShortcutDbAdapter.KEY_PATH);\n                cursor.moveToFirst();\n                do {\n                    Uri uri = Uri.parse(cursor.getString(pathKey));\n                    toUpdate.add(uri);\n                }\n                while (cursor.moveToNext());\n            }\n            cursor.close();\n            ShortcutDbAdapter.VIDEO.close();\n            if(NetworkState.isLocalNetworkConnected(context)) {\n                PreferenceManager.getDefaultSharedPreferences(context).edit().putInt(AUTO_RESCAN_ERROR, 0).commit();//reset error\n                for (Uri uri : toUpdate) {\n                    log.debug(\"onReceive: scanning \"+uri);\n                    if(\"upnp\".equals(uri.getScheme())){ //start upnp service\n                        UpnpServiceManager.startServiceIfNeeded(context);\n                    }\n                    if(\"ftp\".equalsIgnoreCase(uri.getScheme())||\"ftps\".equals(uri.getScheme()))\n                        Session.getInstance().removeFTPClient(uri);\n                    if(\"sftp\".equalsIgnoreCase(uri.getScheme()))\n                        SFTPSession.getInstance().removeSession(uri);\n                    Intent refreshIntent = new Intent(ArchosMediaIntent.ACTION_VIDEO_SCANNER_SCAN_FILE, uri);\n                    refreshIntent.putExtra(NetworkScannerServiceVideo.RECORD_ON_FAIL_PREFERENCE, AUTO_RESCAN_ERROR);\n                    refreshIntent.putExtra(NetworkScannerServiceVideo.RECORD_END_OF_SCAN_PREFERENCE, AUTO_RESCAN_LAST_SCAN);\n                    refreshIntent.setPackage(ArchosUtils.getGlobalContext().getPackageName());\n                    context.sendBroadcast(refreshIntent);\n                }\n            }\n            else{\n                PreferenceManager.getDefaultSharedPreferences(context).edit().putInt(AUTO_RESCAN_ERROR, AUTO_RESCAN_ERROR_NO_WIFI).commit();//reset error\n                NetworkScannerServiceVideo.notifyListeners();\n            }\n            log.debug(\"onReceive: received rescan intent end\");\n        }\n    }\n    private static final AppState.OnForeGroundListener sForeGroundListener = new AppState.OnForeGroundListener() {\n        @Override\n        public void onForeGroundState(Context applicationContext, boolean foreground) {\n            if (foreground&&autoRescanAtStart(applicationContext))\n                forceRescan(applicationContext);\n        }\n    };\n    public static void init() {\n        AppState.addOnForeGroundListener(sForeGroundListener);\n    }\n    public static void forceRescan(Context context){\n        Intent intent = new Intent(context, NetworkAutoRefresh.class);\n        intent.setAction(ACTION_FORCE_RESCAN_INDEXED_FOLDERS);\n        intent.setPackage(ArchosUtils.getGlobalContext().getPackageName());\n        context.sendBroadcast(intent);\n    }\n    public static int getLastError(Context context){\n        return  PreferenceManager.getDefaultSharedPreferences(context).getInt(AUTO_RESCAN_ERROR, 0);\n    }\n    public static boolean autoRescanAtStart(Context context) {\n        return PreferenceManager.getDefaultSharedPreferences(context).getBoolean(AUTO_RESCAN_ON_APP_RESTART,false);\n    }\n    public static void setAutoRescanAtStart(Context context, boolean autoRescanAtStart) {\n        PreferenceManager.getDefaultSharedPreferences(context).edit().putBoolean(AUTO_RESCAN_ON_APP_RESTART,autoRescanAtStart).apply();\n    }\n    public static int getRescanPeriod(Context context) {\n        return PreferenceManager.getDefaultSharedPreferences(context).getInt(AUTO_RESCAN_PERIOD, 0);\n    }\n"]]}
{"hexsha": "de4fa7e508a8ccd4630e5d932cdec5820ffdb6a8", "ext": "java", "lang": "Java", "content": "@Slf4j\n@Configuration\npublic class AsyncPoolConfig extends WebMvcConfigurerAdapter {\n\n    @Bean(name = \"asyncPoolTaskExecutor\")\n    public ThreadPoolTaskExecutor getAsyncThreadPoolTaskExecutor() {\n        ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();\n        taskExecutor.setCorePoolSize(20);\n        taskExecutor.setMaxPoolSize(200);\n        taskExecutor.setQueueCapacity(25);\n        taskExecutor.setKeepAliveSeconds(200);\n        taskExecutor.setThreadNamePrefix(\"MvcAsync-callable-\");\n        taskExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());\n        taskExecutor.initialize();\n        return taskExecutor;\n    }\n\n    @Override\n    public void configureAsyncSupport(final AsyncSupportConfigurer configurer) {\n        configurer.setDefaultTimeout(60 * 1000);\n        configurer.registerCallableInterceptors(timeoutInterceptor());\n        configurer.setTaskExecutor(getAsyncThreadPoolTaskExecutor());\n    }\n\n    @Bean\n    public TimeoutCallableInterceptor timeoutInterceptor() {\n        return new TimeoutCallableInterceptor();\n    }\n\n    static class TimeoutCallableInterceptor implements CallableProcessingInterceptor {\n        @Override\n        public <T> void beforeConcurrentHandling(NativeWebRequest request, Callable<T> task) throws Exception {\n        }\n\n        @Override\n        public <T> void preProcess(NativeWebRequest request, Callable<T> task) throws Exception {\n        }\n\n        @Override\n        public <T> void postProcess(NativeWebRequest request, Callable<T> task, Object concurrentResult) throws Exception {\n        }\n\n        @Override\n        public <T> Object handleTimeout(NativeWebRequest request, Callable<T> task) throws Exception {\n            log.error(\"\u4efb\u52a1\u8d85\u65f6:{}\", task.getClass().getName());\n            return null;\n        }\n\n        @Override\n        public <T> void afterCompletion(NativeWebRequest request, Callable<T> task) throws Exception {\n            log.error(\"\u4efb\u52a1\u6b63\u5e38\u7ed3\u675f:{}\", task.getClass().getName());\n        }\n    }\n\n    static class AsyncHandlerInterceptor implements org.springframework.web.servlet.AsyncHandlerInterceptor {\n        @Override\n        public void afterConcurrentHandlingStarted(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {\n        }\n\n        @Override\n        public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {\n            return false;\n        }\n\n        @Override\n        public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {\n        }\n\n        @Override\n        public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {\n\n        }\n    }\n}", "class_id": 0, "repo": "LuVx21/spring-boot", "file": "spring-boot-async/src/main/java/org/luvx/config/AsyncPoolConfig.java", "last_update_at": "2019-10-22T03:17:05+00:00", "question_id": "de4fa7e508a8ccd4630e5d932cdec5820ffdb6a8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Slf4j\n@Configuration\npublic class AsyncPoolConfig extends WebMvcConfigurerAdapter {\n    @Bean(name = \"asyncPoolTaskExecutor\")\n    public ThreadPoolTaskExecutor getAsyncThreadPoolTaskExecutor() {\n        ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();\n        taskExecutor.setCorePoolSize(20);\n        taskExecutor.setMaxPoolSize(200);\n        taskExecutor.setQueueCapacity(25);\n        taskExecutor.setKeepAliveSeconds(200);\n        taskExecutor.setThreadNamePrefix(\"MvcAsync-callable-\");\n        taskExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());\n        taskExecutor.initialize();\n        return taskExecutor;\n    }\n    @Override\n    public void configureAsyncSupport(final AsyncSupportConfigurer configurer) {\n        configurer.setDefaultTimeout(60 * 1000);\n        configurer.registerCallableInterceptors(timeoutInterceptor());\n        configurer.setTaskExecutor(getAsyncThreadPoolTaskExecutor());\n    }\n    @Bean\n    public TimeoutCallableInterceptor timeoutInterceptor() {\n        return new TimeoutCallableInterceptor();\n    }\n    static class TimeoutCallableInterceptor implements CallableProcessingInterceptor {\n        @Override\n        public <T> void beforeConcurrentHandling(NativeWebRequest request, Callable<T> task) throws Exception {\n        }\n        @Override\n        public <T> void preProcess(NativeWebRequest request, Callable<T> task) throws Exception {\n        }\n        @Override\n        public <T> void postProcess(NativeWebRequest request, Callable<T> task, Object concurrentResult) throws Exception {\n        }\n        @Override\n        public <T> Object handleTimeout(NativeWebRequest request, Callable<T> task) throws Exception {\n            log.error(\"\u4efb\u52a1\u8d85\u65f6:{}\", task.getClass().getName());\n            return null;\n        }\n        @Override\n        public <T> void afterCompletion(NativeWebRequest request, Callable<T> task) throws Exception {\n            log.error(\"\u4efb\u52a1\u6b63\u5e38\u7ed3\u675f:{}\", task.getClass().getName());\n        }\n    }\n    static class AsyncHandlerInterceptor implements org.springframework.web.servlet.AsyncHandlerInterceptor {\n        @Override\n        public void afterConcurrentHandlingStarted(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {\n        }\n        @Override\n        public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {\n            return false;\n        }\n        @Override\n        public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {\n        }\n        @Override\n        public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {\n        }\n    }\n"]]}
{"hexsha": "7ebaf9ef0e6d725cf6d6043ed9966d8710fe3a12", "ext": "java", "lang": "Java", "content": "public class CommandManager {\n\n    private Map<String, CommandTemplate> commands = new HashMap<>();\n    private Map<String, List<CommandExecutor>> commandExecutors = new HashMap<>();\n    private String customChar;\n    private TS3Api api;\n    private List<Thread> commandThreads = new ArrayList<>();\n    private Thread listenerThread;\n    private List<String> registeredCommands = new ArrayList<>();\n    private Teamspeak3Bot instance;\n\n    public CommandManager(TS3Api api, char customChar, Teamspeak3Bot instance) {\n\n        registeredCommands.add(\"quit\");\n        registeredCommands.add(\"exit\");\n        registeredCommands.add(\"stop\");\n        registeredCommands.add(\"uploadErrorLog\");\n\n        this.customChar = String.valueOf(customChar);\n        this.api = api;\n        this.instance = instance;\n\n        AtomicBoolean breakOut = new AtomicBoolean(false);\n\n        listenerThread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(60000);\n                    int x = commandThreads.size();\n\n                    if (x == 0) {\n                        instance.debug(Language.COMMAND, \"Nothing found to remove.\");\n                        run();\n                    }\n\n                    for (int i = x - 1; i >= 0; i--) {\n\n                        Thread thr = commandThreads.get(i);\n                        if (thr.isInterrupted() || !thr.isAlive()) {\n                            commandThreads.remove(thr);\n                            instance.debug(Language.COMMAND, \"Thread \" + thr.getName() + \" removed from list.\");\n                        }\n                    }\n                } catch (Exception x) {\n                    x.printStackTrace();\n                    breakOut.set(true);\n                }\n                if (!breakOut.get()) {\n                    run();\n                }\n            }\n        }, \"CommandManager-Thread\");\n        listenerThread.start();\n    }\n\n\n    public CommandTemplate registerNewCommand(CommandTemplate cmdTemp) {\n        commands.put(cmdTemp.getCommand(), cmdTemp);\n        return cmdTemp;\n    }\n\n    public CommandTemplate getCommand(String name) {\n        return commands.getOrDefault(name, null);\n    }\n\n    public CommandTemplate getCommand(JavaPlugin plugin, String str, CommandExecutor cmdEx, CommandTemplate cmdTemp) {\n        return getCommand(plugin.getName(), str, cmdEx, cmdTemp);\n    }\n\n    public CommandTemplate getCommand(String pluginName, String str, CommandExecutor cmdEx, CommandTemplate cmdTemp) {\n        CommandTemplate cmd = commands.get(str);\n\n        if (cmd == null) {\n            cmd = registerNewCommand(cmdTemp);\n        }\n\n        List<CommandExecutor> executors = commandExecutors.getOrDefault(str, new ArrayList<>());\n        executors.add(cmdEx);\n\n        commandExecutors.put(str, executors);\n        List<String> aliasList = cmd.getAliases();\n        if (!aliasList.contains(str)) {\n            aliasList.add(str);\n        }\n\n        // Command cmd = new Command(aliasList.toArray(new String[]{}), description, str, pluginName);\n        commands.put(str, cmd);\n        for (String s : cmd.getAliases()) {\n            registeredCommands.add(pluginName + \":\" + s);\n            registeredCommands.add(s);\n        }\n        return cmd;\n    }\n\n    public boolean executeCommand(String cmd, String[] args, CommandSender source, int clientId, int channelId, boolean run) {\n\n        String cmdString = getCommandStringFromAlias(resolveCommand(cmd));\n\n        if (!Validator.notNull(api)) {\n\n            if (commands.containsKey(cmdString)) {\n                if (run) {\n                    Map<String, String> map = new HashMap<>();\n                    map.put(\"invokerid\", clientId + \"\");\n                    map.put(\"channelid\", channelId + \"\");\n                    parseRun(cmd, args, source, map);\n                }\n                return true;\n            }\n        } else\n            Teamspeak3Bot.getLogger().error(Language.COMMAND + \"API is null !!!!\");\n        return false;\n    }\n\n    private void parseRun(String cmd, String[] args, CommandSender source, Map<String, String> map) {\n\n        List<CommandExecutor> executors = commandExecutors.getOrDefault(getCommandStringFromAlias(resolveCommand(cmd)), new ArrayList<>());\n        CommandTemplate cmdTemp = commands.get(getCommandStringFromAlias(resolveCommand(cmd)));\n\n        for (CommandExecutor executor : executors) {\n            //To prevent a constant loop in the command\n            Thread thread = new Thread(() -> executor.run(source, new Command(cmdTemp, map), cmd, args), cmdTemp.getCommand() + \"-\" + commandThreads.size());\n            commandThreads.add(thread);\n            instance.debug(Language.COMMAND, thread.getName());\n\n            thread.start();\n        }\n    }\n\n    public boolean checkCommand(String cmdString, int clientId, CommandSender source) {\n        return checkCommand(new String[]{cmdString}, clientId, source);\n    }\n\n    public boolean checkCommand(String[] cmd, int clientId, CommandSender source) {\n        List<String> aList = new ArrayList<>();\n        Collections.addAll(aList, cmd);\n\n        String consoleMessage = \"Command From %source%: \" + aList.get(0);\n\n        aList.set(0, aList.get(0).replaceFirst(customChar, \"\"));\n        consoleMessage = consoleMessage.replaceAll(\"%source%\", source.toString().toLowerCase());\n\n        instance.debug(Language.COMMAND, consoleMessage);\n        instance.debug(Language.COMMAND, \"Custom Prefix Key: \" + customChar);\n\n        String str = getCommandStringFromAlias(resolveCommand(aList.get(0)));\n\n        if (!(source instanceof ConsoleCommandSender) && !(cmd[0].startsWith(customChar))) {\n            return false;\n        }\n\n        if (str != null) {\n            CommandTemplate cCommand = commands.get(str);\n            String cPlugin = cCommand.getPlugin();\n            List<String> cAliases = cCommand.getAliases();\n            instance.debug(Language.COMMAND, cPlugin + \":\" + str + \", \" + Arrays.toString(cAliases.toArray()));\n            return true;\n        }\n\n        source.sendMessage(0, clientId, \"Unknown Command: \" + cmd[0]);\n        source.sendMessage(0, clientId, \"Please use help or ? for help\");\n        return false;\n    }\n\n    public String getCommandStringFromAlias(String alias) {\n\n        for (String key : commands.keySet()) {\n            if (alias.equalsIgnoreCase(key)) {\n                return key;\n            }\n            List<String> values = commands.get(key).getAliases();\n            for (String value : values) {\n                if (alias.equalsIgnoreCase(value)) {\n                    return key;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    public String resolveCommand(String arg) {\n        String[] str = arg.split(\":+\");\n        String command = \"\";\n\n        if (str.length == 1) {\n            command = str[0];\n        } else if (str.length > 1) {\n            if (commands.containsKey(getCommandStringFromAlias(str[1]))) {\n                if (commands.get(getCommandStringFromAlias(str[1])).getPlugin().equalsIgnoreCase(str[0])) {\n                    command = str[1];\n                }\n            }\n        }\n        return command;\n    }\n\n    public String getCommandFromArray(String[] cmdArray) {\n        return cmdArray[0].replaceFirst(String.valueOf(customChar), \"\");\n    }\n\n    public List<String> getCommandList() {\n        return registeredCommands;\n    }\n\n    public Map<String, CommandTemplate> getCommands() {\n        return commands;\n    }\n}", "class_id": 0, "repo": "blombler008/Teamspeak-3-Bot", "file": "src/main/java/com/github/blombler008/teamspeak3bot/commands/CommandManager.java", "last_update_at": "2019-04-30T20:29:56+00:00", "question_id": "7ebaf9ef0e6d725cf6d6043ed9966d8710fe3a12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CommandManager {\n    private Map<String, CommandTemplate> commands = new HashMap<>();\n    private Map<String, List<CommandExecutor>> commandExecutors = new HashMap<>();\n    private String customChar;\n    private TS3Api api;\n    private List<Thread> commandThreads = new ArrayList<>();\n    private Thread listenerThread;\n    private List<String> registeredCommands = new ArrayList<>();\n    private Teamspeak3Bot instance;\n    public CommandManager(TS3Api api, char customChar, Teamspeak3Bot instance) {\n        registeredCommands.add(\"quit\");\n        registeredCommands.add(\"exit\");\n        registeredCommands.add(\"stop\");\n        registeredCommands.add(\"uploadErrorLog\");\n        this.customChar = String.valueOf(customChar);\n        this.api = api;\n        this.instance = instance;\n        AtomicBoolean breakOut = new AtomicBoolean(false);\n        listenerThread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(60000);\n                    int x = commandThreads.size();\n                    if (x == 0) {\n                        instance.debug(Language.COMMAND, \"Nothing found to remove.\");\n                        run();\n                    }\n                    for (int i = x - 1; i >= 0; i--) {\n                        Thread thr = commandThreads.get(i);\n                        if (thr.isInterrupted() || !thr.isAlive()) {\n                            commandThreads.remove(thr);\n                            instance.debug(Language.COMMAND, \"Thread \" + thr.getName() + \" removed from list.\");\n                        }\n                    }\n                } catch (Exception x) {\n                    x.printStackTrace();\n                    breakOut.set(true);\n                }\n                if (!breakOut.get()) {\n                    run();\n                }\n            }\n        }, \"CommandManager-Thread\");\n        listenerThread.start();\n    }\n    public CommandTemplate registerNewCommand(CommandTemplate cmdTemp) {\n        commands.put(cmdTemp.getCommand(), cmdTemp);\n        return cmdTemp;\n    }\n    public CommandTemplate getCommand(String name) {\n        return commands.getOrDefault(name, null);\n    }\n    public CommandTemplate getCommand(JavaPlugin plugin, String str, CommandExecutor cmdEx, CommandTemplate cmdTemp) {\n        return getCommand(plugin.getName(), str, cmdEx, cmdTemp);\n    }\n    public CommandTemplate getCommand(String pluginName, String str, CommandExecutor cmdEx, CommandTemplate cmdTemp) {\n        CommandTemplate cmd = commands.get(str);\n        if (cmd == null) {\n            cmd = registerNewCommand(cmdTemp);\n        }\n        List<CommandExecutor> executors = commandExecutors.getOrDefault(str, new ArrayList<>());\n        executors.add(cmdEx);\n        commandExecutors.put(str, executors);\n        List<String> aliasList = cmd.getAliases();\n        if (!aliasList.contains(str)) {\n            aliasList.add(str);\n        }\n        // Command cmd = new Command(aliasList.toArray(new String[]{}), description, str, pluginName);\n        commands.put(str, cmd);\n        for (String s : cmd.getAliases()) {\n            registeredCommands.add(pluginName + \":\" + s);\n            registeredCommands.add(s);\n        }\n        return cmd;\n    }\n    public boolean executeCommand(String cmd, String[] args, CommandSender source, int clientId, int channelId, boolean run) {\n        String cmdString = getCommandStringFromAlias(resolveCommand(cmd));\n        if (!Validator.notNull(api)) {\n            if (commands.containsKey(cmdString)) {\n                if (run) {\n                    Map<String, String> map = new HashMap<>();\n                    map.put(\"invokerid\", clientId + \"\");\n                    map.put(\"channelid\", channelId + \"\");\n                    parseRun(cmd, args, source, map);\n                }\n                return true;\n            }\n        } else\n            Teamspeak3Bot.getLogger().error(Language.COMMAND + \"API is null !!!!\");\n        return false;\n    }\n    private void parseRun(String cmd, String[] args, CommandSender source, Map<String, String> map) {\n        List<CommandExecutor> executors = commandExecutors.getOrDefault(getCommandStringFromAlias(resolveCommand(cmd)), new ArrayList<>());\n        CommandTemplate cmdTemp = commands.get(getCommandStringFromAlias(resolveCommand(cmd)));\n        for (CommandExecutor executor : executors) {\n            //To prevent a constant loop in the command\n            Thread thread = new Thread(() -> executor.run(source, new Command(cmdTemp, map), cmd, args), cmdTemp.getCommand() + \"-\" + commandThreads.size());\n            commandThreads.add(thread);\n            instance.debug(Language.COMMAND, thread.getName());\n            thread.start();\n        }\n    }\n    public boolean checkCommand(String cmdString, int clientId, CommandSender source) {\n        return checkCommand(new String[]{cmdString}, clientId, source);\n    }\n    public boolean checkCommand(String[] cmd, int clientId, CommandSender source) {\n        List<String> aList = new ArrayList<>();\n        Collections.addAll(aList, cmd);\n        String consoleMessage = \"Command From %source%: \" + aList.get(0);\n        aList.set(0, aList.get(0).replaceFirst(customChar, \"\"));\n        consoleMessage = consoleMessage.replaceAll(\"%source%\", source.toString().toLowerCase());\n        instance.debug(Language.COMMAND, consoleMessage);\n        instance.debug(Language.COMMAND, \"Custom Prefix Key: \" + customChar);\n        String str = getCommandStringFromAlias(resolveCommand(aList.get(0)));\n        if (!(source instanceof ConsoleCommandSender) && !(cmd[0].startsWith(customChar))) {\n            return false;\n        }\n        if (str != null) {\n            CommandTemplate cCommand = commands.get(str);\n            String cPlugin = cCommand.getPlugin();\n            List<String> cAliases = cCommand.getAliases();\n            instance.debug(Language.COMMAND, cPlugin + \":\" + str + \", \" + Arrays.toString(cAliases.toArray()));\n            return true;\n        }\n        source.sendMessage(0, clientId, \"Unknown Command: \" + cmd[0]);\n        source.sendMessage(0, clientId, \"Please use help or ? for help\");\n        return false;\n    }\n    public String getCommandStringFromAlias(String alias) {\n        for (String key : commands.keySet()) {\n            if (alias.equalsIgnoreCase(key)) {\n                return key;\n            }\n            List<String> values = commands.get(key).getAliases();\n            for (String value : values) {\n                if (alias.equalsIgnoreCase(value)) {\n                    return key;\n                }\n            }\n        }\n        return null;\n    }\n    public String resolveCommand(String arg) {\n        String[] str = arg.split(\":+\");\n        String command = \"\";\n        if (str.length == 1) {\n            command = str[0];\n        } else if (str.length > 1) {\n            if (commands.containsKey(getCommandStringFromAlias(str[1]))) {\n                if (commands.get(getCommandStringFromAlias(str[1])).getPlugin().equalsIgnoreCase(str[0])) {\n                    command = str[1];\n                }\n            }\n        }\n        return command;\n    }\n    public String getCommandFromArray(String[] cmdArray) {\n        return cmdArray[0].replaceFirst(String.valueOf(customChar), \"\");\n    }\n    public List<String> getCommandList() {\n        return registeredCommands;\n    }\n    public Map<String, CommandTemplate> getCommands() {\n        return commands;\n    }\n"]]}
{"hexsha": "c8d23c77029cd24b93d6adcaf81358862f8432d5", "ext": "java", "lang": "Java", "content": "public class MyWikiModel extends WikiModel {\n\n    /**\n     * Interwiki links pointing to other wikis in the web\n     */\n    private static final String[] INTERLANGUAGE_STRINGS = { \"en\", \"de\", \"fr\",\n            \"it\", \"pl\", \"es\", \"ja\", \"ru\", \"nl\", \"pt\", \"sv\", \"zh\", \"ca\", \"uk\",\n            \"no\", \"fi\", \"hu\", \"cs\", \"ro\", \"tr\", \"ko\", \"vi\", \"da\", \"ar\", \"eo\",\n            \"sr\", \"id\", \"lt\", \"vo\", \"sk\", \"he\", \"fa\", \"bg\", \"sl\", \"eu\", \"war\",\n            \"lmo\", \"et\", \"hr\", \"new\", \"te\", \"nn\", \"th\", \"gl\", \"el\", \"ceb\",\n            \"simple\", \"ms\", \"ht\", \"bs\", \"bpy\", \"lb\", \"ka\", \"is\", \"sq\", \"la\",\n            \"br\", \"hi\", \"az\", \"bn\", \"mk\", \"mr\", \"sh\", \"tl\", \"cy\", \"io\", \"pms\",\n            \"lv\", \"ta\", \"su\", \"oc\", \"jv\", \"nap\", \"nds\", \"scn\", \"be\", \"ast\",\n            \"ku\", \"wa\", \"af\", \"be-x-old\", \"an\", \"ksh\", \"szl\", \"fy\", \"frr\",\n            \"yue\", \"ur\", \"ia\", \"ga\", \"yi\", \"sw\", \"als\", \"hy\", \"am\", \"roa-rup\",\n            \"map-bms\", \"bh\", \"co\", \"cv\", \"dv\", \"nds-nl\", \"fo\", \"fur\", \"glk\",\n            \"gu\", \"ilo\", \"kn\", \"pam\", \"csb\", \"kk\", \"km\", \"lij\", \"li\", \"ml\",\n            \"gv\", \"mi\", \"mt\", \"nah\", \"ne\", \"nrm\", \"se\", \"nov\", \"qu\", \"os\",\n            \"pi\", \"pag\", \"ps\", \"pdc\", \"rm\", \"bat-smg\", \"sa\", \"gd\", \"sco\", \"sc\",\n            \"si\", \"tg\", \"roa-tara\", \"tt\", \"to\", \"tk\", \"hsb\", \"uz\", \"vec\",\n            \"fiu-vro\", \"wuu\", \"vls\", \"yo\", \"diq\", \"zh-min-nan\", \"zh-classical\",\n            \"frp\", \"lad\", \"bar\", \"bcl\", \"kw\", \"mn\", \"haw\", \"ang\", \"ln\", \"ie\",\n            \"wo\", \"tpi\", \"ty\", \"crh\", \"jbo\", \"ay\", \"zea\", \"eml\", \"ky\", \"ig\",\n            \"or\", \"mg\", \"cbk-zam\", \"kg\", \"arc\", \"rmy\", \"gn\", \"mo (closed)\",\n            \"so\", \"kab\", \"ks\", \"stq\", \"ce\", \"udm\", \"mzn\", \"pap\", \"cu\", \"sah\",\n            \"tet\", \"sd\", \"lo\", \"ba\", \"pnb\", \"iu\", \"na\", \"got\", \"bo\", \"dsb\",\n            \"chr\", \"cdo\", \"hak\", \"om\", \"my\", \"sm\", \"ee\", \"pcd\", \"ug\", \"as\",\n            \"ti\", \"av\", \"bm\", \"zu\", \"pnt\", \"nv\", \"cr\", \"pih\", \"ss\", \"ve\", \"bi\",\n            \"rw\", \"ch\", \"arz\", \"xh\", \"kl\", \"ik\", \"bug\", \"dz\", \"ts\", \"tn\", \"kv\",\n            \"tum\", \"xal\", \"st\", \"tw\", \"bxr\", \"ak\", \"ab\", \"ny\", \"fj\", \"lbe\",\n            \"ki\", \"za\", \"ff\", \"lg\", \"sn\", \"ha\", \"sg\", \"ii\", \"cho\", \"rn\", \"mh\",\n            \"chy\", \"ng\", \"kj\", \"ho\", \"mus\", \"kr\", \"hz\", \"mwl\", \"pa\", \"ace\",\n            \"bat-smg\", \"bjn\", \"cbk-zam\", \"cdo\", \"ceb\", \"crh\", \"dsb\", \"eml\",\n            \"ext\", \"fiu-vro\", \"frp\", \"frr\", \"gag\", \"gan\", \"hak\", \"kaa\", \"kab\",\n            \"kbd\", \"koi\", \"krc\", \"ksh\", \"lad\", \"lbe\", \"lmo\", \"map-bms\", \"mdf\",\n            \"mrj\", \"mwl\", \"nap\", \"nds-nl\", \"nrm\", \"pcd\", \"pfl\", \"pih\", \"pnb\", \"rmy\",\n            \"roa-tara\", \"rue\", \"sah\", \"sco\", \"stq\", \"szl\", \"udm\",\n            \"war\", \"wuu\", \"xmf\", \"zea\", \"zh-classical\", \"zh-yue\",\n            \"ckb\", \"hif\", \"mhr\", \"myv\", \"srn\"};\n    \n    protected static final Set<String> INTERLANGUAGE_KEYS;\n    \n    /**\n     * Localised prefixes for special pages, e.g. \"Special\". \n     */\n    public static final Map<String, String> SPECIAL_PREFIX = new HashMap<String, String>();\n    /**\n     * Localised suffixes for special pages, e.g. \"AllPages\".\n     */\n    public static final Map<String, EnumMap<SpecialPage, String>> SPECIAL_SUFFIX = new HashMap<String, EnumMap<SpecialPage, String>>();\n\n    /**\n     * Enum for all available special pages.\n     * \n     * @author Nico Kruber, kruber@zib.de\n     */\n    public static enum SpecialPage {\n        /**\n         * Redirect to random page.\n         */\n        SPECIAL_RANDOM,\n        /**\n         * List of all pages.\n         */\n        SPECIAL_ALLPAGES,\n        /**\n         * List of all pages with a given prefix.\n         */\n        SPECIAL_PREFIXINDEX,\n        /**\n         * Search for a page.\n         */\n        SPECIAL_SEARCH,\n        /**\n         * Pages linking to another page.\n         */\n        SPECIAL_WHATLINKSHERE,\n        /**\n         * List of available special pages.\n         */\n        SPECIAL_SPECIALPAGES,\n        /**\n         * Some statistics.\n         */\n        SPECIAL_STATS,\n        /**\n         * Version information.\n         */\n        SPECIAL_VERSION;\n    }\n    \n    /**\n     * Cache of processed magic words.\n     */\n    protected Map<String, String> magicWordCache = new HashMap<String, String>();\n\n    protected LinkedMultiHashMap<String, Long> stats = new LinkedMultiHashMap<String, Long>();\n    \n    /**\n     * All keys that have been read or written during the current operation.\n     */\n    protected final List<InvolvedKey> involvedKeys = new ArrayList<InvolvedKey>();\n    \n    protected ExistingPagesCache existingPages = ExistingPagesCache.NULL_CACHE;\n\n    protected Map<NormalisedTitle, String> pageCache = new HashMap<NormalisedTitle, String>();\n\n    /**\n     * Text of the page to render, i.e. given to\n     * {@link #renderPageWithCache(String)} or\n     * {@link #renderPageWithCache(ITextConverter, String)}.\n     */\n    private String renderWikiText = null;\n    \n    protected static final Pattern MATCH_WIKI_FORBIDDEN_TITLE_CHARS =\n            Pattern.compile(\"^.*?([\\\\p{Cc}\\\\p{Cn}\\\\p{Co}#<>\\\\[\\\\]|{}\\\\n\\\\r]).*$\", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n\n    /**\n     * Pattern to check whether a wikitext is redirecting or not.\n     */\n    public static final Pattern MATCH_WIKI_REDIRECT = Pattern.compile(\"^\\\\s*#REDIRECT[ ]?\\\\[\\\\[:?([^\\\\]#]*)[^\\\\]]*\\\\]\\\\].*$\", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n\n    static {\n        // BEWARE: fields in Configuration are static -> this changes all configurations!\n        Configuration.DEFAULT_CONFIGURATION.addTemplateFunction(\"fullurl\", MyFullurl.CONST);\n        Configuration.DEFAULT_CONFIGURATION.addTemplateFunction(\"localurl\", MyLocalurl.CONST);\n        \n        // do not put these into the HTML text (they are not rendered anyway)\n        Configuration.DEFAULT_CONFIGURATION.addTokenTag(\"inputbox\", new IgnoreTag(\"inputbox\"));\n        Configuration.DEFAULT_CONFIGURATION.addTokenTag(\"imagemap\", new IgnoreTag(\"imagemap\"));\n        Configuration.DEFAULT_CONFIGURATION.addTokenTag(\"timeline\", new IgnoreTag(\"timeline\"));\n        \n        Configuration.AVOID_PAGE_BREAK_IN_TABLE = false;\n        \n        // allow style attributes:\n        TagNode.addAllowedAttribute(\"style\");\n        \n        // create set of keys for interlanguage wiki links\n        // also add missing hsb interlanguage link:\n        Map<String, String> interWikiMap = Configuration.DEFAULT_CONFIGURATION.getInterwikiMap();\n        INTERLANGUAGE_KEYS = new HashSet<String>(INTERLANGUAGE_STRINGS.length);\n        for (String lang : INTERLANGUAGE_STRINGS) {\n            INTERLANGUAGE_KEYS.add(lang);\n            // if there is no interwiki link for it, create one and guess the URL:\n            if (!interWikiMap.containsKey(lang)) {\n                Configuration.DEFAULT_CONFIGURATION.addInterwikiLink(lang, \"http://\" + lang + \".wiktionary.org/wiki/?${title}\");\n            }\n        }\n        \n        // localised special pages titles (prefix + suffix)\n        // BEWARE: keep SPECIAL_PREFIX and SPECIAL_SUFFIX in sync!\n        SPECIAL_PREFIX.put(\"en\", \"Special\");\n        SPECIAL_PREFIX.put(\"simple\", \"Special\");\n        SPECIAL_PREFIX.put(\"de\", \"Spezial\");\n        SPECIAL_PREFIX.put(\"bar\", \"Spezial\");\n        SPECIAL_PREFIX.put(\"es\", \"Especial\");\n        SPECIAL_PREFIX.put(\"pl\", \"Specjalna\");\n        // BEWARE: include normalised page titles!\n\n        EnumMap<SpecialPage, String> SPECIAL_SUFFIX_EN = new EnumMap<SpecialPage, String>(SpecialPage.class);\n        SPECIAL_SUFFIX_EN.put(SpecialPage.SPECIAL_RANDOM, \"Random\");\n        SPECIAL_SUFFIX_EN.put(SpecialPage.SPECIAL_ALLPAGES, \"AllPages\");\n        SPECIAL_SUFFIX_EN.put(SpecialPage.SPECIAL_PREFIXINDEX, \"PrefixIndex\");\n        SPECIAL_SUFFIX_EN.put(SpecialPage.SPECIAL_SEARCH, \"Search\");\n        SPECIAL_SUFFIX_EN.put(SpecialPage.SPECIAL_WHATLINKSHERE, \"WhatLinksHere\");\n        SPECIAL_SUFFIX_EN.put(SpecialPage.SPECIAL_SPECIALPAGES, \"SpecialPages\");\n        SPECIAL_SUFFIX_EN.put(SpecialPage.SPECIAL_STATS, \"Statistics\");\n        SPECIAL_SUFFIX_EN.put(SpecialPage.SPECIAL_VERSION, \"Version\");\n\n        EnumMap<SpecialPage, String> SPECIAL_SUFFIX_DE = new EnumMap<SpecialPage, String>(SpecialPage.class);\n        SPECIAL_SUFFIX_DE.put(SpecialPage.SPECIAL_RANDOM, \"Zuf\u00e4llige Seite\");\n        SPECIAL_SUFFIX_DE.put(SpecialPage.SPECIAL_ALLPAGES, \"Alle Seiten\");\n        SPECIAL_SUFFIX_DE.put(SpecialPage.SPECIAL_PREFIXINDEX, \"Pr\u00e4fixindex\");\n        SPECIAL_SUFFIX_DE.put(SpecialPage.SPECIAL_SEARCH, \"Suche\");\n        SPECIAL_SUFFIX_DE.put(SpecialPage.SPECIAL_WHATLINKSHERE, \"Linkliste\");\n        SPECIAL_SUFFIX_DE.put(SpecialPage.SPECIAL_SPECIALPAGES, \"Spezialseiten\");\n        SPECIAL_SUFFIX_DE.put(SpecialPage.SPECIAL_STATS, \"Statistik\");\n        SPECIAL_SUFFIX_DE.put(SpecialPage.SPECIAL_VERSION, \"Version\");\n\n        EnumMap<SpecialPage, String> SPECIAL_SUFFIX_ES = new EnumMap<SpecialPage, String>(SpecialPage.class);\n        SPECIAL_SUFFIX_ES.put(SpecialPage.SPECIAL_RANDOM, \"Aleatoria\");\n        SPECIAL_SUFFIX_ES.put(SpecialPage.SPECIAL_ALLPAGES, \"Todas\");\n        SPECIAL_SUFFIX_ES.put(SpecialPage.SPECIAL_PREFIXINDEX, \"P\u00e1ginasPorPrefijo\");\n        SPECIAL_SUFFIX_ES.put(SpecialPage.SPECIAL_SEARCH, \"Buscar\");\n        SPECIAL_SUFFIX_ES.put(SpecialPage.SPECIAL_WHATLINKSHERE, \"LoQueEnlazaAqu\u00ed\");\n        SPECIAL_SUFFIX_ES.put(SpecialPage.SPECIAL_SPECIALPAGES, \"P\u00e1ginasEspeciales\");\n        SPECIAL_SUFFIX_ES.put(SpecialPage.SPECIAL_STATS, \"Estad\u00edsticas\");\n        SPECIAL_SUFFIX_ES.put(SpecialPage.SPECIAL_VERSION, \"Versi\u00f3n\");\n        \n        SPECIAL_SUFFIX.put(\"en\", SPECIAL_SUFFIX_EN);\n        SPECIAL_SUFFIX.put(\"simple\", SPECIAL_SUFFIX_EN);\n        SPECIAL_SUFFIX.put(\"de\", SPECIAL_SUFFIX_DE);\n        SPECIAL_SUFFIX.put(\"bar\", SPECIAL_SUFFIX_DE);\n        SPECIAL_SUFFIX.put(\"es\", SPECIAL_SUFFIX_ES);\n    }\n    \n    /**\n     * Creates a new wiki model to render wiki text fixing some bugs of\n     * {@link WikiModel}.\n     * \n     * @param imageBaseURL\n     *            base url pointing to images - can contain ${image} for\n     *            replacement\n     * @param linkBaseURL\n     *            base url pointing to links - can contain ${title} for\n     *            replacement\n     * @param namespace\n     *            namespace of the wiki\n     */\n    public MyWikiModel(String imageBaseURL, String linkBaseURL, MyNamespace namespace) {\n        super(new MyConfiguration(namespace), null, namespace, imageBaseURL, linkBaseURL);\n        addTemplateFunction(\"#ifexist\", MyIfexistTemplateFun.CONST);\n    }\n    \n    /* (non-Javadoc)\n     * @see info.bliki.wiki.model.AbstractWikiModel#getRawWikiContent(java.lang.String, java.lang.String, java.util.Map)\n     */\n    @Override\n    public String getRawWikiContent(String namespace, String articleName,\n            Map<String, String> templateParameters) {\n        if (isTemplateNamespace(namespace)) {\n            String processedMagicWord = null;\n            processedMagicWord = processMagicWord(articleName);\n            if (processedMagicWord != null) {\n                return processedMagicWord;\n            }\n        }\n        \n        if (!isValidTitle(createFullPageName(namespace, articleName))) {\n            return null;\n        }\n\n        // (ugly) fix for template parameter replacement if no parameters given,\n        // e.g. \"{{noun}}\" in the simple English Wiktionary\n        if (templateParameters != null && templateParameters.isEmpty()) {\n            templateParameters.put(\"\", null);\n        }\n\n        // note: cannot cache templates here since the text returned by the\n        // implementation-specific retrievePage() method may depend in the exact\n        // parameters or not\n        return retrievePage(namespace, articleName, templateParameters);\n    }\n\n    /**\n     * Checks whether the given template name is a magic word and if this is the\n     * case, processes it and returns its value.\n     * \n     * Retrieves magic word contents using\n     * {@link #retrieveMagicWord(String, String, String)} and caches the\n     * contents in {@link #magicWordCache}.\n     * \n     * @param templateName\n     *            the template's name without the namespace, e.g. a magic word\n     *            including its parameters\n     * \n     * @return the contents of the magic word or <tt>null</tt> if the template\n     *         is no magic word\n     */\n    private String processMagicWord(String templateName) {\n        int index = templateName.indexOf(':');\n        String magicWord = templateName;\n        String parameter = \"\";\n        boolean hasParameter = false;\n        if (index > 0) {\n            hasParameter = true;\n            // if it is a magic word, the first part is the word itself, the second its parameters\n            magicWord = templateName.substring(0, index);\n            parameter = templateName.substring(index + 1).trim();\n        }\n        \n        if (isMagicWord(magicWord)) {\n            // cache values for magic words:\n            if (magicWordCache.containsKey(templateName)) {\n                return magicWordCache.get(templateName);\n            } else {\n                String value = retrieveMagicWord(templateName, magicWord, parameter, hasParameter);\n                magicWordCache.put(templateName, value);\n                return value;\n            }\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Determines if a template name corresponds to a magic word using\n     * {@link MyMagicWord#isMagicWord(String)} (does not recognise magic\n     * words with parameters, e.g. <tt>TALKPAGENAME:Title</tt>).\n     * \n     * @param name\n     *            the template name (without the template namespace)\n     * \n     * @return whether the template is a magic word or not\n     */\n    protected boolean isMagicWord(String name) {\n        return MyMagicWord.isMagicWord(name);\n    }\n\n    /**\n     * Determines if a template name corresponds to a magic word using\n     * {@link #isMagicWord(String)} (also recognises magic\n     * words with parameters, e.g. <tt>TALKPAGENAME:Title</tt>).\n     * \n     * @param name\n     *            the template name (without the template namespace)\n     * \n     * @return whether the template is a magic word or not\n     */\n    public final boolean isMagicWordFull(String name) {\n        return isMagicWord(MyMagicWord.extractMagicWordPart(name));\n    }\n\n    /**\n     * Gets the names of all included pages in the template namespace (excluding\n     * magic words).\n     * \n     * @return page names without the template namespace prefix\n     * @see #getTemplates()\n     */\n    public final Set<String> getTemplatesNoMagicWords() {\n        final Set<String> result = new HashSet<String>(templates.size());\n        // remove magic words:\n        for (String template : templates) {\n            if (!isMagicWordFull(template)) {\n                result.add(template);\n            }\n        }\n        return result;\n    }\n    \n    /**\n     * Retrieves the contents of the given magic word using\n     * {@link MyMagicWord#processMagicWord(String, String, info.bliki.wiki.model.IWikiModel)}.\n     * \n     * @param templateName\n     *            the template's name without the namespace, e.g. a magic word\n     *            including its parameters\n     * @param magicWord\n     *            the magic word alone\n     * @param parameter\n     *            the parameters of the magic word name\n     * @param hasParameter\n     *            whether a parameter was given or not (cannot distinguish from\n     *            <tt>parameter</tt> value alone)\n     * \n     * @return the contents of the magic word\n     */\n    protected String retrieveMagicWord(String templateName, String magicWord,\n            String parameter, boolean hasParameter) {\n        return MyMagicWord.processMagicWord(templateName, parameter, this, hasParameter);\n    }\n    \n    /**\n     * Renders the \"redirect to\" content in case no auto-redirection is used.\n     * \n     * @param pageTitle\n     *            the title of the page being redirected to\n     * \n     * @return HTML redirect note\n     */\n    public String renderRedirectPage(String pageTitle) {\n        final String redirectUrl = getWikiBaseURL().replace(\"${title}\", pageTitle);\n        final String safeRedirectTitle = StringEscapeUtils.escapeHtml(pageTitle);\n        return \"<div class=\\\"redirectMsg\\\">\"\n                + \"<img src=\\\"skins/redirectltr.png\\\" alt=\\\"#REDIRECT\\\" />\"\n                + \"<span class=\\\"redirectText\\\">\"\n                + \"<a href=\\\"\" + redirectUrl + \"\\\" title=\\\"\" + safeRedirectTitle + \"\\\">\" + pageTitle + \"</a>\"\n                + \"</span></div>\";\n    }\n    \n    /**\n     * Creates the full pagename including the namespace (if non-empty).\n     * \n     * @param namespace\n     *            the namespace of a page\n     * @param articleName\n     *            the name of a page\n     * \n     * @return the full name of the page\n     */\n    public static String createFullPageName(String namespace, String articleName) {\n        String pageName;\n        if (namespace.isEmpty()) {\n            pageName = articleName;\n        } else {\n            pageName = namespace + \":\" + articleName;\n        }\n        return pageName;\n    }\n    \n    /**\n     * Retrieves the contents of the given page.\n     * \n     * @param namespace\n     *            the namespace of the page\n     * @param articleName\n     *            the (unnormalised) page's name without the namespace\n     * @param templateParameters\n     *            template parameters if the page is a template, <tt>null</tt>\n     *            otherwise\n     * \n     * @return <tt>null</tt>\n     * @see #retrievePage(String, String, Map, boolean)\n     */\n    final protected String retrievePage(String namespace, String articleName,\n            Map<String, String> templateParameters) {\n        return retrievePage(namespace, articleName, templateParameters, true);\n    }\n\n    /**\n     * Retrieves the contents of the given page.\n     * \n     * @param pageName0\n     *            the unnormalised name of the page\n     * @param templateParameters\n     *            template parameters if the page is a template, <tt>null</tt>\n     *            otherwise\n     * @param followRedirect\n     *            whether to follow a redirect or not (at most one redirect\n     *            should be followed)\n     * \n     * @return the page's contents or <tt>null</tt> if no connection exists\n     * @see #retrievePage(String, String, Map, boolean)\n     */\n    final protected String retrievePage(String pageName0,\n            Map<String, String> templateParameters, boolean followRedirect) {\n        String[] parts = splitNsTitle(pageName0);\n        return retrievePage(parts[0], parts[1], templateParameters, followRedirect);\n    }\n\n    /**\n     * Retrieves the contents of the given page.\n     * \n     * If {@link #hasDBConnection()} is <tt>true</tt>, uses\n     * {@link #getRevFromDB(NormalisedTitle)} to get the content from the DB. If\n     * <tt>followRedirect</tt> is set, resolves redirects by including the\n     * redirected content instead.\n     * \n     * Caches retrieved pages in {@link #pageCache}.\n     * \n     * @param namespace\n     *            the namespace of the page\n     * @param articleName\n     *            the (unnormalised) page's name without the namespace\n     * @param templateParameters\n     *            template parameters if the page is a template, <tt>null</tt>\n     *            otherwise\n     * @param followRedirect\n     *            whether to follow a redirect or not (at most one redirect\n     *            should be followed)\n     * \n     * @return the page's contents or <tt>null</tt> if no connection exists\n     */\n    protected String retrievePage(String namespace, String articleName,\n            Map<String, String> templateParameters, boolean followRedirect) {\n\n        if (articleName.isEmpty()) {\n            return null;\n        }\n        \n        // normalise page name:\n        NormalisedTitle pageName = normalisePageTitle(namespace, articleName);\n        if (pageCache.containsKey(pageName)) {\n            return pageCache.get(pageName);\n        } else if (hasDBConnection()) {\n            String text = null;\n            // System.out.println(\"retrievePage(\" + namespace + \", \" + articleName + \")\");\n            RevisionResult getRevResult = getRevFromDB(pageName);\n            addStats(getRevResult.stats);\n            addInvolvedKeys(getRevResult.involvedKeys);\n            if (getRevResult.success) {\n                text = getRevResult.revision.unpackedText();\n                if (getRevResult.page.isRedirect()) {\n                    final Matcher matcher = MATCH_WIKI_REDIRECT.matcher(text);\n                    if (matcher.matches()) {\n                        String[] redirFullName = splitNsTitle(matcher.group(1));\n                        if (followRedirect) {\n                            // see https://secure.wikimedia.org/wikipedia/en/wiki/Help:Redirect#Transclusion\n                            String redirText = retrievePage(redirFullName[0], redirFullName[1], templateParameters, false);\n                            if (redirText != null && !redirText.isEmpty()) {\n                                text = redirText;\n                            } else {\n                                text = \"<ol><li>REDIRECT [[\"\n                                        + createFullPageName(redirFullName[0],\n                                                redirFullName[1]) + \"]]</li></ol>\";\n                            }\n                        } else {\n                            // we must disarm the redirect here!\n                            text = \"<ol><li>REDIRECT [[\"\n                                    + createFullPageName(redirFullName[0],\n                                            redirFullName[1]) + \"]]</li></ol>\";\n                        }\n                    } else {\n                        // we must disarm the redirect here!\n                        System.err\n                                .println(\"Couldn't parse the redirect title of \\\"\"\n                                        + createFullPageName(namespace, articleName)\n                                        + \"\\\" in \\\"\"\n                                        + createFullPageName(\n                                                getNamespaceName(),\n                                                getPageName())\n                                        + \"\\\" from: \"\n                                        + text.substring(0, Math.min(100, text.length())));\n                        text = null;\n                    }\n                }\n            } else {\n                // NOTE: must return null for non-existing pages in order for #ifexist to work correctly!\n                // System.err.println(getRevResult.message);\n                // text = \"<b>ERROR: template \" + pageName + \" not available: \" + getRevResult.message + \"</b>\";\n            }\n            pageCache.put(pageName, text);\n            return text;\n        }\n        return null;\n    }\n    \n    protected boolean hasDBConnection() {\n        return false;\n    }\n    \n    protected RevisionResult getRevFromDB(NormalisedTitle title) {\n        return new RevisionResult(false, new ArrayList<InvolvedKey>(),\n                \"no DB connection\", true, title, null, null, false,\n                false, title.toString(), 0l);\n    }\n\n    /* (non-Javadoc)\n     * @see info.bliki.wiki.model.AbstractWikiModel#encodeTitleToUrl(java.lang.String, boolean)\n     */\n    @Override\n    public String encodeTitleToUrl(String wikiTitle, boolean firstCharacterAsUpperCase) {\n        try {\n            // some links may contain '_' which needs to be translated back to ' ':\n            wikiTitle = wikiTitle.replace('_', ' ');\n            return URLEncoder.encode(wikiTitle, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            return super.encodeTitleToUrl(wikiTitle, firstCharacterAsUpperCase);\n        }\n    }\n\n    /* (non-Javadoc)\n     * @see info.bliki.wiki.model.WikiModel#getNamespace()\n     */\n    @Override\n    public MyNamespace getNamespace() {\n        return (MyNamespace) super.getNamespace();\n    }\n\n    /**\n     * Formats the given number using the wiki's locale.\n     * \n     * Note: Currently, the English locale is always used.\n     * \n     * @param rawNumber\n     *            whether the raw number should be returned\n     * @param number\n     *            the number\n     * \n     * @return the formatted number\n     */\n    public String formatStatisticNumber(boolean rawNumber, Number number) {\n        if (rawNumber) {\n            return number.toString();\n        } else {\n            // TODO: use locale from Wiki\n            NumberFormat nf = NumberFormat.getNumberInstance(Locale.ENGLISH);\n            nf.setGroupingUsed(true);\n            return nf.format(number);\n        }\n    }\n\n    /**\n     * Splits the given full title at the first colon.\n     * \n     * @param fullTitle\n     *            the (full) title including a namespace (if present)\n     * \n     * @return a 2-element array with the two components - the first may be\n     *         empty if no colon is found\n     */\n    protected static String[] splitAtColon(String fullTitle) {\n        int colonIndex = fullTitle.indexOf(':');\n        if (colonIndex != (-1)) {\n            return new String[] { fullTitle.substring(0, colonIndex),\n                    fullTitle.substring(colonIndex + 1) };\n        }\n        return new String[] { \"\", fullTitle };\n    }\n\n    /* (non-Javadoc)\n     * @see info.bliki.wiki.model.AbstractWikiModel#appendRedirectLink(java.lang.String)\n     */\n    @Override\n    public boolean appendRedirectLink(String redirectLink) {\n        // do not add redirection if we are parsing a template:\n        if (getRecursionLevel() == 0) {\n            // remove \"#section\" from redirect links (this form of redirects is unsupported)\n            if (redirectLink != null) {\n                return super.appendRedirectLink(redirectLink.replaceFirst(\"#.*$\", \"\"));\n            }\n            return super.appendRedirectLink(null);\n        }\n        return true;\n    }\n\n    /* (non-Javadoc)\n     * @see info.bliki.wiki.model.AbstractWikiModel#appendInterWikiLink(java.lang.String, java.lang.String, java.lang.String)\n     */\n    @Override\n    public void appendInterWikiLink(String namespace, String title, String linkText) {\n        appendInterWikiLink(namespace, title, linkText, true);\n    }\n    \n    protected void appendInterWikiLink(String namespace, String title, String linkText, boolean ignoreInterLang) {\n        if (INTERLANGUAGE_KEYS.contains(namespace)) {\n            // also check if this is an inter wiki link to an external wiki in another language\n            // -> only ignore inter language links to the same wiki\n            String namespace2 = splitAtColon(title)[0];\n            if (!ignoreInterLang || (!namespace2.isEmpty() && isInterWiki(namespace2))) {\n                // bliki is not able to parse language-specific interwiki links\n                // -> use default language\n                super.appendInterWikiLink(namespace2, title, linkText);\n            } else {\n                // ignore interlanguage keys\n            }\n        } else {\n            super.appendInterWikiLink(namespace, title, linkText);\n        }\n    }\n\n    /* (non-Javadoc)\n     * @see info.bliki.wiki.model.WikiModel#addLink(java.lang.String)\n     */\n    @Override\n    public void addLink(String topicName) {\n        /*\n         * do not add links like [[:w:nl:User:WinContro|Dutch Wikipedia]] to\n         * the internal links\n         */\n        String[] nsTitle = splitAtColon(topicName);\n        if (!nsTitle[0].isEmpty() && isInterWiki(nsTitle[0])) {\n            appendInterWikiLink(nsTitle[0], nsTitle[1], \"\");\n        } else {\n            super.addLink(topicName);\n        }\n    }\n\n    /* (non-Javadoc)\n     * @see info.bliki.wiki.model.WikiModel#appendInternalLink(java.lang.String, java.lang.String, java.lang.String, java.lang.String, boolean)\n     */\n    @Override\n    public void appendInternalLink(String topic0, String hashSection, String topicDescription,\n            String cssClass, boolean parseRecursive) {\n        /*\n         * convert links like [[:w:nl:User:WinContro|Dutch Wikipedia]] to\n         * external links if the link is an interwiki link\n         */\n        String[] nsTitle = splitAtColon(topic0);\n        if (!nsTitle[0].isEmpty() && isInterWiki(nsTitle[0])) {\n            appendInterWikiLink(nsTitle[0], nsTitle[1], topicDescription, nsTitle[1].isEmpty() && topicDescription.equals(topic0));\n        } else {\n            boolean pageExists = true;\n            if (existingPages.hasContains()) {\n                pageExists = existingPages.contains(normalisePageTitle(topic0));\n            }\n            super.appendInternalLink(topic0, hashSection, topicDescription, cssClass, parseRecursive, pageExists);\n        }\n    }\n\n    /**\n     * Normalises the given string, i.e. capitalises the first letter and\n     * replaces underscores with spaces.\n     * \n     * @param value\n     *            the string\n     * \n     * @return a normalised string\n     */\n    public static String normaliseName(final String value) {\n        return Encoder.normaliseTitle(value, true, ' ', true);\n    }\n    \n    /**\n     * Normalises the given page title by capitalising its first letter after\n     * the namespace.\n     * \n     * @param title\n     *            the original page title\n     * \n     * @return the normalised page title\n     */\n    public NormalisedTitle normalisePageTitle(final String title) {\n        return NormalisedTitle.fromUnnormalised(title, getNamespace());\n    }\n    \n    /**\n     * Normalises the given page title by capitalising its first letter after\n     * the namespace.\n     * \n     * @param maybeNs\n     *            the namespace of the page\n     * @param articleName\n     *            the (unnormalised) page's name without the namespace\n     * \n     * @return the normalised page title\n     */\n    public NormalisedTitle normalisePageTitle(final String maybeNs, final String articleName) {\n        return NormalisedTitle.fromUnnormalised(maybeNs, articleName, getNamespace());\n    }\n    \n    /**\n     * Normalises the given page title by capitalising its first letter after\n     * the namespace.\n     * \n     * @param <T>\n     * \n     * @param titles\n     *            the original page titles\n     * @param normalisedTitles\n     *            the container to write the normalised titles to\n     * \n     * @return the normalised page titles\n     */\n    public <T extends Collection<NormalisedTitle>> T normalisePageTitles(final Collection<String> titles, T normalisedTitles) {\n        return MyWikiModel.<T>normalisePageTitles(titles, getNamespace(), normalisedTitles);\n    }\n    \n    /**\n     * Normalises the given page titles by capitalising their first letter after\n     * the namespace.\n     * \n     * @param <T>\n     * \n     * @param titles\n     *            the original page titles\n     * @param nsObject\n     *            the namespace for determining how to split the title\n     * @param normalisedTitles\n     *            the container to write the normalised titles to\n     * \n     * @return the normalised page titles\n     */\n    public static <T extends Collection<NormalisedTitle>> T normalisePageTitles(final Collection<String> titles, final MyNamespace nsObject, T normalisedTitles) {\n        for (String title: titles) {\n            normalisedTitles.add(NormalisedTitle.fromUnnormalised(title, nsObject));\n        }\n        return normalisedTitles;\n    }\n    \n    /**\n     * De-normalises the given page titles.\n     * \n     * @param <T>\n     * \n     * @param titles\n     *            the normalised page titles\n     * @param denormalisedTitles\n     *            the container to write the de-normalised titles to\n     * \n     * @return the original page title\n     */\n    public <T extends Collection<String>> T denormalisePageTitles(final Collection<NormalisedTitle> titles, T denormalisedTitles) {\n        return MyWikiModel.<T>denormalisePageTitles(titles, getNamespace(), denormalisedTitles);\n    }\n    \n    /**\n     * De-normalises the given page titles.\n     * \n     * @param <T>\n     * \n     * @param titles\n     *            the normalised page titles\n     * @param nsObject\n     *            the namespace for determining how to split the title\n     * @param denormalisedTitles\n     *            the container to write the de-normalised titles to\n     * \n     * @return the original page title\n     */\n    public static <T extends Collection<String>> T denormalisePageTitles(final Collection<NormalisedTitle> titles, final MyNamespace nsObject, T denormalisedTitles) {\n        for (NormalisedTitle title: titles) {\n            denormalisedTitles.add(title.denormalise(nsObject));\n        }\n        return denormalisedTitles;\n    }\n\n    /* (non-Javadoc)\n     * @see info.bliki.wiki.model.WikiModel#setUp()\n     */\n    @Override\n    public void setUp() {\n        super.setUp();\n        magicWordCache = new HashMap<String, String>();\n        pageCache = new HashMap<NormalisedTitle, String>();\n        if (renderWikiText != null) {\n            pageCache.put(normalisePageTitle(getPageName()), renderWikiText );\n        }\n    }\n\n    /**\n     * Checks whether the given namespace is a valid media namespace.\n     * \n     * @param namespace\n     *            the namespace to check\n     * \n     * @return <tt>true</tt> if it is one of the two media namespace strings\n     */\n    public boolean isMediaNamespace(String namespace) {\n        return namespace.equalsIgnoreCase(fNamespace.getMedia()) || namespace.equalsIgnoreCase(fNamespace.getMedia2());\n    }\n\n    /**\n     * Gets information about the time needed to look up pages.\n     * \n     * @return a mapping of page titles to retrieval times\n     */\n    public Map<String, List<Long>> getStats() {\n        return stats;\n    }\n\n    /**\n     * Adds the time needed to retrieve the given page to the collected\n     * statistics.\n     * \n     * @param title\n     *            the title of the page\n     * @param value\n     *            the number of milliseconds it took to retrieve the page\n     */\n    public void addStat(String title, long value) {\n        stats.put1(title, value);\n    }\n\n    /**\n     * Adds the time needed to retrieve the given page to the collected\n     * statistics.\n     * \n     * @param title\n     *            the title of the page\n     * @param value\n     *            multiple number of milliseconds it took to retrieve the page\n     */\n    public void addStats(String title, List<Long> value) {\n        stats.put(title, value);\n    }\n\n    /**\n     * Adds the time needed to retrieve the given page to the collected\n     * statistics.\n     * \n     * @param values\n     *            a mapping between page titles and the number of milliseconds\n     *            it took to retrieve the page\n     */\n    public void addStats(Map<String, List<Long>> values) {\n        stats.putAll(values);\n    }\n    \n    /**\n     * Adds an involved key to the collected statistics.\n     * \n     * @param key\n     *            the key to add\n     */\n    public void addInvolvedKey(InvolvedKey key) {\n        involvedKeys.add(key);\n    }\n    \n    /**\n     * Adds a number of involved keys to the collected statistics.\n     * \n     * @param keys\n     *            the keys to add\n     */\n    public void addInvolvedKeys(Collection<? extends InvolvedKey> keys) {\n        involvedKeys.addAll(keys);\n    }\n\n    /**\n     * Gets the list of all keys that have been read or written during the\n     * current operation.\n     * \n     * @return the involvedKeys\n     */\n    public List<InvolvedKey> getInvolvedKeys() {\n        return involvedKeys;\n    }\n    \n    /**\n     * @return the existingPages\n     */\n    public ExistingPagesCache getExistingPages() {\n        return existingPages;\n    }\n\n    /**\n     * @param existingPages the existingPages to set\n     */\n    public void setExistingPages(ExistingPagesCache existingPages) {\n        this.existingPages = existingPages;\n    }\n    \n    /**\n     * The following characters are forbidden in page titles:\n     * <tt># &lt; &gt; [ ] | { }</tt>. Any line breaks and non-printable unicode\n     * characters are also forbidden here.\n     * \n     * @param title\n     *            the title to check\n     * \n     * @return <tt>true</tt> if the title contains a forbidden character,\n     *         <tt>false</tt> otherwise\n     * \n     * @see #MATCH_WIKI_FORBIDDEN_TITLE_CHARS\n     */\n    public static boolean isValidTitle(String title) {\n        if (title == null || title.isEmpty() || title.length() >= 256) {\n            return false;\n        }\n        final Matcher matcher = MATCH_WIKI_FORBIDDEN_TITLE_CHARS.matcher(title);\n        return !matcher.matches();\n    }\n\n    /**\n     * Determines whether a page with the given properties is an article.\n     * \n     * A new page in the main namespace will be counted as an article if it\n     * contains at least one wiki link or is categorised to at least one\n     * category.\n     * \n     * @param namespace\n     *            the ID of the namespace of the page\n     * @param links\n     *            the links in this page\n     * @param categories\n     *            categories of this page\n     * \n     * @return whether the page is an article or not\n     * \n     * @see <a\n     *      href=\"https://www.mediawiki.org/wiki/Manual:Article_count\">MediaWiki\n     *      explanation</a>\n     */\n    public static boolean isArticle(int namespace, Collection<String> links,\n            Collection<String> categories) {\n        return (namespace == 0) && (!links.isEmpty() || !categories.isEmpty());\n    }\n    \n    /**\n     * Gets all localised variants for the given special page.\n     * \n     * @param page\n     *            the special page\n     * \n     * @return localised variants including the English names\n     */\n    public static Collection<String> getLocalisedSpecialPageNames(SpecialPage page) {\n        ArrayList<String> result = new ArrayList<String>();\n        \n        for (Entry<String, String> prefix : SPECIAL_PREFIX.entrySet()) {\n            EnumMap<SpecialPage, String> localisedSuffix = SPECIAL_SUFFIX.get(prefix.getKey());\n            if (localisedSuffix != null) {\n                result.add(MyWikiModel.createFullPageName(prefix.getValue(), localisedSuffix.get(page)));\n            }\n            // Also add the English suffix for the localised prefix.\n            EnumMap<SpecialPage, String> englishSuffix = SPECIAL_SUFFIX.get(\"en\");\n            if (englishSuffix != null) {\n                result.add(MyWikiModel.createFullPageName(prefix.getValue(), englishSuffix.get(page)));\n            }\n        }\n        return result;\n    }\n    \n    /**\n     * Gets the localised variants for the given special page.\n     * \n     * @param page\n     *            the special page\n     * @param language\n     *            the language to get the variants for\n     * \n     * @return localised variants including the English names\n     */\n    public static Collection<String> getLocalisedSpecialPageNames(SpecialPage page, String language) {\n        ArrayList<String> result = new ArrayList<String>(4);\n        \n        String localisedPrefix = SPECIAL_PREFIX.get(\"en\");\n        EnumMap<SpecialPage, String> localisedSuffix = SPECIAL_SUFFIX.get(\"en\");\n        result.add(MyWikiModel.createFullPageName(localisedPrefix, localisedSuffix.get(page)));\n        \n        localisedPrefix = SPECIAL_PREFIX.get(language);\n        localisedSuffix = SPECIAL_SUFFIX.get(language);\n        if (localisedPrefix != null && localisedSuffix != null) {\n            result.add(MyWikiModel.createFullPageName(localisedPrefix, localisedSuffix.get(page)));\n        }\n        return result;\n    }\n\n    /* (non-Javadoc)\n     * @see info.bliki.wiki.model.AbstractWikiModel#isImageNamespace(java.lang.String)\n     */\n    @Override\n    public boolean isImageNamespace(String namespace) {\n        return super.isImageNamespace(namespace) ||\n                ((MyNamespace) fNamespace).getNumberByName(namespace) == Namespace.FILE_NAMESPACE_KEY;\n    }\n\n    /**\n     * Renders the raw Wikipedia text into a string for a given converter\n     * (renders the wiki text as if a template topic will be displayed\n     * directly).\n     * \n     * @param converter\n     *            a text converter. <b>Note</b> the converter may be\n     *            <code>null</code>, if you only would like to analyze the raw\n     *            wiki text and don't need to convert. This speeds up the\n     *            parsing process.\n     * @param rawWikiText\n     *            a raw wiki text\n     * @return <code>null</code> if an IOException occurs or\n     *         <code>converter==null</code>\n     * \n     * @see info.bliki.wiki.model.AbstractWikiModel#render(info.bliki.wiki.filter.ITextConverter,\n     *      java.lang.String, boolean)\n     */\n    public String renderPageWithCache(ITextConverter converter, String rawWikiText) {\n        renderWikiText = rawWikiText;\n        return super.render(converter, rawWikiText, true);\n    }\n\n    /**\n     * Renders the raw Wikipedia text into an HTML string and use the default\n     * HTMLConverter (renders the wiki text as if a template topic will be\n     * displayed directly).\n     * \n     * @param rawWikiText\n     *            a raw wiki text\n     * @return <code>null</code> if an IOException occurs\n     * \n     * @see info.bliki.wiki.model.AbstractWikiModel#render(java.lang.String,\n     *      boolean)\n     */\n    public String renderPageWithCache(String rawWikiText) {\n        renderWikiText = rawWikiText;\n        return super.render(new HTMLConverter(), rawWikiText, true);\n    }\n}", "class_id": 0, "repo": "schintke/scalaris", "file": "contrib/wikipedia/src/de/zib/scalaris/examples/wikipedia/bliki/MyWikiModel.java", "last_update_at": "2019-05-14T11:53:22+00:00", "question_id": "c8d23c77029cd24b93d6adcaf81358862f8432d5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MyWikiModel extends WikiModel {\n    /**\n     * Interwiki links pointing to other wikis in the web\n     */\n    private static final String[] INTERLANGUAGE_STRINGS = { \"en\", \"de\", \"fr\",\n            \"it\", \"pl\", \"es\", \"ja\", \"ru\", \"nl\", \"pt\", \"sv\", \"zh\", \"ca\", \"uk\",\n            \"no\", \"fi\", \"hu\", \"cs\", \"ro\", \"tr\", \"ko\", \"vi\", \"da\", \"ar\", \"eo\",\n            \"sr\", \"id\", \"lt\", \"vo\", \"sk\", \"he\", \"fa\", \"bg\", \"sl\", \"eu\", \"war\",\n            \"lmo\", \"et\", \"hr\", \"new\", \"te\", \"nn\", \"th\", \"gl\", \"el\", \"ceb\",\n            \"simple\", \"ms\", \"ht\", \"bs\", \"bpy\", \"lb\", \"ka\", \"is\", \"sq\", \"la\",\n            \"br\", \"hi\", \"az\", \"bn\", \"mk\", \"mr\", \"sh\", \"tl\", \"cy\", \"io\", \"pms\",\n            \"lv\", \"ta\", \"su\", \"oc\", \"jv\", \"nap\", \"nds\", \"scn\", \"be\", \"ast\",\n            \"ku\", \"wa\", \"af\", \"be-x-old\", \"an\", \"ksh\", \"szl\", \"fy\", \"frr\",\n            \"yue\", \"ur\", \"ia\", \"ga\", \"yi\", \"sw\", \"als\", \"hy\", \"am\", \"roa-rup\",\n            \"map-bms\", \"bh\", \"co\", \"cv\", \"dv\", \"nds-nl\", \"fo\", \"fur\", \"glk\",\n            \"gu\", \"ilo\", \"kn\", \"pam\", \"csb\", \"kk\", \"km\", \"lij\", \"li\", \"ml\",\n            \"gv\", \"mi\", \"mt\", \"nah\", \"ne\", \"nrm\", \"se\", \"nov\", \"qu\", \"os\",\n            \"pi\", \"pag\", \"ps\", \"pdc\", \"rm\", \"bat-smg\", \"sa\", \"gd\", \"sco\", \"sc\",\n            \"si\", \"tg\", \"roa-tara\", \"tt\", \"to\", \"tk\", \"hsb\", \"uz\", \"vec\",\n            \"fiu-vro\", \"wuu\", \"vls\", \"yo\", \"diq\", \"zh-min-nan\", \"zh-classical\",\n            \"frp\", \"lad\", \"bar\", \"bcl\", \"kw\", \"mn\", \"haw\", \"ang\", \"ln\", \"ie\",\n            \"wo\", \"tpi\", \"ty\", \"crh\", \"jbo\", \"ay\", \"zea\", \"eml\", \"ky\", \"ig\",\n            \"or\", \"mg\", \"cbk-zam\", \"kg\", \"arc\", \"rmy\", \"gn\", \"mo (closed)\",\n            \"so\", \"kab\", \"ks\", \"stq\", \"ce\", \"udm\", \"mzn\", \"pap\", \"cu\", \"sah\",\n            \"tet\", \"sd\", \"lo\", \"ba\", \"pnb\", \"iu\", \"na\", \"got\", \"bo\", \"dsb\",\n            \"chr\", \"cdo\", \"hak\", \"om\", \"my\", \"sm\", \"ee\", \"pcd\", \"ug\", \"as\",\n            \"ti\", \"av\", \"bm\", \"zu\", \"pnt\", \"nv\", \"cr\", \"pih\", \"ss\", \"ve\", \"bi\",\n            \"rw\", \"ch\", \"arz\", \"xh\", \"kl\", \"ik\", \"bug\", \"dz\", \"ts\", \"tn\", \"kv\",\n            \"tum\", \"xal\", \"st\", \"tw\", \"bxr\", \"ak\", \"ab\", \"ny\", \"fj\", \"lbe\",\n            \"ki\", \"za\", \"ff\", \"lg\", \"sn\", \"ha\", \"sg\", \"ii\", \"cho\", \"rn\", \"mh\",\n            \"chy\", \"ng\", \"kj\", \"ho\", \"mus\", \"kr\", \"hz\", \"mwl\", \"pa\", \"ace\",\n            \"bat-smg\", \"bjn\", \"cbk-zam\", \"cdo\", \"ceb\", \"crh\", \"dsb\", \"eml\",\n            \"ext\", \"fiu-vro\", \"frp\", \"frr\", \"gag\", \"gan\", \"hak\", \"kaa\", \"kab\",\n            \"kbd\", \"koi\", \"krc\", \"ksh\", \"lad\", \"lbe\", \"lmo\", \"map-bms\", \"mdf\",\n            \"mrj\", \"mwl\", \"nap\", \"nds-nl\", \"nrm\", \"pcd\", \"pfl\", \"pih\", \"pnb\", \"rmy\",\n            \"roa-tara\", \"rue\", \"sah\", \"sco\", \"stq\", \"szl\", \"udm\",\n            \"war\", \"wuu\", \"xmf\", \"zea\", \"zh-classical\", \"zh-yue\",\n            \"ckb\", \"hif\", \"mhr\", \"myv\", \"srn\"};\n    protected static final Set<String> INTERLANGUAGE_KEYS;\n    /**\n     * Localised prefixes for special pages, e.g. \"Special\". \n     */\n    public static final Map<String, String> SPECIAL_PREFIX = new HashMap<String, String>();\n    /**\n     * Localised suffixes for special pages, e.g. \"AllPages\".\n     */\n    public static final Map<String, EnumMap<SpecialPage, String>> SPECIAL_SUFFIX = new HashMap<String, EnumMap<SpecialPage, String>>();\n    /**\n     * Enum for all available special pages.\n     * \n     * @author Nico Kruber, kruber@zib.de\n     */\n    public static enum SpecialPage {\n        /**\n         * Redirect to random page.\n         */\n        SPECIAL_RANDOM,\n        /**\n         * List of all pages.\n         */\n        SPECIAL_ALLPAGES,\n        /**\n         * List of all pages with a given prefix.\n         */\n        SPECIAL_PREFIXINDEX,\n        /**\n         * Search for a page.\n         */\n        SPECIAL_SEARCH,\n        /**\n         * Pages linking to another page.\n         */\n        SPECIAL_WHATLINKSHERE,\n        /**\n         * List of available special pages.\n         */\n        SPECIAL_SPECIALPAGES,\n        /**\n         * Some statistics.\n         */\n        SPECIAL_STATS,\n        /**\n         * Version information.\n         */\n        SPECIAL_VERSION;\n    }\n    /**\n     * Cache of processed magic words.\n     */\n    protected Map<String, String> magicWordCache = new HashMap<String, String>();\n    protected LinkedMultiHashMap<String, Long> stats = new LinkedMultiHashMap<String, Long>();\n    /**\n     * All keys that have been read or written during the current operation.\n     */\n    protected final List<InvolvedKey> involvedKeys = new ArrayList<InvolvedKey>();\n    protected ExistingPagesCache existingPages = ExistingPagesCache.NULL_CACHE;\n    protected Map<NormalisedTitle, String> pageCache = new HashMap<NormalisedTitle, String>();\n    /**\n     * Text of the page to render, i.e. given to\n     * {@link #renderPageWithCache(String)} or\n     * {@link #renderPageWithCache(ITextConverter, String)}.\n     */\n    private String renderWikiText = null;\n    protected static final Pattern MATCH_WIKI_FORBIDDEN_TITLE_CHARS =\n            Pattern.compile(\"^.*?([\\\\p{Cc}\\\\p{Cn}\\\\p{Co}#<>\\\\[\\\\]|{}\\\\n\\\\r]).*$\", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n    /**\n     * Pattern to check whether a wikitext is redirecting or not.\n     */\n    public static final Pattern MATCH_WIKI_REDIRECT = Pattern.compile(\"^\\\\s*#REDIRECT[ ]?\\\\[\\\\[:?([^\\\\]#]*)[^\\\\]]*\\\\]\\\\].*$\", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n    static {\n        // BEWARE: fields in Configuration are static -> this changes all configurations!\n        Configuration.DEFAULT_CONFIGURATION.addTemplateFunction(\"fullurl\", MyFullurl.CONST);\n        Configuration.DEFAULT_CONFIGURATION.addTemplateFunction(\"localurl\", MyLocalurl.CONST);\n        // do not put these into the HTML text (they are not rendered anyway)\n        Configuration.DEFAULT_CONFIGURATION.addTokenTag(\"inputbox\", new IgnoreTag(\"inputbox\"));\n        Configuration.DEFAULT_CONFIGURATION.addTokenTag(\"imagemap\", new IgnoreTag(\"imagemap\"));\n        Configuration.DEFAULT_CONFIGURATION.addTokenTag(\"timeline\", new IgnoreTag(\"timeline\"));\n        Configuration.AVOID_PAGE_BREAK_IN_TABLE = false;\n        // allow style attributes:\n        TagNode.addAllowedAttribute(\"style\");\n        // create set of keys for interlanguage wiki links\n        // also add missing hsb interlanguage link:\n        Map<String, String> interWikiMap = Configuration.DEFAULT_CONFIGURATION.getInterwikiMap();\n        INTERLANGUAGE_KEYS = new HashSet<String>(INTERLANGUAGE_STRINGS.length);\n        for (String lang : INTERLANGUAGE_STRINGS) {\n            INTERLANGUAGE_KEYS.add(lang);\n            // if there is no interwiki link for it, create one and guess the URL:\n            if (!interWikiMap.containsKey(lang)) {\n                Configuration.DEFAULT_CONFIGURATION.addInterwikiLink(lang, \"http://\" + lang + \".wiktionary.org/wiki/?${title}\");\n            }\n        }\n        // localised special pages titles (prefix + suffix)\n        // BEWARE: keep SPECIAL_PREFIX and SPECIAL_SUFFIX in sync!\n        SPECIAL_PREFIX.put(\"en\", \"Special\");\n        SPECIAL_PREFIX.put(\"simple\", \"Special\");\n        SPECIAL_PREFIX.put(\"de\", \"Spezial\");\n        SPECIAL_PREFIX.put(\"bar\", \"Spezial\");\n        SPECIAL_PREFIX.put(\"es\", \"Especial\");\n        SPECIAL_PREFIX.put(\"pl\", \"Specjalna\");\n        // BEWARE: include normalised page titles!\n        EnumMap<SpecialPage, String> SPECIAL_SUFFIX_EN = new EnumMap<SpecialPage, String>(SpecialPage.class);\n        SPECIAL_SUFFIX_EN.put(SpecialPage.SPECIAL_RANDOM, \"Random\");\n        SPECIAL_SUFFIX_EN.put(SpecialPage.SPECIAL_ALLPAGES, \"AllPages\");\n        SPECIAL_SUFFIX_EN.put(SpecialPage.SPECIAL_PREFIXINDEX, \"PrefixIndex\");\n        SPECIAL_SUFFIX_EN.put(SpecialPage.SPECIAL_SEARCH, \"Search\");\n        SPECIAL_SUFFIX_EN.put(SpecialPage.SPECIAL_WHATLINKSHERE, \"WhatLinksHere\");\n        SPECIAL_SUFFIX_EN.put(SpecialPage.SPECIAL_SPECIALPAGES, \"SpecialPages\");\n        SPECIAL_SUFFIX_EN.put(SpecialPage.SPECIAL_STATS, \"Statistics\");\n        SPECIAL_SUFFIX_EN.put(SpecialPage.SPECIAL_VERSION, \"Version\");\n        EnumMap<SpecialPage, String> SPECIAL_SUFFIX_DE = new EnumMap<SpecialPage, String>(SpecialPage.class);\n        SPECIAL_SUFFIX_DE.put(SpecialPage.SPECIAL_RANDOM, \"Zuf\u00e4llige Seite\");\n        SPECIAL_SUFFIX_DE.put(SpecialPage.SPECIAL_ALLPAGES, \"Alle Seiten\");\n        SPECIAL_SUFFIX_DE.put(SpecialPage.SPECIAL_PREFIXINDEX, \"Pr\u00e4fixindex\");\n        SPECIAL_SUFFIX_DE.put(SpecialPage.SPECIAL_SEARCH, \"Suche\");\n        SPECIAL_SUFFIX_DE.put(SpecialPage.SPECIAL_WHATLINKSHERE, \"Linkliste\");\n        SPECIAL_SUFFIX_DE.put(SpecialPage.SPECIAL_SPECIALPAGES, \"Spezialseiten\");\n        SPECIAL_SUFFIX_DE.put(SpecialPage.SPECIAL_STATS, \"Statistik\");\n        SPECIAL_SUFFIX_DE.put(SpecialPage.SPECIAL_VERSION, \"Version\");\n        EnumMap<SpecialPage, String> SPECIAL_SUFFIX_ES = new EnumMap<SpecialPage, String>(SpecialPage.class);\n        SPECIAL_SUFFIX_ES.put(SpecialPage.SPECIAL_RANDOM, \"Aleatoria\");\n        SPECIAL_SUFFIX_ES.put(SpecialPage.SPECIAL_ALLPAGES, \"Todas\");\n        SPECIAL_SUFFIX_ES.put(SpecialPage.SPECIAL_PREFIXINDEX, \"P\u00e1ginasPorPrefijo\");\n        SPECIAL_SUFFIX_ES.put(SpecialPage.SPECIAL_SEARCH, \"Buscar\");\n        SPECIAL_SUFFIX_ES.put(SpecialPage.SPECIAL_WHATLINKSHERE, \"LoQueEnlazaAqu\u00ed\");\n        SPECIAL_SUFFIX_ES.put(SpecialPage.SPECIAL_SPECIALPAGES, \"P\u00e1ginasEspeciales\");\n        SPECIAL_SUFFIX_ES.put(SpecialPage.SPECIAL_STATS, \"Estad\u00edsticas\");\n        SPECIAL_SUFFIX_ES.put(SpecialPage.SPECIAL_VERSION, \"Versi\u00f3n\");\n        SPECIAL_SUFFIX.put(\"en\", SPECIAL_SUFFIX_EN);\n        SPECIAL_SUFFIX.put(\"simple\", SPECIAL_SUFFIX_EN);\n        SPECIAL_SUFFIX.put(\"de\", SPECIAL_SUFFIX_DE);\n        SPECIAL_SUFFIX.put(\"bar\", SPECIAL_SUFFIX_DE);\n        SPECIAL_SUFFIX.put(\"es\", SPECIAL_SUFFIX_ES);\n    }\n    /**\n     * Creates a new wiki model to render wiki text fixing some bugs of\n     * {@link WikiModel}.\n     * \n     * @param imageBaseURL\n     *            base url pointing to images - can contain ${image} for\n     *            replacement\n     * @param linkBaseURL\n     *            base url pointing to links - can contain ${title} for\n     *            replacement\n     * @param namespace\n     *            namespace of the wiki\n     */\n    public MyWikiModel(String imageBaseURL, String linkBaseURL, MyNamespace namespace) {\n        super(new MyConfiguration(namespace), null, namespace, imageBaseURL, linkBaseURL);\n        addTemplateFunction(\"#ifexist\", MyIfexistTemplateFun.CONST);\n    }\n    /* (non-Javadoc)\n     * @see info.bliki.wiki.model.AbstractWikiModel#getRawWikiContent(java.lang.String, java.lang.String, java.util.Map)\n     */\n    @Override\n    public String getRawWikiContent(String namespace, String articleName,\n            Map<String, String> templateParameters) {\n        if (isTemplateNamespace(namespace)) {\n            String processedMagicWord = null;\n            processedMagicWord = processMagicWord(articleName);\n            if (processedMagicWord != null) {\n                return processedMagicWord;\n            }\n        }\n        if (!isValidTitle(createFullPageName(namespace, articleName))) {\n            return null;\n        }\n        // (ugly) fix for template parameter replacement if no parameters given,\n        // e.g. \"{{noun}}\" in the simple English Wiktionary\n        if (templateParameters != null && templateParameters.isEmpty()) {\n            templateParameters.put(\"\", null);\n        }\n        // note: cannot cache templates here since the text returned by the\n        // implementation-specific retrievePage() method may depend in the exact\n        // parameters or not\n        return retrievePage(namespace, articleName, templateParameters);\n    }\n    /**\n     * Checks whether the given template name is a magic word and if this is the\n     * case, processes it and returns its value.\n     * \n     * Retrieves magic word contents using\n     * {@link #retrieveMagicWord(String, String, String)} and caches the\n     * contents in {@link #magicWordCache}.\n     * \n     * @param templateName\n     *            the template's name without the namespace, e.g. a magic word\n     *            including its parameters\n     * \n     * @return the contents of the magic word or <tt>null</tt> if the template\n     *         is no magic word\n     */\n    private String processMagicWord(String templateName) {\n        int index = templateName.indexOf(':');\n        String magicWord = templateName;\n        String parameter = \"\";\n        boolean hasParameter = false;\n        if (index > 0) {\n            hasParameter = true;\n            // if it is a magic word, the first part is the word itself, the second its parameters\n            magicWord = templateName.substring(0, index);\n            parameter = templateName.substring(index + 1).trim();\n        }\n        if (isMagicWord(magicWord)) {\n            // cache values for magic words:\n            if (magicWordCache.containsKey(templateName)) {\n                return magicWordCache.get(templateName);\n            } else {\n                String value = retrieveMagicWord(templateName, magicWord, parameter, hasParameter);\n                magicWordCache.put(templateName, value);\n                return value;\n            }\n        } else {\n            return null;\n        }\n    }\n    /**\n     * Determines if a template name corresponds to a magic word using\n     * {@link MyMagicWord#isMagicWord(String)} (does not recognise magic\n     * words with parameters, e.g. <tt>TALKPAGENAME:Title</tt>).\n     * \n     * @param name\n     *            the template name (without the template namespace)\n     * \n     * @return whether the template is a magic word or not\n     */\n    protected boolean isMagicWord(String name) {\n        return MyMagicWord.isMagicWord(name);\n    }\n    /**\n     * Determines if a template name corresponds to a magic word using\n     * {@link #isMagicWord(String)} (also recognises magic\n     * words with parameters, e.g. <tt>TALKPAGENAME:Title</tt>).\n     * \n     * @param name\n     *            the template name (without the template namespace)\n     * \n     * @return whether the template is a magic word or not\n     */\n    public final boolean isMagicWordFull(String name) {\n        return isMagicWord(MyMagicWord.extractMagicWordPart(name));\n    }\n    /**\n     * Gets the names of all included pages in the template namespace (excluding\n     * magic words).\n     * \n     * @return page names without the template namespace prefix\n     * @see #getTemplates()\n     */\n    public final Set<String> getTemplatesNoMagicWords() {\n        final Set<String> result = new HashSet<String>(templates.size());\n        // remove magic words:\n        for (String template : templates) {\n            if (!isMagicWordFull(template)) {\n                result.add(template);\n            }\n        }\n        return result;\n    }\n    /**\n     * Retrieves the contents of the given magic word using\n     * {@link MyMagicWord#processMagicWord(String, String, info.bliki.wiki.model.IWikiModel)}.\n     * \n     * @param templateName\n     *            the template's name without the namespace, e.g. a magic word\n     *            including its parameters\n     * @param magicWord\n     *            the magic word alone\n     * @param parameter\n     *            the parameters of the magic word name\n     * @param hasParameter\n     *            whether a parameter was given or not (cannot distinguish from\n     *            <tt>parameter</tt> value alone)\n     * \n     * @return the contents of the magic word\n     */\n    protected String retrieveMagicWord(String templateName, String magicWord,\n            String parameter, boolean hasParameter) {\n        return MyMagicWord.processMagicWord(templateName, parameter, this, hasParameter);\n    }\n    /**\n     * Renders the \"redirect to\" content in case no auto-redirection is used.\n     * \n     * @param pageTitle\n     *            the title of the page being redirected to\n     * \n     * @return HTML redirect note\n     */\n    public String renderRedirectPage(String pageTitle) {\n        final String redirectUrl = getWikiBaseURL().replace(\"${title}\", pageTitle);\n        final String safeRedirectTitle = StringEscapeUtils.escapeHtml(pageTitle);\n        return \"<div class=\\\"redirectMsg\\\">\"\n                + \"<img src=\\\"skins/redirectltr.png\\\" alt=\\\"#REDIRECT\\\" />\"\n                + \"<span class=\\\"redirectText\\\">\"\n                + \"<a href=\\\"\" + redirectUrl + \"\\\" title=\\\"\" + safeRedirectTitle + \"\\\">\" + pageTitle + \"</a>\"\n                + \"</span></div>\";\n    }\n    /**\n     * Creates the full pagename including the namespace (if non-empty).\n     * \n     * @param namespace\n     *            the namespace of a page\n     * @param articleName\n     *            the name of a page\n     * \n     * @return the full name of the page\n     */\n    public static String createFullPageName(String namespace, String articleName) {\n        String pageName;\n        if (namespace.isEmpty()) {\n            pageName = articleName;\n        } else {\n            pageName = namespace + \":\" + articleName;\n        }\n        return pageName;\n    }\n    /**\n     * Retrieves the contents of the given page.\n     * \n     * @param namespace\n     *            the namespace of the page\n     * @param articleName\n     *            the (unnormalised) page's name without the namespace\n     * @param templateParameters\n     *            template parameters if the page is a template, <tt>null</tt>\n     *            otherwise\n     * \n     * @return <tt>null</tt>\n     * @see #retrievePage(String, String, Map, boolean)\n     */\n    final protected String retrievePage(String namespace, String articleName,\n            Map<String, String> templateParameters) {\n        return retrievePage(namespace, articleName, templateParameters, true);\n    }\n    /**\n     * Retrieves the contents of the given page.\n     * \n     * @param pageName0\n     *            the unnormalised name of the page\n     * @param templateParameters\n     *            template parameters if the page is a template, <tt>null</tt>\n     *            otherwise\n     * @param followRedirect\n     *            whether to follow a redirect or not (at most one redirect\n     *            should be followed)\n     * \n     * @return the page's contents or <tt>null</tt> if no connection exists\n     * @see #retrievePage(String, String, Map, boolean)\n     */\n    final protected String retrievePage(String pageName0,\n            Map<String, String> templateParameters, boolean followRedirect) {\n        String[] parts = splitNsTitle(pageName0);\n        return retrievePage(parts[0], parts[1], templateParameters, followRedirect);\n    }\n    /**\n     * Retrieves the contents of the given page.\n     * \n     * If {@link #hasDBConnection()} is <tt>true</tt>, uses\n     * {@link #getRevFromDB(NormalisedTitle)} to get the content from the DB. If\n     * <tt>followRedirect</tt> is set, resolves redirects by including the\n     * redirected content instead.\n     * \n     * Caches retrieved pages in {@link #pageCache}.\n     * \n     * @param namespace\n     *            the namespace of the page\n     * @param articleName\n     *            the (unnormalised) page's name without the namespace\n     * @param templateParameters\n     *            template parameters if the page is a template, <tt>null</tt>\n     *            otherwise\n     * @param followRedirect\n     *            whether to follow a redirect or not (at most one redirect\n     *            should be followed)\n     * \n     * @return the page's contents or <tt>null</tt> if no connection exists\n     */\n    protected String retrievePage(String namespace, String articleName,\n            Map<String, String> templateParameters, boolean followRedirect) {\n        if (articleName.isEmpty()) {\n            return null;\n        }\n        // normalise page name:\n        NormalisedTitle pageName = normalisePageTitle(namespace, articleName);\n        if (pageCache.containsKey(pageName)) {\n            return pageCache.get(pageName);\n        } else if (hasDBConnection()) {\n            String text = null;\n            // System.out.println(\"retrievePage(\" + namespace + \", \" + articleName + \")\");\n            RevisionResult getRevResult = getRevFromDB(pageName);\n            addStats(getRevResult.stats);\n            addInvolvedKeys(getRevResult.involvedKeys);\n            if (getRevResult.success) {\n                text = getRevResult.revision.unpackedText();\n                if (getRevResult.page.isRedirect()) {\n                    final Matcher matcher = MATCH_WIKI_REDIRECT.matcher(text);\n                    if (matcher.matches()) {\n                        String[] redirFullName = splitNsTitle(matcher.group(1));\n                        if (followRedirect) {\n                            // see https://secure.wikimedia.org/wikipedia/en/wiki/Help:Redirect#Transclusion\n                            String redirText = retrievePage(redirFullName[0], redirFullName[1], templateParameters, false);\n                            if (redirText != null && !redirText.isEmpty()) {\n                                text = redirText;\n                            } else {\n                                text = \"<ol><li>REDIRECT [[\"\n                                        + createFullPageName(redirFullName[0],\n                                                redirFullName[1]) + \"]]</li></ol>\";\n                            }\n                        } else {\n                            // we must disarm the redirect here!\n                            text = \"<ol><li>REDIRECT [[\"\n                                    + createFullPageName(redirFullName[0],\n                                            redirFullName[1]) + \"]]</li></ol>\";\n                        }\n                    } else {\n                        // we must disarm the redirect here!\n                        System.err\n                                .println(\"Couldn't parse the redirect title of \\\"\"\n                                        + createFullPageName(namespace, articleName)\n                                        + \"\\\" in \\\"\"\n                                        + createFullPageName(\n                                                getNamespaceName(),\n                                                getPageName())\n                                        + \"\\\" from: \"\n                                        + text.substring(0, Math.min(100, text.length())));\n                        text = null;\n                    }\n                }\n            } else {\n                // NOTE: must return null for non-existing pages in order for #ifexist to work correctly!\n                // System.err.println(getRevResult.message);\n                // text = \"<b>ERROR: template \" + pageName + \" not available: \" + getRevResult.message + \"</b>\";\n            }\n            pageCache.put(pageName, text);\n            return text;\n        }\n        return null;\n    }\n    protected boolean hasDBConnection() {\n        return false;\n    }\n    protected RevisionResult getRevFromDB(NormalisedTitle title) {\n        return new RevisionResult(false, new ArrayList<InvolvedKey>(),\n                \"no DB connection\", true, title, null, null, false,\n                false, title.toString(), 0l);\n    }\n    /* (non-Javadoc)\n     * @see info.bliki.wiki.model.AbstractWikiModel#encodeTitleToUrl(java.lang.String, boolean)\n     */\n    @Override\n    public String encodeTitleToUrl(String wikiTitle, boolean firstCharacterAsUpperCase) {\n        try {\n            // some links may contain '_' which needs to be translated back to ' ':\n            wikiTitle = wikiTitle.replace('_', ' ');\n            return URLEncoder.encode(wikiTitle, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            return super.encodeTitleToUrl(wikiTitle, firstCharacterAsUpperCase);\n        }\n    }\n    /* (non-Javadoc)\n     * @see info.bliki.wiki.model.WikiModel#getNamespace()\n     */\n    @Override\n    public MyNamespace getNamespace() {\n        return (MyNamespace) super.getNamespace();\n    }\n    /**\n     * Formats the given number using the wiki's locale.\n     * \n     * Note: Currently, the English locale is always used.\n     * \n     * @param rawNumber\n     *            whether the raw number should be returned\n     * @param number\n     *            the number\n     * \n     * @return the formatted number\n     */\n    public String formatStatisticNumber(boolean rawNumber, Number number) {\n        if (rawNumber) {\n            return number.toString();\n        } else {\n            // TODO: use locale from Wiki\n            NumberFormat nf = NumberFormat.getNumberInstance(Locale.ENGLISH);\n            nf.setGroupingUsed(true);\n            return nf.format(number);\n        }\n    }\n    /**\n     * Splits the given full title at the first colon.\n     * \n     * @param fullTitle\n     *            the (full) title including a namespace (if present)\n     * \n     * @return a 2-element array with the two components - the first may be\n     *         empty if no colon is found\n     */\n    protected static String[] splitAtColon(String fullTitle) {\n        int colonIndex = fullTitle.indexOf(':');\n        if (colonIndex != (-1)) {\n            return new String[] { fullTitle.substring(0, colonIndex),\n                    fullTitle.substring(colonIndex + 1) };\n        }\n        return new String[] { \"\", fullTitle };\n    }\n    /* (non-Javadoc)\n     * @see info.bliki.wiki.model.AbstractWikiModel#appendRedirectLink(java.lang.String)\n     */\n    @Override\n    public boolean appendRedirectLink(String redirectLink) {\n        // do not add redirection if we are parsing a template:\n        if (getRecursionLevel() == 0) {\n            // remove \"#section\" from redirect links (this form of redirects is unsupported)\n            if (redirectLink != null) {\n                return super.appendRedirectLink(redirectLink.replaceFirst(\"#.*$\", \"\"));\n            }\n            return super.appendRedirectLink(null);\n        }\n        return true;\n    }\n    /* (non-Javadoc)\n     * @see info.bliki.wiki.model.AbstractWikiModel#appendInterWikiLink(java.lang.String, java.lang.String, java.lang.String)\n     */\n    @Override\n    public void appendInterWikiLink(String namespace, String title, String linkText) {\n        appendInterWikiLink(namespace, title, linkText, true);\n    }\n    protected void appendInterWikiLink(String namespace, String title, String linkText, boolean ignoreInterLang) {\n        if (INTERLANGUAGE_KEYS.contains(namespace)) {\n            // also check if this is an inter wiki link to an external wiki in another language\n            // -> only ignore inter language links to the same wiki\n            String namespace2 = splitAtColon(title)[0];\n            if (!ignoreInterLang || (!namespace2.isEmpty() && isInterWiki(namespace2))) {\n                // bliki is not able to parse language-specific interwiki links\n                // -> use default language\n                super.appendInterWikiLink(namespace2, title, linkText);\n            } else {\n                // ignore interlanguage keys\n            }\n        } else {\n            super.appendInterWikiLink(namespace, title, linkText);\n        }\n    }\n    /* (non-Javadoc)\n     * @see info.bliki.wiki.model.WikiModel#addLink(java.lang.String)\n     */\n    @Override\n    public void addLink(String topicName) {\n        /*\n         * do not add links like [[:w:nl:User:WinContro|Dutch Wikipedia]] to\n         * the internal links\n         */\n        String[] nsTitle = splitAtColon(topicName);\n        if (!nsTitle[0].isEmpty() && isInterWiki(nsTitle[0])) {\n            appendInterWikiLink(nsTitle[0], nsTitle[1], \"\");\n        } else {\n            super.addLink(topicName);\n        }\n    }\n    /* (non-Javadoc)\n     * @see info.bliki.wiki.model.WikiModel#appendInternalLink(java.lang.String, java.lang.String, java.lang.String, java.lang.String, boolean)\n     */\n    @Override\n    public void appendInternalLink(String topic0, String hashSection, String topicDescription,\n            String cssClass, boolean parseRecursive) {\n        /*\n         * convert links like [[:w:nl:User:WinContro|Dutch Wikipedia]] to\n         * external links if the link is an interwiki link\n         */\n        String[] nsTitle = splitAtColon(topic0);\n        if (!nsTitle[0].isEmpty() && isInterWiki(nsTitle[0])) {\n            appendInterWikiLink(nsTitle[0], nsTitle[1], topicDescription, nsTitle[1].isEmpty() && topicDescription.equals(topic0));\n        } else {\n            boolean pageExists = true;\n            if (existingPages.hasContains()) {\n                pageExists = existingPages.contains(normalisePageTitle(topic0));\n            }\n            super.appendInternalLink(topic0, hashSection, topicDescription, cssClass, parseRecursive, pageExists);\n        }\n    }\n    /**\n     * Normalises the given string, i.e. capitalises the first letter and\n     * replaces underscores with spaces.\n     * \n     * @param value\n     *            the string\n     * \n     * @return a normalised string\n     */\n    public static String normaliseName(final String value) {\n        return Encoder.normaliseTitle(value, true, ' ', true);\n    }\n    /**\n     * Normalises the given page title by capitalising its first letter after\n     * the namespace.\n     * \n     * @param title\n     *            the original page title\n     * \n     * @return the normalised page title\n     */\n    public NormalisedTitle normalisePageTitle(final String title) {\n        return NormalisedTitle.fromUnnormalised(title, getNamespace());\n    }\n    /**\n     * Normalises the given page title by capitalising its first letter after\n     * the namespace.\n     * \n     * @param maybeNs\n     *            the namespace of the page\n     * @param articleName\n     *            the (unnormalised) page's name without the namespace\n     * \n     * @return the normalised page title\n     */\n    public NormalisedTitle normalisePageTitle(final String maybeNs, final String articleName) {\n        return NormalisedTitle.fromUnnormalised(maybeNs, articleName, getNamespace());\n    }\n    /**\n     * Normalises the given page title by capitalising its first letter after\n     * the namespace.\n     * \n     * @param <T>\n     * \n     * @param titles\n     *            the original page titles\n     * @param normalisedTitles\n     *            the container to write the normalised titles to\n     * \n     * @return the normalised page titles\n     */\n    public <T extends Collection<NormalisedTitle>> T normalisePageTitles(final Collection<String> titles, T normalisedTitles) {\n        return MyWikiModel.<T>normalisePageTitles(titles, getNamespace(), normalisedTitles);\n    }\n    /**\n     * Normalises the given page titles by capitalising their first letter after\n     * the namespace.\n     * \n     * @param <T>\n     * \n     * @param titles\n     *            the original page titles\n     * @param nsObject\n     *            the namespace for determining how to split the title\n     * @param normalisedTitles\n     *            the container to write the normalised titles to\n     * \n     * @return the normalised page titles\n     */\n    public static <T extends Collection<NormalisedTitle>> T normalisePageTitles(final Collection<String> titles, final MyNamespace nsObject, T normalisedTitles) {\n        for (String title: titles) {\n            normalisedTitles.add(NormalisedTitle.fromUnnormalised(title, nsObject));\n        }\n        return normalisedTitles;\n    }\n    /**\n     * De-normalises the given page titles.\n     * \n     * @param <T>\n     * \n     * @param titles\n     *            the normalised page titles\n     * @param denormalisedTitles\n     *            the container to write the de-normalised titles to\n     * \n     * @return the original page title\n     */\n    public <T extends Collection<String>> T denormalisePageTitles(final Collection<NormalisedTitle> titles, T denormalisedTitles) {\n        return MyWikiModel.<T>denormalisePageTitles(titles, getNamespace(), denormalisedTitles);\n    }\n    /**\n     * De-normalises the given page titles.\n     * \n     * @param <T>\n     * \n     * @param titles\n     *            the normalised page titles\n     * @param nsObject\n     *            the namespace for determining how to split the title\n     * @param denormalisedTitles\n     *            the container to write the de-normalised titles to\n     * \n     * @return the original page title\n     */\n    public static <T extends Collection<String>> T denormalisePageTitles(final Collection<NormalisedTitle> titles, final MyNamespace nsObject, T denormalisedTitles) {\n        for (NormalisedTitle title: titles) {\n            denormalisedTitles.add(title.denormalise(nsObject));\n        }\n        return denormalisedTitles;\n    }\n    /* (non-Javadoc)\n     * @see info.bliki.wiki.model.WikiModel#setUp()\n     */\n    @Override\n    public void setUp() {\n        super.setUp();\n        magicWordCache = new HashMap<String, String>();\n        pageCache = new HashMap<NormalisedTitle, String>();\n        if (renderWikiText != null) {\n            pageCache.put(normalisePageTitle(getPageName()), renderWikiText );\n        }\n    }\n    /**\n     * Checks whether the given namespace is a valid media namespace.\n     * \n     * @param namespace\n     *            the namespace to check\n     * \n     * @return <tt>true</tt> if it is one of the two media namespace strings\n     */\n    public boolean isMediaNamespace(String namespace) {\n        return namespace.equalsIgnoreCase(fNamespace.getMedia()) || namespace.equalsIgnoreCase(fNamespace.getMedia2());\n    }\n    /**\n     * Gets information about the time needed to look up pages.\n     * \n     * @return a mapping of page titles to retrieval times\n     */\n    public Map<String, List<Long>> getStats() {\n        return stats;\n    }\n    /**\n     * Adds the time needed to retrieve the given page to the collected\n     * statistics.\n     * \n     * @param title\n     *            the title of the page\n     * @param value\n     *            the number of milliseconds it took to retrieve the page\n     */\n    public void addStat(String title, long value) {\n        stats.put1(title, value);\n    }\n    /**\n     * Adds the time needed to retrieve the given page to the collected\n     * statistics.\n     * \n     * @param title\n     *            the title of the page\n     * @param value\n     *            multiple number of milliseconds it took to retrieve the page\n     */\n    public void addStats(String title, List<Long> value) {\n        stats.put(title, value);\n    }\n    /**\n     * Adds the time needed to retrieve the given page to the collected\n     * statistics.\n     * \n     * @param values\n     *            a mapping between page titles and the number of milliseconds\n     *            it took to retrieve the page\n     */\n    public void addStats(Map<String, List<Long>> values) {\n        stats.putAll(values);\n    }\n    /**\n     * Adds an involved key to the collected statistics.\n     * \n     * @param key\n     *            the key to add\n     */\n    public void addInvolvedKey(InvolvedKey key) {\n        involvedKeys.add(key);\n    }\n    /**\n     * Adds a number of involved keys to the collected statistics.\n     * \n     * @param keys\n     *            the keys to add\n     */\n    public void addInvolvedKeys(Collection<? extends InvolvedKey> keys) {\n        involvedKeys.addAll(keys);\n    }\n    /**\n     * Gets the list of all keys that have been read or written during the\n     * current operation.\n     * \n     * @return the involvedKeys\n     */\n    public List<InvolvedKey> getInvolvedKeys() {\n        return involvedKeys;\n    }\n    /**\n     * @return the existingPages\n     */\n    public ExistingPagesCache getExistingPages() {\n        return existingPages;\n    }\n    /**\n     * @param existingPages the existingPages to set\n     */\n    public void setExistingPages(ExistingPagesCache existingPages) {\n        this.existingPages = existingPages;\n    }\n    /**\n     * The following characters are forbidden in page titles:\n     * <tt># &lt; &gt; [ ] | { }</tt>. Any line breaks and non-printable unicode\n     * characters are also forbidden here.\n     * \n     * @param title\n     *            the title to check\n     * \n     * @return <tt>true</tt> if the title contains a forbidden character,\n     *         <tt>false</tt> otherwise\n     * \n     * @see #MATCH_WIKI_FORBIDDEN_TITLE_CHARS\n     */\n    public static boolean isValidTitle(String title) {\n        if (title == null || title.isEmpty() || title.length() >= 256) {\n            return false;\n        }\n        final Matcher matcher = MATCH_WIKI_FORBIDDEN_TITLE_CHARS.matcher(title);\n        return !matcher.matches();\n    }\n    /**\n     * Determines whether a page with the given properties is an article.\n     * \n     * A new page in the main namespace will be counted as an article if it\n     * contains at least one wiki link or is categorised to at least one\n     * category.\n     * \n     * @param namespace\n     *            the ID of the namespace of the page\n     * @param links\n     *            the links in this page\n     * @param categories\n     *            categories of this page\n     * \n     * @return whether the page is an article or not\n     * \n     * @see <a\n     *      href=\"https://www.mediawiki.org/wiki/Manual:Article_count\">MediaWiki\n     *      explanation</a>\n     */\n    public static boolean isArticle(int namespace, Collection<String> links,\n            Collection<String> categories) {\n        return (namespace == 0) && (!links.isEmpty() || !categories.isEmpty());\n    }\n    /**\n     * Gets all localised variants for the given special page.\n     * \n     * @param page\n     *            the special page\n     * \n     * @return localised variants including the English names\n     */\n    public static Collection<String> getLocalisedSpecialPageNames(SpecialPage page) {\n        ArrayList<String> result = new ArrayList<String>();\n        for (Entry<String, String> prefix : SPECIAL_PREFIX.entrySet()) {\n            EnumMap<SpecialPage, String> localisedSuffix = SPECIAL_SUFFIX.get(prefix.getKey());\n            if (localisedSuffix != null) {\n                result.add(MyWikiModel.createFullPageName(prefix.getValue(), localisedSuffix.get(page)));\n            }\n            // Also add the English suffix for the localised prefix.\n            EnumMap<SpecialPage, String> englishSuffix = SPECIAL_SUFFIX.get(\"en\");\n            if (englishSuffix != null) {\n                result.add(MyWikiModel.createFullPageName(prefix.getValue(), englishSuffix.get(page)));\n            }\n        }\n        return result;\n    }\n    /**\n     * Gets the localised variants for the given special page.\n     * \n     * @param page\n     *            the special page\n     * @param language\n     *            the language to get the variants for\n     * \n     * @return localised variants including the English names\n     */\n    public static Collection<String> getLocalisedSpecialPageNames(SpecialPage page, String language) {\n        ArrayList<String> result = new ArrayList<String>(4);\n        String localisedPrefix = SPECIAL_PREFIX.get(\"en\");\n        EnumMap<SpecialPage, String> localisedSuffix = SPECIAL_SUFFIX.get(\"en\");\n        result.add(MyWikiModel.createFullPageName(localisedPrefix, localisedSuffix.get(page)));\n        localisedPrefix = SPECIAL_PREFIX.get(language);\n        localisedSuffix = SPECIAL_SUFFIX.get(language);\n        if (localisedPrefix != null && localisedSuffix != null) {\n            result.add(MyWikiModel.createFullPageName(localisedPrefix, localisedSuffix.get(page)));\n        }\n        return result;\n    }\n    /* (non-Javadoc)\n     * @see info.bliki.wiki.model.AbstractWikiModel#isImageNamespace(java.lang.String)\n     */\n    @Override\n    public boolean isImageNamespace(String namespace) {\n        return super.isImageNamespace(namespace) ||\n                ((MyNamespace) fNamespace).getNumberByName(namespace) == Namespace.FILE_NAMESPACE_KEY;\n    }\n    /**\n     * Renders the raw Wikipedia text into a string for a given converter\n     * (renders the wiki text as if a template topic will be displayed\n     * directly).\n     * \n     * @param converter\n     *            a text converter. <b>Note</b> the converter may be\n     *            <code>null</code>, if you only would like to analyze the raw\n     *            wiki text and don't need to convert. This speeds up the\n     *            parsing process.\n     * @param rawWikiText\n     *            a raw wiki text\n     * @return <code>null</code> if an IOException occurs or\n     *         <code>converter==null</code>\n     * \n     * @see info.bliki.wiki.model.AbstractWikiModel#render(info.bliki.wiki.filter.ITextConverter,\n     *      java.lang.String, boolean)\n     */\n    public String renderPageWithCache(ITextConverter converter, String rawWikiText) {\n        renderWikiText = rawWikiText;\n        return super.render(converter, rawWikiText, true);\n    }\n    /**\n     * Renders the raw Wikipedia text into an HTML string and use the default\n     * HTMLConverter (renders the wiki text as if a template topic will be\n     * displayed directly).\n     * \n     * @param rawWikiText\n     *            a raw wiki text\n     * @return <code>null</code> if an IOException occurs\n     * \n     * @see info.bliki.wiki.model.AbstractWikiModel#render(java.lang.String,\n     *      boolean)\n     */\n    public String renderPageWithCache(String rawWikiText) {\n        renderWikiText = rawWikiText;\n        return super.render(new HTMLConverter(), rawWikiText, true);\n    }\n"]]}
{"hexsha": "b614cbabc7331a8bb6c755cb35fa42189bc13983", "ext": "java", "lang": "Java", "content": "public class AlgXmlWriter extends AlgWriterImpl {\n\n    private final XmlOutput xmlOutput;\n    boolean generic = true;\n\n    // TODO jvs 23-Dec-2005:  honor detail level.  The current inheritance structure makes this difficult without duplication; need to factor out the filtering of attributes before rendering.\n\n\n    public AlgXmlWriter( PrintWriter pw, ExplainLevel detailLevel ) {\n        super( pw, detailLevel, true );\n        xmlOutput = new XmlOutput( pw );\n        xmlOutput.setGlob( true );\n        xmlOutput.setCompact( false );\n    }\n\n\n    @Override\n    protected void explain_( AlgNode alg, List<Pair<String, Object>> values ) {\n        if ( generic ) {\n            explainGeneric( alg, values );\n        } else {\n            explainSpecific( alg, values );\n        }\n    }\n\n\n    /**\n     * Generates generic XML (sometimes called 'element-oriented XML'). Like this:\n     *\n     * <blockquote>\n     * <code>\n     * &lt;{@link AlgNode} id=\"1\" type=\"Join\"&gt;<br>\n     * &nbsp;&nbsp;&lt;Property name=\"condition\"&gt;EMP.DEPTNO =\n     * DEPT.DEPTNO&lt;/Property&gt;<br>\n     * &nbsp;&nbsp;&lt;Inputs&gt;<br>\n     * &nbsp;&nbsp;&nbsp;&nbsp;&lt;{@link AlgNode} id=\"2\" type=\"Project\"&gt;<br>\n     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Property name=\"expr1\"&gt;x +\n     * y&lt;/Property&gt;<br>\n     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Property\n     * name=\"expr2\"&gt;45&lt;/Property&gt;<br>\n     * &nbsp;&nbsp;&nbsp;&nbsp;&lt;/AlgNode&gt;<br>\n     * &nbsp;&nbsp;&nbsp;&nbsp;&lt;{@link AlgNode} id=\"3\" type=\"TableAccess\"&gt;<br>\n     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Property\n     * name=\"table\"&gt;SALES.EMP&lt;/Property&gt;<br>\n     * &nbsp;&nbsp;&nbsp;&nbsp;&lt;/AlgNode&gt;<br>\n     * &nbsp;&nbsp;&lt;/Inputs&gt;<br>\n     * &lt;/AlgNode&gt;</code>\n     * </blockquote>\n     *\n     * @param alg Relational expression\n     * @param values List of term-value pairs\n     */\n    private void explainGeneric( AlgNode alg, List<Pair<String, Object>> values ) {\n        String algType = alg.getAlgTypeName();\n        xmlOutput.beginBeginTag( \"AlgNode\" );\n        xmlOutput.attribute( \"type\", algType );\n\n        xmlOutput.endBeginTag( \"AlgNode\" );\n\n        final List<AlgNode> inputs = new ArrayList<>();\n        for ( Pair<String, Object> pair : values ) {\n            if ( pair.right instanceof AlgNode ) {\n                inputs.add( (AlgNode) pair.right );\n                continue;\n            }\n            if ( pair.right == null ) {\n                continue;\n            }\n            xmlOutput.beginBeginTag( \"Property\" );\n            xmlOutput.attribute( \"name\", pair.left );\n            xmlOutput.endBeginTag( \"Property\" );\n            xmlOutput.cdata( pair.right.toString() );\n            xmlOutput.endTag( \"Property\" );\n        }\n        xmlOutput.beginTag( \"Inputs\", null );\n        spacer.add( 2 );\n        for ( AlgNode input : inputs ) {\n            input.explain( this );\n        }\n        spacer.subtract( 2 );\n        xmlOutput.endTag( \"Inputs\" );\n        xmlOutput.endTag( \"AlgNode\" );\n    }\n\n\n    /**\n     * Generates specific XML (sometimes called 'attribute-oriented XML'). Like this:\n     *\n     * <blockquote><pre>\n     * &lt;Join condition=\"EMP.DEPTNO = DEPT.DEPTNO\"&gt;\n     *   &lt;Project expr1=\"x + y\" expr2=\"42\"&gt;\n     *   &lt;TableAccess table=\"SALES.EMPS\"&gt;\n     * &lt;/Join&gt;\n     * </pre></blockquote>\n     *\n     * @param alg Relational expression\n     * @param values List of term-value pairs\n     */\n    private void explainSpecific( AlgNode alg, List<Pair<String, Object>> values ) {\n        String tagName = alg.getAlgTypeName();\n        xmlOutput.beginBeginTag( tagName );\n        xmlOutput.attribute( \"id\", alg.getId() + \"\" );\n\n        for ( Pair<String, Object> value : values ) {\n            if ( value.right instanceof AlgNode ) {\n                continue;\n            }\n            xmlOutput.attribute( value.left, value.right.toString() );\n        }\n        xmlOutput.endBeginTag( tagName );\n        spacer.add( 2 );\n        for ( AlgNode input : alg.getInputs() ) {\n            input.explain( this );\n        }\n        spacer.subtract( 2 );\n    }\n\n}", "class_id": 0, "repo": "erdengk/Polypheny-DB", "file": "core/src/main/java/org/polypheny/db/algebra/externalize/AlgXmlWriter.java", "last_update_at": "2019-09-25T08:01:56+00:00", "question_id": "b614cbabc7331a8bb6c755cb35fa42189bc13983", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AlgXmlWriter extends AlgWriterImpl {\n    private final XmlOutput xmlOutput;\n    boolean generic = true;\n    // TODO jvs 23-Dec-2005:  honor detail level.  The current inheritance structure makes this difficult without duplication; need to factor out the filtering of attributes before rendering.\n    public AlgXmlWriter( PrintWriter pw, ExplainLevel detailLevel ) {\n        super( pw, detailLevel, true );\n        xmlOutput = new XmlOutput( pw );\n        xmlOutput.setGlob( true );\n        xmlOutput.setCompact( false );\n    }\n    @Override\n    protected void explain_( AlgNode alg, List<Pair<String, Object>> values ) {\n        if ( generic ) {\n            explainGeneric( alg, values );\n        } else {\n            explainSpecific( alg, values );\n        }\n    }\n    /**\n     * Generates generic XML (sometimes called 'element-oriented XML'). Like this:\n     *\n     * <blockquote>\n     * <code>\n     * &lt;{@link AlgNode} id=\"1\" type=\"Join\"&gt;<br>\n     * &nbsp;&nbsp;&lt;Property name=\"condition\"&gt;EMP.DEPTNO =\n     * DEPT.DEPTNO&lt;/Property&gt;<br>\n     * &nbsp;&nbsp;&lt;Inputs&gt;<br>\n     * &nbsp;&nbsp;&nbsp;&nbsp;&lt;{@link AlgNode} id=\"2\" type=\"Project\"&gt;<br>\n     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Property name=\"expr1\"&gt;x +\n     * y&lt;/Property&gt;<br>\n     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Property\n     * name=\"expr2\"&gt;45&lt;/Property&gt;<br>\n     * &nbsp;&nbsp;&nbsp;&nbsp;&lt;/AlgNode&gt;<br>\n     * &nbsp;&nbsp;&nbsp;&nbsp;&lt;{@link AlgNode} id=\"3\" type=\"TableAccess\"&gt;<br>\n     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Property\n     * name=\"table\"&gt;SALES.EMP&lt;/Property&gt;<br>\n     * &nbsp;&nbsp;&nbsp;&nbsp;&lt;/AlgNode&gt;<br>\n     * &nbsp;&nbsp;&lt;/Inputs&gt;<br>\n     * &lt;/AlgNode&gt;</code>\n     * </blockquote>\n     *\n     * @param alg Relational expression\n     * @param values List of term-value pairs\n     */\n    private void explainGeneric( AlgNode alg, List<Pair<String, Object>> values ) {\n        String algType = alg.getAlgTypeName();\n        xmlOutput.beginBeginTag( \"AlgNode\" );\n        xmlOutput.attribute( \"type\", algType );\n        xmlOutput.endBeginTag( \"AlgNode\" );\n        final List<AlgNode> inputs = new ArrayList<>();\n        for ( Pair<String, Object> pair : values ) {\n            if ( pair.right instanceof AlgNode ) {\n                inputs.add( (AlgNode) pair.right );\n                continue;\n            }\n            if ( pair.right == null ) {\n                continue;\n            }\n            xmlOutput.beginBeginTag( \"Property\" );\n            xmlOutput.attribute( \"name\", pair.left );\n            xmlOutput.endBeginTag( \"Property\" );\n            xmlOutput.cdata( pair.right.toString() );\n            xmlOutput.endTag( \"Property\" );\n        }\n        xmlOutput.beginTag( \"Inputs\", null );\n        spacer.add( 2 );\n        for ( AlgNode input : inputs ) {\n            input.explain( this );\n        }\n        spacer.subtract( 2 );\n        xmlOutput.endTag( \"Inputs\" );\n        xmlOutput.endTag( \"AlgNode\" );\n    }\n    /**\n     * Generates specific XML (sometimes called 'attribute-oriented XML'). Like this:\n     *\n     * <blockquote><pre>\n     * &lt;Join condition=\"EMP.DEPTNO = DEPT.DEPTNO\"&gt;\n     *   &lt;Project expr1=\"x + y\" expr2=\"42\"&gt;\n     *   &lt;TableAccess table=\"SALES.EMPS\"&gt;\n     * &lt;/Join&gt;\n     * </pre></blockquote>\n     *\n     * @param alg Relational expression\n     * @param values List of term-value pairs\n     */\n    private void explainSpecific( AlgNode alg, List<Pair<String, Object>> values ) {\n        String tagName = alg.getAlgTypeName();\n        xmlOutput.beginBeginTag( tagName );\n        xmlOutput.attribute( \"id\", alg.getId() + \"\" );\n        for ( Pair<String, Object> value : values ) {\n            if ( value.right instanceof AlgNode ) {\n                continue;\n            }\n            xmlOutput.attribute( value.left, value.right.toString() );\n        }\n        xmlOutput.endBeginTag( tagName );\n        spacer.add( 2 );\n        for ( AlgNode input : alg.getInputs() ) {\n            input.explain( this );\n        }\n        spacer.subtract( 2 );\n    }\n"]]}
{"hexsha": "88ea1e41f12eaebfc6b0221b571367b24ab07478", "ext": "java", "lang": "Java", "content": "public final class ArgEdge<S extends State, A extends Action> {\n\tprivate static final int HASH_SEED = 3653;\n\tprivate volatile int hashCode = 0;\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (this == o) return true;\n\t\tif (o == null || getClass() != o.getClass()) return false;\n\t\tArgEdge<?, ?> argEdge = (ArgEdge<?, ?>) o;\n\t\treturn Objects.equals(source.getState(), argEdge.source.getState())\n\t\t\t\t&& Objects.equals(target.getState(), argEdge.target.getState())\n\t\t\t\t&& Objects.equals(action.toString(), argEdge.action.toString());\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint result = hashCode;\n\t\tif (result == 0) {\n\t\t\tresult = HASH_SEED;\n\t\t\tresult = 31 * result + source.getState().hashCode();\n\t\t\tresult = 31 * result + target.getState().hashCode();\n\t\t\tresult = 31 * result + action.toString().hashCode();\n\t\t\thashCode = result;\n\t\t}\n\t\treturn result;\n\t\t// return Objects.hash(source.getState(), target.getState(), action.toString());\n\t}\n\n\tprivate final ArgNode<S, A> source;\n\tprivate final ArgNode<S, A> target;\n\tprivate final A action;\n\n\tArgEdge(final ArgNode<S, A> source, final A action, final ArgNode<S, A> target) {\n\t\tthis.source = source;\n\t\tthis.action = action;\n\t\tthis.target = target;\n\t}\n\n\tpublic ArgNode<S, A> getSource() {\n\t\treturn source;\n\t}\n\n\tpublic ArgNode<S, A> getTarget() {\n\t\treturn target;\n\t}\n\n\tpublic A getAction() {\n\t\treturn action;\n\t}\n\n}", "class_id": 0, "repo": "s0mark/theta", "file": "subprojects/common/analysis/src/main/java/hu/bme/mit/theta/analysis/algorithm/ArgEdge.java", "last_update_at": "2019-10-30T07:34:11+00:00", "question_id": "88ea1e41f12eaebfc6b0221b571367b24ab07478", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class ArgEdge<S extends State, A extends Action> {\n\tprivate static final int HASH_SEED = 3653;\n\tprivate volatile int hashCode = 0;\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (this == o) return true;\n\t\tif (o == null || getClass() != o.getClass()) return false;\n\t\tArgEdge<?, ?> argEdge = (ArgEdge<?, ?>) o;\n\t\treturn Objects.equals(source.getState(), argEdge.source.getState())\n\t\t\t\t&& Objects.equals(target.getState(), argEdge.target.getState())\n\t\t\t\t&& Objects.equals(action.toString(), argEdge.action.toString());\n\t}\n\t@Override\n\tpublic int hashCode() {\n\t\tint result = hashCode;\n\t\tif (result == 0) {\n\t\t\tresult = HASH_SEED;\n\t\t\tresult = 31 * result + source.getState().hashCode();\n\t\t\tresult = 31 * result + target.getState().hashCode();\n\t\t\tresult = 31 * result + action.toString().hashCode();\n\t\t\thashCode = result;\n\t\t}\n\t\treturn result;\n\t\t// return Objects.hash(source.getState(), target.getState(), action.toString());\n\t}\n\tprivate final ArgNode<S, A> source;\n\tprivate final ArgNode<S, A> target;\n\tprivate final A action;\n\tArgEdge(final ArgNode<S, A> source, final A action, final ArgNode<S, A> target) {\n\t\tthis.source = source;\n\t\tthis.action = action;\n\t\tthis.target = target;\n\t}\n\tpublic ArgNode<S, A> getSource() {\n\t\treturn source;\n\t}\n\tpublic ArgNode<S, A> getTarget() {\n\t\treturn target;\n\t}\n\tpublic A getAction() {\n\t\treturn action;\n\t}\n"]]}
{"hexsha": "8dd3c20136e85234227656d2adccc535ed2c6014", "ext": "java", "lang": "Java", "content": "class Thrower {\n    public void f() {\n        // Compiler gives an error: \"unreported\n        // exception MyException; must be caught\n        // or declared to be thrown\"\n        //! throw new MyException(\"Inside f()\");\n    }\n\n    public void g() throws MyException {\n        throw new MyException(\"Inside g()\");\n    }\n}", "class_id": 0, "repo": "letitgone/thinking_in_java", "file": "Chapter12/src/test/java/ExerciseEight.java", "last_update_at": "2019-03-18T11:31:22+00:00", "question_id": "8dd3c20136e85234227656d2adccc535ed2c6014", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Thrower {\n    public void f() {\n        // Compiler gives an error: \"unreported\n        // exception MyException; must be caught\n        // or declared to be thrown\"\n        //! throw new MyException(\"Inside f()\");\n    }\n    public void g() throws MyException {\n        throw new MyException(\"Inside g()\");\n    }\n"]]}
{"hexsha": "2babce80465b4a6a2f9ea601da5b9bcd8ec76f43", "ext": "java", "lang": "Java", "content": "public class OctetEncodingTest extends TestCase implements\n        XMLStreamConstants {\n    \n    public void testSmallChunkedOctets() throws Exception {\n        String envNS = \"http://envelope\";\n        String[] texts = new String[] {\"sdf===ertS\", \"S\", \"I\", \"N\", \"G\", \"L\", \"E\", \"\", \"DDFFEdsfsdf23432423\"};\n        \n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        StAXDocumentSerializer serializer = new StAXDocumentSerializer(out);\n        XMLStreamWriter writer = serializer;\n        writer.writeStartDocument();\n        \n        writer.setPrefix(\"ns1\", envNS);\n        writer.writeStartElement(envNS, \"Envelope\");\n        writer.writeNamespace(\"ns1\", envNS);\n        StringBuffer patternBuffer = new StringBuffer();\n        for(String s : texts) {\n            byte[] buf = s.getBytes();\n            serializer.writeOctets(buf, 0, buf.length);\n            patternBuffer.append(s);\n        }\n        writer.writeEndElement(); // Close just last element\n        \n        writer.writeEndDocument();\n        \n        writer.flush();\n        out.flush();\n        out.close();\n        \n        ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());\n        XMLStreamReader reader = new StAXDocumentParser(in);\n        \n        \n        assertEquals(START_ELEMENT, reader.next());\n        assertEquals(\"Envelope\", reader.getLocalName());\n        \n        BASE64EncodingAlgorithm base64Decoder = new BASE64EncodingAlgorithm();\n        StringBuffer bufToTest = new StringBuffer();\n        while(reader.next() == CHARACTERS) {\n            char[] charBuf = reader.getText().toCharArray();\n            String decodedStr = new String((byte[]) base64Decoder.convertFromCharacters(charBuf, 0, charBuf.length));\n            bufToTest.append(decodedStr);\n        }\n        assertEquals(patternBuffer.toString(), bufToTest.toString());\n        \n        assertEquals(END_ELEMENT, reader.getEventType()); // </Envelope>\n        \n        reader.close();\n        in.close();\n    }\n    \n    public void testBigChunkedOctets() throws Exception {\n        String envNS = \"http://envelope\";\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        StAXDocumentSerializer serializer = new StAXDocumentSerializer(out);\n        XMLStreamWriter writer = serializer;\n        writer.writeStartDocument();\n        \n        writer.setPrefix(\"ns1\", envNS);\n        writer.writeStartElement(envNS, \"Envelope\");\n        writer.writeNamespace(\"ns1\", envNS);\n        StringBuffer patternBuffer = new StringBuffer();\n        for(int i = 0; i < 5; i++) {\n            String s = createRandomString(2000 + i * 100);\n            byte[] buf = s.getBytes();\n            serializer.writeOctets(buf, 0, buf.length);\n            patternBuffer.append(s);\n        }\n        \n        writer.writeEndElement(); // Close just last element\n        \n        writer.writeEndDocument();\n        \n        writer.flush();\n        out.flush();\n        out.close();\n        \n        ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());\n        XMLStreamReader reader = new StAXDocumentParser(in);\n        \n        \n        assertEquals(START_ELEMENT, reader.next());\n        assertEquals(\"Envelope\", reader.getLocalName());\n        \n        BASE64EncodingAlgorithm base64Decoder = new BASE64EncodingAlgorithm();\n        StringBuffer bufToTest = new StringBuffer();\n        while(reader.next() == CHARACTERS) {\n            char[] charBuf = reader.getText().toCharArray();\n            String decodedStr = new String((byte[]) base64Decoder.convertFromCharacters(charBuf, 0, charBuf.length));\n            bufToTest.append(decodedStr);\n        }\n        assertEquals(patternBuffer.toString(), bufToTest.toString());\n        \n        assertEquals(END_ELEMENT, reader.getEventType()); // </Envelope>\n        \n        reader.close();\n        in.close();\n    }\n    \n    private String createRandomString(int length) {\n        StringBuffer sb = new StringBuffer(length);\n        Random random = new Random();\n        for(int i=0; i<length; i++) {\n            sb.append((char) (random.nextInt(20) + 'a'));\n        }\n        \n        return sb.toString();\n    }\n}", "class_id": 0, "repo": "pbielicki/fastinfoset-java", "file": "fastinfoset/src/test/java/stax/OctetEncodingTest.java", "last_update_at": "2019-01-30T23:37:14+00:00", "question_id": "2babce80465b4a6a2f9ea601da5b9bcd8ec76f43", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OctetEncodingTest extends TestCase implements\n        XMLStreamConstants {\n    public void testSmallChunkedOctets() throws Exception {\n        String envNS = \"http://envelope\";\n        String[] texts = new String[] {\"sdf===ertS\", \"S\", \"I\", \"N\", \"G\", \"L\", \"E\", \"\", \"DDFFEdsfsdf23432423\"};\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        StAXDocumentSerializer serializer = new StAXDocumentSerializer(out);\n        XMLStreamWriter writer = serializer;\n        writer.writeStartDocument();\n        writer.setPrefix(\"ns1\", envNS);\n        writer.writeStartElement(envNS, \"Envelope\");\n        writer.writeNamespace(\"ns1\", envNS);\n        StringBuffer patternBuffer = new StringBuffer();\n        for(String s : texts) {\n            byte[] buf = s.getBytes();\n            serializer.writeOctets(buf, 0, buf.length);\n            patternBuffer.append(s);\n        }\n        writer.writeEndElement(); // Close just last element\n        writer.writeEndDocument();\n        writer.flush();\n        out.flush();\n        out.close();\n        ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());\n        XMLStreamReader reader = new StAXDocumentParser(in);\n        assertEquals(START_ELEMENT, reader.next());\n        assertEquals(\"Envelope\", reader.getLocalName());\n        BASE64EncodingAlgorithm base64Decoder = new BASE64EncodingAlgorithm();\n        StringBuffer bufToTest = new StringBuffer();\n        while(reader.next() == CHARACTERS) {\n            char[] charBuf = reader.getText().toCharArray();\n            String decodedStr = new String((byte[]) base64Decoder.convertFromCharacters(charBuf, 0, charBuf.length));\n            bufToTest.append(decodedStr);\n        }\n        assertEquals(patternBuffer.toString(), bufToTest.toString());\n        assertEquals(END_ELEMENT, reader.getEventType()); // </Envelope>\n        reader.close();\n        in.close();\n    }\n    public void testBigChunkedOctets() throws Exception {\n        String envNS = \"http://envelope\";\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        StAXDocumentSerializer serializer = new StAXDocumentSerializer(out);\n        XMLStreamWriter writer = serializer;\n        writer.writeStartDocument();\n        writer.setPrefix(\"ns1\", envNS);\n        writer.writeStartElement(envNS, \"Envelope\");\n        writer.writeNamespace(\"ns1\", envNS);\n        StringBuffer patternBuffer = new StringBuffer();\n        for(int i = 0; i < 5; i++) {\n            String s = createRandomString(2000 + i * 100);\n            byte[] buf = s.getBytes();\n            serializer.writeOctets(buf, 0, buf.length);\n            patternBuffer.append(s);\n        }\n        writer.writeEndElement(); // Close just last element\n        writer.writeEndDocument();\n        writer.flush();\n        out.flush();\n        out.close();\n        ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());\n        XMLStreamReader reader = new StAXDocumentParser(in);\n        assertEquals(START_ELEMENT, reader.next());\n        assertEquals(\"Envelope\", reader.getLocalName());\n        BASE64EncodingAlgorithm base64Decoder = new BASE64EncodingAlgorithm();\n        StringBuffer bufToTest = new StringBuffer();\n        while(reader.next() == CHARACTERS) {\n            char[] charBuf = reader.getText().toCharArray();\n            String decodedStr = new String((byte[]) base64Decoder.convertFromCharacters(charBuf, 0, charBuf.length));\n            bufToTest.append(decodedStr);\n        }\n        assertEquals(patternBuffer.toString(), bufToTest.toString());\n        assertEquals(END_ELEMENT, reader.getEventType()); // </Envelope>\n        reader.close();\n        in.close();\n    }\n    private String createRandomString(int length) {\n        StringBuffer sb = new StringBuffer(length);\n        Random random = new Random();\n        for(int i=0; i<length; i++) {\n            sb.append((char) (random.nextInt(20) + 'a'));\n        }\n        return sb.toString();\n    }\n"]]}
{"hexsha": "96cdb480e98e0ea4fe84257bd25c036c94c3a4a4", "ext": "java", "lang": "Java", "content": "@Service\npublic class DiffService {\n\n    public LinkedList<diff_match_patch.Diff> getDiff(Context context, Options options) {\n        diff_match_patch diffMatchPatch = new diff_match_patch();\n\n        diffMatchPatch.Diff_Timeout = options.getTimeout();\n\n        LinkedList<diff_match_patch.Diff> diffLinkedList = diffMatchPatch.diff_main(context.getOriginal(), context.getRevised(), options.isCheckLines());\n\n        if (options.getCleanupSemantic()) {\n            diffMatchPatch.diff_cleanupSemantic(diffLinkedList);\n        }\n\n        return diffLinkedList;\n    }\n    public String toPrettyHtml(LinkedList<diff_match_patch.Diff> diffs) {\n        StringBuffer buffer = new StringBuffer();\n        diffs.forEach(diff -> {\n            switch (diff.operation) {\n                case EQUAL:\n                    buffer.append(String.format(\"<span>%s</span>\", diff.text));\n                    break;\n                case INSERT:\n                    buffer.append(String.format(\"<ins>%s</ins>\", diff.text));\n                    break;\n                case  DELETE:\n                    buffer.append(String.format(\"<del>%s</del>\", diff.text));\n                    break;\n            }\n        });\n\n        return buffer.toString();\n    }\n\n}", "class_id": 0, "repo": "o/rest-diff", "file": "src/main/java/nl/youwe/diff/service/DiffService.java", "last_update_at": "2019-04-16T12:08:24+00:00", "question_id": "96cdb480e98e0ea4fe84257bd25c036c94c3a4a4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\npublic class DiffService {\n    public LinkedList<diff_match_patch.Diff> getDiff(Context context, Options options) {\n        diff_match_patch diffMatchPatch = new diff_match_patch();\n        diffMatchPatch.Diff_Timeout = options.getTimeout();\n        LinkedList<diff_match_patch.Diff> diffLinkedList = diffMatchPatch.diff_main(context.getOriginal(), context.getRevised(), options.isCheckLines());\n        if (options.getCleanupSemantic()) {\n            diffMatchPatch.diff_cleanupSemantic(diffLinkedList);\n        }\n        return diffLinkedList;\n    }\n    public String toPrettyHtml(LinkedList<diff_match_patch.Diff> diffs) {\n        StringBuffer buffer = new StringBuffer();\n        diffs.forEach(diff -> {\n            switch (diff.operation) {\n                case EQUAL:\n                    buffer.append(String.format(\"<span>%s</span>\", diff.text));\n                    break;\n                case INSERT:\n                    buffer.append(String.format(\"<ins>%s</ins>\", diff.text));\n                    break;\n                case  DELETE:\n                    buffer.append(String.format(\"<del>%s</del>\", diff.text));\n                    break;\n            }\n        });\n        return buffer.toString();\n    }\n"]]}
{"hexsha": "5913abb6ae4e4434205e8ee24b456b8fe22365e2", "ext": "java", "lang": "Java", "content": "public class UglyNumber {\n    public static int GetUglyNumber_Solution(int index) {\n        List<Integer> array = new ArrayList<>(index - 1);\n        List<Integer> ugly = new ArrayList<>();\n        ugly.add(2);\n        ugly.add(3);\n        ugly.add(5);\n        array.add(1);\n        int num = 2;\n        while (array.size() < index) {\n            List<Integer> primeNumber = new ArrayList<>();\n            for (int i = 2; i < num; i++) {\n                if (num % i == 0) {\n                    primeNumber.add(i);\n                }\n            }\n            primeNumber.removeAll(ugly);\n            if (primeNumber.size() == 0) {\n                array.add(num++);\n            }\n        }\n        return array.get(array.size() - 1);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(GetUglyNumber_Solution(8));\n    }\n}", "class_id": 0, "repo": "ztt0928/begin", "file": "src/algorithm/lxy/UglyNumber.java", "last_update_at": "2019-10-27T00:15:40+00:00", "question_id": "5913abb6ae4e4434205e8ee24b456b8fe22365e2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class UglyNumber {\n    public static int GetUglyNumber_Solution(int index) {\n        List<Integer> array = new ArrayList<>(index - 1);\n        List<Integer> ugly = new ArrayList<>();\n        ugly.add(2);\n        ugly.add(3);\n        ugly.add(5);\n        array.add(1);\n        int num = 2;\n        while (array.size() < index) {\n            List<Integer> primeNumber = new ArrayList<>();\n            for (int i = 2; i < num; i++) {\n                if (num % i == 0) {\n                    primeNumber.add(i);\n                }\n            }\n            primeNumber.removeAll(ugly);\n            if (primeNumber.size() == 0) {\n                array.add(num++);\n            }\n        }\n        return array.get(array.size() - 1);\n    }\n    public static void main(String[] args) {\n        System.out.println(GetUglyNumber_Solution(8));\n    }\n"]]}
{"hexsha": "38a3e8b0de256a18e4f992c656668d91ff56f017", "ext": "java", "lang": "Java", "content": "class ViewHighlighter$OverlayHighlighter$1\n\timplements Runnable\n{\n\n\tpublic void run()\n\t{\n\t\tViewHighlighter.OverlayHighlighter.access$100(ViewHighlighter.OverlayHighlighter.this);\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #17  <Field ViewHighlighter$OverlayHighlighter this$0>\n\t//    2    4:invokestatic    #25  <Method void ViewHighlighter$OverlayHighlighter.access$100(ViewHighlighter$OverlayHighlighter)>\n\t//    3    7:return          \n\t}\n\n\tfinal ViewHighlighter.OverlayHighlighter this$0;\n\n\tViewHighlighter$OverlayHighlighter$1()\n\t{\n\t\tthis$0 = ViewHighlighter.OverlayHighlighter.this;\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:putfield        #17  <Field ViewHighlighter$OverlayHighlighter this$0>\n\t\tsuper();\n\t//    3    5:aload_0         \n\t//    4    6:invokespecial   #20  <Method void Object()>\n\t//    5    9:return          \n\t}\n}", "class_id": 0, "repo": "Andreas237/AndroidPolicyAutomation", "file": "ExtractedJars/Ibotta_com.ibotta.android/javafiles/com/facebook/stetho/inspector/elements/android/ViewHighlighter$OverlayHighlighter$1.java", "last_update_at": "2019-07-06T22:21:59+00:00", "question_id": "38a3e8b0de256a18e4f992c656668d91ff56f017", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class ViewHighlighter$OverlayHighlighter$1\n\timplements Runnable\n{\n\tpublic void run()\n\t{\n\t\tViewHighlighter.OverlayHighlighter.access$100(ViewHighlighter.OverlayHighlighter.this);\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #17  <Field ViewHighlighter$OverlayHighlighter this$0>\n\t//    2    4:invokestatic    #25  <Method void ViewHighlighter$OverlayHighlighter.access$100(ViewHighlighter$OverlayHighlighter)>\n\t//    3    7:return          \n\t}\n\tfinal ViewHighlighter.OverlayHighlighter this$0;\n\tViewHighlighter$OverlayHighlighter$1()\n\t{\n\t\tthis$0 = ViewHighlighter.OverlayHighlighter.this;\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:putfield        #17  <Field ViewHighlighter$OverlayHighlighter this$0>\n\t\tsuper();\n\t//    3    5:aload_0         \n\t//    4    6:invokespecial   #20  <Method void Object()>\n\t//    5    9:return          \n\t}\n"]]}
{"hexsha": "220079aeaf150fd54df0fd4ce56dc2d3c5cf40b5", "ext": "java", "lang": "Java", "content": "public class MappingsTest\n    extends TestCase\n{\n    /**\n     * Constructor for MappingsTest.\n     *\n     * @param name the name for this test case\n     */\n    public MappingsTest(String name)\n    {\n        super(name);\n    }\n\n    private static final String TO_1 = \"base64Binary\";\n    private static final String FROM_1 = \"datatype.Blob\";\n    private static final String FROM_2 = \"datatype.byte[]\";\n    private static final String FROM_3 = \"datatype.Byte[]\";\n    private static final String FROM_4 = \"datatype.Clob\";\n    private static final String TO_2 = \"java.lang.String\";\n    private static final String FROM_5 = \"datatype.String\";\n    private static final String NOT_MAPPED_1 = \"datatype.byte\";\n    private static final String NOT_MAPPED_2 = \"datatype.String[]\";\n    private static final String TO_3 = \"Class<? extends ToType>\";\n    private static final String FROM_6 = \"Class<? extends FromType>\";\n\n    /**\n     *\n     */\n    public void testGetTo()\n    {\n        Mappings mappings1 = new Mappings();\n        Mapping mapping1 = new Mapping();\n        mapping1.setTo(TO_1);\n        mapping1.addFrom(FROM_1);\n        mapping1.addFrom(FROM_2);\n        mapping1.addFrom(FROM_3);\n        mapping1.addFrom(FROM_4);\n        mappings1.addMapping(mapping1);\n\n        // make sure the to == from when passing in a mappings1 that don't exist\n        assertNotNull(mappings1.getTo(NOT_MAPPED_1));\n        assertEquals(\n            NOT_MAPPED_1,\n            mappings1.getTo(NOT_MAPPED_1));\n        assertEquals(\n            mappings1.getTo(NOT_MAPPED_2),\n            mappings1.getTo(NOT_MAPPED_2));\n\n        // make sure we can retrieve the to using a from array.\n        assertNotNull(mappings1.getTo(FROM_1));\n        assertEquals(\n            TO_1,\n            mappings1.getTo(FROM_1));\n\n        // make sure we can retrieve the to using a from non array.\n        assertEquals(\n            TO_1,\n            mappings1.getTo(FROM_4));\n\n        Mappings mappings2 = new Mappings();\n        Mapping mapping2 = new Mapping();\n        mapping2.setTo(TO_2);\n        mapping2.addFrom(FROM_5);\n        mappings2.addMapping(mapping2);\n        assertEquals(\n            TO_2,\n            mappings2.getTo(FROM_5));\n\n        Mappings mappings3 = new Mappings();\n        Mapping mapping3 = new Mapping();\n        mapping3.setTo(TO_3);\n        mapping3.addFrom(FROM_6);\n        mappings3.addMapping(mapping3);\n        // make sure whitespace isn't deleted, only trimmed (Java generics would fail compilation otherwise for example)\n        assertEquals(\n            TO_3,\n            mappings3.getTo(FROM_6));\n    }\n\n    /**\n     *\n     */\n    public void testMappingsInheritance()\n    {\n        final URL testMappingsParentUri = MappingsTest.class.getResource(\"TestMappingsParent.xml\");\n        assertNotNull(testMappingsParentUri);\n        final Mappings testMappingsParent = Mappings.getInstance(testMappingsParentUri);\n        assertNotNull(testMappingsParent);\n        final Collection<Mapping> mappings1 = testMappingsParent.getMappings();\n        assertEquals(\n            3,\n            mappings1.size());\n        final Iterator mappings1Iterator = mappings1.iterator();\n        Mapping mapping1 = (Mapping)mappings1Iterator.next();\n        assertEquals(\n            \"datatype::typeOne\",\n            mapping1.getFroms().iterator().next());\n        assertEquals(\n            \"Type_One\",\n            mapping1.getTo());\n        Mapping mapping2 = (Mapping)mappings1Iterator.next();\n        assertEquals(\n            \"datatype::typeTwo\",\n            mapping2.getFroms().iterator().next());\n        assertEquals(\n            \"Type_Two\",\n            mapping2.getTo());\n        Mapping mapping3 = (Mapping)mappings1Iterator.next();\n        assertEquals(\n            \"datatype::typeThree\",\n            mapping3.getFroms().iterator().next());\n        assertEquals(\n            \"Type_Three\",\n            mapping3.getTo());\n\n        final URL testMappingsUri = MappingsTest.class.getResource(\"TestMappings.xml\");\n        assertNotNull(testMappingsUri);\n        Mappings testMappings = Mappings.getInstance(testMappingsUri);\n        assertNotNull(testMappings);\n        final Collection<Mapping> mappings2 = testMappings.getMappings();\n        assertEquals(\n            4,\n            mappings2.size());\n        final Iterator mappings2Iterator = mappings2.iterator();\n        mapping1 = (Mapping)mappings2Iterator.next();\n        assertEquals(\n            \"datatype::typeOne\",\n            mapping1.getFroms().iterator().next());\n        assertEquals(\n            \"Type_One\",\n            mapping1.getTo());\n        mapping2 = (Mapping)mappings2Iterator.next();\n        assertEquals(\n            \"datatype::typeTwo\",\n            mapping2.getFroms().iterator().next());\n        assertEquals(\n            \"Overridden\",\n            mapping2.getTo());\n        mapping3 = (Mapping)mappings2Iterator.next();\n        assertEquals(\n            \"datatype::typeThree\",\n            mapping3.getFroms().iterator().next());\n        assertEquals(\n            \"Type_Three\",\n            mapping3.getTo());\n        Mapping mapping4 = (Mapping)mappings2Iterator.next();\n        assertEquals(\n            \"datatype::typeFour\",\n            mapping4.getFroms().iterator().next());\n        assertEquals(\n            \"Type_Four\",\n            mapping4.getTo());\n    }\n\n    /**\n     *\n     */\n    public void testEmptyMappings()\n    {\n        final URL testEmptyMappingsUri = MappingsTest.class.getResource(\"TestMappingsEmpty.xml\");\n        assertNotNull(testEmptyMappingsUri);\n\n        final Mappings mappings = Mappings.getInstance(testEmptyMappingsUri);\n        assertNotNull(mappings);\n\n        final Collection<Mapping> mappingCollection = mappings.getMappings();\n        assertEquals(0, mappingCollection.size());\n    }\n\n    /**\n     *\n     */\n    public void testTransitivelyExtendingLogicalMappings()\n    {\n        // the order has been mixed up on purpose\n        Mappings.addLogicalMappings(MappingsTest.class.getResource(\"TestMappingsExtendsLevelA.xml\"));\n        Mappings.addLogicalMappings(MappingsTest.class.getResource(\"TestMappingsExtendsLevelD.xml\"));\n        Mappings.addLogicalMappings(MappingsTest.class.getResource(\"TestMappingsExtendsLevelC.xml\"));\n        Mappings.addLogicalMappings(MappingsTest.class.getResource(\"TestMappingsExtendsLevelB.xml\"));\n\n        Mappings.initializeLogicalMappings();\n\n        final Mappings mappings = Mappings.getInstance(\"TestMappingsExtendsLevelD\");\n        assertNotNull(mappings);\n\n        final Mapping aaa = mappings.getMapping(\"datatype::aaa\");\n        assertNotNull(aaa);\n        assertEquals(\"AAA\", aaa.getTo());\n\n        final Mapping bbb = mappings.getMapping(\"datatype::bbb\");\n        assertNotNull(bbb);\n        assertEquals(\"BBB\", bbb.getTo());\n\n        final Mapping ccc = mappings.getMapping(\"datatype::ccc\");\n        assertNotNull(ccc);\n        assertEquals(\"CCC\", ccc.getTo());\n\n        final Mapping ddd = mappings.getMapping(\"datatype::ddd\");\n        assertNotNull(ddd);\n        assertEquals(\"DDD\", ddd.getTo());\n    }\n\n    /**\n     *\n     */\n    public void testCyclicInheritanceLogicalMappingsException()\n    {\n        Mappings.addLogicalMappings(MappingsTest.class.getResource(\"TestMappingsCyclicA.xml\"));\n        Mappings.addLogicalMappings(MappingsTest.class.getResource(\"TestMappingsCyclicB.xml\"));\n\n        try\n        {\n            Mappings.initializeLogicalMappings();\n            fail(\"Expected exception\");\n        }\n        catch (MappingsException mappingsException)\n        {\n            final String message = mappingsException.getMessage();\n            assertTrue(message.startsWith(\"Logical mappings cannot be initialized due to invalid inheritance\"));\n            assertTrue(message.contains(\"TestMappingsCyclicA\"));\n            assertTrue(message.contains(\"TestMappingsCyclicB\"));\n        }\n        finally\n        {\n            // clear out the cached entries so that the other tests won't fail because if the invalid\n            // ones we have entered here\n            Mappings.clearLogicalMappings();\n        }\n    }\n}", "class_id": 0, "repo": "wpradnyana/andromda", "file": "andromda-core/src/test/java/org/andromda/core/mappings/MappingsTest.java", "last_update_at": "2019-11-02T06:25:37+00:00", "question_id": "220079aeaf150fd54df0fd4ce56dc2d3c5cf40b5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MappingsTest\n    extends TestCase\n{\n    /**\n     * Constructor for MappingsTest.\n     *\n     * @param name the name for this test case\n     */\n    public MappingsTest(String name)\n    {\n        super(name);\n    }\n    private static final String TO_1 = \"base64Binary\";\n    private static final String FROM_1 = \"datatype.Blob\";\n    private static final String FROM_2 = \"datatype.byte[]\";\n    private static final String FROM_3 = \"datatype.Byte[]\";\n    private static final String FROM_4 = \"datatype.Clob\";\n    private static final String TO_2 = \"java.lang.String\";\n    private static final String FROM_5 = \"datatype.String\";\n    private static final String NOT_MAPPED_1 = \"datatype.byte\";\n    private static final String NOT_MAPPED_2 = \"datatype.String[]\";\n    private static final String TO_3 = \"Class<? extends ToType>\";\n    private static final String FROM_6 = \"Class<? extends FromType>\";\n    /**\n     *\n     */\n    public void testGetTo()\n    {\n        Mappings mappings1 = new Mappings();\n        Mapping mapping1 = new Mapping();\n        mapping1.setTo(TO_1);\n        mapping1.addFrom(FROM_1);\n        mapping1.addFrom(FROM_2);\n        mapping1.addFrom(FROM_3);\n        mapping1.addFrom(FROM_4);\n        mappings1.addMapping(mapping1);\n        // make sure the to == from when passing in a mappings1 that don't exist\n        assertNotNull(mappings1.getTo(NOT_MAPPED_1));\n        assertEquals(\n            NOT_MAPPED_1,\n            mappings1.getTo(NOT_MAPPED_1));\n        assertEquals(\n            mappings1.getTo(NOT_MAPPED_2),\n            mappings1.getTo(NOT_MAPPED_2));\n        // make sure we can retrieve the to using a from array.\n        assertNotNull(mappings1.getTo(FROM_1));\n        assertEquals(\n            TO_1,\n            mappings1.getTo(FROM_1));\n        // make sure we can retrieve the to using a from non array.\n        assertEquals(\n            TO_1,\n            mappings1.getTo(FROM_4));\n        Mappings mappings2 = new Mappings();\n        Mapping mapping2 = new Mapping();\n        mapping2.setTo(TO_2);\n        mapping2.addFrom(FROM_5);\n        mappings2.addMapping(mapping2);\n        assertEquals(\n            TO_2,\n            mappings2.getTo(FROM_5));\n        Mappings mappings3 = new Mappings();\n        Mapping mapping3 = new Mapping();\n        mapping3.setTo(TO_3);\n        mapping3.addFrom(FROM_6);\n        mappings3.addMapping(mapping3);\n        // make sure whitespace isn't deleted, only trimmed (Java generics would fail compilation otherwise for example)\n        assertEquals(\n            TO_3,\n            mappings3.getTo(FROM_6));\n    }\n    /**\n     *\n     */\n    public void testMappingsInheritance()\n    {\n        final URL testMappingsParentUri = MappingsTest.class.getResource(\"TestMappingsParent.xml\");\n        assertNotNull(testMappingsParentUri);\n        final Mappings testMappingsParent = Mappings.getInstance(testMappingsParentUri);\n        assertNotNull(testMappingsParent);\n        final Collection<Mapping> mappings1 = testMappingsParent.getMappings();\n        assertEquals(\n            3,\n            mappings1.size());\n        final Iterator mappings1Iterator = mappings1.iterator();\n        Mapping mapping1 = (Mapping)mappings1Iterator.next();\n        assertEquals(\n            \"datatype::typeOne\",\n            mapping1.getFroms().iterator().next());\n        assertEquals(\n            \"Type_One\",\n            mapping1.getTo());\n        Mapping mapping2 = (Mapping)mappings1Iterator.next();\n        assertEquals(\n            \"datatype::typeTwo\",\n            mapping2.getFroms().iterator().next());\n        assertEquals(\n            \"Type_Two\",\n            mapping2.getTo());\n        Mapping mapping3 = (Mapping)mappings1Iterator.next();\n        assertEquals(\n            \"datatype::typeThree\",\n            mapping3.getFroms().iterator().next());\n        assertEquals(\n            \"Type_Three\",\n            mapping3.getTo());\n        final URL testMappingsUri = MappingsTest.class.getResource(\"TestMappings.xml\");\n        assertNotNull(testMappingsUri);\n        Mappings testMappings = Mappings.getInstance(testMappingsUri);\n        assertNotNull(testMappings);\n        final Collection<Mapping> mappings2 = testMappings.getMappings();\n        assertEquals(\n            4,\n            mappings2.size());\n        final Iterator mappings2Iterator = mappings2.iterator();\n        mapping1 = (Mapping)mappings2Iterator.next();\n        assertEquals(\n            \"datatype::typeOne\",\n            mapping1.getFroms().iterator().next());\n        assertEquals(\n            \"Type_One\",\n            mapping1.getTo());\n        mapping2 = (Mapping)mappings2Iterator.next();\n        assertEquals(\n            \"datatype::typeTwo\",\n            mapping2.getFroms().iterator().next());\n        assertEquals(\n            \"Overridden\",\n            mapping2.getTo());\n        mapping3 = (Mapping)mappings2Iterator.next();\n        assertEquals(\n            \"datatype::typeThree\",\n            mapping3.getFroms().iterator().next());\n        assertEquals(\n            \"Type_Three\",\n            mapping3.getTo());\n        Mapping mapping4 = (Mapping)mappings2Iterator.next();\n        assertEquals(\n            \"datatype::typeFour\",\n            mapping4.getFroms().iterator().next());\n        assertEquals(\n            \"Type_Four\",\n            mapping4.getTo());\n    }\n    /**\n     *\n     */\n    public void testEmptyMappings()\n    {\n        final URL testEmptyMappingsUri = MappingsTest.class.getResource(\"TestMappingsEmpty.xml\");\n        assertNotNull(testEmptyMappingsUri);\n        final Mappings mappings = Mappings.getInstance(testEmptyMappingsUri);\n        assertNotNull(mappings);\n        final Collection<Mapping> mappingCollection = mappings.getMappings();\n        assertEquals(0, mappingCollection.size());\n    }\n    /**\n     *\n     */\n    public void testTransitivelyExtendingLogicalMappings()\n    {\n        // the order has been mixed up on purpose\n        Mappings.addLogicalMappings(MappingsTest.class.getResource(\"TestMappingsExtendsLevelA.xml\"));\n        Mappings.addLogicalMappings(MappingsTest.class.getResource(\"TestMappingsExtendsLevelD.xml\"));\n        Mappings.addLogicalMappings(MappingsTest.class.getResource(\"TestMappingsExtendsLevelC.xml\"));\n        Mappings.addLogicalMappings(MappingsTest.class.getResource(\"TestMappingsExtendsLevelB.xml\"));\n        Mappings.initializeLogicalMappings();\n        final Mappings mappings = Mappings.getInstance(\"TestMappingsExtendsLevelD\");\n        assertNotNull(mappings);\n        final Mapping aaa = mappings.getMapping(\"datatype::aaa\");\n        assertNotNull(aaa);\n        assertEquals(\"AAA\", aaa.getTo());\n        final Mapping bbb = mappings.getMapping(\"datatype::bbb\");\n        assertNotNull(bbb);\n        assertEquals(\"BBB\", bbb.getTo());\n        final Mapping ccc = mappings.getMapping(\"datatype::ccc\");\n        assertNotNull(ccc);\n        assertEquals(\"CCC\", ccc.getTo());\n        final Mapping ddd = mappings.getMapping(\"datatype::ddd\");\n        assertNotNull(ddd);\n        assertEquals(\"DDD\", ddd.getTo());\n    }\n    /**\n     *\n     */\n    public void testCyclicInheritanceLogicalMappingsException()\n    {\n        Mappings.addLogicalMappings(MappingsTest.class.getResource(\"TestMappingsCyclicA.xml\"));\n        Mappings.addLogicalMappings(MappingsTest.class.getResource(\"TestMappingsCyclicB.xml\"));\n        try\n        {\n            Mappings.initializeLogicalMappings();\n            fail(\"Expected exception\");\n        }\n        catch (MappingsException mappingsException)\n        {\n            final String message = mappingsException.getMessage();\n            assertTrue(message.startsWith(\"Logical mappings cannot be initialized due to invalid inheritance\"));\n            assertTrue(message.contains(\"TestMappingsCyclicA\"));\n            assertTrue(message.contains(\"TestMappingsCyclicB\"));\n        }\n        finally\n        {\n            // clear out the cached entries so that the other tests won't fail because if the invalid\n            // ones we have entered here\n            Mappings.clearLogicalMappings();\n        }\n    }\n"]]}
{"hexsha": "e10f99dd7a854d5cc38842e20d28c67e1816a35d", "ext": "java", "lang": "Java", "content": "@Slf4j\npublic class ExceptionHandlerAdvice {\n\n    /**\n     * \u5f02\u5e38\u5904\u7406\u3002\n     * @param e\n     * \u5f02\u5e38\u3002\n     * @return \u8fd4\u56de\u3002\n     */\n    @ExceptionHandler(value = { Exception.class })\n    @ResponseBody\n    public Response<Serializable> handlerException(final Exception e) {\n        log.warn(\"handlerException-exp: \" + e);\n        if(e instanceof AuthenException){\n            //\u89e3\u6790\u9519\u8bef\u4ee3\u7801\n            final RespStatus respStatus = RespStatus.parse(((AuthenException)e).getCode());\n            if(respStatus != null){\n                //\u521b\u5efa\u54cd\u5e94\u62a5\u6587\n                return RespUtils.createResponse(respStatus);\n            }\n        }\n        return RespUtils.createResponse(RespStatus.ErrWithServer, e.getMessage());\n    }\n}", "class_id": 0, "repo": "jeasonyoung/springboot2-young-zen", "file": "young-common/src/main/java/org/young/common/exception/ExceptionHandlerAdvice.java", "last_update_at": "2019-03-15T11:37:24+00:00", "question_id": "e10f99dd7a854d5cc38842e20d28c67e1816a35d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Slf4j\npublic class ExceptionHandlerAdvice {\n    /**\n     * \u5f02\u5e38\u5904\u7406\u3002\n     * @param e\n     * \u5f02\u5e38\u3002\n     * @return \u8fd4\u56de\u3002\n     */\n    @ExceptionHandler(value = { Exception.class })\n    @ResponseBody\n    public Response<Serializable> handlerException(final Exception e) {\n        log.warn(\"handlerException-exp: \" + e);\n        if(e instanceof AuthenException){\n            //\u89e3\u6790\u9519\u8bef\u4ee3\u7801\n            final RespStatus respStatus = RespStatus.parse(((AuthenException)e).getCode());\n            if(respStatus != null){\n                //\u521b\u5efa\u54cd\u5e94\u62a5\u6587\n                return RespUtils.createResponse(respStatus);\n            }\n        }\n        return RespUtils.createResponse(RespStatus.ErrWithServer, e.getMessage());\n    }\n"]]}
{"hexsha": "24e91e53b67578b1d1aacc2692fe7f6579bc9237", "ext": "java", "lang": "Java", "content": "public class FeaturePosting implements IFeaturePosting {\n\tprotected String postingFileName;\n\tprotected RandomAccessFile postingFile;\n\n\tpublic FeaturePosting(String postingFileName) {\n\t\tthis.postingFileName = postingFileName;\n\t\tif (postingFileName != null)\n\t\t\ttry {\n\t\t\t\tthis.postingFile = new RandomAccessFile(this.postingFileName,\n\t\t\t\t\t\t\"r\");\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t}\n\n\tpublic RandomAccessFile getPostingFile() {\n\t\treturn this.postingFile;\n\t}\n\n\tpublic String getPostingFileName() {\n\t\treturn this.postingFileName;\n\t}\n\n\t@Override\n\tpublic int[] getPosting(long postingShift) {\n\t\tString results = null;\n\t\tString[] tokens;\n\t\tif (this.postingFile == null)\n\t\t\ttry {\n\t\t\t\tthis.postingFile = new RandomAccessFile(this.postingFileName,\n\t\t\t\t\t\t\"r\");\n\t\t\t} catch (FileNotFoundException e1) {\n\t\t\t\te1.printStackTrace();\n\t\t\t}\n\t\ttry {\n\t\t\tthis.postingFile.seek(postingShift);\n\t\t\tresults = this.postingFile.readLine();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t\ttokens = results.split(\",\");\n\t\tint[] posting = new int[tokens.length - 1];\n\t\tfor (int i = 0; i < tokens.length - 1; i++)\n\t\t\tposting[i] = Integer.parseInt(tokens[i + 1]);\n\t\treturn posting;\n\t}\n\n\tprotected String getPostingString(long postingShift) {\n\t\tString results = null;\n\t\tif (this.postingFile == null)\n\t\t\ttry {\n\t\t\t\tthis.postingFile = new RandomAccessFile(this.postingFileName,\n\t\t\t\t\t\t\"r\");\n\t\t\t} catch (FileNotFoundException e1) {\n\t\t\t\te1.printStackTrace();\n\t\t\t}\n\t\ttry {\n\t\t\tthis.postingFile.seek(postingShift);\n\t\t\tresults = this.postingFile.readLine();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t\treturn results;\n\t}\n\n\t/**\n\t * Read the postings starting from the \"featureShift\", rewrite it to the\n\t * postingChannel and return the new shift.\n\t * \n\t * @param postingChannel\n\t * @param featureShift\n\t * @param featureID\n\t * @return\n\t */\n\tpublic long savePostings(FileChannel postingChannel, long featureShift,\n\t\t\tint featureID) {\n\t\tByteBuffer postbbuf = ByteBuffer.allocate(1024);\n\t\tlong shift = -1;\n\t\ttry {\n\t\t\tshift = postingChannel.position();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tString postingString = this.getPostingString(featureShift);\n\t\tbyte[] bytes = null;\n\t\t// Change ID if necessary\n\t\tint index = postingString.indexOf(\",\");\n\t\tbytes = (featureID + postingString.substring(index) + '\\n').getBytes();\n\t\t// Starting writing the postings\n\t\tint start = 0;\n\t\tint length = postbbuf.capacity();\n\t\twhile (start < bytes.length) {\n\t\t\tif (start + length <= bytes.length)\n\t\t\t\tpostbbuf.put(bytes, start, length);\n\t\t\telse\n\t\t\t\tpostbbuf.put(bytes, start, bytes.length - start);\n\t\t\tpostbbuf.flip();\n\t\t\ttry {\n\t\t\t\tpostingChannel.write(postbbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tpostbbuf.clear();\n\t\t\tstart = start + length;\n\t\t}\n\t\treturn shift;\n\t}\n\t\n\t/**\n\t * Write the postings to the ostingChannel and return the new shift.\n\t * \n\t * @param postingChannel\n\t * @param featureShift\n\t * @param featureID\n\t * @return\n\t */\n\tpublic static long savePostings(FileChannel postingChannel, int[] postings,\n\t\t\tint featureID) throws IOException {\n\t\tArrays.sort(postings);\n\t\tStringBuffer postingBuffer = new StringBuffer(200);\n\t\tByteBuffer bbuf = ByteBuffer.allocate(1024);\n\t\tpostingBuffer.append(featureID);\n\n\t\tfor (int i = 0; i < postings.length; i++) {\n\t\t\tpostingBuffer.append(',');\n\t\t\tpostingBuffer.append(postings[i]);\n\t\t}\n\t\tpostingBuffer.append('\\n');\n\t\tbyte[] bytes = postingBuffer.toString().getBytes();\n\t\tlong shift = postingChannel.position();\n\t\tint start = 0;\n\t\tint length = bbuf.capacity();\n\t\twhile (start < bytes.length) {\n\t\t\tif (start + length <= bytes.length)\n\t\t\t\tbbuf.put(bytes, start, length);\n\t\t\telse\n\t\t\t\tbbuf.put(bytes, start, bytes.length - start);\n\t\t\tbbuf.flip();\n\t\t\tpostingChannel.write(bbuf);\n\t\t\tbbuf.clear();\n\t\t\tstart = start + length;\n\t\t}\n\t\treturn shift;\n\t}\n}", "class_id": 0, "repo": "Santa827/Lindex", "file": "src/edu/psu/chemxseer/structure/subsearch/Impl/indexfeature/FeaturePosting.java", "last_update_at": "2019-02-01T08:32:05+00:00", "question_id": "24e91e53b67578b1d1aacc2692fe7f6579bc9237", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FeaturePosting implements IFeaturePosting {\n\tprotected String postingFileName;\n\tprotected RandomAccessFile postingFile;\n\tpublic FeaturePosting(String postingFileName) {\n\t\tthis.postingFileName = postingFileName;\n\t\tif (postingFileName != null)\n\t\t\ttry {\n\t\t\t\tthis.postingFile = new RandomAccessFile(this.postingFileName,\n\t\t\t\t\t\t\"r\");\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t}\n\tpublic RandomAccessFile getPostingFile() {\n\t\treturn this.postingFile;\n\t}\n\tpublic String getPostingFileName() {\n\t\treturn this.postingFileName;\n\t}\n\t@Override\n\tpublic int[] getPosting(long postingShift) {\n\t\tString results = null;\n\t\tString[] tokens;\n\t\tif (this.postingFile == null)\n\t\t\ttry {\n\t\t\t\tthis.postingFile = new RandomAccessFile(this.postingFileName,\n\t\t\t\t\t\t\"r\");\n\t\t\t} catch (FileNotFoundException e1) {\n\t\t\t\te1.printStackTrace();\n\t\t\t}\n\t\ttry {\n\t\t\tthis.postingFile.seek(postingShift);\n\t\t\tresults = this.postingFile.readLine();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t\ttokens = results.split(\",\");\n\t\tint[] posting = new int[tokens.length - 1];\n\t\tfor (int i = 0; i < tokens.length - 1; i++)\n\t\t\tposting[i] = Integer.parseInt(tokens[i + 1]);\n\t\treturn posting;\n\t}\n\tprotected String getPostingString(long postingShift) {\n\t\tString results = null;\n\t\tif (this.postingFile == null)\n\t\t\ttry {\n\t\t\t\tthis.postingFile = new RandomAccessFile(this.postingFileName,\n\t\t\t\t\t\t\"r\");\n\t\t\t} catch (FileNotFoundException e1) {\n\t\t\t\te1.printStackTrace();\n\t\t\t}\n\t\ttry {\n\t\t\tthis.postingFile.seek(postingShift);\n\t\t\tresults = this.postingFile.readLine();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t\treturn results;\n\t}\n\t/**\n\t * Read the postings starting from the \"featureShift\", rewrite it to the\n\t * postingChannel and return the new shift.\n\t * \n\t * @param postingChannel\n\t * @param featureShift\n\t * @param featureID\n\t * @return\n\t */\n\tpublic long savePostings(FileChannel postingChannel, long featureShift,\n\t\t\tint featureID) {\n\t\tByteBuffer postbbuf = ByteBuffer.allocate(1024);\n\t\tlong shift = -1;\n\t\ttry {\n\t\t\tshift = postingChannel.position();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tString postingString = this.getPostingString(featureShift);\n\t\tbyte[] bytes = null;\n\t\t// Change ID if necessary\n\t\tint index = postingString.indexOf(\",\");\n\t\tbytes = (featureID + postingString.substring(index) + '\\n').getBytes();\n\t\t// Starting writing the postings\n\t\tint start = 0;\n\t\tint length = postbbuf.capacity();\n\t\twhile (start < bytes.length) {\n\t\t\tif (start + length <= bytes.length)\n\t\t\t\tpostbbuf.put(bytes, start, length);\n\t\t\telse\n\t\t\t\tpostbbuf.put(bytes, start, bytes.length - start);\n\t\t\tpostbbuf.flip();\n\t\t\ttry {\n\t\t\t\tpostingChannel.write(postbbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tpostbbuf.clear();\n\t\t\tstart = start + length;\n\t\t}\n\t\treturn shift;\n\t}\n\t\n\t/**\n\t * Write the postings to the ostingChannel and return the new shift.\n\t * \n\t * @param postingChannel\n\t * @param featureShift\n\t * @param featureID\n\t * @return\n\t */\n\tpublic static long savePostings(FileChannel postingChannel, int[] postings,\n\t\t\tint featureID) throws IOException {\n\t\tArrays.sort(postings);\n\t\tStringBuffer postingBuffer = new StringBuffer(200);\n\t\tByteBuffer bbuf = ByteBuffer.allocate(1024);\n\t\tpostingBuffer.append(featureID);\n\t\tfor (int i = 0; i < postings.length; i++) {\n\t\t\tpostingBuffer.append(',');\n\t\t\tpostingBuffer.append(postings[i]);\n\t\t}\n\t\tpostingBuffer.append('\\n');\n\t\tbyte[] bytes = postingBuffer.toString().getBytes();\n\t\tlong shift = postingChannel.position();\n\t\tint start = 0;\n\t\tint length = bbuf.capacity();\n\t\twhile (start < bytes.length) {\n\t\t\tif (start + length <= bytes.length)\n\t\t\t\tbbuf.put(bytes, start, length);\n\t\t\telse\n\t\t\t\tbbuf.put(bytes, start, bytes.length - start);\n\t\t\tbbuf.flip();\n\t\t\tpostingChannel.write(bbuf);\n\t\t\tbbuf.clear();\n\t\t\tstart = start + length;\n\t\t}\n\t\treturn shift;\n\t}\n"]]}
{"hexsha": "002aa70c49ade1a72d2db048be8138088d0030bd", "ext": "java", "lang": "Java", "content": "public class CliSequenceTestCase {\n\n    private static final String CLI_TEST_SEQUENCE = \"CliTestSequence\";\n    private static final String CLI_SAMPLE_SEQUENCE = \"CliSampleSequence\";\n\n    /**\n     * Get information about all Sequence\n     */\n    @Test\n    public void miShowSequenceAllTest() throws IOException {\n\n        List<String> outputForCLICommand = TestUtils.getOutputForCLICommand(Constants.SEQUENCE, Constants.SHOW);\n        String artifactName_seq_1[] = TestUtils.getArtifactList(outputForCLICommand).get(0).split(\" \", 2);\n        String artifactName_seq_2[] = TestUtils.getArtifactList(outputForCLICommand).get(1).split(\" \", 2);\n\n        Assert.assertEquals(artifactName_seq_1[0], CLI_TEST_SEQUENCE);\n        Assert.assertEquals(artifactName_seq_2[0], CLI_SAMPLE_SEQUENCE);\n    }\n\n    /**\n     * Get information about single Sequence\n     */\n    @Test\n    public void miShowSequenceTest() throws IOException {\n\n        List<String> outputForCLICommand = TestUtils.getOutputForCLICommandArtifactName(Constants.SEQUENCE, Constants.SHOW, CLI_TEST_SEQUENCE);\n        Assert.assertEquals(outputForCLICommand.get(0), \"Name - CliTestSequence\");\n    }\n\n    /**\n     * Test un-deployed Sequence\n     */\n    @Test\n    public void miShowSequenceNotFoundTest() throws IOException {\n\n        List<String> outputForCLICommand = TestUtils.getOutputForCLICommandArtifactName(Constants.SEQUENCE, Constants.SHOW, \"CLITestSequence\");\n        Assert.assertEquals(outputForCLICommand.get(0), \"[ERROR] Getting Information of the Sequence 404 Not Found\");\n    }\n}", "class_id": 0, "repo": "RidmiR/micro-integrator", "file": "integration/cli-tests/src/test/java/org/wso2/micro/integrator/cli/CliSequenceTestCase.java", "last_update_at": "2019-09-24T08:36:16+00:00", "question_id": "002aa70c49ade1a72d2db048be8138088d0030bd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CliSequenceTestCase {\n    private static final String CLI_TEST_SEQUENCE = \"CliTestSequence\";\n    private static final String CLI_SAMPLE_SEQUENCE = \"CliSampleSequence\";\n    /**\n     * Get information about all Sequence\n     */\n    @Test\n    public void miShowSequenceAllTest() throws IOException {\n        List<String> outputForCLICommand = TestUtils.getOutputForCLICommand(Constants.SEQUENCE, Constants.SHOW);\n        String artifactName_seq_1[] = TestUtils.getArtifactList(outputForCLICommand).get(0).split(\" \", 2);\n        String artifactName_seq_2[] = TestUtils.getArtifactList(outputForCLICommand).get(1).split(\" \", 2);\n        Assert.assertEquals(artifactName_seq_1[0], CLI_TEST_SEQUENCE);\n        Assert.assertEquals(artifactName_seq_2[0], CLI_SAMPLE_SEQUENCE);\n    }\n    /**\n     * Get information about single Sequence\n     */\n    @Test\n    public void miShowSequenceTest() throws IOException {\n        List<String> outputForCLICommand = TestUtils.getOutputForCLICommandArtifactName(Constants.SEQUENCE, Constants.SHOW, CLI_TEST_SEQUENCE);\n        Assert.assertEquals(outputForCLICommand.get(0), \"Name - CliTestSequence\");\n    }\n    /**\n     * Test un-deployed Sequence\n     */\n    @Test\n    public void miShowSequenceNotFoundTest() throws IOException {\n        List<String> outputForCLICommand = TestUtils.getOutputForCLICommandArtifactName(Constants.SEQUENCE, Constants.SHOW, \"CLITestSequence\");\n        Assert.assertEquals(outputForCLICommand.get(0), \"[ERROR] Getting Information of the Sequence 404 Not Found\");\n    }\n"]]}
{"hexsha": "09dac61e444c3c583568113dc31ee8ec23bc8182", "ext": "java", "lang": "Java", "content": "@RunWith(SpringRunner.class)\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\npublic class GraphQLQueryIntegrationTest {\n\n  @Autowired\n  GraphQLSchema schema;\n\n  @Autowired\n  private TestRestTemplate restTemplate;\n\n  @Before\n  public void verifySchema() {\n    assertNotNull(schema);\n  }\n\n  @Test\n  public void shouldReturnBadRequest() {\n    ResponseEntity<String> response = restTemplate.postForEntity(\"/graphql\", \"{}\", String.class);\n    String message = response.getBody();\n    assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());\n  }\n\n\n  @Test\n  public void shouldReturnUserList() {\n    String request = \"{\\n\" +\n      \"\\t\\\"query\\\": \\\"{users{id}}\\\"\\n\" +\n      \"}\";\n    ResponseEntity<String> response = restTemplate.postForEntity(\"/graphql\", request, String.class);\n    String message = response.getBody();\n    assertEquals(HttpStatus.OK, response.getStatusCode());\n  }\n\n\n  @Test\n  public void shouldAddNewUserSuccessfully() {\n    String request = \"{\\n\" +\n      \"\\\"query\\\":\\\"mutation {user(name:\\\\\\\"dkf\\\\\\\", email:\\\\\\\"dkf@asd.com\\\\\\\"){id name}}\\\",\" +\n      \"\\\"variables\\\":null\" +\n      \"}\";\n    ResponseEntity<String> response = restTemplate.postForEntity(\"/graphql\", request, String.class);\n    String message = response.getBody();\n    assertEquals(HttpStatus.OK, response.getStatusCode());\n    assertThat(\"Response should contain name\", message, CoreMatchers.containsString(\"\\\"name\\\":\\\"dkf\\\"\"));\n  }\n\n  @Test\n  public void shouldExecuteProperly() {\n    ExecutionInput executionInput = ExecutionInput.newExecutionInput().query(\"query { user(id:1) { id name } }\")\n      .build();\n\n\n    GraphQL graphQL = GraphQL.newGraphQL(schema).build();\n\n    ExecutionResult executionResult = graphQL.execute(executionInput);\n\n\n    User user = JacksonHelper.deserialize(JacksonHelper.serialize(executionResult.getData()), UserDTO.class).getUser();\n    List<GraphQLError> errors = executionResult.getErrors();\n\n    Assert.assertEquals(\"No error\", 0, errors.size());\n    Assert.assertNotNull(user);\n    Assert.assertEquals(\"ID\", 1, user.getId());\n\n\n  }\n\n\n}", "class_id": 0, "repo": "kdeng/java-demos", "file": "spring-demos/spring-mvc-graphql/src/test/java/nz/net/osnz/demos/graphql/GraphQLQueryIntegrationTest.java", "last_update_at": "2019-10-13T08:03:58+00:00", "question_id": "09dac61e444c3c583568113dc31ee8ec23bc8182", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(SpringRunner.class)\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\npublic class GraphQLQueryIntegrationTest {\n  @Autowired\n  GraphQLSchema schema;\n  @Autowired\n  private TestRestTemplate restTemplate;\n  @Before\n  public void verifySchema() {\n    assertNotNull(schema);\n  }\n  @Test\n  public void shouldReturnBadRequest() {\n    ResponseEntity<String> response = restTemplate.postForEntity(\"/graphql\", \"{}\", String.class);\n    String message = response.getBody();\n    assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());\n  }\n  @Test\n  public void shouldReturnUserList() {\n    String request = \"{\\n\" +\n      \"\\t\\\"query\\\": \\\"{users{id}}\\\"\\n\" +\n      \"}\";\n    ResponseEntity<String> response = restTemplate.postForEntity(\"/graphql\", request, String.class);\n    String message = response.getBody();\n    assertEquals(HttpStatus.OK, response.getStatusCode());\n  }\n  @Test\n  public void shouldAddNewUserSuccessfully() {\n    String request = \"{\\n\" +\n      \"\\\"query\\\":\\\"mutation {user(name:\\\\\\\"dkf\\\\\\\", email:\\\\\\\"dkf@asd.com\\\\\\\"){id name}}\\\",\" +\n      \"\\\"variables\\\":null\" +\n      \"}\";\n    ResponseEntity<String> response = restTemplate.postForEntity(\"/graphql\", request, String.class);\n    String message = response.getBody();\n    assertEquals(HttpStatus.OK, response.getStatusCode());\n    assertThat(\"Response should contain name\", message, CoreMatchers.containsString(\"\\\"name\\\":\\\"dkf\\\"\"));\n  }\n  @Test\n  public void shouldExecuteProperly() {\n    ExecutionInput executionInput = ExecutionInput.newExecutionInput().query(\"query { user(id:1) { id name } }\")\n      .build();\n    GraphQL graphQL = GraphQL.newGraphQL(schema).build();\n    ExecutionResult executionResult = graphQL.execute(executionInput);\n    User user = JacksonHelper.deserialize(JacksonHelper.serialize(executionResult.getData()), UserDTO.class).getUser();\n    List<GraphQLError> errors = executionResult.getErrors();\n    Assert.assertEquals(\"No error\", 0, errors.size());\n    Assert.assertNotNull(user);\n    Assert.assertEquals(\"ID\", 1, user.getId());\n  }\n"]]}
{"hexsha": "dd79ba918bd95fd7b3d536951ff08258324f179a", "ext": "java", "lang": "Java", "content": "public class JamaItemTypeTest extends TestCase {\n\n    public void testItemType() throws RestClientException {\n        JamaConfig jamaConfig = new JamaConfig();\n        jamaConfig.setBaseUrl(\"test\");\n        jamaConfig.setHttpClient(new TestHttpClient());\n        jamaConfig.setPassword(\"\");\n        jamaConfig.setUsername(\"\");\n        jamaConfig.setResourceTimeOut(1);\n\n        JamaInstance jamaInstance = new JamaInstance(jamaConfig);\n        JamaItemType jamaItemType= jamaInstance.getItemType(89011);\n\n        assertEquals(89011, jamaItemType.getId().intValue());\n        assertEquals(\"TC\", jamaItemType.getTypeKey().toString());\n        assertEquals(\"Test Case\", jamaItemType.getDisplay().toString());\n        assertEquals(\"Test Cases\", jamaItemType.getDisplayPlural().toString());\n        assertEquals(JamaItemType.class, jamaItemType.getClass());\n        //TODO: need to getImage and check it is of type ItemTypeImage\n        assertEquals(ArrayList.class, jamaItemType.getFields().getClass());\n        try {\n            refresh(jamaItemType);\n            fields(jamaItemType);\n        } catch (Exception e) {\n            throw new RestClientException(e);\n        }\n        System.out.println(\"Done\");\n    }\n\n    public void refresh(JamaItemType jamaItemType) throws Exception {\n\n        Field field = JamaItemType.class.getDeclaredField(\"display\");\n        field.setAccessible(true);\n        String oldName = \"oldName\";\n        field.set(jamaItemType, oldName);\n        assertEquals(\"oldName\", field.get(jamaItemType));\n        TimeUnit.SECONDS.sleep(1);\n        assertEquals(\"Test Case\", jamaItemType.getDisplay());\n    }\n\n    public void checkField(Class clazz, JamaField fieldValue) {\n        assertTrue(clazz.isInstance(fieldValue));\n    }\n\n    public void fields(JamaItemType jamaItemType) throws Exception, RestClientException {\n        checkField(RichTextField.class, jamaItemType.getField(\"description\"));\n        checkField(TextField.class, jamaItemType.getField(\"name\"));\n        checkField(TestCaseStatusField.class, jamaItemType.getField(\"testCaseStatus\"));\n        checkField(TestCaseStepsField.class, jamaItemType.getField(\"testCaseSteps\"));\n        checkField(UserField.class, jamaItemType.getField(\"assignedTo\"));\n        checkField(PickListField.class, jamaItemType.getField(\"priority\"));\n        checkField(IntegerField.class, jamaItemType.getField(\"custom_number\"));\n    }\n}", "class_id": 0, "repo": "jmauersberger/RestClient", "file": "test/restclient/jamadomain/lazyresources/JamaItemTypeTest.java", "last_update_at": "2019-12-23T12:02:10+00:00", "question_id": "dd79ba918bd95fd7b3d536951ff08258324f179a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class JamaItemTypeTest extends TestCase {\n    public void testItemType() throws RestClientException {\n        JamaConfig jamaConfig = new JamaConfig();\n        jamaConfig.setBaseUrl(\"test\");\n        jamaConfig.setHttpClient(new TestHttpClient());\n        jamaConfig.setPassword(\"\");\n        jamaConfig.setUsername(\"\");\n        jamaConfig.setResourceTimeOut(1);\n        JamaInstance jamaInstance = new JamaInstance(jamaConfig);\n        JamaItemType jamaItemType= jamaInstance.getItemType(89011);\n        assertEquals(89011, jamaItemType.getId().intValue());\n        assertEquals(\"TC\", jamaItemType.getTypeKey().toString());\n        assertEquals(\"Test Case\", jamaItemType.getDisplay().toString());\n        assertEquals(\"Test Cases\", jamaItemType.getDisplayPlural().toString());\n        assertEquals(JamaItemType.class, jamaItemType.getClass());\n        //TODO: need to getImage and check it is of type ItemTypeImage\n        assertEquals(ArrayList.class, jamaItemType.getFields().getClass());\n        try {\n            refresh(jamaItemType);\n            fields(jamaItemType);\n        } catch (Exception e) {\n            throw new RestClientException(e);\n        }\n        System.out.println(\"Done\");\n    }\n    public void refresh(JamaItemType jamaItemType) throws Exception {\n        Field field = JamaItemType.class.getDeclaredField(\"display\");\n        field.setAccessible(true);\n        String oldName = \"oldName\";\n        field.set(jamaItemType, oldName);\n        assertEquals(\"oldName\", field.get(jamaItemType));\n        TimeUnit.SECONDS.sleep(1);\n        assertEquals(\"Test Case\", jamaItemType.getDisplay());\n    }\n    public void checkField(Class clazz, JamaField fieldValue) {\n        assertTrue(clazz.isInstance(fieldValue));\n    }\n    public void fields(JamaItemType jamaItemType) throws Exception, RestClientException {\n        checkField(RichTextField.class, jamaItemType.getField(\"description\"));\n        checkField(TextField.class, jamaItemType.getField(\"name\"));\n        checkField(TestCaseStatusField.class, jamaItemType.getField(\"testCaseStatus\"));\n        checkField(TestCaseStepsField.class, jamaItemType.getField(\"testCaseSteps\"));\n        checkField(UserField.class, jamaItemType.getField(\"assignedTo\"));\n        checkField(PickListField.class, jamaItemType.getField(\"priority\"));\n        checkField(IntegerField.class, jamaItemType.getField(\"custom_number\"));\n    }\n"]]}
{"hexsha": "7c784517813a66674a232b5af31005ba39c17414", "ext": "java", "lang": "Java", "content": "public class FlavorRulesShowPageSteps extends RulesShowPageGenericSteps<FlavorRulesShowPageSteps> {\n\n    RulesShowPageObjects rulesShowPageObjects;\n    FlavorRulesShowPage rulesShowPage;\n    FlavorRulesTemplatesShowPage rulesTemplatesShowPage;\n\n    @Step\n    public FlavorRulesShowPageSteps openRulesPage() {\n        rulesShowPage.open();\n        rulesShowPage.waitFor(500).milliseconds();\n\n        return getThis();\n    }\n\n    @Step\n    public FlavorRulesShowPageSteps openTemplatesPage() {\n        rulesTemplatesShowPage.open();\n\n        return getThis();\n    }\n\n    @Step\n    public FlavorRulesShowPageSteps verifyPermanentRuleExists(String ruleName, String flavor, String queryPairs) {\n        Assert.assertTrue(rulesShowPage.isRuleReturningFlavor(ruleName, flavor));\n        Assert.assertTrue(rulesShowPage.isRuleReturningQueryPairs(ruleName, queryPairs));\n\n        return getThis();\n    }\n\n    @Step\n    public FlavorRulesShowPageSteps verifyPendingAddedRuleIsShown(String ruleName, String flavor, String queryPairs) {\n        Assert.assertTrue(rulesShowPageObjects.isRulePresent(ruleName));\n        Assert.assertTrue(rulesShowPage.isRuleReturningFlavor(ruleName, flavor));\n        Assert.assertTrue(rulesShowPage.isRuleReturningQueryPairs(ruleName, queryPairs));\n        Assert.assertTrue(\"Rule Preview should have 'PENDING ADD' look and feel\", rulesShowPageObjects.isRulePendingForAddition(ruleName));\n\n        return getThis();\n    }\n\n    @Step\n    public FlavorRulesShowPageSteps verifyPendingAddedRuleAdvancedServerIsShown(String ruleName, String serverPath) {\n        rulesShowPage.waitFor(1).second();\n        Assert.assertTrue(rulesShowPageObjects.isRulePresent(ruleName));\n        Assert.assertTrue(rulesShowPage.isRuleReturningServerPath(ruleName, serverPath));\n        Assert.assertTrue(\"Rule Preview should have 'PENDING ADD' look and feel\", rulesShowPageObjects.isRulePendingForAddition(ruleName));\n        return getThis();\n    }\n\n    @Step\n    public FlavorRulesShowPageSteps verifyPendingAddedRuleAdvancedServerContainsQueryPairsIsShown(String ruleName, String queryPairs) {\n        Assert.assertTrue(rulesShowPage.isRuleReturningQueryPairs(ruleName, queryPairs));\n        return getThis();\n    }\n\n    @Override\n    public FlavorRulesShowPageSteps getThis() {\n        return this;\n    }\n}", "class_id": 0, "repo": "deebugger/redirector", "file": "testing/ux-automation/src/test/java/com/comcast/redirector/thucydides/steps/rules/flavor/FlavorRulesShowPageSteps.java", "last_update_at": "2019-05-16T06:43:51+00:00", "question_id": "7c784517813a66674a232b5af31005ba39c17414", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FlavorRulesShowPageSteps extends RulesShowPageGenericSteps<FlavorRulesShowPageSteps> {\n    RulesShowPageObjects rulesShowPageObjects;\n    FlavorRulesShowPage rulesShowPage;\n    FlavorRulesTemplatesShowPage rulesTemplatesShowPage;\n    @Step\n    public FlavorRulesShowPageSteps openRulesPage() {\n        rulesShowPage.open();\n        rulesShowPage.waitFor(500).milliseconds();\n        return getThis();\n    }\n    @Step\n    public FlavorRulesShowPageSteps openTemplatesPage() {\n        rulesTemplatesShowPage.open();\n        return getThis();\n    }\n    @Step\n    public FlavorRulesShowPageSteps verifyPermanentRuleExists(String ruleName, String flavor, String queryPairs) {\n        Assert.assertTrue(rulesShowPage.isRuleReturningFlavor(ruleName, flavor));\n        Assert.assertTrue(rulesShowPage.isRuleReturningQueryPairs(ruleName, queryPairs));\n        return getThis();\n    }\n    @Step\n    public FlavorRulesShowPageSteps verifyPendingAddedRuleIsShown(String ruleName, String flavor, String queryPairs) {\n        Assert.assertTrue(rulesShowPageObjects.isRulePresent(ruleName));\n        Assert.assertTrue(rulesShowPage.isRuleReturningFlavor(ruleName, flavor));\n        Assert.assertTrue(rulesShowPage.isRuleReturningQueryPairs(ruleName, queryPairs));\n        Assert.assertTrue(\"Rule Preview should have 'PENDING ADD' look and feel\", rulesShowPageObjects.isRulePendingForAddition(ruleName));\n        return getThis();\n    }\n    @Step\n    public FlavorRulesShowPageSteps verifyPendingAddedRuleAdvancedServerIsShown(String ruleName, String serverPath) {\n        rulesShowPage.waitFor(1).second();\n        Assert.assertTrue(rulesShowPageObjects.isRulePresent(ruleName));\n        Assert.assertTrue(rulesShowPage.isRuleReturningServerPath(ruleName, serverPath));\n        Assert.assertTrue(\"Rule Preview should have 'PENDING ADD' look and feel\", rulesShowPageObjects.isRulePendingForAddition(ruleName));\n        return getThis();\n    }\n    @Step\n    public FlavorRulesShowPageSteps verifyPendingAddedRuleAdvancedServerContainsQueryPairsIsShown(String ruleName, String queryPairs) {\n        Assert.assertTrue(rulesShowPage.isRuleReturningQueryPairs(ruleName, queryPairs));\n        return getThis();\n    }\n    @Override\n    public FlavorRulesShowPageSteps getThis() {\n        return this;\n    }\n"]]}
{"hexsha": "4bc1396e911ee7edf5f6bfb4bc60babb60fcd53d", "ext": "java", "lang": "Java", "content": "public class SingletonTest {\n\n    @Test\n    public void testIODH() {\n        IDGenerator generator1 = IDGenerator.get();\n        IDGenerator generator2 = IDGenerator.get();\n        assertThat(generator1).isSameAs(generator2);\n    }\n}", "class_id": 0, "repo": "HasonHuang/java-design-patterns", "file": "singleton-pattern/src/test/java/com/hason/patterns/singleton/SingletonTest.java", "last_update_at": "2019-10-16T07:14:33+00:00", "question_id": "4bc1396e911ee7edf5f6bfb4bc60babb60fcd53d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SingletonTest {\n    @Test\n    public void testIODH() {\n        IDGenerator generator1 = IDGenerator.get();\n        IDGenerator generator2 = IDGenerator.get();\n        assertThat(generator1).isSameAs(generator2);\n    }\n"]]}
{"hexsha": "81163eed525c75854386220fafe777f638bca3dd", "ext": "java", "lang": "Java", "content": "@javax.annotation.Generated(value = \"io.swagger.codegen.languages.JavaClientCodegen\", date = \"2018-04-19T15:41:52.549-07:00\")\npublic class StoragepoolStoragepools {\n  @SerializedName(\"storagepools\")\n  private List<StoragepoolStoragepool> storagepools = null;\n\n  @SerializedName(\"total\")\n  private Integer total = null;\n\n  public StoragepoolStoragepools storagepools(List<StoragepoolStoragepool> storagepools) {\n    this.storagepools = storagepools;\n    return this;\n  }\n\n  public StoragepoolStoragepools addStoragepoolsItem(StoragepoolStoragepool storagepoolsItem) {\n    if (this.storagepools == null) {\n      this.storagepools = new ArrayList<StoragepoolStoragepool>();\n    }\n    this.storagepools.add(storagepoolsItem);\n    return this;\n  }\n\n   /**\n   * Get storagepools\n   * @return storagepools\n  **/\n  @ApiModelProperty(value = \"\")\n  public List<StoragepoolStoragepool> getStoragepools() {\n    return storagepools;\n  }\n\n  public void setStoragepools(List<StoragepoolStoragepool> storagepools) {\n    this.storagepools = storagepools;\n  }\n\n  public StoragepoolStoragepools total(Integer total) {\n    this.total = total;\n    return this;\n  }\n\n   /**\n   * Total number of items available.\n   * minimum: 0\n   * maximum: 4294967295\n   * @return total\n  **/\n  @ApiModelProperty(value = \"Total number of items available.\")\n  public Integer getTotal() {\n    return total;\n  }\n\n  public void setTotal(Integer total) {\n    this.total = total;\n  }\n\n\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    StoragepoolStoragepools storagepoolStoragepools = (StoragepoolStoragepools) o;\n    return Objects.equals(this.storagepools, storagepoolStoragepools.storagepools) &&\n        Objects.equals(this.total, storagepoolStoragepools.total);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(storagepools, total);\n  }\n\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class StoragepoolStoragepools {\\n\");\n    \n    sb.append(\"    storagepools: \").append(toIndentedString(storagepools)).append(\"\\n\");\n    sb.append(\"    total: \").append(toIndentedString(total)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n\n}", "class_id": 0, "repo": "Atomicology/isilon_sdk_java", "file": "src/main/java/io/swagger/client/model/StoragepoolStoragepools.java", "last_update_at": "2019-11-07T17:38:23+00:00", "question_id": "81163eed525c75854386220fafe777f638bca3dd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@javax.annotation.Generated(value = \"io.swagger.codegen.languages.JavaClientCodegen\", date = \"2018-04-19T15:41:52.549-07:00\")\npublic class StoragepoolStoragepools {\n  @SerializedName(\"storagepools\")\n  private List<StoragepoolStoragepool> storagepools = null;\n  @SerializedName(\"total\")\n  private Integer total = null;\n  public StoragepoolStoragepools storagepools(List<StoragepoolStoragepool> storagepools) {\n    this.storagepools = storagepools;\n    return this;\n  }\n  public StoragepoolStoragepools addStoragepoolsItem(StoragepoolStoragepool storagepoolsItem) {\n    if (this.storagepools == null) {\n      this.storagepools = new ArrayList<StoragepoolStoragepool>();\n    }\n    this.storagepools.add(storagepoolsItem);\n    return this;\n  }\n   /**\n   * Get storagepools\n   * @return storagepools\n  **/\n  @ApiModelProperty(value = \"\")\n  public List<StoragepoolStoragepool> getStoragepools() {\n    return storagepools;\n  }\n  public void setStoragepools(List<StoragepoolStoragepool> storagepools) {\n    this.storagepools = storagepools;\n  }\n  public StoragepoolStoragepools total(Integer total) {\n    this.total = total;\n    return this;\n  }\n   /**\n   * Total number of items available.\n   * minimum: 0\n   * maximum: 4294967295\n   * @return total\n  **/\n  @ApiModelProperty(value = \"Total number of items available.\")\n  public Integer getTotal() {\n    return total;\n  }\n  public void setTotal(Integer total) {\n    this.total = total;\n  }\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    StoragepoolStoragepools storagepoolStoragepools = (StoragepoolStoragepools) o;\n    return Objects.equals(this.storagepools, storagepoolStoragepools.storagepools) &&\n        Objects.equals(this.total, storagepoolStoragepools.total);\n  }\n  @Override\n  public int hashCode() {\n    return Objects.hash(storagepools, total);\n  }\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class StoragepoolStoragepools {\\n\");\n    sb.append(\"    storagepools: \").append(toIndentedString(storagepools)).append(\"\\n\");\n    sb.append(\"    total: \").append(toIndentedString(total)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n"]]}
{"hexsha": "f922034e9a3512e65dd726851557ecfc328b7d36", "ext": "java", "lang": "Java", "content": "@SuppressWarnings(\"serial\")\r\npublic class AdminSession extends AuthenticatedWebSession\r\n{\r\n\tprivate String userid = null;\r\n\r\n\tpublic AdminSession(Request request)\r\n\t\t{\r\n\t\tsuper(request);\r\n\t\tsetLocale(Locale.ENGLISH);\r\n\t\tAdminApplication.getLogging().logDebug(\" - internet session started with id XXXX\");\r\n\t\t}\r\n\r\n\tpublic AdminSession(Request request, Logging newlog)\r\n\t\t{\r\n\t\tsuper(request);\r\n\t\tsetLocale(Locale.ENGLISH);\r\n\t\tnewlog.logDebug(\" - internet session started with id XXXX\");\r\n\t\t}\r\n\r\n\tpublic static AdminSession get()\r\n\t\t{\r\n\t\treturn (AdminSession) Session.get();\r\n\t\t}\r\n\r\n\tpublic synchronized String getUser()\r\n\t\t{\r\n\t\treturn userid;\r\n\t\t}\r\n\r\n\tpublic synchronized boolean isAuthenticated()\r\n\t\t{\r\n\t\treturn (userid != null);\r\n\t\t}\r\n\r\n\tpublic synchronized void setUser(String user)\r\n\t\t{\r\n\t\tthis.userid = user;\r\n\t\tdirty();\r\n\t\t}\r\n\r\n\tpublic DataContext getDataContext()\r\n\t\t{\r\n\t\treturn (DataContext)BaseContext.getThreadObjectContext();\r\n\t\t}\r\n\r\n\tpublic Logging getLogging()\r\n\t\t{\r\n\t\treturn AdminApplication.getLogging();\r\n\t\t}\r\n\r\n\t/**\r\n\t * @see org.apache.wicket.authentication.AuthenticatedWebSession#authenticate(java.lang.String,\r\n\t *      java.lang.String)\r\n\t */\r\n\t@Override\r\n\tpublic boolean authenticate(final String username, final String password)\r\n\t{\r\n\t\tfinal String WICKET = \"wicket\";\r\n\r\n\t\t// Check username and password\r\n\t\treturn WICKET.equals(username) && WICKET.equals(password);\r\n\t}\r\n\r\n\t/**\r\n\t * @see org.apache.wicket.authroles.authentication.AbstractAuthenticatedWebSession#getRoles()\r\n\t */\r\n\t@Override\r\n\tpublic Roles getRoles()\r\n\t\t{\r\n\t\tif (isSignedIn())\r\n\t\t{\r\n\t\t\t// If the user is signed in, they have these roles\r\n\t\t\treturn new Roles(Roles.ADMIN);\r\n\t\t}\r\n\t\treturn null;\r\n\t\t}\r\n\r\n}", "class_id": 0, "repo": "yafraorg/yafra-java", "file": "org.yafra.server.jee/src/main/java/org/yafra/wicket/admin/AdminSession.java", "last_update_at": "2019-04-15T07:09:15+00:00", "question_id": "f922034e9a3512e65dd726851557ecfc328b7d36", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings(\"serial\")\r\npublic class AdminSession extends AuthenticatedWebSession\r\n{\r\n\tprivate String userid = null;\r\n\r\n\tpublic AdminSession(Request request)\r\n\t\t{\r\n\t\tsuper(request);\r\n\t\tsetLocale(Locale.ENGLISH);\r\n\t\tAdminApplication.getLogging().logDebug(\" - internet session started with id XXXX\");\r\n\t\t}\r\n\r\n\tpublic AdminSession(Request request, Logging newlog)\r\n\t\t{\r\n\t\tsuper(request);\r\n\t\tsetLocale(Locale.ENGLISH);\r\n\t\tnewlog.logDebug(\" - internet session started with id XXXX\");\r\n\t\t}\r\n\r\n\tpublic static AdminSession get()\r\n\t\t{\r\n\t\treturn (AdminSession) Session.get();\r\n\t\t}\r\n\r\n\tpublic synchronized String getUser()\r\n\t\t{\r\n\t\treturn userid;\r\n\t\t}\r\n\r\n\tpublic synchronized boolean isAuthenticated()\r\n\t\t{\r\n\t\treturn (userid != null);\r\n\t\t}\r\n\r\n\tpublic synchronized void setUser(String user)\r\n\t\t{\r\n\t\tthis.userid = user;\r\n\t\tdirty();\r\n\t\t}\r\n\r\n\tpublic DataContext getDataContext()\r\n\t\t{\r\n\t\treturn (DataContext)BaseContext.getThreadObjectContext();\r\n\t\t}\r\n\r\n\tpublic Logging getLogging()\r\n\t\t{\r\n\t\treturn AdminApplication.getLogging();\r\n\t\t}\r\n\r\n\t/**\r\n\t * @see org.apache.wicket.authentication.AuthenticatedWebSession#authenticate(java.lang.String,\r\n\t *      java.lang.String)\r\n\t */\r\n\t@Override\r\n\tpublic boolean authenticate(final String username, final String password)\r\n\t{\r\n\t\tfinal String WICKET = \"wicket\";\r\n\r\n\t\t// Check username and password\r\n\t\treturn WICKET.equals(username) && WICKET.equals(password);\r\n\t}\r\n\r\n\t/**\r\n\t * @see org.apache.wicket.authroles.authentication.AbstractAuthenticatedWebSession#getRoles()\r\n\t */\r\n\t@Override\r\n\tpublic Roles getRoles()\r\n\t\t{\r\n\t\tif (isSignedIn())\r\n\t\t{\r\n\t\t\t// If the user is signed in, they have these roles\r\n\t\t\treturn new Roles(Roles.ADMIN);\r\n\t\t}\r\n\t\treturn null;\r\n\t\t}\r\n\r\n"]]}
{"hexsha": "bcaf35a80255ec75d456fd6ed06a66960e264ed7", "ext": "java", "lang": "Java", "content": "public class GrpcConnector implements AutoCloseable{\n    private static Logger logger = LoggerFactory.getLogger(GrpcConnector.class);\n    private final LinkedList<String> addrs;\n    private final ConcurrentHashMap<String, ManagedChannel> channelMap;\n    private int robinIndex;\n    public GrpcConnector(){\n        addrs = new LinkedList<>();\n        channelMap = new ConcurrentHashMap<>();\n        robinIndex = 0;\n    }\n\n    public ManagedChannel getChannel(){\n        String address = getAddrs();\n        if(address == null){\n            logger.info(\"Get channel failed for addrs is empty\");\n            return null;\n        }\n\n        ManagedChannel channel = channelMap.get(address);\n        if(channel != null){\n            return channel;\n        }\n\n        return createChannel(address);\n    }\n\n    public int getAddrsCount(){\n        return addrs.size();\n    }\n\n    public void kickOutChannel(String serverName,String address){\n        logger.info(\"Kick out {} channel for:{}\", address, serverName);\n        synchronized (this){\n            ManagedChannel channel = channelMap.get(address);\n            if(channel != null){\n                channel.shutdown();\n            }\n            addrs.remove(address);\n        }\n    }\n\n    public void addAddress(List<String> addrList){\n        synchronized (this){\n            for(String str: addrList){\n                if(addrs.contains(str)){\n                    continue;\n                }\n                addrs.add(str);\n            }\n        }\n    }\n\n    public void addAddress(String addr){\n        synchronized (this){\n            if(!addrs.contains(addr)){\n                addrs.add(addr);\n            }\n        }\n    }\n\n    private ManagedChannel createChannel(String address){\n        synchronized (this){\n            ManagedChannel channel = channelMap.get(address);\n            if(channel != null){\n                return channel;\n            }\n            /***connect channel***/\n            logger.info(\"Use server:{}\", address);\n            String[] host = address.split(\":\");\n            channel = ManagedChannelBuilder.forAddress(host[0], Integer.valueOf(host[1])).usePlaintext().build();\n            channelMap.put(address, channel);\n            return channel;\n        }\n    }\n\n    private String getAddrs(){\n        synchronized (this){\n            if(addrs.isEmpty()){\n                return null;\n            }\n            int ridx = robinIndex % addrs.size();\n            robinIndex = (robinIndex + 1) % addrs.size();\n            return addrs.get(ridx);\n        }\n    }\n\n    @Override\n    public void close() throws Exception {\n        synchronized (this){\n            addrs.clear();\n            for(ManagedChannel channel:channelMap.values()){\n                channel.shutdown();\n            }\n\n            channelMap.clear();\n        }\n    }\n}", "class_id": 0, "repo": "ZhiYu2018/grpc", "file": "grpc-discover/src/main/java/com/gexiang/core/vo/GrpcConnector.java", "last_update_at": "2019-09-18T14:51:21+00:00", "question_id": "bcaf35a80255ec75d456fd6ed06a66960e264ed7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GrpcConnector implements AutoCloseable{\n    private static Logger logger = LoggerFactory.getLogger(GrpcConnector.class);\n    private final LinkedList<String> addrs;\n    private final ConcurrentHashMap<String, ManagedChannel> channelMap;\n    private int robinIndex;\n    public GrpcConnector(){\n        addrs = new LinkedList<>();\n        channelMap = new ConcurrentHashMap<>();\n        robinIndex = 0;\n    }\n    public ManagedChannel getChannel(){\n        String address = getAddrs();\n        if(address == null){\n            logger.info(\"Get channel failed for addrs is empty\");\n            return null;\n        }\n        ManagedChannel channel = channelMap.get(address);\n        if(channel != null){\n            return channel;\n        }\n        return createChannel(address);\n    }\n    public int getAddrsCount(){\n        return addrs.size();\n    }\n    public void kickOutChannel(String serverName,String address){\n        logger.info(\"Kick out {} channel for:{}\", address, serverName);\n        synchronized (this){\n            ManagedChannel channel = channelMap.get(address);\n            if(channel != null){\n                channel.shutdown();\n            }\n            addrs.remove(address);\n        }\n    }\n    public void addAddress(List<String> addrList){\n        synchronized (this){\n            for(String str: addrList){\n                if(addrs.contains(str)){\n                    continue;\n                }\n                addrs.add(str);\n            }\n        }\n    }\n    public void addAddress(String addr){\n        synchronized (this){\n            if(!addrs.contains(addr)){\n                addrs.add(addr);\n            }\n        }\n    }\n    private ManagedChannel createChannel(String address){\n        synchronized (this){\n            ManagedChannel channel = channelMap.get(address);\n            if(channel != null){\n                return channel;\n            }\n            /***connect channel***/\n            logger.info(\"Use server:{}\", address);\n            String[] host = address.split(\":\");\n            channel = ManagedChannelBuilder.forAddress(host[0], Integer.valueOf(host[1])).usePlaintext().build();\n            channelMap.put(address, channel);\n            return channel;\n        }\n    }\n    private String getAddrs(){\n        synchronized (this){\n            if(addrs.isEmpty()){\n                return null;\n            }\n            int ridx = robinIndex % addrs.size();\n            robinIndex = (robinIndex + 1) % addrs.size();\n            return addrs.get(ridx);\n        }\n    }\n    @Override\n    public void close() throws Exception {\n        synchronized (this){\n            addrs.clear();\n            for(ManagedChannel channel:channelMap.values()){\n                channel.shutdown();\n            }\n            channelMap.clear();\n        }\n    }\n"]]}
{"hexsha": "f8ab0d3f87d77ab850dbd24836df4671e9fb08a6", "ext": "java", "lang": "Java", "content": "public class ClasspathSetterHandler implements HttpHandler {\n    // TODO change me to an empty dir where the error output will be written\n    public static File outputCustomizeClasspathRootDir = new File(\"tmp\" + SLASH + \"output\" + SLASH + \"CustomizeClasspath\");\n    static final ObjectMapper objectMapper = new ObjectMapper();\n\n    @Override\n    public void handleRequest(HttpServerExchange httpServerExchange) throws Exception {\n        httpServerExchange.getResponseHeaders()\n                .put(new HttpString(\"Access-Control-Allow-Origin\"), \"*\");\n        String jsonString = getString(httpServerExchange.getInputStream());\n        byte[] jsonBytes = jsonString.getBytes(\"UTF-8\");\n        int jsonHash = Math.abs(jsonString.hashCode());\n        File customizeClasspath = new File(outputCustomizeClasspathRootDir.getPath(), jsonHash + \".json\");\n        customizeClasspath.getParentFile().mkdirs();\n        Files.write(customizeClasspath.toPath(), jsonBytes);\n        httpServerExchange.getResponseHeaders().add(Headers.CONTENT_TYPE, \"application/json\");\n        httpServerExchange.getResponseSender().send(\"{\\\"classpathHash\\\": \\\"\" + jsonHash + \"\\\"}\");\n    }\n\n    private String getString(InputStream is) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n        return br.lines().collect(Collectors.joining(System.lineSeparator()));\n    }\n}", "class_id": 0, "repo": "DnsZhou/online-Java-navigator", "file": "src/main/java/uk/ac/ncl/cs/tongzhou/navigator/webservice/ClasspathSetterHandler.java", "last_update_at": "2019-04-15T08:53:31+00:00", "question_id": "f8ab0d3f87d77ab850dbd24836df4671e9fb08a6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ClasspathSetterHandler implements HttpHandler {\n    // TODO change me to an empty dir where the error output will be written\n    public static File outputCustomizeClasspathRootDir = new File(\"tmp\" + SLASH + \"output\" + SLASH + \"CustomizeClasspath\");\n    static final ObjectMapper objectMapper = new ObjectMapper();\n    @Override\n    public void handleRequest(HttpServerExchange httpServerExchange) throws Exception {\n        httpServerExchange.getResponseHeaders()\n                .put(new HttpString(\"Access-Control-Allow-Origin\"), \"*\");\n        String jsonString = getString(httpServerExchange.getInputStream());\n        byte[] jsonBytes = jsonString.getBytes(\"UTF-8\");\n        int jsonHash = Math.abs(jsonString.hashCode());\n        File customizeClasspath = new File(outputCustomizeClasspathRootDir.getPath(), jsonHash + \".json\");\n        customizeClasspath.getParentFile().mkdirs();\n        Files.write(customizeClasspath.toPath(), jsonBytes);\n        httpServerExchange.getResponseHeaders().add(Headers.CONTENT_TYPE, \"application/json\");\n        httpServerExchange.getResponseSender().send(\"{\\\"classpathHash\\\": \\\"\" + jsonHash + \"\\\"}\");\n    }\n    private String getString(InputStream is) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n        return br.lines().collect(Collectors.joining(System.lineSeparator()));\n    }\n"]]}
{"hexsha": "b6f51f784d8ee5a13e1baa43195deea8a7e573b9", "ext": "java", "lang": "Java", "content": "public class Tree<T> extends AbstractTreeLikeStructure<T, Tree<T>> implements Serializable /* TODO:extends Iterable<T> */{\n\n\tprivate static final long serialVersionUID = -7482343083286183794L;\n\n\tprivate final Tree<T> parent;\n\tprivate final T value;\n\tprivate final List<Tree<T>> children;\n\n\t// -- constructors + factory methods\n\n\tpublic Tree(T value) {\n\t\tthis(null, value, List.of(), TreeTransformer::identity, TreeTransformer::identity);\n\t}\n\n\tpublic Tree(T value, Iterable<Tree<T>> children) {\n\t\tthis(null, value, children, TreeTransformer::identity, TreeTransformer::updateChildren);\n\t}\n\n\tpublic Tree(Tree<T> parent, T value) {\n\t\tthis(parent, value, List.of(), TreeTransformer::addThisToParent, TreeTransformer::identity);\n\t}\n\n\tpublic Tree(Tree<T> parent, T value, Iterable<Tree<T>> children) {\n\t\tthis(parent, value, children, TreeTransformer::addThisToParent, TreeTransformer::updateChildren);\n\t}\n\n\t// DEV-NOTE: beware of NPEs because this is leaving the constructor\n\tTree(Tree<T> parent, T value, Iterable<Tree<T>> children, TreeTransformer<T> updateParent,\n\t\t\tTreeTransformer<T> updateChildren) {\n\t\trequireNonNull(children, \"children is null\");\n\t\trequireNonNull(updateParent, \"updateParent is null\");\n\t\trequireNonNull(updateChildren, \"updateChildren is null\");\n\t\tthis.value = value;\n\t\tthis.children = List.of(children).replaceAll(updateChildren.apply(this));\n\t\tthis.parent = Option.of(parent).map(updateParent.apply(this)).orElse(null);\n\t}\n\n\t/**\n\t * Factory method for easy tree building.\n\t * <p>\n\t * <strong>Example:</strong>\n\t * <p>\n\t * {@code tree(\"A\", tree(\"B\"), tree(\"C\", tree(\"D\"), tree(\"E\", tree(\"F\", tree(\"G\")))))}\n\t * <p>\n\t * results in:\n\t * \n\t * <pre>\n\t * <code>\n\t *   A\n\t *  / \\\n\t * B   C\n\t *    / \\\n\t *   D   E\n\t *       |\n\t *       F\n\t *       |\n\t *       G\n\t * </code>\n\t * </pre>\n\t * \n\t * @param <T> value type of the result Tree\n\t * @param value The value of the Tree.\n\t * @param children The children of the Tree.\n\t * @return A new Tree instance based on the arguments.\n\t */\n\t@SafeVarargs\n\tpublic static <T> Tree<T> tree(T value, Tree<T>... children) {\n\t\tfinal List<Tree<T>> childList = List.of(children);\n\t\treturn new Tree<>(null, value, childList, TreeTransformer::identity, TreeTransformer::updateChildren);\n\t}\n\n\t// -- core\n\n\tpublic Option<Tree<T>> getParent() {\n\t\treturn Option.of(parent);\n\t}\n\n\tpublic Tree<T> setParent(Tree<T> parent) {\n\t\tif (Objects.equals(this.parent, parent)) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new Tree<>(parent, value, children, TreeTransformer::addThisToParent,\n\t\t\t\t\tTreeTransformer::updateChildren);\n\t\t}\n\t}\n\n\tpublic Tree<T> getRoot() {\n\t\tTree<T> tree = this;\n\t\twhile (tree.parent != null) {\n\t\t\ttree = tree.parent;\n\t\t}\n\t\treturn tree;\n\t}\n\n\tpublic boolean isRoot() {\n\t\treturn parent == null;\n\t}\n\n\t@Override\n\tpublic T getValue() {\n\t\treturn value;\n\t}\n\n\t@Override\n\tpublic Tree<T> setValue(T value) {\n\t\treturn new Tree<>(parent, value, children, TreeTransformer.updateParent(this), TreeTransformer::updateChildren);\n\t}\n\n\t@Override\n\tpublic List<Tree<T>> getChildren() {\n\t\treturn children;\n\t}\n\n\t@Override\n\tpublic Tree<T> setChildren(Iterable<Tree<T>> children) {\n\t\treturn new Tree<>(parent, value, children, TreeTransformer.updateParent(this), TreeTransformer::updateChildren);\n\t}\n\n\t// -- operations\n\n\t@Override\n\tpublic Tree<T> attach(Iterable<Tree<T>> trees) {\n\t\treturn new Tree<>(parent, value, List.of(trees).prependAll(children), TreeTransformer.updateParent(this),\n\t\t\t\tTreeTransformer::updateChildren);\n\t}\n\n\t@Override\n\tpublic Tree<T> detach(Iterable<Tree<T>> trees) {\n\t\treturn new Tree<>(parent, value, children.removeAll(trees), TreeTransformer.updateParent(this),\n\t\t\t\tTreeTransformer::updateChildren);\n\t}\n\n\t@Override\n\tpublic Tree<T> subtree() {\n\t\treturn new Tree<>(null, value, children, TreeTransformer::identity, TreeTransformer::updateChildren);\n\t}\n\n\t// -- conversion\n\n\tpublic Node<T> asNode() {\n\t\treturn new Node<T>(value, children.stream().map(child -> child.asNode()).collect(List.collector()));\n\t}\n\n\t// -- transformation\n\n\t/**\n\t * Manifest-type for and holder of Tree transformations.\n\t * \n\t * @param <T>\n\t */\n\tstatic interface TreeTransformer<T> extends Function<Tree<T>, UnaryOperator<Tree<T>>> {\n\n\t\t/**\n\t\t * Use-case: tree tells its children to re-create all their children without re-creating their parents.\n\t\t * <p>\n\t\t * Example: (1 2 3).detach(3)<br>\n\t\t * \n\t\t * <pre>\n\t\t * <code>\n\t\t *    1\n\t\t *   / \\\n\t\t *  2   3\n\t\t * \n\t\t * new1 = Tree(prev1.parent, prev1.value, updateChildren(prev1.children.remove(3)))\n\t\t * updateChildren(prev2) = new2 = Tree(new1, prev2.value, ())\n\t\t * \n\t\t *    1\n\t\t *    |\n\t\t *    2\n\t\t * </code>\n\t\t * </pre>\n\t\t * \n\t\t * @param self\n\t\t * @return\n\t\t */\n\t\tstatic <T> UnaryOperator<Tree<T>> updateChildren(Tree<T> self) {\n\t\t\treturn child -> new Tree<>(self, child.value, child.children, TreeTransformer::identity,\n\t\t\t\t\tTreeTransformer::updateChildren);\n\t\t}\n\n\t\t// Use-case 1: tree passes itself as parent to its children\n\t\t// Use-case 2: tree defers decending children, see Node.asTree()\n\t\t// TODO: return None instead of identity() to reduce O(n) to O(1)\n\t\tstatic <T> UnaryOperator<Tree<T>> identity(Tree<T> self) {\n\t\t\treturn parent -> parent;\n\t\t}\n\n\t\t// Use-case: update the whole parent structure but substitute parent.oldChild with this new child\n\t\tstatic <T> TreeTransformer<T> updateParent(Tree<T> prevChild) {\n\t\t\treturn self -> parent -> new Tree<>(parent.parent, parent.value, parent.children,\n\t\t\t\t\tTreeTransformer.updateParent(parent), TreeTransformer.substitutePreviousChild(prevChild, self));\n\t\t}\n\n\t\t// Use-case: existing tree instructs its parent to replace it and re-create the rest of the children\n\t\tstatic <T> TreeTransformer<T> substitutePreviousChild(Tree<T> prevChild, Tree<T> newChild) {\n\t\t\treturn self -> child -> (child.equals(prevChild)) ? newChild : new Tree<>(self, child.value,\n\t\t\t\t\tchild.children, TreeTransformer::identity, TreeTransformer::updateChildren);\n\t\t}\n\n\t\t// Use-case: creating new Tree node with a specific parent\n\t\tstatic <T> UnaryOperator<Tree<T>> addThisToParent(Tree<T> self) {\n\t\t\treturn parent -> new Tree<>(parent.parent, parent.value, parent.children.append(self),\n\t\t\t\t\tTreeTransformer.updateParent(parent), TreeTransformer::updateChildren);\n\t\t}\n\t}\n}", "class_id": 0, "repo": "cybernetics/javaslang", "file": "src/main/java/javaslang/collection/Tree.java", "last_update_at": "2019-04-22T08:48:34+00:00", "question_id": "b6f51f784d8ee5a13e1baa43195deea8a7e573b9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Tree<T> extends AbstractTreeLikeStructure<T, Tree<T>> implements Serializable /* TODO:extends Iterable<T> */{\n\tprivate static final long serialVersionUID = -7482343083286183794L;\n\tprivate final Tree<T> parent;\n\tprivate final T value;\n\tprivate final List<Tree<T>> children;\n\t// -- constructors + factory methods\n\tpublic Tree(T value) {\n\t\tthis(null, value, List.of(), TreeTransformer::identity, TreeTransformer::identity);\n\t}\n\tpublic Tree(T value, Iterable<Tree<T>> children) {\n\t\tthis(null, value, children, TreeTransformer::identity, TreeTransformer::updateChildren);\n\t}\n\tpublic Tree(Tree<T> parent, T value) {\n\t\tthis(parent, value, List.of(), TreeTransformer::addThisToParent, TreeTransformer::identity);\n\t}\n\tpublic Tree(Tree<T> parent, T value, Iterable<Tree<T>> children) {\n\t\tthis(parent, value, children, TreeTransformer::addThisToParent, TreeTransformer::updateChildren);\n\t}\n\t// DEV-NOTE: beware of NPEs because this is leaving the constructor\n\tTree(Tree<T> parent, T value, Iterable<Tree<T>> children, TreeTransformer<T> updateParent,\n\t\t\tTreeTransformer<T> updateChildren) {\n\t\trequireNonNull(children, \"children is null\");\n\t\trequireNonNull(updateParent, \"updateParent is null\");\n\t\trequireNonNull(updateChildren, \"updateChildren is null\");\n\t\tthis.value = value;\n\t\tthis.children = List.of(children).replaceAll(updateChildren.apply(this));\n\t\tthis.parent = Option.of(parent).map(updateParent.apply(this)).orElse(null);\n\t}\n\t/**\n\t * Factory method for easy tree building.\n\t * <p>\n\t * <strong>Example:</strong>\n\t * <p>\n\t * {@code tree(\"A\", tree(\"B\"), tree(\"C\", tree(\"D\"), tree(\"E\", tree(\"F\", tree(\"G\")))))}\n\t * <p>\n\t * results in:\n\t * \n\t * <pre>\n\t * <code>\n\t *   A\n\t *  / \\\n\t * B   C\n\t *    / \\\n\t *   D   E\n\t *       |\n\t *       F\n\t *       |\n\t *       G\n\t * </code>\n\t * </pre>\n\t * \n\t * @param <T> value type of the result Tree\n\t * @param value The value of the Tree.\n\t * @param children The children of the Tree.\n\t * @return A new Tree instance based on the arguments.\n\t */\n\t@SafeVarargs\n\tpublic static <T> Tree<T> tree(T value, Tree<T>... children) {\n\t\tfinal List<Tree<T>> childList = List.of(children);\n\t\treturn new Tree<>(null, value, childList, TreeTransformer::identity, TreeTransformer::updateChildren);\n\t}\n\t// -- core\n\tpublic Option<Tree<T>> getParent() {\n\t\treturn Option.of(parent);\n\t}\n\tpublic Tree<T> setParent(Tree<T> parent) {\n\t\tif (Objects.equals(this.parent, parent)) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new Tree<>(parent, value, children, TreeTransformer::addThisToParent,\n\t\t\t\t\tTreeTransformer::updateChildren);\n\t\t}\n\t}\n\tpublic Tree<T> getRoot() {\n\t\tTree<T> tree = this;\n\t\twhile (tree.parent != null) {\n\t\t\ttree = tree.parent;\n\t\t}\n\t\treturn tree;\n\t}\n\tpublic boolean isRoot() {\n\t\treturn parent == null;\n\t}\n\t@Override\n\tpublic T getValue() {\n\t\treturn value;\n\t}\n\t@Override\n\tpublic Tree<T> setValue(T value) {\n\t\treturn new Tree<>(parent, value, children, TreeTransformer.updateParent(this), TreeTransformer::updateChildren);\n\t}\n\t@Override\n\tpublic List<Tree<T>> getChildren() {\n\t\treturn children;\n\t}\n\t@Override\n\tpublic Tree<T> setChildren(Iterable<Tree<T>> children) {\n\t\treturn new Tree<>(parent, value, children, TreeTransformer.updateParent(this), TreeTransformer::updateChildren);\n\t}\n\t// -- operations\n\t@Override\n\tpublic Tree<T> attach(Iterable<Tree<T>> trees) {\n\t\treturn new Tree<>(parent, value, List.of(trees).prependAll(children), TreeTransformer.updateParent(this),\n\t\t\t\tTreeTransformer::updateChildren);\n\t}\n\t@Override\n\tpublic Tree<T> detach(Iterable<Tree<T>> trees) {\n\t\treturn new Tree<>(parent, value, children.removeAll(trees), TreeTransformer.updateParent(this),\n\t\t\t\tTreeTransformer::updateChildren);\n\t}\n\t@Override\n\tpublic Tree<T> subtree() {\n\t\treturn new Tree<>(null, value, children, TreeTransformer::identity, TreeTransformer::updateChildren);\n\t}\n\t// -- conversion\n\tpublic Node<T> asNode() {\n\t\treturn new Node<T>(value, children.stream().map(child -> child.asNode()).collect(List.collector()));\n\t}\n\t// -- transformation\n\t/**\n\t * Manifest-type for and holder of Tree transformations.\n\t * \n\t * @param <T>\n\t */\n\tstatic interface TreeTransformer<T> extends Function<Tree<T>, UnaryOperator<Tree<T>>> {\n\t\t/**\n\t\t * Use-case: tree tells its children to re-create all their children without re-creating their parents.\n\t\t * <p>\n\t\t * Example: (1 2 3).detach(3)<br>\n\t\t * \n\t\t * <pre>\n\t\t * <code>\n\t\t *    1\n\t\t *   / \\\n\t\t *  2   3\n\t\t * \n\t\t * new1 = Tree(prev1.parent, prev1.value, updateChildren(prev1.children.remove(3)))\n\t\t * updateChildren(prev2) = new2 = Tree(new1, prev2.value, ())\n\t\t * \n\t\t *    1\n\t\t *    |\n\t\t *    2\n\t\t * </code>\n\t\t * </pre>\n\t\t * \n\t\t * @param self\n\t\t * @return\n\t\t */\n\t\tstatic <T> UnaryOperator<Tree<T>> updateChildren(Tree<T> self) {\n\t\t\treturn child -> new Tree<>(self, child.value, child.children, TreeTransformer::identity,\n\t\t\t\t\tTreeTransformer::updateChildren);\n\t\t}\n\t\t// Use-case 1: tree passes itself as parent to its children\n\t\t// Use-case 2: tree defers decending children, see Node.asTree()\n\t\t// TODO: return None instead of identity() to reduce O(n) to O(1)\n\t\tstatic <T> UnaryOperator<Tree<T>> identity(Tree<T> self) {\n\t\t\treturn parent -> parent;\n\t\t}\n\t\t// Use-case: update the whole parent structure but substitute parent.oldChild with this new child\n\t\tstatic <T> TreeTransformer<T> updateParent(Tree<T> prevChild) {\n\t\t\treturn self -> parent -> new Tree<>(parent.parent, parent.value, parent.children,\n\t\t\t\t\tTreeTransformer.updateParent(parent), TreeTransformer.substitutePreviousChild(prevChild, self));\n\t\t}\n\t\t// Use-case: existing tree instructs its parent to replace it and re-create the rest of the children\n\t\tstatic <T> TreeTransformer<T> substitutePreviousChild(Tree<T> prevChild, Tree<T> newChild) {\n\t\t\treturn self -> child -> (child.equals(prevChild)) ? newChild : new Tree<>(self, child.value,\n\t\t\t\t\tchild.children, TreeTransformer::identity, TreeTransformer::updateChildren);\n\t\t}\n\t\t// Use-case: creating new Tree node with a specific parent\n\t\tstatic <T> UnaryOperator<Tree<T>> addThisToParent(Tree<T> self) {\n\t\t\treturn parent -> new Tree<>(parent.parent, parent.value, parent.children.append(self),\n\t\t\t\t\tTreeTransformer.updateParent(parent), TreeTransformer::updateChildren);\n\t\t}\n\t}\n"]]}
{"hexsha": "fe621f0c1804e5bf30835d1b01f5acee8fb59abc", "ext": "java", "lang": "Java", "content": "public class ThermostatUserInterfaceConfigurationClient extends ClientCluster {\r\n\r\n\tprivate static final DoubleByte THERMOSTAT_USER_INTERFACE_CONFIGURATION_ID_DB = new DoubleByte(0x0204);\r\n\t\r\n\tpublic static final DoubleByte KEYPAD_LOOKOUT_ATTRIBUTE_ID = new DoubleByte(0x0001);\r\n\t\r\n\t@Override\r\n\tprotected ZFrame[] manageClusterSpecificFrame(AfIncomingMsg af, ZclDevice dev,MqttConnection connection) {\r\n\t\treturn new ZFrame[0];\r\n\t}\r\n\r\n\t@Override\r\n\tprotected ZFrame[] manageProfileWideFrame(AfIncomingMsg af, ZclDevice dev) {\r\n\t\treturn new ZFrame[0];\r\n\t}\r\n\r\n\t@Override\r\n\tpublic ZFrame[] init(ZclDevice dev) {\r\n\t\tif (dev == null) {\r\n\t\t\treturn new ZFrame[0];\r\n\t\t}\r\n\t\tZclCluster tuicCluster = dev.getZclCluster(THERMOSTAT_USER_INTERFACE_CONFIGURATION_ID_DB);\r\n\t\tif (tuicCluster == null) {\r\n\t\t\treturn new ZFrame[0];\r\n\t\t}\r\n\t\tZFrame frame = tuicCluster.buildWriteAttributes(\r\n\t\t\t\tKEYPAD_LOOKOUT_ATTRIBUTE_ID, \"0\");\r\n\t\treturn new ZFrame[] {frame};\r\n\t}\r\n\r\n\t@Override\r\n\tpublic DoubleByte getClusterId() {\r\n\t\treturn new DoubleByte(THERMOSTAT_USER_INTERFACE_CONFIGURATION_ID_DB.intValue());\r\n\t}\r\n}", "class_id": 0, "repo": "onesaitplatform/onesait-things", "file": "edge-engine/edge-zigbee/sources/modules/zigbee/src/main/java/com/onesait/edge/engine/zigbee/clients/ThermostatUserInterfaceConfigurationClient.java", "last_update_at": "2019-09-17T05:27:15+00:00", "question_id": "fe621f0c1804e5bf30835d1b01f5acee8fb59abc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ThermostatUserInterfaceConfigurationClient extends ClientCluster {\r\n\r\n\tprivate static final DoubleByte THERMOSTAT_USER_INTERFACE_CONFIGURATION_ID_DB = new DoubleByte(0x0204);\r\n\t\r\n\tpublic static final DoubleByte KEYPAD_LOOKOUT_ATTRIBUTE_ID = new DoubleByte(0x0001);\r\n\t\r\n\t@Override\r\n\tprotected ZFrame[] manageClusterSpecificFrame(AfIncomingMsg af, ZclDevice dev,MqttConnection connection) {\r\n\t\treturn new ZFrame[0];\r\n\t}\r\n\r\n\t@Override\r\n\tprotected ZFrame[] manageProfileWideFrame(AfIncomingMsg af, ZclDevice dev) {\r\n\t\treturn new ZFrame[0];\r\n\t}\r\n\r\n\t@Override\r\n\tpublic ZFrame[] init(ZclDevice dev) {\r\n\t\tif (dev == null) {\r\n\t\t\treturn new ZFrame[0];\r\n\t\t}\r\n\t\tZclCluster tuicCluster = dev.getZclCluster(THERMOSTAT_USER_INTERFACE_CONFIGURATION_ID_DB);\r\n\t\tif (tuicCluster == null) {\r\n\t\t\treturn new ZFrame[0];\r\n\t\t}\r\n\t\tZFrame frame = tuicCluster.buildWriteAttributes(\r\n\t\t\t\tKEYPAD_LOOKOUT_ATTRIBUTE_ID, \"0\");\r\n\t\treturn new ZFrame[] {frame};\r\n\t}\r\n\r\n\t@Override\r\n\tpublic DoubleByte getClusterId() {\r\n\t\treturn new DoubleByte(THERMOSTAT_USER_INTERFACE_CONFIGURATION_ID_DB.intValue());\r\n\t}\r\n"]]}
{"hexsha": "b086381ed79de7165255cb295f777c59bb9aacaf", "ext": "java", "lang": "Java", "content": "public class MethodHierarchyBrowser extends MethodHierarchyBrowserBase {\n  private static final Logger LOG = Logger.getInstance(MethodHierarchyBrowser.class);\n\n  public MethodHierarchyBrowser(final Project project, final PsiMethod method) {\n    super(project, method);\n  }\n\n  @Override\n  protected void createTrees(@NotNull Map<String, JTree> trees) {\n    final JTree tree = createTree(false);\n    ActionGroup group = (ActionGroup)ActionManager.getInstance().getAction(IdeActions.GROUP_METHOD_HIERARCHY_POPUP);\n    PopupHandler.installPopupHandler(tree, group, ActionPlaces.METHOD_HIERARCHY_VIEW_POPUP, ActionManager.getInstance());\n                    \n    final BaseOnThisMethodAction action = new BaseOnThisMethodAction();\n    action.registerCustomShortcutSet(ActionManager.getInstance().getAction(IdeActions.ACTION_METHOD_HIERARCHY).getShortcutSet(), tree);\n\n    trees.put(METHOD_TYPE, tree);\n  }\n\n  @Override\n  protected JPanel createLegendPanel() {\n    return createStandardLegendPanel(IdeBundle.message(\"hierarchy.legend.method.is.defined.in.class\"),\n                                     IdeBundle.message(\"hierarchy.legend.method.defined.in.superclass\"),\n                                     IdeBundle.message(\"hierarchy.legend.method.should.be.defined\"));\n  }\n\n  @Override\n  protected PsiElement getElementFromDescriptor(@NotNull final HierarchyNodeDescriptor descriptor) {\n    if (descriptor instanceof MethodHierarchyNodeDescriptor) {\n      return ((MethodHierarchyNodeDescriptor)descriptor).getTargetElement();\n    }\n    return null;\n  }\n\n  @Override\n  protected boolean isApplicableElement(@NotNull final PsiElement psiElement) {\n    return psiElement instanceof PsiMethod;\n  }\n\n  @Override\n  protected HierarchyTreeStructure createHierarchyTreeStructure(@NotNull final String typeName, @NotNull final PsiElement psiElement) {\n    if (!METHOD_TYPE.equals(typeName)) {\n      LOG.error(\"unexpected type: \" + typeName);\n      return null;\n    }\n    return new MethodHierarchyTreeStructure(myProject, (PsiMethod)psiElement, getCurrentScopeType());\n  }\n\n  @Override\n  protected Comparator<NodeDescriptor> getComparator() {\n    return JavaHierarchyUtil.getComparator(myProject);\n  }\n\n  public PsiMethod getBaseMethod() {\n    return (PsiMethod)getHierarchyBase();\n  }\n\n  public static final class BaseOnThisMethodAction extends MethodHierarchyBrowserBase.BaseOnThisMethodAction { }\n}", "class_id": 0, "repo": "tgodzik/intellij-community", "file": "java/java-impl/src/com/intellij/ide/hierarchy/method/MethodHierarchyBrowser.java", "last_update_at": "2019-12-02T20:40:59+00:00", "question_id": "b086381ed79de7165255cb295f777c59bb9aacaf", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MethodHierarchyBrowser extends MethodHierarchyBrowserBase {\n  private static final Logger LOG = Logger.getInstance(MethodHierarchyBrowser.class);\n  public MethodHierarchyBrowser(final Project project, final PsiMethod method) {\n    super(project, method);\n  }\n  @Override\n  protected void createTrees(@NotNull Map<String, JTree> trees) {\n    final JTree tree = createTree(false);\n    ActionGroup group = (ActionGroup)ActionManager.getInstance().getAction(IdeActions.GROUP_METHOD_HIERARCHY_POPUP);\n    PopupHandler.installPopupHandler(tree, group, ActionPlaces.METHOD_HIERARCHY_VIEW_POPUP, ActionManager.getInstance());\n    final BaseOnThisMethodAction action = new BaseOnThisMethodAction();\n    action.registerCustomShortcutSet(ActionManager.getInstance().getAction(IdeActions.ACTION_METHOD_HIERARCHY).getShortcutSet(), tree);\n    trees.put(METHOD_TYPE, tree);\n  }\n  @Override\n  protected JPanel createLegendPanel() {\n    return createStandardLegendPanel(IdeBundle.message(\"hierarchy.legend.method.is.defined.in.class\"),\n                                     IdeBundle.message(\"hierarchy.legend.method.defined.in.superclass\"),\n                                     IdeBundle.message(\"hierarchy.legend.method.should.be.defined\"));\n  }\n  @Override\n  protected PsiElement getElementFromDescriptor(@NotNull final HierarchyNodeDescriptor descriptor) {\n    if (descriptor instanceof MethodHierarchyNodeDescriptor) {\n      return ((MethodHierarchyNodeDescriptor)descriptor).getTargetElement();\n    }\n    return null;\n  }\n  @Override\n  protected boolean isApplicableElement(@NotNull final PsiElement psiElement) {\n    return psiElement instanceof PsiMethod;\n  }\n  @Override\n  protected HierarchyTreeStructure createHierarchyTreeStructure(@NotNull final String typeName, @NotNull final PsiElement psiElement) {\n    if (!METHOD_TYPE.equals(typeName)) {\n      LOG.error(\"unexpected type: \" + typeName);\n      return null;\n    }\n    return new MethodHierarchyTreeStructure(myProject, (PsiMethod)psiElement, getCurrentScopeType());\n  }\n  @Override\n  protected Comparator<NodeDescriptor> getComparator() {\n    return JavaHierarchyUtil.getComparator(myProject);\n  }\n  public PsiMethod getBaseMethod() {\n    return (PsiMethod)getHierarchyBase();\n  }\n  public static final class BaseOnThisMethodAction extends MethodHierarchyBrowserBase.BaseOnThisMethodAction { }\n"]]}
{"hexsha": "bc786a7c599bda940751dcc7562807bc6019832a", "ext": "java", "lang": "Java", "content": "public class SWEA_1208_Flatten {\n\tprivate static int[] map;\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t\n\t\tBufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder stringBuilder = new StringBuilder();\n\t\tfor(int tc=1;tc<=1;tc++) {\n\t\t\tint num = Integer.parseInt(bufferedReader.readLine());\n\t\t\tStringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine());\n\t\t\tmap = new int[100];\n\t\t\tfor(int i=0;i<100;i++) {\n\t\t\t\tmap[i] = Integer.parseInt(stringTokenizer.nextToken());\n\t\t\t}\n\t\t\tstringBuilder.append(\"#\"+tc+\" \");\n\t\t\tboolean end = false;\n\t\t\tint k=1;\n\t\t\tfor( k=0;k<=num;k++) {\n\t\t\t\tint max=Integer.MIN_VALUE;\n\t\t\t\tint max_idx=-1;\n\t\t\t\tint min =Integer.MAX_VALUE;\n\t\t\t\tint min_idx=-1;\n\t\t\t\tfor(int i=0;i<100;i++) {\n\t\t\t\t\tif(max<map[i]) {\n\t\t\t\t\t\tmax_idx=i;\n\t\t\t\t\t\tmax=map[i];\n\t\t\t\t\t}\n\t\t\t\t\tif(min>map[i]) {\n\t\t\t\t\t\tmin_idx=i;\n\t\t\t\t\t\tmin=map[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//\ub2e4\ud588\uc744 \ub54c max,min\uc774 \uc815\ud574\uc9c4\ub2e4.\n\t\t\t\tmap[max_idx]-=1;\n\t\t\t\tmap[min_idx]+=1;\n\t\t\t\tif(map[max_idx]==map[min_idx] ) { //\ucc28\uac00 0 \uc62c 1 \uc774 \ub420\ub54c \uadf8\ub9cc\ub454\ub2e4.\n\t\t\t\t\tstringBuilder.append(0+\"\\n\");\n\t\t\t\t\tend = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(map[max_idx]-map[min_idx]==1 ) { //\ucc28\uac00 0 \uc62c 1 \uc774 \ub420\ub54c \uadf8\ub9cc\ub454\ub2e4.\n\t\t\t\t\tstringBuilder.append(1+\"\\n\");\n\t\t\t\t\tend = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(k==num&&!end) {\n\t\t\t\t\tstringBuilder.append((map[max_idx]-map[min_idx]+2)+\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}//tc\n\t\tSystem.out.println(stringBuilder);\n\t}\n}", "class_id": 0, "repo": "stevejhkang/algorithm-quiz", "file": "project_folder/src/SWEA2/SWEA_1208_Flatten.java", "last_update_at": "2019-10-31T15:13:05+00:00", "question_id": "bc786a7c599bda940751dcc7562807bc6019832a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SWEA_1208_Flatten {\n\tprivate static int[] map;\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t\n\t\tBufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder stringBuilder = new StringBuilder();\n\t\tfor(int tc=1;tc<=1;tc++) {\n\t\t\tint num = Integer.parseInt(bufferedReader.readLine());\n\t\t\tStringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine());\n\t\t\tmap = new int[100];\n\t\t\tfor(int i=0;i<100;i++) {\n\t\t\t\tmap[i] = Integer.parseInt(stringTokenizer.nextToken());\n\t\t\t}\n\t\t\tstringBuilder.append(\"#\"+tc+\" \");\n\t\t\tboolean end = false;\n\t\t\tint k=1;\n\t\t\tfor( k=0;k<=num;k++) {\n\t\t\t\tint max=Integer.MIN_VALUE;\n\t\t\t\tint max_idx=-1;\n\t\t\t\tint min =Integer.MAX_VALUE;\n\t\t\t\tint min_idx=-1;\n\t\t\t\tfor(int i=0;i<100;i++) {\n\t\t\t\t\tif(max<map[i]) {\n\t\t\t\t\t\tmax_idx=i;\n\t\t\t\t\t\tmax=map[i];\n\t\t\t\t\t}\n\t\t\t\t\tif(min>map[i]) {\n\t\t\t\t\t\tmin_idx=i;\n\t\t\t\t\t\tmin=map[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//\ub2e4\ud588\uc744 \ub54c max,min\uc774 \uc815\ud574\uc9c4\ub2e4.\n\t\t\t\tmap[max_idx]-=1;\n\t\t\t\tmap[min_idx]+=1;\n\t\t\t\tif(map[max_idx]==map[min_idx] ) { //\ucc28\uac00 0 \uc62c 1 \uc774 \ub420\ub54c \uadf8\ub9cc\ub454\ub2e4.\n\t\t\t\t\tstringBuilder.append(0+\"\\n\");\n\t\t\t\t\tend = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(map[max_idx]-map[min_idx]==1 ) { //\ucc28\uac00 0 \uc62c 1 \uc774 \ub420\ub54c \uadf8\ub9cc\ub454\ub2e4.\n\t\t\t\t\tstringBuilder.append(1+\"\\n\");\n\t\t\t\t\tend = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(k==num&&!end) {\n\t\t\t\t\tstringBuilder.append((map[max_idx]-map[min_idx]+2)+\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}//tc\n\t\tSystem.out.println(stringBuilder);\n\t}\n"]]}
{"hexsha": "a569ae9bd4b420cb3e1426ae758ee98b3e14fbfb", "ext": "java", "lang": "Java", "content": "public class TestSlice extends StreamingProgramTestBase {\r\n\r\n\tprivate String resultPath;\r\n\tprivate String expectedResult;\r\n\r\n\t@Rule\r\n\tpublic TemporaryFolder tempFolder = new TemporaryFolder();\r\n\r\n\t@Override\r\n\tprotected void preSubmit() throws Exception {\r\n\t\tresultPath = tempFolder.newFile().toURI().toString();\r\n\t}\r\n\r\n\t@Override\r\n\tprotected void postSubmit() throws Exception {\r\n\t\tcompareResultsByLinesInMemory(expectedResult, resultPath);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void testProgram() throws Exception {\r\n\t\ttestFoldNeighborsDefault();\r\n\t\ttestFoldNeighborsIn();\r\n\t\ttestFoldNeighborsAll();\r\n\t\ttestReduceOnNeighborsDefault();\r\n\t\ttestReduceOnNeighborsIn();\r\n\t\ttestReduceOnNeighborsAll();\r\n\t\ttestApplyOnNeighborsDefault();\r\n\t\ttestApplyOnNeighborsIn();\r\n\t\ttestApplyOnNeighborsAll();\r\n\t}\r\n\r\n\tpublic void testFoldNeighborsDefault() throws Exception {\r\n\r\n\t\tfinal StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\r\n\r\n\t\tSimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);\r\n\r\n\t\tDataStream<Tuple2<Long, Long>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS))\r\n\t\t\t.foldNeighbors(new Tuple2<Long, Long>(0l, 0l), new SumEdgeValues());\r\n\r\n\t\tsum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);\r\n\t\tenv.execute();\r\n\t\texpectedResult = \"1,25\\n\" +\r\n\t\t\t\t\"2,23\\n\" +\r\n\t\t\t\t\"3,69\\n\" +\r\n\t\t\t\t\"4,45\\n\" +\r\n\t\t\t\t\"5,51\\n\";\r\n\t}\r\n\r\n\tpublic void testFoldNeighborsIn() throws Exception {\r\n\r\n\t\tfinal StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\r\n\r\n\t\tSimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);\r\n\r\n\t\tDataStream<Tuple2<Long, Long>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS), EdgeDirection.IN)\r\n\t\t\t.foldNeighbors(new Tuple2<Long, Long>(0l, 0l), new SumEdgeValues());\r\n\r\n\t\tsum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);\r\n\t\tenv.execute();\r\n\t\texpectedResult = \"1,51\\n\" +\r\n\t\t\t\t\"2,12\\n\" +\r\n\t\t\t\t\"3,36\\n\" +\r\n\t\t\t\t\"4,34\\n\" +\r\n\t\t\t\t\"5,80\\n\";\r\n\t}\r\n\r\n\tpublic void testFoldNeighborsAll() throws Exception {\r\n\r\n\t\tfinal StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\r\n\r\n\t\tSimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);\r\n\r\n\t\tDataStream<Tuple2<Long, Long>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS), EdgeDirection.ALL)\r\n\t\t\t.foldNeighbors(new Tuple2<Long, Long>(0l, 0l), new SumEdgeValues());\r\n\r\n\t\tsum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);\r\n\t\tenv.execute();\r\n\t\texpectedResult = \"1,76\\n\" +\r\n\t\t\t\t\"2,35\\n\" +\r\n\t\t\t\t\"3,105\\n\" +\r\n\t\t\t\t\"4,79\\n\" +\r\n\t\t\t\t\"5,131\\n\";\r\n\t}\r\n\r\n\tpublic void testReduceOnNeighborsDefault() throws Exception {\r\n\r\n\t\tfinal StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\r\n\r\n\t\tSimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);\r\n\r\n\t\tDataStream<Tuple2<Long, Long>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS))\r\n\t\t\t.reduceOnEdges(new SumEdgeValuesReduce());\r\n\r\n\t\tsum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);\r\n\t\tenv.execute();\r\n\t\texpectedResult = \"1,25\\n\" +\r\n\t\t\t\t\"2,23\\n\" +\r\n\t\t\t\t\"3,69\\n\" +\r\n\t\t\t\t\"4,45\\n\" +\r\n\t\t\t\t\"5,51\\n\";\r\n\t}\r\n\r\n\tpublic void testReduceOnNeighborsIn() throws Exception {\r\n\r\n\t\tfinal StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\r\n\r\n\t\tSimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);\r\n\r\n\t\tDataStream<Tuple2<Long, Long>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS), EdgeDirection.IN)\r\n\t\t\t\t.reduceOnEdges(new SumEdgeValuesReduce());\r\n\r\n\t\tsum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);\r\n\t\tenv.execute();\r\n\t\texpectedResult = \"1,51\\n\" +\r\n\t\t\t\t\"2,12\\n\" +\r\n\t\t\t\t\"3,36\\n\" +\r\n\t\t\t\t\"4,34\\n\" +\r\n\t\t\t\t\"5,80\\n\";\r\n\t}\r\n\r\n\tpublic void testReduceOnNeighborsAll() throws Exception {\r\n\r\n\t\tfinal StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\r\n\r\n\t\tSimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);\r\n\r\n\t\tDataStream<Tuple2<Long, Long>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS), EdgeDirection.ALL)\r\n\t\t\t\t.reduceOnEdges(new SumEdgeValuesReduce());\r\n\r\n\t\tsum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);\r\n\t\tenv.execute();\r\n\t\texpectedResult = \"1,76\\n\" +\r\n\t\t\t\t\"2,35\\n\" +\r\n\t\t\t\t\"3,105\\n\" +\r\n\t\t\t\t\"4,79\\n\" +\r\n\t\t\t\t\"5,131\\n\";\r\n\t}\r\n\r\n\tpublic void testApplyOnNeighborsDefault() throws Exception {\r\n\r\n\t\tfinal StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\r\n\r\n\t\tSimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);\r\n\r\n\t\tDataStream<Tuple2<Long, String>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS))\r\n\t\t\t\t.applyOnNeighbors(new SumEdgeValuesApply());\r\n\r\n\t\tsum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);\r\n\t\tenv.execute();\r\n\t\texpectedResult = \"1,small\\n\" +\r\n\t\t\t\t\"2,small\\n\" +\r\n\t\t\t\t\"3,big\\n\" +\r\n\t\t\t\t\"4,small\\n\" +\r\n\t\t\t\t\"5,big\\n\";\r\n\t}\r\n\r\n\tpublic void testApplyOnNeighborsIn() throws Exception {\r\n\r\n\t\tfinal StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\r\n\r\n\t\tSimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);\r\n\r\n\t\tDataStream<Tuple2<Long, String>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS), EdgeDirection.IN)\r\n\t\t\t\t.applyOnNeighbors(new SumEdgeValuesApply());\r\n\r\n\t\tsum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);\r\n\t\tenv.execute();\r\n\t\texpectedResult = \"1,big\\n\" +\r\n\t\t\t\t\"2,small\\n\" +\r\n\t\t\t\t\"3,small\\n\" +\r\n\t\t\t\t\"4,small\\n\" +\r\n\t\t\t\t\"5,big\\n\";\r\n\t}\r\n\r\n\tpublic void testApplyOnNeighborsAll() throws Exception {\r\n\r\n\t\tfinal StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\r\n\r\n\t\tSimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);\r\n\r\n\t\tDataStream<Tuple2<Long, String>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS), EdgeDirection.ALL)\r\n\t\t\t\t.applyOnNeighbors(new SumEdgeValuesApply());\r\n\r\n\t\tsum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);\r\n\t\tenv.execute();\r\n\t\texpectedResult = \"1,big\\n\" +\r\n\t\t\t\t\"2,small\\n\" +\r\n\t\t\t\t\"3,big\\n\" +\r\n\t\t\t\t\"4,big\\n\" +\r\n\t\t\t\t\"5,big\\n\";\r\n\t}\r\n\r\n\t@SuppressWarnings(\"serial\")\r\n\tprivate static final class SumEdgeValues implements EdgesFold<Long, Long, Tuple2<Long, Long>> {\r\n\r\n\t\tpublic Tuple2<Long, Long> foldEdges(Tuple2<Long, Long> accum, Long id, Long neighborID, Long edgeValue) {\r\n\t\t\taccum.setField(id, 0);\r\n\t\t\taccum.setField(accum.f1 + edgeValue, 1);\r\n\t\t\treturn accum;\r\n\t\t}\r\n\t}\r\n\r\n\t@SuppressWarnings(\"serial\")\r\n\tprivate static final class SumEdgeValuesReduce implements EdgesReduce<Long> {\r\n\r\n\t\t@Override\r\n\t\tpublic Long reduceEdges(Long firstEdgeValue, Long secondEdgeValue) {\r\n\t\t\treturn firstEdgeValue + secondEdgeValue;\r\n\t\t}\r\n\t}\r\n\r\n\t@SuppressWarnings(\"serial\")\r\n\tprivate static final class SumEdgeValuesApply implements EdgesApply<Long, Long, Tuple2<Long, String>> {\r\n\r\n\t\t@Override\r\n\t\tpublic void applyOnEdges(Long vertexID,\r\n\t\t\t\tIterable<Tuple2<Long, Long>> neighbors, Collector<Tuple2<Long, String>> out) {\r\n\t\t\tlong sum = 0;\r\n\t\t\tfor (Tuple2<Long, Long> n: neighbors) {\r\n\t\t\t\tsum += n.f1;\r\n\t\t\t}\r\n\t\t\tif (sum > 50) {\r\n\t\t\t\tout.collect(new Tuple2<Long, String>(vertexID, \"big\"));\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tout.collect(new Tuple2<Long, String>(vertexID, \"small\"));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}", "class_id": 0, "repo": "BenjaminSchiller/FlinkWrapper", "file": "src/test/java/org/apache/flink/graph/streaming/test/operations/TestSlice.java", "last_update_at": "2019-01-29T16:46:50+00:00", "question_id": "a569ae9bd4b420cb3e1426ae758ee98b3e14fbfb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestSlice extends StreamingProgramTestBase {\r\n\r\n\tprivate String resultPath;\r\n\tprivate String expectedResult;\r\n\r\n\t@Rule\r\n\tpublic TemporaryFolder tempFolder = new TemporaryFolder();\r\n\r\n\t@Override\r\n\tprotected void preSubmit() throws Exception {\r\n\t\tresultPath = tempFolder.newFile().toURI().toString();\r\n\t}\r\n\r\n\t@Override\r\n\tprotected void postSubmit() throws Exception {\r\n\t\tcompareResultsByLinesInMemory(expectedResult, resultPath);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void testProgram() throws Exception {\r\n\t\ttestFoldNeighborsDefault();\r\n\t\ttestFoldNeighborsIn();\r\n\t\ttestFoldNeighborsAll();\r\n\t\ttestReduceOnNeighborsDefault();\r\n\t\ttestReduceOnNeighborsIn();\r\n\t\ttestReduceOnNeighborsAll();\r\n\t\ttestApplyOnNeighborsDefault();\r\n\t\ttestApplyOnNeighborsIn();\r\n\t\ttestApplyOnNeighborsAll();\r\n\t}\r\n\r\n\tpublic void testFoldNeighborsDefault() throws Exception {\r\n\r\n\t\tfinal StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\r\n\r\n\t\tSimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);\r\n\r\n\t\tDataStream<Tuple2<Long, Long>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS))\r\n\t\t\t.foldNeighbors(new Tuple2<Long, Long>(0l, 0l), new SumEdgeValues());\r\n\r\n\t\tsum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);\r\n\t\tenv.execute();\r\n\t\texpectedResult = \"1,25\\n\" +\r\n\t\t\t\t\"2,23\\n\" +\r\n\t\t\t\t\"3,69\\n\" +\r\n\t\t\t\t\"4,45\\n\" +\r\n\t\t\t\t\"5,51\\n\";\r\n\t}\r\n\r\n\tpublic void testFoldNeighborsIn() throws Exception {\r\n\r\n\t\tfinal StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\r\n\r\n\t\tSimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);\r\n\r\n\t\tDataStream<Tuple2<Long, Long>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS), EdgeDirection.IN)\r\n\t\t\t.foldNeighbors(new Tuple2<Long, Long>(0l, 0l), new SumEdgeValues());\r\n\r\n\t\tsum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);\r\n\t\tenv.execute();\r\n\t\texpectedResult = \"1,51\\n\" +\r\n\t\t\t\t\"2,12\\n\" +\r\n\t\t\t\t\"3,36\\n\" +\r\n\t\t\t\t\"4,34\\n\" +\r\n\t\t\t\t\"5,80\\n\";\r\n\t}\r\n\r\n\tpublic void testFoldNeighborsAll() throws Exception {\r\n\r\n\t\tfinal StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\r\n\r\n\t\tSimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);\r\n\r\n\t\tDataStream<Tuple2<Long, Long>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS), EdgeDirection.ALL)\r\n\t\t\t.foldNeighbors(new Tuple2<Long, Long>(0l, 0l), new SumEdgeValues());\r\n\r\n\t\tsum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);\r\n\t\tenv.execute();\r\n\t\texpectedResult = \"1,76\\n\" +\r\n\t\t\t\t\"2,35\\n\" +\r\n\t\t\t\t\"3,105\\n\" +\r\n\t\t\t\t\"4,79\\n\" +\r\n\t\t\t\t\"5,131\\n\";\r\n\t}\r\n\r\n\tpublic void testReduceOnNeighborsDefault() throws Exception {\r\n\r\n\t\tfinal StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\r\n\r\n\t\tSimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);\r\n\r\n\t\tDataStream<Tuple2<Long, Long>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS))\r\n\t\t\t.reduceOnEdges(new SumEdgeValuesReduce());\r\n\r\n\t\tsum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);\r\n\t\tenv.execute();\r\n\t\texpectedResult = \"1,25\\n\" +\r\n\t\t\t\t\"2,23\\n\" +\r\n\t\t\t\t\"3,69\\n\" +\r\n\t\t\t\t\"4,45\\n\" +\r\n\t\t\t\t\"5,51\\n\";\r\n\t}\r\n\r\n\tpublic void testReduceOnNeighborsIn() throws Exception {\r\n\r\n\t\tfinal StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\r\n\r\n\t\tSimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);\r\n\r\n\t\tDataStream<Tuple2<Long, Long>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS), EdgeDirection.IN)\r\n\t\t\t\t.reduceOnEdges(new SumEdgeValuesReduce());\r\n\r\n\t\tsum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);\r\n\t\tenv.execute();\r\n\t\texpectedResult = \"1,51\\n\" +\r\n\t\t\t\t\"2,12\\n\" +\r\n\t\t\t\t\"3,36\\n\" +\r\n\t\t\t\t\"4,34\\n\" +\r\n\t\t\t\t\"5,80\\n\";\r\n\t}\r\n\r\n\tpublic void testReduceOnNeighborsAll() throws Exception {\r\n\r\n\t\tfinal StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\r\n\r\n\t\tSimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);\r\n\r\n\t\tDataStream<Tuple2<Long, Long>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS), EdgeDirection.ALL)\r\n\t\t\t\t.reduceOnEdges(new SumEdgeValuesReduce());\r\n\r\n\t\tsum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);\r\n\t\tenv.execute();\r\n\t\texpectedResult = \"1,76\\n\" +\r\n\t\t\t\t\"2,35\\n\" +\r\n\t\t\t\t\"3,105\\n\" +\r\n\t\t\t\t\"4,79\\n\" +\r\n\t\t\t\t\"5,131\\n\";\r\n\t}\r\n\r\n\tpublic void testApplyOnNeighborsDefault() throws Exception {\r\n\r\n\t\tfinal StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\r\n\r\n\t\tSimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);\r\n\r\n\t\tDataStream<Tuple2<Long, String>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS))\r\n\t\t\t\t.applyOnNeighbors(new SumEdgeValuesApply());\r\n\r\n\t\tsum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);\r\n\t\tenv.execute();\r\n\t\texpectedResult = \"1,small\\n\" +\r\n\t\t\t\t\"2,small\\n\" +\r\n\t\t\t\t\"3,big\\n\" +\r\n\t\t\t\t\"4,small\\n\" +\r\n\t\t\t\t\"5,big\\n\";\r\n\t}\r\n\r\n\tpublic void testApplyOnNeighborsIn() throws Exception {\r\n\r\n\t\tfinal StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\r\n\r\n\t\tSimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);\r\n\r\n\t\tDataStream<Tuple2<Long, String>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS), EdgeDirection.IN)\r\n\t\t\t\t.applyOnNeighbors(new SumEdgeValuesApply());\r\n\r\n\t\tsum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);\r\n\t\tenv.execute();\r\n\t\texpectedResult = \"1,big\\n\" +\r\n\t\t\t\t\"2,small\\n\" +\r\n\t\t\t\t\"3,small\\n\" +\r\n\t\t\t\t\"4,small\\n\" +\r\n\t\t\t\t\"5,big\\n\";\r\n\t}\r\n\r\n\tpublic void testApplyOnNeighborsAll() throws Exception {\r\n\r\n\t\tfinal StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\r\n\r\n\t\tSimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);\r\n\r\n\t\tDataStream<Tuple2<Long, String>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS), EdgeDirection.ALL)\r\n\t\t\t\t.applyOnNeighbors(new SumEdgeValuesApply());\r\n\r\n\t\tsum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);\r\n\t\tenv.execute();\r\n\t\texpectedResult = \"1,big\\n\" +\r\n\t\t\t\t\"2,small\\n\" +\r\n\t\t\t\t\"3,big\\n\" +\r\n\t\t\t\t\"4,big\\n\" +\r\n\t\t\t\t\"5,big\\n\";\r\n\t}\r\n\r\n\t@SuppressWarnings(\"serial\")\r\n\tprivate static final class SumEdgeValues implements EdgesFold<Long, Long, Tuple2<Long, Long>> {\r\n\r\n\t\tpublic Tuple2<Long, Long> foldEdges(Tuple2<Long, Long> accum, Long id, Long neighborID, Long edgeValue) {\r\n\t\t\taccum.setField(id, 0);\r\n\t\t\taccum.setField(accum.f1 + edgeValue, 1);\r\n\t\t\treturn accum;\r\n\t\t}\r\n\t}\r\n\r\n\t@SuppressWarnings(\"serial\")\r\n\tprivate static final class SumEdgeValuesReduce implements EdgesReduce<Long> {\r\n\r\n\t\t@Override\r\n\t\tpublic Long reduceEdges(Long firstEdgeValue, Long secondEdgeValue) {\r\n\t\t\treturn firstEdgeValue + secondEdgeValue;\r\n\t\t}\r\n\t}\r\n\r\n\t@SuppressWarnings(\"serial\")\r\n\tprivate static final class SumEdgeValuesApply implements EdgesApply<Long, Long, Tuple2<Long, String>> {\r\n\r\n\t\t@Override\r\n\t\tpublic void applyOnEdges(Long vertexID,\r\n\t\t\t\tIterable<Tuple2<Long, Long>> neighbors, Collector<Tuple2<Long, String>> out) {\r\n\t\t\tlong sum = 0;\r\n\t\t\tfor (Tuple2<Long, Long> n: neighbors) {\r\n\t\t\t\tsum += n.f1;\r\n\t\t\t}\r\n\t\t\tif (sum > 50) {\r\n\t\t\t\tout.collect(new Tuple2<Long, String>(vertexID, \"big\"));\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tout.collect(new Tuple2<Long, String>(vertexID, \"small\"));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n"]]}
{"hexsha": "69b7d346760caef0f459834a300f9f748badb527", "ext": "java", "lang": "Java", "content": "public class XmlReader {\r\n\r\n\tpublic static Element racine;\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t\t// Import fichier xml pour lecture\r\n\t\tFile file = new File(\"C:\\\\Users\\\\HB\\\\workspace\\\\Initiation_Java\\\\ressources\\\\trainees.xml\");\r\n\r\n\t\tDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\r\n\t\tDocumentBuilder db = null;\r\n\t\tDocument document = null;\r\n\t\t\r\n\t\ttry {\r\n\t\t\tdb = dbf.newDocumentBuilder();\r\n\t\t\tdocument = (Document) db.parse(file);\r\n\t\t} catch (SAXException | IOException | ParserConfigurationException e ) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\t\r\n\t\t// Element racine\r\n\t\tfinal Element racine = document.getDocumentElement();\r\n\t\t\r\n\t\t// Noeuds enfant\r\n\t\tfinal NodeList trainees = racine.getChildNodes();\r\n\r\n\t\t\r\n\t\t// Elements\r\n\t\tElement trainee, lastname, firstname, email, hobbies, hobby, title, director, singer;\r\n\t\t\r\n\t\t// Parcourir les noeuds\r\n\t\tfor (int i=0; i<trainees.getLength(); i++) {\r\n\t\t\tif (trainees.item(i).getNodeType() == Node.ELEMENT_NODE) { // Si Noeud du type Element\r\n\t\t\t\t// Noeud trainee\r\n\t\t\t\ttrainee = (Element) trainees.item(i);\r\n\t\t\t\tSystem.out.println(\"\\nsexe : \" + trainee.getAttribute(\"sexe\"));\r\n\t\t\t\t\t// Noeud lastname\r\n\t\t\t\t\tlastname = (Element) trainee.getElementsByTagName(\"lastname\").item(0);\r\n\t\t\t\t\tSystem.out.println(\"lastname : \" + lastname.getTextContent());\r\n\t\t\t\t\t// Noeud firstname\r\n\t\t\t\t\tfirstname = (Element) trainee.getElementsByTagName(\"firstname\").item(0);\r\n\t\t\t\t\tSystem.out.println(\"firstname : \" + firstname.getTextContent());\r\n\t\t\t\t\t// Noeud email\r\n\t\t\t\t\temail = (Element) trainee.getElementsByTagName(\"email\").item(0);\r\n\t\t\t\t\tSystem.out.println(\"email : \" + email.getTextContent());\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Noeud Hobbies\r\n\t\t\t\t\tNodeList hobbiesNodes = null;\r\n\t\t\t\t\thobbiesNodes = trainee.getElementsByTagName(\"hobbies\");\t\t\t\t\t\t\r\n\t\t\t\t\tfor (int j=0; j<hobbiesNodes.getLength(); j++) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\thobbies = (Element) hobbiesNodes.item(j);\r\n\t\t\t\t\t\tSystem.out.println(\"hobbies : \" + \"\\n{\");\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Noeud Hobby\r\n\t\t\t\t\t\tNodeList hobbyNodes = null;\r\n\t\t\t\t\t\thobbyNodes = hobbies.getElementsByTagName(\"hobby\");\r\n\t\t\t\t\t\tfor (int k = 0; k < hobbyNodes.getLength(); k++) {\r\n\t\t\t\t\t\t\thobby = (Element) hobbyNodes.item(k);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (hobby.getAttribute(\"category\").equals(\"cinema\")) { // cinema\r\n\t\t\t\t\t\t\t\ttitle = (Element) hobby.getElementsByTagName(\"title\").item(0);\r\n\t\t\t\t\t\t\t\tdirector = (Element) hobby.getElementsByTagName(\"director\").item(0);\r\n\t\t\t\t\t\t\t\tSystem.out.println(\"  cinema : \" + title.getTextContent() + \", director : \" + director.getTextContent());\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (hobby.getAttribute(\"category\").equals(\"music\")) { // music\r\n\t\t\t\t\t\t\t\ttitle = (Element) hobby.getElementsByTagName(\"title\").item(0);\r\n\t\t\t\t\t\t\t\tsinger = (Element) hobby.getElementsByTagName(\"singer\").item(0);\r\n\t\t\t\t\t\t\t\tSystem.out.println(\"  music : \" + title.getTextContent() + \", singer : \" + singer.getTextContent());\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (hobby.getAttribute(\"category\").equals(\"sport\")) { // sport\r\n\t\t\t\t\t\t\t\tSystem.out.println(\"  sport : \" + hobby.getTextContent());\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tSystem.out.println(\"}\");\r\n\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\r\n\t\t\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n}", "class_id": 0, "repo": "anouvene/JAVA", "file": "Basics/flux_xml/XmlReader.java", "last_update_at": "2019-04-27T13:51:31+00:00", "question_id": "69b7d346760caef0f459834a300f9f748badb527", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class XmlReader {\r\n\r\n\tpublic static Element racine;\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t\t// Import fichier xml pour lecture\r\n\t\tFile file = new File(\"C:\\\\Users\\\\HB\\\\workspace\\\\Initiation_Java\\\\ressources\\\\trainees.xml\");\r\n\r\n\t\tDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\r\n\t\tDocumentBuilder db = null;\r\n\t\tDocument document = null;\r\n\t\t\r\n\t\ttry {\r\n\t\t\tdb = dbf.newDocumentBuilder();\r\n\t\t\tdocument = (Document) db.parse(file);\r\n\t\t} catch (SAXException | IOException | ParserConfigurationException e ) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\t\r\n\t\t// Element racine\r\n\t\tfinal Element racine = document.getDocumentElement();\r\n\t\t\r\n\t\t// Noeuds enfant\r\n\t\tfinal NodeList trainees = racine.getChildNodes();\r\n\r\n\t\t\r\n\t\t// Elements\r\n\t\tElement trainee, lastname, firstname, email, hobbies, hobby, title, director, singer;\r\n\t\t\r\n\t\t// Parcourir les noeuds\r\n\t\tfor (int i=0; i<trainees.getLength(); i++) {\r\n\t\t\tif (trainees.item(i).getNodeType() == Node.ELEMENT_NODE) { // Si Noeud du type Element\r\n\t\t\t\t// Noeud trainee\r\n\t\t\t\ttrainee = (Element) trainees.item(i);\r\n\t\t\t\tSystem.out.println(\"\\nsexe : \" + trainee.getAttribute(\"sexe\"));\r\n\t\t\t\t\t// Noeud lastname\r\n\t\t\t\t\tlastname = (Element) trainee.getElementsByTagName(\"lastname\").item(0);\r\n\t\t\t\t\tSystem.out.println(\"lastname : \" + lastname.getTextContent());\r\n\t\t\t\t\t// Noeud firstname\r\n\t\t\t\t\tfirstname = (Element) trainee.getElementsByTagName(\"firstname\").item(0);\r\n\t\t\t\t\tSystem.out.println(\"firstname : \" + firstname.getTextContent());\r\n\t\t\t\t\t// Noeud email\r\n\t\t\t\t\temail = (Element) trainee.getElementsByTagName(\"email\").item(0);\r\n\t\t\t\t\tSystem.out.println(\"email : \" + email.getTextContent());\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Noeud Hobbies\r\n\t\t\t\t\tNodeList hobbiesNodes = null;\r\n\t\t\t\t\thobbiesNodes = trainee.getElementsByTagName(\"hobbies\");\t\t\t\t\t\t\r\n\t\t\t\t\tfor (int j=0; j<hobbiesNodes.getLength(); j++) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\thobbies = (Element) hobbiesNodes.item(j);\r\n\t\t\t\t\t\tSystem.out.println(\"hobbies : \" + \"\\n{\");\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Noeud Hobby\r\n\t\t\t\t\t\tNodeList hobbyNodes = null;\r\n\t\t\t\t\t\thobbyNodes = hobbies.getElementsByTagName(\"hobby\");\r\n\t\t\t\t\t\tfor (int k = 0; k < hobbyNodes.getLength(); k++) {\r\n\t\t\t\t\t\t\thobby = (Element) hobbyNodes.item(k);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (hobby.getAttribute(\"category\").equals(\"cinema\")) { // cinema\r\n\t\t\t\t\t\t\t\ttitle = (Element) hobby.getElementsByTagName(\"title\").item(0);\r\n\t\t\t\t\t\t\t\tdirector = (Element) hobby.getElementsByTagName(\"director\").item(0);\r\n\t\t\t\t\t\t\t\tSystem.out.println(\"  cinema : \" + title.getTextContent() + \", director : \" + director.getTextContent());\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (hobby.getAttribute(\"category\").equals(\"music\")) { // music\r\n\t\t\t\t\t\t\t\ttitle = (Element) hobby.getElementsByTagName(\"title\").item(0);\r\n\t\t\t\t\t\t\t\tsinger = (Element) hobby.getElementsByTagName(\"singer\").item(0);\r\n\t\t\t\t\t\t\t\tSystem.out.println(\"  music : \" + title.getTextContent() + \", singer : \" + singer.getTextContent());\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (hobby.getAttribute(\"category\").equals(\"sport\")) { // sport\r\n\t\t\t\t\t\t\t\tSystem.out.println(\"  sport : \" + hobby.getTextContent());\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tSystem.out.println(\"}\");\r\n\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\r\n\t\t\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n"]]}
{"hexsha": "8f1cbe4e99b1e50af407273513a48899c4741802", "ext": "java", "lang": "Java", "content": "class Test {\n\n    public static void main(String[] args) {\n        final String s = \"text\";\n        <selection>class A {\n            {\n                System.out.println(s);\n            }\n        }</selection>\n    }\n}", "class_id": 0, "repo": "jnthn/intellij-community", "file": "java/java-tests/testData/refactoring/extractMethod/FinalParams4LocalClasses.java", "last_update_at": "2019-08-17T10:07:23+00:00", "question_id": "8f1cbe4e99b1e50af407273513a48899c4741802", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Test {\n    public static void main(String[] args) {\n        final String s = \"text\";\n        <selection>class A {\n            {\n                System.out.println(s);\n            }\n        }</selection>\n    }\n"]]}
{"hexsha": "8f485ea35e4570be7e0b206a5f13b639a4943bb1", "ext": "java", "lang": "Java", "content": "@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest(classes = CarLocationApplication.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\npublic class CarLocationIT {\n\n    private static final String SUCCESS_CAR_UUID = \"9E219725-490E-4509-A42D-D0388DF317D4\";\n    private static final String NOT_FOUND_CAR_UUID = \"\";\n    private static final String ERROR_CAR_UUID = \"9E219725-490E-4509-A42D-D0388DF317DG\";\n\n    @LocalServerPort\n    private int randomServerPort;\n\n    @Test\n    public void smoke_test(){\n        assertThat(true).isTrue();\n    }\n\n    @Test\n    public void should_request_by_uuid_and_obtain_car_location() {\n        //Given\n        final RestTemplate restTemplate = new RestTemplate();\n\n        //When\n        final CarLocationDTO carLocation = restTemplate.getForObject(\"http://localhost:\" + randomServerPort + \"/carlocation/\"+SUCCESS_CAR_UUID+\"?q=foobar\", CarLocationDTO.class);\n\n        //Then\n        assertThat(carLocation).isNotNull();\n        assertThat(carLocation.getUuid()).isEqualToIgnoringCase(SUCCESS_CAR_UUID);\n        assertThat(carLocation.getLatitude()).isNotNull();\n        assertThat(carLocation.getLongitude()).isNotNull();\n    }\n\n    /*@Test\n    public void should_request_by_uuid_and_obtain_not_found() {\n        //Given\n        final RestTemplate restTemplate = new RestTemplate();\n\n        //When\n        final CarLocationDTO carLocation = restTemplate.getForObject(\"http://localhost:\" + randomServerPort + \"/carlocation/\"+NOT_FOUND_CAR_UUID+\"?q=foobar\", CarLocationDTO.class);\n\n        //Then\n        assertThat(carLocation).isNotNull();\n        assertThat(carLocation.getUuid()).isEqualToIgnoringCase(SUCCESS_CAR_UUID);\n        assertThat(carLocation.getLatitude()).isNotNull();\n        assertThat(carLocation.getLongitude()).isNotNull();\n    }*/\n\n    /*@Test\n    public void should_request_by_uuid_and_obtain_error() {\n        //Given\n        final RestTemplate restTemplate = new RestTemplate();\n\n        //When\n        final CarLocationDTO carLocation = restTemplate.getForObject(\"http://localhost:\" + randomServerPort + \"/carlocation/\"+ERROR_CAR_UUID+\"?q=foobar\", CarLocationDTO.class);\n\n        //Then\n        assertThat(carLocation).isNotNull();\n        assertThat(carLocation.getUuid()).isEqualToIgnoringCase(SUCCESS_CAR_UUID);\n        assertThat(carLocation.getLatitude()).isNotNull();\n        assertThat(carLocation.getLongitude()).isNotNull();\n    }*/\n\n    @Test\n    public void should_request_by_uuid_and_save_in_db_and_find_by_uuid() {\n        //Given\n        final RestTemplate restTemplate = new RestTemplate();\n        final CarLocationDTO carLocationRemote = restTemplate.getForObject(\"http://localhost:\" + randomServerPort + \"/carlocation/\"+SUCCESS_CAR_UUID, CarLocationDTO.class);\n        restTemplate.postForObject(\"http://localhost:\" + randomServerPort + \"/carlocation/\", carLocationRemote, List.class);\n        final ResponseEntity<List<CarLocationDTO>> exchange = restTemplate.exchange(\"http://localhost:\" + randomServerPort + \"/carlocation/db/\" + SUCCESS_CAR_UUID, HttpMethod.GET, null, new ParameterizedTypeReference<List<CarLocationDTO>>() {});\n        final List<CarLocationDTO> carLocationFromDbList = exchange.getBody();\n\n        assertThat(carLocationFromDbList).isNotNull();\n\n        for(CarLocationDTO carLocationFromDb : carLocationFromDbList) {\n            if(!StringUtils.isEmpty(carLocationFromDb.getUuid())){\n                assertThat(carLocationFromDb.getUuid().toUpperCase()).isEqualTo(SUCCESS_CAR_UUID);\n                assertThat(carLocationFromDb.getLatitude()).isNotNull();\n                assertThat(carLocationFromDb.getLongitude()).isNotNull();\n            }\n        }\n    }\n\n}", "class_id": 0, "repo": "scope-demo/scopeagent-reference-springboot2", "file": "src/test/java/com/undefinedlabs/scope/it/CarLocationIT.java", "last_update_at": "2019-12-10T17:58:42+00:00", "question_id": "8f485ea35e4570be7e0b206a5f13b639a4943bb1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest(classes = CarLocationApplication.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\npublic class CarLocationIT {\n    private static final String SUCCESS_CAR_UUID = \"9E219725-490E-4509-A42D-D0388DF317D4\";\n    private static final String NOT_FOUND_CAR_UUID = \"\";\n    private static final String ERROR_CAR_UUID = \"9E219725-490E-4509-A42D-D0388DF317DG\";\n    @LocalServerPort\n    private int randomServerPort;\n    @Test\n    public void smoke_test(){\n        assertThat(true).isTrue();\n    }\n    @Test\n    public void should_request_by_uuid_and_obtain_car_location() {\n        //Given\n        final RestTemplate restTemplate = new RestTemplate();\n        //When\n        final CarLocationDTO carLocation = restTemplate.getForObject(\"http://localhost:\" + randomServerPort + \"/carlocation/\"+SUCCESS_CAR_UUID+\"?q=foobar\", CarLocationDTO.class);\n        //Then\n        assertThat(carLocation).isNotNull();\n        assertThat(carLocation.getUuid()).isEqualToIgnoringCase(SUCCESS_CAR_UUID);\n        assertThat(carLocation.getLatitude()).isNotNull();\n        assertThat(carLocation.getLongitude()).isNotNull();\n    }\n    /*@Test\n    public void should_request_by_uuid_and_obtain_not_found() {\n        //Given\n        final RestTemplate restTemplate = new RestTemplate();\n        //When\n        final CarLocationDTO carLocation = restTemplate.getForObject(\"http://localhost:\" + randomServerPort + \"/carlocation/\"+NOT_FOUND_CAR_UUID+\"?q=foobar\", CarLocationDTO.class);\n        //Then\n        assertThat(carLocation).isNotNull();\n        assertThat(carLocation.getUuid()).isEqualToIgnoringCase(SUCCESS_CAR_UUID);\n        assertThat(carLocation.getLatitude()).isNotNull();\n        assertThat(carLocation.getLongitude()).isNotNull();\n    }*/\n    /*@Test\n    public void should_request_by_uuid_and_obtain_error() {\n        //Given\n        final RestTemplate restTemplate = new RestTemplate();\n        //When\n        final CarLocationDTO carLocation = restTemplate.getForObject(\"http://localhost:\" + randomServerPort + \"/carlocation/\"+ERROR_CAR_UUID+\"?q=foobar\", CarLocationDTO.class);\n        //Then\n        assertThat(carLocation).isNotNull();\n        assertThat(carLocation.getUuid()).isEqualToIgnoringCase(SUCCESS_CAR_UUID);\n        assertThat(carLocation.getLatitude()).isNotNull();\n        assertThat(carLocation.getLongitude()).isNotNull();\n    }*/\n    @Test\n    public void should_request_by_uuid_and_save_in_db_and_find_by_uuid() {\n        //Given\n        final RestTemplate restTemplate = new RestTemplate();\n        final CarLocationDTO carLocationRemote = restTemplate.getForObject(\"http://localhost:\" + randomServerPort + \"/carlocation/\"+SUCCESS_CAR_UUID, CarLocationDTO.class);\n        restTemplate.postForObject(\"http://localhost:\" + randomServerPort + \"/carlocation/\", carLocationRemote, List.class);\n        final ResponseEntity<List<CarLocationDTO>> exchange = restTemplate.exchange(\"http://localhost:\" + randomServerPort + \"/carlocation/db/\" + SUCCESS_CAR_UUID, HttpMethod.GET, null, new ParameterizedTypeReference<List<CarLocationDTO>>() {});\n        final List<CarLocationDTO> carLocationFromDbList = exchange.getBody();\n        assertThat(carLocationFromDbList).isNotNull();\n        for(CarLocationDTO carLocationFromDb : carLocationFromDbList) {\n            if(!StringUtils.isEmpty(carLocationFromDb.getUuid())){\n                assertThat(carLocationFromDb.getUuid().toUpperCase()).isEqualTo(SUCCESS_CAR_UUID);\n                assertThat(carLocationFromDb.getLatitude()).isNotNull();\n                assertThat(carLocationFromDb.getLongitude()).isNotNull();\n            }\n        }\n    }\n"]]}
{"hexsha": "0090665434bd1deaf7c0780958851f5dd53cac27", "ext": "java", "lang": "Java", "content": "@RunWith(SpringRunner.class)\n@SpringBootTest(classes = SpringbootApplication.class)\n@AutoConfigureMockMvc\n@TestPropertySource(locations = \"classpath:application-test.properties\")\npublic class UserControllerTest\n{\n    /**\n     * Control de los E-mail.\n     */\n    @MockBean\n    public JavaMailSender emailSender;\n    /**\n     * Repositorio de usuarios.\n     */\n    @MockBean\n    public UserRepository userRepository;\n    /**\n     * MVC de pruebas.\n     */\n    @Autowired\n    private MockMvc mvc;\n    /**\n     * Instancia del Contexto del servlet.\n     */\n    @Autowired\n    ServletContext servletContext;\n    /**\n     * Instancia del servicio de emails\n     */\n    @Autowired\n    private MailService mailService;\n    /**\n     * Instancia del servicio i18n\n     */\n    @Autowired\n    private MessageSource messageSource;\n    /**\n     * Instancia del servicio de usuarios.\n     */\n    @Autowired\n    private UserService userService;\n    /**\n     * Instancia del servicio de art\u00edculos.\n     */\n    @Autowired\n    private ArticleService articleService;\n    /**\n     * Instancia del servicio de login.\n     */\n    @Autowired\n    private UserAccessService userDetailsService;\n    /**\n     * Instancia del servicio de explorador de archivos.\n     */\n    @Autowired\n    private BrowserService browserService;\n    \n    /**\n     * Setup del test.\n     * \n     * @throws Exception \n     */\n    @Before\n    public void setUp() throws Exception\n    {\n        // E-MAIL\n        Mockito.when(emailSender.createMimeMessage()).thenReturn(new MimeMessage((Session)null));\n        \n        // Usuario\n        User user = new User();\n        user.setId(1);\n        user.setEmail(\"admin@test.com\");\n        user.setNickname(\"admin\");\n        user.setActive(Boolean.TRUE);\n        user.setUserRole(\"ROLE_USER\");\n        user.setUkey(\"UKEYTEST\");\n        user.setPassword(\"PASSWORD\");\n        \n        // Repositorios\n        // Usuarios\n        Mockito.when(userRepository.findByNickname(Mockito.eq(user.getNickname()))).thenReturn(user);\n        Mockito.when(userRepository.findByNickname(Mockito.eq(\"testing\"))).thenReturn(null);\n        Mockito.when(userRepository.findByEmail(Mockito.eq(user.getEmail()))).thenReturn(user);\n        Mockito.when(userRepository.findByUkey(Mockito.eq(user.getUkey()))).thenReturn(user);\n        Mockito.when(userRepository.findByUkey(Mockito.eq(\"UKEYNONE\"))).thenReturn(null);\n        Mockito.when(userRepository.findById(Mockito.eq(1))).thenReturn(Optional.of(user));\n        Mockito.when(userRepository.save((User) argThat(hasProperty(\"id\", is(1))))).thenReturn(user);\n    }\n    \n    /**\n     * Contexto.\n     * @throws Exception \n     */\n    @Test\n    public void contextLoads() throws Exception\n    {\n        assertThat(servletContext).isNotNull();\n        assertThat(mailService).isNotNull();\n        assertThat(messageSource).isNotNull();\n        assertThat(userService).isNotNull();\n        assertThat(articleService).isNotNull();\n        assertThat(userDetailsService).isNotNull();\n        assertThat(browserService).isNotNull();\n    }\n    /**\n     * Prueba de login sin usuario\n     * @throws Throwable \n     */\n    @Test\n    public void accessLoginNoUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/login\"))\n            .andExpect(status().isOk())\n            .andExpect(view().name(\"user/login\"));\n    }\n    /**\n     * Prueba de login con usuario\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessLoginUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/login\"))\n            .andExpect(status().isUnauthorized());\n    }\n    /**\n     * Prueba de logout sin usuario\n     * @throws Throwable \n     */\n    @Test\n    public void accessLogoutNoUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/logout\"))\n            .andExpect(status().isUnauthorized());;\n    }\n    /**\n     * Prueba de logout con usuario\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessLogoutUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/logout\"))\n            .andExpect(status().is3xxRedirection())\n            .andExpect(redirectedUrl(\"/\"));\n    }\n    /**\n     * Prueba de registro sin usuario\n     * @throws Throwable \n     */\n    @Test\n    public void accessRegisterNoUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/register\"))\n            .andExpect(status().isOk())\n            .andExpect(view().name(\"user/register\"));\n    }\n    /**\n     * Prueba de registro con usuario\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessRegisterUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/register\"))\n            .andExpect(status().isUnauthorized());\n    }\n    /**\n     * Registro sin usuario.\n     * @throws Throwable \n     */\n    @Test\n    public void accessRegisterPostOk() throws Throwable\n    {\n        mvc\n            .perform(post(\"/user/register\")\n                .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n                .with(csrf())\n                .param(\"email\", \"test2@test.com\")\n                .param(\"emailRepeat\", \"test2@test.com\")\n                .param(\"nickname\", \"testing\")\n            )\n            .andExpect(status().is3xxRedirection())\n            .andExpect(redirectedUrl(\"/\"))\n            .andExpect(model().hasNoErrors());\n    }\n    /**\n     * Registro con usuario.\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessRegisterPostUser() throws Throwable\n    {\n        mvc\n            .perform(post(\"/user/register\")\n                .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n                .with(csrf())\n            )\n            .andExpect(status().isUnauthorized());\n    }\n    /**\n     * Registro sin csrf.\n     * @throws Throwable \n     */\n    @Test\n    public void accessRegisterPostNoCsrf() throws Throwable\n    {\n        mvc\n            .perform(post(\"/user/register\")\n                .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n            )\n            .andExpect(status().isForbidden());\n    }\n    /**\n     * Prueba de activar la cuenta sin usuario\n     * @throws Throwable \n     */\n    @Test\n    public void accessAccountActivateNoUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/?k=UKEYTEST\"))\n            .andExpect(status().is3xxRedirection())\n            .andExpect(redirectedUrl(\"/\"));\n    }\n    /**\n     * Prueba de activar la cuenta con usuario\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessAccountActivateUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/?k=UKEYTEST\"))\n            .andExpect(status().isUnauthorized());\n    }\n    /**\n     * Prueba de recuperar sin usuario\n     * @throws Throwable \n     */\n    @Test\n    public void accessRecoverNoUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/recover?k=UKEYTEST\"))\n            .andExpect(status().is3xxRedirection())\n            .andExpect(redirectedUrl(\"/user/profile/password\"));\n    }\n    /**\n     * Prueba de recuperar sin usuario pero UKEY incorrecta\n     * @throws Throwable \n     */\n    @Test\n    public void accessRecoverNoUserNone() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/recover?k=UKEYNONE\"))\n            .andExpect(status().isNotFound());\n    }\n    /**\n     * Prueba de recuperar con usuario\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessRecoverUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/recover?k=UKEYNONE\"))\n            .andExpect(status().isUnauthorized());\n    }\n    /**\n     * Prueba de Contrase\u00f1a olvidada sin usuario\n     * @throws Throwable \n     */\n    @Test\n    public void accessForgotNoUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/forgot\"))\n            .andExpect(status().isOk())\n            .andExpect(view().name(\"user/forgot\"));\n    }\n    /**\n     * Prueba de Contrase\u00f1a olvidada con usuario\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessForgotUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/forgot\"))\n            .andExpect(status().isUnauthorized());\n    }\n    /**\n     * Recuperar contrase\u00f1a sin usuario.\n     * @throws Throwable \n     */\n    @Test\n    public void accessForgotPostOk() throws Throwable\n    {\n        mvc\n            .perform(post(\"/user/forgot\")\n                .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n                .with(csrf())\n                .param(\"email\", \"admin@test.com\")\n            )\n            .andExpect(status().is3xxRedirection())\n            .andExpect(redirectedUrl(\"/\"))\n            .andExpect(model().hasNoErrors());\n    }\n    /**\n     * Recuperar contrase\u00f1a con usuario.\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessForgotPostUser() throws Throwable\n    {\n        mvc\n            .perform(post(\"/user/forgot\")\n                .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n                .with(csrf())\n            )\n            .andExpect(status().isUnauthorized());\n    }\n    /**\n     * Recuperar contrase\u00f1a sin csrf.\n     * @throws Throwable \n     */\n    @Test\n    public void accessForgotPostNoCsrf() throws Throwable\n    {\n        mvc\n            .perform(post(\"/user/forgot\")\n                .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n            )\n            .andExpect(status().isForbidden());\n    }\n    /**\n     * Prueba de Acceso al perfil sin usuario\n     * @throws Throwable \n     */\n    @Test\n    public void accessProfileNoUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/profile\"))\n            .andExpect(status().isUnauthorized());\n    }\n    /**\n     * Prueba de Acceso al perfil con usuario\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessProfileUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/profile\"))\n            .andExpect(status().isOk())\n            .andExpect(view().name(\"user/profile\"));\n    }\n    /**\n     * Perfil sin usuario.\n     * @throws Throwable \n     */\n    @Test\n    public void accessProfilePostNoUser() throws Throwable\n    {\n        mvc\n            .perform(post(\"/user/profile\")\n                .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n                .with(csrf())\n            )\n            .andExpect(status().isUnauthorized());\n    }\n    /**\n     * Perfil con usuario.\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessProfilePostOk() throws Throwable\n    {\n        mvc\n            .perform(post(\"/user/profile\")\n                .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n                .with(csrf())\n                .param(\"id\", \"1\")\n                .param(\"nickname\", \"testing\")\n                .param(\"avatar\", \"test\")\n            )\n            .andExpect(status().is3xxRedirection())\n            .andExpect(redirectedUrl(\"/user/profile\"))\n            .andExpect(model().hasNoErrors());\n    }\n    /**\n     * Perfil sin csrf.\n     * @throws Throwable \n     */\n    @Test\n        public void accessProfilePostNoCsrf() throws Throwable\n    {\n        mvc\n            .perform(post(\"/user/profile\")\n                .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n            )\n            .andExpect(status().isForbidden());\n    }\n    /**\n     * Prueba de Acceso al perfil - contrase\u00f1a sin usuario\n     * @throws Throwable \n     */\n    @Test\n    public void accessProfilePasswordNoUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/profile/password\"))\n            .andExpect(status().isUnauthorized());\n    }\n    /**\n     * Prueba de Acceso al perfil - contrase\u00f1a con usuario\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessProfilePasswordUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/profile/password\"))\n            .andExpect(status().isOk())\n            .andExpect(view().name(\"user/password\"));\n    }\n    /**\n     * Recuperar contrase\u00f1a sin usuario.\n     * @throws Throwable \n     */\n    @Test\n    public void accessProfilePasswordPostNoUser() throws Throwable\n    {\n        mvc\n            .perform(post(\"/user/profile/password\")\n                .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n                .with(csrf())\n            )\n            .andExpect(status().isUnauthorized());\n    }\n    /**\n     * Recuperar contrase\u00f1a con usuario.\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessProfilePasswordPostOk() throws Throwable\n    {\n        mvc\n            .perform(post(\"/user/profile/password\")\n                .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n                .with(csrf())\n                .param(\"id\", \"1\")\n                .param(\"password\", \"PASSWORD\")\n                .param(\"passwordRepeat\", \"PASSWORD\")\n            )\n            .andExpect(status().is3xxRedirection())\n            .andExpect(redirectedUrl(\"/user/profile\"))\n            .andExpect(model().hasNoErrors());\n    }\n    /**\n     * Perfil sin csrf.\n     * @throws Throwable \n     */\n    @Test\n        public void accessProfilePasswordPostNoCsrf() throws Throwable\n    {\n        mvc\n            .perform(post(\"/user/profile/password\")\n                .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n            )\n            .andExpect(status().isForbidden());\n    }\n    /**\n     * Prueba de Acceso a los avatares - contrase\u00f1a sin usuario\n     * @throws Throwable \n     */\n    @Test\n    public void accessAvatarsNoUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/avatars?field=test\"))\n            .andExpect(status().isUnauthorized());\n    }\n    /**\n     * Prueba de Acceso a los avatares - contrase\u00f1a con usuario\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessAvatarsUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/avatars?field=test\"))\n            .andExpect(status().isOk())\n            .andExpect(view().name(\"user/avatars\"));\n    }\n}", "class_id": 0, "repo": "grenhaz/springboot-web", "file": "src/test/java/org/obarcia/springboot/UserControllerTest.java", "last_update_at": "2019-09-13T17:36:22+00:00", "question_id": "0090665434bd1deaf7c0780958851f5dd53cac27", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(SpringRunner.class)\n@SpringBootTest(classes = SpringbootApplication.class)\n@AutoConfigureMockMvc\n@TestPropertySource(locations = \"classpath:application-test.properties\")\npublic class UserControllerTest\n{\n    /**\n     * Control de los E-mail.\n     */\n    @MockBean\n    public JavaMailSender emailSender;\n    /**\n     * Repositorio de usuarios.\n     */\n    @MockBean\n    public UserRepository userRepository;\n    /**\n     * MVC de pruebas.\n     */\n    @Autowired\n    private MockMvc mvc;\n    /**\n     * Instancia del Contexto del servlet.\n     */\n    @Autowired\n    ServletContext servletContext;\n    /**\n     * Instancia del servicio de emails\n     */\n    @Autowired\n    private MailService mailService;\n    /**\n     * Instancia del servicio i18n\n     */\n    @Autowired\n    private MessageSource messageSource;\n    /**\n     * Instancia del servicio de usuarios.\n     */\n    @Autowired\n    private UserService userService;\n    /**\n     * Instancia del servicio de art\u00edculos.\n     */\n    @Autowired\n    private ArticleService articleService;\n    /**\n     * Instancia del servicio de login.\n     */\n    @Autowired\n    private UserAccessService userDetailsService;\n    /**\n     * Instancia del servicio de explorador de archivos.\n     */\n    @Autowired\n    private BrowserService browserService;\n    /**\n     * Setup del test.\n     * \n     * @throws Exception \n     */\n    @Before\n    public void setUp() throws Exception\n    {\n        // E-MAIL\n        Mockito.when(emailSender.createMimeMessage()).thenReturn(new MimeMessage((Session)null));\n        // Usuario\n        User user = new User();\n        user.setId(1);\n        user.setEmail(\"admin@test.com\");\n        user.setNickname(\"admin\");\n        user.setActive(Boolean.TRUE);\n        user.setUserRole(\"ROLE_USER\");\n        user.setUkey(\"UKEYTEST\");\n        user.setPassword(\"PASSWORD\");\n        // Repositorios\n        // Usuarios\n        Mockito.when(userRepository.findByNickname(Mockito.eq(user.getNickname()))).thenReturn(user);\n        Mockito.when(userRepository.findByNickname(Mockito.eq(\"testing\"))).thenReturn(null);\n        Mockito.when(userRepository.findByEmail(Mockito.eq(user.getEmail()))).thenReturn(user);\n        Mockito.when(userRepository.findByUkey(Mockito.eq(user.getUkey()))).thenReturn(user);\n        Mockito.when(userRepository.findByUkey(Mockito.eq(\"UKEYNONE\"))).thenReturn(null);\n        Mockito.when(userRepository.findById(Mockito.eq(1))).thenReturn(Optional.of(user));\n        Mockito.when(userRepository.save((User) argThat(hasProperty(\"id\", is(1))))).thenReturn(user);\n    }\n    /**\n     * Contexto.\n     * @throws Exception \n     */\n    @Test\n    public void contextLoads() throws Exception\n    {\n        assertThat(servletContext).isNotNull();\n        assertThat(mailService).isNotNull();\n        assertThat(messageSource).isNotNull();\n        assertThat(userService).isNotNull();\n        assertThat(articleService).isNotNull();\n        assertThat(userDetailsService).isNotNull();\n        assertThat(browserService).isNotNull();\n    }\n    /**\n     * Prueba de login sin usuario\n     * @throws Throwable \n     */\n    @Test\n    public void accessLoginNoUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/login\"))\n            .andExpect(status().isOk())\n            .andExpect(view().name(\"user/login\"));\n    }\n    /**\n     * Prueba de login con usuario\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessLoginUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/login\"))\n            .andExpect(status().isUnauthorized());\n    }\n    /**\n     * Prueba de logout sin usuario\n     * @throws Throwable \n     */\n    @Test\n    public void accessLogoutNoUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/logout\"))\n            .andExpect(status().isUnauthorized());;\n    }\n    /**\n     * Prueba de logout con usuario\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessLogoutUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/logout\"))\n            .andExpect(status().is3xxRedirection())\n            .andExpect(redirectedUrl(\"/\"));\n    }\n    /**\n     * Prueba de registro sin usuario\n     * @throws Throwable \n     */\n    @Test\n    public void accessRegisterNoUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/register\"))\n            .andExpect(status().isOk())\n            .andExpect(view().name(\"user/register\"));\n    }\n    /**\n     * Prueba de registro con usuario\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessRegisterUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/register\"))\n            .andExpect(status().isUnauthorized());\n    }\n    /**\n     * Registro sin usuario.\n     * @throws Throwable \n     */\n    @Test\n    public void accessRegisterPostOk() throws Throwable\n    {\n        mvc\n            .perform(post(\"/user/register\")\n                .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n                .with(csrf())\n                .param(\"email\", \"test2@test.com\")\n                .param(\"emailRepeat\", \"test2@test.com\")\n                .param(\"nickname\", \"testing\")\n            )\n            .andExpect(status().is3xxRedirection())\n            .andExpect(redirectedUrl(\"/\"))\n            .andExpect(model().hasNoErrors());\n    }\n    /**\n     * Registro con usuario.\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessRegisterPostUser() throws Throwable\n    {\n        mvc\n            .perform(post(\"/user/register\")\n                .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n                .with(csrf())\n            )\n            .andExpect(status().isUnauthorized());\n    }\n    /**\n     * Registro sin csrf.\n     * @throws Throwable \n     */\n    @Test\n    public void accessRegisterPostNoCsrf() throws Throwable\n    {\n        mvc\n            .perform(post(\"/user/register\")\n                .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n            )\n            .andExpect(status().isForbidden());\n    }\n    /**\n     * Prueba de activar la cuenta sin usuario\n     * @throws Throwable \n     */\n    @Test\n    public void accessAccountActivateNoUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/?k=UKEYTEST\"))\n            .andExpect(status().is3xxRedirection())\n            .andExpect(redirectedUrl(\"/\"));\n    }\n    /**\n     * Prueba de activar la cuenta con usuario\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessAccountActivateUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/?k=UKEYTEST\"))\n            .andExpect(status().isUnauthorized());\n    }\n    /**\n     * Prueba de recuperar sin usuario\n     * @throws Throwable \n     */\n    @Test\n    public void accessRecoverNoUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/recover?k=UKEYTEST\"))\n            .andExpect(status().is3xxRedirection())\n            .andExpect(redirectedUrl(\"/user/profile/password\"));\n    }\n    /**\n     * Prueba de recuperar sin usuario pero UKEY incorrecta\n     * @throws Throwable \n     */\n    @Test\n    public void accessRecoverNoUserNone() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/recover?k=UKEYNONE\"))\n            .andExpect(status().isNotFound());\n    }\n    /**\n     * Prueba de recuperar con usuario\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessRecoverUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/recover?k=UKEYNONE\"))\n            .andExpect(status().isUnauthorized());\n    }\n    /**\n     * Prueba de Contrase\u00f1a olvidada sin usuario\n     * @throws Throwable \n     */\n    @Test\n    public void accessForgotNoUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/forgot\"))\n            .andExpect(status().isOk())\n            .andExpect(view().name(\"user/forgot\"));\n    }\n    /**\n     * Prueba de Contrase\u00f1a olvidada con usuario\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessForgotUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/forgot\"))\n            .andExpect(status().isUnauthorized());\n    }\n    /**\n     * Recuperar contrase\u00f1a sin usuario.\n     * @throws Throwable \n     */\n    @Test\n    public void accessForgotPostOk() throws Throwable\n    {\n        mvc\n            .perform(post(\"/user/forgot\")\n                .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n                .with(csrf())\n                .param(\"email\", \"admin@test.com\")\n            )\n            .andExpect(status().is3xxRedirection())\n            .andExpect(redirectedUrl(\"/\"))\n            .andExpect(model().hasNoErrors());\n    }\n    /**\n     * Recuperar contrase\u00f1a con usuario.\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessForgotPostUser() throws Throwable\n    {\n        mvc\n            .perform(post(\"/user/forgot\")\n                .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n                .with(csrf())\n            )\n            .andExpect(status().isUnauthorized());\n    }\n    /**\n     * Recuperar contrase\u00f1a sin csrf.\n     * @throws Throwable \n     */\n    @Test\n    public void accessForgotPostNoCsrf() throws Throwable\n    {\n        mvc\n            .perform(post(\"/user/forgot\")\n                .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n            )\n            .andExpect(status().isForbidden());\n    }\n    /**\n     * Prueba de Acceso al perfil sin usuario\n     * @throws Throwable \n     */\n    @Test\n    public void accessProfileNoUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/profile\"))\n            .andExpect(status().isUnauthorized());\n    }\n    /**\n     * Prueba de Acceso al perfil con usuario\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessProfileUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/profile\"))\n            .andExpect(status().isOk())\n            .andExpect(view().name(\"user/profile\"));\n    }\n    /**\n     * Perfil sin usuario.\n     * @throws Throwable \n     */\n    @Test\n    public void accessProfilePostNoUser() throws Throwable\n    {\n        mvc\n            .perform(post(\"/user/profile\")\n                .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n                .with(csrf())\n            )\n            .andExpect(status().isUnauthorized());\n    }\n    /**\n     * Perfil con usuario.\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessProfilePostOk() throws Throwable\n    {\n        mvc\n            .perform(post(\"/user/profile\")\n                .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n                .with(csrf())\n                .param(\"id\", \"1\")\n                .param(\"nickname\", \"testing\")\n                .param(\"avatar\", \"test\")\n            )\n            .andExpect(status().is3xxRedirection())\n            .andExpect(redirectedUrl(\"/user/profile\"))\n            .andExpect(model().hasNoErrors());\n    }\n    /**\n     * Perfil sin csrf.\n     * @throws Throwable \n     */\n    @Test\n        public void accessProfilePostNoCsrf() throws Throwable\n    {\n        mvc\n            .perform(post(\"/user/profile\")\n                .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n            )\n            .andExpect(status().isForbidden());\n    }\n    /**\n     * Prueba de Acceso al perfil - contrase\u00f1a sin usuario\n     * @throws Throwable \n     */\n    @Test\n    public void accessProfilePasswordNoUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/profile/password\"))\n            .andExpect(status().isUnauthorized());\n    }\n    /**\n     * Prueba de Acceso al perfil - contrase\u00f1a con usuario\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessProfilePasswordUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/profile/password\"))\n            .andExpect(status().isOk())\n            .andExpect(view().name(\"user/password\"));\n    }\n    /**\n     * Recuperar contrase\u00f1a sin usuario.\n     * @throws Throwable \n     */\n    @Test\n    public void accessProfilePasswordPostNoUser() throws Throwable\n    {\n        mvc\n            .perform(post(\"/user/profile/password\")\n                .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n                .with(csrf())\n            )\n            .andExpect(status().isUnauthorized());\n    }\n    /**\n     * Recuperar contrase\u00f1a con usuario.\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessProfilePasswordPostOk() throws Throwable\n    {\n        mvc\n            .perform(post(\"/user/profile/password\")\n                .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n                .with(csrf())\n                .param(\"id\", \"1\")\n                .param(\"password\", \"PASSWORD\")\n                .param(\"passwordRepeat\", \"PASSWORD\")\n            )\n            .andExpect(status().is3xxRedirection())\n            .andExpect(redirectedUrl(\"/user/profile\"))\n            .andExpect(model().hasNoErrors());\n    }\n    /**\n     * Perfil sin csrf.\n     * @throws Throwable \n     */\n    @Test\n        public void accessProfilePasswordPostNoCsrf() throws Throwable\n    {\n        mvc\n            .perform(post(\"/user/profile/password\")\n                .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n            )\n            .andExpect(status().isForbidden());\n    }\n    /**\n     * Prueba de Acceso a los avatares - contrase\u00f1a sin usuario\n     * @throws Throwable \n     */\n    @Test\n    public void accessAvatarsNoUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/avatars?field=test\"))\n            .andExpect(status().isUnauthorized());\n    }\n    /**\n     * Prueba de Acceso a los avatares - contrase\u00f1a con usuario\n     * @throws Throwable \n     */\n    @Test\n    @WithMockUser(username = \"admin@test.com\", roles = {\"USER\"})\n    public void accessAvatarsUser() throws Throwable\n    {\n        mvc\n            .perform(get(\"/user/avatars?field=test\"))\n            .andExpect(status().isOk())\n            .andExpect(view().name(\"user/avatars\"));\n    }\n"]]}
{"hexsha": "f2f59e7d252719a8869e8b418bd7f91ef37dc5de", "ext": "java", "lang": "Java", "content": "public class TestUtil {\n\n\n\tpublic static void main(String[] args) {\n\t\tApplicationContext ctx = new FileSystemXmlApplicationContext(\n\t\t\t\tnew String[] { \"src/applicationContext_jndi.xml\",\n\t\t\t\t\t\t\"src/applicationContext_dao.xml\" });\n\t\tResourceDAO dao = (ResourceDAO) ctx.getBean(\"resourceDAO\");\n\t\t\n\t\tHysResources u = new HysResources();\n\t\tu.setName(\"aaa\");\n\t\tu.setType(1);\n\t\tu.setValue(\"usdfs\");\n\t\t\n\t\tdao.save(u);\n\t\t\n\t\t\n\t\t\n//\t\tList list = new ArrayList();\n//\t\tlist.add(1);\n//\t\tlist.add(2);\n//\t\tlist.add(3);\n//\t\tlist.add(4);\n//\t\tlist.add(5);\n//\t\tSystem.out.println(org.apache.commons.lang.StringUtils.join(list.iterator(), \",\"));\n\t\t\n\t\t\n\n\t}\n\n}", "class_id": 0, "repo": "1224500506/NCME-Admin", "file": "auth/com/hys/auth/util/TestUtil.java", "last_update_at": "2019-09-04T00:57:27+00:00", "question_id": "f2f59e7d252719a8869e8b418bd7f91ef37dc5de", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestUtil {\n\tpublic static void main(String[] args) {\n\t\tApplicationContext ctx = new FileSystemXmlApplicationContext(\n\t\t\t\tnew String[] { \"src/applicationContext_jndi.xml\",\n\t\t\t\t\t\t\"src/applicationContext_dao.xml\" });\n\t\tResourceDAO dao = (ResourceDAO) ctx.getBean(\"resourceDAO\");\n\t\t\n\t\tHysResources u = new HysResources();\n\t\tu.setName(\"aaa\");\n\t\tu.setType(1);\n\t\tu.setValue(\"usdfs\");\n\t\t\n\t\tdao.save(u);\n\t\t\n\t\t\n\t\t\n//\t\tList list = new ArrayList();\n//\t\tlist.add(1);\n//\t\tlist.add(2);\n//\t\tlist.add(3);\n//\t\tlist.add(4);\n//\t\tlist.add(5);\n//\t\tSystem.out.println(org.apache.commons.lang.StringUtils.join(list.iterator(), \",\"));\n\t\t\n\t\t\n\t}\n"]]}
{"hexsha": "86c3088cd2b3473c5bff37b0e5aff318267547bb", "ext": "java", "lang": "Java", "content": "public class OutsetHandler extends ItemStackHandler\n{\n\tItemStack[] ghostStacks;\n\tpublic OutsetHandler()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic OutsetHandler( int size )\n\t{\n\t\tsuper( size );\n\t\tghostStacks = new ItemStack[size];\n\t}\n\n\tpublic OutsetHandler( ItemStack[] stacks )\n\t{\n\t\tsuper( stacks );\n\t\tghostStacks = new ItemStack[stacks.length];\n\t}\n\n    public void setSize(int size)\n    {\n    \tsuper.setSize( size );\n    \tghostStacks = new ItemStack[size];\n    }\n\n\tpublic void setStackGhosted(int slot, ItemStack stack)\n    {\n        validateSlotIndex(slot);\n        if (ItemStack.matches(this.ghostStacks[slot], stack))\n            return;\n        this.ghostStacks[slot] = stack;\n    }\n}", "class_id": 0, "repo": "TehStoneMan/BetterStorageToo", "file": "old_src/main/java/net/mcft/copy/betterstorage/misc/handlers/OutputStackHandler.java", "last_update_at": "2019-02-28T17:13:04+00:00", "question_id": "86c3088cd2b3473c5bff37b0e5aff318267547bb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OutsetHandler extends ItemStackHandler\n{\n\tItemStack[] ghostStacks;\n\tpublic OutsetHandler()\n\t{\n\t\tsuper();\n\t}\n\tpublic OutsetHandler( int size )\n\t{\n\t\tsuper( size );\n\t\tghostStacks = new ItemStack[size];\n\t}\n\tpublic OutsetHandler( ItemStack[] stacks )\n\t{\n\t\tsuper( stacks );\n\t\tghostStacks = new ItemStack[stacks.length];\n\t}\n    public void setSize(int size)\n    {\n    \tsuper.setSize( size );\n    \tghostStacks = new ItemStack[size];\n    }\n\tpublic void setStackGhosted(int slot, ItemStack stack)\n    {\n        validateSlotIndex(slot);\n        if (ItemStack.matches(this.ghostStacks[slot], stack))\n            return;\n        this.ghostStacks[slot] = stack;\n    }\n"]]}
{"hexsha": "2e3f7f9cefefad929e844fa48cbfeab1b5cb9526", "ext": "java", "lang": "Java", "content": "public class HelloWorld\r\n{\r\n    public static void main(String[] args) throws Exception\r\n    {\r\n        // The path to the documents directory.\r\n        String dataDir = \"src/quickstart/helloworld/data/\";\r\n        // Create a blank document.\r\n        Document doc = new Document();\r\n        // DocumentBuilder provides members to easily add content to a document.\r\n        DocumentBuilder builder = new DocumentBuilder(doc);\r\n        // Write a new paragraph in the document with the text \"Hello World!\"\r\n        builder.writeln(\"Hello World!\");\r\n        // Save the document in DOCX format. The format to save as is inferred from the extension of the file name.\r\n        // Aspose.Words supports saving any document in many more formats.\r\n        doc.save(dataDir + \"HelloWorld Out.docx\");\r\n    }\r\n}", "class_id": 0, "repo": "asposemarketplace/Aspose-Words-Java", "file": "src/quickstart/helloworld/java/HelloWorld.java", "last_update_at": "2019-05-24T01:11:29+00:00", "question_id": "2e3f7f9cefefad929e844fa48cbfeab1b5cb9526", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HelloWorld\r\n{\r\n    public static void main(String[] args) throws Exception\r\n    {\r\n        // The path to the documents directory.\r\n        String dataDir = \"src/quickstart/helloworld/data/\";\r\n        // Create a blank document.\r\n        Document doc = new Document();\r\n        // DocumentBuilder provides members to easily add content to a document.\r\n        DocumentBuilder builder = new DocumentBuilder(doc);\r\n        // Write a new paragraph in the document with the text \"Hello World!\"\r\n        builder.writeln(\"Hello World!\");\r\n        // Save the document in DOCX format. The format to save as is inferred from the extension of the file name.\r\n        // Aspose.Words supports saving any document in many more formats.\r\n        doc.save(dataDir + \"HelloWorld Out.docx\");\r\n    }\r\n"]]}
{"hexsha": "bbfccaf5417cb8b937ed914d8979873e8f65491c", "ext": "java", "lang": "Java", "content": "public class PinCommandTest {\n    private Model testModelNoPinned = new ModelManager(\n            getTypicalSourceManager(),\n            new UserPrefs(),\n            getTypicalDeletedSources(),\n            0);\n    private Model testModelWithPinned = new ModelManager(\n            getTypicalSourceManager(),\n            new UserPrefs(),\n            getTypicalDeletedSources(),\n            2);\n    private Model testModelWithMaxPinned = new ModelManager(\n            getTypicalSourceManager(),\n            new UserPrefs(),\n            getTypicalDeletedSources(),\n            PinCommand.PINNED_LIMIT);\n    private CommandHistory commandHistory = new CommandHistory();\n\n    @Test\n    public void execute_basicOperationPinSource_success() {\n        int targetIndex = 2;\n\n        Model expectedModel = new ModelManager(\n                testModelNoPinned.getSourceManager(),\n                new UserPrefs(),\n                testModelNoPinned.getDeletedSources(),\n                0);\n\n        Source sourceToPin = testModelNoPinned.getFilteredSourceList().get(targetIndex - 1);\n        expectedModel.deleteSource(sourceToPin);\n        expectedModel.addSourceAtIndex(sourceToPin, 0);\n\n        PinnedSourcesCoordinationCenter.incrementPinnedSources(expectedModel);\n\n        String expectedMessage = String.format(PinCommand.MESSAGE_SUCCESS, sourceToPin);\n\n        assertCommandSuccess(\n                new PinCommand(targetIndex),\n                testModelNoPinned,\n                commandHistory,\n                expectedMessage,\n                expectedModel);\n    }\n\n    @Test\n    public void execute_pinAlreadyPinnedSource_failure() {\n        int targetIndex = 1;\n\n        String expectedMessage = PinCommand.MESSAGE_SOURCE_PINNED_INVALID;\n\n        assertCommandFailure(\n                new PinCommand(targetIndex),\n                testModelWithPinned,\n                commandHistory,\n                expectedMessage);\n    }\n\n    @Test\n    public void execute_inputIndexZero_failure() {\n        int targetIndex = 0;\n\n        String expectedMessage = PinCommand.MESSAGE_SOURCE_INDEX_INVALID;\n\n        assertCommandFailure(\n                new PinCommand(targetIndex),\n                testModelWithPinned,\n                commandHistory,\n                expectedMessage);\n    }\n\n    @Test\n    public void execute_inputIndexOutOfBounds_failure() {\n        int targetIndex = testModelWithPinned.getFilteredSourceList().size() + 1;\n\n        String expectedMessage = PinCommand.MESSAGE_SOURCE_INDEX_INVALID;\n\n        assertCommandFailure(\n                new PinCommand(targetIndex),\n                testModelWithPinned,\n                commandHistory,\n                expectedMessage);\n    }\n\n    @Test\n    public void execute_exceedMaxPinnedSources_failure() {\n        int targetIndex = PinCommand.PINNED_LIMIT + 1;\n\n        String expectedMessage = PinCommand.MESSAGE_MAX_PINNED_INVALID;\n\n        assertCommandFailure(\n                new PinCommand(targetIndex),\n                testModelWithMaxPinned,\n                commandHistory,\n                expectedMessage);\n    }\n}", "class_id": 0, "repo": "suriruhani/main", "file": "src/test/java/seedu/address/logic/commands/PinCommandTest.java", "last_update_at": "2019-04-13T10:53:56+00:00", "question_id": "bbfccaf5417cb8b937ed914d8979873e8f65491c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PinCommandTest {\n    private Model testModelNoPinned = new ModelManager(\n            getTypicalSourceManager(),\n            new UserPrefs(),\n            getTypicalDeletedSources(),\n            0);\n    private Model testModelWithPinned = new ModelManager(\n            getTypicalSourceManager(),\n            new UserPrefs(),\n            getTypicalDeletedSources(),\n            2);\n    private Model testModelWithMaxPinned = new ModelManager(\n            getTypicalSourceManager(),\n            new UserPrefs(),\n            getTypicalDeletedSources(),\n            PinCommand.PINNED_LIMIT);\n    private CommandHistory commandHistory = new CommandHistory();\n    @Test\n    public void execute_basicOperationPinSource_success() {\n        int targetIndex = 2;\n        Model expectedModel = new ModelManager(\n                testModelNoPinned.getSourceManager(),\n                new UserPrefs(),\n                testModelNoPinned.getDeletedSources(),\n                0);\n        Source sourceToPin = testModelNoPinned.getFilteredSourceList().get(targetIndex - 1);\n        expectedModel.deleteSource(sourceToPin);\n        expectedModel.addSourceAtIndex(sourceToPin, 0);\n        PinnedSourcesCoordinationCenter.incrementPinnedSources(expectedModel);\n        String expectedMessage = String.format(PinCommand.MESSAGE_SUCCESS, sourceToPin);\n        assertCommandSuccess(\n                new PinCommand(targetIndex),\n                testModelNoPinned,\n                commandHistory,\n                expectedMessage,\n                expectedModel);\n    }\n    @Test\n    public void execute_pinAlreadyPinnedSource_failure() {\n        int targetIndex = 1;\n        String expectedMessage = PinCommand.MESSAGE_SOURCE_PINNED_INVALID;\n        assertCommandFailure(\n                new PinCommand(targetIndex),\n                testModelWithPinned,\n                commandHistory,\n                expectedMessage);\n    }\n    @Test\n    public void execute_inputIndexZero_failure() {\n        int targetIndex = 0;\n        String expectedMessage = PinCommand.MESSAGE_SOURCE_INDEX_INVALID;\n        assertCommandFailure(\n                new PinCommand(targetIndex),\n                testModelWithPinned,\n                commandHistory,\n                expectedMessage);\n    }\n    @Test\n    public void execute_inputIndexOutOfBounds_failure() {\n        int targetIndex = testModelWithPinned.getFilteredSourceList().size() + 1;\n        String expectedMessage = PinCommand.MESSAGE_SOURCE_INDEX_INVALID;\n        assertCommandFailure(\n                new PinCommand(targetIndex),\n                testModelWithPinned,\n                commandHistory,\n                expectedMessage);\n    }\n    @Test\n    public void execute_exceedMaxPinnedSources_failure() {\n        int targetIndex = PinCommand.PINNED_LIMIT + 1;\n        String expectedMessage = PinCommand.MESSAGE_MAX_PINNED_INVALID;\n        assertCommandFailure(\n                new PinCommand(targetIndex),\n                testModelWithMaxPinned,\n                commandHistory,\n                expectedMessage);\n    }\n"]]}
{"hexsha": "77a6eca34a3c83b9075c359c5223261f562baeee", "ext": "java", "lang": "Java", "content": "public class Cache\n{\n    private final Logger LOG= LoggerFactory.getLogger(Cache.class);\n    private static final long DECAY = TimeUnit.SECONDS.toMillis(30);\n    private final Map<CacheEntry, Object> cacheMap = new HashMap<>();\n    private final Map<CacheEntry, Supplier<Object>> getterMap = new HashMap<>();\n\n    {\n        LOG.info(\"Creating a new cache\");\n    }\n    public void registerSupplier(String key, Supplier<Object> function)\n    {\n        getterMap.put(new CacheEntry(key, -1), function);\n    }\n\n    public <T> T get(String key)\n    {\n        for (Map.Entry<CacheEntry, Object> entry : cacheMap.entrySet())\n        {\n            if (entry.getKey().getKey().equals(key))\n            {\n                long time = entry.getKey().getCreated();\n                if (time + DECAY < System.currentTimeMillis())\n                {\n                    if (!getterMap.containsKey(entry.getKey()))\n                    {\n                        return null;\n                    }\n                    LOG.info(\"Recalculating the value for {}\",key);\n                    Object val = getterMap.get(entry.getKey()).get();\n                    CacheEntry newEntry = new CacheEntry(key,\n                            System.currentTimeMillis());\n                    cacheMap.put(newEntry, val);\n                    return (T) val;\n                } else\n                {\n                    LOG.info(\"Retrieving cached value for {}\",key);\n                    return (T) entry.getValue();\n                }\n            }\n        }\n        CacheEntry keyEntry = new CacheEntry(key, DECAY);\n        if (!getterMap.containsKey(keyEntry))\n        {\n            LOG.info(\"No information of values found for {}\",key);\n            return null;\n        }\n        LOG.info(\"Calculating the value for {}\",key);\n        Object val = getterMap.get(keyEntry).get();\n        CacheEntry newEntry = new CacheEntry(key, System.currentTimeMillis());\n        cacheMap.put(newEntry, val);\n        return (T) val;\n    }\n\n    private static class CacheEntry\n    {\n\n        private final String key;\n        private final long created;\n\n        public CacheEntry(String key, long created)\n        {\n            this.key = key;\n            this.created = created;\n        }\n\n        public long getCreated()\n        {\n            return created;\n        }\n\n        public String getKey()\n        {\n            return key;\n        }\n\n        @Override\n        public int hashCode()\n        {\n            int hash = 7;\n            hash = 53 * hash + Objects.hashCode(this.key);\n            return hash;\n        }\n\n        @Override\n        public boolean equals(Object obj)\n        {\n            if (this == obj)\n            {\n                return true;\n            }\n            if (obj == null)\n            {\n                return false;\n            }\n            if (getClass() != obj.getClass())\n            {\n                return false;\n            }\n            final CacheEntry other = (CacheEntry) obj;\n            if (!Objects.equals(this.key, other.key))\n            {\n                return false;\n            }\n            return true;\n        }\n\n    }\n\n}", "class_id": 0, "repo": "Clayn/Dentahl", "file": "Dentahl4J/dentahl4j-domain/src/main/java/de/clayntech/dentahl4j/util/Cache.java", "last_update_at": "2019-04-03T18:32:38+00:00", "question_id": "77a6eca34a3c83b9075c359c5223261f562baeee", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Cache\n{\n    private final Logger LOG= LoggerFactory.getLogger(Cache.class);\n    private static final long DECAY = TimeUnit.SECONDS.toMillis(30);\n    private final Map<CacheEntry, Object> cacheMap = new HashMap<>();\n    private final Map<CacheEntry, Supplier<Object>> getterMap = new HashMap<>();\n    {\n        LOG.info(\"Creating a new cache\");\n    }\n    public void registerSupplier(String key, Supplier<Object> function)\n    {\n        getterMap.put(new CacheEntry(key, -1), function);\n    }\n    public <T> T get(String key)\n    {\n        for (Map.Entry<CacheEntry, Object> entry : cacheMap.entrySet())\n        {\n            if (entry.getKey().getKey().equals(key))\n            {\n                long time = entry.getKey().getCreated();\n                if (time + DECAY < System.currentTimeMillis())\n                {\n                    if (!getterMap.containsKey(entry.getKey()))\n                    {\n                        return null;\n                    }\n                    LOG.info(\"Recalculating the value for {}\",key);\n                    Object val = getterMap.get(entry.getKey()).get();\n                    CacheEntry newEntry = new CacheEntry(key,\n                            System.currentTimeMillis());\n                    cacheMap.put(newEntry, val);\n                    return (T) val;\n                } else\n                {\n                    LOG.info(\"Retrieving cached value for {}\",key);\n                    return (T) entry.getValue();\n                }\n            }\n        }\n        CacheEntry keyEntry = new CacheEntry(key, DECAY);\n        if (!getterMap.containsKey(keyEntry))\n        {\n            LOG.info(\"No information of values found for {}\",key);\n            return null;\n        }\n        LOG.info(\"Calculating the value for {}\",key);\n        Object val = getterMap.get(keyEntry).get();\n        CacheEntry newEntry = new CacheEntry(key, System.currentTimeMillis());\n        cacheMap.put(newEntry, val);\n        return (T) val;\n    }\n    private static class CacheEntry\n    {\n        private final String key;\n        private final long created;\n        public CacheEntry(String key, long created)\n        {\n            this.key = key;\n            this.created = created;\n        }\n        public long getCreated()\n        {\n            return created;\n        }\n        public String getKey()\n        {\n            return key;\n        }\n        @Override\n        public int hashCode()\n        {\n            int hash = 7;\n            hash = 53 * hash + Objects.hashCode(this.key);\n            return hash;\n        }\n        @Override\n        public boolean equals(Object obj)\n        {\n            if (this == obj)\n            {\n                return true;\n            }\n            if (obj == null)\n            {\n                return false;\n            }\n            if (getClass() != obj.getClass())\n            {\n                return false;\n            }\n            final CacheEntry other = (CacheEntry) obj;\n            if (!Objects.equals(this.key, other.key))\n            {\n                return false;\n            }\n            return true;\n        }\n    }\n"]]}
{"hexsha": "2d833dc833eddac348d5c214ff30ba3c5d94e2e1", "ext": "java", "lang": "Java", "content": "public class HostessRoleAndPermissions extends AbstractRoleAndPermissionsFixtureScript {\n\n    public static final String ROLE_NAME = \"hostess-role\";\n\n    public HostessRoleAndPermissions() {\n        super(ROLE_NAME, \"Can manage ecpcrm dom, except centers\");\n    }\n\n    @Override\n    protected void execute(final ExecutionContext executionContext) {\n        newPackagePermissions(\n                ApplicationPermissionRule.ALLOW,\n                ApplicationPermissionMode.CHANGING,\n                EcpCrmLoyaltyCardsModule.class.getPackage().getName(),\n                EcpCrmApplicationModule.class.getPackage().getName()\n        );\n        newPackagePermissions(\n                ApplicationPermissionRule.VETO,\n                ApplicationPermissionMode.VIEWING,\n                Center.class.getPackage().getName()\n        );\n        newClassPermissions(\n                ApplicationPermissionRule.VETO,\n                ApplicationPermissionMode.VIEWING,\n                CenterMenu.class\n        );\n        newMemberPermissions(\n                ApplicationPermissionRule.VETO,\n                ApplicationPermissionMode.VIEWING,\n                User.class,\n                \"center\"\n        );\n        newMemberPermissions(\n                ApplicationPermissionRule.VETO,\n                ApplicationPermissionMode.VIEWING,\n                Card.class,\n                \"center\"\n        );\n\n        newPackagePermissions(\n                ApplicationPermissionRule.VETO,\n                ApplicationPermissionMode.VIEWING,\n                AdminMenu.class.getPackage().getName()\n        );\n        newMemberPermissions(\n                ApplicationPermissionRule.VETO,\n                ApplicationPermissionMode.VIEWING,\n                CardMenu.class,\n                \"downloadAllCards\"\n        );\n        newMemberPermissions(\n                ApplicationPermissionRule.VETO,\n                ApplicationPermissionMode.VIEWING,\n                UserMenu.class,\n                \"downloadAllUsers\"\n        );\n    }\n}", "class_id": 0, "repo": "incodehq/ecpcrm", "file": "application/src/main/java/org/incode/eurocommercial/ecpcrm/module/application/fixture/security/roles/HostessRoleAndPermissions.java", "last_update_at": "2019-02-22T12:18:42+00:00", "question_id": "2d833dc833eddac348d5c214ff30ba3c5d94e2e1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HostessRoleAndPermissions extends AbstractRoleAndPermissionsFixtureScript {\n    public static final String ROLE_NAME = \"hostess-role\";\n    public HostessRoleAndPermissions() {\n        super(ROLE_NAME, \"Can manage ecpcrm dom, except centers\");\n    }\n    @Override\n    protected void execute(final ExecutionContext executionContext) {\n        newPackagePermissions(\n                ApplicationPermissionRule.ALLOW,\n                ApplicationPermissionMode.CHANGING,\n                EcpCrmLoyaltyCardsModule.class.getPackage().getName(),\n                EcpCrmApplicationModule.class.getPackage().getName()\n        );\n        newPackagePermissions(\n                ApplicationPermissionRule.VETO,\n                ApplicationPermissionMode.VIEWING,\n                Center.class.getPackage().getName()\n        );\n        newClassPermissions(\n                ApplicationPermissionRule.VETO,\n                ApplicationPermissionMode.VIEWING,\n                CenterMenu.class\n        );\n        newMemberPermissions(\n                ApplicationPermissionRule.VETO,\n                ApplicationPermissionMode.VIEWING,\n                User.class,\n                \"center\"\n        );\n        newMemberPermissions(\n                ApplicationPermissionRule.VETO,\n                ApplicationPermissionMode.VIEWING,\n                Card.class,\n                \"center\"\n        );\n        newPackagePermissions(\n                ApplicationPermissionRule.VETO,\n                ApplicationPermissionMode.VIEWING,\n                AdminMenu.class.getPackage().getName()\n        );\n        newMemberPermissions(\n                ApplicationPermissionRule.VETO,\n                ApplicationPermissionMode.VIEWING,\n                CardMenu.class,\n                \"downloadAllCards\"\n        );\n        newMemberPermissions(\n                ApplicationPermissionRule.VETO,\n                ApplicationPermissionMode.VIEWING,\n                UserMenu.class,\n                \"downloadAllUsers\"\n        );\n    }\n"]]}
{"hexsha": "57b0d23dbeb06e2306f5091c6ab4ba6f93eb9210", "ext": "java", "lang": "Java", "content": "@Controller\n@RequestMapping(path = \"/people\")\n@Secured(\"ROLE_USER\")\n@Slf4j\n@RequiredArgsConstructor\nclass PeopleController {\n\n  private final RestTemplate template;\n\n  @GetMapping\n  public String getAllPeople(Model model) {\n    LOGGER.info(\"GetAllPeople: Authentication={}\", getContext().getAuthentication());\n\n    ResponseEntity<List<Person>> people =\n        template.exchange(\"/\", GET, null, new ParameterizedTypeReference<>() {\n        });\n\n    model.addAttribute(\"people\", people.getBody());\n\n    return \"people\";\n  }\n\n  @GetMapping(path = \"/{id}\")\n  public String getPersonById(@PathVariable UUID id, Model model) {\n    LOGGER.info(\"GetPersonById: Id={}, Authentication={}\", id, getContext().getAuthentication());\n\n    var person = template.getForObject(\"/\" + id.toString(), Person.class);\n\n    model.addAttribute(\"person\", person);\n\n    return \"person\";\n  }\n}", "class_id": 0, "repo": "frank-rahn/guidelines-spring-boot", "file": "guideline-springboot-web/src/main/java/de/rahn/guidelines/springboot/web/ui/people/PeopleController.java", "last_update_at": "2019-12-27T18:12:06+00:00", "question_id": "57b0d23dbeb06e2306f5091c6ab4ba6f93eb9210", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Controller\n@RequestMapping(path = \"/people\")\n@Secured(\"ROLE_USER\")\n@Slf4j\n@RequiredArgsConstructor\nclass PeopleController {\n  private final RestTemplate template;\n  @GetMapping\n  public String getAllPeople(Model model) {\n    LOGGER.info(\"GetAllPeople: Authentication={}\", getContext().getAuthentication());\n    ResponseEntity<List<Person>> people =\n        template.exchange(\"/\", GET, null, new ParameterizedTypeReference<>() {\n        });\n    model.addAttribute(\"people\", people.getBody());\n    return \"people\";\n  }\n  @GetMapping(path = \"/{id}\")\n  public String getPersonById(@PathVariable UUID id, Model model) {\n    LOGGER.info(\"GetPersonById: Id={}, Authentication={}\", id, getContext().getAuthentication());\n    var person = template.getForObject(\"/\" + id.toString(), Person.class);\n    model.addAttribute(\"person\", person);\n    return \"person\";\n  }\n"]]}
{"hexsha": "90f253e2ebebe2f9ca0e7650a6acbed85ab16f77", "ext": "java", "lang": "Java", "content": "public class Rating {\n    public enum RatingEvent implements Audit.ApiAuditEvent {\n        RATING_CREATED, RATING_UPDATED, RATING_DELETED\n    }\n    private String id;\n    private String referenceId;\n    private RatingReferenceType referenceType;\n    private String user;\n    private byte rate;\n    private String title;\n    private String comment;\n    private Date createdAt;\n    private Date updatedAt;\n\n    public Rating() {\n    }\n\n    public Rating(Rating cloned) {\n        this.id = cloned.id;\n        this.user = cloned.user;\n        this.rate = cloned.rate;\n        this.title = cloned.title;\n        this.comment = cloned.comment;\n        this.createdAt = cloned.createdAt;\n        this.updatedAt = cloned.updatedAt;\n        this.referenceId = cloned.referenceId;\n        this.referenceType = cloned.referenceType;\n    }\n\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getUser() {\n        return user;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    public byte getRate() {\n        return rate;\n    }\n\n    public void setRate(byte rate) {\n        this.rate = rate;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    public String getComment() {\n        return comment;\n    }\n\n    public void setComment(String comment) {\n        this.comment = comment;\n    }\n\n    public Date getCreatedAt() {\n        return createdAt;\n    }\n\n    public void setCreatedAt(Date createdAt) {\n        this.createdAt = createdAt;\n    }\n\n    public Date getUpdatedAt() {\n        return updatedAt;\n    }\n\n    public void setUpdatedAt(Date updatedAt) {\n        this.updatedAt = updatedAt;\n    }\n\n    \n    public String getReferenceId() {\n        return referenceId;\n    }\n\n    public void setReferenceId(String referenceId) {\n        this.referenceId = referenceId;\n    }\n\n    public RatingReferenceType getReferenceType() {\n        return referenceType;\n    }\n\n    public void setReferenceType(RatingReferenceType referenceType) {\n        this.referenceType = referenceType;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Rating)) return false;\n        Rating rating = (Rating) o;\n        return Objects.equals(id, rating.id);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id, referenceId, referenceType);\n    }\n\n    @Override\n    public String toString() {\n        return \"Rating{\" +\n                \"id='\" + id + '\\'' +\n                \", referenceId='\" + referenceId + '\\'' +\n                \", referenceType=\" + referenceType +\n                \", user='\" + user + '\\'' +\n                \", rate=\" + rate +\n                \", title='\" + title + '\\'' +\n                \", comment='\" + comment + '\\'' +\n                \", createdAt=\" + createdAt +\n                \", updatedAt=\" + updatedAt +\n                '}';\n    }\n}", "class_id": 0, "repo": "GGui/gravitee-repository", "file": "src/main/java/io/gravitee/repository/management/model/Rating.java", "last_update_at": "2019-09-29T15:27:13+00:00", "question_id": "90f253e2ebebe2f9ca0e7650a6acbed85ab16f77", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Rating {\n    public enum RatingEvent implements Audit.ApiAuditEvent {\n        RATING_CREATED, RATING_UPDATED, RATING_DELETED\n    }\n    private String id;\n    private String referenceId;\n    private RatingReferenceType referenceType;\n    private String user;\n    private byte rate;\n    private String title;\n    private String comment;\n    private Date createdAt;\n    private Date updatedAt;\n    public Rating() {\n    }\n    public Rating(Rating cloned) {\n        this.id = cloned.id;\n        this.user = cloned.user;\n        this.rate = cloned.rate;\n        this.title = cloned.title;\n        this.comment = cloned.comment;\n        this.createdAt = cloned.createdAt;\n        this.updatedAt = cloned.updatedAt;\n        this.referenceId = cloned.referenceId;\n        this.referenceType = cloned.referenceType;\n    }\n    public String getId() {\n        return id;\n    }\n    public void setId(String id) {\n        this.id = id;\n    }\n    public String getUser() {\n        return user;\n    }\n    public void setUser(String user) {\n        this.user = user;\n    }\n    public byte getRate() {\n        return rate;\n    }\n    public void setRate(byte rate) {\n        this.rate = rate;\n    }\n    public String getTitle() {\n        return title;\n    }\n    public void setTitle(String title) {\n        this.title = title;\n    }\n    public String getComment() {\n        return comment;\n    }\n    public void setComment(String comment) {\n        this.comment = comment;\n    }\n    public Date getCreatedAt() {\n        return createdAt;\n    }\n    public void setCreatedAt(Date createdAt) {\n        this.createdAt = createdAt;\n    }\n    public Date getUpdatedAt() {\n        return updatedAt;\n    }\n    public void setUpdatedAt(Date updatedAt) {\n        this.updatedAt = updatedAt;\n    }\n    public String getReferenceId() {\n        return referenceId;\n    }\n    public void setReferenceId(String referenceId) {\n        this.referenceId = referenceId;\n    }\n    public RatingReferenceType getReferenceType() {\n        return referenceType;\n    }\n    public void setReferenceType(RatingReferenceType referenceType) {\n        this.referenceType = referenceType;\n    }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Rating)) return false;\n        Rating rating = (Rating) o;\n        return Objects.equals(id, rating.id);\n    }\n    @Override\n    public int hashCode() {\n        return Objects.hash(id, referenceId, referenceType);\n    }\n    @Override\n    public String toString() {\n        return \"Rating{\" +\n                \"id='\" + id + '\\'' +\n                \", referenceId='\" + referenceId + '\\'' +\n                \", referenceType=\" + referenceType +\n                \", user='\" + user + '\\'' +\n                \", rate=\" + rate +\n                \", title='\" + title + '\\'' +\n                \", comment='\" + comment + '\\'' +\n                \", createdAt=\" + createdAt +\n                \", updatedAt=\" + updatedAt +\n                '}';\n    }\n"]]}
{"hexsha": "bfc8323487cc8b05462c45e2c7c87ca68da330f2", "ext": "java", "lang": "Java", "content": "public class GradleClassFinder extends NonClasspathClassFinder {\n\n  @NotNull private final GradleInstallationManager myLibraryManager;\n\n  public GradleClassFinder(Project project, @NotNull GradleInstallationManager manager) {\n    super(project);\n    myLibraryManager = manager;\n  }\n\n  @Override\n  protected List<VirtualFile> calcClassRoots() {\n    final List<VirtualFile> roots = myLibraryManager.getClassRoots(myProject);\n    if (roots != null) {\n      return roots;\n    }\n    return Collections.emptyList();\n  }\n}", "class_id": 0, "repo": "dmarcotte/intellij-community", "file": "plugins/gradle/src/org/jetbrains/plugins/gradle/config/GradleClassFinder.java", "last_update_at": "2019-03-14T10:35:19+00:00", "question_id": "bfc8323487cc8b05462c45e2c7c87ca68da330f2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GradleClassFinder extends NonClasspathClassFinder {\n  @NotNull private final GradleInstallationManager myLibraryManager;\n  public GradleClassFinder(Project project, @NotNull GradleInstallationManager manager) {\n    super(project);\n    myLibraryManager = manager;\n  }\n  @Override\n  protected List<VirtualFile> calcClassRoots() {\n    final List<VirtualFile> roots = myLibraryManager.getClassRoots(myProject);\n    if (roots != null) {\n      return roots;\n    }\n    return Collections.emptyList();\n  }\n"]]}
{"hexsha": "189f9552921978485e4ef4fa5e5b0fb81850746b", "ext": "java", "lang": "Java", "content": "public class SidebarRenderer {\n\n  public static final String NUTRITION_INFO_NAME = \"Limit Nutrition (per serving)\";\n\n  private static final SearchResult EMPTY_SEARCH_RESULT = new SearchResult.Builder().build();\n  private static final RangedSpec UNSELECTED_RANGE = RangedSpec.of(0, 0);\n  private static final DietSpec UNSELECTED_DIET = DietSpec.of(\"NONE\", 1F);\n\n  private static final FacetData EMPTY_FACET_DATA =\n      new FacetData.Builder().dimension(\"EMPTY\").build();\n\n  public SidebarRenderer() {}\n\n  public SidebarInfo render(SearchQuery query, UriComponentsBuilder uriBuilder) {\n    return render(query, EMPTY_SEARCH_RESULT, uriBuilder);\n  }\n\n  public SidebarInfo render(\n      SearchQuery query, SearchResult result, UriComponentsBuilder uriBuilder) {\n    var builder = new SidebarInfo.Builder();\n\n    var sort = new FilterInfo.Builder().name(Category.SORT.getTitle()).isRemovable(false);\n    addCategoryOptions(sort, Category.SORT, query.sort(), result, uriBuilder);\n    builder.addFilters(sort.build());\n\n    var hasFacetData = !result.facets().isEmpty();\n\n    var diet = new FilterInfo.Builder().name(Category.DIET.getTitle());\n    addCategoryOptions(\n        diet, Category.DIET, query.diet().orElse(UNSELECTED_DIET), result, uriBuilder);\n    diet.showCounts(hasFacetData && query.diet().isEmpty());\n    builder.addFilters(diet.build());\n\n    var numIngredient = new FilterInfo.Builder().name(Category.NUM_INGREDIENT.getTitle());\n    addCategoryOptions(\n        numIngredient,\n        Category.NUM_INGREDIENT,\n        query.numIngredients().orElse(UNSELECTED_RANGE),\n        result,\n        uriBuilder);\n    numIngredient.showCounts(hasFacetData && query.numIngredients().isEmpty());\n    builder.addFilters(numIngredient.build());\n\n    var totalTime =\n        new FilterInfo.Builder().name(Category.TOTAL_TIME.getTitle()).showCounts(hasFacetData);\n    addCategoryOptions(\n        totalTime,\n        Category.TOTAL_TIME,\n        query.totalTime().orElse(UNSELECTED_RANGE),\n        result,\n        uriBuilder);\n    totalTime.showCounts(hasFacetData && query.totalTime().isEmpty());\n    builder.addFilters(totalTime.build());\n\n    var nutrition = new FilterInfo.Builder().name(NUTRITION_INFO_NAME).showCounts(hasFacetData);\n    addCategoryOptions(\n        nutrition,\n        Category.CALORIES,\n        query.calories().orElse(UNSELECTED_RANGE),\n        result,\n        uriBuilder);\n    addCategoryOptions(\n        nutrition,\n        Category.FAT_CONTENT,\n        query.fatContent().orElse(UNSELECTED_RANGE),\n        result,\n        uriBuilder);\n    addCategoryOptions(\n        nutrition,\n        Category.CARB_CONTENT,\n        query.carbohydrateContent().orElse(UNSELECTED_RANGE),\n        result,\n        uriBuilder);\n    nutrition.showCounts(\n        hasFacetData\n            && query.calories().isEmpty()\n            && query.fatContent().isEmpty()\n            && query.carbohydrateContent().isEmpty());\n    builder.addFilters(nutrition.build());\n\n    return builder.build();\n  }\n\n  private int countLabelData(SearchResult result, Category category, CategoryOption label) {\n    return result\n        .facets()\n        .getOrDefault(category.getIndexKey(), EMPTY_FACET_DATA)\n        .children()\n        .getOrDefault(label.getIndexKey(), 0L)\n        .intValue();\n  }\n\n  private void addCategoryOptions(\n      FilterInfo.Builder infoBuilder,\n      Category category,\n      Object selected,\n      SearchResult result,\n      UriComponentsBuilder cloneMe) {\n\n    var uriBuilder = cloneMe.cloneBuilder();\n\n    category\n        .getOptions()\n        .forEach(\n            opt -> {\n              var isActive = opt.isActive(selected);\n\n              if (isActive) {\n                uriBuilder.replaceQueryParam(category.getIndexKey());\n              } else {\n                uriBuilder.replaceQueryParam(category.getIndexKey(), opt.getIndexKey());\n              }\n\n              var filterOption =\n                  new FilterInfo.FilterOption.Builder()\n                      .name(opt.getTitle())\n                      .count(countLabelData(result, category, opt))\n                      .isActive(isActive)\n                      .href(uriBuilder.build().toUriString())\n                      .build();\n\n              infoBuilder.addOptions(filterOption);\n            });\n  }\n}", "class_id": 0, "repo": "caio/casserole", "file": "src/main/java/co/caio/casserole/component/SidebarRenderer.java", "last_update_at": "2019-03-20T16:28:32+00:00", "question_id": "189f9552921978485e4ef4fa5e5b0fb81850746b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SidebarRenderer {\n  public static final String NUTRITION_INFO_NAME = \"Limit Nutrition (per serving)\";\n  private static final SearchResult EMPTY_SEARCH_RESULT = new SearchResult.Builder().build();\n  private static final RangedSpec UNSELECTED_RANGE = RangedSpec.of(0, 0);\n  private static final DietSpec UNSELECTED_DIET = DietSpec.of(\"NONE\", 1F);\n  private static final FacetData EMPTY_FACET_DATA =\n      new FacetData.Builder().dimension(\"EMPTY\").build();\n  public SidebarRenderer() {}\n  public SidebarInfo render(SearchQuery query, UriComponentsBuilder uriBuilder) {\n    return render(query, EMPTY_SEARCH_RESULT, uriBuilder);\n  }\n  public SidebarInfo render(\n      SearchQuery query, SearchResult result, UriComponentsBuilder uriBuilder) {\n    var builder = new SidebarInfo.Builder();\n    var sort = new FilterInfo.Builder().name(Category.SORT.getTitle()).isRemovable(false);\n    addCategoryOptions(sort, Category.SORT, query.sort(), result, uriBuilder);\n    builder.addFilters(sort.build());\n    var hasFacetData = !result.facets().isEmpty();\n    var diet = new FilterInfo.Builder().name(Category.DIET.getTitle());\n    addCategoryOptions(\n        diet, Category.DIET, query.diet().orElse(UNSELECTED_DIET), result, uriBuilder);\n    diet.showCounts(hasFacetData && query.diet().isEmpty());\n    builder.addFilters(diet.build());\n    var numIngredient = new FilterInfo.Builder().name(Category.NUM_INGREDIENT.getTitle());\n    addCategoryOptions(\n        numIngredient,\n        Category.NUM_INGREDIENT,\n        query.numIngredients().orElse(UNSELECTED_RANGE),\n        result,\n        uriBuilder);\n    numIngredient.showCounts(hasFacetData && query.numIngredients().isEmpty());\n    builder.addFilters(numIngredient.build());\n    var totalTime =\n        new FilterInfo.Builder().name(Category.TOTAL_TIME.getTitle()).showCounts(hasFacetData);\n    addCategoryOptions(\n        totalTime,\n        Category.TOTAL_TIME,\n        query.totalTime().orElse(UNSELECTED_RANGE),\n        result,\n        uriBuilder);\n    totalTime.showCounts(hasFacetData && query.totalTime().isEmpty());\n    builder.addFilters(totalTime.build());\n    var nutrition = new FilterInfo.Builder().name(NUTRITION_INFO_NAME).showCounts(hasFacetData);\n    addCategoryOptions(\n        nutrition,\n        Category.CALORIES,\n        query.calories().orElse(UNSELECTED_RANGE),\n        result,\n        uriBuilder);\n    addCategoryOptions(\n        nutrition,\n        Category.FAT_CONTENT,\n        query.fatContent().orElse(UNSELECTED_RANGE),\n        result,\n        uriBuilder);\n    addCategoryOptions(\n        nutrition,\n        Category.CARB_CONTENT,\n        query.carbohydrateContent().orElse(UNSELECTED_RANGE),\n        result,\n        uriBuilder);\n    nutrition.showCounts(\n        hasFacetData\n            && query.calories().isEmpty()\n            && query.fatContent().isEmpty()\n            && query.carbohydrateContent().isEmpty());\n    builder.addFilters(nutrition.build());\n    return builder.build();\n  }\n  private int countLabelData(SearchResult result, Category category, CategoryOption label) {\n    return result\n        .facets()\n        .getOrDefault(category.getIndexKey(), EMPTY_FACET_DATA)\n        .children()\n        .getOrDefault(label.getIndexKey(), 0L)\n        .intValue();\n  }\n  private void addCategoryOptions(\n      FilterInfo.Builder infoBuilder,\n      Category category,\n      Object selected,\n      SearchResult result,\n      UriComponentsBuilder cloneMe) {\n    var uriBuilder = cloneMe.cloneBuilder();\n    category\n        .getOptions()\n        .forEach(\n            opt -> {\n              var isActive = opt.isActive(selected);\n              if (isActive) {\n                uriBuilder.replaceQueryParam(category.getIndexKey());\n              } else {\n                uriBuilder.replaceQueryParam(category.getIndexKey(), opt.getIndexKey());\n              }\n              var filterOption =\n                  new FilterInfo.FilterOption.Builder()\n                      .name(opt.getTitle())\n                      .count(countLabelData(result, category, opt))\n                      .isActive(isActive)\n                      .href(uriBuilder.build().toUriString())\n                      .build();\n              infoBuilder.addOptions(filterOption);\n            });\n  }\n"]]}
{"hexsha": "cc296ba0118e3c532513f2f394ca71359abf13c4", "ext": "java", "lang": "Java", "content": "public class TwoIlluminants extends SpectralColorDisplay {\r\n\tpublic ExPar Illuminant1 = new ExPar(SPECTRUM, new ExParValue(\"D6500\"),\r\n\t\t\t\"First illuminant spectrum\");\r\n\tpublic ExPar Illuminant2 = new ExPar(SPECTRUM, new ExParValue(\"D2400\"),\r\n\t\t\t\"Second illuminant spectrum\");\r\n\tpublic ExPar Illuminant1Luminance = new ExPar(0.0, 200.0, new ExParValue(\r\n\t\t\t180.0), \"Luminance of the 1st illuminant\");\r\n\tpublic ExPar Illuminant2Luminance = new ExPar(0.0, 200.0, new ExParValue(\r\n\t\t\t120.0), \"Luminance of the 2nd illuminant\");\r\n\tpublic ExPar Background = new ExPar(SPECTRUM, new ExParValue(\"2.5R 3/2\"),\r\n\t\t\t\"Background reflectance\");\r\n\tpublic ExPar Center = new ExPar(SPECTRUM, new ExParValue(\"5R 6/4\"),\r\n\t\t\t\"Center reflectance\");\r\n\tpublic ExPar CenterSize = new ExPar(PROPORT, new ExParValue(0.33),\r\n\t\t\t\"Center square size\");\r\n\r\n\t/** Cunstructor creating the title of the display. */\r\n\tpublic TwoIlluminants() {\r\n\t\tsetTitleAndTopic(\"Two Illuminants for a Center and Surround Field\",\r\n\t\t\t\tSPECTRAL_COLOR_DSP | DEMO);\r\n\t}\r\n\tprivate ExPar c1, c2, c3, c4;\r\n\tprivate int s1, s2, s3, s4;\r\n\r\n\tprotected int create() {\r\n\t\tSpectralLightSource ls1 = getLightSource(this.Illuminant1,\r\n\t\t\t\tthis.Illuminant1Luminance);\r\n\t\tSpectralLightSource ls2 = getLightSource(this.Illuminant2,\r\n\t\t\t\tthis.Illuminant2Luminance);\r\n\t\tSpectralLightFilter bg = getLightFilter(this.Background);\r\n\t\tSpectralLightFilter ct = getLightFilter(this.Center);\r\n\t\tc1 = enterLight(\"Left background\", ls1, bg);\r\n\t\tc2 = enterLight(\"Right background\", ls2, bg);\r\n\t\tc3 = enterLight(\"Left center\", ls1, ct);\r\n\t\tc4 = enterLight(\"Right center\", ls2, ct);\r\n\t\ts1 = enterDisplayElement(new Bar(c1));\r\n\t\ts2 = enterDisplayElement(new Bar(c2));\r\n\t\ts3 = enterDisplayElement(new Bar(c3));\r\n\t\ts4 = enterDisplayElement(new Bar(c4));\r\n\t\treturn (s4);\r\n\t}\r\n\r\n\tprotected void computeGeometry() {\r\n\t\tdouble p = CenterSize.getDouble();\r\n\t\tRectangle l = new Rectangle(-width / 2, -height / 2, width / 2, height);\r\n\t\tRectangle r = new Rectangle(0, -height / 2, width - width / 2, height);\r\n\t\tgetDisplayElement(s1).setRect(l);\r\n\t\tgetDisplayElement(s2).setRect(r);\r\n\t\tgetDisplayElement(s3).setRect(innerRect(l, p));\r\n\t\tgetDisplayElement(s4).setRect(innerRect(r, p));\r\n\t}\r\n}", "class_id": 0, "repo": "manuelgentile/pxlab", "file": "pxlab/src/main/java/de/pxlab/pxl/display/TwoIlluminants.java", "last_update_at": "2019-03-04T11:10:59+00:00", "question_id": "cc296ba0118e3c532513f2f394ca71359abf13c4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TwoIlluminants extends SpectralColorDisplay {\r\n\tpublic ExPar Illuminant1 = new ExPar(SPECTRUM, new ExParValue(\"D6500\"),\r\n\t\t\t\"First illuminant spectrum\");\r\n\tpublic ExPar Illuminant2 = new ExPar(SPECTRUM, new ExParValue(\"D2400\"),\r\n\t\t\t\"Second illuminant spectrum\");\r\n\tpublic ExPar Illuminant1Luminance = new ExPar(0.0, 200.0, new ExParValue(\r\n\t\t\t180.0), \"Luminance of the 1st illuminant\");\r\n\tpublic ExPar Illuminant2Luminance = new ExPar(0.0, 200.0, new ExParValue(\r\n\t\t\t120.0), \"Luminance of the 2nd illuminant\");\r\n\tpublic ExPar Background = new ExPar(SPECTRUM, new ExParValue(\"2.5R 3/2\"),\r\n\t\t\t\"Background reflectance\");\r\n\tpublic ExPar Center = new ExPar(SPECTRUM, new ExParValue(\"5R 6/4\"),\r\n\t\t\t\"Center reflectance\");\r\n\tpublic ExPar CenterSize = new ExPar(PROPORT, new ExParValue(0.33),\r\n\t\t\t\"Center square size\");\r\n\r\n\t/** Cunstructor creating the title of the display. */\r\n\tpublic TwoIlluminants() {\r\n\t\tsetTitleAndTopic(\"Two Illuminants for a Center and Surround Field\",\r\n\t\t\t\tSPECTRAL_COLOR_DSP | DEMO);\r\n\t}\r\n\tprivate ExPar c1, c2, c3, c4;\r\n\tprivate int s1, s2, s3, s4;\r\n\r\n\tprotected int create() {\r\n\t\tSpectralLightSource ls1 = getLightSource(this.Illuminant1,\r\n\t\t\t\tthis.Illuminant1Luminance);\r\n\t\tSpectralLightSource ls2 = getLightSource(this.Illuminant2,\r\n\t\t\t\tthis.Illuminant2Luminance);\r\n\t\tSpectralLightFilter bg = getLightFilter(this.Background);\r\n\t\tSpectralLightFilter ct = getLightFilter(this.Center);\r\n\t\tc1 = enterLight(\"Left background\", ls1, bg);\r\n\t\tc2 = enterLight(\"Right background\", ls2, bg);\r\n\t\tc3 = enterLight(\"Left center\", ls1, ct);\r\n\t\tc4 = enterLight(\"Right center\", ls2, ct);\r\n\t\ts1 = enterDisplayElement(new Bar(c1));\r\n\t\ts2 = enterDisplayElement(new Bar(c2));\r\n\t\ts3 = enterDisplayElement(new Bar(c3));\r\n\t\ts4 = enterDisplayElement(new Bar(c4));\r\n\t\treturn (s4);\r\n\t}\r\n\r\n\tprotected void computeGeometry() {\r\n\t\tdouble p = CenterSize.getDouble();\r\n\t\tRectangle l = new Rectangle(-width / 2, -height / 2, width / 2, height);\r\n\t\tRectangle r = new Rectangle(0, -height / 2, width - width / 2, height);\r\n\t\tgetDisplayElement(s1).setRect(l);\r\n\t\tgetDisplayElement(s2).setRect(r);\r\n\t\tgetDisplayElement(s3).setRect(innerRect(l, p));\r\n\t\tgetDisplayElement(s4).setRect(innerRect(r, p));\r\n\t}\r\n"]]}
{"hexsha": "e36f079f4fe1cc3c6d5b09e14f2dff29c0a3fee1", "ext": "java", "lang": "Java", "content": "public class AddRemoteStep extends AbstractStepImpl {\n    private String serverUrl;\n    private String serverName;\n    private String conanHome;\n\n    @DataBoundConstructor\n    public AddRemoteStep(String serverUrl, String serverName, String conanHome) {\n        this.serverUrl = serverUrl;\n        this.serverName = serverName;\n        this.conanHome = conanHome;\n    }\n\n    public String getServerUrl() {\n        return this.serverUrl;\n    }\n\n    public String getServerName() {\n        return this.serverName;\n    }\n\n    public String getConanHome() {\n        return this.conanHome;\n    }\n\n    public static class Execution extends AbstractSynchronousStepExecution<Boolean> {\n        private static final long serialVersionUID = 1L;\n\n        @StepContextParameter\n        private transient Run build;\n\n        @StepContextParameter\n        private transient TaskListener listener;\n\n        @StepContextParameter\n        private transient Launcher launcher;\n\n        @Inject(optional = true)\n        private transient AddRemoteStep step;\n\n        @StepContextParameter\n        private transient FilePath ws;\n\n        @StepContextParameter\n        private transient EnvVars env;\n\n        @Override\n        protected Boolean run() throws Exception {\n            ArgumentListBuilder args = new ArgumentListBuilder();\n            args.addTokenized(\"conan remote add\");\n            args.add(step.getServerName());\n            args.add(step.getServerUrl());\n            EnvVars extendedEnv = new EnvVars(env);\n            extendedEnv.put(Utils.CONAN_USER_HOME, step.getConanHome());\n            Utils.exeConan(args, ws, launcher, listener, build, extendedEnv);\n            return true;\n        }\n    }\n\n    @Extension\n    public static final class DescriptorImpl extends AbstractStepDescriptorImpl {\n\n        public DescriptorImpl() {\n            super(AddRemoteStep.Execution.class);\n        }\n\n        @Override\n        public String getFunctionName() {\n            return \"conanAddRemote\";\n        }\n\n        @Override\n        public String getDisplayName() {\n            return \"Add new repo to Conan config\";\n        }\n\n        @Override\n        public boolean isAdvanced() {\n            return true;\n        }\n    }\n}", "class_id": 0, "repo": "Kuanlin-Chen/jenkins-artifactory-plugin", "file": "src/main/java/org/jfrog/hudson/pipeline/scripted/steps/conan/AddRemoteStep.java", "last_update_at": "2019-03-11T02:23:14+00:00", "question_id": "e36f079f4fe1cc3c6d5b09e14f2dff29c0a3fee1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AddRemoteStep extends AbstractStepImpl {\n    private String serverUrl;\n    private String serverName;\n    private String conanHome;\n    @DataBoundConstructor\n    public AddRemoteStep(String serverUrl, String serverName, String conanHome) {\n        this.serverUrl = serverUrl;\n        this.serverName = serverName;\n        this.conanHome = conanHome;\n    }\n    public String getServerUrl() {\n        return this.serverUrl;\n    }\n    public String getServerName() {\n        return this.serverName;\n    }\n    public String getConanHome() {\n        return this.conanHome;\n    }\n    public static class Execution extends AbstractSynchronousStepExecution<Boolean> {\n        private static final long serialVersionUID = 1L;\n        @StepContextParameter\n        private transient Run build;\n        @StepContextParameter\n        private transient TaskListener listener;\n        @StepContextParameter\n        private transient Launcher launcher;\n        @Inject(optional = true)\n        private transient AddRemoteStep step;\n        @StepContextParameter\n        private transient FilePath ws;\n        @StepContextParameter\n        private transient EnvVars env;\n        @Override\n        protected Boolean run() throws Exception {\n            ArgumentListBuilder args = new ArgumentListBuilder();\n            args.addTokenized(\"conan remote add\");\n            args.add(step.getServerName());\n            args.add(step.getServerUrl());\n            EnvVars extendedEnv = new EnvVars(env);\n            extendedEnv.put(Utils.CONAN_USER_HOME, step.getConanHome());\n            Utils.exeConan(args, ws, launcher, listener, build, extendedEnv);\n            return true;\n        }\n    }\n    @Extension\n    public static final class DescriptorImpl extends AbstractStepDescriptorImpl {\n        public DescriptorImpl() {\n            super(AddRemoteStep.Execution.class);\n        }\n        @Override\n        public String getFunctionName() {\n            return \"conanAddRemote\";\n        }\n        @Override\n        public String getDisplayName() {\n            return \"Add new repo to Conan config\";\n        }\n        @Override\n        public boolean isAdvanced() {\n            return true;\n        }\n    }\n"]]}
{"hexsha": "b022ca7489f0b6aa70d67b873157ea8b69be9d10", "ext": "java", "lang": "Java", "content": "public class EventStoreDao {\n    private final CassandraAsyncExecutor cassandraAsyncExecutor;\n    private final PreparedStatement insert;\n    private final PreparedStatement select;\n    private final JsonEventSerializer jsonEventSerializer;\n\n    @Inject\n    public EventStoreDao(Session session, JsonEventSerializer jsonEventSerializer) {\n        this.cassandraAsyncExecutor = new CassandraAsyncExecutor(session);\n        this.jsonEventSerializer = jsonEventSerializer;\n        this.insert = prepareInsert(session);\n        this.select = prepareSelect(session);\n    }\n\n    private PreparedStatement prepareInsert(Session session) {\n        return session.prepare(insertInto(EVENTS_TABLE)\n            .value(AGGREGATE_ID, bindMarker(AGGREGATE_ID))\n            .value(EVENT_ID, bindMarker(EVENT_ID))\n            .value(EVENT, bindMarker(EVENT))\n            .ifNotExists());\n    }\n\n    private PreparedStatement prepareSelect(Session session) {\n        return session.prepare(select()\n            .from(EVENTS_TABLE)\n            .where(eq(AGGREGATE_ID, bindMarker(AGGREGATE_ID))));\n    }\n\n    public Mono<Boolean> appendAll(List<Event> events) {\n        BatchStatement batch = new BatchStatement();\n        events.forEach(event -> batch.add(insertEvent(event)));\n        return cassandraAsyncExecutor.executeReturnApplied(batch);\n    }\n\n    private BoundStatement insertEvent(Event event) {\n        try {\n            return insert\n                .bind()\n                .setString(AGGREGATE_ID, event.getAggregateId().asAggregateKey())\n                .setInt(EVENT_ID, event.eventId().serialize())\n                .setString(EVENT, jsonEventSerializer.serialize(event));\n        } catch (JsonProcessingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public History getEventsOfAggregate(AggregateId aggregateId) {\n        return cassandraAsyncExecutor.executeRows(\n                select.bind()\n                    .setString(AGGREGATE_ID, aggregateId.asAggregateKey()))\n            .map(this::toEvent)\n            .collectList()\n            .map(History::of)\n            .block();\n    }\n\n    private Event toEvent(Row row) {\n        try {\n            return jsonEventSerializer.deserialize(row.getString(EVENT));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}", "class_id": 0, "repo": "marincenusa/james-project", "file": "event-sourcing/event-store-cassandra/src/main/java/org/apache/james/eventsourcing/eventstore/cassandra/EventStoreDao.java", "last_update_at": "2019-03-17T05:16:21+00:00", "question_id": "b022ca7489f0b6aa70d67b873157ea8b69be9d10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EventStoreDao {\n    private final CassandraAsyncExecutor cassandraAsyncExecutor;\n    private final PreparedStatement insert;\n    private final PreparedStatement select;\n    private final JsonEventSerializer jsonEventSerializer;\n    @Inject\n    public EventStoreDao(Session session, JsonEventSerializer jsonEventSerializer) {\n        this.cassandraAsyncExecutor = new CassandraAsyncExecutor(session);\n        this.jsonEventSerializer = jsonEventSerializer;\n        this.insert = prepareInsert(session);\n        this.select = prepareSelect(session);\n    }\n    private PreparedStatement prepareInsert(Session session) {\n        return session.prepare(insertInto(EVENTS_TABLE)\n            .value(AGGREGATE_ID, bindMarker(AGGREGATE_ID))\n            .value(EVENT_ID, bindMarker(EVENT_ID))\n            .value(EVENT, bindMarker(EVENT))\n            .ifNotExists());\n    }\n    private PreparedStatement prepareSelect(Session session) {\n        return session.prepare(select()\n            .from(EVENTS_TABLE)\n            .where(eq(AGGREGATE_ID, bindMarker(AGGREGATE_ID))));\n    }\n    public Mono<Boolean> appendAll(List<Event> events) {\n        BatchStatement batch = new BatchStatement();\n        events.forEach(event -> batch.add(insertEvent(event)));\n        return cassandraAsyncExecutor.executeReturnApplied(batch);\n    }\n    private BoundStatement insertEvent(Event event) {\n        try {\n            return insert\n                .bind()\n                .setString(AGGREGATE_ID, event.getAggregateId().asAggregateKey())\n                .setInt(EVENT_ID, event.eventId().serialize())\n                .setString(EVENT, jsonEventSerializer.serialize(event));\n        } catch (JsonProcessingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    public History getEventsOfAggregate(AggregateId aggregateId) {\n        return cassandraAsyncExecutor.executeRows(\n                select.bind()\n                    .setString(AGGREGATE_ID, aggregateId.asAggregateKey()))\n            .map(this::toEvent)\n            .collectList()\n            .map(History::of)\n            .block();\n    }\n    private Event toEvent(Row row) {\n        try {\n            return jsonEventSerializer.deserialize(row.getString(EVENT));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n"]]}
{"hexsha": "8b8a0fdc9e2e5176fb105c18f63471f88ae8c642", "ext": "java", "lang": "Java", "content": "public final class DeadlockGlobalCache implements IDeadlockGlobalCacheSubmitter, IDeadlockGlobalCache {\n\n    private final ICachingStrategy<ILockCacheEntry, ILockThreadEntry> lockCache;\n\n    private final ICachingStrategy<IFieldCacheEntry, IFieldThreadEntry> fieldCache;\n\n    @SuppressWarnings({\"unused\", \"FieldCanBeLocal\"})\n    private final DeadlockCollector fileCollector;\n\n    private final IDeadlockCollectBindingResolver resolver;\n\n\n    static DeadlockGlobalCache\n    create(IDeadlockCollectBindingResolver resolver, ICachingStrategy.ICachingStrategyCreator<ICacheEntry, IThreadEntry> strategyCreator) {\n\n        ICachingStrategy<ILockCacheEntry, ILockThreadEntry> lockCache = JctraceUtil.uncheckedCast(\n            strategyCreator.apply(e -> new LockCacheEntry((ILockThreadEntry) e)));\n        ICachingStrategy<IFieldCacheEntry, IFieldThreadEntry> fieldCache = JctraceUtil.uncheckedCast(\n            strategyCreator.apply(e -> new FieldCacheEntry((IFieldThreadEntry) e)));\n\n        return new DeadlockGlobalCache(resolver, lockCache, fieldCache);\n    }\n\n    private DeadlockGlobalCache(IDeadlockCollectBindingResolver resolver,\n                                ICachingStrategy<ILockCacheEntry, ILockThreadEntry> lockCache,\n                                ICachingStrategy<IFieldCacheEntry, IFieldThreadEntry> fieldCache) {\n        this.resolver = resolver;\n        this.lockCache = lockCache;\n        this.fieldCache = fieldCache;\n        this.fileCollector = new DeadlockCollector(resolver);\n\n    }\n\n    @Override\n    public void waitForProcessing() {\n    }\n\n    @Nullable\n    @Override\n    public ILockCacheEntry getLockCacheEntryForThreadUnsafe(ILockThreadEntry threadEntry) {\n        return lockCache.getCacheEntryUnsafe(threadEntry);\n    }\n\n    @Override\n    public void newLockMonitorEnter(ILockThreadEntry lockThreadEntry, ILockThreadEntry[] heldLocks) {\n        LockCacheEntry lockEntry = (LockCacheEntry) lockCache.getCacheEntryOrCreate(lockThreadEntry);\n        lockEntry.updateLockCacheEntry(resolver, lockThreadEntry, heldLocks);\n\n    }\n\n    @Override\n    public void newFieldGet(IFieldThreadEntry fieldThreadEntry, ILockThreadEntry[] heldLocks) {\n        FieldCacheEntry fieldEntry = (FieldCacheEntry) fieldCache.getCacheEntryOrCreate(fieldThreadEntry);\n        fieldEntry.fieldGetCacheEntry(resolver, fieldThreadEntry, heldLocks);\n    }\n\n    @Override\n    public void newFieldSet(IFieldThreadEntry fieldThreadEntry, ILockThreadEntry[] heldLocks) {\n        FieldCacheEntry fieldEntry = (FieldCacheEntry) fieldCache.getCacheEntryOrCreate(fieldThreadEntry);\n        fieldEntry.fieldSetCacheEntry(resolver, fieldThreadEntry, heldLocks);\n    }\n\n    @Override\n    public void newLockCreated(ILockThreadEntry lockThreadEntry, ILockThreadEntry[] heldLocks) {\n        LockCacheEntry lockEntry = (LockCacheEntry) lockCache.getCacheEntryOrCreate(lockThreadEntry);\n        lockEntry.newLockCreatedCacheEntry(resolver, lockThreadEntry, heldLocks);\n    }\n\n    @Override\n    public List<ILockCacheEntry> getLockEntries() {\n        return lockCache.getEntries();\n    }\n\n    @Override\n    public List<IFieldCacheEntry> getFieldEntries() {\n        return fieldCache.getEntries();\n    }\n\n    @Override\n    public List<ILockCacheEntry> getLockEntriesExpungeStallEntries() {\n        return lockCache.getEntriesExpungeStallEntries();\n    }\n\n    @Override\n    public List<IFieldCacheEntry> getFieldEntriesExpungeStallEntries() {\n        return fieldCache.getEntriesExpungeStallEntries();\n    }\n\n\n    @ThreadSafe\n    static final class LockCacheEntry extends AbstractCacheEntry implements ILockCacheEntry {\n        private static final AtomicInteger globalIdCounter = new AtomicInteger(0);\n\n        private final String lockClass;\n\n        @GuardedBy(\"this\")\n        private long lockedCount = 0;\n\n        @GuardedBy(\"this\")\n        private final TIntSet dependentLocks = new TIntHashSet();\n\n\n        LockCacheEntry(ILockThreadEntry entry) {\n            super(globalIdCounter.incrementAndGet());\n            requireNonNull(entry);\n            Object lock = entry.getLock();\n            requireNonNull(lock);\n            if (lock instanceof Class) {\n                Class<?> clazz = (Class<?>) lock;\n                lockClass = \"(ClassLock) \" + clazz.getName();\n            } else {\n                lockClass = lock.getClass().getName();\n            }\n\n        }\n\n        protected ISerializableData createSerObjInternal(int revision) {\n            return new LockCacheEntrySer(this, revision);\n        }\n\n        void newLockCreatedCacheEntry(IDeadlockCollectBindingResolver resolver,\n                                      ILockThreadEntry lockThreadEntry,\n                                      ILockThreadEntry[] heldLocks) {\n            synchronized (this) {\n                setChangedSinceLastSnapshot();\n                int locationId = lockThreadEntry.getLocationId();\n                int threadId = lockThreadEntry.getThreadId();\n                boolean newLocationAdded = addLocationId(locationId);\n                if (newLocationAdded) {\n                    checkNewLocationForStacktracing(resolver, locationId);\n                }\n                addThreadId(threadId);\n            }\n        }\n\n        void updateLockCacheEntry(IDeadlockCollectBindingResolver resolver,\n                                  ILockThreadEntry lockThreadEntry,\n                                  ILockThreadEntry[] heldLocks) {\n            synchronized (this) {\n                setChangedSinceLastSnapshot();\n                int locationId = lockThreadEntry.getLocationId();\n                int threadId = lockThreadEntry.getThreadId();\n                boolean newLocationAdded = addLocationId(locationId);\n                if (newLocationAdded) {\n                    checkNewLocationForStacktracing(resolver, locationId);\n                }\n                addThreadId(threadId);\n                incrementLockCount();\n                TIntList dependentLocksLst = addDependentLocks(resolver, lockThreadEntry, heldLocks);\n                addStackEntry(locationId, threadId, dependentLocksLst);\n            }\n        }\n\n        private TIntList addDependentLocks(IDeadlockCollectBindingResolver resolver, ILockThreadEntry lockThreadEntry, ILockThreadEntry[] heldLocks) {\n\n            TIntList dependentLocks = null;\n            if (isStackCapturingEnabled()) {\n                dependentLocks = new TIntArrayList();\n            }\n            for (ILockThreadEntry lockThObj : heldLocks) {\n                if (lockThObj == null) {\n                    continue;\n                }\n                if (lockThObj == lockThreadEntry) {\n                    continue;\n                }\n                ILockCacheEntry lockEntry = resolver.getLockCache().getLockCacheEntryForThreadUnsafe(lockThObj);\n                if (lockEntry == null) {\n                    ILockCacheEntry lockEntry2 = resolver.getLockCache().getLockCacheEntryForThreadUnsafe(lockThObj);\n                    throw new IllegalStateException(\"There must be a ILockCacheEntry for the lock \" + lockThObj + \" second try \" + lockEntry2);\n                }\n                addDependentLocks(lockEntry);\n                if (isStackCapturingEnabled()) {\n                    requireNonNull(dependentLocks).add(lockEntry.getId());\n                }\n            }\n            return dependentLocks;\n        }\n\n        private void incrementLockCount() {\n            lockedCount++;\n        }\n\n        private void addDependentLocks(ILockCacheEntry lock) {\n            dependentLocks.add(lock.getId());\n        }\n\n        @Override\n        public boolean hasDependentLock(ILockCacheEntry lock) {\n            return hasDependentLock(lock.getId());\n        }\n\n        @Override\n        public boolean hasDependentLock(int lockId) {\n            synchronized (this) {\n                return dependentLocks.contains(lockId);\n            }\n        }\n\n        @Override\n        public int compareTo(@Nonnull ILockCacheEntry o) {\n            int id1 = this.getId();\n            int id2 = o.getId();\n            return Integer.compare(id1, id2);\n        }\n\n        @Override\n        public long getLockedCount() {\n            return lockedCount;\n        }\n\n        @Override\n        public String getLockClass() {\n            return lockClass;\n        }\n\n        @Override\n        public int[] getDependentLocks() {\n            synchronized (this) {\n                return dependentLocks.toArray();\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"LockCacheEntry [id=\" + getId() + \", lockClass=\" + lockClass + \", lockedCount=\" + lockedCount + \"]\";\n        }\n\n    }\n\n\n    @ThreadSafe\n    static final class FieldCacheEntry extends AbstractCacheEntry implements IFieldCacheEntry {\n        private static final AtomicInteger globalIdCounter = new AtomicInteger(0);\n\n        private final int fieldDescriptorId;\n\n        @GuardedBy(\"this\")\n        private long readCount = 0;\n\n        @GuardedBy(\"this\")\n        private long writeCount = 0;\n\n        private final int ownerIdentityHash;\n\n        FieldCacheEntry(IFieldThreadEntry entry) {\n            super(globalIdCounter.incrementAndGet());\n\n            requireNonNull(entry);\n            Object owner = entry.getOwner();\n            requireNonNull(owner);\n            ownerIdentityHash = System.identityHashCode(owner);\n            fieldDescriptorId = entry.getFieldDescriptorId();\n        }\n\n        protected ISerializableData createSerObjInternal(int revision) {\n            return new FieldCacheEntrySer(this, revision);\n        }\n\n        void fieldGetCacheEntry(IDeadlockCollectBindingResolver resolver,\n                                IFieldThreadEntry fieldThreadEntry,\n                                ILockThreadEntry[] heldLocks) {\n            synchronized (this) {\n                fieldUsage(resolver, fieldThreadEntry, heldLocks);\n                this.incrementReadCount();\n            }\n        }\n\n        void fieldSetCacheEntry(IDeadlockCollectBindingResolver resolver,\n                                IFieldThreadEntry fieldThreadEntry,\n                                ILockThreadEntry[] heldLocks) {\n            synchronized (this) {\n                fieldUsage(resolver, fieldThreadEntry, heldLocks);\n                this.incrementWriteCount();\n            }\n        }\n\n        private void fieldUsage(IDeadlockCollectBindingResolver resolver, IFieldThreadEntry fieldThreadEntry, ILockThreadEntry[] heldLocks) {\n            setChangedSinceLastSnapshot();\n            int locationId = fieldThreadEntry.getLocationId();\n            int threadId = fieldThreadEntry.getThreadId();\n            boolean newLocationAdded = addLocationId(locationId);\n            if (newLocationAdded) {\n                checkNewLocationForStacktracing(resolver, locationId);\n            }\n            addThreadId(threadId);\n            TIntList dependentLocksList = addDependentLocks(resolver, heldLocks);\n            addStackEntry(locationId, threadId, dependentLocksList);\n        }\n\n        private TIntList addDependentLocks(IDeadlockCollectBindingResolver resolver, ILockThreadEntry[] heldLocks) {\n\n            TIntList dependentLocks = null;\n            if (isStackCapturingEnabled()) {\n                dependentLocks = new TIntArrayList();\n            }\n            for (ILockThreadEntry lockThObj : heldLocks) {\n                if (lockThObj == null) {\n                    continue;\n                }\n                ILockCacheEntry lockEntry = resolver.getLockCache().getLockCacheEntryForThreadUnsafe(lockThObj);\n                if (lockEntry == null) {\n                    ILockCacheEntry lockEntry2 = resolver.getLockCache().getLockCacheEntryForThreadUnsafe(lockThObj);\n                    throw new IllegalStateException(\"There must be a ILockCacheEntry for the lock \" + lockThObj + \" second try \" + lockEntry2);\n                }\n                //addDependentLocks(lockEntry);\n                if (isStackCapturingEnabled()) {\n                    requireNonNull(dependentLocks).add(lockEntry.getId());\n                }\n            }\n            return dependentLocks;\n        }\n\n        private void incrementWriteCount() {\n            writeCount++;\n        }\n\n        private void incrementReadCount() {\n            readCount++;\n        }\n\n        @Override\n        public int compareTo(@Nonnull IFieldCacheEntry o) {\n            int id1 = this.getId();\n            int id2 = o.getId();\n            return Integer.compare(id1, id2);\n        }\n\n\n        @Override\n        public int getFieldDescriptorId() {\n            return fieldDescriptorId;\n        }\n\n        @Override\n        public long getReadCount() {\n            synchronized (this) {\n                return readCount;\n            }\n        }\n\n        @Override\n        public long getWriteCount() {\n            synchronized (this) {\n                return writeCount;\n            }\n        }\n\n        public int getOwnerIdentityHash() {\n            return ownerIdentityHash;\n        }\n\n        @Override\n        public String toString() {\n            return \"FieldCacheEntry [id=\" + getId() + \", fieldDescriptorId=\" + fieldDescriptorId + \"]\";\n        }\n\n    }\n\n}", "class_id": 0, "repo": "AndreasTu/jctrace", "file": "subprojects/jctrace-core/src/main/java/de/turban/deadlock/tracer/runtime/datacollection/DeadlockGlobalCache.java", "last_update_at": "2019-11-06T06:35:41+00:00", "question_id": "8b8a0fdc9e2e5176fb105c18f63471f88ae8c642", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class DeadlockGlobalCache implements IDeadlockGlobalCacheSubmitter, IDeadlockGlobalCache {\n    private final ICachingStrategy<ILockCacheEntry, ILockThreadEntry> lockCache;\n    private final ICachingStrategy<IFieldCacheEntry, IFieldThreadEntry> fieldCache;\n    @SuppressWarnings({\"unused\", \"FieldCanBeLocal\"})\n    private final DeadlockCollector fileCollector;\n    private final IDeadlockCollectBindingResolver resolver;\n    static DeadlockGlobalCache\n    create(IDeadlockCollectBindingResolver resolver, ICachingStrategy.ICachingStrategyCreator<ICacheEntry, IThreadEntry> strategyCreator) {\n        ICachingStrategy<ILockCacheEntry, ILockThreadEntry> lockCache = JctraceUtil.uncheckedCast(\n            strategyCreator.apply(e -> new LockCacheEntry((ILockThreadEntry) e)));\n        ICachingStrategy<IFieldCacheEntry, IFieldThreadEntry> fieldCache = JctraceUtil.uncheckedCast(\n            strategyCreator.apply(e -> new FieldCacheEntry((IFieldThreadEntry) e)));\n        return new DeadlockGlobalCache(resolver, lockCache, fieldCache);\n    }\n    private DeadlockGlobalCache(IDeadlockCollectBindingResolver resolver,\n                                ICachingStrategy<ILockCacheEntry, ILockThreadEntry> lockCache,\n                                ICachingStrategy<IFieldCacheEntry, IFieldThreadEntry> fieldCache) {\n        this.resolver = resolver;\n        this.lockCache = lockCache;\n        this.fieldCache = fieldCache;\n        this.fileCollector = new DeadlockCollector(resolver);\n    }\n    @Override\n    public void waitForProcessing() {\n    }\n    @Nullable\n    @Override\n    public ILockCacheEntry getLockCacheEntryForThreadUnsafe(ILockThreadEntry threadEntry) {\n        return lockCache.getCacheEntryUnsafe(threadEntry);\n    }\n    @Override\n    public void newLockMonitorEnter(ILockThreadEntry lockThreadEntry, ILockThreadEntry[] heldLocks) {\n        LockCacheEntry lockEntry = (LockCacheEntry) lockCache.getCacheEntryOrCreate(lockThreadEntry);\n        lockEntry.updateLockCacheEntry(resolver, lockThreadEntry, heldLocks);\n    }\n    @Override\n    public void newFieldGet(IFieldThreadEntry fieldThreadEntry, ILockThreadEntry[] heldLocks) {\n        FieldCacheEntry fieldEntry = (FieldCacheEntry) fieldCache.getCacheEntryOrCreate(fieldThreadEntry);\n        fieldEntry.fieldGetCacheEntry(resolver, fieldThreadEntry, heldLocks);\n    }\n    @Override\n    public void newFieldSet(IFieldThreadEntry fieldThreadEntry, ILockThreadEntry[] heldLocks) {\n        FieldCacheEntry fieldEntry = (FieldCacheEntry) fieldCache.getCacheEntryOrCreate(fieldThreadEntry);\n        fieldEntry.fieldSetCacheEntry(resolver, fieldThreadEntry, heldLocks);\n    }\n    @Override\n    public void newLockCreated(ILockThreadEntry lockThreadEntry, ILockThreadEntry[] heldLocks) {\n        LockCacheEntry lockEntry = (LockCacheEntry) lockCache.getCacheEntryOrCreate(lockThreadEntry);\n        lockEntry.newLockCreatedCacheEntry(resolver, lockThreadEntry, heldLocks);\n    }\n    @Override\n    public List<ILockCacheEntry> getLockEntries() {\n        return lockCache.getEntries();\n    }\n    @Override\n    public List<IFieldCacheEntry> getFieldEntries() {\n        return fieldCache.getEntries();\n    }\n    @Override\n    public List<ILockCacheEntry> getLockEntriesExpungeStallEntries() {\n        return lockCache.getEntriesExpungeStallEntries();\n    }\n    @Override\n    public List<IFieldCacheEntry> getFieldEntriesExpungeStallEntries() {\n        return fieldCache.getEntriesExpungeStallEntries();\n    }\n    @ThreadSafe\n    static final class LockCacheEntry extends AbstractCacheEntry implements ILockCacheEntry {\n        private static final AtomicInteger globalIdCounter = new AtomicInteger(0);\n        private final String lockClass;\n        @GuardedBy(\"this\")\n        private long lockedCount = 0;\n        @GuardedBy(\"this\")\n        private final TIntSet dependentLocks = new TIntHashSet();\n        LockCacheEntry(ILockThreadEntry entry) {\n            super(globalIdCounter.incrementAndGet());\n            requireNonNull(entry);\n            Object lock = entry.getLock();\n            requireNonNull(lock);\n            if (lock instanceof Class) {\n                Class<?> clazz = (Class<?>) lock;\n                lockClass = \"(ClassLock) \" + clazz.getName();\n            } else {\n                lockClass = lock.getClass().getName();\n            }\n        }\n        protected ISerializableData createSerObjInternal(int revision) {\n            return new LockCacheEntrySer(this, revision);\n        }\n        void newLockCreatedCacheEntry(IDeadlockCollectBindingResolver resolver,\n                                      ILockThreadEntry lockThreadEntry,\n                                      ILockThreadEntry[] heldLocks) {\n            synchronized (this) {\n                setChangedSinceLastSnapshot();\n                int locationId = lockThreadEntry.getLocationId();\n                int threadId = lockThreadEntry.getThreadId();\n                boolean newLocationAdded = addLocationId(locationId);\n                if (newLocationAdded) {\n                    checkNewLocationForStacktracing(resolver, locationId);\n                }\n                addThreadId(threadId);\n            }\n        }\n        void updateLockCacheEntry(IDeadlockCollectBindingResolver resolver,\n                                  ILockThreadEntry lockThreadEntry,\n                                  ILockThreadEntry[] heldLocks) {\n            synchronized (this) {\n                setChangedSinceLastSnapshot();\n                int locationId = lockThreadEntry.getLocationId();\n                int threadId = lockThreadEntry.getThreadId();\n                boolean newLocationAdded = addLocationId(locationId);\n                if (newLocationAdded) {\n                    checkNewLocationForStacktracing(resolver, locationId);\n                }\n                addThreadId(threadId);\n                incrementLockCount();\n                TIntList dependentLocksLst = addDependentLocks(resolver, lockThreadEntry, heldLocks);\n                addStackEntry(locationId, threadId, dependentLocksLst);\n            }\n        }\n        private TIntList addDependentLocks(IDeadlockCollectBindingResolver resolver, ILockThreadEntry lockThreadEntry, ILockThreadEntry[] heldLocks) {\n            TIntList dependentLocks = null;\n            if (isStackCapturingEnabled()) {\n                dependentLocks = new TIntArrayList();\n            }\n            for (ILockThreadEntry lockThObj : heldLocks) {\n                if (lockThObj == null) {\n                    continue;\n                }\n                if (lockThObj == lockThreadEntry) {\n                    continue;\n                }\n                ILockCacheEntry lockEntry = resolver.getLockCache().getLockCacheEntryForThreadUnsafe(lockThObj);\n                if (lockEntry == null) {\n                    ILockCacheEntry lockEntry2 = resolver.getLockCache().getLockCacheEntryForThreadUnsafe(lockThObj);\n                    throw new IllegalStateException(\"There must be a ILockCacheEntry for the lock \" + lockThObj + \" second try \" + lockEntry2);\n                }\n                addDependentLocks(lockEntry);\n                if (isStackCapturingEnabled()) {\n                    requireNonNull(dependentLocks).add(lockEntry.getId());\n                }\n            }\n            return dependentLocks;\n        }\n        private void incrementLockCount() {\n            lockedCount++;\n        }\n        private void addDependentLocks(ILockCacheEntry lock) {\n            dependentLocks.add(lock.getId());\n        }\n        @Override\n        public boolean hasDependentLock(ILockCacheEntry lock) {\n            return hasDependentLock(lock.getId());\n        }\n        @Override\n        public boolean hasDependentLock(int lockId) {\n            synchronized (this) {\n                return dependentLocks.contains(lockId);\n            }\n        }\n        @Override\n        public int compareTo(@Nonnull ILockCacheEntry o) {\n            int id1 = this.getId();\n            int id2 = o.getId();\n            return Integer.compare(id1, id2);\n        }\n        @Override\n        public long getLockedCount() {\n            return lockedCount;\n        }\n        @Override\n        public String getLockClass() {\n            return lockClass;\n        }\n        @Override\n        public int[] getDependentLocks() {\n            synchronized (this) {\n                return dependentLocks.toArray();\n            }\n        }\n        @Override\n        public String toString() {\n            return \"LockCacheEntry [id=\" + getId() + \", lockClass=\" + lockClass + \", lockedCount=\" + lockedCount + \"]\";\n        }\n    }\n    @ThreadSafe\n    static final class FieldCacheEntry extends AbstractCacheEntry implements IFieldCacheEntry {\n        private static final AtomicInteger globalIdCounter = new AtomicInteger(0);\n        private final int fieldDescriptorId;\n        @GuardedBy(\"this\")\n        private long readCount = 0;\n        @GuardedBy(\"this\")\n        private long writeCount = 0;\n        private final int ownerIdentityHash;\n        FieldCacheEntry(IFieldThreadEntry entry) {\n            super(globalIdCounter.incrementAndGet());\n            requireNonNull(entry);\n            Object owner = entry.getOwner();\n            requireNonNull(owner);\n            ownerIdentityHash = System.identityHashCode(owner);\n            fieldDescriptorId = entry.getFieldDescriptorId();\n        }\n        protected ISerializableData createSerObjInternal(int revision) {\n            return new FieldCacheEntrySer(this, revision);\n        }\n        void fieldGetCacheEntry(IDeadlockCollectBindingResolver resolver,\n                                IFieldThreadEntry fieldThreadEntry,\n                                ILockThreadEntry[] heldLocks) {\n            synchronized (this) {\n                fieldUsage(resolver, fieldThreadEntry, heldLocks);\n                this.incrementReadCount();\n            }\n        }\n        void fieldSetCacheEntry(IDeadlockCollectBindingResolver resolver,\n                                IFieldThreadEntry fieldThreadEntry,\n                                ILockThreadEntry[] heldLocks) {\n            synchronized (this) {\n                fieldUsage(resolver, fieldThreadEntry, heldLocks);\n                this.incrementWriteCount();\n            }\n        }\n        private void fieldUsage(IDeadlockCollectBindingResolver resolver, IFieldThreadEntry fieldThreadEntry, ILockThreadEntry[] heldLocks) {\n            setChangedSinceLastSnapshot();\n            int locationId = fieldThreadEntry.getLocationId();\n            int threadId = fieldThreadEntry.getThreadId();\n            boolean newLocationAdded = addLocationId(locationId);\n            if (newLocationAdded) {\n                checkNewLocationForStacktracing(resolver, locationId);\n            }\n            addThreadId(threadId);\n            TIntList dependentLocksList = addDependentLocks(resolver, heldLocks);\n            addStackEntry(locationId, threadId, dependentLocksList);\n        }\n        private TIntList addDependentLocks(IDeadlockCollectBindingResolver resolver, ILockThreadEntry[] heldLocks) {\n            TIntList dependentLocks = null;\n            if (isStackCapturingEnabled()) {\n                dependentLocks = new TIntArrayList();\n            }\n            for (ILockThreadEntry lockThObj : heldLocks) {\n                if (lockThObj == null) {\n                    continue;\n                }\n                ILockCacheEntry lockEntry = resolver.getLockCache().getLockCacheEntryForThreadUnsafe(lockThObj);\n                if (lockEntry == null) {\n                    ILockCacheEntry lockEntry2 = resolver.getLockCache().getLockCacheEntryForThreadUnsafe(lockThObj);\n                    throw new IllegalStateException(\"There must be a ILockCacheEntry for the lock \" + lockThObj + \" second try \" + lockEntry2);\n                }\n                //addDependentLocks(lockEntry);\n                if (isStackCapturingEnabled()) {\n                    requireNonNull(dependentLocks).add(lockEntry.getId());\n                }\n            }\n            return dependentLocks;\n        }\n        private void incrementWriteCount() {\n            writeCount++;\n        }\n        private void incrementReadCount() {\n            readCount++;\n        }\n        @Override\n        public int compareTo(@Nonnull IFieldCacheEntry o) {\n            int id1 = this.getId();\n            int id2 = o.getId();\n            return Integer.compare(id1, id2);\n        }\n        @Override\n        public int getFieldDescriptorId() {\n            return fieldDescriptorId;\n        }\n        @Override\n        public long getReadCount() {\n            synchronized (this) {\n                return readCount;\n            }\n        }\n        @Override\n        public long getWriteCount() {\n            synchronized (this) {\n                return writeCount;\n            }\n        }\n        public int getOwnerIdentityHash() {\n            return ownerIdentityHash;\n        }\n        @Override\n        public String toString() {\n            return \"FieldCacheEntry [id=\" + getId() + \", fieldDescriptorId=\" + fieldDescriptorId + \"]\";\n        }\n    }\n"]]}
{"hexsha": "dd93eb1f5722f8fe6795a75469980047418947d8", "ext": "java", "lang": "Java", "content": "public class PacketRunningShoes implements IMessage\n{\n\tboolean isRunningShoes;\n\tpublic PacketRunningShoes(){\n\n\t}\n\n\tpublic PacketRunningShoes(boolean isRunningShoes){\n\t\tthis.isRunningShoes = isRunningShoes;\n\t}\n\n\t@Override\n\tpublic void fromBytes(ByteBuf buffer) \n\t{\n\t\tisRunningShoes = buffer.readBoolean();\n\t}\n\n\t@Override\n\tpublic void toBytes(ByteBuf buffer) \n\t{\n\t\tbuffer.writeBoolean(isRunningShoes);\n\t}\n\t\n\tpublic static class Handler implements IMessageHandler<PacketRunningShoes, IMessage> \n\t{\n        @Override\n        public IMessage onMessage(PacketRunningShoes message, MessageContext ctx) \n        {\n        \tEntityPlayer player = ctx.getServerHandler().playerEntity;\n        \tExtendedPlayer props = ExtendedPlayer.get(player);\n    \t\tprops.isRunning = message.isRunningShoes;\n    \t\tprops.saveProxyData(player);\n    \t\tprops.loadProxyData(player);\n    \t\treturn null;\n        }\n    }\n\n}", "class_id": 0, "repo": "Sudwood/AdvancedUtilities", "file": "java/com/sudwood/advancedutilities/packets/PacketRunningShoes.java", "last_update_at": "2019-11-22T08:35:09+00:00", "question_id": "dd93eb1f5722f8fe6795a75469980047418947d8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PacketRunningShoes implements IMessage\n{\n\tboolean isRunningShoes;\n\tpublic PacketRunningShoes(){\n\t}\n\tpublic PacketRunningShoes(boolean isRunningShoes){\n\t\tthis.isRunningShoes = isRunningShoes;\n\t}\n\t@Override\n\tpublic void fromBytes(ByteBuf buffer) \n\t{\n\t\tisRunningShoes = buffer.readBoolean();\n\t}\n\t@Override\n\tpublic void toBytes(ByteBuf buffer) \n\t{\n\t\tbuffer.writeBoolean(isRunningShoes);\n\t}\n\t\n\tpublic static class Handler implements IMessageHandler<PacketRunningShoes, IMessage> \n\t{\n        @Override\n        public IMessage onMessage(PacketRunningShoes message, MessageContext ctx) \n        {\n        \tEntityPlayer player = ctx.getServerHandler().playerEntity;\n        \tExtendedPlayer props = ExtendedPlayer.get(player);\n    \t\tprops.isRunning = message.isRunningShoes;\n    \t\tprops.saveProxyData(player);\n    \t\tprops.loadProxyData(player);\n    \t\treturn null;\n        }\n    }\n"]]}
{"hexsha": "c4384f0415035b18e6ac59d1df420fcfec693011", "ext": "java", "lang": "Java", "content": "@Category(DefaultTest.class)\npublic class SocialUtilsTestCase extends TestCase{\n\n    /**\n     * Test Period Date.\n     * @throws IOException\n     * @throws HttpException\n     * @throws EnmeFailOperation\n     */\n    @Test(timeout = 5000)\n    public void testGetGoGlShortUrl() throws HttpException, IOException, EnmeFailOperation{\n        //System.out.println(SocialUtils.getGoGl(\"http://blog.jotadeveloper.com\",\n         //                                       \"AIzaSyCvEMnlGa4q4Suayx1bMYXg-Wkf1jYmmaQ\"));\n    }\n\n    @Test(timeout = 5000)\n    public void testgetTinyUrl() throws HttpException, IOException{\n       // System.out.println(SocialUtils.getTinyUrl(\"http://blog.jotadeveloper.com\"));\n    }\n\n    @Test(timeout = 5000)\n    public void testgetGoogleStas() throws HttpException, IOException{\n       // System.out.println(SocialUtils.getGoGlStats(\"http://blog.jotadeveloper.com\"));\n    }\n\n    @Test(timeout = 5000)\n    public void testgetBitLy() throws HttpException, IOException, EnmeFailOperation{\n        //System.out.println(SocialUtils.getBitLy(\"http://blog.jotadeveloper.com\",\n         //       \"R_5ea5369d4eee11edbd860ec8ef5dc7a0\", \"jotadeveloper\"));\n        //System.out.println(SocialUtils.getBitLy(\"http://www.encuestame.org\",\n         //       \"R_5ea5369d4eee11edbd860ec8ef5dc7a0\", \"jotadeveloper\"));\n    }\n}", "class_id": 0, "repo": "encuestame/encuestame", "file": "enme-core/src/test/java/org/encuestame/core/test/util/SocialUtilsTestCase.java", "last_update_at": "2019-07-17T14:31:03+00:00", "question_id": "c4384f0415035b18e6ac59d1df420fcfec693011", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Category(DefaultTest.class)\npublic class SocialUtilsTestCase extends TestCase{\n    /**\n     * Test Period Date.\n     * @throws IOException\n     * @throws HttpException\n     * @throws EnmeFailOperation\n     */\n    @Test(timeout = 5000)\n    public void testGetGoGlShortUrl() throws HttpException, IOException, EnmeFailOperation{\n        //System.out.println(SocialUtils.getGoGl(\"http://blog.jotadeveloper.com\",\n         //                                       \"AIzaSyCvEMnlGa4q4Suayx1bMYXg-Wkf1jYmmaQ\"));\n    }\n    @Test(timeout = 5000)\n    public void testgetTinyUrl() throws HttpException, IOException{\n       // System.out.println(SocialUtils.getTinyUrl(\"http://blog.jotadeveloper.com\"));\n    }\n    @Test(timeout = 5000)\n    public void testgetGoogleStas() throws HttpException, IOException{\n       // System.out.println(SocialUtils.getGoGlStats(\"http://blog.jotadeveloper.com\"));\n    }\n    @Test(timeout = 5000)\n    public void testgetBitLy() throws HttpException, IOException, EnmeFailOperation{\n        //System.out.println(SocialUtils.getBitLy(\"http://blog.jotadeveloper.com\",\n         //       \"R_5ea5369d4eee11edbd860ec8ef5dc7a0\", \"jotadeveloper\"));\n        //System.out.println(SocialUtils.getBitLy(\"http://www.encuestame.org\",\n         //       \"R_5ea5369d4eee11edbd860ec8ef5dc7a0\", \"jotadeveloper\"));\n    }\n"]]}
{"hexsha": "3c03439e87a969828a0d3ab9289436457057f412", "ext": "java", "lang": "Java", "content": "public class EightQueen {\n\n    int result[] = new int[8];\n\n    public void solution() {\n        cal(0);\n\n    }\n\n    private void cal(int row) {\n        if (row == 8) {\n            print();\n            return;\n        }\n        for (int col = 0; col < 8; ++col) {\n            if (isOk(row, col)) {\n                result[row] = col;\n                cal(row + 1);\n            }\n        }\n    }\n\n    private boolean isOk(int row, int column) {\n        int leftup = column - 1;\n        int rightup = column + 1;\n        for (int i = row - 1; i >= 0; --i) {\n            if (result[i] == column) {\n                return false;\n            }\n            if (leftup >= 0) {\n                if (result[i] == leftup) {\n                    return false;\n                }\n            }\n            if (rightup < 8) {\n                if (result[i] == rightup) {\n                    return false;\n                }\n            }\n            --leftup;\n            ++rightup;\n        }\n        return true;\n    }\n\n    private void print() {\n        for (int row = 0; row < 8; ++row) {\n            for (int col = 0; col < 8; ++col) {\n                if (result[row] == col) {\n                    System.out.print(\"Q \");\n                } else {\n                    System.out.print(\"* \");\n                }\n            }\n            System.out.println();\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        EightQueen eightQueen = new EightQueen();\n        eightQueen.solution();\n    }\n}", "class_id": 0, "repo": "ljm516/java-knowledge", "file": "java-in-depth/src/main/java/top/ljming/javaindepth/dsa/lesson/geekbang/EightQueen.java", "last_update_at": "2019-10-24T13:37:54+00:00", "question_id": "3c03439e87a969828a0d3ab9289436457057f412", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EightQueen {\n    int result[] = new int[8];\n    public void solution() {\n        cal(0);\n    }\n    private void cal(int row) {\n        if (row == 8) {\n            print();\n            return;\n        }\n        for (int col = 0; col < 8; ++col) {\n            if (isOk(row, col)) {\n                result[row] = col;\n                cal(row + 1);\n            }\n        }\n    }\n    private boolean isOk(int row, int column) {\n        int leftup = column - 1;\n        int rightup = column + 1;\n        for (int i = row - 1; i >= 0; --i) {\n            if (result[i] == column) {\n                return false;\n            }\n            if (leftup >= 0) {\n                if (result[i] == leftup) {\n                    return false;\n                }\n            }\n            if (rightup < 8) {\n                if (result[i] == rightup) {\n                    return false;\n                }\n            }\n            --leftup;\n            ++rightup;\n        }\n        return true;\n    }\n    private void print() {\n        for (int row = 0; row < 8; ++row) {\n            for (int col = 0; col < 8; ++col) {\n                if (result[row] == col) {\n                    System.out.print(\"Q \");\n                } else {\n                    System.out.print(\"* \");\n                }\n            }\n            System.out.println();\n        }\n        System.out.println();\n    }\n    public static void main(String[] args) {\n        EightQueen eightQueen = new EightQueen();\n        eightQueen.solution();\n    }\n"]]}
{"hexsha": "2617b47296faa5004cccc34808cd207c355eab21", "ext": "java", "lang": "Java", "content": "public class CuratorManager implements Managed {\n\n    private final CuratorFramework framework;\n\n    /**\n     * Constructor\n     * \n     * @param framework\n     *            {@link CuratorFramework}\n     */\n    public CuratorManager(@Nonnull final CuratorFramework framework) {\n        this.framework = checkNotNull(framework);\n        // start framework directly to allow other bundles to interact with\n        // zookeeper during their run() method.\n        if (this.framework.getState() != CuratorFrameworkState.STARTED) {\n            this.framework.start();\n        }\n    }\n\n    @Override\n    public void start() throws Exception {\n        framework.blockUntilConnected();\n        final Stat stat = framework.checkExists().forPath(\"/\");\n        if (stat == null) {\n            // ensure that the root path is available\n            framework.create().creatingParentsIfNeeded().forPath(\"/\");\n        }\n    }\n\n    @Override\n    public void stop() throws Exception {\n        framework.close();\n    }\n}", "class_id": 0, "repo": "dropwizard/dropwizard-discovery", "file": "src/main/java/io/dropwizard/discovery/manage/CuratorManager.java", "last_update_at": "2019-10-02T07:24:23+00:00", "question_id": "2617b47296faa5004cccc34808cd207c355eab21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CuratorManager implements Managed {\n    private final CuratorFramework framework;\n    /**\n     * Constructor\n     * \n     * @param framework\n     *            {@link CuratorFramework}\n     */\n    public CuratorManager(@Nonnull final CuratorFramework framework) {\n        this.framework = checkNotNull(framework);\n        // start framework directly to allow other bundles to interact with\n        // zookeeper during their run() method.\n        if (this.framework.getState() != CuratorFrameworkState.STARTED) {\n            this.framework.start();\n        }\n    }\n    @Override\n    public void start() throws Exception {\n        framework.blockUntilConnected();\n        final Stat stat = framework.checkExists().forPath(\"/\");\n        if (stat == null) {\n            // ensure that the root path is available\n            framework.create().creatingParentsIfNeeded().forPath(\"/\");\n        }\n    }\n    @Override\n    public void stop() throws Exception {\n        framework.close();\n    }\n"]]}
{"hexsha": "d1e9f855c4ac0a28d2aa075d4a0fe624ff98b5cb", "ext": "java", "lang": "Java", "content": "@RestController\npublic class SpspController {\n\n  private final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n  private final StreamReceiver streamReceiver;\n  private final UrlPathHelper urlPathHelper;\n  private final Supplier<SpspServerSettings> spspServerSettingsSupplier;\n\n  public SpspController(\n    final Supplier<SpspServerSettings> spspServerSettingsSupplier,\n    final StreamReceiver streamReceiver\n  ) {\n    this.streamReceiver = Objects.requireNonNull(streamReceiver);\n    this.spspServerSettingsSupplier = spspServerSettingsSupplier;\n    this.urlPathHelper = new UrlPathHelper();\n  }\n\n  /**\n   * A simple SPSP endpoint that merely returns a new Shared Secret and destination address to support a stateless\n   * receiver.\n   *\n   * @param accountId The SPSP path, as a {@link String}.\n   *\n   * @return\n   */\n  @RequestMapping(\n    path = \"/{account_id}/**\", method = RequestMethod.GET,\n    produces = {\"application/spsp4+json\", APPLICATION_JSON_VALUE, MediaTypes.PROBLEM_VALUE}\n  )\n  public ResponseEntity<StreamConnectionDetails> getSpspResponse(\n    @PathVariable(\"account_id\") final String accountId,\n    final HttpServletRequest servletRequest\n  ) {\n    Objects.requireNonNull(accountId);\n\n    String paymentTarget = this.urlPathHelper.getPathWithinApplication(servletRequest).replaceAll(\"/\", \".\");\n    if (paymentTarget.startsWith(\".\")) {\n      paymentTarget = paymentTarget.replaceFirst(\".\", \"\");\n    }\n    if (paymentTarget.endsWith(\".\")) {\n      paymentTarget = paymentTarget.substring(0, paymentTarget.length() - 1);\n    }\n\n    final InterledgerAddress paymentReceiverAddress = spspServerSettingsSupplier.get().operatorAddress()\n      .with(paymentTarget);\n\n    final StreamConnectionDetails connectionDetails = streamReceiver.setupStream(paymentReceiverAddress);\n    final org.interledger.spsp.server.model.StreamConnectionDetails returnableStreamConnectionDetails =\n      org.interledger.spsp.server.model.StreamConnectionDetails.builder()\n        .destinationAddress(connectionDetails.destinationAddress())\n        .sharedSecretBase64(Base64.getEncoder().encodeToString(connectionDetails.sharedSecret().key()))\n        .build();\n    final HttpHeaders headers = new HttpHeaders();\n    headers.setContentType(MediaType.APPLICATION_JSON);\n\n    // TODO: Add client-cache directive per RFC (i.e., configurable max-age).\n    return new ResponseEntity(returnableStreamConnectionDetails, headers, HttpStatus.OK);\n  }\n}", "class_id": 0, "repo": "nhartner/ilp-spsp-server", "file": "src/main/java/org/interledger/spsp/server/controllers/SpspController.java", "last_update_at": "2019-11-22T22:52:48+00:00", "question_id": "d1e9f855c4ac0a28d2aa075d4a0fe624ff98b5cb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RestController\npublic class SpspController {\n  private final Logger logger = LoggerFactory.getLogger(this.getClass());\n  private final StreamReceiver streamReceiver;\n  private final UrlPathHelper urlPathHelper;\n  private final Supplier<SpspServerSettings> spspServerSettingsSupplier;\n  public SpspController(\n    final Supplier<SpspServerSettings> spspServerSettingsSupplier,\n    final StreamReceiver streamReceiver\n  ) {\n    this.streamReceiver = Objects.requireNonNull(streamReceiver);\n    this.spspServerSettingsSupplier = spspServerSettingsSupplier;\n    this.urlPathHelper = new UrlPathHelper();\n  }\n  /**\n   * A simple SPSP endpoint that merely returns a new Shared Secret and destination address to support a stateless\n   * receiver.\n   *\n   * @param accountId The SPSP path, as a {@link String}.\n   *\n   * @return\n   */\n  @RequestMapping(\n    path = \"/{account_id}/**\", method = RequestMethod.GET,\n    produces = {\"application/spsp4+json\", APPLICATION_JSON_VALUE, MediaTypes.PROBLEM_VALUE}\n  )\n  public ResponseEntity<StreamConnectionDetails> getSpspResponse(\n    @PathVariable(\"account_id\") final String accountId,\n    final HttpServletRequest servletRequest\n  ) {\n    Objects.requireNonNull(accountId);\n    String paymentTarget = this.urlPathHelper.getPathWithinApplication(servletRequest).replaceAll(\"/\", \".\");\n    if (paymentTarget.startsWith(\".\")) {\n      paymentTarget = paymentTarget.replaceFirst(\".\", \"\");\n    }\n    if (paymentTarget.endsWith(\".\")) {\n      paymentTarget = paymentTarget.substring(0, paymentTarget.length() - 1);\n    }\n    final InterledgerAddress paymentReceiverAddress = spspServerSettingsSupplier.get().operatorAddress()\n      .with(paymentTarget);\n    final StreamConnectionDetails connectionDetails = streamReceiver.setupStream(paymentReceiverAddress);\n    final org.interledger.spsp.server.model.StreamConnectionDetails returnableStreamConnectionDetails =\n      org.interledger.spsp.server.model.StreamConnectionDetails.builder()\n        .destinationAddress(connectionDetails.destinationAddress())\n        .sharedSecretBase64(Base64.getEncoder().encodeToString(connectionDetails.sharedSecret().key()))\n        .build();\n    final HttpHeaders headers = new HttpHeaders();\n    headers.setContentType(MediaType.APPLICATION_JSON);\n    // TODO: Add client-cache directive per RFC (i.e., configurable max-age).\n    return new ResponseEntity(returnableStreamConnectionDetails, headers, HttpStatus.OK);\n  }\n"]]}
{"hexsha": "7f063e02da7239b80f8210e703f815bf861362c7", "ext": "java", "lang": "Java", "content": "@RunWith(Arquillian.class)\n@RunAsClient\npublic class MPClientCollectionTest {\n    protected static final Logger LOG = Logger.getLogger(MPCollectionTest.class.getName());\n    private static final String WAR_SERVICE = \"war_service\";\n    private static final String WAR_CLIENT = \"war_client\";\n\n    @Deployment(name=WAR_SERVICE)\n    public static Archive<?> serviceDeploy() {\n        WebArchive war = TestUtil.prepareArchive(WAR_SERVICE);\n        war.addClasses(MPCollectionService.class,\n                MPCollectionActivator.class);\n        return TestUtil.finishContainerPrepare(war, null, null);\n    }\n\n    @Deployment(name=WAR_CLIENT)\n    public static Archive<?> clientDeploy() {\n        WebArchive war = TestUtil.prepareArchive(WAR_CLIENT);\n        war.addClasses(MPCollectionResource.class,\n                MPCollectionServiceIntf.class,\n                MPPatronActivator.class);\n        return TestUtil.finishContainerPrepare(war, null, null);\n    }\n\n    static ResteasyClient client;\n    @BeforeClass\n    public static void before() throws Exception {\n        client = (ResteasyClient)ClientBuilder.newClient();\n    }\n\n    @AfterClass\n    public static void after() throws Exception {\n        client.close();\n    }\n\n    private String generateURL(String path, String deployName) {\n        return PortProviderUtil.generateURL(path, deployName);\n    }\n\n    @Test\n    public void preTest() throws Exception {\n        // pre-test, confirm the service is reachable\n        // If this test fails the other tests will not pass\n        Response response = client.target(\n                generateURL(\"/theService/ping\", WAR_SERVICE)).request().get();\n        Assert.assertEquals(200, response.getStatus());\n        Assert.assertEquals(\"pong\", response.readEntity(String.class));\n    }\n\n    @Test\n    public void testStringReturnType() throws Exception {\n\n        // Test service is accessed via injection\n        // Test endpoint with simple (String) return type\n        Response response = client.target(\n                generateURL(\"/thePatron/checking\", WAR_CLIENT)).request().get();\n        Assert.assertEquals(200, response.getStatus());\n        Assert.assertEquals(\"pong thePatron\", response.readEntity(String.class));\n    }\n\n    @Test\n    public void testGenericTypeReturnType() throws Exception {\n        // Test service is accessed via injection\n        // Test endpoint with GenericType return type\n        Response response = client.target(\n                generateURL(\"/thePatron/got\", WAR_CLIENT)).request().get();\n        Assert.assertEquals(200, response.getStatus());\n        List<String> l = response.readEntity(new GenericType<List<String>>() {});\n        Assert.assertEquals(4, l.size());\n        Assert.assertEquals(\"thePatron\", l.get(3));\n    }\n}", "class_id": 0, "repo": "rsvoboda/Resteasy", "file": "testsuite/integration-tests/src/test/java/org/jboss/resteasy/test/microprofile/restclient/MPClientCollectionTest.java", "last_update_at": "2019-06-21T00:01:16+00:00", "question_id": "7f063e02da7239b80f8210e703f815bf861362c7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(Arquillian.class)\n@RunAsClient\npublic class MPClientCollectionTest {\n    protected static final Logger LOG = Logger.getLogger(MPCollectionTest.class.getName());\n    private static final String WAR_SERVICE = \"war_service\";\n    private static final String WAR_CLIENT = \"war_client\";\n    @Deployment(name=WAR_SERVICE)\n    public static Archive<?> serviceDeploy() {\n        WebArchive war = TestUtil.prepareArchive(WAR_SERVICE);\n        war.addClasses(MPCollectionService.class,\n                MPCollectionActivator.class);\n        return TestUtil.finishContainerPrepare(war, null, null);\n    }\n    @Deployment(name=WAR_CLIENT)\n    public static Archive<?> clientDeploy() {\n        WebArchive war = TestUtil.prepareArchive(WAR_CLIENT);\n        war.addClasses(MPCollectionResource.class,\n                MPCollectionServiceIntf.class,\n                MPPatronActivator.class);\n        return TestUtil.finishContainerPrepare(war, null, null);\n    }\n    static ResteasyClient client;\n    @BeforeClass\n    public static void before() throws Exception {\n        client = (ResteasyClient)ClientBuilder.newClient();\n    }\n    @AfterClass\n    public static void after() throws Exception {\n        client.close();\n    }\n    private String generateURL(String path, String deployName) {\n        return PortProviderUtil.generateURL(path, deployName);\n    }\n    @Test\n    public void preTest() throws Exception {\n        // pre-test, confirm the service is reachable\n        // If this test fails the other tests will not pass\n        Response response = client.target(\n                generateURL(\"/theService/ping\", WAR_SERVICE)).request().get();\n        Assert.assertEquals(200, response.getStatus());\n        Assert.assertEquals(\"pong\", response.readEntity(String.class));\n    }\n    @Test\n    public void testStringReturnType() throws Exception {\n        // Test service is accessed via injection\n        // Test endpoint with simple (String) return type\n        Response response = client.target(\n                generateURL(\"/thePatron/checking\", WAR_CLIENT)).request().get();\n        Assert.assertEquals(200, response.getStatus());\n        Assert.assertEquals(\"pong thePatron\", response.readEntity(String.class));\n    }\n    @Test\n    public void testGenericTypeReturnType() throws Exception {\n        // Test service is accessed via injection\n        // Test endpoint with GenericType return type\n        Response response = client.target(\n                generateURL(\"/thePatron/got\", WAR_CLIENT)).request().get();\n        Assert.assertEquals(200, response.getStatus());\n        List<String> l = response.readEntity(new GenericType<List<String>>() {});\n        Assert.assertEquals(4, l.size());\n        Assert.assertEquals(\"thePatron\", l.get(3));\n    }\n"]]}
{"hexsha": "b5876612483b981d46d65bed168dc3f7cc20f03e", "ext": "java", "lang": "Java", "content": "public class InService {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(InService.class);\n\n    private final PlantOutRepository plantOutRepository;\n    private final PlantInRepository plantInRepository;\n    private final DetailInRepository detailInRepository;\n\n    public InService(\n            final PlantOutRepository plantOutRepository,\n            final PlantInRepository plantInRepository,\n            final DetailInRepository detailInRepository\n    ) {\n        this.plantOutRepository = plantOutRepository;\n        this.plantInRepository = plantInRepository;\n        this.detailInRepository = detailInRepository;\n    }\n\n    public void write(\n            final UUID userId,\n            final String type,\n            final String password,\n            final Date inTimestamp,\n            final double temperature,\n            final double humidity,\n            final double light,\n            final double conductivity\n    ) throws ConsumeException {\n\n        final Optional<Plant> optionalPlant = this.plantOutRepository.getByUserId(userId);\n\n        if (!optionalPlant.isPresent()) {\n            final String problem = String.format(\"No plant with user id [%s]\", userId);\n            LOGGER.warn(problem);\n            throw new ConsumeException(problem);\n        }\n\n        final Plant plant = optionalPlant.get();\n\n        if (!PasswordHasher.verify(plant.getPassword(), password)) {\n            final String problem = String.format(\"Password [%s] is incorrect for plant with user id [%s]\", password, userId);\n            LOGGER.warn(problem);\n            throw new ConsumeException(problem);\n        }\n\n        // If type is different, get it in\n        // TODO Validate type when there's something to validate against.\n        // TODO Possible an enum of acceptable plants\n        if (StringUtils.isNotBlank(type) && !type.equalsIgnoreCase(plant.getType())) {\n            this.plantInRepository.updateType(type, plant.getId());\n        }\n\n        // We're going to trust the date\n\n        // TODO Ugh.\n        final boolean temperatureValid = verify(temperature);\n        final boolean humidityValid = verify(humidity);\n        final boolean lightValid = verify(light);\n        final boolean conductivityValid = verify(conductivity);\n\n        if (temperatureValid && humidityValid && lightValid && conductivityValid) {\n            try {\n                this.detailInRepository.save(plant.getId(), inTimestamp, temperature, humidity, light, conductivity);\n            } catch (UnableToExecuteStatementException e) {\n                LOGGER.warn(\"SQL problem saving detail\", e);\n            }\n        } else {\n            final String problem = String.format(\n                    \"Data invalid for detail - plantId: [%d], inTimestamp: [%s], temp: [%f], hum: [%f], light: [%f], cond: [%f]\",\n                    plant.getId(), inTimestamp, temperature, humidity, light, conductivity\n            );\n            LOGGER.warn(problem);\n            throw new ConsumeException(problem);\n        }\n\n    }\n\n    // TODO This could do with being pulled out and unit tested, it is likely to change\n    // TODO Also, different verification is likely to take place on the different numbers...\n    // TODO e.g temperature probably won't be 0 to infinity\n    private boolean verify(double candidate) {\n        return candidate >= 0;\n    }\n\n}", "class_id": 0, "repo": "JohnSharpe/plantlive", "file": "src/main/java/com/jsharpe/plantlive/consume/InService.java", "last_update_at": "2019-08-14T10:24:51+00:00", "question_id": "b5876612483b981d46d65bed168dc3f7cc20f03e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class InService {\n    private static final Logger LOGGER = LoggerFactory.getLogger(InService.class);\n    private final PlantOutRepository plantOutRepository;\n    private final PlantInRepository plantInRepository;\n    private final DetailInRepository detailInRepository;\n    public InService(\n            final PlantOutRepository plantOutRepository,\n            final PlantInRepository plantInRepository,\n            final DetailInRepository detailInRepository\n    ) {\n        this.plantOutRepository = plantOutRepository;\n        this.plantInRepository = plantInRepository;\n        this.detailInRepository = detailInRepository;\n    }\n    public void write(\n            final UUID userId,\n            final String type,\n            final String password,\n            final Date inTimestamp,\n            final double temperature,\n            final double humidity,\n            final double light,\n            final double conductivity\n    ) throws ConsumeException {\n        final Optional<Plant> optionalPlant = this.plantOutRepository.getByUserId(userId);\n        if (!optionalPlant.isPresent()) {\n            final String problem = String.format(\"No plant with user id [%s]\", userId);\n            LOGGER.warn(problem);\n            throw new ConsumeException(problem);\n        }\n        final Plant plant = optionalPlant.get();\n        if (!PasswordHasher.verify(plant.getPassword(), password)) {\n            final String problem = String.format(\"Password [%s] is incorrect for plant with user id [%s]\", password, userId);\n            LOGGER.warn(problem);\n            throw new ConsumeException(problem);\n        }\n        // If type is different, get it in\n        // TODO Validate type when there's something to validate against.\n        // TODO Possible an enum of acceptable plants\n        if (StringUtils.isNotBlank(type) && !type.equalsIgnoreCase(plant.getType())) {\n            this.plantInRepository.updateType(type, plant.getId());\n        }\n        // We're going to trust the date\n        // TODO Ugh.\n        final boolean temperatureValid = verify(temperature);\n        final boolean humidityValid = verify(humidity);\n        final boolean lightValid = verify(light);\n        final boolean conductivityValid = verify(conductivity);\n        if (temperatureValid && humidityValid && lightValid && conductivityValid) {\n            try {\n                this.detailInRepository.save(plant.getId(), inTimestamp, temperature, humidity, light, conductivity);\n            } catch (UnableToExecuteStatementException e) {\n                LOGGER.warn(\"SQL problem saving detail\", e);\n            }\n        } else {\n            final String problem = String.format(\n                    \"Data invalid for detail - plantId: [%d], inTimestamp: [%s], temp: [%f], hum: [%f], light: [%f], cond: [%f]\",\n                    plant.getId(), inTimestamp, temperature, humidity, light, conductivity\n            );\n            LOGGER.warn(problem);\n            throw new ConsumeException(problem);\n        }\n    }\n    // TODO This could do with being pulled out and unit tested, it is likely to change\n    // TODO Also, different verification is likely to take place on the different numbers...\n    // TODO e.g temperature probably won't be 0 to infinity\n    private boolean verify(double candidate) {\n        return candidate >= 0;\n    }\n"]]}
{"hexsha": "ce9cddc795975d7c65082cc6282c5b34f525ae0c", "ext": "java", "lang": "Java", "content": "public final class GLTracer implements InvocationHandler {\n    \n    private final Object obj;\n    private final IntMap<String> constMap;\n    private static final HashMap<String, IntMap<Void>> nonEnumArgMap = new HashMap<String, IntMap<Void>>();\n    \n    private static final String ANSI_RESET = \"\\u001B[0m\";\n    private static final String ANSI_BRIGHT = \"\\u001B[1m\";\n    private static final String ANSI_RED = \"\\u001B[31m\";\n    private static final String ANSI_GREEN = \"\\u001B[32m\";\n    private static final String ANSI_YELLOW = \"\\u001B[33m\";\n    private static final String ANSI_BLUE = \"\\u001B[34m\";\n    private static final String ANSI_MAGENTA = \"\\u001B[35m\";\n    private static final String ANSI_CYAN = \"\\u001B[36m\";\n\n    private static void noEnumArgs(String method, int... argSlots) {\n        IntMap<Void> argSlotsMap = new IntMap<>();\n        for (int argSlot : argSlots) {\n            argSlotsMap.put(argSlot, null);\n        }\n        nonEnumArgMap.put(method, argSlotsMap);\n    }\n    \n    static {\n        noEnumArgs(\"glViewport\", 0, 1, 2, 3);\n        noEnumArgs(\"glScissor\", 0, 1, 2, 3);\n        noEnumArgs(\"glClear\", 0);\n        noEnumArgs(\"glGetInteger\", 1);\n        noEnumArgs(\"glGetString\", 1);\n        \n        noEnumArgs(\"glBindTexture\", 1);\n        noEnumArgs(\"glPixelStorei\", 1);\n//        noEnumArgs(\"glTexParameteri\", 2);\n        noEnumArgs(\"glTexImage2D\", 1, 3, 4, 5);\n        noEnumArgs(\"glTexImage3D\", 1, 3, 4, 5, 6);\n        noEnumArgs(\"glTexSubImage2D\", 1, 2, 3, 4, 5);\n        noEnumArgs(\"glTexSubImage3D\", 1, 2, 3, 4, 5, 6, 7);\n        noEnumArgs(\"glCompressedTexImage2D\", 1, 3, 4, 5);\n        noEnumArgs(\"glCompressedTexSubImage3D\", 1, 2, 3, 4, 5, 6, 7);\n        noEnumArgs(\"glDeleteTextures\", 0);\n        noEnumArgs(\"glReadPixels\", 0, 1, 2, 3);\n        \n        noEnumArgs(\"glBindBuffer\", 1);\n        noEnumArgs(\"glEnableVertexAttribArray\", 0);\n        noEnumArgs(\"glDisableVertexAttribArray\", 0);\n        noEnumArgs(\"glVertexAttribPointer\", 0, 1, 4, 5);\n        noEnumArgs(\"glVertexAttribDivisorARB\", 0, 1);\n        noEnumArgs(\"glDrawRangeElements\", 1, 2, 3, 5);\n        noEnumArgs(\"glDrawArrays\", 1, 2);\n        noEnumArgs(\"glDeleteBuffers\", 0);\n        noEnumArgs(\"glBindVertexArray\", 0);\n        noEnumArgs(\"glGenVertexArrays\", 0);\n        \n        noEnumArgs(\"glBindFramebufferEXT\", 1);\n        noEnumArgs(\"glBindRenderbufferEXT\", 1);\n        noEnumArgs(\"glRenderbufferStorageEXT\", 2, 3);\n        noEnumArgs(\"glRenderbufferStorageMultisampleEXT\", 1, 3, 4);\n        noEnumArgs(\"glFramebufferRenderbufferEXT\", 3);\n        noEnumArgs(\"glFramebufferTexture2DEXT\", 3, 4);\n        noEnumArgs(\"glFramebufferTextureLayerEXT\", 2, 3, 4);\n        noEnumArgs(\"glBlitFramebufferEXT\", 0, 1, 2, 3, 4, 5, 6, 7, 8);\n        \n        noEnumArgs(\"glCreateProgram\", -1);\n        noEnumArgs(\"glCreateShader\", -1);\n        noEnumArgs(\"glShaderSource\", 0);\n        noEnumArgs(\"glCompileShader\", 0);\n        noEnumArgs(\"glGetShader\", 0);\n        noEnumArgs(\"glAttachShader\", 0, 1);\n        noEnumArgs(\"glLinkProgram\", 0);\n        noEnumArgs(\"glGetProgram\", 0);\n        noEnumArgs(\"glUseProgram\", 0);\n        noEnumArgs(\"glGetUniformLocation\", 0, -1);\n        noEnumArgs(\"glUniformMatrix3\", 0);\n        noEnumArgs(\"glUniformMatrix4\", 0);\n        noEnumArgs(\"glUniform1i\", 0, 1);\n        noEnumArgs(\"glUniform1f\", 0);\n        noEnumArgs(\"glUniform2f\", 0);\n        noEnumArgs(\"glUniform3f\", 0);\n        noEnumArgs(\"glUniform4\", 0);\n        noEnumArgs(\"glUniform4f\", 0);\n        noEnumArgs(\"glGetAttribLocation\", 0, -1);\n        noEnumArgs(\"glDetachShader\", 0, 1);\n        noEnumArgs(\"glDeleteShader\", 0);\n        noEnumArgs(\"glDeleteProgram\", 0);\n        noEnumArgs(\"glBindFragDataLocation\", 0, 1);\n    }\n    \n    public GLTracer(Object obj, IntMap<String> constMap) {\n        this.obj = obj;\n        this.constMap = constMap;\n    }\n    \n    private static IntMap<String> generateConstantMap(Class<?> ... classes) {\n        IntMap<String> constMap = new IntMap<>();\n        for (Class<?> clazz : classes) {\n            for (Field field : clazz.getFields()) {\n                if (field.getType() == int.class) {\n                    try {\n                        int val = field.getInt(null);\n                        String name = field.getName();\n                        constMap.put(val, name);\n                    } catch (IllegalArgumentException\n                            | IllegalAccessException ex) {\n                    }\n                }\n            }\n        }\n        // GL_ONE is more common than GL_TRUE (which is a boolean anyway)\n        constMap.put(1, \"GL_ONE\");\n        return constMap;\n    }\n    \n    /**\n     * Creates a tracer implementation that wraps OpenGL ES 2.\n     *\n     * @param glInterface OGL object to wrap\n     * @param glInterfaceClasses The interface(s) to implement\n     * @return A tracer that implements the given interface\n     */\n    public static Object createGlesTracer(Object glInterface, Class<?>... glInterfaceClasses) {\n        IntMap<String> constMap = generateConstantMap(GL.class, GL2.class, GL3.class, GLFbo.class, GLExt.class);\n        return Proxy.newProxyInstance(\n                glInterface.getClass().getClassLoader(),\n                glInterfaceClasses,\n                new GLTracer(glInterface, constMap));\n    }\n\n    /**\n     * Creates a tracer implementation that wraps OpenGL 2+.\n     * \n     * @param glInterface OGL object to wrap\n     * @param glInterfaceClasses The interface(s) to implement\n     * @return A tracer that implements the given interface\n     */\n    public static Object createDesktopGlTracer(Object glInterface, Class<?> ... glInterfaceClasses) {\n        IntMap<String> constMap = generateConstantMap(GL2.class, GL3.class, GL4.class, GLFbo.class, GLExt.class);\n        return Proxy.newProxyInstance(glInterface.getClass().getClassLoader(),\n                                      glInterfaceClasses, \n                                      new GLTracer(glInterface, constMap));\n    }\n    \n    private void printStyle(String style, String string) {\n        System.out.print(style + string + ANSI_RESET);\n    }\n    \n    private void print(String string) {\n        System.out.print(string);\n    }\n    \n    private void printInt(int value) {\n        print(Integer.toString(value));\n    }\n    \n    private void printEnum(int value) {\n        String enumName = constMap.get(value);\n        if (enumName != null) {\n            if (enumName.startsWith(\"GL_\")) {\n                enumName = enumName.substring(3);\n            }\n            if (enumName.endsWith(\"_EXT\") || enumName.endsWith(\"_ARB\")) {\n                enumName = enumName.substring(0, enumName.length() - 4);\n            }\n            printStyle(ANSI_GREEN, enumName);\n        } else {\n            printStyle(ANSI_GREEN, \"ENUM_\" + Integer.toHexString(value));\n        }\n    }\n    \n    private void printIntOrEnum(String method, int value, int argIndex) {\n        IntMap<Void> argSlotMap = nonEnumArgMap.get(method);\n        if (argSlotMap != null && argSlotMap.containsKey(argIndex)) {\n            printInt(value);\n        } else {\n            printEnum(value);\n        }\n    }\n    \n    private void printNewLine() {\n        System.out.println();\n    }\n    \n    private void printString(String value) {\n        if (value.length() > 150) {\n            value = value.substring(0, 150) + \"...\";\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(ANSI_YELLOW);\n        sb.append(\"\\\"\");\n        sb.append(ANSI_RESET);\n        for (String line : value.split(\"\\n\")) {\n            sb.append(ANSI_YELLOW);\n            sb.append(line.replaceAll(\"\\0\", \"\\\\\\\\0\"));\n            sb.append(ANSI_RESET);\n            sb.append(\"\\n\");\n        }\n        if (sb.length() > 1 && sb.charAt(sb.length() - 1) == '\\n') {\n            sb.setLength(sb.length() - 1);\n        }\n        sb.append(ANSI_YELLOW);\n        sb.append(\"\\\"\");\n        sb.append(ANSI_RESET);\n        print(sb.toString());\n    }\n    \n    private void printBoolean(boolean bool) {\n        printStyle(ANSI_BLUE, bool ? \"true\" : \"false\");\n    }\n    \n    private void printBuffer(Buffer buffer) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(ANSI_MAGENTA);\n        if (buffer instanceof ByteBuffer) {\n            sb.append(\"byte\");\n        } else if (buffer instanceof ShortBuffer) {\n            sb.append(\"short\");\n        } else if (buffer instanceof CharBuffer) { \n            sb.append(\"char\");\n        } else if (buffer instanceof FloatBuffer) {\n            sb.append(\"float\");\n        } else if (buffer instanceof IntBuffer) {\n            sb.append(\"int\");\n        } else if (buffer instanceof LongBuffer) {\n            sb.append(\"long\");\n        } else if (buffer instanceof DoubleBuffer) {\n            sb.append(\"double\");\n        } else {\n            throw new UnsupportedOperationException();\n        }\n        sb.append(ANSI_RESET);\n        sb.append(\"[\");\n        \n        if (buffer.position() == 0\n                && buffer.limit() == buffer.capacity()) {\n            // Common case. Just print buffer size.\n            sb.append(buffer.capacity());\n        } else {\n            sb.append(\"pos=\").append(buffer.position());\n            sb.append(\" lim=\").append(buffer.limit());\n            sb.append(\" cap=\").append(buffer.capacity());\n        }\n        \n        sb.append(\"]\");\n        print(sb.toString());\n    }\n    \n    private void printMethodName(String methodName) {\n        if (methodName.startsWith(\"gl\")) {\n            // GL calls which actually draw (as opposed to change state)\n            // will be printed in darker color\n            methodName = methodName.substring(2);\n            if (methodName.equals(\"Clear\")\n                    || methodName.equals(\"DrawRangeElements\")\n                    || methodName.equals(\"DrawElementsInstancedARB\")) {\n                print(methodName);\n            } else {\n                if (methodName.endsWith(\"EXT\")) {\n                    methodName = methodName.substring(0, methodName.length() - 3);\n                }\n                printStyle(ANSI_BRIGHT, methodName);\n            }\n        } else if (methodName.equals(\"resetStats\")) {\n            printStyle(ANSI_RED, \"-- frame boundary --\");\n        }\n    }\n    \n    private void printArgsClear(int mask) {\n        boolean needAPipe = false;\n        print(\"(\");\n        if ((mask & GL.GL_COLOR_BUFFER_BIT) != 0) {\n            printStyle(ANSI_GREEN, \"COLOR_BUFFER_BIT\");\n            needAPipe = true;\n        }\n        if ((mask & GL.GL_DEPTH_BUFFER_BIT) != 0) {\n            if (needAPipe) {\n                print(\" | \");\n            }\n            printStyle(ANSI_GREEN, \"DEPTH_BUFFER_BIT\");\n        }\n        if ((mask & GL.GL_STENCIL_BUFFER_BIT) != 0) {\n            if (needAPipe) {\n                print(\" | \");\n            }\n            printStyle(ANSI_GREEN, \"STENCIL_BUFFER_BIT\");\n        }\n        print(\")\");\n    }\n    \n    private void printArgsGetInteger(Object[] args) {\n        print(\"(\");\n        int param = (Integer)args[0];\n        IntBuffer ib = (IntBuffer) args[1];\n        printEnum(param);\n        print(\", \");\n        printOut();\n        if (param == GL2.GL_DRAW_BUFFER || param == GL2.GL_READ_BUFFER) {\n            printEnum(ib.get(0));\n        } else {\n            printInt(ib.get(0));\n        }\n        print(\")\");\n    }\n    \n    private void printArgsTexParameter(Object[] args) {\n        print(\"(\");\n\n        int target = (Integer) args[0];\n        int param = (Integer) args[1];\n        int value = (Integer) args[2];\n\n        printEnum(target);\n        print(\", \");\n        printEnum(param);\n        print(\", \");\n        \n        if (param == GL2.GL_TEXTURE_BASE_LEVEL\n                || param == GL2.GL_TEXTURE_MAX_LEVEL) {\n            printInt(value);\n        } else {\n            printEnum(value);\n        }\n        \n        print(\")\");\n    }\n    \n    private void printOut() {\n        printStyle(ANSI_CYAN, \"out=\");\n    }\n    \n    private void printResult(String methodName, Object result, Class<?> returnType) {\n        if (returnType != void.class) {\n            print(\" = \");\n            if (result instanceof String) {\n                printString((String) result);\n            } else if (returnType == int.class) {\n                int val = (Integer) result;\n                printIntOrEnum(methodName, val, -1);\n            } else if (returnType == boolean.class) {\n                printBoolean((Boolean)result);\n            } else {\n                print(\" = ???\");\n            }\n        }\n    }\n    \n    private void printNull() {\n        printStyle(ANSI_BLUE, \"null\");\n    }\n    \n    private void printArgs(String methodName, Object[] args, Class<?>[] paramTypes) {\n        if (methodName.equals(\"glClear\")) {\n            printArgsClear((Integer)args[0]);\n            return;\n        } else if (methodName.equals(\"glTexParameteri\")) {\n            printArgsTexParameter(args);\n            return;\n        } else if (methodName.equals(\"glGetInteger\")) {\n            printArgsGetInteger(args);\n            return;\n        }\n        \n        if (args == null) {\n            print(\"()\");\n            return;\n        }\n        \n        print(\"(\");\n        for (int i = 0; i < args.length; i++) {\n            if (paramTypes[i] == int.class) {\n                int val = (Integer)args[i];\n                printIntOrEnum(methodName, val, i);\n            } else if (paramTypes[i] == boolean.class) {\n                printBoolean((Boolean)args[i]);\n            } else if (paramTypes[i] == String.class) {\n                printString((String)args[i]);\n            } else if (paramTypes[i] == String[].class) {\n                String[] arr = (String[]) args[i];\n                if (arr.length == 1) {\n                    printString(arr[0]);\n                } else {\n                    print(\"string[\" + arr.length + \"]\");\n                }\n            } else if (args[i] instanceof IntBuffer) {\n                IntBuffer buf = (IntBuffer) args[i];\n                if (buf.capacity() == 16) {\n                    int val = buf.get(0);\n                    printOut();\n                    printIntOrEnum(methodName, val, i);\n                } else if (buf.capacity() == 1) {\n                    printOut();\n                    print(Integer.toString(buf.get(0)));\n                } else {\n                    printBuffer(buf);\n                }\n            } else if (args[i] instanceof ByteBuffer) {\n                ByteBuffer bb = (ByteBuffer)args[i];\n                if (bb.capacity() == 250) {\n                    printOut();\n                    printBoolean(bb.get(0) != 0);\n                } else {\n                    printBuffer(bb);\n                }\n            } else if (args[i] instanceof Buffer) {\n                printBuffer((Buffer)args[i]);\n            } else if (args[i] != null) {\n                print(args[i].toString());\n            } else {\n                printNull();\n            }\n\n            if (i != args.length - 1) {\n                System.out.print(\", \");\n            }\n        }\n        print(\")\");\n    }\n    \n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        String methodName = method.getName();\n        printMethodName(methodName);\n        \n        if (methodName.startsWith(\"gl\")) {\n            try {\n                // Try to evaluate result first, so we can see output values.\n                Object result = method.invoke(obj, args);\n                printArgs(methodName, args, method.getParameterTypes());\n                printResult(methodName, result, method.getReturnType());\n                printNewLine();\n                return result;\n            } catch (Throwable ex) {\n                // Execution failed, print args anyway\n                // but output values will be incorrect.\n                printArgs(methodName, args, method.getParameterTypes());\n                printNewLine();\n                System.out.println(\"\\tException occurred!\");\n                System.out.println(ex.toString());\n                throw ex;\n            }\n        } else {\n            printNewLine();\n            return method.invoke(obj, args);\n        }\n    }\n}", "class_id": 0, "repo": "bob0bob/jmonkeyengine", "file": "jme3-core/src/main/java/com/jme3/renderer/opengl/GLTracer.java", "last_update_at": "2019-04-15T17:02:51+00:00", "question_id": "ce9cddc795975d7c65082cc6282c5b34f525ae0c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class GLTracer implements InvocationHandler {\n    private final Object obj;\n    private final IntMap<String> constMap;\n    private static final HashMap<String, IntMap<Void>> nonEnumArgMap = new HashMap<String, IntMap<Void>>();\n    private static final String ANSI_RESET = \"\\u001B[0m\";\n    private static final String ANSI_BRIGHT = \"\\u001B[1m\";\n    private static final String ANSI_RED = \"\\u001B[31m\";\n    private static final String ANSI_GREEN = \"\\u001B[32m\";\n    private static final String ANSI_YELLOW = \"\\u001B[33m\";\n    private static final String ANSI_BLUE = \"\\u001B[34m\";\n    private static final String ANSI_MAGENTA = \"\\u001B[35m\";\n    private static final String ANSI_CYAN = \"\\u001B[36m\";\n    private static void noEnumArgs(String method, int... argSlots) {\n        IntMap<Void> argSlotsMap = new IntMap<>();\n        for (int argSlot : argSlots) {\n            argSlotsMap.put(argSlot, null);\n        }\n        nonEnumArgMap.put(method, argSlotsMap);\n    }\n    static {\n        noEnumArgs(\"glViewport\", 0, 1, 2, 3);\n        noEnumArgs(\"glScissor\", 0, 1, 2, 3);\n        noEnumArgs(\"glClear\", 0);\n        noEnumArgs(\"glGetInteger\", 1);\n        noEnumArgs(\"glGetString\", 1);\n        noEnumArgs(\"glBindTexture\", 1);\n        noEnumArgs(\"glPixelStorei\", 1);\n//        noEnumArgs(\"glTexParameteri\", 2);\n        noEnumArgs(\"glTexImage2D\", 1, 3, 4, 5);\n        noEnumArgs(\"glTexImage3D\", 1, 3, 4, 5, 6);\n        noEnumArgs(\"glTexSubImage2D\", 1, 2, 3, 4, 5);\n        noEnumArgs(\"glTexSubImage3D\", 1, 2, 3, 4, 5, 6, 7);\n        noEnumArgs(\"glCompressedTexImage2D\", 1, 3, 4, 5);\n        noEnumArgs(\"glCompressedTexSubImage3D\", 1, 2, 3, 4, 5, 6, 7);\n        noEnumArgs(\"glDeleteTextures\", 0);\n        noEnumArgs(\"glReadPixels\", 0, 1, 2, 3);\n        noEnumArgs(\"glBindBuffer\", 1);\n        noEnumArgs(\"glEnableVertexAttribArray\", 0);\n        noEnumArgs(\"glDisableVertexAttribArray\", 0);\n        noEnumArgs(\"glVertexAttribPointer\", 0, 1, 4, 5);\n        noEnumArgs(\"glVertexAttribDivisorARB\", 0, 1);\n        noEnumArgs(\"glDrawRangeElements\", 1, 2, 3, 5);\n        noEnumArgs(\"glDrawArrays\", 1, 2);\n        noEnumArgs(\"glDeleteBuffers\", 0);\n        noEnumArgs(\"glBindVertexArray\", 0);\n        noEnumArgs(\"glGenVertexArrays\", 0);\n        noEnumArgs(\"glBindFramebufferEXT\", 1);\n        noEnumArgs(\"glBindRenderbufferEXT\", 1);\n        noEnumArgs(\"glRenderbufferStorageEXT\", 2, 3);\n        noEnumArgs(\"glRenderbufferStorageMultisampleEXT\", 1, 3, 4);\n        noEnumArgs(\"glFramebufferRenderbufferEXT\", 3);\n        noEnumArgs(\"glFramebufferTexture2DEXT\", 3, 4);\n        noEnumArgs(\"glFramebufferTextureLayerEXT\", 2, 3, 4);\n        noEnumArgs(\"glBlitFramebufferEXT\", 0, 1, 2, 3, 4, 5, 6, 7, 8);\n        noEnumArgs(\"glCreateProgram\", -1);\n        noEnumArgs(\"glCreateShader\", -1);\n        noEnumArgs(\"glShaderSource\", 0);\n        noEnumArgs(\"glCompileShader\", 0);\n        noEnumArgs(\"glGetShader\", 0);\n        noEnumArgs(\"glAttachShader\", 0, 1);\n        noEnumArgs(\"glLinkProgram\", 0);\n        noEnumArgs(\"glGetProgram\", 0);\n        noEnumArgs(\"glUseProgram\", 0);\n        noEnumArgs(\"glGetUniformLocation\", 0, -1);\n        noEnumArgs(\"glUniformMatrix3\", 0);\n        noEnumArgs(\"glUniformMatrix4\", 0);\n        noEnumArgs(\"glUniform1i\", 0, 1);\n        noEnumArgs(\"glUniform1f\", 0);\n        noEnumArgs(\"glUniform2f\", 0);\n        noEnumArgs(\"glUniform3f\", 0);\n        noEnumArgs(\"glUniform4\", 0);\n        noEnumArgs(\"glUniform4f\", 0);\n        noEnumArgs(\"glGetAttribLocation\", 0, -1);\n        noEnumArgs(\"glDetachShader\", 0, 1);\n        noEnumArgs(\"glDeleteShader\", 0);\n        noEnumArgs(\"glDeleteProgram\", 0);\n        noEnumArgs(\"glBindFragDataLocation\", 0, 1);\n    }\n    public GLTracer(Object obj, IntMap<String> constMap) {\n        this.obj = obj;\n        this.constMap = constMap;\n    }\n    private static IntMap<String> generateConstantMap(Class<?> ... classes) {\n        IntMap<String> constMap = new IntMap<>();\n        for (Class<?> clazz : classes) {\n            for (Field field : clazz.getFields()) {\n                if (field.getType() == int.class) {\n                    try {\n                        int val = field.getInt(null);\n                        String name = field.getName();\n                        constMap.put(val, name);\n                    } catch (IllegalArgumentException\n                            | IllegalAccessException ex) {\n                    }\n                }\n            }\n        }\n        // GL_ONE is more common than GL_TRUE (which is a boolean anyway)\n        constMap.put(1, \"GL_ONE\");\n        return constMap;\n    }\n    /**\n     * Creates a tracer implementation that wraps OpenGL ES 2.\n     *\n     * @param glInterface OGL object to wrap\n     * @param glInterfaceClasses The interface(s) to implement\n     * @return A tracer that implements the given interface\n     */\n    public static Object createGlesTracer(Object glInterface, Class<?>... glInterfaceClasses) {\n        IntMap<String> constMap = generateConstantMap(GL.class, GL2.class, GL3.class, GLFbo.class, GLExt.class);\n        return Proxy.newProxyInstance(\n                glInterface.getClass().getClassLoader(),\n                glInterfaceClasses,\n                new GLTracer(glInterface, constMap));\n    }\n    /**\n     * Creates a tracer implementation that wraps OpenGL 2+.\n     * \n     * @param glInterface OGL object to wrap\n     * @param glInterfaceClasses The interface(s) to implement\n     * @return A tracer that implements the given interface\n     */\n    public static Object createDesktopGlTracer(Object glInterface, Class<?> ... glInterfaceClasses) {\n        IntMap<String> constMap = generateConstantMap(GL2.class, GL3.class, GL4.class, GLFbo.class, GLExt.class);\n        return Proxy.newProxyInstance(glInterface.getClass().getClassLoader(),\n                                      glInterfaceClasses, \n                                      new GLTracer(glInterface, constMap));\n    }\n    private void printStyle(String style, String string) {\n        System.out.print(style + string + ANSI_RESET);\n    }\n    private void print(String string) {\n        System.out.print(string);\n    }\n    private void printInt(int value) {\n        print(Integer.toString(value));\n    }\n    private void printEnum(int value) {\n        String enumName = constMap.get(value);\n        if (enumName != null) {\n            if (enumName.startsWith(\"GL_\")) {\n                enumName = enumName.substring(3);\n            }\n            if (enumName.endsWith(\"_EXT\") || enumName.endsWith(\"_ARB\")) {\n                enumName = enumName.substring(0, enumName.length() - 4);\n            }\n            printStyle(ANSI_GREEN, enumName);\n        } else {\n            printStyle(ANSI_GREEN, \"ENUM_\" + Integer.toHexString(value));\n        }\n    }\n    private void printIntOrEnum(String method, int value, int argIndex) {\n        IntMap<Void> argSlotMap = nonEnumArgMap.get(method);\n        if (argSlotMap != null && argSlotMap.containsKey(argIndex)) {\n            printInt(value);\n        } else {\n            printEnum(value);\n        }\n    }\n    private void printNewLine() {\n        System.out.println();\n    }\n    private void printString(String value) {\n        if (value.length() > 150) {\n            value = value.substring(0, 150) + \"...\";\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(ANSI_YELLOW);\n        sb.append(\"\\\"\");\n        sb.append(ANSI_RESET);\n        for (String line : value.split(\"\\n\")) {\n            sb.append(ANSI_YELLOW);\n            sb.append(line.replaceAll(\"\\0\", \"\\\\\\\\0\"));\n            sb.append(ANSI_RESET);\n            sb.append(\"\\n\");\n        }\n        if (sb.length() > 1 && sb.charAt(sb.length() - 1) == '\\n') {\n            sb.setLength(sb.length() - 1);\n        }\n        sb.append(ANSI_YELLOW);\n        sb.append(\"\\\"\");\n        sb.append(ANSI_RESET);\n        print(sb.toString());\n    }\n    private void printBoolean(boolean bool) {\n        printStyle(ANSI_BLUE, bool ? \"true\" : \"false\");\n    }\n    private void printBuffer(Buffer buffer) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(ANSI_MAGENTA);\n        if (buffer instanceof ByteBuffer) {\n            sb.append(\"byte\");\n        } else if (buffer instanceof ShortBuffer) {\n            sb.append(\"short\");\n        } else if (buffer instanceof CharBuffer) { \n            sb.append(\"char\");\n        } else if (buffer instanceof FloatBuffer) {\n            sb.append(\"float\");\n        } else if (buffer instanceof IntBuffer) {\n            sb.append(\"int\");\n        } else if (buffer instanceof LongBuffer) {\n            sb.append(\"long\");\n        } else if (buffer instanceof DoubleBuffer) {\n            sb.append(\"double\");\n        } else {\n            throw new UnsupportedOperationException();\n        }\n        sb.append(ANSI_RESET);\n        sb.append(\"[\");\n        if (buffer.position() == 0\n                && buffer.limit() == buffer.capacity()) {\n            // Common case. Just print buffer size.\n            sb.append(buffer.capacity());\n        } else {\n            sb.append(\"pos=\").append(buffer.position());\n            sb.append(\" lim=\").append(buffer.limit());\n            sb.append(\" cap=\").append(buffer.capacity());\n        }\n        sb.append(\"]\");\n        print(sb.toString());\n    }\n    private void printMethodName(String methodName) {\n        if (methodName.startsWith(\"gl\")) {\n            // GL calls which actually draw (as opposed to change state)\n            // will be printed in darker color\n            methodName = methodName.substring(2);\n            if (methodName.equals(\"Clear\")\n                    || methodName.equals(\"DrawRangeElements\")\n                    || methodName.equals(\"DrawElementsInstancedARB\")) {\n                print(methodName);\n            } else {\n                if (methodName.endsWith(\"EXT\")) {\n                    methodName = methodName.substring(0, methodName.length() - 3);\n                }\n                printStyle(ANSI_BRIGHT, methodName);\n            }\n        } else if (methodName.equals(\"resetStats\")) {\n            printStyle(ANSI_RED, \"-- frame boundary --\");\n        }\n    }\n    private void printArgsClear(int mask) {\n        boolean needAPipe = false;\n        print(\"(\");\n        if ((mask & GL.GL_COLOR_BUFFER_BIT) != 0) {\n            printStyle(ANSI_GREEN, \"COLOR_BUFFER_BIT\");\n            needAPipe = true;\n        }\n        if ((mask & GL.GL_DEPTH_BUFFER_BIT) != 0) {\n            if (needAPipe) {\n                print(\" | \");\n            }\n            printStyle(ANSI_GREEN, \"DEPTH_BUFFER_BIT\");\n        }\n        if ((mask & GL.GL_STENCIL_BUFFER_BIT) != 0) {\n            if (needAPipe) {\n                print(\" | \");\n            }\n            printStyle(ANSI_GREEN, \"STENCIL_BUFFER_BIT\");\n        }\n        print(\")\");\n    }\n    private void printArgsGetInteger(Object[] args) {\n        print(\"(\");\n        int param = (Integer)args[0];\n        IntBuffer ib = (IntBuffer) args[1];\n        printEnum(param);\n        print(\", \");\n        printOut();\n        if (param == GL2.GL_DRAW_BUFFER || param == GL2.GL_READ_BUFFER) {\n            printEnum(ib.get(0));\n        } else {\n            printInt(ib.get(0));\n        }\n        print(\")\");\n    }\n    private void printArgsTexParameter(Object[] args) {\n        print(\"(\");\n        int target = (Integer) args[0];\n        int param = (Integer) args[1];\n        int value = (Integer) args[2];\n        printEnum(target);\n        print(\", \");\n        printEnum(param);\n        print(\", \");\n        if (param == GL2.GL_TEXTURE_BASE_LEVEL\n                || param == GL2.GL_TEXTURE_MAX_LEVEL) {\n            printInt(value);\n        } else {\n            printEnum(value);\n        }\n        print(\")\");\n    }\n    private void printOut() {\n        printStyle(ANSI_CYAN, \"out=\");\n    }\n    private void printResult(String methodName, Object result, Class<?> returnType) {\n        if (returnType != void.class) {\n            print(\" = \");\n            if (result instanceof String) {\n                printString((String) result);\n            } else if (returnType == int.class) {\n                int val = (Integer) result;\n                printIntOrEnum(methodName, val, -1);\n            } else if (returnType == boolean.class) {\n                printBoolean((Boolean)result);\n            } else {\n                print(\" = ???\");\n            }\n        }\n    }\n    private void printNull() {\n        printStyle(ANSI_BLUE, \"null\");\n    }\n    private void printArgs(String methodName, Object[] args, Class<?>[] paramTypes) {\n        if (methodName.equals(\"glClear\")) {\n            printArgsClear((Integer)args[0]);\n            return;\n        } else if (methodName.equals(\"glTexParameteri\")) {\n            printArgsTexParameter(args);\n            return;\n        } else if (methodName.equals(\"glGetInteger\")) {\n            printArgsGetInteger(args);\n            return;\n        }\n        if (args == null) {\n            print(\"()\");\n            return;\n        }\n        print(\"(\");\n        for (int i = 0; i < args.length; i++) {\n            if (paramTypes[i] == int.class) {\n                int val = (Integer)args[i];\n                printIntOrEnum(methodName, val, i);\n            } else if (paramTypes[i] == boolean.class) {\n                printBoolean((Boolean)args[i]);\n            } else if (paramTypes[i] == String.class) {\n                printString((String)args[i]);\n            } else if (paramTypes[i] == String[].class) {\n                String[] arr = (String[]) args[i];\n                if (arr.length == 1) {\n                    printString(arr[0]);\n                } else {\n                    print(\"string[\" + arr.length + \"]\");\n                }\n            } else if (args[i] instanceof IntBuffer) {\n                IntBuffer buf = (IntBuffer) args[i];\n                if (buf.capacity() == 16) {\n                    int val = buf.get(0);\n                    printOut();\n                    printIntOrEnum(methodName, val, i);\n                } else if (buf.capacity() == 1) {\n                    printOut();\n                    print(Integer.toString(buf.get(0)));\n                } else {\n                    printBuffer(buf);\n                }\n            } else if (args[i] instanceof ByteBuffer) {\n                ByteBuffer bb = (ByteBuffer)args[i];\n                if (bb.capacity() == 250) {\n                    printOut();\n                    printBoolean(bb.get(0) != 0);\n                } else {\n                    printBuffer(bb);\n                }\n            } else if (args[i] instanceof Buffer) {\n                printBuffer((Buffer)args[i]);\n            } else if (args[i] != null) {\n                print(args[i].toString());\n            } else {\n                printNull();\n            }\n            if (i != args.length - 1) {\n                System.out.print(\", \");\n            }\n        }\n        print(\")\");\n    }\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        String methodName = method.getName();\n        printMethodName(methodName);\n        if (methodName.startsWith(\"gl\")) {\n            try {\n                // Try to evaluate result first, so we can see output values.\n                Object result = method.invoke(obj, args);\n                printArgs(methodName, args, method.getParameterTypes());\n                printResult(methodName, result, method.getReturnType());\n                printNewLine();\n                return result;\n            } catch (Throwable ex) {\n                // Execution failed, print args anyway\n                // but output values will be incorrect.\n                printArgs(methodName, args, method.getParameterTypes());\n                printNewLine();\n                System.out.println(\"\\tException occurred!\");\n                System.out.println(ex.toString());\n                throw ex;\n            }\n        } else {\n            printNewLine();\n            return method.invoke(obj, args);\n        }\n    }\n"]]}
{"hexsha": "c57faef56c1afc9fad41de4a68b771186bcdf42f", "ext": "java", "lang": "Java", "content": "public class MarkDownPreviewActivity extends BackBaseActivity {\n\n    private static final String EXTRA_MARKDOWN = \"markdown\";\n    private MarkdownView markdownView;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_back_base);\n        setCustomTitle(\"MarkDown\u9884\u89c8\");\n        FrameLayout layout = (FrameLayout) findViewById(R.id.container);\n\n        markdownView = new MarkdownView(this);\n        layout.addView(markdownView);\n//        markdownView.loadMarkdown();\n        showWebContent(StringUtils.renderMarkdown(getIntent().getStringExtra(EXTRA_MARKDOWN)));\n    }\n\n\n\n\n\n    public static void open(Context context, String markdown) {\n        Intent intent = new Intent(context, MarkDownPreviewActivity.class);\n        intent.putExtra(EXTRA_MARKDOWN, markdown);\n        context.startActivity(intent);\n    }\n\n\n    public void showWebContent(String htmlBody) {\n        String prompt = \"\";\n        AssetManager assetManager = getResources().getAssets();\n\n        try {\n            InputStream inputStream;\n\n            if (PreferenceManager.getDefaultSharedPreferences(this).getBoolean(SettingsFragment.KEY_PREF_THEME, false)) {\n                Log.e(\"theme\", \"is dark theme\");\n                inputStream = assetManager.open(\"dark_template.html\");\n            } else {\n                Log.e(\"theme\", \"is light theme\");\n                inputStream = assetManager.open(\"h5_template.html\");\n            }\n\n            byte[] b = new byte[inputStream.available()];\n            inputStream.read(b);\n            prompt = new String(b);\n            prompt = prompt.concat(htmlBody.replace(\"<img src=\\\"/photo/\",\n                    \"<img src=\\\"https://testerhome.com/photo/\")).concat(\"</body></html>\");\n            inputStream.close();\n        } catch (IOException e) {\n            Log.e(\"\", \"Counldn't open updrage-alter.html\", e);\n        }\n\n        markdownView.setBackgroundColor(0);\n        markdownView.loadDataWithBaseURL(null, prompt, \"text/html\", \"utf-8\", null);\n\n    }\n\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        markdownView.removeAllViews();\n        markdownView.destroy();\n    }\n}", "class_id": 0, "repo": "testerhome/A-Native-TesterHome", "file": "app/src/main/java/com/testerhome/nativeandroid/views/MarkDownPreviewActivity.java", "last_update_at": "2019-05-03T13:39:13+00:00", "question_id": "c57faef56c1afc9fad41de4a68b771186bcdf42f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MarkDownPreviewActivity extends BackBaseActivity {\n    private static final String EXTRA_MARKDOWN = \"markdown\";\n    private MarkdownView markdownView;\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_back_base);\n        setCustomTitle(\"MarkDown\u9884\u89c8\");\n        FrameLayout layout = (FrameLayout) findViewById(R.id.container);\n        markdownView = new MarkdownView(this);\n        layout.addView(markdownView);\n//        markdownView.loadMarkdown();\n        showWebContent(StringUtils.renderMarkdown(getIntent().getStringExtra(EXTRA_MARKDOWN)));\n    }\n    public static void open(Context context, String markdown) {\n        Intent intent = new Intent(context, MarkDownPreviewActivity.class);\n        intent.putExtra(EXTRA_MARKDOWN, markdown);\n        context.startActivity(intent);\n    }\n    public void showWebContent(String htmlBody) {\n        String prompt = \"\";\n        AssetManager assetManager = getResources().getAssets();\n        try {\n            InputStream inputStream;\n            if (PreferenceManager.getDefaultSharedPreferences(this).getBoolean(SettingsFragment.KEY_PREF_THEME, false)) {\n                Log.e(\"theme\", \"is dark theme\");\n                inputStream = assetManager.open(\"dark_template.html\");\n            } else {\n                Log.e(\"theme\", \"is light theme\");\n                inputStream = assetManager.open(\"h5_template.html\");\n            }\n            byte[] b = new byte[inputStream.available()];\n            inputStream.read(b);\n            prompt = new String(b);\n            prompt = prompt.concat(htmlBody.replace(\"<img src=\\\"/photo/\",\n                    \"<img src=\\\"https://testerhome.com/photo/\")).concat(\"</body></html>\");\n            inputStream.close();\n        } catch (IOException e) {\n            Log.e(\"\", \"Counldn't open updrage-alter.html\", e);\n        }\n        markdownView.setBackgroundColor(0);\n        markdownView.loadDataWithBaseURL(null, prompt, \"text/html\", \"utf-8\", null);\n    }\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        markdownView.removeAllViews();\n        markdownView.destroy();\n    }\n"]]}
{"hexsha": "05a03bbd55ae1a5cad492d5614bbafd937996336", "ext": "java", "lang": "Java", "content": "@ApiModel(description = \"JIT provisioning related configurations\")\npublic class JITProvisioningDTO  {\n  \n  \n  \n  private Boolean enable = null;\n  \n  \n  private String userstoreDomain = null;\n\n  \n  /**\n   **/\n  @ApiModelProperty(value = \"\")\n  @JsonProperty(\"enable\")\n  public Boolean getEnable() {\n    return enable;\n  }\n  public void setEnable(Boolean enable) {\n    this.enable = enable;\n  }\n\n  \n  /**\n   **/\n  @ApiModelProperty(value = \"\")\n  @JsonProperty(\"userstoreDomain\")\n  public String getUserstoreDomain() {\n    return userstoreDomain;\n  }\n  public void setUserstoreDomain(String userstoreDomain) {\n    this.userstoreDomain = userstoreDomain;\n  }\n\n  \n\n  @Override\n  public String toString()  {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class JITProvisioningDTO {\\n\");\n    \n    sb.append(\"  enable: \").append(enable).append(\"\\n\");\n    sb.append(\"  userstoreDomain: \").append(userstoreDomain).append(\"\\n\");\n    sb.append(\"}\\n\");\n    return sb.toString();\n  }\n}", "class_id": 0, "repo": "darshanasbg/identity-api-idpmgt", "file": "components/org.wso2.carbon.identity.api.idpmgt.endpoint/src/gen/java/org/wso2/carbon/identity/api/idpmgt/endpoint/dto/JITProvisioningDTO.java", "last_update_at": "2019-12-13T06:04:58+00:00", "question_id": "05a03bbd55ae1a5cad492d5614bbafd937996336", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ApiModel(description = \"JIT provisioning related configurations\")\npublic class JITProvisioningDTO  {\n  private Boolean enable = null;\n  private String userstoreDomain = null;\n  /**\n   **/\n  @ApiModelProperty(value = \"\")\n  @JsonProperty(\"enable\")\n  public Boolean getEnable() {\n    return enable;\n  }\n  public void setEnable(Boolean enable) {\n    this.enable = enable;\n  }\n  /**\n   **/\n  @ApiModelProperty(value = \"\")\n  @JsonProperty(\"userstoreDomain\")\n  public String getUserstoreDomain() {\n    return userstoreDomain;\n  }\n  public void setUserstoreDomain(String userstoreDomain) {\n    this.userstoreDomain = userstoreDomain;\n  }\n  @Override\n  public String toString()  {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class JITProvisioningDTO {\\n\");\n    sb.append(\"  enable: \").append(enable).append(\"\\n\");\n    sb.append(\"  userstoreDomain: \").append(userstoreDomain).append(\"\\n\");\n    sb.append(\"}\\n\");\n    return sb.toString();\n  }\n"]]}
{"hexsha": "08836f15dac4972085c740da5e5e1876a573ff3f", "ext": "java", "lang": "Java", "content": "@RunWith(SpringJUnit4ClassRunner.class)\n@TestPropertySource(properties = { \"spring.application.name=multiplehopsintegrationtests\",\n\t\t\"spring.sleuth.http.legacy.enabled=true\" })\n@SpringBootTest(classes = MultipleHopsIntegrationTests.Config.class, webEnvironment = RANDOM_PORT)\n@ActiveProfiles(\"baggage\")\npublic class MultipleHopsIntegrationTests {\n\n\t@Autowired\n\tTracer tracer;\n\n\t@Autowired\n\tArrayListSpanReporter reporter;\n\n\t@Autowired\n\tRestTemplate restTemplate;\n\n\t@Autowired\n\tConfig config;\n\n\t@Autowired\n\tDemoApplication application;\n\n\t@Before\n\tpublic void setup() {\n\t\tthis.reporter.clear();\n\t}\n\n\t@Test\n\tpublic void should_prepare_spans_for_export() throws Exception {\n\t\tthis.restTemplate.getForObject(\n\t\t\t\t\"http://localhost:\" + this.config.port + \"/greeting\", String.class);\n\n\t\tawait().atMost(5, SECONDS).untilAsserted(() -> {\n\t\t\tthen(this.reporter.getSpans()).hasSize(14);\n\t\t});\n\t\tthen(this.reporter.getSpans().stream().map(zipkin2.Span::name).collect(toList()))\n\t\t\t\t.containsAll(asList(\"http:/greeting\", \"send\"));\n\t\tthen(this.reporter.getSpans().stream().map(zipkin2.Span::kind)\n\t\t\t\t// no server kind due to test constraints\n\t\t\t\t.collect(toList()))\n\t\t\t\t\t\t.containsAll(asList(zipkin2.Span.Kind.CONSUMER,\n\t\t\t\t\t\t\t\tzipkin2.Span.Kind.PRODUCER, zipkin2.Span.Kind.SERVER));\n\t\tthen(this.reporter.getSpans().stream().map(span -> span.tags().get(\"channel\"))\n\t\t\t\t.filter(Objects::nonNull).distinct().collect(toList())).hasSize(3)\n\t\t\t\t\t\t.containsAll(asList(\"words\", \"counts\", \"greetings\"));\n\t}\n\n\t// issue #237 - baggage\n\t@Test\n\t// Notes:\n\t// * path-prefix header propagation can't reliably support mixed case, due to http/2\n\t// downcasing\n\t// * Since not all tokenizers are case insensitive, mixed case can break correlation\n\t// * Brave's ExtraFieldPropagation downcases due to the above\n\t// * This code should probably test the side-effect on http headers\n\t// * the assumption all correlation fields (baggage) are saved to a span is an\n\t// interesting one\n\t// * should all correlation fields (baggage) be added to the MDC context?\n\t// * Until below, a configuration item of a correlation field whitelist is needed\n\t// * https://github.com/openzipkin/brave/pull/577\n\t// * probably needed anyway as an empty whitelist is a nice way to disable the feature\n\tpublic void should_propagate_the_baggage() throws Exception {\n\t\t// tag::baggage[]\n\t\tSpan initialSpan = this.tracer.nextSpan().name(\"span\").start();\n\t\tExtraFieldPropagation.set(initialSpan.context(), \"foo\", \"bar\");\n\t\tExtraFieldPropagation.set(initialSpan.context(), \"UPPER_CASE\", \"someValue\");\n\t\t// end::baggage[]\n\n\t\ttry (Tracer.SpanInScope ws = this.tracer.withSpanInScope(initialSpan)) {\n\t\t\t// tag::baggage_tag[]\n\t\t\tinitialSpan.tag(\"foo\",\n\t\t\t\t\tExtraFieldPropagation.get(initialSpan.context(), \"foo\"));\n\t\t\tinitialSpan.tag(\"UPPER_CASE\",\n\t\t\t\t\tExtraFieldPropagation.get(initialSpan.context(), \"UPPER_CASE\"));\n\t\t\t// end::baggage_tag[]\n\n\t\t\tHttpHeaders headers = new HttpHeaders();\n\t\t\theaders.put(\"baggage-baz\", Collections.singletonList(\"baz\"));\n\t\t\theaders.put(\"baggage-bizarreCASE\", Collections.singletonList(\"value\"));\n\t\t\tRequestEntity requestEntity = new RequestEntity(headers, HttpMethod.GET,\n\t\t\t\t\tURI.create(\"http://localhost:\" + this.config.port + \"/greeting\"));\n\t\t\tthis.restTemplate.exchange(requestEntity, String.class);\n\t\t}\n\t\tfinally {\n\t\t\tinitialSpan.finish();\n\t\t}\n\t\tawait().atMost(5, SECONDS).untilAsserted(() -> {\n\t\t\tthen(this.reporter.getSpans()).isNotEmpty();\n\t\t});\n\n\t\tthen(this.application.allSpans()).as(\"All have foo\")\n\t\t\t\t.allMatch(span -> \"bar\".equals(baggage(span, \"foo\")));\n\t\tthen(this.application.allSpans()).as(\"All have UPPER_CASE\")\n\t\t\t\t.allMatch(span -> \"someValue\".equals(baggage(span, \"UPPER_CASE\")));\n\t\tthen(this.application.allSpans().stream()\n\t\t\t\t.filter(span -> \"baz\".equals(baggage(span, \"baz\")))\n\t\t\t\t.collect(Collectors.toList())).as(\"Someone has baz\").isNotEmpty();\n\t\tthen(this.reporter.getSpans().stream()\n\t\t\t\t.filter(span -> span.tags().containsKey(\"foo\")\n\t\t\t\t\t\t&& span.tags().containsKey(\"UPPER_CASE\"))\n\t\t\t\t.collect(Collectors.toList())).as(\"Someone has foo and UPPER_CASE tags\")\n\t\t\t\t\t\t.isNotEmpty();\n\t\tthen(this.application.allSpans().stream()\n\t\t\t\t.filter(span -> \"value\".equals(baggage(span, \"bizarreCASE\")))\n\t\t\t\t.collect(Collectors.toList())).isNotEmpty();\n\t}\n\n\tprivate String baggage(Span span, String name) {\n\t\treturn ExtraFieldPropagation.get(span.context(), name);\n\t}\n\n\t@Configuration\n\t@SpringBootApplication(exclude = JmxAutoConfiguration.class)\n\tpublic static class Config\n\t\t\timplements ApplicationListener<ServletWebServerInitializedEvent> {\n\n\t\tint port;\n\n\t\t@Override\n\t\tpublic void onApplicationEvent(ServletWebServerInitializedEvent event) {\n\t\t\tthis.port = event.getSource().getPort();\n\t\t}\n\n\t\t@Bean\n\t\tRestTemplate restTemplate() {\n\t\t\treturn new RestTemplate();\n\t\t}\n\n\t\t@Bean\n\t\tArrayListSpanReporter arrayListSpanAccumulator() {\n\t\t\treturn new ArrayListSpanReporter();\n\t\t}\n\n\t\t@Bean\n\t\tSampler defaultTraceSampler() {\n\t\t\treturn Sampler.ALWAYS_SAMPLE;\n\t\t}\n\n\t}\n\n}", "class_id": 0, "repo": "yuchuang12/spring-cloud-sleuth", "file": "spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/instrument/multiple/MultipleHopsIntegrationTests.java", "last_update_at": "2019-03-22T12:40:10+00:00", "question_id": "08836f15dac4972085c740da5e5e1876a573ff3f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(SpringJUnit4ClassRunner.class)\n@TestPropertySource(properties = { \"spring.application.name=multiplehopsintegrationtests\",\n\t\t\"spring.sleuth.http.legacy.enabled=true\" })\n@SpringBootTest(classes = MultipleHopsIntegrationTests.Config.class, webEnvironment = RANDOM_PORT)\n@ActiveProfiles(\"baggage\")\npublic class MultipleHopsIntegrationTests {\n\t@Autowired\n\tTracer tracer;\n\t@Autowired\n\tArrayListSpanReporter reporter;\n\t@Autowired\n\tRestTemplate restTemplate;\n\t@Autowired\n\tConfig config;\n\t@Autowired\n\tDemoApplication application;\n\t@Before\n\tpublic void setup() {\n\t\tthis.reporter.clear();\n\t}\n\t@Test\n\tpublic void should_prepare_spans_for_export() throws Exception {\n\t\tthis.restTemplate.getForObject(\n\t\t\t\t\"http://localhost:\" + this.config.port + \"/greeting\", String.class);\n\t\tawait().atMost(5, SECONDS).untilAsserted(() -> {\n\t\t\tthen(this.reporter.getSpans()).hasSize(14);\n\t\t});\n\t\tthen(this.reporter.getSpans().stream().map(zipkin2.Span::name).collect(toList()))\n\t\t\t\t.containsAll(asList(\"http:/greeting\", \"send\"));\n\t\tthen(this.reporter.getSpans().stream().map(zipkin2.Span::kind)\n\t\t\t\t// no server kind due to test constraints\n\t\t\t\t.collect(toList()))\n\t\t\t\t\t\t.containsAll(asList(zipkin2.Span.Kind.CONSUMER,\n\t\t\t\t\t\t\t\tzipkin2.Span.Kind.PRODUCER, zipkin2.Span.Kind.SERVER));\n\t\tthen(this.reporter.getSpans().stream().map(span -> span.tags().get(\"channel\"))\n\t\t\t\t.filter(Objects::nonNull).distinct().collect(toList())).hasSize(3)\n\t\t\t\t\t\t.containsAll(asList(\"words\", \"counts\", \"greetings\"));\n\t}\n\t// issue #237 - baggage\n\t@Test\n\t// Notes:\n\t// * path-prefix header propagation can't reliably support mixed case, due to http/2\n\t// downcasing\n\t// * Since not all tokenizers are case insensitive, mixed case can break correlation\n\t// * Brave's ExtraFieldPropagation downcases due to the above\n\t// * This code should probably test the side-effect on http headers\n\t// * the assumption all correlation fields (baggage) are saved to a span is an\n\t// interesting one\n\t// * should all correlation fields (baggage) be added to the MDC context?\n\t// * Until below, a configuration item of a correlation field whitelist is needed\n\t// * https://github.com/openzipkin/brave/pull/577\n\t// * probably needed anyway as an empty whitelist is a nice way to disable the feature\n\tpublic void should_propagate_the_baggage() throws Exception {\n\t\t// tag::baggage[]\n\t\tSpan initialSpan = this.tracer.nextSpan().name(\"span\").start();\n\t\tExtraFieldPropagation.set(initialSpan.context(), \"foo\", \"bar\");\n\t\tExtraFieldPropagation.set(initialSpan.context(), \"UPPER_CASE\", \"someValue\");\n\t\t// end::baggage[]\n\t\ttry (Tracer.SpanInScope ws = this.tracer.withSpanInScope(initialSpan)) {\n\t\t\t// tag::baggage_tag[]\n\t\t\tinitialSpan.tag(\"foo\",\n\t\t\t\t\tExtraFieldPropagation.get(initialSpan.context(), \"foo\"));\n\t\t\tinitialSpan.tag(\"UPPER_CASE\",\n\t\t\t\t\tExtraFieldPropagation.get(initialSpan.context(), \"UPPER_CASE\"));\n\t\t\t// end::baggage_tag[]\n\t\t\tHttpHeaders headers = new HttpHeaders();\n\t\t\theaders.put(\"baggage-baz\", Collections.singletonList(\"baz\"));\n\t\t\theaders.put(\"baggage-bizarreCASE\", Collections.singletonList(\"value\"));\n\t\t\tRequestEntity requestEntity = new RequestEntity(headers, HttpMethod.GET,\n\t\t\t\t\tURI.create(\"http://localhost:\" + this.config.port + \"/greeting\"));\n\t\t\tthis.restTemplate.exchange(requestEntity, String.class);\n\t\t}\n\t\tfinally {\n\t\t\tinitialSpan.finish();\n\t\t}\n\t\tawait().atMost(5, SECONDS).untilAsserted(() -> {\n\t\t\tthen(this.reporter.getSpans()).isNotEmpty();\n\t\t});\n\t\tthen(this.application.allSpans()).as(\"All have foo\")\n\t\t\t\t.allMatch(span -> \"bar\".equals(baggage(span, \"foo\")));\n\t\tthen(this.application.allSpans()).as(\"All have UPPER_CASE\")\n\t\t\t\t.allMatch(span -> \"someValue\".equals(baggage(span, \"UPPER_CASE\")));\n\t\tthen(this.application.allSpans().stream()\n\t\t\t\t.filter(span -> \"baz\".equals(baggage(span, \"baz\")))\n\t\t\t\t.collect(Collectors.toList())).as(\"Someone has baz\").isNotEmpty();\n\t\tthen(this.reporter.getSpans().stream()\n\t\t\t\t.filter(span -> span.tags().containsKey(\"foo\")\n\t\t\t\t\t\t&& span.tags().containsKey(\"UPPER_CASE\"))\n\t\t\t\t.collect(Collectors.toList())).as(\"Someone has foo and UPPER_CASE tags\")\n\t\t\t\t\t\t.isNotEmpty();\n\t\tthen(this.application.allSpans().stream()\n\t\t\t\t.filter(span -> \"value\".equals(baggage(span, \"bizarreCASE\")))\n\t\t\t\t.collect(Collectors.toList())).isNotEmpty();\n\t}\n\tprivate String baggage(Span span, String name) {\n\t\treturn ExtraFieldPropagation.get(span.context(), name);\n\t}\n\t@Configuration\n\t@SpringBootApplication(exclude = JmxAutoConfiguration.class)\n\tpublic static class Config\n\t\t\timplements ApplicationListener<ServletWebServerInitializedEvent> {\n\t\tint port;\n\t\t@Override\n\t\tpublic void onApplicationEvent(ServletWebServerInitializedEvent event) {\n\t\t\tthis.port = event.getSource().getPort();\n\t\t}\n\t\t@Bean\n\t\tRestTemplate restTemplate() {\n\t\t\treturn new RestTemplate();\n\t\t}\n\t\t@Bean\n\t\tArrayListSpanReporter arrayListSpanAccumulator() {\n\t\t\treturn new ArrayListSpanReporter();\n\t\t}\n\t\t@Bean\n\t\tSampler defaultTraceSampler() {\n\t\t\treturn Sampler.ALWAYS_SAMPLE;\n\t\t}\n\t}\n"]]}
{"hexsha": "de4b40b6a3c4c6a9cd99a09538e26a5137eb3083", "ext": "java", "lang": "Java", "content": "public class Leetcode347 {\n\n    private class Freq implements Comparable<Freq>{\n        public int e, freq;\n\n        public Freq(int e, int freq) {\n            this.e = e;\n            this.freq = freq;\n        }\n\n        @Override\n        public int compareTo(Freq o) {\n            if(this.freq < o.freq)\n                return 1;\n            else if(this.freq > o.freq)\n                return -1;\n            else\n                return 0;\n        }\n    }\n\n    public List<Integer> topKFrequent(int[] nums, int k) {\n\n        TreeMap<Integer, Integer> map = new TreeMap<>();\n\n        for (int num : nums) {\n            if(!map.containsKey(num)){\n                map.put(num, 1);\n            }else\n                map.put(num, map.get(num) + 1);\n        }\n\n        PriorityQueue<Freq> pq = new PriorityQueue<>();\n        for (int key: map.keySet()){\n            if(pq.getSize() < k)\n                pq.enqueue(new Freq(key, map.get(key)));\n            else if(map.get(key) > pq.getFront().freq){\n                pq.dequeue();\n                pq.enqueue(new Freq(key, map.get(key)));\n            }\n        }\n\n        LinkedList<Integer> list = new LinkedList<>();\n        while (!pq.isEmpty())\n            list.add(pq.dequeue().e);\n\n        return list;\n    }\n\n}", "class_id": 0, "repo": "lishangwu/liuyubobobo2", "file": "src/com/MaxHeap/Leetcode347.java", "last_update_at": "2019-07-16T01:39:24+00:00", "question_id": "de4b40b6a3c4c6a9cd99a09538e26a5137eb3083", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Leetcode347 {\n    private class Freq implements Comparable<Freq>{\n        public int e, freq;\n        public Freq(int e, int freq) {\n            this.e = e;\n            this.freq = freq;\n        }\n        @Override\n        public int compareTo(Freq o) {\n            if(this.freq < o.freq)\n                return 1;\n            else if(this.freq > o.freq)\n                return -1;\n            else\n                return 0;\n        }\n    }\n    public List<Integer> topKFrequent(int[] nums, int k) {\n        TreeMap<Integer, Integer> map = new TreeMap<>();\n        for (int num : nums) {\n            if(!map.containsKey(num)){\n                map.put(num, 1);\n            }else\n                map.put(num, map.get(num) + 1);\n        }\n        PriorityQueue<Freq> pq = new PriorityQueue<>();\n        for (int key: map.keySet()){\n            if(pq.getSize() < k)\n                pq.enqueue(new Freq(key, map.get(key)));\n            else if(map.get(key) > pq.getFront().freq){\n                pq.dequeue();\n                pq.enqueue(new Freq(key, map.get(key)));\n            }\n        }\n        LinkedList<Integer> list = new LinkedList<>();\n        while (!pq.isEmpty())\n            list.add(pq.dequeue().e);\n        return list;\n    }\n"]]}
{"hexsha": "64f0c8be3399ea411a6b8ffb3ff3ef31f32719bf", "ext": "java", "lang": "Java", "content": "public class ArgumentDiagramEditPart extends DiagramEditPart {\n\n\t/**\n\t * @generated\n\t */\n\tpublic final static String MODEL_ID = \"Argument\"; //$NON-NLS-1$\n\n\t/**\n\t * @generated\n\t */\n\tpublic static final int VISUAL_ID = 1000;\n\n\t/**\n\t * @generated\n\t */\n\tpublic ArgumentDiagramEditPart(View view) {\n\t\tsuper(view);\n\t}\n\n\t/**\n\t * @generated\n\t */\n\tprotected void createDefaultEditPolicies() {\n\t\tsuper.createDefaultEditPolicies();\n\t\tinstallEditPolicy(EditPolicyRoles.SEMANTIC_ROLE,\n\t\t\t\tnew ArgumentDiagramItemSemanticEditPolicy());\n\t\tinstallEditPolicy(EditPolicyRoles.CANONICAL_ROLE,\n\t\t\t\tnew ArgumentDiagramCanonicalEditPolicy());\n\t\t// removeEditPolicy(org.eclipse.gmf.runtime.diagram.ui.editpolicies.EditPolicyRoles.POPUPBAR_ROLE);\n\t}\n\n\t/**\n\t * @generated\n\t */\n\t/*package-local*/static class NodeLabelDragPolicy extends\n\t\t\tNonResizableEditPolicy {\n\n\t\t/**\n\t\t * @generated\n\t\t */\n\t\t@SuppressWarnings(\"rawtypes\")\n\t\tprotected List createSelectionHandles() {\n\t\t\tMoveHandle h = new MoveHandle((GraphicalEditPart) getHost());\n\t\t\th.setBorder(null);\n\t\t\treturn Collections.singletonList(h);\n\t\t}\n\n\t\t/**\n\t\t * @generated\n\t\t */\n\t\tpublic Command getCommand(Request request) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * @generated\n\t\t */\n\t\tpublic boolean understandsRequest(Request request) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @generated\n\t */\n\t/*package-local*/static class LinkLabelDragPolicy extends\n\t\t\tNonResizableLabelEditPolicy {\n\n\t\t/**\n\t\t * @generated\n\t\t */\n\t\t@SuppressWarnings(\"rawtypes\")\n\t\tprotected List createSelectionHandles() {\n\t\t\tMoveHandle mh = new MoveHandle((GraphicalEditPart) getHost());\n\t\t\tmh.setBorder(null);\n\t\t\treturn Collections.singletonList(mh);\n\t\t}\n\t}\n\n}", "class_id": 0, "repo": "problem-frames/openpf", "file": "workspace/argument.diagram/src/argument/argument/diagram/edit/parts/ArgumentDiagramEditPart.java", "last_update_at": "2019-05-03T20:03:11+00:00", "question_id": "64f0c8be3399ea411a6b8ffb3ff3ef31f32719bf", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ArgumentDiagramEditPart extends DiagramEditPart {\n\t/**\n\t * @generated\n\t */\n\tpublic final static String MODEL_ID = \"Argument\"; //$NON-NLS-1$\n\t/**\n\t * @generated\n\t */\n\tpublic static final int VISUAL_ID = 1000;\n\t/**\n\t * @generated\n\t */\n\tpublic ArgumentDiagramEditPart(View view) {\n\t\tsuper(view);\n\t}\n\t/**\n\t * @generated\n\t */\n\tprotected void createDefaultEditPolicies() {\n\t\tsuper.createDefaultEditPolicies();\n\t\tinstallEditPolicy(EditPolicyRoles.SEMANTIC_ROLE,\n\t\t\t\tnew ArgumentDiagramItemSemanticEditPolicy());\n\t\tinstallEditPolicy(EditPolicyRoles.CANONICAL_ROLE,\n\t\t\t\tnew ArgumentDiagramCanonicalEditPolicy());\n\t\t// removeEditPolicy(org.eclipse.gmf.runtime.diagram.ui.editpolicies.EditPolicyRoles.POPUPBAR_ROLE);\n\t}\n\t/**\n\t * @generated\n\t */\n\t/*package-local*/static class NodeLabelDragPolicy extends\n\t\t\tNonResizableEditPolicy {\n\t\t/**\n\t\t * @generated\n\t\t */\n\t\t@SuppressWarnings(\"rawtypes\")\n\t\tprotected List createSelectionHandles() {\n\t\t\tMoveHandle h = new MoveHandle((GraphicalEditPart) getHost());\n\t\t\th.setBorder(null);\n\t\t\treturn Collections.singletonList(h);\n\t\t}\n\t\t/**\n\t\t * @generated\n\t\t */\n\t\tpublic Command getCommand(Request request) {\n\t\t\treturn null;\n\t\t}\n\t\t/**\n\t\t * @generated\n\t\t */\n\t\tpublic boolean understandsRequest(Request request) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t/**\n\t * @generated\n\t */\n\t/*package-local*/static class LinkLabelDragPolicy extends\n\t\t\tNonResizableLabelEditPolicy {\n\t\t/**\n\t\t * @generated\n\t\t */\n\t\t@SuppressWarnings(\"rawtypes\")\n\t\tprotected List createSelectionHandles() {\n\t\t\tMoveHandle mh = new MoveHandle((GraphicalEditPart) getHost());\n\t\t\tmh.setBorder(null);\n\t\t\treturn Collections.singletonList(mh);\n\t\t}\n\t}\n"]]}
{"hexsha": "e294d4fe5d44fa0721c53f7775d4a5198a2997c2", "ext": "java", "lang": "Java", "content": "public class ModelCleanup implements OptimizerStateListener {\n    private SimulationModel model;\n    private ModelFactory factory;\n    private DelayedDeleter deleter;\n\n    @Inject\n    public ModelCleanup(SimulationModel model, ModelFactory factory) {\n        this.model = model;\n        this.factory = factory;\n        this.deleter = DelayedDeleter.activate();\n\n        Runtime.getRuntime().addShutdownHook(new Thread(this::shutdown));\n    }\n\n    private synchronized void shutdown() {\n        try {\n            if (model != null) {\n                model.close();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            model = null;\n        }\n        try {\n            if (factory != null) {\n                factory.close();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            factory = null;\n        }\n        deleter.tryDelete();\n    }\n\n    @Override\n    public void optimizationStarted(Optimizer optimizer) {}\n\n    @Override\n    public void optimizationStopped(Optimizer optimizer) {\n        shutdown();\n    }\n}", "class_id": 0, "repo": "Cityopt/cityopt", "file": "opt-ga/src/main/java/eu/cityopt/opt/ga/ModelCleanup.java", "last_update_at": "2019-09-30T07:36:51+00:00", "question_id": "e294d4fe5d44fa0721c53f7775d4a5198a2997c2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ModelCleanup implements OptimizerStateListener {\n    private SimulationModel model;\n    private ModelFactory factory;\n    private DelayedDeleter deleter;\n    @Inject\n    public ModelCleanup(SimulationModel model, ModelFactory factory) {\n        this.model = model;\n        this.factory = factory;\n        this.deleter = DelayedDeleter.activate();\n        Runtime.getRuntime().addShutdownHook(new Thread(this::shutdown));\n    }\n    private synchronized void shutdown() {\n        try {\n            if (model != null) {\n                model.close();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            model = null;\n        }\n        try {\n            if (factory != null) {\n                factory.close();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            factory = null;\n        }\n        deleter.tryDelete();\n    }\n    @Override\n    public void optimizationStarted(Optimizer optimizer) {}\n    @Override\n    public void optimizationStopped(Optimizer optimizer) {\n        shutdown();\n    }\n"]]}
{"hexsha": "6c9459798c71d5f8316c1f39aa76f766adc19069", "ext": "java", "lang": "Java", "content": "class PackageReference\n{\n    private final static String PACKAGE_REFERENCE_PATTERN = \n        \"([+-]?)([.a-zA-Z0-9-+]+)((?:=)|(?:>)|(?:>=)|(?:<)|(?:<=))?([0-9.]+?)?\";\n    \n    private PackageKind packageKind;\n    private String packageName;\n    private ComparisonOperator operator;\n    private PackageVersion packageVersion;\n    \n    private PackageReference() { }\n\n    public PackageKind getPackageKind()\n    {\n        return packageKind;\n    }\n    \n    public String getPackageName()\n    {\n        return packageName;\n    }\n\n    public ComparisonOperator getOperator()\n    {\n        return operator;\n    }\n\n    public PackageVersion getPackageVersion()\n    {\n        return packageVersion;\n    }\n    \n    public boolean fits(PackageReference other)\n    {\n        if (getPackageName().equals(other.getPackageName()))\n        {\n            if (other.operator == ComparisonOperator.None) return true;\n            if (other.operator == ComparisonOperator.Equal && \n                packageVersion.getTotal() == other.packageVersion.getTotal()) return true;\n            if (other.operator == ComparisonOperator.Greater && \n                packageVersion.getTotal() > other.packageVersion.getTotal()) return true;\n            if (other.operator == ComparisonOperator.GreaterOrEqual && \n                packageVersion.getTotal() >= other.packageVersion.getTotal()) return true;\n            if (other.operator == ComparisonOperator.Less && \n                packageVersion.getTotal() < other.packageVersion.getTotal()) return true;\n            if (other.operator == ComparisonOperator.LessOrEqual && \n                packageVersion.getTotal() <= other.packageVersion.getTotal()) return true;\n        }\n        \n        return false;\n    }\n    \n    @Override\n    public String toString()\n    {\n        if (operator != ComparisonOperator.None)\n        {\n            return packageName + getOperatorText(operator) + packageVersion;\n        }\n        \n        return packageName;\n    }\n    \n    private String getOperatorText(ComparisonOperator operator)\n    {\n        if (operator == ComparisonOperator.Equal) return \"=\";\n        if (operator == ComparisonOperator.Greater) return \">\";\n        if (operator == ComparisonOperator.GreaterOrEqual) return \">=\";\n        if (operator == ComparisonOperator.Less) return \"<\";\n        if (operator == ComparisonOperator.LessOrEqual) return \"<=\";\n        \n        return null;\n    }\n    \n    public static PackageReference parse(String input)\n    {\n        PackageReference result;\n        Pattern pattern;\n        Matcher matcher;\n        String kind, name, operator, version;\n        \n        result = new PackageReference();\n        pattern = Pattern.compile(PACKAGE_REFERENCE_PATTERN);\n        matcher = pattern.matcher(input);\n        \n        if (matcher.matches())\n        {\n            kind = matcher.group(1);\n            name = matcher.group(2);\n            operator = matcher.group(3);\n            version = matcher.group(4);\n            \n            if (kind == null)\n            {\n                result.packageKind = PackageKind.None;\n            }\n            else if (kind.equals(\"+\"))\n            {\n                result.packageKind = PackageKind.Positive;\n            }\n            else\n            {\n                result.packageKind = PackageKind.Negative;\n            }\n            \n            result.packageName = name;\n            \n            if (operator != null)\n            {\n                if (operator.equals(\"=\")) result.operator = ComparisonOperator.Equal;\n                else if (operator.equals(\">\")) result.operator = ComparisonOperator.Greater;\n                else if (operator.equals(\">=\")) result.operator = ComparisonOperator.GreaterOrEqual;\n                else if (operator.equals(\"<\")) result.operator = ComparisonOperator.Less;\n                else result.operator = ComparisonOperator.LessOrEqual;\n            }\n            else\n            {\n                result.operator = ComparisonOperator.None;\n            }\n            \n            if (version == null)\n            {\n                version = \"0\";\n            }\n            \n            result.packageVersion = PackageVersion.parse(version);\n            \n            return result;\n        }\n\n        throw new IllegalArgumentException(input);\n    }\n    \n    public static PackageReference parse(Package _package)\n    {\n        PackageReference result;\n        \n        result = new PackageReference();\n        result.packageName = _package.getName();\n        result.packageVersion = PackageVersion.parse(_package.getVersion());\n        result.operator = ComparisonOperator.Equal;\n        result.packageKind = PackageKind.None;\n        \n        return result;\n    }\n}", "class_id": 3, "repo": "ukc-co663/dependency-solver-2019-kp432", "file": "src/depsolver/Main.java", "last_update_at": "2019-03-06T12:35:22+00:00", "question_id": "6c9459798c71d5f8316c1f39aa76f766adc19069", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class PackageReference\n{\n    private final static String PACKAGE_REFERENCE_PATTERN = \n        \"([+-]?)([.a-zA-Z0-9-+]+)((?:=)|(?:>)|(?:>=)|(?:<)|(?:<=))?([0-9.]+?)?\";\n    private PackageKind packageKind;\n    private String packageName;\n    private ComparisonOperator operator;\n    private PackageVersion packageVersion;\n    private PackageReference() { }\n    public PackageKind getPackageKind()\n    {\n        return packageKind;\n    }\n    public String getPackageName()\n    {\n        return packageName;\n    }\n    public ComparisonOperator getOperator()\n    {\n        return operator;\n    }\n    public PackageVersion getPackageVersion()\n    {\n        return packageVersion;\n    }\n    public boolean fits(PackageReference other)\n    {\n        if (getPackageName().equals(other.getPackageName()))\n        {\n            if (other.operator == ComparisonOperator.None) return true;\n            if (other.operator == ComparisonOperator.Equal && \n                packageVersion.getTotal() == other.packageVersion.getTotal()) return true;\n            if (other.operator == ComparisonOperator.Greater && \n                packageVersion.getTotal() > other.packageVersion.getTotal()) return true;\n            if (other.operator == ComparisonOperator.GreaterOrEqual && \n                packageVersion.getTotal() >= other.packageVersion.getTotal()) return true;\n            if (other.operator == ComparisonOperator.Less && \n                packageVersion.getTotal() < other.packageVersion.getTotal()) return true;\n            if (other.operator == ComparisonOperator.LessOrEqual && \n                packageVersion.getTotal() <= other.packageVersion.getTotal()) return true;\n        }\n        return false;\n    }\n    @Override\n    public String toString()\n    {\n        if (operator != ComparisonOperator.None)\n        {\n            return packageName + getOperatorText(operator) + packageVersion;\n        }\n        return packageName;\n    }\n    private String getOperatorText(ComparisonOperator operator)\n    {\n        if (operator == ComparisonOperator.Equal) return \"=\";\n        if (operator == ComparisonOperator.Greater) return \">\";\n        if (operator == ComparisonOperator.GreaterOrEqual) return \">=\";\n        if (operator == ComparisonOperator.Less) return \"<\";\n        if (operator == ComparisonOperator.LessOrEqual) return \"<=\";\n        return null;\n    }\n    public static PackageReference parse(String input)\n    {\n        PackageReference result;\n        Pattern pattern;\n        Matcher matcher;\n        String kind, name, operator, version;\n        result = new PackageReference();\n        pattern = Pattern.compile(PACKAGE_REFERENCE_PATTERN);\n        matcher = pattern.matcher(input);\n        if (matcher.matches())\n        {\n            kind = matcher.group(1);\n            name = matcher.group(2);\n            operator = matcher.group(3);\n            version = matcher.group(4);\n            if (kind == null)\n            {\n                result.packageKind = PackageKind.None;\n            }\n            else if (kind.equals(\"+\"))\n            {\n                result.packageKind = PackageKind.Positive;\n            }\n            else\n            {\n                result.packageKind = PackageKind.Negative;\n            }\n            result.packageName = name;\n            if (operator != null)\n            {\n                if (operator.equals(\"=\")) result.operator = ComparisonOperator.Equal;\n                else if (operator.equals(\">\")) result.operator = ComparisonOperator.Greater;\n                else if (operator.equals(\">=\")) result.operator = ComparisonOperator.GreaterOrEqual;\n                else if (operator.equals(\"<\")) result.operator = ComparisonOperator.Less;\n                else result.operator = ComparisonOperator.LessOrEqual;\n            }\n            else\n            {\n                result.operator = ComparisonOperator.None;\n            }\n            if (version == null)\n            {\n                version = \"0\";\n            }\n            result.packageVersion = PackageVersion.parse(version);\n            return result;\n        }\n        throw new IllegalArgumentException(input);\n    }\n    public static PackageReference parse(Package _package)\n    {\n        PackageReference result;\n        result = new PackageReference();\n        result.packageName = _package.getName();\n        result.packageVersion = PackageVersion.parse(_package.getVersion());\n        result.operator = ComparisonOperator.Equal;\n        result.packageKind = PackageKind.None;\n        return result;\n    }\n"]]}
{"hexsha": "329f1320c1944012db12dfb4d9d7eb4d2e85b21a", "ext": "java", "lang": "Java", "content": "public class MockNonVisibleComponent extends MockComponent {\n\n  private final Icon iconWidget;\n\n  /**\n   * Creates a new instance of a non-visible component whose icon is\n   * loaded dynamically (not part of the icon image bundle)\n   */\n  public MockNonVisibleComponent(SimpleEditor editor, String type, Image iconImage) {\n    super(editor, type, iconImage);\n    iconWidget = new Icon(iconImage);\n\n    initComponent(iconWidget);\n  }\n\n  @Override\n  public void initComponent(Widget widget) {\n    super.initComponent(widget);\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * This is always {@code false} for subclasses of this class.\n   */\n  @Override\n  public final boolean isVisibleComponent() {\n    return false;\n  }\n\n  @Override\n  public final int getPreferredHeight() {\n    return 0;\n  }\n\n  @Override\n  public final int getPreferredWidth() {\n    return 0;\n  }\n\n  @Override\n  protected final void onSelectedChange(boolean selected) {\n    super.onSelectedChange(selected);\n    if (selected) {\n      iconWidget.select();\n    } else {\n      iconWidget.deselect();\n    }\n  }\n\n  // PropertyChangeListener implementation\n\n  @Override\n  public void onPropertyChange(String propertyName, String newValue) {\n    super.onPropertyChange(propertyName, newValue);\n\n    // No visual changes after property changes (other than icon name).\n    if (propertyName.equals(PROPERTY_NAME_NAME)) {\n      iconWidget.setCaption(newValue);\n    }\n  }\n}", "class_id": 0, "repo": "souvik-bera/AppyBuilder-Source", "file": "appinventor/appengine/src/com/google/appinventor/client/editor/simple/components/MockNonVisibleComponent.java", "last_update_at": "2019-09-10T19:00:03+00:00", "question_id": "329f1320c1944012db12dfb4d9d7eb4d2e85b21a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MockNonVisibleComponent extends MockComponent {\n  private final Icon iconWidget;\n  /**\n   * Creates a new instance of a non-visible component whose icon is\n   * loaded dynamically (not part of the icon image bundle)\n   */\n  public MockNonVisibleComponent(SimpleEditor editor, String type, Image iconImage) {\n    super(editor, type, iconImage);\n    iconWidget = new Icon(iconImage);\n    initComponent(iconWidget);\n  }\n  @Override\n  public void initComponent(Widget widget) {\n    super.initComponent(widget);\n  }\n  /**\n   * {@inheritDoc}\n   *\n   * This is always {@code false} for subclasses of this class.\n   */\n  @Override\n  public final boolean isVisibleComponent() {\n    return false;\n  }\n  @Override\n  public final int getPreferredHeight() {\n    return 0;\n  }\n  @Override\n  public final int getPreferredWidth() {\n    return 0;\n  }\n  @Override\n  protected final void onSelectedChange(boolean selected) {\n    super.onSelectedChange(selected);\n    if (selected) {\n      iconWidget.select();\n    } else {\n      iconWidget.deselect();\n    }\n  }\n  // PropertyChangeListener implementation\n  @Override\n  public void onPropertyChange(String propertyName, String newValue) {\n    super.onPropertyChange(propertyName, newValue);\n    // No visual changes after property changes (other than icon name).\n    if (propertyName.equals(PROPERTY_NAME_NAME)) {\n      iconWidget.setCaption(newValue);\n    }\n  }\n"]]}
{"hexsha": "e6c54a8daf7f2de3ea9cbce44f576440373d3d4a", "ext": "java", "lang": "Java", "content": "public class userchoice\n{\n    public static void main()throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        System.out.println(\"Enter the Nth value\");\n        int n=Integer.parseInt(br.readLine());\n        System.out.println(\"Enter your choice\");\n        int ch=Integer.parseInt(br.readLine());\n        switch(ch)\n        {\n            case 1:double s=0;int j=4;\n                   for(int i=1;i<=n;i++)\n                   {\n                       s=s+(double)((double)1/(double)j);\n                       j=j+4;\n                   }\n                   System.out.println(\"Series1 is\"+s);\n                   break;\n            case 2:double s1=0;int k=1;int f;\n                   for(int i=1;i<=n;i++)\n                   {\n                       f=1;\n                       for(int j1=1;j1<=i;j1++)\n                         f=f*j1;\n                       s1=s1+(double)(((double)1/(double)f)*k);\n                       k=k*(-1);\n                    }\n                   System.out.println(\"Series2 is\"+s1);\n                   break;\n            default:System.out.println(\"Invalid Input\");\n        }\n    }\n}", "class_id": 0, "repo": "SayanGhoshBDA/code-backup", "file": "java_backup/my java/rohit_ranojoy/userchoice.java", "last_update_at": "2019-05-08T10:09:52+00:00", "question_id": "e6c54a8daf7f2de3ea9cbce44f576440373d3d4a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class userchoice\n{\n    public static void main()throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        System.out.println(\"Enter the Nth value\");\n        int n=Integer.parseInt(br.readLine());\n        System.out.println(\"Enter your choice\");\n        int ch=Integer.parseInt(br.readLine());\n        switch(ch)\n        {\n            case 1:double s=0;int j=4;\n                   for(int i=1;i<=n;i++)\n                   {\n                       s=s+(double)((double)1/(double)j);\n                       j=j+4;\n                   }\n                   System.out.println(\"Series1 is\"+s);\n                   break;\n            case 2:double s1=0;int k=1;int f;\n                   for(int i=1;i<=n;i++)\n                   {\n                       f=1;\n                       for(int j1=1;j1<=i;j1++)\n                         f=f*j1;\n                       s1=s1+(double)(((double)1/(double)f)*k);\n                       k=k*(-1);\n                    }\n                   System.out.println(\"Series2 is\"+s1);\n                   break;\n            default:System.out.println(\"Invalid Input\");\n        }\n    }\n"]]}
{"hexsha": "610b54d380f6cefdb781ddab0b330c2e086fdc76", "ext": "java", "lang": "Java", "content": "public class FamilyProfileChangePrimaryCG extends FamilyProfileChangeHead {\n\n    public static FamilyProfileChangePrimaryCG newInstance(String familyID) {\n        FamilyProfileChangePrimaryCG fragment = new FamilyProfileChangePrimaryCG();\n        Bundle args = new Bundle();\n        args.putString(FamilyProfileChangeHead.FAMILY_ID, familyID);\n        fragment.setArguments(args);\n        return fragment;\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        // Inflate the layout for this fragment\n        View root = inflater.inflate(R.layout.fragment_family_profile_change_primary_cg, container, false);\n        super.prepareViews(root);\n        members = new ArrayList<>();\n        presenter = new FamilyChangeContractPresenter(this, this.familyID);\n        presenter.getAdultMembersExcludePCG();\n        return root;\n    }\n\n    @Override\n    protected void validateSave(int itemPosition) {\n        Boolean valid = memberAdapter.validateSave((MemberAdapter.MyViewHolder) recyclerView.findViewHolderForAdapterPosition(itemPosition));\n        if (valid) {\n            HashMap<String, String> res = memberAdapter.getSelectedResults(\n                    (MemberAdapter.MyViewHolder) recyclerView.findViewHolderForAdapterPosition(itemPosition),\n                    itemPosition\n            );\n            res.put(Constants.PROFILE_CHANGE_ACTION.ACTION_TYPE, Constants.PROFILE_CHANGE_ACTION.PRIMARY_CARE_GIVER);\n            updateFamilyMember(res);\n        }\n    }\n}", "class_id": 0, "repo": "issyzac/opensrp-client", "file": "opensrp-jhpiego/src/main/java/org/smartgresiter/jhpiego/fragment/FamilyProfileChangePrimaryCG.java", "last_update_at": "2019-03-25T06:02:56+00:00", "question_id": "610b54d380f6cefdb781ddab0b330c2e086fdc76", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FamilyProfileChangePrimaryCG extends FamilyProfileChangeHead {\n    public static FamilyProfileChangePrimaryCG newInstance(String familyID) {\n        FamilyProfileChangePrimaryCG fragment = new FamilyProfileChangePrimaryCG();\n        Bundle args = new Bundle();\n        args.putString(FamilyProfileChangeHead.FAMILY_ID, familyID);\n        fragment.setArguments(args);\n        return fragment;\n    }\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        // Inflate the layout for this fragment\n        View root = inflater.inflate(R.layout.fragment_family_profile_change_primary_cg, container, false);\n        super.prepareViews(root);\n        members = new ArrayList<>();\n        presenter = new FamilyChangeContractPresenter(this, this.familyID);\n        presenter.getAdultMembersExcludePCG();\n        return root;\n    }\n    @Override\n    protected void validateSave(int itemPosition) {\n        Boolean valid = memberAdapter.validateSave((MemberAdapter.MyViewHolder) recyclerView.findViewHolderForAdapterPosition(itemPosition));\n        if (valid) {\n            HashMap<String, String> res = memberAdapter.getSelectedResults(\n                    (MemberAdapter.MyViewHolder) recyclerView.findViewHolderForAdapterPosition(itemPosition),\n                    itemPosition\n            );\n            res.put(Constants.PROFILE_CHANGE_ACTION.ACTION_TYPE, Constants.PROFILE_CHANGE_ACTION.PRIMARY_CARE_GIVER);\n            updateFamilyMember(res);\n        }\n    }\n"]]}
{"hexsha": "4bb7b0b33f43a1a96775422655b795aa952466a5", "ext": "java", "lang": "Java", "content": "public class RecentChanges extends AbstractSpecialPage {\n\n  /**\n   * We don't actually do 'recent' in terms of date as that's less useful.\n   */\n  static final long RECENT_CHANGES_DEFAULT_HISTORY_SIZE = 50;\n  static final long RECENT_CHANGES_MAX_HISTORY_SIZE = 250;\n  \n  private static final Predicate<ChangeInfo> MAJOR_ONLY = new Predicate<ChangeInfo>() {\n    public Boolean transform(final ChangeInfo in) {\n      return !in.isMinorEdit();\n    }\n  };\n\n  private final PageStore _store;\n  private final FeedWriter _feedWriter;\n  private final WikiUrls _wikiUrls;\n  private final WikiConfiguration _configuration;\n\n  public RecentChanges(final WikiConfiguration configuration, final DefaultPage defaultPage, final CachingPageStore store, final FeedWriter feedWriter, final WikiUrls wikiUrls) {\n    super(defaultPage);\n    _configuration = configuration;\n    _store = store;\n    _feedWriter = feedWriter;\n    _wikiUrls = wikiUrls;\n  }\n\n  @Override\n  public View get(PageReference page, ConsumedPath path, HttpServletRequest request, HttpServletResponse response) throws Exception {\n    final boolean showMinor = request.getParameter(\"showMinor\") != null;\n    final List<ChangeInfo> recentChanges = getRecentChanges(getLimit(request), showMinor);\n    request.setAttribute(\"recentChanges\", recentChanges);\n    if (ViewTypeConstants.is(request, CTYPE_ATOM)) {\n      return new FeedView(_configuration, _feedWriter, recentChanges, _wikiUrls.feed(URLOutputFilter.NULL));\n    }\n    return new JspView(\"RecentChanges\");\n  }\n\n  private Long getLimit(HttpServletRequest request) throws InvalidInputException {\n    Long limit = RequestParameterReaders.getLong(request, \"limit\");\n    if (limit == null) {\n      limit = RECENT_CHANGES_DEFAULT_HISTORY_SIZE;\n    }\n    limit = Math.min(limit, RECENT_CHANGES_MAX_HISTORY_SIZE);\n    return limit;\n  }\n\n  private List<ChangeInfo> getRecentChanges(final long limit, final boolean showMinor) throws PageStoreException {\n    return list(filter(_store.recentChanges(limit), showMinor ? Predicates.<ChangeInfo>all() : MAJOR_ONLY));\n  }\n\n  public String getName() {\n    return \"RecentChanges\";\n  }\n\n}", "class_id": 0, "repo": "ashirley/reviki-old", "file": "src/net/hillsdon/reviki/web/pages/impl/RecentChanges.java", "last_update_at": "2019-01-18T14:49:29+00:00", "question_id": "4bb7b0b33f43a1a96775422655b795aa952466a5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RecentChanges extends AbstractSpecialPage {\n  /**\n   * We don't actually do 'recent' in terms of date as that's less useful.\n   */\n  static final long RECENT_CHANGES_DEFAULT_HISTORY_SIZE = 50;\n  static final long RECENT_CHANGES_MAX_HISTORY_SIZE = 250;\n  private static final Predicate<ChangeInfo> MAJOR_ONLY = new Predicate<ChangeInfo>() {\n    public Boolean transform(final ChangeInfo in) {\n      return !in.isMinorEdit();\n    }\n  };\n  private final PageStore _store;\n  private final FeedWriter _feedWriter;\n  private final WikiUrls _wikiUrls;\n  private final WikiConfiguration _configuration;\n  public RecentChanges(final WikiConfiguration configuration, final DefaultPage defaultPage, final CachingPageStore store, final FeedWriter feedWriter, final WikiUrls wikiUrls) {\n    super(defaultPage);\n    _configuration = configuration;\n    _store = store;\n    _feedWriter = feedWriter;\n    _wikiUrls = wikiUrls;\n  }\n  @Override\n  public View get(PageReference page, ConsumedPath path, HttpServletRequest request, HttpServletResponse response) throws Exception {\n    final boolean showMinor = request.getParameter(\"showMinor\") != null;\n    final List<ChangeInfo> recentChanges = getRecentChanges(getLimit(request), showMinor);\n    request.setAttribute(\"recentChanges\", recentChanges);\n    if (ViewTypeConstants.is(request, CTYPE_ATOM)) {\n      return new FeedView(_configuration, _feedWriter, recentChanges, _wikiUrls.feed(URLOutputFilter.NULL));\n    }\n    return new JspView(\"RecentChanges\");\n  }\n  private Long getLimit(HttpServletRequest request) throws InvalidInputException {\n    Long limit = RequestParameterReaders.getLong(request, \"limit\");\n    if (limit == null) {\n      limit = RECENT_CHANGES_DEFAULT_HISTORY_SIZE;\n    }\n    limit = Math.min(limit, RECENT_CHANGES_MAX_HISTORY_SIZE);\n    return limit;\n  }\n  private List<ChangeInfo> getRecentChanges(final long limit, final boolean showMinor) throws PageStoreException {\n    return list(filter(_store.recentChanges(limit), showMinor ? Predicates.<ChangeInfo>all() : MAJOR_ONLY));\n  }\n  public String getName() {\n    return \"RecentChanges\";\n  }\n"]]}
{"hexsha": "e2f38036b45e16efbd8e9cbd243b8364127535d0", "ext": "java", "lang": "Java", "content": "public class AppointmentManager {\n    public static final LocalTime OPENING_HOUR = LocalTime.parse(\"09:00\");\n    public static final LocalTime CLOSING_HOUR = LocalTime.parse(\"18:00\");\n\n    private final List<Appointment> appointments;\n\n    public AppointmentManager() {\n        appointments = new ArrayList<>();\n    }\n\n    public List<Appointment> getAppointmentList() {\n        return appointments;\n    }\n\n    public void delete(Appointment app) {\n        appointments.remove(app);\n    }\n\n    public boolean hasDuplicateAppointment(Appointment app) {\n        return appointments.contains(app);\n    }\n\n\n    /**\n     * Finds and returns the {@code Appointment} in the list of appointments with the given date and start time,\n     * if it exists.\n     *\n     * @param date the {@code LocalDate} date of the {@code Appointment} to find.\n     * @param start the {@code LocalTime} start time of the {@code Appointment} to find.\n     * @return the {@code Appointment} found, if it exists, else returns {@code Optional.empty()}.\n     */\n    public Optional<Appointment> getAppointment(LocalDate date, LocalTime start) {\n        List<Appointment> filtered = appointments.stream()\n                .filter(a -> a.getDate().equals(date))\n                .filter(a -> a.getStart().equals(start))\n                .collect(Collectors.toList());\n\n        // filtered cannot contain > 1 appointment as each appointment is uniquely identified by its\n        // date and start fields.\n        assert filtered.size() <= 1;\n\n        if (filtered.isEmpty()) {\n            return Optional.empty();\n        } else {\n            return Optional.of(filtered.get(0));\n        }\n    }\n\n    /**\n     * Returns a {@code List} of {@code Appointment}s that are within the given search range of dates.\n     *\n     * @param start the {@code LocalDate start} date of the search range.\n     * @param end the {@code LocalDate end} date of the search range.\n     * @return {@code List} of {@code Appointment}s that has dates from {@code start} to {@code end}.\n     */\n    private List<Appointment> getAppointments(LocalDate start, LocalDate end) {\n        List<Appointment> validApps = new ArrayList<>();\n        LocalDate date;\n\n        for (Appointment app : appointments) {\n            date = app.getDate();\n            // Add appointments to validApps only with dates between the given range (inclusive)\n            if (date.compareTo(start) >= 0 && date.compareTo(end) <= 0) {\n                validApps.add(app);\n            }\n\n            // Stop adding when date of appointment is after given end date, since appointments are already sorted\n            if (date.compareTo(end) > 0) {\n                break;\n            }\n        }\n        return validApps;\n    }\n\n    /**\n     * Returns a {@code List} of {@code Appointment}s that were created for the given {@code Patient}.\n     *\n     * @param patient the {@code Patient} whose {@code Appointment}s to be retrieved.\n     * @return {@code List} of {@code Appointment}s that were created for {@code Patient patient}.\n     */\n    private List<Appointment> getAppointments(Patient patient) {\n        List<Appointment> validApps = new ArrayList<>();\n\n        for (Appointment app : appointments) {\n            // Add appointments to validApps only if they were created for the given patient\n            if (app.getPatient().equals(patient)) {\n                validApps.add(app);\n            }\n        }\n        return validApps;\n    }\n\n    /**\n     * Adds an {@code Appointment} to the ordered list of appointments, in the correct position.\n     *\n     * @param toAdd the {@code Appointment} to add.\n     */\n    public void addAppointment(Appointment toAdd) {\n        // checking for time conflicts should have happened in AddAppCommand\n        assert !this.hasTimeConflicts(toAdd);\n        if (appointments.isEmpty()) {\n            appointments.add(toAdd);\n            return;\n        }\n\n        // place appointment in correct position\n        for (Appointment app : appointments) {\n            if (app.compareTo(toAdd) > 0) {\n                int index = appointments.indexOf(app);\n                appointments.add(index, toAdd);\n                return;\n            }\n        }\n\n        // toAdd is to be placed at the end of the list\n        appointments.add(toAdd);\n    }\n\n    /**\n     * Checks if there are any conflicts in appointment timings between the current list of appointments\n     * and the given {@code Appointment}.\n     *\n     * @param otherApp given {@code Appointment} to check timing against the existing list of appointments.\n     * @return {@code true} if there exists a conflict in timing, else return {@code false}.\n     */\n    public boolean hasTimeConflicts(Appointment otherApp) {\n        LocalDate date = otherApp.getDate();\n\n        for (Appointment app : appointments) {\n            if (app.getDate().compareTo(date) == 0) {\n                if (hasOverlappingTime(app, otherApp)) {\n                    return true;\n                }\n            } else if (app.getDate().isAfter(date)) {\n                // terminate loop early since appointments are already sorted by date and time\n                break;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks if two {@code Appointment}s have an overlap in timing.\n     *\n     * @param appA first {@code Appointment} given.\n     * @param appB second {@code Appontment} given.\n     * @return {@code true} if there is an overlap in timing, else return {@code false}.\n     */\n    private boolean hasOverlappingTime(Appointment appA, Appointment appB) {\n        LocalTime startA = appA.getStart();\n        LocalTime endA = appA.getEnd();\n        LocalTime startB = appB.getStart();\n        LocalTime endB = appB.getEnd();\n\n        // shortcut to check for overlaps between two intervals\n        return startA.isBefore(endB) && startB.isBefore(endA);\n    }\n\n    /**\n     * Generates a {@code String} of {@code Appointment} details with dates between a search range, inclusive.\n     *\n     * @param start the {@code LocalDate start} date of the search range.\n     * @param end the {@code LocalDate end} date of the search range.\n     * @return {@code String} of {@code Appointment} details with dates from {@code start} to {@code end}.\n     */\n    public String listAppointments(LocalDate start, LocalDate end) {\n        List<Appointment> toList = getAppointments(start, end);\n        return listAppointments(toList);\n    }\n\n    /**\n     * Generates a {@code String} of {@code Appointment} details created for a given {@code Patient}.\n     *\n     * @param patient the {@code Patient} whose {@code Appointment} details to list.\n     * @return {@code String} of {@code Appointment} details created for the given {@code Patient}.\n     */\n    public String listAppointments(Patient patient) {\n        List<Appointment> toList = getAppointments(patient);\n        return listAppointments(toList);\n    }\n\n    /**\n     * Generates a {@code String} of {@code Appointment} details given the appointments.\n     *\n     * @param appsToList the {@code List} of {@code Appointment}s to list.\n     * @return {@code String} of {@code Appointment} details.\n     */\n    public String listAppointments(List<Appointment> appsToList) {\n        StringBuilder sb = new StringBuilder();\n        // index of the appointment to be displayed\n        int i = 1;\n\n        for (Appointment app : appsToList) {\n            sb.append(i)\n                    .append(\") \")\n                    .append(app.toString())\n                    .append(\"\\n\");\n            i++;\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Generates a {@code List} of free {@code Slot}s within a given search range of dates.\n     * A {@code Slot} is free if there are no {@code Appointment}s scheduled during that time slot.\n     *\n     * @param start the {@code LocalDate start} date of the search range.\n     * @param end the {@code LocalDate end} date of the search range.\n     * @return {@code List} of free {@code Slot}s within the given search range.\n     */\n    private List<Slot> getFreeSlots(LocalDate start, LocalDate end) {\n        List<Slot> freeSlots = new ArrayList<>();\n        List<Appointment> toSearch = getAppointments(start, end);\n\n        // all slots are free\n        if (toSearch.isEmpty()) {\n            for (LocalDate date = start; date.compareTo(end) <= 0; date = date.plusDays(1)) {\n                freeSlots.add(new Slot(date, OPENING_HOUR, CLOSING_HOUR));\n            }\n            return freeSlots;\n        }\n\n        Slot slot;\n        LocalDate date = start;\n        int index = 0;\n        Appointment app = toSearch.get(index);\n        Appointment prevApp = new Appointment(\n                app.getPatient(), app.getDate().minusDays(1), app.getStart(), app.getEnd(), app.getComment());\n\n        // loop through all search dates from the start\n        while (date.compareTo(end) <= 0) {\n\n            // no appointments for given date\n            if (!date.isEqual(app.getDate())) {\n                slot = new Slot(date, OPENING_HOUR, CLOSING_HOUR);\n                freeSlots.add(slot);\n            }\n\n            LocalTime startTime;\n            LocalTime endTime;\n            // there are appointments in given date\n            while (date.isEqual(app.getDate())) {\n\n                // start a new slot for the day\n                if (prevApp.getDate().isBefore(date)) {\n                    startTime = OPENING_HOUR;\n                } else {\n                    startTime = prevApp.getEnd();\n                }\n                endTime = app.getStart();\n\n                // do not add a free slot if the start time and end time are the same\n                if (startTime != endTime) {\n                    slot = new Slot(date, startTime, endTime);\n                    freeSlots.add(slot);\n                }\n                prevApp = app;\n\n                // no more next appointment, create last slot for the day\n                if (toSearch.size() == index + 1 || date.isBefore(toSearch.get(index + 1).getDate())) {\n                    startTime = app.getEnd();\n                    endTime = CLOSING_HOUR;\n\n                    // do not add a free slot if the start time and end time are the same\n                    if (startTime != endTime) {\n                        slot = new Slot(date, startTime, endTime);\n                        freeSlots.add(slot);\n                    }\n\n                    // no more appointments in toSearch\n                    if (toSearch.size() == index + 1) {\n                        break;\n                    }\n                }\n                index++;\n                app = toSearch.get(index);\n            }\n\n            date = date.plusDays(1);\n        }\n\n        return freeSlots;\n    }\n\n    /**\n     * Generates a {@code String} of free {@code Slot}s given a search range of dates.\n     * A {@code Slot} is free if there are no {@code Appointment}s scheduled during that time slot.\n     *\n     * @param start the {@code LocalDate start} date of the search range.\n     * @param end the {@code LocalDate end} date of the search range.\n     * @return {@code String} of free {@code Slot}s within the given search range.\n     */\n    public String listFreeSlots(LocalDate start, LocalDate end) {\n        List<Slot> freeSlots = getFreeSlots(start, end);\n        StringBuilder sb = new StringBuilder();\n        LocalDate date = start.minusDays(1);\n\n        for (Slot slot : freeSlots) {\n            // start listing for a new date\n            if (slot.getDate().isAfter(date)) {\n                date = slot.getDate();\n                sb.append(\"\\n\")\n                        .append(date)\n                        .append(\": \");\n            } else {\n                sb.append(\", \");\n            }\n\n            // Whole day is free\n            if (slot.getStart().equals(OPENING_HOUR) && slot.getEnd().equals(CLOSING_HOUR)) {\n                sb.append(\"All slots are free\");\n            } else {\n                sb.append(slot.getStart())\n                        .append(\" to \")\n                        .append(slot.getEnd());\n            }\n        }\n        return sb.toString();\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        if (other == this) {\n            return true;\n        }\n\n        if (!(other instanceof AppointmentManager)) {\n            return false;\n        }\n\n        AppointmentManager otherManager = (AppointmentManager) other;\n        return otherManager.appointments.equals(this.appointments);\n    }\n}", "class_id": 0, "repo": "ongaaron96/main", "file": "src/main/java/quickdocs/model/appointment/AppointmentManager.java", "last_update_at": "2019-07-26T07:18:53+00:00", "question_id": "e2f38036b45e16efbd8e9cbd243b8364127535d0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AppointmentManager {\n    public static final LocalTime OPENING_HOUR = LocalTime.parse(\"09:00\");\n    public static final LocalTime CLOSING_HOUR = LocalTime.parse(\"18:00\");\n    private final List<Appointment> appointments;\n    public AppointmentManager() {\n        appointments = new ArrayList<>();\n    }\n    public List<Appointment> getAppointmentList() {\n        return appointments;\n    }\n    public void delete(Appointment app) {\n        appointments.remove(app);\n    }\n    public boolean hasDuplicateAppointment(Appointment app) {\n        return appointments.contains(app);\n    }\n    /**\n     * Finds and returns the {@code Appointment} in the list of appointments with the given date and start time,\n     * if it exists.\n     *\n     * @param date the {@code LocalDate} date of the {@code Appointment} to find.\n     * @param start the {@code LocalTime} start time of the {@code Appointment} to find.\n     * @return the {@code Appointment} found, if it exists, else returns {@code Optional.empty()}.\n     */\n    public Optional<Appointment> getAppointment(LocalDate date, LocalTime start) {\n        List<Appointment> filtered = appointments.stream()\n                .filter(a -> a.getDate().equals(date))\n                .filter(a -> a.getStart().equals(start))\n                .collect(Collectors.toList());\n        // filtered cannot contain > 1 appointment as each appointment is uniquely identified by its\n        // date and start fields.\n        assert filtered.size() <= 1;\n        if (filtered.isEmpty()) {\n            return Optional.empty();\n        } else {\n            return Optional.of(filtered.get(0));\n        }\n    }\n    /**\n     * Returns a {@code List} of {@code Appointment}s that are within the given search range of dates.\n     *\n     * @param start the {@code LocalDate start} date of the search range.\n     * @param end the {@code LocalDate end} date of the search range.\n     * @return {@code List} of {@code Appointment}s that has dates from {@code start} to {@code end}.\n     */\n    private List<Appointment> getAppointments(LocalDate start, LocalDate end) {\n        List<Appointment> validApps = new ArrayList<>();\n        LocalDate date;\n        for (Appointment app : appointments) {\n            date = app.getDate();\n            // Add appointments to validApps only with dates between the given range (inclusive)\n            if (date.compareTo(start) >= 0 && date.compareTo(end) <= 0) {\n                validApps.add(app);\n            }\n            // Stop adding when date of appointment is after given end date, since appointments are already sorted\n            if (date.compareTo(end) > 0) {\n                break;\n            }\n        }\n        return validApps;\n    }\n    /**\n     * Returns a {@code List} of {@code Appointment}s that were created for the given {@code Patient}.\n     *\n     * @param patient the {@code Patient} whose {@code Appointment}s to be retrieved.\n     * @return {@code List} of {@code Appointment}s that were created for {@code Patient patient}.\n     */\n    private List<Appointment> getAppointments(Patient patient) {\n        List<Appointment> validApps = new ArrayList<>();\n        for (Appointment app : appointments) {\n            // Add appointments to validApps only if they were created for the given patient\n            if (app.getPatient().equals(patient)) {\n                validApps.add(app);\n            }\n        }\n        return validApps;\n    }\n    /**\n     * Adds an {@code Appointment} to the ordered list of appointments, in the correct position.\n     *\n     * @param toAdd the {@code Appointment} to add.\n     */\n    public void addAppointment(Appointment toAdd) {\n        // checking for time conflicts should have happened in AddAppCommand\n        assert !this.hasTimeConflicts(toAdd);\n        if (appointments.isEmpty()) {\n            appointments.add(toAdd);\n            return;\n        }\n        // place appointment in correct position\n        for (Appointment app : appointments) {\n            if (app.compareTo(toAdd) > 0) {\n                int index = appointments.indexOf(app);\n                appointments.add(index, toAdd);\n                return;\n            }\n        }\n        // toAdd is to be placed at the end of the list\n        appointments.add(toAdd);\n    }\n    /**\n     * Checks if there are any conflicts in appointment timings between the current list of appointments\n     * and the given {@code Appointment}.\n     *\n     * @param otherApp given {@code Appointment} to check timing against the existing list of appointments.\n     * @return {@code true} if there exists a conflict in timing, else return {@code false}.\n     */\n    public boolean hasTimeConflicts(Appointment otherApp) {\n        LocalDate date = otherApp.getDate();\n        for (Appointment app : appointments) {\n            if (app.getDate().compareTo(date) == 0) {\n                if (hasOverlappingTime(app, otherApp)) {\n                    return true;\n                }\n            } else if (app.getDate().isAfter(date)) {\n                // terminate loop early since appointments are already sorted by date and time\n                break;\n            }\n        }\n        return false;\n    }\n    /**\n     * Checks if two {@code Appointment}s have an overlap in timing.\n     *\n     * @param appA first {@code Appointment} given.\n     * @param appB second {@code Appontment} given.\n     * @return {@code true} if there is an overlap in timing, else return {@code false}.\n     */\n    private boolean hasOverlappingTime(Appointment appA, Appointment appB) {\n        LocalTime startA = appA.getStart();\n        LocalTime endA = appA.getEnd();\n        LocalTime startB = appB.getStart();\n        LocalTime endB = appB.getEnd();\n        // shortcut to check for overlaps between two intervals\n        return startA.isBefore(endB) && startB.isBefore(endA);\n    }\n    /**\n     * Generates a {@code String} of {@code Appointment} details with dates between a search range, inclusive.\n     *\n     * @param start the {@code LocalDate start} date of the search range.\n     * @param end the {@code LocalDate end} date of the search range.\n     * @return {@code String} of {@code Appointment} details with dates from {@code start} to {@code end}.\n     */\n    public String listAppointments(LocalDate start, LocalDate end) {\n        List<Appointment> toList = getAppointments(start, end);\n        return listAppointments(toList);\n    }\n    /**\n     * Generates a {@code String} of {@code Appointment} details created for a given {@code Patient}.\n     *\n     * @param patient the {@code Patient} whose {@code Appointment} details to list.\n     * @return {@code String} of {@code Appointment} details created for the given {@code Patient}.\n     */\n    public String listAppointments(Patient patient) {\n        List<Appointment> toList = getAppointments(patient);\n        return listAppointments(toList);\n    }\n    /**\n     * Generates a {@code String} of {@code Appointment} details given the appointments.\n     *\n     * @param appsToList the {@code List} of {@code Appointment}s to list.\n     * @return {@code String} of {@code Appointment} details.\n     */\n    public String listAppointments(List<Appointment> appsToList) {\n        StringBuilder sb = new StringBuilder();\n        // index of the appointment to be displayed\n        int i = 1;\n        for (Appointment app : appsToList) {\n            sb.append(i)\n                    .append(\") \")\n                    .append(app.toString())\n                    .append(\"\\n\");\n            i++;\n        }\n        return sb.toString();\n    }\n    /**\n     * Generates a {@code List} of free {@code Slot}s within a given search range of dates.\n     * A {@code Slot} is free if there are no {@code Appointment}s scheduled during that time slot.\n     *\n     * @param start the {@code LocalDate start} date of the search range.\n     * @param end the {@code LocalDate end} date of the search range.\n     * @return {@code List} of free {@code Slot}s within the given search range.\n     */\n    private List<Slot> getFreeSlots(LocalDate start, LocalDate end) {\n        List<Slot> freeSlots = new ArrayList<>();\n        List<Appointment> toSearch = getAppointments(start, end);\n        // all slots are free\n        if (toSearch.isEmpty()) {\n            for (LocalDate date = start; date.compareTo(end) <= 0; date = date.plusDays(1)) {\n                freeSlots.add(new Slot(date, OPENING_HOUR, CLOSING_HOUR));\n            }\n            return freeSlots;\n        }\n        Slot slot;\n        LocalDate date = start;\n        int index = 0;\n        Appointment app = toSearch.get(index);\n        Appointment prevApp = new Appointment(\n                app.getPatient(), app.getDate().minusDays(1), app.getStart(), app.getEnd(), app.getComment());\n        // loop through all search dates from the start\n        while (date.compareTo(end) <= 0) {\n            // no appointments for given date\n            if (!date.isEqual(app.getDate())) {\n                slot = new Slot(date, OPENING_HOUR, CLOSING_HOUR);\n                freeSlots.add(slot);\n            }\n            LocalTime startTime;\n            LocalTime endTime;\n            // there are appointments in given date\n            while (date.isEqual(app.getDate())) {\n                // start a new slot for the day\n                if (prevApp.getDate().isBefore(date)) {\n                    startTime = OPENING_HOUR;\n                } else {\n                    startTime = prevApp.getEnd();\n                }\n                endTime = app.getStart();\n                // do not add a free slot if the start time and end time are the same\n                if (startTime != endTime) {\n                    slot = new Slot(date, startTime, endTime);\n                    freeSlots.add(slot);\n                }\n                prevApp = app;\n                // no more next appointment, create last slot for the day\n                if (toSearch.size() == index + 1 || date.isBefore(toSearch.get(index + 1).getDate())) {\n                    startTime = app.getEnd();\n                    endTime = CLOSING_HOUR;\n                    // do not add a free slot if the start time and end time are the same\n                    if (startTime != endTime) {\n                        slot = new Slot(date, startTime, endTime);\n                        freeSlots.add(slot);\n                    }\n                    // no more appointments in toSearch\n                    if (toSearch.size() == index + 1) {\n                        break;\n                    }\n                }\n                index++;\n                app = toSearch.get(index);\n            }\n            date = date.plusDays(1);\n        }\n        return freeSlots;\n    }\n    /**\n     * Generates a {@code String} of free {@code Slot}s given a search range of dates.\n     * A {@code Slot} is free if there are no {@code Appointment}s scheduled during that time slot.\n     *\n     * @param start the {@code LocalDate start} date of the search range.\n     * @param end the {@code LocalDate end} date of the search range.\n     * @return {@code String} of free {@code Slot}s within the given search range.\n     */\n    public String listFreeSlots(LocalDate start, LocalDate end) {\n        List<Slot> freeSlots = getFreeSlots(start, end);\n        StringBuilder sb = new StringBuilder();\n        LocalDate date = start.minusDays(1);\n        for (Slot slot : freeSlots) {\n            // start listing for a new date\n            if (slot.getDate().isAfter(date)) {\n                date = slot.getDate();\n                sb.append(\"\\n\")\n                        .append(date)\n                        .append(\": \");\n            } else {\n                sb.append(\", \");\n            }\n            // Whole day is free\n            if (slot.getStart().equals(OPENING_HOUR) && slot.getEnd().equals(CLOSING_HOUR)) {\n                sb.append(\"All slots are free\");\n            } else {\n                sb.append(slot.getStart())\n                        .append(\" to \")\n                        .append(slot.getEnd());\n            }\n        }\n        return sb.toString();\n    }\n    @Override\n    public boolean equals(Object other) {\n        if (other == this) {\n            return true;\n        }\n        if (!(other instanceof AppointmentManager)) {\n            return false;\n        }\n        AppointmentManager otherManager = (AppointmentManager) other;\n        return otherManager.appointments.equals(this.appointments);\n    }\n"]]}
{"hexsha": "6604793eed37901b5888d3a2f11c282c414079e8", "ext": "java", "lang": "Java", "content": "class FinnDateConverter {\n\n    private static final String FINN_DATE_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss[.SSS]Z\";\n\n\n    public static LocalDateTime convertDate(String date) {\n        if (StringUtils.isBlank(date)) {\n            return null;\n        }\n\n        date = date.replace(\"Z\", \"+0000\");\n        return LocalDateTime.parse(date, DateTimeFormatter.ofPattern(FINN_DATE_PATTERN));\n    }\n\n    public static String toString(LocalDateTime date) {\n\n        String dateValue = date.atZone(ZoneId.of(\"Z\"))\n                .format(DateTimeFormatter.ofPattern(FINN_DATE_PATTERN));\n        return dateValue.replace(\"+0000\", \"Z\");\n    }\n}", "class_id": 0, "repo": "FeatureToggleStudy/pam-annonsemottak", "file": "src/main/java/no/nav/pam/annonsemottak/receivers/finn/FinnDateConverter.java", "last_update_at": "2019-12-12T20:50:28+00:00", "question_id": "6604793eed37901b5888d3a2f11c282c414079e8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class FinnDateConverter {\n    private static final String FINN_DATE_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss[.SSS]Z\";\n    public static LocalDateTime convertDate(String date) {\n        if (StringUtils.isBlank(date)) {\n            return null;\n        }\n        date = date.replace(\"Z\", \"+0000\");\n        return LocalDateTime.parse(date, DateTimeFormatter.ofPattern(FINN_DATE_PATTERN));\n    }\n    public static String toString(LocalDateTime date) {\n        String dateValue = date.atZone(ZoneId.of(\"Z\"))\n                .format(DateTimeFormatter.ofPattern(FINN_DATE_PATTERN));\n        return dateValue.replace(\"+0000\", \"Z\");\n    }\n"]]}
{"hexsha": "6bbbbef48b6488c2618a9019bddf3c467e6eb7d3", "ext": "java", "lang": "Java", "content": "@Configuration\npublic class VelocityEngineProvider {\n    @Bean\n    public VelocityEngine velocityEngine() {\n        VelocityEngine velocityEngine = new VelocityEngine();\n\n        velocityEngine.setProperty(\"resource.loader\", \"class\");\n        velocityEngine.setProperty(\"class.resource.loader.class\",\n                \"org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader\");\n        velocityEngine.setProperty(RuntimeConstants.EVENTHANDLER_INCLUDE, IncludeRelativePath.class.getName());\n        velocityEngine.setProperty(\"velocimacro.library\", TemplatesLocation.MACROS);\n\n        velocityEngine.init();\n\n        return velocityEngine;\n    }\n}", "class_id": 0, "repo": "stori-es/stories", "file": "dashboard/src/main/java/org/consumersunion/stories/server/velocity/VelocityEngineProvider.java", "last_update_at": "2019-06-12T18:51:01+00:00", "question_id": "6bbbbef48b6488c2618a9019bddf3c467e6eb7d3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Configuration\npublic class VelocityEngineProvider {\n    @Bean\n    public VelocityEngine velocityEngine() {\n        VelocityEngine velocityEngine = new VelocityEngine();\n        velocityEngine.setProperty(\"resource.loader\", \"class\");\n        velocityEngine.setProperty(\"class.resource.loader.class\",\n                \"org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader\");\n        velocityEngine.setProperty(RuntimeConstants.EVENTHANDLER_INCLUDE, IncludeRelativePath.class.getName());\n        velocityEngine.setProperty(\"velocimacro.library\", TemplatesLocation.MACROS);\n        velocityEngine.init();\n        return velocityEngine;\n    }\n"]]}
{"hexsha": "0d9aecb6dc3050bed6dd31bcbed57b1cf8b9abad", "ext": "java", "lang": "Java", "content": "public class TypoTokenFilterFactory extends TokenFilterFactory implements ResourceLoaderAware, MultiTermAwareComponent {\n\n    private final HashMap<String, String> normMap = new HashMap<>();\n    private final String dictionary;\n\n    public TypoTokenFilterFactory(Map<String, String> args) {\n        super(args);\n        dictionary = require(args, \"dictionary\");\n\n        if (!args.isEmpty()) {\n            throw new IllegalArgumentException(\"Unknown parameters: \" + args);\n        }\n    }\n\n    @Override\n    public TokenStream create(TokenStream tokenStream) {\n        return new TypoTokenFilter(tokenStream, normMap);\n    }\n\n    @Override\n    public AbstractAnalysisFactory getMultiTermComponent() {\n        return this;\n    }\n\n    @Override\n    public void inform(ResourceLoader loader) throws IOException {\n\n        Set<String> wlist = new HashSet<>();\n        List<String> files = splitFileNames(dictionary);\n\n        for (String file : files) {\n            List<String> lines = getLines(loader, file.trim());\n            wlist.addAll(lines);\n        }\n\n        for (String s : wlist) {\n\n            String[] parts = s.split(\"\\t\");\n\n            if (parts.length != 2) throw new RuntimeException(\"more than two words in the phrase \" + s);\n\n            if (parts[0].contains(\" \") || parts[1].contains(\" \"))\n                throw new RuntimeException(\"typo parts should not contain spaces \" + String.join(\"_\", parts));\n\n            normMap.put(parts[0], parts[1]);\n        }\n\n\n    }\n\n\n    private static final class TypoTokenFilter extends TokenFilter {\n\n        private final HashMap<String, String> map;\n\n        private final CharTermAttribute termAttribute = addAttribute(CharTermAttribute.class);\n\n        TypoTokenFilter(TokenStream input, HashMap<String, String> map) {\n            super(input);\n            this.map = map;\n        }\n\n        @Override\n        public boolean incrementToken() throws IOException {\n\n            if (!input.incrementToken()) return false;\n\n            final String term = termAttribute.toString();\n\n            //    boolean matched = false;\n\n            List<String> matchedKeys = new ArrayList<>();\n\n            for (String key : map.keySet()) {\n                if (term.startsWith(key)) {\n                    matchedKeys.add(key);\n                }\n            }\n\n            if (matchedKeys.size() == 1) {\n                termAttribute.setEmpty().append(map.get(matchedKeys.get(0)));\n            } else if (matchedKeys.size() > 1) {\n                String minKey = Collections.min(matchedKeys, Comparator.comparingInt(String::length));\n                termAttribute.setEmpty().append(map.get(minKey));\n                System.out.println(minKey + \" \" + matchedKeys);\n            }\n\n            return true;\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        String text = \"egzos egzost yunanl\u0131 orjinal cimnastik yapm\u0131\u015flar anotomi motorsiklet motorsiklette orjinali orjinalleri\";\n        System.out.println(\"--------typo----------------\");\n        System.out.println(getAnalyzedString(text, typo()));\n    }\n}", "class_id": 0, "repo": "iorixxx/Kemik", "file": "src/main/java/edu/anadolu/TypoTokenFilterFactory.java", "last_update_at": "2019-08-04T13:18:37+00:00", "question_id": "0d9aecb6dc3050bed6dd31bcbed57b1cf8b9abad", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TypoTokenFilterFactory extends TokenFilterFactory implements ResourceLoaderAware, MultiTermAwareComponent {\n    private final HashMap<String, String> normMap = new HashMap<>();\n    private final String dictionary;\n    public TypoTokenFilterFactory(Map<String, String> args) {\n        super(args);\n        dictionary = require(args, \"dictionary\");\n        if (!args.isEmpty()) {\n            throw new IllegalArgumentException(\"Unknown parameters: \" + args);\n        }\n    }\n    @Override\n    public TokenStream create(TokenStream tokenStream) {\n        return new TypoTokenFilter(tokenStream, normMap);\n    }\n    @Override\n    public AbstractAnalysisFactory getMultiTermComponent() {\n        return this;\n    }\n    @Override\n    public void inform(ResourceLoader loader) throws IOException {\n        Set<String> wlist = new HashSet<>();\n        List<String> files = splitFileNames(dictionary);\n        for (String file : files) {\n            List<String> lines = getLines(loader, file.trim());\n            wlist.addAll(lines);\n        }\n        for (String s : wlist) {\n            String[] parts = s.split(\"\\t\");\n            if (parts.length != 2) throw new RuntimeException(\"more than two words in the phrase \" + s);\n            if (parts[0].contains(\" \") || parts[1].contains(\" \"))\n                throw new RuntimeException(\"typo parts should not contain spaces \" + String.join(\"_\", parts));\n            normMap.put(parts[0], parts[1]);\n        }\n    }\n    private static final class TypoTokenFilter extends TokenFilter {\n        private final HashMap<String, String> map;\n        private final CharTermAttribute termAttribute = addAttribute(CharTermAttribute.class);\n        TypoTokenFilter(TokenStream input, HashMap<String, String> map) {\n            super(input);\n            this.map = map;\n        }\n        @Override\n        public boolean incrementToken() throws IOException {\n            if (!input.incrementToken()) return false;\n            final String term = termAttribute.toString();\n            //    boolean matched = false;\n            List<String> matchedKeys = new ArrayList<>();\n            for (String key : map.keySet()) {\n                if (term.startsWith(key)) {\n                    matchedKeys.add(key);\n                }\n            }\n            if (matchedKeys.size() == 1) {\n                termAttribute.setEmpty().append(map.get(matchedKeys.get(0)));\n            } else if (matchedKeys.size() > 1) {\n                String minKey = Collections.min(matchedKeys, Comparator.comparingInt(String::length));\n                termAttribute.setEmpty().append(map.get(minKey));\n                System.out.println(minKey + \" \" + matchedKeys);\n            }\n            return true;\n        }\n    }\n    public static void main(String[] args) throws Exception {\n        String text = \"egzos egzost yunanl\u0131 orjinal cimnastik yapm\u0131\u015flar anotomi motorsiklet motorsiklette orjinali orjinalleri\";\n        System.out.println(\"--------typo----------------\");\n        System.out.println(getAnalyzedString(text, typo()));\n    }\n"]]}
{"hexsha": "f6497444b00f21016a5008d62ccd5c337ea9bd72", "ext": "java", "lang": "Java", "content": "public class E32_OrnamentalGarden3 {\n    public static void main(String[] args) throws Exception {\n        // All must share a single CountDownLatch object:\n        CountDownLatch latch = new CountDownLatch(5);\n        ExecutorService exec = Executors.newCachedThreadPool();\n        for (int i = 0; i < 5; i++)\n            exec.execute(new Entrance3(latch, i));\n        TimeUnit.SECONDS.sleep(3);\n        Entrance3.cancel();\n        exec.shutdown();\n        latch.await();  // Wait for results\n        print(\"Total: \" + Entrance3.getTotalCount());\n        print(\"Sum of Entrances: \" + Entrance3.sumEntrances());\n    }\n}", "class_id": 1, "repo": "letitgone/thinking_in_java", "file": "Chapter21/src/test/java/E32_OrnamentalGarden3.java", "last_update_at": "2019-03-18T11:31:22+00:00", "question_id": "f6497444b00f21016a5008d62ccd5c337ea9bd72", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class E32_OrnamentalGarden3 {\n    public static void main(String[] args) throws Exception {\n        // All must share a single CountDownLatch object:\n        CountDownLatch latch = new CountDownLatch(5);\n        ExecutorService exec = Executors.newCachedThreadPool();\n        for (int i = 0; i < 5; i++)\n            exec.execute(new Entrance3(latch, i));\n        TimeUnit.SECONDS.sleep(3);\n        Entrance3.cancel();\n        exec.shutdown();\n        latch.await();  // Wait for results\n        print(\"Total: \" + Entrance3.getTotalCount());\n        print(\"Sum of Entrances: \" + Entrance3.sumEntrances());\n    }\n"]]}
{"hexsha": "bdfdc02944813387a0451c853da04caa89656fc2", "ext": "java", "lang": "Java", "content": "public class Products {\n\n\tpublic int[] product(int[] array) {\n\t\tint product = 1;\n\t\tint[] productArray = new int[array.length];\n\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array.length; j++) {\n\t\t\t\tif (j != i) {\n\t\t\t\t\tproduct = product * array[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tproductArray[i] = product;\n\t\t\tproduct = 1;\n\t\t}\n\t\treturn productArray;\n\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tProducts test = new Products();\n\t\tint[] array = { 1, 2, 3, 4, 5 };\n\n\t\tint[] array1 = test.product(array);\n\n\t\tfor (int k : array1) {\n\t\t\tSystem.out.println(k);\n\t\t}\n\t}\n}", "class_id": 0, "repo": "krrajpurohit/Java", "file": "problems/Products.java", "last_update_at": "2019-10-18T06:09:57+00:00", "question_id": "bdfdc02944813387a0451c853da04caa89656fc2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Products {\n\tpublic int[] product(int[] array) {\n\t\tint product = 1;\n\t\tint[] productArray = new int[array.length];\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array.length; j++) {\n\t\t\t\tif (j != i) {\n\t\t\t\t\tproduct = product * array[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tproductArray[i] = product;\n\t\t\tproduct = 1;\n\t\t}\n\t\treturn productArray;\n\t}\n\tpublic static void main(String[] args) {\n\t\tProducts test = new Products();\n\t\tint[] array = { 1, 2, 3, 4, 5 };\n\t\tint[] array1 = test.product(array);\n\t\tfor (int k : array1) {\n\t\t\tSystem.out.println(k);\n\t\t}\n\t}\n"]]}
{"hexsha": "80ee0a6a7f3a4985856807c16dd83c933a62d954", "ext": "java", "lang": "Java", "content": "@Path(\"/mr_clients\")\n@Api( value= \"MR_Clients\", description = \"Endpoint for a Message Router Client that implements a Publisher or a Subscriber\" )\n@Consumes(MediaType.APPLICATION_JSON)\n@Produces(MediaType.APPLICATION_JSON)\n@Authorization\npublic class MR_ClientResource extends BaseLoggingClass {\n\n\tprivate MR_ClientService mr_clientService = new MR_ClientService();\n\tprivate ResponseBuilder responseBuilder = new ResponseBuilder();\n\tprivate RequiredChecker checker = new RequiredChecker();\n\t\t\n\t@GET\n\t@ApiOperation( value = \"return MR_Client details\", \n\tnotes = \"Returns array of  `MR_Client` objects.\", \n\tresponse = MR_Client.class)\n\t@ApiResponses( value = {\n\t    @ApiResponse( code = 200, message = \"Success\", response = MR_Client.class),\n\t    @ApiResponse( code = 400, message = \"Error\", response = ApiError.class )\n\t})\n\tpublic Response getMr_Clients() {\n\t\tList<MR_Client> clients = mr_clientService.getAllMr_Clients();\n\n\t\tGenericEntity<List<MR_Client>> list = new GenericEntity<List<MR_Client>>(clients) {\n        };\n        return responseBuilder.success(list);\n\t}\n\t\t\n\t@POST\n\t@ApiOperation( value = \"Associate an MR_Client object to a Topic\", \n\tnotes = \"Create a  `MR_Client` object.\"\n\t\t\t+ \"The `dcaeLocation` attribute is used to match an `MR_Cluster` object with the same value, with the intent of localizing message traffic.\"\n\t\t\t+ \"  In legacy implementation, the `clientRole` is granted appropriate permission in AAF.\"\n\t\t\t+ \"  Newer implementions may instead specify an AAF Identity, which will be added to the appropriate `Topic` role.\", \n\tresponse = MR_Client.class)\n\t@ApiResponses( value = {\n\t    @ApiResponse( code = 200, message = \"Success\", response = MR_Client.class),\n\t    @ApiResponse( code = 400, message = \"Error\", response = ApiError.class )\n\t})\n\tpublic Response addMr_Client(MR_Client client) {\n\t\tApiError apiError = new ApiError();\n\n\t\ttry {\n\t\t\tchecker.required( \"fqtn\", client.getFqtn());\n\t\t\tchecker.required( \"dcaeLocationName\", client.getDcaeLocationName());\n\t\t\tString s = client.getClientRole();\n\t\t\tif ( s == null ) {\n\t\t\t\ts = client.getClientIdentity();\n\t\t\t}\n\t\t\tchecker.required( \"clientRole or clientIdentity\", s);\n\t\t\tchecker.required( \"action\", client.getAction());\n\n\t\t} catch ( RequiredFieldException rfe ) {\n\t\t\tlogger.debug( rfe.getApiError().toString() );\n\t\t\treturn responseBuilder.error(rfe.getApiError());\n\t\t}\n\t\tMR_ClusterService clusters = new MR_ClusterService();\n\n\t\tMR_Cluster cluster = clusters.getMr_Cluster(client.getDcaeLocationName(), apiError);\n\t\tif ( cluster == null ) {\n\n\t\t\tapiError.setCode(Status.BAD_REQUEST.getStatusCode());\n\t\t\tapiError.setMessage( \"MR_Cluster alias not found for dcaeLocation: \" + client.getDcaeLocationName());\n\t\t\tapiError.setFields(\"dcaeLocationName\");\n\t\t\tlogger.warn(apiError.toString());\n\t\t\treturn responseBuilder.error(apiError);\n\t\t}\n\n\t\tTopicService topics = new TopicService();\n\n\t\tTopic t = topics.getTopic(client.getFqtn(), apiError);\n\t\tif ( t == null ) {\n\t\t\treturn responseBuilder.error(apiError);\n\t\t}\n\t\tMR_Client nClient =  mr_clientService.addMr_Client(client, t, apiError);\n\t\tif (apiError.is2xx()) {\n\t\t\tt = topics.getTopic(client.getFqtn(), apiError);\n\t\t\ttopics.checkForBridge(t, apiError);\n\t\t\treturn responseBuilder.success(nClient);\n\t\t}\n\t\telse {\n\t\t\treturn responseBuilder.error(apiError);\n\t\t}\n\t}\n\t\t\n\t@PUT\n\t@ApiOperation( value = \"Update an MR_Client object\", \n\tnotes = \"Update a  `MR_Client` object, specified by clientId\", \n\tresponse = MR_Client.class)\n\t@ApiResponses( value = {\n\t    @ApiResponse( code = 200, message = \"Success\", response = MR_Client.class),\n\t    @ApiResponse( code = 400, message = \"Error\", response = ApiError.class )\n\t})\n\t@Path(\"/{clientId}\")\n\tpublic Response updateMr_Client(@PathParam(\"clientId\") String clientId, MR_Client client) {\n\t\tApiError apiError = new ApiError();\n\n\t\ttry {\n\t\t\tchecker.required( \"fqtn\", client.getFqtn());\n\t\t\tchecker.required( \"dcaeLocationName\", client.getDcaeLocationName());\n\t\t\tchecker.required( \"clientRole\", client.getClientRole());\n\t\t\tchecker.required( \"action\", client.getAction());\n\n\t\t} catch ( RequiredFieldException rfe ) {\n\t\t\tlogger.debug( rfe.getApiError().toString() );\n\t\t\treturn responseBuilder.error(rfe.getApiError());\n\t\t}\n\t\tclient.setMrClientId(clientId);\n\t\tMR_Client nClient = mr_clientService.updateMr_Client(client, apiError);\n\t\tif (apiError.is2xx()) {\n\t\t\treturn Response.ok(nClient)\n\t\t\t\t.build();\n\t\t}\n\t\treturn Response.status(apiError.getCode())\n\t\t\t\t.entity(apiError)\n\t\t\t\t.build();\n\t}\n\t\t\n\t@DELETE\n\t@ApiOperation( value = \"Delete an MR_Client object\", \n\tnotes = \"Delete a  `MR_Client` object, specified by clientId\", \n\tresponse = MR_Client.class)\n\t@ApiResponses( value = {\n\t    @ApiResponse( code = 204, message = \"Success\", response = MR_Client.class),\n\t    @ApiResponse( code = 400, message = \"Error\", response = ApiError.class )\n\t})\n\t@Path(\"/{subId}\")\n\tpublic Response deleteMr_Client(@PathParam(\"subId\") String id){\n\t\tApiError apiError = new ApiError();\n\n\t\tmr_clientService.removeMr_Client(id, true, apiError);\n\t\tif (apiError.is2xx()) {\n\t\t\treturn responseBuilder.success(NO_CONTENT.getStatusCode(), null);\n\t\t}\n\t\t\n\t\treturn responseBuilder.error(apiError);\n\t}\n\n\t@GET\n\t@ApiOperation( value = \"return MR_Client details\", \n\tnotes = \"Retrieve a  `MR_Client` object, specified by clientId\", \n\tresponse = MR_Client.class)\n\t@ApiResponses( value = {\n\t    @ApiResponse( code = 200, message = \"Success\", response = MR_Client.class),\n\t    @ApiResponse( code = 400, message = \"Error\", response = ApiError.class )\n\t})\n\t@Path(\"/{subId}\")\n\tpublic Response getMr_Client(@PathParam(\"subId\") String id) {\n\t\tApiError apiError = new ApiError();\n\n\t\tMR_Client nClient =  mr_clientService.getMr_Client(id, apiError);\n\t\tif (apiError.is2xx()) {\n\t\t\treturn responseBuilder.success(nClient);\n\t\t}\n\t\treturn responseBuilder.error(apiError);\n\t}\n}", "class_id": 0, "repo": "onap/archive-dmaap-dbcapi", "file": "src/main/java/org/onap/dmaap/dbcapi/resources/MR_ClientResource.java", "last_update_at": "2019-11-07T06:39:20+00:00", "question_id": "80ee0a6a7f3a4985856807c16dd83c933a62d954", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Path(\"/mr_clients\")\n@Api( value= \"MR_Clients\", description = \"Endpoint for a Message Router Client that implements a Publisher or a Subscriber\" )\n@Consumes(MediaType.APPLICATION_JSON)\n@Produces(MediaType.APPLICATION_JSON)\n@Authorization\npublic class MR_ClientResource extends BaseLoggingClass {\n\tprivate MR_ClientService mr_clientService = new MR_ClientService();\n\tprivate ResponseBuilder responseBuilder = new ResponseBuilder();\n\tprivate RequiredChecker checker = new RequiredChecker();\n\t\t\n\t@GET\n\t@ApiOperation( value = \"return MR_Client details\", \n\tnotes = \"Returns array of  `MR_Client` objects.\", \n\tresponse = MR_Client.class)\n\t@ApiResponses( value = {\n\t    @ApiResponse( code = 200, message = \"Success\", response = MR_Client.class),\n\t    @ApiResponse( code = 400, message = \"Error\", response = ApiError.class )\n\t})\n\tpublic Response getMr_Clients() {\n\t\tList<MR_Client> clients = mr_clientService.getAllMr_Clients();\n\t\tGenericEntity<List<MR_Client>> list = new GenericEntity<List<MR_Client>>(clients) {\n        };\n        return responseBuilder.success(list);\n\t}\n\t\t\n\t@POST\n\t@ApiOperation( value = \"Associate an MR_Client object to a Topic\", \n\tnotes = \"Create a  `MR_Client` object.\"\n\t\t\t+ \"The `dcaeLocation` attribute is used to match an `MR_Cluster` object with the same value, with the intent of localizing message traffic.\"\n\t\t\t+ \"  In legacy implementation, the `clientRole` is granted appropriate permission in AAF.\"\n\t\t\t+ \"  Newer implementions may instead specify an AAF Identity, which will be added to the appropriate `Topic` role.\", \n\tresponse = MR_Client.class)\n\t@ApiResponses( value = {\n\t    @ApiResponse( code = 200, message = \"Success\", response = MR_Client.class),\n\t    @ApiResponse( code = 400, message = \"Error\", response = ApiError.class )\n\t})\n\tpublic Response addMr_Client(MR_Client client) {\n\t\tApiError apiError = new ApiError();\n\t\ttry {\n\t\t\tchecker.required( \"fqtn\", client.getFqtn());\n\t\t\tchecker.required( \"dcaeLocationName\", client.getDcaeLocationName());\n\t\t\tString s = client.getClientRole();\n\t\t\tif ( s == null ) {\n\t\t\t\ts = client.getClientIdentity();\n\t\t\t}\n\t\t\tchecker.required( \"clientRole or clientIdentity\", s);\n\t\t\tchecker.required( \"action\", client.getAction());\n\t\t} catch ( RequiredFieldException rfe ) {\n\t\t\tlogger.debug( rfe.getApiError().toString() );\n\t\t\treturn responseBuilder.error(rfe.getApiError());\n\t\t}\n\t\tMR_ClusterService clusters = new MR_ClusterService();\n\t\tMR_Cluster cluster = clusters.getMr_Cluster(client.getDcaeLocationName(), apiError);\n\t\tif ( cluster == null ) {\n\t\t\tapiError.setCode(Status.BAD_REQUEST.getStatusCode());\n\t\t\tapiError.setMessage( \"MR_Cluster alias not found for dcaeLocation: \" + client.getDcaeLocationName());\n\t\t\tapiError.setFields(\"dcaeLocationName\");\n\t\t\tlogger.warn(apiError.toString());\n\t\t\treturn responseBuilder.error(apiError);\n\t\t}\n\t\tTopicService topics = new TopicService();\n\t\tTopic t = topics.getTopic(client.getFqtn(), apiError);\n\t\tif ( t == null ) {\n\t\t\treturn responseBuilder.error(apiError);\n\t\t}\n\t\tMR_Client nClient =  mr_clientService.addMr_Client(client, t, apiError);\n\t\tif (apiError.is2xx()) {\n\t\t\tt = topics.getTopic(client.getFqtn(), apiError);\n\t\t\ttopics.checkForBridge(t, apiError);\n\t\t\treturn responseBuilder.success(nClient);\n\t\t}\n\t\telse {\n\t\t\treturn responseBuilder.error(apiError);\n\t\t}\n\t}\n\t\t\n\t@PUT\n\t@ApiOperation( value = \"Update an MR_Client object\", \n\tnotes = \"Update a  `MR_Client` object, specified by clientId\", \n\tresponse = MR_Client.class)\n\t@ApiResponses( value = {\n\t    @ApiResponse( code = 200, message = \"Success\", response = MR_Client.class),\n\t    @ApiResponse( code = 400, message = \"Error\", response = ApiError.class )\n\t})\n\t@Path(\"/{clientId}\")\n\tpublic Response updateMr_Client(@PathParam(\"clientId\") String clientId, MR_Client client) {\n\t\tApiError apiError = new ApiError();\n\t\ttry {\n\t\t\tchecker.required( \"fqtn\", client.getFqtn());\n\t\t\tchecker.required( \"dcaeLocationName\", client.getDcaeLocationName());\n\t\t\tchecker.required( \"clientRole\", client.getClientRole());\n\t\t\tchecker.required( \"action\", client.getAction());\n\t\t} catch ( RequiredFieldException rfe ) {\n\t\t\tlogger.debug( rfe.getApiError().toString() );\n\t\t\treturn responseBuilder.error(rfe.getApiError());\n\t\t}\n\t\tclient.setMrClientId(clientId);\n\t\tMR_Client nClient = mr_clientService.updateMr_Client(client, apiError);\n\t\tif (apiError.is2xx()) {\n\t\t\treturn Response.ok(nClient)\n\t\t\t\t.build();\n\t\t}\n\t\treturn Response.status(apiError.getCode())\n\t\t\t\t.entity(apiError)\n\t\t\t\t.build();\n\t}\n\t\t\n\t@DELETE\n\t@ApiOperation( value = \"Delete an MR_Client object\", \n\tnotes = \"Delete a  `MR_Client` object, specified by clientId\", \n\tresponse = MR_Client.class)\n\t@ApiResponses( value = {\n\t    @ApiResponse( code = 204, message = \"Success\", response = MR_Client.class),\n\t    @ApiResponse( code = 400, message = \"Error\", response = ApiError.class )\n\t})\n\t@Path(\"/{subId}\")\n\tpublic Response deleteMr_Client(@PathParam(\"subId\") String id){\n\t\tApiError apiError = new ApiError();\n\t\tmr_clientService.removeMr_Client(id, true, apiError);\n\t\tif (apiError.is2xx()) {\n\t\t\treturn responseBuilder.success(NO_CONTENT.getStatusCode(), null);\n\t\t}\n\t\t\n\t\treturn responseBuilder.error(apiError);\n\t}\n\t@GET\n\t@ApiOperation( value = \"return MR_Client details\", \n\tnotes = \"Retrieve a  `MR_Client` object, specified by clientId\", \n\tresponse = MR_Client.class)\n\t@ApiResponses( value = {\n\t    @ApiResponse( code = 200, message = \"Success\", response = MR_Client.class),\n\t    @ApiResponse( code = 400, message = \"Error\", response = ApiError.class )\n\t})\n\t@Path(\"/{subId}\")\n\tpublic Response getMr_Client(@PathParam(\"subId\") String id) {\n\t\tApiError apiError = new ApiError();\n\t\tMR_Client nClient =  mr_clientService.getMr_Client(id, apiError);\n\t\tif (apiError.is2xx()) {\n\t\t\treturn responseBuilder.success(nClient);\n\t\t}\n\t\treturn responseBuilder.error(apiError);\n\t}\n"]]}
{"hexsha": "479be213edd9fc6374cba96bf60e6c678a560dcb", "ext": "java", "lang": "Java", "content": "public class HibernatePropertiesUtil\n{\n\tprivate HibernatePropertiesUtil() { super(); }\n\t\n\tpublic static void configure(File configFile, Properties props) \n\t\tthrows IOException\n\t{\n\t\tFile tmpFile = File.createTempFile(\"HibernatePropertiesUtil\", \".properties\");\n\t\ttmpFile.deleteOnExit();\n\t\tBufferedReader br = new BufferedReader(new FileReader(configFile));\n\t\tPrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(tmpFile)));\n\t\tString line = null;\n\t\twhile ((line = br.readLine()) != null) {\n\t\t\tint index = line.indexOf('=');\n\t\t\tif (index == -1) index = line.indexOf(' ');\n\t\t\tif (index == -1) {\n\t\t\t\tout.println(line);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString key = line.substring(0, index);\n\t\t\tif (! props.containsKey(key)) {\n\t\t\t\tout.println(line);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString delimiter = line.substring(index, index+1);\n\t\t\tString value = line.substring(index+1);\n\t\t\tout.println(key + delimiter + props.getProperty(key)); \n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\t\tbr.close();\n\t\tFileUtils.copy(tmpFile, configFile);\n\t\ttmpFile.delete();\n\t}\n}", "class_id": 0, "repo": "NCIP/catrip", "file": "codebase/projects/test-system/src/java/edu/duke/cabig/catrip/test/system/util/HibernatePropertiesUtil.java", "last_update_at": "2019-04-30T06:37:01+00:00", "question_id": "479be213edd9fc6374cba96bf60e6c678a560dcb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HibernatePropertiesUtil\n{\n\tprivate HibernatePropertiesUtil() { super(); }\n\t\n\tpublic static void configure(File configFile, Properties props) \n\t\tthrows IOException\n\t{\n\t\tFile tmpFile = File.createTempFile(\"HibernatePropertiesUtil\", \".properties\");\n\t\ttmpFile.deleteOnExit();\n\t\tBufferedReader br = new BufferedReader(new FileReader(configFile));\n\t\tPrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(tmpFile)));\n\t\tString line = null;\n\t\twhile ((line = br.readLine()) != null) {\n\t\t\tint index = line.indexOf('=');\n\t\t\tif (index == -1) index = line.indexOf(' ');\n\t\t\tif (index == -1) {\n\t\t\t\tout.println(line);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString key = line.substring(0, index);\n\t\t\tif (! props.containsKey(key)) {\n\t\t\t\tout.println(line);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString delimiter = line.substring(index, index+1);\n\t\t\tString value = line.substring(index+1);\n\t\t\tout.println(key + delimiter + props.getProperty(key)); \n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\t\tbr.close();\n\t\tFileUtils.copy(tmpFile, configFile);\n\t\ttmpFile.delete();\n\t}\n"]]}
{"hexsha": "787ae5d06251a17281a109162229ea75b94c435d", "ext": "java", "lang": "Java", "content": "public class UuidTypeHandler extends BaseTypeHandler<UUID> {\n    @Override\n    public void setNonNullParameter(PreparedStatement preparedStatement, int i, UUID uuid, JdbcType jdbcType) throws SQLException {\n        preparedStatement.setString(i, uuid.toString());\n    }\n\n    @Override\n    public UUID getNullableResult(ResultSet resultSet, String s) throws SQLException {\n        String uuidString = resultSet.getString(s);\n        if (uuidString != null) {\n            return UUID.fromString(uuidString);\n        }\n        return null;\n    }\n\n    @Override\n    public UUID getNullableResult(ResultSet resultSet, int i) throws SQLException {\n        String uuidString = resultSet.getString(i);\n        if (uuidString != null) {\n            return UUID.fromString(uuidString);\n        }\n        return null;\n    }\n\n    @Override\n    public UUID getNullableResult(CallableStatement callableStatement, int i) throws SQLException {\n        String uuidString = callableStatement.getString(i);\n        if (uuidString != null) {\n            return UUID.fromString(uuidString);\n        }\n        return null;\n    }\n}", "class_id": 0, "repo": "Xylus/pinpoint-plugin-workshop", "file": "workshop-pizza-oven/src/main/java/com/pinpoint/workshop/pizza/oven/type/UuidTypeHandler.java", "last_update_at": "2019-11-01T01:05:39+00:00", "question_id": "787ae5d06251a17281a109162229ea75b94c435d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class UuidTypeHandler extends BaseTypeHandler<UUID> {\n    @Override\n    public void setNonNullParameter(PreparedStatement preparedStatement, int i, UUID uuid, JdbcType jdbcType) throws SQLException {\n        preparedStatement.setString(i, uuid.toString());\n    }\n    @Override\n    public UUID getNullableResult(ResultSet resultSet, String s) throws SQLException {\n        String uuidString = resultSet.getString(s);\n        if (uuidString != null) {\n            return UUID.fromString(uuidString);\n        }\n        return null;\n    }\n    @Override\n    public UUID getNullableResult(ResultSet resultSet, int i) throws SQLException {\n        String uuidString = resultSet.getString(i);\n        if (uuidString != null) {\n            return UUID.fromString(uuidString);\n        }\n        return null;\n    }\n    @Override\n    public UUID getNullableResult(CallableStatement callableStatement, int i) throws SQLException {\n        String uuidString = callableStatement.getString(i);\n        if (uuidString != null) {\n            return UUID.fromString(uuidString);\n        }\n        return null;\n    }\n"]]}
{"hexsha": "06efab1a475e514cf31d1fd62d00b4420de8a54f", "ext": "java", "lang": "Java", "content": "public class InstrumentView extends RelativeLayout implements Instrument {\n\n    private TextView labelView;\n    private TextView measurementView;\n    private TextView unitsView;\n\n    public InstrumentView(Context context) {\n        super(context);\n        init(context, null, 0);\n    }\n\n    public InstrumentView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context, attrs, 0);\n    }\n\n    public InstrumentView(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        init(context, attrs, defStyle);\n    }\n\n    private void init(Context context, AttributeSet attrs, int defStyle) {\n        TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.InstrumentView, defStyle, 0);\n        String labelText = ta.getString(R.styleable.InstrumentView_labelText);\n        ta.recycle();\n\n        View v = inflate(getContext(), R.layout.view_instrument, this);\n        labelView = TextView.class.cast(v.findViewById(R.id.view_instrument_label));\n        measurementView = TextView.class.cast(v.findViewById(R.id.view_instrument_measurement));\n        unitsView = TextView.class.cast(v.findViewById(R.id.view_instrument_units));\n        if (!TextUtils.isEmpty(labelText)) {\n            setLabel(labelText);\n        }\n    }\n\n    @Override\n    public void setLabel(String label) {\n        labelView.setText(label);\n    }\n\n    @Override\n    public void updateReading(String value, String units) {\n        measurementView.setText(value);\n        unitsView.setText(units);\n    }\n\n}", "class_id": 0, "repo": "krschultz/AndroidWeatherBuoyDemo", "file": "app/src/main/java/com/kevinrschultz/weatherbuoy/views/InstrumentView.java", "last_update_at": "2019-11-10T10:05:45+00:00", "question_id": "06efab1a475e514cf31d1fd62d00b4420de8a54f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class InstrumentView extends RelativeLayout implements Instrument {\n    private TextView labelView;\n    private TextView measurementView;\n    private TextView unitsView;\n    public InstrumentView(Context context) {\n        super(context);\n        init(context, null, 0);\n    }\n    public InstrumentView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context, attrs, 0);\n    }\n    public InstrumentView(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        init(context, attrs, defStyle);\n    }\n    private void init(Context context, AttributeSet attrs, int defStyle) {\n        TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.InstrumentView, defStyle, 0);\n        String labelText = ta.getString(R.styleable.InstrumentView_labelText);\n        ta.recycle();\n        View v = inflate(getContext(), R.layout.view_instrument, this);\n        labelView = TextView.class.cast(v.findViewById(R.id.view_instrument_label));\n        measurementView = TextView.class.cast(v.findViewById(R.id.view_instrument_measurement));\n        unitsView = TextView.class.cast(v.findViewById(R.id.view_instrument_units));\n        if (!TextUtils.isEmpty(labelText)) {\n            setLabel(labelText);\n        }\n    }\n    @Override\n    public void setLabel(String label) {\n        labelView.setText(label);\n    }\n    @Override\n    public void updateReading(String value, String units) {\n        measurementView.setText(value);\n        unitsView.setText(units);\n    }\n"]]}
{"hexsha": "3064f42d658ff54d36b408b13285844915338959", "ext": "java", "lang": "Java", "content": "public final class LsBenchLsSetup {\n\n    private LsBenchLsSetup() {\n    }\n\n    public static LogstashInstallation logstashFromGit(final String pwd, final String version,\n        final JRubyInstallation jruby) {\n        final File lsdir = Paths.get(pwd, \"logstash\").toFile();\n        final LogstashInstallation logstash;\n        if (version.contains(\"#\")) {\n            final String[] parts = version.split(\"#\");\n            logstash = new LogstashInstallation.FromGithub(lsdir, parts[0], parts[1], jruby);\n        } else {\n            logstash = new LogstashInstallation.FromGithub(lsdir, version, jruby);\n        }\n        return logstash;\n    }\n\n    public static LogstashInstallation setupLS(final String pwd, final String version,\n        final LsVersionType type, final UserOutput output) {\n        final LogstashInstallation logstash;\n        if (type == LsVersionType.LOCAL) {\n            logstash = new LogstashInstallation.FromLocalPath(version);\n        } else {\n            logstash = new LogstashInstallation.FromRelease(\n                Paths.get(pwd, String.format(\"ls-release-%s\", version)).toFile(), version, output\n            );\n        }\n        return logstash;\n    }\n}", "class_id": 0, "repo": "microsoup/logstash", "file": "tools/benchmark-cli/src/main/java/org/logstash/benchmark/cli/util/LsBenchLsSetup.java", "last_update_at": "2019-11-26T10:05:20+00:00", "question_id": "3064f42d658ff54d36b408b13285844915338959", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class LsBenchLsSetup {\n    private LsBenchLsSetup() {\n    }\n    public static LogstashInstallation logstashFromGit(final String pwd, final String version,\n        final JRubyInstallation jruby) {\n        final File lsdir = Paths.get(pwd, \"logstash\").toFile();\n        final LogstashInstallation logstash;\n        if (version.contains(\"#\")) {\n            final String[] parts = version.split(\"#\");\n            logstash = new LogstashInstallation.FromGithub(lsdir, parts[0], parts[1], jruby);\n        } else {\n            logstash = new LogstashInstallation.FromGithub(lsdir, version, jruby);\n        }\n        return logstash;\n    }\n    public static LogstashInstallation setupLS(final String pwd, final String version,\n        final LsVersionType type, final UserOutput output) {\n        final LogstashInstallation logstash;\n        if (type == LsVersionType.LOCAL) {\n            logstash = new LogstashInstallation.FromLocalPath(version);\n        } else {\n            logstash = new LogstashInstallation.FromRelease(\n                Paths.get(pwd, String.format(\"ls-release-%s\", version)).toFile(), version, output\n            );\n        }\n        return logstash;\n    }\n"]]}
{"hexsha": "4a8677c23c3c1f50a2a19e2bf0836624c1112b70", "ext": "java", "lang": "Java", "content": "public class Configuration {\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n    public final static String PID = \"net.es.enos.swagger.config\";\n\n    // Last resort defaults.\n    public final static String DEFAULT_HOST = \"localhost\";\n    public final static String DEFAULT_PORT = \"8181\";\n    public final static String DEFAULT_PATH = \"/services\";\n\n    // Swagger configuration property keys.\n    public final static String KEY_BASEPATH = \"swagger.basePath\";\n    public final static String KEY_HOST = \"swagger.host\";\n    public final static String KEY_TITLE = \"swagger.info.title\";\n    public final static String KEY_DESCRIPTION = \"swagger.info.description\";\n    public final static String KEY_VERSION = \"swagger.info.version\";\n    public final static String KEY_TERMSOFSERVICE = \"swagger.info.termsOfService\";\n    public final static String KEY_CONTACTNAME = \"swagger.info.contact.name\";\n    public final static String KEY_CONTACTURL = \"swagger.info.contact.url\";\n    public final static String KEY_CONTACTEMAIL = \"swagger.info.contact.email\";\n    public final static String KEY_LICENSENAME = \"swagger.info.license.name\";\n    public final static String KEY_LICENSEURL = \"swagger.info.license.url\";\n\n    // Configuration values.\n    private String basePath;\n    private String host;\n    private String title;\n    private String description;\n    private String version;\n    private String termsOfService;\n    private String contactName;\n    private String contactURL;\n    private String contactEmail;\n    private String licenseName;\n    private String licenseURL;\n\n    public Configuration() {\n\n    }\n\n    public void refresh() {\n        logger.info(\"net.es.enos.swagger.Configuration refresh, basePath=\" + basePath);\n\n        BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();\n        ServiceReference reference = bundleContext.getServiceReference(ConfigurationAdmin.class.getName());\n        ConfigurationAdmin configAdmin = (ConfigurationAdmin) bundleContext.getService(reference);\n\n        // Get the swagger configuration to verify it exists.\n        org.osgi.service.cm.Configuration swagger;\n        try {\n            swagger = configAdmin.getConfiguration(\"com.eclipsesource.jaxrs.swagger.config\");\n        } catch (IOException ex) {\n            logger.error(\"Could not read com.eclipsesource.jaxrs.swagger.config configuration\", ex);\n            bundleContext.ungetService(reference);\n            return;\n        }\n\n        Dictionary<String, Object> properties = swagger.getProperties();\n\n        // if null, the configuration is new.\n        if (properties == null) {\n            properties = new Hashtable();\n            logger.info(\"enos-swagger: creating a new configuration.\");\n        }\n\n        // We are considered the master of the swagger config to overwrite\n        // the com.eclipsesource.jaxrs.swagger.config version.\n        properties.put(KEY_HOST, Strings.isNullOrEmpty(host) ? getHost(configAdmin) : host);\n        properties.put(KEY_BASEPATH, Strings.isNullOrEmpty(basePath) ? getPath(configAdmin) : basePath);\n\n        if (!Strings.isNullOrEmpty(title)) {\n            properties.put(KEY_TITLE, title);\n        }\n\n        if (!Strings.isNullOrEmpty(description)) {\n            properties.put(KEY_DESCRIPTION, description);\n        }\n\n        if (!Strings.isNullOrEmpty(version)) {\n            properties.put(KEY_VERSION, version);\n        }\n\n        if (!Strings.isNullOrEmpty(termsOfService)) {\n            properties.put(KEY_TERMSOFSERVICE, termsOfService);\n        }\n\n        if (!Strings.isNullOrEmpty(contactName)) {\n            properties.put(KEY_CONTACTNAME, contactName);\n        }\n\n        if (!Strings.isNullOrEmpty(contactURL)) {\n            properties.put(KEY_CONTACTURL, contactURL);\n        }\n\n        if (!Strings.isNullOrEmpty(contactEmail)) {\n            properties.put(KEY_CONTACTEMAIL, contactEmail);\n        }\n\n        if (!Strings.isNullOrEmpty(licenseName)) {\n            properties.put(KEY_LICENSENAME, licenseName);\n        }\n\n        if (!Strings.isNullOrEmpty(licenseURL)) {\n            properties.put(KEY_LICENSEURL, licenseURL);\n        }\n\n        try {\n            swagger.update(properties);\n        } catch (IOException ex) {\n            logger.error(\"Could not update com.eclipsesource.jaxrs.swagger.config configuration\", ex);\n        }\n\n        // We are done with the configuration service.\n        bundleContext.ungetService(reference);\n    }\n\n    private String getProperty(Dictionary<String, Object> properties, String key, String defaultValue) {\n        if (properties == null) {\n            return defaultValue;\n        }\n\n        Object value = properties.get(key);\n        if (value == null || !(value instanceof String)) {\n            return defaultValue;\n        }\n\n        String vstring = (String) value;\n        if (vstring.isEmpty()) {\n            return defaultValue;\n        }\n\n        return vstring;\n    }\n\n    private String getHost(ConfigurationAdmin configAdmin) {\n        String ahost;\n        String port;\n\n        // Get the web service configuration so we can properly set the http port.\n        try {\n            org.osgi.service.cm.Configuration http = configAdmin.getConfiguration(\"org.ops4j.pax.web\");\n            Dictionary<String, Object> httpProperties = http.getProperties();\n            ahost = getProperty(httpProperties, \"org.ops4j.pax.web.listening.addresses\", DEFAULT_HOST);\n            port = getProperty(httpProperties, \"org.osgi.service.http.port\", DEFAULT_PORT);\n        } catch (IOException ex) {\n            logger.error(\"Could not read org.ops4j.pax.web configuration\", ex);\n            ahost = DEFAULT_HOST;\n            port = DEFAULT_PORT;\n        }\n\n        String hp = ahost + \":\" + port;\n        logger.info(\"enos-swagger: bound to http service \" + hp);\n        return hp;\n    }\n\n    private String getPath(ConfigurationAdmin configAdmin) {\n        String root;\n\n        // Get the relative path to our swagger managed services.\n        try {\n            org.osgi.service.cm.Configuration jaxrs = configAdmin.getConfiguration(\"com.eclipsesource.jaxrs.connector\");\n            Dictionary<String, Object> jaxrsProperties = jaxrs.getProperties();\n            root = getProperty(jaxrsProperties, \"root\", DEFAULT_PATH);\n        } catch (IOException ex) {\n            logger.error(\"Could not read com.eclipsesource.jaxrs.connector configuration\", ex);\n            root = DEFAULT_PATH;\n        }\n\n        logger.info(\"enos-swagger: bound REST services to basePath \" + root);\n        return root;\n    }\n\n    /**\n     * @return the basePath\n     */\n    public String getBasePath() {\n        return basePath;\n    }\n\n    /**\n     * @param basePath the basePath to set\n     */\n    public void setBasePath(String basePath) {\n        this.basePath = basePath;\n    }\n\n    /**\n     * @return the host\n     */\n    public String getHost() {\n        return host;\n    }\n\n    /**\n     * @param host the host to set\n     */\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    /**\n     * @return the title\n     */\n    public String getTitle() {\n        return title;\n    }\n\n    /**\n     * @param title the title to set\n     */\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    /**\n     * @return the description\n     */\n    public String getDescription() {\n        return description;\n    }\n\n    /**\n     * @param description the description to set\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @return the version\n     */\n    public String getVersion() {\n        return version;\n    }\n\n    /**\n     * @param version the version to set\n     */\n    public void setVersion(String version) {\n        this.version = version;\n    }\n\n    /**\n     * @return the termsOfService\n     */\n    public String getTermsOfService() {\n        return termsOfService;\n    }\n\n    /**\n     * @param termsOfService the termsOfService to set\n     */\n    public void setTermsOfService(String termsOfService) {\n        this.termsOfService = termsOfService;\n    }\n\n    /**\n     * @return the contactName\n     */\n    public String getContactName() {\n        return contactName;\n    }\n\n    /**\n     * @param contactName the contactName to set\n     */\n    public void setContactName(String contactName) {\n        this.contactName = contactName;\n    }\n\n    /**\n     * @return the contactURL\n     */\n    public String getContactURL() {\n        return contactURL;\n    }\n\n    /**\n     * @param contactURL the contactURL to set\n     */\n    public void setContactURL(String contactURL) {\n        this.contactURL = contactURL;\n    }\n\n    /**\n     * @return the contactEmail\n     */\n    public String getContactEmail() {\n        return contactEmail;\n    }\n\n    /**\n     * @param contactEmail the contactEmail to set\n     */\n    public void setContactEmail(String contactEmail) {\n        this.contactEmail = contactEmail;\n    }\n\n    /**\n     * @return the licenseName\n     */\n    public String getLicenseName() {\n        return licenseName;\n    }\n\n    /**\n     * @param licenseName the licenseName to set\n     */\n    public void setLicenseName(String licenseName) {\n        this.licenseName = licenseName;\n    }\n\n    /**\n     * @return the licenseURL\n     */\n    public String getLicenseURL() {\n        return licenseURL;\n    }\n\n    /**\n     * @param licenseURL the licenseURL to set\n     */\n    public void setLicenseURL(String licenseURL) {\n        this.licenseURL = licenseURL;\n    }\n}", "class_id": 0, "repo": "esnet/enos", "file": "swagger/src/main/java/net/es/enos/swagger/Configuration.java", "last_update_at": "2019-04-15T08:56:54+00:00", "question_id": "4a8677c23c3c1f50a2a19e2bf0836624c1112b70", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Configuration {\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n    public final static String PID = \"net.es.enos.swagger.config\";\n    // Last resort defaults.\n    public final static String DEFAULT_HOST = \"localhost\";\n    public final static String DEFAULT_PORT = \"8181\";\n    public final static String DEFAULT_PATH = \"/services\";\n    // Swagger configuration property keys.\n    public final static String KEY_BASEPATH = \"swagger.basePath\";\n    public final static String KEY_HOST = \"swagger.host\";\n    public final static String KEY_TITLE = \"swagger.info.title\";\n    public final static String KEY_DESCRIPTION = \"swagger.info.description\";\n    public final static String KEY_VERSION = \"swagger.info.version\";\n    public final static String KEY_TERMSOFSERVICE = \"swagger.info.termsOfService\";\n    public final static String KEY_CONTACTNAME = \"swagger.info.contact.name\";\n    public final static String KEY_CONTACTURL = \"swagger.info.contact.url\";\n    public final static String KEY_CONTACTEMAIL = \"swagger.info.contact.email\";\n    public final static String KEY_LICENSENAME = \"swagger.info.license.name\";\n    public final static String KEY_LICENSEURL = \"swagger.info.license.url\";\n    // Configuration values.\n    private String basePath;\n    private String host;\n    private String title;\n    private String description;\n    private String version;\n    private String termsOfService;\n    private String contactName;\n    private String contactURL;\n    private String contactEmail;\n    private String licenseName;\n    private String licenseURL;\n    public Configuration() {\n    }\n    public void refresh() {\n        logger.info(\"net.es.enos.swagger.Configuration refresh, basePath=\" + basePath);\n        BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();\n        ServiceReference reference = bundleContext.getServiceReference(ConfigurationAdmin.class.getName());\n        ConfigurationAdmin configAdmin = (ConfigurationAdmin) bundleContext.getService(reference);\n        // Get the swagger configuration to verify it exists.\n        org.osgi.service.cm.Configuration swagger;\n        try {\n            swagger = configAdmin.getConfiguration(\"com.eclipsesource.jaxrs.swagger.config\");\n        } catch (IOException ex) {\n            logger.error(\"Could not read com.eclipsesource.jaxrs.swagger.config configuration\", ex);\n            bundleContext.ungetService(reference);\n            return;\n        }\n        Dictionary<String, Object> properties = swagger.getProperties();\n        // if null, the configuration is new.\n        if (properties == null) {\n            properties = new Hashtable();\n            logger.info(\"enos-swagger: creating a new configuration.\");\n        }\n        // We are considered the master of the swagger config to overwrite\n        // the com.eclipsesource.jaxrs.swagger.config version.\n        properties.put(KEY_HOST, Strings.isNullOrEmpty(host) ? getHost(configAdmin) : host);\n        properties.put(KEY_BASEPATH, Strings.isNullOrEmpty(basePath) ? getPath(configAdmin) : basePath);\n        if (!Strings.isNullOrEmpty(title)) {\n            properties.put(KEY_TITLE, title);\n        }\n        if (!Strings.isNullOrEmpty(description)) {\n            properties.put(KEY_DESCRIPTION, description);\n        }\n        if (!Strings.isNullOrEmpty(version)) {\n            properties.put(KEY_VERSION, version);\n        }\n        if (!Strings.isNullOrEmpty(termsOfService)) {\n            properties.put(KEY_TERMSOFSERVICE, termsOfService);\n        }\n        if (!Strings.isNullOrEmpty(contactName)) {\n            properties.put(KEY_CONTACTNAME, contactName);\n        }\n        if (!Strings.isNullOrEmpty(contactURL)) {\n            properties.put(KEY_CONTACTURL, contactURL);\n        }\n        if (!Strings.isNullOrEmpty(contactEmail)) {\n            properties.put(KEY_CONTACTEMAIL, contactEmail);\n        }\n        if (!Strings.isNullOrEmpty(licenseName)) {\n            properties.put(KEY_LICENSENAME, licenseName);\n        }\n        if (!Strings.isNullOrEmpty(licenseURL)) {\n            properties.put(KEY_LICENSEURL, licenseURL);\n        }\n        try {\n            swagger.update(properties);\n        } catch (IOException ex) {\n            logger.error(\"Could not update com.eclipsesource.jaxrs.swagger.config configuration\", ex);\n        }\n        // We are done with the configuration service.\n        bundleContext.ungetService(reference);\n    }\n    private String getProperty(Dictionary<String, Object> properties, String key, String defaultValue) {\n        if (properties == null) {\n            return defaultValue;\n        }\n        Object value = properties.get(key);\n        if (value == null || !(value instanceof String)) {\n            return defaultValue;\n        }\n        String vstring = (String) value;\n        if (vstring.isEmpty()) {\n            return defaultValue;\n        }\n        return vstring;\n    }\n    private String getHost(ConfigurationAdmin configAdmin) {\n        String ahost;\n        String port;\n        // Get the web service configuration so we can properly set the http port.\n        try {\n            org.osgi.service.cm.Configuration http = configAdmin.getConfiguration(\"org.ops4j.pax.web\");\n            Dictionary<String, Object> httpProperties = http.getProperties();\n            ahost = getProperty(httpProperties, \"org.ops4j.pax.web.listening.addresses\", DEFAULT_HOST);\n            port = getProperty(httpProperties, \"org.osgi.service.http.port\", DEFAULT_PORT);\n        } catch (IOException ex) {\n            logger.error(\"Could not read org.ops4j.pax.web configuration\", ex);\n            ahost = DEFAULT_HOST;\n            port = DEFAULT_PORT;\n        }\n        String hp = ahost + \":\" + port;\n        logger.info(\"enos-swagger: bound to http service \" + hp);\n        return hp;\n    }\n    private String getPath(ConfigurationAdmin configAdmin) {\n        String root;\n        // Get the relative path to our swagger managed services.\n        try {\n            org.osgi.service.cm.Configuration jaxrs = configAdmin.getConfiguration(\"com.eclipsesource.jaxrs.connector\");\n            Dictionary<String, Object> jaxrsProperties = jaxrs.getProperties();\n            root = getProperty(jaxrsProperties, \"root\", DEFAULT_PATH);\n        } catch (IOException ex) {\n            logger.error(\"Could not read com.eclipsesource.jaxrs.connector configuration\", ex);\n            root = DEFAULT_PATH;\n        }\n        logger.info(\"enos-swagger: bound REST services to basePath \" + root);\n        return root;\n    }\n    /**\n     * @return the basePath\n     */\n    public String getBasePath() {\n        return basePath;\n    }\n    /**\n     * @param basePath the basePath to set\n     */\n    public void setBasePath(String basePath) {\n        this.basePath = basePath;\n    }\n    /**\n     * @return the host\n     */\n    public String getHost() {\n        return host;\n    }\n    /**\n     * @param host the host to set\n     */\n    public void setHost(String host) {\n        this.host = host;\n    }\n    /**\n     * @return the title\n     */\n    public String getTitle() {\n        return title;\n    }\n    /**\n     * @param title the title to set\n     */\n    public void setTitle(String title) {\n        this.title = title;\n    }\n    /**\n     * @return the description\n     */\n    public String getDescription() {\n        return description;\n    }\n    /**\n     * @param description the description to set\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n    /**\n     * @return the version\n     */\n    public String getVersion() {\n        return version;\n    }\n    /**\n     * @param version the version to set\n     */\n    public void setVersion(String version) {\n        this.version = version;\n    }\n    /**\n     * @return the termsOfService\n     */\n    public String getTermsOfService() {\n        return termsOfService;\n    }\n    /**\n     * @param termsOfService the termsOfService to set\n     */\n    public void setTermsOfService(String termsOfService) {\n        this.termsOfService = termsOfService;\n    }\n    /**\n     * @return the contactName\n     */\n    public String getContactName() {\n        return contactName;\n    }\n    /**\n     * @param contactName the contactName to set\n     */\n    public void setContactName(String contactName) {\n        this.contactName = contactName;\n    }\n    /**\n     * @return the contactURL\n     */\n    public String getContactURL() {\n        return contactURL;\n    }\n    /**\n     * @param contactURL the contactURL to set\n     */\n    public void setContactURL(String contactURL) {\n        this.contactURL = contactURL;\n    }\n    /**\n     * @return the contactEmail\n     */\n    public String getContactEmail() {\n        return contactEmail;\n    }\n    /**\n     * @param contactEmail the contactEmail to set\n     */\n    public void setContactEmail(String contactEmail) {\n        this.contactEmail = contactEmail;\n    }\n    /**\n     * @return the licenseName\n     */\n    public String getLicenseName() {\n        return licenseName;\n    }\n    /**\n     * @param licenseName the licenseName to set\n     */\n    public void setLicenseName(String licenseName) {\n        this.licenseName = licenseName;\n    }\n    /**\n     * @return the licenseURL\n     */\n    public String getLicenseURL() {\n        return licenseURL;\n    }\n    /**\n     * @param licenseURL the licenseURL to set\n     */\n    public void setLicenseURL(String licenseURL) {\n        this.licenseURL = licenseURL;\n    }\n"]]}
{"hexsha": "fae383f4fbd6db1d747fff4daf37605b0c0898a4", "ext": "java", "lang": "Java", "content": "public class PurgeAction extends SharedAction {\n\tprivate static final Logger logger = LoggerFactory.getLogger(PurgeAction.class);\n\n\t@SuppressWarnings(\"static-access\")\n\tpublic PurgeAction() {\n\t\tcreateOption(\"purge\",\n                \"Warning: Rollback all current deltas and reset index accordingly. DEPRECATED: use purge\");\n\t}\n\n    public void invoke(FacadeFactory factory, ProjectAndEnv projectAndEnv, Collection<Parameter> unused,\n\t\t\tCollection<Parameter> artifacts, String... args) throws CfnAssistException, MissingArgumentException, InterruptedException {\n\t\tlogger.info(\"Invoking rollback for \" + projectAndEnv);\n\t\tAwsFacade aws = factory.createFacade();\n\t\taws.rollbackTemplatesByIndexTag(projectAndEnv);\n\t}\n\n\t@Override\n\tpublic void validate(ProjectAndEnv projectAndEnv, Collection<Parameter> cfnParams,\n\t\t\tCollection<Parameter> artifacts, String... argumentForAction)\n\t\t\tthrows CommandLineException {\n\t\tguardForProjectAndEnv(projectAndEnv);\n\t\tguardForNoBuildNumber(projectAndEnv);\t\n\t\tguardForNoArtifacts(artifacts);\n\t}\n\n\t@Override\n\tpublic boolean usesProject() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean usesComment() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean usesSNS() {\n\t\treturn true;\n\t}\n\n}", "class_id": 0, "repo": "GuruInferenceServiceTests/repoSize253", "file": "src/tw/com/commandline/actions/PurgeAction.java", "last_update_at": "2019-07-09T18:47:20+00:00", "question_id": "fae383f4fbd6db1d747fff4daf37605b0c0898a4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PurgeAction extends SharedAction {\n\tprivate static final Logger logger = LoggerFactory.getLogger(PurgeAction.class);\n\t@SuppressWarnings(\"static-access\")\n\tpublic PurgeAction() {\n\t\tcreateOption(\"purge\",\n                \"Warning: Rollback all current deltas and reset index accordingly. DEPRECATED: use purge\");\n\t}\n    public void invoke(FacadeFactory factory, ProjectAndEnv projectAndEnv, Collection<Parameter> unused,\n\t\t\tCollection<Parameter> artifacts, String... args) throws CfnAssistException, MissingArgumentException, InterruptedException {\n\t\tlogger.info(\"Invoking rollback for \" + projectAndEnv);\n\t\tAwsFacade aws = factory.createFacade();\n\t\taws.rollbackTemplatesByIndexTag(projectAndEnv);\n\t}\n\t@Override\n\tpublic void validate(ProjectAndEnv projectAndEnv, Collection<Parameter> cfnParams,\n\t\t\tCollection<Parameter> artifacts, String... argumentForAction)\n\t\t\tthrows CommandLineException {\n\t\tguardForProjectAndEnv(projectAndEnv);\n\t\tguardForNoBuildNumber(projectAndEnv);\t\n\t\tguardForNoArtifacts(artifacts);\n\t}\n\t@Override\n\tpublic boolean usesProject() {\n\t\treturn true;\n\t}\n\t@Override\n\tpublic boolean usesComment() {\n\t\treturn false;\n\t}\n\t@Override\n\tpublic boolean usesSNS() {\n\t\treturn true;\n\t}\n"]]}
{"hexsha": "e72646c6d101390165630655d359f6e40c641310", "ext": "java", "lang": "Java", "content": "public class BOJ_1919 {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader bReader = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer stringTokenizer = new StringTokenizer(bReader.readLine());\n\t\tString string1 = stringTokenizer.nextToken();\n\t\tstringTokenizer = new StringTokenizer(bReader.readLine());\n\t\tString string2 = stringTokenizer.nextToken();\n\t\t\n\t\tint[] alpa = new int [26];\n\t\tfor(int i=0;i<string1.length();i++) {\n\t\t\tint a = string1.charAt(i)-'a';\n\t\t\talpa[a]++;\n\t\t}\n\t\tfor(int i=0;i<string2.length();i++) {\n\t\t\tint a = string2.charAt(i)-'a';\n\t\t\talpa[a]--;\n\t\t}\n\t\tint sum=0;\n\t\tfor (int i : alpa) {\n\t\t\tif(i<0)\n\t\t\t\tsum-=i;\n\t\t\telse\n\t\t\t\tsum+=i;\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n\n}", "class_id": 0, "repo": "stevejhkang/algorithm-quiz", "file": "project_folder/src/boj_february/BOJ_1919.java", "last_update_at": "2019-10-31T15:13:05+00:00", "question_id": "e72646c6d101390165630655d359f6e40c641310", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BOJ_1919 {\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader bReader = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer stringTokenizer = new StringTokenizer(bReader.readLine());\n\t\tString string1 = stringTokenizer.nextToken();\n\t\tstringTokenizer = new StringTokenizer(bReader.readLine());\n\t\tString string2 = stringTokenizer.nextToken();\n\t\t\n\t\tint[] alpa = new int [26];\n\t\tfor(int i=0;i<string1.length();i++) {\n\t\t\tint a = string1.charAt(i)-'a';\n\t\t\talpa[a]++;\n\t\t}\n\t\tfor(int i=0;i<string2.length();i++) {\n\t\t\tint a = string2.charAt(i)-'a';\n\t\t\talpa[a]--;\n\t\t}\n\t\tint sum=0;\n\t\tfor (int i : alpa) {\n\t\t\tif(i<0)\n\t\t\t\tsum-=i;\n\t\t\telse\n\t\t\t\tsum+=i;\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n"]]}
{"hexsha": "8b76ab5038324a2f66e7e80e42c4876e04e6e1b2", "ext": "java", "lang": "Java", "content": "public class DayOfTheProgrammer {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int year = scanner.nextInt();\n        System.out.println(dayOfProgrammer(year));\n    }\n\n    private static String dayOfProgrammer(int year) {\n        if (year == 1918) {\n            return \"26.09.1918\";\n        }\n        return (isLeapYear(year) ? \"12.09.\" : \"13.09.\") + year;\n    }\n\n    private static boolean isLeapYear(int year) {\n        return (year <= 1917 && year % 4 == 0)\n                || (year % 400 == 0 || (year  % 4 == 0 && year % 100 != 0));\n    }\n}", "class_id": 0, "repo": "anishLearnsToCode/hackerrank-algorithms", "file": "src/implimentation/DayOfTheProgrammer.java", "last_update_at": "2019-07-08T16:28:43+00:00", "question_id": "8b76ab5038324a2f66e7e80e42c4876e04e6e1b2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DayOfTheProgrammer {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int year = scanner.nextInt();\n        System.out.println(dayOfProgrammer(year));\n    }\n    private static String dayOfProgrammer(int year) {\n        if (year == 1918) {\n            return \"26.09.1918\";\n        }\n        return (isLeapYear(year) ? \"12.09.\" : \"13.09.\") + year;\n    }\n    private static boolean isLeapYear(int year) {\n        return (year <= 1917 && year % 4 == 0)\n                || (year % 400 == 0 || (year  % 4 == 0 && year % 100 != 0));\n    }\n"]]}
{"hexsha": "70a166c3a407c99fd83bbca65b2a0445bfa500fc", "ext": "java", "lang": "Java", "content": "@ObfuscatedName(\"fc\")\n@Implements(\"MilliClock\")\npublic class MilliClock extends Clock {\n\t@ObfuscatedName(\"z\")\n\tlong[] field1993;\n\t@ObfuscatedName(\"n\")\n\t@ObfuscatedGetter(\n\t\tintValue = 1174263325\n\t)\n\tint field1992;\n\t@ObfuscatedName(\"v\")\n\t@ObfuscatedGetter(\n\t\tintValue = -133065269\n\t)\n\tint field1994;\n\t@ObfuscatedName(\"u\")\n\t@ObfuscatedGetter(\n\t\tlongValue = 4855142476282651555L\n\t)\n\tlong field1997;\n\t@ObfuscatedName(\"r\")\n\t@ObfuscatedGetter(\n\t\tintValue = -118742351\n\t)\n\tint field1996;\n\t@ObfuscatedName(\"p\")\n\t@ObfuscatedGetter(\n\t\tintValue = -432514755\n\t)\n\tint field1995;\n\n\tMilliClock() {\n\t\tthis.field1993 = new long[10];\n\t\tthis.field1992 = 256;\n\t\tthis.field1994 = 1;\n\t\tthis.field1996 = 0;\n\t\tthis.field1997 = class30.currentTimeMillis();\n\n\t\tfor (int var1 = 0; var1 < 10; ++var1) {\n\t\t\tthis.field1993[var1] = this.field1997;\n\t\t}\n\n\t}\n\n\t@ObfuscatedName(\"z\")\n\t@ObfuscatedSignature(\n\t\tsignature = \"(B)V\",\n\t\tgarbageValue = \"-54\"\n\t)\n\t@Export(\"mark\")\n\tpublic void mark() {\n\t\tfor (int var1 = 0; var1 < 10; ++var1) {\n\t\t\tthis.field1993[var1] = 0L;\n\t\t}\n\n\t}\n\n\t@ObfuscatedName(\"n\")\n\t@ObfuscatedSignature(\n\t\tsignature = \"(III)I\",\n\t\tgarbageValue = \"569029249\"\n\t)\n\t@Export(\"wait\")\n\tpublic int wait(int var1, int var2) {\n\t\tint var3 = this.field1992;\n\t\tint var4 = this.field1994;\n\t\tthis.field1992 = 300;\n\t\tthis.field1994 = 1;\n\t\tthis.field1997 = class30.currentTimeMillis();\n\t\tif (0L == this.field1993[this.field1995]) {\n\t\t\tthis.field1992 = var3;\n\t\t\tthis.field1994 = var4;\n\t\t} else if (this.field1997 > this.field1993[this.field1995]) {\n\t\t\tthis.field1992 = (int)((long)(var1 * 2560) / (this.field1997 - this.field1993[this.field1995]));\n\t\t}\n\n\t\tif (this.field1992 < 25) {\n\t\t\tthis.field1992 = 25;\n\t\t}\n\n\t\tif (this.field1992 > 256) {\n\t\t\tthis.field1992 = 256;\n\t\t\tthis.field1994 = (int)((long)var1 - (this.field1997 - this.field1993[this.field1995]) / 10L);\n\t\t}\n\n\t\tif (this.field1994 > var1) {\n\t\t\tthis.field1994 = var1;\n\t\t}\n\n\t\tthis.field1993[this.field1995] = this.field1997;\n\t\tthis.field1995 = (this.field1995 + 1) % 10;\n\t\tif (this.field1994 > 1) {\n\t\t\tfor (int var5 = 0; var5 < 10; ++var5) {\n\t\t\t\tif (0L != this.field1993[var5]) {\n\t\t\t\t\tthis.field1993[var5] += (long)this.field1994;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.field1994 < var2) {\n\t\t\tthis.field1994 = var2;\n\t\t}\n\n\t\tlong var10 = (long)this.field1994;\n\t\tif (var10 > 0L) {\n\t\t\tif (var10 % 10L == 0L) {\n\t\t\t\tlong var7 = var10 - 1L;\n\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(var7);\n\t\t\t\t} catch (InterruptedException var16) {\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(1L);\n\t\t\t\t} catch (InterruptedException var15) {\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(var10);\n\t\t\t\t} catch (InterruptedException var14) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint var13;\n\t\tfor (var13 = 0; this.field1996 < 256; this.field1996 += this.field1992) {\n\t\t\t++var13;\n\t\t}\n\n\t\tthis.field1996 &= 255;\n\t\treturn var13;\n\t}\n}", "class_id": 0, "repo": "JHPinto/runelite", "file": "runescape-client/src/main/java/MilliClock.java", "last_update_at": "2019-10-09T19:09:32+00:00", "question_id": "70a166c3a407c99fd83bbca65b2a0445bfa500fc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ObfuscatedName(\"fc\")\n@Implements(\"MilliClock\")\npublic class MilliClock extends Clock {\n\t@ObfuscatedName(\"z\")\n\tlong[] field1993;\n\t@ObfuscatedName(\"n\")\n\t@ObfuscatedGetter(\n\t\tintValue = 1174263325\n\t)\n\tint field1992;\n\t@ObfuscatedName(\"v\")\n\t@ObfuscatedGetter(\n\t\tintValue = -133065269\n\t)\n\tint field1994;\n\t@ObfuscatedName(\"u\")\n\t@ObfuscatedGetter(\n\t\tlongValue = 4855142476282651555L\n\t)\n\tlong field1997;\n\t@ObfuscatedName(\"r\")\n\t@ObfuscatedGetter(\n\t\tintValue = -118742351\n\t)\n\tint field1996;\n\t@ObfuscatedName(\"p\")\n\t@ObfuscatedGetter(\n\t\tintValue = -432514755\n\t)\n\tint field1995;\n\tMilliClock() {\n\t\tthis.field1993 = new long[10];\n\t\tthis.field1992 = 256;\n\t\tthis.field1994 = 1;\n\t\tthis.field1996 = 0;\n\t\tthis.field1997 = class30.currentTimeMillis();\n\t\tfor (int var1 = 0; var1 < 10; ++var1) {\n\t\t\tthis.field1993[var1] = this.field1997;\n\t\t}\n\t}\n\t@ObfuscatedName(\"z\")\n\t@ObfuscatedSignature(\n\t\tsignature = \"(B)V\",\n\t\tgarbageValue = \"-54\"\n\t)\n\t@Export(\"mark\")\n\tpublic void mark() {\n\t\tfor (int var1 = 0; var1 < 10; ++var1) {\n\t\t\tthis.field1993[var1] = 0L;\n\t\t}\n\t}\n\t@ObfuscatedName(\"n\")\n\t@ObfuscatedSignature(\n\t\tsignature = \"(III)I\",\n\t\tgarbageValue = \"569029249\"\n\t)\n\t@Export(\"wait\")\n\tpublic int wait(int var1, int var2) {\n\t\tint var3 = this.field1992;\n\t\tint var4 = this.field1994;\n\t\tthis.field1992 = 300;\n\t\tthis.field1994 = 1;\n\t\tthis.field1997 = class30.currentTimeMillis();\n\t\tif (0L == this.field1993[this.field1995]) {\n\t\t\tthis.field1992 = var3;\n\t\t\tthis.field1994 = var4;\n\t\t} else if (this.field1997 > this.field1993[this.field1995]) {\n\t\t\tthis.field1992 = (int)((long)(var1 * 2560) / (this.field1997 - this.field1993[this.field1995]));\n\t\t}\n\t\tif (this.field1992 < 25) {\n\t\t\tthis.field1992 = 25;\n\t\t}\n\t\tif (this.field1992 > 256) {\n\t\t\tthis.field1992 = 256;\n\t\t\tthis.field1994 = (int)((long)var1 - (this.field1997 - this.field1993[this.field1995]) / 10L);\n\t\t}\n\t\tif (this.field1994 > var1) {\n\t\t\tthis.field1994 = var1;\n\t\t}\n\t\tthis.field1993[this.field1995] = this.field1997;\n\t\tthis.field1995 = (this.field1995 + 1) % 10;\n\t\tif (this.field1994 > 1) {\n\t\t\tfor (int var5 = 0; var5 < 10; ++var5) {\n\t\t\t\tif (0L != this.field1993[var5]) {\n\t\t\t\t\tthis.field1993[var5] += (long)this.field1994;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.field1994 < var2) {\n\t\t\tthis.field1994 = var2;\n\t\t}\n\t\tlong var10 = (long)this.field1994;\n\t\tif (var10 > 0L) {\n\t\t\tif (var10 % 10L == 0L) {\n\t\t\t\tlong var7 = var10 - 1L;\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(var7);\n\t\t\t\t} catch (InterruptedException var16) {\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(1L);\n\t\t\t\t} catch (InterruptedException var15) {\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(var10);\n\t\t\t\t} catch (InterruptedException var14) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint var13;\n\t\tfor (var13 = 0; this.field1996 < 256; this.field1996 += this.field1992) {\n\t\t\t++var13;\n\t\t}\n\t\tthis.field1996 &= 255;\n\t\treturn var13;\n\t}\n"]]}
{"hexsha": "57ef1a5cc41115a5e70502cc466a8290ba6f2d1b", "ext": "java", "lang": "Java", "content": "@Test(groups = \"live\", testName = \"DatabaseApiLiveTest\")\npublic class DatabaseApiLiveTest extends BaseTroveApiLiveTest {\n\n   // region to instance\n   private static Map<String, List<Instance>> instancesToDelete = Maps.newHashMap();\n   // not deleting databases. they will be deleted when instances are deleted\n\n   @Override\n   @BeforeClass(groups = { \"integration\", \"live\" })\n   public void setup() {\n      super.setup();\n      TroveUtils utils = new TroveUtils(api);\n      for (String region : api.getConfiguredRegions()) {\n         // create instances\n         List<Instance> instanceList = Lists.newArrayList();\n         Instance first = utils.getWorkingInstance(region, \"first_database_testing_\" + region, \"1\", 1);\n         Instance second = utils.getWorkingInstance(region, \"second_database_testing_\" + region, \"1\", 1);\n         instanceList.add(first);\n         instanceList.add(second);\n         instancesToDelete.put(region, instanceList);\n\n         DatabaseApi databaseApiFirst = api.getDatabaseApi(region, first.getId());\n         DatabaseApi databaseApiSecond = api.getDatabaseApi(region, second.getId());\n         databaseApiFirst.create(\"livetest_db1\");\n         databaseApiFirst.create(\"livetest_db2\");\n         databaseApiSecond.create(\"livetest_db3\");\n      }\n   }\n\n   @Override\n   @AfterClass(groups = { \"integration\", \"live\" })\n   public void tearDown(){\n      for (String region : api.getConfiguredRegions()) {\n         InstanceApi instanceApi = api.getInstanceApi(region);\n         for (Instance instance : instancesToDelete.get(region)) {\n            if (!instanceApi.delete(instance.getId()))\n               throw new RuntimeException(\"Could not delete a database instance after tests!\");\n         }\n      }\n      super.tearDown();\n   }\n\n   @Test\n   public void testListDatabases() {\n      for (String region : api.getConfiguredRegions()) {\n         InstanceApi instanceApi = api.getInstanceApi(region);\n         assertTrue(instanceApi.list().size() >= 2);\n         for (Instance instance : instancesToDelete.get(region)) {\n            DatabaseApi databaseApi = api.getDatabaseApi(region, instance.getId());\n            if (!instance.getName().contains(\"database_testing\"))\n               continue;\n            assertTrue(databaseApi.list().size() >= 1);\n            for (String database : databaseApi.list()) {\n               assertNotNull(database);\n            }\n         }\n      }\n   }\n\n   @Test\n   public void testDeleteDatabases() {\n      for (String region : api.getConfiguredRegions()) {\n         InstanceApi instanceApi = api.getInstanceApi(region);\n         assertTrue(instanceApi.list().size() >= 2);\n         for (Instance instance : instancesToDelete.get(region)) {\n            DatabaseApi databaseApi = api.getDatabaseApi(region, instance.getId());\n            if (!instance.getName().contains(\"database_testing\"))\n               continue;\n            assertTrue(databaseApi.list().size() >= 1);\n            for (String database : databaseApi.list()) {\n               assertNotNull(database);\n               assertTrue(database.equals(\"livetest_db1\") || database.equals(\"livetest_db2\") || database.equals(\"livetest_db3\") );\n               assertTrue(databaseApi.delete(database));\n               assertTrue(databaseApi.create(database));\n            }\n         }\n      }\n   }\n}", "class_id": 0, "repo": "xored/jclouds", "file": "apis/openstack-trove/src/test/java/org/jclouds/openstack/trove/v1/features/DatabaseApiLiveTest.java", "last_update_at": "2019-07-08T06:41:46+00:00", "question_id": "57ef1a5cc41115a5e70502cc466a8290ba6f2d1b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Test(groups = \"live\", testName = \"DatabaseApiLiveTest\")\npublic class DatabaseApiLiveTest extends BaseTroveApiLiveTest {\n   // region to instance\n   private static Map<String, List<Instance>> instancesToDelete = Maps.newHashMap();\n   // not deleting databases. they will be deleted when instances are deleted\n   @Override\n   @BeforeClass(groups = { \"integration\", \"live\" })\n   public void setup() {\n      super.setup();\n      TroveUtils utils = new TroveUtils(api);\n      for (String region : api.getConfiguredRegions()) {\n         // create instances\n         List<Instance> instanceList = Lists.newArrayList();\n         Instance first = utils.getWorkingInstance(region, \"first_database_testing_\" + region, \"1\", 1);\n         Instance second = utils.getWorkingInstance(region, \"second_database_testing_\" + region, \"1\", 1);\n         instanceList.add(first);\n         instanceList.add(second);\n         instancesToDelete.put(region, instanceList);\n         DatabaseApi databaseApiFirst = api.getDatabaseApi(region, first.getId());\n         DatabaseApi databaseApiSecond = api.getDatabaseApi(region, second.getId());\n         databaseApiFirst.create(\"livetest_db1\");\n         databaseApiFirst.create(\"livetest_db2\");\n         databaseApiSecond.create(\"livetest_db3\");\n      }\n   }\n   @Override\n   @AfterClass(groups = { \"integration\", \"live\" })\n   public void tearDown(){\n      for (String region : api.getConfiguredRegions()) {\n         InstanceApi instanceApi = api.getInstanceApi(region);\n         for (Instance instance : instancesToDelete.get(region)) {\n            if (!instanceApi.delete(instance.getId()))\n               throw new RuntimeException(\"Could not delete a database instance after tests!\");\n         }\n      }\n      super.tearDown();\n   }\n   @Test\n   public void testListDatabases() {\n      for (String region : api.getConfiguredRegions()) {\n         InstanceApi instanceApi = api.getInstanceApi(region);\n         assertTrue(instanceApi.list().size() >= 2);\n         for (Instance instance : instancesToDelete.get(region)) {\n            DatabaseApi databaseApi = api.getDatabaseApi(region, instance.getId());\n            if (!instance.getName().contains(\"database_testing\"))\n               continue;\n            assertTrue(databaseApi.list().size() >= 1);\n            for (String database : databaseApi.list()) {\n               assertNotNull(database);\n            }\n         }\n      }\n   }\n   @Test\n   public void testDeleteDatabases() {\n      for (String region : api.getConfiguredRegions()) {\n         InstanceApi instanceApi = api.getInstanceApi(region);\n         assertTrue(instanceApi.list().size() >= 2);\n         for (Instance instance : instancesToDelete.get(region)) {\n            DatabaseApi databaseApi = api.getDatabaseApi(region, instance.getId());\n            if (!instance.getName().contains(\"database_testing\"))\n               continue;\n            assertTrue(databaseApi.list().size() >= 1);\n            for (String database : databaseApi.list()) {\n               assertNotNull(database);\n               assertTrue(database.equals(\"livetest_db1\") || database.equals(\"livetest_db2\") || database.equals(\"livetest_db3\") );\n               assertTrue(databaseApi.delete(database));\n               assertTrue(databaseApi.create(database));\n            }\n         }\n      }\n   }\n"]]}
{"hexsha": "281a46ab5705bea02890d49807f1f9744c4c5c17", "ext": "java", "lang": "Java", "content": "public class DataBaseHelper implements EntityManagerHelper {\r\n\r\n    private final Map<String, ThreadLocal<EntityManager>> sessions = new HashMap<>();\r\n    private static final Logger LOG = Logger.getLogger(DataBaseHelper.class.getName());\r\n    private static final Map<String, String> propMap = new HashMap();\r\n    public final static int SALVAR = 0, ATUALIZAR = 1, DELETAR = 2;\r\n    public final static String DATABASE_PU = \"DATABASE_PU\";\r\n\r\n    public DataBaseHelper() {\r\n    }\r\n\r\n    @Override\r\n    public boolean getOperation(int operation_type, Object object, String persistence_unit) {\r\n        EntityManager session = getSession(persistence_unit);\r\n        EntityTransaction transaction = session.getTransaction();\r\n        try {\r\n            transaction.begin();\r\n            switch (operation_type) {\r\n                case SALVAR:\r\n                    LOG.info(\"Salvando registro no banco de dados\");\r\n                    session.persist(object);\r\n                    session.getTransaction().commit();\r\n                    break;\r\n                case ATUALIZAR:\r\n                    LOG.info(\"Atualizando registro no banco de dados\");\r\n                    session.merge(object);\r\n                    session.getTransaction().commit();\r\n                    break;\r\n                case DELETAR:\r\n                    LOG.info(\"Deletando registro no banco de dados\");\r\n                    session.remove(session.merge(object));\r\n                    session.getTransaction().commit();\r\n                    break;\r\n            }\r\n            this.closeSession(persistence_unit);\r\n            return true;\r\n        } catch (Exception e) {\r\n            //transaction.rollback();\r\n            this.closeSession(persistence_unit);\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public EntityManager getSession(String persistence_unit) {\r\n        EntityManager session = null;\r\n        if (sessions.isEmpty()) {\r\n            sessions.put(persistence_unit, new ThreadLocal());\r\n            session = sessions.get(persistence_unit).get();\r\n            session = session == null ? DataBaseFactoryService.getEntityManagerFactory(persistence_unit, propMap).createEntityManager() : session;\r\n        } else {\r\n            session = sessions.get(persistence_unit).get();\r\n            session = session == null ? DataBaseFactoryService.getEntityManagerFactory(persistence_unit, propMap).createEntityManager() : session;\r\n        }\r\n        return session;\r\n    }\r\n\r\n    @Override\r\n    public void closeSession(String persistence_unit) {\r\n        EntityManager session = null;\r\n        if (!sessions.isEmpty()) {\r\n            session = sessions.get(persistence_unit).get();\r\n            LOG.info(\"Encerrando sess\u00e3o do banco de dados\");\r\n            if (session != null) {\r\n                if (session.isOpen()) {\r\n                    session.close();\r\n                }\r\n            }\r\n        }\r\n        LOG.info(\"Removendo Entity Manager desta sess\u00e3o\");\r\n        sessions.remove(persistence_unit);\r\n    }\r\n\r\n    @Override\r\n    public void closeAll() {\r\n        LOG.info(\"Encerrando todas as sess\u00f5es\");\r\n        sessions.clear();\r\n    }\r\n\r\n    @Override\r\n    public Connection getConnection(String persistence_unit) {\r\n        try {\r\n            EntityManager entityManager = getSession(persistence_unit);\r\n            Connection conn = ((EntityManagerImpl) (entityManager.getDelegate())).getServerSession().getAccessor().getConnection();\r\n            return conn;\r\n        } catch (Exception ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public List getObjectList(String strHQL, String persistence_unit) {\r\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\r\n    }\r\n\r\n    @Override\r\n    public Optional getObjectList(Class entity, String strHQL, Map parameters, String persistence_unit) {\r\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\r\n    }\r\n\r\n    @Override\r\n    public List getObjectList(String strHQL, String strParam, Object valor, String persistence_unit) {\r\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\r\n    }\r\n\r\n    @Override\r\n    public Optional getObjectListNamedQuery(Class classType, String namedQuery, String[] strParam, Object[] valor, String persistence_unit) {\r\n        try {\r\n            EntityManager session = this.getSession(persistence_unit);\r\n            session.getTransaction().begin();\r\n            Query query = session.createNamedQuery(namedQuery, classType);\r\n            int cont = 0;\r\n            if (strParam != null) {\r\n                for (String p : strParam) {\r\n                    query.setParameter(p, valor[cont++]);\r\n                }\r\n            }\r\n            Optional<List<?>> objects = Optional.ofNullable(query.getResultList());\r\n            this.closeSession(persistence_unit);\r\n            return objects;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            this.closeSession(persistence_unit);\r\n            return Optional.empty();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Optional getObjectNamedQuery(Class classType, String namedQuery, String strParam, Object valor, String persistence_unit) {\r\n        try {\r\n            EntityManager session = this.getSession(persistence_unit);\r\n            session.getTransaction().begin();\r\n            Query query = session.createNamedQuery(namedQuery, classType);\r\n            if (strParam != null) {\r\n                query.setParameter(strParam, valor);\r\n            }\r\n            Object object = query.getSingleResult();\r\n            this.closeSession(persistence_unit);\r\n            return Optional.ofNullable(object);\r\n        } catch (Exception e) {\r\n            //e.printStackTrace();\r\n            this.closeSession(persistence_unit);\r\n            return Optional.empty();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public List getObjectList(String strHQL, String strParam, Boolean valor, String persistence_unit) {\r\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\r\n    }\r\n\r\n    @Override\r\n    public Object getObject(String strHQL, String persistence_unit) {\r\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\r\n    }\r\n\r\n    @Override\r\n    public Object getObject(String strHQL, String strParam, Object valor, String persistence_unit) {\r\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\r\n    }\r\n\r\n    @Override\r\n    public Object getObject(String strHQL, String[] strParam, String[] valor, String persistence_unit) {\r\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\r\n    }\r\n\r\n}", "class_id": 0, "repo": "tiagoadmstz/CBI", "file": "src/main/java/br/com/cbi/dal/DataBaseHelper.java", "last_update_at": "2019-03-01T23:27:42+00:00", "question_id": "281a46ab5705bea02890d49807f1f9744c4c5c17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DataBaseHelper implements EntityManagerHelper {\r\n\r\n    private final Map<String, ThreadLocal<EntityManager>> sessions = new HashMap<>();\r\n    private static final Logger LOG = Logger.getLogger(DataBaseHelper.class.getName());\r\n    private static final Map<String, String> propMap = new HashMap();\r\n    public final static int SALVAR = 0, ATUALIZAR = 1, DELETAR = 2;\r\n    public final static String DATABASE_PU = \"DATABASE_PU\";\r\n\r\n    public DataBaseHelper() {\r\n    }\r\n\r\n    @Override\r\n    public boolean getOperation(int operation_type, Object object, String persistence_unit) {\r\n        EntityManager session = getSession(persistence_unit);\r\n        EntityTransaction transaction = session.getTransaction();\r\n        try {\r\n            transaction.begin();\r\n            switch (operation_type) {\r\n                case SALVAR:\r\n                    LOG.info(\"Salvando registro no banco de dados\");\r\n                    session.persist(object);\r\n                    session.getTransaction().commit();\r\n                    break;\r\n                case ATUALIZAR:\r\n                    LOG.info(\"Atualizando registro no banco de dados\");\r\n                    session.merge(object);\r\n                    session.getTransaction().commit();\r\n                    break;\r\n                case DELETAR:\r\n                    LOG.info(\"Deletando registro no banco de dados\");\r\n                    session.remove(session.merge(object));\r\n                    session.getTransaction().commit();\r\n                    break;\r\n            }\r\n            this.closeSession(persistence_unit);\r\n            return true;\r\n        } catch (Exception e) {\r\n            //transaction.rollback();\r\n            this.closeSession(persistence_unit);\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public EntityManager getSession(String persistence_unit) {\r\n        EntityManager session = null;\r\n        if (sessions.isEmpty()) {\r\n            sessions.put(persistence_unit, new ThreadLocal());\r\n            session = sessions.get(persistence_unit).get();\r\n            session = session == null ? DataBaseFactoryService.getEntityManagerFactory(persistence_unit, propMap).createEntityManager() : session;\r\n        } else {\r\n            session = sessions.get(persistence_unit).get();\r\n            session = session == null ? DataBaseFactoryService.getEntityManagerFactory(persistence_unit, propMap).createEntityManager() : session;\r\n        }\r\n        return session;\r\n    }\r\n\r\n    @Override\r\n    public void closeSession(String persistence_unit) {\r\n        EntityManager session = null;\r\n        if (!sessions.isEmpty()) {\r\n            session = sessions.get(persistence_unit).get();\r\n            LOG.info(\"Encerrando sess\u00e3o do banco de dados\");\r\n            if (session != null) {\r\n                if (session.isOpen()) {\r\n                    session.close();\r\n                }\r\n            }\r\n        }\r\n        LOG.info(\"Removendo Entity Manager desta sess\u00e3o\");\r\n        sessions.remove(persistence_unit);\r\n    }\r\n\r\n    @Override\r\n    public void closeAll() {\r\n        LOG.info(\"Encerrando todas as sess\u00f5es\");\r\n        sessions.clear();\r\n    }\r\n\r\n    @Override\r\n    public Connection getConnection(String persistence_unit) {\r\n        try {\r\n            EntityManager entityManager = getSession(persistence_unit);\r\n            Connection conn = ((EntityManagerImpl) (entityManager.getDelegate())).getServerSession().getAccessor().getConnection();\r\n            return conn;\r\n        } catch (Exception ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public List getObjectList(String strHQL, String persistence_unit) {\r\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\r\n    }\r\n\r\n    @Override\r\n    public Optional getObjectList(Class entity, String strHQL, Map parameters, String persistence_unit) {\r\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\r\n    }\r\n\r\n    @Override\r\n    public List getObjectList(String strHQL, String strParam, Object valor, String persistence_unit) {\r\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\r\n    }\r\n\r\n    @Override\r\n    public Optional getObjectListNamedQuery(Class classType, String namedQuery, String[] strParam, Object[] valor, String persistence_unit) {\r\n        try {\r\n            EntityManager session = this.getSession(persistence_unit);\r\n            session.getTransaction().begin();\r\n            Query query = session.createNamedQuery(namedQuery, classType);\r\n            int cont = 0;\r\n            if (strParam != null) {\r\n                for (String p : strParam) {\r\n                    query.setParameter(p, valor[cont++]);\r\n                }\r\n            }\r\n            Optional<List<?>> objects = Optional.ofNullable(query.getResultList());\r\n            this.closeSession(persistence_unit);\r\n            return objects;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            this.closeSession(persistence_unit);\r\n            return Optional.empty();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Optional getObjectNamedQuery(Class classType, String namedQuery, String strParam, Object valor, String persistence_unit) {\r\n        try {\r\n            EntityManager session = this.getSession(persistence_unit);\r\n            session.getTransaction().begin();\r\n            Query query = session.createNamedQuery(namedQuery, classType);\r\n            if (strParam != null) {\r\n                query.setParameter(strParam, valor);\r\n            }\r\n            Object object = query.getSingleResult();\r\n            this.closeSession(persistence_unit);\r\n            return Optional.ofNullable(object);\r\n        } catch (Exception e) {\r\n            //e.printStackTrace();\r\n            this.closeSession(persistence_unit);\r\n            return Optional.empty();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public List getObjectList(String strHQL, String strParam, Boolean valor, String persistence_unit) {\r\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\r\n    }\r\n\r\n    @Override\r\n    public Object getObject(String strHQL, String persistence_unit) {\r\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\r\n    }\r\n\r\n    @Override\r\n    public Object getObject(String strHQL, String strParam, Object valor, String persistence_unit) {\r\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\r\n    }\r\n\r\n    @Override\r\n    public Object getObject(String strHQL, String[] strParam, String[] valor, String persistence_unit) {\r\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\r\n    }\r\n\r\n"]]}
{"hexsha": "2e767f2619da99b7069529fbcea829177548c706", "ext": "java", "lang": "Java", "content": "public class AnnotationMergerAE\n  extends CommonAE\n{\n  public static final String PARAM_SUBSUMING_ANNOTATION = \"SubsumingAnnotation\";\n  @ConfigurationParameter(name=\"SubsumingAnnotation\", mandatory=true)\n  private String subsumingAnnotationName;\n  public static final String PARAM_SUBSUMED_ANNOTATION = \"SubsumedAnnotation\";\n  @ConfigurationParameter(name=\"SubsumedAnnotation\", mandatory=true)\n  private String subsumedAnnotationName;\n  public static final String PARAM_STRICT_OFFSET = \"StrictOffset\";\n  @ConfigurationParameter(name=\"StrictOffset\", mandatory=false, defaultValue={\"false\"})\n  private boolean strictOffset;\n  \n  public void initialize(UimaContext aContext)\n    throws ResourceInitializationException\n  {\n/* 110 */     super.initialize(aContext);\n    \n\n/* 113 */     if (this.subsumedAnnotationName == null) { this.subsumedAnnotationName = this.subsumingAnnotationName;\n    }\n  }\n  \n\n\n\n\n\n\n\n\n  protected String processContextAnnotation(JCas inputViewJCas, FSIterator<Annotation> contextAnnotationsFSIter, Annotation contextAnnotation, FSIterator<Annotation> contextualizedInputAnnotationsFSIter, String inputFeatureString, JCas outputViewJCas, String outputAnnotationString, String ouputFeatureString)\n    throws AnalysisEngineProcessException\n  {\n/* 128 */     LocatedAnnotationIndexInterface locatedAnnotationIndex = LocatedAnnotationIndexBuilder.buildsIndex(inputViewJCas);\n    \n/* 130 */     Map<String, LocatedAnnotation> locatedAnnotationSortedMap = locatedAnnotationIndex.getLocatedAnnotationIndex();\n    \n/* 132 */     Set<String> sortedOffsetSet = locatedAnnotationSortedMap.keySet();\n    \n\n/* 135 */     for (String offset : sortedOffsetSet)\n    {\n/* 137 */       LocatedAnnotation locatedAnnotation = (LocatedAnnotation)locatedAnnotationSortedMap.get(offset);\n      \n\n\n/* 141 */       List<Annotation> currentAnnotations = locatedAnnotation.getCurrent();\n/* 142 */       Boolean isCurrentSubsumingAnnotation = Boolean.valueOf(false);\n/* 143 */       Boolean isCurrentSubsumedAnnotation = Boolean.valueOf(false);\n      \n/* 145 */       for (Annotation currentAnnotation : currentAnnotations) {\n/* 146 */         if (currentAnnotation.getType().getName().equalsIgnoreCase(this.subsumingAnnotationName)) {\n/* 147 */           isCurrentSubsumingAnnotation = Boolean.valueOf(true);\n        }\n/* 149 */         else if (currentAnnotation.getType().getName().equalsIgnoreCase(this.subsumedAnnotationName)) {\n/* 150 */           isCurrentSubsumedAnnotation = Boolean.valueOf(true);\n        }\n      }\n      \n/* 154 */       if (isCurrentSubsumingAnnotation.booleanValue())\n      {\n/* 156 */         AnnotationUtils.createAnnotation(inputViewJCas, outputAnnotationString, locatedAnnotation.getBegin(), locatedAnnotation.getEnd());\n\n\n\n      }\n/* 161 */       else if (isCurrentSubsumedAnnotation.booleanValue())\n      {\n\n/* 164 */         List<LocatedAnnotation> superAnnotations = locatedAnnotation.getContiguousParent();\n/* 165 */         Boolean isSuperSubsumingAnnotation = Boolean.valueOf(false);\n        \n/* 167 */         for (LocatedAnnotation superAnnotation : superAnnotations) {\n/* 168 */           if (superAnnotation.containsCurrent(this.subsumingAnnotationName)) {\n/* 169 */             isSuperSubsumingAnnotation = Boolean.valueOf(true);\n          }\n        }\n/* 172 */         if (!isSuperSubsumingAnnotation.booleanValue())\n        {\n/* 174 */           List<LocatedAnnotation> partialPreviousAnnotations = locatedAnnotation.getContiguousPartialPreceding();\n/* 175 */           Boolean isPartialPreviousSubsumingAnnotation = Boolean.valueOf(false);\n          \n/* 177 */           for (LocatedAnnotation partialPreviousAnnotation : partialPreviousAnnotations) {\n/* 178 */             if (partialPreviousAnnotation.containsCurrent(this.subsumingAnnotationName)) {\n/* 179 */               isPartialPreviousSubsumingAnnotation = Boolean.valueOf(true);\n            }\n          }\n/* 182 */           if (!isPartialPreviousSubsumingAnnotation.booleanValue())\n          {\n/* 184 */             List<LocatedAnnotation> partialNextAnnotations = locatedAnnotation.getContiguousPartialPreceding();\n/* 185 */             Boolean isPartialNextSubsumingAnnotation = Boolean.valueOf(false);\n            \n/* 187 */             for (LocatedAnnotation partialNextAnnotation : partialNextAnnotations) {\n/* 188 */               if (partialNextAnnotation.containsCurrent(this.subsumingAnnotationName)) {\n/* 189 */                 isPartialNextSubsumingAnnotation = Boolean.valueOf(true);\n              }\n            }\n/* 192 */             if (!isPartialNextSubsumingAnnotation.booleanValue())\n            {\n/* 194 */               AnnotationUtils.createAnnotation(inputViewJCas, outputAnnotationString, locatedAnnotation.getBegin(), locatedAnnotation.getEnd());\n            }\n          }\n        }\n      }\n    }\n    \n\n\n\n\n\n\n\n\n\n\n\n/* 212 */     return contextAnnotation.getCoveredText();\n  }\n  \n\n\n\n\n  private void doAnnotationMergerBasedOnDistinctSubsumingAndSubsumedAnnotations(JCas inputViewJCas)\n    throws AnalysisEngineProcessException\n  {\n/* 222 */     Map<Annotation, Integer> annotationAlreadySeenMap = new HashMap();\n    \n/* 224 */     Type subsumingAnnotationType = inputViewJCas.getTypeSystem().getType(this.subsumingAnnotationName);\n/* 225 */     AnnotationIndex<Annotation> subsumingAnnotationIndex = inputViewJCas.getAnnotationIndex(subsumingAnnotationType);\n    \n\n\n/* 229 */     FSIterator<Annotation> subsumingAnnotationIterator = subsumingAnnotationIndex.iterator();\n    \n\n/* 232 */     while (subsumingAnnotationIterator.hasNext()) {\n/* 233 */       Annotation aSubsumingAnnotation = (Annotation)subsumingAnnotationIterator.next();\n      \n\n/* 236 */       if (!annotationAlreadySeenMap.containsKey(aSubsumingAnnotation)) {\n/* 237 */         int minSubsumedAnnotationBegin = aSubsumingAnnotation.getEnd();\n/* 238 */         int maxSubsumedAnnotationEnd = aSubsumingAnnotation.getBegin();\n        \n/* 240 */         Map<Annotation, Integer> subsumedAnnotationPotentiallyAlreadySeenMap = new HashMap();\n        \n/* 242 */         FSIterator<Annotation> subsumedAnnotationIterator = AnnotationCollectionUtils.subiterator(inputViewJCas, aSubsumingAnnotation);\n        \n\n\n/* 246 */         while (subsumedAnnotationIterator.hasNext()) {\n/* 247 */           Annotation aSubsumedAnnotation = (Annotation)subsumedAnnotationIterator.next();\n          \n\n\n\n\n/* 253 */           if (aSubsumedAnnotation.getBegin() < minSubsumedAnnotationBegin) minSubsumedAnnotationBegin = aSubsumedAnnotation.getBegin();\n/* 254 */           if (aSubsumedAnnotation.getEnd() > maxSubsumedAnnotationEnd) { maxSubsumedAnnotationEnd = aSubsumedAnnotation.getEnd();\n          }\n/* 256 */           subsumedAnnotationPotentiallyAlreadySeenMap.put(aSubsumedAnnotation, Integer.valueOf(1));\n        }\n        \n\n\n\n/* 262 */         if ((aSubsumingAnnotation.getBegin() == minSubsumedAnnotationBegin) && (aSubsumingAnnotation.getEnd() == maxSubsumedAnnotationEnd))\n        {\n\n\n\n/* 267 */           annotationAlreadySeenMap.putAll(subsumedAnnotationPotentiallyAlreadySeenMap);\n          \n\n/* 270 */           AnnotationUtils.createAnnotation(inputViewJCas, getOutputAnnotation(), aSubsumingAnnotation.getBegin(), aSubsumingAnnotation.getEnd());\n        }\n      }\n    }\n    \n\n\n\n\n\n\n\n\n/* 283 */     Type subsumedAnnotationType = inputViewJCas.getTypeSystem().getType(this.subsumedAnnotationName);\n/* 284 */     System.err.println(\"Debug: subsumedAnnotationName \" + this.subsumedAnnotationName + \" subsumingAnnotationName \" + this.subsumingAnnotationName);\n/* 285 */     AnnotationIndex<Annotation> subsumedAnnotationIndex = inputViewJCas.getAnnotationIndex(subsumedAnnotationType);\n    \n\n\n\n/* 290 */     FSIterator<Annotation> subsumedAnnotationIterator = subsumedAnnotationIndex.iterator();\n/* 291 */     while (subsumedAnnotationIterator.hasNext()) {\n/* 292 */       Annotation aSubsumedAnnotation = (Annotation)subsumedAnnotationIterator.next();\n/* 293 */       if (!annotationAlreadySeenMap.containsKey(aSubsumedAnnotation)) {\n/* 294 */         AnnotationUtils.createAnnotation(inputViewJCas, getOutputAnnotation(), aSubsumedAnnotation.getBegin(), aSubsumedAnnotation.getEnd());\n      }\n    }\n  }\n}", "class_id": 0, "repo": "nicolashernandez/dev-star", "file": "uima-star/uima-common/src/main/java/fr/univnantes/lina/uima/common/ae/AnnotationMergerAE.java", "last_update_at": "2019-09-10T11:15:52+00:00", "question_id": "2e767f2619da99b7069529fbcea829177548c706", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AnnotationMergerAE\n  extends CommonAE\n{\n  public static final String PARAM_SUBSUMING_ANNOTATION = \"SubsumingAnnotation\";\n  @ConfigurationParameter(name=\"SubsumingAnnotation\", mandatory=true)\n  private String subsumingAnnotationName;\n  public static final String PARAM_SUBSUMED_ANNOTATION = \"SubsumedAnnotation\";\n  @ConfigurationParameter(name=\"SubsumedAnnotation\", mandatory=true)\n  private String subsumedAnnotationName;\n  public static final String PARAM_STRICT_OFFSET = \"StrictOffset\";\n  @ConfigurationParameter(name=\"StrictOffset\", mandatory=false, defaultValue={\"false\"})\n  private boolean strictOffset;\n  public void initialize(UimaContext aContext)\n    throws ResourceInitializationException\n  {\n/* 110 */     super.initialize(aContext);\n/* 113 */     if (this.subsumedAnnotationName == null) { this.subsumedAnnotationName = this.subsumingAnnotationName;\n    }\n  }\n  protected String processContextAnnotation(JCas inputViewJCas, FSIterator<Annotation> contextAnnotationsFSIter, Annotation contextAnnotation, FSIterator<Annotation> contextualizedInputAnnotationsFSIter, String inputFeatureString, JCas outputViewJCas, String outputAnnotationString, String ouputFeatureString)\n    throws AnalysisEngineProcessException\n  {\n/* 128 */     LocatedAnnotationIndexInterface locatedAnnotationIndex = LocatedAnnotationIndexBuilder.buildsIndex(inputViewJCas);\n/* 130 */     Map<String, LocatedAnnotation> locatedAnnotationSortedMap = locatedAnnotationIndex.getLocatedAnnotationIndex();\n/* 132 */     Set<String> sortedOffsetSet = locatedAnnotationSortedMap.keySet();\n/* 135 */     for (String offset : sortedOffsetSet)\n    {\n/* 137 */       LocatedAnnotation locatedAnnotation = (LocatedAnnotation)locatedAnnotationSortedMap.get(offset);\n/* 141 */       List<Annotation> currentAnnotations = locatedAnnotation.getCurrent();\n/* 142 */       Boolean isCurrentSubsumingAnnotation = Boolean.valueOf(false);\n/* 143 */       Boolean isCurrentSubsumedAnnotation = Boolean.valueOf(false);\n/* 145 */       for (Annotation currentAnnotation : currentAnnotations) {\n/* 146 */         if (currentAnnotation.getType().getName().equalsIgnoreCase(this.subsumingAnnotationName)) {\n/* 147 */           isCurrentSubsumingAnnotation = Boolean.valueOf(true);\n        }\n/* 149 */         else if (currentAnnotation.getType().getName().equalsIgnoreCase(this.subsumedAnnotationName)) {\n/* 150 */           isCurrentSubsumedAnnotation = Boolean.valueOf(true);\n        }\n      }\n/* 154 */       if (isCurrentSubsumingAnnotation.booleanValue())\n      {\n/* 156 */         AnnotationUtils.createAnnotation(inputViewJCas, outputAnnotationString, locatedAnnotation.getBegin(), locatedAnnotation.getEnd());\n      }\n/* 161 */       else if (isCurrentSubsumedAnnotation.booleanValue())\n      {\n/* 164 */         List<LocatedAnnotation> superAnnotations = locatedAnnotation.getContiguousParent();\n/* 165 */         Boolean isSuperSubsumingAnnotation = Boolean.valueOf(false);\n/* 167 */         for (LocatedAnnotation superAnnotation : superAnnotations) {\n/* 168 */           if (superAnnotation.containsCurrent(this.subsumingAnnotationName)) {\n/* 169 */             isSuperSubsumingAnnotation = Boolean.valueOf(true);\n          }\n        }\n/* 172 */         if (!isSuperSubsumingAnnotation.booleanValue())\n        {\n/* 174 */           List<LocatedAnnotation> partialPreviousAnnotations = locatedAnnotation.getContiguousPartialPreceding();\n/* 175 */           Boolean isPartialPreviousSubsumingAnnotation = Boolean.valueOf(false);\n/* 177 */           for (LocatedAnnotation partialPreviousAnnotation : partialPreviousAnnotations) {\n/* 178 */             if (partialPreviousAnnotation.containsCurrent(this.subsumingAnnotationName)) {\n/* 179 */               isPartialPreviousSubsumingAnnotation = Boolean.valueOf(true);\n            }\n          }\n/* 182 */           if (!isPartialPreviousSubsumingAnnotation.booleanValue())\n          {\n/* 184 */             List<LocatedAnnotation> partialNextAnnotations = locatedAnnotation.getContiguousPartialPreceding();\n/* 185 */             Boolean isPartialNextSubsumingAnnotation = Boolean.valueOf(false);\n/* 187 */             for (LocatedAnnotation partialNextAnnotation : partialNextAnnotations) {\n/* 188 */               if (partialNextAnnotation.containsCurrent(this.subsumingAnnotationName)) {\n/* 189 */                 isPartialNextSubsumingAnnotation = Boolean.valueOf(true);\n              }\n            }\n/* 192 */             if (!isPartialNextSubsumingAnnotation.booleanValue())\n            {\n/* 194 */               AnnotationUtils.createAnnotation(inputViewJCas, outputAnnotationString, locatedAnnotation.getBegin(), locatedAnnotation.getEnd());\n            }\n          }\n        }\n      }\n    }\n/* 212 */     return contextAnnotation.getCoveredText();\n  }\n  private void doAnnotationMergerBasedOnDistinctSubsumingAndSubsumedAnnotations(JCas inputViewJCas)\n    throws AnalysisEngineProcessException\n  {\n/* 222 */     Map<Annotation, Integer> annotationAlreadySeenMap = new HashMap();\n/* 224 */     Type subsumingAnnotationType = inputViewJCas.getTypeSystem().getType(this.subsumingAnnotationName);\n/* 225 */     AnnotationIndex<Annotation> subsumingAnnotationIndex = inputViewJCas.getAnnotationIndex(subsumingAnnotationType);\n/* 229 */     FSIterator<Annotation> subsumingAnnotationIterator = subsumingAnnotationIndex.iterator();\n/* 232 */     while (subsumingAnnotationIterator.hasNext()) {\n/* 233 */       Annotation aSubsumingAnnotation = (Annotation)subsumingAnnotationIterator.next();\n/* 236 */       if (!annotationAlreadySeenMap.containsKey(aSubsumingAnnotation)) {\n/* 237 */         int minSubsumedAnnotationBegin = aSubsumingAnnotation.getEnd();\n/* 238 */         int maxSubsumedAnnotationEnd = aSubsumingAnnotation.getBegin();\n/* 240 */         Map<Annotation, Integer> subsumedAnnotationPotentiallyAlreadySeenMap = new HashMap();\n/* 242 */         FSIterator<Annotation> subsumedAnnotationIterator = AnnotationCollectionUtils.subiterator(inputViewJCas, aSubsumingAnnotation);\n/* 246 */         while (subsumedAnnotationIterator.hasNext()) {\n/* 247 */           Annotation aSubsumedAnnotation = (Annotation)subsumedAnnotationIterator.next();\n/* 253 */           if (aSubsumedAnnotation.getBegin() < minSubsumedAnnotationBegin) minSubsumedAnnotationBegin = aSubsumedAnnotation.getBegin();\n/* 254 */           if (aSubsumedAnnotation.getEnd() > maxSubsumedAnnotationEnd) { maxSubsumedAnnotationEnd = aSubsumedAnnotation.getEnd();\n          }\n/* 256 */           subsumedAnnotationPotentiallyAlreadySeenMap.put(aSubsumedAnnotation, Integer.valueOf(1));\n        }\n/* 262 */         if ((aSubsumingAnnotation.getBegin() == minSubsumedAnnotationBegin) && (aSubsumingAnnotation.getEnd() == maxSubsumedAnnotationEnd))\n        {\n/* 267 */           annotationAlreadySeenMap.putAll(subsumedAnnotationPotentiallyAlreadySeenMap);\n/* 270 */           AnnotationUtils.createAnnotation(inputViewJCas, getOutputAnnotation(), aSubsumingAnnotation.getBegin(), aSubsumingAnnotation.getEnd());\n        }\n      }\n    }\n/* 283 */     Type subsumedAnnotationType = inputViewJCas.getTypeSystem().getType(this.subsumedAnnotationName);\n/* 284 */     System.err.println(\"Debug: subsumedAnnotationName \" + this.subsumedAnnotationName + \" subsumingAnnotationName \" + this.subsumingAnnotationName);\n/* 285 */     AnnotationIndex<Annotation> subsumedAnnotationIndex = inputViewJCas.getAnnotationIndex(subsumedAnnotationType);\n/* 290 */     FSIterator<Annotation> subsumedAnnotationIterator = subsumedAnnotationIndex.iterator();\n/* 291 */     while (subsumedAnnotationIterator.hasNext()) {\n/* 292 */       Annotation aSubsumedAnnotation = (Annotation)subsumedAnnotationIterator.next();\n/* 293 */       if (!annotationAlreadySeenMap.containsKey(aSubsumedAnnotation)) {\n/* 294 */         AnnotationUtils.createAnnotation(inputViewJCas, getOutputAnnotation(), aSubsumedAnnotation.getBegin(), aSubsumedAnnotation.getEnd());\n      }\n    }\n  }\n"]]}
{"hexsha": "b5f3e8ad1c9de91212ae32aeb01c1d0cec208493", "ext": "java", "lang": "Java", "content": "public class BitcoinBootstrapBlockCornerCaseTest {\n    \n    private static VeriBlockSecurity security;\n    private static BitcoinBlockchain blockchain;\n\n    private final static int block1Height = 601491;\n    private final static BitcoinBlock block1  = new BitcoinBlock(\n            766099456,\n            Sha256Hash.wrap(\"00000000000000000004dc9c42c22f489ade54a9349e3a47aee5b55069062afd\"),\n            Sha256Hash.wrap(\"87839c0e4c6771557ef02a5076c8b46a7157e5532eff7153293791ca852d2e58\"),\n            1572336145, 0x17148edf, 790109764);\n\n    private final static BitcoinBlock block2 = new BitcoinBlock(\n            1073733632,\n            Sha256Hash.wrap(\"0000000000000000000faad7ae177b313ee4e3f1da519dbbf5b3ab58ccff6338\"),\n            Sha256Hash.wrap(\"902e5a70c8fa99fb9ba6d0f855f5e84b8ffc3fe56b694889d07031d8adb6a0f8\"),\n            1572336708, 0x17148edf, 344118374);\n\n    private final static BitcoinBlock block3 = new BitcoinBlock(\n            536870912,\n            Sha256Hash.wrap(\"00000000000000000001163c9e1130c26984d831cb16c16f994945a197550897\"),\n            Sha256Hash.wrap(\"2dfad61070eeea30ee035cc58ac20a325292802f9445851d14f23b4e71ddee61\"),\n            1572337243, 0x17148edf, 2111493782);\n\n    @Before\n    public void setUp() throws SQLException, IOException {\n        VeriBlockIntegrationLibraryManager manager = new VeriBlockIntegrationLibraryManager();\n        security = manager.init();\n        blockchain = security.getBitcoinBlockchain();\n    }\n    \n    @After\n    public void tearDown() throws SQLException {\n        security.shutdown();\n    }\n\n    @Test\n    public void checkBitcoinContextuallyTest() throws SQLException {\n        blockchain.bootstrap(Arrays.asList(block1, block2, block3), block1Height);\n\n        security.checkConnectivity(block1);\n        security.checkConnectivity(block2);\n        security.checkConnectivity(block3);\n    }\n\n    @Test\n    public void addBootstrapBlockTest() throws SQLException {\n        blockchain.bootstrap(Arrays.asList(block1, block2), block1Height);\n\n        blockchain.add(block1);\n        blockchain.add(block2);\n        blockchain.add(block3);\n    }\n\n}", "class_id": 0, "repo": "VeriBlock/alt-integration", "file": "core/src/test/java/org/veriblock/sdk/BitcoinBootstrapBlockCornerCaseTest.java", "last_update_at": "2019-11-21T14:10:03+00:00", "question_id": "b5f3e8ad1c9de91212ae32aeb01c1d0cec208493", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BitcoinBootstrapBlockCornerCaseTest {\n    private static VeriBlockSecurity security;\n    private static BitcoinBlockchain blockchain;\n    private final static int block1Height = 601491;\n    private final static BitcoinBlock block1  = new BitcoinBlock(\n            766099456,\n            Sha256Hash.wrap(\"00000000000000000004dc9c42c22f489ade54a9349e3a47aee5b55069062afd\"),\n            Sha256Hash.wrap(\"87839c0e4c6771557ef02a5076c8b46a7157e5532eff7153293791ca852d2e58\"),\n            1572336145, 0x17148edf, 790109764);\n    private final static BitcoinBlock block2 = new BitcoinBlock(\n            1073733632,\n            Sha256Hash.wrap(\"0000000000000000000faad7ae177b313ee4e3f1da519dbbf5b3ab58ccff6338\"),\n            Sha256Hash.wrap(\"902e5a70c8fa99fb9ba6d0f855f5e84b8ffc3fe56b694889d07031d8adb6a0f8\"),\n            1572336708, 0x17148edf, 344118374);\n    private final static BitcoinBlock block3 = new BitcoinBlock(\n            536870912,\n            Sha256Hash.wrap(\"00000000000000000001163c9e1130c26984d831cb16c16f994945a197550897\"),\n            Sha256Hash.wrap(\"2dfad61070eeea30ee035cc58ac20a325292802f9445851d14f23b4e71ddee61\"),\n            1572337243, 0x17148edf, 2111493782);\n    @Before\n    public void setUp() throws SQLException, IOException {\n        VeriBlockIntegrationLibraryManager manager = new VeriBlockIntegrationLibraryManager();\n        security = manager.init();\n        blockchain = security.getBitcoinBlockchain();\n    }\n    @After\n    public void tearDown() throws SQLException {\n        security.shutdown();\n    }\n    @Test\n    public void checkBitcoinContextuallyTest() throws SQLException {\n        blockchain.bootstrap(Arrays.asList(block1, block2, block3), block1Height);\n        security.checkConnectivity(block1);\n        security.checkConnectivity(block2);\n        security.checkConnectivity(block3);\n    }\n    @Test\n    public void addBootstrapBlockTest() throws SQLException {\n        blockchain.bootstrap(Arrays.asList(block1, block2), block1Height);\n        blockchain.add(block1);\n        blockchain.add(block2);\n        blockchain.add(block3);\n    }\n"]]}
{"hexsha": "6767dab337666325589573c903cf855a982aaee7", "ext": "java", "lang": "Java", "content": "public class Str_ser\n{\npublic static void main(String args[])\n{\nScanner sc=new Scanner(System.in);\nSystem.out.println(\"enter string\");\nString w=sc.nextLine();\nint al=1;\nw=w.trim();\nfor(int i=0;i<w.length();i++)\n{\nif(w.charAt(i)==' ')\n{\nal++;\n}\n}\n\nString m[]=new String[al];\nint h=0;\nm[0]=\"\";\nfor(int j=0;j<w.length();j++)\n{\n if(w.charAt(j)==' ')\n {\n     h=h+1;\n     m[h]=\"\";\n    }\n    else\n    {\n    m[h]=m[h]+w.charAt(j);\n}\n}\n\nfor(int k=0;k<al/2;k++)\n{\nSystem.out.print(m[k]+\" \");\nint l=al-k-1;\nif(k==l)\n{\nbreak;\n}\nSystem.out.print(m[al-k-1]+\" \");\n}\nif(al%2!=0)\n{\nSystem.out.println(m[al/2]);\n}\n}\n}", "class_id": 0, "repo": "SayanGhoshBDA/code-backup", "file": "java_backup/my java/Mainak Roy/Str_ser.java", "last_update_at": "2019-05-08T10:09:52+00:00", "question_id": "6767dab337666325589573c903cf855a982aaee7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Str_ser\n{\npublic static void main(String args[])\n{\nScanner sc=new Scanner(System.in);\nSystem.out.println(\"enter string\");\nString w=sc.nextLine();\nint al=1;\nw=w.trim();\nfor(int i=0;i<w.length();i++)\n{\nif(w.charAt(i)==' ')\n{\nal++;\n}\n}\nString m[]=new String[al];\nint h=0;\nm[0]=\"\";\nfor(int j=0;j<w.length();j++)\n{\n if(w.charAt(j)==' ')\n {\n     h=h+1;\n     m[h]=\"\";\n    }\n    else\n    {\n    m[h]=m[h]+w.charAt(j);\n}\n}\nfor(int k=0;k<al/2;k++)\n{\nSystem.out.print(m[k]+\" \");\nint l=al-k-1;\nif(k==l)\n{\nbreak;\n}\nSystem.out.print(m[al-k-1]+\" \");\n}\nif(al%2!=0)\n{\nSystem.out.println(m[al/2]);\n}\n}\n"]]}
{"hexsha": "c74a7bb37080f5e69bddec915a5d542efab5b0db", "ext": "java", "lang": "Java", "content": "@Service\npublic class CallbackService {\n\n    private final static Logger logger = LoggerFactory.getLogger(CallbackService.class);\n    private final static String CHECK_URL = \"check_url\";\n    private final static String EVENT_TYPE = \"EventType\";\n    private final static String SUCCESS = \"success\";\n\n    public Map<String, String> callback(String signature, String timeStamp, String nonce, String encrypt) {\n        if(ToolsKit.isEmpty(signature) || ToolsKit.isEmpty(timeStamp) || ToolsKit.isEmpty(nonce)) {\n            throw new ServiceException(\"\u56de\u8c03\u65f6\uff0c\u6240\u6709\u53c2\u6570\u4e0d\u80fd\u4e3a\u7a7a\");\n        }\n\n        String plainText = DingTalkUtils.getDecryptMsg(signature, timeStamp, nonce, encrypt);\n        logger.warn(\"\u660e\u6587: \" + plainText);\n        Map callbackMap = ToolsKit.jsonParseObject(plainText, Map.class);\n        if(ToolsKit.isEmpty(callbackMap)) {\n            throw new ServiceException(\"\u6839\u636e\u89e3\u5bc6\u7684\u5b57\u7b26\u4e32\u8f6c\u6362\u6210Map\u65f6\u51fa\u9519: Map\u4e3a\u7a7a\");\n        }\n        String eventType = callbackMap.get(EVENT_TYPE) + \"\";\n\n//        switch (eventType) {\n//            case \"user_modify_org\" :\n//                logger.warn(\"\u901a\u8baf\u5f55\u7528\u6237\u66f4\u6539\");\n//                break;\n//            case \"bpms_task_change\" :\n//                logger.warn(\"\u5ba1\u6279\u4efb\u52a1\u5f00\u59cb/\u7ed3\u675f\");\n//                break;\n//            case \"bpms_instance_change\" :\n//                logger.warn(\"\u5ba1\u6279\u5b9e\u4f8b\u5f00\u59cb/\u7ed3\u675f\");\n//                break;\n//             default:\n//                 logger.warn(\"############\");\n//        }\n\n\n        try {\n            if(!CHECK_URL.equalsIgnoreCase(eventType)) {\n                IStrategy strategy = DingTalkUtils.getStrategy(eventType);\n                if(ToolsKit.isNotEmpty(strategy)) {\n                    // throw new ServiceException(\"\u6ca1\u6709\u627e\u5230\u5bf9\u5e94\u7684\u7b56\u7565\u7c7b\u8fdb\u884c\u5b9e\u65bd\u64cd\u4f5c\");\n                    strategy.handle(plainText);\n                }\n            }\n            // \u8fd4\u56desuccess\u7684\u52a0\u5bc6\u4fe1\u606f\u8868\u793a\u56de\u8c03\u5904\u7406\u6210\u529f\n            return DingTalkUtils.getEncryptedMap(SUCCESS, System.currentTimeMillis(), DingTalkUtils.getRandomStr(8));\n        } catch (Exception e) {\n            throw new ServiceException(e.getMessage(), e);\n        }\n    }\n}", "class_id": 0, "repo": "tcrct/dunag-dingtalk", "file": "src/main/java/com/duangframework/dingtalk/service/CallbackService.java", "last_update_at": "2019-08-05T12:36:50+00:00", "question_id": "c74a7bb37080f5e69bddec915a5d542efab5b0db", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\npublic class CallbackService {\n    private final static Logger logger = LoggerFactory.getLogger(CallbackService.class);\n    private final static String CHECK_URL = \"check_url\";\n    private final static String EVENT_TYPE = \"EventType\";\n    private final static String SUCCESS = \"success\";\n    public Map<String, String> callback(String signature, String timeStamp, String nonce, String encrypt) {\n        if(ToolsKit.isEmpty(signature) || ToolsKit.isEmpty(timeStamp) || ToolsKit.isEmpty(nonce)) {\n            throw new ServiceException(\"\u56de\u8c03\u65f6\uff0c\u6240\u6709\u53c2\u6570\u4e0d\u80fd\u4e3a\u7a7a\");\n        }\n        String plainText = DingTalkUtils.getDecryptMsg(signature, timeStamp, nonce, encrypt);\n        logger.warn(\"\u660e\u6587: \" + plainText);\n        Map callbackMap = ToolsKit.jsonParseObject(plainText, Map.class);\n        if(ToolsKit.isEmpty(callbackMap)) {\n            throw new ServiceException(\"\u6839\u636e\u89e3\u5bc6\u7684\u5b57\u7b26\u4e32\u8f6c\u6362\u6210Map\u65f6\u51fa\u9519: Map\u4e3a\u7a7a\");\n        }\n        String eventType = callbackMap.get(EVENT_TYPE) + \"\";\n//        switch (eventType) {\n//            case \"user_modify_org\" :\n//                logger.warn(\"\u901a\u8baf\u5f55\u7528\u6237\u66f4\u6539\");\n//                break;\n//            case \"bpms_task_change\" :\n//                logger.warn(\"\u5ba1\u6279\u4efb\u52a1\u5f00\u59cb/\u7ed3\u675f\");\n//                break;\n//            case \"bpms_instance_change\" :\n//                logger.warn(\"\u5ba1\u6279\u5b9e\u4f8b\u5f00\u59cb/\u7ed3\u675f\");\n//                break;\n//             default:\n//                 logger.warn(\"############\");\n//        }\n        try {\n            if(!CHECK_URL.equalsIgnoreCase(eventType)) {\n                IStrategy strategy = DingTalkUtils.getStrategy(eventType);\n                if(ToolsKit.isNotEmpty(strategy)) {\n                    // throw new ServiceException(\"\u6ca1\u6709\u627e\u5230\u5bf9\u5e94\u7684\u7b56\u7565\u7c7b\u8fdb\u884c\u5b9e\u65bd\u64cd\u4f5c\");\n                    strategy.handle(plainText);\n                }\n            }\n            // \u8fd4\u56desuccess\u7684\u52a0\u5bc6\u4fe1\u606f\u8868\u793a\u56de\u8c03\u5904\u7406\u6210\u529f\n            return DingTalkUtils.getEncryptedMap(SUCCESS, System.currentTimeMillis(), DingTalkUtils.getRandomStr(8));\n        } catch (Exception e) {\n            throw new ServiceException(e.getMessage(), e);\n        }\n    }\n"]]}
{"hexsha": "a585178eddf349d67cdbbb48fc7170c94b329e3c", "ext": "java", "lang": "Java", "content": "public class CopyTaskCommand extends Command {\n\n    public static final String COMMAND_WORD = \"copytask\";\n\n    public static final String MESSAGE_USAGE = COMMAND_WORD\n            + \": Copies the Task identified by the index from one plan to another.\\n\"\n            + \"Parameters:\\n\"\n            + PREFIX_TASK + \"TASK_INDEX \"\n            + PREFIX_PLAN_FROM + \"PLAN_FROM_INDEX \"\n            + PREFIX_PLAN_TO + \"PLAN_TO_INDEX\\n\"\n            + \"Example:\\n\"\n            + COMMAND_WORD + \" \"\n            + PREFIX_TASK + \"10 \"\n            + PREFIX_PLAN_FROM + \"1 \"\n            + PREFIX_PLAN_TO + \"2\";\n\n    public static final String MESSAGE_MOVE_TASK_SUCCESS = \"Task [%1$s] copied from Plan [%2$s] to Plan [%3$s].\";\n\n    private final CopyTaskDescriptor copyTaskDescriptor;\n\n    /**\n     * Creates a CopyTaskCommand to copy a {@code Task} from the specified {@code Plan} to another\n     *\n     * @param copyTaskDescriptor details of the plan and problem involved\n     */\n    public CopyTaskCommand(CopyTaskDescriptor copyTaskDescriptor) {\n        requireNonNull(copyTaskDescriptor);\n\n        this.copyTaskDescriptor = copyTaskDescriptor;\n    }\n\n    @Override\n    public CommandResult execute(Model model, CommandHistory history) throws CommandException {\n        requireNonNull(model);\n\n        String successMessage =\n            TaskCommandUtil.shiftTask(\n                model,\n                copyTaskDescriptor.planFromIndex,\n                copyTaskDescriptor.planToIndex,\n                copyTaskDescriptor.taskIndex,\n                false,\n                MESSAGE_MOVE_TASK_SUCCESS\n            );\n\n        return new CommandResult(successMessage);\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        return other == this // short circuit if same object\n                || (other instanceof CopyTaskCommand // instanceof handles nulls\n                && copyTaskDescriptor.equals(((CopyTaskCommand) other).copyTaskDescriptor)); // state check\n    }\n\n    /**\n     * Stores the details of the plan and problem involved.\n     */\n    public static class CopyTaskDescriptor {\n        private Index taskIndex;\n        private Index planFromIndex;\n        private Index planToIndex;\n\n        public CopyTaskDescriptor(Index taskIndex, Index planFromIndex, Index planToIndex) {\n            this.taskIndex = taskIndex;\n            this.planFromIndex = planFromIndex;\n            this.planToIndex = planToIndex;\n        }\n\n        @Override\n        public boolean equals(Object other) {\n            return other == this // short circuit if same object\n                || (other instanceof CopyTaskDescriptor // instanceof handles nulls\n                && taskIndex.equals(((CopyTaskDescriptor) other).taskIndex)\n                && planFromIndex.equals(((CopyTaskDescriptor) other).planFromIndex)\n                && planToIndex.equals(((CopyTaskDescriptor) other).planToIndex));\n        }\n    }\n}", "class_id": 0, "repo": "jiayushe/main", "file": "src/main/java/seedu/algobase/logic/commands/task/CopyTaskCommand.java", "last_update_at": "2019-11-14T05:12:47+00:00", "question_id": "a585178eddf349d67cdbbb48fc7170c94b329e3c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CopyTaskCommand extends Command {\n    public static final String COMMAND_WORD = \"copytask\";\n    public static final String MESSAGE_USAGE = COMMAND_WORD\n            + \": Copies the Task identified by the index from one plan to another.\\n\"\n            + \"Parameters:\\n\"\n            + PREFIX_TASK + \"TASK_INDEX \"\n            + PREFIX_PLAN_FROM + \"PLAN_FROM_INDEX \"\n            + PREFIX_PLAN_TO + \"PLAN_TO_INDEX\\n\"\n            + \"Example:\\n\"\n            + COMMAND_WORD + \" \"\n            + PREFIX_TASK + \"10 \"\n            + PREFIX_PLAN_FROM + \"1 \"\n            + PREFIX_PLAN_TO + \"2\";\n    public static final String MESSAGE_MOVE_TASK_SUCCESS = \"Task [%1$s] copied from Plan [%2$s] to Plan [%3$s].\";\n    private final CopyTaskDescriptor copyTaskDescriptor;\n    /**\n     * Creates a CopyTaskCommand to copy a {@code Task} from the specified {@code Plan} to another\n     *\n     * @param copyTaskDescriptor details of the plan and problem involved\n     */\n    public CopyTaskCommand(CopyTaskDescriptor copyTaskDescriptor) {\n        requireNonNull(copyTaskDescriptor);\n        this.copyTaskDescriptor = copyTaskDescriptor;\n    }\n    @Override\n    public CommandResult execute(Model model, CommandHistory history) throws CommandException {\n        requireNonNull(model);\n        String successMessage =\n            TaskCommandUtil.shiftTask(\n                model,\n                copyTaskDescriptor.planFromIndex,\n                copyTaskDescriptor.planToIndex,\n                copyTaskDescriptor.taskIndex,\n                false,\n                MESSAGE_MOVE_TASK_SUCCESS\n            );\n        return new CommandResult(successMessage);\n    }\n    @Override\n    public boolean equals(Object other) {\n        return other == this // short circuit if same object\n                || (other instanceof CopyTaskCommand // instanceof handles nulls\n                && copyTaskDescriptor.equals(((CopyTaskCommand) other).copyTaskDescriptor)); // state check\n    }\n    /**\n     * Stores the details of the plan and problem involved.\n     */\n    public static class CopyTaskDescriptor {\n        private Index taskIndex;\n        private Index planFromIndex;\n        private Index planToIndex;\n        public CopyTaskDescriptor(Index taskIndex, Index planFromIndex, Index planToIndex) {\n            this.taskIndex = taskIndex;\n            this.planFromIndex = planFromIndex;\n            this.planToIndex = planToIndex;\n        }\n        @Override\n        public boolean equals(Object other) {\n            return other == this // short circuit if same object\n                || (other instanceof CopyTaskDescriptor // instanceof handles nulls\n                && taskIndex.equals(((CopyTaskDescriptor) other).taskIndex)\n                && planFromIndex.equals(((CopyTaskDescriptor) other).planFromIndex)\n                && planToIndex.equals(((CopyTaskDescriptor) other).planToIndex));\n        }\n    }\n"]]}
{"hexsha": "2265c1d4383d6d2de66da1a0deeeda03b46626c5", "ext": "java", "lang": "Java", "content": "public class ApplicationActor extends UntypedActor {\n\n  private static final Logger LOG = LoggerFactory.getLogger(ApplicationActor.class);\n\n  private final AkkaContext context;\n\n  private final Map<EndpointObjectHash, GlobalEndpointActorMetaData> globalEndpointSessions;\n  /**\n   * The endpoint sessions.\n   */\n  private final Map<EndpointObjectHash, LocalEndpointActorMetaData> localEndpointSessions;\n\n  private final Map<String, EndpointObjectHash> endpointActorMap;\n\n  /**\n   * The topic sessions.\n   */\n  private final Map<String, ActorRef> topicSessions;\n\n  private final String nodeId;\n\n  private final String tenantId;\n\n  private final String appToken;\n\n  private final Map<String, ActorRef> logsSessions;\n\n  private final Map<String, ActorRef> userVerifierSessions;\n\n  private ActorRef applicationLogActor;\n\n  private ActorRef userVerifierActor;\n\n  /**\n   * Instantiates a new application actor.\n   *\n   * @param context          the context\n   * @param applicationToken the application token\n   */\n  private ApplicationActor(AkkaContext context, String tenantId, String applicationToken) {\n    this.context = context;\n    this.nodeId = context.getClusterService().getNodeId();\n    this.tenantId = tenantId;\n    this.appToken = applicationToken;\n    this.globalEndpointSessions = new HashMap<>();\n    this.localEndpointSessions = new HashMap<>();\n    this.endpointActorMap = new HashMap<>();\n    this.topicSessions = new HashMap<>();\n    this.logsSessions = new HashMap<>();\n    this.userVerifierSessions = new HashMap<>();\n    this.applicationLogActor = getOrCreateLogActor();\n    this.userVerifierActor = getOrCreateUserVerifierActor();\n  }\n\n  /**\n   * Builds the topic key.\n   *\n   * @param topicId the topic id\n   * @return the string\n   */\n  public static String buildTopicKey(String topicId) {\n    // TODO: Improve;\n    return topicId;\n  }\n\n  @Override\n  public SupervisorStrategy supervisorStrategy() {\n    return SupervisionStrategyFactory.createApplicationActorStrategy(context);\n  }\n\n  /*\n   * (non-Javadoc)\n   *\n   * @see akka.actor.UntypedActor#onReceive(java.lang.Object)\n   */\n  @Override\n  public void onReceive(Object message) throws Exception {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"[{}] Received: {}\", appToken, message);\n    } else {\n      LOG.debug(\"[{}] Received: {}\", appToken, message.getClass().getName());\n    }\n    if (message instanceof EndpointAwareMessage) {\n      processEndpointAwareMessage((EndpointAwareMessage) message);\n    }\n    if (message instanceof EndpointActorMsg) {\n      processEndpointActorMsg((EndpointActorMsg) message);\n    } else if (message instanceof SessionAware) {\n      processSessionAwareMessage((SessionAware) message);\n    } else if (message instanceof EndpointEventDeliveryMessage) {\n      processEndpointEventDeliveryMessage((EndpointEventDeliveryMessage) message);\n    } else if (message instanceof Terminated) {\n      processTermination((Terminated) message);\n    } else if (message instanceof ThriftNotificationMessage) {\n      processThriftNotification((ThriftNotificationMessage) message);\n    } else if (message instanceof EndpointStopMessage) {\n      updateEndpointActor((EndpointStopMessage) message);\n    } else if (message instanceof LogEventPackMessage) {\n      processLogEventPackMessage((LogEventPackMessage) message);\n    } else if (message instanceof UserVerificationRequestMessage) {\n      processUserVerificationRequestMessage((UserVerificationRequestMessage) message);\n    } else if (message instanceof EndpointUserActionMessage) {\n      processEndpointUserActionMessage((EndpointUserActionMessage) message, true);\n    } else if (message instanceof EndpointUserActionRouteMessage) {\n      processEndpointUserActionMessage(((EndpointUserActionRouteMessage) message).getMessage(),\n          false);\n    } else if (message instanceof StatusRequestMessage) {\n      processStatusRequest((StatusRequestMessage) message);\n    } else if (message instanceof ClusterUpdateMessage) {\n      processClusterUpdate((ClusterUpdateMessage) message);\n    } else if (message instanceof RouteMessage<?>) {\n      processRouteMessage((RouteMessage<?>) message);\n    }\n  }\n\n  private void processEndpointActorMsg(EndpointActorMsg message) {\n    EndpointAddress address = message.getAddress();\n    EndpointObjectHash endpointId = EndpointObjectHash.fromBytes(address.getEntityId());\n    ActorClassifier classifier = message.getClassifier();\n    if (classifier == ActorClassifier.APPLICATION) {\n      boolean processed = false;\n      if (message instanceof ThriftEndpointActorMsg<?>) {\n        processed = processCommonThriftEndpointActorMsg(\n            endpointId, (ThriftEndpointActorMsg<?>) message);\n      }\n      if (!processed) {\n        LOG.warn(\"[{}] Failed to lookup processor for endpoint msg {}.\", endpointId, message);\n      }\n    } else {\n      EndpointActorMetaData actorMetaData = null;\n      if (classifier == ActorClassifier.GLOBAL) {\n        actorMetaData = globalEndpointSessions.get(endpointId);\n      } else if (classifier == ActorClassifier.LOCAL) {\n        actorMetaData = localEndpointSessions.get(endpointId);\n      }\n      if (actorMetaData != null) {\n        actorMetaData.actorRef.tell(message, context().self());\n      } else {\n        LOG.warn(\"[{}] Failed to lookup {} actor for endpoint.\", endpointId, classifier.name());\n      }\n    }\n  }\n\n  private boolean processCommonThriftEndpointActorMsg(EndpointObjectHash endpointId,\n                                                      ThriftEndpointActorMsg<?> msg) {\n    if (msg.getMsg() instanceof ThriftEndpointDeregistrationMessage) {\n      forwardMessageQuietly(globalEndpointSessions.get(endpointId), msg);\n      forwardMessageQuietly(localEndpointSessions.get(endpointId), msg);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  private void forwardMessageQuietly(EndpointActorMetaData actorMetaData, Object msg) {\n    if (actorMetaData != null) {\n      actorMetaData.actorRef.tell(msg, context().self());\n    }\n  }\n\n  private void processClusterUpdate(ClusterUpdateMessage message) {\n    for (Entry<EndpointObjectHash, LocalEndpointActorMetaData> entry :\n        localEndpointSessions.entrySet()) {\n      String globalActorNodeId = getGlobalEndpointActorNodeId(entry.getKey());\n      if (!globalActorNodeId.equals(entry.getValue().globalActorNodeId)) {\n        entry.getValue().globalActorNodeId = globalActorNodeId;\n        notifyGlobalEndpointActor(entry.getKey(), globalActorNodeId);\n      }\n    }\n    for (GlobalEndpointActorMetaData entry : globalEndpointSessions.values()) {\n      entry.actorRef.tell(message, context().self());\n    }\n  }\n\n  /**\n   * Process log event pack message.\n   *\n   * @param message the message\n   */\n  private void processLogEventPackMessage(LogEventPackMessage message) {\n    LOG.debug(\"[{}] Processing log event pack message\", appToken);\n    applicationLogActor.tell(message, self());\n  }\n\n  private void processUserVerificationRequestMessage(UserVerificationRequestMessage message) {\n    LOG.debug(\"[{}] Processing user verification request message\", appToken);\n    userVerifierActor.tell(message, self());\n  }\n\n  private void processLogNotificationMessage(ThriftNotificationMessage message) {\n    processThriftNotificationMessage(applicationLogActor, message);\n  }\n\n  private void processUserVerifierNotificationMessage(ThriftNotificationMessage message) {\n    processThriftNotificationMessage(userVerifierActor, message);\n  }\n\n  private void processThriftNotificationMessage(ActorRef actor, ThriftNotificationMessage message) {\n    LOG.debug(\"[{}] Processing thrift notification message {}\", appToken, message);\n    actor.tell(message, self());\n  }\n\n  private void processStatusRequest(StatusRequestMessage message) {\n    LOG.debug(\"[{}] Processing status request\", message.getId());\n    int endpointCount = localEndpointSessions.size();\n    context().parent()\n        .tell(new ApplicationActorStatusResponse(message.getId(), endpointCount),\n            ActorRef.noSender());\n  }\n\n  /**\n   * Process thrift notification.\n   *\n   * @param message the message\n   */\n  private void processThriftNotification(ThriftNotificationMessage message) {\n    Notification notification = message.getNotification();\n    if (notification.isSetNotificationId()) {\n      LOG.debug(\"[{}] Forwarding message to specific topic\", appToken);\n      sendToSpecificTopic(message);\n    } else if (notification.isSetAppenderId()) {\n      LOG.debug(\"[{}] Forwarding message to application log actor\", appToken);\n      processLogNotificationMessage(message);\n    } else if (notification.isSetUserVerifierToken()) {\n      LOG.debug(\"[{}] Forwarding message to application user verifier actor\", appToken);\n      processUserVerifierNotificationMessage(message);\n    } else {\n      LOG.debug(\"[{}] Broadcasting message to all endpoints\", appToken);\n      broadcastToAllEndpoints(message);\n    }\n  }\n\n  /**\n   * Send to specific topic.\n   *\n   * @param message the message\n   */\n  private void sendToSpecificTopic(ThriftNotificationMessage message) {\n    Notification notification = message.getNotification();\n    ActorRef topicActor = getOrCreateTopic(notification.getTopicId());\n    topicActor.tell(message, self());\n  }\n\n  /**\n   * Gets the or create topic.\n   *\n   * @param topicId the topic id\n   * @return the or create topic\n   */\n  private ActorRef getOrCreateTopic(String topicId) {\n    ActorRef topicActor = topicSessions.get(topicId);\n    if (topicActor == null) {\n      topicActor = context().actorOf(\n          Props.create(new TopicActor.ActorCreator(context.getNotificationDeltaService()))\n              .withDispatcher(TOPIC_DISPATCHER_NAME),\n          buildTopicKey(topicId)\n      );\n      topicSessions.put(topicId, topicActor);\n      context().watch(topicActor);\n    }\n    return topicActor;\n  }\n\n  /**\n   * Broadcast to all endpoints.\n   *\n   * @param message the message\n   */\n  private void broadcastToAllEndpoints(ThriftNotificationMessage message) {\n    for (LocalEndpointActorMetaData endpoint : localEndpointSessions.values()) {\n      endpoint.actorRef.tell(message, self());\n    }\n  }\n\n  /**\n   * Process endpoint aware message.\n   *\n   * @param message the message\n   */\n  private void processEndpointAwareMessage(EndpointAwareMessage message) {\n    if (message instanceof TopicSubscriptionMessage) {\n      processEndpointTopicRegistration((TopicSubscriptionMessage) message);\n    } else if (message instanceof EndpointUserConnectMessage) {\n      processEndpointUserRegistration((EndpointUserConnectMessage) message);\n    } else if (message instanceof EndpointUserDisconnectMessage) {\n      processEndpointUserDeregistration((EndpointUserDisconnectMessage) message);\n    } else if (message instanceof EndpointEventSendMessage) {\n      processEndpointEventSendMessage((EndpointEventSendMessage) message);\n    } else if (message instanceof EndpointEventReceiveMessage) {\n      processEndpointEventReceiveMessage((EndpointEventReceiveMessage) message);\n    } else {\n      processEndpointRequest(message);\n    }\n  }\n\n  /**\n   * Process endpoint aware message.\n   *\n   * @param message the message\n   */\n  private void processSessionAwareMessage(SessionAware message) {\n    LocalEndpointActorMetaData endpointMetaData = localEndpointSessions\n        .get(message.getSessionInfo().getKey());\n    if (endpointMetaData != null) {\n      endpointMetaData.actorRef.tell(message, self());\n    } else {\n      LOG.debug(\"[{}] Can't find endpoint actor that corresponds to {}\",\n          appToken, message.getSessionInfo().getKey());\n    }\n  }\n\n  private void processEndpointEventReceiveMessage(EndpointEventReceiveMessage message) {\n    LocalEndpointActorMetaData endpointActor = localEndpointSessions.get(message.getKey());\n    if (endpointActor != null) {\n      endpointActor.actorRef.tell(message, self());\n    } else {\n      LOG.debug(\"[{}] Can't find endpoint actor that corresponds to {}\",\n          appToken, message.getKey());\n      context().parent()\n          .tell(new EndpointEventDeliveryMessage(message, EventDeliveryStatus.FAILURE), self());\n    }\n  }\n\n  private void processEndpointEventSendMessage(EndpointEventSendMessage message) {\n    LOG.debug(\"[{}] Forwarding message to specific user\", appToken, message.getUserId());\n    context().parent().tell(message, self());\n  }\n\n  private void processEndpointEventDeliveryMessage(EndpointEventDeliveryMessage message) {\n    LOG.debug(\"[{}] Forwarding message to specific user\", appToken, message.getUserId());\n    context().parent().tell(message, self());\n  }\n\n  /**\n   * Process endpoint registration.\n   *\n   * @param message the message\n   */\n  private void processEndpointTopicRegistration(TopicSubscriptionMessage message) {\n    ActorRef topicActor = getOrCreateTopic(message.getTopicId());\n    topicActor.tell(message, self());\n  }\n\n  /**\n   * Process endpoint registration.\n   *\n   * @param message the message\n   */\n  private void processEndpointUserRegistration(EndpointUserConnectMessage message) {\n    context().parent().tell(message, self());\n  }\n\n  /**\n   * Process endpoint deregistration.\n   *\n   * @param message the message\n   */\n  private void processEndpointUserDeregistration(EndpointUserDisconnectMessage message) {\n    context().parent().tell(message, self());\n  }\n\n  /**\n   * Process session endpoint request.\n   *\n   * @param message the message\n   */\n  private void processEndpointRequest(EndpointAwareMessage message) {\n    LocalEndpointActorMetaData actorMetaData = localEndpointSessions.get(message.getKey());\n    if (actorMetaData == null) {\n      EndpointObjectHash endpointKey = message.getKey();\n      String endpointActorId = LocalEndpointActorCreator.generateActorKey();\n      LOG.debug(\"[{}] Creating actor with endpointKey: {}\", appToken, endpointActorId);\n      String globalActorNodeId = getGlobalEndpointActorNodeId(endpointKey);\n      actorMetaData = new LocalEndpointActorMetaData(context()\n          .actorOf(Props\n              .create(new LocalEndpointActorCreator(\n                  context,\n                  endpointActorId,\n                  message.getAppToken(),\n                  message.getKey()\n              )).withDispatcher(ENDPOINT_DISPATCHER_NAME), endpointActorId),\n          endpointActorId, globalActorNodeId);\n      localEndpointSessions.put(message.getKey(), actorMetaData);\n      endpointActorMap.put(endpointActorId, message.getKey());\n      context().watch(actorMetaData.actorRef);\n      notifyGlobalEndpointActor(endpointKey, globalActorNodeId);\n    }\n    actorMetaData.actorRef.tell(message, self());\n  }\n\n  private String getGlobalEndpointActorNodeId(EndpointObjectHash endpointKey) {\n    return context.getClusterService().getEntityNode(endpointKey);\n  }\n\n  private void notifyGlobalEndpointActor(EndpointObjectHash endpointKey, String globalActorNodeId) {\n    notifyGlobalEndpointActor(endpointKey, globalActorNodeId, RouteOperation.ADD);\n  }\n\n  private void notifyGlobalEndpointActor(EndpointObjectHash endpointKey,\n                                         String globalActorNodeId, RouteOperation operation) {\n    EndpointRouteMessage msg = new EndpointRouteMessage(\n        new EndpointClusterAddress(nodeId, tenantId, appToken, endpointKey), operation);\n    if (globalActorNodeId.equals(nodeId)) {\n      processEndpointRouteMessage(msg);\n    } else {\n      context.getClusterService().sendRouteMessage(msg);\n    }\n  }\n\n  private void processRouteMessage(RouteMessage<?> msg) {\n    if (msg instanceof EndpointRouteMessage) {\n      processEndpointRouteMessage((EndpointRouteMessage) msg);\n    }\n  }\n\n  private void processEndpointRouteMessage(EndpointRouteMessage msg) {\n    EndpointObjectHash endpointKey = msg.getAddress().getEndpointKey();\n    GlobalEndpointActorMetaData actorMetaData = globalEndpointSessions.get(endpointKey);\n    if (actorMetaData == null) {\n      String endpointActorId = GlobalEndpointActorCreator.generateActorKey();\n      LOG.debug(\"[{}] Creating global endpoint actor for endpointKey: {}\", appToken, endpointKey);\n      actorMetaData = new GlobalEndpointActorMetaData(\n          context().actorOf(Props.create(\n              new GlobalEndpointActorCreator(context, endpointActorId, appToken, endpointKey))\n              .withDispatcher(ENDPOINT_DISPATCHER_NAME), endpointActorId),\n          endpointActorId);\n      globalEndpointSessions.put(endpointKey, actorMetaData);\n      context().watch(actorMetaData.actorRef);\n    }\n    actorMetaData.actorRef.tell(msg, self());\n  }\n\n  private void processEndpointUserActionMessage(EndpointUserActionMessage message,\n                                                boolean escalate) {\n    LocalEndpointActorMetaData endpointMetaData = localEndpointSessions.get(message.getKey());\n    if (endpointMetaData != null) {\n      LOG.debug(\"[{}] Found affected endpoint and forwarding message to it\", appToken);\n      endpointMetaData.actorRef.tell(message, self());\n    } else if (escalate) {\n      LOG.debug(\"[{}] Failed to fing affected endpoint in scope of current application.\"\n          + \" Forwarding message to tenant actor\", appToken);\n      EndpointUserActionRouteMessage routeMessage =\n          new EndpointUserActionRouteMessage(message, appToken);\n      context().parent().tell(routeMessage, self());\n    }\n  }\n\n  private void updateEndpointActor(EndpointStopMessage message) {\n    String actorKey = message.getActorKey();\n    EndpointObjectHash endpointKey = message.getEndpointKey();\n    LOG.debug(\"[{}] Stoping actor [{}] with [{}]\", appToken, message.getActorKey(), endpointKey);\n    LocalEndpointActorMetaData endpointMetaData = localEndpointSessions.get(endpointKey);\n    if (endpointMetaData != null) {\n      if (actorKey.equals(endpointMetaData.actorId)) {\n        localEndpointSessions.remove(endpointKey);\n        LOG.debug(\"[{}] Removed actor [{}] from endpoint sessions map\", appToken, actorKey);\n      }\n    } else {\n      LOG.warn(\"[{}] EndpointSession for actor {} is not found!\", appToken, endpointKey);\n    }\n    endpointActorMap.remove(actorKey);\n    message.getOriginator().tell(message, self());\n  }\n\n  /**\n   * Process termination.\n   *\n   * @param message the message\n   */\n  private void processTermination(Terminated message) {\n    ActorRef terminated = message.actor();\n    if (terminated instanceof LocalActorRef) {\n      LocalActorRef localActor = (LocalActorRef) terminated;\n      String name = localActor.path().name();\n      EndpointObjectHash endpointHash = endpointActorMap.remove(name);\n      if (endpointHash != null) {\n        LocalEndpointActorMetaData actorMetaData = localEndpointSessions.get(endpointHash);\n        if (actorMetaData != null && actorMetaData.actorRef.equals(localActor)) {\n          localEndpointSessions.remove(endpointHash);\n          LOG.debug(\"[{}] removed endpoint: {}\", appToken, localActor);\n          notifyGlobalEndpointActor(endpointHash,\n              actorMetaData.globalActorNodeId, RouteOperation.DELETE);\n        }\n      } else if (topicSessions.remove(name) != null) {\n        LOG.debug(\"[{}] removed topic: {}\", appToken, localActor);\n      } else if (logsSessions.remove(name) != null) {\n        LOG.debug(\"[{}] removed log: {}\", appToken, localActor);\n        applicationLogActor = getOrCreateLogActor(name);\n        LOG.debug(\"[{}] created log: {}\", appToken, applicationLogActor);\n      } else if (userVerifierSessions.remove(name) != null) {\n        LOG.debug(\"[{}] removed log: {}\", appToken, localActor);\n        userVerifierActor = getOrCreateUserVerifierActor(name);\n        LOG.debug(\"[{}] created log: {}\", appToken, applicationLogActor);\n      }\n    } else {\n      LOG.warn(\"remove commands for remote actors are not supported yet!\");\n    }\n  }\n\n  private ActorRef getOrCreateLogActor() {\n    return getOrCreateLogActor(null);\n  }\n\n  private ActorRef getOrCreateLogActor(String name) {\n    ActorRef logActor = logsSessions.get(name);\n    if (logActor == null) {\n      logActor = context().actorOf(\n          Props.create(new ApplicationLogActor.ActorCreator(context, appToken))\n              .withDispatcher(LOG_DISPATCHER_NAME)\n      );\n      context().watch(logActor);\n      logsSessions.put(logActor.path().name(), logActor);\n    }\n    return logActor;\n  }\n\n  private ActorRef getOrCreateUserVerifierActor() {\n    return getOrCreateUserVerifierActor(null);\n  }\n\n  private ActorRef getOrCreateUserVerifierActor(String name) {\n    ActorRef userVerifierActor = userVerifierSessions.get(name);\n    if (userVerifierActor == null) {\n      userVerifierActor = context()\n          .actorOf(\n              Props.create(new ApplicationUserVerifierActor.ActorCreator(context, appToken))\n                  .withDispatcher(VERIFIER_DISPATCHER_NAME)\n          );\n      context().watch(userVerifierActor);\n      userVerifierSessions.put(userVerifierActor.path().name(), userVerifierActor);\n    }\n    return userVerifierActor;\n  }\n\n  /*\n   * (non-Javadoc)\n   *\n   * @see akka.actor.UntypedActor#preStart()\n   */\n  @Override\n  public void preStart() {\n    LOG.info(\"[{}] Starting \", appToken);\n  }\n\n  /*\n   * (non-Javadoc)\n   *\n   * @see akka.actor.UntypedActor#postStop()\n   */\n  @Override\n  public void postStop() {\n    LOG.info(\"[{}] Stoped \", appToken);\n  }\n\n\n  public static class ActorCreator implements Creator<ApplicationActor> {\n\n    private static final long serialVersionUID = 1L;\n\n    private final AkkaContext context;\n\n    private final String tenantId;\n\n    private final String appToken;\n\n    /**\n     * Instantiates a new actor creator.\n     *\n     * @param context  the context\n     * @param tenantId the tenant id\n     * @param appToken the application token\n     */\n    public ActorCreator(AkkaContext context, String tenantId, String appToken) {\n      super();\n      this.context = context;\n      this.tenantId = tenantId;\n      this.appToken = appToken;\n    }\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see akka.japi.Creator#create()\n     */\n    @Override\n    public ApplicationActor create() throws Exception {\n      return new ApplicationActor(context, tenantId, appToken);\n    }\n  }\n}", "class_id": 0, "repo": "myCustomDemo/kaa_demo", "file": "server/node/src/main/java/org/kaaproject/kaa/server/operations/service/akka/actors/core/ApplicationActor.java", "last_update_at": "2019-08-30T06:21:04+00:00", "question_id": "2265c1d4383d6d2de66da1a0deeeda03b46626c5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ApplicationActor extends UntypedActor {\n  private static final Logger LOG = LoggerFactory.getLogger(ApplicationActor.class);\n  private final AkkaContext context;\n  private final Map<EndpointObjectHash, GlobalEndpointActorMetaData> globalEndpointSessions;\n  /**\n   * The endpoint sessions.\n   */\n  private final Map<EndpointObjectHash, LocalEndpointActorMetaData> localEndpointSessions;\n  private final Map<String, EndpointObjectHash> endpointActorMap;\n  /**\n   * The topic sessions.\n   */\n  private final Map<String, ActorRef> topicSessions;\n  private final String nodeId;\n  private final String tenantId;\n  private final String appToken;\n  private final Map<String, ActorRef> logsSessions;\n  private final Map<String, ActorRef> userVerifierSessions;\n  private ActorRef applicationLogActor;\n  private ActorRef userVerifierActor;\n  /**\n   * Instantiates a new application actor.\n   *\n   * @param context          the context\n   * @param applicationToken the application token\n   */\n  private ApplicationActor(AkkaContext context, String tenantId, String applicationToken) {\n    this.context = context;\n    this.nodeId = context.getClusterService().getNodeId();\n    this.tenantId = tenantId;\n    this.appToken = applicationToken;\n    this.globalEndpointSessions = new HashMap<>();\n    this.localEndpointSessions = new HashMap<>();\n    this.endpointActorMap = new HashMap<>();\n    this.topicSessions = new HashMap<>();\n    this.logsSessions = new HashMap<>();\n    this.userVerifierSessions = new HashMap<>();\n    this.applicationLogActor = getOrCreateLogActor();\n    this.userVerifierActor = getOrCreateUserVerifierActor();\n  }\n  /**\n   * Builds the topic key.\n   *\n   * @param topicId the topic id\n   * @return the string\n   */\n  public static String buildTopicKey(String topicId) {\n    // TODO: Improve;\n    return topicId;\n  }\n  @Override\n  public SupervisorStrategy supervisorStrategy() {\n    return SupervisionStrategyFactory.createApplicationActorStrategy(context);\n  }\n  /*\n   * (non-Javadoc)\n   *\n   * @see akka.actor.UntypedActor#onReceive(java.lang.Object)\n   */\n  @Override\n  public void onReceive(Object message) throws Exception {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"[{}] Received: {}\", appToken, message);\n    } else {\n      LOG.debug(\"[{}] Received: {}\", appToken, message.getClass().getName());\n    }\n    if (message instanceof EndpointAwareMessage) {\n      processEndpointAwareMessage((EndpointAwareMessage) message);\n    }\n    if (message instanceof EndpointActorMsg) {\n      processEndpointActorMsg((EndpointActorMsg) message);\n    } else if (message instanceof SessionAware) {\n      processSessionAwareMessage((SessionAware) message);\n    } else if (message instanceof EndpointEventDeliveryMessage) {\n      processEndpointEventDeliveryMessage((EndpointEventDeliveryMessage) message);\n    } else if (message instanceof Terminated) {\n      processTermination((Terminated) message);\n    } else if (message instanceof ThriftNotificationMessage) {\n      processThriftNotification((ThriftNotificationMessage) message);\n    } else if (message instanceof EndpointStopMessage) {\n      updateEndpointActor((EndpointStopMessage) message);\n    } else if (message instanceof LogEventPackMessage) {\n      processLogEventPackMessage((LogEventPackMessage) message);\n    } else if (message instanceof UserVerificationRequestMessage) {\n      processUserVerificationRequestMessage((UserVerificationRequestMessage) message);\n    } else if (message instanceof EndpointUserActionMessage) {\n      processEndpointUserActionMessage((EndpointUserActionMessage) message, true);\n    } else if (message instanceof EndpointUserActionRouteMessage) {\n      processEndpointUserActionMessage(((EndpointUserActionRouteMessage) message).getMessage(),\n          false);\n    } else if (message instanceof StatusRequestMessage) {\n      processStatusRequest((StatusRequestMessage) message);\n    } else if (message instanceof ClusterUpdateMessage) {\n      processClusterUpdate((ClusterUpdateMessage) message);\n    } else if (message instanceof RouteMessage<?>) {\n      processRouteMessage((RouteMessage<?>) message);\n    }\n  }\n  private void processEndpointActorMsg(EndpointActorMsg message) {\n    EndpointAddress address = message.getAddress();\n    EndpointObjectHash endpointId = EndpointObjectHash.fromBytes(address.getEntityId());\n    ActorClassifier classifier = message.getClassifier();\n    if (classifier == ActorClassifier.APPLICATION) {\n      boolean processed = false;\n      if (message instanceof ThriftEndpointActorMsg<?>) {\n        processed = processCommonThriftEndpointActorMsg(\n            endpointId, (ThriftEndpointActorMsg<?>) message);\n      }\n      if (!processed) {\n        LOG.warn(\"[{}] Failed to lookup processor for endpoint msg {}.\", endpointId, message);\n      }\n    } else {\n      EndpointActorMetaData actorMetaData = null;\n      if (classifier == ActorClassifier.GLOBAL) {\n        actorMetaData = globalEndpointSessions.get(endpointId);\n      } else if (classifier == ActorClassifier.LOCAL) {\n        actorMetaData = localEndpointSessions.get(endpointId);\n      }\n      if (actorMetaData != null) {\n        actorMetaData.actorRef.tell(message, context().self());\n      } else {\n        LOG.warn(\"[{}] Failed to lookup {} actor for endpoint.\", endpointId, classifier.name());\n      }\n    }\n  }\n  private boolean processCommonThriftEndpointActorMsg(EndpointObjectHash endpointId,\n                                                      ThriftEndpointActorMsg<?> msg) {\n    if (msg.getMsg() instanceof ThriftEndpointDeregistrationMessage) {\n      forwardMessageQuietly(globalEndpointSessions.get(endpointId), msg);\n      forwardMessageQuietly(localEndpointSessions.get(endpointId), msg);\n      return true;\n    } else {\n      return false;\n    }\n  }\n  private void forwardMessageQuietly(EndpointActorMetaData actorMetaData, Object msg) {\n    if (actorMetaData != null) {\n      actorMetaData.actorRef.tell(msg, context().self());\n    }\n  }\n  private void processClusterUpdate(ClusterUpdateMessage message) {\n    for (Entry<EndpointObjectHash, LocalEndpointActorMetaData> entry :\n        localEndpointSessions.entrySet()) {\n      String globalActorNodeId = getGlobalEndpointActorNodeId(entry.getKey());\n      if (!globalActorNodeId.equals(entry.getValue().globalActorNodeId)) {\n        entry.getValue().globalActorNodeId = globalActorNodeId;\n        notifyGlobalEndpointActor(entry.getKey(), globalActorNodeId);\n      }\n    }\n    for (GlobalEndpointActorMetaData entry : globalEndpointSessions.values()) {\n      entry.actorRef.tell(message, context().self());\n    }\n  }\n  /**\n   * Process log event pack message.\n   *\n   * @param message the message\n   */\n  private void processLogEventPackMessage(LogEventPackMessage message) {\n    LOG.debug(\"[{}] Processing log event pack message\", appToken);\n    applicationLogActor.tell(message, self());\n  }\n  private void processUserVerificationRequestMessage(UserVerificationRequestMessage message) {\n    LOG.debug(\"[{}] Processing user verification request message\", appToken);\n    userVerifierActor.tell(message, self());\n  }\n  private void processLogNotificationMessage(ThriftNotificationMessage message) {\n    processThriftNotificationMessage(applicationLogActor, message);\n  }\n  private void processUserVerifierNotificationMessage(ThriftNotificationMessage message) {\n    processThriftNotificationMessage(userVerifierActor, message);\n  }\n  private void processThriftNotificationMessage(ActorRef actor, ThriftNotificationMessage message) {\n    LOG.debug(\"[{}] Processing thrift notification message {}\", appToken, message);\n    actor.tell(message, self());\n  }\n  private void processStatusRequest(StatusRequestMessage message) {\n    LOG.debug(\"[{}] Processing status request\", message.getId());\n    int endpointCount = localEndpointSessions.size();\n    context().parent()\n        .tell(new ApplicationActorStatusResponse(message.getId(), endpointCount),\n            ActorRef.noSender());\n  }\n  /**\n   * Process thrift notification.\n   *\n   * @param message the message\n   */\n  private void processThriftNotification(ThriftNotificationMessage message) {\n    Notification notification = message.getNotification();\n    if (notification.isSetNotificationId()) {\n      LOG.debug(\"[{}] Forwarding message to specific topic\", appToken);\n      sendToSpecificTopic(message);\n    } else if (notification.isSetAppenderId()) {\n      LOG.debug(\"[{}] Forwarding message to application log actor\", appToken);\n      processLogNotificationMessage(message);\n    } else if (notification.isSetUserVerifierToken()) {\n      LOG.debug(\"[{}] Forwarding message to application user verifier actor\", appToken);\n      processUserVerifierNotificationMessage(message);\n    } else {\n      LOG.debug(\"[{}] Broadcasting message to all endpoints\", appToken);\n      broadcastToAllEndpoints(message);\n    }\n  }\n  /**\n   * Send to specific topic.\n   *\n   * @param message the message\n   */\n  private void sendToSpecificTopic(ThriftNotificationMessage message) {\n    Notification notification = message.getNotification();\n    ActorRef topicActor = getOrCreateTopic(notification.getTopicId());\n    topicActor.tell(message, self());\n  }\n  /**\n   * Gets the or create topic.\n   *\n   * @param topicId the topic id\n   * @return the or create topic\n   */\n  private ActorRef getOrCreateTopic(String topicId) {\n    ActorRef topicActor = topicSessions.get(topicId);\n    if (topicActor == null) {\n      topicActor = context().actorOf(\n          Props.create(new TopicActor.ActorCreator(context.getNotificationDeltaService()))\n              .withDispatcher(TOPIC_DISPATCHER_NAME),\n          buildTopicKey(topicId)\n      );\n      topicSessions.put(topicId, topicActor);\n      context().watch(topicActor);\n    }\n    return topicActor;\n  }\n  /**\n   * Broadcast to all endpoints.\n   *\n   * @param message the message\n   */\n  private void broadcastToAllEndpoints(ThriftNotificationMessage message) {\n    for (LocalEndpointActorMetaData endpoint : localEndpointSessions.values()) {\n      endpoint.actorRef.tell(message, self());\n    }\n  }\n  /**\n   * Process endpoint aware message.\n   *\n   * @param message the message\n   */\n  private void processEndpointAwareMessage(EndpointAwareMessage message) {\n    if (message instanceof TopicSubscriptionMessage) {\n      processEndpointTopicRegistration((TopicSubscriptionMessage) message);\n    } else if (message instanceof EndpointUserConnectMessage) {\n      processEndpointUserRegistration((EndpointUserConnectMessage) message);\n    } else if (message instanceof EndpointUserDisconnectMessage) {\n      processEndpointUserDeregistration((EndpointUserDisconnectMessage) message);\n    } else if (message instanceof EndpointEventSendMessage) {\n      processEndpointEventSendMessage((EndpointEventSendMessage) message);\n    } else if (message instanceof EndpointEventReceiveMessage) {\n      processEndpointEventReceiveMessage((EndpointEventReceiveMessage) message);\n    } else {\n      processEndpointRequest(message);\n    }\n  }\n  /**\n   * Process endpoint aware message.\n   *\n   * @param message the message\n   */\n  private void processSessionAwareMessage(SessionAware message) {\n    LocalEndpointActorMetaData endpointMetaData = localEndpointSessions\n        .get(message.getSessionInfo().getKey());\n    if (endpointMetaData != null) {\n      endpointMetaData.actorRef.tell(message, self());\n    } else {\n      LOG.debug(\"[{}] Can't find endpoint actor that corresponds to {}\",\n          appToken, message.getSessionInfo().getKey());\n    }\n  }\n  private void processEndpointEventReceiveMessage(EndpointEventReceiveMessage message) {\n    LocalEndpointActorMetaData endpointActor = localEndpointSessions.get(message.getKey());\n    if (endpointActor != null) {\n      endpointActor.actorRef.tell(message, self());\n    } else {\n      LOG.debug(\"[{}] Can't find endpoint actor that corresponds to {}\",\n          appToken, message.getKey());\n      context().parent()\n          .tell(new EndpointEventDeliveryMessage(message, EventDeliveryStatus.FAILURE), self());\n    }\n  }\n  private void processEndpointEventSendMessage(EndpointEventSendMessage message) {\n    LOG.debug(\"[{}] Forwarding message to specific user\", appToken, message.getUserId());\n    context().parent().tell(message, self());\n  }\n  private void processEndpointEventDeliveryMessage(EndpointEventDeliveryMessage message) {\n    LOG.debug(\"[{}] Forwarding message to specific user\", appToken, message.getUserId());\n    context().parent().tell(message, self());\n  }\n  /**\n   * Process endpoint registration.\n   *\n   * @param message the message\n   */\n  private void processEndpointTopicRegistration(TopicSubscriptionMessage message) {\n    ActorRef topicActor = getOrCreateTopic(message.getTopicId());\n    topicActor.tell(message, self());\n  }\n  /**\n   * Process endpoint registration.\n   *\n   * @param message the message\n   */\n  private void processEndpointUserRegistration(EndpointUserConnectMessage message) {\n    context().parent().tell(message, self());\n  }\n  /**\n   * Process endpoint deregistration.\n   *\n   * @param message the message\n   */\n  private void processEndpointUserDeregistration(EndpointUserDisconnectMessage message) {\n    context().parent().tell(message, self());\n  }\n  /**\n   * Process session endpoint request.\n   *\n   * @param message the message\n   */\n  private void processEndpointRequest(EndpointAwareMessage message) {\n    LocalEndpointActorMetaData actorMetaData = localEndpointSessions.get(message.getKey());\n    if (actorMetaData == null) {\n      EndpointObjectHash endpointKey = message.getKey();\n      String endpointActorId = LocalEndpointActorCreator.generateActorKey();\n      LOG.debug(\"[{}] Creating actor with endpointKey: {}\", appToken, endpointActorId);\n      String globalActorNodeId = getGlobalEndpointActorNodeId(endpointKey);\n      actorMetaData = new LocalEndpointActorMetaData(context()\n          .actorOf(Props\n              .create(new LocalEndpointActorCreator(\n                  context,\n                  endpointActorId,\n                  message.getAppToken(),\n                  message.getKey()\n              )).withDispatcher(ENDPOINT_DISPATCHER_NAME), endpointActorId),\n          endpointActorId, globalActorNodeId);\n      localEndpointSessions.put(message.getKey(), actorMetaData);\n      endpointActorMap.put(endpointActorId, message.getKey());\n      context().watch(actorMetaData.actorRef);\n      notifyGlobalEndpointActor(endpointKey, globalActorNodeId);\n    }\n    actorMetaData.actorRef.tell(message, self());\n  }\n  private String getGlobalEndpointActorNodeId(EndpointObjectHash endpointKey) {\n    return context.getClusterService().getEntityNode(endpointKey);\n  }\n  private void notifyGlobalEndpointActor(EndpointObjectHash endpointKey, String globalActorNodeId) {\n    notifyGlobalEndpointActor(endpointKey, globalActorNodeId, RouteOperation.ADD);\n  }\n  private void notifyGlobalEndpointActor(EndpointObjectHash endpointKey,\n                                         String globalActorNodeId, RouteOperation operation) {\n    EndpointRouteMessage msg = new EndpointRouteMessage(\n        new EndpointClusterAddress(nodeId, tenantId, appToken, endpointKey), operation);\n    if (globalActorNodeId.equals(nodeId)) {\n      processEndpointRouteMessage(msg);\n    } else {\n      context.getClusterService().sendRouteMessage(msg);\n    }\n  }\n  private void processRouteMessage(RouteMessage<?> msg) {\n    if (msg instanceof EndpointRouteMessage) {\n      processEndpointRouteMessage((EndpointRouteMessage) msg);\n    }\n  }\n  private void processEndpointRouteMessage(EndpointRouteMessage msg) {\n    EndpointObjectHash endpointKey = msg.getAddress().getEndpointKey();\n    GlobalEndpointActorMetaData actorMetaData = globalEndpointSessions.get(endpointKey);\n    if (actorMetaData == null) {\n      String endpointActorId = GlobalEndpointActorCreator.generateActorKey();\n      LOG.debug(\"[{}] Creating global endpoint actor for endpointKey: {}\", appToken, endpointKey);\n      actorMetaData = new GlobalEndpointActorMetaData(\n          context().actorOf(Props.create(\n              new GlobalEndpointActorCreator(context, endpointActorId, appToken, endpointKey))\n              .withDispatcher(ENDPOINT_DISPATCHER_NAME), endpointActorId),\n          endpointActorId);\n      globalEndpointSessions.put(endpointKey, actorMetaData);\n      context().watch(actorMetaData.actorRef);\n    }\n    actorMetaData.actorRef.tell(msg, self());\n  }\n  private void processEndpointUserActionMessage(EndpointUserActionMessage message,\n                                                boolean escalate) {\n    LocalEndpointActorMetaData endpointMetaData = localEndpointSessions.get(message.getKey());\n    if (endpointMetaData != null) {\n      LOG.debug(\"[{}] Found affected endpoint and forwarding message to it\", appToken);\n      endpointMetaData.actorRef.tell(message, self());\n    } else if (escalate) {\n      LOG.debug(\"[{}] Failed to fing affected endpoint in scope of current application.\"\n          + \" Forwarding message to tenant actor\", appToken);\n      EndpointUserActionRouteMessage routeMessage =\n          new EndpointUserActionRouteMessage(message, appToken);\n      context().parent().tell(routeMessage, self());\n    }\n  }\n  private void updateEndpointActor(EndpointStopMessage message) {\n    String actorKey = message.getActorKey();\n    EndpointObjectHash endpointKey = message.getEndpointKey();\n    LOG.debug(\"[{}] Stoping actor [{}] with [{}]\", appToken, message.getActorKey(), endpointKey);\n    LocalEndpointActorMetaData endpointMetaData = localEndpointSessions.get(endpointKey);\n    if (endpointMetaData != null) {\n      if (actorKey.equals(endpointMetaData.actorId)) {\n        localEndpointSessions.remove(endpointKey);\n        LOG.debug(\"[{}] Removed actor [{}] from endpoint sessions map\", appToken, actorKey);\n      }\n    } else {\n      LOG.warn(\"[{}] EndpointSession for actor {} is not found!\", appToken, endpointKey);\n    }\n    endpointActorMap.remove(actorKey);\n    message.getOriginator().tell(message, self());\n  }\n  /**\n   * Process termination.\n   *\n   * @param message the message\n   */\n  private void processTermination(Terminated message) {\n    ActorRef terminated = message.actor();\n    if (terminated instanceof LocalActorRef) {\n      LocalActorRef localActor = (LocalActorRef) terminated;\n      String name = localActor.path().name();\n      EndpointObjectHash endpointHash = endpointActorMap.remove(name);\n      if (endpointHash != null) {\n        LocalEndpointActorMetaData actorMetaData = localEndpointSessions.get(endpointHash);\n        if (actorMetaData != null && actorMetaData.actorRef.equals(localActor)) {\n          localEndpointSessions.remove(endpointHash);\n          LOG.debug(\"[{}] removed endpoint: {}\", appToken, localActor);\n          notifyGlobalEndpointActor(endpointHash,\n              actorMetaData.globalActorNodeId, RouteOperation.DELETE);\n        }\n      } else if (topicSessions.remove(name) != null) {\n        LOG.debug(\"[{}] removed topic: {}\", appToken, localActor);\n      } else if (logsSessions.remove(name) != null) {\n        LOG.debug(\"[{}] removed log: {}\", appToken, localActor);\n        applicationLogActor = getOrCreateLogActor(name);\n        LOG.debug(\"[{}] created log: {}\", appToken, applicationLogActor);\n      } else if (userVerifierSessions.remove(name) != null) {\n        LOG.debug(\"[{}] removed log: {}\", appToken, localActor);\n        userVerifierActor = getOrCreateUserVerifierActor(name);\n        LOG.debug(\"[{}] created log: {}\", appToken, applicationLogActor);\n      }\n    } else {\n      LOG.warn(\"remove commands for remote actors are not supported yet!\");\n    }\n  }\n  private ActorRef getOrCreateLogActor() {\n    return getOrCreateLogActor(null);\n  }\n  private ActorRef getOrCreateLogActor(String name) {\n    ActorRef logActor = logsSessions.get(name);\n    if (logActor == null) {\n      logActor = context().actorOf(\n          Props.create(new ApplicationLogActor.ActorCreator(context, appToken))\n              .withDispatcher(LOG_DISPATCHER_NAME)\n      );\n      context().watch(logActor);\n      logsSessions.put(logActor.path().name(), logActor);\n    }\n    return logActor;\n  }\n  private ActorRef getOrCreateUserVerifierActor() {\n    return getOrCreateUserVerifierActor(null);\n  }\n  private ActorRef getOrCreateUserVerifierActor(String name) {\n    ActorRef userVerifierActor = userVerifierSessions.get(name);\n    if (userVerifierActor == null) {\n      userVerifierActor = context()\n          .actorOf(\n              Props.create(new ApplicationUserVerifierActor.ActorCreator(context, appToken))\n                  .withDispatcher(VERIFIER_DISPATCHER_NAME)\n          );\n      context().watch(userVerifierActor);\n      userVerifierSessions.put(userVerifierActor.path().name(), userVerifierActor);\n    }\n    return userVerifierActor;\n  }\n  /*\n   * (non-Javadoc)\n   *\n   * @see akka.actor.UntypedActor#preStart()\n   */\n  @Override\n  public void preStart() {\n    LOG.info(\"[{}] Starting \", appToken);\n  }\n  /*\n   * (non-Javadoc)\n   *\n   * @see akka.actor.UntypedActor#postStop()\n   */\n  @Override\n  public void postStop() {\n    LOG.info(\"[{}] Stoped \", appToken);\n  }\n  public static class ActorCreator implements Creator<ApplicationActor> {\n    private static final long serialVersionUID = 1L;\n    private final AkkaContext context;\n    private final String tenantId;\n    private final String appToken;\n    /**\n     * Instantiates a new actor creator.\n     *\n     * @param context  the context\n     * @param tenantId the tenant id\n     * @param appToken the application token\n     */\n    public ActorCreator(AkkaContext context, String tenantId, String appToken) {\n      super();\n      this.context = context;\n      this.tenantId = tenantId;\n      this.appToken = appToken;\n    }\n    /*\n     * (non-Javadoc)\n     *\n     * @see akka.japi.Creator#create()\n     */\n    @Override\n    public ApplicationActor create() throws Exception {\n      return new ApplicationActor(context, tenantId, appToken);\n    }\n  }\n"]]}
{"hexsha": "7f98e684b1d2a1fb9e78c9bd66c9d22a1bdc2ef2", "ext": "java", "lang": "Java", "content": "class X {\n    void f() {\n        int i = 2;\n        // begin\n        int o = 0; //mid\n        // end\n    }\n}", "class_id": 0, "repo": "teddywest32/intellij-community", "file": "java/java-tests/testData/codeInsight/daemonCodeAnalyzer/quickFix/simplifyBooleanExpression/after5.java", "last_update_at": "2019-08-17T10:07:23+00:00", "question_id": "7f98e684b1d2a1fb9e78c9bd66c9d22a1bdc2ef2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class X {\n    void f() {\n        int i = 2;\n        // begin\n        int o = 0; //mid\n        // end\n    }\n"]]}
{"hexsha": "c0a47a79a9167e9c1f9c8a1dd735ddf95c431a83", "ext": "java", "lang": "Java", "content": "public class ServerControlWrapperUnitTest extends TestBase\n{\n    @Test\n    public void testEquality () throws Exception\n    {\n        TransactionFactoryImple imple = new TransactionFactoryImple(\"test\");\n        ControlImple tx = imple.createLocal(1000);\n        \n        ServerControlWrapper wrap1 = new ServerControlWrapper(tx);\n        ServerControlWrapper wrap2 = new ServerControlWrapper(tx.getControl());\n        \n        assertTrue(wrap1.get_uid().equals(wrap2.get_uid()));\n        \n        wrap1 = new ServerControlWrapper(tx.getControl(), tx);\n        wrap2 = new ServerControlWrapper(tx.getControl(), tx.get_uid());\n        \n        assertTrue(wrap1.get_uid().equals(wrap2.get_uid()));\n    }\n    \n    @Test\n    public void testNested () throws Exception\n    {\n        TransactionFactoryImple imple = new TransactionFactoryImple(\"test\");\n        ControlImple tx = imple.createLocal(1000);\n        \n        ServerControlWrapper wrap = new ServerControlWrapper(tx);\n        ControlWrapper sub = wrap.create_subtransaction();\n        \n        assertTrue(sub != null);\n        \n        assertEquals(sub.cancel(), ActionStatus.ABORTED);\n    }\n}", "class_id": 0, "repo": "nmcl/wfswarm-example-arjuna-old", "file": "graalvm/transactions/fork/narayana/ArjunaJTS/jts/tests/classes/com/hp/mwtests/ts/jts/interposition/ServerControlWrapperUnitTest.java", "last_update_at": "2019-05-23T18:19:26+00:00", "question_id": "c0a47a79a9167e9c1f9c8a1dd735ddf95c431a83", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ServerControlWrapperUnitTest extends TestBase\n{\n    @Test\n    public void testEquality () throws Exception\n    {\n        TransactionFactoryImple imple = new TransactionFactoryImple(\"test\");\n        ControlImple tx = imple.createLocal(1000);\n        ServerControlWrapper wrap1 = new ServerControlWrapper(tx);\n        ServerControlWrapper wrap2 = new ServerControlWrapper(tx.getControl());\n        assertTrue(wrap1.get_uid().equals(wrap2.get_uid()));\n        wrap1 = new ServerControlWrapper(tx.getControl(), tx);\n        wrap2 = new ServerControlWrapper(tx.getControl(), tx.get_uid());\n        assertTrue(wrap1.get_uid().equals(wrap2.get_uid()));\n    }\n    @Test\n    public void testNested () throws Exception\n    {\n        TransactionFactoryImple imple = new TransactionFactoryImple(\"test\");\n        ControlImple tx = imple.createLocal(1000);\n        ServerControlWrapper wrap = new ServerControlWrapper(tx);\n        ControlWrapper sub = wrap.create_subtransaction();\n        assertTrue(sub != null);\n        assertEquals(sub.cancel(), ActionStatus.ABORTED);\n    }\n"]]}
{"hexsha": "79f22dfde110f798d07d95958a9d86776c9445c5", "ext": "java", "lang": "Java", "content": "public class BrickWall {\n    public int leastBricks(List<List<Integer>> wall) {\n        int max = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        for (List<Integer> wa : wall) {\n            int sum = 0;\n            for (int i=0;i<wa.size()-1;i++) {\n                sum += wa.get(i);\n                map.put(sum, map.getOrDefault(sum, 0) + 1);\n                max = Math.max(max, map.get(sum));\n            }\n\n        }\n        return wall.size() - max;\n    }\n}", "class_id": 0, "repo": "Kevin-SJW/Enterprise-programming-exercises", "file": "ClassificationTraining/huaweiMiddle/BrickWall.java", "last_update_at": "2019-05-12T11:17:57+00:00", "question_id": "79f22dfde110f798d07d95958a9d86776c9445c5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BrickWall {\n    public int leastBricks(List<List<Integer>> wall) {\n        int max = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        for (List<Integer> wa : wall) {\n            int sum = 0;\n            for (int i=0;i<wa.size()-1;i++) {\n                sum += wa.get(i);\n                map.put(sum, map.getOrDefault(sum, 0) + 1);\n                max = Math.max(max, map.get(sum));\n            }\n        }\n        return wall.size() - max;\n    }\n"]]}
{"hexsha": "7f4ccdfaf3954b9021e497b88b35eab452862541", "ext": "java", "lang": "Java", "content": "public class DataDisjunctionTest {\n\n\tpublic static void main(String[] args) {\n\t\tIntegerDataArray a1 = new IntegerDataArray(new Integer[]{1, 5, 7, 11, 15});\n\t\tIntegerDataArray a2 = new IntegerDataArray(new Integer[]{2, 3, 5, 11});\n\t\tIntegerDataArray a3 = new IntegerDataArray(new Integer[]{5, 11, 12 });\n\t\tIntegerDataArray a4 = new IntegerDataArray(new Integer[]{1, 3, 5});\n\t\tIntegerDataArray a5 = new IntegerDataArray(new Integer[]{5, 7, 11});\n\t\t\n\t\tDataDisjunction disjunction = new DataDisjunction(new IDataArray[]{a1, a2, a3, a4, a5}, 4);\n\t\t\n//\t\tSystem.out.println(\"advance : \" + disjunction.advance(11));\n\t\t\n\t\tlong data = -1;\n\t\tlong begin = System.nanoTime();\n\t\twhile((data = disjunction.nextDoc()) != IDataArray.NO_MORE_DATA) {\n\t\t\tSystem.out.println(data);\n\t\t}\n\t\tSystem.out.println(\"cost : \" + (System.nanoTime() - begin) / (float) 1000000 + \" ms\");\n\t}\n}", "class_id": 0, "repo": "zilongTong/algorithm", "file": "geek-Arithmetics/src/main/java/list/conbain/test/DataDisjunctionTest.java", "last_update_at": "2019-06-12T04:02:04+00:00", "question_id": "7f4ccdfaf3954b9021e497b88b35eab452862541", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DataDisjunctionTest {\n\tpublic static void main(String[] args) {\n\t\tIntegerDataArray a1 = new IntegerDataArray(new Integer[]{1, 5, 7, 11, 15});\n\t\tIntegerDataArray a2 = new IntegerDataArray(new Integer[]{2, 3, 5, 11});\n\t\tIntegerDataArray a3 = new IntegerDataArray(new Integer[]{5, 11, 12 });\n\t\tIntegerDataArray a4 = new IntegerDataArray(new Integer[]{1, 3, 5});\n\t\tIntegerDataArray a5 = new IntegerDataArray(new Integer[]{5, 7, 11});\n\t\t\n\t\tDataDisjunction disjunction = new DataDisjunction(new IDataArray[]{a1, a2, a3, a4, a5}, 4);\n\t\t\n//\t\tSystem.out.println(\"advance : \" + disjunction.advance(11));\n\t\t\n\t\tlong data = -1;\n\t\tlong begin = System.nanoTime();\n\t\twhile((data = disjunction.nextDoc()) != IDataArray.NO_MORE_DATA) {\n\t\t\tSystem.out.println(data);\n\t\t}\n\t\tSystem.out.println(\"cost : \" + (System.nanoTime() - begin) / (float) 1000000 + \" ms\");\n\t}\n"]]}
{"hexsha": "7513219d7c6dde893ed257c76940124088489ab7", "ext": "java", "lang": "Java", "content": "public class LineEventDisruptor {\n\n    public Disruptor<LineEvent> create(ThreadFactory threadFactory,\n                                       ColumnType[] types,\n                                       ChLineEventHandler clickhouseHandler) {\n        final int threads = typesCount(types);\n\n        EventFactory<LineEvent> factory = () -> new LineEvent(threads);\n\n        // Specify the size of the ring buffer, must be power of 2.\n        int bufferSize = getRingBufferSize();\n\n        // Construct the Disruptor\n        Disruptor<LineEvent> disruptor =\n                new Disruptor<>(factory, bufferSize, threadFactory,\n                        getProducerType(), getWaitStrategy());\n\n        // Connect the handler\n        final EventHandler<LineEvent>[] parseHandlers = getParseHandlers(types);\n        if (parseHandlers.length > 0) {\n            disruptor\n                    .handleEventsWith(parseHandlers)\n                    .then(clickhouseHandler);\n        } else {\n            throw new IllegalArgumentException(\"Nothing to parse\");\n        }\n\n        disruptor.start();\n\n        return disruptor;\n    }\n\n    protected int getRingBufferSize() {\n        return 1024 * 32;\n    }\n\n    protected WaitStrategy getWaitStrategy() {\n        return new SleepingWaitStrategy();\n    }\n\n    protected ProducerType getProducerType() {\n        return ProducerType.SINGLE;\n    }\n\n    public static int typesCount(ColumnType[] types) {\n        return Arrays.stream(types).collect(Collectors.toSet()).size();\n    }\n\n    public static EventHandler<LineEvent>[] getParseHandlers(ColumnType[] types) {\n        Set<ColumnType> typeSet = Arrays.stream(types).collect(Collectors.toSet());\n        List<EventHandler<LineEvent>> handlers = new ArrayList<>();\n        int id = 0;\n        for (ColumnType type : typeSet) {\n            switch (type) {\n                case INT_32:\n                    handlers.add(new IntegerValidation(id++,\n                            ParsePacketCsvDisruptor.typeColumns(types, ColumnType.INT_32)));\n                    break;\n                case DOUBLE:\n                    handlers.add(new DoubleValidation(id++,\n                            ParsePacketCsvDisruptor.typeColumns(types, ColumnType.DOUBLE)));\n                    break;\n                case LOCAL_DATE:\n                    throw new NotImplementedException(\"LOCAL_DATE\");\n                case SQL_DATE:\n                    handlers.add(new SqlDateValidation(id++,\n                            ParsePacketCsvDisruptor.typeColumns(types, ColumnType.SQL_DATE)));\n                    break;\n            }\n        }\n        EventHandler<LineEvent>[] result = new EventHandler[handlers.size()];\n        for (int i = 0; i < handlers.size(); ++i) result[i] = handlers.get(i);\n        return result;\n    }\n\n\n}", "class_id": 0, "repo": "egorlitvinenko/testparsing", "file": "testdisruptor/src/main/java/org/egorlitvinenko/testdisruptor/clickhousestream/disruptor/LineEventDisruptor.java", "last_update_at": "2019-02-21T16:09:33+00:00", "question_id": "7513219d7c6dde893ed257c76940124088489ab7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LineEventDisruptor {\n    public Disruptor<LineEvent> create(ThreadFactory threadFactory,\n                                       ColumnType[] types,\n                                       ChLineEventHandler clickhouseHandler) {\n        final int threads = typesCount(types);\n        EventFactory<LineEvent> factory = () -> new LineEvent(threads);\n        // Specify the size of the ring buffer, must be power of 2.\n        int bufferSize = getRingBufferSize();\n        // Construct the Disruptor\n        Disruptor<LineEvent> disruptor =\n                new Disruptor<>(factory, bufferSize, threadFactory,\n                        getProducerType(), getWaitStrategy());\n        // Connect the handler\n        final EventHandler<LineEvent>[] parseHandlers = getParseHandlers(types);\n        if (parseHandlers.length > 0) {\n            disruptor\n                    .handleEventsWith(parseHandlers)\n                    .then(clickhouseHandler);\n        } else {\n            throw new IllegalArgumentException(\"Nothing to parse\");\n        }\n        disruptor.start();\n        return disruptor;\n    }\n    protected int getRingBufferSize() {\n        return 1024 * 32;\n    }\n    protected WaitStrategy getWaitStrategy() {\n        return new SleepingWaitStrategy();\n    }\n    protected ProducerType getProducerType() {\n        return ProducerType.SINGLE;\n    }\n    public static int typesCount(ColumnType[] types) {\n        return Arrays.stream(types).collect(Collectors.toSet()).size();\n    }\n    public static EventHandler<LineEvent>[] getParseHandlers(ColumnType[] types) {\n        Set<ColumnType> typeSet = Arrays.stream(types).collect(Collectors.toSet());\n        List<EventHandler<LineEvent>> handlers = new ArrayList<>();\n        int id = 0;\n        for (ColumnType type : typeSet) {\n            switch (type) {\n                case INT_32:\n                    handlers.add(new IntegerValidation(id++,\n                            ParsePacketCsvDisruptor.typeColumns(types, ColumnType.INT_32)));\n                    break;\n                case DOUBLE:\n                    handlers.add(new DoubleValidation(id++,\n                            ParsePacketCsvDisruptor.typeColumns(types, ColumnType.DOUBLE)));\n                    break;\n                case LOCAL_DATE:\n                    throw new NotImplementedException(\"LOCAL_DATE\");\n                case SQL_DATE:\n                    handlers.add(new SqlDateValidation(id++,\n                            ParsePacketCsvDisruptor.typeColumns(types, ColumnType.SQL_DATE)));\n                    break;\n            }\n        }\n        EventHandler<LineEvent>[] result = new EventHandler[handlers.size()];\n        for (int i = 0; i < handlers.size(); ++i) result[i] = handlers.get(i);\n        return result;\n    }\n"]]}
{"hexsha": "65fae0c076d5b89cfee5e25f05834c7db68f592d", "ext": "java", "lang": "Java", "content": "public class Wizard {\n\n    /*\n     * telport:\n     *\tBamf the hero someplace else\n     */\n    public static void teleport(Player player) {\n        AbstractCoordinate c = new Coordinate();\n\n        Display.mvaddch(player.getPosition(), Pack.floor_at().getValue());\n        DrawRoom.find_floor(null, c, false, true);\n        if (!Chase.roomin(c).equals(player.getRoom())) {\n            Rooms.leave_room(player.getPosition());\n            player.setPosition(c);\n            Rooms.enter_room(player.getPosition());\n        } else {\n            player.setPosition(c);\n            Misc.look(true);\n        }\n        Display.mvaddch(player.getPosition(), ObjectType.PLAYER.getValue());\n        /*\n         * turn off ISHELD in case teleportation was done while fighting\n         * a Flytrap\n         */\n        if (player.containsState(StateEnum.ISHELD)) {\n\n            player.removeState(StateEnum.ISHELD);\n            Global.vf_hit = 0;\n            for (OriginalMonster mp : Global.mlist) {\n                if (mp.getType() == 'F')\n                    mp.getStatus().s_dmg = \"0x0\";\n            }\n        }\n        Global.no_move = 0;\n        Global.count = 0;\n        Global.running = false;\n        Mach_dep.flush_type();\n    }\n\n    /*\n     * whatIs:\n     *\tWhat a certin object is\n     */\n    public static void whatIs(Player player, boolean insist, int type) {\n\n        if (player.getBaggageSize() == 0) {\n            IOUtil.msg(\"you don't have anything in your pack to identify\");\n            return;\n        }\n\n        Thing obj;\n        for (; ; ) {\n            obj = Pack.get_item(\"identify\", ObjectType.get((char) type));\n            if (insist) {\n                if (Global.n_objs == 0) {\n                    return;\n                } else if (obj == null) {\n                    IOUtil.msg(\"you must identify something\");\n                } else if (type != 0 && obj.getDisplay().getValue() != type &&\n                        !(type == Const.R_OR_S && (obj instanceof Ring || obj instanceof Stick))) {\n                    IOUtil.msg(\"you must identify a %s\", type_name(type));\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        if (obj == null) {\n            return;\n        }\n\n        if (obj instanceof Scroll) {\n            set_know(obj, Global.scr_info);\n        } else if (obj instanceof Potion) {\n            set_know(obj, Global.pot_info);\n        } else if (obj instanceof Stick) {\n            set_know(obj, Global.ws_info);\n        } else if (obj instanceof Weapon || obj instanceof Armor) {\n            obj.add_o_flags(Const.ISKNOW);\n        } else if (obj instanceof Ring) {\n            set_know(obj, Global.ring_info);\n        }\n        IOUtil.msg(ThingMethod.inventoryName(obj, false));\n    }\n\n    /*\n     * set_know:\n     *\tSet things up when we really know what a thing is\n     */\n    private static void set_know(Thing obj, Obj_info[] info) {\n        info[obj.getNumber()].know();\n        obj.add_o_flags(Const.ISKNOW);\n    }\n\n    /*\n     * type_name:\n     *\tReturn a pointer to the name of the type\n     */\n    static String type_name(int type) {\n        List<Help_list> tlist = new ArrayList<>();\n        {\n            Help_list h = new Help_list(ObjectType.POTION.getValue(), \"potion\", false);\n            tlist.add(h);\n        }\n        {\n            Help_list h = new Help_list(ObjectType.SCROLL.getValue(), \"scroll\", false);\n            tlist.add(h);\n        }\n        {\n            Help_list h = new Help_list(ObjectType.FOOD.getValue(), \"food\", false);\n            tlist.add(h);\n        }\n        {\n            Help_list h = new Help_list((char) Const.R_OR_S, \"ring, wand or staff\", false);\n            tlist.add(h);\n        }\n        {\n            Help_list h = new Help_list(ObjectType.RING.getValue(), \"ring\", false);\n            tlist.add(h);\n        }\n        {\n            Help_list h = new Help_list(ObjectType.STICK.getValue(), \"wand or staff\", false);\n            tlist.add(h);\n        }\n        {\n            Help_list h = new Help_list(ObjectType.WEAPON.getValue(), \"weapon\", false);\n            tlist.add(h);\n        }\n        {\n            Help_list h = new Help_list(ObjectType.ARMOR.getValue(), \"suit of armor\", false);\n            tlist.add(h);\n        }\n\n        for (Help_list hp : tlist) {\n            if (type == hp.h_ch) {\n                return hp.h_desc;\n            }\n        }\n        /* NOTREACHED */\n        return \"\";\n    }\n\n\n}", "class_id": 0, "repo": "yamanakahirofumi/RogueInJava", "file": "src/main/java/org/hiro/Wizard.java", "last_update_at": "2019-01-09T18:44:31+00:00", "question_id": "65fae0c076d5b89cfee5e25f05834c7db68f592d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Wizard {\n    /*\n     * telport:\n     *\tBamf the hero someplace else\n     */\n    public static void teleport(Player player) {\n        AbstractCoordinate c = new Coordinate();\n        Display.mvaddch(player.getPosition(), Pack.floor_at().getValue());\n        DrawRoom.find_floor(null, c, false, true);\n        if (!Chase.roomin(c).equals(player.getRoom())) {\n            Rooms.leave_room(player.getPosition());\n            player.setPosition(c);\n            Rooms.enter_room(player.getPosition());\n        } else {\n            player.setPosition(c);\n            Misc.look(true);\n        }\n        Display.mvaddch(player.getPosition(), ObjectType.PLAYER.getValue());\n        /*\n         * turn off ISHELD in case teleportation was done while fighting\n         * a Flytrap\n         */\n        if (player.containsState(StateEnum.ISHELD)) {\n            player.removeState(StateEnum.ISHELD);\n            Global.vf_hit = 0;\n            for (OriginalMonster mp : Global.mlist) {\n                if (mp.getType() == 'F')\n                    mp.getStatus().s_dmg = \"0x0\";\n            }\n        }\n        Global.no_move = 0;\n        Global.count = 0;\n        Global.running = false;\n        Mach_dep.flush_type();\n    }\n    /*\n     * whatIs:\n     *\tWhat a certin object is\n     */\n    public static void whatIs(Player player, boolean insist, int type) {\n        if (player.getBaggageSize() == 0) {\n            IOUtil.msg(\"you don't have anything in your pack to identify\");\n            return;\n        }\n        Thing obj;\n        for (; ; ) {\n            obj = Pack.get_item(\"identify\", ObjectType.get((char) type));\n            if (insist) {\n                if (Global.n_objs == 0) {\n                    return;\n                } else if (obj == null) {\n                    IOUtil.msg(\"you must identify something\");\n                } else if (type != 0 && obj.getDisplay().getValue() != type &&\n                        !(type == Const.R_OR_S && (obj instanceof Ring || obj instanceof Stick))) {\n                    IOUtil.msg(\"you must identify a %s\", type_name(type));\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n        if (obj == null) {\n            return;\n        }\n        if (obj instanceof Scroll) {\n            set_know(obj, Global.scr_info);\n        } else if (obj instanceof Potion) {\n            set_know(obj, Global.pot_info);\n        } else if (obj instanceof Stick) {\n            set_know(obj, Global.ws_info);\n        } else if (obj instanceof Weapon || obj instanceof Armor) {\n            obj.add_o_flags(Const.ISKNOW);\n        } else if (obj instanceof Ring) {\n            set_know(obj, Global.ring_info);\n        }\n        IOUtil.msg(ThingMethod.inventoryName(obj, false));\n    }\n    /*\n     * set_know:\n     *\tSet things up when we really know what a thing is\n     */\n    private static void set_know(Thing obj, Obj_info[] info) {\n        info[obj.getNumber()].know();\n        obj.add_o_flags(Const.ISKNOW);\n    }\n    /*\n     * type_name:\n     *\tReturn a pointer to the name of the type\n     */\n    static String type_name(int type) {\n        List<Help_list> tlist = new ArrayList<>();\n        {\n            Help_list h = new Help_list(ObjectType.POTION.getValue(), \"potion\", false);\n            tlist.add(h);\n        }\n        {\n            Help_list h = new Help_list(ObjectType.SCROLL.getValue(), \"scroll\", false);\n            tlist.add(h);\n        }\n        {\n            Help_list h = new Help_list(ObjectType.FOOD.getValue(), \"food\", false);\n            tlist.add(h);\n        }\n        {\n            Help_list h = new Help_list((char) Const.R_OR_S, \"ring, wand or staff\", false);\n            tlist.add(h);\n        }\n        {\n            Help_list h = new Help_list(ObjectType.RING.getValue(), \"ring\", false);\n            tlist.add(h);\n        }\n        {\n            Help_list h = new Help_list(ObjectType.STICK.getValue(), \"wand or staff\", false);\n            tlist.add(h);\n        }\n        {\n            Help_list h = new Help_list(ObjectType.WEAPON.getValue(), \"weapon\", false);\n            tlist.add(h);\n        }\n        {\n            Help_list h = new Help_list(ObjectType.ARMOR.getValue(), \"suit of armor\", false);\n            tlist.add(h);\n        }\n        for (Help_list hp : tlist) {\n            if (type == hp.h_ch) {\n                return hp.h_desc;\n            }\n        }\n        /* NOTREACHED */\n        return \"\";\n    }\n"]]}
{"hexsha": "5b18d3e45be0f2e9ebb4767b9e5bcad36eb805fe", "ext": "java", "lang": "Java", "content": "public class OFDescriptionStatistics implements OFStatistics {\n    public static int DESCRIPTION_STRING_LENGTH = 256;\n    public static int SERIAL_NUMBER_LENGTH = 32;\n\n    protected String manufacturerDescription;\n    protected String hardwareDescription;\n    protected String softwareDescription;\n    protected String serialNumber;\n    protected String datapathDescription;\n\n    /**\n     * @return the manufacturerDescription\n     */\n    public String getManufacturerDescription() {\n        return this.manufacturerDescription;\n    }\n\n    /**\n     * @param manufacturerDescription\n     *            the manufacturerDescription to set\n     */\n    public void setManufacturerDescription(final String manufacturerDescription) {\n        this.manufacturerDescription = manufacturerDescription;\n    }\n\n    /**\n     * @return the hardwareDescription\n     */\n    public String getHardwareDescription() {\n        return this.hardwareDescription;\n    }\n\n    /**\n     * @param hardwareDescription\n     *            the hardwareDescription to set\n     */\n    public void setHardwareDescription(final String hardwareDescription) {\n        this.hardwareDescription = hardwareDescription;\n    }\n\n    /**\n     * @return the softwareDescription\n     */\n    public String getSoftwareDescription() {\n        return this.softwareDescription;\n    }\n\n    /**\n     * @param softwareDescription\n     *            the softwareDescription to set\n     */\n    public void setSoftwareDescription(final String softwareDescription) {\n        this.softwareDescription = softwareDescription;\n    }\n\n    /**\n     * @return the serialNumber\n     */\n    public String getSerialNumber() {\n        return this.serialNumber;\n    }\n\n    /**\n     * @param serialNumber\n     *            the serialNumber to set\n     */\n    public void setSerialNumber(final String serialNumber) {\n        this.serialNumber = serialNumber;\n    }\n\n    /**\n     * @return the datapathDescription\n     */\n    public String getDatapathDescription() {\n        return this.datapathDescription;\n    }\n\n    /**\n     * @param datapathDescription\n     *            the datapathDescription to set\n     */\n    public void setDatapathDescription(final String datapathDescription) {\n        this.datapathDescription = datapathDescription;\n    }\n\n    @Override\n    public int getLength() {\n        return 1056;\n    }\n\n    @Override\n    public void readFrom(final ChannelBuffer data) {\n        this.manufacturerDescription = StringByteSerializer.readFrom(data,\n                OFDescriptionStatistics.DESCRIPTION_STRING_LENGTH);\n        this.hardwareDescription = StringByteSerializer.readFrom(data,\n                OFDescriptionStatistics.DESCRIPTION_STRING_LENGTH);\n        this.softwareDescription = StringByteSerializer.readFrom(data,\n                OFDescriptionStatistics.DESCRIPTION_STRING_LENGTH);\n        this.serialNumber = StringByteSerializer.readFrom(data,\n                OFDescriptionStatistics.SERIAL_NUMBER_LENGTH);\n        this.datapathDescription = StringByteSerializer.readFrom(data,\n                OFDescriptionStatistics.DESCRIPTION_STRING_LENGTH);\n    }\n\n    @Override\n    public void writeTo(final ChannelBuffer data) {\n        StringByteSerializer.writeTo(data,\n                OFDescriptionStatistics.DESCRIPTION_STRING_LENGTH,\n                this.manufacturerDescription);\n        StringByteSerializer.writeTo(data,\n                OFDescriptionStatistics.DESCRIPTION_STRING_LENGTH,\n                this.hardwareDescription);\n        StringByteSerializer.writeTo(data,\n                OFDescriptionStatistics.DESCRIPTION_STRING_LENGTH,\n                this.softwareDescription);\n        StringByteSerializer\n                .writeTo(data, OFDescriptionStatistics.SERIAL_NUMBER_LENGTH,\n                        this.serialNumber);\n        StringByteSerializer.writeTo(data,\n                OFDescriptionStatistics.DESCRIPTION_STRING_LENGTH,\n                this.datapathDescription);\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 409;\n        int result = 1;\n        result = prime\n                * result\n                + (this.datapathDescription == null ? 0\n                        : this.datapathDescription.hashCode());\n        result = prime\n                * result\n                + (this.hardwareDescription == null ? 0\n                        : this.hardwareDescription.hashCode());\n        result = prime\n                * result\n                + (this.manufacturerDescription == null ? 0\n                        : this.manufacturerDescription.hashCode());\n        result = prime\n                * result\n                + (this.serialNumber == null ? 0 : this.serialNumber.hashCode());\n        result = prime\n                * result\n                + (this.softwareDescription == null ? 0\n                        : this.softwareDescription.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof OFDescriptionStatistics)) {\n            return false;\n        }\n        final OFDescriptionStatistics other = (OFDescriptionStatistics) obj;\n        if (this.datapathDescription == null) {\n            if (other.datapathDescription != null) {\n                return false;\n            }\n        } else if (!this.datapathDescription.equals(other.datapathDescription)) {\n            return false;\n        }\n        if (this.hardwareDescription == null) {\n            if (other.hardwareDescription != null) {\n                return false;\n            }\n        } else if (!this.hardwareDescription.equals(other.hardwareDescription)) {\n            return false;\n        }\n        if (this.manufacturerDescription == null) {\n            if (other.manufacturerDescription != null) {\n                return false;\n            }\n        } else if (!this.manufacturerDescription\n                .equals(other.manufacturerDescription)) {\n            return false;\n        }\n        if (this.serialNumber == null) {\n            if (other.serialNumber != null) {\n                return false;\n            }\n        } else if (!this.serialNumber.equals(other.serialNumber)) {\n            return false;\n        }\n        if (this.softwareDescription == null) {\n            if (other.softwareDescription != null) {\n                return false;\n            }\n        } else if (!this.softwareDescription.equals(other.softwareDescription)) {\n            return false;\n        }\n        return true;\n    }\n}", "class_id": 0, "repo": "os-xebra/AggFlow", "file": "src/main/java/org/openflow/protocol/statistics/OFDescriptionStatistics.java", "last_update_at": "2019-04-18T04:41:51+00:00", "question_id": "5b18d3e45be0f2e9ebb4767b9e5bcad36eb805fe", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OFDescriptionStatistics implements OFStatistics {\n    public static int DESCRIPTION_STRING_LENGTH = 256;\n    public static int SERIAL_NUMBER_LENGTH = 32;\n    protected String manufacturerDescription;\n    protected String hardwareDescription;\n    protected String softwareDescription;\n    protected String serialNumber;\n    protected String datapathDescription;\n    /**\n     * @return the manufacturerDescription\n     */\n    public String getManufacturerDescription() {\n        return this.manufacturerDescription;\n    }\n    /**\n     * @param manufacturerDescription\n     *            the manufacturerDescription to set\n     */\n    public void setManufacturerDescription(final String manufacturerDescription) {\n        this.manufacturerDescription = manufacturerDescription;\n    }\n    /**\n     * @return the hardwareDescription\n     */\n    public String getHardwareDescription() {\n        return this.hardwareDescription;\n    }\n    /**\n     * @param hardwareDescription\n     *            the hardwareDescription to set\n     */\n    public void setHardwareDescription(final String hardwareDescription) {\n        this.hardwareDescription = hardwareDescription;\n    }\n    /**\n     * @return the softwareDescription\n     */\n    public String getSoftwareDescription() {\n        return this.softwareDescription;\n    }\n    /**\n     * @param softwareDescription\n     *            the softwareDescription to set\n     */\n    public void setSoftwareDescription(final String softwareDescription) {\n        this.softwareDescription = softwareDescription;\n    }\n    /**\n     * @return the serialNumber\n     */\n    public String getSerialNumber() {\n        return this.serialNumber;\n    }\n    /**\n     * @param serialNumber\n     *            the serialNumber to set\n     */\n    public void setSerialNumber(final String serialNumber) {\n        this.serialNumber = serialNumber;\n    }\n    /**\n     * @return the datapathDescription\n     */\n    public String getDatapathDescription() {\n        return this.datapathDescription;\n    }\n    /**\n     * @param datapathDescription\n     *            the datapathDescription to set\n     */\n    public void setDatapathDescription(final String datapathDescription) {\n        this.datapathDescription = datapathDescription;\n    }\n    @Override\n    public int getLength() {\n        return 1056;\n    }\n    @Override\n    public void readFrom(final ChannelBuffer data) {\n        this.manufacturerDescription = StringByteSerializer.readFrom(data,\n                OFDescriptionStatistics.DESCRIPTION_STRING_LENGTH);\n        this.hardwareDescription = StringByteSerializer.readFrom(data,\n                OFDescriptionStatistics.DESCRIPTION_STRING_LENGTH);\n        this.softwareDescription = StringByteSerializer.readFrom(data,\n                OFDescriptionStatistics.DESCRIPTION_STRING_LENGTH);\n        this.serialNumber = StringByteSerializer.readFrom(data,\n                OFDescriptionStatistics.SERIAL_NUMBER_LENGTH);\n        this.datapathDescription = StringByteSerializer.readFrom(data,\n                OFDescriptionStatistics.DESCRIPTION_STRING_LENGTH);\n    }\n    @Override\n    public void writeTo(final ChannelBuffer data) {\n        StringByteSerializer.writeTo(data,\n                OFDescriptionStatistics.DESCRIPTION_STRING_LENGTH,\n                this.manufacturerDescription);\n        StringByteSerializer.writeTo(data,\n                OFDescriptionStatistics.DESCRIPTION_STRING_LENGTH,\n                this.hardwareDescription);\n        StringByteSerializer.writeTo(data,\n                OFDescriptionStatistics.DESCRIPTION_STRING_LENGTH,\n                this.softwareDescription);\n        StringByteSerializer\n                .writeTo(data, OFDescriptionStatistics.SERIAL_NUMBER_LENGTH,\n                        this.serialNumber);\n        StringByteSerializer.writeTo(data,\n                OFDescriptionStatistics.DESCRIPTION_STRING_LENGTH,\n                this.datapathDescription);\n    }\n    @Override\n    public int hashCode() {\n        final int prime = 409;\n        int result = 1;\n        result = prime\n                * result\n                + (this.datapathDescription == null ? 0\n                        : this.datapathDescription.hashCode());\n        result = prime\n                * result\n                + (this.hardwareDescription == null ? 0\n                        : this.hardwareDescription.hashCode());\n        result = prime\n                * result\n                + (this.manufacturerDescription == null ? 0\n                        : this.manufacturerDescription.hashCode());\n        result = prime\n                * result\n                + (this.serialNumber == null ? 0 : this.serialNumber.hashCode());\n        result = prime\n                * result\n                + (this.softwareDescription == null ? 0\n                        : this.softwareDescription.hashCode());\n        return result;\n    }\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof OFDescriptionStatistics)) {\n            return false;\n        }\n        final OFDescriptionStatistics other = (OFDescriptionStatistics) obj;\n        if (this.datapathDescription == null) {\n            if (other.datapathDescription != null) {\n                return false;\n            }\n        } else if (!this.datapathDescription.equals(other.datapathDescription)) {\n            return false;\n        }\n        if (this.hardwareDescription == null) {\n            if (other.hardwareDescription != null) {\n                return false;\n            }\n        } else if (!this.hardwareDescription.equals(other.hardwareDescription)) {\n            return false;\n        }\n        if (this.manufacturerDescription == null) {\n            if (other.manufacturerDescription != null) {\n                return false;\n            }\n        } else if (!this.manufacturerDescription\n                .equals(other.manufacturerDescription)) {\n            return false;\n        }\n        if (this.serialNumber == null) {\n            if (other.serialNumber != null) {\n                return false;\n            }\n        } else if (!this.serialNumber.equals(other.serialNumber)) {\n            return false;\n        }\n        if (this.softwareDescription == null) {\n            if (other.softwareDescription != null) {\n                return false;\n            }\n        } else if (!this.softwareDescription.equals(other.softwareDescription)) {\n            return false;\n        }\n        return true;\n    }\n"]]}
{"hexsha": "8c69e59ac22e4898f825e302530424f432cc0f51", "ext": "java", "lang": "Java", "content": "public class StereoOnWithCDCommand implements Command {\n    Stereo stereo;\n\n    public StereoOnWithCDCommand(Stereo stereo) {\n        this.stereo = stereo;\n    }\n\n    @Override\n    public void execute() {\n        stereo.on();\n        stereo.setCD();\n        stereo.setVolume();\n    }\n\n    @Override\n    public void undo() {\n        stereo.off();\n    }\n}", "class_id": 0, "repo": "guzijiang/JavaPattern", "file": "src/com/pattern8/command/impl/StereoOnWithCDCommand.java", "last_update_at": "2019-10-31T13:13:53+00:00", "question_id": "8c69e59ac22e4898f825e302530424f432cc0f51", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class StereoOnWithCDCommand implements Command {\n    Stereo stereo;\n    public StereoOnWithCDCommand(Stereo stereo) {\n        this.stereo = stereo;\n    }\n    @Override\n    public void execute() {\n        stereo.on();\n        stereo.setCD();\n        stereo.setVolume();\n    }\n    @Override\n    public void undo() {\n        stereo.off();\n    }\n"]]}
{"hexsha": "bae171a517c0c1b291893b423f8e3500bf5160cd", "ext": "java", "lang": "Java", "content": "public class FeedbackPresenterImpl implements FeedbackPresenter,\n        FeedbackDataModel.OnFinishedPresenterListener, FeedbackDataModel.OnSubmitFeedbackPresenterListener,\n        FeedbackDataModel.HasUserSubmittedAFeedbackPresenterListener\n{\n\n    private FeedbackView feedbackView;\n    private FeedbackDataModel feedbackDataModel;\n\n    public FeedbackPresenterImpl(FeedbackView feedbackActivity, FeedbackDataModel feedbackDataModel) {\n        this.feedbackView = feedbackActivity;\n        this.feedbackDataModel = feedbackDataModel;\n    }\n\n    @Override\n    public void onLoading() {\n        feedbackDataModel.hasUserSubmittedAFeedback(this);\n    }\n\n    @Override\n    public void onHasUserSubmittedFeedback() {\n        feedbackView.installFeedbackFragment();\n    }\n\n    @Override\n    public void onHasUserNotSubmittedFeedback() {\n        if (feedbackView != null) {\n            feedbackView.showProgress();\n        }\n        feedbackDataModel.getQuestions(this);\n    }\n\n    @Override\n    public void onDestroy() {\n        feedbackView = null;\n    }\n\n    @Override\n    public void saveState() {\n//        Log.e(\"onDestroy submit\", feedbackDataModel.getFeedbackSubmitEntity().getJsonElement().getAsJsonObject().toString());\n        feedbackDataModel.setFeedbackResponseFromSharedPreferences(this);\n    }\n\n    @Override\n    public void restoreState() {\n        feedbackDataModel.getFeedbackResponseFromSharedPreferences();\n    }\n\n    @Override\n    public void submitFeedback() {\n        feedbackDataModel.submitFeedback(this);\n    }\n\n    @Override\n    public void onClickChangeFeedbackResponse() {\n        feedbackView.uninstallFeedbackFragment();\n        if (feedbackView != null) {\n            feedbackView.showProgress();\n        }\n        feedbackDataModel.getQuestions(this);\n    }\n\n    @Override\n    public void onFinished(List<FeedbackQuestionEntity> items) {\n        if (feedbackView != null) {\n            Log.e(\"onFinished\", \"onFinished: \" + items.toString());\n//            feedbackView.hideProgress();\n            feedbackView.setItems(items, feedbackDataModel.getFeedbackSubmitEntity(items));\n        }\n    }\n\n    @Override\n    public void onSubmit() {\n        feedbackView.showMessageForSubmittedFeedback(\"Thank you for your feedback!\");\n    }\n\n    @Override\n    public void onFailed() {\n        feedbackView.showMessageForErrorOnSubmit(\"Fields with marks(*) are required.\");\n    }\n}", "class_id": 0, "repo": "fdibernardo/PlusPrivacy", "file": "clients/android/PlusPrivacy/app/src/main/java/eu/operando/feedback/presenter/FeedbackPresenterImpl.java", "last_update_at": "2019-07-16T12:55:20+00:00", "question_id": "bae171a517c0c1b291893b423f8e3500bf5160cd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FeedbackPresenterImpl implements FeedbackPresenter,\n        FeedbackDataModel.OnFinishedPresenterListener, FeedbackDataModel.OnSubmitFeedbackPresenterListener,\n        FeedbackDataModel.HasUserSubmittedAFeedbackPresenterListener\n{\n    private FeedbackView feedbackView;\n    private FeedbackDataModel feedbackDataModel;\n    public FeedbackPresenterImpl(FeedbackView feedbackActivity, FeedbackDataModel feedbackDataModel) {\n        this.feedbackView = feedbackActivity;\n        this.feedbackDataModel = feedbackDataModel;\n    }\n    @Override\n    public void onLoading() {\n        feedbackDataModel.hasUserSubmittedAFeedback(this);\n    }\n    @Override\n    public void onHasUserSubmittedFeedback() {\n        feedbackView.installFeedbackFragment();\n    }\n    @Override\n    public void onHasUserNotSubmittedFeedback() {\n        if (feedbackView != null) {\n            feedbackView.showProgress();\n        }\n        feedbackDataModel.getQuestions(this);\n    }\n    @Override\n    public void onDestroy() {\n        feedbackView = null;\n    }\n    @Override\n    public void saveState() {\n//        Log.e(\"onDestroy submit\", feedbackDataModel.getFeedbackSubmitEntity().getJsonElement().getAsJsonObject().toString());\n        feedbackDataModel.setFeedbackResponseFromSharedPreferences(this);\n    }\n    @Override\n    public void restoreState() {\n        feedbackDataModel.getFeedbackResponseFromSharedPreferences();\n    }\n    @Override\n    public void submitFeedback() {\n        feedbackDataModel.submitFeedback(this);\n    }\n    @Override\n    public void onClickChangeFeedbackResponse() {\n        feedbackView.uninstallFeedbackFragment();\n        if (feedbackView != null) {\n            feedbackView.showProgress();\n        }\n        feedbackDataModel.getQuestions(this);\n    }\n    @Override\n    public void onFinished(List<FeedbackQuestionEntity> items) {\n        if (feedbackView != null) {\n            Log.e(\"onFinished\", \"onFinished: \" + items.toString());\n//            feedbackView.hideProgress();\n            feedbackView.setItems(items, feedbackDataModel.getFeedbackSubmitEntity(items));\n        }\n    }\n    @Override\n    public void onSubmit() {\n        feedbackView.showMessageForSubmittedFeedback(\"Thank you for your feedback!\");\n    }\n    @Override\n    public void onFailed() {\n        feedbackView.showMessageForErrorOnSubmit(\"Fields with marks(*) are required.\");\n    }\n"]]}
{"hexsha": "f9d32d398ab45f420b3ca27d39f82fd8a93078a8", "ext": "java", "lang": "Java", "content": "class Insertionsort { \n\t\n\tvoid sort(int array[]) \n\t{ \n\t\tint n = 5;\t\t\n                 for (int i = 1; i < 5; ++i) { \n\t\t\tint key = array[i]; \n\t\t\tint j = i - 1; \n\n\t\t\n\t\t\twhile (j >= 0 && array[j] > key) {\n      //This program is coded by roja\n\t\t\t\tarray[j+1] = array[j]; \n\t\t\t\tj = j - 1; \n\t\t\t} \n\t\t\tarray[j + 1] = key; \n\t\t} \n\t} \npublic static void main(String args[]) \n\t{ \n         int k;      \n        System.out.println(\"enter the array size\");\n\n                Scanner obj = new Scanner(System.in);\n                //This program is coded by roja\n                int s = obj.nextInt();\n                int array[] = new int[5];\n System.out.println(\"enter \" + s + \" element \");\n for( k = 0;  k < 5; k++)\n{\nint x =obj.nextInt();\narray[k]=x;\n}\n   \tInsertionsort ob = new Insertionsort(); \n\t\tob.sort(array);\n          System.out.println(\"after sorting\");\n          for (int i = 0; i < 5; i++) \n        //This program is coded by roja\n\t\t\tSystem.out.print(array[i] + \" \"); \n      System.out.println();\n                    \n\n               \n\t\n\t} \n}", "class_id": 0, "repo": "GunduRoja/insertion-sort", "file": "code.java", "last_update_at": "2019-12-19T15:53:29+00:00", "question_id": "f9d32d398ab45f420b3ca27d39f82fd8a93078a8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Insertionsort { \n\t\n\tvoid sort(int array[]) \n\t{ \n\t\tint n = 5;\t\t\n                 for (int i = 1; i < 5; ++i) { \n\t\t\tint key = array[i]; \n\t\t\tint j = i - 1; \n\t\t\n\t\t\twhile (j >= 0 && array[j] > key) {\n      //This program is coded by roja\n\t\t\t\tarray[j+1] = array[j]; \n\t\t\t\tj = j - 1; \n\t\t\t} \n\t\t\tarray[j + 1] = key; \n\t\t} \n\t} \npublic static void main(String args[]) \n\t{ \n         int k;      \n        System.out.println(\"enter the array size\");\n                Scanner obj = new Scanner(System.in);\n                //This program is coded by roja\n                int s = obj.nextInt();\n                int array[] = new int[5];\n System.out.println(\"enter \" + s + \" element \");\n for( k = 0;  k < 5; k++)\n{\nint x =obj.nextInt();\narray[k]=x;\n}\n   \tInsertionsort ob = new Insertionsort(); \n\t\tob.sort(array);\n          System.out.println(\"after sorting\");\n          for (int i = 0; i < 5; i++) \n        //This program is coded by roja\n\t\t\tSystem.out.print(array[i] + \" \"); \n      System.out.println();\n\t\n\t} \n"]]}
{"hexsha": "dbf6542e8a615f8e73d4b26963728bffdc32e5a8", "ext": "java", "lang": "Java", "content": "public class PartitionHashRecordV2 extends VisorDataTransferObject {\n    /** */\n    private static final long serialVersionUID = 0L;\n\n    /** Moving partition size. */\n    public static final long MOVING_PARTITION_SIZE = Long.MIN_VALUE;\n\n    /** Partition key. */\n    @GridToStringExclude\n    private PartitionKeyV2 partKey;\n\n    /** Is primary flag. */\n    private boolean isPrimary;\n\n    /** Consistent id. */\n    @GridToStringInclude\n    private Object consistentId;\n\n    /** Partition hash. */\n    @GridToStringExclude\n    private int partHash;\n\n    /** Update counter. */\n    private long updateCntr;\n\n    /** Size. */\n    @GridToStringExclude\n    private long size;\n\n    /**\n     * @param partKey Partition key.\n     * @param isPrimary Is primary.\n     * @param consistentId Consistent id.\n     * @param partHash Partition hash.\n     * @param updateCntr Update counter.\n     * @param size Size.\n     */\n    public PartitionHashRecordV2(PartitionKeyV2 partKey, boolean isPrimary,\n        Object consistentId, int partHash, long updateCntr, long size) {\n        this.partKey = partKey;\n        this.isPrimary = isPrimary;\n        this.consistentId = consistentId;\n        this.partHash = partHash;\n        this.updateCntr = updateCntr;\n        this.size = size;\n    }\n\n    /**\n     * Default constructor for Externalizable.\n     */\n    public PartitionHashRecordV2() {\n    }\n\n    /**\n     * @return Partition key.\n     */\n    public PartitionKeyV2 partitionKey() {\n        return partKey;\n    }\n\n    /**\n     * @return Is primary.\n     */\n    public boolean isPrimary() {\n        return isPrimary;\n    }\n\n    /**\n     * @return Consistent id.\n     */\n    public Object consistentId() {\n        return consistentId;\n    }\n\n    /**\n     * @return Partition hash.\n     */\n    public int partitionHash() {\n        return partHash;\n    }\n\n    /**\n     * @return Update counter.\n     */\n    public long updateCounter() {\n        return updateCntr;\n    }\n\n    /**\n     * @return Size.\n     */\n    public long size() {\n        return size;\n    }\n\n    /** {@inheritDoc} */\n    @Override protected void writeExternalData(ObjectOutput out) throws IOException {\n        out.writeObject(partKey);\n        out.writeBoolean(isPrimary);\n        out.writeObject(consistentId);\n        out.writeInt(partHash);\n        out.writeLong(updateCntr);\n        out.writeLong(size);\n    }\n\n    /** {@inheritDoc} */\n    @Override protected void readExternalData(byte protoVer, ObjectInput in) throws IOException, ClassNotFoundException {\n        partKey = (PartitionKeyV2)in.readObject();\n        isPrimary = in.readBoolean();\n        consistentId = in.readObject();\n        partHash = in.readInt();\n        updateCntr = in.readLong();\n        size = in.readLong();\n    }\n\n    /** {@inheritDoc} */\n    @Override public String toString() {\n        return size == MOVING_PARTITION_SIZE ?\n            S.toString(PartitionHashRecordV2.class, this, \"state\", \"MOVING\") :\n            S.toString(PartitionHashRecordV2.class, this, \"size\", size, \"partHash\", partHash);\n    }\n\n    /** {@inheritDoc} */\n    @Override public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n\n        PartitionHashRecordV2 record = (PartitionHashRecordV2)o;\n\n        return consistentId.equals(record.consistentId);\n    }\n\n    /** {@inheritDoc} */\n    @Override public int hashCode() {\n        return consistentId.hashCode();\n    }\n}", "class_id": 0, "repo": "DirectXceriD/gridgain", "file": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/verify/PartitionHashRecordV2.java", "last_update_at": "2019-03-11T08:52:37+00:00", "question_id": "dbf6542e8a615f8e73d4b26963728bffdc32e5a8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PartitionHashRecordV2 extends VisorDataTransferObject {\n    /** */\n    private static final long serialVersionUID = 0L;\n    /** Moving partition size. */\n    public static final long MOVING_PARTITION_SIZE = Long.MIN_VALUE;\n    /** Partition key. */\n    @GridToStringExclude\n    private PartitionKeyV2 partKey;\n    /** Is primary flag. */\n    private boolean isPrimary;\n    /** Consistent id. */\n    @GridToStringInclude\n    private Object consistentId;\n    /** Partition hash. */\n    @GridToStringExclude\n    private int partHash;\n    /** Update counter. */\n    private long updateCntr;\n    /** Size. */\n    @GridToStringExclude\n    private long size;\n    /**\n     * @param partKey Partition key.\n     * @param isPrimary Is primary.\n     * @param consistentId Consistent id.\n     * @param partHash Partition hash.\n     * @param updateCntr Update counter.\n     * @param size Size.\n     */\n    public PartitionHashRecordV2(PartitionKeyV2 partKey, boolean isPrimary,\n        Object consistentId, int partHash, long updateCntr, long size) {\n        this.partKey = partKey;\n        this.isPrimary = isPrimary;\n        this.consistentId = consistentId;\n        this.partHash = partHash;\n        this.updateCntr = updateCntr;\n        this.size = size;\n    }\n    /**\n     * Default constructor for Externalizable.\n     */\n    public PartitionHashRecordV2() {\n    }\n    /**\n     * @return Partition key.\n     */\n    public PartitionKeyV2 partitionKey() {\n        return partKey;\n    }\n    /**\n     * @return Is primary.\n     */\n    public boolean isPrimary() {\n        return isPrimary;\n    }\n    /**\n     * @return Consistent id.\n     */\n    public Object consistentId() {\n        return consistentId;\n    }\n    /**\n     * @return Partition hash.\n     */\n    public int partitionHash() {\n        return partHash;\n    }\n    /**\n     * @return Update counter.\n     */\n    public long updateCounter() {\n        return updateCntr;\n    }\n    /**\n     * @return Size.\n     */\n    public long size() {\n        return size;\n    }\n    /** {@inheritDoc} */\n    @Override protected void writeExternalData(ObjectOutput out) throws IOException {\n        out.writeObject(partKey);\n        out.writeBoolean(isPrimary);\n        out.writeObject(consistentId);\n        out.writeInt(partHash);\n        out.writeLong(updateCntr);\n        out.writeLong(size);\n    }\n    /** {@inheritDoc} */\n    @Override protected void readExternalData(byte protoVer, ObjectInput in) throws IOException, ClassNotFoundException {\n        partKey = (PartitionKeyV2)in.readObject();\n        isPrimary = in.readBoolean();\n        consistentId = in.readObject();\n        partHash = in.readInt();\n        updateCntr = in.readLong();\n        size = in.readLong();\n    }\n    /** {@inheritDoc} */\n    @Override public String toString() {\n        return size == MOVING_PARTITION_SIZE ?\n            S.toString(PartitionHashRecordV2.class, this, \"state\", \"MOVING\") :\n            S.toString(PartitionHashRecordV2.class, this, \"size\", size, \"partHash\", partHash);\n    }\n    /** {@inheritDoc} */\n    @Override public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        PartitionHashRecordV2 record = (PartitionHashRecordV2)o;\n        return consistentId.equals(record.consistentId);\n    }\n    /** {@inheritDoc} */\n    @Override public int hashCode() {\n        return consistentId.hashCode();\n    }\n"]]}
{"hexsha": "47d539cd740d162402a3804ed62c269e7e3849e8", "ext": "java", "lang": "Java", "content": "public final class MonitoringControllerHolder {\n\n\tprivate static volatile IMonitoringController monitoringController;\n\tprivate static volatile MonitoringConfiguration monitoringConfiguration;\n\n\tprivate MonitoringControllerHolder( ) {\n\t\t// Avoid instantiation\n\t}\n\n\tpublic static IMonitoringController getMonitoringController( ) {\n\t\treturn monitoringController;\n\t}\n\n\tpublic static void setMonitoringController( final IMonitoringController aMonitoringController ) {\n\t\tmonitoringController = aMonitoringController;\n\t}\n\n\tpublic static MonitoringConfiguration getCurrentConfiguration( ) {\n\t\treturn monitoringConfiguration;\n\t}\n\n\tpublic static void setCurrentConfiguration( final MonitoringConfiguration aMonitoringConfiguration ) {\n\t\tmonitoringConfiguration = aMonitoringConfiguration;\n\t}\n\n\tpublic static IMonitoringController clearMonitoringController( ) {\n\t\tfinal IMonitoringController controller = monitoringController;\n\t\tmonitoringController = null;\n\t\treturn controller;\n\t}\n\n}", "class_id": 0, "repo": "massoudasadimcc7f/kieker-monitoringu", "file": "ktd-backend/ktd-backend-monitoring/src/main/java/kieker/diagnosis/backend/monitoring/MonitoringControllerHolder.java", "last_update_at": "2019-08-16T10:57:54+00:00", "question_id": "47d539cd740d162402a3804ed62c269e7e3849e8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class MonitoringControllerHolder {\n\tprivate static volatile IMonitoringController monitoringController;\n\tprivate static volatile MonitoringConfiguration monitoringConfiguration;\n\tprivate MonitoringControllerHolder( ) {\n\t\t// Avoid instantiation\n\t}\n\tpublic static IMonitoringController getMonitoringController( ) {\n\t\treturn monitoringController;\n\t}\n\tpublic static void setMonitoringController( final IMonitoringController aMonitoringController ) {\n\t\tmonitoringController = aMonitoringController;\n\t}\n\tpublic static MonitoringConfiguration getCurrentConfiguration( ) {\n\t\treturn monitoringConfiguration;\n\t}\n\tpublic static void setCurrentConfiguration( final MonitoringConfiguration aMonitoringConfiguration ) {\n\t\tmonitoringConfiguration = aMonitoringConfiguration;\n\t}\n\tpublic static IMonitoringController clearMonitoringController( ) {\n\t\tfinal IMonitoringController controller = monitoringController;\n\t\tmonitoringController = null;\n\t\treturn controller;\n\t}\n"]]}
{"hexsha": "d94a1d4125a8dc34ed0d8afffc51f874a8f6baee", "ext": "java", "lang": "Java", "content": "public class TestServer extends ServerHelper {\n    @Test\n    public void testVolume() throws JarvisException {\n        assertEquals(100, jarvis.getVolume());\n    }\n\n    @Test\n    public void testSetVolume() throws JarvisException {\n        assertEquals(20, jarvis.setVolume(20));\n    }\n\n    @Test\n    public void testVolumeUp() throws JarvisException {\n        assertEquals(105, jarvis.volumeUp());\n    }\n\n    @Test\n    public void testVolumeDown() throws JarvisException {\n        assertEquals(95, jarvis.volumeDown());\n    }\n\n    @Test\n    public void testTempo() throws JarvisException {\n        assertEquals(80, jarvis.getTempo());\n    }\n\n    @Test\n    public void testSetTempo() throws JarvisException {\n        assertEquals(20, jarvis.setTempo(20));\n    }\n\n    @Test\n    public void testTempoUp() throws JarvisException {\n        assertEquals(85, jarvis.tempoUp());\n    }\n\n    @Test\n    public void testTempoDown() throws JarvisException {\n        assertEquals(75, jarvis.tempoDown());\n    }\n\n    @Test(expected = JarvisException.class)\n    public void testNoCommandFound() throws JarvisException {\n        jarvis.sendMessage(\"definitelynotacommandatall\");\n    }\n\n    @Test(expected = JarvisException.class)\n    public void testGeneratorCommandGeneratorNotLoaded() throws JarvisException {\n        jarvis.loadGenerator(\"Random\");\n        jarvis.sendMessage(\"Otomata.poke 1 1\");\n    }\n\n    @Test\n    public void testListGenerators() throws JarvisException {\n        String[] list = jarvis.getGenerators();\n        assertTrue(list.length > 0);\n    }\n\n    @Test\n    public void testStart() throws JarvisException {\n        String response = jarvis.start();\n        assertTrue(response.contains(\"successfully\"));\n    }\n\n    @Test\n    public void testStop() throws JarvisException {\n        jarvis.start();\n        String response = jarvis.stop();\n        assertTrue(response.contains(\"successfully\"));\n    }\n}", "class_id": 0, "repo": "samwho/jarvis", "file": "client_libs/java/test/TestServer.java", "last_update_at": "2019-04-16T19:58:33+00:00", "question_id": "d94a1d4125a8dc34ed0d8afffc51f874a8f6baee", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestServer extends ServerHelper {\n    @Test\n    public void testVolume() throws JarvisException {\n        assertEquals(100, jarvis.getVolume());\n    }\n    @Test\n    public void testSetVolume() throws JarvisException {\n        assertEquals(20, jarvis.setVolume(20));\n    }\n    @Test\n    public void testVolumeUp() throws JarvisException {\n        assertEquals(105, jarvis.volumeUp());\n    }\n    @Test\n    public void testVolumeDown() throws JarvisException {\n        assertEquals(95, jarvis.volumeDown());\n    }\n    @Test\n    public void testTempo() throws JarvisException {\n        assertEquals(80, jarvis.getTempo());\n    }\n    @Test\n    public void testSetTempo() throws JarvisException {\n        assertEquals(20, jarvis.setTempo(20));\n    }\n    @Test\n    public void testTempoUp() throws JarvisException {\n        assertEquals(85, jarvis.tempoUp());\n    }\n    @Test\n    public void testTempoDown() throws JarvisException {\n        assertEquals(75, jarvis.tempoDown());\n    }\n    @Test(expected = JarvisException.class)\n    public void testNoCommandFound() throws JarvisException {\n        jarvis.sendMessage(\"definitelynotacommandatall\");\n    }\n    @Test(expected = JarvisException.class)\n    public void testGeneratorCommandGeneratorNotLoaded() throws JarvisException {\n        jarvis.loadGenerator(\"Random\");\n        jarvis.sendMessage(\"Otomata.poke 1 1\");\n    }\n    @Test\n    public void testListGenerators() throws JarvisException {\n        String[] list = jarvis.getGenerators();\n        assertTrue(list.length > 0);\n    }\n    @Test\n    public void testStart() throws JarvisException {\n        String response = jarvis.start();\n        assertTrue(response.contains(\"successfully\"));\n    }\n    @Test\n    public void testStop() throws JarvisException {\n        jarvis.start();\n        String response = jarvis.stop();\n        assertTrue(response.contains(\"successfully\"));\n    }\n"]]}
{"hexsha": "658520e56f702f781b2023d11bfa82e9586eaa52", "ext": "java", "lang": "Java", "content": "public class main {\n    public static void main(String[] args){\n        Singleton singleton1 = Singleton.getInstance();\n        Singleton singleton2 = Singleton.getInstance();\n        System.out.println(singleton1.toString());\n        System.out.println(singleton2.toString());\n    }\n}", "class_id": 0, "repo": "jsyjst/DesignPatternDemo", "file": "src/singleton/main.java", "last_update_at": "2019-04-12T09:35:19+00:00", "question_id": "658520e56f702f781b2023d11bfa82e9586eaa52", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class main {\n    public static void main(String[] args){\n        Singleton singleton1 = Singleton.getInstance();\n        Singleton singleton2 = Singleton.getInstance();\n        System.out.println(singleton1.toString());\n        System.out.println(singleton2.toString());\n    }\n"]]}
{"hexsha": "b41b8f0c8e962f668e692cf871a41b166bc3603c", "ext": "java", "lang": "Java", "content": "@Entity\n@Table(name = \"direct_asset\")\n@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n@Document(indexName = \"directasset\")\npublic class DirectAsset implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"sequenceGenerator\")\n    @SequenceGenerator(name = \"sequenceGenerator\")\n    private Long id;\n\n    @OneToOne\n    @JoinColumn(unique = true)\n    private MyAsset myAsset;\n\n\n    @OneToMany(mappedBy = \"directAsset\", fetch = FetchType.EAGER,\n        cascade = {CascadeType.ALL, CascadeType.PERSIST, CascadeType.MERGE}, orphanRemoval = true)\n    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n    private Set<IndirectAsset> effects = new HashSet<>();\n\n    // jhipster-needle-entity-add-field - JHipster will add fields here, do not remove\n    public Long getId() {\n        return id;\n    }\n\n    public void setId(Long id) {\n        this.id = id;\n    }\n\n    public MyAsset getMyAsset() {\n        return myAsset;\n    }\n\n    public DirectAsset myAsset(MyAsset myAsset) {\n        this.myAsset = myAsset;\n        return this;\n    }\n\n    public void setMyAsset(MyAsset myAsset) {\n        this.myAsset = myAsset;\n    }\n\n    public Set<IndirectAsset> getEffects() {\n        return effects;\n    }\n\n    public DirectAsset effects(Set<IndirectAsset> indirectAssets) {\n        this.effects = indirectAssets;\n        return this;\n    }\n\n    public DirectAsset addEffects(IndirectAsset indirectAsset) {\n        this.effects.add(indirectAsset);\n        indirectAsset.setDirectAsset(this);\n        return this;\n    }\n\n    public DirectAsset removeEffects(IndirectAsset indirectAsset) {\n        this.effects.remove(indirectAsset);\n        indirectAsset.setDirectAsset(null);\n        return this;\n    }\n\n    public void setEffects(Set<IndirectAsset> indirectAssets) {\n        this.effects = indirectAssets;\n    }\n    // jhipster-needle-entity-add-getters-setters - JHipster will add getters and setters here, do not remove\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        DirectAsset directAsset = (DirectAsset) o;\n        if (directAsset.getId() == null || getId() == null) {\n            return false;\n        }\n        return Objects.equals(getId(), directAsset.getId());\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hashCode(getId());\n    }\n\n    @Override\n    public String toString() {\n        return \"DirectAsset{\" +\n            \"id=\" + getId() +\n            \"}\";\n    }\n}", "class_id": 0, "repo": "rating-eu/rating", "file": "src/main/java/eu/hermeneut/domain/DirectAsset.java", "last_update_at": "2019-07-26T10:57:14+00:00", "question_id": "b41b8f0c8e962f668e692cf871a41b166bc3603c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Entity\n@Table(name = \"direct_asset\")\n@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n@Document(indexName = \"directasset\")\npublic class DirectAsset implements Serializable {\n    private static final long serialVersionUID = 1L;\n    @Id\n    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"sequenceGenerator\")\n    @SequenceGenerator(name = \"sequenceGenerator\")\n    private Long id;\n    @OneToOne\n    @JoinColumn(unique = true)\n    private MyAsset myAsset;\n    @OneToMany(mappedBy = \"directAsset\", fetch = FetchType.EAGER,\n        cascade = {CascadeType.ALL, CascadeType.PERSIST, CascadeType.MERGE}, orphanRemoval = true)\n    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n    private Set<IndirectAsset> effects = new HashSet<>();\n    // jhipster-needle-entity-add-field - JHipster will add fields here, do not remove\n    public Long getId() {\n        return id;\n    }\n    public void setId(Long id) {\n        this.id = id;\n    }\n    public MyAsset getMyAsset() {\n        return myAsset;\n    }\n    public DirectAsset myAsset(MyAsset myAsset) {\n        this.myAsset = myAsset;\n        return this;\n    }\n    public void setMyAsset(MyAsset myAsset) {\n        this.myAsset = myAsset;\n    }\n    public Set<IndirectAsset> getEffects() {\n        return effects;\n    }\n    public DirectAsset effects(Set<IndirectAsset> indirectAssets) {\n        this.effects = indirectAssets;\n        return this;\n    }\n    public DirectAsset addEffects(IndirectAsset indirectAsset) {\n        this.effects.add(indirectAsset);\n        indirectAsset.setDirectAsset(this);\n        return this;\n    }\n    public DirectAsset removeEffects(IndirectAsset indirectAsset) {\n        this.effects.remove(indirectAsset);\n        indirectAsset.setDirectAsset(null);\n        return this;\n    }\n    public void setEffects(Set<IndirectAsset> indirectAssets) {\n        this.effects = indirectAssets;\n    }\n    // jhipster-needle-entity-add-getters-setters - JHipster will add getters and setters here, do not remove\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        DirectAsset directAsset = (DirectAsset) o;\n        if (directAsset.getId() == null || getId() == null) {\n            return false;\n        }\n        return Objects.equals(getId(), directAsset.getId());\n    }\n    @Override\n    public int hashCode() {\n        return Objects.hashCode(getId());\n    }\n    @Override\n    public String toString() {\n        return \"DirectAsset{\" +\n            \"id=\" + getId() +\n            \"}\";\n    }\n"]]}
{"hexsha": "cc47ebfdcc5f7c94cc2334cdc7b4781d4f77576d", "ext": "java", "lang": "Java", "content": "public final class JsonObject extends JsonElement\n{\n\n\tpublic JsonObject()\n\t{\n\t//    0    0:aload_0         \n\t//    1    1:invokespecial   #11  <Method void JsonElement()>\n\t//    2    4:aload_0         \n\t//    3    5:new             #13  <Class LinkedTreeMap>\n\t//    4    8:dup             \n\t//    5    9:invokespecial   #14  <Method void LinkedTreeMap()>\n\t//    6   12:putfield        #16  <Field LinkedTreeMap members>\n\t//    7   15:return          \n\t}\n\n\tprivate JsonElement createJsonElement(Object obj)\n\t{\n\t\tif(obj == null)\n\t//*   0    0:aload_1         \n\t//*   1    1:ifnonnull       8\n\t\t\treturn ((JsonElement) (JsonNull.INSTANCE));\n\t//    2    4:getstatic       #25  <Field JsonNull JsonNull.INSTANCE>\n\t//    3    7:areturn         \n\t\telse\n\t\t\treturn ((JsonElement) (new JsonPrimitive(obj)));\n\t//    4    8:new             #27  <Class JsonPrimitive>\n\t//    5   11:dup             \n\t//    6   12:aload_1         \n\t//    7   13:invokespecial   #30  <Method void JsonPrimitive(Object)>\n\t//    8   16:areturn         \n\t}\n\n\tpublic void add(String s, JsonElement jsonelement)\n\t{\n\t\tObject obj = ((Object) (jsonelement));\n\t//    0    0:aload_2         \n\t//    1    1:astore_3        \n\t\tif(jsonelement == null)\n\t//*   2    2:aload_2         \n\t//*   3    3:ifnonnull       10\n\t\t\tobj = ((Object) (JsonNull.INSTANCE));\n\t//    4    6:getstatic       #25  <Field JsonNull JsonNull.INSTANCE>\n\t//    5    9:astore_3        \n\t\tmembers.put(((Object) (s)), obj);\n\t//    6   10:aload_0         \n\t//    7   11:getfield        #16  <Field LinkedTreeMap members>\n\t//    8   14:aload_1         \n\t//    9   15:aload_3         \n\t//   10   16:invokevirtual   #36  <Method Object LinkedTreeMap.put(Object, Object)>\n\t//   11   19:pop             \n\t//   12   20:return          \n\t}\n\n\tpublic void addProperty(String s, Boolean boolean1)\n\t{\n\t\tadd(s, createJsonElement(((Object) (boolean1))));\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:aload_0         \n\t//    3    3:aload_2         \n\t//    4    4:invokespecial   #40  <Method JsonElement createJsonElement(Object)>\n\t//    5    7:invokevirtual   #42  <Method void add(String, JsonElement)>\n\t//    6   10:return          \n\t}\n\n\tpublic void addProperty(String s, Character character)\n\t{\n\t\tadd(s, createJsonElement(((Object) (character))));\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:aload_0         \n\t//    3    3:aload_2         \n\t//    4    4:invokespecial   #40  <Method JsonElement createJsonElement(Object)>\n\t//    5    7:invokevirtual   #42  <Method void add(String, JsonElement)>\n\t//    6   10:return          \n\t}\n\n\tpublic void addProperty(String s, Number number)\n\t{\n\t\tadd(s, createJsonElement(((Object) (number))));\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:aload_0         \n\t//    3    3:aload_2         \n\t//    4    4:invokespecial   #40  <Method JsonElement createJsonElement(Object)>\n\t//    5    7:invokevirtual   #42  <Method void add(String, JsonElement)>\n\t//    6   10:return          \n\t}\n\n\tpublic void addProperty(String s, String s1)\n\t{\n\t\tadd(s, createJsonElement(((Object) (s1))));\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:aload_0         \n\t//    3    3:aload_2         \n\t//    4    4:invokespecial   #40  <Method JsonElement createJsonElement(Object)>\n\t//    5    7:invokevirtual   #42  <Method void add(String, JsonElement)>\n\t//    6   10:return          \n\t}\n\n\tvolatile JsonElement deepCopy()\n\t{\n\t\treturn ((JsonElement) (deepCopy()));\n\t//    0    0:aload_0         \n\t//    1    1:invokevirtual   #50  <Method JsonObject deepCopy()>\n\t//    2    4:areturn         \n\t}\n\n\tJsonObject deepCopy()\n\t{\n\t\tJsonObject jsonobject = new JsonObject();\n\t//    0    0:new             #2   <Class JsonObject>\n\t//    1    3:dup             \n\t//    2    4:invokespecial   #51  <Method void JsonObject()>\n\t//    3    7:astore_1        \n\t\tjava.util.Map.Entry entry;\n\t\tfor(Iterator iterator = members.entrySet().iterator(); iterator.hasNext(); jsonobject.add((String)entry.getKey(), ((JsonElement)entry.getValue()).deepCopy()))\n\t//*   4    8:aload_0         \n\t//*   5    9:getfield        #16  <Field LinkedTreeMap members>\n\t//*   6   12:invokevirtual   #55  <Method Set LinkedTreeMap.entrySet()>\n\t//*   7   15:invokeinterface #61  <Method Iterator Set.iterator()>\n\t//*   8   20:astore_2        \n\t//*   9   21:aload_2         \n\t//*  10   22:invokeinterface #67  <Method boolean Iterator.hasNext()>\n\t//*  11   27:ifeq            68\n\t\t\tentry = (java.util.Map.Entry)iterator.next();\n\t//   12   30:aload_2         \n\t//   13   31:invokeinterface #71  <Method Object Iterator.next()>\n\t//   14   36:checkcast       #73  <Class java.util.Map$Entry>\n\t//   15   39:astore_3        \n\n\t//   16   40:aload_1         \n\t//   17   41:aload_3         \n\t//   18   42:invokeinterface #76  <Method Object java.util.Map$Entry.getKey()>\n\t//   19   47:checkcast       #78  <Class String>\n\t//   20   50:aload_3         \n\t//   21   51:invokeinterface #81  <Method Object java.util.Map$Entry.getValue()>\n\t//   22   56:checkcast       #4   <Class JsonElement>\n\t//   23   59:invokevirtual   #83  <Method JsonElement JsonElement.deepCopy()>\n\t//   24   62:invokevirtual   #42  <Method void add(String, JsonElement)>\n\t//*  25   65:goto            21\n\t\treturn jsonobject;\n\t//   26   68:aload_1         \n\t//   27   69:areturn         \n\t}\n\n\tpublic Set entrySet()\n\t{\n\t\treturn members.entrySet();\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #16  <Field LinkedTreeMap members>\n\t//    2    4:invokevirtual   #55  <Method Set LinkedTreeMap.entrySet()>\n\t//    3    7:areturn         \n\t}\n\n\tpublic boolean equals(Object obj)\n\t{\n\t\treturn obj == this || (obj instanceof JsonObject) && ((JsonObject)obj).members.equals(((Object) (members)));\n\t//    0    0:aload_1         \n\t//    1    1:aload_0         \n\t//    2    2:if_acmpeq       34\n\t//    3    5:aload_1         \n\t//    4    6:instanceof      #2   <Class JsonObject>\n\t//    5    9:ifeq            32\n\t//    6   12:aload_1         \n\t//    7   13:checkcast       #2   <Class JsonObject>\n\t//    8   16:getfield        #16  <Field LinkedTreeMap members>\n\t//    9   19:aload_0         \n\t//   10   20:getfield        #16  <Field LinkedTreeMap members>\n\t//   11   23:invokevirtual   #89  <Method boolean LinkedTreeMap.equals(Object)>\n\t//   12   26:ifeq            32\n\t//   13   29:goto            34\n\t//   14   32:iconst_0        \n\t//   15   33:ireturn         \n\t//   16   34:iconst_1        \n\t//   17   35:ireturn         \n\t}\n\n\tpublic JsonElement get(String s)\n\t{\n\t\treturn (JsonElement)members.get(((Object) (s)));\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #16  <Field LinkedTreeMap members>\n\t//    2    4:aload_1         \n\t//    3    5:invokevirtual   #94  <Method Object LinkedTreeMap.get(Object)>\n\t//    4    8:checkcast       #4   <Class JsonElement>\n\t//    5   11:areturn         \n\t}\n\n\tpublic JsonArray getAsJsonArray(String s)\n\t{\n\t\treturn (JsonArray)members.get(((Object) (s)));\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #16  <Field LinkedTreeMap members>\n\t//    2    4:aload_1         \n\t//    3    5:invokevirtual   #94  <Method Object LinkedTreeMap.get(Object)>\n\t//    4    8:checkcast       #98  <Class JsonArray>\n\t//    5   11:areturn         \n\t}\n\n\tpublic JsonObject getAsJsonObject(String s)\n\t{\n\t\treturn (JsonObject)members.get(((Object) (s)));\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #16  <Field LinkedTreeMap members>\n\t//    2    4:aload_1         \n\t//    3    5:invokevirtual   #94  <Method Object LinkedTreeMap.get(Object)>\n\t//    4    8:checkcast       #2   <Class JsonObject>\n\t//    5   11:areturn         \n\t}\n\n\tpublic JsonPrimitive getAsJsonPrimitive(String s)\n\t{\n\t\treturn (JsonPrimitive)members.get(((Object) (s)));\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #16  <Field LinkedTreeMap members>\n\t//    2    4:aload_1         \n\t//    3    5:invokevirtual   #94  <Method Object LinkedTreeMap.get(Object)>\n\t//    4    8:checkcast       #27  <Class JsonPrimitive>\n\t//    5   11:areturn         \n\t}\n\n\tpublic boolean has(String s)\n\t{\n\t\treturn members.containsKey(((Object) (s)));\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #16  <Field LinkedTreeMap members>\n\t//    2    4:aload_1         \n\t//    3    5:invokevirtual   #107 <Method boolean LinkedTreeMap.containsKey(Object)>\n\t//    4    8:ireturn         \n\t}\n\n\tpublic int hashCode()\n\t{\n\t\treturn members.hashCode();\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #16  <Field LinkedTreeMap members>\n\t//    2    4:invokevirtual   #111 <Method int LinkedTreeMap.hashCode()>\n\t//    3    7:ireturn         \n\t}\n\n\tpublic JsonElement remove(String s)\n\t{\n\t\treturn (JsonElement)members.remove(((Object) (s)));\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #16  <Field LinkedTreeMap members>\n\t//    2    4:aload_1         \n\t//    3    5:invokevirtual   #114 <Method Object LinkedTreeMap.remove(Object)>\n\t//    4    8:checkcast       #4   <Class JsonElement>\n\t//    5   11:areturn         \n\t}\n\n\tprivate final LinkedTreeMap members = new LinkedTreeMap();\n}", "class_id": 0, "repo": "Andreas237/AndroidPolicyAutomation", "file": "ExtractedJars/iRobot_com.irobot.home/javafiles/com/google/gson/JsonObject.java", "last_update_at": "2019-07-06T22:21:59+00:00", "question_id": "cc47ebfdcc5f7c94cc2334cdc7b4781d4f77576d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class JsonObject extends JsonElement\n{\n\tpublic JsonObject()\n\t{\n\t//    0    0:aload_0         \n\t//    1    1:invokespecial   #11  <Method void JsonElement()>\n\t//    2    4:aload_0         \n\t//    3    5:new             #13  <Class LinkedTreeMap>\n\t//    4    8:dup             \n\t//    5    9:invokespecial   #14  <Method void LinkedTreeMap()>\n\t//    6   12:putfield        #16  <Field LinkedTreeMap members>\n\t//    7   15:return          \n\t}\n\tprivate JsonElement createJsonElement(Object obj)\n\t{\n\t\tif(obj == null)\n\t//*   0    0:aload_1         \n\t//*   1    1:ifnonnull       8\n\t\t\treturn ((JsonElement) (JsonNull.INSTANCE));\n\t//    2    4:getstatic       #25  <Field JsonNull JsonNull.INSTANCE>\n\t//    3    7:areturn         \n\t\telse\n\t\t\treturn ((JsonElement) (new JsonPrimitive(obj)));\n\t//    4    8:new             #27  <Class JsonPrimitive>\n\t//    5   11:dup             \n\t//    6   12:aload_1         \n\t//    7   13:invokespecial   #30  <Method void JsonPrimitive(Object)>\n\t//    8   16:areturn         \n\t}\n\tpublic void add(String s, JsonElement jsonelement)\n\t{\n\t\tObject obj = ((Object) (jsonelement));\n\t//    0    0:aload_2         \n\t//    1    1:astore_3        \n\t\tif(jsonelement == null)\n\t//*   2    2:aload_2         \n\t//*   3    3:ifnonnull       10\n\t\t\tobj = ((Object) (JsonNull.INSTANCE));\n\t//    4    6:getstatic       #25  <Field JsonNull JsonNull.INSTANCE>\n\t//    5    9:astore_3        \n\t\tmembers.put(((Object) (s)), obj);\n\t//    6   10:aload_0         \n\t//    7   11:getfield        #16  <Field LinkedTreeMap members>\n\t//    8   14:aload_1         \n\t//    9   15:aload_3         \n\t//   10   16:invokevirtual   #36  <Method Object LinkedTreeMap.put(Object, Object)>\n\t//   11   19:pop             \n\t//   12   20:return          \n\t}\n\tpublic void addProperty(String s, Boolean boolean1)\n\t{\n\t\tadd(s, createJsonElement(((Object) (boolean1))));\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:aload_0         \n\t//    3    3:aload_2         \n\t//    4    4:invokespecial   #40  <Method JsonElement createJsonElement(Object)>\n\t//    5    7:invokevirtual   #42  <Method void add(String, JsonElement)>\n\t//    6   10:return          \n\t}\n\tpublic void addProperty(String s, Character character)\n\t{\n\t\tadd(s, createJsonElement(((Object) (character))));\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:aload_0         \n\t//    3    3:aload_2         \n\t//    4    4:invokespecial   #40  <Method JsonElement createJsonElement(Object)>\n\t//    5    7:invokevirtual   #42  <Method void add(String, JsonElement)>\n\t//    6   10:return          \n\t}\n\tpublic void addProperty(String s, Number number)\n\t{\n\t\tadd(s, createJsonElement(((Object) (number))));\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:aload_0         \n\t//    3    3:aload_2         \n\t//    4    4:invokespecial   #40  <Method JsonElement createJsonElement(Object)>\n\t//    5    7:invokevirtual   #42  <Method void add(String, JsonElement)>\n\t//    6   10:return          \n\t}\n\tpublic void addProperty(String s, String s1)\n\t{\n\t\tadd(s, createJsonElement(((Object) (s1))));\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:aload_0         \n\t//    3    3:aload_2         \n\t//    4    4:invokespecial   #40  <Method JsonElement createJsonElement(Object)>\n\t//    5    7:invokevirtual   #42  <Method void add(String, JsonElement)>\n\t//    6   10:return          \n\t}\n\tvolatile JsonElement deepCopy()\n\t{\n\t\treturn ((JsonElement) (deepCopy()));\n\t//    0    0:aload_0         \n\t//    1    1:invokevirtual   #50  <Method JsonObject deepCopy()>\n\t//    2    4:areturn         \n\t}\n\tJsonObject deepCopy()\n\t{\n\t\tJsonObject jsonobject = new JsonObject();\n\t//    0    0:new             #2   <Class JsonObject>\n\t//    1    3:dup             \n\t//    2    4:invokespecial   #51  <Method void JsonObject()>\n\t//    3    7:astore_1        \n\t\tjava.util.Map.Entry entry;\n\t\tfor(Iterator iterator = members.entrySet().iterator(); iterator.hasNext(); jsonobject.add((String)entry.getKey(), ((JsonElement)entry.getValue()).deepCopy()))\n\t//*   4    8:aload_0         \n\t//*   5    9:getfield        #16  <Field LinkedTreeMap members>\n\t//*   6   12:invokevirtual   #55  <Method Set LinkedTreeMap.entrySet()>\n\t//*   7   15:invokeinterface #61  <Method Iterator Set.iterator()>\n\t//*   8   20:astore_2        \n\t//*   9   21:aload_2         \n\t//*  10   22:invokeinterface #67  <Method boolean Iterator.hasNext()>\n\t//*  11   27:ifeq            68\n\t\t\tentry = (java.util.Map.Entry)iterator.next();\n\t//   12   30:aload_2         \n\t//   13   31:invokeinterface #71  <Method Object Iterator.next()>\n\t//   14   36:checkcast       #73  <Class java.util.Map$Entry>\n\t//   15   39:astore_3        \n\t//   16   40:aload_1         \n\t//   17   41:aload_3         \n\t//   18   42:invokeinterface #76  <Method Object java.util.Map$Entry.getKey()>\n\t//   19   47:checkcast       #78  <Class String>\n\t//   20   50:aload_3         \n\t//   21   51:invokeinterface #81  <Method Object java.util.Map$Entry.getValue()>\n\t//   22   56:checkcast       #4   <Class JsonElement>\n\t//   23   59:invokevirtual   #83  <Method JsonElement JsonElement.deepCopy()>\n\t//   24   62:invokevirtual   #42  <Method void add(String, JsonElement)>\n\t//*  25   65:goto            21\n\t\treturn jsonobject;\n\t//   26   68:aload_1         \n\t//   27   69:areturn         \n\t}\n\tpublic Set entrySet()\n\t{\n\t\treturn members.entrySet();\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #16  <Field LinkedTreeMap members>\n\t//    2    4:invokevirtual   #55  <Method Set LinkedTreeMap.entrySet()>\n\t//    3    7:areturn         \n\t}\n\tpublic boolean equals(Object obj)\n\t{\n\t\treturn obj == this || (obj instanceof JsonObject) && ((JsonObject)obj).members.equals(((Object) (members)));\n\t//    0    0:aload_1         \n\t//    1    1:aload_0         \n\t//    2    2:if_acmpeq       34\n\t//    3    5:aload_1         \n\t//    4    6:instanceof      #2   <Class JsonObject>\n\t//    5    9:ifeq            32\n\t//    6   12:aload_1         \n\t//    7   13:checkcast       #2   <Class JsonObject>\n\t//    8   16:getfield        #16  <Field LinkedTreeMap members>\n\t//    9   19:aload_0         \n\t//   10   20:getfield        #16  <Field LinkedTreeMap members>\n\t//   11   23:invokevirtual   #89  <Method boolean LinkedTreeMap.equals(Object)>\n\t//   12   26:ifeq            32\n\t//   13   29:goto            34\n\t//   14   32:iconst_0        \n\t//   15   33:ireturn         \n\t//   16   34:iconst_1        \n\t//   17   35:ireturn         \n\t}\n\tpublic JsonElement get(String s)\n\t{\n\t\treturn (JsonElement)members.get(((Object) (s)));\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #16  <Field LinkedTreeMap members>\n\t//    2    4:aload_1         \n\t//    3    5:invokevirtual   #94  <Method Object LinkedTreeMap.get(Object)>\n\t//    4    8:checkcast       #4   <Class JsonElement>\n\t//    5   11:areturn         \n\t}\n\tpublic JsonArray getAsJsonArray(String s)\n\t{\n\t\treturn (JsonArray)members.get(((Object) (s)));\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #16  <Field LinkedTreeMap members>\n\t//    2    4:aload_1         \n\t//    3    5:invokevirtual   #94  <Method Object LinkedTreeMap.get(Object)>\n\t//    4    8:checkcast       #98  <Class JsonArray>\n\t//    5   11:areturn         \n\t}\n\tpublic JsonObject getAsJsonObject(String s)\n\t{\n\t\treturn (JsonObject)members.get(((Object) (s)));\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #16  <Field LinkedTreeMap members>\n\t//    2    4:aload_1         \n\t//    3    5:invokevirtual   #94  <Method Object LinkedTreeMap.get(Object)>\n\t//    4    8:checkcast       #2   <Class JsonObject>\n\t//    5   11:areturn         \n\t}\n\tpublic JsonPrimitive getAsJsonPrimitive(String s)\n\t{\n\t\treturn (JsonPrimitive)members.get(((Object) (s)));\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #16  <Field LinkedTreeMap members>\n\t//    2    4:aload_1         \n\t//    3    5:invokevirtual   #94  <Method Object LinkedTreeMap.get(Object)>\n\t//    4    8:checkcast       #27  <Class JsonPrimitive>\n\t//    5   11:areturn         \n\t}\n\tpublic boolean has(String s)\n\t{\n\t\treturn members.containsKey(((Object) (s)));\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #16  <Field LinkedTreeMap members>\n\t//    2    4:aload_1         \n\t//    3    5:invokevirtual   #107 <Method boolean LinkedTreeMap.containsKey(Object)>\n\t//    4    8:ireturn         \n\t}\n\tpublic int hashCode()\n\t{\n\t\treturn members.hashCode();\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #16  <Field LinkedTreeMap members>\n\t//    2    4:invokevirtual   #111 <Method int LinkedTreeMap.hashCode()>\n\t//    3    7:ireturn         \n\t}\n\tpublic JsonElement remove(String s)\n\t{\n\t\treturn (JsonElement)members.remove(((Object) (s)));\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #16  <Field LinkedTreeMap members>\n\t//    2    4:aload_1         \n\t//    3    5:invokevirtual   #114 <Method Object LinkedTreeMap.remove(Object)>\n\t//    4    8:checkcast       #4   <Class JsonElement>\n\t//    5   11:areturn         \n\t}\n\tprivate final LinkedTreeMap members = new LinkedTreeMap();\n"]]}
{"hexsha": "8afc2656232abb298c3d281da7d640e37fc58954", "ext": "java", "lang": "Java", "content": "class UnaryTable {\n  public static class Iter {\n    int index;\n    UnaryTable table;\n\n    public Iter(int index, UnaryTable table) {\n      this.table = table;\n      if (table.count == 0)\n        this.index = 64 * table.bitmap.length;\n      else {\n        this.index = index;\n        if (!table.contains(0))\n          next();\n      }\n    }\n\n    public int get() {\n      return index;\n    }\n\n    public boolean done() {\n      return index >= 64 * table.bitmap.length;\n    }\n\n    public void next() {\n      int size = 64 * table.bitmap.length;\n      do {\n        index++;\n      } while (index < size && !table.contains(index));\n    }\n  }\n\n\n  final int InitSize = 4;\n\n  long[] bitmap = new long[InitSize];\n  int count = 0;\n\n  public SurrObjMapper mapper;\n\n  public UnaryTable(SurrObjMapper mapper) {\n    this.mapper = mapper;\n  }\n\n  public int size() {\n    return count;\n  }\n\n  public boolean contains(int surr) {\n    int widx = surr / 64;\n    return widx < bitmap.length && ((bitmap[widx] >>> (int) (surr % 64) & 1) != 0);\n  }\n\n  public Iter getIter() {\n    return new Iter(0, this);\n  }\n\n  int liveCount() {\n    int liveCount = 0;\n    for (int i=0 ; i < bitmap.length ; i++) {\n      long mask = bitmap[i];\n      for (int j=0 ; j < 64 ; j++)\n        if (((mask >>> j) & 1) != 0)\n          liveCount++;\n    }\n    return liveCount;\n  }\n\n  public void insert(int surr) {\n    int widx = surr / 64;\n    int bidx = (int) (surr % 64);\n\n    int len = bitmap.length;\n    if (widx >= len) {\n      int newLen = 2 * len;\n      while (widx >= newLen)\n        newLen *= 2;\n      long[] newBitmap = new long[newLen];\n      Array.copy(bitmap, newBitmap, len);\n      bitmap = newBitmap;\n    }\n\n    long mask = bitmap[widx];\n    if (((mask >>> bidx) & 1) == 0) {\n      bitmap[widx] = mask | (1L << bidx);\n      count++;\n    }\n    // Miscellanea._assert(count == LiveCount());\n  }\n\n  public void delete(int surr) {\n    Miscellanea._assert(surr < 64 * bitmap.length);\n\n    int widx = surr / 64;\n    if (widx < bitmap.length) {\n      long mask = bitmap[widx];\n      int bidx = (int) surr % 64;\n      if (((mask >>> bidx) & 1) == 1) {\n        bitmap[widx] = mask & ~(1L << bidx);\n        count--;\n      }\n    }\n    // Miscellanea._assert(count == LiveCount());\n  }\n\n  public long[] clear(int minCapacity) {\n    count = 0;\n    int size = InitSize;\n    while (64 * size < minCapacity)\n      size *= 2;\n    long[] bitmapCopy = bitmap;\n    bitmap = new long[size];\n    return bitmapCopy;\n  }\n\n  public Obj copy() {\n    return copy(new UnaryTable[] {this});\n  }\n\n//    public static String IntToBinaryString(int number) {\n//      String binStr = \"\";\n//      while (number != 0) {\n//        binStr = (number & 1) + binStr;\n//        number = number >>> 1;\n//      }\n//      if (binStr == \"\")\n//        binStr = \"0\";\n//      return binStr;\n//    }\n//\n//    public static String IntToBinaryString(long number) {\n//      String binStr = \"\";\n//      while (number > 0) {\n//        binStr = (number & 1) + binStr;\n//        number = number >>> 1;\n//      }\n//      if (binStr == \"\")\n//        binStr = \"0\";\n//      return binStr;\n//    }\n\n  //////////////////////////////////////////////////////////////////////////////\n  //////////////////////////////////////////////////////////////////////////////\n\n  public static Obj copy(UnaryTable[] tables) {\n    int count = 0;\n    for (int i=0 ; i < tables.length ; i++)\n      count += tables[i].count;\n    if (count == 0)\n      return EmptyRelObj.singleton;\n    Obj[] objs = new Obj[count];\n    int next = 0;\n    for (int i=0 ; i < tables.length ; i++) {\n      UnaryTable table = tables[i];\n      SurrObjMapper mapper = table.mapper;\n      long[] bitmap = table.bitmap;\n      for (int j=0 ; j < bitmap.length ; j++) {\n        long mask = bitmap[j];\n        for (int k=0 ; k < 64 ; k++)\n          if (((mask >>> k) & 1) != 0)\n            objs[next++] = mapper.surrToObj(k + 64 * j);\n      }\n    }\n    Miscellanea._assert(next == count);\n    return Builder.createSet(objs, objs.length);\n  }\n}", "class_id": 0, "repo": "cell-lang/java", "file": "src/automata/net/cell_lang/UnaryTable.java", "last_update_at": "2019-04-05T19:37:37+00:00", "question_id": "8afc2656232abb298c3d281da7d640e37fc58954", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class UnaryTable {\n  public static class Iter {\n    int index;\n    UnaryTable table;\n    public Iter(int index, UnaryTable table) {\n      this.table = table;\n      if (table.count == 0)\n        this.index = 64 * table.bitmap.length;\n      else {\n        this.index = index;\n        if (!table.contains(0))\n          next();\n      }\n    }\n    public int get() {\n      return index;\n    }\n    public boolean done() {\n      return index >= 64 * table.bitmap.length;\n    }\n    public void next() {\n      int size = 64 * table.bitmap.length;\n      do {\n        index++;\n      } while (index < size && !table.contains(index));\n    }\n  }\n  final int InitSize = 4;\n  long[] bitmap = new long[InitSize];\n  int count = 0;\n  public SurrObjMapper mapper;\n  public UnaryTable(SurrObjMapper mapper) {\n    this.mapper = mapper;\n  }\n  public int size() {\n    return count;\n  }\n  public boolean contains(int surr) {\n    int widx = surr / 64;\n    return widx < bitmap.length && ((bitmap[widx] >>> (int) (surr % 64) & 1) != 0);\n  }\n  public Iter getIter() {\n    return new Iter(0, this);\n  }\n  int liveCount() {\n    int liveCount = 0;\n    for (int i=0 ; i < bitmap.length ; i++) {\n      long mask = bitmap[i];\n      for (int j=0 ; j < 64 ; j++)\n        if (((mask >>> j) & 1) != 0)\n          liveCount++;\n    }\n    return liveCount;\n  }\n  public void insert(int surr) {\n    int widx = surr / 64;\n    int bidx = (int) (surr % 64);\n    int len = bitmap.length;\n    if (widx >= len) {\n      int newLen = 2 * len;\n      while (widx >= newLen)\n        newLen *= 2;\n      long[] newBitmap = new long[newLen];\n      Array.copy(bitmap, newBitmap, len);\n      bitmap = newBitmap;\n    }\n    long mask = bitmap[widx];\n    if (((mask >>> bidx) & 1) == 0) {\n      bitmap[widx] = mask | (1L << bidx);\n      count++;\n    }\n    // Miscellanea._assert(count == LiveCount());\n  }\n  public void delete(int surr) {\n    Miscellanea._assert(surr < 64 * bitmap.length);\n    int widx = surr / 64;\n    if (widx < bitmap.length) {\n      long mask = bitmap[widx];\n      int bidx = (int) surr % 64;\n      if (((mask >>> bidx) & 1) == 1) {\n        bitmap[widx] = mask & ~(1L << bidx);\n        count--;\n      }\n    }\n    // Miscellanea._assert(count == LiveCount());\n  }\n  public long[] clear(int minCapacity) {\n    count = 0;\n    int size = InitSize;\n    while (64 * size < minCapacity)\n      size *= 2;\n    long[] bitmapCopy = bitmap;\n    bitmap = new long[size];\n    return bitmapCopy;\n  }\n  public Obj copy() {\n    return copy(new UnaryTable[] {this});\n  }\n//    public static String IntToBinaryString(int number) {\n//      String binStr = \"\";\n//      while (number != 0) {\n//        binStr = (number & 1) + binStr;\n//        number = number >>> 1;\n//      }\n//      if (binStr == \"\")\n//        binStr = \"0\";\n//      return binStr;\n//    }\n//\n//    public static String IntToBinaryString(long number) {\n//      String binStr = \"\";\n//      while (number > 0) {\n//        binStr = (number & 1) + binStr;\n//        number = number >>> 1;\n//      }\n//      if (binStr == \"\")\n//        binStr = \"0\";\n//      return binStr;\n//    }\n  //////////////////////////////////////////////////////////////////////////////\n  //////////////////////////////////////////////////////////////////////////////\n  public static Obj copy(UnaryTable[] tables) {\n    int count = 0;\n    for (int i=0 ; i < tables.length ; i++)\n      count += tables[i].count;\n    if (count == 0)\n      return EmptyRelObj.singleton;\n    Obj[] objs = new Obj[count];\n    int next = 0;\n    for (int i=0 ; i < tables.length ; i++) {\n      UnaryTable table = tables[i];\n      SurrObjMapper mapper = table.mapper;\n      long[] bitmap = table.bitmap;\n      for (int j=0 ; j < bitmap.length ; j++) {\n        long mask = bitmap[j];\n        for (int k=0 ; k < 64 ; k++)\n          if (((mask >>> k) & 1) != 0)\n            objs[next++] = mapper.surrToObj(k + 64 * j);\n      }\n    }\n    Miscellanea._assert(next == count);\n    return Builder.createSet(objs, objs.length);\n  }\n"]]}
{"hexsha": "aac22348abb6d23324c9d7af227e04e2519dcb68", "ext": "java", "lang": "Java", "content": "public class StatsResponseTests extends AbstractResponseTestCase<EnrichStatsAction.Response, StatsResponse> {\n\n    @Override\n    protected EnrichStatsAction.Response createServerTestInstance(XContentType xContentType) {\n        int numExecutingPolicies = randomIntBetween(0, 16);\n        List<EnrichStatsAction.Response.ExecutingPolicy> executingPolicies = new ArrayList<>(numExecutingPolicies);\n        for (int i = 0; i < numExecutingPolicies; i++) {\n            TaskInfo taskInfo = randomTaskInfo();\n            executingPolicies.add(new EnrichStatsAction.Response.ExecutingPolicy(randomAlphaOfLength(4), taskInfo));\n        }\n        int numCoordinatingStats = randomIntBetween(0, 16);\n        List<EnrichStatsAction.Response.CoordinatorStats> coordinatorStats = new ArrayList<>(numCoordinatingStats);\n        for (int i = 0; i < numCoordinatingStats; i++) {\n            EnrichStatsAction.Response.CoordinatorStats stats = new EnrichStatsAction.Response.CoordinatorStats(\n                randomAlphaOfLength(4), randomIntBetween(0, 8096), randomIntBetween(0, 8096), randomNonNegativeLong(),\n                randomNonNegativeLong());\n            coordinatorStats.add(stats);\n        }\n        return new EnrichStatsAction.Response(executingPolicies, coordinatorStats);\n    }\n\n    @Override\n    protected StatsResponse doParseToClientInstance(XContentParser parser) throws IOException {\n        return StatsResponse.fromXContent(parser);\n    }\n\n    @Override\n    protected void assertInstances(EnrichStatsAction.Response serverTestInstance, StatsResponse clientInstance) {\n        assertThat(clientInstance.getExecutingPolicies().size(), equalTo(serverTestInstance.getExecutingPolicies().size()));\n        for (int i = 0; i < clientInstance.getExecutingPolicies().size(); i++) {\n            StatsResponse.ExecutingPolicy actual = clientInstance.getExecutingPolicies().get(i);\n            EnrichStatsAction.Response.ExecutingPolicy expected = serverTestInstance.getExecutingPolicies().get(i);\n            assertThat(actual.getName(), equalTo(expected.getName()));\n            assertThat(actual.getTaskInfo(), equalTo(actual.getTaskInfo()));\n        }\n\n        assertThat(clientInstance.getCoordinatorStats().size(), equalTo(serverTestInstance.getCoordinatorStats().size()));\n        for (int i = 0; i < clientInstance.getCoordinatorStats().size(); i++) {\n            StatsResponse.CoordinatorStats actual = clientInstance.getCoordinatorStats().get(i);\n            EnrichStatsAction.Response.CoordinatorStats expected = serverTestInstance.getCoordinatorStats().get(i);\n            assertThat(actual.getNodeId(), equalTo(expected.getNodeId()));\n            assertThat(actual.getQueueSize(), equalTo(expected.getQueueSize()));\n            assertThat(actual.getRemoteRequestsCurrent(), equalTo(expected.getRemoteRequestsCurrent()));\n            assertThat(actual.getRemoteRequestsTotal(), equalTo(expected.getRemoteRequestsTotal()));\n            assertThat(actual.getExecutedSearchesTotal(), equalTo(expected.getExecutedSearchesTotal()));\n        }\n    }\n\n    private static TaskInfo randomTaskInfo() {\n        TaskId taskId = new TaskId(randomAlphaOfLength(5), randomLong());\n        String type = randomAlphaOfLength(5);\n        String action = randomAlphaOfLength(5);\n        String description = randomAlphaOfLength(5);\n        long startTime = randomLong();\n        long runningTimeNanos = randomLong();\n        boolean cancellable = randomBoolean();\n        TaskId parentTaskId = TaskId.EMPTY_TASK_ID;\n        Map<String, String> headers = randomBoolean() ?\n            Collections.emptyMap() :\n            Collections.singletonMap(randomAlphaOfLength(5), randomAlphaOfLength(5));\n        return new TaskInfo(taskId, type, action, description, null, startTime, runningTimeNanos, cancellable, parentTaskId, headers);\n    }\n}", "class_id": 0, "repo": "y-vectorfield/elasticsearch", "file": "client/rest-high-level/src/test/java/org/elasticsearch/client/enrich/StatsResponseTests.java", "last_update_at": "2019-11-21T09:10:53+00:00", "question_id": "aac22348abb6d23324c9d7af227e04e2519dcb68", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class StatsResponseTests extends AbstractResponseTestCase<EnrichStatsAction.Response, StatsResponse> {\n    @Override\n    protected EnrichStatsAction.Response createServerTestInstance(XContentType xContentType) {\n        int numExecutingPolicies = randomIntBetween(0, 16);\n        List<EnrichStatsAction.Response.ExecutingPolicy> executingPolicies = new ArrayList<>(numExecutingPolicies);\n        for (int i = 0; i < numExecutingPolicies; i++) {\n            TaskInfo taskInfo = randomTaskInfo();\n            executingPolicies.add(new EnrichStatsAction.Response.ExecutingPolicy(randomAlphaOfLength(4), taskInfo));\n        }\n        int numCoordinatingStats = randomIntBetween(0, 16);\n        List<EnrichStatsAction.Response.CoordinatorStats> coordinatorStats = new ArrayList<>(numCoordinatingStats);\n        for (int i = 0; i < numCoordinatingStats; i++) {\n            EnrichStatsAction.Response.CoordinatorStats stats = new EnrichStatsAction.Response.CoordinatorStats(\n                randomAlphaOfLength(4), randomIntBetween(0, 8096), randomIntBetween(0, 8096), randomNonNegativeLong(),\n                randomNonNegativeLong());\n            coordinatorStats.add(stats);\n        }\n        return new EnrichStatsAction.Response(executingPolicies, coordinatorStats);\n    }\n    @Override\n    protected StatsResponse doParseToClientInstance(XContentParser parser) throws IOException {\n        return StatsResponse.fromXContent(parser);\n    }\n    @Override\n    protected void assertInstances(EnrichStatsAction.Response serverTestInstance, StatsResponse clientInstance) {\n        assertThat(clientInstance.getExecutingPolicies().size(), equalTo(serverTestInstance.getExecutingPolicies().size()));\n        for (int i = 0; i < clientInstance.getExecutingPolicies().size(); i++) {\n            StatsResponse.ExecutingPolicy actual = clientInstance.getExecutingPolicies().get(i);\n            EnrichStatsAction.Response.ExecutingPolicy expected = serverTestInstance.getExecutingPolicies().get(i);\n            assertThat(actual.getName(), equalTo(expected.getName()));\n            assertThat(actual.getTaskInfo(), equalTo(actual.getTaskInfo()));\n        }\n        assertThat(clientInstance.getCoordinatorStats().size(), equalTo(serverTestInstance.getCoordinatorStats().size()));\n        for (int i = 0; i < clientInstance.getCoordinatorStats().size(); i++) {\n            StatsResponse.CoordinatorStats actual = clientInstance.getCoordinatorStats().get(i);\n            EnrichStatsAction.Response.CoordinatorStats expected = serverTestInstance.getCoordinatorStats().get(i);\n            assertThat(actual.getNodeId(), equalTo(expected.getNodeId()));\n            assertThat(actual.getQueueSize(), equalTo(expected.getQueueSize()));\n            assertThat(actual.getRemoteRequestsCurrent(), equalTo(expected.getRemoteRequestsCurrent()));\n            assertThat(actual.getRemoteRequestsTotal(), equalTo(expected.getRemoteRequestsTotal()));\n            assertThat(actual.getExecutedSearchesTotal(), equalTo(expected.getExecutedSearchesTotal()));\n        }\n    }\n    private static TaskInfo randomTaskInfo() {\n        TaskId taskId = new TaskId(randomAlphaOfLength(5), randomLong());\n        String type = randomAlphaOfLength(5);\n        String action = randomAlphaOfLength(5);\n        String description = randomAlphaOfLength(5);\n        long startTime = randomLong();\n        long runningTimeNanos = randomLong();\n        boolean cancellable = randomBoolean();\n        TaskId parentTaskId = TaskId.EMPTY_TASK_ID;\n        Map<String, String> headers = randomBoolean() ?\n            Collections.emptyMap() :\n            Collections.singletonMap(randomAlphaOfLength(5), randomAlphaOfLength(5));\n        return new TaskInfo(taskId, type, action, description, null, startTime, runningTimeNanos, cancellable, parentTaskId, headers);\n    }\n"]]}
{"hexsha": "cd2984fbc240149c4d17851a81de8c97e95bc149", "ext": "java", "lang": "Java", "content": "public class NewtonUnconstrainedTest extends TestCase {\r\n\tprivate DoubleFactory2D F2 = DoubleFactory2D.dense;\r\n\tprivate Log log = LogFactory.getLog(this.getClass().getName());\r\n\r\n\t/**\r\n\t * Quadratic objective.\r\n\t */\r\n\tpublic void testOptimize() throws Exception {\r\n\t\tlog.debug(\"testOptimize\");\r\n\t\t// START SNIPPET: newtonUnconstrained-1\r\n\t\t\r\n\t\tRealMatrix PMatrix = new Array2DRowRealMatrix(new double[][] {\r\n\t\t\t\t{ 1.68, 0.34, 0.38 },\r\n\t\t\t\t{ 0.34, 3.09, -1.59 }, \r\n\t\t\t\t{ 0.38, -1.59, 1.54 } });\r\n\t\tRealVector qVector = new ArrayRealVector(new double[] { 0.018, 0.025, 0.01 });\r\n\r\n\t    // Objective function.\r\n\t\tdouble theta = 0.01522;\r\n\t\tRealMatrix P = PMatrix.scalarMultiply(theta);\r\n\t\tRealVector q = qVector.mapMultiply(-1);\r\n\t\tPDQuadraticMultivariateRealFunction objectiveFunction = new PDQuadraticMultivariateRealFunction(P.getData(), q.toArray(), 0);\r\n\t\t\r\n\t\tOptimizationRequest or = new OptimizationRequest();\r\n\t\tor.setF0(objectiveFunction);\r\n\t\tor.setInitialPoint(new double[] {0.04, 0.50, 0.46});\r\n\t\tor.setTolerance(1.e-8);\r\n\t\t\r\n\t    //optimization\r\n\t\tNewtonUnconstrained opt = new NewtonUnconstrained();\r\n\t\topt.setOptimizationRequest(or);\r\n\t\tint returnCode = opt.optimize(); \r\n\t\t\r\n\t\t// END SNIPPET: newtonUnconstrained-1\r\n\t\t\r\n\t\tif(returnCode==OptimizationResponse.FAILED){\r\n\t\t\tfail();\r\n\t\t}\r\n\t\t\r\n\t\tOptimizationResponse response = opt.getOptimizationResponse();\r\n\t\tdouble[] sol = response.getSolution();\r\n\t\tlog.debug(\"sol   : \" + ArrayUtils.toString(sol));\r\n\t\tlog.debug(\"value : \"\t+ objectiveFunction.value(sol));\r\n\r\n\t\t// we know the analytic solution of the problem\r\n\t\t// sol = -PInv * q\r\n\t\tCholeskyDecomposition cFact = new CholeskyDecomposition(P);\r\n\t\tRealVector benchSol = cFact.getSolver().solve(q).mapMultiply(-1);\r\n\t\tlog.debug(\"benchSol   : \" + ArrayUtils.toString(benchSol.toArray()));\r\n\t\tlog.debug(\"benchValue : \" + objectiveFunction.value(benchSol.toArray()));\r\n\r\n\t\tassertEquals(benchSol.getEntry(0), sol[0], 0.00000000000001);\r\n\t\tassertEquals(benchSol.getEntry(1), sol[1], 0.00000000000001);\r\n\t\tassertEquals(benchSol.getEntry(2), sol[2], 0.00000000000001);\r\n\t}\r\n\r\n\t/**\r\n\t * Test with quite large positive definite symmetric matrix.\r\n\t */\r\n\tpublic void testOptimize2() throws Exception {\r\n\t\tlog.debug(\"testOptimize2\");\r\n\r\n\t\tint dim = 40;\r\n\t\t\r\n\t\t// positive definite matrix\r\n\t\tLong seed = new Long(54321);\r\n\t\tDoubleMatrix2D mySymmPD = Utils.randomValuesPositiveMatrix(dim, dim, -0.01, 15.5, seed);\r\n\t\tDoubleMatrix1D CVector = Utils.randomValuesMatrix(1, dim, -0.01, 15.5, seed).viewRow(0);\r\n\t\tMySymmFunction objectiveFunction = new MySymmFunction(mySymmPD,\tCVector);\r\n\t\t\r\n\t\t//optimization\r\n\t\tOptimizationRequest or = new OptimizationRequest();\r\n\t\tor.setF0(objectiveFunction);\r\n\t\tNewtonUnconstrained opt = new NewtonUnconstrained();\r\n\t\topt.setOptimizationRequest(or);\r\n\t\tint returnCode = opt.optimize();\r\n\t\t\r\n\t\tif(returnCode==OptimizationResponse.FAILED){\r\n\t\t\tfail();\r\n\t\t}\r\n\t\t\r\n\t\tOptimizationResponse response = opt.getOptimizationResponse();\r\n\t\tdouble[] sol = response.getSolution();\r\n\t\tlog.debug(\"sol   : \" + ArrayUtils.toString(sol));\r\n\t\tlog.debug(\"value : \" + objectiveFunction.value(sol));\r\n\t\t\r\n\t  // we know the analytic solution of the problem: Qinv.sol = - C\r\n\t\tcern.colt.matrix.linalg.CholeskyDecomposition cFact = new cern.colt.matrix.linalg.CholeskyDecomposition(mySymmPD);\r\n\t\tDoubleMatrix1D benchSol = cFact.solve(F2.make(CVector.copy().assign(Mult.mult(-1)).toArray(), CVector.size())).viewColumn(0);\r\n\t\tlog.debug(\"benchSol   : \" + ArrayUtils.toString(benchSol.toArray()));\r\n\t\tlog.debug(\"benchValue : \"\t+ objectiveFunction.value(benchSol.toArray()));\r\n\r\n\t\tfor(int i=0; i<dim;i++){\r\n\t\t\tassertEquals(benchSol.get(i), sol[i], 0.000001);\r\n\t\t}\r\n\t}\r\n\r\n\tprivate class MySymmFunction extends PDQuadraticMultivariateRealFunction {\r\n\r\n\t\tpublic MySymmFunction(DoubleMatrix2D P, DoubleMatrix1D q) {\r\n\t\t\tsuper(P.toArray(), q.toArray(), 0);\r\n\t\t}\r\n\r\n\t}\r\n}", "class_id": 0, "repo": "vincentk/joptimizer", "file": "src/test/java/com/joptimizer/optimizers/NewtonUnconstrainedTest.java", "last_update_at": "2019-06-03T02:16:41+00:00", "question_id": "cd2984fbc240149c4d17851a81de8c97e95bc149", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NewtonUnconstrainedTest extends TestCase {\r\n\tprivate DoubleFactory2D F2 = DoubleFactory2D.dense;\r\n\tprivate Log log = LogFactory.getLog(this.getClass().getName());\r\n\r\n\t/**\r\n\t * Quadratic objective.\r\n\t */\r\n\tpublic void testOptimize() throws Exception {\r\n\t\tlog.debug(\"testOptimize\");\r\n\t\t// START SNIPPET: newtonUnconstrained-1\r\n\t\t\r\n\t\tRealMatrix PMatrix = new Array2DRowRealMatrix(new double[][] {\r\n\t\t\t\t{ 1.68, 0.34, 0.38 },\r\n\t\t\t\t{ 0.34, 3.09, -1.59 }, \r\n\t\t\t\t{ 0.38, -1.59, 1.54 } });\r\n\t\tRealVector qVector = new ArrayRealVector(new double[] { 0.018, 0.025, 0.01 });\r\n\r\n\t    // Objective function.\r\n\t\tdouble theta = 0.01522;\r\n\t\tRealMatrix P = PMatrix.scalarMultiply(theta);\r\n\t\tRealVector q = qVector.mapMultiply(-1);\r\n\t\tPDQuadraticMultivariateRealFunction objectiveFunction = new PDQuadraticMultivariateRealFunction(P.getData(), q.toArray(), 0);\r\n\t\t\r\n\t\tOptimizationRequest or = new OptimizationRequest();\r\n\t\tor.setF0(objectiveFunction);\r\n\t\tor.setInitialPoint(new double[] {0.04, 0.50, 0.46});\r\n\t\tor.setTolerance(1.e-8);\r\n\t\t\r\n\t    //optimization\r\n\t\tNewtonUnconstrained opt = new NewtonUnconstrained();\r\n\t\topt.setOptimizationRequest(or);\r\n\t\tint returnCode = opt.optimize(); \r\n\t\t\r\n\t\t// END SNIPPET: newtonUnconstrained-1\r\n\t\t\r\n\t\tif(returnCode==OptimizationResponse.FAILED){\r\n\t\t\tfail();\r\n\t\t}\r\n\t\t\r\n\t\tOptimizationResponse response = opt.getOptimizationResponse();\r\n\t\tdouble[] sol = response.getSolution();\r\n\t\tlog.debug(\"sol   : \" + ArrayUtils.toString(sol));\r\n\t\tlog.debug(\"value : \"\t+ objectiveFunction.value(sol));\r\n\r\n\t\t// we know the analytic solution of the problem\r\n\t\t// sol = -PInv * q\r\n\t\tCholeskyDecomposition cFact = new CholeskyDecomposition(P);\r\n\t\tRealVector benchSol = cFact.getSolver().solve(q).mapMultiply(-1);\r\n\t\tlog.debug(\"benchSol   : \" + ArrayUtils.toString(benchSol.toArray()));\r\n\t\tlog.debug(\"benchValue : \" + objectiveFunction.value(benchSol.toArray()));\r\n\r\n\t\tassertEquals(benchSol.getEntry(0), sol[0], 0.00000000000001);\r\n\t\tassertEquals(benchSol.getEntry(1), sol[1], 0.00000000000001);\r\n\t\tassertEquals(benchSol.getEntry(2), sol[2], 0.00000000000001);\r\n\t}\r\n\r\n\t/**\r\n\t * Test with quite large positive definite symmetric matrix.\r\n\t */\r\n\tpublic void testOptimize2() throws Exception {\r\n\t\tlog.debug(\"testOptimize2\");\r\n\r\n\t\tint dim = 40;\r\n\t\t\r\n\t\t// positive definite matrix\r\n\t\tLong seed = new Long(54321);\r\n\t\tDoubleMatrix2D mySymmPD = Utils.randomValuesPositiveMatrix(dim, dim, -0.01, 15.5, seed);\r\n\t\tDoubleMatrix1D CVector = Utils.randomValuesMatrix(1, dim, -0.01, 15.5, seed).viewRow(0);\r\n\t\tMySymmFunction objectiveFunction = new MySymmFunction(mySymmPD,\tCVector);\r\n\t\t\r\n\t\t//optimization\r\n\t\tOptimizationRequest or = new OptimizationRequest();\r\n\t\tor.setF0(objectiveFunction);\r\n\t\tNewtonUnconstrained opt = new NewtonUnconstrained();\r\n\t\topt.setOptimizationRequest(or);\r\n\t\tint returnCode = opt.optimize();\r\n\t\t\r\n\t\tif(returnCode==OptimizationResponse.FAILED){\r\n\t\t\tfail();\r\n\t\t}\r\n\t\t\r\n\t\tOptimizationResponse response = opt.getOptimizationResponse();\r\n\t\tdouble[] sol = response.getSolution();\r\n\t\tlog.debug(\"sol   : \" + ArrayUtils.toString(sol));\r\n\t\tlog.debug(\"value : \" + objectiveFunction.value(sol));\r\n\t\t\r\n\t  // we know the analytic solution of the problem: Qinv.sol = - C\r\n\t\tcern.colt.matrix.linalg.CholeskyDecomposition cFact = new cern.colt.matrix.linalg.CholeskyDecomposition(mySymmPD);\r\n\t\tDoubleMatrix1D benchSol = cFact.solve(F2.make(CVector.copy().assign(Mult.mult(-1)).toArray(), CVector.size())).viewColumn(0);\r\n\t\tlog.debug(\"benchSol   : \" + ArrayUtils.toString(benchSol.toArray()));\r\n\t\tlog.debug(\"benchValue : \"\t+ objectiveFunction.value(benchSol.toArray()));\r\n\r\n\t\tfor(int i=0; i<dim;i++){\r\n\t\t\tassertEquals(benchSol.get(i), sol[i], 0.000001);\r\n\t\t}\r\n\t}\r\n\r\n\tprivate class MySymmFunction extends PDQuadraticMultivariateRealFunction {\r\n\r\n\t\tpublic MySymmFunction(DoubleMatrix2D P, DoubleMatrix1D q) {\r\n\t\t\tsuper(P.toArray(), q.toArray(), 0);\r\n\t\t}\r\n\r\n\t}\r\n"]]}
{"hexsha": "de35dba180a26948b2d5f6beab387b8e3c2b8f95", "ext": "java", "lang": "Java", "content": "public class GenericDeserializer extends JsonDeserializer<Object> {\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        JsonNode node = p.getCodec().readTree(p);\n        String className = node.get(\"@class\").asText();\n        Class<?> c;\n        try {\n            c = Class.forName(className);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n\n        JsonNode valueNode = node.get(\"value\");\n        Object o = new ObjectMapper().treeToValue(valueNode, c);\n        return o;\n    }\n}", "class_id": 0, "repo": "rghwer/testdocs", "file": "arbiter/arbiter-core/src/main/java/org/deeplearning4j/arbiter/optimize/serde/jackson/GenericDeserializer.java", "last_update_at": "2019-04-12T09:31:03+00:00", "question_id": "de35dba180a26948b2d5f6beab387b8e3c2b8f95", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GenericDeserializer extends JsonDeserializer<Object> {\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        JsonNode node = p.getCodec().readTree(p);\n        String className = node.get(\"@class\").asText();\n        Class<?> c;\n        try {\n            c = Class.forName(className);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        JsonNode valueNode = node.get(\"value\");\n        Object o = new ObjectMapper().treeToValue(valueNode, c);\n        return o;\n    }\n"]]}
{"hexsha": "98a43751f61b2282759e3165647f194c7c736d5d", "ext": "java", "lang": "Java", "content": "public class ParabolicSarIndicator extends RecursiveCachedIndicator<Num> {\n\n    private final Num maxAcceleration;\n    private final Num accelerationIncrement;\n    private final Num accelerationStart;\n    private Num accelerationFactor;\n    private boolean currentTrend; // true if uptrend, false otherwise\n    private int startTrendIndex = 0; // index of start bar of the current trend\n    private LowPriceIndicator lowPriceIndicator;\n    private HighPriceIndicator highPriceIndicator;\n    private Num currentExtremePoint; // the extreme point of the current calculation\n    private Num minMaxExtremePoint; // depending on trend the maximum or minimum extreme point value of trend\n\n    /**\n     * Constructor with default parameters\n     *\n     * @param series the bar series for this indicator\n     */\n    public ParabolicSarIndicator(BarSeries series) {\n        this(series, series.numOf(0.02), series.numOf(0.2), series.numOf(0.02));\n\n    }\n\n    /**\n     * Constructor with custom parameters and default increment value\n     *\n     * @param series the bar series for this indicator\n     * @param aF     acceleration factor\n     * @param maxA   maximum acceleration\n     */\n    public ParabolicSarIndicator(BarSeries series, Num aF, Num maxA) {\n        this(series, aF, maxA, series.numOf(0.02));\n    }\n\n    /**\n     * Constructor with custom parameters\n     *\n     * @param series    the bar series for this indicator\n     * @param aF        acceleration factor\n     * @param maxA      maximum acceleration\n     * @param increment the increment step\n     */\n    public ParabolicSarIndicator(BarSeries series, Num aF, Num maxA, Num increment) {\n        super(series);\n        highPriceIndicator = new HighPriceIndicator(series);\n        lowPriceIndicator = new LowPriceIndicator(series);\n        maxAcceleration = maxA;\n        accelerationFactor = aF;\n        accelerationIncrement = increment;\n        accelerationStart = aF;\n    }\n\n    @Override\n    protected Num calculate(int index) {\n        Num sar = NaN;\n        if (index == getBarSeries().getBeginIndex()) {\n            return sar; // no trend detection possible for the first value\n        } else if (index == getBarSeries().getBeginIndex() + 1) {// start trend detection\n            currentTrend = getBarSeries().getBar(getBarSeries().getBeginIndex()).getClosePrice()\n                    .isLessThan(getBarSeries().getBar(index).getClosePrice());\n            if (!currentTrend) { // down trend\n                sar = highPriceIndicator.getValue(index); // put sar on max price of candlestick\n                currentExtremePoint = sar;\n                minMaxExtremePoint = currentExtremePoint;\n            } else { // up trend\n                sar = lowPriceIndicator.getValue(index); // put sar on min price of candlestick\n                currentExtremePoint = sar;\n                minMaxExtremePoint = currentExtremePoint;\n\n            }\n            return sar;\n        }\n\n        Num priorSar = getValue(index - 1);\n        if (currentTrend) { // if up trend\n            sar = priorSar.plus(accelerationFactor.multipliedBy((currentExtremePoint.minus(priorSar))));\n            currentTrend = lowPriceIndicator.getValue(index).isGreaterThan(sar);\n            if (!currentTrend) { // check if sar touches the min price\n                sar = minMaxExtremePoint; // sar starts at the highest extreme point of previous up trend\n                currentTrend = false; // switch to down trend and reset values\n                startTrendIndex = index;\n                accelerationFactor = accelerationStart;\n                currentExtremePoint = getBarSeries().getBar(index).getLowPrice(); // put point on max\n                minMaxExtremePoint = currentExtremePoint;\n            } else { // up trend is going on\n                currentExtremePoint = new HighestValueIndicator(highPriceIndicator, index - startTrendIndex)\n                        .getValue(index);\n                if (currentExtremePoint.isGreaterThan(minMaxExtremePoint)) {\n                    incrementAcceleration();\n                    minMaxExtremePoint = currentExtremePoint;\n                }\n\n            }\n        } else { // downtrend\n            sar = priorSar.minus(accelerationFactor.multipliedBy(((priorSar.minus(currentExtremePoint)))));\n            currentTrend = highPriceIndicator.getValue(index).isGreaterThanOrEqual(sar);\n            if (currentTrend) { // check if switch to up trend\n                sar = minMaxExtremePoint; // sar starts at the lowest extreme point of previous down trend\n                accelerationFactor = accelerationStart;\n                startTrendIndex = index;\n                currentExtremePoint = getBarSeries().getBar(index).getHighPrice();\n                minMaxExtremePoint = currentExtremePoint;\n            } else { // down trend io going on\n                currentExtremePoint = new LowestValueIndicator(lowPriceIndicator, index - startTrendIndex)\n                        .getValue(index);\n                if (currentExtremePoint.isLessThan(minMaxExtremePoint)) {\n                    incrementAcceleration();\n                    minMaxExtremePoint = currentExtremePoint;\n                }\n            }\n        }\n        return sar;\n    }\n\n    /**\n     * Increments the acceleration factor.\n     */\n    private void incrementAcceleration() {\n        if (accelerationFactor.isGreaterThanOrEqual(maxAcceleration)) {\n            accelerationFactor = maxAcceleration;\n        } else {\n            accelerationFactor = accelerationFactor.plus(accelerationIncrement);\n        }\n    }\n}", "class_id": 0, "repo": "Viserius/ta4j", "file": "ta4j-core/src/main/java/org/ta4j/core/indicators/ParabolicSarIndicator.java", "last_update_at": "2019-09-02T09:05:31+00:00", "question_id": "98a43751f61b2282759e3165647f194c7c736d5d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ParabolicSarIndicator extends RecursiveCachedIndicator<Num> {\n    private final Num maxAcceleration;\n    private final Num accelerationIncrement;\n    private final Num accelerationStart;\n    private Num accelerationFactor;\n    private boolean currentTrend; // true if uptrend, false otherwise\n    private int startTrendIndex = 0; // index of start bar of the current trend\n    private LowPriceIndicator lowPriceIndicator;\n    private HighPriceIndicator highPriceIndicator;\n    private Num currentExtremePoint; // the extreme point of the current calculation\n    private Num minMaxExtremePoint; // depending on trend the maximum or minimum extreme point value of trend\n    /**\n     * Constructor with default parameters\n     *\n     * @param series the bar series for this indicator\n     */\n    public ParabolicSarIndicator(BarSeries series) {\n        this(series, series.numOf(0.02), series.numOf(0.2), series.numOf(0.02));\n    }\n    /**\n     * Constructor with custom parameters and default increment value\n     *\n     * @param series the bar series for this indicator\n     * @param aF     acceleration factor\n     * @param maxA   maximum acceleration\n     */\n    public ParabolicSarIndicator(BarSeries series, Num aF, Num maxA) {\n        this(series, aF, maxA, series.numOf(0.02));\n    }\n    /**\n     * Constructor with custom parameters\n     *\n     * @param series    the bar series for this indicator\n     * @param aF        acceleration factor\n     * @param maxA      maximum acceleration\n     * @param increment the increment step\n     */\n    public ParabolicSarIndicator(BarSeries series, Num aF, Num maxA, Num increment) {\n        super(series);\n        highPriceIndicator = new HighPriceIndicator(series);\n        lowPriceIndicator = new LowPriceIndicator(series);\n        maxAcceleration = maxA;\n        accelerationFactor = aF;\n        accelerationIncrement = increment;\n        accelerationStart = aF;\n    }\n    @Override\n    protected Num calculate(int index) {\n        Num sar = NaN;\n        if (index == getBarSeries().getBeginIndex()) {\n            return sar; // no trend detection possible for the first value\n        } else if (index == getBarSeries().getBeginIndex() + 1) {// start trend detection\n            currentTrend = getBarSeries().getBar(getBarSeries().getBeginIndex()).getClosePrice()\n                    .isLessThan(getBarSeries().getBar(index).getClosePrice());\n            if (!currentTrend) { // down trend\n                sar = highPriceIndicator.getValue(index); // put sar on max price of candlestick\n                currentExtremePoint = sar;\n                minMaxExtremePoint = currentExtremePoint;\n            } else { // up trend\n                sar = lowPriceIndicator.getValue(index); // put sar on min price of candlestick\n                currentExtremePoint = sar;\n                minMaxExtremePoint = currentExtremePoint;\n            }\n            return sar;\n        }\n        Num priorSar = getValue(index - 1);\n        if (currentTrend) { // if up trend\n            sar = priorSar.plus(accelerationFactor.multipliedBy((currentExtremePoint.minus(priorSar))));\n            currentTrend = lowPriceIndicator.getValue(index).isGreaterThan(sar);\n            if (!currentTrend) { // check if sar touches the min price\n                sar = minMaxExtremePoint; // sar starts at the highest extreme point of previous up trend\n                currentTrend = false; // switch to down trend and reset values\n                startTrendIndex = index;\n                accelerationFactor = accelerationStart;\n                currentExtremePoint = getBarSeries().getBar(index).getLowPrice(); // put point on max\n                minMaxExtremePoint = currentExtremePoint;\n            } else { // up trend is going on\n                currentExtremePoint = new HighestValueIndicator(highPriceIndicator, index - startTrendIndex)\n                        .getValue(index);\n                if (currentExtremePoint.isGreaterThan(minMaxExtremePoint)) {\n                    incrementAcceleration();\n                    minMaxExtremePoint = currentExtremePoint;\n                }\n            }\n        } else { // downtrend\n            sar = priorSar.minus(accelerationFactor.multipliedBy(((priorSar.minus(currentExtremePoint)))));\n            currentTrend = highPriceIndicator.getValue(index).isGreaterThanOrEqual(sar);\n            if (currentTrend) { // check if switch to up trend\n                sar = minMaxExtremePoint; // sar starts at the lowest extreme point of previous down trend\n                accelerationFactor = accelerationStart;\n                startTrendIndex = index;\n                currentExtremePoint = getBarSeries().getBar(index).getHighPrice();\n                minMaxExtremePoint = currentExtremePoint;\n            } else { // down trend io going on\n                currentExtremePoint = new LowestValueIndicator(lowPriceIndicator, index - startTrendIndex)\n                        .getValue(index);\n                if (currentExtremePoint.isLessThan(minMaxExtremePoint)) {\n                    incrementAcceleration();\n                    minMaxExtremePoint = currentExtremePoint;\n                }\n            }\n        }\n        return sar;\n    }\n    /**\n     * Increments the acceleration factor.\n     */\n    private void incrementAcceleration() {\n        if (accelerationFactor.isGreaterThanOrEqual(maxAcceleration)) {\n            accelerationFactor = maxAcceleration;\n        } else {\n            accelerationFactor = accelerationFactor.plus(accelerationIncrement);\n        }\n    }\n"]]}
{"hexsha": "fe118556438da80f134e4a6a3ebb2b62dd7f3c8a", "ext": "java", "lang": "Java", "content": "public class BorderedRectangle implements Widget {\n\n    /**\n     * onepixel texture.\n     */\n    private Texture pixel;\n\n    private float x;\n    private float y;\n    private float width;\n    private float height;\n\n    public BorderedRectangle(Texture pixel, int x, int y, int width, int height) {\n        this.pixel = pixel;\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n\n    @Override\n    public void render(Renderer renderer) {\n        renderer.begin();\n        pixel.bind();\n        drawRect(renderer, x, y, width, height, Color.BLACK);\n        drawRect(renderer, x + 1, y + 1, width - 2, height - 2, Color.WHITE);\n        renderer.end();\n    }\n\n    private static void drawRect(Renderer renderer, float x, float y, float width, float height, Color color) {\n        renderer.drawTextureRegion(\n                x, y,\n                x + width, y + height,\n                0f, 0f,\n                1f, 1f,\n                color);\n    }\n}", "class_id": 0, "repo": "msteiger/SplashScreens", "file": "src/main/java/org/terasology/splash/glfw/widgets/BorderedRectangle.java", "last_update_at": "2019-01-04T04:17:32+00:00", "question_id": "fe118556438da80f134e4a6a3ebb2b62dd7f3c8a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BorderedRectangle implements Widget {\n    /**\n     * onepixel texture.\n     */\n    private Texture pixel;\n    private float x;\n    private float y;\n    private float width;\n    private float height;\n    public BorderedRectangle(Texture pixel, int x, int y, int width, int height) {\n        this.pixel = pixel;\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    @Override\n    public void render(Renderer renderer) {\n        renderer.begin();\n        pixel.bind();\n        drawRect(renderer, x, y, width, height, Color.BLACK);\n        drawRect(renderer, x + 1, y + 1, width - 2, height - 2, Color.WHITE);\n        renderer.end();\n    }\n    private static void drawRect(Renderer renderer, float x, float y, float width, float height, Color color) {\n        renderer.drawTextureRegion(\n                x, y,\n                x + width, y + height,\n                0f, 0f,\n                1f, 1f,\n                color);\n    }\n"]]}
{"hexsha": "015ae58a1c6e892578967f6ca10a7ca6ac07bfaa", "ext": "java", "lang": "Java", "content": "public class Disabled {\n    \n    public static void init() {\n        Command a = new RumbleOff();\n        a.start();\n        Scheduler.getInstance().removeAll();\n        a.close();\n        Robot.vision.teleopInit();\n    }\n\n    //Periodic method called roughly once every 20ms\n    public static void periodic() {\n        Scheduler.getInstance().run();\n    }\n}", "class_id": 0, "repo": "Spectrum3847/MCC-2019", "file": "src/main/java/frc/robot/Disabled.java", "last_update_at": "2019-04-26T09:13:43+00:00", "question_id": "015ae58a1c6e892578967f6ca10a7ca6ac07bfaa", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Disabled {\n    public static void init() {\n        Command a = new RumbleOff();\n        a.start();\n        Scheduler.getInstance().removeAll();\n        a.close();\n        Robot.vision.teleopInit();\n    }\n    //Periodic method called roughly once every 20ms\n    public static void periodic() {\n        Scheduler.getInstance().run();\n    }\n"]]}
{"hexsha": "067a1f566ea53e71034717887a5dd1a38c3c2170", "ext": "java", "lang": "Java", "content": "public class MapReference<E> implements Reference<E> {\n    private final String name;\n    private final Class<E> eClass;\n    private final MapView<String, E> underlyingMap;\n    @NotNull\n    private final Asset asset;\n\n    public MapReference(@NotNull RequestContext context, @NotNull Asset asset, MapView<String, E> underlying) throws AssetNotFoundException {\n        this(context.name(), context.type(), asset, underlying);\n    }\n\n    public MapReference(String name, Class<E> type, @NotNull Asset asset, MapView<String, E> mapView) {\n        assert asset != null;\n        this.name = name;\n        this.eClass = type;\n        this.asset = asset;\n        this.underlyingMap = mapView;\n        assert underlyingMap != null;\n    }\n\n    @Override\n    public long set(E event) {\n        underlyingMap.set(name, event);\n        return 0;\n    }\n\n    @Nullable\n    @Override\n    public E get() {\n        return underlyingMap.get(name);\n    }\n\n    @Override\n    public void remove() {\n        underlyingMap.remove(name);\n    }\n\n    @Override\n    public void registerSubscriber(boolean bootstrap, int throttlePeriodMs, @NotNull Subscriber<E> subscriber) throws AssetNotFoundException {\n\n        asset.subscription(true)\n                .registerSubscriber(requestContext()\n                                .bootstrap(bootstrap)\n                                .throttlePeriodMs(throttlePeriodMs)\n                                .type(eClass),\n                        subscriber, Filter.empty());\n    }\n\n    @Override\n    public void unregisterSubscriber(@NotNull Subscriber subscriber) {\n        @Nullable SubscriptionCollection subscription = asset.subscription(false);\n        if (subscription != null)\n            subscription.unregisterSubscriber(subscriber);\n    }\n\n    @Override\n    public int subscriberCount() {\n        @Nullable SubscriptionCollection subscription = asset.subscription(false);\n        if (subscription != null)\n            return subscription.subscriberCount();\n        return 0;\n    }\n\n    @Override\n    public Class getType() {\n        return eClass;\n    }\n\n    @NotNull\n    @Override\n    public String toString() {\n        return \"MapReference{\" +\n                \"name='\" + name + '\\'' +\n                \", eClass=\" + eClass +\n                '}';\n    }\n}", "class_id": 0, "repo": "tchen0123/Chronicle-Engine", "file": "src/main/java/net/openhft/chronicle/engine/pubsub/MapReference.java", "last_update_at": "2019-12-25T08:35:31+00:00", "question_id": "067a1f566ea53e71034717887a5dd1a38c3c2170", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MapReference<E> implements Reference<E> {\n    private final String name;\n    private final Class<E> eClass;\n    private final MapView<String, E> underlyingMap;\n    @NotNull\n    private final Asset asset;\n    public MapReference(@NotNull RequestContext context, @NotNull Asset asset, MapView<String, E> underlying) throws AssetNotFoundException {\n        this(context.name(), context.type(), asset, underlying);\n    }\n    public MapReference(String name, Class<E> type, @NotNull Asset asset, MapView<String, E> mapView) {\n        assert asset != null;\n        this.name = name;\n        this.eClass = type;\n        this.asset = asset;\n        this.underlyingMap = mapView;\n        assert underlyingMap != null;\n    }\n    @Override\n    public long set(E event) {\n        underlyingMap.set(name, event);\n        return 0;\n    }\n    @Nullable\n    @Override\n    public E get() {\n        return underlyingMap.get(name);\n    }\n    @Override\n    public void remove() {\n        underlyingMap.remove(name);\n    }\n    @Override\n    public void registerSubscriber(boolean bootstrap, int throttlePeriodMs, @NotNull Subscriber<E> subscriber) throws AssetNotFoundException {\n        asset.subscription(true)\n                .registerSubscriber(requestContext()\n                                .bootstrap(bootstrap)\n                                .throttlePeriodMs(throttlePeriodMs)\n                                .type(eClass),\n                        subscriber, Filter.empty());\n    }\n    @Override\n    public void unregisterSubscriber(@NotNull Subscriber subscriber) {\n        @Nullable SubscriptionCollection subscription = asset.subscription(false);\n        if (subscription != null)\n            subscription.unregisterSubscriber(subscriber);\n    }\n    @Override\n    public int subscriberCount() {\n        @Nullable SubscriptionCollection subscription = asset.subscription(false);\n        if (subscription != null)\n            return subscription.subscriberCount();\n        return 0;\n    }\n    @Override\n    public Class getType() {\n        return eClass;\n    }\n    @NotNull\n    @Override\n    public String toString() {\n        return \"MapReference{\" +\n                \"name='\" + name + '\\'' +\n                \", eClass=\" + eClass +\n                '}';\n    }\n"]]}
{"hexsha": "8d541a1d9f20d73c4badbd20839a934045baf6a1", "ext": "java", "lang": "Java", "content": "public class SumNumbers {\n  public static void main(String[] args) {\n    String sample = \"aa11b33\";\n    System.out.println(\"Output : \" + sumNumbers(sample));\n  }\n\n  /**\n   * Sum the numbers in the given string.\n   * @param str\n   * @return\n   */\n  public static int sumNumbers(String str) {\n    int sum = 0;\n    StringBuffer str_number = new StringBuffer();\n    for (int i = 0; i < str.length(); i++) {\n      if (Character.isDigit(str.charAt(i))) {\n        str_number.append(str.charAt(i));\n      } else if (str_number.length() > 0) {\n        sum = sum + Integer.parseInt(str_number.toString());\n        str_number = new StringBuffer();\n      }\n    }\n    if (str_number.length() > 0) {\n      sum = sum + Integer.parseInt(str_number.toString());\n      return sum;\n    }\n    return sum;\n  }\n}", "class_id": 0, "repo": "taadu/fang_dreamer", "file": "src/main/java/com/fang/dreamer/strings/SumNumbers.java", "last_update_at": "2019-01-07T02:04:02+00:00", "question_id": "8d541a1d9f20d73c4badbd20839a934045baf6a1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SumNumbers {\n  public static void main(String[] args) {\n    String sample = \"aa11b33\";\n    System.out.println(\"Output : \" + sumNumbers(sample));\n  }\n  /**\n   * Sum the numbers in the given string.\n   * @param str\n   * @return\n   */\n  public static int sumNumbers(String str) {\n    int sum = 0;\n    StringBuffer str_number = new StringBuffer();\n    for (int i = 0; i < str.length(); i++) {\n      if (Character.isDigit(str.charAt(i))) {\n        str_number.append(str.charAt(i));\n      } else if (str_number.length() > 0) {\n        sum = sum + Integer.parseInt(str_number.toString());\n        str_number = new StringBuffer();\n      }\n    }\n    if (str_number.length() > 0) {\n      sum = sum + Integer.parseInt(str_number.toString());\n      return sum;\n    }\n    return sum;\n  }\n"]]}
{"hexsha": "7c3747bfd629bc2021240fec64ad1bf506105983", "ext": "java", "lang": "Java", "content": "public class Cleanup01\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tboolean success = false;\n\t\tboolean trying = true;\n\t\tint tries = 0;\n\n\t\ttry\n\t\t{\n\t\t\tORBInterface.initORB(args, null);\n\t\t\tOAInterface.initOA();\n\n\t\t\tString profileName = args[args.length - 1];\n\n\t\t\tint numberOfDrivers = JDBCProfileStore.numberOfDrivers(profileName);\n\t\t\tfor (int index = 0; index < numberOfDrivers; index++)\n\t\t\t{\n\t\t\t\tString driver = JDBCProfileStore.driver(profileName, index);\n\n\t\t\t\tClass.forName(driver);\n\t\t\t}\n\n\t\t\tString databaseURL = JDBCProfileStore.databaseURL(profileName);\n\t\t\tString databaseUser = JDBCProfileStore.databaseUser(profileName);\n\t\t\tString databasePassword = JDBCProfileStore.databasePassword(profileName);\n\t\t\tString databaseDynamicClass = JDBCProfileStore.databaseDynamicClass(profileName);\n\n\t\t\tConnection connection;\n\t\t\tif (databaseDynamicClass != null)\n\t\t\t{\n\t\t\t\tProperties databaseProperties = new Properties();\n\n\t\t\t\tdatabaseProperties.put(com.arjuna.ats.jdbc.TransactionalDriver.userName, databaseUser);\n\t\t\t\tdatabaseProperties.put(com.arjuna.ats.jdbc.TransactionalDriver.password, databasePassword);\n\t\t\t\tdatabaseProperties.put(com.arjuna.ats.jdbc.TransactionalDriver.dynamicClass, databaseDynamicClass);\n\n\t\t\t\tconnection = DriverManager.getConnection(databaseURL, databaseProperties);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tconnection = DriverManager.getConnection(databaseURL, databaseUser, databasePassword);\n\t\t\t}\n\n            String tableName = JDBCProfileStore.getTableName(databaseUser, \"Infotable\");\n            \n\t\t\twhile (trying)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tStatement statement = connection.createStatement();\n\n\t\t\t\t\tSystem.err.println(\"DROP TABLE \" + tableName);\n\t\t\t\t\tstatement.executeUpdate(\"DROP TABLE \" + tableName);\n\n\t\t\t\t\tstatement.close();\n\t\t\t\t\tconnection.close();\n\n\t\t\t\t\ttrying = false;\n\t\t\t\t\tsuccess = true;\n\t\t\t\t\t/* Server might have crashed and table might still be busy. */\n\t\t\t\t}\n\t\t\t\tcatch (java.sql.SQLException s)\n\t\t\t\t{\n\t\t\t\t\tSystem.err.println(\"Cleanup01.main: \" + s);\n\t\t\t\t\tSystem.err.println(\"SQL state is: \" + s.getSQLState());\n\t\t\t\t\tif (s.getSQLState() == \"42000\" ||\t/* no table to drop */\n\t\t\t\t\t\t\ts.getSQLState() == \"42S02\" ||\t/* table not found */\n\t\t\t\t\t\t\ts.getSQLState() == null)\t\t/* connection failed */\n\t\t\t\t\t{\n\t\t\t\t\t\ttrying = false;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttries++;\n\t\t\t\t\t\tif (tries >= 6)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttrying = false;\n\t\t\t\t\t\t\tSystem.err.println(\"Giving up.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSystem.err.println(\"Sleeping \" + (tries * 10) + \" seconds and re-trying ...\");\n\t\t\t\t\t\t\t\tThread.sleep(tries * 10000);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSystem.err.println(\"Cleanup01.main: \" + e);\n\t\t\t\t\t\t\t\ttrying = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tSystem.err.println(\"Cleanup01.main: \" + e);\n\t\t\t\t\ttrying = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception exception)\n\t\t{\n\t\t\tSystem.err.println(\"Cleanup01.main: \" + exception);\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tOAInterface.shutdownOA();\n\t\t\tORBInterface.shutdownORB();\n\t\t}\n\t\tcatch (Exception exception)\n\t\t{\n\t\t\tSystem.err.println(\"Cleanup01.main: \" + exception);\n\t\t\texception.printStackTrace(System.err);\n\n\t\t\tsuccess = false;\n\t\t}\n\n\t\tSystem.out.println(success ? \"Passed\" : \"Failed\");\n\t}\n}", "class_id": 0, "repo": "nmcl/wfswarm-example-arjuna-old", "file": "graalvm/transactions/fork/narayana/qa/tests/src/org/jboss/jbossts/qa/JDBCResources02Cleanups/Cleanup01.java", "last_update_at": "2019-05-23T18:19:26+00:00", "question_id": "7c3747bfd629bc2021240fec64ad1bf506105983", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Cleanup01\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tboolean success = false;\n\t\tboolean trying = true;\n\t\tint tries = 0;\n\t\ttry\n\t\t{\n\t\t\tORBInterface.initORB(args, null);\n\t\t\tOAInterface.initOA();\n\t\t\tString profileName = args[args.length - 1];\n\t\t\tint numberOfDrivers = JDBCProfileStore.numberOfDrivers(profileName);\n\t\t\tfor (int index = 0; index < numberOfDrivers; index++)\n\t\t\t{\n\t\t\t\tString driver = JDBCProfileStore.driver(profileName, index);\n\t\t\t\tClass.forName(driver);\n\t\t\t}\n\t\t\tString databaseURL = JDBCProfileStore.databaseURL(profileName);\n\t\t\tString databaseUser = JDBCProfileStore.databaseUser(profileName);\n\t\t\tString databasePassword = JDBCProfileStore.databasePassword(profileName);\n\t\t\tString databaseDynamicClass = JDBCProfileStore.databaseDynamicClass(profileName);\n\t\t\tConnection connection;\n\t\t\tif (databaseDynamicClass != null)\n\t\t\t{\n\t\t\t\tProperties databaseProperties = new Properties();\n\t\t\t\tdatabaseProperties.put(com.arjuna.ats.jdbc.TransactionalDriver.userName, databaseUser);\n\t\t\t\tdatabaseProperties.put(com.arjuna.ats.jdbc.TransactionalDriver.password, databasePassword);\n\t\t\t\tdatabaseProperties.put(com.arjuna.ats.jdbc.TransactionalDriver.dynamicClass, databaseDynamicClass);\n\t\t\t\tconnection = DriverManager.getConnection(databaseURL, databaseProperties);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tconnection = DriverManager.getConnection(databaseURL, databaseUser, databasePassword);\n\t\t\t}\n            String tableName = JDBCProfileStore.getTableName(databaseUser, \"Infotable\");\n\t\t\twhile (trying)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tStatement statement = connection.createStatement();\n\t\t\t\t\tSystem.err.println(\"DROP TABLE \" + tableName);\n\t\t\t\t\tstatement.executeUpdate(\"DROP TABLE \" + tableName);\n\t\t\t\t\tstatement.close();\n\t\t\t\t\tconnection.close();\n\t\t\t\t\ttrying = false;\n\t\t\t\t\tsuccess = true;\n\t\t\t\t\t/* Server might have crashed and table might still be busy. */\n\t\t\t\t}\n\t\t\t\tcatch (java.sql.SQLException s)\n\t\t\t\t{\n\t\t\t\t\tSystem.err.println(\"Cleanup01.main: \" + s);\n\t\t\t\t\tSystem.err.println(\"SQL state is: \" + s.getSQLState());\n\t\t\t\t\tif (s.getSQLState() == \"42000\" ||\t/* no table to drop */\n\t\t\t\t\t\t\ts.getSQLState() == \"42S02\" ||\t/* table not found */\n\t\t\t\t\t\t\ts.getSQLState() == null)\t\t/* connection failed */\n\t\t\t\t\t{\n\t\t\t\t\t\ttrying = false;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttries++;\n\t\t\t\t\t\tif (tries >= 6)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttrying = false;\n\t\t\t\t\t\t\tSystem.err.println(\"Giving up.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSystem.err.println(\"Sleeping \" + (tries * 10) + \" seconds and re-trying ...\");\n\t\t\t\t\t\t\t\tThread.sleep(tries * 10000);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSystem.err.println(\"Cleanup01.main: \" + e);\n\t\t\t\t\t\t\t\ttrying = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tSystem.err.println(\"Cleanup01.main: \" + e);\n\t\t\t\t\ttrying = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception exception)\n\t\t{\n\t\t\tSystem.err.println(\"Cleanup01.main: \" + exception);\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tOAInterface.shutdownOA();\n\t\t\tORBInterface.shutdownORB();\n\t\t}\n\t\tcatch (Exception exception)\n\t\t{\n\t\t\tSystem.err.println(\"Cleanup01.main: \" + exception);\n\t\t\texception.printStackTrace(System.err);\n\t\t\tsuccess = false;\n\t\t}\n\t\tSystem.out.println(success ? \"Passed\" : \"Failed\");\n\t}\n"]]}
{"hexsha": "70b0e3f3cd02ee1231e61f4ed20dc96cfb897750", "ext": "java", "lang": "Java", "content": "public class TabelaHash\r\n{\r\n  private Aluno[] tabela;\r\n\r\n  public TabelaHash(int N)\r\n  {\r\n    tabela = new Aluno[N];\r\n  }\r\n\r\n  private int hash(int k)\r\n  {\r\n    return k % tabela.length;\r\n  }\r\n\r\n  public Aluno get(int k)\r\n  {\r\n    int h = hash(k);\r\n    Aluno aluno = tabela[h];\r\n\r\n    while (aluno != null)\r\n    {\r\n      if (aluno.getMatricula() == k)\r\n      {\r\n        return aluno;\r\n      }\r\n\r\n      aluno = aluno.getProx();\r\n    }\r\n    return null;\r\n  }\r\n\r\n  public void set(String nome, int matricula, float mediaGeral)\r\n  {\r\n    int h = hash(matricula);\r\n    Aluno aluno = tabela[h];\r\n\r\n    while (aluno != null)\r\n    {\r\n      if (aluno.getMatricula() == matricula)\r\n      {\r\n        break;\r\n      }\r\n\r\n      aluno = aluno.getProx();\r\n    }\r\n\r\n    if (aluno == null)\r\n    {\r\n      aluno = new Aluno();\r\n      aluno.setMatricula(matricula);\r\n      aluno.setProx(tabela[h]);\r\n      tabela[h] = aluno;\r\n    }\r\n\r\n    aluno.setNome(nome);\r\n    aluno.setMediaGeral(mediaGeral);\r\n  }\r\n\r\n  public void remove(int k)\r\n  {\r\n    int h = hash(k);\r\n    Aluno anterior = null;\r\n    Aluno atual = tabela[h];\r\n    while (atual != null && atual.getMatricula() != k)\r\n    {\r\n      anterior = atual;\r\n      atual = atual.getProx();\r\n    }\r\n\r\n    if (atual == null)\r\n    {\r\n      return;\r\n    }\r\n    if (anterior == null)\r\n    {\r\n      tabela[h] = atual.getProx();\r\n    }\r\n    else\r\n    {\r\n      anterior.setProx(atual.getProx());\r\n    }\r\n  }\r\n\r\n  @Override\r\n  public String toString()\r\n  {\r\n    return \"TabelaHash [tabela = \" + Arrays.toString(tabela) + \"]\";\r\n  }\r\n}", "class_id": 0, "repo": "ZeusSchmitz/HTML", "file": "Documents/NetBeansProjects/TestaHash/src/testahash/TabelaHash.java", "last_update_at": "2019-03-14T23:54:16+00:00", "question_id": "70b0e3f3cd02ee1231e61f4ed20dc96cfb897750", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TabelaHash\r\n{\r\n  private Aluno[] tabela;\r\n\r\n  public TabelaHash(int N)\r\n  {\r\n    tabela = new Aluno[N];\r\n  }\r\n\r\n  private int hash(int k)\r\n  {\r\n    return k % tabela.length;\r\n  }\r\n\r\n  public Aluno get(int k)\r\n  {\r\n    int h = hash(k);\r\n    Aluno aluno = tabela[h];\r\n\r\n    while (aluno != null)\r\n    {\r\n      if (aluno.getMatricula() == k)\r\n      {\r\n        return aluno;\r\n      }\r\n\r\n      aluno = aluno.getProx();\r\n    }\r\n    return null;\r\n  }\r\n\r\n  public void set(String nome, int matricula, float mediaGeral)\r\n  {\r\n    int h = hash(matricula);\r\n    Aluno aluno = tabela[h];\r\n\r\n    while (aluno != null)\r\n    {\r\n      if (aluno.getMatricula() == matricula)\r\n      {\r\n        break;\r\n      }\r\n\r\n      aluno = aluno.getProx();\r\n    }\r\n\r\n    if (aluno == null)\r\n    {\r\n      aluno = new Aluno();\r\n      aluno.setMatricula(matricula);\r\n      aluno.setProx(tabela[h]);\r\n      tabela[h] = aluno;\r\n    }\r\n\r\n    aluno.setNome(nome);\r\n    aluno.setMediaGeral(mediaGeral);\r\n  }\r\n\r\n  public void remove(int k)\r\n  {\r\n    int h = hash(k);\r\n    Aluno anterior = null;\r\n    Aluno atual = tabela[h];\r\n    while (atual != null && atual.getMatricula() != k)\r\n    {\r\n      anterior = atual;\r\n      atual = atual.getProx();\r\n    }\r\n\r\n    if (atual == null)\r\n    {\r\n      return;\r\n    }\r\n    if (anterior == null)\r\n    {\r\n      tabela[h] = atual.getProx();\r\n    }\r\n    else\r\n    {\r\n      anterior.setProx(atual.getProx());\r\n    }\r\n  }\r\n\r\n  @Override\r\n  public String toString()\r\n  {\r\n    return \"TabelaHash [tabela = \" + Arrays.toString(tabela) + \"]\";\r\n  }\r\n"]]}
{"hexsha": "fb060ba4989ff3c8e426094e9cdcd89227db1c4b", "ext": "java", "lang": "Java", "content": "public class SearchHelper {\n  public void resize(int width, int height) {\n    mHalfScreenWidth = width * 0.5f;\n    mHalfScreenHeight = height * 0.5f;\n  }\n  \n  public void setTarget(Vector3 target, String targetName) {\n    mTargetName = targetName;\n    mTarget = target.copy();\n    mTransformedPosition = null;\n    mLastUpdateTime = System.currentTimeMillis();\n    mTransitionFactor = targetInFocusRadiusImpl() ? 1 : 0;\n  }\n  \n  public void setTransform(Matrix4x4 transformMatrix) {\n    mTransformMatrix = transformMatrix;\n    mTransformedPosition = null;\n  }\n  \n  public Vector3 getTransformedPosition() {\n    if (mTransformedPosition == null && mTransformMatrix != null) {\n      // Transform the label position by our transform matrix\n      mTransformedPosition = Matrix4x4.transformVector(mTransformMatrix, mTarget);\n    }\n    return mTransformedPosition;\n  }\n  \n  public boolean targetInFocusRadius() {\n    return mWasInFocusLastCheck;\n  }\n  \n  public void setTargetFocusRadius(float radius) {\n    mTargetFocusRadius = radius;\n  }\n  \n  // Returns a number between 0 and 1, 0 meaning that we should draw the UI as if the target\n  // is not in focus, 1 meaning it should be fully in focus, and between the two meaning\n  // it just transitioned between the two, so we should be drawing the transition.\n  public float getTransitionFactor() {\n    return mTransitionFactor;\n  }\n  \n  // Checks whether the search target is in the focus or not, and updates the seconds in the state\n  // accordingly.\n  public void checkState() {\n    boolean inFocus = targetInFocusRadiusImpl();\n    mWasInFocusLastCheck = inFocus;\n    long time = System.currentTimeMillis();\n    float delta = 0.001f * (time - mLastUpdateTime);\n    mTransitionFactor += delta * (inFocus ? 1 : -1);\n    mTransitionFactor = Math.min(1, Math.max(0, mTransitionFactor));\n    mLastUpdateTime = time;\n  }\n  \n  public String getTargetName() {\n    return mTargetName;\n  }\n  \n  // Returns the distance from the center of the screen, in pixels, if the target is in front of\n  // the viewer.  Returns infinity if the point is behind the viewer.\n  private float getDistanceFromCenterOfScreen() {\n    Vector3 position = getTransformedPosition();\n    if (position.z > 0) {\n      float dx = position.x * mHalfScreenWidth;\n      float dy = position.y * mHalfScreenHeight;\n      return MathUtil.sqrt(dx*dx + dy*dy);\n    } else {\n      return Float.POSITIVE_INFINITY;\n    }\n  }\n  \n  private boolean targetInFocusRadiusImpl() {\n    float distFromCenter = getDistanceFromCenterOfScreen();\n    return 0.5f * mTargetFocusRadius > distFromCenter;\n  }\n  \n  private Vector3 mTarget = new Vector3(0, 0, 0);\n  private Vector3 mTransformedPosition = new Vector3(0, 0, 0);\n  private float mHalfScreenWidth = 1;\n  private float mHalfScreenHeight = 1;\n  private Matrix4x4 mTransformMatrix = null;\n  private float mTargetFocusRadius = 0;\n  private float mTransitionFactor = 0;\n  private long mLastUpdateTime = 0;\n  private boolean mWasInFocusLastCheck = false;\n  private String mTargetName = \"Default target name\";\n}", "class_id": 0, "repo": "hemilpanchiwala/stardroid", "file": "app/src/main/java/com/google/android/stardroid/renderer/util/SearchHelper.java", "last_update_at": "2019-03-24T09:49:47+00:00", "question_id": "fb060ba4989ff3c8e426094e9cdcd89227db1c4b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SearchHelper {\n  public void resize(int width, int height) {\n    mHalfScreenWidth = width * 0.5f;\n    mHalfScreenHeight = height * 0.5f;\n  }\n  public void setTarget(Vector3 target, String targetName) {\n    mTargetName = targetName;\n    mTarget = target.copy();\n    mTransformedPosition = null;\n    mLastUpdateTime = System.currentTimeMillis();\n    mTransitionFactor = targetInFocusRadiusImpl() ? 1 : 0;\n  }\n  public void setTransform(Matrix4x4 transformMatrix) {\n    mTransformMatrix = transformMatrix;\n    mTransformedPosition = null;\n  }\n  public Vector3 getTransformedPosition() {\n    if (mTransformedPosition == null && mTransformMatrix != null) {\n      // Transform the label position by our transform matrix\n      mTransformedPosition = Matrix4x4.transformVector(mTransformMatrix, mTarget);\n    }\n    return mTransformedPosition;\n  }\n  public boolean targetInFocusRadius() {\n    return mWasInFocusLastCheck;\n  }\n  public void setTargetFocusRadius(float radius) {\n    mTargetFocusRadius = radius;\n  }\n  // Returns a number between 0 and 1, 0 meaning that we should draw the UI as if the target\n  // is not in focus, 1 meaning it should be fully in focus, and between the two meaning\n  // it just transitioned between the two, so we should be drawing the transition.\n  public float getTransitionFactor() {\n    return mTransitionFactor;\n  }\n  // Checks whether the search target is in the focus or not, and updates the seconds in the state\n  // accordingly.\n  public void checkState() {\n    boolean inFocus = targetInFocusRadiusImpl();\n    mWasInFocusLastCheck = inFocus;\n    long time = System.currentTimeMillis();\n    float delta = 0.001f * (time - mLastUpdateTime);\n    mTransitionFactor += delta * (inFocus ? 1 : -1);\n    mTransitionFactor = Math.min(1, Math.max(0, mTransitionFactor));\n    mLastUpdateTime = time;\n  }\n  public String getTargetName() {\n    return mTargetName;\n  }\n  // Returns the distance from the center of the screen, in pixels, if the target is in front of\n  // the viewer.  Returns infinity if the point is behind the viewer.\n  private float getDistanceFromCenterOfScreen() {\n    Vector3 position = getTransformedPosition();\n    if (position.z > 0) {\n      float dx = position.x * mHalfScreenWidth;\n      float dy = position.y * mHalfScreenHeight;\n      return MathUtil.sqrt(dx*dx + dy*dy);\n    } else {\n      return Float.POSITIVE_INFINITY;\n    }\n  }\n  private boolean targetInFocusRadiusImpl() {\n    float distFromCenter = getDistanceFromCenterOfScreen();\n    return 0.5f * mTargetFocusRadius > distFromCenter;\n  }\n  private Vector3 mTarget = new Vector3(0, 0, 0);\n  private Vector3 mTransformedPosition = new Vector3(0, 0, 0);\n  private float mHalfScreenWidth = 1;\n  private float mHalfScreenHeight = 1;\n  private Matrix4x4 mTransformMatrix = null;\n  private float mTargetFocusRadius = 0;\n  private float mTransitionFactor = 0;\n  private long mLastUpdateTime = 0;\n  private boolean mWasInFocusLastCheck = false;\n  private String mTargetName = \"Default target name\";\n"]]}
{"hexsha": "1ff0d748f517c0b4241d4cc57a6f3b7a957ddae7", "ext": "java", "lang": "Java", "content": "static class GhostViewApi21$Creator\n\timplements GhostViewImpl.Creator\n{\n\n\tpublic GhostViewImpl addGhost(View view, ViewGroup viewgroup, Matrix matrix)\n\t{\n\t\tGhostViewApi21.access$000();\n\t//    0    0:invokestatic    #23  <Method void GhostViewApi21.access$000()>\n\t\tif(GhostViewApi21.access$100() != null)\n\t//*   1    3:invokestatic    #27  <Method Method GhostViewApi21.access$100()>\n\t//*   2    6:ifnull          59\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tview = ((View) (new GhostViewApi21((View)GhostViewApi21.access$100().invoke(((Object) (null)), new Object[] {\n\t\t\t\t\tview, viewgroup, matrix\n\t\t\t\t}), ((GhostViewApi21._cls1) (null)))));\n\t//    3    9:new             #8   <Class GhostViewApi21>\n\t//    4   12:dup             \n\t//    5   13:invokestatic    #27  <Method Method GhostViewApi21.access$100()>\n\t//    6   16:aconst_null     \n\t//    7   17:iconst_3        \n\t//    8   18:anewarray       Object[]\n\t//    9   21:dup             \n\t//   10   22:iconst_0        \n\t//   11   23:aload_1         \n\t//   12   24:aastore         \n\t//   13   25:dup             \n\t//   14   26:iconst_1        \n\t//   15   27:aload_2         \n\t//   16   28:aastore         \n\t//   17   29:dup             \n\t//   18   30:iconst_2        \n\t//   19   31:aload_3         \n\t//   20   32:aastore         \n\t//   21   33:invokevirtual   #33  <Method Object Method.invoke(Object, Object[])>\n\t//   22   36:checkcast       #35  <Class View>\n\t//   23   39:aconst_null     \n\t//   24   40:invokespecial   #38  <Method void GhostViewApi21(View, GhostViewApi21$1)>\n\t//   25   43:astore_1        \n\t\t\t}\n\t//*  26   44:aload_1         \n\t//*  27   45:areturn         \n\t//*  28   46:astore_1        \n\t//*  29   47:new             #40  <Class RuntimeException>\n\t//*  30   50:dup             \n\t//*  31   51:aload_1         \n\t//*  32   52:invokevirtual   #44  <Method Throwable InvocationTargetException.getCause()>\n\t//*  33   55:invokespecial   #47  <Method void RuntimeException(Throwable)>\n\t//*  34   58:athrow          \n\t//*  35   59:aconst_null     \n\t//*  36   60:areturn         \n\t\t\t// Misplaced declaration of an exception variable\n\t\t\tcatch(View view)\n\t//*  37   61:astore_1        \n\t\t\t{\n\t\t\t\treturn null;\n\t//   38   62:aconst_null     \n\t//   39   63:areturn         \n\t\t\t}\n\t\t\t// Misplaced declaration of an exception variable\n\t\t\tcatch(View view)\n\t\t\t{\n\t\t\t\tthrow new RuntimeException(((InvocationTargetException) (view)).getCause());\n\t\t\t}\n\t\t\treturn ((GhostViewImpl) (view));\n\t\t} else\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic void removeGhost(View view)\n\t{\n\t\tGhostViewApi21.access$300();\n\t//    0    0:invokestatic    #52  <Method void GhostViewApi21.access$300()>\n\t\tif(GhostViewApi21.access$400() != null)\n\t//*   1    3:invokestatic    #55  <Method Method GhostViewApi21.access$400()>\n\t//*   2    6:ifnull          39\n\t\t\ttry\n\t\t\t{\n\t\t\t\tGhostViewApi21.access$400().invoke(((Object) (null)), new Object[] {\n\t\t\t\t\tview\n\t\t\t\t});\n\t//    3    9:invokestatic    #55  <Method Method GhostViewApi21.access$400()>\n\t//    4   12:aconst_null     \n\t//    5   13:iconst_1        \n\t//    6   14:anewarray       Object[]\n\t//    7   17:dup             \n\t//    8   18:iconst_0        \n\t//    9   19:aload_1         \n\t//   10   20:aastore         \n\t//   11   21:invokevirtual   #33  <Method Object Method.invoke(Object, Object[])>\n\t//   12   24:pop             \n\t\t\t\treturn;\n\t//   13   25:return          \n\t\t\t}\n\t//*  14   26:astore_1        \n\t//*  15   27:new             #40  <Class RuntimeException>\n\t//*  16   30:dup             \n\t//*  17   31:aload_1         \n\t//*  18   32:invokevirtual   #44  <Method Throwable InvocationTargetException.getCause()>\n\t//*  19   35:invokespecial   #47  <Method void RuntimeException(Throwable)>\n\t//*  20   38:athrow          \n\t//*  21   39:return          \n\t\t\t// Misplaced declaration of an exception variable\n\t\t\tcatch(View view)\n\t//*  22   40:astore_1        \n\t\t\t{\n\t\t\t\treturn;\n\t//   23   41:return          \n\t\t\t}\n\t\t\t// Misplaced declaration of an exception variable\n\t\t\tcatch(View view)\n\t\t\t{\n\t\t\t\tthrow new RuntimeException(((InvocationTargetException) (view)).getCause());\n\t\t\t}\n\t\telse\n\t\t\treturn;\n\t}\n\n\tGhostViewApi21$Creator()\n\t{\n\t//    0    0:aload_0         \n\t//    1    1:invokespecial   #13  <Method void Object()>\n\t//    2    4:return          \n\t}\n}", "class_id": 0, "repo": "Andreas237/AndroidPolicyAutomation", "file": "ExtractedJars/RT_News_com.rt.mobile.english/javafiles/android/support/transition/GhostViewApi21$Creator.java", "last_update_at": "2019-07-06T22:21:59+00:00", "question_id": "1ff0d748f517c0b4241d4cc57a6f3b7a957ddae7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static class GhostViewApi21$Creator\n\timplements GhostViewImpl.Creator\n{\n\tpublic GhostViewImpl addGhost(View view, ViewGroup viewgroup, Matrix matrix)\n\t{\n\t\tGhostViewApi21.access$000();\n\t//    0    0:invokestatic    #23  <Method void GhostViewApi21.access$000()>\n\t\tif(GhostViewApi21.access$100() != null)\n\t//*   1    3:invokestatic    #27  <Method Method GhostViewApi21.access$100()>\n\t//*   2    6:ifnull          59\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tview = ((View) (new GhostViewApi21((View)GhostViewApi21.access$100().invoke(((Object) (null)), new Object[] {\n\t\t\t\t\tview, viewgroup, matrix\n\t\t\t\t}), ((GhostViewApi21._cls1) (null)))));\n\t//    3    9:new             #8   <Class GhostViewApi21>\n\t//    4   12:dup             \n\t//    5   13:invokestatic    #27  <Method Method GhostViewApi21.access$100()>\n\t//    6   16:aconst_null     \n\t//    7   17:iconst_3        \n\t//    8   18:anewarray       Object[]\n\t//    9   21:dup             \n\t//   10   22:iconst_0        \n\t//   11   23:aload_1         \n\t//   12   24:aastore         \n\t//   13   25:dup             \n\t//   14   26:iconst_1        \n\t//   15   27:aload_2         \n\t//   16   28:aastore         \n\t//   17   29:dup             \n\t//   18   30:iconst_2        \n\t//   19   31:aload_3         \n\t//   20   32:aastore         \n\t//   21   33:invokevirtual   #33  <Method Object Method.invoke(Object, Object[])>\n\t//   22   36:checkcast       #35  <Class View>\n\t//   23   39:aconst_null     \n\t//   24   40:invokespecial   #38  <Method void GhostViewApi21(View, GhostViewApi21$1)>\n\t//   25   43:astore_1        \n\t\t\t}\n\t//*  26   44:aload_1         \n\t//*  27   45:areturn         \n\t//*  28   46:astore_1        \n\t//*  29   47:new             #40  <Class RuntimeException>\n\t//*  30   50:dup             \n\t//*  31   51:aload_1         \n\t//*  32   52:invokevirtual   #44  <Method Throwable InvocationTargetException.getCause()>\n\t//*  33   55:invokespecial   #47  <Method void RuntimeException(Throwable)>\n\t//*  34   58:athrow          \n\t//*  35   59:aconst_null     \n\t//*  36   60:areturn         \n\t\t\t// Misplaced declaration of an exception variable\n\t\t\tcatch(View view)\n\t//*  37   61:astore_1        \n\t\t\t{\n\t\t\t\treturn null;\n\t//   38   62:aconst_null     \n\t//   39   63:areturn         \n\t\t\t}\n\t\t\t// Misplaced declaration of an exception variable\n\t\t\tcatch(View view)\n\t\t\t{\n\t\t\t\tthrow new RuntimeException(((InvocationTargetException) (view)).getCause());\n\t\t\t}\n\t\t\treturn ((GhostViewImpl) (view));\n\t\t} else\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t}\n\tpublic void removeGhost(View view)\n\t{\n\t\tGhostViewApi21.access$300();\n\t//    0    0:invokestatic    #52  <Method void GhostViewApi21.access$300()>\n\t\tif(GhostViewApi21.access$400() != null)\n\t//*   1    3:invokestatic    #55  <Method Method GhostViewApi21.access$400()>\n\t//*   2    6:ifnull          39\n\t\t\ttry\n\t\t\t{\n\t\t\t\tGhostViewApi21.access$400().invoke(((Object) (null)), new Object[] {\n\t\t\t\t\tview\n\t\t\t\t});\n\t//    3    9:invokestatic    #55  <Method Method GhostViewApi21.access$400()>\n\t//    4   12:aconst_null     \n\t//    5   13:iconst_1        \n\t//    6   14:anewarray       Object[]\n\t//    7   17:dup             \n\t//    8   18:iconst_0        \n\t//    9   19:aload_1         \n\t//   10   20:aastore         \n\t//   11   21:invokevirtual   #33  <Method Object Method.invoke(Object, Object[])>\n\t//   12   24:pop             \n\t\t\t\treturn;\n\t//   13   25:return          \n\t\t\t}\n\t//*  14   26:astore_1        \n\t//*  15   27:new             #40  <Class RuntimeException>\n\t//*  16   30:dup             \n\t//*  17   31:aload_1         \n\t//*  18   32:invokevirtual   #44  <Method Throwable InvocationTargetException.getCause()>\n\t//*  19   35:invokespecial   #47  <Method void RuntimeException(Throwable)>\n\t//*  20   38:athrow          \n\t//*  21   39:return          \n\t\t\t// Misplaced declaration of an exception variable\n\t\t\tcatch(View view)\n\t//*  22   40:astore_1        \n\t\t\t{\n\t\t\t\treturn;\n\t//   23   41:return          \n\t\t\t}\n\t\t\t// Misplaced declaration of an exception variable\n\t\t\tcatch(View view)\n\t\t\t{\n\t\t\t\tthrow new RuntimeException(((InvocationTargetException) (view)).getCause());\n\t\t\t}\n\t\telse\n\t\t\treturn;\n\t}\n\tGhostViewApi21$Creator()\n\t{\n\t//    0    0:aload_0         \n\t//    1    1:invokespecial   #13  <Method void Object()>\n\t//    2    4:return          \n\t}\n"]]}
{"hexsha": "e308ee752f217b9309e2d890de5ccb5f3d116e48", "ext": "java", "lang": "Java", "content": "@State(Scope.Benchmark)\npublic class ShakespearePlaysScrabble {\n    public static int numProc = Runtime.getRuntime().availableProcessors();\n    public static boolean fast;\n\n\n    /** for words matching the suffix, hash the word and modify the score */\n    @Param(\"ks\")\n    public String suffix = \"ks\";\n\n    /** the number of times to hash each word matching the suffix */\n    @Param(\"0\")\n    public int numHash;\n    \n    static {\n        try { numProc = Integer.parseInt(System.getProperty(\"np\")); }\n        catch (Exception ex) {}\n        fast = System.getProperty(\"fast\") != null;\n    }\n\n    protected void getProperties() {\n        suffix = System.getProperty(\"suffix\");\n        try { numHash = Integer.parseInt(System.getProperty(\"numHash\")); }\n        catch (Exception ex) {}\n        try { size = Integer.parseInt(System.getProperty(\"size\")); }\n        catch (Exception ex) {}\n        try { soft = Integer.parseInt(System.getProperty(\"soft\")); }\n        catch (Exception ex) {}\n        try { sleep = Integer.parseInt(System.getProperty(\"sleep\")); }\n        catch (Exception ex) {}\n        mode = System.getProperty(\"mode\");\n    }\n    \n    static public int numPool = Math.max(1,numProc-1);\n    \n    public static final int [] letterScores = {\n    // a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p,  q, r, s, t, u, v, w, x, y,  z\n       1, 3, 3, 2, 1, 4, 2, 4, 1, 8, 5, 1, 3, 1, 1, 3, 10, 1, 1, 1, 1, 4, 4, 8, 4, 10} ;\n\n    public static final int [] scrabbleAvailableLetters = {\n     // a, b, c, d,  e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\n        9, 2, 2, 1, 12, 2, 3, 2, 9, 1, 1, 4, 2, 6, 8, 2, 1, 6, 4, 6, 4, 2, 2, 1, 2, 1} ;\n    \n    \n    public Set<String> scrabbleWords = null ;\n    private Set<String> words = null ;\n    public Iterable<Stringx> shakespeareWords() {\n        if (sleep < -1) return LimitSource::new;\n        if (sleep == -1) return BurnSource::new;\n        return sleep==0 ? Source::new : SleepSource::new;\n    }\n    AtomicInteger outstanding = new AtomicInteger();\n\n\n    /**\n     * most implementations support a queue size.\n     * if this value is non-zero, it is used.\n     * otherwise, the size is computed based on the soft limit.\n     */\n    @Param(\"0\")\n    public int size;\n\n    /**\n     * the soft limit on the number of outstanding iterator objects.\n     * only active for positive sleep values\n     */\n    @Param(\"32\")\n    public int soft = 32;\n\n    /** \n     * for positive values, the number of times to sleep before exceeding the soft limit.\n     * if less than -1, only iterate through the first -sleep values.\n     * if -1, burn the cpu using an additional task and only use the first 100 values.\n     */\n    @Param(\"0\")\n    public int sleep;\n\n    /**\n     * modes allow setting multiple params as a group.\n     * only the first letter is needed.\n     * supported values are: fast, all, burn, cost, delay, effort.\n     * some single letter modes can embed other param values.\n     * ie \"a200\" does 200 iterations and d80 or e80 uses a soft limit of 80.\n     */\n    @Param({\"fast\", \"all\", \"burn\", \"cost\", \"delay\"})\n    public String mode;\n\n    // hard limit on the number of soft limit sleeps\n    static int MAX_YIELD = 1000;\n\n    boolean startsWith(String txt) { return mode.startsWith(txt.substring(0,1)); }\n\n    void getSoft() {\n        try { soft = Integer.parseInt(mode.substring(1)); }\n        catch (Exception ex) {}\n    }\n    void getLimit() {\n        try { sleep = -Integer.parseInt(mode.substring(1)); }\n        catch (Exception ex) {}\n    }\n    \n    @Setup\n    public void init() {\n    \tscrabbleWords = Util.readScrabbleWords() ;\n        words = Util.readShakespeareWords();\n        if (mode==null || mode.length()==0);\n        else if (startsWith(\"fast\")) {}\n        else if (startsWith(\"all\")) { suffix=\"\"; numHash=numHash==0 ? 1000:numHash; sleep=-100; getLimit(); }\n        else if (startsWith(\"burn\")) { sleep=-1; }\n        else if (startsWith(\"cost\")) { numHash=1000; }\n        else if (startsWith(\"delay\")) { sleep=1; getSoft(); }\n        else if (startsWith(\"effort\")) { sleep=10; getSoft(); }\n        else System.out.println(\"mode not found, using defaults: \" + mode);\n        if (sleep <= 0)\n            soft = 0;\n    }\n\n    class Source implements Iterator<Stringx> {\n        Iterator<String> iter = words.iterator();\n        public boolean hasNext() { return iter.hasNext(); }\n        public Stringx next() { return new Stringx(iter.next()); }\n    }\n\n    class SleepSource implements Iterator<Stringx> {\n        int maxOut = soft;\n        int nyield;\n        Iterator<String> iter = words.iterator();\n        public boolean hasNext() { return iter.hasNext(); }\n        public Stringx next() {\n            try {\n                int ii=0;\n                for (; ii <= sleep && outstanding.get() >= maxOut; ii++)\n                    Thread.sleep(ii < sleep ? 0:1);\n                if (ii > sleep && ++nyield > MAX_YIELD) {\n                    String msg = \"number of yields exceeded - shutting down immediately\";\n                    new AssertionError(msg).printStackTrace();\n                    System.exit(1);\n                }\n                outstanding.incrementAndGet();\n                return new Stringx(iter.next());\n            }\n            catch (InterruptedException ex) {}\n            return null;\n        }\n    }\n\n    class BurnSource implements Iterator<Stringx> {\n        int index;\n        Thread [] burners = new Thread[numProc];\n        Iterator<String> iter = words.iterator();\n        {\n            for (int ii=0; ii < burners.length; ii++)\n                (burners[ii] = new Thread(() -> Blackhole.consumeCPU(100_000_000))).start();\n        }\n        public boolean hasNext() {\n            try {\n                Thread.sleep(1);\n                if (index < 100)\n                    return iter.hasNext();\n                for (Thread thread : burners)\n                    thread.join();\n            }\n            catch (InterruptedException ex) {}\n            return false;\n        }\n        public Stringx next() {\n            index++;\n            return new Stringx(iter.next());\n        }\n    }\n    class LimitSource implements Iterator<Stringx> {\n        int index;\n        int limit = -sleep;\n        Iterator<String> iter = words.iterator();\n        public boolean hasNext() {\n            if (index < limit)\n                return iter.hasNext();\n            return false;\n        }\n        public Stringx next() {\n            index++;\n            return new Stringx(iter.next());\n        }\n    }\n\n    public class Stringx {\n        public String data;\n        public Stringx(String data) { this.data = data; }\n        public void dispose() {\n            outstanding.decrementAndGet();\n        }\n    }\n}", "class_id": 0, "repo": "nqzero/reactive-bench", "file": "src/main/java/org/paumard/jdk8/bench/ShakespearePlaysScrabble.java", "last_update_at": "2019-12-04T08:48:52+00:00", "question_id": "e308ee752f217b9309e2d890de5ccb5f3d116e48", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@State(Scope.Benchmark)\npublic class ShakespearePlaysScrabble {\n    public static int numProc = Runtime.getRuntime().availableProcessors();\n    public static boolean fast;\n    /** for words matching the suffix, hash the word and modify the score */\n    @Param(\"ks\")\n    public String suffix = \"ks\";\n    /** the number of times to hash each word matching the suffix */\n    @Param(\"0\")\n    public int numHash;\n    static {\n        try { numProc = Integer.parseInt(System.getProperty(\"np\")); }\n        catch (Exception ex) {}\n        fast = System.getProperty(\"fast\") != null;\n    }\n    protected void getProperties() {\n        suffix = System.getProperty(\"suffix\");\n        try { numHash = Integer.parseInt(System.getProperty(\"numHash\")); }\n        catch (Exception ex) {}\n        try { size = Integer.parseInt(System.getProperty(\"size\")); }\n        catch (Exception ex) {}\n        try { soft = Integer.parseInt(System.getProperty(\"soft\")); }\n        catch (Exception ex) {}\n        try { sleep = Integer.parseInt(System.getProperty(\"sleep\")); }\n        catch (Exception ex) {}\n        mode = System.getProperty(\"mode\");\n    }\n    static public int numPool = Math.max(1,numProc-1);\n    public static final int [] letterScores = {\n    // a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p,  q, r, s, t, u, v, w, x, y,  z\n       1, 3, 3, 2, 1, 4, 2, 4, 1, 8, 5, 1, 3, 1, 1, 3, 10, 1, 1, 1, 1, 4, 4, 8, 4, 10} ;\n    public static final int [] scrabbleAvailableLetters = {\n     // a, b, c, d,  e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\n        9, 2, 2, 1, 12, 2, 3, 2, 9, 1, 1, 4, 2, 6, 8, 2, 1, 6, 4, 6, 4, 2, 2, 1, 2, 1} ;\n    public Set<String> scrabbleWords = null ;\n    private Set<String> words = null ;\n    public Iterable<Stringx> shakespeareWords() {\n        if (sleep < -1) return LimitSource::new;\n        if (sleep == -1) return BurnSource::new;\n        return sleep==0 ? Source::new : SleepSource::new;\n    }\n    AtomicInteger outstanding = new AtomicInteger();\n    /**\n     * most implementations support a queue size.\n     * if this value is non-zero, it is used.\n     * otherwise, the size is computed based on the soft limit.\n     */\n    @Param(\"0\")\n    public int size;\n    /**\n     * the soft limit on the number of outstanding iterator objects.\n     * only active for positive sleep values\n     */\n    @Param(\"32\")\n    public int soft = 32;\n    /** \n     * for positive values, the number of times to sleep before exceeding the soft limit.\n     * if less than -1, only iterate through the first -sleep values.\n     * if -1, burn the cpu using an additional task and only use the first 100 values.\n     */\n    @Param(\"0\")\n    public int sleep;\n    /**\n     * modes allow setting multiple params as a group.\n     * only the first letter is needed.\n     * supported values are: fast, all, burn, cost, delay, effort.\n     * some single letter modes can embed other param values.\n     * ie \"a200\" does 200 iterations and d80 or e80 uses a soft limit of 80.\n     */\n    @Param({\"fast\", \"all\", \"burn\", \"cost\", \"delay\"})\n    public String mode;\n    // hard limit on the number of soft limit sleeps\n    static int MAX_YIELD = 1000;\n    boolean startsWith(String txt) { return mode.startsWith(txt.substring(0,1)); }\n    void getSoft() {\n        try { soft = Integer.parseInt(mode.substring(1)); }\n        catch (Exception ex) {}\n    }\n    void getLimit() {\n        try { sleep = -Integer.parseInt(mode.substring(1)); }\n        catch (Exception ex) {}\n    }\n    @Setup\n    public void init() {\n    \tscrabbleWords = Util.readScrabbleWords() ;\n        words = Util.readShakespeareWords();\n        if (mode==null || mode.length()==0);\n        else if (startsWith(\"fast\")) {}\n        else if (startsWith(\"all\")) { suffix=\"\"; numHash=numHash==0 ? 1000:numHash; sleep=-100; getLimit(); }\n        else if (startsWith(\"burn\")) { sleep=-1; }\n        else if (startsWith(\"cost\")) { numHash=1000; }\n        else if (startsWith(\"delay\")) { sleep=1; getSoft(); }\n        else if (startsWith(\"effort\")) { sleep=10; getSoft(); }\n        else System.out.println(\"mode not found, using defaults: \" + mode);\n        if (sleep <= 0)\n            soft = 0;\n    }\n    class Source implements Iterator<Stringx> {\n        Iterator<String> iter = words.iterator();\n        public boolean hasNext() { return iter.hasNext(); }\n        public Stringx next() { return new Stringx(iter.next()); }\n    }\n    class SleepSource implements Iterator<Stringx> {\n        int maxOut = soft;\n        int nyield;\n        Iterator<String> iter = words.iterator();\n        public boolean hasNext() { return iter.hasNext(); }\n        public Stringx next() {\n            try {\n                int ii=0;\n                for (; ii <= sleep && outstanding.get() >= maxOut; ii++)\n                    Thread.sleep(ii < sleep ? 0:1);\n                if (ii > sleep && ++nyield > MAX_YIELD) {\n                    String msg = \"number of yields exceeded - shutting down immediately\";\n                    new AssertionError(msg).printStackTrace();\n                    System.exit(1);\n                }\n                outstanding.incrementAndGet();\n                return new Stringx(iter.next());\n            }\n            catch (InterruptedException ex) {}\n            return null;\n        }\n    }\n    class BurnSource implements Iterator<Stringx> {\n        int index;\n        Thread [] burners = new Thread[numProc];\n        Iterator<String> iter = words.iterator();\n        {\n            for (int ii=0; ii < burners.length; ii++)\n                (burners[ii] = new Thread(() -> Blackhole.consumeCPU(100_000_000))).start();\n        }\n        public boolean hasNext() {\n            try {\n                Thread.sleep(1);\n                if (index < 100)\n                    return iter.hasNext();\n                for (Thread thread : burners)\n                    thread.join();\n            }\n            catch (InterruptedException ex) {}\n            return false;\n        }\n        public Stringx next() {\n            index++;\n            return new Stringx(iter.next());\n        }\n    }\n    class LimitSource implements Iterator<Stringx> {\n        int index;\n        int limit = -sleep;\n        Iterator<String> iter = words.iterator();\n        public boolean hasNext() {\n            if (index < limit)\n                return iter.hasNext();\n            return false;\n        }\n        public Stringx next() {\n            index++;\n            return new Stringx(iter.next());\n        }\n    }\n    public class Stringx {\n        public String data;\n        public Stringx(String data) { this.data = data; }\n        public void dispose() {\n            outstanding.decrementAndGet();\n        }\n    }\n"]]}
{"hexsha": "dd6b38bb949eba9f0a5e0c9e135aea57a0e47637", "ext": "java", "lang": "Java", "content": "@Component\npublic class MailMan {\n\n    private static final String KEY_HOST_SETTING = \"mail.smtp.host\";\n\n    @Autowired\n    private MailProps mailProps;\n\n    /**\n     * Sends a message to a user.\n     * @param user the user who should get the message\n     * @param content the content of the message\n     * @param subject the subject of the message\n     */\n    public void sendMail(User user, String content, String subject) {\n\n        Logger logger = LoggerFactory.getLogger(MailMan.class);\n\n        if(user.getEmail() == null) {\n            logger.error(\"User has no email set! Unable to send mail!\");\n            return;\n        }\n\n        Properties props = new Properties();\n        props.put(KEY_HOST_SETTING, mailProps.getHost());\n\n        Session session = Session.getInstance(props, null);\n\n        try {\n            MimeMessage msg = new MimeMessage(session);\n            msg.setFrom(new InternetAddress(mailProps.getFrom()));\n            InternetAddress[] address = {new InternetAddress(user.getEmail())};\n            msg.setRecipients(Message.RecipientType.TO, address);\n            msg.setSubject(subject);\n            msg.setSentDate(new Date());\n            msg.setHeader(\"X-Mailer\", Consts.MAIL_XMAILER);\n            msg.setText(content);\n            msg.saveChanges(); // don't forget this\n            if (mailProps.isAuthrequired()) {\n                if (mailProps.getAuthpass().equals(\"changeme\") || mailProps.getAuthusr().equals(\"changeme\")) {\n                    logger.warn(\"It seems like you didn't change the standard mail auth settings.\");\n                }\n                Transport tr = session.getTransport(\"smtp\");\n                tr.connect(mailProps.getHost(), mailProps.getAuthusr(), mailProps.getAuthpass());\n                tr.sendMessage(msg, msg.getAllRecipients());\n                tr.close();\n            } else {\n                Transport.send(msg);\n            }\n\n            logger.debug(\"Email sent to \" + user.getUsername());\n        } catch (MessagingException mex) {\n            logger.error(\"Error sending mail: \", mex);\n        }\n    }\n\n\n}", "class_id": 0, "repo": "lfuelling/generator-springboot-kickstart", "file": "app/templates/src/main/java/package/mail/MailMan.java", "last_update_at": "2019-05-16T15:07:12+00:00", "question_id": "dd6b38bb949eba9f0a5e0c9e135aea57a0e47637", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\npublic class MailMan {\n    private static final String KEY_HOST_SETTING = \"mail.smtp.host\";\n    @Autowired\n    private MailProps mailProps;\n    /**\n     * Sends a message to a user.\n     * @param user the user who should get the message\n     * @param content the content of the message\n     * @param subject the subject of the message\n     */\n    public void sendMail(User user, String content, String subject) {\n        Logger logger = LoggerFactory.getLogger(MailMan.class);\n        if(user.getEmail() == null) {\n            logger.error(\"User has no email set! Unable to send mail!\");\n            return;\n        }\n        Properties props = new Properties();\n        props.put(KEY_HOST_SETTING, mailProps.getHost());\n        Session session = Session.getInstance(props, null);\n        try {\n            MimeMessage msg = new MimeMessage(session);\n            msg.setFrom(new InternetAddress(mailProps.getFrom()));\n            InternetAddress[] address = {new InternetAddress(user.getEmail())};\n            msg.setRecipients(Message.RecipientType.TO, address);\n            msg.setSubject(subject);\n            msg.setSentDate(new Date());\n            msg.setHeader(\"X-Mailer\", Consts.MAIL_XMAILER);\n            msg.setText(content);\n            msg.saveChanges(); // don't forget this\n            if (mailProps.isAuthrequired()) {\n                if (mailProps.getAuthpass().equals(\"changeme\") || mailProps.getAuthusr().equals(\"changeme\")) {\n                    logger.warn(\"It seems like you didn't change the standard mail auth settings.\");\n                }\n                Transport tr = session.getTransport(\"smtp\");\n                tr.connect(mailProps.getHost(), mailProps.getAuthusr(), mailProps.getAuthpass());\n                tr.sendMessage(msg, msg.getAllRecipients());\n                tr.close();\n            } else {\n                Transport.send(msg);\n            }\n            logger.debug(\"Email sent to \" + user.getUsername());\n        } catch (MessagingException mex) {\n            logger.error(\"Error sending mail: \", mex);\n        }\n    }\n"]]}
{"hexsha": "76d77960f74f16aa7557143e42bf18d5980d2fd6", "ext": "java", "lang": "Java", "content": "public class ClassParsed {\n\n\tprivate Class<?> clz;\n\tprivate String simpleName;\n\tprivate String fullName;\n\tprivate String pkg;\n\tprivate String basePkg;\n\t\n\tprivate String mapping;\n\tprivate Set<String> importSet = new HashSet<>();\n\tprivate List<MethodParsed> methodList = new ArrayList<>();\n\n\tprivate Class actualType;\n\t\n\tpublic ClassParsed(){}\n\tpublic ClassParsed(Class<?> clz2) {\n\t\tthis.clz = clz2;\n\t\tthis.fullName = clz.getName();\n\t\tthis.pkg = clz.getPackage().getName();\n\t\tthis.simpleName = this.fullName.replace(this.pkg+\".\", \"\");\n\t}\n\tpublic Class<?> getClz() {\n\t\treturn clz;\n\t}\n\tpublic void setClz(Class<?> clz) {\n\t\tthis.clz = clz;\n\t}\n\tpublic String getSimpleName() {\n\t\treturn simpleName;\n\t}\n\tpublic void setSimpleName(String simpleName) {\n\t\tthis.simpleName = simpleName;\n\t}\n\tpublic String getFullName() {\n\t\treturn fullName;\n\t}\n\tpublic void setFullName(String fullName) {\n\t\tthis.fullName = fullName;\n\t}\n\tpublic String getMapping() {\n\t\treturn mapping;\n\t}\n\tpublic void setMapping(String mapping) {\n\t\tthis.mapping = mapping;\n\t}\n\tpublic String getPkg() {\n\t\treturn pkg;\n\t}\n\tpublic void setPkg(String pkg) {\n\t\tthis.pkg = pkg;\n\t}\n\tpublic Set<String> getImportSet() {\n\t\treturn importSet;\n\t}\n\n\tpublic Class getActualType() {\n\t\treturn actualType;\n\t}\n\n\tpublic void setActualType(Class actualType) {\n\t\tthis.actualType = actualType;\n\t}\n\n\tpublic void setImportSet(Set<String> importSet) {\n\t\tthis.importSet = importSet;\n\t}\n\tpublic List<MethodParsed> getMethodList() {\n\t\treturn methodList;\n\t}\n\tpublic void setMethodList(List<MethodParsed> methodList) {\n\t\tthis.methodList = methodList;\n\t}\n\tpublic String getBasePkg() {\n\t\treturn basePkg;\n\t}\n\tpublic void setBasePkg(String basePkg) {\n\t\tthis.basePkg = basePkg;\n\t}\n\n\tpublic void createMapping(String pkg,String clzSuffix, String simpleName){\n\t\tString clzMapping = simpleName.replace(clzSuffix, \"\");\n\t\tclzMapping = BeanUtil.getByFirstLower(clzMapping);\n\t\tString find = \"\";\n\t\tif (clzMapping.contains(\"$\")){\n\t\t\tfind = clzMapping.substring(clzMapping.lastIndexOf(\"$\"));\n\t\t\tclzMapping = clzMapping.replace(find,\"\");\n\t\t\tfind = \"/\" + find;\n\t\t}\n\n\t\tpkg = pkg.replace(basePkg, \"\");\n\n\t\tString mapping = pkg;\n\t\tif (! pkg.endsWith(\".\"+clzMapping)){\n\t\t\tmapping = pkg + \".\" + clzMapping;\n\t\t}\n\t\tmapping += find;\n\n\t\tmapping = mapping.replace(\".\", \"/\");\n\t\tsetMapping(mapping);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"ClassParsed [clz=\" + clz + \", simpleName=\" + simpleName + \", fullName=\" + fullName + \", pkg=\" + pkg\n\t\t\t\t+ \", basePkg=\" + basePkg + \", mapping=\" + mapping + \", importSet=\" + importSet + \", methodList=\"\n\t\t\t\t+ methodList + \"]\";\n\t}\n\n}", "class_id": 0, "repo": "zeng33/x7", "file": "x7-core/src/main/java/x7/tools/ClassParsed.java", "last_update_at": "2019-12-06T08:31:09+00:00", "question_id": "76d77960f74f16aa7557143e42bf18d5980d2fd6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ClassParsed {\n\tprivate Class<?> clz;\n\tprivate String simpleName;\n\tprivate String fullName;\n\tprivate String pkg;\n\tprivate String basePkg;\n\t\n\tprivate String mapping;\n\tprivate Set<String> importSet = new HashSet<>();\n\tprivate List<MethodParsed> methodList = new ArrayList<>();\n\tprivate Class actualType;\n\t\n\tpublic ClassParsed(){}\n\tpublic ClassParsed(Class<?> clz2) {\n\t\tthis.clz = clz2;\n\t\tthis.fullName = clz.getName();\n\t\tthis.pkg = clz.getPackage().getName();\n\t\tthis.simpleName = this.fullName.replace(this.pkg+\".\", \"\");\n\t}\n\tpublic Class<?> getClz() {\n\t\treturn clz;\n\t}\n\tpublic void setClz(Class<?> clz) {\n\t\tthis.clz = clz;\n\t}\n\tpublic String getSimpleName() {\n\t\treturn simpleName;\n\t}\n\tpublic void setSimpleName(String simpleName) {\n\t\tthis.simpleName = simpleName;\n\t}\n\tpublic String getFullName() {\n\t\treturn fullName;\n\t}\n\tpublic void setFullName(String fullName) {\n\t\tthis.fullName = fullName;\n\t}\n\tpublic String getMapping() {\n\t\treturn mapping;\n\t}\n\tpublic void setMapping(String mapping) {\n\t\tthis.mapping = mapping;\n\t}\n\tpublic String getPkg() {\n\t\treturn pkg;\n\t}\n\tpublic void setPkg(String pkg) {\n\t\tthis.pkg = pkg;\n\t}\n\tpublic Set<String> getImportSet() {\n\t\treturn importSet;\n\t}\n\tpublic Class getActualType() {\n\t\treturn actualType;\n\t}\n\tpublic void setActualType(Class actualType) {\n\t\tthis.actualType = actualType;\n\t}\n\tpublic void setImportSet(Set<String> importSet) {\n\t\tthis.importSet = importSet;\n\t}\n\tpublic List<MethodParsed> getMethodList() {\n\t\treturn methodList;\n\t}\n\tpublic void setMethodList(List<MethodParsed> methodList) {\n\t\tthis.methodList = methodList;\n\t}\n\tpublic String getBasePkg() {\n\t\treturn basePkg;\n\t}\n\tpublic void setBasePkg(String basePkg) {\n\t\tthis.basePkg = basePkg;\n\t}\n\tpublic void createMapping(String pkg,String clzSuffix, String simpleName){\n\t\tString clzMapping = simpleName.replace(clzSuffix, \"\");\n\t\tclzMapping = BeanUtil.getByFirstLower(clzMapping);\n\t\tString find = \"\";\n\t\tif (clzMapping.contains(\"$\")){\n\t\t\tfind = clzMapping.substring(clzMapping.lastIndexOf(\"$\"));\n\t\t\tclzMapping = clzMapping.replace(find,\"\");\n\t\t\tfind = \"/\" + find;\n\t\t}\n\t\tpkg = pkg.replace(basePkg, \"\");\n\t\tString mapping = pkg;\n\t\tif (! pkg.endsWith(\".\"+clzMapping)){\n\t\t\tmapping = pkg + \".\" + clzMapping;\n\t\t}\n\t\tmapping += find;\n\t\tmapping = mapping.replace(\".\", \"/\");\n\t\tsetMapping(mapping);\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn \"ClassParsed [clz=\" + clz + \", simpleName=\" + simpleName + \", fullName=\" + fullName + \", pkg=\" + pkg\n\t\t\t\t+ \", basePkg=\" + basePkg + \", mapping=\" + mapping + \", importSet=\" + importSet + \", methodList=\"\n\t\t\t\t+ methodList + \"]\";\n\t}\n"]]}
{"hexsha": "3c36230c7f758bdd0997c580bc150ea871a1ca75", "ext": "java", "lang": "Java", "content": "@Singleton\npublic class WorkspaceShareWithMe implements ParameterizedHandler {\n    private final UserRepository userRepository;\n    private final WorkspaceRepository workspaceRepository;\n\n    @Inject\n    public WorkspaceShareWithMe(\n            final UserRepository userRepository,\n            final WorkspaceRepository workspaceRepository\n    ) {\n        this.userRepository = userRepository;\n        this.workspaceRepository = workspaceRepository;\n    }\n\n    @Handle\n    public ClientApiSuccess handle(\n            @Required(name = \"workspaceId\") String workspaceId,\n            @Required(name = \"user-name\") String userName,\n            User me\n    ) throws Exception {\n        User user = userRepository.findByUsername(userName);\n        if (user == null) {\n            throw new OpenLumifyResourceNotFoundException(\"Could not find user: \" + userName);\n        }\n\n        Workspace workspace = workspaceRepository.findById(workspaceId, user);\n        if (workspace == null) {\n            throw new OpenLumifyResourceNotFoundException(\"Could not find workspace: \" + workspaceId);\n        }\n\n        workspaceRepository.updateUserOnWorkspace(workspace, me.getUserId(), WorkspaceAccess.WRITE, user);\n\n        return OpenLumifyResponse.SUCCESS;\n    }\n}", "class_id": 0, "repo": "glennji/openlumify", "file": "web/plugins/admin-user-tools/src/main/java/org/openlumify/web/plugin/adminUserTools/WorkspaceShareWithMe.java", "last_update_at": "2019-10-26T11:39:59+00:00", "question_id": "3c36230c7f758bdd0997c580bc150ea871a1ca75", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Singleton\npublic class WorkspaceShareWithMe implements ParameterizedHandler {\n    private final UserRepository userRepository;\n    private final WorkspaceRepository workspaceRepository;\n    @Inject\n    public WorkspaceShareWithMe(\n            final UserRepository userRepository,\n            final WorkspaceRepository workspaceRepository\n    ) {\n        this.userRepository = userRepository;\n        this.workspaceRepository = workspaceRepository;\n    }\n    @Handle\n    public ClientApiSuccess handle(\n            @Required(name = \"workspaceId\") String workspaceId,\n            @Required(name = \"user-name\") String userName,\n            User me\n    ) throws Exception {\n        User user = userRepository.findByUsername(userName);\n        if (user == null) {\n            throw new OpenLumifyResourceNotFoundException(\"Could not find user: \" + userName);\n        }\n        Workspace workspace = workspaceRepository.findById(workspaceId, user);\n        if (workspace == null) {\n            throw new OpenLumifyResourceNotFoundException(\"Could not find workspace: \" + workspaceId);\n        }\n        workspaceRepository.updateUserOnWorkspace(workspace, me.getUserId(), WorkspaceAccess.WRITE, user);\n        return OpenLumifyResponse.SUCCESS;\n    }\n"]]}
{"hexsha": "2d5b29148a8b28dba3c22519968dbe2adfed787a", "ext": "java", "lang": "Java", "content": "@ExtensionPoint(\n  id = \"FileOpenSaveNewExtensionPoint\",\n  extensionPointId = \"SpoonOpenSaveNew\",\n  description = \"Open the new file browser\"\n)\npublic class FileOpenSaveExtensionPoint implements ExtensionPointInterface {\n\n  private static final String TRANSFORMATION = \"transformation\";\n  private static final String REPOSITORY = \"repository\";\n\n  private static final int WIDTH = ( Const.isOSX() || Const.isLinux() ) ? 930 : 947;\n  private static final int HEIGHT = ( Const.isOSX() || Const.isLinux() ) ? 618 : 626;\n\n  private Supplier<Spoon> spoonSupplier = Spoon::getInstance;\n\n  @Override public void callExtensionPoint( LogChannelInterface logChannelInterface, Object o ) throws KettleException {\n    FileDialogOperation fileDialogOperation = (FileDialogOperation) o;\n\n    FileOpenSaveDialog repositoryOpenSaveDialog =\n      new FileOpenSaveDialog( spoonSupplier.get().getShell(), WIDTH, HEIGHT, logChannelInterface );\n\n    resolveProvider( fileDialogOperation );\n    repositoryOpenSaveDialog.open( fileDialogOperation );\n\n    if ( repositoryOpenSaveDialog.getProvider() != null && repositoryOpenSaveDialog.getProvider()\n      .equalsIgnoreCase( REPOSITORY ) ) {\n      RepositoryObject repositoryObject = new RepositoryObject();\n      repositoryObject.setObjectId( repositoryOpenSaveDialog::getObjectId );\n      repositoryObject.setName( repositoryOpenSaveDialog.getName() );\n      repositoryObject\n        .setRepositoryDirectory( getRepository().findDirectory( repositoryOpenSaveDialog.getParentPath() ) );\n      if ( repositoryOpenSaveDialog.getType() != null ) {\n        repositoryObject.setObjectType(\n          repositoryOpenSaveDialog.getType().equals( TRANSFORMATION ) ? RepositoryObjectType.TRANSFORMATION\n            : RepositoryObjectType.JOB );\n      }\n      fileDialogOperation.setRepositoryObject( repositoryObject );\n      fileDialogOperation.setProvider( repositoryOpenSaveDialog.getProvider() );\n      fileDialogOperation.setFilename( repositoryOpenSaveDialog.getName() );\n    } else {\n      fileDialogOperation.setPath( repositoryOpenSaveDialog.getPath() );\n      fileDialogOperation.setFilename( repositoryOpenSaveDialog.getName() );\n      fileDialogOperation.setConnection( repositoryOpenSaveDialog.getConnection() );\n      fileDialogOperation.setProvider( repositoryOpenSaveDialog.getProvider() );\n    }\n  }\n\n  private void resolveProvider( FileDialogOperation op ) {\n    if ( op.getProvider() == null ) {\n      if ( op.getConnection() != null ) {\n        op.setProvider( VFSFileProvider.TYPE );\n      } else if ( spoonSupplier.get().rep != null ) {\n        op.setProvider( RepositoryFileProvider.TYPE );\n      } else {\n        op.setProvider( LocalFileProvider.TYPE );\n      }\n    }\n  }\n\n  private Repository getRepository() {\n    return RepositoryBrowserController.repository != null ? RepositoryBrowserController.repository\n      : spoonSupplier.get().getRepository();\n  }\n}", "class_id": 0, "repo": "georgeshafik/pentaho-kettle", "file": "plugins/file-open-save-new/core/src/main/java/org/pentaho/di/plugins/fileopensave/extension/FileOpenSaveExtensionPoint.java", "last_update_at": "2019-11-21T14:23:32+00:00", "question_id": "2d5b29148a8b28dba3c22519968dbe2adfed787a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ExtensionPoint(\n  id = \"FileOpenSaveNewExtensionPoint\",\n  extensionPointId = \"SpoonOpenSaveNew\",\n  description = \"Open the new file browser\"\n)\npublic class FileOpenSaveExtensionPoint implements ExtensionPointInterface {\n  private static final String TRANSFORMATION = \"transformation\";\n  private static final String REPOSITORY = \"repository\";\n  private static final int WIDTH = ( Const.isOSX() || Const.isLinux() ) ? 930 : 947;\n  private static final int HEIGHT = ( Const.isOSX() || Const.isLinux() ) ? 618 : 626;\n  private Supplier<Spoon> spoonSupplier = Spoon::getInstance;\n  @Override public void callExtensionPoint( LogChannelInterface logChannelInterface, Object o ) throws KettleException {\n    FileDialogOperation fileDialogOperation = (FileDialogOperation) o;\n    FileOpenSaveDialog repositoryOpenSaveDialog =\n      new FileOpenSaveDialog( spoonSupplier.get().getShell(), WIDTH, HEIGHT, logChannelInterface );\n    resolveProvider( fileDialogOperation );\n    repositoryOpenSaveDialog.open( fileDialogOperation );\n    if ( repositoryOpenSaveDialog.getProvider() != null && repositoryOpenSaveDialog.getProvider()\n      .equalsIgnoreCase( REPOSITORY ) ) {\n      RepositoryObject repositoryObject = new RepositoryObject();\n      repositoryObject.setObjectId( repositoryOpenSaveDialog::getObjectId );\n      repositoryObject.setName( repositoryOpenSaveDialog.getName() );\n      repositoryObject\n        .setRepositoryDirectory( getRepository().findDirectory( repositoryOpenSaveDialog.getParentPath() ) );\n      if ( repositoryOpenSaveDialog.getType() != null ) {\n        repositoryObject.setObjectType(\n          repositoryOpenSaveDialog.getType().equals( TRANSFORMATION ) ? RepositoryObjectType.TRANSFORMATION\n            : RepositoryObjectType.JOB );\n      }\n      fileDialogOperation.setRepositoryObject( repositoryObject );\n      fileDialogOperation.setProvider( repositoryOpenSaveDialog.getProvider() );\n      fileDialogOperation.setFilename( repositoryOpenSaveDialog.getName() );\n    } else {\n      fileDialogOperation.setPath( repositoryOpenSaveDialog.getPath() );\n      fileDialogOperation.setFilename( repositoryOpenSaveDialog.getName() );\n      fileDialogOperation.setConnection( repositoryOpenSaveDialog.getConnection() );\n      fileDialogOperation.setProvider( repositoryOpenSaveDialog.getProvider() );\n    }\n  }\n  private void resolveProvider( FileDialogOperation op ) {\n    if ( op.getProvider() == null ) {\n      if ( op.getConnection() != null ) {\n        op.setProvider( VFSFileProvider.TYPE );\n      } else if ( spoonSupplier.get().rep != null ) {\n        op.setProvider( RepositoryFileProvider.TYPE );\n      } else {\n        op.setProvider( LocalFileProvider.TYPE );\n      }\n    }\n  }\n  private Repository getRepository() {\n    return RepositoryBrowserController.repository != null ? RepositoryBrowserController.repository\n      : spoonSupplier.get().getRepository();\n  }\n"]]}
{"hexsha": "3972e76df8fb5123c864af245858ee78215452f5", "ext": "java", "lang": "Java", "content": "public class Stealth_Mode extends CustomCard {\n    public static final String ID = \"Yohane:Stealth_Mode\";\n    private static CardStrings cardStrings = CardCrawlGame.languagePack.getCardStrings(ID);\n    public static final String NAME = cardStrings.NAME;\n    public static final String DESCRIPTION = cardStrings.DESCRIPTION;\n    public static final String IMG_PATH = \"cards/Stealth_Mode.png\";\n    private static final int COST = 0;\n    private static final int POOL = 1;\n    private static final int INTANGIBLE = 1;\n    private static final CardRarity rarity = CardRarity.RARE;\n    private static final CardTarget target = CardTarget.SELF;\n\n    public Stealth_Mode() {\n        super(ID, NAME, IMG_PATH, COST, DESCRIPTION,\n                CardType.SKILL, AbstractCardEnum.YOHANE_GREY,\n                        rarity, target);\n        this.magicNumber = this.baseMagicNumber = INTANGIBLE;\n        this.retain = true;\n    }\n\n    @Override\n    public void use(AbstractPlayer p, AbstractMonster m) {\n    }\n\n    @Override\n    public void applyPowers() {\n        super.applyPowers();\n        this.retain = true;\n    }\n\n    public void triggerOnEndOfTurnForPlayingCard() {\n        AbstractPlayer p = AbstractDungeon.player;\n        if (!p.drawPile.group.isEmpty()) {\n            for (AbstractCard c : p.drawPile.group) {\n                c.current_y = (-200.0F * Settings.scale);\n                c.target_x = (Settings.WIDTH / 2.0F + 200.0F);\n                c.target_y = (Settings.HEIGHT / 2.0F);\n                c.targetAngle = 0.0F;\n                c.lighten(false);\n                c.drawScale = 0.12F;\n                c.targetDrawScale = 0.75F;\n                AbstractDungeon.actionManager.addToBottom(new ExhaustSpecificCardAction(c, p.drawPile));\n            }\n        }\n        if (!p.discardPile.group.isEmpty()) {\n            for (AbstractCard c : p.discardPile.group) {\n                c.current_y = (-200.0F * Settings.scale);\n                c.target_x = (Settings.WIDTH / 2.0F + 200.0F);\n                c.target_y = (Settings.HEIGHT / 2.0F);\n                c.targetAngle = 0.0F;\n                c.lighten(false);\n                c.drawScale = 0.12F;\n                c.targetDrawScale = 0.75F;\n                AbstractDungeon.actionManager.addToBottom(new ExhaustSpecificCardAction(c, p.discardPile));\n            }\n        } else {\n            for (AbstractCard c : p.hand.group) {\n                AbstractDungeon.actionManager.addToBottom(new ExhaustSpecificCardAction(c, p.hand));\n            }\n        }\n        AbstractDungeon.actionManager.addToBottom(new com.megacrit.cardcrawl.actions.common.ApplyPowerAction(p, p, new IntangiblePlayerPower(p, this.magicNumber), this.magicNumber));\n    }\n    \n\n    @Override\n    public AbstractCard makeCopy() {\n        return new Stealth_Mode();\n    }\n\n    @Override\n    public void upgrade() {\n        if (!this.upgraded) {\n            this.upgradeName();\n        }\n    }\n\n}", "class_id": 0, "repo": "squeeny/Yohane-", "file": "src/main/java/yohanemod/cards/Stealth_Mode.java", "last_update_at": "2019-01-26T11:46:03+00:00", "question_id": "3972e76df8fb5123c864af245858ee78215452f5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Stealth_Mode extends CustomCard {\n    public static final String ID = \"Yohane:Stealth_Mode\";\n    private static CardStrings cardStrings = CardCrawlGame.languagePack.getCardStrings(ID);\n    public static final String NAME = cardStrings.NAME;\n    public static final String DESCRIPTION = cardStrings.DESCRIPTION;\n    public static final String IMG_PATH = \"cards/Stealth_Mode.png\";\n    private static final int COST = 0;\n    private static final int POOL = 1;\n    private static final int INTANGIBLE = 1;\n    private static final CardRarity rarity = CardRarity.RARE;\n    private static final CardTarget target = CardTarget.SELF;\n    public Stealth_Mode() {\n        super(ID, NAME, IMG_PATH, COST, DESCRIPTION,\n                CardType.SKILL, AbstractCardEnum.YOHANE_GREY,\n                        rarity, target);\n        this.magicNumber = this.baseMagicNumber = INTANGIBLE;\n        this.retain = true;\n    }\n    @Override\n    public void use(AbstractPlayer p, AbstractMonster m) {\n    }\n    @Override\n    public void applyPowers() {\n        super.applyPowers();\n        this.retain = true;\n    }\n    public void triggerOnEndOfTurnForPlayingCard() {\n        AbstractPlayer p = AbstractDungeon.player;\n        if (!p.drawPile.group.isEmpty()) {\n            for (AbstractCard c : p.drawPile.group) {\n                c.current_y = (-200.0F * Settings.scale);\n                c.target_x = (Settings.WIDTH / 2.0F + 200.0F);\n                c.target_y = (Settings.HEIGHT / 2.0F);\n                c.targetAngle = 0.0F;\n                c.lighten(false);\n                c.drawScale = 0.12F;\n                c.targetDrawScale = 0.75F;\n                AbstractDungeon.actionManager.addToBottom(new ExhaustSpecificCardAction(c, p.drawPile));\n            }\n        }\n        if (!p.discardPile.group.isEmpty()) {\n            for (AbstractCard c : p.discardPile.group) {\n                c.current_y = (-200.0F * Settings.scale);\n                c.target_x = (Settings.WIDTH / 2.0F + 200.0F);\n                c.target_y = (Settings.HEIGHT / 2.0F);\n                c.targetAngle = 0.0F;\n                c.lighten(false);\n                c.drawScale = 0.12F;\n                c.targetDrawScale = 0.75F;\n                AbstractDungeon.actionManager.addToBottom(new ExhaustSpecificCardAction(c, p.discardPile));\n            }\n        } else {\n            for (AbstractCard c : p.hand.group) {\n                AbstractDungeon.actionManager.addToBottom(new ExhaustSpecificCardAction(c, p.hand));\n            }\n        }\n        AbstractDungeon.actionManager.addToBottom(new com.megacrit.cardcrawl.actions.common.ApplyPowerAction(p, p, new IntangiblePlayerPower(p, this.magicNumber), this.magicNumber));\n    }\n    @Override\n    public AbstractCard makeCopy() {\n        return new Stealth_Mode();\n    }\n    @Override\n    public void upgrade() {\n        if (!this.upgraded) {\n            this.upgradeName();\n        }\n    }\n"]]}
{"hexsha": "7e3140f478b7540ebbfc7ed008247e37f6c66bda", "ext": "java", "lang": "Java", "content": "public class OutputConnection {\n\n    public static Connection _con;\n\n    public OutputConnection(String url) {\n        Connect(url);\n        CreateGraphSQL();\n    }\n\n    private void Connect(String url) {\n        try {\n            _con = DriverManager.getConnection(url);\n            System.out.println(\"Connection for output established.\");\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void DropTablesIfExists() {\n        try {\n            Statement stmt = _con.createStatement();\n            stmt.executeUpdate(\"DROP TABLE IF EXISTS node;\");\n            stmt.executeUpdate(\"DROP TABLE IF EXISTS edge;\");\n            stmt.executeUpdate(\"DROP TABLE IF EXISTS property;\");\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void CreateNodeTable() {\n        try {\n            Statement stmt = _con.createStatement();\n            stmt.executeUpdate(\"CREATE TABLE node(id INTEGER NOT NULL, label TEXT, PRIMARY KEY (id));\");\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void CreateEdgeTable() {\n        try {\n            Statement stmt = _con.createStatement();\n            stmt.executeUpdate(\n                    \"CREATE TABLE edge(id INTEGER NOT NULL, srcId INTEGER, tgtId INTEGER, label TEXT, PRIMARY KEY (id));\");\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void CreatePropertyTable() {\n        try {\n            Statement stmt = _con.createStatement();\n            stmt.executeUpdate(\n                    \"CREATE TABLE property(id INTEGER NOT NULL, pkey VARCHAR(256), pvalue TEXT, PRIMARY KEY (id, pkey));\");\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void InsertPropertyRow(ResultSet values, ResultSetMetaData valuesMd, String currIdentifier) {\n\n        String sql = \"INSERT INTO property VALUES(?,?,?);\";\n        try {\n            int length = valuesMd.getColumnCount();\n\n            PreparedStatement st = _con.prepareStatement(sql);\n            for (int i = 1; i < length; i++) {\n                String currAtt = valuesMd.getColumnName(i);\n                Object currVal = values.getObject(i);\n                if (currVal != null) {\n                    Property prop = new Property(currIdentifier, currAtt, currVal.toString());\n                    st.setInt(1, Integer.parseInt(prop.Id));\n                    st.setString(2, prop.Key);\n                    st.setString(3, prop.Value);\n                    st.addBatch();\n                }\n            }\n            int[] result = st.executeBatch();\n            System.out.println(result.length + \" property(ies) added.\");\n\n        } catch (SQLException e) {\n            System.out.println(sql);\n            e.printStackTrace();\n        }\n    }\n\n    public static void InsertEdgeRow(Edge edge) {\n        try {\n            App._statementEdges.setInt(1, Integer.parseInt(edge.Id));\n            App._statementEdges.setInt(2, Integer.parseInt(edge.SrcId));\n            App._statementEdges.setInt(3, Integer.parseInt(edge.TgtId));\n            App._statementEdges.setString(4, edge.Label);\n            App._statementEdges.addBatch();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void InsertNodeRow(Node n) {\n        try {\n            String sql = \"INSERT INTO node VALUES(?,?);\";\n            PreparedStatement st = _con.prepareStatement(sql);\n            st.setInt(1, Integer.parseInt(n.Id));\n            st.setString(2, n.Label);\n\n            Integer result = st.executeUpdate();\n            System.out.println(result.toString().concat(\" node added.\"));\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static List<String> JoinNodeAndProperty(String relName, String key, String val) {\n        String sql = \"SELECT n.id, n.label, p.pkey, p.pvalue FROM node n INNER JOIN property p ON n.id = p.id AND p.pvalue='\"\n                .concat(val).concat(\"' AND p.pkey='\").concat(key).concat(\"' AND n.label='\").concat(relName)\n                .concat(\"';\");\n        List<String> results = new ArrayList<>();\n\n        try {\n            Statement stmt = _con.createStatement();\n            ResultSet values = stmt.executeQuery(sql);\n            while (values.next()) {\n                results.add(values.getString(1));\n            }\n        } catch (SQLException e) {\n            System.out.println(sql);\n            e.printStackTrace();\n            return null;\n        } finally {\n            return results;\n        }\n\n    }\n\n    public static void Statistics() {\n        String sql = \"SELECT COUNT(*) as stats FROM node UNION SELECT COUNT(*) FROM property UNION SELECT COUNT(*) FROM edge;\";\n        List<String> results = new ArrayList<>();\n\n        try {\n            Statement stmt = _con.createStatement();\n            ResultSet values = stmt.executeQuery(sql);\n            while (values.next()) {\n                results.add(values.getString(1));\n            }\n        } catch (SQLException e) {\n            System.out.println(sql);\n            e.printStackTrace();\n        } finally {\n            System.out.println(\"# Nodes: \".concat(results.get(0)));\n            System.out.println(\"# Properties: \".concat(results.get(1)));\n            System.out.println(\"# Edges: \".concat(results.get(2)));\n        }\n    }\n\n    public static ResultSet GetNodeData() {\n        String sql = \"select * from node;\";\n\n        try {\n            PreparedStatement stmt = _con.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY,\n                    ResultSet.CONCUR_READ_ONLY);\n            stmt.setFetchSize(500);\n            ResultSet values = stmt.executeQuery();\n            return values;\n        } catch (SQLException e) {\n            System.out.println(sql);\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public static ResultSet GetPropertyData() {\n        String sql = \"select * from property;\";\n\n        try {\n            PreparedStatement stmt = _con.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY,\n                    ResultSet.CONCUR_READ_ONLY);\n            stmt.setFetchSize(500);\n            ResultSet values = stmt.executeQuery();\n            return values;\n        } catch (SQLException e) {\n            System.out.println(sql);\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public static ResultSet GetEdgeData() {\n        String sql = \"select * from edge;\";\n\n        try {\n            PreparedStatement stmt = _con.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY,\n                    ResultSet.CONCUR_READ_ONLY);\n            stmt.setFetchSize(500);\n            ResultSet values = stmt.executeQuery();\n            return values;\n        } catch (SQLException e) {\n            System.out.println(sql);\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public void CreateGraphSQL() {\n        DropTablesIfExists();\n        CreateNodeTable();\n        CreateEdgeTable();\n        CreatePropertyTable();\n        System.out.println(\"Mapping - Created tables.\");\n    }\n}", "class_id": 0, "repo": "radualex/R2PG-DM", "file": "java-project/src/main/java/com/java/r2pgdm/OutputConnection.java", "last_update_at": "2019-10-08T11:00:09+00:00", "question_id": "7e3140f478b7540ebbfc7ed008247e37f6c66bda", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OutputConnection {\n    public static Connection _con;\n    public OutputConnection(String url) {\n        Connect(url);\n        CreateGraphSQL();\n    }\n    private void Connect(String url) {\n        try {\n            _con = DriverManager.getConnection(url);\n            System.out.println(\"Connection for output established.\");\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    private void DropTablesIfExists() {\n        try {\n            Statement stmt = _con.createStatement();\n            stmt.executeUpdate(\"DROP TABLE IF EXISTS node;\");\n            stmt.executeUpdate(\"DROP TABLE IF EXISTS edge;\");\n            stmt.executeUpdate(\"DROP TABLE IF EXISTS property;\");\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    private void CreateNodeTable() {\n        try {\n            Statement stmt = _con.createStatement();\n            stmt.executeUpdate(\"CREATE TABLE node(id INTEGER NOT NULL, label TEXT, PRIMARY KEY (id));\");\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    private void CreateEdgeTable() {\n        try {\n            Statement stmt = _con.createStatement();\n            stmt.executeUpdate(\n                    \"CREATE TABLE edge(id INTEGER NOT NULL, srcId INTEGER, tgtId INTEGER, label TEXT, PRIMARY KEY (id));\");\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    private void CreatePropertyTable() {\n        try {\n            Statement stmt = _con.createStatement();\n            stmt.executeUpdate(\n                    \"CREATE TABLE property(id INTEGER NOT NULL, pkey VARCHAR(256), pvalue TEXT, PRIMARY KEY (id, pkey));\");\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    public static void InsertPropertyRow(ResultSet values, ResultSetMetaData valuesMd, String currIdentifier) {\n        String sql = \"INSERT INTO property VALUES(?,?,?);\";\n        try {\n            int length = valuesMd.getColumnCount();\n            PreparedStatement st = _con.prepareStatement(sql);\n            for (int i = 1; i < length; i++) {\n                String currAtt = valuesMd.getColumnName(i);\n                Object currVal = values.getObject(i);\n                if (currVal != null) {\n                    Property prop = new Property(currIdentifier, currAtt, currVal.toString());\n                    st.setInt(1, Integer.parseInt(prop.Id));\n                    st.setString(2, prop.Key);\n                    st.setString(3, prop.Value);\n                    st.addBatch();\n                }\n            }\n            int[] result = st.executeBatch();\n            System.out.println(result.length + \" property(ies) added.\");\n        } catch (SQLException e) {\n            System.out.println(sql);\n            e.printStackTrace();\n        }\n    }\n    public static void InsertEdgeRow(Edge edge) {\n        try {\n            App._statementEdges.setInt(1, Integer.parseInt(edge.Id));\n            App._statementEdges.setInt(2, Integer.parseInt(edge.SrcId));\n            App._statementEdges.setInt(3, Integer.parseInt(edge.TgtId));\n            App._statementEdges.setString(4, edge.Label);\n            App._statementEdges.addBatch();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    public static void InsertNodeRow(Node n) {\n        try {\n            String sql = \"INSERT INTO node VALUES(?,?);\";\n            PreparedStatement st = _con.prepareStatement(sql);\n            st.setInt(1, Integer.parseInt(n.Id));\n            st.setString(2, n.Label);\n            Integer result = st.executeUpdate();\n            System.out.println(result.toString().concat(\" node added.\"));\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    public static List<String> JoinNodeAndProperty(String relName, String key, String val) {\n        String sql = \"SELECT n.id, n.label, p.pkey, p.pvalue FROM node n INNER JOIN property p ON n.id = p.id AND p.pvalue='\"\n                .concat(val).concat(\"' AND p.pkey='\").concat(key).concat(\"' AND n.label='\").concat(relName)\n                .concat(\"';\");\n        List<String> results = new ArrayList<>();\n        try {\n            Statement stmt = _con.createStatement();\n            ResultSet values = stmt.executeQuery(sql);\n            while (values.next()) {\n                results.add(values.getString(1));\n            }\n        } catch (SQLException e) {\n            System.out.println(sql);\n            e.printStackTrace();\n            return null;\n        } finally {\n            return results;\n        }\n    }\n    public static void Statistics() {\n        String sql = \"SELECT COUNT(*) as stats FROM node UNION SELECT COUNT(*) FROM property UNION SELECT COUNT(*) FROM edge;\";\n        List<String> results = new ArrayList<>();\n        try {\n            Statement stmt = _con.createStatement();\n            ResultSet values = stmt.executeQuery(sql);\n            while (values.next()) {\n                results.add(values.getString(1));\n            }\n        } catch (SQLException e) {\n            System.out.println(sql);\n            e.printStackTrace();\n        } finally {\n            System.out.println(\"# Nodes: \".concat(results.get(0)));\n            System.out.println(\"# Properties: \".concat(results.get(1)));\n            System.out.println(\"# Edges: \".concat(results.get(2)));\n        }\n    }\n    public static ResultSet GetNodeData() {\n        String sql = \"select * from node;\";\n        try {\n            PreparedStatement stmt = _con.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY,\n                    ResultSet.CONCUR_READ_ONLY);\n            stmt.setFetchSize(500);\n            ResultSet values = stmt.executeQuery();\n            return values;\n        } catch (SQLException e) {\n            System.out.println(sql);\n            e.printStackTrace();\n            return null;\n        }\n    }\n    public static ResultSet GetPropertyData() {\n        String sql = \"select * from property;\";\n        try {\n            PreparedStatement stmt = _con.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY,\n                    ResultSet.CONCUR_READ_ONLY);\n            stmt.setFetchSize(500);\n            ResultSet values = stmt.executeQuery();\n            return values;\n        } catch (SQLException e) {\n            System.out.println(sql);\n            e.printStackTrace();\n            return null;\n        }\n    }\n    public static ResultSet GetEdgeData() {\n        String sql = \"select * from edge;\";\n        try {\n            PreparedStatement stmt = _con.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY,\n                    ResultSet.CONCUR_READ_ONLY);\n            stmt.setFetchSize(500);\n            ResultSet values = stmt.executeQuery();\n            return values;\n        } catch (SQLException e) {\n            System.out.println(sql);\n            e.printStackTrace();\n            return null;\n        }\n    }\n    public void CreateGraphSQL() {\n        DropTablesIfExists();\n        CreateNodeTable();\n        CreateEdgeTable();\n        CreatePropertyTable();\n        System.out.println(\"Mapping - Created tables.\");\n    }\n"]]}
{"hexsha": "ee59db94735aa440c35792460eda6bdcf7b49c3f", "ext": "java", "lang": "Java", "content": "public final class XServletHandlerToSimpleHandler implements IXServletHandler\n{\n  private static final Logger LOGGER = LoggerFactory.getLogger (XServletHandlerToSimpleHandler.class);\n\n  private final IMutableStatisticsHandlerCounter m_aStatsHasLastModification = StatisticsManager.getCounterHandler (getClass ().getName () +\n                                                                                                                    \"$has-lastmodification\");\n  private final IMutableStatisticsHandlerCounter m_aStatsHasETag = StatisticsManager.getCounterHandler (getClass ().getName () +\n                                                                                                        \"$has-etag\");\n  private final IMutableStatisticsHandlerCounter m_aStatsNotModifiedIfModifiedSince = StatisticsManager.getCounterHandler (getClass ().getName () +\n                                                                                                                           \"$notmodified.if-modified-since\");\n  private final IMutableStatisticsHandlerCounter m_aStatsModifiedIfModifiedSince = StatisticsManager.getCounterHandler (getClass ().getName () +\n                                                                                                                        \"$modified.if-modified-since\");\n  private final IMutableStatisticsHandlerCounter m_aStatsNotModifiedIfUnmodifiedSince = StatisticsManager.getCounterHandler (getClass ().getName () +\n                                                                                                                             \"$notmodified.if-unmodified-since\");\n  private final IMutableStatisticsHandlerCounter m_aStatsModifiedIfUnmodifiedSince = StatisticsManager.getCounterHandler (getClass ().getName () +\n                                                                                                                          \"$modified.if-unmodified-since\");\n  private final IMutableStatisticsHandlerCounter m_aStatsNotModifiedIfNonMatch = StatisticsManager.getCounterHandler (getClass ().getName () +\n                                                                                                                      \"$notmodified.if-unon-match\");\n  private final IMutableStatisticsHandlerCounter m_aStatsModifiedIfNonMatch = StatisticsManager.getCounterHandler (getClass ().getName () +\n                                                                                                                   \"$modified.if-unon-match\");\n\n  private final IXServletSimpleHandler m_aSimpleHandler;\n\n  public XServletHandlerToSimpleHandler (@Nonnull final IXServletSimpleHandler aSimpleHandler)\n  {\n    ValueEnforcer.notNull (aSimpleHandler, \"SimpleHandler\");\n    m_aSimpleHandler = aSimpleHandler;\n  }\n\n  @Override\n  public void onServletInit (@Nonnull final ICommonsMap <String, String> aInitParams) throws ServletException\n  {\n    // Pass-through!\n    m_aSimpleHandler.onServletInit (aInitParams);\n  }\n\n  private void _onException (@Nonnull final IRequestWebScopeWithoutResponse aRequestScope,\n                             @Nonnull final UnifiedResponse aUnifiedResponse,\n                             @Nonnull final Throwable t) throws IOException, ServletException\n  {\n    if (LOGGER.isErrorEnabled ())\n      LOGGER.error (\"An exception was caught in servlet processing for URL '\" + aRequestScope.getURL () + \"'\", t);\n\n    // Invoke exception handler\n    if (m_aSimpleHandler.onException (aRequestScope, aUnifiedResponse, t).isContinue ())\n    {\n      // Propagate exception\n      if (t instanceof IOException)\n        throw (IOException) t;\n      if (t instanceof ServletException)\n        throw (ServletException) t;\n      throw new ServletException (t);\n    }\n  }\n\n  @Nonnull\n  private EContinue _handleETag (@Nonnull final HttpServletRequest aHttpRequest,\n                                 @Nonnull final IRequestWebScopeWithoutResponse aRequestScope,\n                                 @Nonnull final UnifiedResponse aUnifiedResponse)\n  {\n    final LocalDateTime aLastModification = m_aSimpleHandler.getLastModificationDateTime (aRequestScope);\n    if (aLastModification != null)\n    {\n      m_aStatsHasLastModification.increment ();\n\n      // Get the If-Modified-Since date header\n      final long nRequestIfModifiedSince = aHttpRequest.getDateHeader (CHttpHeader.IF_MODIFIED_SINCE);\n      if (nRequestIfModifiedSince >= 0)\n      {\n        final LocalDateTime aRequestIfModifiedSince = CHttp.convertMillisToLocalDateTime (nRequestIfModifiedSince);\n        if (aLastModification.compareTo (aRequestIfModifiedSince) <= 0)\n        {\n          if (LOGGER.isDebugEnabled ())\n            LOGGER.debug (\"Requested resource was not modified: \" + aRequestScope.getPathWithinServlet ());\n\n          // Was not modified since the passed time\n          m_aStatsNotModifiedIfModifiedSince.increment ();\n          return EContinue.BREAK;\n        }\n        m_aStatsModifiedIfModifiedSince.increment ();\n      }\n\n      // Get the If-Unmodified-Since date header\n      final long nRequestIfUnmodifiedSince = aHttpRequest.getDateHeader (CHttpHeader.IF_UNMODIFIED_SINCE);\n      if (nRequestIfUnmodifiedSince >= 0)\n      {\n        final LocalDateTime aRequestIfUnmodifiedSince = CHttp.convertMillisToLocalDateTime (nRequestIfUnmodifiedSince);\n        if (aLastModification.compareTo (aRequestIfUnmodifiedSince) >= 0)\n        {\n          if (LOGGER.isDebugEnabled ())\n            LOGGER.debug (\"Requested resource was not modified: \" + aRequestScope.getPathWithinServlet ());\n\n          // Was not modified since the passed time\n          m_aStatsNotModifiedIfUnmodifiedSince.increment ();\n          return EContinue.BREAK;\n        }\n        m_aStatsModifiedIfUnmodifiedSince.increment ();\n      }\n\n      // No If-Modified-Since request header present, set the Last-Modified\n      // header for later reuse\n      aUnifiedResponse.setLastModified (aLastModification);\n    }\n\n    // Handle the ETag\n    final String sSupportedETag = m_aSimpleHandler.getSupportedETag (aRequestScope);\n    if (StringHelper.hasText (sSupportedETag))\n    {\n      m_aStatsHasETag.increment ();\n\n      // get the request ETag\n      final String sRequestETags = aHttpRequest.getHeader (CHttpHeader.IF_NON_MATCH);\n      if (StringHelper.hasText (sRequestETags))\n      {\n        // Request header may contain several ETag values\n        final ICommonsList <String> aAllETags = RegExHelper.getSplitToList (sRequestETags, \",\\\\s+\");\n        if (aAllETags.isEmpty ())\n        {\n          if (LOGGER.isWarnEnabled ())\n            LOGGER.warn (\"Empty ETag list found (\" + sRequestETags + \")\");\n        }\n        else\n        {\n          // Scan all found ETags for match\n          for (final String sCurrentETag : aAllETags)\n            if (sSupportedETag.equals (sCurrentETag))\n            {\n              if (LOGGER.isDebugEnabled ())\n                LOGGER.debug (\"Requested resource has the same E-Tag: \" + aRequestScope.getPathWithinServlet ());\n\n              // We have a matching ETag\n              m_aStatsNotModifiedIfNonMatch.increment ();\n              return EContinue.BREAK;\n            }\n        }\n        m_aStatsModifiedIfNonMatch.increment ();\n      }\n\n      // Save the ETag for the response\n      aUnifiedResponse.setETagIfApplicable (sSupportedETag);\n    }\n    return EContinue.CONTINUE;\n  }\n\n  public void onRequest (@Nonnull final HttpServletRequest aHttpRequest,\n                         @Nonnull final HttpServletResponse aHttpResponse,\n                         @Nonnull final EHttpVersion eHttpVersion,\n                         @Nonnull final EHttpMethod eHttpMethod,\n                         @Nonnull final IRequestWebScope aRequestScope) throws ServletException, IOException\n  {\n    final UnifiedResponse aUnifiedResponse = m_aSimpleHandler.createUnifiedResponse (eHttpVersion,\n                                                                                     eHttpMethod,\n                                                                                     aHttpRequest,\n                                                                                     aRequestScope);\n    if (m_aSimpleHandler.initRequestState (aRequestScope, aUnifiedResponse).isBreak ())\n    {\n      if (LOGGER.isDebugEnabled ())\n        LOGGER.debug (\"Cancelled request after initRequestState with response \" + aUnifiedResponse);\n\n      // May e.g. be an 404 error for some not-found resource\n    }\n    else\n    {\n      // Init was successful\n\n      // Check for last-modification on GET and HEAD\n      boolean bExecute = true;\n      if (eHttpMethod == EHttpMethod.GET || eHttpMethod == EHttpMethod.HEAD)\n        if (_handleETag (aHttpRequest, aRequestScope, aUnifiedResponse).isBreak ())\n        {\n          // ETag present in request\n          aUnifiedResponse.setStatus (HttpServletResponse.SC_NOT_MODIFIED);\n          bExecute = false;\n        }\n\n      if (bExecute)\n      {\n        // On request begin\n        try\n        {\n          m_aSimpleHandler.onRequestBegin (aRequestScope);\n        }\n        catch (final Throwable t)\n        {\n          _onException (aRequestScope, aUnifiedResponse, t);\n        }\n\n        Throwable aCaughtException = null;\n        try\n        {\n          // main servlet handling\n          m_aSimpleHandler.handleRequest (aRequestScope, aUnifiedResponse);\n\n          if (LOGGER.isDebugEnabled ())\n            LOGGER.debug (\"Successfully handled request: \" + aRequestScope.getPathWithinServlet ());\n        }\n        catch (final ForcedRedirectException ex)\n        {\n          // Pass through\n          throw ex;\n        }\n        catch (final Exception ex)\n        {\n          // Invoke exception handler\n          // This internally re-throws the exception if needed\n          aCaughtException = ex;\n          _onException (aRequestScope, aUnifiedResponse, ex);\n        }\n        finally\n        {\n          // On request end\n          try\n          {\n            m_aSimpleHandler.onRequestEnd (aCaughtException);\n          }\n          catch (final Exception ex)\n          {\n            LOGGER.error (\"onRequestEnd failed\", ex);\n            // Don't throw anything here\n          }\n        }\n      }\n    }\n    aUnifiedResponse.applyToResponse (aHttpResponse);\n  }\n\n  @Override\n  public void onServletDestroy ()\n  {\n    // Pass-through!\n    m_aSimpleHandler.onServletDestroy ();\n  }\n}", "class_id": 0, "repo": "xianleizheng/ph-web", "file": "ph-xservlet/src/main/java/com/helger/xservlet/handler/simple/XServletHandlerToSimpleHandler.java", "last_update_at": "2019-10-18T17:48:20+00:00", "question_id": "ee59db94735aa440c35792460eda6bdcf7b49c3f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class XServletHandlerToSimpleHandler implements IXServletHandler\n{\n  private static final Logger LOGGER = LoggerFactory.getLogger (XServletHandlerToSimpleHandler.class);\n  private final IMutableStatisticsHandlerCounter m_aStatsHasLastModification = StatisticsManager.getCounterHandler (getClass ().getName () +\n                                                                                                                    \"$has-lastmodification\");\n  private final IMutableStatisticsHandlerCounter m_aStatsHasETag = StatisticsManager.getCounterHandler (getClass ().getName () +\n                                                                                                        \"$has-etag\");\n  private final IMutableStatisticsHandlerCounter m_aStatsNotModifiedIfModifiedSince = StatisticsManager.getCounterHandler (getClass ().getName () +\n                                                                                                                           \"$notmodified.if-modified-since\");\n  private final IMutableStatisticsHandlerCounter m_aStatsModifiedIfModifiedSince = StatisticsManager.getCounterHandler (getClass ().getName () +\n                                                                                                                        \"$modified.if-modified-since\");\n  private final IMutableStatisticsHandlerCounter m_aStatsNotModifiedIfUnmodifiedSince = StatisticsManager.getCounterHandler (getClass ().getName () +\n                                                                                                                             \"$notmodified.if-unmodified-since\");\n  private final IMutableStatisticsHandlerCounter m_aStatsModifiedIfUnmodifiedSince = StatisticsManager.getCounterHandler (getClass ().getName () +\n                                                                                                                          \"$modified.if-unmodified-since\");\n  private final IMutableStatisticsHandlerCounter m_aStatsNotModifiedIfNonMatch = StatisticsManager.getCounterHandler (getClass ().getName () +\n                                                                                                                      \"$notmodified.if-unon-match\");\n  private final IMutableStatisticsHandlerCounter m_aStatsModifiedIfNonMatch = StatisticsManager.getCounterHandler (getClass ().getName () +\n                                                                                                                   \"$modified.if-unon-match\");\n  private final IXServletSimpleHandler m_aSimpleHandler;\n  public XServletHandlerToSimpleHandler (@Nonnull final IXServletSimpleHandler aSimpleHandler)\n  {\n    ValueEnforcer.notNull (aSimpleHandler, \"SimpleHandler\");\n    m_aSimpleHandler = aSimpleHandler;\n  }\n  @Override\n  public void onServletInit (@Nonnull final ICommonsMap <String, String> aInitParams) throws ServletException\n  {\n    // Pass-through!\n    m_aSimpleHandler.onServletInit (aInitParams);\n  }\n  private void _onException (@Nonnull final IRequestWebScopeWithoutResponse aRequestScope,\n                             @Nonnull final UnifiedResponse aUnifiedResponse,\n                             @Nonnull final Throwable t) throws IOException, ServletException\n  {\n    if (LOGGER.isErrorEnabled ())\n      LOGGER.error (\"An exception was caught in servlet processing for URL '\" + aRequestScope.getURL () + \"'\", t);\n    // Invoke exception handler\n    if (m_aSimpleHandler.onException (aRequestScope, aUnifiedResponse, t).isContinue ())\n    {\n      // Propagate exception\n      if (t instanceof IOException)\n        throw (IOException) t;\n      if (t instanceof ServletException)\n        throw (ServletException) t;\n      throw new ServletException (t);\n    }\n  }\n  @Nonnull\n  private EContinue _handleETag (@Nonnull final HttpServletRequest aHttpRequest,\n                                 @Nonnull final IRequestWebScopeWithoutResponse aRequestScope,\n                                 @Nonnull final UnifiedResponse aUnifiedResponse)\n  {\n    final LocalDateTime aLastModification = m_aSimpleHandler.getLastModificationDateTime (aRequestScope);\n    if (aLastModification != null)\n    {\n      m_aStatsHasLastModification.increment ();\n      // Get the If-Modified-Since date header\n      final long nRequestIfModifiedSince = aHttpRequest.getDateHeader (CHttpHeader.IF_MODIFIED_SINCE);\n      if (nRequestIfModifiedSince >= 0)\n      {\n        final LocalDateTime aRequestIfModifiedSince = CHttp.convertMillisToLocalDateTime (nRequestIfModifiedSince);\n        if (aLastModification.compareTo (aRequestIfModifiedSince) <= 0)\n        {\n          if (LOGGER.isDebugEnabled ())\n            LOGGER.debug (\"Requested resource was not modified: \" + aRequestScope.getPathWithinServlet ());\n          // Was not modified since the passed time\n          m_aStatsNotModifiedIfModifiedSince.increment ();\n          return EContinue.BREAK;\n        }\n        m_aStatsModifiedIfModifiedSince.increment ();\n      }\n      // Get the If-Unmodified-Since date header\n      final long nRequestIfUnmodifiedSince = aHttpRequest.getDateHeader (CHttpHeader.IF_UNMODIFIED_SINCE);\n      if (nRequestIfUnmodifiedSince >= 0)\n      {\n        final LocalDateTime aRequestIfUnmodifiedSince = CHttp.convertMillisToLocalDateTime (nRequestIfUnmodifiedSince);\n        if (aLastModification.compareTo (aRequestIfUnmodifiedSince) >= 0)\n        {\n          if (LOGGER.isDebugEnabled ())\n            LOGGER.debug (\"Requested resource was not modified: \" + aRequestScope.getPathWithinServlet ());\n          // Was not modified since the passed time\n          m_aStatsNotModifiedIfUnmodifiedSince.increment ();\n          return EContinue.BREAK;\n        }\n        m_aStatsModifiedIfUnmodifiedSince.increment ();\n      }\n      // No If-Modified-Since request header present, set the Last-Modified\n      // header for later reuse\n      aUnifiedResponse.setLastModified (aLastModification);\n    }\n    // Handle the ETag\n    final String sSupportedETag = m_aSimpleHandler.getSupportedETag (aRequestScope);\n    if (StringHelper.hasText (sSupportedETag))\n    {\n      m_aStatsHasETag.increment ();\n      // get the request ETag\n      final String sRequestETags = aHttpRequest.getHeader (CHttpHeader.IF_NON_MATCH);\n      if (StringHelper.hasText (sRequestETags))\n      {\n        // Request header may contain several ETag values\n        final ICommonsList <String> aAllETags = RegExHelper.getSplitToList (sRequestETags, \",\\\\s+\");\n        if (aAllETags.isEmpty ())\n        {\n          if (LOGGER.isWarnEnabled ())\n            LOGGER.warn (\"Empty ETag list found (\" + sRequestETags + \")\");\n        }\n        else\n        {\n          // Scan all found ETags for match\n          for (final String sCurrentETag : aAllETags)\n            if (sSupportedETag.equals (sCurrentETag))\n            {\n              if (LOGGER.isDebugEnabled ())\n                LOGGER.debug (\"Requested resource has the same E-Tag: \" + aRequestScope.getPathWithinServlet ());\n              // We have a matching ETag\n              m_aStatsNotModifiedIfNonMatch.increment ();\n              return EContinue.BREAK;\n            }\n        }\n        m_aStatsModifiedIfNonMatch.increment ();\n      }\n      // Save the ETag for the response\n      aUnifiedResponse.setETagIfApplicable (sSupportedETag);\n    }\n    return EContinue.CONTINUE;\n  }\n  public void onRequest (@Nonnull final HttpServletRequest aHttpRequest,\n                         @Nonnull final HttpServletResponse aHttpResponse,\n                         @Nonnull final EHttpVersion eHttpVersion,\n                         @Nonnull final EHttpMethod eHttpMethod,\n                         @Nonnull final IRequestWebScope aRequestScope) throws ServletException, IOException\n  {\n    final UnifiedResponse aUnifiedResponse = m_aSimpleHandler.createUnifiedResponse (eHttpVersion,\n                                                                                     eHttpMethod,\n                                                                                     aHttpRequest,\n                                                                                     aRequestScope);\n    if (m_aSimpleHandler.initRequestState (aRequestScope, aUnifiedResponse).isBreak ())\n    {\n      if (LOGGER.isDebugEnabled ())\n        LOGGER.debug (\"Cancelled request after initRequestState with response \" + aUnifiedResponse);\n      // May e.g. be an 404 error for some not-found resource\n    }\n    else\n    {\n      // Init was successful\n      // Check for last-modification on GET and HEAD\n      boolean bExecute = true;\n      if (eHttpMethod == EHttpMethod.GET || eHttpMethod == EHttpMethod.HEAD)\n        if (_handleETag (aHttpRequest, aRequestScope, aUnifiedResponse).isBreak ())\n        {\n          // ETag present in request\n          aUnifiedResponse.setStatus (HttpServletResponse.SC_NOT_MODIFIED);\n          bExecute = false;\n        }\n      if (bExecute)\n      {\n        // On request begin\n        try\n        {\n          m_aSimpleHandler.onRequestBegin (aRequestScope);\n        }\n        catch (final Throwable t)\n        {\n          _onException (aRequestScope, aUnifiedResponse, t);\n        }\n        Throwable aCaughtException = null;\n        try\n        {\n          // main servlet handling\n          m_aSimpleHandler.handleRequest (aRequestScope, aUnifiedResponse);\n          if (LOGGER.isDebugEnabled ())\n            LOGGER.debug (\"Successfully handled request: \" + aRequestScope.getPathWithinServlet ());\n        }\n        catch (final ForcedRedirectException ex)\n        {\n          // Pass through\n          throw ex;\n        }\n        catch (final Exception ex)\n        {\n          // Invoke exception handler\n          // This internally re-throws the exception if needed\n          aCaughtException = ex;\n          _onException (aRequestScope, aUnifiedResponse, ex);\n        }\n        finally\n        {\n          // On request end\n          try\n          {\n            m_aSimpleHandler.onRequestEnd (aCaughtException);\n          }\n          catch (final Exception ex)\n          {\n            LOGGER.error (\"onRequestEnd failed\", ex);\n            // Don't throw anything here\n          }\n        }\n      }\n    }\n    aUnifiedResponse.applyToResponse (aHttpResponse);\n  }\n  @Override\n  public void onServletDestroy ()\n  {\n    // Pass-through!\n    m_aSimpleHandler.onServletDestroy ();\n  }\n"]]}
{"hexsha": "4f1fe265e4ed3313651d99528cbdac78d87fe8fa", "ext": "java", "lang": "Java", "content": "@javax.annotation.Generated(value = \"org.openapitools.codegen.languages.JavaClientCodegen\", date = \"2020-12-08T12:42:53.880-06:00[America/Chicago]\")\npublic class PackageMeasurements {\n  public static final String SERIALIZED_NAME_ATTRIBUTES = \"attributes\";\n  @SerializedName(SERIALIZED_NAME_ATTRIBUTES)\n  private Map<String, Object> attributes = null;\n\n  public static final String SERIALIZED_NAME_HEIGHT = \"height\";\n  @SerializedName(SERIALIZED_NAME_HEIGHT)\n  private Measurement height = null;\n\n  public static final String SERIALIZED_NAME_LENGTH = \"length\";\n  @SerializedName(SERIALIZED_NAME_LENGTH)\n  private Measurement length = null;\n\n  public static final String SERIALIZED_NAME_WEIGHT = \"weight\";\n  @SerializedName(SERIALIZED_NAME_WEIGHT)\n  private Measurement weight = null;\n\n  public static final String SERIALIZED_NAME_WIDTH = \"width\";\n  @SerializedName(SERIALIZED_NAME_WIDTH)\n  private Measurement width = null;\n\n  public PackageMeasurements attributes(Map<String, Object> attributes) {\n    this.attributes = attributes;\n    return this;\n  }\n\n  public PackageMeasurements putAttributesItem(String key, Object attributesItem) {\n    if (this.attributes == null) {\n      this.attributes = new HashMap<String, Object>();\n    }\n    this.attributes.put(key, attributesItem);\n    return this;\n  }\n\n   /**\n   * Get attributes\n   * @return attributes\n  **/\n  @ApiModelProperty(value = \"\")\n  public Map<String, Object> getAttributes() {\n    return attributes;\n  }\n\n  public void setAttributes(Map<String, Object> attributes) {\n    this.attributes = attributes;\n  }\n\n  public PackageMeasurements height(Measurement height) {\n    this.height = height;\n    return this;\n  }\n\n   /**\n   * Get height\n   * @return height\n  **/\n  @ApiModelProperty(value = \"\")\n  public Measurement getHeight() {\n    return height;\n  }\n\n  public void setHeight(Measurement height) {\n    this.height = height;\n  }\n\n  public PackageMeasurements length(Measurement length) {\n    this.length = length;\n    return this;\n  }\n\n   /**\n   * Get length\n   * @return length\n  **/\n  @ApiModelProperty(value = \"\")\n  public Measurement getLength() {\n    return length;\n  }\n\n  public void setLength(Measurement length) {\n    this.length = length;\n  }\n\n  public PackageMeasurements weight(Measurement weight) {\n    this.weight = weight;\n    return this;\n  }\n\n   /**\n   * Get weight\n   * @return weight\n  **/\n  @ApiModelProperty(value = \"\")\n  public Measurement getWeight() {\n    return weight;\n  }\n\n  public void setWeight(Measurement weight) {\n    this.weight = weight;\n  }\n\n  public PackageMeasurements width(Measurement width) {\n    this.width = width;\n    return this;\n  }\n\n   /**\n   * Get width\n   * @return width\n  **/\n  @ApiModelProperty(value = \"\")\n  public Measurement getWidth() {\n    return width;\n  }\n\n  public void setWidth(Measurement width) {\n    this.width = width;\n  }\n\n\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    PackageMeasurements packageMeasurements = (PackageMeasurements) o;\n    return Objects.equals(this.attributes, packageMeasurements.attributes) &&\n        Objects.equals(this.height, packageMeasurements.height) &&\n        Objects.equals(this.length, packageMeasurements.length) &&\n        Objects.equals(this.weight, packageMeasurements.weight) &&\n        Objects.equals(this.width, packageMeasurements.width);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(attributes, height, length, weight, width);\n  }\n\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class PackageMeasurements {\\n\");\n    \n    sb.append(\"    attributes: \").append(toIndentedString(attributes)).append(\"\\n\");\n    sb.append(\"    height: \").append(toIndentedString(height)).append(\"\\n\");\n    sb.append(\"    length: \").append(toIndentedString(length)).append(\"\\n\");\n    sb.append(\"    weight: \").append(toIndentedString(weight)).append(\"\\n\");\n    sb.append(\"    width: \").append(toIndentedString(width)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n\n}", "class_id": 0, "repo": "KiboSoftware/kibo.sdk.java", "file": "fulfillment-sdk/src/main/java/com/kibocommerce/sdk/fulfillment/model/PackageMeasurements.java", "last_update_at": "2019-10-02T13:15:06+00:00", "question_id": "4f1fe265e4ed3313651d99528cbdac78d87fe8fa", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@javax.annotation.Generated(value = \"org.openapitools.codegen.languages.JavaClientCodegen\", date = \"2020-12-08T12:42:53.880-06:00[America/Chicago]\")\npublic class PackageMeasurements {\n  public static final String SERIALIZED_NAME_ATTRIBUTES = \"attributes\";\n  @SerializedName(SERIALIZED_NAME_ATTRIBUTES)\n  private Map<String, Object> attributes = null;\n  public static final String SERIALIZED_NAME_HEIGHT = \"height\";\n  @SerializedName(SERIALIZED_NAME_HEIGHT)\n  private Measurement height = null;\n  public static final String SERIALIZED_NAME_LENGTH = \"length\";\n  @SerializedName(SERIALIZED_NAME_LENGTH)\n  private Measurement length = null;\n  public static final String SERIALIZED_NAME_WEIGHT = \"weight\";\n  @SerializedName(SERIALIZED_NAME_WEIGHT)\n  private Measurement weight = null;\n  public static final String SERIALIZED_NAME_WIDTH = \"width\";\n  @SerializedName(SERIALIZED_NAME_WIDTH)\n  private Measurement width = null;\n  public PackageMeasurements attributes(Map<String, Object> attributes) {\n    this.attributes = attributes;\n    return this;\n  }\n  public PackageMeasurements putAttributesItem(String key, Object attributesItem) {\n    if (this.attributes == null) {\n      this.attributes = new HashMap<String, Object>();\n    }\n    this.attributes.put(key, attributesItem);\n    return this;\n  }\n   /**\n   * Get attributes\n   * @return attributes\n  **/\n  @ApiModelProperty(value = \"\")\n  public Map<String, Object> getAttributes() {\n    return attributes;\n  }\n  public void setAttributes(Map<String, Object> attributes) {\n    this.attributes = attributes;\n  }\n  public PackageMeasurements height(Measurement height) {\n    this.height = height;\n    return this;\n  }\n   /**\n   * Get height\n   * @return height\n  **/\n  @ApiModelProperty(value = \"\")\n  public Measurement getHeight() {\n    return height;\n  }\n  public void setHeight(Measurement height) {\n    this.height = height;\n  }\n  public PackageMeasurements length(Measurement length) {\n    this.length = length;\n    return this;\n  }\n   /**\n   * Get length\n   * @return length\n  **/\n  @ApiModelProperty(value = \"\")\n  public Measurement getLength() {\n    return length;\n  }\n  public void setLength(Measurement length) {\n    this.length = length;\n  }\n  public PackageMeasurements weight(Measurement weight) {\n    this.weight = weight;\n    return this;\n  }\n   /**\n   * Get weight\n   * @return weight\n  **/\n  @ApiModelProperty(value = \"\")\n  public Measurement getWeight() {\n    return weight;\n  }\n  public void setWeight(Measurement weight) {\n    this.weight = weight;\n  }\n  public PackageMeasurements width(Measurement width) {\n    this.width = width;\n    return this;\n  }\n   /**\n   * Get width\n   * @return width\n  **/\n  @ApiModelProperty(value = \"\")\n  public Measurement getWidth() {\n    return width;\n  }\n  public void setWidth(Measurement width) {\n    this.width = width;\n  }\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    PackageMeasurements packageMeasurements = (PackageMeasurements) o;\n    return Objects.equals(this.attributes, packageMeasurements.attributes) &&\n        Objects.equals(this.height, packageMeasurements.height) &&\n        Objects.equals(this.length, packageMeasurements.length) &&\n        Objects.equals(this.weight, packageMeasurements.weight) &&\n        Objects.equals(this.width, packageMeasurements.width);\n  }\n  @Override\n  public int hashCode() {\n    return Objects.hash(attributes, height, length, weight, width);\n  }\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class PackageMeasurements {\\n\");\n    sb.append(\"    attributes: \").append(toIndentedString(attributes)).append(\"\\n\");\n    sb.append(\"    height: \").append(toIndentedString(height)).append(\"\\n\");\n    sb.append(\"    length: \").append(toIndentedString(length)).append(\"\\n\");\n    sb.append(\"    weight: \").append(toIndentedString(weight)).append(\"\\n\");\n    sb.append(\"    width: \").append(toIndentedString(width)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n"]]}
{"hexsha": "3fef80058b1052597d0be6af7ff50012a5823b98", "ext": "java", "lang": "Java", "content": "public class MatrixCheck {\n    public boolean mono(boolean[][] data) {\n        boolean result = true;\n        for (int index1 = 0, index = data.length - 1; index1 < data.length - 1; index1++, index--) {\n            if (data[0][data.length - 1] != data[index][index1] || data[0][0] != data[index][index]) {\n                result = false;\n                break;\n            }\n        }\n        return result;\n    }\n}", "class_id": 0, "repo": "Sir-Hedgehog/job4j", "file": "chapter_001/src/main/java/ru/job4j/array/MatrixCheck.java", "last_update_at": "2019-12-16T19:47:17+00:00", "question_id": "3fef80058b1052597d0be6af7ff50012a5823b98", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MatrixCheck {\n    public boolean mono(boolean[][] data) {\n        boolean result = true;\n        for (int index1 = 0, index = data.length - 1; index1 < data.length - 1; index1++, index--) {\n            if (data[0][data.length - 1] != data[index][index1] || data[0][0] != data[index][index]) {\n                result = false;\n                break;\n            }\n        }\n        return result;\n    }\n"]]}
{"hexsha": "e2519feb61e206419eb942658f459b4d28491170", "ext": "java", "lang": "Java", "content": "public class FindByHeader extends CommandState {\n\n    public FindByHeader(Tracker tracker, Input input) {\n        super(tracker, input);\n    }\n\n    @Override\n    public void execute() {\n        String header = this.input.ask(\"Enter task name for search.\");\n        this.tracker.findByHeader(header);\n        System.out.println(tracker.getMessage());\n        System.out.println(\"=========================================================\");\n    }\n\n    @Override\n    public boolean checkCommand(final String commandFlag) {\n        return commandFlag.equals(\"f -h\");\n    }\n}", "class_id": 0, "repo": "triodjangopiter/junior", "file": "chapter_002/tracker/src/main/java/ru/pravvich/start/commands/FindByHeader.java", "last_update_at": "2019-01-14T17:25:43+00:00", "question_id": "e2519feb61e206419eb942658f459b4d28491170", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FindByHeader extends CommandState {\n    public FindByHeader(Tracker tracker, Input input) {\n        super(tracker, input);\n    }\n    @Override\n    public void execute() {\n        String header = this.input.ask(\"Enter task name for search.\");\n        this.tracker.findByHeader(header);\n        System.out.println(tracker.getMessage());\n        System.out.println(\"=========================================================\");\n    }\n    @Override\n    public boolean checkCommand(final String commandFlag) {\n        return commandFlag.equals(\"f -h\");\n    }\n"]]}
{"hexsha": "e0c8377c74b7ba4b45056364cc0c53625cc79b45", "ext": "java", "lang": "Java", "content": "@objid (\"5855fce8-9795-40f8-927d-4d8fefceded3\")\r\npublic class ModelUtils {\r\n    @objid (\"08d3e755-5c18-4e5d-be2b-7d70ebcac93d\")\r\n    private static String namespacingSeparator = \"::\";\r\n\r\n    /**\r\n     * return the ModelElement target of the FIRST dependency stereotyped stereotypeName  owned by source element\r\n     * @param source : the ModelElement which is the source of the dependency\r\n     * @param stereotypeName : the stereotype name applicable on Dependency Metaclass\r\n     * @return the ModelElement target of the first dependency\r\n     */\r\n    @objid (\"50592fea-05e0-4c0c-a045-16e588becc0a\")\r\n    public static ModelElement getTarget(ModelElement source, String stereotypeName) {\r\n        for(Dependency dp: source.getDependsOnDependency()){\r\n            if(dp.isStereotyped(ICPSWarmPeerModule.MODULE_NAME,  stereotypeName)){\r\n                ModelElement element = dp.getDependsOn();\r\n                if(element != null){\r\n                    return element;\r\n                }       \r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * This method returns the list of Classifier associated (sharing an Association) to the given Association\r\n     * @param center : the central association\r\n     * @return the list of associated Association\r\n     */\r\n    @objid (\"2c78105e-5dcc-4a94-b961-c29e71a4e341\")\r\n    public static List<Classifier> getAssociatedClassifier(final Classifier center) {\r\n        List<Classifier> result = new ArrayList<Classifier>();\r\n        \r\n        for (AssociationEnd feature : center.getOwnedEnd()){\r\n            AssociationEnd opposite = feature.getOpposite();\r\n            Classifier owner = opposite.getOwner();\r\n            if (!result.contains(owner))\r\n                result.add(owner);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * This method test if the Analyst module is already deployed\r\n     * @return true if the Analyst module is deployed\r\n     */\r\n    @objid (\"e0511acc-2a34-4f62-9c84-079210755a79\")\r\n    public static boolean isRequirementDeployed() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Allows the tagged value getting\r\n     * @param tagtypeName : tagged value name\r\n     * @param element : owner element\r\n     * @return the tagged value values in a string form\r\n     */\r\n    @objid (\"8c279abb-09c3-4263-9934-d649ac41d04b\")\r\n    public static String getTaggedValue(final String tagtypeName, final ModelElement element) {\r\n        for (TaggedValue tag : element.getTag()) {\r\n            TagType type = tag.getDefinition();\r\n            String tagname = type.getName();\r\n            if (tagname.equals(tagtypeName)) {\r\n                if (!tag.getActual().isEmpty()) {\r\n                    String result = \"\";\r\n                    for (TagParameter tp: tag.getActual()) {\r\n                        if (tag.getDefinition().getParamNumber().equals(\"1\")) {\r\n        \r\n                            result = tp.getValue();\r\n                        }\r\n                        else {\r\n                            result = result + tp.getValue() + \" \";\r\n                        }\r\n                    }\r\n                    return result; \r\n                }\r\n            }\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Allows the tagged value values parsing to string tab\r\n     * @param value : the tagged value\r\n     * @return a string tab with many string values\r\n     */\r\n    @objid (\"9ee07478-e4c2-466f-8265-7f3c6428b885\")\r\n    public static String[] parseValuesToStringTab(final String value) {\r\n        ArrayList<String> dynamicList = new ArrayList<String>();\r\n        String current = \"\";\r\n        boolean hasManyElts = false;\r\n        \r\n        for (int i=0; i < value.length(); i++) {\r\n            if (value.charAt(i) != ' ') {\r\n                current = current + value.charAt(i);\r\n        \r\n                if ((i == value.length()-1) && (hasManyElts)) {\r\n                    dynamicList.add(current);\r\n                }\r\n            }\r\n        \r\n            if ((value.charAt(i) == ' ')&&(!current.equals(\"\"))) {\r\n                dynamicList.add(current);\r\n                current = \"\";\r\n                hasManyElts = true;\r\n            }\r\n            else if (current.length() == value.length()) {\r\n                dynamicList.add(current);\r\n                current = \"\";\r\n            }\r\n        }\r\n        \r\n        String[] result = dynamicList.toArray(new String[dynamicList.size()]);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Allows the tagged value adding.\r\n     * @param element : owner element\r\n     * @param tagtypeName : tagged value name\r\n     * @param value : value to add\r\n     */\r\n    @objid (\"f13232aa-0596-4eb3-b523-afcf3beacc41\")\r\n    public static void addStringValue(final ModelElement element, final String tagtypeName, final String value) {\r\n        // DON'T place Transition HERE\r\n        boolean exist = false;\r\n        List<TaggedValue> tagElements = element.getTag();\r\n        TaggedValue tvFound = null;\r\n        TagType type = null;\r\n        \r\n        // existing verification\r\n        if (!tagElements.isEmpty()) {\r\n            for (TaggedValue tag : tagElements) {\r\n        \r\n                type = tag.getDefinition();\r\n                String tagname = type.getName();\r\n        \r\n                if (tagname.equals(tagtypeName)) {\r\n                    exist = true;\r\n                    tvFound = tag;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // if the tagged value doesn't exist yet, we create this\r\n        if (!exist) {\r\n            \r\n                TaggedValue v = CPSWarmModule.getInstance().getModuleContext().getModelingSession().getModel().createTaggedValue(type, element);\r\n                if (!v.getDefinition().getParamNumber().equals(\"0\")) {\r\n                    setTaggedValue(element, tagtypeName, value);\r\n                }\r\n            \r\n        }\r\n        // if the tagged value already exists\r\n        else {\r\n            if ((tvFound!= null) && (tvFound.getDefinition().getParamNumber().equals(\"0\"))) {\r\n                tvFound.delete();\r\n            }\r\n            else {\r\n                setTaggedValue(element, tagtypeName, value);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Allows the tagged value setting\r\n     * @param elt : owner element\r\n     * @param tagtypeName : name of the tagtype\r\n     * @param value : taggeValue value\r\n     */\r\n    @objid (\"46410fc4-66cc-4915-96e8-1cd2e86aaf9f\")\r\n    public static void setTaggedValue(final ModelElement elt, final String tagtypeName, final String value) {\r\n        // if the element has tagged values\r\n        if (!elt.getTag().isEmpty()) {\r\n            // for each tagged values\r\n            for (TaggedValue tag : elt.getTag()) {\r\n                //good tagged value getting\r\n                if (tag.getDefinition().getName().equals(tagtypeName)) {\r\n                    // if the parameter number is one\r\n                    if (tag.getDefinition().getParamNumber().equals(\"1\")) {\r\n                        if(tag.getActual().size() != 0) {\r\n                            tag.getActual().get(0).setValue(value);\r\n                        }\r\n                        else {\r\n                            tag.getActual().add(CPSWarmModule.getInstance().getModuleContext().getModelingSession().getModel().createTagParameter(value, tag));\r\n                        }\r\n                    }\r\n                    //if the parameter number is multiple\r\n                    else if (tag.getDefinition().getParamNumber().equals(\"*\")) {\r\n        \r\n                        // string transformation to string tab\r\n                        String[] tabValues = parseValuesToStringTab(value);\r\n        \r\n                        // array list for the news tag parameters\r\n                        ArrayList<TagParameter> listTagParam = new ArrayList<TagParameter>();\r\n        \r\n                        // old tag parameters deleting\r\n                        for (TagParameter tp:tag.getActual()) {\r\n                            tag.getActual().remove(tp);\r\n                            tp.delete();\r\n                        }\r\n        \r\n                        // new list creating\r\n                        for (String s:tabValues) {\r\n                            listTagParam.add(CPSWarmModule.getInstance().getModuleContext().getModelingSession().getModel().createTagParameter(s+\" \", tag));\r\n                        }\r\n        \r\n                        // new tag parameters adding\r\n                        for (TagParameter tpl:listTagParam) {\r\n                            tag.getActual().add(tpl);\r\n                        }\r\n                    }\r\n                    else {\r\n                        // else, the parameter number is another number, 2, 3 4 etc.\r\n                        try {\r\n                            int nbParam = Integer.parseInt(tag.getDefinition().getParamNumber());\r\n        \r\n                            // string transformation to string tab\r\n                            String[] tabValues = parseValuesToStringTab(value);\r\n        \r\n                            /* if (tabValues.length > nbParam) {\r\n                                //JOptionPane.showMessageDialog(null,  \"You have too many parameter numbers, only \"+tag.getDefinition().getParamNumber()+\" has been set.\", \"Too many parameter numbers\", JOptionPane.ERROR_MESSAGE);\r\n                                //MessageDialog.openError(null, \"Too many parameter numbers\", \"You have too many parameter numbers, only \"+tag.getDefinition().getParamNumber()+\" has been set.\");\r\n                                //MARTEFrame.marteShowMessageDialog(null, \"Too many parameter numbers\", \"You have too many parameter numbers, only \"+tag.getDefinition().getParamNumber()+\" has been set.\", JOptionPane.ERROR_MESSAGE);\r\n                                MARTEFrame f = new MARTEFrame(\"You have to enter integers.\");\r\n                                f.show();\r\n        \r\n                            }*/\r\n                            // array list for the news tag parameters\r\n                            ArrayList<TagParameter> listTagParam = new ArrayList<TagParameter>();\r\n        \r\n                            // old tag parameters deleting\r\n                            for (TagParameter tp:tag.getActual()) {\r\n                                tag.getActual().remove(tp);\r\n                                tp.delete();\r\n                            }\r\n        \r\n                            // new list creating\r\n                            for (int i = 0; i <tabValues.length;i++) {\r\n                                if (i<nbParam) {\r\n                                    listTagParam.add(CPSWarmModule.getInstance().getModuleContext().getModelingSession().getModel().createTagParameter(tabValues[i]+\" \", tag));\r\n                                }\r\n                            }\r\n        \r\n                            // new tag parameters adding\r\n                            for (TagParameter tpl:listTagParam) {\r\n                                tag.getActual().add(tpl);\r\n                            }\r\n        \r\n                        }\r\n                        catch (Exception e) {\r\n                            JOptionPane.showMessageDialog(null, \"Internal ERROR :\\nThe parameter number is not a number.\", \"-- Internal Error --\", JOptionPane.ERROR_MESSAGE);\r\n                        }\r\n        \r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            \r\n        }\r\n    }\r\n\r\n    /**\r\n     * Allows a string tab creating. The string tab element has this form : parentName::elementName\r\n     * @param listElement : the element list\r\n     * @return a string tab\r\n     */\r\n    @objid (\"b2373f7e-c6cb-43ee-8969-354271d51ac8\")\r\n    public static String[] createListString(final List<ModelElement> listElement) {\r\n        List<String> listEltName = new ArrayList<String>();\r\n        \r\n        listEltName.add(\"\");\r\n        \r\n        for (ModelElement elt: listElement) {\r\n            listEltName.add(getCPSwarmName(elt));\r\n        }\r\n        \r\n        Collections.sort(listEltName);\r\n        String[] result = listEltName.toArray(new String[listEltName.size()]);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the \"CPSwarm\" name\r\n     * @param elt : the element\r\n     * @return String : the marte name of the element.\r\n     */\r\n    @objid (\"1bf0e048-da11-49ea-8659-d5cfa088ca39\")\r\n    public static String getCPSwarmName(final ModelElement elt) {\r\n        String result = elt.getName();\r\n        MObject owner = elt.getCompositionOwner();\r\n        if (owner instanceof ModelElement){\r\n            result = ((ModelElement) owner).getName() + namespacingSeparator + result;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * This method test if the SysML module is already deployed\r\n     * @return true if the SysML module is deployed\r\n     */\r\n    @objid (\"d14ab131-fdeb-4a7d-878b-b1e2124d3e66\")\r\n    public static boolean isSysMLDeployed() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * This method test if the MARTE module is already deployed\r\n     * @return true if the MARTE module is deployed\r\n     */\r\n    @objid (\"ae28d354-c74d-4379-9729-6fcbd287981e\")\r\n    public static boolean isMARTEDeployed() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method setTaggedValue\r\n     * @author ebrosse\r\n     * @param tvFound\r\n     * @param elt\r\n     * @param value\r\n     * @param related\r\n     * @param stereotypeLink @return\r\n     */\r\n    @objid (\"0b34c93c-76cc-42f7-97dd-3ffd903d959d\")\r\n    public static void setTaggedValue(TaggedValue tvFound, ModelElement elt, String value, ModelElement related, String modulelink, String stereotypeLink) {\r\n        IUmlModel model = CPSWarmModule.getInstance().getModuleContext().getModelingSession().getModel();\r\n        \r\n        for (Dependency existingLinks : new ArrayList<>(elt.getDependsOnDependency())) {\r\n            if (existingLinks.isStereotyped(modulelink,stereotypeLink)) {\r\n                existingLinks.delete();\r\n            }\r\n        }\r\n        \r\n        TagParameter firstElt = null;\r\n        List<TagParameter> actuals = tvFound.getActual();\r\n        if ((actuals != null) && (actuals.size() > 0)) {\r\n            firstElt = actuals.get(0);\r\n        } else {\r\n            firstElt = model.createTagParameter();\r\n            tvFound.getActual().add(firstElt);\r\n        }\r\n        \r\n        if (value.equals(\"false\")) {\r\n            tvFound.delete();\r\n        } else {\r\n            firstElt.setValue(value);\r\n            try {\r\n                model.createDependency(elt, related,modulelink, stereotypeLink);\r\n            } catch (Exception e) {\r\n                CPSWarmModule.logService.error(e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method addValue\r\n     * @author ebrosse\r\n     * @param name\r\n     * @param value\r\n     * @param element\r\n     * @param related\r\n     * @param stereotypeLink @return\r\n     */\r\n    @objid (\"2e550c8b-36ec-40ac-9c7a-c22f8e19f516\")\r\n    public static void addValue(String modulename, String name, String value, ModelElement element, ModelElement related, String modulelink, String stereotypeLink) {\r\n        // DON'T place Transition HERE\r\n        \r\n        boolean exist = false;\r\n        \r\n        TaggedValue tag = null;\r\n        List<TaggedValue> tagElements = element.getTag();\r\n        IUmlModel model = CPSWarmModule.getInstance().getModuleContext().getModelingSession().getModel();\r\n        \r\n        if (!tagElements.isEmpty()) {\r\n            for (TaggedValue currentTag : tagElements) {\r\n                TagType type = currentTag.getDefinition();\r\n                String tagname = type.getName();\r\n        \r\n                if (tagname.equals(name)) {\r\n                    exist = true;\r\n                    tag = currentTag;\r\n                    break;\r\n        \r\n                }\r\n            }\r\n        }\r\n        \r\n        if (!exist) {\r\n            try {\r\n                tag = model.createTaggedValue(modulename, name, element);\r\n        \r\n            } catch (Exception e) {\r\n                CPSWarmModule.logService.error(e);\r\n            }\r\n        \r\n        }\r\n        \r\n        setTaggedValue(tag, element, value, related,modulelink, stereotypeLink);\r\n    }\r\n\r\n    @objid (\"7f16c153-7a5c-4f68-af78-a5c5e3a7bd2b\")\r\n    public static void addValue(String modulename, String name, String values, ModelElement element) {\r\n        // DON'T place Transition HERE\r\n        boolean exist = false;\r\n        List<TaggedValue> tagElements = element.getTag();\r\n        TaggedValue tvFound = null;\r\n        \r\n        // existing verification\r\n        if (!tagElements.isEmpty()) {\r\n            for (TaggedValue tag : tagElements) {\r\n        \r\n                TagType type = tag.getDefinition();\r\n                String tagname = type.getName();\r\n        \r\n                if (tagname.equals(name)) {\r\n                    exist = true;\r\n                    // Modelio.out.println(\"tvFound FOUND\");\r\n                    tvFound = tag;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // if the tagged value doesn't exist yet, we create this\r\n        if (!exist) {\r\n            try {\r\n                // Modelio.out.println(\"tvFound does not exist\");\r\n                TaggedValue v = CPSWarmModule.getInstance().getModuleContext().getModelingSession().getModel().createTaggedValue(modulename, name, element);\r\n                element.getTag().add(v);\r\n                if (!v.getDefinition().getParamNumber().equals(\"0\")) {\r\n                    setTaggedValue(name, element, values);\r\n                }\r\n            } catch (Exception e) {\r\n                CPSWarmModule.logService.error(e);\r\n            }\r\n        }\r\n        // if the tagged value already exists\r\n        else {\r\n            if ((tvFound != null ) && (tvFound.getDefinition().getParamNumber().equals(\"0\"))) {\r\n                // Modelio.out.println(\"tvFound.getDefinition().getParamNumber().equals(0), the tv is deleted\");\r\n                tvFound.delete();\r\n            } else {\r\n                setTaggedValue(name, element, values);\r\n            }\r\n        }\r\n    }\r\n\r\n    @objid (\"f6a4fdfd-ae3a-4f78-8506-965489d7889f\")\r\n    public static void setTaggedValue(String name, ModelElement elt, String value) {\r\n        List<TaggedValue> tagElements = elt.getTag();\r\n        IUmlModel model = CPSWarmModule.getInstance().getModuleContext().getModelingSession().getModel();\r\n        \r\n        if (!tagElements.isEmpty()) {\r\n        \r\n            for (TaggedValue tag : tagElements) {\r\n                String tagname = tag.getDefinition().getName();\r\n                if (tagname.equals(name)) {\r\n        \r\n                    TagParameter firstElt = null;\r\n                    List<TagParameter> actuals = tag.getActual();\r\n                    if ((actuals != null) && (actuals.size() > 0)) {\r\n                        firstElt = actuals.get(0);\r\n                    } else {\r\n                        firstElt = model.createTagParameter();\r\n                        tag.getActual().add(firstElt);\r\n                    }\r\n        \r\n                    if (((value.equals(\"false\")) && (tag.getDefinition().getParamNumber().equals(\"0\")))\r\n                            || ((value.equals(\"\")) && (tag.getDefinition().getParamNumber().equals(\"1\")))) {\r\n                        tag.delete();\r\n                    } else {\r\n                        firstElt.setValue(value);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n}", "class_id": 0, "repo": "cpswarm/modelio-cpswarm-modeler", "file": "src/main/java/org/modelio/module/cpswarm/utils/ModelUtils.java", "last_update_at": "2019-09-16T10:29:25+00:00", "question_id": "e0c8377c74b7ba4b45056364cc0c53625cc79b45", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@objid (\"5855fce8-9795-40f8-927d-4d8fefceded3\")\r\npublic class ModelUtils {\r\n    @objid (\"08d3e755-5c18-4e5d-be2b-7d70ebcac93d\")\r\n    private static String namespacingSeparator = \"::\";\r\n\r\n    /**\r\n     * return the ModelElement target of the FIRST dependency stereotyped stereotypeName  owned by source element\r\n     * @param source : the ModelElement which is the source of the dependency\r\n     * @param stereotypeName : the stereotype name applicable on Dependency Metaclass\r\n     * @return the ModelElement target of the first dependency\r\n     */\r\n    @objid (\"50592fea-05e0-4c0c-a045-16e588becc0a\")\r\n    public static ModelElement getTarget(ModelElement source, String stereotypeName) {\r\n        for(Dependency dp: source.getDependsOnDependency()){\r\n            if(dp.isStereotyped(ICPSWarmPeerModule.MODULE_NAME,  stereotypeName)){\r\n                ModelElement element = dp.getDependsOn();\r\n                if(element != null){\r\n                    return element;\r\n                }       \r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * This method returns the list of Classifier associated (sharing an Association) to the given Association\r\n     * @param center : the central association\r\n     * @return the list of associated Association\r\n     */\r\n    @objid (\"2c78105e-5dcc-4a94-b961-c29e71a4e341\")\r\n    public static List<Classifier> getAssociatedClassifier(final Classifier center) {\r\n        List<Classifier> result = new ArrayList<Classifier>();\r\n        \r\n        for (AssociationEnd feature : center.getOwnedEnd()){\r\n            AssociationEnd opposite = feature.getOpposite();\r\n            Classifier owner = opposite.getOwner();\r\n            if (!result.contains(owner))\r\n                result.add(owner);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * This method test if the Analyst module is already deployed\r\n     * @return true if the Analyst module is deployed\r\n     */\r\n    @objid (\"e0511acc-2a34-4f62-9c84-079210755a79\")\r\n    public static boolean isRequirementDeployed() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Allows the tagged value getting\r\n     * @param tagtypeName : tagged value name\r\n     * @param element : owner element\r\n     * @return the tagged value values in a string form\r\n     */\r\n    @objid (\"8c279abb-09c3-4263-9934-d649ac41d04b\")\r\n    public static String getTaggedValue(final String tagtypeName, final ModelElement element) {\r\n        for (TaggedValue tag : element.getTag()) {\r\n            TagType type = tag.getDefinition();\r\n            String tagname = type.getName();\r\n            if (tagname.equals(tagtypeName)) {\r\n                if (!tag.getActual().isEmpty()) {\r\n                    String result = \"\";\r\n                    for (TagParameter tp: tag.getActual()) {\r\n                        if (tag.getDefinition().getParamNumber().equals(\"1\")) {\r\n        \r\n                            result = tp.getValue();\r\n                        }\r\n                        else {\r\n                            result = result + tp.getValue() + \" \";\r\n                        }\r\n                    }\r\n                    return result; \r\n                }\r\n            }\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Allows the tagged value values parsing to string tab\r\n     * @param value : the tagged value\r\n     * @return a string tab with many string values\r\n     */\r\n    @objid (\"9ee07478-e4c2-466f-8265-7f3c6428b885\")\r\n    public static String[] parseValuesToStringTab(final String value) {\r\n        ArrayList<String> dynamicList = new ArrayList<String>();\r\n        String current = \"\";\r\n        boolean hasManyElts = false;\r\n        \r\n        for (int i=0; i < value.length(); i++) {\r\n            if (value.charAt(i) != ' ') {\r\n                current = current + value.charAt(i);\r\n        \r\n                if ((i == value.length()-1) && (hasManyElts)) {\r\n                    dynamicList.add(current);\r\n                }\r\n            }\r\n        \r\n            if ((value.charAt(i) == ' ')&&(!current.equals(\"\"))) {\r\n                dynamicList.add(current);\r\n                current = \"\";\r\n                hasManyElts = true;\r\n            }\r\n            else if (current.length() == value.length()) {\r\n                dynamicList.add(current);\r\n                current = \"\";\r\n            }\r\n        }\r\n        \r\n        String[] result = dynamicList.toArray(new String[dynamicList.size()]);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Allows the tagged value adding.\r\n     * @param element : owner element\r\n     * @param tagtypeName : tagged value name\r\n     * @param value : value to add\r\n     */\r\n    @objid (\"f13232aa-0596-4eb3-b523-afcf3beacc41\")\r\n    public static void addStringValue(final ModelElement element, final String tagtypeName, final String value) {\r\n        // DON'T place Transition HERE\r\n        boolean exist = false;\r\n        List<TaggedValue> tagElements = element.getTag();\r\n        TaggedValue tvFound = null;\r\n        TagType type = null;\r\n        \r\n        // existing verification\r\n        if (!tagElements.isEmpty()) {\r\n            for (TaggedValue tag : tagElements) {\r\n        \r\n                type = tag.getDefinition();\r\n                String tagname = type.getName();\r\n        \r\n                if (tagname.equals(tagtypeName)) {\r\n                    exist = true;\r\n                    tvFound = tag;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // if the tagged value doesn't exist yet, we create this\r\n        if (!exist) {\r\n            \r\n                TaggedValue v = CPSWarmModule.getInstance().getModuleContext().getModelingSession().getModel().createTaggedValue(type, element);\r\n                if (!v.getDefinition().getParamNumber().equals(\"0\")) {\r\n                    setTaggedValue(element, tagtypeName, value);\r\n                }\r\n            \r\n        }\r\n        // if the tagged value already exists\r\n        else {\r\n            if ((tvFound!= null) && (tvFound.getDefinition().getParamNumber().equals(\"0\"))) {\r\n                tvFound.delete();\r\n            }\r\n            else {\r\n                setTaggedValue(element, tagtypeName, value);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Allows the tagged value setting\r\n     * @param elt : owner element\r\n     * @param tagtypeName : name of the tagtype\r\n     * @param value : taggeValue value\r\n     */\r\n    @objid (\"46410fc4-66cc-4915-96e8-1cd2e86aaf9f\")\r\n    public static void setTaggedValue(final ModelElement elt, final String tagtypeName, final String value) {\r\n        // if the element has tagged values\r\n        if (!elt.getTag().isEmpty()) {\r\n            // for each tagged values\r\n            for (TaggedValue tag : elt.getTag()) {\r\n                //good tagged value getting\r\n                if (tag.getDefinition().getName().equals(tagtypeName)) {\r\n                    // if the parameter number is one\r\n                    if (tag.getDefinition().getParamNumber().equals(\"1\")) {\r\n                        if(tag.getActual().size() != 0) {\r\n                            tag.getActual().get(0).setValue(value);\r\n                        }\r\n                        else {\r\n                            tag.getActual().add(CPSWarmModule.getInstance().getModuleContext().getModelingSession().getModel().createTagParameter(value, tag));\r\n                        }\r\n                    }\r\n                    //if the parameter number is multiple\r\n                    else if (tag.getDefinition().getParamNumber().equals(\"*\")) {\r\n        \r\n                        // string transformation to string tab\r\n                        String[] tabValues = parseValuesToStringTab(value);\r\n        \r\n                        // array list for the news tag parameters\r\n                        ArrayList<TagParameter> listTagParam = new ArrayList<TagParameter>();\r\n        \r\n                        // old tag parameters deleting\r\n                        for (TagParameter tp:tag.getActual()) {\r\n                            tag.getActual().remove(tp);\r\n                            tp.delete();\r\n                        }\r\n        \r\n                        // new list creating\r\n                        for (String s:tabValues) {\r\n                            listTagParam.add(CPSWarmModule.getInstance().getModuleContext().getModelingSession().getModel().createTagParameter(s+\" \", tag));\r\n                        }\r\n        \r\n                        // new tag parameters adding\r\n                        for (TagParameter tpl:listTagParam) {\r\n                            tag.getActual().add(tpl);\r\n                        }\r\n                    }\r\n                    else {\r\n                        // else, the parameter number is another number, 2, 3 4 etc.\r\n                        try {\r\n                            int nbParam = Integer.parseInt(tag.getDefinition().getParamNumber());\r\n        \r\n                            // string transformation to string tab\r\n                            String[] tabValues = parseValuesToStringTab(value);\r\n        \r\n                            /* if (tabValues.length > nbParam) {\r\n                                //JOptionPane.showMessageDialog(null,  \"You have too many parameter numbers, only \"+tag.getDefinition().getParamNumber()+\" has been set.\", \"Too many parameter numbers\", JOptionPane.ERROR_MESSAGE);\r\n                                //MessageDialog.openError(null, \"Too many parameter numbers\", \"You have too many parameter numbers, only \"+tag.getDefinition().getParamNumber()+\" has been set.\");\r\n                                //MARTEFrame.marteShowMessageDialog(null, \"Too many parameter numbers\", \"You have too many parameter numbers, only \"+tag.getDefinition().getParamNumber()+\" has been set.\", JOptionPane.ERROR_MESSAGE);\r\n                                MARTEFrame f = new MARTEFrame(\"You have to enter integers.\");\r\n                                f.show();\r\n        \r\n                            }*/\r\n                            // array list for the news tag parameters\r\n                            ArrayList<TagParameter> listTagParam = new ArrayList<TagParameter>();\r\n        \r\n                            // old tag parameters deleting\r\n                            for (TagParameter tp:tag.getActual()) {\r\n                                tag.getActual().remove(tp);\r\n                                tp.delete();\r\n                            }\r\n        \r\n                            // new list creating\r\n                            for (int i = 0; i <tabValues.length;i++) {\r\n                                if (i<nbParam) {\r\n                                    listTagParam.add(CPSWarmModule.getInstance().getModuleContext().getModelingSession().getModel().createTagParameter(tabValues[i]+\" \", tag));\r\n                                }\r\n                            }\r\n        \r\n                            // new tag parameters adding\r\n                            for (TagParameter tpl:listTagParam) {\r\n                                tag.getActual().add(tpl);\r\n                            }\r\n        \r\n                        }\r\n                        catch (Exception e) {\r\n                            JOptionPane.showMessageDialog(null, \"Internal ERROR :\\nThe parameter number is not a number.\", \"-- Internal Error --\", JOptionPane.ERROR_MESSAGE);\r\n                        }\r\n        \r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            \r\n        }\r\n    }\r\n\r\n    /**\r\n     * Allows a string tab creating. The string tab element has this form : parentName::elementName\r\n     * @param listElement : the element list\r\n     * @return a string tab\r\n     */\r\n    @objid (\"b2373f7e-c6cb-43ee-8969-354271d51ac8\")\r\n    public static String[] createListString(final List<ModelElement> listElement) {\r\n        List<String> listEltName = new ArrayList<String>();\r\n        \r\n        listEltName.add(\"\");\r\n        \r\n        for (ModelElement elt: listElement) {\r\n            listEltName.add(getCPSwarmName(elt));\r\n        }\r\n        \r\n        Collections.sort(listEltName);\r\n        String[] result = listEltName.toArray(new String[listEltName.size()]);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the \"CPSwarm\" name\r\n     * @param elt : the element\r\n     * @return String : the marte name of the element.\r\n     */\r\n    @objid (\"1bf0e048-da11-49ea-8659-d5cfa088ca39\")\r\n    public static String getCPSwarmName(final ModelElement elt) {\r\n        String result = elt.getName();\r\n        MObject owner = elt.getCompositionOwner();\r\n        if (owner instanceof ModelElement){\r\n            result = ((ModelElement) owner).getName() + namespacingSeparator + result;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * This method test if the SysML module is already deployed\r\n     * @return true if the SysML module is deployed\r\n     */\r\n    @objid (\"d14ab131-fdeb-4a7d-878b-b1e2124d3e66\")\r\n    public static boolean isSysMLDeployed() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * This method test if the MARTE module is already deployed\r\n     * @return true if the MARTE module is deployed\r\n     */\r\n    @objid (\"ae28d354-c74d-4379-9729-6fcbd287981e\")\r\n    public static boolean isMARTEDeployed() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method setTaggedValue\r\n     * @author ebrosse\r\n     * @param tvFound\r\n     * @param elt\r\n     * @param value\r\n     * @param related\r\n     * @param stereotypeLink @return\r\n     */\r\n    @objid (\"0b34c93c-76cc-42f7-97dd-3ffd903d959d\")\r\n    public static void setTaggedValue(TaggedValue tvFound, ModelElement elt, String value, ModelElement related, String modulelink, String stereotypeLink) {\r\n        IUmlModel model = CPSWarmModule.getInstance().getModuleContext().getModelingSession().getModel();\r\n        \r\n        for (Dependency existingLinks : new ArrayList<>(elt.getDependsOnDependency())) {\r\n            if (existingLinks.isStereotyped(modulelink,stereotypeLink)) {\r\n                existingLinks.delete();\r\n            }\r\n        }\r\n        \r\n        TagParameter firstElt = null;\r\n        List<TagParameter> actuals = tvFound.getActual();\r\n        if ((actuals != null) && (actuals.size() > 0)) {\r\n            firstElt = actuals.get(0);\r\n        } else {\r\n            firstElt = model.createTagParameter();\r\n            tvFound.getActual().add(firstElt);\r\n        }\r\n        \r\n        if (value.equals(\"false\")) {\r\n            tvFound.delete();\r\n        } else {\r\n            firstElt.setValue(value);\r\n            try {\r\n                model.createDependency(elt, related,modulelink, stereotypeLink);\r\n            } catch (Exception e) {\r\n                CPSWarmModule.logService.error(e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method addValue\r\n     * @author ebrosse\r\n     * @param name\r\n     * @param value\r\n     * @param element\r\n     * @param related\r\n     * @param stereotypeLink @return\r\n     */\r\n    @objid (\"2e550c8b-36ec-40ac-9c7a-c22f8e19f516\")\r\n    public static void addValue(String modulename, String name, String value, ModelElement element, ModelElement related, String modulelink, String stereotypeLink) {\r\n        // DON'T place Transition HERE\r\n        \r\n        boolean exist = false;\r\n        \r\n        TaggedValue tag = null;\r\n        List<TaggedValue> tagElements = element.getTag();\r\n        IUmlModel model = CPSWarmModule.getInstance().getModuleContext().getModelingSession().getModel();\r\n        \r\n        if (!tagElements.isEmpty()) {\r\n            for (TaggedValue currentTag : tagElements) {\r\n                TagType type = currentTag.getDefinition();\r\n                String tagname = type.getName();\r\n        \r\n                if (tagname.equals(name)) {\r\n                    exist = true;\r\n                    tag = currentTag;\r\n                    break;\r\n        \r\n                }\r\n            }\r\n        }\r\n        \r\n        if (!exist) {\r\n            try {\r\n                tag = model.createTaggedValue(modulename, name, element);\r\n        \r\n            } catch (Exception e) {\r\n                CPSWarmModule.logService.error(e);\r\n            }\r\n        \r\n        }\r\n        \r\n        setTaggedValue(tag, element, value, related,modulelink, stereotypeLink);\r\n    }\r\n\r\n    @objid (\"7f16c153-7a5c-4f68-af78-a5c5e3a7bd2b\")\r\n    public static void addValue(String modulename, String name, String values, ModelElement element) {\r\n        // DON'T place Transition HERE\r\n        boolean exist = false;\r\n        List<TaggedValue> tagElements = element.getTag();\r\n        TaggedValue tvFound = null;\r\n        \r\n        // existing verification\r\n        if (!tagElements.isEmpty()) {\r\n            for (TaggedValue tag : tagElements) {\r\n        \r\n                TagType type = tag.getDefinition();\r\n                String tagname = type.getName();\r\n        \r\n                if (tagname.equals(name)) {\r\n                    exist = true;\r\n                    // Modelio.out.println(\"tvFound FOUND\");\r\n                    tvFound = tag;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // if the tagged value doesn't exist yet, we create this\r\n        if (!exist) {\r\n            try {\r\n                // Modelio.out.println(\"tvFound does not exist\");\r\n                TaggedValue v = CPSWarmModule.getInstance().getModuleContext().getModelingSession().getModel().createTaggedValue(modulename, name, element);\r\n                element.getTag().add(v);\r\n                if (!v.getDefinition().getParamNumber().equals(\"0\")) {\r\n                    setTaggedValue(name, element, values);\r\n                }\r\n            } catch (Exception e) {\r\n                CPSWarmModule.logService.error(e);\r\n            }\r\n        }\r\n        // if the tagged value already exists\r\n        else {\r\n            if ((tvFound != null ) && (tvFound.getDefinition().getParamNumber().equals(\"0\"))) {\r\n                // Modelio.out.println(\"tvFound.getDefinition().getParamNumber().equals(0), the tv is deleted\");\r\n                tvFound.delete();\r\n            } else {\r\n                setTaggedValue(name, element, values);\r\n            }\r\n        }\r\n    }\r\n\r\n    @objid (\"f6a4fdfd-ae3a-4f78-8506-965489d7889f\")\r\n    public static void setTaggedValue(String name, ModelElement elt, String value) {\r\n        List<TaggedValue> tagElements = elt.getTag();\r\n        IUmlModel model = CPSWarmModule.getInstance().getModuleContext().getModelingSession().getModel();\r\n        \r\n        if (!tagElements.isEmpty()) {\r\n        \r\n            for (TaggedValue tag : tagElements) {\r\n                String tagname = tag.getDefinition().getName();\r\n                if (tagname.equals(name)) {\r\n        \r\n                    TagParameter firstElt = null;\r\n                    List<TagParameter> actuals = tag.getActual();\r\n                    if ((actuals != null) && (actuals.size() > 0)) {\r\n                        firstElt = actuals.get(0);\r\n                    } else {\r\n                        firstElt = model.createTagParameter();\r\n                        tag.getActual().add(firstElt);\r\n                    }\r\n        \r\n                    if (((value.equals(\"false\")) && (tag.getDefinition().getParamNumber().equals(\"0\")))\r\n                            || ((value.equals(\"\")) && (tag.getDefinition().getParamNumber().equals(\"1\")))) {\r\n                        tag.delete();\r\n                    } else {\r\n                        firstElt.setValue(value);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n"]]}
{"hexsha": "df1909ebee4db989d987fb9faad99ef2d958e871", "ext": "java", "lang": "Java", "content": "public final class zzdbg extends zzfm implements zzdbf {\n    zzdbg(IBinder iBinder) {\n        super(iBinder, \"com.google.android.gms.gass.internal.IGassService\");\n    }\n\n    /* renamed from: a */\n    public final zzdbd mo31367a(zzdbb zzdbb) throws RemoteException {\n        Parcel a = mo31749a();\n        zzfo.m30222a(a, (Parcelable) zzdbb);\n        Parcel a2 = mo31750a(1, a);\n        zzdbd zzdbd = (zzdbd) zzfo.m30220a(a2, zzdbd.CREATOR);\n        a2.recycle();\n        return zzdbd;\n    }\n\n    /* renamed from: a */\n    public final void mo31368a(zzday zzday) throws RemoteException {\n        Parcel a = mo31749a();\n        zzfo.m30222a(a, (Parcelable) zzday);\n        mo31752b(2, a);\n    }\n}", "class_id": 0, "repo": "tusharchoudhary0003/Custom-Football-Game", "file": "sources/com/google/android/gms/internal/ads/zzdbg.java", "last_update_at": "2019-10-01T11:34:10+00:00", "question_id": "df1909ebee4db989d987fb9faad99ef2d958e871", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class zzdbg extends zzfm implements zzdbf {\n    zzdbg(IBinder iBinder) {\n        super(iBinder, \"com.google.android.gms.gass.internal.IGassService\");\n    }\n    /* renamed from: a */\n    public final zzdbd mo31367a(zzdbb zzdbb) throws RemoteException {\n        Parcel a = mo31749a();\n        zzfo.m30222a(a, (Parcelable) zzdbb);\n        Parcel a2 = mo31750a(1, a);\n        zzdbd zzdbd = (zzdbd) zzfo.m30220a(a2, zzdbd.CREATOR);\n        a2.recycle();\n        return zzdbd;\n    }\n    /* renamed from: a */\n    public final void mo31368a(zzday zzday) throws RemoteException {\n        Parcel a = mo31749a();\n        zzfo.m30222a(a, (Parcelable) zzday);\n        mo31752b(2, a);\n    }\n"]]}
{"hexsha": "200123a7130a3c6ce28560064be52a809e50a64a", "ext": "java", "lang": "Java", "content": "@RunWith(AndroidJUnit4.class)\npublic class TestPerformance {\n    private static final String TAG = \"TestPerformance\";\n\n    @Test\n    public void useAppContext() {\n        // Context of the app under test.\n        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();\n\n        assertEquals(\"com.chienpm.zimagesample\", appContext.getPackageName());\n    }\n\n    @Test\n    public void crawImage(){\n        //https://api.imgur.com/3/gallery/search/viral/%7Bpage%7D?q_type=jpg&client_id=546c25a59c58ad7&q=school\n        StringBuffer response = null;\n        String keywords[] = new String[]{\"messi\", \"ronaldo\", \"neymar\", \"rooney\", \"torres\", \"kaka\", \"tom\", \"jerry\"};\n        String keywords2[] = new String[]{\"lady\", \"girl\", \"marie\", \"lan-ngoc\", \"ngoc-trinh\"};\n        String clientId = \"546c25a59c58ad7\";\n\n        JSONObject json = null;\n\n        int count = 0;\n        for(String keyword: keywords2) {\n            for (int page = 1; page < 5; page++) {\n                try {\n                    URL apiURL = new URL(\"https://api.imgur.com/3/gallery/search/viral/\" + page + \"?q_type=jpg&client_id=\" + clientId + \"&q=\" + keyword);\n                    HttpURLConnection connection = (HttpURLConnection) apiURL.openConnection();\n                    connection.setRequestMethod(\"GET\");\n                    connection.setReadTimeout(10000); //10 seconds\n\n                    int responseCode = connection.getResponseCode();\n\n                    if (responseCode == HttpURLConnection.HTTP_OK) {\n                        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                        String inputLine;\n                        response = new StringBuffer();\n\n                        // read data\n                        while ((inputLine = bufferedReader.readLine()) != null) {\n                            response.append(inputLine);\n                        }\n\n                        // process data\n                        try {\n\n                            json = new JSONObject(response.toString());\n\n                            JSONArray galleries = json.getJSONArray(\"data\");\n\n                            for (int i = 0; i < galleries.length(); ++i) {\n\n                                if (galleries.getJSONObject(i).has(\"images\")) {\n\n                                    JSONArray images = galleries.getJSONObject(i).getJSONArray(\"images\");\n\n                                    for (int j = 0; j < images.length(); ++j) {\n\n                                        JSONObject img = images.getJSONObject(j);\n                                        if (img.has(\"link\")) {\n                                            String link = img.getString(\"link\");\n                                            if (!link.contains(\".mp4\")) {\n                                                System.out.println(link);\n                                            }\n                                        }\n                                    }\n                                }\n\n                            }\n\n                        } catch (JSONException e) {\n                            e.printStackTrace();\n                            System.out.println(\"error: \" + e.getMessage());\n                            json = null;\n                        }\n\n\n                    } else {\n                        System.out.println(\"GET request not worked\");\n                    }\n\n\n                } catch (MalformedURLException e) {\n                    e.printStackTrace();\n                    response = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    response = null;\n                }\n            }\n        }\n\n        System.out.printf(json.toString());\n\n        assertNotNull(response);\n        assertTrue(response.length() > 0);\n    }\n\n    public List<String> loadImages(){\n        List<String> images = new ArrayList<>();\n\n        try {\n\n            Context testContext = InstrumentationRegistry.getInstrumentation().getContext();\n            InputStream inputStream = testContext.getAssets().open(\"images.txt\");\n\n            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n\n            String line;\n\n            while ((line = bufferedReader.readLine())!=null){\n                images.add(line);\n                System.out.println(line);\n            }\n\n        } catch (IOException e) {\n            e.printStackTrace();\n            images.clear();\n        }\n\n        assertTrue(images.size()>0);\n        return  images;\n    }\n}", "class_id": 0, "repo": "1612052/Zimage", "file": "app/src/androidTest/java/com/chienpm/zimagesample/TestPerformance.java", "last_update_at": "2019-10-23T09:44:57+00:00", "question_id": "200123a7130a3c6ce28560064be52a809e50a64a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(AndroidJUnit4.class)\npublic class TestPerformance {\n    private static final String TAG = \"TestPerformance\";\n    @Test\n    public void useAppContext() {\n        // Context of the app under test.\n        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();\n        assertEquals(\"com.chienpm.zimagesample\", appContext.getPackageName());\n    }\n    @Test\n    public void crawImage(){\n        //https://api.imgur.com/3/gallery/search/viral/%7Bpage%7D?q_type=jpg&client_id=546c25a59c58ad7&q=school\n        StringBuffer response = null;\n        String keywords[] = new String[]{\"messi\", \"ronaldo\", \"neymar\", \"rooney\", \"torres\", \"kaka\", \"tom\", \"jerry\"};\n        String keywords2[] = new String[]{\"lady\", \"girl\", \"marie\", \"lan-ngoc\", \"ngoc-trinh\"};\n        String clientId = \"546c25a59c58ad7\";\n        JSONObject json = null;\n        int count = 0;\n        for(String keyword: keywords2) {\n            for (int page = 1; page < 5; page++) {\n                try {\n                    URL apiURL = new URL(\"https://api.imgur.com/3/gallery/search/viral/\" + page + \"?q_type=jpg&client_id=\" + clientId + \"&q=\" + keyword);\n                    HttpURLConnection connection = (HttpURLConnection) apiURL.openConnection();\n                    connection.setRequestMethod(\"GET\");\n                    connection.setReadTimeout(10000); //10 seconds\n                    int responseCode = connection.getResponseCode();\n                    if (responseCode == HttpURLConnection.HTTP_OK) {\n                        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                        String inputLine;\n                        response = new StringBuffer();\n                        // read data\n                        while ((inputLine = bufferedReader.readLine()) != null) {\n                            response.append(inputLine);\n                        }\n                        // process data\n                        try {\n                            json = new JSONObject(response.toString());\n                            JSONArray galleries = json.getJSONArray(\"data\");\n                            for (int i = 0; i < galleries.length(); ++i) {\n                                if (galleries.getJSONObject(i).has(\"images\")) {\n                                    JSONArray images = galleries.getJSONObject(i).getJSONArray(\"images\");\n                                    for (int j = 0; j < images.length(); ++j) {\n                                        JSONObject img = images.getJSONObject(j);\n                                        if (img.has(\"link\")) {\n                                            String link = img.getString(\"link\");\n                                            if (!link.contains(\".mp4\")) {\n                                                System.out.println(link);\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        } catch (JSONException e) {\n                            e.printStackTrace();\n                            System.out.println(\"error: \" + e.getMessage());\n                            json = null;\n                        }\n                    } else {\n                        System.out.println(\"GET request not worked\");\n                    }\n                } catch (MalformedURLException e) {\n                    e.printStackTrace();\n                    response = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    response = null;\n                }\n            }\n        }\n        System.out.printf(json.toString());\n        assertNotNull(response);\n        assertTrue(response.length() > 0);\n    }\n    public List<String> loadImages(){\n        List<String> images = new ArrayList<>();\n        try {\n            Context testContext = InstrumentationRegistry.getInstrumentation().getContext();\n            InputStream inputStream = testContext.getAssets().open(\"images.txt\");\n            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n            String line;\n            while ((line = bufferedReader.readLine())!=null){\n                images.add(line);\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            images.clear();\n        }\n        assertTrue(images.size()>0);\n        return  images;\n    }\n"]]}
{"hexsha": "3c5afe9360c61362cb4d2b54f5faab701276b5b4", "ext": "java", "lang": "Java", "content": "@ParametersExtractor(\"markScaleValueParametersExtractor\")\npublic class MarkScaleValueParametersExtractor extends AbstractParametersExtractor<MarkScaleValue>  {\n\n\t@Resource(name = \"markScaleDao\")\n\tprivate Dao<MarkScale, MarkScale, Long> markScaleDao;\n\t\n\t@Override\n\tpublic Map<String, Object> getParameters(final MarkScaleValue entity, final Map<String, Object> parameters) {\n\t\t\n\t\taddParameter(entity.getMarkScale(), markScaleDao, \"markScale\", parameters);\n\n\t\taddParameter(entity.getStrValue(), \"strValue\", parameters);\n\t\t\n\t\treturn parameters;\n\t}\n\n}", "class_id": 0, "repo": "JLLeitschuh/ums-backend", "file": "is-lnu-service/src/main/java/org/lnu/is/extractor/mark/scale/value/MarkScaleValueParametersExtractor.java", "last_update_at": "2019-08-16T08:21:24+00:00", "question_id": "3c5afe9360c61362cb4d2b54f5faab701276b5b4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ParametersExtractor(\"markScaleValueParametersExtractor\")\npublic class MarkScaleValueParametersExtractor extends AbstractParametersExtractor<MarkScaleValue>  {\n\t@Resource(name = \"markScaleDao\")\n\tprivate Dao<MarkScale, MarkScale, Long> markScaleDao;\n\t\n\t@Override\n\tpublic Map<String, Object> getParameters(final MarkScaleValue entity, final Map<String, Object> parameters) {\n\t\t\n\t\taddParameter(entity.getMarkScale(), markScaleDao, \"markScale\", parameters);\n\t\taddParameter(entity.getStrValue(), \"strValue\", parameters);\n\t\t\n\t\treturn parameters;\n\t}\n"]]}
{"hexsha": "dd6d07a055746585e959bb38a95af3aa37b4a34d", "ext": "java", "lang": "Java", "content": "public class DataMigrator extends Thread {\n  private static final Logger LOG = LoggerFactory.getLogger(DataMigrator.class);\n\n  private final List<Integer> resolutions;\n  private final DatasetFramework datasetFramework;\n  private final String v2TableNamePrefix;\n  private final String v3TableNamePrefix;\n  private final int sleepMillisBetweenTransfer;\n  private final MetricDatasetFactory metricDatasetFactory;\n\n  private volatile boolean stopping;\n  private MetricsTableMigration metricsTableMigration;\n  /**\n   * Data migrator to run data migration for metrics tables from v2 to v3 metrics tables.\n   * @param resolutions - list of resolution tables to migrate data from\n   * @param sleepMillisBetweenTransfer while the data transfer is running -\n   *                                   amount of time to sleep between each record transfer\n   */\n  public DataMigrator(DatasetFramework datasetFramework, MetricDatasetFactory metricDatasetFactory,\n                      List<Integer> resolutions,\n                      String v2TableNamePrefix, String v3TableNamePrefix, int sleepMillisBetweenTransfer) {\n    super(\"MetricsMigratorThread\");\n    setDaemon(true);\n    this.datasetFramework = datasetFramework;\n    this.metricDatasetFactory = metricDatasetFactory;\n    this.resolutions = resolutions;\n    this.v2TableNamePrefix = v2TableNamePrefix;\n    this.v3TableNamePrefix = v3TableNamePrefix;\n    this.sleepMillisBetweenTransfer = sleepMillisBetweenTransfer;\n    stopping = false;\n    metricsTableMigration = null;\n  }\n\n  public void requestStop() {\n    stopping = true;\n    if (metricsTableMigration != null) {\n      metricsTableMigration.requestStop();\n    }\n  }\n\n  @Override\n  public void run() {\n    // iterate through resolutions, if datasetFramework has v2metricsTable then try to get V2 table with a retry\n    // once you get v2 table, get v3 table and run migration\n    // after migration is completed, we delete the v2 table for that resolution\n    // if v2 table does not exist continue to next resolution\n    // if no v2 tables exist then exit this thread - data migration is complete.\n    for (int resolution : resolutions) {\n      try {\n        DatasetId v2MetricsTableId = getMetricsDatasetId(v2TableNamePrefix, resolution);\n        DatasetId v3MetricsTableId = getMetricsDatasetId(v3TableNamePrefix, resolution);\n        if (MigrationTableHelper.hasInstanceWithRetry(datasetFramework, v2MetricsTableId)) {\n          // if v3 table is not available, call getOrCreate,\n          // this could happen when migrator thread might have started running before processing threads\n          if (!MigrationTableHelper.hasInstanceWithRetry(datasetFramework, v3MetricsTableId)) {\n            metricDatasetFactory.getOrCreateFactTable(resolution);\n          }\n          try (MetricsTable v2MetricsTable =\n                 MigrationTableHelper.getDatasetWithRetry(datasetFramework, v2MetricsTableId);\n               MetricsTable v3MetricsTable =\n                 MigrationTableHelper.getDatasetWithRetry(datasetFramework, v3MetricsTableId)) {\n            MetricsTableMigration metricsTableMigration =\n              new MetricsTableMigration(v2MetricsTableId.getDataset(), v2MetricsTable,\n                                        v3MetricsTableId.getDataset(), v3MetricsTable);\n\n            metricsTableMigration.transferData(sleepMillisBetweenTransfer);\n            LOG.info(\"Metrics table data migration is complete for {}\", v2MetricsTableId.getDataset());\n            // don't delete if we are stopping\n            if (stopping) {\n              break;\n            }\n            // now transfer is complete; its safe to delete the v2 metrics table\n            MigrationTableHelper.deleteInstanceWithRetry(datasetFramework, v2MetricsTableId);\n            LOG.info(\"Deleted Metrics table {}\", v2MetricsTableId.getDataset());\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            break;\n          }\n        }\n      } catch (Exception e) {\n        LOG.error(\"Exception while performing dataset operation during metrics table migration\", e);\n        return;\n      }\n    }\n  }\n\n  private DatasetId getMetricsDatasetId(String tableNamePrefix, int resolution) {\n    String tableName =  tableNamePrefix + resolution;\n    return NamespaceId.SYSTEM.dataset(tableName);\n  }\n}", "class_id": 0, "repo": "pa-mahe/cdap", "file": "cdap-watchdog/src/main/java/co/cask/cdap/metrics/process/DataMigrator.java", "last_update_at": "2019-10-14T10:03:40+00:00", "question_id": "dd6d07a055746585e959bb38a95af3aa37b4a34d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DataMigrator extends Thread {\n  private static final Logger LOG = LoggerFactory.getLogger(DataMigrator.class);\n  private final List<Integer> resolutions;\n  private final DatasetFramework datasetFramework;\n  private final String v2TableNamePrefix;\n  private final String v3TableNamePrefix;\n  private final int sleepMillisBetweenTransfer;\n  private final MetricDatasetFactory metricDatasetFactory;\n  private volatile boolean stopping;\n  private MetricsTableMigration metricsTableMigration;\n  /**\n   * Data migrator to run data migration for metrics tables from v2 to v3 metrics tables.\n   * @param resolutions - list of resolution tables to migrate data from\n   * @param sleepMillisBetweenTransfer while the data transfer is running -\n   *                                   amount of time to sleep between each record transfer\n   */\n  public DataMigrator(DatasetFramework datasetFramework, MetricDatasetFactory metricDatasetFactory,\n                      List<Integer> resolutions,\n                      String v2TableNamePrefix, String v3TableNamePrefix, int sleepMillisBetweenTransfer) {\n    super(\"MetricsMigratorThread\");\n    setDaemon(true);\n    this.datasetFramework = datasetFramework;\n    this.metricDatasetFactory = metricDatasetFactory;\n    this.resolutions = resolutions;\n    this.v2TableNamePrefix = v2TableNamePrefix;\n    this.v3TableNamePrefix = v3TableNamePrefix;\n    this.sleepMillisBetweenTransfer = sleepMillisBetweenTransfer;\n    stopping = false;\n    metricsTableMigration = null;\n  }\n  public void requestStop() {\n    stopping = true;\n    if (metricsTableMigration != null) {\n      metricsTableMigration.requestStop();\n    }\n  }\n  @Override\n  public void run() {\n    // iterate through resolutions, if datasetFramework has v2metricsTable then try to get V2 table with a retry\n    // once you get v2 table, get v3 table and run migration\n    // after migration is completed, we delete the v2 table for that resolution\n    // if v2 table does not exist continue to next resolution\n    // if no v2 tables exist then exit this thread - data migration is complete.\n    for (int resolution : resolutions) {\n      try {\n        DatasetId v2MetricsTableId = getMetricsDatasetId(v2TableNamePrefix, resolution);\n        DatasetId v3MetricsTableId = getMetricsDatasetId(v3TableNamePrefix, resolution);\n        if (MigrationTableHelper.hasInstanceWithRetry(datasetFramework, v2MetricsTableId)) {\n          // if v3 table is not available, call getOrCreate,\n          // this could happen when migrator thread might have started running before processing threads\n          if (!MigrationTableHelper.hasInstanceWithRetry(datasetFramework, v3MetricsTableId)) {\n            metricDatasetFactory.getOrCreateFactTable(resolution);\n          }\n          try (MetricsTable v2MetricsTable =\n                 MigrationTableHelper.getDatasetWithRetry(datasetFramework, v2MetricsTableId);\n               MetricsTable v3MetricsTable =\n                 MigrationTableHelper.getDatasetWithRetry(datasetFramework, v3MetricsTableId)) {\n            MetricsTableMigration metricsTableMigration =\n              new MetricsTableMigration(v2MetricsTableId.getDataset(), v2MetricsTable,\n                                        v3MetricsTableId.getDataset(), v3MetricsTable);\n            metricsTableMigration.transferData(sleepMillisBetweenTransfer);\n            LOG.info(\"Metrics table data migration is complete for {}\", v2MetricsTableId.getDataset());\n            // don't delete if we are stopping\n            if (stopping) {\n              break;\n            }\n            // now transfer is complete; its safe to delete the v2 metrics table\n            MigrationTableHelper.deleteInstanceWithRetry(datasetFramework, v2MetricsTableId);\n            LOG.info(\"Deleted Metrics table {}\", v2MetricsTableId.getDataset());\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            break;\n          }\n        }\n      } catch (Exception e) {\n        LOG.error(\"Exception while performing dataset operation during metrics table migration\", e);\n        return;\n      }\n    }\n  }\n  private DatasetId getMetricsDatasetId(String tableNamePrefix, int resolution) {\n    String tableName =  tableNamePrefix + resolution;\n    return NamespaceId.SYSTEM.dataset(tableName);\n  }\n"]]}
{"hexsha": "8b3b372e754c24f330a50b51e3f29c68b563e0e6", "ext": "java", "lang": "Java", "content": "@SuppressWarnings(\"restriction\")\npublic class GenericResolveContextResolveTest extends TestCase {\n\n\tprivate static final LogService\tlog\t= new NullLogService();\n\n\tpublic static void testSimpleResolve() {\n\n\t\tRepository repository = createRepo(IO.getFile(\"testdata/repo3.index.xml\"));\n\t\tGenericResolveContext grc = new GenericResolveContext(log);\n\t\tResource framework = grc.getFrameworkResource(Arrays.asList(repository), \"org.apache.felix.framework\", null);\n\n\t\tList<Requirement> systemRequirements = new ArrayList<Requirement>();\n\t\tList<Capability> systemCapabilities = new ArrayList<Capability>();\n\n\t\tsystemRequirements.addAll(framework.getRequirements(null));\n\t\tsystemCapabilities.addAll(framework.getCapabilities(null));\n\n\t\tsystemCapabilities.addAll(GenericResolveContext.getEECapabilities(EE.JavaSE_1_7));\n\n\t\tGenericResolveContext context = new GenericResolveContext(systemCapabilities, systemRequirements, log);\n\n\t\tcontext.addRepository(repository);\n\n\t\tRequirement requirement = GenericResolveContext.createBundleRequirement(\"org.apache.felix.gogo.shell\", \"[0,1)\");\n\t\tcontext.addInputRequirement(GenericResolveContext.createBundleRequirement(\"org.apache.felix.gogo.shell\", \"[0,1)\"));\n\n\t\tResolver resolver = new BndResolver(new ResolverLogger(4));\n\n\t\ttry {\n\t\t\tMap<Resource,List<Wire>> resolved = resolver.resolve(context);\n\t\t\tSet<Resource> resources = resolved.keySet();\n\t\t\tResource resource = getResource(resources, \"org.apache.felix.gogo.runtime\", \"0.10\");\n\t\t\tassertNotNull(resource);\n\t\t}\n\t\tcatch (ResolutionException e) {\n\t\t\tfail(\"Resolve failed\");\n\t\t}\n\t}\n\n\tpublic static void testResolveRequirementNoDirective() {\n\n\t\tRepository repository = createRepo(IO.getFile(\"testdata/repo6/index.xml\"));\n\t\tGenericResolveContext grc = new GenericResolveContext(log);\n\n\t\tGenericResolveContext context = new GenericResolveContext(Collections.<Capability> emptyList(),\n\t\t\t\tCollections.<Requirement> emptyList(), log);\n\n\t\tcontext.addRepository(repository);\n\n\t\tList<Capability> providers = context.findProviders(new CapReqBuilder(\"osgi.service\").addDirective(\"filter\",\n\t\t\t\t\"(objectClass=org.osgi.service.log.LogService)\").buildSyntheticRequirement());\n\n\t\tassertEquals(2, providers.size());\n\n\t\tSet<String> resourceNames = new HashSet<String>();\n\t\tfor(Capability cap : providers) {\n\t\t\tresourceNames.add(cap.getResource().getCapabilities(IdentityNamespace.IDENTITY_NAMESPACE)\n\t\t\t\t\t.get(0).getAttributes().get(IdentityNamespace.IDENTITY_NAMESPACE).toString());\n\t\t}\n\t\t\n\t\tSet<String> expectedResourceNames = new HashSet<String>(Arrays.asList(\"test.a\", \"test.b\"));\n\t\t\n\t\tassertEquals(expectedResourceNames, resourceNames);\n\t}\n\n\tpublic static void testResolveRequirementResolveDirective() {\n\n\t\tRepository repository = createRepo(IO.getFile(\"testdata/repo6/index.xml\"));\n\t\tGenericResolveContext grc = new GenericResolveContext(log);\n\n\t\tGenericResolveContext context = new GenericResolveContext(Collections.<Capability> emptyList(),\n\t\t\t\tCollections.<Requirement> emptyList(), log);\n\n\t\tcontext.addRepository(repository);\n\n\t\tList<Capability> providers = context.findProviders(new CapReqBuilder(\"osgi.service\")\n\t\t\t\t.addDirective(\"filter\", \"(objectClass=org.osgi.service.log.LogService)\")\n\t\t\t\t.addDirective(\"effective\", \"resolve\").buildSyntheticRequirement());\n\n\t\tassertEquals(2, providers.size());\n\n\t\tSet<String> resourceNames = new HashSet<String>();\n\t\tfor (Capability cap : providers) {\n\t\t\tresourceNames.add(cap.getResource().getCapabilities(IdentityNamespace.IDENTITY_NAMESPACE).get(0)\n\t\t\t\t\t.getAttributes().get(IdentityNamespace.IDENTITY_NAMESPACE).toString());\n\t\t}\n\n\t\tSet<String> expectedResourceNames = new HashSet<String>(Arrays.asList(\"test.a\", \"test.b\"));\n\n\t\tassertEquals(expectedResourceNames, resourceNames);\n\t}\n\n\tpublic static void testResolveRequirementActiveDirective() {\n\n\t\tRepository repository = createRepo(IO.getFile(\"testdata/repo6/index.xml\"));\n\t\tGenericResolveContext grc = new GenericResolveContext(log);\n\n\t\tGenericResolveContext context = new GenericResolveContext(Collections.<Capability> emptyList(),\n\t\t\t\tCollections.<Requirement> emptyList(), log);\n\n\t\tcontext.addRepository(repository);\n\n\t\tList<Capability> providers = context.findProviders(new CapReqBuilder(\"osgi.service\")\n\t\t\t\t.addDirective(\"filter\", \"(objectClass=org.osgi.service.log.LogService)\")\n\t\t\t\t.addDirective(\"effective\", \"active\").buildSyntheticRequirement());\n\n\t\tassertEquals(3, providers.size());\n\n\t\tSet<String> resourceNames = new HashSet<String>();\n\t\tfor (Capability cap : providers) {\n\t\t\tresourceNames.add(cap.getResource().getCapabilities(IdentityNamespace.IDENTITY_NAMESPACE).get(0)\n\t\t\t\t\t.getAttributes().get(IdentityNamespace.IDENTITY_NAMESPACE).toString());\n\t\t}\n\n\t\tSet<String> expectedResourceNames = new HashSet<String>(Arrays.asList(\"test.a\", \"test.b\", \"test.c\"));\n\n\t\tassertEquals(expectedResourceNames, resourceNames);\n\t}\n\n\tprivate static Resource getResource(Set<Resource> resources, String bsn, String versionString) {\n\t\tfor (Resource resource : resources) {\n\t\t\tList<Capability> identities = resource.getCapabilities(IdentityNamespace.IDENTITY_NAMESPACE);\n\t\t\tif (identities != null && identities.size() == 1) {\n\t\t\t\tCapability idCap = identities.get(0);\n\t\t\t\tObject id = idCap.getAttributes().get(IdentityNamespace.IDENTITY_NAMESPACE);\n\t\t\t\tObject version = idCap.getAttributes().get(IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE);\n\t\t\t\tif (bsn.equals(id)) {\n\t\t\t\t\tif (versionString == null) {\n\t\t\t\t\t\treturn resource;\n\t\t\t\t\t}\n\t\t\t\t\tVersion requested = Version.parseVersion(versionString);\n\t\t\t\t\tVersion current;\n\t\t\t\t\tif (version instanceof Version) {\n\t\t\t\t\t\tcurrent = (Version) version;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrent = Version.parseVersion((String) version);\n\t\t\t\t\t}\n\t\t\t\t\tif (requested.equals(current)) {\n\t\t\t\t\t\treturn resource;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n}", "class_id": 0, "repo": "marcdejonge/bnd", "file": "biz.aQute.resolve/test/biz/aQute/resolve/internal/GenericResolveContextResolveTest.java", "last_update_at": "2019-02-22T02:39:19+00:00", "question_id": "8b3b372e754c24f330a50b51e3f29c68b563e0e6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings(\"restriction\")\npublic class GenericResolveContextResolveTest extends TestCase {\n\tprivate static final LogService\tlog\t= new NullLogService();\n\tpublic static void testSimpleResolve() {\n\t\tRepository repository = createRepo(IO.getFile(\"testdata/repo3.index.xml\"));\n\t\tGenericResolveContext grc = new GenericResolveContext(log);\n\t\tResource framework = grc.getFrameworkResource(Arrays.asList(repository), \"org.apache.felix.framework\", null);\n\t\tList<Requirement> systemRequirements = new ArrayList<Requirement>();\n\t\tList<Capability> systemCapabilities = new ArrayList<Capability>();\n\t\tsystemRequirements.addAll(framework.getRequirements(null));\n\t\tsystemCapabilities.addAll(framework.getCapabilities(null));\n\t\tsystemCapabilities.addAll(GenericResolveContext.getEECapabilities(EE.JavaSE_1_7));\n\t\tGenericResolveContext context = new GenericResolveContext(systemCapabilities, systemRequirements, log);\n\t\tcontext.addRepository(repository);\n\t\tRequirement requirement = GenericResolveContext.createBundleRequirement(\"org.apache.felix.gogo.shell\", \"[0,1)\");\n\t\tcontext.addInputRequirement(GenericResolveContext.createBundleRequirement(\"org.apache.felix.gogo.shell\", \"[0,1)\"));\n\t\tResolver resolver = new BndResolver(new ResolverLogger(4));\n\t\ttry {\n\t\t\tMap<Resource,List<Wire>> resolved = resolver.resolve(context);\n\t\t\tSet<Resource> resources = resolved.keySet();\n\t\t\tResource resource = getResource(resources, \"org.apache.felix.gogo.runtime\", \"0.10\");\n\t\t\tassertNotNull(resource);\n\t\t}\n\t\tcatch (ResolutionException e) {\n\t\t\tfail(\"Resolve failed\");\n\t\t}\n\t}\n\tpublic static void testResolveRequirementNoDirective() {\n\t\tRepository repository = createRepo(IO.getFile(\"testdata/repo6/index.xml\"));\n\t\tGenericResolveContext grc = new GenericResolveContext(log);\n\t\tGenericResolveContext context = new GenericResolveContext(Collections.<Capability> emptyList(),\n\t\t\t\tCollections.<Requirement> emptyList(), log);\n\t\tcontext.addRepository(repository);\n\t\tList<Capability> providers = context.findProviders(new CapReqBuilder(\"osgi.service\").addDirective(\"filter\",\n\t\t\t\t\"(objectClass=org.osgi.service.log.LogService)\").buildSyntheticRequirement());\n\t\tassertEquals(2, providers.size());\n\t\tSet<String> resourceNames = new HashSet<String>();\n\t\tfor(Capability cap : providers) {\n\t\t\tresourceNames.add(cap.getResource().getCapabilities(IdentityNamespace.IDENTITY_NAMESPACE)\n\t\t\t\t\t.get(0).getAttributes().get(IdentityNamespace.IDENTITY_NAMESPACE).toString());\n\t\t}\n\t\t\n\t\tSet<String> expectedResourceNames = new HashSet<String>(Arrays.asList(\"test.a\", \"test.b\"));\n\t\t\n\t\tassertEquals(expectedResourceNames, resourceNames);\n\t}\n\tpublic static void testResolveRequirementResolveDirective() {\n\t\tRepository repository = createRepo(IO.getFile(\"testdata/repo6/index.xml\"));\n\t\tGenericResolveContext grc = new GenericResolveContext(log);\n\t\tGenericResolveContext context = new GenericResolveContext(Collections.<Capability> emptyList(),\n\t\t\t\tCollections.<Requirement> emptyList(), log);\n\t\tcontext.addRepository(repository);\n\t\tList<Capability> providers = context.findProviders(new CapReqBuilder(\"osgi.service\")\n\t\t\t\t.addDirective(\"filter\", \"(objectClass=org.osgi.service.log.LogService)\")\n\t\t\t\t.addDirective(\"effective\", \"resolve\").buildSyntheticRequirement());\n\t\tassertEquals(2, providers.size());\n\t\tSet<String> resourceNames = new HashSet<String>();\n\t\tfor (Capability cap : providers) {\n\t\t\tresourceNames.add(cap.getResource().getCapabilities(IdentityNamespace.IDENTITY_NAMESPACE).get(0)\n\t\t\t\t\t.getAttributes().get(IdentityNamespace.IDENTITY_NAMESPACE).toString());\n\t\t}\n\t\tSet<String> expectedResourceNames = new HashSet<String>(Arrays.asList(\"test.a\", \"test.b\"));\n\t\tassertEquals(expectedResourceNames, resourceNames);\n\t}\n\tpublic static void testResolveRequirementActiveDirective() {\n\t\tRepository repository = createRepo(IO.getFile(\"testdata/repo6/index.xml\"));\n\t\tGenericResolveContext grc = new GenericResolveContext(log);\n\t\tGenericResolveContext context = new GenericResolveContext(Collections.<Capability> emptyList(),\n\t\t\t\tCollections.<Requirement> emptyList(), log);\n\t\tcontext.addRepository(repository);\n\t\tList<Capability> providers = context.findProviders(new CapReqBuilder(\"osgi.service\")\n\t\t\t\t.addDirective(\"filter\", \"(objectClass=org.osgi.service.log.LogService)\")\n\t\t\t\t.addDirective(\"effective\", \"active\").buildSyntheticRequirement());\n\t\tassertEquals(3, providers.size());\n\t\tSet<String> resourceNames = new HashSet<String>();\n\t\tfor (Capability cap : providers) {\n\t\t\tresourceNames.add(cap.getResource().getCapabilities(IdentityNamespace.IDENTITY_NAMESPACE).get(0)\n\t\t\t\t\t.getAttributes().get(IdentityNamespace.IDENTITY_NAMESPACE).toString());\n\t\t}\n\t\tSet<String> expectedResourceNames = new HashSet<String>(Arrays.asList(\"test.a\", \"test.b\", \"test.c\"));\n\t\tassertEquals(expectedResourceNames, resourceNames);\n\t}\n\tprivate static Resource getResource(Set<Resource> resources, String bsn, String versionString) {\n\t\tfor (Resource resource : resources) {\n\t\t\tList<Capability> identities = resource.getCapabilities(IdentityNamespace.IDENTITY_NAMESPACE);\n\t\t\tif (identities != null && identities.size() == 1) {\n\t\t\t\tCapability idCap = identities.get(0);\n\t\t\t\tObject id = idCap.getAttributes().get(IdentityNamespace.IDENTITY_NAMESPACE);\n\t\t\t\tObject version = idCap.getAttributes().get(IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE);\n\t\t\t\tif (bsn.equals(id)) {\n\t\t\t\t\tif (versionString == null) {\n\t\t\t\t\t\treturn resource;\n\t\t\t\t\t}\n\t\t\t\t\tVersion requested = Version.parseVersion(versionString);\n\t\t\t\t\tVersion current;\n\t\t\t\t\tif (version instanceof Version) {\n\t\t\t\t\t\tcurrent = (Version) version;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrent = Version.parseVersion((String) version);\n\t\t\t\t\t}\n\t\t\t\t\tif (requested.equals(current)) {\n\t\t\t\t\t\treturn resource;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n"]]}
{"hexsha": "ef71506d0ec030e2b2bc29d0db1cb82e7ad57c0a", "ext": "java", "lang": "Java", "content": "public class GT_TileEntity_CircuitAssemblyLine extends GT_MetaTileEntity_MultiBlockBase {\n\n    public String getTypeForDisplay() {\n        if (this.type.equals(new NBTTagCompound()))\n            return \"\";\n        return GT_LanguageManager.getTranslation(GT_LanguageManager.getTranslateableItemStackName(CircuitImprintLoader.getStackFromTag(this.type)));\n    }\n\n    private NBTTagCompound type = new NBTTagCompound();\n    private GT_Recipe bufferedRecipe;\n\n    public GT_TileEntity_CircuitAssemblyLine(int aID, String aName, String aNameRegional) {\n        super(aID, aName, aNameRegional);\n    }\n\n    public GT_TileEntity_CircuitAssemblyLine(String aName) {\n        super(aName);\n    }\n\n    private boolean imprintMachine(ItemStack itemStack){\n        if (!this.type.equals(new NBTTagCompound()))\n            return true;\n        if (!GT_Utility.isStackValid(itemStack))\n            return false;\n        if (itemStack.getItem() instanceof BW_Meta_Items.BW_GT_MetaGenCircuits && itemStack.getItemDamage() == 0 && itemStack.getTagCompound() != null && this.type.equals(new NBTTagCompound())){\n            this.type = itemStack.getTagCompound();\n            this.mInventory[1] = null;\n            this.getBaseMetaTileEntity().issueBlockUpdate();\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean isCorrectMachinePart(ItemStack itemStack) {\n        return true;\n    }\n\n    @Override\n    public void startSoundLoop(byte aIndex, double aX, double aY, double aZ) {\n        super.startSoundLoop(aIndex, aX, aY, aZ);\n        if (aIndex == 20) {\n            GT_Utility.doSoundAtClient(GregTech_API.sSoundList.get(212), 10, 1.0F, aX, aY, aZ);\n        }\n    }\n\n    @Override\n    public void loadNBTData(NBTTagCompound aNBT) {\n        this.type = aNBT.getCompoundTag(\"Type\");\n        super.loadNBTData(aNBT);\n    }\n\n    @Override\n    public void saveNBTData(NBTTagCompound aNBT) {\n        if (!this.type.equals(new NBTTagCompound()))\n            aNBT.setTag(\"Type\", this.type);\n        super.saveNBTData(aNBT);\n\n    }\n\n    private final Collection<GT_Recipe> GT_RECIPE_COLLECTION = new HashSet<>();\n\n    @Override\n    public boolean checkRecipe(ItemStack itemStack) {\n        if (this.type.equals(new NBTTagCompound()))\n            if (!this.imprintMachine(itemStack))\n                return false;\n\n        if (this.bufferedRecipe != null && this.bufferedRecipe.isRecipeInputEqual(true,false, BW_Util.getFluidsFromInputHatches(this), BW_Util.getItemsFromInputBusses(this))) {\n            BW_Util.calculateOverclockedNessMulti(this.bufferedRecipe.mEUt,this.bufferedRecipe.mDuration,1,this.getMaxInputVoltage(),this);\n            this.mMaxProgresstime = Math.max(1, this.mMaxProgresstime);\n            this.mOutputItems = this.bufferedRecipe.mOutputs;\n            this.mOutputFluids = this.bufferedRecipe.mFluidOutputs;\n            this.updateSlots();\n            return true;\n        }\n\n        ItemStack stack = ItemStack.loadItemStackFromNBT(this.type);\n\n        if (stack == null)\n            return false;\n\n        if (this.GT_RECIPE_COLLECTION.isEmpty()) {\n            for (GT_Recipe recipe : BWRecipes.instance.getMappingsFor((byte) 3).mRecipeList) {\n                if (GT_Utility.areStacksEqual(recipe.mOutputs[0], stack, true)) {\n                    this.GT_RECIPE_COLLECTION.add(recipe);\n                }\n            }\n        }\n\n        for (GT_Recipe recipe : this.GT_RECIPE_COLLECTION) {\n            if (recipe.isRecipeInputEqual(true,false, BW_Util.getFluidsFromInputHatches(this), BW_Util.getItemsFromInputBusses(this)))\n                this.bufferedRecipe = recipe;\n            else\n                continue;\n\n            BW_Util.calculateOverclockedNessMulti(this.bufferedRecipe.mEUt,this.bufferedRecipe.mDuration,1,this.getMaxInputVoltage(),this);\n            this.mMaxProgresstime = Math.max(1, this.mMaxProgresstime);\n            this.mOutputItems = this.bufferedRecipe.mOutputs;\n            this.mOutputFluids = this.bufferedRecipe.mFluidOutputs;\n            this.updateSlots();\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean checkMachine(IGregTechTileEntity aBaseMetaTileEntity, ItemStack aStack) {\n        int xDir = ForgeDirection.getOrientation(aBaseMetaTileEntity.getBackFacing()).offsetX;\n        int zDir = ForgeDirection.getOrientation(aBaseMetaTileEntity.getBackFacing()).offsetZ;\n        int r;\n        int i;\n        IGregTechTileEntity tTileEntity;\n        if (xDir != 0) {\n            for(r = 0; r <= 7; ++r) {\n                i = r * xDir;\n\n                tTileEntity = aBaseMetaTileEntity.getIGregTechTileEntityOffset(xDir, 0, i);\n                if (!this.addEnergyInputToMachineList(tTileEntity, 16))\n                    if ((aBaseMetaTileEntity.getBlockOffset(0, 0, i) != GregTech_API.sBlockCasings3 || aBaseMetaTileEntity.getMetaIDOffset(0, 0, i) != 10) && r == 1)\n                        return false;\n                if (!aBaseMetaTileEntity.getBlockOffset(0, -1, i).getUnlocalizedName().equals(\"blockAlloyGlass\"))\n                    return false;\n\n                tTileEntity = aBaseMetaTileEntity.getIGregTechTileEntityOffset(0, -2, i);\n                if (!this.addMaintenanceToMachineList(tTileEntity, 16) && !this.addInputToMachineList(tTileEntity, 16))\n                    if (aBaseMetaTileEntity.getBlockOffset(0, -2, i) != GregTech_API.sBlockCasings2 || aBaseMetaTileEntity.getMetaIDOffset(0, -2, i) != 0)\n                        return false;\n\n                if (i != 0 && (aBaseMetaTileEntity.getBlockOffset(xDir, -1, i) != GregTech_API.sBlockCasings2 || aBaseMetaTileEntity.getMetaIDOffset(xDir, -1, i) != 5))\n                    return false;\n\n                if (!aBaseMetaTileEntity.getBlockOffset(xDir * 2, -1, i).getUnlocalizedName().equals(\"blockAlloyGlass\"))\n                    return false;\n\n                tTileEntity = aBaseMetaTileEntity.getIGregTechTileEntityOffset(xDir * 2, -2, i);\n                if (!this.addMaintenanceToMachineList(tTileEntity, 16) && !this.addInputToMachineList(tTileEntity, 16))\n                    if (aBaseMetaTileEntity.getBlockOffset(xDir * 2, -2, i) != GregTech_API.sBlockCasings2 || aBaseMetaTileEntity.getMetaIDOffset(xDir * 2, -2, i) != 0)\n                        return false;\n\n                tTileEntity = aBaseMetaTileEntity.getIGregTechTileEntityOffset(xDir, -2, i);\n                if (!this.addInputToMachineList(tTileEntity, 16) && this.addOutputToMachineList(tTileEntity, 16))\n                    return r > 0 && this.mEnergyHatches.size() > 0;\n\n            }\n        } else {\n\n            for(r = 0; r <= 7; ++r) {\n                i = r * -zDir;\n\n                //top with grate and energy hatch\n                tTileEntity = aBaseMetaTileEntity.getIGregTechTileEntityOffset(i, 0, zDir);\n                if (!this.addEnergyInputToMachineList(tTileEntity, 16))\n                    if ((aBaseMetaTileEntity.getBlockOffset(i, 0, 0) != GregTech_API.sBlockCasings3 || aBaseMetaTileEntity.getMetaIDOffset(i, 0, 0) != 10) && r == 1)\n                        return false;\n\n                if (!aBaseMetaTileEntity.getBlockOffset(i, -1, 0).getUnlocalizedName().equals(\"blockAlloyGlass\"))\n                    return false;\n\n                tTileEntity = aBaseMetaTileEntity.getIGregTechTileEntityOffset(i, -2, 0);\n                if (!this.addMaintenanceToMachineList(tTileEntity, 16) && !this.addInputToMachineList(tTileEntity, 16))\n                    if (aBaseMetaTileEntity.getBlockOffset(i, -2, 0) != GregTech_API.sBlockCasings2 || aBaseMetaTileEntity.getMetaIDOffset(i, -2, 0) != 0)\n                        return false;\n\n                if (i != 0 && (aBaseMetaTileEntity.getBlockOffset(i, -1, zDir) != GregTech_API.sBlockCasings2 || aBaseMetaTileEntity.getMetaIDOffset(i, -1, zDir) != 5))\n                    return false;\n\n                if (!aBaseMetaTileEntity.getBlockOffset(i, -1, zDir * 2).getUnlocalizedName().equals(\"blockAlloyGlass\"))\n                    return false;\n\n\n                tTileEntity = aBaseMetaTileEntity.getIGregTechTileEntityOffset(i, -2, zDir * 2);\n                if (!this.addMaintenanceToMachineList(tTileEntity, 16) && !this.addInputToMachineList(tTileEntity, 16))\n                    if (aBaseMetaTileEntity.getBlockOffset(i, -2, zDir * 2) != GregTech_API.sBlockCasings2 || aBaseMetaTileEntity.getMetaIDOffset(i, -2, zDir * 2) != 0)\n                        return false;\n\n                tTileEntity = aBaseMetaTileEntity.getIGregTechTileEntityOffset(i, -2, zDir);\n                if (!this.addInputToMachineList(tTileEntity, 16) && this.addOutputToMachineList(tTileEntity, 16))\n                    return r > 0 && this.mEnergyHatches.size() == 1;\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean addInputToMachineList(IGregTechTileEntity aTileEntity, int aBaseCasingIndex) {\n        if (aTileEntity == null) {\n            return false;\n        } else {\n            IMetaTileEntity aMetaTileEntity = aTileEntity.getMetaTileEntity();\n            if (aMetaTileEntity instanceof GT_MetaTileEntity_Hatch_Input) {\n                ((GT_MetaTileEntity_Hatch)aMetaTileEntity).updateTexture(aBaseCasingIndex);\n                ((GT_MetaTileEntity_Hatch_Input)aMetaTileEntity).mRecipeMap = this.getRecipeMap();\n                return this.mInputHatches.add((GT_MetaTileEntity_Hatch_Input)aMetaTileEntity);\n            } else if (aMetaTileEntity instanceof GT_MetaTileEntity_Hatch_InputBus && ((GT_MetaTileEntity_Hatch_InputBus) aMetaTileEntity).mTier == 0) {\n                ((GT_MetaTileEntity_Hatch)aMetaTileEntity).updateTexture(aBaseCasingIndex);\n                ((GT_MetaTileEntity_Hatch_InputBus)aMetaTileEntity).mRecipeMap = this.getRecipeMap();\n                return this.mInputBusses.add((GT_MetaTileEntity_Hatch_InputBus)aMetaTileEntity);\n            } else {\n                return false;\n            }\n        }\n    }\n\n    @Override\n    public boolean addOutputToMachineList(IGregTechTileEntity aTileEntity, int aBaseCasingIndex) {\n        if (aTileEntity == null) {\n            return false;\n        } else {\n            IMetaTileEntity aMetaTileEntity = aTileEntity.getMetaTileEntity();\n            if (aMetaTileEntity instanceof GT_MetaTileEntity_Hatch_OutputBus && ((GT_MetaTileEntity_Hatch_OutputBus) aMetaTileEntity).mTier == 0) {\n                ((GT_MetaTileEntity_Hatch)aMetaTileEntity).updateTexture(aBaseCasingIndex);\n                return this.mOutputBusses.add((GT_MetaTileEntity_Hatch_OutputBus)aMetaTileEntity);\n            } else {\n                return false;\n            }\n        }\n    }\n\n    @Override\n    public int getMaxEfficiency(ItemStack itemStack) {\n        return 10000;\n    }\n\n    @Override\n    public int getPollutionPerTick(ItemStack itemStack) {\n        return 0;\n    }\n\n    @Override\n    public int getDamageToComponent(ItemStack itemStack) {\n        return 0;\n    }\n\n    @Override\n    public boolean explodesOnComponentBreak(ItemStack itemStack) {\n        return false;\n    }\n\n    @Override\n    public IMetaTileEntity newMetaEntity(IGregTechTileEntity iGregTechTileEntity) {\n        return new GT_TileEntity_CircuitAssemblyLine(this.mName);\n    }\n\n    @Override\n    public String[] getDescription() {\n        return new String[]{\n                \"Circuit Assembly Line\", \"Size(WxHxD): (2-7)x3x3, variable length\",\n                \"Bottom: Steel Machine Casing(or 1x Maintenance or Input Hatch),\",\n                \"ULV Input Bus (Last ULV Output Bus), Steel Machine Casing\",\n                \"Middle: Reinforced Glass, Assembling Line Casing, Reinforced Glass\",\n                \"Top: Grate Machine Casing (or Controller or 1x Energy Hatch)\",\n                \"Up to 7 repeating slices, last is Output Bus\",\n                \"Imprint this machine with a Circuit Imprint,\",\n                \"by putting the imprint in the controller.\",\n                \"Every Circuit Assembly Line can only be imprinted ONCE.\",\n                StatCollector.translateToLocal(\"tooltip.bw.1.name\") + ChatColorHelper.DARKGREEN + \" BartWorks\"\n        };\n    }\n\n    @Override\n    public String[] getInfoData() {\n        String[] ret = new String[super.getInfoData().length+1];\n        System.arraycopy(super.getInfoData(),0,ret,0,super.getInfoData().length);\n        ret[super.getInfoData().length] = \"Imprinted with: \"+ GT_LanguageManager.getTranslation(GT_LanguageManager.getTranslateableItemStackName(CircuitImprintLoader.getStackFromTag(this.type)));\n        return ret;\n    }\n\n    @Override\n    public boolean isGivingInformation() {\n        return true;\n    }\n\n    @Override\n    public ITexture[] getTexture(IGregTechTileEntity aBaseMetaTileEntity, byte aSide, byte aFacing, byte aColorIndex, boolean aActive, boolean aRedstone) {\n        return aSide == aFacing ? new ITexture[]{Textures.BlockIcons.CASING_BLOCKS[16], new GT_RenderedTexture(aActive ? Textures.BlockIcons.OVERLAY_FRONT_ASSEMBLY_LINE_ACTIVE : Textures.BlockIcons.OVERLAY_FRONT_ASSEMBLY_LINE)} : new ITexture[]{Textures.BlockIcons.CASING_BLOCKS[16]};\n    }\n}", "class_id": 0, "repo": "observeroftime02/bartworks", "file": "src/main/java/com/github/bartimaeusnek/bartworks/common/tileentities/multis/GT_TileEntity_CircuitAssemblyLine.java", "last_update_at": "2019-11-07T23:48:51+00:00", "question_id": "ef71506d0ec030e2b2bc29d0db1cb82e7ad57c0a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GT_TileEntity_CircuitAssemblyLine extends GT_MetaTileEntity_MultiBlockBase {\n    public String getTypeForDisplay() {\n        if (this.type.equals(new NBTTagCompound()))\n            return \"\";\n        return GT_LanguageManager.getTranslation(GT_LanguageManager.getTranslateableItemStackName(CircuitImprintLoader.getStackFromTag(this.type)));\n    }\n    private NBTTagCompound type = new NBTTagCompound();\n    private GT_Recipe bufferedRecipe;\n    public GT_TileEntity_CircuitAssemblyLine(int aID, String aName, String aNameRegional) {\n        super(aID, aName, aNameRegional);\n    }\n    public GT_TileEntity_CircuitAssemblyLine(String aName) {\n        super(aName);\n    }\n    private boolean imprintMachine(ItemStack itemStack){\n        if (!this.type.equals(new NBTTagCompound()))\n            return true;\n        if (!GT_Utility.isStackValid(itemStack))\n            return false;\n        if (itemStack.getItem() instanceof BW_Meta_Items.BW_GT_MetaGenCircuits && itemStack.getItemDamage() == 0 && itemStack.getTagCompound() != null && this.type.equals(new NBTTagCompound())){\n            this.type = itemStack.getTagCompound();\n            this.mInventory[1] = null;\n            this.getBaseMetaTileEntity().issueBlockUpdate();\n            return true;\n        }\n        return false;\n    }\n    @Override\n    public boolean isCorrectMachinePart(ItemStack itemStack) {\n        return true;\n    }\n    @Override\n    public void startSoundLoop(byte aIndex, double aX, double aY, double aZ) {\n        super.startSoundLoop(aIndex, aX, aY, aZ);\n        if (aIndex == 20) {\n            GT_Utility.doSoundAtClient(GregTech_API.sSoundList.get(212), 10, 1.0F, aX, aY, aZ);\n        }\n    }\n    @Override\n    public void loadNBTData(NBTTagCompound aNBT) {\n        this.type = aNBT.getCompoundTag(\"Type\");\n        super.loadNBTData(aNBT);\n    }\n    @Override\n    public void saveNBTData(NBTTagCompound aNBT) {\n        if (!this.type.equals(new NBTTagCompound()))\n            aNBT.setTag(\"Type\", this.type);\n        super.saveNBTData(aNBT);\n    }\n    private final Collection<GT_Recipe> GT_RECIPE_COLLECTION = new HashSet<>();\n    @Override\n    public boolean checkRecipe(ItemStack itemStack) {\n        if (this.type.equals(new NBTTagCompound()))\n            if (!this.imprintMachine(itemStack))\n                return false;\n        if (this.bufferedRecipe != null && this.bufferedRecipe.isRecipeInputEqual(true,false, BW_Util.getFluidsFromInputHatches(this), BW_Util.getItemsFromInputBusses(this))) {\n            BW_Util.calculateOverclockedNessMulti(this.bufferedRecipe.mEUt,this.bufferedRecipe.mDuration,1,this.getMaxInputVoltage(),this);\n            this.mMaxProgresstime = Math.max(1, this.mMaxProgresstime);\n            this.mOutputItems = this.bufferedRecipe.mOutputs;\n            this.mOutputFluids = this.bufferedRecipe.mFluidOutputs;\n            this.updateSlots();\n            return true;\n        }\n        ItemStack stack = ItemStack.loadItemStackFromNBT(this.type);\n        if (stack == null)\n            return false;\n        if (this.GT_RECIPE_COLLECTION.isEmpty()) {\n            for (GT_Recipe recipe : BWRecipes.instance.getMappingsFor((byte) 3).mRecipeList) {\n                if (GT_Utility.areStacksEqual(recipe.mOutputs[0], stack, true)) {\n                    this.GT_RECIPE_COLLECTION.add(recipe);\n                }\n            }\n        }\n        for (GT_Recipe recipe : this.GT_RECIPE_COLLECTION) {\n            if (recipe.isRecipeInputEqual(true,false, BW_Util.getFluidsFromInputHatches(this), BW_Util.getItemsFromInputBusses(this)))\n                this.bufferedRecipe = recipe;\n            else\n                continue;\n            BW_Util.calculateOverclockedNessMulti(this.bufferedRecipe.mEUt,this.bufferedRecipe.mDuration,1,this.getMaxInputVoltage(),this);\n            this.mMaxProgresstime = Math.max(1, this.mMaxProgresstime);\n            this.mOutputItems = this.bufferedRecipe.mOutputs;\n            this.mOutputFluids = this.bufferedRecipe.mFluidOutputs;\n            this.updateSlots();\n            return true;\n        }\n        return false;\n    }\n    @Override\n    public boolean checkMachine(IGregTechTileEntity aBaseMetaTileEntity, ItemStack aStack) {\n        int xDir = ForgeDirection.getOrientation(aBaseMetaTileEntity.getBackFacing()).offsetX;\n        int zDir = ForgeDirection.getOrientation(aBaseMetaTileEntity.getBackFacing()).offsetZ;\n        int r;\n        int i;\n        IGregTechTileEntity tTileEntity;\n        if (xDir != 0) {\n            for(r = 0; r <= 7; ++r) {\n                i = r * xDir;\n                tTileEntity = aBaseMetaTileEntity.getIGregTechTileEntityOffset(xDir, 0, i);\n                if (!this.addEnergyInputToMachineList(tTileEntity, 16))\n                    if ((aBaseMetaTileEntity.getBlockOffset(0, 0, i) != GregTech_API.sBlockCasings3 || aBaseMetaTileEntity.getMetaIDOffset(0, 0, i) != 10) && r == 1)\n                        return false;\n                if (!aBaseMetaTileEntity.getBlockOffset(0, -1, i).getUnlocalizedName().equals(\"blockAlloyGlass\"))\n                    return false;\n                tTileEntity = aBaseMetaTileEntity.getIGregTechTileEntityOffset(0, -2, i);\n                if (!this.addMaintenanceToMachineList(tTileEntity, 16) && !this.addInputToMachineList(tTileEntity, 16))\n                    if (aBaseMetaTileEntity.getBlockOffset(0, -2, i) != GregTech_API.sBlockCasings2 || aBaseMetaTileEntity.getMetaIDOffset(0, -2, i) != 0)\n                        return false;\n                if (i != 0 && (aBaseMetaTileEntity.getBlockOffset(xDir, -1, i) != GregTech_API.sBlockCasings2 || aBaseMetaTileEntity.getMetaIDOffset(xDir, -1, i) != 5))\n                    return false;\n                if (!aBaseMetaTileEntity.getBlockOffset(xDir * 2, -1, i).getUnlocalizedName().equals(\"blockAlloyGlass\"))\n                    return false;\n                tTileEntity = aBaseMetaTileEntity.getIGregTechTileEntityOffset(xDir * 2, -2, i);\n                if (!this.addMaintenanceToMachineList(tTileEntity, 16) && !this.addInputToMachineList(tTileEntity, 16))\n                    if (aBaseMetaTileEntity.getBlockOffset(xDir * 2, -2, i) != GregTech_API.sBlockCasings2 || aBaseMetaTileEntity.getMetaIDOffset(xDir * 2, -2, i) != 0)\n                        return false;\n                tTileEntity = aBaseMetaTileEntity.getIGregTechTileEntityOffset(xDir, -2, i);\n                if (!this.addInputToMachineList(tTileEntity, 16) && this.addOutputToMachineList(tTileEntity, 16))\n                    return r > 0 && this.mEnergyHatches.size() > 0;\n            }\n        } else {\n            for(r = 0; r <= 7; ++r) {\n                i = r * -zDir;\n                //top with grate and energy hatch\n                tTileEntity = aBaseMetaTileEntity.getIGregTechTileEntityOffset(i, 0, zDir);\n                if (!this.addEnergyInputToMachineList(tTileEntity, 16))\n                    if ((aBaseMetaTileEntity.getBlockOffset(i, 0, 0) != GregTech_API.sBlockCasings3 || aBaseMetaTileEntity.getMetaIDOffset(i, 0, 0) != 10) && r == 1)\n                        return false;\n                if (!aBaseMetaTileEntity.getBlockOffset(i, -1, 0).getUnlocalizedName().equals(\"blockAlloyGlass\"))\n                    return false;\n                tTileEntity = aBaseMetaTileEntity.getIGregTechTileEntityOffset(i, -2, 0);\n                if (!this.addMaintenanceToMachineList(tTileEntity, 16) && !this.addInputToMachineList(tTileEntity, 16))\n                    if (aBaseMetaTileEntity.getBlockOffset(i, -2, 0) != GregTech_API.sBlockCasings2 || aBaseMetaTileEntity.getMetaIDOffset(i, -2, 0) != 0)\n                        return false;\n                if (i != 0 && (aBaseMetaTileEntity.getBlockOffset(i, -1, zDir) != GregTech_API.sBlockCasings2 || aBaseMetaTileEntity.getMetaIDOffset(i, -1, zDir) != 5))\n                    return false;\n                if (!aBaseMetaTileEntity.getBlockOffset(i, -1, zDir * 2).getUnlocalizedName().equals(\"blockAlloyGlass\"))\n                    return false;\n                tTileEntity = aBaseMetaTileEntity.getIGregTechTileEntityOffset(i, -2, zDir * 2);\n                if (!this.addMaintenanceToMachineList(tTileEntity, 16) && !this.addInputToMachineList(tTileEntity, 16))\n                    if (aBaseMetaTileEntity.getBlockOffset(i, -2, zDir * 2) != GregTech_API.sBlockCasings2 || aBaseMetaTileEntity.getMetaIDOffset(i, -2, zDir * 2) != 0)\n                        return false;\n                tTileEntity = aBaseMetaTileEntity.getIGregTechTileEntityOffset(i, -2, zDir);\n                if (!this.addInputToMachineList(tTileEntity, 16) && this.addOutputToMachineList(tTileEntity, 16))\n                    return r > 0 && this.mEnergyHatches.size() == 1;\n            }\n        }\n        return false;\n    }\n    @Override\n    public boolean addInputToMachineList(IGregTechTileEntity aTileEntity, int aBaseCasingIndex) {\n        if (aTileEntity == null) {\n            return false;\n        } else {\n            IMetaTileEntity aMetaTileEntity = aTileEntity.getMetaTileEntity();\n            if (aMetaTileEntity instanceof GT_MetaTileEntity_Hatch_Input) {\n                ((GT_MetaTileEntity_Hatch)aMetaTileEntity).updateTexture(aBaseCasingIndex);\n                ((GT_MetaTileEntity_Hatch_Input)aMetaTileEntity).mRecipeMap = this.getRecipeMap();\n                return this.mInputHatches.add((GT_MetaTileEntity_Hatch_Input)aMetaTileEntity);\n            } else if (aMetaTileEntity instanceof GT_MetaTileEntity_Hatch_InputBus && ((GT_MetaTileEntity_Hatch_InputBus) aMetaTileEntity).mTier == 0) {\n                ((GT_MetaTileEntity_Hatch)aMetaTileEntity).updateTexture(aBaseCasingIndex);\n                ((GT_MetaTileEntity_Hatch_InputBus)aMetaTileEntity).mRecipeMap = this.getRecipeMap();\n                return this.mInputBusses.add((GT_MetaTileEntity_Hatch_InputBus)aMetaTileEntity);\n            } else {\n                return false;\n            }\n        }\n    }\n    @Override\n    public boolean addOutputToMachineList(IGregTechTileEntity aTileEntity, int aBaseCasingIndex) {\n        if (aTileEntity == null) {\n            return false;\n        } else {\n            IMetaTileEntity aMetaTileEntity = aTileEntity.getMetaTileEntity();\n            if (aMetaTileEntity instanceof GT_MetaTileEntity_Hatch_OutputBus && ((GT_MetaTileEntity_Hatch_OutputBus) aMetaTileEntity).mTier == 0) {\n                ((GT_MetaTileEntity_Hatch)aMetaTileEntity).updateTexture(aBaseCasingIndex);\n                return this.mOutputBusses.add((GT_MetaTileEntity_Hatch_OutputBus)aMetaTileEntity);\n            } else {\n                return false;\n            }\n        }\n    }\n    @Override\n    public int getMaxEfficiency(ItemStack itemStack) {\n        return 10000;\n    }\n    @Override\n    public int getPollutionPerTick(ItemStack itemStack) {\n        return 0;\n    }\n    @Override\n    public int getDamageToComponent(ItemStack itemStack) {\n        return 0;\n    }\n    @Override\n    public boolean explodesOnComponentBreak(ItemStack itemStack) {\n        return false;\n    }\n    @Override\n    public IMetaTileEntity newMetaEntity(IGregTechTileEntity iGregTechTileEntity) {\n        return new GT_TileEntity_CircuitAssemblyLine(this.mName);\n    }\n    @Override\n    public String[] getDescription() {\n        return new String[]{\n                \"Circuit Assembly Line\", \"Size(WxHxD): (2-7)x3x3, variable length\",\n                \"Bottom: Steel Machine Casing(or 1x Maintenance or Input Hatch),\",\n                \"ULV Input Bus (Last ULV Output Bus), Steel Machine Casing\",\n                \"Middle: Reinforced Glass, Assembling Line Casing, Reinforced Glass\",\n                \"Top: Grate Machine Casing (or Controller or 1x Energy Hatch)\",\n                \"Up to 7 repeating slices, last is Output Bus\",\n                \"Imprint this machine with a Circuit Imprint,\",\n                \"by putting the imprint in the controller.\",\n                \"Every Circuit Assembly Line can only be imprinted ONCE.\",\n                StatCollector.translateToLocal(\"tooltip.bw.1.name\") + ChatColorHelper.DARKGREEN + \" BartWorks\"\n        };\n    }\n    @Override\n    public String[] getInfoData() {\n        String[] ret = new String[super.getInfoData().length+1];\n        System.arraycopy(super.getInfoData(),0,ret,0,super.getInfoData().length);\n        ret[super.getInfoData().length] = \"Imprinted with: \"+ GT_LanguageManager.getTranslation(GT_LanguageManager.getTranslateableItemStackName(CircuitImprintLoader.getStackFromTag(this.type)));\n        return ret;\n    }\n    @Override\n    public boolean isGivingInformation() {\n        return true;\n    }\n    @Override\n    public ITexture[] getTexture(IGregTechTileEntity aBaseMetaTileEntity, byte aSide, byte aFacing, byte aColorIndex, boolean aActive, boolean aRedstone) {\n        return aSide == aFacing ? new ITexture[]{Textures.BlockIcons.CASING_BLOCKS[16], new GT_RenderedTexture(aActive ? Textures.BlockIcons.OVERLAY_FRONT_ASSEMBLY_LINE_ACTIVE : Textures.BlockIcons.OVERLAY_FRONT_ASSEMBLY_LINE)} : new ITexture[]{Textures.BlockIcons.CASING_BLOCKS[16]};\n    }\n"]]}
{"hexsha": "a6c66284c7bdc3794f7e3328e89d126ab2dd8400", "ext": "java", "lang": "Java", "content": "@SuppressWarnings(\"unused\")\npublic final class TypesBrokerReport extends Table {\n    public static TypesBrokerReport getRootAsTypesBrokerReport(ByteBuffer _bb) {\n        return getRootAsTypesBrokerReport(_bb, new TypesBrokerReport());\n    }\n\n    public static TypesBrokerReport getRootAsTypesBrokerReport(ByteBuffer _bb, TypesBrokerReport obj) {\n        _bb.order(ByteOrder.LITTLE_ENDIAN);\n        return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb));\n    }\n\n    public void __init(int _i, ByteBuffer _bb) {\n        bb_pos = _i;\n        bb = _bb;\n    }\n\n    public TypesBrokerReport __assign(int _i, ByteBuffer _bb) {\n        __init(_i, _bb);\n        return this;\n    }\n\n    public String brokerID() {\n        int o = __offset(4);\n        return o != 0 ? __string(o + bb_pos) : null;\n    }\n\n    public ByteBuffer brokerIDAsByteBuffer() {\n        return __vector_as_bytebuffer(4, 1);\n    }\n\n    public long timeTag() {\n        int o = __offset(6);\n        return o != 0 ? bb.getLong(o + bb_pos) : 0L;\n    }\n\n    public double loadRatio() {\n        int o = __offset(8);\n        return o != 0 ? bb.getDouble(o + bb_pos) : 0.0;\n    }\n\n    public double bandWidthBytes() {\n        int o = __offset(10);\n        return o != 0 ? bb.getDouble(o + bb_pos) : 0.0;\n    }\n\n    public TypesChannelReport channelReports(int j) {\n        return channelReports(new TypesChannelReport(), j);\n    }\n\n    public TypesChannelReport channelReports(TypesChannelReport obj, int j) {\n        int o = __offset(12);\n        return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null;\n    }\n\n    public int channelReportsLength() {\n        int o = __offset(12);\n        return o != 0 ? __vector_len(o) : 0;\n    }\n\n    public static int createTypesBrokerReport(FlatBufferBuilder builder,\n                                              int brokerIDOffset,\n                                              long timeTag,\n                                              double loadRatio,\n                                              double bandWidthBytes,\n                                              int channelReportsOffset) {\n        builder.startObject(5);\n        TypesBrokerReport.addBandWidthBytes(builder, bandWidthBytes);\n        TypesBrokerReport.addLoadRatio(builder, loadRatio);\n        TypesBrokerReport.addTimeTag(builder, timeTag);\n        TypesBrokerReport.addChannelReports(builder, channelReportsOffset);\n        TypesBrokerReport.addBrokerID(builder, brokerIDOffset);\n        return TypesBrokerReport.endTypesBrokerReport(builder);\n    }\n\n    public static void startTypesBrokerReport(FlatBufferBuilder builder) {\n        builder.startObject(5);\n    }\n\n    public static void addBrokerID(FlatBufferBuilder builder, int brokerIDOffset) {\n        builder.addOffset(0, brokerIDOffset, 0);\n    }\n\n    public static void addTimeTag(FlatBufferBuilder builder, long timeTag) {\n        builder.addLong(1, timeTag, 0L);\n    }\n\n    public static void addLoadRatio(FlatBufferBuilder builder, double loadRatio) {\n        builder.addDouble(2, loadRatio, 0.0);\n    }\n\n    public static void addBandWidthBytes(FlatBufferBuilder builder, double bandWidthBytes) {\n        builder.addDouble(3, bandWidthBytes, 0.0);\n    }\n\n    public static void addChannelReports(FlatBufferBuilder builder, int channelReportsOffset) {\n        builder.addOffset(4, channelReportsOffset, 0);\n    }\n\n    public static int createChannelReportsVector(FlatBufferBuilder builder, int[] data) {\n        builder.startVector(4, data.length, 4);\n        for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]);\n        return builder.endVector();\n    }\n\n    public static void startChannelReportsVector(FlatBufferBuilder builder, int numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n\n    public static int endTypesBrokerReport(FlatBufferBuilder builder) {\n        int o = builder.endObject();\n        return o;\n    }\n\n    public static void finishTypesBrokerReportBuffer(FlatBufferBuilder builder, int offset) {\n        builder.finish(offset);\n    }\n}", "class_id": 0, "repo": "doc-vu/PubSubCoordZmq", "file": "src/main/java/edu/vanderbilt/chuilian/types/TypesBrokerReport.java", "last_update_at": "2019-08-15T09:13:58+00:00", "question_id": "a6c66284c7bdc3794f7e3328e89d126ab2dd8400", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings(\"unused\")\npublic final class TypesBrokerReport extends Table {\n    public static TypesBrokerReport getRootAsTypesBrokerReport(ByteBuffer _bb) {\n        return getRootAsTypesBrokerReport(_bb, new TypesBrokerReport());\n    }\n    public static TypesBrokerReport getRootAsTypesBrokerReport(ByteBuffer _bb, TypesBrokerReport obj) {\n        _bb.order(ByteOrder.LITTLE_ENDIAN);\n        return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb));\n    }\n    public void __init(int _i, ByteBuffer _bb) {\n        bb_pos = _i;\n        bb = _bb;\n    }\n    public TypesBrokerReport __assign(int _i, ByteBuffer _bb) {\n        __init(_i, _bb);\n        return this;\n    }\n    public String brokerID() {\n        int o = __offset(4);\n        return o != 0 ? __string(o + bb_pos) : null;\n    }\n    public ByteBuffer brokerIDAsByteBuffer() {\n        return __vector_as_bytebuffer(4, 1);\n    }\n    public long timeTag() {\n        int o = __offset(6);\n        return o != 0 ? bb.getLong(o + bb_pos) : 0L;\n    }\n    public double loadRatio() {\n        int o = __offset(8);\n        return o != 0 ? bb.getDouble(o + bb_pos) : 0.0;\n    }\n    public double bandWidthBytes() {\n        int o = __offset(10);\n        return o != 0 ? bb.getDouble(o + bb_pos) : 0.0;\n    }\n    public TypesChannelReport channelReports(int j) {\n        return channelReports(new TypesChannelReport(), j);\n    }\n    public TypesChannelReport channelReports(TypesChannelReport obj, int j) {\n        int o = __offset(12);\n        return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null;\n    }\n    public int channelReportsLength() {\n        int o = __offset(12);\n        return o != 0 ? __vector_len(o) : 0;\n    }\n    public static int createTypesBrokerReport(FlatBufferBuilder builder,\n                                              int brokerIDOffset,\n                                              long timeTag,\n                                              double loadRatio,\n                                              double bandWidthBytes,\n                                              int channelReportsOffset) {\n        builder.startObject(5);\n        TypesBrokerReport.addBandWidthBytes(builder, bandWidthBytes);\n        TypesBrokerReport.addLoadRatio(builder, loadRatio);\n        TypesBrokerReport.addTimeTag(builder, timeTag);\n        TypesBrokerReport.addChannelReports(builder, channelReportsOffset);\n        TypesBrokerReport.addBrokerID(builder, brokerIDOffset);\n        return TypesBrokerReport.endTypesBrokerReport(builder);\n    }\n    public static void startTypesBrokerReport(FlatBufferBuilder builder) {\n        builder.startObject(5);\n    }\n    public static void addBrokerID(FlatBufferBuilder builder, int brokerIDOffset) {\n        builder.addOffset(0, brokerIDOffset, 0);\n    }\n    public static void addTimeTag(FlatBufferBuilder builder, long timeTag) {\n        builder.addLong(1, timeTag, 0L);\n    }\n    public static void addLoadRatio(FlatBufferBuilder builder, double loadRatio) {\n        builder.addDouble(2, loadRatio, 0.0);\n    }\n    public static void addBandWidthBytes(FlatBufferBuilder builder, double bandWidthBytes) {\n        builder.addDouble(3, bandWidthBytes, 0.0);\n    }\n    public static void addChannelReports(FlatBufferBuilder builder, int channelReportsOffset) {\n        builder.addOffset(4, channelReportsOffset, 0);\n    }\n    public static int createChannelReportsVector(FlatBufferBuilder builder, int[] data) {\n        builder.startVector(4, data.length, 4);\n        for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]);\n        return builder.endVector();\n    }\n    public static void startChannelReportsVector(FlatBufferBuilder builder, int numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    public static int endTypesBrokerReport(FlatBufferBuilder builder) {\n        int o = builder.endObject();\n        return o;\n    }\n    public static void finishTypesBrokerReportBuffer(FlatBufferBuilder builder, int offset) {\n        builder.finish(offset);\n    }\n"]]}
{"hexsha": "da10b58f8dc10f22f7d0cff63bae49bb186f6ef7", "ext": "java", "lang": "Java", "content": "class GbmModel_Forest_6 {\n  public static void score0(double[] fdata, double[] preds) {\n    preds[1] += GbmModel_Tree_6_class_0.score0(fdata);\n    preds[2] += GbmModel_Tree_6_class_1.score0(fdata);\n    preds[3] += GbmModel_Tree_6_class_2.score0(fdata);\n    preds[4] += GbmModel_Tree_6_class_3.score0(fdata);\n    preds[5] += GbmModel_Tree_6_class_4.score0(fdata);\n    preds[6] += GbmModel_Tree_6_class_5.score0(fdata);\n  }\n}", "class_id": 9, "repo": "h2oai/qcon2015", "file": "06-pojo-model-deployment/models/GbmModel.java", "last_update_at": "2019-05-11T16:34:15+00:00", "question_id": "da10b58f8dc10f22f7d0cff63bae49bb186f6ef7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class GbmModel_Forest_6 {\n  public static void score0(double[] fdata, double[] preds) {\n    preds[1] += GbmModel_Tree_6_class_0.score0(fdata);\n    preds[2] += GbmModel_Tree_6_class_1.score0(fdata);\n    preds[3] += GbmModel_Tree_6_class_2.score0(fdata);\n    preds[4] += GbmModel_Tree_6_class_3.score0(fdata);\n    preds[5] += GbmModel_Tree_6_class_4.score0(fdata);\n    preds[6] += GbmModel_Tree_6_class_5.score0(fdata);\n  }\n"]]}
{"hexsha": "f52449133dc1b8fb835cce8ab3b487a6fe536655", "ext": "java", "lang": "Java", "content": "public class MyLockDemo {\n\n    MyLock lock = new MyLock();\n    int i = 0;\n\n    public void safeIncrease(){\n        for (int j = 0; j < 10000; j++){\n            lock.lock();\n            i++;\n            lock.unlock();\n        }\n    }\n\n    public void unsafeIncrease(){\n        for (int j = 0; j < 10000; j++){\n            i++;\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException{\n        MyLockDemo demo = new MyLockDemo();\n        CountDownLatch count = new CountDownLatch(10);\n        for (int i = 0; i < 10; i++){\n            Thread t = new Thread(() -> {\n//                demo.unsafeIncrease(); // \u6267\u884c\u7ed3\u679c\u5fc5\u7136\u5c0f\u4e8e100000\n                demo.safeIncrease(); // \u6267\u884c\u7ed3\u679c\u7b49\u4e8e100000\n                count.countDown();\n            });\n            t.start();\n        }\n        count.await();\n        System.out.println(demo.i);\n    }\n}", "class_id": 0, "repo": "SucreWu/learning-project", "file": "src/test/java/com/wujie/learning/lock/MyLockDemo.java", "last_update_at": "2019-06-22T10:19:29+00:00", "question_id": "f52449133dc1b8fb835cce8ab3b487a6fe536655", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MyLockDemo {\n    MyLock lock = new MyLock();\n    int i = 0;\n    public void safeIncrease(){\n        for (int j = 0; j < 10000; j++){\n            lock.lock();\n            i++;\n            lock.unlock();\n        }\n    }\n    public void unsafeIncrease(){\n        for (int j = 0; j < 10000; j++){\n            i++;\n        }\n    }\n    public static void main(String[] args) throws InterruptedException{\n        MyLockDemo demo = new MyLockDemo();\n        CountDownLatch count = new CountDownLatch(10);\n        for (int i = 0; i < 10; i++){\n            Thread t = new Thread(() -> {\n//                demo.unsafeIncrease(); // \u6267\u884c\u7ed3\u679c\u5fc5\u7136\u5c0f\u4e8e100000\n                demo.safeIncrease(); // \u6267\u884c\u7ed3\u679c\u7b49\u4e8e100000\n                count.countDown();\n            });\n            t.start();\n        }\n        count.await();\n        System.out.println(demo.i);\n    }\n"]]}
{"hexsha": "bc5e6a40275f6b5472c504c25859529c458d7b3d", "ext": "java", "lang": "Java", "content": "@Service\npublic class FeedbackServiceImpl implements FeedbackService {\n\n\n   private static final Logger LOGGER = LoggerFactory.getLogger(FeedbackServiceImpl.class);\n\n   @Autowired\n   private GameService gameService;\n\n   @Override\n   public ResponseObject getFeedbackFor(final HttpSession session, final PinPlacement requestPlacement) {\n      LOGGER.debug(\"--> getFeedbackFor\");\n      final ResponseObject responseObject = new ResponseObject();\n\n      try {\n         final Game currentGame = gameService.getCurrentGameOf(session);\n         final PinPlacement solution = currentGame.getPinSolution();\n         final Map<Integer, String> solutionMap = solution.getColors();\n         final Map<Integer, String> placementMap = requestPlacement.getColors();\n         List<Object> solutionValues = new ArrayList<>(solutionMap.values());\n         List<Object> placementValues = new ArrayList<>(placementMap.values());\n\n         List<Object> correctPositions = calculateCorrectPositions(solutionValues, placementValues);\n\n         for (Object position : correctPositions) {\n            solutionValues.remove(position);\n            placementValues.remove(position);\n\n         }\n\n         int correctColors = calculateCorrectColors(solutionValues, placementValues);\n         responseObject.setCorrectColors(correctColors);\n         responseObject.setCorrectPositions(correctPositions.size());\n\n      } catch (GameNotFoundException e) {\n         responseObject.setCorrectPositions(0);\n         responseObject.setCorrectColors(0);\n      }\n\n\n      LOGGER.debug(\"<-- getFeedbackFor\");\n      return responseObject;\n\n\n   }\n\n   private List<Object> calculateCorrectPositions(final List<Object> solutionEntries, final List<Object> placementEntries) {\n\n      List<Object> correctPositionValues = new ArrayList<>();\n      for (int i = 0; i < solutionEntries.size(); i++) {\n         if (placementEntries.get(i).equals(solutionEntries.get(i))) {\n            correctPositionValues.add(placementEntries.get(i));\n         }\n      }\n      return correctPositionValues;\n   }\n\n   private int calculateCorrectColors(final List<Object> solutionEntries, final List<Object> placementEntries) {\n\n      int correctColors = 0;\n      List<Object> correctColorsValues = new ArrayList<>();\n\n      for (int i = 0; i < solutionEntries.size(); i++) {\n         Object color = solutionEntries.get(i);\n         if (!correctColorsValues.contains(color)) {\n            for (int a = 0; a < solutionEntries.size(); a++) {\n               if (color.equals(placementEntries.get(a))) {\n                  correctColors++;\n                  correctColorsValues.add(color);\n                  break;\n               }\n            }\n         }\n      }\n\n      return correctColors;\n   }\n\n\n}", "class_id": 0, "repo": "Sybit-Education/Coding-Camp-2019", "file": "src/main/java/de/sybit/codingcamp2019/service/FeedbackServiceImpl.java", "last_update_at": "2019-12-18T16:51:32+00:00", "question_id": "bc5e6a40275f6b5472c504c25859529c458d7b3d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\npublic class FeedbackServiceImpl implements FeedbackService {\n   private static final Logger LOGGER = LoggerFactory.getLogger(FeedbackServiceImpl.class);\n   @Autowired\n   private GameService gameService;\n   @Override\n   public ResponseObject getFeedbackFor(final HttpSession session, final PinPlacement requestPlacement) {\n      LOGGER.debug(\"--> getFeedbackFor\");\n      final ResponseObject responseObject = new ResponseObject();\n      try {\n         final Game currentGame = gameService.getCurrentGameOf(session);\n         final PinPlacement solution = currentGame.getPinSolution();\n         final Map<Integer, String> solutionMap = solution.getColors();\n         final Map<Integer, String> placementMap = requestPlacement.getColors();\n         List<Object> solutionValues = new ArrayList<>(solutionMap.values());\n         List<Object> placementValues = new ArrayList<>(placementMap.values());\n         List<Object> correctPositions = calculateCorrectPositions(solutionValues, placementValues);\n         for (Object position : correctPositions) {\n            solutionValues.remove(position);\n            placementValues.remove(position);\n         }\n         int correctColors = calculateCorrectColors(solutionValues, placementValues);\n         responseObject.setCorrectColors(correctColors);\n         responseObject.setCorrectPositions(correctPositions.size());\n      } catch (GameNotFoundException e) {\n         responseObject.setCorrectPositions(0);\n         responseObject.setCorrectColors(0);\n      }\n      LOGGER.debug(\"<-- getFeedbackFor\");\n      return responseObject;\n   }\n   private List<Object> calculateCorrectPositions(final List<Object> solutionEntries, final List<Object> placementEntries) {\n      List<Object> correctPositionValues = new ArrayList<>();\n      for (int i = 0; i < solutionEntries.size(); i++) {\n         if (placementEntries.get(i).equals(solutionEntries.get(i))) {\n            correctPositionValues.add(placementEntries.get(i));\n         }\n      }\n      return correctPositionValues;\n   }\n   private int calculateCorrectColors(final List<Object> solutionEntries, final List<Object> placementEntries) {\n      int correctColors = 0;\n      List<Object> correctColorsValues = new ArrayList<>();\n      for (int i = 0; i < solutionEntries.size(); i++) {\n         Object color = solutionEntries.get(i);\n         if (!correctColorsValues.contains(color)) {\n            for (int a = 0; a < solutionEntries.size(); a++) {\n               if (color.equals(placementEntries.get(a))) {\n                  correctColors++;\n                  correctColorsValues.add(color);\n                  break;\n               }\n            }\n         }\n      }\n      return correctColors;\n   }\n"]]}
{"hexsha": "222ddd87afd4681494ed1c57cd57e975d01443c5", "ext": "java", "lang": "Java", "content": "@JsonIgnoreProperties(ignoreUnknown = true)\npublic class AbiDefinition {\n    private boolean constant;\n    private List<NamedType> inputs;\n    private String name;\n    private List<NamedType> outputs;\n    private String type;\n    private boolean payable;\n\n    /**\n     * The stateMutability function modifier.\n     *\n     * <p>this does not factor into the <code>#hashCode()</code> or <code>#equals()</code> logic\n     * since multiple functions with the same signature that only differ in mutability are not\n     * allowed in Solidity.\n     *\n     * <p>Valid values are:\n     *\n     * <ul>\n     *   <li>pure\n     *   <li>view\n     *   <li>nonpayable\n     *   <li>payable\n     * </ul>\n     */\n    private String stateMutability;\n\n    public AbiDefinition() {}\n\n    public AbiDefinition(AbiDefinition from) {\n        this(\n                from.constant,\n                clone(from.inputs),\n                from.name,\n                clone(from.outputs),\n                from.type,\n                from.payable,\n                from.stateMutability);\n    }\n\n    public AbiDefinition(\n            boolean constant,\n            List<NamedType> inputs,\n            String name,\n            List<NamedType> outputs,\n            String type,\n            boolean payable) {\n        this(constant, inputs, name, outputs, type, payable, null);\n    }\n\n    public AbiDefinition(\n            boolean constant,\n            List<NamedType> inputs,\n            String name,\n            List<NamedType> outputs,\n            String type,\n            boolean payable,\n            String stateMutability) {\n        this.constant = constant;\n        this.inputs = inputs;\n        this.name = name;\n        this.outputs = outputs;\n        this.type = type;\n        this.payable = payable;\n        this.stateMutability = stateMutability;\n    }\n\n    public boolean isConstant() {\n        return constant;\n    }\n\n    public void setConstant(boolean constant) {\n        this.constant = constant;\n    }\n\n    public List<NamedType> getInputs() {\n        return inputs;\n    }\n\n    public void setInputs(List<NamedType> inputs) {\n        this.inputs = inputs;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public List<NamedType> getOutputs() {\n        return outputs;\n    }\n\n    public boolean hasOutputs() {\n        return !outputs.isEmpty();\n    }\n\n    public void setOutputs(List<NamedType> outputs) {\n        this.outputs = outputs;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public boolean isPayable() {\n        return payable;\n    }\n\n    public void setPayable(boolean payable) {\n        this.payable = payable;\n    }\n\n    public String getStateMutability() {\n        return stateMutability;\n    }\n\n    public void setStateMutability(String stateMutability) {\n        this.stateMutability = stateMutability;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof AbiDefinition)) {\n            return false;\n        }\n\n        AbiDefinition that = (AbiDefinition) o;\n\n        if (isConstant() != that.isConstant()) {\n            return false;\n        }\n        if (isPayable() != that.isPayable()) {\n            return false;\n        }\n        if (getInputs() != null\n                ? !getInputs().equals(that.getInputs())\n                : that.getInputs() != null) {\n            return false;\n        }\n        if (getName() != null ? !getName().equals(that.getName()) : that.getName() != null) {\n            return false;\n        }\n        if (getOutputs() != null\n                ? !getOutputs().equals(that.getOutputs())\n                : that.getOutputs() != null) {\n            return false;\n        }\n        if (getStateMutability() != null\n                ? !getStateMutability().equals(that.getStateMutability())\n                : that.getStateMutability() != null) {\n            return false;\n        }\n        return getType() != null ? getType().equals(that.getType()) : that.getType() == null;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = (isConstant() ? 1 : 0);\n        result = 31 * result + (getInputs() != null ? getInputs().hashCode() : 0);\n        result = 31 * result + (getName() != null ? getName().hashCode() : 0);\n        result = 31 * result + (getOutputs() != null ? getOutputs().hashCode() : 0);\n        result = 31 * result + (getType() != null ? getType().hashCode() : 0);\n        result = 31 * result + (isPayable() ? 1 : 0);\n        result = 31 * result + (getStateMutability() != null ? getStateMutability().hashCode() : 0);\n        return result;\n    }\n\n    public static class NamedType {\n        private String name;\n        private String type;\n        private boolean indexed;\n\n        public NamedType() {}\n\n        public NamedType(NamedType from) {\n            this(from.name, from.type, from.indexed);\n        }\n\n        public NamedType(String name, String type) {\n            this.name = name;\n            this.type = type;\n        }\n\n        public NamedType(String name, String type, boolean indexed) {\n            this.name = name;\n            this.type = type;\n            this.indexed = indexed;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public String getType() {\n            return type;\n        }\n\n        public void setType(String type) {\n            this.type = type;\n        }\n\n        public boolean isIndexed() {\n            return indexed;\n        }\n\n        public void setIndexed(boolean indexed) {\n            this.indexed = indexed;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (!(o instanceof NamedType)) {\n                return false;\n            }\n\n            NamedType namedType = (NamedType) o;\n\n            if (isIndexed() != namedType.isIndexed()) {\n                return false;\n            }\n\n            if (getName() != null\n                    ? !getName().equals(namedType.getName())\n                    : namedType.getName() != null) {\n                return false;\n            }\n            return getType() != null\n                    ? getType().equals(namedType.getType())\n                    : namedType.getType() == null;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = getName() != null ? getName().hashCode() : 0;\n            result = 31 * result + (getType() != null ? getType().hashCode() : 0);\n            result = 31 * result + (isIndexed() ? 1 : 0);\n            return result;\n        }\n    }\n\n    private static List<NamedType> clone(final List<NamedType> from) {\n        return from.stream().map(NamedType::new).collect(Collectors.toList());\n    }\n}", "class_id": 0, "repo": "storm3java/storm3java", "file": "core/src/main/java/org/storm3j/protocol/core/methods/response/AbiDefinition.java", "last_update_at": "2019-12-26T06:47:29+00:00", "question_id": "222ddd87afd4681494ed1c57cd57e975d01443c5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@JsonIgnoreProperties(ignoreUnknown = true)\npublic class AbiDefinition {\n    private boolean constant;\n    private List<NamedType> inputs;\n    private String name;\n    private List<NamedType> outputs;\n    private String type;\n    private boolean payable;\n    /**\n     * The stateMutability function modifier.\n     *\n     * <p>this does not factor into the <code>#hashCode()</code> or <code>#equals()</code> logic\n     * since multiple functions with the same signature that only differ in mutability are not\n     * allowed in Solidity.\n     *\n     * <p>Valid values are:\n     *\n     * <ul>\n     *   <li>pure\n     *   <li>view\n     *   <li>nonpayable\n     *   <li>payable\n     * </ul>\n     */\n    private String stateMutability;\n    public AbiDefinition() {}\n    public AbiDefinition(AbiDefinition from) {\n        this(\n                from.constant,\n                clone(from.inputs),\n                from.name,\n                clone(from.outputs),\n                from.type,\n                from.payable,\n                from.stateMutability);\n    }\n    public AbiDefinition(\n            boolean constant,\n            List<NamedType> inputs,\n            String name,\n            List<NamedType> outputs,\n            String type,\n            boolean payable) {\n        this(constant, inputs, name, outputs, type, payable, null);\n    }\n    public AbiDefinition(\n            boolean constant,\n            List<NamedType> inputs,\n            String name,\n            List<NamedType> outputs,\n            String type,\n            boolean payable,\n            String stateMutability) {\n        this.constant = constant;\n        this.inputs = inputs;\n        this.name = name;\n        this.outputs = outputs;\n        this.type = type;\n        this.payable = payable;\n        this.stateMutability = stateMutability;\n    }\n    public boolean isConstant() {\n        return constant;\n    }\n    public void setConstant(boolean constant) {\n        this.constant = constant;\n    }\n    public List<NamedType> getInputs() {\n        return inputs;\n    }\n    public void setInputs(List<NamedType> inputs) {\n        this.inputs = inputs;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public List<NamedType> getOutputs() {\n        return outputs;\n    }\n    public boolean hasOutputs() {\n        return !outputs.isEmpty();\n    }\n    public void setOutputs(List<NamedType> outputs) {\n        this.outputs = outputs;\n    }\n    public String getType() {\n        return type;\n    }\n    public void setType(String type) {\n        this.type = type;\n    }\n    public boolean isPayable() {\n        return payable;\n    }\n    public void setPayable(boolean payable) {\n        this.payable = payable;\n    }\n    public String getStateMutability() {\n        return stateMutability;\n    }\n    public void setStateMutability(String stateMutability) {\n        this.stateMutability = stateMutability;\n    }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof AbiDefinition)) {\n            return false;\n        }\n        AbiDefinition that = (AbiDefinition) o;\n        if (isConstant() != that.isConstant()) {\n            return false;\n        }\n        if (isPayable() != that.isPayable()) {\n            return false;\n        }\n        if (getInputs() != null\n                ? !getInputs().equals(that.getInputs())\n                : that.getInputs() != null) {\n            return false;\n        }\n        if (getName() != null ? !getName().equals(that.getName()) : that.getName() != null) {\n            return false;\n        }\n        if (getOutputs() != null\n                ? !getOutputs().equals(that.getOutputs())\n                : that.getOutputs() != null) {\n            return false;\n        }\n        if (getStateMutability() != null\n                ? !getStateMutability().equals(that.getStateMutability())\n                : that.getStateMutability() != null) {\n            return false;\n        }\n        return getType() != null ? getType().equals(that.getType()) : that.getType() == null;\n    }\n    @Override\n    public int hashCode() {\n        int result = (isConstant() ? 1 : 0);\n        result = 31 * result + (getInputs() != null ? getInputs().hashCode() : 0);\n        result = 31 * result + (getName() != null ? getName().hashCode() : 0);\n        result = 31 * result + (getOutputs() != null ? getOutputs().hashCode() : 0);\n        result = 31 * result + (getType() != null ? getType().hashCode() : 0);\n        result = 31 * result + (isPayable() ? 1 : 0);\n        result = 31 * result + (getStateMutability() != null ? getStateMutability().hashCode() : 0);\n        return result;\n    }\n    public static class NamedType {\n        private String name;\n        private String type;\n        private boolean indexed;\n        public NamedType() {}\n        public NamedType(NamedType from) {\n            this(from.name, from.type, from.indexed);\n        }\n        public NamedType(String name, String type) {\n            this.name = name;\n            this.type = type;\n        }\n        public NamedType(String name, String type, boolean indexed) {\n            this.name = name;\n            this.type = type;\n            this.indexed = indexed;\n        }\n        public String getName() {\n            return name;\n        }\n        public void setName(String name) {\n            this.name = name;\n        }\n        public String getType() {\n            return type;\n        }\n        public void setType(String type) {\n            this.type = type;\n        }\n        public boolean isIndexed() {\n            return indexed;\n        }\n        public void setIndexed(boolean indexed) {\n            this.indexed = indexed;\n        }\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (!(o instanceof NamedType)) {\n                return false;\n            }\n            NamedType namedType = (NamedType) o;\n            if (isIndexed() != namedType.isIndexed()) {\n                return false;\n            }\n            if (getName() != null\n                    ? !getName().equals(namedType.getName())\n                    : namedType.getName() != null) {\n                return false;\n            }\n            return getType() != null\n                    ? getType().equals(namedType.getType())\n                    : namedType.getType() == null;\n        }\n        @Override\n        public int hashCode() {\n            int result = getName() != null ? getName().hashCode() : 0;\n            result = 31 * result + (getType() != null ? getType().hashCode() : 0);\n            result = 31 * result + (isIndexed() ? 1 : 0);\n            return result;\n        }\n    }\n    private static List<NamedType> clone(final List<NamedType> from) {\n        return from.stream().map(NamedType::new).collect(Collectors.toList());\n    }\n"]]}
{"hexsha": "fb2eda00abf5381409eecbc715aae4b3dbc06a17", "ext": "java", "lang": "Java", "content": "public class RemoteRosterEntry {\n\n    private Jid user;\n    private String name;\n    private final List<String> groupNames = new ArrayList<String>();\n\n    /**\n     * Creates a new remote roster entry.\n     *\n     * @param user the user.\n     * @param name the user's name.\n     * @param groups the list of group names the entry will belong to, or <tt>null</tt> if the\n     *      the roster entry won't belong to a group.\n     */\n    public RemoteRosterEntry(Jid user, String name, String [] groups) {\n        this.user = user;\n        this.name = name;\n        if (groups != null) {\n            groupNames.addAll(Arrays.asList(groups));\n        }\n    }\n\n    /**\n     * Returns the user.\n     *\n     * @return the user.\n     */\n    public Jid getUser() {\n        return user;\n    }\n\n    /**\n     * Returns the user's name.\n     *\n     * @return the user's name.\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns an Iterator for the group names (as Strings) that the roster entry\n     * belongs to.\n     *\n     * @return an Iterator for the group names.\n     */\n    public Iterator<String> getGroupNames() {\n        synchronized (groupNames) {\n            return Collections.unmodifiableList(groupNames).iterator();\n        }\n    }\n\n    /**\n     * Returns a String array for the group names that the roster entry\n     * belongs to.\n     *\n     * @return a String[] for the group names.\n     */\n    public String[] getGroupArrayNames() {\n        synchronized (groupNames) {\n            return Collections.unmodifiableList(groupNames).toArray(new String[groupNames.size()]);\n        }\n    }\n\n    public String toXML() {\n        StringBuilder buf = new StringBuilder();\n        buf.append(\"<item jid=\\\"\").append(user).append('\"');\n        if (name != null) {\n            buf.append(\" name=\\\"\").append(name).append('\"');\n        }\n        buf.append('>');\n        synchronized (groupNames) {\n            for (String groupName : groupNames) {\n                buf.append(\"<group>\").append(groupName).append(\"</group>\");\n            }\n        }\n        buf.append(\"</item>\");\n        return buf.toString();\n    }\n\n}", "class_id": 0, "repo": "annovanvliet/Smack", "file": "smack-legacy/src/main/java/org/jivesoftware/smackx/xroster/RemoteRosterEntry.java", "last_update_at": "2019-09-16T04:03:12+00:00", "question_id": "fb2eda00abf5381409eecbc715aae4b3dbc06a17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RemoteRosterEntry {\n    private Jid user;\n    private String name;\n    private final List<String> groupNames = new ArrayList<String>();\n    /**\n     * Creates a new remote roster entry.\n     *\n     * @param user the user.\n     * @param name the user's name.\n     * @param groups the list of group names the entry will belong to, or <tt>null</tt> if the\n     *      the roster entry won't belong to a group.\n     */\n    public RemoteRosterEntry(Jid user, String name, String [] groups) {\n        this.user = user;\n        this.name = name;\n        if (groups != null) {\n            groupNames.addAll(Arrays.asList(groups));\n        }\n    }\n    /**\n     * Returns the user.\n     *\n     * @return the user.\n     */\n    public Jid getUser() {\n        return user;\n    }\n    /**\n     * Returns the user's name.\n     *\n     * @return the user's name.\n     */\n    public String getName() {\n        return name;\n    }\n    /**\n     * Returns an Iterator for the group names (as Strings) that the roster entry\n     * belongs to.\n     *\n     * @return an Iterator for the group names.\n     */\n    public Iterator<String> getGroupNames() {\n        synchronized (groupNames) {\n            return Collections.unmodifiableList(groupNames).iterator();\n        }\n    }\n    /**\n     * Returns a String array for the group names that the roster entry\n     * belongs to.\n     *\n     * @return a String[] for the group names.\n     */\n    public String[] getGroupArrayNames() {\n        synchronized (groupNames) {\n            return Collections.unmodifiableList(groupNames).toArray(new String[groupNames.size()]);\n        }\n    }\n    public String toXML() {\n        StringBuilder buf = new StringBuilder();\n        buf.append(\"<item jid=\\\"\").append(user).append('\"');\n        if (name != null) {\n            buf.append(\" name=\\\"\").append(name).append('\"');\n        }\n        buf.append('>');\n        synchronized (groupNames) {\n            for (String groupName : groupNames) {\n                buf.append(\"<group>\").append(groupName).append(\"</group>\");\n            }\n        }\n        buf.append(\"</item>\");\n        return buf.toString();\n    }\n"]]}
{"hexsha": "62a3871cbd1b202556754083c0141c839d45bc5c", "ext": "java", "lang": "Java", "content": "public class BenchmarkTask implements\n        ParallelTaskRunner.TaskWithException<VariantAnnotation, Pair<VariantAnnotationDiff, VariantAnnotationDiff>, Exception> {\n\n    private FastaIndexManager fastaIndexManager;\n    private static final String VARIANT_STRING_PATTERN = \"[ACGT]*\";\n//    private static final String VARIANT_STRING_PATTERN = \"([ACGT]*)|(<CNV>)|(<INV>)|(<DEL>)|(<INS>)|(<DUP:TANDEM>)\";\n    private VariantAnnotator variantAnnotator;\n\n    public BenchmarkTask(VariantAnnotator variantAnnotator, FastaIndexManager fastaIndexManager) {\n        this.variantAnnotator = variantAnnotator;\n        this.fastaIndexManager = fastaIndexManager;\n    }\n\n    public void pre() {\n        variantAnnotator.open();\n    }\n\n    public List<Pair<VariantAnnotationDiff, VariantAnnotationDiff>> apply(List<VariantAnnotation> batch)\n            throws Exception {\n        // VEP format does not include the reference allele. It's needed for the benchmark if the cache is activated -\n        // otherwise VariantAnnotationCalculator wont find most of the variants in the variation collection\n        fixReference(batch);\n        removeInvalidVariants(batch);\n        List<Variant> cellBaseBatch = createEmptyVariantList(batch);\n        variantAnnotator.run(cellBaseBatch);\n        List<Pair<VariantAnnotationDiff, VariantAnnotationDiff>> comparisonResultList = new ArrayList<>();\n        for (int i = 0; i < batch.size(); i++) {\n            // Variants such as MT:453:TTT:ATT are skipped for the benchmark - will not have CellBase annotation\n            // compatible with VEP annotation and therefore consequenceTypeList = null\n            if (batch.get(i).getConsequenceTypes() != null && batch.get(i).getConsequenceTypes().size() > 0\n                    && cellBaseBatch.get(i).getAnnotation().getConsequenceTypes() != null\n                    && cellBaseBatch.get(i).getAnnotation().getConsequenceTypes().size() > 0) {\n                Pair<VariantAnnotationDiff, VariantAnnotationDiff> comparisonResult = compare(batch.get(i),\n                        cellBaseBatch.get(i).getAnnotation());\n                comparisonResult.getLeft().setVariantAnnotation(batch.get(i));\n                comparisonResult.getRight().setVariantAnnotation(cellBaseBatch.get(i).getAnnotation());\n                comparisonResultList.add(comparisonResult);\n            }\n        }\n        return comparisonResultList;\n    }\n\n    private void fixReference(List<VariantAnnotation> variantAnnotationList) throws RocksDBException {\n        for (VariantAnnotation variantAnnotation : variantAnnotationList) {\n            if (!variantAnnotation.getReference().isEmpty() && !variantAnnotation.getReference().equals(\"-\")) {\n                variantAnnotation.setReference(fastaIndexManager.query(variantAnnotation.getChromosome(),\n                        variantAnnotation.getStart(), variantAnnotation.getStart()\n                                + variantAnnotation.getReference().length() - 1));\n            }\n        }\n    }\n\n    private void removeInvalidVariants(List<VariantAnnotation> variantAnnotationList) {\n        int i = 0;\n        while (i < variantAnnotationList.size()) {\n            if (isValid(variantAnnotationList.get(i))) {\n                i++;\n            } else {\n                variantAnnotationList.remove(i);\n            }\n        }\n    }\n\n    /**\n     * Checks whether a variant is valid.\n     *\n     * @param variantAnnotation Variant object to be checked.\n     * @return   true/false depending on whether 'variant' does contain valid values. Currently just a simple check of\n     * reference/alternate attributes being strings of [A,C,G,T] of length >= 0 is performed to detect cases such as\n     * 19:13318673:(CAG)4:(CAG)5 which are not currently supported by CellBase. Ref and alt alleles must be different\n     * as well for the variant to be valid. Functionality of the method may be improved in the future.\n     */\n    private boolean isValid(VariantAnnotation variantAnnotation) {\n        return (variantAnnotation.getAlternate().matches(VARIANT_STRING_PATTERN)\n//                && variantAnnotation.getReferenceStart().matches(VARIANT_STRING_PATTERN)\n                && !variantAnnotation.getAlternate().equals(variantAnnotation.getReference()));\n    }\n\n    private Pair<VariantAnnotationDiff, VariantAnnotationDiff> compare(VariantAnnotation variant1, VariantAnnotation variant2) {\n        Pair<VariantAnnotationDiff, VariantAnnotationDiff> result\n                = Pair.of(new VariantAnnotationDiff(), new VariantAnnotationDiff());\n        compareSequenceOntologyTerms(result, variant1.getConsequenceTypes(),\n                variant2.getConsequenceTypes());\n\n        return result;\n    }\n\n    private void compareSequenceOntologyTerms(Pair<VariantAnnotationDiff, VariantAnnotationDiff> result,\n                                              List<ConsequenceType> consequenceTypeList1,\n                                              List<ConsequenceType> consequenceTypeList2) {\n        Set<SequenceOntologyTermComparisonObject> sequenceOntologySet1 = getSequenceOntologySet(consequenceTypeList1);\n        Set<SequenceOntologyTermComparisonObject> sequenceOntologySet2 = getSequenceOntologySet(consequenceTypeList2);\n        Set<SequenceOntologyTermComparisonObject> sequenceOntologySet1bak = new HashSet<>(sequenceOntologySet1);\n        sequenceOntologySet1.removeAll(sequenceOntologySet2);\n        sequenceOntologySet2.removeAll(sequenceOntologySet1bak);\n        if (sequenceOntologySet1.size() > 0) {\n            result.getLeft().setSequenceOntology(new ArrayList(sequenceOntologySet1));\n        }\n        if (sequenceOntologySet2.size() > 0) {\n            result.getRight().setSequenceOntology(new ArrayList(sequenceOntologySet2));\n        }\n    }\n\n    private Set<SequenceOntologyTermComparisonObject> getSequenceOntologySet(List<ConsequenceType> consequenceTypeList) {\n        if (consequenceTypeList != null) {\n            Set<SequenceOntologyTermComparisonObject> set = new HashSet<>(consequenceTypeList.size());\n            for (ConsequenceType consequenceType : consequenceTypeList) {\n                for (SequenceOntologyTerm sequenceOntologyTerm : consequenceType.getSequenceOntologyTerms()) {\n//                    // Expected many differences depending on the regulatory source databases used by the annotators.\n//                    // Better skip regulatory_region_variant annotations\n//                    if (!(sequenceOntologyTerm.getName().equals(VariantAnnotationUtils.REGULATORY_REGION_VARIANT)\n//                            || sequenceOntologyTerm.getName().equals(VariantAnnotationUtils.TF_BINDING_SITE_VARIANT))) {\n                    set.add(new SequenceOntologyTermComparisonObject(consequenceType.getEnsemblTranscriptId(),\n                            sequenceOntologyTerm));\n//                    }\n                }\n            }\n\n            return set;\n        } else {\n            return null;\n        }\n    }\n\n    private List<Variant> createEmptyVariantList(List<VariantAnnotation> variantAnnotationList) {\n        List<Variant> newVariantList = new ArrayList<>(variantAnnotationList.size());\n        for (VariantAnnotation variantAnnotation : variantAnnotationList) {\n            Variant variant = new Variant(variantAnnotation.getChromosome(), variantAnnotation.getStart(),\n                    variantAnnotation.getEnd(), variantAnnotation.getReference(), variantAnnotation.getAlternate());\n            variant.resetType();\n            variant.resetLength();\n            newVariantList.add(variant);\n        }\n\n        return newVariantList;\n    }\n\n    public void post() {\n        variantAnnotator.close();\n    }\n}", "class_id": 0, "repo": "babelomics/cellbase", "file": "cellbase-app/src/main/java/org/opencb/cellbase/app/cli/variant/annotation/BenchmarkTask.java", "last_update_at": "2019-06-14T08:35:10+00:00", "question_id": "62a3871cbd1b202556754083c0141c839d45bc5c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BenchmarkTask implements\n        ParallelTaskRunner.TaskWithException<VariantAnnotation, Pair<VariantAnnotationDiff, VariantAnnotationDiff>, Exception> {\n    private FastaIndexManager fastaIndexManager;\n    private static final String VARIANT_STRING_PATTERN = \"[ACGT]*\";\n//    private static final String VARIANT_STRING_PATTERN = \"([ACGT]*)|(<CNV>)|(<INV>)|(<DEL>)|(<INS>)|(<DUP:TANDEM>)\";\n    private VariantAnnotator variantAnnotator;\n    public BenchmarkTask(VariantAnnotator variantAnnotator, FastaIndexManager fastaIndexManager) {\n        this.variantAnnotator = variantAnnotator;\n        this.fastaIndexManager = fastaIndexManager;\n    }\n    public void pre() {\n        variantAnnotator.open();\n    }\n    public List<Pair<VariantAnnotationDiff, VariantAnnotationDiff>> apply(List<VariantAnnotation> batch)\n            throws Exception {\n        // VEP format does not include the reference allele. It's needed for the benchmark if the cache is activated -\n        // otherwise VariantAnnotationCalculator wont find most of the variants in the variation collection\n        fixReference(batch);\n        removeInvalidVariants(batch);\n        List<Variant> cellBaseBatch = createEmptyVariantList(batch);\n        variantAnnotator.run(cellBaseBatch);\n        List<Pair<VariantAnnotationDiff, VariantAnnotationDiff>> comparisonResultList = new ArrayList<>();\n        for (int i = 0; i < batch.size(); i++) {\n            // Variants such as MT:453:TTT:ATT are skipped for the benchmark - will not have CellBase annotation\n            // compatible with VEP annotation and therefore consequenceTypeList = null\n            if (batch.get(i).getConsequenceTypes() != null && batch.get(i).getConsequenceTypes().size() > 0\n                    && cellBaseBatch.get(i).getAnnotation().getConsequenceTypes() != null\n                    && cellBaseBatch.get(i).getAnnotation().getConsequenceTypes().size() > 0) {\n                Pair<VariantAnnotationDiff, VariantAnnotationDiff> comparisonResult = compare(batch.get(i),\n                        cellBaseBatch.get(i).getAnnotation());\n                comparisonResult.getLeft().setVariantAnnotation(batch.get(i));\n                comparisonResult.getRight().setVariantAnnotation(cellBaseBatch.get(i).getAnnotation());\n                comparisonResultList.add(comparisonResult);\n            }\n        }\n        return comparisonResultList;\n    }\n    private void fixReference(List<VariantAnnotation> variantAnnotationList) throws RocksDBException {\n        for (VariantAnnotation variantAnnotation : variantAnnotationList) {\n            if (!variantAnnotation.getReference().isEmpty() && !variantAnnotation.getReference().equals(\"-\")) {\n                variantAnnotation.setReference(fastaIndexManager.query(variantAnnotation.getChromosome(),\n                        variantAnnotation.getStart(), variantAnnotation.getStart()\n                                + variantAnnotation.getReference().length() - 1));\n            }\n        }\n    }\n    private void removeInvalidVariants(List<VariantAnnotation> variantAnnotationList) {\n        int i = 0;\n        while (i < variantAnnotationList.size()) {\n            if (isValid(variantAnnotationList.get(i))) {\n                i++;\n            } else {\n                variantAnnotationList.remove(i);\n            }\n        }\n    }\n    /**\n     * Checks whether a variant is valid.\n     *\n     * @param variantAnnotation Variant object to be checked.\n     * @return   true/false depending on whether 'variant' does contain valid values. Currently just a simple check of\n     * reference/alternate attributes being strings of [A,C,G,T] of length >= 0 is performed to detect cases such as\n     * 19:13318673:(CAG)4:(CAG)5 which are not currently supported by CellBase. Ref and alt alleles must be different\n     * as well for the variant to be valid. Functionality of the method may be improved in the future.\n     */\n    private boolean isValid(VariantAnnotation variantAnnotation) {\n        return (variantAnnotation.getAlternate().matches(VARIANT_STRING_PATTERN)\n//                && variantAnnotation.getReferenceStart().matches(VARIANT_STRING_PATTERN)\n                && !variantAnnotation.getAlternate().equals(variantAnnotation.getReference()));\n    }\n    private Pair<VariantAnnotationDiff, VariantAnnotationDiff> compare(VariantAnnotation variant1, VariantAnnotation variant2) {\n        Pair<VariantAnnotationDiff, VariantAnnotationDiff> result\n                = Pair.of(new VariantAnnotationDiff(), new VariantAnnotationDiff());\n        compareSequenceOntologyTerms(result, variant1.getConsequenceTypes(),\n                variant2.getConsequenceTypes());\n        return result;\n    }\n    private void compareSequenceOntologyTerms(Pair<VariantAnnotationDiff, VariantAnnotationDiff> result,\n                                              List<ConsequenceType> consequenceTypeList1,\n                                              List<ConsequenceType> consequenceTypeList2) {\n        Set<SequenceOntologyTermComparisonObject> sequenceOntologySet1 = getSequenceOntologySet(consequenceTypeList1);\n        Set<SequenceOntologyTermComparisonObject> sequenceOntologySet2 = getSequenceOntologySet(consequenceTypeList2);\n        Set<SequenceOntologyTermComparisonObject> sequenceOntologySet1bak = new HashSet<>(sequenceOntologySet1);\n        sequenceOntologySet1.removeAll(sequenceOntologySet2);\n        sequenceOntologySet2.removeAll(sequenceOntologySet1bak);\n        if (sequenceOntologySet1.size() > 0) {\n            result.getLeft().setSequenceOntology(new ArrayList(sequenceOntologySet1));\n        }\n        if (sequenceOntologySet2.size() > 0) {\n            result.getRight().setSequenceOntology(new ArrayList(sequenceOntologySet2));\n        }\n    }\n    private Set<SequenceOntologyTermComparisonObject> getSequenceOntologySet(List<ConsequenceType> consequenceTypeList) {\n        if (consequenceTypeList != null) {\n            Set<SequenceOntologyTermComparisonObject> set = new HashSet<>(consequenceTypeList.size());\n            for (ConsequenceType consequenceType : consequenceTypeList) {\n                for (SequenceOntologyTerm sequenceOntologyTerm : consequenceType.getSequenceOntologyTerms()) {\n//                    // Expected many differences depending on the regulatory source databases used by the annotators.\n//                    // Better skip regulatory_region_variant annotations\n//                    if (!(sequenceOntologyTerm.getName().equals(VariantAnnotationUtils.REGULATORY_REGION_VARIANT)\n//                            || sequenceOntologyTerm.getName().equals(VariantAnnotationUtils.TF_BINDING_SITE_VARIANT))) {\n                    set.add(new SequenceOntologyTermComparisonObject(consequenceType.getEnsemblTranscriptId(),\n                            sequenceOntologyTerm));\n//                    }\n                }\n            }\n            return set;\n        } else {\n            return null;\n        }\n    }\n    private List<Variant> createEmptyVariantList(List<VariantAnnotation> variantAnnotationList) {\n        List<Variant> newVariantList = new ArrayList<>(variantAnnotationList.size());\n        for (VariantAnnotation variantAnnotation : variantAnnotationList) {\n            Variant variant = new Variant(variantAnnotation.getChromosome(), variantAnnotation.getStart(),\n                    variantAnnotation.getEnd(), variantAnnotation.getReference(), variantAnnotation.getAlternate());\n            variant.resetType();\n            variant.resetLength();\n            newVariantList.add(variant);\n        }\n        return newVariantList;\n    }\n    public void post() {\n        variantAnnotator.close();\n    }\n"]]}
{"hexsha": "d2d456aa7424232cdf56ff5880dc8e920f1cc9a1", "ext": "java", "lang": "Java", "content": "public class AddLibraryUtility {\n    static final String FILE_SUFFIX = \".jar\";\n\n    static void addLibraryRoot(File file, Library.ModifiableModel libraryModel) {\n        if (file.isFile()) {\n            libraryModel.addRoot(VfsUtil.getUrlForLibraryRoot(file), OrderRootType.CLASSES);\n        } else {\n            for (File file0 : file.listFiles()) {\n                addLibraryRoot(file0, libraryModel);\n            }\n        }\n    }\n\n    static void addLibraryFiles(File file, Library.ModifiableModel libraryModel, String[] files) {\n        List filesList = Arrays.asList(files);\n        for (File file0 : file.listFiles()) {\n            if (filesList.contains(extractArtifactName(file0.getName()).toLowerCase())) {\n                addLibraryRoot(file0, libraryModel);\n            }\n        }\n    }\n\n    static String extractArtifactName(String nameWithVersion) {\n        if (nameWithVersion == null) {\n            return \"\";\n        }\n        nameWithVersion = nameWithVersion.trim();\n        if (!nameWithVersion.endsWith(FILE_SUFFIX)){\n            return nameWithVersion;\n        }\n\n        nameWithVersion = nameWithVersion.substring(0, nameWithVersion.length() - FILE_SUFFIX.length());\n        int index = nameWithVersion.indexOf('.');\n        if (index < 0) {\n            return nameWithVersion;\n        }\n\n        String artifactName = nameWithVersion;\n\n        int lastIndex = nameWithVersion.lastIndexOf('-');\n        while (lastIndex > index) {\n            nameWithVersion = nameWithVersion.substring(0, lastIndex);\n            lastIndex = nameWithVersion.lastIndexOf('-');\n        }\n\n        if (lastIndex < 0) {\n            return artifactName;\n        }\n\n        artifactName = nameWithVersion.substring(0, lastIndex);\n        return artifactName;\n    }\n}", "class_id": 0, "repo": "cyberstormdotmu/azure-tools-for-java", "file": "PluginsAndFeatures/azure-toolkit-for-intellij/src/main/java/com/microsoft/intellij/ui/libraries/AddLibraryUtility.java", "last_update_at": "2019-04-23T14:41:48+00:00", "question_id": "d2d456aa7424232cdf56ff5880dc8e920f1cc9a1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AddLibraryUtility {\n    static final String FILE_SUFFIX = \".jar\";\n    static void addLibraryRoot(File file, Library.ModifiableModel libraryModel) {\n        if (file.isFile()) {\n            libraryModel.addRoot(VfsUtil.getUrlForLibraryRoot(file), OrderRootType.CLASSES);\n        } else {\n            for (File file0 : file.listFiles()) {\n                addLibraryRoot(file0, libraryModel);\n            }\n        }\n    }\n    static void addLibraryFiles(File file, Library.ModifiableModel libraryModel, String[] files) {\n        List filesList = Arrays.asList(files);\n        for (File file0 : file.listFiles()) {\n            if (filesList.contains(extractArtifactName(file0.getName()).toLowerCase())) {\n                addLibraryRoot(file0, libraryModel);\n            }\n        }\n    }\n    static String extractArtifactName(String nameWithVersion) {\n        if (nameWithVersion == null) {\n            return \"\";\n        }\n        nameWithVersion = nameWithVersion.trim();\n        if (!nameWithVersion.endsWith(FILE_SUFFIX)){\n            return nameWithVersion;\n        }\n        nameWithVersion = nameWithVersion.substring(0, nameWithVersion.length() - FILE_SUFFIX.length());\n        int index = nameWithVersion.indexOf('.');\n        if (index < 0) {\n            return nameWithVersion;\n        }\n        String artifactName = nameWithVersion;\n        int lastIndex = nameWithVersion.lastIndexOf('-');\n        while (lastIndex > index) {\n            nameWithVersion = nameWithVersion.substring(0, lastIndex);\n            lastIndex = nameWithVersion.lastIndexOf('-');\n        }\n        if (lastIndex < 0) {\n            return artifactName;\n        }\n        artifactName = nameWithVersion.substring(0, lastIndex);\n        return artifactName;\n    }\n"]]}
{"hexsha": "e461a59a52c86242f753f9940655bde177768b38", "ext": "java", "lang": "Java", "content": "public class Dungeon {\n\n    \n    private int length, height, vampires, moves;\n    private final boolean vampiresMove;\n    private List<Vampire> vampireList  = new ArrayList<Vampire>();\n    private Random random = new Random();\n    private Player player = new Player();\n    private Scanner input = new Scanner(System.in);\n    \n     public Dungeon(int length, int height, int vampires, int moves, boolean vampiresMove) {\n        this.length=length;\n        this.height=height;\n        this.vampires=vampires;\n        this.moves=moves;\n        this.vampiresMove=vampiresMove;\n     }\n     \n \n     \n     private void printVampires() {\n        for(Vampire vampire : vampireList) {\n                 System.out.println(vampire);\n             }\n             System.out.println(\"\");\n     \n     }\n     \n     private void createVampires() {\n         \n         for(int i=0;i<this.vampires;i++) {\n                \n                int x = this.random.nextInt(this.length);\n                int y = this.random.nextInt(this.height);\n             \n                if(this.VampireAt(x, y) || this.player.isAt(x, y)) {\n                x = this.random.nextInt(this.length);\n                y = this.random.nextInt(this.height);\n                this.vampireList.add(new Vampire(x,y));\n                }\n                \n                else this.vampireList.add(new Vampire(x,y));\n                \n        }\n\n     }\n     \n     private void printMap() {\n         \n         for(int y=0;y<this.height;y++) {\n         \n             for(int x=0;x<this.length;x++) {\n                 if(this.player.isAt(x,y)) System.out.print(\"@\");\n                 else if(this.VampireAt(x,y)) System.out.print(\"v\");\n                 else System.out.print(\".\");  \n             \n             }\n             System.out.println(\"\");\n\n         }\n         System.out.println(\"\");\n         \n     }\n     \n     private void randomize() {\n         for(Vampire vampire : vampireList) {\n             int x = this.random.nextInt(this.length);\n             int y = this.random.nextInt(this.height);\n             \n             if(this.VampireAt(x, y) || this.player.isAt(x, y)) {\n                x = this.random.nextInt(this.length);\n                y = this.random.nextInt(this.height);\n                vampire.setX(x);\n                vampire.setY(y);\n                }\n             \n             \n             else{\n             vampire.setX(x);\n             vampire.setY(y);\n                     }\n         }\n     }\n     \n    \n     private boolean VampireAt(int x, int y) {\n        for(Vampire vampire : vampireList) {\n            if(vampire.getX()==x && vampire.getY()==y) return true;\n        }\n        return false;\n    }\n    \n     \n     private void action(String command) {\n     \n         ArrayList<Vampire> killed = new ArrayList<Vampire>();\n         \n         for(int position=0;position<command.length();position++) {\n             char letter = command.charAt(position);\n             this.player.move(letter);\n             if(player.getX()>=this.length) player.setX(this.length-1);\n             if(player.getY()>=this.height) player.setY(this.height-1);\n             if(player.getX()<0) player.setX(0);\n             if(player.getY()<0) player.setY(0);\n                        for(Vampire vampire : vampireList) {\n                        if(vampire.getX()==this.player.getX() && vampire.getY()==this.player.getY()) {\n                killed.add(vampire);\n            }\n        }\n                \n             \n         }\n         \n         \n         this.vampireList.removeAll(killed);\n     \n     }\n     \n     \n     public void run() {\n     \n         this.createVampires();\n\n         while(moves>0) {\n             System.out.println(this.moves + \"\\n\");\n             System.out.println(\"@ \" + player.getX() + \" \" + player.getY());\n             this.printVampires();\n             this.printMap();\n         \n             String command = input.nextLine();\n             this.action(command);\n             \n             if(this.vampireList.isEmpty()) {\n                 System.out.println(\"YOU WIN\");\n                 break;\n             }\n             \n             if(vampiresMove) this.randomize();\n             moves--;\n         }\n     \n         if(moves==0) System.out.println(\"YOU LOSE\");\n         \n         \n     \n     }\n \n    \n}", "class_id": 0, "repo": "SreekVed/vampire-dungeon", "file": "src/dungeon/Dungeon.java", "last_update_at": "2019-08-15T08:18:15+00:00", "question_id": "e461a59a52c86242f753f9940655bde177768b38", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Dungeon {\n    private int length, height, vampires, moves;\n    private final boolean vampiresMove;\n    private List<Vampire> vampireList  = new ArrayList<Vampire>();\n    private Random random = new Random();\n    private Player player = new Player();\n    private Scanner input = new Scanner(System.in);\n     public Dungeon(int length, int height, int vampires, int moves, boolean vampiresMove) {\n        this.length=length;\n        this.height=height;\n        this.vampires=vampires;\n        this.moves=moves;\n        this.vampiresMove=vampiresMove;\n     }\n     private void printVampires() {\n        for(Vampire vampire : vampireList) {\n                 System.out.println(vampire);\n             }\n             System.out.println(\"\");\n     }\n     private void createVampires() {\n         for(int i=0;i<this.vampires;i++) {\n                int x = this.random.nextInt(this.length);\n                int y = this.random.nextInt(this.height);\n                if(this.VampireAt(x, y) || this.player.isAt(x, y)) {\n                x = this.random.nextInt(this.length);\n                y = this.random.nextInt(this.height);\n                this.vampireList.add(new Vampire(x,y));\n                }\n                else this.vampireList.add(new Vampire(x,y));\n        }\n     }\n     private void printMap() {\n         for(int y=0;y<this.height;y++) {\n             for(int x=0;x<this.length;x++) {\n                 if(this.player.isAt(x,y)) System.out.print(\"@\");\n                 else if(this.VampireAt(x,y)) System.out.print(\"v\");\n                 else System.out.print(\".\");  \n             }\n             System.out.println(\"\");\n         }\n         System.out.println(\"\");\n     }\n     private void randomize() {\n         for(Vampire vampire : vampireList) {\n             int x = this.random.nextInt(this.length);\n             int y = this.random.nextInt(this.height);\n             if(this.VampireAt(x, y) || this.player.isAt(x, y)) {\n                x = this.random.nextInt(this.length);\n                y = this.random.nextInt(this.height);\n                vampire.setX(x);\n                vampire.setY(y);\n                }\n             else{\n             vampire.setX(x);\n             vampire.setY(y);\n                     }\n         }\n     }\n     private boolean VampireAt(int x, int y) {\n        for(Vampire vampire : vampireList) {\n            if(vampire.getX()==x && vampire.getY()==y) return true;\n        }\n        return false;\n    }\n     private void action(String command) {\n         ArrayList<Vampire> killed = new ArrayList<Vampire>();\n         for(int position=0;position<command.length();position++) {\n             char letter = command.charAt(position);\n             this.player.move(letter);\n             if(player.getX()>=this.length) player.setX(this.length-1);\n             if(player.getY()>=this.height) player.setY(this.height-1);\n             if(player.getX()<0) player.setX(0);\n             if(player.getY()<0) player.setY(0);\n                        for(Vampire vampire : vampireList) {\n                        if(vampire.getX()==this.player.getX() && vampire.getY()==this.player.getY()) {\n                killed.add(vampire);\n            }\n        }\n         }\n         this.vampireList.removeAll(killed);\n     }\n     public void run() {\n         this.createVampires();\n         while(moves>0) {\n             System.out.println(this.moves + \"\\n\");\n             System.out.println(\"@ \" + player.getX() + \" \" + player.getY());\n             this.printVampires();\n             this.printMap();\n             String command = input.nextLine();\n             this.action(command);\n             if(this.vampireList.isEmpty()) {\n                 System.out.println(\"YOU WIN\");\n                 break;\n             }\n             if(vampiresMove) this.randomize();\n             moves--;\n         }\n         if(moves==0) System.out.println(\"YOU LOSE\");\n     }\n"]]}
{"hexsha": "67a8266acd0822f3d2b268eb97986ed1ad00c464", "ext": "java", "lang": "Java", "content": "class Utils {\n    static void main() {\n        A a = new A();\n        a.a = 248;\n        a.b = 233;\n        a.printIntegersBetweenTwoValues();\n        a.printDivisorsOfA();\n        a.printPrimeDivisorsOfB();\n        System.out.println(String.format(\"The most frequent digit of b (%d) is: %d\", a.b, a.getTheMostFrequentDigitOfB()));\n\n        B b = new B();\n        b._a(-100, 100);\n        b._b(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        b.printThreeRandomIntegersBetweenTwoValues();\n        b.printThreeMultiplesOfA();\n        b.printEveryIntegerCreatedFromTheDigitsOfB();\n        b.getMaximumDigitOfB();\n    }\n}", "class_id": 0, "repo": "GiorgiBeriashvili/java-group-2", "file": "classwork/classwork-04/src/dev/beriashvili/classwork/lab_console_04_03/Utils.java", "last_update_at": "2019-10-26T18:28:26+00:00", "question_id": "67a8266acd0822f3d2b268eb97986ed1ad00c464", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Utils {\n    static void main() {\n        A a = new A();\n        a.a = 248;\n        a.b = 233;\n        a.printIntegersBetweenTwoValues();\n        a.printDivisorsOfA();\n        a.printPrimeDivisorsOfB();\n        System.out.println(String.format(\"The most frequent digit of b (%d) is: %d\", a.b, a.getTheMostFrequentDigitOfB()));\n        B b = new B();\n        b._a(-100, 100);\n        b._b(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        b.printThreeRandomIntegersBetweenTwoValues();\n        b.printThreeMultiplesOfA();\n        b.printEveryIntegerCreatedFromTheDigitsOfB();\n        b.getMaximumDigitOfB();\n    }\n"]]}
{"hexsha": "ba1a3bb4c200131d37bc07151571ef2c0b6854e5", "ext": "java", "lang": "Java", "content": "public class TestCaseMain {\n\n    private static final int DELAY_TIME = 50;\n\n    private static ScriptEngine engine;\n\n    private static ExecutionEventManager eventManager;\n\n    /**\n     * Setup test case or test suite before executing.\n     *\n     * CustomKeywords now has many custom keyword static methods, each one is\n     * named with format [packageName].[className].[keywordName] but Groovy compiler\n     * itself cannot invoke that formatted name. Therefore, we must change the\n     * meta class of CustomKeywords to another one.\n     * \n     * @throws IOException\n     */\n    public static void beforeStart() throws IOException {\n        LogbackConfigurator.init();\n        \n        GroovyClassLoader classLoader = new GroovyClassLoader(TestCaseMain.class.getClassLoader());\n        engine = ScriptEngine.getDefault(classLoader);\n\n        // Load GlobalVariable class\n//        loadGlobalVariableClass(classLoader);\n//        loadInternalGlobalVariableClass(classLoader);\n        loadCustomKeywordsClass(classLoader);\n\n        eventManager = ExecutionEventManager.getInstance();\n    }\n\n    private static void loadCustomKeywordsClass(GroovyClassLoader cl) {\n        // Load CustomKeywords class\n        Class<?> clazz = cl.parseClass(\"class CustomKeywords { }\");\n        InvokerHelper.metaRegistry.setMetaClass(clazz, new CustomKeywordDelegatingMetaClass(clazz, cl));\n    }\n\n    private static void loadGlobalVariableClass(GroovyClassLoader cl) {\n        try {\n            cl.loadClass(StringConstants.GLOBAL_VARIABLE_CLASS_NAME);\n        } catch (ClassNotFoundException ex) {\n            try {\n                cl.parseClass(new File(RunConfiguration.getProjectDir(), StringConstants.GLOBAL_VARIABLE_FILE_NAME));\n            } catch (CompilationFailedException | IOException ignored) {\n\n            }\n        }\n    }\n    \n    private static void loadInternalGlobalVariableClass(GroovyClassLoader cl) {\n        try {\n            cl.loadClass(StringConstants.INTERNAL_GLOBAL_VARIABLE_CLASS_NAME);\n        } catch (ClassNotFoundException ex) {\n            try {\n                cl.parseClass(new File(RunConfiguration.getProjectDir(), StringConstants.INTERNAL_GLOBAL_VARIABLE_FILE_NAME));\n            } catch (CompilationFailedException | IOException ignored) {\n\n            }\n        }\n    }\n    public static TestResult runTestCase(String testCaseId, TestCaseBinding testCaseBinding,\n            FailureHandling flowControl) throws InterruptedException {\n        return runTestCase(testCaseId, testCaseBinding, flowControl, true, true);\n    }\n\n    public static TestResult runTestCase(String testCaseId, TestCaseBinding testCaseBinding,\n            FailureHandling flowControl, boolean doCleanUp) throws InterruptedException {\n        return runTestCase(testCaseId, testCaseBinding, flowControl, true, doCleanUp);\n    }\n\n    public static TestResult runTestCase(String testCaseId, TestCaseBinding testCaseBinding,\n            FailureHandling flowControl, boolean isMain, boolean doCleanUp) throws InterruptedException {\n        Thread.sleep(DELAY_TIME);\n        InternalTestCaseContext testCaseContext = new InternalTestCaseContext(testCaseId);\n        testCaseContext.setMainTestCase(isMain);\n        return new TestCaseExecutor(testCaseBinding, engine, eventManager, testCaseContext, doCleanUp)\n                .execute(flowControl);\n    }\n    \n    public static TestResult runWSVerificationScript(String verificationScript, FailureHandling flowControl,\n            boolean doCleanUp) throws InterruptedException {\n        Thread.sleep(DELAY_TIME);\n        return new WSVerificationExecutor(verificationScript, engine, eventManager, doCleanUp).execute(flowControl);\n    }\n\n    public static TestResult runWSVerificationScript(TestCaseBinding testCaseBinding, String verificationScript,\n            FailureHandling flowControl, boolean doCleanUp) throws InterruptedException {\n        Thread.sleep(DELAY_TIME);\n        return new WSVerificationExecutor(testCaseBinding, verificationScript, engine, eventManager, doCleanUp)\n                .execute(flowControl);\n    }\n\n    public static TestResult runTestCaseRawScript(String testScript, String testCaseId, TestCaseBinding testCaseBinding,\n            FailureHandling flowControl) throws InterruptedException {\n        Thread.sleep(DELAY_TIME);\n        return new RawTestScriptExecutor(testScript, testCaseBinding, engine, eventManager,\n                new InternalTestCaseContext(testCaseId)).execute(flowControl);\n    }\n\n    public static TestResult runFeatureFile(String featureFile) throws InterruptedException {\n        Thread.sleep(DELAY_TIME);\n        String verificationScript = MessageFormat\n                .format(\"import com.kms.katalon.core.cucumber.keyword.CucumberBuiltinKeywords as CucumberKW\\n\" +\n\n                        \"CucumberKW.runFeatureFile(''{0}'')\", featureFile);\n        return new WSVerificationExecutor(verificationScript, engine, eventManager, true)\n                .execute(FailureHandling.STOP_ON_FAILURE);\n    }\n\n    public static TestResult runTestCaseRawScript(String testScript, String testCaseId, TestCaseBinding testCaseBinding,\n            FailureHandling flowControl, boolean doCleanUp) throws InterruptedException {\n        Thread.sleep(DELAY_TIME);\n        return new RawTestScriptExecutor(testScript, testCaseBinding, engine, eventManager,\n                new InternalTestCaseContext(testCaseId), doCleanUp).execute(flowControl);\n    }\n\n    public static void startTestSuite(String testSuiteId, Map<String, String> suiteProperties,\n            List<TestCaseBinding> testCaseBindings) {\n        TestSuiteExecutor testSuiteExecutor = new TestSuiteExecutor(testSuiteId, engine, eventManager);\n        testSuiteExecutor.execute(suiteProperties, testCaseBindings);\n    }\n\n    public static void invokeStartSuite(String testSuiteId) {\n        InternalTestSuiteContext testSuiteContext = new InternalTestSuiteContext();\n        testSuiteContext.setTestSuiteId(testSuiteId);\n        eventManager.publicEvent(ExecutionListenerEvent.BEFORE_TEST_SUITE, new Object[] { testSuiteContext });\n    }\n\n    public static void invokeEndSuite(String testSuiteId) {\n        InternalTestSuiteContext testSuiteContext = new InternalTestSuiteContext();\n        testSuiteContext.setTestSuiteId(testSuiteId);\n\n        eventManager.publicEvent(ExecutionListenerEvent.AFTER_TEST_SUITE, new Object[] { testSuiteContext });\n    }\n\n    public static ScriptEngine getScriptEngine() {\n        return engine;\n    }\n}", "class_id": 0, "repo": "rosiecorn/katalon-studio-testing-framework", "file": "Include/scripts/groovy/com/kms/katalon/core/main/TestCaseMain.java", "last_update_at": "2019-03-03T06:48:23+00:00", "question_id": "ba1a3bb4c200131d37bc07151571ef2c0b6854e5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestCaseMain {\n    private static final int DELAY_TIME = 50;\n    private static ScriptEngine engine;\n    private static ExecutionEventManager eventManager;\n    /**\n     * Setup test case or test suite before executing.\n     *\n     * CustomKeywords now has many custom keyword static methods, each one is\n     * named with format [packageName].[className].[keywordName] but Groovy compiler\n     * itself cannot invoke that formatted name. Therefore, we must change the\n     * meta class of CustomKeywords to another one.\n     * \n     * @throws IOException\n     */\n    public static void beforeStart() throws IOException {\n        LogbackConfigurator.init();\n        GroovyClassLoader classLoader = new GroovyClassLoader(TestCaseMain.class.getClassLoader());\n        engine = ScriptEngine.getDefault(classLoader);\n        // Load GlobalVariable class\n//        loadGlobalVariableClass(classLoader);\n//        loadInternalGlobalVariableClass(classLoader);\n        loadCustomKeywordsClass(classLoader);\n        eventManager = ExecutionEventManager.getInstance();\n    }\n    private static void loadCustomKeywordsClass(GroovyClassLoader cl) {\n        // Load CustomKeywords class\n        Class<?> clazz = cl.parseClass(\"class CustomKeywords { }\");\n        InvokerHelper.metaRegistry.setMetaClass(clazz, new CustomKeywordDelegatingMetaClass(clazz, cl));\n    }\n    private static void loadGlobalVariableClass(GroovyClassLoader cl) {\n        try {\n            cl.loadClass(StringConstants.GLOBAL_VARIABLE_CLASS_NAME);\n        } catch (ClassNotFoundException ex) {\n            try {\n                cl.parseClass(new File(RunConfiguration.getProjectDir(), StringConstants.GLOBAL_VARIABLE_FILE_NAME));\n            } catch (CompilationFailedException | IOException ignored) {\n            }\n        }\n    }\n    private static void loadInternalGlobalVariableClass(GroovyClassLoader cl) {\n        try {\n            cl.loadClass(StringConstants.INTERNAL_GLOBAL_VARIABLE_CLASS_NAME);\n        } catch (ClassNotFoundException ex) {\n            try {\n                cl.parseClass(new File(RunConfiguration.getProjectDir(), StringConstants.INTERNAL_GLOBAL_VARIABLE_FILE_NAME));\n            } catch (CompilationFailedException | IOException ignored) {\n            }\n        }\n    }\n    public static TestResult runTestCase(String testCaseId, TestCaseBinding testCaseBinding,\n            FailureHandling flowControl) throws InterruptedException {\n        return runTestCase(testCaseId, testCaseBinding, flowControl, true, true);\n    }\n    public static TestResult runTestCase(String testCaseId, TestCaseBinding testCaseBinding,\n            FailureHandling flowControl, boolean doCleanUp) throws InterruptedException {\n        return runTestCase(testCaseId, testCaseBinding, flowControl, true, doCleanUp);\n    }\n    public static TestResult runTestCase(String testCaseId, TestCaseBinding testCaseBinding,\n            FailureHandling flowControl, boolean isMain, boolean doCleanUp) throws InterruptedException {\n        Thread.sleep(DELAY_TIME);\n        InternalTestCaseContext testCaseContext = new InternalTestCaseContext(testCaseId);\n        testCaseContext.setMainTestCase(isMain);\n        return new TestCaseExecutor(testCaseBinding, engine, eventManager, testCaseContext, doCleanUp)\n                .execute(flowControl);\n    }\n    public static TestResult runWSVerificationScript(String verificationScript, FailureHandling flowControl,\n            boolean doCleanUp) throws InterruptedException {\n        Thread.sleep(DELAY_TIME);\n        return new WSVerificationExecutor(verificationScript, engine, eventManager, doCleanUp).execute(flowControl);\n    }\n    public static TestResult runWSVerificationScript(TestCaseBinding testCaseBinding, String verificationScript,\n            FailureHandling flowControl, boolean doCleanUp) throws InterruptedException {\n        Thread.sleep(DELAY_TIME);\n        return new WSVerificationExecutor(testCaseBinding, verificationScript, engine, eventManager, doCleanUp)\n                .execute(flowControl);\n    }\n    public static TestResult runTestCaseRawScript(String testScript, String testCaseId, TestCaseBinding testCaseBinding,\n            FailureHandling flowControl) throws InterruptedException {\n        Thread.sleep(DELAY_TIME);\n        return new RawTestScriptExecutor(testScript, testCaseBinding, engine, eventManager,\n                new InternalTestCaseContext(testCaseId)).execute(flowControl);\n    }\n    public static TestResult runFeatureFile(String featureFile) throws InterruptedException {\n        Thread.sleep(DELAY_TIME);\n        String verificationScript = MessageFormat\n                .format(\"import com.kms.katalon.core.cucumber.keyword.CucumberBuiltinKeywords as CucumberKW\\n\" +\n                        \"CucumberKW.runFeatureFile(''{0}'')\", featureFile);\n        return new WSVerificationExecutor(verificationScript, engine, eventManager, true)\n                .execute(FailureHandling.STOP_ON_FAILURE);\n    }\n    public static TestResult runTestCaseRawScript(String testScript, String testCaseId, TestCaseBinding testCaseBinding,\n            FailureHandling flowControl, boolean doCleanUp) throws InterruptedException {\n        Thread.sleep(DELAY_TIME);\n        return new RawTestScriptExecutor(testScript, testCaseBinding, engine, eventManager,\n                new InternalTestCaseContext(testCaseId), doCleanUp).execute(flowControl);\n    }\n    public static void startTestSuite(String testSuiteId, Map<String, String> suiteProperties,\n            List<TestCaseBinding> testCaseBindings) {\n        TestSuiteExecutor testSuiteExecutor = new TestSuiteExecutor(testSuiteId, engine, eventManager);\n        testSuiteExecutor.execute(suiteProperties, testCaseBindings);\n    }\n    public static void invokeStartSuite(String testSuiteId) {\n        InternalTestSuiteContext testSuiteContext = new InternalTestSuiteContext();\n        testSuiteContext.setTestSuiteId(testSuiteId);\n        eventManager.publicEvent(ExecutionListenerEvent.BEFORE_TEST_SUITE, new Object[] { testSuiteContext });\n    }\n    public static void invokeEndSuite(String testSuiteId) {\n        InternalTestSuiteContext testSuiteContext = new InternalTestSuiteContext();\n        testSuiteContext.setTestSuiteId(testSuiteId);\n        eventManager.publicEvent(ExecutionListenerEvent.AFTER_TEST_SUITE, new Object[] { testSuiteContext });\n    }\n    public static ScriptEngine getScriptEngine() {\n        return engine;\n    }\n"]]}
{"hexsha": "f3590d6a195db9a59a3e060d92da68cfcf7b9700", "ext": "java", "lang": "Java", "content": "public class JoystickCommandPair {\n\n    // A button from the operator interface\n    private JoystickButton button;\n    \n    // Contains the details about the command that you are binding to the button\n    private CommandDetails commandDetails;\n \n    // Instance of a ControlsProcessor \n    private ControlsProcessor controlsProcessor;\n\n    // Save previous state to call only when on edge.\n    private boolean lastState = false;\n\n    /**\n     * @param controlsProcessor The current ControlsProcessor object in reference\n     * @param commandInput The whole command string appended\n     * @param buttonToPair The button to pair the command with\n     */\n    public JoystickCommandPair(ControlsProcessor controlsProcessor, String commandInput, JoystickButton buttonToPair) {\n        this.button = buttonToPair;\n        this.commandDetails = new CommandDetails(commandInput);\n        this.controlsProcessor = controlsProcessor;\n    }\n\n    /**\n     * Called periodically to check for button edges \n     */\n    public void checkButton() {\n        boolean currentState = this.button.get();\n\n        if (currentState && !this.lastState) {\n            controlsProcessor.callCommand(this.commandDetails);\n        }\n\n        if (!currentState && this.lastState && this.commandDetails.type() == \n            CommandDetails.CommandType.SERIES) {\n            controlsProcessor.cancelCommand(this.commandDetails);\n        }\n\n        this.lastState = currentState;\n    }\n}", "class_id": 0, "repo": "FRC2714/2019Competition", "file": "src/main/java/frc/robot/util/JoystickCommandPair.java", "last_update_at": "2019-01-10T20:06:34+00:00", "question_id": "f3590d6a195db9a59a3e060d92da68cfcf7b9700", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class JoystickCommandPair {\n    // A button from the operator interface\n    private JoystickButton button;\n    // Contains the details about the command that you are binding to the button\n    private CommandDetails commandDetails;\n    // Instance of a ControlsProcessor \n    private ControlsProcessor controlsProcessor;\n    // Save previous state to call only when on edge.\n    private boolean lastState = false;\n    /**\n     * @param controlsProcessor The current ControlsProcessor object in reference\n     * @param commandInput The whole command string appended\n     * @param buttonToPair The button to pair the command with\n     */\n    public JoystickCommandPair(ControlsProcessor controlsProcessor, String commandInput, JoystickButton buttonToPair) {\n        this.button = buttonToPair;\n        this.commandDetails = new CommandDetails(commandInput);\n        this.controlsProcessor = controlsProcessor;\n    }\n    /**\n     * Called periodically to check for button edges \n     */\n    public void checkButton() {\n        boolean currentState = this.button.get();\n        if (currentState && !this.lastState) {\n            controlsProcessor.callCommand(this.commandDetails);\n        }\n        if (!currentState && this.lastState && this.commandDetails.type() == \n            CommandDetails.CommandType.SERIES) {\n            controlsProcessor.cancelCommand(this.commandDetails);\n        }\n        this.lastState = currentState;\n    }\n"]]}
{"hexsha": "a147692ec63231ffaccb5802b20459728690725b", "ext": "java", "lang": "Java", "content": "@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class IntervalAnalysisStateTest {\n\n  @Test\n  public void pseudoPartiotionKey() {\n    IntervalAnalysisState s = new IntervalAnalysisState();\n    IntervalAnalysisState sa1 = s.addInterval(\"a\", new Interval(1L, 1L), 10);\n    IntervalAnalysisState sb2 = s.addInterval(\"b\", new Interval(2L, 2L), 10);\n    IntervalAnalysisState sa1b2 = sa1.addInterval(\"b\", new Interval(2L, 2L), 10);\n    IntervalAnalysisState sa1b3 = sa1.addInterval(\"b\", new Interval(3L, 3L), 10);\n    IntervalAnalysisState sa1b23 = sa1.addInterval(\"b\", new Interval(2L, 3L), 10);\n\n    Comparable cs = s.getPseudoPartitionKey();\n    Comparable csa1 = sa1.getPseudoPartitionKey();\n    Comparable csb2 = sb2.getPseudoPartitionKey();\n    Comparable csa1b2 = sa1b2.getPseudoPartitionKey();\n    Comparable csa1b3 = sa1b3.getPseudoPartitionKey();\n    Comparable csa1b23 = sa1b23.getPseudoPartitionKey();\n\n    checkEquals(cs, cs);\n    checkEquals(csa1, csa1);\n    checkEquals(csb2, csb2);\n    checkEquals(csa1b2, csa1b2);\n    checkEquals(csa1b3, csa1b3);\n    checkEquals(csa1b23, csa1b23);\n\n    checkEquals(csa1, csb2);\n    checkEquals(csa1b2, csa1b3);\n\n    checkLess(cs, csa1);\n    checkLess(cs, csb2);\n    checkLess(cs, csa1b2);\n    checkLess(cs, csa1b3);\n    checkLess(csa1, csa1b2);\n    checkLess(csa1, csa1b3);\n    checkLess(csb2, csa1b2);\n\n    checkLess(csa1, csa1b23);\n    checkLess(csb2, csa1b23);\n    checkLess(csa1b23, csa1b2);\n    checkLess(csa1b23, csa1b3);\n  }\n\n  private void checkLess(Comparable c1, Comparable c2) {\n    assertThat(c1.compareTo(c2) < 0).isTrue();\n    assertThat(c2.compareTo(c1) > 0).isTrue();\n  }\n\n  private void checkEquals(Comparable c1, Comparable c2) {\n    assertThat(c1.compareTo(c2)).isEqualTo(0);\n    assertThat(c2.compareTo(c1)).isEqualTo(0);\n  }\n}", "class_id": 0, "repo": "melkishengue/cpachecker", "file": "src/org/sosy_lab/cpachecker/cpa/interval/IntervalAnalysisStateTest.java", "last_update_at": "2019-05-23T19:41:59+00:00", "question_id": "a147692ec63231ffaccb5802b20459728690725b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class IntervalAnalysisStateTest {\n  @Test\n  public void pseudoPartiotionKey() {\n    IntervalAnalysisState s = new IntervalAnalysisState();\n    IntervalAnalysisState sa1 = s.addInterval(\"a\", new Interval(1L, 1L), 10);\n    IntervalAnalysisState sb2 = s.addInterval(\"b\", new Interval(2L, 2L), 10);\n    IntervalAnalysisState sa1b2 = sa1.addInterval(\"b\", new Interval(2L, 2L), 10);\n    IntervalAnalysisState sa1b3 = sa1.addInterval(\"b\", new Interval(3L, 3L), 10);\n    IntervalAnalysisState sa1b23 = sa1.addInterval(\"b\", new Interval(2L, 3L), 10);\n    Comparable cs = s.getPseudoPartitionKey();\n    Comparable csa1 = sa1.getPseudoPartitionKey();\n    Comparable csb2 = sb2.getPseudoPartitionKey();\n    Comparable csa1b2 = sa1b2.getPseudoPartitionKey();\n    Comparable csa1b3 = sa1b3.getPseudoPartitionKey();\n    Comparable csa1b23 = sa1b23.getPseudoPartitionKey();\n    checkEquals(cs, cs);\n    checkEquals(csa1, csa1);\n    checkEquals(csb2, csb2);\n    checkEquals(csa1b2, csa1b2);\n    checkEquals(csa1b3, csa1b3);\n    checkEquals(csa1b23, csa1b23);\n    checkEquals(csa1, csb2);\n    checkEquals(csa1b2, csa1b3);\n    checkLess(cs, csa1);\n    checkLess(cs, csb2);\n    checkLess(cs, csa1b2);\n    checkLess(cs, csa1b3);\n    checkLess(csa1, csa1b2);\n    checkLess(csa1, csa1b3);\n    checkLess(csb2, csa1b2);\n    checkLess(csa1, csa1b23);\n    checkLess(csb2, csa1b23);\n    checkLess(csa1b23, csa1b2);\n    checkLess(csa1b23, csa1b3);\n  }\n  private void checkLess(Comparable c1, Comparable c2) {\n    assertThat(c1.compareTo(c2) < 0).isTrue();\n    assertThat(c2.compareTo(c1) > 0).isTrue();\n  }\n  private void checkEquals(Comparable c1, Comparable c2) {\n    assertThat(c1.compareTo(c2)).isEqualTo(0);\n    assertThat(c2.compareTo(c1)).isEqualTo(0);\n  }\n"]]}
{"hexsha": "c018f72b8c8dd46e35e2006e1a493888ae0e9cc6", "ext": "java", "lang": "Java", "content": "@ApplicationScoped\npublic class OpenApiEndpointProducer {\n\n    @Produces\n    @ApplicationScoped\n    DeploymentMetaData deployment() {\n        DeploymentMetaData deployment = new DeploymentMetaData(\"microprofile-openapi\");\n        deployment.setContextPath(\"/openapi\");\n        deployment.addServlet(servlet());\n        deployment.setManagement(true);\n        return deployment;\n    }\n\n    ServletMetaData servlet() {\n        ServletMetaData servlet = new ServletMetaData(\"endpoint\", OpenApiServlet.class);\n        servlet.addUrlPattern(\"/*\");\n        return servlet;\n    }\n}", "class_id": 0, "repo": "thumb-tack/", "file": "core/openapi/src/main/java/io/thorntail/openapi/impl/OpenApiEndpointProducer.java", "last_update_at": "2019-09-23T13:39:49+00:00", "question_id": "c018f72b8c8dd46e35e2006e1a493888ae0e9cc6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ApplicationScoped\npublic class OpenApiEndpointProducer {\n    @Produces\n    @ApplicationScoped\n    DeploymentMetaData deployment() {\n        DeploymentMetaData deployment = new DeploymentMetaData(\"microprofile-openapi\");\n        deployment.setContextPath(\"/openapi\");\n        deployment.addServlet(servlet());\n        deployment.setManagement(true);\n        return deployment;\n    }\n    ServletMetaData servlet() {\n        ServletMetaData servlet = new ServletMetaData(\"endpoint\", OpenApiServlet.class);\n        servlet.addUrlPattern(\"/*\");\n        return servlet;\n    }\n"]]}
{"hexsha": "c3f383db0374dffc761d81751199127be69277d8", "ext": "java", "lang": "Java", "content": "public class AccumuloDeleteSchemaTask extends AbstractTask<String, CoalesceStringResponseType, DataStore> {\n\n    @Override\n    protected CoalesceStringResponseType doWork(TaskParameters<DataStore, String> parameters)\n            throws CoalesceException\n    {\n        CoalesceStringResponseType result = new CoalesceStringResponseType();\n\n        DataStore datastore = parameters.getTarget();\n        String name = parameters.getParams();\n\n        try\n        {\n            datastore.removeSchema(name);\n            result.setStatus(EResultStatus.SUCCESS);\n        }\n        catch (IOException | IllegalArgumentException e)\n        {\n            throw new CoalescePersistorException(String.format(\"(FAILED) Removing Schema: (%s)\", name), e);\n        }\n\n        return result;\n    }\n\n    @Override\n    protected Map<String, String> getParameters(String params, boolean isTrace)\n    {\n        return new HashMap<>();\n    }\n\n    @Override\n    protected CoalesceStringResponseType createResult()\n    {\n        return new CoalesceStringResponseType();\n    }\n}", "class_id": 0, "repo": "InCadence/coalesce", "file": "src/Coalesce.Framework.Persister.Accumulo/src/main/java/com/incadencecorp/coalesce/framework/persistance/accumulo/tasks/AccumuloDeleteSchemaTask.java", "last_update_at": "2019-04-02T15:10:24+00:00", "question_id": "c3f383db0374dffc761d81751199127be69277d8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AccumuloDeleteSchemaTask extends AbstractTask<String, CoalesceStringResponseType, DataStore> {\n    @Override\n    protected CoalesceStringResponseType doWork(TaskParameters<DataStore, String> parameters)\n            throws CoalesceException\n    {\n        CoalesceStringResponseType result = new CoalesceStringResponseType();\n        DataStore datastore = parameters.getTarget();\n        String name = parameters.getParams();\n        try\n        {\n            datastore.removeSchema(name);\n            result.setStatus(EResultStatus.SUCCESS);\n        }\n        catch (IOException | IllegalArgumentException e)\n        {\n            throw new CoalescePersistorException(String.format(\"(FAILED) Removing Schema: (%s)\", name), e);\n        }\n        return result;\n    }\n    @Override\n    protected Map<String, String> getParameters(String params, boolean isTrace)\n    {\n        return new HashMap<>();\n    }\n    @Override\n    protected CoalesceStringResponseType createResult()\n    {\n        return new CoalesceStringResponseType();\n    }\n"]]}
{"hexsha": "730c54a448d63b3a8301ffb2d5d1259527816880", "ext": "java", "lang": "Java", "content": "public class TestGrunt extends TestCase {\n    MiniCluster cluster = MiniCluster.buildCluster();\n\n\t\n\t@Test \n\tpublic void testCopyFromLocal() throws Throwable {\n\t\tPigServer server = new PigServer(ExecType.MAPREDUCE, cluster.getProperties());\n        PigContext context = server.getPigContext();\n        \n        String strCmd = \"copyFromLocal /tmp/TestMe;\";\n        \n        ByteArrayInputStream cmd = new ByteArrayInputStream(strCmd.getBytes());\n        InputStreamReader reader = new InputStreamReader(cmd);\n        \n        Grunt grunt = new Grunt(new BufferedReader(reader), context);\n\t\n        grunt.exec();\n\t}\n}", "class_id": 0, "repo": "bertpassek/pig", "file": "test/org/apache/pig/test/TestGrunt.java", "last_update_at": "2019-06-05T18:31:10+00:00", "question_id": "730c54a448d63b3a8301ffb2d5d1259527816880", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestGrunt extends TestCase {\n    MiniCluster cluster = MiniCluster.buildCluster();\n\t\n\t@Test \n\tpublic void testCopyFromLocal() throws Throwable {\n\t\tPigServer server = new PigServer(ExecType.MAPREDUCE, cluster.getProperties());\n        PigContext context = server.getPigContext();\n        String strCmd = \"copyFromLocal /tmp/TestMe;\";\n        ByteArrayInputStream cmd = new ByteArrayInputStream(strCmd.getBytes());\n        InputStreamReader reader = new InputStreamReader(cmd);\n        Grunt grunt = new Grunt(new BufferedReader(reader), context);\n\t\n        grunt.exec();\n\t}\n"]]}
{"hexsha": "9e073177adef4e3090460db8508c681c6f118851", "ext": "java", "lang": "Java", "content": "public class AnnotatedDependsOnDemo {\n\n\tpublic static void main(String... args) {\n\t\tGenericXmlApplicationContext ctx = new GenericXmlApplicationContext();\n\t\tctx.load(\"classpath:spring/app-context-02.xml\");\n\t\tctx.refresh();\n\n\t\tSinger johnMayer = ctx.getBean(\"johnMayer\", Singer.class);\n\t\tjohnMayer.sing();\n\n\t\tctx.close();\n\t}\n\n}", "class_id": 0, "repo": "dhanu10896/tech-notes", "file": "pro-spring-5-master/chapter03/bean-autowiring/src/main/java/com/apress/prospring5/ch3/annotated/AnnotatedDependsOnDemo.java", "last_update_at": "2019-03-08T03:15:54+00:00", "question_id": "9e073177adef4e3090460db8508c681c6f118851", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AnnotatedDependsOnDemo {\n\tpublic static void main(String... args) {\n\t\tGenericXmlApplicationContext ctx = new GenericXmlApplicationContext();\n\t\tctx.load(\"classpath:spring/app-context-02.xml\");\n\t\tctx.refresh();\n\t\tSinger johnMayer = ctx.getBean(\"johnMayer\", Singer.class);\n\t\tjohnMayer.sing();\n\t\tctx.close();\n\t}\n"]]}
{"hexsha": "a1dd3ed47914f0a80fc7c291f437b9fca0235a12", "ext": "java", "lang": "Java", "content": "class B implements I {\n    public void m() {\n        <selection>System.out.println(A.TEXT);</selection>\n    }\n}", "class_id": 0, "repo": "jnthn/intellij-community", "file": "java/java-tests/testData/codeInsight/daemonCodeAnalyzer/quickFix/copyAbstractMethodImplementation/afterStaticRef.java", "last_update_at": "2019-08-17T10:07:23+00:00", "question_id": "a1dd3ed47914f0a80fc7c291f437b9fca0235a12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class B implements I {\n    public void m() {\n        <selection>System.out.println(A.TEXT);</selection>\n    }\n"]]}
{"hexsha": "4ad6adcbfc1008c89cd3084b9b5b0696f4baddb9", "ext": "java", "lang": "Java", "content": "public class StatusOffWebSocketClient extends SpringBootWebSocketClient {\n    @Override\n    public void onOpen(WebSocket webSocket, Response response) {\n        super.onOpen(webSocket, response);\n        sendConnectMessage(webSocket);\n        for (String topic : topics.keySet()) {\n            sendSubscribeMessage(webSocket, topic);\n        }\n        // turn the givenId user status off\n        sendMessage(webSocket, \"/app/userList/status/off\", \"1\");\n        closeHandler = new CloseHandler(webSocket);\n    }\n}", "class_id": 0, "repo": "weihuiwu/springboot-android-chat-client", "file": "app/src/main/java/com/nil/client/websocket/socketclient/StatusOffWebSocketClient.java", "last_update_at": "2019-07-05T07:32:39+00:00", "question_id": "4ad6adcbfc1008c89cd3084b9b5b0696f4baddb9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class StatusOffWebSocketClient extends SpringBootWebSocketClient {\n    @Override\n    public void onOpen(WebSocket webSocket, Response response) {\n        super.onOpen(webSocket, response);\n        sendConnectMessage(webSocket);\n        for (String topic : topics.keySet()) {\n            sendSubscribeMessage(webSocket, topic);\n        }\n        // turn the givenId user status off\n        sendMessage(webSocket, \"/app/userList/status/off\", \"1\");\n        closeHandler = new CloseHandler(webSocket);\n    }\n"]]}
{"hexsha": "a53265b8898d0e563a419fe4c452c5dab5c9c963", "ext": "java", "lang": "Java", "content": "public class OrderManagerTest {\n\n\t@BeforeClass\n\tpublic static void registerDefaultCurrencyPairs() {\n\t\tif(BitfinexCurrencyPair.values().size() < 10) {\n\t\t\tBitfinexCurrencyPair.unregisterAll();\n\t\t\tBitfinexCurrencyPair.registerDefaults();\t\n\t\t}\n\t}\n\t\n    /**\n     * Test order submit failed\n     *\n     * @throws BitfinexClientException\n     * @throws InterruptedException\n     */\n    @Test\n    public void testOrderSubmissionFailed() throws BitfinexClientException, InterruptedException {\n        final String jsonString = \"[0,\\\"n\\\",[null,\\\"on-req\\\",null,null,[null,null,1513970684865000,\\\"tBTCUSD\\\",null,null,0.001,0.001,\\\"EXCHANGE MARKET\\\",null,null,null,null,null,null,null,12940,null,null,null,null,null,null,0,null,null],null,\\\"ERROR\\\",\\\"Invalid order: minimum size for BTC/USD is 0.002\\\"]]\";\n        final JSONArray jsonArray = new JSONArray(jsonString);\n\n        final Consumer<BitfinexSubmittedOrder> orderCallback = (e) -> {\n            Assert.assertEquals(BitfinexSubmittedOrderStatus.ERROR, e.getStatus());\n            Assert.assertEquals(TestHelper.API_KEY, e.getApiKey());\n            Assert.assertEquals(1513970684865000L, (long)e.getClientId());\n            Assert.assertEquals(BitfinexCurrencyPair.of(\"BTC\", \"USD\").toBitfinexString(), e.getCurrencyPair().toBitfinexString());\n        };\n\n        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();\n        bitfinexApiBroker.getOrderManager().registerCallback(orderCallback);\n        final NotificationHandler notificationHandler = new NotificationHandler(0, BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, \"api-key\"));\n        notificationHandler.onOrderNotification((a, eo) -> {\n            bitfinexApiBroker.getOrderManager().updateOrder(a, eo);\n        });\n\n        notificationHandler.handleChannelData(\"n\", jsonArray.getJSONArray(2));\n    }\n\n\n    /**\n     * Test notifications with null value\n     *\n     * @throws BitfinexClientException\n     * @throws InterruptedException\n     */\n    @Test\n    public void testNotificationWithNull() throws BitfinexClientException, InterruptedException {\n        final String jsonString = \"[0,\\\"n\\\",[1523930407542,\\\"on-req\\\",null,null,[null,null,1523930407442000,null,null,null,0.0001,null,\\\"LIMIT\\\",null,null,null,null,null,null,null,6800,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null],null,\\\"ERROR\\\",\\\"amount: invalid\\\"]]\";\n        final JSONArray jsonArray = new JSONArray(jsonString);\n\n        final Consumer<BitfinexSubmittedOrder> orderCallback = (e) -> {\n            Assert.assertEquals(BitfinexSubmittedOrderStatus.ERROR, e.getStatus());\n            Assert.assertEquals(TestHelper.API_KEY, e.getApiKey());\n            Assert.assertEquals(1523930407442000L, (long) e.getClientId());\n            Assert.assertNull(e.getCurrencyPair());\n        };\n\n        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();\n        bitfinexApiBroker.getOrderManager().registerCallback(orderCallback);\n        final NotificationHandler notificationHandler = new NotificationHandler(0, BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, \"api-key\"));\n\n        notificationHandler.handleChannelData(\"n\", jsonArray.getJSONArray(2));\n\n        notificationHandler.onOrderNotification((a, eo) -> {\n            bitfinexApiBroker.getOrderManager().updateOrder(a, eo);\n        });\n    }\n\n    /**\n     * Test the order channel handler - single order\n     *\n     * @throws BitfinexClientException\n     */\n    @Test\n    public void testOrderChannelHandler1() throws BitfinexClientException {\n        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();\n        final String jsonString = \"[0,\\\"on\\\",[6784335053,null,1514956504945000,\\\"tIOTUSD\\\",1514956505134,1514956505164,-24.175121,-24.175121,\\\"EXCHANGE STOP\\\",null,null,null,0,\\\"ACTIVE\\\",null,null,3.84,0,null,null,null,null,null,0,0,0]]\";\n        final JSONArray jsonArray = new JSONArray(jsonString);\n        final OrderHandler orderHandler = new OrderHandler(0, BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, \"api-key\"));\n        orderHandler.onSubmittedOrderEvent((a, eos) -> {\n            for (BitfinexSubmittedOrder exchangeOrder : eos) {\n                bitfinexApiBroker.getOrderManager().updateOrder(a, exchangeOrder);\n            }\n        });\n\n        final OrderManager orderManager = bitfinexApiBroker.getOrderManager();\n        Assert.assertTrue(orderManager.getOrders().isEmpty());\n        orderHandler.handleChannelData(\"on\", jsonArray.getJSONArray(2));\n\n        Assert.assertEquals(1, orderManager.getOrders().size());\n\n        Assert.assertEquals(BitfinexSubmittedOrderStatus.ACTIVE, orderManager.getOrders().get(0).getStatus());\n    }\n\n    /**\n     * Test the order channel handler - snapshot\n     *\n     * @throws BitfinexClientException\n     */\n    @Test\n    public void testOrderChannelHandler2() throws BitfinexClientException {\n        final String jsonString = \"[0,\\\"on\\\",[[6784335053,null,1514956504945000,\\\"tIOTUSD\\\",1514956505134,1514956505164,-24.175121,-24.175121,\\\"EXCHANGE STOP\\\",null,null,null,0,\\\"ACTIVE\\\",null,null,3.84,0,null,null,null,null,null,0,0,0], [67843353243,null,1514956234945000,\\\"tBTCUSD\\\",1514956505134,1514956505164,-24.175121,-24.175121,\\\"EXCHANGE STOP\\\",null,null,null,0,\\\"ACTIVE\\\",null,null,3.84,0,null,null,null,null,null,0,0,0]]]\";\n        final JSONArray jsonArray = new JSONArray(jsonString);\n        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();\n        final OrderHandler orderHandler = new OrderHandler(0, BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, \"api-key\"));\n        orderHandler.onSubmittedOrderEvent((a, eos) -> {\n            for (BitfinexSubmittedOrder exchangeOrder : eos) {\n                bitfinexApiBroker.getOrderManager().updateOrder(a, exchangeOrder);\n            }\n        });\n\n        final OrderManager orderManager = bitfinexApiBroker.getOrderManager();\n        Assert.assertTrue(orderManager.getOrders().isEmpty());\n        orderHandler.handleChannelData(\"on\", jsonArray.getJSONArray(2));\n        Assert.assertEquals(2, orderManager.getOrders().size());\n\n        Assert.assertEquals(BitfinexSubmittedOrderStatus.ACTIVE, orderManager.getOrders().get(0).getStatus());\n        Assert.assertEquals(BitfinexSubmittedOrderStatus.ACTIVE, orderManager.getOrders().get(1).getStatus());\n\n        orderManager.clear();\n        Assert.assertTrue(orderManager.getOrders().isEmpty());\n    }\n\n    /**\n     * Test the order channel handler - posclose order\n     *\n     * @throws BitfinexClientException\n     */\n    @Test\n    public void testOrderChannelHandler3() throws BitfinexClientException {\n        final String jsonString = \"[0,\\\"on\\\",[6827301913,null,null,\\\"tXRPUSD\\\",1515069803530,1515069803530,-60,-60,\\\"MARKET\\\",null,null,null,0,\\\"ACTIVE (note:POSCLOSE)\\\",null,null,0,3.2041,null,null,null,null,null,0,0,0]]\";\n\n        final JSONArray jsonArray = new JSONArray(jsonString);\n        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();\n        final OrderHandler orderHandler = new OrderHandler(0, BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, \"api-key\"));\n        orderHandler.onSubmittedOrderEvent((a,eos) -> {\n            for (BitfinexSubmittedOrder exchangeOrder : eos) {\n                bitfinexApiBroker.getOrderManager().updateOrder(a, exchangeOrder);\n            }\n        });\n\n        final OrderManager orderManager = bitfinexApiBroker.getOrderManager();\n        Assert.assertTrue(orderManager.getOrders().isEmpty());\n        orderHandler.handleChannelData(\"on\", jsonArray.getJSONArray(2));\n\n        Assert.assertEquals(1, orderManager.getOrders().size());\n        Assert.assertEquals(BitfinexSubmittedOrderStatus.ACTIVE, orderManager.getOrders().get(0).getStatus());\n    }\n\n    /**\n     * Test the order channel handler - partFilled order\n     *\n     * @throws BitfinexClientException\n     */\n    @Test\n    public void testOrderChannelHandler4() throws BitfinexClientException {\n        final String jsonString = \"[0,\\\"oc\\\",[11291120775,null,null,\\\"tNEOBTC\\\",1524661302976,1524661303001,0,-0.41291886,\\\"MARKET\\\",null,null,null,0,\\\"INSUFFICIENT BALANCE (G1) was: ACTIVE (note:POSCLOSE), PARTIALLY FILLED @ 0.008049(-0.41291886)\\\",null,null,0,0.008049,null,null,null,null,null,0,0,0,null,null,\\\"\\\",null,null,null]]\";\n\n        final JSONArray jsonArray = new JSONArray(jsonString);\n        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();\n        final OrderHandler orderHandler = new OrderHandler(0, BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, \"api-key\"));\n        orderHandler.onSubmittedOrderEvent((a, eos) -> {\n            for (BitfinexSubmittedOrder exchangeOrder : eos) {\n                bitfinexApiBroker.getOrderManager().updateOrder(a, exchangeOrder);\n            }\n        });\n\n        final OrderManager orderManager = bitfinexApiBroker.getOrderManager();\n        Assert.assertTrue(orderManager.getOrders().isEmpty());\n        orderHandler.handleChannelData(\"oc\", jsonArray.getJSONArray(2));\n\n        Assert.assertEquals(1, orderManager.getOrders().size());\n        Assert.assertEquals(BitfinexSubmittedOrderStatus.PARTIALLY_FILLED, orderManager.getOrders().get(0).getStatus());\n    }\n\n    /**\n     * Test the cancelation of an order\n     *\n     * @throws InterruptedException\n     * @throws BitfinexClientException\n     */\n    @Test(expected = BitfinexClientException.class)\n    public void testCancelOrderUnauth() throws BitfinexClientException, InterruptedException {\n\n        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();\n        Mockito.when(bitfinexApiBroker.getApiKeyPermissions()).thenReturn(BitfinexApiKeyPermissions.NO_PERMISSIONS);\n\n        final OrderManager orderManager = bitfinexApiBroker.getOrderManager();\n        orderManager.cancelOrderAndWaitForCompletion(12);\n    }\n\n    /**\n     * Test the cancelation of an order\n     *\n     * @throws InterruptedException\n     * @throws BitfinexClientException\n     */\n    @Test(timeout = 60000)\n    public void testCancelOrder() throws BitfinexClientException, InterruptedException {\n        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();\n\n        final OrderManager orderManager = bitfinexApiBroker.getOrderManager();\n        BitfinexAccountSymbol symbol = BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, \"apiKey\");\n\n        final Runnable r = () -> {\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                return;\n            }\n            final BitfinexSubmittedOrder exchangeOrder = new BitfinexSubmittedOrder();\n            exchangeOrder.setOrderId(12L);\n            exchangeOrder.setStatus(BitfinexSubmittedOrderStatus.CANCELED);\n            orderManager.updateOrder(symbol, exchangeOrder);\n        };\n\n        // Cancel event\n        (new Thread(r)).start();\n\n        orderManager.cancelOrderAndWaitForCompletion(12);\n    }\n\n    /**\n     * Test the placement of an order\n     *\n     * @throws InterruptedException\n     * @throws BitfinexClientException\n     */\n    @Test(expected = BitfinexClientException.class)\n    public void testPlaceOrderUnauth() throws BitfinexClientException, InterruptedException {\n\n        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();\n        Mockito.when(bitfinexApiBroker.getApiKeyPermissions()).thenReturn(BitfinexApiKeyPermissions.NO_PERMISSIONS);\n\n        final OrderManager orderManager = bitfinexApiBroker.getOrderManager();\n\n        final BitfinexNewOrder order\n                = BitfinexOrderBuilder.create(BitfinexCurrencyPair.of(\"BTC\", \"USD\"), BitfinexOrderType.MARKET, 12).build();\n\n        orderManager.placeOrderAndWaitUntilActive(order);\n    }\n\n\n    /**\n     * Test the placement of an order\n     *\n     * @throws InterruptedException\n     * @throws BitfinexClientException\n     */\n    @Test(timeout = 60000)\n    public void testPlaceOrder() throws BitfinexClientException, InterruptedException {\n\n        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();\n        Mockito.when(bitfinexApiBroker.isAuthenticated()).thenReturn(true);\n\n        final OrderManager orderManager = bitfinexApiBroker.getOrderManager();\n\n        final BitfinexNewOrder order\n                = BitfinexOrderBuilder.create(BitfinexCurrencyPair.of(\"BTC\", \"USD\"), BitfinexOrderType.MARKET, 1).build();\n        BitfinexAccountSymbol symbol = BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, \"apiKey\");\n\n        final Runnable r = () -> {\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                return;\n            }\n            final BitfinexSubmittedOrder exchangeOrder = new BitfinexSubmittedOrder();\n            exchangeOrder.setClientId(order.getClientId());\n            exchangeOrder.setStatus(BitfinexSubmittedOrderStatus.ACTIVE);\n            orderManager.updateOrder(symbol, exchangeOrder);\n        };\n\n        // Cancel event\n        (new Thread(r)).start();\n\n        orderManager.placeOrderAndWaitUntilActive(order);\n    }\n\n\n}", "class_id": 0, "repo": "barrymac/bitfinex-v2-wss-api-java", "file": "src/test/java/com/github/jnidzwetzki/bitfinex/v2/test/manager/OrderManagerTest.java", "last_update_at": "2019-09-08T19:14:07+00:00", "question_id": "a53265b8898d0e563a419fe4c452c5dab5c9c963", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OrderManagerTest {\n\t@BeforeClass\n\tpublic static void registerDefaultCurrencyPairs() {\n\t\tif(BitfinexCurrencyPair.values().size() < 10) {\n\t\t\tBitfinexCurrencyPair.unregisterAll();\n\t\t\tBitfinexCurrencyPair.registerDefaults();\t\n\t\t}\n\t}\n\t\n    /**\n     * Test order submit failed\n     *\n     * @throws BitfinexClientException\n     * @throws InterruptedException\n     */\n    @Test\n    public void testOrderSubmissionFailed() throws BitfinexClientException, InterruptedException {\n        final String jsonString = \"[0,\\\"n\\\",[null,\\\"on-req\\\",null,null,[null,null,1513970684865000,\\\"tBTCUSD\\\",null,null,0.001,0.001,\\\"EXCHANGE MARKET\\\",null,null,null,null,null,null,null,12940,null,null,null,null,null,null,0,null,null],null,\\\"ERROR\\\",\\\"Invalid order: minimum size for BTC/USD is 0.002\\\"]]\";\n        final JSONArray jsonArray = new JSONArray(jsonString);\n        final Consumer<BitfinexSubmittedOrder> orderCallback = (e) -> {\n            Assert.assertEquals(BitfinexSubmittedOrderStatus.ERROR, e.getStatus());\n            Assert.assertEquals(TestHelper.API_KEY, e.getApiKey());\n            Assert.assertEquals(1513970684865000L, (long)e.getClientId());\n            Assert.assertEquals(BitfinexCurrencyPair.of(\"BTC\", \"USD\").toBitfinexString(), e.getCurrencyPair().toBitfinexString());\n        };\n        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();\n        bitfinexApiBroker.getOrderManager().registerCallback(orderCallback);\n        final NotificationHandler notificationHandler = new NotificationHandler(0, BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, \"api-key\"));\n        notificationHandler.onOrderNotification((a, eo) -> {\n            bitfinexApiBroker.getOrderManager().updateOrder(a, eo);\n        });\n        notificationHandler.handleChannelData(\"n\", jsonArray.getJSONArray(2));\n    }\n    /**\n     * Test notifications with null value\n     *\n     * @throws BitfinexClientException\n     * @throws InterruptedException\n     */\n    @Test\n    public void testNotificationWithNull() throws BitfinexClientException, InterruptedException {\n        final String jsonString = \"[0,\\\"n\\\",[1523930407542,\\\"on-req\\\",null,null,[null,null,1523930407442000,null,null,null,0.0001,null,\\\"LIMIT\\\",null,null,null,null,null,null,null,6800,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null],null,\\\"ERROR\\\",\\\"amount: invalid\\\"]]\";\n        final JSONArray jsonArray = new JSONArray(jsonString);\n        final Consumer<BitfinexSubmittedOrder> orderCallback = (e) -> {\n            Assert.assertEquals(BitfinexSubmittedOrderStatus.ERROR, e.getStatus());\n            Assert.assertEquals(TestHelper.API_KEY, e.getApiKey());\n            Assert.assertEquals(1523930407442000L, (long) e.getClientId());\n            Assert.assertNull(e.getCurrencyPair());\n        };\n        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();\n        bitfinexApiBroker.getOrderManager().registerCallback(orderCallback);\n        final NotificationHandler notificationHandler = new NotificationHandler(0, BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, \"api-key\"));\n        notificationHandler.handleChannelData(\"n\", jsonArray.getJSONArray(2));\n        notificationHandler.onOrderNotification((a, eo) -> {\n            bitfinexApiBroker.getOrderManager().updateOrder(a, eo);\n        });\n    }\n    /**\n     * Test the order channel handler - single order\n     *\n     * @throws BitfinexClientException\n     */\n    @Test\n    public void testOrderChannelHandler1() throws BitfinexClientException {\n        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();\n        final String jsonString = \"[0,\\\"on\\\",[6784335053,null,1514956504945000,\\\"tIOTUSD\\\",1514956505134,1514956505164,-24.175121,-24.175121,\\\"EXCHANGE STOP\\\",null,null,null,0,\\\"ACTIVE\\\",null,null,3.84,0,null,null,null,null,null,0,0,0]]\";\n        final JSONArray jsonArray = new JSONArray(jsonString);\n        final OrderHandler orderHandler = new OrderHandler(0, BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, \"api-key\"));\n        orderHandler.onSubmittedOrderEvent((a, eos) -> {\n            for (BitfinexSubmittedOrder exchangeOrder : eos) {\n                bitfinexApiBroker.getOrderManager().updateOrder(a, exchangeOrder);\n            }\n        });\n        final OrderManager orderManager = bitfinexApiBroker.getOrderManager();\n        Assert.assertTrue(orderManager.getOrders().isEmpty());\n        orderHandler.handleChannelData(\"on\", jsonArray.getJSONArray(2));\n        Assert.assertEquals(1, orderManager.getOrders().size());\n        Assert.assertEquals(BitfinexSubmittedOrderStatus.ACTIVE, orderManager.getOrders().get(0).getStatus());\n    }\n    /**\n     * Test the order channel handler - snapshot\n     *\n     * @throws BitfinexClientException\n     */\n    @Test\n    public void testOrderChannelHandler2() throws BitfinexClientException {\n        final String jsonString = \"[0,\\\"on\\\",[[6784335053,null,1514956504945000,\\\"tIOTUSD\\\",1514956505134,1514956505164,-24.175121,-24.175121,\\\"EXCHANGE STOP\\\",null,null,null,0,\\\"ACTIVE\\\",null,null,3.84,0,null,null,null,null,null,0,0,0], [67843353243,null,1514956234945000,\\\"tBTCUSD\\\",1514956505134,1514956505164,-24.175121,-24.175121,\\\"EXCHANGE STOP\\\",null,null,null,0,\\\"ACTIVE\\\",null,null,3.84,0,null,null,null,null,null,0,0,0]]]\";\n        final JSONArray jsonArray = new JSONArray(jsonString);\n        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();\n        final OrderHandler orderHandler = new OrderHandler(0, BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, \"api-key\"));\n        orderHandler.onSubmittedOrderEvent((a, eos) -> {\n            for (BitfinexSubmittedOrder exchangeOrder : eos) {\n                bitfinexApiBroker.getOrderManager().updateOrder(a, exchangeOrder);\n            }\n        });\n        final OrderManager orderManager = bitfinexApiBroker.getOrderManager();\n        Assert.assertTrue(orderManager.getOrders().isEmpty());\n        orderHandler.handleChannelData(\"on\", jsonArray.getJSONArray(2));\n        Assert.assertEquals(2, orderManager.getOrders().size());\n        Assert.assertEquals(BitfinexSubmittedOrderStatus.ACTIVE, orderManager.getOrders().get(0).getStatus());\n        Assert.assertEquals(BitfinexSubmittedOrderStatus.ACTIVE, orderManager.getOrders().get(1).getStatus());\n        orderManager.clear();\n        Assert.assertTrue(orderManager.getOrders().isEmpty());\n    }\n    /**\n     * Test the order channel handler - posclose order\n     *\n     * @throws BitfinexClientException\n     */\n    @Test\n    public void testOrderChannelHandler3() throws BitfinexClientException {\n        final String jsonString = \"[0,\\\"on\\\",[6827301913,null,null,\\\"tXRPUSD\\\",1515069803530,1515069803530,-60,-60,\\\"MARKET\\\",null,null,null,0,\\\"ACTIVE (note:POSCLOSE)\\\",null,null,0,3.2041,null,null,null,null,null,0,0,0]]\";\n        final JSONArray jsonArray = new JSONArray(jsonString);\n        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();\n        final OrderHandler orderHandler = new OrderHandler(0, BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, \"api-key\"));\n        orderHandler.onSubmittedOrderEvent((a,eos) -> {\n            for (BitfinexSubmittedOrder exchangeOrder : eos) {\n                bitfinexApiBroker.getOrderManager().updateOrder(a, exchangeOrder);\n            }\n        });\n        final OrderManager orderManager = bitfinexApiBroker.getOrderManager();\n        Assert.assertTrue(orderManager.getOrders().isEmpty());\n        orderHandler.handleChannelData(\"on\", jsonArray.getJSONArray(2));\n        Assert.assertEquals(1, orderManager.getOrders().size());\n        Assert.assertEquals(BitfinexSubmittedOrderStatus.ACTIVE, orderManager.getOrders().get(0).getStatus());\n    }\n    /**\n     * Test the order channel handler - partFilled order\n     *\n     * @throws BitfinexClientException\n     */\n    @Test\n    public void testOrderChannelHandler4() throws BitfinexClientException {\n        final String jsonString = \"[0,\\\"oc\\\",[11291120775,null,null,\\\"tNEOBTC\\\",1524661302976,1524661303001,0,-0.41291886,\\\"MARKET\\\",null,null,null,0,\\\"INSUFFICIENT BALANCE (G1) was: ACTIVE (note:POSCLOSE), PARTIALLY FILLED @ 0.008049(-0.41291886)\\\",null,null,0,0.008049,null,null,null,null,null,0,0,0,null,null,\\\"\\\",null,null,null]]\";\n        final JSONArray jsonArray = new JSONArray(jsonString);\n        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();\n        final OrderHandler orderHandler = new OrderHandler(0, BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, \"api-key\"));\n        orderHandler.onSubmittedOrderEvent((a, eos) -> {\n            for (BitfinexSubmittedOrder exchangeOrder : eos) {\n                bitfinexApiBroker.getOrderManager().updateOrder(a, exchangeOrder);\n            }\n        });\n        final OrderManager orderManager = bitfinexApiBroker.getOrderManager();\n        Assert.assertTrue(orderManager.getOrders().isEmpty());\n        orderHandler.handleChannelData(\"oc\", jsonArray.getJSONArray(2));\n        Assert.assertEquals(1, orderManager.getOrders().size());\n        Assert.assertEquals(BitfinexSubmittedOrderStatus.PARTIALLY_FILLED, orderManager.getOrders().get(0).getStatus());\n    }\n    /**\n     * Test the cancelation of an order\n     *\n     * @throws InterruptedException\n     * @throws BitfinexClientException\n     */\n    @Test(expected = BitfinexClientException.class)\n    public void testCancelOrderUnauth() throws BitfinexClientException, InterruptedException {\n        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();\n        Mockito.when(bitfinexApiBroker.getApiKeyPermissions()).thenReturn(BitfinexApiKeyPermissions.NO_PERMISSIONS);\n        final OrderManager orderManager = bitfinexApiBroker.getOrderManager();\n        orderManager.cancelOrderAndWaitForCompletion(12);\n    }\n    /**\n     * Test the cancelation of an order\n     *\n     * @throws InterruptedException\n     * @throws BitfinexClientException\n     */\n    @Test(timeout = 60000)\n    public void testCancelOrder() throws BitfinexClientException, InterruptedException {\n        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();\n        final OrderManager orderManager = bitfinexApiBroker.getOrderManager();\n        BitfinexAccountSymbol symbol = BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, \"apiKey\");\n        final Runnable r = () -> {\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                return;\n            }\n            final BitfinexSubmittedOrder exchangeOrder = new BitfinexSubmittedOrder();\n            exchangeOrder.setOrderId(12L);\n            exchangeOrder.setStatus(BitfinexSubmittedOrderStatus.CANCELED);\n            orderManager.updateOrder(symbol, exchangeOrder);\n        };\n        // Cancel event\n        (new Thread(r)).start();\n        orderManager.cancelOrderAndWaitForCompletion(12);\n    }\n    /**\n     * Test the placement of an order\n     *\n     * @throws InterruptedException\n     * @throws BitfinexClientException\n     */\n    @Test(expected = BitfinexClientException.class)\n    public void testPlaceOrderUnauth() throws BitfinexClientException, InterruptedException {\n        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();\n        Mockito.when(bitfinexApiBroker.getApiKeyPermissions()).thenReturn(BitfinexApiKeyPermissions.NO_PERMISSIONS);\n        final OrderManager orderManager = bitfinexApiBroker.getOrderManager();\n        final BitfinexNewOrder order\n                = BitfinexOrderBuilder.create(BitfinexCurrencyPair.of(\"BTC\", \"USD\"), BitfinexOrderType.MARKET, 12).build();\n        orderManager.placeOrderAndWaitUntilActive(order);\n    }\n    /**\n     * Test the placement of an order\n     *\n     * @throws InterruptedException\n     * @throws BitfinexClientException\n     */\n    @Test(timeout = 60000)\n    public void testPlaceOrder() throws BitfinexClientException, InterruptedException {\n        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();\n        Mockito.when(bitfinexApiBroker.isAuthenticated()).thenReturn(true);\n        final OrderManager orderManager = bitfinexApiBroker.getOrderManager();\n        final BitfinexNewOrder order\n                = BitfinexOrderBuilder.create(BitfinexCurrencyPair.of(\"BTC\", \"USD\"), BitfinexOrderType.MARKET, 1).build();\n        BitfinexAccountSymbol symbol = BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, \"apiKey\");\n        final Runnable r = () -> {\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                return;\n            }\n            final BitfinexSubmittedOrder exchangeOrder = new BitfinexSubmittedOrder();\n            exchangeOrder.setClientId(order.getClientId());\n            exchangeOrder.setStatus(BitfinexSubmittedOrderStatus.ACTIVE);\n            orderManager.updateOrder(symbol, exchangeOrder);\n        };\n        // Cancel event\n        (new Thread(r)).start();\n        orderManager.placeOrderAndWaitUntilActive(order);\n    }\n"]]}
{"hexsha": "fab1a06c233d3c5e207c132fe276f209dd4d3bbb", "ext": "java", "lang": "Java", "content": "public class DepartmentDaoImpl implements DepartmentDao {\n\t\n\tpublic int save(Department dept) {\n\t\tString sql = \"insert into dept values(?,?,?)\";\n\t\tObject[] params = {dept.getDeptno(),dept.getDeptName(),dept.getLocation()};\n\t\t\n\t\treturn DBUtil.executeUpdate(sql, params);\n\t\t\n\t}\n\n\t@Override\n\tpublic List<Department> findAll() {\n\t\t\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\t\t\n\t\tList<Department> depts = null;\n\t\t\n\t\ttry {\n\t\t\tconn = DBUtil.getConnection();\n\t\t\tString sql = \"select * from dept\";\n\t\t\tps=conn.prepareStatement(sql);\n\t\t\trs=ps.executeQuery();\n\t\t\tdepts = new ArrayList<>();\n\t\t\twhile(rs.next()) {\n\t\t\t\tDepartment dept=new Department();\n\t\t\t\tdept.setDeptno(rs.getInt(\"deptno\"));\n\t\t\t\tdept.setDeptName(rs.getString(\"deptName\"));\n\t\t\t\tdept.setLocation(rs.getString(\"location\"));\n\t\t\t\tdepts.add(dept);\n\t\t\t}\n\t\t\tSystem.out.println(depts);\n\t\t\t\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}finally {\n\t\t\tDBUtil.closeAll(rs, ps, conn);\n\t\t}\n\t\t\n\t\treturn depts;\n\t}\n\n\t@Override\n\tpublic int delete(int deptNo) {\n\t\t\n\t\tString sql = \"delete from dept where deptno=?\";\n\t\tObject[] params = {deptNo};\n\t\t\n\t\treturn DBUtil.executeUpdate(sql, params);\n\t}\n\n\t@Override\n\tpublic Department findById(int deptNo) {\n\t\t\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\t\t\n\t\tDepartment dept=null;\n\t\t\n\t\ttry {\n\t\t\tconn = DBUtil.getConnection();\n\t\t\tString sql = \"select * from dept where deptno=?\";\n\t\t\tps=conn.prepareStatement(sql);\n\t\t\tps.setInt(1, deptNo);\n\t\t\trs=ps.executeQuery();\n\t\t\twhile(rs.next()) {\n\t\t\t\tdept=new Department();\n\t\t\t\tdept.setDeptno(rs.getInt(\"deptno\"));\n\t\t\t\tdept.setDeptName(rs.getString(\"deptName\"));\n\t\t\t\tdept.setLocation(rs.getString(\"location\"));\n\t\t\t}\n\t\t\tSystem.out.println(dept);\n\t\t\t\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}finally {\n\t\t\tDBUtil.closeAll(rs, ps, conn);\n\t\t}\n\t\t\n\t\treturn dept;\n\t}\n\n\t@Override\n\tpublic int update(Department dept) {\n\t\t\n\t\tString sql = \"update dept set deptname=?,location=? where deptno=?\";\n\t\tObject[] params = {dept.getDeptName(),dept.getLocation(),dept.getDeptno()};\n\t\t\n\t\treturn DBUtil.executeUpdate(sql, params);\n\t}\n}", "class_id": 0, "repo": "Tu-Yi/my-java-experience", "file": "jsp/sxtoa/src/com/niliv/dao/impl/DepartmentDaoImpl.java", "last_update_at": "2019-05-13T02:09:32+00:00", "question_id": "fab1a06c233d3c5e207c132fe276f209dd4d3bbb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DepartmentDaoImpl implements DepartmentDao {\n\t\n\tpublic int save(Department dept) {\n\t\tString sql = \"insert into dept values(?,?,?)\";\n\t\tObject[] params = {dept.getDeptno(),dept.getDeptName(),dept.getLocation()};\n\t\t\n\t\treturn DBUtil.executeUpdate(sql, params);\n\t\t\n\t}\n\t@Override\n\tpublic List<Department> findAll() {\n\t\t\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\t\t\n\t\tList<Department> depts = null;\n\t\t\n\t\ttry {\n\t\t\tconn = DBUtil.getConnection();\n\t\t\tString sql = \"select * from dept\";\n\t\t\tps=conn.prepareStatement(sql);\n\t\t\trs=ps.executeQuery();\n\t\t\tdepts = new ArrayList<>();\n\t\t\twhile(rs.next()) {\n\t\t\t\tDepartment dept=new Department();\n\t\t\t\tdept.setDeptno(rs.getInt(\"deptno\"));\n\t\t\t\tdept.setDeptName(rs.getString(\"deptName\"));\n\t\t\t\tdept.setLocation(rs.getString(\"location\"));\n\t\t\t\tdepts.add(dept);\n\t\t\t}\n\t\t\tSystem.out.println(depts);\n\t\t\t\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}finally {\n\t\t\tDBUtil.closeAll(rs, ps, conn);\n\t\t}\n\t\t\n\t\treturn depts;\n\t}\n\t@Override\n\tpublic int delete(int deptNo) {\n\t\t\n\t\tString sql = \"delete from dept where deptno=?\";\n\t\tObject[] params = {deptNo};\n\t\t\n\t\treturn DBUtil.executeUpdate(sql, params);\n\t}\n\t@Override\n\tpublic Department findById(int deptNo) {\n\t\t\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\t\t\n\t\tDepartment dept=null;\n\t\t\n\t\ttry {\n\t\t\tconn = DBUtil.getConnection();\n\t\t\tString sql = \"select * from dept where deptno=?\";\n\t\t\tps=conn.prepareStatement(sql);\n\t\t\tps.setInt(1, deptNo);\n\t\t\trs=ps.executeQuery();\n\t\t\twhile(rs.next()) {\n\t\t\t\tdept=new Department();\n\t\t\t\tdept.setDeptno(rs.getInt(\"deptno\"));\n\t\t\t\tdept.setDeptName(rs.getString(\"deptName\"));\n\t\t\t\tdept.setLocation(rs.getString(\"location\"));\n\t\t\t}\n\t\t\tSystem.out.println(dept);\n\t\t\t\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}finally {\n\t\t\tDBUtil.closeAll(rs, ps, conn);\n\t\t}\n\t\t\n\t\treturn dept;\n\t}\n\t@Override\n\tpublic int update(Department dept) {\n\t\t\n\t\tString sql = \"update dept set deptname=?,location=? where deptno=?\";\n\t\tObject[] params = {dept.getDeptName(),dept.getLocation(),dept.getDeptno()};\n\t\t\n\t\treturn DBUtil.executeUpdate(sql, params);\n\t}\n"]]}
{"hexsha": "d30dac85ab1b54f9487f62d51c77e43b0066bfd3", "ext": "java", "lang": "Java", "content": "public class ConfigTom extends ConfigTrades {\n\n\t@Expose public List<String> POI_LOSS_PHRASES = new ArrayList<String>();\n\t@Expose public List<String> DESPAWN_PHRASES = new ArrayList<String>();\n\t\n\t@Expose public int DESPAWN_DELAY;\n\t\n\t@Expose public int TRADES_COUNT;\n\n\tpublic ConfigTom() {\n\n\t}\n\n\t@Override\n\tpublic String getLocation() {\n\t\treturn \"tom.json\";\n\t}\n\t\n\t@Override\n\tprotected void resetConfig() {\n\t\tthis.POI_LOSS_PHRASES.add(\"I'm lost, where should I go?\");\n\t\tthis.DESPAWN_PHRASES.add(\"Nothing left for me here...\");\n\t\tthis.DESPAWN_DELAY = 24000;\n\t\tthis.TRADES_COUNT = 10;\n\t\tthis.DEFAULT_TRADE = new Trade(new Product(null, 0, 10, null), null, new Product(Items.DIAMOND, 0, 1, null), 5000);\t\t\n\t}\n\n}", "class_id": 0, "repo": "KaptainWutax/QFM-Traders", "file": "src/main/java/kaptainwutax/traders/config/ConfigTom.java", "last_update_at": "2019-08-24T10:04:50+00:00", "question_id": "d30dac85ab1b54f9487f62d51c77e43b0066bfd3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ConfigTom extends ConfigTrades {\n\t@Expose public List<String> POI_LOSS_PHRASES = new ArrayList<String>();\n\t@Expose public List<String> DESPAWN_PHRASES = new ArrayList<String>();\n\t\n\t@Expose public int DESPAWN_DELAY;\n\t\n\t@Expose public int TRADES_COUNT;\n\tpublic ConfigTom() {\n\t}\n\t@Override\n\tpublic String getLocation() {\n\t\treturn \"tom.json\";\n\t}\n\t\n\t@Override\n\tprotected void resetConfig() {\n\t\tthis.POI_LOSS_PHRASES.add(\"I'm lost, where should I go?\");\n\t\tthis.DESPAWN_PHRASES.add(\"Nothing left for me here...\");\n\t\tthis.DESPAWN_DELAY = 24000;\n\t\tthis.TRADES_COUNT = 10;\n\t\tthis.DEFAULT_TRADE = new Trade(new Product(null, 0, 10, null), null, new Product(Items.DIAMOND, 0, 1, null), 5000);\t\t\n\t}\n"]]}
{"hexsha": "c2c16b5cc558ddafb2073ddf4944d0283cbe23d5", "ext": "java", "lang": "Java", "content": "class Average\n{\n\tpublic static void main ( String args[]) throws IOException\n\t{\n\t\tInputStreamReader ab= new InputStreamReader(System.in);\n\t\tBufferedReader cd= new BufferedReader(ab);\n\t\tSystem.out.println (\"Enter 3 numbers:\");\n\t\tint a,b,c;\n\t\tdouble d;\n\t\ta = Integer.parseInt(cd.readLine());\n\t\tb = Integer.parseInt(cd.readLine());\n\t       \tc = Integer.parseInt(cd.readLine());\n\t\td = (a+b+c)/3;\n\t\tSystem.out.println (\"Average =\"+d);\n\t}\n}", "class_id": 0, "repo": "SayanGhoshBDA/code-backup", "file": "java_backup/DAMAN_2019/Average.java", "last_update_at": "2019-05-08T10:09:52+00:00", "question_id": "c2c16b5cc558ddafb2073ddf4944d0283cbe23d5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Average\n{\n\tpublic static void main ( String args[]) throws IOException\n\t{\n\t\tInputStreamReader ab= new InputStreamReader(System.in);\n\t\tBufferedReader cd= new BufferedReader(ab);\n\t\tSystem.out.println (\"Enter 3 numbers:\");\n\t\tint a,b,c;\n\t\tdouble d;\n\t\ta = Integer.parseInt(cd.readLine());\n\t\tb = Integer.parseInt(cd.readLine());\n\t       \tc = Integer.parseInt(cd.readLine());\n\t\td = (a+b+c)/3;\n\t\tSystem.out.println (\"Average =\"+d);\n\t}\n"]]}
{"hexsha": "83b0701971c3d7b66b752f6c65dc65b3b294b67c", "ext": "java", "lang": "Java", "content": "class GitStubDownloader implements StubDownloader {\n\n\tprivate static final Log log = LogFactory.getLog(GitStubDownloader.class);\n\n\t// Preloading class for the shutdown hook not to throw ClassNotFound\n\tprivate static final Class CLAZZ = TemporaryFileStorage.class;\n\n\tprivate final StubRunnerOptions stubRunnerOptions;\n\n\tprivate final boolean deleteStubsAfterTest;\n\n\tprivate final GitContractsRepo gitContractsRepo;\n\n\tGitStubDownloader(StubRunnerOptions stubRunnerOptions) {\n\t\tthis.stubRunnerOptions = stubRunnerOptions;\n\t\tthis.deleteStubsAfterTest = this.stubRunnerOptions.isDeleteStubsAfterTest();\n\t\tthis.gitContractsRepo = new GitContractsRepo(stubRunnerOptions);\n\t\tregisterShutdownHook();\n\t}\n\n\t@Override\n\tpublic Map.Entry<StubConfiguration, File> downloadAndUnpackStubJar(\n\t\t\tStubConfiguration stubConfiguration) {\n\t\ttry {\n\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\tlog.debug(\"Trying to find a contract for [\"\n\t\t\t\t\t\t+ stubConfiguration.toColonSeparatedDependencyNotation() + \"]\");\n\t\t\t}\n\t\t\tResource repo = this.stubRunnerOptions.getStubRepositoryRoot();\n\t\t\tFile clonedRepo = this.gitContractsRepo.clonedRepo(repo);\n\t\t\tFileWalker walker = new FileWalker(stubConfiguration);\n\t\t\tFiles.walkFileTree(clonedRepo.toPath(), walker);\n\t\t\tif (walker.foundFile != null) {\n\t\t\t\treturn new AbstractMap.SimpleEntry<>(stubConfiguration,\n\t\t\t\t\t\twalker.foundFile.toFile());\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\tif (log.isWarnEnabled()) {\n\t\t\tlog.warn(\"No matching contracts were found in the repo for [\"\n\t\t\t\t\t+ stubConfiguration.toColonSeparatedDependencyNotation() + \"]\");\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate void registerShutdownHook() {\n\t\tRuntime.getRuntime().addShutdownHook(new Thread(() -> TemporaryFileStorage\n\t\t\t\t.cleanup(GitStubDownloader.this.deleteStubsAfterTest)));\n\t}\n\n}", "class_id": 2, "repo": "Dominick1993/spring-cloud-contract", "file": "spring-cloud-contract-stub-runner/src/main/java/org/springframework/cloud/contract/stubrunner/ScmStubDownloaderBuilder.java", "last_update_at": "2019-02-13T22:35:44+00:00", "question_id": "83b0701971c3d7b66b752f6c65dc65b3b294b67c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class GitStubDownloader implements StubDownloader {\n\tprivate static final Log log = LogFactory.getLog(GitStubDownloader.class);\n\t// Preloading class for the shutdown hook not to throw ClassNotFound\n\tprivate static final Class CLAZZ = TemporaryFileStorage.class;\n\tprivate final StubRunnerOptions stubRunnerOptions;\n\tprivate final boolean deleteStubsAfterTest;\n\tprivate final GitContractsRepo gitContractsRepo;\n\tGitStubDownloader(StubRunnerOptions stubRunnerOptions) {\n\t\tthis.stubRunnerOptions = stubRunnerOptions;\n\t\tthis.deleteStubsAfterTest = this.stubRunnerOptions.isDeleteStubsAfterTest();\n\t\tthis.gitContractsRepo = new GitContractsRepo(stubRunnerOptions);\n\t\tregisterShutdownHook();\n\t}\n\t@Override\n\tpublic Map.Entry<StubConfiguration, File> downloadAndUnpackStubJar(\n\t\t\tStubConfiguration stubConfiguration) {\n\t\ttry {\n\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\tlog.debug(\"Trying to find a contract for [\"\n\t\t\t\t\t\t+ stubConfiguration.toColonSeparatedDependencyNotation() + \"]\");\n\t\t\t}\n\t\t\tResource repo = this.stubRunnerOptions.getStubRepositoryRoot();\n\t\t\tFile clonedRepo = this.gitContractsRepo.clonedRepo(repo);\n\t\t\tFileWalker walker = new FileWalker(stubConfiguration);\n\t\t\tFiles.walkFileTree(clonedRepo.toPath(), walker);\n\t\t\tif (walker.foundFile != null) {\n\t\t\t\treturn new AbstractMap.SimpleEntry<>(stubConfiguration,\n\t\t\t\t\t\twalker.foundFile.toFile());\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\tif (log.isWarnEnabled()) {\n\t\t\tlog.warn(\"No matching contracts were found in the repo for [\"\n\t\t\t\t\t+ stubConfiguration.toColonSeparatedDependencyNotation() + \"]\");\n\t\t}\n\t\treturn null;\n\t}\n\tprivate void registerShutdownHook() {\n\t\tRuntime.getRuntime().addShutdownHook(new Thread(() -> TemporaryFileStorage\n\t\t\t\t.cleanup(GitStubDownloader.this.deleteStubsAfterTest)));\n\t}\n"]]}
{"hexsha": "bb2801aa233354e620a22506010470ba263a6a95", "ext": "java", "lang": "Java", "content": "public class ChainSkills {\n\n    private Map<String, ChainSkill> multiSkills = new FastMap<String, ChainSkill>();\n    private ChainSkill chainSkill = new ChainSkill(\"\", 0, 0);\n\n    //private Logger log = LoggerFactory.getLogger(ChainSkills.class);\n    public int getChainCount(Player player, SkillTemplate template, String category) {\n        if (category == null) {\n            return 0;\n        }\n        long nullTime = player.getSkillCoolDown(template.getCooldownId());\n        if (this.multiSkills.get(category) != null) {\n            if (System.currentTimeMillis() >= nullTime && this.multiSkills.get(category).getUseTime() <= nullTime) {\n                this.multiSkills.get(category).setChainCount(0);\n            }\n\n            return this.multiSkills.get(category).getChainCount();\n        }\n\n        return 0;\n    }\n\n    public long getLastChainUseTime(String category) {\n        if (this.multiSkills.get(category) != null) {\n            return this.multiSkills.get(category).getUseTime();\n        } else if (chainSkill.getCategory().equals(category)) {\n            return this.chainSkill.getUseTime();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * returns true if next chain skill can still be casted, or time is over\n     *\n     * @param category\n     * @param time\n     * @return\n     */\n    public boolean chainSkillEnabled(String category, int time) {\n        long useTime = 0;\n        if (this.multiSkills.get(category) != null) {\n            useTime = this.multiSkills.get(category).getUseTime();\n        } else if (chainSkill.getCategory().equals(category)) {\n            useTime = chainSkill.getUseTime();\n        }\n\n        if ((useTime + time) >= System.currentTimeMillis()) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public void addChainSkill(String category, boolean multiCast) {\n        if (multiCast) {\n            if (this.multiSkills.get(category) != null) {\n                if (multiCast) {\n                    this.multiSkills.get(category).increaseChainCount();\n                }\n                this.multiSkills.get(category).setUseTime(System.currentTimeMillis());\n            } else {\n                this.multiSkills.put(category, new ChainSkill(category, (multiCast ? 1 : 0), System.currentTimeMillis()));\n            }\n        } else {\n            chainSkill.updateChainSkill(category);\n        }\n    }\n\n    public Collection<ChainSkill> getChainSkills() {\n        Collection<ChainSkill> collection = new ArrayList<ChainSkill>();\n        collection.add(this.chainSkill);\n        collection.addAll(this.multiSkills.values());\n\n        return collection;\n    }\n}", "class_id": 0, "repo": "karllgiovany/Aion-Lightning-4.9-SRC", "file": "AL-Game/src/com/aionemu/gameserver/skillengine/model/ChainSkills.java", "last_update_at": "2019-04-05T22:05:41+00:00", "question_id": "bb2801aa233354e620a22506010470ba263a6a95", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ChainSkills {\n    private Map<String, ChainSkill> multiSkills = new FastMap<String, ChainSkill>();\n    private ChainSkill chainSkill = new ChainSkill(\"\", 0, 0);\n    //private Logger log = LoggerFactory.getLogger(ChainSkills.class);\n    public int getChainCount(Player player, SkillTemplate template, String category) {\n        if (category == null) {\n            return 0;\n        }\n        long nullTime = player.getSkillCoolDown(template.getCooldownId());\n        if (this.multiSkills.get(category) != null) {\n            if (System.currentTimeMillis() >= nullTime && this.multiSkills.get(category).getUseTime() <= nullTime) {\n                this.multiSkills.get(category).setChainCount(0);\n            }\n            return this.multiSkills.get(category).getChainCount();\n        }\n        return 0;\n    }\n    public long getLastChainUseTime(String category) {\n        if (this.multiSkills.get(category) != null) {\n            return this.multiSkills.get(category).getUseTime();\n        } else if (chainSkill.getCategory().equals(category)) {\n            return this.chainSkill.getUseTime();\n        } else {\n            return 0;\n        }\n    }\n    /**\n     * returns true if next chain skill can still be casted, or time is over\n     *\n     * @param category\n     * @param time\n     * @return\n     */\n    public boolean chainSkillEnabled(String category, int time) {\n        long useTime = 0;\n        if (this.multiSkills.get(category) != null) {\n            useTime = this.multiSkills.get(category).getUseTime();\n        } else if (chainSkill.getCategory().equals(category)) {\n            useTime = chainSkill.getUseTime();\n        }\n        if ((useTime + time) >= System.currentTimeMillis()) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    public void addChainSkill(String category, boolean multiCast) {\n        if (multiCast) {\n            if (this.multiSkills.get(category) != null) {\n                if (multiCast) {\n                    this.multiSkills.get(category).increaseChainCount();\n                }\n                this.multiSkills.get(category).setUseTime(System.currentTimeMillis());\n            } else {\n                this.multiSkills.put(category, new ChainSkill(category, (multiCast ? 1 : 0), System.currentTimeMillis()));\n            }\n        } else {\n            chainSkill.updateChainSkill(category);\n        }\n    }\n    public Collection<ChainSkill> getChainSkills() {\n        Collection<ChainSkill> collection = new ArrayList<ChainSkill>();\n        collection.add(this.chainSkill);\n        collection.addAll(this.multiSkills.values());\n        return collection;\n    }\n"]]}
{"hexsha": "acae353ff26e8aa7a37623fb47732b221f51e668", "ext": "java", "lang": "Java", "content": "@Test\npublic class BusinessDayConventionTest {\n\n  private static final LocalDate FRI_2014_07_11 = LocalDate.of(2014, 7, 11);\n  private static final LocalDate SAT_2014_07_12 = LocalDate.of(2014, 7, 12);\n  private static final LocalDate SUN_2014_07_13 = LocalDate.of(2014, 7, 13);\n  private static final LocalDate MON_2014_07_14 = LocalDate.of(2014, 7, 14);\n  private static final LocalDate TUE_2014_07_15 = LocalDate.of(2014, 7, 15);\n\n  private static final LocalDate FRI_2014_08_29 = LocalDate.of(2014, 8, 29);\n  private static final LocalDate SAT_2014_08_30 = LocalDate.of(2014, 8, 30);\n  private static final LocalDate SUN_2014_08_31 = LocalDate.of(2014, 8, 31);\n  private static final LocalDate MON_2014_09_01 = LocalDate.of(2014, 9, 1);\n\n  private static final LocalDate FRI_2014_10_31 = LocalDate.of(2014, 10, 31);\n  private static final LocalDate SAT_2014_11_01 = LocalDate.of(2014, 11, 1);\n  private static final LocalDate SUN_2014_11_02 = LocalDate.of(2014, 11, 2);\n  private static final LocalDate MON_2014_11_03 = LocalDate.of(2014, 11, 3);\n\n  private static final LocalDate FRI_2014_11_14 = LocalDate.of(2014, 11, 14);\n  private static final LocalDate SAT_2014_11_15 = LocalDate.of(2014, 11, 15);\n  private static final LocalDate SUN_2014_11_16 = LocalDate.of(2014, 11, 16);\n  private static final LocalDate MON_2014_11_17 = LocalDate.of(2014, 11, 17);\n\n  //-------------------------------------------------------------------------\n  @DataProvider(name = \"types\")\n  static Object[][] data_types() {\n    StandardBusinessDayConventions[] conv = StandardBusinessDayConventions.values();\n    Object[][] result = new Object[conv.length][];\n    for (int i = 0; i < conv.length; i++) {\n      result[i] = new Object[] {conv[i]};\n    }\n    return result;\n  }\n\n  @Test(dataProvider = \"types\")\n  public void test_null(BusinessDayConvention type) {\n    assertThrows(() -> type.adjust(null, HolidayCalendars.NO_HOLIDAYS), IllegalArgumentException.class);\n    assertThrows(() -> type.adjust(FRI_2014_11_14, null), IllegalArgumentException.class);\n    assertThrows(() -> type.adjust(null, null), IllegalArgumentException.class);\n  }\n\n  //-------------------------------------------------------------------------\n  @DataProvider(name = \"convention\")\n  static Object[][] data_convention() {\n    return new Object[][] {\n        {NO_ADJUST, FRI_2014_07_11, FRI_2014_07_11},\n        {NO_ADJUST, SAT_2014_07_12, SAT_2014_07_12},\n        {NO_ADJUST, SUN_2014_07_13, SUN_2014_07_13},\n        {NO_ADJUST, MON_2014_07_14, MON_2014_07_14},\n\n        {FOLLOWING, FRI_2014_07_11, FRI_2014_07_11},\n        {FOLLOWING, SAT_2014_07_12, MON_2014_07_14},\n        {FOLLOWING, SUN_2014_07_13, MON_2014_07_14},\n        {FOLLOWING, MON_2014_07_14, MON_2014_07_14},\n\n        {FOLLOWING, FRI_2014_08_29, FRI_2014_08_29},\n        {FOLLOWING, SAT_2014_08_30, MON_2014_09_01},\n        {FOLLOWING, SUN_2014_08_31, MON_2014_09_01},\n        {FOLLOWING, MON_2014_09_01, MON_2014_09_01},\n\n        {FOLLOWING, FRI_2014_10_31, FRI_2014_10_31},\n        {FOLLOWING, SAT_2014_11_01, MON_2014_11_03},\n        {FOLLOWING, SUN_2014_11_02, MON_2014_11_03},\n        {FOLLOWING, MON_2014_11_03, MON_2014_11_03},\n\n        {MODIFIED_FOLLOWING, FRI_2014_07_11, FRI_2014_07_11},\n        {MODIFIED_FOLLOWING, SAT_2014_07_12, MON_2014_07_14},\n        {MODIFIED_FOLLOWING, SUN_2014_07_13, MON_2014_07_14},\n        {MODIFIED_FOLLOWING, MON_2014_07_14, MON_2014_07_14},\n\n        {MODIFIED_FOLLOWING, FRI_2014_08_29, FRI_2014_08_29},\n        {MODIFIED_FOLLOWING, SAT_2014_08_30, FRI_2014_08_29},  // modified\n        {MODIFIED_FOLLOWING, SUN_2014_08_31, FRI_2014_08_29},  // modified\n        {MODIFIED_FOLLOWING, MON_2014_09_01, MON_2014_09_01},\n\n        {MODIFIED_FOLLOWING, FRI_2014_10_31, FRI_2014_10_31},\n        {MODIFIED_FOLLOWING, SAT_2014_11_01, MON_2014_11_03},\n        {MODIFIED_FOLLOWING, SUN_2014_11_02, MON_2014_11_03},\n        {MODIFIED_FOLLOWING, MON_2014_11_03, MON_2014_11_03},\n\n        {MODIFIED_FOLLOWING_BI_MONTHLY, FRI_2014_07_11, FRI_2014_07_11},\n        {MODIFIED_FOLLOWING_BI_MONTHLY, SAT_2014_07_12, MON_2014_07_14},\n        {MODIFIED_FOLLOWING_BI_MONTHLY, SUN_2014_07_13, MON_2014_07_14},\n        {MODIFIED_FOLLOWING_BI_MONTHLY, MON_2014_07_14, MON_2014_07_14},\n\n        {MODIFIED_FOLLOWING_BI_MONTHLY, FRI_2014_08_29, FRI_2014_08_29},\n        {MODIFIED_FOLLOWING_BI_MONTHLY, SAT_2014_08_30, FRI_2014_08_29},  // modified\n        {MODIFIED_FOLLOWING_BI_MONTHLY, SUN_2014_08_31, FRI_2014_08_29},  // modified\n        {MODIFIED_FOLLOWING_BI_MONTHLY, MON_2014_09_01, MON_2014_09_01},\n\n        {MODIFIED_FOLLOWING_BI_MONTHLY, FRI_2014_10_31, FRI_2014_10_31},\n        {MODIFIED_FOLLOWING_BI_MONTHLY, SAT_2014_11_01, MON_2014_11_03},\n        {MODIFIED_FOLLOWING_BI_MONTHLY, SUN_2014_11_02, MON_2014_11_03},\n        {MODIFIED_FOLLOWING_BI_MONTHLY, MON_2014_11_03, MON_2014_11_03},\n\n        {MODIFIED_FOLLOWING_BI_MONTHLY, FRI_2014_11_14, FRI_2014_11_14},\n        {MODIFIED_FOLLOWING_BI_MONTHLY, SAT_2014_11_15, FRI_2014_11_14},  // modified\n        {MODIFIED_FOLLOWING_BI_MONTHLY, SUN_2014_11_16, MON_2014_11_17},\n        {MODIFIED_FOLLOWING_BI_MONTHLY, MON_2014_11_17, MON_2014_11_17},\n\n        {PRECEDING, FRI_2014_07_11, FRI_2014_07_11},\n        {PRECEDING, SAT_2014_07_12, FRI_2014_07_11},\n        {PRECEDING, SUN_2014_07_13, FRI_2014_07_11},\n        {PRECEDING, MON_2014_07_14, MON_2014_07_14},\n\n        {PRECEDING, FRI_2014_08_29, FRI_2014_08_29},\n        {PRECEDING, SAT_2014_08_30, FRI_2014_08_29},\n        {PRECEDING, SUN_2014_08_31, FRI_2014_08_29},\n        {PRECEDING, MON_2014_09_01, MON_2014_09_01},\n\n        {PRECEDING, FRI_2014_10_31, FRI_2014_10_31},\n        {PRECEDING, SAT_2014_11_01, FRI_2014_10_31},\n        {PRECEDING, SUN_2014_11_02, FRI_2014_10_31},\n        {PRECEDING, MON_2014_11_03, MON_2014_11_03},\n\n        {MODIFIED_PRECEDING, FRI_2014_07_11, FRI_2014_07_11},\n        {MODIFIED_PRECEDING, SAT_2014_07_12, FRI_2014_07_11},\n        {MODIFIED_PRECEDING, SUN_2014_07_13, FRI_2014_07_11},\n        {MODIFIED_PRECEDING, MON_2014_07_14, MON_2014_07_14},\n\n        {MODIFIED_PRECEDING, FRI_2014_08_29, FRI_2014_08_29},\n        {MODIFIED_PRECEDING, SAT_2014_08_30, FRI_2014_08_29},\n        {MODIFIED_PRECEDING, SUN_2014_08_31, FRI_2014_08_29},\n        {MODIFIED_PRECEDING, MON_2014_09_01, MON_2014_09_01},\n\n        {MODIFIED_PRECEDING, FRI_2014_10_31, FRI_2014_10_31},\n        {MODIFIED_PRECEDING, SAT_2014_11_01, MON_2014_11_03},  // modified\n        {MODIFIED_PRECEDING, SUN_2014_11_02, MON_2014_11_03},  // modified\n        {MODIFIED_PRECEDING, MON_2014_11_03, MON_2014_11_03},\n\n        {NEAREST, FRI_2014_07_11, FRI_2014_07_11},\n        {NEAREST, SAT_2014_07_12, FRI_2014_07_11},\n        {NEAREST, SUN_2014_07_13, MON_2014_07_14},\n        {NEAREST, MON_2014_07_14, MON_2014_07_14},\n    };\n  }\n\n  @Test(dataProvider = \"convention\")\n  public void test_convention(BusinessDayConvention convention, LocalDate input, LocalDate expected) {\n    assertEquals(convention.adjust(input, HolidayCalendars.SAT_SUN), expected);\n  }\n\n  public void test_nearest() {\n    HolidayCalendar cal = ImmutableHolidayCalendar.of(\"Test\", ImmutableList.of(MON_2014_07_14), SATURDAY, SUNDAY);\n    assertEquals(NEAREST.adjust(FRI_2014_07_11, cal), FRI_2014_07_11);\n    assertEquals(NEAREST.adjust(SAT_2014_07_12, cal), FRI_2014_07_11);\n    assertEquals(NEAREST.adjust(SUN_2014_07_13, cal), TUE_2014_07_15);\n    assertEquals(NEAREST.adjust(MON_2014_07_14, cal), TUE_2014_07_15);\n  }\n\n  //-------------------------------------------------------------------------\n  @DataProvider(name = \"name\")\n  static Object[][] data_name() {\n    return new Object[][] {\n        {NO_ADJUST, \"NoAdjust\"},\n        {FOLLOWING, \"Following\"},\n        {MODIFIED_FOLLOWING, \"ModifiedFollowing\"},\n        {MODIFIED_FOLLOWING_BI_MONTHLY, \"ModifiedFollowingBiMonthly\"},\n        {PRECEDING, \"Preceding\"},\n        {MODIFIED_PRECEDING, \"ModifiedPreceding\"},\n        {NEAREST, \"Nearest\"},\n    };\n  }\n\n  @Test(dataProvider = \"name\")\n  public void test_name(BusinessDayConvention convention, String name) {\n    assertEquals(convention.getName(), name);\n  }\n\n  @Test(dataProvider = \"name\")\n  public void test_toString(BusinessDayConvention convention, String name) {\n    assertEquals(convention.toString(), name);\n  }\n\n  @Test(dataProvider = \"name\")\n  public void test_of_lookup(BusinessDayConvention convention, String name) {\n    assertEquals(BusinessDayConvention.of(name), convention);\n  }\n\n  @Test(dataProvider = \"name\")\n  public void test_extendedEnum(BusinessDayConvention convention, String name) {\n    ImmutableMap<String, BusinessDayConvention> map = BusinessDayConvention.extendedEnum().lookupAll();\n    assertEquals(map.get(name), convention);\n  }\n\n  public void test_of_lookup_notFound() {\n    assertThrows(() -> BusinessDayConvention.of(\"Rubbish\"), IllegalArgumentException.class);\n  }\n\n  public void test_of_lookup_null() {\n    assertThrows(() -> BusinessDayConvention.of(null), IllegalArgumentException.class);\n  }\n\n  //-------------------------------------------------------------------------\n  public void coverage() {\n    coverPrivateConstructor(BusinessDayConventions.class);\n    coverEnum(StandardBusinessDayConventions.class);\n  }\n\n  public void test_serialization() {\n    assertSerialization(NO_ADJUST);\n  }\n\n  public void test_jodaConvert() {\n    assertJodaConvert(BusinessDayConvention.class, NO_ADJUST);\n    assertJodaConvert(BusinessDayConvention.class, MODIFIED_FOLLOWING);\n  }\n\n}", "class_id": 0, "repo": "carrot-garden/quant_OG-Commons", "file": "modules/basics/src/test/java/com/opengamma/basics/date/BusinessDayConventionTest.java", "last_update_at": "2019-07-21T19:54:55+00:00", "question_id": "acae353ff26e8aa7a37623fb47732b221f51e668", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Test\npublic class BusinessDayConventionTest {\n  private static final LocalDate FRI_2014_07_11 = LocalDate.of(2014, 7, 11);\n  private static final LocalDate SAT_2014_07_12 = LocalDate.of(2014, 7, 12);\n  private static final LocalDate SUN_2014_07_13 = LocalDate.of(2014, 7, 13);\n  private static final LocalDate MON_2014_07_14 = LocalDate.of(2014, 7, 14);\n  private static final LocalDate TUE_2014_07_15 = LocalDate.of(2014, 7, 15);\n  private static final LocalDate FRI_2014_08_29 = LocalDate.of(2014, 8, 29);\n  private static final LocalDate SAT_2014_08_30 = LocalDate.of(2014, 8, 30);\n  private static final LocalDate SUN_2014_08_31 = LocalDate.of(2014, 8, 31);\n  private static final LocalDate MON_2014_09_01 = LocalDate.of(2014, 9, 1);\n  private static final LocalDate FRI_2014_10_31 = LocalDate.of(2014, 10, 31);\n  private static final LocalDate SAT_2014_11_01 = LocalDate.of(2014, 11, 1);\n  private static final LocalDate SUN_2014_11_02 = LocalDate.of(2014, 11, 2);\n  private static final LocalDate MON_2014_11_03 = LocalDate.of(2014, 11, 3);\n  private static final LocalDate FRI_2014_11_14 = LocalDate.of(2014, 11, 14);\n  private static final LocalDate SAT_2014_11_15 = LocalDate.of(2014, 11, 15);\n  private static final LocalDate SUN_2014_11_16 = LocalDate.of(2014, 11, 16);\n  private static final LocalDate MON_2014_11_17 = LocalDate.of(2014, 11, 17);\n  //-------------------------------------------------------------------------\n  @DataProvider(name = \"types\")\n  static Object[][] data_types() {\n    StandardBusinessDayConventions[] conv = StandardBusinessDayConventions.values();\n    Object[][] result = new Object[conv.length][];\n    for (int i = 0; i < conv.length; i++) {\n      result[i] = new Object[] {conv[i]};\n    }\n    return result;\n  }\n  @Test(dataProvider = \"types\")\n  public void test_null(BusinessDayConvention type) {\n    assertThrows(() -> type.adjust(null, HolidayCalendars.NO_HOLIDAYS), IllegalArgumentException.class);\n    assertThrows(() -> type.adjust(FRI_2014_11_14, null), IllegalArgumentException.class);\n    assertThrows(() -> type.adjust(null, null), IllegalArgumentException.class);\n  }\n  //-------------------------------------------------------------------------\n  @DataProvider(name = \"convention\")\n  static Object[][] data_convention() {\n    return new Object[][] {\n        {NO_ADJUST, FRI_2014_07_11, FRI_2014_07_11},\n        {NO_ADJUST, SAT_2014_07_12, SAT_2014_07_12},\n        {NO_ADJUST, SUN_2014_07_13, SUN_2014_07_13},\n        {NO_ADJUST, MON_2014_07_14, MON_2014_07_14},\n        {FOLLOWING, FRI_2014_07_11, FRI_2014_07_11},\n        {FOLLOWING, SAT_2014_07_12, MON_2014_07_14},\n        {FOLLOWING, SUN_2014_07_13, MON_2014_07_14},\n        {FOLLOWING, MON_2014_07_14, MON_2014_07_14},\n        {FOLLOWING, FRI_2014_08_29, FRI_2014_08_29},\n        {FOLLOWING, SAT_2014_08_30, MON_2014_09_01},\n        {FOLLOWING, SUN_2014_08_31, MON_2014_09_01},\n        {FOLLOWING, MON_2014_09_01, MON_2014_09_01},\n        {FOLLOWING, FRI_2014_10_31, FRI_2014_10_31},\n        {FOLLOWING, SAT_2014_11_01, MON_2014_11_03},\n        {FOLLOWING, SUN_2014_11_02, MON_2014_11_03},\n        {FOLLOWING, MON_2014_11_03, MON_2014_11_03},\n        {MODIFIED_FOLLOWING, FRI_2014_07_11, FRI_2014_07_11},\n        {MODIFIED_FOLLOWING, SAT_2014_07_12, MON_2014_07_14},\n        {MODIFIED_FOLLOWING, SUN_2014_07_13, MON_2014_07_14},\n        {MODIFIED_FOLLOWING, MON_2014_07_14, MON_2014_07_14},\n        {MODIFIED_FOLLOWING, FRI_2014_08_29, FRI_2014_08_29},\n        {MODIFIED_FOLLOWING, SAT_2014_08_30, FRI_2014_08_29},  // modified\n        {MODIFIED_FOLLOWING, SUN_2014_08_31, FRI_2014_08_29},  // modified\n        {MODIFIED_FOLLOWING, MON_2014_09_01, MON_2014_09_01},\n        {MODIFIED_FOLLOWING, FRI_2014_10_31, FRI_2014_10_31},\n        {MODIFIED_FOLLOWING, SAT_2014_11_01, MON_2014_11_03},\n        {MODIFIED_FOLLOWING, SUN_2014_11_02, MON_2014_11_03},\n        {MODIFIED_FOLLOWING, MON_2014_11_03, MON_2014_11_03},\n        {MODIFIED_FOLLOWING_BI_MONTHLY, FRI_2014_07_11, FRI_2014_07_11},\n        {MODIFIED_FOLLOWING_BI_MONTHLY, SAT_2014_07_12, MON_2014_07_14},\n        {MODIFIED_FOLLOWING_BI_MONTHLY, SUN_2014_07_13, MON_2014_07_14},\n        {MODIFIED_FOLLOWING_BI_MONTHLY, MON_2014_07_14, MON_2014_07_14},\n        {MODIFIED_FOLLOWING_BI_MONTHLY, FRI_2014_08_29, FRI_2014_08_29},\n        {MODIFIED_FOLLOWING_BI_MONTHLY, SAT_2014_08_30, FRI_2014_08_29},  // modified\n        {MODIFIED_FOLLOWING_BI_MONTHLY, SUN_2014_08_31, FRI_2014_08_29},  // modified\n        {MODIFIED_FOLLOWING_BI_MONTHLY, MON_2014_09_01, MON_2014_09_01},\n        {MODIFIED_FOLLOWING_BI_MONTHLY, FRI_2014_10_31, FRI_2014_10_31},\n        {MODIFIED_FOLLOWING_BI_MONTHLY, SAT_2014_11_01, MON_2014_11_03},\n        {MODIFIED_FOLLOWING_BI_MONTHLY, SUN_2014_11_02, MON_2014_11_03},\n        {MODIFIED_FOLLOWING_BI_MONTHLY, MON_2014_11_03, MON_2014_11_03},\n        {MODIFIED_FOLLOWING_BI_MONTHLY, FRI_2014_11_14, FRI_2014_11_14},\n        {MODIFIED_FOLLOWING_BI_MONTHLY, SAT_2014_11_15, FRI_2014_11_14},  // modified\n        {MODIFIED_FOLLOWING_BI_MONTHLY, SUN_2014_11_16, MON_2014_11_17},\n        {MODIFIED_FOLLOWING_BI_MONTHLY, MON_2014_11_17, MON_2014_11_17},\n        {PRECEDING, FRI_2014_07_11, FRI_2014_07_11},\n        {PRECEDING, SAT_2014_07_12, FRI_2014_07_11},\n        {PRECEDING, SUN_2014_07_13, FRI_2014_07_11},\n        {PRECEDING, MON_2014_07_14, MON_2014_07_14},\n        {PRECEDING, FRI_2014_08_29, FRI_2014_08_29},\n        {PRECEDING, SAT_2014_08_30, FRI_2014_08_29},\n        {PRECEDING, SUN_2014_08_31, FRI_2014_08_29},\n        {PRECEDING, MON_2014_09_01, MON_2014_09_01},\n        {PRECEDING, FRI_2014_10_31, FRI_2014_10_31},\n        {PRECEDING, SAT_2014_11_01, FRI_2014_10_31},\n        {PRECEDING, SUN_2014_11_02, FRI_2014_10_31},\n        {PRECEDING, MON_2014_11_03, MON_2014_11_03},\n        {MODIFIED_PRECEDING, FRI_2014_07_11, FRI_2014_07_11},\n        {MODIFIED_PRECEDING, SAT_2014_07_12, FRI_2014_07_11},\n        {MODIFIED_PRECEDING, SUN_2014_07_13, FRI_2014_07_11},\n        {MODIFIED_PRECEDING, MON_2014_07_14, MON_2014_07_14},\n        {MODIFIED_PRECEDING, FRI_2014_08_29, FRI_2014_08_29},\n        {MODIFIED_PRECEDING, SAT_2014_08_30, FRI_2014_08_29},\n        {MODIFIED_PRECEDING, SUN_2014_08_31, FRI_2014_08_29},\n        {MODIFIED_PRECEDING, MON_2014_09_01, MON_2014_09_01},\n        {MODIFIED_PRECEDING, FRI_2014_10_31, FRI_2014_10_31},\n        {MODIFIED_PRECEDING, SAT_2014_11_01, MON_2014_11_03},  // modified\n        {MODIFIED_PRECEDING, SUN_2014_11_02, MON_2014_11_03},  // modified\n        {MODIFIED_PRECEDING, MON_2014_11_03, MON_2014_11_03},\n        {NEAREST, FRI_2014_07_11, FRI_2014_07_11},\n        {NEAREST, SAT_2014_07_12, FRI_2014_07_11},\n        {NEAREST, SUN_2014_07_13, MON_2014_07_14},\n        {NEAREST, MON_2014_07_14, MON_2014_07_14},\n    };\n  }\n  @Test(dataProvider = \"convention\")\n  public void test_convention(BusinessDayConvention convention, LocalDate input, LocalDate expected) {\n    assertEquals(convention.adjust(input, HolidayCalendars.SAT_SUN), expected);\n  }\n  public void test_nearest() {\n    HolidayCalendar cal = ImmutableHolidayCalendar.of(\"Test\", ImmutableList.of(MON_2014_07_14), SATURDAY, SUNDAY);\n    assertEquals(NEAREST.adjust(FRI_2014_07_11, cal), FRI_2014_07_11);\n    assertEquals(NEAREST.adjust(SAT_2014_07_12, cal), FRI_2014_07_11);\n    assertEquals(NEAREST.adjust(SUN_2014_07_13, cal), TUE_2014_07_15);\n    assertEquals(NEAREST.adjust(MON_2014_07_14, cal), TUE_2014_07_15);\n  }\n  //-------------------------------------------------------------------------\n  @DataProvider(name = \"name\")\n  static Object[][] data_name() {\n    return new Object[][] {\n        {NO_ADJUST, \"NoAdjust\"},\n        {FOLLOWING, \"Following\"},\n        {MODIFIED_FOLLOWING, \"ModifiedFollowing\"},\n        {MODIFIED_FOLLOWING_BI_MONTHLY, \"ModifiedFollowingBiMonthly\"},\n        {PRECEDING, \"Preceding\"},\n        {MODIFIED_PRECEDING, \"ModifiedPreceding\"},\n        {NEAREST, \"Nearest\"},\n    };\n  }\n  @Test(dataProvider = \"name\")\n  public void test_name(BusinessDayConvention convention, String name) {\n    assertEquals(convention.getName(), name);\n  }\n  @Test(dataProvider = \"name\")\n  public void test_toString(BusinessDayConvention convention, String name) {\n    assertEquals(convention.toString(), name);\n  }\n  @Test(dataProvider = \"name\")\n  public void test_of_lookup(BusinessDayConvention convention, String name) {\n    assertEquals(BusinessDayConvention.of(name), convention);\n  }\n  @Test(dataProvider = \"name\")\n  public void test_extendedEnum(BusinessDayConvention convention, String name) {\n    ImmutableMap<String, BusinessDayConvention> map = BusinessDayConvention.extendedEnum().lookupAll();\n    assertEquals(map.get(name), convention);\n  }\n  public void test_of_lookup_notFound() {\n    assertThrows(() -> BusinessDayConvention.of(\"Rubbish\"), IllegalArgumentException.class);\n  }\n  public void test_of_lookup_null() {\n    assertThrows(() -> BusinessDayConvention.of(null), IllegalArgumentException.class);\n  }\n  //-------------------------------------------------------------------------\n  public void coverage() {\n    coverPrivateConstructor(BusinessDayConventions.class);\n    coverEnum(StandardBusinessDayConventions.class);\n  }\n  public void test_serialization() {\n    assertSerialization(NO_ADJUST);\n  }\n  public void test_jodaConvert() {\n    assertJodaConvert(BusinessDayConvention.class, NO_ADJUST);\n    assertJodaConvert(BusinessDayConvention.class, MODIFIED_FOLLOWING);\n  }\n"]]}
{"hexsha": "9111a20a4d82522445b4ded8983b79e919e38c0d", "ext": "java", "lang": "Java", "content": "public class ArrayInstance extends Instance {\n\n    private final Type mType;\n\n    private final int mLength;\n\n    private final long mValuesOffset;\n\n    public ArrayInstance(long id, @NonNull StackTrace stack, @NonNull Type type, int length,\n            long valuesOffset) {\n        super(id, stack);\n        mType = type;\n        mLength = length;\n        mValuesOffset = valuesOffset;\n    }\n\n    @NonNull\n    public Object[] getValues() {\n        Object[] values = new Object[mLength];\n\n        getBuffer().setPosition(mValuesOffset);\n        for (int i = 0; i < mLength; i++) {\n            values[i] = readValue(mType);\n        }\n        return values;\n    }\n\n    @NonNull\n    public byte[] asRawByteArray(int start, int elementCount) {\n        getBuffer().setPosition(mValuesOffset);\n        assert mType != Type.OBJECT;\n        assert start + elementCount <= mLength;\n        byte[] bytes = new byte[elementCount * mType.getSize()];\n        getBuffer().readSubSequence(bytes, start * mType.getSize(), elementCount * mType.getSize());\n        return bytes;\n    }\n\n    @NonNull\n    public char[] asCharArray(int offset, int length) {\n        assert mType == Type.CHAR;\n        // TODO: Make this copy less by supporting offset in asRawByteArray.\n        CharBuffer charBuffer = ByteBuffer.wrap(asRawByteArray(offset, length)).order(\n                DataBuffer.HPROF_BYTE_ORDER).asCharBuffer();\n        char[] result = new char[length];\n        charBuffer.get(result);\n        return result;\n    }\n\n    @Override\n    public final int getSize() {\n        // TODO: Take the rest of the fields into account: length, type, etc (~16 bytes).\n        return mLength * mHeap.mSnapshot.getTypeSize(mType);\n    }\n\n    @Override\n    public final void resolveReferences() {\n        if (mType == Type.OBJECT) {\n            for (Object value : getValues()) {\n                if (value instanceof Instance) {\n                    ((Instance)value).addReverseReference(null, this);\n                    mHardForwardReferences.add((Instance)value);\n                }\n            }\n        }\n    }\n\n    @Override\n    public final void accept(@NonNull Visitor visitor) {\n        visitor.visitArrayInstance(this);\n        for (Instance instance : mHardForwardReferences) {\n            visitor.visitLater(this, instance);\n        }\n    }\n\n    @Override\n    public ClassObj getClassObj() {\n        if (mType == Type.OBJECT) {\n            return super.getClassObj();\n        } else {\n            // Primitive arrays don't set their classId, we need to do the lookup manually.\n            ClassObj primitiveArrayClassObj =\n                    mHeap.mSnapshot.findClass(mType.getClassNameOfPrimitiveArray(false));\n            if (primitiveArrayClassObj == null) {\n                // We might not be parsing an Android hprof.\n                primitiveArrayClassObj =\n                        mHeap.mSnapshot.findClass(mType.getClassNameOfPrimitiveArray(true));\n            }\n            return primitiveArrayClassObj;\n        }\n    }\n\n    /**\n     * Returns the number of elements in the array.\n     */\n    public int getLength() {\n        return mLength;\n    }\n\n    public Type getArrayType() {\n        return mType;\n    }\n\n    public final String toString() {\n        String className = getClassObj().getClassName();\n        if (className.endsWith(\"[]\")) {\n            className = className.substring(0, className.length() - 2);\n        }\n        return String.format(\"%s[%d]@%d (0x%x)\", className, mLength, getUniqueId(), getUniqueId());\n    }\n}", "class_id": 0, "repo": "jomof/CppBuildCacheWorkInProgress", "file": "agp-7.1.0-alpha01/tools/base/perflib/src/main/java/com/android/tools/perflib/heap/ArrayInstance.java", "last_update_at": "2019-12-04T11:34:36+00:00", "question_id": "9111a20a4d82522445b4ded8983b79e919e38c0d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ArrayInstance extends Instance {\n    private final Type mType;\n    private final int mLength;\n    private final long mValuesOffset;\n    public ArrayInstance(long id, @NonNull StackTrace stack, @NonNull Type type, int length,\n            long valuesOffset) {\n        super(id, stack);\n        mType = type;\n        mLength = length;\n        mValuesOffset = valuesOffset;\n    }\n    @NonNull\n    public Object[] getValues() {\n        Object[] values = new Object[mLength];\n        getBuffer().setPosition(mValuesOffset);\n        for (int i = 0; i < mLength; i++) {\n            values[i] = readValue(mType);\n        }\n        return values;\n    }\n    @NonNull\n    public byte[] asRawByteArray(int start, int elementCount) {\n        getBuffer().setPosition(mValuesOffset);\n        assert mType != Type.OBJECT;\n        assert start + elementCount <= mLength;\n        byte[] bytes = new byte[elementCount * mType.getSize()];\n        getBuffer().readSubSequence(bytes, start * mType.getSize(), elementCount * mType.getSize());\n        return bytes;\n    }\n    @NonNull\n    public char[] asCharArray(int offset, int length) {\n        assert mType == Type.CHAR;\n        // TODO: Make this copy less by supporting offset in asRawByteArray.\n        CharBuffer charBuffer = ByteBuffer.wrap(asRawByteArray(offset, length)).order(\n                DataBuffer.HPROF_BYTE_ORDER).asCharBuffer();\n        char[] result = new char[length];\n        charBuffer.get(result);\n        return result;\n    }\n    @Override\n    public final int getSize() {\n        // TODO: Take the rest of the fields into account: length, type, etc (~16 bytes).\n        return mLength * mHeap.mSnapshot.getTypeSize(mType);\n    }\n    @Override\n    public final void resolveReferences() {\n        if (mType == Type.OBJECT) {\n            for (Object value : getValues()) {\n                if (value instanceof Instance) {\n                    ((Instance)value).addReverseReference(null, this);\n                    mHardForwardReferences.add((Instance)value);\n                }\n            }\n        }\n    }\n    @Override\n    public final void accept(@NonNull Visitor visitor) {\n        visitor.visitArrayInstance(this);\n        for (Instance instance : mHardForwardReferences) {\n            visitor.visitLater(this, instance);\n        }\n    }\n    @Override\n    public ClassObj getClassObj() {\n        if (mType == Type.OBJECT) {\n            return super.getClassObj();\n        } else {\n            // Primitive arrays don't set their classId, we need to do the lookup manually.\n            ClassObj primitiveArrayClassObj =\n                    mHeap.mSnapshot.findClass(mType.getClassNameOfPrimitiveArray(false));\n            if (primitiveArrayClassObj == null) {\n                // We might not be parsing an Android hprof.\n                primitiveArrayClassObj =\n                        mHeap.mSnapshot.findClass(mType.getClassNameOfPrimitiveArray(true));\n            }\n            return primitiveArrayClassObj;\n        }\n    }\n    /**\n     * Returns the number of elements in the array.\n     */\n    public int getLength() {\n        return mLength;\n    }\n    public Type getArrayType() {\n        return mType;\n    }\n    public final String toString() {\n        String className = getClassObj().getClassName();\n        if (className.endsWith(\"[]\")) {\n            className = className.substring(0, className.length() - 2);\n        }\n        return String.format(\"%s[%d]@%d (0x%x)\", className, mLength, getUniqueId(), getUniqueId());\n    }\n"]]}
{"hexsha": "4146c44e5ff63502d4479ee779b916a7238ff048", "ext": "java", "lang": "Java", "content": "public class TilkjentYtelseV1Test {\n\n    private static ObjectMapper mapper = getObjectMapper();\n\n    @Test\n    public void skal_serialisere_riktig() throws JsonProcessingException {\n        TilkjentYtelseBehandlingInfoV1 info = new TilkjentYtelseBehandlingInfoV1()\n                .setAkt\u00f8rId(\"9000012345678\")\n                .setSaksnummer(\"2525253\")\n                .setBehandlingId(100000123)\n                .setVedtaksdato(LocalDate.of(2019, 3, 10))\n                .setGjelderAdopsjon(false)\n                .setAnsvarligSaksbehandler(\"Z000001\")\n                .setYtelseType(TilkjentYtelseV1.YtelseType.FORELDREPENGER);\n        var andeler1 = new ArrayList<TilkjentYtelseAndelV1>();\n        andeler1.add(TilkjentYtelseAndelV1.tilBruker(FRILANSER, 100L, DAGSATS));\n        andeler1.add(TilkjentYtelseAndelV1.refusjon(ARBEIDSTAKER, 1000L, DAGSATS).medArbeidsgiverOrgNr(\"123123123\"));\n        var andeler2 = new ArrayList<TilkjentYtelseAndelV1>();\n        andeler2.add(TilkjentYtelseAndelV1.tilBruker(FRILANSER, 135L, DAGSATS));\n        andeler2.add(TilkjentYtelseAndelV1.refusjon(ARBEIDSTAKER, 1586L, DAGSATS).medArbeidsgiverOrgNr(\"123123123\").leggTilFeriepenger(Year.of(2018), 187));\n\n        var perioder = new ArrayList<TilkjentYtelsePeriodeV1>();\n        perioder.add(new TilkjentYtelsePeriodeV1(LocalDate.of(2018, 12, 24), LocalDate.of(2019, 2, 28), andeler1));\n        perioder.add(new TilkjentYtelsePeriodeV1(LocalDate.of(2019, 3, 1), LocalDate.of(2019, 3, 31), andeler2));\n        TilkjentYtelse tilkjentYtelseV1 = new TilkjentYtelseV1(info, perioder)\n                .setErOpph\u00f8r(true)\n                .setErOpph\u00f8rEtterSkj\u00e6ringstidspunkt(false);\n\n        String resultat = mapper.writeValueAsString(tilkjentYtelseV1);\n\n        //hvis du endrer noe slik at denne testen feiler, har du gjort noe galt! Endringene du \u00f8nsker krever at du oppretter en ny versjon av TilkjentYtelse\n        assertThat(resultat).isEqualTo(\"{\\\"version\\\":\\\"1.0\\\",\\\"behandingsinfo\\\":{\\\"aktoerId\\\":\\\"9000012345678\\\",\\\"saksnummer\\\":\\\"2525253\\\",\\\"behandlingId\\\":100000123,\\\"ytelseType\\\":\\\"FORELDREPENGER\\\",\\\"gjelderAdopsjon\\\":false,\\\"vedtaksdato\\\":\\\"2019-03-10\\\",\\\"ansvarligSaksbehandler\\\":\\\"Z000001\\\"},\\\"perioder\\\":[{\\\"fom\\\":\\\"2018-12-24\\\",\\\"tom\\\":\\\"2019-02-28\\\",\\\"andeler\\\":[{\\\"utbetalesTilBruker\\\":true,\\\"inntektskategori\\\":\\\"FRILANSER\\\",\\\"satsType\\\":\\\"DAGSATS\\\",\\\"satsBeloep\\\":100},{\\\"utbetalesTilBruker\\\":false,\\\"arbeidsgiverOrgNr\\\":\\\"123123123\\\",\\\"inntektskategori\\\":\\\"ARBEIDSTAKER\\\",\\\"satsType\\\":\\\"DAGSATS\\\",\\\"satsBeloep\\\":1000}]},{\\\"fom\\\":\\\"2019-03-01\\\",\\\"tom\\\":\\\"2019-03-31\\\",\\\"andeler\\\":[{\\\"utbetalesTilBruker\\\":true,\\\"inntektskategori\\\":\\\"FRILANSER\\\",\\\"satsType\\\":\\\"DAGSATS\\\",\\\"satsBeloep\\\":135},{\\\"utbetalesTilBruker\\\":false,\\\"arbeidsgiverOrgNr\\\":\\\"123123123\\\",\\\"inntektskategori\\\":\\\"ARBEIDSTAKER\\\",\\\"satsType\\\":\\\"DAGSATS\\\",\\\"feriepenger\\\":[{\\\"opptjeningsaar\\\":2018,\\\"beloep\\\":187}],\\\"satsBeloep\\\":1586}]}],\\\"erOpphoer\\\":true,\\\"erOpphoerEtterSkjaeringTidspunkt\\\":false}\");\n    }\n\n    @Test\n    public void skal_serialisere_og_deserialisere_med_feriepenger() throws IOException, ParseException {\n        TilkjentYtelseBehandlingInfoV1 info = new TilkjentYtelseBehandlingInfoV1()\n                .setAkt\u00f8rId(\"90000123\")\n                .setSaksnummer(\"2525253\")\n                .setBehandlingId(100000123)\n                .setVedtaksdato(LocalDate.of(2019, 3, 10))\n                .setGjelderAdopsjon(false)\n                .setAnsvarligSaksbehandler(\"Z000001\")\n                .setYtelseType(TilkjentYtelseV1.YtelseType.FORELDREPENGER);\n        var andeler = new ArrayList<TilkjentYtelseAndelV1>();\n        andeler.add(TilkjentYtelseAndelV1.tilBruker(FRILANSER, 100L, DAGSATS).leggTilFeriepenger(Year.of(2018), 12));\n\n        var perioder = new ArrayList<TilkjentYtelsePeriodeV1>();\n        perioder.add(new TilkjentYtelsePeriodeV1(LocalDate.of(2018, 12, 24), LocalDate.of(2019, 2, 28), andeler));\n        TilkjentYtelse tilkjentYtelseV1 = new TilkjentYtelseV1(info, perioder)\n                .setEndringsdato(LocalDate.of(2018, 12, 27));\n\n        String json = mapper.writeValueAsString(tilkjentYtelseV1);\n        TilkjentYtelse resultat = mapper.readValue(json, TilkjentYtelse.class);\n        assertThat(resultat).isInstanceOf(TilkjentYtelseV1.class);\n\n        TilkjentYtelseV1 ty = (TilkjentYtelseV1) resultat;\n        ty.kryssvalider();\n\n        assertThat(ty.getEndringsdato()).isEqualTo(LocalDate.of(2018, 12, 27));\n        TilkjentYtelseAndelV1 andel = ty.getPerioder().iterator().next().getAndeler().iterator().next();\n        List<TilkjentYtelseFeriepengerV1> feriepenger = andel.getFeriepenger();\n        assertThat(feriepenger).hasSize(1);\n        assertThat(feriepenger.get(0).getBel\u00f8p()).isEqualTo(12);\n        assertThat(feriepenger.get(0).getOpptjenings\u00e5r()).isEqualTo(2018);\n    }\n\n    @Test\n    public void skal_deserialisere() throws IOException, ParseException {\n        TilkjentYtelse resultat = mapper.readValue(\"{\\\"version\\\":\\\"1.0\\\",\\\"behandingsinfo\\\":{\\\"saksnummer\\\":\\\"2525253\\\",\\\"behandlingId\\\":100000123,\\\"ytelseType\\\":\\\"FORELDREPENGER\\\",\\\"gjelderAdopsjon\\\":false,\\\"vedtaksdato\\\":\\\"2019-03-10\\\",\\\"ansvarligSaksbehandler\\\":\\\"Z000001\\\",\\\"aktoerId\\\":\\\"90000123\\\"},\\\"perioder\\\":[{\\\"fom\\\":\\\"2018-12-24\\\",\\\"tom\\\":\\\"2019-02-28\\\",\\\"andeler\\\":[{\\\"utbetalesTilBruker\\\":true,\\\"inntektskategori\\\":\\\"FRILANSER\\\",\\\"satsType\\\":\\\"DAGSATS\\\",\\\"satsBeloep\\\":100},{\\\"utbetalesTilBruker\\\":false,\\\"arbeidsgiverOrgNr\\\":\\\"123123123\\\",\\\"inntektskategori\\\":\\\"ARBEIDSTAKER\\\",\\\"satsType\\\":\\\"DAGSATS\\\",\\\"satsBeloep\\\":1000}]},{\\\"fom\\\":\\\"2019-03-01\\\",\\\"tom\\\":\\\"2019-03-31\\\",\\\"andeler\\\":[{\\\"utbetalesTilBruker\\\":true,\\\"inntektskategori\\\":\\\"FRILANSER\\\",\\\"satsType\\\":\\\"DAGSATS\\\",\\\"satsBeloep\\\":135},{\\\"utbetalesTilBruker\\\":false,\\\"arbeidsgiverOrgNr\\\":\\\"123123123\\\",\\\"inntektskategori\\\":\\\"ARBEIDSTAKER\\\",\\\"satsType\\\":\\\"DAGSATS\\\",\\\"feriepenger\\\":[{\\\"opptjeningsaar\\\":2018,\\\"beloep\\\":187}],\\\"satsBeloep\\\":1586}]}],\\\"erOpphoer\\\":true,\\\"erOpphoerEtterSkjaeringTidspunkt\\\":false}\", TilkjentYtelse.class);\n\n        assertThat(resultat).isInstanceOf(TilkjentYtelseV1.class);\n\n        TilkjentYtelseV1 ty = (TilkjentYtelseV1) resultat;\n        ty.kryssvalider();\n        TilkjentYtelseBehandlingInfoV1 info = ty.getBehandingsinfo();\n        assertThat(info.getAkt\u00f8rId()).isEqualTo(\"90000123\");\n        assertThat(info.getSaksnummer()).isEqualTo(\"2525253\");\n        assertThat(info.getBehandlingId()).isEqualTo(100000123);\n        assertThat(info.getVedtaksdato()).isEqualTo(LocalDate.of(2019, 3, 10));\n        assertThat(info.isGjelderAdopsjon()).isFalse();\n        assertThat(info.getAnsvarligSaksbehandler()).isEqualTo(\"Z000001\");\n        assertThat(info.getYtelseType()).isEqualTo(TilkjentYtelseV1.YtelseType.FORELDREPENGER);\n\n        assertThat(ty.getPerioder()).hasSize(2);\n        TilkjentYtelsePeriodeV1 periode = ty.getPerioder().iterator().next();\n        assertThat(periode.getAndeler()).hasSize(2);\n        assertThat(periode.getFom()).isEqualTo(LocalDate.of(2018, 12, 24));\n        assertThat(periode.getTom()).isEqualTo(LocalDate.of(2019, 2, 28));\n        Iterator<TilkjentYtelseAndelV1> andeler = periode.getAndeler().iterator();\n        TilkjentYtelseAndelV1 andel1 = andeler.next();\n        assertThat(andel1.getUtbetalesTilBruker()).isTrue();\n        assertThat(andel1.getInntektskategori()).isEqualTo(TilkjentYtelseV1.Inntektskategori.FRILANSER);\n        assertThat(andel1.getSatsBel\u00f8p()).isEqualTo(100);\n        assertThat(andel1.getSatsType()).isEqualTo(TilkjentYtelseV1.SatsType.DAGSATS);\n        assertThat(andel1.getArbeidsgiverOrgNr()).isNull();\n        assertThat(andel1.getArbeidsgiverAkt\u00f8rId()).isNull();\n        TilkjentYtelseAndelV1 andel2 = andeler.next();\n        assertThat(andel2.getUtbetalesTilBruker()).isFalse();\n        assertThat(andel2.getInntektskategori()).isEqualTo(TilkjentYtelseV1.Inntektskategori.ARBEIDSTAKER);\n        assertThat(andel2.getSatsBel\u00f8p()).isEqualTo(1000);\n        assertThat(andel2.getSatsType()).isEqualTo(TilkjentYtelseV1.SatsType.DAGSATS);\n        assertThat(andel2.getArbeidsgiverOrgNr()).isEqualTo(\"123123123\");\n        assertThat(andel2.getArbeidsgiverAkt\u00f8rId()).isNull();\n    }\n\n    @Test\n    public void skal_ikke_deserialisere_ukjent_versjon() {\n        assertThrows(InvalidTypeIdException.class, () -> mapper.readValue(\"{\\\"version\\\":\\\"1000.0\\\",\\\"behandingsinfo\\\":{\\\"aktoerId\\\":90000123,\\\"saksnummer\\\":\\\"2525253\\\",\\\"behandlingId\\\":100000123,\\\"ytelseType\\\":\\\"FORELDREPENGER\\\",\\\"gjelderAdopsjon\\\":false,\\\"vedtaksdato\\\":\\\"2019-03-10\\\",\\\"ansvarligSaksbehandler\\\":\\\"Z000001\\\",\\\"ansvarligBeslutter\\\":\\\"Z222222\\\"},\\\"perioder\\\":[{\\\"fom\\\":\\\"2018-12-24\\\",\\\"tom\\\":\\\"2019-02-28\\\",\\\"andeler\\\":[{\\\"inntektskategori\\\":\\\"FRILANSER\\\",\\\"satsBel\u00f8p\\\":100,\\\"satsType\\\":\\\"DAGSATS\\\"},{\\\"arbeidsgiverOrgNr\\\":\\\"123123123\\\",\\\"inntektskategori\\\":\\\"ARBEIDSTAKER\\\",\\\"satsBel\u00f8p\\\":1000,\\\"satsType\\\":\\\"DAGSATS\\\"}]},{\\\"fom\\\":\\\"2019-03-01\\\",\\\"tom\\\":\\\"2019-03-31\\\",\\\"andeler\\\":[{\\\"inntektskategori\\\":\\\"FRILANSER\\\",\\\"satsBel\u00f8p\\\":135,\\\"satsType\\\":\\\"DAGSATS\\\"},{\\\"arbeidsgiverOrgNr\\\":\\\"123123123\\\",\\\"inntektskategori\\\":\\\"ARBEIDSTAKER\\\",\\\"satsBel\u00f8p\\\":1586,\\\"satsType\\\":\\\"DAGSATS\\\"}]}]}\", TilkjentYtelse.class));\n    }\n\n    private static ObjectMapper getObjectMapper() {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.registerModule(new Jdk8Module());\n        mapper.registerModule(new JavaTimeModule());\n        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        mapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);\n        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n        return mapper;\n    }\n\n}", "class_id": 0, "repo": "navikt/fp-kontrakter", "file": "vl-kontrakt-fp-tilkjent-ytelse/src/test/java/no/nav/foreldrepenger/kontrakter/tilkjentytelse/v1/TilkjentYtelseV1Test.java", "last_update_at": "2019-06-27T10:53:39+00:00", "question_id": "4146c44e5ff63502d4479ee779b916a7238ff048", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TilkjentYtelseV1Test {\n    private static ObjectMapper mapper = getObjectMapper();\n    @Test\n    public void skal_serialisere_riktig() throws JsonProcessingException {\n        TilkjentYtelseBehandlingInfoV1 info = new TilkjentYtelseBehandlingInfoV1()\n                .setAkt\u00f8rId(\"9000012345678\")\n                .setSaksnummer(\"2525253\")\n                .setBehandlingId(100000123)\n                .setVedtaksdato(LocalDate.of(2019, 3, 10))\n                .setGjelderAdopsjon(false)\n                .setAnsvarligSaksbehandler(\"Z000001\")\n                .setYtelseType(TilkjentYtelseV1.YtelseType.FORELDREPENGER);\n        var andeler1 = new ArrayList<TilkjentYtelseAndelV1>();\n        andeler1.add(TilkjentYtelseAndelV1.tilBruker(FRILANSER, 100L, DAGSATS));\n        andeler1.add(TilkjentYtelseAndelV1.refusjon(ARBEIDSTAKER, 1000L, DAGSATS).medArbeidsgiverOrgNr(\"123123123\"));\n        var andeler2 = new ArrayList<TilkjentYtelseAndelV1>();\n        andeler2.add(TilkjentYtelseAndelV1.tilBruker(FRILANSER, 135L, DAGSATS));\n        andeler2.add(TilkjentYtelseAndelV1.refusjon(ARBEIDSTAKER, 1586L, DAGSATS).medArbeidsgiverOrgNr(\"123123123\").leggTilFeriepenger(Year.of(2018), 187));\n        var perioder = new ArrayList<TilkjentYtelsePeriodeV1>();\n        perioder.add(new TilkjentYtelsePeriodeV1(LocalDate.of(2018, 12, 24), LocalDate.of(2019, 2, 28), andeler1));\n        perioder.add(new TilkjentYtelsePeriodeV1(LocalDate.of(2019, 3, 1), LocalDate.of(2019, 3, 31), andeler2));\n        TilkjentYtelse tilkjentYtelseV1 = new TilkjentYtelseV1(info, perioder)\n                .setErOpph\u00f8r(true)\n                .setErOpph\u00f8rEtterSkj\u00e6ringstidspunkt(false);\n        String resultat = mapper.writeValueAsString(tilkjentYtelseV1);\n        //hvis du endrer noe slik at denne testen feiler, har du gjort noe galt! Endringene du \u00f8nsker krever at du oppretter en ny versjon av TilkjentYtelse\n        assertThat(resultat).isEqualTo(\"{\\\"version\\\":\\\"1.0\\\",\\\"behandingsinfo\\\":{\\\"aktoerId\\\":\\\"9000012345678\\\",\\\"saksnummer\\\":\\\"2525253\\\",\\\"behandlingId\\\":100000123,\\\"ytelseType\\\":\\\"FORELDREPENGER\\\",\\\"gjelderAdopsjon\\\":false,\\\"vedtaksdato\\\":\\\"2019-03-10\\\",\\\"ansvarligSaksbehandler\\\":\\\"Z000001\\\"},\\\"perioder\\\":[{\\\"fom\\\":\\\"2018-12-24\\\",\\\"tom\\\":\\\"2019-02-28\\\",\\\"andeler\\\":[{\\\"utbetalesTilBruker\\\":true,\\\"inntektskategori\\\":\\\"FRILANSER\\\",\\\"satsType\\\":\\\"DAGSATS\\\",\\\"satsBeloep\\\":100},{\\\"utbetalesTilBruker\\\":false,\\\"arbeidsgiverOrgNr\\\":\\\"123123123\\\",\\\"inntektskategori\\\":\\\"ARBEIDSTAKER\\\",\\\"satsType\\\":\\\"DAGSATS\\\",\\\"satsBeloep\\\":1000}]},{\\\"fom\\\":\\\"2019-03-01\\\",\\\"tom\\\":\\\"2019-03-31\\\",\\\"andeler\\\":[{\\\"utbetalesTilBruker\\\":true,\\\"inntektskategori\\\":\\\"FRILANSER\\\",\\\"satsType\\\":\\\"DAGSATS\\\",\\\"satsBeloep\\\":135},{\\\"utbetalesTilBruker\\\":false,\\\"arbeidsgiverOrgNr\\\":\\\"123123123\\\",\\\"inntektskategori\\\":\\\"ARBEIDSTAKER\\\",\\\"satsType\\\":\\\"DAGSATS\\\",\\\"feriepenger\\\":[{\\\"opptjeningsaar\\\":2018,\\\"beloep\\\":187}],\\\"satsBeloep\\\":1586}]}],\\\"erOpphoer\\\":true,\\\"erOpphoerEtterSkjaeringTidspunkt\\\":false}\");\n    }\n    @Test\n    public void skal_serialisere_og_deserialisere_med_feriepenger() throws IOException, ParseException {\n        TilkjentYtelseBehandlingInfoV1 info = new TilkjentYtelseBehandlingInfoV1()\n                .setAkt\u00f8rId(\"90000123\")\n                .setSaksnummer(\"2525253\")\n                .setBehandlingId(100000123)\n                .setVedtaksdato(LocalDate.of(2019, 3, 10))\n                .setGjelderAdopsjon(false)\n                .setAnsvarligSaksbehandler(\"Z000001\")\n                .setYtelseType(TilkjentYtelseV1.YtelseType.FORELDREPENGER);\n        var andeler = new ArrayList<TilkjentYtelseAndelV1>();\n        andeler.add(TilkjentYtelseAndelV1.tilBruker(FRILANSER, 100L, DAGSATS).leggTilFeriepenger(Year.of(2018), 12));\n        var perioder = new ArrayList<TilkjentYtelsePeriodeV1>();\n        perioder.add(new TilkjentYtelsePeriodeV1(LocalDate.of(2018, 12, 24), LocalDate.of(2019, 2, 28), andeler));\n        TilkjentYtelse tilkjentYtelseV1 = new TilkjentYtelseV1(info, perioder)\n                .setEndringsdato(LocalDate.of(2018, 12, 27));\n        String json = mapper.writeValueAsString(tilkjentYtelseV1);\n        TilkjentYtelse resultat = mapper.readValue(json, TilkjentYtelse.class);\n        assertThat(resultat).isInstanceOf(TilkjentYtelseV1.class);\n        TilkjentYtelseV1 ty = (TilkjentYtelseV1) resultat;\n        ty.kryssvalider();\n        assertThat(ty.getEndringsdato()).isEqualTo(LocalDate.of(2018, 12, 27));\n        TilkjentYtelseAndelV1 andel = ty.getPerioder().iterator().next().getAndeler().iterator().next();\n        List<TilkjentYtelseFeriepengerV1> feriepenger = andel.getFeriepenger();\n        assertThat(feriepenger).hasSize(1);\n        assertThat(feriepenger.get(0).getBel\u00f8p()).isEqualTo(12);\n        assertThat(feriepenger.get(0).getOpptjenings\u00e5r()).isEqualTo(2018);\n    }\n    @Test\n    public void skal_deserialisere() throws IOException, ParseException {\n        TilkjentYtelse resultat = mapper.readValue(\"{\\\"version\\\":\\\"1.0\\\",\\\"behandingsinfo\\\":{\\\"saksnummer\\\":\\\"2525253\\\",\\\"behandlingId\\\":100000123,\\\"ytelseType\\\":\\\"FORELDREPENGER\\\",\\\"gjelderAdopsjon\\\":false,\\\"vedtaksdato\\\":\\\"2019-03-10\\\",\\\"ansvarligSaksbehandler\\\":\\\"Z000001\\\",\\\"aktoerId\\\":\\\"90000123\\\"},\\\"perioder\\\":[{\\\"fom\\\":\\\"2018-12-24\\\",\\\"tom\\\":\\\"2019-02-28\\\",\\\"andeler\\\":[{\\\"utbetalesTilBruker\\\":true,\\\"inntektskategori\\\":\\\"FRILANSER\\\",\\\"satsType\\\":\\\"DAGSATS\\\",\\\"satsBeloep\\\":100},{\\\"utbetalesTilBruker\\\":false,\\\"arbeidsgiverOrgNr\\\":\\\"123123123\\\",\\\"inntektskategori\\\":\\\"ARBEIDSTAKER\\\",\\\"satsType\\\":\\\"DAGSATS\\\",\\\"satsBeloep\\\":1000}]},{\\\"fom\\\":\\\"2019-03-01\\\",\\\"tom\\\":\\\"2019-03-31\\\",\\\"andeler\\\":[{\\\"utbetalesTilBruker\\\":true,\\\"inntektskategori\\\":\\\"FRILANSER\\\",\\\"satsType\\\":\\\"DAGSATS\\\",\\\"satsBeloep\\\":135},{\\\"utbetalesTilBruker\\\":false,\\\"arbeidsgiverOrgNr\\\":\\\"123123123\\\",\\\"inntektskategori\\\":\\\"ARBEIDSTAKER\\\",\\\"satsType\\\":\\\"DAGSATS\\\",\\\"feriepenger\\\":[{\\\"opptjeningsaar\\\":2018,\\\"beloep\\\":187}],\\\"satsBeloep\\\":1586}]}],\\\"erOpphoer\\\":true,\\\"erOpphoerEtterSkjaeringTidspunkt\\\":false}\", TilkjentYtelse.class);\n        assertThat(resultat).isInstanceOf(TilkjentYtelseV1.class);\n        TilkjentYtelseV1 ty = (TilkjentYtelseV1) resultat;\n        ty.kryssvalider();\n        TilkjentYtelseBehandlingInfoV1 info = ty.getBehandingsinfo();\n        assertThat(info.getAkt\u00f8rId()).isEqualTo(\"90000123\");\n        assertThat(info.getSaksnummer()).isEqualTo(\"2525253\");\n        assertThat(info.getBehandlingId()).isEqualTo(100000123);\n        assertThat(info.getVedtaksdato()).isEqualTo(LocalDate.of(2019, 3, 10));\n        assertThat(info.isGjelderAdopsjon()).isFalse();\n        assertThat(info.getAnsvarligSaksbehandler()).isEqualTo(\"Z000001\");\n        assertThat(info.getYtelseType()).isEqualTo(TilkjentYtelseV1.YtelseType.FORELDREPENGER);\n        assertThat(ty.getPerioder()).hasSize(2);\n        TilkjentYtelsePeriodeV1 periode = ty.getPerioder().iterator().next();\n        assertThat(periode.getAndeler()).hasSize(2);\n        assertThat(periode.getFom()).isEqualTo(LocalDate.of(2018, 12, 24));\n        assertThat(periode.getTom()).isEqualTo(LocalDate.of(2019, 2, 28));\n        Iterator<TilkjentYtelseAndelV1> andeler = periode.getAndeler().iterator();\n        TilkjentYtelseAndelV1 andel1 = andeler.next();\n        assertThat(andel1.getUtbetalesTilBruker()).isTrue();\n        assertThat(andel1.getInntektskategori()).isEqualTo(TilkjentYtelseV1.Inntektskategori.FRILANSER);\n        assertThat(andel1.getSatsBel\u00f8p()).isEqualTo(100);\n        assertThat(andel1.getSatsType()).isEqualTo(TilkjentYtelseV1.SatsType.DAGSATS);\n        assertThat(andel1.getArbeidsgiverOrgNr()).isNull();\n        assertThat(andel1.getArbeidsgiverAkt\u00f8rId()).isNull();\n        TilkjentYtelseAndelV1 andel2 = andeler.next();\n        assertThat(andel2.getUtbetalesTilBruker()).isFalse();\n        assertThat(andel2.getInntektskategori()).isEqualTo(TilkjentYtelseV1.Inntektskategori.ARBEIDSTAKER);\n        assertThat(andel2.getSatsBel\u00f8p()).isEqualTo(1000);\n        assertThat(andel2.getSatsType()).isEqualTo(TilkjentYtelseV1.SatsType.DAGSATS);\n        assertThat(andel2.getArbeidsgiverOrgNr()).isEqualTo(\"123123123\");\n        assertThat(andel2.getArbeidsgiverAkt\u00f8rId()).isNull();\n    }\n    @Test\n    public void skal_ikke_deserialisere_ukjent_versjon() {\n        assertThrows(InvalidTypeIdException.class, () -> mapper.readValue(\"{\\\"version\\\":\\\"1000.0\\\",\\\"behandingsinfo\\\":{\\\"aktoerId\\\":90000123,\\\"saksnummer\\\":\\\"2525253\\\",\\\"behandlingId\\\":100000123,\\\"ytelseType\\\":\\\"FORELDREPENGER\\\",\\\"gjelderAdopsjon\\\":false,\\\"vedtaksdato\\\":\\\"2019-03-10\\\",\\\"ansvarligSaksbehandler\\\":\\\"Z000001\\\",\\\"ansvarligBeslutter\\\":\\\"Z222222\\\"},\\\"perioder\\\":[{\\\"fom\\\":\\\"2018-12-24\\\",\\\"tom\\\":\\\"2019-02-28\\\",\\\"andeler\\\":[{\\\"inntektskategori\\\":\\\"FRILANSER\\\",\\\"satsBel\u00f8p\\\":100,\\\"satsType\\\":\\\"DAGSATS\\\"},{\\\"arbeidsgiverOrgNr\\\":\\\"123123123\\\",\\\"inntektskategori\\\":\\\"ARBEIDSTAKER\\\",\\\"satsBel\u00f8p\\\":1000,\\\"satsType\\\":\\\"DAGSATS\\\"}]},{\\\"fom\\\":\\\"2019-03-01\\\",\\\"tom\\\":\\\"2019-03-31\\\",\\\"andeler\\\":[{\\\"inntektskategori\\\":\\\"FRILANSER\\\",\\\"satsBel\u00f8p\\\":135,\\\"satsType\\\":\\\"DAGSATS\\\"},{\\\"arbeidsgiverOrgNr\\\":\\\"123123123\\\",\\\"inntektskategori\\\":\\\"ARBEIDSTAKER\\\",\\\"satsBel\u00f8p\\\":1586,\\\"satsType\\\":\\\"DAGSATS\\\"}]}]}\", TilkjentYtelse.class));\n    }\n    private static ObjectMapper getObjectMapper() {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.registerModule(new Jdk8Module());\n        mapper.registerModule(new JavaTimeModule());\n        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        mapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);\n        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n        return mapper;\n    }\n"]]}
{"hexsha": "ae58d6d724faca17f4d0b8242239003a15004a78", "ext": "java", "lang": "Java", "content": "class Producer extends Thread { \n    static final int MAXQUEUE = 5; \n    private Vector messages = new Vector(); \n    public void run() { \n        try { \n            while ( true ) { \n                putMessage(); \n                sleep(1000); \n            } \n        }  \n        catch( InterruptedException e ){} \n    } \n    private synchronized void putMessage() \n        throws InterruptedException { \n\n        while ( messages.size() == MAXQUEUE )\n            wait(); \n        messages.addElement( new java.util.Date().toString() ); \n        notify(); \n    } \n    public synchronized String getMessage() \n        throws InterruptedException { \n        notify(); \n        while ( messages.size() == 0 ) \n            wait(); \n        String message = (String)messages.firstElement(); \n        messages.removeElement( message ); \n        return message; \n    } \n}", "class_id": 0, "repo": "SayanGhoshBDA/code-backup", "file": "java_backup/chin2_BACKUP OF JAVA/Producer.java", "last_update_at": "2019-05-08T10:09:52+00:00", "question_id": "ae58d6d724faca17f4d0b8242239003a15004a78", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Producer extends Thread { \n    static final int MAXQUEUE = 5; \n    private Vector messages = new Vector(); \n    public void run() { \n        try { \n            while ( true ) { \n                putMessage(); \n                sleep(1000); \n            } \n        }  \n        catch( InterruptedException e ){} \n    } \n    private synchronized void putMessage() \n        throws InterruptedException { \n        while ( messages.size() == MAXQUEUE )\n            wait(); \n        messages.addElement( new java.util.Date().toString() ); \n        notify(); \n    } \n    public synchronized String getMessage() \n        throws InterruptedException { \n        notify(); \n        while ( messages.size() == 0 ) \n            wait(); \n        String message = (String)messages.firstElement(); \n        messages.removeElement( message ); \n        return message; \n    } \n"]]}
{"hexsha": "8bdc2e88c1163d94bad3909c999c04280a97eaec", "ext": "java", "lang": "Java", "content": "@SuppressWarnings( { \"ClassWithoutLogger\", \"UseOfSystemOutOrSystemErr\" } )\npublic class DirectoryWatcherTest {\n\n\t@BeforeClass\n\tpublic static void setUpClass() {\n\t\tSystem.out.println(\"---- DirectoryWatcherTest --------------------------------------\");\n\t}\n\n\tprivate Path dir_a;\n\tprivate Path dir_a_c;\n\tprivate Path dir_b;\n\tprivate ExecutorService executor;\n\tprivate Path file_a;\n\tprivate Path file_a_c;\n\tprivate Path file_b1;\n\tprivate Path file_b2;\n\tprivate Path root;\n\n\t@Before\n\tpublic void setUp() throws IOException {\n\t\texecutor = Executors.newSingleThreadExecutor();\n\t\troot = Files.createTempDirectory(\"DW_\");\n\t\tdir_a = Files.createTempDirectory(root, \"DW_a_\");\n\t\tfile_a = Files.createTempFile(dir_a, \"DW_a_\", \".test\");\n\t\tdir_a_c = Files.createTempDirectory(dir_a, \"DW_a_c_\");\n\t\tfile_a_c = Files.createTempFile(dir_a_c, \"DW_a_c_\", \".test\");\n\t\tdir_b = Files.createTempDirectory(root, \"DW_b_\");\n\t\tfile_b1 = Files.createTempFile(dir_b, \"DW_b1_\", \".test\");\n\t\tfile_b2 = Files.createTempFile(dir_b, \"DW_b2_\", \".test\");\n\t}\n\n\t@After\n\tpublic void tearDown() throws IOException {\n\t\tFiles.walkFileTree(root, new DeleteFileVisitor());\n\t\texecutor.shutdown();\n\t}\n\n\t/**\n\t * Test of close method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test( expected = RejectedExecutionException.class )\n\tpublic void testClose() throws IOException, RejectedExecutionException, InterruptedException {\n\n\t\tSystem.out.println(\"  Testing 'close'...\");\n\n\t\tCountDownLatch latchErrors = new CountDownLatch(1);\n\t\tCountDownLatch latchEvents = new CountDownLatch(1);\n\t\tDirectoryWatcher watcher = build(executor);\n\t\tDisposable errrorsSubscription = watcher.errors().subscribe(t -> {}, t -> {}, latchErrors::countDown);\n\t\tDisposable eventsSubscription = watcher.events().subscribe(t -> {}, t -> {}, latchEvents::countDown);\n\n\t\tassertFalse(watcher.isClosed());\n\n\t\twatcher.delete(\n\t\t\tfile_b2,\n\t\t\tt -> {\n\t\t\t\tassertTrue(t);\n\t\t\t},\n\t\t\te -> {\n\t\t\t\tfail(MessageFormat.format(\"File not deleted: {0}\", file_b2));\n\t\t\t}\n\t\t);\n\n\t\twatcher.close();\n\n\t\tassertTrue(watcher.isClosed());\n\n\t\tif ( !latchErrors.await(15, TimeUnit.SECONDS) ) {\n\t\t\tfail(\"Missing 'onComplete' for errors stream in 15 seconds.\");\n\t\t}\n\t\tif ( !latchEvents.await(15, TimeUnit.SECONDS) ) {\n\t\t\tfail(\"Missing 'onComplete' for events stream in 15 seconds.\");\n\t\t}\n\n\t\twatcher.delete(\n\t\t\tfile_b1,\n\t\t\tt -> {\n\t\t\t\tfail(\"Operation has not been rejected.\");\n\t\t\t},\n\t\t\te -> {\n\t\t\t\tfail(\"Operation has not been rejected.\");\n\t\t\t}\n\t\t);\n\n\t\terrrorsSubscription.dispose();\n\t\teventsSubscription.dispose();\n\n\t}\n\n\t/**\n\t * Test of build method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t */\n\t@Test\n\tpublic void testCreate() throws IOException {\n\n\t\tSystem.out.println(\"  Testing 'create'...\");\n\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\t\t\tassertNotNull(watcher);\n\t\t\tassertFalse(watcher.isClosed());\n\t\t}\n\n\t}\n\n\t/**\n\t * Test of createDirectories method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testCreateDirectories() throws IOException, InterruptedException {\n\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''createDirectories'' [on {0}]...\", root));\n\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\n\t\t\tCountDownLatch latch = new CountDownLatch(2);\n\t\t\tPath toBeCreated = FileSystems.getDefault().getPath(dir_a.toString(), \"dir_a_x\", \"dir_a_y\", \"dir_a_z\");\n\n\t\t\twatcher.createDirectories(\n\t\t\t\ttoBeCreated,\n\t\t\t\tp -> {\n\t\t\t\t\tassertNotNull(p);\n\t\t\t\t\tassertTrue(Files.exists(p));\n\t\t\t\t\tassertTrue(Files.isDirectory(p));\n\t\t\t\t\tassertEquals(toBeCreated, p);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"Directory not created: {0}\", toBeCreated));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tPath toFail = file_a;\n\n\t\t\twatcher.createDirectories(\n\t\t\t\ttoFail,\n\t\t\t\tp -> {\n\t\t\t\t\tfail(MessageFormat.format(\"Directory was created: {0}\", toFail));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tassertNotNull(e);\n\t\t\t\t\tassertTrue(e instanceof FileAlreadyExistsException);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif ( !latch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"Directories creation not completed in 1 minute.\");\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Test of createDirectory method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testCreateDirectory() throws IOException, InterruptedException {\n\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''createDirectory'' [on {0}]...\", root));\n\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\n\t\t\tCountDownLatch latch = new CountDownLatch(3);\n\t\t\tPath toBeCreated = FileSystems.getDefault().getPath(dir_a.toString(), \"dir_a_z\");\n\n\t\t\twatcher.createDirectory(\n\t\t\t\ttoBeCreated,\n\t\t\t\tp -> {\n\t\t\t\t\tassertNotNull(p);\n\t\t\t\t\tassertTrue(Files.exists(p));\n\t\t\t\t\tassertTrue(Files.isDirectory(p));\n\t\t\t\t\tassertEquals(toBeCreated, p);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"Directory not created: {0}\", toBeCreated));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tPath toFail1 = dir_a_c;\n\n\t\t\twatcher.createDirectory(\n\t\t\t\ttoFail1,\n\t\t\t\tp -> {\n\t\t\t\t\tfail(MessageFormat.format(\"Directory was created: {0}\", toFail1));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tassertNotNull(e);\n\t\t\t\t\tassertTrue(e instanceof FileAlreadyExistsException);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tPath toFail2 = FileSystems.getDefault().getPath(dir_a.toString(), \"dir_a_x\", \"dir_a_y\", \"dir_a_z\");\n\n\t\t\twatcher.createDirectory(\n\t\t\t\ttoFail2,\n\t\t\t\tp -> {\n\t\t\t\t\tfail(MessageFormat.format(\"Directory was created: {0}\", toFail2));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tassertNotNull(e);\n\t\t\t\t\tassertTrue(e instanceof IOException);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif ( !latch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"Directory creation not completed in 1 minute.\");\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Test of createFile method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testCreateFile() throws IOException, InterruptedException {\n\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''createFile'' [on {0}]...\", root));\n\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\n\t\t\tCountDownLatch latch = new CountDownLatch(2);\n\t\t\tPath toBeCreated = FileSystems.getDefault().getPath(dir_a.toString(), \"created_file.txt\");\n\n\t\t\twatcher.createFile(\n\t\t\t\ttoBeCreated,\n\t\t\t\tt -> {\n\t\t\t\t\tassertNotNull(t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File not created: {0}\", toBeCreated));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tPath toFail = FileSystems.getDefault().getPath(dir_a.toString(), \"non-exitent\", \"created_file.txt\");\n\n\t\t\twatcher.createFile(\n\t\t\t\ttoFail,\n\t\t\t\tt -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File was created: {0}\", toFail));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tassertNotNull(e);\n\t\t\t\t\tassertTrue(e instanceof IOException);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif ( !latch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File creation not completed in 1 minute.\");\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Test of delete method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testDelete() throws IOException, InterruptedException {\n\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''delete'' [on {0}]...\", root));\n\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\n\t\t\tCountDownLatch latch = new CountDownLatch(5);\n\n\t\t\twatcher.delete(\n\t\t\t\tfile_b2,\n\t\t\t\tt -> {\n\t\t\t\t\tassertTrue(t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File not deleted: {0}\", file_b2));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\twatcher.delete(\n\t\t\t\tfile_b2,\n\t\t\t\tt -> {\n\t\t\t\t\tassertFalse(t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File not deleted: {0}\", file_b2));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\twatcher.delete(\n\t\t\t\tdir_b,\n\t\t\t\tt -> {\n\t\t\t\t\tfail(MessageFormat.format(\"Non-empty directory was deleted: {0}\", file_b2));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tassertNotNull(e);\n\t\t\t\t\tassertTrue(e instanceof IOException);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\twatcher.delete(\n\t\t\t\tfile_b1,\n\t\t\t\tt -> {\n\t\t\t\t\tassertTrue(t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File not deleted: {0}\", file_b2));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\twatcher.delete(\n\t\t\t\tdir_b,\n\t\t\t\tt -> {\n\t\t\t\t\tassertTrue(t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"Directory not deleted: {0}\", file_b2));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif ( !latch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File deletion not completed in 1 minute.\");\n\t\t\t}\n\n\t\t\tassertFalse(Files.exists(dir_b));\n\t\t\tassertFalse(Files.exists(file_b1));\n\t\t\tassertFalse(Files.exists(file_b2));\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Test of deleteTree method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testDeleteTree() throws IOException, InterruptedException {\n\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''deleteTree'' [on {0}]...\", root));\n\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\n\t\t\tCountDownLatch latch = new CountDownLatch(2);\n\n\t\t\twatcher.deleteTree(\n\t\t\t\tdir_a,\n\t\t\t\tt -> {\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"Tree not deleted: {0}\", file_b2));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\twatcher.deleteTree(\n\t\t\t\tPaths.get(\"a\", \"b\", \"c\", \"d\", \"e\", \"1\", \"2\", \"3\", \"4\", \"5\"),\n\t\t\t\tt -> {\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"Tree not deleted: {0}\", file_b2));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif ( !latch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File deletion not completed in 1 minute.\");\n\t\t\t}\n\n\t\t\tassertFalse(Files.exists(file_a_c));\n\t\t\tassertFalse(Files.exists(dir_a_c));\n\t\t\tassertFalse(Files.exists(file_a));\n\t\t\tassertFalse(Files.exists(dir_a));\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Test of errors method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t */\n\t@Test\n\tpublic void testErrors() throws IOException {\n\n\t\tSystem.out.println(\"  Testing 'errors'...\");\n\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\n\t\t\tObservable<Throwable> errorsStream = watcher.errors();\n\n\t\t\tassertNotNull(errorsStream);\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Test of events method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t */\n\t@Test\n\tpublic void testEvents() throws IOException {\n\n\t\tSystem.out.println(\"  Testing 'events'...\");\n\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\n\t\t\tObservable<DirectoryWatcher.DirectoryEvent> event = watcher.events();\n\n\t\t\tassertNotNull(event);\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Test of isCloseComplete method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t */\n\t@Test\n\tpublic void testIsCloseComplete() throws IOException {\n\n\t\tSystem.out.println(\"  Testing 'isCloseComplete'...\");\n\n\t\tDirectoryWatcher watcher = build(executor);\n\n\t\tassertFalse(watcher.isClosed());\n\t\tassertFalse(watcher.isCloseComplete());\n\n\t\twatcher.close();\n\n\t\tassertFalse(watcher.isCloseComplete());\n\t\tassertTrue(watcher.isClosed());\n\n\t\tlong startTime = System.currentTimeMillis();\n\t\tlong currentTime = startTime;\n\n\t\twhile ( !watcher.isCloseComplete() && startTime + 60000L > currentTime ) {\n\t\t\tcurrentTime = System.currentTimeMillis();\n\t\t}\n\n\t\tassertTrue(watcher.isCloseComplete());\n\n\t}\n\n\t/**\n\t * Test of isClosed method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t */\n\t@Test\n\tpublic void testIsClosed() throws IOException {\n\n\t\tSystem.out.println(\"  Testing 'isClosed'...\");\n\n\t\tDirectoryWatcher watcher = build(executor);\n\n\t\tassertFalse(watcher.isClosed());\n\n\t\twatcher.close();\n\n\t\tassertTrue(watcher.isClosed());\n\n\t}\n\n\t/**\n\t * Test of isWatched method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\t@SuppressWarnings( \"CallToThreadYield\" )\n\tpublic void testIsWatched() throws IOException, InterruptedException {\n\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''isWatched'' [on {0}]...\", root));\n\n\t\tDirectoryWatcher watcher = build(executor);\n\n\t\twatcher.watch(dir_a);\n\t\tassertTrue(watcher.isWatched(dir_a));\n\n\t\twatcher.watch(dir_a_c);\n\t\tassertTrue(watcher.isWatched(dir_a_c));\n\n\t\twatcher.watch(dir_b);\n\t\tassertTrue(watcher.isWatched(dir_b));\n\n\t\tCountDownLatch latch = new CountDownLatch(1);\n\n\t\tDisposable subscription = watcher.events().subscribe(event -> {\n\t\t\tevent.getEvents().stream().forEach(e -> {\n\t\t\t\tif ( StandardWatchEventKinds.ENTRY_DELETE.equals(e.kind()) ) {\n\t\t\t\t\tSystem.out.println(\"    Path deleted: \" + e.context());\n\t\t\t\t\tif ( dir_a_c.equals(event.getWatchedPath().resolve((Path) e.context())) ) {\n\t\t\t\t\t\tlatch.countDown();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\tFiles.walkFileTree(dir_a_c, new DeleteFileVisitor());\n\n\t\tif ( !latch.await(1, TimeUnit.MINUTES) ) {\n\t\t\tfail(\"File deletion not signalled in 1 minute.\");\n\t\t}\n\n\t\tassertFalse(watcher.isWatched(dir_a_c));\n\n\t\twatcher.delete(\n\t\t\tdir_a,\n\t\t\tsuccess -> assertFalse(watcher.isWatched(dir_a)),\n\t\t\tnull\n\t\t);\n\n\t\tsubscription.dispose();\n\t\twatcher.close();\n\n\t\twhile ( !watcher.isCloseComplete() ) {\n\t\t\tThread.yield();\n\t\t}\n\n\t\tassertFalse(watcher.isWatched(dir_b));\n\n\t}\n\n\t/**\n\t * Test of readBinaryFile method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testReadBinaryFile() throws IOException, InterruptedException {\n\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''readBinaryFile'' [on {0}]...\", root));\n\n\t\tbyte[] content = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x03, 0x02, 0x01, 0x00 };\n\t\tCountDownLatch latch = new CountDownLatch(2);\n\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\n\t\t\tFiles.write(file_b1, content);\n\n\t\t\twatcher.readBinaryFile(\n\t\t\t\tfile_b1,\n\t\t\t\tt -> {\n\t\t\t\t\tassertArrayEquals(content, t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File not read: {0}\", file_b1));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tPath toFail = FileSystems.getDefault().getPath(dir_a.toString(), \"non-exitent\", \"created_file.txt\");\n\n\t\t\twatcher.readBinaryFile(\n\t\t\t\ttoFail,\n\t\t\t\tt -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File was read: {0}\", toFail));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tassertNotNull(e);\n\t\t\t\t\tassertTrue(e instanceof IOException);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif ( !latch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File creation not completed in 1 minute.\");\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Test of readTextFile method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testReadTextFile() throws IOException, InterruptedException {\n\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''readTextFile'' [on {0}]...\", root));\n\n\t\tString content = \"First line of text.\\nSecond line of text.\";\n\t\tCharset charset = defaultCharset();\n\t\tCountDownLatch latch = new CountDownLatch(2);\n\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\n\t\t\tFiles.write(file_b1, content.getBytes(charset), CREATE, WRITE, TRUNCATE_EXISTING);\n\n\t\t\twatcher.readTextFile(\n\t\t\t\tfile_b1,\n\t\t\t\tcharset,\n\t\t\t\tt -> {\n\t\t\t\t\tassertEquals(content, t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File not read: {0}\", file_b1));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tPath toFail = FileSystems.getDefault().getPath(dir_a.toString(), \"non-exitent\", \"created_file.txt\");\n\n\t\t\twatcher.readTextFile(\n\t\t\t\ttoFail,\n\t\t\t\tcharset,\n\t\t\t\tt -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File was read: {0}\", toFail));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tassertNotNull(e);\n\t\t\t\t\tassertTrue(e instanceof IOException);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif ( !latch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File creation not completed in 1 minute.\");\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Test of writeBinaryFile and readBinaryFile method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testReadWriteBinaryFile() throws IOException, InterruptedException {\n\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''writeBinaryFile'' and ''readBinaryFile'' [on {0}]...\", root));\n\n\t\tbyte[] content = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x03, 0x02, 0x01, 0x00 };\n\t\tCountDownLatch latch = new CountDownLatch(2);\n\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\n\t\t\tPath readWriteFile = FileSystems.getDefault().getPath(dir_a.toString(), \"created_file.txt\");\n\n\t\t\twatcher.writeBinaryFile(\n\t\t\t\treadWriteFile,\n\t\t\t\tcontent,\n\t\t\t\tt -> {\n\t\t\t\t\tassertNotNull(t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File not written: {0}\", readWriteFile));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\twatcher.readBinaryFile(\n\t\t\t\treadWriteFile,\n\t\t\t\tt -> {\n\t\t\t\t\tassertArrayEquals(content, t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File not read: {0}\", file_b1));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif ( !latch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File creation not completed in 1 minute.\");\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Test of writeTextFile and readTextFile methods, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testReadWriteTextFile() throws IOException, InterruptedException {\n\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''writeTextFile'' and ''readTextFile'' [on {0}]...\", root));\n\n\t\tString content = \"First line of text.\\nSecond line of text.\";\n\t\tCharset charset = defaultCharset();\n\t\tCountDownLatch latch = new CountDownLatch(2);\n\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\n\t\t\tPath readWriteFile = FileSystems.getDefault().getPath(dir_a.toString(), \"created_file.txt\");\n\n\t\t\twatcher.writeTextFile(\n\t\t\t\treadWriteFile,\n\t\t\t\tcontent,\n\t\t\t\tcharset,\n\t\t\t\tt -> {\n\t\t\t\t\tassertNotNull(t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File not written: {0}\", readWriteFile));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\twatcher.readTextFile(\n\t\t\t\treadWriteFile,\n\t\t\t\tcharset,\n\t\t\t\tt -> {\n\t\t\t\t\tassertEquals(content, t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File not read: {0}\", file_b1));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif ( !latch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File creation not completed in 1 minute.\");\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Test of unwatch method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t */\n\t@Test\n\tpublic void testUnwatch() throws IOException {\n\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''unwatch'' [on {0}]...\", root));\n\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\n\t\t\twatcher.watch(dir_a);\n\t\t\tassertTrue(watcher.isWatched(dir_a));\n\n\t\t\twatcher.watch(dir_a_c);\n\t\t\tassertTrue(watcher.isWatched(dir_a_c));\n\n\t\t\twatcher.watch(dir_b);\n\t\t\tassertTrue(watcher.isWatched(dir_b));\n\n\t\t\twatcher.unwatch(dir_a);\n\t\t\tassertFalse(watcher.isWatched(dir_a));\n\n\t\t\twatcher.unwatch(dir_a_c);\n\t\t\tassertFalse(watcher.isWatched(dir_a_c));\n\n\t\t\twatcher.unwatch(dir_b);\n\t\t\tassertFalse(watcher.isWatched(dir_b));\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Test of watch method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testWatch() throws IOException, InterruptedException {\n\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''watch'' [on {0}]...\", root));\n\n\t\tCountDownLatch createLatch = new CountDownLatch(1);\n\t\tCountDownLatch deleteLatch = new CountDownLatch(1);\n\t\tCountDownLatch modifyLatch = new CountDownLatch(1);\n\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\n\t\t\tDisposable subscription = watcher.events().subscribe(event -> {\n\t\t\t\tevent.getEvents().stream().forEach(e -> {\n\t\t\t\t\tif ( StandardWatchEventKinds.ENTRY_CREATE.equals(e.kind()) ) {\n\t\t\t\t\t\tSystem.out.println(\"    File created: \" + e.context());\n\t\t\t\t\t\tcreateLatch.countDown();\n\t\t\t\t\t} else if ( StandardWatchEventKinds.ENTRY_DELETE.equals(e.kind()) ) {\n\t\t\t\t\t\tSystem.out.println(\"    File deleted: \" + e.context());\n\t\t\t\t\t\tdeleteLatch.countDown();\n\t\t\t\t\t} else if ( StandardWatchEventKinds.ENTRY_MODIFY.equals(e.kind()) ) {\n\t\t\t\t\t\tSystem.out.println(\"    File modified: \" + e.context());\n\t\t\t\t\t\tmodifyLatch.countDown();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\n\t\t\twatcher.watch(root);\n\n\t\t\tPath tmpFile = Files.createTempFile(root, \"DW_\", \".test\");\n\n\t\t\tif ( !createLatch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File creation not signalled in 1 minute.\");\n\t\t\t}\n\n\t\t\tFiles.write(tmpFile, \"Some text content\".getBytes(), APPEND);\n\n\t\t\tif ( !modifyLatch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File modification not signalled in 1 minute.\");\n\t\t\t}\n\n\t\t\tFiles.delete(tmpFile);\n\n\t\t\tif ( !deleteLatch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File deletion not signalled in 1 minute.\");\n\t\t\t}\n\n\t\t\tsubscription.dispose();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Test of watchOrStreamError method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testWatchOrStreamError() throws IOException, InterruptedException {\n\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''watchOrStreamError'' [on {0}]...\", root));\n\n\t\tCountDownLatch errorLatch = new CountDownLatch(1);\n\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\n\t\t\tDisposable subscription = watcher.errors().subscribe(throwable -> {\n\t\t\t\tif ( throwable instanceof NotDirectoryException ) {\n\t\t\t\t\terrorLatch.countDown();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\twatcher.watchOrStreamError(file_a);\n\n\t\t\tif ( !errorLatch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File deletion not signalled in 1 minute.\");\n\t\t\t}\n\t\t\tsubscription.dispose();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Test of watchUp and unwatchUp methods, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t */\n\t@Test\n\tpublic void testWatchUpAndUnwatchUp() throws IOException {\n\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''watchUp'' and ''unwatchUp'' [on {0}]...\", root));\n\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\n\t\t\twatcher.watchUp(dir_a_c, root);\n\t\t\tassertTrue(watcher.isWatched(dir_a));\n\t\t\tassertTrue(watcher.isWatched(dir_a_c));\n\t\t\tassertFalse(watcher.isWatched(root));\n\n\t\t\twatcher.watch(root);\n\t\t\tassertTrue(watcher.isWatched(root));\n\n\t\t\twatcher.unwatchUp(dir_a_c, root);\n\t\t\tassertFalse(watcher.isWatched(dir_a));\n\t\t\tassertFalse(watcher.isWatched(dir_a_c));\n\t\t\tassertTrue(watcher.isWatched(root));\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Test of writeBinaryFile method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testWriteBinaryFile() throws IOException, InterruptedException {\n\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''writeBinaryFile'' [on {0}]...\", root));\n\n\t\tbyte[] content = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x03, 0x02, 0x01, 0x00 };\n\t\tCountDownLatch latch = new CountDownLatch(2);\n\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\n\t\t\tPath toBeCreated = FileSystems.getDefault().getPath(dir_a.toString(), \"created_file.txt\");\n\n\t\t\twatcher.writeBinaryFile(\n\t\t\t\ttoBeCreated,\n\t\t\t\tcontent,\n\t\t\t\tt -> {\n\t\t\t\t\tassertNotNull(t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File not written: {0}\", toBeCreated));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tPath toFail = FileSystems.getDefault().getPath(dir_a.toString(), \"non-exitent\", \"created_file.txt\");\n\n\t\t\twatcher.writeBinaryFile(\n\t\t\t\ttoFail,\n\t\t\t\tcontent,\n\t\t\t\tt -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File was written: {0}\", toFail));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tassertNotNull(e);\n\t\t\t\t\tassertTrue(e instanceof IOException);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif ( !latch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File creation not completed in 1 minute.\");\n\t\t\t}\n\n\t\t\tassertArrayEquals(content, Files.readAllBytes(toBeCreated));\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Test of writeTextFile method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testWriteTextFile() throws IOException, InterruptedException {\n\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''writeTextFile'' [on {0}]...\", root));\n\n\t\tString content = \"First line of text.\\nSecond line of text.\";\n\t\tCharset charset = defaultCharset();\n\t\tCountDownLatch latch = new CountDownLatch(2);\n\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\n\t\t\tPath toBeCreated = FileSystems.getDefault().getPath(dir_a.toString(), \"created_file.txt\");\n\n\t\t\twatcher.writeTextFile(\n\t\t\t\ttoBeCreated,\n\t\t\t\tcontent,\n\t\t\t\tcharset,\n\t\t\t\tt -> {\n\t\t\t\t\tassertNotNull(t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File not written: {0}\", toBeCreated));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tPath toFail = FileSystems.getDefault().getPath(dir_a.toString(), \"non-exitent\", \"created_file.txt\");\n\n\t\t\twatcher.writeTextFile(\n\t\t\t\ttoFail,\n\t\t\t\tcontent,\n\t\t\t\tcharset,\n\t\t\t\tt -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File was written: {0}\", toFail));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tassertNotNull(e);\n\t\t\t\t\tassertTrue(e instanceof IOException);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif ( !latch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File creation not completed in 1 minute.\");\n\t\t\t}\n\n\t\t\tassertEquals(content, new String(Files.readAllBytes(toBeCreated), charset));\n\n\t\t}\n\n\t}\n\n}", "class_id": 0, "repo": "ESSICS/openxal-fx", "file": "xaos.core.module/src/test/java/se/europeanspallationsource/xaos/core/util/io/DirectoryWatcherTest.java", "last_update_at": "2019-02-08T13:40:38+00:00", "question_id": "8bdc2e88c1163d94bad3909c999c04280a97eaec", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings( { \"ClassWithoutLogger\", \"UseOfSystemOutOrSystemErr\" } )\npublic class DirectoryWatcherTest {\n\t@BeforeClass\n\tpublic static void setUpClass() {\n\t\tSystem.out.println(\"---- DirectoryWatcherTest --------------------------------------\");\n\t}\n\tprivate Path dir_a;\n\tprivate Path dir_a_c;\n\tprivate Path dir_b;\n\tprivate ExecutorService executor;\n\tprivate Path file_a;\n\tprivate Path file_a_c;\n\tprivate Path file_b1;\n\tprivate Path file_b2;\n\tprivate Path root;\n\t@Before\n\tpublic void setUp() throws IOException {\n\t\texecutor = Executors.newSingleThreadExecutor();\n\t\troot = Files.createTempDirectory(\"DW_\");\n\t\tdir_a = Files.createTempDirectory(root, \"DW_a_\");\n\t\tfile_a = Files.createTempFile(dir_a, \"DW_a_\", \".test\");\n\t\tdir_a_c = Files.createTempDirectory(dir_a, \"DW_a_c_\");\n\t\tfile_a_c = Files.createTempFile(dir_a_c, \"DW_a_c_\", \".test\");\n\t\tdir_b = Files.createTempDirectory(root, \"DW_b_\");\n\t\tfile_b1 = Files.createTempFile(dir_b, \"DW_b1_\", \".test\");\n\t\tfile_b2 = Files.createTempFile(dir_b, \"DW_b2_\", \".test\");\n\t}\n\t@After\n\tpublic void tearDown() throws IOException {\n\t\tFiles.walkFileTree(root, new DeleteFileVisitor());\n\t\texecutor.shutdown();\n\t}\n\t/**\n\t * Test of close method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test( expected = RejectedExecutionException.class )\n\tpublic void testClose() throws IOException, RejectedExecutionException, InterruptedException {\n\t\tSystem.out.println(\"  Testing 'close'...\");\n\t\tCountDownLatch latchErrors = new CountDownLatch(1);\n\t\tCountDownLatch latchEvents = new CountDownLatch(1);\n\t\tDirectoryWatcher watcher = build(executor);\n\t\tDisposable errrorsSubscription = watcher.errors().subscribe(t -> {}, t -> {}, latchErrors::countDown);\n\t\tDisposable eventsSubscription = watcher.events().subscribe(t -> {}, t -> {}, latchEvents::countDown);\n\t\tassertFalse(watcher.isClosed());\n\t\twatcher.delete(\n\t\t\tfile_b2,\n\t\t\tt -> {\n\t\t\t\tassertTrue(t);\n\t\t\t},\n\t\t\te -> {\n\t\t\t\tfail(MessageFormat.format(\"File not deleted: {0}\", file_b2));\n\t\t\t}\n\t\t);\n\t\twatcher.close();\n\t\tassertTrue(watcher.isClosed());\n\t\tif ( !latchErrors.await(15, TimeUnit.SECONDS) ) {\n\t\t\tfail(\"Missing 'onComplete' for errors stream in 15 seconds.\");\n\t\t}\n\t\tif ( !latchEvents.await(15, TimeUnit.SECONDS) ) {\n\t\t\tfail(\"Missing 'onComplete' for events stream in 15 seconds.\");\n\t\t}\n\t\twatcher.delete(\n\t\t\tfile_b1,\n\t\t\tt -> {\n\t\t\t\tfail(\"Operation has not been rejected.\");\n\t\t\t},\n\t\t\te -> {\n\t\t\t\tfail(\"Operation has not been rejected.\");\n\t\t\t}\n\t\t);\n\t\terrrorsSubscription.dispose();\n\t\teventsSubscription.dispose();\n\t}\n\t/**\n\t * Test of build method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t */\n\t@Test\n\tpublic void testCreate() throws IOException {\n\t\tSystem.out.println(\"  Testing 'create'...\");\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\t\t\tassertNotNull(watcher);\n\t\t\tassertFalse(watcher.isClosed());\n\t\t}\n\t}\n\t/**\n\t * Test of createDirectories method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testCreateDirectories() throws IOException, InterruptedException {\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''createDirectories'' [on {0}]...\", root));\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\t\t\tCountDownLatch latch = new CountDownLatch(2);\n\t\t\tPath toBeCreated = FileSystems.getDefault().getPath(dir_a.toString(), \"dir_a_x\", \"dir_a_y\", \"dir_a_z\");\n\t\t\twatcher.createDirectories(\n\t\t\t\ttoBeCreated,\n\t\t\t\tp -> {\n\t\t\t\t\tassertNotNull(p);\n\t\t\t\t\tassertTrue(Files.exists(p));\n\t\t\t\t\tassertTrue(Files.isDirectory(p));\n\t\t\t\t\tassertEquals(toBeCreated, p);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"Directory not created: {0}\", toBeCreated));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\tPath toFail = file_a;\n\t\t\twatcher.createDirectories(\n\t\t\t\ttoFail,\n\t\t\t\tp -> {\n\t\t\t\t\tfail(MessageFormat.format(\"Directory was created: {0}\", toFail));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tassertNotNull(e);\n\t\t\t\t\tassertTrue(e instanceof FileAlreadyExistsException);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\tif ( !latch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"Directories creation not completed in 1 minute.\");\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Test of createDirectory method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testCreateDirectory() throws IOException, InterruptedException {\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''createDirectory'' [on {0}]...\", root));\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\t\t\tCountDownLatch latch = new CountDownLatch(3);\n\t\t\tPath toBeCreated = FileSystems.getDefault().getPath(dir_a.toString(), \"dir_a_z\");\n\t\t\twatcher.createDirectory(\n\t\t\t\ttoBeCreated,\n\t\t\t\tp -> {\n\t\t\t\t\tassertNotNull(p);\n\t\t\t\t\tassertTrue(Files.exists(p));\n\t\t\t\t\tassertTrue(Files.isDirectory(p));\n\t\t\t\t\tassertEquals(toBeCreated, p);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"Directory not created: {0}\", toBeCreated));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\tPath toFail1 = dir_a_c;\n\t\t\twatcher.createDirectory(\n\t\t\t\ttoFail1,\n\t\t\t\tp -> {\n\t\t\t\t\tfail(MessageFormat.format(\"Directory was created: {0}\", toFail1));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tassertNotNull(e);\n\t\t\t\t\tassertTrue(e instanceof FileAlreadyExistsException);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\tPath toFail2 = FileSystems.getDefault().getPath(dir_a.toString(), \"dir_a_x\", \"dir_a_y\", \"dir_a_z\");\n\t\t\twatcher.createDirectory(\n\t\t\t\ttoFail2,\n\t\t\t\tp -> {\n\t\t\t\t\tfail(MessageFormat.format(\"Directory was created: {0}\", toFail2));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tassertNotNull(e);\n\t\t\t\t\tassertTrue(e instanceof IOException);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\tif ( !latch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"Directory creation not completed in 1 minute.\");\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Test of createFile method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testCreateFile() throws IOException, InterruptedException {\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''createFile'' [on {0}]...\", root));\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\t\t\tCountDownLatch latch = new CountDownLatch(2);\n\t\t\tPath toBeCreated = FileSystems.getDefault().getPath(dir_a.toString(), \"created_file.txt\");\n\t\t\twatcher.createFile(\n\t\t\t\ttoBeCreated,\n\t\t\t\tt -> {\n\t\t\t\t\tassertNotNull(t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File not created: {0}\", toBeCreated));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\tPath toFail = FileSystems.getDefault().getPath(dir_a.toString(), \"non-exitent\", \"created_file.txt\");\n\t\t\twatcher.createFile(\n\t\t\t\ttoFail,\n\t\t\t\tt -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File was created: {0}\", toFail));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tassertNotNull(e);\n\t\t\t\t\tassertTrue(e instanceof IOException);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\tif ( !latch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File creation not completed in 1 minute.\");\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Test of delete method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testDelete() throws IOException, InterruptedException {\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''delete'' [on {0}]...\", root));\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\t\t\tCountDownLatch latch = new CountDownLatch(5);\n\t\t\twatcher.delete(\n\t\t\t\tfile_b2,\n\t\t\t\tt -> {\n\t\t\t\t\tassertTrue(t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File not deleted: {0}\", file_b2));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\twatcher.delete(\n\t\t\t\tfile_b2,\n\t\t\t\tt -> {\n\t\t\t\t\tassertFalse(t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File not deleted: {0}\", file_b2));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\twatcher.delete(\n\t\t\t\tdir_b,\n\t\t\t\tt -> {\n\t\t\t\t\tfail(MessageFormat.format(\"Non-empty directory was deleted: {0}\", file_b2));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tassertNotNull(e);\n\t\t\t\t\tassertTrue(e instanceof IOException);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\twatcher.delete(\n\t\t\t\tfile_b1,\n\t\t\t\tt -> {\n\t\t\t\t\tassertTrue(t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File not deleted: {0}\", file_b2));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\twatcher.delete(\n\t\t\t\tdir_b,\n\t\t\t\tt -> {\n\t\t\t\t\tassertTrue(t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"Directory not deleted: {0}\", file_b2));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\tif ( !latch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File deletion not completed in 1 minute.\");\n\t\t\t}\n\t\t\tassertFalse(Files.exists(dir_b));\n\t\t\tassertFalse(Files.exists(file_b1));\n\t\t\tassertFalse(Files.exists(file_b2));\n\t\t}\n\t}\n\t/**\n\t * Test of deleteTree method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testDeleteTree() throws IOException, InterruptedException {\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''deleteTree'' [on {0}]...\", root));\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\t\t\tCountDownLatch latch = new CountDownLatch(2);\n\t\t\twatcher.deleteTree(\n\t\t\t\tdir_a,\n\t\t\t\tt -> {\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"Tree not deleted: {0}\", file_b2));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\twatcher.deleteTree(\n\t\t\t\tPaths.get(\"a\", \"b\", \"c\", \"d\", \"e\", \"1\", \"2\", \"3\", \"4\", \"5\"),\n\t\t\t\tt -> {\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"Tree not deleted: {0}\", file_b2));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\tif ( !latch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File deletion not completed in 1 minute.\");\n\t\t\t}\n\t\t\tassertFalse(Files.exists(file_a_c));\n\t\t\tassertFalse(Files.exists(dir_a_c));\n\t\t\tassertFalse(Files.exists(file_a));\n\t\t\tassertFalse(Files.exists(dir_a));\n\t\t}\n\t}\n\t/**\n\t * Test of errors method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t */\n\t@Test\n\tpublic void testErrors() throws IOException {\n\t\tSystem.out.println(\"  Testing 'errors'...\");\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\t\t\tObservable<Throwable> errorsStream = watcher.errors();\n\t\t\tassertNotNull(errorsStream);\n\t\t}\n\t}\n\t/**\n\t * Test of events method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t */\n\t@Test\n\tpublic void testEvents() throws IOException {\n\t\tSystem.out.println(\"  Testing 'events'...\");\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\t\t\tObservable<DirectoryWatcher.DirectoryEvent> event = watcher.events();\n\t\t\tassertNotNull(event);\n\t\t}\n\t}\n\t/**\n\t * Test of isCloseComplete method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t */\n\t@Test\n\tpublic void testIsCloseComplete() throws IOException {\n\t\tSystem.out.println(\"  Testing 'isCloseComplete'...\");\n\t\tDirectoryWatcher watcher = build(executor);\n\t\tassertFalse(watcher.isClosed());\n\t\tassertFalse(watcher.isCloseComplete());\n\t\twatcher.close();\n\t\tassertFalse(watcher.isCloseComplete());\n\t\tassertTrue(watcher.isClosed());\n\t\tlong startTime = System.currentTimeMillis();\n\t\tlong currentTime = startTime;\n\t\twhile ( !watcher.isCloseComplete() && startTime + 60000L > currentTime ) {\n\t\t\tcurrentTime = System.currentTimeMillis();\n\t\t}\n\t\tassertTrue(watcher.isCloseComplete());\n\t}\n\t/**\n\t * Test of isClosed method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t */\n\t@Test\n\tpublic void testIsClosed() throws IOException {\n\t\tSystem.out.println(\"  Testing 'isClosed'...\");\n\t\tDirectoryWatcher watcher = build(executor);\n\t\tassertFalse(watcher.isClosed());\n\t\twatcher.close();\n\t\tassertTrue(watcher.isClosed());\n\t}\n\t/**\n\t * Test of isWatched method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\t@SuppressWarnings( \"CallToThreadYield\" )\n\tpublic void testIsWatched() throws IOException, InterruptedException {\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''isWatched'' [on {0}]...\", root));\n\t\tDirectoryWatcher watcher = build(executor);\n\t\twatcher.watch(dir_a);\n\t\tassertTrue(watcher.isWatched(dir_a));\n\t\twatcher.watch(dir_a_c);\n\t\tassertTrue(watcher.isWatched(dir_a_c));\n\t\twatcher.watch(dir_b);\n\t\tassertTrue(watcher.isWatched(dir_b));\n\t\tCountDownLatch latch = new CountDownLatch(1);\n\t\tDisposable subscription = watcher.events().subscribe(event -> {\n\t\t\tevent.getEvents().stream().forEach(e -> {\n\t\t\t\tif ( StandardWatchEventKinds.ENTRY_DELETE.equals(e.kind()) ) {\n\t\t\t\t\tSystem.out.println(\"    Path deleted: \" + e.context());\n\t\t\t\t\tif ( dir_a_c.equals(event.getWatchedPath().resolve((Path) e.context())) ) {\n\t\t\t\t\t\tlatch.countDown();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tFiles.walkFileTree(dir_a_c, new DeleteFileVisitor());\n\t\tif ( !latch.await(1, TimeUnit.MINUTES) ) {\n\t\t\tfail(\"File deletion not signalled in 1 minute.\");\n\t\t}\n\t\tassertFalse(watcher.isWatched(dir_a_c));\n\t\twatcher.delete(\n\t\t\tdir_a,\n\t\t\tsuccess -> assertFalse(watcher.isWatched(dir_a)),\n\t\t\tnull\n\t\t);\n\t\tsubscription.dispose();\n\t\twatcher.close();\n\t\twhile ( !watcher.isCloseComplete() ) {\n\t\t\tThread.yield();\n\t\t}\n\t\tassertFalse(watcher.isWatched(dir_b));\n\t}\n\t/**\n\t * Test of readBinaryFile method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testReadBinaryFile() throws IOException, InterruptedException {\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''readBinaryFile'' [on {0}]...\", root));\n\t\tbyte[] content = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x03, 0x02, 0x01, 0x00 };\n\t\tCountDownLatch latch = new CountDownLatch(2);\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\t\t\tFiles.write(file_b1, content);\n\t\t\twatcher.readBinaryFile(\n\t\t\t\tfile_b1,\n\t\t\t\tt -> {\n\t\t\t\t\tassertArrayEquals(content, t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File not read: {0}\", file_b1));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\tPath toFail = FileSystems.getDefault().getPath(dir_a.toString(), \"non-exitent\", \"created_file.txt\");\n\t\t\twatcher.readBinaryFile(\n\t\t\t\ttoFail,\n\t\t\t\tt -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File was read: {0}\", toFail));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tassertNotNull(e);\n\t\t\t\t\tassertTrue(e instanceof IOException);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\tif ( !latch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File creation not completed in 1 minute.\");\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Test of readTextFile method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testReadTextFile() throws IOException, InterruptedException {\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''readTextFile'' [on {0}]...\", root));\n\t\tString content = \"First line of text.\\nSecond line of text.\";\n\t\tCharset charset = defaultCharset();\n\t\tCountDownLatch latch = new CountDownLatch(2);\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\t\t\tFiles.write(file_b1, content.getBytes(charset), CREATE, WRITE, TRUNCATE_EXISTING);\n\t\t\twatcher.readTextFile(\n\t\t\t\tfile_b1,\n\t\t\t\tcharset,\n\t\t\t\tt -> {\n\t\t\t\t\tassertEquals(content, t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File not read: {0}\", file_b1));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\tPath toFail = FileSystems.getDefault().getPath(dir_a.toString(), \"non-exitent\", \"created_file.txt\");\n\t\t\twatcher.readTextFile(\n\t\t\t\ttoFail,\n\t\t\t\tcharset,\n\t\t\t\tt -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File was read: {0}\", toFail));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tassertNotNull(e);\n\t\t\t\t\tassertTrue(e instanceof IOException);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\tif ( !latch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File creation not completed in 1 minute.\");\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Test of writeBinaryFile and readBinaryFile method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testReadWriteBinaryFile() throws IOException, InterruptedException {\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''writeBinaryFile'' and ''readBinaryFile'' [on {0}]...\", root));\n\t\tbyte[] content = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x03, 0x02, 0x01, 0x00 };\n\t\tCountDownLatch latch = new CountDownLatch(2);\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\t\t\tPath readWriteFile = FileSystems.getDefault().getPath(dir_a.toString(), \"created_file.txt\");\n\t\t\twatcher.writeBinaryFile(\n\t\t\t\treadWriteFile,\n\t\t\t\tcontent,\n\t\t\t\tt -> {\n\t\t\t\t\tassertNotNull(t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File not written: {0}\", readWriteFile));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\twatcher.readBinaryFile(\n\t\t\t\treadWriteFile,\n\t\t\t\tt -> {\n\t\t\t\t\tassertArrayEquals(content, t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File not read: {0}\", file_b1));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\tif ( !latch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File creation not completed in 1 minute.\");\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Test of writeTextFile and readTextFile methods, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testReadWriteTextFile() throws IOException, InterruptedException {\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''writeTextFile'' and ''readTextFile'' [on {0}]...\", root));\n\t\tString content = \"First line of text.\\nSecond line of text.\";\n\t\tCharset charset = defaultCharset();\n\t\tCountDownLatch latch = new CountDownLatch(2);\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\t\t\tPath readWriteFile = FileSystems.getDefault().getPath(dir_a.toString(), \"created_file.txt\");\n\t\t\twatcher.writeTextFile(\n\t\t\t\treadWriteFile,\n\t\t\t\tcontent,\n\t\t\t\tcharset,\n\t\t\t\tt -> {\n\t\t\t\t\tassertNotNull(t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File not written: {0}\", readWriteFile));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\twatcher.readTextFile(\n\t\t\t\treadWriteFile,\n\t\t\t\tcharset,\n\t\t\t\tt -> {\n\t\t\t\t\tassertEquals(content, t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File not read: {0}\", file_b1));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\tif ( !latch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File creation not completed in 1 minute.\");\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Test of unwatch method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t */\n\t@Test\n\tpublic void testUnwatch() throws IOException {\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''unwatch'' [on {0}]...\", root));\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\t\t\twatcher.watch(dir_a);\n\t\t\tassertTrue(watcher.isWatched(dir_a));\n\t\t\twatcher.watch(dir_a_c);\n\t\t\tassertTrue(watcher.isWatched(dir_a_c));\n\t\t\twatcher.watch(dir_b);\n\t\t\tassertTrue(watcher.isWatched(dir_b));\n\t\t\twatcher.unwatch(dir_a);\n\t\t\tassertFalse(watcher.isWatched(dir_a));\n\t\t\twatcher.unwatch(dir_a_c);\n\t\t\tassertFalse(watcher.isWatched(dir_a_c));\n\t\t\twatcher.unwatch(dir_b);\n\t\t\tassertFalse(watcher.isWatched(dir_b));\n\t\t}\n\t}\n\t/**\n\t * Test of watch method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testWatch() throws IOException, InterruptedException {\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''watch'' [on {0}]...\", root));\n\t\tCountDownLatch createLatch = new CountDownLatch(1);\n\t\tCountDownLatch deleteLatch = new CountDownLatch(1);\n\t\tCountDownLatch modifyLatch = new CountDownLatch(1);\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\t\t\tDisposable subscription = watcher.events().subscribe(event -> {\n\t\t\t\tevent.getEvents().stream().forEach(e -> {\n\t\t\t\t\tif ( StandardWatchEventKinds.ENTRY_CREATE.equals(e.kind()) ) {\n\t\t\t\t\t\tSystem.out.println(\"    File created: \" + e.context());\n\t\t\t\t\t\tcreateLatch.countDown();\n\t\t\t\t\t} else if ( StandardWatchEventKinds.ENTRY_DELETE.equals(e.kind()) ) {\n\t\t\t\t\t\tSystem.out.println(\"    File deleted: \" + e.context());\n\t\t\t\t\t\tdeleteLatch.countDown();\n\t\t\t\t\t} else if ( StandardWatchEventKinds.ENTRY_MODIFY.equals(e.kind()) ) {\n\t\t\t\t\t\tSystem.out.println(\"    File modified: \" + e.context());\n\t\t\t\t\t\tmodifyLatch.countDown();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t\twatcher.watch(root);\n\t\t\tPath tmpFile = Files.createTempFile(root, \"DW_\", \".test\");\n\t\t\tif ( !createLatch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File creation not signalled in 1 minute.\");\n\t\t\t}\n\t\t\tFiles.write(tmpFile, \"Some text content\".getBytes(), APPEND);\n\t\t\tif ( !modifyLatch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File modification not signalled in 1 minute.\");\n\t\t\t}\n\t\t\tFiles.delete(tmpFile);\n\t\t\tif ( !deleteLatch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File deletion not signalled in 1 minute.\");\n\t\t\t}\n\t\t\tsubscription.dispose();\n\t\t}\n\t}\n\t/**\n\t * Test of watchOrStreamError method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testWatchOrStreamError() throws IOException, InterruptedException {\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''watchOrStreamError'' [on {0}]...\", root));\n\t\tCountDownLatch errorLatch = new CountDownLatch(1);\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\t\t\tDisposable subscription = watcher.errors().subscribe(throwable -> {\n\t\t\t\tif ( throwable instanceof NotDirectoryException ) {\n\t\t\t\t\terrorLatch.countDown();\n\t\t\t\t}\n\t\t\t});\n\t\t\twatcher.watchOrStreamError(file_a);\n\t\t\tif ( !errorLatch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File deletion not signalled in 1 minute.\");\n\t\t\t}\n\t\t\tsubscription.dispose();\n\t\t}\n\t}\n\t/**\n\t * Test of watchUp and unwatchUp methods, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t */\n\t@Test\n\tpublic void testWatchUpAndUnwatchUp() throws IOException {\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''watchUp'' and ''unwatchUp'' [on {0}]...\", root));\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\t\t\twatcher.watchUp(dir_a_c, root);\n\t\t\tassertTrue(watcher.isWatched(dir_a));\n\t\t\tassertTrue(watcher.isWatched(dir_a_c));\n\t\t\tassertFalse(watcher.isWatched(root));\n\t\t\twatcher.watch(root);\n\t\t\tassertTrue(watcher.isWatched(root));\n\t\t\twatcher.unwatchUp(dir_a_c, root);\n\t\t\tassertFalse(watcher.isWatched(dir_a));\n\t\t\tassertFalse(watcher.isWatched(dir_a_c));\n\t\t\tassertTrue(watcher.isWatched(root));\n\t\t}\n\t}\n\t/**\n\t * Test of writeBinaryFile method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testWriteBinaryFile() throws IOException, InterruptedException {\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''writeBinaryFile'' [on {0}]...\", root));\n\t\tbyte[] content = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x03, 0x02, 0x01, 0x00 };\n\t\tCountDownLatch latch = new CountDownLatch(2);\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\t\t\tPath toBeCreated = FileSystems.getDefault().getPath(dir_a.toString(), \"created_file.txt\");\n\t\t\twatcher.writeBinaryFile(\n\t\t\t\ttoBeCreated,\n\t\t\t\tcontent,\n\t\t\t\tt -> {\n\t\t\t\t\tassertNotNull(t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File not written: {0}\", toBeCreated));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\tPath toFail = FileSystems.getDefault().getPath(dir_a.toString(), \"non-exitent\", \"created_file.txt\");\n\t\t\twatcher.writeBinaryFile(\n\t\t\t\ttoFail,\n\t\t\t\tcontent,\n\t\t\t\tt -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File was written: {0}\", toFail));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tassertNotNull(e);\n\t\t\t\t\tassertTrue(e instanceof IOException);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\tif ( !latch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File creation not completed in 1 minute.\");\n\t\t\t}\n\t\t\tassertArrayEquals(content, Files.readAllBytes(toBeCreated));\n\t\t}\n\t}\n\t/**\n\t * Test of writeTextFile method, of class DirectoryWatcher.\n\t *\n\t * @throws java.io.IOException\n\t * @throws java.lang.InterruptedException\n\t */\n\t@Test\n\tpublic void testWriteTextFile() throws IOException, InterruptedException {\n\t\tSystem.out.println(MessageFormat.format(\"  Testing ''writeTextFile'' [on {0}]...\", root));\n\t\tString content = \"First line of text.\\nSecond line of text.\";\n\t\tCharset charset = defaultCharset();\n\t\tCountDownLatch latch = new CountDownLatch(2);\n\t\ttry ( DirectoryWatcher watcher = build(executor) ) {\n\t\t\tPath toBeCreated = FileSystems.getDefault().getPath(dir_a.toString(), \"created_file.txt\");\n\t\t\twatcher.writeTextFile(\n\t\t\t\ttoBeCreated,\n\t\t\t\tcontent,\n\t\t\t\tcharset,\n\t\t\t\tt -> {\n\t\t\t\t\tassertNotNull(t);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File not written: {0}\", toBeCreated));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\tPath toFail = FileSystems.getDefault().getPath(dir_a.toString(), \"non-exitent\", \"created_file.txt\");\n\t\t\twatcher.writeTextFile(\n\t\t\t\ttoFail,\n\t\t\t\tcontent,\n\t\t\t\tcharset,\n\t\t\t\tt -> {\n\t\t\t\t\tfail(MessageFormat.format(\"File was written: {0}\", toFail));\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t},\n\t\t\t\te -> {\n\t\t\t\t\tassertNotNull(e);\n\t\t\t\t\tassertTrue(e instanceof IOException);\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t);\n\t\t\tif ( !latch.await(1, TimeUnit.MINUTES) ) {\n\t\t\t\tfail(\"File creation not completed in 1 minute.\");\n\t\t\t}\n\t\t\tassertEquals(content, new String(Files.readAllBytes(toBeCreated), charset));\n\t\t}\n\t}\n"]]}
{"hexsha": "8ee5ef0c8ee0282c20642cb3d1e484e0a0cae12b", "ext": "java", "lang": "Java", "content": "public class JvmMetricsStartTest {\n\n    private MetricRegistry metricRegistry;\n    private JvmMetricsStart callback;\n\n    @Before\n    public void before() {\n        metricRegistry = new MetricRegistry();\n        callback = new JvmMetricsStart(metricRegistry);\n    }\n\n    @Test\n    public void testOnBrokerStart_metricsRegistered() throws Exception {\n\n        callback.onBrokerStart();\n\n        final SortedSet<String> names = metricRegistry.getNames();\n\n        //check for at least one metric from each metric set\n        assertTrue(names.contains(\"com.hivemq.jvm.buffer-pool.direct.count\"));\n        assertTrue(names.contains(\"com.hivemq.jvm.buffer-pool.mapped.count\"));\n        assertTrue(names.contains(\"com.hivemq.jvm.class-loader.loaded\"));\n        assertTrue(names.contains(\"com.hivemq.jvm.file-descriptor.ratio\"));\n        assertTrue(names.contains(\"com.hivemq.jvm.garbage-collector.PS-MarkSweep.count\"));\n        assertTrue(names.contains(\"com.hivemq.jvm.garbage-collector.PS-Scavenge.count\"));\n        assertTrue(names.contains(\"com.hivemq.jvm.memory.heap.max\"));\n        assertTrue(names.contains(\"com.hivemq.jvm.memory.non-heap.max\"));\n        assertTrue(names.contains(\"com.hivemq.jvm.memory.total.max\"));\n        assertTrue(names.contains(\"com.hivemq.jvm.threads.count\"));\n    }\n}", "class_id": 0, "repo": "hivemq/jvm-metrics-plugin", "file": "src/test/java/com/hivemq/plugins/jvmmetrics/callbacks/JvmMetricsStartTest.java", "last_update_at": "2019-04-28T03:18:22+00:00", "question_id": "8ee5ef0c8ee0282c20642cb3d1e484e0a0cae12b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class JvmMetricsStartTest {\n    private MetricRegistry metricRegistry;\n    private JvmMetricsStart callback;\n    @Before\n    public void before() {\n        metricRegistry = new MetricRegistry();\n        callback = new JvmMetricsStart(metricRegistry);\n    }\n    @Test\n    public void testOnBrokerStart_metricsRegistered() throws Exception {\n        callback.onBrokerStart();\n        final SortedSet<String> names = metricRegistry.getNames();\n        //check for at least one metric from each metric set\n        assertTrue(names.contains(\"com.hivemq.jvm.buffer-pool.direct.count\"));\n        assertTrue(names.contains(\"com.hivemq.jvm.buffer-pool.mapped.count\"));\n        assertTrue(names.contains(\"com.hivemq.jvm.class-loader.loaded\"));\n        assertTrue(names.contains(\"com.hivemq.jvm.file-descriptor.ratio\"));\n        assertTrue(names.contains(\"com.hivemq.jvm.garbage-collector.PS-MarkSweep.count\"));\n        assertTrue(names.contains(\"com.hivemq.jvm.garbage-collector.PS-Scavenge.count\"));\n        assertTrue(names.contains(\"com.hivemq.jvm.memory.heap.max\"));\n        assertTrue(names.contains(\"com.hivemq.jvm.memory.non-heap.max\"));\n        assertTrue(names.contains(\"com.hivemq.jvm.memory.total.max\"));\n        assertTrue(names.contains(\"com.hivemq.jvm.threads.count\"));\n    }\n"]]}
{"hexsha": "93b3490859b65aadc79743e3929d101eaa8ecc65", "ext": "java", "lang": "Java", "content": "public class Resource {\n  private final String resourceUrl;\n  private final AuthzStatus priorAclDecision;\n  \n  public Resource(String url, AuthzStatus priorAclDecision) {\n    resourceUrl = url;\n    this.priorAclDecision = priorAclDecision;\n  }\n  \n  public String getUrl() {\n    return resourceUrl;\n  }\n  \n  public AuthzStatus getPriorAclDecision() {\n    return priorAclDecision;\n  }\n\n  /**\n   * Gets a collection of resources from a collection of urls with no Acls.\n   * @param urls collection of urls.\n   * @return collection of resources.\n   */\n  public static Collection<Resource> urlsToResourcesNoAcls(Collection<String> urls) {\n    ImmutableList.Builder<Resource> resources = ImmutableList.builder();\n    for (String url : urls) {\n      resources.add(new Resource(url, null));\n    }\n    return resources.build();\n  }\n\n  /**\n   * Gets the urls in a list of Resources.\n   * @param resources collection of resources.\n   * @return collection of urls.\n   */\n  public static Collection<String> resourcesToUrls(Collection<Resource> resources) {\n    ImmutableList.Builder<String> resourceUrls = ImmutableList.builder();\n    for (Resource resource : resources) {\n      resourceUrls.add(resource.getUrl());\n    }\n    return resourceUrls.build();\n  }\n\n}", "class_id": 0, "repo": "szab100/secmgr", "file": "src/main/java/com/google/enterprise/secmgr/common/Resource.java", "last_update_at": "2019-03-19T16:52:11+00:00", "question_id": "93b3490859b65aadc79743e3929d101eaa8ecc65", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Resource {\n  private final String resourceUrl;\n  private final AuthzStatus priorAclDecision;\n  public Resource(String url, AuthzStatus priorAclDecision) {\n    resourceUrl = url;\n    this.priorAclDecision = priorAclDecision;\n  }\n  public String getUrl() {\n    return resourceUrl;\n  }\n  public AuthzStatus getPriorAclDecision() {\n    return priorAclDecision;\n  }\n  /**\n   * Gets a collection of resources from a collection of urls with no Acls.\n   * @param urls collection of urls.\n   * @return collection of resources.\n   */\n  public static Collection<Resource> urlsToResourcesNoAcls(Collection<String> urls) {\n    ImmutableList.Builder<Resource> resources = ImmutableList.builder();\n    for (String url : urls) {\n      resources.add(new Resource(url, null));\n    }\n    return resources.build();\n  }\n  /**\n   * Gets the urls in a list of Resources.\n   * @param resources collection of resources.\n   * @return collection of urls.\n   */\n  public static Collection<String> resourcesToUrls(Collection<Resource> resources) {\n    ImmutableList.Builder<String> resourceUrls = ImmutableList.builder();\n    for (Resource resource : resources) {\n      resourceUrls.add(resource.getUrl());\n    }\n    return resourceUrls.build();\n  }\n"]]}
{"hexsha": "6b7fa9ffc9aedfba70fa6d992497088c5ee95939", "ext": "java", "lang": "Java", "content": "public class ConnectInfo\n\timplements IMessageEntity\n{\n\n\tpublic ConnectInfo()\n\t{\n\t//    0    0:aload_0         \n\t//    1    1:invokespecial   #19  <Method void Object()>\n\t//    2    4:return          \n\t}\n\n\tpublic ConnectInfo(List list, List list1, String s, String s1)\n\t{\n\t//    0    0:aload_0         \n\t//    1    1:invokespecial   #19  <Method void Object()>\n\t\tapiNameList = list;\n\t//    2    4:aload_0         \n\t//    3    5:aload_1         \n\t//    4    6:putfield        #23  <Field List apiNameList>\n\t\tscopeList = list1;\n\t//    5    9:aload_0         \n\t//    6   10:aload_2         \n\t//    7   11:putfield        #25  <Field List scopeList>\n\t\tfingerprint = s;\n\t//    8   14:aload_0         \n\t//    9   15:aload_3         \n\t//   10   16:putfield        #27  <Field String fingerprint>\n\t\tsubAppID = s1;\n\t//   11   19:aload_0         \n\t//   12   20:aload           4\n\t//   13   22:putfield        #29  <Field String subAppID>\n\t//   14   25:return          \n\t}\n\n\tpublic List getApiNameList()\n\t{\n\t\treturn apiNameList;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #23  <Field List apiNameList>\n\t//    2    4:areturn         \n\t}\n\n\tpublic String getFingerprint()\n\t{\n\t\treturn fingerprint;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #27  <Field String fingerprint>\n\t//    2    4:areturn         \n\t}\n\n\tpublic List getScopeList()\n\t{\n\t\treturn scopeList;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #25  <Field List scopeList>\n\t//    2    4:areturn         \n\t}\n\n\tpublic String getSubAppID()\n\t{\n\t\treturn subAppID;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #29  <Field String subAppID>\n\t//    2    4:areturn         \n\t}\n\n\tpublic void setApiNameList(List list)\n\t{\n\t\tapiNameList = list;\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:putfield        #23  <Field List apiNameList>\n\t//    3    5:return          \n\t}\n\n\tpublic void setFingerprint(String s)\n\t{\n\t\tfingerprint = s;\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:putfield        #27  <Field String fingerprint>\n\t//    3    5:return          \n\t}\n\n\tpublic void setScopeList(List list)\n\t{\n\t\tscopeList = list;\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:putfield        #25  <Field List scopeList>\n\t//    3    5:return          \n\t}\n\n\tpublic void setSubAppID(String s)\n\t{\n\t\tsubAppID = s;\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:putfield        #29  <Field String subAppID>\n\t//    3    5:return          \n\t}\n\n\tprivate List apiNameList;\n\tprivate String fingerprint;\n\tprivate List scopeList;\n\tprivate String subAppID;\n}", "class_id": 0, "repo": "Andreas237/AndroidPolicyAutomation", "file": "ExtractedJars/Health_com.huawei.health/javafiles/com/huawei/hms/support/api/entity/core/ConnectInfo.java", "last_update_at": "2019-07-06T22:21:59+00:00", "question_id": "6b7fa9ffc9aedfba70fa6d992497088c5ee95939", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ConnectInfo\n\timplements IMessageEntity\n{\n\tpublic ConnectInfo()\n\t{\n\t//    0    0:aload_0         \n\t//    1    1:invokespecial   #19  <Method void Object()>\n\t//    2    4:return          \n\t}\n\tpublic ConnectInfo(List list, List list1, String s, String s1)\n\t{\n\t//    0    0:aload_0         \n\t//    1    1:invokespecial   #19  <Method void Object()>\n\t\tapiNameList = list;\n\t//    2    4:aload_0         \n\t//    3    5:aload_1         \n\t//    4    6:putfield        #23  <Field List apiNameList>\n\t\tscopeList = list1;\n\t//    5    9:aload_0         \n\t//    6   10:aload_2         \n\t//    7   11:putfield        #25  <Field List scopeList>\n\t\tfingerprint = s;\n\t//    8   14:aload_0         \n\t//    9   15:aload_3         \n\t//   10   16:putfield        #27  <Field String fingerprint>\n\t\tsubAppID = s1;\n\t//   11   19:aload_0         \n\t//   12   20:aload           4\n\t//   13   22:putfield        #29  <Field String subAppID>\n\t//   14   25:return          \n\t}\n\tpublic List getApiNameList()\n\t{\n\t\treturn apiNameList;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #23  <Field List apiNameList>\n\t//    2    4:areturn         \n\t}\n\tpublic String getFingerprint()\n\t{\n\t\treturn fingerprint;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #27  <Field String fingerprint>\n\t//    2    4:areturn         \n\t}\n\tpublic List getScopeList()\n\t{\n\t\treturn scopeList;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #25  <Field List scopeList>\n\t//    2    4:areturn         \n\t}\n\tpublic String getSubAppID()\n\t{\n\t\treturn subAppID;\n\t//    0    0:aload_0         \n\t//    1    1:getfield        #29  <Field String subAppID>\n\t//    2    4:areturn         \n\t}\n\tpublic void setApiNameList(List list)\n\t{\n\t\tapiNameList = list;\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:putfield        #23  <Field List apiNameList>\n\t//    3    5:return          \n\t}\n\tpublic void setFingerprint(String s)\n\t{\n\t\tfingerprint = s;\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:putfield        #27  <Field String fingerprint>\n\t//    3    5:return          \n\t}\n\tpublic void setScopeList(List list)\n\t{\n\t\tscopeList = list;\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:putfield        #25  <Field List scopeList>\n\t//    3    5:return          \n\t}\n\tpublic void setSubAppID(String s)\n\t{\n\t\tsubAppID = s;\n\t//    0    0:aload_0         \n\t//    1    1:aload_1         \n\t//    2    2:putfield        #29  <Field String subAppID>\n\t//    3    5:return          \n\t}\n\tprivate List apiNameList;\n\tprivate String fingerprint;\n\tprivate List scopeList;\n\tprivate String subAppID;\n"]]}
{"hexsha": "4e0c4f164ba0e837f6c3ae51d983cd6447416911", "ext": "java", "lang": "Java", "content": "@XmlRootElement\npublic class CourseSchedule {\n\n    private short taughtYear;\n    private short startPeriod;\n    private short endPeriod;\n    private short periodIdxAmongAllPlanPeriods;\n\n    private CourseSchedule(){\n        // for jaxb\n    }\n    public short getPeriodIdxAmongAllPlanPeriods() {\n        return periodIdxAmongAllPlanPeriods;\n    }\n\n    public void setPeriodIdxAmongAllPlanPeriods(short periodIdxAmongAllPlanPeriods) {\n        this.periodIdxAmongAllPlanPeriods = periodIdxAmongAllPlanPeriods;\n    }\n\n    public CourseSchedule(short taughtYear, short startPeriod) {\n        this.taughtYear = taughtYear;\n        this.startPeriod = startPeriod;\n    }\n    \n    public CourseSchedule(short taughtYear, short startPeriod, short periodIdxAmongAllPlanPeriods) {\n        this.taughtYear = taughtYear;\n        this.startPeriod = startPeriod;\n        this.periodIdxAmongAllPlanPeriods = periodIdxAmongAllPlanPeriods;\n    }\n\n    public short getTaughtYear() {\n        return taughtYear;\n    }\n\n    public void setTaughtYear(short taughtYear) {\n        this.taughtYear = taughtYear;\n    }\n\n    public short getStartPeriod() {\n        return startPeriod;\n    }\n\n    public void setStartPeriod(short startPeriod) {\n        this.startPeriod = startPeriod;\n    }\n\n    public short getEndPeriod() {\n        return endPeriod;\n    }\n\n    public void setEndPeriod(short endPeriod) {\n        this.endPeriod = endPeriod;\n    }\n\n    @Override\n    public int hashCode() {\n        int hash = 7;\n        hash = 83 * hash + this.taughtYear;\n        hash = 83 * hash + this.startPeriod;\n        hash = 83 * hash + this.endPeriod;\n        return hash;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        final CourseSchedule other = (CourseSchedule) obj;\n        if (this.taughtYear != other.taughtYear) {\n            return false;\n        }\n        if (this.startPeriod != other.startPeriod) {\n            return false;\n        }\n        if (this.endPeriod != other.endPeriod) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"CourseSchedule{\" + \"taughtYear=\" + taughtYear + \", startPeriod=\" + startPeriod + \", endPeriod=\" + endPeriod + '}';\n    }\n\n}", "class_id": 0, "repo": "yong-at-git/CourseRecommenderParent", "file": "CourseRecommenderAPI/src/main/java/se/uu/it/cs/recsys/api/type/CourseSchedule.java", "last_update_at": "2019-08-01T19:17:18+00:00", "question_id": "4e0c4f164ba0e837f6c3ae51d983cd6447416911", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@XmlRootElement\npublic class CourseSchedule {\n    private short taughtYear;\n    private short startPeriod;\n    private short endPeriod;\n    private short periodIdxAmongAllPlanPeriods;\n    private CourseSchedule(){\n        // for jaxb\n    }\n    public short getPeriodIdxAmongAllPlanPeriods() {\n        return periodIdxAmongAllPlanPeriods;\n    }\n    public void setPeriodIdxAmongAllPlanPeriods(short periodIdxAmongAllPlanPeriods) {\n        this.periodIdxAmongAllPlanPeriods = periodIdxAmongAllPlanPeriods;\n    }\n    public CourseSchedule(short taughtYear, short startPeriod) {\n        this.taughtYear = taughtYear;\n        this.startPeriod = startPeriod;\n    }\n    public CourseSchedule(short taughtYear, short startPeriod, short periodIdxAmongAllPlanPeriods) {\n        this.taughtYear = taughtYear;\n        this.startPeriod = startPeriod;\n        this.periodIdxAmongAllPlanPeriods = periodIdxAmongAllPlanPeriods;\n    }\n    public short getTaughtYear() {\n        return taughtYear;\n    }\n    public void setTaughtYear(short taughtYear) {\n        this.taughtYear = taughtYear;\n    }\n    public short getStartPeriod() {\n        return startPeriod;\n    }\n    public void setStartPeriod(short startPeriod) {\n        this.startPeriod = startPeriod;\n    }\n    public short getEndPeriod() {\n        return endPeriod;\n    }\n    public void setEndPeriod(short endPeriod) {\n        this.endPeriod = endPeriod;\n    }\n    @Override\n    public int hashCode() {\n        int hash = 7;\n        hash = 83 * hash + this.taughtYear;\n        hash = 83 * hash + this.startPeriod;\n        hash = 83 * hash + this.endPeriod;\n        return hash;\n    }\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        final CourseSchedule other = (CourseSchedule) obj;\n        if (this.taughtYear != other.taughtYear) {\n            return false;\n        }\n        if (this.startPeriod != other.startPeriod) {\n            return false;\n        }\n        if (this.endPeriod != other.endPeriod) {\n            return false;\n        }\n        return true;\n    }\n    @Override\n    public String toString() {\n        return \"CourseSchedule{\" + \"taughtYear=\" + taughtYear + \", startPeriod=\" + startPeriod + \", endPeriod=\" + endPeriod + '}';\n    }\n"]]}
{"hexsha": "555331c8f5a38f9f59cfbdbf6b8688ac45e9d4f3", "ext": "java", "lang": "Java", "content": "public class ParseThreddsMetadataCreatedDate\n{\n//    @Parameterized.Parameters\n//    public static Collection<Object[]> junk()\n//    {\n//\n//    }\n\n    @Test\n    public void parseDataFormat()\n            throws URISyntaxException,\n                   XMLStreamException,\n                   ThreddsXmlParserException\n    {\n        String docBaseUriString = \"http://cat2.stax.ParseMetadataTest/parseDataFormat.xml\";\n\n        String mdXml = \"<dataFormat>NEXRAD-2</dataFormat>\";\n\n        parseDataFormatHelper( docBaseUriString, mdXml );\n    }\n\n    @Test\n    public void parseDataFormatWrapped()\n            throws URISyntaxException,\n                   ThreddsXmlParserException\n    {\n        String docBaseUriString = \"http://cat2.stax.ParseMetadataTest/parseDataFormatWrapped.xml\";\n        String mdXml = \"<metadata><dataFormat>NEXRAD-2</dataFormat></metadata>\";\n\n        parseDataFormatHelper( docBaseUriString, mdXml );\n    }\n\n    @Test\n    public void parseDataFormatInherited()\n            throws URISyntaxException,\n                   ThreddsXmlParserException\n    {\n        String docBaseUriString = \"http://cat2.stax.ParseMetadataTest/parseDataFormatInherited.xml\";\n        String mdXml = \"<metadata inherited='true'><dataFormat>NEXRAD-2</dataFormat></metadata>\";\n\n        parseDataFormatHelper( docBaseUriString, mdXml );\n    }\n\n    private void assertCreatDateAsExpected( ThreddsMetadataBuilder.DatePointBuilder datePointBuilder )\n    {\n\n    }\n\n    private void parseDataFormatHelper( String docBaseUriString, String mdXml )\n            throws URISyntaxException,\n                   ThreddsXmlParserException\n    {\n        URI docBaseUri = new URI( docBaseUriString );\n        String catalogXml = CatalogXmlUtils.wrapThreddsXmlInContainerDataset( mdXml );\n\n        CatalogBuilder catBuilder = CatalogXmlUtils.parseCatalogIntoBuilder( docBaseUri, catalogXml );\n\n        assertNotNull( catBuilder );\n\n        DatasetBuilder dsBldr = CatalogXmlUtils.assertCatalogWithContainerDatasetAsExpected( catBuilder, docBaseUri );\n        ThreddsMetadataBuilder tmdBldr = dsBldr.getThreddsMetadataBuilder();\n        DataFormatType dataFormat = tmdBldr.getDataFormat();\n        assertEquals( dataFormat, DataFormatType.NEXRAD2 );\n    }\n\n}", "class_id": 0, "repo": "joansmith3/thredds", "file": "archive/src/test/java/thredds/catalog2/xml/parser/stax/ParseThreddsMetadataCreatedDate.java", "last_update_at": "2019-01-22T11:30:51+00:00", "question_id": "555331c8f5a38f9f59cfbdbf6b8688ac45e9d4f3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ParseThreddsMetadataCreatedDate\n{\n//    @Parameterized.Parameters\n//    public static Collection<Object[]> junk()\n//    {\n//\n//    }\n    @Test\n    public void parseDataFormat()\n            throws URISyntaxException,\n                   XMLStreamException,\n                   ThreddsXmlParserException\n    {\n        String docBaseUriString = \"http://cat2.stax.ParseMetadataTest/parseDataFormat.xml\";\n        String mdXml = \"<dataFormat>NEXRAD-2</dataFormat>\";\n        parseDataFormatHelper( docBaseUriString, mdXml );\n    }\n    @Test\n    public void parseDataFormatWrapped()\n            throws URISyntaxException,\n                   ThreddsXmlParserException\n    {\n        String docBaseUriString = \"http://cat2.stax.ParseMetadataTest/parseDataFormatWrapped.xml\";\n        String mdXml = \"<metadata><dataFormat>NEXRAD-2</dataFormat></metadata>\";\n        parseDataFormatHelper( docBaseUriString, mdXml );\n    }\n    @Test\n    public void parseDataFormatInherited()\n            throws URISyntaxException,\n                   ThreddsXmlParserException\n    {\n        String docBaseUriString = \"http://cat2.stax.ParseMetadataTest/parseDataFormatInherited.xml\";\n        String mdXml = \"<metadata inherited='true'><dataFormat>NEXRAD-2</dataFormat></metadata>\";\n        parseDataFormatHelper( docBaseUriString, mdXml );\n    }\n    private void assertCreatDateAsExpected( ThreddsMetadataBuilder.DatePointBuilder datePointBuilder )\n    {\n    }\n    private void parseDataFormatHelper( String docBaseUriString, String mdXml )\n            throws URISyntaxException,\n                   ThreddsXmlParserException\n    {\n        URI docBaseUri = new URI( docBaseUriString );\n        String catalogXml = CatalogXmlUtils.wrapThreddsXmlInContainerDataset( mdXml );\n        CatalogBuilder catBuilder = CatalogXmlUtils.parseCatalogIntoBuilder( docBaseUri, catalogXml );\n        assertNotNull( catBuilder );\n        DatasetBuilder dsBldr = CatalogXmlUtils.assertCatalogWithContainerDatasetAsExpected( catBuilder, docBaseUri );\n        ThreddsMetadataBuilder tmdBldr = dsBldr.getThreddsMetadataBuilder();\n        DataFormatType dataFormat = tmdBldr.getDataFormat();\n        assertEquals( dataFormat, DataFormatType.NEXRAD2 );\n    }\n"]]}
{"hexsha": "6a74a054baab0863fb72b0acca404e4117016e5b", "ext": "java", "lang": "Java", "content": "public class OddEvenLinkedList {\n\n    public ListNode oddEvenList(ListNode head) {\n\n        if (head == null || head.next == null) return head;\n\n        ListNode oddNode = head;\n        ListNode evenNode = head.next;\n        ListNode firstEvenNode = head.next;\n\n        while (oddNode.next != null && evenNode.next != null) {\n            ListNode tmp = oddNode;\n            oddNode = oddNode.next.next;\n            tmp.next = oddNode;\n            tmp = evenNode;\n            evenNode = evenNode.next.next;\n            tmp.next = evenNode;\n        }\n\n        oddNode.next = firstEvenNode;\n        evenNode.next = null;\n\n        return head;\n\n    }\n\n}", "class_id": 0, "repo": "18810817370/LeetCodePracticeJava", "file": "Java/src/mideum/_328/OddEvenLinkedList.java", "last_update_at": "2019-03-19T12:04:20+00:00", "question_id": "6a74a054baab0863fb72b0acca404e4117016e5b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OddEvenLinkedList {\n    public ListNode oddEvenList(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode oddNode = head;\n        ListNode evenNode = head.next;\n        ListNode firstEvenNode = head.next;\n        while (oddNode.next != null && evenNode.next != null) {\n            ListNode tmp = oddNode;\n            oddNode = oddNode.next.next;\n            tmp.next = oddNode;\n            tmp = evenNode;\n            evenNode = evenNode.next.next;\n            tmp.next = evenNode;\n        }\n        oddNode.next = firstEvenNode;\n        evenNode.next = null;\n        return head;\n    }\n"]]}
{"hexsha": "32763839c821bbb58ed324d11364a24375818f13", "ext": "java", "lang": "Java", "content": "public class Workspace {\n\tprivate static final Logger log = LoggerFactory.getLogger(Workspace.class);\n\n\tprivate PersistenceDirectoryManager<Challenge> challengeManager;\n\t\n\tprivate PersistenceDirectoryManager<String> modelManager;\n\tprivate PersistenceDirectoryManager<Playground> playgroundManager;\n\n\tprivate PersistenceDirectoryManager<PersistedInput> inputManager;\n\tprivate PersistenceDirectoryManager<PersistedOutput> outputManager;\n\tprivate PersistenceDirectoryManager<PersistedTest> testManager;\n\n\tprivate PersistenceFileManager configurationManager;\n\tprivate Configuration configuration;\n\tprivate PersistenceFileManager accessLogManager;\n\tprivate AccessLog accessLog;\n\n\tprivate HybridDecisionSession decisionSession;\n\n\tpublic Workspace(String workspaceUUID) throws Exception {\n\t\tmodelManager = new PersistenceDirectoryManager<>(workspaceUUID, \"models\", String.class, \"dmn\");\n\t\tplaygroundManager = new PersistenceDirectoryManager<>(workspaceUUID, \"playgrounds\", Playground.class, \"json\");\n\t\tchallengeManager = new PersistenceDirectoryManager<>(workspaceUUID, \"challenges\", Challenge.class, \"json\");\n\t\tinputManager = new PersistenceDirectoryManager<>(workspaceUUID, \"inputs\", PersistedInput.class, \"json\");\n\t\toutputManager = new PersistenceDirectoryManager<>(workspaceUUID, \"outputs\", PersistedOutput.class, \"json\");\n\t\ttestManager = new PersistenceDirectoryManager<>(workspaceUUID, \"tests\", PersistedTest.class, \"json\");\n\n\t\tconfigurationManager = new PersistenceFileManager(workspaceUUID, \"configuration.json\");\n\t\tconfiguration = new Configuration(configurationManager);\n\n\t\taccessLogManager = new PersistenceFileManager(workspaceUUID, \"access.log\");\n\t\taccessLog = new AccessLog(accessLogManager);\n\n\t\tdecisionSession = new HybridDecisionSession();\n\n\t\tDroolsHelper.importModels(this);\n\t}\n\t\n\tpublic PersistenceDirectoryManager<Challenge> getChallengeManager() {\n\t\treturn challengeManager;\n\t}\n\n\tpublic PersistenceDirectoryManager<String> getModelManager() {\n\t\treturn modelManager;\n\t}\n\n\tpublic PersistenceDirectoryManager<Playground> getPlaygroundManager() {\n\t\treturn playgroundManager;\n\t}\n\n\tpublic PersistenceDirectoryManager<PersistedInput> getInputManager() {\n\t\treturn inputManager;\n\t}\n\n\tpublic PersistenceDirectoryManager<PersistedOutput> getOutputManager() {\n\t\treturn outputManager;\n\t}\n\n\tpublic PersistenceDirectoryManager<PersistedTest> getTestManager() {\n\t\treturn testManager;\n\t}\n\n\tpublic HybridDecisionSession getDecisionSession() {\n\t\treturn decisionSession;\n\t}\n\n\tpublic void clearDecisionSession() throws Exception {\n\t\tdecisionSession = new HybridDecisionSession();\n\t}\n\n\tpublic Configuration getConfig() {\n\t\treturn configuration;\n\t}\n\n\tpublic AccessLog getAccessLog() {\n\t\treturn accessLog;\n\t}\n\n\tpublic void verify() throws IOException {\n\t\tmodelManager.verifyAllFiles();\n\t\tplaygroundManager.verifyAllFiles();\n\t\tinputManager.verifyAllFiles();\n\t\toutputManager.verifyAllFiles();\n\t\ttestManager.verifyAllFiles();\n\t}\n}", "class_id": 0, "repo": "materna-se/dmn-tester", "file": "server/src/main/java/de/materna/dmn/tester/servlets/workspace/beans/Workspace.java", "last_update_at": "2019-07-01T09:34:12+00:00", "question_id": "32763839c821bbb58ed324d11364a24375818f13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Workspace {\n\tprivate static final Logger log = LoggerFactory.getLogger(Workspace.class);\n\tprivate PersistenceDirectoryManager<Challenge> challengeManager;\n\t\n\tprivate PersistenceDirectoryManager<String> modelManager;\n\tprivate PersistenceDirectoryManager<Playground> playgroundManager;\n\tprivate PersistenceDirectoryManager<PersistedInput> inputManager;\n\tprivate PersistenceDirectoryManager<PersistedOutput> outputManager;\n\tprivate PersistenceDirectoryManager<PersistedTest> testManager;\n\tprivate PersistenceFileManager configurationManager;\n\tprivate Configuration configuration;\n\tprivate PersistenceFileManager accessLogManager;\n\tprivate AccessLog accessLog;\n\tprivate HybridDecisionSession decisionSession;\n\tpublic Workspace(String workspaceUUID) throws Exception {\n\t\tmodelManager = new PersistenceDirectoryManager<>(workspaceUUID, \"models\", String.class, \"dmn\");\n\t\tplaygroundManager = new PersistenceDirectoryManager<>(workspaceUUID, \"playgrounds\", Playground.class, \"json\");\n\t\tchallengeManager = new PersistenceDirectoryManager<>(workspaceUUID, \"challenges\", Challenge.class, \"json\");\n\t\tinputManager = new PersistenceDirectoryManager<>(workspaceUUID, \"inputs\", PersistedInput.class, \"json\");\n\t\toutputManager = new PersistenceDirectoryManager<>(workspaceUUID, \"outputs\", PersistedOutput.class, \"json\");\n\t\ttestManager = new PersistenceDirectoryManager<>(workspaceUUID, \"tests\", PersistedTest.class, \"json\");\n\t\tconfigurationManager = new PersistenceFileManager(workspaceUUID, \"configuration.json\");\n\t\tconfiguration = new Configuration(configurationManager);\n\t\taccessLogManager = new PersistenceFileManager(workspaceUUID, \"access.log\");\n\t\taccessLog = new AccessLog(accessLogManager);\n\t\tdecisionSession = new HybridDecisionSession();\n\t\tDroolsHelper.importModels(this);\n\t}\n\t\n\tpublic PersistenceDirectoryManager<Challenge> getChallengeManager() {\n\t\treturn challengeManager;\n\t}\n\tpublic PersistenceDirectoryManager<String> getModelManager() {\n\t\treturn modelManager;\n\t}\n\tpublic PersistenceDirectoryManager<Playground> getPlaygroundManager() {\n\t\treturn playgroundManager;\n\t}\n\tpublic PersistenceDirectoryManager<PersistedInput> getInputManager() {\n\t\treturn inputManager;\n\t}\n\tpublic PersistenceDirectoryManager<PersistedOutput> getOutputManager() {\n\t\treturn outputManager;\n\t}\n\tpublic PersistenceDirectoryManager<PersistedTest> getTestManager() {\n\t\treturn testManager;\n\t}\n\tpublic HybridDecisionSession getDecisionSession() {\n\t\treturn decisionSession;\n\t}\n\tpublic void clearDecisionSession() throws Exception {\n\t\tdecisionSession = new HybridDecisionSession();\n\t}\n\tpublic Configuration getConfig() {\n\t\treturn configuration;\n\t}\n\tpublic AccessLog getAccessLog() {\n\t\treturn accessLog;\n\t}\n\tpublic void verify() throws IOException {\n\t\tmodelManager.verifyAllFiles();\n\t\tplaygroundManager.verifyAllFiles();\n\t\tinputManager.verifyAllFiles();\n\t\toutputManager.verifyAllFiles();\n\t\ttestManager.verifyAllFiles();\n\t}\n"]]}
{"hexsha": "b4e86ebccc11e0a83580d62e69b75ac5e6832dd8", "ext": "java", "lang": "Java", "content": "public class AuthenticationUserService implements UserDetailsService {\n\n  private UserRepository userRepository;\n\n  public AuthenticationUserService(UserRepository userRepository) {\n    this.userRepository = userRepository;\n  }\n\n  @Override\n  public UserDetails loadUserByUsername(String id) throws UsernameNotFoundException {\n    User user = userRepository.findById(id);\n    if (user == null) {\n      throw new UsernameNotFoundException(\"Not found: \" + id);\n    }\n    return new AuthenticationUser(user);\n  }\n}", "class_id": 0, "repo": "alextremp/hashtagsxrep", "file": "src/main/java/cat/xarxarepublicana/hashtagsxrep/infrastructure/security/AuthenticationUserService.java", "last_update_at": "2019-05-10T08:27:51+00:00", "question_id": "b4e86ebccc11e0a83580d62e69b75ac5e6832dd8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AuthenticationUserService implements UserDetailsService {\n  private UserRepository userRepository;\n  public AuthenticationUserService(UserRepository userRepository) {\n    this.userRepository = userRepository;\n  }\n  @Override\n  public UserDetails loadUserByUsername(String id) throws UsernameNotFoundException {\n    User user = userRepository.findById(id);\n    if (user == null) {\n      throw new UsernameNotFoundException(\"Not found: \" + id);\n    }\n    return new AuthenticationUser(user);\n  }\n"]]}
{"hexsha": "83363982165be6cd29bfe88c44fd30a52f9b8633", "ext": "java", "lang": "Java", "content": "public class SchemaConverter {\n  private static final Logger LOGGER = LoggerFactory.getLogger(SchemaConverter.class);\n\n  public static SimpleFeatureType schemaToFeatureType(\n      final StructType schema,\n      final String typeName) {\n    final SimpleFeatureTypeBuilder typeBuilder = new SimpleFeatureTypeBuilder();\n    typeBuilder.setName(typeName);\n    typeBuilder.setNamespaceURI(BasicFeatureTypes.DEFAULT_NAMESPACE);\n    try {\n      typeBuilder.setCRS(CRS.decode(\"EPSG:4326\", true));\n    } catch (final FactoryException e) {\n      LOGGER.error(e.getMessage(), e);\n    }\n\n    final AttributeTypeBuilder attrBuilder = new AttributeTypeBuilder();\n\n    for (final StructField field : schema.fields()) {\n      final AttributeDescriptor attrDesc = attrDescFromStructField(attrBuilder, field);\n\n      typeBuilder.add(attrDesc);\n    }\n\n    return typeBuilder.buildFeatureType();\n  }\n\n  private static AttributeDescriptor attrDescFromStructField(\n      final AttributeTypeBuilder attrBuilder,\n      final StructField field) {\n    if (field.name().equals(\"geom\")) {\n      return attrBuilder.binding(Geometry.class).nillable(false).buildDescriptor(\"geom\");\n    }\n    if (field.dataType() == DataTypes.StringType) {\n      return attrBuilder.binding(String.class).buildDescriptor(field.name());\n    } else if (field.dataType() == DataTypes.DoubleType) {\n      return attrBuilder.binding(Double.class).buildDescriptor(field.name());\n    } else if (field.dataType() == DataTypes.FloatType) {\n      return attrBuilder.binding(Float.class).buildDescriptor(field.name());\n    } else if (field.dataType() == DataTypes.LongType) {\n      return attrBuilder.binding(Long.class).buildDescriptor(field.name());\n    } else if (field.dataType() == DataTypes.IntegerType) {\n      return attrBuilder.binding(Integer.class).buildDescriptor(field.name());\n    } else if (field.dataType() == DataTypes.BooleanType) {\n      return attrBuilder.binding(Boolean.class).buildDescriptor(field.name());\n    } else if (field.dataType() == DataTypes.TimestampType) {\n      return attrBuilder.binding(Date.class).buildDescriptor(field.name());\n    }\n\n    return null;\n  }\n\n  public static StructType schemaFromFeatureType(final SimpleFeatureType featureType) {\n    final List<StructField> fields = new ArrayList<>();\n\n    for (final AttributeDescriptor attrDesc : featureType.getAttributeDescriptors()) {\n      final SimpleFeatureDataType sfDataType = attrDescToDataType(attrDesc);\n\n      final String fieldName = (sfDataType.isGeom() ? \"geom\" : attrDesc.getName().getLocalPart());\n\n      final StructField field =\n          DataTypes.createStructField(fieldName, sfDataType.getDataType(), true);\n\n      fields.add(field);\n    }\n\n    if (fields.isEmpty()) {\n      LOGGER.error(\"Feature type produced empty dataframe schema!\");\n      return null;\n    }\n\n    return DataTypes.createStructType(fields);\n  }\n\n  private static SimpleFeatureDataType attrDescToDataType(final AttributeDescriptor attrDesc) {\n    boolean isGeom = false;\n    DataType dataTypeOut = DataTypes.NullType;\n\n    if (attrDesc.getType().getBinding().equals(String.class)) {\n\n      dataTypeOut = DataTypes.StringType;\n    } else if (attrDesc.getType().getBinding().equals(Double.class)) {\n      dataTypeOut = DataTypes.DoubleType;\n    } else if (attrDesc.getType().getBinding().equals(Float.class)) {\n      dataTypeOut = DataTypes.FloatType;\n    } else if (attrDesc.getType().getBinding().equals(Long.class)) {\n      dataTypeOut = DataTypes.LongType;\n    } else if (attrDesc.getType().getBinding().equals(Integer.class)) {\n      dataTypeOut = DataTypes.IntegerType;\n    } else if (attrDesc.getType().getBinding().equals(Boolean.class)) {\n      dataTypeOut = DataTypes.BooleanType;\n    } else if (attrDesc.getType().getBinding().equals(Date.class)) {\n      dataTypeOut = DataTypes.TimestampType;\n    }\n\n    // Custom geometry types get WKB encoding\n    else if (Geometry.class.isAssignableFrom(attrDesc.getType().getBinding())) {\n      dataTypeOut = GeoWaveSpatialEncoders.geometryUDT;\n      isGeom = true;\n    }\n\n    return new SimpleFeatureDataType(dataTypeOut, isGeom);\n  }\n}", "class_id": 0, "repo": "jhickman-prominent/geowave", "file": "analytics/spark/src/main/java/org/locationtech/geowave/analytic/spark/sparksql/util/SchemaConverter.java", "last_update_at": "2019-12-03T14:07:43+00:00", "question_id": "83363982165be6cd29bfe88c44fd30a52f9b8633", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SchemaConverter {\n  private static final Logger LOGGER = LoggerFactory.getLogger(SchemaConverter.class);\n  public static SimpleFeatureType schemaToFeatureType(\n      final StructType schema,\n      final String typeName) {\n    final SimpleFeatureTypeBuilder typeBuilder = new SimpleFeatureTypeBuilder();\n    typeBuilder.setName(typeName);\n    typeBuilder.setNamespaceURI(BasicFeatureTypes.DEFAULT_NAMESPACE);\n    try {\n      typeBuilder.setCRS(CRS.decode(\"EPSG:4326\", true));\n    } catch (final FactoryException e) {\n      LOGGER.error(e.getMessage(), e);\n    }\n    final AttributeTypeBuilder attrBuilder = new AttributeTypeBuilder();\n    for (final StructField field : schema.fields()) {\n      final AttributeDescriptor attrDesc = attrDescFromStructField(attrBuilder, field);\n      typeBuilder.add(attrDesc);\n    }\n    return typeBuilder.buildFeatureType();\n  }\n  private static AttributeDescriptor attrDescFromStructField(\n      final AttributeTypeBuilder attrBuilder,\n      final StructField field) {\n    if (field.name().equals(\"geom\")) {\n      return attrBuilder.binding(Geometry.class).nillable(false).buildDescriptor(\"geom\");\n    }\n    if (field.dataType() == DataTypes.StringType) {\n      return attrBuilder.binding(String.class).buildDescriptor(field.name());\n    } else if (field.dataType() == DataTypes.DoubleType) {\n      return attrBuilder.binding(Double.class).buildDescriptor(field.name());\n    } else if (field.dataType() == DataTypes.FloatType) {\n      return attrBuilder.binding(Float.class).buildDescriptor(field.name());\n    } else if (field.dataType() == DataTypes.LongType) {\n      return attrBuilder.binding(Long.class).buildDescriptor(field.name());\n    } else if (field.dataType() == DataTypes.IntegerType) {\n      return attrBuilder.binding(Integer.class).buildDescriptor(field.name());\n    } else if (field.dataType() == DataTypes.BooleanType) {\n      return attrBuilder.binding(Boolean.class).buildDescriptor(field.name());\n    } else if (field.dataType() == DataTypes.TimestampType) {\n      return attrBuilder.binding(Date.class).buildDescriptor(field.name());\n    }\n    return null;\n  }\n  public static StructType schemaFromFeatureType(final SimpleFeatureType featureType) {\n    final List<StructField> fields = new ArrayList<>();\n    for (final AttributeDescriptor attrDesc : featureType.getAttributeDescriptors()) {\n      final SimpleFeatureDataType sfDataType = attrDescToDataType(attrDesc);\n      final String fieldName = (sfDataType.isGeom() ? \"geom\" : attrDesc.getName().getLocalPart());\n      final StructField field =\n          DataTypes.createStructField(fieldName, sfDataType.getDataType(), true);\n      fields.add(field);\n    }\n    if (fields.isEmpty()) {\n      LOGGER.error(\"Feature type produced empty dataframe schema!\");\n      return null;\n    }\n    return DataTypes.createStructType(fields);\n  }\n  private static SimpleFeatureDataType attrDescToDataType(final AttributeDescriptor attrDesc) {\n    boolean isGeom = false;\n    DataType dataTypeOut = DataTypes.NullType;\n    if (attrDesc.getType().getBinding().equals(String.class)) {\n      dataTypeOut = DataTypes.StringType;\n    } else if (attrDesc.getType().getBinding().equals(Double.class)) {\n      dataTypeOut = DataTypes.DoubleType;\n    } else if (attrDesc.getType().getBinding().equals(Float.class)) {\n      dataTypeOut = DataTypes.FloatType;\n    } else if (attrDesc.getType().getBinding().equals(Long.class)) {\n      dataTypeOut = DataTypes.LongType;\n    } else if (attrDesc.getType().getBinding().equals(Integer.class)) {\n      dataTypeOut = DataTypes.IntegerType;\n    } else if (attrDesc.getType().getBinding().equals(Boolean.class)) {\n      dataTypeOut = DataTypes.BooleanType;\n    } else if (attrDesc.getType().getBinding().equals(Date.class)) {\n      dataTypeOut = DataTypes.TimestampType;\n    }\n    // Custom geometry types get WKB encoding\n    else if (Geometry.class.isAssignableFrom(attrDesc.getType().getBinding())) {\n      dataTypeOut = GeoWaveSpatialEncoders.geometryUDT;\n      isGeom = true;\n    }\n    return new SimpleFeatureDataType(dataTypeOut, isGeom);\n  }\n"]]}
{"hexsha": "b22a251b850cc3425deb6d83bfb30027031b9cc4", "ext": "java", "lang": "Java", "content": "public class ActionFacadeLogicImpl\n    extends ActionFacadeLogic\n{\n    private static final long serialVersionUID = 34L;\n    /**\n     * @param metaObject\n     * @param context\n     */\n    public ActionFacadeLogicImpl(\n        final org.eclipse.uml2.Action metaObject,\n        final String context)\n    {\n        super(metaObject, context);\n    }\n\n    /**\n     * @return owner\n     * @see org.andromda.metafacades.uml.ActionFacade#getTransition()\n     */\n    protected Object handleGetTransition()\n    {\n        final Element owner = this.metaObject.getActivity().getOwner();\n        return owner instanceof Transition ? owner : null;\n    }\n\n    /**\n     * @return owner\n     * @see org.andromda.metafacades.uml.ActionFacade#getActionState()\n     */\n    protected Object handleGetActionState()\n    {\n        final Element owner = this.metaObject.getActivity().getOwner();\n        return owner instanceof State ? owner : null;\n    }\n\n    /**\n     * @see org.andromda.core.metafacade.MetafacadeBase#getValidationOwner()\n     */\n    public Object getValidationOwner()\n    {\n        Object validationOwner = getTransition();\n\n        if (validationOwner == null)\n        {\n            validationOwner = getActionState();\n        }\n\n        return validationOwner;\n    }\n}", "class_id": 0, "repo": "wpradnyana/andromda", "file": "metafacades/uml/emf/uml2/src/main/java/org/andromda/metafacades/emf/uml2/ActionFacadeLogicImpl.java", "last_update_at": "2019-11-02T06:25:37+00:00", "question_id": "b22a251b850cc3425deb6d83bfb30027031b9cc4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ActionFacadeLogicImpl\n    extends ActionFacadeLogic\n{\n    private static final long serialVersionUID = 34L;\n    /**\n     * @param metaObject\n     * @param context\n     */\n    public ActionFacadeLogicImpl(\n        final org.eclipse.uml2.Action metaObject,\n        final String context)\n    {\n        super(metaObject, context);\n    }\n    /**\n     * @return owner\n     * @see org.andromda.metafacades.uml.ActionFacade#getTransition()\n     */\n    protected Object handleGetTransition()\n    {\n        final Element owner = this.metaObject.getActivity().getOwner();\n        return owner instanceof Transition ? owner : null;\n    }\n    /**\n     * @return owner\n     * @see org.andromda.metafacades.uml.ActionFacade#getActionState()\n     */\n    protected Object handleGetActionState()\n    {\n        final Element owner = this.metaObject.getActivity().getOwner();\n        return owner instanceof State ? owner : null;\n    }\n    /**\n     * @see org.andromda.core.metafacade.MetafacadeBase#getValidationOwner()\n     */\n    public Object getValidationOwner()\n    {\n        Object validationOwner = getTransition();\n        if (validationOwner == null)\n        {\n            validationOwner = getActionState();\n        }\n        return validationOwner;\n    }\n"]]}
{"hexsha": "3000c4a07de26d597f41f5e1397ab49958c4d4e4", "ext": "java", "lang": "Java", "content": "public class PointTest {\n\n    private Point point;\n    private VectorSequence coordinates;\n\n    @Test\n    public void isEmptyTest() {\n        point = new Point();\n        assertFalse(point.isEmpty());\n    }\n\n\n    @Test\n    public void makeDimensionTest() {\n        Point point1 = new Point();\n        point1.makeDimension(2);\n        assertTrue(point1.getDimension() == 2);\n    }\n\n\n    @Test\n    public void loadTest() {\n        Point p = new Point(1, 1, 1);\n        try {\n            byte[] bytes = p.storeToByteArray();\n            long s = p.getByteArraySize();\n            assertTrue(bytes.length == s);\n            Point p2 = new Point();\n            p2.loadFromByteArray(bytes);\n            assertTrue(p2.getDimension() == 3);\n            assertTrue(p2.getY() == 1);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    @Test\n    public void storeTest() {\n        Point p = new Point(1, 1, 1);\n        try {\n            byte[] t = p.storeToByteArray();\n            Point p1 = (Point) p.clone();\n            byte[] t2 = p1.storeToByteArray();\n            assertEquals(t.length, t2.length);\n            assertArrayEquals(t, t2);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n\n    }\n\n    @Test\n    public void getByteArraySizeTest() {\n        point = new Point();\n        long byteArraySize = point.getByteArraySize();\n        try {\n            byte[] bs = point.storeToByteArray();\n            assertEquals(bs.length, byteArraySize);\n        } catch (IOException e) {\n\n        }\n    }\n\n    @Test\n    public void cloneTest() {\n        Point point1 = new Point(1, 2, 3);\n        Point point2 = (Point) point1.clone();\n        assertEquals(point1, point2);\n        System.out.println(point1.getVectorSequence());\n        System.out.println(point2.getVectorSequence());\n        assertEquals(point1.getVectorSequence(), point2.getVectorSequence());\n        assertTrue(point2.getX() == point1.getX());\n        assertTrue(point2.getY() == 2);\n        assertTrue(point2.getZ() == 3);\n\n        Point point3 = new Point(3);\n        VectorSequence coordinate1 = point3.getVectorSequence();\n        coordinate1.add(4, 5, 6);\n        Point point4 = (Point) point3.clone();\n        System.out.println(point4.getDimension());\n        Vector v = point4.getVectorSequence().getVector(1);\n        assertTrue(v.getX() == 4);\n        assertTrue(v.getY() == 5);\n        assertTrue(v.getZ() == 6);\n\n        double[] de = {1.2, 1.4, 1.5};\n        VectorSequence vectorSequence = new PackedVectorSequence(de, 3);\n        Point point5 = new Point(vectorSequence);\n    }\n\n}", "class_id": 0, "repo": "ZhenwenHe/gtl-java", "file": "common/src/test/java/cn/edu/cug/cs/gtl/geom/PointTest.java", "last_update_at": "2019-11-19T13:26:28+00:00", "question_id": "3000c4a07de26d597f41f5e1397ab49958c4d4e4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PointTest {\n    private Point point;\n    private VectorSequence coordinates;\n    @Test\n    public void isEmptyTest() {\n        point = new Point();\n        assertFalse(point.isEmpty());\n    }\n    @Test\n    public void makeDimensionTest() {\n        Point point1 = new Point();\n        point1.makeDimension(2);\n        assertTrue(point1.getDimension() == 2);\n    }\n    @Test\n    public void loadTest() {\n        Point p = new Point(1, 1, 1);\n        try {\n            byte[] bytes = p.storeToByteArray();\n            long s = p.getByteArraySize();\n            assertTrue(bytes.length == s);\n            Point p2 = new Point();\n            p2.loadFromByteArray(bytes);\n            assertTrue(p2.getDimension() == 3);\n            assertTrue(p2.getY() == 1);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    @Test\n    public void storeTest() {\n        Point p = new Point(1, 1, 1);\n        try {\n            byte[] t = p.storeToByteArray();\n            Point p1 = (Point) p.clone();\n            byte[] t2 = p1.storeToByteArray();\n            assertEquals(t.length, t2.length);\n            assertArrayEquals(t, t2);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    @Test\n    public void getByteArraySizeTest() {\n        point = new Point();\n        long byteArraySize = point.getByteArraySize();\n        try {\n            byte[] bs = point.storeToByteArray();\n            assertEquals(bs.length, byteArraySize);\n        } catch (IOException e) {\n        }\n    }\n    @Test\n    public void cloneTest() {\n        Point point1 = new Point(1, 2, 3);\n        Point point2 = (Point) point1.clone();\n        assertEquals(point1, point2);\n        System.out.println(point1.getVectorSequence());\n        System.out.println(point2.getVectorSequence());\n        assertEquals(point1.getVectorSequence(), point2.getVectorSequence());\n        assertTrue(point2.getX() == point1.getX());\n        assertTrue(point2.getY() == 2);\n        assertTrue(point2.getZ() == 3);\n        Point point3 = new Point(3);\n        VectorSequence coordinate1 = point3.getVectorSequence();\n        coordinate1.add(4, 5, 6);\n        Point point4 = (Point) point3.clone();\n        System.out.println(point4.getDimension());\n        Vector v = point4.getVectorSequence().getVector(1);\n        assertTrue(v.getX() == 4);\n        assertTrue(v.getY() == 5);\n        assertTrue(v.getZ() == 6);\n        double[] de = {1.2, 1.4, 1.5};\n        VectorSequence vectorSequence = new PackedVectorSequence(de, 3);\n        Point point5 = new Point(vectorSequence);\n    }\n"]]}
{"hexsha": "25b569027fdbb487b2fda5b46c9f39236b227963", "ext": "java", "lang": "Java", "content": "public class PUT_NaturalIdIT extends JerseyTestOnDerby {\n\n    @Override\n    protected void doAddResources(FeatureContext context) {\n        context.register(Resource.class);\n    }\n\n    @Test\n    public void test_PUT_SingleId() {\n        insert(\"e20\", \"name\", \"'John'\");\n        insert(\"e20\", \"name\", \"'Brian'\");\n\n        Response response = target(\"/single-id/John\")\n                .request()\n                .put(Entity.json(\"{\\\"age\\\":28,\\\"description\\\":\\\"zzz\\\"}\"));\n\n        onSuccess(response).bodyEquals(1, \"{\\\"id\\\":\\\"John\\\",\\\"age\\\":28,\\\"description\\\":\\\"zzz\\\",\\\"name\\\":\\\"John\\\"}\");\n\n        assertEquals(1, intForQuery(\"SELECT COUNT(1) FROM utest.e20 WHERE age = 28 AND description = 'zzz'\"));\n    }\n\n    @Test\n    public void test_PUT_Single_Id_SeveralExistingObjects() {\n        insert(\"e20\", \"name\", \"'John'\");\n        insert(\"e20\", \"name\", \"'John'\");\n\n        Response response = target(\"/single-id/John\").request().put(Entity.json(\"{\\\"age\\\":28,\\\"description\\\":\\\"zzz\\\"}\"));\n\n        assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());\n        assertEquals(\"{\\\"success\\\":false,\\\"message\\\":\\\"Found more than one object for ID 'John' and entity 'E20'\\\"}\",\n                response.readEntity(String.class));\n    }\n\n    @Test\n    public void test_PUT_MultiId() {\n        insert(\"e21\", \"age, name\", \"18, 'John'\");\n        insert(\"e21\", \"age, name\", \"27, 'Brian'\");\n\n        Response response = target(\"/multi-id/byid\").queryParam(\"age\", 18)\n                .queryParam(\"name\", \"John\")\n                .request().put(Entity.json(\"{\\\"age\\\":28,\\\"description\\\":\\\"zzz\\\"}\"));\n\n        onSuccess(response).bodyEquals(1,\n                \"{\\\"id\\\":{\\\"age\\\":28,\\\"name\\\":\\\"John\\\"},\\\"age\\\":28,\\\"description\\\":\\\"zzz\\\",\\\"name\\\":\\\"John\\\"}\");\n\n        assertEquals(1, intForQuery(\"SELECT COUNT(1) FROM utest.e21 WHERE age = 28 AND description = 'zzz'\"));\n    }\n\n    @Test\n    public void test_PUT_SeveralExistingObjects_MultiId() {\n        insert(\"e21\", \"age, name\", \"18, 'John'\");\n        insert(\"e21\", \"age, name\", \"18, 'John'\");\n\n        Response response = target(\"/multi-id/byid\").queryParam(\"age\", 18).queryParam(\"name\", \"John\")\n                .request().put(Entity.json(\"{\\\"age\\\":28,\\\"description\\\":\\\"zzz\\\"}\"));\n\n        assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());\n        assertEquals(\"{\\\"success\\\":false,\\\"message\\\":\\\"Found more than one object for ID '{name:John,age:18}' and entity 'E21'\\\"}\",\n                response.readEntity(String.class));\n    }\n\n    @Path(\"\")\n    public static class Resource {\n\n        @Context\n        private Configuration config;\n\n        @PUT\n        @Path(\"single-id/{id}\")\n        public DataResponse<E20> createOrUpdate_E20(\n                @PathParam(\"id\") String name,\n                EntityUpdate<E20> update,\n                @Context UriInfo uriInfo) {\n\n            return Ag.idempotentCreateOrUpdate(E20.class, config).id(name).uri(uriInfo).syncAndSelect(update);\n        }\n\n        @PUT\n        @Path(\"multi-id/byid\")\n        public DataResponse<E21> createOrUpdate_E21(\n                @QueryParam(\"age\") int age,\n                @QueryParam(\"name\") String name,\n                EntityUpdate<E21> update,\n                @Context UriInfo uriInfo) {\n\n            Map<String, Object> id = new HashMap<>(3);\n            id.put(\"age\", age);\n            id.put(\"name\", name);\n            return Ag.idempotentCreateOrUpdate(E21.class, config).id(id).uri(uriInfo).syncAndSelect(update);\n        }\n    }\n\n}", "class_id": 0, "repo": "vyarmolovich/agrest", "file": "agrest/src/test/java/io/agrest/it/PUT_NaturalIdIT.java", "last_update_at": "2019-11-20T10:23:38+00:00", "question_id": "25b569027fdbb487b2fda5b46c9f39236b227963", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PUT_NaturalIdIT extends JerseyTestOnDerby {\n    @Override\n    protected void doAddResources(FeatureContext context) {\n        context.register(Resource.class);\n    }\n    @Test\n    public void test_PUT_SingleId() {\n        insert(\"e20\", \"name\", \"'John'\");\n        insert(\"e20\", \"name\", \"'Brian'\");\n        Response response = target(\"/single-id/John\")\n                .request()\n                .put(Entity.json(\"{\\\"age\\\":28,\\\"description\\\":\\\"zzz\\\"}\"));\n        onSuccess(response).bodyEquals(1, \"{\\\"id\\\":\\\"John\\\",\\\"age\\\":28,\\\"description\\\":\\\"zzz\\\",\\\"name\\\":\\\"John\\\"}\");\n        assertEquals(1, intForQuery(\"SELECT COUNT(1) FROM utest.e20 WHERE age = 28 AND description = 'zzz'\"));\n    }\n    @Test\n    public void test_PUT_Single_Id_SeveralExistingObjects() {\n        insert(\"e20\", \"name\", \"'John'\");\n        insert(\"e20\", \"name\", \"'John'\");\n        Response response = target(\"/single-id/John\").request().put(Entity.json(\"{\\\"age\\\":28,\\\"description\\\":\\\"zzz\\\"}\"));\n        assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());\n        assertEquals(\"{\\\"success\\\":false,\\\"message\\\":\\\"Found more than one object for ID 'John' and entity 'E20'\\\"}\",\n                response.readEntity(String.class));\n    }\n    @Test\n    public void test_PUT_MultiId() {\n        insert(\"e21\", \"age, name\", \"18, 'John'\");\n        insert(\"e21\", \"age, name\", \"27, 'Brian'\");\n        Response response = target(\"/multi-id/byid\").queryParam(\"age\", 18)\n                .queryParam(\"name\", \"John\")\n                .request().put(Entity.json(\"{\\\"age\\\":28,\\\"description\\\":\\\"zzz\\\"}\"));\n        onSuccess(response).bodyEquals(1,\n                \"{\\\"id\\\":{\\\"age\\\":28,\\\"name\\\":\\\"John\\\"},\\\"age\\\":28,\\\"description\\\":\\\"zzz\\\",\\\"name\\\":\\\"John\\\"}\");\n        assertEquals(1, intForQuery(\"SELECT COUNT(1) FROM utest.e21 WHERE age = 28 AND description = 'zzz'\"));\n    }\n    @Test\n    public void test_PUT_SeveralExistingObjects_MultiId() {\n        insert(\"e21\", \"age, name\", \"18, 'John'\");\n        insert(\"e21\", \"age, name\", \"18, 'John'\");\n        Response response = target(\"/multi-id/byid\").queryParam(\"age\", 18).queryParam(\"name\", \"John\")\n                .request().put(Entity.json(\"{\\\"age\\\":28,\\\"description\\\":\\\"zzz\\\"}\"));\n        assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());\n        assertEquals(\"{\\\"success\\\":false,\\\"message\\\":\\\"Found more than one object for ID '{name:John,age:18}' and entity 'E21'\\\"}\",\n                response.readEntity(String.class));\n    }\n    @Path(\"\")\n    public static class Resource {\n        @Context\n        private Configuration config;\n        @PUT\n        @Path(\"single-id/{id}\")\n        public DataResponse<E20> createOrUpdate_E20(\n                @PathParam(\"id\") String name,\n                EntityUpdate<E20> update,\n                @Context UriInfo uriInfo) {\n            return Ag.idempotentCreateOrUpdate(E20.class, config).id(name).uri(uriInfo).syncAndSelect(update);\n        }\n        @PUT\n        @Path(\"multi-id/byid\")\n        public DataResponse<E21> createOrUpdate_E21(\n                @QueryParam(\"age\") int age,\n                @QueryParam(\"name\") String name,\n                EntityUpdate<E21> update,\n                @Context UriInfo uriInfo) {\n            Map<String, Object> id = new HashMap<>(3);\n            id.put(\"age\", age);\n            id.put(\"name\", name);\n            return Ag.idempotentCreateOrUpdate(E21.class, config).id(id).uri(uriInfo).syncAndSelect(update);\n        }\n    }\n"]]}
{"hexsha": "6d269195af8aff7c49389f53431ea814820b9662", "ext": "java", "lang": "Java", "content": "public class ProvisioningClassLoaderConfigurer implements ClassLoaderConfigurer {\n    // just some default if one is not set\n    private URL[] added = new URL[0];\n    private Filter excluded = FalseFilter.INSTANCE;\n\n    @Override\n    public URL[] additionalURLs() {\n        return added;\n    }\n\n    @Override\n    public boolean accept(final URL url) {\n        try {\n            final File file = URLs.toFile(url);\n            return !excluded.accept(file.getName());\n        } catch (final IllegalArgumentException iae) {\n            return true;\n        }\n    }\n\n    public void setConfiguration(final String configFile) {\n        final Collection<URL> toAdd = new ArrayList<URL>();\n        final Collection<String> toExclude = new ArrayList<String>();\n\n        BufferedReader reader = null;\n        try {\n            reader = new BufferedReader(new FileReader(configFile));\n\n            String line;\n            while ((line = reader.readLine()) != null) {\n                line = PropertyPlaceHolderHelper.SUBSTITUTOR.replace(line.trim());\n                if (line.startsWith(\"#\") || line.isEmpty()) {\n                    continue;\n                }\n\n                if (line.startsWith(\"-\")) {\n                    toExclude.add(line);\n                } else {\n                    if (line.startsWith(\"+\")) {\n                        line = line.substring(1);\n                    }\n\n                    String location = line;\n                    String algo = \"MD5\";\n                    String hash = null;\n                    final boolean validJar = line.contains(\"|\");\n\n                    if (validJar) {\n                        final String[] segments = line.split(\"|\");\n                        location = segments[0];\n                        if (segments.length >= 2) {\n                            hash = segments[1];\n                        }\n                        if (segments.length >= 3) {\n                            algo = segments[2].trim();\n                        }\n\n                    }\n\n                    final Set<URL> repos = toUrls(ProvisioningUtil.realLocation(location));\n                    toAdd.addAll(repos);\n\n                    if (validJar) {\n                        final String computedHash = Files.hash(repos, algo);\n                        if (!computedHash.equals(hash)) {\n                            throw new IllegalStateException(\"Hash of \" + location + \"(\" + computedHash + \") doesn't match expected one (\" + hash + \")\");\n                        }\n                    }\n                }\n            }\n\n        } catch (final Exception e) {\n            Logger.getInstance(LogCategory.OPENEJB, ProvisioningClassLoaderConfigurer.class).error(\"Can't read \" + configFile, e);\n        } finally {\n            IO.close(reader);\n        }\n\n        added = toAdd.toArray(new URL[toAdd.size()]);\n        if (toExclude.size() > 0) {\n            excluded = Filters.prefixes(toExclude.toArray(new String[toExclude.size()]));\n        }\n    }\n\n    private static Set<URL> toUrls(final Set<String> strings) {\n        final Set<URL> urls = new HashSet<>();\n        for (final String s : strings) {\n            try {\n                urls.add(new File(s).toURI().toURL());\n            } catch (final MalformedURLException e) {\n                throw new IllegalArgumentException(e);\n            }\n        }\n        return urls;\n    }\n}", "class_id": 0, "repo": "ferdisn/tomee", "file": "container/openejb-core/src/main/java/org/apache/openejb/classloader/ProvisioningClassLoaderConfigurer.java", "last_update_at": "2019-08-02T07:59:58+00:00", "question_id": "6d269195af8aff7c49389f53431ea814820b9662", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ProvisioningClassLoaderConfigurer implements ClassLoaderConfigurer {\n    // just some default if one is not set\n    private URL[] added = new URL[0];\n    private Filter excluded = FalseFilter.INSTANCE;\n    @Override\n    public URL[] additionalURLs() {\n        return added;\n    }\n    @Override\n    public boolean accept(final URL url) {\n        try {\n            final File file = URLs.toFile(url);\n            return !excluded.accept(file.getName());\n        } catch (final IllegalArgumentException iae) {\n            return true;\n        }\n    }\n    public void setConfiguration(final String configFile) {\n        final Collection<URL> toAdd = new ArrayList<URL>();\n        final Collection<String> toExclude = new ArrayList<String>();\n        BufferedReader reader = null;\n        try {\n            reader = new BufferedReader(new FileReader(configFile));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                line = PropertyPlaceHolderHelper.SUBSTITUTOR.replace(line.trim());\n                if (line.startsWith(\"#\") || line.isEmpty()) {\n                    continue;\n                }\n                if (line.startsWith(\"-\")) {\n                    toExclude.add(line);\n                } else {\n                    if (line.startsWith(\"+\")) {\n                        line = line.substring(1);\n                    }\n                    String location = line;\n                    String algo = \"MD5\";\n                    String hash = null;\n                    final boolean validJar = line.contains(\"|\");\n                    if (validJar) {\n                        final String[] segments = line.split(\"|\");\n                        location = segments[0];\n                        if (segments.length >= 2) {\n                            hash = segments[1];\n                        }\n                        if (segments.length >= 3) {\n                            algo = segments[2].trim();\n                        }\n                    }\n                    final Set<URL> repos = toUrls(ProvisioningUtil.realLocation(location));\n                    toAdd.addAll(repos);\n                    if (validJar) {\n                        final String computedHash = Files.hash(repos, algo);\n                        if (!computedHash.equals(hash)) {\n                            throw new IllegalStateException(\"Hash of \" + location + \"(\" + computedHash + \") doesn't match expected one (\" + hash + \")\");\n                        }\n                    }\n                }\n            }\n        } catch (final Exception e) {\n            Logger.getInstance(LogCategory.OPENEJB, ProvisioningClassLoaderConfigurer.class).error(\"Can't read \" + configFile, e);\n        } finally {\n            IO.close(reader);\n        }\n        added = toAdd.toArray(new URL[toAdd.size()]);\n        if (toExclude.size() > 0) {\n            excluded = Filters.prefixes(toExclude.toArray(new String[toExclude.size()]));\n        }\n    }\n    private static Set<URL> toUrls(final Set<String> strings) {\n        final Set<URL> urls = new HashSet<>();\n        for (final String s : strings) {\n            try {\n                urls.add(new File(s).toURI().toURL());\n            } catch (final MalformedURLException e) {\n                throw new IllegalArgumentException(e);\n            }\n        }\n        return urls;\n    }\n"]]}
{"hexsha": "51ecebb0d5a4a026301ab714acd28a68913018ad", "ext": "java", "lang": "Java", "content": "public class RunExamples {\n    /*\n     * Method which runs a static method in the example class. Assumes that\n     * method accepts a single parameter of type PrintStream, and saves\n     * contents that are written to this stream under the method's name in a\n     * JSONObject (i.e. a HashMap)\n     */\n\n    /// @export \"run-method\"\n    public static void runMethod(Method method, PrintStream out, ByteArrayOutputStream byteStream, JSONObject outputStreams) throws Exception {\n        System.out.println(\"Running method \" + method.getName());\n        method.invoke(null, out);\n\n        out.flush();\n        outputStreams.put(method.getName(), byteStream.toString());\n        byteStream.reset();\n    }\n\n    /// @export \"class-names\"\n    public static String[] classNames() {\n        return new String[] {\n            \"com.opengamma.analytics.example.coupledfokkerplank.CoupledFokkerPlankExample\",\n            \"com.opengamma.analytics.example.curveconstruction.AnnuityExample\",\n            \"com.opengamma.analytics.example.curveconstruction.CashExample\",\n            \"com.opengamma.analytics.example.curveconstruction.CurveConstructionExample\",\n            \"com.opengamma.analytics.example.curveconstruction.CurveExample\",\n            \"com.opengamma.analytics.example.curveconstruction.FunctionExample\",\n            \"com.opengamma.analytics.example.curveconstruction.MatrixExample\",\n            \"com.opengamma.analytics.example.curveconstruction.YieldCurveExample\",\n            \"com.opengamma.analytics.example.sabrextrapolation.SabrExtrapolationExample\",\n            \"com.opengamma.analytics.example.timeseries.TimeSeriesExample\"\n        };\n    }\n    /// @end\n\n    public static void runExamples() throws Exception {\n        String[] classNames = classNames();\n        String outputFilename = \"dexy--example-output.json\";\n        String fieldsFilename = \"dexy--example-fields.json\";\n\n        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();\n        PrintStream out = new PrintStream(byteStream);\n        JSONObject outputStreams = new JSONObject();\n        JSONObject fieldInfo = new JSONObject();\n\n        /// @export \"find-methods-to-run\"\n        for (int k = 0; k < classNames.length; k++) {\n            String className = classNames[k];\n            Class thisClass = Class.forName(className);\n\n            JSONObject classOutputStreams = new JSONObject();\n            Method[] methods = thisClass.getMethods();\n            for (int i = 0; i < methods.length; i++) {\n                Method method = methods[i];\n                Class[] params = method.getParameterTypes();\n                if (params.length == 1 && params[0] == PrintStream.class) {\n                    runMethod(method, out, byteStream, classOutputStreams);\n                }\n            }\n            outputStreams.put(className, classOutputStreams);\n            /// @end\n\n            JSONObject classFieldInfo = new JSONObject();\n            Field[] fields = thisClass.getDeclaredFields();\n            for (int i = 0; i < fields.length; i++) {\n                Field field = fields[i];\n\n                try {\n                    Object value = field.get(null);\n\n                    // Handle any special data types that cause problems for the JSON conversion...\n                    if (field.getType().equals(double[].class)) {\n                        double[] values = (double[])value;\n                        JSONArray array = new JSONArray();\n                        for (int j = 0; j < values.length; j++) {\n                            array.add(values[j]);\n                        }\n                        classFieldInfo.put(field.getName(), array);\n                    } else {\n                        // default case\n\n                        // check class, if not a directly supported type, then explicitly call toString() or else we get invalid JSON\n                        Class fieldClass = field.getType();\n\n                        // TODO Finish this, need to recognize all classes that should not be converted to strings.\n                        // The values can be any of these types: Boolean, JSONArray, JSONObject, Number, String, or the JSONObject.NULL object.\n                        if (fieldClass.equals(double.class)) {\n                            // ok\n                        } else if (fieldClass.equals(int.class)) {\n                            // ok\n                        } else if (fieldClass.equals(long.class)) {\n                            // ok\n                        } else if (fieldClass.equals(boolean.class)) {\n                            // ok\n                        } else if (java.lang.Number.class.isAssignableFrom(fieldClass)) {\n                            // ok\n                        } else {\n                            value = value.toString();\n                        }\n                        classFieldInfo.put(field.getName(), value);\n                    }\n                } catch (java.lang.IllegalAccessException e) {\n                    // Skip any fields that aren't accessible.\n                    System.out.println(\"Not allowed to see value of \" + field.getName() + \" in \" + className);\n                }\n            }\n            fieldInfo.put(className, classFieldInfo);\n        }\n\n        File f;\n        FileWriter file;\n\n        f = new File(outputFilename);\n        file = new FileWriter(f);\n        outputStreams.writeJSONString(file);\n        file.close();\n\n        f = new File(fieldsFilename);\n        file = new FileWriter(f);\n        fieldInfo.writeJSONString(file);\n        file.close();\n    }\n\n    public static void main(String[] args) throws Exception {\n        runExamples();\n    }\n}", "class_id": 0, "repo": "Incapture/OG-Platform", "file": "docs/shared/RunExamples.java", "last_update_at": "2019-08-22T06:50:21+00:00", "question_id": "51ecebb0d5a4a026301ab714acd28a68913018ad", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RunExamples {\n    /*\n     * Method which runs a static method in the example class. Assumes that\n     * method accepts a single parameter of type PrintStream, and saves\n     * contents that are written to this stream under the method's name in a\n     * JSONObject (i.e. a HashMap)\n     */\n    /// @export \"run-method\"\n    public static void runMethod(Method method, PrintStream out, ByteArrayOutputStream byteStream, JSONObject outputStreams) throws Exception {\n        System.out.println(\"Running method \" + method.getName());\n        method.invoke(null, out);\n        out.flush();\n        outputStreams.put(method.getName(), byteStream.toString());\n        byteStream.reset();\n    }\n    /// @export \"class-names\"\n    public static String[] classNames() {\n        return new String[] {\n            \"com.opengamma.analytics.example.coupledfokkerplank.CoupledFokkerPlankExample\",\n            \"com.opengamma.analytics.example.curveconstruction.AnnuityExample\",\n            \"com.opengamma.analytics.example.curveconstruction.CashExample\",\n            \"com.opengamma.analytics.example.curveconstruction.CurveConstructionExample\",\n            \"com.opengamma.analytics.example.curveconstruction.CurveExample\",\n            \"com.opengamma.analytics.example.curveconstruction.FunctionExample\",\n            \"com.opengamma.analytics.example.curveconstruction.MatrixExample\",\n            \"com.opengamma.analytics.example.curveconstruction.YieldCurveExample\",\n            \"com.opengamma.analytics.example.sabrextrapolation.SabrExtrapolationExample\",\n            \"com.opengamma.analytics.example.timeseries.TimeSeriesExample\"\n        };\n    }\n    /// @end\n    public static void runExamples() throws Exception {\n        String[] classNames = classNames();\n        String outputFilename = \"dexy--example-output.json\";\n        String fieldsFilename = \"dexy--example-fields.json\";\n        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();\n        PrintStream out = new PrintStream(byteStream);\n        JSONObject outputStreams = new JSONObject();\n        JSONObject fieldInfo = new JSONObject();\n        /// @export \"find-methods-to-run\"\n        for (int k = 0; k < classNames.length; k++) {\n            String className = classNames[k];\n            Class thisClass = Class.forName(className);\n            JSONObject classOutputStreams = new JSONObject();\n            Method[] methods = thisClass.getMethods();\n            for (int i = 0; i < methods.length; i++) {\n                Method method = methods[i];\n                Class[] params = method.getParameterTypes();\n                if (params.length == 1 && params[0] == PrintStream.class) {\n                    runMethod(method, out, byteStream, classOutputStreams);\n                }\n            }\n            outputStreams.put(className, classOutputStreams);\n            /// @end\n            JSONObject classFieldInfo = new JSONObject();\n            Field[] fields = thisClass.getDeclaredFields();\n            for (int i = 0; i < fields.length; i++) {\n                Field field = fields[i];\n                try {\n                    Object value = field.get(null);\n                    // Handle any special data types that cause problems for the JSON conversion...\n                    if (field.getType().equals(double[].class)) {\n                        double[] values = (double[])value;\n                        JSONArray array = new JSONArray();\n                        for (int j = 0; j < values.length; j++) {\n                            array.add(values[j]);\n                        }\n                        classFieldInfo.put(field.getName(), array);\n                    } else {\n                        // default case\n                        // check class, if not a directly supported type, then explicitly call toString() or else we get invalid JSON\n                        Class fieldClass = field.getType();\n                        // TODO Finish this, need to recognize all classes that should not be converted to strings.\n                        // The values can be any of these types: Boolean, JSONArray, JSONObject, Number, String, or the JSONObject.NULL object.\n                        if (fieldClass.equals(double.class)) {\n                            // ok\n                        } else if (fieldClass.equals(int.class)) {\n                            // ok\n                        } else if (fieldClass.equals(long.class)) {\n                            // ok\n                        } else if (fieldClass.equals(boolean.class)) {\n                            // ok\n                        } else if (java.lang.Number.class.isAssignableFrom(fieldClass)) {\n                            // ok\n                        } else {\n                            value = value.toString();\n                        }\n                        classFieldInfo.put(field.getName(), value);\n                    }\n                } catch (java.lang.IllegalAccessException e) {\n                    // Skip any fields that aren't accessible.\n                    System.out.println(\"Not allowed to see value of \" + field.getName() + \" in \" + className);\n                }\n            }\n            fieldInfo.put(className, classFieldInfo);\n        }\n        File f;\n        FileWriter file;\n        f = new File(outputFilename);\n        file = new FileWriter(f);\n        outputStreams.writeJSONString(file);\n        file.close();\n        f = new File(fieldsFilename);\n        file = new FileWriter(f);\n        fieldInfo.writeJSONString(file);\n        file.close();\n    }\n    public static void main(String[] args) throws Exception {\n        runExamples();\n    }\n"]]}
{"hexsha": "3e640f396d26823a541044cc8314cd2cec6f5cbd", "ext": "java", "lang": "Java", "content": "public class BigDecimalTests {\n\n    @Test\n    void test1() {\n        float f1 = 1.0f - 0.9f;\n        float f2 = 0.9f - 0.8f;\n\n        assertThat(f1 == f2).isTrue();\n    }\n\n    @Test\n    void test2() {\n        BigDecimal a = new BigDecimal(\"0.1\");\n        BigDecimal b = new BigDecimal(\"0.9\");\n        BigDecimal c = new BigDecimal(\"0.8\");\n\n        final BigDecimal subtract = b.subtract(c);\n\n        assertThat(subtract).isEqualTo(a);\n    }\n\n    @Test\n    void test3() {\n        BigDecimal m = new BigDecimal(\"1.255433\");\n        BigDecimal n = m.setScale(3, RoundingMode.HALF_DOWN);\n\n        assertThat(n.toString()).isEqualTo(\"1.255\");\n    }\n}", "class_id": 0, "repo": "LiuKay/Concurrency_Demo", "file": "src/test/java/com/kay/BigDecimalTests.java", "last_update_at": "2019-10-19T06:44:37+00:00", "question_id": "3e640f396d26823a541044cc8314cd2cec6f5cbd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BigDecimalTests {\n    @Test\n    void test1() {\n        float f1 = 1.0f - 0.9f;\n        float f2 = 0.9f - 0.8f;\n        assertThat(f1 == f2).isTrue();\n    }\n    @Test\n    void test2() {\n        BigDecimal a = new BigDecimal(\"0.1\");\n        BigDecimal b = new BigDecimal(\"0.9\");\n        BigDecimal c = new BigDecimal(\"0.8\");\n        final BigDecimal subtract = b.subtract(c);\n        assertThat(subtract).isEqualTo(a);\n    }\n    @Test\n    void test3() {\n        BigDecimal m = new BigDecimal(\"1.255433\");\n        BigDecimal n = m.setScale(3, RoundingMode.HALF_DOWN);\n        assertThat(n.toString()).isEqualTo(\"1.255\");\n    }\n"]]}
{"hexsha": "8ba5c2badc32fc63f18e1eb093689f48513d1b04", "ext": "java", "lang": "Java", "content": "public final class ScriptsLocation implements Comparable<ScriptsLocation> {\n\n  private static final String CLASSPATH_PREFIX = \"classpath:\";\n  public static final String FILESYSTEM_PREFIX = \"filesystem:\";\n\n  private String prefix; // classpath or filesystem\n  private String path;\n\n  public ScriptsLocation(String descriptor) {\n    String normalizedDescriptor = descriptor.trim().replace(\"\\\\\", \"/\");\n\n    if (normalizedDescriptor.contains(\":\")) {\n      prefix = normalizedDescriptor.substring(0, normalizedDescriptor.indexOf(\":\") + 1);\n      path = normalizedDescriptor.substring(normalizedDescriptor.indexOf(\":\") + 1);\n    } else {\n      prefix = CLASSPATH_PREFIX;\n      path = normalizedDescriptor;\n    }\n\n    if (isClassPath()) {\n      path = path.replace(\".\", \"/\");\n      if (path.startsWith(\"/\")) {\n        path = path.substring(1);\n      }\n    } else {\n      if (!isFileSystem()) {\n        throw new CassandraMigrationException(\n            \"Unknown prefix for location. \"\n                + \"Must be \"\n                + CLASSPATH_PREFIX\n                + \" or \"\n                + FILESYSTEM_PREFIX\n                + \".\"\n                + normalizedDescriptor);\n      }\n    }\n\n    if (path.endsWith(\"/\")) {\n      path = path.substring(0, path.length() - 1);\n    }\n  }\n\n  public boolean isClassPath() {\n    return CLASSPATH_PREFIX.equals(prefix);\n  }\n\n  public boolean isFileSystem() {\n    return FILESYSTEM_PREFIX.equals(prefix);\n  }\n\n  public boolean isParentOf(ScriptsLocation other) {\n    return (other.getDescriptor() + \"/\").startsWith(getDescriptor() + \"/\");\n  }\n\n  public String getPrefix() {\n    return prefix;\n  }\n\n  public String getPath() {\n    return path;\n  }\n\n  public String getDescriptor() {\n    return prefix + path;\n  }\n\n  @SuppressWarnings(\"NullableProblems\")\n  public int compareTo(ScriptsLocation o) {\n    return getDescriptor().compareTo(o.getDescriptor());\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n\n    ScriptsLocation location = (ScriptsLocation) o;\n\n    return getDescriptor().equals(location.getDescriptor());\n  }\n\n  @Override\n  public int hashCode() {\n    return getDescriptor().hashCode();\n  }\n\n  @Override\n  public String toString() {\n    return getDescriptor();\n  }\n}", "class_id": 0, "repo": "reshmi-nair/sunbird-utils", "file": "sunbird-cassandra-migration/cassandra-migration/src/main/java/com/contrastsecurity/cassandra/migration/config/ScriptsLocation.java", "last_update_at": "2019-03-28T09:09:53+00:00", "question_id": "8ba5c2badc32fc63f18e1eb093689f48513d1b04", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class ScriptsLocation implements Comparable<ScriptsLocation> {\n  private static final String CLASSPATH_PREFIX = \"classpath:\";\n  public static final String FILESYSTEM_PREFIX = \"filesystem:\";\n  private String prefix; // classpath or filesystem\n  private String path;\n  public ScriptsLocation(String descriptor) {\n    String normalizedDescriptor = descriptor.trim().replace(\"\\\\\", \"/\");\n    if (normalizedDescriptor.contains(\":\")) {\n      prefix = normalizedDescriptor.substring(0, normalizedDescriptor.indexOf(\":\") + 1);\n      path = normalizedDescriptor.substring(normalizedDescriptor.indexOf(\":\") + 1);\n    } else {\n      prefix = CLASSPATH_PREFIX;\n      path = normalizedDescriptor;\n    }\n    if (isClassPath()) {\n      path = path.replace(\".\", \"/\");\n      if (path.startsWith(\"/\")) {\n        path = path.substring(1);\n      }\n    } else {\n      if (!isFileSystem()) {\n        throw new CassandraMigrationException(\n            \"Unknown prefix for location. \"\n                + \"Must be \"\n                + CLASSPATH_PREFIX\n                + \" or \"\n                + FILESYSTEM_PREFIX\n                + \".\"\n                + normalizedDescriptor);\n      }\n    }\n    if (path.endsWith(\"/\")) {\n      path = path.substring(0, path.length() - 1);\n    }\n  }\n  public boolean isClassPath() {\n    return CLASSPATH_PREFIX.equals(prefix);\n  }\n  public boolean isFileSystem() {\n    return FILESYSTEM_PREFIX.equals(prefix);\n  }\n  public boolean isParentOf(ScriptsLocation other) {\n    return (other.getDescriptor() + \"/\").startsWith(getDescriptor() + \"/\");\n  }\n  public String getPrefix() {\n    return prefix;\n  }\n  public String getPath() {\n    return path;\n  }\n  public String getDescriptor() {\n    return prefix + path;\n  }\n  @SuppressWarnings(\"NullableProblems\")\n  public int compareTo(ScriptsLocation o) {\n    return getDescriptor().compareTo(o.getDescriptor());\n  }\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ScriptsLocation location = (ScriptsLocation) o;\n    return getDescriptor().equals(location.getDescriptor());\n  }\n  @Override\n  public int hashCode() {\n    return getDescriptor().hashCode();\n  }\n  @Override\n  public String toString() {\n    return getDescriptor();\n  }\n"]]}
{"hexsha": "b08534df7d002be8cc031157b9836464527f4da6", "ext": "java", "lang": "Java", "content": "public class ContextHelper {\n    public static String getUserAgent(ContainerRequestContext request) {\n  \treturn request.getHeaderString(\"user-agent\");\n      }\n\n      public static String getRemoteAdress(ContainerRequestContext request) {\n  \tString forwarded = request.getHeaderString(\"x-forwarded-for\");\n  \tString remoteIP;\n  \tif (forwarded != null) {\n  \t    int i = forwarded.indexOf(\",\");\n  \t    if (i > -1) {\n  \t\tremoteIP = forwarded.substring(0, i);\n  \t    } else {\n  \t\tremoteIP = forwarded;\n  \t    }\n  \t} else {\n  \t    Object p = request.getProperty(IPFilter.REMOTE_IP);\n  \t    if (p != null) {\n  \t\tremoteIP = p.toString();\n  \t    } else {\n  \t\tremoteIP = \"0.0.0.0\";\n  \t    }\n  \t}\n  \treturn remoteIP;\n      }\n}", "class_id": 0, "repo": "webeverde/dropwizard-helpers", "file": "src/main/java/de/webever/dropwizard/helpers/ContextHelper.java", "last_update_at": "2019-08-21T13:44:22+00:00", "question_id": "b08534df7d002be8cc031157b9836464527f4da6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ContextHelper {\n    public static String getUserAgent(ContainerRequestContext request) {\n  \treturn request.getHeaderString(\"user-agent\");\n      }\n      public static String getRemoteAdress(ContainerRequestContext request) {\n  \tString forwarded = request.getHeaderString(\"x-forwarded-for\");\n  \tString remoteIP;\n  \tif (forwarded != null) {\n  \t    int i = forwarded.indexOf(\",\");\n  \t    if (i > -1) {\n  \t\tremoteIP = forwarded.substring(0, i);\n  \t    } else {\n  \t\tremoteIP = forwarded;\n  \t    }\n  \t} else {\n  \t    Object p = request.getProperty(IPFilter.REMOTE_IP);\n  \t    if (p != null) {\n  \t\tremoteIP = p.toString();\n  \t    } else {\n  \t\tremoteIP = \"0.0.0.0\";\n  \t    }\n  \t}\n  \treturn remoteIP;\n      }\n"]]}
{"hexsha": "4d5f471ea8ae38c5f679def66fd20c866953ae80", "ext": "java", "lang": "Java", "content": "public class DistBuildLogsCommandIntegrationTest {\n\n  private static final StampedeId STAMPEDE_ID = new StampedeId().setId(\"super_cool_stampede_id\");\n\n  @Rule public TemporaryPaths tmp = new TemporaryPaths();\n\n  @Test\n  public void runCommandAndCheckOutputFile() throws IOException {\n    BuildSlaveInfo slave1 =\n        new BuildSlaveInfo().setBuildSlaveRunId(new BuildSlaveRunId().setId(\"build_slave_1\"));\n    BuildSlaveInfo slave2 =\n        new BuildSlaveInfo().setBuildSlaveRunId(new BuildSlaveRunId().setId(\"build_slave_2\"));\n    BuildJob buildJob = new BuildJob().setStampedeId(STAMPEDE_ID);\n    buildJob.addToBuildSlaves(slave1);\n    buildJob.addToBuildSlaves(slave2);\n\n    LogDir logDir1 =\n        new LogDir().setBuildSlaveRunId(slave1.getBuildSlaveRunId()).setData(getZipContents());\n    LogDir logDir2 =\n        new LogDir().setBuildSlaveRunId(slave2.getBuildSlaveRunId()).setData(getZipContents());\n    List<LogDir> logDirs = Lists.newArrayList(logDir1, logDir2);\n\n    try (Server server = new Server(buildJob, logDirs)) {\n      ProjectWorkspace workspace =\n          TestDataHelper.createProjectWorkspaceForScenario(this, \"dist_build_logs_command\", tmp);\n      workspace.setUp();\n      workspace\n          .runBuckCommand(\n              \"distbuild\",\n              \"logs\",\n              \"--stampede-id=\" + STAMPEDE_ID.getId(),\n              server.getStampedeConfigArg(),\n              server.getPingEndpointConfigArg())\n          .assertSuccess();\n\n      ListAllFiles filesLister = new ListAllFiles();\n      Files.walkFileTree(tmp.getRoot(), filesLister);\n\n      List<String> helloWorldFiles =\n          filesLister.getAbsPaths().stream()\n              .filter(x -> x.contains(\"hello_world.txt\"))\n              .sorted()\n              .collect(Collectors.toList());\n\n      Assert.assertEquals(2, helloWorldFiles.size());\n      Assert.assertTrue(helloWorldFiles.get(0).contains(slave1.getBuildSlaveRunId().getId()));\n      Assert.assertTrue(helloWorldFiles.get(1).contains(slave2.getBuildSlaveRunId().getId()));\n    }\n  }\n\n  private byte[] getZipContents() {\n    // Zip file containing one empty file named \"hello_world.txt\".\n    String base64Contents =\n        \"UEsDBAoAAAAAADNUU0sAAAAAAAAAAAAAAAAPABwAaGVsbG9fd29ybGQudHh0VVQJAA\"\n            + \"NycehZcnHoWXV4CwABBNE7wRgEui3Tb1BLAQIeAwoAAAAAADNUU0sAAAAAAAAAAAAAAAAPABgAAAAAAAAAAACkg\"\n            + \"QAAAABoZWxsb193b3JsZC50eHRVVAUAA3Jx6Fl1eAsAAQTRO8EYBLot029QSwUGAAAAAAEAAQBVAAAASQAAAAAA\";\n    return Base64.getDecoder().decode(base64Contents);\n  }\n\n  private static class ListAllFiles implements FileVisitor<Path> {\n\n    List<String> absPaths;\n\n    public ListAllFiles() {\n      absPaths = Lists.newArrayList();\n    }\n\n    public List<String> getAbsPaths() {\n      return absPaths;\n    }\n\n    @Override\n    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n      return FileVisitResult.CONTINUE;\n    }\n\n    @Override\n    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n      absPaths.add(file.toAbsolutePath().toString());\n      return FileVisitResult.CONTINUE;\n    }\n\n    @Override\n    public FileVisitResult visitFileFailed(Path file, IOException exc) {\n      return FileVisitResult.CONTINUE;\n    }\n\n    @Override\n    public FileVisitResult postVisitDirectory(Path dir, IOException exc) {\n      return FileVisitResult.CONTINUE;\n    }\n  }\n\n  private static class Server extends FakeFrontendHttpServer {\n\n    private final BuildJob buildJob;\n    private final List<LogDir> logDirs;\n\n    public Server(BuildJob buildJob, List<LogDir> logDirs) throws IOException {\n      this.buildJob = buildJob;\n      this.logDirs = logDirs;\n    }\n\n    @Override\n    public FrontendResponse handleRequest(FrontendRequest request) {\n      FrontendResponse response = new FrontendResponse();\n      response.setType(request.getType());\n      response.setWasSuccessful(true);\n\n      if (request.getType() == FrontendRequestType.BUILD_STATUS) {\n        BuildStatusResponse statusResponse = new BuildStatusResponse();\n        statusResponse.setBuildJob(buildJob);\n        response.setBuildStatusResponse(statusResponse);\n      } else if (request.getType() == FrontendRequestType.GET_BUILD_SLAVE_LOG_DIR) {\n        MultiGetBuildSlaveLogDirResponse logDirResponse = new MultiGetBuildSlaveLogDirResponse();\n        logDirResponse.setLogDirs(logDirs);\n        response.setMultiGetBuildSlaveLogDirResponse(logDirResponse);\n      } else {\n        Assert.fail(\"This call was not expected.\");\n      }\n\n      return response;\n    }\n  }\n}", "class_id": 0, "repo": "isfaaghyth/buck", "file": "test/com/facebook/buck/cli/DistBuildLogsCommandIntegrationTest.java", "last_update_at": "2019-09-22T06:36:24+00:00", "question_id": "4d5f471ea8ae38c5f679def66fd20c866953ae80", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DistBuildLogsCommandIntegrationTest {\n  private static final StampedeId STAMPEDE_ID = new StampedeId().setId(\"super_cool_stampede_id\");\n  @Rule public TemporaryPaths tmp = new TemporaryPaths();\n  @Test\n  public void runCommandAndCheckOutputFile() throws IOException {\n    BuildSlaveInfo slave1 =\n        new BuildSlaveInfo().setBuildSlaveRunId(new BuildSlaveRunId().setId(\"build_slave_1\"));\n    BuildSlaveInfo slave2 =\n        new BuildSlaveInfo().setBuildSlaveRunId(new BuildSlaveRunId().setId(\"build_slave_2\"));\n    BuildJob buildJob = new BuildJob().setStampedeId(STAMPEDE_ID);\n    buildJob.addToBuildSlaves(slave1);\n    buildJob.addToBuildSlaves(slave2);\n    LogDir logDir1 =\n        new LogDir().setBuildSlaveRunId(slave1.getBuildSlaveRunId()).setData(getZipContents());\n    LogDir logDir2 =\n        new LogDir().setBuildSlaveRunId(slave2.getBuildSlaveRunId()).setData(getZipContents());\n    List<LogDir> logDirs = Lists.newArrayList(logDir1, logDir2);\n    try (Server server = new Server(buildJob, logDirs)) {\n      ProjectWorkspace workspace =\n          TestDataHelper.createProjectWorkspaceForScenario(this, \"dist_build_logs_command\", tmp);\n      workspace.setUp();\n      workspace\n          .runBuckCommand(\n              \"distbuild\",\n              \"logs\",\n              \"--stampede-id=\" + STAMPEDE_ID.getId(),\n              server.getStampedeConfigArg(),\n              server.getPingEndpointConfigArg())\n          .assertSuccess();\n      ListAllFiles filesLister = new ListAllFiles();\n      Files.walkFileTree(tmp.getRoot(), filesLister);\n      List<String> helloWorldFiles =\n          filesLister.getAbsPaths().stream()\n              .filter(x -> x.contains(\"hello_world.txt\"))\n              .sorted()\n              .collect(Collectors.toList());\n      Assert.assertEquals(2, helloWorldFiles.size());\n      Assert.assertTrue(helloWorldFiles.get(0).contains(slave1.getBuildSlaveRunId().getId()));\n      Assert.assertTrue(helloWorldFiles.get(1).contains(slave2.getBuildSlaveRunId().getId()));\n    }\n  }\n  private byte[] getZipContents() {\n    // Zip file containing one empty file named \"hello_world.txt\".\n    String base64Contents =\n        \"UEsDBAoAAAAAADNUU0sAAAAAAAAAAAAAAAAPABwAaGVsbG9fd29ybGQudHh0VVQJAA\"\n            + \"NycehZcnHoWXV4CwABBNE7wRgEui3Tb1BLAQIeAwoAAAAAADNUU0sAAAAAAAAAAAAAAAAPABgAAAAAAAAAAACkg\"\n            + \"QAAAABoZWxsb193b3JsZC50eHRVVAUAA3Jx6Fl1eAsAAQTRO8EYBLot029QSwUGAAAAAAEAAQBVAAAASQAAAAAA\";\n    return Base64.getDecoder().decode(base64Contents);\n  }\n  private static class ListAllFiles implements FileVisitor<Path> {\n    List<String> absPaths;\n    public ListAllFiles() {\n      absPaths = Lists.newArrayList();\n    }\n    public List<String> getAbsPaths() {\n      return absPaths;\n    }\n    @Override\n    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n      return FileVisitResult.CONTINUE;\n    }\n    @Override\n    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n      absPaths.add(file.toAbsolutePath().toString());\n      return FileVisitResult.CONTINUE;\n    }\n    @Override\n    public FileVisitResult visitFileFailed(Path file, IOException exc) {\n      return FileVisitResult.CONTINUE;\n    }\n    @Override\n    public FileVisitResult postVisitDirectory(Path dir, IOException exc) {\n      return FileVisitResult.CONTINUE;\n    }\n  }\n  private static class Server extends FakeFrontendHttpServer {\n    private final BuildJob buildJob;\n    private final List<LogDir> logDirs;\n    public Server(BuildJob buildJob, List<LogDir> logDirs) throws IOException {\n      this.buildJob = buildJob;\n      this.logDirs = logDirs;\n    }\n    @Override\n    public FrontendResponse handleRequest(FrontendRequest request) {\n      FrontendResponse response = new FrontendResponse();\n      response.setType(request.getType());\n      response.setWasSuccessful(true);\n      if (request.getType() == FrontendRequestType.BUILD_STATUS) {\n        BuildStatusResponse statusResponse = new BuildStatusResponse();\n        statusResponse.setBuildJob(buildJob);\n        response.setBuildStatusResponse(statusResponse);\n      } else if (request.getType() == FrontendRequestType.GET_BUILD_SLAVE_LOG_DIR) {\n        MultiGetBuildSlaveLogDirResponse logDirResponse = new MultiGetBuildSlaveLogDirResponse();\n        logDirResponse.setLogDirs(logDirs);\n        response.setMultiGetBuildSlaveLogDirResponse(logDirResponse);\n      } else {\n        Assert.fail(\"This call was not expected.\");\n      }\n      return response;\n    }\n  }\n"]]}
{"hexsha": "981c5dc4fccf04a61c0023635c6b2ee50fb23046", "ext": "java", "lang": "Java", "content": "public class BookmarkActivity extends Activity {\n\n\tprivate Intent intent;\n\n\tpublic static final int MAXIMAGES = 10;\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\n\t\tintent = getIntent();\n\t\tString action = intent.getAction();\n\t\tString type = intent.getType();\n\n\t\tif (Intent.ACTION_SEND.equals(action) && type != null) {\n\t\t\thandleSendImage(intent);\n\t\t}\n\t\tif (Intent.ACTION_SEND_MULTIPLE.equals(action) && type != null) {\n\t\t\thandleSendMultipleImages(intent);\n\t\t}\n\n\t\tfinish();\n\t}\n\n\tvoid handleSendImage(Intent intent) {\n\t\tUri imageUri = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM);\n\t\tif (imageUri != null) {\n\t\t\tnew BookmarkTask(this).execute(imageUri);\n\t\t}\n\t}\n\n\tvoid handleSendMultipleImages(Intent intent) {\n\t\tArrayList<Uri> imageUris = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);\n\t\tif (imageUris != null) {\n\t\t\tif (imageUris.size() <= MAXIMAGES) {\n\t\t\t\tnew BookmarkTask(this).execute(imageUris.toArray(new Uri[0]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString str = getString(R.string.msg_too_many, MAXIMAGES);\n\t\t\t\tToast.makeText(this, str, Toast.LENGTH_SHORT).show();\n\t\t\t}\n\t\t}\n\t}\n}", "class_id": 0, "repo": "onyxbits/photobookmark", "file": "src/de/onyxbits/photobookmark/BookmarkActivity.java", "last_update_at": "2019-05-03T23:42:55+00:00", "question_id": "981c5dc4fccf04a61c0023635c6b2ee50fb23046", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BookmarkActivity extends Activity {\n\tprivate Intent intent;\n\tpublic static final int MAXIMAGES = 10;\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tintent = getIntent();\n\t\tString action = intent.getAction();\n\t\tString type = intent.getType();\n\t\tif (Intent.ACTION_SEND.equals(action) && type != null) {\n\t\t\thandleSendImage(intent);\n\t\t}\n\t\tif (Intent.ACTION_SEND_MULTIPLE.equals(action) && type != null) {\n\t\t\thandleSendMultipleImages(intent);\n\t\t}\n\t\tfinish();\n\t}\n\tvoid handleSendImage(Intent intent) {\n\t\tUri imageUri = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM);\n\t\tif (imageUri != null) {\n\t\t\tnew BookmarkTask(this).execute(imageUri);\n\t\t}\n\t}\n\tvoid handleSendMultipleImages(Intent intent) {\n\t\tArrayList<Uri> imageUris = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);\n\t\tif (imageUris != null) {\n\t\t\tif (imageUris.size() <= MAXIMAGES) {\n\t\t\t\tnew BookmarkTask(this).execute(imageUris.toArray(new Uri[0]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString str = getString(R.string.msg_too_many, MAXIMAGES);\n\t\t\t\tToast.makeText(this, str, Toast.LENGTH_SHORT).show();\n\t\t\t}\n\t\t}\n\t}\n"]]}
{"hexsha": "0f01c3ec9f23839a634e5ec961653b94040384e0", "ext": "java", "lang": "Java", "content": "@Component\npublic class ResourceGenerator {\n\n    public Resource<OperationDto> getOperationResource(OperationDto operationDto) {\n        Resource<OperationDto> resource = new Resource<>(operationDto);\n        resource.add(ControllerLinkBuilder.linkTo(ControllerLinkBuilder.methodOn(OperationController.class)\n                .getOperation(operationDto.getIdUser(), operationDto.getIdOperation())).withRel(\"self\"));\n        return resource;\n    }\n\n    public Resource<UserDto> getUserResource(UserDto userDto) {\n        Resource<UserDto> resource = new Resource<>(userDto);\n        resource.add(ControllerLinkBuilder.linkTo(ControllerLinkBuilder.methodOn(UserController.class)\n                .getUserProfile(userDto.getId())).withRel(\"self\"));\n        return resource;\n    }\n\n    public Resource<ProductDto> getProductResource(ProductDto productDto) {\n        Resource<ProductDto> resource = new Resource<>(productDto);\n        resource.add(ControllerLinkBuilder.linkTo(ControllerLinkBuilder.methodOn(ProductController.class)\n                .getProduct(productDto.getIdProduct())).withRel(\"self\"));\n        return resource;\n    }\n\n    public Resource<PageDto<Resource<ProductDto>>> getProductsResource(Collection<ProductDto> products, Long totalElements, Integer numberOfElements) {\n        List<Resource<ProductDto>> list = products.stream().map(this::getProductResource).collect(Collectors.toList());\n        return new Resource<>(PageDto.of(list, totalElements, numberOfElements));\n    }\n}", "class_id": 0, "repo": "jfbernal92/buymesth", "file": "buymesth-back/src/main/java/com/buymesth/app/controllers/ResourceGenerator.java", "last_update_at": "2019-06-17T07:51:01+00:00", "question_id": "0f01c3ec9f23839a634e5ec961653b94040384e0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\npublic class ResourceGenerator {\n    public Resource<OperationDto> getOperationResource(OperationDto operationDto) {\n        Resource<OperationDto> resource = new Resource<>(operationDto);\n        resource.add(ControllerLinkBuilder.linkTo(ControllerLinkBuilder.methodOn(OperationController.class)\n                .getOperation(operationDto.getIdUser(), operationDto.getIdOperation())).withRel(\"self\"));\n        return resource;\n    }\n    public Resource<UserDto> getUserResource(UserDto userDto) {\n        Resource<UserDto> resource = new Resource<>(userDto);\n        resource.add(ControllerLinkBuilder.linkTo(ControllerLinkBuilder.methodOn(UserController.class)\n                .getUserProfile(userDto.getId())).withRel(\"self\"));\n        return resource;\n    }\n    public Resource<ProductDto> getProductResource(ProductDto productDto) {\n        Resource<ProductDto> resource = new Resource<>(productDto);\n        resource.add(ControllerLinkBuilder.linkTo(ControllerLinkBuilder.methodOn(ProductController.class)\n                .getProduct(productDto.getIdProduct())).withRel(\"self\"));\n        return resource;\n    }\n    public Resource<PageDto<Resource<ProductDto>>> getProductsResource(Collection<ProductDto> products, Long totalElements, Integer numberOfElements) {\n        List<Resource<ProductDto>> list = products.stream().map(this::getProductResource).collect(Collectors.toList());\n        return new Resource<>(PageDto.of(list, totalElements, numberOfElements));\n    }\n"]]}
{"hexsha": "0fab1bbcb68a1dd0ef168d85911a929ed62962c1", "ext": "java", "lang": "Java", "content": "class Outperformance extends CombinationStrategy {\n    /**\n     * Map stores the number of times each forecastMethod had the overall lowest forecast error in the last runs timesteps.\n     */\n    @NotNull\n    private final Map<AbstractForecastMethod, Integer> outperformanceWeights;\n    /**\n     * Maximum number of the last stored winner counts.\n     */\n    private final int runs = 10;\n    /**\n     * Moving window of the last runs best AbstractForecastMethods.\n     */\n    private final List<AbstractForecastMethod> forecastWinners = new ArrayList<>(runs);\n    private double bestWeight = Double.MAX_VALUE;\n    @Nullable\n    private AbstractForecastMethod bestForecastMethod;\n\n    Outperformance() {\n        this.outperformanceWeights = new HashMap<>();\n    }\n\n    void addForecastMethod(final AbstractForecastMethod forecastMethod) {\n        this.outperformanceWeights.put(forecastMethod, 0);\n    }\n\n    public double run() {\n        List<Double> weights = getWeights();\n        if (weights.isEmpty()) {\n            return Double.NaN;\n        }\n\n        removeInvalidEntries(forecasts, weights);\n        if (weights.isEmpty()) {\n            return Double.NaN;\n        }\n\n        return simpleWeightedSum(forecasts, weights);\n    }\n\n    @NotNull\n    private List<Double> getWeights() {\n        if (this.bestForecastMethod == null) {\n            return Collections.emptyList();\n        }\n\n        updateOutperformanceMap(this.bestForecastMethod);\n        if (this.forecastWinners.size() < this.runs) {\n            return Collections.emptyList();\n        }\n\n        return calculateOutperformanceWeights();\n    }\n\n    @NotNull\n    private List<Double> calculateOutperformanceWeights() {\n        List<Double> weights = new ArrayList<>(this.outperformanceWeights.size());\n        for (double count : this.outperformanceWeights.values()) {\n            weights.add((1 + count) / (this.outperformanceWeights.size() + this.runs));\n        }\n\n        logWeights(weights);\n\n        return weights;\n    }\n\n    private void updateOutperformanceMap(AbstractForecastMethod forecastMethod) {\n        this.outperformanceWeights.computeIfPresent(forecastMethod, (p, count) -> count + 1);\n        this.forecastWinners.add(forecastMethod);\n\n        while (this.forecastWinners.size() > runs) {\n            AbstractForecastMethod oldest = this.forecastWinners.remove(0);\n            this.outperformanceWeights.computeIfPresent(oldest, (p, count) -> count - 1);\n        }\n    }\n\n    void reset() {\n        this.bestForecastMethod = null;\n        this.bestWeight = Double.MAX_VALUE;\n    }\n\n    void update(double weight, AbstractForecastMethod forecastMethod) {\n        if (weight < this.bestWeight) {\n            this.bestForecastMethod = forecastMethod;\n            this.bestWeight = weight;\n        }\n    }\n}", "class_id": 0, "repo": "matthiassommer/forecast-r-java", "file": "src/forecasting/combinationStrategies/Outperformance.java", "last_update_at": "2019-08-28T16:47:02+00:00", "question_id": "0fab1bbcb68a1dd0ef168d85911a929ed62962c1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Outperformance extends CombinationStrategy {\n    /**\n     * Map stores the number of times each forecastMethod had the overall lowest forecast error in the last runs timesteps.\n     */\n    @NotNull\n    private final Map<AbstractForecastMethod, Integer> outperformanceWeights;\n    /**\n     * Maximum number of the last stored winner counts.\n     */\n    private final int runs = 10;\n    /**\n     * Moving window of the last runs best AbstractForecastMethods.\n     */\n    private final List<AbstractForecastMethod> forecastWinners = new ArrayList<>(runs);\n    private double bestWeight = Double.MAX_VALUE;\n    @Nullable\n    private AbstractForecastMethod bestForecastMethod;\n    Outperformance() {\n        this.outperformanceWeights = new HashMap<>();\n    }\n    void addForecastMethod(final AbstractForecastMethod forecastMethod) {\n        this.outperformanceWeights.put(forecastMethod, 0);\n    }\n    public double run() {\n        List<Double> weights = getWeights();\n        if (weights.isEmpty()) {\n            return Double.NaN;\n        }\n        removeInvalidEntries(forecasts, weights);\n        if (weights.isEmpty()) {\n            return Double.NaN;\n        }\n        return simpleWeightedSum(forecasts, weights);\n    }\n    @NotNull\n    private List<Double> getWeights() {\n        if (this.bestForecastMethod == null) {\n            return Collections.emptyList();\n        }\n        updateOutperformanceMap(this.bestForecastMethod);\n        if (this.forecastWinners.size() < this.runs) {\n            return Collections.emptyList();\n        }\n        return calculateOutperformanceWeights();\n    }\n    @NotNull\n    private List<Double> calculateOutperformanceWeights() {\n        List<Double> weights = new ArrayList<>(this.outperformanceWeights.size());\n        for (double count : this.outperformanceWeights.values()) {\n            weights.add((1 + count) / (this.outperformanceWeights.size() + this.runs));\n        }\n        logWeights(weights);\n        return weights;\n    }\n    private void updateOutperformanceMap(AbstractForecastMethod forecastMethod) {\n        this.outperformanceWeights.computeIfPresent(forecastMethod, (p, count) -> count + 1);\n        this.forecastWinners.add(forecastMethod);\n        while (this.forecastWinners.size() > runs) {\n            AbstractForecastMethod oldest = this.forecastWinners.remove(0);\n            this.outperformanceWeights.computeIfPresent(oldest, (p, count) -> count - 1);\n        }\n    }\n    void reset() {\n        this.bestForecastMethod = null;\n        this.bestWeight = Double.MAX_VALUE;\n    }\n    void update(double weight, AbstractForecastMethod forecastMethod) {\n        if (weight < this.bestWeight) {\n            this.bestForecastMethod = forecastMethod;\n            this.bestWeight = weight;\n        }\n    }\n"]]}
{"hexsha": "091be020cbd8fd41dd763bacf33ce2d2a44a4880", "ext": "java", "lang": "Java", "content": "class PropertyHolder\n{\n\tprivate PropertyLoader loader;\n\n\t/** store the properties */\n\tprivate Properties defaultProperties;\n\tprivate Properties specificProperperties;\n\n\t/** store parsed properties */\n\tprivate Map<String, Double> doubleProperties;\n\tprivate Map<String, Integer> intProperties;\n\n\t/**\n\t * Creates a new PropertyHolder and loads the files from the specified paths.\n\t *\n\t * @param defaultPropertiesPath the path of the property file that contains the default properties, if there is no\n\t * default property file specify null\n\t * @param specificPropertiesPath the path of the property file that contains the specific properties\n\t */\n\tpublic PropertyHolder(String defaultPropertiesPath, String specificPropertiesPath)\n\t{\n\t\tloader = new PropertyLoader();\n\t\tdefaultProperties = loader.load(defaultPropertiesPath, true);\n\t\tspecificProperperties = loader.load(specificPropertiesPath, false);\n\t\tdoubleProperties = new HashMap<>();\n\t\tintProperties = new HashMap<>();\n\t}\n\n\t/**\n\t * Returns the property value of the specified key.\n\t *\n\t * @param key the key of the property\n\t * @return the value of the specified key\n\t */\n\tpublic String getProperty(String key)\n\t{\n\t\treturn specificProperperties.getProperty(key);\n\t}\n\n\t/**\n\t * Returns the property value of the specified key as a double and stores the parsed value.\n\t *\n\t * @param key the key of the property\n\t * @return the value of the key\n\t */\n\tpublic double getDoubleProperty(String key)\n\t{\n\t\tDouble result = doubleProperties.get(key);\n\n\t\tif (result != null) {\n\t\t\treturn result;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tresult = Double.parseDouble(specificProperperties.getProperty(key));\n\t\t\t\tdoubleProperties.put(key, result);\n\t\t\t\treturn result;\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tSystem.err.println(\"Invalid double property: \" + key + \" = \" + specificProperperties.getProperty(key));\n\t\t\t\te.printStackTrace();\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns the property value of the specified key as a integer and stores the parsed value.\n\t *\n\t * @param key the key of the property\n\t * @return the value of the key\n\t */\n\tpublic int getIntegerProperty(String key)\n\t{\n\t\tInteger result = intProperties.get(key);\n\n\t\tif (result != null) {\n\t\t\treturn result;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tresult = Integer.parseInt(specificProperperties.getProperty(key));\n\t\t\t\tintProperties.put(key, result);\n\t\t\t\treturn result;\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tSystem.err.println(\"Invalid integer property: \" + key + \" = \" + specificProperperties.getProperty(key));\n\t\t\t\te.printStackTrace();\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns the property value of the specified key as a float and stores the parsed value.\n\t *\n\t * @param key the key of the property\n\t * @return the value of the key\n\t */\n\tpublic float getFloatProperty(String key)\n\t{\n\t\treturn (float) getDoubleProperty(key);\n\t}\n\n\t/**\n\t * Returns the property value of the specified key as a short and stores the parsed value.\n\t *\n\t * @param key the key of the property\n\t * @return the value of the key\n\t */\n\tpublic int getShortProperty(String key)\n\t{\n\t\treturn (short) getIntegerProperty(key);\n\t}\n\n\t/**\n\t * Returns the property value of the specified key as a byte and stores the parsed value.\n\t *\n\t * @param key the key of the property\n\t * @return the value of the key\n\t */\n\tpublic int getByteProperty(String key)\n\t{\n\t\treturn (byte) getIntegerProperty(key);\n\t}\n\n\tprivate class PropertyLoader\n\t{\n\t\t/**\n\t\t * Loads a .properties file from the specified path.\n\t\t *\n\t\t * @param path the path of the property file\n\t\t * @param isDefault true if the file to be loaded contains default properties otherwise false\n\t\t * @return a java.util.Properties object containing the properties\n\t\t */\n\t\tprivate Properties load(String path, boolean isDefault)\n\t\t{\n\t\t\tif (path == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tProperties result = isDefault ? new Properties() : new Properties(defaultProperties);\n\n\t\t\ttry (InputStream in = PropertyLoader.class.getResourceAsStream(path)) {\n\t\t\t\tresult.load(in);\n\t\t\t} catch (IOException e) {\n\t\t\t\tSystem.err.println(\"Unable to load property file from \" + path);\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t}\n}", "class_id": 0, "repo": "TeamAutonomousCarOffenburg/TACO_2018", "file": "client/base/src/hso/autonomy/util/properties/PropertyHolder.java", "last_update_at": "2019-09-11T23:06:25+00:00", "question_id": "091be020cbd8fd41dd763bacf33ce2d2a44a4880", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class PropertyHolder\n{\n\tprivate PropertyLoader loader;\n\t/** store the properties */\n\tprivate Properties defaultProperties;\n\tprivate Properties specificProperperties;\n\t/** store parsed properties */\n\tprivate Map<String, Double> doubleProperties;\n\tprivate Map<String, Integer> intProperties;\n\t/**\n\t * Creates a new PropertyHolder and loads the files from the specified paths.\n\t *\n\t * @param defaultPropertiesPath the path of the property file that contains the default properties, if there is no\n\t * default property file specify null\n\t * @param specificPropertiesPath the path of the property file that contains the specific properties\n\t */\n\tpublic PropertyHolder(String defaultPropertiesPath, String specificPropertiesPath)\n\t{\n\t\tloader = new PropertyLoader();\n\t\tdefaultProperties = loader.load(defaultPropertiesPath, true);\n\t\tspecificProperperties = loader.load(specificPropertiesPath, false);\n\t\tdoubleProperties = new HashMap<>();\n\t\tintProperties = new HashMap<>();\n\t}\n\t/**\n\t * Returns the property value of the specified key.\n\t *\n\t * @param key the key of the property\n\t * @return the value of the specified key\n\t */\n\tpublic String getProperty(String key)\n\t{\n\t\treturn specificProperperties.getProperty(key);\n\t}\n\t/**\n\t * Returns the property value of the specified key as a double and stores the parsed value.\n\t *\n\t * @param key the key of the property\n\t * @return the value of the key\n\t */\n\tpublic double getDoubleProperty(String key)\n\t{\n\t\tDouble result = doubleProperties.get(key);\n\t\tif (result != null) {\n\t\t\treturn result;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tresult = Double.parseDouble(specificProperperties.getProperty(key));\n\t\t\t\tdoubleProperties.put(key, result);\n\t\t\t\treturn result;\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tSystem.err.println(\"Invalid double property: \" + key + \" = \" + specificProperperties.getProperty(key));\n\t\t\t\te.printStackTrace();\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Returns the property value of the specified key as a integer and stores the parsed value.\n\t *\n\t * @param key the key of the property\n\t * @return the value of the key\n\t */\n\tpublic int getIntegerProperty(String key)\n\t{\n\t\tInteger result = intProperties.get(key);\n\t\tif (result != null) {\n\t\t\treturn result;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tresult = Integer.parseInt(specificProperperties.getProperty(key));\n\t\t\t\tintProperties.put(key, result);\n\t\t\t\treturn result;\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tSystem.err.println(\"Invalid integer property: \" + key + \" = \" + specificProperperties.getProperty(key));\n\t\t\t\te.printStackTrace();\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Returns the property value of the specified key as a float and stores the parsed value.\n\t *\n\t * @param key the key of the property\n\t * @return the value of the key\n\t */\n\tpublic float getFloatProperty(String key)\n\t{\n\t\treturn (float) getDoubleProperty(key);\n\t}\n\t/**\n\t * Returns the property value of the specified key as a short and stores the parsed value.\n\t *\n\t * @param key the key of the property\n\t * @return the value of the key\n\t */\n\tpublic int getShortProperty(String key)\n\t{\n\t\treturn (short) getIntegerProperty(key);\n\t}\n\t/**\n\t * Returns the property value of the specified key as a byte and stores the parsed value.\n\t *\n\t * @param key the key of the property\n\t * @return the value of the key\n\t */\n\tpublic int getByteProperty(String key)\n\t{\n\t\treturn (byte) getIntegerProperty(key);\n\t}\n\tprivate class PropertyLoader\n\t{\n\t\t/**\n\t\t * Loads a .properties file from the specified path.\n\t\t *\n\t\t * @param path the path of the property file\n\t\t * @param isDefault true if the file to be loaded contains default properties otherwise false\n\t\t * @return a java.util.Properties object containing the properties\n\t\t */\n\t\tprivate Properties load(String path, boolean isDefault)\n\t\t{\n\t\t\tif (path == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tProperties result = isDefault ? new Properties() : new Properties(defaultProperties);\n\t\t\ttry (InputStream in = PropertyLoader.class.getResourceAsStream(path)) {\n\t\t\t\tresult.load(in);\n\t\t\t} catch (IOException e) {\n\t\t\t\tSystem.err.println(\"Unable to load property file from \" + path);\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n"]]}
{"hexsha": "8d65dcfa9e34e222bc74fbbe881c1482d08a225b", "ext": "java", "lang": "Java", "content": "final class PreambleUtil {\n\n  private PreambleUtil() {}\n\n  // ###### DO NOT MESS WITH THIS FROM HERE ...\n  // Preamble byte Addresses\n  static final int PREAMBLE_LONGS_BYTE   = 0; // Only low 6 bits used\n  static final int LG_RESIZE_FACTOR_BIT  = 6; // upper 2 bits. Not used by compact or direct.\n  static final int SER_VER_BYTE          = 1;\n  static final int FAMILY_BYTE           = 2;\n  static final int FLAGS_BYTE            = 3;\n  static final int RESERVOIR_SIZE_SHORT  = 4; // used in ser_ver 1\n  static final int RESERVOIR_SIZE_INT    = 4;\n  static final int SERDE_ID_SHORT        = 6; // used in ser_ver 1\n  static final int ITEMS_SEEN_LONG       = 8;\n\n  static final int MAX_K_SIZE_INT        = 4; // used in Union only\n  static final int OUTER_TAU_NUM_DOUBLE  = 16; // used in Varopt Union only\n  static final int OUTER_TAU_DENOM_LONG  = 24; // used in Varopt Union only\n\n  // constants and addresses used in varopt\n  static final int ITEM_COUNT_H_INT      = 16;\n  static final int ITEM_COUNT_R_INT      = 20;\n  static final int TOTAL_WEIGHT_R_DOUBLE = 24;\n  static final int VO_PRELONGS_EMPTY     = Family.VAROPT.getMinPreLongs();\n  static final int VO_PRELONGS_WARMUP    = 3;   // Doesn't match min or max prelongs in Family\n  static final int VO_PRELONGS_FULL      = Family.VAROPT.getMaxPreLongs();\n\n  // flag bit masks\n  //static final int BIG_ENDIAN_FLAG_MASK = 1;\n  //static final int READ_ONLY_FLAG_MASK  = 2;\n  static final int EMPTY_FLAG_MASK      = 4;\n  static final int GADGET_FLAG_MASK     = 128;\n\n  //Other constants\n  static final int SER_VER                    = 2;\n\n  static final boolean NATIVE_ORDER_IS_BIG_ENDIAN  =\n      (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN);\n\n  // STRINGS\n\n  /**\n   * Returns a human readable string summary of the preamble state of the given byte array.\n   * Used primarily in testing.\n   *\n   * @param byteArr the given byte array.\n   * @return the summary preamble string.\n   */\n  static String preambleToString(final byte[] byteArr) {\n    final Memory mem = Memory.wrap(byteArr);\n    return preambleToString(mem);\n  }\n\n  /**\n   * Returns a human readable string summary of the preamble state of the given Memory.\n   * Note: other than making sure that the given Memory size is large\n   * enough for just the preamble, this does not do much value checking of the contents of the\n   * preamble as this is primarily a tool for debugging the preamble visually.\n   *\n   * @param mem the given Memory.\n   * @return the summary preamble string.\n   */\n  static String preambleToString(final Memory mem) {\n    final int preLongs = getAndCheckPreLongs(mem);  // make sure we can get the assumed preamble\n\n    final Family family = Family.idToFamily(mem.getByte(FAMILY_BYTE));\n\n    switch (family) {\n      case RESERVOIR:\n      case VAROPT:\n        return sketchPreambleToString(mem, family, preLongs);\n      case RESERVOIR_UNION:\n      case VAROPT_UNION:\n        return unionPreambleToString(mem, family, preLongs);\n      default:\n        throw new SketchesArgumentException(\"Inspecting preamble with Sampling family's \"\n                + \"PreambleUtil with object of family \" + family.getFamilyName());\n    }\n  }\n\n  private static String sketchPreambleToString(final Memory mem,\n                                               final Family family,\n                                               final int preLongs) {\n    final ResizeFactor rf = ResizeFactor.getRF(extractResizeFactor(mem));\n    final int serVer = extractSerVer(mem);\n\n    // Flags\n    final int flags = extractFlags(mem);\n    final String flagsStr = zeroPad(Integer.toBinaryString(flags), 8) + \", \" + (flags);\n    //final boolean bigEndian = (flags & BIG_ENDIAN_FLAG_MASK) > 0;\n    //final String nativeOrder = ByteOrder.nativeOrder().toString();\n    //final boolean readOnly = (flags & READ_ONLY_FLAG_MASK) > 0;\n    final boolean isEmpty = (flags & EMPTY_FLAG_MASK) > 0;\n    final boolean isGadget = (flags & GADGET_FLAG_MASK) > 0;\n\n    final int k;\n    if (serVer == 1) {\n      final short encK = extractEncodedReservoirSize(mem);\n      k = ReservoirSize.decodeValue(encK);\n    } else {\n      k = extractK(mem);\n    }\n\n    long n = 0;\n    if (!isEmpty) {\n      n = extractN(mem);\n    }\n    final long dataBytes = mem.getCapacity() - (preLongs << 3);\n\n    final StringBuilder sb = new StringBuilder();\n    sb.append(LS)\n      .append(\"### END \")\n      .append(family.getFamilyName().toUpperCase())\n      .append(\" PREAMBLE SUMMARY\").append(LS)\n      .append(\"Byte  0: Preamble Longs       : \").append(preLongs).append(LS)\n      .append(\"Byte  0: ResizeFactor         : \").append(rf.toString()).append(LS)\n      .append(\"Byte  1: Serialization Version: \").append(serVer).append(LS)\n      .append(\"Byte  2: Family               : \").append(family.toString()).append(LS)\n      .append(\"Byte  3: Flags Field          : \").append(flagsStr).append(LS)\n      //.append(\"  BIG_ENDIAN_STORAGE          : \").append(bigEndian).append(LS)\n      //.append(\"  (Native Byte Order)         : \").append(nativeOrder).append(LS)\n      //.append(\"  READ_ONLY                   : \").append(readOnly).append(LS)\n      .append(\"  EMPTY                       : \").append(isEmpty).append(LS);\n    if (family == Family.VAROPT) {\n      sb.append(\"  GADGET                      : \").append(isGadget).append(LS);\n    }\n    sb.append(\"Bytes  4-7: Sketch Size (k)   : \").append(k).append(LS);\n    if (!isEmpty) {\n      sb.append(\"Bytes 8-15: Items Seen (n)    : \").append(n).append(LS);\n    }\n    if ((family == Family.VAROPT) && !isEmpty) {\n      final int hCount = extractHRegionItemCount(mem);\n      final int rCount = extractRRegionItemCount(mem);\n      final double totalRWeight = extractTotalRWeight(mem);\n      sb.append(\"Bytes 16-19: H region count   : \").append(hCount).append(LS)\n        .append(\"Bytes 20-23: R region count   : \").append(rCount).append(LS);\n      if (rCount > 0) {\n        sb.append(\"Bytes 24-31: R region weight  : \").append(totalRWeight).append(LS);\n      }\n    }\n\n    sb.append(\"TOTAL Sketch Bytes            : \").append(mem.getCapacity()).append(LS)\n      .append(\"  Preamble Bytes              : \").append(preLongs << 3).append(LS)\n      .append(\"  Data Bytes                  : \").append(dataBytes).append(LS)\n      .append(\"### END \")\n      .append(family.getFamilyName().toUpperCase())\n      .append(\" PREAMBLE SUMMARY\").append(LS);\n    return sb.toString();\n  }\n\n  private static String unionPreambleToString(final Memory mem,\n                                              final Family family,\n                                              final int preLongs) {\n    final ResizeFactor rf = ResizeFactor.getRF(extractResizeFactor(mem));\n    final int serVer = extractSerVer(mem);\n\n    // Flags\n    final int flags = extractFlags(mem);\n    final String flagsStr = zeroPad(Integer.toBinaryString(flags), 8) + \", \" + (flags);\n    //final boolean bigEndian = (flags & BIG_ENDIAN_FLAG_MASK) > 0;\n    //final String nativeOrder = ByteOrder.nativeOrder().toString();\n    //final boolean readOnly = (flags & READ_ONLY_FLAG_MASK) > 0;\n    final boolean isEmpty = (flags & EMPTY_FLAG_MASK) > 0;\n\n    final int k;\n    if (serVer == 1) {\n      final short encK = extractEncodedReservoirSize(mem);\n      k = ReservoirSize.decodeValue(encK);\n    } else {\n      k = extractK(mem);\n    }\n\n    final long dataBytes = mem.getCapacity() - (preLongs << 3);\n\n    return LS\n            + \"### END \" + family.getFamilyName().toUpperCase() + \" PREAMBLE SUMMARY\" + LS\n            + \"Byte  0: Preamble Longs           : \" + preLongs + LS\n            + \"Byte  0: ResizeFactor             : \" + rf.toString() + LS\n            + \"Byte  1: Serialization Version    : \" + serVer + LS\n            + \"Byte  2: Family                   : \" + family.toString() + LS\n            + \"Byte  3: Flags Field              : \" + flagsStr + LS\n            //+ \"  BIG_ENDIAN_STORAGE              : \" + bigEndian + LS\n            //+ \"  (Native Byte Order)             : \" + nativeOrder + LS\n            //+ \"  READ_ONLY                       : \" + readOnly + LS\n            + \"  EMPTY                           : \" + isEmpty + LS\n            + \"Bytes  4-7: Max Sketch Size (maxK): \" + k + LS\n            + \"TOTAL Sketch Bytes                : \" + mem.getCapacity() + LS\n            + \"  Preamble Bytes                  : \" + (preLongs << 3) + LS\n            + \"  Sketch Bytes                    : \" + dataBytes + LS\n            + \"### END \" + family.getFamilyName().toUpperCase() + \" PREAMBLE SUMMARY\" + LS;\n  }\n\n  // Extraction methods\n\n  static int extractPreLongs(final Memory mem) {\n    return mem.getByte(PREAMBLE_LONGS_BYTE) & 0x3F;\n  }\n\n  static int extractResizeFactor(final Memory mem) {\n    return (mem.getByte(PREAMBLE_LONGS_BYTE) >>> LG_RESIZE_FACTOR_BIT) & 0x3;\n  }\n\n  static int extractSerVer(final Memory mem) {\n    return mem.getByte(SER_VER_BYTE) & 0xFF;\n  }\n\n  static int extractFamilyID(final Memory mem) {\n    return mem.getByte(FAMILY_BYTE) & 0xFF;\n  }\n\n  static int extractFlags(final Memory mem) {\n    return mem.getByte(FLAGS_BYTE) & 0xFF;\n  }\n\n  static short extractEncodedReservoirSize(final Memory mem) {\n    return mem.getShort(RESERVOIR_SIZE_SHORT);\n  }\n\n  static int extractK(final Memory mem) {\n    return mem.getInt(RESERVOIR_SIZE_INT);\n  }\n\n  static int extractMaxK(final Memory mem) {\n    return extractK(mem);\n  }\n\n  static long extractN(final Memory mem) {\n    return mem.getLong(ITEMS_SEEN_LONG);\n  }\n\n  static int extractHRegionItemCount(final Memory mem) {\n    return mem.getInt(ITEM_COUNT_H_INT);\n  }\n\n  static int extractRRegionItemCount(final Memory mem) {\n    return mem.getInt(ITEM_COUNT_R_INT);\n  }\n\n  static double extractTotalRWeight(final Memory mem) {\n    return mem.getDouble(TOTAL_WEIGHT_R_DOUBLE);\n  }\n\n  static double extractOuterTauNumerator(final Memory mem) {\n    return mem.getDouble(OUTER_TAU_NUM_DOUBLE);\n  }\n\n  static long extractOuterTauDenominator(final Memory mem) {\n    return mem.getLong(OUTER_TAU_DENOM_LONG);\n  }\n\n  // Insertion methods\n\n  static void insertPreLongs(final WritableMemory wmem, final int preLongs) {\n    final int curByte = wmem.getByte(PREAMBLE_LONGS_BYTE);\n    final int mask = 0x3F;\n    final byte newByte = (byte) ((preLongs & mask) | (~mask & curByte));\n    wmem.putByte(PREAMBLE_LONGS_BYTE, newByte);\n  }\n\n  static void insertLgResizeFactor(final WritableMemory wmem, final int rf) {\n    final int curByte = wmem.getByte(PREAMBLE_LONGS_BYTE);\n    final int shift = LG_RESIZE_FACTOR_BIT; // shift in bits\n    final int mask = 3;\n    final byte newByte = (byte) (((rf & mask) << shift) | (~(mask << shift) & curByte));\n    wmem.putByte(PREAMBLE_LONGS_BYTE, newByte);\n  }\n\n  static void insertSerVer(final WritableMemory wmem, final int serVer) {\n    wmem.putByte(SER_VER_BYTE, (byte) serVer);\n  }\n\n  static void insertFamilyID(final WritableMemory wmem, final int famId) {\n    wmem.putByte(FAMILY_BYTE, (byte) famId);\n  }\n\n  static void insertFlags(final WritableMemory wmem, final int flags) {\n    wmem.putByte(FLAGS_BYTE,  (byte) flags);\n  }\n\n  static void insertK(final WritableMemory wmem, final int k) {\n    wmem.putInt(RESERVOIR_SIZE_INT, k);\n  }\n\n  static void insertMaxK(final WritableMemory wmem, final int maxK) {\n    insertK(wmem, maxK);\n  }\n\n  static void insertN(final WritableMemory wmem, final long totalSeen) {\n    wmem.putLong(ITEMS_SEEN_LONG, totalSeen);\n  }\n\n  static void insertHRegionItemCount(final WritableMemory wmem, final int hCount) {\n    wmem.putInt(ITEM_COUNT_H_INT, hCount);\n  }\n\n  static void insertRRegionItemCount(final WritableMemory wmem, final int rCount) {\n    wmem.putInt(ITEM_COUNT_R_INT, rCount);\n  }\n\n  static void insertTotalRWeight(final WritableMemory wmem, final double weight) {\n    wmem.putDouble(TOTAL_WEIGHT_R_DOUBLE, weight);\n  }\n\n  static void insertOuterTauNumerator(final WritableMemory wmem, final double numer) {\n    wmem.putDouble(OUTER_TAU_NUM_DOUBLE, numer);\n  }\n\n  static void insertOuterTauDenominator(final WritableMemory wmem, final long denom) {\n    wmem.putLong(OUTER_TAU_DENOM_LONG, denom);\n  }\n\n  /**\n   * Checks Memory for capacity to hold the preamble and returns the extracted preLongs.\n   * @param mem the given Memory\n   * @return the extracted prelongs value.\n   */\n  static int getAndCheckPreLongs(final Memory mem) {\n    final long cap = mem.getCapacity();\n    if (cap < 8) { throwNotBigEnough(cap, 8); }\n    final int preLongs = mem.getByte(0) & 0x3F;\n    final int required = Math.max(preLongs << 3, 8);\n    if (cap < required) { throwNotBigEnough(cap, required); }\n    return preLongs;\n  }\n\n  private static void throwNotBigEnough(final long cap, final int required) {\n    throw new SketchesArgumentException(\n        \"Possible Corruption: Size of byte array or Memory not large enough: Size: \" + cap\n        + \", Required: \" + required);\n  }\n}", "class_id": 0, "repo": "tallamjr/incubator-datasketches-java", "file": "src/main/java/org/apache/datasketches/sampling/PreambleUtil.java", "last_update_at": "2019-05-17T10:07:43+00:00", "question_id": "8d65dcfa9e34e222bc74fbbe881c1482d08a225b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["final class PreambleUtil {\n  private PreambleUtil() {}\n  // ###### DO NOT MESS WITH THIS FROM HERE ...\n  // Preamble byte Addresses\n  static final int PREAMBLE_LONGS_BYTE   = 0; // Only low 6 bits used\n  static final int LG_RESIZE_FACTOR_BIT  = 6; // upper 2 bits. Not used by compact or direct.\n  static final int SER_VER_BYTE          = 1;\n  static final int FAMILY_BYTE           = 2;\n  static final int FLAGS_BYTE            = 3;\n  static final int RESERVOIR_SIZE_SHORT  = 4; // used in ser_ver 1\n  static final int RESERVOIR_SIZE_INT    = 4;\n  static final int SERDE_ID_SHORT        = 6; // used in ser_ver 1\n  static final int ITEMS_SEEN_LONG       = 8;\n  static final int MAX_K_SIZE_INT        = 4; // used in Union only\n  static final int OUTER_TAU_NUM_DOUBLE  = 16; // used in Varopt Union only\n  static final int OUTER_TAU_DENOM_LONG  = 24; // used in Varopt Union only\n  // constants and addresses used in varopt\n  static final int ITEM_COUNT_H_INT      = 16;\n  static final int ITEM_COUNT_R_INT      = 20;\n  static final int TOTAL_WEIGHT_R_DOUBLE = 24;\n  static final int VO_PRELONGS_EMPTY     = Family.VAROPT.getMinPreLongs();\n  static final int VO_PRELONGS_WARMUP    = 3;   // Doesn't match min or max prelongs in Family\n  static final int VO_PRELONGS_FULL      = Family.VAROPT.getMaxPreLongs();\n  // flag bit masks\n  //static final int BIG_ENDIAN_FLAG_MASK = 1;\n  //static final int READ_ONLY_FLAG_MASK  = 2;\n  static final int EMPTY_FLAG_MASK      = 4;\n  static final int GADGET_FLAG_MASK     = 128;\n  //Other constants\n  static final int SER_VER                    = 2;\n  static final boolean NATIVE_ORDER_IS_BIG_ENDIAN  =\n      (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN);\n  // STRINGS\n  /**\n   * Returns a human readable string summary of the preamble state of the given byte array.\n   * Used primarily in testing.\n   *\n   * @param byteArr the given byte array.\n   * @return the summary preamble string.\n   */\n  static String preambleToString(final byte[] byteArr) {\n    final Memory mem = Memory.wrap(byteArr);\n    return preambleToString(mem);\n  }\n  /**\n   * Returns a human readable string summary of the preamble state of the given Memory.\n   * Note: other than making sure that the given Memory size is large\n   * enough for just the preamble, this does not do much value checking of the contents of the\n   * preamble as this is primarily a tool for debugging the preamble visually.\n   *\n   * @param mem the given Memory.\n   * @return the summary preamble string.\n   */\n  static String preambleToString(final Memory mem) {\n    final int preLongs = getAndCheckPreLongs(mem);  // make sure we can get the assumed preamble\n    final Family family = Family.idToFamily(mem.getByte(FAMILY_BYTE));\n    switch (family) {\n      case RESERVOIR:\n      case VAROPT:\n        return sketchPreambleToString(mem, family, preLongs);\n      case RESERVOIR_UNION:\n      case VAROPT_UNION:\n        return unionPreambleToString(mem, family, preLongs);\n      default:\n        throw new SketchesArgumentException(\"Inspecting preamble with Sampling family's \"\n                + \"PreambleUtil with object of family \" + family.getFamilyName());\n    }\n  }\n  private static String sketchPreambleToString(final Memory mem,\n                                               final Family family,\n                                               final int preLongs) {\n    final ResizeFactor rf = ResizeFactor.getRF(extractResizeFactor(mem));\n    final int serVer = extractSerVer(mem);\n    // Flags\n    final int flags = extractFlags(mem);\n    final String flagsStr = zeroPad(Integer.toBinaryString(flags), 8) + \", \" + (flags);\n    //final boolean bigEndian = (flags & BIG_ENDIAN_FLAG_MASK) > 0;\n    //final String nativeOrder = ByteOrder.nativeOrder().toString();\n    //final boolean readOnly = (flags & READ_ONLY_FLAG_MASK) > 0;\n    final boolean isEmpty = (flags & EMPTY_FLAG_MASK) > 0;\n    final boolean isGadget = (flags & GADGET_FLAG_MASK) > 0;\n    final int k;\n    if (serVer == 1) {\n      final short encK = extractEncodedReservoirSize(mem);\n      k = ReservoirSize.decodeValue(encK);\n    } else {\n      k = extractK(mem);\n    }\n    long n = 0;\n    if (!isEmpty) {\n      n = extractN(mem);\n    }\n    final long dataBytes = mem.getCapacity() - (preLongs << 3);\n    final StringBuilder sb = new StringBuilder();\n    sb.append(LS)\n      .append(\"### END \")\n      .append(family.getFamilyName().toUpperCase())\n      .append(\" PREAMBLE SUMMARY\").append(LS)\n      .append(\"Byte  0: Preamble Longs       : \").append(preLongs).append(LS)\n      .append(\"Byte  0: ResizeFactor         : \").append(rf.toString()).append(LS)\n      .append(\"Byte  1: Serialization Version: \").append(serVer).append(LS)\n      .append(\"Byte  2: Family               : \").append(family.toString()).append(LS)\n      .append(\"Byte  3: Flags Field          : \").append(flagsStr).append(LS)\n      //.append(\"  BIG_ENDIAN_STORAGE          : \").append(bigEndian).append(LS)\n      //.append(\"  (Native Byte Order)         : \").append(nativeOrder).append(LS)\n      //.append(\"  READ_ONLY                   : \").append(readOnly).append(LS)\n      .append(\"  EMPTY                       : \").append(isEmpty).append(LS);\n    if (family == Family.VAROPT) {\n      sb.append(\"  GADGET                      : \").append(isGadget).append(LS);\n    }\n    sb.append(\"Bytes  4-7: Sketch Size (k)   : \").append(k).append(LS);\n    if (!isEmpty) {\n      sb.append(\"Bytes 8-15: Items Seen (n)    : \").append(n).append(LS);\n    }\n    if ((family == Family.VAROPT) && !isEmpty) {\n      final int hCount = extractHRegionItemCount(mem);\n      final int rCount = extractRRegionItemCount(mem);\n      final double totalRWeight = extractTotalRWeight(mem);\n      sb.append(\"Bytes 16-19: H region count   : \").append(hCount).append(LS)\n        .append(\"Bytes 20-23: R region count   : \").append(rCount).append(LS);\n      if (rCount > 0) {\n        sb.append(\"Bytes 24-31: R region weight  : \").append(totalRWeight).append(LS);\n      }\n    }\n    sb.append(\"TOTAL Sketch Bytes            : \").append(mem.getCapacity()).append(LS)\n      .append(\"  Preamble Bytes              : \").append(preLongs << 3).append(LS)\n      .append(\"  Data Bytes                  : \").append(dataBytes).append(LS)\n      .append(\"### END \")\n      .append(family.getFamilyName().toUpperCase())\n      .append(\" PREAMBLE SUMMARY\").append(LS);\n    return sb.toString();\n  }\n  private static String unionPreambleToString(final Memory mem,\n                                              final Family family,\n                                              final int preLongs) {\n    final ResizeFactor rf = ResizeFactor.getRF(extractResizeFactor(mem));\n    final int serVer = extractSerVer(mem);\n    // Flags\n    final int flags = extractFlags(mem);\n    final String flagsStr = zeroPad(Integer.toBinaryString(flags), 8) + \", \" + (flags);\n    //final boolean bigEndian = (flags & BIG_ENDIAN_FLAG_MASK) > 0;\n    //final String nativeOrder = ByteOrder.nativeOrder().toString();\n    //final boolean readOnly = (flags & READ_ONLY_FLAG_MASK) > 0;\n    final boolean isEmpty = (flags & EMPTY_FLAG_MASK) > 0;\n    final int k;\n    if (serVer == 1) {\n      final short encK = extractEncodedReservoirSize(mem);\n      k = ReservoirSize.decodeValue(encK);\n    } else {\n      k = extractK(mem);\n    }\n    final long dataBytes = mem.getCapacity() - (preLongs << 3);\n    return LS\n            + \"### END \" + family.getFamilyName().toUpperCase() + \" PREAMBLE SUMMARY\" + LS\n            + \"Byte  0: Preamble Longs           : \" + preLongs + LS\n            + \"Byte  0: ResizeFactor             : \" + rf.toString() + LS\n            + \"Byte  1: Serialization Version    : \" + serVer + LS\n            + \"Byte  2: Family                   : \" + family.toString() + LS\n            + \"Byte  3: Flags Field              : \" + flagsStr + LS\n            //+ \"  BIG_ENDIAN_STORAGE              : \" + bigEndian + LS\n            //+ \"  (Native Byte Order)             : \" + nativeOrder + LS\n            //+ \"  READ_ONLY                       : \" + readOnly + LS\n            + \"  EMPTY                           : \" + isEmpty + LS\n            + \"Bytes  4-7: Max Sketch Size (maxK): \" + k + LS\n            + \"TOTAL Sketch Bytes                : \" + mem.getCapacity() + LS\n            + \"  Preamble Bytes                  : \" + (preLongs << 3) + LS\n            + \"  Sketch Bytes                    : \" + dataBytes + LS\n            + \"### END \" + family.getFamilyName().toUpperCase() + \" PREAMBLE SUMMARY\" + LS;\n  }\n  // Extraction methods\n  static int extractPreLongs(final Memory mem) {\n    return mem.getByte(PREAMBLE_LONGS_BYTE) & 0x3F;\n  }\n  static int extractResizeFactor(final Memory mem) {\n    return (mem.getByte(PREAMBLE_LONGS_BYTE) >>> LG_RESIZE_FACTOR_BIT) & 0x3;\n  }\n  static int extractSerVer(final Memory mem) {\n    return mem.getByte(SER_VER_BYTE) & 0xFF;\n  }\n  static int extractFamilyID(final Memory mem) {\n    return mem.getByte(FAMILY_BYTE) & 0xFF;\n  }\n  static int extractFlags(final Memory mem) {\n    return mem.getByte(FLAGS_BYTE) & 0xFF;\n  }\n  static short extractEncodedReservoirSize(final Memory mem) {\n    return mem.getShort(RESERVOIR_SIZE_SHORT);\n  }\n  static int extractK(final Memory mem) {\n    return mem.getInt(RESERVOIR_SIZE_INT);\n  }\n  static int extractMaxK(final Memory mem) {\n    return extractK(mem);\n  }\n  static long extractN(final Memory mem) {\n    return mem.getLong(ITEMS_SEEN_LONG);\n  }\n  static int extractHRegionItemCount(final Memory mem) {\n    return mem.getInt(ITEM_COUNT_H_INT);\n  }\n  static int extractRRegionItemCount(final Memory mem) {\n    return mem.getInt(ITEM_COUNT_R_INT);\n  }\n  static double extractTotalRWeight(final Memory mem) {\n    return mem.getDouble(TOTAL_WEIGHT_R_DOUBLE);\n  }\n  static double extractOuterTauNumerator(final Memory mem) {\n    return mem.getDouble(OUTER_TAU_NUM_DOUBLE);\n  }\n  static long extractOuterTauDenominator(final Memory mem) {\n    return mem.getLong(OUTER_TAU_DENOM_LONG);\n  }\n  // Insertion methods\n  static void insertPreLongs(final WritableMemory wmem, final int preLongs) {\n    final int curByte = wmem.getByte(PREAMBLE_LONGS_BYTE);\n    final int mask = 0x3F;\n    final byte newByte = (byte) ((preLongs & mask) | (~mask & curByte));\n    wmem.putByte(PREAMBLE_LONGS_BYTE, newByte);\n  }\n  static void insertLgResizeFactor(final WritableMemory wmem, final int rf) {\n    final int curByte = wmem.getByte(PREAMBLE_LONGS_BYTE);\n    final int shift = LG_RESIZE_FACTOR_BIT; // shift in bits\n    final int mask = 3;\n    final byte newByte = (byte) (((rf & mask) << shift) | (~(mask << shift) & curByte));\n    wmem.putByte(PREAMBLE_LONGS_BYTE, newByte);\n  }\n  static void insertSerVer(final WritableMemory wmem, final int serVer) {\n    wmem.putByte(SER_VER_BYTE, (byte) serVer);\n  }\n  static void insertFamilyID(final WritableMemory wmem, final int famId) {\n    wmem.putByte(FAMILY_BYTE, (byte) famId);\n  }\n  static void insertFlags(final WritableMemory wmem, final int flags) {\n    wmem.putByte(FLAGS_BYTE,  (byte) flags);\n  }\n  static void insertK(final WritableMemory wmem, final int k) {\n    wmem.putInt(RESERVOIR_SIZE_INT, k);\n  }\n  static void insertMaxK(final WritableMemory wmem, final int maxK) {\n    insertK(wmem, maxK);\n  }\n  static void insertN(final WritableMemory wmem, final long totalSeen) {\n    wmem.putLong(ITEMS_SEEN_LONG, totalSeen);\n  }\n  static void insertHRegionItemCount(final WritableMemory wmem, final int hCount) {\n    wmem.putInt(ITEM_COUNT_H_INT, hCount);\n  }\n  static void insertRRegionItemCount(final WritableMemory wmem, final int rCount) {\n    wmem.putInt(ITEM_COUNT_R_INT, rCount);\n  }\n  static void insertTotalRWeight(final WritableMemory wmem, final double weight) {\n    wmem.putDouble(TOTAL_WEIGHT_R_DOUBLE, weight);\n  }\n  static void insertOuterTauNumerator(final WritableMemory wmem, final double numer) {\n    wmem.putDouble(OUTER_TAU_NUM_DOUBLE, numer);\n  }\n  static void insertOuterTauDenominator(final WritableMemory wmem, final long denom) {\n    wmem.putLong(OUTER_TAU_DENOM_LONG, denom);\n  }\n  /**\n   * Checks Memory for capacity to hold the preamble and returns the extracted preLongs.\n   * @param mem the given Memory\n   * @return the extracted prelongs value.\n   */\n  static int getAndCheckPreLongs(final Memory mem) {\n    final long cap = mem.getCapacity();\n    if (cap < 8) { throwNotBigEnough(cap, 8); }\n    final int preLongs = mem.getByte(0) & 0x3F;\n    final int required = Math.max(preLongs << 3, 8);\n    if (cap < required) { throwNotBigEnough(cap, required); }\n    return preLongs;\n  }\n  private static void throwNotBigEnough(final long cap, final int required) {\n    throw new SketchesArgumentException(\n        \"Possible Corruption: Size of byte array or Memory not large enough: Size: \" + cap\n        + \", Required: \" + required);\n  }\n"]]}
{"hexsha": "d49b3984ad6ded734a79ffc8c31a25948fd3d85d", "ext": "java", "lang": "Java", "content": "public class RecipeUtil {\n    private static final CBRecipeBackend SERVICE = BackendManager.request(CBRecipeBackend.class).orElseThrow(UnsupportedOperationException::new);\n\n    /**\n     * Registers the given recipe.\n     * @param recipe the recipe\n     */\n    public static void register(@NotNull Recipe recipe){\n        Bukkit.addRecipe(recipe);\n    }\n\n    /**\n     * Unregisters the given recipe.\n     * @param recipe the recipe\n     */\n    @Beta\n    public static void unregister(@NotNull Recipe recipe){\n        SERVICE.removeIf(r -> compare(r, recipe));\n    }\n\n    /**\n     * Checks if the given recipe is registered.\n     * @param recipe the recipe\n     * @return {@code true} if it was or {@code false} otherwise\n     */\n    @Beta\n    public static boolean isRegistered(@NotNull Recipe recipe){\n        return SERVICE.anyMatch(r -> compare(r, recipe));\n    }\n\n    /**\n     * Compares two given recipe.\n     * @param recipe the first recipe\n     * @param otherRecipe the second recipe\n     * @return {@code true} if they are equal or {@code false} otherwise\n     */\n    public static boolean compare(@Nullable Recipe recipe, @Nullable Recipe otherRecipe){\n        if(recipe == null && otherRecipe == null) return true;\n        if(recipe == null || otherRecipe == null) return false;\n        if(NMSVersion.current().compare(NMSVersion.v1_12_R1) >= 0 && recipe instanceof Keyed && otherRecipe instanceof Keyed){\n            return ((Keyed) recipe).getKey().equals(((Keyed) otherRecipe).getKey());\n        }\n        if(recipe instanceof ShapedRecipe && otherRecipe instanceof ShapedRecipe) {\n            ShapedRecipe a = (ShapedRecipe) recipe;\n            ShapedRecipe b = (ShapedRecipe) otherRecipe;\n            if(ItemUtil.compare(a.getResult(), b.getResult())){\n                List<ItemStack> ai = new ArrayList<>();\n                List<ItemStack> bi = new ArrayList<>();\n                for(String as : a.getShape()){\n                    for(char ac : as.toCharArray()) ai.add(a.getIngredientMap().get(ac));\n                }\n                for(String bs : b.getShape()){\n                    for(char bc : bs.toCharArray()) bi.add(b.getIngredientMap().get(bc));\n                }\n                return ItemUtil.compare(ai, bi);\n            }\n        }\n        else if(recipe instanceof ShapelessRecipe && otherRecipe instanceof ShapelessRecipe){\n            ShapelessRecipe a = (ShapelessRecipe) recipe;\n            ShapelessRecipe b = (ShapelessRecipe) otherRecipe;\n            if(ItemUtil.compare(a.getResult(), b.getResult()))\n                return ItemUtil.compare(a.getIngredientList(), b.getIngredientList());\n        }\n        else if(recipe instanceof FurnaceRecipe && otherRecipe instanceof FurnaceRecipe){\n            FurnaceRecipe a = (FurnaceRecipe) recipe;\n            FurnaceRecipe b = (FurnaceRecipe) otherRecipe;\n            return a.getExperience() == b.getExperience()\n                    && ItemUtil.compare(a.getInput(), b.getInput())\n                    && ItemUtil.compare(a.getResult(), b.getResult());\n        }\n        else if(recipe instanceof MerchantRecipe && otherRecipe instanceof MerchantRecipe){\n            MerchantRecipe a = (MerchantRecipe) recipe;\n            MerchantRecipe b = (MerchantRecipe) otherRecipe;\n            return a.hasExperienceReward() == b.hasExperienceReward() && a.getMaxUses() == b.getMaxUses() && a.getUses() == b.getUses() && ItemUtil.compare(a.getResult(), b.getResult()) && ItemUtil.compare(a.getIngredients(), b.getIngredients());\n        }\n        return false;\n    }\n}", "class_id": 0, "repo": "anhcraft/CraftKit", "file": "spigot/src/main/java/dev/anhcraft/craftkit/utils/RecipeUtil.java", "last_update_at": "2019-12-29T08:35:24+00:00", "question_id": "d49b3984ad6ded734a79ffc8c31a25948fd3d85d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RecipeUtil {\n    private static final CBRecipeBackend SERVICE = BackendManager.request(CBRecipeBackend.class).orElseThrow(UnsupportedOperationException::new);\n    /**\n     * Registers the given recipe.\n     * @param recipe the recipe\n     */\n    public static void register(@NotNull Recipe recipe){\n        Bukkit.addRecipe(recipe);\n    }\n    /**\n     * Unregisters the given recipe.\n     * @param recipe the recipe\n     */\n    @Beta\n    public static void unregister(@NotNull Recipe recipe){\n        SERVICE.removeIf(r -> compare(r, recipe));\n    }\n    /**\n     * Checks if the given recipe is registered.\n     * @param recipe the recipe\n     * @return {@code true} if it was or {@code false} otherwise\n     */\n    @Beta\n    public static boolean isRegistered(@NotNull Recipe recipe){\n        return SERVICE.anyMatch(r -> compare(r, recipe));\n    }\n    /**\n     * Compares two given recipe.\n     * @param recipe the first recipe\n     * @param otherRecipe the second recipe\n     * @return {@code true} if they are equal or {@code false} otherwise\n     */\n    public static boolean compare(@Nullable Recipe recipe, @Nullable Recipe otherRecipe){\n        if(recipe == null && otherRecipe == null) return true;\n        if(recipe == null || otherRecipe == null) return false;\n        if(NMSVersion.current().compare(NMSVersion.v1_12_R1) >= 0 && recipe instanceof Keyed && otherRecipe instanceof Keyed){\n            return ((Keyed) recipe).getKey().equals(((Keyed) otherRecipe).getKey());\n        }\n        if(recipe instanceof ShapedRecipe && otherRecipe instanceof ShapedRecipe) {\n            ShapedRecipe a = (ShapedRecipe) recipe;\n            ShapedRecipe b = (ShapedRecipe) otherRecipe;\n            if(ItemUtil.compare(a.getResult(), b.getResult())){\n                List<ItemStack> ai = new ArrayList<>();\n                List<ItemStack> bi = new ArrayList<>();\n                for(String as : a.getShape()){\n                    for(char ac : as.toCharArray()) ai.add(a.getIngredientMap().get(ac));\n                }\n                for(String bs : b.getShape()){\n                    for(char bc : bs.toCharArray()) bi.add(b.getIngredientMap().get(bc));\n                }\n                return ItemUtil.compare(ai, bi);\n            }\n        }\n        else if(recipe instanceof ShapelessRecipe && otherRecipe instanceof ShapelessRecipe){\n            ShapelessRecipe a = (ShapelessRecipe) recipe;\n            ShapelessRecipe b = (ShapelessRecipe) otherRecipe;\n            if(ItemUtil.compare(a.getResult(), b.getResult()))\n                return ItemUtil.compare(a.getIngredientList(), b.getIngredientList());\n        }\n        else if(recipe instanceof FurnaceRecipe && otherRecipe instanceof FurnaceRecipe){\n            FurnaceRecipe a = (FurnaceRecipe) recipe;\n            FurnaceRecipe b = (FurnaceRecipe) otherRecipe;\n            return a.getExperience() == b.getExperience()\n                    && ItemUtil.compare(a.getInput(), b.getInput())\n                    && ItemUtil.compare(a.getResult(), b.getResult());\n        }\n        else if(recipe instanceof MerchantRecipe && otherRecipe instanceof MerchantRecipe){\n            MerchantRecipe a = (MerchantRecipe) recipe;\n            MerchantRecipe b = (MerchantRecipe) otherRecipe;\n            return a.hasExperienceReward() == b.hasExperienceReward() && a.getMaxUses() == b.getMaxUses() && a.getUses() == b.getUses() && ItemUtil.compare(a.getResult(), b.getResult()) && ItemUtil.compare(a.getIngredients(), b.getIngredients());\n        }\n        return false;\n    }\n"]]}
{"hexsha": "91d4c7887eaa04d2f2f99ee2b5f3879a0f7f6a30", "ext": "java", "lang": "Java", "content": "public class EL3204_2 extends Slave {\n    static final long vendorID = 0x00000002L;\n    static final long productCode = 0x0c843052;\n\n    public class Input extends TxPDO {\n        protected Input(int address) {\n            super(address);\n        }\n\n        Bool underrange = new Bool();\n        Bool overrange = new Bool();\n        Member limit1 = new Bit2();\n        Member limit2 = new Bit2();\n        Bool error = new Bool();\n        Bit7 gap = new Bit7();\n        Bool txPDOState = new Bool();\n        Bool txPDOToggle = new Bool();\n        Signed16 value = new Signed16();\n    }\n\n    private final Input temperatureOverheatedGas = new Input(0x1a00);\n    private final Input temperatureSwitchOnSensor = new Input(0x1a01);\n    private final Input temperatureReserve1 = new Input(0x1a02);\n    private final Input temperatureReserve2 = new Input(0x1a03);\n\n\n    public EL3204_2(int aliasAddress, int configAddress) {\n        super(vendorID, productCode, aliasAddress, configAddress);\n\n        registerSyncManager(new SyncManager(2, false));\n        registerSyncManager(new SyncManager(3, false));\n\n        sm(3).registerPDO(temperatureOverheatedGas);\n        sm(3).registerPDO(temperatureSwitchOnSensor);\n        sm(3).registerPDO(temperatureReserve1);\n        sm(3).registerPDO(temperatureReserve2);\n    }\n\n    @Override\n    protected void configure(boolean dcEnabled, long cycleTimeInNs) {\n        // Configure PT1000\n        writeSDO(32768, 25, (short) 2);\n        writeSDO(32784, 25, (short) 2);\n        writeSDO(32800, 25, (short) 2);\n        writeSDO(32816, 25, (short) 2);\n    }\n\n\n    public float getTemperatureSwitchOnSensor() {\n        return convert(temperatureSwitchOnSensor.value.get());\n    }\n\n    public boolean getTemperatureSwitchOnSensorUnderrange() {\n        return temperatureSwitchOnSensor.underrange.get();\n    }\n\n    public boolean getTemperatureSwitchOnSensorOverrange() {\n        return temperatureSwitchOnSensor.overrange.get();\n    }\n\n    public boolean getTemperatureSwitchOnSensorError() {\n        return temperatureSwitchOnSensor.error.get();\n    }\n\n\n    public float getTemperatureOverheatedGas() {\n        return convert(temperatureOverheatedGas.value.get());\n    }\n\n    public boolean getTemperatureOverheatedGasUnderrange() {\n        return temperatureOverheatedGas.underrange.get();\n    }\n\n    public boolean getTemperatureOverheatedGasOverrange() {\n        return temperatureOverheatedGas.overrange.get();\n    }\n\n    public boolean getTemperatureOverheatedGasError() {\n        return temperatureOverheatedGas.error.get();\n    }\n\n\n    public float getTemperatureReserve1() {\n        return convert(temperatureReserve1.value.get());\n    }\n\n    public boolean getTemperatureReserve1Underrange() {\n        return temperatureReserve1.underrange.get();\n    }\n\n    public boolean getTemperatureReserve1Overrange() {\n        return temperatureReserve1.overrange.get();\n    }\n\n    public boolean getTemperatureReserve1Error() {\n        return temperatureReserve1.error.get();\n    }\n\n\n    public float getTemperatureReserve2() {\n        return convert(temperatureReserve2.value.get());\n    }\n\n    public boolean getTemperatureReserve2Underrange() {\n        return temperatureReserve2.underrange.get();\n    }\n\n    public boolean getTemperatureReserve2Overrange() {\n        return temperatureReserve2.overrange.get();\n    }\n\n    public boolean getTemperatureReserve2Error() {\n        return temperatureReserve2.error.get();\n    }\n\n    public String toProcessdataString() {\n        return new StringJoiner(\", \", EL3204_2.class.getSimpleName() + \"[\", \"]\")\n            .add(\"TemperatureSwitchOnSensor=\" + getTemperatureSwitchOnSensor())\n            .add(\"TemperatureSwitchOnSensorError=\" + getTemperatureSwitchOnSensorError())\n            .add(\"TemperatureSwitchOnSensorUnderrange=\" + getTemperatureSwitchOnSensorUnderrange())\n            .add(\"TemperatureSwitchOnSensor=Overrange\" + getTemperatureSwitchOnSensorOverrange())\n\n            .add(\"TemperatureOverheatedGas=\" + getTemperatureOverheatedGas())\n            .add(\"TemperatureOverheatedGasError=\" + getTemperatureOverheatedGasError())\n            .add(\"TemperatureOverheatedGasUnderrange=\" + getTemperatureOverheatedGasUnderrange())\n            .add(\"TemperatureOverheatedGas=Overrange\" + getTemperatureOverheatedGasOverrange())\n\n            .add(\"TemperatureReserve1=\" + getTemperatureReserve1())\n            .add(\"TemperatureReserve1Error=\" + getTemperatureReserve1Error())\n            .add(\"TemperatureReserve1Underrange=\" + getTemperatureReserve1Underrange())\n            .add(\"TemperatureReserve1=Overrange\" + getTemperatureReserve1Overrange())\n\n            .add(\"TemperatureReserve2=\" + getTemperatureReserve2())\n            .add(\"TemperatureReserve2Error=\" + getTemperatureReserve2Error())\n            .add(\"TemperatureReserve2Underrange=\" + getTemperatureReserve2Underrange())\n            .add(\"TemperatureReserve2=Overrange\" + getTemperatureReserve2Overrange())\n\n            .toString();\n    }\n\n    private float convert(short value) {\n        return Float.valueOf(value) / 10;\n    }\n\n\n/* Slaveinfo:\n\n7 - 0:6 EL3204\n\tManufacturer: 0x00000002\n\tProduct code: 0x0c843052\n\tRevision: 1114112\n\tDistributed Clocks: yes\n\tSM(0) Address: 0x1000, length: 128\tFlags: 65574\tType: Mailbox messages receive\n\tSM(1) Address: 0x1080, length: 128\tFlags: 65570\tType: Mailbox messages transmit\n\tSM(2) Address: 0x1100, length: 0\tFlags: 4\tType: Cyclic process data receive\n\tSM(3) Address: 0x1180, length: 16\tFlags: 65568\tType: Cyclic process data transmit\n\t\tTxPDO 0x1a00\tRTD TxPDO-Map Ch.1\n\t\t\t0x6000:0x01 BOOLEAN\tUnderrange\n\t\t\t0x6000:0x02 BOOLEAN\tOverrange\n\t\t\t0x6000:0x03 BIT2\tLimit 1\n\t\t\t0x6000:0x05 BIT2\tLimit 2\n\t\t\t0x6000:0x07 BOOLEAN\tError\n\t\t\t0x0000:0x00 (7 bit)\n\t\t\t0x1800:0x07 BOOLEAN\tTxPDO State\n\t\t\t0x1800:0x09 BOOLEAN\tTxPDO Toggle\n\t\t\t0x6000:0x11 INTEGER16\tValue\n\t\tTxPDO 0x1a01\tRTD TxPDO-Map Ch.2\n\t\t\t0x6010:0x01 BOOLEAN\tUnderrange\n\t\t\t0x6010:0x02 BOOLEAN\tOverrange\n\t\t\t0x6010:0x03 BIT2\tLimit 1\n\t\t\t0x6010:0x05 BIT2\tLimit 2\n\t\t\t0x6010:0x07 BOOLEAN\tError\n\t\t\t0x0000:0x00 (7 bit)\n\t\t\t0x1801:0x07 BOOLEAN\tTxPDO State\n\t\t\t0x1801:0x09 BOOLEAN\tTxPDO Toggle\n\t\t\t0x6010:0x11 INTEGER16\tValue\n\t\tTxPDO 0x1a02\tRTD TxPDO-Map Ch.3\n\t\t\t0x6020:0x01 BOOLEAN\tUnderrange\n\t\t\t0x6020:0x02 BOOLEAN\tOverrange\n\t\t\t0x6020:0x03 BIT2\tLimit 1\n\t\t\t0x6020:0x05 BIT2\tLimit 2\n\t\t\t0x6020:0x07 BOOLEAN\tError\n\t\t\t0x0000:0x00 (7 bit)\n\t\t\t0x1802:0x07 BOOLEAN\tTxPDO State\n\t\t\t0x1802:0x09 BOOLEAN\tTxPDO Toggle\n\t\t\t0x6020:0x11 INTEGER16\tValue\n\t\tTxPDO 0x1a03\tRTD TxPDO-Map Ch.4\n\t\t\t0x6030:0x01 BOOLEAN\tUnderrange\n\t\t\t0x6030:0x02 BOOLEAN\tOverrange\n\t\t\t0x6030:0x03 BIT2\tLimit 1\n\t\t\t0x6030:0x05 BIT2\tLimit 2\n\t\t\t0x6030:0x07 BOOLEAN\tError\n\t\t\t0x0000:0x00 (7 bit)\n\t\t\t0x1803:0x07 BOOLEAN\tTxPDO State\n\t\t\t0x1803:0x09 BOOLEAN\tTxPDO Toggle\n\t\t\t0x6030:0x11 INTEGER16\tValue\n7 - 0:6 EL3204\n\tManufacturer: 0x00000002\n\tProduct code: 0x0c843052\n\tRevision: 1114112\n\tDistributed Clocks: yes\n\tSM(0) Address: 0x1000, length: 128\tFlags: 65574\tType: Mailbox messages receive\n\tSM(1) Address: 0x1080, length: 128\tFlags: 65570\tType: Mailbox messages transmit\n\tSM(2) Address: 0x1100, length: 0\tFlags: 4\tType: Cyclic process data receive\n\tSM(3) Address: 0x1180, length: 16\tFlags: 65568\tType: Cyclic process data transmit\n\n */\n\n}", "class_id": 0, "repo": "vrees/heatpump-react", "file": "src/main/java/de/vrees/heatpump/slaves/beckhoff/EL3204_2.java", "last_update_at": "2019-10-03T09:09:08+00:00", "question_id": "91d4c7887eaa04d2f2f99ee2b5f3879a0f7f6a30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EL3204_2 extends Slave {\n    static final long vendorID = 0x00000002L;\n    static final long productCode = 0x0c843052;\n    public class Input extends TxPDO {\n        protected Input(int address) {\n            super(address);\n        }\n        Bool underrange = new Bool();\n        Bool overrange = new Bool();\n        Member limit1 = new Bit2();\n        Member limit2 = new Bit2();\n        Bool error = new Bool();\n        Bit7 gap = new Bit7();\n        Bool txPDOState = new Bool();\n        Bool txPDOToggle = new Bool();\n        Signed16 value = new Signed16();\n    }\n    private final Input temperatureOverheatedGas = new Input(0x1a00);\n    private final Input temperatureSwitchOnSensor = new Input(0x1a01);\n    private final Input temperatureReserve1 = new Input(0x1a02);\n    private final Input temperatureReserve2 = new Input(0x1a03);\n    public EL3204_2(int aliasAddress, int configAddress) {\n        super(vendorID, productCode, aliasAddress, configAddress);\n        registerSyncManager(new SyncManager(2, false));\n        registerSyncManager(new SyncManager(3, false));\n        sm(3).registerPDO(temperatureOverheatedGas);\n        sm(3).registerPDO(temperatureSwitchOnSensor);\n        sm(3).registerPDO(temperatureReserve1);\n        sm(3).registerPDO(temperatureReserve2);\n    }\n    @Override\n    protected void configure(boolean dcEnabled, long cycleTimeInNs) {\n        // Configure PT1000\n        writeSDO(32768, 25, (short) 2);\n        writeSDO(32784, 25, (short) 2);\n        writeSDO(32800, 25, (short) 2);\n        writeSDO(32816, 25, (short) 2);\n    }\n    public float getTemperatureSwitchOnSensor() {\n        return convert(temperatureSwitchOnSensor.value.get());\n    }\n    public boolean getTemperatureSwitchOnSensorUnderrange() {\n        return temperatureSwitchOnSensor.underrange.get();\n    }\n    public boolean getTemperatureSwitchOnSensorOverrange() {\n        return temperatureSwitchOnSensor.overrange.get();\n    }\n    public boolean getTemperatureSwitchOnSensorError() {\n        return temperatureSwitchOnSensor.error.get();\n    }\n    public float getTemperatureOverheatedGas() {\n        return convert(temperatureOverheatedGas.value.get());\n    }\n    public boolean getTemperatureOverheatedGasUnderrange() {\n        return temperatureOverheatedGas.underrange.get();\n    }\n    public boolean getTemperatureOverheatedGasOverrange() {\n        return temperatureOverheatedGas.overrange.get();\n    }\n    public boolean getTemperatureOverheatedGasError() {\n        return temperatureOverheatedGas.error.get();\n    }\n    public float getTemperatureReserve1() {\n        return convert(temperatureReserve1.value.get());\n    }\n    public boolean getTemperatureReserve1Underrange() {\n        return temperatureReserve1.underrange.get();\n    }\n    public boolean getTemperatureReserve1Overrange() {\n        return temperatureReserve1.overrange.get();\n    }\n    public boolean getTemperatureReserve1Error() {\n        return temperatureReserve1.error.get();\n    }\n    public float getTemperatureReserve2() {\n        return convert(temperatureReserve2.value.get());\n    }\n    public boolean getTemperatureReserve2Underrange() {\n        return temperatureReserve2.underrange.get();\n    }\n    public boolean getTemperatureReserve2Overrange() {\n        return temperatureReserve2.overrange.get();\n    }\n    public boolean getTemperatureReserve2Error() {\n        return temperatureReserve2.error.get();\n    }\n    public String toProcessdataString() {\n        return new StringJoiner(\", \", EL3204_2.class.getSimpleName() + \"[\", \"]\")\n            .add(\"TemperatureSwitchOnSensor=\" + getTemperatureSwitchOnSensor())\n            .add(\"TemperatureSwitchOnSensorError=\" + getTemperatureSwitchOnSensorError())\n            .add(\"TemperatureSwitchOnSensorUnderrange=\" + getTemperatureSwitchOnSensorUnderrange())\n            .add(\"TemperatureSwitchOnSensor=Overrange\" + getTemperatureSwitchOnSensorOverrange())\n            .add(\"TemperatureOverheatedGas=\" + getTemperatureOverheatedGas())\n            .add(\"TemperatureOverheatedGasError=\" + getTemperatureOverheatedGasError())\n            .add(\"TemperatureOverheatedGasUnderrange=\" + getTemperatureOverheatedGasUnderrange())\n            .add(\"TemperatureOverheatedGas=Overrange\" + getTemperatureOverheatedGasOverrange())\n            .add(\"TemperatureReserve1=\" + getTemperatureReserve1())\n            .add(\"TemperatureReserve1Error=\" + getTemperatureReserve1Error())\n            .add(\"TemperatureReserve1Underrange=\" + getTemperatureReserve1Underrange())\n            .add(\"TemperatureReserve1=Overrange\" + getTemperatureReserve1Overrange())\n            .add(\"TemperatureReserve2=\" + getTemperatureReserve2())\n            .add(\"TemperatureReserve2Error=\" + getTemperatureReserve2Error())\n            .add(\"TemperatureReserve2Underrange=\" + getTemperatureReserve2Underrange())\n            .add(\"TemperatureReserve2=Overrange\" + getTemperatureReserve2Overrange())\n            .toString();\n    }\n    private float convert(short value) {\n        return Float.valueOf(value) / 10;\n    }\n/* Slaveinfo:\n7 - 0:6 EL3204\n\tManufacturer: 0x00000002\n\tProduct code: 0x0c843052\n\tRevision: 1114112\n\tDistributed Clocks: yes\n\tSM(0) Address: 0x1000, length: 128\tFlags: 65574\tType: Mailbox messages receive\n\tSM(1) Address: 0x1080, length: 128\tFlags: 65570\tType: Mailbox messages transmit\n\tSM(2) Address: 0x1100, length: 0\tFlags: 4\tType: Cyclic process data receive\n\tSM(3) Address: 0x1180, length: 16\tFlags: 65568\tType: Cyclic process data transmit\n\t\tTxPDO 0x1a00\tRTD TxPDO-Map Ch.1\n\t\t\t0x6000:0x01 BOOLEAN\tUnderrange\n\t\t\t0x6000:0x02 BOOLEAN\tOverrange\n\t\t\t0x6000:0x03 BIT2\tLimit 1\n\t\t\t0x6000:0x05 BIT2\tLimit 2\n\t\t\t0x6000:0x07 BOOLEAN\tError\n\t\t\t0x0000:0x00 (7 bit)\n\t\t\t0x1800:0x07 BOOLEAN\tTxPDO State\n\t\t\t0x1800:0x09 BOOLEAN\tTxPDO Toggle\n\t\t\t0x6000:0x11 INTEGER16\tValue\n\t\tTxPDO 0x1a01\tRTD TxPDO-Map Ch.2\n\t\t\t0x6010:0x01 BOOLEAN\tUnderrange\n\t\t\t0x6010:0x02 BOOLEAN\tOverrange\n\t\t\t0x6010:0x03 BIT2\tLimit 1\n\t\t\t0x6010:0x05 BIT2\tLimit 2\n\t\t\t0x6010:0x07 BOOLEAN\tError\n\t\t\t0x0000:0x00 (7 bit)\n\t\t\t0x1801:0x07 BOOLEAN\tTxPDO State\n\t\t\t0x1801:0x09 BOOLEAN\tTxPDO Toggle\n\t\t\t0x6010:0x11 INTEGER16\tValue\n\t\tTxPDO 0x1a02\tRTD TxPDO-Map Ch.3\n\t\t\t0x6020:0x01 BOOLEAN\tUnderrange\n\t\t\t0x6020:0x02 BOOLEAN\tOverrange\n\t\t\t0x6020:0x03 BIT2\tLimit 1\n\t\t\t0x6020:0x05 BIT2\tLimit 2\n\t\t\t0x6020:0x07 BOOLEAN\tError\n\t\t\t0x0000:0x00 (7 bit)\n\t\t\t0x1802:0x07 BOOLEAN\tTxPDO State\n\t\t\t0x1802:0x09 BOOLEAN\tTxPDO Toggle\n\t\t\t0x6020:0x11 INTEGER16\tValue\n\t\tTxPDO 0x1a03\tRTD TxPDO-Map Ch.4\n\t\t\t0x6030:0x01 BOOLEAN\tUnderrange\n\t\t\t0x6030:0x02 BOOLEAN\tOverrange\n\t\t\t0x6030:0x03 BIT2\tLimit 1\n\t\t\t0x6030:0x05 BIT2\tLimit 2\n\t\t\t0x6030:0x07 BOOLEAN\tError\n\t\t\t0x0000:0x00 (7 bit)\n\t\t\t0x1803:0x07 BOOLEAN\tTxPDO State\n\t\t\t0x1803:0x09 BOOLEAN\tTxPDO Toggle\n\t\t\t0x6030:0x11 INTEGER16\tValue\n7 - 0:6 EL3204\n\tManufacturer: 0x00000002\n\tProduct code: 0x0c843052\n\tRevision: 1114112\n\tDistributed Clocks: yes\n\tSM(0) Address: 0x1000, length: 128\tFlags: 65574\tType: Mailbox messages receive\n\tSM(1) Address: 0x1080, length: 128\tFlags: 65570\tType: Mailbox messages transmit\n\tSM(2) Address: 0x1100, length: 0\tFlags: 4\tType: Cyclic process data receive\n\tSM(3) Address: 0x1180, length: 16\tFlags: 65568\tType: Cyclic process data transmit\n */\n"]]}
{"hexsha": "91e55880c96dc3cea3c58991d6f11f788d57f87c", "ext": "java", "lang": "Java", "content": "public class ElementPanel extends JPanel implements IElementUpdater\n{\n\tprivate static final long serialVersionUID = 2345409972608231073L;\n\n\tprotected ElementManager manager;\n\n\tprotected SizePanel panelSize;\n\tprotected PositionPanel panelPosition;\n\n    public ElementPanel(ElementManager manager)\n    {\n        this.manager = manager;\n        setBackground(ModelCreator.BACKGROUND);\n        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));\n        initComponents();\n        addComponents();\n    }\n\n    protected void initComponents()\n    {\n        panelSize = new SizePanel(manager);\n        panelPosition = new PositionPanel(manager);\n    }\n\n    protected void addComponents()\n    {\n        add(Box.createRigidArea(new Dimension(188, 5)));\n        add(panelSize);\n        add(Box.createRigidArea(new Dimension(188, 5)));\n        add(panelPosition);\n    }\n\n    @Override\n    public void updateValues(Element cube)\n    {\n        panelSize.updateValues(cube);\n        panelPosition.updateValues(cube);\n    }\n}", "class_id": 0, "repo": "Bricktricker/ModelCreator", "file": "src/main/java/com/mrcrayfish/modelcreator/panels/tabs/ElementPanel.java", "last_update_at": "2019-07-19T16:18:20+00:00", "question_id": "91e55880c96dc3cea3c58991d6f11f788d57f87c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ElementPanel extends JPanel implements IElementUpdater\n{\n\tprivate static final long serialVersionUID = 2345409972608231073L;\n\tprotected ElementManager manager;\n\tprotected SizePanel panelSize;\n\tprotected PositionPanel panelPosition;\n    public ElementPanel(ElementManager manager)\n    {\n        this.manager = manager;\n        setBackground(ModelCreator.BACKGROUND);\n        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));\n        initComponents();\n        addComponents();\n    }\n    protected void initComponents()\n    {\n        panelSize = new SizePanel(manager);\n        panelPosition = new PositionPanel(manager);\n    }\n    protected void addComponents()\n    {\n        add(Box.createRigidArea(new Dimension(188, 5)));\n        add(panelSize);\n        add(Box.createRigidArea(new Dimension(188, 5)));\n        add(panelPosition);\n    }\n    @Override\n    public void updateValues(Element cube)\n    {\n        panelSize.updateValues(cube);\n        panelPosition.updateValues(cube);\n    }\n"]]}
{"hexsha": "894995dc2211b293e6e3d532e03565e16d032060", "ext": "java", "lang": "Java", "content": "public class AugmentedStmtGraph implements DirectedGraph\n{\n    private HashMap binding, original2clone;\n    private IterableSet aug_list, stmt_list;\n    private List bheads, btails, cheads, ctails;\n\n\n    public AugmentedStmtGraph( AugmentedStmtGraph other)\n    {\n\tthis();\n\n\tHashMap old2new = new HashMap();\n\n\tIterator it = other.aug_list.iterator();\n\twhile (it.hasNext()) {\n\t    AugmentedStmt oas = (AugmentedStmt) it.next();\n\t    Stmt s = oas.get_Stmt();\n\n\t    AugmentedStmt nas = new AugmentedStmt( s);\n\t    aug_list.add( nas);\n\t    stmt_list.add( s);\n\t    binding.put( s, nas);\n\n\t    old2new.put( oas, nas);\n\t}\n\n\t\n\tit = other.aug_list.iterator();\n\twhile (it.hasNext()) {\n\t    AugmentedStmt oas = (AugmentedStmt) it.next();\n\t    AugmentedStmt nas = (AugmentedStmt) old2new.get( oas);\n\n\t    Iterator pit = oas.bpreds.iterator();\n\t    while (pit.hasNext())\n\t\tnas.bpreds.add( old2new.get( pit.next()));\n\t    if (nas.bpreds.isEmpty())\n\t\tbheads.add( nas);\n\n\t    pit = oas.cpreds.iterator();\n\t    while (pit.hasNext())\n\t\tnas.cpreds.add( old2new.get( pit.next()));\n\t    if (nas.cpreds.isEmpty())\n\t\tcheads.add( nas);\n\n\t    Iterator sit = oas.bsuccs.iterator();\n\t    while (sit.hasNext())\n\t\tnas.bsuccs.add( old2new.get( sit.next()));\n\t    if (nas.bsuccs.isEmpty())\n\t\tbtails.add( nas);\n\n\t    sit = oas.csuccs.iterator();\n\t    while (sit.hasNext())\n\t\tnas.csuccs.add( old2new.get( sit.next()));\n\t    if (nas.csuccs.isEmpty())\n\t\tctails.add( nas);\n\t}\n\n\tfind_Dominators();\n    }\n   \n    public AugmentedStmtGraph( BriefUnitGraph bug, TrapUnitGraph cug)\n    {\n\tthis();\n\n\tDava.v().log( \"AugmentedStmtGraph::AugmentedStmtGraph() - cug.size() = \" + cug.size());\n\n\t// make the augmented statements\n\tIterator it = cug.iterator();\n\twhile (it.hasNext()) {\n\t    Stmt s = (Stmt) it.next();\n\t    add_StmtBinding( s, new AugmentedStmt( s));\n\t}\n\n\t// make the list of augmented statements in pseudo topological order!\n        it = (new PseudoTopologicalOrderer()).newList( cug, false ).iterator();\n\twhile (it.hasNext()) {\n\t    Stmt s = (Stmt) it.next();\n\t    aug_list.add( get_AugStmt( s));\n\t    stmt_list.add( s);\n\t}\n\n\t// now that we've got all the augmented statements, mirror the statement graph\n\tit = aug_list.iterator();\n\twhile (it.hasNext()) {\n\t    AugmentedStmt as = (AugmentedStmt) it.next();\n\t    \n\t    mirror_PredsSuccs( as, bug);\n\t    mirror_PredsSuccs( as, cug);\n\t}\n\n\tfind_Dominators();\n    }\n\n    public AugmentedStmtGraph()\n    {\n        binding  = new HashMap();\n\toriginal2clone = new HashMap();\n\taug_list = new IterableSet();\n\tstmt_list = new IterableSet();\n\n\tbheads = new LinkedList();\n\tbtails = new LinkedList();\n\tcheads = new LinkedList();\n\tctails = new LinkedList();\n    }\n\n    public void add_AugmentedStmt( AugmentedStmt as)\n    {\n\tStmt s = as.get_Stmt();\n\n\taug_list.add( as);\n\tstmt_list.add( s);\n\t\n\tadd_StmtBinding( s, as);\n\n\tif (as.bpreds.isEmpty())\n\t    bheads.add( as);\n\t\n\tif (as.cpreds.isEmpty())\n\t    cheads.add( as);\n\t\n\tif (as.bsuccs.isEmpty())\n\t    btails.add( as);\n\t\n\tif (as.csuccs.isEmpty())\n\t    ctails.add( as);\n\n\tcheck_List( as.bpreds, btails);\n\tcheck_List( as.bsuccs, bheads);\n\tcheck_List( as.cpreds, ctails);\n\tcheck_List( as.csuccs, cheads);\n    }\n\n    public boolean contains( Object o)\n    {\n\treturn aug_list.contains( o);\n    }\n\n    public AugmentedStmt get_CloneOf( AugmentedStmt as)\n    {\n\treturn (AugmentedStmt) original2clone.get( as);\n    }\n\n    public int size()\n    {\n\treturn aug_list.size();\n    }\n\n    private void check_List( List psList, List htList)\n    {\n\tIterator it = psList.iterator();\n\twhile (it.hasNext()) {\n\t    Object o = it.next();\n\n\t    if (htList.contains( o))\n\t\thtList.remove(o);\n\t}\n    }\n\n\n    public void calculate_Reachability( AugmentedStmt source, HashSet blockers, AugmentedStmt dominator)\n    {\n\tif (blockers == null)\n\t    throw new RuntimeException( \"Tried to call AugmentedStmtGraph:calculate_Reachability() with null blockers.\");\n\n\tif (source == null)\n\t    return;\n\n\tLinkedList<AugmentedStmt> worklist = new LinkedList<AugmentedStmt>();\n\tHashSet<AugmentedStmt> touchSet = new HashSet<AugmentedStmt>();\n\t\n\tworklist.addLast( source);\n\ttouchSet.add( source);\n\t\n\twhile (worklist.isEmpty() == false) {\n\t    AugmentedStmt as = worklist.removeFirst();\n\t    \n\t    Iterator sit = as.csuccs.iterator();\n\t    while (sit.hasNext()) {\n\t\tAugmentedStmt sas = (AugmentedStmt) sit.next();\n\t\t\n\t\tif ((touchSet.contains( sas)) || (sas.get_Dominators().contains( dominator) == false))\n\t\t    continue;\n\t\t\n\t\ttouchSet.add( sas);\n\t\t\n\t\tIterableSet reachers = sas.get_Reachers();\n\t\t\n\t\tif (reachers.contains( source) == false)\n\t\t    reachers.add( source);\n\t\t\n\t\tif (blockers.contains( sas) == false)\n\t\t    worklist.addLast( sas);\n\t    }\n\t}\n    }\n\n    public void calculate_Reachability( Collection sources, HashSet blockers, AugmentedStmt dominator)\n    {\n\tIterator srcIt = sources.iterator();\n\twhile (srcIt.hasNext())\n\t    calculate_Reachability( (AugmentedStmt) srcIt.next(), blockers, dominator);\n    }\n\n    public void calculate_Reachability( AugmentedStmt source, AugmentedStmt blocker, AugmentedStmt dominator)\n    {\n\tHashSet h = new HashSet();\n\n\th.add( blocker);\n\n\tcalculate_Reachability( source, h, dominator);\n    }\n    \n    public void calculate_Reachability( Collection sources, AugmentedStmt blocker, AugmentedStmt dominator)\n    {\n\tHashSet h = new HashSet();\n\t\n\th.add( blocker);\n\t\n\tcalculate_Reachability( sources, h, dominator);\n    }\n\n    public void calculate_Reachability( AugmentedStmt source, AugmentedStmt dominator)\n    {\n\tcalculate_Reachability( source, new HashSet(), dominator);\n    }\n\n    public void calculate_Reachability( Collection sources, AugmentedStmt dominator)\n    {\n\tcalculate_Reachability( sources, new HashSet(), dominator);\n    }\n\n    public void calculate_Reachability( AugmentedStmt source)\n    {\n\tcalculate_Reachability( source, null);\n    }\n\n    public void calculate_Reachability( Collection sources)\n    {\n\tcalculate_Reachability( sources, null);\n    }\n\n    public void add_StmtBinding( Stmt s, AugmentedStmt as)\n    {\n\tbinding.put( s, as);\n    }\n\n    public AugmentedStmt get_AugStmt( Stmt s)\n    {\n\tAugmentedStmt as = (AugmentedStmt) binding.get( s);\n\tif (as == null)\n\t    throw new RuntimeException( \"Could not find augmented statement for: \" + s.toString());\n\n\treturn as;\n    }\n\n\n    // now put in the methods to satisfy the DirectedGraph interface\n\n    public List getHeads()\n    {\n\treturn cheads;\n    }\n\n    public List getTails()\n    {\n\treturn ctails;\n    }\n\n    public Iterator iterator()\n    {\n\treturn aug_list.iterator();\n    }\n\n    public List getPredsOf( Object s)\n    {\n\tif (s instanceof AugmentedStmt)\n\t    return ((AugmentedStmt) s).cpreds;\n\telse if (s instanceof Stmt)\n\t    return get_AugStmt((Stmt) s).cpreds;\n\telse\n\t    throw new RuntimeException( \"Object \" + s + \" class: \" + s.getClass() + \" not a member of this AugmentedStmtGraph\");\n    }\n\n    public List getSuccsOf( Object s)\n    {\n\tif (s instanceof AugmentedStmt)\n\t    return ((AugmentedStmt) s).csuccs;\n\telse if (s instanceof Stmt)\n\t    return get_AugStmt((Stmt) s).csuccs;\n\telse\n\t    throw new RuntimeException( \"Object \" + s + \" class: \" + s.getClass() + \" not a member of this AugmentedStmtGraph\");\n    }\n    \n    // end of methods satisfying DirectedGraph\n\n    public List get_BriefHeads()\n    {\n\treturn bheads;\n    }\n\n    public List get_BriefTails()\n    {\n\treturn btails;\n    }\n\n    public IterableSet get_ChainView()\n    {\n\tIterableSet c = new IterableSet();\n\n\tc.addAll( aug_list);\n\treturn c;\n    }\n\n    public Object clone()\n    {\n\treturn new AugmentedStmtGraph( this);\n    }\n\n    public boolean remove_AugmentedStmt( AugmentedStmt toRemove)\n    {\n\tif (aug_list.contains( toRemove) == false)\n\t    return false;\n\t\n\tIterator pit = toRemove.bpreds.iterator();\n\twhile (pit.hasNext()) {\n\t    AugmentedStmt pas = (AugmentedStmt) pit.next();\n\t    if (pas.bsuccs.contains( toRemove))\n\t\tpas.bsuccs.remove( toRemove);\n\t}\n\n\tpit = toRemove.cpreds.iterator();\n\twhile (pit.hasNext()) {\n\t    AugmentedStmt pas = (AugmentedStmt) pit.next();\n\t    if (pas.csuccs.contains( toRemove))\n\t\tpas.csuccs.remove( toRemove);\n\t}\n\n\tIterator sit = toRemove.bsuccs.iterator();\n\twhile (sit.hasNext()) {\n\t    AugmentedStmt sas = (AugmentedStmt) sit.next();\n\t    if (sas.bpreds.contains( toRemove))\n\t\tsas.bpreds.remove( toRemove);\n\t}\n\n\tsit = toRemove.csuccs.iterator();\n\twhile (sit.hasNext()) {\n\t    AugmentedStmt sas = (AugmentedStmt) sit.next();\n\t    if (sas.cpreds.contains( toRemove))\n\t\tsas.cpreds.remove( toRemove);\n\t}\n\n\taug_list.remove( toRemove);\n\tstmt_list.remove( toRemove.get_Stmt());\n\n\tif (bheads.contains( toRemove))\n\t    bheads.remove( toRemove);\n\tif (btails.contains( toRemove))\n\t    btails.remove( toRemove);\n\tif (cheads.contains( toRemove))\n\t    cheads.remove( toRemove);\n\tif (ctails.contains( toRemove))\n\t    ctails.remove( toRemove);\n\t\n\tbinding.remove( toRemove.get_Stmt());\n\n\treturn true;\n\n\t// NOTE: we do *NOT* touch the underlying unit graphs.\n    }\n\n    public String toString()\n    {\n\tStringBuffer b = new StringBuffer();\n\tString cr = \"\\n\";\n\n\tb.append( \"AugmentedStmtGraph (size: \" + size() + \" stmts)\" + cr);\n\n\tIterator it = aug_list.iterator();\n\twhile (it.hasNext()) {\n\t    AugmentedStmt as = (AugmentedStmt) it.next();\n\n\t    b.append( \"| .---\" + cr + \"| | AugmentedStmt \" + as.toString() + cr + \"| |\" + cr + \"| |  preds:\");\n\n\t    Iterator pit = as.cpreds.iterator();\n\t    while (pit.hasNext()) {\n\t\tAugmentedStmt pas = (AugmentedStmt) pit.next();\n\n\t\tb.append( \" \" + pas.toString());\n\t    }\n\n\t    b.append( cr + \"| |\" + cr + \"| |  succs:\");\n\t    Iterator sit = as.csuccs.iterator();\n\t    while (sit.hasNext()) {\n\t\tAugmentedStmt sas = (AugmentedStmt) sit.next();\n\n\t\tb.append( \" \" + sas.toString());\n\t    }\n\n\t    b.append( cr + \"| |\" + cr + \"| |  doms:\");\n\t    Iterator dit = as.get_Dominators().iterator();\n\t    while (dit.hasNext()) {\n\t\tAugmentedStmt das = (AugmentedStmt) dit.next();\n\n\t\tb.append( \" \" + das.toString());\n\t    }\n\n\t    b.append( cr + \"| `---\" + cr);\n\t}\n\n\tb.append( \"-\" + cr);\n\treturn b.toString();\n    }\n\n\n    private void mirror_PredsSuccs( AugmentedStmt as, UnitGraph ug)\n    {\n\tStmt s = as.get_Stmt();\n\n\tLinkedList \n\t    preds = new LinkedList(),\n\t    succs = new LinkedList();\n\t\n\t// mirror the predecessors\n\tIterator pit = ug.getPredsOf( s).iterator();\n\twhile (pit.hasNext()) {\n\t    Object po = get_AugStmt( (Stmt) pit.next());\n\t    if (preds.contains( po) == false)\n\t\tpreds.add( po);\n\t}\n\n\t// mirror the successors\n\tIterator sit = ug.getSuccsOf( s).iterator();\n\twhile (sit.hasNext()) {\n\t    Object so = get_AugStmt( (Stmt) sit.next());\n\t    if (succs.contains( so) == false)\n\t\tsuccs.add( so);\n\t}\n\n\t// attach the mirrors properly to the AugmentedStmt\n\tif (ug instanceof BriefUnitGraph) {\n\t    as.bpreds = preds;\n\t    as.bsuccs = succs;\n\n\t    if (preds.size() == 0)\n\t\tbheads.add( as);\n\t    if (succs.size() == 0)\n\t\tbtails.add( as);\n\t}\n\telse if (ug instanceof TrapUnitGraph) {\n\t    as.cpreds = preds;\n\t    as.csuccs = succs;\n\n\t    if (preds.size() == 0)\n\t\tcheads.add( as);\n\t    if (succs.size() == 0)\n\t\tctails.add( as);\n\t}\n\telse throw new RuntimeException( \"Unknown UnitGraph type: \" + ug.getClass());\n    }\n\n\n    public IterableSet clone_Body( IterableSet oldBody)\n    {\n\tHashMap \n\t    old2new = new HashMap(),\n\t    new2old = new HashMap();\n\t\n\tIterableSet newBody = new IterableSet();\n\n\tIterator it = oldBody.iterator();\n\twhile (it.hasNext()) {\n\t    AugmentedStmt as = (AugmentedStmt) it.next();\n\t    AugmentedStmt clone = (AugmentedStmt) as.clone();\n\n\t    original2clone.put( as, clone);\n\n\t    old2new.put( as, clone);\n\t    new2old.put( clone, as);\n\t    newBody.add( clone);\n\t}\n\n\tit = newBody.iterator();\n\twhile (it.hasNext()) {\n\t    AugmentedStmt newAs = (AugmentedStmt) it.next();\n\t    AugmentedStmt oldAs = (AugmentedStmt) new2old.get( newAs);\n\n\t    mirror_PredsSuccs( oldAs, oldAs.bpreds, newAs.bpreds, old2new);\n\t    mirror_PredsSuccs( oldAs, oldAs.cpreds, newAs.cpreds, old2new);\n\t    mirror_PredsSuccs( oldAs, oldAs.bsuccs, newAs.bsuccs, old2new);\n\t    mirror_PredsSuccs( oldAs, oldAs.csuccs, newAs.csuccs, old2new);\n\t}\n\n\tit = newBody.iterator();\n\twhile (it.hasNext()) \n\t    add_AugmentedStmt( (AugmentedStmt) it.next());\n\n\tHashMap<Stmt, Stmt> so2n = new HashMap<Stmt, Stmt>();\n\n\tit = oldBody.iterator();\n\twhile (it.hasNext()) {\n\t    AugmentedStmt as = (AugmentedStmt) it.next();\n\t    \n\t    Stmt os = as.get_Stmt();\n\t    Stmt ns = ((AugmentedStmt) old2new.get( as)).get_Stmt();\n\n\t    so2n.put( os, ns);\n\t}\n\n\tit = newBody.iterator();\n\twhile (it.hasNext()) {\n\t    AugmentedStmt nas = (AugmentedStmt) it.next();\n\t    AugmentedStmt oas = (AugmentedStmt) new2old.get( nas);\n\t    \t    \n\t    Stmt \n\t\tns = nas.get_Stmt(),\n\t\tos = oas.get_Stmt();\n\n\t    if (os instanceof IfStmt) {\n\t\tUnit \n\t\t    target = ((IfStmt) os).getTarget(),\n\t\t    newTgt = null;\n\n\t\tif ((newTgt = so2n.get( target)) != null)\n\t\t    ((IfStmt) ns).setTarget( newTgt);\n\t\telse\n\t\t    ((IfStmt) ns).setTarget( target);\n\t    }\n\n\t    else if (os instanceof TableSwitchStmt) {\n\t\tTableSwitchStmt \n\t\t    otss = (TableSwitchStmt) os,\n\t\t    ntss = (TableSwitchStmt) ns;\n\n\t\tUnit\n\t\t    target = otss.getDefaultTarget(),\n\t\t    newTgt = null;\n\n\t\tif ((newTgt = so2n.get( target)) != null)\n\t\t    ntss.setDefaultTarget( newTgt);\n\t\telse\n\t\t    ntss.setDefaultTarget( target);\n\t\t\n\t\tLinkedList<Unit> new_target_list = new LinkedList<Unit>();\n\t\t\n\t\tint target_count = otss.getHighIndex() - otss.getLowIndex() + 1;\n\t\tfor (int i=0; i<target_count; i++) {\n\t\t    target = otss.getTarget(i);\n\t\t    newTgt = null;\n\n\t\t    if ((newTgt = so2n.get( target)) != null)\n\t\t\tnew_target_list.add( newTgt);\n\t\t    else\n\t\t\tnew_target_list.add( target);\n\t\t}\n\t\tntss.setTargets( new_target_list);\n\t    }\n\n\t    else if (os instanceof LookupSwitchStmt) {\n\t\tLookupSwitchStmt \n\t\t    olss = (LookupSwitchStmt) os,\n\t\t    nlss = (LookupSwitchStmt) ns;\n\n\t\tUnit\n\t\t    target = olss.getDefaultTarget(),\n\t\t    newTgt = null;\n\n\t\tif ((newTgt = so2n.get( target)) != null)\n\t\t    nlss.setDefaultTarget( newTgt);\n\t\telse\n\t\t    nlss.setDefaultTarget( target);\n\t\t\n\t\tUnit[] new_target_list = new Unit[ olss.getTargetCount()];\n\t\t\n\t\tfor (int i=0; i<new_target_list.length; i++) {\n\t\t    target = olss.getTarget(i);\n\t\t    newTgt = null;\n\n\t\t    if ((newTgt = so2n.get( target)) != null)\n\t\t\tnew_target_list[i] = newTgt;\n\t\t    else\n\t\t\tnew_target_list[i] = target;\n\t\t}\n\t\tnlss.setTargets( new_target_list);\n\t\tnlss.setLookupValues( olss.getLookupValues());\n\t    }\n\t}\n\t\n\treturn newBody;\n    }\n\n    private void mirror_PredsSuccs( AugmentedStmt originalAs, List oldList, List newList, Map old2new)\n    {\n\tIterator it = oldList.iterator();\n\twhile (it.hasNext()) {\n\t    AugmentedStmt oldAs = (AugmentedStmt) it.next();\n\t    AugmentedStmt newAs = (AugmentedStmt) old2new.get( oldAs);\n\t    \n\t    if (newAs != null)\n\t\tnewList.add( newAs);\n\n\t    else {\n\t\tnewList.add( oldAs);\n\t\t\n\t\tAugmentedStmt clonedAs = (AugmentedStmt) old2new.get( originalAs);\n\n\t\tif (oldList == originalAs.bpreds)\n\t\t    oldAs.bsuccs.add( clonedAs);\n\t\telse if (oldList == originalAs.cpreds)\n\t\t    oldAs.csuccs.add( clonedAs);\n\t\telse if (oldList == originalAs.bsuccs)\n\t\t    oldAs.bpreds.add( clonedAs);\n\t\telse if (oldList == originalAs.csuccs)\n\t\t    oldAs.cpreds.add( clonedAs);\n\t\telse \n\t\t    throw new RuntimeException( \"Error mirroring preds and succs in Try block splitting.\");\n\t    }\n\t}\n    }\n\n\n    public void find_Dominators()\n    {\n\t// set up the dominator sets for all the nodes in the graph\n\tIterator asgit = aug_list.iterator();\n\twhile (asgit.hasNext()) {\n\t    AugmentedStmt as = (AugmentedStmt) asgit.next();\n\n\t    // Dominators:\n\t    // safe starting approximation for S(0) ... empty set\n\t    // unsafe starting approximation for S(i) .. full set\n\t    if (as.cpreds.size() != 0) {\n\n\t\tif (as.get_Dominators().isEmpty() == false)\n\t\t    as.get_Dominators().clear();\n\n\t\tas.get_Dominators().addAll( aug_list);\n\t    }\n\t    else \n\t\tas.get_Dominators().clear();\n\t}\n\n\t// build the worklist\n\tIterableSet worklist = new IterableSet();\n\tworklist.addAll( aug_list);\n\n\t// keep going until the worklist is empty\n\twhile (worklist.isEmpty() == false) {\n\t    AugmentedStmt as = (AugmentedStmt) worklist.getFirst();\n\t    worklist.removeFirst();\n\t    \n\t    IterableSet pred_intersection = new IterableSet();\n\t    boolean first_pred = true;\n\n\t    // run through all the predecessors and get their dominance intersection\n\t    Iterator pit = as.cpreds.iterator();\n\t    while (pit.hasNext()) {\n\t\tAugmentedStmt pas = (AugmentedStmt) pit.next();\n\t\t\n\t\t// for the first predecessor just take all his dominators\n\t\tif (first_pred) {\n\t\t    pred_intersection.addAll( pas.get_Dominators());\n\t\t    if (pred_intersection.contains( pas) == false)\n\t\t\tpred_intersection.add( pas);\n\t\t    first_pred = false;\n\t\t}\n\n\t\t// for the subsequent predecessors remove the ones they do not have from the intersection\n\t\telse {\n\t\t    Iterator piit = pred_intersection.snapshotIterator();\n\t\t    while (piit.hasNext()) {\n\t\t\tAugmentedStmt pid = (AugmentedStmt) piit.next();\n\n\t\t\tif ((pas.get_Dominators().contains( pid) == false) && (pas != pid))\n\t\t\t    pred_intersection.remove( pid);\n\t\t    }\n\t\t}\n\t    }\n\n\t    // update dominance if we have a change\n\t    if (as.get_Dominators().equals( pred_intersection) == false) {\n\t\tIterator sit = as.csuccs.iterator();\n\t\twhile (sit.hasNext()) {\n\t\t    Object o = sit.next();\n\n\t\t    if (worklist.contains( o) == false)\n\t\t\tworklist.add( o);\n\t\t}\n\n\t\tas.get_Dominators().clear();\n\t\tas.get_Dominators().addAll( pred_intersection);\n\t    }\n\t}\n    }\n}", "class_id": 0, "repo": "dongy6/type-inference", "file": "ICC/SOOT-Nightly/soot-github/src/soot/dava/internal/asg/AugmentedStmtGraph.java", "last_update_at": "2019-12-07T16:13:03+00:00", "question_id": "894995dc2211b293e6e3d532e03565e16d032060", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AugmentedStmtGraph implements DirectedGraph\n{\n    private HashMap binding, original2clone;\n    private IterableSet aug_list, stmt_list;\n    private List bheads, btails, cheads, ctails;\n    public AugmentedStmtGraph( AugmentedStmtGraph other)\n    {\n\tthis();\n\tHashMap old2new = new HashMap();\n\tIterator it = other.aug_list.iterator();\n\twhile (it.hasNext()) {\n\t    AugmentedStmt oas = (AugmentedStmt) it.next();\n\t    Stmt s = oas.get_Stmt();\n\t    AugmentedStmt nas = new AugmentedStmt( s);\n\t    aug_list.add( nas);\n\t    stmt_list.add( s);\n\t    binding.put( s, nas);\n\t    old2new.put( oas, nas);\n\t}\n\t\n\tit = other.aug_list.iterator();\n\twhile (it.hasNext()) {\n\t    AugmentedStmt oas = (AugmentedStmt) it.next();\n\t    AugmentedStmt nas = (AugmentedStmt) old2new.get( oas);\n\t    Iterator pit = oas.bpreds.iterator();\n\t    while (pit.hasNext())\n\t\tnas.bpreds.add( old2new.get( pit.next()));\n\t    if (nas.bpreds.isEmpty())\n\t\tbheads.add( nas);\n\t    pit = oas.cpreds.iterator();\n\t    while (pit.hasNext())\n\t\tnas.cpreds.add( old2new.get( pit.next()));\n\t    if (nas.cpreds.isEmpty())\n\t\tcheads.add( nas);\n\t    Iterator sit = oas.bsuccs.iterator();\n\t    while (sit.hasNext())\n\t\tnas.bsuccs.add( old2new.get( sit.next()));\n\t    if (nas.bsuccs.isEmpty())\n\t\tbtails.add( nas);\n\t    sit = oas.csuccs.iterator();\n\t    while (sit.hasNext())\n\t\tnas.csuccs.add( old2new.get( sit.next()));\n\t    if (nas.csuccs.isEmpty())\n\t\tctails.add( nas);\n\t}\n\tfind_Dominators();\n    }\n    public AugmentedStmtGraph( BriefUnitGraph bug, TrapUnitGraph cug)\n    {\n\tthis();\n\tDava.v().log( \"AugmentedStmtGraph::AugmentedStmtGraph() - cug.size() = \" + cug.size());\n\t// make the augmented statements\n\tIterator it = cug.iterator();\n\twhile (it.hasNext()) {\n\t    Stmt s = (Stmt) it.next();\n\t    add_StmtBinding( s, new AugmentedStmt( s));\n\t}\n\t// make the list of augmented statements in pseudo topological order!\n        it = (new PseudoTopologicalOrderer()).newList( cug, false ).iterator();\n\twhile (it.hasNext()) {\n\t    Stmt s = (Stmt) it.next();\n\t    aug_list.add( get_AugStmt( s));\n\t    stmt_list.add( s);\n\t}\n\t// now that we've got all the augmented statements, mirror the statement graph\n\tit = aug_list.iterator();\n\twhile (it.hasNext()) {\n\t    AugmentedStmt as = (AugmentedStmt) it.next();\n\t    \n\t    mirror_PredsSuccs( as, bug);\n\t    mirror_PredsSuccs( as, cug);\n\t}\n\tfind_Dominators();\n    }\n    public AugmentedStmtGraph()\n    {\n        binding  = new HashMap();\n\toriginal2clone = new HashMap();\n\taug_list = new IterableSet();\n\tstmt_list = new IterableSet();\n\tbheads = new LinkedList();\n\tbtails = new LinkedList();\n\tcheads = new LinkedList();\n\tctails = new LinkedList();\n    }\n    public void add_AugmentedStmt( AugmentedStmt as)\n    {\n\tStmt s = as.get_Stmt();\n\taug_list.add( as);\n\tstmt_list.add( s);\n\t\n\tadd_StmtBinding( s, as);\n\tif (as.bpreds.isEmpty())\n\t    bheads.add( as);\n\t\n\tif (as.cpreds.isEmpty())\n\t    cheads.add( as);\n\t\n\tif (as.bsuccs.isEmpty())\n\t    btails.add( as);\n\t\n\tif (as.csuccs.isEmpty())\n\t    ctails.add( as);\n\tcheck_List( as.bpreds, btails);\n\tcheck_List( as.bsuccs, bheads);\n\tcheck_List( as.cpreds, ctails);\n\tcheck_List( as.csuccs, cheads);\n    }\n    public boolean contains( Object o)\n    {\n\treturn aug_list.contains( o);\n    }\n    public AugmentedStmt get_CloneOf( AugmentedStmt as)\n    {\n\treturn (AugmentedStmt) original2clone.get( as);\n    }\n    public int size()\n    {\n\treturn aug_list.size();\n    }\n    private void check_List( List psList, List htList)\n    {\n\tIterator it = psList.iterator();\n\twhile (it.hasNext()) {\n\t    Object o = it.next();\n\t    if (htList.contains( o))\n\t\thtList.remove(o);\n\t}\n    }\n    public void calculate_Reachability( AugmentedStmt source, HashSet blockers, AugmentedStmt dominator)\n    {\n\tif (blockers == null)\n\t    throw new RuntimeException( \"Tried to call AugmentedStmtGraph:calculate_Reachability() with null blockers.\");\n\tif (source == null)\n\t    return;\n\tLinkedList<AugmentedStmt> worklist = new LinkedList<AugmentedStmt>();\n\tHashSet<AugmentedStmt> touchSet = new HashSet<AugmentedStmt>();\n\t\n\tworklist.addLast( source);\n\ttouchSet.add( source);\n\t\n\twhile (worklist.isEmpty() == false) {\n\t    AugmentedStmt as = worklist.removeFirst();\n\t    \n\t    Iterator sit = as.csuccs.iterator();\n\t    while (sit.hasNext()) {\n\t\tAugmentedStmt sas = (AugmentedStmt) sit.next();\n\t\t\n\t\tif ((touchSet.contains( sas)) || (sas.get_Dominators().contains( dominator) == false))\n\t\t    continue;\n\t\t\n\t\ttouchSet.add( sas);\n\t\t\n\t\tIterableSet reachers = sas.get_Reachers();\n\t\t\n\t\tif (reachers.contains( source) == false)\n\t\t    reachers.add( source);\n\t\t\n\t\tif (blockers.contains( sas) == false)\n\t\t    worklist.addLast( sas);\n\t    }\n\t}\n    }\n    public void calculate_Reachability( Collection sources, HashSet blockers, AugmentedStmt dominator)\n    {\n\tIterator srcIt = sources.iterator();\n\twhile (srcIt.hasNext())\n\t    calculate_Reachability( (AugmentedStmt) srcIt.next(), blockers, dominator);\n    }\n    public void calculate_Reachability( AugmentedStmt source, AugmentedStmt blocker, AugmentedStmt dominator)\n    {\n\tHashSet h = new HashSet();\n\th.add( blocker);\n\tcalculate_Reachability( source, h, dominator);\n    }\n    public void calculate_Reachability( Collection sources, AugmentedStmt blocker, AugmentedStmt dominator)\n    {\n\tHashSet h = new HashSet();\n\t\n\th.add( blocker);\n\t\n\tcalculate_Reachability( sources, h, dominator);\n    }\n    public void calculate_Reachability( AugmentedStmt source, AugmentedStmt dominator)\n    {\n\tcalculate_Reachability( source, new HashSet(), dominator);\n    }\n    public void calculate_Reachability( Collection sources, AugmentedStmt dominator)\n    {\n\tcalculate_Reachability( sources, new HashSet(), dominator);\n    }\n    public void calculate_Reachability( AugmentedStmt source)\n    {\n\tcalculate_Reachability( source, null);\n    }\n    public void calculate_Reachability( Collection sources)\n    {\n\tcalculate_Reachability( sources, null);\n    }\n    public void add_StmtBinding( Stmt s, AugmentedStmt as)\n    {\n\tbinding.put( s, as);\n    }\n    public AugmentedStmt get_AugStmt( Stmt s)\n    {\n\tAugmentedStmt as = (AugmentedStmt) binding.get( s);\n\tif (as == null)\n\t    throw new RuntimeException( \"Could not find augmented statement for: \" + s.toString());\n\treturn as;\n    }\n    // now put in the methods to satisfy the DirectedGraph interface\n    public List getHeads()\n    {\n\treturn cheads;\n    }\n    public List getTails()\n    {\n\treturn ctails;\n    }\n    public Iterator iterator()\n    {\n\treturn aug_list.iterator();\n    }\n    public List getPredsOf( Object s)\n    {\n\tif (s instanceof AugmentedStmt)\n\t    return ((AugmentedStmt) s).cpreds;\n\telse if (s instanceof Stmt)\n\t    return get_AugStmt((Stmt) s).cpreds;\n\telse\n\t    throw new RuntimeException( \"Object \" + s + \" class: \" + s.getClass() + \" not a member of this AugmentedStmtGraph\");\n    }\n    public List getSuccsOf( Object s)\n    {\n\tif (s instanceof AugmentedStmt)\n\t    return ((AugmentedStmt) s).csuccs;\n\telse if (s instanceof Stmt)\n\t    return get_AugStmt((Stmt) s).csuccs;\n\telse\n\t    throw new RuntimeException( \"Object \" + s + \" class: \" + s.getClass() + \" not a member of this AugmentedStmtGraph\");\n    }\n    // end of methods satisfying DirectedGraph\n    public List get_BriefHeads()\n    {\n\treturn bheads;\n    }\n    public List get_BriefTails()\n    {\n\treturn btails;\n    }\n    public IterableSet get_ChainView()\n    {\n\tIterableSet c = new IterableSet();\n\tc.addAll( aug_list);\n\treturn c;\n    }\n    public Object clone()\n    {\n\treturn new AugmentedStmtGraph( this);\n    }\n    public boolean remove_AugmentedStmt( AugmentedStmt toRemove)\n    {\n\tif (aug_list.contains( toRemove) == false)\n\t    return false;\n\t\n\tIterator pit = toRemove.bpreds.iterator();\n\twhile (pit.hasNext()) {\n\t    AugmentedStmt pas = (AugmentedStmt) pit.next();\n\t    if (pas.bsuccs.contains( toRemove))\n\t\tpas.bsuccs.remove( toRemove);\n\t}\n\tpit = toRemove.cpreds.iterator();\n\twhile (pit.hasNext()) {\n\t    AugmentedStmt pas = (AugmentedStmt) pit.next();\n\t    if (pas.csuccs.contains( toRemove))\n\t\tpas.csuccs.remove( toRemove);\n\t}\n\tIterator sit = toRemove.bsuccs.iterator();\n\twhile (sit.hasNext()) {\n\t    AugmentedStmt sas = (AugmentedStmt) sit.next();\n\t    if (sas.bpreds.contains( toRemove))\n\t\tsas.bpreds.remove( toRemove);\n\t}\n\tsit = toRemove.csuccs.iterator();\n\twhile (sit.hasNext()) {\n\t    AugmentedStmt sas = (AugmentedStmt) sit.next();\n\t    if (sas.cpreds.contains( toRemove))\n\t\tsas.cpreds.remove( toRemove);\n\t}\n\taug_list.remove( toRemove);\n\tstmt_list.remove( toRemove.get_Stmt());\n\tif (bheads.contains( toRemove))\n\t    bheads.remove( toRemove);\n\tif (btails.contains( toRemove))\n\t    btails.remove( toRemove);\n\tif (cheads.contains( toRemove))\n\t    cheads.remove( toRemove);\n\tif (ctails.contains( toRemove))\n\t    ctails.remove( toRemove);\n\t\n\tbinding.remove( toRemove.get_Stmt());\n\treturn true;\n\t// NOTE: we do *NOT* touch the underlying unit graphs.\n    }\n    public String toString()\n    {\n\tStringBuffer b = new StringBuffer();\n\tString cr = \"\\n\";\n\tb.append( \"AugmentedStmtGraph (size: \" + size() + \" stmts)\" + cr);\n\tIterator it = aug_list.iterator();\n\twhile (it.hasNext()) {\n\t    AugmentedStmt as = (AugmentedStmt) it.next();\n\t    b.append( \"| .---\" + cr + \"| | AugmentedStmt \" + as.toString() + cr + \"| |\" + cr + \"| |  preds:\");\n\t    Iterator pit = as.cpreds.iterator();\n\t    while (pit.hasNext()) {\n\t\tAugmentedStmt pas = (AugmentedStmt) pit.next();\n\t\tb.append( \" \" + pas.toString());\n\t    }\n\t    b.append( cr + \"| |\" + cr + \"| |  succs:\");\n\t    Iterator sit = as.csuccs.iterator();\n\t    while (sit.hasNext()) {\n\t\tAugmentedStmt sas = (AugmentedStmt) sit.next();\n\t\tb.append( \" \" + sas.toString());\n\t    }\n\t    b.append( cr + \"| |\" + cr + \"| |  doms:\");\n\t    Iterator dit = as.get_Dominators().iterator();\n\t    while (dit.hasNext()) {\n\t\tAugmentedStmt das = (AugmentedStmt) dit.next();\n\t\tb.append( \" \" + das.toString());\n\t    }\n\t    b.append( cr + \"| `---\" + cr);\n\t}\n\tb.append( \"-\" + cr);\n\treturn b.toString();\n    }\n    private void mirror_PredsSuccs( AugmentedStmt as, UnitGraph ug)\n    {\n\tStmt s = as.get_Stmt();\n\tLinkedList \n\t    preds = new LinkedList(),\n\t    succs = new LinkedList();\n\t\n\t// mirror the predecessors\n\tIterator pit = ug.getPredsOf( s).iterator();\n\twhile (pit.hasNext()) {\n\t    Object po = get_AugStmt( (Stmt) pit.next());\n\t    if (preds.contains( po) == false)\n\t\tpreds.add( po);\n\t}\n\t// mirror the successors\n\tIterator sit = ug.getSuccsOf( s).iterator();\n\twhile (sit.hasNext()) {\n\t    Object so = get_AugStmt( (Stmt) sit.next());\n\t    if (succs.contains( so) == false)\n\t\tsuccs.add( so);\n\t}\n\t// attach the mirrors properly to the AugmentedStmt\n\tif (ug instanceof BriefUnitGraph) {\n\t    as.bpreds = preds;\n\t    as.bsuccs = succs;\n\t    if (preds.size() == 0)\n\t\tbheads.add( as);\n\t    if (succs.size() == 0)\n\t\tbtails.add( as);\n\t}\n\telse if (ug instanceof TrapUnitGraph) {\n\t    as.cpreds = preds;\n\t    as.csuccs = succs;\n\t    if (preds.size() == 0)\n\t\tcheads.add( as);\n\t    if (succs.size() == 0)\n\t\tctails.add( as);\n\t}\n\telse throw new RuntimeException( \"Unknown UnitGraph type: \" + ug.getClass());\n    }\n    public IterableSet clone_Body( IterableSet oldBody)\n    {\n\tHashMap \n\t    old2new = new HashMap(),\n\t    new2old = new HashMap();\n\t\n\tIterableSet newBody = new IterableSet();\n\tIterator it = oldBody.iterator();\n\twhile (it.hasNext()) {\n\t    AugmentedStmt as = (AugmentedStmt) it.next();\n\t    AugmentedStmt clone = (AugmentedStmt) as.clone();\n\t    original2clone.put( as, clone);\n\t    old2new.put( as, clone);\n\t    new2old.put( clone, as);\n\t    newBody.add( clone);\n\t}\n\tit = newBody.iterator();\n\twhile (it.hasNext()) {\n\t    AugmentedStmt newAs = (AugmentedStmt) it.next();\n\t    AugmentedStmt oldAs = (AugmentedStmt) new2old.get( newAs);\n\t    mirror_PredsSuccs( oldAs, oldAs.bpreds, newAs.bpreds, old2new);\n\t    mirror_PredsSuccs( oldAs, oldAs.cpreds, newAs.cpreds, old2new);\n\t    mirror_PredsSuccs( oldAs, oldAs.bsuccs, newAs.bsuccs, old2new);\n\t    mirror_PredsSuccs( oldAs, oldAs.csuccs, newAs.csuccs, old2new);\n\t}\n\tit = newBody.iterator();\n\twhile (it.hasNext()) \n\t    add_AugmentedStmt( (AugmentedStmt) it.next());\n\tHashMap<Stmt, Stmt> so2n = new HashMap<Stmt, Stmt>();\n\tit = oldBody.iterator();\n\twhile (it.hasNext()) {\n\t    AugmentedStmt as = (AugmentedStmt) it.next();\n\t    \n\t    Stmt os = as.get_Stmt();\n\t    Stmt ns = ((AugmentedStmt) old2new.get( as)).get_Stmt();\n\t    so2n.put( os, ns);\n\t}\n\tit = newBody.iterator();\n\twhile (it.hasNext()) {\n\t    AugmentedStmt nas = (AugmentedStmt) it.next();\n\t    AugmentedStmt oas = (AugmentedStmt) new2old.get( nas);\n\t    \t    \n\t    Stmt \n\t\tns = nas.get_Stmt(),\n\t\tos = oas.get_Stmt();\n\t    if (os instanceof IfStmt) {\n\t\tUnit \n\t\t    target = ((IfStmt) os).getTarget(),\n\t\t    newTgt = null;\n\t\tif ((newTgt = so2n.get( target)) != null)\n\t\t    ((IfStmt) ns).setTarget( newTgt);\n\t\telse\n\t\t    ((IfStmt) ns).setTarget( target);\n\t    }\n\t    else if (os instanceof TableSwitchStmt) {\n\t\tTableSwitchStmt \n\t\t    otss = (TableSwitchStmt) os,\n\t\t    ntss = (TableSwitchStmt) ns;\n\t\tUnit\n\t\t    target = otss.getDefaultTarget(),\n\t\t    newTgt = null;\n\t\tif ((newTgt = so2n.get( target)) != null)\n\t\t    ntss.setDefaultTarget( newTgt);\n\t\telse\n\t\t    ntss.setDefaultTarget( target);\n\t\t\n\t\tLinkedList<Unit> new_target_list = new LinkedList<Unit>();\n\t\t\n\t\tint target_count = otss.getHighIndex() - otss.getLowIndex() + 1;\n\t\tfor (int i=0; i<target_count; i++) {\n\t\t    target = otss.getTarget(i);\n\t\t    newTgt = null;\n\t\t    if ((newTgt = so2n.get( target)) != null)\n\t\t\tnew_target_list.add( newTgt);\n\t\t    else\n\t\t\tnew_target_list.add( target);\n\t\t}\n\t\tntss.setTargets( new_target_list);\n\t    }\n\t    else if (os instanceof LookupSwitchStmt) {\n\t\tLookupSwitchStmt \n\t\t    olss = (LookupSwitchStmt) os,\n\t\t    nlss = (LookupSwitchStmt) ns;\n\t\tUnit\n\t\t    target = olss.getDefaultTarget(),\n\t\t    newTgt = null;\n\t\tif ((newTgt = so2n.get( target)) != null)\n\t\t    nlss.setDefaultTarget( newTgt);\n\t\telse\n\t\t    nlss.setDefaultTarget( target);\n\t\t\n\t\tUnit[] new_target_list = new Unit[ olss.getTargetCount()];\n\t\t\n\t\tfor (int i=0; i<new_target_list.length; i++) {\n\t\t    target = olss.getTarget(i);\n\t\t    newTgt = null;\n\t\t    if ((newTgt = so2n.get( target)) != null)\n\t\t\tnew_target_list[i] = newTgt;\n\t\t    else\n\t\t\tnew_target_list[i] = target;\n\t\t}\n\t\tnlss.setTargets( new_target_list);\n\t\tnlss.setLookupValues( olss.getLookupValues());\n\t    }\n\t}\n\t\n\treturn newBody;\n    }\n    private void mirror_PredsSuccs( AugmentedStmt originalAs, List oldList, List newList, Map old2new)\n    {\n\tIterator it = oldList.iterator();\n\twhile (it.hasNext()) {\n\t    AugmentedStmt oldAs = (AugmentedStmt) it.next();\n\t    AugmentedStmt newAs = (AugmentedStmt) old2new.get( oldAs);\n\t    \n\t    if (newAs != null)\n\t\tnewList.add( newAs);\n\t    else {\n\t\tnewList.add( oldAs);\n\t\t\n\t\tAugmentedStmt clonedAs = (AugmentedStmt) old2new.get( originalAs);\n\t\tif (oldList == originalAs.bpreds)\n\t\t    oldAs.bsuccs.add( clonedAs);\n\t\telse if (oldList == originalAs.cpreds)\n\t\t    oldAs.csuccs.add( clonedAs);\n\t\telse if (oldList == originalAs.bsuccs)\n\t\t    oldAs.bpreds.add( clonedAs);\n\t\telse if (oldList == originalAs.csuccs)\n\t\t    oldAs.cpreds.add( clonedAs);\n\t\telse \n\t\t    throw new RuntimeException( \"Error mirroring preds and succs in Try block splitting.\");\n\t    }\n\t}\n    }\n    public void find_Dominators()\n    {\n\t// set up the dominator sets for all the nodes in the graph\n\tIterator asgit = aug_list.iterator();\n\twhile (asgit.hasNext()) {\n\t    AugmentedStmt as = (AugmentedStmt) asgit.next();\n\t    // Dominators:\n\t    // safe starting approximation for S(0) ... empty set\n\t    // unsafe starting approximation for S(i) .. full set\n\t    if (as.cpreds.size() != 0) {\n\t\tif (as.get_Dominators().isEmpty() == false)\n\t\t    as.get_Dominators().clear();\n\t\tas.get_Dominators().addAll( aug_list);\n\t    }\n\t    else \n\t\tas.get_Dominators().clear();\n\t}\n\t// build the worklist\n\tIterableSet worklist = new IterableSet();\n\tworklist.addAll( aug_list);\n\t// keep going until the worklist is empty\n\twhile (worklist.isEmpty() == false) {\n\t    AugmentedStmt as = (AugmentedStmt) worklist.getFirst();\n\t    worklist.removeFirst();\n\t    \n\t    IterableSet pred_intersection = new IterableSet();\n\t    boolean first_pred = true;\n\t    // run through all the predecessors and get their dominance intersection\n\t    Iterator pit = as.cpreds.iterator();\n\t    while (pit.hasNext()) {\n\t\tAugmentedStmt pas = (AugmentedStmt) pit.next();\n\t\t\n\t\t// for the first predecessor just take all his dominators\n\t\tif (first_pred) {\n\t\t    pred_intersection.addAll( pas.get_Dominators());\n\t\t    if (pred_intersection.contains( pas) == false)\n\t\t\tpred_intersection.add( pas);\n\t\t    first_pred = false;\n\t\t}\n\t\t// for the subsequent predecessors remove the ones they do not have from the intersection\n\t\telse {\n\t\t    Iterator piit = pred_intersection.snapshotIterator();\n\t\t    while (piit.hasNext()) {\n\t\t\tAugmentedStmt pid = (AugmentedStmt) piit.next();\n\t\t\tif ((pas.get_Dominators().contains( pid) == false) && (pas != pid))\n\t\t\t    pred_intersection.remove( pid);\n\t\t    }\n\t\t}\n\t    }\n\t    // update dominance if we have a change\n\t    if (as.get_Dominators().equals( pred_intersection) == false) {\n\t\tIterator sit = as.csuccs.iterator();\n\t\twhile (sit.hasNext()) {\n\t\t    Object o = sit.next();\n\t\t    if (worklist.contains( o) == false)\n\t\t\tworklist.add( o);\n\t\t}\n\t\tas.get_Dominators().clear();\n\t\tas.get_Dominators().addAll( pred_intersection);\n\t    }\n\t}\n    }\n"]]}
{"hexsha": "2c4df6ebddadcb830114fa120fffbb89cec57c7f", "ext": "java", "lang": "Java", "content": "public class BenchmarkTest {\n\n   private static Dispatcher dispatcher;\n\n   @BeforeClass\n   public static void BeforeClass() {\n      dispatcher = MockDispatcherFactory.createDispatcher();\n      dispatcher.getRegistry().addPerRequestResource(HelloResource.class);\n   }\n\n   @Before\n   public void before() {\n      ResteasyContext.getContextDataMap().put(Configurable.class, dispatcher.getProviderFactory());\n   }\n\n   @Path(\"/hello\")\n   public static class HelloResource {\n      @GET\n      @Produces(\"text/plain\")\n      public String get() {\n         return \"hello world\";\n      }\n\n      @POST\n      @Produces(\"text/plain\")\n      @Consumes(\"text/plain\")\n      public String post(String name) {\n         return \"Hello \" + name;\n      }\n\n      @GET\n      @Path(\"{id}\")\n      @Produces(\"text/plain\")\n      public String getPath(@PathParam(\"id\") int id) {\n         return \"hello world \" + id;\n      }\n\n\n   }\n\n   private static final int ITERATIONS=1000000;\n\n   //@Test\n   public void runPathGet() {\n      long start = System.currentTimeMillis();\n      for (int i = 0; i < ITERATIONS; i++) {\n         testPathGet();\n      }\n      long end = System.currentTimeMillis() - start;\n      //System.out.println(\"Took \" + end);\n   }\n\n   public void testPathGet() {\n      MockHttpRequest request = MockHttpRequest.create(\"GET\", \"/hello/1\", \"\", \"\");\n      MockHttpResponse response = new MockHttpResponse();\n      dispatcher.invoke(request, response);\n\n   }\n   public void testPlainGet() {\n      MockHttpRequest request = MockHttpRequest.create(\"GET\", \"/hello\", \"\", \"\");\n      MockHttpResponse response = new MockHttpResponse();\n      dispatcher.invoke(request, response);\n\n   }\n   public void testPlainPost() {\n      MockHttpRequest request = MockHttpRequest.create(\"GET\", \"/hello\", \"\", \"\");\n      request.contentType(\"text/plain\").content(\"world\".getBytes());\n      MockHttpResponse response = new MockHttpResponse();\n      dispatcher.invoke(request, response);\n\n   }\n\n\n}", "class_id": 0, "repo": "gytis/Resteasy", "file": "testsuite/unit-tests/src/test/java/org/jboss/resteasy/test/resource/BenchmarkTest.java", "last_update_at": "2019-06-21T00:01:16+00:00", "question_id": "2c4df6ebddadcb830114fa120fffbb89cec57c7f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BenchmarkTest {\n   private static Dispatcher dispatcher;\n   @BeforeClass\n   public static void BeforeClass() {\n      dispatcher = MockDispatcherFactory.createDispatcher();\n      dispatcher.getRegistry().addPerRequestResource(HelloResource.class);\n   }\n   @Before\n   public void before() {\n      ResteasyContext.getContextDataMap().put(Configurable.class, dispatcher.getProviderFactory());\n   }\n   @Path(\"/hello\")\n   public static class HelloResource {\n      @GET\n      @Produces(\"text/plain\")\n      public String get() {\n         return \"hello world\";\n      }\n      @POST\n      @Produces(\"text/plain\")\n      @Consumes(\"text/plain\")\n      public String post(String name) {\n         return \"Hello \" + name;\n      }\n      @GET\n      @Path(\"{id}\")\n      @Produces(\"text/plain\")\n      public String getPath(@PathParam(\"id\") int id) {\n         return \"hello world \" + id;\n      }\n   }\n   private static final int ITERATIONS=1000000;\n   //@Test\n   public void runPathGet() {\n      long start = System.currentTimeMillis();\n      for (int i = 0; i < ITERATIONS; i++) {\n         testPathGet();\n      }\n      long end = System.currentTimeMillis() - start;\n      //System.out.println(\"Took \" + end);\n   }\n   public void testPathGet() {\n      MockHttpRequest request = MockHttpRequest.create(\"GET\", \"/hello/1\", \"\", \"\");\n      MockHttpResponse response = new MockHttpResponse();\n      dispatcher.invoke(request, response);\n   }\n   public void testPlainGet() {\n      MockHttpRequest request = MockHttpRequest.create(\"GET\", \"/hello\", \"\", \"\");\n      MockHttpResponse response = new MockHttpResponse();\n      dispatcher.invoke(request, response);\n   }\n   public void testPlainPost() {\n      MockHttpRequest request = MockHttpRequest.create(\"GET\", \"/hello\", \"\", \"\");\n      request.contentType(\"text/plain\").content(\"world\".getBytes());\n      MockHttpResponse response = new MockHttpResponse();\n      dispatcher.invoke(request, response);\n   }\n"]]}
{"hexsha": "84eee976f52695b87dca16bac04b65017ee3a4d4", "ext": "java", "lang": "Java", "content": "public class SimpleFragmentPagerAdapter extends FragmentPagerAdapter {\n    public boolean CHANGE_VISIBILITY = true;\n\n    public SimpleFragmentPagerAdapter(@NonNull FragmentManager fragmentManager) {\n        super(fragmentManager);\n    }\n\n    public SimpleFragmentPagerAdapter(@NonNull FragmentManager fragmentManager, @Nullable List<Page> pages) {\n        super(fragmentManager, pages);\n    }\n\n    @Nullable\n    @Override\n    public CharSequence getPageTitle(int position) {\n        try {\n            CharSequence title = super.getPageTitle(position);\n            if (title != null && title.length() > 0)\n                return title;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        try {\n            Page page = getPageAtOrThrow(position);\n            if (page.isCreated()) {\n                Fragment fragment = page.getFragment();\n\n                if (fragment instanceof NameableAdapter) {\n                    String name = ((NameableAdapter) fragment).getName();\n                    if (name != null && name.length() > 0)\n                        return name;\n                }\n                if (fragment instanceof SimpleFragment) {\n                    String name = ((SimpleFragment) fragment).getTitle();\n                    if (name != null && name.length() > 0)\n                        return name;\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n\n    @Override\n    protected void setVisible(@NonNull Fragment fragment, boolean visible) {\n        super.setVisible(fragment, visible);\n\n        if (CHANGE_VISIBILITY && fragment instanceof VisibilityAdapter) {\n            VisibilityAdapter visibilityAdapter = (VisibilityAdapter) fragment;\n            visibilityAdapter.setVisibility(visible, false);\n        }\n    }\n}", "class_id": 0, "repo": "ProDev2/SimpleLibrary", "file": "simplelib/src/main/java/com/simplelib/pager/SimpleFragmentPagerAdapter.java", "last_update_at": "2019-06-19T21:22:32+00:00", "question_id": "84eee976f52695b87dca16bac04b65017ee3a4d4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SimpleFragmentPagerAdapter extends FragmentPagerAdapter {\n    public boolean CHANGE_VISIBILITY = true;\n    public SimpleFragmentPagerAdapter(@NonNull FragmentManager fragmentManager) {\n        super(fragmentManager);\n    }\n    public SimpleFragmentPagerAdapter(@NonNull FragmentManager fragmentManager, @Nullable List<Page> pages) {\n        super(fragmentManager, pages);\n    }\n    @Nullable\n    @Override\n    public CharSequence getPageTitle(int position) {\n        try {\n            CharSequence title = super.getPageTitle(position);\n            if (title != null && title.length() > 0)\n                return title;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            Page page = getPageAtOrThrow(position);\n            if (page.isCreated()) {\n                Fragment fragment = page.getFragment();\n                if (fragment instanceof NameableAdapter) {\n                    String name = ((NameableAdapter) fragment).getName();\n                    if (name != null && name.length() > 0)\n                        return name;\n                }\n                if (fragment instanceof SimpleFragment) {\n                    String name = ((SimpleFragment) fragment).getTitle();\n                    if (name != null && name.length() > 0)\n                        return name;\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n    @Override\n    protected void setVisible(@NonNull Fragment fragment, boolean visible) {\n        super.setVisible(fragment, visible);\n        if (CHANGE_VISIBILITY && fragment instanceof VisibilityAdapter) {\n            VisibilityAdapter visibilityAdapter = (VisibilityAdapter) fragment;\n            visibilityAdapter.setVisibility(visible, false);\n        }\n    }\n"]]}
{"hexsha": "2e363ad0cdf82d8e6f2607cd28e016e59c024894", "ext": "java", "lang": "Java", "content": "public class SegmentSelectorTest {\n\n    private final String scope = \"scope\";\n    private final String streamName = \"streamName\";\n    private final EventWriterConfig config = EventWriterConfig.builder().build();\n    private final Consumer<Segment> segmentSealedCallback = segment -> { };\n\n    @Test\n    public void testUsesAllSegments() {\n        Controller controller = Mockito.mock(Controller.class);\n        SegmentOutputStreamFactory factory = Mockito.mock(SegmentOutputStreamFactory.class);\n        SegmentSelector selector = new SegmentSelector(new StreamImpl(scope, streamName), controller, factory, config);\n        TreeMap<Double, SegmentWithRange> segments = new TreeMap<>();\n        addNewSegment(segments, 0, 0.0, 0.25);\n        addNewSegment(segments, 1, 0.25, 0.5);\n        addNewSegment(segments, 2, 0.5, 0.75);\n        addNewSegment(segments, 3, 0.75, 1.0);\n        StreamSegments streamSegments = new StreamSegments(segments, \"\");\n\n        when(controller.getCurrentSegments(scope, streamName))\n               .thenReturn(CompletableFuture.completedFuture(streamSegments));\n        selector.refreshSegmentEventWriters(segmentSealedCallback);\n        int[] counts = new int[4];\n        Arrays.fill(counts, 0);\n        for (int i = 0; i < 20; i++) {\n            Segment segment = selector.getSegmentForEvent(\"\" + i);\n            assertNotNull(segment);\n            counts[StreamSegmentNameUtils.getSegmentNumber(segment.getSegmentId())]++;\n        }\n        for (int count : counts) {\n            assertTrue(count > 1);\n        }\n    }\n\n    private void addNewSegment(TreeMap<Double, SegmentWithRange> segments, int number, double low, double high) {\n        segments.put(high, new SegmentWithRange(new Segment(scope, streamName, number), low, high));\n    }\n\n    @Test\n    public void testNullRoutingKey() {\n        Controller controller = Mockito.mock(Controller.class);\n        SegmentOutputStreamFactory factory = Mockito.mock(SegmentOutputStreamFactory.class);\n        SegmentSelector selector = new SegmentSelector(new StreamImpl(scope, streamName), controller, factory, config);\n        TreeMap<Double, SegmentWithRange> segments = new TreeMap<>();\n        addNewSegment(segments, 0, 0.0, 0.25);\n        addNewSegment(segments, 1, 0.25, 0.5);\n        addNewSegment(segments, 2, 0.5, 0.75);\n        addNewSegment(segments, 3, 0.75, 1.0);\n        StreamSegments streamSegments = new StreamSegments(segments, \"\");\n\n        when(controller.getCurrentSegments(scope, streamName))\n               .thenReturn(CompletableFuture.completedFuture(streamSegments));\n        selector.refreshSegmentEventWriters(segmentSealedCallback);\n        int[] counts = new int[4];\n        Arrays.fill(counts, 0);\n        for (int i = 0; i < 100; i++) {\n            Segment segment = selector.getSegmentForEvent(null);\n            assertNotNull(segment);\n            counts[StreamSegmentNameUtils.getSegmentNumber(segment.getSegmentId())]++;\n        }\n        for (int count : counts) {\n            assertTrue(count > 1);\n        }\n    }\n\n    @Test\n    public void testSameRoutingKey() {\n        Controller controller = Mockito.mock(Controller.class);\n        SegmentOutputStreamFactory factory = Mockito.mock(SegmentOutputStreamFactory.class);\n        SegmentSelector selector = new SegmentSelector(new StreamImpl(scope, streamName), controller, factory, config);\n        TreeMap<Double, SegmentWithRange> segments = new TreeMap<>();\n        addNewSegment(segments, 0, 0.0, 0.25);\n        addNewSegment(segments, 1, 0.25, 0.5);\n        addNewSegment(segments, 2, 0.5, 0.75);\n        addNewSegment(segments, 3, 0.75, 1.0);\n        StreamSegments streamSegments = new StreamSegments(segments, \"\");\n\n        when(controller.getCurrentSegments(scope, streamName))\n               .thenReturn(CompletableFuture.completedFuture(streamSegments));\n        selector.refreshSegmentEventWriters(segmentSealedCallback);\n        int[] counts = new int[4];\n        Arrays.fill(counts, 0);\n        for (int i = 0; i < 20; i++) {\n            Segment segment = selector.getSegmentForEvent(\"Foo\");\n            assertNotNull(segment);\n            counts[StreamSegmentNameUtils.getSegmentNumber(segment.getSegmentId())]++;\n        }\n        assertArrayEquals(new int[] { 20, 0, 0, 0 }, counts);\n    }\n\n    @Test\n    public void testStreamDeletion() {\n        final Segment segment0 = new Segment(scope, streamName, 0);\n        final Segment segment1 = new Segment(scope, streamName, 1);\n        final CompletableFuture<Void> writerFuture = new CompletableFuture<>();\n\n        // Setup Mock.\n        SegmentOutputStream s0Writer = Mockito.mock(SegmentOutputStream.class);\n        SegmentOutputStream s1Writer = Mockito.mock(SegmentOutputStream.class);\n        when(s0Writer.getUnackedEventsOnSeal())\n                .thenReturn(ImmutableList.of(PendingEvent.withHeader(\"0\", ByteBuffer.wrap(\"e\".getBytes()), writerFuture)));\n\n        SegmentOutputStreamFactory factory = Mockito.mock(SegmentOutputStreamFactory.class);\n        when(factory.createOutputStreamForSegment(eq(segment0), ArgumentMatchers.<Consumer<Segment>>any(), any(EventWriterConfig.class), anyString()))\n                .thenReturn(s0Writer);\n        when(factory.createOutputStreamForSegment(eq(segment1), ArgumentMatchers.<Consumer<Segment>>any(), any(EventWriterConfig.class), anyString()))\n                .thenReturn(s1Writer);\n\n        Controller controller = Mockito.mock(Controller.class);\n        SegmentSelector selector = new SegmentSelector(new StreamImpl(scope, streamName), controller, factory, config);\n        TreeMap<Double, SegmentWithRange> segments = new TreeMap<>();\n        addNewSegment(segments, 0, 0.0, 0.5);\n        addNewSegment(segments, 1, 0.5, 1.0);\n        StreamSegments streamSegments = new StreamSegments(segments, \"\");\n\n        when(controller.getCurrentSegments(scope, streamName))\n                .thenReturn(CompletableFuture.completedFuture(streamSegments));\n        //trigger refresh.\n        selector.refreshSegmentEventWriters(segmentSealedCallback);\n\n        //simulate stream deletion where controller.getSuccessors() is completed exceptionally.\n        when(controller.getSuccessors(segment0))\n                .thenAnswer(i -> {\n                    CompletableFuture<StreamSegmentsWithPredecessors> result = new CompletableFuture<>();\n                    // Controller throws io.pravega.controller.store.stream.StoreException$DataNotFoundException which is type RuntimeException.\n                    // Using RunTimeException here as the controller exception is not visible.\n                    result.completeExceptionally(new RuntimeException());\n                    return result;\n                });\n\n        assertEquals(Collections.emptyList(), selector.refreshSegmentEventWritersUponSealed(segment0, segmentSealedCallback));\n        assertFutureThrows(\"Writer Future\", writerFuture, t -> t instanceof NoSuchSegmentException);\n    }\n\n}", "class_id": 0, "repo": "jkhalack/pravega", "file": "client/src/test/java/io/pravega/client/stream/impl/SegmentSelectorTest.java", "last_update_at": "2019-04-06T16:31:22+00:00", "question_id": "2e363ad0cdf82d8e6f2607cd28e016e59c024894", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SegmentSelectorTest {\n    private final String scope = \"scope\";\n    private final String streamName = \"streamName\";\n    private final EventWriterConfig config = EventWriterConfig.builder().build();\n    private final Consumer<Segment> segmentSealedCallback = segment -> { };\n    @Test\n    public void testUsesAllSegments() {\n        Controller controller = Mockito.mock(Controller.class);\n        SegmentOutputStreamFactory factory = Mockito.mock(SegmentOutputStreamFactory.class);\n        SegmentSelector selector = new SegmentSelector(new StreamImpl(scope, streamName), controller, factory, config);\n        TreeMap<Double, SegmentWithRange> segments = new TreeMap<>();\n        addNewSegment(segments, 0, 0.0, 0.25);\n        addNewSegment(segments, 1, 0.25, 0.5);\n        addNewSegment(segments, 2, 0.5, 0.75);\n        addNewSegment(segments, 3, 0.75, 1.0);\n        StreamSegments streamSegments = new StreamSegments(segments, \"\");\n        when(controller.getCurrentSegments(scope, streamName))\n               .thenReturn(CompletableFuture.completedFuture(streamSegments));\n        selector.refreshSegmentEventWriters(segmentSealedCallback);\n        int[] counts = new int[4];\n        Arrays.fill(counts, 0);\n        for (int i = 0; i < 20; i++) {\n            Segment segment = selector.getSegmentForEvent(\"\" + i);\n            assertNotNull(segment);\n            counts[StreamSegmentNameUtils.getSegmentNumber(segment.getSegmentId())]++;\n        }\n        for (int count : counts) {\n            assertTrue(count > 1);\n        }\n    }\n    private void addNewSegment(TreeMap<Double, SegmentWithRange> segments, int number, double low, double high) {\n        segments.put(high, new SegmentWithRange(new Segment(scope, streamName, number), low, high));\n    }\n    @Test\n    public void testNullRoutingKey() {\n        Controller controller = Mockito.mock(Controller.class);\n        SegmentOutputStreamFactory factory = Mockito.mock(SegmentOutputStreamFactory.class);\n        SegmentSelector selector = new SegmentSelector(new StreamImpl(scope, streamName), controller, factory, config);\n        TreeMap<Double, SegmentWithRange> segments = new TreeMap<>();\n        addNewSegment(segments, 0, 0.0, 0.25);\n        addNewSegment(segments, 1, 0.25, 0.5);\n        addNewSegment(segments, 2, 0.5, 0.75);\n        addNewSegment(segments, 3, 0.75, 1.0);\n        StreamSegments streamSegments = new StreamSegments(segments, \"\");\n        when(controller.getCurrentSegments(scope, streamName))\n               .thenReturn(CompletableFuture.completedFuture(streamSegments));\n        selector.refreshSegmentEventWriters(segmentSealedCallback);\n        int[] counts = new int[4];\n        Arrays.fill(counts, 0);\n        for (int i = 0; i < 100; i++) {\n            Segment segment = selector.getSegmentForEvent(null);\n            assertNotNull(segment);\n            counts[StreamSegmentNameUtils.getSegmentNumber(segment.getSegmentId())]++;\n        }\n        for (int count : counts) {\n            assertTrue(count > 1);\n        }\n    }\n    @Test\n    public void testSameRoutingKey() {\n        Controller controller = Mockito.mock(Controller.class);\n        SegmentOutputStreamFactory factory = Mockito.mock(SegmentOutputStreamFactory.class);\n        SegmentSelector selector = new SegmentSelector(new StreamImpl(scope, streamName), controller, factory, config);\n        TreeMap<Double, SegmentWithRange> segments = new TreeMap<>();\n        addNewSegment(segments, 0, 0.0, 0.25);\n        addNewSegment(segments, 1, 0.25, 0.5);\n        addNewSegment(segments, 2, 0.5, 0.75);\n        addNewSegment(segments, 3, 0.75, 1.0);\n        StreamSegments streamSegments = new StreamSegments(segments, \"\");\n        when(controller.getCurrentSegments(scope, streamName))\n               .thenReturn(CompletableFuture.completedFuture(streamSegments));\n        selector.refreshSegmentEventWriters(segmentSealedCallback);\n        int[] counts = new int[4];\n        Arrays.fill(counts, 0);\n        for (int i = 0; i < 20; i++) {\n            Segment segment = selector.getSegmentForEvent(\"Foo\");\n            assertNotNull(segment);\n            counts[StreamSegmentNameUtils.getSegmentNumber(segment.getSegmentId())]++;\n        }\n        assertArrayEquals(new int[] { 20, 0, 0, 0 }, counts);\n    }\n    @Test\n    public void testStreamDeletion() {\n        final Segment segment0 = new Segment(scope, streamName, 0);\n        final Segment segment1 = new Segment(scope, streamName, 1);\n        final CompletableFuture<Void> writerFuture = new CompletableFuture<>();\n        // Setup Mock.\n        SegmentOutputStream s0Writer = Mockito.mock(SegmentOutputStream.class);\n        SegmentOutputStream s1Writer = Mockito.mock(SegmentOutputStream.class);\n        when(s0Writer.getUnackedEventsOnSeal())\n                .thenReturn(ImmutableList.of(PendingEvent.withHeader(\"0\", ByteBuffer.wrap(\"e\".getBytes()), writerFuture)));\n        SegmentOutputStreamFactory factory = Mockito.mock(SegmentOutputStreamFactory.class);\n        when(factory.createOutputStreamForSegment(eq(segment0), ArgumentMatchers.<Consumer<Segment>>any(), any(EventWriterConfig.class), anyString()))\n                .thenReturn(s0Writer);\n        when(factory.createOutputStreamForSegment(eq(segment1), ArgumentMatchers.<Consumer<Segment>>any(), any(EventWriterConfig.class), anyString()))\n                .thenReturn(s1Writer);\n        Controller controller = Mockito.mock(Controller.class);\n        SegmentSelector selector = new SegmentSelector(new StreamImpl(scope, streamName), controller, factory, config);\n        TreeMap<Double, SegmentWithRange> segments = new TreeMap<>();\n        addNewSegment(segments, 0, 0.0, 0.5);\n        addNewSegment(segments, 1, 0.5, 1.0);\n        StreamSegments streamSegments = new StreamSegments(segments, \"\");\n        when(controller.getCurrentSegments(scope, streamName))\n                .thenReturn(CompletableFuture.completedFuture(streamSegments));\n        //trigger refresh.\n        selector.refreshSegmentEventWriters(segmentSealedCallback);\n        //simulate stream deletion where controller.getSuccessors() is completed exceptionally.\n        when(controller.getSuccessors(segment0))\n                .thenAnswer(i -> {\n                    CompletableFuture<StreamSegmentsWithPredecessors> result = new CompletableFuture<>();\n                    // Controller throws io.pravega.controller.store.stream.StoreException$DataNotFoundException which is type RuntimeException.\n                    // Using RunTimeException here as the controller exception is not visible.\n                    result.completeExceptionally(new RuntimeException());\n                    return result;\n                });\n        assertEquals(Collections.emptyList(), selector.refreshSegmentEventWritersUponSealed(segment0, segmentSealedCallback));\n        assertFutureThrows(\"Writer Future\", writerFuture, t -> t instanceof NoSuchSegmentException);\n    }\n"]]}
{"hexsha": "419c448b0da2fe975d2e69e947a97a967e6da489", "ext": "java", "lang": "Java", "content": "public class Update extends ConditionSqlBase {\r\n\r\n    private Update(SqlType sqlType) {\r\n        super(sqlType);\r\n    }\r\n\r\n    public static Update sql() {\r\n        return new Update(SqlType.UPDATE);\r\n    }\r\n\r\n    public Update update(Object item) {\r\n        String tableName = getTableName(item);\r\n\r\n        SampleMirrorObject sampleMirrorObject = SampleMirrorObject.forObject(item);\r\n\r\n        List<String> names = findParamsList(item);\r\n\r\n        this.sql.append(UPDATE).append(SPLIT).append(TAG).append(tableName).append(TAG).append(SPLIT);\r\n\r\n        StringBuilder setData = new StringBuilder();\r\n\r\n        boolean isStart = true;\r\n\r\n        for (String paramName : names) {\r\n            Object paramValue = sampleMirrorObject.getValue(paramName);\r\n            if (paramValue != null) {\r\n                if (isStart) {\r\n                    setData.append(TAG).append(paramName).append(TAG).append(EQUAL).append(PLACEHOLDER);\r\n                    isStart = false;\r\n                } else {\r\n                    setData.append(COMMA).append(TAG).append(paramName).append(TAG).append(EQUAL).append(PLACEHOLDER);\r\n                }\r\n                this.paramList.add(paramValue);\r\n            }\r\n        }\r\n\r\n        if (setData.length() > 0) {\r\n            this.sql.append(SET).append(SPLIT).append(setData).append(SPLIT);\r\n        } else {\r\n            throw new RuntimeException();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    public Update update(String tableName, String[] paramsNames, Object[] params) {\r\n        if (paramsNames.length != params.length) {\r\n            throw new RuntimeException();\r\n        }\r\n        this.sql.append(UPDATE).append(SPLIT).append(TAG).append(tableName).append(TAG).append(SPLIT);\r\n        StringBuilder setData = new StringBuilder();\r\n        boolean isStart = true;\r\n        for (int a = 0; a < params.length; a++) {\r\n            if (params[a] == null) {\r\n                throw new RuntimeException();\r\n            }\r\n            if (isStart) {\r\n                setData.append(paramsNames[a]).append(SPLIT).append(EQUAL).append(PLACEHOLDER);\r\n                isStart = false;\r\n            } else {\r\n                setData.append(COMMA).append(paramsNames[a]).append(SPLIT).append(EQUAL).append(PLACEHOLDER);\r\n            }\r\n            this.paramList.add(params[a]);\r\n        }\r\n        this.sql.append(setData);\r\n        return this;\r\n    }\r\n\r\n}", "class_id": 0, "repo": "kyssion/mintflow-function-engine", "file": "mintflow-sql/src/main/java/org/mintflow/sql/Update.java", "last_update_at": "2019-10-20T13:05:34+00:00", "question_id": "419c448b0da2fe975d2e69e947a97a967e6da489", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Update extends ConditionSqlBase {\r\n\r\n    private Update(SqlType sqlType) {\r\n        super(sqlType);\r\n    }\r\n\r\n    public static Update sql() {\r\n        return new Update(SqlType.UPDATE);\r\n    }\r\n\r\n    public Update update(Object item) {\r\n        String tableName = getTableName(item);\r\n\r\n        SampleMirrorObject sampleMirrorObject = SampleMirrorObject.forObject(item);\r\n\r\n        List<String> names = findParamsList(item);\r\n\r\n        this.sql.append(UPDATE).append(SPLIT).append(TAG).append(tableName).append(TAG).append(SPLIT);\r\n\r\n        StringBuilder setData = new StringBuilder();\r\n\r\n        boolean isStart = true;\r\n\r\n        for (String paramName : names) {\r\n            Object paramValue = sampleMirrorObject.getValue(paramName);\r\n            if (paramValue != null) {\r\n                if (isStart) {\r\n                    setData.append(TAG).append(paramName).append(TAG).append(EQUAL).append(PLACEHOLDER);\r\n                    isStart = false;\r\n                } else {\r\n                    setData.append(COMMA).append(TAG).append(paramName).append(TAG).append(EQUAL).append(PLACEHOLDER);\r\n                }\r\n                this.paramList.add(paramValue);\r\n            }\r\n        }\r\n\r\n        if (setData.length() > 0) {\r\n            this.sql.append(SET).append(SPLIT).append(setData).append(SPLIT);\r\n        } else {\r\n            throw new RuntimeException();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    public Update update(String tableName, String[] paramsNames, Object[] params) {\r\n        if (paramsNames.length != params.length) {\r\n            throw new RuntimeException();\r\n        }\r\n        this.sql.append(UPDATE).append(SPLIT).append(TAG).append(tableName).append(TAG).append(SPLIT);\r\n        StringBuilder setData = new StringBuilder();\r\n        boolean isStart = true;\r\n        for (int a = 0; a < params.length; a++) {\r\n            if (params[a] == null) {\r\n                throw new RuntimeException();\r\n            }\r\n            if (isStart) {\r\n                setData.append(paramsNames[a]).append(SPLIT).append(EQUAL).append(PLACEHOLDER);\r\n                isStart = false;\r\n            } else {\r\n                setData.append(COMMA).append(paramsNames[a]).append(SPLIT).append(EQUAL).append(PLACEHOLDER);\r\n            }\r\n            this.paramList.add(params[a]);\r\n        }\r\n        this.sql.append(setData);\r\n        return this;\r\n    }\r\n\r\n"]]}
{"hexsha": "946acf05163866f1a33cc371456dcd79e5ae5f7f", "ext": "java", "lang": "Java", "content": "class variable3\n{\n    public static void main()\n    {\n        int a,b,c,d,e;\n        a=9;\n        b=7;\n        c=8;\n        d=6;\n        e=(a+(b+c)+(c+d)+(d+b));\n        System.out.println(e);\n    }\n}", "class_id": 0, "repo": "SayanGhoshBDA/code-backup", "file": "java_backup/my java/arpan_adamas/variable3.java", "last_update_at": "2019-05-08T10:09:52+00:00", "question_id": "946acf05163866f1a33cc371456dcd79e5ae5f7f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class variable3\n{\n    public static void main()\n    {\n        int a,b,c,d,e;\n        a=9;\n        b=7;\n        c=8;\n        d=6;\n        e=(a+(b+c)+(c+d)+(d+b));\n        System.out.println(e);\n    }\n"]]}
{"hexsha": "8efddaf039ff96eacb880145a6677f6977b81e86", "ext": "java", "lang": "Java", "content": "public class AppbarCustomizer {\n\n    public static void configureAppbar(Activity activity, boolean showBackArrow) {\n        ActionBar actionBar = ((AppCompatActivity) activity).getSupportActionBar();\n        if (actionBar != null) {\n            actionBar.setDisplayUseLogoEnabled(!showBackArrow);\n            actionBar.setDisplayShowHomeEnabled(!showBackArrow);\n            actionBar.setDisplayHomeAsUpEnabled(showBackArrow);\n            if (!showBackArrow) actionBar.setIcon(R.mipmap.ic_launcher);\n        }\n    }\n\n    public static void changeAppbarColor(Activity activity, @ColorRes int id) {\n        ActionBar actionBar = ((AppCompatActivity) activity).getSupportActionBar();\n        if (actionBar != null) actionBar.setBackgroundDrawable(new ColorDrawable(activity.getResources().getColor(id)));\n    }\n\n    public static void changeAppbarTitle (Activity activity, @StringRes int id) {\n        changeAppbarTitle(activity, activity.getResources().getString(id));\n    }\n\n    public static void changeAppbarTitle(Activity activity, String text) {\n        ActionBar actionBar = ((AppCompatActivity)activity).getSupportActionBar();\n        if (actionBar != null) actionBar.setTitle(fontifyString(activity, text));\n    }\n\n    public static SpannableString fontifyString(Context context, String text) {\n        SpannableString string = new SpannableString(text);\n        string.setSpan(new TypefaceSpan(context, FONT_NAME), 0, string.length(),\n                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n        return string;\n    }\n}", "class_id": 0, "repo": "vaginessa/Neuronizer", "file": "app/src/main/java/de/djuelg/neuronizer/presentation/ui/custom/view/AppbarCustomizer.java", "last_update_at": "2019-09-17T15:51:21+00:00", "question_id": "8efddaf039ff96eacb880145a6677f6977b81e86", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AppbarCustomizer {\n    public static void configureAppbar(Activity activity, boolean showBackArrow) {\n        ActionBar actionBar = ((AppCompatActivity) activity).getSupportActionBar();\n        if (actionBar != null) {\n            actionBar.setDisplayUseLogoEnabled(!showBackArrow);\n            actionBar.setDisplayShowHomeEnabled(!showBackArrow);\n            actionBar.setDisplayHomeAsUpEnabled(showBackArrow);\n            if (!showBackArrow) actionBar.setIcon(R.mipmap.ic_launcher);\n        }\n    }\n    public static void changeAppbarColor(Activity activity, @ColorRes int id) {\n        ActionBar actionBar = ((AppCompatActivity) activity).getSupportActionBar();\n        if (actionBar != null) actionBar.setBackgroundDrawable(new ColorDrawable(activity.getResources().getColor(id)));\n    }\n    public static void changeAppbarTitle (Activity activity, @StringRes int id) {\n        changeAppbarTitle(activity, activity.getResources().getString(id));\n    }\n    public static void changeAppbarTitle(Activity activity, String text) {\n        ActionBar actionBar = ((AppCompatActivity)activity).getSupportActionBar();\n        if (actionBar != null) actionBar.setTitle(fontifyString(activity, text));\n    }\n    public static SpannableString fontifyString(Context context, String text) {\n        SpannableString string = new SpannableString(text);\n        string.setSpan(new TypefaceSpan(context, FONT_NAME), 0, string.length(),\n                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n        return string;\n    }\n"]]}
