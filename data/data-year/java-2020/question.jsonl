{"hexsha": "3c70cab69121f364f1772cd3c27494171b225d31", "ext": "java", "lang": "Java", "content": "public class MethodTest {\n\n\t@Test\n\tpublic void test() {\n\t\tMethodExampleGen gen1 = new MethodExampleGen();\n\t\tgen1.setSomeString(\"foo\");\n\t\tgen1.setSomeInt(1);\n\n\t\tMethodExampleGen gen2 = new MethodExampleGen();\n\t\tgen2.setSomeString(\"foo\");\n\t\tgen2.setSomeInt(1);\n\n\t\tMethodExampleGen gen3 = new MethodExampleGen();\n\t\tgen3.setSomeString(\"foo\");\n\t\tgen3.setSomeInt(2);\n\n\t\tassertEquals(gen1.hashCode(), gen2.hashCode());\n\t\tassertEquals(gen1, gen2);\n\n\t\tassertFalse(gen1.hashCode() == gen3.hashCode());\n\t\tassertFalse(gen1.equals(gen3));\n\t\tassertFalse(gen1.equals(null));\n\t\tassertFalse(gen1.equals(new Object()));\n\t\tassertFalse(new Object().equals(gen1));\n\t}\n\n}", "class_id": 0, "repo": "japkit/japkit", "file": "japkit-test/src/test/java/de/japkit/test/members/method/MethodTest.java", "last_update_at": "2020-07-22T18:05:38+00:00", "question_id": "3c70cab69121f364f1772cd3c27494171b225d31", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MethodTest {\n\t@Test\n\tpublic void test() {\n\t\tMethodExampleGen gen1 = new MethodExampleGen();\n\t\tgen1.setSomeString(\"foo\");\n\t\tgen1.setSomeInt(1);\n\t\tMethodExampleGen gen2 = new MethodExampleGen();\n\t\tgen2.setSomeString(\"foo\");\n\t\tgen2.setSomeInt(1);\n\t\tMethodExampleGen gen3 = new MethodExampleGen();\n\t\tgen3.setSomeString(\"foo\");\n\t\tgen3.setSomeInt(2);\n\t\tassertEquals(gen1.hashCode(), gen2.hashCode());\n\t\tassertEquals(gen1, gen2);\n\t\tassertFalse(gen1.hashCode() == gen3.hashCode());\n\t\tassertFalse(gen1.equals(gen3));\n\t\tassertFalse(gen1.equals(null));\n\t\tassertFalse(gen1.equals(new Object()));\n\t\tassertFalse(new Object().equals(gen1));\n\t}\n"]]}
{"hexsha": "bb1d42e69aee131817a3cf876c3e59e7c0414f39", "ext": "java", "lang": "Java", "content": "public class ArgParser\n{\n\n   private Logger log = LoggerFactory.getLogger(ArgParser.class);\n\n   String args[]=null;\n   \n   /**\n    * The constructor requires the arguements that are passed to the \n    * main method.\n    */\n   public ArgParser(String a[]) {\n      args=a;\n   }\n\n   public String getStringArg(String key){\n      return getStringArg(key, null);\n   }\n\n   /**\n    * Returns the string corresponding to the requested key.\n    */\n   public String getStringArg(String key, String def) {\n      for (int i=0; i<args.length; i++) {\n         String arg=args[i];\n         \n         if (arg.equalsIgnoreCase(key) &&\n             args.length >= i+2)\n            return args[i+1].trim();\n         \n         if (arg.startsWith(key))\n            return arg.substring(key.length()).trim();\n      }\n      return def;\n   }\n\n   public int size() {return args.length;}\n   public String getLastArg() {\n      if (args.length == 0)\n         return null;\n      return args[args.length-1];\n   }\n\n   /**\n    *\n    */\n   public Integer getIntegerArg(String key) {\n      String str=getStringArg(key);\n      if (str == null || str.trim().length() <= 0) return null;\n      \n      Integer val=null;\n      try {\n         int i=Integer.parseInt(str.trim());\n         val=new Integer(i);\n      } catch (NumberFormatException ex) {\n         log.warn(\"NumberFormatException reading \"+key+\" from \"+\n                             \"args.\");\n      }\n      return val;\n   }\n\n   /** */\n   public int getIntArg(String key, int def) {\n      Integer i=getIntegerArg(key);\n      if (i == null)\n         return def;\n      else\n         return i.intValue();\n   }\n\n   /** */\n   public String toString() {\n      StringBuffer sb=new StringBuffer();\n      for (int i=0; i<args.length; i++) {\n         sb.append(\"  \"+i+\": '\"+args[i]+\"'\\n\");\n      }\n      return sb.toString();\n   }\n\n   /**\n    * Returns a boolean indicating whether a command like switch was\n    * present.\n    */ \n   public boolean getBooleanArg(String key) {\n      for (int i=0; i<args.length; i++) {\n         String arg=args[i];\n         if (arg.equalsIgnoreCase(key))\n            return true;\n      }\n      return false;\n   }\n\n   /**\n    * Returns a boolean indicating whether a command like switch was\n    * present.\n    */ \n   public boolean getBooleanArg(String key, boolean def) {\n      for (int i=0; i<args.length; i++) {\n         String arg=args[i];\n         if (arg.equalsIgnoreCase(key))\n            return true;\n      }\n      return def;\n   }\n}", "class_id": 0, "repo": "turnsk/eproperties", "file": "src/main/java/net/jmatrix/eproperties/cli/ArgParser.java", "last_update_at": "2020-11-24T08:03:38+00:00", "question_id": "bb1d42e69aee131817a3cf876c3e59e7c0414f39", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ArgParser\n{\n   private Logger log = LoggerFactory.getLogger(ArgParser.class);\n   String args[]=null;\n   /**\n    * The constructor requires the arguements that are passed to the \n    * main method.\n    */\n   public ArgParser(String a[]) {\n      args=a;\n   }\n   public String getStringArg(String key){\n      return getStringArg(key, null);\n   }\n   /**\n    * Returns the string corresponding to the requested key.\n    */\n   public String getStringArg(String key, String def) {\n      for (int i=0; i<args.length; i++) {\n         String arg=args[i];\n         if (arg.equalsIgnoreCase(key) &&\n             args.length >= i+2)\n            return args[i+1].trim();\n         if (arg.startsWith(key))\n            return arg.substring(key.length()).trim();\n      }\n      return def;\n   }\n   public int size() {return args.length;}\n   public String getLastArg() {\n      if (args.length == 0)\n         return null;\n      return args[args.length-1];\n   }\n   /**\n    *\n    */\n   public Integer getIntegerArg(String key) {\n      String str=getStringArg(key);\n      if (str == null || str.trim().length() <= 0) return null;\n      Integer val=null;\n      try {\n         int i=Integer.parseInt(str.trim());\n         val=new Integer(i);\n      } catch (NumberFormatException ex) {\n         log.warn(\"NumberFormatException reading \"+key+\" from \"+\n                             \"args.\");\n      }\n      return val;\n   }\n   /** */\n   public int getIntArg(String key, int def) {\n      Integer i=getIntegerArg(key);\n      if (i == null)\n         return def;\n      else\n         return i.intValue();\n   }\n   /** */\n   public String toString() {\n      StringBuffer sb=new StringBuffer();\n      for (int i=0; i<args.length; i++) {\n         sb.append(\"  \"+i+\": '\"+args[i]+\"'\\n\");\n      }\n      return sb.toString();\n   }\n   /**\n    * Returns a boolean indicating whether a command like switch was\n    * present.\n    */ \n   public boolean getBooleanArg(String key) {\n      for (int i=0; i<args.length; i++) {\n         String arg=args[i];\n         if (arg.equalsIgnoreCase(key))\n            return true;\n      }\n      return false;\n   }\n   /**\n    * Returns a boolean indicating whether a command like switch was\n    * present.\n    */ \n   public boolean getBooleanArg(String key, boolean def) {\n      for (int i=0; i<args.length; i++) {\n         String arg=args[i];\n         if (arg.equalsIgnoreCase(key))\n            return true;\n      }\n      return def;\n   }\n"]]}
{"hexsha": "a4862962b3814f7582b05ead4ab8f461ce421340", "ext": "java", "lang": "Java", "content": "public class CMSG_PET_NAME_QUERY extends AbstractRealmClientPacket {\n\n    /**\n     * Packet size.\n     */\n    private short size;\n    \n    /**\n     * Pet number\n     */\n    private int number;\n    \n    /**\n     * Pet ID.\n     */\n    private long guid;\n    \n    /**\n     * Constructor with opcode.\n     *\n     * @param opcode\n     */\n    public CMSG_PET_NAME_QUERY(Opcodes opcode, short size) {\n        super(opcode);\n        this.size = size;\n    }\n\n    public short getSize() {\n        return size;\n    }\n\n    public void setSize(short size) {\n        this.size = size;\n    }\n\n    public int getNumber() {\n        return number;\n    }\n\n    public void setNumber(int number) {\n        this.number = number;\n    }\n\n    public long getGuid() {\n        return guid;\n    }\n\n    public void setGuid(long guid) {\n        this.guid = guid;\n    }    \n    \n    public String toString() {\n        String toString = \"[CMSG_PET_NAME_QUERY [\"\n                + \"number: \"+this.number\n                + \", guid: \"+this.guid                \n                +\"]]\";\n\n        return toString;\n    }\n\n    @Override\n    public void decode(ByteBuf buf) throws Exception {           \n        if((buf.readableBytes()+4) < this.size)\n        {\n            throw new Exception();\n        }\n        \n        this.number = buf.readInt();\n        this.guid = buf.readLong();\n    }\n\n}", "class_id": 0, "repo": "Warkdev/JaNGOSRealm", "file": "src/main/java/eu/jangos/realm/network/packet/client/query/CMSG_PET_NAME_QUERY.java", "last_update_at": "2020-10-31T19:14:47+00:00", "question_id": "a4862962b3814f7582b05ead4ab8f461ce421340", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CMSG_PET_NAME_QUERY extends AbstractRealmClientPacket {\n    /**\n     * Packet size.\n     */\n    private short size;\n    /**\n     * Pet number\n     */\n    private int number;\n    /**\n     * Pet ID.\n     */\n    private long guid;\n    /**\n     * Constructor with opcode.\n     *\n     * @param opcode\n     */\n    public CMSG_PET_NAME_QUERY(Opcodes opcode, short size) {\n        super(opcode);\n        this.size = size;\n    }\n    public short getSize() {\n        return size;\n    }\n    public void setSize(short size) {\n        this.size = size;\n    }\n    public int getNumber() {\n        return number;\n    }\n    public void setNumber(int number) {\n        this.number = number;\n    }\n    public long getGuid() {\n        return guid;\n    }\n    public void setGuid(long guid) {\n        this.guid = guid;\n    }    \n    public String toString() {\n        String toString = \"[CMSG_PET_NAME_QUERY [\"\n                + \"number: \"+this.number\n                + \", guid: \"+this.guid                \n                +\"]]\";\n        return toString;\n    }\n    @Override\n    public void decode(ByteBuf buf) throws Exception {           \n        if((buf.readableBytes()+4) < this.size)\n        {\n            throw new Exception();\n        }\n        this.number = buf.readInt();\n        this.guid = buf.readLong();\n    }\n"]]}
{"hexsha": "41adc46758e76b1c8633ceccf673cebc059395df", "ext": "java", "lang": "Java", "content": "@RestController\npublic class AlarmPanelServerController {\n\n    AlarmPanel alarmPanel;\n\n    public AlarmPanelServerController(AlarmPanel alarmPanel) {\n        this.alarmPanel = alarmPanel;\n    }\n\n    @RequestMapping(path=\"/state\", method=RequestMethod.GET)\n    public HttpEntity<AlarmPanelStateResource> alarmPanelStateResource() {\n\n    \tAlarmPanelStateResource alarmPanelStateResource = new AlarmPanelStateResource(alarmPanel);\n    \talarmPanelStateResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelStateResource()).withSelfRel());\n    \t\n    \talarmPanelStateResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelBitfieldResource()).withRel(\"bit-field\"));\n    \talarmPanelStateResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelRawDataResource()).withRel(\"raw-data\"));\n    \talarmPanelStateResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelKeypadTextResource()).withRel(\"keypad-text\"));\n    \talarmPanelStateResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelNumCodeResource()).withRel(\"numeric-code\"));\n\n        return new ResponseEntity<AlarmPanelStateResource>(alarmPanelStateResource, HttpStatus.OK);\n    }\n        \n    @RequestMapping(path=\"/bit-field\", method=RequestMethod.GET)\n    public HttpEntity<AlarmPanelBitfieldResource> alarmPanelBitfieldResource() {\n\n    \tAlarmPanelBitfieldResource alarmPanelBitfieldResource = new AlarmPanelBitfieldResource(alarmPanel);\n    \talarmPanelBitfieldResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelBitfieldResource()).withSelfRel());\n\n        return new ResponseEntity<AlarmPanelBitfieldResource>(alarmPanelBitfieldResource, HttpStatus.OK);\n    }\n        \n    @RequestMapping(path=\"/raw-data\", method=RequestMethod.GET)\n    public HttpEntity<AlarmPanelRawDataResource> alarmPanelRawDataResource() {\n\n    \tAlarmPanelRawDataResource alarmPanelRawDataResource = new AlarmPanelRawDataResource(alarmPanel);\n    \talarmPanelRawDataResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelRawDataResource()).withSelfRel());\n\n        return new ResponseEntity<AlarmPanelRawDataResource>(alarmPanelRawDataResource, HttpStatus.OK);\n    }\n        \n    @RequestMapping(path=\"/keypad-text\", method=RequestMethod.GET)\n    public HttpEntity<AlarmPanelKeypadTextResource> alarmPanelKeypadTextResource() {\n\n    \tAlarmPanelKeypadTextResource alarmPanelKeypadTextResource = new AlarmPanelKeypadTextResource(alarmPanel);\n    \talarmPanelKeypadTextResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelKeypadTextResource()).withSelfRel());\n\n        return new ResponseEntity<AlarmPanelKeypadTextResource>(alarmPanelKeypadTextResource, HttpStatus.OK);\n    }\n        \n    @RequestMapping(path=\"/numeric-code\", method=RequestMethod.GET)\n    public HttpEntity<AlarmPanelNumCodeResource> alarmPanelNumCodeResource() {\n\n    \tAlarmPanelNumCodeResource alarmPanelNumCodeResource = new AlarmPanelNumCodeResource(alarmPanel);\n    \talarmPanelNumCodeResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelNumCodeResource()).withSelfRel());\n\n        return new ResponseEntity<AlarmPanelNumCodeResource>(alarmPanelNumCodeResource, HttpStatus.OK);\n    }\n        \n}", "class_id": 0, "repo": "agent-P/alarm-server", "file": "src/main/java/spagnola/ha/alarm/web/AlarmPanelServerController.java", "last_update_at": "2020-12-01T20:37:37+00:00", "question_id": "41adc46758e76b1c8633ceccf673cebc059395df", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RestController\npublic class AlarmPanelServerController {\n    AlarmPanel alarmPanel;\n    public AlarmPanelServerController(AlarmPanel alarmPanel) {\n        this.alarmPanel = alarmPanel;\n    }\n    @RequestMapping(path=\"/state\", method=RequestMethod.GET)\n    public HttpEntity<AlarmPanelStateResource> alarmPanelStateResource() {\n    \tAlarmPanelStateResource alarmPanelStateResource = new AlarmPanelStateResource(alarmPanel);\n    \talarmPanelStateResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelStateResource()).withSelfRel());\n    \t\n    \talarmPanelStateResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelBitfieldResource()).withRel(\"bit-field\"));\n    \talarmPanelStateResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelRawDataResource()).withRel(\"raw-data\"));\n    \talarmPanelStateResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelKeypadTextResource()).withRel(\"keypad-text\"));\n    \talarmPanelStateResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelNumCodeResource()).withRel(\"numeric-code\"));\n        return new ResponseEntity<AlarmPanelStateResource>(alarmPanelStateResource, HttpStatus.OK);\n    }\n    @RequestMapping(path=\"/bit-field\", method=RequestMethod.GET)\n    public HttpEntity<AlarmPanelBitfieldResource> alarmPanelBitfieldResource() {\n    \tAlarmPanelBitfieldResource alarmPanelBitfieldResource = new AlarmPanelBitfieldResource(alarmPanel);\n    \talarmPanelBitfieldResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelBitfieldResource()).withSelfRel());\n        return new ResponseEntity<AlarmPanelBitfieldResource>(alarmPanelBitfieldResource, HttpStatus.OK);\n    }\n    @RequestMapping(path=\"/raw-data\", method=RequestMethod.GET)\n    public HttpEntity<AlarmPanelRawDataResource> alarmPanelRawDataResource() {\n    \tAlarmPanelRawDataResource alarmPanelRawDataResource = new AlarmPanelRawDataResource(alarmPanel);\n    \talarmPanelRawDataResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelRawDataResource()).withSelfRel());\n        return new ResponseEntity<AlarmPanelRawDataResource>(alarmPanelRawDataResource, HttpStatus.OK);\n    }\n    @RequestMapping(path=\"/keypad-text\", method=RequestMethod.GET)\n    public HttpEntity<AlarmPanelKeypadTextResource> alarmPanelKeypadTextResource() {\n    \tAlarmPanelKeypadTextResource alarmPanelKeypadTextResource = new AlarmPanelKeypadTextResource(alarmPanel);\n    \talarmPanelKeypadTextResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelKeypadTextResource()).withSelfRel());\n        return new ResponseEntity<AlarmPanelKeypadTextResource>(alarmPanelKeypadTextResource, HttpStatus.OK);\n    }\n    @RequestMapping(path=\"/numeric-code\", method=RequestMethod.GET)\n    public HttpEntity<AlarmPanelNumCodeResource> alarmPanelNumCodeResource() {\n    \tAlarmPanelNumCodeResource alarmPanelNumCodeResource = new AlarmPanelNumCodeResource(alarmPanel);\n    \talarmPanelNumCodeResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelNumCodeResource()).withSelfRel());\n        return new ResponseEntity<AlarmPanelNumCodeResource>(alarmPanelNumCodeResource, HttpStatus.OK);\n    }\n"]]}
{"hexsha": "ab72d37a9ad701829fb4cd320b7b4132c6d2695f", "ext": "java", "lang": "Java", "content": "public class GreatestCommonDivisor4\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner scannerObject = new Scanner(System.in);\n\t\tSystem.out.printf(\"Enter the first number. \");\n\t\tint firstNumber = scannerObject.nextInt();\n\n\t\tSystem.out.printf(\"Enter the second number. \");\n\t\tint secondNumber = scannerObject.nextInt();\n\n\t\tint divisor, dividend, remainder = -1;\n\t\tint gcd = 1;\n\t\tif(firstNumber >= 1 && secondNumber >= 1)\n\t\t{\n\t\t\tif(firstNumber == secondNumber)\n\t\t\t{\n\t\t\t\tgcd = firstNumber;\n\t\t\t}\n\t\t\telse\n\t\t\t\tfor(int k = (firstNumber > secondNumber ? firstNumber / 2 : secondNumber / 2); k >= 2; k--)\n\t\t\t\t{\n\t\t\t\t\tif(firstNumber % k == 0 && secondNumber % k == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tgcd = k;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tSystem.out.printf(\"GCD(%d, %d): %d\\n\", firstNumber, secondNumber, gcd);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSystem.out.printf(\"Invalid input. Both numbers have to be natural numbers. The program will now exit.\\n\");\n\t\t}\n\t}\n}", "class_id": 0, "repo": "akinfotech19/IntroductionToJavaProgramming", "file": "Liang/Chapter5/GreatestCommonDivisor4.java", "last_update_at": "2020-05-26T16:01:11+00:00", "question_id": "ab72d37a9ad701829fb4cd320b7b4132c6d2695f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GreatestCommonDivisor4\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner scannerObject = new Scanner(System.in);\n\t\tSystem.out.printf(\"Enter the first number. \");\n\t\tint firstNumber = scannerObject.nextInt();\n\t\tSystem.out.printf(\"Enter the second number. \");\n\t\tint secondNumber = scannerObject.nextInt();\n\t\tint divisor, dividend, remainder = -1;\n\t\tint gcd = 1;\n\t\tif(firstNumber >= 1 && secondNumber >= 1)\n\t\t{\n\t\t\tif(firstNumber == secondNumber)\n\t\t\t{\n\t\t\t\tgcd = firstNumber;\n\t\t\t}\n\t\t\telse\n\t\t\t\tfor(int k = (firstNumber > secondNumber ? firstNumber / 2 : secondNumber / 2); k >= 2; k--)\n\t\t\t\t{\n\t\t\t\t\tif(firstNumber % k == 0 && secondNumber % k == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tgcd = k;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tSystem.out.printf(\"GCD(%d, %d): %d\\n\", firstNumber, secondNumber, gcd);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSystem.out.printf(\"Invalid input. Both numbers have to be natural numbers. The program will now exit.\\n\");\n\t\t}\n\t}\n"]]}
{"hexsha": "797553ef390bc60423b70777912447dc3d9b5a9e", "ext": "java", "lang": "Java", "content": "public class RecipeBuilder {\n\n    public static final String DEFAULT_NAME = \"Ham Sandwich\";\n    public static final List<Ingredient> DEFAULT_INGREDIENT_LIST = List.of(new Ingredient(\"bread, 2 slices\"),\n            new Ingredient(\"ham, 1 slice\"));\n    public static final List<Instruction> DEFAULT_INSTRUCTION_LIST = List.of(\n            new Instruction(\"place ham between \" + \"slices of bread\"), new Instruction(\"eat\"));\n    public static final Photograph DEFAULT_PHOTOGRAPH = Photograph.PLACEHOLDER_PHOTOGRAPH;\n    public static final String DEFAULT_CALORIE = \"300\";\n    public static final int DEFAULT_SERVING = 1;\n    public static final int DEFAULT_RATING = 3;\n    public static final int DEFAULT_DIFFICULTY = 3;\n\n\n    private Name name;\n    private IngredientList ingredients;\n    private InstructionList instructions;\n    private Photograph photograph;\n    private Calorie calorie;\n    private Serving serving;\n    private Rating rating;\n    private Difficulty difficulty;\n    private Time timing;\n    private Set<Tag> tags;\n\n    private Recipe recipe;\n\n    public RecipeBuilder() {\n        name = new Name(DEFAULT_NAME);\n        ingredients = new IngredientList(DEFAULT_INGREDIENT_LIST);\n        instructions = new InstructionList(DEFAULT_INSTRUCTION_LIST);\n        photograph = DEFAULT_PHOTOGRAPH;\n        calorie = new Calorie(DEFAULT_CALORIE);\n        serving = new Serving(DEFAULT_SERVING);\n        rating = new Rating(DEFAULT_RATING);\n        difficulty = new Difficulty(DEFAULT_DIFFICULTY);\n        tags = new HashSet<>();\n    }\n\n    /**\n     * Initializes the RecipeBuilder with the data of {@code recipeToCopy}.\n     */\n    public RecipeBuilder(Recipe recipeToCopy) {\n        name = recipeToCopy.getName();\n        ingredients = recipeToCopy.getIngredients();\n        instructions = recipeToCopy.getInstructions();\n        photograph = recipeToCopy.getPhotograph();\n        calorie = recipeToCopy.getCalorie();\n        serving = recipeToCopy.getServing();\n        rating = recipeToCopy.getRating();\n        difficulty = recipeToCopy.getDifficulty();\n        tags = new HashSet<>(recipeToCopy.getTags());\n    }\n\n    /**\n     * Sets the {@code Name} of the {@code Recipe} that we are building.\n     */\n    public RecipeBuilder withName(String name) {\n        this.name = new Name(name);\n        return this;\n    }\n\n    /**\n     * Parses the {@code tags} into a {@code Set<Tag>} and set it to the {@code Recipe} that we are building.\n     */\n    public RecipeBuilder withTags(String... tags) {\n        this.tags = SampleDataUtil.getTagSet(tags);\n        return this;\n    }\n\n    /**\n     * Sets the {@code IngredientList} of the {@code Recipe} that we are building.\n     */\n    public RecipeBuilder withIngredients(String ingredients) {\n        List<Ingredient> ingredientList =\n                Stream.of(ingredients.trim().split(\";\")).map(String::trim).map(Ingredient::new)\n                        .collect(Collectors.toList());\n        this.ingredients = new IngredientList(ingredientList);\n        return this;\n    }\n\n    /**\n     * Sets the {@code InstructionList} of the {@code Recipe} that we are building.\n     */\n    public RecipeBuilder withInstructions(String instructions) {\n        List<Instruction> instructionList = (Stream.of(instructions.trim().split(\";\")).map(String::trim)\n                .map(Instruction::new).collect(Collectors.toList()));\n        this.instructions = new InstructionList(instructionList);\n        return this;\n    }\n\n    /**\n     * Sets the {@code Photograph} of the {@code Recipe} that we are building.\n     */\n    public RecipeBuilder withPhotograph(String photograph) {\n        Photograph ph;\n        try {\n            ph = new Photograph(photograph);\n        } catch (IOException e) {\n            return this;\n        }\n        this.photograph = ph;\n        return this;\n    }\n\n    /**\n     * Sets the {@code Calorie} of the {@code Recipe} that we are building.\n     */\n    public RecipeBuilder withCalorie(String calorie) {\n        this.calorie = new Calorie(calorie);\n        return this;\n    }\n\n    /**\n     * Sets the {@code Serving} of the {@code Recipe} that we are building.\n     */\n    public RecipeBuilder withServing(int serving) {\n        this.serving = new Serving(serving);\n        return this;\n    }\n\n    /**\n     * Sets the {@code Rating} of the {@code Recipe} that we are building.\n     */\n    public RecipeBuilder withRating(int rating) {\n        this.rating = new Rating(rating);\n        return this;\n    }\n\n    /**\n     * Sets the {@code Difficulty} of the {@code Recipe} that we are building.\n     */\n    public RecipeBuilder withDifficulty(int difficulty) {\n        this.difficulty = new Difficulty(difficulty);\n        return this;\n    }\n\n    /**\n     * builds a Recipe.\n     * @return the Recipe.\n     */\n    public Recipe build() {\n        Recipe toReturn = new Recipe(name, ingredients, instructions, photograph, calorie, serving, rating, difficulty,\n                tags);\n        return toReturn;\n    }\n\n    /**\n     * adds a time to the recipe.\n     * @param h the hour component of the time.\n     * @param m the minute component of the time.\n     * @param s the second component of the time.\n     * @return\n     */\n    public RecipeBuilder addTime(int h, int m, int s) {\n        this.timing = new Time(h, m, s);\n        return this;\n    }\n}", "class_id": 0, "repo": "muhd97/main", "file": "src/test/java/cookbuddy/testutil/RecipeBuilder.java", "last_update_at": "2020-08-12T06:30:17+00:00", "question_id": "797553ef390bc60423b70777912447dc3d9b5a9e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RecipeBuilder {\n    public static final String DEFAULT_NAME = \"Ham Sandwich\";\n    public static final List<Ingredient> DEFAULT_INGREDIENT_LIST = List.of(new Ingredient(\"bread, 2 slices\"),\n            new Ingredient(\"ham, 1 slice\"));\n    public static final List<Instruction> DEFAULT_INSTRUCTION_LIST = List.of(\n            new Instruction(\"place ham between \" + \"slices of bread\"), new Instruction(\"eat\"));\n    public static final Photograph DEFAULT_PHOTOGRAPH = Photograph.PLACEHOLDER_PHOTOGRAPH;\n    public static final String DEFAULT_CALORIE = \"300\";\n    public static final int DEFAULT_SERVING = 1;\n    public static final int DEFAULT_RATING = 3;\n    public static final int DEFAULT_DIFFICULTY = 3;\n    private Name name;\n    private IngredientList ingredients;\n    private InstructionList instructions;\n    private Photograph photograph;\n    private Calorie calorie;\n    private Serving serving;\n    private Rating rating;\n    private Difficulty difficulty;\n    private Time timing;\n    private Set<Tag> tags;\n    private Recipe recipe;\n    public RecipeBuilder() {\n        name = new Name(DEFAULT_NAME);\n        ingredients = new IngredientList(DEFAULT_INGREDIENT_LIST);\n        instructions = new InstructionList(DEFAULT_INSTRUCTION_LIST);\n        photograph = DEFAULT_PHOTOGRAPH;\n        calorie = new Calorie(DEFAULT_CALORIE);\n        serving = new Serving(DEFAULT_SERVING);\n        rating = new Rating(DEFAULT_RATING);\n        difficulty = new Difficulty(DEFAULT_DIFFICULTY);\n        tags = new HashSet<>();\n    }\n    /**\n     * Initializes the RecipeBuilder with the data of {@code recipeToCopy}.\n     */\n    public RecipeBuilder(Recipe recipeToCopy) {\n        name = recipeToCopy.getName();\n        ingredients = recipeToCopy.getIngredients();\n        instructions = recipeToCopy.getInstructions();\n        photograph = recipeToCopy.getPhotograph();\n        calorie = recipeToCopy.getCalorie();\n        serving = recipeToCopy.getServing();\n        rating = recipeToCopy.getRating();\n        difficulty = recipeToCopy.getDifficulty();\n        tags = new HashSet<>(recipeToCopy.getTags());\n    }\n    /**\n     * Sets the {@code Name} of the {@code Recipe} that we are building.\n     */\n    public RecipeBuilder withName(String name) {\n        this.name = new Name(name);\n        return this;\n    }\n    /**\n     * Parses the {@code tags} into a {@code Set<Tag>} and set it to the {@code Recipe} that we are building.\n     */\n    public RecipeBuilder withTags(String... tags) {\n        this.tags = SampleDataUtil.getTagSet(tags);\n        return this;\n    }\n    /**\n     * Sets the {@code IngredientList} of the {@code Recipe} that we are building.\n     */\n    public RecipeBuilder withIngredients(String ingredients) {\n        List<Ingredient> ingredientList =\n                Stream.of(ingredients.trim().split(\";\")).map(String::trim).map(Ingredient::new)\n                        .collect(Collectors.toList());\n        this.ingredients = new IngredientList(ingredientList);\n        return this;\n    }\n    /**\n     * Sets the {@code InstructionList} of the {@code Recipe} that we are building.\n     */\n    public RecipeBuilder withInstructions(String instructions) {\n        List<Instruction> instructionList = (Stream.of(instructions.trim().split(\";\")).map(String::trim)\n                .map(Instruction::new).collect(Collectors.toList()));\n        this.instructions = new InstructionList(instructionList);\n        return this;\n    }\n    /**\n     * Sets the {@code Photograph} of the {@code Recipe} that we are building.\n     */\n    public RecipeBuilder withPhotograph(String photograph) {\n        Photograph ph;\n        try {\n            ph = new Photograph(photograph);\n        } catch (IOException e) {\n            return this;\n        }\n        this.photograph = ph;\n        return this;\n    }\n    /**\n     * Sets the {@code Calorie} of the {@code Recipe} that we are building.\n     */\n    public RecipeBuilder withCalorie(String calorie) {\n        this.calorie = new Calorie(calorie);\n        return this;\n    }\n    /**\n     * Sets the {@code Serving} of the {@code Recipe} that we are building.\n     */\n    public RecipeBuilder withServing(int serving) {\n        this.serving = new Serving(serving);\n        return this;\n    }\n    /**\n     * Sets the {@code Rating} of the {@code Recipe} that we are building.\n     */\n    public RecipeBuilder withRating(int rating) {\n        this.rating = new Rating(rating);\n        return this;\n    }\n    /**\n     * Sets the {@code Difficulty} of the {@code Recipe} that we are building.\n     */\n    public RecipeBuilder withDifficulty(int difficulty) {\n        this.difficulty = new Difficulty(difficulty);\n        return this;\n    }\n    /**\n     * builds a Recipe.\n     * @return the Recipe.\n     */\n    public Recipe build() {\n        Recipe toReturn = new Recipe(name, ingredients, instructions, photograph, calorie, serving, rating, difficulty,\n                tags);\n        return toReturn;\n    }\n    /**\n     * adds a time to the recipe.\n     * @param h the hour component of the time.\n     * @param m the minute component of the time.\n     * @param s the second component of the time.\n     * @return\n     */\n    public RecipeBuilder addTime(int h, int m, int s) {\n        this.timing = new Time(h, m, s);\n        return this;\n    }\n"]]}
{"hexsha": "315dc5b716520499b640778d8d95dea295c56069", "ext": "java", "lang": "Java", "content": "public class ItemAdapter extends PagedListAdapter<Image, ItemAdapter.ItemViewHolder> {\n\n    private static DiffUtil.ItemCallback<Image> DIFF_CALLBACK =\n            new DiffUtil.ItemCallback<Image>() {\n                @Override\n                public boolean areItemsTheSame(Image oldItem, Image newItem) {\n                    return oldItem.getId() == newItem.getId();\n                }\n\n                @Override\n                public boolean areContentsTheSame(Image oldItem, Image newItem) {\n                    return oldItem.equals(newItem);\n                }\n            };\n    private Context mCtx;\n\n    public ItemAdapter(Context mCtx) {\n        super(DIFF_CALLBACK);\n        this.mCtx = mCtx;\n    }\n\n    @NonNull\n    @Override\n    public ItemViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {\n        View view = LayoutInflater.from(mCtx).inflate(R.layout.image_layout, parent, false);\n        return new ItemViewHolder(view);\n    }\n\n    @Override\n    public void onBindViewHolder(@NonNull ItemViewHolder holder, int position) {\n        final Image image = getItem(position);\n        holder.userName.setText(image.getUser().toString());\n        holder.like.setText(image.getLikes().toString());\n        holder.comments.setText(image.getComments().toString());\n\n        Picasso.get()\n                .load(image.getLargeImageURL())\n                .placeholder(R.drawable.shimmer_background)\n                .into(holder.image);\n\n        Transformation transformation = new RoundedTransformationBuilder()\n                .borderColor(Color.BLACK)\n                .borderWidthDp(1)\n                .cornerRadiusDp(30)\n                .oval(false)\n                .build();\n\n        if (!image.getUserImageURL().isEmpty()) {\n            Picasso.get()\n                    .load(image.getUserImageURL())\n                    .fit()\n                    .transform(transformation)\n                    .into(holder.userImage);\n        }\n    }\n\n    class ItemViewHolder extends RecyclerView.ViewHolder {\n\n        TextView userName, like, comments;\n        ImageView image, userImage;\n\n        public ItemViewHolder(View view) {\n            super(view);\n            image = view.findViewById(R.id.image);\n            userImage = view.findViewById(R.id.user_image);\n            userName = view.findViewById(R.id.user);\n            like = view.findViewById(R.id.like);\n            comments = view.findViewById(R.id.comments);\n        }\n    }\n}", "class_id": 0, "repo": "SmartToolFactory/Paging-Library-Tutorials", "file": "External-Tutorial-Paging-REST-ImageGallery/src/main/java/com/paging/com/mysample/homescreen/ItemAdapter.java", "last_update_at": "2020-10-28T12:49:20+00:00", "question_id": "315dc5b716520499b640778d8d95dea295c56069", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ItemAdapter extends PagedListAdapter<Image, ItemAdapter.ItemViewHolder> {\n    private static DiffUtil.ItemCallback<Image> DIFF_CALLBACK =\n            new DiffUtil.ItemCallback<Image>() {\n                @Override\n                public boolean areItemsTheSame(Image oldItem, Image newItem) {\n                    return oldItem.getId() == newItem.getId();\n                }\n                @Override\n                public boolean areContentsTheSame(Image oldItem, Image newItem) {\n                    return oldItem.equals(newItem);\n                }\n            };\n    private Context mCtx;\n    public ItemAdapter(Context mCtx) {\n        super(DIFF_CALLBACK);\n        this.mCtx = mCtx;\n    }\n    @NonNull\n    @Override\n    public ItemViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {\n        View view = LayoutInflater.from(mCtx).inflate(R.layout.image_layout, parent, false);\n        return new ItemViewHolder(view);\n    }\n    @Override\n    public void onBindViewHolder(@NonNull ItemViewHolder holder, int position) {\n        final Image image = getItem(position);\n        holder.userName.setText(image.getUser().toString());\n        holder.like.setText(image.getLikes().toString());\n        holder.comments.setText(image.getComments().toString());\n        Picasso.get()\n                .load(image.getLargeImageURL())\n                .placeholder(R.drawable.shimmer_background)\n                .into(holder.image);\n        Transformation transformation = new RoundedTransformationBuilder()\n                .borderColor(Color.BLACK)\n                .borderWidthDp(1)\n                .cornerRadiusDp(30)\n                .oval(false)\n                .build();\n        if (!image.getUserImageURL().isEmpty()) {\n            Picasso.get()\n                    .load(image.getUserImageURL())\n                    .fit()\n                    .transform(transformation)\n                    .into(holder.userImage);\n        }\n    }\n    class ItemViewHolder extends RecyclerView.ViewHolder {\n        TextView userName, like, comments;\n        ImageView image, userImage;\n        public ItemViewHolder(View view) {\n            super(view);\n            image = view.findViewById(R.id.image);\n            userImage = view.findViewById(R.id.user_image);\n            userName = view.findViewById(R.id.user);\n            like = view.findViewById(R.id.like);\n            comments = view.findViewById(R.id.comments);\n        }\n    }\n"]]}
{"hexsha": "2d42323106644458b214a985ce3e6891d04cec19", "ext": "java", "lang": "Java", "content": "public class PathEval\n{\n    /** Evaluate a path : SPARQL semantics */\n    static public Iterator<Node> eval(Graph graph, Node node, Path path, Context context) {\n        return eval$(graph, node, path, new PathEngineSPARQL(graph, true, context)) ;\n        // return eval$(graph, node, path, new PathEngineN(graph, true)) ;\n    }\n\n    /** Evaluate a path */\n    static public Iterator<Node> evalReverse(Graph graph, Node node, Path path, Context context) {\n        return eval$(graph, node, path, new PathEngineSPARQL(graph, false, context)) ;\n        // return eval$(graph, node, path, new PathEngineN(graph, false)) ;\n    }\n\n    /** Evaluate a path : counting semantics */\n    static public Iterator<Node> evalN(Graph graph, Node node, Path path) {\n        return eval$(graph, node, path, new PathEngineN(graph, true)) ;\n    }\n\n    /** Evaluate a path : counting semantics */\n    static public Iterator<Node> evalReverseN(Graph graph, Node node, Path path) {\n        return eval$(graph, node, path, new PathEngineN(graph, false)) ;\n    }\n\n    /** Evaluate a path : unique results */\n    static public Iterator<Node> eval1(Graph graph, Node node, Path path) {\n        return eval$(graph, node, path, new PathEngine1(graph, true)) ;\n    }\n\n    /** Evaluate a path : unique results */\n    static public Iterator<Node> evalReverse1(Graph graph, Node node, Path path) {\n        return eval$(graph, node, path, new PathEngine1(graph, false)) ;\n    }\n\n    /** Evaluate a path */\n    static void eval$(Graph graph, Node node, Path path, PathEngine engine, Collection<Node> acc) {\n        PathEvaluator evaluator = new PathEvaluator(graph, node, acc, engine) ;\n        path.visit(evaluator) ;\n    }\n\n    /** Evaluate a path */\n    static Iter<Node> eval$(Graph graph, Node node, Path path, PathEngine engine) {\n        Collection<Node> acc = new ArrayList<>() ;\n        eval$(graph, node, path, engine, acc); \n        return Iter.iter(acc) ;\n    }\n}", "class_id": 0, "repo": "m-nakagawa/sample", "file": "jena-3.0.1/jena-arq/src/main/java/org/apache/jena/sparql/path/eval/PathEval.java", "last_update_at": "2020-06-11T12:26:06+00:00", "question_id": "2d42323106644458b214a985ce3e6891d04cec19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PathEval\n{\n    /** Evaluate a path : SPARQL semantics */\n    static public Iterator<Node> eval(Graph graph, Node node, Path path, Context context) {\n        return eval$(graph, node, path, new PathEngineSPARQL(graph, true, context)) ;\n        // return eval$(graph, node, path, new PathEngineN(graph, true)) ;\n    }\n    /** Evaluate a path */\n    static public Iterator<Node> evalReverse(Graph graph, Node node, Path path, Context context) {\n        return eval$(graph, node, path, new PathEngineSPARQL(graph, false, context)) ;\n        // return eval$(graph, node, path, new PathEngineN(graph, false)) ;\n    }\n    /** Evaluate a path : counting semantics */\n    static public Iterator<Node> evalN(Graph graph, Node node, Path path) {\n        return eval$(graph, node, path, new PathEngineN(graph, true)) ;\n    }\n    /** Evaluate a path : counting semantics */\n    static public Iterator<Node> evalReverseN(Graph graph, Node node, Path path) {\n        return eval$(graph, node, path, new PathEngineN(graph, false)) ;\n    }\n    /** Evaluate a path : unique results */\n    static public Iterator<Node> eval1(Graph graph, Node node, Path path) {\n        return eval$(graph, node, path, new PathEngine1(graph, true)) ;\n    }\n    /** Evaluate a path : unique results */\n    static public Iterator<Node> evalReverse1(Graph graph, Node node, Path path) {\n        return eval$(graph, node, path, new PathEngine1(graph, false)) ;\n    }\n    /** Evaluate a path */\n    static void eval$(Graph graph, Node node, Path path, PathEngine engine, Collection<Node> acc) {\n        PathEvaluator evaluator = new PathEvaluator(graph, node, acc, engine) ;\n        path.visit(evaluator) ;\n    }\n    /** Evaluate a path */\n    static Iter<Node> eval$(Graph graph, Node node, Path path, PathEngine engine) {\n        Collection<Node> acc = new ArrayList<>() ;\n        eval$(graph, node, path, engine, acc); \n        return Iter.iter(acc) ;\n    }\n"]]}
{"hexsha": "639803c91bd894ec45208b20531f231b66d75b82", "ext": "java", "lang": "Java", "content": "@RestController\npublic class ContestRankController {\n\n    @Autowired\n    private ContestDao contestDao;\n\n    private final CachedRank cachedRank;\n\n    public ContestRankController(CachedRank cachedRank) {\n        this.cachedRank = cachedRank;\n    }\n\n    @RequestMapping(\"api/contest_rank\")\n    public Object getContestRank(@RequestParam(value = \"offset\",defaultValue = \"0\") Integer offset,\n                                 @RequestParam(value = \"limit\",required = false) Integer limit,\n                                 @RequestParam(\"contest_id\") Integer contest_id,\n                                 @RequestParam(value = \"force_refresh\",required = false) Integer force_refresh,\n                                 @RequestParam(value = \"download_csv\",required = false) Integer download_csv,\n                                 HttpServletRequest request) {\n        if(download_csv!=null&&download_csv!=0){\n            try {\n                User user = Authentication.getUser(request);\n                boolean admin = Authentication.isAdministrator(user);\n                if (user == null || !admin) {\n                    return new ReturnType(\"error\", \"you are not administrator\");\n                }\n                CachedRank.writeCSV(Integer.toString(contest_id),contestDao.getProblemsID(contest_id).size(),cachedRank.getRank(contest_id,0));\n                File file = new File(\"cachedrank/\"+contest_id+\".csv\");\n                Path path = Paths.get(file.getAbsolutePath());\n                ByteArrayResource resource = new ByteArrayResource(Files.readAllBytes(path));\n\n                HttpHeaders headers = new HttpHeaders();\n                headers.add(HttpHeaders.CONTENT_DISPOSITION, \"attachment; filename=\"+contestDao.getContest(contest_id).getTitle()+\"_Rank.csv\");\n\n                return ResponseEntity.ok()\n                        .headers(headers)\n                        .contentLength(file.length())\n                        .contentType(MediaType.parseMediaType(\"application/octet-stream\"))\n                        .body(resource);\n            }catch (Exception e){\n                e.printStackTrace();\n                return new ReturnType<>(\"error\",e.getMessage());\n            }\n        }\n        Integer frozen=contestDao.getFrozen(contest_id);\n        if(frozen==null){\n            frozen=0;\n        }\n//        if (force_refresh !=null && force_refresh !=0) {\n//            cachedRank.refresh(contest_id,frozen);\n//            if(frozen!=0){\n//                cachedRank.refresh(contest_id,0);\n//            }\n//        }\n//        Contest contest=contestDao.getContest(contest_id);\n\n        User user = Authentication.getUser(request);\n        if(Authentication.isAdministrator(user)){\n            frozen=0;\n        }\n        var res = cachedRank.getRank(contest_id,frozen);\n        int end = Math.min(res.size(), offset + limit);\n        return new ReturnType<>(new ReturnListType<>(res.subList(offset, end), res.size()));\n    }\n\n    @GetMapping(\"api/contest_rank/myrank\")\n    public ReturnType<ReturnListType> getMyRank(@RequestParam(\"id\") Integer id,HttpServletRequest request){\n        Integer frozen=contestDao.getFrozen(id);\n        if(frozen==null){\n            frozen=-1000;\n        }\n        User user = Authentication.getUser(request);\n        if(user==null){\n            return new ReturnType<>(new ReturnListType(new ArrayList(),0));\n        }\n        var ranklist=cachedRank.getRank(id,0);\n        ArrayList res=new ArrayList();\n        try {\n            for(var c:ranklist){\n                if(Objects.equals(c.getUser().getId(), user.getId())){\n                    long end=contestDao.getContest(id).getEnd_time().getTime();\n                    try {\n                        Solve solve = (Solve) c.clone();\n                        if (end - frozen * 60 * 1000 < System.currentTimeMillis()) {\n                            solve.setRank(\"?\");\n                        }\n                        res.add(solve);\n                    }catch (Exception e){\n                        e.printStackTrace();\n                    }\n                    return new ReturnType<>(new ReturnListType(res,1));\n                }\n            }\n        }catch (Exception e){\n            return new ReturnType<>(new ReturnListType(new ArrayList(),0));\n        }\n        return new ReturnType<>(new ReturnListType(new ArrayList(),0));\n    }\n\n\n}", "class_id": 0, "repo": "Tert-butyllithium/OnlineJudgeBackend", "file": "src/main/java/edu/sustech/oj_server/controller/ContestRankController.java", "last_update_at": "2020-11-18T09:33:25+00:00", "question_id": "639803c91bd894ec45208b20531f231b66d75b82", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RestController\npublic class ContestRankController {\n    @Autowired\n    private ContestDao contestDao;\n    private final CachedRank cachedRank;\n    public ContestRankController(CachedRank cachedRank) {\n        this.cachedRank = cachedRank;\n    }\n    @RequestMapping(\"api/contest_rank\")\n    public Object getContestRank(@RequestParam(value = \"offset\",defaultValue = \"0\") Integer offset,\n                                 @RequestParam(value = \"limit\",required = false) Integer limit,\n                                 @RequestParam(\"contest_id\") Integer contest_id,\n                                 @RequestParam(value = \"force_refresh\",required = false) Integer force_refresh,\n                                 @RequestParam(value = \"download_csv\",required = false) Integer download_csv,\n                                 HttpServletRequest request) {\n        if(download_csv!=null&&download_csv!=0){\n            try {\n                User user = Authentication.getUser(request);\n                boolean admin = Authentication.isAdministrator(user);\n                if (user == null || !admin) {\n                    return new ReturnType(\"error\", \"you are not administrator\");\n                }\n                CachedRank.writeCSV(Integer.toString(contest_id),contestDao.getProblemsID(contest_id).size(),cachedRank.getRank(contest_id,0));\n                File file = new File(\"cachedrank/\"+contest_id+\".csv\");\n                Path path = Paths.get(file.getAbsolutePath());\n                ByteArrayResource resource = new ByteArrayResource(Files.readAllBytes(path));\n                HttpHeaders headers = new HttpHeaders();\n                headers.add(HttpHeaders.CONTENT_DISPOSITION, \"attachment; filename=\"+contestDao.getContest(contest_id).getTitle()+\"_Rank.csv\");\n                return ResponseEntity.ok()\n                        .headers(headers)\n                        .contentLength(file.length())\n                        .contentType(MediaType.parseMediaType(\"application/octet-stream\"))\n                        .body(resource);\n            }catch (Exception e){\n                e.printStackTrace();\n                return new ReturnType<>(\"error\",e.getMessage());\n            }\n        }\n        Integer frozen=contestDao.getFrozen(contest_id);\n        if(frozen==null){\n            frozen=0;\n        }\n//        if (force_refresh !=null && force_refresh !=0) {\n//            cachedRank.refresh(contest_id,frozen);\n//            if(frozen!=0){\n//                cachedRank.refresh(contest_id,0);\n//            }\n//        }\n//        Contest contest=contestDao.getContest(contest_id);\n        User user = Authentication.getUser(request);\n        if(Authentication.isAdministrator(user)){\n            frozen=0;\n        }\n        var res = cachedRank.getRank(contest_id,frozen);\n        int end = Math.min(res.size(), offset + limit);\n        return new ReturnType<>(new ReturnListType<>(res.subList(offset, end), res.size()));\n    }\n    @GetMapping(\"api/contest_rank/myrank\")\n    public ReturnType<ReturnListType> getMyRank(@RequestParam(\"id\") Integer id,HttpServletRequest request){\n        Integer frozen=contestDao.getFrozen(id);\n        if(frozen==null){\n            frozen=-1000;\n        }\n        User user = Authentication.getUser(request);\n        if(user==null){\n            return new ReturnType<>(new ReturnListType(new ArrayList(),0));\n        }\n        var ranklist=cachedRank.getRank(id,0);\n        ArrayList res=new ArrayList();\n        try {\n            for(var c:ranklist){\n                if(Objects.equals(c.getUser().getId(), user.getId())){\n                    long end=contestDao.getContest(id).getEnd_time().getTime();\n                    try {\n                        Solve solve = (Solve) c.clone();\n                        if (end - frozen * 60 * 1000 < System.currentTimeMillis()) {\n                            solve.setRank(\"?\");\n                        }\n                        res.add(solve);\n                    }catch (Exception e){\n                        e.printStackTrace();\n                    }\n                    return new ReturnType<>(new ReturnListType(res,1));\n                }\n            }\n        }catch (Exception e){\n            return new ReturnType<>(new ReturnListType(new ArrayList(),0));\n        }\n        return new ReturnType<>(new ReturnListType(new ArrayList(),0));\n    }\n"]]}
{"hexsha": "d2ec30e6e006634cd5f430d21eb7bb03fb67ec20", "ext": "java", "lang": "Java", "content": "public class LoopMoveList {\n    public static void main(String[] args) {\n        List list = Arrays.asList(\"one Two three Four five six\".split(\" \"));\n        System.out.println(\"List :\" + list);\n        Collections.rotate(list, 3);\n        System.out.println(\"rotate: \" + list);\n    }\n}", "class_id": 0, "repo": "yaozhu008/practice-java", "file": "src/com/apache/examples/LoopMoveList.java", "last_update_at": "2020-07-31T15:27:35+00:00", "question_id": "d2ec30e6e006634cd5f430d21eb7bb03fb67ec20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LoopMoveList {\n    public static void main(String[] args) {\n        List list = Arrays.asList(\"one Two three Four five six\".split(\" \"));\n        System.out.println(\"List :\" + list);\n        Collections.rotate(list, 3);\n        System.out.println(\"rotate: \" + list);\n    }\n"]]}
{"hexsha": "f14c094307df3bd2ab751f9ce70f0640341c5aa2", "ext": "java", "lang": "Java", "content": "public class p225g23 {\n\n\tpublic static void main(String[] args) \n\t{\n\t\tString str=\"application\",str1=\"\";\n\t\tchar ch,ch1,ch2=' ';\n\t\tint i,j,len;\n\t\tlen=str.length();\n\t\tfor(i=0;i<len;i++)\n\t\t{\n\t\t\tch=str.charAt(i);\n\t\t\tfor(j=i+1;j<len;j++)\n\t\t\t{\n\t\t\t\tch1=str.charAt(j);\n\t\t\t\tif(ch==ch1)\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\tstr1=str1+ch1;\n\t\t\t}\t\t\t\n\t\t}\n\t\tSystem.out.println(str1);//incomplete,,,,,,,,,\n\t}\n\n}", "class_id": 0, "repo": "umar07/class_10_codes", "file": "strings/p225g23.java", "last_update_at": "2020-08-04T05:13:03+00:00", "question_id": "f14c094307df3bd2ab751f9ce70f0640341c5aa2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class p225g23 {\n\tpublic static void main(String[] args) \n\t{\n\t\tString str=\"application\",str1=\"\";\n\t\tchar ch,ch1,ch2=' ';\n\t\tint i,j,len;\n\t\tlen=str.length();\n\t\tfor(i=0;i<len;i++)\n\t\t{\n\t\t\tch=str.charAt(i);\n\t\t\tfor(j=i+1;j<len;j++)\n\t\t\t{\n\t\t\t\tch1=str.charAt(j);\n\t\t\t\tif(ch==ch1)\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\tstr1=str1+ch1;\n\t\t\t}\t\t\t\n\t\t}\n\t\tSystem.out.println(str1);//incomplete,,,,,,,,,\n\t}\n"]]}
{"hexsha": "cb4b061f3d804de1deddc717c8802f759f920a8e", "ext": "java", "lang": "Java", "content": "public class CompraStateFactory {\n\n\tpublic enum Estado {\n\t\tCREADA, EN_ESPERA, VERIFICADA, CANCELADA, ENVIADA\n\t}\n\t\n\tpublic static CompraState buildState(Estado estado, Compra compra) {\n\t\tCompraState cs = null;\n\t\tswitch (estado) {\n\t\t\tcase CREADA:\n\t\t\t\tcs = new CreadaCompraState(compra);\n\t\t\t\tbreak;\n\t\t\tcase EN_ESPERA:\n\t\t\t\tcs = new EnEsperaCompraState(compra);\n\t\t\t\tbreak;\n\t\t\tcase VERIFICADA:\n\t\t\t\tcs =  new VerificadaCompraState(compra);\n\t\t\t\tbreak;\n\t\t\tcase CANCELADA:\n\t\t\t\tcs = new CanceladaCompraState(compra);\n\t\t\t\tbreak;\n\t\t\tcase ENVIADA:\n\t\t\t\tcs = new EnviadaCompraState(compra);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t\treturn cs;\n\t}\n}", "class_id": 0, "repo": "AthanBr/GG", "file": "PatronState/src/main/java/es/com/blogspot/elblogdepicodev/pattern/state/CompraStateFactory.java", "last_update_at": "2020-11-21T08:02:02+00:00", "question_id": "cb4b061f3d804de1deddc717c8802f759f920a8e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CompraStateFactory {\n\tpublic enum Estado {\n\t\tCREADA, EN_ESPERA, VERIFICADA, CANCELADA, ENVIADA\n\t}\n\t\n\tpublic static CompraState buildState(Estado estado, Compra compra) {\n\t\tCompraState cs = null;\n\t\tswitch (estado) {\n\t\t\tcase CREADA:\n\t\t\t\tcs = new CreadaCompraState(compra);\n\t\t\t\tbreak;\n\t\t\tcase EN_ESPERA:\n\t\t\t\tcs = new EnEsperaCompraState(compra);\n\t\t\t\tbreak;\n\t\t\tcase VERIFICADA:\n\t\t\t\tcs =  new VerificadaCompraState(compra);\n\t\t\t\tbreak;\n\t\t\tcase CANCELADA:\n\t\t\t\tcs = new CanceladaCompraState(compra);\n\t\t\t\tbreak;\n\t\t\tcase ENVIADA:\n\t\t\t\tcs = new EnviadaCompraState(compra);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t\treturn cs;\n\t}\n"]]}
{"hexsha": "b44adae5816e4318ec87fca8fd95f1a8ab6bf594", "ext": "java", "lang": "Java", "content": "public class ImgDavaAndAvaForDouYin {\n\n    public static void main(String[] args) {\n        int size = 3;\n        int h = 720;\n        int w = 1280 / size;\n        int x = 0;\n        for (int i = 0; i < size; i++) {\n            try {\n                Thumbnails.of(\"/Users/kingtiger/Downloads/Me/\u513f\u7ae5\u6559\u80b2/DaveAndAva/temp/out.jpg\")\n                        .sourceRegion(x, 0, w, h)\n                        .size(w, h)\n                        .outputFormat(\"jpg\")\n                        .keepAspectRatio(false)\n                        .toFile(String.format(\"/Users/kingtiger/Downloads/Me/\u513f\u7ae5\u6559\u80b2/DaveAndAva/temp/out_%s.jpg\", i + 1));\n                x += w;\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n}", "class_id": 0, "repo": "hdwmp123/maven_img_video", "file": "src/main/java/com/king/img/ImgDavaAndAvaForDouYin.java", "last_update_at": "2020-09-15T05:04:47+00:00", "question_id": "b44adae5816e4318ec87fca8fd95f1a8ab6bf594", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ImgDavaAndAvaForDouYin {\n    public static void main(String[] args) {\n        int size = 3;\n        int h = 720;\n        int w = 1280 / size;\n        int x = 0;\n        for (int i = 0; i < size; i++) {\n            try {\n                Thumbnails.of(\"/Users/kingtiger/Downloads/Me/\u513f\u7ae5\u6559\u80b2/DaveAndAva/temp/out.jpg\")\n                        .sourceRegion(x, 0, w, h)\n                        .size(w, h)\n                        .outputFormat(\"jpg\")\n                        .keepAspectRatio(false)\n                        .toFile(String.format(\"/Users/kingtiger/Downloads/Me/\u513f\u7ae5\u6559\u80b2/DaveAndAva/temp/out_%s.jpg\", i + 1));\n                x += w;\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n"]]}
{"hexsha": "1f6b8556310164102fe5227f371459cb58cd68d9", "ext": "java", "lang": "Java", "content": "@WebServlet(\"/SelezionaBar\")\npublic class SelezioneBar extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n\n\n\t/**\n\t * @see HttpServlet#HttpServlet()\n\t */\n\tpublic SelezioneBar() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse\n\t *      response)\n\t */\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\t\tHttpSession ses = request.getSession();\n\t\t\tint ido = Integer.parseInt(request.getParameter(\"ordine\"));\n\t\t\tint idbar = Integer.parseInt(request.getParameter(\"bar\"));\n\t\t\tOrdini o = new Ordini();\n\t\t\tOrdine or = o.bar(ido, idbar);\n\t\t\tif(or==null) {\n\t\t\t\t\n\t\t\t}else {\n\t\t\t\tses.setAttribute(\"IDb\", request.getAttribute(\"ID\"));\n\t\t\t\tOrdineJson ord = new OrdineJson();\n\t\t\t\tord.setId(String.valueOf(ido));\n\t\t\t\tObjectMapper om = new ObjectMapper();\n\t\t\t\tresponse.setContentType(\"application/json\");\n\t\t\t\tresponse.getWriter().append(om.writeValueAsString(ord));\t\t\t\t\n\t\t\t\t}\n\n\t\n\t}\n\n\t/**\n\t * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse\n\t *      response)\n\t */\n\tprotected void doPost(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\tdoGet(request, response);\n\t}\n}", "class_id": 0, "repo": "itsar19-20/bfast", "file": "Progetto colazioni/HTML-JAVA/b.fast.utente/src/main/java/controllers/SelezioneBar.java", "last_update_at": "2020-02-03T09:12:58+00:00", "question_id": "1f6b8556310164102fe5227f371459cb58cd68d9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@WebServlet(\"/SelezionaBar\")\npublic class SelezioneBar extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n\t/**\n\t * @see HttpServlet#HttpServlet()\n\t */\n\tpublic SelezioneBar() {\n\t\tsuper();\n\t}\n\t/**\n\t * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse\n\t *      response)\n\t */\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\t\tHttpSession ses = request.getSession();\n\t\t\tint ido = Integer.parseInt(request.getParameter(\"ordine\"));\n\t\t\tint idbar = Integer.parseInt(request.getParameter(\"bar\"));\n\t\t\tOrdini o = new Ordini();\n\t\t\tOrdine or = o.bar(ido, idbar);\n\t\t\tif(or==null) {\n\t\t\t\t\n\t\t\t}else {\n\t\t\t\tses.setAttribute(\"IDb\", request.getAttribute(\"ID\"));\n\t\t\t\tOrdineJson ord = new OrdineJson();\n\t\t\t\tord.setId(String.valueOf(ido));\n\t\t\t\tObjectMapper om = new ObjectMapper();\n\t\t\t\tresponse.setContentType(\"application/json\");\n\t\t\t\tresponse.getWriter().append(om.writeValueAsString(ord));\t\t\t\t\n\t\t\t\t}\n\t\n\t}\n\t/**\n\t * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse\n\t *      response)\n\t */\n\tprotected void doPost(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\tdoGet(request, response);\n\t}\n"]]}
{"hexsha": "2a1cec440681d6709525614923a49a7328b40bd8", "ext": "java", "lang": "Java", "content": "@Controller\npublic class ServiceController {\n\t\n\t@Autowired ServiceRepository serRepo;\n\t\n\t@GetMapping(\"/service\")\n\tpublic String serviceList(Model model) {\n\t\tvar serviceList = serRepo.getAllPrescence();\n\t\t\n\t\tSystem.out.print(\"serviceList -> serviceList.size()\");\n\t\tSystem.out.println(serviceList.size());\n\t\t\n\t\tmodel.addAttribute(\"serviceList\", serviceList);\n\t\treturn \"serviceList\";\n\t}\n\n}", "class_id": 0, "repo": "crocuscus/client_base", "file": "src/main/java/com/clientbase/controller/ServiceController.java", "last_update_at": "2020-12-02T18:49:16+00:00", "question_id": "2a1cec440681d6709525614923a49a7328b40bd8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Controller\npublic class ServiceController {\n\t\n\t@Autowired ServiceRepository serRepo;\n\t\n\t@GetMapping(\"/service\")\n\tpublic String serviceList(Model model) {\n\t\tvar serviceList = serRepo.getAllPrescence();\n\t\t\n\t\tSystem.out.print(\"serviceList -> serviceList.size()\");\n\t\tSystem.out.println(serviceList.size());\n\t\t\n\t\tmodel.addAttribute(\"serviceList\", serviceList);\n\t\treturn \"serviceList\";\n\t}\n"]]}
{"hexsha": "963ba6a9e64cc1d54e629a947b068148fbc15e85", "ext": "java", "lang": "Java", "content": "public class FreezeCommand extends ExecutedCommand {\n\t@Override\n\tpublic boolean execute(Player player, String playerName, Command cmd,\n\t\t\tString label, String[] args) {\n\t\tif (args.length <= 0) {\n\t\t\tStefsAPI.MessageHandler.buildMessage().addSender(playerName)\n\t\t\t\t\t.setMessage(\"error.notEnoughArguments\", AdminEye.messages)\n\t\t\t\t\t.changeVariable(\"syntax\", \"/freeze <player name>\").build();\n\t\t} else {\n\t\t\tfreezePlayer(player, playerName, args[0]);\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static void freezePlayer(Player player, String playerName,\n\t\t\tString freezePlayerName) {\n\t\tArrayList<Player> freezePlayers = AdminEyeUtils\n\t\t\t\t.requestPlayers(freezePlayerName);\n\t\tif (freezePlayers == null && freezePlayerName != null) {\n\t\t\tStefsAPI.MessageHandler.buildMessage().addSender(playerName)\n\t\t\t\t\t.setMessage(\"error.playerNotFound\", AdminEye.messages)\n\t\t\t\t\t.changeVariable(\"playername\", freezePlayerName).build();\n\t\t\treturn;\n\t\t}\n\n\t\tString frozenPlayers = \"\";\n\n\t\tfor (Player freezePlayer : freezePlayers) {\n\t\t\tPlayerFile playerFile = new PlayerFile(freezePlayer.getName());\n\t\t\tplayerFile.frozenFroze = true;\n\t\t\tplayerFile.save();\n\n\t\t\tfrozenPlayers += \"%A\" + freezePlayer.getName() + \"%N, \";\n\t\t}\n\n\t\tfrozenPlayers = (freezePlayerName.equals(\"*\") ? frozenPlayers = AdminEye.config\n\t\t\t\t.getFile().getString(\"chat.everyone\") + \"%N, \"\n\t\t\t\t: frozenPlayers);\n\n\t\tAdminEye.broadcastAdminEyeMessage(playerName, \"freeze\", \"freeze\",\n\t\t\t\t\"playernames\", frozenPlayers);\n\t}\n}", "class_id": 0, "repo": "Steffion/AdminEye", "file": "src/nl/Steffion/AdminEye/Commands/FreezeCommand.java", "last_update_at": "2020-12-23T12:07:44+00:00", "question_id": "963ba6a9e64cc1d54e629a947b068148fbc15e85", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FreezeCommand extends ExecutedCommand {\n\t@Override\n\tpublic boolean execute(Player player, String playerName, Command cmd,\n\t\t\tString label, String[] args) {\n\t\tif (args.length <= 0) {\n\t\t\tStefsAPI.MessageHandler.buildMessage().addSender(playerName)\n\t\t\t\t\t.setMessage(\"error.notEnoughArguments\", AdminEye.messages)\n\t\t\t\t\t.changeVariable(\"syntax\", \"/freeze <player name>\").build();\n\t\t} else {\n\t\t\tfreezePlayer(player, playerName, args[0]);\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static void freezePlayer(Player player, String playerName,\n\t\t\tString freezePlayerName) {\n\t\tArrayList<Player> freezePlayers = AdminEyeUtils\n\t\t\t\t.requestPlayers(freezePlayerName);\n\t\tif (freezePlayers == null && freezePlayerName != null) {\n\t\t\tStefsAPI.MessageHandler.buildMessage().addSender(playerName)\n\t\t\t\t\t.setMessage(\"error.playerNotFound\", AdminEye.messages)\n\t\t\t\t\t.changeVariable(\"playername\", freezePlayerName).build();\n\t\t\treturn;\n\t\t}\n\t\tString frozenPlayers = \"\";\n\t\tfor (Player freezePlayer : freezePlayers) {\n\t\t\tPlayerFile playerFile = new PlayerFile(freezePlayer.getName());\n\t\t\tplayerFile.frozenFroze = true;\n\t\t\tplayerFile.save();\n\t\t\tfrozenPlayers += \"%A\" + freezePlayer.getName() + \"%N, \";\n\t\t}\n\t\tfrozenPlayers = (freezePlayerName.equals(\"*\") ? frozenPlayers = AdminEye.config\n\t\t\t\t.getFile().getString(\"chat.everyone\") + \"%N, \"\n\t\t\t\t: frozenPlayers);\n\t\tAdminEye.broadcastAdminEyeMessage(playerName, \"freeze\", \"freeze\",\n\t\t\t\t\"playernames\", frozenPlayers);\n\t}\n"]]}
{"hexsha": "24793cc29f2a7a6a9401594fda2c1438d66b21b1", "ext": "java", "lang": "Java", "content": "class MyTrackerEventLogger extends ContextDependentEventLogger\n{\n  MyTrackerEventLogger(@NonNull Application application)\n  {\n    super(application);\n  }\n\n  @Override\n  public void initialize()\n  {\n    initTracker();\n  }\n\n  @Override\n  public void sendTags(@NonNull String tag, @Nullable String[] params)\n  {\n    /* Do nothing */\n  }\n\n  @Override\n  public void logEvent(@NonNull String event, @NonNull Map<String, String> params)\n  {\n    MyTracker.trackEvent(event, params);\n  }\n\n  @Override\n  public void startActivity(@NonNull Activity context)\n  {\n    MyTracker.onStartActivity(context);\n  }\n\n  @Override\n  public void stopActivity(@NonNull Activity context)\n  {\n    MyTracker.onStopActivity(context);\n  }\n\n  private void initTracker()\n  {\n    MyTracker.setDebugMode(BuildConfig.DEBUG);\n    MyTracker.createTracker(PrivateVariables.myTrackerKey(), getApplication());\n    final MyTrackerParams myParams = MyTracker.getTrackerParams();\n    if (myParams != null)\n    {\n      myParams.setDefaultVendorAppPackage();\n      boolean isLocationGranted = PermissionsUtils.isLocationGranted(getApplication());\n      myParams.setTrackingLocationEnabled(isLocationGranted);\n      myParams.setTrackingEnvironmentEnabled(isLocationGranted);\n    }\n    MyTracker.initTracker();\n  }\n}", "class_id": 0, "repo": "vicpopov/omim", "file": "android/src/com/mapswithme/maps/analytics/MyTrackerEventLogger.java", "last_update_at": "2020-11-10T01:13:12+00:00", "question_id": "24793cc29f2a7a6a9401594fda2c1438d66b21b1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class MyTrackerEventLogger extends ContextDependentEventLogger\n{\n  MyTrackerEventLogger(@NonNull Application application)\n  {\n    super(application);\n  }\n  @Override\n  public void initialize()\n  {\n    initTracker();\n  }\n  @Override\n  public void sendTags(@NonNull String tag, @Nullable String[] params)\n  {\n    /* Do nothing */\n  }\n  @Override\n  public void logEvent(@NonNull String event, @NonNull Map<String, String> params)\n  {\n    MyTracker.trackEvent(event, params);\n  }\n  @Override\n  public void startActivity(@NonNull Activity context)\n  {\n    MyTracker.onStartActivity(context);\n  }\n  @Override\n  public void stopActivity(@NonNull Activity context)\n  {\n    MyTracker.onStopActivity(context);\n  }\n  private void initTracker()\n  {\n    MyTracker.setDebugMode(BuildConfig.DEBUG);\n    MyTracker.createTracker(PrivateVariables.myTrackerKey(), getApplication());\n    final MyTrackerParams myParams = MyTracker.getTrackerParams();\n    if (myParams != null)\n    {\n      myParams.setDefaultVendorAppPackage();\n      boolean isLocationGranted = PermissionsUtils.isLocationGranted(getApplication());\n      myParams.setTrackingLocationEnabled(isLocationGranted);\n      myParams.setTrackingEnvironmentEnabled(isLocationGranted);\n    }\n    MyTracker.initTracker();\n  }\n"]]}
{"hexsha": "1e962b0f24615bd7790c68851fd77406e48aa53a", "ext": "java", "lang": "Java", "content": "@RunWith(Parameterized.class)\npublic class TestOneLineFormatterMillisPerformance {\n\n    @Parameterized.Parameters(name = \"{index}: format[{0}]\")\n    public static Collection<Object[]> parameters() {\n\n        List<Object[]> parameterSets = new ArrayList<>();\n\n        parameterSets.add(new String[] { \"dd-MMM-yyyy HH:mm:ss.SSS\" });\n        parameterSets.add(new String[] { \"dd-MMM-yyyy HH:mm:ss.SS\" });\n        parameterSets.add(new String[] { \"dd-MMM-yyyy HH:mm:ss.S\" });\n        parameterSets.add(new String[] { \"dd-MMM-yyyy HH:mm:ss\" });\n        parameterSets.add(new String[] { \"dd-MMM-yyyy HH:mm:ss XXX\" });\n        parameterSets.add(new String[] { \"dd-MMM-yyyy HH:mm:ss.SSSXXX\" });\n        parameterSets.add(new String[] { \"dd-MMM-yyyy HH:mm:ss.SSXXX\" });\n        parameterSets.add(new String[] { \"dd-MMM-yyyy HH:mm:ss.SXXX\" });\n        parameterSets.add(new String[] { \"SSS dd-MMM-yyyy HH:mm:ss\" });\n        parameterSets.add(new String[] { \"SS dd-MMM-yyyy HH:mm:ss\" });\n        parameterSets.add(new String[] { \"S dd-MMM-yyyy HH:mm:ss\" });\n\n        return parameterSets;\n    }\n\n\n    @Parameter(0)\n    public String timestampFormat;\n\n    @Test\n    public void testMillisHandling() {\n        OneLineFormatter olf = new OneLineFormatter();\n        olf.setTimeFormat(timestampFormat);\n\n        long timeStamp = System.currentTimeMillis();\n        StringBuilder buf = new StringBuilder(64);\n\n        long start = System.nanoTime();\n        for (int i = 0; i < 10000000; i++) {\n            buf.setLength(0);\n            olf.addTimestamp(buf, timeStamp);\n        }\n        System.out.println(\"Format: [\" + timestampFormat + \"], Output: [\" + buf + \"], Duration: [\" + (System.nanoTime() - start) + \"] ns\");\n    }\n}", "class_id": 0, "repo": "yangfancoming/apache-tomcat-8.5.54-src", "file": "test/org/apache/juli/TestOneLineFormatterMillisPerformance.java", "last_update_at": "2020-05-21T01:21:44+00:00", "question_id": "1e962b0f24615bd7790c68851fd77406e48aa53a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(Parameterized.class)\npublic class TestOneLineFormatterMillisPerformance {\n    @Parameterized.Parameters(name = \"{index}: format[{0}]\")\n    public static Collection<Object[]> parameters() {\n        List<Object[]> parameterSets = new ArrayList<>();\n        parameterSets.add(new String[] { \"dd-MMM-yyyy HH:mm:ss.SSS\" });\n        parameterSets.add(new String[] { \"dd-MMM-yyyy HH:mm:ss.SS\" });\n        parameterSets.add(new String[] { \"dd-MMM-yyyy HH:mm:ss.S\" });\n        parameterSets.add(new String[] { \"dd-MMM-yyyy HH:mm:ss\" });\n        parameterSets.add(new String[] { \"dd-MMM-yyyy HH:mm:ss XXX\" });\n        parameterSets.add(new String[] { \"dd-MMM-yyyy HH:mm:ss.SSSXXX\" });\n        parameterSets.add(new String[] { \"dd-MMM-yyyy HH:mm:ss.SSXXX\" });\n        parameterSets.add(new String[] { \"dd-MMM-yyyy HH:mm:ss.SXXX\" });\n        parameterSets.add(new String[] { \"SSS dd-MMM-yyyy HH:mm:ss\" });\n        parameterSets.add(new String[] { \"SS dd-MMM-yyyy HH:mm:ss\" });\n        parameterSets.add(new String[] { \"S dd-MMM-yyyy HH:mm:ss\" });\n        return parameterSets;\n    }\n    @Parameter(0)\n    public String timestampFormat;\n    @Test\n    public void testMillisHandling() {\n        OneLineFormatter olf = new OneLineFormatter();\n        olf.setTimeFormat(timestampFormat);\n        long timeStamp = System.currentTimeMillis();\n        StringBuilder buf = new StringBuilder(64);\n        long start = System.nanoTime();\n        for (int i = 0; i < 10000000; i++) {\n            buf.setLength(0);\n            olf.addTimestamp(buf, timeStamp);\n        }\n        System.out.println(\"Format: [\" + timestampFormat + \"], Output: [\" + buf + \"], Duration: [\" + (System.nanoTime() - start) + \"] ns\");\n    }\n"]]}
{"hexsha": "af71b46898b0e48473f62f85ac57e4d7ad732427", "ext": "java", "lang": "Java", "content": "public class HeartbeatFieldsTest {\r\n    \r\n    private HeartbeatFields createTestSubject() {\r\n        return new HeartbeatFields();\r\n    }\r\n    \r\n    @Test\r\n    public void testGetAdditionalFields() throws Exception {\r\n        HeartbeatFields testSubject;\r\n        List<AlarmAdditionalInformation> result;\r\n        \r\n        // default test\r\n        testSubject = createTestSubject();\r\n        result = testSubject.getAdditionalFields();\r\n    }\r\n    \r\n    @Test\r\n    public void testSetAdditionalFields() throws Exception {\r\n        HeartbeatFields testSubject;\r\n        List<AlarmAdditionalInformation> additionalFields = null;\r\n        \r\n        \r\n        // default test\r\n        testSubject = createTestSubject();\r\n        testSubject.setAdditionalFields(additionalFields);\r\n    }\r\n    \r\n    @Test\r\n    public void testGetHeartbeatFieldsVersion() throws Exception {\r\n        HeartbeatFields testSubject;\r\n        Double result;\r\n        \r\n        // default test\r\n        testSubject = createTestSubject();\r\n        result = testSubject.getHeartbeatFieldsVersion();\r\n    }\r\n    \r\n    @Test\r\n    public void testSetHeartbeatFieldsVersion() throws Exception {\r\n        HeartbeatFields testSubject;\r\n        Double heartbeatFieldsVersion = null;\r\n        \r\n        \r\n        // default test\r\n        testSubject = createTestSubject();\r\n        testSubject.setHeartbeatFieldsVersion(heartbeatFieldsVersion);\r\n    }\r\n    \r\n    @Test\r\n    public void testGetHeartbeatInterval() throws Exception {\r\n        HeartbeatFields testSubject;\r\n        Integer result;\r\n        \r\n        // default test\r\n        testSubject = createTestSubject();\r\n        result = testSubject.getHeartbeatInterval();\r\n    }\r\n    \r\n    @Test\r\n    public void testSetHeartbeatInterval() throws Exception {\r\n        HeartbeatFields testSubject;\r\n        Integer heartbeatInterval = 0;\r\n        \r\n        \r\n        // default test\r\n        testSubject = createTestSubject();\r\n        testSubject.setHeartbeatInterval(heartbeatInterval);\r\n    }\r\n    \r\n    @Test\r\n    public void testToString() throws Exception {\r\n        HeartbeatFields testSubject;\r\n        String result;\r\n        \r\n        // default test\r\n        testSubject = createTestSubject();\r\n        result = testSubject.toString();\r\n    }\r\n    \r\n    @Test\r\n    public void testGetAdditionalProperties() throws Exception {\r\n        HeartbeatFields testSubject;\r\n        Map<String, Object> result;\r\n        \r\n        // default test\r\n        testSubject = createTestSubject();\r\n        result = testSubject.getAdditionalProperties();\r\n    }\r\n    \r\n    @Test\r\n    public void testSetAdditionalProperty() throws Exception {\r\n        HeartbeatFields testSubject;\r\n        String name = \"\";\r\n        Object value = null;\r\n        \r\n        \r\n        // default test\r\n        testSubject = createTestSubject();\r\n        testSubject.setAdditionalProperty(name, value);\r\n    }\r\n    \r\n    @Test\r\n    public void testHashCode() throws Exception {\r\n        HeartbeatFields testSubject;\r\n        int result;\r\n        \r\n        // default test\r\n        testSubject = createTestSubject();\r\n        result = testSubject.hashCode();\r\n    }\r\n    \r\n    \r\n}", "class_id": 0, "repo": "onap/dcaegen2-services-mapper", "file": "UniversalVesAdapter/src/test/java/org/onap/dcaegen2/ves/domain/ves54/HeartbeatFieldsTest.java", "last_update_at": "2020-03-05T10:00:08+00:00", "question_id": "af71b46898b0e48473f62f85ac57e4d7ad732427", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HeartbeatFieldsTest {\r\n    \r\n    private HeartbeatFields createTestSubject() {\r\n        return new HeartbeatFields();\r\n    }\r\n    \r\n    @Test\r\n    public void testGetAdditionalFields() throws Exception {\r\n        HeartbeatFields testSubject;\r\n        List<AlarmAdditionalInformation> result;\r\n        \r\n        // default test\r\n        testSubject = createTestSubject();\r\n        result = testSubject.getAdditionalFields();\r\n    }\r\n    \r\n    @Test\r\n    public void testSetAdditionalFields() throws Exception {\r\n        HeartbeatFields testSubject;\r\n        List<AlarmAdditionalInformation> additionalFields = null;\r\n        \r\n        \r\n        // default test\r\n        testSubject = createTestSubject();\r\n        testSubject.setAdditionalFields(additionalFields);\r\n    }\r\n    \r\n    @Test\r\n    public void testGetHeartbeatFieldsVersion() throws Exception {\r\n        HeartbeatFields testSubject;\r\n        Double result;\r\n        \r\n        // default test\r\n        testSubject = createTestSubject();\r\n        result = testSubject.getHeartbeatFieldsVersion();\r\n    }\r\n    \r\n    @Test\r\n    public void testSetHeartbeatFieldsVersion() throws Exception {\r\n        HeartbeatFields testSubject;\r\n        Double heartbeatFieldsVersion = null;\r\n        \r\n        \r\n        // default test\r\n        testSubject = createTestSubject();\r\n        testSubject.setHeartbeatFieldsVersion(heartbeatFieldsVersion);\r\n    }\r\n    \r\n    @Test\r\n    public void testGetHeartbeatInterval() throws Exception {\r\n        HeartbeatFields testSubject;\r\n        Integer result;\r\n        \r\n        // default test\r\n        testSubject = createTestSubject();\r\n        result = testSubject.getHeartbeatInterval();\r\n    }\r\n    \r\n    @Test\r\n    public void testSetHeartbeatInterval() throws Exception {\r\n        HeartbeatFields testSubject;\r\n        Integer heartbeatInterval = 0;\r\n        \r\n        \r\n        // default test\r\n        testSubject = createTestSubject();\r\n        testSubject.setHeartbeatInterval(heartbeatInterval);\r\n    }\r\n    \r\n    @Test\r\n    public void testToString() throws Exception {\r\n        HeartbeatFields testSubject;\r\n        String result;\r\n        \r\n        // default test\r\n        testSubject = createTestSubject();\r\n        result = testSubject.toString();\r\n    }\r\n    \r\n    @Test\r\n    public void testGetAdditionalProperties() throws Exception {\r\n        HeartbeatFields testSubject;\r\n        Map<String, Object> result;\r\n        \r\n        // default test\r\n        testSubject = createTestSubject();\r\n        result = testSubject.getAdditionalProperties();\r\n    }\r\n    \r\n    @Test\r\n    public void testSetAdditionalProperty() throws Exception {\r\n        HeartbeatFields testSubject;\r\n        String name = \"\";\r\n        Object value = null;\r\n        \r\n        \r\n        // default test\r\n        testSubject = createTestSubject();\r\n        testSubject.setAdditionalProperty(name, value);\r\n    }\r\n    \r\n    @Test\r\n    public void testHashCode() throws Exception {\r\n        HeartbeatFields testSubject;\r\n        int result;\r\n        \r\n        // default test\r\n        testSubject = createTestSubject();\r\n        result = testSubject.hashCode();\r\n    }\r\n    \r\n    \r\n"]]}
{"hexsha": "fa1e8aba6a0f9bfdcf103880ce82d9bf370584dd", "ext": "java", "lang": "Java", "content": "@Data\npublic class ArticlesDto implements Serializable {\n\n\n    private int id;\n    private String title;\n    private String body;\n    private Date created_at;\n    private Date updated_at;\n    private Integer topic_id;\n    private Integer user_id;\n    private String what_changed;\n\n    private TopicsDto topic;\n    private UsersDto user;\n\n\n    public ArticlesDto() {\n    }\n\n    public ArticlesDto(int id, String title, String body, int topic_id, int user_id) {\n        this.id = id;\n        this.title = title;\n        this.body = body;\n        this.topic_id = topic_id;\n        this.user_id = user_id;\n    }\n\n    public ArticlesDto(String title, String body, int topic_id, int user_id) {\n        this.title = title;\n        this.body = body;\n        this.topic_id = topic_id;\n        this.user_id = user_id;\n    }\n\n    public ArticlesDto(int id, String title, String body, int topic_id, int user_id, String what_changed) {\n        this.id=id;\n        this.title = title;\n        this.body = body;\n        this.topic_id = topic_id;\n        this.user_id = user_id;\n        this.what_changed = what_changed;\n\n    }\n\n\n    /**\n     * ArticlesDto to Articles\n     *\n     * @return articles\n     */\n    public Articles convertToArticles() {\n        Articles articles = new Articles();\n        articles.setId(this.id);\n        articles.setTitle(this.title);\n        articles.setBody(this.body);\n        articles.setUsersByUserId(new Users(this.user_id));\n        articles.setTopicsByTopicId(new Topics(this.topic_id));\n        // articles.setTopicId(this.topic_id);\n        // articles.setUserId(this.user_id);\n        articles.setWhatChanged(this.what_changed);\n        return articles;\n    }\n\n\n    /**\n     * ArticlesDto List to Articles List\n     *\n     * @param articlesDtoList\n     * @return articlesList\n     */\n    public static List<Articles> convertToArticlesList(List<ArticlesDto> articlesDtoList) {\n\n        List<Articles> articlesList = new ArrayList<>();\n\n        for (ArticlesDto articlesDto : articlesDtoList) {\n            articlesList.add(articlesDto.convertToArticles());\n        }\n        return articlesList;\n    }\n\n\n    /**\n     * Articles to ArticlesDto\n     *\n     * @param articles\n     * @return articlesDto\n     */\n    public static ArticlesDto convertFromArticles(Articles articles) {\n        ArticlesDto articlesDto = new ArticlesDto();\n        articlesDto.setId(articles.getId());\n        articlesDto.setTitle(articles.getTitle());\n        articlesDto.setBody(articles.getBody());\n        articlesDto.setCreated_at(articles.getCreatedAt());\n        articlesDto.setUpdated_at(articles.getUpdatedAt());\n        articlesDto.setTopic_id(articles.getTopicsByTopicId().getId());\n        articlesDto.setUser_id(articles.getUsersByUserId().getId());\n        // articlesDto.setTopic_id(articles.getTopicId());\n        //  articlesDto.setUser_id(articles.getUserId());\n        articlesDto.setWhat_changed(articles.getWhatChanged());\n\n        articlesDto.setUser(UsersDto.convertFromUsers(articles.getUsersByUserId()));\n        articlesDto.setTopic(\n                TopicsDto.convertFromTopics(articles.getTopicsByTopicId())\n        );\n        return articlesDto;\n\n    }\n\n\n    /**\n     * Articles List to    ArticlesDto List\n     *\n     * @param articlesList\n     * @return articlesDtoList\n     */\n    public static List<ArticlesDto> convertFromArticlesList(List<Articles> articlesList) {\n\n        List<ArticlesDto> articlesDtoList = new ArrayList<>();\n\n        for (Articles articles : articlesList) {\n            ArticlesDto articlesDtoItem = convertFromArticles(articles);\n            articlesDtoList.add(articlesDtoItem);\n        }\n        return articlesDtoList;\n    }\n\n\n}", "class_id": 0, "repo": "volunL/Matterwiki4j", "file": "matterwiki-4j-boot/src/main/java/com/brainboom/matterwiki4jboot/dto/ArticlesDto.java", "last_update_at": "2020-12-31T01:16:57+00:00", "question_id": "fa1e8aba6a0f9bfdcf103880ce82d9bf370584dd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Data\npublic class ArticlesDto implements Serializable {\n    private int id;\n    private String title;\n    private String body;\n    private Date created_at;\n    private Date updated_at;\n    private Integer topic_id;\n    private Integer user_id;\n    private String what_changed;\n    private TopicsDto topic;\n    private UsersDto user;\n    public ArticlesDto() {\n    }\n    public ArticlesDto(int id, String title, String body, int topic_id, int user_id) {\n        this.id = id;\n        this.title = title;\n        this.body = body;\n        this.topic_id = topic_id;\n        this.user_id = user_id;\n    }\n    public ArticlesDto(String title, String body, int topic_id, int user_id) {\n        this.title = title;\n        this.body = body;\n        this.topic_id = topic_id;\n        this.user_id = user_id;\n    }\n    public ArticlesDto(int id, String title, String body, int topic_id, int user_id, String what_changed) {\n        this.id=id;\n        this.title = title;\n        this.body = body;\n        this.topic_id = topic_id;\n        this.user_id = user_id;\n        this.what_changed = what_changed;\n    }\n    /**\n     * ArticlesDto to Articles\n     *\n     * @return articles\n     */\n    public Articles convertToArticles() {\n        Articles articles = new Articles();\n        articles.setId(this.id);\n        articles.setTitle(this.title);\n        articles.setBody(this.body);\n        articles.setUsersByUserId(new Users(this.user_id));\n        articles.setTopicsByTopicId(new Topics(this.topic_id));\n        // articles.setTopicId(this.topic_id);\n        // articles.setUserId(this.user_id);\n        articles.setWhatChanged(this.what_changed);\n        return articles;\n    }\n    /**\n     * ArticlesDto List to Articles List\n     *\n     * @param articlesDtoList\n     * @return articlesList\n     */\n    public static List<Articles> convertToArticlesList(List<ArticlesDto> articlesDtoList) {\n        List<Articles> articlesList = new ArrayList<>();\n        for (ArticlesDto articlesDto : articlesDtoList) {\n            articlesList.add(articlesDto.convertToArticles());\n        }\n        return articlesList;\n    }\n    /**\n     * Articles to ArticlesDto\n     *\n     * @param articles\n     * @return articlesDto\n     */\n    public static ArticlesDto convertFromArticles(Articles articles) {\n        ArticlesDto articlesDto = new ArticlesDto();\n        articlesDto.setId(articles.getId());\n        articlesDto.setTitle(articles.getTitle());\n        articlesDto.setBody(articles.getBody());\n        articlesDto.setCreated_at(articles.getCreatedAt());\n        articlesDto.setUpdated_at(articles.getUpdatedAt());\n        articlesDto.setTopic_id(articles.getTopicsByTopicId().getId());\n        articlesDto.setUser_id(articles.getUsersByUserId().getId());\n        // articlesDto.setTopic_id(articles.getTopicId());\n        //  articlesDto.setUser_id(articles.getUserId());\n        articlesDto.setWhat_changed(articles.getWhatChanged());\n        articlesDto.setUser(UsersDto.convertFromUsers(articles.getUsersByUserId()));\n        articlesDto.setTopic(\n                TopicsDto.convertFromTopics(articles.getTopicsByTopicId())\n        );\n        return articlesDto;\n    }\n    /**\n     * Articles List to    ArticlesDto List\n     *\n     * @param articlesList\n     * @return articlesDtoList\n     */\n    public static List<ArticlesDto> convertFromArticlesList(List<Articles> articlesList) {\n        List<ArticlesDto> articlesDtoList = new ArrayList<>();\n        for (Articles articles : articlesList) {\n            ArticlesDto articlesDtoItem = convertFromArticles(articles);\n            articlesDtoList.add(articlesDtoItem);\n        }\n        return articlesDtoList;\n    }\n"]]}
{"hexsha": "2700adf2ca2b8ae55e83253cd55075cfceef01f9", "ext": "java", "lang": "Java", "content": "public class GetDNSCustomRRType {\n\n\tpublic static void main(String[] args) {\n\t\tHashMap<ContextOptionName, Object> options = new HashMap<ContextOptionName, Object>();\n\t\toptions.put(ContextOptionName.STUB, true);\n\t\toptions.put(ContextOptionName.DNS_TRANSPORT, 542);\n\t\tfinal IGetDNSContextSync context = GetDNSFactory.createSync(1, options);\n\t\tString queryString = \"getdnsapi.net\";\n\t\tString type = \"A\";\n\t\tHashMap<ExtensionName, Object> extensions = new HashMap<ExtensionName, Object>();\n\t\textensions.put(ExtensionName.DNSSEC_RETURN_STATUS, GetDNSConstants.GETDNS_EXTENSION_TRUE);\n\n\t\ttry {\n\t\t\tHashMap<String, Object> info = context.generalSync(queryString, RRType.valueOf(type), extensions);\n\t\t\tif (info != null) {\n\t\t\t\tif (Integer.parseInt(info.get(\"status\").toString()) == 900) {\n\t\t\t\t\tbyte[] rdataRaw = (byte[]) GetDNSUtil.getObject(info, \"/replies_tree[0]/answer[0]/rdata/rdata_raw\");\n\t\t\t\t\tSystem.out.println(\"Size: \" + rdataRaw.length);\n\t\t\t\t\tSystem.out.println(\"Rdata: \" + bytesToHex(rdataRaw));\n\t\t\t\t}\n\n\t\t\t\telse if (Integer.parseInt(info.get(\"status\").toString()) == 901) {\n\t\t\t\t\tSystem.out.println(\"no such name: \" + queryString + \"with type: \" + type);\n\t\t\t\t} else {\n\n\t\t\t\t\tSystem.out.println(\"Error in query GETDNS Status =\" + info.get(\"status\").toString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"No response form DNS SERVER\");\n\t\t\t}\n\t\t} finally {\n\t\t\tcontext.close();\n\t\t}\n\t\tSystem.exit(0);\n\n\t}\n\n\tfinal protected static char[] hexArray = \"0123456789ABCDEF\".toCharArray();\n\n\tpublic static String bytesToHex(byte[] bytes) {\n\t\tchar[] hexChars = new char[bytes.length * 2];\n\t\tfor (int j = 0; j < bytes.length; j++) {\n\t\t\tint v = bytes[j] & 0xFF;\n\t\t\thexChars[j * 2] = hexArray[v >>> 4];\n\t\t\thexChars[j * 2 + 1] = hexArray[v & 0x0F];\n\t\t}\n\t\treturn new String(hexChars);\n\t}\n\n}", "class_id": 0, "repo": "getdnsapi/getdns-java-bindings", "file": "src/examples/java/com/verisign/getdns/example/GetDNSCustomRRType.java", "last_update_at": "2020-08-25T03:28:45+00:00", "question_id": "2700adf2ca2b8ae55e83253cd55075cfceef01f9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GetDNSCustomRRType {\n\tpublic static void main(String[] args) {\n\t\tHashMap<ContextOptionName, Object> options = new HashMap<ContextOptionName, Object>();\n\t\toptions.put(ContextOptionName.STUB, true);\n\t\toptions.put(ContextOptionName.DNS_TRANSPORT, 542);\n\t\tfinal IGetDNSContextSync context = GetDNSFactory.createSync(1, options);\n\t\tString queryString = \"getdnsapi.net\";\n\t\tString type = \"A\";\n\t\tHashMap<ExtensionName, Object> extensions = new HashMap<ExtensionName, Object>();\n\t\textensions.put(ExtensionName.DNSSEC_RETURN_STATUS, GetDNSConstants.GETDNS_EXTENSION_TRUE);\n\t\ttry {\n\t\t\tHashMap<String, Object> info = context.generalSync(queryString, RRType.valueOf(type), extensions);\n\t\t\tif (info != null) {\n\t\t\t\tif (Integer.parseInt(info.get(\"status\").toString()) == 900) {\n\t\t\t\t\tbyte[] rdataRaw = (byte[]) GetDNSUtil.getObject(info, \"/replies_tree[0]/answer[0]/rdata/rdata_raw\");\n\t\t\t\t\tSystem.out.println(\"Size: \" + rdataRaw.length);\n\t\t\t\t\tSystem.out.println(\"Rdata: \" + bytesToHex(rdataRaw));\n\t\t\t\t}\n\t\t\t\telse if (Integer.parseInt(info.get(\"status\").toString()) == 901) {\n\t\t\t\t\tSystem.out.println(\"no such name: \" + queryString + \"with type: \" + type);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"Error in query GETDNS Status =\" + info.get(\"status\").toString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"No response form DNS SERVER\");\n\t\t\t}\n\t\t} finally {\n\t\t\tcontext.close();\n\t\t}\n\t\tSystem.exit(0);\n\t}\n\tfinal protected static char[] hexArray = \"0123456789ABCDEF\".toCharArray();\n\tpublic static String bytesToHex(byte[] bytes) {\n\t\tchar[] hexChars = new char[bytes.length * 2];\n\t\tfor (int j = 0; j < bytes.length; j++) {\n\t\t\tint v = bytes[j] & 0xFF;\n\t\t\thexChars[j * 2] = hexArray[v >>> 4];\n\t\t\thexChars[j * 2 + 1] = hexArray[v & 0x0F];\n\t\t}\n\t\treturn new String(hexChars);\n\t}\n"]]}
{"hexsha": "2b23716c547598eb58965675e1c8839afd8bc526", "ext": "java", "lang": "Java", "content": "public class QueryLinkefabricFabricCiconfigsResponseUnmarshaller {\n\n\tpublic static QueryLinkefabricFabricCiconfigsResponse unmarshall(QueryLinkefabricFabricCiconfigsResponse queryLinkefabricFabricCiconfigsResponse, UnmarshallerContext _ctx) {\n\t\t\r\n\t\tqueryLinkefabricFabricCiconfigsResponse.setRequestId(_ctx.stringValue(\"QueryLinkefabricFabricCiconfigsResponse.RequestId\"));\r\n\t\tqueryLinkefabricFabricCiconfigsResponse.setResultCode(_ctx.stringValue(\"QueryLinkefabricFabricCiconfigsResponse.ResultCode\"));\r\n\t\tqueryLinkefabricFabricCiconfigsResponse.setResultMessage(_ctx.stringValue(\"QueryLinkefabricFabricCiconfigsResponse.ResultMessage\"));\r\n\t\tqueryLinkefabricFabricCiconfigsResponse.setMessage(_ctx.stringValue(\"QueryLinkefabricFabricCiconfigsResponse.Message\"));\r\n\t\tqueryLinkefabricFabricCiconfigsResponse.setResponseStatusCode(_ctx.longValue(\"QueryLinkefabricFabricCiconfigsResponse.ResponseStatusCode\"));\r\n\t\tqueryLinkefabricFabricCiconfigsResponse.setSuccess(_ctx.booleanValue(\"QueryLinkefabricFabricCiconfigsResponse.Success\"));\r\n\r\n\t\tData data = new Data();\r\n\t\tdata.setDevStage(_ctx.stringValue(\"QueryLinkefabricFabricCiconfigsResponse.Data.DevStage\"));\r\n\t\tdata.setEnv(_ctx.stringValue(\"QueryLinkefabricFabricCiconfigsResponse.Data.Env\"));\r\n\t\tdata.setExtraParams(_ctx.stringValue(\"QueryLinkefabricFabricCiconfigsResponse.Data.ExtraParams\"));\r\n\r\n\t\tList<String> configs = new ArrayList<String>();\r\n\t\tfor (int i = 0; i < _ctx.lengthValue(\"QueryLinkefabricFabricCiconfigsResponse.Data.Configs.Length\"); i++) {\r\n\t\t\tconfigs.add(_ctx.stringValue(\"QueryLinkefabricFabricCiconfigsResponse.Data.Configs[\"+ i +\"]\"));\r\n\t\t}\r\n\t\tdata.setConfigs(configs);\r\n\r\n\t\tList<String> projectConfigs = new ArrayList<String>();\r\n\t\tfor (int i = 0; i < _ctx.lengthValue(\"QueryLinkefabricFabricCiconfigsResponse.Data.ProjectConfigs.Length\"); i++) {\r\n\t\t\tprojectConfigs.add(_ctx.stringValue(\"QueryLinkefabricFabricCiconfigsResponse.Data.ProjectConfigs[\"+ i +\"]\"));\r\n\t\t}\r\n\t\tdata.setProjectConfigs(projectConfigs);\r\n\r\n\t\tList<String> sameRepoAppList = new ArrayList<String>();\r\n\t\tfor (int i = 0; i < _ctx.lengthValue(\"QueryLinkefabricFabricCiconfigsResponse.Data.SameRepoAppList.Length\"); i++) {\r\n\t\t\tsameRepoAppList.add(_ctx.stringValue(\"QueryLinkefabricFabricCiconfigsResponse.Data.SameRepoAppList[\"+ i +\"]\"));\r\n\t\t}\r\n\t\tdata.setSameRepoAppList(sameRepoAppList);\r\n\t\tqueryLinkefabricFabricCiconfigsResponse.setData(data);\n\t \n\t \treturn queryLinkefabricFabricCiconfigsResponse;\n\t}\n}", "class_id": 0, "repo": "cctvzd7/aliyun-openapi-java-sdk", "file": "aliyun-java-sdk-sofa/src/main/java/com/aliyuncs/sofa/transform/v20190815/QueryLinkefabricFabricCiconfigsResponseUnmarshaller.java", "last_update_at": "2020-11-03T01:40:47+00:00", "question_id": "2b23716c547598eb58965675e1c8839afd8bc526", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class QueryLinkefabricFabricCiconfigsResponseUnmarshaller {\n\tpublic static QueryLinkefabricFabricCiconfigsResponse unmarshall(QueryLinkefabricFabricCiconfigsResponse queryLinkefabricFabricCiconfigsResponse, UnmarshallerContext _ctx) {\n\t\t\r\n\t\tqueryLinkefabricFabricCiconfigsResponse.setRequestId(_ctx.stringValue(\"QueryLinkefabricFabricCiconfigsResponse.RequestId\"));\r\n\t\tqueryLinkefabricFabricCiconfigsResponse.setResultCode(_ctx.stringValue(\"QueryLinkefabricFabricCiconfigsResponse.ResultCode\"));\r\n\t\tqueryLinkefabricFabricCiconfigsResponse.setResultMessage(_ctx.stringValue(\"QueryLinkefabricFabricCiconfigsResponse.ResultMessage\"));\r\n\t\tqueryLinkefabricFabricCiconfigsResponse.setMessage(_ctx.stringValue(\"QueryLinkefabricFabricCiconfigsResponse.Message\"));\r\n\t\tqueryLinkefabricFabricCiconfigsResponse.setResponseStatusCode(_ctx.longValue(\"QueryLinkefabricFabricCiconfigsResponse.ResponseStatusCode\"));\r\n\t\tqueryLinkefabricFabricCiconfigsResponse.setSuccess(_ctx.booleanValue(\"QueryLinkefabricFabricCiconfigsResponse.Success\"));\r\n\r\n\t\tData data = new Data();\r\n\t\tdata.setDevStage(_ctx.stringValue(\"QueryLinkefabricFabricCiconfigsResponse.Data.DevStage\"));\r\n\t\tdata.setEnv(_ctx.stringValue(\"QueryLinkefabricFabricCiconfigsResponse.Data.Env\"));\r\n\t\tdata.setExtraParams(_ctx.stringValue(\"QueryLinkefabricFabricCiconfigsResponse.Data.ExtraParams\"));\r\n\r\n\t\tList<String> configs = new ArrayList<String>();\r\n\t\tfor (int i = 0; i < _ctx.lengthValue(\"QueryLinkefabricFabricCiconfigsResponse.Data.Configs.Length\"); i++) {\r\n\t\t\tconfigs.add(_ctx.stringValue(\"QueryLinkefabricFabricCiconfigsResponse.Data.Configs[\"+ i +\"]\"));\r\n\t\t}\r\n\t\tdata.setConfigs(configs);\r\n\r\n\t\tList<String> projectConfigs = new ArrayList<String>();\r\n\t\tfor (int i = 0; i < _ctx.lengthValue(\"QueryLinkefabricFabricCiconfigsResponse.Data.ProjectConfigs.Length\"); i++) {\r\n\t\t\tprojectConfigs.add(_ctx.stringValue(\"QueryLinkefabricFabricCiconfigsResponse.Data.ProjectConfigs[\"+ i +\"]\"));\r\n\t\t}\r\n\t\tdata.setProjectConfigs(projectConfigs);\r\n\r\n\t\tList<String> sameRepoAppList = new ArrayList<String>();\r\n\t\tfor (int i = 0; i < _ctx.lengthValue(\"QueryLinkefabricFabricCiconfigsResponse.Data.SameRepoAppList.Length\"); i++) {\r\n\t\t\tsameRepoAppList.add(_ctx.stringValue(\"QueryLinkefabricFabricCiconfigsResponse.Data.SameRepoAppList[\"+ i +\"]\"));\r\n\t\t}\r\n\t\tdata.setSameRepoAppList(sameRepoAppList);\r\n\t\tqueryLinkefabricFabricCiconfigsResponse.setData(data);\n\t \n\t \treturn queryLinkefabricFabricCiconfigsResponse;\n\t}\n"]]}
{"hexsha": "1a1be5d60cc2bf79fef5aa7cd007b6bf125a990f", "ext": "java", "lang": "Java", "content": "public class TestXAActiveMQProducer {\n\n    public static void main(String[] args) throws JMSException, XAException {\n        XAConnectionFactory xaFactory = new ActiveMQXAConnectionFactory(\"tcp://localhost:61616\");\n        XAConnection xaCon = xaFactory.createXAConnection();\n        xaCon.start();\n\n        Xid xId = createXid(1); // Global transaction ID\n        XASession xaSession = xaCon.createXASession();\n        // XAResource is not in sql/jms package, it is in javax.transaction because it is common for all resource types\n        XAResource xaResource = xaSession.getXAResource();\n\n        // Mark work as started\n        xaResource.start(xId, XAResource.TMNOFLAGS);\n\n        // Work like with regular JMS core\n        Session session = xaSession.getSession();\n        Destination queue = session.createQueue(\"JMS.XA.QUEUE1\");\n        Destination queue2 = session.createQueue(\"JMS.XA.QUEUE2\");\n\n        MessageProducer producer1 = session.createProducer(queue);\n        producer1.send(session.createTextMessage(\"message\"));\n\n        MessageProducer producer2 = session.createProducer(queue2);\n        producer2.send(session.createTextMessage(\"message2\"));\n\n        xaResource.end(xId, XAResource.TMSUCCESS);\n\n        int vote = xaResource.prepare(xId);\n\n        xaResource.rollback(xId);\n\n        if (vote == XAResource.XA_OK) {\n            System.out.println(\"Commit XA transaction\");\n            xaResource.commit(xId, false); // Message goes to both queues\n        } else {\n            System.out.println(\"Rollback XA transaction\");\n            xaResource.rollback(xId); // Message doens't go to any queue\n        }\n\n        session.close();\n\n        xaSession.close();\n        xaCon.close();\n    }\n\n    public static Xid createXid(int bids) {\n        byte[] gid = new byte[1];\n        gid[0] = (byte) 9;\n        byte[] bid = new byte[1];\n        bid[0] = (byte) bids;\n        byte[] gtrid = new byte[64];\n        byte[] bqual = new byte[64];\n        System.arraycopy(gid, 0, gtrid, 0, 1);\n        System.arraycopy(bid, 0, bqual, 0, 1);\n        // TODO can we use any Xid implementation when we do transaction across MySQL and ActiveMQ?\n        return new MysqlXid(gtrid, bqual, 0x1234);\n    }\n}", "class_id": 0, "repo": "luiz158/distributed-transactions", "file": "database-jms-example/src/main/java/com/slisenko/examples/xa/activemq/TestXAActiveMQProducer.java", "last_update_at": "2020-01-24T12:43:47+00:00", "question_id": "1a1be5d60cc2bf79fef5aa7cd007b6bf125a990f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestXAActiveMQProducer {\n    public static void main(String[] args) throws JMSException, XAException {\n        XAConnectionFactory xaFactory = new ActiveMQXAConnectionFactory(\"tcp://localhost:61616\");\n        XAConnection xaCon = xaFactory.createXAConnection();\n        xaCon.start();\n        Xid xId = createXid(1); // Global transaction ID\n        XASession xaSession = xaCon.createXASession();\n        // XAResource is not in sql/jms package, it is in javax.transaction because it is common for all resource types\n        XAResource xaResource = xaSession.getXAResource();\n        // Mark work as started\n        xaResource.start(xId, XAResource.TMNOFLAGS);\n        // Work like with regular JMS core\n        Session session = xaSession.getSession();\n        Destination queue = session.createQueue(\"JMS.XA.QUEUE1\");\n        Destination queue2 = session.createQueue(\"JMS.XA.QUEUE2\");\n        MessageProducer producer1 = session.createProducer(queue);\n        producer1.send(session.createTextMessage(\"message\"));\n        MessageProducer producer2 = session.createProducer(queue2);\n        producer2.send(session.createTextMessage(\"message2\"));\n        xaResource.end(xId, XAResource.TMSUCCESS);\n        int vote = xaResource.prepare(xId);\n        xaResource.rollback(xId);\n        if (vote == XAResource.XA_OK) {\n            System.out.println(\"Commit XA transaction\");\n            xaResource.commit(xId, false); // Message goes to both queues\n        } else {\n            System.out.println(\"Rollback XA transaction\");\n            xaResource.rollback(xId); // Message doens't go to any queue\n        }\n        session.close();\n        xaSession.close();\n        xaCon.close();\n    }\n    public static Xid createXid(int bids) {\n        byte[] gid = new byte[1];\n        gid[0] = (byte) 9;\n        byte[] bid = new byte[1];\n        bid[0] = (byte) bids;\n        byte[] gtrid = new byte[64];\n        byte[] bqual = new byte[64];\n        System.arraycopy(gid, 0, gtrid, 0, 1);\n        System.arraycopy(bid, 0, bqual, 0, 1);\n        // TODO can we use any Xid implementation when we do transaction across MySQL and ActiveMQ?\n        return new MysqlXid(gtrid, bqual, 0x1234);\n    }\n"]]}
{"hexsha": "ec223942ff91067be81344be661e3bec2ac6250a", "ext": "java", "lang": "Java", "content": "public final class AccessToken implements Parcelable {\n  public static final Creator<AccessToken> CREATOR = new Creator<AccessToken>() {\n    public AccessToken createFromParcel(Parcel source) {\n      return new AccessToken(source);\n    }\n\n    public AccessToken[] newArray(int size) {\n      return new AccessToken[size];\n    }\n  };\n  private static final long DEFAULT_TOKEN_REFRESH_INTERVAL = 604800L;\n  private static final int PARCEL_VERSION = 2;\n  private final String accountId;\n  private final String applicationId;\n  private final Date lastRefresh;\n  private final String token;\n  private final long tokenRefreshIntervalInSeconds;\n\n  public AccessToken(@NonNull String token, @NonNull String accountId, @NonNull String applicationId, long tokenRefreshIntervalInSeconds, @Nullable Date lastRefreshTime) {\n    this.token = token;\n    this.accountId = accountId;\n    this.applicationId = applicationId;\n    this.tokenRefreshIntervalInSeconds = tokenRefreshIntervalInSeconds;\n    this.lastRefresh = lastRefreshTime != null ? lastRefreshTime : new Date();\n  }\n\n  private AccessToken(Parcel parcel) {\n    int version = 1;\n\n    try {\n      version = parcel.readInt();\n    } catch (ClassCastException var6) {\n    }\n\n    String toSetToken;\n    try {\n      toSetToken = parcel.readString();\n    } catch (ClassCastException var5) {\n      parcel.readLong();\n      toSetToken = parcel.readString();\n    }\n\n    this.token = toSetToken;\n    this.accountId = parcel.readString();\n    this.lastRefresh = new Date(parcel.readLong());\n    this.applicationId = parcel.readString();\n    if (version == 2) {\n      this.tokenRefreshIntervalInSeconds = parcel.readLong();\n    } else {\n      this.tokenRefreshIntervalInSeconds = 604800L;\n    }\n\n  }\n\n  public String getAccountId() {\n    return this.accountId;\n  }\n\n  public String getApplicationId() {\n    return this.applicationId;\n  }\n\n  public Date getLastRefresh() {\n    return this.lastRefresh;\n  }\n\n  public String getToken() {\n    return this.token;\n  }\n\n  public long getTokenRefreshIntervalSeconds() {\n    return this.tokenRefreshIntervalInSeconds;\n  }\n\n  public String toString() {\n    return \"{AccessToken token:\" + this.tokenToString() + \" accountId:\" + this.accountId + \"}\";\n  }\n\n  public boolean equals(Object other) {\n    if (this == other) {\n      return true;\n    } else if (!(other instanceof AccessToken)) {\n      return false;\n    } else {\n      AccessToken o = (AccessToken) other;\n      return this.tokenRefreshIntervalInSeconds == o.tokenRefreshIntervalInSeconds && Utility.areObjectsEqual(this.accountId, o.accountId) && Utility.areObjectsEqual(this.applicationId, o.applicationId) && Utility.areObjectsEqual(this.lastRefresh, o.lastRefresh) && Utility.areObjectsEqual(this.token, o.token);\n    }\n  }\n\n  public int hashCode() {\n    int result = 17;\n    result = result * 31 + Utility.getHashCode(this.accountId);\n    result = result * 31 + Utility.getHashCode(this.applicationId);\n    result = result * 31 + Utility.getHashCode(this.lastRefresh);\n    result = result * 31 + Utility.getHashCode(this.token);\n    result = result * 31 + Utility.getHashCode(this.tokenRefreshIntervalInSeconds);\n    return result;\n  }\n\n  private String tokenToString() {\n    if (this.token == null) {\n      return \"null\";\n    } else {\n      return AccountKit.getLoggingBehaviors().isEnabled(LoggingBehavior.INCLUDE_ACCESS_TOKENS) ? this.token : \"ACCESS_TOKEN_REMOVED\";\n    }\n  }\n\n  public int describeContents() {\n    return 0;\n  }\n\n  public void writeToParcel(Parcel dest, int flags) {\n    dest.writeInt(2);\n    dest.writeString(this.token);\n    dest.writeString(this.accountId);\n    dest.writeLong(this.lastRefresh.getTime());\n    dest.writeString(this.applicationId);\n    dest.writeLong(this.tokenRefreshIntervalInSeconds);\n  }\n}", "class_id": 0, "repo": "Splash-C0/dinger-unpublished", "file": "account-kit-sdk/src/main/java/com/facebook/accountkit/AccessToken.java", "last_update_at": "2020-08-28T14:01:39+00:00", "question_id": "ec223942ff91067be81344be661e3bec2ac6250a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class AccessToken implements Parcelable {\n  public static final Creator<AccessToken> CREATOR = new Creator<AccessToken>() {\n    public AccessToken createFromParcel(Parcel source) {\n      return new AccessToken(source);\n    }\n    public AccessToken[] newArray(int size) {\n      return new AccessToken[size];\n    }\n  };\n  private static final long DEFAULT_TOKEN_REFRESH_INTERVAL = 604800L;\n  private static final int PARCEL_VERSION = 2;\n  private final String accountId;\n  private final String applicationId;\n  private final Date lastRefresh;\n  private final String token;\n  private final long tokenRefreshIntervalInSeconds;\n  public AccessToken(@NonNull String token, @NonNull String accountId, @NonNull String applicationId, long tokenRefreshIntervalInSeconds, @Nullable Date lastRefreshTime) {\n    this.token = token;\n    this.accountId = accountId;\n    this.applicationId = applicationId;\n    this.tokenRefreshIntervalInSeconds = tokenRefreshIntervalInSeconds;\n    this.lastRefresh = lastRefreshTime != null ? lastRefreshTime : new Date();\n  }\n  private AccessToken(Parcel parcel) {\n    int version = 1;\n    try {\n      version = parcel.readInt();\n    } catch (ClassCastException var6) {\n    }\n    String toSetToken;\n    try {\n      toSetToken = parcel.readString();\n    } catch (ClassCastException var5) {\n      parcel.readLong();\n      toSetToken = parcel.readString();\n    }\n    this.token = toSetToken;\n    this.accountId = parcel.readString();\n    this.lastRefresh = new Date(parcel.readLong());\n    this.applicationId = parcel.readString();\n    if (version == 2) {\n      this.tokenRefreshIntervalInSeconds = parcel.readLong();\n    } else {\n      this.tokenRefreshIntervalInSeconds = 604800L;\n    }\n  }\n  public String getAccountId() {\n    return this.accountId;\n  }\n  public String getApplicationId() {\n    return this.applicationId;\n  }\n  public Date getLastRefresh() {\n    return this.lastRefresh;\n  }\n  public String getToken() {\n    return this.token;\n  }\n  public long getTokenRefreshIntervalSeconds() {\n    return this.tokenRefreshIntervalInSeconds;\n  }\n  public String toString() {\n    return \"{AccessToken token:\" + this.tokenToString() + \" accountId:\" + this.accountId + \"}\";\n  }\n  public boolean equals(Object other) {\n    if (this == other) {\n      return true;\n    } else if (!(other instanceof AccessToken)) {\n      return false;\n    } else {\n      AccessToken o = (AccessToken) other;\n      return this.tokenRefreshIntervalInSeconds == o.tokenRefreshIntervalInSeconds && Utility.areObjectsEqual(this.accountId, o.accountId) && Utility.areObjectsEqual(this.applicationId, o.applicationId) && Utility.areObjectsEqual(this.lastRefresh, o.lastRefresh) && Utility.areObjectsEqual(this.token, o.token);\n    }\n  }\n  public int hashCode() {\n    int result = 17;\n    result = result * 31 + Utility.getHashCode(this.accountId);\n    result = result * 31 + Utility.getHashCode(this.applicationId);\n    result = result * 31 + Utility.getHashCode(this.lastRefresh);\n    result = result * 31 + Utility.getHashCode(this.token);\n    result = result * 31 + Utility.getHashCode(this.tokenRefreshIntervalInSeconds);\n    return result;\n  }\n  private String tokenToString() {\n    if (this.token == null) {\n      return \"null\";\n    } else {\n      return AccountKit.getLoggingBehaviors().isEnabled(LoggingBehavior.INCLUDE_ACCESS_TOKENS) ? this.token : \"ACCESS_TOKEN_REMOVED\";\n    }\n  }\n  public int describeContents() {\n    return 0;\n  }\n  public void writeToParcel(Parcel dest, int flags) {\n    dest.writeInt(2);\n    dest.writeString(this.token);\n    dest.writeString(this.accountId);\n    dest.writeLong(this.lastRefresh.getTime());\n    dest.writeString(this.applicationId);\n    dest.writeLong(this.tokenRefreshIntervalInSeconds);\n  }\n"]]}
{"hexsha": "3761c5ddef33ec41d5f22744fe9138cd0ef2a45b", "ext": "java", "lang": "Java", "content": "public class GroupMemberAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> implements View.OnClickListener {\n\n    private List<GroupMember> memberList = new ArrayList<>();\n    private int iconWidth;\n    private int iconHeight;\n    private int itemPadding;\n    private Context mContext;\n\n    private boolean mEnableCheckMenberInfo;\n    private View.OnClickListener mAddGroupListener;\n\n    private static final int CONTENT = 0;\n    private static final int ADD_BTN = 1;\n\n    public GroupMemberAdapter(Context context, boolean enableCheckMenberInfo, View.OnClickListener listener){\n        itemPadding = AppTools.dip2px(8);\n        iconWidth = (Resources.getSystem().getDisplayMetrics().widthPixels - itemPadding ) / 7;\n        iconHeight = iconWidth;\n        mContext = context;\n        this.mAddGroupListener = listener;\n        this.mEnableCheckMenberInfo = enableCheckMenberInfo;\n    }\n    @Override\n    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        if (viewType == CONTENT){\n            return new LogoNameViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.item_grid_group_member, parent, false));\n        }else {\n            return new AddMemberViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.item_grid_group_member, parent, false));\n        }\n    }\n\n    @Override\n    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\n        if (holder instanceof LogoNameViewHolder){\n\n            LogoNameViewHolder holder1 = (LogoNameViewHolder) holder;\n            GroupMember member = memberList.get(position);\n            holder1.name.setText(member.name);\n\n            holder1.itemView.setPadding( 0,  0,  itemPadding,  0);\n\n            holder1.icon.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));\n            holder1.icon.load(FileURLBuilder.getUserIconUrl(member.account), R.mipmap.lianxiren, 999);\n            holder1.itemView.setTag(member);\n            holder1.itemView.setOnClickListener(this);\n        }else if (holder instanceof AddMemberViewHolder){\n            AddMemberViewHolder holder2 = (AddMemberViewHolder) holder;\n            holder2.imageView.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));\n            holder2.imageView.setOnClickListener(mAddGroupListener);\n            holder2.nameTv.setTextColor(mContext.getResources().getColor(R.color.tex_color_blue_1068ed));\n        }\n    }\n\n    @Override\n    public int getItemViewType(int position) {\n        if (memberList.size() >  5){\n            return position > 4 ? ADD_BTN : CONTENT;\n        }else {\n            return position < memberList.size() ? CONTENT : ADD_BTN;\n        }\n    }\n\n    public void setmEnableCheckMenberInfo(boolean mEnableCheckMenberInfo) {\n        this.mEnableCheckMenberInfo = mEnableCheckMenberInfo;\n        notifyDataSetChanged();\n    }\n\n    boolean isFirstColumn(int pos) {\n        return pos % 5 == 0;\n    }\n\n    boolean isFirstRow(int pos) {\n        return pos < 5 ;\n    }\n\n\n    boolean isLastColumn(int pos) {\n        return (pos+1) % 5 == 0;\n    }\n\n\n    public void addAll(List<GroupMember> list) {\n        if (memberList.equals(list)) {\n            return;\n        }\n        memberList.clear();\n        if (list.size() > 5 ){\n            memberList.addAll(list.subList(0, 5));\n        }else {\n            memberList.addAll(list);\n        }\n\n        notifyDataSetChanged();\n    }\n\n    @Override\n    public long getItemId(int position) {\n        return 0;\n    }\n\n    @Override\n    public int getItemCount() {\n        return memberList.size() + 1;\n    }\n\n\n    @Override\n    public void onClick(View v) {\n        GroupMember member = (GroupMember) v.getTag();\n        Friend friend = FriendRepository.queryFriend(member.account, mListener);\n        if (friend != null){\n            postQueryFriend(friend);\n        }\n    }\n\n    private HttpRequestListener<BasePersonInfoResult> mListener = new HttpRequestListener<BasePersonInfoResult>() {\n        @Override\n        public void onHttpRequestSucceed(BasePersonInfoResult result, OriginalCall call) {\n            if (result.isSuccess()){\n                Friend friend = User.UserToFriend(result.getData());\n                FriendRepository.save(friend);\n                postQueryFriend(friend);\n            }\n        }\n\n        @Override\n        public void onHttpRequestFailure(Exception e, OriginalCall call) {\n\n        }\n    };\n\n    private void postQueryFriend(Friend friend){\n        if (mEnableCheckMenberInfo){\n            Intent intent = new Intent(mContext, PersonInfoActivity.class);\n            intent.putExtra(Friend.class.getName(), friend);\n            mContext.startActivity(intent);\n        }\n    }\n\n    public class AddMemberViewHolder extends RecyclerView.ViewHolder{\n        @BindView(R.id.icon)\n        WebImageView imageView;\n        @BindView(R.id.name)\n        TextView nameTv;\n\n        public AddMemberViewHolder(@NonNull View itemView) {\n            super(itemView);\n            ButterKnife.bind(this, itemView);\n        }\n    }\n}", "class_id": 0, "repo": "hongchun166/jtxt", "file": "app/src/main/java/com/linkb/jstx/adapter/GroupMemberAdapter.java", "last_update_at": "2020-07-27T10:36:28+00:00", "question_id": "3761c5ddef33ec41d5f22744fe9138cd0ef2a45b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GroupMemberAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> implements View.OnClickListener {\n    private List<GroupMember> memberList = new ArrayList<>();\n    private int iconWidth;\n    private int iconHeight;\n    private int itemPadding;\n    private Context mContext;\n    private boolean mEnableCheckMenberInfo;\n    private View.OnClickListener mAddGroupListener;\n    private static final int CONTENT = 0;\n    private static final int ADD_BTN = 1;\n    public GroupMemberAdapter(Context context, boolean enableCheckMenberInfo, View.OnClickListener listener){\n        itemPadding = AppTools.dip2px(8);\n        iconWidth = (Resources.getSystem().getDisplayMetrics().widthPixels - itemPadding ) / 7;\n        iconHeight = iconWidth;\n        mContext = context;\n        this.mAddGroupListener = listener;\n        this.mEnableCheckMenberInfo = enableCheckMenberInfo;\n    }\n    @Override\n    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        if (viewType == CONTENT){\n            return new LogoNameViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.item_grid_group_member, parent, false));\n        }else {\n            return new AddMemberViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.item_grid_group_member, parent, false));\n        }\n    }\n    @Override\n    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\n        if (holder instanceof LogoNameViewHolder){\n            LogoNameViewHolder holder1 = (LogoNameViewHolder) holder;\n            GroupMember member = memberList.get(position);\n            holder1.name.setText(member.name);\n            holder1.itemView.setPadding( 0,  0,  itemPadding,  0);\n            holder1.icon.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));\n            holder1.icon.load(FileURLBuilder.getUserIconUrl(member.account), R.mipmap.lianxiren, 999);\n            holder1.itemView.setTag(member);\n            holder1.itemView.setOnClickListener(this);\n        }else if (holder instanceof AddMemberViewHolder){\n            AddMemberViewHolder holder2 = (AddMemberViewHolder) holder;\n            holder2.imageView.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));\n            holder2.imageView.setOnClickListener(mAddGroupListener);\n            holder2.nameTv.setTextColor(mContext.getResources().getColor(R.color.tex_color_blue_1068ed));\n        }\n    }\n    @Override\n    public int getItemViewType(int position) {\n        if (memberList.size() >  5){\n            return position > 4 ? ADD_BTN : CONTENT;\n        }else {\n            return position < memberList.size() ? CONTENT : ADD_BTN;\n        }\n    }\n    public void setmEnableCheckMenberInfo(boolean mEnableCheckMenberInfo) {\n        this.mEnableCheckMenberInfo = mEnableCheckMenberInfo;\n        notifyDataSetChanged();\n    }\n    boolean isFirstColumn(int pos) {\n        return pos % 5 == 0;\n    }\n    boolean isFirstRow(int pos) {\n        return pos < 5 ;\n    }\n    boolean isLastColumn(int pos) {\n        return (pos+1) % 5 == 0;\n    }\n    public void addAll(List<GroupMember> list) {\n        if (memberList.equals(list)) {\n            return;\n        }\n        memberList.clear();\n        if (list.size() > 5 ){\n            memberList.addAll(list.subList(0, 5));\n        }else {\n            memberList.addAll(list);\n        }\n        notifyDataSetChanged();\n    }\n    @Override\n    public long getItemId(int position) {\n        return 0;\n    }\n    @Override\n    public int getItemCount() {\n        return memberList.size() + 1;\n    }\n    @Override\n    public void onClick(View v) {\n        GroupMember member = (GroupMember) v.getTag();\n        Friend friend = FriendRepository.queryFriend(member.account, mListener);\n        if (friend != null){\n            postQueryFriend(friend);\n        }\n    }\n    private HttpRequestListener<BasePersonInfoResult> mListener = new HttpRequestListener<BasePersonInfoResult>() {\n        @Override\n        public void onHttpRequestSucceed(BasePersonInfoResult result, OriginalCall call) {\n            if (result.isSuccess()){\n                Friend friend = User.UserToFriend(result.getData());\n                FriendRepository.save(friend);\n                postQueryFriend(friend);\n            }\n        }\n        @Override\n        public void onHttpRequestFailure(Exception e, OriginalCall call) {\n        }\n    };\n    private void postQueryFriend(Friend friend){\n        if (mEnableCheckMenberInfo){\n            Intent intent = new Intent(mContext, PersonInfoActivity.class);\n            intent.putExtra(Friend.class.getName(), friend);\n            mContext.startActivity(intent);\n        }\n    }\n    public class AddMemberViewHolder extends RecyclerView.ViewHolder{\n        @BindView(R.id.icon)\n        WebImageView imageView;\n        @BindView(R.id.name)\n        TextView nameTv;\n        public AddMemberViewHolder(@NonNull View itemView) {\n            super(itemView);\n            ButterKnife.bind(this, itemView);\n        }\n    }\n"]]}
{"hexsha": "333f32ee75f5df978a34cd45852eb5a630f4e564", "ext": "java", "lang": "Java", "content": "public class CrossoverSelectionTest {\n\n    /**\n     * Test that candidates selected by the source {@link Selection} are cross-bred.\n     */\n    @Test\n    public void selectCandiates() {\n\n        final Predicate<String> crossIf = cand -> !cand.equals(\"selected\")\n                && !cand.equals(\",\")\n                && !cand.equals(\"and\")\n                && !cand.equals(\"are\")\n                && !cand.equals(\"candidates\")\n                && !cand.equals(\"crossed\");\n\n        final List<Map.Entry<Double, StringCrossBreeding>> candidates = Stream.of\n                (\"ignore\", \"the\", \"dummy\", \"candidates\", \",\", \"they\", \"shall\", \"not\", \"be\", \"selected\", \"and\", \"are\", \"not\", \"crossed\")\n                .map(string -> new StringCrossBreeding(string, crossIf))\n                .map(str -> new AbstractMap.SimpleEntry<>(666d, str))\n                .collect(Collectors.toList());\n\n        final Map<String, String> pairing = new LinkedHashMap<>();\n        pairing.put(\"the\", \"selected\");\n        pairing.put(\"they\", \"are\");\n        pairing.put(\"be\", \"crossed\");\n\n        final String expected = \"the selected candidates , they are selected and are crossed\";\n        final String actual = new CrossoverSelection<StringCrossBreeding>(\n\n                (cand, cands) -> Optional.ofNullable(pairing.get(cand.string))\n                        .map(mapped -> new StringCrossBreeding(mapped, crossIf))\n                .orElse(cand),\n\n\n                // Source selection\n                cands -> cands.stream().map(Map.Entry::getValue)\n                        .filter(cand -> !cand.string.equals(\"ignore\"))\n                        .filter(cand -> !cand.string.equals(\"dummy\"))\n                        .filter(cand -> !cand.string.equals(\"not\"))\n                        .filter(cand -> !cand.string.equals(\"nor\"))\n                        .filter(cand -> !cand.string.equals(\"as\"))\n                        .filter(cand -> !cand.string.equals(\"shall\"))\n                        .filter(cand -> !cand.string.equals(\"be\"))\n        ).selectCandiates(candidates).map(selected -> selected.string)\n                .collect(Collectors.joining(\" \"));\n\n        assertEquals(\"Incorrect selection!\", expected, actual);\n    }\n\n    private final static class StringCrossBreeding implements CrossBreeding<StringCrossBreeding> {\n\n        private final String string;\n        private final Predicate<String> crossIf;\n\n        private StringCrossBreeding(String string, Predicate<String> crossIf) {\n            this.string = string;\n            this.crossIf = crossIf;\n        }\n\n        @Override\n        public StringCrossBreeding cross(StringCrossBreeding mate) {\n            if(!crossIf.test(string)) {\n                return new StringCrossBreeding(string, crossIf);\n            }\n            return new StringCrossBreeding(string + \" \" + mate.string, crossIf);\n        }\n    }\n}", "class_id": 0, "repo": "DrChainsaw/AmpControl", "file": "src/test/java/ampcontrol/model/training/model/evolve/selection/CrossoverSelectionTest.java", "last_update_at": "2020-09-01T08:31:26+00:00", "question_id": "333f32ee75f5df978a34cd45852eb5a630f4e564", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CrossoverSelectionTest {\n    /**\n     * Test that candidates selected by the source {@link Selection} are cross-bred.\n     */\n    @Test\n    public void selectCandiates() {\n        final Predicate<String> crossIf = cand -> !cand.equals(\"selected\")\n                && !cand.equals(\",\")\n                && !cand.equals(\"and\")\n                && !cand.equals(\"are\")\n                && !cand.equals(\"candidates\")\n                && !cand.equals(\"crossed\");\n        final List<Map.Entry<Double, StringCrossBreeding>> candidates = Stream.of\n                (\"ignore\", \"the\", \"dummy\", \"candidates\", \",\", \"they\", \"shall\", \"not\", \"be\", \"selected\", \"and\", \"are\", \"not\", \"crossed\")\n                .map(string -> new StringCrossBreeding(string, crossIf))\n                .map(str -> new AbstractMap.SimpleEntry<>(666d, str))\n                .collect(Collectors.toList());\n        final Map<String, String> pairing = new LinkedHashMap<>();\n        pairing.put(\"the\", \"selected\");\n        pairing.put(\"they\", \"are\");\n        pairing.put(\"be\", \"crossed\");\n        final String expected = \"the selected candidates , they are selected and are crossed\";\n        final String actual = new CrossoverSelection<StringCrossBreeding>(\n                (cand, cands) -> Optional.ofNullable(pairing.get(cand.string))\n                        .map(mapped -> new StringCrossBreeding(mapped, crossIf))\n                .orElse(cand),\n                // Source selection\n                cands -> cands.stream().map(Map.Entry::getValue)\n                        .filter(cand -> !cand.string.equals(\"ignore\"))\n                        .filter(cand -> !cand.string.equals(\"dummy\"))\n                        .filter(cand -> !cand.string.equals(\"not\"))\n                        .filter(cand -> !cand.string.equals(\"nor\"))\n                        .filter(cand -> !cand.string.equals(\"as\"))\n                        .filter(cand -> !cand.string.equals(\"shall\"))\n                        .filter(cand -> !cand.string.equals(\"be\"))\n        ).selectCandiates(candidates).map(selected -> selected.string)\n                .collect(Collectors.joining(\" \"));\n        assertEquals(\"Incorrect selection!\", expected, actual);\n    }\n    private final static class StringCrossBreeding implements CrossBreeding<StringCrossBreeding> {\n        private final String string;\n        private final Predicate<String> crossIf;\n        private StringCrossBreeding(String string, Predicate<String> crossIf) {\n            this.string = string;\n            this.crossIf = crossIf;\n        }\n        @Override\n        public StringCrossBreeding cross(StringCrossBreeding mate) {\n            if(!crossIf.test(string)) {\n                return new StringCrossBreeding(string, crossIf);\n            }\n            return new StringCrossBreeding(string + \" \" + mate.string, crossIf);\n        }\n    }\n"]]}
{"hexsha": "e04cfa39f69e8a248a0f05b7a63558725899d1d0", "ext": "java", "lang": "Java", "content": "public class TradingBalanceRestClient {\n\n    private static final String RESOURCE_PATH = \"/trading/balance\";\n    private static final String REQUEST_URI = HitBtcAPI.BASE_URL + RESOURCE_PATH;\n    private static final Log LOG = LogFactory.getLog(HistoricalOrderRestClient.class);\n\n    public static List<Balance> getBalances(HitBtcAPI hitBtcAPI) {\n        ApiAuthRequest<Balance> apiAuthRequest = new ApiAuthRequest<>(hitBtcAPI);\n        List<Balance> balances = apiAuthRequest.getListRequest(REQUEST_URI, Balance[].class);\n\n        if (balances.isEmpty())\n            LOG.error(\"There was an Error in retrieving Balances\");\n\n        return balances;\n    }\n\n    public static Optional<Balance> getBalance(HitBtcAPI hitBtcAPI, String currency) {\n        List<Balance> balances = getBalances(hitBtcAPI);\n\n        for (Balance singleBalance : balances)\n            if (singleBalance.getCurrency().equals(currency))\n                return Optional.of(singleBalance);\n\n        return Optional.empty();\n    }\n}", "class_id": 0, "repo": "HairstonSolutions/hitbtc-java-client", "file": "src/main/java/com/hairstonsolutions/trading/clients/hitbtc/api/account/TradingBalanceRestClient.java", "last_update_at": "2020-12-07T15:23:59+00:00", "question_id": "e04cfa39f69e8a248a0f05b7a63558725899d1d0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TradingBalanceRestClient {\n    private static final String RESOURCE_PATH = \"/trading/balance\";\n    private static final String REQUEST_URI = HitBtcAPI.BASE_URL + RESOURCE_PATH;\n    private static final Log LOG = LogFactory.getLog(HistoricalOrderRestClient.class);\n    public static List<Balance> getBalances(HitBtcAPI hitBtcAPI) {\n        ApiAuthRequest<Balance> apiAuthRequest = new ApiAuthRequest<>(hitBtcAPI);\n        List<Balance> balances = apiAuthRequest.getListRequest(REQUEST_URI, Balance[].class);\n        if (balances.isEmpty())\n            LOG.error(\"There was an Error in retrieving Balances\");\n        return balances;\n    }\n    public static Optional<Balance> getBalance(HitBtcAPI hitBtcAPI, String currency) {\n        List<Balance> balances = getBalances(hitBtcAPI);\n        for (Balance singleBalance : balances)\n            if (singleBalance.getCurrency().equals(currency))\n                return Optional.of(singleBalance);\n        return Optional.empty();\n    }\n"]]}
{"hexsha": "6f7430e1d2b4a7889fe2339392026a7a91a0e8fb", "ext": "java", "lang": "Java", "content": "public class SettingsActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_settings);\n\n        setTitle(\"Settings\");\n        getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n\n        getFragmentManager().beginTransaction().\n                add(R.id.container,new SettingsFragment()).commit();\n    }\n\n    @Override\n    public boolean onSupportNavigateUp() {\n        finish();\n        return super.onSupportNavigateUp();\n    }\n}", "class_id": 0, "repo": "MC-Team2212/MC-onMusic", "file": "app/src/main/java/com/mc/onmusic_relase/SettingsActivity.java", "last_update_at": "2020-06-03T09:13:02+00:00", "question_id": "6f7430e1d2b4a7889fe2339392026a7a91a0e8fb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SettingsActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_settings);\n        setTitle(\"Settings\");\n        getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        getFragmentManager().beginTransaction().\n                add(R.id.container,new SettingsFragment()).commit();\n    }\n    @Override\n    public boolean onSupportNavigateUp() {\n        finish();\n        return super.onSupportNavigateUp();\n    }\n"]]}
{"hexsha": "164c168bf1b651e868786061cf603a2c0cf599ff", "ext": "java", "lang": "Java", "content": "public class PreviewWindow {\n  @FXML private TextField accessToken;\n  @FXML private Button clipboard;\n  @FXML private Button exit;\n  @FXML private Button refresh;\n  @FXML private Label title;\n\n  private SpotifyUser user;\n\n  @FXML public void initialize() {\n    Platform.runLater(this::loadDetails);\n\n    clipboard.setOnMouseClicked(e -> copyToClipboard());\n    exit.setOnMouseClicked(e -> {\n      final int selection = JOptionPane.showConfirmDialog(null, \"Are you sure you wish to exit?\");\n      if (selection == JOptionPane.YES_OPTION) exitGenerator();\n    });\n  }\n\n  private void exitGenerator() {\n    user.disableTimer();\n    Stage stage = (Stage) clipboard.getScene().getWindow();\n    stage.close();\n  }\n\n  private void copyToClipboard() {\n    copyText();\n    editLabel(\"Copied to clipboard\", 3);\n  }\n\n  private void editLabel(String addOn, int duration) {\n    title.setText(String.format(\"Access Token (%s):\", addOn));\n    final Timeline timeline = new Timeline(new KeyFrame(Duration.seconds(duration), e -> title.setText(\"Access Token:\")));\n    timeline.play();\n  }\n\n  private void copyText() {\n    final Clipboard clipboard = Clipboard.getSystemClipboard();\n    final ClipboardContent content = new ClipboardContent();\n    content.putString(accessToken.getText());\n    clipboard.setContent(content);\n  }\n\n  private void loadDetails() {\n    accessToken.setText(user.getAccessToken());\n    if (user.getExpiryDuration() == null) {\n      System.out.println(\"Unable to refresh tokens due to some unknown error with the expiry duration\");\n      return;\n    }\n    final Timeline timeline = new Timeline(\n      new KeyFrame(Duration.seconds(user.getExpiryDuration() + 1),\n        e -> {\n          JOptionPane.showMessageDialog(null, \"Access Token was refreshed\");\n          editLabel(\"Refreshed\", 5);\n          accessToken.setText(user.getAccessToken());\n        }));\n    timeline.setCycleCount(Animation.INDEFINITE);\n    timeline.play();\n  }\n\n  void setUser(SpotifyUser user) {\n    this.user = user;\n  }\n}", "class_id": 0, "repo": "woojiahao/spotify-access-token-generator", "file": "src/main/java/PreviewWindow.java", "last_update_at": "2020-04-09T13:31:24+00:00", "question_id": "164c168bf1b651e868786061cf603a2c0cf599ff", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PreviewWindow {\n  @FXML private TextField accessToken;\n  @FXML private Button clipboard;\n  @FXML private Button exit;\n  @FXML private Button refresh;\n  @FXML private Label title;\n  private SpotifyUser user;\n  @FXML public void initialize() {\n    Platform.runLater(this::loadDetails);\n    clipboard.setOnMouseClicked(e -> copyToClipboard());\n    exit.setOnMouseClicked(e -> {\n      final int selection = JOptionPane.showConfirmDialog(null, \"Are you sure you wish to exit?\");\n      if (selection == JOptionPane.YES_OPTION) exitGenerator();\n    });\n  }\n  private void exitGenerator() {\n    user.disableTimer();\n    Stage stage = (Stage) clipboard.getScene().getWindow();\n    stage.close();\n  }\n  private void copyToClipboard() {\n    copyText();\n    editLabel(\"Copied to clipboard\", 3);\n  }\n  private void editLabel(String addOn, int duration) {\n    title.setText(String.format(\"Access Token (%s):\", addOn));\n    final Timeline timeline = new Timeline(new KeyFrame(Duration.seconds(duration), e -> title.setText(\"Access Token:\")));\n    timeline.play();\n  }\n  private void copyText() {\n    final Clipboard clipboard = Clipboard.getSystemClipboard();\n    final ClipboardContent content = new ClipboardContent();\n    content.putString(accessToken.getText());\n    clipboard.setContent(content);\n  }\n  private void loadDetails() {\n    accessToken.setText(user.getAccessToken());\n    if (user.getExpiryDuration() == null) {\n      System.out.println(\"Unable to refresh tokens due to some unknown error with the expiry duration\");\n      return;\n    }\n    final Timeline timeline = new Timeline(\n      new KeyFrame(Duration.seconds(user.getExpiryDuration() + 1),\n        e -> {\n          JOptionPane.showMessageDialog(null, \"Access Token was refreshed\");\n          editLabel(\"Refreshed\", 5);\n          accessToken.setText(user.getAccessToken());\n        }));\n    timeline.setCycleCount(Animation.INDEFINITE);\n    timeline.play();\n  }\n  void setUser(SpotifyUser user) {\n    this.user = user;\n  }\n"]]}
{"hexsha": "0e07abac520ed61d2a2bb3517cfcb92874d1b226", "ext": "java", "lang": "Java", "content": "public class DeleteCommentHandlerTest {\n\n\tContext createContext(String apiCall) {\n\t\tTestContext ctx = new TestContext();\n\t\tctx.setFunctionName(apiCall);\n\t\treturn ctx;\n\t}\n\t\n\tvoid testDelete(String incoming, int outgoing, String errMes, int numComments) {\n\t\tDeleteCommentHandler handler = new DeleteCommentHandler();\n\t\tDeleteCommentRequest req = new Gson().fromJson(incoming, DeleteCommentRequest.class);\n\t\tDeleteCommentResponse response = handler.handleRequest(req, createContext(\"deleteComment\"));\n\t\t\n\t\tassertEquals(outgoing, response.getStatusCode());\n\t\tassertEquals(errMes, response.getStatusMessage());\n\t\t\n\t\tGetSnipCommentsHandler handler2 = new GetSnipCommentsHandler();\n\t\tGetSnipCommentsRequest req2 = new Gson().fromJson(\"{\\\"id\\\": \\\"\" + req.snippetID +\"\\\"}\", GetSnipCommentsRequest.class);\n\t\tGetSnipCommentsResponse response2 = handler2.handleRequest(req2, createContext(\"getComments\"));\n\t\t\n\t\tassertEquals(numComments, response2.getComments().size());\n\t}\n\t\n\t@Test\n\tpublic void testDeleteComment() throws Exception {\n\t\tSnippetDAO snipdao = new SnippetDAO();\n\t\tSnippet snip = new Snippet(snipdao.getAllSnippets(), \"password\");\n\t\tsnipdao.addSnippet(snip);\n\n\t\tCommentDAO commdao = new CommentDAO();\n\t\tComment comment = new Comment(commdao.getAllComments(), snip.getID(), 1, 1, \"test\");\n\t\tcommdao.addComment(comment);\n\t\t\n\t\tString incoming = \"{\"\n\t\t\t\t\t\t\t+ \"\\\"snippetID\\\": \\\"\" + snip.getID() + \"\\\",\"\n\t\t\t\t\t\t\t+ \"\\\"id\\\": \\\"\" + comment.getID() + \"\\\",\"\n\t\t\t\t\t\t\t+ \"\\\"password\\\": \\\"\" + snip.getPassword() + \"\\\"\"\n\t\t\t\t\t\t+ \"}\";\n\t\tint sc = 200;\n\t\tString errMes = \"Comment deleted!\";\n\t\tint numComments = 0;\n\t\ttestDelete(incoming, sc, errMes, numComments);\n\t\t\n\t\tsnipdao.deleteSnippet(snip.getID(), snip.getPassword());\n\t\tcommdao = new CommentDAO();\n\t\tcommdao.deleteCommentsBySnippet(snip, snip.getPassword());\n\t\t\n\t}\n\t\n}", "class_id": 0, "repo": "JosuContrer/infinite-monkey-snippet", "file": "src/test/java/com/amazonaws/lambda/demo/DeleteCommentHandlerTest.java", "last_update_at": "2020-12-02T22:42:45+00:00", "question_id": "0e07abac520ed61d2a2bb3517cfcb92874d1b226", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DeleteCommentHandlerTest {\n\tContext createContext(String apiCall) {\n\t\tTestContext ctx = new TestContext();\n\t\tctx.setFunctionName(apiCall);\n\t\treturn ctx;\n\t}\n\t\n\tvoid testDelete(String incoming, int outgoing, String errMes, int numComments) {\n\t\tDeleteCommentHandler handler = new DeleteCommentHandler();\n\t\tDeleteCommentRequest req = new Gson().fromJson(incoming, DeleteCommentRequest.class);\n\t\tDeleteCommentResponse response = handler.handleRequest(req, createContext(\"deleteComment\"));\n\t\t\n\t\tassertEquals(outgoing, response.getStatusCode());\n\t\tassertEquals(errMes, response.getStatusMessage());\n\t\t\n\t\tGetSnipCommentsHandler handler2 = new GetSnipCommentsHandler();\n\t\tGetSnipCommentsRequest req2 = new Gson().fromJson(\"{\\\"id\\\": \\\"\" + req.snippetID +\"\\\"}\", GetSnipCommentsRequest.class);\n\t\tGetSnipCommentsResponse response2 = handler2.handleRequest(req2, createContext(\"getComments\"));\n\t\t\n\t\tassertEquals(numComments, response2.getComments().size());\n\t}\n\t\n\t@Test\n\tpublic void testDeleteComment() throws Exception {\n\t\tSnippetDAO snipdao = new SnippetDAO();\n\t\tSnippet snip = new Snippet(snipdao.getAllSnippets(), \"password\");\n\t\tsnipdao.addSnippet(snip);\n\t\tCommentDAO commdao = new CommentDAO();\n\t\tComment comment = new Comment(commdao.getAllComments(), snip.getID(), 1, 1, \"test\");\n\t\tcommdao.addComment(comment);\n\t\t\n\t\tString incoming = \"{\"\n\t\t\t\t\t\t\t+ \"\\\"snippetID\\\": \\\"\" + snip.getID() + \"\\\",\"\n\t\t\t\t\t\t\t+ \"\\\"id\\\": \\\"\" + comment.getID() + \"\\\",\"\n\t\t\t\t\t\t\t+ \"\\\"password\\\": \\\"\" + snip.getPassword() + \"\\\"\"\n\t\t\t\t\t\t+ \"}\";\n\t\tint sc = 200;\n\t\tString errMes = \"Comment deleted!\";\n\t\tint numComments = 0;\n\t\ttestDelete(incoming, sc, errMes, numComments);\n\t\t\n\t\tsnipdao.deleteSnippet(snip.getID(), snip.getPassword());\n\t\tcommdao = new CommentDAO();\n\t\tcommdao.deleteCommentsBySnippet(snip, snip.getPassword());\n\t\t\n\t}\n\t\n"]]}
{"hexsha": "640a5dafc5c50d19adf023ebe65c9e42673674fd", "ext": "java", "lang": "Java", "content": "public class CurrencyDetailsViewModel extends BaseDisposableViewModel implements BaseViewModel {\n\n    public static final String KEY_CURRENCY_CODE = \"KEY_CURRENCY_CODE\";\n    private GetCurrencySeriesUseCase mGetSeriesUseCase;\n    private boolean mIsProgressVisible;\n    private List<SingleValue> mCurrencySeries;\n    private String mCurrencyCode;\n\n    public CurrencyDetailsViewModel(final GetCurrencySeriesUseCase getSeriesUseCase) {\n        mGetSeriesUseCase = getSeriesUseCase;\n        mCurrencySeries = new ArrayList<>();\n    }\n\n    @Bindable\n    public String getCurrencyCode() {\n        return mCurrencyCode;\n    }\n\n    public void setCurrencyCode(final String currencyCode) {\n        mCurrencyCode = currencyCode;\n        notifyPropertyChanged(BR.currencyCode);\n    }\n\n    @Bindable\n    public List<SingleValue> getCurrencySeries() {\n        return mCurrencySeries;\n    }\n\n    @Override\n    public void onLoad(final Bundle bundle) {\n        checkNotNull(bundle);\n        checkArgument(bundle.containsKey(KEY_CURRENCY_CODE), \"Currency code must be provided to onLoad method\");\n        setCurrencyCode(bundle.getString(KEY_CURRENCY_CODE));\n        performRequest();\n    }\n\n    @Bindable\n    public boolean isProgressVisible() {\n        return mIsProgressVisible;\n    }\n\n    public void setProgressVisible(final boolean progressVisible) {\n        mIsProgressVisible = progressVisible;\n        notifyPropertyChanged(BR.progressVisible);\n    }\n\n    public void performRefresh() {\n        performRequest();\n    }\n\n    private void performRequest() {\n        setProgressVisible(true);\n        Date endDate = new Date();\n        int daysRange = 10;\n        mCurrencySeries.clear();\n        final Calendar calendar = Calendar.getInstance();\n        calendar.setTime(endDate);\n        calendar.add(Calendar.DAY_OF_YEAR, -daysRange);\n        Date from = calendar.getTime();\n        CurrencySeriesParam params = new CurrencySeriesParam(from, endDate, mCurrencyCode);\n        addDisposable(\n                mGetSeriesUseCase.run(params)\n                        .doFinally(() -> {\n                            setProgressVisible(false);\n                            notifyPropertyChanged(BR.currencySeries);\n                        })\n                        .subscribe(currencyData -> {\n                            mCurrencySeries.add(currencyData);\n                        })\n        );\n    }\n\n}", "class_id": 0, "repo": "krokers/exchange-rates-mvvm", "file": "presentation/src/main/java/eu/rampsoftware/er/viewmodel/details/CurrencyDetailsViewModel.java", "last_update_at": "2020-06-21T10:11:10+00:00", "question_id": "640a5dafc5c50d19adf023ebe65c9e42673674fd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CurrencyDetailsViewModel extends BaseDisposableViewModel implements BaseViewModel {\n    public static final String KEY_CURRENCY_CODE = \"KEY_CURRENCY_CODE\";\n    private GetCurrencySeriesUseCase mGetSeriesUseCase;\n    private boolean mIsProgressVisible;\n    private List<SingleValue> mCurrencySeries;\n    private String mCurrencyCode;\n    public CurrencyDetailsViewModel(final GetCurrencySeriesUseCase getSeriesUseCase) {\n        mGetSeriesUseCase = getSeriesUseCase;\n        mCurrencySeries = new ArrayList<>();\n    }\n    @Bindable\n    public String getCurrencyCode() {\n        return mCurrencyCode;\n    }\n    public void setCurrencyCode(final String currencyCode) {\n        mCurrencyCode = currencyCode;\n        notifyPropertyChanged(BR.currencyCode);\n    }\n    @Bindable\n    public List<SingleValue> getCurrencySeries() {\n        return mCurrencySeries;\n    }\n    @Override\n    public void onLoad(final Bundle bundle) {\n        checkNotNull(bundle);\n        checkArgument(bundle.containsKey(KEY_CURRENCY_CODE), \"Currency code must be provided to onLoad method\");\n        setCurrencyCode(bundle.getString(KEY_CURRENCY_CODE));\n        performRequest();\n    }\n    @Bindable\n    public boolean isProgressVisible() {\n        return mIsProgressVisible;\n    }\n    public void setProgressVisible(final boolean progressVisible) {\n        mIsProgressVisible = progressVisible;\n        notifyPropertyChanged(BR.progressVisible);\n    }\n    public void performRefresh() {\n        performRequest();\n    }\n    private void performRequest() {\n        setProgressVisible(true);\n        Date endDate = new Date();\n        int daysRange = 10;\n        mCurrencySeries.clear();\n        final Calendar calendar = Calendar.getInstance();\n        calendar.setTime(endDate);\n        calendar.add(Calendar.DAY_OF_YEAR, -daysRange);\n        Date from = calendar.getTime();\n        CurrencySeriesParam params = new CurrencySeriesParam(from, endDate, mCurrencyCode);\n        addDisposable(\n                mGetSeriesUseCase.run(params)\n                        .doFinally(() -> {\n                            setProgressVisible(false);\n                            notifyPropertyChanged(BR.currencySeries);\n                        })\n                        .subscribe(currencyData -> {\n                            mCurrencySeries.add(currencyData);\n                        })\n        );\n    }\n"]]}
{"hexsha": "8c2f3f6ae803d3df64262670ce5e71f7e94d1434", "ext": "java", "lang": "Java", "content": "final class TracingConnectionConsumer implements ConnectionConsumer {\n  static ConnectionConsumer create(ConnectionConsumer delegate, JmsTracing jmsTracing) {\n    if (delegate == null) throw new NullPointerException(\"connectionConsumer == null\");\n    if (delegate instanceof TracingConnectionConsumer) return delegate;\n    return new TracingConnectionConsumer(delegate, jmsTracing);\n  }\n\n  final ConnectionConsumer delegate;\n  final JmsTracing jmsTracing;\n\n  TracingConnectionConsumer(ConnectionConsumer delegate, JmsTracing jmsTracing) {\n    this.delegate = delegate;\n    this.jmsTracing = jmsTracing;\n  }\n\n  @Override public ServerSessionPool getServerSessionPool() throws JMSException {\n    return TracingServerSessionPool.create(delegate.getServerSessionPool(), jmsTracing);\n  }\n\n  @Override public void close() throws JMSException {\n    delegate.close();\n  }\n}", "class_id": 0, "repo": "IAMTJW/brave", "file": "instrumentation/jms/src/main/java/brave/jms/TracingConnectionConsumer.java", "last_update_at": "2020-11-30T14:52:44+00:00", "question_id": "8c2f3f6ae803d3df64262670ce5e71f7e94d1434", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["final class TracingConnectionConsumer implements ConnectionConsumer {\n  static ConnectionConsumer create(ConnectionConsumer delegate, JmsTracing jmsTracing) {\n    if (delegate == null) throw new NullPointerException(\"connectionConsumer == null\");\n    if (delegate instanceof TracingConnectionConsumer) return delegate;\n    return new TracingConnectionConsumer(delegate, jmsTracing);\n  }\n  final ConnectionConsumer delegate;\n  final JmsTracing jmsTracing;\n  TracingConnectionConsumer(ConnectionConsumer delegate, JmsTracing jmsTracing) {\n    this.delegate = delegate;\n    this.jmsTracing = jmsTracing;\n  }\n  @Override public ServerSessionPool getServerSessionPool() throws JMSException {\n    return TracingServerSessionPool.create(delegate.getServerSessionPool(), jmsTracing);\n  }\n  @Override public void close() throws JMSException {\n    delegate.close();\n  }\n"]]}
{"hexsha": "2c8608a214bd27f28a7f0883fd11afd93a0a8a5d", "ext": "java", "lang": "Java", "content": "public class OrderValidator implements Validator {\n\n    private final Validator addressValidator;\n\n    public OrderValidator(Validator addressValidator) {\n        if (addressValidator == null) {\n            throw new IllegalArgumentException(\n                    \"The supplied [Validator] is required and must not be null.\");\n        }\n        if (!addressValidator.supports(Address.class)) {\n            throw new IllegalArgumentException(\n                    \"The supplied [Validator] must support the validation of [Address] instances.\");\n        }\n        this.addressValidator = addressValidator;\n    }\n\n    @Override\n    public boolean supports(Class<?> clazz) {\n        return Order.class.isAssignableFrom(clazz);\n    }\n\n    @Override\n    public void validate(Object obj, Errors errors) {\n        validateCreditCard((Order) obj, errors);\n        validateBillingAddress((Order) obj, errors);\n        validateShippingAddress((Order) obj, errors);\n    }\n\n    public void validateCreditCard(Order order, Errors errors) {\n        ValidationUtils.rejectIfEmpty(errors, \"cardNumber\", \"required\", new String[]{\"FAKE (!) credit card number\"});\n        ValidationUtils.rejectIfEmpty(errors, \"expireDate\", \"required\", new String[]{\"Expiry date\"});\n        ValidationUtils.rejectIfEmpty(errors, \"cardType\", \"required\", new String[]{\"Card type\"});\n    }\n\n    public void validateBillingAddress(Order order, Errors errors) {\n        ValidationUtils.rejectIfEmpty(errors, \"billToFirstname\", \"required\", new String[]{\"Billing Info: first name\"});\n        ValidationUtils.rejectIfEmpty(errors, \"billToLastname\", \"required\", new String[]{\"Billing Info: last name\"});\n\n        errors.setNestedPath(\"order.billAddress\");\n        ValidationUtils.invokeValidator(this.addressValidator, order.getBillAddress(), errors);\n    }\n\n    public void validateShippingAddress(Order order, Errors errors) {\n        ValidationUtils.rejectIfEmpty(errors, \"shipToFirstname\", \"required\", new String[]{\"Shipping Info: first name\"});\n        ValidationUtils.rejectIfEmpty(errors, \"shipToLastname\", \"required\", new String[]{\"Shipping Info: last name\"});\n\n        errors.setNestedPath(\"order.shipAddress\");\n\n        ValidationUtils.invokeValidator(this.addressValidator, order.getShipAddress(), errors);\n    }\n}", "class_id": 0, "repo": "pizirun/hjpetstore2.0", "file": "src/main/java/org/pprun/hjpetstore/service/validator/OrderValidator.java", "last_update_at": "2020-03-01T03:33:52+00:00", "question_id": "2c8608a214bd27f28a7f0883fd11afd93a0a8a5d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OrderValidator implements Validator {\n    private final Validator addressValidator;\n    public OrderValidator(Validator addressValidator) {\n        if (addressValidator == null) {\n            throw new IllegalArgumentException(\n                    \"The supplied [Validator] is required and must not be null.\");\n        }\n        if (!addressValidator.supports(Address.class)) {\n            throw new IllegalArgumentException(\n                    \"The supplied [Validator] must support the validation of [Address] instances.\");\n        }\n        this.addressValidator = addressValidator;\n    }\n    @Override\n    public boolean supports(Class<?> clazz) {\n        return Order.class.isAssignableFrom(clazz);\n    }\n    @Override\n    public void validate(Object obj, Errors errors) {\n        validateCreditCard((Order) obj, errors);\n        validateBillingAddress((Order) obj, errors);\n        validateShippingAddress((Order) obj, errors);\n    }\n    public void validateCreditCard(Order order, Errors errors) {\n        ValidationUtils.rejectIfEmpty(errors, \"cardNumber\", \"required\", new String[]{\"FAKE (!) credit card number\"});\n        ValidationUtils.rejectIfEmpty(errors, \"expireDate\", \"required\", new String[]{\"Expiry date\"});\n        ValidationUtils.rejectIfEmpty(errors, \"cardType\", \"required\", new String[]{\"Card type\"});\n    }\n    public void validateBillingAddress(Order order, Errors errors) {\n        ValidationUtils.rejectIfEmpty(errors, \"billToFirstname\", \"required\", new String[]{\"Billing Info: first name\"});\n        ValidationUtils.rejectIfEmpty(errors, \"billToLastname\", \"required\", new String[]{\"Billing Info: last name\"});\n        errors.setNestedPath(\"order.billAddress\");\n        ValidationUtils.invokeValidator(this.addressValidator, order.getBillAddress(), errors);\n    }\n    public void validateShippingAddress(Order order, Errors errors) {\n        ValidationUtils.rejectIfEmpty(errors, \"shipToFirstname\", \"required\", new String[]{\"Shipping Info: first name\"});\n        ValidationUtils.rejectIfEmpty(errors, \"shipToLastname\", \"required\", new String[]{\"Shipping Info: last name\"});\n        errors.setNestedPath(\"order.shipAddress\");\n        ValidationUtils.invokeValidator(this.addressValidator, order.getShipAddress(), errors);\n    }\n"]]}
{"hexsha": "db50e644a4c5aeccec24f0037fb71469b2f91429", "ext": "java", "lang": "Java", "content": "public class Table {\n    // region object variables\n    private List<Row> rowList;\n    // endregion\n\n    // region constructors\n    public Table() {\n        this.rowList = new ArrayList<Row>();\n    }\n    // endregion\n\n    // region object methods\n    /**\n     * Direct method for adding a row.\n     * @param row Row to add.\n     */\n    public void addRow(Row row) throws Exception {\n        if(row == null) {\n            throw new Exception(\"Row object is null\");\n        }\n        if(this.rowList == null) {\n            this.rowList = new ArrayList<Row>();\n        }\n        this.rowList.add(row);\n    }\n\n    /**\n     * Direct methods for adding multiple rows.\n     * For each row, the internal method addRow(in row: Row) will called.\n     *\n     * @param rows Multiple objects of type Row.\n     * @throws Exception Thrown, if one row object is null.\n     */\n    public void addRows(Row... rows) throws Exception {\n        for(Row row:rows) {\n            this.addRow(row);\n        }\n    }\n    // endregion\n\n    // region getter & setter\n\n    public List<Row> getRowList() {\n        return rowList;\n    }\n\n    public void setRowList(List<Row> rowList) {\n        this.rowList = rowList;\n    }\n\n    // endregion\n\n    // region nested enum Type\n    public enum Type {\n        Table,\n        DragAndDrop,\n        Support\n    }\n    // endregion\n}", "class_id": 0, "repo": "mls-workshop/MLS-Lernanwendung-Android", "file": "app/src/main/java/Components/Table.java", "last_update_at": "2020-12-20T13:44:11+00:00", "question_id": "db50e644a4c5aeccec24f0037fb71469b2f91429", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Table {\n    // region object variables\n    private List<Row> rowList;\n    // endregion\n    // region constructors\n    public Table() {\n        this.rowList = new ArrayList<Row>();\n    }\n    // endregion\n    // region object methods\n    /**\n     * Direct method for adding a row.\n     * @param row Row to add.\n     */\n    public void addRow(Row row) throws Exception {\n        if(row == null) {\n            throw new Exception(\"Row object is null\");\n        }\n        if(this.rowList == null) {\n            this.rowList = new ArrayList<Row>();\n        }\n        this.rowList.add(row);\n    }\n    /**\n     * Direct methods for adding multiple rows.\n     * For each row, the internal method addRow(in row: Row) will called.\n     *\n     * @param rows Multiple objects of type Row.\n     * @throws Exception Thrown, if one row object is null.\n     */\n    public void addRows(Row... rows) throws Exception {\n        for(Row row:rows) {\n            this.addRow(row);\n        }\n    }\n    // endregion\n    // region getter & setter\n    public List<Row> getRowList() {\n        return rowList;\n    }\n    public void setRowList(List<Row> rowList) {\n        this.rowList = rowList;\n    }\n    // endregion\n    // region nested enum Type\n    public enum Type {\n        Table,\n        DragAndDrop,\n        Support\n    }\n    // endregion\n"]]}
{"hexsha": "e5e4309335c0643774deb9fb42815a1bc17837d4", "ext": "java", "lang": "Java", "content": "public class EdgePreserving implements Filter {\n    public int flags = RECURS_FILTER;\n//    int flags = NORMCONV_FILTER;\n    public float sigma_s = 60;\n    public float sigma_r = 0.4f;\n\n    public int getFlags() {\n        return flags;\n    }\n\n    public void setFlags(int flags) {\n        this.flags = flags;\n    }\n\n    public float getSigma_s() {\n        return sigma_s;\n    }\n\n    public void setSigma_s(float sigma_s) {\n        this.sigma_s = sigma_s;\n    }\n\n    public float getSigma_r() {\n        return sigma_r;\n    }\n\n    public void setSigma_r(float sigma_r) {\n        this.sigma_r = sigma_r;\n    }\n\n    @Override\n    public Mat apply(Mat in) {\n        Mat dst = new Mat();\n        edgePreservingFilter(in, dst, flags, sigma_s, sigma_r);\n        return dst;\n    }\n}", "class_id": 0, "repo": "hellonico/optimized-image-enhanced", "file": "src/main/java/origami/filters/EdgePreserving.java", "last_update_at": "2020-05-29T01:01:54+00:00", "question_id": "e5e4309335c0643774deb9fb42815a1bc17837d4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EdgePreserving implements Filter {\n    public int flags = RECURS_FILTER;\n//    int flags = NORMCONV_FILTER;\n    public float sigma_s = 60;\n    public float sigma_r = 0.4f;\n    public int getFlags() {\n        return flags;\n    }\n    public void setFlags(int flags) {\n        this.flags = flags;\n    }\n    public float getSigma_s() {\n        return sigma_s;\n    }\n    public void setSigma_s(float sigma_s) {\n        this.sigma_s = sigma_s;\n    }\n    public float getSigma_r() {\n        return sigma_r;\n    }\n    public void setSigma_r(float sigma_r) {\n        this.sigma_r = sigma_r;\n    }\n    @Override\n    public Mat apply(Mat in) {\n        Mat dst = new Mat();\n        edgePreservingFilter(in, dst, flags, sigma_s, sigma_r);\n        return dst;\n    }\n"]]}
{"hexsha": "3879eb3512c3d2a7c961ea72f1a35473fe259687", "ext": "java", "lang": "Java", "content": "public class PathSum {\n\n    public List<List<Integer>> pathSum(TreeNode root, int sum) {\n        List<List<Integer>> result = new ArrayList<>();\n        pathSum(root, sum, result, new ArrayList<>());\n        return result;\n    }\n\n    public void pathSum(TreeNode node, int target, List<List<Integer>> result, List<Integer> temp) {\n        if (node == null) {\n            return;\n        }\n        temp.add(node.val);\n        if (node.val == target && node.left == null && node.right == null) {\n            result.add(new ArrayList<>(temp));\n        } else {\n            pathSum(node.left, target - node.val, result, temp);\n            pathSum(node.right, target - node.val, result, temp);\n        }\n        temp.remove(temp.size() - 1);\n    }\n\n    @Test\n    public void case1() {\n        TreeNode root = TreeNode.from(5, 4, 8, 11, null, 13, 4, 7, 2, null, null, 5, 1);\n        int sum = 22;\n        List<List<Integer>> expected = Arrays.asList(Arrays.asList(5, 4, 11, 2), Arrays.asList(5, 8, 4, 5));\n        Assert.assertTrue(CommonUtil.isEquals(expected, pathSum(root, sum)));\n    }\n}", "class_id": 0, "repo": "lindonglin/leetcode", "file": "src/main/java/me/donglin/leetcode/medium/PathSum.java", "last_update_at": "2020-07-12T15:41:22+00:00", "question_id": "3879eb3512c3d2a7c961ea72f1a35473fe259687", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PathSum {\n    public List<List<Integer>> pathSum(TreeNode root, int sum) {\n        List<List<Integer>> result = new ArrayList<>();\n        pathSum(root, sum, result, new ArrayList<>());\n        return result;\n    }\n    public void pathSum(TreeNode node, int target, List<List<Integer>> result, List<Integer> temp) {\n        if (node == null) {\n            return;\n        }\n        temp.add(node.val);\n        if (node.val == target && node.left == null && node.right == null) {\n            result.add(new ArrayList<>(temp));\n        } else {\n            pathSum(node.left, target - node.val, result, temp);\n            pathSum(node.right, target - node.val, result, temp);\n        }\n        temp.remove(temp.size() - 1);\n    }\n    @Test\n    public void case1() {\n        TreeNode root = TreeNode.from(5, 4, 8, 11, null, 13, 4, 7, 2, null, null, 5, 1);\n        int sum = 22;\n        List<List<Integer>> expected = Arrays.asList(Arrays.asList(5, 4, 11, 2), Arrays.asList(5, 8, 4, 5));\n        Assert.assertTrue(CommonUtil.isEquals(expected, pathSum(root, sum)));\n    }\n"]]}
{"hexsha": "cb98a377689cc05669d077b65e83dfa7d060254b", "ext": "java", "lang": "Java", "content": "public class InheritanceData\n{\n    private final InheritanceData parent;\n\n    private final String packageName;\n\n    private final Set<String> methodNames = PlasticInternalUtils.newSet();\n    private final Map<String, Boolean> methods = PlasticInternalUtils.newMap();\n    private final Set<String> interfaceNames = PlasticInternalUtils.newSet();\n\n    public InheritanceData(String packageName)\n    {\n        this(null, packageName);\n    }\n\n    private InheritanceData(InheritanceData parent, String packageName)\n    {\n        this.parent = parent;\n        this.packageName = packageName;\n    }\n\n    /**\n     * Is this bundle for a transformed class, or for a base class (typically Object)?\n     *\n     * @return true if this bundle is for transformed class, false otherwise\n     */\n    public boolean isTransformed()\n    {\n        return parent != null;\n    }\n\n    /**\n     * Returns a new MethodBundle that represents the methods of a child class\n     * of this bundle. The returned bundle will always be {@linkplain #isTransformed() transformed}.\n     *\n     * @param packageName\n     *         the package that the child class will be created in\n     * @return new method bundle\n     */\n    public InheritanceData createChild(String packageName)\n    {\n        return new InheritanceData(this, packageName);\n    }\n\n    /**\n     * Adds a new instance method. Only non-private methods should be added (that is, methods which might\n     * be overridden in subclasses). This can later be queried to see if any base class implements the method.\n     *\n     * @param name\n     *         name of method\n     * @param desc\n     *         describes the parameters and return value of the method\n     * @param samePackageOnly\n     *         whether the method can only be overridden in classes that are in the same package\n     */\n    public void addMethod(String name, String desc, boolean samePackageOnly)\n    {\n        methods.put(toValue(name, desc), samePackageOnly);\n        methodNames.add(name);\n    }\n\n\n    /**\n     * Returns true if this class or a transformed parent class contains an implementation of,\n     * or abstract placeholder for, the method.\n     *\n     * @param name\n     *         method name\n     * @param desc\n     *         method descriptor\n     * @return true if this class or a base class implements the method (including abstract methods)\n     */\n    public boolean isImplemented(String name, String desc)\n    {\n        return checkForMethod(toValue(name, desc), this);\n    }\n\n    /**\n     * Returns true if the method is an override of a base class method\n     *\n     * @param name\n     *         method name\n     * @param desc\n     *         method descriptor\n     * @return true if a base class implements the method (including abstract methods)\n     */\n    public boolean isOverride(String name, String desc)\n    {\n        return checkForMethod(toValue(name, desc), parent);\n    }\n\n    private boolean checkForMethod(String value, InheritanceData cursor)\n    {\n\n        String thisPackageName = packageName;\n\n        while (cursor != null)\n        {\n            if (cursor.methods.containsKey(value))\n            {\n                boolean mustBeInSamePackage = cursor.methods.get(value);\n\n                if (!mustBeInSamePackage)\n                {\n                    return true;\n                }\n                boolean isInSamePackage = thisPackageName.equals(cursor.packageName);\n\n                if (isInSamePackage)\n                {\n                    return true;\n                }\n            }\n\n            cursor = cursor.parent;\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns true if the class represented by this data, or any parent data, implements\n     * the named interface.\n     */\n    public boolean isInterfaceImplemented(String name)\n    {\n        InheritanceData cursor = this;\n\n        while (cursor != null)\n        {\n            if (cursor.interfaceNames.contains(name))\n            {\n                return true;\n            }\n\n            cursor = cursor.parent;\n        }\n\n        return false;\n    }\n\n    public void addInterface(String name)\n    {\n        if (!interfaceNames.contains(name))\n        {\n            interfaceNames.add(name);\n        }\n    }\n\n    /**\n     * Combines a method name and its desc (which describes parameter types and return value) to form\n     * a value, which is how methods are tracked.\n     */\n    private static String toValue(String name, String desc)\n    {\n        // TAP5-2268: ignore return-type to avoid methods with the same number (and type) of parameters but different\n        //            return-types which is illegal in Java.\n        // desc is something like \"(I)Ljava/lang/String;\", which means: takes an int, returns a String. We strip\n        // everything after the parameter list.\n        int endOfParameterSpecIdx = desc.indexOf(')');\n\n        return name + \":\" + desc.substring(0, endOfParameterSpecIdx+1);\n    }\n\n    /**\n     * Returns the names of any methods in this bundle, or from any parent bundles.\n     */\n    public Set<String> methodNames()\n    {\n        Set<String> result = PlasticInternalUtils.newSet();\n\n        InheritanceData cursor = this;\n\n        while (cursor != null)\n        {\n            result.addAll(cursor.methodNames);\n            cursor = cursor.parent;\n        }\n\n        return result;\n    }\n}", "class_id": 0, "repo": "xfyre/tapestry-5", "file": "plastic/src/main/java/org/apache/tapestry5/internal/plastic/InheritanceData.java", "last_update_at": "2020-12-26T22:06:44+00:00", "question_id": "cb98a377689cc05669d077b65e83dfa7d060254b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class InheritanceData\n{\n    private final InheritanceData parent;\n    private final String packageName;\n    private final Set<String> methodNames = PlasticInternalUtils.newSet();\n    private final Map<String, Boolean> methods = PlasticInternalUtils.newMap();\n    private final Set<String> interfaceNames = PlasticInternalUtils.newSet();\n    public InheritanceData(String packageName)\n    {\n        this(null, packageName);\n    }\n    private InheritanceData(InheritanceData parent, String packageName)\n    {\n        this.parent = parent;\n        this.packageName = packageName;\n    }\n    /**\n     * Is this bundle for a transformed class, or for a base class (typically Object)?\n     *\n     * @return true if this bundle is for transformed class, false otherwise\n     */\n    public boolean isTransformed()\n    {\n        return parent != null;\n    }\n    /**\n     * Returns a new MethodBundle that represents the methods of a child class\n     * of this bundle. The returned bundle will always be {@linkplain #isTransformed() transformed}.\n     *\n     * @param packageName\n     *         the package that the child class will be created in\n     * @return new method bundle\n     */\n    public InheritanceData createChild(String packageName)\n    {\n        return new InheritanceData(this, packageName);\n    }\n    /**\n     * Adds a new instance method. Only non-private methods should be added (that is, methods which might\n     * be overridden in subclasses). This can later be queried to see if any base class implements the method.\n     *\n     * @param name\n     *         name of method\n     * @param desc\n     *         describes the parameters and return value of the method\n     * @param samePackageOnly\n     *         whether the method can only be overridden in classes that are in the same package\n     */\n    public void addMethod(String name, String desc, boolean samePackageOnly)\n    {\n        methods.put(toValue(name, desc), samePackageOnly);\n        methodNames.add(name);\n    }\n    /**\n     * Returns true if this class or a transformed parent class contains an implementation of,\n     * or abstract placeholder for, the method.\n     *\n     * @param name\n     *         method name\n     * @param desc\n     *         method descriptor\n     * @return true if this class or a base class implements the method (including abstract methods)\n     */\n    public boolean isImplemented(String name, String desc)\n    {\n        return checkForMethod(toValue(name, desc), this);\n    }\n    /**\n     * Returns true if the method is an override of a base class method\n     *\n     * @param name\n     *         method name\n     * @param desc\n     *         method descriptor\n     * @return true if a base class implements the method (including abstract methods)\n     */\n    public boolean isOverride(String name, String desc)\n    {\n        return checkForMethod(toValue(name, desc), parent);\n    }\n    private boolean checkForMethod(String value, InheritanceData cursor)\n    {\n        String thisPackageName = packageName;\n        while (cursor != null)\n        {\n            if (cursor.methods.containsKey(value))\n            {\n                boolean mustBeInSamePackage = cursor.methods.get(value);\n                if (!mustBeInSamePackage)\n                {\n                    return true;\n                }\n                boolean isInSamePackage = thisPackageName.equals(cursor.packageName);\n                if (isInSamePackage)\n                {\n                    return true;\n                }\n            }\n            cursor = cursor.parent;\n        }\n        return false;\n    }\n    /**\n     * Returns true if the class represented by this data, or any parent data, implements\n     * the named interface.\n     */\n    public boolean isInterfaceImplemented(String name)\n    {\n        InheritanceData cursor = this;\n        while (cursor != null)\n        {\n            if (cursor.interfaceNames.contains(name))\n            {\n                return true;\n            }\n            cursor = cursor.parent;\n        }\n        return false;\n    }\n    public void addInterface(String name)\n    {\n        if (!interfaceNames.contains(name))\n        {\n            interfaceNames.add(name);\n        }\n    }\n    /**\n     * Combines a method name and its desc (which describes parameter types and return value) to form\n     * a value, which is how methods are tracked.\n     */\n    private static String toValue(String name, String desc)\n    {\n        // TAP5-2268: ignore return-type to avoid methods with the same number (and type) of parameters but different\n        //            return-types which is illegal in Java.\n        // desc is something like \"(I)Ljava/lang/String;\", which means: takes an int, returns a String. We strip\n        // everything after the parameter list.\n        int endOfParameterSpecIdx = desc.indexOf(')');\n        return name + \":\" + desc.substring(0, endOfParameterSpecIdx+1);\n    }\n    /**\n     * Returns the names of any methods in this bundle, or from any parent bundles.\n     */\n    public Set<String> methodNames()\n    {\n        Set<String> result = PlasticInternalUtils.newSet();\n        InheritanceData cursor = this;\n        while (cursor != null)\n        {\n            result.addAll(cursor.methodNames);\n            cursor = cursor.parent;\n        }\n        return result;\n    }\n"]]}
{"hexsha": "e36287f078f00cc006443cef39087027970c98eb", "ext": "java", "lang": "Java", "content": "public class DockerContainer {\n    public final DockerImage image;\n    public final boolean privileged;\n    public final List<EnvironmentVar> environment;\n    public final List<String> volumes;\n    public final List<DockerLink> links;\n\n    public DockerContainer(\n            DockerImage image,\n            boolean privileged,\n            List<EnvironmentVar> environment,\n            List<String> volumes,\n            List<DockerLink> links) {\n        this.image = image;\n        this.privileged = privileged;\n        this.environment = environment;\n        this.volumes = volumes;\n        this.links = links;\n    }\n\n    public DockerContainer(DockerImage image) {\n        this(image, false, new ArrayList<>(), new ArrayList<>(), new ArrayList<>());\n    }\n\n    public DockerContainer(JsonObject json)  {\n        image = new DockerImage(json.get(\"image\").getAsJsonObject());\n        privileged = json.get(\"privileged\").getAsBoolean();\n        volumes = jsonToListOfString(json.get(\"volumes\").getAsJsonArray());\n        environment = jsonToList(json.get(\"environment\").getAsJsonArray(), jsonElement -> new EnvironmentVar(jsonElement.getAsJsonObject()));\n        links = jsonToList(json.get(\"links\").getAsJsonArray(), jsonElement -> new DockerLink(jsonElement.getAsJsonObject()));\n    }\n\n    public JsonObject toJson() {\n        JsonObject json = new JsonObject();\n        json.add(\"image\", image.toJson());\n        json.addProperty(\"privileged\", privileged);\n        json.add(\"volumes\", listOfString(volumes));\n        json.add(\"environment\", listOfObjects(environment, EnvironmentVar::toJson));\n        json.add(\"links\", listOfObjects(links, DockerLink::toJson));\n        return json;\n    }\n\n\n}", "class_id": 0, "repo": "simpleci/simpleci", "file": "src/backend/shared/src/main/java/simpleci/shared/job/config/docker/DockerContainer.java", "last_update_at": "2020-02-18T10:48:58+00:00", "question_id": "e36287f078f00cc006443cef39087027970c98eb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DockerContainer {\n    public final DockerImage image;\n    public final boolean privileged;\n    public final List<EnvironmentVar> environment;\n    public final List<String> volumes;\n    public final List<DockerLink> links;\n    public DockerContainer(\n            DockerImage image,\n            boolean privileged,\n            List<EnvironmentVar> environment,\n            List<String> volumes,\n            List<DockerLink> links) {\n        this.image = image;\n        this.privileged = privileged;\n        this.environment = environment;\n        this.volumes = volumes;\n        this.links = links;\n    }\n    public DockerContainer(DockerImage image) {\n        this(image, false, new ArrayList<>(), new ArrayList<>(), new ArrayList<>());\n    }\n    public DockerContainer(JsonObject json)  {\n        image = new DockerImage(json.get(\"image\").getAsJsonObject());\n        privileged = json.get(\"privileged\").getAsBoolean();\n        volumes = jsonToListOfString(json.get(\"volumes\").getAsJsonArray());\n        environment = jsonToList(json.get(\"environment\").getAsJsonArray(), jsonElement -> new EnvironmentVar(jsonElement.getAsJsonObject()));\n        links = jsonToList(json.get(\"links\").getAsJsonArray(), jsonElement -> new DockerLink(jsonElement.getAsJsonObject()));\n    }\n    public JsonObject toJson() {\n        JsonObject json = new JsonObject();\n        json.add(\"image\", image.toJson());\n        json.addProperty(\"privileged\", privileged);\n        json.add(\"volumes\", listOfString(volumes));\n        json.add(\"environment\", listOfObjects(environment, EnvironmentVar::toJson));\n        json.add(\"links\", listOfObjects(links, DockerLink::toJson));\n        return json;\n    }\n"]]}
{"hexsha": "18bc265c1b387562a8b492ea56c691d6b36373cd", "ext": "java", "lang": "Java", "content": "class DelugeProgramOutput {\n\n    static DelugeProgramOutput from(RunnerProgramOutput programOutput) {\n        final var output = programOutput.output();\n        final var duration = programOutput.executionDuration();\n        final var error = programOutput.error().orElse(null);\n        return new DelugeProgramOutput(output, duration, error);\n    }\n\n    static DelugeProgramOutput from(String[] output, Duration duration, Exception error) {\n        return new DelugeProgramOutput(output, duration, error);\n    }\n\n    private final String[] output;\n\n    private final Exception error;\n\n    private final Duration duration;\n\n    private DelugeProgramOutput(String[] output, Duration duration, Exception error) {\n        this.output = output;\n        this.duration = duration;\n        this.error = error;\n    }\n\n    String[] output() {\n        return output;\n    }\n\n    Exception error() {\n        return error;\n    }\n\n    Duration executionDuration() {\n        return duration;\n    }\n\n}", "class_id": 0, "repo": "ZoftWhere/bolt-assertion", "file": "test-java/app/zoftwhere/bolt/deluge/DelugeProgramOutput.java", "last_update_at": "2020-09-28T03:14:01+00:00", "question_id": "18bc265c1b387562a8b492ea56c691d6b36373cd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class DelugeProgramOutput {\n    static DelugeProgramOutput from(RunnerProgramOutput programOutput) {\n        final var output = programOutput.output();\n        final var duration = programOutput.executionDuration();\n        final var error = programOutput.error().orElse(null);\n        return new DelugeProgramOutput(output, duration, error);\n    }\n    static DelugeProgramOutput from(String[] output, Duration duration, Exception error) {\n        return new DelugeProgramOutput(output, duration, error);\n    }\n    private final String[] output;\n    private final Exception error;\n    private final Duration duration;\n    private DelugeProgramOutput(String[] output, Duration duration, Exception error) {\n        this.output = output;\n        this.duration = duration;\n        this.error = error;\n    }\n    String[] output() {\n        return output;\n    }\n    Exception error() {\n        return error;\n    }\n    Duration executionDuration() {\n        return duration;\n    }\n"]]}
{"hexsha": "666806922449af44818ebd0d1a8edbe128833956", "ext": "java", "lang": "Java", "content": "public class GooglePhotosService\n    implements Exporter<PhotosModelWrapper>, Importer<PhotosModelWrapper> {\n\n  private static final String CLIENT_NAME = \"Portability\";\n\n  private final PicasawebService service;\n  private final JobDataCache jobDataCache;\n\n  public GooglePhotosService(Credential credential, JobDataCache jobDataCache) {\n    this.jobDataCache = jobDataCache;\n    this.service = new PicasawebService(CLIENT_NAME);\n    this.service.setOAuth2Credentials(credential);\n  }\n\n  private static InputStream getImageAsStream(String urlStr) throws IOException {\n    URL url = new URL(urlStr);\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    conn.connect();\n    return conn.getInputStream();\n  }\n\n  @Override\n  public PhotosModelWrapper export(ExportInformation exportInformation) throws IOException {\n    if (exportInformation.getResource().isPresent()) {\n      return exportPhotos(\n          ((IdOnlyResource) exportInformation.getResource().get()).getId(),\n          exportInformation.getPaginationInformation());\n    } else {\n      return exportAlbums(exportInformation.getPaginationInformation());\n    }\n\n  }\n\n  private PhotosModelWrapper exportAlbums(Optional<PaginationInformation> pageInfo)\n      throws IOException {\n    URL albumUrl = new URL(\"https://picasaweb.google.com/data/feed/api/user/default?kind=album\");\n\n    UserFeed albumFeed;\n\n    try {\n      albumFeed = service.getFeed(albumUrl, UserFeed.class);\n    } catch (ServiceException e) {\n      throw new IOException(\"Problem making request to: \" + albumUrl, e);\n    }\n\n    List<PhotoAlbum> albums = new ArrayList<>(albumFeed.getEntries().size());\n    List<Resource> resources = new ArrayList<>(albumFeed.getEntries().size());\n\n    for (GphotoEntry myAlbum : albumFeed.getEntries()) {\n      // Adding sub-resources tells the framework to re-call\n      // export to get all the photos.\n      resources.add(new IdOnlyResource(myAlbum.getGphotoId()));\n      // Saving data to the album allows the target service\n      // to recreate the album structure.\n      albums.add(new PhotoAlbum(\n          myAlbum.getGphotoId(),\n          myAlbum.getTitle().getPlainText(),\n          myAlbum.getDescription().getPlainText()\n      ));\n    }\n\n    return new PhotosModelWrapper(albums, null, new ContinuationInformation(resources, null));\n  }\n\n  private PhotosModelWrapper exportPhotos(\n      String albumId, Optional<PaginationInformation> pageInfo) throws IOException {\n    // imgmax=d gets the original immage as per:\n    // https://developers.google.com/picasa-web/docs/2.0/reference\n    URL photosUrl = new URL(\"https://picasaweb.google.com/data/feed/api/user/default/albumid/\"\n        + albumId + \"?imgmax=d\");\n    AlbumFeed photoFeed;\n    try {\n      photoFeed = service.getFeed(photosUrl, AlbumFeed.class);\n    } catch (ServiceException e) {\n      throw new IOException(\"Problem making request to: \" + photosUrl, e);\n    }\n\n    List<PhotoModel> photos = new ArrayList<>(photoFeed.getEntries().size());\n    for (GphotoEntry photo : photoFeed.getEntries()) {\n      MediaContent mediaContent = (MediaContent) photo.getContent();\n      photos.add(new PhotoModel(\n          photo.getTitle().getPlainText(),\n          mediaContent.getUri(),\n          photo.getDescription().getPlainText(),\n          mediaContent.getMimeType().getMediaType(),\n          albumId\n      ));\n    }\n\n    return new PhotosModelWrapper(null, photos, new ContinuationInformation(null, null));\n  }\n\n  @Override\n  public void importItem(PhotosModelWrapper wrapper) throws IOException {\n    for (PhotoAlbum album : wrapper.getAlbums()) {\n      if (true) {\n        // Google doesn't support creating albums anymore\n        continue;\n      }\n      AlbumEntry myAlbum = new AlbumEntry();\n\n      myAlbum.setTitle(new PlainTextConstruct(\"copy of \" + album.getName()));\n      myAlbum.setDescription(new PlainTextConstruct(album.getDescription()));\n\n      URL albumUrl = new URL(\n          \"https://picasaweb.google.com/data/feed/api/user/default\");\n      AlbumEntry insertedEntry;\n\n      try {\n        // https://developers.google.com/picasa-web/docs/2.0/developers_guide_java#AddAlbums\n        insertedEntry = service.insert(albumUrl, myAlbum);\n        jobDataCache.store(album.getId(), insertedEntry.getGphotoId());\n      } catch (ServiceException e) {\n        throw new IOException(\n            \"Problem copying\" + album.getName() + \" request to: \" + albumUrl, e);\n      }\n    }\n\n    for (PhotoModel photo : wrapper.getPhotos()) {\n      //String newAlbumId = jobDataCache.getData(photo.getAlbumId(), String.class);\n      String newAlbumId = \"default\";\n      URL photoPostUrl = new URL(\"https://picasaweb.google.com/data/feed/api/user/default/albumid/\"\n          + newAlbumId);\n\n      PhotoEntry myPhoto = new PhotoEntry();\n      myPhoto.setTitle(new PlainTextConstruct(\"copy of \" + photo.getTitle()));\n      myPhoto.setDescription(new PlainTextConstruct(photo.getDescription()));\n      myPhoto.setClient(CLIENT_NAME);\n\n      String mediaType = photo.getMediaType();\n\n      if (mediaType == null) {\n        mediaType = \"image/jpeg\";\n      }\n\n      MediaStreamSource streamSource = new MediaStreamSource(\n          getImageAsStream(photo.getFetchableUrl()),\n          mediaType);\n      myPhoto.setMediaSource(streamSource);\n\n      try {\n        service.insert(photoPostUrl, myPhoto);\n      } catch (ServiceException e) {\n        throw new IOException(\"Problem adding \" + photo.getTitle() + \" to \"\n            + newAlbumId, e);\n      }\n    }\n  }\n}", "class_id": 0, "repo": "denalisf/data-portability", "file": "portability-core/src/main/java/org/dataportabilityproject/serviceProviders/google/piccasa/GooglePhotosService.java", "last_update_at": "2020-07-19T21:22:25+00:00", "question_id": "666806922449af44818ebd0d1a8edbe128833956", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GooglePhotosService\n    implements Exporter<PhotosModelWrapper>, Importer<PhotosModelWrapper> {\n  private static final String CLIENT_NAME = \"Portability\";\n  private final PicasawebService service;\n  private final JobDataCache jobDataCache;\n  public GooglePhotosService(Credential credential, JobDataCache jobDataCache) {\n    this.jobDataCache = jobDataCache;\n    this.service = new PicasawebService(CLIENT_NAME);\n    this.service.setOAuth2Credentials(credential);\n  }\n  private static InputStream getImageAsStream(String urlStr) throws IOException {\n    URL url = new URL(urlStr);\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    conn.connect();\n    return conn.getInputStream();\n  }\n  @Override\n  public PhotosModelWrapper export(ExportInformation exportInformation) throws IOException {\n    if (exportInformation.getResource().isPresent()) {\n      return exportPhotos(\n          ((IdOnlyResource) exportInformation.getResource().get()).getId(),\n          exportInformation.getPaginationInformation());\n    } else {\n      return exportAlbums(exportInformation.getPaginationInformation());\n    }\n  }\n  private PhotosModelWrapper exportAlbums(Optional<PaginationInformation> pageInfo)\n      throws IOException {\n    URL albumUrl = new URL(\"https://picasaweb.google.com/data/feed/api/user/default?kind=album\");\n    UserFeed albumFeed;\n    try {\n      albumFeed = service.getFeed(albumUrl, UserFeed.class);\n    } catch (ServiceException e) {\n      throw new IOException(\"Problem making request to: \" + albumUrl, e);\n    }\n    List<PhotoAlbum> albums = new ArrayList<>(albumFeed.getEntries().size());\n    List<Resource> resources = new ArrayList<>(albumFeed.getEntries().size());\n    for (GphotoEntry myAlbum : albumFeed.getEntries()) {\n      // Adding sub-resources tells the framework to re-call\n      // export to get all the photos.\n      resources.add(new IdOnlyResource(myAlbum.getGphotoId()));\n      // Saving data to the album allows the target service\n      // to recreate the album structure.\n      albums.add(new PhotoAlbum(\n          myAlbum.getGphotoId(),\n          myAlbum.getTitle().getPlainText(),\n          myAlbum.getDescription().getPlainText()\n      ));\n    }\n    return new PhotosModelWrapper(albums, null, new ContinuationInformation(resources, null));\n  }\n  private PhotosModelWrapper exportPhotos(\n      String albumId, Optional<PaginationInformation> pageInfo) throws IOException {\n    // imgmax=d gets the original immage as per:\n    // https://developers.google.com/picasa-web/docs/2.0/reference\n    URL photosUrl = new URL(\"https://picasaweb.google.com/data/feed/api/user/default/albumid/\"\n        + albumId + \"?imgmax=d\");\n    AlbumFeed photoFeed;\n    try {\n      photoFeed = service.getFeed(photosUrl, AlbumFeed.class);\n    } catch (ServiceException e) {\n      throw new IOException(\"Problem making request to: \" + photosUrl, e);\n    }\n    List<PhotoModel> photos = new ArrayList<>(photoFeed.getEntries().size());\n    for (GphotoEntry photo : photoFeed.getEntries()) {\n      MediaContent mediaContent = (MediaContent) photo.getContent();\n      photos.add(new PhotoModel(\n          photo.getTitle().getPlainText(),\n          mediaContent.getUri(),\n          photo.getDescription().getPlainText(),\n          mediaContent.getMimeType().getMediaType(),\n          albumId\n      ));\n    }\n    return new PhotosModelWrapper(null, photos, new ContinuationInformation(null, null));\n  }\n  @Override\n  public void importItem(PhotosModelWrapper wrapper) throws IOException {\n    for (PhotoAlbum album : wrapper.getAlbums()) {\n      if (true) {\n        // Google doesn't support creating albums anymore\n        continue;\n      }\n      AlbumEntry myAlbum = new AlbumEntry();\n      myAlbum.setTitle(new PlainTextConstruct(\"copy of \" + album.getName()));\n      myAlbum.setDescription(new PlainTextConstruct(album.getDescription()));\n      URL albumUrl = new URL(\n          \"https://picasaweb.google.com/data/feed/api/user/default\");\n      AlbumEntry insertedEntry;\n      try {\n        // https://developers.google.com/picasa-web/docs/2.0/developers_guide_java#AddAlbums\n        insertedEntry = service.insert(albumUrl, myAlbum);\n        jobDataCache.store(album.getId(), insertedEntry.getGphotoId());\n      } catch (ServiceException e) {\n        throw new IOException(\n            \"Problem copying\" + album.getName() + \" request to: \" + albumUrl, e);\n      }\n    }\n    for (PhotoModel photo : wrapper.getPhotos()) {\n      //String newAlbumId = jobDataCache.getData(photo.getAlbumId(), String.class);\n      String newAlbumId = \"default\";\n      URL photoPostUrl = new URL(\"https://picasaweb.google.com/data/feed/api/user/default/albumid/\"\n          + newAlbumId);\n      PhotoEntry myPhoto = new PhotoEntry();\n      myPhoto.setTitle(new PlainTextConstruct(\"copy of \" + photo.getTitle()));\n      myPhoto.setDescription(new PlainTextConstruct(photo.getDescription()));\n      myPhoto.setClient(CLIENT_NAME);\n      String mediaType = photo.getMediaType();\n      if (mediaType == null) {\n        mediaType = \"image/jpeg\";\n      }\n      MediaStreamSource streamSource = new MediaStreamSource(\n          getImageAsStream(photo.getFetchableUrl()),\n          mediaType);\n      myPhoto.setMediaSource(streamSource);\n      try {\n        service.insert(photoPostUrl, myPhoto);\n      } catch (ServiceException e) {\n        throw new IOException(\"Problem adding \" + photo.getTitle() + \" to \"\n            + newAlbumId, e);\n      }\n    }\n  }\n"]]}
{"hexsha": "9ef90ac9481642aa9f15fc4c51765c42dbbd38ef", "ext": "java", "lang": "Java", "content": "public class ASTDivNode extends SimpleNode {\n    /**\n     * Create the node given an id.\n     *\n     * @param id node id.\n     */\n    public ASTDivNode(int id) {\n        super(id);\n    }\n\n    /**\n     * Create a node with the given parser and id.\n     *\n     * @param p a parser.\n     * @param id node id.\n     */\n    public ASTDivNode(Parser p, int id) {\n        super(p, id);\n    }\n\n    /** {@inheritDoc} */\n    public Object jjtAccept(ParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n    /** {@inheritDoc} */\n    public Object value(JexlContext jc) throws Exception {\n        Object left = ((SimpleNode) jjtGetChild(0)).value(jc);\n        Object right = ((SimpleNode) jjtGetChild(1)).value(jc);\n\n        /*\n         * the spec says 'and', I think 'or'\n         */\n        if (left == null && right == null) {\n            return new Byte((byte) 0);\n        }\n\n        if (left instanceof BigInteger || right instanceof BigInteger) {\n            BigInteger l = Coercion.coerceBigInteger(left);\n            BigInteger r = Coercion.coerceBigInteger(right);\n            return l.divide(r);\n        }\n\n        if (left instanceof BigDecimal || right instanceof BigDecimal) {\n            BigDecimal l = Coercion.coerceBigDecimal(left);\n            BigDecimal r = Coercion.coerceBigDecimal(right);\n            return l.divide(r);\n        }\n\n        Double l = Coercion.coerceDouble(left);\n        Double r = Coercion.coerceDouble(right);\n\n        /*\n         * catch div/0\n         */\n        if (r.doubleValue() == 0.0) {\n            return new Double(0.0);\n        }\n\n        return new Double(l.doubleValue() / r.doubleValue());\n\n    }\n}", "class_id": 0, "repo": "percussion/commons-jexl", "file": "src/java/org/apache/commons/jexl/parser/ASTDivNode.java", "last_update_at": "2020-12-03T18:05:36+00:00", "question_id": "9ef90ac9481642aa9f15fc4c51765c42dbbd38ef", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ASTDivNode extends SimpleNode {\n    /**\n     * Create the node given an id.\n     *\n     * @param id node id.\n     */\n    public ASTDivNode(int id) {\n        super(id);\n    }\n    /**\n     * Create a node with the given parser and id.\n     *\n     * @param p a parser.\n     * @param id node id.\n     */\n    public ASTDivNode(Parser p, int id) {\n        super(p, id);\n    }\n    /** {@inheritDoc} */\n    public Object jjtAccept(ParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n    /** {@inheritDoc} */\n    public Object value(JexlContext jc) throws Exception {\n        Object left = ((SimpleNode) jjtGetChild(0)).value(jc);\n        Object right = ((SimpleNode) jjtGetChild(1)).value(jc);\n        /*\n         * the spec says 'and', I think 'or'\n         */\n        if (left == null && right == null) {\n            return new Byte((byte) 0);\n        }\n        if (left instanceof BigInteger || right instanceof BigInteger) {\n            BigInteger l = Coercion.coerceBigInteger(left);\n            BigInteger r = Coercion.coerceBigInteger(right);\n            return l.divide(r);\n        }\n        if (left instanceof BigDecimal || right instanceof BigDecimal) {\n            BigDecimal l = Coercion.coerceBigDecimal(left);\n            BigDecimal r = Coercion.coerceBigDecimal(right);\n            return l.divide(r);\n        }\n        Double l = Coercion.coerceDouble(left);\n        Double r = Coercion.coerceDouble(right);\n        /*\n         * catch div/0\n         */\n        if (r.doubleValue() == 0.0) {\n            return new Double(0.0);\n        }\n        return new Double(l.doubleValue() / r.doubleValue());\n    }\n"]]}
{"hexsha": "4e4636fa00cc7eafe82760fe9c4d53b4293912ca", "ext": "java", "lang": "Java", "content": "public class TestHeader extends LCCoreAbstractTest {\r\n\r\n\t@Test\r\n\tpublic void testMimeHeader() throws Exception {\r\n\t\tMimeHeader h = new MimeHeader(\"X-Test\", \"toto; titi=tata; (a comment) hello=world, heho, aa; bb=cc\");\r\n\t\tAssert.assertEquals(\"X-Test\", h.getName());\r\n\t\tAssert.assertEquals(\"x-test\", h.getNameLowerCase());\r\n\t\tAssert.assertEquals(\"toto; titi=tata; (a comment) hello=world, heho, aa; bb=cc\", h.getRawValue());\r\n\t\tParameterizedHeaderValues values = h.getValue(ParameterizedHeaderValues.class);\r\n\t\tAssert.assertEquals(3, values.getValues().size());\r\n\t\tParameterizedHeaderValue v = values.getMainValue(\"toto\");\r\n\t\tAssert.assertNotNull(v);\r\n\t\tAssert.assertEquals(2, v.getParameters().size());\r\n\t\tAssert.assertEquals(\"tata\", v.getParameter(\"titi\"));\r\n\t\tAssert.assertEquals(\"world\", v.getParameter(\"hello\"));\r\n\t\tAssert.assertNull(v.getParameter(\"heho\"));\r\n\t\tAssert.assertNull(v.getParameter(\"aa\"));\r\n\t\tAssert.assertNull(v.getParameter(\"bb\"));\r\n\t\tv = values.getMainValue(\"heho\");\r\n\t\tAssert.assertNotNull(v);\r\n\t\tAssert.assertEquals(0, v.getParameters().size());\r\n\t\tAssert.assertNull(v.getParameter(\"aa\"));\r\n\t\tAssert.assertNull(v.getParameterIgnoreCase(\"bb\"));\r\n\t\tv = values.getMainValue(\"aa\");\r\n\t\tAssert.assertNotNull(v);\r\n\t\tAssert.assertEquals(1, v.getParameters().size());\r\n\t\tAssert.assertEquals(\"cc\", v.getParameter(\"bb\"));\r\n\t\t\r\n\t\tAssert.assertNull(values.getMainValue(\"abcd\"));\r\n\t\tAssert.assertFalse(values.hasMainValue(\"abcd\"));\r\n\t\tAssert.assertTrue(values.hasMainValue(\"aa\"));\r\n\t\tCharArrayStringBuffer s = new CharArrayStringBuffer();\r\n\t\tvalues.generate(s, 17, 13);\r\n\t\tAssert.assertEquals(\"toto;titi=tata;\\r\\n\\thello=world,\\r\\n\\theho,aa;bb=cc\", s.toString());\r\n\t\t\r\n\t\th.setRawValue(\"hello; fr=bonjour\");\r\n\t\tAssert.assertEquals(\"hello; fr=bonjour\", h.getRawValue());\r\n\t\th.appendTo(new CharArrayStringBuffer());\r\n\t\tv = h.getValue(ParameterizedHeaderValue.class);\r\n\t\tAssert.assertEquals(\"hello\", v.getMainValue());\r\n\t\tAssert.assertEquals(\"bonjour\", v.getParameter(\"fr\"));\r\n\t\tv = h.getValue(ParameterizedHeaderValue.class);\r\n\t\tAssert.assertEquals(\"hello\", v.getMainValue());\r\n\t\tAssert.assertEquals(\"bonjour\", v.getParameterIgnoreCase(\"FR\"));\r\n\t\th.setValue(new ParameterizedHeaderValue(\"world\", \"fr\", \"monde\", \"test\", \"yes\"));\r\n\t\tAssert.assertEquals(\"world;fr=monde;test=yes\", h.getRawValue());\r\n\t\th.setValue(new ParameterizedHeaderValue(\"world\", \"fr\", \"monde\", \"test\", \"yes\"));\r\n\t\th.appendTo(new CharArrayStringBuffer());\r\n\t\tv.setMainValue(\"hello\");\r\n\t\tv.setParameter(\"turlututu\", \"pointu\");\r\n\t\t\r\n\t\tMimeHeaders mime = new MimeHeaders(\r\n\t\t\tnew MimeHeader(\"h1\", \"v1\"),\r\n\t\t\tnew MimeHeader(\"h2\", \"v2\")\r\n\t\t);\r\n\t\tmime.add(new MimeHeader(\"h3\", \"v3\"));\r\n\t\tmime.set(new MimeHeader(\"h1\", \"v11\"));\r\n\t\tmime.set(new MimeHeader(\"h4\", \"v4\"));\r\n\t\tAssert.assertEquals(4, mime.getHeaders().size());\r\n\t}\r\n\t\r\n\t@Test\r\n\tpublic void testParser() {\r\n\t\tList<Token> tokens = MimeHeaderValueParser.parse(\"hello (a comment)  world [domain]  <user@mail.com> \\\"bonjour  \\\\\\\"ami\\\\\\\"\\\"\");\r\n\t\tIterator<Token> it = tokens.iterator();\r\n\t\tToken tok = it.next();\r\n\t\tAssert.assertEquals(Word.class, tok.getClass());\r\n\t\tAssert.assertEquals(\"hello\", ((Word)tok).getContent());\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Space.class, tok.getClass());\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Comment.class, tok.getClass());\r\n\t\tAssert.assertEquals(\"(a comment)\", ((Comment)tok).asString());\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Space.class, tok.getClass());\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Word.class, tok.getClass());\r\n\t\tAssert.assertEquals(\"world\", ((Word)tok).getContent());\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Space.class, tok.getClass());\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(DomainLiteral.class, tok.getClass());\r\n\t\tAssert.assertEquals(\"[domain]\", ((DomainLiteral)tok).asString());\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Space.class, tok.getClass());\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Address.class, tok.getClass());\r\n\t\tAssert.assertEquals(\"<user@mail.com>\", ((Address)tok).asString());\r\n\t\t((Address)tok).getContent();\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Space.class, tok.getClass());\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Word.class, tok.getClass());\r\n\t\tAssert.assertEquals(\"bonjour  \\\"ami\\\"\", ((Word)tok).getContent());\r\n\t\tAssert.assertFalse(it.hasNext());\r\n\r\n\t\r\n\t\ttokens = MimeHeaderValueParser.parse(\"(comment1 [domain1 (comment2) [domain2]] (comment3))\");\r\n\t\tit = tokens.iterator();\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Comment.class, tok.getClass());\r\n\t\tAssert.assertFalse(it.hasNext());\r\n\t\tit = ((Comment)tok).getContent().iterator();\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Word.class, tok.getClass());\r\n\t\tAssert.assertEquals(\"comment1\", ((Word)tok).getContent());\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Space.class, tok.getClass());\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(DomainLiteral.class, tok.getClass());\r\n\r\n\t\tIterator<Token> it2 = ((DomainLiteral)tok).getContent().iterator();\r\n\t\tToken tok2 = it2.next();\r\n\t\tAssert.assertEquals(Word.class, tok2.getClass());\r\n\t\tAssert.assertEquals(\"domain1\", ((Word)tok2).getContent());\r\n\t\ttok2 = it2.next();\r\n\t\tAssert.assertEquals(Space.class, tok2.getClass());\r\n\t\ttok2 = it2.next();\r\n\t\tAssert.assertEquals(Comment.class, tok2.getClass());\r\n\t\tAssert.assertEquals(\"(comment2)\", ((Comment)tok2).asString());\r\n\t\ttok2 = it2.next();\r\n\t\tAssert.assertEquals(Space.class, tok2.getClass());\r\n\t\ttok2 = it2.next();\r\n\t\tAssert.assertEquals(DomainLiteral.class, tok2.getClass());\r\n\t\tAssert.assertEquals(\"[domain2]\", ((DomainLiteral)tok2).asString());\r\n\t\tAssert.assertFalse(it2.hasNext());\r\n\t\t\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Space.class, tok.getClass());\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Comment.class, tok.getClass());\r\n\t\tAssert.assertEquals(\"(comment3)\", ((Comment)tok).asString());\r\n\t\tAssert.assertFalse(it.hasNext());\r\n\t\t\r\n\t\ttokens = MimeHeaderValueParser.parse(\" hel\\\\5lo \");\r\n\t\tToken.trim(tokens);\r\n\t\tAssert.assertEquals(1, tokens.size());\r\n\t\tAssert.assertEquals(Word.class, tokens.get(0).getClass());\r\n\t\tAssert.assertEquals(\"hel5lo\", ((Word)tokens.get(0)).getContent());\r\n\t}\r\n\t\r\n\t@Test\r\n\tpublic void testMimeHeaders() {\r\n\t\tMimeHeaders headers = new MimeHeaders();\r\n\t\theaders.setRawValue(\"test\", \"hello\");\r\n\t\tAssert.assertNull(headers.getFirstLongValue(\"test\"));\r\n\t\tAssert.assertTrue(headers.has(\"test\"));\r\n\t\tAssert.assertFalse(headers.has(\"test2\"));\r\n\t\tAssert.assertNull(headers.getContentTypeValue());\r\n\t\theaders.setRawValue(\"Content-Type\", \"=?toto?=\");\r\n\t\tAssert.assertNull(headers.getContentTypeValue());\r\n\t\t\r\n\t\tAsyncSupplier<Boolean, MimeException> consume = headers.createConsumer(10).consume(new ByteArray(\"X-Header: x-value\\r\\n\\r\\n\".getBytes(StandardCharsets.US_ASCII)));\r\n\t\tconsume.block(0);\r\n\t\tAssert.assertTrue(consume.hasError());\r\n\t\t\r\n\t\tconsume = headers.createConsumer(10).consume(new ByteArray(\"X-Header-TooLong: x-value\\r\\n\\r\\n\".getBytes(StandardCharsets.US_ASCII)));\r\n\t\tconsume.block(0);\r\n\t\tAssert.assertTrue(consume.hasError());\r\n\t\t\r\n\t\tconsume = headers.createConsumer(10).consume(new ByteArray(\"X: y\\r\\nZ: zzzzzzzzzz\\r\\n\\r\\n\".getBytes(StandardCharsets.US_ASCII)));\r\n\t\tconsume.block(0);\r\n\t\tAssert.assertTrue(consume.hasError());\r\n\t\t\r\n\t\tconsume = headers.createConsumer(10).consume(new ByteArray(\"X: abcde\\r\\n\\r\\n\".getBytes(StandardCharsets.US_ASCII)));\r\n\t\tconsume.block(0);\r\n\t\tAssert.assertTrue(consume.hasError());\r\n\t\t\r\n\t\tconsume = headers.createConsumer(100).consume(new ByteArray(\" X: abcde\\r\\n\\r\\n\".getBytes(StandardCharsets.US_ASCII)));\r\n\t\tconsume.block(0);\r\n\t\tAssert.assertTrue(consume.hasError());\r\n\t\t\r\n\t\tconsume = headers.createConsumer(100).consume(new ByteArray(\"123465789\\r\\n\\r\\n\".getBytes(StandardCharsets.US_ASCII)));\r\n\t\tconsume.block(0);\r\n\t\tAssert.assertTrue(consume.hasError());\r\n\t}\r\n\t\r\n\tpublic static class Container implements MimeHeadersContainer<Container> {\r\n\t\t\r\n\t\tprivate MimeHeaders headers = new MimeHeaders();\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic MimeHeaders getHeaders() {\r\n\t\t\treturn headers;\r\n\t\t}\r\n\t}\r\n\t\r\n\t@Test\r\n\tpublic void testHeadersContainer() throws Exception {\r\n\t\tContainer c = new Container();\r\n\t\tc.addHeader(new MimeHeader(\"a\", \"b\"));\r\n\t\tc.addHeader(\"c\", \"d\");\r\n\t\tc.addHeader(\"e\", new ParameterizedHeaderValue(\"f\", \"g\", \"h\"));\r\n\t\tAssert.assertEquals(\"b\", c.getHeaders().getFirstRawValue(\"a\"));\r\n\t\tAssert.assertEquals(\"d\", c.getHeaders().getFirstRawValue(\"c\"));\r\n\t\tc.setHeader(\"c\", \"1\");\r\n\t\tAssert.assertEquals(\"1\", c.getHeaders().getFirstRawValue(\"c\"));\r\n\t\tc.setHeader(new MimeHeader(\"c\", \"2\"));\r\n\t\tAssert.assertEquals(\"2\", c.getHeaders().getFirstRawValue(\"c\"));\r\n\t\tc.setHeader(\"c\", new ParameterizedHeaderValue(\"A\", \"B\", \"C\"));\r\n\t\tAssert.assertEquals(\"A\", c.getHeaders().getFirstValue(\"c\", ParameterizedHeaderValue.class).getMainValue());\r\n\t}\r\n\t\r\n}", "class_id": 0, "repo": "lecousin/java-framework-network-mime", "file": "src/test/java/net/lecousin/framework/network/mime/TestHeader.java", "last_update_at": "2020-03-08T11:40:46+00:00", "question_id": "4e4636fa00cc7eafe82760fe9c4d53b4293912ca", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestHeader extends LCCoreAbstractTest {\r\n\r\n\t@Test\r\n\tpublic void testMimeHeader() throws Exception {\r\n\t\tMimeHeader h = new MimeHeader(\"X-Test\", \"toto; titi=tata; (a comment) hello=world, heho, aa; bb=cc\");\r\n\t\tAssert.assertEquals(\"X-Test\", h.getName());\r\n\t\tAssert.assertEquals(\"x-test\", h.getNameLowerCase());\r\n\t\tAssert.assertEquals(\"toto; titi=tata; (a comment) hello=world, heho, aa; bb=cc\", h.getRawValue());\r\n\t\tParameterizedHeaderValues values = h.getValue(ParameterizedHeaderValues.class);\r\n\t\tAssert.assertEquals(3, values.getValues().size());\r\n\t\tParameterizedHeaderValue v = values.getMainValue(\"toto\");\r\n\t\tAssert.assertNotNull(v);\r\n\t\tAssert.assertEquals(2, v.getParameters().size());\r\n\t\tAssert.assertEquals(\"tata\", v.getParameter(\"titi\"));\r\n\t\tAssert.assertEquals(\"world\", v.getParameter(\"hello\"));\r\n\t\tAssert.assertNull(v.getParameter(\"heho\"));\r\n\t\tAssert.assertNull(v.getParameter(\"aa\"));\r\n\t\tAssert.assertNull(v.getParameter(\"bb\"));\r\n\t\tv = values.getMainValue(\"heho\");\r\n\t\tAssert.assertNotNull(v);\r\n\t\tAssert.assertEquals(0, v.getParameters().size());\r\n\t\tAssert.assertNull(v.getParameter(\"aa\"));\r\n\t\tAssert.assertNull(v.getParameterIgnoreCase(\"bb\"));\r\n\t\tv = values.getMainValue(\"aa\");\r\n\t\tAssert.assertNotNull(v);\r\n\t\tAssert.assertEquals(1, v.getParameters().size());\r\n\t\tAssert.assertEquals(\"cc\", v.getParameter(\"bb\"));\r\n\t\t\r\n\t\tAssert.assertNull(values.getMainValue(\"abcd\"));\r\n\t\tAssert.assertFalse(values.hasMainValue(\"abcd\"));\r\n\t\tAssert.assertTrue(values.hasMainValue(\"aa\"));\r\n\t\tCharArrayStringBuffer s = new CharArrayStringBuffer();\r\n\t\tvalues.generate(s, 17, 13);\r\n\t\tAssert.assertEquals(\"toto;titi=tata;\\r\\n\\thello=world,\\r\\n\\theho,aa;bb=cc\", s.toString());\r\n\t\t\r\n\t\th.setRawValue(\"hello; fr=bonjour\");\r\n\t\tAssert.assertEquals(\"hello; fr=bonjour\", h.getRawValue());\r\n\t\th.appendTo(new CharArrayStringBuffer());\r\n\t\tv = h.getValue(ParameterizedHeaderValue.class);\r\n\t\tAssert.assertEquals(\"hello\", v.getMainValue());\r\n\t\tAssert.assertEquals(\"bonjour\", v.getParameter(\"fr\"));\r\n\t\tv = h.getValue(ParameterizedHeaderValue.class);\r\n\t\tAssert.assertEquals(\"hello\", v.getMainValue());\r\n\t\tAssert.assertEquals(\"bonjour\", v.getParameterIgnoreCase(\"FR\"));\r\n\t\th.setValue(new ParameterizedHeaderValue(\"world\", \"fr\", \"monde\", \"test\", \"yes\"));\r\n\t\tAssert.assertEquals(\"world;fr=monde;test=yes\", h.getRawValue());\r\n\t\th.setValue(new ParameterizedHeaderValue(\"world\", \"fr\", \"monde\", \"test\", \"yes\"));\r\n\t\th.appendTo(new CharArrayStringBuffer());\r\n\t\tv.setMainValue(\"hello\");\r\n\t\tv.setParameter(\"turlututu\", \"pointu\");\r\n\t\t\r\n\t\tMimeHeaders mime = new MimeHeaders(\r\n\t\t\tnew MimeHeader(\"h1\", \"v1\"),\r\n\t\t\tnew MimeHeader(\"h2\", \"v2\")\r\n\t\t);\r\n\t\tmime.add(new MimeHeader(\"h3\", \"v3\"));\r\n\t\tmime.set(new MimeHeader(\"h1\", \"v11\"));\r\n\t\tmime.set(new MimeHeader(\"h4\", \"v4\"));\r\n\t\tAssert.assertEquals(4, mime.getHeaders().size());\r\n\t}\r\n\t\r\n\t@Test\r\n\tpublic void testParser() {\r\n\t\tList<Token> tokens = MimeHeaderValueParser.parse(\"hello (a comment)  world [domain]  <user@mail.com> \\\"bonjour  \\\\\\\"ami\\\\\\\"\\\"\");\r\n\t\tIterator<Token> it = tokens.iterator();\r\n\t\tToken tok = it.next();\r\n\t\tAssert.assertEquals(Word.class, tok.getClass());\r\n\t\tAssert.assertEquals(\"hello\", ((Word)tok).getContent());\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Space.class, tok.getClass());\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Comment.class, tok.getClass());\r\n\t\tAssert.assertEquals(\"(a comment)\", ((Comment)tok).asString());\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Space.class, tok.getClass());\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Word.class, tok.getClass());\r\n\t\tAssert.assertEquals(\"world\", ((Word)tok).getContent());\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Space.class, tok.getClass());\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(DomainLiteral.class, tok.getClass());\r\n\t\tAssert.assertEquals(\"[domain]\", ((DomainLiteral)tok).asString());\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Space.class, tok.getClass());\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Address.class, tok.getClass());\r\n\t\tAssert.assertEquals(\"<user@mail.com>\", ((Address)tok).asString());\r\n\t\t((Address)tok).getContent();\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Space.class, tok.getClass());\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Word.class, tok.getClass());\r\n\t\tAssert.assertEquals(\"bonjour  \\\"ami\\\"\", ((Word)tok).getContent());\r\n\t\tAssert.assertFalse(it.hasNext());\r\n\r\n\t\r\n\t\ttokens = MimeHeaderValueParser.parse(\"(comment1 [domain1 (comment2) [domain2]] (comment3))\");\r\n\t\tit = tokens.iterator();\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Comment.class, tok.getClass());\r\n\t\tAssert.assertFalse(it.hasNext());\r\n\t\tit = ((Comment)tok).getContent().iterator();\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Word.class, tok.getClass());\r\n\t\tAssert.assertEquals(\"comment1\", ((Word)tok).getContent());\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Space.class, tok.getClass());\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(DomainLiteral.class, tok.getClass());\r\n\r\n\t\tIterator<Token> it2 = ((DomainLiteral)tok).getContent().iterator();\r\n\t\tToken tok2 = it2.next();\r\n\t\tAssert.assertEquals(Word.class, tok2.getClass());\r\n\t\tAssert.assertEquals(\"domain1\", ((Word)tok2).getContent());\r\n\t\ttok2 = it2.next();\r\n\t\tAssert.assertEquals(Space.class, tok2.getClass());\r\n\t\ttok2 = it2.next();\r\n\t\tAssert.assertEquals(Comment.class, tok2.getClass());\r\n\t\tAssert.assertEquals(\"(comment2)\", ((Comment)tok2).asString());\r\n\t\ttok2 = it2.next();\r\n\t\tAssert.assertEquals(Space.class, tok2.getClass());\r\n\t\ttok2 = it2.next();\r\n\t\tAssert.assertEquals(DomainLiteral.class, tok2.getClass());\r\n\t\tAssert.assertEquals(\"[domain2]\", ((DomainLiteral)tok2).asString());\r\n\t\tAssert.assertFalse(it2.hasNext());\r\n\t\t\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Space.class, tok.getClass());\r\n\t\ttok = it.next();\r\n\t\tAssert.assertEquals(Comment.class, tok.getClass());\r\n\t\tAssert.assertEquals(\"(comment3)\", ((Comment)tok).asString());\r\n\t\tAssert.assertFalse(it.hasNext());\r\n\t\t\r\n\t\ttokens = MimeHeaderValueParser.parse(\" hel\\\\5lo \");\r\n\t\tToken.trim(tokens);\r\n\t\tAssert.assertEquals(1, tokens.size());\r\n\t\tAssert.assertEquals(Word.class, tokens.get(0).getClass());\r\n\t\tAssert.assertEquals(\"hel5lo\", ((Word)tokens.get(0)).getContent());\r\n\t}\r\n\t\r\n\t@Test\r\n\tpublic void testMimeHeaders() {\r\n\t\tMimeHeaders headers = new MimeHeaders();\r\n\t\theaders.setRawValue(\"test\", \"hello\");\r\n\t\tAssert.assertNull(headers.getFirstLongValue(\"test\"));\r\n\t\tAssert.assertTrue(headers.has(\"test\"));\r\n\t\tAssert.assertFalse(headers.has(\"test2\"));\r\n\t\tAssert.assertNull(headers.getContentTypeValue());\r\n\t\theaders.setRawValue(\"Content-Type\", \"=?toto?=\");\r\n\t\tAssert.assertNull(headers.getContentTypeValue());\r\n\t\t\r\n\t\tAsyncSupplier<Boolean, MimeException> consume = headers.createConsumer(10).consume(new ByteArray(\"X-Header: x-value\\r\\n\\r\\n\".getBytes(StandardCharsets.US_ASCII)));\r\n\t\tconsume.block(0);\r\n\t\tAssert.assertTrue(consume.hasError());\r\n\t\t\r\n\t\tconsume = headers.createConsumer(10).consume(new ByteArray(\"X-Header-TooLong: x-value\\r\\n\\r\\n\".getBytes(StandardCharsets.US_ASCII)));\r\n\t\tconsume.block(0);\r\n\t\tAssert.assertTrue(consume.hasError());\r\n\t\t\r\n\t\tconsume = headers.createConsumer(10).consume(new ByteArray(\"X: y\\r\\nZ: zzzzzzzzzz\\r\\n\\r\\n\".getBytes(StandardCharsets.US_ASCII)));\r\n\t\tconsume.block(0);\r\n\t\tAssert.assertTrue(consume.hasError());\r\n\t\t\r\n\t\tconsume = headers.createConsumer(10).consume(new ByteArray(\"X: abcde\\r\\n\\r\\n\".getBytes(StandardCharsets.US_ASCII)));\r\n\t\tconsume.block(0);\r\n\t\tAssert.assertTrue(consume.hasError());\r\n\t\t\r\n\t\tconsume = headers.createConsumer(100).consume(new ByteArray(\" X: abcde\\r\\n\\r\\n\".getBytes(StandardCharsets.US_ASCII)));\r\n\t\tconsume.block(0);\r\n\t\tAssert.assertTrue(consume.hasError());\r\n\t\t\r\n\t\tconsume = headers.createConsumer(100).consume(new ByteArray(\"123465789\\r\\n\\r\\n\".getBytes(StandardCharsets.US_ASCII)));\r\n\t\tconsume.block(0);\r\n\t\tAssert.assertTrue(consume.hasError());\r\n\t}\r\n\t\r\n\tpublic static class Container implements MimeHeadersContainer<Container> {\r\n\t\t\r\n\t\tprivate MimeHeaders headers = new MimeHeaders();\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic MimeHeaders getHeaders() {\r\n\t\t\treturn headers;\r\n\t\t}\r\n\t}\r\n\t\r\n\t@Test\r\n\tpublic void testHeadersContainer() throws Exception {\r\n\t\tContainer c = new Container();\r\n\t\tc.addHeader(new MimeHeader(\"a\", \"b\"));\r\n\t\tc.addHeader(\"c\", \"d\");\r\n\t\tc.addHeader(\"e\", new ParameterizedHeaderValue(\"f\", \"g\", \"h\"));\r\n\t\tAssert.assertEquals(\"b\", c.getHeaders().getFirstRawValue(\"a\"));\r\n\t\tAssert.assertEquals(\"d\", c.getHeaders().getFirstRawValue(\"c\"));\r\n\t\tc.setHeader(\"c\", \"1\");\r\n\t\tAssert.assertEquals(\"1\", c.getHeaders().getFirstRawValue(\"c\"));\r\n\t\tc.setHeader(new MimeHeader(\"c\", \"2\"));\r\n\t\tAssert.assertEquals(\"2\", c.getHeaders().getFirstRawValue(\"c\"));\r\n\t\tc.setHeader(\"c\", new ParameterizedHeaderValue(\"A\", \"B\", \"C\"));\r\n\t\tAssert.assertEquals(\"A\", c.getHeaders().getFirstValue(\"c\", ParameterizedHeaderValue.class).getMainValue());\r\n\t}\r\n\t\r\n"]]}
{"hexsha": "039e5289f5325e47f3f7e0acce78e60e0c47e626", "ext": "java", "lang": "Java", "content": "public class ExecutionTest {\n\n    @Test\n    public void main() throws IOException {\n\n        ShaclSail shaclSail = new ShaclSail(new MemoryStore());\n        SailRepository sailRepository = new SailRepository(shaclSail);\n        sailRepository.init();\n\n        try (SailRepositoryConnection connection = sailRepository.getConnection()) {\n            connection.begin();\n            StringReader shaclRules = new StringReader(\n                    String.join(\"\\n\", \"\",\n                            \"@prefix ex: <http://example.com/ns#> .\",\n                            \"@prefix sh: <http://www.w3.org/ns/shacl#> .\",\n                            \"@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .\",\n                            \"@prefix foaf: <http://xmlns.com/foaf/0.1/>.\",\n\n                            \"ex:PersonShape\",\n                            \"  a sh:NodeShape  ;\",\n                            \"  sh:targetClass foaf:Person ;\",\n                            \"  sh:property ex:PersonShapeProperty .\",\n\n                            \"ex:PersonShapeProperty \",\n                            \"  sh:path foaf:age ;\",\n                            \"  sh:datatype xsd:int ;\",\n                            \"  sh:maxCount 1 ;\",\n                            \"  sh:minCount 1 .\"\n                    ));\n\n            connection.add(shaclRules, \"\", RDFFormat.TURTLE, RDF4J.SHACL_SHAPE_GRAPH);\n            connection.commit();\n        }\n\n        try (SailRepositoryConnection connection = sailRepository.getConnection()) {\n            connection.begin();\n\n            StringReader invalidSampleData = new StringReader(\n                    String.join(\"\\n\", \"\",\n                            \"@prefix ex: <http://example.com/ns#> .\",\n                            \"@prefix foaf: <http://xmlns.com/foaf/0.1/>.\",\n                            \"@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .\",\n\n                            \"ex:peter a foaf:Person ;\",\n                            \"  foaf:age 20, \\\"30\\\"^^xsd:int  .\"\n\n                    ));\n\n            connection.add(invalidSampleData, \"\", RDFFormat.TURTLE);\n            try {\n                connection.commit();\n            } catch (RepositoryException exception) {\n                Throwable cause = exception.getCause();\n                if (cause instanceof ShaclSailValidationException) {\n                    ValidationReport validationReport = ((ShaclSailValidationException) cause).getValidationReport();\n                    Model validationReportModel = ((ShaclSailValidationException) cause).validationReportAsModel();\n                    return;\n                }\n                throw exception;\n            }\n        }\n    }\n\n}", "class_id": 0, "repo": "rpatil524/etl", "file": "plugins/t-shacl/src/test/java/com/linkedpipes/plugin/transformer/shacl/ExecutionTest.java", "last_update_at": "2020-12-17T00:45:26+00:00", "question_id": "039e5289f5325e47f3f7e0acce78e60e0c47e626", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ExecutionTest {\n    @Test\n    public void main() throws IOException {\n        ShaclSail shaclSail = new ShaclSail(new MemoryStore());\n        SailRepository sailRepository = new SailRepository(shaclSail);\n        sailRepository.init();\n        try (SailRepositoryConnection connection = sailRepository.getConnection()) {\n            connection.begin();\n            StringReader shaclRules = new StringReader(\n                    String.join(\"\\n\", \"\",\n                            \"@prefix ex: <http://example.com/ns#> .\",\n                            \"@prefix sh: <http://www.w3.org/ns/shacl#> .\",\n                            \"@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .\",\n                            \"@prefix foaf: <http://xmlns.com/foaf/0.1/>.\",\n                            \"ex:PersonShape\",\n                            \"  a sh:NodeShape  ;\",\n                            \"  sh:targetClass foaf:Person ;\",\n                            \"  sh:property ex:PersonShapeProperty .\",\n                            \"ex:PersonShapeProperty \",\n                            \"  sh:path foaf:age ;\",\n                            \"  sh:datatype xsd:int ;\",\n                            \"  sh:maxCount 1 ;\",\n                            \"  sh:minCount 1 .\"\n                    ));\n            connection.add(shaclRules, \"\", RDFFormat.TURTLE, RDF4J.SHACL_SHAPE_GRAPH);\n            connection.commit();\n        }\n        try (SailRepositoryConnection connection = sailRepository.getConnection()) {\n            connection.begin();\n            StringReader invalidSampleData = new StringReader(\n                    String.join(\"\\n\", \"\",\n                            \"@prefix ex: <http://example.com/ns#> .\",\n                            \"@prefix foaf: <http://xmlns.com/foaf/0.1/>.\",\n                            \"@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .\",\n                            \"ex:peter a foaf:Person ;\",\n                            \"  foaf:age 20, \\\"30\\\"^^xsd:int  .\"\n                    ));\n            connection.add(invalidSampleData, \"\", RDFFormat.TURTLE);\n            try {\n                connection.commit();\n            } catch (RepositoryException exception) {\n                Throwable cause = exception.getCause();\n                if (cause instanceof ShaclSailValidationException) {\n                    ValidationReport validationReport = ((ShaclSailValidationException) cause).getValidationReport();\n                    Model validationReportModel = ((ShaclSailValidationException) cause).validationReportAsModel();\n                    return;\n                }\n                throw exception;\n            }\n        }\n    }\n"]]}
{"hexsha": "1e9917f7a1d92e43a183f5e4598c7ca83d807b1a", "ext": "java", "lang": "Java", "content": "@EqualsAndHashCode\npublic class RoleRequestCondition implements RequestCondition<RoleRequestCondition> {\n    private Set<String> roles;\n\n    public RoleRequestCondition(Set<String> roles) {\n        this.roles = roles;\n    }\n\n    public RoleRequestCondition(String... roles) {\n        this(new HashSet<>(Arrays.asList(roles)));\n    }\n\n    public Set<String> getRoles() {\n        return roles;\n    }\n\n    @Override\n    public RoleRequestCondition combine(RoleRequestCondition other) {\n        this.roles.addAll(other.getRoles());\n        return this;\n    }\n\n    @Override\n    public RoleRequestCondition getMatchingCondition(HttpServletRequest request) {\n        Set<String> userRoles = SecurityContextHolder.getContext().getAuthentication().getAuthorities().stream()\n                .map(GrantedAuthority::getAuthority)\n                .collect(Collectors.toSet());\n\n        for (String role : userRoles) {\n            if (this.roles.contains(role)) {\n                return this;\n            }\n        }\n\n        return null;\n    }\n\n    @Override\n    public int compareTo(RoleRequestCondition other, HttpServletRequest request) {\n        return this.roles.size() - other.getRoles().size();\n    }\n}", "class_id": 0, "repo": "Civil-Service-Human-Resources/learning-catalogue", "file": "src/main/java/uk/gov/cslearning/catalogue/mapping/RoleRequestCondition.java", "last_update_at": "2020-07-31T10:01:57+00:00", "question_id": "1e9917f7a1d92e43a183f5e4598c7ca83d807b1a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@EqualsAndHashCode\npublic class RoleRequestCondition implements RequestCondition<RoleRequestCondition> {\n    private Set<String> roles;\n    public RoleRequestCondition(Set<String> roles) {\n        this.roles = roles;\n    }\n    public RoleRequestCondition(String... roles) {\n        this(new HashSet<>(Arrays.asList(roles)));\n    }\n    public Set<String> getRoles() {\n        return roles;\n    }\n    @Override\n    public RoleRequestCondition combine(RoleRequestCondition other) {\n        this.roles.addAll(other.getRoles());\n        return this;\n    }\n    @Override\n    public RoleRequestCondition getMatchingCondition(HttpServletRequest request) {\n        Set<String> userRoles = SecurityContextHolder.getContext().getAuthentication().getAuthorities().stream()\n                .map(GrantedAuthority::getAuthority)\n                .collect(Collectors.toSet());\n        for (String role : userRoles) {\n            if (this.roles.contains(role)) {\n                return this;\n            }\n        }\n        return null;\n    }\n    @Override\n    public int compareTo(RoleRequestCondition other, HttpServletRequest request) {\n        return this.roles.size() - other.getRoles().size();\n    }\n"]]}
{"hexsha": "2d5f5d1979a7349dfa22bc295c4b17b5a3613205", "ext": "java", "lang": "Java", "content": "@RunWith(Parameterized.class)\npublic class PersistentTreeMapTest extends AbstractPersistentMapTest {\n    \n    @Parameters(name = \"{0}\")\n    public static Collection<Object[]> data() {\n        return Arrays.asList(new Object[][] {{BalancerType.AVL}, {BalancerType.NON_BALANCED}});\n    }\n    \n    private final BalancerType balancer;\n    \n    public PersistentTreeMapTest(BalancerType balancer) {\n        this.balancer = balancer;\n    }\n    \n    @Override\n    protected PersistentMap<String, Integer> empty() {\n        return PersistentTreeMap.<String, Integer>empty(String.class, balancer);\n    }\n    \n    @Test\n    public void invariants() {\n        checkInvariants(mapEmpty);\n        checkInvariants(mapSingleton);\n        checkInvariants(mapThree);\n        checkInvariants(mapLarge);\n    }\n    \n    private void checkInvariants(PersistentMap<String, Integer> map) {\n        PersistentTreeMap<?, ?, ?> treeMap = ObjectUtil.castOrNull(map, PersistentTreeMap.class);\n        if (treeMap != null) {\n            treeMap.checkInvariants();\n        }\n    }\n    \n}", "class_id": 0, "repo": "iquadrat/collection", "file": "org.povworld.collection/test/test/org/povworld/collection/persistent/PersistentTreeMapTest.java", "last_update_at": "2020-04-28T07:15:36+00:00", "question_id": "2d5f5d1979a7349dfa22bc295c4b17b5a3613205", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(Parameterized.class)\npublic class PersistentTreeMapTest extends AbstractPersistentMapTest {\n    @Parameters(name = \"{0}\")\n    public static Collection<Object[]> data() {\n        return Arrays.asList(new Object[][] {{BalancerType.AVL}, {BalancerType.NON_BALANCED}});\n    }\n    private final BalancerType balancer;\n    public PersistentTreeMapTest(BalancerType balancer) {\n        this.balancer = balancer;\n    }\n    @Override\n    protected PersistentMap<String, Integer> empty() {\n        return PersistentTreeMap.<String, Integer>empty(String.class, balancer);\n    }\n    @Test\n    public void invariants() {\n        checkInvariants(mapEmpty);\n        checkInvariants(mapSingleton);\n        checkInvariants(mapThree);\n        checkInvariants(mapLarge);\n    }\n    private void checkInvariants(PersistentMap<String, Integer> map) {\n        PersistentTreeMap<?, ?, ?> treeMap = ObjectUtil.castOrNull(map, PersistentTreeMap.class);\n        if (treeMap != null) {\n            treeMap.checkInvariants();\n        }\n    }\n"]]}
{"hexsha": "e37c75d21d711925fdb47bbb761a08f1d3080090", "ext": "java", "lang": "Java", "content": "public class ConceptTest {\n\n    Concept c1,c2,c3,c4;\n    \n    @Before\n    public void setUp() throws Exception {\n        c1 = new Concept(1);\n        c2 = new Concept(2);\n        c3 = new Concept(3);\n        c4 = new Concept(4);\n\n        c1.setPrimitive(true);\n        c2.setPrimitive(true);\n        c3.setPrimitive(true);\n        c4.setPrimitive(true);\n    }\n\n    /*\n     * Test case 1:\n     * ------------\n     * {1,2,3} is primitive\n     * 1 isKindOf 2\n     * 2 isKindOf 3\n     * \n     * All primitive supertypes for concept 1: \n     * {2,3}\n     * \n     * All supertypes for concept 1:\n     * {2,3} \n     */\n    @Test\n    public void shouldPassPrimitiveParentTestCase1_WithCache() {\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);\n        assertEquals(2, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c2));\n        assertTrue(allPrimitive.contains(c3));\n    }\n\n    @Test\n    public void shouldPassPrimitiveParentTestCase1_WithoutCache() {\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);\n        assertEquals(2, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c2));\n        assertTrue(allPrimitive.contains(c3));\n    } \n    \n    @Test\n    public void shouldPassParentTestCase1_WithoutCache() {\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);\n        assertEquals(2, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n    }     \n    \n    @Test\n    public void shouldPassParentTestCase1_WithCache() {\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);\n        assertEquals(2, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n    }         \n\n    /*\n     * Test case 2:\n     * ------------\n     * {1,3} is primitive, {2} is not primitive\n     * 1 isKindOf 2\n     * 2 isKindOf 3\n     * \n     * All primitive supertypes for concept 1: \n     * {3}\n     * \n     * All supertypes for concept 1:\n     * {2,3}\n     */ \n    @Test\n    public void shouldPassPrimitiveParentTestCase2_WithCache() {\n        c2.setPrimitive(false);\n\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);\n        assertEquals(1, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c3));\n    }\n    @Test\n    public void shouldPassPrimitiveParentTestCase2_WithoutCache() {\n        c2.setPrimitive(false);\n\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);\n        assertEquals(1, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c3));\n    }\n    \n    @Test\n    public void shouldPassParentTestCase2_WithCache() {\n        c2.setPrimitive(false);\n\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);\n        assertEquals(2, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n    }\n    @Test\n    public void shouldPassParentTestCase2_WithoutCache() {\n        c2.setPrimitive(false);\n\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);\n        assertEquals(2, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n    }    \n\n    /*\n     * Test case 3:\n     * ------------\n     * {1,4} is primitive, {2,3} is not primitive\n     * 1 isKindOf 2\n     * 2 isKindOf 3\n     * 3 isKindOf 4\n     * \n     * All primitive supertypes for concept 1: \n     * {4}\n     * \n     * All supertypes for concept 1:\n     * {2,3,4}\n     */ \n    @Test\n    public void shouldPassPrimitiveParentTestCase3_WithCache() {\n        c2.setPrimitive(false);\n        c3.setPrimitive(false);\n\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);\n        assertEquals(1, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c4));\n    }    \n\n    @Test\n    public void shouldPassPrimitiveParentTestCase3_WithoutCache() {\n        c2.setPrimitive(false);\n        c3.setPrimitive(false);\n\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);\n        assertEquals(1, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c4));\n    }      \n    \n    @Test\n    public void shouldPassParentTestCase3_WithCache() {\n        c2.setPrimitive(false);\n        c3.setPrimitive(false);\n\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);\n        assertEquals(3, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n        assertTrue(allKindOfs.contains(c4));\n    }    \n\n    @Test\n    public void shouldPassPrimitiveTestCase3_WithoutCache() {\n        c2.setPrimitive(false);\n        c3.setPrimitive(false);\n\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);\n        assertEquals(3, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n        assertTrue(allKindOfs.contains(c4));\n    }     \n\n\n    /*\n     * Test case 4:\n     * ------------\n     * {1,2,3,4} is primitive\n     * 1 isKindOf 2\n     * 2 isKindOf 3\n     * 3 isKindOf 4 \n     * \n     * All primitive supertypes for concept 1: \n     * {2,3,4}\n     * \n     * All supertypes for concept 1: \n     * {2,3,4}\n     */\n    @Test\n    public void shouldPassPrimitiveParentTestCase4_WithCache() {\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);\n        assertEquals(3, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c2));\n        assertTrue(allPrimitive.contains(c3));\n        assertTrue(allPrimitive.contains(c4));\n    } \n\n    @Test\n    public void shouldPassPrimitiveParentTestCase4_WithoutCache() {\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);\n        assertEquals(3, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c2));\n        assertTrue(allPrimitive.contains(c3));\n        assertTrue(allPrimitive.contains(c4));\n    } \n    \n    @Test\n    public void shouldPassParentTestCase4_WithCache() {\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);\n        assertEquals(3, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n        assertTrue(allKindOfs.contains(c4));\n    } \n\n    @Test\n    public void shouldPassParentTestCase4_WithoutCache() {\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);\n        assertEquals(3, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n        assertTrue(allKindOfs.contains(c4));\n    }     \n\n    /*\n     * Test case 5:\n     * ------------\n     * {1,2,3,4,5} is primitive\n     * 1 isKindOf 2\n     * 1 isKindOf 3\n     * 2 isKindof 4\n     * 3 isKindOf 4\n     * \n     * All primitive supertypes for concept 1: \n     * {2,3,4}\n     * \n     * All supertypes for concept 1: \n     * {2,3,4}\n     */\n    @Test\n    public void shouldPassPrimitiveParentTestCase5_WithCache() {\n        c1.addKindOf(c2);\n        c1.addKindOf(c3);\n        c2.addKindOf(c4);\n        c3.addKindOf(c4);\n\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);\n        assertEquals(3, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c2));\n        assertTrue(allPrimitive.contains(c3));\n        assertTrue(allPrimitive.contains(c4));\n    }\n\n    @Test\n    public void shouldPassPrimitiveParentTestCase5_WithoutCache() {\n        c1.addKindOf(c2);\n        c1.addKindOf(c3);\n        c2.addKindOf(c4);\n        c3.addKindOf(c4);\n\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);\n        assertEquals(3, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c2));\n        assertTrue(allPrimitive.contains(c3));\n        assertTrue(allPrimitive.contains(c4));\n    }   \n    \n    @Test\n    public void shouldPassParentTestCase5_WithCache() {\n        c1.addKindOf(c2);\n        c1.addKindOf(c3);\n        c2.addKindOf(c4);\n        c3.addKindOf(c4);\n\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);\n        assertEquals(3, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n        assertTrue(allKindOfs.contains(c4));\n    }\n\n    @Test\n    public void shouldPassParentTestCase5_WithoutCache() {\n        c1.addKindOf(c2);\n        c1.addKindOf(c3);\n        c2.addKindOf(c4);\n        c3.addKindOf(c4);\n\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);\n        assertEquals(3, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n        assertTrue(allKindOfs.contains(c4));\n    }       \n\n    /*\n     * Test case 6:\n     * ------------\n     * {1,2,4} is primitive, {3} is not primitive\n     * 1 isKindOf 2\n     * 2 isKindOf 3\n     * 3 isKindof 4\n     * \n     * All primitive supertypes for concept 1: \n     * {2,4}\n     * \n     * All supertypes for concept 1: \n     * {2,3,4}\n     */\n    @Test\n    public void shouldPassPrimitiveParentTestCase6_WithCache() {\n        c3.setPrimitive(false);\n\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);\n        assertEquals(2, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c2));\n        assertTrue(allPrimitive.contains(c4));\n    }\n\n    @Test\n    public void shouldPassPrimitiveParentTestCase6_WithoutCache() {\n        c3.setPrimitive(false);\n\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);\n        assertEquals(2, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c2));\n        assertTrue(allPrimitive.contains(c4));\n    }  \n    \n    @Test\n    public void shouldPassParentTestCase6_WithCache() {\n        c3.setPrimitive(false);\n\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);\n        assertEquals(3, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n        assertTrue(allKindOfs.contains(c4));\n    }\n\n    @Test\n    public void shouldPassParentTestCase6_WithoutCache() {\n        c3.setPrimitive(false);\n\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);\n        assertEquals(3, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n        assertTrue(allKindOfs.contains(c4));\n    }      \n\n    /*\n     * Test case 7:\n     * ------------\n     * {1,4} is primitive, {2,3} is not primitive\n     * 1 isKindOf 2\n     * 1 isKindOf 3\n     * 2 isKindof 4\n     * 3 isKindOf 4\n     * \n     * All primitive supertypes for concept 1: \n     * {4}\n     * \n     * All supertypes for concept 1: \n     * {2,3,4}\n     */\n    @Test\n    public void shouldPassPrimitiveParentTestCase7_WithCache() {\n        c2.setPrimitive(false);\n        c3.setPrimitive(false);\n\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n        c1.addKindOf(c4);\n\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);\n        assertEquals(1, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c4));\n    }   \n\n    @Test\n    public void shouldPassPrimitiveParentTestCase7_WithoutCache() {\n        c2.setPrimitive(false);\n        c3.setPrimitive(false);\n\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n        c1.addKindOf(c4);\n\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);\n        assertEquals(1, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c4));\n    }   \n    \n    @Test\n    public void shouldPassParentTestCase7_WithCache() {\n        c2.setPrimitive(false);\n        c3.setPrimitive(false);\n\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n        c1.addKindOf(c4);\n\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);\n        assertEquals(3, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c4));\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n    }   \n\n    @Test\n    public void shouldPassParentTestCase7_WithoutCache() {\n        c2.setPrimitive(false);\n        c3.setPrimitive(false);\n\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n        c1.addKindOf(c4);\n\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);\n        assertEquals(3, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c4));\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n    }       \n\n    /*\n     * Test case 8:\n     * ------------\n     * {1,2,4} is primitive, {3} is not primitive\n     * 1 isKindOf 2\n     * 1 isKindOf 3\n     * 2 isKindof 4\n     * 3 isKindOf 4\n     * \n     * All primitive supertypes for concept 1: \n     * {2,4}\n     * \n     * All supertypes for concept 1: \n     * {2,3,4}\n     */\n    @Test\n    public void shouldPassPrimitiveParentTestCase8_WithCache() {\n        c3.setPrimitive(false);\n\n        c1.addKindOf(c2);\n        c1.addKindOf(c3);\n        c2.addKindOf(c4);\n        c3.addKindOf(c4);\n\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);\n        assertEquals(2, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c4));\n        assertTrue(allPrimitive.contains(c2));\n    }   \n\n    @Test\n    public void shouldPassPrimitiveParentTestCase8_WithoutCache() {\n        c3.setPrimitive(false);\n\n        c1.addKindOf(c2);\n        c1.addKindOf(c3);\n        c2.addKindOf(c4);\n        c3.addKindOf(c4);\n\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);\n        assertEquals(2, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c4));\n        assertTrue(allPrimitive.contains(c2));\n    }    \n    @Test\n    public void shouldPassParentTestCase8_WithCache() {\n        c3.setPrimitive(false);\n\n        c1.addKindOf(c2);\n        c1.addKindOf(c3);\n        c2.addKindOf(c4);\n        c3.addKindOf(c4);\n\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);\n        assertEquals(3, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c4));\n        assertTrue(allKindOfs.contains(c3));\n        assertTrue(allKindOfs.contains(c2));\n    }   \n\n    @Test\n    public void shouldPassParentTestCase8_WithoutCache() {\n        c3.setPrimitive(false);\n\n        c1.addKindOf(c2);\n        c1.addKindOf(c3);\n        c2.addKindOf(c4);\n        c3.addKindOf(c4);\n\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);\n        assertEquals(3, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c4));\n        assertTrue(allKindOfs.contains(c3));\n        assertTrue(allKindOfs.contains(c2));\n    }\n    \n    \n    \n\n    @Test\n    public void shouldReturnTrueForIsKindOfPredicate(){\n        assertTrue(new Concept(Concept.IS_KIND_OF_RELATIONSHIP_TYPE_ID).isKindOfPredicate());\n    }\n    \n    @Test\n    public void shouldReturnTrueForIsPredicate(){\n        Concept c = new Concept(123);\n        c.addPredicateOfStatement(new Statement(Statement.SERIALISED_ID_NOT_DEFINED));\n        assertTrue(c.isPredicate());\n    }\n    \n    @Test\n    public void shouldBeEqualConcepts(){\n        Concept c1 = new Concept(123);\n        Concept c2 = new Concept(123);\n        assertEquals(c1, c2);\n        assertEquals(c1.hashCode(), c2.hashCode());\n    }\n    \n    @Test\n    public void shouldBeUnequalConcepts(){\n        Concept c1 = new Concept(123);\n        Concept c2 = new Concept(1234);\n        assertNotEquals(c1, c2);\n        assertNotEquals(c1.hashCode(), c2.hashCode());\n    }\n    \n    @Test\n    public void shouldCreateGroupFromStatement() throws InvalidInputException{\n        Concept c = new Concept(123);\n        Concept p = new Concept(999);\n        Concept o = new Concept(666);\n        Statement s = new Statement(444);\n        s.setSubject(c);\n        s.setPredicate(p);\n        s.setObject(o);\n        s.setGroupId(5);\n        c.addSubjectOfStatement(s);\n        Group g = new Group(s);\n        assertTrue(g.equals(c.getGroup(s)));\n    }\n    \n    @Test\n    public void shouldGetGroupFromStatement() throws InvalidInputException{\n        Concept c = new Concept(123);\n        Concept p = new Concept(999);\n        Concept o = new Concept(666);\n        Statement s = new Statement(444);\n        s.setSubject(c);\n        s.setPredicate(p);\n        s.setObject(o);\n        s.setGroupId(5);\n        c.addSubjectOfStatement(s);\n        Group g = new Group(s);\n        //create group\n        assertTrue(g.equals(c.getGroup(s)));\n        //get group\n        assertTrue(g.equals(c.getGroup(s)));\n    }\n    \n    @Test\n    public void shouldGetCorrectGroupFromMultipleGroupsTrue() throws InvalidInputException{\n        Concept c = new Concept(123);\n        \n        Statement s = new Statement(444);\n        s.setSubject(c);\n        s.setPredicate(new Concept(999));\n        s.setObject(new Concept(666));\n        s.setGroupId(5);\n\n        Statement s1 = new Statement(444);\n        s1.setSubject(c);\n        s1.setPredicate(new Concept(9991));\n        s1.setObject(new Concept(6661));\n        s1.setGroupId(2);\n\n        c.addSubjectOfStatement(s);\n        c.addSubjectOfStatement(s1);\n        \n        assertTrue(new Group(s).equals(c.getGroup(s)));\n    }\n\n    @Test\n    public void shouldGetCorrectGroupFromMultipleStatementsTrue() throws InvalidInputException{\n        Concept c = new Concept(123);\n        \n        Statement s = new Statement(444);\n        s.setSubject(c);\n        s.setPredicate(new Concept(999));\n        s.setObject(new Concept(666));\n        s.setGroupId(2);\n\n        Statement s1 = new Statement(4441);\n        s1.setSubject(c);\n        s1.setPredicate(new Concept(9991));\n        s1.setObject(new Concept(6661));\n        s1.setGroupId(2);\n\n        c.addSubjectOfStatement(s);\n        c.addSubjectOfStatement(s1);\n        \n        assertTrue(new Group(Arrays.asList(s1, s)).equals(c.getGroup(s)));\n    }\n    \n    @Test\n    public void shouldGetCorrectGroupFromMultipleStatementsFalse() throws InvalidInputException{\n        Concept c = new Concept(123);\n        \n        Statement s = new Statement(444);\n        s.setSubject(c);\n        s.setPredicate(new Concept(999));\n        s.setObject(new Concept(666));\n        s.setGroupId(2);\n\n        Statement s1 = new Statement(4441);\n        s1.setSubject(c);\n        s1.setPredicate(new Concept(9991));\n        s1.setObject(new Concept(6661));\n        s1.setGroupId(2);\n\n        c.addSubjectOfStatement(s);\n        c.addSubjectOfStatement(s1);\n        \n        assertTrue(!new Group(Arrays.asList(s1)).equals(c.getGroup(s)));\n    }    \n    \n    @Test\n    public void shouldGetCorrectGroupFromMultipleGroupsFalse() throws InvalidInputException{\n        Concept c = new Concept(123);\n\n        Statement s = new Statement(444);\n        s.setSubject(c);\n        s.setPredicate(new Concept(999));\n        s.setObject(new Concept(666));\n        s.setGroupId(5);\n\n        Statement s1 = new Statement(444);\n        s1.setSubject(c);\n        s1.setPredicate(new Concept(9991));\n        s1.setObject(new Concept(6661));\n        s1.setGroupId(2);\n\n        c.addSubjectOfStatement(s);\n        c.addSubjectOfStatement(s1);\n\n        assertTrue(!new Group(s1).equals(c.getGroup(s)));\n    }\n    \n    \n\n}", "class_id": 0, "repo": "sparkling/snomed-publish", "file": "model/src/test/java/com/ihtsdo/snomed/model/ConceptTest.java", "last_update_at": "2020-08-10T13:07:01+00:00", "question_id": "e37c75d21d711925fdb47bbb761a08f1d3080090", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ConceptTest {\n    Concept c1,c2,c3,c4;\n    @Before\n    public void setUp() throws Exception {\n        c1 = new Concept(1);\n        c2 = new Concept(2);\n        c3 = new Concept(3);\n        c4 = new Concept(4);\n        c1.setPrimitive(true);\n        c2.setPrimitive(true);\n        c3.setPrimitive(true);\n        c4.setPrimitive(true);\n    }\n    /*\n     * Test case 1:\n     * ------------\n     * {1,2,3} is primitive\n     * 1 isKindOf 2\n     * 2 isKindOf 3\n     * \n     * All primitive supertypes for concept 1: \n     * {2,3}\n     * \n     * All supertypes for concept 1:\n     * {2,3} \n     */\n    @Test\n    public void shouldPassPrimitiveParentTestCase1_WithCache() {\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);\n        assertEquals(2, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c2));\n        assertTrue(allPrimitive.contains(c3));\n    }\n    @Test\n    public void shouldPassPrimitiveParentTestCase1_WithoutCache() {\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);\n        assertEquals(2, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c2));\n        assertTrue(allPrimitive.contains(c3));\n    } \n    @Test\n    public void shouldPassParentTestCase1_WithoutCache() {\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);\n        assertEquals(2, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n    }     \n    @Test\n    public void shouldPassParentTestCase1_WithCache() {\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);\n        assertEquals(2, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n    }         \n    /*\n     * Test case 2:\n     * ------------\n     * {1,3} is primitive, {2} is not primitive\n     * 1 isKindOf 2\n     * 2 isKindOf 3\n     * \n     * All primitive supertypes for concept 1: \n     * {3}\n     * \n     * All supertypes for concept 1:\n     * {2,3}\n     */ \n    @Test\n    public void shouldPassPrimitiveParentTestCase2_WithCache() {\n        c2.setPrimitive(false);\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);\n        assertEquals(1, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c3));\n    }\n    @Test\n    public void shouldPassPrimitiveParentTestCase2_WithoutCache() {\n        c2.setPrimitive(false);\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);\n        assertEquals(1, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c3));\n    }\n    @Test\n    public void shouldPassParentTestCase2_WithCache() {\n        c2.setPrimitive(false);\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);\n        assertEquals(2, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n    }\n    @Test\n    public void shouldPassParentTestCase2_WithoutCache() {\n        c2.setPrimitive(false);\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);\n        assertEquals(2, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n    }    \n    /*\n     * Test case 3:\n     * ------------\n     * {1,4} is primitive, {2,3} is not primitive\n     * 1 isKindOf 2\n     * 2 isKindOf 3\n     * 3 isKindOf 4\n     * \n     * All primitive supertypes for concept 1: \n     * {4}\n     * \n     * All supertypes for concept 1:\n     * {2,3,4}\n     */ \n    @Test\n    public void shouldPassPrimitiveParentTestCase3_WithCache() {\n        c2.setPrimitive(false);\n        c3.setPrimitive(false);\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);\n        assertEquals(1, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c4));\n    }    \n    @Test\n    public void shouldPassPrimitiveParentTestCase3_WithoutCache() {\n        c2.setPrimitive(false);\n        c3.setPrimitive(false);\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);\n        assertEquals(1, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c4));\n    }      \n    @Test\n    public void shouldPassParentTestCase3_WithCache() {\n        c2.setPrimitive(false);\n        c3.setPrimitive(false);\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);\n        assertEquals(3, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n        assertTrue(allKindOfs.contains(c4));\n    }    \n    @Test\n    public void shouldPassPrimitiveTestCase3_WithoutCache() {\n        c2.setPrimitive(false);\n        c3.setPrimitive(false);\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);\n        assertEquals(3, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n        assertTrue(allKindOfs.contains(c4));\n    }     \n    /*\n     * Test case 4:\n     * ------------\n     * {1,2,3,4} is primitive\n     * 1 isKindOf 2\n     * 2 isKindOf 3\n     * 3 isKindOf 4 \n     * \n     * All primitive supertypes for concept 1: \n     * {2,3,4}\n     * \n     * All supertypes for concept 1: \n     * {2,3,4}\n     */\n    @Test\n    public void shouldPassPrimitiveParentTestCase4_WithCache() {\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);\n        assertEquals(3, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c2));\n        assertTrue(allPrimitive.contains(c3));\n        assertTrue(allPrimitive.contains(c4));\n    } \n    @Test\n    public void shouldPassPrimitiveParentTestCase4_WithoutCache() {\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);\n        assertEquals(3, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c2));\n        assertTrue(allPrimitive.contains(c3));\n        assertTrue(allPrimitive.contains(c4));\n    } \n    @Test\n    public void shouldPassParentTestCase4_WithCache() {\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);\n        assertEquals(3, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n        assertTrue(allKindOfs.contains(c4));\n    } \n    @Test\n    public void shouldPassParentTestCase4_WithoutCache() {\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);\n        assertEquals(3, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n        assertTrue(allKindOfs.contains(c4));\n    }     \n    /*\n     * Test case 5:\n     * ------------\n     * {1,2,3,4,5} is primitive\n     * 1 isKindOf 2\n     * 1 isKindOf 3\n     * 2 isKindof 4\n     * 3 isKindOf 4\n     * \n     * All primitive supertypes for concept 1: \n     * {2,3,4}\n     * \n     * All supertypes for concept 1: \n     * {2,3,4}\n     */\n    @Test\n    public void shouldPassPrimitiveParentTestCase5_WithCache() {\n        c1.addKindOf(c2);\n        c1.addKindOf(c3);\n        c2.addKindOf(c4);\n        c3.addKindOf(c4);\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);\n        assertEquals(3, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c2));\n        assertTrue(allPrimitive.contains(c3));\n        assertTrue(allPrimitive.contains(c4));\n    }\n    @Test\n    public void shouldPassPrimitiveParentTestCase5_WithoutCache() {\n        c1.addKindOf(c2);\n        c1.addKindOf(c3);\n        c2.addKindOf(c4);\n        c3.addKindOf(c4);\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);\n        assertEquals(3, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c2));\n        assertTrue(allPrimitive.contains(c3));\n        assertTrue(allPrimitive.contains(c4));\n    }   \n    @Test\n    public void shouldPassParentTestCase5_WithCache() {\n        c1.addKindOf(c2);\n        c1.addKindOf(c3);\n        c2.addKindOf(c4);\n        c3.addKindOf(c4);\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);\n        assertEquals(3, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n        assertTrue(allKindOfs.contains(c4));\n    }\n    @Test\n    public void shouldPassParentTestCase5_WithoutCache() {\n        c1.addKindOf(c2);\n        c1.addKindOf(c3);\n        c2.addKindOf(c4);\n        c3.addKindOf(c4);\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);\n        assertEquals(3, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n        assertTrue(allKindOfs.contains(c4));\n    }       \n    /*\n     * Test case 6:\n     * ------------\n     * {1,2,4} is primitive, {3} is not primitive\n     * 1 isKindOf 2\n     * 2 isKindOf 3\n     * 3 isKindof 4\n     * \n     * All primitive supertypes for concept 1: \n     * {2,4}\n     * \n     * All supertypes for concept 1: \n     * {2,3,4}\n     */\n    @Test\n    public void shouldPassPrimitiveParentTestCase6_WithCache() {\n        c3.setPrimitive(false);\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);\n        assertEquals(2, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c2));\n        assertTrue(allPrimitive.contains(c4));\n    }\n    @Test\n    public void shouldPassPrimitiveParentTestCase6_WithoutCache() {\n        c3.setPrimitive(false);\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);\n        assertEquals(2, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c2));\n        assertTrue(allPrimitive.contains(c4));\n    }  \n    @Test\n    public void shouldPassParentTestCase6_WithCache() {\n        c3.setPrimitive(false);\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);\n        assertEquals(3, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n        assertTrue(allKindOfs.contains(c4));\n    }\n    @Test\n    public void shouldPassParentTestCase6_WithoutCache() {\n        c3.setPrimitive(false);\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);\n        assertEquals(3, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n        assertTrue(allKindOfs.contains(c4));\n    }      \n    /*\n     * Test case 7:\n     * ------------\n     * {1,4} is primitive, {2,3} is not primitive\n     * 1 isKindOf 2\n     * 1 isKindOf 3\n     * 2 isKindof 4\n     * 3 isKindOf 4\n     * \n     * All primitive supertypes for concept 1: \n     * {4}\n     * \n     * All supertypes for concept 1: \n     * {2,3,4}\n     */\n    @Test\n    public void shouldPassPrimitiveParentTestCase7_WithCache() {\n        c2.setPrimitive(false);\n        c3.setPrimitive(false);\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n        c1.addKindOf(c4);\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);\n        assertEquals(1, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c4));\n    }   \n    @Test\n    public void shouldPassPrimitiveParentTestCase7_WithoutCache() {\n        c2.setPrimitive(false);\n        c3.setPrimitive(false);\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n        c1.addKindOf(c4);\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);\n        assertEquals(1, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c4));\n    }   \n    @Test\n    public void shouldPassParentTestCase7_WithCache() {\n        c2.setPrimitive(false);\n        c3.setPrimitive(false);\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n        c1.addKindOf(c4);\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);\n        assertEquals(3, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c4));\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n    }   \n    @Test\n    public void shouldPassParentTestCase7_WithoutCache() {\n        c2.setPrimitive(false);\n        c3.setPrimitive(false);\n        c1.addKindOf(c2);\n        c2.addKindOf(c3);\n        c3.addKindOf(c4);\n        c1.addKindOf(c4);\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);\n        assertEquals(3, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c4));\n        assertTrue(allKindOfs.contains(c2));\n        assertTrue(allKindOfs.contains(c3));\n    }       \n    /*\n     * Test case 8:\n     * ------------\n     * {1,2,4} is primitive, {3} is not primitive\n     * 1 isKindOf 2\n     * 1 isKindOf 3\n     * 2 isKindof 4\n     * 3 isKindOf 4\n     * \n     * All primitive supertypes for concept 1: \n     * {2,4}\n     * \n     * All supertypes for concept 1: \n     * {2,3,4}\n     */\n    @Test\n    public void shouldPassPrimitiveParentTestCase8_WithCache() {\n        c3.setPrimitive(false);\n        c1.addKindOf(c2);\n        c1.addKindOf(c3);\n        c2.addKindOf(c4);\n        c3.addKindOf(c4);\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);\n        assertEquals(2, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c4));\n        assertTrue(allPrimitive.contains(c2));\n    }   \n    @Test\n    public void shouldPassPrimitiveParentTestCase8_WithoutCache() {\n        c3.setPrimitive(false);\n        c1.addKindOf(c2);\n        c1.addKindOf(c3);\n        c2.addKindOf(c4);\n        c3.addKindOf(c4);\n        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);\n        assertEquals(2, allPrimitive.size());\n        assertTrue(allPrimitive.contains(c4));\n        assertTrue(allPrimitive.contains(c2));\n    }    \n    @Test\n    public void shouldPassParentTestCase8_WithCache() {\n        c3.setPrimitive(false);\n        c1.addKindOf(c2);\n        c1.addKindOf(c3);\n        c2.addKindOf(c4);\n        c3.addKindOf(c4);\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);\n        assertEquals(3, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c4));\n        assertTrue(allKindOfs.contains(c3));\n        assertTrue(allKindOfs.contains(c2));\n    }   \n    @Test\n    public void shouldPassParentTestCase8_WithoutCache() {\n        c3.setPrimitive(false);\n        c1.addKindOf(c2);\n        c1.addKindOf(c3);\n        c2.addKindOf(c4);\n        c3.addKindOf(c4);\n        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);\n        assertEquals(3, allKindOfs.size());\n        assertTrue(allKindOfs.contains(c4));\n        assertTrue(allKindOfs.contains(c3));\n        assertTrue(allKindOfs.contains(c2));\n    }\n    @Test\n    public void shouldReturnTrueForIsKindOfPredicate(){\n        assertTrue(new Concept(Concept.IS_KIND_OF_RELATIONSHIP_TYPE_ID).isKindOfPredicate());\n    }\n    @Test\n    public void shouldReturnTrueForIsPredicate(){\n        Concept c = new Concept(123);\n        c.addPredicateOfStatement(new Statement(Statement.SERIALISED_ID_NOT_DEFINED));\n        assertTrue(c.isPredicate());\n    }\n    @Test\n    public void shouldBeEqualConcepts(){\n        Concept c1 = new Concept(123);\n        Concept c2 = new Concept(123);\n        assertEquals(c1, c2);\n        assertEquals(c1.hashCode(), c2.hashCode());\n    }\n    @Test\n    public void shouldBeUnequalConcepts(){\n        Concept c1 = new Concept(123);\n        Concept c2 = new Concept(1234);\n        assertNotEquals(c1, c2);\n        assertNotEquals(c1.hashCode(), c2.hashCode());\n    }\n    @Test\n    public void shouldCreateGroupFromStatement() throws InvalidInputException{\n        Concept c = new Concept(123);\n        Concept p = new Concept(999);\n        Concept o = new Concept(666);\n        Statement s = new Statement(444);\n        s.setSubject(c);\n        s.setPredicate(p);\n        s.setObject(o);\n        s.setGroupId(5);\n        c.addSubjectOfStatement(s);\n        Group g = new Group(s);\n        assertTrue(g.equals(c.getGroup(s)));\n    }\n    @Test\n    public void shouldGetGroupFromStatement() throws InvalidInputException{\n        Concept c = new Concept(123);\n        Concept p = new Concept(999);\n        Concept o = new Concept(666);\n        Statement s = new Statement(444);\n        s.setSubject(c);\n        s.setPredicate(p);\n        s.setObject(o);\n        s.setGroupId(5);\n        c.addSubjectOfStatement(s);\n        Group g = new Group(s);\n        //create group\n        assertTrue(g.equals(c.getGroup(s)));\n        //get group\n        assertTrue(g.equals(c.getGroup(s)));\n    }\n    @Test\n    public void shouldGetCorrectGroupFromMultipleGroupsTrue() throws InvalidInputException{\n        Concept c = new Concept(123);\n        Statement s = new Statement(444);\n        s.setSubject(c);\n        s.setPredicate(new Concept(999));\n        s.setObject(new Concept(666));\n        s.setGroupId(5);\n        Statement s1 = new Statement(444);\n        s1.setSubject(c);\n        s1.setPredicate(new Concept(9991));\n        s1.setObject(new Concept(6661));\n        s1.setGroupId(2);\n        c.addSubjectOfStatement(s);\n        c.addSubjectOfStatement(s1);\n        assertTrue(new Group(s).equals(c.getGroup(s)));\n    }\n    @Test\n    public void shouldGetCorrectGroupFromMultipleStatementsTrue() throws InvalidInputException{\n        Concept c = new Concept(123);\n        Statement s = new Statement(444);\n        s.setSubject(c);\n        s.setPredicate(new Concept(999));\n        s.setObject(new Concept(666));\n        s.setGroupId(2);\n        Statement s1 = new Statement(4441);\n        s1.setSubject(c);\n        s1.setPredicate(new Concept(9991));\n        s1.setObject(new Concept(6661));\n        s1.setGroupId(2);\n        c.addSubjectOfStatement(s);\n        c.addSubjectOfStatement(s1);\n        assertTrue(new Group(Arrays.asList(s1, s)).equals(c.getGroup(s)));\n    }\n    @Test\n    public void shouldGetCorrectGroupFromMultipleStatementsFalse() throws InvalidInputException{\n        Concept c = new Concept(123);\n        Statement s = new Statement(444);\n        s.setSubject(c);\n        s.setPredicate(new Concept(999));\n        s.setObject(new Concept(666));\n        s.setGroupId(2);\n        Statement s1 = new Statement(4441);\n        s1.setSubject(c);\n        s1.setPredicate(new Concept(9991));\n        s1.setObject(new Concept(6661));\n        s1.setGroupId(2);\n        c.addSubjectOfStatement(s);\n        c.addSubjectOfStatement(s1);\n        assertTrue(!new Group(Arrays.asList(s1)).equals(c.getGroup(s)));\n    }    \n    @Test\n    public void shouldGetCorrectGroupFromMultipleGroupsFalse() throws InvalidInputException{\n        Concept c = new Concept(123);\n        Statement s = new Statement(444);\n        s.setSubject(c);\n        s.setPredicate(new Concept(999));\n        s.setObject(new Concept(666));\n        s.setGroupId(5);\n        Statement s1 = new Statement(444);\n        s1.setSubject(c);\n        s1.setPredicate(new Concept(9991));\n        s1.setObject(new Concept(6661));\n        s1.setGroupId(2);\n        c.addSubjectOfStatement(s);\n        c.addSubjectOfStatement(s1);\n        assertTrue(!new Group(s1).equals(c.getGroup(s)));\n    }\n"]]}
{"hexsha": "3feb49bc81f001ddcb0e322c540c724b505976bb", "ext": "java", "lang": "Java", "content": "public class TestingUtils {\n    public static SimpleDateFormat getFormatter(String pattern) {\n        SimpleDateFormat sdf = new SimpleDateFormat(pattern);\n        sdf.setTimeZone(TimeZone.getTimeZone(ZoneId.of(\"UTC\")));\n        return sdf;\n    }\n}", "class_id": 0, "repo": "yahoo/data-disposal", "file": "src/test/java/com/vz/disposal/utils/TestingUtils.java", "last_update_at": "2020-09-28T08:45:42+00:00", "question_id": "3feb49bc81f001ddcb0e322c540c724b505976bb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestingUtils {\n    public static SimpleDateFormat getFormatter(String pattern) {\n        SimpleDateFormat sdf = new SimpleDateFormat(pattern);\n        sdf.setTimeZone(TimeZone.getTimeZone(ZoneId.of(\"UTC\")));\n        return sdf;\n    }\n"]]}
{"hexsha": "27651879d758f37d00dbead897986e1a3375d6e8", "ext": "java", "lang": "Java", "content": "class TestExecutionProfilerTopN extends StroomUnitTest {\n    @Test\n    void test() {\n        final List<ExecutionProfiler> list = new ArrayList<>();\n        list.add(new SimpleExecutionProfiler(10));\n        list.add(new SimpleExecutionProfiler(1));\n        list.add(new SimpleExecutionProfiler(5));\n\n        final ExecutionProfilerTopN topN = new ExecutionProfilerTopN(list, 2);\n\n        assertThat(topN.getTopN().get(0).getTotalExecutionCount()).isEqualTo(10);\n        assertThat(topN.getTopN().get(1).getTotalExecutionCount()).isEqualTo(5);\n        assertThat(topN.getTopN().size()).isEqualTo(2);\n    }\n\n    class SimpleExecutionProfiler implements ExecutionProfiler {\n        int id;\n\n        public SimpleExecutionProfiler(final int id) {\n            this.id = id;\n        }\n\n        @Override\n        public String getExecutionString() {\n            return String.valueOf(id);\n        }\n\n        @Override\n        public long getTotalExecutionTime() {\n            return id;\n        }\n\n        @Override\n        public long getTotalExecutionCount() {\n            return id;\n        }\n\n    }\n}", "class_id": 0, "repo": "TimYagan/stroom", "file": "stroom-pipeline/src/test/java/stroom/pipeline/xml/converter/ds3/TestExecutionProfilerTopN.java", "last_update_at": "2020-03-23T21:23:14+00:00", "question_id": "27651879d758f37d00dbead897986e1a3375d6e8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class TestExecutionProfilerTopN extends StroomUnitTest {\n    @Test\n    void test() {\n        final List<ExecutionProfiler> list = new ArrayList<>();\n        list.add(new SimpleExecutionProfiler(10));\n        list.add(new SimpleExecutionProfiler(1));\n        list.add(new SimpleExecutionProfiler(5));\n        final ExecutionProfilerTopN topN = new ExecutionProfilerTopN(list, 2);\n        assertThat(topN.getTopN().get(0).getTotalExecutionCount()).isEqualTo(10);\n        assertThat(topN.getTopN().get(1).getTotalExecutionCount()).isEqualTo(5);\n        assertThat(topN.getTopN().size()).isEqualTo(2);\n    }\n    class SimpleExecutionProfiler implements ExecutionProfiler {\n        int id;\n        public SimpleExecutionProfiler(final int id) {\n            this.id = id;\n        }\n        @Override\n        public String getExecutionString() {\n            return String.valueOf(id);\n        }\n        @Override\n        public long getTotalExecutionTime() {\n            return id;\n        }\n        @Override\n        public long getTotalExecutionCount() {\n            return id;\n        }\n    }\n"]]}
{"hexsha": "675424e98a94049e43ed956c9af8c05a476937dd", "ext": "java", "lang": "Java", "content": "@WebServlet(name = \"Histogram\", value = \"/histogram\")\npublic class Histogram extends HttpServlet {\n  @Override\n  public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    // Get this user's session.\n    HttpSession session = request.getSession();\n\n    // Will hold the size bounds for the histogram.\n    long lowerBound;\n    long upperBound;\n\n    // Check whether the reset button was clicked or not.\n    String resetButton = request.getParameter(\"reset-bounds-btn\");\n    if (resetButton != null) {\n      // Reset was clicked, so set the bounds to be the extrema of the sizes, so the user can see\n      // the entire range of sizes.\n      lowerBound = (long) session.getAttribute(\"minBound\");\n      upperBound = (long) session.getAttribute(\"maxBound\");\n\n      // Reset the field that searches for a specific string in a pathname.\n      session.setAttribute(\"name\", \"\");\n    } else {\n      // Get user-chosen numbers from form in interactive-histogram.html.\n      String lower = request.getParameter(\"lower-bound\");\n      String upper = request.getParameter(\"upper-bound\");\n\n      // Parse the bound from user input and set the bounds to the chosen bounds.\n      lowerBound = parseBound(lower);\n      upperBound = parseBound(upper);\n\n      // Check the name field to see if a specific string in a pathname was searched for, and if so\n      // add it to the session.\n      String name = request.getParameter(\"path-filter\");\n      if (name != null) {\n        session.setAttribute(\"name\", name);\n      }\n    }\n\n    // Set the session's histogram bounds to the new bounds.\n    session.setAttribute(\"lowerBound\", lowerBound);\n    session.setAttribute(\"upperBound\", upperBound);\n\n    // Set the postFired option to be true since the user has done at least one post.\n    session.setAttribute(\"postFired\", true);\n\n    // Reload the interactive-histogram.html.\n    response.sendRedirect(\"/interactive-histogram.html\");\n  }\n\n  @Override\n  public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    // Response will be a Json.\n    response.setContentType(\"application/json\");\n\n    // Get this user's session.\n    HttpSession session = request.getSession();\n\n    // Check whether doPost has been fired for the first time yet.\n    boolean postFired = (boolean) session.getAttribute(\"postFired\");\n\n    // Will hold the size bounds for the histogram.\n    long lowerBound;\n    long upperBound;\n\n    // Will hold the pathname from path filter.\n    String name;\n\n    // If the user hasn't entered custom bounds yet, use the initial min and max from regions list,\n    // otherwise use the ones that were submitted previously and set to the session. If the user\n    // hasn't chosen a specific name in the pathname to filter, just make it an empty string,\n    // otherwise get it from the session.\n    if (!postFired) {\n      lowerBound = (long) session.getAttribute(\"minBound\");\n      upperBound = (long) session.getAttribute(\"maxBound\");\n      name = \"\";\n\n      // Set the new variables to the session.\n      session.setAttribute(\"lowerBound\", lowerBound);\n      session.setAttribute(\"upperBound\", upperBound);\n      session.setAttribute(\"name\", \"\");\n    } else {\n      lowerBound = (long) session.getAttribute(\"lowerBound\");\n      upperBound = (long) session.getAttribute(\"upperBound\");\n      name = (String) session.getAttribute(\"name\");\n    }\n\n    // Get the region list from the session, which was set when the file was uploaded.\n    List<Region> regionList = (List<Region>) session.getAttribute(\"regionList\");\n\n    // Parse histogram data.\n    List<Object[]> histogramData = makeDataArray(regionList, name);\n\n    // Construct 2D array to hold the bounds.\n    long[] bounds = {lowerBound, upperBound};\n\n    // Transfer the arrays into JavaScript Objects (Json).\n    Gson boundsGson = new Gson();\n    Gson nameGson = new Gson();\n    Gson histGson = new Gson();\n    String boundsJson = boundsGson.toJson(bounds);\n    String nameJson = nameGson.toJson(name);\n    String histogramDataJson = histGson.toJson(histogramData);\n\n    // Put the two Json strings into a list to send to histogram.js.\n    List<String> jsonList = new ArrayList<String>();\n    jsonList.add(boundsJson);\n    jsonList.add(nameJson);\n    jsonList.add(histogramDataJson);\n\n    // Write Json to histogram.js\n    response.getWriter().println(jsonList);\n  }\n\n  /**\n   * Returns the input from the forms in interactive-histogram.html parsed as a long. The bound\n   * input forms in interactive-histogram.html only allow positive integers, but accept numbers with\n   * .0, so in that case drop the decimal when parsing.\n   */\n  public long parseBound(String bound) {\n    if (bound.contains(\".\")) {\n      return (long) Double.parseDouble(bound);\n    }\n    return Long.parseLong(bound);\n  }\n\n  /** Creates list of 2D Object arrays of data for histogram. */\n  static ArrayList<Object[]> makeDataArray(List<Region> regions, String name) {\n    // List must contain both Strings and numbers, so must be of type Object.\n    ArrayList<Object[]> dataArray = new ArrayList<Object[]>();\n\n    // First pair in list must define the format of the data.\n    Object[] labelPair = {\"Range\", \"Size\"};\n    dataArray.add(labelPair);\n\n    // Add an array to init the data, but make range null and the size -1 so that it won't show up\n    // in the actual chart.\n    Object[] initPair = {null, -1};\n    dataArray.add(initPair);\n\n    // Go through the regions and add range/size pairs to the list, and check that it contains in\n    // its pathname the specific name that was searched for (if no name was searched, it will just\n    // be an empty string).\n    for (int i = 0; i < regions.size(); i++) {\n      Region curR = regions.get(i);\n      if (curR.pathname().contains(name)) {\n        String range = curR.startLoc() + \" - \" + curR.endLoc();\n        Object val = (Object) curR.size();\n        Object[] pair = {range, val};\n        dataArray.add(pair);\n      }\n    }\n    return dataArray;\n  }\n}", "class_id": 0, "repo": "googleinterns/smaps-visualizer", "file": "smaps/src/main/java/com/google/smaps/Histogram.java", "last_update_at": "2020-08-13T20:00:30+00:00", "question_id": "675424e98a94049e43ed956c9af8c05a476937dd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@WebServlet(name = \"Histogram\", value = \"/histogram\")\npublic class Histogram extends HttpServlet {\n  @Override\n  public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    // Get this user's session.\n    HttpSession session = request.getSession();\n    // Will hold the size bounds for the histogram.\n    long lowerBound;\n    long upperBound;\n    // Check whether the reset button was clicked or not.\n    String resetButton = request.getParameter(\"reset-bounds-btn\");\n    if (resetButton != null) {\n      // Reset was clicked, so set the bounds to be the extrema of the sizes, so the user can see\n      // the entire range of sizes.\n      lowerBound = (long) session.getAttribute(\"minBound\");\n      upperBound = (long) session.getAttribute(\"maxBound\");\n      // Reset the field that searches for a specific string in a pathname.\n      session.setAttribute(\"name\", \"\");\n    } else {\n      // Get user-chosen numbers from form in interactive-histogram.html.\n      String lower = request.getParameter(\"lower-bound\");\n      String upper = request.getParameter(\"upper-bound\");\n      // Parse the bound from user input and set the bounds to the chosen bounds.\n      lowerBound = parseBound(lower);\n      upperBound = parseBound(upper);\n      // Check the name field to see if a specific string in a pathname was searched for, and if so\n      // add it to the session.\n      String name = request.getParameter(\"path-filter\");\n      if (name != null) {\n        session.setAttribute(\"name\", name);\n      }\n    }\n    // Set the session's histogram bounds to the new bounds.\n    session.setAttribute(\"lowerBound\", lowerBound);\n    session.setAttribute(\"upperBound\", upperBound);\n    // Set the postFired option to be true since the user has done at least one post.\n    session.setAttribute(\"postFired\", true);\n    // Reload the interactive-histogram.html.\n    response.sendRedirect(\"/interactive-histogram.html\");\n  }\n  @Override\n  public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    // Response will be a Json.\n    response.setContentType(\"application/json\");\n    // Get this user's session.\n    HttpSession session = request.getSession();\n    // Check whether doPost has been fired for the first time yet.\n    boolean postFired = (boolean) session.getAttribute(\"postFired\");\n    // Will hold the size bounds for the histogram.\n    long lowerBound;\n    long upperBound;\n    // Will hold the pathname from path filter.\n    String name;\n    // If the user hasn't entered custom bounds yet, use the initial min and max from regions list,\n    // otherwise use the ones that were submitted previously and set to the session. If the user\n    // hasn't chosen a specific name in the pathname to filter, just make it an empty string,\n    // otherwise get it from the session.\n    if (!postFired) {\n      lowerBound = (long) session.getAttribute(\"minBound\");\n      upperBound = (long) session.getAttribute(\"maxBound\");\n      name = \"\";\n      // Set the new variables to the session.\n      session.setAttribute(\"lowerBound\", lowerBound);\n      session.setAttribute(\"upperBound\", upperBound);\n      session.setAttribute(\"name\", \"\");\n    } else {\n      lowerBound = (long) session.getAttribute(\"lowerBound\");\n      upperBound = (long) session.getAttribute(\"upperBound\");\n      name = (String) session.getAttribute(\"name\");\n    }\n    // Get the region list from the session, which was set when the file was uploaded.\n    List<Region> regionList = (List<Region>) session.getAttribute(\"regionList\");\n    // Parse histogram data.\n    List<Object[]> histogramData = makeDataArray(regionList, name);\n    // Construct 2D array to hold the bounds.\n    long[] bounds = {lowerBound, upperBound};\n    // Transfer the arrays into JavaScript Objects (Json).\n    Gson boundsGson = new Gson();\n    Gson nameGson = new Gson();\n    Gson histGson = new Gson();\n    String boundsJson = boundsGson.toJson(bounds);\n    String nameJson = nameGson.toJson(name);\n    String histogramDataJson = histGson.toJson(histogramData);\n    // Put the two Json strings into a list to send to histogram.js.\n    List<String> jsonList = new ArrayList<String>();\n    jsonList.add(boundsJson);\n    jsonList.add(nameJson);\n    jsonList.add(histogramDataJson);\n    // Write Json to histogram.js\n    response.getWriter().println(jsonList);\n  }\n  /**\n   * Returns the input from the forms in interactive-histogram.html parsed as a long. The bound\n   * input forms in interactive-histogram.html only allow positive integers, but accept numbers with\n   * .0, so in that case drop the decimal when parsing.\n   */\n  public long parseBound(String bound) {\n    if (bound.contains(\".\")) {\n      return (long) Double.parseDouble(bound);\n    }\n    return Long.parseLong(bound);\n  }\n  /** Creates list of 2D Object arrays of data for histogram. */\n  static ArrayList<Object[]> makeDataArray(List<Region> regions, String name) {\n    // List must contain both Strings and numbers, so must be of type Object.\n    ArrayList<Object[]> dataArray = new ArrayList<Object[]>();\n    // First pair in list must define the format of the data.\n    Object[] labelPair = {\"Range\", \"Size\"};\n    dataArray.add(labelPair);\n    // Add an array to init the data, but make range null and the size -1 so that it won't show up\n    // in the actual chart.\n    Object[] initPair = {null, -1};\n    dataArray.add(initPair);\n    // Go through the regions and add range/size pairs to the list, and check that it contains in\n    // its pathname the specific name that was searched for (if no name was searched, it will just\n    // be an empty string).\n    for (int i = 0; i < regions.size(); i++) {\n      Region curR = regions.get(i);\n      if (curR.pathname().contains(name)) {\n        String range = curR.startLoc() + \" - \" + curR.endLoc();\n        Object val = (Object) curR.size();\n        Object[] pair = {range, val};\n        dataArray.add(pair);\n      }\n    }\n    return dataArray;\n  }\n"]]}
{"hexsha": "22048f07e862ab21701c1f56ab4f445e44fe7997", "ext": "java", "lang": "Java", "content": "public class RichLocalNotificationDismissReceiver extends BroadcastReceiver {\n\n  private RichLocalNotificationManager richLocalNotificationManager;\n\n  @Override\n  public void onReceive(Context context, Intent intent) {\n    Log.i(\"RLN\", \"Dimissing local notification\");\n    JSObject dataJson = getRichLocalNotificationManagerInstance(context).handleNotificationActionPerformed(intent);\n    RichLocalNotifications.sendNotificationActionPerformed(dataJson);\n  }\n\n  private RichLocalNotificationManager getRichLocalNotificationManagerInstance(Context context) {\n    if (richLocalNotificationManager == null) {\n      this.richLocalNotificationManager = new RichLocalNotificationManager(context);\n    }\n    return this.richLocalNotificationManager;\n  }\n\n}", "class_id": 0, "repo": "okode/capacitor-rich-local-notifications", "file": "android/src/main/java/com/okode/richlocalnotifications/RichLocalNotificationDismissReceiver.java", "last_update_at": "2020-05-05T19:32:20+00:00", "question_id": "22048f07e862ab21701c1f56ab4f445e44fe7997", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RichLocalNotificationDismissReceiver extends BroadcastReceiver {\n  private RichLocalNotificationManager richLocalNotificationManager;\n  @Override\n  public void onReceive(Context context, Intent intent) {\n    Log.i(\"RLN\", \"Dimissing local notification\");\n    JSObject dataJson = getRichLocalNotificationManagerInstance(context).handleNotificationActionPerformed(intent);\n    RichLocalNotifications.sendNotificationActionPerformed(dataJson);\n  }\n  private RichLocalNotificationManager getRichLocalNotificationManagerInstance(Context context) {\n    if (richLocalNotificationManager == null) {\n      this.richLocalNotificationManager = new RichLocalNotificationManager(context);\n    }\n    return this.richLocalNotificationManager;\n  }\n"]]}
{"hexsha": "a7bc87a9e2f6e4f2190eea13f6b0e2bd3901515a", "ext": "java", "lang": "Java", "content": "public class ClassTranslatorFactory<P> implements TranslatorFactory<P, PropertyContainer>\n{\n\t/** Cache of existing translators, see the class javadoc */\n\tprivate Map<Class<P>, ClassTranslator<P>> translators = new HashMap<>();\n\n\t@Override\n\tpublic ClassTranslator<P> create(TypeKey<P> tk, CreateContext ctx, Path path) {\n\t\tClass<P> clazz = tk.getTypeAsClass();\n\n\t\tClassTranslator<P> classTranslator = translators.get(clazz);\n\t\tif (classTranslator == null) {\n\t\t\t// Entity is an inherited annotation; this checks up the hierarchy\n\t\t\tclassTranslator = (clazz.isAnnotationPresent(Entity.class))\n\t\t\t\t\t? createEntityClassTranslator(clazz, ctx, path)\n\t\t\t\t\t: createEmbeddedClassTranslator(clazz, ctx, path);\n\n\t\t\ttranslators.put(clazz, classTranslator);\n\n\t\t\tif (clazz.isAnnotationPresent(Subclass.class))\n\t\t\t\tregisterSubclass(classTranslator, new TypeKey<>(clazz.getSuperclass(), tk), ctx, path);\n\t\t}\n\n\t\treturn classTranslator;\n\t}\n\n\t/**\n\t */\n\tpublic static <P> ClassTranslator<P> createEntityClassTranslator(Class<P> clazz, CreateContext ctx, Path path) {\n\t\tKeyMetadata<P> keyMetadata = new KeyMetadata<>(clazz, ctx, path);\n\t\tCreator<P> creator = new EntityCreator<>(clazz, ctx.getFactory(), keyMetadata);\n\t\tPopulator<P> populator = new ClassPopulator<>(clazz, ctx, path);\n\n\t\treturn new ClassTranslator<>(clazz, path, creator, populator);\n\t}\n\n\t/**\n\t */\n\tpublic static <P> ClassTranslator<P> createEmbeddedClassTranslator(Class<P> clazz, CreateContext ctx, Path path) {\n\t\tCreator<P> creator = new EmbeddedCreator<>(clazz, ctx.getFactory());\n\t\tPopulator<P> populator = new ClassPopulator<>(clazz, ctx, path);\n\n\t\treturn new ClassTranslator<>(clazz, path, creator, populator);\n\t}\n\n\t/**\n\t * Recursively register this subclass with all the superclass translators. This works because we cache\n\t * translators uniquely in the factory.\n\t */\n\tprivate void registerSubclass(ClassTranslator<P> translator, TypeKey<? super P> superclassTypeKey, CreateContext ctx, Path path) {\n\t\tif (superclassTypeKey.getTypeAsClass() == Object.class)\n\t\t\treturn;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tClassTranslator<? super P> superTranslator = create((TypeKey)superclassTypeKey, ctx, path);\n\t\tsuperTranslator.registerSubclass(translator);\n\n\t\tregisterSubclass(translator, new TypeKey<>(superclassTypeKey.getTypeAsClass().getSuperclass()), ctx, path);\n\t}\n}", "class_id": 0, "repo": "step76/objectify", "file": "src/main/java/com/googlecode/objectify/impl/translate/ClassTranslatorFactory.java", "last_update_at": "2020-09-24T15:12:32+00:00", "question_id": "a7bc87a9e2f6e4f2190eea13f6b0e2bd3901515a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ClassTranslatorFactory<P> implements TranslatorFactory<P, PropertyContainer>\n{\n\t/** Cache of existing translators, see the class javadoc */\n\tprivate Map<Class<P>, ClassTranslator<P>> translators = new HashMap<>();\n\t@Override\n\tpublic ClassTranslator<P> create(TypeKey<P> tk, CreateContext ctx, Path path) {\n\t\tClass<P> clazz = tk.getTypeAsClass();\n\t\tClassTranslator<P> classTranslator = translators.get(clazz);\n\t\tif (classTranslator == null) {\n\t\t\t// Entity is an inherited annotation; this checks up the hierarchy\n\t\t\tclassTranslator = (clazz.isAnnotationPresent(Entity.class))\n\t\t\t\t\t? createEntityClassTranslator(clazz, ctx, path)\n\t\t\t\t\t: createEmbeddedClassTranslator(clazz, ctx, path);\n\t\t\ttranslators.put(clazz, classTranslator);\n\t\t\tif (clazz.isAnnotationPresent(Subclass.class))\n\t\t\t\tregisterSubclass(classTranslator, new TypeKey<>(clazz.getSuperclass(), tk), ctx, path);\n\t\t}\n\t\treturn classTranslator;\n\t}\n\t/**\n\t */\n\tpublic static <P> ClassTranslator<P> createEntityClassTranslator(Class<P> clazz, CreateContext ctx, Path path) {\n\t\tKeyMetadata<P> keyMetadata = new KeyMetadata<>(clazz, ctx, path);\n\t\tCreator<P> creator = new EntityCreator<>(clazz, ctx.getFactory(), keyMetadata);\n\t\tPopulator<P> populator = new ClassPopulator<>(clazz, ctx, path);\n\t\treturn new ClassTranslator<>(clazz, path, creator, populator);\n\t}\n\t/**\n\t */\n\tpublic static <P> ClassTranslator<P> createEmbeddedClassTranslator(Class<P> clazz, CreateContext ctx, Path path) {\n\t\tCreator<P> creator = new EmbeddedCreator<>(clazz, ctx.getFactory());\n\t\tPopulator<P> populator = new ClassPopulator<>(clazz, ctx, path);\n\t\treturn new ClassTranslator<>(clazz, path, creator, populator);\n\t}\n\t/**\n\t * Recursively register this subclass with all the superclass translators. This works because we cache\n\t * translators uniquely in the factory.\n\t */\n\tprivate void registerSubclass(ClassTranslator<P> translator, TypeKey<? super P> superclassTypeKey, CreateContext ctx, Path path) {\n\t\tif (superclassTypeKey.getTypeAsClass() == Object.class)\n\t\t\treturn;\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tClassTranslator<? super P> superTranslator = create((TypeKey)superclassTypeKey, ctx, path);\n\t\tsuperTranslator.registerSubclass(translator);\n\t\tregisterSubclass(translator, new TypeKey<>(superclassTypeKey.getTypeAsClass().getSuperclass()), ctx, path);\n\t}\n"]]}
{"hexsha": "ac53ae52e2265abc3785b746e28eda3baf1421cf", "ext": "java", "lang": "Java", "content": "public class TestElementIndex extends InternalSelenseTestBase {\n  @Test\n  public void testElementIndex() throws Exception {\n    selenium.open(\"../tests/html/test_element_order.html\");\n    assertEquals(selenium.getElementIndex(\"d2\"), \"1\");\n    assertEquals(selenium.getElementIndex(\"d1.1.1\"), \"0\");\n    verifyEquals(selenium.getElementIndex(\"d2\"), \"1\");\n    verifyEquals(selenium.getElementIndex(\"d1.2\"), \"5\");\n    assertNotEquals(\"2\", selenium.getElementIndex(\"d2\"));\n    verifyNotEquals(\"2\", selenium.getElementIndex(\"d2\"));\n  }\n}", "class_id": 0, "repo": "vinay-qa/vinayit-android-server-apk", "file": "java/client/test/com/thoughtworks/selenium/corebased/TestElementIndex.java", "last_update_at": "2020-03-23T07:47:39+00:00", "question_id": "ac53ae52e2265abc3785b746e28eda3baf1421cf", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestElementIndex extends InternalSelenseTestBase {\n  @Test\n  public void testElementIndex() throws Exception {\n    selenium.open(\"../tests/html/test_element_order.html\");\n    assertEquals(selenium.getElementIndex(\"d2\"), \"1\");\n    assertEquals(selenium.getElementIndex(\"d1.1.1\"), \"0\");\n    verifyEquals(selenium.getElementIndex(\"d2\"), \"1\");\n    verifyEquals(selenium.getElementIndex(\"d1.2\"), \"5\");\n    assertNotEquals(\"2\", selenium.getElementIndex(\"d2\"));\n    verifyNotEquals(\"2\", selenium.getElementIndex(\"d2\"));\n  }\n"]]}
{"hexsha": "03bf50425e2ed4500979a26bb562e68bf9680a1d", "ext": "java", "lang": "Java", "content": "class StatusMap extends LinkedHashMap<Long, Map<String, Object>> \n{\n   private static final long serialVersionUID = 1L;\n   private static final int MAX_JOB_EXECUTION_COUNT = 1000;\n\n   protected boolean removeEldestEntry(Map.Entry<Long, Map<String, Object>> eldest) {\n      Map<String, Object> data = eldest.getValue();\n      boolean unregistered = (Boolean) data\n            .get(InMemoryJobExecutionStatusHolder.JOB_UNREGISTERED);\n      return unregistered && size() > MAX_JOB_EXECUTION_COUNT;\n   }\n}", "class_id": 0, "repo": "isabella232/serengeti-ws", "file": "server/cluster-mgmt/src/main/java/com/vmware/bdd/service/job/InMemoryJobExecutionStatusHolder.java", "last_update_at": "2020-02-19T09:05:00+00:00", "question_id": "03bf50425e2ed4500979a26bb562e68bf9680a1d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class StatusMap extends LinkedHashMap<Long, Map<String, Object>> \n{\n   private static final long serialVersionUID = 1L;\n   private static final int MAX_JOB_EXECUTION_COUNT = 1000;\n   protected boolean removeEldestEntry(Map.Entry<Long, Map<String, Object>> eldest) {\n      Map<String, Object> data = eldest.getValue();\n      boolean unregistered = (Boolean) data\n            .get(InMemoryJobExecutionStatusHolder.JOB_UNREGISTERED);\n      return unregistered && size() > MAX_JOB_EXECUTION_COUNT;\n   }\n"]]}
{"hexsha": "dd75b83ebcb1dd0814cbb8ae8494d06fe1da4394", "ext": "java", "lang": "Java", "content": "@Entity\n@Table(name = \"seed\",schema = \"joko_security\")\npublic class SeedEntity implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n\n    @GenericGenerator(\n            name = \"seed_id_seq\",\n            strategy = \"org.hibernate.id.enhanced.SequenceStyleGenerator\",\n            parameters = {\n                    @org.hibernate.annotations.Parameter(name = \"sequence_name\", value =\n                            \"joko_security.seed_id_seq\"),\n                    @org.hibernate.annotations.Parameter(name = \"increment_size\", value = \"1\")\n            }\n    )\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY, generator = \"seed_id_seq\")\n    @Column(name = \"id\")\n    private Long seedId;\n\n    @Column(name = \"user_id\")\n    private String userId;\n\n    @Column(name = \"seed_secret\")\n    private String seedSecret;\n\n    public Long getSeedId() {\n        return seedId;\n    }\n\n    public void setSeedId(Long seedId) {\n        this.seedId = seedId;\n    }\n\n    public String getUserId() {\n        return userId;\n    }\n\n    public void setUserId(String userId) {\n        this.userId = userId;\n    }\n\n    public String getSeedSecret() {\n        return seedSecret;\n    }\n\n    public void setSeedSecret(String seedSecret) {\n        this.seedSecret = seedSecret;\n    }\n\n    @Override\n    public String toString() {\n        return \"SeedEntity{\" +\n                \"seedId='\" + seedId + '\\'' +\n                \", userId='\" + userId + '\\'' +\n                \", seedSecret='\" + seedSecret + '\\'' +\n                '}';\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n\n        if (o == null || getClass() != o.getClass()) return false;\n\n        SeedEntity that = (SeedEntity) o;\n\n        return new EqualsBuilder()\n                .append(seedId, that.seedId)\n                .append(userId, that.userId)\n                .append(seedSecret, that.seedSecret)\n                .isEquals();\n    }\n\n    @Override\n    public int hashCode() {\n        return new HashCodeBuilder(17, 37)\n                .append(seedId)\n                .append(userId)\n                .append(seedSecret)\n                .toHashCode();\n    }\n}", "class_id": 0, "repo": "jokoframework/security", "file": "src/main/java/io/github/jokoframework/security/entities/SeedEntity.java", "last_update_at": "2020-08-26T21:16:44+00:00", "question_id": "dd75b83ebcb1dd0814cbb8ae8494d06fe1da4394", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Entity\n@Table(name = \"seed\",schema = \"joko_security\")\npublic class SeedEntity implements Serializable {\n    private static final long serialVersionUID = 1L;\n    @GenericGenerator(\n            name = \"seed_id_seq\",\n            strategy = \"org.hibernate.id.enhanced.SequenceStyleGenerator\",\n            parameters = {\n                    @org.hibernate.annotations.Parameter(name = \"sequence_name\", value =\n                            \"joko_security.seed_id_seq\"),\n                    @org.hibernate.annotations.Parameter(name = \"increment_size\", value = \"1\")\n            }\n    )\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY, generator = \"seed_id_seq\")\n    @Column(name = \"id\")\n    private Long seedId;\n    @Column(name = \"user_id\")\n    private String userId;\n    @Column(name = \"seed_secret\")\n    private String seedSecret;\n    public Long getSeedId() {\n        return seedId;\n    }\n    public void setSeedId(Long seedId) {\n        this.seedId = seedId;\n    }\n    public String getUserId() {\n        return userId;\n    }\n    public void setUserId(String userId) {\n        this.userId = userId;\n    }\n    public String getSeedSecret() {\n        return seedSecret;\n    }\n    public void setSeedSecret(String seedSecret) {\n        this.seedSecret = seedSecret;\n    }\n    @Override\n    public String toString() {\n        return \"SeedEntity{\" +\n                \"seedId='\" + seedId + '\\'' +\n                \", userId='\" + userId + '\\'' +\n                \", seedSecret='\" + seedSecret + '\\'' +\n                '}';\n    }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        SeedEntity that = (SeedEntity) o;\n        return new EqualsBuilder()\n                .append(seedId, that.seedId)\n                .append(userId, that.userId)\n                .append(seedSecret, that.seedSecret)\n                .isEquals();\n    }\n    @Override\n    public int hashCode() {\n        return new HashCodeBuilder(17, 37)\n                .append(seedId)\n                .append(userId)\n                .append(seedSecret)\n                .toHashCode();\n    }\n"]]}
{"hexsha": "9a566b4bc8b0067738083e87599123aa9b2cd505", "ext": "java", "lang": "Java", "content": "public class ScreenShotPlayerActivity extends AppCompatActivity {\n\n    private VideoView mVideoView;\n    private ImageView mScreenShot;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_screen_shot_player);\n        ActionBar actionBar = getSupportActionBar();\n        if (actionBar != null) {\n            actionBar.setTitle(R.string.str_screen_shot);\n            actionBar.setDisplayHomeAsUpEnabled(true);\n        }\n        mVideoView = findViewById(R.id.player);\n        mScreenShot = findViewById(R.id.iv_screen_shot);\n        StandardVideoController controller = new StandardVideoController(this);\n        mVideoView.setUrl(\"http://vfx.mtime.cn/Video/2019/03/12/mp4/190312143927981075.mp4\");\n        mVideoView.setVideoController(controller);\n        mVideoView.start();\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        if (item.getItemId() == android.R.id.home) {\n            finish();\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    protected void onPause() {\n        super.onPause();\n        mVideoView.pause();\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        mVideoView.resume();\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        mVideoView.release();\n    }\n\n\n    @Override\n    public void onBackPressed() {\n        if (!mVideoView.onBackPressed()) {\n            super.onBackPressed();\n        }\n    }\n\n    public void doScreenShot(View view) {\n        Bitmap bitmap = mVideoView.doScreenShot();\n        mScreenShot.setImageBitmap(bitmap);\n    }\n}", "class_id": 0, "repo": "dheerajbred/dkplayernew", "file": "app/src/main/java/com/dueeeke/dkplayer/activity/api/ScreenShotPlayerActivity.java", "last_update_at": "2020-07-13T01:42:23+00:00", "question_id": "9a566b4bc8b0067738083e87599123aa9b2cd505", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ScreenShotPlayerActivity extends AppCompatActivity {\n    private VideoView mVideoView;\n    private ImageView mScreenShot;\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_screen_shot_player);\n        ActionBar actionBar = getSupportActionBar();\n        if (actionBar != null) {\n            actionBar.setTitle(R.string.str_screen_shot);\n            actionBar.setDisplayHomeAsUpEnabled(true);\n        }\n        mVideoView = findViewById(R.id.player);\n        mScreenShot = findViewById(R.id.iv_screen_shot);\n        StandardVideoController controller = new StandardVideoController(this);\n        mVideoView.setUrl(\"http://vfx.mtime.cn/Video/2019/03/12/mp4/190312143927981075.mp4\");\n        mVideoView.setVideoController(controller);\n        mVideoView.start();\n    }\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        if (item.getItemId() == android.R.id.home) {\n            finish();\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    @Override\n    protected void onPause() {\n        super.onPause();\n        mVideoView.pause();\n    }\n    @Override\n    protected void onResume() {\n        super.onResume();\n        mVideoView.resume();\n    }\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        mVideoView.release();\n    }\n    @Override\n    public void onBackPressed() {\n        if (!mVideoView.onBackPressed()) {\n            super.onBackPressed();\n        }\n    }\n    public void doScreenShot(View view) {\n        Bitmap bitmap = mVideoView.doScreenShot();\n        mScreenShot.setImageBitmap(bitmap);\n    }\n"]]}
{"hexsha": "ed642a17b04a00c6433c819f41e65b3a5dbb7279", "ext": "java", "lang": "Java", "content": "public class PascalGen extends RandomVariateGenInt {\n   protected int    n;\n   protected double p;\n\n   /**\n    * Creates a Pascal random variate generator with parameters @f$n@f$\n    * and @f$p@f$, using stream `s`.\n    */\n   public PascalGen (RandomStream s, int n, double p) {\n      super (s, new PascalDist (n, p));\n      setParams (n, p);\n   }\n\n   /**\n    * Creates a new generator for the distribution `dist`, using stream\n    * `s`.\n    */\n   public PascalGen (RandomStream s, PascalDist dist) {\n      super (s, dist);\n      if (dist != null)\n         setParams (dist.getN1(), dist.getP());\n   }\n\n   /**\n    * Generates a new variate from the *Pascal* distribution, with\n    * parameters @f$n = @f$&nbsp;`n` and @f$p = @f$&nbsp;`p`, using stream\n    * `s`.\n    */\n   public static int nextInt (RandomStream s, int n, double p) {\n      return PascalDist.inverseF (n, p, s.nextDouble());\n   }\n\n   /**\n    * Returns the parameter @f$n@f$ of this object.\n    */\n   public int getN() {\n      return n;\n   }\n\n   /**\n    * Returns the parameter @f$p@f$ of this object.\n    */\n   public double getP() {\n      return p;\n   }\n\n   /**\n    * Sets the parameter @f$n@f$ and @f$p@f$ of this object.\n    */\n   protected void setParams (int n, double p) {\n      if (p < 0.0 || p > 1.0)\n         throw new IllegalArgumentException (\"p not in [0, 1]\");\n      if (n <= 0)\n         throw new IllegalArgumentException (\"n <= 0\");\n      this.p = p;\n      this.n = n;\n   }\n}", "class_id": 0, "repo": "pierrelecuyer/NouveauSSJ", "file": "src/main/java/umontreal/ssj/randvar/PascalGen.java", "last_update_at": "2020-11-08T02:51:06+00:00", "question_id": "ed642a17b04a00c6433c819f41e65b3a5dbb7279", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PascalGen extends RandomVariateGenInt {\n   protected int    n;\n   protected double p;\n   /**\n    * Creates a Pascal random variate generator with parameters @f$n@f$\n    * and @f$p@f$, using stream `s`.\n    */\n   public PascalGen (RandomStream s, int n, double p) {\n      super (s, new PascalDist (n, p));\n      setParams (n, p);\n   }\n   /**\n    * Creates a new generator for the distribution `dist`, using stream\n    * `s`.\n    */\n   public PascalGen (RandomStream s, PascalDist dist) {\n      super (s, dist);\n      if (dist != null)\n         setParams (dist.getN1(), dist.getP());\n   }\n   /**\n    * Generates a new variate from the *Pascal* distribution, with\n    * parameters @f$n = @f$&nbsp;`n` and @f$p = @f$&nbsp;`p`, using stream\n    * `s`.\n    */\n   public static int nextInt (RandomStream s, int n, double p) {\n      return PascalDist.inverseF (n, p, s.nextDouble());\n   }\n   /**\n    * Returns the parameter @f$n@f$ of this object.\n    */\n   public int getN() {\n      return n;\n   }\n   /**\n    * Returns the parameter @f$p@f$ of this object.\n    */\n   public double getP() {\n      return p;\n   }\n   /**\n    * Sets the parameter @f$n@f$ and @f$p@f$ of this object.\n    */\n   protected void setParams (int n, double p) {\n      if (p < 0.0 || p > 1.0)\n         throw new IllegalArgumentException (\"p not in [0, 1]\");\n      if (n <= 0)\n         throw new IllegalArgumentException (\"n <= 0\");\n      this.p = p;\n      this.n = n;\n   }\n"]]}
{"hexsha": "09536f860f14c901cb00610fa5fadcff2c16f4a9", "ext": "java", "lang": "Java", "content": "public class TestOpenTsdbMetricStreamerConfig {\n\n    @Test\n    public void validateValidConfig() {\n        List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();\n        OpenTsdbMetricStreamerConfig config = new OpenTsdbMetricStreamerConfig(\"host\", 4242,\n                new TimeInterval(10L, TimeUnit.SECONDS), streams);\n        config.validate();\n\n        assertThat(config.getOpenTsdbHost(), is(\"host\"));\n        assertThat(config.getOpenTsdbPort(), is(4242));\n        assertThat(config.getPollInterval(), is(new TimeInterval(10L, TimeUnit.SECONDS)));\n        assertThat(config.getMetricStreams(), is(Collections.emptyList()));\n    }\n\n    /**\n     * openTsdbPort, pollInterval and metricstreams is optional\n     */\n    @Test\n    public void withDefaults() {\n        Integer openTsdbPort = null;\n        List<OpenTsdbMetricStreamDefinition> streams = null;\n        TimeInterval pollInterval = null;\n        OpenTsdbMetricStreamerConfig config = new OpenTsdbMetricStreamerConfig(\"host\", openTsdbPort, pollInterval,\n                streams);\n        config.validate();\n\n        assertThat(config.getOpenTsdbPort(), is(OpenTsdbMetricStreamerConfig.DEFAULT_OPENTSDB_PORT));\n        assertThat(config.getPollInterval(), is(OpenTsdbMetricStreamerConfig.DEFAULT_POLL_INTERVAL));\n        assertThat(config.getMetricStreams(), is(Collections.emptyList()));\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void validateWithMissingHost() {\n        List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();\n        new OpenTsdbMetricStreamerConfig(null, 4242, new TimeInterval(10L, TimeUnit.SECONDS), streams).validate();\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void validateWithNegativePort() {\n        List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();\n        new OpenTsdbMetricStreamerConfig(\"host\", -1, new TimeInterval(10L, TimeUnit.SECONDS), streams).validate();\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void validateWithZeroPort() {\n        List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();\n        new OpenTsdbMetricStreamerConfig(\"host\", 0, new TimeInterval(10L, TimeUnit.SECONDS), streams).validate();\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void validateWithTooHighPort() {\n        List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();\n        new OpenTsdbMetricStreamerConfig(\"host\", 65354, new TimeInterval(10L, TimeUnit.SECONDS), streams).validate();\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void validateWithNegativePollInterval() {\n        List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();\n        TimeInterval illegalPollInterval = JsonUtils\n                .toObject(JsonUtils.parseJsonString(\"{\\\"time\\\": -1, \\\"unit\\\": \\\"seconds\\\"}\"), TimeInterval.class);\n        new OpenTsdbMetricStreamerConfig(\"host\", 4242, illegalPollInterval, streams).validate();\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void validateWithZeroPollInterval() {\n        List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();\n        TimeInterval illegalPollInterval = new TimeInterval(0L, TimeUnit.SECONDS);\n        new OpenTsdbMetricStreamerConfig(\"host\", 4242, illegalPollInterval, streams).validate();\n    }\n\n    @Test\n    public void testEqualsAndHashcode() {\n        List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();\n        OpenTsdbMetricStreamerConfig config = new OpenTsdbMetricStreamerConfig(\"host\", 4242,\n                new TimeInterval(10L, TimeUnit.SECONDS), streams);\n\n        OpenTsdbMetricStreamerConfig equal = new OpenTsdbMetricStreamerConfig(\"host\", 4242,\n                new TimeInterval(10L, TimeUnit.SECONDS), streams);\n        OpenTsdbMetricStreamerConfig differentHost = new OpenTsdbMetricStreamerConfig(\"host2\", 4242,\n                new TimeInterval(10L, TimeUnit.SECONDS), streams);\n        OpenTsdbMetricStreamerConfig differentPort = new OpenTsdbMetricStreamerConfig(\"host\", 2424,\n                new TimeInterval(10L, TimeUnit.SECONDS), streams);\n        OpenTsdbMetricStreamerConfig differentPoll = new OpenTsdbMetricStreamerConfig(\"host\", 4242,\n                new TimeInterval(11L, TimeUnit.SECONDS), streams);\n        OpenTsdbMetricStreamerConfig differentStreams = config.withMetricStream(new OpenTsdbMetricStreamDefinition(\"id\",\n                \"metric\", MetricAggregator.MAX, false, null, null, null, null));\n\n        assertTrue(config.equals(equal));\n        assertFalse(config.equals(differentHost));\n        assertFalse(config.equals(differentPort));\n        assertFalse(config.equals(differentPoll));\n        assertFalse(config.equals(differentStreams));\n\n        assertTrue(config.hashCode() == equal.hashCode());\n        assertFalse(config.hashCode() == differentHost.hashCode());\n        assertFalse(config.hashCode() == differentPort.hashCode());\n        assertFalse(config.hashCode() == differentPoll.hashCode());\n        assertFalse(config.hashCode() == differentStreams.hashCode());\n    }\n\n    /**\n     * Tests the\n     * {@link OpenTsdbMetricStreamerConfig#withMetricStream(OpenTsdbMetricStreamDefinition)}\n     * copy method.\n     */\n    @Test\n    public void testWithMetricStreamDefinition() {\n        OpenTsdbMetricStreamerConfig original = config();\n        assertThat(original, is(config()));\n\n        // use withStreamDefinition copy method to create a config with an add\n        // stream definition\n        OpenTsdbMetricStreamDefinition stream1 = new OpenTsdbMetricStreamDefinition(\"id1\", \"metric\",\n                MetricAggregator.SUM, true, null, null, new TimeInterval(10L, TimeUnit.SECONDS), null);\n        OpenTsdbMetricStreamerConfig extendedCopy = original.withMetricStream(stream1);\n        // extended copy is original + the new stream definition\n        assertThat(extendedCopy, is(config(stream1)));\n        // original should remain unchanged\n        assertThat(original, is(config()));\n\n        // test chaining calls\n        OpenTsdbMetricStreamDefinition stream2 = new OpenTsdbMetricStreamDefinition(\"id2\", \"metric2\",\n                MetricAggregator.SUM, true, null, null, new TimeInterval(20L, TimeUnit.SECONDS), null);\n        extendedCopy = original.withMetricStream(stream1).withMetricStream(stream2);\n        assertThat(extendedCopy, is(config(stream1, stream2)));\n    }\n\n    private OpenTsdbMetricStreamerConfig config(OpenTsdbMetricStreamDefinition... streams) {\n        List<OpenTsdbMetricStreamDefinition> streamDefList = Arrays.asList(streams);\n        return new OpenTsdbMetricStreamerConfig(\"host\", 4242, new TimeInterval(10L, TimeUnit.SECONDS), streamDefList);\n    }\n\n}", "class_id": 0, "repo": "elastisys/autoscaler", "file": "metricstreamers/opentsdb/src/test/java/com/elastisys/autoscaler/metricstreamers/opentsdb/config/TestOpenTsdbMetricStreamerConfig.java", "last_update_at": "2020-04-16T07:45:25+00:00", "question_id": "09536f860f14c901cb00610fa5fadcff2c16f4a9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestOpenTsdbMetricStreamerConfig {\n    @Test\n    public void validateValidConfig() {\n        List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();\n        OpenTsdbMetricStreamerConfig config = new OpenTsdbMetricStreamerConfig(\"host\", 4242,\n                new TimeInterval(10L, TimeUnit.SECONDS), streams);\n        config.validate();\n        assertThat(config.getOpenTsdbHost(), is(\"host\"));\n        assertThat(config.getOpenTsdbPort(), is(4242));\n        assertThat(config.getPollInterval(), is(new TimeInterval(10L, TimeUnit.SECONDS)));\n        assertThat(config.getMetricStreams(), is(Collections.emptyList()));\n    }\n    /**\n     * openTsdbPort, pollInterval and metricstreams is optional\n     */\n    @Test\n    public void withDefaults() {\n        Integer openTsdbPort = null;\n        List<OpenTsdbMetricStreamDefinition> streams = null;\n        TimeInterval pollInterval = null;\n        OpenTsdbMetricStreamerConfig config = new OpenTsdbMetricStreamerConfig(\"host\", openTsdbPort, pollInterval,\n                streams);\n        config.validate();\n        assertThat(config.getOpenTsdbPort(), is(OpenTsdbMetricStreamerConfig.DEFAULT_OPENTSDB_PORT));\n        assertThat(config.getPollInterval(), is(OpenTsdbMetricStreamerConfig.DEFAULT_POLL_INTERVAL));\n        assertThat(config.getMetricStreams(), is(Collections.emptyList()));\n    }\n    @Test(expected = IllegalArgumentException.class)\n    public void validateWithMissingHost() {\n        List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();\n        new OpenTsdbMetricStreamerConfig(null, 4242, new TimeInterval(10L, TimeUnit.SECONDS), streams).validate();\n    }\n    @Test(expected = IllegalArgumentException.class)\n    public void validateWithNegativePort() {\n        List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();\n        new OpenTsdbMetricStreamerConfig(\"host\", -1, new TimeInterval(10L, TimeUnit.SECONDS), streams).validate();\n    }\n    @Test(expected = IllegalArgumentException.class)\n    public void validateWithZeroPort() {\n        List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();\n        new OpenTsdbMetricStreamerConfig(\"host\", 0, new TimeInterval(10L, TimeUnit.SECONDS), streams).validate();\n    }\n    @Test(expected = IllegalArgumentException.class)\n    public void validateWithTooHighPort() {\n        List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();\n        new OpenTsdbMetricStreamerConfig(\"host\", 65354, new TimeInterval(10L, TimeUnit.SECONDS), streams).validate();\n    }\n    @Test(expected = IllegalArgumentException.class)\n    public void validateWithNegativePollInterval() {\n        List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();\n        TimeInterval illegalPollInterval = JsonUtils\n                .toObject(JsonUtils.parseJsonString(\"{\\\"time\\\": -1, \\\"unit\\\": \\\"seconds\\\"}\"), TimeInterval.class);\n        new OpenTsdbMetricStreamerConfig(\"host\", 4242, illegalPollInterval, streams).validate();\n    }\n    @Test(expected = IllegalArgumentException.class)\n    public void validateWithZeroPollInterval() {\n        List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();\n        TimeInterval illegalPollInterval = new TimeInterval(0L, TimeUnit.SECONDS);\n        new OpenTsdbMetricStreamerConfig(\"host\", 4242, illegalPollInterval, streams).validate();\n    }\n    @Test\n    public void testEqualsAndHashcode() {\n        List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();\n        OpenTsdbMetricStreamerConfig config = new OpenTsdbMetricStreamerConfig(\"host\", 4242,\n                new TimeInterval(10L, TimeUnit.SECONDS), streams);\n        OpenTsdbMetricStreamerConfig equal = new OpenTsdbMetricStreamerConfig(\"host\", 4242,\n                new TimeInterval(10L, TimeUnit.SECONDS), streams);\n        OpenTsdbMetricStreamerConfig differentHost = new OpenTsdbMetricStreamerConfig(\"host2\", 4242,\n                new TimeInterval(10L, TimeUnit.SECONDS), streams);\n        OpenTsdbMetricStreamerConfig differentPort = new OpenTsdbMetricStreamerConfig(\"host\", 2424,\n                new TimeInterval(10L, TimeUnit.SECONDS), streams);\n        OpenTsdbMetricStreamerConfig differentPoll = new OpenTsdbMetricStreamerConfig(\"host\", 4242,\n                new TimeInterval(11L, TimeUnit.SECONDS), streams);\n        OpenTsdbMetricStreamerConfig differentStreams = config.withMetricStream(new OpenTsdbMetricStreamDefinition(\"id\",\n                \"metric\", MetricAggregator.MAX, false, null, null, null, null));\n        assertTrue(config.equals(equal));\n        assertFalse(config.equals(differentHost));\n        assertFalse(config.equals(differentPort));\n        assertFalse(config.equals(differentPoll));\n        assertFalse(config.equals(differentStreams));\n        assertTrue(config.hashCode() == equal.hashCode());\n        assertFalse(config.hashCode() == differentHost.hashCode());\n        assertFalse(config.hashCode() == differentPort.hashCode());\n        assertFalse(config.hashCode() == differentPoll.hashCode());\n        assertFalse(config.hashCode() == differentStreams.hashCode());\n    }\n    /**\n     * Tests the\n     * {@link OpenTsdbMetricStreamerConfig#withMetricStream(OpenTsdbMetricStreamDefinition)}\n     * copy method.\n     */\n    @Test\n    public void testWithMetricStreamDefinition() {\n        OpenTsdbMetricStreamerConfig original = config();\n        assertThat(original, is(config()));\n        // use withStreamDefinition copy method to create a config with an add\n        // stream definition\n        OpenTsdbMetricStreamDefinition stream1 = new OpenTsdbMetricStreamDefinition(\"id1\", \"metric\",\n                MetricAggregator.SUM, true, null, null, new TimeInterval(10L, TimeUnit.SECONDS), null);\n        OpenTsdbMetricStreamerConfig extendedCopy = original.withMetricStream(stream1);\n        // extended copy is original + the new stream definition\n        assertThat(extendedCopy, is(config(stream1)));\n        // original should remain unchanged\n        assertThat(original, is(config()));\n        // test chaining calls\n        OpenTsdbMetricStreamDefinition stream2 = new OpenTsdbMetricStreamDefinition(\"id2\", \"metric2\",\n                MetricAggregator.SUM, true, null, null, new TimeInterval(20L, TimeUnit.SECONDS), null);\n        extendedCopy = original.withMetricStream(stream1).withMetricStream(stream2);\n        assertThat(extendedCopy, is(config(stream1, stream2)));\n    }\n    private OpenTsdbMetricStreamerConfig config(OpenTsdbMetricStreamDefinition... streams) {\n        List<OpenTsdbMetricStreamDefinition> streamDefList = Arrays.asList(streams);\n        return new OpenTsdbMetricStreamerConfig(\"host\", 4242, new TimeInterval(10L, TimeUnit.SECONDS), streamDefList);\n    }\n"]]}
{"hexsha": "17c6edbbc6087fc6a2ae572bf420ad84c0f27658", "ext": "java", "lang": "Java", "content": "public class DefaultCredentialsProvider implements AlibabaCloudCredentialsProvider {\n    private List<AlibabaCloudCredentialsProvider> defaultProviders = new ArrayList<AlibabaCloudCredentialsProvider>();\n    private static final List<AlibabaCloudCredentialsProvider> USER_CONFIGURATION_PROVIDERS =\n            new Vector<AlibabaCloudCredentialsProvider>();\n\n    public DefaultCredentialsProvider() {\n        defaultProviders.add(new SystemPropertiesCredentialsProvider());\n        defaultProviders.add(new EnvironmentVariableCredentialsProvider());\n        defaultProviders.add(new ProfileCredentialsProvider());\n        String roleName = AuthUtils.getEnvironmentECSMetaData();\n        if (roleName != null) {\n            defaultProviders.add(new EcsRamRoleCredentialProvider(roleName));\n        }\n    }\n\n    @Override\n    public AlibabaCloudCredentials getCredentials() {\n        AlibabaCloudCredentials credential;\n        if (USER_CONFIGURATION_PROVIDERS.size() > 0) {\n            for (AlibabaCloudCredentialsProvider provider : USER_CONFIGURATION_PROVIDERS) {\n                credential = provider.getCredentials();\n                if (null != credential) {\n                    return credential;\n                }\n            }\n        }\n        for (AlibabaCloudCredentialsProvider provider : defaultProviders) {\n            credential = provider.getCredentials();\n            if (null != credential) {\n                return credential;\n            }\n        }\n        throw new CredentialException(\"not found credentials\");\n    }\n\n    public static boolean addCredentialsProvider(AlibabaCloudCredentialsProvider provider) {\n        return DefaultCredentialsProvider.USER_CONFIGURATION_PROVIDERS.add(provider);\n    }\n\n    public static boolean removeCredentialsProvider(AlibabaCloudCredentialsProvider provider) {\n        return DefaultCredentialsProvider.USER_CONFIGURATION_PROVIDERS.remove(provider);\n    }\n\n    public static boolean containsCredentialsProvider(AlibabaCloudCredentialsProvider provider) {\n        return DefaultCredentialsProvider.USER_CONFIGURATION_PROVIDERS.contains(provider);\n    }\n\n    public static void clearCredentialsProvider() {\n        DefaultCredentialsProvider.USER_CONFIGURATION_PROVIDERS.clear();\n    }\n}", "class_id": 0, "repo": "yndu13/credentials-java", "file": "src/main/java/com/aliyun/credentials/provider/DefaultCredentialsProvider.java", "last_update_at": "2020-01-18T15:35:41+00:00", "question_id": "17c6edbbc6087fc6a2ae572bf420ad84c0f27658", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DefaultCredentialsProvider implements AlibabaCloudCredentialsProvider {\n    private List<AlibabaCloudCredentialsProvider> defaultProviders = new ArrayList<AlibabaCloudCredentialsProvider>();\n    private static final List<AlibabaCloudCredentialsProvider> USER_CONFIGURATION_PROVIDERS =\n            new Vector<AlibabaCloudCredentialsProvider>();\n    public DefaultCredentialsProvider() {\n        defaultProviders.add(new SystemPropertiesCredentialsProvider());\n        defaultProviders.add(new EnvironmentVariableCredentialsProvider());\n        defaultProviders.add(new ProfileCredentialsProvider());\n        String roleName = AuthUtils.getEnvironmentECSMetaData();\n        if (roleName != null) {\n            defaultProviders.add(new EcsRamRoleCredentialProvider(roleName));\n        }\n    }\n    @Override\n    public AlibabaCloudCredentials getCredentials() {\n        AlibabaCloudCredentials credential;\n        if (USER_CONFIGURATION_PROVIDERS.size() > 0) {\n            for (AlibabaCloudCredentialsProvider provider : USER_CONFIGURATION_PROVIDERS) {\n                credential = provider.getCredentials();\n                if (null != credential) {\n                    return credential;\n                }\n            }\n        }\n        for (AlibabaCloudCredentialsProvider provider : defaultProviders) {\n            credential = provider.getCredentials();\n            if (null != credential) {\n                return credential;\n            }\n        }\n        throw new CredentialException(\"not found credentials\");\n    }\n    public static boolean addCredentialsProvider(AlibabaCloudCredentialsProvider provider) {\n        return DefaultCredentialsProvider.USER_CONFIGURATION_PROVIDERS.add(provider);\n    }\n    public static boolean removeCredentialsProvider(AlibabaCloudCredentialsProvider provider) {\n        return DefaultCredentialsProvider.USER_CONFIGURATION_PROVIDERS.remove(provider);\n    }\n    public static boolean containsCredentialsProvider(AlibabaCloudCredentialsProvider provider) {\n        return DefaultCredentialsProvider.USER_CONFIGURATION_PROVIDERS.contains(provider);\n    }\n    public static void clearCredentialsProvider() {\n        DefaultCredentialsProvider.USER_CONFIGURATION_PROVIDERS.clear();\n    }\n"]]}
{"hexsha": "631198c554366e4c829dbfbb04518fac1765181d", "ext": "java", "lang": "Java", "content": "class ViewUtils {\n\n\t  public static int getWidth(View v) { \n\t\t  return v.getLayoutParams().width; \n\t  }\n\t  \n\t  public static int getHeight(View v) {\n\t    return v.getLayoutParams().height;\n\t  }\n\t  \n\t  public static int getLeft(View v){\n\t\t  RateDialogLayout.LayoutParams lp = (RateDialogLayout.LayoutParams)v.getLayoutParams();\n\t    return lp.left;\n\t  }\n\t  \n\t  public static int getTop(View v){\n\t\tRateDialogLayout.LayoutParams lp = (RateDialogLayout.LayoutParams)v.getLayoutParams();\n\t    return lp.top;\n\t  }\n\n\t  public static void setWidth(View v,int width){\n\t\t    ViewGroup.LayoutParams lp = v.getLayoutParams();\n\t\t    lp.width = width;\n\t\t    requestLayout(v);\n\t   }\n\t  \n\t  public static void setHeight(View v,int height) {\n\t    ViewGroup.LayoutParams lp = v.getLayoutParams();\n\t    lp.height = height;\n\t    requestLayout(v);\n\t  }\n\t  \n\t  public static void setLeft(View v,int left) {\n\t\t  RateDialogLayout.LayoutParams lp = (RateDialogLayout.LayoutParams)v.getLayoutParams();\n\t    lp.left = left;\n\t    requestLayout(v);\n\t  }\n\t  \n\t  public static void setTop(View v,int top) {\n\t    RateDialogLayout.LayoutParams lp = (RateDialogLayout.LayoutParams)v.getLayoutParams();\n\t    lp.top = top;\n\t    requestLayout(v);\n\t  }\n\t  \n\t  private static void requestLayout(View v) { \n\t\t  ViewParent parent = v.getParent();\n\t    if (parent != null) {\n\t      parent.requestLayout();\n\t    }\n\t  }\n\t  \n\t  public static int getTextWidth (TextView v) {\n\t\treturn (int) MeasureStringWidth(new Paint(),v.getText().toString(),v.getTypeface(),v.getTextSize());\n\t  }\n\t  \n\t  private static float MeasureStringWidth(Paint paint,String Text, Typeface Typeface, float TextSize)\n\t  {\n\t    paint.setTextSize(TextSize);\n\t    paint.setTypeface(Typeface);\n\t    paint.setStrokeWidth(0.0F);\n\t    paint.setStyle(Paint.Style.STROKE);\n\t    paint.setTextAlign(Paint.Align.LEFT);\n\t    return paint.measureText(Text);\n\t  }\n\t  \n\t  public static void setClipToOutline(ViewGroup v) {\n\t\t  if (Build.VERSION.SDK_INT >= 21) {\n\t\t\tv.setClipToOutline(true);\n\t\t  }\n\t  }\n\n\t  public static void setClickEffect(View View, boolean Borderless) {\n\t    int[] attrs;\t    \n\t    if (Borderless) {\n\t      attrs = new int[] { android.R.attr.selectableItemBackgroundBorderless };\n\t    } else {\n\t      attrs = new int[] { android.R.attr.selectableItemBackground };\n\t    }\n\t    TypedArray typedArray = View.getContext().obtainStyledAttributes(attrs);\n\t    int backgroundResource = typedArray.getResourceId(0, 0);\n\t    View.setBackgroundResource(backgroundResource);\n\t  }\n\t  \t\n\t  public static void RemoveView(View view) {\n\t    if (view.getParent() instanceof ViewGroup) {\n\t      ViewGroup vg = (ViewGroup)view.getParent();\n\t      vg.removeView(view);\n\t    }\n\t  }\n\t  \n\t  public static void setElevation (View v,float e) {\n\t\t  if (Build.VERSION.SDK_INT >= 21) {\n\t\t\t  v.setElevation(e);\n\t\t  }\n\t  }\n}", "class_id": 0, "repo": "Aghajari/AmirRateDialog-Android-Java", "file": "AmirRateDialog/ratedialog/src/main/java/com/aghajari/ratedialog/ViewUtils.java", "last_update_at": "2020-01-01T06:09:25+00:00", "question_id": "631198c554366e4c829dbfbb04518fac1765181d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class ViewUtils {\n\t  public static int getWidth(View v) { \n\t\t  return v.getLayoutParams().width; \n\t  }\n\t  \n\t  public static int getHeight(View v) {\n\t    return v.getLayoutParams().height;\n\t  }\n\t  \n\t  public static int getLeft(View v){\n\t\t  RateDialogLayout.LayoutParams lp = (RateDialogLayout.LayoutParams)v.getLayoutParams();\n\t    return lp.left;\n\t  }\n\t  \n\t  public static int getTop(View v){\n\t\tRateDialogLayout.LayoutParams lp = (RateDialogLayout.LayoutParams)v.getLayoutParams();\n\t    return lp.top;\n\t  }\n\t  public static void setWidth(View v,int width){\n\t\t    ViewGroup.LayoutParams lp = v.getLayoutParams();\n\t\t    lp.width = width;\n\t\t    requestLayout(v);\n\t   }\n\t  \n\t  public static void setHeight(View v,int height) {\n\t    ViewGroup.LayoutParams lp = v.getLayoutParams();\n\t    lp.height = height;\n\t    requestLayout(v);\n\t  }\n\t  \n\t  public static void setLeft(View v,int left) {\n\t\t  RateDialogLayout.LayoutParams lp = (RateDialogLayout.LayoutParams)v.getLayoutParams();\n\t    lp.left = left;\n\t    requestLayout(v);\n\t  }\n\t  \n\t  public static void setTop(View v,int top) {\n\t    RateDialogLayout.LayoutParams lp = (RateDialogLayout.LayoutParams)v.getLayoutParams();\n\t    lp.top = top;\n\t    requestLayout(v);\n\t  }\n\t  \n\t  private static void requestLayout(View v) { \n\t\t  ViewParent parent = v.getParent();\n\t    if (parent != null) {\n\t      parent.requestLayout();\n\t    }\n\t  }\n\t  \n\t  public static int getTextWidth (TextView v) {\n\t\treturn (int) MeasureStringWidth(new Paint(),v.getText().toString(),v.getTypeface(),v.getTextSize());\n\t  }\n\t  \n\t  private static float MeasureStringWidth(Paint paint,String Text, Typeface Typeface, float TextSize)\n\t  {\n\t    paint.setTextSize(TextSize);\n\t    paint.setTypeface(Typeface);\n\t    paint.setStrokeWidth(0.0F);\n\t    paint.setStyle(Paint.Style.STROKE);\n\t    paint.setTextAlign(Paint.Align.LEFT);\n\t    return paint.measureText(Text);\n\t  }\n\t  \n\t  public static void setClipToOutline(ViewGroup v) {\n\t\t  if (Build.VERSION.SDK_INT >= 21) {\n\t\t\tv.setClipToOutline(true);\n\t\t  }\n\t  }\n\t  public static void setClickEffect(View View, boolean Borderless) {\n\t    int[] attrs;\t    \n\t    if (Borderless) {\n\t      attrs = new int[] { android.R.attr.selectableItemBackgroundBorderless };\n\t    } else {\n\t      attrs = new int[] { android.R.attr.selectableItemBackground };\n\t    }\n\t    TypedArray typedArray = View.getContext().obtainStyledAttributes(attrs);\n\t    int backgroundResource = typedArray.getResourceId(0, 0);\n\t    View.setBackgroundResource(backgroundResource);\n\t  }\n\t  \t\n\t  public static void RemoveView(View view) {\n\t    if (view.getParent() instanceof ViewGroup) {\n\t      ViewGroup vg = (ViewGroup)view.getParent();\n\t      vg.removeView(view);\n\t    }\n\t  }\n\t  \n\t  public static void setElevation (View v,float e) {\n\t\t  if (Build.VERSION.SDK_INT >= 21) {\n\t\t\t  v.setElevation(e);\n\t\t  }\n\t  }\n"]]}
{"hexsha": "a9e146d2675401c8dbf33442ed126d7eedb0ae9c", "ext": "java", "lang": "Java", "content": "public class MyGson {\n    MyGson() {\n\n    }\n\n    String toJson(Object AnyObject) throws IllegalAccessException {\n        Class<AnyObject> classString = AnyObject.class;\n\n        Field[] fields = classString.getDeclaredFields();\n        StringBuilder jsonString = new StringBuilder();\n        if (fields.length != 0) {\n            jsonString.append(\"{\\\"\");\n        } else {\n            jsonString.append(\"{\");\n        }\n\n        for (int i = 0; i < fields.length; i++) {\n            if (fields[i].get(AnyObject) != null) {\n                if (i != 0) {\n                    jsonString.append(\",\\\"\");\n                }\n                jsonString.append(fields[i].getName() + \"\\\":\");\n                if (fields[i].getType().isArray()) {\n                    jsonString.append(\"[\");\n                }\n\n                ToMyGsonStringInterface config = ConfigurationFactory.getConfiguration(fields[i].getType().toString());\n                jsonString.append(config.ToMyGsonString(fields[i].get(AnyObject)));\n\n                if (fields[i].getType().isArray()) {\n                    jsonString.append(\"]\");\n                }\n            }\n        }\n        jsonString.append(\"}\");\n        return jsonString.toString();\n    }\n}", "class_id": 0, "repo": "Ingenieur2/2020-06-otus-java-korolev", "file": "hw08-MyGson/src/main/java/ru/package01/MyGson.java", "last_update_at": "2020-08-26T16:04:31+00:00", "question_id": "a9e146d2675401c8dbf33442ed126d7eedb0ae9c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MyGson {\n    MyGson() {\n    }\n    String toJson(Object AnyObject) throws IllegalAccessException {\n        Class<AnyObject> classString = AnyObject.class;\n        Field[] fields = classString.getDeclaredFields();\n        StringBuilder jsonString = new StringBuilder();\n        if (fields.length != 0) {\n            jsonString.append(\"{\\\"\");\n        } else {\n            jsonString.append(\"{\");\n        }\n        for (int i = 0; i < fields.length; i++) {\n            if (fields[i].get(AnyObject) != null) {\n                if (i != 0) {\n                    jsonString.append(\",\\\"\");\n                }\n                jsonString.append(fields[i].getName() + \"\\\":\");\n                if (fields[i].getType().isArray()) {\n                    jsonString.append(\"[\");\n                }\n                ToMyGsonStringInterface config = ConfigurationFactory.getConfiguration(fields[i].getType().toString());\n                jsonString.append(config.ToMyGsonString(fields[i].get(AnyObject)));\n                if (fields[i].getType().isArray()) {\n                    jsonString.append(\"]\");\n                }\n            }\n        }\n        jsonString.append(\"}\");\n        return jsonString.toString();\n    }\n"]]}
{"hexsha": "7227f47aa7610fe95ca27247cd92d5e1d2bfa855", "ext": "java", "lang": "Java", "content": "public class VersionedNewPortfolio extends NewPortfolio {\n\n  public enum Day {\n    Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday\n  }\n  \n  protected int pdxId = 0;           \n  protected String pdxName = \"name\";        \n  protected String pdxStatus = \"status\";\n  protected String pdxType = \"type\";\n  protected Map pdxPositions = new HashMap();\n  public String pdxUndefinedTestField = null;\n  public Day aDay;\n  \n  static transient List dayList;\n  \n  static {\n    Log.getLogWriter().info(\"In static initializer for testsVersions/version2/objects.VersionedPortfolio\");\n    dayList = new ArrayList();\n    dayList.addAll(EnumSet.range(Day.Monday, Day.Friday));\n  }\n  \n  public VersionedNewPortfolio() {\n    myVersion = \"testsVersions/version2/parReg.query.VersionedNewPortfolio\";\n  }\n  public VersionedNewPortfolio(String name, int id) {\n    super(name, id);\n\n    \n    this.pdxName = name;\n    this.pdxId = id;\n    \n    this.pdxStatus = id % 2 == 0 ? \"active\" : \"inactive\";\n    this.pdxType = \"type\" + (id % NUM_OF_TYPES);\n    this.aDay = getDayForBase(id);\n    \n    setPositions();\n  }\n  \n  private void setPositions() {\n    int numOfPositions = rng.nextInt(MAX_NUM_OF_POSITIONS);\n    if (numOfPositions == 0) \n      numOfPositions++;\n     \n    int secId =  rng.nextInt(NUM_OF_SECURITIES);\n    \n    for (int i=0; i < numOfPositions; i++) {\n      Properties props = getProps();\n      \n//    secId needs to be UNIQUE in one portfolio, keep track MAX_NUM_OF_POSITIONS and NUM_OF_SECURITIES\n      secId += i * 7;                    \n      if (secId > NUM_OF_SECURITIES)\n        secId -= NUM_OF_SECURITIES;\n      props.setProperty(\"secId\", new Integer(secId).toString());\n      \n      Position pos = new Position();\n      pos.init(props);\n      this.positions.put(pos.getSecId(), pos);\n    }\n  }\n\n  /* (non-Javadoc)\n   * @see java.lang.Object#toString()\n   */\n  @Override\n  public String toString() {\n    return this.getClass().getName() + \" [pdxId=\" + this.pdxId + \", pdxName=\"\n        + this.pdxName + \", pdxStatus=\" + this.pdxStatus + \", pdxType=\"\n        + this.pdxType + \", pdxPositions=\" + this.pdxPositions\n        + \", pdxUndefinedTestField=\" + this.pdxUndefinedTestField\n        + \", aDay=\" + this.aDay\n        + \", myVersion=\" + this.myVersion + \", id=\" + this.id + \", name=\"\n        + this.name + \", status=\" + this.status + \", type=\" + this.type\n        + \", positions=\" + this.positions + \", undefinedTestField=\"\n        + this.undefinedTestField + \"]\";\n  }\n\n  /* (non-Javadoc)\n   * @see com.gemstone.gemfire.pdx.PdxSerializable#toData(com.gemstone.gemfire.pdx.PdxWriter)\n   */\n  public void myToData(PdxWriter writer) {\n    if (PdxPrms.getLogToAndFromData()) {\n      Log.getLogWriter().info(\"In testsVersions/version2/parReg.query.VersionedNewPortfolio.myToData: \" + this);\n    }\n    writer.writeString(\"myVersion\", myVersion);\n    writer.writeInt(\"id\", id);\n    writer.writeString(\"name\", name);\n    writer.writeString(\"status\", status);\n    writer.writeString(\"type\", type);\n    writer.writeObject(\"positions\", positions);\n    writer.writeString(\"undefinedTestField\", undefinedTestField);\n    writer.writeInt(\"pdxId\", pdxId);\n    writer.writeString(\"pdxName\", pdxName);\n    writer.writeString(\"pdxStatus\", pdxStatus);\n    writer.writeString(\"pdxType\", pdxType);\n    writer.writeObject(\"pdxPositions\", pdxPositions);\n    writer.writeString(\"pdxUndefinedTestField\", pdxUndefinedTestField);\n    writer.writeObject(\"aDay\", aDay);\n  }\n\n  /* (non-Javadoc)\n   * @see com.gemstone.gemfire.pdx.PdxSerializable#fromData(com.gemstone.gemfire.pdx.PdxReader)\n   */\n  public void myFromData(PdxReader reader) {\n    myVersion = reader.readString(\"myVersion\");\n    if (PdxPrms.getLogToAndFromData()) {\n      Log.getLogWriter().info(\"In testsVersions/version2/parReg.query.VersionedNewPortfolio.myFromData with myVersion: \" + myVersion);\n    }\n    id = reader.readInt(\"id\");\n    name = reader.readString(\"name\");\n    status = reader.readString(\"status\");\n    type = reader.readString(\"type\");\n    positions = (Map)reader.readObject(\"positions\");\n    undefinedTestField = reader.readString(\"undefinedTestField\");\n    pdxId = reader.readInt(\"pdxId\");\n    pdxName = reader.readString(\"pdxName\");\n    pdxStatus = reader.readString(\"pdxStatus\");\n    pdxType = reader.readString(\"pdxType\");\n    pdxPositions = (Map)reader.readObject(\"pdxPositions\");\n    pdxUndefinedTestField = reader.readString(\"pdxUndefinedTestField\");\n    aDay = (Day)(reader.readObject(\"aDay\"));\n    if (PdxPrms.getLogToAndFromData()) {\n      Log.getLogWriter().info(\"After reading fields in testsVersion/version2/parReg.query.VersionedNewPortfolio.fromData: \" + this);\n    }\n  }\n  \n  /** Return the appropriate enum Day value given the base\n   * \n   * @param base Index to base the Day calculation on.\n   * @return A value of Day.\n   */\n  public static Day getDayForBase(int base) {\n      Day aDay = (Day)(dayList.get((base % dayList.size())));\n      return aDay;\n  }\n  \n}", "class_id": 0, "repo": "xyxiaoyou/snappy-store", "file": "tests/core/src/version2/java/parReg/query/VersionedNewPortfolio.java", "last_update_at": "2020-04-07T06:35:36+00:00", "question_id": "7227f47aa7610fe95ca27247cd92d5e1d2bfa855", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class VersionedNewPortfolio extends NewPortfolio {\n  public enum Day {\n    Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday\n  }\n  protected int pdxId = 0;           \n  protected String pdxName = \"name\";        \n  protected String pdxStatus = \"status\";\n  protected String pdxType = \"type\";\n  protected Map pdxPositions = new HashMap();\n  public String pdxUndefinedTestField = null;\n  public Day aDay;\n  static transient List dayList;\n  static {\n    Log.getLogWriter().info(\"In static initializer for testsVersions/version2/objects.VersionedPortfolio\");\n    dayList = new ArrayList();\n    dayList.addAll(EnumSet.range(Day.Monday, Day.Friday));\n  }\n  public VersionedNewPortfolio() {\n    myVersion = \"testsVersions/version2/parReg.query.VersionedNewPortfolio\";\n  }\n  public VersionedNewPortfolio(String name, int id) {\n    super(name, id);\n    this.pdxName = name;\n    this.pdxId = id;\n    this.pdxStatus = id % 2 == 0 ? \"active\" : \"inactive\";\n    this.pdxType = \"type\" + (id % NUM_OF_TYPES);\n    this.aDay = getDayForBase(id);\n    setPositions();\n  }\n  private void setPositions() {\n    int numOfPositions = rng.nextInt(MAX_NUM_OF_POSITIONS);\n    if (numOfPositions == 0) \n      numOfPositions++;\n    int secId =  rng.nextInt(NUM_OF_SECURITIES);\n    for (int i=0; i < numOfPositions; i++) {\n      Properties props = getProps();\n//    secId needs to be UNIQUE in one portfolio, keep track MAX_NUM_OF_POSITIONS and NUM_OF_SECURITIES\n      secId += i * 7;                    \n      if (secId > NUM_OF_SECURITIES)\n        secId -= NUM_OF_SECURITIES;\n      props.setProperty(\"secId\", new Integer(secId).toString());\n      Position pos = new Position();\n      pos.init(props);\n      this.positions.put(pos.getSecId(), pos);\n    }\n  }\n  /* (non-Javadoc)\n   * @see java.lang.Object#toString()\n   */\n  @Override\n  public String toString() {\n    return this.getClass().getName() + \" [pdxId=\" + this.pdxId + \", pdxName=\"\n        + this.pdxName + \", pdxStatus=\" + this.pdxStatus + \", pdxType=\"\n        + this.pdxType + \", pdxPositions=\" + this.pdxPositions\n        + \", pdxUndefinedTestField=\" + this.pdxUndefinedTestField\n        + \", aDay=\" + this.aDay\n        + \", myVersion=\" + this.myVersion + \", id=\" + this.id + \", name=\"\n        + this.name + \", status=\" + this.status + \", type=\" + this.type\n        + \", positions=\" + this.positions + \", undefinedTestField=\"\n        + this.undefinedTestField + \"]\";\n  }\n  /* (non-Javadoc)\n   * @see com.gemstone.gemfire.pdx.PdxSerializable#toData(com.gemstone.gemfire.pdx.PdxWriter)\n   */\n  public void myToData(PdxWriter writer) {\n    if (PdxPrms.getLogToAndFromData()) {\n      Log.getLogWriter().info(\"In testsVersions/version2/parReg.query.VersionedNewPortfolio.myToData: \" + this);\n    }\n    writer.writeString(\"myVersion\", myVersion);\n    writer.writeInt(\"id\", id);\n    writer.writeString(\"name\", name);\n    writer.writeString(\"status\", status);\n    writer.writeString(\"type\", type);\n    writer.writeObject(\"positions\", positions);\n    writer.writeString(\"undefinedTestField\", undefinedTestField);\n    writer.writeInt(\"pdxId\", pdxId);\n    writer.writeString(\"pdxName\", pdxName);\n    writer.writeString(\"pdxStatus\", pdxStatus);\n    writer.writeString(\"pdxType\", pdxType);\n    writer.writeObject(\"pdxPositions\", pdxPositions);\n    writer.writeString(\"pdxUndefinedTestField\", pdxUndefinedTestField);\n    writer.writeObject(\"aDay\", aDay);\n  }\n  /* (non-Javadoc)\n   * @see com.gemstone.gemfire.pdx.PdxSerializable#fromData(com.gemstone.gemfire.pdx.PdxReader)\n   */\n  public void myFromData(PdxReader reader) {\n    myVersion = reader.readString(\"myVersion\");\n    if (PdxPrms.getLogToAndFromData()) {\n      Log.getLogWriter().info(\"In testsVersions/version2/parReg.query.VersionedNewPortfolio.myFromData with myVersion: \" + myVersion);\n    }\n    id = reader.readInt(\"id\");\n    name = reader.readString(\"name\");\n    status = reader.readString(\"status\");\n    type = reader.readString(\"type\");\n    positions = (Map)reader.readObject(\"positions\");\n    undefinedTestField = reader.readString(\"undefinedTestField\");\n    pdxId = reader.readInt(\"pdxId\");\n    pdxName = reader.readString(\"pdxName\");\n    pdxStatus = reader.readString(\"pdxStatus\");\n    pdxType = reader.readString(\"pdxType\");\n    pdxPositions = (Map)reader.readObject(\"pdxPositions\");\n    pdxUndefinedTestField = reader.readString(\"pdxUndefinedTestField\");\n    aDay = (Day)(reader.readObject(\"aDay\"));\n    if (PdxPrms.getLogToAndFromData()) {\n      Log.getLogWriter().info(\"After reading fields in testsVersion/version2/parReg.query.VersionedNewPortfolio.fromData: \" + this);\n    }\n  }\n  /** Return the appropriate enum Day value given the base\n   * \n   * @param base Index to base the Day calculation on.\n   * @return A value of Day.\n   */\n  public static Day getDayForBase(int base) {\n      Day aDay = (Day)(dayList.get((base % dayList.size())));\n      return aDay;\n  }\n"]]}
{"hexsha": "b5e21d7be9c20f2546ca6122ce45717016671652", "ext": "java", "lang": "Java", "content": "class StartUseVcsDialog extends DialogWrapper {\n  private final Map<String, String> myVcses;\n  private VcsCombo myVcsCombo;\n  private String mySelected;\n\n  StartUseVcsDialog(@NotNull Project project) {\n    super(project, true);\n    myVcses = getVcses(project);\n    setTitle(VcsBundle.message(\"dialog.enable.version.control.integration.title\"));\n\n    init();\n  }\n\n  @Override\n  public JComponent getPreferredFocusedComponent() {\n    return myVcsCombo;\n  }\n\n  @Override\n  protected JComponent createCenterPanel() {\n    JLabel selectText = new JLabel(VcsBundle.message(\"dialog.enable.version.control.integration.select.vcs.label.text\"));\n    selectText.setUI(new MultiLineLabelUI());\n\n    JPanel mainPanel = new JPanel(new GridBagLayout());\n    GridBagConstraints gb = new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.BASELINE, GridBagConstraints.NONE, JBUI.insets(5),\n                                                   0, 0);\n    mainPanel.add(selectText, gb);\n\n    ++gb.gridx;\n\n    myVcsCombo = new VcsCombo(prepareComboData());\n    mainPanel.add(myVcsCombo, gb);\n\n    JLabel helpText = new JLabel(VcsBundle.message(\"dialog.enable.version.control.integration.hint.text\"));\n    helpText.setUI(new MultiLineLabelUI());\n    helpText.setForeground(UIUtil.getInactiveTextColor());\n\n    gb.anchor = GridBagConstraints.NORTHWEST;\n    gb.gridx = 0;\n    ++ gb.gridy;\n    gb.gridwidth = 2;\n    mainPanel.add(helpText, gb);\n\n    JPanel wrapper = new JPanel(new GridBagLayout());\n    GridBagConstraints gbc = new GridBagConstraints(0, 0, 1, 1, 1, 1, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE,\n                                                    JBUI.emptyInsets(), 0, 0);\n    wrapper.add(mainPanel, gbc);\n    return wrapper;\n  }\n\n  @Override\n  protected String getHelpId() {\n    return \"reference.version.control.enable.version.control.integration\";\n  }\n\n  @Override\n  protected void doOKAction() {\n    mySelected = myVcsCombo.getSelectedItem();\n    super.doOKAction();\n  }\n\n  private String @NotNull [] prepareComboData() {\n    ArrayList<String> keys = new ArrayList<>(myVcses.keySet());\n    keys.sort((String o1, String o2) -> {\n      if (o1.equals(o2)) return 0;\n      if (o1.equals(\"Git\")) return -1;\n      if (o2.equals(\"Git\")) return 1;\n      return o1.compareTo(o2);\n    });\n    return ArrayUtil.toStringArray(keys);\n  }\n\n  @NotNull\n  String getVcs() {\n    return myVcses.get(mySelected);\n  }\n\n  private static Map<String, String> getVcses(@NotNull Project project) {\n    VcsDescriptor[] allVcss = ProjectLevelVcsManager.getInstance(project).getAllVcss();\n    Map<String, String> map = new HashMap<>(allVcss.length);\n    for (VcsDescriptor vcs : allVcss) {\n      map.put(vcs.getDisplayName(), vcs.getName());\n    }\n    return map;\n  }\n\n  private static class VcsCombo extends JComboBox<String> {\n    private VcsCombo(String @NotNull [] items) {\n      super(items);\n      setSelectedIndex(0);\n      setEditable(false);\n    }\n\n    @Override\n    public String getSelectedItem() {\n      return (String) super.getSelectedItem();\n    }\n  }\n}", "class_id": 0, "repo": "azaretsky/intellij-community", "file": "platform/vcs-impl/src/com/intellij/ide/actions/StartUseVcsDialog.java", "last_update_at": "2020-05-14T18:47:46+00:00", "question_id": "b5e21d7be9c20f2546ca6122ce45717016671652", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class StartUseVcsDialog extends DialogWrapper {\n  private final Map<String, String> myVcses;\n  private VcsCombo myVcsCombo;\n  private String mySelected;\n  StartUseVcsDialog(@NotNull Project project) {\n    super(project, true);\n    myVcses = getVcses(project);\n    setTitle(VcsBundle.message(\"dialog.enable.version.control.integration.title\"));\n    init();\n  }\n  @Override\n  public JComponent getPreferredFocusedComponent() {\n    return myVcsCombo;\n  }\n  @Override\n  protected JComponent createCenterPanel() {\n    JLabel selectText = new JLabel(VcsBundle.message(\"dialog.enable.version.control.integration.select.vcs.label.text\"));\n    selectText.setUI(new MultiLineLabelUI());\n    JPanel mainPanel = new JPanel(new GridBagLayout());\n    GridBagConstraints gb = new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.BASELINE, GridBagConstraints.NONE, JBUI.insets(5),\n                                                   0, 0);\n    mainPanel.add(selectText, gb);\n    ++gb.gridx;\n    myVcsCombo = new VcsCombo(prepareComboData());\n    mainPanel.add(myVcsCombo, gb);\n    JLabel helpText = new JLabel(VcsBundle.message(\"dialog.enable.version.control.integration.hint.text\"));\n    helpText.setUI(new MultiLineLabelUI());\n    helpText.setForeground(UIUtil.getInactiveTextColor());\n    gb.anchor = GridBagConstraints.NORTHWEST;\n    gb.gridx = 0;\n    ++ gb.gridy;\n    gb.gridwidth = 2;\n    mainPanel.add(helpText, gb);\n    JPanel wrapper = new JPanel(new GridBagLayout());\n    GridBagConstraints gbc = new GridBagConstraints(0, 0, 1, 1, 1, 1, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE,\n                                                    JBUI.emptyInsets(), 0, 0);\n    wrapper.add(mainPanel, gbc);\n    return wrapper;\n  }\n  @Override\n  protected String getHelpId() {\n    return \"reference.version.control.enable.version.control.integration\";\n  }\n  @Override\n  protected void doOKAction() {\n    mySelected = myVcsCombo.getSelectedItem();\n    super.doOKAction();\n  }\n  private String @NotNull [] prepareComboData() {\n    ArrayList<String> keys = new ArrayList<>(myVcses.keySet());\n    keys.sort((String o1, String o2) -> {\n      if (o1.equals(o2)) return 0;\n      if (o1.equals(\"Git\")) return -1;\n      if (o2.equals(\"Git\")) return 1;\n      return o1.compareTo(o2);\n    });\n    return ArrayUtil.toStringArray(keys);\n  }\n  @NotNull\n  String getVcs() {\n    return myVcses.get(mySelected);\n  }\n  private static Map<String, String> getVcses(@NotNull Project project) {\n    VcsDescriptor[] allVcss = ProjectLevelVcsManager.getInstance(project).getAllVcss();\n    Map<String, String> map = new HashMap<>(allVcss.length);\n    for (VcsDescriptor vcs : allVcss) {\n      map.put(vcs.getDisplayName(), vcs.getName());\n    }\n    return map;\n  }\n  private static class VcsCombo extends JComboBox<String> {\n    private VcsCombo(String @NotNull [] items) {\n      super(items);\n      setSelectedIndex(0);\n      setEditable(false);\n    }\n    @Override\n    public String getSelectedItem() {\n      return (String) super.getSelectedItem();\n    }\n  }\n"]]}
{"hexsha": "ad163cd6a802ea0c9da3d83d79bd82b4e5dcc150", "ext": "java", "lang": "Java", "content": "public class BooleanTest {\n    @Test\n    public void sample1Test() {\n        String json = \"[{$eq: [\\\"$IncomeStatus\\\", 30]}, {$eq: [\\\"$IncomeStatus\\\", 40]}, {$eq: [\\\"$ChannelFeeStatus\\\", 30]}, {$eq: [\\\"$BankChannelFeeStatus\\\", 30]}]\";\n        json = JSONUtils.fastjsonParsePreDeal(json);\n\n        Document or = BooleanOperators.or(json);\n        System.out.println(or);\n\n        Document result = new Document(\"$or\", Arrays.asList(\n                new Document(\"$eq\", Arrays.asList(\"$IncomeStatus\", 30)),\n                new Document(\"$eq\", Arrays.asList(\"$IncomeStatus\", 40)),\n                new Document(\"$eq\", Arrays.asList(\"$ChannelFeeStatus\", 30)),\n                new Document(\"$eq\", Arrays.asList(\"$BankChannelFeeStatus\", 30))\n        ));\n        System.out.println(result);\n    }\n\n    @Test\n    public void sample2Test() {\n        String json = \"[{$eq: [\\\"$IncomeStatus\\\", 30]}, {$eq: [\\\"$IncomeStatus\\\", 40]}, {$eq: [\\\"$ChannelFeeStatus\\\", 30]}, {$eq: [\\\"$BankChannelFeeStatus\\\", 30]}]\";\n        json = JSONUtils.fastjsonParsePreDeal(json);\n\n        Document or = BooleanOperators.or(json);\n        System.out.println(or);\n\n        Document result = new Document(\"$or\", Arrays.asList(\n                new Document(\"$eq\", Arrays.asList(\"$IncomeStatus\", 30)),\n                new Document(\"$eq\", Arrays.asList(\"$IncomeStatus\", 40)),\n                new Document(\"$eq\", Arrays.asList(\"$ChannelFeeStatus\", 30)),\n                new Document(\"$eq\", Arrays.asList(\"$BankChannelFeeStatus\", 30))\n        ));\n        System.out.println(result);\n    }\n\n    @Test\n    public void sample3Test() {\n        String json = \"{ $and : [ { $gte : [ { $avg : \\\"$Income\\\" }, 80 ] },{ $lt : [ { $avg : \\\"$Income\\\" }, 90 ] } ] }\";\n        json = JSONUtils.fastjsonParsePreDeal(json);\n\n        Document and = ExpressionHelper.parse(json);\n        System.out.println(and);\n\n        Document result = new Document(\"$and\", Arrays.asList(\n                new Document(\"$gte\", Arrays.asList(new Document(\"$avg\", \"$Income\"), 80)),\n                new Document(\"$lt\", Arrays.asList(new Document(\"$avg\", \"$Income\"), 90))\n        ));\n        System.out.println(result);\n    }\n\n\n\n\n}", "class_id": 0, "repo": "lanceleedev/mongo-pipeline-transfer", "file": "src/test/java/com/mongodb/pipeline/transfer/test/operator/BooleanTest.java", "last_update_at": "2020-04-09T08:59:27+00:00", "question_id": "ad163cd6a802ea0c9da3d83d79bd82b4e5dcc150", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BooleanTest {\n    @Test\n    public void sample1Test() {\n        String json = \"[{$eq: [\\\"$IncomeStatus\\\", 30]}, {$eq: [\\\"$IncomeStatus\\\", 40]}, {$eq: [\\\"$ChannelFeeStatus\\\", 30]}, {$eq: [\\\"$BankChannelFeeStatus\\\", 30]}]\";\n        json = JSONUtils.fastjsonParsePreDeal(json);\n        Document or = BooleanOperators.or(json);\n        System.out.println(or);\n        Document result = new Document(\"$or\", Arrays.asList(\n                new Document(\"$eq\", Arrays.asList(\"$IncomeStatus\", 30)),\n                new Document(\"$eq\", Arrays.asList(\"$IncomeStatus\", 40)),\n                new Document(\"$eq\", Arrays.asList(\"$ChannelFeeStatus\", 30)),\n                new Document(\"$eq\", Arrays.asList(\"$BankChannelFeeStatus\", 30))\n        ));\n        System.out.println(result);\n    }\n    @Test\n    public void sample2Test() {\n        String json = \"[{$eq: [\\\"$IncomeStatus\\\", 30]}, {$eq: [\\\"$IncomeStatus\\\", 40]}, {$eq: [\\\"$ChannelFeeStatus\\\", 30]}, {$eq: [\\\"$BankChannelFeeStatus\\\", 30]}]\";\n        json = JSONUtils.fastjsonParsePreDeal(json);\n        Document or = BooleanOperators.or(json);\n        System.out.println(or);\n        Document result = new Document(\"$or\", Arrays.asList(\n                new Document(\"$eq\", Arrays.asList(\"$IncomeStatus\", 30)),\n                new Document(\"$eq\", Arrays.asList(\"$IncomeStatus\", 40)),\n                new Document(\"$eq\", Arrays.asList(\"$ChannelFeeStatus\", 30)),\n                new Document(\"$eq\", Arrays.asList(\"$BankChannelFeeStatus\", 30))\n        ));\n        System.out.println(result);\n    }\n    @Test\n    public void sample3Test() {\n        String json = \"{ $and : [ { $gte : [ { $avg : \\\"$Income\\\" }, 80 ] },{ $lt : [ { $avg : \\\"$Income\\\" }, 90 ] } ] }\";\n        json = JSONUtils.fastjsonParsePreDeal(json);\n        Document and = ExpressionHelper.parse(json);\n        System.out.println(and);\n        Document result = new Document(\"$and\", Arrays.asList(\n                new Document(\"$gte\", Arrays.asList(new Document(\"$avg\", \"$Income\"), 80)),\n                new Document(\"$lt\", Arrays.asList(new Document(\"$avg\", \"$Income\"), 90))\n        ));\n        System.out.println(result);\n    }\n"]]}
{"hexsha": "b3e22891ce5d8c15a463f8031f247fd2ad09a813", "ext": "java", "lang": "Java", "content": "class Solution {\n    public List<String> summaryRanges(int[] nums) {\n        List<String> ranges = new ArrayList<>();\n        boolean isRange = false;\n        for (int i = 0; i <= nums.length; i++) {\n            if (i > 0 && i < nums.length && nums[i] - nums[i - 1] == 1) {\n                isRange = true;\n            } else if (isRange) {\n                ranges.set(ranges.size() - 1, ranges.get(ranges.size() - 1) + \"->\" + Integer.toString(nums[i - 1]));\n                if (i < nums.length) {\n                    ranges.add(Integer.toString(nums[i]));\n                }\n                isRange = false;\n            } else {\n                if (i < nums.length) {\n                    ranges.add(Integer.toString(nums[i]));\n                }\n            }\n        }\n        return ranges;\n    }\n}", "class_id": 0, "repo": "FeiZhan/Algo-Collection", "file": "answers/leetcode/Summary Ranges/Summary Ranges.java", "last_update_at": "2020-12-06T00:37:32+00:00", "question_id": "b3e22891ce5d8c15a463f8031f247fd2ad09a813", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Solution {\n    public List<String> summaryRanges(int[] nums) {\n        List<String> ranges = new ArrayList<>();\n        boolean isRange = false;\n        for (int i = 0; i <= nums.length; i++) {\n            if (i > 0 && i < nums.length && nums[i] - nums[i - 1] == 1) {\n                isRange = true;\n            } else if (isRange) {\n                ranges.set(ranges.size() - 1, ranges.get(ranges.size() - 1) + \"->\" + Integer.toString(nums[i - 1]));\n                if (i < nums.length) {\n                    ranges.add(Integer.toString(nums[i]));\n                }\n                isRange = false;\n            } else {\n                if (i < nums.length) {\n                    ranges.add(Integer.toString(nums[i]));\n                }\n            }\n        }\n        return ranges;\n    }\n"]]}
{"hexsha": "f15535888b742bf4d27de0cdc58c5e1036331bae", "ext": "java", "lang": "Java", "content": "public class ReaderTokenizerTest extends TestCase {\n\n\tpublic void testReaderTokenizerRules() throws IOException, TokenizerException {\n\t\tString input = FileUtils.getFromResource(\"ee/pri/rl/tokenizer/reader/test/test.rules\");\n\t\tlong start = System.currentTimeMillis();\n\t\tList<Token> tokens = ReaderTokenizer.tokenize(input);\n\t\tSystem.out.println(\"Tokenizing took \" + (System.currentTimeMillis() - start) + \"ms\");\n\t\tassertFalse(tokens.isEmpty());\n\t\tassertTrue(tokens.get(0).equals(new Token(\"startState\", \"startState\", 0)));\n\t\tassertTrue(tokens.get(1).equals(new Token(\"endState\", \"end\", 0)));\n\t}\n}", "class_id": 0, "repo": "rla/old-code", "file": "2007/wiki/parser-tokenizer/src/ee/pri/rl/tokenizer/reader/test/ReaderTokenizerTest.java", "last_update_at": "2020-03-10T00:00:58+00:00", "question_id": "f15535888b742bf4d27de0cdc58c5e1036331bae", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ReaderTokenizerTest extends TestCase {\n\tpublic void testReaderTokenizerRules() throws IOException, TokenizerException {\n\t\tString input = FileUtils.getFromResource(\"ee/pri/rl/tokenizer/reader/test/test.rules\");\n\t\tlong start = System.currentTimeMillis();\n\t\tList<Token> tokens = ReaderTokenizer.tokenize(input);\n\t\tSystem.out.println(\"Tokenizing took \" + (System.currentTimeMillis() - start) + \"ms\");\n\t\tassertFalse(tokens.isEmpty());\n\t\tassertTrue(tokens.get(0).equals(new Token(\"startState\", \"startState\", 0)));\n\t\tassertTrue(tokens.get(1).equals(new Token(\"endState\", \"end\", 0)));\n\t}\n"]]}
{"hexsha": "60ba1d51cf918d5d71aa9d1d4bff3bbdd47025fc", "ext": "java", "lang": "Java", "content": "public class PaymentSessionTest {\n    private static final NetworkParameters PARAMS = TestNet3Params.get();\n    private static final String simplePaymentUrl = \"http://a.simple.url.com/\";\n    private static final String paymentRequestMemo = \"send coinz noa plz kthx\";\n    private static final String paymentMemo = \"take ze coinz\";\n    private static final ByteString merchantData = ByteString.copyFromUtf8(\"merchant data\");\n    private static final long time = System.currentTimeMillis() / 1000L;\n    private ECKey serverKey;\n    private Transaction tx;\n    private TransactionOutput outputToMe;\n    private Coin coin = COIN;\n\n    @Before\n    public void setUp() throws Exception {\n        serverKey = new ECKey();\n        tx = new Transaction(PARAMS);\n        outputToMe = new TransactionOutput(PARAMS, tx, coin, serverKey);\n        tx.addOutput(outputToMe);\n    }\n\n    @Test\n    public void testSimplePayment() throws Exception {\n        // Create a PaymentRequest and make sure the correct values are parsed by the PaymentSession.\n        MockPaymentSession paymentSession = new MockPaymentSession(newSimplePaymentRequest(\"test\"));\n        assertEquals(paymentRequestMemo, paymentSession.getMemo());\n        assertEquals(coin, paymentSession.getValue());\n        assertEquals(simplePaymentUrl, paymentSession.getPaymentUrl());\n        assertTrue(new Date(time * 1000L).equals(paymentSession.getDate()));\n        assertTrue(paymentSession.getSendRequest().tx.equals(tx));\n        assertFalse(paymentSession.isExpired());\n\n        // Send the payment and verify that the correct information is sent.\n        // Add a dummy input to tx so it is considered valid.\n        tx.addInput(new TransactionInput(PARAMS, tx, outputToMe.getScriptBytes()));\n        ArrayList<Transaction> txns = new ArrayList<>();\n        txns.add(tx);\n        Address refundAddr = new Address(PARAMS, serverKey.getPubKeyHash());\n        paymentSession.sendPayment(txns, refundAddr, paymentMemo);\n        assertEquals(1, paymentSession.getPaymentLog().size());\n        assertEquals(simplePaymentUrl, paymentSession.getPaymentLog().get(0).getUrl().toString());\n        Protos.Payment payment = paymentSession.getPaymentLog().get(0).getPayment();\n        assertEquals(paymentMemo, payment.getMemo());\n        assertEquals(merchantData, payment.getMerchantData());\n        assertEquals(1, payment.getRefundToCount());\n        assertEquals(coin.value, payment.getRefundTo(0).getAmount());\n        TransactionOutput refundOutput = new TransactionOutput(PARAMS, null, coin, refundAddr);\n        ByteString refundScript = ByteString.copyFrom(refundOutput.getScriptBytes());\n        assertTrue(refundScript.equals(payment.getRefundTo(0).getScript()));\n    }\n\n    @Test\n    public void testDefaults() throws Exception {\n        Protos.Output.Builder outputBuilder = Protos.Output.newBuilder()\n                .setScript(ByteString.copyFrom(outputToMe.getScriptBytes()));\n        Protos.PaymentDetails paymentDetails = Protos.PaymentDetails.newBuilder()\n                .setTime(time)\n                .addOutputs(outputBuilder)\n                .build();\n        Protos.PaymentRequest paymentRequest = Protos.PaymentRequest.newBuilder()\n                .setSerializedPaymentDetails(paymentDetails.toByteString())\n                .build();\n        MockPaymentSession paymentSession = new MockPaymentSession(paymentRequest);\n        assertEquals(Coin.ZERO, paymentSession.getValue());\n        assertNull(paymentSession.getPaymentUrl());\n        assertNull(paymentSession.getMemo());\n    }\n\n    @Test\n    public void testExpiredPaymentRequest() throws Exception {\n        MockPaymentSession paymentSession = new MockPaymentSession(newExpiredPaymentRequest());\n        assertTrue(paymentSession.isExpired());\n        // Send the payment and verify that an exception is thrown.\n        // Add a dummy input to tx so it is considered valid.\n        tx.addInput(new TransactionInput(PARAMS, tx, outputToMe.getScriptBytes()));\n        ArrayList<Transaction> txns = new ArrayList<>();\n        txns.add(tx);\n        try {\n            paymentSession.sendPayment(txns, null, null);\n        } catch(PaymentProtocolException.Expired e) {\n            assertEquals(0, paymentSession.getPaymentLog().size());\n            assertEquals(e.getMessage(), \"PaymentRequest is expired\");\n            return;\n        }\n        fail(\"Expected exception due to expired PaymentRequest\");\n    }\n\n    @Test\n    public void testPkiVerification() throws Exception {\n        InputStream in = getClass().getResourceAsStream(\"pki_test.bitcoinpaymentrequest\");\n        Protos.PaymentRequest paymentRequest = Protos.PaymentRequest.newBuilder().mergeFrom(in).build();\n        PaymentProtocol.PkiVerificationData pkiData = PaymentProtocol.verifyPaymentRequestPki(paymentRequest,\n                new TrustStoreLoader.DefaultTrustStoreLoader().getKeyStore());\n        assertEquals(\"www.bitcoincore.org\", pkiData.displayName);\n        assertEquals(\"The USERTRUST Network, Salt Lake City, US\", pkiData.rootAuthorityName);\n    }\n\n    @Test(expected = PaymentProtocolException.InvalidNetwork.class)\n    public void testWrongNetwork() throws Exception {\n        // Create a PaymentRequest and make sure the correct values are parsed by the PaymentSession.\n        MockPaymentSession paymentSession = new MockPaymentSession(newSimplePaymentRequest(\"main\"));\n        assertEquals(MainNetParams.get(), paymentSession.getNetworkParameters());\n\n        // Send the payment and verify that the correct information is sent.\n        // Add a dummy input to tx so it is considered valid.\n        tx.addInput(new TransactionInput(PARAMS, tx, outputToMe.getScriptBytes()));\n        ArrayList<Transaction> txns = new ArrayList<>();\n        txns.add(tx);\n        Address refundAddr = new Address(PARAMS, serverKey.getPubKeyHash());\n        paymentSession.sendPayment(txns, refundAddr, paymentMemo);\n        assertEquals(1, paymentSession.getPaymentLog().size());\n    }\n\n    private Protos.PaymentRequest newSimplePaymentRequest(String netID) {\n        Protos.Output.Builder outputBuilder = Protos.Output.newBuilder()\n                .setAmount(coin.value)\n                .setScript(ByteString.copyFrom(outputToMe.getScriptBytes()));\n        Protos.PaymentDetails paymentDetails = Protos.PaymentDetails.newBuilder()\n                .setNetwork(netID)\n                .setTime(time)\n                .setPaymentUrl(simplePaymentUrl)\n                .addOutputs(outputBuilder)\n                .setMemo(paymentRequestMemo)\n                .setMerchantData(merchantData)\n                .build();\n        return Protos.PaymentRequest.newBuilder()\n                .setPaymentDetailsVersion(1)\n                .setPkiType(\"none\")\n                .setSerializedPaymentDetails(paymentDetails.toByteString())\n                .build();\n    }\n\n    private Protos.PaymentRequest newExpiredPaymentRequest() {\n        Protos.Output.Builder outputBuilder = Protos.Output.newBuilder()\n                .setAmount(coin.value)\n                .setScript(ByteString.copyFrom(outputToMe.getScriptBytes()));\n        Protos.PaymentDetails paymentDetails = Protos.PaymentDetails.newBuilder()\n                .setNetwork(\"test\")\n                .setTime(time - 10)\n                .setExpires(time - 1)\n                .setPaymentUrl(simplePaymentUrl)\n                .addOutputs(outputBuilder)\n                .setMemo(paymentRequestMemo)\n                .setMerchantData(merchantData)\n                .build();\n        return Protos.PaymentRequest.newBuilder()\n                .setPaymentDetailsVersion(1)\n                .setPkiType(\"none\")\n                .setSerializedPaymentDetails(paymentDetails.toByteString())\n                .build();\n    }\n\n    private class MockPaymentSession extends PaymentSession {\n        private ArrayList<PaymentLogItem> paymentLog = new ArrayList<>();\n\n        public MockPaymentSession(Protos.PaymentRequest request) throws PaymentProtocolException {\n            super(request);\n        }\n\n        public ArrayList<PaymentLogItem> getPaymentLog() {\n            return paymentLog;\n        }\n\n        @Override\n        protected ListenableFuture<PaymentProtocol.Ack> sendPayment(final URL url, final Protos.Payment payment) {\n            paymentLog.add(new PaymentLogItem(url, payment));\n            return null;\n        }\n\n        public class PaymentLogItem {\n            private final URL url;\n            private final Protos.Payment payment;\n\n            PaymentLogItem(final URL url, final Protos.Payment payment) {\n                this.url = url;\n                this.payment = payment;\n            }\n\n            public URL getUrl() {\n                return url;\n            }\n\n            public Protos.Payment getPayment() {\n                return payment;\n            }\n        }\n    }\n}", "class_id": 0, "repo": "beyondcoin-project/beyondcoinj", "file": "core/src/test/java/org/beyondcoinj/protocols/payments/PaymentSessionTest.java", "last_update_at": "2020-03-27T23:44:16+00:00", "question_id": "60ba1d51cf918d5d71aa9d1d4bff3bbdd47025fc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PaymentSessionTest {\n    private static final NetworkParameters PARAMS = TestNet3Params.get();\n    private static final String simplePaymentUrl = \"http://a.simple.url.com/\";\n    private static final String paymentRequestMemo = \"send coinz noa plz kthx\";\n    private static final String paymentMemo = \"take ze coinz\";\n    private static final ByteString merchantData = ByteString.copyFromUtf8(\"merchant data\");\n    private static final long time = System.currentTimeMillis() / 1000L;\n    private ECKey serverKey;\n    private Transaction tx;\n    private TransactionOutput outputToMe;\n    private Coin coin = COIN;\n    @Before\n    public void setUp() throws Exception {\n        serverKey = new ECKey();\n        tx = new Transaction(PARAMS);\n        outputToMe = new TransactionOutput(PARAMS, tx, coin, serverKey);\n        tx.addOutput(outputToMe);\n    }\n    @Test\n    public void testSimplePayment() throws Exception {\n        // Create a PaymentRequest and make sure the correct values are parsed by the PaymentSession.\n        MockPaymentSession paymentSession = new MockPaymentSession(newSimplePaymentRequest(\"test\"));\n        assertEquals(paymentRequestMemo, paymentSession.getMemo());\n        assertEquals(coin, paymentSession.getValue());\n        assertEquals(simplePaymentUrl, paymentSession.getPaymentUrl());\n        assertTrue(new Date(time * 1000L).equals(paymentSession.getDate()));\n        assertTrue(paymentSession.getSendRequest().tx.equals(tx));\n        assertFalse(paymentSession.isExpired());\n        // Send the payment and verify that the correct information is sent.\n        // Add a dummy input to tx so it is considered valid.\n        tx.addInput(new TransactionInput(PARAMS, tx, outputToMe.getScriptBytes()));\n        ArrayList<Transaction> txns = new ArrayList<>();\n        txns.add(tx);\n        Address refundAddr = new Address(PARAMS, serverKey.getPubKeyHash());\n        paymentSession.sendPayment(txns, refundAddr, paymentMemo);\n        assertEquals(1, paymentSession.getPaymentLog().size());\n        assertEquals(simplePaymentUrl, paymentSession.getPaymentLog().get(0).getUrl().toString());\n        Protos.Payment payment = paymentSession.getPaymentLog().get(0).getPayment();\n        assertEquals(paymentMemo, payment.getMemo());\n        assertEquals(merchantData, payment.getMerchantData());\n        assertEquals(1, payment.getRefundToCount());\n        assertEquals(coin.value, payment.getRefundTo(0).getAmount());\n        TransactionOutput refundOutput = new TransactionOutput(PARAMS, null, coin, refundAddr);\n        ByteString refundScript = ByteString.copyFrom(refundOutput.getScriptBytes());\n        assertTrue(refundScript.equals(payment.getRefundTo(0).getScript()));\n    }\n    @Test\n    public void testDefaults() throws Exception {\n        Protos.Output.Builder outputBuilder = Protos.Output.newBuilder()\n                .setScript(ByteString.copyFrom(outputToMe.getScriptBytes()));\n        Protos.PaymentDetails paymentDetails = Protos.PaymentDetails.newBuilder()\n                .setTime(time)\n                .addOutputs(outputBuilder)\n                .build();\n        Protos.PaymentRequest paymentRequest = Protos.PaymentRequest.newBuilder()\n                .setSerializedPaymentDetails(paymentDetails.toByteString())\n                .build();\n        MockPaymentSession paymentSession = new MockPaymentSession(paymentRequest);\n        assertEquals(Coin.ZERO, paymentSession.getValue());\n        assertNull(paymentSession.getPaymentUrl());\n        assertNull(paymentSession.getMemo());\n    }\n    @Test\n    public void testExpiredPaymentRequest() throws Exception {\n        MockPaymentSession paymentSession = new MockPaymentSession(newExpiredPaymentRequest());\n        assertTrue(paymentSession.isExpired());\n        // Send the payment and verify that an exception is thrown.\n        // Add a dummy input to tx so it is considered valid.\n        tx.addInput(new TransactionInput(PARAMS, tx, outputToMe.getScriptBytes()));\n        ArrayList<Transaction> txns = new ArrayList<>();\n        txns.add(tx);\n        try {\n            paymentSession.sendPayment(txns, null, null);\n        } catch(PaymentProtocolException.Expired e) {\n            assertEquals(0, paymentSession.getPaymentLog().size());\n            assertEquals(e.getMessage(), \"PaymentRequest is expired\");\n            return;\n        }\n        fail(\"Expected exception due to expired PaymentRequest\");\n    }\n    @Test\n    public void testPkiVerification() throws Exception {\n        InputStream in = getClass().getResourceAsStream(\"pki_test.bitcoinpaymentrequest\");\n        Protos.PaymentRequest paymentRequest = Protos.PaymentRequest.newBuilder().mergeFrom(in).build();\n        PaymentProtocol.PkiVerificationData pkiData = PaymentProtocol.verifyPaymentRequestPki(paymentRequest,\n                new TrustStoreLoader.DefaultTrustStoreLoader().getKeyStore());\n        assertEquals(\"www.bitcoincore.org\", pkiData.displayName);\n        assertEquals(\"The USERTRUST Network, Salt Lake City, US\", pkiData.rootAuthorityName);\n    }\n    @Test(expected = PaymentProtocolException.InvalidNetwork.class)\n    public void testWrongNetwork() throws Exception {\n        // Create a PaymentRequest and make sure the correct values are parsed by the PaymentSession.\n        MockPaymentSession paymentSession = new MockPaymentSession(newSimplePaymentRequest(\"main\"));\n        assertEquals(MainNetParams.get(), paymentSession.getNetworkParameters());\n        // Send the payment and verify that the correct information is sent.\n        // Add a dummy input to tx so it is considered valid.\n        tx.addInput(new TransactionInput(PARAMS, tx, outputToMe.getScriptBytes()));\n        ArrayList<Transaction> txns = new ArrayList<>();\n        txns.add(tx);\n        Address refundAddr = new Address(PARAMS, serverKey.getPubKeyHash());\n        paymentSession.sendPayment(txns, refundAddr, paymentMemo);\n        assertEquals(1, paymentSession.getPaymentLog().size());\n    }\n    private Protos.PaymentRequest newSimplePaymentRequest(String netID) {\n        Protos.Output.Builder outputBuilder = Protos.Output.newBuilder()\n                .setAmount(coin.value)\n                .setScript(ByteString.copyFrom(outputToMe.getScriptBytes()));\n        Protos.PaymentDetails paymentDetails = Protos.PaymentDetails.newBuilder()\n                .setNetwork(netID)\n                .setTime(time)\n                .setPaymentUrl(simplePaymentUrl)\n                .addOutputs(outputBuilder)\n                .setMemo(paymentRequestMemo)\n                .setMerchantData(merchantData)\n                .build();\n        return Protos.PaymentRequest.newBuilder()\n                .setPaymentDetailsVersion(1)\n                .setPkiType(\"none\")\n                .setSerializedPaymentDetails(paymentDetails.toByteString())\n                .build();\n    }\n    private Protos.PaymentRequest newExpiredPaymentRequest() {\n        Protos.Output.Builder outputBuilder = Protos.Output.newBuilder()\n                .setAmount(coin.value)\n                .setScript(ByteString.copyFrom(outputToMe.getScriptBytes()));\n        Protos.PaymentDetails paymentDetails = Protos.PaymentDetails.newBuilder()\n                .setNetwork(\"test\")\n                .setTime(time - 10)\n                .setExpires(time - 1)\n                .setPaymentUrl(simplePaymentUrl)\n                .addOutputs(outputBuilder)\n                .setMemo(paymentRequestMemo)\n                .setMerchantData(merchantData)\n                .build();\n        return Protos.PaymentRequest.newBuilder()\n                .setPaymentDetailsVersion(1)\n                .setPkiType(\"none\")\n                .setSerializedPaymentDetails(paymentDetails.toByteString())\n                .build();\n    }\n    private class MockPaymentSession extends PaymentSession {\n        private ArrayList<PaymentLogItem> paymentLog = new ArrayList<>();\n        public MockPaymentSession(Protos.PaymentRequest request) throws PaymentProtocolException {\n            super(request);\n        }\n        public ArrayList<PaymentLogItem> getPaymentLog() {\n            return paymentLog;\n        }\n        @Override\n        protected ListenableFuture<PaymentProtocol.Ack> sendPayment(final URL url, final Protos.Payment payment) {\n            paymentLog.add(new PaymentLogItem(url, payment));\n            return null;\n        }\n        public class PaymentLogItem {\n            private final URL url;\n            private final Protos.Payment payment;\n            PaymentLogItem(final URL url, final Protos.Payment payment) {\n                this.url = url;\n                this.payment = payment;\n            }\n            public URL getUrl() {\n                return url;\n            }\n            public Protos.Payment getPayment() {\n                return payment;\n            }\n        }\n    }\n"]]}
{"hexsha": "eccc474756cb7236c86b3ffef8df5b704d96b430", "ext": "java", "lang": "Java", "content": "public class MementoCard extends AbstractDynamicCard {\n    // TEXT DECLARATION\n\n    public static final String ID = HermitMod.makeID(MementoCard.class.getSimpleName());\n    public static final String IMG = makeCardPath(\"memento.png\");\n\n    // /TEXT DECLARATION/\n\n\n    // STAT DECLARATION\n\n    private static final CardRarity RARITY = CardRarity.SPECIAL;\n    private static final CardTarget TARGET = CardTarget.ALL;\n    private static final CardType TYPE = CardType.CURSE;\n    public static final CardColor COLOR = CardColor.CURSE;\n    private static final CardStrings cardStrings = CardCrawlGame.languagePack.getCardStrings(ID);\n    public static final String UPGRADE_DESCRIPTION = cardStrings.UPGRADE_DESCRIPTION;\n\n    private static final int MAGIC_NUMBER = 1;\n\n    private static final int COST = 0;\n\n    // /STAT DECLARATION/\n\n    public MementoCard() {\n        super(ID, IMG, COST, TYPE, COLOR, RARITY, TARGET);\n        baseMagicNumber = magicNumber = MAGIC_NUMBER;\n        this.selfRetain = true;\n        loadJokeCardImage(this, \"memento.png\");\n    }\n\n    public void use(AbstractPlayer p, AbstractMonster m) {\n        Iterator var4 = AbstractDungeon.getCurrRoom().monsters.monsters.iterator();\n\n        while(var4.hasNext()) {\n            AbstractMonster mo = (AbstractMonster)var4.next();\n            this.addToBot(new ApplyPowerAction(mo, p, new VulnerablePower(mo, magicNumber, false), magicNumber, true, AbstractGameAction.AttackEffect.NONE));\n\n            if (this.upgraded)\n            this.addToBot(new ApplyPowerAction(mo, p, new WeakPower(mo, magicNumber, false), magicNumber, true, AbstractGameAction.AttackEffect.NONE));\n        }\n\n        this.addToBot(new ApplyPowerAction(p, p, new VulnerablePower(p, magicNumber, false), magicNumber));\n\n        if (this.upgraded)\n        this.addToBot(new ApplyPowerAction(p, p, new WeakPower(p, magicNumber, false), magicNumber));\n    }\n\n    //Upgraded stats.\n    @Override\n    public void upgrade() {\n    }\n\n    public AbstractCard makeCopy() {\n        return new MementoCard();\n    }\n}", "class_id": 0, "repo": "Stanek-K/EvilWithin", "file": "src/main/java/hermit/cards/MementoCard.java", "last_update_at": "2020-01-22T19:08:45+00:00", "question_id": "eccc474756cb7236c86b3ffef8df5b704d96b430", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MementoCard extends AbstractDynamicCard {\n    // TEXT DECLARATION\n    public static final String ID = HermitMod.makeID(MementoCard.class.getSimpleName());\n    public static final String IMG = makeCardPath(\"memento.png\");\n    // /TEXT DECLARATION/\n    // STAT DECLARATION\n    private static final CardRarity RARITY = CardRarity.SPECIAL;\n    private static final CardTarget TARGET = CardTarget.ALL;\n    private static final CardType TYPE = CardType.CURSE;\n    public static final CardColor COLOR = CardColor.CURSE;\n    private static final CardStrings cardStrings = CardCrawlGame.languagePack.getCardStrings(ID);\n    public static final String UPGRADE_DESCRIPTION = cardStrings.UPGRADE_DESCRIPTION;\n    private static final int MAGIC_NUMBER = 1;\n    private static final int COST = 0;\n    // /STAT DECLARATION/\n    public MementoCard() {\n        super(ID, IMG, COST, TYPE, COLOR, RARITY, TARGET);\n        baseMagicNumber = magicNumber = MAGIC_NUMBER;\n        this.selfRetain = true;\n        loadJokeCardImage(this, \"memento.png\");\n    }\n    public void use(AbstractPlayer p, AbstractMonster m) {\n        Iterator var4 = AbstractDungeon.getCurrRoom().monsters.monsters.iterator();\n        while(var4.hasNext()) {\n            AbstractMonster mo = (AbstractMonster)var4.next();\n            this.addToBot(new ApplyPowerAction(mo, p, new VulnerablePower(mo, magicNumber, false), magicNumber, true, AbstractGameAction.AttackEffect.NONE));\n            if (this.upgraded)\n            this.addToBot(new ApplyPowerAction(mo, p, new WeakPower(mo, magicNumber, false), magicNumber, true, AbstractGameAction.AttackEffect.NONE));\n        }\n        this.addToBot(new ApplyPowerAction(p, p, new VulnerablePower(p, magicNumber, false), magicNumber));\n        if (this.upgraded)\n        this.addToBot(new ApplyPowerAction(p, p, new WeakPower(p, magicNumber, false), magicNumber));\n    }\n    //Upgraded stats.\n    @Override\n    public void upgrade() {\n    }\n    public AbstractCard makeCopy() {\n        return new MementoCard();\n    }\n"]]}
{"hexsha": "632ead9166a319d9e1e3bfe928eeda51d32e4da2", "ext": "java", "lang": "Java", "content": "@Preamble(description = \"Model for a device enrollment denial.\")\n@SuppressWarnings(\"PMD.AvoidDuplicateLiterals\")\npublic class DeviceEnrollmentDenial implements SdkModel {\n    /**\n     * Serialisation Id.\n     */\n    private static final long serialVersionUID = 3114354744522935L;\n\n    /**\n     * account id.\n     */\n    private final String accountId;\n\n    /**\n     * date on which the failed bootstrap was attempted on.\n     */\n    private final Date createdAt;\n\n    /**\n     * endpoint name.\n     */\n    private final String endpointName;\n\n    /**\n     * id of the recorded failed bootstrap attempt.\n     */\n    private String id;\n\n    /**\n     * Trusted certificate id.\n     */\n    private final String trustedCertificateId;\n\n    /**\n     * Internal constructor.\n     * \n     * <p>\n     * Constructor based on all fields.\n     * <p>\n     * Note: Should not be used. Use {@link #DeviceEnrollmentDenial()} instead.\n     * \n     * @param accountId\n     *            account id.\n     * @param createdAt\n     *            date on which the failed bootstrap was attempted on.\n     * @param endpointName\n     *            endpoint name.\n     * @param id\n     *            id of the recorded failed bootstrap attempt.\n     * @param trustedCertificateId\n     *            Trusted certificate id.\n     */\n    @Internal\n    public DeviceEnrollmentDenial(String accountId, Date createdAt, String endpointName, String id,\n                                  String trustedCertificateId) {\n        super();\n        this.accountId = accountId;\n        this.createdAt = createdAt;\n        this.endpointName = endpointName;\n        this.trustedCertificateId = trustedCertificateId;\n        setId(id);\n    }\n\n    /**\n     * Internal constructor.\n     * \n     * <p>\n     * Constructor based on a similar object.\n     * <p>\n     * Note: Should not be used. Use {@link #DeviceEnrollmentDenial()} instead.\n     * \n     * @param deviceEnrollmentDenial\n     *            a device enrollment denial.\n     */\n    @Internal\n    public DeviceEnrollmentDenial(DeviceEnrollmentDenial deviceEnrollmentDenial) {\n        this(deviceEnrollmentDenial == null ? (String) null : deviceEnrollmentDenial.accountId,\n             deviceEnrollmentDenial == null ? new Date() : deviceEnrollmentDenial.createdAt,\n             deviceEnrollmentDenial == null ? (String) null : deviceEnrollmentDenial.endpointName,\n             deviceEnrollmentDenial == null ? (String) null : deviceEnrollmentDenial.id,\n             deviceEnrollmentDenial == null ? (String) null : deviceEnrollmentDenial.trustedCertificateId);\n    }\n\n    /**\n     * Constructor.\n     */\n    public DeviceEnrollmentDenial() {\n        this((String) null, new Date(), (String) null, (String) null, (String) null);\n    }\n\n    /**\n     * Constructor.\n     * \n     * <p>\n     * Constructor based on object identifier.\n     * <p>\n     * \n     * @param id\n     *            id of the recorded failed bootstrap attempt.\n     */\n    public DeviceEnrollmentDenial(String id) {\n        this();\n        setId(id);\n    }\n\n    /**\n     * Internal constructor.\n     * \n     * <p>\n     * Constructor based on read-only fields.\n     * <p>\n     * Note: Should not be used. Use {@link #DeviceEnrollmentDenial()} instead.\n     * \n     * @param accountId\n     *            account id.\n     * @param createdAt\n     *            date on which the failed bootstrap was attempted on.\n     * @param endpointName\n     *            endpoint name.\n     * @param trustedCertificateId\n     *            Trusted certificate id.\n     */\n    @Internal\n    public DeviceEnrollmentDenial(String accountId, Date createdAt, String endpointName, String trustedCertificateId) {\n        this(accountId, createdAt, endpointName, (String) null, trustedCertificateId);\n    }\n\n    /**\n     * Gets account id.\n     * \n     * @return accountId\n     */\n    public String getAccountId() {\n        return accountId;\n    }\n\n    /**\n     * Gets date on which the failed bootstrap was attempted on.\n     * \n     * @return createdAt\n     */\n    public Date getCreatedAt() {\n        return createdAt;\n    }\n\n    /**\n     * Gets endpoint name.\n     * \n     * @return endpointName\n     */\n    public String getEndpointName() {\n        return endpointName;\n    }\n\n    /**\n     * Gets id of the recorded failed bootstrap attempt.\n     * \n     * @return id\n     */\n    @Override\n    public String getId() {\n        return id;\n    }\n\n    /**\n     * Sets id of the recorded failed bootstrap attempt.\n     * \n     * <p>\n     * Note: the length of the string has to match {@code /[a-f0-9]{32}/} to be valid\n     * \n     * @param id\n     *            id of the recorded failed bootstrap attempt.\n     */\n    @Override\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    /**\n     * Sets id of the recorded failed bootstrap attempt.\n     * \n     * <p>\n     * Similar to {@link #setId(String)}\n     * <p>\n     * Note: the length of the string has to match {@code /[a-f0-9]{32}/} to be valid\n     * \n     * @param deviceEnrollmentDenialId\n     *            id of the recorded failed bootstrap attempt.\n     */\n    @Internal\n    public void setDeviceEnrollmentDenialId(String deviceEnrollmentDenialId) {\n        setId(deviceEnrollmentDenialId);\n    }\n\n    /**\n     * Checks whether id value is valid.\n     * \n     * @return true if the value is valid; false otherwise.\n     */\n    @SuppressWarnings(\"PMD.UselessParentheses\")\n    public boolean isIdValid() {\n        return (id == null || id.matches(\"[a-f0-9]{32}\"));\n    }\n\n    /**\n     * Gets trusted certificate id.\n     * \n     * @return trustedCertificateId\n     */\n    public String getTrustedCertificateId() {\n        return trustedCertificateId;\n    }\n\n    /**\n     * Returns a string representation of the object.\n     * \n     * <p>\n     * \n     * @see java.lang.Object#toString()\n     * @return the string representation\n     */\n    @Override\n    public String toString() {\n        return \"DeviceEnrollmentDenial [accountId=\" + accountId + \", createdAt=\" + createdAt + \", endpointName=\"\n               + endpointName + \", id=\" + id + \", trustedCertificateId=\" + trustedCertificateId + \"]\";\n    }\n\n    /**\n     * Calculates the hash code of this instance based on field values.\n     * \n     * <p>\n     * \n     * @see java.lang.Object#hashCode()\n     * @return hash code\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((accountId == null) ? 0 : accountId.hashCode());\n        result = prime * result + ((createdAt == null) ? 0 : createdAt.hashCode());\n        result = prime * result + ((endpointName == null) ? 0 : endpointName.hashCode());\n        result = prime * result + ((id == null) ? 0 : id.hashCode());\n        result = prime * result + ((trustedCertificateId == null) ? 0 : trustedCertificateId.hashCode());\n        return result;\n    }\n\n    /**\n     * Method to ensure {@link #equals(Object)} is correct.\n     * \n     * <p>\n     * Note: see this article: <a href=\"https://www.artima.com/lejava/articles/equality.html\">canEqual()</a>\n     * \n     * @param other\n     *            another object.\n     * @return true if the other object is an instance of the class in which canEqual is (re)defined, false otherwise.\n     */\n    protected boolean canEqual(Object other) {\n        return other instanceof DeviceEnrollmentDenial;\n    }\n\n    /**\n     * Indicates whether some other object is \"equal to\" this one.\n     * \n     * <p>\n     * \n     * @see java.lang.Object#equals(java.lang.Object)\n     * @param obj\n     *            an object to compare with this instance.\n     * @return true if this object is the same as the obj argument; false otherwise.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof DeviceEnrollmentDenial)) {\n            return false;\n        }\n        final DeviceEnrollmentDenial other = (DeviceEnrollmentDenial) obj;\n        if (!other.canEqual(this)) {\n            return false;\n        }\n        if (accountId == null) {\n            if (other.accountId != null) {\n                return false;\n            }\n        } else if (!accountId.equals(other.accountId)) {\n            return false;\n        }\n        if (createdAt == null) {\n            if (other.createdAt != null) {\n                return false;\n            }\n        } else if (!createdAt.equals(other.createdAt)) {\n            return false;\n        }\n        if (endpointName == null) {\n            if (other.endpointName != null) {\n                return false;\n            }\n        } else if (!endpointName.equals(other.endpointName)) {\n            return false;\n        }\n        if (id == null) {\n            if (other.id != null) {\n                return false;\n            }\n        } else if (!id.equals(other.id)) {\n            return false;\n        }\n        if (trustedCertificateId == null) {\n            if (other.trustedCertificateId != null) {\n                return false;\n            }\n        } else if (!trustedCertificateId.equals(other.trustedCertificateId)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Checks whether the model is valid or not.\n     * \n     * <p>\n     * \n     * @see SdkModel#isValid()\n     * @return true if the model is valid; false otherwise.\n     */\n    @Override\n    public boolean isValid() {\n        return isIdValid();\n    }\n\n    /**\n     * Clones this instance.\n     * \n     * <p>\n     * \n     * @see java.lang.Object#clone()\n     * @return a cloned instance\n     */\n    @Override\n    public DeviceEnrollmentDenial clone() {\n        return new DeviceEnrollmentDenial(this);\n    }\n}", "class_id": 0, "repo": "PelionIoT/mbed-cloud-sdk-java", "file": "foundation-models/src/main/java/com/arm/mbed/cloud/sdk/devices/model/DeviceEnrollmentDenial.java", "last_update_at": "2020-03-23T19:15:31+00:00", "question_id": "632ead9166a319d9e1e3bfe928eeda51d32e4da2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Preamble(description = \"Model for a device enrollment denial.\")\n@SuppressWarnings(\"PMD.AvoidDuplicateLiterals\")\npublic class DeviceEnrollmentDenial implements SdkModel {\n    /**\n     * Serialisation Id.\n     */\n    private static final long serialVersionUID = 3114354744522935L;\n    /**\n     * account id.\n     */\n    private final String accountId;\n    /**\n     * date on which the failed bootstrap was attempted on.\n     */\n    private final Date createdAt;\n    /**\n     * endpoint name.\n     */\n    private final String endpointName;\n    /**\n     * id of the recorded failed bootstrap attempt.\n     */\n    private String id;\n    /**\n     * Trusted certificate id.\n     */\n    private final String trustedCertificateId;\n    /**\n     * Internal constructor.\n     * \n     * <p>\n     * Constructor based on all fields.\n     * <p>\n     * Note: Should not be used. Use {@link #DeviceEnrollmentDenial()} instead.\n     * \n     * @param accountId\n     *            account id.\n     * @param createdAt\n     *            date on which the failed bootstrap was attempted on.\n     * @param endpointName\n     *            endpoint name.\n     * @param id\n     *            id of the recorded failed bootstrap attempt.\n     * @param trustedCertificateId\n     *            Trusted certificate id.\n     */\n    @Internal\n    public DeviceEnrollmentDenial(String accountId, Date createdAt, String endpointName, String id,\n                                  String trustedCertificateId) {\n        super();\n        this.accountId = accountId;\n        this.createdAt = createdAt;\n        this.endpointName = endpointName;\n        this.trustedCertificateId = trustedCertificateId;\n        setId(id);\n    }\n    /**\n     * Internal constructor.\n     * \n     * <p>\n     * Constructor based on a similar object.\n     * <p>\n     * Note: Should not be used. Use {@link #DeviceEnrollmentDenial()} instead.\n     * \n     * @param deviceEnrollmentDenial\n     *            a device enrollment denial.\n     */\n    @Internal\n    public DeviceEnrollmentDenial(DeviceEnrollmentDenial deviceEnrollmentDenial) {\n        this(deviceEnrollmentDenial == null ? (String) null : deviceEnrollmentDenial.accountId,\n             deviceEnrollmentDenial == null ? new Date() : deviceEnrollmentDenial.createdAt,\n             deviceEnrollmentDenial == null ? (String) null : deviceEnrollmentDenial.endpointName,\n             deviceEnrollmentDenial == null ? (String) null : deviceEnrollmentDenial.id,\n             deviceEnrollmentDenial == null ? (String) null : deviceEnrollmentDenial.trustedCertificateId);\n    }\n    /**\n     * Constructor.\n     */\n    public DeviceEnrollmentDenial() {\n        this((String) null, new Date(), (String) null, (String) null, (String) null);\n    }\n    /**\n     * Constructor.\n     * \n     * <p>\n     * Constructor based on object identifier.\n     * <p>\n     * \n     * @param id\n     *            id of the recorded failed bootstrap attempt.\n     */\n    public DeviceEnrollmentDenial(String id) {\n        this();\n        setId(id);\n    }\n    /**\n     * Internal constructor.\n     * \n     * <p>\n     * Constructor based on read-only fields.\n     * <p>\n     * Note: Should not be used. Use {@link #DeviceEnrollmentDenial()} instead.\n     * \n     * @param accountId\n     *            account id.\n     * @param createdAt\n     *            date on which the failed bootstrap was attempted on.\n     * @param endpointName\n     *            endpoint name.\n     * @param trustedCertificateId\n     *            Trusted certificate id.\n     */\n    @Internal\n    public DeviceEnrollmentDenial(String accountId, Date createdAt, String endpointName, String trustedCertificateId) {\n        this(accountId, createdAt, endpointName, (String) null, trustedCertificateId);\n    }\n    /**\n     * Gets account id.\n     * \n     * @return accountId\n     */\n    public String getAccountId() {\n        return accountId;\n    }\n    /**\n     * Gets date on which the failed bootstrap was attempted on.\n     * \n     * @return createdAt\n     */\n    public Date getCreatedAt() {\n        return createdAt;\n    }\n    /**\n     * Gets endpoint name.\n     * \n     * @return endpointName\n     */\n    public String getEndpointName() {\n        return endpointName;\n    }\n    /**\n     * Gets id of the recorded failed bootstrap attempt.\n     * \n     * @return id\n     */\n    @Override\n    public String getId() {\n        return id;\n    }\n    /**\n     * Sets id of the recorded failed bootstrap attempt.\n     * \n     * <p>\n     * Note: the length of the string has to match {@code /[a-f0-9]{32}/} to be valid\n     * \n     * @param id\n     *            id of the recorded failed bootstrap attempt.\n     */\n    @Override\n    public void setId(String id) {\n        this.id = id;\n    }\n    /**\n     * Sets id of the recorded failed bootstrap attempt.\n     * \n     * <p>\n     * Similar to {@link #setId(String)}\n     * <p>\n     * Note: the length of the string has to match {@code /[a-f0-9]{32}/} to be valid\n     * \n     * @param deviceEnrollmentDenialId\n     *            id of the recorded failed bootstrap attempt.\n     */\n    @Internal\n    public void setDeviceEnrollmentDenialId(String deviceEnrollmentDenialId) {\n        setId(deviceEnrollmentDenialId);\n    }\n    /**\n     * Checks whether id value is valid.\n     * \n     * @return true if the value is valid; false otherwise.\n     */\n    @SuppressWarnings(\"PMD.UselessParentheses\")\n    public boolean isIdValid() {\n        return (id == null || id.matches(\"[a-f0-9]{32}\"));\n    }\n    /**\n     * Gets trusted certificate id.\n     * \n     * @return trustedCertificateId\n     */\n    public String getTrustedCertificateId() {\n        return trustedCertificateId;\n    }\n    /**\n     * Returns a string representation of the object.\n     * \n     * <p>\n     * \n     * @see java.lang.Object#toString()\n     * @return the string representation\n     */\n    @Override\n    public String toString() {\n        return \"DeviceEnrollmentDenial [accountId=\" + accountId + \", createdAt=\" + createdAt + \", endpointName=\"\n               + endpointName + \", id=\" + id + \", trustedCertificateId=\" + trustedCertificateId + \"]\";\n    }\n    /**\n     * Calculates the hash code of this instance based on field values.\n     * \n     * <p>\n     * \n     * @see java.lang.Object#hashCode()\n     * @return hash code\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((accountId == null) ? 0 : accountId.hashCode());\n        result = prime * result + ((createdAt == null) ? 0 : createdAt.hashCode());\n        result = prime * result + ((endpointName == null) ? 0 : endpointName.hashCode());\n        result = prime * result + ((id == null) ? 0 : id.hashCode());\n        result = prime * result + ((trustedCertificateId == null) ? 0 : trustedCertificateId.hashCode());\n        return result;\n    }\n    /**\n     * Method to ensure {@link #equals(Object)} is correct.\n     * \n     * <p>\n     * Note: see this article: <a href=\"https://www.artima.com/lejava/articles/equality.html\">canEqual()</a>\n     * \n     * @param other\n     *            another object.\n     * @return true if the other object is an instance of the class in which canEqual is (re)defined, false otherwise.\n     */\n    protected boolean canEqual(Object other) {\n        return other instanceof DeviceEnrollmentDenial;\n    }\n    /**\n     * Indicates whether some other object is \"equal to\" this one.\n     * \n     * <p>\n     * \n     * @see java.lang.Object#equals(java.lang.Object)\n     * @param obj\n     *            an object to compare with this instance.\n     * @return true if this object is the same as the obj argument; false otherwise.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof DeviceEnrollmentDenial)) {\n            return false;\n        }\n        final DeviceEnrollmentDenial other = (DeviceEnrollmentDenial) obj;\n        if (!other.canEqual(this)) {\n            return false;\n        }\n        if (accountId == null) {\n            if (other.accountId != null) {\n                return false;\n            }\n        } else if (!accountId.equals(other.accountId)) {\n            return false;\n        }\n        if (createdAt == null) {\n            if (other.createdAt != null) {\n                return false;\n            }\n        } else if (!createdAt.equals(other.createdAt)) {\n            return false;\n        }\n        if (endpointName == null) {\n            if (other.endpointName != null) {\n                return false;\n            }\n        } else if (!endpointName.equals(other.endpointName)) {\n            return false;\n        }\n        if (id == null) {\n            if (other.id != null) {\n                return false;\n            }\n        } else if (!id.equals(other.id)) {\n            return false;\n        }\n        if (trustedCertificateId == null) {\n            if (other.trustedCertificateId != null) {\n                return false;\n            }\n        } else if (!trustedCertificateId.equals(other.trustedCertificateId)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Checks whether the model is valid or not.\n     * \n     * <p>\n     * \n     * @see SdkModel#isValid()\n     * @return true if the model is valid; false otherwise.\n     */\n    @Override\n    public boolean isValid() {\n        return isIdValid();\n    }\n    /**\n     * Clones this instance.\n     * \n     * <p>\n     * \n     * @see java.lang.Object#clone()\n     * @return a cloned instance\n     */\n    @Override\n    public DeviceEnrollmentDenial clone() {\n        return new DeviceEnrollmentDenial(this);\n    }\n"]]}
{"hexsha": "efd9da203f471c3da15bb7565eaf8e1de5d1eb19", "ext": "java", "lang": "Java", "content": "public class VitaminManager extends Functions\n{\n\tprivate static final int PetCoupon = 13273;\n\tprivate static final int SpecialPetCoupon = 14065;\n\n\tprivate static final int WeaselNeck = 13017;\n\tprivate static final int PrincNeck = 13018;\n\tprivate static final int BeastNeck = 13019;\n\tprivate static final int FoxNeck = 13020;\n\n\tprivate static final int KnightNeck = 13548;\n\tprivate static final int SpiritNeck = 13549;\n\tprivate static final int OwlNeck = 13550;\n\tprivate static final int TurtleNeck = 13551;\n\n\tpublic void giveWeasel()\n\t{\n\t\tPlayer player = getSelf();\n\t\tNpcInstance npc = getNpc();\n\n\t\tString htmltext;\n\t\tif (getItemCount(player, PetCoupon) > 0)\n\t\t{\n\t\t\tremoveItem(player, PetCoupon, 1, \"VitaminManager\");\n\t\t\taddItem(player, WeaselNeck, 1, \"VitaminManager\");\n\t\t\thtmltext = npc.getNpcId() + \"-ok.htm\";\n\t\t}\n\t\telse\n\t\t\thtmltext = npc.getNpcId() + \"-no.htm\";\n\n\t\tnpc.showChatWindow(player, \"default/\" + htmltext);\n\t}\n\n\tpublic void givePrinc()\n\t{\n\t\tPlayer player = getSelf();\n\t\tNpcInstance npc = getNpc();\n\n\t\tString htmltext;\n\t\tif (getItemCount(player, PetCoupon) > 0)\n\t\t{\n\t\t\tremoveItem(player, PetCoupon, 1, \"givePrinc\");\n\t\t\taddItem(player, PrincNeck, 1, \"givePrinc\");\n\t\t\thtmltext = npc.getNpcId() + \"-ok.htm\";\n\t\t}\n\t\telse\n\t\t\thtmltext = npc.getNpcId() + \"-no.htm\";\n\n\t\tnpc.showChatWindow(player, \"default/\" + htmltext);\n\t}\n\n\tpublic void giveBeast()\n\t{\n\t\tPlayer player = getSelf();\n\t\tNpcInstance npc = getNpc();\n\n\t\tString htmltext;\n\t\tif (getItemCount(player, PetCoupon) > 0)\n\t\t{\n\t\t\tremoveItem(player, PetCoupon, 1, \"giveBeast\");\n\t\t\taddItem(player, BeastNeck, 1, \"giveBeast\");\n\t\t\thtmltext = npc.getNpcId() + \"-ok.htm\";\n\t\t}\n\t\telse\n\t\t\thtmltext = npc.getNpcId() + \"-no.htm\";\n\n\t\tnpc.showChatWindow(player, \"default/\" + htmltext);\n\t}\n\n\tpublic void giveFox()\n\t{\n\t\tPlayer player = getSelf();\n\t\tNpcInstance npc = getNpc();\n\n\t\tString htmltext;\n\t\tif (getItemCount(player, PetCoupon) > 0)\n\t\t{\n\t\t\tremoveItem(player, PetCoupon, 1, \"giveFox\");\n\t\t\taddItem(player, FoxNeck, 1, \"giveFox\");\n\t\t\thtmltext = npc.getNpcId() + \"-ok.htm\";\n\t\t}\n\t\telse\n\t\t\thtmltext = npc.getNpcId() + \"-no.htm\";\n\n\t\tnpc.showChatWindow(player, \"default/\" + htmltext);\n\t}\n\n\tpublic void giveKnight()\n\t{\n\t\tPlayer player = getSelf();\n\t\tNpcInstance npc = getNpc();\n\n\t\tString htmltext;\n\t\tif (getItemCount(player, SpecialPetCoupon) > 0)\n\t\t{\n\t\t\tremoveItem(player, SpecialPetCoupon, 1, \"giveKnight\");\n\t\t\taddItem(player, KnightNeck, 1, \"giveKnight\");\n\t\t\thtmltext = npc.getNpcId() + \"-ok.htm\";\n\t\t}\n\t\telse\n\t\t\thtmltext = npc.getNpcId() + \"-no.htm\";\n\n\t\tnpc.showChatWindow(player, \"default/\" + htmltext);\n\t}\n\n\tpublic void giveSpirit()\n\t{\n\t\tPlayer player = getSelf();\n\t\tNpcInstance npc = getNpc();\n\n\t\tString htmltext;\n\t\tif (getItemCount(player, SpecialPetCoupon) > 0)\n\t\t{\n\t\t\tremoveItem(player, SpecialPetCoupon, 1, \"giveSpirit\");\n\t\t\taddItem(player, SpiritNeck, 1, \"giveSpirit\");\n\t\t\thtmltext = npc.getNpcId() + \"-ok.htm\";\n\t\t}\n\t\telse\n\t\t\thtmltext = npc.getNpcId() + \"-no.htm\";\n\n\t\tnpc.showChatWindow(player, \"default/\" + htmltext);\n\t}\n\n\tpublic void giveOwl()\n\t{\n\t\tPlayer player = getSelf();\n\t\tNpcInstance npc = getNpc();\n\n\t\tString htmltext;\n\t\tif (getItemCount(player, SpecialPetCoupon) > 0)\n\t\t{\n\t\t\tremoveItem(player, SpecialPetCoupon, 1, \"giveOwl\");\n\t\t\taddItem(player, OwlNeck, 1, \"giveOwl\");\n\t\t\thtmltext = npc.getNpcId() + \"-ok.htm\";\n\t\t}\n\t\telse\n\t\t\thtmltext = npc.getNpcId() + \"-no.htm\";\n\n\t\tnpc.showChatWindow(player, \"default/\" + htmltext);\n\t}\n\n\tpublic void giveTurtle()\n\t{\n\t\tPlayer player = getSelf();\n\t\tNpcInstance npc = getNpc();\n\n\t\tString htmltext;\n\t\tif (getItemCount(player, SpecialPetCoupon) > 0)\n\t\t{\n\t\t\tremoveItem(player, SpecialPetCoupon, 1, \"giveTurtle\");\n\t\t\taddItem(player, TurtleNeck, 1, \"giveTurtle\");\n\t\t\thtmltext = npc.getNpcId() + \"-ok.htm\";\n\t\t}\n\t\telse\n\t\t\thtmltext = npc.getNpcId() + \"-no.htm\";\n\n\t\tnpc.showChatWindow(player, \"default/\" + htmltext);\n\t}\n}", "class_id": 0, "repo": "Arodev76/L2Advanced", "file": "dist/gameserver/data/scripts/services/VitaminManager.java", "last_update_at": "2020-08-06T06:35:54+00:00", "question_id": "efd9da203f471c3da15bb7565eaf8e1de5d1eb19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class VitaminManager extends Functions\n{\n\tprivate static final int PetCoupon = 13273;\n\tprivate static final int SpecialPetCoupon = 14065;\n\tprivate static final int WeaselNeck = 13017;\n\tprivate static final int PrincNeck = 13018;\n\tprivate static final int BeastNeck = 13019;\n\tprivate static final int FoxNeck = 13020;\n\tprivate static final int KnightNeck = 13548;\n\tprivate static final int SpiritNeck = 13549;\n\tprivate static final int OwlNeck = 13550;\n\tprivate static final int TurtleNeck = 13551;\n\tpublic void giveWeasel()\n\t{\n\t\tPlayer player = getSelf();\n\t\tNpcInstance npc = getNpc();\n\t\tString htmltext;\n\t\tif (getItemCount(player, PetCoupon) > 0)\n\t\t{\n\t\t\tremoveItem(player, PetCoupon, 1, \"VitaminManager\");\n\t\t\taddItem(player, WeaselNeck, 1, \"VitaminManager\");\n\t\t\thtmltext = npc.getNpcId() + \"-ok.htm\";\n\t\t}\n\t\telse\n\t\t\thtmltext = npc.getNpcId() + \"-no.htm\";\n\t\tnpc.showChatWindow(player, \"default/\" + htmltext);\n\t}\n\tpublic void givePrinc()\n\t{\n\t\tPlayer player = getSelf();\n\t\tNpcInstance npc = getNpc();\n\t\tString htmltext;\n\t\tif (getItemCount(player, PetCoupon) > 0)\n\t\t{\n\t\t\tremoveItem(player, PetCoupon, 1, \"givePrinc\");\n\t\t\taddItem(player, PrincNeck, 1, \"givePrinc\");\n\t\t\thtmltext = npc.getNpcId() + \"-ok.htm\";\n\t\t}\n\t\telse\n\t\t\thtmltext = npc.getNpcId() + \"-no.htm\";\n\t\tnpc.showChatWindow(player, \"default/\" + htmltext);\n\t}\n\tpublic void giveBeast()\n\t{\n\t\tPlayer player = getSelf();\n\t\tNpcInstance npc = getNpc();\n\t\tString htmltext;\n\t\tif (getItemCount(player, PetCoupon) > 0)\n\t\t{\n\t\t\tremoveItem(player, PetCoupon, 1, \"giveBeast\");\n\t\t\taddItem(player, BeastNeck, 1, \"giveBeast\");\n\t\t\thtmltext = npc.getNpcId() + \"-ok.htm\";\n\t\t}\n\t\telse\n\t\t\thtmltext = npc.getNpcId() + \"-no.htm\";\n\t\tnpc.showChatWindow(player, \"default/\" + htmltext);\n\t}\n\tpublic void giveFox()\n\t{\n\t\tPlayer player = getSelf();\n\t\tNpcInstance npc = getNpc();\n\t\tString htmltext;\n\t\tif (getItemCount(player, PetCoupon) > 0)\n\t\t{\n\t\t\tremoveItem(player, PetCoupon, 1, \"giveFox\");\n\t\t\taddItem(player, FoxNeck, 1, \"giveFox\");\n\t\t\thtmltext = npc.getNpcId() + \"-ok.htm\";\n\t\t}\n\t\telse\n\t\t\thtmltext = npc.getNpcId() + \"-no.htm\";\n\t\tnpc.showChatWindow(player, \"default/\" + htmltext);\n\t}\n\tpublic void giveKnight()\n\t{\n\t\tPlayer player = getSelf();\n\t\tNpcInstance npc = getNpc();\n\t\tString htmltext;\n\t\tif (getItemCount(player, SpecialPetCoupon) > 0)\n\t\t{\n\t\t\tremoveItem(player, SpecialPetCoupon, 1, \"giveKnight\");\n\t\t\taddItem(player, KnightNeck, 1, \"giveKnight\");\n\t\t\thtmltext = npc.getNpcId() + \"-ok.htm\";\n\t\t}\n\t\telse\n\t\t\thtmltext = npc.getNpcId() + \"-no.htm\";\n\t\tnpc.showChatWindow(player, \"default/\" + htmltext);\n\t}\n\tpublic void giveSpirit()\n\t{\n\t\tPlayer player = getSelf();\n\t\tNpcInstance npc = getNpc();\n\t\tString htmltext;\n\t\tif (getItemCount(player, SpecialPetCoupon) > 0)\n\t\t{\n\t\t\tremoveItem(player, SpecialPetCoupon, 1, \"giveSpirit\");\n\t\t\taddItem(player, SpiritNeck, 1, \"giveSpirit\");\n\t\t\thtmltext = npc.getNpcId() + \"-ok.htm\";\n\t\t}\n\t\telse\n\t\t\thtmltext = npc.getNpcId() + \"-no.htm\";\n\t\tnpc.showChatWindow(player, \"default/\" + htmltext);\n\t}\n\tpublic void giveOwl()\n\t{\n\t\tPlayer player = getSelf();\n\t\tNpcInstance npc = getNpc();\n\t\tString htmltext;\n\t\tif (getItemCount(player, SpecialPetCoupon) > 0)\n\t\t{\n\t\t\tremoveItem(player, SpecialPetCoupon, 1, \"giveOwl\");\n\t\t\taddItem(player, OwlNeck, 1, \"giveOwl\");\n\t\t\thtmltext = npc.getNpcId() + \"-ok.htm\";\n\t\t}\n\t\telse\n\t\t\thtmltext = npc.getNpcId() + \"-no.htm\";\n\t\tnpc.showChatWindow(player, \"default/\" + htmltext);\n\t}\n\tpublic void giveTurtle()\n\t{\n\t\tPlayer player = getSelf();\n\t\tNpcInstance npc = getNpc();\n\t\tString htmltext;\n\t\tif (getItemCount(player, SpecialPetCoupon) > 0)\n\t\t{\n\t\t\tremoveItem(player, SpecialPetCoupon, 1, \"giveTurtle\");\n\t\t\taddItem(player, TurtleNeck, 1, \"giveTurtle\");\n\t\t\thtmltext = npc.getNpcId() + \"-ok.htm\";\n\t\t}\n\t\telse\n\t\t\thtmltext = npc.getNpcId() + \"-no.htm\";\n\t\tnpc.showChatWindow(player, \"default/\" + htmltext);\n\t}\n"]]}
{"hexsha": "57867d7d465f26966deaba0e545a23f9d9edfd30", "ext": "java", "lang": "Java", "content": "public class SolutionTest {\n\n    @Test\n    public void intToRoman() {\n        Solution s =  new Solution();\n        assertEquals(\"III\", s.intToRoman(3));\n        assertEquals(\"IV\", s.intToRoman(4));\n        assertEquals(\"IX\", s.intToRoman(9));\n        assertEquals(\"LVIII\", s.intToRoman(58));\n        assertEquals(\"MCMXCIV\", s.intToRoman(1994));\n    }\n}", "class_id": 0, "repo": "shank3/algs-study", "file": "src/test/java/leetcode/page0/p012/SolutionTest.java", "last_update_at": "2020-10-13T13:23:34+00:00", "question_id": "57867d7d465f26966deaba0e545a23f9d9edfd30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SolutionTest {\n    @Test\n    public void intToRoman() {\n        Solution s =  new Solution();\n        assertEquals(\"III\", s.intToRoman(3));\n        assertEquals(\"IV\", s.intToRoman(4));\n        assertEquals(\"IX\", s.intToRoman(9));\n        assertEquals(\"LVIII\", s.intToRoman(58));\n        assertEquals(\"MCMXCIV\", s.intToRoman(1994));\n    }\n"]]}
{"hexsha": "31df0e4c199c6ad6811a1c4cf033a6a96ac3656d", "ext": "java", "lang": "Java", "content": "@SuppressWarnings(\"WeakerAccess\")\npublic class Fluentd extends Recorder implements SimpleBuildStep {\n    public static final String DEFAULT_LOGGER = \"Jenkins\";\n    public static final String DEFAULT_HOST = \"localhost\";\n    public static final int DEFAULT_PORT = 24224;\n\n    private static transient volatile FluentLogger fluentLogger;\n    private final String tag;\n    private final String json;\n    private final String fileName;\n    private final boolean failBuild;\n\n    @DataBoundConstructor\n    public Fluentd(String tag, boolean failBuild, String fileName, String json) {\n        this.tag = tag;\n        this.failBuild = failBuild;\n        this.fileName = fileName;\n        this.json = json;\n    }\n\n    @SuppressWarnings(\"unused\")\n    public String getTag() {\n        return tag;\n    }\n\n    @SuppressWarnings(\"unused\")\n    public String getFileName() {\n        return fileName;\n    }\n\n    @SuppressWarnings(\"unused\")\n    public String getJson() {\n        return json;\n    }\n\n    @SuppressWarnings(\"unused\")\n    public boolean isFailBuild() {\n        return failBuild;\n    }\n\n    @Override\n    public void perform(@Nonnull Run<?, ?> build, @Nonnull FilePath workspace, @Nonnull Launcher launcher, @Nonnull TaskListener listener) throws IOException, InterruptedException {\n        boolean succeed = false;\n\n        // TODO: Publish from slave if it's possible\n        if (fileName != null && !fileName.isEmpty()) {\n            final FilePath file = new FilePath(workspace, fileName);\n            if (file.exists()) {\n                succeed = send(json, file.readToString(), build, listener);\n            } else {\n                listener.error(\"File doesn't exist: \" + fileName);\n            }\n        } else {\n            succeed = send(json, \"{}\", build, listener);\n        }\n\n        if (!succeed && failBuild) {\n            build.setResult(Result.FAILURE);\n        }\n    }\n\n    private boolean send(String json, String jsonFromFile, @Nonnull Run<?, ?> build, @Nonnull TaskListener listener) throws InterruptedException {\n        final Map<String, String> envVars = getEnvVariables(build, listener);\n\n        try {\n            sendJson(getFluentLogger(), tag, envVars, json, jsonFromFile, build.getStartTimeInMillis());\n            return true;\n        } catch (IllegalArgumentException e) {\n            listener.error(e.getMessage());\n            e.printStackTrace(listener.getLogger());\n            return false;\n        }\n    }\n\n    private Map<String, String> getEnvVariables(@Nonnull Run<?, ?> build, @Nonnull TaskListener listener) throws InterruptedException {\n        Map<String, String> envVars;\n        try {\n            envVars = build.getEnvironment(listener);\n        } catch (IOException e) {\n            listener.error(\"Failed to get environment variables\");\n            e.printStackTrace(listener.getLogger());\n            envVars = new HashMap<>();\n        }\n        return envVars;\n    }\n\n    private FluentLogger getFluentLogger() {\n        if (fluentLogger == null) {\n            synchronized (Fluentd.class) {\n                if (fluentLogger == null) {\n                    final DescriptorImpl desc = getDescriptor();\n                    fluentLogger = FluentLogger.getLogger(desc.getLoggerName(), desc.getHost(), getDescriptor().getPort());\n                }\n            }\n        }\n        return fluentLogger;\n    }\n\n    @Override\n    public DescriptorImpl getDescriptor() {\n        return (DescriptorImpl) super.getDescriptor();\n    }\n\n    @Override\n    public BuildStepMonitor getRequiredMonitorService() {\n        return BuildStepMonitor.NONE;\n    }\n\n    /**\n     * Descriptor for {@link Fluentd}. Used as a singleton.\n     * The class is marked as public so that it can be accessed from views.\n     * <p>\n     * See <tt>src/main/resources/hudson/plugins/hello_world/Fluentd/*.jelly</tt>\n     * for the actual HTML fragment for the configuration screen.\n     */\n    @Extension\n    public static final class DescriptorImpl extends BuildStepDescriptor<Publisher> {\n        /**\n         * To persist global configuration information,\n         * simply store it in a field and call save().\n         * <p>\n         * <p>\n         * If you don't want fields to be persisted, use <tt>transient</tt>.\n         */\n        private String loggerName;\n        private String host;\n        private int port;\n\n        /**\n         * In order to load the persisted global configuration, you have to\n         * call load() in the constructor.\n         */\n        public DescriptorImpl() {\n            load();\n            if (port == 0) port = DEFAULT_PORT;\n            if (host == null || host.isEmpty()) host = DEFAULT_HOST;\n            if (loggerName == null || loggerName.isEmpty()) loggerName = DEFAULT_LOGGER;\n        }\n\n        @Override\n        public boolean isApplicable(Class<? extends AbstractProject> aClass) {\n            // Indicates that this builder can be used with all kinds of project types \n            return true;\n        }\n\n        /**\n         * This human readable name is used in the configuration screen.\n         */\n        @Override\n        public String getDisplayName() {\n            return \"Send to Fluentd\";\n        }\n\n        @Override\n        public boolean configure(StaplerRequest req, JSONObject formData) throws FormException {\n            loggerName = formData.optString(\"loggerName\", DEFAULT_LOGGER);\n            port = formData.optInt(\"port\", DEFAULT_PORT);\n            host = formData.optString(\"host\", DEFAULT_HOST);\n            save();\n            fluentLogger = null; // reset logger\n            return super.configure(req, formData);\n        }\n\n        public String getLoggerName() {\n            return loggerName;\n        }\n\n        public int getPort() {\n            return port;\n        }\n\n        public String getHost() {\n            return host;\n        }\n    }\n}", "class_id": 0, "repo": "JLLeitschuh/fluentd-plugin", "file": "src/main/java/org/jenkinsci/plugins/fluentd/Fluentd.java", "last_update_at": "2020-02-11T05:29:23+00:00", "question_id": "31df0e4c199c6ad6811a1c4cf033a6a96ac3656d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings(\"WeakerAccess\")\npublic class Fluentd extends Recorder implements SimpleBuildStep {\n    public static final String DEFAULT_LOGGER = \"Jenkins\";\n    public static final String DEFAULT_HOST = \"localhost\";\n    public static final int DEFAULT_PORT = 24224;\n    private static transient volatile FluentLogger fluentLogger;\n    private final String tag;\n    private final String json;\n    private final String fileName;\n    private final boolean failBuild;\n    @DataBoundConstructor\n    public Fluentd(String tag, boolean failBuild, String fileName, String json) {\n        this.tag = tag;\n        this.failBuild = failBuild;\n        this.fileName = fileName;\n        this.json = json;\n    }\n    @SuppressWarnings(\"unused\")\n    public String getTag() {\n        return tag;\n    }\n    @SuppressWarnings(\"unused\")\n    public String getFileName() {\n        return fileName;\n    }\n    @SuppressWarnings(\"unused\")\n    public String getJson() {\n        return json;\n    }\n    @SuppressWarnings(\"unused\")\n    public boolean isFailBuild() {\n        return failBuild;\n    }\n    @Override\n    public void perform(@Nonnull Run<?, ?> build, @Nonnull FilePath workspace, @Nonnull Launcher launcher, @Nonnull TaskListener listener) throws IOException, InterruptedException {\n        boolean succeed = false;\n        // TODO: Publish from slave if it's possible\n        if (fileName != null && !fileName.isEmpty()) {\n            final FilePath file = new FilePath(workspace, fileName);\n            if (file.exists()) {\n                succeed = send(json, file.readToString(), build, listener);\n            } else {\n                listener.error(\"File doesn't exist: \" + fileName);\n            }\n        } else {\n            succeed = send(json, \"{}\", build, listener);\n        }\n        if (!succeed && failBuild) {\n            build.setResult(Result.FAILURE);\n        }\n    }\n    private boolean send(String json, String jsonFromFile, @Nonnull Run<?, ?> build, @Nonnull TaskListener listener) throws InterruptedException {\n        final Map<String, String> envVars = getEnvVariables(build, listener);\n        try {\n            sendJson(getFluentLogger(), tag, envVars, json, jsonFromFile, build.getStartTimeInMillis());\n            return true;\n        } catch (IllegalArgumentException e) {\n            listener.error(e.getMessage());\n            e.printStackTrace(listener.getLogger());\n            return false;\n        }\n    }\n    private Map<String, String> getEnvVariables(@Nonnull Run<?, ?> build, @Nonnull TaskListener listener) throws InterruptedException {\n        Map<String, String> envVars;\n        try {\n            envVars = build.getEnvironment(listener);\n        } catch (IOException e) {\n            listener.error(\"Failed to get environment variables\");\n            e.printStackTrace(listener.getLogger());\n            envVars = new HashMap<>();\n        }\n        return envVars;\n    }\n    private FluentLogger getFluentLogger() {\n        if (fluentLogger == null) {\n            synchronized (Fluentd.class) {\n                if (fluentLogger == null) {\n                    final DescriptorImpl desc = getDescriptor();\n                    fluentLogger = FluentLogger.getLogger(desc.getLoggerName(), desc.getHost(), getDescriptor().getPort());\n                }\n            }\n        }\n        return fluentLogger;\n    }\n    @Override\n    public DescriptorImpl getDescriptor() {\n        return (DescriptorImpl) super.getDescriptor();\n    }\n    @Override\n    public BuildStepMonitor getRequiredMonitorService() {\n        return BuildStepMonitor.NONE;\n    }\n    /**\n     * Descriptor for {@link Fluentd}. Used as a singleton.\n     * The class is marked as public so that it can be accessed from views.\n     * <p>\n     * See <tt>src/main/resources/hudson/plugins/hello_world/Fluentd/*.jelly</tt>\n     * for the actual HTML fragment for the configuration screen.\n     */\n    @Extension\n    public static final class DescriptorImpl extends BuildStepDescriptor<Publisher> {\n        /**\n         * To persist global configuration information,\n         * simply store it in a field and call save().\n         * <p>\n         * <p>\n         * If you don't want fields to be persisted, use <tt>transient</tt>.\n         */\n        private String loggerName;\n        private String host;\n        private int port;\n        /**\n         * In order to load the persisted global configuration, you have to\n         * call load() in the constructor.\n         */\n        public DescriptorImpl() {\n            load();\n            if (port == 0) port = DEFAULT_PORT;\n            if (host == null || host.isEmpty()) host = DEFAULT_HOST;\n            if (loggerName == null || loggerName.isEmpty()) loggerName = DEFAULT_LOGGER;\n        }\n        @Override\n        public boolean isApplicable(Class<? extends AbstractProject> aClass) {\n            // Indicates that this builder can be used with all kinds of project types \n            return true;\n        }\n        /**\n         * This human readable name is used in the configuration screen.\n         */\n        @Override\n        public String getDisplayName() {\n            return \"Send to Fluentd\";\n        }\n        @Override\n        public boolean configure(StaplerRequest req, JSONObject formData) throws FormException {\n            loggerName = formData.optString(\"loggerName\", DEFAULT_LOGGER);\n            port = formData.optInt(\"port\", DEFAULT_PORT);\n            host = formData.optString(\"host\", DEFAULT_HOST);\n            save();\n            fluentLogger = null; // reset logger\n            return super.configure(req, formData);\n        }\n        public String getLoggerName() {\n            return loggerName;\n        }\n        public int getPort() {\n            return port;\n        }\n        public String getHost() {\n            return host;\n        }\n    }\n"]]}
{"hexsha": "56d0ea3a37b86c8af344ad03a46204cd51be8247", "ext": "java", "lang": "Java", "content": "public class MessageListItem extends RelativeLayout{\n\n\tprivate ImageView mBadgeImageView;\n\t\n\tpublic MessageListItem(Context context, AttributeSet attributeSet, int defStyle) {\n\t\tsuper(context, attributeSet, defStyle);\n\t}\n\t\n\tpublic MessageListItem(Context context, Notification notification) {\n\t\tsuper(context);\n\t\tinitLayout(notification);\n\t}\n\t\n\tprivate void initLayout(Notification notification) {\n\t\tView v = View.inflate(getContext(), R.layout.message_list_item, this);\n\t    mBadgeImageView = (ImageView)v.findViewById(R.id.message_list_item_batch);\n\t    enableBatch(false);\n\t}\n\t\n\tpublic void enableBatch(boolean b) {\n\t\tmBadgeImageView.setVisibility(b ? View.VISIBLE:View.GONE);\n\t}\n\n}", "class_id": 0, "repo": "zoozooll/MyExercise", "file": "meep/MeepNotificationCenter/src/com/oregonscientific/meep/notification/view/MessageListItem.java", "last_update_at": "2020-08-06T06:24:06+00:00", "question_id": "56d0ea3a37b86c8af344ad03a46204cd51be8247", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MessageListItem extends RelativeLayout{\n\tprivate ImageView mBadgeImageView;\n\t\n\tpublic MessageListItem(Context context, AttributeSet attributeSet, int defStyle) {\n\t\tsuper(context, attributeSet, defStyle);\n\t}\n\t\n\tpublic MessageListItem(Context context, Notification notification) {\n\t\tsuper(context);\n\t\tinitLayout(notification);\n\t}\n\t\n\tprivate void initLayout(Notification notification) {\n\t\tView v = View.inflate(getContext(), R.layout.message_list_item, this);\n\t    mBadgeImageView = (ImageView)v.findViewById(R.id.message_list_item_batch);\n\t    enableBatch(false);\n\t}\n\t\n\tpublic void enableBatch(boolean b) {\n\t\tmBadgeImageView.setVisibility(b ? View.VISIBLE:View.GONE);\n\t}\n"]]}
{"hexsha": "910ae74fd7d5dace25c08978011bbbc12a5ca114", "ext": "java", "lang": "Java", "content": "public class ProfileManagerTest {\n\n    private ProfileManager profileManager = new ProfileManager();\n\n    @Test\n    public void constructor() {\n        assertEquals(new UserPrefs(), profileManager.getUserPrefs());\n        assertEquals(new GuiSettings(), profileManager.getGuiSettings());\n        assertEquals(new ProfileList(), profileManager.getProfileList());\n    }\n\n    @Test\n    public void setUserPrefs_nullUserPrefs_throwsNullPointerException() {\n        assertThrows(NullPointerException.class, () -> profileManager.setUserPrefs(null));\n    }\n\n    @Test\n    public void setUserPrefs_validUserPrefs_copiesUserPrefs() {\n        UserPrefs userPrefs = new UserPrefs();\n        userPrefs.setAddressBookFilePath(Paths.get(\"address/book/file/path\"));\n        userPrefs.setGuiSettings(new GuiSettings(1, 2, 3, 4));\n        profileManager.setUserPrefs(userPrefs);\n        assertEquals(userPrefs, profileManager.getUserPrefs());\n\n        // Modifying userPrefs should not modify profileManager's userPrefs\n        UserPrefs oldUserPrefs = new UserPrefs(userPrefs);\n        userPrefs.setAddressBookFilePath(Paths.get(\"new/address/book/file/path\"));\n        assertEquals(oldUserPrefs, profileManager.getUserPrefs());\n    }\n\n    @Test\n    public void setGuiSettings_nullGuiSettings_throwsNullPointerException() {\n        assertThrows(NullPointerException.class, () -> profileManager.setGuiSettings(null));\n    }\n\n    @Test\n    public void setGuiSettings_validGuiSettings_setsGuiSettings() {\n        GuiSettings guiSettings = new GuiSettings(1, 2, 3, 4);\n        profileManager.setGuiSettings(guiSettings);\n        assertEquals(guiSettings, profileManager.getGuiSettings());\n    }\n\n    @Test\n    public void setProfileListFilePath_nullPath_throwsNullPointerException() {\n        assertThrows(NullPointerException.class, () -> profileManager.setProfileListFilePath(null));\n    }\n\n    @Test\n    public void setProfileListFilePath_validPath_setsAddressBookFilePath() {\n        Path path = Paths.get(\"address/book/file/path\");\n        profileManager.setProfileListFilePath(path);\n        assertEquals(path, profileManager.getProfileListFilePath());\n    }\n\n    @Test\n    public void hasProfile_nullPerson_throwsNullPointerException() {\n        assertThrows(NullPointerException.class, () -> profileManager.hasProfile(null));\n    }\n\n    @Test\n    public void hasProfile_profileNotInProfileList_returnsFalse() {\n        assertFalse(profileManager.hasProfile(ALICE.getName()));\n    }\n\n    @Test\n    public void hasProfile_profileInProfileList_returnsTrue() {\n        profileManager.addProfile(ALICE);\n        assertTrue(profileManager.hasProfile(ALICE.getName()));\n        profileManager.deleteProfile(ALICE);\n    }\n\n    @Test\n    public void hasProfile_profileDeletedFromProfileList_returnsFalse() {\n        profileManager.addProfile(ALICE);\n        profileManager.deleteProfile(ALICE);\n        assertFalse(profileManager.hasProfile((ALICE.getName())));\n    }\n\n    @Test\n    public void hasProfile_profileReplacedInProfileList_returnsTrue() {\n        profileManager.addProfile(ALICE);\n        profileManager.setProfile(ALICE, BENSON);\n        assertTrue(profileManager.hasProfile(BENSON.getName()));\n        profileManager.deleteProfile(BENSON);\n    }\n\n\n    @Test\n    public void hasProfile_profileReplacedInProfileList_returnFalse() {\n        profileManager.addProfile(ALICE);\n        profileManager.setProfile(ALICE, BENSON);\n        assertFalse(profileManager.hasProfile((ALICE.getName())));\n        profileManager.deleteProfile(BENSON);\n    }\n\n    @Test\n    public void getFilteredPersonList_modifyList_throwsUnsupportedOperationException() {\n        assertThrows(UnsupportedOperationException.class, () -> profileManager.getFilteredPersonList().remove(0));\n    }\n\n    @Test\n    public void hasOneProfile_profileInProfileList_returnsTrue() {\n        profileManager.addProfile(ALICE);\n        assertTrue(profileManager.hasOneProfile());\n        profileManager.deleteProfile(ALICE);\n    }\n\n    @Test\n    public void hasOneProfile_profileNotInProfileList_returnsFalse() {\n        assertFalse(profileManager.hasOneProfile());\n    }\n\n    @Test\n    public void getFirstProfile_profileInProfileList_returnsTrue() {\n        profileManager.addProfile(BENSON);\n        assertTrue(profileManager.getFirstProfile().equals(BENSON));\n        profileManager.deleteProfile(BENSON);\n    }\n\n    @Test\n    public void getFirstProfile_profileNotInProfileList_returnsFalse() {\n        profileManager.addProfile(BENSON);\n        assertFalse(profileManager.getFirstProfile().equals(ALICE));\n        profileManager.deleteProfile(BENSON);\n    }\n\n    @Test\n    public void addDeadline_nullDeadline_throwsNullPointerException() {\n        assertThrows(NullPointerException.class, () -> profileManager.addDeadline(null));\n    }\n\n    @Test\n    public void deleteDeadline_nullDeadline_throwsNullPointerException() {\n        assertThrows(NullPointerException.class, () -> profileManager.deleteDeadline(null));\n    }\n\n    @Test\n    public void replaceDeadline_nullDeadline_throwsNullPointerException() {\n        Deadline deadline = new Deadline(\"CS1101S\", \"Dummy description\");\n        assertThrows(NullPointerException.class, () -> profileManager.replaceDeadline(deadline, null));\n        assertThrows(NullPointerException.class, () -> profileManager.replaceDeadline(null, deadline));\n        assertThrows(NullPointerException.class, () -> profileManager.replaceDeadline(null, null));\n    }\n\n    @Test\n    public void clearDeadlineList_listSizeZero_returnsTrue() {\n        profileManager.clearDeadlineList();\n        assertTrue(profileManager.getSortedDeadlineList().size() == 0);\n    }\n\n\n}", "class_id": 0, "repo": "jadetayy/main", "file": "src/test/java/seedu/address/model/ProfileManagerTest.java", "last_update_at": "2020-04-20T10:20:55+00:00", "question_id": "910ae74fd7d5dace25c08978011bbbc12a5ca114", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ProfileManagerTest {\n    private ProfileManager profileManager = new ProfileManager();\n    @Test\n    public void constructor() {\n        assertEquals(new UserPrefs(), profileManager.getUserPrefs());\n        assertEquals(new GuiSettings(), profileManager.getGuiSettings());\n        assertEquals(new ProfileList(), profileManager.getProfileList());\n    }\n    @Test\n    public void setUserPrefs_nullUserPrefs_throwsNullPointerException() {\n        assertThrows(NullPointerException.class, () -> profileManager.setUserPrefs(null));\n    }\n    @Test\n    public void setUserPrefs_validUserPrefs_copiesUserPrefs() {\n        UserPrefs userPrefs = new UserPrefs();\n        userPrefs.setAddressBookFilePath(Paths.get(\"address/book/file/path\"));\n        userPrefs.setGuiSettings(new GuiSettings(1, 2, 3, 4));\n        profileManager.setUserPrefs(userPrefs);\n        assertEquals(userPrefs, profileManager.getUserPrefs());\n        // Modifying userPrefs should not modify profileManager's userPrefs\n        UserPrefs oldUserPrefs = new UserPrefs(userPrefs);\n        userPrefs.setAddressBookFilePath(Paths.get(\"new/address/book/file/path\"));\n        assertEquals(oldUserPrefs, profileManager.getUserPrefs());\n    }\n    @Test\n    public void setGuiSettings_nullGuiSettings_throwsNullPointerException() {\n        assertThrows(NullPointerException.class, () -> profileManager.setGuiSettings(null));\n    }\n    @Test\n    public void setGuiSettings_validGuiSettings_setsGuiSettings() {\n        GuiSettings guiSettings = new GuiSettings(1, 2, 3, 4);\n        profileManager.setGuiSettings(guiSettings);\n        assertEquals(guiSettings, profileManager.getGuiSettings());\n    }\n    @Test\n    public void setProfileListFilePath_nullPath_throwsNullPointerException() {\n        assertThrows(NullPointerException.class, () -> profileManager.setProfileListFilePath(null));\n    }\n    @Test\n    public void setProfileListFilePath_validPath_setsAddressBookFilePath() {\n        Path path = Paths.get(\"address/book/file/path\");\n        profileManager.setProfileListFilePath(path);\n        assertEquals(path, profileManager.getProfileListFilePath());\n    }\n    @Test\n    public void hasProfile_nullPerson_throwsNullPointerException() {\n        assertThrows(NullPointerException.class, () -> profileManager.hasProfile(null));\n    }\n    @Test\n    public void hasProfile_profileNotInProfileList_returnsFalse() {\n        assertFalse(profileManager.hasProfile(ALICE.getName()));\n    }\n    @Test\n    public void hasProfile_profileInProfileList_returnsTrue() {\n        profileManager.addProfile(ALICE);\n        assertTrue(profileManager.hasProfile(ALICE.getName()));\n        profileManager.deleteProfile(ALICE);\n    }\n    @Test\n    public void hasProfile_profileDeletedFromProfileList_returnsFalse() {\n        profileManager.addProfile(ALICE);\n        profileManager.deleteProfile(ALICE);\n        assertFalse(profileManager.hasProfile((ALICE.getName())));\n    }\n    @Test\n    public void hasProfile_profileReplacedInProfileList_returnsTrue() {\n        profileManager.addProfile(ALICE);\n        profileManager.setProfile(ALICE, BENSON);\n        assertTrue(profileManager.hasProfile(BENSON.getName()));\n        profileManager.deleteProfile(BENSON);\n    }\n    @Test\n    public void hasProfile_profileReplacedInProfileList_returnFalse() {\n        profileManager.addProfile(ALICE);\n        profileManager.setProfile(ALICE, BENSON);\n        assertFalse(profileManager.hasProfile((ALICE.getName())));\n        profileManager.deleteProfile(BENSON);\n    }\n    @Test\n    public void getFilteredPersonList_modifyList_throwsUnsupportedOperationException() {\n        assertThrows(UnsupportedOperationException.class, () -> profileManager.getFilteredPersonList().remove(0));\n    }\n    @Test\n    public void hasOneProfile_profileInProfileList_returnsTrue() {\n        profileManager.addProfile(ALICE);\n        assertTrue(profileManager.hasOneProfile());\n        profileManager.deleteProfile(ALICE);\n    }\n    @Test\n    public void hasOneProfile_profileNotInProfileList_returnsFalse() {\n        assertFalse(profileManager.hasOneProfile());\n    }\n    @Test\n    public void getFirstProfile_profileInProfileList_returnsTrue() {\n        profileManager.addProfile(BENSON);\n        assertTrue(profileManager.getFirstProfile().equals(BENSON));\n        profileManager.deleteProfile(BENSON);\n    }\n    @Test\n    public void getFirstProfile_profileNotInProfileList_returnsFalse() {\n        profileManager.addProfile(BENSON);\n        assertFalse(profileManager.getFirstProfile().equals(ALICE));\n        profileManager.deleteProfile(BENSON);\n    }\n    @Test\n    public void addDeadline_nullDeadline_throwsNullPointerException() {\n        assertThrows(NullPointerException.class, () -> profileManager.addDeadline(null));\n    }\n    @Test\n    public void deleteDeadline_nullDeadline_throwsNullPointerException() {\n        assertThrows(NullPointerException.class, () -> profileManager.deleteDeadline(null));\n    }\n    @Test\n    public void replaceDeadline_nullDeadline_throwsNullPointerException() {\n        Deadline deadline = new Deadline(\"CS1101S\", \"Dummy description\");\n        assertThrows(NullPointerException.class, () -> profileManager.replaceDeadline(deadline, null));\n        assertThrows(NullPointerException.class, () -> profileManager.replaceDeadline(null, deadline));\n        assertThrows(NullPointerException.class, () -> profileManager.replaceDeadline(null, null));\n    }\n    @Test\n    public void clearDeadlineList_listSizeZero_returnsTrue() {\n        profileManager.clearDeadlineList();\n        assertTrue(profileManager.getSortedDeadlineList().size() == 0);\n    }\n"]]}
{"hexsha": "4d7cfd843a49c96e9ff655d6ff82023577ab3107", "ext": "java", "lang": "Java", "content": "public class Tomcat {\n\tprivate static Thread tomcatThread;\n\n\tpublic static void startJettyServer(int portNum, List<WarSpec> warSpecs, String tmpDir) {\n\t\tstart();\n\t}\n\n\tpublic static SubLObject stopJettyServer(String tmpDir) {\n\t\tstop();\n\t\treturn Lisp.NIL;\n\t}\n\n\t/**\n\t * @return\n\t */\n\tpublic static void stop() {\n\t\t//Jetty.startJettyServer(portNum, warSpecs, tmpDir);\n\t\tdaemon = Bootstrap.daemon;\n\t\tif (daemon != null)\n\t\t\tBootstrap.main(new String[] { \"stop\" });\n\t}\n\n\t/**\n\t * Daemon object used by main.\n\t */\n\t//public static Bootstrap daemon = null;\n\n\tprivate static final Pattern PATH_PATTERN = Pattern.compile(\"(\\\".*?\\\")|(([^,])*)\");\n\n\tprivate static void setCatalinaLoader() {\n\t\tThread.currentThread().setContextClassLoader(IsolatedClassLoader.theIsolatedClassLoader);\n\t\t//Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);\n\t}\n\n\tstatic Bootstrap daemon;\n\n\t/**\n\t * \n\t */\n\tsynchronized public static void start() {\n\t\tdaemon = Bootstrap.daemon;\n\t\tif (daemon != null)\n\t\t\treturn;\n\t\ttomcatThread = new Thread(() -> bgStart());\n\t\ttomcatThread.setName(\"Tomcat Starup thread\");\n\t\ttomcatThread.setDaemon(true);\n\t\ttomcatThread.start();\n\n\t}\n\n\t/**\n\t * \n\t */\n\tpublic static void bgStart() {\n\t\t//Jetty.startJettyServer(portNum, warSpecs, tmpDir);\n\t\t//System.setProperty(\"http.port\", \"\" + portNum);\n\t\tString[] args = new String[] { \"start\" };\n\n\t\t//tomcatThread = new Thread(() -> {\n\n\t\tThread.currentThread().setContextClassLoader(IsolatedClassLoader.theIsolatedClassLoader);\n\n\t\tif (daemon == null) {\n\t\t\t// Don'e set daemon until init() has completed\n\t\t\tBootstrap bootstrap = new Bootstrap();\n\t\t\ttry {\n\t\t\t\tbootstrap.init();\n\t\t\t} catch (Throwable e) {\n\t\t\t\tprintStackTrace(e);\n\t\t\t\tErrors.handleError(e);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdaemon = Bootstrap.daemon = bootstrap;\n\t\t} else {\n\t\t\t// When running as a service the call to stop will be on a new\n\t\t\t// thread so make sure the correct class loader is used to prevent\n\t\t\t// a range of class not found exceptions.\n\t\t\tsetCatalinaLoader();\n\t\t}\n\n\t\ttry {\n\t\t\tdaemon.setAwait(false);\n\t\t} catch (Exception e) {\n\t\t\tprintStackTrace(e);\n\t\t\tErrors.handleError(e);\n\t\t}\n\t\ttry {\n\t\t\tdaemon.load(args);\n\t\t\tSystemCurrent.recheckStdIO();\n\t\t} catch (Exception e) {\n\t\t\tprintStackTrace(e);\n\t\t\tErrors.handleError(e);\n\t\t}\n\t\ttry {\n\t\t\tdaemon.start();\n\t\t} catch (Exception e) {\n\t\t\tprintStackTrace(e);\n\t\t\tErrors.handleError(e);\n\t\t}\n\n\t\t//\t\tif (null == daemon.getServer()) {\n\t\t//\t\t\tStartup.exit(1);\n\t\t//\t\t}\n\t}\n\n}", "class_id": 0, "repo": "TeamSPoon/CYC_JRTL_with_CommonLisp_OLD", "file": "platform/src/com/cyc/tool/subl/webserver/Tomcat.java", "last_update_at": "2020-01-17T16:29:19+00:00", "question_id": "4d7cfd843a49c96e9ff655d6ff82023577ab3107", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Tomcat {\n\tprivate static Thread tomcatThread;\n\tpublic static void startJettyServer(int portNum, List<WarSpec> warSpecs, String tmpDir) {\n\t\tstart();\n\t}\n\tpublic static SubLObject stopJettyServer(String tmpDir) {\n\t\tstop();\n\t\treturn Lisp.NIL;\n\t}\n\t/**\n\t * @return\n\t */\n\tpublic static void stop() {\n\t\t//Jetty.startJettyServer(portNum, warSpecs, tmpDir);\n\t\tdaemon = Bootstrap.daemon;\n\t\tif (daemon != null)\n\t\t\tBootstrap.main(new String[] { \"stop\" });\n\t}\n\t/**\n\t * Daemon object used by main.\n\t */\n\t//public static Bootstrap daemon = null;\n\tprivate static final Pattern PATH_PATTERN = Pattern.compile(\"(\\\".*?\\\")|(([^,])*)\");\n\tprivate static void setCatalinaLoader() {\n\t\tThread.currentThread().setContextClassLoader(IsolatedClassLoader.theIsolatedClassLoader);\n\t\t//Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);\n\t}\n\tstatic Bootstrap daemon;\n\t/**\n\t * \n\t */\n\tsynchronized public static void start() {\n\t\tdaemon = Bootstrap.daemon;\n\t\tif (daemon != null)\n\t\t\treturn;\n\t\ttomcatThread = new Thread(() -> bgStart());\n\t\ttomcatThread.setName(\"Tomcat Starup thread\");\n\t\ttomcatThread.setDaemon(true);\n\t\ttomcatThread.start();\n\t}\n\t/**\n\t * \n\t */\n\tpublic static void bgStart() {\n\t\t//Jetty.startJettyServer(portNum, warSpecs, tmpDir);\n\t\t//System.setProperty(\"http.port\", \"\" + portNum);\n\t\tString[] args = new String[] { \"start\" };\n\t\t//tomcatThread = new Thread(() -> {\n\t\tThread.currentThread().setContextClassLoader(IsolatedClassLoader.theIsolatedClassLoader);\n\t\tif (daemon == null) {\n\t\t\t// Don'e set daemon until init() has completed\n\t\t\tBootstrap bootstrap = new Bootstrap();\n\t\t\ttry {\n\t\t\t\tbootstrap.init();\n\t\t\t} catch (Throwable e) {\n\t\t\t\tprintStackTrace(e);\n\t\t\t\tErrors.handleError(e);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdaemon = Bootstrap.daemon = bootstrap;\n\t\t} else {\n\t\t\t// When running as a service the call to stop will be on a new\n\t\t\t// thread so make sure the correct class loader is used to prevent\n\t\t\t// a range of class not found exceptions.\n\t\t\tsetCatalinaLoader();\n\t\t}\n\t\ttry {\n\t\t\tdaemon.setAwait(false);\n\t\t} catch (Exception e) {\n\t\t\tprintStackTrace(e);\n\t\t\tErrors.handleError(e);\n\t\t}\n\t\ttry {\n\t\t\tdaemon.load(args);\n\t\t\tSystemCurrent.recheckStdIO();\n\t\t} catch (Exception e) {\n\t\t\tprintStackTrace(e);\n\t\t\tErrors.handleError(e);\n\t\t}\n\t\ttry {\n\t\t\tdaemon.start();\n\t\t} catch (Exception e) {\n\t\t\tprintStackTrace(e);\n\t\t\tErrors.handleError(e);\n\t\t}\n\t\t//\t\tif (null == daemon.getServer()) {\n\t\t//\t\t\tStartup.exit(1);\n\t\t//\t\t}\n\t}\n"]]}
{"hexsha": "fe402563a2cb0e659ac628ae27b579113e890fd1", "ext": "java", "lang": "Java", "content": "public abstract class Resources {\r\n\r\n\t/** Pseudo URL prefix for loading from the class path: \"classpath:\" */\r\n\tpublic static final String CLASSPATH_URL_PREFIX = \"classpath:\";\r\n\t\r\n\t/**\r\n\t * Pseudo URL prefix for all matching resources from the class path: \"classpath*:\"\r\n\t * This differs from ResourceLoader's classpath URL prefix in that it\r\n\t * retrieves all matching resources for a given name (e.g. \"/beans.xml\"),\r\n\t * for example in the root of all deployed JAR files.\r\n\t */\r\n\tpublic static String CLASSPATH_ALL_URL_PREFIX = \"classpath*:\";\t\r\n\r\n\t/** URL prefix for loading from the file system: \"file:\" */\r\n\tpublic static final String FILE_URL_PREFIX = \"file:\";\r\n\r\n\t/** URL protocol for a file in the file system: \"file\" */\r\n\tpublic static final String URL_PROTOCOL_FILE = \"file\";\r\n\r\n\t/** URL protocol for an entry from a jar file: \"jar\" */\r\n\tpublic static final String URL_PROTOCOL_JAR = \"jar\";\r\n\r\n\t/** URL protocol for an entry from a zip file: \"zip\" */\r\n\tpublic static final String URL_PROTOCOL_ZIP = \"zip\";\r\n\r\n\t/** URL protocol for an entry from a JBoss jar file: \"vfszip\" */\r\n\tpublic static final String URL_PROTOCOL_VFSZIP = \"vfszip\";\r\n\r\n\t/** URL protocol for a JBoss VFS resource: \"vfs\" */\r\n\tpublic static final String URL_PROTOCOL_VFS = \"vfs\";\r\n\r\n\t/** URL protocol for an entry from a WebSphere jar file: \"wsjar\" */\r\n\tpublic static final String URL_PROTOCOL_WSJAR = \"wsjar\";\r\n\r\n\t/** URL protocol for an entry from an OC4J jar file: \"code-source\" */\r\n\tpublic static final String URL_PROTOCOL_CODE_SOURCE = \"code-source\";\r\n\r\n\t/** Separator between JAR URL and file path within the JAR */\r\n\tpublic static final String JAR_URL_SEPARATOR = \"!/\";\r\n\t\r\n\tprivate static final ResourceLoader \t\t\t\t\t loader \t     = new DefaultResourceLoader();\r\n\tprivate static final PathMatchingResourcePatternResolver resolver        = new PathMatchingResourcePatternResolver();\r\n\tprivate static final PathMatchingResourcePatternResolver resolverQuietly = new PathMatchingResourcePatternResolver(true);\r\n\t\r\n\t/**\r\n\t * Return whether the given resource location is a URL: either a special \"classpath\" pseudo URL or a standard URL.\r\n\t * \r\n\t * @param resourceLocation the location String to check\r\n\t * @return whether the location qualifies as a URL\r\n\t * @see #CLASSPATH_URL_PREFIX\r\n\t * @see java.net.URL\r\n\t */\r\n\tpublic static boolean isUrl(String resourceLocation) {\r\n\t\tif (resourceLocation == null) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tnew URL(resourceLocation);\r\n\t\t\treturn true;\r\n\t\t} catch (MalformedURLException ex) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * Determine whether the given URL points to a resource in the file system, that is, has protocol \"file\" or \"vfs\".\r\n\t * \r\n\t * @param url the URL to check\r\n\t * @return whether the URL has been identified as a file system URL\r\n\t */\r\n\tpublic static boolean isFileURL(URL url) {\r\n\t\tString protocol = url.getProtocol();\r\n\t\treturn (URL_PROTOCOL_FILE.equals(protocol) || protocol.startsWith(URL_PROTOCOL_VFS));\r\n\t}\r\n\r\n\t/**\r\n\t * Determine whether the given URL points to a resource in a jar file, that is, has protocol \"jar\", \"zip\", \"wsjar\"\r\n\t * or \"code-source\".\r\n\t * <p>\r\n\t * \"zip\" and \"wsjar\" are used by BEA WebLogic Server and IBM WebSphere, respectively, but can be treated like jar\r\n\t * files. The same applies to \"code-source\" URLs on Oracle OC4J, provided that the path contains a jar separator.\r\n\t * \r\n\t * @param url the URL to check\r\n\t * @return whether the URL has been identified as a JAR URL\r\n\t */\r\n\tpublic static boolean isJarURL(URL url) {\r\n\t\tString protocol = url.getProtocol();\r\n\t\treturn (URL_PROTOCOL_JAR.equals(protocol) || URL_PROTOCOL_ZIP.equals(protocol) || URL_PROTOCOL_WSJAR.equals(protocol) || (URL_PROTOCOL_CODE_SOURCE\r\n\t\t        .equals(protocol) && url.getPath().contains(JAR_URL_SEPARATOR)));\r\n\t}\t\r\n\r\n\t/**\r\n\t * Resolve the given resource location to a <code>java.net.URL</code>.\r\n\t * <p>\r\n\t * Does not check whether the URL actually exists; simply returns the URL that the given location would correspond\r\n\t * to.\r\n\t * \r\n\t * @param resourceLocation the resource location to resolve: either a \"classpath:\" pseudo URL, a \"file:\" URL, or a\r\n\t *            plain file path\r\n\t * @return a corresponding URL object\r\n\t * @throws ObjectNotFoundException if the resource cannot be resolved to a URL\r\n\t */\r\n\tpublic static URL getURL(String resourceLocation) throws ObjectNotFoundException {\r\n\t\tAssert.notNull(resourceLocation, \"Resource location must not be null\");\r\n\t\tif (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {\r\n\t\t\tString path = resourceLocation.substring(CLASSPATH_URL_PREFIX.length());\r\n\t\t\tURL url = Classes.getClassLoader().getResource(path);\r\n\t\t\tif (url == null) {\r\n\t\t\t\tString description = \"class path resource [\" + path + \"]\";\r\n\t\t\t\tthrow new ObjectNotFoundException(description + \" cannot be resolved to URL because it does not exist\");\r\n\t\t\t}\r\n\t\t\treturn url;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\t// try URL\r\n\t\t\treturn new URL(resourceLocation);\r\n\t\t} catch (MalformedURLException ex) {\r\n\t\t\t// no URL -> treat as file path\r\n\t\t\ttry {\r\n\t\t\t\treturn new File(resourceLocation).toURI().toURL();\r\n\t\t\t} catch (MalformedURLException ex2) {\r\n\t\t\t\tthrow new ObjectNotFoundException(\"Resource location [\" + resourceLocation + \"] is neither a URL not a well-formed file path\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t//scan resources\r\n\t//-----------------------------------------------------------------------------\r\n\tpublic static Resource[] scan(String resourceLocationPattern) throws UncheckedIOException {\r\n\t\treturn scan(resourceLocationPattern,false);\r\n\t}\r\n\t\r\n\tpublic static Resource[] scanQuietly(String resourceLocationPattern) throws UncheckedIOException {\r\n\t\treturn scan(resourceLocationPattern,true);\r\n\t}\r\n\t\r\n\tpublic static Resource[] scan(String resourceLocationPattern,boolean quietly) throws UncheckedIOException {\r\n\t\ttry {\r\n\t        Resource[] resources = quietly ? resolverQuietly.getResources(resourceLocationPattern) : resolver.getResources(resourceLocationPattern);\r\n\t        \r\n\t        List<Resource> list = new ArrayList<Resource>();\r\n\t        \r\n\t        for(Resource r : resources){\r\n\t        \tif(r.exists()){\r\n\t        \t\tlist.add(r);\r\n\t        \t}\r\n\t        }\r\n\t        \r\n\t        return Collections.toArray(list,Resource.class);\r\n        } catch (IOException e) {\r\n        \tthrow new UncheckedIOException(\"Error scanning location : \" + resourceLocationPattern, e);\r\n        }\r\n\t}\r\n\t\r\n\tpublic static Resource getResource(String resourceLocation) throws UncheckedIOException {\r\n\t\tAssert.notNull(resourceLocation,\"Resource location must not be null\");\r\n\t\t\r\n\t\tif(!isUrl(resourceLocation)){\r\n\t\t\tresourceLocation = CLASSPATH_URL_PREFIX + resourceLocation;\r\n\t\t}\r\n\t\t\r\n        return loader.getResource(resourceLocation);\r\n\t}\r\n\t\r\n\tpublic static Resource getResource(Class<?> clazz,String resourceNameInPackage) throws UncheckedIOException {\r\n\t\tAssert.notNull(clazz,\"clazz must not be null\");\r\n\t\tAssert.notNull(resourceNameInPackage,\"resource name must not be null\");\r\n\t\t\r\n\t\tString resourceLocation = CLASSPATH_URL_PREFIX + clazz.getPackage().getName().replace('.', '/') + \"/\" + resourceNameInPackage;\r\n\t\t\r\n        return loader.getResource(resourceLocation);\r\n\t}\r\n\t\r\n\t//InputStream\r\n\t//-----------------------------------------------------------------------------\r\n\t\r\n\tpublic static InputStream getInputStream(String resourceLocation) throws UncheckedIOException {\r\n\t\ttry {\r\n\t\t\treturn getResource(resourceLocation).getInputStream();\r\n        } catch (IOException e) {\r\n        \tthrow new UncheckedIOException(\"Error getInputStream from :\" + resourceLocation,e);\r\n        }\r\n\t}\r\n\t\r\n\tpublic static InputStream getInputStream(Class<?> clazz,String resourceNameInPackage) throws UncheckedIOException {\r\n\t\ttry {\r\n\t\t\treturn getResource(clazz,resourceNameInPackage).getInputStream();\r\n        } catch (IOException e) {\r\n        \tthrow new UncheckedIOException(\"Error getInputStream from :\" + resourceNameInPackage,e);\r\n        }\r\n\t}\r\n\t\r\n\t//File\r\n\t//-----------------------------------------------------------------------------\t\r\n\r\n\t/**\r\n\t * Resolve the given resource location to a <code>java.io.File</code>, i.e. to a file in the file system.\r\n\t * <p>\r\n\t * Does not check whether the fil actually exists; simply returns the File that the given location would correspond\r\n\t * to.\r\n\t * \r\n\t * @param resourceLocation the resource location to resolve: either a \"classpath:\" pseudo URL, a \"file:\" URL, or a\r\n\t *            plain file path\r\n\t * @return a corresponding File object\r\n\t * @throws ObjectNotFoundException if the resource cannot be resolved to a file in the file system\r\n\t */\r\n\tpublic static File getFile(String resourceLocation) throws ObjectNotFoundException {\r\n\t\tAssert.notNull(resourceLocation, \"Resource location must not be null\");\r\n\t\tif (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {\r\n\t\t\tString path = resourceLocation.substring(CLASSPATH_URL_PREFIX.length());\r\n\t\t\tString description = \"class path resource [\" + path + \"]\";\r\n\t\t\tURL url = Classes.getClassLoader().getResource(path);\r\n\t\t\tif (url == null) {\r\n\t\t\t\tthrow new ObjectNotFoundException(description + \" cannot be resolved to absolute file path \"\r\n\t\t\t\t        + \"because it does not reside in the file system\");\r\n\t\t\t}\r\n\t\t\treturn getFile(url, description);\r\n\t\t}\r\n\t\ttry {\r\n\t\t\t// try URL\r\n\t\t\treturn getFile(new URL(resourceLocation));\r\n\t\t} catch (MalformedURLException ex) {\r\n\t\t\t// no URL -> treat as file path\r\n\t\t\treturn new File(resourceLocation);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Resolve the given resource URL to a <code>java.io.File</code>, i.e. to a file in the file system.\r\n\t * \r\n\t * @param resourceUrl the resource URL to resolve\r\n\t * @return a corresponding File object\r\n\t * @throws ObjectNotFoundException if the URL cannot be resolved to a file in the file system\r\n\t */\r\n\tpublic static File getFile(URL resourceUrl) throws ObjectNotFoundException {\r\n\t\treturn getFile(resourceUrl, \"URL\");\r\n\t}\r\n\r\n\t/**\r\n\t * Resolve the given resource URI to a <code>java.io.File</code>, i.e. to a file in the file system.\r\n\t * \r\n\t * @param resourceUri the resource URI to resolve\r\n\t * @return a corresponding File object\r\n\t * @throws ObjectNotFoundException if the URL cannot be resolved to a file in the file system\r\n\t */\r\n\tpublic static File getFile(URI resourceUri) throws ObjectNotFoundException {\r\n\t\treturn getFile(resourceUri, \"URI\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * Resolve the given resource URL to a <code>java.io.File</code>, i.e. to a file in the file system.\r\n\t * \r\n\t * @param resourceUrl the resource URL to resolve\r\n\t * @param description a description of the original resource that the URL was created for (for example, a class path\r\n\t *            location)\r\n\t * @return a corresponding File object\r\n\t * @throws ObjectNotFoundException if the URL cannot be resolved to a file in the file system\r\n\t */\r\n\tstatic File getFile(URL resourceUrl, String description) throws ObjectNotFoundException {\r\n\t\tAssert.notNull(resourceUrl, \"Resource URL must not be null\");\r\n\t\tif (!URL_PROTOCOL_FILE.equals(resourceUrl.getProtocol())) {\r\n\t\t\tthrow new ObjectNotFoundException(description + \" cannot be resolved to absolute file path \"\r\n\t\t\t        + \"because it does not reside in the file system: \" + resourceUrl);\r\n\t\t}\r\n\t\ttry {\r\n\t\t\treturn new File(toURI(resourceUrl).getSchemeSpecificPart());\r\n\t\t} catch (URISyntaxException ex) {\r\n\t\t\t// Fallback for URLs that are not valid URIs (should hardly ever happen).\r\n\t\t\treturn new File(resourceUrl.getFile());\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Resolve the given resource URI to a <code>java.io.File</code>, i.e. to a file in the file system.\r\n\t * \r\n\t * @param resourceUri the resource URI to resolve\r\n\t * @param description a description of the original resource that the URI was created for (for example, a class path\r\n\t *            location)\r\n\t * @return a corresponding File object\r\n\t * @throws ObjectNotFoundException if the URL cannot be resolved to a file in the file system\r\n\t */\r\n\tstatic File getFile(URI resourceUri, String description) throws ObjectNotFoundException {\r\n\t\tAssert.notNull(resourceUri, \"Resource URI must not be null\");\r\n\t\tif (!URL_PROTOCOL_FILE.equals(resourceUri.getScheme())) {\r\n\t\t\tthrow new ObjectNotFoundException(description + \" cannot be resolved to absolute file path \"\r\n\t\t\t        + \"because it does not reside in the file system: \" + resourceUri);\r\n\t\t}\r\n\t\treturn new File(resourceUri.getSchemeSpecificPart());\r\n\t}\r\n\r\n\t/**\r\n\t * Extract the URL for the actual jar file from the given URL (which may point to a resource in a jar file or to a\r\n\t * jar file itself).\r\n\t * \r\n\t * @param jarUrl the original URL\r\n\t * @return the URL for the actual jar file\r\n\t * @throws MalformedURLException if no valid jar file URL could be extracted\r\n\t */\r\n\tstatic URL extractJarFileURL(URL jarUrl) throws MalformedURLException {\r\n\t\tString urlFile = jarUrl.getFile();\r\n\t\tint separatorIndex = urlFile.indexOf(JAR_URL_SEPARATOR);\r\n\t\tif (separatorIndex != -1) {\r\n\t\t\tString jarFile = urlFile.substring(0, separatorIndex);\r\n\t\t\ttry {\r\n\t\t\t\treturn new URL(jarFile);\r\n\t\t\t} catch (MalformedURLException ex) {\r\n\t\t\t\t// Probably no protocol in original jar URL, like \"jar:C:/mypath/myjar.jar\".\r\n\t\t\t\t// This usually indicates that the jar file resides in the file system.\r\n\t\t\t\tif (!jarFile.startsWith(\"/\")) {\r\n\t\t\t\t\tjarFile = \"/\" + jarFile;\r\n\t\t\t\t}\r\n\t\t\t\treturn new URL(FILE_URL_PREFIX + jarFile);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn jarUrl;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Create a URI instance for the given URL, replacing spaces with \"%20\" quotes first.\r\n\t * <p>\r\n\t * Furthermore, this method works on JDK 1.4 as well, in contrast to the <code>URL.toURI()</code> method.\r\n\t * \r\n\t * @param url the URL to convert into a URI instance\r\n\t * @return the URI instance\r\n\t * @throws URISyntaxException if the URL wasn't a valid URI\r\n\t * @see java.net.URL#toURI()\r\n\t */\r\n\tstatic URI toURI(URL url) throws URISyntaxException {\r\n\t\treturn toURI(url.toString());\r\n\t}\r\n\r\n\t/**\r\n\t * Create a URI instance for the given location String, replacing spaces with \"%20\" quotes first.\r\n\t * \r\n\t * @param location the location String to convert into a URI instance\r\n\t * @return the URI instance\r\n\t * @throws URISyntaxException if the location wasn't a valid URI\r\n\t */\r\n\tstatic URI toURI(String location) throws URISyntaxException {\r\n\t\treturn new URI(Strings.replace(location, \" \", \"%20\"));\r\n\t}\r\n\r\n\t/**\r\n\t * Set the {@link URLConnection#setUseCaches \"useCaches\"} flag on the given connection, preferring\r\n\t * <code>false</code> but leaving the flag at <code>true</code> for JNLP based resources.\r\n\t * \r\n\t * @param con the URLConnection to set the flag on\r\n\t */\r\n\tstatic void useCachesIfNecessary(URLConnection con) {\r\n\t\tcon.setUseCaches(con.getClass().getName().startsWith(\"JNLP\"));\r\n\t}\r\n\t\r\n\tstatic String applyRelativePath(String parentPath, String relativePath) {\r\n\t\tint separatorIndex = parentPath.lastIndexOf(Paths.UNIX_SEPARATOR_STR);\r\n\t\tif (separatorIndex != -1) {\r\n\t\t\tString newPath = parentPath.substring(0, separatorIndex);\r\n\t\t\tif (!relativePath.startsWith(Paths.UNIX_SEPARATOR_STR)) {\r\n\t\t\t\tnewPath += Paths.UNIX_SEPARATOR_STR;\r\n\t\t\t}\r\n\t\t\treturn newPath + relativePath;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn relativePath;\r\n\t\t}\r\n\t}\r\n}", "class_id": 0, "repo": "bingo-open-source/bingo-core", "file": "core-lang/src/main/java/bingo/lang/resource/Resources.java", "last_update_at": "2020-03-15T05:00:07+00:00", "question_id": "fe402563a2cb0e659ac628ae27b579113e890fd1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class Resources {\r\n\r\n\t/** Pseudo URL prefix for loading from the class path: \"classpath:\" */\r\n\tpublic static final String CLASSPATH_URL_PREFIX = \"classpath:\";\r\n\t\r\n\t/**\r\n\t * Pseudo URL prefix for all matching resources from the class path: \"classpath*:\"\r\n\t * This differs from ResourceLoader's classpath URL prefix in that it\r\n\t * retrieves all matching resources for a given name (e.g. \"/beans.xml\"),\r\n\t * for example in the root of all deployed JAR files.\r\n\t */\r\n\tpublic static String CLASSPATH_ALL_URL_PREFIX = \"classpath*:\";\t\r\n\r\n\t/** URL prefix for loading from the file system: \"file:\" */\r\n\tpublic static final String FILE_URL_PREFIX = \"file:\";\r\n\r\n\t/** URL protocol for a file in the file system: \"file\" */\r\n\tpublic static final String URL_PROTOCOL_FILE = \"file\";\r\n\r\n\t/** URL protocol for an entry from a jar file: \"jar\" */\r\n\tpublic static final String URL_PROTOCOL_JAR = \"jar\";\r\n\r\n\t/** URL protocol for an entry from a zip file: \"zip\" */\r\n\tpublic static final String URL_PROTOCOL_ZIP = \"zip\";\r\n\r\n\t/** URL protocol for an entry from a JBoss jar file: \"vfszip\" */\r\n\tpublic static final String URL_PROTOCOL_VFSZIP = \"vfszip\";\r\n\r\n\t/** URL protocol for a JBoss VFS resource: \"vfs\" */\r\n\tpublic static final String URL_PROTOCOL_VFS = \"vfs\";\r\n\r\n\t/** URL protocol for an entry from a WebSphere jar file: \"wsjar\" */\r\n\tpublic static final String URL_PROTOCOL_WSJAR = \"wsjar\";\r\n\r\n\t/** URL protocol for an entry from an OC4J jar file: \"code-source\" */\r\n\tpublic static final String URL_PROTOCOL_CODE_SOURCE = \"code-source\";\r\n\r\n\t/** Separator between JAR URL and file path within the JAR */\r\n\tpublic static final String JAR_URL_SEPARATOR = \"!/\";\r\n\t\r\n\tprivate static final ResourceLoader \t\t\t\t\t loader \t     = new DefaultResourceLoader();\r\n\tprivate static final PathMatchingResourcePatternResolver resolver        = new PathMatchingResourcePatternResolver();\r\n\tprivate static final PathMatchingResourcePatternResolver resolverQuietly = new PathMatchingResourcePatternResolver(true);\r\n\t\r\n\t/**\r\n\t * Return whether the given resource location is a URL: either a special \"classpath\" pseudo URL or a standard URL.\r\n\t * \r\n\t * @param resourceLocation the location String to check\r\n\t * @return whether the location qualifies as a URL\r\n\t * @see #CLASSPATH_URL_PREFIX\r\n\t * @see java.net.URL\r\n\t */\r\n\tpublic static boolean isUrl(String resourceLocation) {\r\n\t\tif (resourceLocation == null) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tnew URL(resourceLocation);\r\n\t\t\treturn true;\r\n\t\t} catch (MalformedURLException ex) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * Determine whether the given URL points to a resource in the file system, that is, has protocol \"file\" or \"vfs\".\r\n\t * \r\n\t * @param url the URL to check\r\n\t * @return whether the URL has been identified as a file system URL\r\n\t */\r\n\tpublic static boolean isFileURL(URL url) {\r\n\t\tString protocol = url.getProtocol();\r\n\t\treturn (URL_PROTOCOL_FILE.equals(protocol) || protocol.startsWith(URL_PROTOCOL_VFS));\r\n\t}\r\n\r\n\t/**\r\n\t * Determine whether the given URL points to a resource in a jar file, that is, has protocol \"jar\", \"zip\", \"wsjar\"\r\n\t * or \"code-source\".\r\n\t * <p>\r\n\t * \"zip\" and \"wsjar\" are used by BEA WebLogic Server and IBM WebSphere, respectively, but can be treated like jar\r\n\t * files. The same applies to \"code-source\" URLs on Oracle OC4J, provided that the path contains a jar separator.\r\n\t * \r\n\t * @param url the URL to check\r\n\t * @return whether the URL has been identified as a JAR URL\r\n\t */\r\n\tpublic static boolean isJarURL(URL url) {\r\n\t\tString protocol = url.getProtocol();\r\n\t\treturn (URL_PROTOCOL_JAR.equals(protocol) || URL_PROTOCOL_ZIP.equals(protocol) || URL_PROTOCOL_WSJAR.equals(protocol) || (URL_PROTOCOL_CODE_SOURCE\r\n\t\t        .equals(protocol) && url.getPath().contains(JAR_URL_SEPARATOR)));\r\n\t}\t\r\n\r\n\t/**\r\n\t * Resolve the given resource location to a <code>java.net.URL</code>.\r\n\t * <p>\r\n\t * Does not check whether the URL actually exists; simply returns the URL that the given location would correspond\r\n\t * to.\r\n\t * \r\n\t * @param resourceLocation the resource location to resolve: either a \"classpath:\" pseudo URL, a \"file:\" URL, or a\r\n\t *            plain file path\r\n\t * @return a corresponding URL object\r\n\t * @throws ObjectNotFoundException if the resource cannot be resolved to a URL\r\n\t */\r\n\tpublic static URL getURL(String resourceLocation) throws ObjectNotFoundException {\r\n\t\tAssert.notNull(resourceLocation, \"Resource location must not be null\");\r\n\t\tif (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {\r\n\t\t\tString path = resourceLocation.substring(CLASSPATH_URL_PREFIX.length());\r\n\t\t\tURL url = Classes.getClassLoader().getResource(path);\r\n\t\t\tif (url == null) {\r\n\t\t\t\tString description = \"class path resource [\" + path + \"]\";\r\n\t\t\t\tthrow new ObjectNotFoundException(description + \" cannot be resolved to URL because it does not exist\");\r\n\t\t\t}\r\n\t\t\treturn url;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\t// try URL\r\n\t\t\treturn new URL(resourceLocation);\r\n\t\t} catch (MalformedURLException ex) {\r\n\t\t\t// no URL -> treat as file path\r\n\t\t\ttry {\r\n\t\t\t\treturn new File(resourceLocation).toURI().toURL();\r\n\t\t\t} catch (MalformedURLException ex2) {\r\n\t\t\t\tthrow new ObjectNotFoundException(\"Resource location [\" + resourceLocation + \"] is neither a URL not a well-formed file path\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t//scan resources\r\n\t//-----------------------------------------------------------------------------\r\n\tpublic static Resource[] scan(String resourceLocationPattern) throws UncheckedIOException {\r\n\t\treturn scan(resourceLocationPattern,false);\r\n\t}\r\n\t\r\n\tpublic static Resource[] scanQuietly(String resourceLocationPattern) throws UncheckedIOException {\r\n\t\treturn scan(resourceLocationPattern,true);\r\n\t}\r\n\t\r\n\tpublic static Resource[] scan(String resourceLocationPattern,boolean quietly) throws UncheckedIOException {\r\n\t\ttry {\r\n\t        Resource[] resources = quietly ? resolverQuietly.getResources(resourceLocationPattern) : resolver.getResources(resourceLocationPattern);\r\n\t        \r\n\t        List<Resource> list = new ArrayList<Resource>();\r\n\t        \r\n\t        for(Resource r : resources){\r\n\t        \tif(r.exists()){\r\n\t        \t\tlist.add(r);\r\n\t        \t}\r\n\t        }\r\n\t        \r\n\t        return Collections.toArray(list,Resource.class);\r\n        } catch (IOException e) {\r\n        \tthrow new UncheckedIOException(\"Error scanning location : \" + resourceLocationPattern, e);\r\n        }\r\n\t}\r\n\t\r\n\tpublic static Resource getResource(String resourceLocation) throws UncheckedIOException {\r\n\t\tAssert.notNull(resourceLocation,\"Resource location must not be null\");\r\n\t\t\r\n\t\tif(!isUrl(resourceLocation)){\r\n\t\t\tresourceLocation = CLASSPATH_URL_PREFIX + resourceLocation;\r\n\t\t}\r\n\t\t\r\n        return loader.getResource(resourceLocation);\r\n\t}\r\n\t\r\n\tpublic static Resource getResource(Class<?> clazz,String resourceNameInPackage) throws UncheckedIOException {\r\n\t\tAssert.notNull(clazz,\"clazz must not be null\");\r\n\t\tAssert.notNull(resourceNameInPackage,\"resource name must not be null\");\r\n\t\t\r\n\t\tString resourceLocation = CLASSPATH_URL_PREFIX + clazz.getPackage().getName().replace('.', '/') + \"/\" + resourceNameInPackage;\r\n\t\t\r\n        return loader.getResource(resourceLocation);\r\n\t}\r\n\t\r\n\t//InputStream\r\n\t//-----------------------------------------------------------------------------\r\n\t\r\n\tpublic static InputStream getInputStream(String resourceLocation) throws UncheckedIOException {\r\n\t\ttry {\r\n\t\t\treturn getResource(resourceLocation).getInputStream();\r\n        } catch (IOException e) {\r\n        \tthrow new UncheckedIOException(\"Error getInputStream from :\" + resourceLocation,e);\r\n        }\r\n\t}\r\n\t\r\n\tpublic static InputStream getInputStream(Class<?> clazz,String resourceNameInPackage) throws UncheckedIOException {\r\n\t\ttry {\r\n\t\t\treturn getResource(clazz,resourceNameInPackage).getInputStream();\r\n        } catch (IOException e) {\r\n        \tthrow new UncheckedIOException(\"Error getInputStream from :\" + resourceNameInPackage,e);\r\n        }\r\n\t}\r\n\t\r\n\t//File\r\n\t//-----------------------------------------------------------------------------\t\r\n\r\n\t/**\r\n\t * Resolve the given resource location to a <code>java.io.File</code>, i.e. to a file in the file system.\r\n\t * <p>\r\n\t * Does not check whether the fil actually exists; simply returns the File that the given location would correspond\r\n\t * to.\r\n\t * \r\n\t * @param resourceLocation the resource location to resolve: either a \"classpath:\" pseudo URL, a \"file:\" URL, or a\r\n\t *            plain file path\r\n\t * @return a corresponding File object\r\n\t * @throws ObjectNotFoundException if the resource cannot be resolved to a file in the file system\r\n\t */\r\n\tpublic static File getFile(String resourceLocation) throws ObjectNotFoundException {\r\n\t\tAssert.notNull(resourceLocation, \"Resource location must not be null\");\r\n\t\tif (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {\r\n\t\t\tString path = resourceLocation.substring(CLASSPATH_URL_PREFIX.length());\r\n\t\t\tString description = \"class path resource [\" + path + \"]\";\r\n\t\t\tURL url = Classes.getClassLoader().getResource(path);\r\n\t\t\tif (url == null) {\r\n\t\t\t\tthrow new ObjectNotFoundException(description + \" cannot be resolved to absolute file path \"\r\n\t\t\t\t        + \"because it does not reside in the file system\");\r\n\t\t\t}\r\n\t\t\treturn getFile(url, description);\r\n\t\t}\r\n\t\ttry {\r\n\t\t\t// try URL\r\n\t\t\treturn getFile(new URL(resourceLocation));\r\n\t\t} catch (MalformedURLException ex) {\r\n\t\t\t// no URL -> treat as file path\r\n\t\t\treturn new File(resourceLocation);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Resolve the given resource URL to a <code>java.io.File</code>, i.e. to a file in the file system.\r\n\t * \r\n\t * @param resourceUrl the resource URL to resolve\r\n\t * @return a corresponding File object\r\n\t * @throws ObjectNotFoundException if the URL cannot be resolved to a file in the file system\r\n\t */\r\n\tpublic static File getFile(URL resourceUrl) throws ObjectNotFoundException {\r\n\t\treturn getFile(resourceUrl, \"URL\");\r\n\t}\r\n\r\n\t/**\r\n\t * Resolve the given resource URI to a <code>java.io.File</code>, i.e. to a file in the file system.\r\n\t * \r\n\t * @param resourceUri the resource URI to resolve\r\n\t * @return a corresponding File object\r\n\t * @throws ObjectNotFoundException if the URL cannot be resolved to a file in the file system\r\n\t */\r\n\tpublic static File getFile(URI resourceUri) throws ObjectNotFoundException {\r\n\t\treturn getFile(resourceUri, \"URI\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * Resolve the given resource URL to a <code>java.io.File</code>, i.e. to a file in the file system.\r\n\t * \r\n\t * @param resourceUrl the resource URL to resolve\r\n\t * @param description a description of the original resource that the URL was created for (for example, a class path\r\n\t *            location)\r\n\t * @return a corresponding File object\r\n\t * @throws ObjectNotFoundException if the URL cannot be resolved to a file in the file system\r\n\t */\r\n\tstatic File getFile(URL resourceUrl, String description) throws ObjectNotFoundException {\r\n\t\tAssert.notNull(resourceUrl, \"Resource URL must not be null\");\r\n\t\tif (!URL_PROTOCOL_FILE.equals(resourceUrl.getProtocol())) {\r\n\t\t\tthrow new ObjectNotFoundException(description + \" cannot be resolved to absolute file path \"\r\n\t\t\t        + \"because it does not reside in the file system: \" + resourceUrl);\r\n\t\t}\r\n\t\ttry {\r\n\t\t\treturn new File(toURI(resourceUrl).getSchemeSpecificPart());\r\n\t\t} catch (URISyntaxException ex) {\r\n\t\t\t// Fallback for URLs that are not valid URIs (should hardly ever happen).\r\n\t\t\treturn new File(resourceUrl.getFile());\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Resolve the given resource URI to a <code>java.io.File</code>, i.e. to a file in the file system.\r\n\t * \r\n\t * @param resourceUri the resource URI to resolve\r\n\t * @param description a description of the original resource that the URI was created for (for example, a class path\r\n\t *            location)\r\n\t * @return a corresponding File object\r\n\t * @throws ObjectNotFoundException if the URL cannot be resolved to a file in the file system\r\n\t */\r\n\tstatic File getFile(URI resourceUri, String description) throws ObjectNotFoundException {\r\n\t\tAssert.notNull(resourceUri, \"Resource URI must not be null\");\r\n\t\tif (!URL_PROTOCOL_FILE.equals(resourceUri.getScheme())) {\r\n\t\t\tthrow new ObjectNotFoundException(description + \" cannot be resolved to absolute file path \"\r\n\t\t\t        + \"because it does not reside in the file system: \" + resourceUri);\r\n\t\t}\r\n\t\treturn new File(resourceUri.getSchemeSpecificPart());\r\n\t}\r\n\r\n\t/**\r\n\t * Extract the URL for the actual jar file from the given URL (which may point to a resource in a jar file or to a\r\n\t * jar file itself).\r\n\t * \r\n\t * @param jarUrl the original URL\r\n\t * @return the URL for the actual jar file\r\n\t * @throws MalformedURLException if no valid jar file URL could be extracted\r\n\t */\r\n\tstatic URL extractJarFileURL(URL jarUrl) throws MalformedURLException {\r\n\t\tString urlFile = jarUrl.getFile();\r\n\t\tint separatorIndex = urlFile.indexOf(JAR_URL_SEPARATOR);\r\n\t\tif (separatorIndex != -1) {\r\n\t\t\tString jarFile = urlFile.substring(0, separatorIndex);\r\n\t\t\ttry {\r\n\t\t\t\treturn new URL(jarFile);\r\n\t\t\t} catch (MalformedURLException ex) {\r\n\t\t\t\t// Probably no protocol in original jar URL, like \"jar:C:/mypath/myjar.jar\".\r\n\t\t\t\t// This usually indicates that the jar file resides in the file system.\r\n\t\t\t\tif (!jarFile.startsWith(\"/\")) {\r\n\t\t\t\t\tjarFile = \"/\" + jarFile;\r\n\t\t\t\t}\r\n\t\t\t\treturn new URL(FILE_URL_PREFIX + jarFile);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn jarUrl;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Create a URI instance for the given URL, replacing spaces with \"%20\" quotes first.\r\n\t * <p>\r\n\t * Furthermore, this method works on JDK 1.4 as well, in contrast to the <code>URL.toURI()</code> method.\r\n\t * \r\n\t * @param url the URL to convert into a URI instance\r\n\t * @return the URI instance\r\n\t * @throws URISyntaxException if the URL wasn't a valid URI\r\n\t * @see java.net.URL#toURI()\r\n\t */\r\n\tstatic URI toURI(URL url) throws URISyntaxException {\r\n\t\treturn toURI(url.toString());\r\n\t}\r\n\r\n\t/**\r\n\t * Create a URI instance for the given location String, replacing spaces with \"%20\" quotes first.\r\n\t * \r\n\t * @param location the location String to convert into a URI instance\r\n\t * @return the URI instance\r\n\t * @throws URISyntaxException if the location wasn't a valid URI\r\n\t */\r\n\tstatic URI toURI(String location) throws URISyntaxException {\r\n\t\treturn new URI(Strings.replace(location, \" \", \"%20\"));\r\n\t}\r\n\r\n\t/**\r\n\t * Set the {@link URLConnection#setUseCaches \"useCaches\"} flag on the given connection, preferring\r\n\t * <code>false</code> but leaving the flag at <code>true</code> for JNLP based resources.\r\n\t * \r\n\t * @param con the URLConnection to set the flag on\r\n\t */\r\n\tstatic void useCachesIfNecessary(URLConnection con) {\r\n\t\tcon.setUseCaches(con.getClass().getName().startsWith(\"JNLP\"));\r\n\t}\r\n\t\r\n\tstatic String applyRelativePath(String parentPath, String relativePath) {\r\n\t\tint separatorIndex = parentPath.lastIndexOf(Paths.UNIX_SEPARATOR_STR);\r\n\t\tif (separatorIndex != -1) {\r\n\t\t\tString newPath = parentPath.substring(0, separatorIndex);\r\n\t\t\tif (!relativePath.startsWith(Paths.UNIX_SEPARATOR_STR)) {\r\n\t\t\t\tnewPath += Paths.UNIX_SEPARATOR_STR;\r\n\t\t\t}\r\n\t\t\treturn newPath + relativePath;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn relativePath;\r\n\t\t}\r\n\t}\r\n"]]}
{"hexsha": "6a005427a48ce243e3fa1ae1f58c1005dde59421", "ext": "java", "lang": "Java", "content": "public class SvnKitUpgradeClient extends BaseSvnClient implements UpgradeClient {\n\n  @Override\n  public void upgrade(@NotNull File path, @NotNull WorkingCopyFormat format, @Nullable ProgressTracker handler) throws VcsException {\n    validateFormat(format, getSupportedFormats());\n\n    SVNWCClient client = myVcs.getSvnKitManager().createUpgradeClient();\n\n    client.setEventHandler(toEventHandler(handler));\n    try {\n      cleanupIfNecessary(path, format, client, handler);\n      upgrade(path, format, client, handler);\n    }\n    catch (SVNException e) {\n      throw new SvnBindException(e);\n    }\n  }\n\n  @Override\n  public List<WorkingCopyFormat> getSupportedFormats() throws VcsException {\n    return SvnKitCheckoutClient.SUPPORTED_FORMATS;\n  }\n\n  private static void cleanupIfNecessary(@NotNull File path,\n                                         @NotNull WorkingCopyFormat format,\n                                         @NotNull SVNWCClient client,\n                                         @Nullable ProgressTracker handler) throws SVNException, VcsException {\n    // cleanup is executed only for SVNKit as it could handle both 1.6 and 1.7 formats\n    if (WorkingCopyFormat.ONE_DOT_SEVEN.equals(format)) {\n      // fake event indicating cleanup start\n      callHandler(handler, createEvent(path, EventAction.UPDATE_STARTED));\n      client.doCleanup(path);\n    }\n  }\n\n  private static void upgrade(@NotNull File path,\n                              @NotNull WorkingCopyFormat format,\n                              @NotNull SVNWCClient client,\n                              @Nullable ProgressTracker handler) throws SVNException, VcsException {\n    // fake event indicating upgrade start\n    callHandler(handler, createEvent(path, EventAction.UPDATE_COMPLETED));\n    client.doSetWCFormat(path, format.getFormat());\n  }\n}", "class_id": 0, "repo": "teddywest32/intellij-community", "file": "plugins/svn4idea/src/org/jetbrains/idea/svn/upgrade/SvnKitUpgradeClient.java", "last_update_at": "2020-11-27T10:36:50+00:00", "question_id": "6a005427a48ce243e3fa1ae1f58c1005dde59421", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SvnKitUpgradeClient extends BaseSvnClient implements UpgradeClient {\n  @Override\n  public void upgrade(@NotNull File path, @NotNull WorkingCopyFormat format, @Nullable ProgressTracker handler) throws VcsException {\n    validateFormat(format, getSupportedFormats());\n    SVNWCClient client = myVcs.getSvnKitManager().createUpgradeClient();\n    client.setEventHandler(toEventHandler(handler));\n    try {\n      cleanupIfNecessary(path, format, client, handler);\n      upgrade(path, format, client, handler);\n    }\n    catch (SVNException e) {\n      throw new SvnBindException(e);\n    }\n  }\n  @Override\n  public List<WorkingCopyFormat> getSupportedFormats() throws VcsException {\n    return SvnKitCheckoutClient.SUPPORTED_FORMATS;\n  }\n  private static void cleanupIfNecessary(@NotNull File path,\n                                         @NotNull WorkingCopyFormat format,\n                                         @NotNull SVNWCClient client,\n                                         @Nullable ProgressTracker handler) throws SVNException, VcsException {\n    // cleanup is executed only for SVNKit as it could handle both 1.6 and 1.7 formats\n    if (WorkingCopyFormat.ONE_DOT_SEVEN.equals(format)) {\n      // fake event indicating cleanup start\n      callHandler(handler, createEvent(path, EventAction.UPDATE_STARTED));\n      client.doCleanup(path);\n    }\n  }\n  private static void upgrade(@NotNull File path,\n                              @NotNull WorkingCopyFormat format,\n                              @NotNull SVNWCClient client,\n                              @Nullable ProgressTracker handler) throws SVNException, VcsException {\n    // fake event indicating upgrade start\n    callHandler(handler, createEvent(path, EventAction.UPDATE_COMPLETED));\n    client.doSetWCFormat(path, format.getFormat());\n  }\n"]]}
{"hexsha": "12a4580df0bccd1cd60ae91ac8936d39e1fe4a3b", "ext": "java", "lang": "Java", "content": "public class SetWarpCommand implements CommandExecutor {\n\n    public static final String[] ALIASES = {\"setwarp\", \"addwarp\"};\n\n    /**\n     * Get the Command Specifications for this command\n     *\n     * @return CommandSpec\n     */\n    public static CommandSpec getCommandSpec() {\n        return CommandSpec.builder()\n                .permission(\"destinations.warp.create\")\n                .description(Text.of(\"/setwarp <name>\"))\n                .extendedDescription(Text.of(\"Set this location as a public warp.\"))\n                .executor(new SetWarpCommand())\n                .arguments(GenericArguments.remainingJoinedStrings(Text.of(\"name\")))\n                .build();\n    }\n\n    @Override\n    public CommandResult execute(CommandSource src, CommandContext args) throws CommandException {\n\n        if (!(src instanceof Player)) {\n            return CommandResult.empty();\n        }\n\n        String name = (String) args.getOne(\"name\").orElse(\"\");\n        Player player = (Player) src;\n\n        if (warpExists(name)) {\n            player.sendMessage(MessagesUtil.error(player, \"warp.exist\", name));\n            return CommandResult.success();\n        }\n\n        WarpEntity warp = new WarpEntity(name, false, new LocationEntity(player), PlayerCache.instance.get(player));\n        warp = WarpRepository.instance.save(warp);\n        WarpCache.instance.get().add(warp);\n\n        player.sendMessage(MessagesUtil.success(player, \"warp.create\", name));\n        // TODO: add private flag\n\n        return CommandResult.success();\n    }\n\n    private boolean warpExists(String name) {\n        for (WarpEntity warp : WarpCache.instance.get()) {\n            if (warp.getName().equalsIgnoreCase(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n}", "class_id": 0, "repo": "vincentweeda/Destinations", "file": "src/main/java/com/github/mmonkey/destinations/commands/SetWarpCommand.java", "last_update_at": "2020-04-08T13:07:48+00:00", "question_id": "12a4580df0bccd1cd60ae91ac8936d39e1fe4a3b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SetWarpCommand implements CommandExecutor {\n    public static final String[] ALIASES = {\"setwarp\", \"addwarp\"};\n    /**\n     * Get the Command Specifications for this command\n     *\n     * @return CommandSpec\n     */\n    public static CommandSpec getCommandSpec() {\n        return CommandSpec.builder()\n                .permission(\"destinations.warp.create\")\n                .description(Text.of(\"/setwarp <name>\"))\n                .extendedDescription(Text.of(\"Set this location as a public warp.\"))\n                .executor(new SetWarpCommand())\n                .arguments(GenericArguments.remainingJoinedStrings(Text.of(\"name\")))\n                .build();\n    }\n    @Override\n    public CommandResult execute(CommandSource src, CommandContext args) throws CommandException {\n        if (!(src instanceof Player)) {\n            return CommandResult.empty();\n        }\n        String name = (String) args.getOne(\"name\").orElse(\"\");\n        Player player = (Player) src;\n        if (warpExists(name)) {\n            player.sendMessage(MessagesUtil.error(player, \"warp.exist\", name));\n            return CommandResult.success();\n        }\n        WarpEntity warp = new WarpEntity(name, false, new LocationEntity(player), PlayerCache.instance.get(player));\n        warp = WarpRepository.instance.save(warp);\n        WarpCache.instance.get().add(warp);\n        player.sendMessage(MessagesUtil.success(player, \"warp.create\", name));\n        // TODO: add private flag\n        return CommandResult.success();\n    }\n    private boolean warpExists(String name) {\n        for (WarpEntity warp : WarpCache.instance.get()) {\n            if (warp.getName().equalsIgnoreCase(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n"]]}
{"hexsha": "3e27678292a92c3c3f4eaf18bb6319f84488535a", "ext": "java", "lang": "Java", "content": "public class FileAgent {\n    \n    // hash map that saves all the files already loaded by the simulator\n    // to avoid reading the same file multiple times.\n    private static HashMap<String, ArrayList<String>> readFiles;\n    public static DecimalFormat format;\n    public static DecimalFormat timeFormat;\n    public static final String columnSeparator = \",\";\n    private static final String lineSeparator = \"\\n\";\n    \n    static {\n\tformat = new DecimalFormat(\"0\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n\tformat.setMinimumFractionDigits(1);\n\tformat.setMaximumFractionDigits(10);\n\ttimeFormat = new DecimalFormat(\"0\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n//\ttimeFormat.setMinimumFractionDigits(3);\n\ttimeFormat.setMaximumFractionDigits(0);\n    }\n    \n    public static void init(final Configuration configuration) {\n        try {\n\n            String header = \"\";\n            for (int i = 0; i < StatisticsMonitor.headersExperimentFile.length; i++) {\n                header += StatisticsMonitor.headersExperimentFile[i];\n                if (i < StatisticsMonitor.headersExperimentFile.length - 1)\n                    header += columnSeparator;\n            }\n            header += lineSeparator;\n\n            Path path = Paths.get(configuration.getBaseFolder() + \"results-\" + configuration.getSuffix() + \".csv\");\n            Files.write(path, header.getBytes(), StandardOpenOption.CREATE_NEW);\n\n            header = \"\";\n            for (int i = 0; i < StatisticsMonitor.headersAverageFile.length; i++) {\n                header += StatisticsMonitor.headersAverageFile[i];\n                if (i < StatisticsMonitor.headersAverageFile.length - 1)\n                    header += columnSeparator;\n            }\n            header += lineSeparator;\n\n            path = Paths.get(configuration.getBaseFolder() + \"results-avg-\" + configuration.getSuffix() + \".csv\");\n            Files.write(path, header.getBytes(), StandardOpenOption.CREATE_NEW);\n\n        } catch (final Exception e) {\n            e.printStackTrace();\n            throw new IllegalArgumentException(\"[\" + Thread.currentThread().getName()\n                    + \"] Problem when creating files for the experiment \" + configuration.getId());\n        }\n    }\n\n    public static Configuration getConfiguration(final Config mainConfig)\n            throws ParserConfigurationException, SAXException, IOException {\n        final Configuration config = new Configuration(mainConfig.getInt(\"simulation.seed\"));\n\n        config.setSuffix(mainConfig.getString(\"simulation.suffix\"));\n\n        config.setBaseFolder(mainConfig.getString(\"simulation.folder\"));\n\n        final List<Integer> l = mainConfig.getIntList(\"simulation.policies\");\n        final ProvisioningPolicy.Policy[] policies = new ProvisioningPolicy.Policy[l.size()];\n        for (int i = 0; i < l.size(); i++) {\n            policies[i] = ProvisioningPolicy.Policy.fromInteger(l.get(i));\n        }\n        config.setPolicies(policies);\n\n        config.setRhoProcessing(mainConfig.getDouble(\"simulation.rho-processing\"));\n\n        config.setRhoStorage(mainConfig.getDouble(\"simulation.rho-storage\"));\n\n        if (\"range\".equals(mainConfig.getString(\"simulation.load.type\").toLowerCase())) {\n            final Integer init = mainConfig.getInt(\"simulation.load.min\");\n            final Integer step = mainConfig.getInt(\"simulation.load.step\");\n            final Integer last = mainConfig.getInt(\"simulation.load.max\");\n            final int diff = (last - init) / step;\n            final Integer[] intValues = new Integer[diff + 1];\n            intValues[0] = init;\n            for (int i = 1; i < intValues.length; i++)\n                intValues[i] = init + step * i;\n            config.setLoads(intValues);\n        } else {\n            // TODO implement new load configurations\n            System.err.println(\"Load method not implemented!\");\n            throw new UnsupportedOperationException(\"Not supported yet.\"); // To change body of generated methods,\n                                                                           // choose Tools | Templates.\n        }\n\n        config.setWavelengthsPerFiber(mainConfig.getInt(\"simulation.resources-per-link\"));\n\n        config.setNumberThreads(mainConfig.getInt(\"simulation.threads\"));\n\n        config.setExperiments(mainConfig.getInt(\"simulation.experiments\"));\n\n        config.setNumberArrivals(mainConfig.getInt(\"simulation.arrivals\"));\n\n        config.setIgnoreFirst(mainConfig.getInt(\"simulation.ignore-first\"));\n\n        final String topologyFile = mainConfig.getString(\"simulation.topology\");\n\n        config.setNumberDatacenters(mainConfig.getInt(\"simulation.number-dcs\"));\n\n        config.setTopologyName(topologyFile.replace(\".xml\", \"\").replace(\".txt\", \"\"));\n\n        final Topology topo = readTopology(topologyFile, config);\n\n        config.setTopology(topo);\n\n        return config;\n    }\n\n    public static ArrayList<String> readFile(final String file) {\n        if (readFiles == null)\n            readFiles = new HashMap<>();\n        if (readFiles.containsKey(file))\n            return readFiles.get(file);\n\n        final ArrayList<String> array = new ArrayList<>();\n        try {\n            try (Stream<String> lines = Files.lines(Paths.get(file)).filter(s -> !s.startsWith(\"#\"));) {\n                for (final Object o : lines.toArray())\n                    array.add(o.toString());\n            }\n        } catch (final Exception e) {\n            e.printStackTrace();\n        }\n        readFiles.put(file, array);\n        return array;\n    }\n\n    private static Topology readTopology(final String topologyName, final Configuration configuration)\n            throws ParserConfigurationException, SAXException, IOException {\n        final String path = \"resources\" + File.separator + \"topologies\" + File.separator + topologyName;\n        Topology topology = null;\n\n        if (topologyName.endsWith(\".txt\")) {\n\n            final ArrayList<String> lines = readFile(path);\n\n            final int nNodes = Integer.parseInt(lines.get(0));\n            final int nLinks = Integer.parseInt(lines.get(1));\n            final int nDatacenters = Integer.parseInt(lines.get(2));\n\n            topology = new Topology(nNodes, nLinks, configuration);\n\n            // System.out.println(\"nLinks: \" + nLinks);\n            int node0;\n            int node1;\n            for (int link = 0; link < nLinks; link++) {\n                final String[] nodes = lines.get(link + 3).split(\" \");\n                node0 = Integer.parseInt(nodes[0]) - 1;\n                node1 = Integer.parseInt(nodes[1]) - 1;\n\n                topology.getLinks()[link].setSource(node0);\n                topology.getLinks()[link].setSourceNode(topology.getNodes()[node0]);\n                topology.getLinks()[link].setDestination(node1);\n                topology.getLinks()[link].setDestinationNode(topology.getNodes()[node1]);\n                topology.getLinks()[link].setWeight(1.0);\n\n                topology.getNodes()[node0].getLinks().add(topology.getLinks()[link]);\n                topology.getNodes()[node1].getLinks().add(topology.getLinks()[link]);\n\n                topology.getLinksVector()[node0][node1] = topology.getLinks()[link];\n                topology.getLinksVector()[node1][node0] = topology.getLinks()[link];\n\n            }\n\n            final String[] dcs = lines.get(nLinks + 3).split(\" \");\n\n            for (final String dc : dcs) {\n                final int i = Integer.parseInt(dc);\n                topology.getNodes()[i - 1].setDatacenter(true);\n                topology.addDC(topology.getNodes()[i - 1]);\n            }\n            configuration.setNumberDatacenters(nDatacenters);\n        } else if (topologyName.endsWith(\".xml\")) {\n            // TODO read from SNDlib\n\n            final File file = new File(path);\n            final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            final DocumentBuilder db = dbf.newDocumentBuilder();\n            final Document doc = db.parse(file);\n            doc.getDocumentElement().normalize();\n\n            final NodeList nodeList = doc.getElementsByTagName(\"node\");\n\n            final int nNodes = nodeList.getLength();\n\n            final NodeList linkList = doc.getElementsByTagName(\"link\");\n\n            final int nLinks = linkList.getLength();\n\n            topology = new Topology(nNodes, nLinks, configuration);\n\n            // nodeList is not iterable, so we are using for loop\n            for (int itr = 0; itr < nodeList.getLength(); itr++) {\n                final Node node = nodeList.item(itr);\n                final Element eElement = (Element) node;\n                final Element coordinates = (Element) eElement.getElementsByTagName(\"coordinates\").item(0);\n\n                topology.addNode(itr, node.getAttributes().getNamedItem(\"id\").getNodeValue(),\n                        Double.parseDouble(coordinates.getElementsByTagName(\"x\").item(0).getTextContent()),\n                        Double.parseDouble(coordinates.getElementsByTagName(\"y\").item(0).getTextContent()));\n            }\n\n            for (int itr = 0; itr < linkList.getLength(); itr++) {\n                final Node node = linkList.item(itr);\n                final Element eElement = (Element) node;\n                topology.addLink(itr, node.getAttributes().getNamedItem(\"id\").getNodeValue(),\n                        eElement.getElementsByTagName(\"source\").item(0).getTextContent(),\n                        eElement.getElementsByTagName(\"target\").item(0).getTextContent(), true);\n            }\n\n            // defining the placement of DCs\n            List<Object> dcs = Arrays.asList(topology.getNodes()).stream()\n                    .sorted((n1, n2) -> n2.getDegree().compareTo(n1.getDegree()))\n                    .limit(configuration.getNumberDatacenters()).collect(Collectors.toList());\n            for (final Object o : dcs) {\n                final simulator.cs.anycast.components.Node n = (simulator.cs.anycast.components.Node) o;\n                n.setDatacenter(true);\n                topology.addDC(n);\n            }\n        }\n\n        for (final Link link : topology.getLinks()) {\n            if (topology.getNodes()[link.getSource()].isDatacenter()\n                    || topology.getNodes()[link.getDestination()].isDatacenter())\n                link.setDCLink(true);\n        }\n\n        return topology;\n    }\n\n    /**\n     * Method to write the results for one single experiment. It uses file lock to\n     * prevent multiple writes at the same time\n     * \n     * @param configuration\n     * @param results\n     */\n    public static void reportExperimentStatistics(final Configuration configuration, final ArrayList<Double> results) {\n        try {\n            final Path path = Paths\n                    .get(configuration.getBaseFolder() + \"results-\" + configuration.getSuffix() + \".csv\");\n\n            String text = configuration.getConnectionManager().getPolicyName() + columnSeparator\n                    + configuration.getExperiment();\n            for (final Double res : results)\n                text += columnSeparator + format.format(res);\n            text += lineSeparator;\n\n            Files.write(path, text.getBytes(), StandardOpenOption.APPEND);\n\n        } catch (final Exception ex) {\n            ex.printStackTrace();\n            throw new IllegalArgumentException(\"[\" + Thread.currentThread().getName()\n                    + \"] Problem when creating experiment statistics files for the experiment \"\n                    + configuration.getId());\n        }\n\n    }\n\n    /**\n     * Method to write the final results for one experiment. It uses file lock to\n     * prevent multiple writes at the same time\n     * \n     * @param configuration\n     * @param results\n     */\n    public static void reportFinalStatistics(final Configuration configuration, final ArrayList<BigDecimal> results) {\n        try {\n\n            String text = configuration.getConnectionManager().getPolicyName();\n            for (final BigDecimal res : results)\n                text += columnSeparator + format.format(res);\n            text += lineSeparator;\n\n            Files.write(Paths.get(configuration.getBaseFolder() + \"results-avg-\" + configuration.getSuffix() + \".csv\"),\n                    text.getBytes(), StandardOpenOption.APPEND);\n\n        } catch (final Exception ex) {\n            ex.printStackTrace();\n            throw new IllegalArgumentException(\"[\" + Thread.currentThread().getName()\n                    + \"] Problem when creating final statistics files for the experiment \" + configuration.getId());\n        }\n\n    }\n\n    public static void copyFolder(final Path src, final Path dst) throws IOException {\n        Files.walk(src).forEach(source -> {\n            try {\n                Files.copy(src, dst.resolve(src.relativize(source)));\n            } catch (final IOException ex) {\n                Logger.getLogger(FileAgent.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        });\n    }\n    \n}", "class_id": 0, "repo": "igormaraujo/java-anycast-cs-simulator", "file": "src/main/java/simulator/cs/anycast/core/FileAgent.java", "last_update_at": "2020-02-28T13:01:19+00:00", "question_id": "3e27678292a92c3c3f4eaf18bb6319f84488535a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FileAgent {\n    // hash map that saves all the files already loaded by the simulator\n    // to avoid reading the same file multiple times.\n    private static HashMap<String, ArrayList<String>> readFiles;\n    public static DecimalFormat format;\n    public static DecimalFormat timeFormat;\n    public static final String columnSeparator = \",\";\n    private static final String lineSeparator = \"\\n\";\n    static {\n\tformat = new DecimalFormat(\"0\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n\tformat.setMinimumFractionDigits(1);\n\tformat.setMaximumFractionDigits(10);\n\ttimeFormat = new DecimalFormat(\"0\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n//\ttimeFormat.setMinimumFractionDigits(3);\n\ttimeFormat.setMaximumFractionDigits(0);\n    }\n    public static void init(final Configuration configuration) {\n        try {\n            String header = \"\";\n            for (int i = 0; i < StatisticsMonitor.headersExperimentFile.length; i++) {\n                header += StatisticsMonitor.headersExperimentFile[i];\n                if (i < StatisticsMonitor.headersExperimentFile.length - 1)\n                    header += columnSeparator;\n            }\n            header += lineSeparator;\n            Path path = Paths.get(configuration.getBaseFolder() + \"results-\" + configuration.getSuffix() + \".csv\");\n            Files.write(path, header.getBytes(), StandardOpenOption.CREATE_NEW);\n            header = \"\";\n            for (int i = 0; i < StatisticsMonitor.headersAverageFile.length; i++) {\n                header += StatisticsMonitor.headersAverageFile[i];\n                if (i < StatisticsMonitor.headersAverageFile.length - 1)\n                    header += columnSeparator;\n            }\n            header += lineSeparator;\n            path = Paths.get(configuration.getBaseFolder() + \"results-avg-\" + configuration.getSuffix() + \".csv\");\n            Files.write(path, header.getBytes(), StandardOpenOption.CREATE_NEW);\n        } catch (final Exception e) {\n            e.printStackTrace();\n            throw new IllegalArgumentException(\"[\" + Thread.currentThread().getName()\n                    + \"] Problem when creating files for the experiment \" + configuration.getId());\n        }\n    }\n    public static Configuration getConfiguration(final Config mainConfig)\n            throws ParserConfigurationException, SAXException, IOException {\n        final Configuration config = new Configuration(mainConfig.getInt(\"simulation.seed\"));\n        config.setSuffix(mainConfig.getString(\"simulation.suffix\"));\n        config.setBaseFolder(mainConfig.getString(\"simulation.folder\"));\n        final List<Integer> l = mainConfig.getIntList(\"simulation.policies\");\n        final ProvisioningPolicy.Policy[] policies = new ProvisioningPolicy.Policy[l.size()];\n        for (int i = 0; i < l.size(); i++) {\n            policies[i] = ProvisioningPolicy.Policy.fromInteger(l.get(i));\n        }\n        config.setPolicies(policies);\n        config.setRhoProcessing(mainConfig.getDouble(\"simulation.rho-processing\"));\n        config.setRhoStorage(mainConfig.getDouble(\"simulation.rho-storage\"));\n        if (\"range\".equals(mainConfig.getString(\"simulation.load.type\").toLowerCase())) {\n            final Integer init = mainConfig.getInt(\"simulation.load.min\");\n            final Integer step = mainConfig.getInt(\"simulation.load.step\");\n            final Integer last = mainConfig.getInt(\"simulation.load.max\");\n            final int diff = (last - init) / step;\n            final Integer[] intValues = new Integer[diff + 1];\n            intValues[0] = init;\n            for (int i = 1; i < intValues.length; i++)\n                intValues[i] = init + step * i;\n            config.setLoads(intValues);\n        } else {\n            // TODO implement new load configurations\n            System.err.println(\"Load method not implemented!\");\n            throw new UnsupportedOperationException(\"Not supported yet.\"); // To change body of generated methods,\n                                                                           // choose Tools | Templates.\n        }\n        config.setWavelengthsPerFiber(mainConfig.getInt(\"simulation.resources-per-link\"));\n        config.setNumberThreads(mainConfig.getInt(\"simulation.threads\"));\n        config.setExperiments(mainConfig.getInt(\"simulation.experiments\"));\n        config.setNumberArrivals(mainConfig.getInt(\"simulation.arrivals\"));\n        config.setIgnoreFirst(mainConfig.getInt(\"simulation.ignore-first\"));\n        final String topologyFile = mainConfig.getString(\"simulation.topology\");\n        config.setNumberDatacenters(mainConfig.getInt(\"simulation.number-dcs\"));\n        config.setTopologyName(topologyFile.replace(\".xml\", \"\").replace(\".txt\", \"\"));\n        final Topology topo = readTopology(topologyFile, config);\n        config.setTopology(topo);\n        return config;\n    }\n    public static ArrayList<String> readFile(final String file) {\n        if (readFiles == null)\n            readFiles = new HashMap<>();\n        if (readFiles.containsKey(file))\n            return readFiles.get(file);\n        final ArrayList<String> array = new ArrayList<>();\n        try {\n            try (Stream<String> lines = Files.lines(Paths.get(file)).filter(s -> !s.startsWith(\"#\"));) {\n                for (final Object o : lines.toArray())\n                    array.add(o.toString());\n            }\n        } catch (final Exception e) {\n            e.printStackTrace();\n        }\n        readFiles.put(file, array);\n        return array;\n    }\n    private static Topology readTopology(final String topologyName, final Configuration configuration)\n            throws ParserConfigurationException, SAXException, IOException {\n        final String path = \"resources\" + File.separator + \"topologies\" + File.separator + topologyName;\n        Topology topology = null;\n        if (topologyName.endsWith(\".txt\")) {\n            final ArrayList<String> lines = readFile(path);\n            final int nNodes = Integer.parseInt(lines.get(0));\n            final int nLinks = Integer.parseInt(lines.get(1));\n            final int nDatacenters = Integer.parseInt(lines.get(2));\n            topology = new Topology(nNodes, nLinks, configuration);\n            // System.out.println(\"nLinks: \" + nLinks);\n            int node0;\n            int node1;\n            for (int link = 0; link < nLinks; link++) {\n                final String[] nodes = lines.get(link + 3).split(\" \");\n                node0 = Integer.parseInt(nodes[0]) - 1;\n                node1 = Integer.parseInt(nodes[1]) - 1;\n                topology.getLinks()[link].setSource(node0);\n                topology.getLinks()[link].setSourceNode(topology.getNodes()[node0]);\n                topology.getLinks()[link].setDestination(node1);\n                topology.getLinks()[link].setDestinationNode(topology.getNodes()[node1]);\n                topology.getLinks()[link].setWeight(1.0);\n                topology.getNodes()[node0].getLinks().add(topology.getLinks()[link]);\n                topology.getNodes()[node1].getLinks().add(topology.getLinks()[link]);\n                topology.getLinksVector()[node0][node1] = topology.getLinks()[link];\n                topology.getLinksVector()[node1][node0] = topology.getLinks()[link];\n            }\n            final String[] dcs = lines.get(nLinks + 3).split(\" \");\n            for (final String dc : dcs) {\n                final int i = Integer.parseInt(dc);\n                topology.getNodes()[i - 1].setDatacenter(true);\n                topology.addDC(topology.getNodes()[i - 1]);\n            }\n            configuration.setNumberDatacenters(nDatacenters);\n        } else if (topologyName.endsWith(\".xml\")) {\n            // TODO read from SNDlib\n            final File file = new File(path);\n            final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            final DocumentBuilder db = dbf.newDocumentBuilder();\n            final Document doc = db.parse(file);\n            doc.getDocumentElement().normalize();\n            final NodeList nodeList = doc.getElementsByTagName(\"node\");\n            final int nNodes = nodeList.getLength();\n            final NodeList linkList = doc.getElementsByTagName(\"link\");\n            final int nLinks = linkList.getLength();\n            topology = new Topology(nNodes, nLinks, configuration);\n            // nodeList is not iterable, so we are using for loop\n            for (int itr = 0; itr < nodeList.getLength(); itr++) {\n                final Node node = nodeList.item(itr);\n                final Element eElement = (Element) node;\n                final Element coordinates = (Element) eElement.getElementsByTagName(\"coordinates\").item(0);\n                topology.addNode(itr, node.getAttributes().getNamedItem(\"id\").getNodeValue(),\n                        Double.parseDouble(coordinates.getElementsByTagName(\"x\").item(0).getTextContent()),\n                        Double.parseDouble(coordinates.getElementsByTagName(\"y\").item(0).getTextContent()));\n            }\n            for (int itr = 0; itr < linkList.getLength(); itr++) {\n                final Node node = linkList.item(itr);\n                final Element eElement = (Element) node;\n                topology.addLink(itr, node.getAttributes().getNamedItem(\"id\").getNodeValue(),\n                        eElement.getElementsByTagName(\"source\").item(0).getTextContent(),\n                        eElement.getElementsByTagName(\"target\").item(0).getTextContent(), true);\n            }\n            // defining the placement of DCs\n            List<Object> dcs = Arrays.asList(topology.getNodes()).stream()\n                    .sorted((n1, n2) -> n2.getDegree().compareTo(n1.getDegree()))\n                    .limit(configuration.getNumberDatacenters()).collect(Collectors.toList());\n            for (final Object o : dcs) {\n                final simulator.cs.anycast.components.Node n = (simulator.cs.anycast.components.Node) o;\n                n.setDatacenter(true);\n                topology.addDC(n);\n            }\n        }\n        for (final Link link : topology.getLinks()) {\n            if (topology.getNodes()[link.getSource()].isDatacenter()\n                    || topology.getNodes()[link.getDestination()].isDatacenter())\n                link.setDCLink(true);\n        }\n        return topology;\n    }\n    /**\n     * Method to write the results for one single experiment. It uses file lock to\n     * prevent multiple writes at the same time\n     * \n     * @param configuration\n     * @param results\n     */\n    public static void reportExperimentStatistics(final Configuration configuration, final ArrayList<Double> results) {\n        try {\n            final Path path = Paths\n                    .get(configuration.getBaseFolder() + \"results-\" + configuration.getSuffix() + \".csv\");\n            String text = configuration.getConnectionManager().getPolicyName() + columnSeparator\n                    + configuration.getExperiment();\n            for (final Double res : results)\n                text += columnSeparator + format.format(res);\n            text += lineSeparator;\n            Files.write(path, text.getBytes(), StandardOpenOption.APPEND);\n        } catch (final Exception ex) {\n            ex.printStackTrace();\n            throw new IllegalArgumentException(\"[\" + Thread.currentThread().getName()\n                    + \"] Problem when creating experiment statistics files for the experiment \"\n                    + configuration.getId());\n        }\n    }\n    /**\n     * Method to write the final results for one experiment. It uses file lock to\n     * prevent multiple writes at the same time\n     * \n     * @param configuration\n     * @param results\n     */\n    public static void reportFinalStatistics(final Configuration configuration, final ArrayList<BigDecimal> results) {\n        try {\n            String text = configuration.getConnectionManager().getPolicyName();\n            for (final BigDecimal res : results)\n                text += columnSeparator + format.format(res);\n            text += lineSeparator;\n            Files.write(Paths.get(configuration.getBaseFolder() + \"results-avg-\" + configuration.getSuffix() + \".csv\"),\n                    text.getBytes(), StandardOpenOption.APPEND);\n        } catch (final Exception ex) {\n            ex.printStackTrace();\n            throw new IllegalArgumentException(\"[\" + Thread.currentThread().getName()\n                    + \"] Problem when creating final statistics files for the experiment \" + configuration.getId());\n        }\n    }\n    public static void copyFolder(final Path src, final Path dst) throws IOException {\n        Files.walk(src).forEach(source -> {\n            try {\n                Files.copy(src, dst.resolve(src.relativize(source)));\n            } catch (final IOException ex) {\n                Logger.getLogger(FileAgent.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        });\n    }\n"]]}
{"hexsha": "cda8468b012872dd90533ea71dc6494f3a2c21a2", "ext": "java", "lang": "Java", "content": "public class SerializeDeserializeBinarySearchTree {\n    // Encodes a tree to a single string.\n    // T:O(n), S:O(n)\n    public String serialize(TreeNode root) {\n        // preorder traverse\n        StringBuilder builder = new StringBuilder();\n        dfsSerialize(root, builder);\n        // System.out.println(builder.toString());\n        return builder.toString();\n    }\n\n    public void dfsSerialize(TreeNode node, StringBuilder builder) {\n        if (node == null) return;\n\n        builder.append(node.val);\n        if(node.left != null) {\n            builder.append(\",\");\n            dfsSerialize(node.left, builder);\n        }\n\n        if(node.right != null) {\n            builder.append(\",\");\n            dfsSerialize(node.right, builder);\n        }\n    }\n\n    // Decodes your encoded data to tree.\n    // T:O(n), S:O(n)\n    public TreeNode deserialize(String data) {\n        if (data == null || data.length() == 0) return null;\n\n        // \"2,1,3\"\n        String[] array = data.split(\",\");\n        Queue<Integer> q = new LinkedList<>();\n        for (String s: array) {\n            q.offer(Integer.parseInt(s));\n        }\n        // [2,1,3]\n        return dfsDeserialize(q, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }\n\n    public TreeNode dfsDeserialize(Queue<Integer> q, int min, int max) {\n        if (q.isEmpty()) return null;\n\n        int val = q.peek();\n        if (min > val || val > max) return null;\n\n        TreeNode node = new TreeNode(q.poll());\n        node.left = dfsDeserialize(q, min, node.val);\n        node.right = dfsDeserialize(q, node.val, max);\n        /**\n         2\n         left = dfsDeserialize([1,3], MIN_VALUE, 2);\n         1\n         left = dfsDeserialize([3], MIN_VALUE, 1);\n         right = dfsDeserialize([1,3], MIN_VALUE, 2);\n         */\n\n        return node;\n    }\n}", "class_id": 0, "repo": "booknara/playground", "file": "src/main/java/com/booknara/problem/tree/bst/SerializeDeserializeBinarySearchTree.java", "last_update_at": "2020-02-23T18:36:17+00:00", "question_id": "cda8468b012872dd90533ea71dc6494f3a2c21a2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SerializeDeserializeBinarySearchTree {\n    // Encodes a tree to a single string.\n    // T:O(n), S:O(n)\n    public String serialize(TreeNode root) {\n        // preorder traverse\n        StringBuilder builder = new StringBuilder();\n        dfsSerialize(root, builder);\n        // System.out.println(builder.toString());\n        return builder.toString();\n    }\n    public void dfsSerialize(TreeNode node, StringBuilder builder) {\n        if (node == null) return;\n        builder.append(node.val);\n        if(node.left != null) {\n            builder.append(\",\");\n            dfsSerialize(node.left, builder);\n        }\n        if(node.right != null) {\n            builder.append(\",\");\n            dfsSerialize(node.right, builder);\n        }\n    }\n    // Decodes your encoded data to tree.\n    // T:O(n), S:O(n)\n    public TreeNode deserialize(String data) {\n        if (data == null || data.length() == 0) return null;\n        // \"2,1,3\"\n        String[] array = data.split(\",\");\n        Queue<Integer> q = new LinkedList<>();\n        for (String s: array) {\n            q.offer(Integer.parseInt(s));\n        }\n        // [2,1,3]\n        return dfsDeserialize(q, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }\n    public TreeNode dfsDeserialize(Queue<Integer> q, int min, int max) {\n        if (q.isEmpty()) return null;\n        int val = q.peek();\n        if (min > val || val > max) return null;\n        TreeNode node = new TreeNode(q.poll());\n        node.left = dfsDeserialize(q, min, node.val);\n        node.right = dfsDeserialize(q, node.val, max);\n        /**\n         2\n         left = dfsDeserialize([1,3], MIN_VALUE, 2);\n         1\n         left = dfsDeserialize([3], MIN_VALUE, 1);\n         right = dfsDeserialize([1,3], MIN_VALUE, 2);\n         */\n        return node;\n    }\n"]]}
{"hexsha": "30a3925b18a09100470333dd45e84f4cebf2057a", "ext": "java", "lang": "Java", "content": "@ApplicationScoped\npublic class StudyFormBean {\n\n    @PersistenceContext(unitName = \"sis-jpa\")\n    private EntityManager em;\n\n    @Transactional\n    public List<StudyForm> getStudyForms(QueryParameters query) {\n        return JPAUtils.queryEntities(em, StudyForm.class, query);\n    }\n\n    @Transactional\n    public List<StudyForm> getStudyForms(QueryParameters query, String searchQuery) {\n        if(searchQuery == null) return getStudyForms(query);\n        return JPAUtils.queryEntities(em, StudyForm.class, query, new SearchAllCriteriaFilter<>(searchQuery));\n    }\n\n    @Transactional\n    public StudyForm getStudyForm(int id) {\n        StudyForm c = em.find(StudyForm.class, id);\n        if(c == null) throw new NoResultException(\"No study kind by this id\");\n        return c;\n    }\n\n    @Transactional\n    public boolean existsStudyForm(int id) {\n        return em.find(StudyForm.class, id) != null;\n    }\n\n    @Transactional\n    public StudyForm insertStudyForm(StudyForm c) {\n        em.persist(c);\n        em.flush();\n        return c;\n    }\n\n    @Transactional\n    public void deleteStudyForm(int id) {\n        StudyForm c = em.find(StudyForm.class, id);\n        if(c != null) {\n            c.setDeleted(!c.getDeleted());\n            em.merge(c);\n        } else {\n            throw new NoResultException(\"Course by ID doesn't exist\");\n        }\n    }\n\n    @Transactional\n    public StudyForm updateStudyForm(StudyForm c) {\n        em.merge(c);\n        em.flush();\n        return c;\n    }\n\n}", "class_id": 0, "repo": "matejklemen/sis-backend", "file": "services/src/main/java/beans/crud/StudyFormBean.java", "last_update_at": "2020-11-04T20:53:28+00:00", "question_id": "30a3925b18a09100470333dd45e84f4cebf2057a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ApplicationScoped\npublic class StudyFormBean {\n    @PersistenceContext(unitName = \"sis-jpa\")\n    private EntityManager em;\n    @Transactional\n    public List<StudyForm> getStudyForms(QueryParameters query) {\n        return JPAUtils.queryEntities(em, StudyForm.class, query);\n    }\n    @Transactional\n    public List<StudyForm> getStudyForms(QueryParameters query, String searchQuery) {\n        if(searchQuery == null) return getStudyForms(query);\n        return JPAUtils.queryEntities(em, StudyForm.class, query, new SearchAllCriteriaFilter<>(searchQuery));\n    }\n    @Transactional\n    public StudyForm getStudyForm(int id) {\n        StudyForm c = em.find(StudyForm.class, id);\n        if(c == null) throw new NoResultException(\"No study kind by this id\");\n        return c;\n    }\n    @Transactional\n    public boolean existsStudyForm(int id) {\n        return em.find(StudyForm.class, id) != null;\n    }\n    @Transactional\n    public StudyForm insertStudyForm(StudyForm c) {\n        em.persist(c);\n        em.flush();\n        return c;\n    }\n    @Transactional\n    public void deleteStudyForm(int id) {\n        StudyForm c = em.find(StudyForm.class, id);\n        if(c != null) {\n            c.setDeleted(!c.getDeleted());\n            em.merge(c);\n        } else {\n            throw new NoResultException(\"Course by ID doesn't exist\");\n        }\n    }\n    @Transactional\n    public StudyForm updateStudyForm(StudyForm c) {\n        em.merge(c);\n        em.flush();\n        return c;\n    }\n"]]}
{"hexsha": "06a8d357be1d914b766b8791d5b07ad9c13f2a7a", "ext": "java", "lang": "Java", "content": "@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class CompanyTest {\n\n    @Autowired\n    private CompanyRepository companyRepo;\n\n    @Test\n    public void companyRepositoryIsCreated() {\n        assertNotNull(companyRepo);\n    }\n\n    @Test\n    public void companyMustHaveId() {\n        Company company = new Company();\n        assertThrows(JpaSystemException.class, () -> companyRepo.save(company));\n    }\n\n    @Test\n    public void companyWithIdCanBeAddedToDB() {\n        Company company = new Company();\n        company.setCompanyName(\"BedCompany\");\n        assertDoesNotThrow(() -> companyRepo.save(company));\n    }\n\n    @Test\n    public void companyCanBeFetchedFromDB() {\n        Company company = new Company();\n        company.setCompanyName(\"BedCompany\");\n        companyRepo.save(company);\n        Company dbCompany = companyRepo.findById(\"BedCompany\").get();\n        assertEquals(company.getCompanyName(), dbCompany.getCompanyName());\n    }\n\n    public Presentation addPresentationToCompany() {\n        Company company = new Company();\n        company.setCompanyName(\"BedCompany\");\n\n        Set<Presentation> presentations = new HashSet<>();\n        Presentation p = new Presentation();\n        p.setId(1);\n        p.setDateOfPresentation(new Date());\n        p.setCompanyPresenting(company);\n        presentations.add(p);\n        company.setPresentations(presentations);\n        companyRepo.save(company);\n        return p;\n    }\n\n    public int iteratorCount(Iterator iterator) {\n        int count = 0;\n        while (iterator.hasNext()) {\n            iterator.next();\n            count++;\n        }\n        return count;\n    }\n\n    @Test\n    public void addingPresentationToCompanyAddsOne() {\n        addPresentationToCompany();\n        assertEquals(1, companyRepo.findById(\"BedCompany\").get().getPresentations().size());\n    }\n\n    @Test\n    public void canFindPresentationsRelatedToCompany() {\n        Presentation pres = addPresentationToCompany();\n        Presentation stored = companyRepo.findById(\"BedCompany\").get().getPresentations().iterator().next();\n\n        // Check that date is the same, needs to be compare to because formats can be different\n        //assertEquals(0, stored.getDateOfPresentation().compareTo(pres.getDateOfPresentation()));\n\n        // Check that presenting company is the same\n        assertEquals(stored.getCompanyPresenting().getCompanyName(), pres.getCompanyPresenting().getCompanyName());\n    }\n}", "class_id": 0, "repo": "EirinS/DAT251-company-presentation", "file": "src/test/java/com/presentation/CompanyTest.java", "last_update_at": "2020-04-02T17:36:16+00:00", "question_id": "06a8d357be1d914b766b8791d5b07ad9c13f2a7a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class CompanyTest {\n    @Autowired\n    private CompanyRepository companyRepo;\n    @Test\n    public void companyRepositoryIsCreated() {\n        assertNotNull(companyRepo);\n    }\n    @Test\n    public void companyMustHaveId() {\n        Company company = new Company();\n        assertThrows(JpaSystemException.class, () -> companyRepo.save(company));\n    }\n    @Test\n    public void companyWithIdCanBeAddedToDB() {\n        Company company = new Company();\n        company.setCompanyName(\"BedCompany\");\n        assertDoesNotThrow(() -> companyRepo.save(company));\n    }\n    @Test\n    public void companyCanBeFetchedFromDB() {\n        Company company = new Company();\n        company.setCompanyName(\"BedCompany\");\n        companyRepo.save(company);\n        Company dbCompany = companyRepo.findById(\"BedCompany\").get();\n        assertEquals(company.getCompanyName(), dbCompany.getCompanyName());\n    }\n    public Presentation addPresentationToCompany() {\n        Company company = new Company();\n        company.setCompanyName(\"BedCompany\");\n        Set<Presentation> presentations = new HashSet<>();\n        Presentation p = new Presentation();\n        p.setId(1);\n        p.setDateOfPresentation(new Date());\n        p.setCompanyPresenting(company);\n        presentations.add(p);\n        company.setPresentations(presentations);\n        companyRepo.save(company);\n        return p;\n    }\n    public int iteratorCount(Iterator iterator) {\n        int count = 0;\n        while (iterator.hasNext()) {\n            iterator.next();\n            count++;\n        }\n        return count;\n    }\n    @Test\n    public void addingPresentationToCompanyAddsOne() {\n        addPresentationToCompany();\n        assertEquals(1, companyRepo.findById(\"BedCompany\").get().getPresentations().size());\n    }\n    @Test\n    public void canFindPresentationsRelatedToCompany() {\n        Presentation pres = addPresentationToCompany();\n        Presentation stored = companyRepo.findById(\"BedCompany\").get().getPresentations().iterator().next();\n        // Check that date is the same, needs to be compare to because formats can be different\n        //assertEquals(0, stored.getDateOfPresentation().compareTo(pres.getDateOfPresentation()));\n        // Check that presenting company is the same\n        assertEquals(stored.getCompanyPresenting().getCompanyName(), pres.getCompanyPresenting().getCompanyName());\n    }\n"]]}
{"hexsha": "805c4d4e971b543d87c1fc83a49815496ed5bdc6", "ext": "java", "lang": "Java", "content": "public final class CharUtil {\n    private CharUtil() {\n        noInstanceError();\n    }\n\n    public static final int indexOf(final char[] src, final char[] test) {\n        return indexOf(src, test, 0);\n    }\n\n    public static final int indexOf(final char[] src, final char[] test, int fromIndex) {\n        BooleanUtil.requireFalse(fromIndex < 0);\n\n        if (src == test) {\n            return fromIndex > 0 ? -1 : 0;\n        }\n\n        final int l1 = src.length, l2 = test.length;\n        if (fromIndex == l1) {\n            return -1;\n        }\n        BooleanUtil.requireTrue(fromIndex < l1);\n\n        if (l2 == 0) {\n            return fromIndex;\n        }\n\n        if (l2 > l1) {\n            return -1;\n        }\n\n        final char first = test[0];\n        for (int i = fromIndex, idx; i < l1; i++) {\n            if (src[i] == first) {\n                idx = 1;\n                for (; idx < l2; idx++) {\n                    if (src[idx + i] != test[idx]) {\n                        break;\n                    }\n                }\n                if (idx >= l2) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * \"[4e00-9fa5]\"\n     *\n     * @param ch\n     * @return\n     */\n    public static final boolean isChinese(int ch) {\n        return ch < 40870 && ch > 19967;\n    }\n\n    public static final boolean isLetterOrDigit(int ch) {\n        return isDigit(ch) || isLetter(ch);\n    }\n\n    /**\n     * A-Z,a-z\n     *\n     * @param ch\n     * @return\n     */\n    public static final boolean isLetter(int ch) {\n        return isLowerCase(ch) || isUpperCase(ch);\n    }\n\n    /**\n     * A-Z\n     *\n     * @param ch\n     * @return\n     */\n    public static final boolean isUpperCase(int ch) {\n        return ch > 64 && ch < 91;\n    }\n\n    /**\n     * a-z\n     *\n     * @param ch\n     * @return\n     */\n    public static final boolean isLowerCase(int ch) {\n        return ch > 96 && ch < 123;\n    }\n\n    /**\n     * 0-9\n     *\n     * @param ch\n     * @return\n     */\n    public static final boolean isDigit(int ch) {\n        return ch > 47 && ch < 58;\n    }\n\n    public static final boolean equalsIgnoreCase(int ch1, int ch2) {\n        if (ch1 == ch2) {\n            return true;\n        }\n        if (isLowerCase(ch1) && isUpperCase(ch2)) {\n            return ch1 - 32 == ch2;\n        }\n        if (isUpperCase(ch1) && isLowerCase(ch2)) {\n            return ch2 - 32 == ch1;\n        }\n        return false;\n    }\n\n    public static final boolean isASCIICode(int ch) {\n        return ch < 128;\n    }\n\n    public static boolean isChar(Object o) {\n        return o != null && o.getClass() == Character.class;\n    }\n\n    public static char toCharValue(Boolean bool) {\n        return (char) (bool == null || !bool ? 48 : 49);\n    }\n\n    public static char toCharValue(long value) {\n        return (char) value;\n    }\n\n    public static char toCharValue(float value) {\n        return (char) value;\n    }\n\n    public static char toCharValue(double value) {\n        return (char) value;\n    }\n\n    public static char toCharValue(CharSequence cs) {\n        if (cs == null) {\n            throw new IllegalArgumentException(\n                String.format(\"Can not cast to char of: %s\", cs));\n        }\n        String temp = cs.toString();\n        if (temp.length() == 1) {\n            return temp.charAt(0);\n        }\n        throw new IllegalArgumentException(\n            String.format(\"Can not cast to char of: %s\", cs));\n    }\n\n    /**\n     * @param o\n     * @return\n     * @see IntUtil#toIntValue(Object)\n     */\n    public static char toCharValue(Object o) {\n        if (o == null) {\n            return 0;\n        }\n        if (o instanceof Character) {\n            return (Character) o;\n        }\n        if (o instanceof Number) {\n            return (char) ((Number) o).intValue();\n        }\n        if (o instanceof CharSequence) {\n            return toCharValue(o.toString());\n        }\n        if (o instanceof Boolean) {\n            boolean bool = (boolean) o;\n            return (char) (bool ? 49 : 48);\n        }\n        try {\n            Object firstItem = SupportUtil.onlyOneItemOrSize(o);\n            return toCharValue(firstItem);\n        } catch (Exception e) {\n            throw new IllegalArgumentException(String.format(\"Can not cast to char of: %s\", o), e);\n        }\n    }\n}", "class_id": 0, "repo": "thekingcl/https-github.com-xua744531854-moon-util", "file": "src/main/java/com/moon/lang/CharUtil.java", "last_update_at": "2020-05-24T07:22:42+00:00", "question_id": "805c4d4e971b543d87c1fc83a49815496ed5bdc6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class CharUtil {\n    private CharUtil() {\n        noInstanceError();\n    }\n    public static final int indexOf(final char[] src, final char[] test) {\n        return indexOf(src, test, 0);\n    }\n    public static final int indexOf(final char[] src, final char[] test, int fromIndex) {\n        BooleanUtil.requireFalse(fromIndex < 0);\n        if (src == test) {\n            return fromIndex > 0 ? -1 : 0;\n        }\n        final int l1 = src.length, l2 = test.length;\n        if (fromIndex == l1) {\n            return -1;\n        }\n        BooleanUtil.requireTrue(fromIndex < l1);\n        if (l2 == 0) {\n            return fromIndex;\n        }\n        if (l2 > l1) {\n            return -1;\n        }\n        final char first = test[0];\n        for (int i = fromIndex, idx; i < l1; i++) {\n            if (src[i] == first) {\n                idx = 1;\n                for (; idx < l2; idx++) {\n                    if (src[idx + i] != test[idx]) {\n                        break;\n                    }\n                }\n                if (idx >= l2) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n    /**\n     * \"[4e00-9fa5]\"\n     *\n     * @param ch\n     * @return\n     */\n    public static final boolean isChinese(int ch) {\n        return ch < 40870 && ch > 19967;\n    }\n    public static final boolean isLetterOrDigit(int ch) {\n        return isDigit(ch) || isLetter(ch);\n    }\n    /**\n     * A-Z,a-z\n     *\n     * @param ch\n     * @return\n     */\n    public static final boolean isLetter(int ch) {\n        return isLowerCase(ch) || isUpperCase(ch);\n    }\n    /**\n     * A-Z\n     *\n     * @param ch\n     * @return\n     */\n    public static final boolean isUpperCase(int ch) {\n        return ch > 64 && ch < 91;\n    }\n    /**\n     * a-z\n     *\n     * @param ch\n     * @return\n     */\n    public static final boolean isLowerCase(int ch) {\n        return ch > 96 && ch < 123;\n    }\n    /**\n     * 0-9\n     *\n     * @param ch\n     * @return\n     */\n    public static final boolean isDigit(int ch) {\n        return ch > 47 && ch < 58;\n    }\n    public static final boolean equalsIgnoreCase(int ch1, int ch2) {\n        if (ch1 == ch2) {\n            return true;\n        }\n        if (isLowerCase(ch1) && isUpperCase(ch2)) {\n            return ch1 - 32 == ch2;\n        }\n        if (isUpperCase(ch1) && isLowerCase(ch2)) {\n            return ch2 - 32 == ch1;\n        }\n        return false;\n    }\n    public static final boolean isASCIICode(int ch) {\n        return ch < 128;\n    }\n    public static boolean isChar(Object o) {\n        return o != null && o.getClass() == Character.class;\n    }\n    public static char toCharValue(Boolean bool) {\n        return (char) (bool == null || !bool ? 48 : 49);\n    }\n    public static char toCharValue(long value) {\n        return (char) value;\n    }\n    public static char toCharValue(float value) {\n        return (char) value;\n    }\n    public static char toCharValue(double value) {\n        return (char) value;\n    }\n    public static char toCharValue(CharSequence cs) {\n        if (cs == null) {\n            throw new IllegalArgumentException(\n                String.format(\"Can not cast to char of: %s\", cs));\n        }\n        String temp = cs.toString();\n        if (temp.length() == 1) {\n            return temp.charAt(0);\n        }\n        throw new IllegalArgumentException(\n            String.format(\"Can not cast to char of: %s\", cs));\n    }\n    /**\n     * @param o\n     * @return\n     * @see IntUtil#toIntValue(Object)\n     */\n    public static char toCharValue(Object o) {\n        if (o == null) {\n            return 0;\n        }\n        if (o instanceof Character) {\n            return (Character) o;\n        }\n        if (o instanceof Number) {\n            return (char) ((Number) o).intValue();\n        }\n        if (o instanceof CharSequence) {\n            return toCharValue(o.toString());\n        }\n        if (o instanceof Boolean) {\n            boolean bool = (boolean) o;\n            return (char) (bool ? 49 : 48);\n        }\n        try {\n            Object firstItem = SupportUtil.onlyOneItemOrSize(o);\n            return toCharValue(firstItem);\n        } catch (Exception e) {\n            throw new IllegalArgumentException(String.format(\"Can not cast to char of: %s\", o), e);\n        }\n    }\n"]]}
{"hexsha": "05fa1547b47408246c078969b839aa65476648b3", "ext": "java", "lang": "Java", "content": "public class ClipUri extends ClipContent {\n\n    @NonNull\n    public Uri uri;\n\n    public ClipUri(@NonNull String mimeType, @NonNull Uri uri) {\n        super(mimeType);\n        this.uri = uri;\n    }\n\n    public ClipUri(@NonNull Uri uri) {\n        super(ClipDescription.MIMETYPE_TEXT_URILIST);\n        this.uri = uri;\n    }\n\n    public ClipUri(@NonNull ContentResolver resolver, @NonNull Uri uri) {\n        super(getMimeTypes(resolver, uri)[0]);\n        this.uri = uri;\n    }\n\n    /**\n     * Finds all applicable MIME types for a given URI.\n     *\n     * @param resolver ContentResolver used to get information about the URI.\n     * @param uri      The URI.\n     * @return Returns an array of MIME types.\n     */\n    public static String[] getMimeTypes(ContentResolver resolver, Uri uri) {\n        String[] mimeTypes = null;\n        if (ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())) {\n            String realType = resolver.getType(uri);\n            mimeTypes = resolver.getStreamTypes(uri, \"*/*\");\n            if (realType != null) {\n                if (mimeTypes == null) {\n                    mimeTypes = new String[]{realType};\n                } else if (!Arrays.asList(mimeTypes).contains(realType)) {\n                    String[] tmp = new String[mimeTypes.length + 1];\n                    tmp[0] = realType;\n                    System.arraycopy(mimeTypes, 0, tmp, 1, mimeTypes.length);\n                    mimeTypes = tmp;\n                }\n            }\n        }\n        if (mimeTypes == null) {\n            mimeTypes = new String[]{ClipDescription.MIMETYPE_TEXT_URILIST};\n        }\n        return mimeTypes;\n    }\n\n    @Override\n    public ClipData.Item toItem() {\n        return new ClipData.Item(uri);\n    }\n}", "class_id": 0, "repo": "panpf/tools4a", "file": "tools4a-clipboard/src/main/java/com/github/panpf/tools4a/clipboard/ClipUri.java", "last_update_at": "2020-09-01T02:40:54+00:00", "question_id": "05fa1547b47408246c078969b839aa65476648b3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ClipUri extends ClipContent {\n    @NonNull\n    public Uri uri;\n    public ClipUri(@NonNull String mimeType, @NonNull Uri uri) {\n        super(mimeType);\n        this.uri = uri;\n    }\n    public ClipUri(@NonNull Uri uri) {\n        super(ClipDescription.MIMETYPE_TEXT_URILIST);\n        this.uri = uri;\n    }\n    public ClipUri(@NonNull ContentResolver resolver, @NonNull Uri uri) {\n        super(getMimeTypes(resolver, uri)[0]);\n        this.uri = uri;\n    }\n    /**\n     * Finds all applicable MIME types for a given URI.\n     *\n     * @param resolver ContentResolver used to get information about the URI.\n     * @param uri      The URI.\n     * @return Returns an array of MIME types.\n     */\n    public static String[] getMimeTypes(ContentResolver resolver, Uri uri) {\n        String[] mimeTypes = null;\n        if (ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())) {\n            String realType = resolver.getType(uri);\n            mimeTypes = resolver.getStreamTypes(uri, \"*/*\");\n            if (realType != null) {\n                if (mimeTypes == null) {\n                    mimeTypes = new String[]{realType};\n                } else if (!Arrays.asList(mimeTypes).contains(realType)) {\n                    String[] tmp = new String[mimeTypes.length + 1];\n                    tmp[0] = realType;\n                    System.arraycopy(mimeTypes, 0, tmp, 1, mimeTypes.length);\n                    mimeTypes = tmp;\n                }\n            }\n        }\n        if (mimeTypes == null) {\n            mimeTypes = new String[]{ClipDescription.MIMETYPE_TEXT_URILIST};\n        }\n        return mimeTypes;\n    }\n    @Override\n    public ClipData.Item toItem() {\n        return new ClipData.Item(uri);\n    }\n"]]}
{"hexsha": "dbc1f1360d07506bd7e7b44ef86461cf34cc1bd6", "ext": "java", "lang": "Java", "content": "public class BostonHouseRegression {\n    public static List<DataSet> loadHousePrice(File file) throws IOException {\n        BufferedReader br = new BufferedReader(new FileReader(file));\n        String line = null;\n        List<DataSet> totalDataSetList = new LinkedList<DataSet>();\n        while( (line = br.readLine()) != null ){\n            String[] token = line.split(\",\");\n            double[] featureArray = new double[token.length - 1];\n            double[] labelArray = new double[1];\n            for( int i = 0; i < token.length - 1; ++i ){\n                featureArray[i] = Double.parseDouble(token[i]);\n            }\n            labelArray[0] = Double.parseDouble(token[token.length - 1]);\n            //\n            INDArray featureNDArray = Nd4j.create(featureArray);\n            INDArray labelNDArray = Nd4j.create(labelArray);\n            totalDataSetList.add(new DataSet(featureNDArray, labelNDArray));\n        }\n        br.close();\n        return totalDataSetList;\n}\n    \n    public static MultiLayerNetwork model(){\n        MultiLayerConfiguration.Builder builder = new NeuralNetConfiguration.Builder()\n                        .seed(12345L)\n                        .updater(new Adam(0.01))\n                        .weightInit(WeightInit.XAVIER)\n                        .optimizationAlgo(OptimizationAlgorithm.STOCHASTIC_GRADIENT_DESCENT)\n                        .list()\n                        .layer(0, new DenseLayer.Builder().activation(Activation.LEAKYRELU)\n                                        .nIn(13).nOut(10).build())\n                        .layer(1, new OutputLayer.Builder(LossFunctions.LossFunction.MEAN_SQUARED_LOGARITHMIC_ERROR)\n                                        .activation(Activation.IDENTITY)\n                                        .nIn(10).nOut(1).build());\n        MultiLayerConfiguration conf = builder.build();\n        MultiLayerNetwork model = new MultiLayerNetwork(conf);\n        model.init();\n        return model;      \n}\n    \n    \n    public static void main(String[] args) throws IOException {\n        final int batchSize = 4;\n        final long SEED = 1234L;\n        final int trainSize = 400;\n        List<DataSet> housePriceList = loadHousePrice(new File(\"house_price.csv\"));\n        //\u83b7\u53d6\u5168\u90e8\u6570\u636e\u5e76\u4e14\u6253\u4e71\u987a\u5e8f\n        DataSet allData = DataSet.merge(housePriceList);\n        allData.shuffle(SEED);\n        //\u5212\u5206\u8bad\u7ec3\u96c6\u548c\u9a8c\u8bc1\u96c6\n        SplitTestAndTrain split = allData.splitTestAndTrain(trainSize);\n        DataSet dsTrain = split.getTrain();\n        DataSet dsTest = split.getTest();\n        DataSetIterator trainIter = new ListDataSetIterator(dsTrain.asList() , batchSize);\n        DataSetIterator testIter = new ListDataSetIterator(dsTest.asList() , batchSize);\n        //\u5f52\u4e00\u5316\u5904\u7406\n        DataNormalization scaler = new NormalizerMinMaxScaler(0,1);\n        scaler.fit(trainIter);\n        scaler.fit(testIter);\n        trainIter.setPreProcessor(scaler);\n        testIter.setPreProcessor(scaler);\n        //\u58f0\u660e\u591a\u5c42\u611f\u77e5\u673a\n        MultiLayerNetwork mlp = model();\n        mlp.setListeners(new ScoreIterationListener(1));\n        //\u8bad\u7ec3 200 \u4e2a Epoch\n        for( int i = 0; i < 200; ++i ){\n            mlp.fit(trainIter);\n            trainIter.reset();\n        }\n        //\u5229\u7528 Deeplearning4j \u5185\u7f6e\u7684\u56de\u5f52\u6a21\u578b\u5206\u6790\u5668\u8fdb\u884c\u6a21\u578b\u8bc4\u4f30\n        RegressionEvaluation eval = mlp.evaluateRegression(testIter);\n        System.out.println(eval.stats());\n        testIter.reset();\n        //\u8f93\u51fa\u9a8c\u8bc1\u96c6\u7684\u771f\u5b9e\u503c\u548c\u9884\u6d4b\u503c\n        while( testIter.hasNext() ){\n            System.out.println(testIter.next().getLabels());\n        }\n        System.out.println();\n        testIter.reset();\n        System.out.println(mlp.output(testIter));\n    }\n\n}", "class_id": 0, "repo": "AllenWGX/CSDN-GitChat-DL4j-Course", "file": "src/main/java/lesson02/BostonHouseRegression.java", "last_update_at": "2020-04-19T08:40:36+00:00", "question_id": "dbc1f1360d07506bd7e7b44ef86461cf34cc1bd6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BostonHouseRegression {\n    public static List<DataSet> loadHousePrice(File file) throws IOException {\n        BufferedReader br = new BufferedReader(new FileReader(file));\n        String line = null;\n        List<DataSet> totalDataSetList = new LinkedList<DataSet>();\n        while( (line = br.readLine()) != null ){\n            String[] token = line.split(\",\");\n            double[] featureArray = new double[token.length - 1];\n            double[] labelArray = new double[1];\n            for( int i = 0; i < token.length - 1; ++i ){\n                featureArray[i] = Double.parseDouble(token[i]);\n            }\n            labelArray[0] = Double.parseDouble(token[token.length - 1]);\n            //\n            INDArray featureNDArray = Nd4j.create(featureArray);\n            INDArray labelNDArray = Nd4j.create(labelArray);\n            totalDataSetList.add(new DataSet(featureNDArray, labelNDArray));\n        }\n        br.close();\n        return totalDataSetList;\n}\n    public static MultiLayerNetwork model(){\n        MultiLayerConfiguration.Builder builder = new NeuralNetConfiguration.Builder()\n                        .seed(12345L)\n                        .updater(new Adam(0.01))\n                        .weightInit(WeightInit.XAVIER)\n                        .optimizationAlgo(OptimizationAlgorithm.STOCHASTIC_GRADIENT_DESCENT)\n                        .list()\n                        .layer(0, new DenseLayer.Builder().activation(Activation.LEAKYRELU)\n                                        .nIn(13).nOut(10).build())\n                        .layer(1, new OutputLayer.Builder(LossFunctions.LossFunction.MEAN_SQUARED_LOGARITHMIC_ERROR)\n                                        .activation(Activation.IDENTITY)\n                                        .nIn(10).nOut(1).build());\n        MultiLayerConfiguration conf = builder.build();\n        MultiLayerNetwork model = new MultiLayerNetwork(conf);\n        model.init();\n        return model;      \n}\n    public static void main(String[] args) throws IOException {\n        final int batchSize = 4;\n        final long SEED = 1234L;\n        final int trainSize = 400;\n        List<DataSet> housePriceList = loadHousePrice(new File(\"house_price.csv\"));\n        //\u83b7\u53d6\u5168\u90e8\u6570\u636e\u5e76\u4e14\u6253\u4e71\u987a\u5e8f\n        DataSet allData = DataSet.merge(housePriceList);\n        allData.shuffle(SEED);\n        //\u5212\u5206\u8bad\u7ec3\u96c6\u548c\u9a8c\u8bc1\u96c6\n        SplitTestAndTrain split = allData.splitTestAndTrain(trainSize);\n        DataSet dsTrain = split.getTrain();\n        DataSet dsTest = split.getTest();\n        DataSetIterator trainIter = new ListDataSetIterator(dsTrain.asList() , batchSize);\n        DataSetIterator testIter = new ListDataSetIterator(dsTest.asList() , batchSize);\n        //\u5f52\u4e00\u5316\u5904\u7406\n        DataNormalization scaler = new NormalizerMinMaxScaler(0,1);\n        scaler.fit(trainIter);\n        scaler.fit(testIter);\n        trainIter.setPreProcessor(scaler);\n        testIter.setPreProcessor(scaler);\n        //\u58f0\u660e\u591a\u5c42\u611f\u77e5\u673a\n        MultiLayerNetwork mlp = model();\n        mlp.setListeners(new ScoreIterationListener(1));\n        //\u8bad\u7ec3 200 \u4e2a Epoch\n        for( int i = 0; i < 200; ++i ){\n            mlp.fit(trainIter);\n            trainIter.reset();\n        }\n        //\u5229\u7528 Deeplearning4j \u5185\u7f6e\u7684\u56de\u5f52\u6a21\u578b\u5206\u6790\u5668\u8fdb\u884c\u6a21\u578b\u8bc4\u4f30\n        RegressionEvaluation eval = mlp.evaluateRegression(testIter);\n        System.out.println(eval.stats());\n        testIter.reset();\n        //\u8f93\u51fa\u9a8c\u8bc1\u96c6\u7684\u771f\u5b9e\u503c\u548c\u9884\u6d4b\u503c\n        while( testIter.hasNext() ){\n            System.out.println(testIter.next().getLabels());\n        }\n        System.out.println();\n        testIter.reset();\n        System.out.println(mlp.output(testIter));\n    }\n"]]}
{"hexsha": "0a2abf81286e00f7aff363659a8bd9713c74d06f", "ext": "java", "lang": "Java", "content": "public class MatrixMetaManager {\n  private static final Log LOG = LogFactory.getLog(MatrixMetaManager.class);\n  /** matrix inited flag, worker/ps can get matrix info. only when matrix is initialized after am received matrixinfo from client */\n  //private boolean matrixInited;\n\n  /**matrix id to matrix meta proto map*/\n  private final Int2ObjectOpenHashMap<MatrixProto> matrixProtoMap;\n\n  /** inverted index, psId--->Map( matrixId---->List<PartitionKey>), used for PS */\n  private final Object2ObjectOpenHashMap<ParameterServerId, Int2ObjectOpenHashMap<MatrixPartition>> matrixPartitionOnPS;\n  \n  /** ps id to matrices on this ps map */\n  private final Object2ObjectOpenHashMap<ParameterServerId, IntOpenHashSet> psIdToMatrixIdsMap;\n  \n  /**matrix id generator*/\n  private int maxMatrixId = -1;\n  \n  /**matrix name to id map*/\n  private final Object2IntOpenHashMap<String> matrixNameToIdMap;\n  \n  /**matrix id to psId which has build partitions of this matrix map, use to add matrix */\n  private final Int2ObjectOpenHashMap<ObjectOpenHashSet<ParameterServerId>> matrixIdToPSSetMap;\n  \n  private final Lock readLock;\n  private final Lock writeLock;\n\n  public MatrixMetaManager() {\n    matrixPartitionOnPS = new Object2ObjectOpenHashMap<ParameterServerId, Int2ObjectOpenHashMap<MatrixPartition>>();\n    matrixIdToPSSetMap = new Int2ObjectOpenHashMap<ObjectOpenHashSet<ParameterServerId>>();\n    psIdToMatrixIdsMap = new Object2ObjectOpenHashMap<ParameterServerId, IntOpenHashSet>();\n    matrixProtoMap = new Int2ObjectOpenHashMap<MatrixProto>();\n   \n    matrixNameToIdMap = new Object2IntOpenHashMap<String>();\n\n    ReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n    readLock = readWriteLock.readLock();\n    writeLock = readWriteLock.writeLock();\n  }\n\n  /**\n   * get all matrices meta proto. \n   * @return List<MatrixProto> all matrices meta proto list\n   */\n  public final List<MatrixProto> getMatrixProtos() {\n    try {\n      readLock.lock();\n      List<MatrixProto> matrixes = new ArrayList<MatrixProto>();\n      for (Entry<Integer, MatrixProto> entry : matrixProtoMap.entrySet()) {\n        matrixes.add(entry.getValue());\n      }\n      return matrixes;\n    } finally {\n      readLock.unlock();\n    }\n  }\n  \n  /**\n   * get matrix meta proto use matrix name\n   * @param matrixName matrix name\n   * @return MatrixProto matrix meta proto of the matrix, if not found, just return null\n   */\n  public MatrixProto getMatrix(String matrixName) {\n    try {\n      readLock.lock();\n      for (MatrixProto m : matrixProtoMap.values()) {\n        if (m.getName().equals(matrixName)) {\n          return m;\n        }\n      }\n      return null;\n    } finally {\n      readLock.unlock();\n    }\n  }\n\n  /**\n   * get matrix meta proto use matrix id\n   * @param id matrix id\n   * @return MatrixProto matrix meta proto of the matrix\n   */\n  public MatrixProto getMatrix(int id) {\n    try {\n      readLock.lock();\n      return matrixProtoMap.get(id);\n    } finally {\n      readLock.unlock();\n    }\n  }\n\n  /**\n   * get partitions of a specific parameter server hold\n   * @param psId, parameter server id\n   * @return List<MatrixPartition> the partitions of the parameter server hold\n   */\n\n  public final List<MatrixPartition> getMatrixPartitions(ParameterServerId psId) {\n    try {\n      readLock.lock();\n\n      Map<Integer, MatrixPartition> mpMap = matrixPartitionOnPS.get(psId);\n      if (mpMap == null) {\n        LOG.info(\"psId: \" + psId + \", mpMap null \");\n        return null;\n      }\n\n      List<MatrixPartition> mpList = new ArrayList<MatrixPartition>(mpMap.size());\n      for (Map.Entry<Integer, MatrixPartition> entry : mpMap.entrySet()) {\n        LOG.info(\"MatrixPartition is \" + entry.getValue());\n        mpList.add(entry.getValue());\n      }\n      return mpList;\n    } finally {\n      readLock.unlock();\n    }\n  }\n\n  /**\n   * add matrices meta to matrix meta manager and dispatch the partitions to parameter servers  \n   * @param matrixProtos matrices meta \n   * @throws InvalidParameterException \n   */\n  public void addMatrices(List<MatrixProto> matrixProtos) throws InvalidParameterException {\n    try {\n      writeLock.lock();\n      int size = matrixProtos.size();\n      for (int i = 0; i < size; i++) {\n        //check whether the matrix name conflicts with the existing matrix names, the matrix name must be only\n        if(matrixNameToIdMap.containsKey(matrixProtos.get(i).getName())) {\n          String errorMsg = \"build matrix failed. matrix name \" + matrixProtos.get(i).getName() + \" has exist, you must choose a new one\";\n          LOG.error(errorMsg);\n          throw new InvalidParameterException(errorMsg);\n        } else {\n          matrixNameToIdMap.put(matrixProtos.get(i).getName(), matrixProtos.get(i).getId());\n        }\n\n        LOG.info(\"start building MatrixPartition info. matrix id \" + matrixProtos.get(i).getId());\n        matrixProtoMap.put(matrixProtos.get(i).getId(), matrixProtos.get(i));\n        \n        //dispatch matrix partitions to parameter servers\n        buildPSMatrixInvertInfo(matrixProtos.get(i));\n        \n        //update matrix id generator\n        updateMaxMatrixId(matrixProtos.get(i).getId());\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }\n  \n  @SuppressWarnings(\"unused\")\n  private void waitForMatricesCreateOnPS(List<MatrixProto> matrixProtos) {\n    boolean inited = true;\n    while (true) {\n      try {\n        readLock.lock();\n        int size = matrixProtos.size();\n        inited = true;\n        for (int i = 0; i < size; i++) {\n          ObjectOpenHashSet<ParameterServerId> psIdSet =\n              matrixIdToPSSetMap.get(matrixProtos.get(i).getId());\n\n          if (psIdSet == null || psIdSet.isEmpty()) {\n            continue;\n          }\n\n          for (ParameterServerId psId : psIdSet) {\n            if (!psIdToMatrixIdsMap.containsKey(psId)\n                || !psIdToMatrixIdsMap.get(psId).contains(matrixProtos.get(i).getId())) {\n              inited = false;\n              break;\n            }\n          }\n        }\n      } finally {\n        readLock.unlock();\n      }\n\n      if (inited) {\n        return;\n      }\n\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        LOG.warn(\"waitForMatrixOnPS is interruptted.\");\n      }\n    }\n  }\n  \n  public boolean isCreated(String matrixName) {\n    boolean inited = true;\n\n    try {\n      readLock.lock();\n      if(!matrixNameToIdMap.containsKey(matrixName)) {\n        return true;\n      }\n      \n      int matrixId = matrixNameToIdMap.getInt(matrixName);\n      ObjectOpenHashSet<ParameterServerId> psIdSet = matrixIdToPSSetMap.get(matrixId);\n\n      if (psIdSet == null || psIdSet.isEmpty()) {\n        return true;\n      }\n\n      inited = true;\n      for (ParameterServerId psId : psIdSet) {\n        if (!psIdToMatrixIdsMap.containsKey(psId)\n            || !psIdToMatrixIdsMap.get(psId).contains(matrixId)) {\n          inited = false;\n          break;\n        }\n      }\n    } finally {\n      readLock.unlock();\n    }\n\n    return inited;\n  }\n\n  @SuppressWarnings(\"unused\")\n  private void waitForMatrixCreateOnPS(MatrixProto matrixProto) {\n    boolean inited = true;\n    int matrixId = matrixProto.getId();\n    while (true) {\n      try {\n        readLock.lock();\n        ObjectOpenHashSet<ParameterServerId> psIdSet =\n            matrixIdToPSSetMap.get(matrixId);\n\n        if (psIdSet == null || psIdSet.isEmpty()) {\n          return;\n        }\n        \n        inited = true;\n        for (ParameterServerId psId : psIdSet) {\n          if (!psIdToMatrixIdsMap.containsKey(psId)\n              || !psIdToMatrixIdsMap.get(psId).contains(matrixId)) {\n            LOG.info(\"ps \" + psId + \" does not contain matrix \" + matrixId);\n            inited = false;\n            break;\n          }\n        }\n      } finally {\n        readLock.unlock();\n      }\n\n      if (inited) {\n        LOG.info(\"all ps create matrix \" + matrixId + \" successfully.\");\n        return;\n      }\n\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        LOG.warn(\"waitForMatrixOnPS is interruptted.\");\n      }\n    }\n  }\n\n  @SuppressWarnings(\"unused\")\n  private void waitForMatrixReleaseOnPS(int matrixId) {\n    boolean released = true;\n    while (true) {\n      try {\n        readLock.lock();\n        ObjectOpenHashSet<ParameterServerId> psIdSet = matrixIdToPSSetMap.get(matrixId);\n\n        if (psIdSet == null || psIdSet.isEmpty()) {\n          return;\n        }\n\n        released = true;\n        for (ParameterServerId psId : psIdSet) {\n          if (psIdToMatrixIdsMap.containsKey(psId)\n              && psIdToMatrixIdsMap.get(psId).contains(matrixId)) {\n            released = false;\n            break;\n          }\n        }\n      } finally {\n        readLock.unlock();\n      }\n\n      if (released) {\n        return;\n      }\n\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        LOG.warn(\"waitForMatrixOnPS is interruptted.\");\n      }\n    }\n  }\n  \n  \n  /**\n   * Create a new matrix\n   * @param matrixProto matrix meta proto\n   * @return int matrix id\n   * @throws InvalidParameterException \n   */\n  public int addMatrix(MatrixProto matrixProto) throws InvalidParameterException {\n    int matrixId = -1;\n    try {\n      writeLock.lock();\n\n      matrixId = assignMatrixId();\n      LOG.info(\"start building MatrixPartition info, matrix id \" + matrixId);\n\n      //check whether the matrix name conflicts with the existing matrix names, the matrix name must be only\n      if(matrixNameToIdMap.containsKey(matrixProto.getName())) {\n        String errorMsg = \"build matrix failed. matrix name \" + matrixProto.getName() + \" has exist, you must choose a new one\";\n        LOG.error(errorMsg);\n        throw new InvalidParameterException(errorMsg);\n      } else {\n        matrixNameToIdMap.put(matrixProto.getName(), matrixId);\n      }\n      \n      matrixProtoMap.put(matrixProto.getId(), matrixProto);\n      \n      //dispatch matrix partitions to parameter servers\n      buildPSMatrixInvertInfo(matrixProto);\n      \n    } finally {\n      writeLock.unlock();\n    }\n\n    return matrixId;\n  }\n\n  /**\n   * dispatch matrix partitions to parameter servers \n   * @param matrixProto  matrix meta proto\n   */\n  private void buildPSMatrixInvertInfo(MatrixProto matrixProto) {\n    LOG.debug(\"matrixName: \" + matrixProto.getName() + \", matrixParititionsNum: \"\n        + matrixProto.getMatrixPartLocationCount());\n    List<MatrixPartitionLocation> matrixPartProtoList = matrixProto.getMatrixPartLocationList();\n\n    int matrixId = matrixProto.getId();\n    IntOpenHashSet psIdSet = new IntOpenHashSet();\n\n    Int2ObjectOpenHashMap<MatrixPartition.Builder> builders =\n        new Int2ObjectOpenHashMap<MatrixPartition.Builder>();\n\n    List<MLProtos.Pair> pairs = matrixProto.getAttributeList();\n\n    for (MatrixPartitionLocation matrixPartLocProto : matrixPartProtoList) {\n      Partition part = matrixPartLocProto.getPart();\n      int psId = matrixPartLocProto.getPsId().getPsIndex();\n      psIdSet.add(psId);\n\n      MatrixPartition.Builder mpBuilder = builders.get(psId);\n      if (mpBuilder == null) {\n        mpBuilder = MatrixPartition.newBuilder();\n        builders.put(psId, mpBuilder);\n        mpBuilder.setMatrixId(matrixId);\n        mpBuilder.setMatrixName(matrixProto.getName());\n        mpBuilder.setRowNum(matrixProto.getRowNum());\n        mpBuilder.setColNum(matrixProto.getColNum());\n        mpBuilder.setRowType(matrixProto.getRowType());\n        for (MLProtos.Pair pair : pairs) {\n          mpBuilder.addConfigurations(pair);\n        }\n      }\n\n      mpBuilder.addPartitions(part);\n    }\n\n    for (Entry<Integer, MatrixPartition.Builder> builderEntry : builders.entrySet()) {\n      Int2ObjectOpenHashMap<MatrixPartition> matrixPartMap =\n          matrixPartitionOnPS.get(new ParameterServerId(builderEntry.getKey()));\n      if (matrixPartMap == null) {\n        matrixPartMap = new Int2ObjectOpenHashMap<MatrixPartition>();\n        matrixPartitionOnPS.put(new ParameterServerId(builderEntry.getKey()), matrixPartMap);\n      }\n      \n      matrixPartMap.put(builderEntry.getValue().getMatrixId(), builderEntry.getValue().build());\n      \n      ObjectOpenHashSet<ParameterServerId> psSet = matrixIdToPSSetMap.get(builderEntry.getValue().getMatrixId());\n      if(psSet == null) {\n        psSet = new ObjectOpenHashSet<ParameterServerId>();\n        matrixIdToPSSetMap.put(builderEntry.getValue().getMatrixId(), psSet);\n      }\n      psSet.add(new ParameterServerId(builderEntry.getKey()));\n      \n      LOG.info(\"ps index: \" + builderEntry.getKey() + \", matrixPartition info(matrixId: \" + matrixId\n          + \")\");\n    }\n  }\n\n  private void updateMaxMatrixId(int id) {\n    if (maxMatrixId < id) {\n      maxMatrixId = id;\n    }\n    LOG.debug(\"update maxMatrixId  to \" + maxMatrixId);\n  }\n\n  private int assignMatrixId() {\n    return ++maxMatrixId;\n  }\n\n  /**\n   * compare the matrix meta on the master and the matrix meta on ps to find the matrix this parameter server needs to create and delete\n   * @param matrixReports parameter server matrix report, include the matrix ids this parameter server hold.\n   * @param needCreateMatrixes use to return the matrix partitions this parameter server need to build\n   * @param needReleaseMatrixes use to return the matrix ids this parameter server need to remove\n   * @param psId parameter server id\n  */\n  public void syncMatrixInfos(List<MatrixReport> matrixReports,\n      List<MatrixPartition> needCreateMatrixes, List<Integer> needReleaseMatrixes, ParameterServerId psId) {\n    //get matrix ids in the parameter server report\n    IntOpenHashSet matrixInPS = new IntOpenHashSet();\n    int size = matrixReports.size();\n    for (int i = 0; i < size; i++) {\n      matrixInPS.add(matrixReports.get(i).getMatrixId());\n    }\n    \n    //get the matrices parameter server need to create and delete\n    getPSNeedUpdateMatrix(matrixInPS, needCreateMatrixes, needReleaseMatrixes, psId);\n  }\n\n  private void getPSNeedUpdateMatrix(IntOpenHashSet matrixInPS,\n      List<MatrixPartition> needCreateMatrixes, List<Integer> needReleaseMatrixes, ParameterServerId psId) {\n    try {\n      readLock.lock();\n      Map<Integer, MatrixPartition> matrixIdToPartition = matrixPartitionOnPS.get(psId);\n\n      if (matrixIdToPartition == null) {\n        return;\n      }\n\n      //if a matrix exists on parameter server but not exist on master, we should notify the parameter server to remove this matrix\n      for (int matrixId : matrixInPS) {\n        LOG.debug(\"matrix in ps \" + matrixId);\n        if (!matrixIdToPartition.containsKey(matrixId)) {\n          LOG.debug(\"matrix \" + matrixId + \" need release\");\n          needReleaseMatrixes.add(matrixId);\n        }\n      }\n\n      //if a matrix exists on master but not exist on parameter server, this parameter server need build it.\n      for (Entry<Integer, MatrixPartition> matrixPartEntry : matrixIdToPartition.entrySet()) {\n        LOG.debug(\"matrix in master \" + matrixPartEntry.getKey() + \", \"\n            + matrixPartEntry.getValue().getMatrixName());\n        if (!matrixInPS.contains(matrixPartEntry.getKey())) {\n          needCreateMatrixes.add(matrixPartEntry.getValue());\n        }\n      }\n    } finally {\n      readLock.unlock();\n    }\n  }\n  \n  /**\n   * Update the matrices on the PS\n   * @param psId\n   * @param matrixReports\n   */\n  public void psMatricesUpdate(ParameterServerId psId, List<MatrixReport> matrixReports) {\n    try {\n      writeLock.lock();\n      IntOpenHashSet matrixIdSet = psIdToMatrixIdsMap.get(psId);\n      if(matrixIdSet == null) {\n        matrixIdSet = new IntOpenHashSet();\n        psIdToMatrixIdsMap.put(psId, matrixIdSet);\n      }\n      \n      int size = matrixReports.size();\n      for(int i = 0; i < size; i++) {\n        matrixIdSet.add(matrixReports.get(i).getMatrixId());\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }\n\n  /**\n   * release a matrix. just release matrix meta on master\n   * TODO:maybe we need a method that can wait all parameter servers release this matrix\n   * @param matrixId the matrix need release\n   */\n  public void releaseMatrix(int matrixId) {\n    try {\n      writeLock.lock();\n      LOG.info(\"matrix id=\" + matrixId);\n      matrixProtoMap.remove(matrixId);\n      matrixIdToPSSetMap.remove(matrixId);\n      \n      for (Int2ObjectOpenHashMap<MatrixPartition> entry : matrixPartitionOnPS.values()) {\n        entry.remove(matrixId);\n      }\n\n      ObjectIterator<Entry<String, Integer>> iter = matrixNameToIdMap.entrySet().iterator();\n      while (iter.hasNext()) {\n        if (iter.next().getValue() == matrixId) {\n          iter.remove();\n          break;\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n    \n    //waitForMatrixReleaseOnPS(matrixId);\n  }\n\n  /**\n   * write matrix meta protos to output stream\n   * @param output output stream\n   * @throws IOException\n   */\n  public void serialize(FSDataOutputStream output) throws IOException {\n    try {\n      readLock.lock();\n      if(matrixProtoMap == null) {\n        return;\n      }\n      \n      for(it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry<MatrixProto> entry:matrixProtoMap.int2ObjectEntrySet()) {\n        entry.getValue().writeDelimitedTo(output);\n      }\n    } finally {\n      readLock.unlock();\n    }\n  }\n  \n  /**\n   * read matrix meta protos from input stream\n   * @param input input stream\n   * @throws IOException, InvalidParameterException\n   */\n  public void deserialize(FSDataInputStream input) throws IOException, InvalidParameterException {\n    List<MatrixProto> matrixProtos = new ArrayList<MatrixProto>();\n    while(input.available() > 0) {\n      MatrixProto matrixProto = MatrixProto.parseDelimitedFrom(input);\n      LOG.info(\"deserilize from file matrixProto=\" + matrixProto);\n      matrixProtos.add(matrixProto);\n    }\n    addMatrices(matrixProtos);\n  }\n\n  /**\n   * Get ps ids which contains the matrix\n   * @param matrixId matrix id\n   * @return ps id set\n   */\n  public Set<ParameterServerId> getPsIds(int matrixId) {\n    return matrixIdToPSSetMap.get(matrixId);\n  }\n}", "class_id": 0, "repo": "ericzhang-cn/angel", "file": "angel-ps/core/src/main/java/com/tencent/angel/master/MatrixMetaManager.java", "last_update_at": "2020-08-25T02:17:39+00:00", "question_id": "0a2abf81286e00f7aff363659a8bd9713c74d06f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MatrixMetaManager {\n  private static final Log LOG = LogFactory.getLog(MatrixMetaManager.class);\n  /** matrix inited flag, worker/ps can get matrix info. only when matrix is initialized after am received matrixinfo from client */\n  //private boolean matrixInited;\n  /**matrix id to matrix meta proto map*/\n  private final Int2ObjectOpenHashMap<MatrixProto> matrixProtoMap;\n  /** inverted index, psId--->Map( matrixId---->List<PartitionKey>), used for PS */\n  private final Object2ObjectOpenHashMap<ParameterServerId, Int2ObjectOpenHashMap<MatrixPartition>> matrixPartitionOnPS;\n  /** ps id to matrices on this ps map */\n  private final Object2ObjectOpenHashMap<ParameterServerId, IntOpenHashSet> psIdToMatrixIdsMap;\n  /**matrix id generator*/\n  private int maxMatrixId = -1;\n  /**matrix name to id map*/\n  private final Object2IntOpenHashMap<String> matrixNameToIdMap;\n  /**matrix id to psId which has build partitions of this matrix map, use to add matrix */\n  private final Int2ObjectOpenHashMap<ObjectOpenHashSet<ParameterServerId>> matrixIdToPSSetMap;\n  private final Lock readLock;\n  private final Lock writeLock;\n  public MatrixMetaManager() {\n    matrixPartitionOnPS = new Object2ObjectOpenHashMap<ParameterServerId, Int2ObjectOpenHashMap<MatrixPartition>>();\n    matrixIdToPSSetMap = new Int2ObjectOpenHashMap<ObjectOpenHashSet<ParameterServerId>>();\n    psIdToMatrixIdsMap = new Object2ObjectOpenHashMap<ParameterServerId, IntOpenHashSet>();\n    matrixProtoMap = new Int2ObjectOpenHashMap<MatrixProto>();\n    matrixNameToIdMap = new Object2IntOpenHashMap<String>();\n    ReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n    readLock = readWriteLock.readLock();\n    writeLock = readWriteLock.writeLock();\n  }\n  /**\n   * get all matrices meta proto. \n   * @return List<MatrixProto> all matrices meta proto list\n   */\n  public final List<MatrixProto> getMatrixProtos() {\n    try {\n      readLock.lock();\n      List<MatrixProto> matrixes = new ArrayList<MatrixProto>();\n      for (Entry<Integer, MatrixProto> entry : matrixProtoMap.entrySet()) {\n        matrixes.add(entry.getValue());\n      }\n      return matrixes;\n    } finally {\n      readLock.unlock();\n    }\n  }\n  /**\n   * get matrix meta proto use matrix name\n   * @param matrixName matrix name\n   * @return MatrixProto matrix meta proto of the matrix, if not found, just return null\n   */\n  public MatrixProto getMatrix(String matrixName) {\n    try {\n      readLock.lock();\n      for (MatrixProto m : matrixProtoMap.values()) {\n        if (m.getName().equals(matrixName)) {\n          return m;\n        }\n      }\n      return null;\n    } finally {\n      readLock.unlock();\n    }\n  }\n  /**\n   * get matrix meta proto use matrix id\n   * @param id matrix id\n   * @return MatrixProto matrix meta proto of the matrix\n   */\n  public MatrixProto getMatrix(int id) {\n    try {\n      readLock.lock();\n      return matrixProtoMap.get(id);\n    } finally {\n      readLock.unlock();\n    }\n  }\n  /**\n   * get partitions of a specific parameter server hold\n   * @param psId, parameter server id\n   * @return List<MatrixPartition> the partitions of the parameter server hold\n   */\n  public final List<MatrixPartition> getMatrixPartitions(ParameterServerId psId) {\n    try {\n      readLock.lock();\n      Map<Integer, MatrixPartition> mpMap = matrixPartitionOnPS.get(psId);\n      if (mpMap == null) {\n        LOG.info(\"psId: \" + psId + \", mpMap null \");\n        return null;\n      }\n      List<MatrixPartition> mpList = new ArrayList<MatrixPartition>(mpMap.size());\n      for (Map.Entry<Integer, MatrixPartition> entry : mpMap.entrySet()) {\n        LOG.info(\"MatrixPartition is \" + entry.getValue());\n        mpList.add(entry.getValue());\n      }\n      return mpList;\n    } finally {\n      readLock.unlock();\n    }\n  }\n  /**\n   * add matrices meta to matrix meta manager and dispatch the partitions to parameter servers  \n   * @param matrixProtos matrices meta \n   * @throws InvalidParameterException \n   */\n  public void addMatrices(List<MatrixProto> matrixProtos) throws InvalidParameterException {\n    try {\n      writeLock.lock();\n      int size = matrixProtos.size();\n      for (int i = 0; i < size; i++) {\n        //check whether the matrix name conflicts with the existing matrix names, the matrix name must be only\n        if(matrixNameToIdMap.containsKey(matrixProtos.get(i).getName())) {\n          String errorMsg = \"build matrix failed. matrix name \" + matrixProtos.get(i).getName() + \" has exist, you must choose a new one\";\n          LOG.error(errorMsg);\n          throw new InvalidParameterException(errorMsg);\n        } else {\n          matrixNameToIdMap.put(matrixProtos.get(i).getName(), matrixProtos.get(i).getId());\n        }\n        LOG.info(\"start building MatrixPartition info. matrix id \" + matrixProtos.get(i).getId());\n        matrixProtoMap.put(matrixProtos.get(i).getId(), matrixProtos.get(i));\n        //dispatch matrix partitions to parameter servers\n        buildPSMatrixInvertInfo(matrixProtos.get(i));\n        //update matrix id generator\n        updateMaxMatrixId(matrixProtos.get(i).getId());\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }\n  @SuppressWarnings(\"unused\")\n  private void waitForMatricesCreateOnPS(List<MatrixProto> matrixProtos) {\n    boolean inited = true;\n    while (true) {\n      try {\n        readLock.lock();\n        int size = matrixProtos.size();\n        inited = true;\n        for (int i = 0; i < size; i++) {\n          ObjectOpenHashSet<ParameterServerId> psIdSet =\n              matrixIdToPSSetMap.get(matrixProtos.get(i).getId());\n          if (psIdSet == null || psIdSet.isEmpty()) {\n            continue;\n          }\n          for (ParameterServerId psId : psIdSet) {\n            if (!psIdToMatrixIdsMap.containsKey(psId)\n                || !psIdToMatrixIdsMap.get(psId).contains(matrixProtos.get(i).getId())) {\n              inited = false;\n              break;\n            }\n          }\n        }\n      } finally {\n        readLock.unlock();\n      }\n      if (inited) {\n        return;\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        LOG.warn(\"waitForMatrixOnPS is interruptted.\");\n      }\n    }\n  }\n  public boolean isCreated(String matrixName) {\n    boolean inited = true;\n    try {\n      readLock.lock();\n      if(!matrixNameToIdMap.containsKey(matrixName)) {\n        return true;\n      }\n      int matrixId = matrixNameToIdMap.getInt(matrixName);\n      ObjectOpenHashSet<ParameterServerId> psIdSet = matrixIdToPSSetMap.get(matrixId);\n      if (psIdSet == null || psIdSet.isEmpty()) {\n        return true;\n      }\n      inited = true;\n      for (ParameterServerId psId : psIdSet) {\n        if (!psIdToMatrixIdsMap.containsKey(psId)\n            || !psIdToMatrixIdsMap.get(psId).contains(matrixId)) {\n          inited = false;\n          break;\n        }\n      }\n    } finally {\n      readLock.unlock();\n    }\n    return inited;\n  }\n  @SuppressWarnings(\"unused\")\n  private void waitForMatrixCreateOnPS(MatrixProto matrixProto) {\n    boolean inited = true;\n    int matrixId = matrixProto.getId();\n    while (true) {\n      try {\n        readLock.lock();\n        ObjectOpenHashSet<ParameterServerId> psIdSet =\n            matrixIdToPSSetMap.get(matrixId);\n        if (psIdSet == null || psIdSet.isEmpty()) {\n          return;\n        }\n        inited = true;\n        for (ParameterServerId psId : psIdSet) {\n          if (!psIdToMatrixIdsMap.containsKey(psId)\n              || !psIdToMatrixIdsMap.get(psId).contains(matrixId)) {\n            LOG.info(\"ps \" + psId + \" does not contain matrix \" + matrixId);\n            inited = false;\n            break;\n          }\n        }\n      } finally {\n        readLock.unlock();\n      }\n      if (inited) {\n        LOG.info(\"all ps create matrix \" + matrixId + \" successfully.\");\n        return;\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        LOG.warn(\"waitForMatrixOnPS is interruptted.\");\n      }\n    }\n  }\n  @SuppressWarnings(\"unused\")\n  private void waitForMatrixReleaseOnPS(int matrixId) {\n    boolean released = true;\n    while (true) {\n      try {\n        readLock.lock();\n        ObjectOpenHashSet<ParameterServerId> psIdSet = matrixIdToPSSetMap.get(matrixId);\n        if (psIdSet == null || psIdSet.isEmpty()) {\n          return;\n        }\n        released = true;\n        for (ParameterServerId psId : psIdSet) {\n          if (psIdToMatrixIdsMap.containsKey(psId)\n              && psIdToMatrixIdsMap.get(psId).contains(matrixId)) {\n            released = false;\n            break;\n          }\n        }\n      } finally {\n        readLock.unlock();\n      }\n      if (released) {\n        return;\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        LOG.warn(\"waitForMatrixOnPS is interruptted.\");\n      }\n    }\n  }\n  /**\n   * Create a new matrix\n   * @param matrixProto matrix meta proto\n   * @return int matrix id\n   * @throws InvalidParameterException \n   */\n  public int addMatrix(MatrixProto matrixProto) throws InvalidParameterException {\n    int matrixId = -1;\n    try {\n      writeLock.lock();\n      matrixId = assignMatrixId();\n      LOG.info(\"start building MatrixPartition info, matrix id \" + matrixId);\n      //check whether the matrix name conflicts with the existing matrix names, the matrix name must be only\n      if(matrixNameToIdMap.containsKey(matrixProto.getName())) {\n        String errorMsg = \"build matrix failed. matrix name \" + matrixProto.getName() + \" has exist, you must choose a new one\";\n        LOG.error(errorMsg);\n        throw new InvalidParameterException(errorMsg);\n      } else {\n        matrixNameToIdMap.put(matrixProto.getName(), matrixId);\n      }\n      matrixProtoMap.put(matrixProto.getId(), matrixProto);\n      //dispatch matrix partitions to parameter servers\n      buildPSMatrixInvertInfo(matrixProto);\n    } finally {\n      writeLock.unlock();\n    }\n    return matrixId;\n  }\n  /**\n   * dispatch matrix partitions to parameter servers \n   * @param matrixProto  matrix meta proto\n   */\n  private void buildPSMatrixInvertInfo(MatrixProto matrixProto) {\n    LOG.debug(\"matrixName: \" + matrixProto.getName() + \", matrixParititionsNum: \"\n        + matrixProto.getMatrixPartLocationCount());\n    List<MatrixPartitionLocation> matrixPartProtoList = matrixProto.getMatrixPartLocationList();\n    int matrixId = matrixProto.getId();\n    IntOpenHashSet psIdSet = new IntOpenHashSet();\n    Int2ObjectOpenHashMap<MatrixPartition.Builder> builders =\n        new Int2ObjectOpenHashMap<MatrixPartition.Builder>();\n    List<MLProtos.Pair> pairs = matrixProto.getAttributeList();\n    for (MatrixPartitionLocation matrixPartLocProto : matrixPartProtoList) {\n      Partition part = matrixPartLocProto.getPart();\n      int psId = matrixPartLocProto.getPsId().getPsIndex();\n      psIdSet.add(psId);\n      MatrixPartition.Builder mpBuilder = builders.get(psId);\n      if (mpBuilder == null) {\n        mpBuilder = MatrixPartition.newBuilder();\n        builders.put(psId, mpBuilder);\n        mpBuilder.setMatrixId(matrixId);\n        mpBuilder.setMatrixName(matrixProto.getName());\n        mpBuilder.setRowNum(matrixProto.getRowNum());\n        mpBuilder.setColNum(matrixProto.getColNum());\n        mpBuilder.setRowType(matrixProto.getRowType());\n        for (MLProtos.Pair pair : pairs) {\n          mpBuilder.addConfigurations(pair);\n        }\n      }\n      mpBuilder.addPartitions(part);\n    }\n    for (Entry<Integer, MatrixPartition.Builder> builderEntry : builders.entrySet()) {\n      Int2ObjectOpenHashMap<MatrixPartition> matrixPartMap =\n          matrixPartitionOnPS.get(new ParameterServerId(builderEntry.getKey()));\n      if (matrixPartMap == null) {\n        matrixPartMap = new Int2ObjectOpenHashMap<MatrixPartition>();\n        matrixPartitionOnPS.put(new ParameterServerId(builderEntry.getKey()), matrixPartMap);\n      }\n      matrixPartMap.put(builderEntry.getValue().getMatrixId(), builderEntry.getValue().build());\n      ObjectOpenHashSet<ParameterServerId> psSet = matrixIdToPSSetMap.get(builderEntry.getValue().getMatrixId());\n      if(psSet == null) {\n        psSet = new ObjectOpenHashSet<ParameterServerId>();\n        matrixIdToPSSetMap.put(builderEntry.getValue().getMatrixId(), psSet);\n      }\n      psSet.add(new ParameterServerId(builderEntry.getKey()));\n      LOG.info(\"ps index: \" + builderEntry.getKey() + \", matrixPartition info(matrixId: \" + matrixId\n          + \")\");\n    }\n  }\n  private void updateMaxMatrixId(int id) {\n    if (maxMatrixId < id) {\n      maxMatrixId = id;\n    }\n    LOG.debug(\"update maxMatrixId  to \" + maxMatrixId);\n  }\n  private int assignMatrixId() {\n    return ++maxMatrixId;\n  }\n  /**\n   * compare the matrix meta on the master and the matrix meta on ps to find the matrix this parameter server needs to create and delete\n   * @param matrixReports parameter server matrix report, include the matrix ids this parameter server hold.\n   * @param needCreateMatrixes use to return the matrix partitions this parameter server need to build\n   * @param needReleaseMatrixes use to return the matrix ids this parameter server need to remove\n   * @param psId parameter server id\n  */\n  public void syncMatrixInfos(List<MatrixReport> matrixReports,\n      List<MatrixPartition> needCreateMatrixes, List<Integer> needReleaseMatrixes, ParameterServerId psId) {\n    //get matrix ids in the parameter server report\n    IntOpenHashSet matrixInPS = new IntOpenHashSet();\n    int size = matrixReports.size();\n    for (int i = 0; i < size; i++) {\n      matrixInPS.add(matrixReports.get(i).getMatrixId());\n    }\n    //get the matrices parameter server need to create and delete\n    getPSNeedUpdateMatrix(matrixInPS, needCreateMatrixes, needReleaseMatrixes, psId);\n  }\n  private void getPSNeedUpdateMatrix(IntOpenHashSet matrixInPS,\n      List<MatrixPartition> needCreateMatrixes, List<Integer> needReleaseMatrixes, ParameterServerId psId) {\n    try {\n      readLock.lock();\n      Map<Integer, MatrixPartition> matrixIdToPartition = matrixPartitionOnPS.get(psId);\n      if (matrixIdToPartition == null) {\n        return;\n      }\n      //if a matrix exists on parameter server but not exist on master, we should notify the parameter server to remove this matrix\n      for (int matrixId : matrixInPS) {\n        LOG.debug(\"matrix in ps \" + matrixId);\n        if (!matrixIdToPartition.containsKey(matrixId)) {\n          LOG.debug(\"matrix \" + matrixId + \" need release\");\n          needReleaseMatrixes.add(matrixId);\n        }\n      }\n      //if a matrix exists on master but not exist on parameter server, this parameter server need build it.\n      for (Entry<Integer, MatrixPartition> matrixPartEntry : matrixIdToPartition.entrySet()) {\n        LOG.debug(\"matrix in master \" + matrixPartEntry.getKey() + \", \"\n            + matrixPartEntry.getValue().getMatrixName());\n        if (!matrixInPS.contains(matrixPartEntry.getKey())) {\n          needCreateMatrixes.add(matrixPartEntry.getValue());\n        }\n      }\n    } finally {\n      readLock.unlock();\n    }\n  }\n  /**\n   * Update the matrices on the PS\n   * @param psId\n   * @param matrixReports\n   */\n  public void psMatricesUpdate(ParameterServerId psId, List<MatrixReport> matrixReports) {\n    try {\n      writeLock.lock();\n      IntOpenHashSet matrixIdSet = psIdToMatrixIdsMap.get(psId);\n      if(matrixIdSet == null) {\n        matrixIdSet = new IntOpenHashSet();\n        psIdToMatrixIdsMap.put(psId, matrixIdSet);\n      }\n      int size = matrixReports.size();\n      for(int i = 0; i < size; i++) {\n        matrixIdSet.add(matrixReports.get(i).getMatrixId());\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }\n  /**\n   * release a matrix. just release matrix meta on master\n   * TODO:maybe we need a method that can wait all parameter servers release this matrix\n   * @param matrixId the matrix need release\n   */\n  public void releaseMatrix(int matrixId) {\n    try {\n      writeLock.lock();\n      LOG.info(\"matrix id=\" + matrixId);\n      matrixProtoMap.remove(matrixId);\n      matrixIdToPSSetMap.remove(matrixId);\n      for (Int2ObjectOpenHashMap<MatrixPartition> entry : matrixPartitionOnPS.values()) {\n        entry.remove(matrixId);\n      }\n      ObjectIterator<Entry<String, Integer>> iter = matrixNameToIdMap.entrySet().iterator();\n      while (iter.hasNext()) {\n        if (iter.next().getValue() == matrixId) {\n          iter.remove();\n          break;\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n    //waitForMatrixReleaseOnPS(matrixId);\n  }\n  /**\n   * write matrix meta protos to output stream\n   * @param output output stream\n   * @throws IOException\n   */\n  public void serialize(FSDataOutputStream output) throws IOException {\n    try {\n      readLock.lock();\n      if(matrixProtoMap == null) {\n        return;\n      }\n      for(it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry<MatrixProto> entry:matrixProtoMap.int2ObjectEntrySet()) {\n        entry.getValue().writeDelimitedTo(output);\n      }\n    } finally {\n      readLock.unlock();\n    }\n  }\n  /**\n   * read matrix meta protos from input stream\n   * @param input input stream\n   * @throws IOException, InvalidParameterException\n   */\n  public void deserialize(FSDataInputStream input) throws IOException, InvalidParameterException {\n    List<MatrixProto> matrixProtos = new ArrayList<MatrixProto>();\n    while(input.available() > 0) {\n      MatrixProto matrixProto = MatrixProto.parseDelimitedFrom(input);\n      LOG.info(\"deserilize from file matrixProto=\" + matrixProto);\n      matrixProtos.add(matrixProto);\n    }\n    addMatrices(matrixProtos);\n  }\n  /**\n   * Get ps ids which contains the matrix\n   * @param matrixId matrix id\n   * @return ps id set\n   */\n  public Set<ParameterServerId> getPsIds(int matrixId) {\n    return matrixIdToPSSetMap.get(matrixId);\n  }\n"]]}
{"hexsha": "d7d130924e27071ae6992cc90c60aaef859ab9a9", "ext": "java", "lang": "Java", "content": "public class MetricsPublishTask extends TimerTask {\n    private static final Logger LOGGER = LoggerFactory.getLogger(MetricsPublishTask.class);\n\n    private final OperatingSystemMXBean osBean = ManagementFactory.getPlatformMXBean(OperatingSystemMXBean.class);\n    private final Gson gson = new Gson();\n    private final Connection conn;\n\n    public MetricsPublishTask(Connection conn) {\n        this.conn = conn;\n    }\n\n    @Override\n    public void run() {\n        MetricsMessage metricsMessage = new MetricsMessage();\n        metricsMessage.id = UUID.randomUUID().toString();\n        metricsMessage.cpuPercentage = Math.round(osBean.getSystemCpuLoad() * 100.0) / 100.0;\n        metricsMessage.totalPhysicalMemory = osBean.getTotalPhysicalMemorySize() / 1024 / 1024;\n        metricsMessage.freePhysicalMemory = osBean.getFreePhysicalMemorySize() / 1024 / 1024;\n\n        try {\n            String msg = gson.toJson(metricsMessage);\n\n            LOGGER.info(\"Publishing: \" + msg);\n            conn.publish(\"metrics-queue\", gson.toJson(msg).getBytes());\n        } catch (IOException e) {\n            LOGGER.error(\"Error publishing metrics\", e);\n        }\n    }\n\n    /**\n     * Message published to clients containing system metrics.\n     */\n    private static class MetricsMessage {\n        String id;\n        double cpuPercentage;\n        double totalPhysicalMemory;\n        double freePhysicalMemory;\n    }\n}", "class_id": 0, "repo": "gregwhitaker/nats-queue-example", "file": "queue-service/src/main/java/nats/example/queue/service/MetricsPublishTask.java", "last_update_at": "2020-01-08T04:47:16+00:00", "question_id": "d7d130924e27071ae6992cc90c60aaef859ab9a9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MetricsPublishTask extends TimerTask {\n    private static final Logger LOGGER = LoggerFactory.getLogger(MetricsPublishTask.class);\n    private final OperatingSystemMXBean osBean = ManagementFactory.getPlatformMXBean(OperatingSystemMXBean.class);\n    private final Gson gson = new Gson();\n    private final Connection conn;\n    public MetricsPublishTask(Connection conn) {\n        this.conn = conn;\n    }\n    @Override\n    public void run() {\n        MetricsMessage metricsMessage = new MetricsMessage();\n        metricsMessage.id = UUID.randomUUID().toString();\n        metricsMessage.cpuPercentage = Math.round(osBean.getSystemCpuLoad() * 100.0) / 100.0;\n        metricsMessage.totalPhysicalMemory = osBean.getTotalPhysicalMemorySize() / 1024 / 1024;\n        metricsMessage.freePhysicalMemory = osBean.getFreePhysicalMemorySize() / 1024 / 1024;\n        try {\n            String msg = gson.toJson(metricsMessage);\n            LOGGER.info(\"Publishing: \" + msg);\n            conn.publish(\"metrics-queue\", gson.toJson(msg).getBytes());\n        } catch (IOException e) {\n            LOGGER.error(\"Error publishing metrics\", e);\n        }\n    }\n    /**\n     * Message published to clients containing system metrics.\n     */\n    private static class MetricsMessage {\n        String id;\n        double cpuPercentage;\n        double totalPhysicalMemory;\n        double freePhysicalMemory;\n    }\n"]]}
{"hexsha": "814087476f1ba62432f05c3705ffb1608b313e32", "ext": "java", "lang": "Java", "content": "public class RelayClockCanvas extends Canvas\n{\n    private static final long serialVersionUID = 1L;\n\n    private RelayClockDigitPCB digitS0;\n\n    private RelayClockDigitPCB digitS1;\n\n    private RelayClockDigitPCB digitM0;\n\n    private RelayClockDigitPCB digitM1;\n\n    private RelayClockDigitPCB digitH0;\n\n    private RelayClockDigitPCB digitH1;\n\n    /**\n     * The constructor.\n     */\n    public RelayClockCanvas(RelayClock clock)\n    {\n        this.digitS0 = clock.getDisplayS0();\n        this.digitS1 = clock.getDisplayS1();\n        this.digitM0 = clock.getDisplayM0();\n        this.digitM1 = clock.getDisplayM1();\n        this.digitH0 = clock.getDisplayH0();\n        this.digitH1 = clock.getDisplayH1();\n    }\n\n    @Override\n    public void update(Graphics g)\n    {\n        paint(g);\n    }\n\n    @Override\n    public void paint(Graphics g)\n    {\n        int w = getWidth();\n        int h = getHeight();\n\n        g.setColor(Color.DARK_GRAY);\n        g.fillRect(0, 0, w, h);\n\n        // paint it in the middle of the canvas\n        int x = (w - 330) / 2;\n        int y = (h - 120) / 2;\n\n        paint(digitH1.getDisplay(), g, x + 20, y + 20);\n        paint(digitH0.getDisplay(), g, x + 70, y + 20);\n        paint(digitM1.getDisplay(), g, x + 120, y + 20);\n        paint(digitM0.getDisplay(), g, x + 170, y + 20);\n        paint(digitS1.getDisplay(), g, x + 220, y + 20);\n        paint(digitS0.getDisplay(), g, x + 270, y + 20);\n    }\n\n    private void paint(SevenSegmentDisplay digit, Graphics g, int xOffset, int yOffset)\n    {\n        g.setColor(Color.GREEN);\n\n        if (digit.getA().isOn())\n        {\n            g.drawLine(xOffset, yOffset, xOffset + 40, yOffset);\n        }\n        if (digit.getB().isOn())\n        {\n            g.drawLine(xOffset + 40, yOffset, xOffset + 40, yOffset + 40);\n        }\n        if (digit.getC().isOn())\n        {\n            g.drawLine(xOffset + 40, yOffset + 40, xOffset + 40, yOffset + 80);\n        }\n        if (digit.getD().isOn())\n        {\n            g.drawLine(xOffset, yOffset + 80, xOffset + 40, yOffset + 80);\n        }\n        if (digit.getE().isOn())\n        {\n            g.drawLine(xOffset, yOffset + 80, xOffset, yOffset + 40);\n        }\n        if (digit.getF().isOn())\n        {\n            g.drawLine(xOffset, yOffset + 40, xOffset, yOffset);\n        }\n        if (digit.getG().isOn())\n        {\n            g.drawLine(xOffset, yOffset + 40, xOffset + 40, yOffset + 40);\n        }\n    }\n}", "class_id": 0, "repo": "phaensgen/relay-logic-simulator", "file": "src/sunday/resi/example/relayclock/RelayClockCanvas.java", "last_update_at": "2020-10-07T05:43:07+00:00", "question_id": "814087476f1ba62432f05c3705ffb1608b313e32", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RelayClockCanvas extends Canvas\n{\n    private static final long serialVersionUID = 1L;\n    private RelayClockDigitPCB digitS0;\n    private RelayClockDigitPCB digitS1;\n    private RelayClockDigitPCB digitM0;\n    private RelayClockDigitPCB digitM1;\n    private RelayClockDigitPCB digitH0;\n    private RelayClockDigitPCB digitH1;\n    /**\n     * The constructor.\n     */\n    public RelayClockCanvas(RelayClock clock)\n    {\n        this.digitS0 = clock.getDisplayS0();\n        this.digitS1 = clock.getDisplayS1();\n        this.digitM0 = clock.getDisplayM0();\n        this.digitM1 = clock.getDisplayM1();\n        this.digitH0 = clock.getDisplayH0();\n        this.digitH1 = clock.getDisplayH1();\n    }\n    @Override\n    public void update(Graphics g)\n    {\n        paint(g);\n    }\n    @Override\n    public void paint(Graphics g)\n    {\n        int w = getWidth();\n        int h = getHeight();\n        g.setColor(Color.DARK_GRAY);\n        g.fillRect(0, 0, w, h);\n        // paint it in the middle of the canvas\n        int x = (w - 330) / 2;\n        int y = (h - 120) / 2;\n        paint(digitH1.getDisplay(), g, x + 20, y + 20);\n        paint(digitH0.getDisplay(), g, x + 70, y + 20);\n        paint(digitM1.getDisplay(), g, x + 120, y + 20);\n        paint(digitM0.getDisplay(), g, x + 170, y + 20);\n        paint(digitS1.getDisplay(), g, x + 220, y + 20);\n        paint(digitS0.getDisplay(), g, x + 270, y + 20);\n    }\n    private void paint(SevenSegmentDisplay digit, Graphics g, int xOffset, int yOffset)\n    {\n        g.setColor(Color.GREEN);\n        if (digit.getA().isOn())\n        {\n            g.drawLine(xOffset, yOffset, xOffset + 40, yOffset);\n        }\n        if (digit.getB().isOn())\n        {\n            g.drawLine(xOffset + 40, yOffset, xOffset + 40, yOffset + 40);\n        }\n        if (digit.getC().isOn())\n        {\n            g.drawLine(xOffset + 40, yOffset + 40, xOffset + 40, yOffset + 80);\n        }\n        if (digit.getD().isOn())\n        {\n            g.drawLine(xOffset, yOffset + 80, xOffset + 40, yOffset + 80);\n        }\n        if (digit.getE().isOn())\n        {\n            g.drawLine(xOffset, yOffset + 80, xOffset, yOffset + 40);\n        }\n        if (digit.getF().isOn())\n        {\n            g.drawLine(xOffset, yOffset + 40, xOffset, yOffset);\n        }\n        if (digit.getG().isOn())\n        {\n            g.drawLine(xOffset, yOffset + 40, xOffset + 40, yOffset + 40);\n        }\n    }\n"]]}
{"hexsha": "0eb0ffd73bf0b4053d167eff77958be954d782d0", "ext": "java", "lang": "Java", "content": "class FSQueueTest {\r\n\r\n    @TempDir\r\n    static Path folder;\r\n\r\n    private CommitterContext ctx;\r\n    private FSQueue queue;\r\n\r\n    @BeforeEach\r\n    public void setup() {\r\n        this.ctx = CommitterContext.builder().setWorkDir(folder).build();\r\n        this.queue = new FSQueue();\r\n    }\r\n\r\n    @Test\r\n    void testQueue() throws CommitterException, IOException {\r\n\r\n        final MutableInt batchQty = new MutableInt();\r\n        final Set<String> batchRefs = new TreeSet<>();\r\n\r\n        queue.setBatchSize(5);\r\n        queue.init(ctx, it -> {\r\n            batchQty.increment();\r\n            while (it.hasNext()) {\r\n                ICommitterRequest req = it.next();\r\n                batchRefs.add(req.getReference());\r\n            }\r\n        });\r\n\r\n        // Add test data\r\n        for (int i = 0; i < 13; i++) {\r\n            queue.queue(TestUtil.upsertRequest(i + 1));\r\n        }\r\n        queue.close();\r\n\r\n        // records should have been processed in 3 batches.\r\n        Assertions.assertEquals(3, batchQty.getValue());\r\n\r\n        // There should be 13 obtained from queue in total\r\n        Assertions.assertEquals(13, batchRefs.size());\r\n\r\n        // Queue directory should be empty.\r\n        Assertions.assertEquals(0, Files.find(folder,  1,\r\n                (f, a) -> f.toFile().getName().endsWith(\r\n                        FSQueueUtil.EXT)).count());\r\n    }\r\n\r\n    @Test\r\n    void testWriteRead() {\r\n        FSQueue q = new FSQueue();\r\n        q.setBatchSize(50);\r\n        q.setMaxPerFolder(100);\r\n        q.setCommitLeftoversOnInit(true);\r\n        q.setIgnoreErrors(true);\r\n        q.setMaxRetries(6);\r\n        q.setRetryDelay(666);\r\n        XML.assertWriteRead(q, \"queue\");\r\n    }\r\n}", "class_id": 0, "repo": "Norconex/committer-core", "file": "src/test/java/com/norconex/committer/core3/batch/queue/impl/FSQueueTest.java", "last_update_at": "2020-09-03T20:50:19+00:00", "question_id": "0eb0ffd73bf0b4053d167eff77958be954d782d0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class FSQueueTest {\r\n\r\n    @TempDir\r\n    static Path folder;\r\n\r\n    private CommitterContext ctx;\r\n    private FSQueue queue;\r\n\r\n    @BeforeEach\r\n    public void setup() {\r\n        this.ctx = CommitterContext.builder().setWorkDir(folder).build();\r\n        this.queue = new FSQueue();\r\n    }\r\n\r\n    @Test\r\n    void testQueue() throws CommitterException, IOException {\r\n\r\n        final MutableInt batchQty = new MutableInt();\r\n        final Set<String> batchRefs = new TreeSet<>();\r\n\r\n        queue.setBatchSize(5);\r\n        queue.init(ctx, it -> {\r\n            batchQty.increment();\r\n            while (it.hasNext()) {\r\n                ICommitterRequest req = it.next();\r\n                batchRefs.add(req.getReference());\r\n            }\r\n        });\r\n\r\n        // Add test data\r\n        for (int i = 0; i < 13; i++) {\r\n            queue.queue(TestUtil.upsertRequest(i + 1));\r\n        }\r\n        queue.close();\r\n\r\n        // records should have been processed in 3 batches.\r\n        Assertions.assertEquals(3, batchQty.getValue());\r\n\r\n        // There should be 13 obtained from queue in total\r\n        Assertions.assertEquals(13, batchRefs.size());\r\n\r\n        // Queue directory should be empty.\r\n        Assertions.assertEquals(0, Files.find(folder,  1,\r\n                (f, a) -> f.toFile().getName().endsWith(\r\n                        FSQueueUtil.EXT)).count());\r\n    }\r\n\r\n    @Test\r\n    void testWriteRead() {\r\n        FSQueue q = new FSQueue();\r\n        q.setBatchSize(50);\r\n        q.setMaxPerFolder(100);\r\n        q.setCommitLeftoversOnInit(true);\r\n        q.setIgnoreErrors(true);\r\n        q.setMaxRetries(6);\r\n        q.setRetryDelay(666);\r\n        XML.assertWriteRead(q, \"queue\");\r\n    }\r\n"]]}
{"hexsha": "4f25c79d3ce4213c9407f9d977856de673bcef22", "ext": "java", "lang": "Java", "content": "@Service\npublic class FlowManagerService {\n    protected final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    public static final String FLOW_FILE_EXTENSION = \".flow.json\";\n\n    @Autowired\n    private FlowManager flowManager;\n\n    @Autowired\n    private FlowRunnerImpl flowRunner;\n\n    @Autowired\n    private StepDefinitionManagerService stepDefinitionManagerService;\n\n    @Autowired\n    HubConfigImpl hubConfig;\n\n    @Autowired\n    private FileSystemWatcherService watcherService;\n\n    @Autowired\n    private DataHubService dataHubService;\n\n    @Autowired\n    private Scaffolding scaffolding;\n\n    @Autowired\n    private AsyncFlowService asyncFlowService;\n\n    private CustomStepValidator customStepValidator = null;\n\n    public List<FlowStepModel> getFlows() {\n        return asyncFlowService.getFlows(true);\n    }\n\n    public FlowStepModel createFlow(String flowJson, boolean checkExists) throws IOException {\n        JSONObject jsonObject;\n        try {\n            jsonObject = new JSONObject(flowJson);\n\n            JSONUtils.trimText(jsonObject, \"separator\");\n        }\n        catch (IOException e) {\n            throw new DataHubException(\"Unable to parse flow json string : \" + e.getMessage());\n        }\n\n        if (!jsonObject.isExist(\"name\") || StringUtils.isEmpty(jsonObject.getString(\"name\"))) {\n            throw new BadRequestException(\"Flow Name not provided. Flow Name is required.\");\n        }\n\n        String flowName = jsonObject.getString(\"name\");\n        Flow flow = null;\n        if (checkExists) {\n            if (flowManager.isFlowExisted(flowName)) {\n                throw new DataHubException(\"A Flow with \" + flowName + \" already exists.\");\n            }\n            flow = new FlowImpl();\n            flow.setName(flowName);\n        }\n        else {\n            //for PUT updating\n            flow = flowManager.getFlow(flowName);\n            if (flow == null) {\n                throw new DataHubException(\"Changing flow name not supported.\");\n            }\n        }\n        FlowStepModel.createFlowSteps(flow, jsonObject);\n        flowManager.saveFlow(flow);\n\n        FlowStepModel fsm = FlowStepModel.transformFromFlow(flow);\n        return fsm;\n    }\n\n    public FlowStepModel getFlow(String flowName, boolean fromRunFlow) {\n        Flow flow = flowManager.getFlow(flowName);\n        if (flow == null) {\n            throw new NotFoundException(flowName + \" not found!\");\n        }\n        FlowStepModel fsm = asyncFlowService.getFlowStepModel(flow, fromRunFlow, null);\n        return fsm;\n    }\n\n    public List<String> getFlowNames() {\n        return flowManager.getFlowNames();\n    }\n\n    public JsonNode validateStep(String flowName, String stepId){\n        Flow flow = flowManager.getFlow(flowName);\n        if (flow == null) {\n            throw new NotFoundException(\"Could not find a flow with a name of \" + flowName);\n        }\n        String stepNum = getStepKeyInStepMap(flow, stepId);\n        return getCustomStepValidator().validate(flowName, stepNum);\n    }\n\n    public void deleteFlow(String flowName) {\n        flowManager.deleteFlow(flowName);\n        dataHubService.deleteDocument(\"/flows/\" + flowName + FLOW_FILE_EXTENSION, DatabaseKind.STAGING);\n        dataHubService.deleteDocument(\"/flows/\" + flowName + FLOW_FILE_EXTENSION, DatabaseKind.FINAL);\n    }\n\n    public List<StepModel> getSteps(String flowName) {\n        Flow flow = flowManager.getFlow(flowName);\n        Map<String, Step> stepMap = flow.getSteps();\n\n        List<StepModel> stepModelList = new ArrayList<>();\n        for (String key : stepMap.keySet()) {\n            Step step = stepMap.get(key);\n            StepModel stepModel = transformStepToWebModel(step);\n            stepModelList.add(stepModel);\n        }\n\n        return stepModelList;\n    }\n\n    public StepModel getStep(String flowName, String stepId) {\n        Flow flow = flowManager.getFlow(flowName);\n        if (flow == null) {\n            throw new NotFoundException(flowName + \" not found.\");\n        }\n\n        Step step = flow.getStep(getStepKeyInStepMap(flow, stepId));\n        if (step == null) {\n            throw new NotFoundException(stepId + \" not found.\");\n        }\n\n        return transformStepToWebModel(step);\n    }\n\n    public StepModel createStep(String flowName, Integer stepOrder, String stepId, String stringStep) {\n        StepModel stepModel;\n        JsonNode stepJson;\n        Flow flow = flowManager.getFlow(flowName);\n        Step existingStep = flow.getStep(getStepKeyInStepMap(flow, stepId));\n\n        if (existingStep == null && !StringUtils.isEmpty(stepId)) {\n            throw new NotFoundException(\"Step \" + stepId + \" Not Found\");\n        }\n\n        try {\n            stepJson = JSONObject.readInput(stringStep);\n\n            JSONUtils.trimText(stepJson, \"separator\");\n\n            stepModel = StepModel.fromJson(stepJson);\n        }\n        catch (IOException e) {\n            throw new BadRequestException(\"Error parsing JSON\");\n        }\n\n        if (stepModel == null) {\n            throw new BadRequestException();\n        }\n\n        Step step = StepModel.transformToCoreStepModel(stepModel, stepJson);\n\n        if (step.getStepDefinitionType() == null) {\n            throw new BadRequestException(\"Invalid Step Definition Type\");\n        }\n\n        if (step.getStepDefinitionName() == null) {\n            throw new BadRequestException(\"Invalid Step Definition Name\");\n        }\n\n        if (stepId != null) {\n            if (!stepId.equals(step.getName() + \"-\" + step.getStepDefinitionType())) {\n                throw new BadRequestException(\"Changing step name or step type not supported.\");\n            }\n        }\n        if(!EnumUtils.isValidEnumIgnoreCase(StepDefinition.StepDefinitionType.class, step.getStepDefinitionType().toString())) {\n            throw new BadRequestException(\"Invalid Step Type\");\n        }\n\n        step = upsertStepDefinition(stepModel, step);\n\n        Map<String, Step> currSteps = flow.getSteps();\n        if (stepId != null) {\n            String key = getStepKeyInStepMap(flow, stepId);\n            if (StringUtils.isNotEmpty(key)) {\n                currSteps.put(key, step);\n            }\n            flow.setSteps(currSteps);\n        }\n        else {\n            if (stepOrder == null || stepOrder > currSteps.size()) {\n                currSteps.put(String.valueOf(currSteps.size() + 1), step);\n            }\n            else {\n                Map<String, Step> newSteps = new LinkedHashMap<>();\n                final Integer[] count = {1};\n                Step finalStep = step;\n                currSteps.values().forEach(s -> {\n                    if (count[0].equals(stepOrder)) {\n                        newSteps.put(String.valueOf(count[0]++), finalStep);\n                    }\n                    newSteps.put(String.valueOf(count[0]), s);\n                    ++count[0];\n                });\n                flow.setSteps(newSteps);\n            }\n        }\n\n        if (existingStep != null && existingStep.isEqual(step)) {\n            return transformStepToWebModel(existingStep);\n        }\n\n        flowManager.saveFlow(flow);\n        return transformStepToWebModel(step);\n    }\n\n    protected Step mergeDefaultStepDefinitionIntoStep(StepModel stepModel, Step step) {\n        String stepType = step.getStepDefinitionType().toString().toLowerCase();\n        StepDefinition defaultStepDefinition = getDefaultStepDefinitionFromResources(\"hub-internal-artifacts/step-definitions/\" + stepType + \"/marklogic/\"+ step.getStepDefinitionName() +\".step.json\", step.getStepDefinitionType());\n        Step defaultStep = defaultStepDefinition.transformToStep(step.getName(), defaultStepDefinition, new Step());\n        return StepModel.mergeFields(stepModel, defaultStep, step);\n    }\n\n    protected Step upsertStepDefinition(StepModel stepModel, Step step) {\n        if (stepDefinitionManagerService.getStepDefinition(step.getStepDefinitionName(), step.getStepDefinitionType()) != null) {\n            String stepType = step.getStepDefinitionType().toString().toLowerCase();\n            if(step.getStepDefinitionName().equalsIgnoreCase(\"default-\" + stepType) || \"entity-services-mapping\".equalsIgnoreCase(step.getStepDefinitionName())) {\n                step = mergeDefaultStepDefinitionIntoStep(stepModel, step);\n            }\n            else {\n                StepDefinition oldStepDefinition = stepDefinitionManagerService.getStepDefinition(step.getStepDefinitionName(), step.getStepDefinitionType());\n                StepDefinition stepDefinition = transformFromStep(oldStepDefinition, step, stepModel);\n                stepDefinitionManagerService.saveStepDefinition(stepDefinition);\n            }\n        }\n        else {\n            String stepDefName = step.getStepDefinitionName();\n            StepDefinition.StepDefinitionType stepDefType = step.getStepDefinitionType();\n            String modulePath = \"/custom-modules/\" + stepDefType.toString().toLowerCase() + \"/\" + stepDefName + \"/main.sjs\";\n\n            StepDefinition stepDefinition = StepDefinition.create(stepDefName, stepDefType);\n            stepDefinition = transformFromStep(stepDefinition, step, stepModel);\n\n            scaffolding.createCustomModule(stepDefName, stepDefType.toString());\n            stepDefinition.setModulePath(modulePath);\n            stepDefinitionManagerService.createStepDefinition(stepDefinition);\n        }\n        return step;\n    }\n\n    public void deleteStep(String flowName, String stepId) {\n        Flow flow = flowManager.getFlow(flowName);\n        String key = getStepKeyInStepMap(flow, stepId);\n\n        if (StringUtils.isEmpty(key)) {\n            throw new BadRequestException(\"Invalid Step Id\");\n        }\n\n        try {\n            flowManager.deleteStep(flow, key);\n        }\n        catch (DataHubProjectException e) {\n            throw new NotFoundException(e.getMessage());\n        }\n    }\n\n    /**\n     * This is synchronized because Coverity is reporting that flowManagerService is being modified without proper\n     * synchronization when it's invoked by FlowController.\n     *\n     * @param flowName\n     * @param steps\n     * @return\n     */\n    public synchronized FlowStepModel runFlow(String flowName, List<String> steps) {\n        if (steps == null || steps.size() == 0) {\n            flowRunner.runFlow(flowName);\n        }\n        else {\n            Flow flow = flowManager.getFlow(flowName);\n            List<String> restrictedSteps = new ArrayList<>();\n            steps.forEach((step) -> restrictedSteps.add(this.getStepKeyInStepMap(flow, step)));\n            flowRunner.runFlow(flowName, restrictedSteps);\n        }\n        return getFlow(flowName, true);\n    }\n\n    public FlowStepModel stop(String flowName) {\n        List<String> jobIds = flowRunner.getQueuedJobIdsFromFlow(flowName);\n        Iterator<String> itr = jobIds.iterator();\n        if (!itr.hasNext()) {\n            throw new BadRequestException(\"Flow not running.\");\n        }\n        while (itr.hasNext()) {\n            flowRunner.stopJob(itr.next());\n        }\n        return getFlow(flowName, false);\n    }\n\n    /*\n    The core and web models for steps are different, webModel has 'modulePath' which provides the uri of the main.sjs\n    whereas it is not present in the core step model. Hence the following 2 transform methods additionally are meant to\n    set modulePaths in 'StepModel' and 'StepDefinition' .\n     */\n    private StepModel transformStepToWebModel(Step step) {\n        StepModel stepModel = StepModel.transformToWebStepModel(step);\n        StepDefinition stepDef = stepDefinitionManagerService.getStepDefinition(step.getStepDefinitionName(), step.getStepDefinitionType());\n        stepModel.setModulePath(stepDef.getModulePath());\n        return stepModel;\n    }\n\n    private StepDefinition transformFromStep(StepDefinition stepDefinition, Step step, StepModel stepModel) {\n        StepDefinition newStepDefinition = stepDefinition.transformFromStep(stepDefinition, step);\n        newStepDefinition.setModulePath(stepModel.getModulePath());\n        return newStepDefinition;\n    }\n\n    private String getStepKeyInStepMap(Flow flow, String stepId) {\n        if (flow == null || StringUtils.isEmpty(stepId)) {\n            return null;\n        }\n\n        // Split on the last occurrence of \"-\"\n        String[] stepStr = stepId.split(\"-(?!.*-)\");\n\n        if (stepStr.length == 2) {\n            String name = stepStr[0];\n            String type = stepStr[1];\n            String[] key = new String[1];\n\n            flow.getSteps().forEach((k, v) -> {\n                if (name.equals(v.getName()) && type.equalsIgnoreCase(v.getStepDefinitionType().toString())) {\n                    key[0] = k;\n                }\n            });\n\n            return key[0];\n        }\n\n        return null;\n    }\n\n    private StepDefinition getDefaultStepDefinitionFromResources(String resourcePath, StepDefinition.StepDefinitionType stepDefinitionType) {\n        try (InputStream in = FlowManagerService.class.getClassLoader().getResourceAsStream(resourcePath)) {\n            JSONObject jsonObject = new JSONObject(IOUtils.toString(in));\n            StepDefinition defaultStep = StepDefinition.create(stepDefinitionType.toString(), stepDefinitionType);\n            defaultStep.deserialize(jsonObject.jsonNode());\n            return defaultStep;\n        }\n        catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private synchronized CustomStepValidator getCustomStepValidator() {\n        if (customStepValidator == null) {\n            customStepValidator = new CustomStepValidator(hubConfig.newStagingClient());\n        }\n        return customStepValidator;\n    }\n}", "class_id": 0, "repo": "MLjyang/marklogic-data-hub", "file": "web/src/main/java/com/marklogic/hub/web/service/FlowManagerService.java", "last_update_at": "2020-11-02T20:55:53+00:00", "question_id": "4f25c79d3ce4213c9407f9d977856de673bcef22", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\npublic class FlowManagerService {\n    protected final Logger logger = LoggerFactory.getLogger(this.getClass());\n    public static final String FLOW_FILE_EXTENSION = \".flow.json\";\n    @Autowired\n    private FlowManager flowManager;\n    @Autowired\n    private FlowRunnerImpl flowRunner;\n    @Autowired\n    private StepDefinitionManagerService stepDefinitionManagerService;\n    @Autowired\n    HubConfigImpl hubConfig;\n    @Autowired\n    private FileSystemWatcherService watcherService;\n    @Autowired\n    private DataHubService dataHubService;\n    @Autowired\n    private Scaffolding scaffolding;\n    @Autowired\n    private AsyncFlowService asyncFlowService;\n    private CustomStepValidator customStepValidator = null;\n    public List<FlowStepModel> getFlows() {\n        return asyncFlowService.getFlows(true);\n    }\n    public FlowStepModel createFlow(String flowJson, boolean checkExists) throws IOException {\n        JSONObject jsonObject;\n        try {\n            jsonObject = new JSONObject(flowJson);\n            JSONUtils.trimText(jsonObject, \"separator\");\n        }\n        catch (IOException e) {\n            throw new DataHubException(\"Unable to parse flow json string : \" + e.getMessage());\n        }\n        if (!jsonObject.isExist(\"name\") || StringUtils.isEmpty(jsonObject.getString(\"name\"))) {\n            throw new BadRequestException(\"Flow Name not provided. Flow Name is required.\");\n        }\n        String flowName = jsonObject.getString(\"name\");\n        Flow flow = null;\n        if (checkExists) {\n            if (flowManager.isFlowExisted(flowName)) {\n                throw new DataHubException(\"A Flow with \" + flowName + \" already exists.\");\n            }\n            flow = new FlowImpl();\n            flow.setName(flowName);\n        }\n        else {\n            //for PUT updating\n            flow = flowManager.getFlow(flowName);\n            if (flow == null) {\n                throw new DataHubException(\"Changing flow name not supported.\");\n            }\n        }\n        FlowStepModel.createFlowSteps(flow, jsonObject);\n        flowManager.saveFlow(flow);\n        FlowStepModel fsm = FlowStepModel.transformFromFlow(flow);\n        return fsm;\n    }\n    public FlowStepModel getFlow(String flowName, boolean fromRunFlow) {\n        Flow flow = flowManager.getFlow(flowName);\n        if (flow == null) {\n            throw new NotFoundException(flowName + \" not found!\");\n        }\n        FlowStepModel fsm = asyncFlowService.getFlowStepModel(flow, fromRunFlow, null);\n        return fsm;\n    }\n    public List<String> getFlowNames() {\n        return flowManager.getFlowNames();\n    }\n    public JsonNode validateStep(String flowName, String stepId){\n        Flow flow = flowManager.getFlow(flowName);\n        if (flow == null) {\n            throw new NotFoundException(\"Could not find a flow with a name of \" + flowName);\n        }\n        String stepNum = getStepKeyInStepMap(flow, stepId);\n        return getCustomStepValidator().validate(flowName, stepNum);\n    }\n    public void deleteFlow(String flowName) {\n        flowManager.deleteFlow(flowName);\n        dataHubService.deleteDocument(\"/flows/\" + flowName + FLOW_FILE_EXTENSION, DatabaseKind.STAGING);\n        dataHubService.deleteDocument(\"/flows/\" + flowName + FLOW_FILE_EXTENSION, DatabaseKind.FINAL);\n    }\n    public List<StepModel> getSteps(String flowName) {\n        Flow flow = flowManager.getFlow(flowName);\n        Map<String, Step> stepMap = flow.getSteps();\n        List<StepModel> stepModelList = new ArrayList<>();\n        for (String key : stepMap.keySet()) {\n            Step step = stepMap.get(key);\n            StepModel stepModel = transformStepToWebModel(step);\n            stepModelList.add(stepModel);\n        }\n        return stepModelList;\n    }\n    public StepModel getStep(String flowName, String stepId) {\n        Flow flow = flowManager.getFlow(flowName);\n        if (flow == null) {\n            throw new NotFoundException(flowName + \" not found.\");\n        }\n        Step step = flow.getStep(getStepKeyInStepMap(flow, stepId));\n        if (step == null) {\n            throw new NotFoundException(stepId + \" not found.\");\n        }\n        return transformStepToWebModel(step);\n    }\n    public StepModel createStep(String flowName, Integer stepOrder, String stepId, String stringStep) {\n        StepModel stepModel;\n        JsonNode stepJson;\n        Flow flow = flowManager.getFlow(flowName);\n        Step existingStep = flow.getStep(getStepKeyInStepMap(flow, stepId));\n        if (existingStep == null && !StringUtils.isEmpty(stepId)) {\n            throw new NotFoundException(\"Step \" + stepId + \" Not Found\");\n        }\n        try {\n            stepJson = JSONObject.readInput(stringStep);\n            JSONUtils.trimText(stepJson, \"separator\");\n            stepModel = StepModel.fromJson(stepJson);\n        }\n        catch (IOException e) {\n            throw new BadRequestException(\"Error parsing JSON\");\n        }\n        if (stepModel == null) {\n            throw new BadRequestException();\n        }\n        Step step = StepModel.transformToCoreStepModel(stepModel, stepJson);\n        if (step.getStepDefinitionType() == null) {\n            throw new BadRequestException(\"Invalid Step Definition Type\");\n        }\n        if (step.getStepDefinitionName() == null) {\n            throw new BadRequestException(\"Invalid Step Definition Name\");\n        }\n        if (stepId != null) {\n            if (!stepId.equals(step.getName() + \"-\" + step.getStepDefinitionType())) {\n                throw new BadRequestException(\"Changing step name or step type not supported.\");\n            }\n        }\n        if(!EnumUtils.isValidEnumIgnoreCase(StepDefinition.StepDefinitionType.class, step.getStepDefinitionType().toString())) {\n            throw new BadRequestException(\"Invalid Step Type\");\n        }\n        step = upsertStepDefinition(stepModel, step);\n        Map<String, Step> currSteps = flow.getSteps();\n        if (stepId != null) {\n            String key = getStepKeyInStepMap(flow, stepId);\n            if (StringUtils.isNotEmpty(key)) {\n                currSteps.put(key, step);\n            }\n            flow.setSteps(currSteps);\n        }\n        else {\n            if (stepOrder == null || stepOrder > currSteps.size()) {\n                currSteps.put(String.valueOf(currSteps.size() + 1), step);\n            }\n            else {\n                Map<String, Step> newSteps = new LinkedHashMap<>();\n                final Integer[] count = {1};\n                Step finalStep = step;\n                currSteps.values().forEach(s -> {\n                    if (count[0].equals(stepOrder)) {\n                        newSteps.put(String.valueOf(count[0]++), finalStep);\n                    }\n                    newSteps.put(String.valueOf(count[0]), s);\n                    ++count[0];\n                });\n                flow.setSteps(newSteps);\n            }\n        }\n        if (existingStep != null && existingStep.isEqual(step)) {\n            return transformStepToWebModel(existingStep);\n        }\n        flowManager.saveFlow(flow);\n        return transformStepToWebModel(step);\n    }\n    protected Step mergeDefaultStepDefinitionIntoStep(StepModel stepModel, Step step) {\n        String stepType = step.getStepDefinitionType().toString().toLowerCase();\n        StepDefinition defaultStepDefinition = getDefaultStepDefinitionFromResources(\"hub-internal-artifacts/step-definitions/\" + stepType + \"/marklogic/\"+ step.getStepDefinitionName() +\".step.json\", step.getStepDefinitionType());\n        Step defaultStep = defaultStepDefinition.transformToStep(step.getName(), defaultStepDefinition, new Step());\n        return StepModel.mergeFields(stepModel, defaultStep, step);\n    }\n    protected Step upsertStepDefinition(StepModel stepModel, Step step) {\n        if (stepDefinitionManagerService.getStepDefinition(step.getStepDefinitionName(), step.getStepDefinitionType()) != null) {\n            String stepType = step.getStepDefinitionType().toString().toLowerCase();\n            if(step.getStepDefinitionName().equalsIgnoreCase(\"default-\" + stepType) || \"entity-services-mapping\".equalsIgnoreCase(step.getStepDefinitionName())) {\n                step = mergeDefaultStepDefinitionIntoStep(stepModel, step);\n            }\n            else {\n                StepDefinition oldStepDefinition = stepDefinitionManagerService.getStepDefinition(step.getStepDefinitionName(), step.getStepDefinitionType());\n                StepDefinition stepDefinition = transformFromStep(oldStepDefinition, step, stepModel);\n                stepDefinitionManagerService.saveStepDefinition(stepDefinition);\n            }\n        }\n        else {\n            String stepDefName = step.getStepDefinitionName();\n            StepDefinition.StepDefinitionType stepDefType = step.getStepDefinitionType();\n            String modulePath = \"/custom-modules/\" + stepDefType.toString().toLowerCase() + \"/\" + stepDefName + \"/main.sjs\";\n            StepDefinition stepDefinition = StepDefinition.create(stepDefName, stepDefType);\n            stepDefinition = transformFromStep(stepDefinition, step, stepModel);\n            scaffolding.createCustomModule(stepDefName, stepDefType.toString());\n            stepDefinition.setModulePath(modulePath);\n            stepDefinitionManagerService.createStepDefinition(stepDefinition);\n        }\n        return step;\n    }\n    public void deleteStep(String flowName, String stepId) {\n        Flow flow = flowManager.getFlow(flowName);\n        String key = getStepKeyInStepMap(flow, stepId);\n        if (StringUtils.isEmpty(key)) {\n            throw new BadRequestException(\"Invalid Step Id\");\n        }\n        try {\n            flowManager.deleteStep(flow, key);\n        }\n        catch (DataHubProjectException e) {\n            throw new NotFoundException(e.getMessage());\n        }\n    }\n    /**\n     * This is synchronized because Coverity is reporting that flowManagerService is being modified without proper\n     * synchronization when it's invoked by FlowController.\n     *\n     * @param flowName\n     * @param steps\n     * @return\n     */\n    public synchronized FlowStepModel runFlow(String flowName, List<String> steps) {\n        if (steps == null || steps.size() == 0) {\n            flowRunner.runFlow(flowName);\n        }\n        else {\n            Flow flow = flowManager.getFlow(flowName);\n            List<String> restrictedSteps = new ArrayList<>();\n            steps.forEach((step) -> restrictedSteps.add(this.getStepKeyInStepMap(flow, step)));\n            flowRunner.runFlow(flowName, restrictedSteps);\n        }\n        return getFlow(flowName, true);\n    }\n    public FlowStepModel stop(String flowName) {\n        List<String> jobIds = flowRunner.getQueuedJobIdsFromFlow(flowName);\n        Iterator<String> itr = jobIds.iterator();\n        if (!itr.hasNext()) {\n            throw new BadRequestException(\"Flow not running.\");\n        }\n        while (itr.hasNext()) {\n            flowRunner.stopJob(itr.next());\n        }\n        return getFlow(flowName, false);\n    }\n    /*\n    The core and web models for steps are different, webModel has 'modulePath' which provides the uri of the main.sjs\n    whereas it is not present in the core step model. Hence the following 2 transform methods additionally are meant to\n    set modulePaths in 'StepModel' and 'StepDefinition' .\n     */\n    private StepModel transformStepToWebModel(Step step) {\n        StepModel stepModel = StepModel.transformToWebStepModel(step);\n        StepDefinition stepDef = stepDefinitionManagerService.getStepDefinition(step.getStepDefinitionName(), step.getStepDefinitionType());\n        stepModel.setModulePath(stepDef.getModulePath());\n        return stepModel;\n    }\n    private StepDefinition transformFromStep(StepDefinition stepDefinition, Step step, StepModel stepModel) {\n        StepDefinition newStepDefinition = stepDefinition.transformFromStep(stepDefinition, step);\n        newStepDefinition.setModulePath(stepModel.getModulePath());\n        return newStepDefinition;\n    }\n    private String getStepKeyInStepMap(Flow flow, String stepId) {\n        if (flow == null || StringUtils.isEmpty(stepId)) {\n            return null;\n        }\n        // Split on the last occurrence of \"-\"\n        String[] stepStr = stepId.split(\"-(?!.*-)\");\n        if (stepStr.length == 2) {\n            String name = stepStr[0];\n            String type = stepStr[1];\n            String[] key = new String[1];\n            flow.getSteps().forEach((k, v) -> {\n                if (name.equals(v.getName()) && type.equalsIgnoreCase(v.getStepDefinitionType().toString())) {\n                    key[0] = k;\n                }\n            });\n            return key[0];\n        }\n        return null;\n    }\n    private StepDefinition getDefaultStepDefinitionFromResources(String resourcePath, StepDefinition.StepDefinitionType stepDefinitionType) {\n        try (InputStream in = FlowManagerService.class.getClassLoader().getResourceAsStream(resourcePath)) {\n            JSONObject jsonObject = new JSONObject(IOUtils.toString(in));\n            StepDefinition defaultStep = StepDefinition.create(stepDefinitionType.toString(), stepDefinitionType);\n            defaultStep.deserialize(jsonObject.jsonNode());\n            return defaultStep;\n        }\n        catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    private synchronized CustomStepValidator getCustomStepValidator() {\n        if (customStepValidator == null) {\n            customStepValidator = new CustomStepValidator(hubConfig.newStagingClient());\n        }\n        return customStepValidator;\n    }\n"]]}
{"hexsha": "d0e44d48b966f3921579c64d5f0e2127162ffde1", "ext": "java", "lang": "Java", "content": "public class LoadingIndicatorConfiguratorTest\n        extends AbstractConfigurationTest {\n\n    private final Registry registry = new Registry() {\n        {\n            set(UILifecycle.class, new UILifecycle());\n            set(StateTree.class, new StateTree(this));\n            set(LoadingIndicator.class, new LoadingIndicator());\n        }\n    };\n\n    private NodeMap configuration;\n\n    private LoadingIndicator loadingIndicator;\n\n    @Before\n    public void setup() {\n        StateNode rootNode = registry.getStateTree().getRootNode();\n        configuration = rootNode\n                .getMap(NodeFeatures.LOADING_INDICATOR_CONFIGURATION);\n        loadingIndicator = registry.getLoadingIndicator();\n        LoadingIndicatorConfigurator.observe(rootNode, loadingIndicator);\n    }\n\n    @Override\n    protected MapProperty getProperty(String key) {\n        return configuration.getProperty(key);\n    }\n\n    @Test\n    public void defaults() {\n        Assert.assertEquals(FIRST_DELAY_DEFAULT,\n                loadingIndicator.getFirstDelay());\n        Assert.assertEquals(SECOND_DELAY_DEFAULT,\n                loadingIndicator.getSecondDelay());\n        Assert.assertEquals(THIRD_DELAY_DEFAULT,\n                loadingIndicator.getThirdDelay());\n    }\n\n    @Test\n    public void setGetFirstDelay() {\n        testInt(FIRST_DELAY_KEY, loadingIndicator::getFirstDelay);\n    }\n\n    @Test\n    public void setGetSecondDelay() {\n        testInt(SECOND_DELAY_KEY, loadingIndicator::getSecondDelay);\n    }\n\n    @Test\n    public void setGetThirdDelay() {\n        testInt(THIRD_DELAY_KEY, loadingIndicator::getThirdDelay);\n    }\n\n}", "class_id": 0, "repo": "xdenser/flow", "file": "flow-client/src/test/java/com/vaadin/client/communication/LoadingIndicatorConfiguratorTest.java", "last_update_at": "2020-08-26T14:44:50+00:00", "question_id": "d0e44d48b966f3921579c64d5f0e2127162ffde1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LoadingIndicatorConfiguratorTest\n        extends AbstractConfigurationTest {\n    private final Registry registry = new Registry() {\n        {\n            set(UILifecycle.class, new UILifecycle());\n            set(StateTree.class, new StateTree(this));\n            set(LoadingIndicator.class, new LoadingIndicator());\n        }\n    };\n    private NodeMap configuration;\n    private LoadingIndicator loadingIndicator;\n    @Before\n    public void setup() {\n        StateNode rootNode = registry.getStateTree().getRootNode();\n        configuration = rootNode\n                .getMap(NodeFeatures.LOADING_INDICATOR_CONFIGURATION);\n        loadingIndicator = registry.getLoadingIndicator();\n        LoadingIndicatorConfigurator.observe(rootNode, loadingIndicator);\n    }\n    @Override\n    protected MapProperty getProperty(String key) {\n        return configuration.getProperty(key);\n    }\n    @Test\n    public void defaults() {\n        Assert.assertEquals(FIRST_DELAY_DEFAULT,\n                loadingIndicator.getFirstDelay());\n        Assert.assertEquals(SECOND_DELAY_DEFAULT,\n                loadingIndicator.getSecondDelay());\n        Assert.assertEquals(THIRD_DELAY_DEFAULT,\n                loadingIndicator.getThirdDelay());\n    }\n    @Test\n    public void setGetFirstDelay() {\n        testInt(FIRST_DELAY_KEY, loadingIndicator::getFirstDelay);\n    }\n    @Test\n    public void setGetSecondDelay() {\n        testInt(SECOND_DELAY_KEY, loadingIndicator::getSecondDelay);\n    }\n    @Test\n    public void setGetThirdDelay() {\n        testInt(THIRD_DELAY_KEY, loadingIndicator::getThirdDelay);\n    }\n"]]}
{"hexsha": "06298ab36d38caa9333cade74e69b82b6e69cd5f", "ext": "java", "lang": "Java", "content": "public class Ganzzahl implements EinfacherListenknoten {\n \n    public int wert;\n    private EinfacherListenknoten naechsterKnoten;\n \n    public Ganzzahl(int i) {\n        wert = i;\n        naechsterKnoten = null;\n    }\n    /**\n     * Einfuegen eines Nachfolgers\n     * @param n einzufuegender Listenknoten\n     */\n    @Override\n    public void setNachFolger(EinfacherListenknoten n) {\n        naechsterKnoten = n;\n    }\n    /**\n    * Auslesen des Nachfolgers\n    * @return der Nachfolger\n    */\n    @Override\n    public EinfacherListenknoten getNachfolger() {\n        return naechsterKnoten;\n    }\n \n    /**\n     * Hauptprogramm zum Testen\n     * @param args Kommandozeilenparameter (nicht ben\u00f6tigt)\n     */\n    public static void main(String[] args) {\n        Ganzzahl z1 = new Ganzzahl(11);\n        Ganzzahl z2 = new Ganzzahl(22);\n        Ganzzahl z3 = new Ganzzahl(33);\n        z1.setNachFolger(z2);\n        z2.setNachFolger(z3);\n    }\n}", "class_id": 0, "repo": "scalingbits/dhbwjava", "file": "s2/listen/Ganzzahl.java", "last_update_at": "2020-05-11T09:28:36+00:00", "question_id": "06298ab36d38caa9333cade74e69b82b6e69cd5f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Ganzzahl implements EinfacherListenknoten {\n    public int wert;\n    private EinfacherListenknoten naechsterKnoten;\n    public Ganzzahl(int i) {\n        wert = i;\n        naechsterKnoten = null;\n    }\n    /**\n     * Einfuegen eines Nachfolgers\n     * @param n einzufuegender Listenknoten\n     */\n    @Override\n    public void setNachFolger(EinfacherListenknoten n) {\n        naechsterKnoten = n;\n    }\n    /**\n    * Auslesen des Nachfolgers\n    * @return der Nachfolger\n    */\n    @Override\n    public EinfacherListenknoten getNachfolger() {\n        return naechsterKnoten;\n    }\n    /**\n     * Hauptprogramm zum Testen\n     * @param args Kommandozeilenparameter (nicht ben\u00f6tigt)\n     */\n    public static void main(String[] args) {\n        Ganzzahl z1 = new Ganzzahl(11);\n        Ganzzahl z2 = new Ganzzahl(22);\n        Ganzzahl z3 = new Ganzzahl(33);\n        z1.setNachFolger(z2);\n        z2.setNachFolger(z3);\n    }\n"]]}
{"hexsha": "f09a60ebc232f22fa0de186d6a0b896d022a02e5", "ext": "java", "lang": "Java", "content": "@SuppressWarnings(\"rawtypes\")\npublic final class Repository extends AbstractGitHubType<Map> implements Comparable<Repository> {\n\n    private volatile String fullName;\n\n    private volatile String name;\n\n    private volatile Permissions permissions;\n\n    /**\n     * Creates a new pre-initalized instance\n     * \n     * @param fullName The full name of the repository\n     * @param name The name of the repository\n     * @param permissions The user's permissions in this repository\n     */\n    public Repository(String fullName, String name, Permissions permissions) {\n        super(null, null);\n        this.fullName = fullName;\n        this.name = name;\n        this.permissions = permissions;\n    }\n\n    Repository(Map raw) {\n        super(getString(\"url\", raw), Map.class);\n        initialize(raw);\n    }\n\n    @Override\n    void initialize(Map raw) {\n        this.fullName = getString(\"full_name\", raw);\n        this.name = getString(\"name\", raw);\n        this.permissions = new Permissions(getMap(\"permissions\", raw));\n    }\n\n    /**\n     * Returns the full name of the repository\n     * \n     * @return the fill name of the repository\n     */\n    public String getFullName() {\n        return this.fullName;\n    }\n\n    /**\n     * Returns the name of the repository\n     * \n     * @return the name of the repository\n     */\n    public String getName() {\n        return this.name;\n    }\n\n    /**\n     * Returns the user's permissions in this repository\n     * \n     * @return the user's permissions in this repository\n     */\n    public Permissions getPermissions() {\n        return this.permissions;\n    }\n\n    @Override\n    public int compareTo(Repository o) {\n        return this.fullName.compareToIgnoreCase(o.getFullName());\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = (prime * result) + this.fullName.toLowerCase().hashCode();\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof Repository)) {\n            return false;\n        }\n        Repository other = (Repository) obj;\n        if (!this.fullName.equalsIgnoreCase(other.getFullName())) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Repository [fullName=\" + this.fullName + \", name=\" + this.name + \", permissions=\" + this.permissions + \"]\";\n    }\n\n}", "class_id": 0, "repo": "spring-operator/github-cla-integration", "file": "src/main/java/com/gopivotal/cla/github/Repository.java", "last_update_at": "2020-05-15T10:56:41+00:00", "question_id": "f09a60ebc232f22fa0de186d6a0b896d022a02e5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings(\"rawtypes\")\npublic final class Repository extends AbstractGitHubType<Map> implements Comparable<Repository> {\n    private volatile String fullName;\n    private volatile String name;\n    private volatile Permissions permissions;\n    /**\n     * Creates a new pre-initalized instance\n     * \n     * @param fullName The full name of the repository\n     * @param name The name of the repository\n     * @param permissions The user's permissions in this repository\n     */\n    public Repository(String fullName, String name, Permissions permissions) {\n        super(null, null);\n        this.fullName = fullName;\n        this.name = name;\n        this.permissions = permissions;\n    }\n    Repository(Map raw) {\n        super(getString(\"url\", raw), Map.class);\n        initialize(raw);\n    }\n    @Override\n    void initialize(Map raw) {\n        this.fullName = getString(\"full_name\", raw);\n        this.name = getString(\"name\", raw);\n        this.permissions = new Permissions(getMap(\"permissions\", raw));\n    }\n    /**\n     * Returns the full name of the repository\n     * \n     * @return the fill name of the repository\n     */\n    public String getFullName() {\n        return this.fullName;\n    }\n    /**\n     * Returns the name of the repository\n     * \n     * @return the name of the repository\n     */\n    public String getName() {\n        return this.name;\n    }\n    /**\n     * Returns the user's permissions in this repository\n     * \n     * @return the user's permissions in this repository\n     */\n    public Permissions getPermissions() {\n        return this.permissions;\n    }\n    @Override\n    public int compareTo(Repository o) {\n        return this.fullName.compareToIgnoreCase(o.getFullName());\n    }\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = (prime * result) + this.fullName.toLowerCase().hashCode();\n        return result;\n    }\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof Repository)) {\n            return false;\n        }\n        Repository other = (Repository) obj;\n        if (!this.fullName.equalsIgnoreCase(other.getFullName())) {\n            return false;\n        }\n        return true;\n    }\n    @Override\n    public String toString() {\n        return \"Repository [fullName=\" + this.fullName + \", name=\" + this.name + \", permissions=\" + this.permissions + \"]\";\n    }\n"]]}
{"hexsha": "6da84494d9f7a4023d8521930ca5bc512b552957", "ext": "java", "lang": "Java", "content": "@Deprecated\npublic class PipelineBuilder {\n  public PipelineBuilder(String application) {\n    pipeline = Execution.newPipeline(application);\n  }\n\n  public PipelineBuilder withTrigger(Trigger trigger) {\n    if (trigger != null) {\n      pipeline.setTrigger(trigger);\n    }\n    return this;\n  }\n\n  public PipelineBuilder withNotifications(List<Map<String, Object>> notifications) {\n    pipeline.getNotifications().clear();\n    if (notifications != null) {\n      pipeline.getNotifications().addAll(notifications);\n    }\n    return this;\n  }\n\n  public PipelineBuilder withPipelineConfigId(String id) {\n    pipeline.setPipelineConfigId(id);\n    return this;\n  }\n\n  public PipelineBuilder withStage(String type, String name, Map<String, Object> context) {\n    if (context.get(\"providerType\") != null && !(Arrays.asList(\"aws\", \"titus\")).contains(context.get(\"providerType\"))) {\n      type += \"_\" + context.get(\"providerType\");\n    }\n    pipeline.getStages().add(new Stage(pipeline, type, name, context));\n    return this;\n  }\n\n  public PipelineBuilder withStage(String type, String name) {\n    return withStage(type, name, new HashMap<>());\n  }\n\n  public PipelineBuilder withStage(String type) {\n    return withStage(type, type, new HashMap<>());\n  }\n\n  public PipelineBuilder withStages(List<Map<String, Object>> stages) {\n    stages.forEach(it -> {\n      String type = it.remove(\"type\").toString();\n      String name = it.containsKey(\"name\")? it.remove(\"name\").toString() : null;\n      withStage(type, name != null ? name : type, it);\n    });\n    return this;\n  }\n\n  public Execution build() {\n    pipeline.setBuildTime(System.currentTimeMillis());\n    pipeline.setAuthentication(Execution.AuthenticationDetails.build().orElse(new Execution.AuthenticationDetails()));\n\n    return pipeline;\n  }\n\n  public PipelineBuilder withName(String name) {\n    pipeline.setName(name);\n    return this;\n  }\n\n  public PipelineBuilder withLimitConcurrent(boolean concurrent) {\n    pipeline.setLimitConcurrent(concurrent);\n    return this;\n  }\n\n  public PipelineBuilder withKeepWaitingPipelines(boolean waiting) {\n    pipeline.setKeepWaitingPipelines(waiting);\n    return this;\n  }\n\n  public PipelineBuilder withOrigin(String origin) {\n    pipeline.setOrigin(origin);\n    return this;\n  }\n\n  public PipelineBuilder withSource(Execution.PipelineSource source) {\n    pipeline.setSource(source);\n    return this;\n  }\n\n  public PipelineBuilder withStartTimeExpiry(String startTimeExpiry) {\n    if (startTimeExpiry != null) {\n      pipeline.setStartTimeExpiry(Long.valueOf(startTimeExpiry));\n    }\n    return this;\n  }\n\n  private final Execution pipeline;\n}", "class_id": 0, "repo": "Click2Cloud-electron/orca", "file": "orca-core/src/main/java/com/netflix/spinnaker/orca/pipeline/model/PipelineBuilder.java", "last_update_at": "2020-03-05T08:22:51+00:00", "question_id": "6da84494d9f7a4023d8521930ca5bc512b552957", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Deprecated\npublic class PipelineBuilder {\n  public PipelineBuilder(String application) {\n    pipeline = Execution.newPipeline(application);\n  }\n  public PipelineBuilder withTrigger(Trigger trigger) {\n    if (trigger != null) {\n      pipeline.setTrigger(trigger);\n    }\n    return this;\n  }\n  public PipelineBuilder withNotifications(List<Map<String, Object>> notifications) {\n    pipeline.getNotifications().clear();\n    if (notifications != null) {\n      pipeline.getNotifications().addAll(notifications);\n    }\n    return this;\n  }\n  public PipelineBuilder withPipelineConfigId(String id) {\n    pipeline.setPipelineConfigId(id);\n    return this;\n  }\n  public PipelineBuilder withStage(String type, String name, Map<String, Object> context) {\n    if (context.get(\"providerType\") != null && !(Arrays.asList(\"aws\", \"titus\")).contains(context.get(\"providerType\"))) {\n      type += \"_\" + context.get(\"providerType\");\n    }\n    pipeline.getStages().add(new Stage(pipeline, type, name, context));\n    return this;\n  }\n  public PipelineBuilder withStage(String type, String name) {\n    return withStage(type, name, new HashMap<>());\n  }\n  public PipelineBuilder withStage(String type) {\n    return withStage(type, type, new HashMap<>());\n  }\n  public PipelineBuilder withStages(List<Map<String, Object>> stages) {\n    stages.forEach(it -> {\n      String type = it.remove(\"type\").toString();\n      String name = it.containsKey(\"name\")? it.remove(\"name\").toString() : null;\n      withStage(type, name != null ? name : type, it);\n    });\n    return this;\n  }\n  public Execution build() {\n    pipeline.setBuildTime(System.currentTimeMillis());\n    pipeline.setAuthentication(Execution.AuthenticationDetails.build().orElse(new Execution.AuthenticationDetails()));\n    return pipeline;\n  }\n  public PipelineBuilder withName(String name) {\n    pipeline.setName(name);\n    return this;\n  }\n  public PipelineBuilder withLimitConcurrent(boolean concurrent) {\n    pipeline.setLimitConcurrent(concurrent);\n    return this;\n  }\n  public PipelineBuilder withKeepWaitingPipelines(boolean waiting) {\n    pipeline.setKeepWaitingPipelines(waiting);\n    return this;\n  }\n  public PipelineBuilder withOrigin(String origin) {\n    pipeline.setOrigin(origin);\n    return this;\n  }\n  public PipelineBuilder withSource(Execution.PipelineSource source) {\n    pipeline.setSource(source);\n    return this;\n  }\n  public PipelineBuilder withStartTimeExpiry(String startTimeExpiry) {\n    if (startTimeExpiry != null) {\n      pipeline.setStartTimeExpiry(Long.valueOf(startTimeExpiry));\n    }\n    return this;\n  }\n  private final Execution pipeline;\n"]]}
{"hexsha": "dd9c20dfd25add4d214e93e3a7976446cb8d5899", "ext": "java", "lang": "Java", "content": "public class PrettyMessageBuilder extends TestEnvironment {\n\n    public static String getXmlSuiteName(ITestContext iTestContext) {\n        return iTestContext.getCurrentXmlTest().getSuite().getName();\n    }\n\n    public static String getXmlTestName(ITestContext iTestContext) {\n        return iTestContext.getName();\n    }\n\n    public static String getTestDescription(ITestResult iTestResult) {\n        return iTestResult.getMethod().getDescription().toUpperCase();\n    }\n\n    public static void messageStartSuite(ITestContext iTestContext) {\n        logger.info(StringUtils.repeat(\"#\", 110));\n        logger.info(StringUtils.repeat(\"=\", 31) + \"STARTING TEST SUITE \" + iTestContext.getStartDate() + StringUtils.repeat(\"=\", 30));\n        logger.info(StringUtils.repeat(\"#\", 110));\n    }\n\n    public static void messageEndSuite(ITestContext iTestContext) {\n        logger.info(StringUtils.repeat(\"#\", 110));\n        logger.info(StringUtils.repeat(\"=\", 32) + \"END OF TEST SUITE \" + iTestContext.getEndDate() + StringUtils.repeat(\"=\", 31));\n        logger.info(StringUtils.repeat(\"#\", 110));\n    }\n\n    public static void messageStartTest(ITestResult iTestResult) {\n        logger.info(StringUtils.repeat(\"=\", 48) + \" TEST STARTED \" + StringUtils.repeat(\"=\", 48));\n        logger.info(ANSI_BLUE + \"TEST NAME: \" + getTestDescription(iTestResult) + ANSI_RESET);\n        logger.info(String.format(\"Chosen executor: \\\"%S\\\"\", DriverFactory.getHost()));\n    }\n\n    public static void messageSuccessTest() {\n        logger.info(StringUtils.repeat(\"=\", 37) + \" TEST FINISHED WITH \" + ANSI_GREEN + \"SUCCESS STATUS \" + ANSI_RESET + StringUtils.repeat(\"=\", 38));\n    }\n\n    public static void messageFailTest() {\n        logger.info(StringUtils.repeat(\"=\", 38) + \" TEST FINISHED WITH \" + ANSI_RED + \"FAILED STATUS \" + ANSI_RESET + StringUtils.repeat(\"=\", 38));\n    }\n\n    public static void messageStartScenario(Scenario scenario) {\n        logger.info(StringUtils.repeat(\"#\", 110));\n        logger.info(StringUtils.repeat(\"=\", 46) + \" BEFORE SCENARIO \" + StringUtils.repeat(\"=\", 47));\n        logger.info(StringUtils.repeat(\"#\", 110));\n        logger.info(ANSI_BLUE + \"SCENARIO NAME: \" + scenario.getName().toUpperCase() + ANSI_RESET);\n        logger.info(String.format(\"Chosen executor: \\\"%S\\\"\", DriverFactory.getHost()));\n    }\n\n    public static void messageFinishScenario(Scenario scenario) {\n        String status = (scenario.isFailed() ? ANSI_RED + \"FAILED STATUS \" + ANSI_RESET : ANSI_GREEN + \"SUCCESS STATUS \" + ANSI_RESET);\n        logger.info(StringUtils.repeat(\"#\", 110));\n        logger.info(StringUtils.repeat(\"=\", 36) + \" SCENARIO FINISHED WITH \" + status + StringUtils.repeat(\"=\", 35));\n        logger.info(StringUtils.repeat(\"#\", 110));\n        System.out.println();\n    }\n}", "class_id": 0, "repo": "kabothu/Test_Automation-automationpractice", "file": "src/test/java/com/buildSettings/buildPrettyMessage/PrettyMessageBuilder.java", "last_update_at": "2020-06-10T06:12:28+00:00", "question_id": "dd9c20dfd25add4d214e93e3a7976446cb8d5899", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PrettyMessageBuilder extends TestEnvironment {\n    public static String getXmlSuiteName(ITestContext iTestContext) {\n        return iTestContext.getCurrentXmlTest().getSuite().getName();\n    }\n    public static String getXmlTestName(ITestContext iTestContext) {\n        return iTestContext.getName();\n    }\n    public static String getTestDescription(ITestResult iTestResult) {\n        return iTestResult.getMethod().getDescription().toUpperCase();\n    }\n    public static void messageStartSuite(ITestContext iTestContext) {\n        logger.info(StringUtils.repeat(\"#\", 110));\n        logger.info(StringUtils.repeat(\"=\", 31) + \"STARTING TEST SUITE \" + iTestContext.getStartDate() + StringUtils.repeat(\"=\", 30));\n        logger.info(StringUtils.repeat(\"#\", 110));\n    }\n    public static void messageEndSuite(ITestContext iTestContext) {\n        logger.info(StringUtils.repeat(\"#\", 110));\n        logger.info(StringUtils.repeat(\"=\", 32) + \"END OF TEST SUITE \" + iTestContext.getEndDate() + StringUtils.repeat(\"=\", 31));\n        logger.info(StringUtils.repeat(\"#\", 110));\n    }\n    public static void messageStartTest(ITestResult iTestResult) {\n        logger.info(StringUtils.repeat(\"=\", 48) + \" TEST STARTED \" + StringUtils.repeat(\"=\", 48));\n        logger.info(ANSI_BLUE + \"TEST NAME: \" + getTestDescription(iTestResult) + ANSI_RESET);\n        logger.info(String.format(\"Chosen executor: \\\"%S\\\"\", DriverFactory.getHost()));\n    }\n    public static void messageSuccessTest() {\n        logger.info(StringUtils.repeat(\"=\", 37) + \" TEST FINISHED WITH \" + ANSI_GREEN + \"SUCCESS STATUS \" + ANSI_RESET + StringUtils.repeat(\"=\", 38));\n    }\n    public static void messageFailTest() {\n        logger.info(StringUtils.repeat(\"=\", 38) + \" TEST FINISHED WITH \" + ANSI_RED + \"FAILED STATUS \" + ANSI_RESET + StringUtils.repeat(\"=\", 38));\n    }\n    public static void messageStartScenario(Scenario scenario) {\n        logger.info(StringUtils.repeat(\"#\", 110));\n        logger.info(StringUtils.repeat(\"=\", 46) + \" BEFORE SCENARIO \" + StringUtils.repeat(\"=\", 47));\n        logger.info(StringUtils.repeat(\"#\", 110));\n        logger.info(ANSI_BLUE + \"SCENARIO NAME: \" + scenario.getName().toUpperCase() + ANSI_RESET);\n        logger.info(String.format(\"Chosen executor: \\\"%S\\\"\", DriverFactory.getHost()));\n    }\n    public static void messageFinishScenario(Scenario scenario) {\n        String status = (scenario.isFailed() ? ANSI_RED + \"FAILED STATUS \" + ANSI_RESET : ANSI_GREEN + \"SUCCESS STATUS \" + ANSI_RESET);\n        logger.info(StringUtils.repeat(\"#\", 110));\n        logger.info(StringUtils.repeat(\"=\", 36) + \" SCENARIO FINISHED WITH \" + status + StringUtils.repeat(\"=\", 35));\n        logger.info(StringUtils.repeat(\"#\", 110));\n        System.out.println();\n    }\n"]]}
{"hexsha": "76156c3a1f90a5e530d396fc7890f5ec7c408d99", "ext": "java", "lang": "Java", "content": "@UtilityClass\npublic class RakNetUtils {\n\n    public static void writeIntRanges(ByteBuf buffer, Queue<IntRange> ackQueue, int mtu) {\n        int lengthIndex = buffer.writerIndex();\n        buffer.writeZero(2);\n        mtu -= 2;\n\n        int count = 0;\n        IntRange ackRange;\n        while ((ackRange = ackQueue.poll()) != null) {\n\n            IntRange nextRange;\n            while ((nextRange = ackQueue.peek()) != null && (ackRange.end + 1) == nextRange.start) {\n                ackQueue.remove();\n                ackRange.end = nextRange.end;\n            }\n\n            if (ackRange.start == ackRange.end) {\n                if (mtu < 4) {\n                    break;\n                }\n                mtu -= 4;\n\n                buffer.writeBoolean(true);\n                buffer.writeMediumLE(ackRange.start);\n            } else {\n                if (mtu < 7) {\n                    break;\n                }\n                mtu -= 7;\n\n                buffer.writeBoolean(false);\n                buffer.writeMediumLE(ackRange.start);\n                buffer.writeMediumLE(ackRange.end);\n            }\n            count++;\n        }\n\n        int finalIndex = buffer.writerIndex();\n        buffer.writerIndex(lengthIndex);\n        buffer.writeShort(count);\n        buffer.writerIndex(finalIndex);\n    }\n\n    public static boolean verifyUnconnectedMagic(ByteBuf buffer) {\n        byte[] readMagic = new byte[RakNetConstants.RAKNET_UNCONNECTED_MAGIC.length];\n        buffer.readBytes(readMagic);\n\n        return Arrays.equals(readMagic, RakNetConstants.RAKNET_UNCONNECTED_MAGIC);\n    }\n\n    public static void writeUnconnectedMagic(ByteBuf buffer) {\n        buffer.writeBytes(RakNetConstants.RAKNET_UNCONNECTED_MAGIC);\n    }\n\n    public static int clamp(int value, int low, int high) {\n        return value < low ? low : value > high ? high : value;\n    }\n\n    public static int powerOfTwoCeiling(int value) {\n        value--;\n        value |= value >> 1;\n        value |= value >> 2;\n        value |= value >> 4;\n        value |= value >> 8;\n        value |= value >> 16;\n        value++;\n        return value;\n    }\n}", "class_id": 0, "repo": "good777LUCKY/Bedrock-Network", "file": "raknet/src/main/java/com/nukkitx/network/raknet/RakNetUtils.java", "last_update_at": "2020-12-26T07:17:48+00:00", "question_id": "76156c3a1f90a5e530d396fc7890f5ec7c408d99", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@UtilityClass\npublic class RakNetUtils {\n    public static void writeIntRanges(ByteBuf buffer, Queue<IntRange> ackQueue, int mtu) {\n        int lengthIndex = buffer.writerIndex();\n        buffer.writeZero(2);\n        mtu -= 2;\n        int count = 0;\n        IntRange ackRange;\n        while ((ackRange = ackQueue.poll()) != null) {\n            IntRange nextRange;\n            while ((nextRange = ackQueue.peek()) != null && (ackRange.end + 1) == nextRange.start) {\n                ackQueue.remove();\n                ackRange.end = nextRange.end;\n            }\n            if (ackRange.start == ackRange.end) {\n                if (mtu < 4) {\n                    break;\n                }\n                mtu -= 4;\n                buffer.writeBoolean(true);\n                buffer.writeMediumLE(ackRange.start);\n            } else {\n                if (mtu < 7) {\n                    break;\n                }\n                mtu -= 7;\n                buffer.writeBoolean(false);\n                buffer.writeMediumLE(ackRange.start);\n                buffer.writeMediumLE(ackRange.end);\n            }\n            count++;\n        }\n        int finalIndex = buffer.writerIndex();\n        buffer.writerIndex(lengthIndex);\n        buffer.writeShort(count);\n        buffer.writerIndex(finalIndex);\n    }\n    public static boolean verifyUnconnectedMagic(ByteBuf buffer) {\n        byte[] readMagic = new byte[RakNetConstants.RAKNET_UNCONNECTED_MAGIC.length];\n        buffer.readBytes(readMagic);\n        return Arrays.equals(readMagic, RakNetConstants.RAKNET_UNCONNECTED_MAGIC);\n    }\n    public static void writeUnconnectedMagic(ByteBuf buffer) {\n        buffer.writeBytes(RakNetConstants.RAKNET_UNCONNECTED_MAGIC);\n    }\n    public static int clamp(int value, int low, int high) {\n        return value < low ? low : value > high ? high : value;\n    }\n    public static int powerOfTwoCeiling(int value) {\n        value--;\n        value |= value >> 1;\n        value |= value >> 2;\n        value |= value >> 4;\n        value |= value >> 8;\n        value |= value >> 16;\n        value++;\n        return value;\n    }\n"]]}
{"hexsha": "11065489d735a4e66911f85a1b3c4a839664932b", "ext": "java", "lang": "Java", "content": "@RestController\n@RequestMapping(\"/api\")\npublic class RoleResource {\n\n    private final Logger log = LoggerFactory.getLogger(RoleResource.class);\n\n    private static final String ENTITY_NAME = \"role\";\n\n    @Value(\"${jhipster.clientApp.name}\")\n    private String applicationName;\n\n    private final RoleService roleService;\n\n    public RoleResource(RoleService roleService) {\n        this.roleService = roleService;\n    }\n\n    /**\n     * {@code POST  /roles} : Create a new role.\n     *\n     * @param role the role to create.\n     * @return the {@link ResponseEntity} with status {@code 201 (Created)} and with body the new role, or with status {@code 400 (Bad Request)} if the role has already an ID.\n     * @throws URISyntaxException if the Location URI syntax is incorrect.\n     */\n    @PostMapping(\"/roles\")\n    @PreAuthorize(\"hasAuthority('\" + ROLE_CREATE + \"')\")\n    public ResponseEntity<Role> createRole(@Valid @RequestBody Role role) throws URISyntaxException {\n        log.debug(\"REST request to save Role : {}\", role);\n        if (roleService.findOne(role.getName()).isPresent()) {\n            throw new BadRequestAlertException(\"This role already exists\", ENTITY_NAME, \"idexists\");\n        }\n        Role result = roleService.save(role);\n        return ResponseEntity.created(new URI(\"/api/roles/\" + result.getName()))\n            .headers(HeaderUtil.createEntityCreationAlert(applicationName, true, ENTITY_NAME, result.getName()))\n            .body(result);\n    }\n\n    /**\n     * {@code GET  /roles} : get all the roles.\n     *\n     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and the list of roles in body.\n     */\n    @GetMapping(\"/roles\")\n    @PreAuthorize(\"hasAuthority('\" + ROLE_READ + \"')\")\n    public List<Role> getAllRoles() {\n        log.debug(\"REST request to get all Roles\");\n        return roleService.findAll();\n    }\n\n    /**\n     * {@code GET  /roles/:id} : get the \"id\" role.\n     *\n     * @param id the id of the role to retrieve.\n     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the role, or with status {@code 404 (Not Found)}.\n     */\n    @GetMapping(\"/roles/{id}\")\n    @PreAuthorize(\"hasAuthority('\" + ROLE_READ + \"')\")\n    public ResponseEntity<Role> getRole(@PathVariable String id) {\n        log.debug(\"REST request to get Role : {}\", id);\n        Optional<Role> role = roleService.findOne(id);\n        return ResponseUtil.wrapOrNotFound(role);\n    }\n\n    /**\n     * {@code DELETE  /roles/:id} : delete the \"id\" role.\n     *\n     * @param id the id of the role to delete.\n     * @return the {@link ResponseEntity} with status {@code 204 (NO_CONTENT)}.\n     */\n    @DeleteMapping(\"/roles/{id}\")\n    @PreAuthorize(\"hasAuthority('\" + ROLE_DELETE + \"')\")\n    public ResponseEntity<Void> deleteRole(@PathVariable String id) {\n        log.debug(\"REST request to delete Role : {}\", id);\n        roleService.delete(id);\n        return ResponseEntity.noContent().headers(HeaderUtil.createEntityDeletionAlert(applicationName, true, ENTITY_NAME, id)).build();\n    }\n}", "class_id": 0, "repo": "boutainaLemrabet/generator-jhipster-preauthorize", "file": "test/samples/preauthorize/src/main/java/com/mycompany/myapp/web/rest/RoleResource.java", "last_update_at": "2020-11-29T01:46:04+00:00", "question_id": "11065489d735a4e66911f85a1b3c4a839664932b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RestController\n@RequestMapping(\"/api\")\npublic class RoleResource {\n    private final Logger log = LoggerFactory.getLogger(RoleResource.class);\n    private static final String ENTITY_NAME = \"role\";\n    @Value(\"${jhipster.clientApp.name}\")\n    private String applicationName;\n    private final RoleService roleService;\n    public RoleResource(RoleService roleService) {\n        this.roleService = roleService;\n    }\n    /**\n     * {@code POST  /roles} : Create a new role.\n     *\n     * @param role the role to create.\n     * @return the {@link ResponseEntity} with status {@code 201 (Created)} and with body the new role, or with status {@code 400 (Bad Request)} if the role has already an ID.\n     * @throws URISyntaxException if the Location URI syntax is incorrect.\n     */\n    @PostMapping(\"/roles\")\n    @PreAuthorize(\"hasAuthority('\" + ROLE_CREATE + \"')\")\n    public ResponseEntity<Role> createRole(@Valid @RequestBody Role role) throws URISyntaxException {\n        log.debug(\"REST request to save Role : {}\", role);\n        if (roleService.findOne(role.getName()).isPresent()) {\n            throw new BadRequestAlertException(\"This role already exists\", ENTITY_NAME, \"idexists\");\n        }\n        Role result = roleService.save(role);\n        return ResponseEntity.created(new URI(\"/api/roles/\" + result.getName()))\n            .headers(HeaderUtil.createEntityCreationAlert(applicationName, true, ENTITY_NAME, result.getName()))\n            .body(result);\n    }\n    /**\n     * {@code GET  /roles} : get all the roles.\n     *\n     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and the list of roles in body.\n     */\n    @GetMapping(\"/roles\")\n    @PreAuthorize(\"hasAuthority('\" + ROLE_READ + \"')\")\n    public List<Role> getAllRoles() {\n        log.debug(\"REST request to get all Roles\");\n        return roleService.findAll();\n    }\n    /**\n     * {@code GET  /roles/:id} : get the \"id\" role.\n     *\n     * @param id the id of the role to retrieve.\n     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the role, or with status {@code 404 (Not Found)}.\n     */\n    @GetMapping(\"/roles/{id}\")\n    @PreAuthorize(\"hasAuthority('\" + ROLE_READ + \"')\")\n    public ResponseEntity<Role> getRole(@PathVariable String id) {\n        log.debug(\"REST request to get Role : {}\", id);\n        Optional<Role> role = roleService.findOne(id);\n        return ResponseUtil.wrapOrNotFound(role);\n    }\n    /**\n     * {@code DELETE  /roles/:id} : delete the \"id\" role.\n     *\n     * @param id the id of the role to delete.\n     * @return the {@link ResponseEntity} with status {@code 204 (NO_CONTENT)}.\n     */\n    @DeleteMapping(\"/roles/{id}\")\n    @PreAuthorize(\"hasAuthority('\" + ROLE_DELETE + \"')\")\n    public ResponseEntity<Void> deleteRole(@PathVariable String id) {\n        log.debug(\"REST request to delete Role : {}\", id);\n        roleService.delete(id);\n        return ResponseEntity.noContent().headers(HeaderUtil.createEntityDeletionAlert(applicationName, true, ENTITY_NAME, id)).build();\n    }\n"]]}
{"hexsha": "cb0e904b99d298c162dfe34669afb68f3b850e19", "ext": "java", "lang": "Java", "content": "public class  OtherLock implements Runnable {\n\n\tint a = 100;\n\n\tsynchronized void mul() throws InterruptedException {\n\t\ta = 1000;\n\t\tThread.sleep(500);\n\t\tSystem.out.println(\"synchronized:\" + a);\n\t}\n\n\t void display() throws InterruptedException {\n\t\tThread.sleep(200);\n\t\ta = 200;\n\t\tSystem.out.println(\"display:\" + a);\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tmul();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tOtherLock otherLock = new OtherLock();\n\t\tThread thread = new Thread(otherLock);\n\t\tthread.start();\n\t\tSystem.out.println(\"firstmain:\" + otherLock.a);\n\t\tThread.sleep(100);\n\t\totherLock.display();\n\t\tthread.join();\n\t\tSystem.out.println(\"secondmain:\" + otherLock.a);\n\t}\n}", "class_id": 0, "repo": "muxiaobai/springboot-demo", "file": "test-java-demo/src/main/java/io/github/muxiaobai/java/java/threadTest/lock/OtherLock.java", "last_update_at": "2020-05-15T05:33:58+00:00", "question_id": "cb0e904b99d298c162dfe34669afb68f3b850e19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class  OtherLock implements Runnable {\n\tint a = 100;\n\tsynchronized void mul() throws InterruptedException {\n\t\ta = 1000;\n\t\tThread.sleep(500);\n\t\tSystem.out.println(\"synchronized:\" + a);\n\t}\n\t void display() throws InterruptedException {\n\t\tThread.sleep(200);\n\t\ta = 200;\n\t\tSystem.out.println(\"display:\" + a);\n\t}\n\tpublic void run() {\n\t\ttry {\n\t\t\tmul();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tOtherLock otherLock = new OtherLock();\n\t\tThread thread = new Thread(otherLock);\n\t\tthread.start();\n\t\tSystem.out.println(\"firstmain:\" + otherLock.a);\n\t\tThread.sleep(100);\n\t\totherLock.display();\n\t\tthread.join();\n\t\tSystem.out.println(\"secondmain:\" + otherLock.a);\n\t}\n"]]}
{"hexsha": "a57630901d1035d319d6315ea42f853a65889471", "ext": "java", "lang": "Java", "content": "public class LoanAccountDto implements DataTransferObject {\n\n    private final Integer accountId;\n    private final Integer customerId;\n    private final String prdOfferingShortName;\n    private final Short prdOfferingId;\n    private final Short accountState;\n    private final Short interestDeductedAtDisbursement;\n    private final Money loanAmount;\n    private Double amountPaidAtDisbursement;\n\n    private final List<CollectionSheetEntryInstallmentDto> accountTrxnDetails = new ArrayList<CollectionSheetEntryInstallmentDto>();\n\n    public LoanAccountDto(Integer accountId, Integer customerId, String prdOfferingShortName,\n            Short prdOfferingId, Short loanAccountState, Short interestDeductedAtDisbursement, Money loanAmount) {\n        if (loanAmount == null) {\n            throw new MifosRuntimeException(\"Null loanAmount is not allowed for LoanAccountDto\");\n        }\n        this.accountId = accountId;\n        this.customerId = customerId;\n        this.prdOfferingShortName = prdOfferingShortName;\n        this.prdOfferingId = prdOfferingId;\n        this.accountState = loanAccountState;\n        this.interestDeductedAtDisbursement = interestDeductedAtDisbursement;\n        this.loanAmount = loanAmount;\n    }\n\n    public Integer getAccountId() {\n        return accountId;\n    }\n\n    public Integer getCustomerId() {\n        return this.customerId;\n    }\n\n    public String getPrdOfferingShortName() {\n        return prdOfferingShortName;\n    }\n\n    public Short getPrdOfferingId() {\n        return prdOfferingId;\n    }\n\n    public Short getAccountSate() {\n        return accountState;\n    }\n\n    public List<CollectionSheetEntryInstallmentDto> getAccountTrxnDetails() {\n        return accountTrxnDetails;\n    }\n\n    public void addTrxnDetails(List<CollectionSheetEntryInstallmentDto> accountTrxnDetails) {\n        if (null != accountTrxnDetails && accountTrxnDetails.size() > 0) {\n            this.accountTrxnDetails.addAll(accountTrxnDetails);\n        }\n    }\n\n    public Double getTotalAmountDue() {\n        Money totalAmount = new Money(loanAmount.getCurrency());\n        if (isDisbursalAccount()) {\n            return amountPaidAtDisbursement;\n        }\n\n        if (accountTrxnDetails != null && accountTrxnDetails.size() > 0) {\n            for (CollectionSheetEntryInstallmentDto accountAction : accountTrxnDetails) {\n                totalAmount = totalAmount.add(((CollectionSheetEntryLoanInstallmentDto) accountAction)\n                        .getTotalDueWithFees());\n            }\n        }\n        return totalAmount.getAmountDoubleValue();\n    }\n\n    public boolean isInterestDeductedAtDisbursement() {\n        return this.interestDeductedAtDisbursement > 0 ? true : false;\n    }\n\n    public Double getAmountPaidAtDisbursement() {\n        return amountPaidAtDisbursement;\n    }\n\n    public void setAmountPaidAtDisbursement(Double amountPaidAtDisbursement) {\n        this.amountPaidAtDisbursement = amountPaidAtDisbursement;\n    }\n\n    public Double getTotalDisburseAmount() {\n        return isDisbursalAccount() ? this.loanAmount.getAmountDoubleValue() : 0.0;\n    }\n\n    public boolean isDisbursalAccount() {\n        return getAccountSate().equals(AccountState.LOAN_APPROVED.getValue())\n                || getAccountSate().equals(AccountState.LOAN_DISBURSED_TO_LOAN_OFFICER.getValue());\n    }\n}", "class_id": 0, "repo": "sureshkrishnamoorthy/suresh-mifos", "file": "appdomain/src/main/java/org/mifos/accounts/loan/util/helpers/LoanAccountDto.java", "last_update_at": "2020-12-21T18:39:55+00:00", "question_id": "a57630901d1035d319d6315ea42f853a65889471", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LoanAccountDto implements DataTransferObject {\n    private final Integer accountId;\n    private final Integer customerId;\n    private final String prdOfferingShortName;\n    private final Short prdOfferingId;\n    private final Short accountState;\n    private final Short interestDeductedAtDisbursement;\n    private final Money loanAmount;\n    private Double amountPaidAtDisbursement;\n    private final List<CollectionSheetEntryInstallmentDto> accountTrxnDetails = new ArrayList<CollectionSheetEntryInstallmentDto>();\n    public LoanAccountDto(Integer accountId, Integer customerId, String prdOfferingShortName,\n            Short prdOfferingId, Short loanAccountState, Short interestDeductedAtDisbursement, Money loanAmount) {\n        if (loanAmount == null) {\n            throw new MifosRuntimeException(\"Null loanAmount is not allowed for LoanAccountDto\");\n        }\n        this.accountId = accountId;\n        this.customerId = customerId;\n        this.prdOfferingShortName = prdOfferingShortName;\n        this.prdOfferingId = prdOfferingId;\n        this.accountState = loanAccountState;\n        this.interestDeductedAtDisbursement = interestDeductedAtDisbursement;\n        this.loanAmount = loanAmount;\n    }\n    public Integer getAccountId() {\n        return accountId;\n    }\n    public Integer getCustomerId() {\n        return this.customerId;\n    }\n    public String getPrdOfferingShortName() {\n        return prdOfferingShortName;\n    }\n    public Short getPrdOfferingId() {\n        return prdOfferingId;\n    }\n    public Short getAccountSate() {\n        return accountState;\n    }\n    public List<CollectionSheetEntryInstallmentDto> getAccountTrxnDetails() {\n        return accountTrxnDetails;\n    }\n    public void addTrxnDetails(List<CollectionSheetEntryInstallmentDto> accountTrxnDetails) {\n        if (null != accountTrxnDetails && accountTrxnDetails.size() > 0) {\n            this.accountTrxnDetails.addAll(accountTrxnDetails);\n        }\n    }\n    public Double getTotalAmountDue() {\n        Money totalAmount = new Money(loanAmount.getCurrency());\n        if (isDisbursalAccount()) {\n            return amountPaidAtDisbursement;\n        }\n        if (accountTrxnDetails != null && accountTrxnDetails.size() > 0) {\n            for (CollectionSheetEntryInstallmentDto accountAction : accountTrxnDetails) {\n                totalAmount = totalAmount.add(((CollectionSheetEntryLoanInstallmentDto) accountAction)\n                        .getTotalDueWithFees());\n            }\n        }\n        return totalAmount.getAmountDoubleValue();\n    }\n    public boolean isInterestDeductedAtDisbursement() {\n        return this.interestDeductedAtDisbursement > 0 ? true : false;\n    }\n    public Double getAmountPaidAtDisbursement() {\n        return amountPaidAtDisbursement;\n    }\n    public void setAmountPaidAtDisbursement(Double amountPaidAtDisbursement) {\n        this.amountPaidAtDisbursement = amountPaidAtDisbursement;\n    }\n    public Double getTotalDisburseAmount() {\n        return isDisbursalAccount() ? this.loanAmount.getAmountDoubleValue() : 0.0;\n    }\n    public boolean isDisbursalAccount() {\n        return getAccountSate().equals(AccountState.LOAN_APPROVED.getValue())\n                || getAccountSate().equals(AccountState.LOAN_DISBURSED_TO_LOAN_OFFICER.getValue());\n    }\n"]]}
{"hexsha": "c43bb3a25e364299bc97cb27f2d0061dd84356ae", "ext": "java", "lang": "Java", "content": "@MultipartConfig\n@WebServlet(name = \"UserProfileServlet\")\npublic class UserProfileServlet extends HttpServlet {\n\n    private UserDAO userDAO;\n\n    @Override\n    public void init() throws ServletException {\n        DAOFactory daoFactory = (DAOFactory) super.getServletContext().getAttribute(\"daoFactory\");\n        if (daoFactory == null) {\n            throw new ServletException(\"Impossible to get dao factory!\");\n        }\n        try {\n            userDAO = daoFactory.getDAO(UserDAO.class);\n        } catch (DAOFactoryException ex) {\n            throw new ServletException(\"Impossible to get user dao from dao factory!\", ex);\n        }\n    }\n\n    // <editor-fold defaultstate=\"collapsed\" desc=\"HttpServlet methods. Click on the + sign on the left to edit the code.\">\n\n    /**\n     * Handles the HTTP <code>GET</code> method.\n     *\n     * @param request  servlet request\n     * @param response servlet response\n     * @throws ServletException if a servlet-specific error occurs\n     * @throws IOException      if an I/O error occurs\n     */\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        if (!response.isCommitted())\n            request.getRequestDispatcher(\"/WEB-INF/views/user.jsp\").forward(request, response);\n    }\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession session = request.getSession(false);\n        User user = (User) session.getAttribute(\"user\");\n        if (user == null) {\n            response.sendError(500, \"There was an error processing the request\");\n            return;\n        }\n        String message = null;\n        boolean hasError = false;\n        boolean modified = false;\n        String avatarsFolder = getServletContext().getInitParameter(\"avatarsFolder\");\n        if (avatarsFolder == null) {\n            response.sendError(500, \"Avatars folder not configured\");\n            return;\n        }\n\n        String rootPath = System.getProperty(\"catalina.home\");\n        String firstName = request.getParameter(\"firstName\");\n        String lastName = request.getParameter(\"lastName\");\n\n\n        if (firstName == null || lastName == null || firstName.equals(\"\") || lastName.equals(\"\")) {\n            hasError = true;\n            message = \"All fields are mandatory and must be filled!\";\n        } else {\n            Part filePart = request.getPart(\"avatar\");\n            if ((filePart != null) && (filePart.getSize() > 0)) {\n                String fileName = UtilityHelper.getFilename(filePart);\n                fileName = UtilityHelper.renameImage(fileName, \"Profile_\" + user.getId());\n                String userAvatarUploadDir = rootPath + File.separator + avatarsFolder + \"Users\";\n                try {\n                    user.setAvatar(UtilityHelper.uploadFileToDirectory(userAvatarUploadDir, fileName, filePart));\n                } catch (IOException ex) {\n                    response.sendError(500, ex.getMessage());\n                }\n                modified = true;\n            }\n\n            if (!firstName.equals(user.getFirstName())) {\n                modified = true;\n                user.setFirstName(firstName);\n            }\n            if (!lastName.equals(user.getLastName())) {\n                modified = true;\n                user.setLastName(lastName);\n            }\n        }\n\n        if (hasError) {\n            request.setAttribute(\"errorMessage\", \"errors\");\n            getServletContext().getRequestDispatcher(\"/WEB-INF/views/home.jsp\").forward(request, response);\n        } else {\n            try {\n                if (modified) {\n                    user = userDAO.update(user);\n                    message = \"Profile was successfully updated\";\n                    session.setAttribute(\"successMessage\", message);\n                }\n                response.sendRedirect(response.encodeRedirectURL(getServletContext().getContextPath() + \"/user/profile\"));\n            } catch (DAOException ex) {\n                response.sendError(500, ex.toString());\n            }\n        }\n    }\n\n}", "class_id": 0, "repo": "ImGere/programmazioneweb18", "file": "Progetto/ShoppingLesto/src/main/java/it/unitn/shoppinglesto/servlet/UserProfileServlet.java", "last_update_at": "2020-12-04T17:11:24+00:00", "question_id": "c43bb3a25e364299bc97cb27f2d0061dd84356ae", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@MultipartConfig\n@WebServlet(name = \"UserProfileServlet\")\npublic class UserProfileServlet extends HttpServlet {\n    private UserDAO userDAO;\n    @Override\n    public void init() throws ServletException {\n        DAOFactory daoFactory = (DAOFactory) super.getServletContext().getAttribute(\"daoFactory\");\n        if (daoFactory == null) {\n            throw new ServletException(\"Impossible to get dao factory!\");\n        }\n        try {\n            userDAO = daoFactory.getDAO(UserDAO.class);\n        } catch (DAOFactoryException ex) {\n            throw new ServletException(\"Impossible to get user dao from dao factory!\", ex);\n        }\n    }\n    // <editor-fold defaultstate=\"collapsed\" desc=\"HttpServlet methods. Click on the + sign on the left to edit the code.\">\n    /**\n     * Handles the HTTP <code>GET</code> method.\n     *\n     * @param request  servlet request\n     * @param response servlet response\n     * @throws ServletException if a servlet-specific error occurs\n     * @throws IOException      if an I/O error occurs\n     */\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        if (!response.isCommitted())\n            request.getRequestDispatcher(\"/WEB-INF/views/user.jsp\").forward(request, response);\n    }\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession session = request.getSession(false);\n        User user = (User) session.getAttribute(\"user\");\n        if (user == null) {\n            response.sendError(500, \"There was an error processing the request\");\n            return;\n        }\n        String message = null;\n        boolean hasError = false;\n        boolean modified = false;\n        String avatarsFolder = getServletContext().getInitParameter(\"avatarsFolder\");\n        if (avatarsFolder == null) {\n            response.sendError(500, \"Avatars folder not configured\");\n            return;\n        }\n        String rootPath = System.getProperty(\"catalina.home\");\n        String firstName = request.getParameter(\"firstName\");\n        String lastName = request.getParameter(\"lastName\");\n        if (firstName == null || lastName == null || firstName.equals(\"\") || lastName.equals(\"\")) {\n            hasError = true;\n            message = \"All fields are mandatory and must be filled!\";\n        } else {\n            Part filePart = request.getPart(\"avatar\");\n            if ((filePart != null) && (filePart.getSize() > 0)) {\n                String fileName = UtilityHelper.getFilename(filePart);\n                fileName = UtilityHelper.renameImage(fileName, \"Profile_\" + user.getId());\n                String userAvatarUploadDir = rootPath + File.separator + avatarsFolder + \"Users\";\n                try {\n                    user.setAvatar(UtilityHelper.uploadFileToDirectory(userAvatarUploadDir, fileName, filePart));\n                } catch (IOException ex) {\n                    response.sendError(500, ex.getMessage());\n                }\n                modified = true;\n            }\n            if (!firstName.equals(user.getFirstName())) {\n                modified = true;\n                user.setFirstName(firstName);\n            }\n            if (!lastName.equals(user.getLastName())) {\n                modified = true;\n                user.setLastName(lastName);\n            }\n        }\n        if (hasError) {\n            request.setAttribute(\"errorMessage\", \"errors\");\n            getServletContext().getRequestDispatcher(\"/WEB-INF/views/home.jsp\").forward(request, response);\n        } else {\n            try {\n                if (modified) {\n                    user = userDAO.update(user);\n                    message = \"Profile was successfully updated\";\n                    session.setAttribute(\"successMessage\", message);\n                }\n                response.sendRedirect(response.encodeRedirectURL(getServletContext().getContextPath() + \"/user/profile\"));\n            } catch (DAOException ex) {\n                response.sendError(500, ex.toString());\n            }\n        }\n    }\n"]]}
{"hexsha": "3f22a92eb951ac54b1096a40b24bdfe73c5f1fc3", "ext": "java", "lang": "Java", "content": "public class SidePanel extends UiPart<Region> {\n    private static final String FXML = \"SidePanel.fxml\";\n    private static final int MODULE_ROW_HEIGHT = 32;\n    private final Logger logger = LogsCenter.getLogger(SidePanel.class);\n    private final Consumer<ArrayList<Object>> tabConsumer;\n    private final Logic logic;\n    private Button selectedTabButton;\n\n    @FXML\n    private Button upcomingButton;\n\n    @FXML\n    private Button contactButton;\n\n    @FXML\n    private ListView<Module> moduleListView;\n\n    @FXML\n    private Button helpButton;\n\n\n    /**\n     * Constructor for SidePanel\n     *\n     * @param tabConsumer carries values to MainWindow\n     */\n    public SidePanel(Consumer<ArrayList<Object>> tabConsumer, Logic logic) {\n        super(FXML);\n        this.tabConsumer = tabConsumer;\n        this.logic = logic;\n        initialize();\n    }\n\n    /**\n     * Initialises/reloads the tab buttons in the side panel.\n     */\n    public void initialize() {\n        if (logic != null) {\n            // Get modules tab buttons.\n            ObservableList<Module> modules = logic.getFilteredModuleList();\n            moduleListView.setPrefHeight(modules.size() * MODULE_ROW_HEIGHT);\n            moduleListView.setItems(modules);\n            moduleListView.setCellFactory(listView -> new ModuleListViewCell());\n\n            // Set Default tab as upcoming tab.\n            selectedTabButton = upcomingButton;\n            updateButtonDetails(upcomingButton);\n        }\n    }\n\n    /**\n     * Relays message to MainWindow to get Upcoming panel information in TabPanel.\n     */\n    public void toggleUpcomingTab() {\n        ArrayList<Object> upcomingValues = new ArrayList<>(Arrays.asList((Object) UpcomingPanel.TYPE));\n        updateButtonDetails(upcomingButton);\n        tabConsumer.accept(upcomingValues);\n    }\n\n    /**\n     * Relays message to MainWindow to get Contact panel information in TabPanel.\n     */\n    public void toggleContactTab() {\n        ArrayList<Object> contactValues = new ArrayList<>(Arrays.asList((Object) Contact.TYPE));\n        updateButtonDetails(contactButton);\n        tabConsumer.accept(contactValues);\n    }\n\n    /**\n     * Relays message to MainWindow to get Help tab information in TabPanel.\n     */\n    public void toggleHelpTab() {\n        ArrayList<Object> helpValues = new ArrayList<>(Arrays.asList((Object) HelpPanel.TYPE));\n        updateButtonDetails(helpButton);\n        tabConsumer.accept(helpValues);\n    }\n\n    /**\n     * Colors the help button when help command is entered\n     */\n    public void updateHelpButton() {\n        updateButtonDetails(helpButton);\n    }\n\n    /**\n     * Updates the details of the current selected tab button.\n     *\n     * @param button The new selected tab button.\n     */\n    public void updateButtonDetails(Button button) {\n        selectedTabButton.setStyle(\"-fx-text-fill: white;\");\n        selectedTabButton = button;\n        selectedTabButton.setStyle(\"-fx-text-fill: #68C2E8;\");\n    }\n\n    /**\n     * Configure the module section that will include the module button as well as a coloured module circle label.\n     *\n     * @return HBox The module section.\n     */\n    public HBox getModuleSection() {\n        HBox moduleSection = new HBox();\n        moduleSection.setAlignment(Pos.CENTER_LEFT);\n        moduleSection.setPadding(new Insets(0, 0, 0, 10));\n        return moduleSection;\n    }\n\n    /**\n     * Configure the module button tab in the side panel.\n     *\n     * @return moduleButton The module button.\n     */\n    public Button getModuleButton(Module module) {\n        Button button = new Button(module.getCode().code);\n        ArrayList<Object> moduleValues = new ArrayList<>(Arrays.asList(Module.TYPE, module));\n        button.setOnAction(actionEvent -> {\n            updateButtonDetails(button);\n            tabConsumer.accept(moduleValues);\n        });\n        button.setPadding(new Insets(5));\n        return button;\n    }\n\n    /**\n     * Configure the coloured module circle that is displayed beside the module code.\n     *\n     * @return moduleCircle The module circle.\n     */\n    public Circle getModuleCircle(Module module, Logic logic) throws CommandException {\n        Circle moduleCircle = new Circle(0, 0, 6);\n        int moduleIndex = logic.getModuleIndex(module).getZeroBased();\n        moduleCircle.setFill(Module.COLORS.get(moduleIndex % 10));\n        return moduleCircle;\n    }\n\n    /**\n     * Sets the view of the module tab in the side panel.\n     */\n    class ModuleListViewCell extends ListCell<Module> {\n        @Override\n        protected void updateItem(Module module, boolean empty) {\n            super.updateItem(module, empty);\n\n            if (empty || module == null) {\n                setGraphic(null);\n                setText(null);\n            } else {\n                try {\n                    HBox moduleSection = getModuleSection();\n                    Button updatedButton = getModuleButton(module);\n                    Circle moduleCircle = getModuleCircle(module, logic);\n                    moduleSection.getChildren().add(moduleCircle);\n                    moduleSection.getChildren().add(updatedButton);\n                    setGraphic(moduleSection);\n\n                } catch (CommandException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}", "class_id": 0, "repo": "nottiffchan/tp", "file": "src/main/java/trackitnus/ui/SidePanel.java", "last_update_at": "2020-10-12T14:59:15+00:00", "question_id": "3f22a92eb951ac54b1096a40b24bdfe73c5f1fc3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SidePanel extends UiPart<Region> {\n    private static final String FXML = \"SidePanel.fxml\";\n    private static final int MODULE_ROW_HEIGHT = 32;\n    private final Logger logger = LogsCenter.getLogger(SidePanel.class);\n    private final Consumer<ArrayList<Object>> tabConsumer;\n    private final Logic logic;\n    private Button selectedTabButton;\n    @FXML\n    private Button upcomingButton;\n    @FXML\n    private Button contactButton;\n    @FXML\n    private ListView<Module> moduleListView;\n    @FXML\n    private Button helpButton;\n    /**\n     * Constructor for SidePanel\n     *\n     * @param tabConsumer carries values to MainWindow\n     */\n    public SidePanel(Consumer<ArrayList<Object>> tabConsumer, Logic logic) {\n        super(FXML);\n        this.tabConsumer = tabConsumer;\n        this.logic = logic;\n        initialize();\n    }\n    /**\n     * Initialises/reloads the tab buttons in the side panel.\n     */\n    public void initialize() {\n        if (logic != null) {\n            // Get modules tab buttons.\n            ObservableList<Module> modules = logic.getFilteredModuleList();\n            moduleListView.setPrefHeight(modules.size() * MODULE_ROW_HEIGHT);\n            moduleListView.setItems(modules);\n            moduleListView.setCellFactory(listView -> new ModuleListViewCell());\n            // Set Default tab as upcoming tab.\n            selectedTabButton = upcomingButton;\n            updateButtonDetails(upcomingButton);\n        }\n    }\n    /**\n     * Relays message to MainWindow to get Upcoming panel information in TabPanel.\n     */\n    public void toggleUpcomingTab() {\n        ArrayList<Object> upcomingValues = new ArrayList<>(Arrays.asList((Object) UpcomingPanel.TYPE));\n        updateButtonDetails(upcomingButton);\n        tabConsumer.accept(upcomingValues);\n    }\n    /**\n     * Relays message to MainWindow to get Contact panel information in TabPanel.\n     */\n    public void toggleContactTab() {\n        ArrayList<Object> contactValues = new ArrayList<>(Arrays.asList((Object) Contact.TYPE));\n        updateButtonDetails(contactButton);\n        tabConsumer.accept(contactValues);\n    }\n    /**\n     * Relays message to MainWindow to get Help tab information in TabPanel.\n     */\n    public void toggleHelpTab() {\n        ArrayList<Object> helpValues = new ArrayList<>(Arrays.asList((Object) HelpPanel.TYPE));\n        updateButtonDetails(helpButton);\n        tabConsumer.accept(helpValues);\n    }\n    /**\n     * Colors the help button when help command is entered\n     */\n    public void updateHelpButton() {\n        updateButtonDetails(helpButton);\n    }\n    /**\n     * Updates the details of the current selected tab button.\n     *\n     * @param button The new selected tab button.\n     */\n    public void updateButtonDetails(Button button) {\n        selectedTabButton.setStyle(\"-fx-text-fill: white;\");\n        selectedTabButton = button;\n        selectedTabButton.setStyle(\"-fx-text-fill: #68C2E8;\");\n    }\n    /**\n     * Configure the module section that will include the module button as well as a coloured module circle label.\n     *\n     * @return HBox The module section.\n     */\n    public HBox getModuleSection() {\n        HBox moduleSection = new HBox();\n        moduleSection.setAlignment(Pos.CENTER_LEFT);\n        moduleSection.setPadding(new Insets(0, 0, 0, 10));\n        return moduleSection;\n    }\n    /**\n     * Configure the module button tab in the side panel.\n     *\n     * @return moduleButton The module button.\n     */\n    public Button getModuleButton(Module module) {\n        Button button = new Button(module.getCode().code);\n        ArrayList<Object> moduleValues = new ArrayList<>(Arrays.asList(Module.TYPE, module));\n        button.setOnAction(actionEvent -> {\n            updateButtonDetails(button);\n            tabConsumer.accept(moduleValues);\n        });\n        button.setPadding(new Insets(5));\n        return button;\n    }\n    /**\n     * Configure the coloured module circle that is displayed beside the module code.\n     *\n     * @return moduleCircle The module circle.\n     */\n    public Circle getModuleCircle(Module module, Logic logic) throws CommandException {\n        Circle moduleCircle = new Circle(0, 0, 6);\n        int moduleIndex = logic.getModuleIndex(module).getZeroBased();\n        moduleCircle.setFill(Module.COLORS.get(moduleIndex % 10));\n        return moduleCircle;\n    }\n    /**\n     * Sets the view of the module tab in the side panel.\n     */\n    class ModuleListViewCell extends ListCell<Module> {\n        @Override\n        protected void updateItem(Module module, boolean empty) {\n            super.updateItem(module, empty);\n            if (empty || module == null) {\n                setGraphic(null);\n                setText(null);\n            } else {\n                try {\n                    HBox moduleSection = getModuleSection();\n                    Button updatedButton = getModuleButton(module);\n                    Circle moduleCircle = getModuleCircle(module, logic);\n                    moduleSection.getChildren().add(moduleCircle);\n                    moduleSection.getChildren().add(updatedButton);\n                    setGraphic(moduleSection);\n                } catch (CommandException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n"]]}
{"hexsha": "d42d3725c32c349c43c720d444ab377d375b7863", "ext": "java", "lang": "Java", "content": "@SpringBootTest\nclass GulimallThirdPartyApplicationTests {\n\n    @Autowired\n    OSSClient ossClient;\n\n    @Autowired\n    SMSComponent smsComponent;\n\n    @Test\n    void testSendSms() {\n        smsComponent.sendSMSCode(\"18931007018\", \"123456\");\n    }\n\n    @Test\n    void testOSSUpdate() throws FileNotFoundException {\n        InputStream inputStream = new FileInputStream(\"/Users/zhengyuli/Desktop/avatar.png\");\n        ossClient.putObject(\"zli78122-gulimall\", \"avatar.png\", inputStream);\n        ossClient.shutdown();\n    }\n}", "class_id": 0, "repo": "zli78122/gulimall", "file": "gulimall-third-party/src/test/java/com/atguigu/gulimall/thirdparty/GulimallThirdPartyApplicationTests.java", "last_update_at": "2020-12-26T09:16:19+00:00", "question_id": "d42d3725c32c349c43c720d444ab377d375b7863", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SpringBootTest\nclass GulimallThirdPartyApplicationTests {\n    @Autowired\n    OSSClient ossClient;\n    @Autowired\n    SMSComponent smsComponent;\n    @Test\n    void testSendSms() {\n        smsComponent.sendSMSCode(\"18931007018\", \"123456\");\n    }\n    @Test\n    void testOSSUpdate() throws FileNotFoundException {\n        InputStream inputStream = new FileInputStream(\"/Users/zhengyuli/Desktop/avatar.png\");\n        ossClient.putObject(\"zli78122-gulimall\", \"avatar.png\", inputStream);\n        ossClient.shutdown();\n    }\n"]]}
{"hexsha": "65a90a74dc2873fd6ce97f9e755aa2eaee8aa4cb", "ext": "java", "lang": "Java", "content": "@Command(name = \"Simple kubectl plugin\", mixinStandardHelpOptions = true, version = \"1\",\n    description = \"Gets Pods names and other stuff\")\nclass PluginTest implements Callable<Integer> {\n\n  @CommandLine.Option(names = { \"-n\", \"--namespace\" }, description = \"The @|bold namespace|@\",\n      paramLabel = \"NAMESPACE\")\n  String namespace = null;\n\n  @Parameters(index = \"0\", description = \"Regex pattern\", paramLabel = \"NAMEPATTERN\",\n      arity = \"0..1\")\n  Pattern namePattern = null;\n\n  public static void main(String... args) {\n    System.setProperty(\"org.slf4j.simpleLogger.logFile\", \"System.out\");\n    int exitCode = new CommandLine(new PluginTest()).execute(args);\n    System.exit(exitCode);\n  }\n\n  private void printlnAnsi(String msg) {\n    System.out.println(CommandLine.Help.Ansi.AUTO.string(msg));\n  }\n\n  @Override\n  public Integer call() {\n    try {\n      ApiClient client = Config.defaultClient();\n      Configuration.setDefaultApiClient(client);\n\n      CoreV1Api api = new CoreV1Api();\n      V1PodList list = namespace == null\n          ? api.listPodForAllNamespaces(null, null, null, null, null, null, null, null, null)\n          : api.listNamespacedPod(namespace, null, null, null, null, null, null, null, null, null);\n      list.getItems()\n          .stream()\n          .filter(namePattern != null\n            ? pod -> namePattern.asMatchPredicate().test(pod.getMetadata().getName())\n            : pod -> true)\n          .forEach(pod -> printlnAnsi(\"@|green Name:|@ \"\n            + pod.getMetadata().getName()\n            + \"\\t@|green SelfLink:|@ \"\n            + pod.getMetadata().getSelfLink()));\n      return 0;\n    } catch (Exception ex) {\n      ex.printStackTrace();\n      return 1;\n    }\n  }\n}", "class_id": 0, "repo": "quintesse/kubectl-java-test", "file": "kubectl-java_test.java", "last_update_at": "2020-11-20T15:48:49+00:00", "question_id": "65a90a74dc2873fd6ce97f9e755aa2eaee8aa4cb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Command(name = \"Simple kubectl plugin\", mixinStandardHelpOptions = true, version = \"1\",\n    description = \"Gets Pods names and other stuff\")\nclass PluginTest implements Callable<Integer> {\n  @CommandLine.Option(names = { \"-n\", \"--namespace\" }, description = \"The @|bold namespace|@\",\n      paramLabel = \"NAMESPACE\")\n  String namespace = null;\n  @Parameters(index = \"0\", description = \"Regex pattern\", paramLabel = \"NAMEPATTERN\",\n      arity = \"0..1\")\n  Pattern namePattern = null;\n  public static void main(String... args) {\n    System.setProperty(\"org.slf4j.simpleLogger.logFile\", \"System.out\");\n    int exitCode = new CommandLine(new PluginTest()).execute(args);\n    System.exit(exitCode);\n  }\n  private void printlnAnsi(String msg) {\n    System.out.println(CommandLine.Help.Ansi.AUTO.string(msg));\n  }\n  @Override\n  public Integer call() {\n    try {\n      ApiClient client = Config.defaultClient();\n      Configuration.setDefaultApiClient(client);\n      CoreV1Api api = new CoreV1Api();\n      V1PodList list = namespace == null\n          ? api.listPodForAllNamespaces(null, null, null, null, null, null, null, null, null)\n          : api.listNamespacedPod(namespace, null, null, null, null, null, null, null, null, null);\n      list.getItems()\n          .stream()\n          .filter(namePattern != null\n            ? pod -> namePattern.asMatchPredicate().test(pod.getMetadata().getName())\n            : pod -> true)\n          .forEach(pod -> printlnAnsi(\"@|green Name:|@ \"\n            + pod.getMetadata().getName()\n            + \"\\t@|green SelfLink:|@ \"\n            + pod.getMetadata().getSelfLink()));\n      return 0;\n    } catch (Exception ex) {\n      ex.printStackTrace();\n      return 1;\n    }\n  }\n"]]}
{"hexsha": "e45eacab543132c7d40e95586c6e44a5339e0793", "ext": "java", "lang": "Java", "content": "public class P1500 implements PA {\n\n  private FastScanner scanner;\n\n  @Override\n  public void reset() {\n    scanner = new FastScanner(System.in);\n  }\n\n  @Override\n  public void trivialSolution() {\n    reset();\n    int testCaseCount = scanner.nextInt();\n    while (testCaseCount-- > 0) {\n      trivialProcessTestCase(scanner.nextInt(), scanner.nextInt());\n    }\n  }\n  \n  private void trivialProcessTestCase(int numberCount, int commandCount) {\n    long[] numbers = new long[numberCount + 1];\n    int p;\n    int q;\n    int v;\n    while (commandCount-- > 0) {\n      if (scanner.nextInt() == 0) {\n        p = scanner.nextInt();\n        q = scanner.nextInt();\n        v = scanner.nextInt();\n        for (int i = p; i <= q; i++) {\n          numbers[i] += v;\n        }\n      } else {\n        p = scanner.nextInt();\n        q = scanner.nextInt();\n        long sum = 0;\n        for (int i = p; i <= q; i++) {\n          sum += numbers[i];\n        }\n        System.out.println(sum);\n      }\n    }\n  }\n\n  @Override\n  public void finalSolution() {\n    reset();\n    int testCaseCount = scanner.nextInt();\n    while (testCaseCount-- > 0) {\n      finalProcessTestCase(scanner.nextInt(), scanner.nextInt());\n    }\n  }\n\n  private void finalProcessTestCase(int numberCount, int commandCount) {\n    SegmentTree segmentTree = new SegmentTree(numberCount);\n    while (commandCount-- > 0) {\n      if (scanner.nextInt() == 0) {\n        segmentTree.update(scanner.nextInt() - 1, scanner.nextInt() - 1, scanner.nextInt());\n      } else {\n        System.out.println(segmentTree.sum(scanner.nextInt() - 1, scanner.nextInt() - 1));\n      }\n    }\n  }\n\n  private static class SegmentTree {\n\n    final int numberCount;\n\n    final int treeSize;\n\n    final int firstLeaf;\n\n    final long[] tree;\n\n    long[] lazy;\n\n    SegmentTree(int numberCount) {\n      this.numberCount = numberCount;\n      this.treeSize = computeMaxTreeSize(numberCount);\n      this.firstLeaf = treeSize / 2;\n      this.tree = new long[this.treeSize];\n      this.lazy = new long[this.treeSize];\n    }\n\n    int computeMaxTreeSize(int n) {\n      int leafCount = 1;\n      while (n > leafCount) {\n        leafCount <<= 1;\n      }\n      return (2 * leafCount) - 1;\n    }\n\n    void update(int from, int to, int value) {\n      Stack<Node> nodes = new Stack<>();\n      nodes.push(new Node(0, 0, numberCount - 1));\n      while (!nodes.isEmpty()) {\n        Node node = nodes.pop();\n\n        // Handle current node pending update\n        long pendingUpdate = lazy[node.index];\n        if (pendingUpdate > 0) {\n          tree[node.index] += (node.to - node.from + 1) * pendingUpdate;\n          lazy[node.index] = 0;\n          if (node.index < firstLeaf) {\n            lazy[left(node.index)] += pendingUpdate;\n            lazy[right(node.index)] += pendingUpdate;\n          }\n        }\n\n        // Ignore node if out of range\n        if (node.to < from || node.from > to) {\n          continue;\n        }\n\n        if (node.from >= from && node.to <= to) {\n          // Handle current node update if it lies completely in update range\n          tree[node.index] += ((long) (node.to - node.from + 1) * value);\n          if (node.index < firstLeaf) {\n            lazy[left(node.index)] += value;\n            lazy[right(node.index)] += value;\n          }\n        } else {\n          // Handle current node update if it overlaps with update range\n          tree[node.index] += (long) (Math.min(node.to, to) - Math.max(node.from, from) + 1) * value;\n          nodes.push(right(node));\n          nodes.push(left(node));\n        }\n      }\n    }\n\n    long sum(int from, int to) {\n      long sum = 0;\n      Stack<Node> nodes = new Stack<>();\n      nodes.push(new Node(0, 0, numberCount - 1));\n      while (!nodes.isEmpty()) {\n        Node node = nodes.pop();\n\n        // Handle current node pending update\n        long pendingUpdate = lazy[node.index];\n        if (pendingUpdate > 0) {\n          tree[node.index] += (node.to - node.from + 1) * pendingUpdate;\n          lazy[node.index] = 0;\n\n          // Postpone children updates\n          if (node.index < firstLeaf) {\n            lazy[left(node.index)] += pendingUpdate;\n            lazy[right(node.index)] += pendingUpdate;\n          }\n        }\n\n        // Ignore node if out of range\n        if (node.to < from || node.from > to) {\n          continue;\n        }\n\n        if (node.from >= from && node.to <= to) {\n          sum += tree[node.index];\n        } else if (node.to >= from || node.from <= to) {\n          nodes.push(right(node));\n          nodes.push(left(node));\n        }\n      }\n      return sum;\n    }\n\n    int middle(int from, int to) {\n      return from + (to - from) / 2;\n    }\n\n    int left(int i) {\n      return (i << 1) + 1;\n    }\n\n    int right(int i) {\n      return (i << 1) + 2;\n    }\n\n    Node left(Node node) {\n      int left = left(node.index);\n      if (left >= treeSize) {\n        return null;\n      }\n      return new Node(left(node.index), node.from, middle(node.from, node.to));\n    }\n\n    Node right(Node node) {\n      int right = right(node.index);\n      if (right >= treeSize) {\n        return null;\n      }\n      return new Node(right(node.index), middle(node.from, node.to) + 1, node.to);\n    }\n  }\n\n  private static class Node {\n\n    final int index;\n\n    final int from;\n\n    final int to;\n\n    Node(int index, int from, int to) {\n      this.index = index;\n      this.from = from;\n      this.to = to;\n    }\n\n    @Override\n    public String toString() {\n      return \"Node{\" + \"index=\" + index + \", from=\" + from + \", to=\" + to + '}';\n    }\n  }\n}", "class_id": 0, "repo": "guidesanti/EDX-AlgorithmsAndDataStructures-UCSanDiego", "file": "URI/src/main/java/br/com/eventhorizon/uri/datastructures/P1500.java", "last_update_at": "2020-12-23T15:19:33+00:00", "question_id": "e45eacab543132c7d40e95586c6e44a5339e0793", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class P1500 implements PA {\n  private FastScanner scanner;\n  @Override\n  public void reset() {\n    scanner = new FastScanner(System.in);\n  }\n  @Override\n  public void trivialSolution() {\n    reset();\n    int testCaseCount = scanner.nextInt();\n    while (testCaseCount-- > 0) {\n      trivialProcessTestCase(scanner.nextInt(), scanner.nextInt());\n    }\n  }\n  private void trivialProcessTestCase(int numberCount, int commandCount) {\n    long[] numbers = new long[numberCount + 1];\n    int p;\n    int q;\n    int v;\n    while (commandCount-- > 0) {\n      if (scanner.nextInt() == 0) {\n        p = scanner.nextInt();\n        q = scanner.nextInt();\n        v = scanner.nextInt();\n        for (int i = p; i <= q; i++) {\n          numbers[i] += v;\n        }\n      } else {\n        p = scanner.nextInt();\n        q = scanner.nextInt();\n        long sum = 0;\n        for (int i = p; i <= q; i++) {\n          sum += numbers[i];\n        }\n        System.out.println(sum);\n      }\n    }\n  }\n  @Override\n  public void finalSolution() {\n    reset();\n    int testCaseCount = scanner.nextInt();\n    while (testCaseCount-- > 0) {\n      finalProcessTestCase(scanner.nextInt(), scanner.nextInt());\n    }\n  }\n  private void finalProcessTestCase(int numberCount, int commandCount) {\n    SegmentTree segmentTree = new SegmentTree(numberCount);\n    while (commandCount-- > 0) {\n      if (scanner.nextInt() == 0) {\n        segmentTree.update(scanner.nextInt() - 1, scanner.nextInt() - 1, scanner.nextInt());\n      } else {\n        System.out.println(segmentTree.sum(scanner.nextInt() - 1, scanner.nextInt() - 1));\n      }\n    }\n  }\n  private static class SegmentTree {\n    final int numberCount;\n    final int treeSize;\n    final int firstLeaf;\n    final long[] tree;\n    long[] lazy;\n    SegmentTree(int numberCount) {\n      this.numberCount = numberCount;\n      this.treeSize = computeMaxTreeSize(numberCount);\n      this.firstLeaf = treeSize / 2;\n      this.tree = new long[this.treeSize];\n      this.lazy = new long[this.treeSize];\n    }\n    int computeMaxTreeSize(int n) {\n      int leafCount = 1;\n      while (n > leafCount) {\n        leafCount <<= 1;\n      }\n      return (2 * leafCount) - 1;\n    }\n    void update(int from, int to, int value) {\n      Stack<Node> nodes = new Stack<>();\n      nodes.push(new Node(0, 0, numberCount - 1));\n      while (!nodes.isEmpty()) {\n        Node node = nodes.pop();\n        // Handle current node pending update\n        long pendingUpdate = lazy[node.index];\n        if (pendingUpdate > 0) {\n          tree[node.index] += (node.to - node.from + 1) * pendingUpdate;\n          lazy[node.index] = 0;\n          if (node.index < firstLeaf) {\n            lazy[left(node.index)] += pendingUpdate;\n            lazy[right(node.index)] += pendingUpdate;\n          }\n        }\n        // Ignore node if out of range\n        if (node.to < from || node.from > to) {\n          continue;\n        }\n        if (node.from >= from && node.to <= to) {\n          // Handle current node update if it lies completely in update range\n          tree[node.index] += ((long) (node.to - node.from + 1) * value);\n          if (node.index < firstLeaf) {\n            lazy[left(node.index)] += value;\n            lazy[right(node.index)] += value;\n          }\n        } else {\n          // Handle current node update if it overlaps with update range\n          tree[node.index] += (long) (Math.min(node.to, to) - Math.max(node.from, from) + 1) * value;\n          nodes.push(right(node));\n          nodes.push(left(node));\n        }\n      }\n    }\n    long sum(int from, int to) {\n      long sum = 0;\n      Stack<Node> nodes = new Stack<>();\n      nodes.push(new Node(0, 0, numberCount - 1));\n      while (!nodes.isEmpty()) {\n        Node node = nodes.pop();\n        // Handle current node pending update\n        long pendingUpdate = lazy[node.index];\n        if (pendingUpdate > 0) {\n          tree[node.index] += (node.to - node.from + 1) * pendingUpdate;\n          lazy[node.index] = 0;\n          // Postpone children updates\n          if (node.index < firstLeaf) {\n            lazy[left(node.index)] += pendingUpdate;\n            lazy[right(node.index)] += pendingUpdate;\n          }\n        }\n        // Ignore node if out of range\n        if (node.to < from || node.from > to) {\n          continue;\n        }\n        if (node.from >= from && node.to <= to) {\n          sum += tree[node.index];\n        } else if (node.to >= from || node.from <= to) {\n          nodes.push(right(node));\n          nodes.push(left(node));\n        }\n      }\n      return sum;\n    }\n    int middle(int from, int to) {\n      return from + (to - from) / 2;\n    }\n    int left(int i) {\n      return (i << 1) + 1;\n    }\n    int right(int i) {\n      return (i << 1) + 2;\n    }\n    Node left(Node node) {\n      int left = left(node.index);\n      if (left >= treeSize) {\n        return null;\n      }\n      return new Node(left(node.index), node.from, middle(node.from, node.to));\n    }\n    Node right(Node node) {\n      int right = right(node.index);\n      if (right >= treeSize) {\n        return null;\n      }\n      return new Node(right(node.index), middle(node.from, node.to) + 1, node.to);\n    }\n  }\n  private static class Node {\n    final int index;\n    final int from;\n    final int to;\n    Node(int index, int from, int to) {\n      this.index = index;\n      this.from = from;\n      this.to = to;\n    }\n    @Override\n    public String toString() {\n      return \"Node{\" + \"index=\" + index + \", from=\" + from + \", to=\" + to + '}';\n    }\n  }\n"]]}
{"hexsha": "6c1a8a96cd60552269c9915646d5e27ec8cff213", "ext": "java", "lang": "Java", "content": "public class TestOptions {\n\n  public static final String TEST_PROPERTIES_RESOURCE = \"/org/tmatesoft/svn/test/test.properties\";\n  public static final String TEST_PROPERTIES_TEMPLATE_RESOURCE = \"/org/tmatesoft/svn/test/test.properties.template\";\n\n  public static TestOptions instance;\n\n  public static TestOptions loadFrom(Properties properties) {\n    final SVNURL repositoryUrl = getRepositoryUrl(properties);\n    final File tempDirectory = getTempDirectory(properties);\n    final String sqlite3Command = getSqlite3Command(properties);\n    final long largeUpdateStep = getLargeUpdateStep(properties);\n    final String svnCommand = getSvnCommand(properties);\n    final List<SVNRevisionRange> updateSchedule = getUpdateSchedule(properties);\n    final String apacheCtlCommand = getApacheCtlCommand(properties);\n    final File apacheRoot = getApacheRoot(properties);\n    final String htpasswdCommand = getHtpasswdCommand(properties);\n    final String svnserveCommand = getSvnserveCommand(properties);\n    return new TestOptions(repositoryUrl, tempDirectory, sqlite3Command, largeUpdateStep, svnCommand, updateSchedule, apacheCtlCommand, apacheRoot, htpasswdCommand, svnserveCommand);\n  }\n\n  private final SVNURL repositoryUrl;\n\n  private final File tempDirectory;\n\n  private final String sqlite3Command;\n\n  private final long largeUpdateStep;\n\n  private final String svnCommand;\n\n  private final List<SVNRevisionRange> updateSchedule;\n\n  private final String apacheCtlCommand;\n  private final File apacheRoot;\n  private final String htpasswdCommand;\n  private final String svnserveCommand;\n\n  public TestOptions(SVNURL repositoryUrl, File tempDirectory, String sqlite3Command, long largeUpdateStep, String svnCommand, List<SVNRevisionRange> updateSchedule, String apacheCtlCommand, File apacheRoot, String htpasswdCommand, String svnserveCommand) {\n    this.repositoryUrl = repositoryUrl;\n    this.tempDirectory = tempDirectory;\n    this.sqlite3Command = sqlite3Command;\n    this.largeUpdateStep = largeUpdateStep;\n    this.svnCommand = svnCommand;\n    this.updateSchedule = updateSchedule;\n    this.apacheCtlCommand = apacheCtlCommand;\n    this.apacheRoot = apacheRoot;\n    this.htpasswdCommand = htpasswdCommand;\n    this.svnserveCommand = svnserveCommand;\n  }\n\n  public SVNURL getRepositoryUrl() {\n    return repositoryUrl;\n  }\n\n  public File getTempDirectory() {\n    return tempDirectory;\n  }\n\n  public String getSqlite3Command() {\n    return sqlite3Command;\n  }\n\n  public long getLargeUpdateStep() {\n    return largeUpdateStep;\n  }\n\n  public String getSvnCommand() {\n    return svnCommand;\n  }\n\n  public List<SVNRevisionRange> getUpdateSchedule() {\n    return updateSchedule;\n  }\n\n  public String getApacheCtlCommand() {\n    return apacheCtlCommand;\n  }\n\n  public File getApacheRoot() {\n    return apacheRoot;\n  }\n\n  public String getHtpasswdCommand() {\n    return htpasswdCommand;\n  }\n\n  public String getSvnserveCommand() {\n    return svnserveCommand;\n  }\n\n  public static TestOptions getInstance() {\n    if (instance == null) {\n      Properties properties;\n\n      properties = loadPropertiesFromResource(TEST_PROPERTIES_RESOURCE);\n      if (properties != null) {\n        instance = TestOptions.loadFrom(properties);\n        return instance;\n      }\n      properties = loadPropertiesFromResource(TEST_PROPERTIES_TEMPLATE_RESOURCE);\n      if (properties != null) {\n        instance = TestOptions.loadFrom(properties);\n        return instance;\n      }\n\n      throw new RuntimeException(\"Unable to load properties resources: \" + TEST_PROPERTIES_RESOURCE + \" and \" + TEST_PROPERTIES_TEMPLATE_RESOURCE);\n    }\n    return instance;\n  }\n\n  private static Properties loadPropertiesFromResource(String resourceName) {\n    final InputStream inputStream = TestOptions.class.getResourceAsStream(resourceName);\n    if (inputStream == null) {\n      return null;\n    }\n    final Properties properties = new Properties();\n    try {\n      properties.load(inputStream);\n      return properties;\n    } catch (IOException e) {\n      return null;\n    } finally {\n      SVNFileUtil.closeFile(inputStream);\n    }\n  }\n\n  private static SVNURL getRepositoryUrl(Properties properties) {\n    try {\n      return SVNURL.parseURIEncoded(properties.getProperty(\"repository.url\"));\n    } catch (SVNException e) {\n      return null;\n    }\n  }\n\n  private static File getTempDirectory(Properties properties) {\n    final String tempDirectoryPath = properties.getProperty(\"temp.dir\");\n    return tempDirectoryPath == null ? new File(\".tests\") : new File(tempDirectoryPath);\n  }\n\n  private static String getSqlite3Command(Properties properties) {\n    final String sqlite3Command = properties.getProperty(\"sqlite3.command\");\n    return sqlite3Command == null ? \"sqlite3\" : sqlite3Command;\n  }\n\n  private static long getLargeUpdateStep(Properties properties) {\n    return getLongProperty(properties, \"large.update.step\", 10);\n  }\n\n  private static String getSvnCommand(Properties properties) {\n    return properties.getProperty(\"svn.command\", \"svn\");\n  }\n\n  private static long getLongProperty(Properties properties, String propertyName, long defaultValue) {\n    final String valueString = properties.getProperty(propertyName);\n    if (valueString == null) {\n      return defaultValue;\n    }\n\n    try {\n      return Long.parseLong(valueString);\n    } catch (NumberFormatException e) {\n      return defaultValue;\n    }\n  }\n\n  private static List<SVNRevisionRange> getUpdateSchedule(Properties properties) {\n    final String updateScheduleString = properties.getProperty(\"update.schedule\");\n    if (updateScheduleString == null) {\n      return null;\n    }\n\n    final String[] rangeStrings = updateScheduleString.split(\",\");\n\n    final List<SVNRevisionRange> ranges = new ArrayList<SVNRevisionRange>();\n    for (String rangeString : rangeStrings) {\n      final int dashIndex = rangeString.indexOf('-');\n      if (dashIndex >= 0) {\n        final String startRevisionString = rangeString.substring(0, dashIndex);\n        final String endRevisionString = rangeString.substring(dashIndex + 1);\n        ranges.add(new SVNRevisionRange(SVNRevision.parse(startRevisionString), SVNRevision.parse(endRevisionString)));\n      } else {\n        final SVNRevision revision = SVNRevision.parse(rangeString);\n        ranges.add(new SVNRevisionRange(revision, revision));\n      }\n    }\n    return ranges;\n  }\n\n  private static String getApacheCtlCommand(Properties properties) {\n    return properties.getProperty(\"apachectl.command\");\n  }\n\n  private static File getApacheRoot(Properties properties) {\n    final String apacheRootPath = properties.getProperty(\"apache.root\");\n    if (apacheRootPath == null) {\n      return null;\n    }\n    return new File(apacheRootPath);\n  }\n\n  private static String getHtpasswdCommand(Properties properties) {\n    return properties.getProperty(\"htpasswd.command\");\n  }\n\n  private static String getSvnserveCommand(Properties properties) {\n    return properties.getProperty(\"svnserve.command\");\n  }\n}", "class_id": 0, "repo": "kensipe/hygieia-scm-subversion-collector", "file": "src/test/java/com/capitalone/dashboard/TestOptions.java", "last_update_at": "2020-01-26T11:52:58+00:00", "question_id": "6c1a8a96cd60552269c9915646d5e27ec8cff213", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestOptions {\n  public static final String TEST_PROPERTIES_RESOURCE = \"/org/tmatesoft/svn/test/test.properties\";\n  public static final String TEST_PROPERTIES_TEMPLATE_RESOURCE = \"/org/tmatesoft/svn/test/test.properties.template\";\n  public static TestOptions instance;\n  public static TestOptions loadFrom(Properties properties) {\n    final SVNURL repositoryUrl = getRepositoryUrl(properties);\n    final File tempDirectory = getTempDirectory(properties);\n    final String sqlite3Command = getSqlite3Command(properties);\n    final long largeUpdateStep = getLargeUpdateStep(properties);\n    final String svnCommand = getSvnCommand(properties);\n    final List<SVNRevisionRange> updateSchedule = getUpdateSchedule(properties);\n    final String apacheCtlCommand = getApacheCtlCommand(properties);\n    final File apacheRoot = getApacheRoot(properties);\n    final String htpasswdCommand = getHtpasswdCommand(properties);\n    final String svnserveCommand = getSvnserveCommand(properties);\n    return new TestOptions(repositoryUrl, tempDirectory, sqlite3Command, largeUpdateStep, svnCommand, updateSchedule, apacheCtlCommand, apacheRoot, htpasswdCommand, svnserveCommand);\n  }\n  private final SVNURL repositoryUrl;\n  private final File tempDirectory;\n  private final String sqlite3Command;\n  private final long largeUpdateStep;\n  private final String svnCommand;\n  private final List<SVNRevisionRange> updateSchedule;\n  private final String apacheCtlCommand;\n  private final File apacheRoot;\n  private final String htpasswdCommand;\n  private final String svnserveCommand;\n  public TestOptions(SVNURL repositoryUrl, File tempDirectory, String sqlite3Command, long largeUpdateStep, String svnCommand, List<SVNRevisionRange> updateSchedule, String apacheCtlCommand, File apacheRoot, String htpasswdCommand, String svnserveCommand) {\n    this.repositoryUrl = repositoryUrl;\n    this.tempDirectory = tempDirectory;\n    this.sqlite3Command = sqlite3Command;\n    this.largeUpdateStep = largeUpdateStep;\n    this.svnCommand = svnCommand;\n    this.updateSchedule = updateSchedule;\n    this.apacheCtlCommand = apacheCtlCommand;\n    this.apacheRoot = apacheRoot;\n    this.htpasswdCommand = htpasswdCommand;\n    this.svnserveCommand = svnserveCommand;\n  }\n  public SVNURL getRepositoryUrl() {\n    return repositoryUrl;\n  }\n  public File getTempDirectory() {\n    return tempDirectory;\n  }\n  public String getSqlite3Command() {\n    return sqlite3Command;\n  }\n  public long getLargeUpdateStep() {\n    return largeUpdateStep;\n  }\n  public String getSvnCommand() {\n    return svnCommand;\n  }\n  public List<SVNRevisionRange> getUpdateSchedule() {\n    return updateSchedule;\n  }\n  public String getApacheCtlCommand() {\n    return apacheCtlCommand;\n  }\n  public File getApacheRoot() {\n    return apacheRoot;\n  }\n  public String getHtpasswdCommand() {\n    return htpasswdCommand;\n  }\n  public String getSvnserveCommand() {\n    return svnserveCommand;\n  }\n  public static TestOptions getInstance() {\n    if (instance == null) {\n      Properties properties;\n      properties = loadPropertiesFromResource(TEST_PROPERTIES_RESOURCE);\n      if (properties != null) {\n        instance = TestOptions.loadFrom(properties);\n        return instance;\n      }\n      properties = loadPropertiesFromResource(TEST_PROPERTIES_TEMPLATE_RESOURCE);\n      if (properties != null) {\n        instance = TestOptions.loadFrom(properties);\n        return instance;\n      }\n      throw new RuntimeException(\"Unable to load properties resources: \" + TEST_PROPERTIES_RESOURCE + \" and \" + TEST_PROPERTIES_TEMPLATE_RESOURCE);\n    }\n    return instance;\n  }\n  private static Properties loadPropertiesFromResource(String resourceName) {\n    final InputStream inputStream = TestOptions.class.getResourceAsStream(resourceName);\n    if (inputStream == null) {\n      return null;\n    }\n    final Properties properties = new Properties();\n    try {\n      properties.load(inputStream);\n      return properties;\n    } catch (IOException e) {\n      return null;\n    } finally {\n      SVNFileUtil.closeFile(inputStream);\n    }\n  }\n  private static SVNURL getRepositoryUrl(Properties properties) {\n    try {\n      return SVNURL.parseURIEncoded(properties.getProperty(\"repository.url\"));\n    } catch (SVNException e) {\n      return null;\n    }\n  }\n  private static File getTempDirectory(Properties properties) {\n    final String tempDirectoryPath = properties.getProperty(\"temp.dir\");\n    return tempDirectoryPath == null ? new File(\".tests\") : new File(tempDirectoryPath);\n  }\n  private static String getSqlite3Command(Properties properties) {\n    final String sqlite3Command = properties.getProperty(\"sqlite3.command\");\n    return sqlite3Command == null ? \"sqlite3\" : sqlite3Command;\n  }\n  private static long getLargeUpdateStep(Properties properties) {\n    return getLongProperty(properties, \"large.update.step\", 10);\n  }\n  private static String getSvnCommand(Properties properties) {\n    return properties.getProperty(\"svn.command\", \"svn\");\n  }\n  private static long getLongProperty(Properties properties, String propertyName, long defaultValue) {\n    final String valueString = properties.getProperty(propertyName);\n    if (valueString == null) {\n      return defaultValue;\n    }\n    try {\n      return Long.parseLong(valueString);\n    } catch (NumberFormatException e) {\n      return defaultValue;\n    }\n  }\n  private static List<SVNRevisionRange> getUpdateSchedule(Properties properties) {\n    final String updateScheduleString = properties.getProperty(\"update.schedule\");\n    if (updateScheduleString == null) {\n      return null;\n    }\n    final String[] rangeStrings = updateScheduleString.split(\",\");\n    final List<SVNRevisionRange> ranges = new ArrayList<SVNRevisionRange>();\n    for (String rangeString : rangeStrings) {\n      final int dashIndex = rangeString.indexOf('-');\n      if (dashIndex >= 0) {\n        final String startRevisionString = rangeString.substring(0, dashIndex);\n        final String endRevisionString = rangeString.substring(dashIndex + 1);\n        ranges.add(new SVNRevisionRange(SVNRevision.parse(startRevisionString), SVNRevision.parse(endRevisionString)));\n      } else {\n        final SVNRevision revision = SVNRevision.parse(rangeString);\n        ranges.add(new SVNRevisionRange(revision, revision));\n      }\n    }\n    return ranges;\n  }\n  private static String getApacheCtlCommand(Properties properties) {\n    return properties.getProperty(\"apachectl.command\");\n  }\n  private static File getApacheRoot(Properties properties) {\n    final String apacheRootPath = properties.getProperty(\"apache.root\");\n    if (apacheRootPath == null) {\n      return null;\n    }\n    return new File(apacheRootPath);\n  }\n  private static String getHtpasswdCommand(Properties properties) {\n    return properties.getProperty(\"htpasswd.command\");\n  }\n  private static String getSvnserveCommand(Properties properties) {\n    return properties.getProperty(\"svnserve.command\");\n  }\n"]]}
{"hexsha": "d776db482f76279697a4de02d2a60eec296d956e", "ext": "java", "lang": "Java", "content": "public class SortMethod {\n\n    public static final String MESSAGE_CONSTRAINTS = \"Sort method must be either name, date, or priority.\";\n    public static final Comparator STUB_COMPARATOR = (a, b) -> 0; //Stub comparator\n    private final String sortMethodString;\n    private final Comparator<Deadline> deadlineComparator;\n    private final Comparator<Event> eventComparator;\n\n    /**\n     * Constructs a {@code SortMethod}.\n     * @param method A valid method of sorting.\n     */\n    public SortMethod(String method) {\n        requireNonNull(method);\n        checkArgument(isValidSortMethod(method), MESSAGE_CONSTRAINTS);\n        this.sortMethodString = method;\n        this.deadlineComparator = generateDeadlineComparator(method);\n        this.eventComparator = generateEventComparator(method);\n\n    }\n\n    /**\n     * Returns true if a given string is a valid method of sorting.\n     */\n    public static boolean isValidSortMethod(String test) {\n        return (test.equals(\"name\") || test.equals(\"date\") || test.equals(\"priority\"));\n    }\n\n    /**\n     * Returns the string value of the sort method.\n     * @return The string representation of the method of sorting.\n     */\n    public String getSortMethodString() {\n        return sortMethodString;\n    }\n\n    /**\n     * Returns the DeadlineComparator of the sort method.\n     * @return The Comparator used to sort the deadline list.\n     */\n    public Comparator<Deadline> getDeadlineComparator() {\n        return deadlineComparator;\n    }\n\n    /**\n     * Returns the EventComparator of the sort method.\n     * @return The EventComparator used to sort the event list.\n     */\n    public Comparator<Event> getEventComparator() {\n        return eventComparator;\n    }\n\n    /**\n     * Generates and returns the DeadlineComparator used to sort the deadline list.\n     * Default deadline comparator, sorts in ascending order.\n     * Lexicographically smallest(a-z), earliest due date, highest priority at the top of the module deadline list.\n     * @return The DeadlineComparator of this instance of {@code SortMethod}.\n     */\n    public Comparator<Deadline> generateDeadlineComparator(String method) {\n        Comparator<Deadline> nameSorter = Comparator.comparing(l -> l.getName().toString(),\n                String.CASE_INSENSITIVE_ORDER);\n        Comparator<Deadline> dateSorter = Comparator.comparing(l -> l.getDueDate().toString());\n        Comparator<Deadline> prioritySorter = Comparator.comparing(l -> l.getPriority().toString(),\n                Comparator.reverseOrder());\n\n        switch (method) {\n        case \"name\":\n            return nameSorter;\n        case \"date\":\n            return dateSorter;\n        case \"priority\":\n            return prioritySorter;\n        default:\n            throw new IllegalStateException(\"Unexpected value: \" + getSortMethodString());\n        }\n    }\n\n    /**\n     * Generates and returns the EventComparator used to sort the event list.\n     * Default event comparator, sorts in ascending order.\n     * Lexicographically smallest(a-z), earliest start date, at the top of the module event list.\n     * Will not sort based on priority.\n     * @return The DeadlineComparator of this instance of {@code SortMethod}.\n     */\n    public Comparator<Event> generateEventComparator(String method) {\n        Comparator<Event> nameSorter = Comparator.comparing(l -> l.getName().toString(),\n                String.CASE_INSENSITIVE_ORDER);\n        Comparator<Event> dateSorter = Comparator.comparing(l -> l.getStartDate().toString());\n        Comparator<Event> prioritySorter = STUB_COMPARATOR;\n\n        switch (method) {\n        case \"name\":\n            return nameSorter;\n        case \"date\":\n            return dateSorter;\n        case \"priority\":\n            return prioritySorter;\n        default:\n            throw new IllegalStateException(\"Unexpected value: \" + getSortMethodString());\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getSortMethodString();\n    }\n\n}", "class_id": 0, "repo": "AY1920S2-CS2103T-T10-4/main", "file": "src/main/java/nasa/model/module/SortMethod.java", "last_update_at": "2020-04-15T18:50:05+00:00", "question_id": "d776db482f76279697a4de02d2a60eec296d956e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SortMethod {\n    public static final String MESSAGE_CONSTRAINTS = \"Sort method must be either name, date, or priority.\";\n    public static final Comparator STUB_COMPARATOR = (a, b) -> 0; //Stub comparator\n    private final String sortMethodString;\n    private final Comparator<Deadline> deadlineComparator;\n    private final Comparator<Event> eventComparator;\n    /**\n     * Constructs a {@code SortMethod}.\n     * @param method A valid method of sorting.\n     */\n    public SortMethod(String method) {\n        requireNonNull(method);\n        checkArgument(isValidSortMethod(method), MESSAGE_CONSTRAINTS);\n        this.sortMethodString = method;\n        this.deadlineComparator = generateDeadlineComparator(method);\n        this.eventComparator = generateEventComparator(method);\n    }\n    /**\n     * Returns true if a given string is a valid method of sorting.\n     */\n    public static boolean isValidSortMethod(String test) {\n        return (test.equals(\"name\") || test.equals(\"date\") || test.equals(\"priority\"));\n    }\n    /**\n     * Returns the string value of the sort method.\n     * @return The string representation of the method of sorting.\n     */\n    public String getSortMethodString() {\n        return sortMethodString;\n    }\n    /**\n     * Returns the DeadlineComparator of the sort method.\n     * @return The Comparator used to sort the deadline list.\n     */\n    public Comparator<Deadline> getDeadlineComparator() {\n        return deadlineComparator;\n    }\n    /**\n     * Returns the EventComparator of the sort method.\n     * @return The EventComparator used to sort the event list.\n     */\n    public Comparator<Event> getEventComparator() {\n        return eventComparator;\n    }\n    /**\n     * Generates and returns the DeadlineComparator used to sort the deadline list.\n     * Default deadline comparator, sorts in ascending order.\n     * Lexicographically smallest(a-z), earliest due date, highest priority at the top of the module deadline list.\n     * @return The DeadlineComparator of this instance of {@code SortMethod}.\n     */\n    public Comparator<Deadline> generateDeadlineComparator(String method) {\n        Comparator<Deadline> nameSorter = Comparator.comparing(l -> l.getName().toString(),\n                String.CASE_INSENSITIVE_ORDER);\n        Comparator<Deadline> dateSorter = Comparator.comparing(l -> l.getDueDate().toString());\n        Comparator<Deadline> prioritySorter = Comparator.comparing(l -> l.getPriority().toString(),\n                Comparator.reverseOrder());\n        switch (method) {\n        case \"name\":\n            return nameSorter;\n        case \"date\":\n            return dateSorter;\n        case \"priority\":\n            return prioritySorter;\n        default:\n            throw new IllegalStateException(\"Unexpected value: \" + getSortMethodString());\n        }\n    }\n    /**\n     * Generates and returns the EventComparator used to sort the event list.\n     * Default event comparator, sorts in ascending order.\n     * Lexicographically smallest(a-z), earliest start date, at the top of the module event list.\n     * Will not sort based on priority.\n     * @return The DeadlineComparator of this instance of {@code SortMethod}.\n     */\n    public Comparator<Event> generateEventComparator(String method) {\n        Comparator<Event> nameSorter = Comparator.comparing(l -> l.getName().toString(),\n                String.CASE_INSENSITIVE_ORDER);\n        Comparator<Event> dateSorter = Comparator.comparing(l -> l.getStartDate().toString());\n        Comparator<Event> prioritySorter = STUB_COMPARATOR;\n        switch (method) {\n        case \"name\":\n            return nameSorter;\n        case \"date\":\n            return dateSorter;\n        case \"priority\":\n            return prioritySorter;\n        default:\n            throw new IllegalStateException(\"Unexpected value: \" + getSortMethodString());\n        }\n    }\n    @Override\n    public String toString() {\n        return getSortMethodString();\n    }\n"]]}
{"hexsha": "74c857c84a0c4cd364460945e703d62d617ab4d0", "ext": "java", "lang": "Java", "content": "public class BuyToGetFeaturesSpriteWithText extends Sprite {\n\n\tprivate AnimatedSprite animatedSpriteTowerLur;\n\n\tprivate AnimatedSprite animatedSpriteTowerSpear;\n\n\tprivate LFont font;\n\n\tprivate LFont fontHuge;\n\n\tprivate LFont fontMedium;\n\n\tprivate MainGame game;\n\n\tpublic BuyToGetFeaturesSpriteWithText(MainGame game) {\n\t\tsuper(game, \"assets/buytogetfeatures.png\", 0, new Vector2f(0f, 0f));\n\t\tthis.game = game;\n\t\tthis.animatedSpriteTowerSpear = AnimatedSpriteTower\n\t\t\t\t.GetAnimatedSpriteTowerForTowerToolbar(game, new Vector2f(109f,\n\t\t\t\t\t\t154f), TowerType.Spear, 0.4f);\n\t\tthis.animatedSpriteTowerSpear.setDrawOrder(0x149);\n\t\tthis.animatedSpriteTowerSpear.setAnimationSpeedRatio(3);\n\t\tthis.animatedSpriteTowerSpear.setObeyGameOpacity(false);\n\t\tthis.animatedSpriteTowerSpear.setOnlyAnimateIfGameStateStarted(false);\n\t\tthis.animatedSpriteTowerLur = AnimatedSpriteTower\n\t\t\t\t.GetAnimatedSpriteTowerForTowerToolbar(game, new Vector2f(269f,\n\t\t\t\t\t\t132f), TowerType.Lur, 0.4f);\n\t\tthis.animatedSpriteTowerLur.setDrawOrder(0x149);\n\t\tthis.animatedSpriteTowerLur.setAnimationSpeedRatio(3);\n\t\tthis.animatedSpriteTowerLur.setObeyGameOpacity(false);\n\t\tthis.animatedSpriteTowerLur.setOnlyAnimateIfGameStateStarted(false);\n\t\tgame.Components().add(this.animatedSpriteTowerSpear);\n\t\tgame.Components().add(this.animatedSpriteTowerLur);\n\t}\n\n\t@Override\n\tpublic void draw(SpriteBatch batch, GameTime gameTime) {\n\t\tsuper.draw(batch, gameTime);\n\t\tUtils.DrawStringAlignCenter(batch, this.fontHuge,\n\t\t\t\tLanguageResources.getBuyGame(), 160f, 3f, LColor.white);\n\t\tUtils.DrawStringAlignCenter(batch, this.fontMedium,\n\t\t\t\tLanguageResources.getPleaseUnlock(), new Vector2f(160f, 74f),\n\t\t\t\tLColor.white);\n\t\tint num = 8;\n\t\tint num2 = 0xae;\n\t\tUtils.DrawStringAlignLeft(batch, this.font,\n\t\t\t\t\"* \" + LanguageResources.getMediumDifficulty(), num, 102f,\n\t\t\t\tLColor.white);\n\t\tUtils.DrawStringAlignLeft(batch, this.font,\n\t\t\t\t\"* \" + LanguageResources.getSpearTower(), num, 132f,\n\t\t\t\tLColor.white);\n\t\tUtils.DrawStringAlignLeft(batch, this.font,\n\t\t\t\t\"* \" + LanguageResources.getHardDifficulty(), num, 162f,\n\t\t\t\tLColor.white);\n\t\tUtils.DrawStringAlignLeft(batch, this.font,\n\t\t\t\t\"* \" + LanguageResources.getLurTower(), num2, 102f,\n\t\t\t\tLColor.white);\n\t\tUtils.DrawStringAlignLeft(batch, this.font,\n\t\t\t\t\"* \" + LanguageResources.getTwoExtraLevels(), num2, 132f,\n\t\t\t\tLColor.white);\n\t\tUtils.DrawStringAlignLeft(batch, this.font,\n\t\t\t\t\"* \" + LanguageResources.getSupportTheGame(), num2, 162f,\n\t\t\t\tLColor.white);\n\t\tUtils.DrawStringAlignCenter(batch, this.font, LanguageResources\n\t\t\t\t.getUnlockGame().toUpperCase(), 94f, 433f, LColor.white);\n\t\tUtils.DrawStringAlignCenter(batch, this.font,\n\t\t\t\tLanguageResources.getNotNow(), 242f, 433f, LColor.white);\n\t}\n\n\tpublic final void Exit() {\n\t\tif (this.animatedSpriteTowerSpear != null) {\n\t\t\tthis.game.Components().remove(this.animatedSpriteTowerSpear);\n\t\t}\n\t\tif (this.animatedSpriteTowerLur != null) {\n\t\t\tthis.game.Components().remove(this.animatedSpriteTowerLur);\n\t\t}\n\t\tthis.game.Components().remove(this);\n\t}\n\n\t@Override\n\tprotected void loadContent() {\n\t\tthis.fontHuge = LFont.getFont(32);\n\t\tthis.fontMedium = LFont.getFont(16);\n\t\tthis.font = LFont.getFont(12);\n\t\tsuper.loadContent();\n\t}\n}", "class_id": 0, "repo": "windows10207/LGame", "file": "Java/Examples/TowerDefenceGLES/src/org/test/BuyToGetFeaturesSpriteWithText.java", "last_update_at": "2020-05-29T08:04:26+00:00", "question_id": "74c857c84a0c4cd364460945e703d62d617ab4d0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BuyToGetFeaturesSpriteWithText extends Sprite {\n\tprivate AnimatedSprite animatedSpriteTowerLur;\n\tprivate AnimatedSprite animatedSpriteTowerSpear;\n\tprivate LFont font;\n\tprivate LFont fontHuge;\n\tprivate LFont fontMedium;\n\tprivate MainGame game;\n\tpublic BuyToGetFeaturesSpriteWithText(MainGame game) {\n\t\tsuper(game, \"assets/buytogetfeatures.png\", 0, new Vector2f(0f, 0f));\n\t\tthis.game = game;\n\t\tthis.animatedSpriteTowerSpear = AnimatedSpriteTower\n\t\t\t\t.GetAnimatedSpriteTowerForTowerToolbar(game, new Vector2f(109f,\n\t\t\t\t\t\t154f), TowerType.Spear, 0.4f);\n\t\tthis.animatedSpriteTowerSpear.setDrawOrder(0x149);\n\t\tthis.animatedSpriteTowerSpear.setAnimationSpeedRatio(3);\n\t\tthis.animatedSpriteTowerSpear.setObeyGameOpacity(false);\n\t\tthis.animatedSpriteTowerSpear.setOnlyAnimateIfGameStateStarted(false);\n\t\tthis.animatedSpriteTowerLur = AnimatedSpriteTower\n\t\t\t\t.GetAnimatedSpriteTowerForTowerToolbar(game, new Vector2f(269f,\n\t\t\t\t\t\t132f), TowerType.Lur, 0.4f);\n\t\tthis.animatedSpriteTowerLur.setDrawOrder(0x149);\n\t\tthis.animatedSpriteTowerLur.setAnimationSpeedRatio(3);\n\t\tthis.animatedSpriteTowerLur.setObeyGameOpacity(false);\n\t\tthis.animatedSpriteTowerLur.setOnlyAnimateIfGameStateStarted(false);\n\t\tgame.Components().add(this.animatedSpriteTowerSpear);\n\t\tgame.Components().add(this.animatedSpriteTowerLur);\n\t}\n\t@Override\n\tpublic void draw(SpriteBatch batch, GameTime gameTime) {\n\t\tsuper.draw(batch, gameTime);\n\t\tUtils.DrawStringAlignCenter(batch, this.fontHuge,\n\t\t\t\tLanguageResources.getBuyGame(), 160f, 3f, LColor.white);\n\t\tUtils.DrawStringAlignCenter(batch, this.fontMedium,\n\t\t\t\tLanguageResources.getPleaseUnlock(), new Vector2f(160f, 74f),\n\t\t\t\tLColor.white);\n\t\tint num = 8;\n\t\tint num2 = 0xae;\n\t\tUtils.DrawStringAlignLeft(batch, this.font,\n\t\t\t\t\"* \" + LanguageResources.getMediumDifficulty(), num, 102f,\n\t\t\t\tLColor.white);\n\t\tUtils.DrawStringAlignLeft(batch, this.font,\n\t\t\t\t\"* \" + LanguageResources.getSpearTower(), num, 132f,\n\t\t\t\tLColor.white);\n\t\tUtils.DrawStringAlignLeft(batch, this.font,\n\t\t\t\t\"* \" + LanguageResources.getHardDifficulty(), num, 162f,\n\t\t\t\tLColor.white);\n\t\tUtils.DrawStringAlignLeft(batch, this.font,\n\t\t\t\t\"* \" + LanguageResources.getLurTower(), num2, 102f,\n\t\t\t\tLColor.white);\n\t\tUtils.DrawStringAlignLeft(batch, this.font,\n\t\t\t\t\"* \" + LanguageResources.getTwoExtraLevels(), num2, 132f,\n\t\t\t\tLColor.white);\n\t\tUtils.DrawStringAlignLeft(batch, this.font,\n\t\t\t\t\"* \" + LanguageResources.getSupportTheGame(), num2, 162f,\n\t\t\t\tLColor.white);\n\t\tUtils.DrawStringAlignCenter(batch, this.font, LanguageResources\n\t\t\t\t.getUnlockGame().toUpperCase(), 94f, 433f, LColor.white);\n\t\tUtils.DrawStringAlignCenter(batch, this.font,\n\t\t\t\tLanguageResources.getNotNow(), 242f, 433f, LColor.white);\n\t}\n\tpublic final void Exit() {\n\t\tif (this.animatedSpriteTowerSpear != null) {\n\t\t\tthis.game.Components().remove(this.animatedSpriteTowerSpear);\n\t\t}\n\t\tif (this.animatedSpriteTowerLur != null) {\n\t\t\tthis.game.Components().remove(this.animatedSpriteTowerLur);\n\t\t}\n\t\tthis.game.Components().remove(this);\n\t}\n\t@Override\n\tprotected void loadContent() {\n\t\tthis.fontHuge = LFont.getFont(32);\n\t\tthis.fontMedium = LFont.getFont(16);\n\t\tthis.font = LFont.getFont(12);\n\t\tsuper.loadContent();\n\t}\n"]]}
{"hexsha": "6aa4f7b1b0f657562e0d07ceaca2f5db957eb225", "ext": "java", "lang": "Java", "content": "@Service(interfaceClass=SystemLogService.class)\npublic class SystemLogServiceImpl extends BaseServiceImpl<SystemLog> implements SystemLogService {\n\t\n\t@Resource\n\tprivate ICurrentUser currentUser;\n\t\n\t@Resource\n\tprivate SystemLogDao systemLogDao;\n\t\n\t@Resource\n\tprivate com.pepper.service.console.role.RoleService RoleService;\n\n\tpublic void log(String actionName,String url){\n\t\tServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();\n\t    HttpServletRequest request = servletRequestAttributes.getRequest();\n\t\tAdminUser user = (AdminUser) currentUser.getCurrentUser();\n\t\tif(Objects.isNull(user)) {\n\t\t\treturn;\n\t\t}\n\t\tList<Role> list = RoleService.findByUserId1(user.getId());\n\t\tSystemLog systemLog = new SystemLog();\n\t\tfor(Role role : list ) {\n\t\t\tif(Objects.equals(role.getIsDefault(), true)) {\n\t\t\t\tsystemLog.setRoleCode(role.getCode());\n\t\t\t\tsystemLog.setRoleName(role.getName());\n\t\t\t\tsystemLog.setRoleId(role.getId());\n\t\t\t}\n\t\t}\n\t\tsystemLog.setAccount(user.getAccount());\n\t\tsystemLog.setUserId(user==null?\"\":user.getId());\n\t\tsystemLog.setUserName(user==null?\"\":user.getName());\n\t\tsystemLog.setLogContent(actionName);\n\t\tsystemLog.setUrl(request.getRequestURL().toString());\n\t\t\n\t    if(request.getParameterMap().size()>0) {\n\t    \tObjectMapper objectMapper = new ObjectMapper();\n\t    \ttry {\n\t\t\t\tsystemLog.setData(objectMapper.writeValueAsString(request.getParameterMap()));\n\t\t\t} catch (JsonProcessingException e) {\n\t\t\t}\n\t    }\n\t    if(StringUtils.hasText(systemLog.getData())) {\n\t    \tsystemLog.setData(systemLog.getData() + \" \"+ binaryReader(request));\n\t    }else {\n\t    \tsystemLog.setData( binaryReader(request));\n\t    }\n\t    \n\t\tthis.save(systemLog);\n\t}\n\t\n\tpublic void log(String actionName,String url,String data){\n\t\tServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();\n\t    HttpServletRequest request = servletRequestAttributes.getRequest();\n\t\tAdminUser user = (AdminUser) currentUser.getCurrentUser();\n\t\tif(Objects.isNull(user)) {\n\t\t\treturn;\n\t\t}\n\t\tList<Role> list = RoleService.findByUserId1(user.getId());\n\t\tSystemLog systemLog = new SystemLog();\n\t\tfor(Role role : list ) {\n\t\t\tif(Objects.equals(role.getIsDefault(), true)) {\n\t\t\t\tsystemLog.setRoleCode(role.getCode());\n\t\t\t\tsystemLog.setRoleName(role.getName());\n\t\t\t\tsystemLog.setRoleId(role.getId());\n\t\t\t}\n\t\t}\n\t\tsystemLog.setAccount(user.getAccount());\n\t\tsystemLog.setUserId(user==null?\"\":user.getId());\n\t\tsystemLog.setUserName(user==null?\"\":user.getName());\n\t\tsystemLog.setLogContent(actionName);\n\t\tif(request.getParameterMap().size()>0) {\n\t    \tObjectMapper objectMapper = new ObjectMapper();\n\t    \ttry {\n\t\t\t\tsystemLog.setData(objectMapper.writeValueAsString(request.getParameterMap()));\n\t\t\t} catch (JsonProcessingException e) {\n\t\t\t}\n\t    }\n\t\tif(StringUtils.hasText(systemLog.getData())) {\n\t    \tsystemLog.setData(systemLog.getData() + \" \"+ binaryReader(request));\n\t    }else {\n\t    \tsystemLog.setData( binaryReader(request));\n\t    }\n\t\tsystemLog.setUrl(request.getRequestURL().toString());\n\t\tthis.save(systemLog);\n\t}\n\t\n\tpublic void log(String actionName,String url,AdminUser adminUser){\n\t\tif(Objects.isNull(adminUser)) {\n\t\t\treturn;\n\t\t}\n\t\tServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();\n\t    HttpServletRequest request = servletRequestAttributes.getRequest();\n\t    List<Role> list = RoleService.findByUserId1(adminUser.getId());\n\t\tSystemLog systemLog = new SystemLog();\n\t\tfor(Role role : list ) {\n\t\t\tif(Objects.equals(role.getIsDefault(), true)) {\n\t\t\t\tsystemLog.setRoleCode(role.getCode());\n\t\t\t\tsystemLog.setRoleName(role.getName());\n\t\t\t\tsystemLog.setRoleId(role.getId());\n\t\t\t}\n\t\t}\n\t\tsystemLog.setAccount(adminUser.getAccount());\n\t\tsystemLog.setUserId(adminUser==null?\"\":adminUser.getId());\n\t\tsystemLog.setUserName(adminUser==null?\"\":adminUser.getName());\n\t\tsystemLog.setLogContent(actionName);\n\t\tsystemLog.setUrl(request.getRequestURL().toString());\n\t\tif(request.getParameterMap().size()>0) {\n\t    \tObjectMapper objectMapper = new ObjectMapper();\n\t    \ttry {\n\t\t\t\tsystemLog.setData(objectMapper.writeValueAsString(request.getParameterMap()));\n\t\t\t} catch (JsonProcessingException e) {\n\t\t\t}\n\t    }\n\t\tif(StringUtils.hasText(systemLog.getData())) {\n\t    \tsystemLog.setData(systemLog.getData() + \" \"+ binaryReader(request));\n\t    }else {\n\t    \tsystemLog.setData( binaryReader(request));\n\t    }\n\t\tthis.save(systemLog);\n\t}\n\t\n\t\n\n\tprivate String binaryReader(HttpServletRequest request) {\n\t\t\n\t\ttry {\n\t\t\tStringWriter writer = new StringWriter();\n\t\t\tIOUtils.copy(request.getInputStream(), writer, StandardCharsets.UTF_8.name());\n\t\t\tString str = writer.toString();\n\t\t\treturn str;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn \"\";\n\t\t\n\t}\n\n\t@Override\n\tpublic void log(String actionName) {\n\t\tServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();\n\t    HttpServletRequest request = servletRequestAttributes.getRequest();\n\t\tAdminUser user = (AdminUser) currentUser.getCurrentUser();\n\t\tif(Objects.isNull(user)) {\n\t\t\treturn;\n\t\t}\n\t\tList<Role> list = RoleService.findByUserId1(user.getId());\n\t\tSystemLog systemLog = new SystemLog();\n\t\tfor(Role role : list ) {\n\t\t\tif(Objects.equals(role.getIsDefault(), true)) {\n\t\t\t\tsystemLog.setRoleCode(role.getCode());\n\t\t\t\tsystemLog.setRoleName(role.getName());\n\t\t\t\tsystemLog.setRoleId(role.getId());\n\t\t\t}\n\t\t}\n\t\tsystemLog.setAccount(user.getAccount());\n\t\tsystemLog.setUserId(user==null?\"\":user.getId());\n\t\tsystemLog.setUserName(user==null?\"\":user.getName());\n\t\tsystemLog.setLogContent(actionName);\n\t\tsystemLog.setUrl(request.getRequestURL().toString());\n\t\tthis.save(systemLog);\n\t}\n\t\n}", "class_id": 0, "repo": "MrLiuFang/emap", "file": "emap-business/src/main/java/com/pepper/service/emap/log/SystemLogServiceImpl.java", "last_update_at": "2020-03-15T12:51:29+00:00", "question_id": "6aa4f7b1b0f657562e0d07ceaca2f5db957eb225", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service(interfaceClass=SystemLogService.class)\npublic class SystemLogServiceImpl extends BaseServiceImpl<SystemLog> implements SystemLogService {\n\t\n\t@Resource\n\tprivate ICurrentUser currentUser;\n\t\n\t@Resource\n\tprivate SystemLogDao systemLogDao;\n\t\n\t@Resource\n\tprivate com.pepper.service.console.role.RoleService RoleService;\n\tpublic void log(String actionName,String url){\n\t\tServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();\n\t    HttpServletRequest request = servletRequestAttributes.getRequest();\n\t\tAdminUser user = (AdminUser) currentUser.getCurrentUser();\n\t\tif(Objects.isNull(user)) {\n\t\t\treturn;\n\t\t}\n\t\tList<Role> list = RoleService.findByUserId1(user.getId());\n\t\tSystemLog systemLog = new SystemLog();\n\t\tfor(Role role : list ) {\n\t\t\tif(Objects.equals(role.getIsDefault(), true)) {\n\t\t\t\tsystemLog.setRoleCode(role.getCode());\n\t\t\t\tsystemLog.setRoleName(role.getName());\n\t\t\t\tsystemLog.setRoleId(role.getId());\n\t\t\t}\n\t\t}\n\t\tsystemLog.setAccount(user.getAccount());\n\t\tsystemLog.setUserId(user==null?\"\":user.getId());\n\t\tsystemLog.setUserName(user==null?\"\":user.getName());\n\t\tsystemLog.setLogContent(actionName);\n\t\tsystemLog.setUrl(request.getRequestURL().toString());\n\t\t\n\t    if(request.getParameterMap().size()>0) {\n\t    \tObjectMapper objectMapper = new ObjectMapper();\n\t    \ttry {\n\t\t\t\tsystemLog.setData(objectMapper.writeValueAsString(request.getParameterMap()));\n\t\t\t} catch (JsonProcessingException e) {\n\t\t\t}\n\t    }\n\t    if(StringUtils.hasText(systemLog.getData())) {\n\t    \tsystemLog.setData(systemLog.getData() + \" \"+ binaryReader(request));\n\t    }else {\n\t    \tsystemLog.setData( binaryReader(request));\n\t    }\n\t    \n\t\tthis.save(systemLog);\n\t}\n\t\n\tpublic void log(String actionName,String url,String data){\n\t\tServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();\n\t    HttpServletRequest request = servletRequestAttributes.getRequest();\n\t\tAdminUser user = (AdminUser) currentUser.getCurrentUser();\n\t\tif(Objects.isNull(user)) {\n\t\t\treturn;\n\t\t}\n\t\tList<Role> list = RoleService.findByUserId1(user.getId());\n\t\tSystemLog systemLog = new SystemLog();\n\t\tfor(Role role : list ) {\n\t\t\tif(Objects.equals(role.getIsDefault(), true)) {\n\t\t\t\tsystemLog.setRoleCode(role.getCode());\n\t\t\t\tsystemLog.setRoleName(role.getName());\n\t\t\t\tsystemLog.setRoleId(role.getId());\n\t\t\t}\n\t\t}\n\t\tsystemLog.setAccount(user.getAccount());\n\t\tsystemLog.setUserId(user==null?\"\":user.getId());\n\t\tsystemLog.setUserName(user==null?\"\":user.getName());\n\t\tsystemLog.setLogContent(actionName);\n\t\tif(request.getParameterMap().size()>0) {\n\t    \tObjectMapper objectMapper = new ObjectMapper();\n\t    \ttry {\n\t\t\t\tsystemLog.setData(objectMapper.writeValueAsString(request.getParameterMap()));\n\t\t\t} catch (JsonProcessingException e) {\n\t\t\t}\n\t    }\n\t\tif(StringUtils.hasText(systemLog.getData())) {\n\t    \tsystemLog.setData(systemLog.getData() + \" \"+ binaryReader(request));\n\t    }else {\n\t    \tsystemLog.setData( binaryReader(request));\n\t    }\n\t\tsystemLog.setUrl(request.getRequestURL().toString());\n\t\tthis.save(systemLog);\n\t}\n\t\n\tpublic void log(String actionName,String url,AdminUser adminUser){\n\t\tif(Objects.isNull(adminUser)) {\n\t\t\treturn;\n\t\t}\n\t\tServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();\n\t    HttpServletRequest request = servletRequestAttributes.getRequest();\n\t    List<Role> list = RoleService.findByUserId1(adminUser.getId());\n\t\tSystemLog systemLog = new SystemLog();\n\t\tfor(Role role : list ) {\n\t\t\tif(Objects.equals(role.getIsDefault(), true)) {\n\t\t\t\tsystemLog.setRoleCode(role.getCode());\n\t\t\t\tsystemLog.setRoleName(role.getName());\n\t\t\t\tsystemLog.setRoleId(role.getId());\n\t\t\t}\n\t\t}\n\t\tsystemLog.setAccount(adminUser.getAccount());\n\t\tsystemLog.setUserId(adminUser==null?\"\":adminUser.getId());\n\t\tsystemLog.setUserName(adminUser==null?\"\":adminUser.getName());\n\t\tsystemLog.setLogContent(actionName);\n\t\tsystemLog.setUrl(request.getRequestURL().toString());\n\t\tif(request.getParameterMap().size()>0) {\n\t    \tObjectMapper objectMapper = new ObjectMapper();\n\t    \ttry {\n\t\t\t\tsystemLog.setData(objectMapper.writeValueAsString(request.getParameterMap()));\n\t\t\t} catch (JsonProcessingException e) {\n\t\t\t}\n\t    }\n\t\tif(StringUtils.hasText(systemLog.getData())) {\n\t    \tsystemLog.setData(systemLog.getData() + \" \"+ binaryReader(request));\n\t    }else {\n\t    \tsystemLog.setData( binaryReader(request));\n\t    }\n\t\tthis.save(systemLog);\n\t}\n\t\n\t\n\tprivate String binaryReader(HttpServletRequest request) {\n\t\t\n\t\ttry {\n\t\t\tStringWriter writer = new StringWriter();\n\t\t\tIOUtils.copy(request.getInputStream(), writer, StandardCharsets.UTF_8.name());\n\t\t\tString str = writer.toString();\n\t\t\treturn str;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn \"\";\n\t\t\n\t}\n\t@Override\n\tpublic void log(String actionName) {\n\t\tServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();\n\t    HttpServletRequest request = servletRequestAttributes.getRequest();\n\t\tAdminUser user = (AdminUser) currentUser.getCurrentUser();\n\t\tif(Objects.isNull(user)) {\n\t\t\treturn;\n\t\t}\n\t\tList<Role> list = RoleService.findByUserId1(user.getId());\n\t\tSystemLog systemLog = new SystemLog();\n\t\tfor(Role role : list ) {\n\t\t\tif(Objects.equals(role.getIsDefault(), true)) {\n\t\t\t\tsystemLog.setRoleCode(role.getCode());\n\t\t\t\tsystemLog.setRoleName(role.getName());\n\t\t\t\tsystemLog.setRoleId(role.getId());\n\t\t\t}\n\t\t}\n\t\tsystemLog.setAccount(user.getAccount());\n\t\tsystemLog.setUserId(user==null?\"\":user.getId());\n\t\tsystemLog.setUserName(user==null?\"\":user.getName());\n\t\tsystemLog.setLogContent(actionName);\n\t\tsystemLog.setUrl(request.getRequestURL().toString());\n\t\tthis.save(systemLog);\n\t}\n\t\n"]]}
{"hexsha": "aaa23ecc9abcacf254e5ba09df157d118aa7a1fa", "ext": "java", "lang": "Java", "content": "public class ListHelper {\n    public static final Random rand = new Random();\n\n    public static <T> T getRandomFromList(List<T> list) {\n        return getRandomFromList(list, rand);\n    }\n\n    public static <T> T getRandomFromList(List<T> list, Random rand) {\n        final int size = list.size();\n        Preconditions.checkArgument(size > 0, \"Can't select from empty list\");\n        if (size == 0) return null;\n        if (size == 1) return list.get(0);\n        int randomIndex = rand.nextInt(list.size());\n        return list.get(randomIndex);\n    }\n}", "class_id": 0, "repo": "WesterosCraft/StatuesMod", "file": "src/main/java/com/shynieke/statues/util/ListHelper.java", "last_update_at": "2020-11-24T17:26:01+00:00", "question_id": "aaa23ecc9abcacf254e5ba09df157d118aa7a1fa", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ListHelper {\n    public static final Random rand = new Random();\n    public static <T> T getRandomFromList(List<T> list) {\n        return getRandomFromList(list, rand);\n    }\n    public static <T> T getRandomFromList(List<T> list, Random rand) {\n        final int size = list.size();\n        Preconditions.checkArgument(size > 0, \"Can't select from empty list\");\n        if (size == 0) return null;\n        if (size == 1) return list.get(0);\n        int randomIndex = rand.nextInt(list.size());\n        return list.get(randomIndex);\n    }\n"]]}
{"hexsha": "66518c0cfca862ae80cc8bf538581eda13ca9ea9", "ext": "java", "lang": "Java", "content": "public class Leetcode0891 {\n    public int sumSubseqWidths(int[] A) {\n        int mod = 10_0000_0007;\n        Arrays.sort(A);\n        long res = 0;\n        int[] pow = new int[A.length];\n        pow[0] = 1;\n        for (int i = 1; i < A.length; i++) pow[i] = pow[i - 1] * 2 % mod;\n        for (int i = 0; i < A.length; i++) {\n            res += 1L * pow[i] * A[i];\n            res -= 1L * pow[A.length - 1 - i] * A[i];\n            res %= mod;\n        }\n        return (int) res;\n    }\n}", "class_id": 0, "repo": "dezhonger/LeetCode", "file": "Leetcode0891.java", "last_update_at": "2020-06-28T06:29:05+00:00", "question_id": "66518c0cfca862ae80cc8bf538581eda13ca9ea9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Leetcode0891 {\n    public int sumSubseqWidths(int[] A) {\n        int mod = 10_0000_0007;\n        Arrays.sort(A);\n        long res = 0;\n        int[] pow = new int[A.length];\n        pow[0] = 1;\n        for (int i = 1; i < A.length; i++) pow[i] = pow[i - 1] * 2 % mod;\n        for (int i = 0; i < A.length; i++) {\n            res += 1L * pow[i] * A[i];\n            res -= 1L * pow[A.length - 1 - i] * A[i];\n            res %= mod;\n        }\n        return (int) res;\n    }\n"]]}
{"hexsha": "c3776ac551d90de905978e802ee2cd6280d479b5", "ext": "java", "lang": "Java", "content": "public class hm {\n\tprivate class hmNode {\n\t\tInteger key;\n\t\tString value;\n\n\t\tpublic hmNode(Integer key, String value) {\n\t\t\tthis.key = key;\n\t\t\tthis.value = value;\n\t\t\t// TODO Auto-generated constructor stub\n\t\t}\n\t}\n\n\tpublic LinkedList<hmNode> buckets[];\n\tpublic int size;\n\n\tpublic hm() {\n\t\tsize = 0;\n\t\tinitBuckets(4);\n\t\t// TODO Auto-generated constructor stub\n\t}\n\n\tprivate void initBuckets(int nob) {\n\t\tbuckets = new LinkedList[nob];\n\t\tfor (int i = 0; i < buckets.length; i++) {\n\t\t\tbuckets[i] = new LinkedList<>();\n\t\t}\n\n\t}\n\n\tpublic void put(Integer key, String value) {\n\t\tint bi = hashFunc(key);\n\t\tint di = findWithinBucket(bi, key);\n\t\tLinkedList<hmNode> bucket = buckets[bi];\n\t\tif (di == -1) {\n\t\t\thmNode newnode = new hmNode(key, value);\n\t\t\tbucket.addLast(newnode);\n\t\t\tsize++;\n\n\t\t} else {\n\t\t\tbucket.get(di).value = value;\n\n\t\t}\n\t\tdouble lambda = (1.0) * this.size / buckets.length;\n\t\tif (lambda > 2.0) {\n\t\t\trehash();\n\t\t}\n\t}\n\n\tpublic boolean containsKey(Integer key) {\n\t\tint bi = hashFunc(key);\n\t\tint di = findWithinBucket(bi, key);\n\t\tif (di == -1) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\n\t}\n\n\tpublic String get(Integer key) {\n\t\tint bi = hashFunc(key);\n\t\tint di = findWithinBucket(bi, key);\n\t\tif (di == -1) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn buckets[bi].get(di).value;\n\t\t}\n\t}\n\n\tpublic String remove(Integer key) {\n\t\tint bi = hashFunc(key);\n\t\tLinkedList<hmNode> bucket = buckets[bi];\n\t\tfor (int i = 0; i < bucket.size(); i++) {\n\t\t\thmNode node = bucket.get(i);\n\t\t\tif (node.key == key) {\n\t\t\t\tString ret = node.value;\n\t\t\t\tbucket.remove(i);\n\t\t\t\tsize--;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic void rehash() {\n\n\t\tLinkedList<hmNode>[] oa = buckets;\n\t\tbuckets = (LinkedList<hmNode>[]) new LinkedList[2 * oa.length];\n\t\tfor (int i = 0; i < buckets.length; i++) {\n\t\t\tbuckets[i] = new LinkedList<>();\n\t\t}\n\t\tthis.size = 0;\n\t\tfor (int i = 0; i < oa.length; i++) {\n\n\t\t\tfor (int j = 0; j < oa[i].size(); j++) {\n\t\t\t\thmNode node = oa[i].get(j);\n\t\t\t\tthis.put(node.key, node.value);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic void display() {\n\t\tfor (int i = 0; i < buckets.length; i++) {\n\t\t\tSystem.out.print(\"Bucket\" + i + \"->\");\n\t\t\tLinkedList<hmNode> bucket = buckets[i];\n\t\t\tfor (int j = 0; j < bucket.size(); j++) {\n\t\t\t\tSystem.out.print(bucket.get(j).key + \" \" + bucket.get(j).value + \",  \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tprivate int hashFunc(int key) {\n\t\tint hc = key;\n\t\tint bi = Math.abs(hc) % buckets.length;\n\t\treturn bi;\n\t}\n\n\tprivate int findWithinBucket(int bi, int key) {\n\t\tfor (int di = 0; di < buckets[bi].size(); di++) {\n\t\t\thmNode node = buckets[bi].get(di);\n\t\t\tif (node.key.equals(key)) {\n\t\t\t\treturn di;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\thm map = new hm();\n\t\tmap.put(0, \"i\");\n\n\t\tmap.put(1, \"c\");\n\t\tmap.put(2, \"d\");\n\t\tmap.put(3, \"a\");\n\t\tmap.put(4, \"b\");\n\t\tmap.put(5, \"n\");\n\t\tmap.put(6, \"m\");\n\t\tmap.put(7, \"x\");\n\n\t\tmap.display();\n\t\tSystem.out.println();\n\t\tmap.put(8, \"z\");\n\t\tmap.put(15, \"w\");\n\t\tmap.display();\n\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}", "class_id": 0, "repo": "Anshul1601/LeetCode-Solutions", "file": "hashmap.java", "last_update_at": "2020-10-24T15:45:57+00:00", "question_id": "c3776ac551d90de905978e802ee2cd6280d479b5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class hm {\n\tprivate class hmNode {\n\t\tInteger key;\n\t\tString value;\n\t\tpublic hmNode(Integer key, String value) {\n\t\t\tthis.key = key;\n\t\t\tthis.value = value;\n\t\t\t// TODO Auto-generated constructor stub\n\t\t}\n\t}\n\tpublic LinkedList<hmNode> buckets[];\n\tpublic int size;\n\tpublic hm() {\n\t\tsize = 0;\n\t\tinitBuckets(4);\n\t\t// TODO Auto-generated constructor stub\n\t}\n\tprivate void initBuckets(int nob) {\n\t\tbuckets = new LinkedList[nob];\n\t\tfor (int i = 0; i < buckets.length; i++) {\n\t\t\tbuckets[i] = new LinkedList<>();\n\t\t}\n\t}\n\tpublic void put(Integer key, String value) {\n\t\tint bi = hashFunc(key);\n\t\tint di = findWithinBucket(bi, key);\n\t\tLinkedList<hmNode> bucket = buckets[bi];\n\t\tif (di == -1) {\n\t\t\thmNode newnode = new hmNode(key, value);\n\t\t\tbucket.addLast(newnode);\n\t\t\tsize++;\n\t\t} else {\n\t\t\tbucket.get(di).value = value;\n\t\t}\n\t\tdouble lambda = (1.0) * this.size / buckets.length;\n\t\tif (lambda > 2.0) {\n\t\t\trehash();\n\t\t}\n\t}\n\tpublic boolean containsKey(Integer key) {\n\t\tint bi = hashFunc(key);\n\t\tint di = findWithinBucket(bi, key);\n\t\tif (di == -1) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\tpublic String get(Integer key) {\n\t\tint bi = hashFunc(key);\n\t\tint di = findWithinBucket(bi, key);\n\t\tif (di == -1) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn buckets[bi].get(di).value;\n\t\t}\n\t}\n\tpublic String remove(Integer key) {\n\t\tint bi = hashFunc(key);\n\t\tLinkedList<hmNode> bucket = buckets[bi];\n\t\tfor (int i = 0; i < bucket.size(); i++) {\n\t\t\thmNode node = bucket.get(i);\n\t\t\tif (node.key == key) {\n\t\t\t\tString ret = node.value;\n\t\t\t\tbucket.remove(i);\n\t\t\t\tsize--;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\tpublic void rehash() {\n\t\tLinkedList<hmNode>[] oa = buckets;\n\t\tbuckets = (LinkedList<hmNode>[]) new LinkedList[2 * oa.length];\n\t\tfor (int i = 0; i < buckets.length; i++) {\n\t\t\tbuckets[i] = new LinkedList<>();\n\t\t}\n\t\tthis.size = 0;\n\t\tfor (int i = 0; i < oa.length; i++) {\n\t\t\tfor (int j = 0; j < oa[i].size(); j++) {\n\t\t\t\thmNode node = oa[i].get(j);\n\t\t\t\tthis.put(node.key, node.value);\n\t\t\t}\n\t\t}\n\t}\n\tpublic void display() {\n\t\tfor (int i = 0; i < buckets.length; i++) {\n\t\t\tSystem.out.print(\"Bucket\" + i + \"->\");\n\t\t\tLinkedList<hmNode> bucket = buckets[i];\n\t\t\tfor (int j = 0; j < bucket.size(); j++) {\n\t\t\t\tSystem.out.print(bucket.get(j).key + \" \" + bucket.get(j).value + \",  \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tprivate int hashFunc(int key) {\n\t\tint hc = key;\n\t\tint bi = Math.abs(hc) % buckets.length;\n\t\treturn bi;\n\t}\n\tprivate int findWithinBucket(int bi, int key) {\n\t\tfor (int di = 0; di < buckets[bi].size(); di++) {\n\t\t\thmNode node = buckets[bi].get(di);\n\t\t\tif (node.key.equals(key)) {\n\t\t\t\treturn di;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tpublic static void main(String[] args) {\n\t\thm map = new hm();\n\t\tmap.put(0, \"i\");\n\t\tmap.put(1, \"c\");\n\t\tmap.put(2, \"d\");\n\t\tmap.put(3, \"a\");\n\t\tmap.put(4, \"b\");\n\t\tmap.put(5, \"n\");\n\t\tmap.put(6, \"m\");\n\t\tmap.put(7, \"x\");\n\t\tmap.display();\n\t\tSystem.out.println();\n\t\tmap.put(8, \"z\");\n\t\tmap.put(15, \"w\");\n\t\tmap.display();\n\t\t// TODO Auto-generated method stub\n\t}\n"]]}
{"hexsha": "bca67ca38011d8655f7e8fd1f194db91efc352d6", "ext": "java", "lang": "Java", "content": "public class NameParserGBIFTimeoutTest {\n\n  @Test\n  public void timeoutLongNames() throws Exception {\n    final int timeout = 10;\n    final int extra = 250;\n\n    NameParser parser = new NameParserGBIF(timeout);\n    StopWatch watch = new StopWatch();\n    // warm up parser\n    try {\n      parser.parse(\"Abies\", Rank.GENUS);\n    } catch (UnparsableNameException ex) {\n      // too short on your machine? ignore\n    }\n\n    // this name takes 13993ms on a new macbook pro !!!\n    String name = \"Desmarestia ligulata subsp. muelleri (M.E.Ramirez, A.F.Peters, S.S.Y. Wong, A.H.Y. Ngan, Riggs, J.L.L. Teng, A.F.Peters, E.C.Yang, A.F.Peters, E.C.Yang & F.C.K\u00fcpper & van Reine, 2014) S.S.Y. Wong, A.H.Y. Ngan, Riggs, J.L.L. Teng, A.F.Peters, E.C.Yang, A.F.Peters, E.C.Yang, F.C.K\u00fcpper, van Reine, S.S.Y. Wong, A.H.Y. Ngan, Riggs, J.L.L. Teng, A.F.Peters, E.C.Yang, A.F.Peters, E.C.Yang, F.C.K\u00fcpper & van Reine, 2014\";\n    watch.start();\n    try {\n      parser.parse(name);\n      fail(\"Expected to be unparsable, but only took \" + watch.getTime() + \"ms\");\n\n    } catch (UnparsableNameException ex) {\n\n      final long duration = watch.getTime();\n      System.out.println(\"Parsing took \" + duration + \"ms\");\n\n      // make sure no further parser threads are running. Give the JVM a few milliseconds to interrupt the task\n      Thread.sleep(extra);\n\n      Set<Thread> threads = Thread.getAllStackTraces().keySet();\n      for (Thread t : threads) {\n        if (t.getName().startsWith(NameParserGBIF.THREAD_NAME)) {\n          System.out.println(t.getName() + \"  -->  \" + t.getState());\n          assertFalse(\"Running parser thread detected\", t.getState() == Thread.State.RUNNABLE);\n        }\n      }\n    }\n  }\n\n}", "class_id": 0, "repo": "charvolant/name-parser", "file": "name-parser/src/test/java/org/gbif/nameparser/NameParserGBIFTimeoutTest.java", "last_update_at": "2020-12-27T09:39:15+00:00", "question_id": "bca67ca38011d8655f7e8fd1f194db91efc352d6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NameParserGBIFTimeoutTest {\n  @Test\n  public void timeoutLongNames() throws Exception {\n    final int timeout = 10;\n    final int extra = 250;\n    NameParser parser = new NameParserGBIF(timeout);\n    StopWatch watch = new StopWatch();\n    // warm up parser\n    try {\n      parser.parse(\"Abies\", Rank.GENUS);\n    } catch (UnparsableNameException ex) {\n      // too short on your machine? ignore\n    }\n    // this name takes 13993ms on a new macbook pro !!!\n    String name = \"Desmarestia ligulata subsp. muelleri (M.E.Ramirez, A.F.Peters, S.S.Y. Wong, A.H.Y. Ngan, Riggs, J.L.L. Teng, A.F.Peters, E.C.Yang, A.F.Peters, E.C.Yang & F.C.K\u00fcpper & van Reine, 2014) S.S.Y. Wong, A.H.Y. Ngan, Riggs, J.L.L. Teng, A.F.Peters, E.C.Yang, A.F.Peters, E.C.Yang, F.C.K\u00fcpper, van Reine, S.S.Y. Wong, A.H.Y. Ngan, Riggs, J.L.L. Teng, A.F.Peters, E.C.Yang, A.F.Peters, E.C.Yang, F.C.K\u00fcpper & van Reine, 2014\";\n    watch.start();\n    try {\n      parser.parse(name);\n      fail(\"Expected to be unparsable, but only took \" + watch.getTime() + \"ms\");\n    } catch (UnparsableNameException ex) {\n      final long duration = watch.getTime();\n      System.out.println(\"Parsing took \" + duration + \"ms\");\n      // make sure no further parser threads are running. Give the JVM a few milliseconds to interrupt the task\n      Thread.sleep(extra);\n      Set<Thread> threads = Thread.getAllStackTraces().keySet();\n      for (Thread t : threads) {\n        if (t.getName().startsWith(NameParserGBIF.THREAD_NAME)) {\n          System.out.println(t.getName() + \"  -->  \" + t.getState());\n          assertFalse(\"Running parser thread detected\", t.getState() == Thread.State.RUNNABLE);\n        }\n      }\n    }\n  }\n"]]}
{"hexsha": "5b9af69ee2a0bce2b0285a267045a60efe1c8b06", "ext": "java", "lang": "Java", "content": "public class ProfileResultImpl implements ProfileResult {\n   private static final Logger LOGGER = LogManager.getLogger();\n   private static final ProfileLocationInfo EMPTY_INFO = new ProfileLocationInfo() {\n      public long getTotalTime() {\n         return 0L;\n      }\n\n      public long getVisitCount() {\n         return 0L;\n      }\n\n      public Object2LongMap<String> getCounts() {\n         return Object2LongMaps.emptyMap();\n      }\n   };\n   private static final Splitter SPLITTER = Splitter.on('\\u001e');\n   private static final Comparator<Entry<String, ProfileResultImpl.CounterInfo>> COMPARATOR = Entry.<String, ProfileResultImpl.CounterInfo>comparingByValue(Comparator.comparingLong((counterInfo) -> counterInfo.totalTime)).reversed();\n   private final Map<String, ? extends ProfileLocationInfo> locationInfos;\n   private final long startTime;\n   private final int startTick;\n   private final long endTime;\n   private final int endTick;\n   private final int tickDuration;\n\n   public ProfileResultImpl(Map<String, ? extends ProfileLocationInfo> locationInfos, long startTime, int startTick, long endTime, int endTick) {\n      this.locationInfos = locationInfos;\n      this.startTime = startTime;\n      this.startTick = startTick;\n      this.endTime = endTime;\n      this.endTick = endTick;\n      this.tickDuration = endTick - startTick;\n   }\n\n   private ProfileLocationInfo getInfo(String path) {\n      ProfileLocationInfo profileLocationInfo = this.locationInfos.get(path);\n      return profileLocationInfo != null ? profileLocationInfo : EMPTY_INFO;\n   }\n\n   public List<ProfilerTiming> getTimings(String parentPath) {\n      ProfileLocationInfo profileLocationInfo = this.getInfo(\"root\");\n      long l = profileLocationInfo.getTotalTime();\n      ProfileLocationInfo profileLocationInfo2 = this.getInfo(parentPath);\n      long m = profileLocationInfo2.getTotalTime();\n      long n = profileLocationInfo2.getVisitCount();\n      List<ProfilerTiming> list = Lists.newArrayList();\n      if (!parentPath.isEmpty()) {\n         parentPath = parentPath + '\\u001e';\n      }\n\n      long o = 0L;\n\n      for (String string2 : this.locationInfos.keySet()) {\n         if (isSubpath(parentPath, string2)) {\n            o += this.getInfo(string2).getTotalTime();\n         }\n      }\n\n      float f = (float)o;\n      if (o < m) {\n         o = m;\n      }\n\n      if (l < o) {\n         l = o;\n      }\n\n      for (String string3 : this.locationInfos.keySet()) {\n         if (isSubpath(parentPath, string3)) {\n            ProfileLocationInfo profileLocationInfo3 = this.getInfo(string3);\n            long p = profileLocationInfo3.getTotalTime();\n            double d = (double) p * 100.0D / (double) o;\n            double e = (double) p * 100.0D / (double) l;\n            String string4 = string3.substring(parentPath.length());\n            list.add(new ProfilerTiming(string4, d, e, profileLocationInfo3.getVisitCount()));\n         }\n      }\n\n      if ((float)o > f) {\n         list.add(new ProfilerTiming(\"unspecified\", (double)((float)o - f) * 100.0D / (double)o, (double)((float)o - f) * 100.0D / (double)l, n));\n      }\n\n      Collections.sort(list);\n      list.add(0, new ProfilerTiming(parentPath, 100.0D, (double)o * 100.0D / (double)l, n));\n      return list;\n   }\n\n   private static boolean isSubpath(String parent, String path) {\n      return path.length() > parent.length() && path.startsWith(parent) && path.indexOf(30, parent.length() + 1) < 0;\n   }\n\n   private Map<String, ProfileResultImpl.CounterInfo> setupCounters() {\n      Map<String, ProfileResultImpl.CounterInfo> map = Maps.newTreeMap();\n      this.locationInfos.forEach((string, profileLocationInfo) -> {\n         Object2LongMap<String> object2LongMap = profileLocationInfo.getCounts();\n         if (!object2LongMap.isEmpty()) {\n            List<String> list = SPLITTER.splitToList(string);\n            object2LongMap.forEach((stringx, long_) -> map.computeIfAbsent(stringx, (string1) -> new CounterInfo()).add(list.iterator(), long_));\n         }\n\n      });\n      return map;\n   }\n\n   public long getStartTime() {\n      return this.startTime;\n   }\n\n   public int getStartTick() {\n      return this.startTick;\n   }\n\n   public long getEndTime() {\n      return this.endTime;\n   }\n\n   public int getEndTick() {\n      return this.endTick;\n   }\n\n   public boolean save(File file) {\n      //noinspection ResultOfMethodCallIgnored\n      file.getParentFile().mkdirs();\n      OutputStreamWriter writer = null;\n\n      try {\n         writer = new OutputStreamWriter(new FileOutputStream(file), StandardCharsets.UTF_8);\n         writer.write(this.asString(this.getTimeSpan(), this.getTickSpan()));\n         return true;\n      } catch (Throwable var8) {\n         LOGGER.error(\"Could not save profiler results to {}\", file, var8);\n      } finally {\n         IOUtils.closeQuietly(writer);\n      }\n\n      return false;\n   }\n\n   protected String asString(long timeSpan, int tickSpan) {\n      StringBuilder stringBuilder = new StringBuilder();\n      stringBuilder.append(\"---- Minecraft Profiler Results ----\\n\");\n      stringBuilder.append(\"// \");\n      stringBuilder.append(generateWittyComment());\n      stringBuilder.append(\"\\n\\n\");\n      stringBuilder.append(\"Version: \").append(ModID.MINECRAFT.getVersion()).append('\\n');\n      stringBuilder.append(\"Time span: \").append(timeSpan / 1000000L).append(\" ms\\n\");\n      stringBuilder.append(\"Tick span: \").append(tickSpan).append(\" ticks\\n\");\n      stringBuilder.append(\"// This is approximately \").append(String.format(Locale.ROOT, \"%.2f\", (float)tickSpan / ((float)timeSpan / 1.0E9F))).append(\" ticks per second. It should be \").append(20).append(\" ticks per second\\n\\n\");\n      stringBuilder.append(\"--- BEGIN PROFILE DUMP ---\\n\\n\");\n      this.appendTiming(0, \"root\", stringBuilder);\n      stringBuilder.append(\"--- END PROFILE DUMP ---\\n\\n\");\n      Map<String, ProfileResultImpl.CounterInfo> map = this.setupCounters();\n      if (!map.isEmpty()) {\n         stringBuilder.append(\"--- BEGIN COUNTER DUMP ---\\n\\n\");\n         this.appendCounterDump(map, stringBuilder, tickSpan);\n         stringBuilder.append(\"--- END COUNTER DUMP ---\\n\\n\");\n      }\n\n      return stringBuilder.toString();\n   }\n\n   private static StringBuilder indent(StringBuilder sb, int size) {\n      sb.append(String.format(\"[%02d] \", size));\n\n      for(int i = 0; i < size; ++i) {\n         sb.append(\"|   \");\n      }\n\n      return sb;\n   }\n\n   private void appendTiming(int level, String name, StringBuilder sb) {\n      List<ProfilerTiming> list = this.getTimings(name);\n      Object2LongMap<String> object2LongMap = ObjectUtils.firstNonNull(this.locationInfos.get(name), EMPTY_INFO).getCounts();\n      object2LongMap.forEach((string, long_) -> indent(sb, level).append('#').append(string).append(' ').append(long_).append('/').append(long_ / (long)this.tickDuration).append('\\n'));\n      if (list.size() >= 3) {\n         for(int i = 1; i < list.size(); ++i) {\n            ProfilerTiming profilerTiming = list.get(i);\n            indent(sb, level).append(profilerTiming.name).append('(').append(profilerTiming.visitCount).append('/').append(String.format(Locale.ROOT, \"%.0f\", (float)profilerTiming.visitCount / (float)this.tickDuration)).append(')').append(\" - \").append(String.format(Locale.ROOT, \"%.2f\", profilerTiming.parentSectionUsagePercentage)).append(\"%/\").append(String.format(Locale.ROOT, \"%.2f\", profilerTiming.totalUsagePercentage)).append(\"%\\n\");\n            if (!\"unspecified\".equals(profilerTiming.name)) {\n               try {\n                  this.appendTiming(level + 1, name + '\\u001e' + profilerTiming.name, sb);\n               } catch (Exception var9) {\n                  sb.append(\"[[ EXCEPTION \").append(var9).append(\" ]]\");\n               }\n            }\n         }\n\n      }\n   }\n\n   private void appendCounter(int depth, String name, ProfileResultImpl.CounterInfo info, int tickSpan, StringBuilder sb) {\n      indent(sb, depth).append(name).append(\" total:\").append(info.selfTime).append('/').append(info.totalTime).append(\" average: \").append(info.selfTime / (long)tickSpan).append('/').append(info.totalTime / (long)tickSpan).append('\\n');\n      info.subCounters.entrySet().stream().sorted(COMPARATOR).forEach((entry) -> this.appendCounter(depth + 1, entry.getKey(), entry.getValue(), tickSpan, sb));\n   }\n\n   private void appendCounterDump(Map<String, ProfileResultImpl.CounterInfo> counters, StringBuilder sb, int tickSpan) {\n      counters.forEach((string, counterInfo) -> {\n         sb.append(\"-- Counter: \").append(string).append(\" --\\n\");\n         this.appendCounter(0, \"root\", counterInfo.subCounters.get(\"root\"), tickSpan, sb);\n         sb.append(\"\\n\\n\");\n      });\n   }\n\n   private static String generateWittyComment() {\n      String[] strings = new String[]{\"Shiny numbers!\", \"Am I not running fast enough? :(\", \"I'm working as hard as I can!\", \"Will I ever be good enough for you? :(\", \"Speedy. Zoooooom!\", \"Hello world\", \"40% better than a crash report.\", \"Now with extra numbers\", \"Now with less numbers\", \"Now with the same numbers\", \"You should add flames to things, it makes them go faster!\", \"Do you feel the need for... optimization?\", \"*cracks redstone whip*\", \"Maybe if you treated it better then it'll have more motivation to work faster! Poor server.\"};\n\n      try {\n         return strings[(int)(Util.getMeasuringTimeNano() % (long)strings.length)];\n      } catch (Throwable var2) {\n         return \"Witty comment unavailable :(\";\n      }\n   }\n\n   public int getTickSpan() {\n      return this.tickDuration;\n   }\n\n   static class CounterInfo {\n      private long selfTime;\n      private long totalTime;\n      private final Map<String, ProfileResultImpl.CounterInfo> subCounters;\n\n      private CounterInfo() {\n         this.subCounters = Maps.newHashMap();\n      }\n\n      public void add(Iterator<String> pathIterator, long time) {\n         this.totalTime += time;\n         if (!pathIterator.hasNext()) {\n            this.selfTime += time;\n         } else {\n            this.subCounters.computeIfAbsent(pathIterator.next(), (string) -> new CounterInfo()).add(pathIterator, time);\n         }\n\n      }\n   }\n}", "class_id": 0, "repo": "ModifcationStations/StationLoader", "file": "station-api-base/src/main/java/net/modificationstation/stationapi/api/util/profiler/ProfileResultImpl.java", "last_update_at": "2020-12-13T20:09:36+00:00", "question_id": "5b9af69ee2a0bce2b0285a267045a60efe1c8b06", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ProfileResultImpl implements ProfileResult {\n   private static final Logger LOGGER = LogManager.getLogger();\n   private static final ProfileLocationInfo EMPTY_INFO = new ProfileLocationInfo() {\n      public long getTotalTime() {\n         return 0L;\n      }\n      public long getVisitCount() {\n         return 0L;\n      }\n      public Object2LongMap<String> getCounts() {\n         return Object2LongMaps.emptyMap();\n      }\n   };\n   private static final Splitter SPLITTER = Splitter.on('\\u001e');\n   private static final Comparator<Entry<String, ProfileResultImpl.CounterInfo>> COMPARATOR = Entry.<String, ProfileResultImpl.CounterInfo>comparingByValue(Comparator.comparingLong((counterInfo) -> counterInfo.totalTime)).reversed();\n   private final Map<String, ? extends ProfileLocationInfo> locationInfos;\n   private final long startTime;\n   private final int startTick;\n   private final long endTime;\n   private final int endTick;\n   private final int tickDuration;\n   public ProfileResultImpl(Map<String, ? extends ProfileLocationInfo> locationInfos, long startTime, int startTick, long endTime, int endTick) {\n      this.locationInfos = locationInfos;\n      this.startTime = startTime;\n      this.startTick = startTick;\n      this.endTime = endTime;\n      this.endTick = endTick;\n      this.tickDuration = endTick - startTick;\n   }\n   private ProfileLocationInfo getInfo(String path) {\n      ProfileLocationInfo profileLocationInfo = this.locationInfos.get(path);\n      return profileLocationInfo != null ? profileLocationInfo : EMPTY_INFO;\n   }\n   public List<ProfilerTiming> getTimings(String parentPath) {\n      ProfileLocationInfo profileLocationInfo = this.getInfo(\"root\");\n      long l = profileLocationInfo.getTotalTime();\n      ProfileLocationInfo profileLocationInfo2 = this.getInfo(parentPath);\n      long m = profileLocationInfo2.getTotalTime();\n      long n = profileLocationInfo2.getVisitCount();\n      List<ProfilerTiming> list = Lists.newArrayList();\n      if (!parentPath.isEmpty()) {\n         parentPath = parentPath + '\\u001e';\n      }\n      long o = 0L;\n      for (String string2 : this.locationInfos.keySet()) {\n         if (isSubpath(parentPath, string2)) {\n            o += this.getInfo(string2).getTotalTime();\n         }\n      }\n      float f = (float)o;\n      if (o < m) {\n         o = m;\n      }\n      if (l < o) {\n         l = o;\n      }\n      for (String string3 : this.locationInfos.keySet()) {\n         if (isSubpath(parentPath, string3)) {\n            ProfileLocationInfo profileLocationInfo3 = this.getInfo(string3);\n            long p = profileLocationInfo3.getTotalTime();\n            double d = (double) p * 100.0D / (double) o;\n            double e = (double) p * 100.0D / (double) l;\n            String string4 = string3.substring(parentPath.length());\n            list.add(new ProfilerTiming(string4, d, e, profileLocationInfo3.getVisitCount()));\n         }\n      }\n      if ((float)o > f) {\n         list.add(new ProfilerTiming(\"unspecified\", (double)((float)o - f) * 100.0D / (double)o, (double)((float)o - f) * 100.0D / (double)l, n));\n      }\n      Collections.sort(list);\n      list.add(0, new ProfilerTiming(parentPath, 100.0D, (double)o * 100.0D / (double)l, n));\n      return list;\n   }\n   private static boolean isSubpath(String parent, String path) {\n      return path.length() > parent.length() && path.startsWith(parent) && path.indexOf(30, parent.length() + 1) < 0;\n   }\n   private Map<String, ProfileResultImpl.CounterInfo> setupCounters() {\n      Map<String, ProfileResultImpl.CounterInfo> map = Maps.newTreeMap();\n      this.locationInfos.forEach((string, profileLocationInfo) -> {\n         Object2LongMap<String> object2LongMap = profileLocationInfo.getCounts();\n         if (!object2LongMap.isEmpty()) {\n            List<String> list = SPLITTER.splitToList(string);\n            object2LongMap.forEach((stringx, long_) -> map.computeIfAbsent(stringx, (string1) -> new CounterInfo()).add(list.iterator(), long_));\n         }\n      });\n      return map;\n   }\n   public long getStartTime() {\n      return this.startTime;\n   }\n   public int getStartTick() {\n      return this.startTick;\n   }\n   public long getEndTime() {\n      return this.endTime;\n   }\n   public int getEndTick() {\n      return this.endTick;\n   }\n   public boolean save(File file) {\n      //noinspection ResultOfMethodCallIgnored\n      file.getParentFile().mkdirs();\n      OutputStreamWriter writer = null;\n      try {\n         writer = new OutputStreamWriter(new FileOutputStream(file), StandardCharsets.UTF_8);\n         writer.write(this.asString(this.getTimeSpan(), this.getTickSpan()));\n         return true;\n      } catch (Throwable var8) {\n         LOGGER.error(\"Could not save profiler results to {}\", file, var8);\n      } finally {\n         IOUtils.closeQuietly(writer);\n      }\n      return false;\n   }\n   protected String asString(long timeSpan, int tickSpan) {\n      StringBuilder stringBuilder = new StringBuilder();\n      stringBuilder.append(\"---- Minecraft Profiler Results ----\\n\");\n      stringBuilder.append(\"// \");\n      stringBuilder.append(generateWittyComment());\n      stringBuilder.append(\"\\n\\n\");\n      stringBuilder.append(\"Version: \").append(ModID.MINECRAFT.getVersion()).append('\\n');\n      stringBuilder.append(\"Time span: \").append(timeSpan / 1000000L).append(\" ms\\n\");\n      stringBuilder.append(\"Tick span: \").append(tickSpan).append(\" ticks\\n\");\n      stringBuilder.append(\"// This is approximately \").append(String.format(Locale.ROOT, \"%.2f\", (float)tickSpan / ((float)timeSpan / 1.0E9F))).append(\" ticks per second. It should be \").append(20).append(\" ticks per second\\n\\n\");\n      stringBuilder.append(\"--- BEGIN PROFILE DUMP ---\\n\\n\");\n      this.appendTiming(0, \"root\", stringBuilder);\n      stringBuilder.append(\"--- END PROFILE DUMP ---\\n\\n\");\n      Map<String, ProfileResultImpl.CounterInfo> map = this.setupCounters();\n      if (!map.isEmpty()) {\n         stringBuilder.append(\"--- BEGIN COUNTER DUMP ---\\n\\n\");\n         this.appendCounterDump(map, stringBuilder, tickSpan);\n         stringBuilder.append(\"--- END COUNTER DUMP ---\\n\\n\");\n      }\n      return stringBuilder.toString();\n   }\n   private static StringBuilder indent(StringBuilder sb, int size) {\n      sb.append(String.format(\"[%02d] \", size));\n      for(int i = 0; i < size; ++i) {\n         sb.append(\"|   \");\n      }\n      return sb;\n   }\n   private void appendTiming(int level, String name, StringBuilder sb) {\n      List<ProfilerTiming> list = this.getTimings(name);\n      Object2LongMap<String> object2LongMap = ObjectUtils.firstNonNull(this.locationInfos.get(name), EMPTY_INFO).getCounts();\n      object2LongMap.forEach((string, long_) -> indent(sb, level).append('#').append(string).append(' ').append(long_).append('/').append(long_ / (long)this.tickDuration).append('\\n'));\n      if (list.size() >= 3) {\n         for(int i = 1; i < list.size(); ++i) {\n            ProfilerTiming profilerTiming = list.get(i);\n            indent(sb, level).append(profilerTiming.name).append('(').append(profilerTiming.visitCount).append('/').append(String.format(Locale.ROOT, \"%.0f\", (float)profilerTiming.visitCount / (float)this.tickDuration)).append(')').append(\" - \").append(String.format(Locale.ROOT, \"%.2f\", profilerTiming.parentSectionUsagePercentage)).append(\"%/\").append(String.format(Locale.ROOT, \"%.2f\", profilerTiming.totalUsagePercentage)).append(\"%\\n\");\n            if (!\"unspecified\".equals(profilerTiming.name)) {\n               try {\n                  this.appendTiming(level + 1, name + '\\u001e' + profilerTiming.name, sb);\n               } catch (Exception var9) {\n                  sb.append(\"[[ EXCEPTION \").append(var9).append(\" ]]\");\n               }\n            }\n         }\n      }\n   }\n   private void appendCounter(int depth, String name, ProfileResultImpl.CounterInfo info, int tickSpan, StringBuilder sb) {\n      indent(sb, depth).append(name).append(\" total:\").append(info.selfTime).append('/').append(info.totalTime).append(\" average: \").append(info.selfTime / (long)tickSpan).append('/').append(info.totalTime / (long)tickSpan).append('\\n');\n      info.subCounters.entrySet().stream().sorted(COMPARATOR).forEach((entry) -> this.appendCounter(depth + 1, entry.getKey(), entry.getValue(), tickSpan, sb));\n   }\n   private void appendCounterDump(Map<String, ProfileResultImpl.CounterInfo> counters, StringBuilder sb, int tickSpan) {\n      counters.forEach((string, counterInfo) -> {\n         sb.append(\"-- Counter: \").append(string).append(\" --\\n\");\n         this.appendCounter(0, \"root\", counterInfo.subCounters.get(\"root\"), tickSpan, sb);\n         sb.append(\"\\n\\n\");\n      });\n   }\n   private static String generateWittyComment() {\n      String[] strings = new String[]{\"Shiny numbers!\", \"Am I not running fast enough? :(\", \"I'm working as hard as I can!\", \"Will I ever be good enough for you? :(\", \"Speedy. Zoooooom!\", \"Hello world\", \"40% better than a crash report.\", \"Now with extra numbers\", \"Now with less numbers\", \"Now with the same numbers\", \"You should add flames to things, it makes them go faster!\", \"Do you feel the need for... optimization?\", \"*cracks redstone whip*\", \"Maybe if you treated it better then it'll have more motivation to work faster! Poor server.\"};\n      try {\n         return strings[(int)(Util.getMeasuringTimeNano() % (long)strings.length)];\n      } catch (Throwable var2) {\n         return \"Witty comment unavailable :(\";\n      }\n   }\n   public int getTickSpan() {\n      return this.tickDuration;\n   }\n   static class CounterInfo {\n      private long selfTime;\n      private long totalTime;\n      private final Map<String, ProfileResultImpl.CounterInfo> subCounters;\n      private CounterInfo() {\n         this.subCounters = Maps.newHashMap();\n      }\n      public void add(Iterator<String> pathIterator, long time) {\n         this.totalTime += time;\n         if (!pathIterator.hasNext()) {\n            this.selfTime += time;\n         } else {\n            this.subCounters.computeIfAbsent(pathIterator.next(), (string) -> new CounterInfo()).add(pathIterator, time);\n         }\n      }\n   }\n"]]}
{"hexsha": "5f1b4f49ce00715b49c9199388cde8ea63ceda40", "ext": "java", "lang": "Java", "content": "public class CommandRunner {\n\n  // For the moment one pool for all except\n  public static ExecutorService executorService = new ThreadPoolExecutor(0,\n      FlowConfiguration.getIntConfig(commonThreadPoolMaxSize), 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());\n  public static ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);\n\n  public static ExecutorService getExecutorService() {\n    return executorService;\n  }\n\n  public static <T> Future<T> submit(Runnable runnable) {\n    return (Future<T>) getExecutorService().submit(runnable);\n  }\n\n  public static <T> Future<T> submit(Callable callable) {\n    return (Future<T>) getExecutorService().submit(callable);\n  }\n\n  public static ScheduledFuture scheduleFuture(Runnable runnable, long timeout) {\n    ScheduledFuture scheduledFuture = scheduledExecutorService.schedule(runnable, timeout, TimeUnit.MILLISECONDS);\n    return scheduledFuture;\n  }\n\n  public static Object run(FlowDefinition flowDefinition, Object[] args) throws Exception {\n    FlowCommand flowCommand = flowDefinition.getStartCommand();\n    CommandContext commandContext = new CommandContext();\n    commandContext.setArguments(args);\n    commandContext.setFlowDefinition(flowDefinition);\n    flowCommand.run(commandContext);\n\n    return commandContext.getResult();\n  }\n}", "class_id": 0, "repo": "floref/core", "file": "core/src/main/java/org/floref/core/flow/run/CommandRunner.java", "last_update_at": "2020-04-02T14:14:59+00:00", "question_id": "5f1b4f49ce00715b49c9199388cde8ea63ceda40", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CommandRunner {\n  // For the moment one pool for all except\n  public static ExecutorService executorService = new ThreadPoolExecutor(0,\n      FlowConfiguration.getIntConfig(commonThreadPoolMaxSize), 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());\n  public static ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);\n  public static ExecutorService getExecutorService() {\n    return executorService;\n  }\n  public static <T> Future<T> submit(Runnable runnable) {\n    return (Future<T>) getExecutorService().submit(runnable);\n  }\n  public static <T> Future<T> submit(Callable callable) {\n    return (Future<T>) getExecutorService().submit(callable);\n  }\n  public static ScheduledFuture scheduleFuture(Runnable runnable, long timeout) {\n    ScheduledFuture scheduledFuture = scheduledExecutorService.schedule(runnable, timeout, TimeUnit.MILLISECONDS);\n    return scheduledFuture;\n  }\n  public static Object run(FlowDefinition flowDefinition, Object[] args) throws Exception {\n    FlowCommand flowCommand = flowDefinition.getStartCommand();\n    CommandContext commandContext = new CommandContext();\n    commandContext.setArguments(args);\n    commandContext.setFlowDefinition(flowDefinition);\n    flowCommand.run(commandContext);\n    return commandContext.getResult();\n  }\n"]]}
{"hexsha": "aaba759feb1e3e6b78ec00820e3f798d2834bee1", "ext": "java", "lang": "Java", "content": "public class BuildBase64 extends DataProcessorBase<xBase64> {\n    @Override\n    public Variable build(xBase64 item, IDataProcessorBuilder builder) {\n        Variable input = queryVariableOrConstant(item.input, TheStream.getType());\n        Variable output = createUserVariable(xString.inst.getType(), item.name);\n        builder.base64(output, input);\n        return output;\n    }\n\n    @Override\n    public VariableType returnType(xBase64 item) {\n        return xString.inst.getType();\n    }\n\n    @Override\n    public String resultVariableName(xBase64 item) {\n        return item.name;\n    }\n}", "class_id": 0, "repo": "macomfan/cei", "file": "producer/src/main/java/cn/ma/cei/generator/dataprocessor/BuildBase64.java", "last_update_at": "2020-12-31T02:36:45+00:00", "question_id": "aaba759feb1e3e6b78ec00820e3f798d2834bee1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BuildBase64 extends DataProcessorBase<xBase64> {\n    @Override\n    public Variable build(xBase64 item, IDataProcessorBuilder builder) {\n        Variable input = queryVariableOrConstant(item.input, TheStream.getType());\n        Variable output = createUserVariable(xString.inst.getType(), item.name);\n        builder.base64(output, input);\n        return output;\n    }\n    @Override\n    public VariableType returnType(xBase64 item) {\n        return xString.inst.getType();\n    }\n    @Override\n    public String resultVariableName(xBase64 item) {\n        return item.name;\n    }\n"]]}
{"hexsha": "ddd1d15f6c3e27ca5b8859784df6a16d1c4a1cde", "ext": "java", "lang": "Java", "content": "public class RotorCtlServiceTest {\n    private Context testCtx;\n\n    @Test\n    public void hasCorrectStates() {\n        assert (RotorCtlService.State.valueOf(\"MANUAL\") != null);\n        assert (RotorCtlService.State.valueOf(\"AUTONOMOUS\") != null);\n        assert (RotorCtlService.State.valueOf(\"HOMED\") != null);\n    }\n\n    @Test\n    public void transHomedToMan() {\n        RotorCtlService rotorCtlService = new RotorCtlService(null);\n        RotorCtlService.State initialState = rotorCtlService.getRotorState();\n        assertEquals(initialState, RotorCtlService.State.HOMED);\n\n        rotorCtlService.setState(RotorCtlService.State.MANUAL);\n        assertEquals(rotorCtlService.getRotorState(), RotorCtlService.State.MANUAL);\n    }\n\n    @Test\n    public void transHomedToAuto() {\n        RotorCtlService rotorCtlService = new RotorCtlService(null);\n        assertEquals(rotorCtlService.getRotorState(), RotorCtlService.State.HOMED);\n\n        rotorCtlService.setState(RotorCtlService.State.AUTONOMOUS);\n        assertEquals(rotorCtlService.getRotorState(), RotorCtlService.State.AUTONOMOUS);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void transManToAuto() {\n        RotorCtlService rotorCtlService = new RotorCtlService(null);\n        rotorCtlService.setState(RotorCtlService.State.MANUAL);\n        rotorCtlService.setState(RotorCtlService.State.AUTONOMOUS);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void transAutoToMan() {\n        RotorCtlService rotorCtlService = new RotorCtlService(null);\n        rotorCtlService.setState(RotorCtlService.State.AUTONOMOUS);\n        rotorCtlService.setState(RotorCtlService.State.MANUAL);\n    }\n\n    @Test\n    public void verifyImmutable() {\n        RotorCtlService rotorCtlService = new RotorCtlService(null);\n        RotorCtlService.State initialState = rotorCtlService.getRotorState();\n        initialState = RotorCtlService.State.AUTONOMOUS;\n        assertEquals(rotorCtlService.getRotorState(), RotorCtlService.State.HOMED);\n    }\n}", "class_id": 0, "repo": "stuartsoft/rotor-v1", "file": "app/src/test/java/ai/rotor/rotorvehicle/RotorCtlServiceTest.java", "last_update_at": "2020-06-02T04:21:10+00:00", "question_id": "ddd1d15f6c3e27ca5b8859784df6a16d1c4a1cde", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RotorCtlServiceTest {\n    private Context testCtx;\n    @Test\n    public void hasCorrectStates() {\n        assert (RotorCtlService.State.valueOf(\"MANUAL\") != null);\n        assert (RotorCtlService.State.valueOf(\"AUTONOMOUS\") != null);\n        assert (RotorCtlService.State.valueOf(\"HOMED\") != null);\n    }\n    @Test\n    public void transHomedToMan() {\n        RotorCtlService rotorCtlService = new RotorCtlService(null);\n        RotorCtlService.State initialState = rotorCtlService.getRotorState();\n        assertEquals(initialState, RotorCtlService.State.HOMED);\n        rotorCtlService.setState(RotorCtlService.State.MANUAL);\n        assertEquals(rotorCtlService.getRotorState(), RotorCtlService.State.MANUAL);\n    }\n    @Test\n    public void transHomedToAuto() {\n        RotorCtlService rotorCtlService = new RotorCtlService(null);\n        assertEquals(rotorCtlService.getRotorState(), RotorCtlService.State.HOMED);\n        rotorCtlService.setState(RotorCtlService.State.AUTONOMOUS);\n        assertEquals(rotorCtlService.getRotorState(), RotorCtlService.State.AUTONOMOUS);\n    }\n    @Test(expected = IllegalArgumentException.class)\n    public void transManToAuto() {\n        RotorCtlService rotorCtlService = new RotorCtlService(null);\n        rotorCtlService.setState(RotorCtlService.State.MANUAL);\n        rotorCtlService.setState(RotorCtlService.State.AUTONOMOUS);\n    }\n    @Test(expected = IllegalArgumentException.class)\n    public void transAutoToMan() {\n        RotorCtlService rotorCtlService = new RotorCtlService(null);\n        rotorCtlService.setState(RotorCtlService.State.AUTONOMOUS);\n        rotorCtlService.setState(RotorCtlService.State.MANUAL);\n    }\n    @Test\n    public void verifyImmutable() {\n        RotorCtlService rotorCtlService = new RotorCtlService(null);\n        RotorCtlService.State initialState = rotorCtlService.getRotorState();\n        initialState = RotorCtlService.State.AUTONOMOUS;\n        assertEquals(rotorCtlService.getRotorState(), RotorCtlService.State.HOMED);\n    }\n"]]}
{"hexsha": "36869995fdb5cf8a717814fa617956da8a7887a4", "ext": "java", "lang": "Java", "content": "@WebServlet(\"/bf_servlet\")\npublic class BellmanFordServlet extends HttpServlet {\n\tprivate static final long serialVersionUID = 102831973239L;\n\n    /**\n     * Default constructor. \n     */\n    public BellmanFordServlet() {\n        // TODO Auto-generated constructor stub\n    }\n\n\t/**\n\t * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)\n\t */\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\tint source= Integer.parseInt(request.getParameter(\"source\"));\n\t\tInteger[] destinations = {1023, 1013, 1028};\n\t\tFile file = new File(request.getServletContext().getRealPath(\"/data.js\"));\n\t\tHashMap<Integer, Node> nodes = importData(file);\n\t\tlong startTime = System.nanoTime();\n\t\tBellManFordShortestPath d = new BellManFordShortestPath();\n\t\td.setNodeList(nodes);\n\t\tfor(int index=0;index<destinations.length;index++) {\n\t\t\td.computeShortestPathsTo(index,nodes.get(destinations[index]));\n\t\t}\n\t\tlong estimatedTime = System.nanoTime() - startTime;\n\t\tArrayList<ArrayList<Integer>> pathList = new ArrayList<>();\n\t\tfor(int i=0; i<destinations.length;i++) {\n\t\t\tArrayList<Integer> tempList = new ArrayList<>();\n\t\t\ttempList = d.getShortestPathFrom(i,nodes.get(source));\n\t\t\tpathList.add(tempList);\n\t\t}\n\t\trequest.setAttribute(\"paths\", pathList);\n\t\trequest.setAttribute(\"elapsedTime\", estimatedTime);\n\t\tRequestDispatcher view = request.getRequestDispatcher(\"index.jsp\");\n\t\tview.forward(request, response);\t\t\t\n\t}\n\n\t/**\n\t * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)\n\t */\n\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t// TODO Auto-generated method stub\n\t\tdoGet(request, response);\n\t}\n\t\n\tprotected HashMap<Integer,Node> importData(File file) {\n\t\tString text = \"\";\n\t\ttry {\t\t\n\t\t\ttext = new String(Files.readAllBytes(Paths.get(file.getPath())));\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder(text);\n\t\tsb.deleteCharAt(text.length()-1);\n\t\tfor(int i=7; i>-1;i--) {\n\t\t\tsb.deleteCharAt(i);\n\t\t}\n\t\tString str = sb.toString();\n\t\tstr = str.replace(\" \\\\\", \"\");\n\t\tGson gson = new Gson();  \n\t\tNode[] arr = gson.fromJson(str, Node[].class);\n\t\tHashMap<Integer,Node> map = new HashMap<Integer,Node>();\n\t\tfor(int i=0; i<arr.length; i++) {\n\t\t\tmap.put(arr[i].getID(), arr[i]);\n\t\t}\n\t\treturn map;\n\t}\n\n}", "class_id": 0, "repo": "cdaou/shortest_route", "file": "Web Application/Bellman-Ford/src/org/BellmanFord/run/BellmanFordServlet.java", "last_update_at": "2020-07-07T22:49:44+00:00", "question_id": "36869995fdb5cf8a717814fa617956da8a7887a4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@WebServlet(\"/bf_servlet\")\npublic class BellmanFordServlet extends HttpServlet {\n\tprivate static final long serialVersionUID = 102831973239L;\n    /**\n     * Default constructor. \n     */\n    public BellmanFordServlet() {\n        // TODO Auto-generated constructor stub\n    }\n\t/**\n\t * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)\n\t */\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\tint source= Integer.parseInt(request.getParameter(\"source\"));\n\t\tInteger[] destinations = {1023, 1013, 1028};\n\t\tFile file = new File(request.getServletContext().getRealPath(\"/data.js\"));\n\t\tHashMap<Integer, Node> nodes = importData(file);\n\t\tlong startTime = System.nanoTime();\n\t\tBellManFordShortestPath d = new BellManFordShortestPath();\n\t\td.setNodeList(nodes);\n\t\tfor(int index=0;index<destinations.length;index++) {\n\t\t\td.computeShortestPathsTo(index,nodes.get(destinations[index]));\n\t\t}\n\t\tlong estimatedTime = System.nanoTime() - startTime;\n\t\tArrayList<ArrayList<Integer>> pathList = new ArrayList<>();\n\t\tfor(int i=0; i<destinations.length;i++) {\n\t\t\tArrayList<Integer> tempList = new ArrayList<>();\n\t\t\ttempList = d.getShortestPathFrom(i,nodes.get(source));\n\t\t\tpathList.add(tempList);\n\t\t}\n\t\trequest.setAttribute(\"paths\", pathList);\n\t\trequest.setAttribute(\"elapsedTime\", estimatedTime);\n\t\tRequestDispatcher view = request.getRequestDispatcher(\"index.jsp\");\n\t\tview.forward(request, response);\t\t\t\n\t}\n\t/**\n\t * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)\n\t */\n\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t// TODO Auto-generated method stub\n\t\tdoGet(request, response);\n\t}\n\t\n\tprotected HashMap<Integer,Node> importData(File file) {\n\t\tString text = \"\";\n\t\ttry {\t\t\n\t\t\ttext = new String(Files.readAllBytes(Paths.get(file.getPath())));\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder(text);\n\t\tsb.deleteCharAt(text.length()-1);\n\t\tfor(int i=7; i>-1;i--) {\n\t\t\tsb.deleteCharAt(i);\n\t\t}\n\t\tString str = sb.toString();\n\t\tstr = str.replace(\" \\\\\", \"\");\n\t\tGson gson = new Gson();  \n\t\tNode[] arr = gson.fromJson(str, Node[].class);\n\t\tHashMap<Integer,Node> map = new HashMap<Integer,Node>();\n\t\tfor(int i=0; i<arr.length; i++) {\n\t\t\tmap.put(arr[i].getID(), arr[i]);\n\t\t}\n\t\treturn map;\n\t}\n"]]}
{"hexsha": "030296d544cde31942b92139cea5692a2e410f94", "ext": "java", "lang": "Java", "content": "public class NodeSensorsFragment extends Fragment implements NodeStatusContract.View {\n\n    private static final String BOARDER_ROUTER = NodeSensorsFragment.class.getCanonicalName()+\".BOARDER_ROUTER\";\n    private static final String NODE_ADDRESS = NodeSensorsFragment.class.getCanonicalName()+\".NODE_ADDRESS\";\n\n    public static NodeSensorsFragment instantiate(Node router, NetworkAddress address){\n        NodeSensorsFragment fragment = new NodeSensorsFragment();\n\n        Bundle args = new Bundle();\n        args.putString(BOARDER_ROUTER,router.getTag());\n        args.putByteArray(NODE_ADDRESS,address.getBytes());\n        fragment.setArguments(args);\n        return fragment;\n    }\n\n    private NodeStatusContract.Presenter mPresenter;\n\n    private TextView mAddress;\n    private SensorStatusView mTemperature;\n    private SensorStatusView mPressure;\n    private SensorStatusView mHumidity;\n    private SensorStatusView mAccelerometer;\n    private SensorStatusView mMagnetometer;\n    private SensorStatusView mGyroscope;\n    private LedStatusView mLedStatus;\n\n\n    @Override\n    public void showNodeAddress(NetworkAddress address) {\n        FragmentUtil.runOnUiThread(this,()-> mAddress.setText(AddressFormatter.format(address)));\n\n    }\n\n    @Override\n    public void showTemperature(float temperature) {\n        FragmentUtil.runOnUiThread(this,()-> mTemperature.setSensorValue(getString(R.string.lowpan_details_temperature_format,temperature)));\n    }\n\n    @Override\n    public void showPressure(float pressure) {\n        FragmentUtil.runOnUiThread(this,()-> mPressure.setSensorValue(getString(R.string.lowpan_details_pressure_format,pressure)));\n    }\n\n    @Override\n    public void showHumidity(float humidity) {\n        FragmentUtil.runOnUiThread(this,()-> mHumidity.setSensorValue(getString(R.string.lowpan_details_humidity_format,humidity)));\n    }\n\n    @Override\n    public void showAccelerometer(float x, float y, float z) {\n        FragmentUtil.runOnUiThread(this,()-> mAccelerometer.setSensorValue(\n                getString(R.string.lowpan_details_accelerometer_format, x,y,z)));\n    }\n\n    @Override\n    public void showGyroscope(float x, float y, float z) {\n        FragmentUtil.runOnUiThread(this,()-> mGyroscope.setSensorValue(\n                getString(R.string.lowpan_details_gyroscope_format, x,y,z)));\n    }\n\n    @Override\n    public void showMagnetometer(float x, float y, float z) {\n        FragmentUtil.runOnUiThread(this,()-> mMagnetometer.setSensorValue(\n                getString(R.string.lowpan_details_magnetometer_format, x,y,z)));\n    }\n\n    @Override\n    public void showLedStatus(byte dimmingValue) {\n        FragmentUtil.runOnUiThread(this,()->{\n            mLedStatus.setLedStatus((byte) (dimmingValue/4));\n            mLedStatus.setVisibility(View.VISIBLE);\n        });\n    }\n\n\n    @Override\n    public void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        super.setHasOptionsMenu(true);\n        Bundle boundle = getArguments();\n        Node n = Manager.getSharedInstance().getNodeWithTag(boundle.getString(BOARDER_ROUTER));\n        Feature6LoWPANProtocol boarderRouter = n.getFeature(Feature6LoWPANProtocol.class);\n        NetworkAddress nodeAddress = new NetworkAddress(boundle.getByteArray(NODE_ADDRESS));\n\n        mPresenter = new NodeSensorPresenter(this,boarderRouter,nodeAddress);\n\n    }\n\n    @Nullable\n    @Override\n    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) {\n        View root = inflater.inflate(R.layout.framgnet_6lowpan_sensor_details,container,false);\n\n        mAddress = root.findViewById(R.id.lowpan_details_address);\n        mTemperature = root.findViewById(R.id.lowpan_details_temperature);\n        mPressure = root.findViewById(R.id.lowpan_details_pressure);\n        mHumidity = root.findViewById(R.id.lowpan_details_humidity);\n        mAccelerometer = root.findViewById(R.id.lowpan_details_accelerometer);\n        mMagnetometer = root.findViewById(R.id.lowpan_details_magnetometer);\n        mGyroscope = root.findViewById(R.id.lowpan_details_gyroscope);\n        mLedStatus = root.findViewById(R.id.lowpan_details_led);\n        mLedStatus.setOnLedStatusChangeListener(newValue -> {\n            if(mPresenter!=null)\n                mPresenter.setDimmingStatus((byte)( newValue*25));\n        });\n        return root;\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        mPresenter.startRetrievingSensorData();\n    }\n\n    @Override\n    public void onPause() {\n        super.onPause();\n        mPresenter.stopRetrievingSensorData();\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        if(item.getItemId()==android.R.id.home) {\n            getFragmentManager().popBackStack();\n            return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n}", "class_id": 0, "repo": "STMicroelectronics/STSensNet_Android", "file": "STSensNetApp/src/main/java/com/st/SensNet/net6LoWPAN/nodeStatus/NodeSensorsFragment.java", "last_update_at": "2020-03-28T10:44:41+00:00", "question_id": "030296d544cde31942b92139cea5692a2e410f94", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NodeSensorsFragment extends Fragment implements NodeStatusContract.View {\n    private static final String BOARDER_ROUTER = NodeSensorsFragment.class.getCanonicalName()+\".BOARDER_ROUTER\";\n    private static final String NODE_ADDRESS = NodeSensorsFragment.class.getCanonicalName()+\".NODE_ADDRESS\";\n    public static NodeSensorsFragment instantiate(Node router, NetworkAddress address){\n        NodeSensorsFragment fragment = new NodeSensorsFragment();\n        Bundle args = new Bundle();\n        args.putString(BOARDER_ROUTER,router.getTag());\n        args.putByteArray(NODE_ADDRESS,address.getBytes());\n        fragment.setArguments(args);\n        return fragment;\n    }\n    private NodeStatusContract.Presenter mPresenter;\n    private TextView mAddress;\n    private SensorStatusView mTemperature;\n    private SensorStatusView mPressure;\n    private SensorStatusView mHumidity;\n    private SensorStatusView mAccelerometer;\n    private SensorStatusView mMagnetometer;\n    private SensorStatusView mGyroscope;\n    private LedStatusView mLedStatus;\n    @Override\n    public void showNodeAddress(NetworkAddress address) {\n        FragmentUtil.runOnUiThread(this,()-> mAddress.setText(AddressFormatter.format(address)));\n    }\n    @Override\n    public void showTemperature(float temperature) {\n        FragmentUtil.runOnUiThread(this,()-> mTemperature.setSensorValue(getString(R.string.lowpan_details_temperature_format,temperature)));\n    }\n    @Override\n    public void showPressure(float pressure) {\n        FragmentUtil.runOnUiThread(this,()-> mPressure.setSensorValue(getString(R.string.lowpan_details_pressure_format,pressure)));\n    }\n    @Override\n    public void showHumidity(float humidity) {\n        FragmentUtil.runOnUiThread(this,()-> mHumidity.setSensorValue(getString(R.string.lowpan_details_humidity_format,humidity)));\n    }\n    @Override\n    public void showAccelerometer(float x, float y, float z) {\n        FragmentUtil.runOnUiThread(this,()-> mAccelerometer.setSensorValue(\n                getString(R.string.lowpan_details_accelerometer_format, x,y,z)));\n    }\n    @Override\n    public void showGyroscope(float x, float y, float z) {\n        FragmentUtil.runOnUiThread(this,()-> mGyroscope.setSensorValue(\n                getString(R.string.lowpan_details_gyroscope_format, x,y,z)));\n    }\n    @Override\n    public void showMagnetometer(float x, float y, float z) {\n        FragmentUtil.runOnUiThread(this,()-> mMagnetometer.setSensorValue(\n                getString(R.string.lowpan_details_magnetometer_format, x,y,z)));\n    }\n    @Override\n    public void showLedStatus(byte dimmingValue) {\n        FragmentUtil.runOnUiThread(this,()->{\n            mLedStatus.setLedStatus((byte) (dimmingValue/4));\n            mLedStatus.setVisibility(View.VISIBLE);\n        });\n    }\n    @Override\n    public void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        super.setHasOptionsMenu(true);\n        Bundle boundle = getArguments();\n        Node n = Manager.getSharedInstance().getNodeWithTag(boundle.getString(BOARDER_ROUTER));\n        Feature6LoWPANProtocol boarderRouter = n.getFeature(Feature6LoWPANProtocol.class);\n        NetworkAddress nodeAddress = new NetworkAddress(boundle.getByteArray(NODE_ADDRESS));\n        mPresenter = new NodeSensorPresenter(this,boarderRouter,nodeAddress);\n    }\n    @Nullable\n    @Override\n    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) {\n        View root = inflater.inflate(R.layout.framgnet_6lowpan_sensor_details,container,false);\n        mAddress = root.findViewById(R.id.lowpan_details_address);\n        mTemperature = root.findViewById(R.id.lowpan_details_temperature);\n        mPressure = root.findViewById(R.id.lowpan_details_pressure);\n        mHumidity = root.findViewById(R.id.lowpan_details_humidity);\n        mAccelerometer = root.findViewById(R.id.lowpan_details_accelerometer);\n        mMagnetometer = root.findViewById(R.id.lowpan_details_magnetometer);\n        mGyroscope = root.findViewById(R.id.lowpan_details_gyroscope);\n        mLedStatus = root.findViewById(R.id.lowpan_details_led);\n        mLedStatus.setOnLedStatusChangeListener(newValue -> {\n            if(mPresenter!=null)\n                mPresenter.setDimmingStatus((byte)( newValue*25));\n        });\n        return root;\n    }\n    @Override\n    public void onResume() {\n        super.onResume();\n        mPresenter.startRetrievingSensorData();\n    }\n    @Override\n    public void onPause() {\n        super.onPause();\n        mPresenter.stopRetrievingSensorData();\n    }\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        if(item.getItemId()==android.R.id.home) {\n            getFragmentManager().popBackStack();\n            return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n"]]}
{"hexsha": "f621767f066b6046d9e13b34397549b0679c8668", "ext": "java", "lang": "Java", "content": "public class AdViewPagerAdapter extends PagerAdapter{\n\n    private List<ImageView> images;\n\n    public AdViewPagerAdapter(List<ImageView> images){\n        this.images = images;\n    }\n\n    @Override\n    public int getCount(){\n        return images.size();\n    }\n\n    @Override\n    public boolean isViewFromObject(View view, Object obj){\n        return view == obj;\n    }\n\n    @Override\n    public void destroyItem(ViewGroup view, int position, Object object){\n        view.removeView(images.get(position));\n    }\n\n    @Override\n    public Object instantiateItem(ViewGroup view, int position){\n        // TODO Auto-generated method stub\n        view.addView(images.get(position));\n        return images.get(position);\n    }\n}", "class_id": 0, "repo": "LEOgarden/comProc", "file": "app/src/main/java/android/leo/electricity/adapter/AdViewPagerAdapter.java", "last_update_at": "2020-03-15T06:49:21+00:00", "question_id": "f621767f066b6046d9e13b34397549b0679c8668", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AdViewPagerAdapter extends PagerAdapter{\n    private List<ImageView> images;\n    public AdViewPagerAdapter(List<ImageView> images){\n        this.images = images;\n    }\n    @Override\n    public int getCount(){\n        return images.size();\n    }\n    @Override\n    public boolean isViewFromObject(View view, Object obj){\n        return view == obj;\n    }\n    @Override\n    public void destroyItem(ViewGroup view, int position, Object object){\n        view.removeView(images.get(position));\n    }\n    @Override\n    public Object instantiateItem(ViewGroup view, int position){\n        // TODO Auto-generated method stub\n        view.addView(images.get(position));\n        return images.get(position);\n    }\n"]]}
{"hexsha": "3c3d78c7d10506ab65a2e42e2db20acc6594fa83", "ext": "java", "lang": "Java", "content": "@Slf4j\npublic class TransactionInfoEnricher {\n    private final Map<String, ConfigValue> shopKeyWordsToConfigMap;\n    private final AdditionalSourceManager additionalSourceManager;\n\n    public TransactionInfoEnricher(@Nullable KeyWordsToCategoryMapJsonParser config, AdditionalSourceManager additionalSourceManager) {\n        this.shopKeyWordsToConfigMap = config != null ? config.getShopMapping() : Collections.emptyMap();\n        this.additionalSourceManager = additionalSourceManager;\n    }\n\n    private static MoneyTransaction enrichCategoryOrWallet(MoneyTransaction transaction, String categoryOrWallet) {\n        if (transaction.getOperationType() == OperationType.TRANSFER) {\n            return enrichWallet(transaction, categoryOrWallet);\n        }\n        return enrichCategory(transaction, categoryOrWallet);\n    }\n\n    private static MoneyTransaction enrichCategory(MoneyTransaction transaction, String categoryOrWallet) {\n        return transaction.toBuilder()\n                .category(categoryOrWallet)\n                .build();\n    }\n\n    private static MoneyTransaction enrichWallet(MoneyTransaction transaction, String categoryOrWallet) {\n        // One of wallet already filled with default wallet value\n        // Fill other (not filled) wallet\n        if (transaction.getSourceWallet() == null) {\n            return transaction.toBuilder()\n                    .sourceWallet(categoryOrWallet)\n                    .build();\n        }\n        if (transaction.getTargetWallet() == null) {\n            return transaction.toBuilder()\n                    .targetWallet(categoryOrWallet)\n                    .build();\n        }\n        return transaction;\n    }\n\n    private MoneyTransaction fillFromConfig(MoneyTransaction transaction, ConfigValue config) {\n        return Optional.of(transaction)\n                .map(tr -> enrichCategoryOrWallet(tr, config.getCategory()))\n                .map(tr -> enrichWithAdditionalDescriptionIfExist(tr, config.getAdditionalDescription()))\n                .orElseThrow(RuntimeException::new);\n    }\n\n    private MoneyTransaction enrichWithAdditionalDescriptionIfExist(MoneyTransaction tr, @Nullable String additionalDescription) {\n        return Optional.ofNullable(additionalDescription)\n                .map(description -> enrichWithAdditionalDescription(tr, description))\n                .orElse(tr);\n    }\n\n    private MoneyTransaction enrichWithAdditionalDescription(MoneyTransaction tr, String additionalDescription) {\n        return tr.toBuilder()\n                .description(String.format(\"%s (%s)\", additionalDescription, tr.getDescription()))\n                .build();\n    }\n\n    private MoneyTransaction fillTransactionByShopName(MoneyTransaction transaction) {\n        return shopKeyWordsToConfigMap.entrySet().stream()\n                .filter(entry -> transaction.getDescription().toLowerCase().contains(entry.getKey().toLowerCase()))\n                .findFirst()\n                .map(entry -> fillFromConfig(transaction, entry.getValue()))\n                .orElse(transaction);\n    }\n\n    public List<MoneyTransaction> fill(List<MoneyTransaction> transactionList) {\n        return transactionList.stream()\n                .map(this::fillTransactionByShopName)\n                .map(this::fillTransactionFromAdditionalSources)\n                .collect(Collectors.toList());\n    }\n\n    private MoneyTransaction fillTransactionFromAdditionalSources(MoneyTransaction moneyTransaction) {\n        return additionalSourceManager.getAdditionalSources().stream()\n                .filter(additionalSource -> moneyTransaction.getDescription().toLowerCase().contains(additionalSource.getSourceName().toLowerCase()))\n                .findFirst()\n                .map(additionalSource -> {\n                    EnrichmentData enrichmentData = additionalSource.getEnrichmentData(moneyTransaction);\n                    if (enrichmentData == null) {\n                        return moneyTransaction;\n                    }\n                    String category = enrichmentData.getCategory();\n                    String additionalDescription = enrichmentData.getAdditionalDescription();\n                    if (category != null || additionalDescription != null) {\n                        MoneyTransaction.MoneyTransactionBuilder builder = moneyTransaction.toBuilder();\n                        if (category != null) {\n                            builder.category(category);\n                        }\n                        if (additionalDescription != null) {\n                            builder.description(moneyTransaction.getDescription() + \": \" + additionalDescription);\n                        }\n                        return builder.build();\n                    }\n                    return moneyTransaction;\n                })\n                .orElse(moneyTransaction);\n    }\n\n}", "class_id": 0, "repo": "MAXbrainRUS/rocket-bank-statement-parser", "file": "src/main/java/ru/maxbrainrus/parser/TransactionInfoEnricher.java", "last_update_at": "2020-04-23T16:42:26+00:00", "question_id": "3c3d78c7d10506ab65a2e42e2db20acc6594fa83", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Slf4j\npublic class TransactionInfoEnricher {\n    private final Map<String, ConfigValue> shopKeyWordsToConfigMap;\n    private final AdditionalSourceManager additionalSourceManager;\n    public TransactionInfoEnricher(@Nullable KeyWordsToCategoryMapJsonParser config, AdditionalSourceManager additionalSourceManager) {\n        this.shopKeyWordsToConfigMap = config != null ? config.getShopMapping() : Collections.emptyMap();\n        this.additionalSourceManager = additionalSourceManager;\n    }\n    private static MoneyTransaction enrichCategoryOrWallet(MoneyTransaction transaction, String categoryOrWallet) {\n        if (transaction.getOperationType() == OperationType.TRANSFER) {\n            return enrichWallet(transaction, categoryOrWallet);\n        }\n        return enrichCategory(transaction, categoryOrWallet);\n    }\n    private static MoneyTransaction enrichCategory(MoneyTransaction transaction, String categoryOrWallet) {\n        return transaction.toBuilder()\n                .category(categoryOrWallet)\n                .build();\n    }\n    private static MoneyTransaction enrichWallet(MoneyTransaction transaction, String categoryOrWallet) {\n        // One of wallet already filled with default wallet value\n        // Fill other (not filled) wallet\n        if (transaction.getSourceWallet() == null) {\n            return transaction.toBuilder()\n                    .sourceWallet(categoryOrWallet)\n                    .build();\n        }\n        if (transaction.getTargetWallet() == null) {\n            return transaction.toBuilder()\n                    .targetWallet(categoryOrWallet)\n                    .build();\n        }\n        return transaction;\n    }\n    private MoneyTransaction fillFromConfig(MoneyTransaction transaction, ConfigValue config) {\n        return Optional.of(transaction)\n                .map(tr -> enrichCategoryOrWallet(tr, config.getCategory()))\n                .map(tr -> enrichWithAdditionalDescriptionIfExist(tr, config.getAdditionalDescription()))\n                .orElseThrow(RuntimeException::new);\n    }\n    private MoneyTransaction enrichWithAdditionalDescriptionIfExist(MoneyTransaction tr, @Nullable String additionalDescription) {\n        return Optional.ofNullable(additionalDescription)\n                .map(description -> enrichWithAdditionalDescription(tr, description))\n                .orElse(tr);\n    }\n    private MoneyTransaction enrichWithAdditionalDescription(MoneyTransaction tr, String additionalDescription) {\n        return tr.toBuilder()\n                .description(String.format(\"%s (%s)\", additionalDescription, tr.getDescription()))\n                .build();\n    }\n    private MoneyTransaction fillTransactionByShopName(MoneyTransaction transaction) {\n        return shopKeyWordsToConfigMap.entrySet().stream()\n                .filter(entry -> transaction.getDescription().toLowerCase().contains(entry.getKey().toLowerCase()))\n                .findFirst()\n                .map(entry -> fillFromConfig(transaction, entry.getValue()))\n                .orElse(transaction);\n    }\n    public List<MoneyTransaction> fill(List<MoneyTransaction> transactionList) {\n        return transactionList.stream()\n                .map(this::fillTransactionByShopName)\n                .map(this::fillTransactionFromAdditionalSources)\n                .collect(Collectors.toList());\n    }\n    private MoneyTransaction fillTransactionFromAdditionalSources(MoneyTransaction moneyTransaction) {\n        return additionalSourceManager.getAdditionalSources().stream()\n                .filter(additionalSource -> moneyTransaction.getDescription().toLowerCase().contains(additionalSource.getSourceName().toLowerCase()))\n                .findFirst()\n                .map(additionalSource -> {\n                    EnrichmentData enrichmentData = additionalSource.getEnrichmentData(moneyTransaction);\n                    if (enrichmentData == null) {\n                        return moneyTransaction;\n                    }\n                    String category = enrichmentData.getCategory();\n                    String additionalDescription = enrichmentData.getAdditionalDescription();\n                    if (category != null || additionalDescription != null) {\n                        MoneyTransaction.MoneyTransactionBuilder builder = moneyTransaction.toBuilder();\n                        if (category != null) {\n                            builder.category(category);\n                        }\n                        if (additionalDescription != null) {\n                            builder.description(moneyTransaction.getDescription() + \": \" + additionalDescription);\n                        }\n                        return builder.build();\n                    }\n                    return moneyTransaction;\n                })\n                .orElse(moneyTransaction);\n    }\n"]]}
{"hexsha": "91a6523a97a6c7f1206ef5d42f67e1db2c1f953b", "ext": "java", "lang": "Java", "content": "@BeanDefinition(builderScope = \"private\", metaScope = \"private\", factoryName = \"of\")\nfinal class ApiKeyCredentials implements Credentials, ImmutableBean {\n  // this class is intended to stay package-scoped\n  // users are not exposed to the data, to reduce attempts to query the data held within\n\n  /**\n   * The API Key ID with which to authenticate\n   */\n  @PropertyDefinition(validate = \"notBlank\", get = \"\")\n  private final String apiKey;\n\n  /**\n   * The secret corresponding to the id with which to authenticate\n   */\n  @PropertyDefinition(validate = \"notBlank\", get = \"\")\n  private final String secret;\n\n  //-------------------------------------------------------------------------\n  @Override\n  public AccessTokenResult authenticate(AuthClient client) {\n    return client.authenticateApiKey(apiKey, secret);\n  }\n\n  //------------------------- AUTOGENERATED START -------------------------\n  /**\n   * The meta-bean for {@code ApiKeyCredentials}.\n   * @return the meta-bean, not null\n   */\n  public static MetaBean meta() {\n    return ApiKeyCredentials.Meta.INSTANCE;\n  }\n\n  static {\n    MetaBean.register(ApiKeyCredentials.Meta.INSTANCE);\n  }\n\n  /**\n   * Obtains an instance.\n   * @param apiKey  the value of the property, not blank\n   * @param secret  the value of the property, not blank\n   * @return the instance\n   */\n  public static ApiKeyCredentials of(\n      String apiKey,\n      String secret) {\n    return new ApiKeyCredentials(\n      apiKey,\n      secret);\n  }\n\n  private ApiKeyCredentials(\n      String apiKey,\n      String secret) {\n    JodaBeanUtils.notBlank(apiKey, \"apiKey\");\n    JodaBeanUtils.notBlank(secret, \"secret\");\n    this.apiKey = apiKey;\n    this.secret = secret;\n  }\n\n  @Override\n  public MetaBean metaBean() {\n    return ApiKeyCredentials.Meta.INSTANCE;\n  }\n\n  //-----------------------------------------------------------------------\n  @Override\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (obj != null && obj.getClass() == this.getClass()) {\n      ApiKeyCredentials other = (ApiKeyCredentials) obj;\n      return JodaBeanUtils.equal(apiKey, other.apiKey) &&\n          JodaBeanUtils.equal(secret, other.secret);\n    }\n    return false;\n  }\n\n  @Override\n  public int hashCode() {\n    int hash = getClass().hashCode();\n    hash = hash * 31 + JodaBeanUtils.hashCode(apiKey);\n    hash = hash * 31 + JodaBeanUtils.hashCode(secret);\n    return hash;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder buf = new StringBuilder(96);\n    buf.append(\"ApiKeyCredentials{\");\n    buf.append(\"apiKey\").append('=').append(JodaBeanUtils.toString(apiKey)).append(',').append(' ');\n    buf.append(\"secret\").append('=').append(JodaBeanUtils.toString(secret));\n    buf.append('}');\n    return buf.toString();\n  }\n\n  //-----------------------------------------------------------------------\n  /**\n   * The meta-bean for {@code ApiKeyCredentials}.\n   */\n  private static final class Meta extends DirectMetaBean {\n    /**\n     * The singleton instance of the meta-bean.\n     */\n    static final Meta INSTANCE = new Meta();\n\n    /**\n     * The meta-property for the {@code apiKey} property.\n     */\n    private final MetaProperty<String> apiKey = DirectMetaProperty.ofImmutable(\n        this, \"apiKey\", ApiKeyCredentials.class, String.class);\n    /**\n     * The meta-property for the {@code secret} property.\n     */\n    private final MetaProperty<String> secret = DirectMetaProperty.ofImmutable(\n        this, \"secret\", ApiKeyCredentials.class, String.class);\n    /**\n     * The meta-properties.\n     */\n    private final Map<String, MetaProperty<?>> metaPropertyMap$ = new DirectMetaPropertyMap(\n        this, null,\n        \"apiKey\",\n        \"secret\");\n\n    /**\n     * Restricted constructor.\n     */\n    private Meta() {\n    }\n\n    @Override\n    protected MetaProperty<?> metaPropertyGet(String propertyName) {\n      switch (propertyName.hashCode()) {\n        case -1411301915:  // apiKey\n          return apiKey;\n        case -906277200:  // secret\n          return secret;\n      }\n      return super.metaPropertyGet(propertyName);\n    }\n\n    @Override\n    public BeanBuilder<? extends ApiKeyCredentials> builder() {\n      return new ApiKeyCredentials.Builder();\n    }\n\n    @Override\n    public Class<? extends ApiKeyCredentials> beanType() {\n      return ApiKeyCredentials.class;\n    }\n\n    @Override\n    public Map<String, MetaProperty<?>> metaPropertyMap() {\n      return metaPropertyMap$;\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    protected Object propertyGet(Bean bean, String propertyName, boolean quiet) {\n      switch (propertyName.hashCode()) {\n        case -1411301915:  // apiKey\n          return ((ApiKeyCredentials) bean).apiKey;\n        case -906277200:  // secret\n          return ((ApiKeyCredentials) bean).secret;\n      }\n      return super.propertyGet(bean, propertyName, quiet);\n    }\n\n    @Override\n    protected void propertySet(Bean bean, String propertyName, Object newValue, boolean quiet) {\n      metaProperty(propertyName);\n      if (quiet) {\n        return;\n      }\n      throw new UnsupportedOperationException(\"Property cannot be written: \" + propertyName);\n    }\n\n  }\n\n  //-----------------------------------------------------------------------\n  /**\n   * The bean-builder for {@code ApiKeyCredentials}.\n   */\n  private static final class Builder extends DirectPrivateBeanBuilder<ApiKeyCredentials> {\n\n    private String apiKey;\n    private String secret;\n\n    /**\n     * Restricted constructor.\n     */\n    private Builder() {\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public Object get(String propertyName) {\n      switch (propertyName.hashCode()) {\n        case -1411301915:  // apiKey\n          return apiKey;\n        case -906277200:  // secret\n          return secret;\n        default:\n          throw new NoSuchElementException(\"Unknown property: \" + propertyName);\n      }\n    }\n\n    @Override\n    public Builder set(String propertyName, Object newValue) {\n      switch (propertyName.hashCode()) {\n        case -1411301915:  // apiKey\n          this.apiKey = (String) newValue;\n          break;\n        case -906277200:  // secret\n          this.secret = (String) newValue;\n          break;\n        default:\n          throw new NoSuchElementException(\"Unknown property: \" + propertyName);\n      }\n      return this;\n    }\n\n    @Override\n    public ApiKeyCredentials build() {\n      return new ApiKeyCredentials(\n          apiKey,\n          secret);\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public String toString() {\n      StringBuilder buf = new StringBuilder(96);\n      buf.append(\"ApiKeyCredentials.Builder{\");\n      buf.append(\"apiKey\").append('=').append(JodaBeanUtils.toString(apiKey)).append(',').append(' ');\n      buf.append(\"secret\").append('=').append(JodaBeanUtils.toString(secret));\n      buf.append('}');\n      return buf.toString();\n    }\n\n  }\n\n  //-------------------------- AUTOGENERATED END --------------------------\n}", "class_id": 0, "repo": "OpenGamma/ServiceClient", "file": "modules/common/src/main/java/com/opengamma/sdk/common/auth/ApiKeyCredentials.java", "last_update_at": "2020-07-06T15:48:26+00:00", "question_id": "91a6523a97a6c7f1206ef5d42f67e1db2c1f953b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@BeanDefinition(builderScope = \"private\", metaScope = \"private\", factoryName = \"of\")\nfinal class ApiKeyCredentials implements Credentials, ImmutableBean {\n  // this class is intended to stay package-scoped\n  // users are not exposed to the data, to reduce attempts to query the data held within\n  /**\n   * The API Key ID with which to authenticate\n   */\n  @PropertyDefinition(validate = \"notBlank\", get = \"\")\n  private final String apiKey;\n  /**\n   * The secret corresponding to the id with which to authenticate\n   */\n  @PropertyDefinition(validate = \"notBlank\", get = \"\")\n  private final String secret;\n  //-------------------------------------------------------------------------\n  @Override\n  public AccessTokenResult authenticate(AuthClient client) {\n    return client.authenticateApiKey(apiKey, secret);\n  }\n  //------------------------- AUTOGENERATED START -------------------------\n  /**\n   * The meta-bean for {@code ApiKeyCredentials}.\n   * @return the meta-bean, not null\n   */\n  public static MetaBean meta() {\n    return ApiKeyCredentials.Meta.INSTANCE;\n  }\n  static {\n    MetaBean.register(ApiKeyCredentials.Meta.INSTANCE);\n  }\n  /**\n   * Obtains an instance.\n   * @param apiKey  the value of the property, not blank\n   * @param secret  the value of the property, not blank\n   * @return the instance\n   */\n  public static ApiKeyCredentials of(\n      String apiKey,\n      String secret) {\n    return new ApiKeyCredentials(\n      apiKey,\n      secret);\n  }\n  private ApiKeyCredentials(\n      String apiKey,\n      String secret) {\n    JodaBeanUtils.notBlank(apiKey, \"apiKey\");\n    JodaBeanUtils.notBlank(secret, \"secret\");\n    this.apiKey = apiKey;\n    this.secret = secret;\n  }\n  @Override\n  public MetaBean metaBean() {\n    return ApiKeyCredentials.Meta.INSTANCE;\n  }\n  //-----------------------------------------------------------------------\n  @Override\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (obj != null && obj.getClass() == this.getClass()) {\n      ApiKeyCredentials other = (ApiKeyCredentials) obj;\n      return JodaBeanUtils.equal(apiKey, other.apiKey) &&\n          JodaBeanUtils.equal(secret, other.secret);\n    }\n    return false;\n  }\n  @Override\n  public int hashCode() {\n    int hash = getClass().hashCode();\n    hash = hash * 31 + JodaBeanUtils.hashCode(apiKey);\n    hash = hash * 31 + JodaBeanUtils.hashCode(secret);\n    return hash;\n  }\n  @Override\n  public String toString() {\n    StringBuilder buf = new StringBuilder(96);\n    buf.append(\"ApiKeyCredentials{\");\n    buf.append(\"apiKey\").append('=').append(JodaBeanUtils.toString(apiKey)).append(',').append(' ');\n    buf.append(\"secret\").append('=').append(JodaBeanUtils.toString(secret));\n    buf.append('}');\n    return buf.toString();\n  }\n  //-----------------------------------------------------------------------\n  /**\n   * The meta-bean for {@code ApiKeyCredentials}.\n   */\n  private static final class Meta extends DirectMetaBean {\n    /**\n     * The singleton instance of the meta-bean.\n     */\n    static final Meta INSTANCE = new Meta();\n    /**\n     * The meta-property for the {@code apiKey} property.\n     */\n    private final MetaProperty<String> apiKey = DirectMetaProperty.ofImmutable(\n        this, \"apiKey\", ApiKeyCredentials.class, String.class);\n    /**\n     * The meta-property for the {@code secret} property.\n     */\n    private final MetaProperty<String> secret = DirectMetaProperty.ofImmutable(\n        this, \"secret\", ApiKeyCredentials.class, String.class);\n    /**\n     * The meta-properties.\n     */\n    private final Map<String, MetaProperty<?>> metaPropertyMap$ = new DirectMetaPropertyMap(\n        this, null,\n        \"apiKey\",\n        \"secret\");\n    /**\n     * Restricted constructor.\n     */\n    private Meta() {\n    }\n    @Override\n    protected MetaProperty<?> metaPropertyGet(String propertyName) {\n      switch (propertyName.hashCode()) {\n        case -1411301915:  // apiKey\n          return apiKey;\n        case -906277200:  // secret\n          return secret;\n      }\n      return super.metaPropertyGet(propertyName);\n    }\n    @Override\n    public BeanBuilder<? extends ApiKeyCredentials> builder() {\n      return new ApiKeyCredentials.Builder();\n    }\n    @Override\n    public Class<? extends ApiKeyCredentials> beanType() {\n      return ApiKeyCredentials.class;\n    }\n    @Override\n    public Map<String, MetaProperty<?>> metaPropertyMap() {\n      return metaPropertyMap$;\n    }\n    //-----------------------------------------------------------------------\n    @Override\n    protected Object propertyGet(Bean bean, String propertyName, boolean quiet) {\n      switch (propertyName.hashCode()) {\n        case -1411301915:  // apiKey\n          return ((ApiKeyCredentials) bean).apiKey;\n        case -906277200:  // secret\n          return ((ApiKeyCredentials) bean).secret;\n      }\n      return super.propertyGet(bean, propertyName, quiet);\n    }\n    @Override\n    protected void propertySet(Bean bean, String propertyName, Object newValue, boolean quiet) {\n      metaProperty(propertyName);\n      if (quiet) {\n        return;\n      }\n      throw new UnsupportedOperationException(\"Property cannot be written: \" + propertyName);\n    }\n  }\n  //-----------------------------------------------------------------------\n  /**\n   * The bean-builder for {@code ApiKeyCredentials}.\n   */\n  private static final class Builder extends DirectPrivateBeanBuilder<ApiKeyCredentials> {\n    private String apiKey;\n    private String secret;\n    /**\n     * Restricted constructor.\n     */\n    private Builder() {\n    }\n    //-----------------------------------------------------------------------\n    @Override\n    public Object get(String propertyName) {\n      switch (propertyName.hashCode()) {\n        case -1411301915:  // apiKey\n          return apiKey;\n        case -906277200:  // secret\n          return secret;\n        default:\n          throw new NoSuchElementException(\"Unknown property: \" + propertyName);\n      }\n    }\n    @Override\n    public Builder set(String propertyName, Object newValue) {\n      switch (propertyName.hashCode()) {\n        case -1411301915:  // apiKey\n          this.apiKey = (String) newValue;\n          break;\n        case -906277200:  // secret\n          this.secret = (String) newValue;\n          break;\n        default:\n          throw new NoSuchElementException(\"Unknown property: \" + propertyName);\n      }\n      return this;\n    }\n    @Override\n    public ApiKeyCredentials build() {\n      return new ApiKeyCredentials(\n          apiKey,\n          secret);\n    }\n    //-----------------------------------------------------------------------\n    @Override\n    public String toString() {\n      StringBuilder buf = new StringBuilder(96);\n      buf.append(\"ApiKeyCredentials.Builder{\");\n      buf.append(\"apiKey\").append('=').append(JodaBeanUtils.toString(apiKey)).append(',').append(' ');\n      buf.append(\"secret\").append('=').append(JodaBeanUtils.toString(secret));\n      buf.append('}');\n      return buf.toString();\n    }\n  }\n  //-------------------------- AUTOGENERATED END --------------------------\n"]]}
{"hexsha": "dee61b6a7c414eb7acd0915b4ad64bc318ba6e66", "ext": "java", "lang": "Java", "content": "public class FindItemById extends BaseAction {\n\n    public FindItemById(int key, String name) {\n        super(key, name);\n    }\n\n    @Override\n    public void execute(Input input, Tracker tracker) {\n        String id = input.ask(\"Please, enter item id: \");\n        Item item = tracker.findById(id);\n        System.out.println(\"-------------------------------------------------\");\n        System.out.println(\"Id: \" + item.getId());\n        System.out.println(\"Name: \" + item.getName());\n        System.out.println(\"Description: \" + item.getDescription());\n        System.out.println(\"-------------------------------------------------\");\n    }\n}", "class_id": 0, "repo": "MaximMateuk/job4j", "file": "chapter_002/src/main/java/ru/job4j/tracker/actions/FindItemById.java", "last_update_at": "2020-12-24T12:01:10+00:00", "question_id": "dee61b6a7c414eb7acd0915b4ad64bc318ba6e66", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FindItemById extends BaseAction {\n    public FindItemById(int key, String name) {\n        super(key, name);\n    }\n    @Override\n    public void execute(Input input, Tracker tracker) {\n        String id = input.ask(\"Please, enter item id: \");\n        Item item = tracker.findById(id);\n        System.out.println(\"-------------------------------------------------\");\n        System.out.println(\"Id: \" + item.getId());\n        System.out.println(\"Name: \" + item.getName());\n        System.out.println(\"Description: \" + item.getDescription());\n        System.out.println(\"-------------------------------------------------\");\n    }\n"]]}
{"hexsha": "c34048d3ef33b1d47e48ab44358459f8ecbcd2f0", "ext": "java", "lang": "Java", "content": "@ApiModel(description = \"```JSON \\\"details\\\": {   \\\"first_name\\\": \\\"First\\\",   \\\"last_name\\\": \\\"Last\\\",   \\\"bank_name\\\": \\\"Deutsche Bank\\\",   \\\"iban\\\": \\\"DE89370400440532013000\\\",   \\\"bic\\\": \\\"DEUTDEBBXXX\\\" // Optional } ```\")\n\npublic class PayoutMethodDetailsIBAN {\n  public static final String SERIALIZED_NAME_FIRST_NAME = \"first_name\";\n  @SerializedName(SERIALIZED_NAME_FIRST_NAME)\n  private String firstName;\n\n  public static final String SERIALIZED_NAME_LAST_NAME = \"last_name\";\n  @SerializedName(SERIALIZED_NAME_LAST_NAME)\n  private String lastName;\n\n  public static final String SERIALIZED_NAME_BANK_NAME = \"bank_name\";\n  @SerializedName(SERIALIZED_NAME_BANK_NAME)\n  private String bankName;\n\n  public static final String SERIALIZED_NAME_IBAN = \"iban\";\n  @SerializedName(SERIALIZED_NAME_IBAN)\n  private String iban;\n\n  public static final String SERIALIZED_NAME_BIC = \"bic\";\n  @SerializedName(SERIALIZED_NAME_BIC)\n  private String bic;\n\n  public PayoutMethodDetailsIBAN firstName(String firstName) {\n    this.firstName = firstName;\n    return this;\n  }\n\n   /**\n   * Get firstName\n   * @return firstName\n  **/\n  @ApiModelProperty(required = true, value = \"\")\n  public String getFirstName() {\n    return firstName;\n  }\n\n  public void setFirstName(String firstName) {\n    this.firstName = firstName;\n  }\n\n  public PayoutMethodDetailsIBAN lastName(String lastName) {\n    this.lastName = lastName;\n    return this;\n  }\n\n   /**\n   * Get lastName\n   * @return lastName\n  **/\n  @ApiModelProperty(required = true, value = \"\")\n  public String getLastName() {\n    return lastName;\n  }\n\n  public void setLastName(String lastName) {\n    this.lastName = lastName;\n  }\n\n  public PayoutMethodDetailsIBAN bankName(String bankName) {\n    this.bankName = bankName;\n    return this;\n  }\n\n   /**\n   * Get bankName\n   * @return bankName\n  **/\n  @ApiModelProperty(value = \"\")\n  public String getBankName() {\n    return bankName;\n  }\n\n  public void setBankName(String bankName) {\n    this.bankName = bankName;\n  }\n\n  public PayoutMethodDetailsIBAN iban(String iban) {\n    this.iban = iban;\n    return this;\n  }\n\n   /**\n   * Get iban\n   * @return iban\n  **/\n  @ApiModelProperty(required = true, value = \"\")\n  public String getIban() {\n    return iban;\n  }\n\n  public void setIban(String iban) {\n    this.iban = iban;\n  }\n\n  public PayoutMethodDetailsIBAN bic(String bic) {\n    this.bic = bic;\n    return this;\n  }\n\n   /**\n   * Get bic\n   * @return bic\n  **/\n  @ApiModelProperty(value = \"\")\n  public String getBic() {\n    return bic;\n  }\n\n  public void setBic(String bic) {\n    this.bic = bic;\n  }\n\n\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    PayoutMethodDetailsIBAN payoutMethodDetailsIBAN = (PayoutMethodDetailsIBAN) o;\n    return Objects.equals(this.firstName, payoutMethodDetailsIBAN.firstName) &&\n        Objects.equals(this.lastName, payoutMethodDetailsIBAN.lastName) &&\n        Objects.equals(this.bankName, payoutMethodDetailsIBAN.bankName) &&\n        Objects.equals(this.iban, payoutMethodDetailsIBAN.iban) &&\n        Objects.equals(this.bic, payoutMethodDetailsIBAN.bic);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(firstName, lastName, bankName, iban, bic);\n  }\n\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class PayoutMethodDetailsIBAN {\\n\");\n    sb.append(\"    firstName: \").append(toIndentedString(firstName)).append(\"\\n\");\n    sb.append(\"    lastName: \").append(toIndentedString(lastName)).append(\"\\n\");\n    sb.append(\"    bankName: \").append(toIndentedString(bankName)).append(\"\\n\");\n    sb.append(\"    iban: \").append(toIndentedString(iban)).append(\"\\n\");\n    sb.append(\"    bic: \").append(toIndentedString(bic)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n\n}", "class_id": 0, "repo": "transferzero/transferzero-sdk-java7", "file": "src/main/java/com/transferzero/sdk/model/PayoutMethodDetailsIBAN.java", "last_update_at": "2020-03-12T11:25:41+00:00", "question_id": "c34048d3ef33b1d47e48ab44358459f8ecbcd2f0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ApiModel(description = \"```JSON \\\"details\\\": {   \\\"first_name\\\": \\\"First\\\",   \\\"last_name\\\": \\\"Last\\\",   \\\"bank_name\\\": \\\"Deutsche Bank\\\",   \\\"iban\\\": \\\"DE89370400440532013000\\\",   \\\"bic\\\": \\\"DEUTDEBBXXX\\\" // Optional } ```\")\npublic class PayoutMethodDetailsIBAN {\n  public static final String SERIALIZED_NAME_FIRST_NAME = \"first_name\";\n  @SerializedName(SERIALIZED_NAME_FIRST_NAME)\n  private String firstName;\n  public static final String SERIALIZED_NAME_LAST_NAME = \"last_name\";\n  @SerializedName(SERIALIZED_NAME_LAST_NAME)\n  private String lastName;\n  public static final String SERIALIZED_NAME_BANK_NAME = \"bank_name\";\n  @SerializedName(SERIALIZED_NAME_BANK_NAME)\n  private String bankName;\n  public static final String SERIALIZED_NAME_IBAN = \"iban\";\n  @SerializedName(SERIALIZED_NAME_IBAN)\n  private String iban;\n  public static final String SERIALIZED_NAME_BIC = \"bic\";\n  @SerializedName(SERIALIZED_NAME_BIC)\n  private String bic;\n  public PayoutMethodDetailsIBAN firstName(String firstName) {\n    this.firstName = firstName;\n    return this;\n  }\n   /**\n   * Get firstName\n   * @return firstName\n  **/\n  @ApiModelProperty(required = true, value = \"\")\n  public String getFirstName() {\n    return firstName;\n  }\n  public void setFirstName(String firstName) {\n    this.firstName = firstName;\n  }\n  public PayoutMethodDetailsIBAN lastName(String lastName) {\n    this.lastName = lastName;\n    return this;\n  }\n   /**\n   * Get lastName\n   * @return lastName\n  **/\n  @ApiModelProperty(required = true, value = \"\")\n  public String getLastName() {\n    return lastName;\n  }\n  public void setLastName(String lastName) {\n    this.lastName = lastName;\n  }\n  public PayoutMethodDetailsIBAN bankName(String bankName) {\n    this.bankName = bankName;\n    return this;\n  }\n   /**\n   * Get bankName\n   * @return bankName\n  **/\n  @ApiModelProperty(value = \"\")\n  public String getBankName() {\n    return bankName;\n  }\n  public void setBankName(String bankName) {\n    this.bankName = bankName;\n  }\n  public PayoutMethodDetailsIBAN iban(String iban) {\n    this.iban = iban;\n    return this;\n  }\n   /**\n   * Get iban\n   * @return iban\n  **/\n  @ApiModelProperty(required = true, value = \"\")\n  public String getIban() {\n    return iban;\n  }\n  public void setIban(String iban) {\n    this.iban = iban;\n  }\n  public PayoutMethodDetailsIBAN bic(String bic) {\n    this.bic = bic;\n    return this;\n  }\n   /**\n   * Get bic\n   * @return bic\n  **/\n  @ApiModelProperty(value = \"\")\n  public String getBic() {\n    return bic;\n  }\n  public void setBic(String bic) {\n    this.bic = bic;\n  }\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    PayoutMethodDetailsIBAN payoutMethodDetailsIBAN = (PayoutMethodDetailsIBAN) o;\n    return Objects.equals(this.firstName, payoutMethodDetailsIBAN.firstName) &&\n        Objects.equals(this.lastName, payoutMethodDetailsIBAN.lastName) &&\n        Objects.equals(this.bankName, payoutMethodDetailsIBAN.bankName) &&\n        Objects.equals(this.iban, payoutMethodDetailsIBAN.iban) &&\n        Objects.equals(this.bic, payoutMethodDetailsIBAN.bic);\n  }\n  @Override\n  public int hashCode() {\n    return Objects.hash(firstName, lastName, bankName, iban, bic);\n  }\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class PayoutMethodDetailsIBAN {\\n\");\n    sb.append(\"    firstName: \").append(toIndentedString(firstName)).append(\"\\n\");\n    sb.append(\"    lastName: \").append(toIndentedString(lastName)).append(\"\\n\");\n    sb.append(\"    bankName: \").append(toIndentedString(bankName)).append(\"\\n\");\n    sb.append(\"    iban: \").append(toIndentedString(iban)).append(\"\\n\");\n    sb.append(\"    bic: \").append(toIndentedString(bic)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n"]]}
{"hexsha": "e0d154d32d5187a23317189a6d69f59aad0505f0", "ext": "java", "lang": "Java", "content": "public class CloneableObject {\n\n    /*\n     * This class will not use Clonable interface, as no longer recommended by Joshua Bloch\n     */\n\n    private List<Integer> list = new ArrayList<>();\n\n    // Use this constructor to create first instance\n    public CloneableObject() {\n        Random random = new Random();\n        list.add(random.nextInt(100));\n        list.add(random.nextInt(100));\n    }\n\n    // Use this copy constructor to clone the prototype instance\n    public CloneableObject(CloneableObject prototype) {\n        list = new ArrayList<>(prototype.list);\n    }\n\n    public List<Integer> getValues() {\n        return new ArrayList<>(list);\n    }\n\n    public void updateValues(int a, int b) {\n        list.clear();\n        list.add(a);\n        list.add(b);\n    }\n}", "class_id": 0, "repo": "automatictester/useful-stuff", "file": "java/design-patterns/src/main/java/uk/co/automatictester/creational/prototype/CloneableObject.java", "last_update_at": "2020-12-13T10:58:53+00:00", "question_id": "e0d154d32d5187a23317189a6d69f59aad0505f0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CloneableObject {\n    /*\n     * This class will not use Clonable interface, as no longer recommended by Joshua Bloch\n     */\n    private List<Integer> list = new ArrayList<>();\n    // Use this constructor to create first instance\n    public CloneableObject() {\n        Random random = new Random();\n        list.add(random.nextInt(100));\n        list.add(random.nextInt(100));\n    }\n    // Use this copy constructor to clone the prototype instance\n    public CloneableObject(CloneableObject prototype) {\n        list = new ArrayList<>(prototype.list);\n    }\n    public List<Integer> getValues() {\n        return new ArrayList<>(list);\n    }\n    public void updateValues(int a, int b) {\n        list.clear();\n        list.add(a);\n        list.add(b);\n    }\n"]]}
{"hexsha": "2c53cd45c502296492f9887395805fe9669aa4a4", "ext": "java", "lang": "Java", "content": "public class StudentUI extends AppCompatActivity {\n\n    Button btn;\n    BottomNavigationView bottomNavigationView;\n    Menu itemToHide;\n    TextView cours;\n    Bundle b;\n    String coursId;\n    String nom;\n    String s;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_studentui);\n\n        b = getIntent().getExtras();\n\n        cours = (TextView) findViewById(R.id.txtdashboard2);\n        s = cours.getText().toString();\n        cours.setText(s + \" (\" + b.getString(\"name\") + \") \");\n        /*Window window = this.getWindow();\n        window.setStatusBarColor(ContextCompat.getColor(this,R.color.colorDarkRed));\n\n        ActionBar bar = getSupportActionBar();\n        bar.setBackgroundDrawable(new ColorDrawable(getResources().getColor(R.color.colorRed)));\n        bar.setTitle(\"AskNanterre : Etudiant\");*/\n\n        /*btn = (Button)findViewById(R.id.stud_btn);\n\n        btn.setOnClickListener(\n                new View.OnClickListener()\n                {\n                    public void onClick(View view)\n                    {\n                        Intent intent = new Intent(StudentUI.this, ProfessorUI.class);\n                        startActivity(intent);\n                    }\n                });*/\n\n        /*bottomNavigationView = (BottomNavigationView) findViewById(R.id.activity_main_bottom_navigation);\n        itemToHide = bottomNavigationView.getMenu();\n        itemToHide.findItem(R.id.action_goStud).setVisible(false);\n\n        bottomNavigationView.setOnNavigationItemSelectedListener(new BottomNavigationView.OnNavigationItemSelectedListener() {\n            @Override\n            public boolean onNavigationItemSelected(@NonNull MenuItem item) {\n                switch (item.getItemId()) {\n                    case R.id.action_home:\n                        //Toast.makeText(StudentUI.this, \"Recents\", Toast.LENGTH_SHORT).show();\n                        goToMainActivity();\n                        break;\n                    case R.id.action_goStud:\n                        Toast.makeText(StudentUI.this, \"Favorites\", Toast.LENGTH_SHORT).show();\n                        break;\n                    case R.id.action_goProf:\n                        //Toast.makeText(StudentUI.this, \"Nearby\", Toast.LENGTH_SHORT).show();\n                        goToProfUIActivity();\n                        break;\n                }\n                return true;\n            }\n        });*/\n        coursId = b.getString(\"key\");\n        nom =  b.getString(\"name\");\n        Log.v(\"hfhfhfhf\", coursId);\n        Log.v(\"hfhfhfhf\", nom);\n    }\n\n    /*public void displayQuestion(View v){\n        Intent intent = new Intent(this, DisplayQuestion.class);\n        startActivity(intent);\n    }*/\n\n    public void addQuestion(View v){\n        Intent intent = new Intent(this, AddQuestion.class);\n        Bundle b2 = new Bundle();\n        b2.putString(\"key\", coursId);\n        b2.putString(\"name\", nom);\n        intent.putExtras(b2);\n        startActivity(intent);\n    }\n\n    public void addQuestionQCM(View v){\n        Intent intent = new Intent(this, AddQCM.class);\n        Bundle b2 = new Bundle();\n        b2.putString(\"key\", coursId);\n        b2.putString(\"name\", nom);\n        intent.putExtras(b2);\n        startActivity(intent);\n    }\n\n    public void displayQuestionStud(View v){\n        Intent intent = new Intent(this, DisplayQuestionStud.class);\n        Bundle b2 = new Bundle();\n        b2.putString(\"key\", coursId);\n        b2.putString(\"name\", nom);\n        intent.putExtras(b2);\n        startActivity(intent);\n    }\n\n    public void goToMainActivity(View v){\n        Intent intent = new Intent(this, MainActivity.class);\n        startActivity(intent);\n    }\n\n    public void displayQuizz(View v) {\n        Intent intent = new Intent(this, DisplayQuiz.class);\n        Bundle b2 = new Bundle();\n        b2.putString(\"key\", coursId);\n        b2.putString(\"name\", nom);\n        intent.putExtras(b2);\n        startActivity(intent);\n    }\n\n    public void studentUI2(View v) {\n        Intent intent = new Intent(this, StudentUI2.class);\n        Bundle b2 = new Bundle();\n        b2.putString(\"key\", coursId);\n        b2.putString(\"name\", nom);\n        intent.putExtras(b2);\n        startActivity(intent);\n    }\n\n    public void annuler(View v) {\n        finish();\n    }\n}", "class_id": 0, "repo": "thibaultanani/AskNanterre", "file": "app/src/main/java/com/example/asknanterre/StudentUI.java", "last_update_at": "2020-03-17T21:56:08+00:00", "question_id": "2c53cd45c502296492f9887395805fe9669aa4a4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class StudentUI extends AppCompatActivity {\n    Button btn;\n    BottomNavigationView bottomNavigationView;\n    Menu itemToHide;\n    TextView cours;\n    Bundle b;\n    String coursId;\n    String nom;\n    String s;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_studentui);\n        b = getIntent().getExtras();\n        cours = (TextView) findViewById(R.id.txtdashboard2);\n        s = cours.getText().toString();\n        cours.setText(s + \" (\" + b.getString(\"name\") + \") \");\n        /*Window window = this.getWindow();\n        window.setStatusBarColor(ContextCompat.getColor(this,R.color.colorDarkRed));\n        ActionBar bar = getSupportActionBar();\n        bar.setBackgroundDrawable(new ColorDrawable(getResources().getColor(R.color.colorRed)));\n        bar.setTitle(\"AskNanterre : Etudiant\");*/\n        /*btn = (Button)findViewById(R.id.stud_btn);\n        btn.setOnClickListener(\n                new View.OnClickListener()\n                {\n                    public void onClick(View view)\n                    {\n                        Intent intent = new Intent(StudentUI.this, ProfessorUI.class);\n                        startActivity(intent);\n                    }\n                });*/\n        /*bottomNavigationView = (BottomNavigationView) findViewById(R.id.activity_main_bottom_navigation);\n        itemToHide = bottomNavigationView.getMenu();\n        itemToHide.findItem(R.id.action_goStud).setVisible(false);\n        bottomNavigationView.setOnNavigationItemSelectedListener(new BottomNavigationView.OnNavigationItemSelectedListener() {\n            @Override\n            public boolean onNavigationItemSelected(@NonNull MenuItem item) {\n                switch (item.getItemId()) {\n                    case R.id.action_home:\n                        //Toast.makeText(StudentUI.this, \"Recents\", Toast.LENGTH_SHORT).show();\n                        goToMainActivity();\n                        break;\n                    case R.id.action_goStud:\n                        Toast.makeText(StudentUI.this, \"Favorites\", Toast.LENGTH_SHORT).show();\n                        break;\n                    case R.id.action_goProf:\n                        //Toast.makeText(StudentUI.this, \"Nearby\", Toast.LENGTH_SHORT).show();\n                        goToProfUIActivity();\n                        break;\n                }\n                return true;\n            }\n        });*/\n        coursId = b.getString(\"key\");\n        nom =  b.getString(\"name\");\n        Log.v(\"hfhfhfhf\", coursId);\n        Log.v(\"hfhfhfhf\", nom);\n    }\n    /*public void displayQuestion(View v){\n        Intent intent = new Intent(this, DisplayQuestion.class);\n        startActivity(intent);\n    }*/\n    public void addQuestion(View v){\n        Intent intent = new Intent(this, AddQuestion.class);\n        Bundle b2 = new Bundle();\n        b2.putString(\"key\", coursId);\n        b2.putString(\"name\", nom);\n        intent.putExtras(b2);\n        startActivity(intent);\n    }\n    public void addQuestionQCM(View v){\n        Intent intent = new Intent(this, AddQCM.class);\n        Bundle b2 = new Bundle();\n        b2.putString(\"key\", coursId);\n        b2.putString(\"name\", nom);\n        intent.putExtras(b2);\n        startActivity(intent);\n    }\n    public void displayQuestionStud(View v){\n        Intent intent = new Intent(this, DisplayQuestionStud.class);\n        Bundle b2 = new Bundle();\n        b2.putString(\"key\", coursId);\n        b2.putString(\"name\", nom);\n        intent.putExtras(b2);\n        startActivity(intent);\n    }\n    public void goToMainActivity(View v){\n        Intent intent = new Intent(this, MainActivity.class);\n        startActivity(intent);\n    }\n    public void displayQuizz(View v) {\n        Intent intent = new Intent(this, DisplayQuiz.class);\n        Bundle b2 = new Bundle();\n        b2.putString(\"key\", coursId);\n        b2.putString(\"name\", nom);\n        intent.putExtras(b2);\n        startActivity(intent);\n    }\n    public void studentUI2(View v) {\n        Intent intent = new Intent(this, StudentUI2.class);\n        Bundle b2 = new Bundle();\n        b2.putString(\"key\", coursId);\n        b2.putString(\"name\", nom);\n        intent.putExtras(b2);\n        startActivity(intent);\n    }\n    public void annuler(View v) {\n        finish();\n    }\n"]]}
{"hexsha": "a531e8e5dd6ef60b560a68a191fb4dfe77885d45", "ext": "java", "lang": "Java", "content": "@Metadata(bv = {1, 0, 3}, d1 = {\"\\u0000.\\n\\u0002\\u0018\\u0002\\n\\u0002\\u0018\\u0002\\n\\u0000\\n\\u0002\\u0010\\b\\n\\u0000\\n\\u0002\\u0010\\u000e\\n\\u0002\\b\\u0002\\n\\u0002\\u0018\\u0002\\n\\u0002\\b\\u0003\\n\\u0002\\u0018\\u0002\\n\\u0000\\n\\u0002\\u0010\\u0002\\n\\u0002\\b\\u0002\\b\\u0000\\u0018\\u00002\\u00020\\u0001B\\u0017\\b\\u0000\\u0012\\u0006\\u0010\\u0002\\u001a\\u00020\\u0003\\u0012\\u0006\\u0010\\u0004\\u001a\\u00020\\u0005\u00a2\\u0006\\u0002\\u0010\\u0006J\\b\\u0010\\r\\u001a\\u00020\\u000eH\\u0016J\\b\\u0010\\u000f\\u001a\\u00020\\u0005H\\u0016R\\u0014\\u0010\\u0007\\u001a\\u00020\\bX\u0096\\u0004\u00a2\\u0006\\b\\n\\u0000\\u001a\\u0004\\b\\t\\u0010\\nR\\u000e\\u0010\\u0002\\u001a\\u00020\\u0003X\u0082\\u0004\u00a2\\u0006\\u0002\\n\\u0000R\\u000e\\u0010\\u0004\\u001a\\u00020\\u0005X\u0082\\u0004\u00a2\\u0006\\u0002\\n\\u0000R\\u000e\\u0010\\u000b\\u001a\\u00020\\fX\u0082\\u0004\u00a2\\u0006\\u0002\\n\\u0000\u00a8\\u0006\\u0010\"}, d2 = {\"Lkotlinx/coroutines/ThreadPoolDispatcher;\", \"Lkotlinx/coroutines/ExecutorCoroutineDispatcherBase;\", \"nThreads\", \"\", \"name\", \"\", \"(ILjava/lang/String;)V\", \"executor\", \"Ljava/util/concurrent/Executor;\", \"getExecutor\", \"()Ljava/util/concurrent/Executor;\", \"threadNo\", \"Ljava/util/concurrent/atomic/AtomicInteger;\", \"close\", \"\", \"toString\", \"kotlinx-coroutines-core\"}, k = 1, mv = {1, 1, 16})\n/* compiled from: ThreadPoolDispatcher.kt */\npublic final class ThreadPoolDispatcher extends ExecutorCoroutineDispatcherBase {\n    private final Executor executor = Executors.newScheduledThreadPool(this.nThreads, new ThreadPoolDispatcher$executor$1(this));\n    /* access modifiers changed from: private */\n    public final int nThreads;\n    /* access modifiers changed from: private */\n    public final String name;\n    /* access modifiers changed from: private */\n    public final AtomicInteger threadNo = new AtomicInteger();\n\n    public ThreadPoolDispatcher(int i, String str) {\n        this.nThreads = i;\n        this.name = str;\n        initFutureCancellation$kotlinx_coroutines_core();\n    }\n\n    public Executor getExecutor() {\n        return this.executor;\n    }\n\n    public void close() {\n        Executor executor2 = getExecutor();\n        if (executor2 != null) {\n            ((ExecutorService) executor2).shutdown();\n            return;\n        }\n        throw new TypeCastException(\"null cannot be cast to non-null type java.util.concurrent.ExecutorService\");\n    }\n\n    public String toString() {\n        return \"ThreadPoolDispatcher[\" + this.nThreads + \", \" + this.name + ']';\n    }\n}", "class_id": 0, "repo": "ghuntley/COVIDSafe_1.0.11.apk", "file": "src/sources/kotlinx/coroutines/ThreadPoolDispatcher.java", "last_update_at": "2020-05-08T12:59:45+00:00", "question_id": "a531e8e5dd6ef60b560a68a191fb4dfe77885d45", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Metadata(bv = {1, 0, 3}, d1 = {\"\\u0000.\\n\\u0002\\u0018\\u0002\\n\\u0002\\u0018\\u0002\\n\\u0000\\n\\u0002\\u0010\\b\\n\\u0000\\n\\u0002\\u0010\\u000e\\n\\u0002\\b\\u0002\\n\\u0002\\u0018\\u0002\\n\\u0002\\b\\u0003\\n\\u0002\\u0018\\u0002\\n\\u0000\\n\\u0002\\u0010\\u0002\\n\\u0002\\b\\u0002\\b\\u0000\\u0018\\u00002\\u00020\\u0001B\\u0017\\b\\u0000\\u0012\\u0006\\u0010\\u0002\\u001a\\u00020\\u0003\\u0012\\u0006\\u0010\\u0004\\u001a\\u00020\\u0005\u00a2\\u0006\\u0002\\u0010\\u0006J\\b\\u0010\\r\\u001a\\u00020\\u000eH\\u0016J\\b\\u0010\\u000f\\u001a\\u00020\\u0005H\\u0016R\\u0014\\u0010\\u0007\\u001a\\u00020\\bX\u0096\\u0004\u00a2\\u0006\\b\\n\\u0000\\u001a\\u0004\\b\\t\\u0010\\nR\\u000e\\u0010\\u0002\\u001a\\u00020\\u0003X\u0082\\u0004\u00a2\\u0006\\u0002\\n\\u0000R\\u000e\\u0010\\u0004\\u001a\\u00020\\u0005X\u0082\\u0004\u00a2\\u0006\\u0002\\n\\u0000R\\u000e\\u0010\\u000b\\u001a\\u00020\\fX\u0082\\u0004\u00a2\\u0006\\u0002\\n\\u0000\u00a8\\u0006\\u0010\"}, d2 = {\"Lkotlinx/coroutines/ThreadPoolDispatcher;\", \"Lkotlinx/coroutines/ExecutorCoroutineDispatcherBase;\", \"nThreads\", \"\", \"name\", \"\", \"(ILjava/lang/String;)V\", \"executor\", \"Ljava/util/concurrent/Executor;\", \"getExecutor\", \"()Ljava/util/concurrent/Executor;\", \"threadNo\", \"Ljava/util/concurrent/atomic/AtomicInteger;\", \"close\", \"\", \"toString\", \"kotlinx-coroutines-core\"}, k = 1, mv = {1, 1, 16})\n/* compiled from: ThreadPoolDispatcher.kt */\npublic final class ThreadPoolDispatcher extends ExecutorCoroutineDispatcherBase {\n    private final Executor executor = Executors.newScheduledThreadPool(this.nThreads, new ThreadPoolDispatcher$executor$1(this));\n    /* access modifiers changed from: private */\n    public final int nThreads;\n    /* access modifiers changed from: private */\n    public final String name;\n    /* access modifiers changed from: private */\n    public final AtomicInteger threadNo = new AtomicInteger();\n    public ThreadPoolDispatcher(int i, String str) {\n        this.nThreads = i;\n        this.name = str;\n        initFutureCancellation$kotlinx_coroutines_core();\n    }\n    public Executor getExecutor() {\n        return this.executor;\n    }\n    public void close() {\n        Executor executor2 = getExecutor();\n        if (executor2 != null) {\n            ((ExecutorService) executor2).shutdown();\n            return;\n        }\n        throw new TypeCastException(\"null cannot be cast to non-null type java.util.concurrent.ExecutorService\");\n    }\n    public String toString() {\n        return \"ThreadPoolDispatcher[\" + this.nThreads + \", \" + this.name + ']';\n    }\n"]]}
{"hexsha": "10c93aeb12da1035e98a942007e4deb03fbb9355", "ext": "java", "lang": "Java", "content": "class GfG\n{\n    \n    static final int INT_BITS = 32; \n     public static int maxSubarrayXOR(int set[], int n)\n    {\n                    \n    int index = 0; \n   \n    for (int i = INT_BITS - 1; i >= 0; i--)  \n    { \n    \n    int maxInd = index; \n    int maxEle = Integer.MIN_VALUE; \n    for (int j = index; j < n; j++) { \n       \n        if ((set[j] & (1 << i)) != 0 && set[j] > maxEle) \n        { \n        maxEle = set[j]; \n        maxInd = j; \n        } \n    } \n    \n    if (maxEle == -2147483648) \n        continue; \n  \n    int temp = set[index]; \n    set[index] = set[maxInd]; \n    set[maxInd] = temp; \n    maxInd = index; \n    for (int j = 0; j < n; j++) { \n      \n        if (j != maxInd && (set[j] & (1 << i)) != 0) \n        set[j] = set[j] ^ set[maxInd]; \n    } \n    index++; \n    }\n    \n    \n    int res = 0; \n    for (int i = 0; i < n; i++) \n    {res ^= set[i]; }\n    return res; \n}\n    \n}", "class_id": 1, "repo": "kritika-srivastava/Competitive-Programming", "file": "Geeks for Geeks/XOR.java", "last_update_at": "2020-05-03T07:32:12+00:00", "question_id": "10c93aeb12da1035e98a942007e4deb03fbb9355", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class GfG\n{\n    static final int INT_BITS = 32; \n     public static int maxSubarrayXOR(int set[], int n)\n    {\n    int index = 0; \n    for (int i = INT_BITS - 1; i >= 0; i--)  \n    { \n    int maxInd = index; \n    int maxEle = Integer.MIN_VALUE; \n    for (int j = index; j < n; j++) { \n        if ((set[j] & (1 << i)) != 0 && set[j] > maxEle) \n        { \n        maxEle = set[j]; \n        maxInd = j; \n        } \n    } \n    if (maxEle == -2147483648) \n        continue; \n    int temp = set[index]; \n    set[index] = set[maxInd]; \n    set[maxInd] = temp; \n    maxInd = index; \n    for (int j = 0; j < n; j++) { \n        if (j != maxInd && (set[j] & (1 << i)) != 0) \n        set[j] = set[j] ^ set[maxInd]; \n    } \n    index++; \n    }\n    int res = 0; \n    for (int i = 0; i < n; i++) \n    {res ^= set[i]; }\n    return res; \n}\n"]]}
{"hexsha": "57db1192d2446002c9cfe621d32debd52bbb6de8", "ext": "java", "lang": "Java", "content": "public class LocationService extends Service {\n    private static final String TAG = \"LocationService\";\n    public static final String PREFS_NAME = \"LocationServicePrefs\";\n    public static final String PREF_IS_STARTED = \"isStarted\";\n\n    private static final int NOTIFICATION_ID = 1001;\n    private static final String NOTIFICATION_CHANNEL_ID = \"PrivateKitChannel\";\n    private static final String NOTIFICATION_CHANNEL_NAME = \"Notification channel for PrivateKit\";\n\n    private static final int LOCATION_INTERVAL = 1000;\n    private static final float LOCATION_DISTANCE = 0f;\n\n    public static boolean IS_RUNNING = false;\n\n    private LocationManager locationManager = null;\n    private LocationListener locationListenerFine = new LocationListener();\n    private LocationListener locationListenerCoarse = new LocationListener();\n    private LocationWriter locationWriter = new LocationWriter();\n\n    public static void start(@NonNull Context context) {\n        Intent intent = new Intent(context, LocationService.class);\n        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {\n            context.startForegroundService(intent);\n        } else {\n            context.startService(intent);\n        }\n    }\n\n    public static void stop(@NonNull Context context) {\n        Intent intent = new Intent(context, LocationService.class);\n        context.stopService(intent);\n    }\n\n    private class LocationListener implements android.location.LocationListener {\n        @Override\n        public void onLocationChanged(Location location) {\n            Log.d(TAG, \"onLocationChanged: \" + location);\n            try {\n                locationWriter.addPoint(LocationService.this, location, new Date());\n            } catch (Exception e) {\n                e.printStackTrace();\n                Toast.makeText(LocationService.this, getString(R.string.error_file_write, e.getLocalizedMessage()), Toast.LENGTH_LONG).show();\n            }\n        }\n\n        @Override\n        public void onProviderDisabled(String provider) {\n            Log.d(TAG, \"onProviderDisabled: \" + provider);\n        }\n\n        @Override\n        public void onProviderEnabled(String provider) {\n            Log.d(TAG, \"onProviderEnabled: \" + provider);\n        }\n\n        @Override\n        public void onStatusChanged(String provider, int status, Bundle extras) {\n            Log.d(TAG, \"onStatusChanged: \" + provider);\n        }\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        Log.d(TAG, \"onStartCommand\");\n        super.onStartCommand(intent, flags, startId);\n        return START_STICKY;\n    }\n\n    @Override\n    public void onCreate() {\n        Log.d(TAG, \"onCreate\");\n\n        if (locationManager == null) {\n            locationManager = (LocationManager) getApplicationContext().getSystemService(Context.LOCATION_SERVICE);\n        }\n\n        startForeground(NOTIFICATION_ID, createNotification());\n\n        try {\n            locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER,\n                    LOCATION_INTERVAL, LOCATION_DISTANCE, locationListenerFine);\n        } catch (SecurityException | IllegalArgumentException e) {\n            e.printStackTrace();\n            Toast.makeText(LocationService.this, getString(R.string.error_file_write, e.getLocalizedMessage()), Toast.LENGTH_LONG).show();\n        }\n\n        try {\n            locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER,\n                    LOCATION_INTERVAL * 2, LOCATION_DISTANCE, locationListenerCoarse);\n        } catch (SecurityException | IllegalArgumentException e) {\n            e.printStackTrace();\n            Toast.makeText(LocationService.this, getString(R.string.error_file_write, e.getLocalizedMessage()), Toast.LENGTH_LONG).show();\n        }\n\n        persistStartedState(true);\n    }\n\n    @Override\n    public void onDestroy() {\n        persistStartedState(false);\n        Log.d(TAG, \"onDestroy\");\n        super.onDestroy();\n        if (locationManager != null) {\n            try {\n                locationManager.removeUpdates(locationListenerFine);\n            } catch (Exception e) {\n                // ignore\n            }\n            try {\n                locationManager.removeUpdates(locationListenerCoarse);\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n        if (locationWriter != null) {\n            locationWriter.close();\n        }\n    }\n\n    private Notification createNotification() {\n        NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n\n        if (notificationManager != null\n                && android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {\n            NotificationChannel notificationChannel = notificationManager.getNotificationChannel(NOTIFICATION_CHANNEL_ID);\n            if (notificationChannel == null) {\n                notificationChannel = new NotificationChannel(NOTIFICATION_CHANNEL_ID, NOTIFICATION_CHANNEL_NAME, NotificationManager.IMPORTANCE_DEFAULT);\n                notificationManager.createNotificationChannel(notificationChannel);\n            }\n        }\n\n        NotificationCompat.Builder builder = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID)\n                .setSmallIcon(R.drawable.ic_my_location_black_24dp)\n                .setContentIntent(PendingIntent.getActivity(this, 0, new Intent(this, MainActivity.class), PendingIntent.FLAG_UPDATE_CURRENT))\n                .setContentTitle(getString(R.string.notification_title))\n                .setContentText(getString(R.string.notification_text))\n                .setAutoCancel(false);\n        return builder.build();\n    }\n\n    private void persistStartedState(boolean started) {\n        IS_RUNNING = started;\n        SharedPreferences prefs = getApplicationContext().getSharedPreferences(PREFS_NAME, 0);\n        SharedPreferences.Editor editor = prefs.edit();\n        editor.putBoolean(PREF_IS_STARTED, started);\n        editor.apply();\n    }\n}", "class_id": 0, "repo": "dbrant/privatekit", "file": "app/src/main/java/edu/mit/privatekit/LocationService.java", "last_update_at": "2020-03-29T11:24:27+00:00", "question_id": "57db1192d2446002c9cfe621d32debd52bbb6de8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LocationService extends Service {\n    private static final String TAG = \"LocationService\";\n    public static final String PREFS_NAME = \"LocationServicePrefs\";\n    public static final String PREF_IS_STARTED = \"isStarted\";\n    private static final int NOTIFICATION_ID = 1001;\n    private static final String NOTIFICATION_CHANNEL_ID = \"PrivateKitChannel\";\n    private static final String NOTIFICATION_CHANNEL_NAME = \"Notification channel for PrivateKit\";\n    private static final int LOCATION_INTERVAL = 1000;\n    private static final float LOCATION_DISTANCE = 0f;\n    public static boolean IS_RUNNING = false;\n    private LocationManager locationManager = null;\n    private LocationListener locationListenerFine = new LocationListener();\n    private LocationListener locationListenerCoarse = new LocationListener();\n    private LocationWriter locationWriter = new LocationWriter();\n    public static void start(@NonNull Context context) {\n        Intent intent = new Intent(context, LocationService.class);\n        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {\n            context.startForegroundService(intent);\n        } else {\n            context.startService(intent);\n        }\n    }\n    public static void stop(@NonNull Context context) {\n        Intent intent = new Intent(context, LocationService.class);\n        context.stopService(intent);\n    }\n    private class LocationListener implements android.location.LocationListener {\n        @Override\n        public void onLocationChanged(Location location) {\n            Log.d(TAG, \"onLocationChanged: \" + location);\n            try {\n                locationWriter.addPoint(LocationService.this, location, new Date());\n            } catch (Exception e) {\n                e.printStackTrace();\n                Toast.makeText(LocationService.this, getString(R.string.error_file_write, e.getLocalizedMessage()), Toast.LENGTH_LONG).show();\n            }\n        }\n        @Override\n        public void onProviderDisabled(String provider) {\n            Log.d(TAG, \"onProviderDisabled: \" + provider);\n        }\n        @Override\n        public void onProviderEnabled(String provider) {\n            Log.d(TAG, \"onProviderEnabled: \" + provider);\n        }\n        @Override\n        public void onStatusChanged(String provider, int status, Bundle extras) {\n            Log.d(TAG, \"onStatusChanged: \" + provider);\n        }\n    }\n    @Override\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        Log.d(TAG, \"onStartCommand\");\n        super.onStartCommand(intent, flags, startId);\n        return START_STICKY;\n    }\n    @Override\n    public void onCreate() {\n        Log.d(TAG, \"onCreate\");\n        if (locationManager == null) {\n            locationManager = (LocationManager) getApplicationContext().getSystemService(Context.LOCATION_SERVICE);\n        }\n        startForeground(NOTIFICATION_ID, createNotification());\n        try {\n            locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER,\n                    LOCATION_INTERVAL, LOCATION_DISTANCE, locationListenerFine);\n        } catch (SecurityException | IllegalArgumentException e) {\n            e.printStackTrace();\n            Toast.makeText(LocationService.this, getString(R.string.error_file_write, e.getLocalizedMessage()), Toast.LENGTH_LONG).show();\n        }\n        try {\n            locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER,\n                    LOCATION_INTERVAL * 2, LOCATION_DISTANCE, locationListenerCoarse);\n        } catch (SecurityException | IllegalArgumentException e) {\n            e.printStackTrace();\n            Toast.makeText(LocationService.this, getString(R.string.error_file_write, e.getLocalizedMessage()), Toast.LENGTH_LONG).show();\n        }\n        persistStartedState(true);\n    }\n    @Override\n    public void onDestroy() {\n        persistStartedState(false);\n        Log.d(TAG, \"onDestroy\");\n        super.onDestroy();\n        if (locationManager != null) {\n            try {\n                locationManager.removeUpdates(locationListenerFine);\n            } catch (Exception e) {\n                // ignore\n            }\n            try {\n                locationManager.removeUpdates(locationListenerCoarse);\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n        if (locationWriter != null) {\n            locationWriter.close();\n        }\n    }\n    private Notification createNotification() {\n        NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n        if (notificationManager != null\n                && android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {\n            NotificationChannel notificationChannel = notificationManager.getNotificationChannel(NOTIFICATION_CHANNEL_ID);\n            if (notificationChannel == null) {\n                notificationChannel = new NotificationChannel(NOTIFICATION_CHANNEL_ID, NOTIFICATION_CHANNEL_NAME, NotificationManager.IMPORTANCE_DEFAULT);\n                notificationManager.createNotificationChannel(notificationChannel);\n            }\n        }\n        NotificationCompat.Builder builder = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID)\n                .setSmallIcon(R.drawable.ic_my_location_black_24dp)\n                .setContentIntent(PendingIntent.getActivity(this, 0, new Intent(this, MainActivity.class), PendingIntent.FLAG_UPDATE_CURRENT))\n                .setContentTitle(getString(R.string.notification_title))\n                .setContentText(getString(R.string.notification_text))\n                .setAutoCancel(false);\n        return builder.build();\n    }\n    private void persistStartedState(boolean started) {\n        IS_RUNNING = started;\n        SharedPreferences prefs = getApplicationContext().getSharedPreferences(PREFS_NAME, 0);\n        SharedPreferences.Editor editor = prefs.edit();\n        editor.putBoolean(PREF_IS_STARTED, started);\n        editor.apply();\n    }\n"]]}
{"hexsha": "4f232995aa7f5e7eba5cfc2f2d2939b6e8451734", "ext": "java", "lang": "Java", "content": "public class Strings1 {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        // TODO code application logic here\n        \n        String S = \"Lorem at\";\n        int n = S.length();\n        \n        int k = 0;\n        \n        //determine if the string length is odd or even\n        if (n % 2 == 0) {\n            k = 4;\n        } else {\n            k = 3;\n        }\n        \n        //function to transform the string\n        String transformedString = transformString(S, k, n);\n        \n        System.out.println(transformedString);\n    }\n    \n    public static String transformString (String S, int k, int n) {\n        for (int i = 0; i < n;) {\n            if (i + k > n)\n                break;\n            \n            S = S.substring(0, i) + new String(new StringBuilder(\n                   S.substring(i, i + k)).reverse()) +\n                   S.substring(i + k);\n            \n            i += k; \n        }\n        \n        return S;\n    }\n    \n}", "class_id": 0, "repo": "morrisonmburu/Zeraki_Assessment", "file": "question2/question2Algorithm/src/strings1/Strings1.java", "last_update_at": "2020-09-08T08:16:17+00:00", "question_id": "4f232995aa7f5e7eba5cfc2f2d2939b6e8451734", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Strings1 {\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        // TODO code application logic here\n        String S = \"Lorem at\";\n        int n = S.length();\n        int k = 0;\n        //determine if the string length is odd or even\n        if (n % 2 == 0) {\n            k = 4;\n        } else {\n            k = 3;\n        }\n        //function to transform the string\n        String transformedString = transformString(S, k, n);\n        System.out.println(transformedString);\n    }\n    public static String transformString (String S, int k, int n) {\n        for (int i = 0; i < n;) {\n            if (i + k > n)\n                break;\n            S = S.substring(0, i) + new String(new StringBuilder(\n                   S.substring(i, i + k)).reverse()) +\n                   S.substring(i + k);\n            i += k; \n        }\n        return S;\n    }\n"]]}
{"hexsha": "6ecd3c9cf1c74b3510dfb62b8964bb14543fe450", "ext": "java", "lang": "Java", "content": "class CallOrRunMV extends LocalVariablesSorter implements Opcodes {\n\tprivate static final String TARGET = TraceMain.class.getName().replace('.', '/');\n\tprivate static final String START_METHOD = \"callRunnableCallInvoked\";\n\tprivate static final String START_SIGNATURE = \"(Ljava/lang/Object;)Ljava/lang/Object;\";\n\n\tprivate static final String END_METHOD = \"callRunnableCallEnd\";\n\tprivate static final String END_METHOD_DESC = \"(\" +\n\t\t\t\"Ljava/lang/Object;\" +\n\t\t\t\"Ljava/lang/Object;\" +\n\t\t\t\"Ljava/lang/Throwable;\" +\n\t\t\t\")V\";\n\n\tprivate Label startFinally = new Label();\n\tprivate Type returnType;\n\tString name;\n\tString desc;\n\tprivate int statIdx;\n\n\tpublic CallOrRunMV(int access, String name, String desc, MethodVisitor mv) {\n\t\tsuper(ASM5, access, desc, mv);\n\t\tthis.name = name;\n\t\tthis.desc = desc;\n\t\tthis.returnType = Type.getReturnType(desc);\n\t}\n\n\t@Override\n\tpublic void visitCode() {\n\t\tmv.visitVarInsn(Opcodes.ALOAD, 0);\n\t\tmv.visitMethodInsn(Opcodes.INVOKESTATIC, TARGET, START_METHOD, START_SIGNATURE, false);\n\n\t\tstatIdx = newLocal(Type.getType(Object.class));\n\t\tmv.visitVarInsn(Opcodes.ASTORE, statIdx);\n\t\tmv.visitLabel(startFinally);\n\t\tmv.visitCode();\n\t}\n\n\t@Override\n\tpublic void visitInsn(int opcode) {\n\t\tif ((opcode >= IRETURN && opcode <= RETURN)) {\n\t\t\tcapReturn();\n\t\t}\n\t\tmv.visitInsn(opcode);\n\t}\n\n\tprivate void capReturn() {\n\t\tType tp = returnType;\n\n\t\tif (tp == null || tp.equals(Type.VOID_TYPE)) {\n\t\t\tmv.visitInsn(Opcodes.ACONST_NULL);\n\t\t\tmv.visitVarInsn(Opcodes.ALOAD, statIdx);\n\t\t\tmv.visitInsn(Opcodes.ACONST_NULL);\n\t\t\tmv.visitMethodInsn(Opcodes.INVOKESTATIC, TARGET, END_METHOD, END_METHOD_DESC, false);\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (tp.getSort()) {\n\t\t\tcase Type.DOUBLE:\n\t\t\tcase Type.LONG:\n\t\t\t\tmv.visitInsn(Opcodes.DUP2);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmv.visitInsn(Opcodes.DUP);\n\t\t}\n\t\t// TODO method return test dup and store\n//\t\tint rtnIdx = newLocal(tp);\n//\t\tmv.visitVarInsn(Opcodes.ASTORE, rtnIdx);\n//\t\tmv.visitVarInsn(Opcodes.ALOAD, rtnIdx);\n\n\t\tmv.visitVarInsn(Opcodes.ALOAD, statIdx);// stat\n\t\tmv.visitInsn(Opcodes.ACONST_NULL);// throwable\n\t\tmv.visitMethodInsn(Opcodes.INVOKESTATIC, TARGET, END_METHOD, END_METHOD_DESC, false);\n\t}\n\n\t@Override\n\tpublic void visitMaxs(int maxStack, int maxLocals) {\n\t\tLabel endFinally = new Label();\n\t\tmv.visitTryCatchBlock(startFinally, endFinally, endFinally, null);\n\t\tmv.visitLabel(endFinally);\n\t\tmv.visitInsn(DUP);\n\t\tint errIdx = newLocal(Type.getType(Throwable.class));\n\t\tmv.visitVarInsn(Opcodes.ASTORE, errIdx);\n\n\t\tmv.visitInsn(Opcodes.ACONST_NULL);// return\n\t\tmv.visitVarInsn(Opcodes.ALOAD, statIdx);\n\t\tmv.visitVarInsn(Opcodes.ALOAD, errIdx);\n\t\tmv.visitMethodInsn(Opcodes.INVOKESTATIC, TARGET, END_METHOD, END_METHOD_DESC,false);\n\t\tmv.visitInsn(ATHROW);\n\t\tmv.visitMaxs(maxStack + 8, maxLocals + 2);\n\t}\n}", "class_id": 2, "repo": "LAKSEUNG/scouter", "file": "scouter.agent.java/src/main/java/scouter/agent/asm/asyncsupport/CallRunnableASM.java", "last_update_at": "2020-07-27T11:09:58+00:00", "question_id": "6ecd3c9cf1c74b3510dfb62b8964bb14543fe450", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class CallOrRunMV extends LocalVariablesSorter implements Opcodes {\n\tprivate static final String TARGET = TraceMain.class.getName().replace('.', '/');\n\tprivate static final String START_METHOD = \"callRunnableCallInvoked\";\n\tprivate static final String START_SIGNATURE = \"(Ljava/lang/Object;)Ljava/lang/Object;\";\n\tprivate static final String END_METHOD = \"callRunnableCallEnd\";\n\tprivate static final String END_METHOD_DESC = \"(\" +\n\t\t\t\"Ljava/lang/Object;\" +\n\t\t\t\"Ljava/lang/Object;\" +\n\t\t\t\"Ljava/lang/Throwable;\" +\n\t\t\t\")V\";\n\tprivate Label startFinally = new Label();\n\tprivate Type returnType;\n\tString name;\n\tString desc;\n\tprivate int statIdx;\n\tpublic CallOrRunMV(int access, String name, String desc, MethodVisitor mv) {\n\t\tsuper(ASM5, access, desc, mv);\n\t\tthis.name = name;\n\t\tthis.desc = desc;\n\t\tthis.returnType = Type.getReturnType(desc);\n\t}\n\t@Override\n\tpublic void visitCode() {\n\t\tmv.visitVarInsn(Opcodes.ALOAD, 0);\n\t\tmv.visitMethodInsn(Opcodes.INVOKESTATIC, TARGET, START_METHOD, START_SIGNATURE, false);\n\t\tstatIdx = newLocal(Type.getType(Object.class));\n\t\tmv.visitVarInsn(Opcodes.ASTORE, statIdx);\n\t\tmv.visitLabel(startFinally);\n\t\tmv.visitCode();\n\t}\n\t@Override\n\tpublic void visitInsn(int opcode) {\n\t\tif ((opcode >= IRETURN && opcode <= RETURN)) {\n\t\t\tcapReturn();\n\t\t}\n\t\tmv.visitInsn(opcode);\n\t}\n\tprivate void capReturn() {\n\t\tType tp = returnType;\n\t\tif (tp == null || tp.equals(Type.VOID_TYPE)) {\n\t\t\tmv.visitInsn(Opcodes.ACONST_NULL);\n\t\t\tmv.visitVarInsn(Opcodes.ALOAD, statIdx);\n\t\t\tmv.visitInsn(Opcodes.ACONST_NULL);\n\t\t\tmv.visitMethodInsn(Opcodes.INVOKESTATIC, TARGET, END_METHOD, END_METHOD_DESC, false);\n\t\t\treturn;\n\t\t}\n\t\tswitch (tp.getSort()) {\n\t\t\tcase Type.DOUBLE:\n\t\t\tcase Type.LONG:\n\t\t\t\tmv.visitInsn(Opcodes.DUP2);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmv.visitInsn(Opcodes.DUP);\n\t\t}\n\t\t// TODO method return test dup and store\n//\t\tint rtnIdx = newLocal(tp);\n//\t\tmv.visitVarInsn(Opcodes.ASTORE, rtnIdx);\n//\t\tmv.visitVarInsn(Opcodes.ALOAD, rtnIdx);\n\t\tmv.visitVarInsn(Opcodes.ALOAD, statIdx);// stat\n\t\tmv.visitInsn(Opcodes.ACONST_NULL);// throwable\n\t\tmv.visitMethodInsn(Opcodes.INVOKESTATIC, TARGET, END_METHOD, END_METHOD_DESC, false);\n\t}\n\t@Override\n\tpublic void visitMaxs(int maxStack, int maxLocals) {\n\t\tLabel endFinally = new Label();\n\t\tmv.visitTryCatchBlock(startFinally, endFinally, endFinally, null);\n\t\tmv.visitLabel(endFinally);\n\t\tmv.visitInsn(DUP);\n\t\tint errIdx = newLocal(Type.getType(Throwable.class));\n\t\tmv.visitVarInsn(Opcodes.ASTORE, errIdx);\n\t\tmv.visitInsn(Opcodes.ACONST_NULL);// return\n\t\tmv.visitVarInsn(Opcodes.ALOAD, statIdx);\n\t\tmv.visitVarInsn(Opcodes.ALOAD, errIdx);\n\t\tmv.visitMethodInsn(Opcodes.INVOKESTATIC, TARGET, END_METHOD, END_METHOD_DESC,false);\n\t\tmv.visitInsn(ATHROW);\n\t\tmv.visitMaxs(maxStack + 8, maxLocals + 2);\n\t}\n"]]}
{"hexsha": "ed3525f8f3bb66c3f83adfa5c52acc8b6fe5a527", "ext": "java", "lang": "Java", "content": "public class EquivalenceSetGraphAnalyser {\n\n\tprivate static Logger logger = LoggerFactory.getLogger(EquivalenceSetGraphBuilderImpl.class);\n\n\tpublic static void countBlankNodes(RocksDBBackedEquivalenceSetGraph esg) throws IOException {\n\n\t\tlogger.info(\"Counting number of BlankNodes\");\n\t\tint processed = 0;\n\n\t\tint numberOfBlankNodes = 0;\n\t\tint toProcess = esg.ID.keySet().size();\n\n\t\tSet<Long> es_with_bn = new HashSet<>();\n\n\t\tIterator<Entry<String, Long>> iterator = esg.ID.iterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tif (processed % 10000 == 0) {\n\t\t\t\tlogger.info(\"Processed {}/{}:{}\", processed, toProcess, ((double) processed / (double) toProcess));\n\t\t\t}\n\t\t\tprocessed++;\n\t\t\tEntry<String, Long> entry = (Entry<String, Long>) iterator.next();\n\t\t\tif (isBlankNode(entry.getKey())) {\n\t\t\t\tnumberOfBlankNodes++;\n\t\t\t\tes_with_bn.add(entry.getValue());\n\t\t\t}\n\t\t}\n\t\tesg.getStats().bns = numberOfBlankNodes;\n\t\tesg.getStats().es_with_bns = es_with_bn.size();\n\n\t}\n\n\tpublic static void countObservedEntitiesWithEmptyExtesion(RocksDBBackedEquivalenceSetGraph esg) {\n\t\tlogger.info(\"Counting Number of Observed Entities With Empty Extension\");\n\t\tlong result = 0;\n\t\tlong result_without_bn = 0;\n\t\tIterator<Entry<String, Long>> it = esg.oe_size.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tEntry<String, Long> e = it.next();\n\t\t\tif (e.getValue() == 0) {\n\t\t\t\tresult++;\n\t\t\t\tif (!isBlankNode(e.getKey())) {\n\t\t\t\t\tresult_without_bn++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tesg.getStats().oe0 = result;\n\t\tesg.getStats().oe0_bns = result_without_bn;\n\t}\n\n\tpublic static void computeDistributionOfExtensionalSizeOfEquivalenceSets(RocksDBBackedEquivalenceSetGraph esg) {\n\n\t\tlogger.info(\"Computing Statistics on Extensional Size of Equivalence Sets\");\n\t\tMap<Long, Long> result = new HashMap<>();\n\t\tMap<Long, Long> resultPerThreshold = new HashMap<>();\n\t\tSet<Long> sizeThresholds = Sets.newHashSet(1L, 10L, 100L, 1000L, 1000000L, 1000000000L);\n\t\tfor (Long l : sizeThresholds) {\n\t\t\tresultPerThreshold.put(l, 0L);\n\t\t}\n\t\tIterator<Entry<Long, Long>> it = esg.IES.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tEntry<Long, Long> e = it.next();\n\t\t\tLong s = result.get(e.getValue());\n\t\t\tif (s == null) {\n\t\t\t\tresult.put(e.getValue(), 1L);\n\t\t\t} else {\n\t\t\t\tresult.put(e.getValue(), result.get(e.getValue()) + 1);\n\t\t\t}\n\n\t\t\tfor (Long l : sizeThresholds) {\n\t\t\t\tif (e.getValue() > l) {\n\t\t\t\t\tresultPerThreshold.put(l, resultPerThreshold.get(l) + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tesg.getStats().indirectExtensionalSizeDistribution = result;\n\t\tesg.getStats().iesPerThreshold = resultPerThreshold;\n\n\t}\n\n\tpublic static void countEquivalenceSetsWithEmptyExtension(RocksDBBackedEquivalenceSetGraph esg) {\n\n\t\tlogger.info(\"Count Equivalence Sets With Empty Extension\");\n\t\tlong result = 0;\n\t\tlong result_without_bn = 0;\n\t\tIterator<Entry<Long, Long>> it = esg.IES.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tEntry<Long, Long> e = it.next();\n\t\t\tif (e.getValue() == 0) {\n\t\t\t\tresult++;\n\t\t\t\tCollection<String> ES = esg.IS.get(e.getKey());\n\t\t\t\tif (ES.size() == 1 && isBlankNode(ES.iterator().next())) {\n\t\t\t\t\tresult_without_bn++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tesg.getStats().es0 = result;\n\t\tesg.getStats().es0bns = result - result_without_bn;\n\n\t}\n\n\tpublic static void exportIESDistributionAsTSV(RocksDBBackedEquivalenceSetGraph esg, String filepathTSV, double untilPercentage)\n\t\t\tthrows IOException {\n\t\tlogger.info(\"Exporting IES distribution as TSV {}\", filepathTSV);\n\n\t\tMap<Long, Long> result = new HashMap<>();\n\t\tIterator<Entry<Long, Long>> it = esg.IES.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tEntry<Long, Long> e = it.next();\n\t\t\tLong s = result.get(e.getValue());\n\t\t\tif (s == null) {\n\t\t\t\tresult.put(e.getValue(), 1L);\n\t\t\t} else {\n\t\t\t\tresult.put(e.getValue(), result.get(e.getValue()) + 1);\n\t\t\t}\n\n\t\t}\n\n\t\tlong max = Collections.max(result.keySet());\n\t\tlogger.info(\"IES(0): {}\", result.get(0L));\n\t\tlogger.info(\"Max IES: {} IES({}):{}\", max, max, result.get(max));\n\t\tlong totalNumberOfES = esg.IS.keySet().size();\n\t\tlong numberOfESsWithSmallerThanCurrentSize = 0;\n\n\t\tFileOutputStream fos = new FileOutputStream(new File(filepathTSV));\n\t\tfor (long s = 0; s <= max; s++) {\n\t\t\tLong n = result.get(s);\n\t\t\tif (n != null) {\n\t\t\t\tfos.write((s + \"\\t\" + n + \"\\n\").getBytes());\n\t\t\t\tnumberOfESsWithSmallerThanCurrentSize += n;\n\t\t\t\tif (((double) numberOfESsWithSmallerThanCurrentSize / (double) totalNumberOfES) > untilPercentage) {\n\t\t\t\t\tlogger.info(\"Size at {}:{}\", untilPercentage, s);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfos.write((s + \"\\t0\\n\").getBytes());\n\t\t\t}\n\t\t}\n\t\tfos.close();\n\t\tlogger.info(\"IES distribution exported\");\n\t}\n\n\tpublic static void countEdges(RocksDBBackedEquivalenceSetGraph esg) throws IOException {\n\n\t\tlogger.info(\"Counting number of edges\");\n\n\t\tlong numberOfEdges = 0L;\n\t\tIterator<Entry<Long, Collection<Long>>> it = esg.H.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tEntry<Long, Collection<Long>> entry = it.next();\n\t\t\tnumberOfEdges += entry.getValue().size();\n\t\t}\n\t\tesg.getStats().e = numberOfEdges;\n\n\t}\n\n\tpublic static void computeHeight(RocksDBBackedEquivalenceSetGraph esg) throws IOException {\n\t\tlogger.info(\"Computing maximum height\");\n\n\t\tint processed = 0;\n\t\tlong maxHeigh = 0;\n\t\tint cycleNumber = 0;\n\n\t\tint toProcess = esg.IS.keySet().size();\n\n\t\tMap<Long, Long> heightMap = new HashMap<>();\n\n\t\tboolean stop = false;\n\t\tlong lastDiff = 0;\n\t\twhile (!stop) {\n\t\t\tlong heightMapKeySize = heightMap.keySet().size();\n\t\t\tlong currentDiff = toProcess - heightMapKeySize;\n\n\t\t\tlogger.info(\"Cycle number :: {} max height :: {} :: {} ::{}/{} \", cycleNumber++, maxHeigh,\n\t\t\t\t\t(lastDiff - currentDiff), heightMapKeySize, toProcess);\n\n\t\t\tif (!stop && (lastDiff - currentDiff) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlastDiff = currentDiff;\n\n\t\t\tstop = true;\n\t\t\tprocessed = 0;\n\n\t\t\tIterator<Long> iterator = Sets.difference(esg.IS.keySet(), heightMap.keySet()).iterator();\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tif (processed % 10000 == 0) {\n\t\t\t\t\tlogger.info(\"Processed {}/{}:{}\", processed, toProcess, ((double) processed / (double) toProcess));\n\t\t\t\t}\n\t\t\t\tprocessed++;\n\t\t\t\tLong key = iterator.next();\n\n\t\t\t\tif (!heightMap.containsKey(key) || !checkHeightMap(heightMap, esg.H_inverse)) {\n\t\t\t\t\tstop = false;\n\n\t\t\t\t\tCollection<Long> subIS = esg.H_inverse.get(key);\n\t\t\t\t\tif (subIS == null || subIS.isEmpty()) {\n\t\t\t\t\t\t// the current node is a leaf\n\t\t\t\t\t\theightMap.put(key, 0L);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLong max = 0L;\n\t\t\t\t\t\tboolean stopped = false;\n\t\t\t\t\t\tfor (Long sub : subIS) {\n\n\t\t\t\t\t\t\tif (sub.equals(key)) {\n\t\t\t\t\t\t\t\t// continue for self-loops\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!heightMap.containsKey(sub)) {\n\t\t\t\t\t\t\t\tstopped = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlong currentSubHeight = heightMap.get(sub);\n\t\t\t\t\t\t\t\tif (currentSubHeight > max) {\n\t\t\t\t\t\t\t\t\tmax = currentSubHeight;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!stopped) {\n\t\t\t\t\t\t\theightMap.put(key, max + 1);\n\n\t\t\t\t\t\t\tif (maxHeigh < max + 1) {\n\t\t\t\t\t\t\t\tmaxHeigh = max + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprocessed = 0;\n\n\t\tSet<Long> d = Sets.difference(esg.IS.keySet(), heightMap.keySet());\n\t\tIterator<Long> iterator = d.iterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tif (processed % 10000 == 0) {\n\t\t\t\tlogger.info(\"Processed {}/{}:{}\", processed, d.size(), ((double) processed / (double) toProcess));\n\t\t\t}\n\t\t\tprocessed++;\n\t\t\tlong key = iterator.next();\n\n\t\t\tCollection<Long> subs = esg.H_inverse.get(key);\n\t\t\tlong max = 0L;\n\t\t\tlong without = 0;\n\t\t\tfor (long sub : subs) {\n\t\t\t\tif (heightMap.containsKey(sub)) {\n\t\t\t\t\tlong subHeight = heightMap.get(sub);\n\t\t\t\t\tif (subHeight > max) {\n\t\t\t\t\t\tmax = subHeight;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twithout++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong keyHeight = max + without;\n\t\t\theightMap.put(key, max + without);\n\t\t\tif (keyHeight > maxHeigh) {\n\t\t\t\tmaxHeigh = keyHeight;\n\t\t\t}\n\t\t}\n\n\t\tIterator<Map.Entry<Long, Long>> hm_it = heightMap.entrySet().iterator();\n\t\tlong max = 0;\n\t\tMap<Long, Long> height_distribution = new HashMap<>();\n\t\twhile (hm_it.hasNext()) {\n\t\t\tMap.Entry<java.lang.Long, java.lang.Long> entry = (Map.Entry<java.lang.Long, java.lang.Long>) hm_it.next();\n\t\t\tif (entry.getValue() > max) {\n\t\t\t\tmax = entry.getValue();\n\t\t\t}\n\t\t\tif (height_distribution.containsKey(entry.getValue())) {\n\t\t\t\theight_distribution.put(entry.getValue(), height_distribution.get(entry.getValue()) + 1);\n\t\t\t} else {\n\t\t\t\theight_distribution.put(entry.getValue(), 1L);\n\t\t\t}\n\t\t}\n\n\t\tesg.getStats().h_max = max;\n\t\tesg.getStats().heightDistribution = height_distribution;\n\n\t}\n\n\tprivate static boolean checkHeightMap(Map<Long, Long> m, RocksMultiMap<Long, Long> H_inverse) {\n\t\tfor (Long l : H_inverse.keySet()) {\n\n\t\t\tif (m.get(l) == null)\n\t\t\t\treturn false;\n\n\t\t\tCollection<Long> subs = H_inverse.get(l);\n\t\t\tlong max = 0;\n\t\t\tfor (Long ll : subs) {\n\t\t\t\tif (ll == null) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\tmax = Math.max(max, m.get(ll));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (m.get(l) == max + 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static void countIsoltatedEquivalenceSets(RocksDBBackedEquivalenceSetGraph esg) throws IOException {\n\t\tlogger.info(\"Counting isolated Equivalence Sets\");\n\n\t\tint processed = 0;\n\t\tint isolatedIS = 0;\n\t\tint toProcess = esg.IS.keySet().size();\n\n\t\tIterator<Entry<Long, Collection<String>>> iterator = esg.IS.iterator();\n\n\t\twhile (iterator.hasNext()) {\n\t\t\tif (processed % 10000 == 0) {\n\t\t\t\tlogger.info(\"Processed {}/{}:{}\", processed, toProcess, ((double) processed / (double) toProcess));\n\t\t\t}\n\t\t\tprocessed++;\n\t\t\tEntry<Long, Collection<String>> entry = iterator.next();\n\n\t\t\tCollection<Long> subSup = Sets.newHashSet();\n\t\t\tif (esg.H.containsKey(entry.getKey())) {\n\t\t\t\tsubSup.addAll(esg.H.get(entry.getKey()));\n\t\t\t}\n\t\t\tif (esg.H_inverse.containsKey(entry.getKey())) {\n\t\t\t\tsubSup.addAll(esg.H_inverse.get(entry.getKey()));\n\t\t\t}\n\n\t\t\tsubSup.remove(entry.getKey());\n\n\t\t\tif (subSup.isEmpty()) {\n\t\t\t\tisolatedIS++;\n\t\t\t}\n\n\t\t}\n\t\tesg.getStats().in = isolatedIS;\n\n\t}\n\n\tpublic static void countTopLevelEquivalenceSetsAndAssessEmptyNodes(RocksDBBackedEquivalenceSetGraph esg) throws IOException {\n\t\tlogger.info(\"Counting Top Level Equivalence Sets And Assess Empty Nodes\");\n\n\t\tint processed = 0;\n\t\tlong tl = 0;\n\t\tlong tlWithBN = 0;\n\t\tlong oeInTL = 0;\n\t\tlong bnInTL = 0;\n\t\tlong tl0 = 0;\n\t\tlong tl0WithBNs = 0L;\n\t\tlong oeInTL0 = 0;\n\t\tlong oeInTL0WithoutBNs = 0;\n\t\tint toProcess = esg.IS.keySet().size();\n\n\t\tIterator<Entry<Long, Collection<String>>> iterator = esg.IS.iterator();\n\n\t\twhile (iterator.hasNext()) {\n\t\t\tif (processed % 10000 == 0) {\n\t\t\t\tlogger.info(\"Processed {}/{}:{}\", processed, toProcess, ((double) processed / (double) toProcess));\n\t\t\t}\n\t\t\tprocessed++;\n\t\t\tEntry<Long, Collection<String>> entry = iterator.next();\n\n\t\t\tCollection<Long> superES = esg.H.get(entry.getKey());\n\n\t\t\tif (superES != null)\n\t\t\t\tsuperES.remove(entry.getKey());\n\n\t\t\tif (superES == null || superES.isEmpty()) {\n\n\t\t\t\ttl++;\n\n\t\t\t\tif (esg.IES.containsKey(entry.getKey()) && esg.IES.get(entry.getKey()) == 0) {\n\t\t\t\t\ttl0++;\n\n\t\t\t\t\tfor (String uri : entry.getValue()) {\n\t\t\t\t\t\tif (isBlankNode(uri)) {\n\t\t\t\t\t\t\ttl0WithBNs++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\toeInTL += entry.getValue().size();\n\n\t\t\t\tfor (String uri : entry.getValue()) {\n\t\t\t\t\tif (isBlankNode(uri)) {\n\t\t\t\t\t\ttlWithBN++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (String uri : entry.getValue()) {\n\t\t\t\t\tif (isBlankNode(uri)) {\n\t\t\t\t\t\tbnInTL++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (esg.oe_size.containsKey(uri) && esg.oe_size.get(uri) == 0) {\n\t\t\t\t\t\toeInTL0++;\n\t\t\t\t\t\tif (!isBlankNode(uri)) {\n\t\t\t\t\t\t\toeInTL0WithoutBNs++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tesg.getStats().tl = tl;\n\t\tesg.getStats().tlWithoutBNs = tl - tlWithBN;\n\t\tesg.getStats().oeInTL = oeInTL;\n\t\tesg.getStats().oeInTLWithoutBNs = oeInTL - bnInTL;\n\t\tesg.getStats().tl0 = tl0;\n\t\tesg.getStats().tl0WithoutBNs = tl0 - tl0WithBNs;\n\t\tesg.getStats().oeInTL0 = oeInTL0;\n\t\tesg.getStats().oeInTl0WithoutBN = oeInTL0WithoutBNs;\n\n\t}\n\n\tpublic static void countObservedEntitiesInTopLevelEquivalenceSetsWithEmptyExtesion(RocksDBBackedEquivalenceSetGraph esg)\n\t\t\tthrows IOException {\n\n\t\tlogger.info(\"Counting Observed Entities In Top Level Equivalence Sets With Empty Extesion\");\n\n\t\tint processed = 0;\n\t\tlong tl = 0;\n\t\tlong tlWithBN = 0;\n\t\tlong oeInTL = 0;\n\t\tlong bnInTL = 0;\n\t\tint toProcess = esg.IS.keySet().size();\n\n\t\tIterator<Entry<Long, Collection<String>>> iterator = esg.IS.iterator();\n\n\t\twhile (iterator.hasNext()) {\n\t\t\tif (processed % 10000 == 0) {\n\t\t\t\tlogger.info(\"Processed {}/{}:{}\", processed, toProcess, ((double) processed / (double) toProcess));\n\t\t\t}\n\t\t\tprocessed++;\n\t\t\tEntry<Long, Collection<String>> entry = iterator.next();\n\n\t\t\tif (!esg.H.containsKey(entry.getValue())) {\n\t\t\t\ttl++;\n\t\t\t}\n\n\t\t\tfor (String uri : entry.getValue()) {\n\t\t\t\tif (isBlankNode(uri)) {\n\t\t\t\t\ttlWithBN++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toeInTL += entry.getValue().size();\n\n\t\t\tfor (String uri : entry.getValue()) {\n\t\t\t\tif (isBlankNode(uri)) {\n\t\t\t\t\tbnInTL++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tesg.getStats().tl = tl;\n\t\tesg.getStats().tlWithoutBNs = tl - tlWithBN;\n\t\tesg.getStats().oeInTL = oeInTL;\n\t\tesg.getStats().oeInTLWithoutBNs = oeInTL - bnInTL;\n\n\t}\n\n\tprivate static boolean isBlankNode(String uri) {\n\t\t// Exploit skolemization of the blank nodes carried out by LOD Laundromat\n\t\treturn uri.startsWith(\"http://lodlaundromat.org/.well-known/genid/\");\n\t}\n\n}", "class_id": 0, "repo": "luigi-asprino/edwin", "file": "src/main/java/it/cnr/istc/stlab/edwin/EquivalenceSetGraphAnalyser.java", "last_update_at": "2020-01-28T08:03:37+00:00", "question_id": "ed3525f8f3bb66c3f83adfa5c52acc8b6fe5a527", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EquivalenceSetGraphAnalyser {\n\tprivate static Logger logger = LoggerFactory.getLogger(EquivalenceSetGraphBuilderImpl.class);\n\tpublic static void countBlankNodes(RocksDBBackedEquivalenceSetGraph esg) throws IOException {\n\t\tlogger.info(\"Counting number of BlankNodes\");\n\t\tint processed = 0;\n\t\tint numberOfBlankNodes = 0;\n\t\tint toProcess = esg.ID.keySet().size();\n\t\tSet<Long> es_with_bn = new HashSet<>();\n\t\tIterator<Entry<String, Long>> iterator = esg.ID.iterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tif (processed % 10000 == 0) {\n\t\t\t\tlogger.info(\"Processed {}/{}:{}\", processed, toProcess, ((double) processed / (double) toProcess));\n\t\t\t}\n\t\t\tprocessed++;\n\t\t\tEntry<String, Long> entry = (Entry<String, Long>) iterator.next();\n\t\t\tif (isBlankNode(entry.getKey())) {\n\t\t\t\tnumberOfBlankNodes++;\n\t\t\t\tes_with_bn.add(entry.getValue());\n\t\t\t}\n\t\t}\n\t\tesg.getStats().bns = numberOfBlankNodes;\n\t\tesg.getStats().es_with_bns = es_with_bn.size();\n\t}\n\tpublic static void countObservedEntitiesWithEmptyExtesion(RocksDBBackedEquivalenceSetGraph esg) {\n\t\tlogger.info(\"Counting Number of Observed Entities With Empty Extension\");\n\t\tlong result = 0;\n\t\tlong result_without_bn = 0;\n\t\tIterator<Entry<String, Long>> it = esg.oe_size.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tEntry<String, Long> e = it.next();\n\t\t\tif (e.getValue() == 0) {\n\t\t\t\tresult++;\n\t\t\t\tif (!isBlankNode(e.getKey())) {\n\t\t\t\t\tresult_without_bn++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tesg.getStats().oe0 = result;\n\t\tesg.getStats().oe0_bns = result_without_bn;\n\t}\n\tpublic static void computeDistributionOfExtensionalSizeOfEquivalenceSets(RocksDBBackedEquivalenceSetGraph esg) {\n\t\tlogger.info(\"Computing Statistics on Extensional Size of Equivalence Sets\");\n\t\tMap<Long, Long> result = new HashMap<>();\n\t\tMap<Long, Long> resultPerThreshold = new HashMap<>();\n\t\tSet<Long> sizeThresholds = Sets.newHashSet(1L, 10L, 100L, 1000L, 1000000L, 1000000000L);\n\t\tfor (Long l : sizeThresholds) {\n\t\t\tresultPerThreshold.put(l, 0L);\n\t\t}\n\t\tIterator<Entry<Long, Long>> it = esg.IES.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tEntry<Long, Long> e = it.next();\n\t\t\tLong s = result.get(e.getValue());\n\t\t\tif (s == null) {\n\t\t\t\tresult.put(e.getValue(), 1L);\n\t\t\t} else {\n\t\t\t\tresult.put(e.getValue(), result.get(e.getValue()) + 1);\n\t\t\t}\n\t\t\tfor (Long l : sizeThresholds) {\n\t\t\t\tif (e.getValue() > l) {\n\t\t\t\t\tresultPerThreshold.put(l, resultPerThreshold.get(l) + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tesg.getStats().indirectExtensionalSizeDistribution = result;\n\t\tesg.getStats().iesPerThreshold = resultPerThreshold;\n\t}\n\tpublic static void countEquivalenceSetsWithEmptyExtension(RocksDBBackedEquivalenceSetGraph esg) {\n\t\tlogger.info(\"Count Equivalence Sets With Empty Extension\");\n\t\tlong result = 0;\n\t\tlong result_without_bn = 0;\n\t\tIterator<Entry<Long, Long>> it = esg.IES.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tEntry<Long, Long> e = it.next();\n\t\t\tif (e.getValue() == 0) {\n\t\t\t\tresult++;\n\t\t\t\tCollection<String> ES = esg.IS.get(e.getKey());\n\t\t\t\tif (ES.size() == 1 && isBlankNode(ES.iterator().next())) {\n\t\t\t\t\tresult_without_bn++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tesg.getStats().es0 = result;\n\t\tesg.getStats().es0bns = result - result_without_bn;\n\t}\n\tpublic static void exportIESDistributionAsTSV(RocksDBBackedEquivalenceSetGraph esg, String filepathTSV, double untilPercentage)\n\t\t\tthrows IOException {\n\t\tlogger.info(\"Exporting IES distribution as TSV {}\", filepathTSV);\n\t\tMap<Long, Long> result = new HashMap<>();\n\t\tIterator<Entry<Long, Long>> it = esg.IES.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tEntry<Long, Long> e = it.next();\n\t\t\tLong s = result.get(e.getValue());\n\t\t\tif (s == null) {\n\t\t\t\tresult.put(e.getValue(), 1L);\n\t\t\t} else {\n\t\t\t\tresult.put(e.getValue(), result.get(e.getValue()) + 1);\n\t\t\t}\n\t\t}\n\t\tlong max = Collections.max(result.keySet());\n\t\tlogger.info(\"IES(0): {}\", result.get(0L));\n\t\tlogger.info(\"Max IES: {} IES({}):{}\", max, max, result.get(max));\n\t\tlong totalNumberOfES = esg.IS.keySet().size();\n\t\tlong numberOfESsWithSmallerThanCurrentSize = 0;\n\t\tFileOutputStream fos = new FileOutputStream(new File(filepathTSV));\n\t\tfor (long s = 0; s <= max; s++) {\n\t\t\tLong n = result.get(s);\n\t\t\tif (n != null) {\n\t\t\t\tfos.write((s + \"\\t\" + n + \"\\n\").getBytes());\n\t\t\t\tnumberOfESsWithSmallerThanCurrentSize += n;\n\t\t\t\tif (((double) numberOfESsWithSmallerThanCurrentSize / (double) totalNumberOfES) > untilPercentage) {\n\t\t\t\t\tlogger.info(\"Size at {}:{}\", untilPercentage, s);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfos.write((s + \"\\t0\\n\").getBytes());\n\t\t\t}\n\t\t}\n\t\tfos.close();\n\t\tlogger.info(\"IES distribution exported\");\n\t}\n\tpublic static void countEdges(RocksDBBackedEquivalenceSetGraph esg) throws IOException {\n\t\tlogger.info(\"Counting number of edges\");\n\t\tlong numberOfEdges = 0L;\n\t\tIterator<Entry<Long, Collection<Long>>> it = esg.H.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tEntry<Long, Collection<Long>> entry = it.next();\n\t\t\tnumberOfEdges += entry.getValue().size();\n\t\t}\n\t\tesg.getStats().e = numberOfEdges;\n\t}\n\tpublic static void computeHeight(RocksDBBackedEquivalenceSetGraph esg) throws IOException {\n\t\tlogger.info(\"Computing maximum height\");\n\t\tint processed = 0;\n\t\tlong maxHeigh = 0;\n\t\tint cycleNumber = 0;\n\t\tint toProcess = esg.IS.keySet().size();\n\t\tMap<Long, Long> heightMap = new HashMap<>();\n\t\tboolean stop = false;\n\t\tlong lastDiff = 0;\n\t\twhile (!stop) {\n\t\t\tlong heightMapKeySize = heightMap.keySet().size();\n\t\t\tlong currentDiff = toProcess - heightMapKeySize;\n\t\t\tlogger.info(\"Cycle number :: {} max height :: {} :: {} ::{}/{} \", cycleNumber++, maxHeigh,\n\t\t\t\t\t(lastDiff - currentDiff), heightMapKeySize, toProcess);\n\t\t\tif (!stop && (lastDiff - currentDiff) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlastDiff = currentDiff;\n\t\t\tstop = true;\n\t\t\tprocessed = 0;\n\t\t\tIterator<Long> iterator = Sets.difference(esg.IS.keySet(), heightMap.keySet()).iterator();\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tif (processed % 10000 == 0) {\n\t\t\t\t\tlogger.info(\"Processed {}/{}:{}\", processed, toProcess, ((double) processed / (double) toProcess));\n\t\t\t\t}\n\t\t\t\tprocessed++;\n\t\t\t\tLong key = iterator.next();\n\t\t\t\tif (!heightMap.containsKey(key) || !checkHeightMap(heightMap, esg.H_inverse)) {\n\t\t\t\t\tstop = false;\n\t\t\t\t\tCollection<Long> subIS = esg.H_inverse.get(key);\n\t\t\t\t\tif (subIS == null || subIS.isEmpty()) {\n\t\t\t\t\t\t// the current node is a leaf\n\t\t\t\t\t\theightMap.put(key, 0L);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLong max = 0L;\n\t\t\t\t\t\tboolean stopped = false;\n\t\t\t\t\t\tfor (Long sub : subIS) {\n\t\t\t\t\t\t\tif (sub.equals(key)) {\n\t\t\t\t\t\t\t\t// continue for self-loops\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!heightMap.containsKey(sub)) {\n\t\t\t\t\t\t\t\tstopped = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlong currentSubHeight = heightMap.get(sub);\n\t\t\t\t\t\t\t\tif (currentSubHeight > max) {\n\t\t\t\t\t\t\t\t\tmax = currentSubHeight;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!stopped) {\n\t\t\t\t\t\t\theightMap.put(key, max + 1);\n\t\t\t\t\t\t\tif (maxHeigh < max + 1) {\n\t\t\t\t\t\t\t\tmaxHeigh = max + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprocessed = 0;\n\t\tSet<Long> d = Sets.difference(esg.IS.keySet(), heightMap.keySet());\n\t\tIterator<Long> iterator = d.iterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tif (processed % 10000 == 0) {\n\t\t\t\tlogger.info(\"Processed {}/{}:{}\", processed, d.size(), ((double) processed / (double) toProcess));\n\t\t\t}\n\t\t\tprocessed++;\n\t\t\tlong key = iterator.next();\n\t\t\tCollection<Long> subs = esg.H_inverse.get(key);\n\t\t\tlong max = 0L;\n\t\t\tlong without = 0;\n\t\t\tfor (long sub : subs) {\n\t\t\t\tif (heightMap.containsKey(sub)) {\n\t\t\t\t\tlong subHeight = heightMap.get(sub);\n\t\t\t\t\tif (subHeight > max) {\n\t\t\t\t\t\tmax = subHeight;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twithout++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong keyHeight = max + without;\n\t\t\theightMap.put(key, max + without);\n\t\t\tif (keyHeight > maxHeigh) {\n\t\t\t\tmaxHeigh = keyHeight;\n\t\t\t}\n\t\t}\n\t\tIterator<Map.Entry<Long, Long>> hm_it = heightMap.entrySet().iterator();\n\t\tlong max = 0;\n\t\tMap<Long, Long> height_distribution = new HashMap<>();\n\t\twhile (hm_it.hasNext()) {\n\t\t\tMap.Entry<java.lang.Long, java.lang.Long> entry = (Map.Entry<java.lang.Long, java.lang.Long>) hm_it.next();\n\t\t\tif (entry.getValue() > max) {\n\t\t\t\tmax = entry.getValue();\n\t\t\t}\n\t\t\tif (height_distribution.containsKey(entry.getValue())) {\n\t\t\t\theight_distribution.put(entry.getValue(), height_distribution.get(entry.getValue()) + 1);\n\t\t\t} else {\n\t\t\t\theight_distribution.put(entry.getValue(), 1L);\n\t\t\t}\n\t\t}\n\t\tesg.getStats().h_max = max;\n\t\tesg.getStats().heightDistribution = height_distribution;\n\t}\n\tprivate static boolean checkHeightMap(Map<Long, Long> m, RocksMultiMap<Long, Long> H_inverse) {\n\t\tfor (Long l : H_inverse.keySet()) {\n\t\t\tif (m.get(l) == null)\n\t\t\t\treturn false;\n\t\t\tCollection<Long> subs = H_inverse.get(l);\n\t\t\tlong max = 0;\n\t\t\tfor (Long ll : subs) {\n\t\t\t\tif (ll == null) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\tmax = Math.max(max, m.get(ll));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (m.get(l) == max + 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static void countIsoltatedEquivalenceSets(RocksDBBackedEquivalenceSetGraph esg) throws IOException {\n\t\tlogger.info(\"Counting isolated Equivalence Sets\");\n\t\tint processed = 0;\n\t\tint isolatedIS = 0;\n\t\tint toProcess = esg.IS.keySet().size();\n\t\tIterator<Entry<Long, Collection<String>>> iterator = esg.IS.iterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tif (processed % 10000 == 0) {\n\t\t\t\tlogger.info(\"Processed {}/{}:{}\", processed, toProcess, ((double) processed / (double) toProcess));\n\t\t\t}\n\t\t\tprocessed++;\n\t\t\tEntry<Long, Collection<String>> entry = iterator.next();\n\t\t\tCollection<Long> subSup = Sets.newHashSet();\n\t\t\tif (esg.H.containsKey(entry.getKey())) {\n\t\t\t\tsubSup.addAll(esg.H.get(entry.getKey()));\n\t\t\t}\n\t\t\tif (esg.H_inverse.containsKey(entry.getKey())) {\n\t\t\t\tsubSup.addAll(esg.H_inverse.get(entry.getKey()));\n\t\t\t}\n\t\t\tsubSup.remove(entry.getKey());\n\t\t\tif (subSup.isEmpty()) {\n\t\t\t\tisolatedIS++;\n\t\t\t}\n\t\t}\n\t\tesg.getStats().in = isolatedIS;\n\t}\n\tpublic static void countTopLevelEquivalenceSetsAndAssessEmptyNodes(RocksDBBackedEquivalenceSetGraph esg) throws IOException {\n\t\tlogger.info(\"Counting Top Level Equivalence Sets And Assess Empty Nodes\");\n\t\tint processed = 0;\n\t\tlong tl = 0;\n\t\tlong tlWithBN = 0;\n\t\tlong oeInTL = 0;\n\t\tlong bnInTL = 0;\n\t\tlong tl0 = 0;\n\t\tlong tl0WithBNs = 0L;\n\t\tlong oeInTL0 = 0;\n\t\tlong oeInTL0WithoutBNs = 0;\n\t\tint toProcess = esg.IS.keySet().size();\n\t\tIterator<Entry<Long, Collection<String>>> iterator = esg.IS.iterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tif (processed % 10000 == 0) {\n\t\t\t\tlogger.info(\"Processed {}/{}:{}\", processed, toProcess, ((double) processed / (double) toProcess));\n\t\t\t}\n\t\t\tprocessed++;\n\t\t\tEntry<Long, Collection<String>> entry = iterator.next();\n\t\t\tCollection<Long> superES = esg.H.get(entry.getKey());\n\t\t\tif (superES != null)\n\t\t\t\tsuperES.remove(entry.getKey());\n\t\t\tif (superES == null || superES.isEmpty()) {\n\t\t\t\ttl++;\n\t\t\t\tif (esg.IES.containsKey(entry.getKey()) && esg.IES.get(entry.getKey()) == 0) {\n\t\t\t\t\ttl0++;\n\t\t\t\t\tfor (String uri : entry.getValue()) {\n\t\t\t\t\t\tif (isBlankNode(uri)) {\n\t\t\t\t\t\t\ttl0WithBNs++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toeInTL += entry.getValue().size();\n\t\t\t\tfor (String uri : entry.getValue()) {\n\t\t\t\t\tif (isBlankNode(uri)) {\n\t\t\t\t\t\ttlWithBN++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (String uri : entry.getValue()) {\n\t\t\t\t\tif (isBlankNode(uri)) {\n\t\t\t\t\t\tbnInTL++;\n\t\t\t\t\t}\n\t\t\t\t\tif (esg.oe_size.containsKey(uri) && esg.oe_size.get(uri) == 0) {\n\t\t\t\t\t\toeInTL0++;\n\t\t\t\t\t\tif (!isBlankNode(uri)) {\n\t\t\t\t\t\t\toeInTL0WithoutBNs++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tesg.getStats().tl = tl;\n\t\tesg.getStats().tlWithoutBNs = tl - tlWithBN;\n\t\tesg.getStats().oeInTL = oeInTL;\n\t\tesg.getStats().oeInTLWithoutBNs = oeInTL - bnInTL;\n\t\tesg.getStats().tl0 = tl0;\n\t\tesg.getStats().tl0WithoutBNs = tl0 - tl0WithBNs;\n\t\tesg.getStats().oeInTL0 = oeInTL0;\n\t\tesg.getStats().oeInTl0WithoutBN = oeInTL0WithoutBNs;\n\t}\n\tpublic static void countObservedEntitiesInTopLevelEquivalenceSetsWithEmptyExtesion(RocksDBBackedEquivalenceSetGraph esg)\n\t\t\tthrows IOException {\n\t\tlogger.info(\"Counting Observed Entities In Top Level Equivalence Sets With Empty Extesion\");\n\t\tint processed = 0;\n\t\tlong tl = 0;\n\t\tlong tlWithBN = 0;\n\t\tlong oeInTL = 0;\n\t\tlong bnInTL = 0;\n\t\tint toProcess = esg.IS.keySet().size();\n\t\tIterator<Entry<Long, Collection<String>>> iterator = esg.IS.iterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tif (processed % 10000 == 0) {\n\t\t\t\tlogger.info(\"Processed {}/{}:{}\", processed, toProcess, ((double) processed / (double) toProcess));\n\t\t\t}\n\t\t\tprocessed++;\n\t\t\tEntry<Long, Collection<String>> entry = iterator.next();\n\t\t\tif (!esg.H.containsKey(entry.getValue())) {\n\t\t\t\ttl++;\n\t\t\t}\n\t\t\tfor (String uri : entry.getValue()) {\n\t\t\t\tif (isBlankNode(uri)) {\n\t\t\t\t\ttlWithBN++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\toeInTL += entry.getValue().size();\n\t\t\tfor (String uri : entry.getValue()) {\n\t\t\t\tif (isBlankNode(uri)) {\n\t\t\t\t\tbnInTL++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tesg.getStats().tl = tl;\n\t\tesg.getStats().tlWithoutBNs = tl - tlWithBN;\n\t\tesg.getStats().oeInTL = oeInTL;\n\t\tesg.getStats().oeInTLWithoutBNs = oeInTL - bnInTL;\n\t}\n\tprivate static boolean isBlankNode(String uri) {\n\t\t// Exploit skolemization of the blank nodes carried out by LOD Laundromat\n\t\treturn uri.startsWith(\"http://lodlaundromat.org/.well-known/genid/\");\n\t}\n"]]}
{"hexsha": "4f1e4fe64b2e12389d031851155adfb02631bf92", "ext": "java", "lang": "Java", "content": "public abstract class AbstractBitcoinNetParams extends NetworkParameters {\n\n    /**\n     * Scheme part for Bitcoin URIs.\n     */\n    public static final String BITCOIN_SCHEME = \"bitcore\";\n    public static final int REWARD_HALVING_INTERVAL = 210000;\n\n    private static final Logger log = LoggerFactory.getLogger(AbstractBitcoinNetParams.class);\n\n    private static final BigInteger MASK256BIT = new BigInteger(\"00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\", 16);\n    private static final int FORK1_HEIGHT = 10000;\n    private static final int FORK2_HEIGHT = 21000;\n\n\n    public AbstractBitcoinNetParams() {\n        super();\n    }\n\n    /**\n     * Checks if we are at a difficulty transition point.\n     * @param height The height of the previous stored block\n     * @return If this is a difficulty transition point\n     */\n    public final boolean isDifficultyTransitionPoint(final int height) {\n        if (height > FORK2_HEIGHT)\n            return ((height + 1) % this.getInterval2()) == 0;\n        else\n            return ((height + 1) % this.getInterval()) == 0;\n    }\n\n    @Override\n    public void checkDifficultyTransitions(final StoredBlock storedPrev, final Block nextBlock,\n    \tfinal BlockStore blockStore) throws VerificationException, BlockStoreException {\n        if ((storedPrev.getHeight()+1) <= FORK1_HEIGHT) {\n            DUAL_KGW3(storedPrev, nextBlock, blockStore);\n        } else {\n            final Block prev = storedPrev.getHeader();\n\n            // Is this supposed to be a difficulty transition point?\n            if (!isDifficultyTransitionPoint(storedPrev.getHeight())) {\n\n                // No ... so check the difficulty didn't actually change.\n                if (nextBlock.getDifficultyTarget() != prev.getDifficultyTarget())\n                    throw new VerificationException(\"Unexpected change in difficulty at height \" + storedPrev.getHeight() +\n                            \": \" + Long.toHexString(nextBlock.getDifficultyTarget()) + \" vs \" +\n                            Long.toHexString(prev.getDifficultyTarget()));\n                return;\n            }\n\n            // We need to find a block far back in the chain. It's OK that this is expensive because it only occurs every\n            // two weeks after the initial block chain download.\n            Sha256Hash hash = prev.getHash();\n            StoredBlock cursor = null;\n            int interval = 0;\n            if (storedPrev.getHeight() > FORK2_HEIGHT)\n                interval = this.getInterval2()+1;\n            else\n                interval = this.getInterval()+1;\n\n            for (int i = 0; i < interval; i++) {\n                cursor = blockStore.get(hash);\n                if (cursor == null) {\n                    // we my have no enough blocks here\n                    return;\n                }\n                hash = cursor.getHeader().getPrevBlockHash();\n            }\n\n            Block blockIntervalAgo = cursor.getHeader();\n            int timespan = (int) (prev.getTimeSeconds() - blockIntervalAgo.getTimeSeconds());\n            // Limit the adjustment step.\n            int targetTimespan = 0;\n            double factor = 0.0;\n            if (storedPrev.getHeight() > FORK2_HEIGHT) {\n                targetTimespan = this.getTargetTimespan2();\n                factor = 1.15;\n            } else {\n                targetTimespan = this.getTargetTimespan();\n                factor = 4.0;\n            }\n\n            if (timespan < (int)((double)targetTimespan / factor))\n                timespan = (int)((double)targetTimespan / factor );\n            if (timespan > (int)((double)targetTimespan * factor))\n                timespan = (int)((double)targetTimespan * factor );\n\n            BigInteger newTarget = Utils.decodeCompactBits(prev.getDifficultyTarget());\n            newTarget = newTarget.multiply(BigInteger.valueOf(timespan));\n            newTarget = newTarget.divide(BigInteger.valueOf(targetTimespan));\n\n            if (newTarget.compareTo(this.getMaxTarget()) > 0) {\n                log.info(\"Difficulty hit proof of work limit: {}\", newTarget.toString(16));\n                newTarget = this.getMaxTarget();\n            }\n\n            verifyDifficulty(newTarget, storedPrev, nextBlock);\n        }\n    }\n\n    private void DUAL_KGW3(StoredBlock storedPrev, Block nextBlock, final BlockStore blockStore)\n      throws BlockStoreException, VerificationException {\n        final long Blocktime = 96 * 6; // = 9.6 * 60; // 9.6 = 10 min (Value = Value*0.96)\n        long TimeDaySeconds = 60 * 60 * 24;\n        long PastSecondsMin = TimeDaySeconds / 40;\n        long PastSecondsMax = TimeDaySeconds * 7;\n        long PastBlocksMin = PastSecondsMin / Blocktime;\n        long PastBlocksMax = PastSecondsMax / Blocktime;\n\n        // current difficulty formula, ERC3 - DUAL_KGW3, written by Christian Knoepke - apfelbaum@email.de\n        // BitSend and Eropecoin Developer\n        StoredBlock BlockLastSolved = storedPrev;\n        StoredBlock BlockReading = storedPrev;\n\n        long PastBlocksMass = 0;\n        long PastRateActualSeconds = 0;\n        long PastRateTargetSeconds = 0;\n        double PastRateAdjustmentRatio = 1f;\n        BigInteger PastDifficultyAverage = BigInteger.valueOf(0);\n        BigInteger PastDifficultyAveragePrev = BigInteger.valueOf(0);;\n        double EventHorizonDeviation;\n        double EventHorizonDeviationFast;\n        double EventHorizonDeviationSlow;\n\n        BigInteger bnPowLimit = this.getMaxTarget();\n\n        //DUAL_KGW3 SETUP\n        if (BlockLastSolved == null || BlockLastSolved.getHeight() == 0 || (long)BlockLastSolved.getHeight() < PastBlocksMin) {\n            verifyDifficulty(this.getMaxTarget(), storedPrev, nextBlock);\n        } else {\n            for (int i = 1; BlockReading != null && BlockReading.getHeight() > 0; i++) {\n                if (PastBlocksMax > 0 && i > PastBlocksMax) { break; }\n                PastBlocksMass++;\n\n                PastDifficultyAverage = BlockReading.getHeader().getDifficultyTargetAsInteger();\n                if (i > 1) {\n                    if(PastDifficultyAverage.compareTo(PastDifficultyAveragePrev) >= 0)\n                        PastDifficultyAverage = ((PastDifficultyAverage.subtract(PastDifficultyAveragePrev)).divide(BigInteger.valueOf(i)).add(PastDifficultyAveragePrev));\n                    else\n                        PastDifficultyAverage = PastDifficultyAveragePrev.subtract((PastDifficultyAveragePrev.subtract(PastDifficultyAverage)).divide(BigInteger.valueOf(i)));\n                }\n                PastDifficultyAveragePrev = PastDifficultyAverage;\n\n                PastRateActualSeconds = BlockLastSolved.getHeader().getTimeSeconds() - BlockReading.getHeader().getTimeSeconds();\n                PastRateTargetSeconds = Blocktime * PastBlocksMass;\n                PastRateAdjustmentRatio = 1.0f;\n\n                if (PastRateActualSeconds < 0)\n                    PastRateActualSeconds = 0;\n\n                if (PastRateActualSeconds != 0 && PastRateTargetSeconds != 0)\n                    PastRateAdjustmentRatio = (double)PastRateTargetSeconds / PastRateActualSeconds;\n\n                EventHorizonDeviation = 1.0 + (0.7084 * java.lang.Math.pow((Double.valueOf(PastBlocksMass)/Double.valueOf(72)), -1.228));\n                EventHorizonDeviationFast = EventHorizonDeviation;\n                EventHorizonDeviationSlow = 1.0 / EventHorizonDeviation;\n\n                if (PastBlocksMass >= PastBlocksMin)\n                    if ((PastRateAdjustmentRatio <= EventHorizonDeviationSlow) || (PastRateAdjustmentRatio >= EventHorizonDeviationFast))\n                        break;\n\n                StoredBlock BlockReadingPrev = BlockReading.getPrev(blockStore);\n                if (BlockReadingPrev == null) {\n                    // Since we are using the checkpoint system, there may not be enough blocks to do this diff adjust, so skip until we do\n                    // break;\n                    return;\n                  }\n\n                BlockReading = BlockReadingPrev;\n            }\n\n            //KGW Original\n            BigInteger kgw_dual1 = PastDifficultyAverage;\n            BigInteger kgw_dual2 = storedPrev.getHeader().getDifficultyTargetAsInteger();\n            if (PastRateActualSeconds != 0 && PastRateTargetSeconds != 0) {\n                kgw_dual1 = kgw_dual1.multiply(BigInteger.valueOf(PastRateActualSeconds));\n                kgw_dual1 = kgw_dual1.and(MASK256BIT); // overflow is here, we need cut it back to 256 bit\n                kgw_dual1 = kgw_dual1.divide(BigInteger.valueOf(PastRateTargetSeconds));\n                kgw_dual1 = kgw_dual1.and(MASK256BIT);\n            }\n\n            StoredBlock BlockPrev = storedPrev.getPrev(blockStore);\n            long nActualTime1 = storedPrev.getHeader().getTimeSeconds() - BlockPrev.getHeader().getTimeSeconds();\n\n            // hack caused bug in c implementation\n            if (nActualTime1 < 0)\n                nActualTime1 = Blocktime;\n\n            long nActualTimespanshort = nActualTime1;\n\n            if (nActualTime1 < Blocktime / 3)\n                nActualTime1 = Blocktime / 3;\n\n            if (nActualTime1 > Blocktime * 3)\n                nActualTime1 = Blocktime * 3;\n\n            kgw_dual2 = kgw_dual2.multiply(BigInteger.valueOf(nActualTime1));\n            kgw_dual2 = kgw_dual2.and(MASK256BIT);\n            kgw_dual2 = kgw_dual2.divide(BigInteger.valueOf(Blocktime));\n            kgw_dual2 = kgw_dual2.and(MASK256BIT);\n\n            //Fusion from Retarget and Classic KGW3 (BitSend=)\n            BigInteger newDifficulty = (kgw_dual2.add(kgw_dual1)).divide(BigInteger.valueOf(2));\n\n            // DUAL KGW3 increased rapidly the Diff if Blocktime to last block under Blocktime/6 sec.\n            if( nActualTimespanshort < Blocktime/6 ) {\n                newDifficulty = newDifficulty.multiply(BigInteger.valueOf(85));\n                newDifficulty = newDifficulty.divide(BigInteger.valueOf(100));\n            }\n\n            //BitBreak BitSend\n            // Reduce difficulty if current block generation time has already exceeded maximum time limit.\n            long nLongTimeLimit = 12 * 60 * 60;\n            if ((nextBlock.getTimeSeconds() - storedPrev.getHeader().getTimeSeconds()) > nLongTimeLimit)\n                newDifficulty = bnPowLimit;\n\n            if (newDifficulty.compareTo(bnPowLimit) > 0)\n                newDifficulty = bnPowLimit;\n\n            verifyDifficulty(newDifficulty, storedPrev, nextBlock);\n        }\n    }\n\n    private void verifyDifficulty(BigInteger newTarget, StoredBlock storedPrev, Block nextBlock) {\n        int accuracyBytes = (int) (nextBlock.getDifficultyTarget() >>> 24) - 3;\n        long receivedTargetCompact = nextBlock.getDifficultyTarget();\n\n        // The calculated difficulty is to a higher precision than received, so reduce here.\n        BigInteger mask = BigInteger.valueOf(0xFFFFFFL).shiftLeft(accuracyBytes * 8);\n        newTarget = newTarget.and(mask);\n        long newTargetCompact = Utils.encodeCompactBits(newTarget);\n\n        if (newTargetCompact != receivedTargetCompact)\n            throw new VerificationException(\"Network provided difficulty bits do not match what was calculated: \" +\n                    Long.toHexString(newTargetCompact) + \" vs \" + Long.toHexString(receivedTargetCompact));\n    }\n\n    @Override\n    public Coin getMaxMoney() {\n        return MAX_MONEY;\n    }\n\n    @Override\n    public Coin getMinNonDustOutput() {\n        return Transaction.MIN_NONDUST_OUTPUT;\n    }\n\n    @Override\n    public MonetaryFormat getMonetaryFormat() {\n        return new MonetaryFormat();\n    }\n\n    @Override\n    public int getProtocolVersionNum(final ProtocolVersion version) {\n        return version.getBitcoinProtocolVersion();\n    }\n\n    @Override\n    public BitcoinSerializer getSerializer(boolean parseRetain) {\n        return new BitcoinSerializer(this, parseRetain);\n    }\n\n    @Override\n    public String getUriScheme() {\n        return BITCOIN_SCHEME;\n    }\n\n    @Override\n    public boolean hasMaxMoney() {\n        return true;\n    }\n}", "class_id": 0, "repo": "madzebra/bitcorej", "file": "core/src/main/java/org/bitcoinj/params/AbstractBitcoinNetParams.java", "last_update_at": "2020-06-29T05:25:47+00:00", "question_id": "4f1e4fe64b2e12389d031851155adfb02631bf92", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class AbstractBitcoinNetParams extends NetworkParameters {\n    /**\n     * Scheme part for Bitcoin URIs.\n     */\n    public static final String BITCOIN_SCHEME = \"bitcore\";\n    public static final int REWARD_HALVING_INTERVAL = 210000;\n    private static final Logger log = LoggerFactory.getLogger(AbstractBitcoinNetParams.class);\n    private static final BigInteger MASK256BIT = new BigInteger(\"00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\", 16);\n    private static final int FORK1_HEIGHT = 10000;\n    private static final int FORK2_HEIGHT = 21000;\n    public AbstractBitcoinNetParams() {\n        super();\n    }\n    /**\n     * Checks if we are at a difficulty transition point.\n     * @param height The height of the previous stored block\n     * @return If this is a difficulty transition point\n     */\n    public final boolean isDifficultyTransitionPoint(final int height) {\n        if (height > FORK2_HEIGHT)\n            return ((height + 1) % this.getInterval2()) == 0;\n        else\n            return ((height + 1) % this.getInterval()) == 0;\n    }\n    @Override\n    public void checkDifficultyTransitions(final StoredBlock storedPrev, final Block nextBlock,\n    \tfinal BlockStore blockStore) throws VerificationException, BlockStoreException {\n        if ((storedPrev.getHeight()+1) <= FORK1_HEIGHT) {\n            DUAL_KGW3(storedPrev, nextBlock, blockStore);\n        } else {\n            final Block prev = storedPrev.getHeader();\n            // Is this supposed to be a difficulty transition point?\n            if (!isDifficultyTransitionPoint(storedPrev.getHeight())) {\n                // No ... so check the difficulty didn't actually change.\n                if (nextBlock.getDifficultyTarget() != prev.getDifficultyTarget())\n                    throw new VerificationException(\"Unexpected change in difficulty at height \" + storedPrev.getHeight() +\n                            \": \" + Long.toHexString(nextBlock.getDifficultyTarget()) + \" vs \" +\n                            Long.toHexString(prev.getDifficultyTarget()));\n                return;\n            }\n            // We need to find a block far back in the chain. It's OK that this is expensive because it only occurs every\n            // two weeks after the initial block chain download.\n            Sha256Hash hash = prev.getHash();\n            StoredBlock cursor = null;\n            int interval = 0;\n            if (storedPrev.getHeight() > FORK2_HEIGHT)\n                interval = this.getInterval2()+1;\n            else\n                interval = this.getInterval()+1;\n            for (int i = 0; i < interval; i++) {\n                cursor = blockStore.get(hash);\n                if (cursor == null) {\n                    // we my have no enough blocks here\n                    return;\n                }\n                hash = cursor.getHeader().getPrevBlockHash();\n            }\n            Block blockIntervalAgo = cursor.getHeader();\n            int timespan = (int) (prev.getTimeSeconds() - blockIntervalAgo.getTimeSeconds());\n            // Limit the adjustment step.\n            int targetTimespan = 0;\n            double factor = 0.0;\n            if (storedPrev.getHeight() > FORK2_HEIGHT) {\n                targetTimespan = this.getTargetTimespan2();\n                factor = 1.15;\n            } else {\n                targetTimespan = this.getTargetTimespan();\n                factor = 4.0;\n            }\n            if (timespan < (int)((double)targetTimespan / factor))\n                timespan = (int)((double)targetTimespan / factor );\n            if (timespan > (int)((double)targetTimespan * factor))\n                timespan = (int)((double)targetTimespan * factor );\n            BigInteger newTarget = Utils.decodeCompactBits(prev.getDifficultyTarget());\n            newTarget = newTarget.multiply(BigInteger.valueOf(timespan));\n            newTarget = newTarget.divide(BigInteger.valueOf(targetTimespan));\n            if (newTarget.compareTo(this.getMaxTarget()) > 0) {\n                log.info(\"Difficulty hit proof of work limit: {}\", newTarget.toString(16));\n                newTarget = this.getMaxTarget();\n            }\n            verifyDifficulty(newTarget, storedPrev, nextBlock);\n        }\n    }\n    private void DUAL_KGW3(StoredBlock storedPrev, Block nextBlock, final BlockStore blockStore)\n      throws BlockStoreException, VerificationException {\n        final long Blocktime = 96 * 6; // = 9.6 * 60; // 9.6 = 10 min (Value = Value*0.96)\n        long TimeDaySeconds = 60 * 60 * 24;\n        long PastSecondsMin = TimeDaySeconds / 40;\n        long PastSecondsMax = TimeDaySeconds * 7;\n        long PastBlocksMin = PastSecondsMin / Blocktime;\n        long PastBlocksMax = PastSecondsMax / Blocktime;\n        // current difficulty formula, ERC3 - DUAL_KGW3, written by Christian Knoepke - apfelbaum@email.de\n        // BitSend and Eropecoin Developer\n        StoredBlock BlockLastSolved = storedPrev;\n        StoredBlock BlockReading = storedPrev;\n        long PastBlocksMass = 0;\n        long PastRateActualSeconds = 0;\n        long PastRateTargetSeconds = 0;\n        double PastRateAdjustmentRatio = 1f;\n        BigInteger PastDifficultyAverage = BigInteger.valueOf(0);\n        BigInteger PastDifficultyAveragePrev = BigInteger.valueOf(0);;\n        double EventHorizonDeviation;\n        double EventHorizonDeviationFast;\n        double EventHorizonDeviationSlow;\n        BigInteger bnPowLimit = this.getMaxTarget();\n        //DUAL_KGW3 SETUP\n        if (BlockLastSolved == null || BlockLastSolved.getHeight() == 0 || (long)BlockLastSolved.getHeight() < PastBlocksMin) {\n            verifyDifficulty(this.getMaxTarget(), storedPrev, nextBlock);\n        } else {\n            for (int i = 1; BlockReading != null && BlockReading.getHeight() > 0; i++) {\n                if (PastBlocksMax > 0 && i > PastBlocksMax) { break; }\n                PastBlocksMass++;\n                PastDifficultyAverage = BlockReading.getHeader().getDifficultyTargetAsInteger();\n                if (i > 1) {\n                    if(PastDifficultyAverage.compareTo(PastDifficultyAveragePrev) >= 0)\n                        PastDifficultyAverage = ((PastDifficultyAverage.subtract(PastDifficultyAveragePrev)).divide(BigInteger.valueOf(i)).add(PastDifficultyAveragePrev));\n                    else\n                        PastDifficultyAverage = PastDifficultyAveragePrev.subtract((PastDifficultyAveragePrev.subtract(PastDifficultyAverage)).divide(BigInteger.valueOf(i)));\n                }\n                PastDifficultyAveragePrev = PastDifficultyAverage;\n                PastRateActualSeconds = BlockLastSolved.getHeader().getTimeSeconds() - BlockReading.getHeader().getTimeSeconds();\n                PastRateTargetSeconds = Blocktime * PastBlocksMass;\n                PastRateAdjustmentRatio = 1.0f;\n                if (PastRateActualSeconds < 0)\n                    PastRateActualSeconds = 0;\n                if (PastRateActualSeconds != 0 && PastRateTargetSeconds != 0)\n                    PastRateAdjustmentRatio = (double)PastRateTargetSeconds / PastRateActualSeconds;\n                EventHorizonDeviation = 1.0 + (0.7084 * java.lang.Math.pow((Double.valueOf(PastBlocksMass)/Double.valueOf(72)), -1.228));\n                EventHorizonDeviationFast = EventHorizonDeviation;\n                EventHorizonDeviationSlow = 1.0 / EventHorizonDeviation;\n                if (PastBlocksMass >= PastBlocksMin)\n                    if ((PastRateAdjustmentRatio <= EventHorizonDeviationSlow) || (PastRateAdjustmentRatio >= EventHorizonDeviationFast))\n                        break;\n                StoredBlock BlockReadingPrev = BlockReading.getPrev(blockStore);\n                if (BlockReadingPrev == null) {\n                    // Since we are using the checkpoint system, there may not be enough blocks to do this diff adjust, so skip until we do\n                    // break;\n                    return;\n                  }\n                BlockReading = BlockReadingPrev;\n            }\n            //KGW Original\n            BigInteger kgw_dual1 = PastDifficultyAverage;\n            BigInteger kgw_dual2 = storedPrev.getHeader().getDifficultyTargetAsInteger();\n            if (PastRateActualSeconds != 0 && PastRateTargetSeconds != 0) {\n                kgw_dual1 = kgw_dual1.multiply(BigInteger.valueOf(PastRateActualSeconds));\n                kgw_dual1 = kgw_dual1.and(MASK256BIT); // overflow is here, we need cut it back to 256 bit\n                kgw_dual1 = kgw_dual1.divide(BigInteger.valueOf(PastRateTargetSeconds));\n                kgw_dual1 = kgw_dual1.and(MASK256BIT);\n            }\n            StoredBlock BlockPrev = storedPrev.getPrev(blockStore);\n            long nActualTime1 = storedPrev.getHeader().getTimeSeconds() - BlockPrev.getHeader().getTimeSeconds();\n            // hack caused bug in c implementation\n            if (nActualTime1 < 0)\n                nActualTime1 = Blocktime;\n            long nActualTimespanshort = nActualTime1;\n            if (nActualTime1 < Blocktime / 3)\n                nActualTime1 = Blocktime / 3;\n            if (nActualTime1 > Blocktime * 3)\n                nActualTime1 = Blocktime * 3;\n            kgw_dual2 = kgw_dual2.multiply(BigInteger.valueOf(nActualTime1));\n            kgw_dual2 = kgw_dual2.and(MASK256BIT);\n            kgw_dual2 = kgw_dual2.divide(BigInteger.valueOf(Blocktime));\n            kgw_dual2 = kgw_dual2.and(MASK256BIT);\n            //Fusion from Retarget and Classic KGW3 (BitSend=)\n            BigInteger newDifficulty = (kgw_dual2.add(kgw_dual1)).divide(BigInteger.valueOf(2));\n            // DUAL KGW3 increased rapidly the Diff if Blocktime to last block under Blocktime/6 sec.\n            if( nActualTimespanshort < Blocktime/6 ) {\n                newDifficulty = newDifficulty.multiply(BigInteger.valueOf(85));\n                newDifficulty = newDifficulty.divide(BigInteger.valueOf(100));\n            }\n            //BitBreak BitSend\n            // Reduce difficulty if current block generation time has already exceeded maximum time limit.\n            long nLongTimeLimit = 12 * 60 * 60;\n            if ((nextBlock.getTimeSeconds() - storedPrev.getHeader().getTimeSeconds()) > nLongTimeLimit)\n                newDifficulty = bnPowLimit;\n            if (newDifficulty.compareTo(bnPowLimit) > 0)\n                newDifficulty = bnPowLimit;\n            verifyDifficulty(newDifficulty, storedPrev, nextBlock);\n        }\n    }\n    private void verifyDifficulty(BigInteger newTarget, StoredBlock storedPrev, Block nextBlock) {\n        int accuracyBytes = (int) (nextBlock.getDifficultyTarget() >>> 24) - 3;\n        long receivedTargetCompact = nextBlock.getDifficultyTarget();\n        // The calculated difficulty is to a higher precision than received, so reduce here.\n        BigInteger mask = BigInteger.valueOf(0xFFFFFFL).shiftLeft(accuracyBytes * 8);\n        newTarget = newTarget.and(mask);\n        long newTargetCompact = Utils.encodeCompactBits(newTarget);\n        if (newTargetCompact != receivedTargetCompact)\n            throw new VerificationException(\"Network provided difficulty bits do not match what was calculated: \" +\n                    Long.toHexString(newTargetCompact) + \" vs \" + Long.toHexString(receivedTargetCompact));\n    }\n    @Override\n    public Coin getMaxMoney() {\n        return MAX_MONEY;\n    }\n    @Override\n    public Coin getMinNonDustOutput() {\n        return Transaction.MIN_NONDUST_OUTPUT;\n    }\n    @Override\n    public MonetaryFormat getMonetaryFormat() {\n        return new MonetaryFormat();\n    }\n    @Override\n    public int getProtocolVersionNum(final ProtocolVersion version) {\n        return version.getBitcoinProtocolVersion();\n    }\n    @Override\n    public BitcoinSerializer getSerializer(boolean parseRetain) {\n        return new BitcoinSerializer(this, parseRetain);\n    }\n    @Override\n    public String getUriScheme() {\n        return BITCOIN_SCHEME;\n    }\n    @Override\n    public boolean hasMaxMoney() {\n        return true;\n    }\n"]]}
{"hexsha": "7c787218d14b5fd3d476665b129cf5b56607ca47", "ext": "java", "lang": "Java", "content": "public class Geometry {\n\n    private final int cylinders;\n    private final int heads;\n    private final int sectors;\n\n    /**\n     * Create a new instance\n     *\n     * @param c The number of cylinders\n     * @param h The number of heads\n     * @param s The number of sectors/cylinder\n     */\n    public Geometry(int c, int h, int s) {\n        this.cylinders = c;\n        this.heads = h;\n        this.sectors = s;\n    }\n\n    /**\n     * @return int\n     */\n    public int getCylinders() {\n        return cylinders;\n    }\n\n    /**\n     * @return int\n     */\n    public int getHeads() {\n        return heads;\n    }\n\n    /**\n     * @return int\n     */\n    public int getSectors() {\n        return sectors;\n    }\n\n    /**\n     * Gets the total number of sectors\n     *\n     * @return int\n     */\n    public long getTotalSectors() {\n        long v = cylinders;\n        v *= heads;\n        v *= sectors;\n        return v;\n    }\n\n    /**\n     * Gets the logical sector number for a given CHS.\n     *\n     * @param chs\n     * @return long\n     */\n    public long getLogicalSector(CHS chs) {\n        //ls = c*H*S + h*S + s - 1\n        long v = chs.getCylinder() * heads * sectors;\n        v += chs.getHead() * sectors;\n        v += chs.getSector();\n        return v - 1;\n    }\n\n    /**\n     * Gets a CHS from a given logical sector number\n     *\n     * @param logicalSector\n     * @return CHS\n     * @throws GeometryException\n     */\n    public CHS getCHS(long logicalSector) throws GeometryException {\n        // ls = (c*H + h) * S + s - 1\n\n        long v = logicalSector;\n        int s = (int) ((v % sectors) + 1);\n        v = v / sectors;\n        int h = (int) (v % heads);\n        v = v / heads;\n        int c = (int) v;\n\n        try {\n            return new CHS(c, h, s);\n        } catch (IllegalArgumentException iae) {\n            throw new GeometryException(\"can't get CHS for logical sector \" + logicalSector, iae);\n        }\n    }\n\n    /**\n     * increments the given sector and returns the next logical sector as CHS-value\n     *\n     * @param chsToIncrement\n     * @return the CHS value of next sector\n     * @throws GeometryException\n     */\n    public CHS nextSector(CHS chsToIncrement) throws GeometryException {\n\n        int s = chsToIncrement.getSector();\n        int h = chsToIncrement.getHead();\n        int c = chsToIncrement.getCylinder();\n\n        s++;\n\n        if (s > sectors) {\n            s = 1;\n            h++;\n            if (h >= heads) {\n                h = 0;\n                c++;\n                if (c >= cylinders) {\n                    throw new GeometryException(\"this geometry doesn't support cyclinder\" + c);\n                }\n            }\n        }\n        return new CHS(c, h, s);\n    }\n}", "class_id": 0, "repo": "rgarza-wizeline/jnode-fs", "file": "src/main/java/org/jnode/driver/block/Geometry.java", "last_update_at": "2020-12-18T09:25:41+00:00", "question_id": "7c787218d14b5fd3d476665b129cf5b56607ca47", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Geometry {\n    private final int cylinders;\n    private final int heads;\n    private final int sectors;\n    /**\n     * Create a new instance\n     *\n     * @param c The number of cylinders\n     * @param h The number of heads\n     * @param s The number of sectors/cylinder\n     */\n    public Geometry(int c, int h, int s) {\n        this.cylinders = c;\n        this.heads = h;\n        this.sectors = s;\n    }\n    /**\n     * @return int\n     */\n    public int getCylinders() {\n        return cylinders;\n    }\n    /**\n     * @return int\n     */\n    public int getHeads() {\n        return heads;\n    }\n    /**\n     * @return int\n     */\n    public int getSectors() {\n        return sectors;\n    }\n    /**\n     * Gets the total number of sectors\n     *\n     * @return int\n     */\n    public long getTotalSectors() {\n        long v = cylinders;\n        v *= heads;\n        v *= sectors;\n        return v;\n    }\n    /**\n     * Gets the logical sector number for a given CHS.\n     *\n     * @param chs\n     * @return long\n     */\n    public long getLogicalSector(CHS chs) {\n        //ls = c*H*S + h*S + s - 1\n        long v = chs.getCylinder() * heads * sectors;\n        v += chs.getHead() * sectors;\n        v += chs.getSector();\n        return v - 1;\n    }\n    /**\n     * Gets a CHS from a given logical sector number\n     *\n     * @param logicalSector\n     * @return CHS\n     * @throws GeometryException\n     */\n    public CHS getCHS(long logicalSector) throws GeometryException {\n        // ls = (c*H + h) * S + s - 1\n        long v = logicalSector;\n        int s = (int) ((v % sectors) + 1);\n        v = v / sectors;\n        int h = (int) (v % heads);\n        v = v / heads;\n        int c = (int) v;\n        try {\n            return new CHS(c, h, s);\n        } catch (IllegalArgumentException iae) {\n            throw new GeometryException(\"can't get CHS for logical sector \" + logicalSector, iae);\n        }\n    }\n    /**\n     * increments the given sector and returns the next logical sector as CHS-value\n     *\n     * @param chsToIncrement\n     * @return the CHS value of next sector\n     * @throws GeometryException\n     */\n    public CHS nextSector(CHS chsToIncrement) throws GeometryException {\n        int s = chsToIncrement.getSector();\n        int h = chsToIncrement.getHead();\n        int c = chsToIncrement.getCylinder();\n        s++;\n        if (s > sectors) {\n            s = 1;\n            h++;\n            if (h >= heads) {\n                h = 0;\n                c++;\n                if (c >= cylinders) {\n                    throw new GeometryException(\"this geometry doesn't support cyclinder\" + c);\n                }\n            }\n        }\n        return new CHS(c, h, s);\n    }\n"]]}
{"hexsha": "abdf24eaf6e987a6f9a2f58b74d289039d5e7314", "ext": "java", "lang": "Java", "content": "public class MCIBoundedExistenceChecker extends BoundedExistenceChecker {\n    public MCIBoundedExistenceChecker() {\n\n        super();\n    }\n\n    @Override\n    protected boolean evaluateState(Snapshot snapshot, Property verificationProperty) {\n        int ambNum = 0;\n        String tmp = \"\";\n\n        StringTokenizer st = new StringTokenizer(snapshot.getSnapshotString(), \" \");\n        while (st.hasMoreTokens()) {\n            String target = st.nextToken();\n            if (target.equals(\"CurrentAmb:\")) {\n                ambNum = Integer.parseInt(st.nextToken());\n            } else if (target.equals(\"Amb:\")) {\n                for (int i = 0; i < ambNum; i++) {\n                    tmp = st.nextToken();\n                    StringTokenizer st2 = new StringTokenizer(tmp, \"/\");\n                    st2.nextToken();\n\n                    if (st2.nextToken().equals(verificationProperty.getState())) { // Ambulance\uc758 State\uac00 Free\uc778\uc9c0 \uc544\ub2cc\uc9c0 \ud655\uc778\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean check(Log log, Property verificationProperty, int until) {\n        return false;\n    }\n\n    @Override\n    public boolean check(Log log, Property verificationProperty, double prob, int T) {\n        return false;\n    }\n\n    @Override\n    public boolean check(Log log, Property verificationProperty, double prob, int t, int T) {\n        return false;\n    }\n\n    @Override\n    public boolean check(Log log, Property verificationProperty, int t, int T) {\n        return false;\n    }\n\n    @Override\n    protected boolean evaluateState(Log log, Property verificationProperty) {\n        return false;\n    }\n}", "class_id": 0, "repo": "sumin0407/Runtime-Monitoring", "file": "engine/src/property/MCIBoundedExistenceChecker.java", "last_update_at": "2020-11-12T06:19:25+00:00", "question_id": "abdf24eaf6e987a6f9a2f58b74d289039d5e7314", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MCIBoundedExistenceChecker extends BoundedExistenceChecker {\n    public MCIBoundedExistenceChecker() {\n        super();\n    }\n    @Override\n    protected boolean evaluateState(Snapshot snapshot, Property verificationProperty) {\n        int ambNum = 0;\n        String tmp = \"\";\n        StringTokenizer st = new StringTokenizer(snapshot.getSnapshotString(), \" \");\n        while (st.hasMoreTokens()) {\n            String target = st.nextToken();\n            if (target.equals(\"CurrentAmb:\")) {\n                ambNum = Integer.parseInt(st.nextToken());\n            } else if (target.equals(\"Amb:\")) {\n                for (int i = 0; i < ambNum; i++) {\n                    tmp = st.nextToken();\n                    StringTokenizer st2 = new StringTokenizer(tmp, \"/\");\n                    st2.nextToken();\n                    if (st2.nextToken().equals(verificationProperty.getState())) { // Ambulance\uc758 State\uac00 Free\uc778\uc9c0 \uc544\ub2cc\uc9c0 \ud655\uc778\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    @Override\n    public boolean check(Log log, Property verificationProperty, int until) {\n        return false;\n    }\n    @Override\n    public boolean check(Log log, Property verificationProperty, double prob, int T) {\n        return false;\n    }\n    @Override\n    public boolean check(Log log, Property verificationProperty, double prob, int t, int T) {\n        return false;\n    }\n    @Override\n    public boolean check(Log log, Property verificationProperty, int t, int T) {\n        return false;\n    }\n    @Override\n    protected boolean evaluateState(Log log, Property verificationProperty) {\n        return false;\n    }\n"]]}
{"hexsha": "405269e118ad851aff1587464894a803c15db7cf", "ext": "java", "lang": "Java", "content": "public class Boj15354 {\n\tpublic static void main(String[] args) throws Exception{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint N = Integer.parseInt(br.readLine());\n\t\t\n\t\tint count = 0;\n\t\tchar current = ' ';\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tchar next = br.readLine().charAt(0);\n\t\t\t\n\t\t\tif(current != next) count++;\n\t\t\tcurrent = next;\n\t\t}\n\t\t\n\t\tSystem.out.println(count + 1);\n\t}\n}", "class_id": 0, "repo": "minuk8932/Algorithm_BaekJoon", "file": "src/string_handle/Boj15354.java", "last_update_at": "2020-08-20T10:35:30+00:00", "question_id": "405269e118ad851aff1587464894a803c15db7cf", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Boj15354 {\n\tpublic static void main(String[] args) throws Exception{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint N = Integer.parseInt(br.readLine());\n\t\t\n\t\tint count = 0;\n\t\tchar current = ' ';\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tchar next = br.readLine().charAt(0);\n\t\t\t\n\t\t\tif(current != next) count++;\n\t\t\tcurrent = next;\n\t\t}\n\t\t\n\t\tSystem.out.println(count + 1);\n\t}\n"]]}
{"hexsha": "435276314285ceb5c55928c9c65410123c18524b", "ext": "java", "lang": "Java", "content": "public class GameWorld extends World\n{\n\tpublic GameWorld(Game game)\n\t{\n\t\tthis.game = game;\n\t\t\n\t\taddEntity(new EntityGrayEnemy(this, new Vector2D(0, 0)));\n\t}\n\t\n\t@Override\n\tpublic void update(InputHandler handler)\n\t{\n\t\t// update players\n\t\tfor(int i = 0; i < Game.MaxPlayer; i++)\n\t\t{\n\t\t\tif(players[i] == null)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif(i == game.localID) // local player\n\t\t\t{\n\t\t\t\tplayers[i].lastMouseX = players[i].mouseX;\n\t\t\t\tplayers[i].lastMouseY = players[i].mouseY;\n\t\t\t\tplayers[i].lastLeftDown = players[i].leftDown;\n\t\t\t\t\n\t\t\t\tplayers[i].lastLeft = players[i].left;\n\t\t\t\tplayers[i].lastRight = players[i].right;\n\t\t\t\tplayers[i].lastJump = players[i].jump;\n\t\t\t\tplayers[i].lastSprint = players[i].sprint;\n\t\t\t\tplayers[i].lastSneak = players[i].sneak;\n\t\t\t\t\n\t\t\t\tplayers[i].mouseX = handler.mouseX;\n\t\t\t\tplayers[i].mouseY = handler.mouseY;\n\t\t\t\tplayers[i].leftDown = Controls.punch.isPressed(handler);\n\t\t\t\t\n\t\t\t\tplayers[i].left = Controls.left.isPressed(handler);\n\t\t\t\tplayers[i].right = Controls.right.isPressed(handler);\n\t\t\t\tplayers[i].jump = Controls.jump.isPressed(handler);\n\t\t\t\tplayers[i].sprint = Controls.sprint.isPressed(handler);\n\t\t\t\tplayers[i].sneak = Controls.sneak.isPressed(handler);\n\t\t\t}\n\t\t\t\n\t\t\tplayers[i].update(this);\n\t\t}\n\t\t\n\t\tsuper.update(handler);\n\t}\n\t\n// Player stuff\n\tpublic Player getLocalPlayer()\n\t{\n\t\treturn players[game.localID];\n\t}\n\t\n/**\n * Only creates a 'Player, not an 'EntityPlayer'\n * @param playerID\n */\n\tpublic void createPlayer(int playerID)\n\t{\n\t\tif(players[playerID] == null)\n\t\t\tplayers[playerID] = new Player(playerID);\n\t}\n\t\n/**\n * Creates a 'Player' and 'EntityPlayer'\n * @param playerID\n */\n\tpublic void createPlayerEntity(int playerID)\n\t{\n\t\tif(players[playerID] == null)\n\t\t\tcreatePlayer(playerID);\n\t\telse\n\t\t\tremovePlayerEntity(playerID);\n\t\t\n\t\tplayers[playerID].entity = new EntityPlayer(this, players[playerID]);\n\t\taddEntity(players[playerID].entity);\n\t}\n\t\n\tpublic void removePlayer(int playerID)\n\t{\n\t\tif(players[playerID] == null)\n\t\t\treturn;\n\t\t\n\t\tremovePlayerEntity(playerID);\n\t\tplayers[playerID] = null;\n\t}\n\t\n\tpublic void removePlayerEntity(int playerID)\n\t{\n\t\tif(players[playerID] == null || players[playerID].entity == null)\n\t\t\treturn;\n\t\t\n\t\tremoveEntity(players[playerID].entity);\n\t\tplayers[playerID].entity = null;\n\t}\n\t\n\tpublic void swapPlayer(int id1, int id2)\n\t{\n\t\tPlayer player = players[id1];\n\t\tplayers[id1] = players[id2];\n\t\tplayers[id2] = player;\n\t\t\n\t\tif(players[id1] != null)\n\t\t\tplayers[id1].id = id1;\n\t\tif(players[id2] != null)\n\t\t\tplayers[id2].id = id2;\n\t}\n\t\n//\n\t@Override\n\tpublic void onEntityAdded(Entity entity)\n\t{\n//\t\tif(game.gameState == Game.STATE_MULTIPLAYER_SERVER)\n//\t\t{\n//\t\t\tif(entity instanceof EntityPlayer)\n//\t\t\t{\n//\t\t\t\tEntityPlayer player = (EntityPlayer)entity;\n//\t\t\t\tgame.server.send(\"player_a:\" +player.id);\n//\t\t\t}\n//\t\t}\n\t}\n\t\n\t@Override\n\tpublic void onEntityRemoved(Entity entity)\n\t{\n\t\tif(entity instanceof EntityPlayer || !(entity instanceof EntityLiving))\n\t\t\treturn;\n\t\t\n\t\tgame.addCoins(10);\n\t}\n\t\n// draw\n\t@Override\n\tpublic int playerInsideHidden(EntityPlayer player)\n\t{\n\t\tint l = (int)player.pos.x;\n\t\tif(player.pos.x < 0.0D)\n\t\t\tl--;\n\t\tint r = (int)(player.pos.x + EntityPlayer.WorldSize);\n\t\tif(player.pos.x + EntityPlayer.WorldSize < 0.0D || getLocalPlayer().entity.pos.x + EntityPlayer.WorldSize == r)\n\t\t\tr--;\n\t\tint t = (int)player.pos.y;\n\t\tif(player.pos.y < 0.0D)\n\t\t\tt--;\n\t\tint b = (int)(player.pos.y + EntityPlayer.WorldSize);\n\t\tif(player.pos.y + EntityPlayer.WorldSize < 0.0D || getLocalPlayer().entity.pos.y + EntityPlayer.WorldSize == b)\n\t\t\tb--;\n\t\t\n\t\t// update block data\n\t\tfor(int y = t; y <= b; y++)\n\t\t{\n\t\t\tfor(int x = l; x <= r; x++)\n\t\t\t{\n\t\t\t\tBlockData data = getBlockData(Block.hidden.getLayer(), x, y);\n\t\t\t\tif(data != null && data instanceof BlockDataHidden)\n\t\t\t\t{\n\t\t\t\t\tDataValue dataValue = (DataValue)data.get(0);\n\t\t\t\t\treturn dataValue.value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\t\n\t@Override\n\tpublic void drawPlayer(Graphics g, int xOffset, int yOffset)\n\t{\n\t\tfor(int i = 0; i < Game.MaxPlayer; i++)\n\t\t{\n\t\t\tif(players[i] != null && players[i].entity != null && !players[i].entity.dead)\n\t\t\t{\n\t\t\t\tplayers[i].entity.draw(g, xOffset, yOffset);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic final Game game;\n\tpublic Player players[] = new Player[Game.MaxPlayer];\n}", "class_id": 0, "repo": "ChillerDragon/Acadyan", "file": "src/krisko/acadyan/GameWorld.java", "last_update_at": "2020-11-30T12:13:02+00:00", "question_id": "435276314285ceb5c55928c9c65410123c18524b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GameWorld extends World\n{\n\tpublic GameWorld(Game game)\n\t{\n\t\tthis.game = game;\n\t\t\n\t\taddEntity(new EntityGrayEnemy(this, new Vector2D(0, 0)));\n\t}\n\t\n\t@Override\n\tpublic void update(InputHandler handler)\n\t{\n\t\t// update players\n\t\tfor(int i = 0; i < Game.MaxPlayer; i++)\n\t\t{\n\t\t\tif(players[i] == null)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif(i == game.localID) // local player\n\t\t\t{\n\t\t\t\tplayers[i].lastMouseX = players[i].mouseX;\n\t\t\t\tplayers[i].lastMouseY = players[i].mouseY;\n\t\t\t\tplayers[i].lastLeftDown = players[i].leftDown;\n\t\t\t\t\n\t\t\t\tplayers[i].lastLeft = players[i].left;\n\t\t\t\tplayers[i].lastRight = players[i].right;\n\t\t\t\tplayers[i].lastJump = players[i].jump;\n\t\t\t\tplayers[i].lastSprint = players[i].sprint;\n\t\t\t\tplayers[i].lastSneak = players[i].sneak;\n\t\t\t\t\n\t\t\t\tplayers[i].mouseX = handler.mouseX;\n\t\t\t\tplayers[i].mouseY = handler.mouseY;\n\t\t\t\tplayers[i].leftDown = Controls.punch.isPressed(handler);\n\t\t\t\t\n\t\t\t\tplayers[i].left = Controls.left.isPressed(handler);\n\t\t\t\tplayers[i].right = Controls.right.isPressed(handler);\n\t\t\t\tplayers[i].jump = Controls.jump.isPressed(handler);\n\t\t\t\tplayers[i].sprint = Controls.sprint.isPressed(handler);\n\t\t\t\tplayers[i].sneak = Controls.sneak.isPressed(handler);\n\t\t\t}\n\t\t\t\n\t\t\tplayers[i].update(this);\n\t\t}\n\t\t\n\t\tsuper.update(handler);\n\t}\n\t\n// Player stuff\n\tpublic Player getLocalPlayer()\n\t{\n\t\treturn players[game.localID];\n\t}\n\t\n/**\n * Only creates a 'Player, not an 'EntityPlayer'\n * @param playerID\n */\n\tpublic void createPlayer(int playerID)\n\t{\n\t\tif(players[playerID] == null)\n\t\t\tplayers[playerID] = new Player(playerID);\n\t}\n\t\n/**\n * Creates a 'Player' and 'EntityPlayer'\n * @param playerID\n */\n\tpublic void createPlayerEntity(int playerID)\n\t{\n\t\tif(players[playerID] == null)\n\t\t\tcreatePlayer(playerID);\n\t\telse\n\t\t\tremovePlayerEntity(playerID);\n\t\t\n\t\tplayers[playerID].entity = new EntityPlayer(this, players[playerID]);\n\t\taddEntity(players[playerID].entity);\n\t}\n\t\n\tpublic void removePlayer(int playerID)\n\t{\n\t\tif(players[playerID] == null)\n\t\t\treturn;\n\t\t\n\t\tremovePlayerEntity(playerID);\n\t\tplayers[playerID] = null;\n\t}\n\t\n\tpublic void removePlayerEntity(int playerID)\n\t{\n\t\tif(players[playerID] == null || players[playerID].entity == null)\n\t\t\treturn;\n\t\t\n\t\tremoveEntity(players[playerID].entity);\n\t\tplayers[playerID].entity = null;\n\t}\n\t\n\tpublic void swapPlayer(int id1, int id2)\n\t{\n\t\tPlayer player = players[id1];\n\t\tplayers[id1] = players[id2];\n\t\tplayers[id2] = player;\n\t\t\n\t\tif(players[id1] != null)\n\t\t\tplayers[id1].id = id1;\n\t\tif(players[id2] != null)\n\t\t\tplayers[id2].id = id2;\n\t}\n\t\n//\n\t@Override\n\tpublic void onEntityAdded(Entity entity)\n\t{\n//\t\tif(game.gameState == Game.STATE_MULTIPLAYER_SERVER)\n//\t\t{\n//\t\t\tif(entity instanceof EntityPlayer)\n//\t\t\t{\n//\t\t\t\tEntityPlayer player = (EntityPlayer)entity;\n//\t\t\t\tgame.server.send(\"player_a:\" +player.id);\n//\t\t\t}\n//\t\t}\n\t}\n\t\n\t@Override\n\tpublic void onEntityRemoved(Entity entity)\n\t{\n\t\tif(entity instanceof EntityPlayer || !(entity instanceof EntityLiving))\n\t\t\treturn;\n\t\t\n\t\tgame.addCoins(10);\n\t}\n\t\n// draw\n\t@Override\n\tpublic int playerInsideHidden(EntityPlayer player)\n\t{\n\t\tint l = (int)player.pos.x;\n\t\tif(player.pos.x < 0.0D)\n\t\t\tl--;\n\t\tint r = (int)(player.pos.x + EntityPlayer.WorldSize);\n\t\tif(player.pos.x + EntityPlayer.WorldSize < 0.0D || getLocalPlayer().entity.pos.x + EntityPlayer.WorldSize == r)\n\t\t\tr--;\n\t\tint t = (int)player.pos.y;\n\t\tif(player.pos.y < 0.0D)\n\t\t\tt--;\n\t\tint b = (int)(player.pos.y + EntityPlayer.WorldSize);\n\t\tif(player.pos.y + EntityPlayer.WorldSize < 0.0D || getLocalPlayer().entity.pos.y + EntityPlayer.WorldSize == b)\n\t\t\tb--;\n\t\t\n\t\t// update block data\n\t\tfor(int y = t; y <= b; y++)\n\t\t{\n\t\t\tfor(int x = l; x <= r; x++)\n\t\t\t{\n\t\t\t\tBlockData data = getBlockData(Block.hidden.getLayer(), x, y);\n\t\t\t\tif(data != null && data instanceof BlockDataHidden)\n\t\t\t\t{\n\t\t\t\t\tDataValue dataValue = (DataValue)data.get(0);\n\t\t\t\t\treturn dataValue.value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\t\n\t@Override\n\tpublic void drawPlayer(Graphics g, int xOffset, int yOffset)\n\t{\n\t\tfor(int i = 0; i < Game.MaxPlayer; i++)\n\t\t{\n\t\t\tif(players[i] != null && players[i].entity != null && !players[i].entity.dead)\n\t\t\t{\n\t\t\t\tplayers[i].entity.draw(g, xOffset, yOffset);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic final Game game;\n\tpublic Player players[] = new Player[Game.MaxPlayer];\n"]]}
{"hexsha": "ddb5b3026235ba7a3bddf3ecf1505502cfcf4ce2", "ext": "java", "lang": "Java", "content": "public class LayerCacheUtils {\n\n  private LayerCacheUtils() {}\n\n  /** @return number of actually collected, which may be less than or equals to pointNumber */\n  public static int cachePoints(\n      TSDataType dataType,\n      LayerPointReader source,\n      ElasticSerializableTVList target,\n      int pointNumber)\n      throws QueryProcessException, IOException {\n    int count = 0;\n    while (count < pointNumber && cachePoint(dataType, source, target)) {\n      ++count;\n    }\n    return count;\n  }\n\n  public static boolean cachePoint(\n      TSDataType dataType, LayerPointReader source, ElasticSerializableTVList target)\n      throws IOException, QueryProcessException {\n    if (!source.next()) {\n      return false;\n    }\n    if (source.isCurrentNull()) {\n      target.putNull(source.currentTime());\n    } else {\n      switch (dataType) {\n        case INT32:\n          target.putInt(source.currentTime(), source.currentInt());\n          break;\n        case INT64:\n          target.putLong(source.currentTime(), source.currentLong());\n          break;\n        case FLOAT:\n          target.putFloat(source.currentTime(), source.currentFloat());\n          break;\n        case DOUBLE:\n          target.putDouble(source.currentTime(), source.currentDouble());\n          break;\n        case BOOLEAN:\n          target.putBoolean(source.currentTime(), source.currentBoolean());\n          break;\n        case TEXT:\n          target.putBinary(\n              source.currentTime(),\n              UDFBinaryTransformer.transformToUDFBinary(source.currentBinary()));\n          break;\n        default:\n          throw new UnsupportedOperationException(dataType.name());\n      }\n    }\n\n    source.readyForNext();\n\n    return true;\n  }\n\n  /** @return number of actually collected, which may be less than or equals to rowsNumber */\n  public static int cacheRows(\n      IUDFInputDataSet source, ElasticSerializableRowRecordList target, int rowsNumber)\n      throws QueryProcessException, IOException {\n    int count = 0;\n    while (count < rowsNumber && cacheRow(source, target)) {\n      ++count;\n    }\n    return count;\n  }\n\n  public static boolean cacheRow(IUDFInputDataSet source, ElasticSerializableRowRecordList target)\n      throws IOException, QueryProcessException {\n    if (source.hasNextRowInObjects()) {\n      target.put(source.nextRowInObjects());\n      return true;\n    } else {\n      return false;\n    }\n  }\n}", "class_id": 0, "repo": "apache/incubator-iotdb", "file": "server/src/main/java/org/apache/iotdb/db/mpp/transformation/dag/util/LayerCacheUtils.java", "last_update_at": "2020-10-01T04:17:02+00:00", "question_id": "ddb5b3026235ba7a3bddf3ecf1505502cfcf4ce2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LayerCacheUtils {\n  private LayerCacheUtils() {}\n  /** @return number of actually collected, which may be less than or equals to pointNumber */\n  public static int cachePoints(\n      TSDataType dataType,\n      LayerPointReader source,\n      ElasticSerializableTVList target,\n      int pointNumber)\n      throws QueryProcessException, IOException {\n    int count = 0;\n    while (count < pointNumber && cachePoint(dataType, source, target)) {\n      ++count;\n    }\n    return count;\n  }\n  public static boolean cachePoint(\n      TSDataType dataType, LayerPointReader source, ElasticSerializableTVList target)\n      throws IOException, QueryProcessException {\n    if (!source.next()) {\n      return false;\n    }\n    if (source.isCurrentNull()) {\n      target.putNull(source.currentTime());\n    } else {\n      switch (dataType) {\n        case INT32:\n          target.putInt(source.currentTime(), source.currentInt());\n          break;\n        case INT64:\n          target.putLong(source.currentTime(), source.currentLong());\n          break;\n        case FLOAT:\n          target.putFloat(source.currentTime(), source.currentFloat());\n          break;\n        case DOUBLE:\n          target.putDouble(source.currentTime(), source.currentDouble());\n          break;\n        case BOOLEAN:\n          target.putBoolean(source.currentTime(), source.currentBoolean());\n          break;\n        case TEXT:\n          target.putBinary(\n              source.currentTime(),\n              UDFBinaryTransformer.transformToUDFBinary(source.currentBinary()));\n          break;\n        default:\n          throw new UnsupportedOperationException(dataType.name());\n      }\n    }\n    source.readyForNext();\n    return true;\n  }\n  /** @return number of actually collected, which may be less than or equals to rowsNumber */\n  public static int cacheRows(\n      IUDFInputDataSet source, ElasticSerializableRowRecordList target, int rowsNumber)\n      throws QueryProcessException, IOException {\n    int count = 0;\n    while (count < rowsNumber && cacheRow(source, target)) {\n      ++count;\n    }\n    return count;\n  }\n  public static boolean cacheRow(IUDFInputDataSet source, ElasticSerializableRowRecordList target)\n      throws IOException, QueryProcessException {\n    if (source.hasNextRowInObjects()) {\n      target.put(source.nextRowInObjects());\n      return true;\n    } else {\n      return false;\n    }\n  }\n"]]}
{"hexsha": "bd407743f079c1913d3f4aa526acfab7ae0bcab8", "ext": "java", "lang": "Java", "content": "public class GoogleSearchPageObjTest {\n    WebDriver driver;\n\n    @Before\n    public void setUp() throws Exception {\n        driver = new FirefoxDriver();\n    }\n\n    @Test\n    public void workWithBasicAuthTest() {\n        GoogleSearchPageObj google = new GoogleSearchPageObj(driver);\n        google.searchFor(\"elemental selenium tips\");\n        boolean result = google.searchResultPresent(\"Recieve a Free, Weekly tip\");\n        assert (result == true);\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        driver.quit();\n    }\n}", "class_id": 0, "repo": "tourdedave/selenium-tips", "file": "07-use-a-page-object/java/src/test/java/GoogleSearchPageObjTest.java", "last_update_at": "2020-06-26T16:16:12+00:00", "question_id": "bd407743f079c1913d3f4aa526acfab7ae0bcab8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GoogleSearchPageObjTest {\n    WebDriver driver;\n    @Before\n    public void setUp() throws Exception {\n        driver = new FirefoxDriver();\n    }\n    @Test\n    public void workWithBasicAuthTest() {\n        GoogleSearchPageObj google = new GoogleSearchPageObj(driver);\n        google.searchFor(\"elemental selenium tips\");\n        boolean result = google.searchResultPresent(\"Recieve a Free, Weekly tip\");\n        assert (result == true);\n    }\n    @After\n    public void tearDown() throws Exception {\n        driver.quit();\n    }\n"]]}
{"hexsha": "58ad840e21196d577a9e480e753fcfc8ee56aea8", "ext": "java", "lang": "Java", "content": "public class PoetCodeUtil {\n\n    /**\n     * @param targetClass\n     * @return field and field type\n     */\n    public static HashMap<String, TypeName> createFieldMap(TypeElement targetClass) {\n        HashMap<String, TypeName> fieldMap = new HashMap<>();\n        for (Element encloseElement : targetClass.getEnclosedElements()) {\n            if (encloseElement.getKind() == ElementKind.FIELD) {\n                String fieldName = encloseElement.getSimpleName().toString();\n                TypeName fieldTypeName = TypeName.get(encloseElement.asType());\n                fieldMap.put(fieldName, fieldTypeName);\n            }\n        }\n        return fieldMap;\n    }\n\n    public static String createNewClazzName(TypeElement targetClass, String suffix) {\n        String originClazzName = targetClass.getSimpleName().toString();\n        return originClazzName + suffix;\n    }\n\n    public static ClassName createNewClazzType(String pkg, String newClazzName, String... clazzNames) {\n        return ClassName.get(pkg, newClazzName, clazzNames);\n    }\n\n    public static String getTargetPkgName(TypeElement targetClass, Elements elementUtils) {\n        PackageElement pkg = elementUtils.getPackageOf(targetClass);\n        return pkg.getQualifiedName().toString();\n    }\n\n    public static MethodSpec createConstructMethod(Modifier... modifiers) {\n        MethodSpec.Builder method = MethodSpec.constructorBuilder()\n                .addModifiers(modifiers);\n        return method.build();\n    }\n\n    public static MethodSpec createSetReturn(TypeName returnType, String fieldName, TypeName fieldType, Modifier... modifiers) {\n        String methodName = \"set\" + upperFirstChar(fieldName);\n        MethodSpec.Builder method = MethodSpec.methodBuilder(methodName)\n                .addModifiers(modifiers)\n                .returns(returnType)\n                .addParameter(fieldType, fieldName)\n                .addStatement(\"this.$L = $L\", fieldName, fieldName)\n                .addStatement(\"return this\");\n        return method.build();\n    }\n\n    public static MethodSpec createSet(String fieldName, TypeName fieldType, Modifier... modifiers) {\n        String methodName = \"set\" + upperFirstChar(fieldName);\n        MethodSpec.Builder method = MethodSpec.methodBuilder(methodName)\n                .addModifiers(modifiers)\n                .addParameter(fieldType, fieldName)\n                .addStatement(\"this.$L = $L\", fieldName, fieldName);\n        return method.build();\n    }\n\n    public static MethodSpec createGet(String fieldName, TypeName fieldType, Modifier... modifiers) {\n        String methodName = \"get\" + upperFirstChar(fieldName);\n        MethodSpec.Builder method = MethodSpec.methodBuilder(methodName)\n                .addModifiers(modifiers)\n                .returns(fieldType)\n                .addStatement(\"return \" + fieldName);\n        return method.build();\n    }\n\n    public static MethodSpec createToString(String clazzName, HashMap<String, TypeName> fieldMap, Modifier... modifiers) {\n        String methodName = \"toString\";\n        MethodSpec.Builder method = MethodSpec.methodBuilder(methodName)\n                .addModifiers(modifiers)\n                .addAnnotation(Override.class)\n                .returns(String.class);\n\n        StringBuilder stringBuilder = new StringBuilder();\n        stringBuilder.append(\"\\\"\")\n                .append(clazzName)\n                .append(\"{\\\"\");\n        for (String field : fieldMap.keySet()) {\n            stringBuilder.append(\" + \\\"\").append(field).append(\":\\\" + \").append(field);\n        }\n        stringBuilder.append(\" + \\\"}\\\"\");\n        method.addStatement(\"return \" + stringBuilder.toString());\n        return method.build();\n    }\n\n\n    public static String upperFirstChar(String str) {\n        char[] ch = str.toCharArray();\n        if (ch[0] >= 'a' && ch[0] <= 'z') {\n            ch[0] = (char) (ch[0] - 32);\n        }\n        return new String(ch);\n    }\n\n    public static class Parcelable {\n        public static void createParcelable(TypeName typeName, TypeSpec.Builder typeSpecBuilder, HashMap<String, TypeName> fieldMap) {\n            ClassName parcelableType = ClassName.get(\"android.os\", \"Parcelable\");\n            ClassName parcelType = ClassName.get(\"android.os\", \"Parcel\");\n            ClassName parcelableCreator = ClassName.get(\"android.os\", \"Parcelable\", \"Creator\");\n            TypeName creatorFieldType = ParameterizedTypeName.get(parcelableCreator, typeName);\n\n            //1. implements Parcelable\n            typeSpecBuilder.addSuperinterface(parcelableType);\n\n            //2. describeContents\n            MethodSpec.Builder method = MethodSpec.methodBuilder(\"describeContents\")\n                    .addModifiers(Modifier.PUBLIC)\n                    .addAnnotation(Override.class)\n                    .returns(int.class)\n                    .addStatement(\"return 0\");\n\n            //3. writeToParcel\n            MethodSpec.Builder method1 = MethodSpec.methodBuilder(\"writeToParcel\")\n                    .addModifiers(Modifier.PUBLIC)\n                    .addAnnotation(Override.class)\n                    .addParameter(parcelType, \"dest\")\n                    .addParameter(int.class, \"flags\");\n            for (String field : fieldMap.keySet()) {\n                method1.addStatement(\"dest.writeValue($L)\", \"this.\" + field);\n            }\n\n            //4. construct(Parcel in)\n            MethodSpec.Builder method2 = MethodSpec.constructorBuilder()\n                    .addModifiers(Modifier.PUBLIC)\n                    .addParameter(parcelType, \"in\")\n                    .addStatement(\"$T classLoader = this.getClass().getClassLoader()\", ClassLoader.class);\n            for (String field : fieldMap.keySet()) {\n                method2.addStatement(\"this.$L = ($T)in.readValue(classLoader)\", field, fieldMap.get(field));\n            }\n\n            //5. CREATOR\n            ArrayTypeName newTypeArray = ArrayTypeName.of(typeName);\n            TypeSpec parcelableCreatorType = TypeSpec.anonymousClassBuilder(\"\")\n                    .addSuperinterface(creatorFieldType)\n                    .addMethod(MethodSpec.methodBuilder(\"createFromParcel\")\n                            .addAnnotation(Override.class)\n                            .addModifiers(Modifier.PUBLIC)\n                            .addParameter(parcelType, \"source\")\n                            .returns(typeName)\n                            .addStatement(\"return new $T($N)\", typeName, \"source\")\n                            .build())\n                    .addMethod(MethodSpec.methodBuilder(\"newArray\")\n                            .addAnnotation(Override.class)\n                            .addModifiers(Modifier.PUBLIC)\n                            .addParameter(int.class, \"size\")\n                            .returns(newTypeArray)\n                            .addStatement(\"return new $T[$N]\", typeName, \"size\")\n                            .build())\n                    .build();\n            FieldSpec.Builder creatorField = FieldSpec.builder(creatorFieldType, \"CREATOR\")\n                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)\n                    .initializer(\"$L\", parcelableCreatorType);\n\n            typeSpecBuilder.addMethod(method.build());\n            typeSpecBuilder.addMethod(method1.build());\n            typeSpecBuilder.addMethod(method2.build());\n            typeSpecBuilder.addField(creatorField.build());\n        }\n    }\n\n    public static class Builder {\n        public static TypeSpec createBuilder(String pkgName, String newClazzName, HashMap<String, TypeName> fieldMap) {\n            ClassName newClassName = PoetCodeUtil.createNewClazzType(pkgName, newClazzName);\n            ClassName builderClassName = PoetCodeUtil.createNewClazzType(pkgName, newClazzName, \"Builder\");\n            TypeSpec.Builder typeSpecB = TypeSpec.classBuilder(\"Builder\")\n                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n            for (String field : fieldMap.keySet()) {\n                typeSpecB.addField(fieldMap.get(field), field, Modifier.PRIVATE)\n                        .addMethod(PoetCodeUtil.createSetReturn(builderClassName, field, fieldMap.get(field), Modifier.PUBLIC));\n            }\n            MethodSpec.Builder methodSpecB = MethodSpec.methodBuilder(\"create\")\n                    .addModifiers(Modifier.PUBLIC)\n                    .returns(newClassName)\n                    .addStatement(\"$T outClazz = new $T()\", newClassName, newClassName);\n            for (String field : fieldMap.keySet()) {\n                methodSpecB.addStatement(\"outClazz.$L = $L\", field, field);\n            }\n            methodSpecB.addStatement(\"return outClazz\");\n            typeSpecB.addMethod(methodSpecB.build());\n            return typeSpecB.build();\n        }\n    }\n\n    public static class PcsBean {\n        public static FieldSpec createPcsField() {\n            FieldSpec.Builder pcsField = FieldSpec.builder(PropertyChangeSupport.class, \"pcs\")\n                    .addModifiers(Modifier.PRIVATE, Modifier.FINAL)\n                    .initializer(\"new $T(this)\", PropertyChangeSupport.class);\n            return pcsField.build();\n        }\n\n        public static MethodSpec createPcsSet(String fieldName, TypeName fieldType, Modifier... modifiers) {\n            String methodName = \"set\" + upperFirstChar(fieldName);\n            MethodSpec.Builder method = MethodSpec.methodBuilder(methodName)\n                    .addModifiers(modifiers)\n                    .addParameter(fieldType, fieldName)\n                    .addStatement(\"$T old$L = this.$L\",fieldType,fieldName,fieldName)\n                    .addStatement(\"this.$L = $L\", fieldName, fieldName)\n                    .addStatement(\"this.pcs.firePropertyChange($S,old$L,$L)\",fieldName,fieldName,fieldName);\n            return method.build();\n        }\n\n        public static MethodSpec createAddListenerMethod() {\n            MethodSpec.Builder pcsMethod = MethodSpec.methodBuilder(\"addPropertyChangeListener\")\n                    .addModifiers(Modifier.PUBLIC)\n                    .addParameter(PropertyChangeListener.class,\"listener\")\n                    .addStatement(\"this.pcs.addPropertyChangeListener(listener)\");\n            return pcsMethod.build();\n        }\n\n        public static MethodSpec createRemoveListenerMethod() {\n            MethodSpec.Builder pcsMethod = MethodSpec.methodBuilder(\"removePropertyChangeListener\")\n                    .addModifiers(Modifier.PUBLIC)\n                    .addParameter(PropertyChangeListener.class,\"listener\")\n                    .addStatement(\"this.pcs.removePropertyChangeListener(listener)\");\n            return pcsMethod.build();\n        }\n    }\n}", "class_id": 0, "repo": "lofiwang/javapoet-android", "file": "androidpoet-processor/src/main/java/com/lofiwang/androidpoet/PoetCodeUtil.java", "last_update_at": "2020-07-07T03:35:50+00:00", "question_id": "58ad840e21196d577a9e480e753fcfc8ee56aea8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PoetCodeUtil {\n    /**\n     * @param targetClass\n     * @return field and field type\n     */\n    public static HashMap<String, TypeName> createFieldMap(TypeElement targetClass) {\n        HashMap<String, TypeName> fieldMap = new HashMap<>();\n        for (Element encloseElement : targetClass.getEnclosedElements()) {\n            if (encloseElement.getKind() == ElementKind.FIELD) {\n                String fieldName = encloseElement.getSimpleName().toString();\n                TypeName fieldTypeName = TypeName.get(encloseElement.asType());\n                fieldMap.put(fieldName, fieldTypeName);\n            }\n        }\n        return fieldMap;\n    }\n    public static String createNewClazzName(TypeElement targetClass, String suffix) {\n        String originClazzName = targetClass.getSimpleName().toString();\n        return originClazzName + suffix;\n    }\n    public static ClassName createNewClazzType(String pkg, String newClazzName, String... clazzNames) {\n        return ClassName.get(pkg, newClazzName, clazzNames);\n    }\n    public static String getTargetPkgName(TypeElement targetClass, Elements elementUtils) {\n        PackageElement pkg = elementUtils.getPackageOf(targetClass);\n        return pkg.getQualifiedName().toString();\n    }\n    public static MethodSpec createConstructMethod(Modifier... modifiers) {\n        MethodSpec.Builder method = MethodSpec.constructorBuilder()\n                .addModifiers(modifiers);\n        return method.build();\n    }\n    public static MethodSpec createSetReturn(TypeName returnType, String fieldName, TypeName fieldType, Modifier... modifiers) {\n        String methodName = \"set\" + upperFirstChar(fieldName);\n        MethodSpec.Builder method = MethodSpec.methodBuilder(methodName)\n                .addModifiers(modifiers)\n                .returns(returnType)\n                .addParameter(fieldType, fieldName)\n                .addStatement(\"this.$L = $L\", fieldName, fieldName)\n                .addStatement(\"return this\");\n        return method.build();\n    }\n    public static MethodSpec createSet(String fieldName, TypeName fieldType, Modifier... modifiers) {\n        String methodName = \"set\" + upperFirstChar(fieldName);\n        MethodSpec.Builder method = MethodSpec.methodBuilder(methodName)\n                .addModifiers(modifiers)\n                .addParameter(fieldType, fieldName)\n                .addStatement(\"this.$L = $L\", fieldName, fieldName);\n        return method.build();\n    }\n    public static MethodSpec createGet(String fieldName, TypeName fieldType, Modifier... modifiers) {\n        String methodName = \"get\" + upperFirstChar(fieldName);\n        MethodSpec.Builder method = MethodSpec.methodBuilder(methodName)\n                .addModifiers(modifiers)\n                .returns(fieldType)\n                .addStatement(\"return \" + fieldName);\n        return method.build();\n    }\n    public static MethodSpec createToString(String clazzName, HashMap<String, TypeName> fieldMap, Modifier... modifiers) {\n        String methodName = \"toString\";\n        MethodSpec.Builder method = MethodSpec.methodBuilder(methodName)\n                .addModifiers(modifiers)\n                .addAnnotation(Override.class)\n                .returns(String.class);\n        StringBuilder stringBuilder = new StringBuilder();\n        stringBuilder.append(\"\\\"\")\n                .append(clazzName)\n                .append(\"{\\\"\");\n        for (String field : fieldMap.keySet()) {\n            stringBuilder.append(\" + \\\"\").append(field).append(\":\\\" + \").append(field);\n        }\n        stringBuilder.append(\" + \\\"}\\\"\");\n        method.addStatement(\"return \" + stringBuilder.toString());\n        return method.build();\n    }\n    public static String upperFirstChar(String str) {\n        char[] ch = str.toCharArray();\n        if (ch[0] >= 'a' && ch[0] <= 'z') {\n            ch[0] = (char) (ch[0] - 32);\n        }\n        return new String(ch);\n    }\n    public static class Parcelable {\n        public static void createParcelable(TypeName typeName, TypeSpec.Builder typeSpecBuilder, HashMap<String, TypeName> fieldMap) {\n            ClassName parcelableType = ClassName.get(\"android.os\", \"Parcelable\");\n            ClassName parcelType = ClassName.get(\"android.os\", \"Parcel\");\n            ClassName parcelableCreator = ClassName.get(\"android.os\", \"Parcelable\", \"Creator\");\n            TypeName creatorFieldType = ParameterizedTypeName.get(parcelableCreator, typeName);\n            //1. implements Parcelable\n            typeSpecBuilder.addSuperinterface(parcelableType);\n            //2. describeContents\n            MethodSpec.Builder method = MethodSpec.methodBuilder(\"describeContents\")\n                    .addModifiers(Modifier.PUBLIC)\n                    .addAnnotation(Override.class)\n                    .returns(int.class)\n                    .addStatement(\"return 0\");\n            //3. writeToParcel\n            MethodSpec.Builder method1 = MethodSpec.methodBuilder(\"writeToParcel\")\n                    .addModifiers(Modifier.PUBLIC)\n                    .addAnnotation(Override.class)\n                    .addParameter(parcelType, \"dest\")\n                    .addParameter(int.class, \"flags\");\n            for (String field : fieldMap.keySet()) {\n                method1.addStatement(\"dest.writeValue($L)\", \"this.\" + field);\n            }\n            //4. construct(Parcel in)\n            MethodSpec.Builder method2 = MethodSpec.constructorBuilder()\n                    .addModifiers(Modifier.PUBLIC)\n                    .addParameter(parcelType, \"in\")\n                    .addStatement(\"$T classLoader = this.getClass().getClassLoader()\", ClassLoader.class);\n            for (String field : fieldMap.keySet()) {\n                method2.addStatement(\"this.$L = ($T)in.readValue(classLoader)\", field, fieldMap.get(field));\n            }\n            //5. CREATOR\n            ArrayTypeName newTypeArray = ArrayTypeName.of(typeName);\n            TypeSpec parcelableCreatorType = TypeSpec.anonymousClassBuilder(\"\")\n                    .addSuperinterface(creatorFieldType)\n                    .addMethod(MethodSpec.methodBuilder(\"createFromParcel\")\n                            .addAnnotation(Override.class)\n                            .addModifiers(Modifier.PUBLIC)\n                            .addParameter(parcelType, \"source\")\n                            .returns(typeName)\n                            .addStatement(\"return new $T($N)\", typeName, \"source\")\n                            .build())\n                    .addMethod(MethodSpec.methodBuilder(\"newArray\")\n                            .addAnnotation(Override.class)\n                            .addModifiers(Modifier.PUBLIC)\n                            .addParameter(int.class, \"size\")\n                            .returns(newTypeArray)\n                            .addStatement(\"return new $T[$N]\", typeName, \"size\")\n                            .build())\n                    .build();\n            FieldSpec.Builder creatorField = FieldSpec.builder(creatorFieldType, \"CREATOR\")\n                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)\n                    .initializer(\"$L\", parcelableCreatorType);\n            typeSpecBuilder.addMethod(method.build());\n            typeSpecBuilder.addMethod(method1.build());\n            typeSpecBuilder.addMethod(method2.build());\n            typeSpecBuilder.addField(creatorField.build());\n        }\n    }\n    public static class Builder {\n        public static TypeSpec createBuilder(String pkgName, String newClazzName, HashMap<String, TypeName> fieldMap) {\n            ClassName newClassName = PoetCodeUtil.createNewClazzType(pkgName, newClazzName);\n            ClassName builderClassName = PoetCodeUtil.createNewClazzType(pkgName, newClazzName, \"Builder\");\n            TypeSpec.Builder typeSpecB = TypeSpec.classBuilder(\"Builder\")\n                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n            for (String field : fieldMap.keySet()) {\n                typeSpecB.addField(fieldMap.get(field), field, Modifier.PRIVATE)\n                        .addMethod(PoetCodeUtil.createSetReturn(builderClassName, field, fieldMap.get(field), Modifier.PUBLIC));\n            }\n            MethodSpec.Builder methodSpecB = MethodSpec.methodBuilder(\"create\")\n                    .addModifiers(Modifier.PUBLIC)\n                    .returns(newClassName)\n                    .addStatement(\"$T outClazz = new $T()\", newClassName, newClassName);\n            for (String field : fieldMap.keySet()) {\n                methodSpecB.addStatement(\"outClazz.$L = $L\", field, field);\n            }\n            methodSpecB.addStatement(\"return outClazz\");\n            typeSpecB.addMethod(methodSpecB.build());\n            return typeSpecB.build();\n        }\n    }\n    public static class PcsBean {\n        public static FieldSpec createPcsField() {\n            FieldSpec.Builder pcsField = FieldSpec.builder(PropertyChangeSupport.class, \"pcs\")\n                    .addModifiers(Modifier.PRIVATE, Modifier.FINAL)\n                    .initializer(\"new $T(this)\", PropertyChangeSupport.class);\n            return pcsField.build();\n        }\n        public static MethodSpec createPcsSet(String fieldName, TypeName fieldType, Modifier... modifiers) {\n            String methodName = \"set\" + upperFirstChar(fieldName);\n            MethodSpec.Builder method = MethodSpec.methodBuilder(methodName)\n                    .addModifiers(modifiers)\n                    .addParameter(fieldType, fieldName)\n                    .addStatement(\"$T old$L = this.$L\",fieldType,fieldName,fieldName)\n                    .addStatement(\"this.$L = $L\", fieldName, fieldName)\n                    .addStatement(\"this.pcs.firePropertyChange($S,old$L,$L)\",fieldName,fieldName,fieldName);\n            return method.build();\n        }\n        public static MethodSpec createAddListenerMethod() {\n            MethodSpec.Builder pcsMethod = MethodSpec.methodBuilder(\"addPropertyChangeListener\")\n                    .addModifiers(Modifier.PUBLIC)\n                    .addParameter(PropertyChangeListener.class,\"listener\")\n                    .addStatement(\"this.pcs.addPropertyChangeListener(listener)\");\n            return pcsMethod.build();\n        }\n        public static MethodSpec createRemoveListenerMethod() {\n            MethodSpec.Builder pcsMethod = MethodSpec.methodBuilder(\"removePropertyChangeListener\")\n                    .addModifiers(Modifier.PUBLIC)\n                    .addParameter(PropertyChangeListener.class,\"listener\")\n                    .addStatement(\"this.pcs.removePropertyChangeListener(listener)\");\n            return pcsMethod.build();\n        }\n    }\n"]]}
{"hexsha": "62b128546e839afeb4cf035b5ad88b2cbab5fb74", "ext": "java", "lang": "Java", "content": "public class TapcardActivity extends Activity implements SurfaceHolder.Callback {\n  private static final String TAG = TapcardActivity.class.getSimpleName();\n\n  /**\n   * Milliseconds between screen updates. Note that the fastest I've seen GPS\n   * updates arrive is once per second.\n   */\n  private static long UPDATE_RATE = 100;\n  private boolean isRunning;\n  private UpdateHandler updater = new UpdateHandler();\n\n  // Keys used in the bundle passed to this activity.\n  private static final String PACKAGE_NAME = TapcardActivity.class.getPackage().getName();\n  public static final String AIRPORT_ID = PACKAGE_NAME + \"AirportId\";\n\n  // Dimensions of the \"to\" pointer in pixels\n  private static final float POINTER_LENGTH = 17;\n  private static final float POINTER_WIDTH = 12;\n\n  private FlightMap flightMap;\n  private AviationDbAdapter aviationDbAdapter;\n  private LocationHandler locationHandler;\n  private UserPrefs userPrefs;\n\n  // Screen density\n  private float density;\n\n  // Magnetic variation w/ caching.\n  private final CachedMagneticVariation magneticVariation = new CachedMagneticVariation();\n\n  // Last known bearing\n  private float lastBearing;\n\n  // Items for the navigation display.\n  private LatLng airportLatLng;\n  private Path airplanePath = MapView.createAirplanePath();\n  private Path pointerPath = new Path();\n  private SurfaceView miniMap;\n  private SurfaceHolder holder;\n  private TextView distanceText;\n  private TextView bearingText;\n  private TextView eteText;\n  private Paint navigationPaint = new Paint();\n  private float[] distanceBearingResult = new float[2]; \n  \n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    // No title bar. This must be done before setContentView.\n    requestWindowFeature(Window.FEATURE_NO_TITLE);\n    setContentView(R.layout.tapcard);\n\n    flightMap = (FlightMap) getApplication();\n    // Open database connection.\n    userPrefs = new UserPrefs(flightMap);\n    try {\n      aviationDbAdapter = new CachedAviationDbAdapter(new AndroidAviationDbAdapter(userPrefs));\n      aviationDbAdapter.open();\n    } catch (Throwable t) {\n      Log.w(TAG, \"Unable to open database\", t);\n      finish();\n    }\n\n    // Screen density. Scale pixel sizes up based on this.\n    density = getResources().getDisplayMetrics().density;\n\n    // Get location updates\n    locationHandler = flightMap.getLocationHandler();\n\n    // Find which airport to show.\n    final Intent startingIntent = getIntent();\n    int airportId = startingIntent.getIntExtra(AIRPORT_ID, -1);\n    Airport airport = aviationDbAdapter.getAirport(airportId);\n    if (null == airport) {\n      Log.w(TAG, \"Unable to get airport for id \" + airportId);\n      finish();\n    }\n    initializeTapcardUi(airport, getResources());\n  }\n\n  /**\n   * Initializes the tapcard UI. Should only be called once from onCreate().\n   */\n  private void initializeTapcardUi(Airport airport, Resources res) {\n    // ICAO id and airport name.\n    setIcaoAndName(airport, res);\n\n    // Navigation info to airport\n    setNavigationInfo(airport, res);\n\n    // Communication info\n    final List<Comm> comms = aviationDbAdapter.getAirportComms(airport.id);\n    if (comms != null) {\n      final CommDisplayManager commDisplayManager = new CommDisplayManager(comms);\n      addCommInfo(commDisplayManager.getSortedComms(), res);\n    }\n\n    // Runway details\n    addRunways(airport.runways, res);\n\n    // Elevation\n    addElevation(airport);\n  }\n\n  /**\n   * Sets color for ICAO and name item at the top.\n   */\n  private void setIcaoAndName(Airport airport, Resources res) {\n    TableRow nameRow = (TableRow) findViewById(R.id.tapcard_icao_and_name_row);\n    int nameBackground =\n        airport.isTowered ? res.getColor(R.color.ToweredAirport) : res\n            .getColor(R.color.NonToweredAirport);\n    nameRow.setBackgroundColor(nameBackground);\n\n    // ICAO\n    TextView icaoText = (TextView) findViewById(R.id.tapcard_icao);\n    icaoText.setText(airport.icao);\n\n    // Name\n    TextView airportName = (TextView) findViewById(R.id.tapcard_airport_name);\n    airportName.setText(airport.name);\n  }\n\n  /**\n   * Sets up the static parts of the navigation display.\n   */\n  private void setNavigationInfo(Airport airport, Resources res) {\n    airportLatLng = airport.location;\n    navigationPaint.setColor(res.getColor(R.color.AircraftPaint));\n    navigationPaint.setStrokeWidth(1.5f);\n    navigationPaint.setAntiAlias(true);\n\n    // Create path for the pointer.\n    pointerPath.lineTo(POINTER_WIDTH / 2f, 0);\n    pointerPath.lineTo(0, -POINTER_LENGTH);\n    pointerPath.lineTo(-POINTER_WIDTH / 2f, 0);\n    pointerPath.close();\n\n    miniMap = (SurfaceView) findViewById(R.id.tapcard_minimap);\n    holder = miniMap.getHolder();\n    holder.addCallback(this);\n    distanceText = (TextView) findViewById(R.id.tapcard_distance);\n    bearingText = (TextView) findViewById(R.id.tapcard_bearing);\n    eteText = (TextView) findViewById(R.id.tapcard_ete);\n  }\n\n  /**\n   * Adds communication frequencies to the tapcard.\n   */\n  private void addCommInfo(final List<Comm> comms, Resources res) {\n    final TableLayout commTable = (TableLayout) findViewById(R.id.tapcard_comm_table);\n    final LayoutParams rowLayout =\n        new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT);\n    final int mainTextColor = res.getColor(R.color.TapcardForeground);\n    final int annotationTextColor = res.getColor(R.color.TapcardForegroundAnnotation);\n\n    if (comms == null) {\n      TableRow emptyRow = new TableRow(this);\n      emptyRow.setLayoutParams(rowLayout);\n      TextView emptyMsg = new TextView(this);\n      emptyMsg.setText(R.string.no_comm_freqs);\n      emptyMsg.setTypeface(Typeface.SANS_SERIF);\n      emptyMsg.setTextColor(annotationTextColor);\n      emptyMsg.setTextSize(TypedValue.DENSITY_DEFAULT, 15 * density);\n      emptyMsg.setPadding(5, 10, 5, 0);\n      emptyRow.addView(emptyMsg);\n      commTable.addView(emptyRow);\n      return;\n    }\n\n    for (Comm comm : comms) {\n      TableRow commRow = new TableRow(this);\n      commRow.setLayoutParams(rowLayout);\n\n      // Identifier cell\n      TextView ident = new TextView(this);\n      ident.setText(comm.identifier);\n      ident.setTypeface(Typeface.SANS_SERIF);\n      ident.setTextColor(mainTextColor);\n      ident.setTextSize(TypedValue.DENSITY_DEFAULT, 18 * density);\n      ident.setPadding(5, 25, 5, 0);\n      commRow.addView(ident);\n\n      // Frequency cell\n      TextView frequency = new TextView(this);\n      frequency.setText(comm.frequency);\n      frequency.setTypeface(Typeface.SANS_SERIF, Typeface.BOLD);\n      frequency.setTextColor(mainTextColor);\n      frequency.setTextSize(TypedValue.DENSITY_DEFAULT, 22 * density);\n      frequency.setPadding(10, 0, 5, 0);\n      commRow.addView(frequency);\n\n      commTable.addView(commRow);\n\n\n      if (comm.remarks != null && comm.remarks.length() > 0) {\n        commRow = new TableRow(this);\n        commRow.setLayoutParams(rowLayout);\n        TextView remarks = new TextView(this);\n        remarks.setText(comm.remarks);\n        remarks.setTypeface(Typeface.SANS_SERIF);\n        remarks.setTextColor(annotationTextColor);\n        remarks.setTextSize(TypedValue.DENSITY_DEFAULT, 15 * density);\n        remarks.setPadding(5, 0, 0, 0);\n\n        commRow.addView(remarks);\n        commTable.addView(commRow);\n      }\n    }\n  }\n\n  /**\n   * Adds runway details to the tapcard.\n   * \n   * @param res\n   */\n  private void addRunways(SortedSet<Runway> runways, Resources res) {\n    final LinearLayout runwayLayout = (LinearLayout) findViewById(R.id.tapcard_runway_layout);\n    final int textColor = res.getColor(R.color.TapcardForeground);\n    final int textAnnotationColor = res.getColor(R.color.TapcardForegroundAnnotation);\n\n    // Paint a horizontal rule to separate runway section from comms\n    // TODO shobe to add drawable or whatever\n\n    for (Runway runway : runways) {\n      TextView letters = new TextView(this);\n      letters.setText(runway.letters);\n      letters.setTypeface(Typeface.SANS_SERIF, Typeface.BOLD);\n      letters.setTextColor(textColor);\n      letters.setTextSize(TypedValue.DENSITY_DEFAULT, 22 * density);\n      letters.setPadding(5, 5, 5, 0);\n      runwayLayout.addView(letters);\n\n      TextView size = new TextView(this);\n      size.setText(runway.length + \"x\" + runway.width + \" \" + runway.surface);\n      size.setTypeface(Typeface.SANS_SERIF);\n      size.setTextColor(textAnnotationColor);\n      size.setTextSize(TypedValue.DENSITY_DEFAULT, 15 * density);\n      size.setPadding(5, 0, 5, 10);\n      runwayLayout.addView(size);\n    }\n  }\n\n  /**\n   * Adds airport elevation to the tapcard\n   */\n  private void addElevation(Airport airport) {\n    final Map<String, String> airportProperties =\n        aviationDbAdapter.getAirportProperties(airport.id);\n    if (airportProperties == null) {\n      return;\n    }\n    String elevation = airportProperties.get(\"Elevation\");\n    if (elevation == null) {\n      return;\n    }\n    TextView elevationText = (TextView) findViewById(R.id.tapcard_elevation);\n    elevationText.setText(\"ELEV \" + elevation + \"' MSL\");\n    elevationText.setPadding(10, 0, 0, 0);\n  }\n\n  @Override\n  protected void onResume() {\n    super.onResume();\n    locationHandler.startListening();\n    setRunning(true);\n    update();\n  }\n\n  @Override\n  protected void onPause() {\n    super.onPause();\n    setRunning(false);\n    locationHandler.stopListening();\n  }\n\n  @Override\n  protected void onDestroy() {\n    super.onDestroy();\n    if (aviationDbAdapter != null) {\n      aviationDbAdapter.close();\n    }\n  }\n\n  /**\n   * Surface dimensions changed.\n   */\n  @Override\n  public synchronized void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {\n  }\n\n  @Override\n  public synchronized void surfaceCreated(SurfaceHolder holder) {\n    this.holder = holder;\n  }\n\n  @Override\n  public void surfaceDestroyed(SurfaceHolder holder) {\n    this.holder = null;\n  }\n\n  /**\n   * Updates the view every {@link #UPDATE_RATE} milliseconds using\n   * {@link UpdateHandler}.\n   */\n  private void update() {\n    updater.scheduleUpdate(UPDATE_RATE);\n    if (!isRunning()) {\n      return;\n    }\n    updateNavigationDisplay();\n  }\n\n  /**\n   * Updates the pointer, distance, bearing and ETE to the selected airport.\n   * This is called repeatedly by {@link #update()}.\n   */\n  private void updateNavigationDisplay() {\n    final Location location = locationHandler.getLocation();\n    float magneticConversion = 0;\n    if (location != null) {\n      final LatLng locationLatLng =\n          LatLng.fromDouble(location.getLatitude(), location.getLongitude());\n      magneticConversion =\n          magneticVariation.getMagneticVariation(locationLatLng, (float) location.getAltitude());\n    }\n\n    setDistanceBearingResult(location);\n    updateNavigationMiniMap(location, locationHandler.isLocationCurrent()\n        && locationHandler.isLocationAccurate());\n    updateNavigationTextItems(location, magneticConversion);\n  }\n\n  /**\n   * Stores the distance and bearing from {@code location} to {@code\n   * airportLatLng} in distanceBearingResult[]. Index 0 will be the distance in\n   * meters, index 1 will be the bearing in true degrees.\n   */\n  private synchronized void setDistanceBearingResult(Location location) {\n    // Calculate distance and bearing to airport.\n    final double locationLat = location.getLatitude();\n    final double locationLng = location.getLongitude();\n    // results[0]===distance, results[1]==bearing\n    Location.distanceBetween(locationLat, locationLng, airportLatLng.latDeg(), airportLatLng\n        .lngDeg(), distanceBearingResult);\n  }\n\n  /**\n   * Updates the mini map pointing to the airport.\n   */\n  private synchronized void updateNavigationMiniMap(Location location, boolean isCurrentLocation) {\n    Canvas c = null;\n    try {\n      if (null == holder) {\n        return;\n      }\n      c = holder.lockCanvas();\n      synchronized (holder) {\n        if (c != null) {\n          c.drawColor(Color.BLACK);\n          if (location == null) {\n            return;\n          }\n\n          // Update bearing (if possible)\n          if (location.hasBearing()) {\n            lastBearing = location.getBearing();\n          }\n\n          // Center everythng on the canvas.\n          c.translate(c.getWidth() / 2, c.getHeight() / 2);\n          // Scale the image down based on the size of the canvas.\n          final int width = c.getWidth();\n          final float imageScale = width / 150f;\n          c.save();\n          c.scale(imageScale, imageScale);\n\n          // Rotate the airplane, then draw it.\n          // For north-up, rotate the airplane to its current track.\n          // Do nothing for track-up (the airplane pointing up is right).\n          if (userPrefs.isNorthUp()) {\n            c.rotate(lastBearing);\n          }\n          navigationPaint.setStyle(Paint.Style.FILL);\n          c.scale(density, density);\n          if (isCurrentLocation) {\n            c.drawPath(airplanePath, MapView.AIRPLANE_SOLID_PAINT);\n          } else {\n            c.drawPath(airplanePath, MapView.AIRPLANE_OUTLINE_STROKE_PAINT);\n          }\n\n          // Undo the downscaling and rotation for the airplane.\n          c.restore();\n          \n          // If the location isn't current, the draw a red slash\n          if (!isCurrentLocation) {\n            float slashLength = POINTER_LENGTH * density;\n            c.drawLine(-slashLength, -slashLength, slashLength, slashLength, MapView.RED_SLASH_PAINT);\n            return;\n          }\n\n          // Draw a circle around the airplane.\n          navigationPaint.setStyle(Paint.Style.STROKE);\n          float radius = (width / 2f) - POINTER_LENGTH;\n          c.drawCircle(0, 0, radius, navigationPaint);\n\n          // Calculate pointer direction. If in north-up mode, the it's just\n          // bearingTo, otherwise it's the relative bearing to.\n          float bearingTo = distanceBearingResult[1];\n          if (!userPrefs.isNorthUp()) {\n            bearingTo = (float) NavigationUtil.normalizeBearing(bearingTo - lastBearing);\n          }\n\n          // Rotate the pointer and draw it.\n          c.rotate(bearingTo);\n          c.translate(0, -radius);\n          navigationPaint.setStyle(Paint.Style.FILL);\n          c.drawPath(pointerPath, navigationPaint);\n        }\n      }\n    } finally {\n      if (c != null) {\n        holder.unlockCanvasAndPost(c);\n      }\n    }\n  }\n\n  /**\n   * Updates the distance, bearing and ete text items.\n   */\n  private synchronized void updateNavigationTextItems(final Location location,\n      float magneticConversion) {\n    if (null == location) {\n      distanceText.setText(\"Location unavailable\");\n      bearingText.setText(\"\");\n      eteText.setText(\"\");\n      return;\n    }\n\n    final float distanceMeters = distanceBearingResult[0];\n    final float bearingTo =\n        (float) NavigationUtil.normalizeBearing(distanceBearingResult[1] + magneticConversion);\n\n    DistanceUnits distanceUnits = userPrefs.getDistanceUnits();\n    String distance =\n        String.format(\"      %.1f%s\", distanceUnits.getDistance(distanceMeters),\n            distanceUnits.distanceAbbreviation);\n    distanceText.setText(distance);\n    bearingText.setText(String.format(\" %03.0f%s\", bearingTo, MapView.DEGREES_SYMBOL));\n\n    final DistanceUnits nauticalUnits = DistanceUnits.NAUTICAL_MILES;\n    final double speedInKnots = nauticalUnits.getSpeed(location.getSpeed());\n    if (speedInKnots > 3) {\n      final float metersPerSecond = location.getSpeed();\n      float timeInSeconds = distanceMeters / metersPerSecond;\n      int hours = (int) (timeInSeconds / 60 / 60);\n      int minutes = (int) (timeInSeconds / 60) - (hours * 60);\n      int seconds = (int) (timeInSeconds - (hours * 60 * 60) - (minutes * 60));\n\n      // Normally hours will be 0, so omit if possible.\n      if (hours == 0) {\n        eteText.setText(String.format(\" %d:%02d\", minutes, seconds));\n      } else {\n        eteText.setText(String.format(\" %d:%02d:%02d\", hours, minutes, seconds));\n      }\n    } else {\n      eteText.setText(\"\");\n    }\n  }\n\n  /**\n   * Updates the UI using a delayed message.\n   */\n  private class UpdateHandler extends Handler {\n    private static final int UPDATE_MESSAGE = 1;\n\n    @Override\n    public void handleMessage(Message msg) {\n      update();\n    }\n\n    /**\n     * Call {@link #update} after {@code delay} milliseconds.\n     */\n    public void scheduleUpdate(long delay) {\n      removeMessages(UPDATE_MESSAGE);\n      sendMessageDelayed(obtainMessage(UPDATE_MESSAGE), delay);\n    }\n  }\n\n  private synchronized boolean isRunning() {\n    return isRunning;\n  }\n\n  private synchronized void setRunning(boolean isRunning) {\n    this.isRunning = isRunning;\n  }\n}", "class_id": 0, "repo": "mattshobe/flightmap", "file": "android/src/com/google/flightmap/android/TapcardActivity.java", "last_update_at": "2020-06-03T00:43:37+00:00", "question_id": "62b128546e839afeb4cf035b5ad88b2cbab5fb74", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TapcardActivity extends Activity implements SurfaceHolder.Callback {\n  private static final String TAG = TapcardActivity.class.getSimpleName();\n  /**\n   * Milliseconds between screen updates. Note that the fastest I've seen GPS\n   * updates arrive is once per second.\n   */\n  private static long UPDATE_RATE = 100;\n  private boolean isRunning;\n  private UpdateHandler updater = new UpdateHandler();\n  // Keys used in the bundle passed to this activity.\n  private static final String PACKAGE_NAME = TapcardActivity.class.getPackage().getName();\n  public static final String AIRPORT_ID = PACKAGE_NAME + \"AirportId\";\n  // Dimensions of the \"to\" pointer in pixels\n  private static final float POINTER_LENGTH = 17;\n  private static final float POINTER_WIDTH = 12;\n  private FlightMap flightMap;\n  private AviationDbAdapter aviationDbAdapter;\n  private LocationHandler locationHandler;\n  private UserPrefs userPrefs;\n  // Screen density\n  private float density;\n  // Magnetic variation w/ caching.\n  private final CachedMagneticVariation magneticVariation = new CachedMagneticVariation();\n  // Last known bearing\n  private float lastBearing;\n  // Items for the navigation display.\n  private LatLng airportLatLng;\n  private Path airplanePath = MapView.createAirplanePath();\n  private Path pointerPath = new Path();\n  private SurfaceView miniMap;\n  private SurfaceHolder holder;\n  private TextView distanceText;\n  private TextView bearingText;\n  private TextView eteText;\n  private Paint navigationPaint = new Paint();\n  private float[] distanceBearingResult = new float[2]; \n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    // No title bar. This must be done before setContentView.\n    requestWindowFeature(Window.FEATURE_NO_TITLE);\n    setContentView(R.layout.tapcard);\n    flightMap = (FlightMap) getApplication();\n    // Open database connection.\n    userPrefs = new UserPrefs(flightMap);\n    try {\n      aviationDbAdapter = new CachedAviationDbAdapter(new AndroidAviationDbAdapter(userPrefs));\n      aviationDbAdapter.open();\n    } catch (Throwable t) {\n      Log.w(TAG, \"Unable to open database\", t);\n      finish();\n    }\n    // Screen density. Scale pixel sizes up based on this.\n    density = getResources().getDisplayMetrics().density;\n    // Get location updates\n    locationHandler = flightMap.getLocationHandler();\n    // Find which airport to show.\n    final Intent startingIntent = getIntent();\n    int airportId = startingIntent.getIntExtra(AIRPORT_ID, -1);\n    Airport airport = aviationDbAdapter.getAirport(airportId);\n    if (null == airport) {\n      Log.w(TAG, \"Unable to get airport for id \" + airportId);\n      finish();\n    }\n    initializeTapcardUi(airport, getResources());\n  }\n  /**\n   * Initializes the tapcard UI. Should only be called once from onCreate().\n   */\n  private void initializeTapcardUi(Airport airport, Resources res) {\n    // ICAO id and airport name.\n    setIcaoAndName(airport, res);\n    // Navigation info to airport\n    setNavigationInfo(airport, res);\n    // Communication info\n    final List<Comm> comms = aviationDbAdapter.getAirportComms(airport.id);\n    if (comms != null) {\n      final CommDisplayManager commDisplayManager = new CommDisplayManager(comms);\n      addCommInfo(commDisplayManager.getSortedComms(), res);\n    }\n    // Runway details\n    addRunways(airport.runways, res);\n    // Elevation\n    addElevation(airport);\n  }\n  /**\n   * Sets color for ICAO and name item at the top.\n   */\n  private void setIcaoAndName(Airport airport, Resources res) {\n    TableRow nameRow = (TableRow) findViewById(R.id.tapcard_icao_and_name_row);\n    int nameBackground =\n        airport.isTowered ? res.getColor(R.color.ToweredAirport) : res\n            .getColor(R.color.NonToweredAirport);\n    nameRow.setBackgroundColor(nameBackground);\n    // ICAO\n    TextView icaoText = (TextView) findViewById(R.id.tapcard_icao);\n    icaoText.setText(airport.icao);\n    // Name\n    TextView airportName = (TextView) findViewById(R.id.tapcard_airport_name);\n    airportName.setText(airport.name);\n  }\n  /**\n   * Sets up the static parts of the navigation display.\n   */\n  private void setNavigationInfo(Airport airport, Resources res) {\n    airportLatLng = airport.location;\n    navigationPaint.setColor(res.getColor(R.color.AircraftPaint));\n    navigationPaint.setStrokeWidth(1.5f);\n    navigationPaint.setAntiAlias(true);\n    // Create path for the pointer.\n    pointerPath.lineTo(POINTER_WIDTH / 2f, 0);\n    pointerPath.lineTo(0, -POINTER_LENGTH);\n    pointerPath.lineTo(-POINTER_WIDTH / 2f, 0);\n    pointerPath.close();\n    miniMap = (SurfaceView) findViewById(R.id.tapcard_minimap);\n    holder = miniMap.getHolder();\n    holder.addCallback(this);\n    distanceText = (TextView) findViewById(R.id.tapcard_distance);\n    bearingText = (TextView) findViewById(R.id.tapcard_bearing);\n    eteText = (TextView) findViewById(R.id.tapcard_ete);\n  }\n  /**\n   * Adds communication frequencies to the tapcard.\n   */\n  private void addCommInfo(final List<Comm> comms, Resources res) {\n    final TableLayout commTable = (TableLayout) findViewById(R.id.tapcard_comm_table);\n    final LayoutParams rowLayout =\n        new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT);\n    final int mainTextColor = res.getColor(R.color.TapcardForeground);\n    final int annotationTextColor = res.getColor(R.color.TapcardForegroundAnnotation);\n    if (comms == null) {\n      TableRow emptyRow = new TableRow(this);\n      emptyRow.setLayoutParams(rowLayout);\n      TextView emptyMsg = new TextView(this);\n      emptyMsg.setText(R.string.no_comm_freqs);\n      emptyMsg.setTypeface(Typeface.SANS_SERIF);\n      emptyMsg.setTextColor(annotationTextColor);\n      emptyMsg.setTextSize(TypedValue.DENSITY_DEFAULT, 15 * density);\n      emptyMsg.setPadding(5, 10, 5, 0);\n      emptyRow.addView(emptyMsg);\n      commTable.addView(emptyRow);\n      return;\n    }\n    for (Comm comm : comms) {\n      TableRow commRow = new TableRow(this);\n      commRow.setLayoutParams(rowLayout);\n      // Identifier cell\n      TextView ident = new TextView(this);\n      ident.setText(comm.identifier);\n      ident.setTypeface(Typeface.SANS_SERIF);\n      ident.setTextColor(mainTextColor);\n      ident.setTextSize(TypedValue.DENSITY_DEFAULT, 18 * density);\n      ident.setPadding(5, 25, 5, 0);\n      commRow.addView(ident);\n      // Frequency cell\n      TextView frequency = new TextView(this);\n      frequency.setText(comm.frequency);\n      frequency.setTypeface(Typeface.SANS_SERIF, Typeface.BOLD);\n      frequency.setTextColor(mainTextColor);\n      frequency.setTextSize(TypedValue.DENSITY_DEFAULT, 22 * density);\n      frequency.setPadding(10, 0, 5, 0);\n      commRow.addView(frequency);\n      commTable.addView(commRow);\n      if (comm.remarks != null && comm.remarks.length() > 0) {\n        commRow = new TableRow(this);\n        commRow.setLayoutParams(rowLayout);\n        TextView remarks = new TextView(this);\n        remarks.setText(comm.remarks);\n        remarks.setTypeface(Typeface.SANS_SERIF);\n        remarks.setTextColor(annotationTextColor);\n        remarks.setTextSize(TypedValue.DENSITY_DEFAULT, 15 * density);\n        remarks.setPadding(5, 0, 0, 0);\n        commRow.addView(remarks);\n        commTable.addView(commRow);\n      }\n    }\n  }\n  /**\n   * Adds runway details to the tapcard.\n   * \n   * @param res\n   */\n  private void addRunways(SortedSet<Runway> runways, Resources res) {\n    final LinearLayout runwayLayout = (LinearLayout) findViewById(R.id.tapcard_runway_layout);\n    final int textColor = res.getColor(R.color.TapcardForeground);\n    final int textAnnotationColor = res.getColor(R.color.TapcardForegroundAnnotation);\n    // Paint a horizontal rule to separate runway section from comms\n    // TODO shobe to add drawable or whatever\n    for (Runway runway : runways) {\n      TextView letters = new TextView(this);\n      letters.setText(runway.letters);\n      letters.setTypeface(Typeface.SANS_SERIF, Typeface.BOLD);\n      letters.setTextColor(textColor);\n      letters.setTextSize(TypedValue.DENSITY_DEFAULT, 22 * density);\n      letters.setPadding(5, 5, 5, 0);\n      runwayLayout.addView(letters);\n      TextView size = new TextView(this);\n      size.setText(runway.length + \"x\" + runway.width + \" \" + runway.surface);\n      size.setTypeface(Typeface.SANS_SERIF);\n      size.setTextColor(textAnnotationColor);\n      size.setTextSize(TypedValue.DENSITY_DEFAULT, 15 * density);\n      size.setPadding(5, 0, 5, 10);\n      runwayLayout.addView(size);\n    }\n  }\n  /**\n   * Adds airport elevation to the tapcard\n   */\n  private void addElevation(Airport airport) {\n    final Map<String, String> airportProperties =\n        aviationDbAdapter.getAirportProperties(airport.id);\n    if (airportProperties == null) {\n      return;\n    }\n    String elevation = airportProperties.get(\"Elevation\");\n    if (elevation == null) {\n      return;\n    }\n    TextView elevationText = (TextView) findViewById(R.id.tapcard_elevation);\n    elevationText.setText(\"ELEV \" + elevation + \"' MSL\");\n    elevationText.setPadding(10, 0, 0, 0);\n  }\n  @Override\n  protected void onResume() {\n    super.onResume();\n    locationHandler.startListening();\n    setRunning(true);\n    update();\n  }\n  @Override\n  protected void onPause() {\n    super.onPause();\n    setRunning(false);\n    locationHandler.stopListening();\n  }\n  @Override\n  protected void onDestroy() {\n    super.onDestroy();\n    if (aviationDbAdapter != null) {\n      aviationDbAdapter.close();\n    }\n  }\n  /**\n   * Surface dimensions changed.\n   */\n  @Override\n  public synchronized void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {\n  }\n  @Override\n  public synchronized void surfaceCreated(SurfaceHolder holder) {\n    this.holder = holder;\n  }\n  @Override\n  public void surfaceDestroyed(SurfaceHolder holder) {\n    this.holder = null;\n  }\n  /**\n   * Updates the view every {@link #UPDATE_RATE} milliseconds using\n   * {@link UpdateHandler}.\n   */\n  private void update() {\n    updater.scheduleUpdate(UPDATE_RATE);\n    if (!isRunning()) {\n      return;\n    }\n    updateNavigationDisplay();\n  }\n  /**\n   * Updates the pointer, distance, bearing and ETE to the selected airport.\n   * This is called repeatedly by {@link #update()}.\n   */\n  private void updateNavigationDisplay() {\n    final Location location = locationHandler.getLocation();\n    float magneticConversion = 0;\n    if (location != null) {\n      final LatLng locationLatLng =\n          LatLng.fromDouble(location.getLatitude(), location.getLongitude());\n      magneticConversion =\n          magneticVariation.getMagneticVariation(locationLatLng, (float) location.getAltitude());\n    }\n    setDistanceBearingResult(location);\n    updateNavigationMiniMap(location, locationHandler.isLocationCurrent()\n        && locationHandler.isLocationAccurate());\n    updateNavigationTextItems(location, magneticConversion);\n  }\n  /**\n   * Stores the distance and bearing from {@code location} to {@code\n   * airportLatLng} in distanceBearingResult[]. Index 0 will be the distance in\n   * meters, index 1 will be the bearing in true degrees.\n   */\n  private synchronized void setDistanceBearingResult(Location location) {\n    // Calculate distance and bearing to airport.\n    final double locationLat = location.getLatitude();\n    final double locationLng = location.getLongitude();\n    // results[0]===distance, results[1]==bearing\n    Location.distanceBetween(locationLat, locationLng, airportLatLng.latDeg(), airportLatLng\n        .lngDeg(), distanceBearingResult);\n  }\n  /**\n   * Updates the mini map pointing to the airport.\n   */\n  private synchronized void updateNavigationMiniMap(Location location, boolean isCurrentLocation) {\n    Canvas c = null;\n    try {\n      if (null == holder) {\n        return;\n      }\n      c = holder.lockCanvas();\n      synchronized (holder) {\n        if (c != null) {\n          c.drawColor(Color.BLACK);\n          if (location == null) {\n            return;\n          }\n          // Update bearing (if possible)\n          if (location.hasBearing()) {\n            lastBearing = location.getBearing();\n          }\n          // Center everythng on the canvas.\n          c.translate(c.getWidth() / 2, c.getHeight() / 2);\n          // Scale the image down based on the size of the canvas.\n          final int width = c.getWidth();\n          final float imageScale = width / 150f;\n          c.save();\n          c.scale(imageScale, imageScale);\n          // Rotate the airplane, then draw it.\n          // For north-up, rotate the airplane to its current track.\n          // Do nothing for track-up (the airplane pointing up is right).\n          if (userPrefs.isNorthUp()) {\n            c.rotate(lastBearing);\n          }\n          navigationPaint.setStyle(Paint.Style.FILL);\n          c.scale(density, density);\n          if (isCurrentLocation) {\n            c.drawPath(airplanePath, MapView.AIRPLANE_SOLID_PAINT);\n          } else {\n            c.drawPath(airplanePath, MapView.AIRPLANE_OUTLINE_STROKE_PAINT);\n          }\n          // Undo the downscaling and rotation for the airplane.\n          c.restore();\n          // If the location isn't current, the draw a red slash\n          if (!isCurrentLocation) {\n            float slashLength = POINTER_LENGTH * density;\n            c.drawLine(-slashLength, -slashLength, slashLength, slashLength, MapView.RED_SLASH_PAINT);\n            return;\n          }\n          // Draw a circle around the airplane.\n          navigationPaint.setStyle(Paint.Style.STROKE);\n          float radius = (width / 2f) - POINTER_LENGTH;\n          c.drawCircle(0, 0, radius, navigationPaint);\n          // Calculate pointer direction. If in north-up mode, the it's just\n          // bearingTo, otherwise it's the relative bearing to.\n          float bearingTo = distanceBearingResult[1];\n          if (!userPrefs.isNorthUp()) {\n            bearingTo = (float) NavigationUtil.normalizeBearing(bearingTo - lastBearing);\n          }\n          // Rotate the pointer and draw it.\n          c.rotate(bearingTo);\n          c.translate(0, -radius);\n          navigationPaint.setStyle(Paint.Style.FILL);\n          c.drawPath(pointerPath, navigationPaint);\n        }\n      }\n    } finally {\n      if (c != null) {\n        holder.unlockCanvasAndPost(c);\n      }\n    }\n  }\n  /**\n   * Updates the distance, bearing and ete text items.\n   */\n  private synchronized void updateNavigationTextItems(final Location location,\n      float magneticConversion) {\n    if (null == location) {\n      distanceText.setText(\"Location unavailable\");\n      bearingText.setText(\"\");\n      eteText.setText(\"\");\n      return;\n    }\n    final float distanceMeters = distanceBearingResult[0];\n    final float bearingTo =\n        (float) NavigationUtil.normalizeBearing(distanceBearingResult[1] + magneticConversion);\n    DistanceUnits distanceUnits = userPrefs.getDistanceUnits();\n    String distance =\n        String.format(\"      %.1f%s\", distanceUnits.getDistance(distanceMeters),\n            distanceUnits.distanceAbbreviation);\n    distanceText.setText(distance);\n    bearingText.setText(String.format(\" %03.0f%s\", bearingTo, MapView.DEGREES_SYMBOL));\n    final DistanceUnits nauticalUnits = DistanceUnits.NAUTICAL_MILES;\n    final double speedInKnots = nauticalUnits.getSpeed(location.getSpeed());\n    if (speedInKnots > 3) {\n      final float metersPerSecond = location.getSpeed();\n      float timeInSeconds = distanceMeters / metersPerSecond;\n      int hours = (int) (timeInSeconds / 60 / 60);\n      int minutes = (int) (timeInSeconds / 60) - (hours * 60);\n      int seconds = (int) (timeInSeconds - (hours * 60 * 60) - (minutes * 60));\n      // Normally hours will be 0, so omit if possible.\n      if (hours == 0) {\n        eteText.setText(String.format(\" %d:%02d\", minutes, seconds));\n      } else {\n        eteText.setText(String.format(\" %d:%02d:%02d\", hours, minutes, seconds));\n      }\n    } else {\n      eteText.setText(\"\");\n    }\n  }\n  /**\n   * Updates the UI using a delayed message.\n   */\n  private class UpdateHandler extends Handler {\n    private static final int UPDATE_MESSAGE = 1;\n    @Override\n    public void handleMessage(Message msg) {\n      update();\n    }\n    /**\n     * Call {@link #update} after {@code delay} milliseconds.\n     */\n    public void scheduleUpdate(long delay) {\n      removeMessages(UPDATE_MESSAGE);\n      sendMessageDelayed(obtainMessage(UPDATE_MESSAGE), delay);\n    }\n  }\n  private synchronized boolean isRunning() {\n    return isRunning;\n  }\n  private synchronized void setRunning(boolean isRunning) {\n    this.isRunning = isRunning;\n  }\n"]]}
{"hexsha": "ac97ae51da3e689cc2fdfc28f7a78855ba03f940", "ext": "java", "lang": "Java", "content": "public class EditorSpriterInflater extends InflaterSystem {\n\tprivate SpriterCacheModule cache;\n\tprivate AssetsLoadingMonitorModule loadingMonitor;\n\n\tprivate ComponentMapper<ProtoVisSpriter> protoCm;\n\tprivate ComponentMapper<SpriterProperties> propertiesCm;\n\tprivate ComponentMapper<AssetReference> assetCm;\n\n\tpublic EditorSpriterInflater () {\n\t\tsuper(Aspect.all(ProtoVisSpriter.class, AssetReference.class));\n\t}\n\n\t@Override\n\tpublic void inserted (int entityId) {\n\t\tAssetReference assetRef = assetCm.get(entityId);\n\t\tProtoVisSpriter protoComponent = protoCm.get(entityId);\n\t\tSpriterProperties propsComponent = propertiesCm.get(entityId);\n\n\t\tSpriterAsset asset = (SpriterAsset) assetRef.asset;\n\n\t\ttry {\n\t\t\tVisSpriter component = cache.createComponent(asset, protoComponent.scale);\n\n\t\t\tprotoComponent.fill(component);\n\t\t\tworld.getEntity(entityId).edit().add(component);\n\n\t\t\tif (propsComponent.previewInEditor == false) component.setAnimationPlaying(false);\n\t\t} catch (GdxRuntimeException e) {\n\t\t\tLog.exception(e);\n//\t\t\tworld.getEntity(entityId).edit().add(new VisSpriter(null, null, 1));\n\t\t\tloadingMonitor.addFailedResource(assetRef.asset, e);\n\t\t}\n\n\t\tprotoCm.remove(entityId);\n\t}\n}", "class_id": 0, "repo": "Blunderchips/vis-editor", "file": "plugins/vis-editor-spriter/src/main/java/com/kotcrab/vis/plugin/spriter/system/EditorSpriterInflater.java", "last_update_at": "2020-12-19T05:15:05+00:00", "question_id": "ac97ae51da3e689cc2fdfc28f7a78855ba03f940", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EditorSpriterInflater extends InflaterSystem {\n\tprivate SpriterCacheModule cache;\n\tprivate AssetsLoadingMonitorModule loadingMonitor;\n\tprivate ComponentMapper<ProtoVisSpriter> protoCm;\n\tprivate ComponentMapper<SpriterProperties> propertiesCm;\n\tprivate ComponentMapper<AssetReference> assetCm;\n\tpublic EditorSpriterInflater () {\n\t\tsuper(Aspect.all(ProtoVisSpriter.class, AssetReference.class));\n\t}\n\t@Override\n\tpublic void inserted (int entityId) {\n\t\tAssetReference assetRef = assetCm.get(entityId);\n\t\tProtoVisSpriter protoComponent = protoCm.get(entityId);\n\t\tSpriterProperties propsComponent = propertiesCm.get(entityId);\n\t\tSpriterAsset asset = (SpriterAsset) assetRef.asset;\n\t\ttry {\n\t\t\tVisSpriter component = cache.createComponent(asset, protoComponent.scale);\n\t\t\tprotoComponent.fill(component);\n\t\t\tworld.getEntity(entityId).edit().add(component);\n\t\t\tif (propsComponent.previewInEditor == false) component.setAnimationPlaying(false);\n\t\t} catch (GdxRuntimeException e) {\n\t\t\tLog.exception(e);\n//\t\t\tworld.getEntity(entityId).edit().add(new VisSpriter(null, null, 1));\n\t\t\tloadingMonitor.addFailedResource(assetRef.asset, e);\n\t\t}\n\t\tprotoCm.remove(entityId);\n\t}\n"]]}
{"hexsha": "82bec5a1f0dc3e2a23dce5c3e4d2867ee3bec7eb", "ext": "java", "lang": "Java", "content": "@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST, numDataNodes = 0)\npublic class CloneSnapshotIT extends AbstractSnapshotIntegTestCase {\n\n    public void testShardClone() throws Exception {\n        internalCluster().startMasterOnlyNode();\n        internalCluster().startDataOnlyNode();\n        final String repoName = \"repo-name\";\n        final Path repoPath = randomRepoPath();\n        createRepository(repoName, \"fs\", repoPath);\n\n        final boolean useBwCFormat = randomBoolean();\n        if (useBwCFormat) {\n            initWithSnapshotVersion(repoName, repoPath, SnapshotsService.OLD_SNAPSHOT_FORMAT);\n            // Re-create repo to clear repository data cache\n            assertAcked(client().admin().cluster().prepareDeleteRepository(repoName).get());\n            createRepository(repoName, \"fs\", repoPath);\n        }\n\n        final String indexName = \"test-index\";\n        createIndexWithRandomDocs(indexName, randomIntBetween(5, 10));\n        final String sourceSnapshot = \"source-snapshot\";\n        final SnapshotInfo sourceSnapshotInfo = createFullSnapshot(repoName, sourceSnapshot);\n\n        final BlobStoreRepository repository =\n                (BlobStoreRepository) internalCluster().getCurrentMasterNodeInstance(RepositoriesService.class).repository(repoName);\n        final RepositoryData repositoryData = getRepositoryData(repoName);\n        final IndexId indexId = repositoryData.resolveIndexId(indexName);\n        final int shardId = 0;\n        final RepositoryShardId repositoryShardId = new RepositoryShardId(indexId, shardId);\n\n        final SnapshotId targetSnapshotId = new SnapshotId(\"target-snapshot\", UUIDs.randomBase64UUID(random()));\n\n        final String currentShardGen;\n        if (useBwCFormat) {\n            currentShardGen = null;\n        } else {\n            currentShardGen = repositoryData.shardGenerations().getShardGen(indexId, shardId);\n        }\n        final String newShardGeneration = PlainActionFuture.get(f -> repository.cloneShardSnapshot(\n                sourceSnapshotInfo.snapshotId(), targetSnapshotId, repositoryShardId, currentShardGen, f));\n\n        if (useBwCFormat) {\n            final long gen = Long.parseLong(newShardGeneration);\n            assertEquals(gen, 1L); // Initial snapshot brought it to 0, clone increments it to 1\n        }\n\n        final BlobStoreIndexShardSnapshot targetShardSnapshot = readShardSnapshot(repository, repositoryShardId, targetSnapshotId);\n        final BlobStoreIndexShardSnapshot sourceShardSnapshot =\n                readShardSnapshot(repository, repositoryShardId, sourceSnapshotInfo.snapshotId());\n        assertThat(targetShardSnapshot.incrementalFileCount(), is(0));\n        final List<BlobStoreIndexShardSnapshot.FileInfo> sourceFiles = sourceShardSnapshot.indexFiles();\n        final List<BlobStoreIndexShardSnapshot.FileInfo> targetFiles = targetShardSnapshot.indexFiles();\n        final int fileCount = sourceFiles.size();\n        assertEquals(fileCount, targetFiles.size());\n        for (int i = 0; i < fileCount; i++) {\n            assertTrue(sourceFiles.get(i).isSame(targetFiles.get(i)));\n        }\n        final BlobStoreIndexShardSnapshots shardMetadata = readShardGeneration(repository, repositoryShardId, newShardGeneration);\n        final List<SnapshotFiles> snapshotFiles = shardMetadata.snapshots();\n        assertThat(snapshotFiles, hasSize(2));\n        assertTrue(snapshotFiles.get(0).isSame(snapshotFiles.get(1)));\n\n        // verify that repeated cloning is idempotent\n        final String newShardGeneration2 = PlainActionFuture.get(f -> repository.cloneShardSnapshot(\n                sourceSnapshotInfo.snapshotId(), targetSnapshotId, repositoryShardId, newShardGeneration, f));\n        assertEquals(newShardGeneration, newShardGeneration2);\n    }\n\n    private static BlobStoreIndexShardSnapshots readShardGeneration(BlobStoreRepository repository, RepositoryShardId repositoryShardId,\n                                                                    String generation) {\n        return PlainActionFuture.get(f -> repository.threadPool().generic().execute(ActionRunnable.supply(f,\n                () -> BlobStoreRepository.INDEX_SHARD_SNAPSHOTS_FORMAT.read(repository.shardContainer(repositoryShardId.index(),\n                        repositoryShardId.shardId()), generation, NamedXContentRegistry.EMPTY))));\n    }\n\n    private static BlobStoreIndexShardSnapshot readShardSnapshot(BlobStoreRepository repository, RepositoryShardId repositoryShardId,\n                                                                 SnapshotId snapshotId) {\n        return PlainActionFuture.get(f -> repository.threadPool().generic().execute(ActionRunnable.supply(f,\n                () -> repository.loadShardSnapshot(repository.shardContainer(repositoryShardId.index(), repositoryShardId.shardId()),\n                        snapshotId))));\n    }\n}", "class_id": 0, "repo": "stkrelax/elasticsearch", "file": "server/src/internalClusterTest/java/org/elasticsearch/snapshots/CloneSnapshotIT.java", "last_update_at": "2020-11-13T04:57:47+00:00", "question_id": "82bec5a1f0dc3e2a23dce5c3e4d2867ee3bec7eb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST, numDataNodes = 0)\npublic class CloneSnapshotIT extends AbstractSnapshotIntegTestCase {\n    public void testShardClone() throws Exception {\n        internalCluster().startMasterOnlyNode();\n        internalCluster().startDataOnlyNode();\n        final String repoName = \"repo-name\";\n        final Path repoPath = randomRepoPath();\n        createRepository(repoName, \"fs\", repoPath);\n        final boolean useBwCFormat = randomBoolean();\n        if (useBwCFormat) {\n            initWithSnapshotVersion(repoName, repoPath, SnapshotsService.OLD_SNAPSHOT_FORMAT);\n            // Re-create repo to clear repository data cache\n            assertAcked(client().admin().cluster().prepareDeleteRepository(repoName).get());\n            createRepository(repoName, \"fs\", repoPath);\n        }\n        final String indexName = \"test-index\";\n        createIndexWithRandomDocs(indexName, randomIntBetween(5, 10));\n        final String sourceSnapshot = \"source-snapshot\";\n        final SnapshotInfo sourceSnapshotInfo = createFullSnapshot(repoName, sourceSnapshot);\n        final BlobStoreRepository repository =\n                (BlobStoreRepository) internalCluster().getCurrentMasterNodeInstance(RepositoriesService.class).repository(repoName);\n        final RepositoryData repositoryData = getRepositoryData(repoName);\n        final IndexId indexId = repositoryData.resolveIndexId(indexName);\n        final int shardId = 0;\n        final RepositoryShardId repositoryShardId = new RepositoryShardId(indexId, shardId);\n        final SnapshotId targetSnapshotId = new SnapshotId(\"target-snapshot\", UUIDs.randomBase64UUID(random()));\n        final String currentShardGen;\n        if (useBwCFormat) {\n            currentShardGen = null;\n        } else {\n            currentShardGen = repositoryData.shardGenerations().getShardGen(indexId, shardId);\n        }\n        final String newShardGeneration = PlainActionFuture.get(f -> repository.cloneShardSnapshot(\n                sourceSnapshotInfo.snapshotId(), targetSnapshotId, repositoryShardId, currentShardGen, f));\n        if (useBwCFormat) {\n            final long gen = Long.parseLong(newShardGeneration);\n            assertEquals(gen, 1L); // Initial snapshot brought it to 0, clone increments it to 1\n        }\n        final BlobStoreIndexShardSnapshot targetShardSnapshot = readShardSnapshot(repository, repositoryShardId, targetSnapshotId);\n        final BlobStoreIndexShardSnapshot sourceShardSnapshot =\n                readShardSnapshot(repository, repositoryShardId, sourceSnapshotInfo.snapshotId());\n        assertThat(targetShardSnapshot.incrementalFileCount(), is(0));\n        final List<BlobStoreIndexShardSnapshot.FileInfo> sourceFiles = sourceShardSnapshot.indexFiles();\n        final List<BlobStoreIndexShardSnapshot.FileInfo> targetFiles = targetShardSnapshot.indexFiles();\n        final int fileCount = sourceFiles.size();\n        assertEquals(fileCount, targetFiles.size());\n        for (int i = 0; i < fileCount; i++) {\n            assertTrue(sourceFiles.get(i).isSame(targetFiles.get(i)));\n        }\n        final BlobStoreIndexShardSnapshots shardMetadata = readShardGeneration(repository, repositoryShardId, newShardGeneration);\n        final List<SnapshotFiles> snapshotFiles = shardMetadata.snapshots();\n        assertThat(snapshotFiles, hasSize(2));\n        assertTrue(snapshotFiles.get(0).isSame(snapshotFiles.get(1)));\n        // verify that repeated cloning is idempotent\n        final String newShardGeneration2 = PlainActionFuture.get(f -> repository.cloneShardSnapshot(\n                sourceSnapshotInfo.snapshotId(), targetSnapshotId, repositoryShardId, newShardGeneration, f));\n        assertEquals(newShardGeneration, newShardGeneration2);\n    }\n    private static BlobStoreIndexShardSnapshots readShardGeneration(BlobStoreRepository repository, RepositoryShardId repositoryShardId,\n                                                                    String generation) {\n        return PlainActionFuture.get(f -> repository.threadPool().generic().execute(ActionRunnable.supply(f,\n                () -> BlobStoreRepository.INDEX_SHARD_SNAPSHOTS_FORMAT.read(repository.shardContainer(repositoryShardId.index(),\n                        repositoryShardId.shardId()), generation, NamedXContentRegistry.EMPTY))));\n    }\n    private static BlobStoreIndexShardSnapshot readShardSnapshot(BlobStoreRepository repository, RepositoryShardId repositoryShardId,\n                                                                 SnapshotId snapshotId) {\n        return PlainActionFuture.get(f -> repository.threadPool().generic().execute(ActionRunnable.supply(f,\n                () -> repository.loadShardSnapshot(repository.shardContainer(repositoryShardId.index(), repositoryShardId.shardId()),\n                        snapshotId))));\n    }\n"]]}
{"hexsha": "26d24c2f3114b2a095a5333b2fc0cf5e763f4686", "ext": "java", "lang": "Java", "content": "public class DescribeClusterTemplateResponseUnmarshaller {\n\n\tpublic static DescribeClusterTemplateResponse unmarshall(DescribeClusterTemplateResponse describeClusterTemplateResponse, UnmarshallerContext _ctx) {\n\t\t\r\n\t\tdescribeClusterTemplateResponse.setRequestId(_ctx.stringValue(\"DescribeClusterTemplateResponse.RequestId\"));\r\n\r\n\t\tTemplateInfo templateInfo = new TemplateInfo();\r\n\t\ttemplateInfo.setId(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.Id\"));\r\n\t\ttemplateInfo.setTemplateName(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.TemplateName\"));\r\n\t\ttemplateInfo.setEmrVer(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.EmrVer\"));\r\n\t\ttemplateInfo.setLogEnable(_ctx.booleanValue(\"DescribeClusterTemplateResponse.TemplateInfo.LogEnable\"));\r\n\t\ttemplateInfo.setLogPath(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.LogPath\"));\r\n\t\ttemplateInfo.setUserId(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.UserId\"));\r\n\t\ttemplateInfo.setUserDefinedEmrEcsRole(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.UserDefinedEmrEcsRole\"));\r\n\t\ttemplateInfo.setMasterNodeTotal(_ctx.integerValue(\"DescribeClusterTemplateResponse.TemplateInfo.MasterNodeTotal\"));\r\n\t\ttemplateInfo.setVpcId(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.VpcId\"));\r\n\t\ttemplateInfo.setVSwitchId(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.VSwitchId\"));\r\n\t\ttemplateInfo.setNetType(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.NetType\"));\r\n\t\ttemplateInfo.setIoOptimized(_ctx.booleanValue(\"DescribeClusterTemplateResponse.TemplateInfo.IoOptimized\"));\r\n\t\ttemplateInfo.setInstanceGeneration(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.InstanceGeneration\"));\r\n\t\ttemplateInfo.setHighAvailabilityEnable(_ctx.booleanValue(\"DescribeClusterTemplateResponse.TemplateInfo.HighAvailabilityEnable\"));\r\n\t\ttemplateInfo.setEasEnable(_ctx.booleanValue(\"DescribeClusterTemplateResponse.TemplateInfo.EasEnable\"));\r\n\t\ttemplateInfo.setGmtCreate(_ctx.longValue(\"DescribeClusterTemplateResponse.TemplateInfo.GmtCreate\"));\r\n\t\ttemplateInfo.setGmtModified(_ctx.longValue(\"DescribeClusterTemplateResponse.TemplateInfo.GmtModified\"));\r\n\t\ttemplateInfo.setZoneId(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.ZoneId\"));\r\n\t\ttemplateInfo.setClusterType(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.ClusterType\"));\r\n\t\ttemplateInfo.setSecurityGroupId(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.SecurityGroupId\"));\r\n\t\ttemplateInfo.setSecurityGroupName(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.SecurityGroupName\"));\r\n\t\ttemplateInfo.setConfigurations(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.Configurations\"));\r\n\t\ttemplateInfo.setAllowNotebook(_ctx.booleanValue(\"DescribeClusterTemplateResponse.TemplateInfo.AllowNotebook\"));\r\n\t\ttemplateInfo.setCreateSource(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.CreateSource\"));\r\n\t\ttemplateInfo.setUseLocalMetaDb(_ctx.booleanValue(\"DescribeClusterTemplateResponse.TemplateInfo.UseLocalMetaDb\"));\r\n\t\ttemplateInfo.setSshEnable(_ctx.booleanValue(\"DescribeClusterTemplateResponse.TemplateInfo.SshEnable\"));\r\n\t\ttemplateInfo.setIsOpenPublicIp(_ctx.booleanValue(\"DescribeClusterTemplateResponse.TemplateInfo.IsOpenPublicIp\"));\r\n\t\ttemplateInfo.setDepositType(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.DepositType\"));\r\n\t\ttemplateInfo.setMachineType(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.MachineType\"));\r\n\t\ttemplateInfo.setUseCustomHiveMetaDb(_ctx.booleanValue(\"DescribeClusterTemplateResponse.TemplateInfo.UseCustomHiveMetaDb\"));\r\n\t\ttemplateInfo.setInitCustomHiveMetaDb(_ctx.booleanValue(\"DescribeClusterTemplateResponse.TemplateInfo.InitCustomHiveMetaDb\"));\r\n\t\ttemplateInfo.setKeyPairName(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.KeyPairName\"));\r\n\t\ttemplateInfo.setMasterPwd(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.MasterPwd\"));\r\n\t\ttemplateInfo.setMetaStoreType(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.MetaStoreType\"));\r\n\t\ttemplateInfo.setMetaStoreConf(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.MetaStoreConf\"));\r\n\r\n\t\tList<String> softwareInfoList = new ArrayList<String>();\r\n\t\tfor (int i = 0; i < _ctx.lengthValue(\"DescribeClusterTemplateResponse.TemplateInfo.SoftwareInfoList.Length\"); i++) {\r\n\t\t\tsoftwareInfoList.add(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.SoftwareInfoList[\"+ i +\"]\"));\r\n\t\t}\r\n\t\ttemplateInfo.setSoftwareInfoList(softwareInfoList);\r\n\r\n\t\tList<BootstrapAction> bootstrapActionList = new ArrayList<BootstrapAction>();\r\n\t\tfor (int i = 0; i < _ctx.lengthValue(\"DescribeClusterTemplateResponse.TemplateInfo.BootstrapActionList.Length\"); i++) {\r\n\t\t\tBootstrapAction bootstrapAction = new BootstrapAction();\r\n\t\t\tbootstrapAction.setName(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.BootstrapActionList[\"+ i +\"].Name\"));\r\n\t\t\tbootstrapAction.setPath(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.BootstrapActionList[\"+ i +\"].Path\"));\r\n\t\t\tbootstrapAction.setArg(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.BootstrapActionList[\"+ i +\"].Arg\"));\r\n\r\n\t\t\tbootstrapActionList.add(bootstrapAction);\r\n\t\t}\r\n\t\ttemplateInfo.setBootstrapActionList(bootstrapActionList);\r\n\r\n\t\tList<HostGroup> hostGroupList = new ArrayList<HostGroup>();\r\n\t\tfor (int i = 0; i < _ctx.lengthValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList.Length\"); i++) {\r\n\t\t\tHostGroup hostGroup = new HostGroup();\r\n\t\t\thostGroup.setHostGroupId(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].HostGroupId\"));\r\n\t\t\thostGroup.setHostGroupName(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].HostGroupName\"));\r\n\t\t\thostGroup.setHostGroupType(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].HostGroupType\"));\r\n\t\t\thostGroup.setChargeType(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].ChargeType\"));\r\n\t\t\thostGroup.setPeriod(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].Period\"));\r\n\t\t\thostGroup.setNodeCount(_ctx.integerValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].NodeCount\"));\r\n\t\t\thostGroup.setInstanceType(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].InstanceType\"));\r\n\t\t\thostGroup.setDiskType(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].DiskType\"));\r\n\t\t\thostGroup.setDiskCapacity(_ctx.integerValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].DiskCapacity\"));\r\n\t\t\thostGroup.setDiskCount(_ctx.integerValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].DiskCount\"));\r\n\t\t\thostGroup.setSysDiskType(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].SysDiskType\"));\r\n\t\t\thostGroup.setSysDiskCapacity(_ctx.integerValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].SysDiskCapacity\"));\r\n\t\t\thostGroup.setMultiInstanceTypes(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].MultiInstanceTypes\"));\r\n\r\n\t\t\thostGroupList.add(hostGroup);\r\n\t\t}\r\n\t\ttemplateInfo.setHostGroupList(hostGroupList);\r\n\r\n\t\tList<Config> configList = new ArrayList<Config>();\r\n\t\tfor (int i = 0; i < _ctx.lengthValue(\"DescribeClusterTemplateResponse.TemplateInfo.ConfigList.Length\"); i++) {\r\n\t\t\tConfig config = new Config();\r\n\t\t\tconfig.setServiceName(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.ConfigList[\"+ i +\"].ServiceName\"));\r\n\t\t\tconfig.setFileName(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.ConfigList[\"+ i +\"].FileName\"));\r\n\t\t\tconfig.setConfigKey(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.ConfigList[\"+ i +\"].ConfigKey\"));\r\n\t\t\tconfig.setConfigValue(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.ConfigList[\"+ i +\"].ConfigValue\"));\r\n\t\t\tconfig.setEncrypt(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.ConfigList[\"+ i +\"].Encrypt\"));\r\n\t\t\tconfig.setReplace(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.ConfigList[\"+ i +\"].Replace\"));\r\n\r\n\t\t\tconfigList.add(config);\r\n\t\t}\r\n\t\ttemplateInfo.setConfigList(configList);\r\n\r\n\t\tList<Tag> tags = new ArrayList<Tag>();\r\n\t\tfor (int i = 0; i < _ctx.lengthValue(\"DescribeClusterTemplateResponse.TemplateInfo.Tags.Length\"); i++) {\r\n\t\t\tTag tag = new Tag();\r\n\t\t\ttag.setTagKey(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.Tags[\"+ i +\"].TagKey\"));\r\n\t\t\ttag.setTagValue(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.Tags[\"+ i +\"].TagValue\"));\r\n\r\n\t\t\ttags.add(tag);\r\n\t\t}\r\n\t\ttemplateInfo.setTags(tags);\r\n\t\tdescribeClusterTemplateResponse.setTemplateInfo(templateInfo);\n\t \n\t \treturn describeClusterTemplateResponse;\n\t}\n}", "class_id": 0, "repo": "cctvzd7/aliyun-openapi-java-sdk", "file": "aliyun-java-sdk-emr/src/main/java/com/aliyuncs/emr/transform/v20160408/DescribeClusterTemplateResponseUnmarshaller.java", "last_update_at": "2020-11-23T08:42:58+00:00", "question_id": "26d24c2f3114b2a095a5333b2fc0cf5e763f4686", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DescribeClusterTemplateResponseUnmarshaller {\n\tpublic static DescribeClusterTemplateResponse unmarshall(DescribeClusterTemplateResponse describeClusterTemplateResponse, UnmarshallerContext _ctx) {\n\t\t\r\n\t\tdescribeClusterTemplateResponse.setRequestId(_ctx.stringValue(\"DescribeClusterTemplateResponse.RequestId\"));\r\n\r\n\t\tTemplateInfo templateInfo = new TemplateInfo();\r\n\t\ttemplateInfo.setId(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.Id\"));\r\n\t\ttemplateInfo.setTemplateName(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.TemplateName\"));\r\n\t\ttemplateInfo.setEmrVer(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.EmrVer\"));\r\n\t\ttemplateInfo.setLogEnable(_ctx.booleanValue(\"DescribeClusterTemplateResponse.TemplateInfo.LogEnable\"));\r\n\t\ttemplateInfo.setLogPath(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.LogPath\"));\r\n\t\ttemplateInfo.setUserId(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.UserId\"));\r\n\t\ttemplateInfo.setUserDefinedEmrEcsRole(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.UserDefinedEmrEcsRole\"));\r\n\t\ttemplateInfo.setMasterNodeTotal(_ctx.integerValue(\"DescribeClusterTemplateResponse.TemplateInfo.MasterNodeTotal\"));\r\n\t\ttemplateInfo.setVpcId(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.VpcId\"));\r\n\t\ttemplateInfo.setVSwitchId(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.VSwitchId\"));\r\n\t\ttemplateInfo.setNetType(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.NetType\"));\r\n\t\ttemplateInfo.setIoOptimized(_ctx.booleanValue(\"DescribeClusterTemplateResponse.TemplateInfo.IoOptimized\"));\r\n\t\ttemplateInfo.setInstanceGeneration(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.InstanceGeneration\"));\r\n\t\ttemplateInfo.setHighAvailabilityEnable(_ctx.booleanValue(\"DescribeClusterTemplateResponse.TemplateInfo.HighAvailabilityEnable\"));\r\n\t\ttemplateInfo.setEasEnable(_ctx.booleanValue(\"DescribeClusterTemplateResponse.TemplateInfo.EasEnable\"));\r\n\t\ttemplateInfo.setGmtCreate(_ctx.longValue(\"DescribeClusterTemplateResponse.TemplateInfo.GmtCreate\"));\r\n\t\ttemplateInfo.setGmtModified(_ctx.longValue(\"DescribeClusterTemplateResponse.TemplateInfo.GmtModified\"));\r\n\t\ttemplateInfo.setZoneId(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.ZoneId\"));\r\n\t\ttemplateInfo.setClusterType(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.ClusterType\"));\r\n\t\ttemplateInfo.setSecurityGroupId(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.SecurityGroupId\"));\r\n\t\ttemplateInfo.setSecurityGroupName(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.SecurityGroupName\"));\r\n\t\ttemplateInfo.setConfigurations(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.Configurations\"));\r\n\t\ttemplateInfo.setAllowNotebook(_ctx.booleanValue(\"DescribeClusterTemplateResponse.TemplateInfo.AllowNotebook\"));\r\n\t\ttemplateInfo.setCreateSource(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.CreateSource\"));\r\n\t\ttemplateInfo.setUseLocalMetaDb(_ctx.booleanValue(\"DescribeClusterTemplateResponse.TemplateInfo.UseLocalMetaDb\"));\r\n\t\ttemplateInfo.setSshEnable(_ctx.booleanValue(\"DescribeClusterTemplateResponse.TemplateInfo.SshEnable\"));\r\n\t\ttemplateInfo.setIsOpenPublicIp(_ctx.booleanValue(\"DescribeClusterTemplateResponse.TemplateInfo.IsOpenPublicIp\"));\r\n\t\ttemplateInfo.setDepositType(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.DepositType\"));\r\n\t\ttemplateInfo.setMachineType(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.MachineType\"));\r\n\t\ttemplateInfo.setUseCustomHiveMetaDb(_ctx.booleanValue(\"DescribeClusterTemplateResponse.TemplateInfo.UseCustomHiveMetaDb\"));\r\n\t\ttemplateInfo.setInitCustomHiveMetaDb(_ctx.booleanValue(\"DescribeClusterTemplateResponse.TemplateInfo.InitCustomHiveMetaDb\"));\r\n\t\ttemplateInfo.setKeyPairName(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.KeyPairName\"));\r\n\t\ttemplateInfo.setMasterPwd(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.MasterPwd\"));\r\n\t\ttemplateInfo.setMetaStoreType(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.MetaStoreType\"));\r\n\t\ttemplateInfo.setMetaStoreConf(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.MetaStoreConf\"));\r\n\r\n\t\tList<String> softwareInfoList = new ArrayList<String>();\r\n\t\tfor (int i = 0; i < _ctx.lengthValue(\"DescribeClusterTemplateResponse.TemplateInfo.SoftwareInfoList.Length\"); i++) {\r\n\t\t\tsoftwareInfoList.add(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.SoftwareInfoList[\"+ i +\"]\"));\r\n\t\t}\r\n\t\ttemplateInfo.setSoftwareInfoList(softwareInfoList);\r\n\r\n\t\tList<BootstrapAction> bootstrapActionList = new ArrayList<BootstrapAction>();\r\n\t\tfor (int i = 0; i < _ctx.lengthValue(\"DescribeClusterTemplateResponse.TemplateInfo.BootstrapActionList.Length\"); i++) {\r\n\t\t\tBootstrapAction bootstrapAction = new BootstrapAction();\r\n\t\t\tbootstrapAction.setName(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.BootstrapActionList[\"+ i +\"].Name\"));\r\n\t\t\tbootstrapAction.setPath(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.BootstrapActionList[\"+ i +\"].Path\"));\r\n\t\t\tbootstrapAction.setArg(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.BootstrapActionList[\"+ i +\"].Arg\"));\r\n\r\n\t\t\tbootstrapActionList.add(bootstrapAction);\r\n\t\t}\r\n\t\ttemplateInfo.setBootstrapActionList(bootstrapActionList);\r\n\r\n\t\tList<HostGroup> hostGroupList = new ArrayList<HostGroup>();\r\n\t\tfor (int i = 0; i < _ctx.lengthValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList.Length\"); i++) {\r\n\t\t\tHostGroup hostGroup = new HostGroup();\r\n\t\t\thostGroup.setHostGroupId(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].HostGroupId\"));\r\n\t\t\thostGroup.setHostGroupName(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].HostGroupName\"));\r\n\t\t\thostGroup.setHostGroupType(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].HostGroupType\"));\r\n\t\t\thostGroup.setChargeType(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].ChargeType\"));\r\n\t\t\thostGroup.setPeriod(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].Period\"));\r\n\t\t\thostGroup.setNodeCount(_ctx.integerValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].NodeCount\"));\r\n\t\t\thostGroup.setInstanceType(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].InstanceType\"));\r\n\t\t\thostGroup.setDiskType(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].DiskType\"));\r\n\t\t\thostGroup.setDiskCapacity(_ctx.integerValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].DiskCapacity\"));\r\n\t\t\thostGroup.setDiskCount(_ctx.integerValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].DiskCount\"));\r\n\t\t\thostGroup.setSysDiskType(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].SysDiskType\"));\r\n\t\t\thostGroup.setSysDiskCapacity(_ctx.integerValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].SysDiskCapacity\"));\r\n\t\t\thostGroup.setMultiInstanceTypes(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.HostGroupList[\"+ i +\"].MultiInstanceTypes\"));\r\n\r\n\t\t\thostGroupList.add(hostGroup);\r\n\t\t}\r\n\t\ttemplateInfo.setHostGroupList(hostGroupList);\r\n\r\n\t\tList<Config> configList = new ArrayList<Config>();\r\n\t\tfor (int i = 0; i < _ctx.lengthValue(\"DescribeClusterTemplateResponse.TemplateInfo.ConfigList.Length\"); i++) {\r\n\t\t\tConfig config = new Config();\r\n\t\t\tconfig.setServiceName(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.ConfigList[\"+ i +\"].ServiceName\"));\r\n\t\t\tconfig.setFileName(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.ConfigList[\"+ i +\"].FileName\"));\r\n\t\t\tconfig.setConfigKey(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.ConfigList[\"+ i +\"].ConfigKey\"));\r\n\t\t\tconfig.setConfigValue(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.ConfigList[\"+ i +\"].ConfigValue\"));\r\n\t\t\tconfig.setEncrypt(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.ConfigList[\"+ i +\"].Encrypt\"));\r\n\t\t\tconfig.setReplace(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.ConfigList[\"+ i +\"].Replace\"));\r\n\r\n\t\t\tconfigList.add(config);\r\n\t\t}\r\n\t\ttemplateInfo.setConfigList(configList);\r\n\r\n\t\tList<Tag> tags = new ArrayList<Tag>();\r\n\t\tfor (int i = 0; i < _ctx.lengthValue(\"DescribeClusterTemplateResponse.TemplateInfo.Tags.Length\"); i++) {\r\n\t\t\tTag tag = new Tag();\r\n\t\t\ttag.setTagKey(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.Tags[\"+ i +\"].TagKey\"));\r\n\t\t\ttag.setTagValue(_ctx.stringValue(\"DescribeClusterTemplateResponse.TemplateInfo.Tags[\"+ i +\"].TagValue\"));\r\n\r\n\t\t\ttags.add(tag);\r\n\t\t}\r\n\t\ttemplateInfo.setTags(tags);\r\n\t\tdescribeClusterTemplateResponse.setTemplateInfo(templateInfo);\n\t \n\t \treturn describeClusterTemplateResponse;\n\t}\n"]]}
{"hexsha": "8f7acd1c6716ff45fc7a9e90f82f69b91976813b", "ext": "java", "lang": "Java", "content": "public class ValueCollectionTest\n{\n\n\tprivate static final double DOUBLE_VALUE_1 = 0.15625d;\n\tprivate static final double DOUBLE_VALUE_2 = 5.0E2;\n\n\t@Test\n\tpublic void testConversionToReal() throws Exception\n\t{\n\t\tAsn1Factory factory = new DefaultAsn1Factory();\n\t\tModule module = factory.types().dummyModule();\n\n\t\tValueCollection collection = factory.values().collection( true );\n\t\tcollection.addNamed( \"mantissa\", factory.values().integer( 5 ) );\n\t\tcollection.addNamed( \"base\", factory.values().integer( 2 ) );\n\t\tcollection.addNamed( \"exponent\", factory.values().integer( -5 ) );\n\n\t\tDefinedValue value = factory.types().define( \"a-real\", UniversalType.REAL.ref(), collection, null );\n\n\t\tmodule.validate();\n\n\t\tAssert.assertEquals( \"Is not 0.15625\", 0, factory.values().real( DOUBLE_VALUE_1 ).compareTo( value.getValue() ) );\n\t}\n\n\t@Test\n\tpublic void testConversionToReal2() throws Exception\n\t{\n\t\tAsn1Factory factory = new DefaultAsn1Factory();\n\t\tModule module = factory.types().dummyModule();\n\n\t\tValueCollection collection = factory.values().collection( true );\n\t\tcollection.addNamed( \"mantissa\", factory.values().integer( 5 ) );\n\t\tcollection.addNamed( \"base\", factory.values().integer( 10 ) );\n\t\tcollection.addNamed( \"exponent\", factory.values().integer( 2 ) );\n\n\t\tDefinedValue value = factory.types().define( \"a-real\", UniversalType.REAL.ref(), collection, null );\n\n\t\tmodule.validate();\n\n\t\tAssert.assertEquals( \"Is not 5E2\", 0, factory.values().real( DOUBLE_VALUE_2 ).compareTo( value.getValue() ) );\n\t}\n}", "class_id": 0, "repo": "lastrix/asn1s", "file": "asn1s-core/src/test/java/org/asn1s/core/value/ValueCollectionTest.java", "last_update_at": "2020-03-18T09:55:15+00:00", "question_id": "8f7acd1c6716ff45fc7a9e90f82f69b91976813b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ValueCollectionTest\n{\n\tprivate static final double DOUBLE_VALUE_1 = 0.15625d;\n\tprivate static final double DOUBLE_VALUE_2 = 5.0E2;\n\t@Test\n\tpublic void testConversionToReal() throws Exception\n\t{\n\t\tAsn1Factory factory = new DefaultAsn1Factory();\n\t\tModule module = factory.types().dummyModule();\n\t\tValueCollection collection = factory.values().collection( true );\n\t\tcollection.addNamed( \"mantissa\", factory.values().integer( 5 ) );\n\t\tcollection.addNamed( \"base\", factory.values().integer( 2 ) );\n\t\tcollection.addNamed( \"exponent\", factory.values().integer( -5 ) );\n\t\tDefinedValue value = factory.types().define( \"a-real\", UniversalType.REAL.ref(), collection, null );\n\t\tmodule.validate();\n\t\tAssert.assertEquals( \"Is not 0.15625\", 0, factory.values().real( DOUBLE_VALUE_1 ).compareTo( value.getValue() ) );\n\t}\n\t@Test\n\tpublic void testConversionToReal2() throws Exception\n\t{\n\t\tAsn1Factory factory = new DefaultAsn1Factory();\n\t\tModule module = factory.types().dummyModule();\n\t\tValueCollection collection = factory.values().collection( true );\n\t\tcollection.addNamed( \"mantissa\", factory.values().integer( 5 ) );\n\t\tcollection.addNamed( \"base\", factory.values().integer( 10 ) );\n\t\tcollection.addNamed( \"exponent\", factory.values().integer( 2 ) );\n\t\tDefinedValue value = factory.types().define( \"a-real\", UniversalType.REAL.ref(), collection, null );\n\t\tmodule.validate();\n\t\tAssert.assertEquals( \"Is not 5E2\", 0, factory.values().real( DOUBLE_VALUE_2 ).compareTo( value.getValue() ) );\n\t}\n"]]}
{"hexsha": "a0a830e37355c38527f0d1d22be7dc1be61724a9", "ext": "java", "lang": "Java", "content": "@SuppressWarnings(\"WeakerAccess\")\npublic class MavenRepositories {\n    private static final String MAVEN_METADATA_FILE_NAME = \"maven-metadata.xml\";\n\n    private MavenRepositories() {}\n\n    /**\n     * Finds the best matching {@link GradleCoordinate}.\n     *\n     * @param groupId      the artifact group id\n     * @param artifactId   the artifact id\n     * @param repository   the path to the m2repository directory\n     * @param filter       an optional version filter that has to be satisfied by the matched coordinate\n     * @param allowPreview whether preview versions are allowed to match\n     * @return the best (highest version) matching coordinate, or null if none were found\n     */\n    @Nullable\n    public static GradleCoordinate getHighestInstalledVersion(\n            @NonNull String groupId,\n            @NonNull String artifactId,\n            @NonNull File repository,\n            @Nullable Predicate<GradleVersion> filter,\n            boolean allowPreview,\n            @NonNull FileOp fileOp) {\n        File versionDir = getArtifactIdDirectory(repository, groupId, artifactId);\n        File[] versions = fileOp.listFiles(versionDir);\n        GradleCoordinate maxVersion = null;\n        for (File dir : versions) {\n            if (!fileOp.isDirectory(dir)) {\n                continue;\n            }\n            GradleCoordinate gc = GradleCoordinate.parseCoordinateString(\n                    groupId + \":\" + artifactId + \":\" + dir.getName());\n\n            if (gc != null && (allowPreview || !isPreview(gc))\n                    && (maxVersion == null || COMPARE_PLUS_HIGHER.compare(gc, maxVersion) > 0)\n                    && (applyVersionPredicate(gc.getRevision(), filter))) {\n                maxVersion = gc;\n            }\n        }\n\n        return maxVersion;\n    }\n\n    private static boolean applyVersionPredicate(@NonNull String revision,\n            @Nullable Predicate<GradleVersion> predicate) {\n        if (predicate == null) {\n            return true;\n        }\n        GradleVersion version = GradleVersion.tryParse(revision);\n        return version != null && predicate.test(version);\n    }\n\n    /**\n     * Finds the best matching {@link GradleVersion}. Like\n     * {@link #getHighestInstalledVersion(String, String, File, Predicate, boolean, FileOp)} but\n     * operates on {@link GradleVersion} instead of {@link GradleCoordinate}.\n     *\n     * @param groupId      the artifact group id\n     * @param artifactId   the artifact id\n     * @param repository   the path to the m2repository directory\n     * @param filter       an optional filter which the matched version must satisfy\n     * @param allowPreview whether preview versions are allowed to match\n     * @param fileOp       file operator to use for file access\n     * @return the best (highest version) matching version, or null if none were found\n     */\n    @Nullable\n    public static GradleVersion getHighestInstalledVersionNumber(\n            @NonNull String groupId,\n            @NonNull String artifactId,\n            @NonNull File repository,\n            @Nullable Predicate<GradleVersion> filter,\n            boolean allowPreview,\n            @NonNull FileOp fileOp) {\n        File versionDir = getArtifactIdDirectory(repository, groupId, artifactId);\n        return getHighestVersion(versionDir, filter, allowPreview, fileOp);\n    }\n\n    /**\n     * Given a directory containing version numbers returns the highest version number\n     * matching the given filter\n     *\n     * @param versionDir   the directory containing version numbers\n     * @param filter       an optional filter which the matched version must satisfy\n     * @param allowPreview whether preview versions are allowed to match\n     * @param fileOp       file operator to use for file access\n     * @return the best (highest version), or null if none were found\n     */\n    @Nullable\n    public static GradleVersion getHighestVersion(\n            @NonNull File versionDir,\n            @Nullable Predicate<GradleVersion> filter,\n            boolean allowPreview, @NonNull FileOp fileOp) {\n        File[] versionDirs = fileOp.listFiles(versionDir);\n        GradleVersion maxVersion = null;\n        for (File dir : versionDirs) {\n            if (!fileOp.isDirectory(dir)) {\n                continue;\n            }\n            String name = dir.getName();\n            if (name.isEmpty() || !Character.isDigit(name.charAt(0))) {\n                continue;\n            }\n            GradleVersion version = GradleVersion.tryParse(name);\n            if (version != null && (allowPreview || !version.isPreview()\n                    && (filter == null || filter.test(version)))\n                    && (maxVersion == null || version.compareTo(maxVersion) > 0)) {\n                maxVersion = version;\n            }\n        }\n\n        return maxVersion;\n    }\n\n    /**\n     * Decides whether a given {@link GradleCoordinate} is considered preview.\n     *\n     * <p>This is mostly compatible with {@link GradleCoordinate#isPreview()}, but there is one edge\n     * case that we need to handle, related to Play Services. (See https://b.android.com/75292)\n     */\n    public static boolean isPreview(GradleCoordinate coordinate) {\n        //noinspection SimplifiableIfStatement\n        if (coordinate.isPreview()) {\n            return true;\n        }\n\n        return \"com.google.android.gms\".equals(coordinate.getGroupId())\n                && \"play-services\".equals(coordinate.getArtifactId())\n                && \"5.2.08\".equals(coordinate.getRevision());\n    }\n\n    /**\n     * Returns true if the group is an AndroidX group.\n     *\n     * @param groupId\n     */\n    public static boolean isAndroidX(@NonNull String groupId) {\n        return groupId.startsWith(\"androidx.\");\n    }\n\n    public static File getArtifactIdDirectory(\n            @NonNull File repository,\n            @NonNull String groupId,\n            @NonNull String artifactId) {\n        return new File(repository,\n                groupId.replace('.', separatorChar) + separator + artifactId);\n    }\n\n    public static File getArtifactDirectory(\n            @NonNull File repository,\n            @NonNull GradleCoordinate coordinate) {\n        File artifactIdDirectory = getArtifactIdDirectory(\n                repository, coordinate.getGroupId(), coordinate.getArtifactId());\n\n        return new File(artifactIdDirectory, coordinate.getRevision());\n    }\n\n    public static File getMavenMetadataFile(\n            @NonNull File repository,\n            @NonNull String groupId,\n            @NonNull String artifactId) {\n        return new File(getArtifactIdDirectory(repository, groupId, artifactId),\n                MAVEN_METADATA_FILE_NAME);\n    }\n}", "class_id": 0, "repo": "qiangxu1996/vmtrace", "file": "base/sdk-common/src/main/java/com/android/ide/common/repository/MavenRepositories.java", "last_update_at": "2020-10-04T19:30:22+00:00", "question_id": "a0a830e37355c38527f0d1d22be7dc1be61724a9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings(\"WeakerAccess\")\npublic class MavenRepositories {\n    private static final String MAVEN_METADATA_FILE_NAME = \"maven-metadata.xml\";\n    private MavenRepositories() {}\n    /**\n     * Finds the best matching {@link GradleCoordinate}.\n     *\n     * @param groupId      the artifact group id\n     * @param artifactId   the artifact id\n     * @param repository   the path to the m2repository directory\n     * @param filter       an optional version filter that has to be satisfied by the matched coordinate\n     * @param allowPreview whether preview versions are allowed to match\n     * @return the best (highest version) matching coordinate, or null if none were found\n     */\n    @Nullable\n    public static GradleCoordinate getHighestInstalledVersion(\n            @NonNull String groupId,\n            @NonNull String artifactId,\n            @NonNull File repository,\n            @Nullable Predicate<GradleVersion> filter,\n            boolean allowPreview,\n            @NonNull FileOp fileOp) {\n        File versionDir = getArtifactIdDirectory(repository, groupId, artifactId);\n        File[] versions = fileOp.listFiles(versionDir);\n        GradleCoordinate maxVersion = null;\n        for (File dir : versions) {\n            if (!fileOp.isDirectory(dir)) {\n                continue;\n            }\n            GradleCoordinate gc = GradleCoordinate.parseCoordinateString(\n                    groupId + \":\" + artifactId + \":\" + dir.getName());\n            if (gc != null && (allowPreview || !isPreview(gc))\n                    && (maxVersion == null || COMPARE_PLUS_HIGHER.compare(gc, maxVersion) > 0)\n                    && (applyVersionPredicate(gc.getRevision(), filter))) {\n                maxVersion = gc;\n            }\n        }\n        return maxVersion;\n    }\n    private static boolean applyVersionPredicate(@NonNull String revision,\n            @Nullable Predicate<GradleVersion> predicate) {\n        if (predicate == null) {\n            return true;\n        }\n        GradleVersion version = GradleVersion.tryParse(revision);\n        return version != null && predicate.test(version);\n    }\n    /**\n     * Finds the best matching {@link GradleVersion}. Like\n     * {@link #getHighestInstalledVersion(String, String, File, Predicate, boolean, FileOp)} but\n     * operates on {@link GradleVersion} instead of {@link GradleCoordinate}.\n     *\n     * @param groupId      the artifact group id\n     * @param artifactId   the artifact id\n     * @param repository   the path to the m2repository directory\n     * @param filter       an optional filter which the matched version must satisfy\n     * @param allowPreview whether preview versions are allowed to match\n     * @param fileOp       file operator to use for file access\n     * @return the best (highest version) matching version, or null if none were found\n     */\n    @Nullable\n    public static GradleVersion getHighestInstalledVersionNumber(\n            @NonNull String groupId,\n            @NonNull String artifactId,\n            @NonNull File repository,\n            @Nullable Predicate<GradleVersion> filter,\n            boolean allowPreview,\n            @NonNull FileOp fileOp) {\n        File versionDir = getArtifactIdDirectory(repository, groupId, artifactId);\n        return getHighestVersion(versionDir, filter, allowPreview, fileOp);\n    }\n    /**\n     * Given a directory containing version numbers returns the highest version number\n     * matching the given filter\n     *\n     * @param versionDir   the directory containing version numbers\n     * @param filter       an optional filter which the matched version must satisfy\n     * @param allowPreview whether preview versions are allowed to match\n     * @param fileOp       file operator to use for file access\n     * @return the best (highest version), or null if none were found\n     */\n    @Nullable\n    public static GradleVersion getHighestVersion(\n            @NonNull File versionDir,\n            @Nullable Predicate<GradleVersion> filter,\n            boolean allowPreview, @NonNull FileOp fileOp) {\n        File[] versionDirs = fileOp.listFiles(versionDir);\n        GradleVersion maxVersion = null;\n        for (File dir : versionDirs) {\n            if (!fileOp.isDirectory(dir)) {\n                continue;\n            }\n            String name = dir.getName();\n            if (name.isEmpty() || !Character.isDigit(name.charAt(0))) {\n                continue;\n            }\n            GradleVersion version = GradleVersion.tryParse(name);\n            if (version != null && (allowPreview || !version.isPreview()\n                    && (filter == null || filter.test(version)))\n                    && (maxVersion == null || version.compareTo(maxVersion) > 0)) {\n                maxVersion = version;\n            }\n        }\n        return maxVersion;\n    }\n    /**\n     * Decides whether a given {@link GradleCoordinate} is considered preview.\n     *\n     * <p>This is mostly compatible with {@link GradleCoordinate#isPreview()}, but there is one edge\n     * case that we need to handle, related to Play Services. (See https://b.android.com/75292)\n     */\n    public static boolean isPreview(GradleCoordinate coordinate) {\n        //noinspection SimplifiableIfStatement\n        if (coordinate.isPreview()) {\n            return true;\n        }\n        return \"com.google.android.gms\".equals(coordinate.getGroupId())\n                && \"play-services\".equals(coordinate.getArtifactId())\n                && \"5.2.08\".equals(coordinate.getRevision());\n    }\n    /**\n     * Returns true if the group is an AndroidX group.\n     *\n     * @param groupId\n     */\n    public static boolean isAndroidX(@NonNull String groupId) {\n        return groupId.startsWith(\"androidx.\");\n    }\n    public static File getArtifactIdDirectory(\n            @NonNull File repository,\n            @NonNull String groupId,\n            @NonNull String artifactId) {\n        return new File(repository,\n                groupId.replace('.', separatorChar) + separator + artifactId);\n    }\n    public static File getArtifactDirectory(\n            @NonNull File repository,\n            @NonNull GradleCoordinate coordinate) {\n        File artifactIdDirectory = getArtifactIdDirectory(\n                repository, coordinate.getGroupId(), coordinate.getArtifactId());\n        return new File(artifactIdDirectory, coordinate.getRevision());\n    }\n    public static File getMavenMetadataFile(\n            @NonNull File repository,\n            @NonNull String groupId,\n            @NonNull String artifactId) {\n        return new File(getArtifactIdDirectory(repository, groupId, artifactId),\n                MAVEN_METADATA_FILE_NAME);\n    }\n"]]}
{"hexsha": "1a3775db1532636ad54df958791a96df6592e03b", "ext": "java", "lang": "Java", "content": "public class WebBook extends AppCompatActivity {\n\n    private String URI;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.web_view);\n        WebView webView = (WebView) findViewById(R.id.view_web);\n        webView.getSettings().setJavaScriptEnabled(true);\n        webView.setWebViewClient(new WebViewClient());\n        Intent intent = getIntent();\n        String name = intent.getStringExtra(\"name\");\n        URI = \"https://www.amazon.cn/s/ref=nb_sb_ss_i_2_9/461-5115720-8747102?__mk_zh_CN=%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%BD%91%E7%AB%99&url=search-alias%3Daps&field-keywords=%E6%B5%B7%E6%B0%B4%E9%B1%BC%E5%9B%BE%E9%89%B4&sprefix=\"\n                + name + \"%2Caps%2C148&crid=115Y6JWK1RSDX\\n\";\n        webView.loadUrl(URI);\n\n    }\n}", "class_id": 0, "repo": "LonglyWolf/Drop", "file": "app/src/main/java/com/example/drop/activities/WebBook.java", "last_update_at": "2020-04-16T07:33:37+00:00", "question_id": "1a3775db1532636ad54df958791a96df6592e03b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class WebBook extends AppCompatActivity {\n    private String URI;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.web_view);\n        WebView webView = (WebView) findViewById(R.id.view_web);\n        webView.getSettings().setJavaScriptEnabled(true);\n        webView.setWebViewClient(new WebViewClient());\n        Intent intent = getIntent();\n        String name = intent.getStringExtra(\"name\");\n        URI = \"https://www.amazon.cn/s/ref=nb_sb_ss_i_2_9/461-5115720-8747102?__mk_zh_CN=%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%BD%91%E7%AB%99&url=search-alias%3Daps&field-keywords=%E6%B5%B7%E6%B0%B4%E9%B1%BC%E5%9B%BE%E9%89%B4&sprefix=\"\n                + name + \"%2Caps%2C148&crid=115Y6JWK1RSDX\\n\";\n        webView.loadUrl(URI);\n    }\n"]]}
{"hexsha": "7fed804b68876c4bf94dce0394e1695dc0ac1c97", "ext": "java", "lang": "Java", "content": "public class PhilosophersStoneItem extends TransmutableReagentItem {\n    public final long minCharge, maxCharge;\n\n    // Kinda ugly hack to retain the ItemStack for getUnitCharge\n    private static ItemStack heldStack = null;\n\n    public PhilosophersStoneItem (Settings settings, AlchymReference.PhilosophersStoneCharges charge) {\n        super (settings);\n\n        minCharge = charge.min;\n        maxCharge = charge.max;\n    }\n\n    @Override\n    public boolean isReagent() {\n        return true;\n    }\n\n    @Override\n    public long getUnitCharge() {\n        long charge = 0;\n\n        if (heldStack != null) {\n            charge = getStoneCharge (heldStack);\n            heldStack = null;\n        }\n        return charge;\n    }\n\n    @Override\n    public AlchymReference.Reagents getReagentType() {\n        return AlchymReference.Reagents.PHILOSOPHERS_STONE;\n    }\n\n    @Override\n    public TypedActionResult<ItemStack> use (World world, PlayerEntity player, Hand hand) {\n        if (!world.isClient && isPhilosophersStone (player.getStackInHand (hand))) {\n            PhilosophersStoneItem.setHeldStack (player.getStackInHand (hand));\n\n            // Delegate to superclass use method\n            return super.use (world, player, hand);\n        }\n\n        return new TypedActionResult(ActionResult.PASS, player.getStackInHand (hand));\n    }\n\n    public static long getStoneCharge (ItemStack stack) {\n        long charge = 0L;\n\n        if (stack != null && ! stack.isEmpty() && stack.getItem () instanceof PhilosophersStoneItem) {\n            if (stack.hasTag () && stack.getTag ().contains (AlchymReference.MODID) &&\n                    stack.getTag ().getCompound (AlchymReference.MODID).contains (\"stone_charge\")) {\n                charge = stack.getTag ().getCompound (AlchymReference.MODID).getLong (\"stone_charge\");\n            } else {\n                CompoundTag tag = new CompoundTag ();\n                charge = ((PhilosophersStoneItem) stack.getItem ()).minCharge;\n                tag.putLong (\"stone_charge\", charge);\n                stack.setTag(tag);\n            }\n        }\n\n        return charge;\n    }\n\n    public static void setHeldStack (ItemStack stack) {\n        heldStack = stack;\n    }\n\n    private boolean isPhilosophersStone (ItemStack stack) {\n        return TransmutationHelper.isReagent (stack) && stack.getItem() instanceof PhilosophersStoneItem;\n    }\n}", "class_id": 0, "repo": "deyahruhd/Alchym", "file": "src/main/java/jard/alchym/items/PhilosophersStoneItem.java", "last_update_at": "2020-12-29T20:12:39+00:00", "question_id": "7fed804b68876c4bf94dce0394e1695dc0ac1c97", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PhilosophersStoneItem extends TransmutableReagentItem {\n    public final long minCharge, maxCharge;\n    // Kinda ugly hack to retain the ItemStack for getUnitCharge\n    private static ItemStack heldStack = null;\n    public PhilosophersStoneItem (Settings settings, AlchymReference.PhilosophersStoneCharges charge) {\n        super (settings);\n        minCharge = charge.min;\n        maxCharge = charge.max;\n    }\n    @Override\n    public boolean isReagent() {\n        return true;\n    }\n    @Override\n    public long getUnitCharge() {\n        long charge = 0;\n        if (heldStack != null) {\n            charge = getStoneCharge (heldStack);\n            heldStack = null;\n        }\n        return charge;\n    }\n    @Override\n    public AlchymReference.Reagents getReagentType() {\n        return AlchymReference.Reagents.PHILOSOPHERS_STONE;\n    }\n    @Override\n    public TypedActionResult<ItemStack> use (World world, PlayerEntity player, Hand hand) {\n        if (!world.isClient && isPhilosophersStone (player.getStackInHand (hand))) {\n            PhilosophersStoneItem.setHeldStack (player.getStackInHand (hand));\n            // Delegate to superclass use method\n            return super.use (world, player, hand);\n        }\n        return new TypedActionResult(ActionResult.PASS, player.getStackInHand (hand));\n    }\n    public static long getStoneCharge (ItemStack stack) {\n        long charge = 0L;\n        if (stack != null && ! stack.isEmpty() && stack.getItem () instanceof PhilosophersStoneItem) {\n            if (stack.hasTag () && stack.getTag ().contains (AlchymReference.MODID) &&\n                    stack.getTag ().getCompound (AlchymReference.MODID).contains (\"stone_charge\")) {\n                charge = stack.getTag ().getCompound (AlchymReference.MODID).getLong (\"stone_charge\");\n            } else {\n                CompoundTag tag = new CompoundTag ();\n                charge = ((PhilosophersStoneItem) stack.getItem ()).minCharge;\n                tag.putLong (\"stone_charge\", charge);\n                stack.setTag(tag);\n            }\n        }\n        return charge;\n    }\n    public static void setHeldStack (ItemStack stack) {\n        heldStack = stack;\n    }\n    private boolean isPhilosophersStone (ItemStack stack) {\n        return TransmutationHelper.isReagent (stack) && stack.getItem() instanceof PhilosophersStoneItem;\n    }\n"]]}
{"hexsha": "8e7dc8e2e2ccfa5ec900d2d82823b6b3b66e02c6", "ext": "java", "lang": "Java", "content": "public class Blob {\n  // Canto superior esquerdo e inferior direito\n  float minx;\n  float miny;\n  float maxx;\n  float maxy;\n  int cor;\n  // int id = -1;\n  int numPixels = 0;\n\n  Blob(float x, float y) {\n    minx = x;\n    miny = y;\n    maxx = x;\n    maxy = y;\n  }\n  Blob(float x, float y, int c) {\n    minx = x;\n    miny = y;\n    maxx = x;\n    maxy = y;\n    cor = c;\n  }\n\n  Blob(Blob b) {\n    minx = b.minx;\n    miny = b.miny;\n    maxx = b.maxx;\n    maxy = b.maxy;\n    cor = b.cor;\n    // id = b.id;\n    numPixels = b.numPixels;\n  }\n\n  Blob() {\n  }\n  \n  protected Blob clone() {\n    Blob b = new Blob(this);\n    return b;\n  }\n\n  public PVector center() {\n    PVector centro = new PVector();\n    centro.x = (minx+maxx)/2;\n    centro.y = (miny+maxy)/2;\n    \n    return centro;\n  }\n\n  void add(float x, float y) {\n    minx = Math.min(minx, x);\n    miny = Math.min(miny, y);\n    maxx = Math.max(maxx, x);\n    maxy = Math.max(maxy, y);\n    numPixels++;\n  }\n  \n  // Limpa as coordenadas do blob\n  void reset() {\n    minx = Float.MAX_VALUE;\n    miny = Float.MAX_VALUE;\n    maxx = 0;\n    maxy = 0;\n    numPixels = 0;\n  }\n  \n  //// Verifica se um ponto (x, y) faz parte do blob\n  boolean isNear(float x, float y) {\n    int distancia = 10;\n    float cx = Math.max(Math.min(x, maxx), minx);\n    float cy = Math.max(Math.min(y, maxy), miny);\n    float d = distSq(cx, cy, x, y);\n\n  if (d < distancia*distancia) return true;\n    return false;\n  }\n\n  float size() {\n    return (maxx-minx)*(maxy-miny); \n  }\n\n  private float distSq(float ax, float ay, float bx, float by) {\n      return (ax-bx)*(ax-bx) + (ay-by)*(ay-by);\n  }\n}", "class_id": 0, "repo": "mochetti/tampi_lib", "file": "src/tampi/Blob.java", "last_update_at": "2020-12-29T20:42:56+00:00", "question_id": "8e7dc8e2e2ccfa5ec900d2d82823b6b3b66e02c6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Blob {\n  // Canto superior esquerdo e inferior direito\n  float minx;\n  float miny;\n  float maxx;\n  float maxy;\n  int cor;\n  // int id = -1;\n  int numPixels = 0;\n  Blob(float x, float y) {\n    minx = x;\n    miny = y;\n    maxx = x;\n    maxy = y;\n  }\n  Blob(float x, float y, int c) {\n    minx = x;\n    miny = y;\n    maxx = x;\n    maxy = y;\n    cor = c;\n  }\n  Blob(Blob b) {\n    minx = b.minx;\n    miny = b.miny;\n    maxx = b.maxx;\n    maxy = b.maxy;\n    cor = b.cor;\n    // id = b.id;\n    numPixels = b.numPixels;\n  }\n  Blob() {\n  }\n  protected Blob clone() {\n    Blob b = new Blob(this);\n    return b;\n  }\n  public PVector center() {\n    PVector centro = new PVector();\n    centro.x = (minx+maxx)/2;\n    centro.y = (miny+maxy)/2;\n    return centro;\n  }\n  void add(float x, float y) {\n    minx = Math.min(minx, x);\n    miny = Math.min(miny, y);\n    maxx = Math.max(maxx, x);\n    maxy = Math.max(maxy, y);\n    numPixels++;\n  }\n  // Limpa as coordenadas do blob\n  void reset() {\n    minx = Float.MAX_VALUE;\n    miny = Float.MAX_VALUE;\n    maxx = 0;\n    maxy = 0;\n    numPixels = 0;\n  }\n  //// Verifica se um ponto (x, y) faz parte do blob\n  boolean isNear(float x, float y) {\n    int distancia = 10;\n    float cx = Math.max(Math.min(x, maxx), minx);\n    float cy = Math.max(Math.min(y, maxy), miny);\n    float d = distSq(cx, cy, x, y);\n  if (d < distancia*distancia) return true;\n    return false;\n  }\n  float size() {\n    return (maxx-minx)*(maxy-miny); \n  }\n  private float distSq(float ax, float ay, float bx, float by) {\n      return (ax-bx)*(ax-bx) + (ay-by)*(ay-by);\n  }\n"]]}
{"hexsha": "6c7cbb7c77d6c5b9075449651bbc46e1a1707b6b", "ext": "java", "lang": "Java", "content": "public class SampleTest extends ValidationTest<Sample> {\n\n  public SampleTest(ValidationTestCase<Sample> testCase) {\n    super(testCase);\n  }\n\n  @Override\n  protected Sample createValidTestSubject() {\n    return Sample.create(\"xxxx\", \"yyy\");\n  }\n\n  @Parameterized.Parameters\n  public static Collection testCases() {\n    final Collection<ValidationTestCase> ret = new ArrayList<>();\n    ret.add(new ValidationTestCase<Sample>(\"basicCase\")\n            .adjustment(x -> {})\n            .valid(true));\n    ret.add(new ValidationTestCase<Sample>(\"nullIdentifier\")\n            .adjustment(x -> x.setIdentifier(null))\n            .valid(false));\n    ret.add(new ValidationTestCase<Sample>(\"tooShortIdentifier\")\n            .adjustment(x -> x.setIdentifier(\"z\"))\n            .valid(false));\n    ret.add(new ValidationTestCase<Sample>(\"tooLongPayload\")\n            .adjustment(x -> x.setPayload(RandomStringUtils.randomAlphanumeric(513)))\n            .valid(false));\n    return ret;\n  }\n\n}", "class_id": 0, "repo": "awasum/fineract-cn-sms", "file": "api/src/test/java/io/mifos/sms/api/v1/domain/SampleTest.java", "last_update_at": "2020-01-07T13:32:14+00:00", "question_id": "6c7cbb7c77d6c5b9075449651bbc46e1a1707b6b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SampleTest extends ValidationTest<Sample> {\n  public SampleTest(ValidationTestCase<Sample> testCase) {\n    super(testCase);\n  }\n  @Override\n  protected Sample createValidTestSubject() {\n    return Sample.create(\"xxxx\", \"yyy\");\n  }\n  @Parameterized.Parameters\n  public static Collection testCases() {\n    final Collection<ValidationTestCase> ret = new ArrayList<>();\n    ret.add(new ValidationTestCase<Sample>(\"basicCase\")\n            .adjustment(x -> {})\n            .valid(true));\n    ret.add(new ValidationTestCase<Sample>(\"nullIdentifier\")\n            .adjustment(x -> x.setIdentifier(null))\n            .valid(false));\n    ret.add(new ValidationTestCase<Sample>(\"tooShortIdentifier\")\n            .adjustment(x -> x.setIdentifier(\"z\"))\n            .valid(false));\n    ret.add(new ValidationTestCase<Sample>(\"tooLongPayload\")\n            .adjustment(x -> x.setPayload(RandomStringUtils.randomAlphanumeric(513)))\n            .valid(false));\n    return ret;\n  }\n"]]}
{"hexsha": "871df602c1ff1b5a199e875e712f0a7e65ea02c8", "ext": "java", "lang": "Java", "content": "public abstract class AbstractDMNValidationAwareMojo extends AbstractKieMojo {\n\n    @Parameter(required = true, defaultValue = \"${project.build.resources}\")\n    private List<Resource> resources;\n\n    @Parameter(property = \"validateDMN\", defaultValue = \"VALIDATE_SCHEMA,VALIDATE_MODEL,ANALYZE_DECISION_TABLE\")\n    private String validateDMN;\n\n    protected String getValidateDMN() {\n        return validateDMN;\n    }\n\n    protected void logValidationMessages(List<DMNMessage> validation,\n                                         Function<DMNMessage, String> prefixer,\n                                         Function<DMNMessage, String> computeMessage) {\n        for (DMNMessage msg : validation) {\n            Consumer<CharSequence> logFn = null;\n            switch (msg.getLevel()) {\n                case ERROR:\n                    logFn = getLog()::error;\n                    break;\n                case WARNING:\n                    logFn = getLog()::warn;\n                    break;\n                case INFO:\n                default:\n                    logFn = getLog()::info;\n                    break;\n            }\n            StringBuilder sb = new StringBuilder();\n            sb.append(prefixer.apply(msg));\n            sb.append(computeMessage.apply(msg));\n            logFn.accept(sb.toString());\n        }\n    }\n\n    public List<Validation> computeFlagsFromCSVString(String csvString) {\n        List<Validation> flags = new ArrayList<>();\n        boolean resetFlag = false;\n        for (String p : csvString.split(\",\")) {\n            try {\n                flags.add(Validation.valueOf(p));\n            } catch (IllegalArgumentException e) {\n                getLog().info(\"validateDMN configured with flag: '\" + p + \"' determines this Mojo will not be executed (reset all flags).\");\n                resetFlag = true;\n            }\n        }\n        if (resetFlag) {\n            flags.clear();\n        }\n        return flags;\n    }\n\n    protected boolean shallPerformDMNDTAnalysis() {\n        return computeFlagsFromCSVString(getValidateDMN()).contains(Validation.ANALYZE_DECISION_TABLE);\n    }\n\n    public void performDMNDTAnalysis(InternalKieModule kieModule) throws MojoExecutionException, MojoFailureException {\n        Collection<DMNModel> dmnModels = extractDMNModelsFromKieModule(kieModule);\n        getLog().info(\"Initializing DMN DT Validator...\");\n        InternalDMNDTAnalyser analyser = InternalDMNDTAnalyserFactory.newDMNDTAnalyser(computeDMNProfiles());\n        getLog().info(\"DMN DT Validator initialized.\");\n        for (DMNModel model : dmnModels) {\n            getLog().info(\"Analysing decision tables in DMN Model '\" + model.getName() + \"' ...\");\n            List<DTAnalysis> results = analyser.analyse(model, new HashSet<>(Arrays.asList(Validation.ANALYZE_DECISION_TABLE)));\n            if (results.isEmpty()) {\n                getLog().info(\" no decision tables found.\");\n            } else {\n                for (DTAnalysis r : results) {\n                    getLog().info(\" analysis for decision table '\" + r.nameOrIDOfTable() + \"':\");\n                    List<DMNMessage> messages = r.asDMNMessages();\n                    logValidationMessages(messages, (u) -> \"  \", DMNMessage::getMessage);\n                    if (messages.stream().anyMatch(m -> m.getLevel() == Level.ERROR)) {\n                        throw new MojoFailureException(\"There are DMN Validation Error(s).\");\n                    }\n                }\n            }\n        }\n    }\n\n    private Collection<DMNModel> extractDMNModelsFromKieModule(InternalKieModule kieModule) {\n        Collection<KiePackage> kpkgs = kieModule.getKieModuleModel().getKieBaseModels().keySet().stream()\n                                                .flatMap(name -> kieModule.getKnowledgePackagesForKieBase(name).stream())\n                                                .collect(Collectors.toList());\n        Set<DMNModel> models = new HashSet<>();\n        for (KiePackage kp : kpkgs) {\n            InternalKnowledgePackage ikpkg = (InternalKnowledgePackage) kp;\n            ResourceTypePackage<DMNModel> rtp = (ResourceTypePackage<DMNModel>) ikpkg.getResourceTypePackages().get(ResourceType.DMN);\n            if (rtp == null) {\n                continue;\n            }\n            for (DMNModel dmnModel : rtp) {\n                models.add(dmnModel);\n            }\n        }\n        Map<org.kie.api.io.Resource, DMNModel> removeDups = new HashMap<>();\n        for (DMNModel m : models) {\n            removeDups.put(m.getResource(), m);\n        }\n        return removeDups.values();\n    }\n\n    protected List<Path> resourcesPaths() {\n        List<Path> resourcesPaths = resources.stream().map(r -> new File(r.getDirectory()).toPath()).collect(Collectors.toList());\n        if (getLog().isDebugEnabled()) {\n            getLog().debug(\"resourcesPaths: \" + resourcesPaths.stream().map(Path::toString).collect(Collectors.joining(\",\\n\")));\n        }\n        return resourcesPaths;\n    }\n\n    protected List<DMNProfile> computeDMNProfiles() throws MojoExecutionException {\n        ClassLoader classLoader = ClassLoaderUtil.findDefaultClassLoader();\n        ChainedProperties chainedProperties = ChainedProperties.getChainedProperties(classLoader);\n        List<KieModuleModel> kieModules = new ArrayList<>();\n        for (Path p : resourcesPaths()) {\n            try (Stream<Path> walk = Files.walk(p)) {\n                List<Path> collect = walk.filter(f -> f.toString().endsWith(\"kmodule.xml\")).collect(Collectors.toList());\n                for (Path k : collect) {\n                    kieModules.add(KieModuleModelImpl.fromXML(k.toFile()));\n                }\n            } catch (Exception e) {\n                throw new MojoExecutionException(\"Failed executing AbstractDMNValidationAwareMojo while computing DMNProfile(s)\", e);\n            }\n        }\n        for (KieModuleModel kmm : kieModules) {\n            Properties ps = new Properties();\n            ps.putAll(kmm.getConfigurationProperties());\n            chainedProperties.addProperties(ps);\n        }\n        List<DMNProfile> dmnProfiles = new ArrayList<>();\n        dmnProfiles.addAll(DMNAssemblerService.getDefaultDMNProfiles(chainedProperties));\n        try {\n            Map<String, String> dmnProfileProperties = new HashMap<>();\n            chainedProperties.mapStartsWith(dmnProfileProperties, DMNAssemblerService.DMN_PROFILE_PREFIX, false);\n            for (Map.Entry<String, String> dmnProfileProperty : dmnProfileProperties.entrySet()) {\n                DMNProfile dmnProfile = (DMNProfile) classLoader.loadClass(dmnProfileProperty.getValue()).newInstance();\n                dmnProfiles.add(dmnProfile);\n            }\n        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) {\n            throw new MojoExecutionException(\"Failed executing AbstractDMNValidationAwareMojo while computing DMNProfile(s)\", e);\n        }\n        return dmnProfiles;\n    }\n}", "class_id": 0, "repo": "vigneshvarma/droolsjbpm-integration", "file": "kie-maven-plugin/src/main/java/org/kie/maven/plugin/AbstractDMNValidationAwareMojo.java", "last_update_at": "2020-10-05T17:12:11+00:00", "question_id": "871df602c1ff1b5a199e875e712f0a7e65ea02c8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class AbstractDMNValidationAwareMojo extends AbstractKieMojo {\n    @Parameter(required = true, defaultValue = \"${project.build.resources}\")\n    private List<Resource> resources;\n    @Parameter(property = \"validateDMN\", defaultValue = \"VALIDATE_SCHEMA,VALIDATE_MODEL,ANALYZE_DECISION_TABLE\")\n    private String validateDMN;\n    protected String getValidateDMN() {\n        return validateDMN;\n    }\n    protected void logValidationMessages(List<DMNMessage> validation,\n                                         Function<DMNMessage, String> prefixer,\n                                         Function<DMNMessage, String> computeMessage) {\n        for (DMNMessage msg : validation) {\n            Consumer<CharSequence> logFn = null;\n            switch (msg.getLevel()) {\n                case ERROR:\n                    logFn = getLog()::error;\n                    break;\n                case WARNING:\n                    logFn = getLog()::warn;\n                    break;\n                case INFO:\n                default:\n                    logFn = getLog()::info;\n                    break;\n            }\n            StringBuilder sb = new StringBuilder();\n            sb.append(prefixer.apply(msg));\n            sb.append(computeMessage.apply(msg));\n            logFn.accept(sb.toString());\n        }\n    }\n    public List<Validation> computeFlagsFromCSVString(String csvString) {\n        List<Validation> flags = new ArrayList<>();\n        boolean resetFlag = false;\n        for (String p : csvString.split(\",\")) {\n            try {\n                flags.add(Validation.valueOf(p));\n            } catch (IllegalArgumentException e) {\n                getLog().info(\"validateDMN configured with flag: '\" + p + \"' determines this Mojo will not be executed (reset all flags).\");\n                resetFlag = true;\n            }\n        }\n        if (resetFlag) {\n            flags.clear();\n        }\n        return flags;\n    }\n    protected boolean shallPerformDMNDTAnalysis() {\n        return computeFlagsFromCSVString(getValidateDMN()).contains(Validation.ANALYZE_DECISION_TABLE);\n    }\n    public void performDMNDTAnalysis(InternalKieModule kieModule) throws MojoExecutionException, MojoFailureException {\n        Collection<DMNModel> dmnModels = extractDMNModelsFromKieModule(kieModule);\n        getLog().info(\"Initializing DMN DT Validator...\");\n        InternalDMNDTAnalyser analyser = InternalDMNDTAnalyserFactory.newDMNDTAnalyser(computeDMNProfiles());\n        getLog().info(\"DMN DT Validator initialized.\");\n        for (DMNModel model : dmnModels) {\n            getLog().info(\"Analysing decision tables in DMN Model '\" + model.getName() + \"' ...\");\n            List<DTAnalysis> results = analyser.analyse(model, new HashSet<>(Arrays.asList(Validation.ANALYZE_DECISION_TABLE)));\n            if (results.isEmpty()) {\n                getLog().info(\" no decision tables found.\");\n            } else {\n                for (DTAnalysis r : results) {\n                    getLog().info(\" analysis for decision table '\" + r.nameOrIDOfTable() + \"':\");\n                    List<DMNMessage> messages = r.asDMNMessages();\n                    logValidationMessages(messages, (u) -> \"  \", DMNMessage::getMessage);\n                    if (messages.stream().anyMatch(m -> m.getLevel() == Level.ERROR)) {\n                        throw new MojoFailureException(\"There are DMN Validation Error(s).\");\n                    }\n                }\n            }\n        }\n    }\n    private Collection<DMNModel> extractDMNModelsFromKieModule(InternalKieModule kieModule) {\n        Collection<KiePackage> kpkgs = kieModule.getKieModuleModel().getKieBaseModels().keySet().stream()\n                                                .flatMap(name -> kieModule.getKnowledgePackagesForKieBase(name).stream())\n                                                .collect(Collectors.toList());\n        Set<DMNModel> models = new HashSet<>();\n        for (KiePackage kp : kpkgs) {\n            InternalKnowledgePackage ikpkg = (InternalKnowledgePackage) kp;\n            ResourceTypePackage<DMNModel> rtp = (ResourceTypePackage<DMNModel>) ikpkg.getResourceTypePackages().get(ResourceType.DMN);\n            if (rtp == null) {\n                continue;\n            }\n            for (DMNModel dmnModel : rtp) {\n                models.add(dmnModel);\n            }\n        }\n        Map<org.kie.api.io.Resource, DMNModel> removeDups = new HashMap<>();\n        for (DMNModel m : models) {\n            removeDups.put(m.getResource(), m);\n        }\n        return removeDups.values();\n    }\n    protected List<Path> resourcesPaths() {\n        List<Path> resourcesPaths = resources.stream().map(r -> new File(r.getDirectory()).toPath()).collect(Collectors.toList());\n        if (getLog().isDebugEnabled()) {\n            getLog().debug(\"resourcesPaths: \" + resourcesPaths.stream().map(Path::toString).collect(Collectors.joining(\",\\n\")));\n        }\n        return resourcesPaths;\n    }\n    protected List<DMNProfile> computeDMNProfiles() throws MojoExecutionException {\n        ClassLoader classLoader = ClassLoaderUtil.findDefaultClassLoader();\n        ChainedProperties chainedProperties = ChainedProperties.getChainedProperties(classLoader);\n        List<KieModuleModel> kieModules = new ArrayList<>();\n        for (Path p : resourcesPaths()) {\n            try (Stream<Path> walk = Files.walk(p)) {\n                List<Path> collect = walk.filter(f -> f.toString().endsWith(\"kmodule.xml\")).collect(Collectors.toList());\n                for (Path k : collect) {\n                    kieModules.add(KieModuleModelImpl.fromXML(k.toFile()));\n                }\n            } catch (Exception e) {\n                throw new MojoExecutionException(\"Failed executing AbstractDMNValidationAwareMojo while computing DMNProfile(s)\", e);\n            }\n        }\n        for (KieModuleModel kmm : kieModules) {\n            Properties ps = new Properties();\n            ps.putAll(kmm.getConfigurationProperties());\n            chainedProperties.addProperties(ps);\n        }\n        List<DMNProfile> dmnProfiles = new ArrayList<>();\n        dmnProfiles.addAll(DMNAssemblerService.getDefaultDMNProfiles(chainedProperties));\n        try {\n            Map<String, String> dmnProfileProperties = new HashMap<>();\n            chainedProperties.mapStartsWith(dmnProfileProperties, DMNAssemblerService.DMN_PROFILE_PREFIX, false);\n            for (Map.Entry<String, String> dmnProfileProperty : dmnProfileProperties.entrySet()) {\n                DMNProfile dmnProfile = (DMNProfile) classLoader.loadClass(dmnProfileProperty.getValue()).newInstance();\n                dmnProfiles.add(dmnProfile);\n            }\n        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) {\n            throw new MojoExecutionException(\"Failed executing AbstractDMNValidationAwareMojo while computing DMNProfile(s)\", e);\n        }\n        return dmnProfiles;\n    }\n"]]}
{"hexsha": "701d7cddb4139c5c4c4ff51c366e9ea5e8229c0a", "ext": "java", "lang": "Java", "content": "public class Block121 extends UIComponent {\n    private UISpan title = new UISpan();\n    private UIImage leftImage = new UIImage();\n    private UrlRecord leftUrl = new UrlRecord();\n    private UrlRecord rightUrl = new UrlRecord();\n    private UISpan rightText = new UISpan();\n\n    public Block121(UIComponent owner) {\n        super(owner);\n    }\n\n    @Override\n    public void output(HtmlWriter html) {\n        html.println(\"<!-- %s -->\", this.getClass().getName());\n        html.print(\"<header  class='block121'>\");\n        if (this.leftImage.getSrc() != null && !\"\".equals(this.leftImage.getSrc())) {\n            html.print(\"<a href='%s'  class='arrow-left'>\", this.leftUrl.getUrl());\n            this.leftImage.output(html);\n            html.print(\"</a>\");\n        }\n        html.print(\"<h1 class='title'>\");\n        this.title.output(html);\n        html.print(\"</h1>\");\n        if (this.rightText.getText() != null && !\"\".equals(this.rightText.getText())) {\n            html.print(\"<a href='%s' class='arrow-right'>\", this.rightUrl.getUrl());\n            this.rightText.output(html);\n            html.print(\"</a>\");\n        }\n        html.print(\"</header>\");\n    }\n\n    public UrlRecord getRightUrl() {\n        return rightUrl;\n    }\n\n    public UISpan getRightText() {\n        return rightText;\n    }\n\n    public UISpan getTitle() {\n        return title;\n    }\n\n    public UIImage getLeftImage() {\n        return this.leftImage;\n    }\n\n    public UrlRecord getLeftUrl() {\n        return leftUrl;\n    }\n\n}", "class_id": 0, "repo": "15218057878/summer-server-1", "file": "summer-ui/src/main/java/cn/cerc/ui/phone/Block121.java", "last_update_at": "2020-05-01T01:09:27+00:00", "question_id": "701d7cddb4139c5c4c4ff51c366e9ea5e8229c0a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Block121 extends UIComponent {\n    private UISpan title = new UISpan();\n    private UIImage leftImage = new UIImage();\n    private UrlRecord leftUrl = new UrlRecord();\n    private UrlRecord rightUrl = new UrlRecord();\n    private UISpan rightText = new UISpan();\n    public Block121(UIComponent owner) {\n        super(owner);\n    }\n    @Override\n    public void output(HtmlWriter html) {\n        html.println(\"<!-- %s -->\", this.getClass().getName());\n        html.print(\"<header  class='block121'>\");\n        if (this.leftImage.getSrc() != null && !\"\".equals(this.leftImage.getSrc())) {\n            html.print(\"<a href='%s'  class='arrow-left'>\", this.leftUrl.getUrl());\n            this.leftImage.output(html);\n            html.print(\"</a>\");\n        }\n        html.print(\"<h1 class='title'>\");\n        this.title.output(html);\n        html.print(\"</h1>\");\n        if (this.rightText.getText() != null && !\"\".equals(this.rightText.getText())) {\n            html.print(\"<a href='%s' class='arrow-right'>\", this.rightUrl.getUrl());\n            this.rightText.output(html);\n            html.print(\"</a>\");\n        }\n        html.print(\"</header>\");\n    }\n    public UrlRecord getRightUrl() {\n        return rightUrl;\n    }\n    public UISpan getRightText() {\n        return rightText;\n    }\n    public UISpan getTitle() {\n        return title;\n    }\n    public UIImage getLeftImage() {\n        return this.leftImage;\n    }\n    public UrlRecord getLeftUrl() {\n        return leftUrl;\n    }\n"]]}
{"hexsha": "178ce37da3dd338c29beea3fce8e185ac974c797", "ext": "java", "lang": "Java", "content": "public class ArrayRotation {\r\n\t\r\n\tpublic static void rotate(int[] arr, int d, int n) {\t\t\r\n\t\tif(d < 0) {\r\n\t\t\tSystem.out.println(\"Number of rotations cannot be less than 0\");\r\n\t\t}\r\n\t\t\r\n\t\tint i,j,k,temp;\r\n\t\tfor(i = 0; i<gcd(d,n); i++) {\r\n\t\t\ttemp = arr[i];\r\n\t\t\tj = i;\r\n\t\t\twhile(true) {\r\n\t\t\t\tk = j + d;\r\n\t\t\t\twhile(k >= n)\r\n\t\t\t\t\tk = k - n;\r\n\t\t\t\tif(k == i)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tarr[j] = arr[k];\r\n\t\t\t\tj = k;\r\n\t\t\t}\r\n\t\t\tarr[j] = temp;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int gcd(int i, int j) {\r\n\t\tif (j == 0)\r\n\t\t\treturn i;\r\n\t\telse\r\n\t\t\treturn gcd(j, i%j);\r\n\t}\r\n\t\r\n\tpublic static void printArray(int[] arr) {\r\n\t\tfor(int i = 0; i<arr.length; i++) {\r\n\t\t\tSystem.out.print(arr[i]+ \" \");\r\n\t\t}\t\t\t\r\n\t}\r\n\t\r\n\tpublic static void leftRotatebyOne(int arr[], int n)\r\n\t{\r\n\t   int temp = arr[0];\r\n\t   int i;\r\n\t   for(i = 0; i < n-1; i++)\r\n\t   arr[i] = arr[i+1];\r\n\t    \r\n\t   arr[i] = temp;\r\n\t}\r\n\t \r\n\t/*Function to left rotate arr[] of size n by d*/\r\n\tpublic static void leftRotate(int arr[], int d, int n)\r\n\t{\r\n\t    for (int i = 0; i < d; i++)\r\n\t    leftRotatebyOne(arr, n);\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t// TODO Auto-generated method stub\r\n\t\tint[] arr = {1,2,3,4,5,6,7,8,9};\r\n\t\trotate(arr, 201, 9);\r\n\t\tprintArray(arr);\r\n\t\tSystem.out.print(\"\\n=================\\n\");\r\n\t\tleftRotate(arr, 2, 9);\r\n\t\tprintArray(arr);\r\n\t}\r\n\r\n}", "class_id": 0, "repo": "onk3sh/JavaProblems", "file": "src/arrays/ArrayRotation.java", "last_update_at": "2020-05-06T12:19:23+00:00", "question_id": "178ce37da3dd338c29beea3fce8e185ac974c797", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ArrayRotation {\r\n\t\r\n\tpublic static void rotate(int[] arr, int d, int n) {\t\t\r\n\t\tif(d < 0) {\r\n\t\t\tSystem.out.println(\"Number of rotations cannot be less than 0\");\r\n\t\t}\r\n\t\t\r\n\t\tint i,j,k,temp;\r\n\t\tfor(i = 0; i<gcd(d,n); i++) {\r\n\t\t\ttemp = arr[i];\r\n\t\t\tj = i;\r\n\t\t\twhile(true) {\r\n\t\t\t\tk = j + d;\r\n\t\t\t\twhile(k >= n)\r\n\t\t\t\t\tk = k - n;\r\n\t\t\t\tif(k == i)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tarr[j] = arr[k];\r\n\t\t\t\tj = k;\r\n\t\t\t}\r\n\t\t\tarr[j] = temp;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int gcd(int i, int j) {\r\n\t\tif (j == 0)\r\n\t\t\treturn i;\r\n\t\telse\r\n\t\t\treturn gcd(j, i%j);\r\n\t}\r\n\t\r\n\tpublic static void printArray(int[] arr) {\r\n\t\tfor(int i = 0; i<arr.length; i++) {\r\n\t\t\tSystem.out.print(arr[i]+ \" \");\r\n\t\t}\t\t\t\r\n\t}\r\n\t\r\n\tpublic static void leftRotatebyOne(int arr[], int n)\r\n\t{\r\n\t   int temp = arr[0];\r\n\t   int i;\r\n\t   for(i = 0; i < n-1; i++)\r\n\t   arr[i] = arr[i+1];\r\n\t    \r\n\t   arr[i] = temp;\r\n\t}\r\n\t \r\n\t/*Function to left rotate arr[] of size n by d*/\r\n\tpublic static void leftRotate(int arr[], int d, int n)\r\n\t{\r\n\t    for (int i = 0; i < d; i++)\r\n\t    leftRotatebyOne(arr, n);\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t// TODO Auto-generated method stub\r\n\t\tint[] arr = {1,2,3,4,5,6,7,8,9};\r\n\t\trotate(arr, 201, 9);\r\n\t\tprintArray(arr);\r\n\t\tSystem.out.print(\"\\n=================\\n\");\r\n\t\tleftRotate(arr, 2, 9);\r\n\t\tprintArray(arr);\r\n\t}\r\n\r\n"]]}
{"hexsha": "5f639b1917ac0e6e9e1bdf8d1d8fb88e31bf9aa0", "ext": "java", "lang": "Java", "content": "@RestController\n@RequestMapping(\"/customer\")\npublic class CustomerController {\n\n    @Autowired\n    private CustomerService customerService;\n\n    @Autowired\n    private AddressService addressService;\n\n    @GetMapping(\"/search\")\n    public PageInfo<CustomerListOutDTO> search(CustomerSearchInDTO customerSearchInDTO,\n                                               @RequestParam(defaultValue = \"1\") Integer pageNum){\n        PageHelper.startPage(pageNum,5);\n        List<Customer> customers = customerService.search(customerSearchInDTO);\n        List<CustomerListOutDTO> customerListOutDTOS = customers.stream().map(customer -> {\n            CustomerListOutDTO customerListOutDTO = new CustomerListOutDTO();\n            customerListOutDTO.setCustomerId(customer.getCustomerId());\n            customerListOutDTO.setUsername(customer.getUsername());\n            customerListOutDTO.setRealName(customer.getRealName());\n            customerListOutDTO.setMobile(customer.getMobile());\n            customerListOutDTO.setEmail(customer.getEmail());\n            customerListOutDTO.setStatus(customer.getStatus());\n            customerListOutDTO.setCreateTimestamp(customer.getCreateTime().getTime());\n            return customerListOutDTO;\n        }).collect(Collectors.toList());\n        PageInfo<CustomerListOutDTO> pageInfo = new PageInfo<>(customerListOutDTOS);\n        return pageInfo;\n    }\n\n    @PostMapping(\"/create\")\n    public String  create(@RequestBody CustomerCreateInDTO customerCreateInDTO){\n        return null;\n    }\n\n    @GetMapping(\"/getCustomer\")\n    public CustomerShowOutDTO getCustomer(@RequestParam Integer customerId){\n        Customer customer = customerService.getById(customerId);\n        CustomerShowOutDTO customerShowOutDTO = new CustomerShowOutDTO();\n        customerShowOutDTO.setCustomerId(customerId);\n        customerShowOutDTO.setUsername(customer.getUsername());\n        customerShowOutDTO.setRealName(customer.getRealName());\n        customerShowOutDTO.setMobile(customer.getMobile());\n        customerShowOutDTO.setEmail(customer.getEmail());\n        customerShowOutDTO.setDefaultAddressId(customer.getDefaultAddressId());\n        customerShowOutDTO.setStatus(customer.getStatus());\n        customerShowOutDTO.setCreateTimestamp(customer.getCreateTime().getTime());\n        customerShowOutDTO.setNewsSubscribed(customer.getNewsSubscribed());\n        customerShowOutDTO.setRewordPoints(customer.getRewordPoints());\n        customerShowOutDTO.setAvatarUrl(customer.getAvatarUrl());\n\n        Address addressById = addressService.getById(customer.getDefaultAddressId());\n        if(addressById != null){\n            customerShowOutDTO.setDefaultAddress(addressById.getContent());\n        }\n\n\n        return customerShowOutDTO;\n    }\n\n    @PostMapping(\"/update\")\n    public void update(@RequestBody CustomerUpdateInDTO customerUpdateInDTO){\n\n    }\n\n    @PostMapping(\"/setStatus\")\n    public void setStatus(@RequestBody CustomerSetStatusInDTO customerSetStatusInDTO){\n        customerService.setStatus(customerSetStatusInDTO);\n    }\n\n}", "class_id": 0, "repo": "xu0521/xin", "file": "xl050224/src/main/java/com/xuxin/xl050224/controller/CustomerController.java", "last_update_at": "2020-02-26T07:35:13+00:00", "question_id": "5f639b1917ac0e6e9e1bdf8d1d8fb88e31bf9aa0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RestController\n@RequestMapping(\"/customer\")\npublic class CustomerController {\n    @Autowired\n    private CustomerService customerService;\n    @Autowired\n    private AddressService addressService;\n    @GetMapping(\"/search\")\n    public PageInfo<CustomerListOutDTO> search(CustomerSearchInDTO customerSearchInDTO,\n                                               @RequestParam(defaultValue = \"1\") Integer pageNum){\n        PageHelper.startPage(pageNum,5);\n        List<Customer> customers = customerService.search(customerSearchInDTO);\n        List<CustomerListOutDTO> customerListOutDTOS = customers.stream().map(customer -> {\n            CustomerListOutDTO customerListOutDTO = new CustomerListOutDTO();\n            customerListOutDTO.setCustomerId(customer.getCustomerId());\n            customerListOutDTO.setUsername(customer.getUsername());\n            customerListOutDTO.setRealName(customer.getRealName());\n            customerListOutDTO.setMobile(customer.getMobile());\n            customerListOutDTO.setEmail(customer.getEmail());\n            customerListOutDTO.setStatus(customer.getStatus());\n            customerListOutDTO.setCreateTimestamp(customer.getCreateTime().getTime());\n            return customerListOutDTO;\n        }).collect(Collectors.toList());\n        PageInfo<CustomerListOutDTO> pageInfo = new PageInfo<>(customerListOutDTOS);\n        return pageInfo;\n    }\n    @PostMapping(\"/create\")\n    public String  create(@RequestBody CustomerCreateInDTO customerCreateInDTO){\n        return null;\n    }\n    @GetMapping(\"/getCustomer\")\n    public CustomerShowOutDTO getCustomer(@RequestParam Integer customerId){\n        Customer customer = customerService.getById(customerId);\n        CustomerShowOutDTO customerShowOutDTO = new CustomerShowOutDTO();\n        customerShowOutDTO.setCustomerId(customerId);\n        customerShowOutDTO.setUsername(customer.getUsername());\n        customerShowOutDTO.setRealName(customer.getRealName());\n        customerShowOutDTO.setMobile(customer.getMobile());\n        customerShowOutDTO.setEmail(customer.getEmail());\n        customerShowOutDTO.setDefaultAddressId(customer.getDefaultAddressId());\n        customerShowOutDTO.setStatus(customer.getStatus());\n        customerShowOutDTO.setCreateTimestamp(customer.getCreateTime().getTime());\n        customerShowOutDTO.setNewsSubscribed(customer.getNewsSubscribed());\n        customerShowOutDTO.setRewordPoints(customer.getRewordPoints());\n        customerShowOutDTO.setAvatarUrl(customer.getAvatarUrl());\n        Address addressById = addressService.getById(customer.getDefaultAddressId());\n        if(addressById != null){\n            customerShowOutDTO.setDefaultAddress(addressById.getContent());\n        }\n        return customerShowOutDTO;\n    }\n    @PostMapping(\"/update\")\n    public void update(@RequestBody CustomerUpdateInDTO customerUpdateInDTO){\n    }\n    @PostMapping(\"/setStatus\")\n    public void setStatus(@RequestBody CustomerSetStatusInDTO customerSetStatusInDTO){\n        customerService.setStatus(customerSetStatusInDTO);\n    }\n"]]}
{"hexsha": "154c084c6e0d73897090274c46aa00b04a182ef3", "ext": "java", "lang": "Java", "content": "public class ScaleInTransformer implements ViewPager2.PageTransformer {\n\n    private float mMinScale = 0.85f;\n    private float DEFAULT_CENTER = 0.5f;\n\n    @Override\n    public void transformPage(@NonNull View page, float position) {\n        page.setElevation(-Math.abs(position));\n        int pageWidth = page.getWidth();\n        int pageHeight = page.getHeight();\n\n        page.setPivotX(pageWidth / 2);\n        page.setPivotY(pageHeight / 2);\n\n        if (position < -1) {\n            page.setScaleX(mMinScale);\n            page.setScaleY(mMinScale);\n            page.setPivotX(pageWidth);\n        } else if (position <= -1) {\n            if (position < 0) {\n                float scaleFactor = (1 + position) * (1 - mMinScale) + mMinScale;\n                page.setScaleX(scaleFactor);\n                page.setScaleY(scaleFactor);\n                page.setPivotX(pageWidth * (DEFAULT_CENTER + DEFAULT_CENTER * -position));\n            } else {\n                float scaleFactor = (1 - position) * (1 - mMinScale) + mMinScale;\n                page.setScaleX(scaleFactor);\n                page.setScaleY(scaleFactor);\n                page.setPivotX(pageWidth * ((1 - position) * DEFAULT_CENTER));\n            }\n        }else {\n            page.setPivotX(0f);\n            page.setScaleX(mMinScale);\n            page.setScaleY(mMinScale);\n        }\n    }\n}", "class_id": 0, "repo": "yxmFromTheMoon/MyGank", "file": "app/src/main/java/com/yxm/mygank/common/util/ScaleInTransformer.java", "last_update_at": "2020-05-28T00:51:14+00:00", "question_id": "154c084c6e0d73897090274c46aa00b04a182ef3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ScaleInTransformer implements ViewPager2.PageTransformer {\n    private float mMinScale = 0.85f;\n    private float DEFAULT_CENTER = 0.5f;\n    @Override\n    public void transformPage(@NonNull View page, float position) {\n        page.setElevation(-Math.abs(position));\n        int pageWidth = page.getWidth();\n        int pageHeight = page.getHeight();\n        page.setPivotX(pageWidth / 2);\n        page.setPivotY(pageHeight / 2);\n        if (position < -1) {\n            page.setScaleX(mMinScale);\n            page.setScaleY(mMinScale);\n            page.setPivotX(pageWidth);\n        } else if (position <= -1) {\n            if (position < 0) {\n                float scaleFactor = (1 + position) * (1 - mMinScale) + mMinScale;\n                page.setScaleX(scaleFactor);\n                page.setScaleY(scaleFactor);\n                page.setPivotX(pageWidth * (DEFAULT_CENTER + DEFAULT_CENTER * -position));\n            } else {\n                float scaleFactor = (1 - position) * (1 - mMinScale) + mMinScale;\n                page.setScaleX(scaleFactor);\n                page.setScaleY(scaleFactor);\n                page.setPivotX(pageWidth * ((1 - position) * DEFAULT_CENTER));\n            }\n        }else {\n            page.setPivotX(0f);\n            page.setScaleX(mMinScale);\n            page.setScaleY(mMinScale);\n        }\n    }\n"]]}
{"hexsha": "f9165640edec4cd3855e4993c37ad1e68b971d7b", "ext": "java", "lang": "Java", "content": "public class BlueprintsMap {\n    private static BlueprintsMap instance;\n    public final HashMap<String, Blueprint> blueprints;\n    private Json json;\n\n    private BlueprintsMap() {\n        blueprints = new HashMap<>();\n        json = new Json();\n        json.setOutputType(JsonWriter.OutputType.json);\n        loadBlueprints();\n    }\n\n    public static BlueprintsMap getInstance() {\n        if (instance == null)\n            instance = new BlueprintsMap();\n        return instance;\n    }\n\n    private void loadBlueprints() {\n        Logger.LOADING.log(\"blueprints\");\n        ArrayList<RawBlueprint> elements = json.fromJson(ArrayList.class, RawBlueprint.class, FileUtil.get(FileUtil.BLUEPRINTS_PATH));\n        BlueprintProcessor processor = new BlueprintProcessor();\n        for (RawBlueprint rawBlueprint : elements) {\n            blueprints.put(rawBlueprint.name, processor.processRawBlueprint(rawBlueprint));\n        }\n        Logger.LOADING.log(blueprints.keySet().size() + \" loaded from \" + FileUtil.BLUEPRINTS_PATH);\n    }\n\n    public Blueprint getBlueprint(String name) {\n        return blueprints.get(name);\n    }\n}", "class_id": 0, "repo": "Sorgas/Tearfall", "file": "core/src/stonering/enums/buildings/blueprint/BlueprintsMap.java", "last_update_at": "2020-04-13T17:32:09+00:00", "question_id": "f9165640edec4cd3855e4993c37ad1e68b971d7b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BlueprintsMap {\n    private static BlueprintsMap instance;\n    public final HashMap<String, Blueprint> blueprints;\n    private Json json;\n    private BlueprintsMap() {\n        blueprints = new HashMap<>();\n        json = new Json();\n        json.setOutputType(JsonWriter.OutputType.json);\n        loadBlueprints();\n    }\n    public static BlueprintsMap getInstance() {\n        if (instance == null)\n            instance = new BlueprintsMap();\n        return instance;\n    }\n    private void loadBlueprints() {\n        Logger.LOADING.log(\"blueprints\");\n        ArrayList<RawBlueprint> elements = json.fromJson(ArrayList.class, RawBlueprint.class, FileUtil.get(FileUtil.BLUEPRINTS_PATH));\n        BlueprintProcessor processor = new BlueprintProcessor();\n        for (RawBlueprint rawBlueprint : elements) {\n            blueprints.put(rawBlueprint.name, processor.processRawBlueprint(rawBlueprint));\n        }\n        Logger.LOADING.log(blueprints.keySet().size() + \" loaded from \" + FileUtil.BLUEPRINTS_PATH);\n    }\n    public Blueprint getBlueprint(String name) {\n        return blueprints.get(name);\n    }\n"]]}
{"hexsha": "5711941de5e2c64e839760ce0516912ae3a5e68c", "ext": "java", "lang": "Java", "content": "public class Optimizer {\n\n    private final List<OptimizerPass> optimizationList = new ArrayList<>();\n    protected List<CodeSequence> codeSequenceList = new ArrayList<>();\n\n    protected boolean doDumping = false;\n    protected String dumpingPath;\n\n    protected Set<Obj> globalVariables;\n\n    protected StringBuilder exceptionToThrow = new StringBuilder();\n\n    public Optimizer(List<List<Quadruple>> code, List<Obj> functions, Set<Obj> globalVariables) {\n        int i = 0;\n\n        this.globalVariables = globalVariables;\n\n        for (List<Quadruple> quadrupleList : code) {\n            CodeSequence sequence = new CodeSequence();\n\n            sequence.function = functions.get(i);\n            sequence.labelIndices = BasicBlock.generateMapOfLabels(quadrupleList);\n            sequence.basicBlocks = BasicBlock.extractBasicBlocksFromSequence(sequence.function, quadrupleList, sequence.labelIndices);\n            assert sequence.basicBlocks != null;\n            sequence.entryBlock = sequence.basicBlocks.stream().filter(BasicBlock::isEntryBlock).findFirst().orElseThrow();\n\n            long numberOfBlocksWithoutPredecessors = sequence.basicBlocks.stream().filter(p -> p.predecessors.size() == 0).count();\n            if (numberOfBlocksWithoutPredecessors > 1)\n                exceptionToThrow.append(\"WARNING: At least one unreachable portion of code \" +\n                        \"has been detected in function '\" + sequence.function.getName() + \"'.\").append(System.lineSeparator());\n\n            // update ENTER instruction and assign address to all variables\n            Quadruple enterInstruction = sequence.entryBlock.instructions.get(1);\n\n            Collection<Obj> allVariables = new HashSet<>();\n            for (BasicBlock b : sequence.basicBlocks) {\n                allVariables.addAll(b.extractAllVariables());\n                allVariables.addAll(new HashSet<>(sequence.function.getLocalSymbols()));\n            }\n\n            int oldAllocationValue = ((QuadrupleIntegerConst) enterInstruction.getArg1()).getValue();\n\n            //System.out.println(\"Variables for \" + sequence.function.getName());\n            int lastSize = giveAddressToTemps(allVariables, oldAllocationValue);\n\n            enterInstruction.setArg1(new QuadrupleIntegerConst(SystemV_ABI.alignTo16(lastSize)));\n\n            codeSequenceList.add(sequence);\n            i++;\n        }\n    }\n\n    public StringBuilder getExceptionToThrow() {\n        return exceptionToThrow;\n    }\n\n    public static int giveAddressToAll(Collection<Obj> variables, int startValue) {\n        for (Obj obj : variables) {\n            int lastTaken = startValue;\n            if (SystemV_ABI.alignTo16(lastTaken) - lastTaken < SystemV_ABI.getX64VariableSize(obj.getType()))\n                lastTaken = SystemV_ABI.alignTo16(lastTaken);\n            int thisVarAddress = lastTaken + SystemV_ABI.getX64VariableSize(obj.getType());\n            obj.setAdr(thisVarAddress);\n            startValue = thisVarAddress;\n\n        }\n\n        return startValue;\n    }\n\n    public static int giveAddressToTemps(Collection<Obj> variables, int startValue) {\n        for (Obj obj : variables) {\n            if (((obj.tempVar || obj.getName().startsWith(Config.prefix_phi)) || (obj.parameter && !obj.stackParameter)) && obj.getKind() != Obj.Con) {\n                int lastTaken = startValue;\n                if (SystemV_ABI.alignTo16(lastTaken) - lastTaken < SystemV_ABI.getX64VariableSize(obj.getType()))\n                    lastTaken = SystemV_ABI.alignTo16(lastTaken);\n                int thisVarAddress = lastTaken + SystemV_ABI.getX64VariableSize(obj.getType());\n                obj.setAdr(thisVarAddress);\n                startValue = thisVarAddress;\n            }\n        }\n\n        return startValue;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder stringBuilder = new StringBuilder();\n\n        for (CodeSequence codeSequence : codeSequenceList) {\n            if (codeSequence.inlined)\n                continue;\n\n            stringBuilder.append(\"-----------------------------------------------------------------------------------------\\n\");\n\n            for (BasicBlock basicBlock : Optimizer.reassembleBasicBlocks(codeSequence.basicBlocks))\n                for (Quadruple q : basicBlock.instructions)\n                    stringBuilder.append(q).append(System.lineSeparator());\n\n            stringBuilder.append(\"-----------------------------------------------------------------------------------------\\n\");\n        }\n\n        return stringBuilder.toString();\n    }\n\n    protected void addOptimizationPass(OptimizerPass optimizerPass) {\n        optimizationList.add(optimizerPass);\n    }\n\n    public void executeOptimizations() {\n        assert globalVariables != null;\n\n        // non-SSA optimizations\n        for (CodeSequence sequence : codeSequenceList) {\n            // DO NOT REMOVE THIS LINE\n            optimizationList.clear();\n\n            // NOTE: do not comment the following line -> unreachable code elimination\n            (new CFGCleaner(sequence)).optimize();\n\n            internalDump(sequence, dumpingPath, \"1_pre_non_ssa_opt_\");\n\n            addOptimizationPass(new ValueNumbering(sequence));\n            addOptimizationPass(new FunctionInlining(sequence, codeSequenceList));\n            addOptimizationPass(new CFGCleaner(sequence));\n\n            for (OptimizerPass pass : optimizationList) {\n                pass.optimize();\n                pass.finalizePass();\n            }\n\n            internalDump(sequence, dumpingPath, \"2_post_non_ssa_opt_\");\n        }\n\n        // SSA optimizations\n        for (CodeSequence sequence : codeSequenceList) {\n            if (sequence.inlined)\n                continue;\n\n            sequence.dominanceAnalyzer = new DominanceAnalyzer(sequence);\n            SSAConverter ssaConverter = new SSAConverter(sequence.dominanceAnalyzer);\n\n            // DO NOT REMOVE THIS LINE\n            optimizationList.clear();\n\n            ssaConverter.doPhiPlacement();\n            ssaConverter.renameVariables();\n\n            internalDump(sequence, dumpingPath, \"3_pre_ssa_opt_\");\n\n            addOptimizationPass(new UninitializedVariableDetection(sequence, globalVariables));\n            addOptimizationPass(new LoopInvariantCodeMotion(sequence));\n            addOptimizationPass(new CFGCleaner(sequence));\n            addOptimizationPass(new DeadCodeElimination(sequence)); // always call CFGCleaner after DCE\n            addOptimizationPass(new CFGCleaner(sequence));\n            for (OptimizerPass pass : optimizationList) {\n                try {\n                    pass.optimize();\n                    pass.finalizePass();\n                } catch (UninitializedVariableException ex) {\n                    System.err.println(ex.getMessage());\n                }\n            }\n\n            internalDump(sequence, dumpingPath, \"4_post_ssa_opt_\");\n\n            // eliminating SSA from code\n            ssaConverter.toNormalForm();\n\n            internalDump(sequence, dumpingPath, \"5_final_\");\n        }\n    }\n\n    public List<CodeSequence> getOptimizationOutput() {\n        return codeSequenceList;\n    }\n\n    public static List<BasicBlock> reassembleBasicBlocks(List<BasicBlock> cfg) {\n        /*List<BasicBlock> result = new ArrayList<>();\n\n        Stack<BasicBlock> stack = new Stack<>();\n        BasicBlock currentBlock = cfg.stream().filter(BasicBlock::isEntryBlock).collect(Collectors.toList()).get(0);\n        // current block is the entry block\n\n        int index = 0;\n        while (index < cfg.size()) {\n            if (cfg.size() == 1 || currentBlock.successor.size() == 0)\n                result.add(currentBlock);\n            else if (currentBlock.successor.size() == 1) {\n                Quadruple lastInstruction = currentBlock.instructions.get(currentBlock.instructions.size() - 1);\n\n                result.add(currentBlock);\n                if (lastInstruction.getInstruction() == IRInstruction.JMP)\n                    currentBlock = stack.pop();\n                else\n                    currentBlock = currentBlock.successor.get(0);\n            } else if (currentBlock.successor.size() == 2) {\n                Quadruple lastInstruction = currentBlock.instructions.get(currentBlock.instructions.size() - 1);\n\n                QuadrupleLabel jumpDestination = (QuadrupleLabel) lastInstruction.getResult();\n\n                BasicBlock successor1 = currentBlock.successor.get(0);\n                BasicBlock successor2 = currentBlock.successor.get(1);\n\n                BasicBlock addToStack = successor2;\n                for (int i = 0; i < successor1.instructions.size(); i++) {\n                    Quadruple q = successor1.instructions.get(i);\n                    if (q.getInstruction() == IRInstruction.GEN_LABEL) {\n                        if (((QuadrupleLabel) q.getArg1()).getLabelName().equals(jumpDestination.getLabelName())) {\n                            addToStack = successor1;\n                            break;\n                        }\n                    }\n                }\n\n                if (stack.isEmpty() || stack.peek() != addToStack)\n                    stack.push(addToStack);\n                result.add(currentBlock);\n                currentBlock = (addToStack == successor1 ? successor2 : successor1);\n            } else\n                throw new RuntimeException(\"Basic block cannot have more than two successors.\");\n\n            // solution for IF without ELSE\n            if (!stack.isEmpty() && stack.peek() == currentBlock)\n                stack.pop();\n\n            index++;\n        }\n\n        assert result.size() == result.stream().distinct().count();*/\n\n        return cfg;\n    }\n\n    private void internalDump(CodeSequence sequence, String path, String prefix) {\n        if (!doDumping)\n            return;\n\n        if (sequence.dominanceAnalyzer == null)\n            sequence.dominanceAnalyzer = new DominanceAnalyzer(sequence);\n\n        DominanceAnalyzer.dumpCFG(path + prefix + \"cfg_\" + sequence.function + \".dot\",\n                path + prefix + \"rcfg_\" + sequence.function + \".dot\",\n                sequence.dominanceAnalyzer.getBasicBlocks());\n        DominanceAnalyzer.dumpDominatorTree(path + prefix + \"dtree_\" + sequence.function + \".dot\",\n                sequence.dominanceAnalyzer.getImmediateDominators());\n        DominanceAnalyzer.dumpDominatorTree(path + prefix + \"rdomtree_\" + sequence.function + \".dot\",\n                sequence.dominanceAnalyzer.getReverseImmediateDominators());\n    }\n\n    public void setDumpFlag(String dumpingPath) {\n        this.doDumping = true;\n        this.dumpingPath = dumpingPath;\n    }\n}", "class_id": 0, "repo": "cvetkovic/microjava_x64", "file": "src/cvetkovic/optimizer/Optimizer.java", "last_update_at": "2020-07-12T11:03:59+00:00", "question_id": "5711941de5e2c64e839760ce0516912ae3a5e68c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Optimizer {\n    private final List<OptimizerPass> optimizationList = new ArrayList<>();\n    protected List<CodeSequence> codeSequenceList = new ArrayList<>();\n    protected boolean doDumping = false;\n    protected String dumpingPath;\n    protected Set<Obj> globalVariables;\n    protected StringBuilder exceptionToThrow = new StringBuilder();\n    public Optimizer(List<List<Quadruple>> code, List<Obj> functions, Set<Obj> globalVariables) {\n        int i = 0;\n        this.globalVariables = globalVariables;\n        for (List<Quadruple> quadrupleList : code) {\n            CodeSequence sequence = new CodeSequence();\n            sequence.function = functions.get(i);\n            sequence.labelIndices = BasicBlock.generateMapOfLabels(quadrupleList);\n            sequence.basicBlocks = BasicBlock.extractBasicBlocksFromSequence(sequence.function, quadrupleList, sequence.labelIndices);\n            assert sequence.basicBlocks != null;\n            sequence.entryBlock = sequence.basicBlocks.stream().filter(BasicBlock::isEntryBlock).findFirst().orElseThrow();\n            long numberOfBlocksWithoutPredecessors = sequence.basicBlocks.stream().filter(p -> p.predecessors.size() == 0).count();\n            if (numberOfBlocksWithoutPredecessors > 1)\n                exceptionToThrow.append(\"WARNING: At least one unreachable portion of code \" +\n                        \"has been detected in function '\" + sequence.function.getName() + \"'.\").append(System.lineSeparator());\n            // update ENTER instruction and assign address to all variables\n            Quadruple enterInstruction = sequence.entryBlock.instructions.get(1);\n            Collection<Obj> allVariables = new HashSet<>();\n            for (BasicBlock b : sequence.basicBlocks) {\n                allVariables.addAll(b.extractAllVariables());\n                allVariables.addAll(new HashSet<>(sequence.function.getLocalSymbols()));\n            }\n            int oldAllocationValue = ((QuadrupleIntegerConst) enterInstruction.getArg1()).getValue();\n            //System.out.println(\"Variables for \" + sequence.function.getName());\n            int lastSize = giveAddressToTemps(allVariables, oldAllocationValue);\n            enterInstruction.setArg1(new QuadrupleIntegerConst(SystemV_ABI.alignTo16(lastSize)));\n            codeSequenceList.add(sequence);\n            i++;\n        }\n    }\n    public StringBuilder getExceptionToThrow() {\n        return exceptionToThrow;\n    }\n    public static int giveAddressToAll(Collection<Obj> variables, int startValue) {\n        for (Obj obj : variables) {\n            int lastTaken = startValue;\n            if (SystemV_ABI.alignTo16(lastTaken) - lastTaken < SystemV_ABI.getX64VariableSize(obj.getType()))\n                lastTaken = SystemV_ABI.alignTo16(lastTaken);\n            int thisVarAddress = lastTaken + SystemV_ABI.getX64VariableSize(obj.getType());\n            obj.setAdr(thisVarAddress);\n            startValue = thisVarAddress;\n        }\n        return startValue;\n    }\n    public static int giveAddressToTemps(Collection<Obj> variables, int startValue) {\n        for (Obj obj : variables) {\n            if (((obj.tempVar || obj.getName().startsWith(Config.prefix_phi)) || (obj.parameter && !obj.stackParameter)) && obj.getKind() != Obj.Con) {\n                int lastTaken = startValue;\n                if (SystemV_ABI.alignTo16(lastTaken) - lastTaken < SystemV_ABI.getX64VariableSize(obj.getType()))\n                    lastTaken = SystemV_ABI.alignTo16(lastTaken);\n                int thisVarAddress = lastTaken + SystemV_ABI.getX64VariableSize(obj.getType());\n                obj.setAdr(thisVarAddress);\n                startValue = thisVarAddress;\n            }\n        }\n        return startValue;\n    }\n    @Override\n    public String toString() {\n        StringBuilder stringBuilder = new StringBuilder();\n        for (CodeSequence codeSequence : codeSequenceList) {\n            if (codeSequence.inlined)\n                continue;\n            stringBuilder.append(\"-----------------------------------------------------------------------------------------\\n\");\n            for (BasicBlock basicBlock : Optimizer.reassembleBasicBlocks(codeSequence.basicBlocks))\n                for (Quadruple q : basicBlock.instructions)\n                    stringBuilder.append(q).append(System.lineSeparator());\n            stringBuilder.append(\"-----------------------------------------------------------------------------------------\\n\");\n        }\n        return stringBuilder.toString();\n    }\n    protected void addOptimizationPass(OptimizerPass optimizerPass) {\n        optimizationList.add(optimizerPass);\n    }\n    public void executeOptimizations() {\n        assert globalVariables != null;\n        // non-SSA optimizations\n        for (CodeSequence sequence : codeSequenceList) {\n            // DO NOT REMOVE THIS LINE\n            optimizationList.clear();\n            // NOTE: do not comment the following line -> unreachable code elimination\n            (new CFGCleaner(sequence)).optimize();\n            internalDump(sequence, dumpingPath, \"1_pre_non_ssa_opt_\");\n            addOptimizationPass(new ValueNumbering(sequence));\n            addOptimizationPass(new FunctionInlining(sequence, codeSequenceList));\n            addOptimizationPass(new CFGCleaner(sequence));\n            for (OptimizerPass pass : optimizationList) {\n                pass.optimize();\n                pass.finalizePass();\n            }\n            internalDump(sequence, dumpingPath, \"2_post_non_ssa_opt_\");\n        }\n        // SSA optimizations\n        for (CodeSequence sequence : codeSequenceList) {\n            if (sequence.inlined)\n                continue;\n            sequence.dominanceAnalyzer = new DominanceAnalyzer(sequence);\n            SSAConverter ssaConverter = new SSAConverter(sequence.dominanceAnalyzer);\n            // DO NOT REMOVE THIS LINE\n            optimizationList.clear();\n            ssaConverter.doPhiPlacement();\n            ssaConverter.renameVariables();\n            internalDump(sequence, dumpingPath, \"3_pre_ssa_opt_\");\n            addOptimizationPass(new UninitializedVariableDetection(sequence, globalVariables));\n            addOptimizationPass(new LoopInvariantCodeMotion(sequence));\n            addOptimizationPass(new CFGCleaner(sequence));\n            addOptimizationPass(new DeadCodeElimination(sequence)); // always call CFGCleaner after DCE\n            addOptimizationPass(new CFGCleaner(sequence));\n            for (OptimizerPass pass : optimizationList) {\n                try {\n                    pass.optimize();\n                    pass.finalizePass();\n                } catch (UninitializedVariableException ex) {\n                    System.err.println(ex.getMessage());\n                }\n            }\n            internalDump(sequence, dumpingPath, \"4_post_ssa_opt_\");\n            // eliminating SSA from code\n            ssaConverter.toNormalForm();\n            internalDump(sequence, dumpingPath, \"5_final_\");\n        }\n    }\n    public List<CodeSequence> getOptimizationOutput() {\n        return codeSequenceList;\n    }\n    public static List<BasicBlock> reassembleBasicBlocks(List<BasicBlock> cfg) {\n        /*List<BasicBlock> result = new ArrayList<>();\n        Stack<BasicBlock> stack = new Stack<>();\n        BasicBlock currentBlock = cfg.stream().filter(BasicBlock::isEntryBlock).collect(Collectors.toList()).get(0);\n        // current block is the entry block\n        int index = 0;\n        while (index < cfg.size()) {\n            if (cfg.size() == 1 || currentBlock.successor.size() == 0)\n                result.add(currentBlock);\n            else if (currentBlock.successor.size() == 1) {\n                Quadruple lastInstruction = currentBlock.instructions.get(currentBlock.instructions.size() - 1);\n                result.add(currentBlock);\n                if (lastInstruction.getInstruction() == IRInstruction.JMP)\n                    currentBlock = stack.pop();\n                else\n                    currentBlock = currentBlock.successor.get(0);\n            } else if (currentBlock.successor.size() == 2) {\n                Quadruple lastInstruction = currentBlock.instructions.get(currentBlock.instructions.size() - 1);\n                QuadrupleLabel jumpDestination = (QuadrupleLabel) lastInstruction.getResult();\n                BasicBlock successor1 = currentBlock.successor.get(0);\n                BasicBlock successor2 = currentBlock.successor.get(1);\n                BasicBlock addToStack = successor2;\n                for (int i = 0; i < successor1.instructions.size(); i++) {\n                    Quadruple q = successor1.instructions.get(i);\n                    if (q.getInstruction() == IRInstruction.GEN_LABEL) {\n                        if (((QuadrupleLabel) q.getArg1()).getLabelName().equals(jumpDestination.getLabelName())) {\n                            addToStack = successor1;\n                            break;\n                        }\n                    }\n                }\n                if (stack.isEmpty() || stack.peek() != addToStack)\n                    stack.push(addToStack);\n                result.add(currentBlock);\n                currentBlock = (addToStack == successor1 ? successor2 : successor1);\n            } else\n                throw new RuntimeException(\"Basic block cannot have more than two successors.\");\n            // solution for IF without ELSE\n            if (!stack.isEmpty() && stack.peek() == currentBlock)\n                stack.pop();\n            index++;\n        }\n        assert result.size() == result.stream().distinct().count();*/\n        return cfg;\n    }\n    private void internalDump(CodeSequence sequence, String path, String prefix) {\n        if (!doDumping)\n            return;\n        if (sequence.dominanceAnalyzer == null)\n            sequence.dominanceAnalyzer = new DominanceAnalyzer(sequence);\n        DominanceAnalyzer.dumpCFG(path + prefix + \"cfg_\" + sequence.function + \".dot\",\n                path + prefix + \"rcfg_\" + sequence.function + \".dot\",\n                sequence.dominanceAnalyzer.getBasicBlocks());\n        DominanceAnalyzer.dumpDominatorTree(path + prefix + \"dtree_\" + sequence.function + \".dot\",\n                sequence.dominanceAnalyzer.getImmediateDominators());\n        DominanceAnalyzer.dumpDominatorTree(path + prefix + \"rdomtree_\" + sequence.function + \".dot\",\n                sequence.dominanceAnalyzer.getReverseImmediateDominators());\n    }\n    public void setDumpFlag(String dumpingPath) {\n        this.doDumping = true;\n        this.dumpingPath = dumpingPath;\n    }\n"]]}
{"hexsha": "4f0d5c5849a723cc29ca59c2d2a24b223dae997b", "ext": "java", "lang": "Java", "content": "public final class Db {\n\n    private static final JdbcConnectionPool cp;\n    private static volatile int maxActiveConnections;\n\n    private static final ThreadLocal<DbConnection> localConnection = new ThreadLocal<>();\n    private static final ThreadLocal<Map<String,Map<DbKey,Object>>> transactionCaches = new ThreadLocal<>();\n    private static final ThreadLocal<Map<String,Map<DbKey,Object>>> transactionBatches = new ThreadLocal<>();\n\n    private static final class DbConnection extends FilteredConnection {\n\n        private DbConnection(Connection con) {\n            super(con);\n        }\n\n        @Override\n        public void setAutoCommit(boolean autoCommit) throws SQLException {\n            throw new UnsupportedOperationException(\"Use Db.beginTransaction() to start a new transaction\");\n        }\n\n        @Override\n        public void commit() throws SQLException {\n            if (localConnection.get() == null) {\n                super.commit();\n            } else if (! this.equals(localConnection.get())) {\n                throw new IllegalStateException(\"Previous connection not committed\");\n            } else {\n                throw new UnsupportedOperationException(\"Use Db.commitTransaction() to commit the transaction\");\n            }\n        }\n\n        private void doCommit() throws SQLException {\n            super.commit();\n        }\n\n        @Override\n        public void rollback() throws SQLException {\n            if (localConnection.get() == null) {\n                super.rollback();\n            } else if (! this.equals(localConnection.get())) {\n                throw new IllegalStateException(\"Previous connection not committed\");\n            } else {\n                throw new UnsupportedOperationException(\"Use Db.rollbackTransaction() to rollback the transaction\");\n            }\n        }\n\n        private void doRollback() throws SQLException {\n            super.rollback();\n        }\n\n        @Override\n        public void close() throws SQLException {\n            if (localConnection.get() == null) {\n                super.close();\n            } else if (! this.equals(localConnection.get())) {\n                throw new IllegalStateException(\"Previous connection not committed\");\n            }\n        }\n\n    }\n\n    public static void init() {}\n\n    static {\n        long maxCacheSize = Nxt.getIntProperty(\"nxt.dbCacheKB\");\n        if (maxCacheSize == 0) {\n        \tmaxCacheSize = Math.min(256, Math.max(16, (Runtime.getRuntime().maxMemory() / (1024 * 1024) - 128)/2)) * 1024;\n        }\n        String dbUrl = Constants.isTestnet ? Nxt.getStringProperty(\"nxt.testDbUrl\") : Nxt.getStringProperty(\"nxt.dbUrl\");\n        if (! dbUrl.contains(\"CACHE_SIZE=\")) {\n            dbUrl += \";CACHE_SIZE=\" + maxCacheSize;\n        }\n\t// Replace old DB-Url if needed:\n\tif ( dbUrl.startsWith(\"jdbc:h2:ATM_db\")) {\n\t    dbUrl = \"jdbc:h2:./ATM_db\" + dbUrl.substring(16);\n\t    Logger.logMessage(dbUrl);\n\t}\n\n        Logger.logDebugMessage(\"Database jdbc url set to: \" + dbUrl);\n        cp = JdbcConnectionPool.create(dbUrl, \"sa\", \"sa\");\n        cp.setMaxConnections(Nxt.getIntProperty(\"nxt.maxDbConnections\"));\n        cp.setLoginTimeout(Nxt.getIntProperty(\"nxt.dbLoginTimeout\"));\n        int defaultLockTimeout = Nxt.getIntProperty(\"nxt.dbDefaultLockTimeout\") * 1000;\n        try (Connection con = cp.getConnection();\n             Statement stmt = con.createStatement()) {\n            stmt.executeUpdate(\"SET DEFAULT_LOCK_TIMEOUT \" + defaultLockTimeout);\n        } catch (SQLException e) {\n            throw new RuntimeException(e.toString(), e);\n        }\n    }\n    \n    public static void analyzeTables() {\n        try (Connection con = cp.getConnection();\n             Statement stmt = con.createStatement()) {\n            stmt.execute(\"ANALYZE SAMPLE_SIZE 0\");\n        } catch (SQLException e) {\n            throw new RuntimeException(e.toString(), e);\n        }\n    }\n\n    public static void shutdown() {\n        try {\n            Connection con = cp.getConnection();\n            Statement stmt = con.createStatement();\n            stmt.execute(\"SHUTDOWN COMPACT\");\n            Logger.logShutdownMessage(\"Database shutdown completed\");\n        } catch (SQLException e) {\n            Logger.logShutdownMessage(e.toString(), e);\n        }\n    }\n\n    private static Connection getPooledConnection() throws SQLException {\n        Connection con = cp.getConnection();\n        int activeConnections = cp.getActiveConnections();\n        if (activeConnections > maxActiveConnections) {\n            maxActiveConnections = activeConnections;\n            Logger.logDebugMessage(\"Database connection pool current size: \" + activeConnections);\n        }\n        return con;\n    }\n\n    public static Connection getConnection() throws SQLException {\n        Connection con = localConnection.get();\n        if (con != null) {\n            return con;\n        }\n        con = getPooledConnection();\n        con.setAutoCommit(true);\n        return new DbConnection(con);\n    }\n\n    static Map<DbKey,Object> getCache(String tableName) {\n        if (!isInTransaction()) {\n            throw new IllegalStateException(\"Not in transaction\");\n        }\n        Map<DbKey,Object> cacheMap = transactionCaches.get().get(tableName);\n        if (cacheMap == null) {\n            cacheMap = new HashMap<>();\n            transactionCaches.get().put(tableName, cacheMap);\n        }\n        return cacheMap;\n    }\n\n    static Map<DbKey,Object> getBatch(String tableName) {\n        if(!isInTransaction()) {\n            throw new IllegalStateException(\"Not in transaction\");\n        }\n        Map<DbKey,Object> batchMap = transactionBatches.get().get(tableName);\n        if(batchMap == null) {\n            batchMap = new HashMap<>();\n            transactionBatches.get().put(tableName, batchMap);\n        }\n        return batchMap;\n    }\n\n    public static boolean isInTransaction() {\n        return localConnection.get() != null;\n    }\n\n    public static Connection beginTransaction() {\n        if (localConnection.get() != null) {\n            throw new IllegalStateException(\"Transaction already in progress\");\n        }\n        try {\n            Connection con = getPooledConnection();\n            con.setAutoCommit(false);\n            con = new DbConnection(con);\n            localConnection.set((DbConnection)con);\n            transactionCaches.set(new HashMap<String, Map<DbKey, Object>>());\n            transactionBatches.set(new HashMap<String, Map<DbKey, Object>>());\n            return con;\n        } catch (SQLException e) {\n            throw new RuntimeException(e.toString(), e);\n        }\n    }\n\n    public static void commitTransaction() {\n        DbConnection con = localConnection.get();\n        if (con == null) {\n            throw new IllegalStateException(\"Not in transaction\");\n        }\n        try {\n            con.doCommit();\n        } catch (SQLException e) {\n            throw new RuntimeException(e.toString(), e);\n        }\n    }\n\n    public static void rollbackTransaction() {\n        DbConnection con = localConnection.get();\n        if (con == null) {\n            throw new IllegalStateException(\"Not in transaction\");\n        }\n        try {\n            con.doRollback();\n        } catch (SQLException e) {\n            throw new RuntimeException(e.toString(), e);\n        }\n        transactionCaches.get().clear();\n        transactionBatches.get().clear();\n    }\n\n    public static void endTransaction() {\n        Connection con = localConnection.get();\n        if (con == null) {\n            throw new IllegalStateException(\"Not in transaction\");\n        }\n        localConnection.set(null);\n        transactionCaches.get().clear();\n        transactionCaches.set(null);\n        transactionBatches.get().clear();\n        transactionBatches.set(null);\n        DbUtils.close(con);\n    }\n\n    private Db() {} // never\n\n}", "class_id": 0, "repo": "ATMcashDevelopment/atmcash.v1", "file": "src/java/nxt/db/Db.java", "last_update_at": "2020-04-25T13:20:39+00:00", "question_id": "4f0d5c5849a723cc29ca59c2d2a24b223dae997b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class Db {\n    private static final JdbcConnectionPool cp;\n    private static volatile int maxActiveConnections;\n    private static final ThreadLocal<DbConnection> localConnection = new ThreadLocal<>();\n    private static final ThreadLocal<Map<String,Map<DbKey,Object>>> transactionCaches = new ThreadLocal<>();\n    private static final ThreadLocal<Map<String,Map<DbKey,Object>>> transactionBatches = new ThreadLocal<>();\n    private static final class DbConnection extends FilteredConnection {\n        private DbConnection(Connection con) {\n            super(con);\n        }\n        @Override\n        public void setAutoCommit(boolean autoCommit) throws SQLException {\n            throw new UnsupportedOperationException(\"Use Db.beginTransaction() to start a new transaction\");\n        }\n        @Override\n        public void commit() throws SQLException {\n            if (localConnection.get() == null) {\n                super.commit();\n            } else if (! this.equals(localConnection.get())) {\n                throw new IllegalStateException(\"Previous connection not committed\");\n            } else {\n                throw new UnsupportedOperationException(\"Use Db.commitTransaction() to commit the transaction\");\n            }\n        }\n        private void doCommit() throws SQLException {\n            super.commit();\n        }\n        @Override\n        public void rollback() throws SQLException {\n            if (localConnection.get() == null) {\n                super.rollback();\n            } else if (! this.equals(localConnection.get())) {\n                throw new IllegalStateException(\"Previous connection not committed\");\n            } else {\n                throw new UnsupportedOperationException(\"Use Db.rollbackTransaction() to rollback the transaction\");\n            }\n        }\n        private void doRollback() throws SQLException {\n            super.rollback();\n        }\n        @Override\n        public void close() throws SQLException {\n            if (localConnection.get() == null) {\n                super.close();\n            } else if (! this.equals(localConnection.get())) {\n                throw new IllegalStateException(\"Previous connection not committed\");\n            }\n        }\n    }\n    public static void init() {}\n    static {\n        long maxCacheSize = Nxt.getIntProperty(\"nxt.dbCacheKB\");\n        if (maxCacheSize == 0) {\n        \tmaxCacheSize = Math.min(256, Math.max(16, (Runtime.getRuntime().maxMemory() / (1024 * 1024) - 128)/2)) * 1024;\n        }\n        String dbUrl = Constants.isTestnet ? Nxt.getStringProperty(\"nxt.testDbUrl\") : Nxt.getStringProperty(\"nxt.dbUrl\");\n        if (! dbUrl.contains(\"CACHE_SIZE=\")) {\n            dbUrl += \";CACHE_SIZE=\" + maxCacheSize;\n        }\n\t// Replace old DB-Url if needed:\n\tif ( dbUrl.startsWith(\"jdbc:h2:ATM_db\")) {\n\t    dbUrl = \"jdbc:h2:./ATM_db\" + dbUrl.substring(16);\n\t    Logger.logMessage(dbUrl);\n\t}\n        Logger.logDebugMessage(\"Database jdbc url set to: \" + dbUrl);\n        cp = JdbcConnectionPool.create(dbUrl, \"sa\", \"sa\");\n        cp.setMaxConnections(Nxt.getIntProperty(\"nxt.maxDbConnections\"));\n        cp.setLoginTimeout(Nxt.getIntProperty(\"nxt.dbLoginTimeout\"));\n        int defaultLockTimeout = Nxt.getIntProperty(\"nxt.dbDefaultLockTimeout\") * 1000;\n        try (Connection con = cp.getConnection();\n             Statement stmt = con.createStatement()) {\n            stmt.executeUpdate(\"SET DEFAULT_LOCK_TIMEOUT \" + defaultLockTimeout);\n        } catch (SQLException e) {\n            throw new RuntimeException(e.toString(), e);\n        }\n    }\n    public static void analyzeTables() {\n        try (Connection con = cp.getConnection();\n             Statement stmt = con.createStatement()) {\n            stmt.execute(\"ANALYZE SAMPLE_SIZE 0\");\n        } catch (SQLException e) {\n            throw new RuntimeException(e.toString(), e);\n        }\n    }\n    public static void shutdown() {\n        try {\n            Connection con = cp.getConnection();\n            Statement stmt = con.createStatement();\n            stmt.execute(\"SHUTDOWN COMPACT\");\n            Logger.logShutdownMessage(\"Database shutdown completed\");\n        } catch (SQLException e) {\n            Logger.logShutdownMessage(e.toString(), e);\n        }\n    }\n    private static Connection getPooledConnection() throws SQLException {\n        Connection con = cp.getConnection();\n        int activeConnections = cp.getActiveConnections();\n        if (activeConnections > maxActiveConnections) {\n            maxActiveConnections = activeConnections;\n            Logger.logDebugMessage(\"Database connection pool current size: \" + activeConnections);\n        }\n        return con;\n    }\n    public static Connection getConnection() throws SQLException {\n        Connection con = localConnection.get();\n        if (con != null) {\n            return con;\n        }\n        con = getPooledConnection();\n        con.setAutoCommit(true);\n        return new DbConnection(con);\n    }\n    static Map<DbKey,Object> getCache(String tableName) {\n        if (!isInTransaction()) {\n            throw new IllegalStateException(\"Not in transaction\");\n        }\n        Map<DbKey,Object> cacheMap = transactionCaches.get().get(tableName);\n        if (cacheMap == null) {\n            cacheMap = new HashMap<>();\n            transactionCaches.get().put(tableName, cacheMap);\n        }\n        return cacheMap;\n    }\n    static Map<DbKey,Object> getBatch(String tableName) {\n        if(!isInTransaction()) {\n            throw new IllegalStateException(\"Not in transaction\");\n        }\n        Map<DbKey,Object> batchMap = transactionBatches.get().get(tableName);\n        if(batchMap == null) {\n            batchMap = new HashMap<>();\n            transactionBatches.get().put(tableName, batchMap);\n        }\n        return batchMap;\n    }\n    public static boolean isInTransaction() {\n        return localConnection.get() != null;\n    }\n    public static Connection beginTransaction() {\n        if (localConnection.get() != null) {\n            throw new IllegalStateException(\"Transaction already in progress\");\n        }\n        try {\n            Connection con = getPooledConnection();\n            con.setAutoCommit(false);\n            con = new DbConnection(con);\n            localConnection.set((DbConnection)con);\n            transactionCaches.set(new HashMap<String, Map<DbKey, Object>>());\n            transactionBatches.set(new HashMap<String, Map<DbKey, Object>>());\n            return con;\n        } catch (SQLException e) {\n            throw new RuntimeException(e.toString(), e);\n        }\n    }\n    public static void commitTransaction() {\n        DbConnection con = localConnection.get();\n        if (con == null) {\n            throw new IllegalStateException(\"Not in transaction\");\n        }\n        try {\n            con.doCommit();\n        } catch (SQLException e) {\n            throw new RuntimeException(e.toString(), e);\n        }\n    }\n    public static void rollbackTransaction() {\n        DbConnection con = localConnection.get();\n        if (con == null) {\n            throw new IllegalStateException(\"Not in transaction\");\n        }\n        try {\n            con.doRollback();\n        } catch (SQLException e) {\n            throw new RuntimeException(e.toString(), e);\n        }\n        transactionCaches.get().clear();\n        transactionBatches.get().clear();\n    }\n    public static void endTransaction() {\n        Connection con = localConnection.get();\n        if (con == null) {\n            throw new IllegalStateException(\"Not in transaction\");\n        }\n        localConnection.set(null);\n        transactionCaches.get().clear();\n        transactionCaches.set(null);\n        transactionBatches.get().clear();\n        transactionBatches.set(null);\n        DbUtils.close(con);\n    }\n    private Db() {} // never\n"]]}
{"hexsha": "dd3622f796fcad1346fb98b41c0e76621ebca8ff", "ext": "java", "lang": "Java", "content": "public class MockResponseTest {\n\n    @Test\n    public void testJson() throws Exception {\n        Observable<String> jsonObservable = MockResponse.generateJson(736L, 1, 1000, 5);\n        String json = jsonObservable.toBlockingObservable().single();\n        System.out.println(json);\n        assertTrue(json.startsWith(\"{\\\"responseKey\\\":\" + MockResponse.getResponseKey(736L) + \",\\\"delay\\\":1,\\\"itemSize\\\":1000,\\\"numItems\\\":5,\\\"items\\\"\"));\n        System.out.println(\"json: \" + json);\n    }\n\n}", "class_id": 0, "repo": "truthiswill/ReactiveLab", "file": "reactive-lab-services/src/test/java/io/reactivex/lab/services/impls/MockResponseTest.java", "last_update_at": "2020-07-29T18:15:04+00:00", "question_id": "dd3622f796fcad1346fb98b41c0e76621ebca8ff", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MockResponseTest {\n    @Test\n    public void testJson() throws Exception {\n        Observable<String> jsonObservable = MockResponse.generateJson(736L, 1, 1000, 5);\n        String json = jsonObservable.toBlockingObservable().single();\n        System.out.println(json);\n        assertTrue(json.startsWith(\"{\\\"responseKey\\\":\" + MockResponse.getResponseKey(736L) + \",\\\"delay\\\":1,\\\"itemSize\\\":1000,\\\"numItems\\\":5,\\\"items\\\"\"));\n        System.out.println(\"json: \" + json);\n    }\n"]]}
{"hexsha": "7a4a6b07c56055191150f09ae37715a4257ccd8e", "ext": "java", "lang": "Java", "content": "public class NettyServer {\n\n    public static void main(String[] args) {\n        NettyServer nettyServer = new NettyServer();\n        nettyServer.bind(9999);\n    }\n\n    private void bind(int port) {\n        //\u914d\u7f6e\u670d\u52a1\u7684nio\u7ebf\u7a0b\u7ec4\n        EventLoopGroup group = new NioEventLoopGroup();\n\n\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n                    .channel(NioDatagramChannel.class)\n                    .option(ChannelOption.SO_BROADCAST, true) //\u5e7f\u64ad\n                    .option(ChannelOption.SO_RCVBUF, 2048 * 1024)  // \u8bbe\u7f6eUDP\u8bfb\u7f13\u51b2\u533a\u4e3a2M\n                    .option(ChannelOption.SO_SNDBUF, 1024 * 1024)  // \u8bbe\u7f6eUDP\u5199\u7f13\u51b2\u533a\u4e3a1M\n                    .handler(new MyChannelInitializer());\n            ChannelFuture f = b.bind(port).sync();\n            System.out.println(\"\u670d\u52a1\u7aef\u542f\u52a8\");\n            f.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            group.shutdownGracefully();\n        }\n\n    }\n}", "class_id": 0, "repo": "yang-xiansen/yxs-code", "file": "yxs-netty/netty-11/src/main/java/org/yxs/netty/server/NettyServer.java", "last_update_at": "2020-07-31T05:27:08+00:00", "question_id": "7a4a6b07c56055191150f09ae37715a4257ccd8e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NettyServer {\n    public static void main(String[] args) {\n        NettyServer nettyServer = new NettyServer();\n        nettyServer.bind(9999);\n    }\n    private void bind(int port) {\n        //\u914d\u7f6e\u670d\u52a1\u7684nio\u7ebf\u7a0b\u7ec4\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n                    .channel(NioDatagramChannel.class)\n                    .option(ChannelOption.SO_BROADCAST, true) //\u5e7f\u64ad\n                    .option(ChannelOption.SO_RCVBUF, 2048 * 1024)  // \u8bbe\u7f6eUDP\u8bfb\u7f13\u51b2\u533a\u4e3a2M\n                    .option(ChannelOption.SO_SNDBUF, 1024 * 1024)  // \u8bbe\u7f6eUDP\u5199\u7f13\u51b2\u533a\u4e3a1M\n                    .handler(new MyChannelInitializer());\n            ChannelFuture f = b.bind(port).sync();\n            System.out.println(\"\u670d\u52a1\u7aef\u542f\u52a8\");\n            f.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n"]]}
{"hexsha": "eb44049499b37c1511e88709a9ff2342cfd09d46", "ext": "java", "lang": "Java", "content": "public class JaxrsUserTest extends AbstractJaxrsTest {\n\n\t@Before\n\tpublic void before() throws Exception {\n\t\tsuper.before();\n\t\t\n\t\tif (isUseTLS()) {\n\t\t\t\n\t\t\tPath srcdir = Paths.get(\"src/test/resources/tls-public\");\n\t\t\tPath pemPath = srcdir.resolve(\"tls.pem\");\n\t\t\t\n\t\t\tSSLContext sslContext = new SSLContextBuilder()\n\t\t\t\t\t.keystorePath(Paths.get(\"target/keystore-public.jks\"))\n\t\t\t\t\t.addPem(\"self-signed-public\", pemPath)\n\t\t\t\t\t.build();\n\t\t\t\n\t\t\tSSLContext.setDefault(sslContext);\n\t\t\t\n\t\t\tgetConfig().setUseTLS(true);\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testUserLifecycle() throws Exception {\n\n\t\tURL resUrl = getClass().getResource(\"/json/user-register.json\");\n\t\t\n\t\tObjectMapper mapper = new ObjectMapper();\n\t\tUserRegister user = mapper.readValue(resUrl, UserRegister.class);\n\t\tAssert.assertEquals(\"myuser@example.com\", user.getEmail());\n\t\t\n\t\t// User Register\n\t\t\n\t\t// PUT http://localhost:8200/jaxrs/api/users\n\t\t// \n\t\t// {\n\t\t//\t  \"firstName\": \"My\",\n\t\t//\t  \"lastName\":  \"User\", \n\t\t//\t  \"email\":\t   \"myuser@example.com\",\n\t\t//\t  \"username\":  \"myuser\", \n\t\t//\t  \"password\":  \"mypass\"\n\t\t// }\n\t\t\n\t\tURI uri = jaxrsUri(\"/api/users\");\n\t\tResponse res = withClient(uri, target -> target.request()\n\t\t\t\t.put(Entity.json(user)));\n\t\t\n\t\tassertStatus(res, Status.CREATED, Status.CONFLICT);\n\t\t\n\t\t// User Login\n\t\t\n\t\t// POST http://localhost:8200/jaxrs/api/user/token\n\t\t// Content-Type: application/x-www-form-urlencoded\n\t\t//\n\t\t// username: myuser \n\t\t// password: mypass\n\t\t\n\t\tMultivaluedMap<String, String> data = new MultivaluedHashMap<>();\n\t\tdata.add(\"username\", user.getUsername());\n\t\tdata.add(\"password\", user.getPassword());\n\t\t\n\t\turi = jaxrsUri(\"/api/users/login\");\n\t\tres = withClient(uri, target -> target.request()\n\t\t\t\t.post(Entity.form(data)));\n\t\t\n\t\tassertStatus(res, Status.OK);\n\t\t\n\t\tUserTokens tokens = res.readEntity(UserTokens.class);\n\t\tString refreshToken = tokens.refreshToken;\n\t\tString userId = tokens.userId;\n\t\t\n\t\t// User State\n\t\t\n\t\t// GET http://localhost:8200/jaxrs/api/user/state\n\t\t// Authorization: \"Bearer eyJhbGciOi...\"\n\t\t\n\t\tKeycloakService kcsrv = getService(KeycloakService.class);\n\t\tString accessToken = kcsrv.refreshAccessToken(refreshToken);\n\t\tAssert.assertNotNull(\"Null access token\", accessToken);\n\t\t\n\t\turi = jaxrsUri(\"/api/user/\" + userId + \"/state\");\n\t\tres = withClient(uri, target -> target.request()\n\t\t\t\t\t.header(\"Authorization\", \"Bearer \" + accessToken)\n\t\t\t\t\t.get());\n\t\t\n\t\tassertStatus(res, Status.OK);\n\t\t\n\t\tUserState userInfo = res.readEntity(UserState.class);\n\t\tAssert.assertEquals(\"myuser@example.com\", userInfo.getEmail());\n\t\t\n\t\t// User Delete\n\t\t\n\t\t// DELETE http://localhost:8200/jaxrs/api/user\n\t\t// Authorization: \"Bearer eyJhbGciOi...\"\n\t\t\n\t\turi = jaxrsUri(\"/api/user/\" + userId);\n\t\tres = withClient(uri, target -> target.request()\n\t\t\t\t\t.header(\"Authorization\", \"Bearer \" + accessToken)\n\t\t\t\t\t.delete());\n\t\t\n\t\tassertStatus(res, Status.NO_CONTENT);\n\t}\n\n\tprivate boolean isUseTLS() {\n\t\t\n\t\tboolean useTLS = getConfig().isUseTLS();\n\t\tif (useTLS) return true; \n\t\t\n\t\tString sysprop = System.getProperty(\"useTLS\");\n\t\tif (!useTLS && sysprop != null) {\n\t\t\tuseTLS = sysprop.length() > 0 ? Boolean.valueOf(sysprop) : true;\n\t\t}\n\t\t\n\t\treturn useTLS;\n\t}\n}", "class_id": 0, "repo": "tdiesler/nessus-actions", "file": "jaxrs/src/test/java/io/nessus/test/actions/jaxrs/JaxrsUserTest.java", "last_update_at": "2020-09-23T13:52:16+00:00", "question_id": "eb44049499b37c1511e88709a9ff2342cfd09d46", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class JaxrsUserTest extends AbstractJaxrsTest {\n\t@Before\n\tpublic void before() throws Exception {\n\t\tsuper.before();\n\t\t\n\t\tif (isUseTLS()) {\n\t\t\t\n\t\t\tPath srcdir = Paths.get(\"src/test/resources/tls-public\");\n\t\t\tPath pemPath = srcdir.resolve(\"tls.pem\");\n\t\t\t\n\t\t\tSSLContext sslContext = new SSLContextBuilder()\n\t\t\t\t\t.keystorePath(Paths.get(\"target/keystore-public.jks\"))\n\t\t\t\t\t.addPem(\"self-signed-public\", pemPath)\n\t\t\t\t\t.build();\n\t\t\t\n\t\t\tSSLContext.setDefault(sslContext);\n\t\t\t\n\t\t\tgetConfig().setUseTLS(true);\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testUserLifecycle() throws Exception {\n\t\tURL resUrl = getClass().getResource(\"/json/user-register.json\");\n\t\t\n\t\tObjectMapper mapper = new ObjectMapper();\n\t\tUserRegister user = mapper.readValue(resUrl, UserRegister.class);\n\t\tAssert.assertEquals(\"myuser@example.com\", user.getEmail());\n\t\t\n\t\t// User Register\n\t\t\n\t\t// PUT http://localhost:8200/jaxrs/api/users\n\t\t// \n\t\t// {\n\t\t//\t  \"firstName\": \"My\",\n\t\t//\t  \"lastName\":  \"User\", \n\t\t//\t  \"email\":\t   \"myuser@example.com\",\n\t\t//\t  \"username\":  \"myuser\", \n\t\t//\t  \"password\":  \"mypass\"\n\t\t// }\n\t\t\n\t\tURI uri = jaxrsUri(\"/api/users\");\n\t\tResponse res = withClient(uri, target -> target.request()\n\t\t\t\t.put(Entity.json(user)));\n\t\t\n\t\tassertStatus(res, Status.CREATED, Status.CONFLICT);\n\t\t\n\t\t// User Login\n\t\t\n\t\t// POST http://localhost:8200/jaxrs/api/user/token\n\t\t// Content-Type: application/x-www-form-urlencoded\n\t\t//\n\t\t// username: myuser \n\t\t// password: mypass\n\t\t\n\t\tMultivaluedMap<String, String> data = new MultivaluedHashMap<>();\n\t\tdata.add(\"username\", user.getUsername());\n\t\tdata.add(\"password\", user.getPassword());\n\t\t\n\t\turi = jaxrsUri(\"/api/users/login\");\n\t\tres = withClient(uri, target -> target.request()\n\t\t\t\t.post(Entity.form(data)));\n\t\t\n\t\tassertStatus(res, Status.OK);\n\t\t\n\t\tUserTokens tokens = res.readEntity(UserTokens.class);\n\t\tString refreshToken = tokens.refreshToken;\n\t\tString userId = tokens.userId;\n\t\t\n\t\t// User State\n\t\t\n\t\t// GET http://localhost:8200/jaxrs/api/user/state\n\t\t// Authorization: \"Bearer eyJhbGciOi...\"\n\t\t\n\t\tKeycloakService kcsrv = getService(KeycloakService.class);\n\t\tString accessToken = kcsrv.refreshAccessToken(refreshToken);\n\t\tAssert.assertNotNull(\"Null access token\", accessToken);\n\t\t\n\t\turi = jaxrsUri(\"/api/user/\" + userId + \"/state\");\n\t\tres = withClient(uri, target -> target.request()\n\t\t\t\t\t.header(\"Authorization\", \"Bearer \" + accessToken)\n\t\t\t\t\t.get());\n\t\t\n\t\tassertStatus(res, Status.OK);\n\t\t\n\t\tUserState userInfo = res.readEntity(UserState.class);\n\t\tAssert.assertEquals(\"myuser@example.com\", userInfo.getEmail());\n\t\t\n\t\t// User Delete\n\t\t\n\t\t// DELETE http://localhost:8200/jaxrs/api/user\n\t\t// Authorization: \"Bearer eyJhbGciOi...\"\n\t\t\n\t\turi = jaxrsUri(\"/api/user/\" + userId);\n\t\tres = withClient(uri, target -> target.request()\n\t\t\t\t\t.header(\"Authorization\", \"Bearer \" + accessToken)\n\t\t\t\t\t.delete());\n\t\t\n\t\tassertStatus(res, Status.NO_CONTENT);\n\t}\n\tprivate boolean isUseTLS() {\n\t\t\n\t\tboolean useTLS = getConfig().isUseTLS();\n\t\tif (useTLS) return true; \n\t\t\n\t\tString sysprop = System.getProperty(\"useTLS\");\n\t\tif (!useTLS && sysprop != null) {\n\t\t\tuseTLS = sysprop.length() > 0 ? Boolean.valueOf(sysprop) : true;\n\t\t}\n\t\t\n\t\treturn useTLS;\n\t}\n"]]}
{"hexsha": "31502ac9ab596a13274c4dd68ad040205e815044", "ext": "java", "lang": "Java", "content": "public class PlayersAroundChecker {\n\n    private final List<Location> playersLoc = new ArrayList<Location>();\n    private final Map<Location, Integer> minDistanceCache = new HashMap<Location, Integer>();\n\n    public PlayersAroundChecker(Plugin plugin, int period) {\n        PlayersLocPoller poller = new PlayersLocPoller();\n\n        poller.run();\n        Bukkit.getScheduler().scheduleSyncRepeatingTask(plugin, poller, period, period);\n    }\n\n    /** Thread unsafe */\n    public boolean isAnyPlayerAround(Location loc, int radius) {\n        if (playersLoc.isEmpty()) return false;\n\n        Integer cachedMinDist = minDistanceCache.get(loc);\n        if (cachedMinDist == null) {\n            int minDist = Integer.MAX_VALUE;\n            for (Location playerLoc : playersLoc) {\n                if (playerLoc.getWorld().equals(loc.getWorld())) {\n                    int curDist = (int) playerLoc.distance(loc);\n                    if (curDist < minDist) {\n                        minDist = curDist;\n                    }\n                }\n            }\n            cachedMinDist = minDist;\n            minDistanceCache.put(loc, cachedMinDist);\n        }\n\n        return cachedMinDist <= radius;\n    }\n\n    private class PlayersLocPoller implements Runnable {\n\n        @Override\n        public void run() {\n            playersLoc.clear();\n            minDistanceCache.clear();\n\n            Player[] players = Bukkit.getServer().getOnlinePlayers();\n            for (Player player : players) {\n                playersLoc.add(player.getLocation());\n            }\n        }\n    }\n}", "class_id": 0, "repo": "galaran/GalaransHeroesSkills", "file": "SkillTurret/src/mccity/heroes/skills/turret/PlayersAroundChecker.java", "last_update_at": "2020-05-11T07:45:20+00:00", "question_id": "31502ac9ab596a13274c4dd68ad040205e815044", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PlayersAroundChecker {\n    private final List<Location> playersLoc = new ArrayList<Location>();\n    private final Map<Location, Integer> minDistanceCache = new HashMap<Location, Integer>();\n    public PlayersAroundChecker(Plugin plugin, int period) {\n        PlayersLocPoller poller = new PlayersLocPoller();\n        poller.run();\n        Bukkit.getScheduler().scheduleSyncRepeatingTask(plugin, poller, period, period);\n    }\n    /** Thread unsafe */\n    public boolean isAnyPlayerAround(Location loc, int radius) {\n        if (playersLoc.isEmpty()) return false;\n        Integer cachedMinDist = minDistanceCache.get(loc);\n        if (cachedMinDist == null) {\n            int minDist = Integer.MAX_VALUE;\n            for (Location playerLoc : playersLoc) {\n                if (playerLoc.getWorld().equals(loc.getWorld())) {\n                    int curDist = (int) playerLoc.distance(loc);\n                    if (curDist < minDist) {\n                        minDist = curDist;\n                    }\n                }\n            }\n            cachedMinDist = minDist;\n            minDistanceCache.put(loc, cachedMinDist);\n        }\n        return cachedMinDist <= radius;\n    }\n    private class PlayersLocPoller implements Runnable {\n        @Override\n        public void run() {\n            playersLoc.clear();\n            minDistanceCache.clear();\n            Player[] players = Bukkit.getServer().getOnlinePlayers();\n            for (Player player : players) {\n                playersLoc.add(player.getLocation());\n            }\n        }\n    }\n"]]}
{"hexsha": "4693e9363bd9c4520301c9fd7a76759876723f1c", "ext": "java", "lang": "Java", "content": "@Path(IndexClient.SERVICE_PATH)\n@Produces({\"application/xml\"})\n@Consumes({\"application/xml\"})\npublic class IndexResource extends NuxeoBasedResource {\n\n    @Override\n    public String getServiceName(){\n        return IndexClient.SERVICE_NAME;\n    }\n\n    @Override\n    protected String getVersionString() {\n    \tfinal String lastChangeRevision = \"$LastChangedRevision: 2108 $\";\n    \treturn lastChangeRevision;\n    }\n\n    @Override\n    //public Class<ObjectexitCommon> getCommonPartClass() {\n    public Class<?> getCommonPartClass() {\n    \ttry {\n            return Class.forName(\"org.collectionspace.services.objectexit.IndexCommon\");//.class;\n        } catch (ClassNotFoundException e){\n            return null;\n        }\n    }\n    \n\t/*\n\t * HTTP Methods\n\t */\n    \n\t@Override\n\t@POST\n\tpublic Response create(@Context ResourceMap resourceMap, @Context UriInfo ui, String xmlPayload) {\n\t\tResponse response = Response.status(Response.Status.BAD_REQUEST)\n\t\t\t\t.entity(ServiceMessages.POST_UNSUPPORTED).type(\"text/plain\").build();\n\t\treturn response;\n\t}\n\t\n    @Override\n\t@DELETE\n    @Path(\"{csid}\")\n    public Response delete(@PathParam(\"csid\") String csid) {\n\t\tResponse response = Response.status(Response.Status.BAD_REQUEST)\n\t\t\t\t.entity(ServiceMessages.DELETE_UNSUPPORTED).type(\"text/plain\")\n\t\t\t\t.build();\n\t\treturn response;\n    }\n    \n\t@POST\n    @Path(\"{indexid}\")\n\tpublic Response reindex(\n            @Context Request request,\n            @Context UriInfo uriInfo,\n            @PathParam(\"indexid\") String indexid) {\n    \turiInfo = new UriInfoWrapper(uriInfo);\n       \tResponse result = Response.ok().build();\n       \tboolean success = false;\n       \tString docType = null;\n       \t\n        try {\n            RemoteServiceContext<PoxPayloadIn, PoxPayloadOut> ctx = (RemoteServiceContext<PoxPayloadIn, PoxPayloadOut>) createServiceContext(uriInfo);\n            docType = ctx.getTenantQualifiedDoctype(); // this will used in the error message if an error occurs\n            DocumentHandler handler = createDocumentHandler(ctx);\n            success = getRepositoryClient(ctx).reindex(handler, indexid);\n        } catch (Exception e) {\n            throw bigReThrow(e, ServiceMessages.REINDEX_FAILED);\n        }\n        \n        if (success == false) {\n            Response response = Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(\n                    ServiceMessages.REINDEX_FAILED + ServiceMessages.indexResourceNotFoundMsg(indexid)).type(\"text/plain\").build();\n            throw new CSWebApplicationException(response);\n        }\n       \t\n       \treturn result;\n    }\n    \n\t/* (non-Javadoc)\n\t * @see org.collectionspace.services.common.ResourceBase#getList(javax.ws.rs.core.UriInfo, java.lang.String)\n\t * \n\t * The index sub-resource does not support a getList operation.\n\t */\n\t@Override\n\t@GET\n\tpublic AbstractCommonList getList(@Context UriInfo ui) {\n\t\tResponse response = Response.status(Response.Status.BAD_REQUEST)\n\t\t\t\t.entity(ServiceMessages.GET_LIST_UNSUPPORTED).type(\"text/plain\")\n\t\t\t\t.build();\n\t\tthrow new CSWebApplicationException(response);\n\t}\n\n\t@Override\n\tpublic AbstractCommonList getList(ServiceContext<PoxPayloadIn, PoxPayloadOut> parentCtx, UriInfo uriInfo) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n}", "class_id": 0, "repo": "jblowe/services", "file": "services/index/service/src/main/java/org/collectionspace/services/index/IndexResource.java", "last_update_at": "2020-05-13T10:04:34+00:00", "question_id": "4693e9363bd9c4520301c9fd7a76759876723f1c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Path(IndexClient.SERVICE_PATH)\n@Produces({\"application/xml\"})\n@Consumes({\"application/xml\"})\npublic class IndexResource extends NuxeoBasedResource {\n    @Override\n    public String getServiceName(){\n        return IndexClient.SERVICE_NAME;\n    }\n    @Override\n    protected String getVersionString() {\n    \tfinal String lastChangeRevision = \"$LastChangedRevision: 2108 $\";\n    \treturn lastChangeRevision;\n    }\n    @Override\n    //public Class<ObjectexitCommon> getCommonPartClass() {\n    public Class<?> getCommonPartClass() {\n    \ttry {\n            return Class.forName(\"org.collectionspace.services.objectexit.IndexCommon\");//.class;\n        } catch (ClassNotFoundException e){\n            return null;\n        }\n    }\n\t/*\n\t * HTTP Methods\n\t */\n\t@Override\n\t@POST\n\tpublic Response create(@Context ResourceMap resourceMap, @Context UriInfo ui, String xmlPayload) {\n\t\tResponse response = Response.status(Response.Status.BAD_REQUEST)\n\t\t\t\t.entity(ServiceMessages.POST_UNSUPPORTED).type(\"text/plain\").build();\n\t\treturn response;\n\t}\n\t\n    @Override\n\t@DELETE\n    @Path(\"{csid}\")\n    public Response delete(@PathParam(\"csid\") String csid) {\n\t\tResponse response = Response.status(Response.Status.BAD_REQUEST)\n\t\t\t\t.entity(ServiceMessages.DELETE_UNSUPPORTED).type(\"text/plain\")\n\t\t\t\t.build();\n\t\treturn response;\n    }\n\t@POST\n    @Path(\"{indexid}\")\n\tpublic Response reindex(\n            @Context Request request,\n            @Context UriInfo uriInfo,\n            @PathParam(\"indexid\") String indexid) {\n    \turiInfo = new UriInfoWrapper(uriInfo);\n       \tResponse result = Response.ok().build();\n       \tboolean success = false;\n       \tString docType = null;\n       \t\n        try {\n            RemoteServiceContext<PoxPayloadIn, PoxPayloadOut> ctx = (RemoteServiceContext<PoxPayloadIn, PoxPayloadOut>) createServiceContext(uriInfo);\n            docType = ctx.getTenantQualifiedDoctype(); // this will used in the error message if an error occurs\n            DocumentHandler handler = createDocumentHandler(ctx);\n            success = getRepositoryClient(ctx).reindex(handler, indexid);\n        } catch (Exception e) {\n            throw bigReThrow(e, ServiceMessages.REINDEX_FAILED);\n        }\n        if (success == false) {\n            Response response = Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(\n                    ServiceMessages.REINDEX_FAILED + ServiceMessages.indexResourceNotFoundMsg(indexid)).type(\"text/plain\").build();\n            throw new CSWebApplicationException(response);\n        }\n       \t\n       \treturn result;\n    }\n\t/* (non-Javadoc)\n\t * @see org.collectionspace.services.common.ResourceBase#getList(javax.ws.rs.core.UriInfo, java.lang.String)\n\t * \n\t * The index sub-resource does not support a getList operation.\n\t */\n\t@Override\n\t@GET\n\tpublic AbstractCommonList getList(@Context UriInfo ui) {\n\t\tResponse response = Response.status(Response.Status.BAD_REQUEST)\n\t\t\t\t.entity(ServiceMessages.GET_LIST_UNSUPPORTED).type(\"text/plain\")\n\t\t\t\t.build();\n\t\tthrow new CSWebApplicationException(response);\n\t}\n\t@Override\n\tpublic AbstractCommonList getList(ServiceContext<PoxPayloadIn, PoxPayloadOut> parentCtx, UriInfo uriInfo) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n"]]}
{"hexsha": "7dec64bf44dfdaeead1c9e4cadff8c00eb8dfe71", "ext": "java", "lang": "Java", "content": "public class PostgresIntegrationTest\n{\n    private Photon photon;\n\n    @SneakyThrows\n    @Before\n    public void setup()\n    {\n        String url = \"jdbc:postgresql://localhost:15432/\";\n        photon = new Photon(url, \"postgres\", \"bears\", PhotonOptions.postgresOptions().build());\n\n        try(PhotonTransaction transaction = photon.beginAutoCommitTransaction())\n        {\n            transaction.executeUpdate(\"CREATE DATABASE photon_test_db\");\n        }\n        catch(PhotonException ex)\n        {\n            if(ex.getCause() == null || !ex.getCause().getMessage().equals(\"ERROR: database \\\"photon_test_db\\\" already exists\"))\n            {\n                throw ex;\n            }\n        }\n\n        url = \"jdbc:postgresql://localhost:15432/photon_test_db\";\n        photon = new Photon(url, \"postgres\", \"bears\", PhotonOptions.postgresOptions().build());\n\n        photon\n            .registerAggregate(PhotonTestTable.class)\n            .withId(\"id\")\n            .withPrimaryKeyAutoIncrement()\n            .register();\n\n        try(PhotonTransaction transaction = photon.beginTransaction())\n        {\n            transaction\n                .query(\n                \"DROP TABLE IF EXISTS \\\"PhotonTestTable\\\";\\n\" +\n                    \"CREATE TABLE \\\"PhotonTestTable\\\"\\n\" +\n                    \"(\\n\" +\n                    \"    id SERIAL PRIMARY KEY,\\n\" +\n                    \"    \\\"uuidColumn\\\" uuid NOT NULL,\\n\" +\n                    \"    \\\"dateColumn\\\" timestamp without time zone NOT NULL,\\n\" +\n                    \"    \\\"varcharColumn\\\" character varying(32) COLLATE pg_catalog.\\\"default\\\" NOT NULL\\n\" +\n                    \")\\n\" +\n                    \"WITH (\\n\" +\n                    \"    OIDS = FALSE\\n\" +\n                    \")\\n\" +\n                    \"TABLESPACE pg_default;\"\n                ).executeInsert();\n\n            transaction.commit();\n        }\n\n        try(PhotonTransaction transaction = photon.beginTransaction())\n        {\n            transaction\n                .query(\"INSERT INTO \\\"PhotonTestTable\\\" (\\\"uuidColumn\\\", \\\"dateColumn\\\", \\\"varcharColumn\\\") VALUES ('8ED1E1BD-253E-4469-B4CB-71E1217825B7', to_timestamp(1489915698), 'Test String')\")\n                .executeInsert();\n\n            transaction.commit();\n        }\n    }\n\n    @Test\n    public void fetchExistingAggregateById_populatesValues()\n    {\n        try(PhotonTransaction transaction = photon.beginTransaction())\n        {\n            PhotonTestTable photonTestTable = transaction.query(PhotonTestTable.class).fetchById(1);\n\n            // Note: Unlike MySQL and SQL Server, Postgres defaults to UTC when given epoch times with to_timestamp(). No need to apply an offset here.\n\n            assertNotNull(photonTestTable);\n            assertEquals(1, photonTestTable.getId());\n            assertEquals(UUID.fromString(\"8ED1E1BD-253E-4469-B4CB-71E1217825B7\"), photonTestTable.getUuidColumn());\n            assertEquals(ZonedDateTime.ofInstant(Instant.ofEpochSecond(1489915698), ZoneId.systemDefault()), photonTestTable.getDateColumn());\n            assertEquals(\"Test String\", photonTestTable.getVarcharColumn());\n        }\n    }\n\n    @Test\n    public void insertAggregateAndFetch_insertsAggregateAndPopulatesValues()\n    {\n        PhotonTestTable photonTestTable = new PhotonTestTable(\n            null,\n            UUID.fromString(\"11111111-2222-3333-4444-555555555555\"),\n            ZonedDateTime.ofInstant(Instant.ofEpochSecond(1493493022), ZoneId.systemDefault()),\n            \"My Test String\"\n        );\n\n        try(PhotonTransaction transaction = photon.beginTransaction())\n        {\n            transaction.insert(photonTestTable);\n            transaction.commit();\n        }\n\n        try(PhotonTransaction transaction = photon.beginTransaction())\n        {\n            PhotonTestTable photonTestTableFetched = transaction.query(PhotonTestTable.class).fetchById(2);\n\n            assertEquals(photonTestTable, photonTestTableFetched);\n        }\n    }\n}", "class_id": 0, "repo": "molcikas/photon", "file": "photon-core/src/test/java/com/github/molcikas/photon/tests/integration/PostgresIntegrationTest.java", "last_update_at": "2020-12-23T17:08:48+00:00", "question_id": "7dec64bf44dfdaeead1c9e4cadff8c00eb8dfe71", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PostgresIntegrationTest\n{\n    private Photon photon;\n    @SneakyThrows\n    @Before\n    public void setup()\n    {\n        String url = \"jdbc:postgresql://localhost:15432/\";\n        photon = new Photon(url, \"postgres\", \"bears\", PhotonOptions.postgresOptions().build());\n        try(PhotonTransaction transaction = photon.beginAutoCommitTransaction())\n        {\n            transaction.executeUpdate(\"CREATE DATABASE photon_test_db\");\n        }\n        catch(PhotonException ex)\n        {\n            if(ex.getCause() == null || !ex.getCause().getMessage().equals(\"ERROR: database \\\"photon_test_db\\\" already exists\"))\n            {\n                throw ex;\n            }\n        }\n        url = \"jdbc:postgresql://localhost:15432/photon_test_db\";\n        photon = new Photon(url, \"postgres\", \"bears\", PhotonOptions.postgresOptions().build());\n        photon\n            .registerAggregate(PhotonTestTable.class)\n            .withId(\"id\")\n            .withPrimaryKeyAutoIncrement()\n            .register();\n        try(PhotonTransaction transaction = photon.beginTransaction())\n        {\n            transaction\n                .query(\n                \"DROP TABLE IF EXISTS \\\"PhotonTestTable\\\";\\n\" +\n                    \"CREATE TABLE \\\"PhotonTestTable\\\"\\n\" +\n                    \"(\\n\" +\n                    \"    id SERIAL PRIMARY KEY,\\n\" +\n                    \"    \\\"uuidColumn\\\" uuid NOT NULL,\\n\" +\n                    \"    \\\"dateColumn\\\" timestamp without time zone NOT NULL,\\n\" +\n                    \"    \\\"varcharColumn\\\" character varying(32) COLLATE pg_catalog.\\\"default\\\" NOT NULL\\n\" +\n                    \")\\n\" +\n                    \"WITH (\\n\" +\n                    \"    OIDS = FALSE\\n\" +\n                    \")\\n\" +\n                    \"TABLESPACE pg_default;\"\n                ).executeInsert();\n            transaction.commit();\n        }\n        try(PhotonTransaction transaction = photon.beginTransaction())\n        {\n            transaction\n                .query(\"INSERT INTO \\\"PhotonTestTable\\\" (\\\"uuidColumn\\\", \\\"dateColumn\\\", \\\"varcharColumn\\\") VALUES ('8ED1E1BD-253E-4469-B4CB-71E1217825B7', to_timestamp(1489915698), 'Test String')\")\n                .executeInsert();\n            transaction.commit();\n        }\n    }\n    @Test\n    public void fetchExistingAggregateById_populatesValues()\n    {\n        try(PhotonTransaction transaction = photon.beginTransaction())\n        {\n            PhotonTestTable photonTestTable = transaction.query(PhotonTestTable.class).fetchById(1);\n            // Note: Unlike MySQL and SQL Server, Postgres defaults to UTC when given epoch times with to_timestamp(). No need to apply an offset here.\n            assertNotNull(photonTestTable);\n            assertEquals(1, photonTestTable.getId());\n            assertEquals(UUID.fromString(\"8ED1E1BD-253E-4469-B4CB-71E1217825B7\"), photonTestTable.getUuidColumn());\n            assertEquals(ZonedDateTime.ofInstant(Instant.ofEpochSecond(1489915698), ZoneId.systemDefault()), photonTestTable.getDateColumn());\n            assertEquals(\"Test String\", photonTestTable.getVarcharColumn());\n        }\n    }\n    @Test\n    public void insertAggregateAndFetch_insertsAggregateAndPopulatesValues()\n    {\n        PhotonTestTable photonTestTable = new PhotonTestTable(\n            null,\n            UUID.fromString(\"11111111-2222-3333-4444-555555555555\"),\n            ZonedDateTime.ofInstant(Instant.ofEpochSecond(1493493022), ZoneId.systemDefault()),\n            \"My Test String\"\n        );\n        try(PhotonTransaction transaction = photon.beginTransaction())\n        {\n            transaction.insert(photonTestTable);\n            transaction.commit();\n        }\n        try(PhotonTransaction transaction = photon.beginTransaction())\n        {\n            PhotonTestTable photonTestTableFetched = transaction.query(PhotonTestTable.class).fetchById(2);\n            assertEquals(photonTestTable, photonTestTableFetched);\n        }\n    }\n"]]}
{"hexsha": "9948b3a68b97b3671e74ee572eb5877ca9633d38", "ext": "java", "lang": "Java", "content": "public class PropertiesManagementMethods implements BaseTest {\n\n    static String propertiesFilePath = \"src/main/resources/config.properties\";\n    static String seleniumPropertiesFilePath = \"src/main/resources/selenium.properties\";\n    static String environmentPropertiesFilePath = \"src/main/resources/ENV.environment.properties\";\n    static String environment = System.getProperty(\"env\").toLowerCase();\n\n    public void setProperty(String propName, String propValue) {\n\n        // create temp test file if not exists\n        File file = new File(propertiesFilePath);\n\n        try {\n            if (file.createNewFile()) {\n                Log.INFO(\"File: \" + propertiesFilePath + \" is created\");\n            }\n        } catch (IOException e1) {\n            e1.printStackTrace();\n        }\n\n        // load config file\n        Properties props = null;\n        try {\n            FileInputStream in = new FileInputStream(propertiesFilePath);\n            props = new Properties();\n            props.load(in);\n            in.close();\n        } catch (Exception e) {\n\n        }\n        // edit config file\n        try {\n            FileOutputStream out = new FileOutputStream(propertiesFilePath);\n            props.setProperty(propName, propValue);\n            props.store(out, null);\n            out.close();\n        } catch (Exception e) {\n        }\n    }\n\n    public String getProperty(String propName) {\n        Properties prop = new Properties();\n\n        InputStream is;\n        try {\n            is = new FileInputStream(propertiesFilePath);\n\n            prop.load(is);\n            String propertieValue = prop.getProperty(propName);\n\n            is.close();\n\n            return propertieValue;\n\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public String getSeleniumProperty(String propName) {\n        Properties prop = new Properties();\n\n        InputStream is;\n        try {\n            is = new FileInputStream(seleniumPropertiesFilePath);\n\n            prop.load(is);\n            String propertieValue = prop.getProperty(propName);\n\n            is.close();\n\n            return propertieValue;\n\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public String getEnvironmentProperty(String propName) {\n        Properties prop = new Properties();\n\n        InputStream is;\n        try {\n            is = new FileInputStream(environmentPropertiesFilePath.replace(\"ENV\", environment));\n\n            prop.load(is);\n            String propertieValue = prop.getProperty(propName);\n\n            is.close();\n\n            return propertieValue;\n\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    // UTILS\n    public static String getOS() {\n        String OS = System.getProperty(\"os.name\").toLowerCase();\n        return OS;\n    }\n\n    public boolean isWindows() {\n        String OS = getOS();\n        return (OS.indexOf(\"win\") >= 0);\n    }\n\n    public boolean isMac() {\n        String OS = getOS();\n        return (OS.indexOf(\"mac\") >= 0);\n    }\n\n    public boolean isUnix() {\n        String OS = getOS();\n        return (OS.indexOf(\"nix\") >= 0 || OS.indexOf(\"nux\") >= 0 || OS.indexOf(\"aix\") > 0);\n    }\n}", "class_id": 0, "repo": "Pavelya/selenium-cucumber-allure-reports-java", "file": "src/main/java/com/qa/tlv/methods/PropertiesManagementMethods.java", "last_update_at": "2020-04-04T18:40:33+00:00", "question_id": "9948b3a68b97b3671e74ee572eb5877ca9633d38", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PropertiesManagementMethods implements BaseTest {\n    static String propertiesFilePath = \"src/main/resources/config.properties\";\n    static String seleniumPropertiesFilePath = \"src/main/resources/selenium.properties\";\n    static String environmentPropertiesFilePath = \"src/main/resources/ENV.environment.properties\";\n    static String environment = System.getProperty(\"env\").toLowerCase();\n    public void setProperty(String propName, String propValue) {\n        // create temp test file if not exists\n        File file = new File(propertiesFilePath);\n        try {\n            if (file.createNewFile()) {\n                Log.INFO(\"File: \" + propertiesFilePath + \" is created\");\n            }\n        } catch (IOException e1) {\n            e1.printStackTrace();\n        }\n        // load config file\n        Properties props = null;\n        try {\n            FileInputStream in = new FileInputStream(propertiesFilePath);\n            props = new Properties();\n            props.load(in);\n            in.close();\n        } catch (Exception e) {\n        }\n        // edit config file\n        try {\n            FileOutputStream out = new FileOutputStream(propertiesFilePath);\n            props.setProperty(propName, propValue);\n            props.store(out, null);\n            out.close();\n        } catch (Exception e) {\n        }\n    }\n    public String getProperty(String propName) {\n        Properties prop = new Properties();\n        InputStream is;\n        try {\n            is = new FileInputStream(propertiesFilePath);\n            prop.load(is);\n            String propertieValue = prop.getProperty(propName);\n            is.close();\n            return propertieValue;\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n    public String getSeleniumProperty(String propName) {\n        Properties prop = new Properties();\n        InputStream is;\n        try {\n            is = new FileInputStream(seleniumPropertiesFilePath);\n            prop.load(is);\n            String propertieValue = prop.getProperty(propName);\n            is.close();\n            return propertieValue;\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n    public String getEnvironmentProperty(String propName) {\n        Properties prop = new Properties();\n        InputStream is;\n        try {\n            is = new FileInputStream(environmentPropertiesFilePath.replace(\"ENV\", environment));\n            prop.load(is);\n            String propertieValue = prop.getProperty(propName);\n            is.close();\n            return propertieValue;\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n    // UTILS\n    public static String getOS() {\n        String OS = System.getProperty(\"os.name\").toLowerCase();\n        return OS;\n    }\n    public boolean isWindows() {\n        String OS = getOS();\n        return (OS.indexOf(\"win\") >= 0);\n    }\n    public boolean isMac() {\n        String OS = getOS();\n        return (OS.indexOf(\"mac\") >= 0);\n    }\n    public boolean isUnix() {\n        String OS = getOS();\n        return (OS.indexOf(\"nix\") >= 0 || OS.indexOf(\"nux\") >= 0 || OS.indexOf(\"aix\") > 0);\n    }\n"]]}
{"hexsha": "0e9e02ded21272f19e8102222a48b78eb4b63383", "ext": "java", "lang": "Java", "content": "public class WeightedKNearestNeighborsClassifier extends KNearestNeighborsClassifier {\n    \n    public WeightedKNearestNeighborsClassifier (DistanceMeasure dm, int k) {\n        super (dm, k);\n    }\n    public WeightedKNearestNeighborsClassifier (DistanceMeasure dm) {\n        super (dm);\n    }\n    public WeightedKNearestNeighborsClassifier () {\n        super ();\n    }\n\n    @Override\n    public synchronized ClassProbabilityDistribution classDistribution (Features df) {\n        HashMap<Features, Double> knearest = new HashMap<>(distance(df));\n        HashMap<Features, Double> wvf = new HashMap<>(weightedVotingFunction(df, knearest));\n        // Create Classification Distribution\n        ClassProbabilityDistribution res = new ClassProbabilityDistribution();\n        knearest.keySet().stream().forEach ((Features x) -> {\n            double value = res.getOrDefault(x.getLabel(), 0.0);\n            double vote = wvf.get(x);\n            res.put(x.getLabel(), value + vote);\n        });\n        return res;\n    }\n    \n    protected Map<Features, Double> weightedVotingFunction (Features f, Map<Features, Double> dis) {\n        double sum = 0.0;\n        for (double x : dis.values()) {\n            sum += x;\n        }\n        HashMap<Features, Double> res = new HashMap<>(dis);\n        for (Features x : dis.keySet()) {\n            res.put(x, 1 - (dis.get(x) / sum));\n        }\n        return res;\n    }\n}", "class_id": 0, "repo": "parham/phm-scientific-platform", "file": "src/main/java/com/phm/comp/classifier/WeightedKNearestNeighborsClassifier.java", "last_update_at": "2020-09-20T04:37:03+00:00", "question_id": "0e9e02ded21272f19e8102222a48b78eb4b63383", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class WeightedKNearestNeighborsClassifier extends KNearestNeighborsClassifier {\n    public WeightedKNearestNeighborsClassifier (DistanceMeasure dm, int k) {\n        super (dm, k);\n    }\n    public WeightedKNearestNeighborsClassifier (DistanceMeasure dm) {\n        super (dm);\n    }\n    public WeightedKNearestNeighborsClassifier () {\n        super ();\n    }\n    @Override\n    public synchronized ClassProbabilityDistribution classDistribution (Features df) {\n        HashMap<Features, Double> knearest = new HashMap<>(distance(df));\n        HashMap<Features, Double> wvf = new HashMap<>(weightedVotingFunction(df, knearest));\n        // Create Classification Distribution\n        ClassProbabilityDistribution res = new ClassProbabilityDistribution();\n        knearest.keySet().stream().forEach ((Features x) -> {\n            double value = res.getOrDefault(x.getLabel(), 0.0);\n            double vote = wvf.get(x);\n            res.put(x.getLabel(), value + vote);\n        });\n        return res;\n    }\n    protected Map<Features, Double> weightedVotingFunction (Features f, Map<Features, Double> dis) {\n        double sum = 0.0;\n        for (double x : dis.values()) {\n            sum += x;\n        }\n        HashMap<Features, Double> res = new HashMap<>(dis);\n        for (Features x : dis.keySet()) {\n            res.put(x, 1 - (dis.get(x) / sum));\n        }\n        return res;\n    }\n"]]}
{"hexsha": "4dae79b946ac622ea052f19661d159d8186a03e6", "ext": "java", "lang": "Java", "content": "public class RegrasNegocioItemInspecao {\n\n    public static void validarItemInspecao(ItemInspecaoVO i, Boolean isInclusao, Connection conn) throws Exception {\n\n//        5.5. Regras de neg\u00f3cio\n//        5.5.1. [RN01] Nomes de itens de pontua\u00e7\u00e3o devem conter no m\u00e1ximo 30 caracteres;\n        if (i.getNome().length() > 30) {\n            throw new Exception(\"Nome deve conter no m\u00e1ximo 30 caracteres\");\n        }\n\n\n\n        if (isInclusao) {\n\n            ItemInspecaoDAO daoItemInspecao;\n            daoItemInspecao= new ItemInspecaoDAO(conn);\n\n//        5.5.2. [RN02] N\u00e3o \u00e9 permitido duplicar nomes de Itens de pontua\u00e7\u00e3o;\n            if (daoItemInspecao.existeItemInspecao(i.getNome())) {\n                throw new Exception(\"Nome de item j\u00e1 existente\");\n            }\n        }\n\n\n//        5.5.3. [RN03] N\u00e3o \u00e9 permitido duplicar nomes de \u00c1reas;\n        //OK\n\n\n//        5.5.4. [RN04] A pontua\u00e7\u00e3o m\u00ednima deve ser maior ou igual a zero;\n        if(i.getPontuacaoMinima().doubleValue() < new BigDecimal(0).doubleValue()){\n            throw new Exception(\"A pontua\u00e7\u00e3o m\u00ednima deve ser maior ou igual a zero\");\n        }\n\n//        5.5.5. [RN05] A pontua\u00e7\u00e3o m\u00e1xima n\u00e3o deve ultrapassar o valor de \u201c999,99\u201d;\n        if(i.getPontuacaoMaxima().doubleValue() > new BigDecimal(999.99).doubleValue()){\n            throw new Exception(\"A pontua\u00e7\u00e3o m\u00e1xima n\u00e3o deve ultrapassar o valor de 999,99\");\n        }\n\n//        5.5.6. [RN06] Os campos Valor M\u00ednimo e Valor M\u00e1ximo devem conter cinco d\u00edgitos, sendo dois ap\u00f3s a virgula;\n//        5.5.7. [RN07] Caso n\u00e3o sejam respeitadas as regras [RN01] at\u00e9 [RN06], avisar o usu\u00e1rio via mensagem na tela.\n//        5.5.8. O conte\u00fado das comboBox deve estar classificado em ordem crescente;\n//        5.5.9. As comboBox devem ser apresentadas preenchidas, com o primeiro registro encontrado ap\u00f3s a ordena\u00e7\u00e3o.\n\n\n\n\n\n\n\n\n\n    }\n}", "class_id": 0, "repo": "jonataspc/pontua", "file": "app/src/main/java/controle/regrasNegocios/RegrasNegocioItemInspecao.java", "last_update_at": "2020-05-25T14:04:10+00:00", "question_id": "4dae79b946ac622ea052f19661d159d8186a03e6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RegrasNegocioItemInspecao {\n    public static void validarItemInspecao(ItemInspecaoVO i, Boolean isInclusao, Connection conn) throws Exception {\n//        5.5. Regras de neg\u00f3cio\n//        5.5.1. [RN01] Nomes de itens de pontua\u00e7\u00e3o devem conter no m\u00e1ximo 30 caracteres;\n        if (i.getNome().length() > 30) {\n            throw new Exception(\"Nome deve conter no m\u00e1ximo 30 caracteres\");\n        }\n        if (isInclusao) {\n            ItemInspecaoDAO daoItemInspecao;\n            daoItemInspecao= new ItemInspecaoDAO(conn);\n//        5.5.2. [RN02] N\u00e3o \u00e9 permitido duplicar nomes de Itens de pontua\u00e7\u00e3o;\n            if (daoItemInspecao.existeItemInspecao(i.getNome())) {\n                throw new Exception(\"Nome de item j\u00e1 existente\");\n            }\n        }\n//        5.5.3. [RN03] N\u00e3o \u00e9 permitido duplicar nomes de \u00c1reas;\n        //OK\n//        5.5.4. [RN04] A pontua\u00e7\u00e3o m\u00ednima deve ser maior ou igual a zero;\n        if(i.getPontuacaoMinima().doubleValue() < new BigDecimal(0).doubleValue()){\n            throw new Exception(\"A pontua\u00e7\u00e3o m\u00ednima deve ser maior ou igual a zero\");\n        }\n//        5.5.5. [RN05] A pontua\u00e7\u00e3o m\u00e1xima n\u00e3o deve ultrapassar o valor de \u201c999,99\u201d;\n        if(i.getPontuacaoMaxima().doubleValue() > new BigDecimal(999.99).doubleValue()){\n            throw new Exception(\"A pontua\u00e7\u00e3o m\u00e1xima n\u00e3o deve ultrapassar o valor de 999,99\");\n        }\n//        5.5.6. [RN06] Os campos Valor M\u00ednimo e Valor M\u00e1ximo devem conter cinco d\u00edgitos, sendo dois ap\u00f3s a virgula;\n//        5.5.7. [RN07] Caso n\u00e3o sejam respeitadas as regras [RN01] at\u00e9 [RN06], avisar o usu\u00e1rio via mensagem na tela.\n//        5.5.8. O conte\u00fado das comboBox deve estar classificado em ordem crescente;\n//        5.5.9. As comboBox devem ser apresentadas preenchidas, com o primeiro registro encontrado ap\u00f3s a ordena\u00e7\u00e3o.\n    }\n"]]}
{"hexsha": "b160dea1970d2ce12140a6977a430bfc9012caf2", "ext": "java", "lang": "Java", "content": "public class BeforeClassOrAfterClassIsPublicStaticVoidNoArgInspection\n  extends BeforeClassOrAfterClassIsPublicStaticVoidNoArgInspectionBase {\n\n  @Override\n  protected InspectionGadgetsFix buildFix(Object... infos) {\n    if (infos.length != 1) return null;\n    final Object name = infos[0];\n    if (!(name instanceof String)) return null;\n    return new MakePublicStaticVoidFix((String)name);\n  }\n\n  private static class MakePublicStaticVoidFix extends InspectionGadgetsFix {\n    private final String myName;\n\n    public MakePublicStaticVoidFix(String name) {\n      myName = name;\n    }\n\n    @Override\n    protected void doFix(final Project project, ProblemDescriptor descriptor) throws IncorrectOperationException {\n      final PsiMethod method = PsiTreeUtil.getParentOfType(descriptor.getPsiElement(), PsiMethod.class);\n      if (method != null) {\n        final PsiModifierList modifierList = method.getModifierList();\n        if (!modifierList.hasModifierProperty(PsiModifier.PUBLIC)) {\n          modifierList.setModifierProperty(PsiModifier.PUBLIC, true);\n        }\n        if (!modifierList.hasModifierProperty(PsiModifier.STATIC)) {\n          modifierList.setModifierProperty(PsiModifier.STATIC, true);\n        }\n\n        if (!PsiType.VOID.equals(method.getReturnType())) {\n          ChangeSignatureProcessor csp =\n            new ChangeSignatureProcessor(project, method, false, PsiModifier.PUBLIC, method.getName(), PsiType.VOID,\n                                         new ParameterInfoImpl[0]);\n          csp.run();\n        }\n      }\n    }\n\n    @NotNull\n    @Override\n    public String getFamilyName() {\n      return \"Fix modifiers\";\n    }\n\n    @Override\n    @NotNull\n    public String getName() {\n      return myName;\n    }\n  }\n}", "class_id": 0, "repo": "teddywest32/intellij-community", "file": "plugins/InspectionGadgets/src/com/siyeh/ig/junit/BeforeClassOrAfterClassIsPublicStaticVoidNoArgInspection.java", "last_update_at": "2020-11-27T10:36:50+00:00", "question_id": "b160dea1970d2ce12140a6977a430bfc9012caf2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BeforeClassOrAfterClassIsPublicStaticVoidNoArgInspection\n  extends BeforeClassOrAfterClassIsPublicStaticVoidNoArgInspectionBase {\n  @Override\n  protected InspectionGadgetsFix buildFix(Object... infos) {\n    if (infos.length != 1) return null;\n    final Object name = infos[0];\n    if (!(name instanceof String)) return null;\n    return new MakePublicStaticVoidFix((String)name);\n  }\n  private static class MakePublicStaticVoidFix extends InspectionGadgetsFix {\n    private final String myName;\n    public MakePublicStaticVoidFix(String name) {\n      myName = name;\n    }\n    @Override\n    protected void doFix(final Project project, ProblemDescriptor descriptor) throws IncorrectOperationException {\n      final PsiMethod method = PsiTreeUtil.getParentOfType(descriptor.getPsiElement(), PsiMethod.class);\n      if (method != null) {\n        final PsiModifierList modifierList = method.getModifierList();\n        if (!modifierList.hasModifierProperty(PsiModifier.PUBLIC)) {\n          modifierList.setModifierProperty(PsiModifier.PUBLIC, true);\n        }\n        if (!modifierList.hasModifierProperty(PsiModifier.STATIC)) {\n          modifierList.setModifierProperty(PsiModifier.STATIC, true);\n        }\n        if (!PsiType.VOID.equals(method.getReturnType())) {\n          ChangeSignatureProcessor csp =\n            new ChangeSignatureProcessor(project, method, false, PsiModifier.PUBLIC, method.getName(), PsiType.VOID,\n                                         new ParameterInfoImpl[0]);\n          csp.run();\n        }\n      }\n    }\n    @NotNull\n    @Override\n    public String getFamilyName() {\n      return \"Fix modifiers\";\n    }\n    @Override\n    @NotNull\n    public String getName() {\n      return myName;\n    }\n  }\n"]]}
{"hexsha": "72d02099b1ed4d923ae366aa98b9754bf766cd2c", "ext": "java", "lang": "Java", "content": "public class NavigatorAction extends CommonFormFields {\r\n\r\n    private static Logger log = LoggerFactory.getLogger(TransformAction.class);\r\n\r\n    /** The xml mapping file that conforms to navigator.xsd */\r\n    private String navigator_xml_file_name;\r\n\r\n    /** An reference xml that conforms to navigator.xsd */\r\n    private String xml_ref;\r\n\r\n\r\n    /** Where we store the result of the navigator processing. If not\r\n     * set we display instead */\r\n    private String key;\r\n\r\n    String path;\r\n\r\n\r\n    public String execute(IExecContext execContext) throws Exception {\r\n\r\n        validate(execContext);\r\n        \r\n\t\tsetTheme(execContext.getThemes().getTheme(getTheme_name(execContext)));\r\n\r\n\t\tNavigator navigator = new Navigator();\r\n\t\tString navXml= null;\r\n        if (StringUtils.isNotEmpty(getXml_ref())) {\r\n        \tnavXml = navigator.buildHtml(execContext, getTheme(execContext), execContext.getString(getXml_ref()));\r\n        } else {\r\n            File file = new File(path, execContext.replace(getNavigator_xml_file_name()));\r\n            if (!file.exists() || file.isDirectory()) {\r\n                throw new IllegalArgumentException(\"Missing or invalid file name [\" + file.getAbsolutePath()\r\n                        + \"] for navigator_xml_file_name attribute [\" + getNavigator_xml_file_name() + \"]\");\r\n            }\r\n            String fileXml = ResourceUtils.loadXMLFileWithISO(file.getAbsolutePath());\r\n        \tnavXml = navigator.buildHtml(execContext, getTheme(execContext), fileXml);\r\n        }\r\n        if (StringUtils.isNotEmpty(getKey())) {\r\n        \texecContext.put(key, navXml);\r\n            return \"\";\r\n        } else {\r\n        \treturn navXml;\r\n        }\r\n    }\r\n\r\n    public void validate(IExecContext execContext) {\r\n        if (StringUtils.isEmpty(getNavigator_xml_file_name()) && StringUtils.isEmpty(getXml_ref())) {\r\n            throw new IllegalArgumentException(\"Missing navigator_xml_file_name and xml_ref attribute in tranform.  At least one of these attributes must be set.\");\r\n        }\r\n        if (StringUtils.isNotEmpty(getNavigator_xml_file_name()) && StringUtils.isNotEmpty(getXml_ref())) {\r\n            throw new IllegalArgumentException(\"Both the navigator_xml_file_name and xml_ref attribute are set. Only one of these attributes must be set, not both\");\r\n        }\r\n        if (path == null) {\r\n            path = (String) execContext.get(ActionConst.WEB_REAL_PATH_BEAN_REF);\r\n        }\r\n        if (StringUtils.isEmpty(getId())){\r\n            throw new IllegalArgumentException(\"Missing id attribute in navigator\");\r\n        }\r\n    }\r\n\r\n    public void setKey(String key) {\r\n        this.key = key;\r\n    }\r\n\r\n    public String getKey() {\r\n        return key;\r\n    }\r\n\r\n\tpublic void setNavigator_xml_file_name(String navigator_xml_file_name) {\r\n\t\tthis.navigator_xml_file_name = navigator_xml_file_name;\r\n\t}\r\n\r\n\tpublic String getNavigator_xml_file_name() {\r\n\t\treturn navigator_xml_file_name;\r\n\t}\r\n\r\n\tpublic void setXml_ref(String xml_ref) {\r\n\t\tthis.xml_ref = xml_ref;\r\n\t}\r\n\r\n\tpublic String getXml_ref() {\r\n\t\treturn xml_ref;\r\n\t}\r\n\r\n}", "class_id": 0, "repo": "mwjmurphy/Axel-Framework", "file": "axel-web/src/main/java/org/xmlactions/pager/actions/navigator/NavigatorAction.java", "last_update_at": "2020-04-22T21:34:34+00:00", "question_id": "72d02099b1ed4d923ae366aa98b9754bf766cd2c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NavigatorAction extends CommonFormFields {\r\n\r\n    private static Logger log = LoggerFactory.getLogger(TransformAction.class);\r\n\r\n    /** The xml mapping file that conforms to navigator.xsd */\r\n    private String navigator_xml_file_name;\r\n\r\n    /** An reference xml that conforms to navigator.xsd */\r\n    private String xml_ref;\r\n\r\n\r\n    /** Where we store the result of the navigator processing. If not\r\n     * set we display instead */\r\n    private String key;\r\n\r\n    String path;\r\n\r\n\r\n    public String execute(IExecContext execContext) throws Exception {\r\n\r\n        validate(execContext);\r\n        \r\n\t\tsetTheme(execContext.getThemes().getTheme(getTheme_name(execContext)));\r\n\r\n\t\tNavigator navigator = new Navigator();\r\n\t\tString navXml= null;\r\n        if (StringUtils.isNotEmpty(getXml_ref())) {\r\n        \tnavXml = navigator.buildHtml(execContext, getTheme(execContext), execContext.getString(getXml_ref()));\r\n        } else {\r\n            File file = new File(path, execContext.replace(getNavigator_xml_file_name()));\r\n            if (!file.exists() || file.isDirectory()) {\r\n                throw new IllegalArgumentException(\"Missing or invalid file name [\" + file.getAbsolutePath()\r\n                        + \"] for navigator_xml_file_name attribute [\" + getNavigator_xml_file_name() + \"]\");\r\n            }\r\n            String fileXml = ResourceUtils.loadXMLFileWithISO(file.getAbsolutePath());\r\n        \tnavXml = navigator.buildHtml(execContext, getTheme(execContext), fileXml);\r\n        }\r\n        if (StringUtils.isNotEmpty(getKey())) {\r\n        \texecContext.put(key, navXml);\r\n            return \"\";\r\n        } else {\r\n        \treturn navXml;\r\n        }\r\n    }\r\n\r\n    public void validate(IExecContext execContext) {\r\n        if (StringUtils.isEmpty(getNavigator_xml_file_name()) && StringUtils.isEmpty(getXml_ref())) {\r\n            throw new IllegalArgumentException(\"Missing navigator_xml_file_name and xml_ref attribute in tranform.  At least one of these attributes must be set.\");\r\n        }\r\n        if (StringUtils.isNotEmpty(getNavigator_xml_file_name()) && StringUtils.isNotEmpty(getXml_ref())) {\r\n            throw new IllegalArgumentException(\"Both the navigator_xml_file_name and xml_ref attribute are set. Only one of these attributes must be set, not both\");\r\n        }\r\n        if (path == null) {\r\n            path = (String) execContext.get(ActionConst.WEB_REAL_PATH_BEAN_REF);\r\n        }\r\n        if (StringUtils.isEmpty(getId())){\r\n            throw new IllegalArgumentException(\"Missing id attribute in navigator\");\r\n        }\r\n    }\r\n\r\n    public void setKey(String key) {\r\n        this.key = key;\r\n    }\r\n\r\n    public String getKey() {\r\n        return key;\r\n    }\r\n\r\n\tpublic void setNavigator_xml_file_name(String navigator_xml_file_name) {\r\n\t\tthis.navigator_xml_file_name = navigator_xml_file_name;\r\n\t}\r\n\r\n\tpublic String getNavigator_xml_file_name() {\r\n\t\treturn navigator_xml_file_name;\r\n\t}\r\n\r\n\tpublic void setXml_ref(String xml_ref) {\r\n\t\tthis.xml_ref = xml_ref;\r\n\t}\r\n\r\n\tpublic String getXml_ref() {\r\n\t\treturn xml_ref;\r\n\t}\r\n\r\n"]]}
{"hexsha": "995212829dd8ab1ab8f10ad4cded7ebbc4f92e59", "ext": "java", "lang": "Java", "content": "public class ExtraOefening5b {\n\n\tpublic static void main(String[] args) {\n\t\tScanner keyboard = new Scanner(System.in);\n\n\t\tdouble volledigGetal, getal;\n\n\t\tSystem.out.println(\"Geef een getal in:\");\n\t\tvolledigGetal = keyboard.nextDouble();\n\n\t\tgetal = ((int) (volledigGetal * 100)) / 100.0;\n\t\tSystem.out.println(\"AFGEKAPT: \" + getal);\n\n\t\tgetal = ((int) ((volledigGetal * 100) + 0.5)) / 100.0;\n\t\tSystem.out.println(\"AFGEROND: \" + getal);\n\n\t\tkeyboard.close();\n\t}\n\n}", "class_id": 0, "repo": "Limoentaart/PXL_IT", "file": "PXL_DIGITAL_JAAR_1/Programming Basics/Oplossingen Oefeningen/H5/extraOefening5/ExtraOefening5b.java", "last_update_at": "2020-10-30T10:02:44+00:00", "question_id": "995212829dd8ab1ab8f10ad4cded7ebbc4f92e59", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ExtraOefening5b {\n\tpublic static void main(String[] args) {\n\t\tScanner keyboard = new Scanner(System.in);\n\t\tdouble volledigGetal, getal;\n\t\tSystem.out.println(\"Geef een getal in:\");\n\t\tvolledigGetal = keyboard.nextDouble();\n\t\tgetal = ((int) (volledigGetal * 100)) / 100.0;\n\t\tSystem.out.println(\"AFGEKAPT: \" + getal);\n\t\tgetal = ((int) ((volledigGetal * 100) + 0.5)) / 100.0;\n\t\tSystem.out.println(\"AFGEROND: \" + getal);\n\t\tkeyboard.close();\n\t}\n"]]}
{"hexsha": "7305313c03084ce925801f2c90e955492fb15f62", "ext": "java", "lang": "Java", "content": "public class UZAPIMaster {\n    private static UZAPIMaster ourInstance;\n\n    public static UZAPIMaster getInstance() {\n        if (ourInstance == null) {\n            ourInstance = new UZAPIMaster();\n        }\n        return ourInstance;\n    }\n\n    private UZAPIMaster() {\n    }\n\n    private CompositeSubscription compositeSubscription = new CompositeSubscription();\n\n    public void destroy() {\n        if (!compositeSubscription.isUnsubscribed()) {\n            compositeSubscription.unsubscribe();\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public void subscribe(Observable observable, Subscriber subscriber) {\n        //TODO maybe in some cases we don't need to check internet connection\n        /*if (!NetworkUtils.hasConnection(this)) {\n            subscriber.onError(new NoConnectionException());\n            return;\n        }*/\n        Subscription subscription = observable.subscribeOn(Schedulers.newThread())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(subscriber);\n        compositeSubscription.add(subscription);\n    }\n}", "class_id": 0, "repo": "haiminhtran810/uiza-android-sdk-player", "file": "uizabase/src/main/java/vn/uiza/restapi/UZAPIMaster.java", "last_update_at": "2020-04-02T11:53:12+00:00", "question_id": "7305313c03084ce925801f2c90e955492fb15f62", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class UZAPIMaster {\n    private static UZAPIMaster ourInstance;\n    public static UZAPIMaster getInstance() {\n        if (ourInstance == null) {\n            ourInstance = new UZAPIMaster();\n        }\n        return ourInstance;\n    }\n    private UZAPIMaster() {\n    }\n    private CompositeSubscription compositeSubscription = new CompositeSubscription();\n    public void destroy() {\n        if (!compositeSubscription.isUnsubscribed()) {\n            compositeSubscription.unsubscribe();\n        }\n    }\n    @SuppressWarnings(\"unchecked\")\n    public void subscribe(Observable observable, Subscriber subscriber) {\n        //TODO maybe in some cases we don't need to check internet connection\n        /*if (!NetworkUtils.hasConnection(this)) {\n            subscriber.onError(new NoConnectionException());\n            return;\n        }*/\n        Subscription subscription = observable.subscribeOn(Schedulers.newThread())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(subscriber);\n        compositeSubscription.add(subscription);\n    }\n"]]}
{"hexsha": "8c639d368aeee14d4cd133a64865ff55144c98ae", "ext": "java", "lang": "Java", "content": "public class ProtostuffUtilTest extends TestCase {\n\t\n\tprivate List<KutaTuple<Long, Long>> getPages(long min, long max, long pageSize) {\n\t\tList<KutaTuple<Long, Long>> pages = new ArrayList<KutaTuple<Long,Long>>();\n\t\tif(max - min > pageSize) {\n\t\t\tfor (long i = min; i <= max; i += pageSize) {\n\t\t\t\tif(i + pageSize <= max) {\n\t\t\t\t\tpages.add(new KutaTuple<Long, Long>(i==min? min : i+1, i + pageSize));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpages.add(new KutaTuple<Long, Long>(i==min? min : i+1, max));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tpages.add(new KutaTuple<Long, Long>(min, max));\n\t\t}\n\t\treturn pages;\n\t}\n\t\n\tpublic void testMapOrList(){\n\t\t List<KutaTuple<Long, Long>> pages = getPages(50000,259200000, 2000000);\n\t\t KutaConsoleUtil.printObj(pages, true);\n//\t\tSystem.out.println(address.toLowerCase());\n\t}\n}", "class_id": 0, "repo": "kutasms/ksf", "file": "base/src/test/java/com/kuta/base/serialization/ProtostuffUtilTest.java", "last_update_at": "2020-09-02T17:09:31+00:00", "question_id": "8c639d368aeee14d4cd133a64865ff55144c98ae", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ProtostuffUtilTest extends TestCase {\n\t\n\tprivate List<KutaTuple<Long, Long>> getPages(long min, long max, long pageSize) {\n\t\tList<KutaTuple<Long, Long>> pages = new ArrayList<KutaTuple<Long,Long>>();\n\t\tif(max - min > pageSize) {\n\t\t\tfor (long i = min; i <= max; i += pageSize) {\n\t\t\t\tif(i + pageSize <= max) {\n\t\t\t\t\tpages.add(new KutaTuple<Long, Long>(i==min? min : i+1, i + pageSize));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpages.add(new KutaTuple<Long, Long>(i==min? min : i+1, max));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tpages.add(new KutaTuple<Long, Long>(min, max));\n\t\t}\n\t\treturn pages;\n\t}\n\t\n\tpublic void testMapOrList(){\n\t\t List<KutaTuple<Long, Long>> pages = getPages(50000,259200000, 2000000);\n\t\t KutaConsoleUtil.printObj(pages, true);\n//\t\tSystem.out.println(address.toLowerCase());\n\t}\n"]]}
{"hexsha": "0d7f32d5fa6219f6444093373031e5a2ac2d402d", "ext": "java", "lang": "Java", "content": "public class BeanParamAnnotationProcessor implements ParameterAnnotationProcessor {\n  public static final Set<Class<?>> SUPPORTED_PARAM_ANNOTATIONS = new HashSet<>();\n\n  public static final String SETTER_METHOD_PREFIX = \"set\";\n\n  static {\n    SUPPORTED_PARAM_ANNOTATIONS.add(PathParam.class);\n    SUPPORTED_PARAM_ANNOTATIONS.add(QueryParam.class);\n    SUPPORTED_PARAM_ANNOTATIONS.add(HeaderParam.class);\n    SUPPORTED_PARAM_ANNOTATIONS.add(CookieParam.class);\n    SUPPORTED_PARAM_ANNOTATIONS.add(FormParam.class);\n  }\n\n  @Override\n  public void process(Object annotation, OperationGenerator operationGenerator, int paramIdx) {\n    final Class<?> beanParamClazz = operationGenerator.getProviderMethod().getParameterTypes()[paramIdx];\n    Map<String, Parameter> swaggerParamMap = new HashMap<>();\n    try {\n      // traversal fields, get those JAX-RS params\n      traversalParamField(operationGenerator, beanParamClazz, swaggerParamMap);\n    } catch (IllegalArgumentException | IntrospectionException e) {\n      throw new Error(String.format(\n          \"Processing param failed, method=%s:%s, beanParamIdx=%d\",\n          operationGenerator.getProviderMethod().getDeclaringClass().getName(),\n          operationGenerator.getProviderMethod().getName(),\n          paramIdx)\n          , e);\n    }\n\n    // set swagger params into operationGenerator, in declared field order\n    Field[] declaredProducerFields = beanParamClazz.getDeclaredFields();\n    Arrays.stream(declaredProducerFields)\n        .map(declaredProducerField -> swaggerParamMap.get(declaredProducerField.getName()))\n        .filter(Objects::nonNull)\n        .forEach(operationGenerator::addProviderParameter);\n  }\n\n  /**\n   * Traversal fields of {@code beanParamClazz},\n   * generate swagger params according to JAX-RS param annotations and set them into {@code swaggerParamMap}.\n   *\n   * @param swaggerParamMap the map contains the generated swagger param,\n   * key is the name defined by source code(the declared field name) and value is the swagger param\n   */\n  private void traversalParamField(OperationGenerator operationGenerator, Class<?> beanParamClazz,\n      Map<String, Parameter> swaggerParamMap) throws IntrospectionException {\n    for (Field beanParamField : beanParamClazz.getDeclaredFields()) {\n      // ignore synthetic member to avoid build failure\n      // see https://github.com/jacoco/jacoco/issues/168\n      if (fieldShouldIgnore(beanParamField) || beanParamField.isSynthetic()) {\n        continue;\n      }\n      // try to process this field directly\n      Parameter swaggerParam = generateSwaggerParam(operationGenerator, beanParamField.getAnnotations(),\n          beanParamField.getGenericType());\n      if (null == swaggerParam) {\n        // if swaggerParam is null, maybe the JAX-RS param annotation is tagged onto the write method\n        swaggerParam = processFieldSetter(operationGenerator, beanParamClazz, beanParamField);\n      }\n\n      if (null == swaggerParam) {\n        throw new IllegalArgumentException(String.format(\n            \"There is a field[%s] cannot be mapped to swagger param. Maybe you should tag @JsonIgnore on it.\",\n            beanParamField.getName())\n        );\n      }\n      swaggerParamMap.put(beanParamField.getName(), swaggerParam);\n    }\n  }\n\n  /**\n   * Sometimes user may tag JAX-RS param annotations on setter method instead of fields.\n   *\n   * @param beanParamClazz class of the BeanParam\n   * @param beanParamField the field of BeanParam whose setter method is processed\n   * @return the generated swagger param, or null if the setter method is not tagged by JAX-RS param annotations\n   * @throws IntrospectionException see {@linkplain PropertyDescriptor#PropertyDescriptor(String, Class)}\n   */\n  private Parameter processFieldSetter(OperationGenerator operationGenerator, Class<?> beanParamClazz,\n      Field beanParamField) throws IntrospectionException {\n    Parameter swaggerParam = null;\n    PropertyDescriptor propertyDescriptor = new PropertyDescriptor(beanParamField.getName(), beanParamClazz);\n    Method writeMethod = propertyDescriptor.getWriteMethod();\n    if (null != writeMethod) {\n      swaggerParam = generateSwaggerParam(operationGenerator, writeMethod.getAnnotations(),\n          beanParamField.getGenericType());\n    }\n    return swaggerParam;\n  }\n\n  /**\n   * Generate a swagger parameter according to {@code annotations} and {@code genericType}.\n   *\n   * @param operationGenerator operationGenerator\n   * @param annotations annotations on fields or setter methods\n   * @param genericType type of the fields, or the param type of the setter methods\n   * @return a swagger param, or null if there is no JAX-RS annotation in {@code annotations}\n   */\n  private Parameter generateSwaggerParam(\n      OperationGenerator operationGenerator,\n      Annotation[] annotations,\n      Type genericType) {\n    String defaultValue = null;\n    for (Annotation fieldAnnotation : annotations) {\n      if (!SUPPORTED_PARAM_ANNOTATIONS.contains(fieldAnnotation.annotationType())) {\n        if (fieldAnnotation instanceof DefaultValue) {\n          defaultValue = ((DefaultValue) fieldAnnotation).value();\n        }\n        continue;\n      }\n\n      return setUpParameter(operationGenerator, fieldAnnotation, genericType, defaultValue);\n    }\n    return null;\n  }\n\n  /**\n   * Generate swagger parameter, set default value, and return it.\n   *\n   * @param operationGenerator operationGenerator\n   * @param fieldAnnotation JAX-RS param annotation\n   * @param genericParamType type of the parameter\n   * @param defaultValue default value, can be null\n   * @return the generated swagger Parameter\n   */\n  private Parameter setUpParameter(\n      OperationGenerator operationGenerator,\n      Annotation fieldAnnotation,\n      Type genericParamType,\n      String defaultValue) {\n    AbstractSerializableParameter<?> parameter = createParameter(\n        operationGenerator.getContext(),\n        fieldAnnotation,\n        genericParamType);\n\n    if (null != defaultValue) {\n      parameter.setDefaultValue(defaultValue);\n    }\n    return parameter;\n  }\n\n  /**\n   * Generate a swagger parameter, set up name and type info.\n   *\n   * @param swaggerGeneratorContext context data carried by {@linkplain OperationGenerator}\n   * @param fieldAnnotation JAX-RS param annotation\n   * @param genericParamType default value, can be null\n   * @return the generated swagger parameter\n   */\n  private AbstractSerializableParameter<?> createParameter(\n      SwaggerGeneratorContext swaggerGeneratorContext,\n      Annotation fieldAnnotation,\n      Type genericParamType) {\n    // find the corresponding ParameterProcessor and process the parameter\n    final AbstractParameterProcessor<?> parameterAnnotationProcessor =\n        (AbstractParameterProcessor<?>) swaggerGeneratorContext\n            .findParameterAnnotationProcessor(fieldAnnotation.annotationType());\n    AbstractSerializableParameter<?> parameter = parameterAnnotationProcessor.createParameter();\n    String paramName = parameterAnnotationProcessor.getAnnotationParameterName(fieldAnnotation);\n    parameter.setName(paramName);\n    ParamUtils.setParameterType(genericParamType, parameter);\n    return parameter;\n  }\n\n  /**\n   * Those fields tagged by @JsonIgnore should be ignored.\n   */\n  private boolean fieldShouldIgnore(Field beanParamField) {\n    for (Annotation annotation : beanParamField.getAnnotations()) {\n      if (annotation instanceof JsonIgnore) {\n        return true;\n      }\n    }\n    return false;\n  }\n}", "class_id": 0, "repo": "ltp217/servicecomb-java-chassis", "file": "swagger/swagger-generator/generator-jaxrs/src/main/java/org/apache/servicecomb/swagger/generator/jaxrs/processor/annotation/BeanParamAnnotationProcessor.java", "last_update_at": "2020-03-22T07:58:13+00:00", "question_id": "0d7f32d5fa6219f6444093373031e5a2ac2d402d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BeanParamAnnotationProcessor implements ParameterAnnotationProcessor {\n  public static final Set<Class<?>> SUPPORTED_PARAM_ANNOTATIONS = new HashSet<>();\n  public static final String SETTER_METHOD_PREFIX = \"set\";\n  static {\n    SUPPORTED_PARAM_ANNOTATIONS.add(PathParam.class);\n    SUPPORTED_PARAM_ANNOTATIONS.add(QueryParam.class);\n    SUPPORTED_PARAM_ANNOTATIONS.add(HeaderParam.class);\n    SUPPORTED_PARAM_ANNOTATIONS.add(CookieParam.class);\n    SUPPORTED_PARAM_ANNOTATIONS.add(FormParam.class);\n  }\n  @Override\n  public void process(Object annotation, OperationGenerator operationGenerator, int paramIdx) {\n    final Class<?> beanParamClazz = operationGenerator.getProviderMethod().getParameterTypes()[paramIdx];\n    Map<String, Parameter> swaggerParamMap = new HashMap<>();\n    try {\n      // traversal fields, get those JAX-RS params\n      traversalParamField(operationGenerator, beanParamClazz, swaggerParamMap);\n    } catch (IllegalArgumentException | IntrospectionException e) {\n      throw new Error(String.format(\n          \"Processing param failed, method=%s:%s, beanParamIdx=%d\",\n          operationGenerator.getProviderMethod().getDeclaringClass().getName(),\n          operationGenerator.getProviderMethod().getName(),\n          paramIdx)\n          , e);\n    }\n    // set swagger params into operationGenerator, in declared field order\n    Field[] declaredProducerFields = beanParamClazz.getDeclaredFields();\n    Arrays.stream(declaredProducerFields)\n        .map(declaredProducerField -> swaggerParamMap.get(declaredProducerField.getName()))\n        .filter(Objects::nonNull)\n        .forEach(operationGenerator::addProviderParameter);\n  }\n  /**\n   * Traversal fields of {@code beanParamClazz},\n   * generate swagger params according to JAX-RS param annotations and set them into {@code swaggerParamMap}.\n   *\n   * @param swaggerParamMap the map contains the generated swagger param,\n   * key is the name defined by source code(the declared field name) and value is the swagger param\n   */\n  private void traversalParamField(OperationGenerator operationGenerator, Class<?> beanParamClazz,\n      Map<String, Parameter> swaggerParamMap) throws IntrospectionException {\n    for (Field beanParamField : beanParamClazz.getDeclaredFields()) {\n      // ignore synthetic member to avoid build failure\n      // see https://github.com/jacoco/jacoco/issues/168\n      if (fieldShouldIgnore(beanParamField) || beanParamField.isSynthetic()) {\n        continue;\n      }\n      // try to process this field directly\n      Parameter swaggerParam = generateSwaggerParam(operationGenerator, beanParamField.getAnnotations(),\n          beanParamField.getGenericType());\n      if (null == swaggerParam) {\n        // if swaggerParam is null, maybe the JAX-RS param annotation is tagged onto the write method\n        swaggerParam = processFieldSetter(operationGenerator, beanParamClazz, beanParamField);\n      }\n      if (null == swaggerParam) {\n        throw new IllegalArgumentException(String.format(\n            \"There is a field[%s] cannot be mapped to swagger param. Maybe you should tag @JsonIgnore on it.\",\n            beanParamField.getName())\n        );\n      }\n      swaggerParamMap.put(beanParamField.getName(), swaggerParam);\n    }\n  }\n  /**\n   * Sometimes user may tag JAX-RS param annotations on setter method instead of fields.\n   *\n   * @param beanParamClazz class of the BeanParam\n   * @param beanParamField the field of BeanParam whose setter method is processed\n   * @return the generated swagger param, or null if the setter method is not tagged by JAX-RS param annotations\n   * @throws IntrospectionException see {@linkplain PropertyDescriptor#PropertyDescriptor(String, Class)}\n   */\n  private Parameter processFieldSetter(OperationGenerator operationGenerator, Class<?> beanParamClazz,\n      Field beanParamField) throws IntrospectionException {\n    Parameter swaggerParam = null;\n    PropertyDescriptor propertyDescriptor = new PropertyDescriptor(beanParamField.getName(), beanParamClazz);\n    Method writeMethod = propertyDescriptor.getWriteMethod();\n    if (null != writeMethod) {\n      swaggerParam = generateSwaggerParam(operationGenerator, writeMethod.getAnnotations(),\n          beanParamField.getGenericType());\n    }\n    return swaggerParam;\n  }\n  /**\n   * Generate a swagger parameter according to {@code annotations} and {@code genericType}.\n   *\n   * @param operationGenerator operationGenerator\n   * @param annotations annotations on fields or setter methods\n   * @param genericType type of the fields, or the param type of the setter methods\n   * @return a swagger param, or null if there is no JAX-RS annotation in {@code annotations}\n   */\n  private Parameter generateSwaggerParam(\n      OperationGenerator operationGenerator,\n      Annotation[] annotations,\n      Type genericType) {\n    String defaultValue = null;\n    for (Annotation fieldAnnotation : annotations) {\n      if (!SUPPORTED_PARAM_ANNOTATIONS.contains(fieldAnnotation.annotationType())) {\n        if (fieldAnnotation instanceof DefaultValue) {\n          defaultValue = ((DefaultValue) fieldAnnotation).value();\n        }\n        continue;\n      }\n      return setUpParameter(operationGenerator, fieldAnnotation, genericType, defaultValue);\n    }\n    return null;\n  }\n  /**\n   * Generate swagger parameter, set default value, and return it.\n   *\n   * @param operationGenerator operationGenerator\n   * @param fieldAnnotation JAX-RS param annotation\n   * @param genericParamType type of the parameter\n   * @param defaultValue default value, can be null\n   * @return the generated swagger Parameter\n   */\n  private Parameter setUpParameter(\n      OperationGenerator operationGenerator,\n      Annotation fieldAnnotation,\n      Type genericParamType,\n      String defaultValue) {\n    AbstractSerializableParameter<?> parameter = createParameter(\n        operationGenerator.getContext(),\n        fieldAnnotation,\n        genericParamType);\n    if (null != defaultValue) {\n      parameter.setDefaultValue(defaultValue);\n    }\n    return parameter;\n  }\n  /**\n   * Generate a swagger parameter, set up name and type info.\n   *\n   * @param swaggerGeneratorContext context data carried by {@linkplain OperationGenerator}\n   * @param fieldAnnotation JAX-RS param annotation\n   * @param genericParamType default value, can be null\n   * @return the generated swagger parameter\n   */\n  private AbstractSerializableParameter<?> createParameter(\n      SwaggerGeneratorContext swaggerGeneratorContext,\n      Annotation fieldAnnotation,\n      Type genericParamType) {\n    // find the corresponding ParameterProcessor and process the parameter\n    final AbstractParameterProcessor<?> parameterAnnotationProcessor =\n        (AbstractParameterProcessor<?>) swaggerGeneratorContext\n            .findParameterAnnotationProcessor(fieldAnnotation.annotationType());\n    AbstractSerializableParameter<?> parameter = parameterAnnotationProcessor.createParameter();\n    String paramName = parameterAnnotationProcessor.getAnnotationParameterName(fieldAnnotation);\n    parameter.setName(paramName);\n    ParamUtils.setParameterType(genericParamType, parameter);\n    return parameter;\n  }\n  /**\n   * Those fields tagged by @JsonIgnore should be ignored.\n   */\n  private boolean fieldShouldIgnore(Field beanParamField) {\n    for (Annotation annotation : beanParamField.getAnnotations()) {\n      if (annotation instanceof JsonIgnore) {\n        return true;\n      }\n    }\n    return false;\n  }\n"]]}
{"hexsha": "26a4299e1e00e69d2b72ef73fe98d474ee2b4767", "ext": "java", "lang": "Java", "content": "public class BundleWatcher implements Runnable, BundleListener {\n\n    private final Logger logger = LoggerFactory.getLogger(BundleWatcher.class);\n\n    private BundleContext bundleContext;\n    private ConfigurationAdmin configurationAdmin;\n\n    private AtomicBoolean running = new AtomicBoolean(false);\n    private long interval = 1000L;\n    private List<String> watchURLs = new CopyOnWriteArrayList<String>();\n    private AtomicInteger counter = new AtomicInteger(0);\n\n\n    /**\n     * Construcotr\n     */\n    public BundleWatcher() {\n    }\n\n    public void bundleChanged(BundleEvent event) {\n        if (event.getType() == BundleEvent.INSTALLED\n                || event.getType() == BundleEvent.UNINSTALLED) {\n            counter.incrementAndGet();\n        }\n    }\n\n    public void run() {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Bundle watcher thread started\");\n        }\n        int oldCounter = -1;\n        Set<Bundle> watchedBundles = new HashSet<Bundle>();\n        while (running.get() && watchURLs.size()>0) {\n            if (oldCounter != counter.get()) {\n                oldCounter = counter.get();\n                watchedBundles.clear();\n                for (String bundleURL : watchURLs) {\n                    for (Bundle bundle : getBundlesByURL(bundleURL)) {\n                        watchedBundles.add(bundle);\n                    }\n                }\n            }\n            if (watchedBundles.size()>0) {\n                File localRepository = getLocalRepository();\n                for (Bundle bundle : watchedBundles) {\n                    try {\n                        File location = getBundleExternalLocation(localRepository, bundle);\n                        if (location != null\n                                && location.exists()\n                                && location.lastModified() > bundle.getLastModified())\n                        {\n                            InputStream is = new FileInputStream(location);\n                            try {\n                                System.out.println(\"[Watch] Updating watched bundle: \" + bundle.getSymbolicName() + \" (\" + bundle.getVersion() + \")\");\n                                bundle.update(is);\n                            } finally {\n                                is.close();\n                            }\n                        }\n                    } catch (IOException ex) {\n                        logger.error(\"Error watching bundle.\", ex);\n                    } catch (BundleException ex) {\n                        logger.error(\"Error updating bundle.\", ex);\n                    }\n                }\n            }\n            try {\n                Thread.sleep(interval);\n            } catch (InterruptedException ex) {\n                running.set(false);\n            }\n        }\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Bundle watcher thread stopped\");\n        }\n    }\n\n    /**\n     * Adds a Bundle URLs to the watch list.\n     * @param url\n     */\n    public void add(String url) {\n        boolean shouldStart = running.get() && (watchURLs.size()==0);\n        if (!watchURLs.contains(url)) {\n            watchURLs.add(url);\n            counter.incrementAndGet();\n        }\n        if (shouldStart) {\n            Thread thread = new Thread(this);\n            thread.start();\n        }\n    }\n\n    /**\n     * Removes a bundle URLs from the watch list.\n     * @param url\n     */\n    public void remove(String url) {\n        watchURLs.remove(url);\n        counter.incrementAndGet();\n    }\n\n    /**\n     * Returns the location of the Bundle inside the local maven repository.\n     * @param bundle\n     * @return\n     */\n    public File getBundleExternalLocation(File localRepository, Bundle bundle) {\n        try {\n            Parser p = new Parser(bundle.getLocation().substring(4));\n            return new File(localRepository.getPath() + File.separator + p.getArtifactPath());\n        } catch (MalformedURLException e) {\n            logger.error(\"Could not parse artifact path for bundle\" + bundle.getSymbolicName(), e);\n        }\n        return null;\n    }\n\n    public File getLocalRepository() {\n        // Attempt to retrieve local repository location from MavenConfiguration\n        MavenConfiguration configuration = retrieveMavenConfiguration();\n        if (configuration != null) {\n            MavenRepositoryURL localRepositoryURL = configuration.getLocalRepository();\n            if (localRepositoryURL != null) {\n                return localRepositoryURL.getFile().getAbsoluteFile();\n            }\n        }\n        // If local repository not found assume default.\n        String localRepo = System.getProperty(\"user.home\") + File.separator + \".m2\" + File.separator + \"repository\";\n        return new File(localRepo).getAbsoluteFile();\n    }\n\n    protected MavenConfiguration retrieveMavenConfiguration() {\n        MavenConfiguration mavenConfiguration = null;\n        try {\n            Configuration configuration = configurationAdmin.getConfiguration(ServiceConstants.PID);\n            if (configuration != null) {\n                Dictionary dictonary = configuration.getProperties();\n                if (dictonary != null) {\n                    DictionaryPropertyResolver resolver = new DictionaryPropertyResolver(dictonary);\n                    mavenConfiguration = new MavenConfigurationImpl(resolver, ServiceConstants.PID);\n                }\n            }\n        } catch (IOException e) {\n            logger.error(\"Error retrieving maven configuration\",e);\n        }\n        return mavenConfiguration;\n    }\n\n    /**\n     * Returns the bundles that match\n     * @param url\n     * @return\n     */\n    public List<Bundle> getBundlesByURL(String url) {\n        List<Bundle> bundleList = new ArrayList<Bundle>();\n        try {\n            Long id = Long.parseLong(url);\n            Bundle bundle = bundleContext.getBundle(id);\n            if (bundle != null) {\n                bundleList.add(bundle);\n            }\n        } catch (NumberFormatException e) {\n            for (int i = 0; i < bundleContext.getBundles().length; i++) {\n                Bundle bundle = bundleContext.getBundles()[i];\n                if (isMavenSnapshotUrl(bundle.getLocation()) && wildCardMatch(bundle.getLocation(), url)) {\n                    bundleList.add(bundle);\n                }\n            }\n        }\n        return bundleList;\n    }\n\n    protected boolean isMavenSnapshotUrl(String url) {\n        return url.startsWith(\"mvn:\") && url.contains(\"-SNAPSHOT\");\n    }\n\n    /**\n     * Matches text using a pattern containing wildcards.\n     *\n     * @param text\n     * @param pattern\n     * @return\n     */\n    protected boolean wildCardMatch(String text, String pattern) {\n        String[] cards = pattern.split(\"\\\\*\");\n        // Iterate over the cards.\n        for (String card : cards) {\n            int idx = text.indexOf(card);\n            // Card not detected in the text.\n            if (idx == -1) {\n                return false;\n            }\n\n            // Move ahead, towards the right of the text.\n            text = text.substring(idx + card.length());\n        }\n        return true;\n    }\n\n\n    public void start() {\n        if (running.compareAndSet(false, true)) {\n            if (watchURLs.size()>0) {\n                Thread thread = new Thread(this);\n                thread.start();\n            }\n        }\n    }\n\n    /**\n     * Stops the execution of the thread and releases the singleton instance\n     */\n    public void stop() {\n        running.set(false);\n    }\n\n    public ConfigurationAdmin getConfigurationAdmin() {\n        return configurationAdmin;\n    }\n\n    public void setConfigurationAdmin(ConfigurationAdmin configurationAdmin) {\n        this.configurationAdmin = configurationAdmin;\n    }\n\n    public BundleContext getBundleContext() {\n        return bundleContext;\n    }\n\n    public void setBundleContext(BundleContext bundleContext) {\n        this.bundleContext = bundleContext;\n    }\n\n    public List<String> getWatchURLs() {\n        return watchURLs;\n    }\n\n    public void setWatchURLs(List<String> watchURLs) {\n        this.watchURLs = watchURLs;\n    }\n\n    public long getInterval() {\n        return interval;\n    }\n\n    public void setInterval(long interval) {\n        this.interval = interval;\n    }\n\n    public boolean isRunning() {\n        return running.get();\n    }\n\n}", "class_id": 0, "repo": "tonit/karafonexam2", "file": "shell/dev/src/main/java/org/apache/karaf/shell/dev/watch/BundleWatcher.java", "last_update_at": "2020-11-04T07:00:04+00:00", "question_id": "26a4299e1e00e69d2b72ef73fe98d474ee2b4767", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BundleWatcher implements Runnable, BundleListener {\n    private final Logger logger = LoggerFactory.getLogger(BundleWatcher.class);\n    private BundleContext bundleContext;\n    private ConfigurationAdmin configurationAdmin;\n    private AtomicBoolean running = new AtomicBoolean(false);\n    private long interval = 1000L;\n    private List<String> watchURLs = new CopyOnWriteArrayList<String>();\n    private AtomicInteger counter = new AtomicInteger(0);\n    /**\n     * Construcotr\n     */\n    public BundleWatcher() {\n    }\n    public void bundleChanged(BundleEvent event) {\n        if (event.getType() == BundleEvent.INSTALLED\n                || event.getType() == BundleEvent.UNINSTALLED) {\n            counter.incrementAndGet();\n        }\n    }\n    public void run() {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Bundle watcher thread started\");\n        }\n        int oldCounter = -1;\n        Set<Bundle> watchedBundles = new HashSet<Bundle>();\n        while (running.get() && watchURLs.size()>0) {\n            if (oldCounter != counter.get()) {\n                oldCounter = counter.get();\n                watchedBundles.clear();\n                for (String bundleURL : watchURLs) {\n                    for (Bundle bundle : getBundlesByURL(bundleURL)) {\n                        watchedBundles.add(bundle);\n                    }\n                }\n            }\n            if (watchedBundles.size()>0) {\n                File localRepository = getLocalRepository();\n                for (Bundle bundle : watchedBundles) {\n                    try {\n                        File location = getBundleExternalLocation(localRepository, bundle);\n                        if (location != null\n                                && location.exists()\n                                && location.lastModified() > bundle.getLastModified())\n                        {\n                            InputStream is = new FileInputStream(location);\n                            try {\n                                System.out.println(\"[Watch] Updating watched bundle: \" + bundle.getSymbolicName() + \" (\" + bundle.getVersion() + \")\");\n                                bundle.update(is);\n                            } finally {\n                                is.close();\n                            }\n                        }\n                    } catch (IOException ex) {\n                        logger.error(\"Error watching bundle.\", ex);\n                    } catch (BundleException ex) {\n                        logger.error(\"Error updating bundle.\", ex);\n                    }\n                }\n            }\n            try {\n                Thread.sleep(interval);\n            } catch (InterruptedException ex) {\n                running.set(false);\n            }\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Bundle watcher thread stopped\");\n        }\n    }\n    /**\n     * Adds a Bundle URLs to the watch list.\n     * @param url\n     */\n    public void add(String url) {\n        boolean shouldStart = running.get() && (watchURLs.size()==0);\n        if (!watchURLs.contains(url)) {\n            watchURLs.add(url);\n            counter.incrementAndGet();\n        }\n        if (shouldStart) {\n            Thread thread = new Thread(this);\n            thread.start();\n        }\n    }\n    /**\n     * Removes a bundle URLs from the watch list.\n     * @param url\n     */\n    public void remove(String url) {\n        watchURLs.remove(url);\n        counter.incrementAndGet();\n    }\n    /**\n     * Returns the location of the Bundle inside the local maven repository.\n     * @param bundle\n     * @return\n     */\n    public File getBundleExternalLocation(File localRepository, Bundle bundle) {\n        try {\n            Parser p = new Parser(bundle.getLocation().substring(4));\n            return new File(localRepository.getPath() + File.separator + p.getArtifactPath());\n        } catch (MalformedURLException e) {\n            logger.error(\"Could not parse artifact path for bundle\" + bundle.getSymbolicName(), e);\n        }\n        return null;\n    }\n    public File getLocalRepository() {\n        // Attempt to retrieve local repository location from MavenConfiguration\n        MavenConfiguration configuration = retrieveMavenConfiguration();\n        if (configuration != null) {\n            MavenRepositoryURL localRepositoryURL = configuration.getLocalRepository();\n            if (localRepositoryURL != null) {\n                return localRepositoryURL.getFile().getAbsoluteFile();\n            }\n        }\n        // If local repository not found assume default.\n        String localRepo = System.getProperty(\"user.home\") + File.separator + \".m2\" + File.separator + \"repository\";\n        return new File(localRepo).getAbsoluteFile();\n    }\n    protected MavenConfiguration retrieveMavenConfiguration() {\n        MavenConfiguration mavenConfiguration = null;\n        try {\n            Configuration configuration = configurationAdmin.getConfiguration(ServiceConstants.PID);\n            if (configuration != null) {\n                Dictionary dictonary = configuration.getProperties();\n                if (dictonary != null) {\n                    DictionaryPropertyResolver resolver = new DictionaryPropertyResolver(dictonary);\n                    mavenConfiguration = new MavenConfigurationImpl(resolver, ServiceConstants.PID);\n                }\n            }\n        } catch (IOException e) {\n            logger.error(\"Error retrieving maven configuration\",e);\n        }\n        return mavenConfiguration;\n    }\n    /**\n     * Returns the bundles that match\n     * @param url\n     * @return\n     */\n    public List<Bundle> getBundlesByURL(String url) {\n        List<Bundle> bundleList = new ArrayList<Bundle>();\n        try {\n            Long id = Long.parseLong(url);\n            Bundle bundle = bundleContext.getBundle(id);\n            if (bundle != null) {\n                bundleList.add(bundle);\n            }\n        } catch (NumberFormatException e) {\n            for (int i = 0; i < bundleContext.getBundles().length; i++) {\n                Bundle bundle = bundleContext.getBundles()[i];\n                if (isMavenSnapshotUrl(bundle.getLocation()) && wildCardMatch(bundle.getLocation(), url)) {\n                    bundleList.add(bundle);\n                }\n            }\n        }\n        return bundleList;\n    }\n    protected boolean isMavenSnapshotUrl(String url) {\n        return url.startsWith(\"mvn:\") && url.contains(\"-SNAPSHOT\");\n    }\n    /**\n     * Matches text using a pattern containing wildcards.\n     *\n     * @param text\n     * @param pattern\n     * @return\n     */\n    protected boolean wildCardMatch(String text, String pattern) {\n        String[] cards = pattern.split(\"\\\\*\");\n        // Iterate over the cards.\n        for (String card : cards) {\n            int idx = text.indexOf(card);\n            // Card not detected in the text.\n            if (idx == -1) {\n                return false;\n            }\n            // Move ahead, towards the right of the text.\n            text = text.substring(idx + card.length());\n        }\n        return true;\n    }\n    public void start() {\n        if (running.compareAndSet(false, true)) {\n            if (watchURLs.size()>0) {\n                Thread thread = new Thread(this);\n                thread.start();\n            }\n        }\n    }\n    /**\n     * Stops the execution of the thread and releases the singleton instance\n     */\n    public void stop() {\n        running.set(false);\n    }\n    public ConfigurationAdmin getConfigurationAdmin() {\n        return configurationAdmin;\n    }\n    public void setConfigurationAdmin(ConfigurationAdmin configurationAdmin) {\n        this.configurationAdmin = configurationAdmin;\n    }\n    public BundleContext getBundleContext() {\n        return bundleContext;\n    }\n    public void setBundleContext(BundleContext bundleContext) {\n        this.bundleContext = bundleContext;\n    }\n    public List<String> getWatchURLs() {\n        return watchURLs;\n    }\n    public void setWatchURLs(List<String> watchURLs) {\n        this.watchURLs = watchURLs;\n    }\n    public long getInterval() {\n        return interval;\n    }\n    public void setInterval(long interval) {\n        this.interval = interval;\n    }\n    public boolean isRunning() {\n        return running.get();\n    }\n"]]}
{"hexsha": "cf8d089649c6d4b70a4e05e41f112ac9b266964a", "ext": "java", "lang": "Java", "content": "@Component\npublic class DatabaseLoader implements CommandLineRunner {\n\n\t@Autowired\n    private CustomerRepository custRepo;\n    @Autowired\n    private AccountRepository acctRepo;\n    @Autowired\n    private TransactionRepository transRepo;\n\n    @Autowired\n    public DatabaseLoader(CustomerRepository custRepo, AccountRepository acctRepo, TransactionRepository transRepo) {\n\t\tthis.custRepo = custRepo;\n\t\tthis.acctRepo = acctRepo;\n\t\tthis.transRepo = transRepo;\n\t}\n\n\t@Override\n\tpublic void run(String... args) throws Exception {\n\t\tCustomer chris = new Customer(\"cj\", \"password\", \"Chris Jabb\",\"chrisjabb@aol.com\",\"nowhere\", \"1233334545\");\n\t\tCustomer matt = new Customer(\"mk\", \"password\", \"Matty K\",\"servethesovietunion@lol.com\",\"everwhere\",\"2223334545\");\n\t\tCustomer nat = new Customer(\"nn\", \"password\", \"Natasha Ng\",\"nn@yahoo.com\",\"Seattle\",\"3123334545\");\n\t\tCustomer dan = new Customer(\"db\", \"password\", \"Danny B\",\"danny@netscape.com\",\"somewhere\", \"693334545\");\n\t\t\n\t\tAccount chrisAcct = new Account();\n\t\tchris.addCustomerToAccount(chrisAcct);\n\t\tSystem.out.println(chrisAcct.getCustomersOnAccount());\n\t\tSystem.out.println(chris.getAccounts());\n\t\tAccount natAcct = new Account(AccountType.SAVINGS);\n\t\tnat.addCustomerToAccount(natAcct);\n\t\tAccount danXMatt = new Account(AccountType.BROKERAGE);\n\t\tdan.addCustomerToAccount(danXMatt);\n\t\tmatt.addCustomerToAccount(danXMatt);\n\t\t\n\t\tTransaction trans1 = chrisAcct.deposit(100.0, \"Initial deposit\");\n\t\tTransaction trans2 = chrisAcct.withdraw(10.0, \"Money for lunch\");\n\t\tTransaction trans3 = danXMatt.deposit(1000.0, \"Init dep\");\n\t\tTransaction trans4 = natAcct.deposit(1000000.0, \"Nats a high roller\");\n\t\t\n\t\tthis.custRepo.save(chris);\n\t\tthis.custRepo.save(matt);\n\t\tthis.custRepo.save(nat);\n\t\tthis.custRepo.save(dan);\n\t\t\n\t\tthis.acctRepo.save(chrisAcct);\n\t\tthis.acctRepo.save(natAcct);\n\t\tthis.acctRepo.save(danXMatt);\n\t\t\n\t\tthis.transRepo.save(trans1);\n\t\tthis.transRepo.save(trans2);\n\t\tthis.transRepo.save(trans3);\n\t\tthis.transRepo.save(trans4);\n\t}\n    \n}", "class_id": 0, "repo": "dgbirm/HabiBank", "file": "src/main/java/com/habibank/DatabaseLoader.java", "last_update_at": "2020-09-04T14:07:44+00:00", "question_id": "cf8d089649c6d4b70a4e05e41f112ac9b266964a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\npublic class DatabaseLoader implements CommandLineRunner {\n\t@Autowired\n    private CustomerRepository custRepo;\n    @Autowired\n    private AccountRepository acctRepo;\n    @Autowired\n    private TransactionRepository transRepo;\n    @Autowired\n    public DatabaseLoader(CustomerRepository custRepo, AccountRepository acctRepo, TransactionRepository transRepo) {\n\t\tthis.custRepo = custRepo;\n\t\tthis.acctRepo = acctRepo;\n\t\tthis.transRepo = transRepo;\n\t}\n\t@Override\n\tpublic void run(String... args) throws Exception {\n\t\tCustomer chris = new Customer(\"cj\", \"password\", \"Chris Jabb\",\"chrisjabb@aol.com\",\"nowhere\", \"1233334545\");\n\t\tCustomer matt = new Customer(\"mk\", \"password\", \"Matty K\",\"servethesovietunion@lol.com\",\"everwhere\",\"2223334545\");\n\t\tCustomer nat = new Customer(\"nn\", \"password\", \"Natasha Ng\",\"nn@yahoo.com\",\"Seattle\",\"3123334545\");\n\t\tCustomer dan = new Customer(\"db\", \"password\", \"Danny B\",\"danny@netscape.com\",\"somewhere\", \"693334545\");\n\t\t\n\t\tAccount chrisAcct = new Account();\n\t\tchris.addCustomerToAccount(chrisAcct);\n\t\tSystem.out.println(chrisAcct.getCustomersOnAccount());\n\t\tSystem.out.println(chris.getAccounts());\n\t\tAccount natAcct = new Account(AccountType.SAVINGS);\n\t\tnat.addCustomerToAccount(natAcct);\n\t\tAccount danXMatt = new Account(AccountType.BROKERAGE);\n\t\tdan.addCustomerToAccount(danXMatt);\n\t\tmatt.addCustomerToAccount(danXMatt);\n\t\t\n\t\tTransaction trans1 = chrisAcct.deposit(100.0, \"Initial deposit\");\n\t\tTransaction trans2 = chrisAcct.withdraw(10.0, \"Money for lunch\");\n\t\tTransaction trans3 = danXMatt.deposit(1000.0, \"Init dep\");\n\t\tTransaction trans4 = natAcct.deposit(1000000.0, \"Nats a high roller\");\n\t\t\n\t\tthis.custRepo.save(chris);\n\t\tthis.custRepo.save(matt);\n\t\tthis.custRepo.save(nat);\n\t\tthis.custRepo.save(dan);\n\t\t\n\t\tthis.acctRepo.save(chrisAcct);\n\t\tthis.acctRepo.save(natAcct);\n\t\tthis.acctRepo.save(danXMatt);\n\t\t\n\t\tthis.transRepo.save(trans1);\n\t\tthis.transRepo.save(trans2);\n\t\tthis.transRepo.save(trans3);\n\t\tthis.transRepo.save(trans4);\n\t}\n"]]}
{"hexsha": "f6b4a9b676fe80667155d8f146a030d1b66e63d4", "ext": "java", "lang": "Java", "content": "public class AsyncHistoryJobHandler extends AbstractAsyncHistoryJobHandler {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(AsyncHistoryJobHandler.class);\n\n    public static final String JOB_TYPE = \"async-history\";\n\n    protected Map<String, List<HistoryJsonTransformer>> historyJsonTransformers = new HashMap<>();\n\n    @Override\n    public String getType() {\n        return JOB_TYPE;\n    }\n\n    public void initDefaultTransformers() {\n        addHistoryJsonTransformer(new ProcessInstanceStartHistoryJsonTransformer());\n        addHistoryJsonTransformer(new ProcessInstanceEndHistoryJsonTransformer());\n        addHistoryJsonTransformer(new ProcessInstanceDeleteHistoryJsonTransformer());\n        addHistoryJsonTransformer(new ProcessInstanceDeleteHistoryByProcessDefinitionIdJsonTransformer());\n        addHistoryJsonTransformer(new ProcessInstancePropertyChangedHistoryJsonTransformer());\n        addHistoryJsonTransformer(new SubProcessInstanceHistoryJsonTransformer());\n        addHistoryJsonTransformer(new SetProcessDefinitionHistoryJsonTransformer());\n\n        addHistoryJsonTransformer(new ActivityStartHistoryJsonTransformer());\n        addHistoryJsonTransformer(new ActivityEndHistoryJsonTransformer());\n        addHistoryJsonTransformer(new ActivityFullHistoryJsonTransformer());\n\n        addHistoryJsonTransformer(new TaskCreatedHistoryJsonTransformer());\n        addHistoryJsonTransformer(new TaskEndedHistoryJsonTransformer());\n\n        addHistoryJsonTransformer(new TaskPropertyChangedHistoryJsonTransformer());\n        addHistoryJsonTransformer(new TaskAssigneeChangedHistoryJsonTransformer());\n        addHistoryJsonTransformer(new TaskOwnerChangedHistoryJsonTransformer());\n        \n        addHistoryJsonTransformer(new IdentityLinkCreatedHistoryJsonTransformer());\n        addHistoryJsonTransformer(new IdentityLinkDeletedHistoryJsonTransformer());\n        \n        addHistoryJsonTransformer(new VariableCreatedHistoryJsonTransformer());\n        addHistoryJsonTransformer(new VariableUpdatedHistoryJsonTransformer());\n        addHistoryJsonTransformer(new VariableRemovedHistoryJsonTransformer());\n        addHistoryJsonTransformer(new HistoricDetailVariableUpdateHistoryJsonTransformer());\n        addHistoryJsonTransformer(new FormPropertiesSubmittedHistoryJsonTransformer());\n    }\n\n    public void addHistoryJsonTransformer(HistoryJsonTransformer historyJsonTransformer) {\n        String type = historyJsonTransformer.getType();\n        if (!historyJsonTransformers.containsKey(type)) {\n            historyJsonTransformers.put(type, new ArrayList<HistoryJsonTransformer>());\n        }\n        historyJsonTransformers.get(historyJsonTransformer.getType()).add(historyJsonTransformer);\n    }\n\n    @Override\n    protected void processHistoryJson(CommandContext commandContext, HistoryJobEntity job, JsonNode historyNode) {\n        \n        String type = historyNode.get(HistoryJsonConstants.TYPE).asText();\n        ObjectNode historicalJsonData = (ObjectNode) historyNode.get(HistoryJsonConstants.DATA);\n\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Handling async history job (id={}, type={})\", job.getId(), type);\n        }\n\n        List<HistoryJsonTransformer> transformers = historyJsonTransformers.get(type);\n        if (transformers != null && !transformers.isEmpty()) {\n            for (HistoryJsonTransformer transformer : transformers) {\n                if (transformer.isApplicable(historicalJsonData, commandContext)) {\n                    transformer.transformJson(job, historicalJsonData, commandContext);\n\n                } else {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(\"Could not handle history job (id={}) for transformer {}. as it is not applicable. Unacquiring. {}\", job.getId(), transformer.getType(), historicalJsonData);\n                    }\n                    throw new AsyncHistoryJobNotApplicableException();\n\n                }\n            }\n        } else {\n            LOGGER.debug(\"Cannot transform history json: no transformers found for type {}\", type);\n        }\n    }\n\n    public Map<String, List<HistoryJsonTransformer>> getHistoryJsonTransformers() {\n        return historyJsonTransformers;\n    }\n\n    public void setHistoryJsonTransformers(Map<String, List<HistoryJsonTransformer>> historyJsonTransformers) {\n        this.historyJsonTransformers = historyJsonTransformers;\n    }\n\n}", "class_id": 0, "repo": "ingensky/flowable-engine", "file": "modules/flowable-engine/src/main/java/org/flowable/engine/impl/history/async/AsyncHistoryJobHandler.java", "last_update_at": "2020-05-25T11:36:33+00:00", "question_id": "f6b4a9b676fe80667155d8f146a030d1b66e63d4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AsyncHistoryJobHandler extends AbstractAsyncHistoryJobHandler {\n    private static final Logger LOGGER = LoggerFactory.getLogger(AsyncHistoryJobHandler.class);\n    public static final String JOB_TYPE = \"async-history\";\n    protected Map<String, List<HistoryJsonTransformer>> historyJsonTransformers = new HashMap<>();\n    @Override\n    public String getType() {\n        return JOB_TYPE;\n    }\n    public void initDefaultTransformers() {\n        addHistoryJsonTransformer(new ProcessInstanceStartHistoryJsonTransformer());\n        addHistoryJsonTransformer(new ProcessInstanceEndHistoryJsonTransformer());\n        addHistoryJsonTransformer(new ProcessInstanceDeleteHistoryJsonTransformer());\n        addHistoryJsonTransformer(new ProcessInstanceDeleteHistoryByProcessDefinitionIdJsonTransformer());\n        addHistoryJsonTransformer(new ProcessInstancePropertyChangedHistoryJsonTransformer());\n        addHistoryJsonTransformer(new SubProcessInstanceHistoryJsonTransformer());\n        addHistoryJsonTransformer(new SetProcessDefinitionHistoryJsonTransformer());\n        addHistoryJsonTransformer(new ActivityStartHistoryJsonTransformer());\n        addHistoryJsonTransformer(new ActivityEndHistoryJsonTransformer());\n        addHistoryJsonTransformer(new ActivityFullHistoryJsonTransformer());\n        addHistoryJsonTransformer(new TaskCreatedHistoryJsonTransformer());\n        addHistoryJsonTransformer(new TaskEndedHistoryJsonTransformer());\n        addHistoryJsonTransformer(new TaskPropertyChangedHistoryJsonTransformer());\n        addHistoryJsonTransformer(new TaskAssigneeChangedHistoryJsonTransformer());\n        addHistoryJsonTransformer(new TaskOwnerChangedHistoryJsonTransformer());\n        addHistoryJsonTransformer(new IdentityLinkCreatedHistoryJsonTransformer());\n        addHistoryJsonTransformer(new IdentityLinkDeletedHistoryJsonTransformer());\n        addHistoryJsonTransformer(new VariableCreatedHistoryJsonTransformer());\n        addHistoryJsonTransformer(new VariableUpdatedHistoryJsonTransformer());\n        addHistoryJsonTransformer(new VariableRemovedHistoryJsonTransformer());\n        addHistoryJsonTransformer(new HistoricDetailVariableUpdateHistoryJsonTransformer());\n        addHistoryJsonTransformer(new FormPropertiesSubmittedHistoryJsonTransformer());\n    }\n    public void addHistoryJsonTransformer(HistoryJsonTransformer historyJsonTransformer) {\n        String type = historyJsonTransformer.getType();\n        if (!historyJsonTransformers.containsKey(type)) {\n            historyJsonTransformers.put(type, new ArrayList<HistoryJsonTransformer>());\n        }\n        historyJsonTransformers.get(historyJsonTransformer.getType()).add(historyJsonTransformer);\n    }\n    @Override\n    protected void processHistoryJson(CommandContext commandContext, HistoryJobEntity job, JsonNode historyNode) {\n        String type = historyNode.get(HistoryJsonConstants.TYPE).asText();\n        ObjectNode historicalJsonData = (ObjectNode) historyNode.get(HistoryJsonConstants.DATA);\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Handling async history job (id={}, type={})\", job.getId(), type);\n        }\n        List<HistoryJsonTransformer> transformers = historyJsonTransformers.get(type);\n        if (transformers != null && !transformers.isEmpty()) {\n            for (HistoryJsonTransformer transformer : transformers) {\n                if (transformer.isApplicable(historicalJsonData, commandContext)) {\n                    transformer.transformJson(job, historicalJsonData, commandContext);\n                } else {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(\"Could not handle history job (id={}) for transformer {}. as it is not applicable. Unacquiring. {}\", job.getId(), transformer.getType(), historicalJsonData);\n                    }\n                    throw new AsyncHistoryJobNotApplicableException();\n                }\n            }\n        } else {\n            LOGGER.debug(\"Cannot transform history json: no transformers found for type {}\", type);\n        }\n    }\n    public Map<String, List<HistoryJsonTransformer>> getHistoryJsonTransformers() {\n        return historyJsonTransformers;\n    }\n    public void setHistoryJsonTransformers(Map<String, List<HistoryJsonTransformer>> historyJsonTransformers) {\n        this.historyJsonTransformers = historyJsonTransformers;\n    }\n"]]}
{"hexsha": "970f5700706d07e21a4327e16524f72c8de70fa5", "ext": "java", "lang": "Java", "content": "public class AuthVerticle extends AbstractVerticle {\n\n    @Override\n    public void start() throws Exception {\n        super.start();\n        HttpServer server = vertx.createHttpServer();\n        Router router = Router.router(vertx);\n        router.post(\"/login\").handler(BodyHandler.create());\n        router.post(\"/login\").handler(this::login);\n        router.get(\"/validAccessToken/:token\").handler(this::validToken);\n        router.post(\"/refreshToken\").handler(BodyHandler.create());\n        router.post(\"/refreshToken\").handler(this::refreshToken);\n        router.post(\"/recoverPass\").handler(BodyHandler.create());\n        router.post(\"/recoverPass\").handler(this::recoverPass);\n        router.post(\"/restorePass\").handler(BodyHandler.create());\n        router.post(\"/restorePass\").handler(this::restorePass);\n        router.post(\"/resetPass\").handler(BodyHandler.create());\n        router.post(\"/resetPass\").handler(this::resetPass);\n        UtilsRouter.getInstance(vertx).mountSubRouter(\"/auth\", router);\n        Integer portNumber = config().getInteger(CONFIG_HTTP_SERVER_PORT);\n        if (portNumber == null) {\n            System.out.println(\"Could not start a HTTP server\" + this.getClass().getSimpleName() + \", no port speficied in configuration\");\n        }\n        server.requestHandler(UtilsRouter.getInstance(vertx)::accept)\n                .listen(portNumber, ar -> {\n                    if (ar.succeeded()) {\n                        System.out.println(this.getClass().getSimpleName() + \" running\");\n                    } else {\n                        System.out.println(\"Could not start a HTTP server \" + this.getClass().getSimpleName() + \", \" + ar.cause());\n                    }\n                });\n    }\n\n    private void login(RoutingContext context) {\n        JsonObject body = context.getBodyAsJson();\n        String email = body.getString(\"email\");\n        String pass = UtilsSecurity.encodeSHA256(body.getString(\"pass\"));\n        JsonObject send = new JsonObject()\n                .put(\"email\", email)\n                .put(\"pass\", pass);\n        DeliveryOptions options = new DeliveryOptions().addHeader(ACTION, EmployeeDBV.ACTION_LOGIN);\n        this.vertx.eventBus().send(EmployeeDBV.class.getSimpleName(), send, options,\n                (AsyncResult<Message<JsonObject>> reply) -> {\n                    if (reply.succeeded()) {\n                        if (reply.result().body() == null) {\n                            UtilsResponse.responseWarning(context, \"User and/or password are invalid\");\n                        } else {\n                            JsonObject result = reply.result().body();\n                            result.put(\"accessToken\", UtilsJWT.generateAccessToken(result.getInteger(\"id\")))\n                                    .put(\"refreshToken\", UtilsJWT.generateRefreshToken(result.getInteger(\"id\")));\n                            UtilsResponse.responseOk(context, result);\n                        }\n                    } else {\n                        responseError(context, UNEXPECTED_ERROR, reply.cause().getMessage());\n                    }\n                });\n\n    }\n\n    private void validToken(RoutingContext context) {\n        String token = context.request().getParam(\"token\");\n        if (UtilsJWT.isAccessTokenValid(token)) {\n            UtilsResponse.responseOk(context, \"valid\");\n        } else {\n            UtilsResponse.responseWarning(context, \"not valid\");\n        }\n    }\n\n    private void refreshToken(RoutingContext context) {\n        try {\n            JsonObject body = context.getBodyAsJson();\n            JsonObject newAccessToken = UtilsJWT.refreshToken(body.getString(\"refreshToken\"), body.getString(\"accessToken\"));\n            UtilsResponse.responseOk(context, new JsonObject().put(\"newAccessToken\", newAccessToken));\n        } catch (RefreshException ex) {\n            UtilsResponse.responseWarning(context, ex.getMessage(), ex.getRefreshProblem());\n        } catch (Exception ex) {\n            UtilsResponse.responseWarning(context, ex.getMessage());\n        }\n    }\n\n    private void recoverPass(RoutingContext context) {\n        JsonObject body = context.getBodyAsJson();\n        this.vertx.eventBus().send(\n                EmployeeDBV.class.getSimpleName(),\n                body, new DeliveryOptions().addHeader(ACTION, EmployeeDBV.ACTION_FIND_BY_MAIL),\n                (AsyncResult<Message<JsonObject>> reply) -> {\n                    if (reply.succeeded()) {\n                        if (reply.result().body() != null) {\n                            Random r = new Random();\n                            //generar codigo de 8 digitos aleatorios\n                            String code = String.valueOf(r.nextInt(99));\n                            code += String.valueOf(r.nextInt(99));\n                            code += String.valueOf(r.nextInt(99));\n                            code += String.valueOf(r.nextInt(99));\n\n                            final String employeeMail = reply.result().body().getString(\"email\");\n                            final String recoverCode = code;\n\n                            JsonObject send = new JsonObject()\n                                    .put(\"employee_email\", employeeMail)\n                                    .put(\"employee_name\", reply.result().body().getString(\"name\"))\n                                    .put(\"recover_code\", recoverCode);\n\n                            this.vertx.eventBus().send(MailVerticle.class.getSimpleName(), send,\n                                    new DeliveryOptions()\n                                            .addHeader(ACTION, MailVerticle.ACTION_SEND_RECOVER_PASS),\n                                    mailReply -> {\n                                        if (mailReply.succeeded()) {\n                                            String jws = UtilsJWT.generateRecoverPasswordToken(recoverCode, employeeMail);\n                                            responseOk(context, new JsonObject()\n                                                    .put(\"recover_token\", jws), \"Mail with code sended\");\n                                        } else {\n                                            responseWarning(context, \"can't send mail\",\n                                                    mailReply.cause().getMessage());\n                                        }\n                                    });\n                        } else {\n                            responseWarning(context, \"Employee not found\");\n                        }\n                    } else {\n                        responseWarning(context, \"can't found employee\", reply.cause().getMessage());\n                    }\n                }\n        );\n    }\n\n    private void restorePass(RoutingContext context) {\n        JsonObject body = context.getBodyAsJson();\n        String recoverCode = body.getString(\"recoverCode\");\n        String recoverToken = body.getString(\"recoverToken\");\n        String newPassword = body.getString(\"newPassword\");\n        UtilsJWT.RecoverValidation validation = UtilsJWT.isRecoverTokenMatching(recoverToken, recoverCode);\n        if (validation.isValid()) {\n            JsonObject send = new JsonObject()\n                    .put(\"employee_email\", validation.getEmployeeMail())\n                    .put(\"new_password\", UtilsSecurity.encodeSHA256(newPassword));\n            DeliveryOptions options = new DeliveryOptions().addHeader(ACTION, EmployeeDBV.ACTION_UPDATE_PASSWORD);\n            this.vertx.eventBus().send(EmployeeDBV.class.getSimpleName(), send, options, reply -> {\n                if (reply.succeeded()) {\n                    responseOk(context, \"Password restored\");\n                } else {\n                    responseError(context, reply.cause().getMessage());\n                }\n            });\n        } else {\n            UtilsResponse.responseWarning(context, \"Recover code or recover token are not matching\");\n        }\n    }\n\n    private void resetPass(RoutingContext context) {\n        String token = context.request().headers().get(AUTHORIZATION);\n        if (UtilsJWT.isAccessTokenValid(token)) {\n            JsonObject body = context.getBodyAsJson();\n            try {\n                UtilsValidation.isGraterEqualAndNotNull(body, \"employee_id\", 0);\n                UtilsValidation.isEmptyAndNotNull(body, \"actual_pass\");\n                UtilsValidation.isEmptyAndNotNull(body, \"new_pass\");\n                int employeeId = UtilsJWT.getEmployeeIdFrom(token);\n                String actualPass = body.getString(\"actual_pass\");\n                String newPass = body.getString(\"new_pass\");\n                if (newPass.equals(actualPass)) {\n                    responseWarning(context, \"The new password can not be equal to the previous one\");\n                    return;\n                }\n                String actualPassEncoded = UtilsSecurity.encodeSHA256(actualPass);\n                String newPassEncoded = UtilsSecurity.encodeSHA256(newPass);\n\n                DeliveryOptions options = new DeliveryOptions()\n                        .addHeader(ACTION, EmployeeDBV.ACTION_VALIDATE_PASS);\n\n                this.vertx.eventBus().send(EmployeeDBV.class.getSimpleName(),\n                        new JsonObject()\n                                .put(\"employee_id\", employeeId)\n                                .put(\"pass\", actualPassEncoded),\n                        options,\n                        reply -> {\n                            if (reply.succeeded()) {\n                                //update pass\n                                DeliveryOptions optionsUpdate = new DeliveryOptions()\n                                        .addHeader(ACTION, EmployeeDBV.ACTION_RESET_PASS);\n                                this.vertx.eventBus().send(EmployeeDBV.class.getSimpleName(),\n                                        new JsonObject()\n                                                .put(\"employee_id\", employeeId)\n                                                .put(\"pass\", newPassEncoded),\n                                        optionsUpdate,\n                                        updateReply -> {\n                                            if (updateReply.succeeded()) {\n                                                responseOk(context, \"Pass reseted\");\n                                            } else {\n                                                responseError(context, updateReply.cause().getMessage());\n                                            }\n                                        });\n                            } else {\n                                responseWarning(context, \"Invalid actual password\");\n                            }\n                        });\n            } catch (UtilsValidation.PropertyValueException ex) {\n                responsePropertyValue(context, ex);\n            }\n        } else {\n            UtilsResponse.responseInvalidToken(context);\n        }\n    }\n\n}", "class_id": 0, "repo": "BeltranGomezUlises/VertxAuth", "file": "src/main/java/service/AuthVerticle.java", "last_update_at": "2020-11-23T07:07:33+00:00", "question_id": "970f5700706d07e21a4327e16524f72c8de70fa5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AuthVerticle extends AbstractVerticle {\n    @Override\n    public void start() throws Exception {\n        super.start();\n        HttpServer server = vertx.createHttpServer();\n        Router router = Router.router(vertx);\n        router.post(\"/login\").handler(BodyHandler.create());\n        router.post(\"/login\").handler(this::login);\n        router.get(\"/validAccessToken/:token\").handler(this::validToken);\n        router.post(\"/refreshToken\").handler(BodyHandler.create());\n        router.post(\"/refreshToken\").handler(this::refreshToken);\n        router.post(\"/recoverPass\").handler(BodyHandler.create());\n        router.post(\"/recoverPass\").handler(this::recoverPass);\n        router.post(\"/restorePass\").handler(BodyHandler.create());\n        router.post(\"/restorePass\").handler(this::restorePass);\n        router.post(\"/resetPass\").handler(BodyHandler.create());\n        router.post(\"/resetPass\").handler(this::resetPass);\n        UtilsRouter.getInstance(vertx).mountSubRouter(\"/auth\", router);\n        Integer portNumber = config().getInteger(CONFIG_HTTP_SERVER_PORT);\n        if (portNumber == null) {\n            System.out.println(\"Could not start a HTTP server\" + this.getClass().getSimpleName() + \", no port speficied in configuration\");\n        }\n        server.requestHandler(UtilsRouter.getInstance(vertx)::accept)\n                .listen(portNumber, ar -> {\n                    if (ar.succeeded()) {\n                        System.out.println(this.getClass().getSimpleName() + \" running\");\n                    } else {\n                        System.out.println(\"Could not start a HTTP server \" + this.getClass().getSimpleName() + \", \" + ar.cause());\n                    }\n                });\n    }\n    private void login(RoutingContext context) {\n        JsonObject body = context.getBodyAsJson();\n        String email = body.getString(\"email\");\n        String pass = UtilsSecurity.encodeSHA256(body.getString(\"pass\"));\n        JsonObject send = new JsonObject()\n                .put(\"email\", email)\n                .put(\"pass\", pass);\n        DeliveryOptions options = new DeliveryOptions().addHeader(ACTION, EmployeeDBV.ACTION_LOGIN);\n        this.vertx.eventBus().send(EmployeeDBV.class.getSimpleName(), send, options,\n                (AsyncResult<Message<JsonObject>> reply) -> {\n                    if (reply.succeeded()) {\n                        if (reply.result().body() == null) {\n                            UtilsResponse.responseWarning(context, \"User and/or password are invalid\");\n                        } else {\n                            JsonObject result = reply.result().body();\n                            result.put(\"accessToken\", UtilsJWT.generateAccessToken(result.getInteger(\"id\")))\n                                    .put(\"refreshToken\", UtilsJWT.generateRefreshToken(result.getInteger(\"id\")));\n                            UtilsResponse.responseOk(context, result);\n                        }\n                    } else {\n                        responseError(context, UNEXPECTED_ERROR, reply.cause().getMessage());\n                    }\n                });\n    }\n    private void validToken(RoutingContext context) {\n        String token = context.request().getParam(\"token\");\n        if (UtilsJWT.isAccessTokenValid(token)) {\n            UtilsResponse.responseOk(context, \"valid\");\n        } else {\n            UtilsResponse.responseWarning(context, \"not valid\");\n        }\n    }\n    private void refreshToken(RoutingContext context) {\n        try {\n            JsonObject body = context.getBodyAsJson();\n            JsonObject newAccessToken = UtilsJWT.refreshToken(body.getString(\"refreshToken\"), body.getString(\"accessToken\"));\n            UtilsResponse.responseOk(context, new JsonObject().put(\"newAccessToken\", newAccessToken));\n        } catch (RefreshException ex) {\n            UtilsResponse.responseWarning(context, ex.getMessage(), ex.getRefreshProblem());\n        } catch (Exception ex) {\n            UtilsResponse.responseWarning(context, ex.getMessage());\n        }\n    }\n    private void recoverPass(RoutingContext context) {\n        JsonObject body = context.getBodyAsJson();\n        this.vertx.eventBus().send(\n                EmployeeDBV.class.getSimpleName(),\n                body, new DeliveryOptions().addHeader(ACTION, EmployeeDBV.ACTION_FIND_BY_MAIL),\n                (AsyncResult<Message<JsonObject>> reply) -> {\n                    if (reply.succeeded()) {\n                        if (reply.result().body() != null) {\n                            Random r = new Random();\n                            //generar codigo de 8 digitos aleatorios\n                            String code = String.valueOf(r.nextInt(99));\n                            code += String.valueOf(r.nextInt(99));\n                            code += String.valueOf(r.nextInt(99));\n                            code += String.valueOf(r.nextInt(99));\n                            final String employeeMail = reply.result().body().getString(\"email\");\n                            final String recoverCode = code;\n                            JsonObject send = new JsonObject()\n                                    .put(\"employee_email\", employeeMail)\n                                    .put(\"employee_name\", reply.result().body().getString(\"name\"))\n                                    .put(\"recover_code\", recoverCode);\n                            this.vertx.eventBus().send(MailVerticle.class.getSimpleName(), send,\n                                    new DeliveryOptions()\n                                            .addHeader(ACTION, MailVerticle.ACTION_SEND_RECOVER_PASS),\n                                    mailReply -> {\n                                        if (mailReply.succeeded()) {\n                                            String jws = UtilsJWT.generateRecoverPasswordToken(recoverCode, employeeMail);\n                                            responseOk(context, new JsonObject()\n                                                    .put(\"recover_token\", jws), \"Mail with code sended\");\n                                        } else {\n                                            responseWarning(context, \"can't send mail\",\n                                                    mailReply.cause().getMessage());\n                                        }\n                                    });\n                        } else {\n                            responseWarning(context, \"Employee not found\");\n                        }\n                    } else {\n                        responseWarning(context, \"can't found employee\", reply.cause().getMessage());\n                    }\n                }\n        );\n    }\n    private void restorePass(RoutingContext context) {\n        JsonObject body = context.getBodyAsJson();\n        String recoverCode = body.getString(\"recoverCode\");\n        String recoverToken = body.getString(\"recoverToken\");\n        String newPassword = body.getString(\"newPassword\");\n        UtilsJWT.RecoverValidation validation = UtilsJWT.isRecoverTokenMatching(recoverToken, recoverCode);\n        if (validation.isValid()) {\n            JsonObject send = new JsonObject()\n                    .put(\"employee_email\", validation.getEmployeeMail())\n                    .put(\"new_password\", UtilsSecurity.encodeSHA256(newPassword));\n            DeliveryOptions options = new DeliveryOptions().addHeader(ACTION, EmployeeDBV.ACTION_UPDATE_PASSWORD);\n            this.vertx.eventBus().send(EmployeeDBV.class.getSimpleName(), send, options, reply -> {\n                if (reply.succeeded()) {\n                    responseOk(context, \"Password restored\");\n                } else {\n                    responseError(context, reply.cause().getMessage());\n                }\n            });\n        } else {\n            UtilsResponse.responseWarning(context, \"Recover code or recover token are not matching\");\n        }\n    }\n    private void resetPass(RoutingContext context) {\n        String token = context.request().headers().get(AUTHORIZATION);\n        if (UtilsJWT.isAccessTokenValid(token)) {\n            JsonObject body = context.getBodyAsJson();\n            try {\n                UtilsValidation.isGraterEqualAndNotNull(body, \"employee_id\", 0);\n                UtilsValidation.isEmptyAndNotNull(body, \"actual_pass\");\n                UtilsValidation.isEmptyAndNotNull(body, \"new_pass\");\n                int employeeId = UtilsJWT.getEmployeeIdFrom(token);\n                String actualPass = body.getString(\"actual_pass\");\n                String newPass = body.getString(\"new_pass\");\n                if (newPass.equals(actualPass)) {\n                    responseWarning(context, \"The new password can not be equal to the previous one\");\n                    return;\n                }\n                String actualPassEncoded = UtilsSecurity.encodeSHA256(actualPass);\n                String newPassEncoded = UtilsSecurity.encodeSHA256(newPass);\n                DeliveryOptions options = new DeliveryOptions()\n                        .addHeader(ACTION, EmployeeDBV.ACTION_VALIDATE_PASS);\n                this.vertx.eventBus().send(EmployeeDBV.class.getSimpleName(),\n                        new JsonObject()\n                                .put(\"employee_id\", employeeId)\n                                .put(\"pass\", actualPassEncoded),\n                        options,\n                        reply -> {\n                            if (reply.succeeded()) {\n                                //update pass\n                                DeliveryOptions optionsUpdate = new DeliveryOptions()\n                                        .addHeader(ACTION, EmployeeDBV.ACTION_RESET_PASS);\n                                this.vertx.eventBus().send(EmployeeDBV.class.getSimpleName(),\n                                        new JsonObject()\n                                                .put(\"employee_id\", employeeId)\n                                                .put(\"pass\", newPassEncoded),\n                                        optionsUpdate,\n                                        updateReply -> {\n                                            if (updateReply.succeeded()) {\n                                                responseOk(context, \"Pass reseted\");\n                                            } else {\n                                                responseError(context, updateReply.cause().getMessage());\n                                            }\n                                        });\n                            } else {\n                                responseWarning(context, \"Invalid actual password\");\n                            }\n                        });\n            } catch (UtilsValidation.PropertyValueException ex) {\n                responsePropertyValue(context, ex);\n            }\n        } else {\n            UtilsResponse.responseInvalidToken(context);\n        }\n    }\n"]]}
{"hexsha": "26b168b2343b574ff632b2240231b1a8d0111d1b", "ext": "java", "lang": "Java", "content": "public class UserDefinedTextWriter extends RecordWriter<UserDefinedDescriptiveText> {\n\n    @Override\n    public RecordType getRecordType() {\n        return RecordType.RT2_USER_DEFINED_TEXT;\n    }\n\n    @Override\n    public void write(OutputStream out, UserDefinedDescriptiveText record) throws IOException {\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        Writer writer = new OutputStreamWriter(buffer, NistHelper.USASCII);\n\n        String idc = String.format(\"%d.%03d:%d\", RecordType.RT2_USER_DEFINED_TEXT.type, 2, record.getIdc());\n        writer.write(idc);\n        writer.write(NistHelper.SEP_GS);\n\n        Map<Integer, String> userFields = record.getUserDefinedFields();\n        int count = 1;\n        for (Integer key : userFields.keySet()) {\n            if (key == null || key < 3) {\n                throw new IllegalArgumentException(\"User defined fields should be 2.003 and above\");\n            }\n            String tag = String.format(\"%d.%03d:\", RecordType.RT2_USER_DEFINED_TEXT.type, key);\n            writer.write(tag);\n\n            writer.write(userFields.get(key));\n\n            if (count < userFields.size()) {\n                writer.write(NistHelper.SEP_GS);\n            }\n            count++;\n        }\n\n        writer.flush();\n        \n        writeRecord(out, buffer);\n    }\n\n}", "class_id": 0, "repo": "thomasdav/jnbis", "file": "src/main/java/org/jnbis/internal/record/writer/UserDefinedTextWriter.java", "last_update_at": "2020-01-21T08:58:30+00:00", "question_id": "26b168b2343b574ff632b2240231b1a8d0111d1b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class UserDefinedTextWriter extends RecordWriter<UserDefinedDescriptiveText> {\n    @Override\n    public RecordType getRecordType() {\n        return RecordType.RT2_USER_DEFINED_TEXT;\n    }\n    @Override\n    public void write(OutputStream out, UserDefinedDescriptiveText record) throws IOException {\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        Writer writer = new OutputStreamWriter(buffer, NistHelper.USASCII);\n        String idc = String.format(\"%d.%03d:%d\", RecordType.RT2_USER_DEFINED_TEXT.type, 2, record.getIdc());\n        writer.write(idc);\n        writer.write(NistHelper.SEP_GS);\n        Map<Integer, String> userFields = record.getUserDefinedFields();\n        int count = 1;\n        for (Integer key : userFields.keySet()) {\n            if (key == null || key < 3) {\n                throw new IllegalArgumentException(\"User defined fields should be 2.003 and above\");\n            }\n            String tag = String.format(\"%d.%03d:\", RecordType.RT2_USER_DEFINED_TEXT.type, key);\n            writer.write(tag);\n            writer.write(userFields.get(key));\n            if (count < userFields.size()) {\n                writer.write(NistHelper.SEP_GS);\n            }\n            count++;\n        }\n        writer.flush();\n        writeRecord(out, buffer);\n    }\n"]]}
{"hexsha": "9052fb0897eef841b736fc7bc51610e7e6b9ceaa", "ext": "java", "lang": "Java", "content": "public class BinarySearchST<Key extends Comparable<Key>, Value> {\n    private Item[] items;\n    private int N;\n\n    private class Item implements Comparable<Item> {\n        public Key key;\n        public Value val;\n        Item(Key key, Value val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public void val(Value val) {\n            this.val = val;\n        }\n\n        public int compareTo(Item that) {\n            return this.key.compareTo(that.key);\n        }\n    }\n\n    public BinarySearchST() {\n        this(5);\n    }\n\n    public BinarySearchST(int capacity) {\n        items = new Item[capacity];\n    }\n\n    public BinarySearchST(Item[] items) {\n        this.items = items;\n        N = item.length;\n        sort(this.items, 0, N - 1);\n    }\n\n    public int size() {\n        return N;\n    }\n\n    public boolean isEmpty() {\n        return N == 0;\n    }\n\n    public Value get(Key key) {\n        if (isEmpty()) return null;\n        int i = rank(key);\n        if (i < N && items[i].key.compareTo(key) == 0) return items[i].val;\n        else return null;\n    }\n\n    public void put(Key key, Value val) {\n        int i = rank(key);\n        if (i < N && items[i].key.compareTo(key) == 0) {\n            items[i].val(val);\n            return;\n        }\n\n        for (int j = N; j > i; j--) {\n            items[j] = items[j - 1];\n        }\n        items[i] = new Item(key, val);\n        N++;\n        resize();\n    }\n\n    public Key min() {\n        return items[0].key;\n    }\n\n    public Key max() {\n        return items[N - 1].key;\n    }\n\n    public Key select(int k) {\n        return items[k].key;\n    }\n\n    public Key ceiling(Key key) {\n        int i = rank(key);\n        return items[i].key;\n    }\n\n    // public Key floor(Key key)\n\n    // public Key delete(Key key)\n\n    public int rank(Key key) {\n        int low = 0;\n        int high = N - 1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            int cmp = key.compareTo(items[mid].key);\n            if (cmp < 0) high = mid - 1;\n            else if (cmp > 0) low = mid + 1;\n            else return mid;\n        }\n        return low;\n    }\n\n    public Iterable<Key> keys(Key low, Key high) {\n        Queue<Key> q = new Queue<Key>();\n        for (int i = rank(low); i < rank(high); i++) {\n            q.enqueue(items[i].key);\n            if (ceiling(high) != null) {\n                q.enqueue(items[rank(high)].key);\n            }\n        }\n        return q;\n    }\n\n    private void resize() {\n        if (N <= items.length / 2) return;\n        int length = items.length * 2;\n        Item[] items = new Item[length];\n\n        for (int i = 0; i < N; i ++) {\n            items[i] = this.items[i];\n        }\n\n        this.items = items;\n    }\n\n    private static void sort(Comparable[] a, int low, int high) {\n        if (high <= low ) return;\n        int mid = low + (high - low) / 2;\n        sort(a, low, mid);\n        sort(a, mid + 1, high);\n        merge(a, low, mid, high);\n    }\n\n    public static void merge(Comparable[] a, int low, int mid, int high) {\n        int i = low;\n        int j = mid + 1;\n\n        for (int k = low; k <= high; k++) {\n            aux[k] = a[k];\n        }\n\n        for (int k = low; k <= high; k++) {\n            if (i > mid) a[k] = aux[j++];\n            else if (j > high) a[k] = aux[i++];\n            else if (less(aux[j], aux[i])) a[k] = aux[j++];\n            else a[k] = aux[i++];\n        }\n    }\n}", "class_id": 0, "repo": "HuangStomach/follow-gaylear", "file": "algs4/3.Search/3.1/Exercises/3.1.12.java", "last_update_at": "2020-06-20T13:28:56+00:00", "question_id": "9052fb0897eef841b736fc7bc51610e7e6b9ceaa", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BinarySearchST<Key extends Comparable<Key>, Value> {\n    private Item[] items;\n    private int N;\n    private class Item implements Comparable<Item> {\n        public Key key;\n        public Value val;\n        Item(Key key, Value val) {\n            this.key = key;\n            this.val = val;\n        }\n        public void val(Value val) {\n            this.val = val;\n        }\n        public int compareTo(Item that) {\n            return this.key.compareTo(that.key);\n        }\n    }\n    public BinarySearchST() {\n        this(5);\n    }\n    public BinarySearchST(int capacity) {\n        items = new Item[capacity];\n    }\n    public BinarySearchST(Item[] items) {\n        this.items = items;\n        N = item.length;\n        sort(this.items, 0, N - 1);\n    }\n    public int size() {\n        return N;\n    }\n    public boolean isEmpty() {\n        return N == 0;\n    }\n    public Value get(Key key) {\n        if (isEmpty()) return null;\n        int i = rank(key);\n        if (i < N && items[i].key.compareTo(key) == 0) return items[i].val;\n        else return null;\n    }\n    public void put(Key key, Value val) {\n        int i = rank(key);\n        if (i < N && items[i].key.compareTo(key) == 0) {\n            items[i].val(val);\n            return;\n        }\n        for (int j = N; j > i; j--) {\n            items[j] = items[j - 1];\n        }\n        items[i] = new Item(key, val);\n        N++;\n        resize();\n    }\n    public Key min() {\n        return items[0].key;\n    }\n    public Key max() {\n        return items[N - 1].key;\n    }\n    public Key select(int k) {\n        return items[k].key;\n    }\n    public Key ceiling(Key key) {\n        int i = rank(key);\n        return items[i].key;\n    }\n    // public Key floor(Key key)\n    // public Key delete(Key key)\n    public int rank(Key key) {\n        int low = 0;\n        int high = N - 1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            int cmp = key.compareTo(items[mid].key);\n            if (cmp < 0) high = mid - 1;\n            else if (cmp > 0) low = mid + 1;\n            else return mid;\n        }\n        return low;\n    }\n    public Iterable<Key> keys(Key low, Key high) {\n        Queue<Key> q = new Queue<Key>();\n        for (int i = rank(low); i < rank(high); i++) {\n            q.enqueue(items[i].key);\n            if (ceiling(high) != null) {\n                q.enqueue(items[rank(high)].key);\n            }\n        }\n        return q;\n    }\n    private void resize() {\n        if (N <= items.length / 2) return;\n        int length = items.length * 2;\n        Item[] items = new Item[length];\n        for (int i = 0; i < N; i ++) {\n            items[i] = this.items[i];\n        }\n        this.items = items;\n    }\n    private static void sort(Comparable[] a, int low, int high) {\n        if (high <= low ) return;\n        int mid = low + (high - low) / 2;\n        sort(a, low, mid);\n        sort(a, mid + 1, high);\n        merge(a, low, mid, high);\n    }\n    public static void merge(Comparable[] a, int low, int mid, int high) {\n        int i = low;\n        int j = mid + 1;\n        for (int k = low; k <= high; k++) {\n            aux[k] = a[k];\n        }\n        for (int k = low; k <= high; k++) {\n            if (i > mid) a[k] = aux[j++];\n            else if (j > high) a[k] = aux[i++];\n            else if (less(aux[j], aux[i])) a[k] = aux[j++];\n            else a[k] = aux[i++];\n        }\n    }\n"]]}
{"hexsha": "554241ecd65ac518af6fe99d9e10ce9745118665", "ext": "java", "lang": "Java", "content": "public class WebDriverAppiumHelper extends WebDriverCommonHelper {\n\n    /***\n     * Default constructor.\n     */\n    public WebDriverAppiumHelper() {\n    }\n\n    public WebDriverAppiumHelper(Platform platform, int webDriverTimeout, TestLog testLog) {\n        setLogger(testLog);\n        setAppiumTheMainUsage(true);\n        setWebDriverWaitTimeoutSeconds(webDriverTimeout);\n        setDevicePlatform(platform);\n\n\n        warnStfUsage();\n    }\n    // region Common Area\n\n    /***\n     * Helper to send values to an web element.\n     * @param platform What platform?\n     * @param selectorType: What is the type of this selector? What selector?\n     * @param selectorId: The element selector.\n     * @param value: The value to be be sent.\n     * @throws Exception\n     */\n    public void sendKeys(Platform platform, SelectorType selectorType, String selectorId, String value) throws Exception {\n        WebElement element = first(selectorType, selectorId);\n        switch (platform) {\n            case ANDROID:\n                element.sendKeys(value);\n                break;\n            case IOS:\n                IOSElement tempElement = (IOSElement) element;\n                tempElement.setValue(value);\n                break;\n            default:\n                throw new Exception(String.format(\"The webdriver platform %1$s is not supported yet.\", platform.toString()));\n        }\n    }\n\n    /**\n     * This helper performs a click in a element.\n     * The difference between this helper and a _common First.Click() is that this one is intended to Mobile elements instead regular WebElements - otherwise I can guarantee that you'll face instabilities while testing Apps.\n     *\n     * @param selectorType: What is the type of this selector? What selector?\n     * @param selectorId:   The element selector.\n     * @throws Exception\n     */\n    public void tap(SelectorType selectorType, String selectorId) throws Exception {\n        MobileElement element;\n        element = (MobileElement) first(selectorType, selectorId);\n        element.click();\n    }\n\n    //endregion\n\n    // region iOS Area\n\n    /***\n     *  Helper to send values to an web element for iOS.\n     * @param selectorType: What is the type of this selector? What selector?\n     * @param selectorId: The element selector.\n     * @param value: The value to be be sent.\n     * @throws Exception\n     */\n    public void sendKeysToiOS(SelectorType selectorType, String selectorId, String value) throws Exception {\n        sendKeys(Platform.IOS, selectorType, selectorId, value);\n    }\n    // endregion\n\n    // region Android Area\n\n    /***\n     * Helper to send values to an web element for Android.\n     * @param selectorType: What is the type of this selector? What selector?\n     * @param selectorId: The element selector.\n     * @param value: The value to be be sent.\n     * @throws Exception\n     */\n    public void sendKeysToAndroid(SelectorType selectorType, String selectorId, String value) throws Exception {\n        sendKeys(Platform.ANDROID, selectorType, selectorId, value);\n    }\n    // endregion\n}", "class_id": 0, "repo": "LaudateCorpus1/smart-test-framework", "file": "stf-webdriver-lib/src/main/java/com/github/jeansantos38/stf/framework/webdriver/WebDriverAppiumHelper.java", "last_update_at": "2020-06-08T16:29:56+00:00", "question_id": "554241ecd65ac518af6fe99d9e10ce9745118665", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class WebDriverAppiumHelper extends WebDriverCommonHelper {\n    /***\n     * Default constructor.\n     */\n    public WebDriverAppiumHelper() {\n    }\n    public WebDriverAppiumHelper(Platform platform, int webDriverTimeout, TestLog testLog) {\n        setLogger(testLog);\n        setAppiumTheMainUsage(true);\n        setWebDriverWaitTimeoutSeconds(webDriverTimeout);\n        setDevicePlatform(platform);\n        warnStfUsage();\n    }\n    // region Common Area\n    /***\n     * Helper to send values to an web element.\n     * @param platform What platform?\n     * @param selectorType: What is the type of this selector? What selector?\n     * @param selectorId: The element selector.\n     * @param value: The value to be be sent.\n     * @throws Exception\n     */\n    public void sendKeys(Platform platform, SelectorType selectorType, String selectorId, String value) throws Exception {\n        WebElement element = first(selectorType, selectorId);\n        switch (platform) {\n            case ANDROID:\n                element.sendKeys(value);\n                break;\n            case IOS:\n                IOSElement tempElement = (IOSElement) element;\n                tempElement.setValue(value);\n                break;\n            default:\n                throw new Exception(String.format(\"The webdriver platform %1$s is not supported yet.\", platform.toString()));\n        }\n    }\n    /**\n     * This helper performs a click in a element.\n     * The difference between this helper and a _common First.Click() is that this one is intended to Mobile elements instead regular WebElements - otherwise I can guarantee that you'll face instabilities while testing Apps.\n     *\n     * @param selectorType: What is the type of this selector? What selector?\n     * @param selectorId:   The element selector.\n     * @throws Exception\n     */\n    public void tap(SelectorType selectorType, String selectorId) throws Exception {\n        MobileElement element;\n        element = (MobileElement) first(selectorType, selectorId);\n        element.click();\n    }\n    //endregion\n    // region iOS Area\n    /***\n     *  Helper to send values to an web element for iOS.\n     * @param selectorType: What is the type of this selector? What selector?\n     * @param selectorId: The element selector.\n     * @param value: The value to be be sent.\n     * @throws Exception\n     */\n    public void sendKeysToiOS(SelectorType selectorType, String selectorId, String value) throws Exception {\n        sendKeys(Platform.IOS, selectorType, selectorId, value);\n    }\n    // endregion\n    // region Android Area\n    /***\n     * Helper to send values to an web element for Android.\n     * @param selectorType: What is the type of this selector? What selector?\n     * @param selectorId: The element selector.\n     * @param value: The value to be be sent.\n     * @throws Exception\n     */\n    public void sendKeysToAndroid(SelectorType selectorType, String selectorId, String value) throws Exception {\n        sendKeys(Platform.ANDROID, selectorType, selectorId, value);\n    }\n    // endregion\n"]]}
{"hexsha": "9d20f169b97cef480ba19001efb76699d41b2a9c", "ext": "java", "lang": "Java", "content": "public class JSONPluginTaskDataBuilder extends PluginTaskDataBuilder<JSONTaskData> {\n\n\tprivate PluginDataSource<JSONTaskData> dataSource;\n\t\n\tpublic static JSONPluginTaskDataBuilder newBuilder() {\n\t\treturn new JSONPluginTaskDataBuilder();\n\t}\n\n\tpublic JSONPluginTaskDataBuilder withDataSource( PluginDataSource<JSONTaskData> dataSource) {\n\t\tthis.dataSource = dataSource;\n\t\treturn this;\n\t}\n\t\n\t@Override\n\tpublic PluginJobDetailImpl<JSONTaskData> build() {\n\t\t// TODO Auto-generated method stub\n\t\tJSONPluginJobDetailImpl impl = new JSONPluginJobDetailImpl();\n\t\timpl.setDataSource(dataSource);\n\t\treturn impl;\n\t}\n}", "class_id": 0, "repo": "kutasms/ksf", "file": "akka-base/src/main/java/com/kuta/akka/base/auto/JSONPluginTaskDataBuilder.java", "last_update_at": "2020-09-02T17:09:31+00:00", "question_id": "9d20f169b97cef480ba19001efb76699d41b2a9c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class JSONPluginTaskDataBuilder extends PluginTaskDataBuilder<JSONTaskData> {\n\tprivate PluginDataSource<JSONTaskData> dataSource;\n\t\n\tpublic static JSONPluginTaskDataBuilder newBuilder() {\n\t\treturn new JSONPluginTaskDataBuilder();\n\t}\n\tpublic JSONPluginTaskDataBuilder withDataSource( PluginDataSource<JSONTaskData> dataSource) {\n\t\tthis.dataSource = dataSource;\n\t\treturn this;\n\t}\n\t\n\t@Override\n\tpublic PluginJobDetailImpl<JSONTaskData> build() {\n\t\t// TODO Auto-generated method stub\n\t\tJSONPluginJobDetailImpl impl = new JSONPluginJobDetailImpl();\n\t\timpl.setDataSource(dataSource);\n\t\treturn impl;\n\t}\n"]]}
{"hexsha": "7689c960ebf8aa8b481ebe906ceddf32bae6a0a0", "ext": "java", "lang": "Java", "content": "public class DataSetProvider extends ResourceProvider<DataSetResourceDescriptor> {\n\n    private final DBUnitConfiguration configuration;\n\n    public DataSetProvider(MetadataExtractor metadataExtractor, DBUnitConfiguration configuration) {\n        super(UsingDataSet.class, metadataExtractor);\n        this.configuration = configuration;\n    }\n\n    @Override\n    protected DataSetResourceDescriptor createDescriptor(String resource) {\n        return new DataSetResourceDescriptor(determineLocation(resource), inferFormat(resource));\n    }\n\n    @Override\n    protected String defaultLocation() {\n        return configuration.getDefaultDataSetLocation();\n    }\n\n    @Override\n    protected String defaultFileName() {\n        Format format = configuration.getDefaultDataSetFormat();\n        return new DataSetFileNamingStrategy(format).createFileName(metadataExtractor.getJavaClass());\n    }\n\n    @Override\n    public Collection<String> getResourceFileNames(Method testMethod) {\n        UsingDataSet dataAnnotation = getResourceAnnotation(testMethod);\n        String[] specifiedFileNames = dataAnnotation.value();\n        if (specifiedFileNames.length == 0 || \"\".equals(specifiedFileNames[0].trim())) {\n            return singletonList(getDefaultFileName(testMethod));\n        }\n        return asList(specifiedFileNames);\n    }\n\n    // Private methods\n\n    private Format inferFormat(String dataFileName) {\n        Format format = Format.inferFromFile(dataFileName);\n        if (Format.UNSUPPORTED.equals(format)) {\n            throw new UnsupportedDataFormatException(\"File \" + dataFileName + \" is not supported as data set format.\");\n        }\n        return format;\n    }\n\n    Collection<Format> getDataFormats(Method testMethod) {\n        final List<Format> formats = new ArrayList<Format>();\n        for (String dataFileName : getResourceFileNames(testMethod)) {\n            formats.add(inferFormat(dataFileName));\n        }\n        return formats;\n    }\n\n    private UsingDataSet getResourceAnnotation(Method testMethod) {\n        return metadataExtractor.usingDataSet().fetchUsingFirst(testMethod);\n    }\n\n    private String getDefaultFileName(Method testMethod) {\n        Format format = configuration.getDefaultDataSetFormat();\n\n        if (metadataExtractor.usingDataSet().isDefinedOn(testMethod)) {\n            return new DataSetFileNamingStrategy(format).createFileName(metadataExtractor.getJavaClass(), testMethod);\n        }\n\n        return new DataSetFileNamingStrategy(format).createFileName(metadataExtractor.getJavaClass());\n    }\n}", "class_id": 0, "repo": "FlakyTestDetection/arquillian-extension-persistence", "file": "dbunit/src/main/java/org/jboss/arquillian/persistence/dbunit/data/provider/DataSetProvider.java", "last_update_at": "2020-07-04T09:06:20+00:00", "question_id": "7689c960ebf8aa8b481ebe906ceddf32bae6a0a0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DataSetProvider extends ResourceProvider<DataSetResourceDescriptor> {\n    private final DBUnitConfiguration configuration;\n    public DataSetProvider(MetadataExtractor metadataExtractor, DBUnitConfiguration configuration) {\n        super(UsingDataSet.class, metadataExtractor);\n        this.configuration = configuration;\n    }\n    @Override\n    protected DataSetResourceDescriptor createDescriptor(String resource) {\n        return new DataSetResourceDescriptor(determineLocation(resource), inferFormat(resource));\n    }\n    @Override\n    protected String defaultLocation() {\n        return configuration.getDefaultDataSetLocation();\n    }\n    @Override\n    protected String defaultFileName() {\n        Format format = configuration.getDefaultDataSetFormat();\n        return new DataSetFileNamingStrategy(format).createFileName(metadataExtractor.getJavaClass());\n    }\n    @Override\n    public Collection<String> getResourceFileNames(Method testMethod) {\n        UsingDataSet dataAnnotation = getResourceAnnotation(testMethod);\n        String[] specifiedFileNames = dataAnnotation.value();\n        if (specifiedFileNames.length == 0 || \"\".equals(specifiedFileNames[0].trim())) {\n            return singletonList(getDefaultFileName(testMethod));\n        }\n        return asList(specifiedFileNames);\n    }\n    // Private methods\n    private Format inferFormat(String dataFileName) {\n        Format format = Format.inferFromFile(dataFileName);\n        if (Format.UNSUPPORTED.equals(format)) {\n            throw new UnsupportedDataFormatException(\"File \" + dataFileName + \" is not supported as data set format.\");\n        }\n        return format;\n    }\n    Collection<Format> getDataFormats(Method testMethod) {\n        final List<Format> formats = new ArrayList<Format>();\n        for (String dataFileName : getResourceFileNames(testMethod)) {\n            formats.add(inferFormat(dataFileName));\n        }\n        return formats;\n    }\n    private UsingDataSet getResourceAnnotation(Method testMethod) {\n        return metadataExtractor.usingDataSet().fetchUsingFirst(testMethod);\n    }\n    private String getDefaultFileName(Method testMethod) {\n        Format format = configuration.getDefaultDataSetFormat();\n        if (metadataExtractor.usingDataSet().isDefinedOn(testMethod)) {\n            return new DataSetFileNamingStrategy(format).createFileName(metadataExtractor.getJavaClass(), testMethod);\n        }\n        return new DataSetFileNamingStrategy(format).createFileName(metadataExtractor.getJavaClass());\n    }\n"]]}
{"hexsha": "05c6490c464f5fe68a723607c022f40d54fc7439", "ext": "java", "lang": "Java", "content": "public final class StyleAndScriptIdentifier extends AbstractMarkupFilter\r\n{\r\n\t/**\r\n\t * Constructor.\r\n\t */\r\n\tpublic StyleAndScriptIdentifier()\r\n\t{\r\n\t}\r\n\r\n\t@Override\r\n\tprotected final MarkupElement onComponentTag(final ComponentTag tag) throws ParseException\r\n\t{\r\n\t\tif (tag.getNamespace() != null)\r\n\t\t{\r\n\t\t\treturn tag;\r\n\t\t}\r\n\r\n\t\tString tagName = tag.getName();\r\n\t\tboolean isScript = XmlPullParser.SCRIPT.equalsIgnoreCase(tagName);\r\n\t\tboolean isStyle = XmlPullParser.STYLE.equalsIgnoreCase(tagName);\r\n\t\tif (isScript || isStyle)\r\n\t\t{\r\n\t\t\tif (tag.isOpen() && tag.getId() == null && ((isScript && tag.getAttribute(\"src\") == null) || isStyle))\r\n\t\t\t{\r\n\t\t\t\t// Not needed, but must not be null\r\n\t\t\t\ttag.setId(\"_ScriptStyle\");\r\n\t\t\t\ttag.setModified(true);\r\n\t\t\t\ttag.setAutoComponentTag(true);\r\n\t\t\t\ttag.setFlag(ComponentTag.RENDER_RAW, true);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttag.setUserData(\"STYLE_OR_SCRIPT\", Boolean.TRUE);\r\n\t\t}\r\n\r\n\t\treturn tag;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void postProcess(Markup markup)\r\n\t{\r\n\t\tfor (int i = 0; i < markup.size(); i++)\r\n\t\t{\r\n\t\t\tMarkupElement elem = markup.get(i);\r\n\t\t\tif (elem instanceof ComponentTag)\r\n\t\t\t{\r\n\t\t\t\tComponentTag open = (ComponentTag)elem;\r\n\r\n\t\t\t\tif (shouldProcess(open))\r\n\t\t\t\t{\r\n\t\t\t\t\tif (open.isOpen() && ((i + 2) < markup.size()))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tMarkupElement body = markup.get(i + 1);\r\n\t\t\t\t\t\tMarkupElement tag2 = markup.get(i + 2);\r\n\r\n\t\t\t\t\t\tif ((body instanceof RawMarkup) && (tag2 instanceof ComponentTag))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tComponentTag close = (ComponentTag)tag2;\r\n\t\t\t\t\t\t\tif (close.closes(open))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tString text = body.toString().trim();\r\n\t\t\t\t\t\t\t\tif (shouldWrapInCdata(text))\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\ttext = JavaScriptUtils.SCRIPT_CONTENT_PREFIX + body.toString() +\r\n\t\t\t\t\t\t\t\t\t\tJavaScriptUtils.SCRIPT_CONTENT_SUFFIX;\r\n\t\t\t\t\t\t\t\t\tmarkup.replace(i + 1, new RawMarkup(text));\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// OES == optional empty space\r\n\r\n\t// OES<!--OES\r\n\tprivate static final Pattern HTML_START_COMMENT = Pattern.compile(\"^\\\\s*<!--\\\\s*.*\", Pattern.DOTALL);\r\n\r\n\t// OES<![CDATA[OES\r\n\tprivate static final Pattern CDATA_START_COMMENT = Pattern.compile(\"^\\\\s*<!\\\\[CDATA\\\\[\\\\s*.*\", Pattern.DOTALL);\r\n\r\n\t// OES/*OES<![CDATA[OES*/OES\r\n\tprivate static final Pattern JS_CDATA_START_COMMENT = Pattern.compile(\"^\\\\s*\\\\/\\\\*\\\\s*<!\\\\[CDATA\\\\[\\\\s*\\\\*\\\\/\\\\s*.*\", Pattern.DOTALL);\r\n\r\n\tboolean shouldWrapInCdata(final String elementBody)\r\n\t{\r\n\t\tArgs.notNull(elementBody, \"elementBody\");\r\n\r\n\t\tboolean shouldWrap = true;\r\n\r\n\t\tif (\r\n\t\t\t\tHTML_START_COMMENT.matcher(elementBody).matches() ||\r\n\t\t\t\tCDATA_START_COMMENT.matcher(elementBody).matches() ||\r\n\t\t\t\tJS_CDATA_START_COMMENT.matcher(elementBody).matches()\r\n\t\t\t)\r\n\t\t{\r\n\t\t\tshouldWrap = false;\r\n\t\t}\r\n\r\n\t\treturn shouldWrap;\r\n\t}\r\n\r\n\tprivate boolean shouldProcess(ComponentTag openTag)\r\n\t{\r\n\t\t// do not wrap in CDATA any <script> which has special MIME type. WICKET-4425\r\n\t\tString typeAttribute = openTag.getAttribute(\"type\");\r\n\t\tboolean shouldProcess =\r\n\t\t\t\t// style elements should be processed\r\n\t\t\t\t\"style\".equals(openTag.getName()) ||\r\n\r\n\t\t\t\t// script elements should be processed only if they have no type (HTML5 recommendation)\r\n\t\t\t\t// or the type is \"text/javascript\"\r\n\t\t\t\t(typeAttribute == null || \"text/javascript\".equalsIgnoreCase(typeAttribute));\r\n\r\n\t\treturn shouldProcess && openTag.getUserData(\"STYLE_OR_SCRIPT\") != null;\r\n\t}\r\n}", "class_id": 0, "repo": "mat128/wicket", "file": "wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/StyleAndScriptIdentifier.java", "last_update_at": "2020-08-14T15:54:10+00:00", "question_id": "05c6490c464f5fe68a723607c022f40d54fc7439", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class StyleAndScriptIdentifier extends AbstractMarkupFilter\r\n{\r\n\t/**\r\n\t * Constructor.\r\n\t */\r\n\tpublic StyleAndScriptIdentifier()\r\n\t{\r\n\t}\r\n\r\n\t@Override\r\n\tprotected final MarkupElement onComponentTag(final ComponentTag tag) throws ParseException\r\n\t{\r\n\t\tif (tag.getNamespace() != null)\r\n\t\t{\r\n\t\t\treturn tag;\r\n\t\t}\r\n\r\n\t\tString tagName = tag.getName();\r\n\t\tboolean isScript = XmlPullParser.SCRIPT.equalsIgnoreCase(tagName);\r\n\t\tboolean isStyle = XmlPullParser.STYLE.equalsIgnoreCase(tagName);\r\n\t\tif (isScript || isStyle)\r\n\t\t{\r\n\t\t\tif (tag.isOpen() && tag.getId() == null && ((isScript && tag.getAttribute(\"src\") == null) || isStyle))\r\n\t\t\t{\r\n\t\t\t\t// Not needed, but must not be null\r\n\t\t\t\ttag.setId(\"_ScriptStyle\");\r\n\t\t\t\ttag.setModified(true);\r\n\t\t\t\ttag.setAutoComponentTag(true);\r\n\t\t\t\ttag.setFlag(ComponentTag.RENDER_RAW, true);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttag.setUserData(\"STYLE_OR_SCRIPT\", Boolean.TRUE);\r\n\t\t}\r\n\r\n\t\treturn tag;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void postProcess(Markup markup)\r\n\t{\r\n\t\tfor (int i = 0; i < markup.size(); i++)\r\n\t\t{\r\n\t\t\tMarkupElement elem = markup.get(i);\r\n\t\t\tif (elem instanceof ComponentTag)\r\n\t\t\t{\r\n\t\t\t\tComponentTag open = (ComponentTag)elem;\r\n\r\n\t\t\t\tif (shouldProcess(open))\r\n\t\t\t\t{\r\n\t\t\t\t\tif (open.isOpen() && ((i + 2) < markup.size()))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tMarkupElement body = markup.get(i + 1);\r\n\t\t\t\t\t\tMarkupElement tag2 = markup.get(i + 2);\r\n\r\n\t\t\t\t\t\tif ((body instanceof RawMarkup) && (tag2 instanceof ComponentTag))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tComponentTag close = (ComponentTag)tag2;\r\n\t\t\t\t\t\t\tif (close.closes(open))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tString text = body.toString().trim();\r\n\t\t\t\t\t\t\t\tif (shouldWrapInCdata(text))\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\ttext = JavaScriptUtils.SCRIPT_CONTENT_PREFIX + body.toString() +\r\n\t\t\t\t\t\t\t\t\t\tJavaScriptUtils.SCRIPT_CONTENT_SUFFIX;\r\n\t\t\t\t\t\t\t\t\tmarkup.replace(i + 1, new RawMarkup(text));\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// OES == optional empty space\r\n\r\n\t// OES<!--OES\r\n\tprivate static final Pattern HTML_START_COMMENT = Pattern.compile(\"^\\\\s*<!--\\\\s*.*\", Pattern.DOTALL);\r\n\r\n\t// OES<![CDATA[OES\r\n\tprivate static final Pattern CDATA_START_COMMENT = Pattern.compile(\"^\\\\s*<!\\\\[CDATA\\\\[\\\\s*.*\", Pattern.DOTALL);\r\n\r\n\t// OES/*OES<![CDATA[OES*/OES\r\n\tprivate static final Pattern JS_CDATA_START_COMMENT = Pattern.compile(\"^\\\\s*\\\\/\\\\*\\\\s*<!\\\\[CDATA\\\\[\\\\s*\\\\*\\\\/\\\\s*.*\", Pattern.DOTALL);\r\n\r\n\tboolean shouldWrapInCdata(final String elementBody)\r\n\t{\r\n\t\tArgs.notNull(elementBody, \"elementBody\");\r\n\r\n\t\tboolean shouldWrap = true;\r\n\r\n\t\tif (\r\n\t\t\t\tHTML_START_COMMENT.matcher(elementBody).matches() ||\r\n\t\t\t\tCDATA_START_COMMENT.matcher(elementBody).matches() ||\r\n\t\t\t\tJS_CDATA_START_COMMENT.matcher(elementBody).matches()\r\n\t\t\t)\r\n\t\t{\r\n\t\t\tshouldWrap = false;\r\n\t\t}\r\n\r\n\t\treturn shouldWrap;\r\n\t}\r\n\r\n\tprivate boolean shouldProcess(ComponentTag openTag)\r\n\t{\r\n\t\t// do not wrap in CDATA any <script> which has special MIME type. WICKET-4425\r\n\t\tString typeAttribute = openTag.getAttribute(\"type\");\r\n\t\tboolean shouldProcess =\r\n\t\t\t\t// style elements should be processed\r\n\t\t\t\t\"style\".equals(openTag.getName()) ||\r\n\r\n\t\t\t\t// script elements should be processed only if they have no type (HTML5 recommendation)\r\n\t\t\t\t// or the type is \"text/javascript\"\r\n\t\t\t\t(typeAttribute == null || \"text/javascript\".equalsIgnoreCase(typeAttribute));\r\n\r\n\t\treturn shouldProcess && openTag.getUserData(\"STYLE_OR_SCRIPT\") != null;\r\n\t}\r\n"]]}
{"hexsha": "ca9fd8d092b14c7dafbb7c112860fd752d8984d0", "ext": "java", "lang": "Java", "content": "public class VirtualMemoryTest {\n    private VirtualMemory vm;\n    private MemoryPage page;\n    private Memory mem;\n    private byte[] bytes;\n\n    @Before\n    public void setup() {\n        vm = new JavaVirtualMemory();\n        bytes = new byte[32];\n        mem = new ByteMemory(bytes);\n        page = new MemoryPage(mem, 0, bytes.length);\n        vm.add(page);\n        vm.setBrk(32);\n    }\n\n    @Test\n    public void compute001() {\n        int val = 0xF0000021;\n        long address = 0x00000000;\n        vm.setI32(address, val);\n        assertEquals(0xF0000021, vm.getI32(address));\n    }\n\n    @Test\n    public void brk001() {\n        long start = vm.brk();\n        assertEquals(0x20, start);\n        long brk = vm.brk(start + 0x10);\n        assertEquals(0x30, brk);\n        brk = vm.brk(brk + 0x10);\n        assertEquals(0x40, brk);\n        brk = vm.brk(brk + 0x10);\n        assertEquals(0x50, brk);\n\n        long address = start;\n        for (int i = 0; i < 0x30; i++) {\n            vm.setI8(address, (byte) i);\n            address++;\n        }\n\n        address = start;\n        for (int i = 0; i < 0x30; i++) {\n            assertEquals((byte) i, vm.getI8(address));\n            address++;\n        }\n    }\n\n    @Test\n    public void vm001() {\n        vm.set32bit();\n        Memory m = new ByteMemory(4096);\n        m.setI32(0x42, 0xDEADBEEF);\n        MemoryPage p = new MemoryPage(m, 0x80000000L, 4096);\n        vm.add(p);\n        assertEquals(0xDEADBEEF, vm.getI32(0x80000042));\n    }\n\n    @Test\n    public void vm002() {\n        vm.set32bit();\n        Memory m = new ByteMemory(8192);\n        MemoryPage p = new MemoryPage(m, 0x80000000L, 8192);\n        vm.add(p);\n        vm.setI32(0x80000042, 0xDEADBEEF);\n        assertEquals(0xDEADBEEF, m.getI32(0x42));\n    }\n\n    @Test\n    public void vmsplit001() {\n        vm.set32bit();\n        Memory m1 = new ByteMemory(65536);\n        Memory m2 = new ByteMemory(4096);\n        MemoryPage p1 = new MemoryPage(m1, 0x80000000L, 65536);\n        MemoryPage p2 = new MemoryPage(m2, 0x80001000L, 4096);\n        vm.add(p1);\n        vm.add(p2);\n        vm.setI32(0x80000042, 0xDEADBEEF);\n        vm.setI32(0x80001042, 0xC0DEBABE);\n        vm.setI32(0x80002042, 0xCAFEBABE);\n        assertEquals(0xDEADBEEF, m1.getI32(0x42));\n        assertEquals(0xC0DEBABE, m2.getI32(0x42));\n        assertEquals(0xCAFEBABE, m1.getI32(0x2042));\n    }\n\n    @Test\n    public void unmap001() throws PosixException {\n        vm.set64bit();\n        Memory m = new ByteMemory(4190208);\n        MemoryPage p = new MemoryPage(m, 0x7f0000e2a000L, 4190208);\n        vm.add(p);\n\n        vm.setI32(0x7f0000e2af00L, 0xDEADBEEF);\n        assertEquals(0xDEADBEEF, m.getI32(0xf00));\n\n        vm.remove(0x00007f0000e2a000L, 1925120);\n\n        vm.setI32(0x7f0001000000L, 0xDEADBEEF);\n        assertEquals(0xDEADBEEF, m.getI32(0x1d6000));\n\n        vm.remove(0x7f0001200000L, 167936);\n\n        vm.setI32(0x7f0001000010L, 0xC0DEBABE);\n        assertEquals(0xDEADBEEF, m.getI32(0x1d6000));\n\n        vm.setI32(0x7f0001000000L, 0xDEADCAFE);\n        assertEquals(0xDEADCAFE, m.getI32(0x1d6000));\n\n        assertEquals(0xC0DEBABE, m.getI32(0x1d6010));\n    }\n}", "class_id": 0, "repo": "LaudateCorpus1/trufflex86", "file": "projects/org.graalvm.vm.memory.test/src/org/graalvm/vm/memory/test/VirtualMemoryTest.java", "last_update_at": "2020-09-18T08:52:39+00:00", "question_id": "ca9fd8d092b14c7dafbb7c112860fd752d8984d0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class VirtualMemoryTest {\n    private VirtualMemory vm;\n    private MemoryPage page;\n    private Memory mem;\n    private byte[] bytes;\n    @Before\n    public void setup() {\n        vm = new JavaVirtualMemory();\n        bytes = new byte[32];\n        mem = new ByteMemory(bytes);\n        page = new MemoryPage(mem, 0, bytes.length);\n        vm.add(page);\n        vm.setBrk(32);\n    }\n    @Test\n    public void compute001() {\n        int val = 0xF0000021;\n        long address = 0x00000000;\n        vm.setI32(address, val);\n        assertEquals(0xF0000021, vm.getI32(address));\n    }\n    @Test\n    public void brk001() {\n        long start = vm.brk();\n        assertEquals(0x20, start);\n        long brk = vm.brk(start + 0x10);\n        assertEquals(0x30, brk);\n        brk = vm.brk(brk + 0x10);\n        assertEquals(0x40, brk);\n        brk = vm.brk(brk + 0x10);\n        assertEquals(0x50, brk);\n        long address = start;\n        for (int i = 0; i < 0x30; i++) {\n            vm.setI8(address, (byte) i);\n            address++;\n        }\n        address = start;\n        for (int i = 0; i < 0x30; i++) {\n            assertEquals((byte) i, vm.getI8(address));\n            address++;\n        }\n    }\n    @Test\n    public void vm001() {\n        vm.set32bit();\n        Memory m = new ByteMemory(4096);\n        m.setI32(0x42, 0xDEADBEEF);\n        MemoryPage p = new MemoryPage(m, 0x80000000L, 4096);\n        vm.add(p);\n        assertEquals(0xDEADBEEF, vm.getI32(0x80000042));\n    }\n    @Test\n    public void vm002() {\n        vm.set32bit();\n        Memory m = new ByteMemory(8192);\n        MemoryPage p = new MemoryPage(m, 0x80000000L, 8192);\n        vm.add(p);\n        vm.setI32(0x80000042, 0xDEADBEEF);\n        assertEquals(0xDEADBEEF, m.getI32(0x42));\n    }\n    @Test\n    public void vmsplit001() {\n        vm.set32bit();\n        Memory m1 = new ByteMemory(65536);\n        Memory m2 = new ByteMemory(4096);\n        MemoryPage p1 = new MemoryPage(m1, 0x80000000L, 65536);\n        MemoryPage p2 = new MemoryPage(m2, 0x80001000L, 4096);\n        vm.add(p1);\n        vm.add(p2);\n        vm.setI32(0x80000042, 0xDEADBEEF);\n        vm.setI32(0x80001042, 0xC0DEBABE);\n        vm.setI32(0x80002042, 0xCAFEBABE);\n        assertEquals(0xDEADBEEF, m1.getI32(0x42));\n        assertEquals(0xC0DEBABE, m2.getI32(0x42));\n        assertEquals(0xCAFEBABE, m1.getI32(0x2042));\n    }\n    @Test\n    public void unmap001() throws PosixException {\n        vm.set64bit();\n        Memory m = new ByteMemory(4190208);\n        MemoryPage p = new MemoryPage(m, 0x7f0000e2a000L, 4190208);\n        vm.add(p);\n        vm.setI32(0x7f0000e2af00L, 0xDEADBEEF);\n        assertEquals(0xDEADBEEF, m.getI32(0xf00));\n        vm.remove(0x00007f0000e2a000L, 1925120);\n        vm.setI32(0x7f0001000000L, 0xDEADBEEF);\n        assertEquals(0xDEADBEEF, m.getI32(0x1d6000));\n        vm.remove(0x7f0001200000L, 167936);\n        vm.setI32(0x7f0001000010L, 0xC0DEBABE);\n        assertEquals(0xDEADBEEF, m.getI32(0x1d6000));\n        vm.setI32(0x7f0001000000L, 0xDEADCAFE);\n        assertEquals(0xDEADCAFE, m.getI32(0x1d6000));\n        assertEquals(0xC0DEBABE, m.getI32(0x1d6010));\n    }\n"]]}
{"hexsha": "f402f49e782ddcd0e031b882aeb7f1c9aa6a177a", "ext": "java", "lang": "Java", "content": "public final class removal_modules_math extends SubLTranslatedFile implements V10 {\n    public static final SubLFile me = new removal_modules_math();\n\n    public static final String myName = \"com.cyc.cycjava_2.cycl.inference.modules.removal.removal_modules_math\";\n\n\n    // defparameter\n    public static final SubLSymbol $default_math_module_cost$ = makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\");\n\n    private static final SubLObject $$interpolationWithCubicSpline = reader_make_constant_shell(makeString(\"interpolationWithCubicSpline\"));\n\n\n\n    private static final SubLSymbol $REMOVAL_INTERPOLATION_WITH_CUBIC_SPLINE = makeKeyword(\"REMOVAL-INTERPOLATION-WITH-CUBIC-SPLINE\");\n\n    private static final SubLList $list3 = list(new SubLObject[]{ makeKeyword(\"SENSE\"), makeKeyword(\"POS\"), makeKeyword(\"PREDICATE\"), reader_make_constant_shell(makeString(\"interpolationWithCubicSpline\")), makeKeyword(\"REQUIRED-PATTERN\"), list(reader_make_constant_shell(makeString(\"interpolationWithCubicSpline\")), makeKeyword(\"FULLY-BOUND\"), list(makeKeyword(\"OR\"), list(reader_make_constant_shell(makeString(\"The2DPoint\")), makeKeyword(\"NOT-FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\")), list(reader_make_constant_shell(makeString(\"The2DPoint\")), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"NOT-FULLY-BOUND\")))), makeKeyword(\"COST-EXPRESSION\"), makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\"), makeKeyword(\"COMPLETENESS\"), makeKeyword(\"COMPLETE\"), makeKeyword(\"EXPAND\"), makeSymbol(\"REMOVAL-INTERPOLATION-WITH-CUBIC-SPLINE-EXPAND\"), makeKeyword(\"DOCUMENTATION\"), makeString(\"(#$interpolationWithCubicSpline <set-of-points> <2d-point-with-x-or-y-bound>)\"), makeKeyword(\"EXAMPLE\"), makeString(\"(#$interpolationWithCubicSpline \\n    (#$TheSet \\n     (#$The2DPoint \\n      (#$Meter 440.1) \\n      (#$DegreeCelsius 160.3)) \\n     (#$The2DPoint \\n      (#$Meter 441.1) \\n      (#$DegreeCelsius 161.4)) \\n     (#$The2DPoint \\n      (#$Meter 442.3) \\n      (#$DegreeCelsius 163.6)) \\n     (#$The2DPoint \\n      (#$Meter 443.6) \\n      (#$DegreeCelsius 165.5)) \\n     (#$The2DPoint \\n      (#$Meter 444.9) \\n      (#$DegreeCelsius 166.4)) \\n     (#$The2DPoint \\n      (#$Meter 445.8) \\n      (#$DegreeCelsius 166.3)) \\n     (#$The2DPoint \\n      (#$Meter 446.7) \\n      (#$DegreeCelsius 165.4)) \\n     (#$The2DPoint \\n      (#$Meter 447.9) \\n      (#$DegreeCelsius 167.8))) \\n    (#$The2DPoint \\n     (#$Meter 445.0) \\n     (#$DegreeCelsius ?VALUE)))\") });\n\n    private static final SubLSymbol JAVA_LINK_X_Y_CUBIC_SPLINE_FIND_Y_FOR_X = makeSymbol(\"JAVA-LINK-X-Y-CUBIC-SPLINE-FIND-Y-FOR-X\");\n\n    private static final SubLObject $const5$interpolationWithPiecewiseLinearP = reader_make_constant_shell(makeString(\"interpolationWithPiecewiseLinearPolynomial\"));\n\n    private static final SubLSymbol $REMOVAL_INTERPOLATION_WITH_PIECEWISE_LINEAR_POLYNOMIAL = makeKeyword(\"REMOVAL-INTERPOLATION-WITH-PIECEWISE-LINEAR-POLYNOMIAL\");\n\n    private static final SubLList $list7 = list(new SubLObject[]{ makeKeyword(\"SENSE\"), makeKeyword(\"POS\"), makeKeyword(\"PREDICATE\"), reader_make_constant_shell(makeString(\"interpolationWithPiecewiseLinearPolynomial\")), makeKeyword(\"REQUIRED-PATTERN\"), list(reader_make_constant_shell(makeString(\"interpolationWithPiecewiseLinearPolynomial\")), makeKeyword(\"FULLY-BOUND\"), list(makeKeyword(\"OR\"), list(reader_make_constant_shell(makeString(\"The2DPoint\")), makeKeyword(\"NOT-FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\")), list(reader_make_constant_shell(makeString(\"The2DPoint\")), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"NOT-FULLY-BOUND\")))), makeKeyword(\"COST-EXPRESSION\"), makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\"), makeKeyword(\"COMPLETENESS\"), makeKeyword(\"COMPLETE\"), makeKeyword(\"EXPAND\"), makeSymbol(\"REMOVAL-INTERPOLATION-WITH-PIECEWISE-LINEAR-POLYNOMIAL-EXPAND\"), makeKeyword(\"DOCUMENTATION\"), makeString(\"(#$interpolationWithPiecewiseLinearPolynomial <set-of-points> <2d-point-with-x-or-y-bound>)\"), makeKeyword(\"EXAMPLE\"), makeString(\"(#$interpolationWithPiecewiseLinearPolynomial \\n    (#$TheSet \\n     (#$The2DPoint \\n      (#$Meter 440.1) \\n      (#$DegreeCelsius 160.3)) \\n     (#$The2DPoint \\n      (#$Meter 441.1) \\n      (#$DegreeCelsius 161.4)) \\n     (#$The2DPoint \\n      (#$Meter 442.3) \\n      (#$DegreeCelsius 163.6)) \\n     (#$The2DPoint \\n      (#$Meter 443.6) \\n      (#$DegreeCelsius 165.5)) \\n     (#$The2DPoint \\n      (#$Meter 444.9) \\n      (#$DegreeCelsius 166.4)) \\n     (#$The2DPoint \\n      (#$Meter 445.8) \\n      (#$DegreeCelsius 166.3)) \\n     (#$The2DPoint \\n      (#$Meter 446.7) \\n      (#$DegreeCelsius 165.4)) \\n     (#$The2DPoint \\n      (#$Meter 447.9) \\n      (#$DegreeCelsius 167.8))) \\n    (#$The2DPoint \\n     (#$Meter 445.0) \\n     (#$DegreeCelsius ?VALUE)))\") });\n\n    private static final SubLSymbol JAVA_LINK_X_Y_PIECEWISE_LINEAR_FIND_Y_FOR_X = makeSymbol(\"JAVA-LINK-X-Y-PIECEWISE-LINEAR-FIND-Y-FOR-X\");\n\n    private static final SubLObject $const9$extrapolationWithSimpleLinearRegr = reader_make_constant_shell(makeString(\"extrapolationWithSimpleLinearRegression\"));\n\n    private static final SubLSymbol $REMOVAL_EXTRAPOLATION_WITH_SIMPLE_LINEAR_REGRESSION = makeKeyword(\"REMOVAL-EXTRAPOLATION-WITH-SIMPLE-LINEAR-REGRESSION\");\n\n    private static final SubLList $list11 = list(new SubLObject[]{ makeKeyword(\"SENSE\"), makeKeyword(\"POS\"), makeKeyword(\"PREDICATE\"), reader_make_constant_shell(makeString(\"extrapolationWithSimpleLinearRegression\")), makeKeyword(\"REQUIRED-PATTERN\"), list(reader_make_constant_shell(makeString(\"extrapolationWithSimpleLinearRegression\")), makeKeyword(\"FULLY-BOUND\"), list(makeKeyword(\"OR\"), list(reader_make_constant_shell(makeString(\"The2DPoint\")), makeKeyword(\"NOT-FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\")), list(reader_make_constant_shell(makeString(\"The2DPoint\")), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"NOT-FULLY-BOUND\")))), makeKeyword(\"COST-EXPRESSION\"), makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\"), makeKeyword(\"COMPLETENESS\"), makeKeyword(\"COMPLETE\"), makeKeyword(\"EXPAND\"), makeSymbol(\"REMOVAL-EXTRAPOLATION-WITH-SIMPLE-LINEAR-REGRESSION-EXPAND\"), makeKeyword(\"DOCUMENTATION\"), makeString(\"(#$extrapolationWithSimpleLinearRegression <set-of-points> <2d-point-with-x-or-y-bound>)\"), makeKeyword(\"EXAMPLE\"), makeString(\"(#$extrapolationWithSimpleLinearRegression \\n    (#$TheSet \\n     (#$The2DPoint \\n      (#$DaysDuration 1) \\n      (#$DegreeCelsius 160.3)) \\n     (#$The2DPoint \\n      (#$DaysDuration 2) \\n      (#$DegreeCelsius 161.4)) \\n     (#$The2DPoint \\n      (#$DaysDuration 3) \\n      (#$DegreeCelsius 163.6)) \\n     (#$The2DPoint \\n      (#$DaysDuration 4) \\n      (#$DegreeCelsius 165.5)) \\n     (#$The2DPoint \\n      (#$DaysDuration 5) \\n      (#$DegreeCelsius 166.4)) \\n     (#$The2DPoint \\n      (#$DaysDuration 6) \\n      (#$DegreeCelsius 166.3)) \\n     (#$The2DPoint \\n      (#$DaysDuration 7) \\n      (#$DegreeCelsius 165.4)) \\n     (#$The2DPoint \\n      (#$DaysDuration 8) \\n      (#$DegreeCelsius 167.8))) \\n    (#$The2DPoint \\n     (#$DaysDuration ?VALUE) \\n     (#$DegreeCelsius 200)))\") });\n\n    private static final SubLSymbol JAVA_LINK_X_Y_REGRESSION_FIND_Y_FOR_X = makeSymbol(\"JAVA-LINK-X-Y-REGRESSION-FIND-Y-FOR-X\");\n\n    private static final SubLSymbol EL_2D_POINT_P = makeSymbol(\"EL-2D-POINT-P\");\n\n    private static final SubLList $list14 = list(makeSymbol(\"THE-2D-POINT\"), makeSymbol(\"QUERY-X-VALUE-WITH-UNITS\"), makeSymbol(\"QUERY-Y-VALUE-WITH-UNITS\"));\n\n\n\n\n\n    private static final SubLObject $const17$extrapolationWithSimpleLinearRegr = reader_make_constant_shell(makeString(\"extrapolationWithSimpleLinearRegressionWithErrorBars\"));\n\n    private static final SubLSymbol $kw18$REMOVAL_EXTRAPOLATION_WITH_SIMPLE_LINEAR_REGRESSION_WITH_ERROR_BA = makeKeyword(\"REMOVAL-EXTRAPOLATION-WITH-SIMPLE-LINEAR-REGRESSION-WITH-ERROR-BARS\");\n\n    private static final SubLList $list19 = list(new SubLObject[]{ makeKeyword(\"SENSE\"), makeKeyword(\"POS\"), makeKeyword(\"PREDICATE\"), reader_make_constant_shell(makeString(\"extrapolationWithSimpleLinearRegressionWithErrorBars\")), makeKeyword(\"REQUIRED-PATTERN\"), list(reader_make_constant_shell(makeString(\"extrapolationWithSimpleLinearRegressionWithErrorBars\")), makeKeyword(\"FULLY-BOUND\"), list(makeKeyword(\"OR\"), list(reader_make_constant_shell(makeString(\"The2DPoint\")), makeKeyword(\"NOT-FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\")), list(reader_make_constant_shell(makeString(\"The2DPoint\")), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"NOT-FULLY-BOUND\"))), makeKeyword(\"NOT-FULLY-BOUND\")), makeKeyword(\"COST-EXPRESSION\"), makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\"), makeKeyword(\"COMPLETENESS\"), makeKeyword(\"COMPLETE\"), makeKeyword(\"EXPAND\"), makeSymbol(\"REMOVAL-EXTRAPOLATION-WITH-SIMPLE-LINEAR-REGRESSION-WITH-ERROR-BARS-EXPAND\"), makeKeyword(\"DOCUMENTATION\"), makeString(\"(#$extrapolationWithSimpleLinearRegressionWithErrorBars <set-of-points> <2d-point-with-x-or-y-bound> <error-term-unbound>)\"), makeKeyword(\"EXAMPLE\"), makeString(\"(#$extrapolationWithSimpleLinearRegressionWithErrorBars\\n    (#$TheSet \\n     (#$The2DPoint \\n      (#$DaysDuration 1) \\n      (#$DegreeCelsius 160.3)) \\n     (#$The2DPoint \\n      (#$DaysDuration 2) \\n      (#$DegreeCelsius 161.4)) \\n     (#$The2DPoint \\n      (#$DaysDuration 3) \\n      (#$DegreeCelsius 163.6)) \\n     (#$The2DPoint \\n      (#$DaysDuration 4) \\n      (#$DegreeCelsius 165.5)) \\n     (#$The2DPoint \\n      (#$DaysDuration 5) \\n      (#$DegreeCelsius 166.4)) \\n     (#$The2DPoint \\n      (#$DaysDuration 6) \\n      (#$DegreeCelsius 166.3)) \\n     (#$The2DPoint \\n      (#$DaysDuration 7) \\n      (#$DegreeCelsius 165.4)) \\n     (#$The2DPoint \\n      (#$DaysDuration 8) \\n      (#$DegreeCelsius 167.8))) \\n    (#$The2DPoint \\n     (#$DaysDuration ?VALUE) \\n     (#$DegreeCelsius 200))\\n    ?ERROR)\") });\n\n    private static final SubLSymbol JAVA_LINK_X_Y_REGRESSION_FIND_Y_FOR_X_WITH_ERROR_BARS = makeSymbol(\"JAVA-LINK-X-Y-REGRESSION-FIND-Y-FOR-X-WITH-ERROR-BARS\");\n\n    private static final SubLObject $const21$regressionLinesForSetsIntersectAt = reader_make_constant_shell(makeString(\"regressionLinesForSetsIntersectAtPoint\"));\n\n    private static final SubLSymbol $REMOVAL_REGRESSION_LINES_FOR_SETS_INTERSECT_AT_POINT = makeKeyword(\"REMOVAL-REGRESSION-LINES-FOR-SETS-INTERSECT-AT-POINT\");\n\n    private static final SubLList $list23 = list(new SubLObject[]{ makeKeyword(\"SENSE\"), makeKeyword(\"POS\"), makeKeyword(\"PREDICATE\"), reader_make_constant_shell(makeString(\"regressionLinesForSetsIntersectAtPoint\")), makeKeyword(\"REQUIRED-PATTERN\"), list(reader_make_constant_shell(makeString(\"regressionLinesForSetsIntersectAtPoint\")), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"NOT-FULLY-BOUND\")), makeKeyword(\"COST-EXPRESSION\"), makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\"), makeKeyword(\"COMPLETENESS\"), makeKeyword(\"COMPLETE\"), makeKeyword(\"EXPAND\"), makeSymbol(\"REMOVAL-REGRESSION-LINES-FOR-SETS-INTERSECT-AT-POINT-EXPAND\"), makeKeyword(\"DOCUMENTATION\"), makeString(\"(#$regressionLinesForSetsIntersectAtPoint <set-of-points> <set-of-points> ?POINT)\"), makeKeyword(\"EXAMPLE\"), makeString(\"(#$regressionLinesForSetsIntersectAtPoint\\n     (#$TheSet\\n      (#$The2DPoint\\n       (#$DegreeCelsius 200)\\n       (#$SecondsDuration 1263118210))\\n      (#$The2DPoint\\n       (#$DegreeCelsius 210)\\n       (#$SecondsDuration 1263204610))\\n      (#$The2DPoint\\n       (#$DegreeCelsius 220)\\n       (#$SecondsDuration 1263291010)))\\n     (TheSet\\n      (#$The2DPoint\\n       (#$DegreeCelsius 211)\\n       (#$SecondsDuration 1263081600))\\n      (#$The2DPoint\\n       (#$DegreeCelsius 212)\\n       (#$SecondsDuration 1263168000))\\n      (#$The2DPoint\\n       (#$DegreeCelsius 213)\\n       (#$SecondsDuration 1263254400)))\\n     ?POINT)\") });\n\n    private static final SubLObject $$The2DPoint = reader_make_constant_shell(makeString(\"The2DPoint\"));\n\n    private static final SubLObject $const25$slopeOfRegressionLineForSetOfPoin = reader_make_constant_shell(makeString(\"slopeOfRegressionLineForSetOfPoints\"));\n\n    private static final SubLSymbol $REMOVAL_SLOPE_OF_REGRESSION_LINE_FOR_SET_OF_POINTS = makeKeyword(\"REMOVAL-SLOPE-OF-REGRESSION-LINE-FOR-SET-OF-POINTS\");\n\n    private static final SubLList $list27 = list(new SubLObject[]{ makeKeyword(\"SENSE\"), makeKeyword(\"POS\"), makeKeyword(\"PREDICATE\"), reader_make_constant_shell(makeString(\"slopeOfRegressionLineForSetOfPoints\")), makeKeyword(\"REQUIRED-PATTERN\"), list(reader_make_constant_shell(makeString(\"slopeOfRegressionLineForSetOfPoints\")), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"NOT-FULLY-BOUND\")), makeKeyword(\"COST-EXPRESSION\"), makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\"), makeKeyword(\"COMPLETENESS\"), makeKeyword(\"COMPLETE\"), makeKeyword(\"EXPAND\"), makeSymbol(\"REMOVAL-SLOPE-OF-REGRESSION-LINE-FOR-SET-OF-POINTS-EXPAND\"), makeKeyword(\"DOCUMENTATION\"), makeString(\"(#$slopeOfRegressionLineForSetOfPoints <set-of-points> ?SLOPE)\"), makeKeyword(\"EXAMPLE\"), makeString(\"(#$slopeOfRegressionLineForSetOfPoints\\n     (#$TheSet\\n      (#$The2DPoint\\n       (#$DegreeCelsius 211)\\n       (#$SecondsDuration 1263081600))\\n      (#$The2DPoint\\n       (#$DegreeCelsius 212)\\n       (#$SecondsDuration 1263168000))\\n      (#$The2DPoint\\n       (#$DegreeCelsius 213)\\n       (#$SecondsDuration 1263254400))) ?X)\") });\n\n    private static final SubLObject $const28$setOfFirstDerivativePointsBasedOn = reader_make_constant_shell(makeString(\"setOfFirstDerivativePointsBasedOnSetOfPoints\"));\n\n    private static final SubLSymbol $REMOVAL_SET_OF_FIRST_DERIVATIVE_POINTS_BASED_ON_SET_OF_POINTS = makeKeyword(\"REMOVAL-SET-OF-FIRST-DERIVATIVE-POINTS-BASED-ON-SET-OF-POINTS\");\n\n    private static final SubLList $list30 = list(new SubLObject[]{ makeKeyword(\"SENSE\"), makeKeyword(\"POS\"), makeKeyword(\"PREDICATE\"), reader_make_constant_shell(makeString(\"setOfFirstDerivativePointsBasedOnSetOfPoints\")), makeKeyword(\"REQUIRED-PATTERN\"), list(reader_make_constant_shell(makeString(\"setOfFirstDerivativePointsBasedOnSetOfPoints\")), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"NOT-FULLY-BOUND\")), makeKeyword(\"COST-EXPRESSION\"), makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\"), makeKeyword(\"COMPLETENESS\"), makeKeyword(\"COMPLETE\"), makeKeyword(\"EXPAND\"), makeSymbol(\"REMOVAL-SET-OF-FIRST-DERIVATIVE-POINTS-BASED-ON-SET-OF-POINTS-EXPAND\"), makeKeyword(\"DOCUMENTATION\"), makeString(\"(#$setOfFirstDerivativePointsBasedOnSetOfPoints <set-of-points> ?SET-OF-POINTS)\"), makeKeyword(\"EXAMPLE\"), makeString(\"(#$setOfFirstDerivativePointsBasedOnSetOfPoints\\n    (#$TheSet\\n     (#$The2DPoint (#$SecondsDuration 1) (#$DegreeCelsius 1))\\n     (#$The2DPoint (#$SecondsDuration 3) (#$DegreeCelsius 5))\\n     (#$The2DPoint (#$SecondsDuration 5) (#$DegreeCelsius 1)))\\n    #$CubicSpline\\n    ?X)\\n    -->\\n    (#$TheSet \\n     (#$The2DPoint (#$SecondsDuration 1) ((#$PerFn #$DegreeCelsius #$SecondsDuration) 6.0))\\n     (#$The2DPoint (#$SecondsDuration 3) ((#$PerFn #$DegreeCelsius #$SecondsDuration) 0.0))\\n     (#$The2DPoint (#$SecondsDuration 5) ((#$PerFn #$DegreeCelsius #$SecondsDuration) -6.0)))\") });\n\n    private static final SubLObject $const31$setHasPointsWithYValueRelnToMatch = reader_make_constant_shell(makeString(\"setHasPointsWithYValueRelnToMatchingXValuePointsInSet\"));\n\n    private static final SubLSymbol $kw32$REMOVAL_SET_HAS_POINTS_WITH_Y_VALUE_RELN_TO_MATCHING_X_VALUE_POIN = makeKeyword(\"REMOVAL-SET-HAS-POINTS-WITH-Y-VALUE-RELN-TO-MATCHING-X-VALUE-POINTS-IN-SET\");\n\n    private static final SubLList $list33 = list(new SubLObject[]{ makeKeyword(\"SENSE\"), makeKeyword(\"POS\"), makeKeyword(\"PREDICATE\"), reader_make_constant_shell(makeString(\"setHasPointsWithYValueRelnToMatchingXValuePointsInSet\")), makeKeyword(\"REQUIRED-PATTERN\"), list(reader_make_constant_shell(makeString(\"setHasPointsWithYValueRelnToMatchingXValuePointsInSet\")), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"NOT-FULLY-BOUND\")), makeKeyword(\"COST-EXPRESSION\"), makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\"), makeKeyword(\"COMPLETENESS\"), makeKeyword(\"COMPLETE\"), makeKeyword(\"EXPAND\"), makeSymbol(\"REMOVAL-SET-HAS-POINTS-WITH-Y-VALUE-RELN-TO-MATCHING-X-VALUE-POINTS-IN-SET-EXPAND\"), makeKeyword(\"DOCUMENTATION\"), makeString(\"(#$setHasPointsWithYValueRelnToMatchingXValuePointsInSet <set-of-points> <set-of-points> <binary-function> <binary-predicate> <value-in-y-units> ?RESULT-SET-OF-POINTS)\"), makeKeyword(\"EXAMPLE\"), makeString(\"(#$setHasPointsWithYValueRelnToMatchingXValuePointsInSet \\n    (#$TheSet \\n      (#$The2DPoint (#$Meter 702) (#$Kelvin 177.5)) \\n      (#$The2DPoint (#$Meter 703) (#$Kelvin 177.5)) \\n      (#$The2DPoint (#$Meter 704) (#$Kelvin 177.5)) \\n      (#$The2DPoint (#$Meter 705) (#$Kelvin 170))) \\n    (#$TheSet \\n      (#$The2DPoint (#$Meter 702) (#$Kelvin 175)) \\n      (#$The2DPoint (#$Meter 703) (#$Kelvin 175)) \\n      (#$The2DPoint (#$Meter 704) (#$Kelvin 175)) \\n      (#$The2DPoint (#$Meter 705) (#$Kelvin 170)))\\n    #$DifferenceFn\\n    #$greaterThanOrEqualTo \\n    (#$Kelvin 2)\\n    ?NEWSET)\\n    -->\\n    (((?NEWSET #$TheSet (#$The2DPoint (#$Meter 702) (#$Kelvin 177.5)) \\n                        (#$The2DPoint (#$Meter 703) (#$Kelvin 177.5)) \\n                        (#$The2DPoint (#$Meter 704) (#$Kelvin 177.5)))))\") });\n\n\n\n    private static final SubLString $str35$org_apache_commons_math_stat_regr = makeString(\"org.apache.commons.math.stat.regression.SimpleRegression\");\n\n    private static final SubLString $$$addData = makeString(\"addData\");\n\n    private static final SubLString $$$double = makeString(\"double\");\n\n    private static final SubLString $$$getSlope = makeString(\"getSlope\");\n\n    private static final SubLString $$$getIntercept = makeString(\"getIntercept\");\n\n\n\n\n\n    private static final SubLString $str42$org_apache_commons_math_analysis_ = makeString(\"org.apache.commons.math.analysis.interpolation.SplineInterpolator\");\n\n    private static final SubLString $$$interpolate = makeString(\"interpolate\");\n\n    private static final SubLString $str44$_D = makeString(\"[D\");\n\n    private static final SubLString $str45$org_apache_commons_math_analysis_ = makeString(\"org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction\");\n\n    private static final SubLString $$$value = makeString(\"value\");\n\n    private static final SubLSymbol $sym47$_ = makeSymbol(\"<\");\n\n\n\n    private static final SubLString $str49$org_apache_commons_math_analysis_ = makeString(\"org.apache.commons.math.analysis.interpolation.LinearInterpolator\");\n\n    private static final SubLString $$$predict = makeString(\"predict\");\n\n    private static final SubLString $$$getSumSquaredErrors = makeString(\"getSumSquaredErrors\");\n\n    private static final SubLString $str52$org_apache_commons_math_geometry_ = makeString(\"org.apache.commons.math.geometry.euclidean.twod.Line\");\n\n    private static final SubLString $str53$org_apache_commons_math_geometry_ = makeString(\"org.apache.commons.math.geometry.euclidean.twod.Vector2D\");\n\n    private static final SubLString $$$intersection = makeString(\"intersection\");\n\n    private static final SubLString $str55$org_apache_commons_math_geometry_ = makeString(\"org.apache.commons.math.geometry.partitioning.Hyperplane\");\n\n    private static final SubLString $$$getX = makeString(\"getX\");\n\n    private static final SubLString $$$getY = makeString(\"getY\");\n\n    private static final SubLObject $$CubicSpline = reader_make_constant_shell(makeString(\"CubicSpline\"));\n\n    private static final SubLObject $const59$LinearPolynomialFunction_Piecewis = reader_make_constant_shell(makeString(\"LinearPolynomialFunction-Piecewise\"));\n\n    private static final SubLString $$$derivative = makeString(\"derivative\");\n\n\n\n    private static final SubLObject $$setHasPointsWithYValueRelnTo = reader_make_constant_shell(makeString(\"setHasPointsWithYValueRelnTo\"));\n\n    private static final SubLSymbol $REMOVAL_SET_HAS_POINTS_WITH_Y_VALUE_RELN_TO = makeKeyword(\"REMOVAL-SET-HAS-POINTS-WITH-Y-VALUE-RELN-TO\");\n\n    private static final SubLList $list64 = list(new SubLObject[]{ makeKeyword(\"SENSE\"), makeKeyword(\"POS\"), makeKeyword(\"PREDICATE\"), reader_make_constant_shell(makeString(\"setHasPointsWithYValueRelnTo\")), makeKeyword(\"REQUIRED-PATTERN\"), list(reader_make_constant_shell(makeString(\"setHasPointsWithYValueRelnTo\")), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"NOT-FULLY-BOUND\")), makeKeyword(\"COST-EXPRESSION\"), makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\"), makeKeyword(\"COMPLETENESS\"), makeKeyword(\"COMPLETE\"), makeKeyword(\"EXPAND\"), makeSymbol(\"REMOVAL-SET-HAS-POINTS-WITH-Y-VALUE-RELN-TO-EXPAND\"), makeKeyword(\"DOCUMENTATION\"), makeString(\"(#$setHasPointsWithYValueRelnTo <set-of-points> <operator> <comparator> <quant1> <quant2> ?NEWSET)\"), makeKeyword(\"EXAMPLE\"), makeString(\"(#$setHasPointsWithYValueRelnTo \\n (#$TheSet \\n  (#$The2DPoint \\n   (#$Meter 20.0) \\n   (#$DegreeCelsius 68.35)) \\n  (#$The2DPoint \\n   (#$Meter 21.0) \\n   (#$DegreeCelsius 72.98)) \\n  (#$The2DPoint \\n   (#$Meter 22.0) \\n   (#$DegreeCelsius 75.68)) \\n  (#$The2DPoint \\n   (#$Meter 23.0) \\n   (#$DegreeCelsius 78.16)) \\n  (#$The2DPoint \\n   (#$Meter 24.0) \\n   (#$DegreeCelsius 80.79)))\\n #$PlusFn\\n #$lessThanOrEqualTo \\n (#$DegreeCelsius 0) \\n (#$DegreeCelsius 70) ?NEWSET)\\n -->\\n (((?NEWSET TheSet\\n   (The2DPoint\\n       (Meter 20.0)\\n       (DegreeCelsius 68.35)))))\") });\n\n    private static final SubLObject $$operationResultComparison = reader_make_constant_shell(makeString(\"operationResultComparison\"));\n\n\n\n    private static final SubLSymbol $REMOVAL_OPERATION_RESULT_COMPARISON_POS_CHECK = makeKeyword(\"REMOVAL-OPERATION-RESULT-COMPARISON-POS-CHECK\");\n\n    private static final SubLList $list68 = list(new SubLObject[]{ makeKeyword(\"SENSE\"), makeKeyword(\"POS\"), makeKeyword(\"PREDICATE\"), reader_make_constant_shell(makeString(\"operationResultComparison\")), makeKeyword(\"REQUIRED-PATTERN\"), list(reader_make_constant_shell(makeString(\"operationResultComparison\")), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\")), makeKeyword(\"COST-EXPRESSION\"), makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\"), makeKeyword(\"COMPLETENESS\"), makeKeyword(\"COMPLETE\"), makeKeyword(\"EXPAND\"), makeSymbol(\"REMOVAL-OPERATION-RESULT-COMPARISON-POS-CHECK\"), makeKeyword(\"DOCUMENTATION\"), makeString(\"(#$operationResultComparison <OP> <A> <B> <COMP> <QUANT>)\"), makeKeyword(\"EXAMPLE\"), makeString(\"(#$operationResultComparison #$PlusFn (#$DegreeCelsius 50) (#$DegreeCelsius 0) #$lessThanOrEqualTo (#$DegreeCelsius 70))\\n   --> True\") });\n\n    private static final SubLSymbol $REMOVAL_OPERATION_RESULT_COMPARISON_NEG_CHECK = makeKeyword(\"REMOVAL-OPERATION-RESULT-COMPARISON-NEG-CHECK\");\n\n    private static final SubLList $list70 = list(new SubLObject[]{ makeKeyword(\"SENSE\"), makeKeyword(\"NEG\"), makeKeyword(\"PREDICATE\"), reader_make_constant_shell(makeString(\"operationResultComparison\")), makeKeyword(\"REQUIRED-PATTERN\"), list(reader_make_constant_shell(makeString(\"operationResultComparison\")), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\")), makeKeyword(\"COST-EXPRESSION\"), makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\"), makeKeyword(\"COMPLETENESS\"), makeKeyword(\"COMPLETE\"), makeKeyword(\"EXPAND\"), makeSymbol(\"REMOVAL-OPERATION-RESULT-COMPARISON-NEG-CHECK\"), makeKeyword(\"DOCUMENTATION\"), makeString(\"(#$operationResultComparison <OP> <A> <B> <COMP> <QUANT>)\"), makeKeyword(\"EXAMPLE\"), makeString(\"(#$not (#$operationResultComparison #$PlusFn (#$DegreeCelsius 100) (#$DegreeCelsius 0) #$lessThanOrEqualTo (#$DegreeCelsius 70))\\n   --> True\") });\n\n    private static final SubLObject $$inflowLengthsWithStartingDepths = reader_make_constant_shell(makeString(\"inflowLengthsWithStartingDepths\"));\n\n    private static final SubLSymbol $REMOVAL_INFLOW_LENGTHS_WITH_STARTING_DEPTHS = makeKeyword(\"REMOVAL-INFLOW-LENGTHS-WITH-STARTING-DEPTHS\");\n\n    private static final SubLList $list73 = list(new SubLObject[]{ makeKeyword(\"SENSE\"), makeKeyword(\"POS\"), makeKeyword(\"PREDICATE\"), reader_make_constant_shell(makeString(\"inflowLengthsWithStartingDepths\")), makeKeyword(\"REQUIRED-PATTERN\"), list(reader_make_constant_shell(makeString(\"inflowLengthsWithStartingDepths\")), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"NOT-FULLY-BOUND\")), makeKeyword(\"COST-EXPRESSION\"), makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\"), makeKeyword(\"COMPLETENESS\"), makeKeyword(\"COMPLETE\"), makeKeyword(\"EXPAND\"), makeSymbol(\"REMOVAL-INFLOW-LENGTHS-WITH-STARTING-DEPTHS-EXPAND\"), makeKeyword(\"DOCUMENTATION\"), makeString(\"(#$inflowLengthsWithStartingDepths <well> <set-of-points> ?LENGTH-AND-DEPTHS)\"), makeKeyword(\"EXAMPLE\"), makeString(\"(#$inflowLengthsWithStartingDepths\\n  (#$The #$Well)\\n  (#$TheSet \\n   (#$The2DPoint (#$Meter 100) (#$DegreeCelsius  95))\\n   (#$The2DPoint (#$Meter 110) (#$DegreeCelsius 110))\\n   (#$The2DPoint (#$Meter 120) (#$DegreeCelsius 115))\\n   (#$The2DPoint (#$Meter 130) (#$DegreeCelsius 114))\\n   (#$The2DPoint (#$Meter 140) (#$DegreeCelsius 103))\\n   (#$The2DPoint (#$Meter 150) (#$DegreeCelsius  95))\\n   (#$The2DPoint (#$Meter 160) (#$DegreeCelsius 100))\\n   (#$The2DPoint (#$Meter 170) (#$DegreeCelsius 102))\\n   (#$The2DPoint (#$Meter 180) (#$DegreeCelsius 102))\\n   (#$The2DPoint (#$Meter 190) (#$DegreeCelsius  91))\\n   (#$The2DPoint (#$Meter 200) (#$DegreeCelsius 100))\\n   (#$The2DPoint (#$Meter 210) (#$DegreeCelsius 110))\\n   (#$The2DPoint (#$Meter 220) (#$DegreeCelsius 105))\\n   (#$The2DPoint (#$Meter 230) (#$DegreeCelsius  97))\\n   (#$The2DPoint (#$Meter 240) (#$DegreeCelsius  96))\\n   (#$The2DPoint (#$Meter 250) (#$DegreeCelsius  95))\\n   (#$The2DPoint (#$Meter 260) (#$DegreeCelsius  94))\\n   (#$The2DPoint (#$Meter 270) (#$DegreeCelsius  93))\\n   (#$The2DPoint (#$Meter 280) (#$DegreeCelsius  92)))\\n  ?LENGTH-AND-DEPTHS)\") });\n\n    private static final SubLObject $$Meter = reader_make_constant_shell(makeString(\"Meter\"));\n\n    private static final SubLObject $$DegreeCelsius = reader_make_constant_shell(makeString(\"DegreeCelsius\"));\n\n    private static final SubLString $str76$____ = makeString(\"~%~%\");\n\n    private static final SubLList $list77 = list(makeSymbol(\"X-VALUE\"), makeSymbol(\"Y-VALUE\"));\n\n    private static final SubLString $str78$High_value__x__A_y__A__ = makeString(\"High value: x=~A y=~A~%\");\n\n    private static final SubLList $list79 = list(makeSymbol(\"CUR-X-VALUE\"), makeSymbol(\"CUR-Y-DERIVATIVE-VALUE\"));\n\n    private static final SubLString $str80$checking_x__A_deriv__A__ = makeString(\"checking x=~A deriv=~A~%\");\n\n    private static final SubLString $$$Bad_looping = makeString(\"Bad looping\");\n\n    private static final SubLFloat $float$0_5 = makeDouble(0.5);\n\n    private static final SubLFloat $float$_0_5 = makeDouble(-0.5);\n\n    private static final SubLString $str84$Got_interval___A__A___ = makeString(\"Got interval (~A ~A)~%\");\n\n    private static final SubLSymbol $sym85$_ = makeSymbol(\">\");\n\n    private static final SubLString $str86$inflow_lengths___A__ = makeString(\"inflow-lengths: ~A~%\");\n\n    private static final SubLList $list87 = list(makeSymbol(\"START\"), makeSymbol(\"END\"));\n\n    private static final SubLString $str88$merged_inflow_lengths___A__ = makeString(\"merged-inflow-lengths: ~A~%\");\n\n    private static final SubLObject $$TheList = reader_make_constant_shell(makeString(\"TheList\"));\n\n    public static SubLObject removal_interpolation_with_cubic_spline_expand(final SubLObject asent, SubLObject sense) {\n        if (sense == UNPROVIDED) {\n            sense = NIL;\n        }\n        return removal_interpolation_or_extrapolation_with_java_link_function_expand_helper(asent, JAVA_LINK_X_Y_CUBIC_SPLINE_FIND_Y_FOR_X);\n    }\n\n    public static SubLObject removal_interpolation_with_piecewise_linear_polynomial_expand(final SubLObject asent, SubLObject sense) {\n        if (sense == UNPROVIDED) {\n            sense = NIL;\n        }\n        return removal_interpolation_or_extrapolation_with_java_link_function_expand_helper(asent, JAVA_LINK_X_Y_PIECEWISE_LINEAR_FIND_Y_FOR_X);\n    }\n\n    public static SubLObject removal_extrapolation_with_simple_linear_regression_expand(final SubLObject asent, SubLObject sense) {\n        if (sense == UNPROVIDED) {\n            sense = NIL;\n        }\n        return removal_interpolation_or_extrapolation_with_java_link_function_expand_helper(asent, JAVA_LINK_X_Y_REGRESSION_FIND_Y_FOR_X);\n    }\n\n    public static SubLObject removal_interpolation_or_extrapolation_with_java_link_function_expand_helper(final SubLObject asent, final SubLObject java_link_function) {\n        final SubLThread thread = SubLProcess.currentSubLThread();\n        final SubLObject set_of_points_in_units = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);\n        final SubLObject query_point = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);\n        if (NIL != el_extensional_set_p(set_of_points_in_units)) {\n            final SubLObject v_2d_points = extensional_set_elements(set_of_points_in_units);\n            if ((NIL != v_2d_points) && (NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points, UNPROVIDED))) {\n                thread.resetMultipleValues();\n                final SubLObject x_y_values = explode_2d_points_with_units(v_2d_points, UNPROVIDED, UNPROVIDED);\n                final SubLObject x_units = thread.secondMultipleValue();\n                final SubLObject y_units = thread.thirdMultipleValue();\n                thread.resetMultipleValues();\n                if (((NIL != x_y_values) && (NIL != x_units)) && (NIL != y_units)) {\n                    SubLObject current;\n                    final SubLObject datum = current = query_point;\n                    SubLObject the_2d_point = NIL;\n                    SubLObject query_x_value_with_units = NIL;\n                    SubLObject query_y_value_with_units = NIL;\n                    destructuring_bind_must_consp(current, datum, $list14);\n                    the_2d_point = current.first();\n                    current = current.rest();\n                    destructuring_bind_must_consp(current, datum, $list14);\n                    query_x_value_with_units = current.first();\n                    current = current.rest();\n                    destructuring_bind_must_consp(current, datum, $list14);\n                    query_y_value_with_units = current.first();\n                    current = current.rest();\n                    if (NIL == current) {\n                        if (NIL != variables.not_fully_bound_p(query_y_value_with_units)) {\n                            thread.resetMultipleValues();\n                            final SubLObject query_x_units = quantities.explode_interval(query_x_value_with_units);\n                            final SubLObject query_x_value = thread.secondMultipleValue();\n                            thread.resetMultipleValues();\n                            final SubLObject normalized_query_x_value = quantities.convert_to_units_absolute(x_units, query_x_units, query_x_value, UNPROVIDED);\n                            final SubLObject answer_y_value = funcall(java_link_function, x_y_values, normalized_query_x_value);\n                            if (NIL != answer_y_value) {\n                                final SubLObject answer_y_value_with_units = quantities.make_interval(y_units, answer_y_value, UNPROVIDED);\n                                final SubLObject v_bindings = quantities.term_unify_with_units(query_y_value_with_units, answer_y_value_with_units);\n                                backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings, asent), UNPROVIDED, UNPROVIDED), v_bindings, UNPROVIDED);\n                            }\n                        } else {\n                            final SubLObject y_x_values = Mapping.mapcar(NREVERSE, x_y_values);\n                            thread.resetMultipleValues();\n                            final SubLObject query_y_units = quantities.explode_interval(query_y_value_with_units);\n                            final SubLObject query_y_value = thread.secondMultipleValue();\n                            thread.resetMultipleValues();\n                            final SubLObject normalized_query_y_value = quantities.convert_to_units_absolute(y_units, query_y_units, query_y_value, UNPROVIDED);\n                            final SubLObject answer_x_value = funcall(java_link_function, y_x_values, normalized_query_y_value);\n                            if (NIL != answer_x_value) {\n                                final SubLObject answer_x_value_with_units = quantities.make_interval(x_units, answer_x_value, UNPROVIDED);\n                                final SubLObject v_bindings2 = quantities.term_unify_with_units(query_x_value_with_units, answer_x_value_with_units);\n                                backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings2, asent), UNPROVIDED, UNPROVIDED), v_bindings2, UNPROVIDED);\n                            }\n                        }\n                    } else {\n                        cdestructuring_bind_error(datum, $list14);\n                    }\n                }\n            }\n        }\n        return NIL;\n    }\n\n    public static SubLObject removal_extrapolation_with_simple_linear_regression_with_error_bars_expand(final SubLObject asent, SubLObject sense) {\n        if (sense == UNPROVIDED) {\n            sense = NIL;\n        }\n        return removal_interpolation_or_extrapolation_with_error_bars_with_java_link_function_expand_helper(asent, JAVA_LINK_X_Y_REGRESSION_FIND_Y_FOR_X_WITH_ERROR_BARS);\n    }\n\n    public static SubLObject removal_interpolation_or_extrapolation_with_error_bars_with_java_link_function_expand_helper(final SubLObject asent, final SubLObject java_link_function) {\n        final SubLThread thread = SubLProcess.currentSubLThread();\n        final SubLObject set_of_points_in_units = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);\n        final SubLObject query_point = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);\n        final SubLObject query_error_with_units = cycl_utilities.atomic_sentence_arg3(asent, UNPROVIDED);\n        if (NIL != el_extensional_set_p(set_of_points_in_units)) {\n            final SubLObject v_2d_points = extensional_set_elements(set_of_points_in_units);\n            if ((NIL != v_2d_points) && (NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points, UNPROVIDED))) {\n                thread.resetMultipleValues();\n                final SubLObject x_y_values = explode_2d_points_with_units(v_2d_points, UNPROVIDED, UNPROVIDED);\n                final SubLObject x_units = thread.secondMultipleValue();\n                final SubLObject y_units = thread.thirdMultipleValue();\n                thread.resetMultipleValues();\n                if (((NIL != x_y_values) && (NIL != x_units)) && (NIL != y_units)) {\n                    SubLObject current;\n                    final SubLObject datum = current = query_point;\n                    SubLObject the_2d_point = NIL;\n                    SubLObject query_x_value_with_units = NIL;\n                    SubLObject query_y_value_with_units = NIL;\n                    destructuring_bind_must_consp(current, datum, $list14);\n                    the_2d_point = current.first();\n                    current = current.rest();\n                    destructuring_bind_must_consp(current, datum, $list14);\n                    query_x_value_with_units = current.first();\n                    current = current.rest();\n                    destructuring_bind_must_consp(current, datum, $list14);\n                    query_y_value_with_units = current.first();\n                    current = current.rest();\n                    if (NIL == current) {\n                        if (NIL != variables.not_fully_bound_p(query_y_value_with_units)) {\n                            thread.resetMultipleValues();\n                            final SubLObject query_x_units = quantities.explode_interval(query_x_value_with_units);\n                            final SubLObject query_x_value = thread.secondMultipleValue();\n                            thread.resetMultipleValues();\n                            final SubLObject normalized_query_x_value = quantities.convert_to_units_absolute(x_units, query_x_units, query_x_value, UNPROVIDED);\n                            thread.resetMultipleValues();\n                            final SubLObject answer_y_value = funcall(java_link_function, x_y_values, normalized_query_x_value);\n                            final SubLObject answer_y_error = thread.secondMultipleValue();\n                            thread.resetMultipleValues();\n                            if ((NIL != answer_y_value) && (NIL != answer_y_error)) {\n                                final SubLObject answer_y_value_with_units = quantities.make_interval(y_units, answer_y_value, UNPROVIDED);\n                                final SubLObject answer_y_error_with_units = quantities.make_interval(y_units, answer_y_error, UNPROVIDED);\n                                final SubLObject v_bindings = append(quantities.term_unify_with_units(query_y_value_with_units, answer_y_value_with_units), quantities.term_unify_with_units(query_error_with_units, answer_y_error_with_units));\n                                backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings, asent), UNPROVIDED, UNPROVIDED), v_bindings, UNPROVIDED);\n                            }\n                        } else {\n                            final SubLObject y_x_values = Mapping.mapcar(NREVERSE, x_y_values);\n                            thread.resetMultipleValues();\n                            final SubLObject query_y_units = quantities.explode_interval(query_y_value_with_units);\n                            final SubLObject query_y_value = thread.secondMultipleValue();\n                            thread.resetMultipleValues();\n                            final SubLObject normalized_query_y_value = quantities.convert_to_units_absolute(y_units, query_y_units, query_y_value, UNPROVIDED);\n                            thread.resetMultipleValues();\n                            final SubLObject answer_x_value = funcall(java_link_function, y_x_values, normalized_query_y_value);\n                            final SubLObject answer_x_error = thread.secondMultipleValue();\n                            thread.resetMultipleValues();\n                            if ((NIL != answer_x_value) && (NIL != answer_x_error)) {\n                                final SubLObject answer_x_value_with_units = quantities.make_interval(x_units, answer_x_value, UNPROVIDED);\n                                final SubLObject answer_x_error_with_units = quantities.make_interval(x_units, answer_x_error, UNPROVIDED);\n                                final SubLObject v_bindings2 = append(quantities.term_unify_with_units(query_x_value_with_units, answer_x_value_with_units), quantities.term_unify_with_units(query_error_with_units, answer_x_error_with_units));\n                                backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings2, asent), UNPROVIDED, UNPROVIDED), v_bindings2, UNPROVIDED);\n                            }\n                        }\n                    } else {\n                        cdestructuring_bind_error(datum, $list14);\n                    }\n                }\n            }\n        }\n        return NIL;\n    }\n\n    public static SubLObject removal_regression_lines_for_sets_intersect_at_point_expand(final SubLObject asent, SubLObject sense) {\n        if (sense == UNPROVIDED) {\n            sense = NIL;\n        }\n        final SubLThread thread = SubLProcess.currentSubLThread();\n        final SubLObject set_of_points_in_units_1 = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);\n        final SubLObject set_of_points_in_units_2 = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);\n        final SubLObject query_point = cycl_utilities.atomic_sentence_arg3(asent, UNPROVIDED);\n        if ((NIL != el_extensional_set_p(set_of_points_in_units_1)) && (NIL != el_extensional_set_p(set_of_points_in_units_2))) {\n            final SubLObject v_2d_points_1 = extensional_set_elements(set_of_points_in_units_1);\n            final SubLObject v_2d_points_2 = extensional_set_elements(set_of_points_in_units_2);\n            if ((NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points_1, UNPROVIDED)) && (NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points_2, UNPROVIDED))) {\n                thread.resetMultipleValues();\n                final SubLObject x_y_values_1 = explode_2d_points_with_units(v_2d_points_1, UNPROVIDED, UNPROVIDED);\n                final SubLObject x_units = thread.secondMultipleValue();\n                final SubLObject y_units = thread.thirdMultipleValue();\n                thread.resetMultipleValues();\n                final SubLObject x_y_values_2 = explode_2d_points_with_units(v_2d_points_2, x_units, y_units);\n                thread.resetMultipleValues();\n                final SubLObject x = java_link_point_intersection_of_two_x_y_regressions(x_y_values_1, x_y_values_2);\n                final SubLObject y = thread.secondMultipleValue();\n                thread.resetMultipleValues();\n                if (x.isNumber() && y.isNumber()) {\n                    if (NIL != variables.variable_p(query_point)) {\n                        final SubLObject x_y_point_with_units = list($$The2DPoint, quantities.make_interval(x_units, x, UNPROVIDED), quantities.make_interval(y_units, y, UNPROVIDED));\n                        final SubLObject v_bindings = quantities.term_unify_with_units(query_point, x_y_point_with_units);\n                        backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings, asent), UNPROVIDED, UNPROVIDED), v_bindings, UNPROVIDED);\n                    } else {\n                        final SubLObject v_bindings2 = append(quantities.term_unify_with_units(second(query_point), quantities.make_interval(x_units, x, UNPROVIDED)), quantities.term_unify_with_units(third(query_point), quantities.make_interval(y_units, y, UNPROVIDED)));\n                        backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings2, asent), UNPROVIDED, UNPROVIDED), v_bindings2, UNPROVIDED);\n                    }\n                }\n            }\n        }\n        return NIL;\n    }\n\n    public static SubLObject removal_slope_of_regression_line_for_set_of_points_expand(final SubLObject asent, SubLObject sense) {\n        if (sense == UNPROVIDED) {\n            sense = NIL;\n        }\n        final SubLThread thread = SubLProcess.currentSubLThread();\n        final SubLObject set_of_points_in_units = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);\n        final SubLObject query_slope = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);\n        if ((NIL != el_extensional_set_p(set_of_points_in_units)) && ONE_INTEGER.numL(el_set_size(set_of_points_in_units))) {\n            final SubLObject v_2d_points = extensional_set_elements(set_of_points_in_units);\n            if (NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points, UNPROVIDED)) {\n                thread.resetMultipleValues();\n                final SubLObject x_y_values = explode_2d_points_with_units(v_2d_points, UNPROVIDED, UNPROVIDED);\n                final SubLObject x_units = thread.secondMultipleValue();\n                final SubLObject y_units = thread.thirdMultipleValue();\n                thread.resetMultipleValues();\n                final SubLObject slope = java_link_slope_and_intercept_of_x_y_regression(x_y_values);\n                final SubLObject bindings_1 = quantities.term_unify_with_units(query_slope, quantities.make_interval(quantities.unit_quotient(y_units, x_units), slope, UNPROVIDED));\n                final SubLObject bindings_2 = (NIL != czer_utilities.equals_elP(x_units, y_units, UNPROVIDED, UNPROVIDED, UNPROVIDED)) ? NIL : quantities.term_unify_with_units(query_slope, quantities.make_interval(quantities.unit_quotient(x_units, y_units), divide(ONE_INTEGER, slope), UNPROVIDED));\n                if (NIL != bindings_1) {\n                    backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(bindings_1, asent), UNPROVIDED, UNPROVIDED), bindings_1, UNPROVIDED);\n                }\n                if (NIL != bindings_2) {\n                    backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(bindings_2, asent), UNPROVIDED, UNPROVIDED), bindings_2, UNPROVIDED);\n                }\n            }\n        }\n        return NIL;\n    }\n\n    public static SubLObject removal_set_of_first_derivative_points_based_on_set_of_points_expand(final SubLObject asent, SubLObject sense) {\n        if (sense == UNPROVIDED) {\n            sense = NIL;\n        }\n        final SubLThread thread = SubLProcess.currentSubLThread();\n        final SubLObject set_of_points_in_units = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);\n        final SubLObject function_type = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);\n        final SubLObject set_of_derivative_points_in_units = cycl_utilities.atomic_sentence_arg3(asent, UNPROVIDED);\n        if (NIL != el_extensional_set_p(set_of_points_in_units)) {\n            final SubLObject v_2d_points = extensional_set_elements(set_of_points_in_units);\n            if (NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points, UNPROVIDED)) {\n                thread.resetMultipleValues();\n                final SubLObject x_y_values = explode_2d_points_with_units(v_2d_points, UNPROVIDED, UNPROVIDED);\n                final SubLObject x_units = thread.secondMultipleValue();\n                final SubLObject y_units = thread.thirdMultipleValue();\n                thread.resetMultipleValues();\n                final SubLObject x_y_derivative_points = java_link_x_y_derivatives_for_interpolation_at_each_x(x_y_values, function_type);\n                final SubLObject derivative_units = quantities.unit_quotient(y_units, x_units);\n                SubLObject result = NIL;\n                SubLObject v_bindings = NIL;\n                SubLObject cdolist_list_var = x_y_derivative_points;\n                SubLObject x_y_derivative_point = NIL;\n                x_y_derivative_point = cdolist_list_var.first();\n                while (NIL != cdolist_list_var) {\n                    result = cons(list($$The2DPoint, list(x_units, x_y_derivative_point.first()), list(derivative_units, second(x_y_derivative_point))), result);\n                    cdolist_list_var = cdolist_list_var.rest();\n                    x_y_derivative_point = cdolist_list_var.first();\n                } \n                result = make_el_extensional_set(nreverse(result));\n                v_bindings = unification_utilities.term_unify(result, set_of_derivative_points_in_units, UNPROVIDED, UNPROVIDED);\n                if (NIL != v_bindings) {\n                    backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings, asent), UNPROVIDED, UNPROVIDED), v_bindings, UNPROVIDED);\n                }\n            }\n        }\n        return NIL;\n    }\n\n    public static SubLObject removal_set_has_points_with_y_value_reln_to_matching_x_value_points_in_set_expand(final SubLObject asent, SubLObject sense) {\n        if (sense == UNPROVIDED) {\n            sense = NIL;\n        }\n        final SubLThread thread = SubLProcess.currentSubLThread();\n        final SubLObject set_of_points_1_in_units = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);\n        final SubLObject set_of_points_2_in_units = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);\n        final SubLObject binary_function = cycl_utilities.atomic_sentence_arg3(asent, UNPROVIDED);\n        final SubLObject binary_predicate = cycl_utilities.atomic_sentence_arg4(asent, UNPROVIDED);\n        final SubLObject value_in_y_units = cycl_utilities.atomic_sentence_arg5(asent, UNPROVIDED);\n        final SubLObject set_of_qualifying_points_in_units = cycl_utilities.atomic_sentence_arg6(asent, UNPROVIDED);\n        if (((((NIL != el_extensional_set_p(set_of_points_1_in_units)) && (NIL != el_extensional_set_p(set_of_points_2_in_units))) && (NIL != fort_types_interface.functionP(binary_function))) && arity.arity(binary_function).eql(TWO_INTEGER)) && (NIL != kb_accessors.binary_predicateP(binary_predicate))) {\n            final SubLObject v_2d_points_1 = extensional_set_elements(set_of_points_1_in_units);\n            final SubLObject v_2d_points_2 = extensional_set_elements(set_of_points_2_in_units);\n            if ((NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points_1, UNPROVIDED)) && (NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points_2, UNPROVIDED))) {\n                thread.resetMultipleValues();\n                final SubLObject x_y_values_1 = explode_2d_points_with_units(v_2d_points_1, UNPROVIDED, UNPROVIDED);\n                final SubLObject x_units = thread.secondMultipleValue();\n                final SubLObject y_units = thread.thirdMultipleValue();\n                thread.resetMultipleValues();\n                final SubLObject x_y_values_2 = explode_2d_points_with_units(v_2d_points_2, x_units, y_units);\n                final SubLObject y_compare_value = second(quantities.cyc_quantity_conversion(y_units, value_in_y_units));\n                SubLObject result_x_y_values = NIL;\n                SubLObject cdolist_list_var = x_y_values_1;\n                SubLObject x_y_value_1 = NIL;\n                x_y_value_1 = cdolist_list_var.first();\n                while (NIL != cdolist_list_var) {\n                    final SubLObject x_value_1 = x_y_value_1.first();\n                    final SubLObject y_value_1 = second(x_y_value_1);\n                    final SubLObject y_value_2 = second(find(x_value_1, x_y_values_2, EQL, FIRST, UNPROVIDED, UNPROVIDED));\n                    if ((NIL != y_value_2) && (NIL != backward.removal_ask(list(binary_predicate, list(binary_function, y_value_1, y_value_2), y_compare_value), UNPROVIDED, UNPROVIDED, UNPROVIDED))) {\n                        result_x_y_values = cons(x_y_value_1, result_x_y_values);\n                    }\n                    cdolist_list_var = cdolist_list_var.rest();\n                    x_y_value_1 = cdolist_list_var.first();\n                } \n                SubLObject result = NIL;\n                SubLObject cdolist_list_var2 = result_x_y_values;\n                SubLObject result_x_y_value = NIL;\n                result_x_y_value = cdolist_list_var2.first();\n                while (NIL != cdolist_list_var2) {\n                    result = cons(list($$The2DPoint, list(x_units, result_x_y_value.first()), list(y_units, second(result_x_y_value))), result);\n                    cdolist_list_var2 = cdolist_list_var2.rest();\n                    result_x_y_value = cdolist_list_var2.first();\n                } \n                result = make_el_extensional_set(nreverse(result));\n                final SubLObject v_bindings = unification_utilities.term_unify(result, set_of_qualifying_points_in_units, UNPROVIDED, UNPROVIDED);\n                if (NIL != v_bindings) {\n                    backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings, asent), UNPROVIDED, UNPROVIDED), v_bindings, UNPROVIDED);\n                }\n            }\n        }\n        return NIL;\n    }\n\n    public static SubLObject java_link_debug_modeP() {\n        final SubLThread thread = SubLProcess.currentSubLThread();\n        return $inference_debugP$.getDynamicValue(thread);\n    }\n\n    public static SubLObject java_link_slope_and_intercept_of_x_y_regression(final SubLObject x_y_values) {\n        final SubLObject regression = JavaLink.java_new($str35$org_apache_commons_math_stat_regr, EMPTY_SUBL_OBJECT_ARRAY);\n        final SubLObject add_data_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$addData, new SubLObject[]{ $$$double, $$$double });\n        final SubLObject slope_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$getSlope, EMPTY_SUBL_OBJECT_ARRAY);\n        final SubLObject intercept_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$getIntercept, EMPTY_SUBL_OBJECT_ARRAY);\n        SubLObject cdolist_list_var = x_y_values;\n        SubLObject x_y_value = NIL;\n        x_y_value = cdolist_list_var.first();\n        while (NIL != cdolist_list_var) {\n            JavaLink.java_call(add_data_method, regression, new SubLObject[]{ x_y_value.first(), second(x_y_value) });\n            cdolist_list_var = cdolist_list_var.rest();\n            x_y_value = cdolist_list_var.first();\n        } \n        return values(JavaLink.java_call(slope_method, regression, EMPTY_SUBL_OBJECT_ARRAY), JavaLink.java_call(intercept_method, regression, EMPTY_SUBL_OBJECT_ARRAY));\n    }\n\n    public static SubLObject java_link_x_y_cubic_spline_find_y_for_x(SubLObject x_y_values, final SubLObject x_value) {\n        if ((x_value.numL(apply(MIN, Mapping.mapcar(FIRST, x_y_values))) || x_value.numG(apply(MAX, Mapping.mapcar(FIRST, x_y_values)))) || ((NIL == java_link_debug_modeP()) && (NIL != list_utilities.duplicatesP(Mapping.mapcar(FIRST, x_y_values), UNPROVIDED, UNPROVIDED)))) {\n            return NIL;\n        }\n        final SubLObject interpolator = JavaLink.java_new($str42$org_apache_commons_math_analysis_, EMPTY_SUBL_OBJECT_ARRAY);\n        final SubLObject interpolate_method = JavaLink.java_method($str42$org_apache_commons_math_analysis_, $$$interpolate, new SubLObject[]{ $str44$_D, $str44$_D });\n        final SubLObject value_method = JavaLink.java_method($str45$org_apache_commons_math_analysis_, $$$value, new SubLObject[]{ $$$double });\n        x_y_values = Sort.sort(x_y_values, $sym47$_, FIRST);\n        final SubLObject poly_spline_function = JavaLink.java_call(interpolate_method, interpolator, new SubLObject[]{ Mapping.mapcar(FIRST, x_y_values), Mapping.mapcar(SECOND, x_y_values) });\n        return JavaLink.java_call(value_method, poly_spline_function, new SubLObject[]{ x_value });\n    }\n\n    public static SubLObject java_link_x_y_piecewise_linear_find_y_for_x(SubLObject x_y_values, final SubLObject x_value) {\n        if ((x_value.numL(apply(MIN, Mapping.mapcar(FIRST, x_y_values))) || x_value.numG(apply(MAX, Mapping.mapcar(FIRST, x_y_values)))) || ((NIL == java_link_debug_modeP()) && (NIL != list_utilities.duplicatesP(Mapping.mapcar(FIRST, x_y_values), UNPROVIDED, UNPROVIDED)))) {\n            return NIL;\n        }\n        final SubLObject interpolator = JavaLink.java_new($str49$org_apache_commons_math_analysis_, EMPTY_SUBL_OBJECT_ARRAY);\n        final SubLObject interpolate_method = JavaLink.java_method($str49$org_apache_commons_math_analysis_, $$$interpolate, new SubLObject[]{ $str44$_D, $str44$_D });\n        final SubLObject value_method = JavaLink.java_method($str45$org_apache_commons_math_analysis_, $$$value, new SubLObject[]{ $$$double });\n        x_y_values = Sort.sort(x_y_values, $sym47$_, FIRST);\n        final SubLObject poly_spline_function = JavaLink.java_call(interpolate_method, interpolator, new SubLObject[]{ Mapping.mapcar(FIRST, x_y_values), Mapping.mapcar(SECOND, x_y_values) });\n        return JavaLink.java_call(value_method, poly_spline_function, new SubLObject[]{ x_value });\n    }\n\n    public static SubLObject java_link_x_y_regression_find_y_for_x(final SubLObject x_y_values, final SubLObject x_value) {\n        final SubLObject regression = JavaLink.java_new($str35$org_apache_commons_math_stat_regr, EMPTY_SUBL_OBJECT_ARRAY);\n        final SubLObject add_data_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$addData, new SubLObject[]{ $$$double, $$$double });\n        final SubLObject predict_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$predict, new SubLObject[]{ $$$double });\n        SubLObject cdolist_list_var = x_y_values;\n        SubLObject x_y_value = NIL;\n        x_y_value = cdolist_list_var.first();\n        while (NIL != cdolist_list_var) {\n            JavaLink.java_call(add_data_method, regression, new SubLObject[]{ x_y_value.first(), second(x_y_value) });\n            cdolist_list_var = cdolist_list_var.rest();\n            x_y_value = cdolist_list_var.first();\n        } \n        return JavaLink.java_call(predict_method, regression, new SubLObject[]{ x_value });\n    }\n\n    public static SubLObject java_link_x_y_regression_find_y_for_x_with_error_bars(final SubLObject x_y_values, final SubLObject x_value) {\n        if (length(x_y_values).numL(THREE_INTEGER)) {\n            return NIL;\n        }\n        final SubLObject number_of_points = length(x_y_values);\n        final SubLObject regression = JavaLink.java_new($str35$org_apache_commons_math_stat_regr, EMPTY_SUBL_OBJECT_ARRAY);\n        final SubLObject add_data_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$addData, new SubLObject[]{ $$$double, $$$double });\n        final SubLObject sse_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$getSumSquaredErrors, EMPTY_SUBL_OBJECT_ARRAY);\n        final SubLObject predict_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$predict, new SubLObject[]{ $$$double });\n        SubLObject cdolist_list_var = x_y_values;\n        SubLObject x_y_value = NIL;\n        x_y_value = cdolist_list_var.first();\n        while (NIL != cdolist_list_var) {\n            JavaLink.java_call(add_data_method, regression, new SubLObject[]{ x_y_value.first(), second(x_y_value) });\n            cdolist_list_var = cdolist_list_var.rest();\n            x_y_value = cdolist_list_var.first();\n        } \n        final SubLObject sum_of_squared_errors = JavaLink.java_call(sse_method, regression, EMPTY_SUBL_OBJECT_ARRAY);\n        final SubLObject y_error = sqrt(divide(sum_of_squared_errors, subtract(number_of_points, TWO_INTEGER)));\n        return values(JavaLink.java_call(predict_method, regression, new SubLObject[]{ x_value }), y_error);\n    }\n\n    public static SubLObject java_link_point_intersection_of_two_x_y_regressions(final SubLObject x_y_values_1, final SubLObject x_y_values_2) {\n        if ((((NIL == x_y_values_1) || (NIL != list_utilities.singletonP(x_y_values_1))) || (NIL == x_y_values_2)) || (NIL != list_utilities.singletonP(x_y_values_2))) {\n            return NIL;\n        }\n        final SubLObject regression_1 = JavaLink.java_new($str35$org_apache_commons_math_stat_regr, EMPTY_SUBL_OBJECT_ARRAY);\n        final SubLObject regression_2 = JavaLink.java_new($str35$org_apache_commons_math_stat_regr, EMPTY_SUBL_OBJECT_ARRAY);\n        final SubLObject add_data_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$addData, new SubLObject[]{ $$$double, $$$double });\n        final SubLObject predict_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$predict, new SubLObject[]{ $$$double });\n        final SubLObject l1_p1_x = x_y_values_1.first().first();\n        final SubLObject l1_p2_x = second(x_y_values_1).first();\n        final SubLObject l2_p1_x = x_y_values_2.first().first();\n        final SubLObject l2_p2_x = second(x_y_values_2).first();\n        SubLObject cdolist_list_var = x_y_values_1;\n        SubLObject x_y_value_1 = NIL;\n        x_y_value_1 = cdolist_list_var.first();\n        while (NIL != cdolist_list_var) {\n            JavaLink.java_call(add_data_method, regression_1, new SubLObject[]{ x_y_value_1.first(), second(x_y_value_1) });\n            cdolist_list_var = cdolist_list_var.rest();\n            x_y_value_1 = cdolist_list_var.first();\n        } \n        cdolist_list_var = x_y_values_2;\n        SubLObject x_y_value_2 = NIL;\n        x_y_value_2 = cdolist_list_var.first();\n        while (NIL != cdolist_list_var) {\n            JavaLink.java_call(add_data_method, regression_2, new SubLObject[]{ x_y_value_2.first(), second(x_y_value_2) });\n            cdolist_list_var = cdolist_list_var.rest();\n            x_y_value_2 = cdolist_list_var.first();\n        } \n        final SubLObject l1_p1_y = JavaLink.java_call(predict_method, regression_1, new SubLObject[]{ l1_p1_x });\n        final SubLObject l1_p2_y = JavaLink.java_call(predict_method, regression_1, new SubLObject[]{ l1_p2_x });\n        final SubLObject l2_p1_y = JavaLink.java_call(predict_method, regression_2, new SubLObject[]{ l2_p1_x });\n        final SubLObject l2_p2_y = JavaLink.java_call(predict_method, regression_2, new SubLObject[]{ l2_p2_x });\n        final SubLObject line_class_name = $str52$org_apache_commons_math_geometry_;\n        final SubLObject vector2d_class_name = $str53$org_apache_commons_math_geometry_;\n        final SubLObject line_new_method = JavaLink.java_method(line_class_name, NIL, new SubLObject[]{ vector2d_class_name, vector2d_class_name });\n        final SubLObject vector2d_new_method = JavaLink.java_method(vector2d_class_name, NIL, new SubLObject[]{ $$$double, $$$double });\n        final SubLObject line_1 = JavaLink.java_new(line_new_method, new SubLObject[]{ JavaLink.java_new(vector2d_new_method, new SubLObject[]{ l1_p1_x, l1_p1_y }), JavaLink.java_new(vector2d_new_method, new SubLObject[]{ l1_p2_x, l1_p2_y }) });\n        final SubLObject line_2 = JavaLink.java_new(line_new_method, new SubLObject[]{ JavaLink.java_new(vector2d_new_method, new SubLObject[]{ l2_p1_x, l2_p1_y }), JavaLink.java_new(vector2d_new_method, new SubLObject[]{ l2_p2_x, l2_p2_y }) });\n        final SubLObject intersection_method = JavaLink.java_method(line_class_name, $$$intersection, new SubLObject[]{ $str55$org_apache_commons_math_geometry_ });\n        final SubLObject intersection_2dvector = JavaLink.java_call(intersection_method, line_1, new SubLObject[]{ line_2 });\n        if (NIL != intersection_2dvector) {\n            final SubLObject vector2d_getx_method = JavaLink.java_method(vector2d_class_name, $$$getX, EMPTY_SUBL_OBJECT_ARRAY);\n            final SubLObject vector2d_gety_method = JavaLink.java_method(vector2d_class_name, $$$getY, EMPTY_SUBL_OBJECT_ARRAY);\n            return values(JavaLink.java_call(vector2d_getx_method, intersection_2dvector, EMPTY_SUBL_OBJECT_ARRAY), JavaLink.java_call(vector2d_gety_method, intersection_2dvector, EMPTY_SUBL_OBJECT_ARRAY));\n        }\n        return NIL;\n    }\n\n    public static SubLObject java_link_x_y_derivatives_for_interpolation_at_each_x(SubLObject x_y_values, final SubLObject interpolator) {\n        if ((NIL == java_link_debug_modeP()) && (NIL != list_utilities.duplicatesP(Mapping.mapcar(FIRST, x_y_values), UNPROVIDED, UNPROVIDED))) {\n            return NIL;\n        }\n        final SubLObject interpolator_string = (interpolator.eql($$CubicSpline)) ? $str42$org_apache_commons_math_analysis_ : interpolator.eql($const59$LinearPolynomialFunction_Piecewis) ? $str49$org_apache_commons_math_analysis_ : $str42$org_apache_commons_math_analysis_;\n        final SubLObject interpolator_$1 = JavaLink.java_new(interpolator_string, EMPTY_SUBL_OBJECT_ARRAY);\n        final SubLObject interpolate_method = JavaLink.java_method(interpolator_string, $$$interpolate, new SubLObject[]{ $str44$_D, $str44$_D });\n        final SubLObject value_method = JavaLink.java_method($str45$org_apache_commons_math_analysis_, $$$value, new SubLObject[]{ $$$double });\n        final SubLObject derivative_method = JavaLink.java_method($str45$org_apache_commons_math_analysis_, $$$derivative, EMPTY_SUBL_OBJECT_ARRAY);\n        SubLObject derivative_x_y_values = NIL;\n        x_y_values = Sort.sort(copy_list(x_y_values), $sym47$_, FIRST);\n        final SubLObject poly_spline_function = JavaLink.java_call(interpolate_method, interpolator_$1, new SubLObject[]{ Mapping.mapcar(FIRST, x_y_values), Mapping.mapcar(SECOND, x_y_values) });\n        final SubLObject poly_spline_derivative = JavaLink.java_call(derivative_method, poly_spline_function, EMPTY_SUBL_OBJECT_ARRAY);\n        SubLObject cdolist_list_var = x_y_values;\n        SubLObject x_y_value = NIL;\n        x_y_value = cdolist_list_var.first();\n        while (NIL != cdolist_list_var) {\n            final SubLObject x_value = x_y_value.first();\n            derivative_x_y_values = cons(list(x_value, JavaLink.java_call(value_method, poly_spline_derivative, new SubLObject[]{ x_value })), derivative_x_y_values);\n            cdolist_list_var = cdolist_list_var.rest();\n            x_y_value = cdolist_list_var.first();\n        } \n        return nreverse(derivative_x_y_values);\n    }\n\n    public static SubLObject el_2d_point_p(final SubLObject v_object) {\n        return makeBoolean(((NIL != el_formula_p(v_object)) && cycl_utilities.formula_operator(v_object).eql($$The2DPoint)) && (NIL != el_binary_formula_p(v_object)));\n    }\n\n    public static SubLObject explode_2d_points_with_units(final SubLObject v_2d_points, SubLObject x_units, SubLObject y_units) {\n        if (x_units == UNPROVIDED) {\n            x_units = NIL;\n        }\n        if (y_units == UNPROVIDED) {\n            y_units = NIL;\n        }\n        final SubLThread thread = SubLProcess.currentSubLThread();\n        assert NIL != list_utilities.non_dotted_list_p(v_2d_points) : \"list_utilities.non_dotted_list_p(v_2d_points) \" + \"CommonSymbols.NIL != list_utilities.non_dotted_list_p(v_2d_points) \" + v_2d_points;\n        SubLObject cdolist_list_var = v_2d_points;\n        SubLObject elem = NIL;\n        elem = cdolist_list_var.first();\n        while (NIL != cdolist_list_var) {\n            assert NIL != el_2d_point_p(elem) : \"removal_modules_math.el_2d_point_p(elem) \" + \"CommonSymbols.NIL != removal_modules_math.el_2d_point_p(elem) \" + elem;\n            cdolist_list_var = cdolist_list_var.rest();\n            elem = cdolist_list_var.first();\n        } \n        SubLObject x_y_values = NIL;\n        cdolist_list_var = v_2d_points;\n        SubLObject v_2d_point = NIL;\n        v_2d_point = cdolist_list_var.first();\n        while (NIL != cdolist_list_var) {\n            final SubLObject x_y_with_units = cycl_utilities.formula_args(v_2d_point, UNPROVIDED);\n            final SubLObject x_with_units = x_y_with_units.first();\n            final SubLObject y_with_units = second(x_y_with_units);\n            thread.resetMultipleValues();\n            final SubLObject this_x_units = quantities.explode_interval(x_with_units);\n            SubLObject this_x_value = thread.secondMultipleValue();\n            thread.resetMultipleValues();\n            if (NIL == x_units) {\n                x_units = this_x_units;\n            }\n            if (!x_units.equal(this_x_units)) {\n                this_x_value = quantities.convert_to_units_absolute(x_units, this_x_units, this_x_value, UNPROVIDED);\n            }\n            thread.resetMultipleValues();\n            final SubLObject this_y_units = quantities.explode_interval(y_with_units);\n            SubLObject this_y_value = thread.secondMultipleValue();\n            thread.resetMultipleValues();\n            if (NIL == y_units) {\n                y_units = this_y_units;\n            }\n            if (!y_units.equal(this_y_units)) {\n                this_y_value = quantities.convert_to_units_absolute(y_units, this_y_units, this_y_value, UNPROVIDED);\n            }\n            x_y_values = cons(list(this_x_value, this_y_value), x_y_values);\n            cdolist_list_var = cdolist_list_var.rest();\n            v_2d_point = cdolist_list_var.first();\n        } \n        return values(x_y_values, x_units, y_units);\n    }\n\n    public static SubLObject removal_set_has_points_with_y_value_reln_to_expand(final SubLObject asent, SubLObject sense) {\n        if (sense == UNPROVIDED) {\n            sense = NIL;\n        }\n        final SubLObject set_of_points_in_units = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);\n        final SubLObject operator = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);\n        final SubLObject comparator = cycl_utilities.atomic_sentence_arg3(asent, UNPROVIDED);\n        final SubLObject quant1 = cycl_utilities.atomic_sentence_arg4(asent, UNPROVIDED);\n        final SubLObject quant2 = cycl_utilities.atomic_sentence_arg5(asent, UNPROVIDED);\n        final SubLObject newset_var = cycl_utilities.atomic_sentence_arg6(asent, UNPROVIDED);\n        if ((((NIL != el_extensional_set_p(set_of_points_in_units)) && (NIL != fort_types_interface.functionP(operator))) && (NIL != relation_evaluation.evaluatable_predicateP(comparator, UNPROVIDED))) && arity.arity(comparator).eql(TWO_INTEGER)) {\n            final SubLObject x_y_values_with_units = extensional_set_elements(set_of_points_in_units);\n            SubLObject result_points = NIL;\n            if (NIL != list_utilities.every_in_list(EL_2D_POINT_P, x_y_values_with_units, UNPROVIDED)) {\n                SubLObject cdolist_list_var = x_y_values_with_units;\n                SubLObject x_y_value_with_units = NIL;\n                x_y_value_with_units = cdolist_list_var.first();\n                while (NIL != cdolist_list_var) {\n                    final SubLObject y_value = cycl_utilities.formula_arg2(x_y_value_with_units, UNPROVIDED);\n                    if (NIL != relation_evaluation.cyc_evaluate(list(comparator, list(operator, y_value, quant1), quant2))) {\n                        result_points = cons(x_y_value_with_units, result_points);\n                    }\n                    cdolist_list_var = cdolist_list_var.rest();\n                    x_y_value_with_units = cdolist_list_var.first();\n                } \n            }\n            if (NIL != result_points) {\n                final SubLObject v_bindings = unification_utilities.term_unify(make_el_set(list_utilities.fast_remove_duplicates(result_points, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED), UNPROVIDED), newset_var, UNPROVIDED, UNPROVIDED);\n                if (NIL != v_bindings) {\n                    backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings, asent), UNPROVIDED, UNPROVIDED), v_bindings, UNPROVIDED);\n                }\n            }\n        }\n        return NIL;\n    }\n\n    public static SubLObject removal_operation_result_comparison_pos_check(final SubLObject asent, SubLObject sense) {\n        if (sense == UNPROVIDED) {\n            sense = NIL;\n        }\n        final SubLObject operator = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);\n        final SubLObject a = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);\n        final SubLObject b = cycl_utilities.atomic_sentence_arg3(asent, UNPROVIDED);\n        final SubLObject comparator = cycl_utilities.atomic_sentence_arg4(asent, UNPROVIDED);\n        final SubLObject quant = cycl_utilities.atomic_sentence_arg5(asent, UNPROVIDED);\n        if (((NIL != fort_types_interface.functionP(operator)) && (NIL != relation_evaluation.evaluatable_predicateP(comparator, UNPROVIDED))) && arity.arity(comparator).eql(TWO_INTEGER)) {\n            final SubLObject expression = list(comparator, list(operator, a, b), quant);\n            if (NIL != relation_evaluation.cyc_evaluate(expression)) {\n                backward.removal_add_node(arguments.make_hl_support($OPAQUE, asent, UNPROVIDED, UNPROVIDED), NIL, list(removal_modules_evaluation.make_eval_support(expression, UNPROVIDED)));\n            }\n        }\n        return NIL;\n    }\n\n    public static SubLObject removal_operation_result_comparison_neg_check(final SubLObject asent, SubLObject sense) {\n        if (sense == UNPROVIDED) {\n            sense = NIL;\n        }\n        final SubLObject operator = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);\n        final SubLObject a = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);\n        final SubLObject b = cycl_utilities.atomic_sentence_arg3(asent, UNPROVIDED);\n        final SubLObject comparator = cycl_utilities.atomic_sentence_arg4(asent, UNPROVIDED);\n        final SubLObject quant = cycl_utilities.atomic_sentence_arg5(asent, UNPROVIDED);\n        if (((NIL != fort_types_interface.functionP(operator)) && (NIL != relation_evaluation.evaluatable_predicateP(comparator, UNPROVIDED))) && arity.arity(comparator).eql(TWO_INTEGER)) {\n            final SubLObject expression = list(comparator, list(operator, a, b), quant);\n            if (NIL == relation_evaluation.cyc_evaluate(expression)) {\n                backward.removal_add_node(arguments.make_hl_support($OPAQUE, make_negation(asent), UNPROVIDED, UNPROVIDED), NIL, list(removal_modules_evaluation.make_eval_support(make_negation(expression), UNPROVIDED)));\n            }\n        }\n        return NIL;\n    }\n\n    public static SubLObject removal_inflow_lengths_with_starting_depths_expand(final SubLObject asent, SubLObject sense) {\n        if (sense == UNPROVIDED) {\n            sense = NIL;\n        }\n        final SubLThread thread = SubLProcess.currentSubLThread();\n        final SubLObject well = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);\n        final SubLObject set_of_points_in_units = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);\n        final SubLObject function_type = $$CubicSpline;\n        final SubLObject length_and_depths_query = cycl_utilities.atomic_sentence_arg3(asent, UNPROVIDED);\n        final SubLObject debugP = NIL;\n        if (NIL != el_extensional_set_p(set_of_points_in_units)) {\n            final SubLObject v_2d_points = extensional_set_elements(set_of_points_in_units);\n            if (NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points, UNPROVIDED)) {\n                thread.resetMultipleValues();\n                SubLObject x_y_values = explode_2d_points_with_units(v_2d_points, $$Meter, $$DegreeCelsius);\n                final SubLObject x_units = thread.secondMultipleValue();\n                final SubLObject y_units = thread.thirdMultipleValue();\n                thread.resetMultipleValues();\n                x_y_values = Sort.sort(copy_list(x_y_values), $sym47$_, FIRST);\n                final SubLObject x_y_derivative_points = java_link_x_y_derivatives_for_interpolation_at_each_x(x_y_values, function_type);\n                final SubLObject average_y_value = number_utilities.average(x_y_values, SECOND);\n                final SubLObject derivative_units = quantities.unit_quotient(y_units, x_units);\n                SubLObject inflow_lengths = NIL;\n                if (NIL != debugP) {\n                    print(x_y_values, UNPROVIDED);\n                    print(x_y_derivative_points, UNPROVIDED);\n                    format_nil.force_format(T, $str76$____, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);\n                }\n                SubLObject cdolist_list_var = Sort.sort(copy_list(x_y_values), $sym85$_, SECOND);\n                SubLObject x_y_value = NIL;\n                x_y_value = cdolist_list_var.first();\n                while (NIL != cdolist_list_var) {\n                    SubLObject current;\n                    final SubLObject datum = current = x_y_value;\n                    SubLObject x_value = NIL;\n                    SubLObject y_value = NIL;\n                    destructuring_bind_must_consp(current, datum, $list77);\n                    x_value = current.first();\n                    current = current.rest();\n                    destructuring_bind_must_consp(current, datum, $list77);\n                    y_value = current.first();\n                    current = current.rest();\n                    if (NIL == current) {\n                        if (NIL != debugP) {\n                            format_nil.force_format(T, $str78$High_value__x__A_y__A__, x_value, y_value, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);\n                        }\n                        if (y_value.numG(add(FIVE_INTEGER, average_y_value))) {\n                            SubLObject already_in_inflowP = NIL;\n                            SubLObject inflow_start_x = NIL;\n                            SubLObject inflow_end_x = NIL;\n                            if (NIL == already_in_inflowP) {\n                                SubLObject csome_list_var = inflow_lengths;\n                                SubLObject inflow_length = NIL;\n                                inflow_length = csome_list_var.first();\n                                while ((NIL == already_in_inflowP) && (NIL != csome_list_var)) {\n                                    if (x_value.numGE(inflow_length.first()) && x_value.numLE(second(inflow_length))) {\n                                        already_in_inflowP = T;\n                                    }\n                                    csome_list_var = csome_list_var.rest();\n                                    inflow_length = csome_list_var.first();\n                                } \n                            }\n                            if (NIL == already_in_inflowP) {\n                                SubLObject found_start_pointP = NIL;\n                                if (NIL == found_start_pointP) {\n                                    SubLObject cur_x_y_value = NIL;\n                                    SubLObject cur_x_y_value_$2 = NIL;\n                                    SubLObject cur_x_y_derivative_point = NIL;\n                                    SubLObject cur_x_y_derivative_point_$3 = NIL;\n                                    cur_x_y_value = nreverse(copy_list(x_y_values));\n                                    cur_x_y_value_$2 = cur_x_y_value.first();\n                                    cur_x_y_derivative_point = nreverse(copy_list(x_y_derivative_points));\n                                    cur_x_y_derivative_point_$3 = cur_x_y_derivative_point.first();\n                                    while ((NIL == found_start_pointP) && ((NIL != cur_x_y_derivative_point) || (NIL != cur_x_y_value))) {\n                                        SubLObject current_$5;\n                                        final SubLObject datum_$4 = current_$5 = cur_x_y_derivative_point_$3;\n                                        SubLObject cur_x_value = NIL;\n                                        SubLObject cur_y_derivative_value = NIL;\n                                        destructuring_bind_must_consp(current_$5, datum_$4, $list79);\n                                        cur_x_value = current_$5.first();\n                                        current_$5 = current_$5.rest();\n                                        destructuring_bind_must_consp(current_$5, datum_$4, $list79);\n                                        cur_y_derivative_value = current_$5.first();\n                                        current_$5 = current_$5.rest();\n                                        if (NIL == current_$5) {\n                                            final SubLObject cur_y_value = second(cur_x_y_value_$2);\n                                            if (NIL != debugP) {\n                                                format_nil.force_format(T, $str80$checking_x__A_deriv__A__, cur_x_value, cur_y_derivative_value, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);\n                                                if (!cur_x_value.eql(cur_x_y_value_$2.first())) {\n                                                    print($$$Bad_looping, UNPROVIDED);\n                                                    Errors.sublisp_break(UNPROVIDED, EMPTY_SUBL_OBJECT_ARRAY);\n                                                }\n                                            }\n                                            if (cur_y_derivative_value.numGE($float$0_5) && cur_x_value.numL(x_value)) {\n                                                found_start_pointP = T;\n                                                inflow_start_x = cur_x_value;\n                                            }\n                                        } else {\n                                            cdestructuring_bind_error(datum_$4, $list79);\n                                        }\n                                        cur_x_y_value = cur_x_y_value.rest();\n                                        cur_x_y_value_$2 = cur_x_y_value.first();\n                                        cur_x_y_derivative_point = cur_x_y_derivative_point.rest();\n                                        cur_x_y_derivative_point_$3 = cur_x_y_derivative_point.first();\n                                    } \n                                }\n                                SubLObject found_end_pointP = NIL;\n                                if (NIL == found_end_pointP) {\n                                    SubLObject cur_x_y_value = NIL;\n                                    SubLObject cur_x_y_value_$3 = NIL;\n                                    SubLObject cur_x_y_derivative_point = NIL;\n                                    SubLObject cur_x_y_derivative_point_$4 = NIL;\n                                    cur_x_y_value = x_y_values;\n                                    cur_x_y_value_$3 = cur_x_y_value.first();\n                                    cur_x_y_derivative_point = x_y_derivative_points;\n                                    cur_x_y_derivative_point_$4 = cur_x_y_derivative_point.first();\n                                    while ((NIL == found_end_pointP) && ((NIL != cur_x_y_derivative_point) || (NIL != cur_x_y_value))) {\n                                        SubLObject current_$6;\n                                        final SubLObject datum_$5 = current_$6 = cur_x_y_derivative_point_$4;\n                                        SubLObject cur_x_value = NIL;\n                                        SubLObject cur_y_derivative_value = NIL;\n                                        destructuring_bind_must_consp(current_$6, datum_$5, $list79);\n                                        cur_x_value = current_$6.first();\n                                        current_$6 = current_$6.rest();\n                                        destructuring_bind_must_consp(current_$6, datum_$5, $list79);\n                                        cur_y_derivative_value = current_$6.first();\n                                        current_$6 = current_$6.rest();\n                                        if (NIL == current_$6) {\n                                            final SubLObject cur_y_value = second(cur_x_y_value_$3);\n                                            if (NIL != debugP) {\n                                                format_nil.force_format(T, $str80$checking_x__A_deriv__A__, cur_x_value, cur_y_derivative_value, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);\n                                                if (!cur_x_value.eql(cur_x_y_value_$3.first())) {\n                                                    print($$$Bad_looping, UNPROVIDED);\n                                                    Errors.sublisp_break(UNPROVIDED, EMPTY_SUBL_OBJECT_ARRAY);\n                                                }\n                                            }\n                                            if (cur_y_derivative_value.numLE($float$_0_5) && cur_x_value.numG(x_value)) {\n                                                found_end_pointP = T;\n                                                inflow_end_x = cur_x_value;\n                                            }\n                                        } else {\n                                            cdestructuring_bind_error(datum_$5, $list79);\n                                        }\n                                        cur_x_y_value = cur_x_y_value.rest();\n                                        cur_x_y_value_$3 = cur_x_y_value.first();\n                                        cur_x_y_derivative_point = cur_x_y_derivative_point.rest();\n                                        cur_x_y_derivative_point_$4 = cur_x_y_derivative_point.first();\n                                    } \n                                }\n                            }\n                            if ((NIL != inflow_start_x) && (NIL != inflow_end_x)) {\n                                if (NIL != debugP) {\n                                    format_nil.force_format(T, $str84$Got_interval___A__A___, inflow_start_x, inflow_end_x, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);\n                                }\n                                inflow_lengths = cons(list(inflow_start_x, inflow_end_x), inflow_lengths);\n                            }\n                        }\n                    } else {\n                        cdestructuring_bind_error(datum, $list77);\n                    }\n                    cdolist_list_var = cdolist_list_var.rest();\n                    x_y_value = cdolist_list_var.first();\n                } \n                inflow_lengths = Sort.sort(inflow_lengths, $sym47$_, FIRST);\n                if (NIL != debugP) {\n                    format_nil.force_format(T, $str86$inflow_lengths___A__, inflow_lengths, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);\n                }\n                SubLObject merged_inflow_lengths = NIL;\n                SubLObject cur_start = NIL;\n                SubLObject cur_end = NIL;\n                SubLObject cdolist_list_var2 = inflow_lengths;\n                SubLObject inflow_length2 = NIL;\n                inflow_length2 = cdolist_list_var2.first();\n                while (NIL != cdolist_list_var2) {\n                    SubLObject current2;\n                    final SubLObject datum2 = current2 = inflow_length2;\n                    SubLObject start = NIL;\n                    SubLObject end = NIL;\n                    destructuring_bind_must_consp(current2, datum2, $list87);\n                    start = current2.first();\n                    current2 = current2.rest();\n                    destructuring_bind_must_consp(current2, datum2, $list87);\n                    end = current2.first();\n                    current2 = current2.rest();\n                    if (NIL == current2) {\n                        if ((NIL != cur_start) && (NIL != cur_end)) {\n                            if (start.numLE(cur_end)) {\n                                cur_end = end;\n                            } else {\n                                merged_inflow_lengths = cons(list(cur_start, cur_end), merged_inflow_lengths);\n                                cur_start = start;\n                                cur_end = end;\n                            }\n                        } else {\n                            cur_start = start;\n                            cur_end = end;\n                        }\n                    } else {\n                        cdestructuring_bind_error(datum2, $list87);\n                    }\n                    cdolist_list_var2 = cdolist_list_var2.rest();\n                    inflow_length2 = cdolist_list_var2.first();\n                } \n                if ((NIL != cur_start) && (NIL != cur_end)) {\n                    merged_inflow_lengths = cons(list(cur_start, cur_end), merged_inflow_lengths);\n                }\n                if (NIL != debugP) {\n                    format_nil.force_format(T, $str88$merged_inflow_lengths___A__, merged_inflow_lengths, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);\n                }\n                inflow_lengths = merged_inflow_lengths;\n                SubLObject result = NIL;\n                SubLObject cdolist_list_var3 = inflow_lengths;\n                SubLObject result_inflow_length = NIL;\n                result_inflow_length = cdolist_list_var3.first();\n                while (NIL != cdolist_list_var3) {\n                    result = cons(list($$TheList, list(x_units, result_inflow_length.first()), list(x_units, subtract(second(result_inflow_length), result_inflow_length.first()))), result);\n                    cdolist_list_var3 = cdolist_list_var3.rest();\n                    result_inflow_length = cdolist_list_var3.first();\n                } \n                result = make_el_list(result, UNPROVIDED);\n                final SubLObject v_bindings = unification_utilities.term_unify(result, length_and_depths_query, UNPROVIDED, UNPROVIDED);\n                if (NIL != v_bindings) {\n                    backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings, asent), UNPROVIDED, UNPROVIDED), v_bindings, UNPROVIDED);\n                }\n            }\n        }\n        return NIL;\n    }\n\n    public static SubLObject declare_removal_modules_math_file() {\n        declareFunction(\"removal_interpolation_with_cubic_spline_expand\", \"REMOVAL-INTERPOLATION-WITH-CUBIC-SPLINE-EXPAND\", 1, 1, false);\n        declareFunction(\"removal_interpolation_with_piecewise_linear_polynomial_expand\", \"REMOVAL-INTERPOLATION-WITH-PIECEWISE-LINEAR-POLYNOMIAL-EXPAND\", 1, 1, false);\n        declareFunction(\"removal_extrapolation_with_simple_linear_regression_expand\", \"REMOVAL-EXTRAPOLATION-WITH-SIMPLE-LINEAR-REGRESSION-EXPAND\", 1, 1, false);\n        declareFunction(\"removal_interpolation_or_extrapolation_with_java_link_function_expand_helper\", \"REMOVAL-INTERPOLATION-OR-EXTRAPOLATION-WITH-JAVA-LINK-FUNCTION-EXPAND-HELPER\", 2, 0, false);\n        declareFunction(\"removal_extrapolation_with_simple_linear_regression_with_error_bars_expand\", \"REMOVAL-EXTRAPOLATION-WITH-SIMPLE-LINEAR-REGRESSION-WITH-ERROR-BARS-EXPAND\", 1, 1, false);\n        declareFunction(\"removal_interpolation_or_extrapolation_with_error_bars_with_java_link_function_expand_helper\", \"REMOVAL-INTERPOLATION-OR-EXTRAPOLATION-WITH-ERROR-BARS-WITH-JAVA-LINK-FUNCTION-EXPAND-HELPER\", 2, 0, false);\n        declareFunction(\"removal_regression_lines_for_sets_intersect_at_point_expand\", \"REMOVAL-REGRESSION-LINES-FOR-SETS-INTERSECT-AT-POINT-EXPAND\", 1, 1, false);\n        declareFunction(\"removal_slope_of_regression_line_for_set_of_points_expand\", \"REMOVAL-SLOPE-OF-REGRESSION-LINE-FOR-SET-OF-POINTS-EXPAND\", 1, 1, false);\n        declareFunction(\"removal_set_of_first_derivative_points_based_on_set_of_points_expand\", \"REMOVAL-SET-OF-FIRST-DERIVATIVE-POINTS-BASED-ON-SET-OF-POINTS-EXPAND\", 1, 1, false);\n        declareFunction(\"removal_set_has_points_with_y_value_reln_to_matching_x_value_points_in_set_expand\", \"REMOVAL-SET-HAS-POINTS-WITH-Y-VALUE-RELN-TO-MATCHING-X-VALUE-POINTS-IN-SET-EXPAND\", 1, 1, false);\n        declareFunction(\"java_link_debug_modeP\", \"JAVA-LINK-DEBUG-MODE?\", 0, 0, false);\n        declareFunction(\"java_link_slope_and_intercept_of_x_y_regression\", \"JAVA-LINK-SLOPE-AND-INTERCEPT-OF-X-Y-REGRESSION\", 1, 0, false);\n        declareFunction(\"java_link_x_y_cubic_spline_find_y_for_x\", \"JAVA-LINK-X-Y-CUBIC-SPLINE-FIND-Y-FOR-X\", 2, 0, false);\n        declareFunction(\"java_link_x_y_piecewise_linear_find_y_for_x\", \"JAVA-LINK-X-Y-PIECEWISE-LINEAR-FIND-Y-FOR-X\", 2, 0, false);\n        declareFunction(\"java_link_x_y_regression_find_y_for_x\", \"JAVA-LINK-X-Y-REGRESSION-FIND-Y-FOR-X\", 2, 0, false);\n        declareFunction(\"java_link_x_y_regression_find_y_for_x_with_error_bars\", \"JAVA-LINK-X-Y-REGRESSION-FIND-Y-FOR-X-WITH-ERROR-BARS\", 2, 0, false);\n        declareFunction(\"java_link_point_intersection_of_two_x_y_regressions\", \"JAVA-LINK-POINT-INTERSECTION-OF-TWO-X-Y-REGRESSIONS\", 2, 0, false);\n        declareFunction(\"java_link_x_y_derivatives_for_interpolation_at_each_x\", \"JAVA-LINK-X-Y-DERIVATIVES-FOR-INTERPOLATION-AT-EACH-X\", 2, 0, false);\n        declareFunction(\"el_2d_point_p\", \"EL-2D-POINT-P\", 1, 0, false);\n        declareFunction(\"explode_2d_points_with_units\", \"EXPLODE-2D-POINTS-WITH-UNITS\", 1, 2, false);\n        declareFunction(\"removal_set_has_points_with_y_value_reln_to_expand\", \"REMOVAL-SET-HAS-POINTS-WITH-Y-VALUE-RELN-TO-EXPAND\", 1, 1, false);\n        declareFunction(\"removal_operation_result_comparison_pos_check\", \"REMOVAL-OPERATION-RESULT-COMPARISON-POS-CHECK\", 1, 1, false);\n        declareFunction(\"removal_operation_result_comparison_neg_check\", \"REMOVAL-OPERATION-RESULT-COMPARISON-NEG-CHECK\", 1, 1, false);\n        declareFunction(\"removal_inflow_lengths_with_starting_depths_expand\", \"REMOVAL-INFLOW-LENGTHS-WITH-STARTING-DEPTHS-EXPAND\", 1, 1, false);\n        return NIL;\n    }\n\n    public static SubLObject init_removal_modules_math_file() {\n        defparameter(\"*DEFAULT-MATH-MODULE-COST*\", $typical_hl_module_check_cost$.getGlobalValue());\n        return NIL;\n    }\n\n    public static SubLObject setup_removal_modules_math_file() {\n        inference_modules.register_solely_specific_removal_module_predicate($$interpolationWithCubicSpline);\n        preference_modules.doomed_unless_arg_bindable($POS, $$interpolationWithCubicSpline, ONE_INTEGER);\n        inference_modules.inference_removal_module($REMOVAL_INTERPOLATION_WITH_CUBIC_SPLINE, $list3);\n        inference_modules.register_solely_specific_removal_module_predicate($const5$interpolationWithPiecewiseLinearP);\n        preference_modules.doomed_unless_arg_bindable($POS, $const5$interpolationWithPiecewiseLinearP, ONE_INTEGER);\n        inference_modules.inference_removal_module($REMOVAL_INTERPOLATION_WITH_PIECEWISE_LINEAR_POLYNOMIAL, $list7);\n        inference_modules.register_solely_specific_removal_module_predicate($const9$extrapolationWithSimpleLinearRegr);\n        preference_modules.doomed_unless_arg_bindable($POS, $const9$extrapolationWithSimpleLinearRegr, ONE_INTEGER);\n        inference_modules.inference_removal_module($REMOVAL_EXTRAPOLATION_WITH_SIMPLE_LINEAR_REGRESSION, $list11);\n        inference_modules.register_solely_specific_removal_module_predicate($const17$extrapolationWithSimpleLinearRegr);\n        preference_modules.doomed_unless_arg_bindable($POS, $const17$extrapolationWithSimpleLinearRegr, ONE_INTEGER);\n        inference_modules.inference_removal_module($kw18$REMOVAL_EXTRAPOLATION_WITH_SIMPLE_LINEAR_REGRESSION_WITH_ERROR_BA, $list19);\n        inference_modules.register_solely_specific_removal_module_predicate($const21$regressionLinesForSetsIntersectAt);\n        preference_modules.doomed_unless_arg_bindable($POS, $const21$regressionLinesForSetsIntersectAt, ONE_INTEGER);\n        preference_modules.doomed_unless_arg_bindable($POS, $const21$regressionLinesForSetsIntersectAt, TWO_INTEGER);\n        inference_modules.inference_removal_module($REMOVAL_REGRESSION_LINES_FOR_SETS_INTERSECT_AT_POINT, $list23);\n        inference_modules.register_solely_specific_removal_module_predicate($const25$slopeOfRegressionLineForSetOfPoin);\n        preference_modules.doomed_unless_arg_bindable($POS, $const25$slopeOfRegressionLineForSetOfPoin, ONE_INTEGER);\n        inference_modules.inference_removal_module($REMOVAL_SLOPE_OF_REGRESSION_LINE_FOR_SET_OF_POINTS, $list27);\n        inference_modules.register_solely_specific_removal_module_predicate($const28$setOfFirstDerivativePointsBasedOn);\n        preference_modules.doomed_unless_arg_bindable($POS, $const28$setOfFirstDerivativePointsBasedOn, ONE_INTEGER);\n        preference_modules.doomed_unless_arg_bindable($POS, $const28$setOfFirstDerivativePointsBasedOn, TWO_INTEGER);\n        inference_modules.inference_removal_module($REMOVAL_SET_OF_FIRST_DERIVATIVE_POINTS_BASED_ON_SET_OF_POINTS, $list30);\n        inference_modules.register_solely_specific_removal_module_predicate($const31$setHasPointsWithYValueRelnToMatch);\n        preference_modules.doomed_unless_arg_bindable($POS, $const31$setHasPointsWithYValueRelnToMatch, ONE_INTEGER);\n        preference_modules.doomed_unless_arg_bindable($POS, $const31$setHasPointsWithYValueRelnToMatch, TWO_INTEGER);\n        preference_modules.doomed_unless_arg_bindable($POS, $const31$setHasPointsWithYValueRelnToMatch, THREE_INTEGER);\n        preference_modules.doomed_unless_arg_bindable($POS, $const31$setHasPointsWithYValueRelnToMatch, FOUR_INTEGER);\n        preference_modules.doomed_unless_arg_bindable($POS, $const31$setHasPointsWithYValueRelnToMatch, FIVE_INTEGER);\n        inference_modules.inference_removal_module($kw32$REMOVAL_SET_HAS_POINTS_WITH_Y_VALUE_RELN_TO_MATCHING_X_VALUE_POIN, $list33);\n        inference_modules.register_solely_specific_removal_module_predicate($$setHasPointsWithYValueRelnTo);\n        preference_modules.doomed_unless_arg_bindable($POS, $$setHasPointsWithYValueRelnTo, ONE_INTEGER);\n        preference_modules.doomed_unless_arg_bindable($POS, $$setHasPointsWithYValueRelnTo, TWO_INTEGER);\n        preference_modules.doomed_unless_arg_bindable($POS, $$setHasPointsWithYValueRelnTo, THREE_INTEGER);\n        preference_modules.doomed_unless_arg_bindable($POS, $$setHasPointsWithYValueRelnTo, FOUR_INTEGER);\n        preference_modules.doomed_unless_arg_bindable($POS, $$setHasPointsWithYValueRelnTo, FIVE_INTEGER);\n        inference_modules.inference_removal_module($REMOVAL_SET_HAS_POINTS_WITH_Y_VALUE_RELN_TO, $list64);\n        inference_modules.register_solely_specific_removal_module_predicate($$operationResultComparison);\n        preference_modules.doomed_unless_all_args_bindable($POS, $$operationResultComparison);\n        preference_modules.doomed_unless_all_args_bindable($NEG, $$operationResultComparison);\n        inference_modules.inference_removal_module($REMOVAL_OPERATION_RESULT_COMPARISON_POS_CHECK, $list68);\n        inference_modules.inference_removal_module($REMOVAL_OPERATION_RESULT_COMPARISON_NEG_CHECK, $list70);\n        inference_modules.register_solely_specific_removal_module_predicate($$inflowLengthsWithStartingDepths);\n        preference_modules.doomed_unless_arg_bindable($POS, $$inflowLengthsWithStartingDepths, ONE_INTEGER);\n        preference_modules.doomed_unless_arg_bindable($POS, $$inflowLengthsWithStartingDepths, TWO_INTEGER);\n        inference_modules.inference_removal_module($REMOVAL_INFLOW_LENGTHS_WITH_STARTING_DEPTHS, $list73);\n        return NIL;\n    }\n\n    @Override\n    public void declareFunctions() {\n        declare_removal_modules_math_file();\n    }\n\n    @Override\n    public void initializeVariables() {\n        init_removal_modules_math_file();\n    }\n\n    @Override\n    public void runTopLevelForms() {\n        setup_removal_modules_math_file();\n    }\n\n    static {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    }\n}", "class_id": 0, "repo": "TeamSPoon/CYC_JRTL_with_CommonLisp_OLD", "file": "platform/main/server-4u/com/cyc/cycjava/cycl/inference/modules/removal/removal_modules_math.java", "last_update_at": "2020-01-17T16:29:19+00:00", "question_id": "f402f49e782ddcd0e031b882aeb7f1c9aa6a177a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class removal_modules_math extends SubLTranslatedFile implements V10 {\n    public static final SubLFile me = new removal_modules_math();\n    public static final String myName = \"com.cyc.cycjava_2.cycl.inference.modules.removal.removal_modules_math\";\n    // defparameter\n    public static final SubLSymbol $default_math_module_cost$ = makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\");\n    private static final SubLObject $$interpolationWithCubicSpline = reader_make_constant_shell(makeString(\"interpolationWithCubicSpline\"));\n    private static final SubLSymbol $REMOVAL_INTERPOLATION_WITH_CUBIC_SPLINE = makeKeyword(\"REMOVAL-INTERPOLATION-WITH-CUBIC-SPLINE\");\n    private static final SubLList $list3 = list(new SubLObject[]{ makeKeyword(\"SENSE\"), makeKeyword(\"POS\"), makeKeyword(\"PREDICATE\"), reader_make_constant_shell(makeString(\"interpolationWithCubicSpline\")), makeKeyword(\"REQUIRED-PATTERN\"), list(reader_make_constant_shell(makeString(\"interpolationWithCubicSpline\")), makeKeyword(\"FULLY-BOUND\"), list(makeKeyword(\"OR\"), list(reader_make_constant_shell(makeString(\"The2DPoint\")), makeKeyword(\"NOT-FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\")), list(reader_make_constant_shell(makeString(\"The2DPoint\")), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"NOT-FULLY-BOUND\")))), makeKeyword(\"COST-EXPRESSION\"), makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\"), makeKeyword(\"COMPLETENESS\"), makeKeyword(\"COMPLETE\"), makeKeyword(\"EXPAND\"), makeSymbol(\"REMOVAL-INTERPOLATION-WITH-CUBIC-SPLINE-EXPAND\"), makeKeyword(\"DOCUMENTATION\"), makeString(\"(#$interpolationWithCubicSpline <set-of-points> <2d-point-with-x-or-y-bound>)\"), makeKeyword(\"EXAMPLE\"), makeString(\"(#$interpolationWithCubicSpline \\n    (#$TheSet \\n     (#$The2DPoint \\n      (#$Meter 440.1) \\n      (#$DegreeCelsius 160.3)) \\n     (#$The2DPoint \\n      (#$Meter 441.1) \\n      (#$DegreeCelsius 161.4)) \\n     (#$The2DPoint \\n      (#$Meter 442.3) \\n      (#$DegreeCelsius 163.6)) \\n     (#$The2DPoint \\n      (#$Meter 443.6) \\n      (#$DegreeCelsius 165.5)) \\n     (#$The2DPoint \\n      (#$Meter 444.9) \\n      (#$DegreeCelsius 166.4)) \\n     (#$The2DPoint \\n      (#$Meter 445.8) \\n      (#$DegreeCelsius 166.3)) \\n     (#$The2DPoint \\n      (#$Meter 446.7) \\n      (#$DegreeCelsius 165.4)) \\n     (#$The2DPoint \\n      (#$Meter 447.9) \\n      (#$DegreeCelsius 167.8))) \\n    (#$The2DPoint \\n     (#$Meter 445.0) \\n     (#$DegreeCelsius ?VALUE)))\") });\n    private static final SubLSymbol JAVA_LINK_X_Y_CUBIC_SPLINE_FIND_Y_FOR_X = makeSymbol(\"JAVA-LINK-X-Y-CUBIC-SPLINE-FIND-Y-FOR-X\");\n    private static final SubLObject $const5$interpolationWithPiecewiseLinearP = reader_make_constant_shell(makeString(\"interpolationWithPiecewiseLinearPolynomial\"));\n    private static final SubLSymbol $REMOVAL_INTERPOLATION_WITH_PIECEWISE_LINEAR_POLYNOMIAL = makeKeyword(\"REMOVAL-INTERPOLATION-WITH-PIECEWISE-LINEAR-POLYNOMIAL\");\n    private static final SubLList $list7 = list(new SubLObject[]{ makeKeyword(\"SENSE\"), makeKeyword(\"POS\"), makeKeyword(\"PREDICATE\"), reader_make_constant_shell(makeString(\"interpolationWithPiecewiseLinearPolynomial\")), makeKeyword(\"REQUIRED-PATTERN\"), list(reader_make_constant_shell(makeString(\"interpolationWithPiecewiseLinearPolynomial\")), makeKeyword(\"FULLY-BOUND\"), list(makeKeyword(\"OR\"), list(reader_make_constant_shell(makeString(\"The2DPoint\")), makeKeyword(\"NOT-FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\")), list(reader_make_constant_shell(makeString(\"The2DPoint\")), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"NOT-FULLY-BOUND\")))), makeKeyword(\"COST-EXPRESSION\"), makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\"), makeKeyword(\"COMPLETENESS\"), makeKeyword(\"COMPLETE\"), makeKeyword(\"EXPAND\"), makeSymbol(\"REMOVAL-INTERPOLATION-WITH-PIECEWISE-LINEAR-POLYNOMIAL-EXPAND\"), makeKeyword(\"DOCUMENTATION\"), makeString(\"(#$interpolationWithPiecewiseLinearPolynomial <set-of-points> <2d-point-with-x-or-y-bound>)\"), makeKeyword(\"EXAMPLE\"), makeString(\"(#$interpolationWithPiecewiseLinearPolynomial \\n    (#$TheSet \\n     (#$The2DPoint \\n      (#$Meter 440.1) \\n      (#$DegreeCelsius 160.3)) \\n     (#$The2DPoint \\n      (#$Meter 441.1) \\n      (#$DegreeCelsius 161.4)) \\n     (#$The2DPoint \\n      (#$Meter 442.3) \\n      (#$DegreeCelsius 163.6)) \\n     (#$The2DPoint \\n      (#$Meter 443.6) \\n      (#$DegreeCelsius 165.5)) \\n     (#$The2DPoint \\n      (#$Meter 444.9) \\n      (#$DegreeCelsius 166.4)) \\n     (#$The2DPoint \\n      (#$Meter 445.8) \\n      (#$DegreeCelsius 166.3)) \\n     (#$The2DPoint \\n      (#$Meter 446.7) \\n      (#$DegreeCelsius 165.4)) \\n     (#$The2DPoint \\n      (#$Meter 447.9) \\n      (#$DegreeCelsius 167.8))) \\n    (#$The2DPoint \\n     (#$Meter 445.0) \\n     (#$DegreeCelsius ?VALUE)))\") });\n    private static final SubLSymbol JAVA_LINK_X_Y_PIECEWISE_LINEAR_FIND_Y_FOR_X = makeSymbol(\"JAVA-LINK-X-Y-PIECEWISE-LINEAR-FIND-Y-FOR-X\");\n    private static final SubLObject $const9$extrapolationWithSimpleLinearRegr = reader_make_constant_shell(makeString(\"extrapolationWithSimpleLinearRegression\"));\n    private static final SubLSymbol $REMOVAL_EXTRAPOLATION_WITH_SIMPLE_LINEAR_REGRESSION = makeKeyword(\"REMOVAL-EXTRAPOLATION-WITH-SIMPLE-LINEAR-REGRESSION\");\n    private static final SubLList $list11 = list(new SubLObject[]{ makeKeyword(\"SENSE\"), makeKeyword(\"POS\"), makeKeyword(\"PREDICATE\"), reader_make_constant_shell(makeString(\"extrapolationWithSimpleLinearRegression\")), makeKeyword(\"REQUIRED-PATTERN\"), list(reader_make_constant_shell(makeString(\"extrapolationWithSimpleLinearRegression\")), makeKeyword(\"FULLY-BOUND\"), list(makeKeyword(\"OR\"), list(reader_make_constant_shell(makeString(\"The2DPoint\")), makeKeyword(\"NOT-FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\")), list(reader_make_constant_shell(makeString(\"The2DPoint\")), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"NOT-FULLY-BOUND\")))), makeKeyword(\"COST-EXPRESSION\"), makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\"), makeKeyword(\"COMPLETENESS\"), makeKeyword(\"COMPLETE\"), makeKeyword(\"EXPAND\"), makeSymbol(\"REMOVAL-EXTRAPOLATION-WITH-SIMPLE-LINEAR-REGRESSION-EXPAND\"), makeKeyword(\"DOCUMENTATION\"), makeString(\"(#$extrapolationWithSimpleLinearRegression <set-of-points> <2d-point-with-x-or-y-bound>)\"), makeKeyword(\"EXAMPLE\"), makeString(\"(#$extrapolationWithSimpleLinearRegression \\n    (#$TheSet \\n     (#$The2DPoint \\n      (#$DaysDuration 1) \\n      (#$DegreeCelsius 160.3)) \\n     (#$The2DPoint \\n      (#$DaysDuration 2) \\n      (#$DegreeCelsius 161.4)) \\n     (#$The2DPoint \\n      (#$DaysDuration 3) \\n      (#$DegreeCelsius 163.6)) \\n     (#$The2DPoint \\n      (#$DaysDuration 4) \\n      (#$DegreeCelsius 165.5)) \\n     (#$The2DPoint \\n      (#$DaysDuration 5) \\n      (#$DegreeCelsius 166.4)) \\n     (#$The2DPoint \\n      (#$DaysDuration 6) \\n      (#$DegreeCelsius 166.3)) \\n     (#$The2DPoint \\n      (#$DaysDuration 7) \\n      (#$DegreeCelsius 165.4)) \\n     (#$The2DPoint \\n      (#$DaysDuration 8) \\n      (#$DegreeCelsius 167.8))) \\n    (#$The2DPoint \\n     (#$DaysDuration ?VALUE) \\n     (#$DegreeCelsius 200)))\") });\n    private static final SubLSymbol JAVA_LINK_X_Y_REGRESSION_FIND_Y_FOR_X = makeSymbol(\"JAVA-LINK-X-Y-REGRESSION-FIND-Y-FOR-X\");\n    private static final SubLSymbol EL_2D_POINT_P = makeSymbol(\"EL-2D-POINT-P\");\n    private static final SubLList $list14 = list(makeSymbol(\"THE-2D-POINT\"), makeSymbol(\"QUERY-X-VALUE-WITH-UNITS\"), makeSymbol(\"QUERY-Y-VALUE-WITH-UNITS\"));\n    private static final SubLObject $const17$extrapolationWithSimpleLinearRegr = reader_make_constant_shell(makeString(\"extrapolationWithSimpleLinearRegressionWithErrorBars\"));\n    private static final SubLSymbol $kw18$REMOVAL_EXTRAPOLATION_WITH_SIMPLE_LINEAR_REGRESSION_WITH_ERROR_BA = makeKeyword(\"REMOVAL-EXTRAPOLATION-WITH-SIMPLE-LINEAR-REGRESSION-WITH-ERROR-BARS\");\n    private static final SubLList $list19 = list(new SubLObject[]{ makeKeyword(\"SENSE\"), makeKeyword(\"POS\"), makeKeyword(\"PREDICATE\"), reader_make_constant_shell(makeString(\"extrapolationWithSimpleLinearRegressionWithErrorBars\")), makeKeyword(\"REQUIRED-PATTERN\"), list(reader_make_constant_shell(makeString(\"extrapolationWithSimpleLinearRegressionWithErrorBars\")), makeKeyword(\"FULLY-BOUND\"), list(makeKeyword(\"OR\"), list(reader_make_constant_shell(makeString(\"The2DPoint\")), makeKeyword(\"NOT-FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\")), list(reader_make_constant_shell(makeString(\"The2DPoint\")), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"NOT-FULLY-BOUND\"))), makeKeyword(\"NOT-FULLY-BOUND\")), makeKeyword(\"COST-EXPRESSION\"), makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\"), makeKeyword(\"COMPLETENESS\"), makeKeyword(\"COMPLETE\"), makeKeyword(\"EXPAND\"), makeSymbol(\"REMOVAL-EXTRAPOLATION-WITH-SIMPLE-LINEAR-REGRESSION-WITH-ERROR-BARS-EXPAND\"), makeKeyword(\"DOCUMENTATION\"), makeString(\"(#$extrapolationWithSimpleLinearRegressionWithErrorBars <set-of-points> <2d-point-with-x-or-y-bound> <error-term-unbound>)\"), makeKeyword(\"EXAMPLE\"), makeString(\"(#$extrapolationWithSimpleLinearRegressionWithErrorBars\\n    (#$TheSet \\n     (#$The2DPoint \\n      (#$DaysDuration 1) \\n      (#$DegreeCelsius 160.3)) \\n     (#$The2DPoint \\n      (#$DaysDuration 2) \\n      (#$DegreeCelsius 161.4)) \\n     (#$The2DPoint \\n      (#$DaysDuration 3) \\n      (#$DegreeCelsius 163.6)) \\n     (#$The2DPoint \\n      (#$DaysDuration 4) \\n      (#$DegreeCelsius 165.5)) \\n     (#$The2DPoint \\n      (#$DaysDuration 5) \\n      (#$DegreeCelsius 166.4)) \\n     (#$The2DPoint \\n      (#$DaysDuration 6) \\n      (#$DegreeCelsius 166.3)) \\n     (#$The2DPoint \\n      (#$DaysDuration 7) \\n      (#$DegreeCelsius 165.4)) \\n     (#$The2DPoint \\n      (#$DaysDuration 8) \\n      (#$DegreeCelsius 167.8))) \\n    (#$The2DPoint \\n     (#$DaysDuration ?VALUE) \\n     (#$DegreeCelsius 200))\\n    ?ERROR)\") });\n    private static final SubLSymbol JAVA_LINK_X_Y_REGRESSION_FIND_Y_FOR_X_WITH_ERROR_BARS = makeSymbol(\"JAVA-LINK-X-Y-REGRESSION-FIND-Y-FOR-X-WITH-ERROR-BARS\");\n    private static final SubLObject $const21$regressionLinesForSetsIntersectAt = reader_make_constant_shell(makeString(\"regressionLinesForSetsIntersectAtPoint\"));\n    private static final SubLSymbol $REMOVAL_REGRESSION_LINES_FOR_SETS_INTERSECT_AT_POINT = makeKeyword(\"REMOVAL-REGRESSION-LINES-FOR-SETS-INTERSECT-AT-POINT\");\n    private static final SubLList $list23 = list(new SubLObject[]{ makeKeyword(\"SENSE\"), makeKeyword(\"POS\"), makeKeyword(\"PREDICATE\"), reader_make_constant_shell(makeString(\"regressionLinesForSetsIntersectAtPoint\")), makeKeyword(\"REQUIRED-PATTERN\"), list(reader_make_constant_shell(makeString(\"regressionLinesForSetsIntersectAtPoint\")), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"NOT-FULLY-BOUND\")), makeKeyword(\"COST-EXPRESSION\"), makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\"), makeKeyword(\"COMPLETENESS\"), makeKeyword(\"COMPLETE\"), makeKeyword(\"EXPAND\"), makeSymbol(\"REMOVAL-REGRESSION-LINES-FOR-SETS-INTERSECT-AT-POINT-EXPAND\"), makeKeyword(\"DOCUMENTATION\"), makeString(\"(#$regressionLinesForSetsIntersectAtPoint <set-of-points> <set-of-points> ?POINT)\"), makeKeyword(\"EXAMPLE\"), makeString(\"(#$regressionLinesForSetsIntersectAtPoint\\n     (#$TheSet\\n      (#$The2DPoint\\n       (#$DegreeCelsius 200)\\n       (#$SecondsDuration 1263118210))\\n      (#$The2DPoint\\n       (#$DegreeCelsius 210)\\n       (#$SecondsDuration 1263204610))\\n      (#$The2DPoint\\n       (#$DegreeCelsius 220)\\n       (#$SecondsDuration 1263291010)))\\n     (TheSet\\n      (#$The2DPoint\\n       (#$DegreeCelsius 211)\\n       (#$SecondsDuration 1263081600))\\n      (#$The2DPoint\\n       (#$DegreeCelsius 212)\\n       (#$SecondsDuration 1263168000))\\n      (#$The2DPoint\\n       (#$DegreeCelsius 213)\\n       (#$SecondsDuration 1263254400)))\\n     ?POINT)\") });\n    private static final SubLObject $$The2DPoint = reader_make_constant_shell(makeString(\"The2DPoint\"));\n    private static final SubLObject $const25$slopeOfRegressionLineForSetOfPoin = reader_make_constant_shell(makeString(\"slopeOfRegressionLineForSetOfPoints\"));\n    private static final SubLSymbol $REMOVAL_SLOPE_OF_REGRESSION_LINE_FOR_SET_OF_POINTS = makeKeyword(\"REMOVAL-SLOPE-OF-REGRESSION-LINE-FOR-SET-OF-POINTS\");\n    private static final SubLList $list27 = list(new SubLObject[]{ makeKeyword(\"SENSE\"), makeKeyword(\"POS\"), makeKeyword(\"PREDICATE\"), reader_make_constant_shell(makeString(\"slopeOfRegressionLineForSetOfPoints\")), makeKeyword(\"REQUIRED-PATTERN\"), list(reader_make_constant_shell(makeString(\"slopeOfRegressionLineForSetOfPoints\")), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"NOT-FULLY-BOUND\")), makeKeyword(\"COST-EXPRESSION\"), makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\"), makeKeyword(\"COMPLETENESS\"), makeKeyword(\"COMPLETE\"), makeKeyword(\"EXPAND\"), makeSymbol(\"REMOVAL-SLOPE-OF-REGRESSION-LINE-FOR-SET-OF-POINTS-EXPAND\"), makeKeyword(\"DOCUMENTATION\"), makeString(\"(#$slopeOfRegressionLineForSetOfPoints <set-of-points> ?SLOPE)\"), makeKeyword(\"EXAMPLE\"), makeString(\"(#$slopeOfRegressionLineForSetOfPoints\\n     (#$TheSet\\n      (#$The2DPoint\\n       (#$DegreeCelsius 211)\\n       (#$SecondsDuration 1263081600))\\n      (#$The2DPoint\\n       (#$DegreeCelsius 212)\\n       (#$SecondsDuration 1263168000))\\n      (#$The2DPoint\\n       (#$DegreeCelsius 213)\\n       (#$SecondsDuration 1263254400))) ?X)\") });\n    private static final SubLObject $const28$setOfFirstDerivativePointsBasedOn = reader_make_constant_shell(makeString(\"setOfFirstDerivativePointsBasedOnSetOfPoints\"));\n    private static final SubLSymbol $REMOVAL_SET_OF_FIRST_DERIVATIVE_POINTS_BASED_ON_SET_OF_POINTS = makeKeyword(\"REMOVAL-SET-OF-FIRST-DERIVATIVE-POINTS-BASED-ON-SET-OF-POINTS\");\n    private static final SubLList $list30 = list(new SubLObject[]{ makeKeyword(\"SENSE\"), makeKeyword(\"POS\"), makeKeyword(\"PREDICATE\"), reader_make_constant_shell(makeString(\"setOfFirstDerivativePointsBasedOnSetOfPoints\")), makeKeyword(\"REQUIRED-PATTERN\"), list(reader_make_constant_shell(makeString(\"setOfFirstDerivativePointsBasedOnSetOfPoints\")), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"NOT-FULLY-BOUND\")), makeKeyword(\"COST-EXPRESSION\"), makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\"), makeKeyword(\"COMPLETENESS\"), makeKeyword(\"COMPLETE\"), makeKeyword(\"EXPAND\"), makeSymbol(\"REMOVAL-SET-OF-FIRST-DERIVATIVE-POINTS-BASED-ON-SET-OF-POINTS-EXPAND\"), makeKeyword(\"DOCUMENTATION\"), makeString(\"(#$setOfFirstDerivativePointsBasedOnSetOfPoints <set-of-points> ?SET-OF-POINTS)\"), makeKeyword(\"EXAMPLE\"), makeString(\"(#$setOfFirstDerivativePointsBasedOnSetOfPoints\\n    (#$TheSet\\n     (#$The2DPoint (#$SecondsDuration 1) (#$DegreeCelsius 1))\\n     (#$The2DPoint (#$SecondsDuration 3) (#$DegreeCelsius 5))\\n     (#$The2DPoint (#$SecondsDuration 5) (#$DegreeCelsius 1)))\\n    #$CubicSpline\\n    ?X)\\n    -->\\n    (#$TheSet \\n     (#$The2DPoint (#$SecondsDuration 1) ((#$PerFn #$DegreeCelsius #$SecondsDuration) 6.0))\\n     (#$The2DPoint (#$SecondsDuration 3) ((#$PerFn #$DegreeCelsius #$SecondsDuration) 0.0))\\n     (#$The2DPoint (#$SecondsDuration 5) ((#$PerFn #$DegreeCelsius #$SecondsDuration) -6.0)))\") });\n    private static final SubLObject $const31$setHasPointsWithYValueRelnToMatch = reader_make_constant_shell(makeString(\"setHasPointsWithYValueRelnToMatchingXValuePointsInSet\"));\n    private static final SubLSymbol $kw32$REMOVAL_SET_HAS_POINTS_WITH_Y_VALUE_RELN_TO_MATCHING_X_VALUE_POIN = makeKeyword(\"REMOVAL-SET-HAS-POINTS-WITH-Y-VALUE-RELN-TO-MATCHING-X-VALUE-POINTS-IN-SET\");\n    private static final SubLList $list33 = list(new SubLObject[]{ makeKeyword(\"SENSE\"), makeKeyword(\"POS\"), makeKeyword(\"PREDICATE\"), reader_make_constant_shell(makeString(\"setHasPointsWithYValueRelnToMatchingXValuePointsInSet\")), makeKeyword(\"REQUIRED-PATTERN\"), list(reader_make_constant_shell(makeString(\"setHasPointsWithYValueRelnToMatchingXValuePointsInSet\")), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"NOT-FULLY-BOUND\")), makeKeyword(\"COST-EXPRESSION\"), makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\"), makeKeyword(\"COMPLETENESS\"), makeKeyword(\"COMPLETE\"), makeKeyword(\"EXPAND\"), makeSymbol(\"REMOVAL-SET-HAS-POINTS-WITH-Y-VALUE-RELN-TO-MATCHING-X-VALUE-POINTS-IN-SET-EXPAND\"), makeKeyword(\"DOCUMENTATION\"), makeString(\"(#$setHasPointsWithYValueRelnToMatchingXValuePointsInSet <set-of-points> <set-of-points> <binary-function> <binary-predicate> <value-in-y-units> ?RESULT-SET-OF-POINTS)\"), makeKeyword(\"EXAMPLE\"), makeString(\"(#$setHasPointsWithYValueRelnToMatchingXValuePointsInSet \\n    (#$TheSet \\n      (#$The2DPoint (#$Meter 702) (#$Kelvin 177.5)) \\n      (#$The2DPoint (#$Meter 703) (#$Kelvin 177.5)) \\n      (#$The2DPoint (#$Meter 704) (#$Kelvin 177.5)) \\n      (#$The2DPoint (#$Meter 705) (#$Kelvin 170))) \\n    (#$TheSet \\n      (#$The2DPoint (#$Meter 702) (#$Kelvin 175)) \\n      (#$The2DPoint (#$Meter 703) (#$Kelvin 175)) \\n      (#$The2DPoint (#$Meter 704) (#$Kelvin 175)) \\n      (#$The2DPoint (#$Meter 705) (#$Kelvin 170)))\\n    #$DifferenceFn\\n    #$greaterThanOrEqualTo \\n    (#$Kelvin 2)\\n    ?NEWSET)\\n    -->\\n    (((?NEWSET #$TheSet (#$The2DPoint (#$Meter 702) (#$Kelvin 177.5)) \\n                        (#$The2DPoint (#$Meter 703) (#$Kelvin 177.5)) \\n                        (#$The2DPoint (#$Meter 704) (#$Kelvin 177.5)))))\") });\n    private static final SubLString $str35$org_apache_commons_math_stat_regr = makeString(\"org.apache.commons.math.stat.regression.SimpleRegression\");\n    private static final SubLString $$$addData = makeString(\"addData\");\n    private static final SubLString $$$double = makeString(\"double\");\n    private static final SubLString $$$getSlope = makeString(\"getSlope\");\n    private static final SubLString $$$getIntercept = makeString(\"getIntercept\");\n    private static final SubLString $str42$org_apache_commons_math_analysis_ = makeString(\"org.apache.commons.math.analysis.interpolation.SplineInterpolator\");\n    private static final SubLString $$$interpolate = makeString(\"interpolate\");\n    private static final SubLString $str44$_D = makeString(\"[D\");\n    private static final SubLString $str45$org_apache_commons_math_analysis_ = makeString(\"org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction\");\n    private static final SubLString $$$value = makeString(\"value\");\n    private static final SubLSymbol $sym47$_ = makeSymbol(\"<\");\n    private static final SubLString $str49$org_apache_commons_math_analysis_ = makeString(\"org.apache.commons.math.analysis.interpolation.LinearInterpolator\");\n    private static final SubLString $$$predict = makeString(\"predict\");\n    private static final SubLString $$$getSumSquaredErrors = makeString(\"getSumSquaredErrors\");\n    private static final SubLString $str52$org_apache_commons_math_geometry_ = makeString(\"org.apache.commons.math.geometry.euclidean.twod.Line\");\n    private static final SubLString $str53$org_apache_commons_math_geometry_ = makeString(\"org.apache.commons.math.geometry.euclidean.twod.Vector2D\");\n    private static final SubLString $$$intersection = makeString(\"intersection\");\n    private static final SubLString $str55$org_apache_commons_math_geometry_ = makeString(\"org.apache.commons.math.geometry.partitioning.Hyperplane\");\n    private static final SubLString $$$getX = makeString(\"getX\");\n    private static final SubLString $$$getY = makeString(\"getY\");\n    private static final SubLObject $$CubicSpline = reader_make_constant_shell(makeString(\"CubicSpline\"));\n    private static final SubLObject $const59$LinearPolynomialFunction_Piecewis = reader_make_constant_shell(makeString(\"LinearPolynomialFunction-Piecewise\"));\n    private static final SubLString $$$derivative = makeString(\"derivative\");\n    private static final SubLObject $$setHasPointsWithYValueRelnTo = reader_make_constant_shell(makeString(\"setHasPointsWithYValueRelnTo\"));\n    private static final SubLSymbol $REMOVAL_SET_HAS_POINTS_WITH_Y_VALUE_RELN_TO = makeKeyword(\"REMOVAL-SET-HAS-POINTS-WITH-Y-VALUE-RELN-TO\");\n    private static final SubLList $list64 = list(new SubLObject[]{ makeKeyword(\"SENSE\"), makeKeyword(\"POS\"), makeKeyword(\"PREDICATE\"), reader_make_constant_shell(makeString(\"setHasPointsWithYValueRelnTo\")), makeKeyword(\"REQUIRED-PATTERN\"), list(reader_make_constant_shell(makeString(\"setHasPointsWithYValueRelnTo\")), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"NOT-FULLY-BOUND\")), makeKeyword(\"COST-EXPRESSION\"), makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\"), makeKeyword(\"COMPLETENESS\"), makeKeyword(\"COMPLETE\"), makeKeyword(\"EXPAND\"), makeSymbol(\"REMOVAL-SET-HAS-POINTS-WITH-Y-VALUE-RELN-TO-EXPAND\"), makeKeyword(\"DOCUMENTATION\"), makeString(\"(#$setHasPointsWithYValueRelnTo <set-of-points> <operator> <comparator> <quant1> <quant2> ?NEWSET)\"), makeKeyword(\"EXAMPLE\"), makeString(\"(#$setHasPointsWithYValueRelnTo \\n (#$TheSet \\n  (#$The2DPoint \\n   (#$Meter 20.0) \\n   (#$DegreeCelsius 68.35)) \\n  (#$The2DPoint \\n   (#$Meter 21.0) \\n   (#$DegreeCelsius 72.98)) \\n  (#$The2DPoint \\n   (#$Meter 22.0) \\n   (#$DegreeCelsius 75.68)) \\n  (#$The2DPoint \\n   (#$Meter 23.0) \\n   (#$DegreeCelsius 78.16)) \\n  (#$The2DPoint \\n   (#$Meter 24.0) \\n   (#$DegreeCelsius 80.79)))\\n #$PlusFn\\n #$lessThanOrEqualTo \\n (#$DegreeCelsius 0) \\n (#$DegreeCelsius 70) ?NEWSET)\\n -->\\n (((?NEWSET TheSet\\n   (The2DPoint\\n       (Meter 20.0)\\n       (DegreeCelsius 68.35)))))\") });\n    private static final SubLObject $$operationResultComparison = reader_make_constant_shell(makeString(\"operationResultComparison\"));\n    private static final SubLSymbol $REMOVAL_OPERATION_RESULT_COMPARISON_POS_CHECK = makeKeyword(\"REMOVAL-OPERATION-RESULT-COMPARISON-POS-CHECK\");\n    private static final SubLList $list68 = list(new SubLObject[]{ makeKeyword(\"SENSE\"), makeKeyword(\"POS\"), makeKeyword(\"PREDICATE\"), reader_make_constant_shell(makeString(\"operationResultComparison\")), makeKeyword(\"REQUIRED-PATTERN\"), list(reader_make_constant_shell(makeString(\"operationResultComparison\")), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\")), makeKeyword(\"COST-EXPRESSION\"), makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\"), makeKeyword(\"COMPLETENESS\"), makeKeyword(\"COMPLETE\"), makeKeyword(\"EXPAND\"), makeSymbol(\"REMOVAL-OPERATION-RESULT-COMPARISON-POS-CHECK\"), makeKeyword(\"DOCUMENTATION\"), makeString(\"(#$operationResultComparison <OP> <A> <B> <COMP> <QUANT>)\"), makeKeyword(\"EXAMPLE\"), makeString(\"(#$operationResultComparison #$PlusFn (#$DegreeCelsius 50) (#$DegreeCelsius 0) #$lessThanOrEqualTo (#$DegreeCelsius 70))\\n   --> True\") });\n    private static final SubLSymbol $REMOVAL_OPERATION_RESULT_COMPARISON_NEG_CHECK = makeKeyword(\"REMOVAL-OPERATION-RESULT-COMPARISON-NEG-CHECK\");\n    private static final SubLList $list70 = list(new SubLObject[]{ makeKeyword(\"SENSE\"), makeKeyword(\"NEG\"), makeKeyword(\"PREDICATE\"), reader_make_constant_shell(makeString(\"operationResultComparison\")), makeKeyword(\"REQUIRED-PATTERN\"), list(reader_make_constant_shell(makeString(\"operationResultComparison\")), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\")), makeKeyword(\"COST-EXPRESSION\"), makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\"), makeKeyword(\"COMPLETENESS\"), makeKeyword(\"COMPLETE\"), makeKeyword(\"EXPAND\"), makeSymbol(\"REMOVAL-OPERATION-RESULT-COMPARISON-NEG-CHECK\"), makeKeyword(\"DOCUMENTATION\"), makeString(\"(#$operationResultComparison <OP> <A> <B> <COMP> <QUANT>)\"), makeKeyword(\"EXAMPLE\"), makeString(\"(#$not (#$operationResultComparison #$PlusFn (#$DegreeCelsius 100) (#$DegreeCelsius 0) #$lessThanOrEqualTo (#$DegreeCelsius 70))\\n   --> True\") });\n    private static final SubLObject $$inflowLengthsWithStartingDepths = reader_make_constant_shell(makeString(\"inflowLengthsWithStartingDepths\"));\n    private static final SubLSymbol $REMOVAL_INFLOW_LENGTHS_WITH_STARTING_DEPTHS = makeKeyword(\"REMOVAL-INFLOW-LENGTHS-WITH-STARTING-DEPTHS\");\n    private static final SubLList $list73 = list(new SubLObject[]{ makeKeyword(\"SENSE\"), makeKeyword(\"POS\"), makeKeyword(\"PREDICATE\"), reader_make_constant_shell(makeString(\"inflowLengthsWithStartingDepths\")), makeKeyword(\"REQUIRED-PATTERN\"), list(reader_make_constant_shell(makeString(\"inflowLengthsWithStartingDepths\")), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"FULLY-BOUND\"), makeKeyword(\"NOT-FULLY-BOUND\")), makeKeyword(\"COST-EXPRESSION\"), makeSymbol(\"*DEFAULT-MATH-MODULE-COST*\"), makeKeyword(\"COMPLETENESS\"), makeKeyword(\"COMPLETE\"), makeKeyword(\"EXPAND\"), makeSymbol(\"REMOVAL-INFLOW-LENGTHS-WITH-STARTING-DEPTHS-EXPAND\"), makeKeyword(\"DOCUMENTATION\"), makeString(\"(#$inflowLengthsWithStartingDepths <well> <set-of-points> ?LENGTH-AND-DEPTHS)\"), makeKeyword(\"EXAMPLE\"), makeString(\"(#$inflowLengthsWithStartingDepths\\n  (#$The #$Well)\\n  (#$TheSet \\n   (#$The2DPoint (#$Meter 100) (#$DegreeCelsius  95))\\n   (#$The2DPoint (#$Meter 110) (#$DegreeCelsius 110))\\n   (#$The2DPoint (#$Meter 120) (#$DegreeCelsius 115))\\n   (#$The2DPoint (#$Meter 130) (#$DegreeCelsius 114))\\n   (#$The2DPoint (#$Meter 140) (#$DegreeCelsius 103))\\n   (#$The2DPoint (#$Meter 150) (#$DegreeCelsius  95))\\n   (#$The2DPoint (#$Meter 160) (#$DegreeCelsius 100))\\n   (#$The2DPoint (#$Meter 170) (#$DegreeCelsius 102))\\n   (#$The2DPoint (#$Meter 180) (#$DegreeCelsius 102))\\n   (#$The2DPoint (#$Meter 190) (#$DegreeCelsius  91))\\n   (#$The2DPoint (#$Meter 200) (#$DegreeCelsius 100))\\n   (#$The2DPoint (#$Meter 210) (#$DegreeCelsius 110))\\n   (#$The2DPoint (#$Meter 220) (#$DegreeCelsius 105))\\n   (#$The2DPoint (#$Meter 230) (#$DegreeCelsius  97))\\n   (#$The2DPoint (#$Meter 240) (#$DegreeCelsius  96))\\n   (#$The2DPoint (#$Meter 250) (#$DegreeCelsius  95))\\n   (#$The2DPoint (#$Meter 260) (#$DegreeCelsius  94))\\n   (#$The2DPoint (#$Meter 270) (#$DegreeCelsius  93))\\n   (#$The2DPoint (#$Meter 280) (#$DegreeCelsius  92)))\\n  ?LENGTH-AND-DEPTHS)\") });\n    private static final SubLObject $$Meter = reader_make_constant_shell(makeString(\"Meter\"));\n    private static final SubLObject $$DegreeCelsius = reader_make_constant_shell(makeString(\"DegreeCelsius\"));\n    private static final SubLString $str76$____ = makeString(\"~%~%\");\n    private static final SubLList $list77 = list(makeSymbol(\"X-VALUE\"), makeSymbol(\"Y-VALUE\"));\n    private static final SubLString $str78$High_value__x__A_y__A__ = makeString(\"High value: x=~A y=~A~%\");\n    private static final SubLList $list79 = list(makeSymbol(\"CUR-X-VALUE\"), makeSymbol(\"CUR-Y-DERIVATIVE-VALUE\"));\n    private static final SubLString $str80$checking_x__A_deriv__A__ = makeString(\"checking x=~A deriv=~A~%\");\n    private static final SubLString $$$Bad_looping = makeString(\"Bad looping\");\n    private static final SubLFloat $float$0_5 = makeDouble(0.5);\n    private static final SubLFloat $float$_0_5 = makeDouble(-0.5);\n    private static final SubLString $str84$Got_interval___A__A___ = makeString(\"Got interval (~A ~A)~%\");\n    private static final SubLSymbol $sym85$_ = makeSymbol(\">\");\n    private static final SubLString $str86$inflow_lengths___A__ = makeString(\"inflow-lengths: ~A~%\");\n    private static final SubLList $list87 = list(makeSymbol(\"START\"), makeSymbol(\"END\"));\n    private static final SubLString $str88$merged_inflow_lengths___A__ = makeString(\"merged-inflow-lengths: ~A~%\");\n    private static final SubLObject $$TheList = reader_make_constant_shell(makeString(\"TheList\"));\n    public static SubLObject removal_interpolation_with_cubic_spline_expand(final SubLObject asent, SubLObject sense) {\n        if (sense == UNPROVIDED) {\n            sense = NIL;\n        }\n        return removal_interpolation_or_extrapolation_with_java_link_function_expand_helper(asent, JAVA_LINK_X_Y_CUBIC_SPLINE_FIND_Y_FOR_X);\n    }\n    public static SubLObject removal_interpolation_with_piecewise_linear_polynomial_expand(final SubLObject asent, SubLObject sense) {\n        if (sense == UNPROVIDED) {\n            sense = NIL;\n        }\n        return removal_interpolation_or_extrapolation_with_java_link_function_expand_helper(asent, JAVA_LINK_X_Y_PIECEWISE_LINEAR_FIND_Y_FOR_X);\n    }\n    public static SubLObject removal_extrapolation_with_simple_linear_regression_expand(final SubLObject asent, SubLObject sense) {\n        if (sense == UNPROVIDED) {\n            sense = NIL;\n        }\n        return removal_interpolation_or_extrapolation_with_java_link_function_expand_helper(asent, JAVA_LINK_X_Y_REGRESSION_FIND_Y_FOR_X);\n    }\n    public static SubLObject removal_interpolation_or_extrapolation_with_java_link_function_expand_helper(final SubLObject asent, final SubLObject java_link_function) {\n        final SubLThread thread = SubLProcess.currentSubLThread();\n        final SubLObject set_of_points_in_units = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);\n        final SubLObject query_point = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);\n        if (NIL != el_extensional_set_p(set_of_points_in_units)) {\n            final SubLObject v_2d_points = extensional_set_elements(set_of_points_in_units);\n            if ((NIL != v_2d_points) && (NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points, UNPROVIDED))) {\n                thread.resetMultipleValues();\n                final SubLObject x_y_values = explode_2d_points_with_units(v_2d_points, UNPROVIDED, UNPROVIDED);\n                final SubLObject x_units = thread.secondMultipleValue();\n                final SubLObject y_units = thread.thirdMultipleValue();\n                thread.resetMultipleValues();\n                if (((NIL != x_y_values) && (NIL != x_units)) && (NIL != y_units)) {\n                    SubLObject current;\n                    final SubLObject datum = current = query_point;\n                    SubLObject the_2d_point = NIL;\n                    SubLObject query_x_value_with_units = NIL;\n                    SubLObject query_y_value_with_units = NIL;\n                    destructuring_bind_must_consp(current, datum, $list14);\n                    the_2d_point = current.first();\n                    current = current.rest();\n                    destructuring_bind_must_consp(current, datum, $list14);\n                    query_x_value_with_units = current.first();\n                    current = current.rest();\n                    destructuring_bind_must_consp(current, datum, $list14);\n                    query_y_value_with_units = current.first();\n                    current = current.rest();\n                    if (NIL == current) {\n                        if (NIL != variables.not_fully_bound_p(query_y_value_with_units)) {\n                            thread.resetMultipleValues();\n                            final SubLObject query_x_units = quantities.explode_interval(query_x_value_with_units);\n                            final SubLObject query_x_value = thread.secondMultipleValue();\n                            thread.resetMultipleValues();\n                            final SubLObject normalized_query_x_value = quantities.convert_to_units_absolute(x_units, query_x_units, query_x_value, UNPROVIDED);\n                            final SubLObject answer_y_value = funcall(java_link_function, x_y_values, normalized_query_x_value);\n                            if (NIL != answer_y_value) {\n                                final SubLObject answer_y_value_with_units = quantities.make_interval(y_units, answer_y_value, UNPROVIDED);\n                                final SubLObject v_bindings = quantities.term_unify_with_units(query_y_value_with_units, answer_y_value_with_units);\n                                backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings, asent), UNPROVIDED, UNPROVIDED), v_bindings, UNPROVIDED);\n                            }\n                        } else {\n                            final SubLObject y_x_values = Mapping.mapcar(NREVERSE, x_y_values);\n                            thread.resetMultipleValues();\n                            final SubLObject query_y_units = quantities.explode_interval(query_y_value_with_units);\n                            final SubLObject query_y_value = thread.secondMultipleValue();\n                            thread.resetMultipleValues();\n                            final SubLObject normalized_query_y_value = quantities.convert_to_units_absolute(y_units, query_y_units, query_y_value, UNPROVIDED);\n                            final SubLObject answer_x_value = funcall(java_link_function, y_x_values, normalized_query_y_value);\n                            if (NIL != answer_x_value) {\n                                final SubLObject answer_x_value_with_units = quantities.make_interval(x_units, answer_x_value, UNPROVIDED);\n                                final SubLObject v_bindings2 = quantities.term_unify_with_units(query_x_value_with_units, answer_x_value_with_units);\n                                backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings2, asent), UNPROVIDED, UNPROVIDED), v_bindings2, UNPROVIDED);\n                            }\n                        }\n                    } else {\n                        cdestructuring_bind_error(datum, $list14);\n                    }\n                }\n            }\n        }\n        return NIL;\n    }\n    public static SubLObject removal_extrapolation_with_simple_linear_regression_with_error_bars_expand(final SubLObject asent, SubLObject sense) {\n        if (sense == UNPROVIDED) {\n            sense = NIL;\n        }\n        return removal_interpolation_or_extrapolation_with_error_bars_with_java_link_function_expand_helper(asent, JAVA_LINK_X_Y_REGRESSION_FIND_Y_FOR_X_WITH_ERROR_BARS);\n    }\n    public static SubLObject removal_interpolation_or_extrapolation_with_error_bars_with_java_link_function_expand_helper(final SubLObject asent, final SubLObject java_link_function) {\n        final SubLThread thread = SubLProcess.currentSubLThread();\n        final SubLObject set_of_points_in_units = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);\n        final SubLObject query_point = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);\n        final SubLObject query_error_with_units = cycl_utilities.atomic_sentence_arg3(asent, UNPROVIDED);\n        if (NIL != el_extensional_set_p(set_of_points_in_units)) {\n            final SubLObject v_2d_points = extensional_set_elements(set_of_points_in_units);\n            if ((NIL != v_2d_points) && (NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points, UNPROVIDED))) {\n                thread.resetMultipleValues();\n                final SubLObject x_y_values = explode_2d_points_with_units(v_2d_points, UNPROVIDED, UNPROVIDED);\n                final SubLObject x_units = thread.secondMultipleValue();\n                final SubLObject y_units = thread.thirdMultipleValue();\n                thread.resetMultipleValues();\n                if (((NIL != x_y_values) && (NIL != x_units)) && (NIL != y_units)) {\n                    SubLObject current;\n                    final SubLObject datum = current = query_point;\n                    SubLObject the_2d_point = NIL;\n                    SubLObject query_x_value_with_units = NIL;\n                    SubLObject query_y_value_with_units = NIL;\n                    destructuring_bind_must_consp(current, datum, $list14);\n                    the_2d_point = current.first();\n                    current = current.rest();\n                    destructuring_bind_must_consp(current, datum, $list14);\n                    query_x_value_with_units = current.first();\n                    current = current.rest();\n                    destructuring_bind_must_consp(current, datum, $list14);\n                    query_y_value_with_units = current.first();\n                    current = current.rest();\n                    if (NIL == current) {\n                        if (NIL != variables.not_fully_bound_p(query_y_value_with_units)) {\n                            thread.resetMultipleValues();\n                            final SubLObject query_x_units = quantities.explode_interval(query_x_value_with_units);\n                            final SubLObject query_x_value = thread.secondMultipleValue();\n                            thread.resetMultipleValues();\n                            final SubLObject normalized_query_x_value = quantities.convert_to_units_absolute(x_units, query_x_units, query_x_value, UNPROVIDED);\n                            thread.resetMultipleValues();\n                            final SubLObject answer_y_value = funcall(java_link_function, x_y_values, normalized_query_x_value);\n                            final SubLObject answer_y_error = thread.secondMultipleValue();\n                            thread.resetMultipleValues();\n                            if ((NIL != answer_y_value) && (NIL != answer_y_error)) {\n                                final SubLObject answer_y_value_with_units = quantities.make_interval(y_units, answer_y_value, UNPROVIDED);\n                                final SubLObject answer_y_error_with_units = quantities.make_interval(y_units, answer_y_error, UNPROVIDED);\n                                final SubLObject v_bindings = append(quantities.term_unify_with_units(query_y_value_with_units, answer_y_value_with_units), quantities.term_unify_with_units(query_error_with_units, answer_y_error_with_units));\n                                backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings, asent), UNPROVIDED, UNPROVIDED), v_bindings, UNPROVIDED);\n                            }\n                        } else {\n                            final SubLObject y_x_values = Mapping.mapcar(NREVERSE, x_y_values);\n                            thread.resetMultipleValues();\n                            final SubLObject query_y_units = quantities.explode_interval(query_y_value_with_units);\n                            final SubLObject query_y_value = thread.secondMultipleValue();\n                            thread.resetMultipleValues();\n                            final SubLObject normalized_query_y_value = quantities.convert_to_units_absolute(y_units, query_y_units, query_y_value, UNPROVIDED);\n                            thread.resetMultipleValues();\n                            final SubLObject answer_x_value = funcall(java_link_function, y_x_values, normalized_query_y_value);\n                            final SubLObject answer_x_error = thread.secondMultipleValue();\n                            thread.resetMultipleValues();\n                            if ((NIL != answer_x_value) && (NIL != answer_x_error)) {\n                                final SubLObject answer_x_value_with_units = quantities.make_interval(x_units, answer_x_value, UNPROVIDED);\n                                final SubLObject answer_x_error_with_units = quantities.make_interval(x_units, answer_x_error, UNPROVIDED);\n                                final SubLObject v_bindings2 = append(quantities.term_unify_with_units(query_x_value_with_units, answer_x_value_with_units), quantities.term_unify_with_units(query_error_with_units, answer_x_error_with_units));\n                                backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings2, asent), UNPROVIDED, UNPROVIDED), v_bindings2, UNPROVIDED);\n                            }\n                        }\n                    } else {\n                        cdestructuring_bind_error(datum, $list14);\n                    }\n                }\n            }\n        }\n        return NIL;\n    }\n    public static SubLObject removal_regression_lines_for_sets_intersect_at_point_expand(final SubLObject asent, SubLObject sense) {\n        if (sense == UNPROVIDED) {\n            sense = NIL;\n        }\n        final SubLThread thread = SubLProcess.currentSubLThread();\n        final SubLObject set_of_points_in_units_1 = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);\n        final SubLObject set_of_points_in_units_2 = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);\n        final SubLObject query_point = cycl_utilities.atomic_sentence_arg3(asent, UNPROVIDED);\n        if ((NIL != el_extensional_set_p(set_of_points_in_units_1)) && (NIL != el_extensional_set_p(set_of_points_in_units_2))) {\n            final SubLObject v_2d_points_1 = extensional_set_elements(set_of_points_in_units_1);\n            final SubLObject v_2d_points_2 = extensional_set_elements(set_of_points_in_units_2);\n            if ((NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points_1, UNPROVIDED)) && (NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points_2, UNPROVIDED))) {\n                thread.resetMultipleValues();\n                final SubLObject x_y_values_1 = explode_2d_points_with_units(v_2d_points_1, UNPROVIDED, UNPROVIDED);\n                final SubLObject x_units = thread.secondMultipleValue();\n                final SubLObject y_units = thread.thirdMultipleValue();\n                thread.resetMultipleValues();\n                final SubLObject x_y_values_2 = explode_2d_points_with_units(v_2d_points_2, x_units, y_units);\n                thread.resetMultipleValues();\n                final SubLObject x = java_link_point_intersection_of_two_x_y_regressions(x_y_values_1, x_y_values_2);\n                final SubLObject y = thread.secondMultipleValue();\n                thread.resetMultipleValues();\n                if (x.isNumber() && y.isNumber()) {\n                    if (NIL != variables.variable_p(query_point)) {\n                        final SubLObject x_y_point_with_units = list($$The2DPoint, quantities.make_interval(x_units, x, UNPROVIDED), quantities.make_interval(y_units, y, UNPROVIDED));\n                        final SubLObject v_bindings = quantities.term_unify_with_units(query_point, x_y_point_with_units);\n                        backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings, asent), UNPROVIDED, UNPROVIDED), v_bindings, UNPROVIDED);\n                    } else {\n                        final SubLObject v_bindings2 = append(quantities.term_unify_with_units(second(query_point), quantities.make_interval(x_units, x, UNPROVIDED)), quantities.term_unify_with_units(third(query_point), quantities.make_interval(y_units, y, UNPROVIDED)));\n                        backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings2, asent), UNPROVIDED, UNPROVIDED), v_bindings2, UNPROVIDED);\n                    }\n                }\n            }\n        }\n        return NIL;\n    }\n    public static SubLObject removal_slope_of_regression_line_for_set_of_points_expand(final SubLObject asent, SubLObject sense) {\n        if (sense == UNPROVIDED) {\n            sense = NIL;\n        }\n        final SubLThread thread = SubLProcess.currentSubLThread();\n        final SubLObject set_of_points_in_units = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);\n        final SubLObject query_slope = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);\n        if ((NIL != el_extensional_set_p(set_of_points_in_units)) && ONE_INTEGER.numL(el_set_size(set_of_points_in_units))) {\n            final SubLObject v_2d_points = extensional_set_elements(set_of_points_in_units);\n            if (NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points, UNPROVIDED)) {\n                thread.resetMultipleValues();\n                final SubLObject x_y_values = explode_2d_points_with_units(v_2d_points, UNPROVIDED, UNPROVIDED);\n                final SubLObject x_units = thread.secondMultipleValue();\n                final SubLObject y_units = thread.thirdMultipleValue();\n                thread.resetMultipleValues();\n                final SubLObject slope = java_link_slope_and_intercept_of_x_y_regression(x_y_values);\n                final SubLObject bindings_1 = quantities.term_unify_with_units(query_slope, quantities.make_interval(quantities.unit_quotient(y_units, x_units), slope, UNPROVIDED));\n                final SubLObject bindings_2 = (NIL != czer_utilities.equals_elP(x_units, y_units, UNPROVIDED, UNPROVIDED, UNPROVIDED)) ? NIL : quantities.term_unify_with_units(query_slope, quantities.make_interval(quantities.unit_quotient(x_units, y_units), divide(ONE_INTEGER, slope), UNPROVIDED));\n                if (NIL != bindings_1) {\n                    backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(bindings_1, asent), UNPROVIDED, UNPROVIDED), bindings_1, UNPROVIDED);\n                }\n                if (NIL != bindings_2) {\n                    backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(bindings_2, asent), UNPROVIDED, UNPROVIDED), bindings_2, UNPROVIDED);\n                }\n            }\n        }\n        return NIL;\n    }\n    public static SubLObject removal_set_of_first_derivative_points_based_on_set_of_points_expand(final SubLObject asent, SubLObject sense) {\n        if (sense == UNPROVIDED) {\n            sense = NIL;\n        }\n        final SubLThread thread = SubLProcess.currentSubLThread();\n        final SubLObject set_of_points_in_units = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);\n        final SubLObject function_type = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);\n        final SubLObject set_of_derivative_points_in_units = cycl_utilities.atomic_sentence_arg3(asent, UNPROVIDED);\n        if (NIL != el_extensional_set_p(set_of_points_in_units)) {\n            final SubLObject v_2d_points = extensional_set_elements(set_of_points_in_units);\n            if (NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points, UNPROVIDED)) {\n                thread.resetMultipleValues();\n                final SubLObject x_y_values = explode_2d_points_with_units(v_2d_points, UNPROVIDED, UNPROVIDED);\n                final SubLObject x_units = thread.secondMultipleValue();\n                final SubLObject y_units = thread.thirdMultipleValue();\n                thread.resetMultipleValues();\n                final SubLObject x_y_derivative_points = java_link_x_y_derivatives_for_interpolation_at_each_x(x_y_values, function_type);\n                final SubLObject derivative_units = quantities.unit_quotient(y_units, x_units);\n                SubLObject result = NIL;\n                SubLObject v_bindings = NIL;\n                SubLObject cdolist_list_var = x_y_derivative_points;\n                SubLObject x_y_derivative_point = NIL;\n                x_y_derivative_point = cdolist_list_var.first();\n                while (NIL != cdolist_list_var) {\n                    result = cons(list($$The2DPoint, list(x_units, x_y_derivative_point.first()), list(derivative_units, second(x_y_derivative_point))), result);\n                    cdolist_list_var = cdolist_list_var.rest();\n                    x_y_derivative_point = cdolist_list_var.first();\n                } \n                result = make_el_extensional_set(nreverse(result));\n                v_bindings = unification_utilities.term_unify(result, set_of_derivative_points_in_units, UNPROVIDED, UNPROVIDED);\n                if (NIL != v_bindings) {\n                    backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings, asent), UNPROVIDED, UNPROVIDED), v_bindings, UNPROVIDED);\n                }\n            }\n        }\n        return NIL;\n    }\n    public static SubLObject removal_set_has_points_with_y_value_reln_to_matching_x_value_points_in_set_expand(final SubLObject asent, SubLObject sense) {\n        if (sense == UNPROVIDED) {\n            sense = NIL;\n        }\n        final SubLThread thread = SubLProcess.currentSubLThread();\n        final SubLObject set_of_points_1_in_units = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);\n        final SubLObject set_of_points_2_in_units = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);\n        final SubLObject binary_function = cycl_utilities.atomic_sentence_arg3(asent, UNPROVIDED);\n        final SubLObject binary_predicate = cycl_utilities.atomic_sentence_arg4(asent, UNPROVIDED);\n        final SubLObject value_in_y_units = cycl_utilities.atomic_sentence_arg5(asent, UNPROVIDED);\n        final SubLObject set_of_qualifying_points_in_units = cycl_utilities.atomic_sentence_arg6(asent, UNPROVIDED);\n        if (((((NIL != el_extensional_set_p(set_of_points_1_in_units)) && (NIL != el_extensional_set_p(set_of_points_2_in_units))) && (NIL != fort_types_interface.functionP(binary_function))) && arity.arity(binary_function).eql(TWO_INTEGER)) && (NIL != kb_accessors.binary_predicateP(binary_predicate))) {\n            final SubLObject v_2d_points_1 = extensional_set_elements(set_of_points_1_in_units);\n            final SubLObject v_2d_points_2 = extensional_set_elements(set_of_points_2_in_units);\n            if ((NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points_1, UNPROVIDED)) && (NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points_2, UNPROVIDED))) {\n                thread.resetMultipleValues();\n                final SubLObject x_y_values_1 = explode_2d_points_with_units(v_2d_points_1, UNPROVIDED, UNPROVIDED);\n                final SubLObject x_units = thread.secondMultipleValue();\n                final SubLObject y_units = thread.thirdMultipleValue();\n                thread.resetMultipleValues();\n                final SubLObject x_y_values_2 = explode_2d_points_with_units(v_2d_points_2, x_units, y_units);\n                final SubLObject y_compare_value = second(quantities.cyc_quantity_conversion(y_units, value_in_y_units));\n                SubLObject result_x_y_values = NIL;\n                SubLObject cdolist_list_var = x_y_values_1;\n                SubLObject x_y_value_1 = NIL;\n                x_y_value_1 = cdolist_list_var.first();\n                while (NIL != cdolist_list_var) {\n                    final SubLObject x_value_1 = x_y_value_1.first();\n                    final SubLObject y_value_1 = second(x_y_value_1);\n                    final SubLObject y_value_2 = second(find(x_value_1, x_y_values_2, EQL, FIRST, UNPROVIDED, UNPROVIDED));\n                    if ((NIL != y_value_2) && (NIL != backward.removal_ask(list(binary_predicate, list(binary_function, y_value_1, y_value_2), y_compare_value), UNPROVIDED, UNPROVIDED, UNPROVIDED))) {\n                        result_x_y_values = cons(x_y_value_1, result_x_y_values);\n                    }\n                    cdolist_list_var = cdolist_list_var.rest();\n                    x_y_value_1 = cdolist_list_var.first();\n                } \n                SubLObject result = NIL;\n                SubLObject cdolist_list_var2 = result_x_y_values;\n                SubLObject result_x_y_value = NIL;\n                result_x_y_value = cdolist_list_var2.first();\n                while (NIL != cdolist_list_var2) {\n                    result = cons(list($$The2DPoint, list(x_units, result_x_y_value.first()), list(y_units, second(result_x_y_value))), result);\n                    cdolist_list_var2 = cdolist_list_var2.rest();\n                    result_x_y_value = cdolist_list_var2.first();\n                } \n                result = make_el_extensional_set(nreverse(result));\n                final SubLObject v_bindings = unification_utilities.term_unify(result, set_of_qualifying_points_in_units, UNPROVIDED, UNPROVIDED);\n                if (NIL != v_bindings) {\n                    backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings, asent), UNPROVIDED, UNPROVIDED), v_bindings, UNPROVIDED);\n                }\n            }\n        }\n        return NIL;\n    }\n    public static SubLObject java_link_debug_modeP() {\n        final SubLThread thread = SubLProcess.currentSubLThread();\n        return $inference_debugP$.getDynamicValue(thread);\n    }\n    public static SubLObject java_link_slope_and_intercept_of_x_y_regression(final SubLObject x_y_values) {\n        final SubLObject regression = JavaLink.java_new($str35$org_apache_commons_math_stat_regr, EMPTY_SUBL_OBJECT_ARRAY);\n        final SubLObject add_data_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$addData, new SubLObject[]{ $$$double, $$$double });\n        final SubLObject slope_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$getSlope, EMPTY_SUBL_OBJECT_ARRAY);\n        final SubLObject intercept_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$getIntercept, EMPTY_SUBL_OBJECT_ARRAY);\n        SubLObject cdolist_list_var = x_y_values;\n        SubLObject x_y_value = NIL;\n        x_y_value = cdolist_list_var.first();\n        while (NIL != cdolist_list_var) {\n            JavaLink.java_call(add_data_method, regression, new SubLObject[]{ x_y_value.first(), second(x_y_value) });\n            cdolist_list_var = cdolist_list_var.rest();\n            x_y_value = cdolist_list_var.first();\n        } \n        return values(JavaLink.java_call(slope_method, regression, EMPTY_SUBL_OBJECT_ARRAY), JavaLink.java_call(intercept_method, regression, EMPTY_SUBL_OBJECT_ARRAY));\n    }\n    public static SubLObject java_link_x_y_cubic_spline_find_y_for_x(SubLObject x_y_values, final SubLObject x_value) {\n        if ((x_value.numL(apply(MIN, Mapping.mapcar(FIRST, x_y_values))) || x_value.numG(apply(MAX, Mapping.mapcar(FIRST, x_y_values)))) || ((NIL == java_link_debug_modeP()) && (NIL != list_utilities.duplicatesP(Mapping.mapcar(FIRST, x_y_values), UNPROVIDED, UNPROVIDED)))) {\n            return NIL;\n        }\n        final SubLObject interpolator = JavaLink.java_new($str42$org_apache_commons_math_analysis_, EMPTY_SUBL_OBJECT_ARRAY);\n        final SubLObject interpolate_method = JavaLink.java_method($str42$org_apache_commons_math_analysis_, $$$interpolate, new SubLObject[]{ $str44$_D, $str44$_D });\n        final SubLObject value_method = JavaLink.java_method($str45$org_apache_commons_math_analysis_, $$$value, new SubLObject[]{ $$$double });\n        x_y_values = Sort.sort(x_y_values, $sym47$_, FIRST);\n        final SubLObject poly_spline_function = JavaLink.java_call(interpolate_method, interpolator, new SubLObject[]{ Mapping.mapcar(FIRST, x_y_values), Mapping.mapcar(SECOND, x_y_values) });\n        return JavaLink.java_call(value_method, poly_spline_function, new SubLObject[]{ x_value });\n    }\n    public static SubLObject java_link_x_y_piecewise_linear_find_y_for_x(SubLObject x_y_values, final SubLObject x_value) {\n        if ((x_value.numL(apply(MIN, Mapping.mapcar(FIRST, x_y_values))) || x_value.numG(apply(MAX, Mapping.mapcar(FIRST, x_y_values)))) || ((NIL == java_link_debug_modeP()) && (NIL != list_utilities.duplicatesP(Mapping.mapcar(FIRST, x_y_values), UNPROVIDED, UNPROVIDED)))) {\n            return NIL;\n        }\n        final SubLObject interpolator = JavaLink.java_new($str49$org_apache_commons_math_analysis_, EMPTY_SUBL_OBJECT_ARRAY);\n        final SubLObject interpolate_method = JavaLink.java_method($str49$org_apache_commons_math_analysis_, $$$interpolate, new SubLObject[]{ $str44$_D, $str44$_D });\n        final SubLObject value_method = JavaLink.java_method($str45$org_apache_commons_math_analysis_, $$$value, new SubLObject[]{ $$$double });\n        x_y_values = Sort.sort(x_y_values, $sym47$_, FIRST);\n        final SubLObject poly_spline_function = JavaLink.java_call(interpolate_method, interpolator, new SubLObject[]{ Mapping.mapcar(FIRST, x_y_values), Mapping.mapcar(SECOND, x_y_values) });\n        return JavaLink.java_call(value_method, poly_spline_function, new SubLObject[]{ x_value });\n    }\n    public static SubLObject java_link_x_y_regression_find_y_for_x(final SubLObject x_y_values, final SubLObject x_value) {\n        final SubLObject regression = JavaLink.java_new($str35$org_apache_commons_math_stat_regr, EMPTY_SUBL_OBJECT_ARRAY);\n        final SubLObject add_data_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$addData, new SubLObject[]{ $$$double, $$$double });\n        final SubLObject predict_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$predict, new SubLObject[]{ $$$double });\n        SubLObject cdolist_list_var = x_y_values;\n        SubLObject x_y_value = NIL;\n        x_y_value = cdolist_list_var.first();\n        while (NIL != cdolist_list_var) {\n            JavaLink.java_call(add_data_method, regression, new SubLObject[]{ x_y_value.first(), second(x_y_value) });\n            cdolist_list_var = cdolist_list_var.rest();\n            x_y_value = cdolist_list_var.first();\n        } \n        return JavaLink.java_call(predict_method, regression, new SubLObject[]{ x_value });\n    }\n    public static SubLObject java_link_x_y_regression_find_y_for_x_with_error_bars(final SubLObject x_y_values, final SubLObject x_value) {\n        if (length(x_y_values).numL(THREE_INTEGER)) {\n            return NIL;\n        }\n        final SubLObject number_of_points = length(x_y_values);\n        final SubLObject regression = JavaLink.java_new($str35$org_apache_commons_math_stat_regr, EMPTY_SUBL_OBJECT_ARRAY);\n        final SubLObject add_data_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$addData, new SubLObject[]{ $$$double, $$$double });\n        final SubLObject sse_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$getSumSquaredErrors, EMPTY_SUBL_OBJECT_ARRAY);\n        final SubLObject predict_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$predict, new SubLObject[]{ $$$double });\n        SubLObject cdolist_list_var = x_y_values;\n        SubLObject x_y_value = NIL;\n        x_y_value = cdolist_list_var.first();\n        while (NIL != cdolist_list_var) {\n            JavaLink.java_call(add_data_method, regression, new SubLObject[]{ x_y_value.first(), second(x_y_value) });\n            cdolist_list_var = cdolist_list_var.rest();\n            x_y_value = cdolist_list_var.first();\n        } \n        final SubLObject sum_of_squared_errors = JavaLink.java_call(sse_method, regression, EMPTY_SUBL_OBJECT_ARRAY);\n        final SubLObject y_error = sqrt(divide(sum_of_squared_errors, subtract(number_of_points, TWO_INTEGER)));\n        return values(JavaLink.java_call(predict_method, regression, new SubLObject[]{ x_value }), y_error);\n    }\n    public static SubLObject java_link_point_intersection_of_two_x_y_regressions(final SubLObject x_y_values_1, final SubLObject x_y_values_2) {\n        if ((((NIL == x_y_values_1) || (NIL != list_utilities.singletonP(x_y_values_1))) || (NIL == x_y_values_2)) || (NIL != list_utilities.singletonP(x_y_values_2))) {\n            return NIL;\n        }\n        final SubLObject regression_1 = JavaLink.java_new($str35$org_apache_commons_math_stat_regr, EMPTY_SUBL_OBJECT_ARRAY);\n        final SubLObject regression_2 = JavaLink.java_new($str35$org_apache_commons_math_stat_regr, EMPTY_SUBL_OBJECT_ARRAY);\n        final SubLObject add_data_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$addData, new SubLObject[]{ $$$double, $$$double });\n        final SubLObject predict_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$predict, new SubLObject[]{ $$$double });\n        final SubLObject l1_p1_x = x_y_values_1.first().first();\n        final SubLObject l1_p2_x = second(x_y_values_1).first();\n        final SubLObject l2_p1_x = x_y_values_2.first().first();\n        final SubLObject l2_p2_x = second(x_y_values_2).first();\n        SubLObject cdolist_list_var = x_y_values_1;\n        SubLObject x_y_value_1 = NIL;\n        x_y_value_1 = cdolist_list_var.first();\n        while (NIL != cdolist_list_var) {\n            JavaLink.java_call(add_data_method, regression_1, new SubLObject[]{ x_y_value_1.first(), second(x_y_value_1) });\n            cdolist_list_var = cdolist_list_var.rest();\n            x_y_value_1 = cdolist_list_var.first();\n        } \n        cdolist_list_var = x_y_values_2;\n        SubLObject x_y_value_2 = NIL;\n        x_y_value_2 = cdolist_list_var.first();\n        while (NIL != cdolist_list_var) {\n            JavaLink.java_call(add_data_method, regression_2, new SubLObject[]{ x_y_value_2.first(), second(x_y_value_2) });\n            cdolist_list_var = cdolist_list_var.rest();\n            x_y_value_2 = cdolist_list_var.first();\n        } \n        final SubLObject l1_p1_y = JavaLink.java_call(predict_method, regression_1, new SubLObject[]{ l1_p1_x });\n        final SubLObject l1_p2_y = JavaLink.java_call(predict_method, regression_1, new SubLObject[]{ l1_p2_x });\n        final SubLObject l2_p1_y = JavaLink.java_call(predict_method, regression_2, new SubLObject[]{ l2_p1_x });\n        final SubLObject l2_p2_y = JavaLink.java_call(predict_method, regression_2, new SubLObject[]{ l2_p2_x });\n        final SubLObject line_class_name = $str52$org_apache_commons_math_geometry_;\n        final SubLObject vector2d_class_name = $str53$org_apache_commons_math_geometry_;\n        final SubLObject line_new_method = JavaLink.java_method(line_class_name, NIL, new SubLObject[]{ vector2d_class_name, vector2d_class_name });\n        final SubLObject vector2d_new_method = JavaLink.java_method(vector2d_class_name, NIL, new SubLObject[]{ $$$double, $$$double });\n        final SubLObject line_1 = JavaLink.java_new(line_new_method, new SubLObject[]{ JavaLink.java_new(vector2d_new_method, new SubLObject[]{ l1_p1_x, l1_p1_y }), JavaLink.java_new(vector2d_new_method, new SubLObject[]{ l1_p2_x, l1_p2_y }) });\n        final SubLObject line_2 = JavaLink.java_new(line_new_method, new SubLObject[]{ JavaLink.java_new(vector2d_new_method, new SubLObject[]{ l2_p1_x, l2_p1_y }), JavaLink.java_new(vector2d_new_method, new SubLObject[]{ l2_p2_x, l2_p2_y }) });\n        final SubLObject intersection_method = JavaLink.java_method(line_class_name, $$$intersection, new SubLObject[]{ $str55$org_apache_commons_math_geometry_ });\n        final SubLObject intersection_2dvector = JavaLink.java_call(intersection_method, line_1, new SubLObject[]{ line_2 });\n        if (NIL != intersection_2dvector) {\n            final SubLObject vector2d_getx_method = JavaLink.java_method(vector2d_class_name, $$$getX, EMPTY_SUBL_OBJECT_ARRAY);\n            final SubLObject vector2d_gety_method = JavaLink.java_method(vector2d_class_name, $$$getY, EMPTY_SUBL_OBJECT_ARRAY);\n            return values(JavaLink.java_call(vector2d_getx_method, intersection_2dvector, EMPTY_SUBL_OBJECT_ARRAY), JavaLink.java_call(vector2d_gety_method, intersection_2dvector, EMPTY_SUBL_OBJECT_ARRAY));\n        }\n        return NIL;\n    }\n    public static SubLObject java_link_x_y_derivatives_for_interpolation_at_each_x(SubLObject x_y_values, final SubLObject interpolator) {\n        if ((NIL == java_link_debug_modeP()) && (NIL != list_utilities.duplicatesP(Mapping.mapcar(FIRST, x_y_values), UNPROVIDED, UNPROVIDED))) {\n            return NIL;\n        }\n        final SubLObject interpolator_string = (interpolator.eql($$CubicSpline)) ? $str42$org_apache_commons_math_analysis_ : interpolator.eql($const59$LinearPolynomialFunction_Piecewis) ? $str49$org_apache_commons_math_analysis_ : $str42$org_apache_commons_math_analysis_;\n        final SubLObject interpolator_$1 = JavaLink.java_new(interpolator_string, EMPTY_SUBL_OBJECT_ARRAY);\n        final SubLObject interpolate_method = JavaLink.java_method(interpolator_string, $$$interpolate, new SubLObject[]{ $str44$_D, $str44$_D });\n        final SubLObject value_method = JavaLink.java_method($str45$org_apache_commons_math_analysis_, $$$value, new SubLObject[]{ $$$double });\n        final SubLObject derivative_method = JavaLink.java_method($str45$org_apache_commons_math_analysis_, $$$derivative, EMPTY_SUBL_OBJECT_ARRAY);\n        SubLObject derivative_x_y_values = NIL;\n        x_y_values = Sort.sort(copy_list(x_y_values), $sym47$_, FIRST);\n        final SubLObject poly_spline_function = JavaLink.java_call(interpolate_method, interpolator_$1, new SubLObject[]{ Mapping.mapcar(FIRST, x_y_values), Mapping.mapcar(SECOND, x_y_values) });\n        final SubLObject poly_spline_derivative = JavaLink.java_call(derivative_method, poly_spline_function, EMPTY_SUBL_OBJECT_ARRAY);\n        SubLObject cdolist_list_var = x_y_values;\n        SubLObject x_y_value = NIL;\n        x_y_value = cdolist_list_var.first();\n        while (NIL != cdolist_list_var) {\n            final SubLObject x_value = x_y_value.first();\n            derivative_x_y_values = cons(list(x_value, JavaLink.java_call(value_method, poly_spline_derivative, new SubLObject[]{ x_value })), derivative_x_y_values);\n            cdolist_list_var = cdolist_list_var.rest();\n            x_y_value = cdolist_list_var.first();\n        } \n        return nreverse(derivative_x_y_values);\n    }\n    public static SubLObject el_2d_point_p(final SubLObject v_object) {\n        return makeBoolean(((NIL != el_formula_p(v_object)) && cycl_utilities.formula_operator(v_object).eql($$The2DPoint)) && (NIL != el_binary_formula_p(v_object)));\n    }\n    public static SubLObject explode_2d_points_with_units(final SubLObject v_2d_points, SubLObject x_units, SubLObject y_units) {\n        if (x_units == UNPROVIDED) {\n            x_units = NIL;\n        }\n        if (y_units == UNPROVIDED) {\n            y_units = NIL;\n        }\n        final SubLThread thread = SubLProcess.currentSubLThread();\n        assert NIL != list_utilities.non_dotted_list_p(v_2d_points) : \"list_utilities.non_dotted_list_p(v_2d_points) \" + \"CommonSymbols.NIL != list_utilities.non_dotted_list_p(v_2d_points) \" + v_2d_points;\n        SubLObject cdolist_list_var = v_2d_points;\n        SubLObject elem = NIL;\n        elem = cdolist_list_var.first();\n        while (NIL != cdolist_list_var) {\n            assert NIL != el_2d_point_p(elem) : \"removal_modules_math.el_2d_point_p(elem) \" + \"CommonSymbols.NIL != removal_modules_math.el_2d_point_p(elem) \" + elem;\n            cdolist_list_var = cdolist_list_var.rest();\n            elem = cdolist_list_var.first();\n        } \n        SubLObject x_y_values = NIL;\n        cdolist_list_var = v_2d_points;\n        SubLObject v_2d_point = NIL;\n        v_2d_point = cdolist_list_var.first();\n        while (NIL != cdolist_list_var) {\n            final SubLObject x_y_with_units = cycl_utilities.formula_args(v_2d_point, UNPROVIDED);\n            final SubLObject x_with_units = x_y_with_units.first();\n            final SubLObject y_with_units = second(x_y_with_units);\n            thread.resetMultipleValues();\n            final SubLObject this_x_units = quantities.explode_interval(x_with_units);\n            SubLObject this_x_value = thread.secondMultipleValue();\n            thread.resetMultipleValues();\n            if (NIL == x_units) {\n                x_units = this_x_units;\n            }\n            if (!x_units.equal(this_x_units)) {\n                this_x_value = quantities.convert_to_units_absolute(x_units, this_x_units, this_x_value, UNPROVIDED);\n            }\n            thread.resetMultipleValues();\n            final SubLObject this_y_units = quantities.explode_interval(y_with_units);\n            SubLObject this_y_value = thread.secondMultipleValue();\n            thread.resetMultipleValues();\n            if (NIL == y_units) {\n                y_units = this_y_units;\n            }\n            if (!y_units.equal(this_y_units)) {\n                this_y_value = quantities.convert_to_units_absolute(y_units, this_y_units, this_y_value, UNPROVIDED);\n            }\n            x_y_values = cons(list(this_x_value, this_y_value), x_y_values);\n            cdolist_list_var = cdolist_list_var.rest();\n            v_2d_point = cdolist_list_var.first();\n        } \n        return values(x_y_values, x_units, y_units);\n    }\n    public static SubLObject removal_set_has_points_with_y_value_reln_to_expand(final SubLObject asent, SubLObject sense) {\n        if (sense == UNPROVIDED) {\n            sense = NIL;\n        }\n        final SubLObject set_of_points_in_units = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);\n        final SubLObject operator = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);\n        final SubLObject comparator = cycl_utilities.atomic_sentence_arg3(asent, UNPROVIDED);\n        final SubLObject quant1 = cycl_utilities.atomic_sentence_arg4(asent, UNPROVIDED);\n        final SubLObject quant2 = cycl_utilities.atomic_sentence_arg5(asent, UNPROVIDED);\n        final SubLObject newset_var = cycl_utilities.atomic_sentence_arg6(asent, UNPROVIDED);\n        if ((((NIL != el_extensional_set_p(set_of_points_in_units)) && (NIL != fort_types_interface.functionP(operator))) && (NIL != relation_evaluation.evaluatable_predicateP(comparator, UNPROVIDED))) && arity.arity(comparator).eql(TWO_INTEGER)) {\n            final SubLObject x_y_values_with_units = extensional_set_elements(set_of_points_in_units);\n            SubLObject result_points = NIL;\n            if (NIL != list_utilities.every_in_list(EL_2D_POINT_P, x_y_values_with_units, UNPROVIDED)) {\n                SubLObject cdolist_list_var = x_y_values_with_units;\n                SubLObject x_y_value_with_units = NIL;\n                x_y_value_with_units = cdolist_list_var.first();\n                while (NIL != cdolist_list_var) {\n                    final SubLObject y_value = cycl_utilities.formula_arg2(x_y_value_with_units, UNPROVIDED);\n                    if (NIL != relation_evaluation.cyc_evaluate(list(comparator, list(operator, y_value, quant1), quant2))) {\n                        result_points = cons(x_y_value_with_units, result_points);\n                    }\n                    cdolist_list_var = cdolist_list_var.rest();\n                    x_y_value_with_units = cdolist_list_var.first();\n                } \n            }\n            if (NIL != result_points) {\n                final SubLObject v_bindings = unification_utilities.term_unify(make_el_set(list_utilities.fast_remove_duplicates(result_points, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED), UNPROVIDED), newset_var, UNPROVIDED, UNPROVIDED);\n                if (NIL != v_bindings) {\n                    backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings, asent), UNPROVIDED, UNPROVIDED), v_bindings, UNPROVIDED);\n                }\n            }\n        }\n        return NIL;\n    }\n    public static SubLObject removal_operation_result_comparison_pos_check(final SubLObject asent, SubLObject sense) {\n        if (sense == UNPROVIDED) {\n            sense = NIL;\n        }\n        final SubLObject operator = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);\n        final SubLObject a = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);\n        final SubLObject b = cycl_utilities.atomic_sentence_arg3(asent, UNPROVIDED);\n        final SubLObject comparator = cycl_utilities.atomic_sentence_arg4(asent, UNPROVIDED);\n        final SubLObject quant = cycl_utilities.atomic_sentence_arg5(asent, UNPROVIDED);\n        if (((NIL != fort_types_interface.functionP(operator)) && (NIL != relation_evaluation.evaluatable_predicateP(comparator, UNPROVIDED))) && arity.arity(comparator).eql(TWO_INTEGER)) {\n            final SubLObject expression = list(comparator, list(operator, a, b), quant);\n            if (NIL != relation_evaluation.cyc_evaluate(expression)) {\n                backward.removal_add_node(arguments.make_hl_support($OPAQUE, asent, UNPROVIDED, UNPROVIDED), NIL, list(removal_modules_evaluation.make_eval_support(expression, UNPROVIDED)));\n            }\n        }\n        return NIL;\n    }\n    public static SubLObject removal_operation_result_comparison_neg_check(final SubLObject asent, SubLObject sense) {\n        if (sense == UNPROVIDED) {\n            sense = NIL;\n        }\n        final SubLObject operator = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);\n        final SubLObject a = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);\n        final SubLObject b = cycl_utilities.atomic_sentence_arg3(asent, UNPROVIDED);\n        final SubLObject comparator = cycl_utilities.atomic_sentence_arg4(asent, UNPROVIDED);\n        final SubLObject quant = cycl_utilities.atomic_sentence_arg5(asent, UNPROVIDED);\n        if (((NIL != fort_types_interface.functionP(operator)) && (NIL != relation_evaluation.evaluatable_predicateP(comparator, UNPROVIDED))) && arity.arity(comparator).eql(TWO_INTEGER)) {\n            final SubLObject expression = list(comparator, list(operator, a, b), quant);\n            if (NIL == relation_evaluation.cyc_evaluate(expression)) {\n                backward.removal_add_node(arguments.make_hl_support($OPAQUE, make_negation(asent), UNPROVIDED, UNPROVIDED), NIL, list(removal_modules_evaluation.make_eval_support(make_negation(expression), UNPROVIDED)));\n            }\n        }\n        return NIL;\n    }\n    public static SubLObject removal_inflow_lengths_with_starting_depths_expand(final SubLObject asent, SubLObject sense) {\n        if (sense == UNPROVIDED) {\n            sense = NIL;\n        }\n        final SubLThread thread = SubLProcess.currentSubLThread();\n        final SubLObject well = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);\n        final SubLObject set_of_points_in_units = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);\n        final SubLObject function_type = $$CubicSpline;\n        final SubLObject length_and_depths_query = cycl_utilities.atomic_sentence_arg3(asent, UNPROVIDED);\n        final SubLObject debugP = NIL;\n        if (NIL != el_extensional_set_p(set_of_points_in_units)) {\n            final SubLObject v_2d_points = extensional_set_elements(set_of_points_in_units);\n            if (NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points, UNPROVIDED)) {\n                thread.resetMultipleValues();\n                SubLObject x_y_values = explode_2d_points_with_units(v_2d_points, $$Meter, $$DegreeCelsius);\n                final SubLObject x_units = thread.secondMultipleValue();\n                final SubLObject y_units = thread.thirdMultipleValue();\n                thread.resetMultipleValues();\n                x_y_values = Sort.sort(copy_list(x_y_values), $sym47$_, FIRST);\n                final SubLObject x_y_derivative_points = java_link_x_y_derivatives_for_interpolation_at_each_x(x_y_values, function_type);\n                final SubLObject average_y_value = number_utilities.average(x_y_values, SECOND);\n                final SubLObject derivative_units = quantities.unit_quotient(y_units, x_units);\n                SubLObject inflow_lengths = NIL;\n                if (NIL != debugP) {\n                    print(x_y_values, UNPROVIDED);\n                    print(x_y_derivative_points, UNPROVIDED);\n                    format_nil.force_format(T, $str76$____, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);\n                }\n                SubLObject cdolist_list_var = Sort.sort(copy_list(x_y_values), $sym85$_, SECOND);\n                SubLObject x_y_value = NIL;\n                x_y_value = cdolist_list_var.first();\n                while (NIL != cdolist_list_var) {\n                    SubLObject current;\n                    final SubLObject datum = current = x_y_value;\n                    SubLObject x_value = NIL;\n                    SubLObject y_value = NIL;\n                    destructuring_bind_must_consp(current, datum, $list77);\n                    x_value = current.first();\n                    current = current.rest();\n                    destructuring_bind_must_consp(current, datum, $list77);\n                    y_value = current.first();\n                    current = current.rest();\n                    if (NIL == current) {\n                        if (NIL != debugP) {\n                            format_nil.force_format(T, $str78$High_value__x__A_y__A__, x_value, y_value, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);\n                        }\n                        if (y_value.numG(add(FIVE_INTEGER, average_y_value))) {\n                            SubLObject already_in_inflowP = NIL;\n                            SubLObject inflow_start_x = NIL;\n                            SubLObject inflow_end_x = NIL;\n                            if (NIL == already_in_inflowP) {\n                                SubLObject csome_list_var = inflow_lengths;\n                                SubLObject inflow_length = NIL;\n                                inflow_length = csome_list_var.first();\n                                while ((NIL == already_in_inflowP) && (NIL != csome_list_var)) {\n                                    if (x_value.numGE(inflow_length.first()) && x_value.numLE(second(inflow_length))) {\n                                        already_in_inflowP = T;\n                                    }\n                                    csome_list_var = csome_list_var.rest();\n                                    inflow_length = csome_list_var.first();\n                                } \n                            }\n                            if (NIL == already_in_inflowP) {\n                                SubLObject found_start_pointP = NIL;\n                                if (NIL == found_start_pointP) {\n                                    SubLObject cur_x_y_value = NIL;\n                                    SubLObject cur_x_y_value_$2 = NIL;\n                                    SubLObject cur_x_y_derivative_point = NIL;\n                                    SubLObject cur_x_y_derivative_point_$3 = NIL;\n                                    cur_x_y_value = nreverse(copy_list(x_y_values));\n                                    cur_x_y_value_$2 = cur_x_y_value.first();\n                                    cur_x_y_derivative_point = nreverse(copy_list(x_y_derivative_points));\n                                    cur_x_y_derivative_point_$3 = cur_x_y_derivative_point.first();\n                                    while ((NIL == found_start_pointP) && ((NIL != cur_x_y_derivative_point) || (NIL != cur_x_y_value))) {\n                                        SubLObject current_$5;\n                                        final SubLObject datum_$4 = current_$5 = cur_x_y_derivative_point_$3;\n                                        SubLObject cur_x_value = NIL;\n                                        SubLObject cur_y_derivative_value = NIL;\n                                        destructuring_bind_must_consp(current_$5, datum_$4, $list79);\n                                        cur_x_value = current_$5.first();\n                                        current_$5 = current_$5.rest();\n                                        destructuring_bind_must_consp(current_$5, datum_$4, $list79);\n                                        cur_y_derivative_value = current_$5.first();\n                                        current_$5 = current_$5.rest();\n                                        if (NIL == current_$5) {\n                                            final SubLObject cur_y_value = second(cur_x_y_value_$2);\n                                            if (NIL != debugP) {\n                                                format_nil.force_format(T, $str80$checking_x__A_deriv__A__, cur_x_value, cur_y_derivative_value, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);\n                                                if (!cur_x_value.eql(cur_x_y_value_$2.first())) {\n                                                    print($$$Bad_looping, UNPROVIDED);\n                                                    Errors.sublisp_break(UNPROVIDED, EMPTY_SUBL_OBJECT_ARRAY);\n                                                }\n                                            }\n                                            if (cur_y_derivative_value.numGE($float$0_5) && cur_x_value.numL(x_value)) {\n                                                found_start_pointP = T;\n                                                inflow_start_x = cur_x_value;\n                                            }\n                                        } else {\n                                            cdestructuring_bind_error(datum_$4, $list79);\n                                        }\n                                        cur_x_y_value = cur_x_y_value.rest();\n                                        cur_x_y_value_$2 = cur_x_y_value.first();\n                                        cur_x_y_derivative_point = cur_x_y_derivative_point.rest();\n                                        cur_x_y_derivative_point_$3 = cur_x_y_derivative_point.first();\n                                    } \n                                }\n                                SubLObject found_end_pointP = NIL;\n                                if (NIL == found_end_pointP) {\n                                    SubLObject cur_x_y_value = NIL;\n                                    SubLObject cur_x_y_value_$3 = NIL;\n                                    SubLObject cur_x_y_derivative_point = NIL;\n                                    SubLObject cur_x_y_derivative_point_$4 = NIL;\n                                    cur_x_y_value = x_y_values;\n                                    cur_x_y_value_$3 = cur_x_y_value.first();\n                                    cur_x_y_derivative_point = x_y_derivative_points;\n                                    cur_x_y_derivative_point_$4 = cur_x_y_derivative_point.first();\n                                    while ((NIL == found_end_pointP) && ((NIL != cur_x_y_derivative_point) || (NIL != cur_x_y_value))) {\n                                        SubLObject current_$6;\n                                        final SubLObject datum_$5 = current_$6 = cur_x_y_derivative_point_$4;\n                                        SubLObject cur_x_value = NIL;\n                                        SubLObject cur_y_derivative_value = NIL;\n                                        destructuring_bind_must_consp(current_$6, datum_$5, $list79);\n                                        cur_x_value = current_$6.first();\n                                        current_$6 = current_$6.rest();\n                                        destructuring_bind_must_consp(current_$6, datum_$5, $list79);\n                                        cur_y_derivative_value = current_$6.first();\n                                        current_$6 = current_$6.rest();\n                                        if (NIL == current_$6) {\n                                            final SubLObject cur_y_value = second(cur_x_y_value_$3);\n                                            if (NIL != debugP) {\n                                                format_nil.force_format(T, $str80$checking_x__A_deriv__A__, cur_x_value, cur_y_derivative_value, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);\n                                                if (!cur_x_value.eql(cur_x_y_value_$3.first())) {\n                                                    print($$$Bad_looping, UNPROVIDED);\n                                                    Errors.sublisp_break(UNPROVIDED, EMPTY_SUBL_OBJECT_ARRAY);\n                                                }\n                                            }\n                                            if (cur_y_derivative_value.numLE($float$_0_5) && cur_x_value.numG(x_value)) {\n                                                found_end_pointP = T;\n                                                inflow_end_x = cur_x_value;\n                                            }\n                                        } else {\n                                            cdestructuring_bind_error(datum_$5, $list79);\n                                        }\n                                        cur_x_y_value = cur_x_y_value.rest();\n                                        cur_x_y_value_$3 = cur_x_y_value.first();\n                                        cur_x_y_derivative_point = cur_x_y_derivative_point.rest();\n                                        cur_x_y_derivative_point_$4 = cur_x_y_derivative_point.first();\n                                    } \n                                }\n                            }\n                            if ((NIL != inflow_start_x) && (NIL != inflow_end_x)) {\n                                if (NIL != debugP) {\n                                    format_nil.force_format(T, $str84$Got_interval___A__A___, inflow_start_x, inflow_end_x, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);\n                                }\n                                inflow_lengths = cons(list(inflow_start_x, inflow_end_x), inflow_lengths);\n                            }\n                        }\n                    } else {\n                        cdestructuring_bind_error(datum, $list77);\n                    }\n                    cdolist_list_var = cdolist_list_var.rest();\n                    x_y_value = cdolist_list_var.first();\n                } \n                inflow_lengths = Sort.sort(inflow_lengths, $sym47$_, FIRST);\n                if (NIL != debugP) {\n                    format_nil.force_format(T, $str86$inflow_lengths___A__, inflow_lengths, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);\n                }\n                SubLObject merged_inflow_lengths = NIL;\n                SubLObject cur_start = NIL;\n                SubLObject cur_end = NIL;\n                SubLObject cdolist_list_var2 = inflow_lengths;\n                SubLObject inflow_length2 = NIL;\n                inflow_length2 = cdolist_list_var2.first();\n                while (NIL != cdolist_list_var2) {\n                    SubLObject current2;\n                    final SubLObject datum2 = current2 = inflow_length2;\n                    SubLObject start = NIL;\n                    SubLObject end = NIL;\n                    destructuring_bind_must_consp(current2, datum2, $list87);\n                    start = current2.first();\n                    current2 = current2.rest();\n                    destructuring_bind_must_consp(current2, datum2, $list87);\n                    end = current2.first();\n                    current2 = current2.rest();\n                    if (NIL == current2) {\n                        if ((NIL != cur_start) && (NIL != cur_end)) {\n                            if (start.numLE(cur_end)) {\n                                cur_end = end;\n                            } else {\n                                merged_inflow_lengths = cons(list(cur_start, cur_end), merged_inflow_lengths);\n                                cur_start = start;\n                                cur_end = end;\n                            }\n                        } else {\n                            cur_start = start;\n                            cur_end = end;\n                        }\n                    } else {\n                        cdestructuring_bind_error(datum2, $list87);\n                    }\n                    cdolist_list_var2 = cdolist_list_var2.rest();\n                    inflow_length2 = cdolist_list_var2.first();\n                } \n                if ((NIL != cur_start) && (NIL != cur_end)) {\n                    merged_inflow_lengths = cons(list(cur_start, cur_end), merged_inflow_lengths);\n                }\n                if (NIL != debugP) {\n                    format_nil.force_format(T, $str88$merged_inflow_lengths___A__, merged_inflow_lengths, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);\n                }\n                inflow_lengths = merged_inflow_lengths;\n                SubLObject result = NIL;\n                SubLObject cdolist_list_var3 = inflow_lengths;\n                SubLObject result_inflow_length = NIL;\n                result_inflow_length = cdolist_list_var3.first();\n                while (NIL != cdolist_list_var3) {\n                    result = cons(list($$TheList, list(x_units, result_inflow_length.first()), list(x_units, subtract(second(result_inflow_length), result_inflow_length.first()))), result);\n                    cdolist_list_var3 = cdolist_list_var3.rest();\n                    result_inflow_length = cdolist_list_var3.first();\n                } \n                result = make_el_list(result, UNPROVIDED);\n                final SubLObject v_bindings = unification_utilities.term_unify(result, length_and_depths_query, UNPROVIDED, UNPROVIDED);\n                if (NIL != v_bindings) {\n                    backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings, asent), UNPROVIDED, UNPROVIDED), v_bindings, UNPROVIDED);\n                }\n            }\n        }\n        return NIL;\n    }\n    public static SubLObject declare_removal_modules_math_file() {\n        declareFunction(\"removal_interpolation_with_cubic_spline_expand\", \"REMOVAL-INTERPOLATION-WITH-CUBIC-SPLINE-EXPAND\", 1, 1, false);\n        declareFunction(\"removal_interpolation_with_piecewise_linear_polynomial_expand\", \"REMOVAL-INTERPOLATION-WITH-PIECEWISE-LINEAR-POLYNOMIAL-EXPAND\", 1, 1, false);\n        declareFunction(\"removal_extrapolation_with_simple_linear_regression_expand\", \"REMOVAL-EXTRAPOLATION-WITH-SIMPLE-LINEAR-REGRESSION-EXPAND\", 1, 1, false);\n        declareFunction(\"removal_interpolation_or_extrapolation_with_java_link_function_expand_helper\", \"REMOVAL-INTERPOLATION-OR-EXTRAPOLATION-WITH-JAVA-LINK-FUNCTION-EXPAND-HELPER\", 2, 0, false);\n        declareFunction(\"removal_extrapolation_with_simple_linear_regression_with_error_bars_expand\", \"REMOVAL-EXTRAPOLATION-WITH-SIMPLE-LINEAR-REGRESSION-WITH-ERROR-BARS-EXPAND\", 1, 1, false);\n        declareFunction(\"removal_interpolation_or_extrapolation_with_error_bars_with_java_link_function_expand_helper\", \"REMOVAL-INTERPOLATION-OR-EXTRAPOLATION-WITH-ERROR-BARS-WITH-JAVA-LINK-FUNCTION-EXPAND-HELPER\", 2, 0, false);\n        declareFunction(\"removal_regression_lines_for_sets_intersect_at_point_expand\", \"REMOVAL-REGRESSION-LINES-FOR-SETS-INTERSECT-AT-POINT-EXPAND\", 1, 1, false);\n        declareFunction(\"removal_slope_of_regression_line_for_set_of_points_expand\", \"REMOVAL-SLOPE-OF-REGRESSION-LINE-FOR-SET-OF-POINTS-EXPAND\", 1, 1, false);\n        declareFunction(\"removal_set_of_first_derivative_points_based_on_set_of_points_expand\", \"REMOVAL-SET-OF-FIRST-DERIVATIVE-POINTS-BASED-ON-SET-OF-POINTS-EXPAND\", 1, 1, false);\n        declareFunction(\"removal_set_has_points_with_y_value_reln_to_matching_x_value_points_in_set_expand\", \"REMOVAL-SET-HAS-POINTS-WITH-Y-VALUE-RELN-TO-MATCHING-X-VALUE-POINTS-IN-SET-EXPAND\", 1, 1, false);\n        declareFunction(\"java_link_debug_modeP\", \"JAVA-LINK-DEBUG-MODE?\", 0, 0, false);\n        declareFunction(\"java_link_slope_and_intercept_of_x_y_regression\", \"JAVA-LINK-SLOPE-AND-INTERCEPT-OF-X-Y-REGRESSION\", 1, 0, false);\n        declareFunction(\"java_link_x_y_cubic_spline_find_y_for_x\", \"JAVA-LINK-X-Y-CUBIC-SPLINE-FIND-Y-FOR-X\", 2, 0, false);\n        declareFunction(\"java_link_x_y_piecewise_linear_find_y_for_x\", \"JAVA-LINK-X-Y-PIECEWISE-LINEAR-FIND-Y-FOR-X\", 2, 0, false);\n        declareFunction(\"java_link_x_y_regression_find_y_for_x\", \"JAVA-LINK-X-Y-REGRESSION-FIND-Y-FOR-X\", 2, 0, false);\n        declareFunction(\"java_link_x_y_regression_find_y_for_x_with_error_bars\", \"JAVA-LINK-X-Y-REGRESSION-FIND-Y-FOR-X-WITH-ERROR-BARS\", 2, 0, false);\n        declareFunction(\"java_link_point_intersection_of_two_x_y_regressions\", \"JAVA-LINK-POINT-INTERSECTION-OF-TWO-X-Y-REGRESSIONS\", 2, 0, false);\n        declareFunction(\"java_link_x_y_derivatives_for_interpolation_at_each_x\", \"JAVA-LINK-X-Y-DERIVATIVES-FOR-INTERPOLATION-AT-EACH-X\", 2, 0, false);\n        declareFunction(\"el_2d_point_p\", \"EL-2D-POINT-P\", 1, 0, false);\n        declareFunction(\"explode_2d_points_with_units\", \"EXPLODE-2D-POINTS-WITH-UNITS\", 1, 2, false);\n        declareFunction(\"removal_set_has_points_with_y_value_reln_to_expand\", \"REMOVAL-SET-HAS-POINTS-WITH-Y-VALUE-RELN-TO-EXPAND\", 1, 1, false);\n        declareFunction(\"removal_operation_result_comparison_pos_check\", \"REMOVAL-OPERATION-RESULT-COMPARISON-POS-CHECK\", 1, 1, false);\n        declareFunction(\"removal_operation_result_comparison_neg_check\", \"REMOVAL-OPERATION-RESULT-COMPARISON-NEG-CHECK\", 1, 1, false);\n        declareFunction(\"removal_inflow_lengths_with_starting_depths_expand\", \"REMOVAL-INFLOW-LENGTHS-WITH-STARTING-DEPTHS-EXPAND\", 1, 1, false);\n        return NIL;\n    }\n    public static SubLObject init_removal_modules_math_file() {\n        defparameter(\"*DEFAULT-MATH-MODULE-COST*\", $typical_hl_module_check_cost$.getGlobalValue());\n        return NIL;\n    }\n    public static SubLObject setup_removal_modules_math_file() {\n        inference_modules.register_solely_specific_removal_module_predicate($$interpolationWithCubicSpline);\n        preference_modules.doomed_unless_arg_bindable($POS, $$interpolationWithCubicSpline, ONE_INTEGER);\n        inference_modules.inference_removal_module($REMOVAL_INTERPOLATION_WITH_CUBIC_SPLINE, $list3);\n        inference_modules.register_solely_specific_removal_module_predicate($const5$interpolationWithPiecewiseLinearP);\n        preference_modules.doomed_unless_arg_bindable($POS, $const5$interpolationWithPiecewiseLinearP, ONE_INTEGER);\n        inference_modules.inference_removal_module($REMOVAL_INTERPOLATION_WITH_PIECEWISE_LINEAR_POLYNOMIAL, $list7);\n        inference_modules.register_solely_specific_removal_module_predicate($const9$extrapolationWithSimpleLinearRegr);\n        preference_modules.doomed_unless_arg_bindable($POS, $const9$extrapolationWithSimpleLinearRegr, ONE_INTEGER);\n        inference_modules.inference_removal_module($REMOVAL_EXTRAPOLATION_WITH_SIMPLE_LINEAR_REGRESSION, $list11);\n        inference_modules.register_solely_specific_removal_module_predicate($const17$extrapolationWithSimpleLinearRegr);\n        preference_modules.doomed_unless_arg_bindable($POS, $const17$extrapolationWithSimpleLinearRegr, ONE_INTEGER);\n        inference_modules.inference_removal_module($kw18$REMOVAL_EXTRAPOLATION_WITH_SIMPLE_LINEAR_REGRESSION_WITH_ERROR_BA, $list19);\n        inference_modules.register_solely_specific_removal_module_predicate($const21$regressionLinesForSetsIntersectAt);\n        preference_modules.doomed_unless_arg_bindable($POS, $const21$regressionLinesForSetsIntersectAt, ONE_INTEGER);\n        preference_modules.doomed_unless_arg_bindable($POS, $const21$regressionLinesForSetsIntersectAt, TWO_INTEGER);\n        inference_modules.inference_removal_module($REMOVAL_REGRESSION_LINES_FOR_SETS_INTERSECT_AT_POINT, $list23);\n        inference_modules.register_solely_specific_removal_module_predicate($const25$slopeOfRegressionLineForSetOfPoin);\n        preference_modules.doomed_unless_arg_bindable($POS, $const25$slopeOfRegressionLineForSetOfPoin, ONE_INTEGER);\n        inference_modules.inference_removal_module($REMOVAL_SLOPE_OF_REGRESSION_LINE_FOR_SET_OF_POINTS, $list27);\n        inference_modules.register_solely_specific_removal_module_predicate($const28$setOfFirstDerivativePointsBasedOn);\n        preference_modules.doomed_unless_arg_bindable($POS, $const28$setOfFirstDerivativePointsBasedOn, ONE_INTEGER);\n        preference_modules.doomed_unless_arg_bindable($POS, $const28$setOfFirstDerivativePointsBasedOn, TWO_INTEGER);\n        inference_modules.inference_removal_module($REMOVAL_SET_OF_FIRST_DERIVATIVE_POINTS_BASED_ON_SET_OF_POINTS, $list30);\n        inference_modules.register_solely_specific_removal_module_predicate($const31$setHasPointsWithYValueRelnToMatch);\n        preference_modules.doomed_unless_arg_bindable($POS, $const31$setHasPointsWithYValueRelnToMatch, ONE_INTEGER);\n        preference_modules.doomed_unless_arg_bindable($POS, $const31$setHasPointsWithYValueRelnToMatch, TWO_INTEGER);\n        preference_modules.doomed_unless_arg_bindable($POS, $const31$setHasPointsWithYValueRelnToMatch, THREE_INTEGER);\n        preference_modules.doomed_unless_arg_bindable($POS, $const31$setHasPointsWithYValueRelnToMatch, FOUR_INTEGER);\n        preference_modules.doomed_unless_arg_bindable($POS, $const31$setHasPointsWithYValueRelnToMatch, FIVE_INTEGER);\n        inference_modules.inference_removal_module($kw32$REMOVAL_SET_HAS_POINTS_WITH_Y_VALUE_RELN_TO_MATCHING_X_VALUE_POIN, $list33);\n        inference_modules.register_solely_specific_removal_module_predicate($$setHasPointsWithYValueRelnTo);\n        preference_modules.doomed_unless_arg_bindable($POS, $$setHasPointsWithYValueRelnTo, ONE_INTEGER);\n        preference_modules.doomed_unless_arg_bindable($POS, $$setHasPointsWithYValueRelnTo, TWO_INTEGER);\n        preference_modules.doomed_unless_arg_bindable($POS, $$setHasPointsWithYValueRelnTo, THREE_INTEGER);\n        preference_modules.doomed_unless_arg_bindable($POS, $$setHasPointsWithYValueRelnTo, FOUR_INTEGER);\n        preference_modules.doomed_unless_arg_bindable($POS, $$setHasPointsWithYValueRelnTo, FIVE_INTEGER);\n        inference_modules.inference_removal_module($REMOVAL_SET_HAS_POINTS_WITH_Y_VALUE_RELN_TO, $list64);\n        inference_modules.register_solely_specific_removal_module_predicate($$operationResultComparison);\n        preference_modules.doomed_unless_all_args_bindable($POS, $$operationResultComparison);\n        preference_modules.doomed_unless_all_args_bindable($NEG, $$operationResultComparison);\n        inference_modules.inference_removal_module($REMOVAL_OPERATION_RESULT_COMPARISON_POS_CHECK, $list68);\n        inference_modules.inference_removal_module($REMOVAL_OPERATION_RESULT_COMPARISON_NEG_CHECK, $list70);\n        inference_modules.register_solely_specific_removal_module_predicate($$inflowLengthsWithStartingDepths);\n        preference_modules.doomed_unless_arg_bindable($POS, $$inflowLengthsWithStartingDepths, ONE_INTEGER);\n        preference_modules.doomed_unless_arg_bindable($POS, $$inflowLengthsWithStartingDepths, TWO_INTEGER);\n        inference_modules.inference_removal_module($REMOVAL_INFLOW_LENGTHS_WITH_STARTING_DEPTHS, $list73);\n        return NIL;\n    }\n    @Override\n    public void declareFunctions() {\n        declare_removal_modules_math_file();\n    }\n    @Override\n    public void initializeVariables() {\n        init_removal_modules_math_file();\n    }\n    @Override\n    public void runTopLevelForms() {\n        setup_removal_modules_math_file();\n    }\n    static {\n    }\n"]]}
{"hexsha": "27c19a8b98a2afd14fb5b64546922426840a082e", "ext": "java", "lang": "Java", "content": "public class PayUtils {\n\n\t/**\u91c7\u7528Rsa\u52a0\u5bc6\u7b97\u6cd5*/\n\tprivate static final String ALGORITHM = \"RSA\";\n\n\t/**\n\t * @param algorithm\n\t * @param ins\n\t * @return\n\t * @throws NoSuchAlgorithmException\n\t * @throws AlipayException\n\t */\n\tprivate static PublicKey getPublicKeyFromX509(String algorithm, String bysKey) throws Exception {\n\t\tbyte[] decodedKey = Base64.decode(bysKey);\n\t\tX509EncodedKeySpec x509 = new X509EncodedKeySpec(decodedKey);\n\n\t\tKeyFactory keyFactory = KeyFactory.getInstance(algorithm);\n\t\treturn keyFactory.generatePublic(x509);\n\t}\n\n\tpublic static String encrypt(String content, String key) {\n\t\ttry {\n\t\t\tPublicKey pubkey = getPublicKeyFromX509(ALGORITHM, key);\n\n\t\t\tCipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n\t\t\tcipher.init(Cipher.ENCRYPT_MODE, pubkey);\n\n\t\t\tbyte plaintext[] = content.getBytes(\"UTF-8\");\n\t\t\tbyte[] output = cipher.doFinal(plaintext);\n\n\t\t\tString s = new String(Base64.encode(output));\n\n\t\t\treturn s;\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static final String SIGN_ALGORITHMS = \"SHA1WithRSA\";\n\n\tpublic static String sign(String content, String privateKey) {\n\t\tString charset = \"UTF-8\";\n\t\ttry {\n\t\t\tPKCS8EncodedKeySpec priPKCS8 = new PKCS8EncodedKeySpec(\n\t\t\t\tBase64.decode(privateKey));\n\t\t\tKeyFactory keyf = KeyFactory.getInstance(ALGORITHM);\n\t\t\tPrivateKey priKey = keyf.generatePrivate(priPKCS8);\n\n\t\t\tSignature signature = Signature\n\t\t\t\t.getInstance(SIGN_ALGORITHMS);\n\n\t\t\tsignature.initSign(priKey);\n\t\t\tsignature.update(content.getBytes(charset));\n\n\t\t\tbyte[] signed = signature.sign();\n\n\t\t\treturn Base64.encode(signed);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic static String getMD5(String content) {\n\t\tString s = null;\n\t\tchar hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n\t\ttry {\n\t\t\tMessageDigest md = MessageDigest.getInstance(\"MD5\");\n\t\t\tmd.update(content.getBytes());\n\t\t\tbyte tmp[] = md.digest();\n\t\t\tchar str[] = new char[16 * 2];\n\t\t\tint k = 0;\n\t\t\tfor (int i = 0; i < 16; i++) {\n\t\t\t\tbyte byte0 = tmp[i];\n\t\t\t\tstr[k++] = hexDigits[byte0 >>> 4 & 0xf];\n\t\t\t\tstr[k++] = hexDigits[byte0 & 0xf];\n\t\t\t}\n\t\t\ts = new String(str);\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn s;\n\t}\n\n\tpublic static boolean doCheck(String content, String sign, String publicKey) {\n\t\ttry {\n\t\t\tKeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n\t\t\tbyte[] encodedKey = Base64.decode(publicKey);\n\t\t\tPublicKey pubKey = keyFactory.generatePublic(new X509EncodedKeySpec(encodedKey));\n\n\t\t\tSignature signature = Signature.getInstance(SIGN_ALGORITHMS);\n\n\t\t\tsignature.initVerify(pubKey);\n\t\t\tsignature.update(content.getBytes(\"utf-8\"));\n\t\t\tLog.i(\"Result\", \"content :   \" + content);\n\t\t\tLog.i(\"Result\", \"sign:   \" + sign);\n\t\t\tboolean bverify = signature.verify(Base64.decode(sign));\n\t\t\tLog.i(\"Result\", \"bverify = \" + bverify);\n\t\t\treturn bverify;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic static String sha1(String str) {\n\t\tif (str == null || str.length() == 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tchar hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n\n\t\ttry {\n\t\t\tMessageDigest mdTemp = MessageDigest.getInstance(\"SHA1\");\n\t\t\tmdTemp.update(str.getBytes());\n\n\t\t\tbyte[] md = mdTemp.digest();\n\t\t\tint j = md.length;\n\t\t\tchar buf[] = new char[j * 2];\n\t\t\tint k = 0;\n\t\t\tfor (int i = 0; i < j; i++) {\n\t\t\t\tbyte byte0 = md[i];\n\t\t\t\tbuf[k++] = hexDigits[byte0 >>> 4 & 0xf];\n\t\t\t\tbuf[k++] = hexDigits[byte0 & 0xf];\n\t\t\t}\n\t\t\treturn new String(buf);\n\t\t} catch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n}", "class_id": 0, "repo": "a289459798/-ichong-react-native-pay", "file": "android/src/main/java/com/zzy/pay/module/utils/PayUtils.java", "last_update_at": "2020-03-08T10:46:15+00:00", "question_id": "27c19a8b98a2afd14fb5b64546922426840a082e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PayUtils {\n\t/**\u91c7\u7528Rsa\u52a0\u5bc6\u7b97\u6cd5*/\n\tprivate static final String ALGORITHM = \"RSA\";\n\t/**\n\t * @param algorithm\n\t * @param ins\n\t * @return\n\t * @throws NoSuchAlgorithmException\n\t * @throws AlipayException\n\t */\n\tprivate static PublicKey getPublicKeyFromX509(String algorithm, String bysKey) throws Exception {\n\t\tbyte[] decodedKey = Base64.decode(bysKey);\n\t\tX509EncodedKeySpec x509 = new X509EncodedKeySpec(decodedKey);\n\t\tKeyFactory keyFactory = KeyFactory.getInstance(algorithm);\n\t\treturn keyFactory.generatePublic(x509);\n\t}\n\tpublic static String encrypt(String content, String key) {\n\t\ttry {\n\t\t\tPublicKey pubkey = getPublicKeyFromX509(ALGORITHM, key);\n\t\t\tCipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n\t\t\tcipher.init(Cipher.ENCRYPT_MODE, pubkey);\n\t\t\tbyte plaintext[] = content.getBytes(\"UTF-8\");\n\t\t\tbyte[] output = cipher.doFinal(plaintext);\n\t\t\tString s = new String(Base64.encode(output));\n\t\t\treturn s;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n\tpublic static final String SIGN_ALGORITHMS = \"SHA1WithRSA\";\n\tpublic static String sign(String content, String privateKey) {\n\t\tString charset = \"UTF-8\";\n\t\ttry {\n\t\t\tPKCS8EncodedKeySpec priPKCS8 = new PKCS8EncodedKeySpec(\n\t\t\t\tBase64.decode(privateKey));\n\t\t\tKeyFactory keyf = KeyFactory.getInstance(ALGORITHM);\n\t\t\tPrivateKey priKey = keyf.generatePrivate(priPKCS8);\n\t\t\tSignature signature = Signature\n\t\t\t\t.getInstance(SIGN_ALGORITHMS);\n\t\t\tsignature.initSign(priKey);\n\t\t\tsignature.update(content.getBytes(charset));\n\t\t\tbyte[] signed = signature.sign();\n\t\t\treturn Base64.encode(signed);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\tpublic static String getMD5(String content) {\n\t\tString s = null;\n\t\tchar hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n\t\ttry {\n\t\t\tMessageDigest md = MessageDigest.getInstance(\"MD5\");\n\t\t\tmd.update(content.getBytes());\n\t\t\tbyte tmp[] = md.digest();\n\t\t\tchar str[] = new char[16 * 2];\n\t\t\tint k = 0;\n\t\t\tfor (int i = 0; i < 16; i++) {\n\t\t\t\tbyte byte0 = tmp[i];\n\t\t\t\tstr[k++] = hexDigits[byte0 >>> 4 & 0xf];\n\t\t\t\tstr[k++] = hexDigits[byte0 & 0xf];\n\t\t\t}\n\t\t\ts = new String(str);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic static boolean doCheck(String content, String sign, String publicKey) {\n\t\ttry {\n\t\t\tKeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n\t\t\tbyte[] encodedKey = Base64.decode(publicKey);\n\t\t\tPublicKey pubKey = keyFactory.generatePublic(new X509EncodedKeySpec(encodedKey));\n\t\t\tSignature signature = Signature.getInstance(SIGN_ALGORITHMS);\n\t\t\tsignature.initVerify(pubKey);\n\t\t\tsignature.update(content.getBytes(\"utf-8\"));\n\t\t\tLog.i(\"Result\", \"content :   \" + content);\n\t\t\tLog.i(\"Result\", \"sign:   \" + sign);\n\t\t\tboolean bverify = signature.verify(Base64.decode(sign));\n\t\t\tLog.i(\"Result\", \"bverify = \" + bverify);\n\t\t\treturn bverify;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static String sha1(String str) {\n\t\tif (str == null || str.length() == 0) {\n\t\t\treturn null;\n\t\t}\n\t\tchar hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n\t\ttry {\n\t\t\tMessageDigest mdTemp = MessageDigest.getInstance(\"SHA1\");\n\t\t\tmdTemp.update(str.getBytes());\n\t\t\tbyte[] md = mdTemp.digest();\n\t\t\tint j = md.length;\n\t\t\tchar buf[] = new char[j * 2];\n\t\t\tint k = 0;\n\t\t\tfor (int i = 0; i < j; i++) {\n\t\t\t\tbyte byte0 = md[i];\n\t\t\t\tbuf[k++] = hexDigits[byte0 >>> 4 & 0xf];\n\t\t\t\tbuf[k++] = hexDigits[byte0 & 0xf];\n\t\t\t}\n\t\t\treturn new String(buf);\n\t\t} catch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t}\n"]]}
{"hexsha": "f755bec2228838a4e6a0ea76cc6ea865736e182a", "ext": "java", "lang": "Java", "content": "public class SecurityInterceptors {\n\n\tpublic void basicAuthInterceptorRealm() {\n\t\t//START SNIPPET: basicAuthInterceptorRealm\n\t\tAuthenticationException ex = new AuthenticationException();\n\t\tex.addAuthenticateHeaderForRealm(\"myRealm\");\n\t\tthrow ex;\n\t\t//END SNIPPET: basicAuthInterceptorRealm\n\t}\n\n\t// START SNIPPET: basicAuthInterceptor\n\t@Interceptor\n\tpublic class BasicSecurityInterceptor {\n\n\t\t/**\n\t\t * This interceptor implements HTTP Basic Auth, which specifies that\n\t\t * a username and password are provided in a header called Authorization.\n\t\t */\n\t\t@Hook(Pointcut.SERVER_INCOMING_REQUEST_POST_PROCESSED)\n\t\tpublic boolean incomingRequestPostProcessed(RequestDetails theRequestDetails, HttpServletRequest theRequest, HttpServletResponse theResponse) throws AuthenticationException {\n\t\t\tString authHeader = theRequest.getHeader(\"Authorization\");\n\n\t\t\t// The format of the header must be:\n\t\t\t// Authorization: Basic [base64 of username:password]\n\t\t\tif (authHeader == null || authHeader.startsWith(\"Basic \") == false) {\n\t\t\t\tthrow new AuthenticationException(\"Missing or invalid Authorization header\");\n\t\t\t}\n\n\t\t\tString base64 = authHeader.substring(\"Basic \".length());\n\t\t\tString base64decoded = new String(Base64.decodeBase64(base64));\n\t\t\tString[] parts = base64decoded.split(\":\");\n\n\t\t\tString username = parts[0];\n\t\t\tString password = parts[1];\n\n\t\t\t/*\n\t\t\t * Here we test for a hardcoded username & password. This is\n\t\t\t * not typically how you would implement this in a production\n\t\t\t * system of course..\n\t\t\t */\n\t\t\tif (!username.equals(\"someuser\") || !password.equals(\"thepassword\")) {\n\t\t\t\tthrow new AuthenticationException(\"Invalid username or password\");\n\t\t\t}\n\n\t\t\t// Return true to allow the request to proceed\n\t\t\treturn true;\n\t\t}\n\n\n\t}\n\t//END SNIPPET: basicAuthInterceptor\n\n}", "class_id": 0, "repo": "gematik-fue/hapi-fhir", "file": "hapi-fhir-docs/src/main/java/ca/uhn/hapi/fhir/docs/SecurityInterceptors.java", "last_update_at": "2020-03-19T15:44:54+00:00", "question_id": "f755bec2228838a4e6a0ea76cc6ea865736e182a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SecurityInterceptors {\n\tpublic void basicAuthInterceptorRealm() {\n\t\t//START SNIPPET: basicAuthInterceptorRealm\n\t\tAuthenticationException ex = new AuthenticationException();\n\t\tex.addAuthenticateHeaderForRealm(\"myRealm\");\n\t\tthrow ex;\n\t\t//END SNIPPET: basicAuthInterceptorRealm\n\t}\n\t// START SNIPPET: basicAuthInterceptor\n\t@Interceptor\n\tpublic class BasicSecurityInterceptor {\n\t\t/**\n\t\t * This interceptor implements HTTP Basic Auth, which specifies that\n\t\t * a username and password are provided in a header called Authorization.\n\t\t */\n\t\t@Hook(Pointcut.SERVER_INCOMING_REQUEST_POST_PROCESSED)\n\t\tpublic boolean incomingRequestPostProcessed(RequestDetails theRequestDetails, HttpServletRequest theRequest, HttpServletResponse theResponse) throws AuthenticationException {\n\t\t\tString authHeader = theRequest.getHeader(\"Authorization\");\n\t\t\t// The format of the header must be:\n\t\t\t// Authorization: Basic [base64 of username:password]\n\t\t\tif (authHeader == null || authHeader.startsWith(\"Basic \") == false) {\n\t\t\t\tthrow new AuthenticationException(\"Missing or invalid Authorization header\");\n\t\t\t}\n\t\t\tString base64 = authHeader.substring(\"Basic \".length());\n\t\t\tString base64decoded = new String(Base64.decodeBase64(base64));\n\t\t\tString[] parts = base64decoded.split(\":\");\n\t\t\tString username = parts[0];\n\t\t\tString password = parts[1];\n\t\t\t/*\n\t\t\t * Here we test for a hardcoded username & password. This is\n\t\t\t * not typically how you would implement this in a production\n\t\t\t * system of course..\n\t\t\t */\n\t\t\tif (!username.equals(\"someuser\") || !password.equals(\"thepassword\")) {\n\t\t\t\tthrow new AuthenticationException(\"Invalid username or password\");\n\t\t\t}\n\t\t\t// Return true to allow the request to proceed\n\t\t\treturn true;\n\t\t}\n\t}\n\t//END SNIPPET: basicAuthInterceptor\n"]]}
{"hexsha": "f81709dc48a9db40884f3f6849eae3e428b9a913", "ext": "java", "lang": "Java", "content": "public class MapFragmentActivity extends AppCompatActivity implements MapFragment.OnMapViewReadyCallback,\n  OnMapReadyCallback, MapView.OnDidFinishRenderingFrameListener {\n\n  private static final String TAG = \"com.mapbox.map\";\n  private MapboxMap mapboxMap;\n  private MapView mapView;\n  private boolean initialCameraAnimation = true;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_map_fragment);\n\n    MapFragment mapFragment;\n    if (savedInstanceState == null) {\n      mapFragment = MapFragment.newInstance(createFragmentOptions());\n      getFragmentManager()\n        .beginTransaction()\n        .add(R.id.fragment_container, mapFragment, TAG)\n        .commit();\n    } else {\n      mapFragment = (MapFragment) getFragmentManager().findFragmentByTag(TAG);\n    }\n    mapFragment.getMapAsync(this);\n  }\n\n  private MapboxMapOptions createFragmentOptions() {\n    MapboxMapOptions options = MapboxMapOptions.createFromAttributes(this, null);\n\n    options.scrollGesturesEnabled(false);\n    options.zoomGesturesEnabled(false);\n    options.tiltGesturesEnabled(false);\n    options.rotateGesturesEnabled(false);\n    options.debugActive(false);\n\n    LatLng dc = new LatLng(38.90252, -77.02291);\n\n    options.minZoomPreference(9);\n    options.maxZoomPreference(11);\n    options.camera(new CameraPosition.Builder()\n      .target(dc)\n      .zoom(11)\n      .build());\n    return options;\n  }\n\n  @Override\n  public void onMapViewReady(MapView map) {\n    mapView = map;\n    mapView.addOnDidFinishRenderingFrameListener(this);\n  }\n\n  @Override\n  public void onMapReady(@NonNull MapboxMap map) {\n    mapboxMap = map;\n    mapboxMap.setStyle(Style.OUTDOORS);\n  }\n\n  @Override\n  protected void onDestroy() {\n    super.onDestroy();\n    if (mapView != null) {\n      mapView.removeOnDidFinishRenderingFrameListener(this);\n    }\n  }\n\n  @Override\n  public void onDidFinishRenderingFrame(boolean fully) {\n    if (initialCameraAnimation && fully && mapboxMap != null) {\n      mapboxMap.animateCamera(\n        CameraUpdateFactory.newCameraPosition(new CameraPosition.Builder().tilt(45.0).build()), 5000);\n      initialCameraAnimation = false;\n    }\n  }\n}", "class_id": 0, "repo": "petr-pokorny-1/maplibre-gl-native", "file": "platform/android/MapboxGLAndroidSDKTestApp/src/main/java/com/mapbox/mapboxsdk/testapp/activity/fragment/MapFragmentActivity.java", "last_update_at": "2020-12-06T09:14:58+00:00", "question_id": "f81709dc48a9db40884f3f6849eae3e428b9a913", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MapFragmentActivity extends AppCompatActivity implements MapFragment.OnMapViewReadyCallback,\n  OnMapReadyCallback, MapView.OnDidFinishRenderingFrameListener {\n  private static final String TAG = \"com.mapbox.map\";\n  private MapboxMap mapboxMap;\n  private MapView mapView;\n  private boolean initialCameraAnimation = true;\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_map_fragment);\n    MapFragment mapFragment;\n    if (savedInstanceState == null) {\n      mapFragment = MapFragment.newInstance(createFragmentOptions());\n      getFragmentManager()\n        .beginTransaction()\n        .add(R.id.fragment_container, mapFragment, TAG)\n        .commit();\n    } else {\n      mapFragment = (MapFragment) getFragmentManager().findFragmentByTag(TAG);\n    }\n    mapFragment.getMapAsync(this);\n  }\n  private MapboxMapOptions createFragmentOptions() {\n    MapboxMapOptions options = MapboxMapOptions.createFromAttributes(this, null);\n    options.scrollGesturesEnabled(false);\n    options.zoomGesturesEnabled(false);\n    options.tiltGesturesEnabled(false);\n    options.rotateGesturesEnabled(false);\n    options.debugActive(false);\n    LatLng dc = new LatLng(38.90252, -77.02291);\n    options.minZoomPreference(9);\n    options.maxZoomPreference(11);\n    options.camera(new CameraPosition.Builder()\n      .target(dc)\n      .zoom(11)\n      .build());\n    return options;\n  }\n  @Override\n  public void onMapViewReady(MapView map) {\n    mapView = map;\n    mapView.addOnDidFinishRenderingFrameListener(this);\n  }\n  @Override\n  public void onMapReady(@NonNull MapboxMap map) {\n    mapboxMap = map;\n    mapboxMap.setStyle(Style.OUTDOORS);\n  }\n  @Override\n  protected void onDestroy() {\n    super.onDestroy();\n    if (mapView != null) {\n      mapView.removeOnDidFinishRenderingFrameListener(this);\n    }\n  }\n  @Override\n  public void onDidFinishRenderingFrame(boolean fully) {\n    if (initialCameraAnimation && fully && mapboxMap != null) {\n      mapboxMap.animateCamera(\n        CameraUpdateFactory.newCameraPosition(new CameraPosition.Builder().tilt(45.0).build()), 5000);\n      initialCameraAnimation = false;\n    }\n  }\n"]]}
{"hexsha": "99b3c76c2f7d629c97dde8e792ded6dca90385b3", "ext": "java", "lang": "Java", "content": "public class AtendimentoDAO implements Serializable {\r\n\r\n\tprivate static final long serialVersionUID = 1L;\r\n\r\n\t@Inject\r\n\tprivate EntityManager manager;\r\n\t\r\n\t@Inject\r\n\tprivate ConvenioDAO conDao;\r\n\r\n\tpublic Atendimento porId(Long id) {\r\n\t\tAtendimento atendimento = manager.find(Atendimento.class, id);\r\n\t\tatendimento.getConvenio().setValores(conDao.valores(atendimento.getConvenio()));\r\n\t\treturn atendimento;\r\n\t}\r\n\r\n\t@Transacional\r\n\tpublic Atendimento salvar(Atendimento atendimento) {\r\n\t\t/*Atendimento atend = manager.merge(atendimento);\r\n\t\tif(atend.getPagamentos()!=null && atend.getPagamentos().size()!=0) {\r\n\t\t\tfor(Pagamento pag :atend.getPagamentos()) {\r\n\t\t\t\tmanager.merge(pag);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn atend;\r\n\t\t*/\r\n\t\treturn manager.merge(atendimento);\r\n\t}\r\n\r\n\t@Transacional\r\n\tpublic void remover(Atendimento atendimento) {\r\n\t\ttry {\r\n\r\n\t\t\t// TODO verificar se existe consultas com este atendimento\r\n\r\n\t\t\tatendimento = porId(atendimento.getId());\r\n\t\t\tmanager.remove(atendimento);\r\n\t\t\tmanager.flush();\r\n\t\t} catch (PersistenceException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\t\r\n\t@Transacional\r\n\tpublic Atendimento cancelar(Atendimento atendimento){\r\n\t\t\tif(atendimento.isCancelado()) {\r\n\t\t\t\tthrow new NegocioException(\"Este atendimento j\u00e1 est\u00e1 Cancelado!\");\r\n\t\t\t}\r\n\t\t\tif(atendimento.isFinalizado()) {\r\n\t\t\t\tthrow new NegocioException(\"Este atendimento j\u00e1 foi Finalizado!\");\r\n\t\t\t}\r\n\t\t\tatendimento = this.salvar(atendimento);\r\n\t\t\tatendimento.setStatus(StatusAtendimento.CANCELADO);\r\n\t\t\tatendimento = this.salvar(atendimento);\r\n\t\t\treturn atendimento;\r\n\t\t\r\n\t}\r\n\t\r\n\t@Transacional\r\n\tpublic Atendimento finalizar(Atendimento atendimento){\r\n\t\t\tif(atendimento.isCancelado()) {\r\n\t\t\t\tthrow new NegocioException(\"Este atendimento j\u00e1 est\u00e1 Cancelado!\");\r\n\t\t\t}\r\n\t\t\tif(atendimento.isFinalizado()) {\r\n\t\t\t\tthrow new NegocioException(\"Este atendimento j\u00e1 foi Finalizado!\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(atendimento.isFinalizavel()) {\r\n\t\t\t\tatendimento = this.salvar(atendimento);\r\n\t\t\t\tatendimento.setStatus(StatusAtendimento.FINALIZADO);\r\n\t\t\t\tatendimento = this.salvar(atendimento);\r\n\t\t\t\treturn atendimento;\r\n\t\t\t}else\r\n\t\t\t\tthrow new NegocioException(\"Este atendimento n\u00e3o pode ser Finalizado!\");\r\n\t}\r\n\r\n\tpublic List<Atendimento> todos() {\r\n\r\n\t\treturn manager.createQuery(\"from Atendimento\", Atendimento.class).getResultList();\r\n\t}\r\n\t\r\n\tpublic List<Atendimento> atendimentosDoDia() throws Exception{\r\n\t\tDate d1 = new Date();\r\n\t\td1.setHours(0);\r\n\t\td1.setMinutes(0);\r\n\t\td1.setSeconds(0);\r\n\t\tDate d2 = new Date();\r\n\t\td2.setHours(23);\r\n\t\td2.setMinutes(59);\r\n\t\td2.setSeconds(59);\r\n\t\t\r\n\t\tSimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n\t\tString inicio = format.format(d1);\r\n\t\tString fim = format.format(d2);\r\n\t\td1 = format.parse(inicio);\r\n\t\td2 = format.parse(fim);\r\n\t\t\r\n\t\tQuery query = manager.createQuery(\"select a from Atendimento a where a.data >= :d1 and a.data <= :d2\", Atendimento.class);\r\n\t\tquery.setParameter(\"d1\", d1);\r\n\t\tquery.setParameter(\"d2\", d2);\r\n\t\t\r\n\t\treturn query.getResultList();\r\n\t\t\r\n\t}\r\n\r\n}", "class_id": 0, "repo": "wagner000/uniclic", "file": "sistemaclinica/src/main/java/com/sistemaclinica/repository/AtendimentoDAO.java", "last_update_at": "2020-09-09T19:13:48+00:00", "question_id": "99b3c76c2f7d629c97dde8e792ded6dca90385b3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AtendimentoDAO implements Serializable {\r\n\r\n\tprivate static final long serialVersionUID = 1L;\r\n\r\n\t@Inject\r\n\tprivate EntityManager manager;\r\n\t\r\n\t@Inject\r\n\tprivate ConvenioDAO conDao;\r\n\r\n\tpublic Atendimento porId(Long id) {\r\n\t\tAtendimento atendimento = manager.find(Atendimento.class, id);\r\n\t\tatendimento.getConvenio().setValores(conDao.valores(atendimento.getConvenio()));\r\n\t\treturn atendimento;\r\n\t}\r\n\r\n\t@Transacional\r\n\tpublic Atendimento salvar(Atendimento atendimento) {\r\n\t\t/*Atendimento atend = manager.merge(atendimento);\r\n\t\tif(atend.getPagamentos()!=null && atend.getPagamentos().size()!=0) {\r\n\t\t\tfor(Pagamento pag :atend.getPagamentos()) {\r\n\t\t\t\tmanager.merge(pag);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn atend;\r\n\t\t*/\r\n\t\treturn manager.merge(atendimento);\r\n\t}\r\n\r\n\t@Transacional\r\n\tpublic void remover(Atendimento atendimento) {\r\n\t\ttry {\r\n\r\n\t\t\t// TODO verificar se existe consultas com este atendimento\r\n\r\n\t\t\tatendimento = porId(atendimento.getId());\r\n\t\t\tmanager.remove(atendimento);\r\n\t\t\tmanager.flush();\r\n\t\t} catch (PersistenceException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\t\r\n\t@Transacional\r\n\tpublic Atendimento cancelar(Atendimento atendimento){\r\n\t\t\tif(atendimento.isCancelado()) {\r\n\t\t\t\tthrow new NegocioException(\"Este atendimento j\u00e1 est\u00e1 Cancelado!\");\r\n\t\t\t}\r\n\t\t\tif(atendimento.isFinalizado()) {\r\n\t\t\t\tthrow new NegocioException(\"Este atendimento j\u00e1 foi Finalizado!\");\r\n\t\t\t}\r\n\t\t\tatendimento = this.salvar(atendimento);\r\n\t\t\tatendimento.setStatus(StatusAtendimento.CANCELADO);\r\n\t\t\tatendimento = this.salvar(atendimento);\r\n\t\t\treturn atendimento;\r\n\t\t\r\n\t}\r\n\t\r\n\t@Transacional\r\n\tpublic Atendimento finalizar(Atendimento atendimento){\r\n\t\t\tif(atendimento.isCancelado()) {\r\n\t\t\t\tthrow new NegocioException(\"Este atendimento j\u00e1 est\u00e1 Cancelado!\");\r\n\t\t\t}\r\n\t\t\tif(atendimento.isFinalizado()) {\r\n\t\t\t\tthrow new NegocioException(\"Este atendimento j\u00e1 foi Finalizado!\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(atendimento.isFinalizavel()) {\r\n\t\t\t\tatendimento = this.salvar(atendimento);\r\n\t\t\t\tatendimento.setStatus(StatusAtendimento.FINALIZADO);\r\n\t\t\t\tatendimento = this.salvar(atendimento);\r\n\t\t\t\treturn atendimento;\r\n\t\t\t}else\r\n\t\t\t\tthrow new NegocioException(\"Este atendimento n\u00e3o pode ser Finalizado!\");\r\n\t}\r\n\r\n\tpublic List<Atendimento> todos() {\r\n\r\n\t\treturn manager.createQuery(\"from Atendimento\", Atendimento.class).getResultList();\r\n\t}\r\n\t\r\n\tpublic List<Atendimento> atendimentosDoDia() throws Exception{\r\n\t\tDate d1 = new Date();\r\n\t\td1.setHours(0);\r\n\t\td1.setMinutes(0);\r\n\t\td1.setSeconds(0);\r\n\t\tDate d2 = new Date();\r\n\t\td2.setHours(23);\r\n\t\td2.setMinutes(59);\r\n\t\td2.setSeconds(59);\r\n\t\t\r\n\t\tSimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n\t\tString inicio = format.format(d1);\r\n\t\tString fim = format.format(d2);\r\n\t\td1 = format.parse(inicio);\r\n\t\td2 = format.parse(fim);\r\n\t\t\r\n\t\tQuery query = manager.createQuery(\"select a from Atendimento a where a.data >= :d1 and a.data <= :d2\", Atendimento.class);\r\n\t\tquery.setParameter(\"d1\", d1);\r\n\t\tquery.setParameter(\"d2\", d2);\r\n\t\t\r\n\t\treturn query.getResultList();\r\n\t\t\r\n\t}\r\n\r\n"]]}
{"hexsha": "5e30724853d8e221d7ed0a9cec203325c3bfe709", "ext": "java", "lang": "Java", "content": "public class IdentitySets {\n\n  private static class IdentitySingletonSet<E> extends AbstractSet<E> implements\n      Serializable {\n\n    private final E item;\n\n    IdentitySingletonSet(E item) {\n      this.item = item;\n    }\n\n    @Override\n    public boolean contains(Object o) {\n      return o == item;\n    }\n\n    @Override\n    public Iterator<E> iterator() {\n      return new SingletonIterator<E>(item);\n    }\n\n    @Override\n    public int size() {\n      return 1;\n    }\n\n    @Override\n    public Object[] toArray() {\n      return toArray(new Object[1]);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T[] toArray(T[] a) {\n      if (a.length < 1) {\n        a = (T[]) Array.newInstance(a.getClass().getComponentType(), 1);\n      }\n      a[0] = (T) item;\n      int i = 1;\n      while (i < a.length) {\n        a[i++] = null;\n      }\n      return a;\n    }\n  }\n  private static final class SingletonIterator<T> implements Iterator<T> {\n\n    /**\n     * Sentinel value to mark that this iterator's single item was consumed.\n     */\n    private static final Object EMPTY = new Object();\n\n    private T item;\n\n    SingletonIterator(T item) {\n      this.item = item;\n    }\n\n    @Override\n    public boolean hasNext() {\n      return item != EMPTY;\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public T next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T toReturn = item;\n      item = (T) EMPTY;\n      return toReturn;\n    }\n\n    @Override\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  private static final Class<?> MULTI_SET_CLASS = IdentityHashSet.class;\n\n  private static final Class<?> SINGLETON_SET_CLASS = IdentitySingletonSet.class;\n\n  public static <T> Set<T> add(Set<T> set, T toAdd) {\n    switch (set.size()) {\n      case 0:\n        // Empty -> Singleton\n        return new IdentitySingletonSet<T>(toAdd);\n      case 1: {\n        if (set.contains(toAdd)) {\n          return set;\n        }\n        // Singleton -> IdentityHashSet\n        Set<T> result = new IdentityHashSet<T>();\n        result.add(set.iterator().next());\n        result.add(toAdd);\n        return result;\n      }\n      default:\n        // IdentityHashSet\n        set.add(toAdd);\n        return set;\n    }\n  }\n\n  public static <T> Set<T> create() {\n    return Collections.emptySet();\n  }\n\n  public static <T> Set<T> create(T item) {\n    return new IdentitySingletonSet<T>(item);\n  }\n\n  public static <T> Set<T> normalize(Set<T> set) {\n    switch (set.size()) {\n      case 0:\n        return create();\n      case 1: {\n        if (set.getClass() == SINGLETON_SET_CLASS) {\n          return set;\n        }\n        return create(set.iterator().next());\n      }\n      default:\n        if (set.getClass() == MULTI_SET_CLASS) {\n          return set;\n        }\n        IdentityHashSet<T> result = new IdentityHashSet<T>();\n        result.addAll(set);\n        return result;\n    }\n  }\n\n  public static <T> Set<T> remove(Set<T> set, T toRemove) {\n    switch (set.size()) {\n      case 0:\n        // Empty\n        return set;\n      case 1:\n        // Singleton -> Empty\n        if (set.contains(toRemove)) {\n          return create();\n        }\n        return set;\n      case 2:\n        // IdentityHashSet -> Singleton\n        if (set.remove(toRemove)) {\n          return create(set.iterator().next());\n        }\n        return set;\n      default:\n        // IdentityHashSet\n        set.remove(toRemove);\n        return set;\n    }\n  }\n}", "class_id": 0, "repo": "TeamSPoon/CYC_JRTL_with_CommonLisp_OLD", "file": "platform/lib/all-deps/com/google/gwt/dev/util/collect/IdentitySets.java", "last_update_at": "2020-01-17T16:29:19+00:00", "question_id": "5e30724853d8e221d7ed0a9cec203325c3bfe709", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class IdentitySets {\n  private static class IdentitySingletonSet<E> extends AbstractSet<E> implements\n      Serializable {\n    private final E item;\n    IdentitySingletonSet(E item) {\n      this.item = item;\n    }\n    @Override\n    public boolean contains(Object o) {\n      return o == item;\n    }\n    @Override\n    public Iterator<E> iterator() {\n      return new SingletonIterator<E>(item);\n    }\n    @Override\n    public int size() {\n      return 1;\n    }\n    @Override\n    public Object[] toArray() {\n      return toArray(new Object[1]);\n    }\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T[] toArray(T[] a) {\n      if (a.length < 1) {\n        a = (T[]) Array.newInstance(a.getClass().getComponentType(), 1);\n      }\n      a[0] = (T) item;\n      int i = 1;\n      while (i < a.length) {\n        a[i++] = null;\n      }\n      return a;\n    }\n  }\n  private static final class SingletonIterator<T> implements Iterator<T> {\n    /**\n     * Sentinel value to mark that this iterator's single item was consumed.\n     */\n    private static final Object EMPTY = new Object();\n    private T item;\n    SingletonIterator(T item) {\n      this.item = item;\n    }\n    @Override\n    public boolean hasNext() {\n      return item != EMPTY;\n    }\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public T next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T toReturn = item;\n      item = (T) EMPTY;\n      return toReturn;\n    }\n    @Override\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n  private static final Class<?> MULTI_SET_CLASS = IdentityHashSet.class;\n  private static final Class<?> SINGLETON_SET_CLASS = IdentitySingletonSet.class;\n  public static <T> Set<T> add(Set<T> set, T toAdd) {\n    switch (set.size()) {\n      case 0:\n        // Empty -> Singleton\n        return new IdentitySingletonSet<T>(toAdd);\n      case 1: {\n        if (set.contains(toAdd)) {\n          return set;\n        }\n        // Singleton -> IdentityHashSet\n        Set<T> result = new IdentityHashSet<T>();\n        result.add(set.iterator().next());\n        result.add(toAdd);\n        return result;\n      }\n      default:\n        // IdentityHashSet\n        set.add(toAdd);\n        return set;\n    }\n  }\n  public static <T> Set<T> create() {\n    return Collections.emptySet();\n  }\n  public static <T> Set<T> create(T item) {\n    return new IdentitySingletonSet<T>(item);\n  }\n  public static <T> Set<T> normalize(Set<T> set) {\n    switch (set.size()) {\n      case 0:\n        return create();\n      case 1: {\n        if (set.getClass() == SINGLETON_SET_CLASS) {\n          return set;\n        }\n        return create(set.iterator().next());\n      }\n      default:\n        if (set.getClass() == MULTI_SET_CLASS) {\n          return set;\n        }\n        IdentityHashSet<T> result = new IdentityHashSet<T>();\n        result.addAll(set);\n        return result;\n    }\n  }\n  public static <T> Set<T> remove(Set<T> set, T toRemove) {\n    switch (set.size()) {\n      case 0:\n        // Empty\n        return set;\n      case 1:\n        // Singleton -> Empty\n        if (set.contains(toRemove)) {\n          return create();\n        }\n        return set;\n      case 2:\n        // IdentityHashSet -> Singleton\n        if (set.remove(toRemove)) {\n          return create(set.iterator().next());\n        }\n        return set;\n      default:\n        // IdentityHashSet\n        set.remove(toRemove);\n        return set;\n    }\n  }\n"]]}
{"hexsha": "c70a6a0392da80e3977ef762971c0ba2fff39f9f", "ext": "java", "lang": "Java", "content": "public class TimeCommand {\n   public static void register(CommandDispatcher<CommandSource> dispatcher) {\n      dispatcher.register(Commands.literal(\"time\").requires((p_198828_0_) -> {\n         return p_198828_0_.hasPermissionLevel(2);\n      }).then(Commands.literal(\"set\").then(Commands.literal(\"day\").executes((p_198832_0_) -> {\n         return setTime(p_198832_0_.getSource(), 1000);\n      })).then(Commands.literal(\"noon\").executes((p_198825_0_) -> {\n         return setTime(p_198825_0_.getSource(), 6000);\n      })).then(Commands.literal(\"night\").executes((p_198822_0_) -> {\n         return setTime(p_198822_0_.getSource(), 13000);\n      })).then(Commands.literal(\"midnight\").executes((p_200563_0_) -> {\n         return setTime(p_200563_0_.getSource(), 18000);\n      })).then(Commands.argument(\"time\", TimeArgument.func_218091_a()).executes((p_200564_0_) -> {\n         return setTime(p_200564_0_.getSource(), IntegerArgumentType.getInteger(p_200564_0_, \"time\"));\n      }))).then(Commands.literal(\"add\").then(Commands.argument(\"time\", TimeArgument.func_218091_a()).executes((p_198830_0_) -> {\n         return addTime(p_198830_0_.getSource(), IntegerArgumentType.getInteger(p_198830_0_, \"time\"));\n      }))).then(Commands.literal(\"query\").then(Commands.literal(\"daytime\").executes((p_198827_0_) -> {\n         return sendQueryResults(p_198827_0_.getSource(), getDayTime(p_198827_0_.getSource().getWorld()));\n      })).then(Commands.literal(\"gametime\").executes((p_198821_0_) -> {\n         return sendQueryResults(p_198821_0_.getSource(), (int)(p_198821_0_.getSource().getWorld().getGameTime() % 2147483647L));\n      })).then(Commands.literal(\"day\").executes((p_198831_0_) -> {\n         return sendQueryResults(p_198831_0_.getSource(), (int)(p_198831_0_.getSource().getWorld().getDayTime() / 24000L % 2147483647L));\n      }))));\n   }\n\n   /**\n    * Returns the day time (time wrapped within a day)\n    */\n   private static int getDayTime(ServerWorld worldIn) {\n      return (int)(worldIn.getDayTime() % 24000L);\n   }\n\n   private static int sendQueryResults(CommandSource source, int time) {\n      source.sendFeedback(new TranslationTextComponent(\"commands.time.query\", time), false);\n      return time;\n   }\n\n   public static int setTime(CommandSource source, int time) {\n      for(ServerWorld serverworld : source.getServer().getWorlds()) {\n         serverworld.setDayTime((long)time);\n      }\n\n      source.sendFeedback(new TranslationTextComponent(\"commands.time.set\", time), true);\n      return getDayTime(source.getWorld());\n   }\n\n   public static int addTime(CommandSource source, int amount) {\n      for(ServerWorld serverworld : source.getServer().getWorlds()) {\n         serverworld.setDayTime(serverworld.getDayTime() + (long)amount);\n      }\n\n      int i = getDayTime(source.getWorld());\n      source.sendFeedback(new TranslationTextComponent(\"commands.time.set\", i), true);\n      return i;\n   }\n}", "class_id": 0, "repo": "GTLugo/Chivalric", "file": "chivalric/build/tmp/expandedArchives/forge-1.16.4-35.1.4_mapped_snapshot_20201028-1.16.3-sources.jar_b77944a67449ffcc9dcc6ef1ff5cf49e/net/minecraft/command/impl/TimeCommand.java", "last_update_at": "2020-11-29T22:15:39+00:00", "question_id": "c70a6a0392da80e3977ef762971c0ba2fff39f9f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TimeCommand {\n   public static void register(CommandDispatcher<CommandSource> dispatcher) {\n      dispatcher.register(Commands.literal(\"time\").requires((p_198828_0_) -> {\n         return p_198828_0_.hasPermissionLevel(2);\n      }).then(Commands.literal(\"set\").then(Commands.literal(\"day\").executes((p_198832_0_) -> {\n         return setTime(p_198832_0_.getSource(), 1000);\n      })).then(Commands.literal(\"noon\").executes((p_198825_0_) -> {\n         return setTime(p_198825_0_.getSource(), 6000);\n      })).then(Commands.literal(\"night\").executes((p_198822_0_) -> {\n         return setTime(p_198822_0_.getSource(), 13000);\n      })).then(Commands.literal(\"midnight\").executes((p_200563_0_) -> {\n         return setTime(p_200563_0_.getSource(), 18000);\n      })).then(Commands.argument(\"time\", TimeArgument.func_218091_a()).executes((p_200564_0_) -> {\n         return setTime(p_200564_0_.getSource(), IntegerArgumentType.getInteger(p_200564_0_, \"time\"));\n      }))).then(Commands.literal(\"add\").then(Commands.argument(\"time\", TimeArgument.func_218091_a()).executes((p_198830_0_) -> {\n         return addTime(p_198830_0_.getSource(), IntegerArgumentType.getInteger(p_198830_0_, \"time\"));\n      }))).then(Commands.literal(\"query\").then(Commands.literal(\"daytime\").executes((p_198827_0_) -> {\n         return sendQueryResults(p_198827_0_.getSource(), getDayTime(p_198827_0_.getSource().getWorld()));\n      })).then(Commands.literal(\"gametime\").executes((p_198821_0_) -> {\n         return sendQueryResults(p_198821_0_.getSource(), (int)(p_198821_0_.getSource().getWorld().getGameTime() % 2147483647L));\n      })).then(Commands.literal(\"day\").executes((p_198831_0_) -> {\n         return sendQueryResults(p_198831_0_.getSource(), (int)(p_198831_0_.getSource().getWorld().getDayTime() / 24000L % 2147483647L));\n      }))));\n   }\n   /**\n    * Returns the day time (time wrapped within a day)\n    */\n   private static int getDayTime(ServerWorld worldIn) {\n      return (int)(worldIn.getDayTime() % 24000L);\n   }\n   private static int sendQueryResults(CommandSource source, int time) {\n      source.sendFeedback(new TranslationTextComponent(\"commands.time.query\", time), false);\n      return time;\n   }\n   public static int setTime(CommandSource source, int time) {\n      for(ServerWorld serverworld : source.getServer().getWorlds()) {\n         serverworld.setDayTime((long)time);\n      }\n      source.sendFeedback(new TranslationTextComponent(\"commands.time.set\", time), true);\n      return getDayTime(source.getWorld());\n   }\n   public static int addTime(CommandSource source, int amount) {\n      for(ServerWorld serverworld : source.getServer().getWorlds()) {\n         serverworld.setDayTime(serverworld.getDayTime() + (long)amount);\n      }\n      int i = getDayTime(source.getWorld());\n      source.sendFeedback(new TranslationTextComponent(\"commands.time.set\", i), true);\n      return i;\n   }\n"]]}
{"hexsha": "cae993c59e60d1a09d4092dd134bbdb191913f4b", "ext": "java", "lang": "Java", "content": "@Layout(\"/browse/*\")\npublic class BrowsePage extends AbstractPage<BrowsePage> {\n\n    /**\n     * Message block displayed when no results are present\n     * @return element\n     */\n    public SelenideElement noContentInfo() {\n        return $(\".apiman-no-entities-description\");\n    }\n\n    /**\n     * Container for result elements\n     * @return element\n     */\n    public SelenideElement resultContainer() {\n        return $(\".browse-items\");\n    }\n\n    /**\n     * Collection of results\n     * @return elements collection\n     */\n    public ElementsCollection resultEntries() {\n        return resultContainer().findAll(\".item\");\n    }\n\n    /**\n     * Link to specific result\n     * @return element\n     */\n    public SelenideElement resultLink(String title) {\n        return resultContainer().find(linkText(title));\n    }\n\n    // Search\n\n    /**\n     * Search input\n     * @return element\n     */\n    public SelenideElement searchInput() {\n        return $(\"#apiman-search\");\n    }\n\n    /**\n     * Search button\n     * @return element\n     */\n    public SelenideElement searchButton() {\n        return $(\"#search-btn\");\n    }\n\n    /**\n     * Performs search operation\n     * @param query value\n     * @param clazz this page class object\n     * @return this page object\n     */\n    public <ThisPageObject> ThisPageObject search(String query, Class<ThisPageObject> clazz) {\n        searchInput().val(query);\n        searchButton().click();\n        return clazz.cast(this);\n    }\n\n    /**\n     * Performs search operation\n     * @param query value\n     * @return this page object\n     */\n    public BrowsePage search(String query) {\n        return search(query, BrowsePage.class);\n    }\n}", "class_id": 0, "repo": "mijaros/apiman-test", "file": "apiman-it-ui/src/test/java/io/apiman/test/integration/ui/support/selenide/layouts/BrowsePage.java", "last_update_at": "2020-08-19T13:05:00+00:00", "question_id": "cae993c59e60d1a09d4092dd134bbdb191913f4b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Layout(\"/browse/*\")\npublic class BrowsePage extends AbstractPage<BrowsePage> {\n    /**\n     * Message block displayed when no results are present\n     * @return element\n     */\n    public SelenideElement noContentInfo() {\n        return $(\".apiman-no-entities-description\");\n    }\n    /**\n     * Container for result elements\n     * @return element\n     */\n    public SelenideElement resultContainer() {\n        return $(\".browse-items\");\n    }\n    /**\n     * Collection of results\n     * @return elements collection\n     */\n    public ElementsCollection resultEntries() {\n        return resultContainer().findAll(\".item\");\n    }\n    /**\n     * Link to specific result\n     * @return element\n     */\n    public SelenideElement resultLink(String title) {\n        return resultContainer().find(linkText(title));\n    }\n    // Search\n    /**\n     * Search input\n     * @return element\n     */\n    public SelenideElement searchInput() {\n        return $(\"#apiman-search\");\n    }\n    /**\n     * Search button\n     * @return element\n     */\n    public SelenideElement searchButton() {\n        return $(\"#search-btn\");\n    }\n    /**\n     * Performs search operation\n     * @param query value\n     * @param clazz this page class object\n     * @return this page object\n     */\n    public <ThisPageObject> ThisPageObject search(String query, Class<ThisPageObject> clazz) {\n        searchInput().val(query);\n        searchButton().click();\n        return clazz.cast(this);\n    }\n    /**\n     * Performs search operation\n     * @param query value\n     * @return this page object\n     */\n    public BrowsePage search(String query) {\n        return search(query, BrowsePage.class);\n    }\n"]]}
{"hexsha": "e436addad1461c6544176d85187594400075ad2e", "ext": "java", "lang": "Java", "content": "public class AssetAssembler {\n\n  private static final NBTTagCompound compound = new NBTTagCompound(\"\");\n\n  static {\n    File file = new File(\"assets.dat\");\n    if (file.exists()) {\n      file.delete();\n    }\n\n    try {\n      readBlockPalette();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n\n  private static void readBlockPalette() throws IOException {\n    File nbtPalette = new File(\"palette.nbt\");\n    byte[] data = Files.readAllBytes(nbtPalette.toPath());\n    NBTReader nbtReader = new NBTReader(Unpooled.wrappedBuffer(data), ByteOrder.BIG_ENDIAN);\n    nbtReader.setUseVarint(true);\n\n    List<Object> blockPalette = new ArrayList<>();\n\n    while (true) {\n      try {\n        NBTTagCompound compound = nbtReader.parse();\n        DumpUtil.dumpNBTCompund(compound);\n        blockPalette.add(compound);\n      } catch (AllocationLimitReachedException | IOException e) {\n        List<Object> nbtTags = compound.getList(\"blockPalette\", true);\n        nbtTags.clear();\n        nbtTags.addAll(blockPalette);\n        return;\n      }\n    }\n  }\n\n  public static void writeToFile() {\n    ByteBuf buf = PooledByteBufAllocator.DEFAULT.directBuffer();\n    NBTWriter nbtWriter = new NBTWriter(buf, ByteOrder.BIG_ENDIAN);\n\n    try {\n      nbtWriter.write(compound);\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n\n    try (FileOutputStream out = new FileOutputStream(new File(\"assets.dat\"))) {\n      byte[] data = new byte[buf.readableBytes()];\n      buf.readBytes(data);\n      out.write(data);\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n\n    buf.release();\n  }\n\n  public static synchronized void addRecipe(String name, UUID uuid, byte type, ItemStack[] in, ItemStack[] out,\n      int width, int height, String block, int prio) {\n    List<Object> recipes = compound.getList(\"recipes\", true);\n\n    NBTTagCompound recipeCompound = new NBTTagCompound(\"\");\n\n    if (name != null) {\n      recipeCompound.addValue(\"name\", name);\n    }\n\n    if (block != null) {\n      recipeCompound.addValue(\"block\", block);\n    }\n\n    recipeCompound.addValue(\"prio\", prio);\n    recipeCompound.addValue(\"type\", type);\n\n    List<byte[]> input = new ArrayList<>();\n    for (ItemStack itemStack : in) {\n      input.add(serializeItem(itemStack));\n    }\n\n    recipeCompound.addValue(\"i\", input);\n\n    List<byte[]> output = new ArrayList<>();\n    for (ItemStack itemStack : out) {\n      output.add(serializeItem(itemStack));\n    }\n\n    recipeCompound.addValue(\"o\", output);\n\n    if (uuid != null) {\n      recipeCompound.addValue(\"u\", uuid.toString());\n    }\n\n    if (width != -1 && height != -1) {\n      recipeCompound.addValue(\"w\", width);\n      recipeCompound.addValue(\"h\", height);\n    }\n\n    recipes.add(recipeCompound);\n  }\n\n  public static synchronized void writeCreativeInventory(ItemStack[] items) {\n    List<Object> nbtTags = compound.getList(\"creativeInventory\", true);\n    nbtTags.clear();\n\n    for (ItemStack item : items) {\n      byte[] itemData = serializeItem(item);\n      nbtTags.add(itemData);\n    }\n  }\n\n  public static synchronized void writeLegacyItems(List<StringShortPair> itemLegacyIds) {\n    List<Object> nbtTags = compound.getList(\"itemLegacyIDs\", true);\n    nbtTags.clear();\n\n    for (StringShortPair itemLegacyId : itemLegacyIds) {\n      NBTTagCompound l = new NBTTagCompound(\"\");\n      l.addValue(\"name\", itemLegacyId.getBlockId());\n      l.addValue(\"id\", itemLegacyId.getData());\n      nbtTags.add(l);\n    }\n  }\n\n  public static synchronized void writeBlockPalette(List<Object> blockPalette) {\n    List<Object> nbtTags = compound.getList(\"blockPalette\", true);\n    nbtTags.clear();\n    nbtTags.addAll(blockPalette);\n  }\n\n  private static byte[] serializeItem(ItemStack itemStack) {\n    PacketBuffer buffer = new PacketBuffer(2);\n    if (itemStack == null) {\n      System.out.println(\"Nulled item\");\n    }\n\n    buffer.writeShort((short) itemStack.getMaterial());\n    buffer.writeByte(itemStack.getAmount());\n    buffer.writeShort(itemStack.getData());\n\n    if (itemStack.getNbtData() != null) {\n      ByteBuf nbtBuf = PooledByteBufAllocator.DEFAULT.directBuffer();\n      try {\n        itemStack.getNbtData().writeTo(nbtBuf, false, ByteOrder.BIG_ENDIAN);\n      } catch (IOException e) {\n\n      }\n\n      buffer.writeShort((short) nbtBuf.readableBytes());\n      buffer.writeBytes(nbtBuf);\n    } else {\n      buffer.writeShort((short) 0);\n    }\n\n    byte[] data = new byte[buffer.getRemaining()];\n    buffer.readBytes(data);\n    buffer.release();\n    return data;\n  }\n\n  public static synchronized void writeBiomeDefinition(NBTTagCompound nbt) {\n    compound.addValue(\"biomeDefinitions\", nbt.deepClone(\"biomeDefinitions\"));\n  }\n\n}", "class_id": 0, "repo": "Janmm14/sniffle", "file": "src/main/java/io/gomint/proxy/asset/AssetAssembler.java", "last_update_at": "2020-06-01T14:15:37+00:00", "question_id": "e436addad1461c6544176d85187594400075ad2e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AssetAssembler {\n  private static final NBTTagCompound compound = new NBTTagCompound(\"\");\n  static {\n    File file = new File(\"assets.dat\");\n    if (file.exists()) {\n      file.delete();\n    }\n    try {\n      readBlockPalette();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n  private static void readBlockPalette() throws IOException {\n    File nbtPalette = new File(\"palette.nbt\");\n    byte[] data = Files.readAllBytes(nbtPalette.toPath());\n    NBTReader nbtReader = new NBTReader(Unpooled.wrappedBuffer(data), ByteOrder.BIG_ENDIAN);\n    nbtReader.setUseVarint(true);\n    List<Object> blockPalette = new ArrayList<>();\n    while (true) {\n      try {\n        NBTTagCompound compound = nbtReader.parse();\n        DumpUtil.dumpNBTCompund(compound);\n        blockPalette.add(compound);\n      } catch (AllocationLimitReachedException | IOException e) {\n        List<Object> nbtTags = compound.getList(\"blockPalette\", true);\n        nbtTags.clear();\n        nbtTags.addAll(blockPalette);\n        return;\n      }\n    }\n  }\n  public static void writeToFile() {\n    ByteBuf buf = PooledByteBufAllocator.DEFAULT.directBuffer();\n    NBTWriter nbtWriter = new NBTWriter(buf, ByteOrder.BIG_ENDIAN);\n    try {\n      nbtWriter.write(compound);\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    try (FileOutputStream out = new FileOutputStream(new File(\"assets.dat\"))) {\n      byte[] data = new byte[buf.readableBytes()];\n      buf.readBytes(data);\n      out.write(data);\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    buf.release();\n  }\n  public static synchronized void addRecipe(String name, UUID uuid, byte type, ItemStack[] in, ItemStack[] out,\n      int width, int height, String block, int prio) {\n    List<Object> recipes = compound.getList(\"recipes\", true);\n    NBTTagCompound recipeCompound = new NBTTagCompound(\"\");\n    if (name != null) {\n      recipeCompound.addValue(\"name\", name);\n    }\n    if (block != null) {\n      recipeCompound.addValue(\"block\", block);\n    }\n    recipeCompound.addValue(\"prio\", prio);\n    recipeCompound.addValue(\"type\", type);\n    List<byte[]> input = new ArrayList<>();\n    for (ItemStack itemStack : in) {\n      input.add(serializeItem(itemStack));\n    }\n    recipeCompound.addValue(\"i\", input);\n    List<byte[]> output = new ArrayList<>();\n    for (ItemStack itemStack : out) {\n      output.add(serializeItem(itemStack));\n    }\n    recipeCompound.addValue(\"o\", output);\n    if (uuid != null) {\n      recipeCompound.addValue(\"u\", uuid.toString());\n    }\n    if (width != -1 && height != -1) {\n      recipeCompound.addValue(\"w\", width);\n      recipeCompound.addValue(\"h\", height);\n    }\n    recipes.add(recipeCompound);\n  }\n  public static synchronized void writeCreativeInventory(ItemStack[] items) {\n    List<Object> nbtTags = compound.getList(\"creativeInventory\", true);\n    nbtTags.clear();\n    for (ItemStack item : items) {\n      byte[] itemData = serializeItem(item);\n      nbtTags.add(itemData);\n    }\n  }\n  public static synchronized void writeLegacyItems(List<StringShortPair> itemLegacyIds) {\n    List<Object> nbtTags = compound.getList(\"itemLegacyIDs\", true);\n    nbtTags.clear();\n    for (StringShortPair itemLegacyId : itemLegacyIds) {\n      NBTTagCompound l = new NBTTagCompound(\"\");\n      l.addValue(\"name\", itemLegacyId.getBlockId());\n      l.addValue(\"id\", itemLegacyId.getData());\n      nbtTags.add(l);\n    }\n  }\n  public static synchronized void writeBlockPalette(List<Object> blockPalette) {\n    List<Object> nbtTags = compound.getList(\"blockPalette\", true);\n    nbtTags.clear();\n    nbtTags.addAll(blockPalette);\n  }\n  private static byte[] serializeItem(ItemStack itemStack) {\n    PacketBuffer buffer = new PacketBuffer(2);\n    if (itemStack == null) {\n      System.out.println(\"Nulled item\");\n    }\n    buffer.writeShort((short) itemStack.getMaterial());\n    buffer.writeByte(itemStack.getAmount());\n    buffer.writeShort(itemStack.getData());\n    if (itemStack.getNbtData() != null) {\n      ByteBuf nbtBuf = PooledByteBufAllocator.DEFAULT.directBuffer();\n      try {\n        itemStack.getNbtData().writeTo(nbtBuf, false, ByteOrder.BIG_ENDIAN);\n      } catch (IOException e) {\n      }\n      buffer.writeShort((short) nbtBuf.readableBytes());\n      buffer.writeBytes(nbtBuf);\n    } else {\n      buffer.writeShort((short) 0);\n    }\n    byte[] data = new byte[buffer.getRemaining()];\n    buffer.readBytes(data);\n    buffer.release();\n    return data;\n  }\n  public static synchronized void writeBiomeDefinition(NBTTagCompound nbt) {\n    compound.addValue(\"biomeDefinitions\", nbt.deepClone(\"biomeDefinitions\"));\n  }\n"]]}
{"hexsha": "62d8b30c2352c27c3568386b4ba8002903091fa3", "ext": "java", "lang": "Java", "content": "public class CreateServiceJavaImplTest {\n    private Dao mockedDao = mock(Dao.class);\n    private CreateServiceJavaImpl javaService;\n\n\n    @Before\n    public void setUp() throws Exception {\n        javaService = new CreateServiceJavaImpl(mockedDao);\n    }\n\n    @Test\n    public void test_JavaServiceResult_saveNew_CREATED() {\n        County newCounty = TestHelper.countyFactory(null, \"46\", \"Lot\");\n        JavaServiceResult res = javaService.saveNew(newCounty);\n\n        Assert.assertNotNull(res);\n        Assert.assertEquals(Http.Status.CREATED, res.getHttpStatus());\n    }\n}", "class_id": 0, "repo": "hzy9981/poc-play-rest-backend", "file": "test/org/myweb/services/crud/create/CreateServiceJavaImplTest.java", "last_update_at": "2020-02-04T06:56:50+00:00", "question_id": "62d8b30c2352c27c3568386b4ba8002903091fa3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CreateServiceJavaImplTest {\n    private Dao mockedDao = mock(Dao.class);\n    private CreateServiceJavaImpl javaService;\n    @Before\n    public void setUp() throws Exception {\n        javaService = new CreateServiceJavaImpl(mockedDao);\n    }\n    @Test\n    public void test_JavaServiceResult_saveNew_CREATED() {\n        County newCounty = TestHelper.countyFactory(null, \"46\", \"Lot\");\n        JavaServiceResult res = javaService.saveNew(newCounty);\n        Assert.assertNotNull(res);\n        Assert.assertEquals(Http.Status.CREATED, res.getHttpStatus());\n    }\n"]]}
{"hexsha": "3fd76c672e2258865a3ddf069142473672941fe6", "ext": "java", "lang": "Java", "content": "@Component\npublic class PromotiondetailinfoServiceMapper extends AbstractServiceMapper {\n\n\t/**\n\t * ModelMapper : bean to bean mapping library.\n\t */\n\tprivate ModelMapper modelMapper;\n\t\n\t/**\n\t * Constructor.\n\t */\n\tpublic PromotiondetailinfoServiceMapper() {\n\t\tmodelMapper = new ModelMapper();\n\t\tmodelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT);\n\t}\n\n\t/**\n\t * Mapping from 'PromotiondetailinfoEntity' to 'Promotiondetailinfo'\n\t * @param promotiondetailinfoEntity\n\t */\n\tpublic Promotiondetailinfo mapPromotiondetailinfoEntityToPromotiondetailinfo(PromotiondetailinfoEntity promotiondetailinfoEntity) {\n\t\tif(promotiondetailinfoEntity == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t//--- Generic mapping \n\t\tPromotiondetailinfo promotiondetailinfo = map(promotiondetailinfoEntity, Promotiondetailinfo.class);\n\n\t\t//--- Link mapping ( link to Dishspecificationinfo )\n\t\treturn promotiondetailinfo;\n\t}\n\t\n\t/**\n\t * Mapping from 'Promotiondetailinfo' to 'PromotiondetailinfoEntity'\n\t * @param promotiondetailinfo\n\t * @param promotiondetailinfoEntity\n\t */\n\tpublic void mapPromotiondetailinfoToPromotiondetailinfoEntity(Promotiondetailinfo promotiondetailinfo, PromotiondetailinfoEntity promotiondetailinfoEntity) {\n\t\tif(promotiondetailinfo == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t//--- Generic mapping \n\t\tmap(promotiondetailinfo, promotiondetailinfoEntity);\n\n\t\t//--- Link mapping ( link : promotiondetailinfo )\n\n\t}\n\t\n\t/**\n\t * Verify that Dishspecificationinfo id is valid.\n\t * @param Dishspecificationinfo Dishspecificationinfo\n\t * @return boolean\n\t */\n\tprivate boolean hasLinkToDishspecificationinfo(Promotiondetailinfo promotiondetailinfo) {\n\t\tif(promotiondetailinfo.getSpecificationid() != null) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tprotected ModelMapper getModelMapper() {\n\t\treturn modelMapper;\n\t}\n\n\tprotected void setModelMapper(ModelMapper modelMapper) {\n\t\tthis.modelMapper = modelMapper;\n\t}\n\n}", "class_id": 0, "repo": "cytochromewangdong/HippoStart", "file": "src/main/java/com/dt/hippo/auto/business/service/mapping/PromotiondetailinfoServiceMapper.java", "last_update_at": "2020-07-29T20:44:21+00:00", "question_id": "3fd76c672e2258865a3ddf069142473672941fe6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\npublic class PromotiondetailinfoServiceMapper extends AbstractServiceMapper {\n\t/**\n\t * ModelMapper : bean to bean mapping library.\n\t */\n\tprivate ModelMapper modelMapper;\n\t\n\t/**\n\t * Constructor.\n\t */\n\tpublic PromotiondetailinfoServiceMapper() {\n\t\tmodelMapper = new ModelMapper();\n\t\tmodelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT);\n\t}\n\t/**\n\t * Mapping from 'PromotiondetailinfoEntity' to 'Promotiondetailinfo'\n\t * @param promotiondetailinfoEntity\n\t */\n\tpublic Promotiondetailinfo mapPromotiondetailinfoEntityToPromotiondetailinfo(PromotiondetailinfoEntity promotiondetailinfoEntity) {\n\t\tif(promotiondetailinfoEntity == null) {\n\t\t\treturn null;\n\t\t}\n\t\t//--- Generic mapping \n\t\tPromotiondetailinfo promotiondetailinfo = map(promotiondetailinfoEntity, Promotiondetailinfo.class);\n\t\t//--- Link mapping ( link to Dishspecificationinfo )\n\t\treturn promotiondetailinfo;\n\t}\n\t\n\t/**\n\t * Mapping from 'Promotiondetailinfo' to 'PromotiondetailinfoEntity'\n\t * @param promotiondetailinfo\n\t * @param promotiondetailinfoEntity\n\t */\n\tpublic void mapPromotiondetailinfoToPromotiondetailinfoEntity(Promotiondetailinfo promotiondetailinfo, PromotiondetailinfoEntity promotiondetailinfoEntity) {\n\t\tif(promotiondetailinfo == null) {\n\t\t\treturn;\n\t\t}\n\t\t//--- Generic mapping \n\t\tmap(promotiondetailinfo, promotiondetailinfoEntity);\n\t\t//--- Link mapping ( link : promotiondetailinfo )\n\t}\n\t\n\t/**\n\t * Verify that Dishspecificationinfo id is valid.\n\t * @param Dishspecificationinfo Dishspecificationinfo\n\t * @return boolean\n\t */\n\tprivate boolean hasLinkToDishspecificationinfo(Promotiondetailinfo promotiondetailinfo) {\n\t\tif(promotiondetailinfo.getSpecificationid() != null) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tprotected ModelMapper getModelMapper() {\n\t\treturn modelMapper;\n\t}\n\tprotected void setModelMapper(ModelMapper modelMapper) {\n\t\tthis.modelMapper = modelMapper;\n\t}\n"]]}
{"hexsha": "77a41e5bea116a1dac519e71d6d2b359c24c3e3a", "ext": "java", "lang": "Java", "content": "public class leet125 {\n    public static void main(String[] args) {\n        String a=\"A man, a plan, a canal: Panama\";\n        String b=\"`l;`` 1o1 ??;l`\";\n//        System.out.println(isPalindrome(a));\n        System.out.println(isPalindrome(b));\n\n    }\n    public static boolean isPalindrome(String s) {\n        if(s.length()==0){\n            return true;\n        }\n        String s0=s.replaceAll(\"[\\\\pP\\\\p{Punct}]\",\"\");\n        StringBuilder s1= new StringBuilder();\n        for(int i=0;i<s0.length();i++){\n            String ss=s0.substring(i,i+1).toLowerCase();\n            if(!ss.equals(\" \")&&!ss.equals(\"''\")){\n               s1.append(ss);\n            }\n        }\n        StringBuilder s2=new StringBuilder(s1.toString());\n        StringBuilder s3=s2.reverse();\n        String       s4=new String(s3);\n\n        return s1.toString().equals(s4);\n    }\n}", "class_id": 0, "repo": "orcakill/leetcode", "file": "java/src/main/java/leetcode/leet125.java", "last_update_at": "2020-10-04T11:12:36+00:00", "question_id": "77a41e5bea116a1dac519e71d6d2b359c24c3e3a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class leet125 {\n    public static void main(String[] args) {\n        String a=\"A man, a plan, a canal: Panama\";\n        String b=\"`l;`` 1o1 ??;l`\";\n//        System.out.println(isPalindrome(a));\n        System.out.println(isPalindrome(b));\n    }\n    public static boolean isPalindrome(String s) {\n        if(s.length()==0){\n            return true;\n        }\n        String s0=s.replaceAll(\"[\\\\pP\\\\p{Punct}]\",\"\");\n        StringBuilder s1= new StringBuilder();\n        for(int i=0;i<s0.length();i++){\n            String ss=s0.substring(i,i+1).toLowerCase();\n            if(!ss.equals(\" \")&&!ss.equals(\"''\")){\n               s1.append(ss);\n            }\n        }\n        StringBuilder s2=new StringBuilder(s1.toString());\n        StringBuilder s3=s2.reverse();\n        String       s4=new String(s3);\n        return s1.toString().equals(s4);\n    }\n"]]}
{"hexsha": "6103fc5e751818821a8a76fde1f7c7a79b8d7a55", "ext": "java", "lang": "Java", "content": "public class ResultResponseSettings implements Parcelable {\n\n    private String id;\n    private String field;\n    private String value;\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getField() {\n        return field;\n    }\n\n    public void setField(String field) {\n        this.field = field;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        dest.writeString(this.id);\n        dest.writeString(this.field);\n        dest.writeString(this.value);\n    }\n\n    public ResultResponseSettings() {\n    }\n\n    protected ResultResponseSettings(Parcel in) {\n        this.id = in.readString();\n        this.field = in.readString();\n        this.value = in.readString();\n    }\n\n    public static final Parcelable.Creator<ResultResponseSettings> CREATOR = new Parcelable.Creator<ResultResponseSettings>() {\n        @Override\n        public ResultResponseSettings createFromParcel(Parcel source) {\n            return new ResultResponseSettings(source);\n        }\n\n        @Override\n        public ResultResponseSettings[] newArray(int size) {\n            return new ResultResponseSettings[size];\n        }\n    };\n}", "class_id": 0, "repo": "SunbirdEd/teacher-aid-prep-app", "file": "app/src/main/java/com/gurug/education/data/model/response/settings/ResultResponseSettings.java", "last_update_at": "2020-11-21T17:55:26+00:00", "question_id": "6103fc5e751818821a8a76fde1f7c7a79b8d7a55", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ResultResponseSettings implements Parcelable {\n    private String id;\n    private String field;\n    private String value;\n    public String getId() {\n        return id;\n    }\n    public void setId(String id) {\n        this.id = id;\n    }\n    public String getField() {\n        return field;\n    }\n    public void setField(String field) {\n        this.field = field;\n    }\n    public String getValue() {\n        return value;\n    }\n    public void setValue(String value) {\n        this.value = value;\n    }\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        dest.writeString(this.id);\n        dest.writeString(this.field);\n        dest.writeString(this.value);\n    }\n    public ResultResponseSettings() {\n    }\n    protected ResultResponseSettings(Parcel in) {\n        this.id = in.readString();\n        this.field = in.readString();\n        this.value = in.readString();\n    }\n    public static final Parcelable.Creator<ResultResponseSettings> CREATOR = new Parcelable.Creator<ResultResponseSettings>() {\n        @Override\n        public ResultResponseSettings createFromParcel(Parcel source) {\n            return new ResultResponseSettings(source);\n        }\n        @Override\n        public ResultResponseSettings[] newArray(int size) {\n            return new ResultResponseSettings[size];\n        }\n    };\n"]]}
{"hexsha": "2a9ca0c3eaf49c3dd6f62664cefcd0fc221221e9", "ext": "java", "lang": "Java", "content": "class _022ArrayPairSumTest {\n\n\tprivate _022ArrayPairSum pairSum = new _022ArrayPairSum();\n\n\t/**\n\t * Test method for\n\t * {@link org.redquark.ramanujan.mustdos._022ArrayPairSum#findPairs(int[], int)}.\n\t */\n\t@Test\n\tvoid testFindPairs() {\n\t\tint[] a = new int[] { 1, 5, 7, -1, 5 };\n\t\tint sum = 6;\n\t\tSet<Pair> expected = new HashSet<>();\n\t\texpected.add(new Pair(1, 5));\n\t\texpected.add(new Pair(7, -1));\n\t\tassertTrue(expected.equals(pairSum.findPairs(a, sum)));\n\n\t\ta = new int[] { 2, 5, 17, -1 };\n\t\tsum = 7;\n\t\texpected = new HashSet<>();\n\t\texpected.add(new Pair(2, 5));\n\t\tassertTrue(expected.equals(pairSum.findPairs(a, sum)));\n\t}\n\n}", "class_id": 0, "repo": "ani03sha/Project-Ramanujam", "file": "MustDos/src/test/java/org/redquark/ramanujan/mustdos/_022ArrayPairSumTest.java", "last_update_at": "2020-01-12T15:30:36+00:00", "question_id": "2a9ca0c3eaf49c3dd6f62664cefcd0fc221221e9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class _022ArrayPairSumTest {\n\tprivate _022ArrayPairSum pairSum = new _022ArrayPairSum();\n\t/**\n\t * Test method for\n\t * {@link org.redquark.ramanujan.mustdos._022ArrayPairSum#findPairs(int[], int)}.\n\t */\n\t@Test\n\tvoid testFindPairs() {\n\t\tint[] a = new int[] { 1, 5, 7, -1, 5 };\n\t\tint sum = 6;\n\t\tSet<Pair> expected = new HashSet<>();\n\t\texpected.add(new Pair(1, 5));\n\t\texpected.add(new Pair(7, -1));\n\t\tassertTrue(expected.equals(pairSum.findPairs(a, sum)));\n\t\ta = new int[] { 2, 5, 17, -1 };\n\t\tsum = 7;\n\t\texpected = new HashSet<>();\n\t\texpected.add(new Pair(2, 5));\n\t\tassertTrue(expected.equals(pairSum.findPairs(a, sum)));\n\t}\n"]]}
{"hexsha": "7935421d6050f2068428026103881b70fc142976", "ext": "java", "lang": "Java", "content": "@ExtendWith(MockitoExtension.class)\n@TestInstance(TestInstance.Lifecycle.PER_CLASS)\nclass FixedAssetsInvestmentsHandlerTest {\n\n    @Mock\n    private ApiClient apiClient;\n\n    @Mock\n    private SmallFullService smallFullService;\n\n    @Mock\n    private SmallFullResourceHandler smallFullResourceHandler;\n\n    @Mock\n    private FixedAssetsInvestmentsGet fixedAssetsInvestmentsGet;\n\n    @Mock\n    private FixedAssetsInvestmentsUpdate fixedAssetsInvestmentsUpdate;\n\n    @Mock\n    private FixedAssetsInvestmentsDelete fixedAssetsInvestmentsDelete;\n\n    @Mock\n    private FixedAssetsInvestmentsCreate fixedAssetsInvestmentsCreate;\n\n    @Mock\n    private FixedAssetsInvestmentsApi fixedAssetsInvestmentsApi;\n\n    @Mock\n    private SmallFullLinks smallFullLinks;\n\n    @Mock\n    private SmallFullApi smallFullApi;\n\n    @Mock\n    private FixedAssetsInvestmentsResourceHandler fixedAssetsInvestmentsResourceHandler;\n\n    @InjectMocks\n    private FixedAssetsInvestmentsHandler fixedAssetsInvestmentsHandler;\n\n    private static final String COMPANY_ACCOUNTS_ID = \"companyAccountsId\";\n    private static final String TRANSACTION_ID = \"transactionId\";\n\n    private static final String URI = \"/transactions/\" + TRANSACTION_ID + \"/company-accounts/\" +\n            COMPANY_ACCOUNTS_ID + \"/small-full/notes/fixed-assets-investments\";\n\n    private static final String FIXED_ASSETS_INVESTMENTS_NOTE = \"fixedAssetsInvestment\";\n\n    @Test\n    @DisplayName(\"Get FixedAssetsInvestments resource URI\")\n    void getFixedAssetsInvestmentsURI() {\n        assertEquals(URI, fixedAssetsInvestmentsHandler.getUri(TRANSACTION_ID, COMPANY_ACCOUNTS_ID));\n    }\n\n    @Test\n    @DisplayName(\"Get FixedAssetsInvestments Resource\")\n    void getFixedAssetsInvestmentsResource() {\n\n        setupFixedAssetsInvestmentsHandler();\n\n        when(fixedAssetsInvestmentsHandler.get(apiClient, URI)).thenReturn(fixedAssetsInvestmentsGet);\n\n        Executor<ApiResponse<FixedAssetsInvestmentsApi>> getFixedAssetsInvestmentsApi = fixedAssetsInvestmentsHandler.get(apiClient, URI);\n\n        assertNotNull(getFixedAssetsInvestmentsApi);\n        assertEquals(getFixedAssetsInvestmentsApi, fixedAssetsInvestmentsGet);\n    }\n\n    @Test\n    @DisplayName(\"Update FixedAssetsInvestments Resource\")\n    void updateFixedAssetsInvestmentsResource() {\n\n        setupFixedAssetsInvestmentsHandler();\n\n        when(fixedAssetsInvestmentsHandler.update(apiClient, URI, fixedAssetsInvestmentsApi)).thenReturn(fixedAssetsInvestmentsUpdate);\n\n        Executor<ApiResponse<Void>> updatedFixedAssetsInvestments = fixedAssetsInvestmentsHandler.update(apiClient, URI, fixedAssetsInvestmentsApi);\n\n        assertNotNull(updatedFixedAssetsInvestments);\n        assertEquals(updatedFixedAssetsInvestments, fixedAssetsInvestmentsUpdate);\n    }\n\n    @Test\n    @DisplayName(\"Create FixedAssetsInvestments Resource\")\n    void createFixedAssetsInvestmentsResource() {\n\n        setupFixedAssetsInvestmentsHandler();\n\n        when(fixedAssetsInvestmentsHandler.create(apiClient, URI, fixedAssetsInvestmentsApi)).thenReturn(fixedAssetsInvestmentsCreate);\n\n        Executor<ApiResponse<FixedAssetsInvestmentsApi>> createFixedAssetsInvestments = fixedAssetsInvestmentsHandler.create(apiClient, URI, fixedAssetsInvestmentsApi);\n\n        assertNotNull(createFixedAssetsInvestments);\n        assertEquals(createFixedAssetsInvestments, fixedAssetsInvestmentsCreate);\n    }\n\n    @Test\n    @DisplayName(\"Delete FixedAssetsInvestments Resource\")\n    void deleteFixedAssetsInvestmentsResource() {\n\n        setupFixedAssetsInvestmentsHandler();\n\n        when(fixedAssetsInvestmentsHandler.delete(apiClient, URI)).thenReturn(fixedAssetsInvestmentsDelete);\n\n        Executor<ApiResponse<Void>> deleteFixedAssetsInvestmentsApi = fixedAssetsInvestmentsHandler.delete(apiClient, URI);\n\n        assertNotNull(deleteFixedAssetsInvestmentsApi);\n        assertEquals(deleteFixedAssetsInvestmentsApi, fixedAssetsInvestmentsDelete);\n    }\n\n    @Test\n    @DisplayName(\"Test parent resource exist\")\n    void testParentResourceExist() throws ServiceException {\n\n        when(smallFullService.getSmallFullAccounts(apiClient, TRANSACTION_ID, COMPANY_ACCOUNTS_ID)).thenReturn(smallFullApi);\n        when(smallFullApi.getLinks()).thenReturn(smallFullLinks);\n        when(smallFullLinks.getFixedAssetsInvestmentsNote()).thenReturn(FIXED_ASSETS_INVESTMENTS_NOTE);\n\n        assertTrue(fixedAssetsInvestmentsHandler.parentResourceExists(apiClient, TRANSACTION_ID, COMPANY_ACCOUNTS_ID));\n    }\n\n    @Test\n    @DisplayName(\"Test parent resource throws service exception\")\n    void testParentResourceThrowsServiceException() throws ServiceException {\n\n        when(smallFullService.getSmallFullAccounts(apiClient, TRANSACTION_ID, COMPANY_ACCOUNTS_ID)).thenThrow(ServiceException.class);\n\n        assertThrows(ServiceException.class, () -> fixedAssetsInvestmentsHandler.parentResourceExists(apiClient, TRANSACTION_ID, COMPANY_ACCOUNTS_ID));\n    }\n\n    @Test\n    @DisplayName(\"Test method returns FixedAssetsInvestments as NoteType\")\n    void testFixedAssetsInvestmentsReturned() {\n\n        assertEquals(NoteType.SMALL_FULL_FIXED_ASSETS_INVESTMENT, fixedAssetsInvestmentsHandler.getNoteType());\n    }\n\n    private void setupFixedAssetsInvestmentsHandler() {\n\n        when(apiClient.smallFull()).thenReturn(smallFullResourceHandler);\n        when(smallFullResourceHandler.fixedAssetsInvestments()).thenReturn(fixedAssetsInvestmentsResourceHandler);\n    }\n}", "class_id": 0, "repo": "companieshouse/company-accounts.web.ch.gov.uk", "file": "src/test/java/uk/gov/companieshouse/web/accounts/service/notehandler/smallfull/FixedAssetsInvestmentsHandlerTest.java", "last_update_at": "2020-01-28T11:28:16+00:00", "question_id": "7935421d6050f2068428026103881b70fc142976", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ExtendWith(MockitoExtension.class)\n@TestInstance(TestInstance.Lifecycle.PER_CLASS)\nclass FixedAssetsInvestmentsHandlerTest {\n    @Mock\n    private ApiClient apiClient;\n    @Mock\n    private SmallFullService smallFullService;\n    @Mock\n    private SmallFullResourceHandler smallFullResourceHandler;\n    @Mock\n    private FixedAssetsInvestmentsGet fixedAssetsInvestmentsGet;\n    @Mock\n    private FixedAssetsInvestmentsUpdate fixedAssetsInvestmentsUpdate;\n    @Mock\n    private FixedAssetsInvestmentsDelete fixedAssetsInvestmentsDelete;\n    @Mock\n    private FixedAssetsInvestmentsCreate fixedAssetsInvestmentsCreate;\n    @Mock\n    private FixedAssetsInvestmentsApi fixedAssetsInvestmentsApi;\n    @Mock\n    private SmallFullLinks smallFullLinks;\n    @Mock\n    private SmallFullApi smallFullApi;\n    @Mock\n    private FixedAssetsInvestmentsResourceHandler fixedAssetsInvestmentsResourceHandler;\n    @InjectMocks\n    private FixedAssetsInvestmentsHandler fixedAssetsInvestmentsHandler;\n    private static final String COMPANY_ACCOUNTS_ID = \"companyAccountsId\";\n    private static final String TRANSACTION_ID = \"transactionId\";\n    private static final String URI = \"/transactions/\" + TRANSACTION_ID + \"/company-accounts/\" +\n            COMPANY_ACCOUNTS_ID + \"/small-full/notes/fixed-assets-investments\";\n    private static final String FIXED_ASSETS_INVESTMENTS_NOTE = \"fixedAssetsInvestment\";\n    @Test\n    @DisplayName(\"Get FixedAssetsInvestments resource URI\")\n    void getFixedAssetsInvestmentsURI() {\n        assertEquals(URI, fixedAssetsInvestmentsHandler.getUri(TRANSACTION_ID, COMPANY_ACCOUNTS_ID));\n    }\n    @Test\n    @DisplayName(\"Get FixedAssetsInvestments Resource\")\n    void getFixedAssetsInvestmentsResource() {\n        setupFixedAssetsInvestmentsHandler();\n        when(fixedAssetsInvestmentsHandler.get(apiClient, URI)).thenReturn(fixedAssetsInvestmentsGet);\n        Executor<ApiResponse<FixedAssetsInvestmentsApi>> getFixedAssetsInvestmentsApi = fixedAssetsInvestmentsHandler.get(apiClient, URI);\n        assertNotNull(getFixedAssetsInvestmentsApi);\n        assertEquals(getFixedAssetsInvestmentsApi, fixedAssetsInvestmentsGet);\n    }\n    @Test\n    @DisplayName(\"Update FixedAssetsInvestments Resource\")\n    void updateFixedAssetsInvestmentsResource() {\n        setupFixedAssetsInvestmentsHandler();\n        when(fixedAssetsInvestmentsHandler.update(apiClient, URI, fixedAssetsInvestmentsApi)).thenReturn(fixedAssetsInvestmentsUpdate);\n        Executor<ApiResponse<Void>> updatedFixedAssetsInvestments = fixedAssetsInvestmentsHandler.update(apiClient, URI, fixedAssetsInvestmentsApi);\n        assertNotNull(updatedFixedAssetsInvestments);\n        assertEquals(updatedFixedAssetsInvestments, fixedAssetsInvestmentsUpdate);\n    }\n    @Test\n    @DisplayName(\"Create FixedAssetsInvestments Resource\")\n    void createFixedAssetsInvestmentsResource() {\n        setupFixedAssetsInvestmentsHandler();\n        when(fixedAssetsInvestmentsHandler.create(apiClient, URI, fixedAssetsInvestmentsApi)).thenReturn(fixedAssetsInvestmentsCreate);\n        Executor<ApiResponse<FixedAssetsInvestmentsApi>> createFixedAssetsInvestments = fixedAssetsInvestmentsHandler.create(apiClient, URI, fixedAssetsInvestmentsApi);\n        assertNotNull(createFixedAssetsInvestments);\n        assertEquals(createFixedAssetsInvestments, fixedAssetsInvestmentsCreate);\n    }\n    @Test\n    @DisplayName(\"Delete FixedAssetsInvestments Resource\")\n    void deleteFixedAssetsInvestmentsResource() {\n        setupFixedAssetsInvestmentsHandler();\n        when(fixedAssetsInvestmentsHandler.delete(apiClient, URI)).thenReturn(fixedAssetsInvestmentsDelete);\n        Executor<ApiResponse<Void>> deleteFixedAssetsInvestmentsApi = fixedAssetsInvestmentsHandler.delete(apiClient, URI);\n        assertNotNull(deleteFixedAssetsInvestmentsApi);\n        assertEquals(deleteFixedAssetsInvestmentsApi, fixedAssetsInvestmentsDelete);\n    }\n    @Test\n    @DisplayName(\"Test parent resource exist\")\n    void testParentResourceExist() throws ServiceException {\n        when(smallFullService.getSmallFullAccounts(apiClient, TRANSACTION_ID, COMPANY_ACCOUNTS_ID)).thenReturn(smallFullApi);\n        when(smallFullApi.getLinks()).thenReturn(smallFullLinks);\n        when(smallFullLinks.getFixedAssetsInvestmentsNote()).thenReturn(FIXED_ASSETS_INVESTMENTS_NOTE);\n        assertTrue(fixedAssetsInvestmentsHandler.parentResourceExists(apiClient, TRANSACTION_ID, COMPANY_ACCOUNTS_ID));\n    }\n    @Test\n    @DisplayName(\"Test parent resource throws service exception\")\n    void testParentResourceThrowsServiceException() throws ServiceException {\n        when(smallFullService.getSmallFullAccounts(apiClient, TRANSACTION_ID, COMPANY_ACCOUNTS_ID)).thenThrow(ServiceException.class);\n        assertThrows(ServiceException.class, () -> fixedAssetsInvestmentsHandler.parentResourceExists(apiClient, TRANSACTION_ID, COMPANY_ACCOUNTS_ID));\n    }\n    @Test\n    @DisplayName(\"Test method returns FixedAssetsInvestments as NoteType\")\n    void testFixedAssetsInvestmentsReturned() {\n        assertEquals(NoteType.SMALL_FULL_FIXED_ASSETS_INVESTMENT, fixedAssetsInvestmentsHandler.getNoteType());\n    }\n    private void setupFixedAssetsInvestmentsHandler() {\n        when(apiClient.smallFull()).thenReturn(smallFullResourceHandler);\n        when(smallFullResourceHandler.fixedAssetsInvestments()).thenReturn(fixedAssetsInvestmentsResourceHandler);\n    }\n"]]}
{"hexsha": "7dc47f44ae1c80df2f9e4704ae2dafa18a3c4733", "ext": "java", "lang": "Java", "content": "public class DexParser {\n\n    private CountingInputStream in;\n    private ByteOrder byteOrder = ByteOrder.LITTLE;\n\n    private static final int NO_INDEX = 0xffffffff;\n\n    private DexClass[] dexClasses;\n\n    public DexParser(InputStream in) {\n        this.in = new CountingInputStream(in, byteOrder);\n    }\n\n    public void parse() throws IOException {\n        // read magic\n        String magic = in.readChars(8);\n        if (!magic.startsWith(\"dex\\n\")) {\n            return;\n        }\n        int version = Integer.parseInt(magic.substring(4, 7));\n        // now the version is 035\n        if (version < 35) {\n            // version 009 was used for the M3 releases of the Android platform (November\u2013December 2007),\n            // and version 013 was used for the M5 releases of the Android platform (February\u2013March 2008)\n            throw new ParserException(\"Dex file version: \" + version + \" is not supported\");\n        }\n\n        // read header\n        DexHeader header = readDexHeader();\n        header.version = version;\n\n        // read string pool\n        long[] stringOffsets = readStringPool(header.stringIdsOff, header.stringIdsSize);\n\n        // read types\n        int[] typeIds = readTypes(header.typeIdsOff, header.typeIdsSize);\n\n        // read classes\n        DexClassStruct[] dexClassStructs = readClass(header.classDefsOff, header.classDefsSize);\n\n        StringPool stringpool = readStrings(stringOffsets);\n\n        String[] types = new String[typeIds.length];\n        for (int i = 0; i < typeIds.length; i++) {\n            types[i] = stringpool.get(typeIds[i]);\n        }\n\n        dexClasses = new DexClass[dexClassStructs.length];\n        for (int i = 0; i < dexClasses.length; i++) {\n            dexClasses[i] = new DexClass();\n        }\n        for (int i = 0; i < dexClassStructs.length; i++) {\n            DexClassStruct dexClassStruct = dexClassStructs[i];\n            DexClass dexClass = dexClasses[i];\n            dexClass.setClassType(types[dexClassStruct.classIdx]);\n            if (dexClassStruct.superclassIdx != NO_INDEX) {\n                dexClass.setSuperClass(types[dexClassStruct.superclassIdx]);\n            }\n            dexClass.setAccessFlags(dexClassStruct.accessFlags);\n        }\n    }\n\n    /**\n     * read class info.\n     */\n    private DexClassStruct[] readClass(long classDefsOff, int classDefsSize) throws IOException {\n        in.advanceTo(classDefsOff);\n\n        DexClassStruct[] dexClassStructs = new DexClassStruct[classDefsSize];\n        for (int i = 0; i < classDefsSize; i++) {\n            DexClassStruct dexClassStruct = new DexClassStruct();\n            dexClassStruct.classIdx = in.readInt();\n\n            dexClassStruct.accessFlags = in.readInt();\n            dexClassStruct.superclassIdx = in.readInt();\n\n            dexClassStruct.interfacesOff = in.readUInt();\n            dexClassStruct.sourceFileIdx = in.readInt();\n            dexClassStruct.annotationsOff = in.readUInt();\n            dexClassStruct.classDataOff = in.readUInt();\n            dexClassStruct.staticValuesOff = in.readUInt();\n            dexClassStructs[i] = dexClassStruct;\n        }\n\n        return dexClassStructs;\n    }\n\n    /**\n     * read types.\n     */\n    private int[] readTypes(long typeIdsOff, int typeIdsSize) throws IOException {\n        in.advanceTo(typeIdsOff);\n        int[] typeIds = new int[typeIdsSize];\n        for (int i = 0; i < typeIdsSize; i++) {\n            typeIds[i] = (int) in.readUInt();\n        }\n        return typeIds;\n    }\n\n    /**\n     * read string pool for dex file.\n     * dex file string pool diff a bit with binary xml file or resource table.\n     *\n     * @param offsets\n     * @return\n     * @throws IOException\n     */\n    private StringPool readStrings(long[] offsets) throws IOException {\n        // read strings.\n        // in some apk, the strings' offsets may not well ordered. we sort it first\n\n        StringPoolEntry[] entries = new StringPoolEntry[offsets.length];\n        for (int i = 0; i < offsets.length; i++) {\n            entries[i] = new StringPoolEntry(i, offsets[i]);\n        }\n        Arrays.sort(entries);\n\n        String lastStr = null;\n        long lastOffset = -1;\n        StringPool stringpool = new StringPool(offsets.length);\n        for (StringPoolEntry entry : entries) {\n            if (entry.getOffset() == lastOffset) {\n                stringpool.set(entry.getIdx(), lastStr);\n                continue;\n            }\n            in.advanceTo(entry.getOffset());\n            lastOffset = entry.getOffset();\n            String str = readString();\n            lastStr = str;\n            stringpool.set(entry.getIdx(), str);\n        }\n        return stringpool;\n    }\n\n    /*\n     * read string identifiers list.\n     */\n    private long[] readStringPool(long stringIdsOff, int stringIdsSize) throws IOException {\n        in.advanceTo(stringIdsOff);\n        long offsets[] = new long[stringIdsSize];\n        for (int i = 0; i < stringIdsSize; i++) {\n            offsets[i] = in.readUInt();\n        }\n\n        return offsets;\n    }\n\n    /**\n     * read dex encoding string.\n     */\n    private String readString() throws IOException {\n        // the length is char len, not byte len\n        int strLen = readVarInts();\n        try {\n            return readString(strLen);\n        } catch (UTFDataFormatException e) {\n            return \"\";\n        }\n    }\n\n    /**\n     * read Modified UTF-8 encoding str.\n     *\n     * @param strLen the java-utf16-char len, not strLen nor bytes len.\n     */\n    private String readString(int strLen) throws IOException {\n        char[] chars = new char[strLen];\n        for (int i = 0; i < strLen; i++) {\n            short a = in.readUByte();\n            if ((a & 0x80) == 0) {\n                // ascii char\n                chars[i] = (char) a;\n            } else if ((a & 0xe0) == 0xc0) {\n                // read one more\n                short b = in.readUByte();\n                chars[i] = (char) (((a & 0x1F) << 6) | (b & 0x3F));\n            } else if ((a & 0xf0) == 0xe0) {\n                short b = in.readUByte();\n                short c = in.readUByte();\n                chars[i] = (char) (((a & 0x0F) << 12) | ((b & 0x3F) << 6) | (c & 0x3F));\n            } else if ((a & 0xf0) == 0xf0) {\n                throw new UTFDataFormatException();\n            } else {\n                throw new UTFDataFormatException();\n            }\n            if (chars[i] == 0) {\n                // the end of string.\n            }\n        }\n\n        return new String(chars);\n    }\n\n\n    /**\n     * read varints.\n     *\n     * @return\n     * @throws IOException\n     */\n    private int readVarInts() throws IOException {\n        int i = 0;\n        int count = 0;\n        short s;\n        do {\n            if (count > 4) {\n                throw new ParserException(\"read varints error.\");\n            }\n            s = in.readUByte();\n            i |= (s & 0x7f) << (count * 7);\n            count++;\n        } while ((s & 0x80) != 0);\n\n        return i;\n    }\n\n    private DexHeader readDexHeader() throws IOException {\n\n        // check sum. skip\n        in.readUInt();\n\n        // signature skip\n        in.readBytes(DexHeader.kSHA1DigestLen);\n\n        DexHeader header = new DexHeader();\n        header.fileSize = in.readUInt();\n        header.headerSize = in.readUInt();\n\n        // skip?\n        in.readUInt();\n\n        // static link data\n        header.linkSize = in.readUInt();\n        header.linkOff = in.readUInt();\n\n        // the map data is just the same as dex header.\n        header.mapOff = in.readUInt();\n\n        header.stringIdsSize = in.readInt();\n        header.stringIdsOff = in.readUInt();\n\n        header.typeIdsSize = in.readInt();\n        header.typeIdsOff = in.readUInt();\n\n        header.protoIdsSize = in.readInt();\n        header.protoIdsOff = in.readUInt();\n\n        header.fieldIdsSize = in.readInt();\n        header.fieldIdsOff = in.readUInt();\n\n        header.methodIdsSize = in.readInt();\n        header.methodIdsOff = in.readUInt();\n\n        header.classDefsSize = in.readInt();\n        header.classDefsOff = in.readUInt();\n\n        header.dataSize = in.readInt();\n        header.dataOff = in.readUInt();\n\n        in.advanceTo(header.headerSize);\n\n        return header;\n    }\n\n    public DexClass[] getDexClasses() {\n        return dexClasses;\n    }\n\n}", "class_id": 0, "repo": "kanpol/resource-parser", "file": "src/main/java/net/dongliu/apk/parser/parser/DexParser.java", "last_update_at": "2020-04-22T17:15:45+00:00", "question_id": "7dc47f44ae1c80df2f9e4704ae2dafa18a3c4733", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DexParser {\n    private CountingInputStream in;\n    private ByteOrder byteOrder = ByteOrder.LITTLE;\n    private static final int NO_INDEX = 0xffffffff;\n    private DexClass[] dexClasses;\n    public DexParser(InputStream in) {\n        this.in = new CountingInputStream(in, byteOrder);\n    }\n    public void parse() throws IOException {\n        // read magic\n        String magic = in.readChars(8);\n        if (!magic.startsWith(\"dex\\n\")) {\n            return;\n        }\n        int version = Integer.parseInt(magic.substring(4, 7));\n        // now the version is 035\n        if (version < 35) {\n            // version 009 was used for the M3 releases of the Android platform (November\u2013December 2007),\n            // and version 013 was used for the M5 releases of the Android platform (February\u2013March 2008)\n            throw new ParserException(\"Dex file version: \" + version + \" is not supported\");\n        }\n        // read header\n        DexHeader header = readDexHeader();\n        header.version = version;\n        // read string pool\n        long[] stringOffsets = readStringPool(header.stringIdsOff, header.stringIdsSize);\n        // read types\n        int[] typeIds = readTypes(header.typeIdsOff, header.typeIdsSize);\n        // read classes\n        DexClassStruct[] dexClassStructs = readClass(header.classDefsOff, header.classDefsSize);\n        StringPool stringpool = readStrings(stringOffsets);\n        String[] types = new String[typeIds.length];\n        for (int i = 0; i < typeIds.length; i++) {\n            types[i] = stringpool.get(typeIds[i]);\n        }\n        dexClasses = new DexClass[dexClassStructs.length];\n        for (int i = 0; i < dexClasses.length; i++) {\n            dexClasses[i] = new DexClass();\n        }\n        for (int i = 0; i < dexClassStructs.length; i++) {\n            DexClassStruct dexClassStruct = dexClassStructs[i];\n            DexClass dexClass = dexClasses[i];\n            dexClass.setClassType(types[dexClassStruct.classIdx]);\n            if (dexClassStruct.superclassIdx != NO_INDEX) {\n                dexClass.setSuperClass(types[dexClassStruct.superclassIdx]);\n            }\n            dexClass.setAccessFlags(dexClassStruct.accessFlags);\n        }\n    }\n    /**\n     * read class info.\n     */\n    private DexClassStruct[] readClass(long classDefsOff, int classDefsSize) throws IOException {\n        in.advanceTo(classDefsOff);\n        DexClassStruct[] dexClassStructs = new DexClassStruct[classDefsSize];\n        for (int i = 0; i < classDefsSize; i++) {\n            DexClassStruct dexClassStruct = new DexClassStruct();\n            dexClassStruct.classIdx = in.readInt();\n            dexClassStruct.accessFlags = in.readInt();\n            dexClassStruct.superclassIdx = in.readInt();\n            dexClassStruct.interfacesOff = in.readUInt();\n            dexClassStruct.sourceFileIdx = in.readInt();\n            dexClassStruct.annotationsOff = in.readUInt();\n            dexClassStruct.classDataOff = in.readUInt();\n            dexClassStruct.staticValuesOff = in.readUInt();\n            dexClassStructs[i] = dexClassStruct;\n        }\n        return dexClassStructs;\n    }\n    /**\n     * read types.\n     */\n    private int[] readTypes(long typeIdsOff, int typeIdsSize) throws IOException {\n        in.advanceTo(typeIdsOff);\n        int[] typeIds = new int[typeIdsSize];\n        for (int i = 0; i < typeIdsSize; i++) {\n            typeIds[i] = (int) in.readUInt();\n        }\n        return typeIds;\n    }\n    /**\n     * read string pool for dex file.\n     * dex file string pool diff a bit with binary xml file or resource table.\n     *\n     * @param offsets\n     * @return\n     * @throws IOException\n     */\n    private StringPool readStrings(long[] offsets) throws IOException {\n        // read strings.\n        // in some apk, the strings' offsets may not well ordered. we sort it first\n        StringPoolEntry[] entries = new StringPoolEntry[offsets.length];\n        for (int i = 0; i < offsets.length; i++) {\n            entries[i] = new StringPoolEntry(i, offsets[i]);\n        }\n        Arrays.sort(entries);\n        String lastStr = null;\n        long lastOffset = -1;\n        StringPool stringpool = new StringPool(offsets.length);\n        for (StringPoolEntry entry : entries) {\n            if (entry.getOffset() == lastOffset) {\n                stringpool.set(entry.getIdx(), lastStr);\n                continue;\n            }\n            in.advanceTo(entry.getOffset());\n            lastOffset = entry.getOffset();\n            String str = readString();\n            lastStr = str;\n            stringpool.set(entry.getIdx(), str);\n        }\n        return stringpool;\n    }\n    /*\n     * read string identifiers list.\n     */\n    private long[] readStringPool(long stringIdsOff, int stringIdsSize) throws IOException {\n        in.advanceTo(stringIdsOff);\n        long offsets[] = new long[stringIdsSize];\n        for (int i = 0; i < stringIdsSize; i++) {\n            offsets[i] = in.readUInt();\n        }\n        return offsets;\n    }\n    /**\n     * read dex encoding string.\n     */\n    private String readString() throws IOException {\n        // the length is char len, not byte len\n        int strLen = readVarInts();\n        try {\n            return readString(strLen);\n        } catch (UTFDataFormatException e) {\n            return \"\";\n        }\n    }\n    /**\n     * read Modified UTF-8 encoding str.\n     *\n     * @param strLen the java-utf16-char len, not strLen nor bytes len.\n     */\n    private String readString(int strLen) throws IOException {\n        char[] chars = new char[strLen];\n        for (int i = 0; i < strLen; i++) {\n            short a = in.readUByte();\n            if ((a & 0x80) == 0) {\n                // ascii char\n                chars[i] = (char) a;\n            } else if ((a & 0xe0) == 0xc0) {\n                // read one more\n                short b = in.readUByte();\n                chars[i] = (char) (((a & 0x1F) << 6) | (b & 0x3F));\n            } else if ((a & 0xf0) == 0xe0) {\n                short b = in.readUByte();\n                short c = in.readUByte();\n                chars[i] = (char) (((a & 0x0F) << 12) | ((b & 0x3F) << 6) | (c & 0x3F));\n            } else if ((a & 0xf0) == 0xf0) {\n                throw new UTFDataFormatException();\n            } else {\n                throw new UTFDataFormatException();\n            }\n            if (chars[i] == 0) {\n                // the end of string.\n            }\n        }\n        return new String(chars);\n    }\n    /**\n     * read varints.\n     *\n     * @return\n     * @throws IOException\n     */\n    private int readVarInts() throws IOException {\n        int i = 0;\n        int count = 0;\n        short s;\n        do {\n            if (count > 4) {\n                throw new ParserException(\"read varints error.\");\n            }\n            s = in.readUByte();\n            i |= (s & 0x7f) << (count * 7);\n            count++;\n        } while ((s & 0x80) != 0);\n        return i;\n    }\n    private DexHeader readDexHeader() throws IOException {\n        // check sum. skip\n        in.readUInt();\n        // signature skip\n        in.readBytes(DexHeader.kSHA1DigestLen);\n        DexHeader header = new DexHeader();\n        header.fileSize = in.readUInt();\n        header.headerSize = in.readUInt();\n        // skip?\n        in.readUInt();\n        // static link data\n        header.linkSize = in.readUInt();\n        header.linkOff = in.readUInt();\n        // the map data is just the same as dex header.\n        header.mapOff = in.readUInt();\n        header.stringIdsSize = in.readInt();\n        header.stringIdsOff = in.readUInt();\n        header.typeIdsSize = in.readInt();\n        header.typeIdsOff = in.readUInt();\n        header.protoIdsSize = in.readInt();\n        header.protoIdsOff = in.readUInt();\n        header.fieldIdsSize = in.readInt();\n        header.fieldIdsOff = in.readUInt();\n        header.methodIdsSize = in.readInt();\n        header.methodIdsOff = in.readUInt();\n        header.classDefsSize = in.readInt();\n        header.classDefsOff = in.readUInt();\n        header.dataSize = in.readInt();\n        header.dataOff = in.readUInt();\n        in.advanceTo(header.headerSize);\n        return header;\n    }\n    public DexClass[] getDexClasses() {\n        return dexClasses;\n    }\n"]]}
{"hexsha": "79d90f5d351dd78c45772f5bab87c78bec8d13e9", "ext": "java", "lang": "Java", "content": "@Immutable\n@Deprecated\nclass DefaultRedirectStrategyAdaptor implements RedirectStrategy {\n\n    private final ch.boye.httpclientandroidlib.client.RedirectHandler handler;\n\n    @Deprecated\n    public DefaultRedirectStrategyAdaptor(final ch.boye.httpclientandroidlib.client.RedirectHandler handler) {\n        super();\n        this.handler = handler;\n    }\n\n    public boolean isRedirected(\n            final HttpRequest request,\n            final HttpResponse response,\n            final HttpContext context) throws ProtocolException {\n        return this.handler.isRedirectRequested(response, context);\n    }\n\n    public HttpUriRequest getRedirect(\n            final HttpRequest request,\n            final HttpResponse response,\n            final HttpContext context) throws ProtocolException {\n        URI uri = this.handler.getLocationURI(response, context);\n        String method = request.getRequestLine().getMethod();\n        if (method.equalsIgnoreCase(HttpHead.METHOD_NAME)) {\n            return new HttpHead(uri);\n        } else {\n            return new HttpGet(uri);\n        }\n    }\n\n}", "class_id": 0, "repo": "wilebeast/FireFox-OS", "file": "B2G/gecko/mobile/android/base/httpclientandroidlib/impl/client/DefaultRedirectStrategyAdaptor.java", "last_update_at": "2020-04-24T20:31:29+00:00", "question_id": "79d90f5d351dd78c45772f5bab87c78bec8d13e9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Immutable\n@Deprecated\nclass DefaultRedirectStrategyAdaptor implements RedirectStrategy {\n    private final ch.boye.httpclientandroidlib.client.RedirectHandler handler;\n    @Deprecated\n    public DefaultRedirectStrategyAdaptor(final ch.boye.httpclientandroidlib.client.RedirectHandler handler) {\n        super();\n        this.handler = handler;\n    }\n    public boolean isRedirected(\n            final HttpRequest request,\n            final HttpResponse response,\n            final HttpContext context) throws ProtocolException {\n        return this.handler.isRedirectRequested(response, context);\n    }\n    public HttpUriRequest getRedirect(\n            final HttpRequest request,\n            final HttpResponse response,\n            final HttpContext context) throws ProtocolException {\n        URI uri = this.handler.getLocationURI(response, context);\n        String method = request.getRequestLine().getMethod();\n        if (method.equalsIgnoreCase(HttpHead.METHOD_NAME)) {\n            return new HttpHead(uri);\n        } else {\n            return new HttpGet(uri);\n        }\n    }\n"]]}
{"hexsha": "e55f13615981add2d55c3af4a7b96afe54485fac", "ext": "java", "lang": "Java", "content": "public class FormatProcess extends AbstractProcess {\r\n\r\n    private static final String GROUP_ID = \"net.revelc.code.formatter\";\r\n    private static final String ARTIFACT_ID = \"formatter-maven-plugin\";\r\n    private static final String GOAL = \"format\";\r\n    private static final String XML_CONFIG = \"config/formatter.xml\";\r\n\r\n    public FormatProcess(boolean skip, Config config, MavenContext element, Logger logger) {\r\n        super(\"FORMAT\", skip, config, element, logger);\r\n    }\r\n\r\n    @Override\r\n    public void executeInternal() throws Exception {\r\n        Plugin formatterPlugin = getPluginFromComponentDependency(GROUP_ID, ARTIFACT_ID);\r\n        assertPlugin(formatterPlugin, GROUP_ID, ARTIFACT_ID, \"<dependency>\");\r\n        String configFile;\r\n        File file = getMavenProjectFile(XML_CONFIG);\r\n        if (file.exists() && file.isFile()) {\r\n            configFile = file.getAbsolutePath();\r\n        } else {\r\n            configFile = processDefaultConfig(XML_CONFIG);\r\n        }\r\n        executeMojo(formatterPlugin,\r\n                goal(GOAL),\r\n                configuration(\r\n                        element(name(\"lineEnding\"), config.getLineEnding()),\r\n                        element(name(\"encoding\"), config.getEncoding()),\r\n                        element(name(\"configFile\"), configFile),\r\n                        element(name(\"skipCssFormatting\"), \"\" + config.isSkipCss()),\r\n                        element(name(\"skipHtmlFormatting\"), \"\" + config.isSkipHtml()),\r\n                        element(name(\"skipJavaFormatting\"), \"\" + config.isSkipJava()),\r\n                        element(name(\"skipJsFormatting\"), \"\" + config.isSkipJs()),\r\n                        element(name(\"skipJsonFormatting\"), \"\" + config.isSkipJson()),\r\n                        element(name(\"skipXmlFormatting\"), \"true\"),\r\n                        element(name(\"directories\"),\r\n                                element(name(\"directory\"), \"${basedir}/src/main/java\"),\r\n                                element(name(\"directory\"), \"${basedir}/src/main/webapp\"),\r\n                                element(name(\"directory\"), \"${basedir}/src/test/java\"),\r\n                                element(name(\"directory\"), \"${basedir}/src/test/webapp\")\r\n                        ),\r\n                        element(name(\"includes\"),\r\n                                element(name(\"include\"), \"**/*.java\"),\r\n                                element(name(\"include\"), \"**/*.html\"),\r\n                                element(name(\"include\"), \"**/*.xhtml\"),\r\n                                element(name(\"include\"), \"**/*.jsp\"),\r\n                                element(name(\"include\"), \"**/*.jspx\"),\r\n                                element(name(\"include\"), \"**/*.css\"),\r\n                                element(name(\"include\"), \"**/*.js\"),\r\n                                element(name(\"include\"), \"**/*.jsx\"),\r\n                                element(name(\"include\"), \"**/*.ts\"),\r\n                                element(name(\"include\"), \"**/*.tsx\"),\r\n                                element(name(\"include\"), \"**/*.json\")\r\n                        )\r\n                ),\r\n                executionEnvironment()\r\n        );\r\n    }\r\n\r\n}", "class_id": 0, "repo": "hiskasoft/hsk-maven-plugin", "file": "hiska-maven-plugin/src/main/java/com/hiskasoft/maven/internal/FormatProcess.java", "last_update_at": "2020-03-11T13:10:19+00:00", "question_id": "e55f13615981add2d55c3af4a7b96afe54485fac", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FormatProcess extends AbstractProcess {\r\n\r\n    private static final String GROUP_ID = \"net.revelc.code.formatter\";\r\n    private static final String ARTIFACT_ID = \"formatter-maven-plugin\";\r\n    private static final String GOAL = \"format\";\r\n    private static final String XML_CONFIG = \"config/formatter.xml\";\r\n\r\n    public FormatProcess(boolean skip, Config config, MavenContext element, Logger logger) {\r\n        super(\"FORMAT\", skip, config, element, logger);\r\n    }\r\n\r\n    @Override\r\n    public void executeInternal() throws Exception {\r\n        Plugin formatterPlugin = getPluginFromComponentDependency(GROUP_ID, ARTIFACT_ID);\r\n        assertPlugin(formatterPlugin, GROUP_ID, ARTIFACT_ID, \"<dependency>\");\r\n        String configFile;\r\n        File file = getMavenProjectFile(XML_CONFIG);\r\n        if (file.exists() && file.isFile()) {\r\n            configFile = file.getAbsolutePath();\r\n        } else {\r\n            configFile = processDefaultConfig(XML_CONFIG);\r\n        }\r\n        executeMojo(formatterPlugin,\r\n                goal(GOAL),\r\n                configuration(\r\n                        element(name(\"lineEnding\"), config.getLineEnding()),\r\n                        element(name(\"encoding\"), config.getEncoding()),\r\n                        element(name(\"configFile\"), configFile),\r\n                        element(name(\"skipCssFormatting\"), \"\" + config.isSkipCss()),\r\n                        element(name(\"skipHtmlFormatting\"), \"\" + config.isSkipHtml()),\r\n                        element(name(\"skipJavaFormatting\"), \"\" + config.isSkipJava()),\r\n                        element(name(\"skipJsFormatting\"), \"\" + config.isSkipJs()),\r\n                        element(name(\"skipJsonFormatting\"), \"\" + config.isSkipJson()),\r\n                        element(name(\"skipXmlFormatting\"), \"true\"),\r\n                        element(name(\"directories\"),\r\n                                element(name(\"directory\"), \"${basedir}/src/main/java\"),\r\n                                element(name(\"directory\"), \"${basedir}/src/main/webapp\"),\r\n                                element(name(\"directory\"), \"${basedir}/src/test/java\"),\r\n                                element(name(\"directory\"), \"${basedir}/src/test/webapp\")\r\n                        ),\r\n                        element(name(\"includes\"),\r\n                                element(name(\"include\"), \"**/*.java\"),\r\n                                element(name(\"include\"), \"**/*.html\"),\r\n                                element(name(\"include\"), \"**/*.xhtml\"),\r\n                                element(name(\"include\"), \"**/*.jsp\"),\r\n                                element(name(\"include\"), \"**/*.jspx\"),\r\n                                element(name(\"include\"), \"**/*.css\"),\r\n                                element(name(\"include\"), \"**/*.js\"),\r\n                                element(name(\"include\"), \"**/*.jsx\"),\r\n                                element(name(\"include\"), \"**/*.ts\"),\r\n                                element(name(\"include\"), \"**/*.tsx\"),\r\n                                element(name(\"include\"), \"**/*.json\")\r\n                        )\r\n                ),\r\n                executionEnvironment()\r\n        );\r\n    }\r\n\r\n"]]}
{"hexsha": "7c396a4665c4e1f18bdb7327881232a5e943c71b", "ext": "java", "lang": "Java", "content": "public class NavListCell extends ListCell<Item> {\n    CellController CC;\n\n    public NavListCell(EventHandler navEvent, String FXML) {\n        super();\n\n        this.CC = new CellController(navEvent, FXML);\n    }\n\n    @Override\n    public void updateItem(Item item, boolean empty) {\n        super.updateItem(item, empty);\n//        this.item = item;\n\n        if (empty) {\n            setGraphic(null);\n        } else {\n            CC.labelID.setText(item!=null ? \" \" + item.itemID + \" \" : \"<null>\");\n            CC.labelName.setText(item!=null ? item.itemName : \"<null>\");\n//            System.out.println(\"ID: \" + item.itemID);\n            CC.button.setId(item.itemID);\n            if (item.progress <= 0) {\n                if (item.progress < 0) {\n                    CC.progress.setText(\"ERROR\");\n                }\n            } else if (item.crawlSuccess) {\n                CC.progress.setText(Integer.toString(item.total));\n                CC.percent.setText(item.progress*100/item.pages + \"%\");\n            } else{\n                CC.progress.setText(item.progress + \"/\" + item.pages);\n                CC.percent.setText(item.progress*100/item.pages + \"%\");\n            }\n            CC.pb.setProgress((double) item.progress/item.pages);\n\n            setGraphic(CC.hbox);\n        }\n    }\n\n//    @Override\n//    protected void updateItem(AppBean app, boolean empty) {\n//        super.updateItem(app, empty);\n//        if (app == null) {\n//            setText(null);\n//            setGraphic(null);\n//            return;\n//        }\n//        if (null == itemRoot) {\n//            try {\n//                itemRoot = FXMLLoader.load(getClass().getResource((\"fxml/appList_item.fxml\")));\n//            } catch (IOException e) {\n//                throw new RuntimeException(e);\n//            }\n//            label_AppName = (Label) itemRoot.lookup(\"#item_Label_AppName\");\n//            imgv_AppIcon = (ImageView) itemRoot.lookup(\"#item_ImageView_AppIcon\");\n//            itemRoot.setOnMouseClicked(clickHandler);\n//        }\n//        //  set user data. like android's setTag(Object).\n//        itemRoot.setUserData(app);\n//        label_AppName.setText(app.name);\n//        imgv_AppIcon.setImage(new Image(getClass().getResource(\"img/icon_64.png\").toExternalForm()));\n//        setGraphic(itemRoot);\n//    }\n}", "class_id": 0, "repo": "kev007/amazon-review-analyser", "file": "src/View/ListView/NavListCell.java", "last_update_at": "2020-04-08T13:47:16+00:00", "question_id": "7c396a4665c4e1f18bdb7327881232a5e943c71b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NavListCell extends ListCell<Item> {\n    CellController CC;\n    public NavListCell(EventHandler navEvent, String FXML) {\n        super();\n        this.CC = new CellController(navEvent, FXML);\n    }\n    @Override\n    public void updateItem(Item item, boolean empty) {\n        super.updateItem(item, empty);\n//        this.item = item;\n        if (empty) {\n            setGraphic(null);\n        } else {\n            CC.labelID.setText(item!=null ? \" \" + item.itemID + \" \" : \"<null>\");\n            CC.labelName.setText(item!=null ? item.itemName : \"<null>\");\n//            System.out.println(\"ID: \" + item.itemID);\n            CC.button.setId(item.itemID);\n            if (item.progress <= 0) {\n                if (item.progress < 0) {\n                    CC.progress.setText(\"ERROR\");\n                }\n            } else if (item.crawlSuccess) {\n                CC.progress.setText(Integer.toString(item.total));\n                CC.percent.setText(item.progress*100/item.pages + \"%\");\n            } else{\n                CC.progress.setText(item.progress + \"/\" + item.pages);\n                CC.percent.setText(item.progress*100/item.pages + \"%\");\n            }\n            CC.pb.setProgress((double) item.progress/item.pages);\n            setGraphic(CC.hbox);\n        }\n    }\n//    @Override\n//    protected void updateItem(AppBean app, boolean empty) {\n//        super.updateItem(app, empty);\n//        if (app == null) {\n//            setText(null);\n//            setGraphic(null);\n//            return;\n//        }\n//        if (null == itemRoot) {\n//            try {\n//                itemRoot = FXMLLoader.load(getClass().getResource((\"fxml/appList_item.fxml\")));\n//            } catch (IOException e) {\n//                throw new RuntimeException(e);\n//            }\n//            label_AppName = (Label) itemRoot.lookup(\"#item_Label_AppName\");\n//            imgv_AppIcon = (ImageView) itemRoot.lookup(\"#item_ImageView_AppIcon\");\n//            itemRoot.setOnMouseClicked(clickHandler);\n//        }\n//        //  set user data. like android's setTag(Object).\n//        itemRoot.setUserData(app);\n//        label_AppName.setText(app.name);\n//        imgv_AppIcon.setImage(new Image(getClass().getResource(\"img/icon_64.png\").toExternalForm()));\n//        setGraphic(itemRoot);\n//    }\n"]]}
{"hexsha": "a3a26c5cab8bf4fa3d1459a05160e3090acda6aa", "ext": "java", "lang": "Java", "content": "public class BukkitRepository<T> {\n\n    private final Plugin plugin;\n\n    private boolean async;\n    private Function<Player, T> loadAction, findAction;\n    private BiConsumer<Player, T> saveAction, onLoaded, onSaved;\n\n    public BukkitRepository(Plugin plugin) {\n        this.plugin = plugin;\n        this.async = ImanityCommon.CORE_CONFIG.ASYNCHRONOUS_DATA_STORING;\n    }\n\n    public BukkitRepository<T> async() {\n        this.async = true;\n        return this;\n    }\n\n    public BukkitRepository<T> load(Function<Player, T> loadAction) {\n        this.loadAction = loadAction;\n        return this;\n    }\n\n    public BukkitRepository<T> find(Function<Player, T> findAction) {\n        this.findAction = findAction;\n        return this;\n    }\n\n    public BukkitRepository<T> save(BiConsumer<Player, T> saveAction) {\n        this.saveAction = saveAction;\n        return this;\n    }\n\n    public BukkitRepository<T> onLoaded(BiConsumer<Player, T> consumer) {\n        this.onLoaded = consumer;\n        return this;\n    }\n\n    public BukkitRepository<T> onSaved(BiConsumer<Player, T> consumer) {\n        this.onSaved = consumer;\n        return this;\n    }\n\n    public void init() {\n        Preconditions.checkNotNull(this.loadAction, \"The loadAction is not being set!\");\n\n        Events.subscribe(PlayerJoinEvent.class)\n                .listen((subscription, event) -> {\n                    Player player = event.getPlayer();\n\n                    Runnable runnable = () -> {\n                        T t = this.loadAction.apply(player);\n                        if (this.onLoaded != null) {\n                            this.onLoaded.accept(player, t);\n                        }\n                    };\n\n                    if (this.async) {\n                        TaskUtil.runAsync(runnable);\n                    } else {\n                        runnable.run();\n                    }\n                })\n        .build(plugin);\n\n        if (this.saveAction != null) {\n            Events.subscribe(PlayerQuitEvent.class)\n                    .listen((subscription, event) -> {\n                        Player player = event.getPlayer();\n\n                        Runnable runnable = () -> {\n                            T t = findAction != null ? findAction.apply(player) : loadAction.apply(player);\n                            this.saveAction.accept(player, t);\n                            if (this.onSaved != null) {\n                                this.onSaved.accept(player, t);\n                            }\n                        };\n\n                        if (this.async) {\n                            TaskUtil.runAsync(runnable);\n                        } else {\n                            runnable.run();\n                        }\n                    })\n                    .build(plugin);\n        }\n    }\n\n}", "class_id": 0, "repo": "LeeGodSRC/ImanityFramework", "file": "bukkit/bukkit-common/src/main/java/org/imanity/framework/bukkit/BukkitRepository.java", "last_update_at": "2020-12-14T11:51:40+00:00", "question_id": "a3a26c5cab8bf4fa3d1459a05160e3090acda6aa", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BukkitRepository<T> {\n    private final Plugin plugin;\n    private boolean async;\n    private Function<Player, T> loadAction, findAction;\n    private BiConsumer<Player, T> saveAction, onLoaded, onSaved;\n    public BukkitRepository(Plugin plugin) {\n        this.plugin = plugin;\n        this.async = ImanityCommon.CORE_CONFIG.ASYNCHRONOUS_DATA_STORING;\n    }\n    public BukkitRepository<T> async() {\n        this.async = true;\n        return this;\n    }\n    public BukkitRepository<T> load(Function<Player, T> loadAction) {\n        this.loadAction = loadAction;\n        return this;\n    }\n    public BukkitRepository<T> find(Function<Player, T> findAction) {\n        this.findAction = findAction;\n        return this;\n    }\n    public BukkitRepository<T> save(BiConsumer<Player, T> saveAction) {\n        this.saveAction = saveAction;\n        return this;\n    }\n    public BukkitRepository<T> onLoaded(BiConsumer<Player, T> consumer) {\n        this.onLoaded = consumer;\n        return this;\n    }\n    public BukkitRepository<T> onSaved(BiConsumer<Player, T> consumer) {\n        this.onSaved = consumer;\n        return this;\n    }\n    public void init() {\n        Preconditions.checkNotNull(this.loadAction, \"The loadAction is not being set!\");\n        Events.subscribe(PlayerJoinEvent.class)\n                .listen((subscription, event) -> {\n                    Player player = event.getPlayer();\n                    Runnable runnable = () -> {\n                        T t = this.loadAction.apply(player);\n                        if (this.onLoaded != null) {\n                            this.onLoaded.accept(player, t);\n                        }\n                    };\n                    if (this.async) {\n                        TaskUtil.runAsync(runnable);\n                    } else {\n                        runnable.run();\n                    }\n                })\n        .build(plugin);\n        if (this.saveAction != null) {\n            Events.subscribe(PlayerQuitEvent.class)\n                    .listen((subscription, event) -> {\n                        Player player = event.getPlayer();\n                        Runnable runnable = () -> {\n                            T t = findAction != null ? findAction.apply(player) : loadAction.apply(player);\n                            this.saveAction.accept(player, t);\n                            if (this.onSaved != null) {\n                                this.onSaved.accept(player, t);\n                            }\n                        };\n                        if (this.async) {\n                            TaskUtil.runAsync(runnable);\n                        } else {\n                            runnable.run();\n                        }\n                    })\n                    .build(plugin);\n        }\n    }\n"]]}
{"hexsha": "150f733a6699feb69b0ad9b07cc34aa2509834aa", "ext": "java", "lang": "Java", "content": "public class Chat implements Receiver {\r\n    protected JChannel channel;\r\n    protected static final String CLUSTER=\"chat\";\r\n\r\n    @Override\r\n    public void viewAccepted(View new_view) {\r\n        System.out.println(\"Print view: \" + new_view);\r\n    }\r\n\r\n    @Override\r\n    public void receive(Message msg) {\r\n        System.out.println(\"[\" + msg.getSrc() + \"]: \" + msg.getObject());\r\n    }\r\n\r\n    public void start(JChannel channel) throws Exception {\r\n        this.channel = channel;\r\n        this.channel.setReceiver(this);\r\n        this.channel.connect(CLUSTER);\r\n        eventLoop();\r\n        this.channel.close();\r\n    }\r\n\r\n    private void start(String props, String name, boolean nohup) throws Exception {\r\n        this.channel = new JChannel(props);\r\n        if (name != null) {\r\n            this.channel.name(name);\r\n        }\r\n        this.channel.setReceiver(this);\r\n        this.channel.connect(CLUSTER);\r\n        if (!nohup) {\r\n            eventLoop();\r\n            this.channel.close();\r\n        }\r\n    }\r\n\r\n    private void eventLoop() {\r\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\r\n        while (true) {\r\n            try {\r\n                System.out.println(\"> \");\r\n                System.out.flush();\r\n                String line = in.readLine().toLowerCase();\r\n                if (line.startsWith(\"quit\") || line.startsWith(\"exit\")) {\r\n                    break;\r\n                }\r\n                Message msg = new Message(null, line);\r\n                this.channel.send(msg);\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        String props = \"udp.xml\";\r\n        String name = null;\r\n        boolean nohup = false;\r\n\r\n        for (int i = 0; i < args.length; i++) {\r\n            if(args[i].equals(\"-props\")) {\r\n                props=args[++i];\r\n                continue;\r\n            }\r\n            if(args[i].equals(\"-name\")) {\r\n                name=args[++i];\r\n                continue;\r\n            }\r\n            if(args[i].equals(\"-nohup\")) {\r\n                nohup=true;\r\n                continue;\r\n            }\r\n            help();\r\n            return;\r\n        }\r\n\r\n        new Chat().start(props, name, nohup);\r\n    }\r\n\r\n    private static void help() {\r\n        System.out.println(\"Chat [-props XML config] [-name name] [-nohup]\");\r\n    }\r\n}", "class_id": 0, "repo": "lindong4067/jboss-demo", "file": "jgroups-chat/src/main/java/com/example/demo/jgroups/chat/Chat.java", "last_update_at": "2020-11-06T09:13:24+00:00", "question_id": "150f733a6699feb69b0ad9b07cc34aa2509834aa", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Chat implements Receiver {\r\n    protected JChannel channel;\r\n    protected static final String CLUSTER=\"chat\";\r\n\r\n    @Override\r\n    public void viewAccepted(View new_view) {\r\n        System.out.println(\"Print view: \" + new_view);\r\n    }\r\n\r\n    @Override\r\n    public void receive(Message msg) {\r\n        System.out.println(\"[\" + msg.getSrc() + \"]: \" + msg.getObject());\r\n    }\r\n\r\n    public void start(JChannel channel) throws Exception {\r\n        this.channel = channel;\r\n        this.channel.setReceiver(this);\r\n        this.channel.connect(CLUSTER);\r\n        eventLoop();\r\n        this.channel.close();\r\n    }\r\n\r\n    private void start(String props, String name, boolean nohup) throws Exception {\r\n        this.channel = new JChannel(props);\r\n        if (name != null) {\r\n            this.channel.name(name);\r\n        }\r\n        this.channel.setReceiver(this);\r\n        this.channel.connect(CLUSTER);\r\n        if (!nohup) {\r\n            eventLoop();\r\n            this.channel.close();\r\n        }\r\n    }\r\n\r\n    private void eventLoop() {\r\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\r\n        while (true) {\r\n            try {\r\n                System.out.println(\"> \");\r\n                System.out.flush();\r\n                String line = in.readLine().toLowerCase();\r\n                if (line.startsWith(\"quit\") || line.startsWith(\"exit\")) {\r\n                    break;\r\n                }\r\n                Message msg = new Message(null, line);\r\n                this.channel.send(msg);\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        String props = \"udp.xml\";\r\n        String name = null;\r\n        boolean nohup = false;\r\n\r\n        for (int i = 0; i < args.length; i++) {\r\n            if(args[i].equals(\"-props\")) {\r\n                props=args[++i];\r\n                continue;\r\n            }\r\n            if(args[i].equals(\"-name\")) {\r\n                name=args[++i];\r\n                continue;\r\n            }\r\n            if(args[i].equals(\"-nohup\")) {\r\n                nohup=true;\r\n                continue;\r\n            }\r\n            help();\r\n            return;\r\n        }\r\n\r\n        new Chat().start(props, name, nohup);\r\n    }\r\n\r\n    private static void help() {\r\n        System.out.println(\"Chat [-props XML config] [-name name] [-nohup]\");\r\n    }\r\n"]]}
{"hexsha": "6f04cc5ed56709438efe1cf437002b0282a4c263", "ext": "java", "lang": "Java", "content": "public class ModuleExtractor {\n\tprivate static String sigParseLog;\n\tprivate static SimpleShortFormProvider sf = new SimpleShortFormProvider();\n\t\n    // Parse & tokenize signature file\n    public static Set<OWLEntity> getSignature(OWLOntology ontology, BufferedReader file) throws IOException {\n        Set<OWLEntity> sig = new HashSet<OWLEntity>();\n        OWLOntologyManager man = ontology.getOWLOntologyManager();\n        OWLDataFactory df = man.getOWLDataFactory();\n        sigParseLog = \"\";\n\n        IRI ontIri = ontology.getOntologyID().getDefaultDocumentIRI();\n        \n        boolean snomed = false;\n        boolean termsFound = false, notFound = false;\n        String termsIri = \"\";\n        \n        // Check entity IRIs for Snomed concepts \n        loopClasses:\n        for(OWLClass c : ontology.getClassesInSignature()) {\n        \tif(c.getIRI().toString().contains(\"www.ihtsdo.org\")) {\n        \t\tsnomed = true;\n        \t\ttermsIri += c.getIRI().toString();\n        \t\ttermsIri = termsIri.substring(0, termsIri.indexOf(\".org/\")+5);\n        \t\tbreak loopClasses;\n        \t}\n        }\n        \n        if(ontIri.toString().contains(\"www.ihtsdo.org\")) {\n        \tsnomed = true;\n        \ttermsIri = ontIri.toString().substring(0, ontIri.toString().indexOf(\".org/\")+5);\n        }\n        \n        if(snomed) {\n        \tfile.readLine();\n            while (file.ready()) {\n                String s = file.readLine();\n                int pos = s.indexOf(\"|\");\n                if(pos < 0) throw new RuntimeException(\"There is no '|' in:   \");\n                \n                s = \"SCT_\" + s.substring(0,pos);\n                IRI iri = IRI.create(termsIri + s);\n                OWLClass cls = df.getOWLClass(iri);\n                if (ontology.containsClassInSignature(iri)) {\n                    sig.add(cls);\n                    termsFound=true;\n                }\n                else {\n                    sigParseLog += \"\\nThere is no class \" + iri + \" in the ontology.\";\n                    notFound = true;\n                }\n            }\n            \n            IRI roleGroupIRI = IRI.create(ontology.getOntologyID().getOntologyIRI() + \"RoleGroup\");\n            OWLObjectProperty roleGroup = df.getOWLObjectProperty(roleGroupIRI);\n            \n            if (ontology.containsObjectPropertyInSignature(roleGroupIRI)) {\n                sig.add(roleGroup);\n                sigParseLog += \"\\nRoleGroup added.\";\n            }\n        }\n        else {\t// Use StringTokenizer\n\t        String delimiters = \"\t|, \";\t// Delimiters allowed\n\t        String strLine = \"\";\n\t        while ((strLine = file.readLine()) != null) {\n\t        \t// Skip commented lines\n\t        \tif(!strLine.startsWith(\"%\")) {\n\t        \t\tif(strLine.contains(\"%\"))\n\t        \t\t\tstrLine = strLine.substring(0, strLine.indexOf(\"%\"));\n\t        \t\t\n\t        \t\tStringTokenizer st = new StringTokenizer(strLine, delimiters, false);\n\t\t        \t\n\t\t        \twhile(st.hasMoreTokens()) {\n\t\t        \t\tString s = st.nextToken();\n\t\t        \t\tSystem.out.println(\"Token from signature file: \" + s );\n\t\t        \t\tIRI termIri = findTermIRI(ontology, s,df);\n\t\t        \t\tif(termIri!=null){\n\t\t\t            if(ontology.containsClassInSignature(termIri)) {\n\t\t\t            \tOWLClass cls = df.getOWLClass(termIri);\n\t\t\t                sig.add(cls); termsFound=true;\n\t\t\t                System.out.println(\"\\tOWL class. IRI: \" + termIri.toString());\n\t\t\t            }\n\t\t\t            else if(ontology.containsObjectPropertyInSignature(termIri)) {\n\t\t\t            \tOWLObjectProperty prop = df.getOWLObjectProperty(termIri);\n\t\t\t            \tsig.add(prop); termsFound=true;\n\t\t\t            \tSystem.out.println(\"\\tOWL object property. IRI: \" + termIri.toString());\n\t\t\t            }\n\t\t\t            else if(ontology.containsDataPropertyInSignature(termIri)) {\n\t\t\t            \tOWLDataProperty prop = df.getOWLDataProperty(termIri);\n\t\t\t            \tsig.add(prop); termsFound=true;\n\t\t\t            \tSystem.out.println(\"\\tOWL data property. IRI: \" + termIri.toString());\n\t\t\t            }\n\t\t\t            else {\n\t\t\t                sigParseLog += \"\\nThere is no term \" + termIri + \" in the ontology.\";\n\t\t\t                System.out.println(\"\\t! The term \" + termIri + \" is not in the ontology.\");\n\t\t\t                notFound = true;\n\t\t\t            }\n\t\t        \t}}\n\t        \t}\n\t        }\n        }\n        sigParseLog += \"\\n\" + sig.size() + \" term(s) found. \";\n        if(!termsFound && !notFound) sigParseLog += \"Signature file is empty!\";\n        return sig;\n    }\n    \n    public static IRI findTermIRI(OWLOntology ont, String name, OWLDataFactory df) {\n    \tIRI out = null;\n    \tIRI tempIRI = IRI.create(name);\n    \tfor(OWLEntity c : ont.getClassesInSignature()){ \n    \t\tif(c.getIRI().equals(tempIRI)) {\n    \t\t\tout = c.getIRI();\n    \t\t\tbreak;\n    \t\t}\n    \t\telse{\n    \t\t\tString str=null;\n    \t\t\tfor (OWLDataProperty annotation : c.getDataPropertiesInSignature() ) {  \n    \t\t\t\t  if (((OWLAnnotation) annotation).getValue() instanceof OWLLiteral) { \n    \t\t\t\t    OWLLiteral val = (OWLLiteral) ((OWLAnnotation) annotation).getValue();\n    \t\t\t\t    str=val.getLiteral();\n    \t\t\t\t    \t\t       \n    \t\t\t\t      }\n    \t\t\t\t   }\n    \t\t\tif(str==null)\n    \t\t\tstr=getManchesterSyntax(c);\n    \t\t  ISub mes=new ISub();\n    \t\t //EditDistance mes=new EditDistance();\n    \t\t//  WordNetMatcher wn=new WordNetMatcher();\n    \t\t//double sim=  wn.compute(str, name);\n    \t\t double sim= mes.getSimilarity(str, name);\n    \t\t//System.out.println(str+\"\\t\"+name+\"\\t\"+sim);\n    \t\t  if(sim>=0.6) {\n    \t\t\tout = c.getIRI();\n    \t\t\tbreak;\n    \t\t}}\n    \t}\n    \t//System.out.println(\"the URI \\t\"+out);\n    \t    \t\n    \treturn out;\n    }\n    \n    public static String getSignatureParseLog() {\n    \treturn sigParseLog;\n    }\n\n    public static OWLOntology extractModule(Set<OWLEntity> signature, OWLOntology o, String modName, ModuleType moduleType) \n    \t\tthrows OWLOntologyCreationException {\n        SyntacticLocalityModuleExtractor extractor = new SyntacticLocalityModuleExtractor(o.getOWLOntologyManager(), o, moduleType);\n        return extractor.extractAsOntology(signature, IRI.create(modName));\n    }\n    \n\tprivate static String getManchesterSyntax(OWLObject obj) {\n\t\tStringWriter wr = new StringWriter();\n\t\tManchesterOWLSyntaxObjectRenderer render = new ManchesterOWLSyntaxObjectRenderer(wr, sf);\n\t\tobj.accept(render);\n\t\tString str = wr.getBuffer().toString();\n\t\treturn str;\n\t}\n\t\n\t  // Parse & tokenize signature list\n    public static Set<OWLEntity> getSignature(OWLOntology ontology, ArrayList<String> terms)  {\n        Set<OWLEntity> sig = new HashSet<OWLEntity>();\n        OWLOntologyManager man = ontology.getOWLOntologyManager();\n        OWLDataFactory df = man.getOWLDataFactory();\n        sigParseLog = \"\";\n\n        IRI ontIri = ontology.getOntologyID().getDefaultDocumentIRI();\n        \n        boolean snomed = false;\n        boolean termsFound = false, notFound = false;\n        String termsIri = \"\";\n        \n        // Check entity IRIs for Snomed concepts \n        loopClasses:\n        for(OWLClass c : ontology.getClassesInSignature()) {   \n        \tif(c.getIRI().toString().contains(\"www.ihtsdo.org\")) {\n        \t\tsnomed = true;\n        \t\ttermsIri += c.getIRI().toString();\n        \t\ttermsIri = termsIri.substring(0, termsIri.indexOf(\".org/\")+5);\n        \t\tbreak loopClasses;\n        \t}\n        }\n        \n      if(ontIri!=null) { if(ontIri.toString().contains(\"www.ihtsdo.org\")) {\n        \tsnomed = true;\n        \ttermsIri = ontIri.toString().substring(0, ontIri.toString().indexOf(\".org/\")+5);\n        }}\n        \n        if(snomed) {\n        \t\n            for (int i=0; i<terms.size(); i++) {\n                String s = terms.get(i);//file.readLine();\n                int pos = s.indexOf(\"|\");\n                if(pos < 0) throw new RuntimeException(\"There is no '|' in:   \");\n                \n                s = \"SCT_\" + s.substring(0,pos);\n                IRI iri = IRI.create(termsIri + s);\n                OWLClass cls = df.getOWLClass(iri);\n                if (ontology.containsClassInSignature(iri)) {\n                    sig.add(cls);\n                    termsFound=true;\n                }\n                else {\n                    sigParseLog += \"\\nThere is no class \" + iri + \" in the ontology.\";\n                    notFound = true;\n                }\n            }\n            \n            IRI roleGroupIRI = IRI.create(ontology.getOntologyID().getOntologyIRI() + \"RoleGroup\");\n            OWLObjectProperty roleGroup = df.getOWLObjectProperty(roleGroupIRI);\n            \n            if (ontology.containsObjectPropertyInSignature(roleGroupIRI)) {\n                sig.add(roleGroup);\n                sigParseLog += \"\\nRoleGroup added.\";\n            }\n        }\n        else {\t// Use StringTokenizer\n\t        String delimiters = \"\t|, \";\t// Delimiters allowed\n\t        String strLine = \"\";\n\t        for (int j=0; j<terms.size();j++) {\n\t        \tstrLine=terms.get(j);\n\t        \t// Skip commented lines\n\t        \tif(!strLine.startsWith(\"%\")) {\n\t        \t\tif(strLine.contains(\"%\"))\n\t        \t\t\tstrLine = strLine.substring(0, strLine.indexOf(\"%\"));\n\t        \t\t\n\t        \t\tStringTokenizer st = new StringTokenizer(strLine, delimiters, false);\n\t\t        \t\n\t\t        \twhile(st.hasMoreTokens()) {\n\t\t        \t\tString s = st.nextToken();\n\t\t        \t\t//System.out.println(\"Token from signature file: \" + s );\n\t\t        \t\tIRI termIri = findTermIRI(ontology, s,df);\n\t\t        \t\tif(termIri!=null){\n\t\t\t            if(ontology.containsClassInSignature(termIri)) {\n\t\t\t            \tOWLClass cls = df.getOWLClass(termIri);\n\t\t\t                sig.add(cls); termsFound=true;\n\t\t\t               // System.out.println(\"\\tOWL class. IRI: \" + termIri.toString());\n\t\t\t            }\n\t\t\t            else if(ontology.containsObjectPropertyInSignature(termIri)) {\n\t\t\t            \tOWLObjectProperty prop = df.getOWLObjectProperty(termIri);\n\t\t\t            \tsig.add(prop); termsFound=true;\n\t\t\t            \t//System.out.println(\"\\tOWL object property. IRI: \" + termIri.toString());\n\t\t\t            }\n\t\t\t            else if(ontology.containsDataPropertyInSignature(termIri)) {\n\t\t\t            \tOWLDataProperty prop = df.getOWLDataProperty(termIri);\n\t\t\t            \tsig.add(prop); termsFound=true;\n\t\t\t            \t//System.out.println(\"\\tOWL data property. IRI: \" + termIri.toString());\n\t\t\t            }\n\t\t\t            else {\n\t\t\t                sigParseLog += \"\\nThere is no term \" + termIri + \" in the ontology.\";\n\t\t\t                //System.out.println(\"\\t! The term \" + termIri + \" is not in the ontology.\");\n\t\t\t                notFound = true;\n\t\t\t            }\n\t\t        \t}}\n\t        \t}\n\t        }\n        }\n        sigParseLog += \"\\n\" + sig.size() + \" term(s) found. \";\n        if(!termsFound && !notFound) sigParseLog += \"Signature file is empty!\";\n        return sig;\n    }\n}", "class_id": 0, "repo": "fusion-jena/HoH_Core_Ontology", "file": "code/ModuleExtractor/extractor/ModuleExtractor.java", "last_update_at": "2020-04-18T02:58:45+00:00", "question_id": "6f04cc5ed56709438efe1cf437002b0282a4c263", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ModuleExtractor {\n\tprivate static String sigParseLog;\n\tprivate static SimpleShortFormProvider sf = new SimpleShortFormProvider();\n\t\n    // Parse & tokenize signature file\n    public static Set<OWLEntity> getSignature(OWLOntology ontology, BufferedReader file) throws IOException {\n        Set<OWLEntity> sig = new HashSet<OWLEntity>();\n        OWLOntologyManager man = ontology.getOWLOntologyManager();\n        OWLDataFactory df = man.getOWLDataFactory();\n        sigParseLog = \"\";\n        IRI ontIri = ontology.getOntologyID().getDefaultDocumentIRI();\n        boolean snomed = false;\n        boolean termsFound = false, notFound = false;\n        String termsIri = \"\";\n        // Check entity IRIs for Snomed concepts \n        loopClasses:\n        for(OWLClass c : ontology.getClassesInSignature()) {\n        \tif(c.getIRI().toString().contains(\"www.ihtsdo.org\")) {\n        \t\tsnomed = true;\n        \t\ttermsIri += c.getIRI().toString();\n        \t\ttermsIri = termsIri.substring(0, termsIri.indexOf(\".org/\")+5);\n        \t\tbreak loopClasses;\n        \t}\n        }\n        if(ontIri.toString().contains(\"www.ihtsdo.org\")) {\n        \tsnomed = true;\n        \ttermsIri = ontIri.toString().substring(0, ontIri.toString().indexOf(\".org/\")+5);\n        }\n        if(snomed) {\n        \tfile.readLine();\n            while (file.ready()) {\n                String s = file.readLine();\n                int pos = s.indexOf(\"|\");\n                if(pos < 0) throw new RuntimeException(\"There is no '|' in:   \");\n                s = \"SCT_\" + s.substring(0,pos);\n                IRI iri = IRI.create(termsIri + s);\n                OWLClass cls = df.getOWLClass(iri);\n                if (ontology.containsClassInSignature(iri)) {\n                    sig.add(cls);\n                    termsFound=true;\n                }\n                else {\n                    sigParseLog += \"\\nThere is no class \" + iri + \" in the ontology.\";\n                    notFound = true;\n                }\n            }\n            IRI roleGroupIRI = IRI.create(ontology.getOntologyID().getOntologyIRI() + \"RoleGroup\");\n            OWLObjectProperty roleGroup = df.getOWLObjectProperty(roleGroupIRI);\n            if (ontology.containsObjectPropertyInSignature(roleGroupIRI)) {\n                sig.add(roleGroup);\n                sigParseLog += \"\\nRoleGroup added.\";\n            }\n        }\n        else {\t// Use StringTokenizer\n\t        String delimiters = \"\t|, \";\t// Delimiters allowed\n\t        String strLine = \"\";\n\t        while ((strLine = file.readLine()) != null) {\n\t        \t// Skip commented lines\n\t        \tif(!strLine.startsWith(\"%\")) {\n\t        \t\tif(strLine.contains(\"%\"))\n\t        \t\t\tstrLine = strLine.substring(0, strLine.indexOf(\"%\"));\n\t        \t\t\n\t        \t\tStringTokenizer st = new StringTokenizer(strLine, delimiters, false);\n\t\t        \t\n\t\t        \twhile(st.hasMoreTokens()) {\n\t\t        \t\tString s = st.nextToken();\n\t\t        \t\tSystem.out.println(\"Token from signature file: \" + s );\n\t\t        \t\tIRI termIri = findTermIRI(ontology, s,df);\n\t\t        \t\tif(termIri!=null){\n\t\t\t            if(ontology.containsClassInSignature(termIri)) {\n\t\t\t            \tOWLClass cls = df.getOWLClass(termIri);\n\t\t\t                sig.add(cls); termsFound=true;\n\t\t\t                System.out.println(\"\\tOWL class. IRI: \" + termIri.toString());\n\t\t\t            }\n\t\t\t            else if(ontology.containsObjectPropertyInSignature(termIri)) {\n\t\t\t            \tOWLObjectProperty prop = df.getOWLObjectProperty(termIri);\n\t\t\t            \tsig.add(prop); termsFound=true;\n\t\t\t            \tSystem.out.println(\"\\tOWL object property. IRI: \" + termIri.toString());\n\t\t\t            }\n\t\t\t            else if(ontology.containsDataPropertyInSignature(termIri)) {\n\t\t\t            \tOWLDataProperty prop = df.getOWLDataProperty(termIri);\n\t\t\t            \tsig.add(prop); termsFound=true;\n\t\t\t            \tSystem.out.println(\"\\tOWL data property. IRI: \" + termIri.toString());\n\t\t\t            }\n\t\t\t            else {\n\t\t\t                sigParseLog += \"\\nThere is no term \" + termIri + \" in the ontology.\";\n\t\t\t                System.out.println(\"\\t! The term \" + termIri + \" is not in the ontology.\");\n\t\t\t                notFound = true;\n\t\t\t            }\n\t\t        \t}}\n\t        \t}\n\t        }\n        }\n        sigParseLog += \"\\n\" + sig.size() + \" term(s) found. \";\n        if(!termsFound && !notFound) sigParseLog += \"Signature file is empty!\";\n        return sig;\n    }\n    public static IRI findTermIRI(OWLOntology ont, String name, OWLDataFactory df) {\n    \tIRI out = null;\n    \tIRI tempIRI = IRI.create(name);\n    \tfor(OWLEntity c : ont.getClassesInSignature()){ \n    \t\tif(c.getIRI().equals(tempIRI)) {\n    \t\t\tout = c.getIRI();\n    \t\t\tbreak;\n    \t\t}\n    \t\telse{\n    \t\t\tString str=null;\n    \t\t\tfor (OWLDataProperty annotation : c.getDataPropertiesInSignature() ) {  \n    \t\t\t\t  if (((OWLAnnotation) annotation).getValue() instanceof OWLLiteral) { \n    \t\t\t\t    OWLLiteral val = (OWLLiteral) ((OWLAnnotation) annotation).getValue();\n    \t\t\t\t    str=val.getLiteral();\n    \t\t\t\t    \t\t       \n    \t\t\t\t      }\n    \t\t\t\t   }\n    \t\t\tif(str==null)\n    \t\t\tstr=getManchesterSyntax(c);\n    \t\t  ISub mes=new ISub();\n    \t\t //EditDistance mes=new EditDistance();\n    \t\t//  WordNetMatcher wn=new WordNetMatcher();\n    \t\t//double sim=  wn.compute(str, name);\n    \t\t double sim= mes.getSimilarity(str, name);\n    \t\t//System.out.println(str+\"\\t\"+name+\"\\t\"+sim);\n    \t\t  if(sim>=0.6) {\n    \t\t\tout = c.getIRI();\n    \t\t\tbreak;\n    \t\t}}\n    \t}\n    \t//System.out.println(\"the URI \\t\"+out);\n    \t    \t\n    \treturn out;\n    }\n    public static String getSignatureParseLog() {\n    \treturn sigParseLog;\n    }\n    public static OWLOntology extractModule(Set<OWLEntity> signature, OWLOntology o, String modName, ModuleType moduleType) \n    \t\tthrows OWLOntologyCreationException {\n        SyntacticLocalityModuleExtractor extractor = new SyntacticLocalityModuleExtractor(o.getOWLOntologyManager(), o, moduleType);\n        return extractor.extractAsOntology(signature, IRI.create(modName));\n    }\n\tprivate static String getManchesterSyntax(OWLObject obj) {\n\t\tStringWriter wr = new StringWriter();\n\t\tManchesterOWLSyntaxObjectRenderer render = new ManchesterOWLSyntaxObjectRenderer(wr, sf);\n\t\tobj.accept(render);\n\t\tString str = wr.getBuffer().toString();\n\t\treturn str;\n\t}\n\t\n\t  // Parse & tokenize signature list\n    public static Set<OWLEntity> getSignature(OWLOntology ontology, ArrayList<String> terms)  {\n        Set<OWLEntity> sig = new HashSet<OWLEntity>();\n        OWLOntologyManager man = ontology.getOWLOntologyManager();\n        OWLDataFactory df = man.getOWLDataFactory();\n        sigParseLog = \"\";\n        IRI ontIri = ontology.getOntologyID().getDefaultDocumentIRI();\n        boolean snomed = false;\n        boolean termsFound = false, notFound = false;\n        String termsIri = \"\";\n        // Check entity IRIs for Snomed concepts \n        loopClasses:\n        for(OWLClass c : ontology.getClassesInSignature()) {   \n        \tif(c.getIRI().toString().contains(\"www.ihtsdo.org\")) {\n        \t\tsnomed = true;\n        \t\ttermsIri += c.getIRI().toString();\n        \t\ttermsIri = termsIri.substring(0, termsIri.indexOf(\".org/\")+5);\n        \t\tbreak loopClasses;\n        \t}\n        }\n      if(ontIri!=null) { if(ontIri.toString().contains(\"www.ihtsdo.org\")) {\n        \tsnomed = true;\n        \ttermsIri = ontIri.toString().substring(0, ontIri.toString().indexOf(\".org/\")+5);\n        }}\n        if(snomed) {\n        \t\n            for (int i=0; i<terms.size(); i++) {\n                String s = terms.get(i);//file.readLine();\n                int pos = s.indexOf(\"|\");\n                if(pos < 0) throw new RuntimeException(\"There is no '|' in:   \");\n                s = \"SCT_\" + s.substring(0,pos);\n                IRI iri = IRI.create(termsIri + s);\n                OWLClass cls = df.getOWLClass(iri);\n                if (ontology.containsClassInSignature(iri)) {\n                    sig.add(cls);\n                    termsFound=true;\n                }\n                else {\n                    sigParseLog += \"\\nThere is no class \" + iri + \" in the ontology.\";\n                    notFound = true;\n                }\n            }\n            IRI roleGroupIRI = IRI.create(ontology.getOntologyID().getOntologyIRI() + \"RoleGroup\");\n            OWLObjectProperty roleGroup = df.getOWLObjectProperty(roleGroupIRI);\n            if (ontology.containsObjectPropertyInSignature(roleGroupIRI)) {\n                sig.add(roleGroup);\n                sigParseLog += \"\\nRoleGroup added.\";\n            }\n        }\n        else {\t// Use StringTokenizer\n\t        String delimiters = \"\t|, \";\t// Delimiters allowed\n\t        String strLine = \"\";\n\t        for (int j=0; j<terms.size();j++) {\n\t        \tstrLine=terms.get(j);\n\t        \t// Skip commented lines\n\t        \tif(!strLine.startsWith(\"%\")) {\n\t        \t\tif(strLine.contains(\"%\"))\n\t        \t\t\tstrLine = strLine.substring(0, strLine.indexOf(\"%\"));\n\t        \t\t\n\t        \t\tStringTokenizer st = new StringTokenizer(strLine, delimiters, false);\n\t\t        \t\n\t\t        \twhile(st.hasMoreTokens()) {\n\t\t        \t\tString s = st.nextToken();\n\t\t        \t\t//System.out.println(\"Token from signature file: \" + s );\n\t\t        \t\tIRI termIri = findTermIRI(ontology, s,df);\n\t\t        \t\tif(termIri!=null){\n\t\t\t            if(ontology.containsClassInSignature(termIri)) {\n\t\t\t            \tOWLClass cls = df.getOWLClass(termIri);\n\t\t\t                sig.add(cls); termsFound=true;\n\t\t\t               // System.out.println(\"\\tOWL class. IRI: \" + termIri.toString());\n\t\t\t            }\n\t\t\t            else if(ontology.containsObjectPropertyInSignature(termIri)) {\n\t\t\t            \tOWLObjectProperty prop = df.getOWLObjectProperty(termIri);\n\t\t\t            \tsig.add(prop); termsFound=true;\n\t\t\t            \t//System.out.println(\"\\tOWL object property. IRI: \" + termIri.toString());\n\t\t\t            }\n\t\t\t            else if(ontology.containsDataPropertyInSignature(termIri)) {\n\t\t\t            \tOWLDataProperty prop = df.getOWLDataProperty(termIri);\n\t\t\t            \tsig.add(prop); termsFound=true;\n\t\t\t            \t//System.out.println(\"\\tOWL data property. IRI: \" + termIri.toString());\n\t\t\t            }\n\t\t\t            else {\n\t\t\t                sigParseLog += \"\\nThere is no term \" + termIri + \" in the ontology.\";\n\t\t\t                //System.out.println(\"\\t! The term \" + termIri + \" is not in the ontology.\");\n\t\t\t                notFound = true;\n\t\t\t            }\n\t\t        \t}}\n\t        \t}\n\t        }\n        }\n        sigParseLog += \"\\n\" + sig.size() + \" term(s) found. \";\n        if(!termsFound && !notFound) sigParseLog += \"Signature file is empty!\";\n        return sig;\n    }\n"]]}
{"hexsha": "f8ac15263598dc5371a9bbb25442710fdc0a8de8", "ext": "java", "lang": "Java", "content": "public class QueueServiceTest {\n\t private HttpServer server;\n\t    private WebTarget target;\n\n\t    @Before\n\t    public void setUp() throws Exception {\n\t        // start the server\n\t        server = Main.startServer();\n\t        // create the client\n\t        Client c = ClientBuilder.newClient();\n\t        \n\t        c.register(MoxyJsonFeature.class);\n\t        c.register(MultiPartFeature.class);\n\n\t        target = c.target(Main.BASE_URI);\n\t    }\n\n\t    @After\n\t    public void tearDown() throws Exception {\n\t        server.stop();\n\t    }\n\n\t    /**\n\t     * Test to see that the message \"Got it!\" is sent in the response.\n\t     * @throws IOException \n\t     */\n\t    @Test\n\t    public void testGetIt() throws IOException {\n\t    \tSession sessions = getSessions(\"exception.txt\");\n\t    \t\n\t    \tSession session = new Session();\n\t    \tsession.setEnvironment(\"RIDE\");\n\t    \t\n\t    \tsession.getProjects().putAll(sessions.getProjects());\n\t    \tsession.setFullStackTrace(null);\n\t    \t\n\t    \tResponse response = target.path(\"queue/build/job1\").request().post(Entity.entity(session, MediaType.APPLICATION_JSON));\n\t    \tassertTrue(response.readEntity(String.class).contains(\"build/job1 queued\"));\n\t    }\n\t    \n\t    \n\t@Test\n\tpublic void testUploadArchive() throws IOException {\n\t\tFile zip = new File(getClass().getClassLoader()\n\t\t\t\t.getResource(\"upload.zip\").getFile());\n\n\t\tfinal FormDataMultiPart multipart = new FormDataMultiPart();\n\t\tFileDataBodyPart filePart = new FileDataBodyPart(\"udc_archive_\"\n\t\t\t\t+ zip.getName(), zip);\n\t\tmultipart.bodyPart(filePart);\n\t\t\n\n\t\tfinal Response response = target.path(\"queue/myApp\").request()\n\t\t\t\t.post(Entity.entity(multipart, multipart.getMediaType()));\n\n\t\tString result=response.readEntity(String.class);\n\t\tassertTrue(result.contains(\"Files: [upload.zip] queued\")\n\t\t\t\t|| result.contains(\"Files: [] queued\"));\n\t}\n\t    \n\t    \n\t    @SuppressWarnings(\"resource\")\n\t\tprivate Session getSessions(String fileName) throws IOException {\n\t\t\tBufferedReader br;\n\t\t\tbr = new BufferedReader(new FileReader(getClass().getClassLoader().getResource(fileName).getFile()));\n\t\t\t\n\t\t\tString sCurrentLine = null;\n\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\twhile ((sCurrentLine = br.readLine()) != null) {\n\t\t\t\tsb.append(sCurrentLine);\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\t\t\t\n\t\t\tLineProcessor pro = new LineProcessor();\n\t\t\treturn pro.process(sb.toString());\n\t\t}\n}", "class_id": 0, "repo": "isabella232/mTracker", "file": "build-service/src/test/java/com/ccoe/build/service/track/QueueServiceTest.java", "last_update_at": "2020-07-31T04:34:46+00:00", "question_id": "f8ac15263598dc5371a9bbb25442710fdc0a8de8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class QueueServiceTest {\n\t private HttpServer server;\n\t    private WebTarget target;\n\t    @Before\n\t    public void setUp() throws Exception {\n\t        // start the server\n\t        server = Main.startServer();\n\t        // create the client\n\t        Client c = ClientBuilder.newClient();\n\t        \n\t        c.register(MoxyJsonFeature.class);\n\t        c.register(MultiPartFeature.class);\n\t        target = c.target(Main.BASE_URI);\n\t    }\n\t    @After\n\t    public void tearDown() throws Exception {\n\t        server.stop();\n\t    }\n\t    /**\n\t     * Test to see that the message \"Got it!\" is sent in the response.\n\t     * @throws IOException \n\t     */\n\t    @Test\n\t    public void testGetIt() throws IOException {\n\t    \tSession sessions = getSessions(\"exception.txt\");\n\t    \t\n\t    \tSession session = new Session();\n\t    \tsession.setEnvironment(\"RIDE\");\n\t    \t\n\t    \tsession.getProjects().putAll(sessions.getProjects());\n\t    \tsession.setFullStackTrace(null);\n\t    \t\n\t    \tResponse response = target.path(\"queue/build/job1\").request().post(Entity.entity(session, MediaType.APPLICATION_JSON));\n\t    \tassertTrue(response.readEntity(String.class).contains(\"build/job1 queued\"));\n\t    }\n\t    \n\t    \n\t@Test\n\tpublic void testUploadArchive() throws IOException {\n\t\tFile zip = new File(getClass().getClassLoader()\n\t\t\t\t.getResource(\"upload.zip\").getFile());\n\t\tfinal FormDataMultiPart multipart = new FormDataMultiPart();\n\t\tFileDataBodyPart filePart = new FileDataBodyPart(\"udc_archive_\"\n\t\t\t\t+ zip.getName(), zip);\n\t\tmultipart.bodyPart(filePart);\n\t\t\n\t\tfinal Response response = target.path(\"queue/myApp\").request()\n\t\t\t\t.post(Entity.entity(multipart, multipart.getMediaType()));\n\t\tString result=response.readEntity(String.class);\n\t\tassertTrue(result.contains(\"Files: [upload.zip] queued\")\n\t\t\t\t|| result.contains(\"Files: [] queued\"));\n\t}\n\t    \n\t    \n\t    @SuppressWarnings(\"resource\")\n\t\tprivate Session getSessions(String fileName) throws IOException {\n\t\t\tBufferedReader br;\n\t\t\tbr = new BufferedReader(new FileReader(getClass().getClassLoader().getResource(fileName).getFile()));\n\t\t\t\n\t\t\tString sCurrentLine = null;\n\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\twhile ((sCurrentLine = br.readLine()) != null) {\n\t\t\t\tsb.append(sCurrentLine);\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\t\t\t\n\t\t\tLineProcessor pro = new LineProcessor();\n\t\t\treturn pro.process(sb.toString());\n\t\t}\n"]]}
{"hexsha": "a114174307d2ddf33baf5de48afc2b247d3eefab", "ext": "java", "lang": "Java", "content": "public class BubbleSort {\n\t\n\tpublic static void sort(int[]arrayToSort){\n\t\tif(arrayToSort == null || arrayToSort.length == 0){\n\t\t\treturn;\n\t\t}\n\t\tint n = arrayToSort.length;\n\t\tint it = 0;\n\t\tboolean swapped = true;\n\t\twhile(it < n - 1 && swapped){\n\t\t\tswapped = false;\n\t\t\tfor(int j = 0; j < n - 1 - it; j++){\n\t\t\t\tif(arrayToSort[j] > arrayToSort[j + 1]){\n\t\t\t\t\tSortUtils.swap(arrayToSort, j, j+1);\n\t\t\t\t\tswapped = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tit++;\n\t\t}\n\t}\n}", "class_id": 0, "repo": "KB-tutorials/Algorytmy", "file": "src/kb/sorting/BubbleSort.java", "last_update_at": "2020-03-05T13:20:27+00:00", "question_id": "a114174307d2ddf33baf5de48afc2b247d3eefab", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BubbleSort {\n\t\n\tpublic static void sort(int[]arrayToSort){\n\t\tif(arrayToSort == null || arrayToSort.length == 0){\n\t\t\treturn;\n\t\t}\n\t\tint n = arrayToSort.length;\n\t\tint it = 0;\n\t\tboolean swapped = true;\n\t\twhile(it < n - 1 && swapped){\n\t\t\tswapped = false;\n\t\t\tfor(int j = 0; j < n - 1 - it; j++){\n\t\t\t\tif(arrayToSort[j] > arrayToSort[j + 1]){\n\t\t\t\t\tSortUtils.swap(arrayToSort, j, j+1);\n\t\t\t\t\tswapped = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tit++;\n\t\t}\n\t}\n"]]}
{"hexsha": "ffd65bc8f8726f67837379ec1a8dcf56ef0348c8", "ext": "java", "lang": "Java", "content": "public class ArraySortedOrNot {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tint[] b = new int[n];\n \t\tfor(int i =0; i< a.length; i++)\n\t\t{\n\t\t\ta[i] = sc.nextInt();\n\t\t\tb[i] = a[i];\n\t\t}\n \t\tArrays.sort(a);\n \t\t\n \t\t\tif(Arrays.equals(a, b))\n \t\t\t{\n \t\t\t\tSystem.out.println(\"true\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tSystem.out.println(\"false\");\n\n \t\t\t}\n\t}\n\n}", "class_id": 0, "repo": "gmonu/Nagaarro_Bootcamp_2020", "file": "src/Session_14/ArraySortedOrNot.java", "last_update_at": "2020-10-02T01:39:43+00:00", "question_id": "ffd65bc8f8726f67837379ec1a8dcf56ef0348c8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ArraySortedOrNot {\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tint[] b = new int[n];\n \t\tfor(int i =0; i< a.length; i++)\n\t\t{\n\t\t\ta[i] = sc.nextInt();\n\t\t\tb[i] = a[i];\n\t\t}\n \t\tArrays.sort(a);\n \t\t\n \t\t\tif(Arrays.equals(a, b))\n \t\t\t{\n \t\t\t\tSystem.out.println(\"true\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tSystem.out.println(\"false\");\n \t\t\t}\n\t}\n"]]}
{"hexsha": "723a4f11a4f5f4f682c07c8c643e4428410bc310", "ext": "java", "lang": "Java", "content": "@ApplicationScoped\npublic class OrderService {\n\n    @Inject MongoClient mongoClient;\n\n    public List<Order> list(){\n\n        List<Order> list = new ArrayList<>();\n\n        MongoCursor<Document> cursor = getCollection().find().iterator();\n\n        try {\n            while (cursor.hasNext()) {\n                Document document = cursor.next();\n                Order order = new Order();\n                order.setOrderId(document.getString(\"orderId\"));\n                order.setName(document.getString(\"name\"));\n                order.setTotal(document.getString(\"total\"));\n                order.setCcNumber(document.getString(\"ccNumber\"));\n                order.setCcExp(document.getString(\"ccExp\"));\n                order.setBillingAddress(document.getString(\"billingAddress\"));\n                order.setStatus(document.getString(\"status\"));\n                list.add(order);\n            }\n        } finally {\n            cursor.close();\n        }\n\n        return list;\n    }\n\n    public void add(Order order){\n\n      Document document = new Document()\n            .append(\"orderId\", order.getOrderId())\n            .append(\"name\", order.getName())\n            .append(\"total\", order.getTotal())\n            .append(\"ccNumber\", order.getCcNumber())\n            .append(\"ccExp\", order.getCcExp())\n            .append(\"billingAddress\", order.getBillingAddress())\n            .append(\"status\", order.getStatus());\n      getCollection().insertOne(document);\n\n    }\n\n    public void updateStatus(String orderId, String status){\n        Document searchQuery = new Document(\"orderId\", orderId);\n        Document newValue = new Document(\"status\", status);\n        Document updateOperationDoc = new Document(\"$set\", newValue);\n        getCollection().updateOne(searchQuery, updateOperationDoc);\n    }\n\n    private MongoCollection<Document> getCollection(){\n        return mongoClient.getDatabase(\"order\").getCollection(\"order\");\n    }\n}", "class_id": 0, "repo": "serhat-dirik/cloud-native-migration", "file": "s4-microservices/order-service/src/main/java/com/redhat/cloudnative/OrderService.java", "last_update_at": "2020-08-19T08:33:55+00:00", "question_id": "723a4f11a4f5f4f682c07c8c643e4428410bc310", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ApplicationScoped\npublic class OrderService {\n    @Inject MongoClient mongoClient;\n    public List<Order> list(){\n        List<Order> list = new ArrayList<>();\n        MongoCursor<Document> cursor = getCollection().find().iterator();\n        try {\n            while (cursor.hasNext()) {\n                Document document = cursor.next();\n                Order order = new Order();\n                order.setOrderId(document.getString(\"orderId\"));\n                order.setName(document.getString(\"name\"));\n                order.setTotal(document.getString(\"total\"));\n                order.setCcNumber(document.getString(\"ccNumber\"));\n                order.setCcExp(document.getString(\"ccExp\"));\n                order.setBillingAddress(document.getString(\"billingAddress\"));\n                order.setStatus(document.getString(\"status\"));\n                list.add(order);\n            }\n        } finally {\n            cursor.close();\n        }\n        return list;\n    }\n    public void add(Order order){\n      Document document = new Document()\n            .append(\"orderId\", order.getOrderId())\n            .append(\"name\", order.getName())\n            .append(\"total\", order.getTotal())\n            .append(\"ccNumber\", order.getCcNumber())\n            .append(\"ccExp\", order.getCcExp())\n            .append(\"billingAddress\", order.getBillingAddress())\n            .append(\"status\", order.getStatus());\n      getCollection().insertOne(document);\n    }\n    public void updateStatus(String orderId, String status){\n        Document searchQuery = new Document(\"orderId\", orderId);\n        Document newValue = new Document(\"status\", status);\n        Document updateOperationDoc = new Document(\"$set\", newValue);\n        getCollection().updateOne(searchQuery, updateOperationDoc);\n    }\n    private MongoCollection<Document> getCollection(){\n        return mongoClient.getDatabase(\"order\").getCollection(\"order\");\n    }\n"]]}
{"hexsha": "a889152c4799b6a8d000fa4cb82cf7275b5716b5", "ext": "java", "lang": "Java", "content": "@Component\npublic class AuthenticationFailureListener implements ApplicationListener<AuthenticationFailureBadCredentialsEvent> {\n\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    private static final Logger logger = LoggerFactory.getLogger(AuthenticationFailureListener.class);\n\n    @Override\n    public void onApplicationEvent(AuthenticationFailureBadCredentialsEvent authenticationFailureBadCredentialsEvent) {\n        String account = authenticationFailureBadCredentialsEvent.getAuthentication().getPrincipal().toString();\n        logger.info(\"\u767b\u5f55\u5931\u8d25\u8c03\u7528-----------------------------------------------------{}\"+account);\n\n        //\u4e0d\u7ba1\u6bcf\u53f0\u662f\u5426\u8d85\u8fc75\u6b21\u8f93\u5165\u9519\u8bef\u7b2c\u4e8c\u5929\u5c06\u5176\u8fd8\u539f\n        redisTemplate.opsForValue().increment(account+\"_\",1);\n        Integer i = (Integer) redisTemplate.opsForValue().get(account + \"_\");\n        if (i > 3 && i <= 5 && redisTemplate.hasKey(account+\"_\")){  //\u5982\u679c\u5927\u4e8e3\u6b21\u9501\u5b9a60\u79d2\n            redisTemplate.opsForValue().set(account+\"enabled\",0,60,TimeUnit.SECONDS);\n            redisTemplate.opsForValue().set(account+\"_\",i,120,TimeUnit.SECONDS);//\u4e00\u5929\u540e\u5931\u6548\n        }else if (i > 5 && redisTemplate.hasKey(account+\"_\")){//\u5982\u679c\u5927\u4e8e5\u6b21\u9501\u5b9a120\u79d2\n            redisTemplate.opsForValue().set(account+\"enabled\",0,120,TimeUnit.SECONDS);//\u9501\u5b9a\u4e00\u5929\u65f6\u95f4\n            redisTemplate.opsForValue().set(account+\"_\",i,120,TimeUnit.SECONDS);//\u4e00\u5929\u540e\u5931\u6548\n        }\n\n\n    }\n}", "class_id": 0, "repo": "zhebin-zhang/kylin-parent", "file": "kylin-upms/kylin-upms-biz/src/main/java/com/kylin/upms/biz/config/AuthenticationFailureListener.java", "last_update_at": "2020-06-14T07:11:27+00:00", "question_id": "a889152c4799b6a8d000fa4cb82cf7275b5716b5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\npublic class AuthenticationFailureListener implements ApplicationListener<AuthenticationFailureBadCredentialsEvent> {\n    @Autowired\n    private RedisTemplate redisTemplate;\n    private static final Logger logger = LoggerFactory.getLogger(AuthenticationFailureListener.class);\n    @Override\n    public void onApplicationEvent(AuthenticationFailureBadCredentialsEvent authenticationFailureBadCredentialsEvent) {\n        String account = authenticationFailureBadCredentialsEvent.getAuthentication().getPrincipal().toString();\n        logger.info(\"\u767b\u5f55\u5931\u8d25\u8c03\u7528-----------------------------------------------------{}\"+account);\n        //\u4e0d\u7ba1\u6bcf\u53f0\u662f\u5426\u8d85\u8fc75\u6b21\u8f93\u5165\u9519\u8bef\u7b2c\u4e8c\u5929\u5c06\u5176\u8fd8\u539f\n        redisTemplate.opsForValue().increment(account+\"_\",1);\n        Integer i = (Integer) redisTemplate.opsForValue().get(account + \"_\");\n        if (i > 3 && i <= 5 && redisTemplate.hasKey(account+\"_\")){  //\u5982\u679c\u5927\u4e8e3\u6b21\u9501\u5b9a60\u79d2\n            redisTemplate.opsForValue().set(account+\"enabled\",0,60,TimeUnit.SECONDS);\n            redisTemplate.opsForValue().set(account+\"_\",i,120,TimeUnit.SECONDS);//\u4e00\u5929\u540e\u5931\u6548\n        }else if (i > 5 && redisTemplate.hasKey(account+\"_\")){//\u5982\u679c\u5927\u4e8e5\u6b21\u9501\u5b9a120\u79d2\n            redisTemplate.opsForValue().set(account+\"enabled\",0,120,TimeUnit.SECONDS);//\u9501\u5b9a\u4e00\u5929\u65f6\u95f4\n            redisTemplate.opsForValue().set(account+\"_\",i,120,TimeUnit.SECONDS);//\u4e00\u5929\u540e\u5931\u6548\n        }\n    }\n"]]}
{"hexsha": "92f111dccb6f07a2c235f8a35fee4e62ac022c9a", "ext": "java", "lang": "Java", "content": "public class SingleDeleteStatement implements DeleteStatement {\n    public final Boolean lowPriority;\n    public final Boolean quick;\n    public final Boolean ignore;\n    public final TableName tableName;\n    public final UidList uidList;\n    public final Expression where;\n    public final OrderByClause orderByClause;\n    public final DecimalLiteral limit;\n\n    SingleDeleteStatement(Boolean lowPriority, Boolean quick, Boolean ignore, TableName tableName,\n        UidList uidList, Expression where, OrderByClause orderByClause, DecimalLiteral limit) {\n      Preconditions.checkArgument(tableName != null);\n\n      this.lowPriority = lowPriority;\n      this.quick = quick;\n      this.ignore = ignore;\n      this.tableName = tableName;\n      this.uidList = uidList;\n      this.where = where;\n      this.orderByClause = orderByClause;\n      this.limit = limit;\n    }\n\n    @Override\n    public String literal() {\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"DELETE \");\n      if (Boolean.TRUE.equals(lowPriority)) {\n        sb.append(\"LOW_PRIORITY \");\n      }\n      if (Boolean.TRUE.equals(quick)) {\n        sb.append(\"QUICK \");\n      }\n      if (Boolean.TRUE.equals(ignore)) {\n        sb.append(\"IGNORE \");\n      }\n      sb.append(\"FROM \").append(tableName.literal()).append(\" \");\n      if (uidList != null) {\n        sb.append(\"PARTITION (\").append(uidList.literal()).append(\") \");\n      }\n      if (where != null) {\n        sb.append(\"WHERE \").append(where.literal()).append(\" \");\n      }\n      if (orderByClause != null) {\n        sb.append(orderByClause.literal()).append(\" \");\n      }\n      if (limit != null) {\n        sb.append(\"LIMIT \").append(limit.literal());\n      }\n      return sb.toString();\n    }\n\n  }", "class_id": 0, "repo": "zhoujiagen/giant-data-analysis", "file": "data-models/datamodel-logic/src/main/java/com/spike/giantdataanalysis/model/logic/relational/expression/raw/DeleteStatement.java", "last_update_at": "2020-05-15T13:02:45+00:00", "question_id": "92f111dccb6f07a2c235f8a35fee4e62ac022c9a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SingleDeleteStatement implements DeleteStatement {\n    public final Boolean lowPriority;\n    public final Boolean quick;\n    public final Boolean ignore;\n    public final TableName tableName;\n    public final UidList uidList;\n    public final Expression where;\n    public final OrderByClause orderByClause;\n    public final DecimalLiteral limit;\n    SingleDeleteStatement(Boolean lowPriority, Boolean quick, Boolean ignore, TableName tableName,\n        UidList uidList, Expression where, OrderByClause orderByClause, DecimalLiteral limit) {\n      Preconditions.checkArgument(tableName != null);\n      this.lowPriority = lowPriority;\n      this.quick = quick;\n      this.ignore = ignore;\n      this.tableName = tableName;\n      this.uidList = uidList;\n      this.where = where;\n      this.orderByClause = orderByClause;\n      this.limit = limit;\n    }\n    @Override\n    public String literal() {\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"DELETE \");\n      if (Boolean.TRUE.equals(lowPriority)) {\n        sb.append(\"LOW_PRIORITY \");\n      }\n      if (Boolean.TRUE.equals(quick)) {\n        sb.append(\"QUICK \");\n      }\n      if (Boolean.TRUE.equals(ignore)) {\n        sb.append(\"IGNORE \");\n      }\n      sb.append(\"FROM \").append(tableName.literal()).append(\" \");\n      if (uidList != null) {\n        sb.append(\"PARTITION (\").append(uidList.literal()).append(\") \");\n      }\n      if (where != null) {\n        sb.append(\"WHERE \").append(where.literal()).append(\" \");\n      }\n      if (orderByClause != null) {\n        sb.append(orderByClause.literal()).append(\" \");\n      }\n      if (limit != null) {\n        sb.append(\"LIMIT \").append(limit.literal());\n      }\n      return sb.toString();\n    }\n"]]}
{"hexsha": "d01fdb3aa61245224feb43a765679aa1bfab1368", "ext": "java", "lang": "Java", "content": "public class ThreadSeq extends Thread{\n\tint n;\n\t\n\tpublic ThreadSeq(int n) {\n\t\tthis.n = n;\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\tcalcSeq();\n\t}\n\t\n\tpublic void calcSeq() {\n\t\tfloat resultado = 0;\n\t\tboolean signal = true;\n\t\tdouble calcParcial = 0;\n\t\t\n\t\tif(n%2 == 0) {\n\t\t\tn--;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= n; i = i + 2) {\n\t\t\tif(signal) {\n\t\t\t\tcalcParcial = 1.0 / i;\n\t\t\t}else {\n\t\t\t\tcalcParcial = - 1.0 / i;\n\t\t\t}\n\t\t\tresultado += calcParcial;\n\t\t\tsignal = !signal;\n\t\t}\n\t\tresultado = 4 * resultado;\n\t\tSystem.out.println(\"N = \" + n + \" - Resultado = \" + resultado);\n\t}\n}", "class_id": 0, "repo": "Gabanelli/SO1", "file": "Thread_Aula/src/controller/ThreadSeq.java", "last_update_at": "2020-05-19T01:38:50+00:00", "question_id": "d01fdb3aa61245224feb43a765679aa1bfab1368", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ThreadSeq extends Thread{\n\tint n;\n\t\n\tpublic ThreadSeq(int n) {\n\t\tthis.n = n;\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\tcalcSeq();\n\t}\n\t\n\tpublic void calcSeq() {\n\t\tfloat resultado = 0;\n\t\tboolean signal = true;\n\t\tdouble calcParcial = 0;\n\t\t\n\t\tif(n%2 == 0) {\n\t\t\tn--;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= n; i = i + 2) {\n\t\t\tif(signal) {\n\t\t\t\tcalcParcial = 1.0 / i;\n\t\t\t}else {\n\t\t\t\tcalcParcial = - 1.0 / i;\n\t\t\t}\n\t\t\tresultado += calcParcial;\n\t\t\tsignal = !signal;\n\t\t}\n\t\tresultado = 4 * resultado;\n\t\tSystem.out.println(\"N = \" + n + \" - Resultado = \" + resultado);\n\t}\n"]]}
{"hexsha": "0a75b00f3f760575d0cde31feb30b1f84279a528", "ext": "java", "lang": "Java", "content": "public class GraphPane extends JComponent\n    implements MouseListener, MouseWheelListener, MouseMotionListener, GraphListener, ComponentListener {\n\n  private static final long serialVersionUID = 3827345534868023684L;\n\n  private Graph graph;\n\n  private Renderers renderers = new Renderers();\n\n  private boolean mouseHoverEnabled = true;\n\n  private StageMode stageMode = StageMode.PAN;\n  private NodeDragMode nodeDragMode = NodeDragMode.SELECTION;\n  private RenderContext renderContext;\n\n  private List<NodeListener> nodeListeners = new ArrayList<>();\n  private List<StageListener> stageListeners = new ArrayList<>();\n  private List<EdgeListener> edgeListeners = new ArrayList<>();\n\n  private boolean historyEnabled = false;\n  private GraphHistory history;\n\n  private boolean showBoundingBoxes = false;\n\n  private boolean mouseWheelZoomEnabled = true;\n  private double scale = 1d / 5d;\n  private static final double MIN_ZOOM = 1d / 4d;\n  private static final double MAX_ZOOM = 5d;\n\n  private boolean isDragging = false;\n  private Node nodeUnderMouse = null;\n  private Edge edgeUnderMouse = null;\n\n  protected AffineTransform transform = new AffineTransform();\n  protected AffineTransform inverseTransform = new AffineTransform();\n\n  private int startDragX;\n  private int startDragY;\n\n  private int nodeDragOffsetX;\n  private int nodeDragOffsetY;\n\n  private Set<String> selectedNodes = new HashSet<>();\n  private Set<String> selectedEdges = new HashSet<>();\n  private Map<String, NodeBoundingBox> boxesIndex = new HashMap<>();\n\n  private Set<String> idleNodes = new HashSet<>();\n  private Set<String> liveNodes = new HashSet<>();\n\n  private Double selectionBox;\n\n  private BufferedImage idleBuffer;\n  private Graphics2D idleGraphics;\n\n  private int lastBufferX;\n  private int lastBufferY;\n\n  private boolean isPrinting;\n\n  public GraphPane(Graph graph) {\n    super();\n    this.graph = graph;\n    this.history = new GraphHistory(this);\n    this.renderContext = new RenderContext(this, graph);\n    this.addMouseWheelListener(this);\n    this.addMouseMotionListener(this);\n    this.addMouseListener(this);\n    this.addComponentListener(this);\n\n    this.graph.addListener(this);\n\n    this.idleNodes.addAll(this.graph.getNodeIds());\n  }\n\n  @Override\n  protected void paintComponent(Graphics g) {\n    Graphics2D g2d = (Graphics2D) g;\n    paintGraph(g, this.transform, g2d.getClipBounds());\n  }\n\n  private void paintGraph(Graphics g, AffineTransform tx, Rectangle2D clipBounds) {\n    Graphics2D g2d = (Graphics2D) g;\n\n    AffineTransform currentTransform = g2d.getTransform();\n    AffineTransform graphTransformation = (AffineTransform) currentTransform.clone();\n    graphTransformation.concatenate(tx);\n\n    int originX = (int) (-1 * currentTransform.getTranslateX());\n    int originY = (int) (-1 * currentTransform.getTranslateY());\n\n    try {\n      clipBounds.setFrame(clipBounds.getX() - Math.abs(originX), clipBounds.getY() - Math.abs(originY),\n          clipBounds.getWidth() + 2 * Math.abs(originX), clipBounds.getHeight() + 2 * Math.abs(originY));\n      clipBounds = graphTransformation.createInverse().createTransformedShape(clipBounds).getBounds2D();\n    } catch (NoninvertibleTransformException e) {\n      throw new RuntimeException(e);\n    }\n\n    RenderingHints rh = new RenderingHints(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n    g2d.setRenderingHints(rh);\n\n    int imageWidth = this.getWidth() + Math.abs(originX);\n    int imageHeight = this.getHeight() + Math.abs(originY);\n\n    BufferedImage liveBuffer = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_ARGB);\n    Graphics2D liveGraphics = liveBuffer.createGraphics();\n    liveGraphics.setRenderingHints(rh);\n    \n    //resetBuffer from other thread could cause NPE because it nulls attributes below\n    BufferedImage idleBuffer = this.idleBuffer;\n    Graphics2D idleGraphics = this.idleGraphics;\n\n    boolean paintIdleNodes = idleBuffer == null || idleBuffer.getHeight() != imageHeight\n        || idleBuffer.getWidth() != imageWidth || this.lastBufferX != originX || this.lastBufferY != originY;\n    if (paintIdleNodes) {\n      idleBuffer = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_ARGB);\n      idleGraphics = idleBuffer.createGraphics();\n      idleGraphics.setRenderingHints(rh);\n\n      idleGraphics.setBackground(getBackground());\n      idleGraphics.clearRect(0, 0, imageWidth, imageHeight);\n\n      this.lastBufferX = originX;\n      this.lastBufferY = originY;\n    }\n\n    GraphRenderer graphRenderer = renderers.getGraphRenderer(this.graph.getType());\n    graphRenderer.render(liveGraphics, this.graph);\n\n    Collection<Edge> liveEdges = new ArrayList<>(graph.getNodesOverlappedEdges(this.liveNodes));\n    paintEdges(liveGraphics, graphTransformation, clipBounds, liveEdges);\n    paintNodes(liveGraphics, graphTransformation, currentTransform, clipBounds, graph.getNodes(this.liveNodes));\n    \n    HashSet<Edge> overlappedEdges = new HashSet<>(liveEdges);\n\n    Collection<Edge> idleEdges = new ArrayList<>(graph.getNodesOverlappedEdges(this.idleNodes));\n    overlappedEdges.addAll(idleEdges);\n    if (paintIdleNodes) {\n      idleEdges.removeAll(liveEdges);\n      paintEdges(idleGraphics, graphTransformation, clipBounds, idleEdges);\n      paintNodes(idleGraphics, graphTransformation, currentTransform, clipBounds, graph.getNodes(this.idleNodes));\n    }\n\n    g2d.drawImage(idleBuffer, originX, originY, null);\n    \n    Set<String> nodesOfSelectedEdges = paintSelectedEdges(liveGraphics, graphTransformation, clipBounds, overlappedEdges);\n    paintNodes(liveGraphics, graphTransformation, currentTransform, clipBounds, graph.getNodes(nodesOfSelectedEdges));\n\n    Node hoveredNode = getHoveredNode();\n    if (hoveredNode != null && !isPrinting) {\n      NodeBoundingBox box = this.boxesIndex.get(hoveredNode.getId());\n      if (box != null) {\n        NodeHoverRenderer renderer = renderers.getNodeHoverRenderer(\"default\");\n        GraphShape graphShape = renderer.render(g2d, box, renderContext);\n        graphShape.draw(g2d, tx);\n        paintNodes(liveGraphics, graphTransformation, currentTransform, clipBounds, Arrays.asList(hoveredNode));\n      }\n    }\n\n    if (!isPrinting) {\n      paintSelections(liveGraphics, graphTransformation, clipBounds);\n    }\n\n    if (this.selectionBox != null && !isPrinting) {\n      paintSelectionBox(liveGraphics, graphTransformation);\n    }\n\n    Color color = liveGraphics.getColor();\n    liveGraphics.setColor(Color.BLUE);\n    liveGraphics.fill(graphTransformation.createTransformedShape(new Rectangle2D.Double(-2, -2, 4, 4)));\n    liveGraphics.setColor(Color.GREEN);\n    liveGraphics.fill(new Rectangle2D.Double(-2, -2, 4, 4));\n\n    liveGraphics.setColor(color);\n    g2d.drawImage(liveBuffer, originX, originY, null);\n\n    liveGraphics.dispose();\n  }\n\n  private void paintSelections(Graphics2D g2d, AffineTransform tx, Rectangle2D clipBounds) {\n    for (String selectedId : this.selectedNodes) {\n      Node node = this.graph.getNode(selectedId);\n      NodeBoundingBox boundingBox = this.boxesIndex.get(node.getId());\n      if (boundingBox.intersects(clipBounds)) {\n        SelectionRenderer renderer = renderers.getSelectionRenderer(node.getSelectionType());\n        GraphShape selectionGraphShape = renderer.render(g2d, boundingBox, renderContext);\n        if (selectionGraphShape != null) {\n          selectionGraphShape.draw(g2d, tx);\n        }\n      }\n    }\n  }\n\n  private void paintSelectionBox(Graphics2D g2d, AffineTransform tx) {\n    Color oldColor = g2d.getColor();\n    g2d.setColor(this.graph.getSettings().getSelectionColor());\n    g2d.draw(tx.createTransformedShape(selectionBox));\n    g2d.setColor(oldColor);\n  }\n\n  private void paintNodes(Graphics2D g2d, AffineTransform stageTx, AffineTransform componentTx, Rectangle2D clipBounds,\n      Collection<Node> nodes) {\n    for (Node node : nodes) {\n      NodeBoundingBox nodeBoundingBox = this.boxesIndex.get(node.getId());\n      if (nodeBoundingBox == null) {\n        nodeBoundingBox = new NodeBoundingBox(1.4d);\n        this.boxesIndex.put(node.getId(), nodeBoundingBox);\n      } else {\n        nodeBoundingBox.clear();\n      }\n\n      NodeRenderer renderer = renderers.getNodeRenderer(node.getType());\n      GraphShape nodeGraphShape = renderer.render(g2d, node, renderContext);\n      if (nodeGraphShape != null && nodeGraphShape.getShape().intersects(clipBounds)) {\n        nodeGraphShape.draw(g2d, stageTx);\n\n        Rectangle2D bounds = nodeBoundingBox.addBox(nodeGraphShape.getShape());\n        if (this.showBoundingBoxes) {\n          g2d.draw(stageTx.createTransformedShape(bounds));\n        }\n      }\n\n      LabelRenderer labelRenderer = renderers.getLabelRenderer(node.getLabelType());\n      GraphShape labelGraphShape = labelRenderer.render(g2d, node, renderContext);\n      if (labelGraphShape != null && labelGraphShape.getShape().intersects(clipBounds)) {\n        labelGraphShape.draw(g2d, stageTx);\n\n        Rectangle2D bounds = nodeBoundingBox.addBox(labelGraphShape.getShape());\n        if (this.showBoundingBoxes) {\n          g2d.draw(stageTx.createTransformedShape(bounds));\n        }\n      }\n    }\n  }\n\n  private void paintEdges(Graphics2D g2d, AffineTransform tx, Rectangle2D clipBounds, Collection<Edge> edges) {\n    for (Edge edge : edges) {\n      EdgeRenderer renderer = renderers.getEdgeRenderer(edge.getType());\n      GraphShape graphShape = renderer.render(g2d, edge, renderContext);\n      if (graphShape != null && graphShape.getShape().intersects(clipBounds)) {\n        graphShape.draw(g2d, tx);\n      }\n    }\n  }\n  \n  private Set<String> paintSelectedEdges(Graphics2D g2d, AffineTransform tx, Rectangle2D clipBounds, Collection<Edge> edges) {\n      Set<String> nodesUnderEdges = new HashSet<>();\n      for (Edge edge : edges) {\n        if(selectedEdges.contains(edge.getId())) {\n            edge.setColor(Color.RED);\n            nodesUnderEdges.add(edge.getSource());\n            nodesUnderEdges.add(edge.getTarget());\n        }else if(edge.equals(this.edgeUnderMouse)){\n            edge.setColor(Color.BLACK);\n            nodesUnderEdges.add(edge.getSource());\n            nodesUnderEdges.add(edge.getTarget());\n        }else {\n            continue;\n        }\n        EdgeRenderer renderer = renderers.getEdgeRenderer(edge.getType());\n        GraphShape graphShape = renderer.render(g2d, edge, renderContext);\n        if (graphShape != null && graphShape.getShape().intersects(clipBounds)) {\n          graphShape.draw(g2d, tx);\n        }\n        edge.setColor(null);\n      }\n      return nodesUnderEdges;\n  }\n\n  public BufferedImage toImage() {\n    BufferedImage image = new BufferedImage(this.getWidth(), this.getHeight(), BufferedImage.TYPE_INT_ARGB);\n    print(image.getGraphics());\n    return image;\n  }\n\n  public Graph getGraph() {\n    return graph;\n  }\n\n  public void addNodeListener(NodeListener nodeListener) {\n    this.nodeListeners.add(nodeListener);\n  }\n\n  public void removeNodeListener(NodeListener nodeListener) {\n    this.nodeListeners.remove(nodeListener);\n  }\n\n  public void addEdgeListener(EdgeListener listener) {\n    this.edgeListeners.add(listener);\n  }\n\n  public void removeEdgeListener(EdgeListener listener) {\n    this.edgeListeners.remove(listener);\n  }\n\n  public void addStageListener(StageListener stageListener) {\n    this.stageListeners.add(stageListener);\n  }\n\n  public void removeStageListener(StageListener stageListener) {\n    this.stageListeners.remove(stageListener);\n  }\n\n  @Override\n  public void mouseClicked(MouseEvent e) {\n    if (this.isEnabled()) {\n      if (this.nodeUnderMouse != null) {\n        notifyNodeClicked(this.nodeUnderMouse, e);\n      } else {\n        if(this.edgeUnderMouse != null) {\n          notifyEdgeClicked(edgeUnderMouse, e);\n        }else {\n          notifyStageClicked(e);    \n        }\n      }\n    }\n  }\n\n  private void notifyStageClicked(MouseEvent e) {\n    for (StageListener stageListener : this.stageListeners) {\n      stageListener.stageClicked(e);\n    }\n  }\n\n  private void notifyZoomChanged() {\n    for (StageListener stageListener : this.stageListeners) {\n      stageListener.stageZoomChanged(getZoom());\n    }\n  }\n\n  private void notifyStageDragStarted(MouseEvent e) {\n    for (StageListener stageListener : this.stageListeners) {\n      stageListener.stageDragStarted(e);\n    }\n  }\n\n  private void notifyStageDragStopped(MouseEvent e) {\n    for (StageListener stageListener : this.stageListeners) {\n      stageListener.stageDragStopped(e);\n    }\n  }\n\n  private void notifyStageMoved() {\n    for (StageListener stageListener : this.stageListeners) {\n      stageListener.stageMoved(getTranslateX(), getTranslateY());\n    }\n  }\n\n  private void notifyNodeClicked(Node node, MouseEvent e) {\n    for (NodeListener listener : this.nodeListeners) {\n      listener.nodeClicked(node, e);\n    }\n  }\n  \n  private void notifyEdgeClicked(Edge edge, MouseEvent e) {\n    for (EdgeListener listener : this.edgeListeners) {\n      listener.edgeClicked(edge, e);\n    }\n  }\n  \n  private void notifyEdgeHover(Edge edge, MouseEvent e) {\n      for (EdgeListener listener : this.edgeListeners) {\n        listener.edgeHovered(edge, e);\n      }\n  }\n  \n  private void notifyEdgeOut(Edge edge, MouseEvent e) {\n      for (EdgeListener listener : this.edgeListeners) {\n        listener.edgeOut(edge, e);\n      }\n  }\n  \n  private void notifyEdgesSelected(Collection<Edge> edges, MouseEvent e) {\n      for (EdgeListener listener : this.edgeListeners) {\n        listener.edgesSelected(edges, e);\n      }\n  }\n\n  private void notifyNodePressed(Node node, MouseEvent e) {\n    for (NodeListener listener : this.nodeListeners) {\n      listener.nodePressed(node, e);\n    }\n  }\n\n  private void notifyNodeHover(Node node, MouseEvent e) {\n    for (NodeListener listener : this.nodeListeners) {\n      listener.nodeHover(node, e);\n    }\n  }\n\n  private void notifyNodeOut(MouseEvent e) {\n    for (NodeListener listener : this.nodeListeners) {\n      listener.nodeOut(e);\n    }\n  }\n\n  private void notifyNodeReleased(Node node, MouseEvent e) {\n    for (NodeListener listener : this.nodeListeners) {\n      listener.nodeReleased(node, e);\n    }\n  }\n\n  private void notifyNodeDragStarted(Collection<Node> nodes, MouseEvent e) {\n    for (NodeListener listener : this.nodeListeners) {\n      listener.nodeDragStarted(nodes, e);\n    }\n  }\n\n  private void notifyNodeDragStopped(Collection<Node> nodes, MouseEvent e) {\n    for (NodeListener listener : this.nodeListeners) {\n      listener.nodeDragStopped(nodes, e);\n    }\n  }\n\n  private void notifyNodeDragged(Collection<Node> nodes, MouseEvent e) {\n    for (NodeListener listener : this.nodeListeners) {\n      listener.nodeDragged(nodes, e);\n    }\n  }\n\n  private Node getNodeUnderMouse(MouseEvent evt) {\n    Point2D evtPoint = invert(evt.getPoint());\n    for (Entry<String, NodeBoundingBox> entry : boxesIndex.entrySet()) {\n      NodeBoundingBox box = entry.getValue();\n      if (box.contains(evtPoint)) {\n        String id = entry.getKey();\n        return this.graph.getNode(id);\n      }\n    }\n    return null;\n  }\n  \n  private Edge getEdgeUnderMouse(MouseEvent evt) {\n      Point2D evtPoint = invert(evt.getPoint());\n      Collection<Edge> edges = new ArrayList<>(graph.getNodesOverlappedEdges(this.idleNodes));\n      \n      for (Edge edge : edges) {\n        if (isNearEdge(edge, evtPoint))\n          return edge;\n      }\n      return null;\n  }\n  \n  private boolean isNearEdge(Edge edge, Point2D p) {\n      Node n1 = renderContext.getGraph().getNode(edge.getSource());\n      Node n2 = renderContext.getGraph().getNode(edge.getTarget());\n      double x1 = n1.getX() + n1.getSize() / 2, x2 = n2.getX() + n2.getSize() / 2;\n      double y1 = n1.getY() + n1.getSize() / 2, y2 = n2.getY() + n2.getSize() / 2;\n      \n      double d = 5;\n      \n      if(x1 < x2 && (p.getX() < x1 - d || p.getX() > x2 + d))\n          return false;\n      if(x1 > x2 && (p.getX() > x1 + d || p.getX() < x2 - d))\n          return false;\n      if(y1 < y2 && (p.getY() < y1 - d || p.getY() > y2 + d))\n          return false;\n      if(y1 > y2 && (p.getY() > y1 + d || p.getY() < y2 - d))\n          return false;\n      \n      double num = Math.abs((y2 - y1) * p.getX() - (x2 - x1) * p.getY() + x2 * y1 - y2 * x1);\n      double div = Math.sqrt(Math.pow((y2 - y1), 2) + Math.pow(x2 - x1, 2));\n      double dist = num / div;\n      if(dist < d)\n          return true;\n      else\n          return false;\n  }\n\n  private void applyCurrentSelection(MouseEvent e) {\n    Set<String> prevSelectedEdges = new HashSet<>(selectedEdges);\n    if (!e.isControlDown() && !e.isShiftDown()) {\n      this.selectedNodes.clear();\n      this.selectedEdges.clear();\n    }\n    for (Entry<String, NodeBoundingBox> entry : boxesIndex.entrySet()) {\n      NodeBoundingBox box = entry.getValue();\n      if (box.intersects(selectionBox)) {\n        String id = entry.getKey();\n        this.selectedNodes.add(id);\n      }\n    }\n    if(selectedNodes.size() > 0) {\n        return;\n    }\n    Collection<Edge> overlappedEdges = new ArrayList<>(graph.getNodesOverlappedEdges(graph.getNodeIds()));\n    Collection<Edge> edgesSelected = new HashSet<>();\n    for(Edge edge : overlappedEdges) {\n        if(getEdgeShape(edge).intersects(selectionBox)) {\n            selectedEdges.add(edge.getId());\n            edgesSelected.add(edge);\n        }\n    }\n    if(prevSelectedEdges.size() != selectedEdges.size()) {\n        notifyEdgesSelected(edgesSelected, e);\n    }else {\n        for(String id : selectedEdges) {\n            if(!prevSelectedEdges.contains(id)) {\n                notifyEdgesSelected(edgesSelected, e);\n                break;\n            }\n        }\n    }\n  }\n  \n  private Shape getEdgeShape(Edge edge) {\n      Node n1 = this.graph.getNode(edge.getSource());\n      Node n2 = this.graph.getNode(edge.getTarget());\n      Line2D shape = new Line2D.Double(n1.getX() + n1.getSize() / 2, n1.getY() + n1.getSize() / 2, \n              n2.getX() + n2.getSize() / 2, n2.getY() + n2.getSize() / 2);\n      return shape;\n  }\n\n  @Override\n  public void mousePressed(MouseEvent e) {\n    if (this.isEnabled()) {\n      this.nodeUnderMouse = getNodeUnderMouse(e);\n      if (this.nodeUnderMouse != null) {\n        notifyNodePressed(this.nodeUnderMouse, e);\n      }\n    }\n  }\n\n  @Override\n  public void mouseReleased(MouseEvent e) {\n    if (this.isEnabled()) {\n      stopDrag(e);\n      this.nodeUnderMouse = getNodeUnderMouse(e);\n      if (this.nodeUnderMouse != null) {\n        notifyNodeReleased(this.nodeUnderMouse, e);\n      }\n      repaint();\n    }\n  }\n\n  @Override\n  public void mouseEntered(MouseEvent e) {\n\n  }\n\n  @Override\n  public void mouseExited(MouseEvent e) {\n    if (this.isEnabled()) {\n      stopDrag(e);\n      repaint();\n    }\n  }\n\n  protected Point2D getCenter() {\n\n    Dimension size = getSize();\n    double widthOffset = size.width / 2d;\n    double heightOffset = size.height / 2d;\n\n    double zoom = getZoom();\n    double x = getTranslateX() + widthOffset / zoom;\n    double y = getTranslateY() + heightOffset / zoom;\n\n    return new Point2D.Double(x, y);\n  }\n\n  @Override\n  public void mouseWheelMoved(MouseWheelEvent e) {\n    if (this.isEnabled()) {\n      int notches = -1 * e.getWheelRotation();\n      double zoom = getZoom();\n      double newZoom = zoom + (scale * notches);\n      newZoom = Math.min(newZoom, MAX_ZOOM);\n      newZoom = Math.max(newZoom, MIN_ZOOM);\n\n      if (zoom != newZoom) {\n        setZoom(newZoom, e.getPoint());\n        repaint();\n      }\n    }\n  }\n\n  public boolean isMouseWheelZoomEnabled() {\n    return mouseWheelZoomEnabled;\n  }\n\n  public void setMouseWheelZoomEnabled(boolean mouseWheelZoomEnabled) {\n    this.mouseWheelZoomEnabled = mouseWheelZoomEnabled;\n    if (!mouseWheelZoomEnabled) {\n      this.removeMouseWheelListener(this);\n    }\n  }\n\n  public double getZoom() {\n    return transform.getScaleX();\n  }\n  \n  public void setZoom(double zoom) {\n      setZoom(zoom, null);\n  }\n\n  public void setZoom(double zoom, Point evtPoint) {\n    zoom = Math.min(zoom, MAX_ZOOM);\n    zoom = Math.max(zoom, MIN_ZOOM);\n    setGraphZoom(zoom, evtPoint);\n  }\n  \n  protected void setGraphZoom(double zoom) {\n      setGraphZoom(zoom, null);\n  }\n\n  protected void setGraphZoom(double zoom, Point evtPoint) {\n    double oldZoom = getZoom();\n\n    double translateX = this.getTranslateX();\n    double translateY = this.getTranslateY();\n    \n    Point2D invPoint = null;\n    if(evtPoint != null)\n        invPoint = invert(evtPoint);\n\n    this.transform.setToScale(zoom, zoom);\n    this.transform.translate(translateX / oldZoom, translateY / oldZoom);\n    \n    try {\n      this.inverseTransform = this.transform.createInverse();\n    } catch (NoninvertibleTransformException e) {\n      throw new RuntimeException(e);\n    }\n    \n    notifyZoomChanged();\n    resetBuffer();\n    \n    if(invPoint != null) {\n        double widthOffset = getSize().width / 2d;\n        double heightOffset = getSize().height / 2d;\n        \n        double dx = (evtPoint.getX() - widthOffset) / zoom;\n        double dy = (evtPoint.getY() - heightOffset) / zoom;\n        \n        centerStageAt(invPoint.getX() - dx, invPoint.getY() - dy);\n    }\n    \n  }\n\n  @Override\n  public void mouseDragged(MouseEvent evt) {\n    if (this.isEnabled()) {\n      if (!isDragging) {\n        startDrag(evt);\n      }\n      if (nodeUnderMouse != null) {\n        if (this.nodeDragMode == NodeDragMode.CURRENT) {\n          dragNode(evt);\n        } else if (this.nodeDragMode == NodeDragMode.SELECTION) {\n          dragSelectedNodes(evt);\n        }\n        repaint();\n      } else if (this.stageMode == StageMode.PAN) {\n        dragStage(evt);\n        repaint();\n      } else if (this.stageMode == StageMode.SELECTION) {\n        updateSelection(evt);\n        repaint();\n      }\n    }\n  }\n\n  private void updateSelection(MouseEvent evt) {\n    Point2D evtLocation = invert(evt.getPoint());\n    double x = Math.min(this.startDragX, evtLocation.getX());\n    double y = Math.min(this.startDragY, evtLocation.getY());\n    double width = Math.abs(this.startDragX - evtLocation.getX());\n    double height = Math.abs(this.startDragY - evtLocation.getY());\n    if (selectionBox == null) {\n      this.selectionBox = new Rectangle2D.Double(x, y, width, height);\n    } else {\n      this.selectionBox.x = x;\n      this.selectionBox.y = y;\n      this.selectionBox.width = width;\n      this.selectionBox.height = height;\n    }\n  }\n\n  private void dragStage(MouseEvent evt) {\n    Point2D evtLocation = invert(evt.getPoint());\n    double x = evtLocation.getX();\n    double y = evtLocation.getY();\n\n    double stageOffsetX = x - this.startDragX;\n    double stageOffsetY = y - this.startDragY;\n\n    translateStage(stageOffsetX, stageOffsetY);\n  }\n\n  protected void centerStageAt(Point2D point) {\n    centerStageAt(point.getX(), point.getY());\n  }\n\n  public void centerStageAt(double newCenterX, double newCenterY) {\n    double zoom = getZoom();\n\n    newCenterX = newCenterX * zoom;\n    newCenterY = newCenterY * zoom;\n\n    Dimension size = getSize();\n    double widthOffset = size.width / 2d;\n    double heightOffset = size.height / 2d;\n\n    double newX = widthOffset - newCenterX - getTranslateX();\n    double newY = heightOffset - newCenterY - getTranslateY();\n\n    translateStage(newX / zoom, newY / zoom);\n  }\n\n  public void moveStageTo(double x, double y) {\n    x = x - getTranslateX();\n    y = y - getTranslateY();\n    translateStage(x, y);\n  }\n\n  public void translateStage(double x, double y) {\n    this.transform.translate(x, y);\n\n    try {\n      this.inverseTransform = this.transform.createInverse();\n    } catch (NoninvertibleTransformException e) {\n      throw new RuntimeException(e);\n    }\n    notifyStageMoved();\n    resetBuffer();\n  }\n\n  protected double getTranslateX() {\n    return this.transform.getTranslateX();\n  }\n\n  protected double getTranslateY() {\n    return this.transform.getTranslateY();\n  }\n\n  public void toOrigin() {\n    moveStageTo(0, 0);\n  }\n\n  private void dragSelectedNodes(MouseEvent evt) {\n    int oldX = this.nodeUnderMouse.getX();\n    int oldY = this.nodeUnderMouse.getY();\n    dragNode(evt);\n\n    Set<String> selected = new HashSet<>(this.selectedNodes);\n    selected.remove(this.nodeUnderMouse.getId());\n    Set<Node> nodes = this.graph.getNodes(selected);\n\n    int offsetX = this.nodeUnderMouse.getX() - oldX;\n    int offsetY = this.nodeUnderMouse.getY() - oldY;\n    for (Node node : nodes) {\n      int x = node.getX() + offsetX;\n      int y = node.getY() + offsetY;\n\n      node.setX(x);\n      node.setY(y);\n\n    }\n    nodes.add(nodeUnderMouse);\n    notifyNodeDragged(nodes, evt);\n  }\n\n  private void dragNode(MouseEvent evt) {\n    Point2D evtLocation = invert(evt.getPoint());\n    int x = (int) (evtLocation.getX() - this.nodeDragOffsetX);\n    int y = (int) (evtLocation.getY() - this.nodeDragOffsetY);\n\n    nodeUnderMouse.setX(x);\n    nodeUnderMouse.setY(y);\n    notifyNodeDragged(Arrays.asList(this.nodeUnderMouse), evt);\n  }\n\n  private void startDrag(MouseEvent e) {\n    this.isDragging = true;\n    this.nodeUnderMouse = getNodeUnderMouse(e);\n\n    Point2D startDrag = invert(e.getPoint());\n    this.startDragX = (int) startDrag.getX();\n    this.startDragY = (int) startDrag.getY();\n\n    if (nodeUnderMouse != null) {\n      this.nodeDragOffsetX = this.startDragX - nodeUnderMouse.getX();\n      this.nodeDragOffsetY = this.startDragY - nodeUnderMouse.getY();\n\n      this.idleNodes.remove(nodeUnderMouse.getId());\n      this.liveNodes.add(nodeUnderMouse.getId());\n      if (this.nodeDragMode == NodeDragMode.SELECTION) {\n        this.liveNodes.addAll(selectedNodes);\n        this.idleNodes.removeAll(selectedNodes);\n\n        Set<Node> nodes = this.graph.getNodes(selectedNodes);\n        nodes.add(nodeUnderMouse);\n        notifyNodeDragStarted(nodes, e);\n      } else if (this.nodeDragMode == NodeDragMode.CURRENT) {\n        notifyNodeDragStarted(Arrays.asList(this.nodeUnderMouse), e);\n      }\n      resetBuffer();\n\n    } else {\n      notifyStageDragStarted(e);\n    }\n\n  }\n\n  private void stopDrag(MouseEvent e) {\n    if (this.isDragging) {\n      if (this.selectionBox != null && this.stageMode == StageMode.SELECTION) {\n        applyCurrentSelection(e);\n      }\n\n      if (nodeUnderMouse != null) {\n        if (this.nodeDragMode == NodeDragMode.SELECTION) {\n          Set<Node> nodes = this.graph.getNodes(selectedNodes);\n          nodes.add(nodeUnderMouse);\n          notifyNodeDragStopped(nodes, e);\n        } else if (this.nodeDragMode == NodeDragMode.CURRENT) {\n          notifyNodeDragStopped(Arrays.asList(this.nodeUnderMouse), e);\n        }\n\n        this.idleNodes.addAll(this.liveNodes);\n        this.liveNodes.clear();\n        resetBuffer();\n      } else {\n        notifyStageDragStopped(e);\n      }\n      this.isDragging = false;\n      this.nodeUnderMouse = null;\n      this.selectionBox = null;\n    }\n  }\n\n  protected Point2D invert(Point original) {\n    return this.inverseTransform.transform(original, new Point2D.Double());\n  }\n\n  public Shape invert(Shape shape) {\n    return this.inverseTransform.createTransformedShape(shape);\n  }\n\n  public Shape transform(Shape shape) {\n    return this.transform.createTransformedShape(shape);\n  }\n\n  public double transform(double distance) {\n    return this.transform.getScaleX() * distance;\n  }\n\n  @Override\n  public void mouseMoved(MouseEvent e) {\n    if (isMouseHoverEnabled()) {\n      boolean wasHovering = this.nodeUnderMouse != null;\n      String oldId = wasHovering ? this.nodeUnderMouse.getId() : null;\n\n      this.nodeUnderMouse = getNodeUnderMouse(e);\n\n      boolean isHovering = this.nodeUnderMouse != null;\n      String id = isHovering ? this.nodeUnderMouse.getId() : null;\n\n      Edge oldEdge = this.edgeUnderMouse;\n      this.edgeUnderMouse = getEdgeUnderMouse(e);\n      \n      if (wasHovering && !isHovering) {\n        notifyNodeOut(e);\n      } else if (!wasHovering && isHovering) {\n        notifyNodeHover(getHoveredNode(), e);\n      } else if (wasHovering && isHovering && !id.equals(oldId)) {\n        notifyNodeOut(e);\n        notifyNodeHover(getHoveredNode(), e);\n      } else {\n          if(oldEdge == null && this.edgeUnderMouse != null) {\n              notifyEdgeHover(this.edgeUnderMouse, e);\n          }else if(oldEdge != null && this.edgeUnderMouse == null) {\n              notifyEdgeOut(oldEdge, e);\n          }else if(oldEdge != null && this.edgeUnderMouse != null && !oldEdge.equals(this.edgeUnderMouse)) {\n              notifyEdgeOut(oldEdge, e);\n              notifyEdgeHover(this.edgeUnderMouse, e);\n          }\n      }\n      repaint();\n    }\n  }\n\n  public boolean isShowBoundingBoxes() {\n    return showBoundingBoxes;\n  }\n\n  public void setShowBoundingBoxes(boolean showBoundingBoxes) {\n    this.showBoundingBoxes = showBoundingBoxes;\n  }\n\n  public Set<String> getSelected() {\n    return selectedNodes;\n  }\n\n  public boolean isNodeUnderMouse(Node node) {\n    return this.nodeUnderMouse != null && this.nodeUnderMouse.getId().equals(node.getId());\n  }\n\n  public boolean isNodeSelected(Node node) {\n    return this.selectedNodes.contains(node.getId());\n  }\n  \n  public boolean isEdgeSelected(Edge edge) {\n      return this.selectedEdges.contains(edge.getId());\n  }\n\n  public Set<Node> getSelectedNodes() {\n    return this.graph.getNodes(this.selectedNodes);\n  }\n\n  public void removeNode(String id) {\n    Node node = this.graph.getNode(id);\n    this.graph.removeNode(node);\n    repaint();\n  }\n\n  public void removeNodes(Set<String> ids) {\n    Set<Node> nodes = this.graph.getNodes(ids);\n    this.graph.removeNodes(nodes);\n    repaint();\n  }\n\n  public void removeSelectedNodes() {\n    removeNodes(selectedNodes);\n  }\n\n  public void selectNodes(Collection<String> ids, boolean keepSelection) {\n    if (!keepSelection) {\n      this.selectedNodes.clear();\n    }\n    boolean modified = !keepSelection;\n    for (String id : ids) {\n      if (!this.graph.containsNode(id)) {\n        throw new IllegalArgumentException(\"Node \" + id + \" does not exist.\");\n      }\n      modified = modified | this.selectedNodes.add(id);\n    }\n    if (modified) {\n      repaint();\n    }\n  }\n\n  public void selectNodes(Collection<String> ids) {\n    this.selectNodes(ids, false);\n  }\n\n  public void selectNode(String id) {\n    this.selectNode(id, false);\n  }\n\n  public void selectNode(String id, boolean keepSelection) {\n    if (!this.graph.containsNode(id)) {\n      throw new IllegalArgumentException(\"Node \" + id + \" does not exist.\");\n    }\n    if (!keepSelection) {\n      this.selectedNodes.clear();\n    }\n    if (this.selectedNodes.add(id) | !keepSelection) {\n      repaint();\n    }\n  }\n\n  public void deselectNode(String id) {\n    this.selectedNodes.remove(id);\n    repaint();\n  }\n  \n  public void selectEdge(String id) {\n      selectEdge(id, false);\n  }\n  \n  public void selectEdge(String id, boolean keepSelection) {\n      if (!this.graph.containsEdge(id)) {\n          //throw new IllegalArgumentException(\"Edge \" + id + \" does not exist.\");\n      }\n      if(!keepSelection) {\n          this.selectedEdges.clear();    \n      }\n      \n      if(this.selectedEdges.add(id) || !keepSelection) {\n          repaint();\n      }\n  }\n  \n  public void deselectEdge(String id) {\n      this.selectedEdges.remove(id);\n      repaint();\n  }\n\n  public void deselectAll() {\n    this.selectedNodes.clear();\n    this.selectedEdges.clear();\n    repaint();\n  }\n\n  public void selectAll() {\n    this.selectedNodes.addAll(this.graph.getNodeIds());\n    repaint();\n  }\n\n  public void nodesAdded(GraphEvent e) {\n    for (Node node : e.getNodes()) {\n      this.idleNodes.add(node.getId());\n    }\n  }\n\n  public void nodesRemoved(GraphEvent e) {\n    for (Node node : e.getNodes()) {\n      String nodeId = node.getId();\n      this.selectedNodes.remove(nodeId);\n      this.boxesIndex.remove(nodeId);\n      this.liveNodes.remove(nodeId);\n      this.idleNodes.remove(nodeId);\n    }\n\n  }\n\n  @Override\n  public void elementsAdded(GraphEvent e) {\n    nodesAdded(e);\n    resetBuffer();\n  }\n\n  public void elementsRemoved(GraphEvent e) {\n    nodesRemoved(e);\n    resetBuffer();\n  }\n\n  public StageMode getStageMode() {\n    return stageMode;\n  }\n\n  public void setStageMode(StageMode stageMode) {\n    this.stageMode = stageMode;\n  }\n\n  public NodeDragMode getNodeDragMode() {\n    return nodeDragMode;\n  }\n\n  public void setNodeDragMode(NodeDragMode nodeDragMode) {\n    this.nodeDragMode = nodeDragMode;\n  }\n\n  public void resetBuffer() {\n    if (this.idleGraphics != null) {\n      this.idleGraphics.dispose();\n    }\n    this.idleBuffer = null;\n    this.idleGraphics = null;\n  }\n\n  @Override\n  public void componentResized(ComponentEvent e) {\n    resetBuffer();\n  }\n\n  @Override\n  public void componentMoved(ComponentEvent e) {\n\n  }\n\n  @Override\n  public void componentShown(ComponentEvent e) {\n    resetBuffer();\n  }\n\n  @Override\n  public void componentHidden(ComponentEvent e) {\n\n  }\n\n  public Node getHoveredNode() {\n    return this.nodeUnderMouse;\n  }\n\n  public boolean isHovered(Node node) {\n    return this.nodeUnderMouse != null && this.nodeUnderMouse.getId().equals(node.getId());\n  }\n\n  @Override\n  protected void printComponent(Graphics g) {\n    this.isPrinting = true;\n    resetBuffer();\n    super.printComponent(g);\n    this.isPrinting = false;\n  }\n\n  public boolean isHistoryEnabled() {\n    return historyEnabled;\n  }\n\n  public void setHistoryEnabled(boolean historyEnabled) {\n    this.historyEnabled = historyEnabled;\n    if (historyEnabled) {\n      this.addNodeListener(history.getMoveRecorder());\n      this.graph.addListener(history.getGraphRecorder());\n    } else {\n      history.clear();\n      this.removeNodeListener(history.getMoveRecorder());\n      this.graph.removeListener(history.getGraphRecorder());\n    }\n  }\n\n  public GraphHistory getHistory() {\n    return history;\n  }\n\n  public Renderers getRenderers() {\n    return renderers;\n  }\n\n  public Rectangle2D getMinimumBoundingBox() {\n\n    Rectangle2D box = null;\n    Set<Node> nodes = graph.getNodes();\n\n    Iterator<Node> iterator = nodes.iterator();\n    if (iterator.hasNext()) {\n\n      Node node = iterator.next();\n      String type = node.getType();\n      NodeRenderer nodeRenderer = renderers.getNodeRenderer(type);\n      GraphShape graphShape = nodeRenderer.render(null, node, renderContext);\n      box = graphShape.getShape().getBounds2D();\n\n      while (iterator.hasNext()) {\n        node = iterator.next();\n        type = node.getType();\n        nodeRenderer = renderers.getNodeRenderer(type);\n\n        graphShape = nodeRenderer.render(null, node, renderContext);\n        Rectangle2D newBox = graphShape.getShape().getBounds2D();\n\n        box = box.createUnion(newBox);\n\n      }\n    }\n\n    return box;\n  }\n\n  public void reset() {\n    toOrigin();\n    setZoom(1d);\n  }\n\n  public boolean isMouseHoverEnabled() {\n    return mouseHoverEnabled;\n  }\n\n  public void setMouseHoverEnabled(boolean mouseHoverEnabled) {\n    this.mouseHoverEnabled = mouseHoverEnabled;\n  }\n\n  public void applyLayout(HistoryEnabledLayout layout) {\n    Graphics2D graphics = (Graphics2D) getGraphics();\n\n    AffineTransform oldTransform = graphics.getTransform();\n    try {\n      graphics.setTransform(new AffineTransform());\n      Font font = graphics.getFont();\n      FontMetrics fontMetrics = graphics.getFontMetrics(font);\n      List<GraphAction> actions = layout.performLayout(this, fontMetrics);\n      this.history.add(actions);\n    } finally {\n      graphics.setTransform(oldTransform);\n    }\n    resetBuffer();\n  }\n\n  public void fitToScreen() {\n    fitToScreen(1.1d);\n  }\n\n  public void fitToScreen(double gapWeight) {\n    Rectangle2D minimumBoundingBox = getMinimumBoundingBox();\n    if (minimumBoundingBox != null) {\n\n      double width = minimumBoundingBox.getWidth();\n      double height = minimumBoundingBox.getHeight();\n\n      double x = minimumBoundingBox.getX() - width * (gapWeight - 1d) / 2d;\n      double y = minimumBoundingBox.getY() - height * (gapWeight - 1d) / 2d;\n      width = width * gapWeight;\n      height = height * gapWeight;\n\n      fitToScreen(new Rectangle2D.Double(x, y, width, height), MIN_ZOOM, MAX_ZOOM);\n    }\n  }\n\n  protected void fitToScreen(Rectangle2D minimumBoundingBox) {\n    fitToScreen(minimumBoundingBox, 0d, java.lang.Double.MAX_VALUE);\n  }\n\n  protected void fitToScreen(Rectangle2D minimumBoundingBox, double minZoom, double maxZoom) {\n    Dimension2D size = getSize();\n\n    double graphWidth = minimumBoundingBox.getWidth();\n    double previewWidth = size.getWidth();\n\n    double zoomFactorWidth = 0.9d * previewWidth / graphWidth;\n\n    double graphHeight = minimumBoundingBox.getHeight();\n    double previewHeight = size.getHeight();\n\n    double zoomFactorHeight = 0.9d * previewHeight / graphHeight;\n\n    double zoom = Math.min(zoomFactorWidth, zoomFactorHeight);\n\n    zoom = Math.min(zoom, maxZoom);\n    zoom = Math.max(zoom, minZoom);\n\n    setGraphZoom(zoom);\n\n    double centerX = minimumBoundingBox.getCenterX();\n    double centerY = minimumBoundingBox.getCenterY();\n\n    centerStageAt(centerX, centerY);\n  }\n}", "class_id": 0, "repo": "lfcnassif/kharon", "file": "src/main/java/org/kharon/GraphPane.java", "last_update_at": "2020-02-07T01:43:17+00:00", "question_id": "0a75b00f3f760575d0cde31feb30b1f84279a528", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GraphPane extends JComponent\n    implements MouseListener, MouseWheelListener, MouseMotionListener, GraphListener, ComponentListener {\n  private static final long serialVersionUID = 3827345534868023684L;\n  private Graph graph;\n  private Renderers renderers = new Renderers();\n  private boolean mouseHoverEnabled = true;\n  private StageMode stageMode = StageMode.PAN;\n  private NodeDragMode nodeDragMode = NodeDragMode.SELECTION;\n  private RenderContext renderContext;\n  private List<NodeListener> nodeListeners = new ArrayList<>();\n  private List<StageListener> stageListeners = new ArrayList<>();\n  private List<EdgeListener> edgeListeners = new ArrayList<>();\n  private boolean historyEnabled = false;\n  private GraphHistory history;\n  private boolean showBoundingBoxes = false;\n  private boolean mouseWheelZoomEnabled = true;\n  private double scale = 1d / 5d;\n  private static final double MIN_ZOOM = 1d / 4d;\n  private static final double MAX_ZOOM = 5d;\n  private boolean isDragging = false;\n  private Node nodeUnderMouse = null;\n  private Edge edgeUnderMouse = null;\n  protected AffineTransform transform = new AffineTransform();\n  protected AffineTransform inverseTransform = new AffineTransform();\n  private int startDragX;\n  private int startDragY;\n  private int nodeDragOffsetX;\n  private int nodeDragOffsetY;\n  private Set<String> selectedNodes = new HashSet<>();\n  private Set<String> selectedEdges = new HashSet<>();\n  private Map<String, NodeBoundingBox> boxesIndex = new HashMap<>();\n  private Set<String> idleNodes = new HashSet<>();\n  private Set<String> liveNodes = new HashSet<>();\n  private Double selectionBox;\n  private BufferedImage idleBuffer;\n  private Graphics2D idleGraphics;\n  private int lastBufferX;\n  private int lastBufferY;\n  private boolean isPrinting;\n  public GraphPane(Graph graph) {\n    super();\n    this.graph = graph;\n    this.history = new GraphHistory(this);\n    this.renderContext = new RenderContext(this, graph);\n    this.addMouseWheelListener(this);\n    this.addMouseMotionListener(this);\n    this.addMouseListener(this);\n    this.addComponentListener(this);\n    this.graph.addListener(this);\n    this.idleNodes.addAll(this.graph.getNodeIds());\n  }\n  @Override\n  protected void paintComponent(Graphics g) {\n    Graphics2D g2d = (Graphics2D) g;\n    paintGraph(g, this.transform, g2d.getClipBounds());\n  }\n  private void paintGraph(Graphics g, AffineTransform tx, Rectangle2D clipBounds) {\n    Graphics2D g2d = (Graphics2D) g;\n    AffineTransform currentTransform = g2d.getTransform();\n    AffineTransform graphTransformation = (AffineTransform) currentTransform.clone();\n    graphTransformation.concatenate(tx);\n    int originX = (int) (-1 * currentTransform.getTranslateX());\n    int originY = (int) (-1 * currentTransform.getTranslateY());\n    try {\n      clipBounds.setFrame(clipBounds.getX() - Math.abs(originX), clipBounds.getY() - Math.abs(originY),\n          clipBounds.getWidth() + 2 * Math.abs(originX), clipBounds.getHeight() + 2 * Math.abs(originY));\n      clipBounds = graphTransformation.createInverse().createTransformedShape(clipBounds).getBounds2D();\n    } catch (NoninvertibleTransformException e) {\n      throw new RuntimeException(e);\n    }\n    RenderingHints rh = new RenderingHints(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n    g2d.setRenderingHints(rh);\n    int imageWidth = this.getWidth() + Math.abs(originX);\n    int imageHeight = this.getHeight() + Math.abs(originY);\n    BufferedImage liveBuffer = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_ARGB);\n    Graphics2D liveGraphics = liveBuffer.createGraphics();\n    liveGraphics.setRenderingHints(rh);\n    //resetBuffer from other thread could cause NPE because it nulls attributes below\n    BufferedImage idleBuffer = this.idleBuffer;\n    Graphics2D idleGraphics = this.idleGraphics;\n    boolean paintIdleNodes = idleBuffer == null || idleBuffer.getHeight() != imageHeight\n        || idleBuffer.getWidth() != imageWidth || this.lastBufferX != originX || this.lastBufferY != originY;\n    if (paintIdleNodes) {\n      idleBuffer = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_ARGB);\n      idleGraphics = idleBuffer.createGraphics();\n      idleGraphics.setRenderingHints(rh);\n      idleGraphics.setBackground(getBackground());\n      idleGraphics.clearRect(0, 0, imageWidth, imageHeight);\n      this.lastBufferX = originX;\n      this.lastBufferY = originY;\n    }\n    GraphRenderer graphRenderer = renderers.getGraphRenderer(this.graph.getType());\n    graphRenderer.render(liveGraphics, this.graph);\n    Collection<Edge> liveEdges = new ArrayList<>(graph.getNodesOverlappedEdges(this.liveNodes));\n    paintEdges(liveGraphics, graphTransformation, clipBounds, liveEdges);\n    paintNodes(liveGraphics, graphTransformation, currentTransform, clipBounds, graph.getNodes(this.liveNodes));\n    HashSet<Edge> overlappedEdges = new HashSet<>(liveEdges);\n    Collection<Edge> idleEdges = new ArrayList<>(graph.getNodesOverlappedEdges(this.idleNodes));\n    overlappedEdges.addAll(idleEdges);\n    if (paintIdleNodes) {\n      idleEdges.removeAll(liveEdges);\n      paintEdges(idleGraphics, graphTransformation, clipBounds, idleEdges);\n      paintNodes(idleGraphics, graphTransformation, currentTransform, clipBounds, graph.getNodes(this.idleNodes));\n    }\n    g2d.drawImage(idleBuffer, originX, originY, null);\n    Set<String> nodesOfSelectedEdges = paintSelectedEdges(liveGraphics, graphTransformation, clipBounds, overlappedEdges);\n    paintNodes(liveGraphics, graphTransformation, currentTransform, clipBounds, graph.getNodes(nodesOfSelectedEdges));\n    Node hoveredNode = getHoveredNode();\n    if (hoveredNode != null && !isPrinting) {\n      NodeBoundingBox box = this.boxesIndex.get(hoveredNode.getId());\n      if (box != null) {\n        NodeHoverRenderer renderer = renderers.getNodeHoverRenderer(\"default\");\n        GraphShape graphShape = renderer.render(g2d, box, renderContext);\n        graphShape.draw(g2d, tx);\n        paintNodes(liveGraphics, graphTransformation, currentTransform, clipBounds, Arrays.asList(hoveredNode));\n      }\n    }\n    if (!isPrinting) {\n      paintSelections(liveGraphics, graphTransformation, clipBounds);\n    }\n    if (this.selectionBox != null && !isPrinting) {\n      paintSelectionBox(liveGraphics, graphTransformation);\n    }\n    Color color = liveGraphics.getColor();\n    liveGraphics.setColor(Color.BLUE);\n    liveGraphics.fill(graphTransformation.createTransformedShape(new Rectangle2D.Double(-2, -2, 4, 4)));\n    liveGraphics.setColor(Color.GREEN);\n    liveGraphics.fill(new Rectangle2D.Double(-2, -2, 4, 4));\n    liveGraphics.setColor(color);\n    g2d.drawImage(liveBuffer, originX, originY, null);\n    liveGraphics.dispose();\n  }\n  private void paintSelections(Graphics2D g2d, AffineTransform tx, Rectangle2D clipBounds) {\n    for (String selectedId : this.selectedNodes) {\n      Node node = this.graph.getNode(selectedId);\n      NodeBoundingBox boundingBox = this.boxesIndex.get(node.getId());\n      if (boundingBox.intersects(clipBounds)) {\n        SelectionRenderer renderer = renderers.getSelectionRenderer(node.getSelectionType());\n        GraphShape selectionGraphShape = renderer.render(g2d, boundingBox, renderContext);\n        if (selectionGraphShape != null) {\n          selectionGraphShape.draw(g2d, tx);\n        }\n      }\n    }\n  }\n  private void paintSelectionBox(Graphics2D g2d, AffineTransform tx) {\n    Color oldColor = g2d.getColor();\n    g2d.setColor(this.graph.getSettings().getSelectionColor());\n    g2d.draw(tx.createTransformedShape(selectionBox));\n    g2d.setColor(oldColor);\n  }\n  private void paintNodes(Graphics2D g2d, AffineTransform stageTx, AffineTransform componentTx, Rectangle2D clipBounds,\n      Collection<Node> nodes) {\n    for (Node node : nodes) {\n      NodeBoundingBox nodeBoundingBox = this.boxesIndex.get(node.getId());\n      if (nodeBoundingBox == null) {\n        nodeBoundingBox = new NodeBoundingBox(1.4d);\n        this.boxesIndex.put(node.getId(), nodeBoundingBox);\n      } else {\n        nodeBoundingBox.clear();\n      }\n      NodeRenderer renderer = renderers.getNodeRenderer(node.getType());\n      GraphShape nodeGraphShape = renderer.render(g2d, node, renderContext);\n      if (nodeGraphShape != null && nodeGraphShape.getShape().intersects(clipBounds)) {\n        nodeGraphShape.draw(g2d, stageTx);\n        Rectangle2D bounds = nodeBoundingBox.addBox(nodeGraphShape.getShape());\n        if (this.showBoundingBoxes) {\n          g2d.draw(stageTx.createTransformedShape(bounds));\n        }\n      }\n      LabelRenderer labelRenderer = renderers.getLabelRenderer(node.getLabelType());\n      GraphShape labelGraphShape = labelRenderer.render(g2d, node, renderContext);\n      if (labelGraphShape != null && labelGraphShape.getShape().intersects(clipBounds)) {\n        labelGraphShape.draw(g2d, stageTx);\n        Rectangle2D bounds = nodeBoundingBox.addBox(labelGraphShape.getShape());\n        if (this.showBoundingBoxes) {\n          g2d.draw(stageTx.createTransformedShape(bounds));\n        }\n      }\n    }\n  }\n  private void paintEdges(Graphics2D g2d, AffineTransform tx, Rectangle2D clipBounds, Collection<Edge> edges) {\n    for (Edge edge : edges) {\n      EdgeRenderer renderer = renderers.getEdgeRenderer(edge.getType());\n      GraphShape graphShape = renderer.render(g2d, edge, renderContext);\n      if (graphShape != null && graphShape.getShape().intersects(clipBounds)) {\n        graphShape.draw(g2d, tx);\n      }\n    }\n  }\n  private Set<String> paintSelectedEdges(Graphics2D g2d, AffineTransform tx, Rectangle2D clipBounds, Collection<Edge> edges) {\n      Set<String> nodesUnderEdges = new HashSet<>();\n      for (Edge edge : edges) {\n        if(selectedEdges.contains(edge.getId())) {\n            edge.setColor(Color.RED);\n            nodesUnderEdges.add(edge.getSource());\n            nodesUnderEdges.add(edge.getTarget());\n        }else if(edge.equals(this.edgeUnderMouse)){\n            edge.setColor(Color.BLACK);\n            nodesUnderEdges.add(edge.getSource());\n            nodesUnderEdges.add(edge.getTarget());\n        }else {\n            continue;\n        }\n        EdgeRenderer renderer = renderers.getEdgeRenderer(edge.getType());\n        GraphShape graphShape = renderer.render(g2d, edge, renderContext);\n        if (graphShape != null && graphShape.getShape().intersects(clipBounds)) {\n          graphShape.draw(g2d, tx);\n        }\n        edge.setColor(null);\n      }\n      return nodesUnderEdges;\n  }\n  public BufferedImage toImage() {\n    BufferedImage image = new BufferedImage(this.getWidth(), this.getHeight(), BufferedImage.TYPE_INT_ARGB);\n    print(image.getGraphics());\n    return image;\n  }\n  public Graph getGraph() {\n    return graph;\n  }\n  public void addNodeListener(NodeListener nodeListener) {\n    this.nodeListeners.add(nodeListener);\n  }\n  public void removeNodeListener(NodeListener nodeListener) {\n    this.nodeListeners.remove(nodeListener);\n  }\n  public void addEdgeListener(EdgeListener listener) {\n    this.edgeListeners.add(listener);\n  }\n  public void removeEdgeListener(EdgeListener listener) {\n    this.edgeListeners.remove(listener);\n  }\n  public void addStageListener(StageListener stageListener) {\n    this.stageListeners.add(stageListener);\n  }\n  public void removeStageListener(StageListener stageListener) {\n    this.stageListeners.remove(stageListener);\n  }\n  @Override\n  public void mouseClicked(MouseEvent e) {\n    if (this.isEnabled()) {\n      if (this.nodeUnderMouse != null) {\n        notifyNodeClicked(this.nodeUnderMouse, e);\n      } else {\n        if(this.edgeUnderMouse != null) {\n          notifyEdgeClicked(edgeUnderMouse, e);\n        }else {\n          notifyStageClicked(e);    \n        }\n      }\n    }\n  }\n  private void notifyStageClicked(MouseEvent e) {\n    for (StageListener stageListener : this.stageListeners) {\n      stageListener.stageClicked(e);\n    }\n  }\n  private void notifyZoomChanged() {\n    for (StageListener stageListener : this.stageListeners) {\n      stageListener.stageZoomChanged(getZoom());\n    }\n  }\n  private void notifyStageDragStarted(MouseEvent e) {\n    for (StageListener stageListener : this.stageListeners) {\n      stageListener.stageDragStarted(e);\n    }\n  }\n  private void notifyStageDragStopped(MouseEvent e) {\n    for (StageListener stageListener : this.stageListeners) {\n      stageListener.stageDragStopped(e);\n    }\n  }\n  private void notifyStageMoved() {\n    for (StageListener stageListener : this.stageListeners) {\n      stageListener.stageMoved(getTranslateX(), getTranslateY());\n    }\n  }\n  private void notifyNodeClicked(Node node, MouseEvent e) {\n    for (NodeListener listener : this.nodeListeners) {\n      listener.nodeClicked(node, e);\n    }\n  }\n  private void notifyEdgeClicked(Edge edge, MouseEvent e) {\n    for (EdgeListener listener : this.edgeListeners) {\n      listener.edgeClicked(edge, e);\n    }\n  }\n  private void notifyEdgeHover(Edge edge, MouseEvent e) {\n      for (EdgeListener listener : this.edgeListeners) {\n        listener.edgeHovered(edge, e);\n      }\n  }\n  private void notifyEdgeOut(Edge edge, MouseEvent e) {\n      for (EdgeListener listener : this.edgeListeners) {\n        listener.edgeOut(edge, e);\n      }\n  }\n  private void notifyEdgesSelected(Collection<Edge> edges, MouseEvent e) {\n      for (EdgeListener listener : this.edgeListeners) {\n        listener.edgesSelected(edges, e);\n      }\n  }\n  private void notifyNodePressed(Node node, MouseEvent e) {\n    for (NodeListener listener : this.nodeListeners) {\n      listener.nodePressed(node, e);\n    }\n  }\n  private void notifyNodeHover(Node node, MouseEvent e) {\n    for (NodeListener listener : this.nodeListeners) {\n      listener.nodeHover(node, e);\n    }\n  }\n  private void notifyNodeOut(MouseEvent e) {\n    for (NodeListener listener : this.nodeListeners) {\n      listener.nodeOut(e);\n    }\n  }\n  private void notifyNodeReleased(Node node, MouseEvent e) {\n    for (NodeListener listener : this.nodeListeners) {\n      listener.nodeReleased(node, e);\n    }\n  }\n  private void notifyNodeDragStarted(Collection<Node> nodes, MouseEvent e) {\n    for (NodeListener listener : this.nodeListeners) {\n      listener.nodeDragStarted(nodes, e);\n    }\n  }\n  private void notifyNodeDragStopped(Collection<Node> nodes, MouseEvent e) {\n    for (NodeListener listener : this.nodeListeners) {\n      listener.nodeDragStopped(nodes, e);\n    }\n  }\n  private void notifyNodeDragged(Collection<Node> nodes, MouseEvent e) {\n    for (NodeListener listener : this.nodeListeners) {\n      listener.nodeDragged(nodes, e);\n    }\n  }\n  private Node getNodeUnderMouse(MouseEvent evt) {\n    Point2D evtPoint = invert(evt.getPoint());\n    for (Entry<String, NodeBoundingBox> entry : boxesIndex.entrySet()) {\n      NodeBoundingBox box = entry.getValue();\n      if (box.contains(evtPoint)) {\n        String id = entry.getKey();\n        return this.graph.getNode(id);\n      }\n    }\n    return null;\n  }\n  private Edge getEdgeUnderMouse(MouseEvent evt) {\n      Point2D evtPoint = invert(evt.getPoint());\n      Collection<Edge> edges = new ArrayList<>(graph.getNodesOverlappedEdges(this.idleNodes));\n      for (Edge edge : edges) {\n        if (isNearEdge(edge, evtPoint))\n          return edge;\n      }\n      return null;\n  }\n  private boolean isNearEdge(Edge edge, Point2D p) {\n      Node n1 = renderContext.getGraph().getNode(edge.getSource());\n      Node n2 = renderContext.getGraph().getNode(edge.getTarget());\n      double x1 = n1.getX() + n1.getSize() / 2, x2 = n2.getX() + n2.getSize() / 2;\n      double y1 = n1.getY() + n1.getSize() / 2, y2 = n2.getY() + n2.getSize() / 2;\n      double d = 5;\n      if(x1 < x2 && (p.getX() < x1 - d || p.getX() > x2 + d))\n          return false;\n      if(x1 > x2 && (p.getX() > x1 + d || p.getX() < x2 - d))\n          return false;\n      if(y1 < y2 && (p.getY() < y1 - d || p.getY() > y2 + d))\n          return false;\n      if(y1 > y2 && (p.getY() > y1 + d || p.getY() < y2 - d))\n          return false;\n      double num = Math.abs((y2 - y1) * p.getX() - (x2 - x1) * p.getY() + x2 * y1 - y2 * x1);\n      double div = Math.sqrt(Math.pow((y2 - y1), 2) + Math.pow(x2 - x1, 2));\n      double dist = num / div;\n      if(dist < d)\n          return true;\n      else\n          return false;\n  }\n  private void applyCurrentSelection(MouseEvent e) {\n    Set<String> prevSelectedEdges = new HashSet<>(selectedEdges);\n    if (!e.isControlDown() && !e.isShiftDown()) {\n      this.selectedNodes.clear();\n      this.selectedEdges.clear();\n    }\n    for (Entry<String, NodeBoundingBox> entry : boxesIndex.entrySet()) {\n      NodeBoundingBox box = entry.getValue();\n      if (box.intersects(selectionBox)) {\n        String id = entry.getKey();\n        this.selectedNodes.add(id);\n      }\n    }\n    if(selectedNodes.size() > 0) {\n        return;\n    }\n    Collection<Edge> overlappedEdges = new ArrayList<>(graph.getNodesOverlappedEdges(graph.getNodeIds()));\n    Collection<Edge> edgesSelected = new HashSet<>();\n    for(Edge edge : overlappedEdges) {\n        if(getEdgeShape(edge).intersects(selectionBox)) {\n            selectedEdges.add(edge.getId());\n            edgesSelected.add(edge);\n        }\n    }\n    if(prevSelectedEdges.size() != selectedEdges.size()) {\n        notifyEdgesSelected(edgesSelected, e);\n    }else {\n        for(String id : selectedEdges) {\n            if(!prevSelectedEdges.contains(id)) {\n                notifyEdgesSelected(edgesSelected, e);\n                break;\n            }\n        }\n    }\n  }\n  private Shape getEdgeShape(Edge edge) {\n      Node n1 = this.graph.getNode(edge.getSource());\n      Node n2 = this.graph.getNode(edge.getTarget());\n      Line2D shape = new Line2D.Double(n1.getX() + n1.getSize() / 2, n1.getY() + n1.getSize() / 2, \n              n2.getX() + n2.getSize() / 2, n2.getY() + n2.getSize() / 2);\n      return shape;\n  }\n  @Override\n  public void mousePressed(MouseEvent e) {\n    if (this.isEnabled()) {\n      this.nodeUnderMouse = getNodeUnderMouse(e);\n      if (this.nodeUnderMouse != null) {\n        notifyNodePressed(this.nodeUnderMouse, e);\n      }\n    }\n  }\n  @Override\n  public void mouseReleased(MouseEvent e) {\n    if (this.isEnabled()) {\n      stopDrag(e);\n      this.nodeUnderMouse = getNodeUnderMouse(e);\n      if (this.nodeUnderMouse != null) {\n        notifyNodeReleased(this.nodeUnderMouse, e);\n      }\n      repaint();\n    }\n  }\n  @Override\n  public void mouseEntered(MouseEvent e) {\n  }\n  @Override\n  public void mouseExited(MouseEvent e) {\n    if (this.isEnabled()) {\n      stopDrag(e);\n      repaint();\n    }\n  }\n  protected Point2D getCenter() {\n    Dimension size = getSize();\n    double widthOffset = size.width / 2d;\n    double heightOffset = size.height / 2d;\n    double zoom = getZoom();\n    double x = getTranslateX() + widthOffset / zoom;\n    double y = getTranslateY() + heightOffset / zoom;\n    return new Point2D.Double(x, y);\n  }\n  @Override\n  public void mouseWheelMoved(MouseWheelEvent e) {\n    if (this.isEnabled()) {\n      int notches = -1 * e.getWheelRotation();\n      double zoom = getZoom();\n      double newZoom = zoom + (scale * notches);\n      newZoom = Math.min(newZoom, MAX_ZOOM);\n      newZoom = Math.max(newZoom, MIN_ZOOM);\n      if (zoom != newZoom) {\n        setZoom(newZoom, e.getPoint());\n        repaint();\n      }\n    }\n  }\n  public boolean isMouseWheelZoomEnabled() {\n    return mouseWheelZoomEnabled;\n  }\n  public void setMouseWheelZoomEnabled(boolean mouseWheelZoomEnabled) {\n    this.mouseWheelZoomEnabled = mouseWheelZoomEnabled;\n    if (!mouseWheelZoomEnabled) {\n      this.removeMouseWheelListener(this);\n    }\n  }\n  public double getZoom() {\n    return transform.getScaleX();\n  }\n  public void setZoom(double zoom) {\n      setZoom(zoom, null);\n  }\n  public void setZoom(double zoom, Point evtPoint) {\n    zoom = Math.min(zoom, MAX_ZOOM);\n    zoom = Math.max(zoom, MIN_ZOOM);\n    setGraphZoom(zoom, evtPoint);\n  }\n  protected void setGraphZoom(double zoom) {\n      setGraphZoom(zoom, null);\n  }\n  protected void setGraphZoom(double zoom, Point evtPoint) {\n    double oldZoom = getZoom();\n    double translateX = this.getTranslateX();\n    double translateY = this.getTranslateY();\n    Point2D invPoint = null;\n    if(evtPoint != null)\n        invPoint = invert(evtPoint);\n    this.transform.setToScale(zoom, zoom);\n    this.transform.translate(translateX / oldZoom, translateY / oldZoom);\n    try {\n      this.inverseTransform = this.transform.createInverse();\n    } catch (NoninvertibleTransformException e) {\n      throw new RuntimeException(e);\n    }\n    notifyZoomChanged();\n    resetBuffer();\n    if(invPoint != null) {\n        double widthOffset = getSize().width / 2d;\n        double heightOffset = getSize().height / 2d;\n        double dx = (evtPoint.getX() - widthOffset) / zoom;\n        double dy = (evtPoint.getY() - heightOffset) / zoom;\n        centerStageAt(invPoint.getX() - dx, invPoint.getY() - dy);\n    }\n  }\n  @Override\n  public void mouseDragged(MouseEvent evt) {\n    if (this.isEnabled()) {\n      if (!isDragging) {\n        startDrag(evt);\n      }\n      if (nodeUnderMouse != null) {\n        if (this.nodeDragMode == NodeDragMode.CURRENT) {\n          dragNode(evt);\n        } else if (this.nodeDragMode == NodeDragMode.SELECTION) {\n          dragSelectedNodes(evt);\n        }\n        repaint();\n      } else if (this.stageMode == StageMode.PAN) {\n        dragStage(evt);\n        repaint();\n      } else if (this.stageMode == StageMode.SELECTION) {\n        updateSelection(evt);\n        repaint();\n      }\n    }\n  }\n  private void updateSelection(MouseEvent evt) {\n    Point2D evtLocation = invert(evt.getPoint());\n    double x = Math.min(this.startDragX, evtLocation.getX());\n    double y = Math.min(this.startDragY, evtLocation.getY());\n    double width = Math.abs(this.startDragX - evtLocation.getX());\n    double height = Math.abs(this.startDragY - evtLocation.getY());\n    if (selectionBox == null) {\n      this.selectionBox = new Rectangle2D.Double(x, y, width, height);\n    } else {\n      this.selectionBox.x = x;\n      this.selectionBox.y = y;\n      this.selectionBox.width = width;\n      this.selectionBox.height = height;\n    }\n  }\n  private void dragStage(MouseEvent evt) {\n    Point2D evtLocation = invert(evt.getPoint());\n    double x = evtLocation.getX();\n    double y = evtLocation.getY();\n    double stageOffsetX = x - this.startDragX;\n    double stageOffsetY = y - this.startDragY;\n    translateStage(stageOffsetX, stageOffsetY);\n  }\n  protected void centerStageAt(Point2D point) {\n    centerStageAt(point.getX(), point.getY());\n  }\n  public void centerStageAt(double newCenterX, double newCenterY) {\n    double zoom = getZoom();\n    newCenterX = newCenterX * zoom;\n    newCenterY = newCenterY * zoom;\n    Dimension size = getSize();\n    double widthOffset = size.width / 2d;\n    double heightOffset = size.height / 2d;\n    double newX = widthOffset - newCenterX - getTranslateX();\n    double newY = heightOffset - newCenterY - getTranslateY();\n    translateStage(newX / zoom, newY / zoom);\n  }\n  public void moveStageTo(double x, double y) {\n    x = x - getTranslateX();\n    y = y - getTranslateY();\n    translateStage(x, y);\n  }\n  public void translateStage(double x, double y) {\n    this.transform.translate(x, y);\n    try {\n      this.inverseTransform = this.transform.createInverse();\n    } catch (NoninvertibleTransformException e) {\n      throw new RuntimeException(e);\n    }\n    notifyStageMoved();\n    resetBuffer();\n  }\n  protected double getTranslateX() {\n    return this.transform.getTranslateX();\n  }\n  protected double getTranslateY() {\n    return this.transform.getTranslateY();\n  }\n  public void toOrigin() {\n    moveStageTo(0, 0);\n  }\n  private void dragSelectedNodes(MouseEvent evt) {\n    int oldX = this.nodeUnderMouse.getX();\n    int oldY = this.nodeUnderMouse.getY();\n    dragNode(evt);\n    Set<String> selected = new HashSet<>(this.selectedNodes);\n    selected.remove(this.nodeUnderMouse.getId());\n    Set<Node> nodes = this.graph.getNodes(selected);\n    int offsetX = this.nodeUnderMouse.getX() - oldX;\n    int offsetY = this.nodeUnderMouse.getY() - oldY;\n    for (Node node : nodes) {\n      int x = node.getX() + offsetX;\n      int y = node.getY() + offsetY;\n      node.setX(x);\n      node.setY(y);\n    }\n    nodes.add(nodeUnderMouse);\n    notifyNodeDragged(nodes, evt);\n  }\n  private void dragNode(MouseEvent evt) {\n    Point2D evtLocation = invert(evt.getPoint());\n    int x = (int) (evtLocation.getX() - this.nodeDragOffsetX);\n    int y = (int) (evtLocation.getY() - this.nodeDragOffsetY);\n    nodeUnderMouse.setX(x);\n    nodeUnderMouse.setY(y);\n    notifyNodeDragged(Arrays.asList(this.nodeUnderMouse), evt);\n  }\n  private void startDrag(MouseEvent e) {\n    this.isDragging = true;\n    this.nodeUnderMouse = getNodeUnderMouse(e);\n    Point2D startDrag = invert(e.getPoint());\n    this.startDragX = (int) startDrag.getX();\n    this.startDragY = (int) startDrag.getY();\n    if (nodeUnderMouse != null) {\n      this.nodeDragOffsetX = this.startDragX - nodeUnderMouse.getX();\n      this.nodeDragOffsetY = this.startDragY - nodeUnderMouse.getY();\n      this.idleNodes.remove(nodeUnderMouse.getId());\n      this.liveNodes.add(nodeUnderMouse.getId());\n      if (this.nodeDragMode == NodeDragMode.SELECTION) {\n        this.liveNodes.addAll(selectedNodes);\n        this.idleNodes.removeAll(selectedNodes);\n        Set<Node> nodes = this.graph.getNodes(selectedNodes);\n        nodes.add(nodeUnderMouse);\n        notifyNodeDragStarted(nodes, e);\n      } else if (this.nodeDragMode == NodeDragMode.CURRENT) {\n        notifyNodeDragStarted(Arrays.asList(this.nodeUnderMouse), e);\n      }\n      resetBuffer();\n    } else {\n      notifyStageDragStarted(e);\n    }\n  }\n  private void stopDrag(MouseEvent e) {\n    if (this.isDragging) {\n      if (this.selectionBox != null && this.stageMode == StageMode.SELECTION) {\n        applyCurrentSelection(e);\n      }\n      if (nodeUnderMouse != null) {\n        if (this.nodeDragMode == NodeDragMode.SELECTION) {\n          Set<Node> nodes = this.graph.getNodes(selectedNodes);\n          nodes.add(nodeUnderMouse);\n          notifyNodeDragStopped(nodes, e);\n        } else if (this.nodeDragMode == NodeDragMode.CURRENT) {\n          notifyNodeDragStopped(Arrays.asList(this.nodeUnderMouse), e);\n        }\n        this.idleNodes.addAll(this.liveNodes);\n        this.liveNodes.clear();\n        resetBuffer();\n      } else {\n        notifyStageDragStopped(e);\n      }\n      this.isDragging = false;\n      this.nodeUnderMouse = null;\n      this.selectionBox = null;\n    }\n  }\n  protected Point2D invert(Point original) {\n    return this.inverseTransform.transform(original, new Point2D.Double());\n  }\n  public Shape invert(Shape shape) {\n    return this.inverseTransform.createTransformedShape(shape);\n  }\n  public Shape transform(Shape shape) {\n    return this.transform.createTransformedShape(shape);\n  }\n  public double transform(double distance) {\n    return this.transform.getScaleX() * distance;\n  }\n  @Override\n  public void mouseMoved(MouseEvent e) {\n    if (isMouseHoverEnabled()) {\n      boolean wasHovering = this.nodeUnderMouse != null;\n      String oldId = wasHovering ? this.nodeUnderMouse.getId() : null;\n      this.nodeUnderMouse = getNodeUnderMouse(e);\n      boolean isHovering = this.nodeUnderMouse != null;\n      String id = isHovering ? this.nodeUnderMouse.getId() : null;\n      Edge oldEdge = this.edgeUnderMouse;\n      this.edgeUnderMouse = getEdgeUnderMouse(e);\n      if (wasHovering && !isHovering) {\n        notifyNodeOut(e);\n      } else if (!wasHovering && isHovering) {\n        notifyNodeHover(getHoveredNode(), e);\n      } else if (wasHovering && isHovering && !id.equals(oldId)) {\n        notifyNodeOut(e);\n        notifyNodeHover(getHoveredNode(), e);\n      } else {\n          if(oldEdge == null && this.edgeUnderMouse != null) {\n              notifyEdgeHover(this.edgeUnderMouse, e);\n          }else if(oldEdge != null && this.edgeUnderMouse == null) {\n              notifyEdgeOut(oldEdge, e);\n          }else if(oldEdge != null && this.edgeUnderMouse != null && !oldEdge.equals(this.edgeUnderMouse)) {\n              notifyEdgeOut(oldEdge, e);\n              notifyEdgeHover(this.edgeUnderMouse, e);\n          }\n      }\n      repaint();\n    }\n  }\n  public boolean isShowBoundingBoxes() {\n    return showBoundingBoxes;\n  }\n  public void setShowBoundingBoxes(boolean showBoundingBoxes) {\n    this.showBoundingBoxes = showBoundingBoxes;\n  }\n  public Set<String> getSelected() {\n    return selectedNodes;\n  }\n  public boolean isNodeUnderMouse(Node node) {\n    return this.nodeUnderMouse != null && this.nodeUnderMouse.getId().equals(node.getId());\n  }\n  public boolean isNodeSelected(Node node) {\n    return this.selectedNodes.contains(node.getId());\n  }\n  public boolean isEdgeSelected(Edge edge) {\n      return this.selectedEdges.contains(edge.getId());\n  }\n  public Set<Node> getSelectedNodes() {\n    return this.graph.getNodes(this.selectedNodes);\n  }\n  public void removeNode(String id) {\n    Node node = this.graph.getNode(id);\n    this.graph.removeNode(node);\n    repaint();\n  }\n  public void removeNodes(Set<String> ids) {\n    Set<Node> nodes = this.graph.getNodes(ids);\n    this.graph.removeNodes(nodes);\n    repaint();\n  }\n  public void removeSelectedNodes() {\n    removeNodes(selectedNodes);\n  }\n  public void selectNodes(Collection<String> ids, boolean keepSelection) {\n    if (!keepSelection) {\n      this.selectedNodes.clear();\n    }\n    boolean modified = !keepSelection;\n    for (String id : ids) {\n      if (!this.graph.containsNode(id)) {\n        throw new IllegalArgumentException(\"Node \" + id + \" does not exist.\");\n      }\n      modified = modified | this.selectedNodes.add(id);\n    }\n    if (modified) {\n      repaint();\n    }\n  }\n  public void selectNodes(Collection<String> ids) {\n    this.selectNodes(ids, false);\n  }\n  public void selectNode(String id) {\n    this.selectNode(id, false);\n  }\n  public void selectNode(String id, boolean keepSelection) {\n    if (!this.graph.containsNode(id)) {\n      throw new IllegalArgumentException(\"Node \" + id + \" does not exist.\");\n    }\n    if (!keepSelection) {\n      this.selectedNodes.clear();\n    }\n    if (this.selectedNodes.add(id) | !keepSelection) {\n      repaint();\n    }\n  }\n  public void deselectNode(String id) {\n    this.selectedNodes.remove(id);\n    repaint();\n  }\n  public void selectEdge(String id) {\n      selectEdge(id, false);\n  }\n  public void selectEdge(String id, boolean keepSelection) {\n      if (!this.graph.containsEdge(id)) {\n          //throw new IllegalArgumentException(\"Edge \" + id + \" does not exist.\");\n      }\n      if(!keepSelection) {\n          this.selectedEdges.clear();    \n      }\n      if(this.selectedEdges.add(id) || !keepSelection) {\n          repaint();\n      }\n  }\n  public void deselectEdge(String id) {\n      this.selectedEdges.remove(id);\n      repaint();\n  }\n  public void deselectAll() {\n    this.selectedNodes.clear();\n    this.selectedEdges.clear();\n    repaint();\n  }\n  public void selectAll() {\n    this.selectedNodes.addAll(this.graph.getNodeIds());\n    repaint();\n  }\n  public void nodesAdded(GraphEvent e) {\n    for (Node node : e.getNodes()) {\n      this.idleNodes.add(node.getId());\n    }\n  }\n  public void nodesRemoved(GraphEvent e) {\n    for (Node node : e.getNodes()) {\n      String nodeId = node.getId();\n      this.selectedNodes.remove(nodeId);\n      this.boxesIndex.remove(nodeId);\n      this.liveNodes.remove(nodeId);\n      this.idleNodes.remove(nodeId);\n    }\n  }\n  @Override\n  public void elementsAdded(GraphEvent e) {\n    nodesAdded(e);\n    resetBuffer();\n  }\n  public void elementsRemoved(GraphEvent e) {\n    nodesRemoved(e);\n    resetBuffer();\n  }\n  public StageMode getStageMode() {\n    return stageMode;\n  }\n  public void setStageMode(StageMode stageMode) {\n    this.stageMode = stageMode;\n  }\n  public NodeDragMode getNodeDragMode() {\n    return nodeDragMode;\n  }\n  public void setNodeDragMode(NodeDragMode nodeDragMode) {\n    this.nodeDragMode = nodeDragMode;\n  }\n  public void resetBuffer() {\n    if (this.idleGraphics != null) {\n      this.idleGraphics.dispose();\n    }\n    this.idleBuffer = null;\n    this.idleGraphics = null;\n  }\n  @Override\n  public void componentResized(ComponentEvent e) {\n    resetBuffer();\n  }\n  @Override\n  public void componentMoved(ComponentEvent e) {\n  }\n  @Override\n  public void componentShown(ComponentEvent e) {\n    resetBuffer();\n  }\n  @Override\n  public void componentHidden(ComponentEvent e) {\n  }\n  public Node getHoveredNode() {\n    return this.nodeUnderMouse;\n  }\n  public boolean isHovered(Node node) {\n    return this.nodeUnderMouse != null && this.nodeUnderMouse.getId().equals(node.getId());\n  }\n  @Override\n  protected void printComponent(Graphics g) {\n    this.isPrinting = true;\n    resetBuffer();\n    super.printComponent(g);\n    this.isPrinting = false;\n  }\n  public boolean isHistoryEnabled() {\n    return historyEnabled;\n  }\n  public void setHistoryEnabled(boolean historyEnabled) {\n    this.historyEnabled = historyEnabled;\n    if (historyEnabled) {\n      this.addNodeListener(history.getMoveRecorder());\n      this.graph.addListener(history.getGraphRecorder());\n    } else {\n      history.clear();\n      this.removeNodeListener(history.getMoveRecorder());\n      this.graph.removeListener(history.getGraphRecorder());\n    }\n  }\n  public GraphHistory getHistory() {\n    return history;\n  }\n  public Renderers getRenderers() {\n    return renderers;\n  }\n  public Rectangle2D getMinimumBoundingBox() {\n    Rectangle2D box = null;\n    Set<Node> nodes = graph.getNodes();\n    Iterator<Node> iterator = nodes.iterator();\n    if (iterator.hasNext()) {\n      Node node = iterator.next();\n      String type = node.getType();\n      NodeRenderer nodeRenderer = renderers.getNodeRenderer(type);\n      GraphShape graphShape = nodeRenderer.render(null, node, renderContext);\n      box = graphShape.getShape().getBounds2D();\n      while (iterator.hasNext()) {\n        node = iterator.next();\n        type = node.getType();\n        nodeRenderer = renderers.getNodeRenderer(type);\n        graphShape = nodeRenderer.render(null, node, renderContext);\n        Rectangle2D newBox = graphShape.getShape().getBounds2D();\n        box = box.createUnion(newBox);\n      }\n    }\n    return box;\n  }\n  public void reset() {\n    toOrigin();\n    setZoom(1d);\n  }\n  public boolean isMouseHoverEnabled() {\n    return mouseHoverEnabled;\n  }\n  public void setMouseHoverEnabled(boolean mouseHoverEnabled) {\n    this.mouseHoverEnabled = mouseHoverEnabled;\n  }\n  public void applyLayout(HistoryEnabledLayout layout) {\n    Graphics2D graphics = (Graphics2D) getGraphics();\n    AffineTransform oldTransform = graphics.getTransform();\n    try {\n      graphics.setTransform(new AffineTransform());\n      Font font = graphics.getFont();\n      FontMetrics fontMetrics = graphics.getFontMetrics(font);\n      List<GraphAction> actions = layout.performLayout(this, fontMetrics);\n      this.history.add(actions);\n    } finally {\n      graphics.setTransform(oldTransform);\n    }\n    resetBuffer();\n  }\n  public void fitToScreen() {\n    fitToScreen(1.1d);\n  }\n  public void fitToScreen(double gapWeight) {\n    Rectangle2D minimumBoundingBox = getMinimumBoundingBox();\n    if (minimumBoundingBox != null) {\n      double width = minimumBoundingBox.getWidth();\n      double height = minimumBoundingBox.getHeight();\n      double x = minimumBoundingBox.getX() - width * (gapWeight - 1d) / 2d;\n      double y = minimumBoundingBox.getY() - height * (gapWeight - 1d) / 2d;\n      width = width * gapWeight;\n      height = height * gapWeight;\n      fitToScreen(new Rectangle2D.Double(x, y, width, height), MIN_ZOOM, MAX_ZOOM);\n    }\n  }\n  protected void fitToScreen(Rectangle2D minimumBoundingBox) {\n    fitToScreen(minimumBoundingBox, 0d, java.lang.Double.MAX_VALUE);\n  }\n  protected void fitToScreen(Rectangle2D minimumBoundingBox, double minZoom, double maxZoom) {\n    Dimension2D size = getSize();\n    double graphWidth = minimumBoundingBox.getWidth();\n    double previewWidth = size.getWidth();\n    double zoomFactorWidth = 0.9d * previewWidth / graphWidth;\n    double graphHeight = minimumBoundingBox.getHeight();\n    double previewHeight = size.getHeight();\n    double zoomFactorHeight = 0.9d * previewHeight / graphHeight;\n    double zoom = Math.min(zoomFactorWidth, zoomFactorHeight);\n    zoom = Math.min(zoom, maxZoom);\n    zoom = Math.max(zoom, minZoom);\n    setGraphZoom(zoom);\n    double centerX = minimumBoundingBox.getCenterX();\n    double centerY = minimumBoundingBox.getCenterY();\n    centerStageAt(centerX, centerY);\n  }\n"]]}
{"hexsha": "372131a3123cd20a5318bc147c894299daa61adc", "ext": "java", "lang": "Java", "content": "class AccessSetHt extends AccessSet {\n    // Normal per-object reference table\n    private HashMap<Long, AccessSetObj> ht;\n    // Flattened atomic table for faster atomic-nonatomic intersection\n    private HashMap<Long, AccessSetObj> flattenedATable;\n\n    // constructor for AccessSetHt\n    public AccessSetHt() {\n        ht = new HashMap<Long, AccessSetObj>();\n        flattenedATable = new HashMap<Long, AccessSetObj>();\n    }\n\n    public void setHt(HashMap<Long, AccessSetObj> hm) {\n        this.ht = hm;\n    }\n\n    public HashMap<Long, AccessSetObj> getHt() {\n        return ht;\n    }\n    public HashMap<Long, AccessSetObj> getFlattenedATable() {\n        return this.flattenedATable;\n    }\n\n    /**\n     * Hashmap print\n     */\n    @Override\n    public void print(){\n        Long obj;\n        AccessSetObj entry;\n        System.out.println(\"Normal accesses\");\n        System.out.print(\"{\");\n        Set addrSet = this.ht.keySet();\n        Iterator itr = addrSet.iterator();\n        while (itr.hasNext()) {\n            obj = (Long) itr.next();\n            System.out.print(obj);\n            entry = (AccessSetObj) this.ht.get(obj);\n            if (entry != null) {\n                System.out.print(\"(\");\n                entry.print();\n                System.out.print(\"),\");\n            }\n\n        }\n        System.out.println(\"}\");\n        System.out.println(\"Atomic accesses\");\n    }\n\n    /**\n     * set intersection.\n     */\n    @Override\n    public void intersect(AccessSet set, int taskType) {\n        // perform intersection on reads/writes\n        Long obj;\n        AccessSetObj entry2;\n        AccessSetObj entry;\n        \n        // if incoming set is a hashtable\n        if (set instanceof AccessSetHt) {\n            AccessSetHt setHt = (AccessSetHt) set;\n            HashMap<Long, AccessSetObj> ht2 = setHt.getHt();\n            Set addrSet = ht2.keySet();\n            Iterator itr = addrSet.iterator();\n            while (itr.hasNext()) {\n                obj = (Long) itr.next();\n                entry = (AccessSetObj) this.ht.get(obj);\n                if (entry != null) {\n                    // skip the reduction object on S node\n                    if (entry.accessInfo instanceof RubyReduction\n                            && taskType != RaceTask.RACE_TASK_FINISH) {\n                        continue;\n                    }\n                    entry2 = (AccessSetObj) ht2.get(obj);\n                    entry.intersect(entry2, obj);\n                }\n            }\n            // Intersect my atomic part with incoming non-atomic part\n            // Note: no merge!\n            // Note: use flattened atomic table\n            for (Long objId : ht2.keySet()) {\n                AccessSetObj incomingEntry = (AccessSetObj) ht2.get(objId);\n                AccessSetObj myEntry = (AccessSetObj) this.flattenedATable.get(objId);\n\n                if (myEntry != null) {\n                    // skip the reduction object on S node\n                    if (!(myEntry.accessInfo instanceof RubyReduction && taskType != RaceTask.RACE_TASK_FINISH)) {\n                        myEntry.intersect(incomingEntry, objId);\n                    }\n                }\n            }\n            // Intersect my non-atomic part with incoming atomic part\n            // Note: no merge!\n            HashMap<Long, AccessSetObj> flattenedAT2 = setHt.getFlattenedATable();\n            for (Long objId : flattenedAT2.keySet()) {\n                AccessSetObj incomingEntry = (AccessSetObj) (flattenedAT2.get(objId));\n                AccessSetObj myEntry = (AccessSetObj) this.ht.get(objId);\n\n                if (myEntry != null) {\n                    // skip the reduction object on S node\n                    if (!(myEntry.accessInfo instanceof RubyReduction && taskType != RaceTask.RACE_TASK_FINISH)) {\n                        myEntry.intersect(incomingEntry, objId);\n                    }\n                }\n            }\n        }\n        // the incoming log is a list\n        else {\n            AccessSetList setList = (AccessSetList) set;\n            long[] reads = setList.getReads();\n            long writes[] = setList.getWrites();\n            Object[] readInfo = setList.getRdInfo();\n            Object[] writeInfo = setList.getWrtInfo();\n            IRubyObject[] readCommScope = setList.getReadCommScope();\n            IRubyObject[] writeCommScope = setList.getWriteCommScope();\n\n            for (int i = 0; i < setList.getReadSize(); i += 2) {\n                obj = reads[i];\n                // detect read-write conflicts\n                // Incoming ops vs. atomic ops\n                HashMap<Long, AccessSetObj> workingTable = this.flattenedATable;\n                entry = (AccessSetObj) (workingTable.get(obj));\n                // Only check for non-atomic ops\n                if (readCommScope[i / 2] == null && entry != null) {\n                    if (entry.isIn((int) reads[i + 1], WRT_FLAG)) {\n                        // only find reduction problems on P node\n                        if (readInfo[i / 2] instanceof RubyReduction\n                                && taskType != RaceTask.RACE_TASK_FINISH) {\n                            continue;\n                        }\n                        if (RaceDetector.detailMode) {\n                            RaceDetector.recordRace(obj, (int) reads[i + 1], (MemoryOprInfo) readInfo[i / 2],\n                                    ((AccessSetObjDetailBm) entry).getMemOprInfo(\n                                            (int) reads[i + 1], WRT_FLAG));\n                        } else {\n                            RaceDetector.recordRace(obj, readInfo[i / 2], (int) reads[i + 1]);\n                        }\n                    }\n                }\n                // Incoming ops vs. non-atomic ops\n                workingTable = this.ht;\n                entry = (AccessSetObj) (workingTable.get(obj));\n                if (entry != null) {\n                    if (entry.isIn((int) reads[i + 1], WRT_FLAG)) {\n                        // only find reduction problems on P node\n                        if (readInfo[i / 2] instanceof RubyReduction\n                                && taskType != RaceTask.RACE_TASK_FINISH) {\n                            continue;\n                        }\n                        if (RaceDetector.detailMode) {\n                            RaceDetector.recordRace(obj, (int) reads[i + 1],\n                                    (MemoryOprInfo) readInfo[i / 2], ((AccessSetObjDetailBm) entry)\n                                            .getMemOprInfo((int) reads[i + 1], WRT_FLAG));\n                        } else {\n                            RaceDetector.recordRace(obj, readInfo[i / 2], (int) reads[i + 1]);\n                        }\n                    }\n                }\n            }\n            for (int i = 0; i < setList.getWriteSize(); i += 2) {\n                obj = writes[i];\n                // detect write-write and read-write conflicts\n                // Incoming ops vs. atomic ops\n                HashMap<Long, AccessSetObj> workingTable = this.flattenedATable;\n                entry = (AccessSetObj) (workingTable.get(obj));\n                // Only check for non-atomic ops\n                if (writeCommScope[i / 2] == null && entry != null) {\n                    if (entry.isIn((int) writes[i + 1], WRT_FLAG)\n                        || entry.isIn((int) writes[i + 1], RD_FLAG)) {\n                        // only find reduction problems on P node\n                        if (writeInfo[i / 2] instanceof RubyReduction\n                                && taskType != RaceTask.RACE_TASK_FINISH) {\n                            continue;\n                        }\n                        if (RaceDetector.detailMode) {\n                            if (entry.isIn((int) writes[i + 1], WRT_FLAG))\n                                RaceDetector.recordRace(obj, (int) writes[i + 1],\n                                        (MemoryOprInfo) writeInfo[i / 2],\n                                        ((AccessSetObjDetailBm) entry).getMemOprInfo(\n                                                (int) writes[i + 1], WRT_FLAG));\n                            else\n                                RaceDetector.recordRace(obj, (int) writes[i + 1],\n                                        (MemoryOprInfo) writeInfo[i / 2],\n                                        ((AccessSetObjDetailBm) entry).getMemOprInfo(\n                                                (int) writes[i + 1], RD_FLAG));\n                        } else {\n                            RaceDetector.recordRace(obj, writeInfo[i / 2], (int) writes[i + 1]);\n                        }\n                    }\n                }\n                // Incoming ops vs. non-atomic ops\n                workingTable = this.ht;\n                entry = (AccessSetObj) (workingTable.get(obj));\n                if (entry != null) {\n                    if (entry.isIn((int) writes[i + 1], WRT_FLAG)\n                            || entry.isIn((int) writes[i + 1], RD_FLAG)) {\n                        // only find reduction problems on P node\n                        if (readInfo[i / 2] instanceof RubyReduction\n                                && taskType != RaceTask.RACE_TASK_FINISH) {\n                            continue;\n                        }\n                        if (RaceDetector.detailMode) {\n                            if (entry.isIn((int) writes[i + 1], WRT_FLAG))\n                                RaceDetector.recordRace(obj, (int) writes[i + 1],\n                                        (MemoryOprInfo) writeInfo[i / 2],\n                                        ((AccessSetObjDetailBm) entry).getMemOprInfo(\n                                                (int) writes[i + 1], WRT_FLAG));\n                            else\n                                RaceDetector.recordRace(obj, (int) writes[i + 1],\n                                        (MemoryOprInfo) writeInfo[i / 2],\n                                        ((AccessSetObjDetailBm) entry).getMemOprInfo(\n                                                (int) writes[i + 1], RD_FLAG));\n                        } else {\n                            RaceDetector.recordRace(obj, writeInfo[i / 2],\n                                    (int) writes[i + 1]);\n                        }\n                    }\n                }\n            }\n        }\n        // Perform intersection on methods\n        intersectCall(set);\n    }\n\n    /**\n     * set merge\n     */\n    @Override\n    public AccessSet merge(AccessSet set) {\n        AccessSetObj entry;\n        Long obj;\n        AccessSetObj entry2;\n        // the incoming log is a hash table\n        if (set instanceof AccessSetHt) {\n            // Merge non-atomic part\n            AccessSetHt setHt = (AccessSetHt) set;\n            HashMap ht2 = setHt.getHt();\n            Set addrSet = ht2.keySet();\n            Iterator itr = addrSet.iterator();\n            while (itr.hasNext()) {\n                obj = (Long) itr.next();\n                entry = (AccessSetObj) this.ht.get(obj);\n                entry2 = (AccessSetObj) ht2.get(obj);\n                if (entry != null) {\n                    size += entry.merge(entry2);\n                } else {\n                    ht.put(obj, entry2);\n                    size += entry2.size();\n                }\n            }\n            // Merge flattened table\n            // Intersect my non-atomic part with incoming atomic part\n            // Note: no merge!\n            HashMap<Long, AccessSetObj> flattenedAT2 = setHt.getFlattenedATable();\n            HashMap<Long, AccessSetObj> myAT = this.flattenedATable;\n            for (Long objId : flattenedAT2.keySet()) {\n                AccessSetObj incomingEntry = (AccessSetObj) (flattenedAT2.get(objId));\n                AccessSetObj myEntry = (AccessSetObj) this.flattenedATable.get(objId);\n                if (myEntry != null) {\n                    myEntry.merge(incomingEntry);\n                } else {\n                    myAT.put(objId, incomingEntry);\n                }\n            }\n        } else { // the incoming log is a list\n            AccessSetList setList = (AccessSetList) set;\n            long[] reads = setList.getReads();\n            long writes[] = setList.getWrites();\n            Object[] readInfo = setList.getRdInfo();\n            Object[] writeInfo = setList.getWrtInfo();\n            IRubyObject[] readCommScope = setList.getReadCommScope();\n            IRubyObject[] writeCommScope = setList.getWriteCommScope();\n            for (int i = 0; i < setList.getReadSize(); i += 2) {\n                obj = reads[i];\n                // Check for atomic ops\n                HashMap<Long, AccessSetObj> workingTable = this.ht;\n                if (readCommScope[i / 2] != null) {\n                    workingTable = this.flattenedATable;\n                }\n                entry = (AccessSetObj) (workingTable.get(obj));\n                // merge reads\n                if (entry == null) {\n                    if (RaceDetector.spaceTreeOn\n                            && readInfo[i / 2] instanceof String\n                            && ((String) readInfo[i / 2]).equals(\"ARRAY\")) {\n                        entry = new AccessSetObjSt();\n                        entry.insert((int) (reads[i + 1]), RD_FLAG);\n                    } else if (RaceDetector.detailMode) {\n                        entry = new AccessSetObjDetailBm((int) (reads[i + 1]),\n                                RD_FLAG, (MemoryOprInfo) readInfo[i / 2]);\n                        size += 2;\n                    } else {\n                        entry = new AccessSetObjBm(readInfo[i / 2],\n                                (int) (reads[i + 1]), 0, 0, RD_FLAG);\n                        size += 2;\n                    }\n                    workingTable.put(obj, entry);\n                } else {\n                    if (RaceDetector.detailMode) {\n                        size += ((AccessSetObjDetailBm) entry).insert((int) reads[i + 1], RD_FLAG,\n                                (MemoryOprInfo) readInfo[i / 2]);\n                    } else {\n                        size += entry.insert((int) reads[i + 1], RD_FLAG);\n                    }\n                }\n            }\n            for (int i = 0; i < setList.getWriteSize(); i += 2) {\n                obj = writes[i];\n                // For atomic ops\n                HashMap<Long, AccessSetObj> workingTable = this.ht;\n                if (writeCommScope[i / 2] != null) {\n                    workingTable = this.flattenedATable;\n                }\n                entry = (AccessSetObj) (workingTable.get(obj));\n                // merge writes\n                if (entry == null) {\n                    if (RaceDetector.spaceTreeOn\n                            && writeInfo[i / 2] instanceof String\n                            && ((String) writeInfo[i / 2]).equals(\"ARRAY\")) {\n\n                        entry = new AccessSetObjSt();\n                        entry.insert((int) (writes[i + 1]), WRT_FLAG);\n                    } else if (RaceDetector.detailMode) {\n                        entry = new AccessSetObjDetailBm((int) (writes[i + 1]),\n                                WRT_FLAG, (MemoryOprInfo) writeInfo[i / 2]);\n                        size += 2;\n                    } else {\n                        entry = new AccessSetObjBm(writeInfo[i / 2],\n                                (int) (writes[i + 1]), 0, 0, WRT_FLAG);\n                        size += 2;\n                    }\n                    workingTable.put(obj, entry);\n                } else {\n                    if (RaceDetector.detailMode) {\n                        size += ((AccessSetObjDetailBm) entry).insert((int) writes[i + 1], WRT_FLAG,\n                                (MemoryOprInfo) writeInfo[i / 2]);\n                    } else {\n                        size += entry.insert((int) writes[i + 1], WRT_FLAG);\n                    }\n                }\n            }\n        }\n\n        this.mergeNum += set.getMergeNum();\n\n        // for commutative\n        mergeCall(set);\n        set.clear();\n        return this;\n    }\n\n    /**\n     * set intersection and merge\n     */\n    @Override\n    public AccessSet intersectAndMerge(AccessSet set, int taskType) {\n        long obj;\n        AccessSetObj entry;\n        AccessSetObj entry2;\n\n        // TODO: intersect and merge with atomicTable\n        // the incoming log is a hash table\n        if (set instanceof AccessSetHt) {\n             // Intersect and merge non-atomic part\n            AccessSetHt setHt = (AccessSetHt) set;\n            HashMap<Long, AccessSetObj> ht2 = setHt.getHt();\n\n            Set addrSet = ht2.keySet();\n            Iterator itr = addrSet.iterator();\n            while (itr.hasNext()) {\n                obj = (Long) itr.next();\n                entry = (AccessSetObj) this.ht.get(obj);\n                if (entry != null) {\n                    entry2 = (AccessSetObj) ht2.get(obj);\n                    // skip the reduction object on S node\n                    if (!(entry.accessInfo instanceof RubyReduction && taskType != RaceTask.RACE_TASK_FINISH)) {\n                        entry.intersect(entry2, obj);\n                    }\n                    size += entry.merge(entry2);\n\n                } else {// merge\n                    entry2 = (AccessSetObj) ht2.get(obj);\n                    this.ht.put(obj, entry2);\n                    size += entry2.size();\n                }\n            }\n            this.mergeNum += set.getMergeNum();\n            // Intersect my atomic part with incoming non-atomic part\n            // Note: no merge!\n            // Note: use flattened atomic table\n            for (Long objId : ht2.keySet()) {\n                AccessSetObj incomingEntry = (AccessSetObj) ht2.get(objId);\n                AccessSetObj myEntry = (AccessSetObj) this.flattenedATable.get(objId);\n                if (myEntry != null) {\n                    // skip the reduction object on S node\n                    if (!(myEntry.accessInfo instanceof RubyReduction && taskType != RaceTask.RACE_TASK_FINISH)) {\n                        myEntry.intersect(incomingEntry, objId);\n                    }\n                }\n            }\n            // Intersect my non-atomic part with incoming atomic part\n            // Note: no merge!\n            HashMap<Long, AccessSetObj> flattenedAT2 = setHt.getFlattenedATable();\n            for (Long objId : flattenedAT2.keySet()) {\n                AccessSetObj incomingEntry = (AccessSetObj) (flattenedAT2.get(objId));\n                AccessSetObj myEntry = (AccessSetObj) this.ht.get(objId);\n                if (myEntry != null) {\n                    // skip the reduction object on S node\n                    if (!(myEntry.accessInfo instanceof RubyReduction && taskType != RaceTask.RACE_TASK_FINISH)) {\n                        myEntry.intersect(incomingEntry, objId);\n                    }\n                }\n            }\n            // Merge flattened table\n            HashMap<Long, AccessSetObj> myAT = this.flattenedATable;\n            for (Long objId : flattenedAT2.keySet()) {\n                AccessSetObj incomingEntry = (AccessSetObj) (flattenedAT2.get(objId));\n                AccessSetObj myEntry = (AccessSetObj) this.flattenedATable.get(objId);\n                if (myEntry != null) {\n                    myEntry.merge(incomingEntry);\n                } else {\n                    myAT.put(objId, incomingEntry);\n                }\n            }\n            // Deal with ac-ops\n            intersectCall(set);\n            mergeCall(set);\n        }\n        // the incoming log is a list\n        else {\n            this.intersect(set, taskType);\n            this.merge(set);\n        }\n\n        set.clear();\n        return this;\n    }\n\n    @Override\n    public void clear() {\n        this.mergeNum = 0;\n        ht.clear();\n        flattenedATable.clear();\n        super.clear();\n    }\n\n    @Override\n    public long size() {\n        return this.size;\n    }\n\n    /**\n     * Insert a log into current access-set \n     */\n    @Override\n    public AccessSet insert(long obj, int offset, int flag, int file,\n            int line, Object info, IRubyObject commScope) {\n        if (offset < 0){\n            return this;\n        }\n        \n        HashMap<Long, AccessSetObj> operatingTable = ht;\n        int atomicModifier = 0;\n        // If the incoming flag indicates this is an op in atomic method, change\n        if (flag >= AccessSet.ATOMIC_OP_OFFSET) {\n            atomicModifier = AccessSet.ATOMIC_OP_OFFSET;\n            // Add this operation to flattened table\n            AccessSetObj flattenedEntry = (AccessSetObj) this.flattenedATable.get(obj);\n            if (flattenedEntry == null) {\n                if (RaceDetector.detailMode) {\n                    flattenedEntry = new AccessSetObjDetailBm(offset, flag - atomicModifier,\n                            ((MemoryOprInfo) info).clone());\n                } else {\n                    flattenedEntry = new AccessSetObjBm(info, offset, line, file, flag\n                            - atomicModifier);\n                }\n                this.flattenedATable.put(obj, flattenedEntry);\n            } else {\n                if (RaceDetector.detailMode) {\n                    ((AccessSetObjDetailBm) flattenedEntry).insert(offset, flag - atomicModifier,\n                            ((MemoryOprInfo) info).clone());\n                } else {\n                    flattenedEntry.insert(offset, flag - atomicModifier);\n                }\n            }\n            return this;\n        } \n        AccessSetObj entry = (AccessSetObj) operatingTable.get(obj);\n        if (entry == null) {\n            if (RaceDetector.spaceTreeOn && info instanceof String\n                    && ((String) info).equals(\"ARRAY\")) {\n                entry = new AccessSetObjSt();\n            } else if (RaceDetector.detailMode) {\n                entry = new AccessSetObjDetailBm(offset, flag - atomicModifier,\n                        ((MemoryOprInfo) info).clone());\n            } else {\n                entry = new AccessSetObjBm(info, offset, line, file, flag - atomicModifier);\n            }\n            operatingTable.put(obj, entry);\n            size += 2;\n        } else {\n            if (RaceDetector.detailMode) {\n                size += ((AccessSetObjDetailBm) entry).insert(offset, flag - atomicModifier,\n                        ((MemoryOprInfo) info).clone());\n            } else {\n                size += entry.insert(offset, flag - atomicModifier);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Insert a batch of accesses into current set\n     */\n    @Override\n    public AccessSet insert(long obj, int offset, int flag, int len, Object info, IRubyObject commScope) {\n        if (offset < 0)\n            return this;\n        HashMap<Long, AccessSetObj> operatingTable = ht;\n        int atomicModifier = 0;\n        // If the incoming flag indicates this is an op in atomic method, change\n        if (flag >= AccessSet.ATOMIC_OP_OFFSET) {\n            atomicModifier = AccessSet.ATOMIC_OP_OFFSET;\n            // Add this operation to flattened table\n            AccessSetObj flattenedEntry = (AccessSetObj) this.flattenedATable.get(obj);\n            if (flattenedEntry == null) {\n                if (RaceDetector.detailMode) {\n                    flattenedEntry = new AccessSetObjDetailBm(offset, flag, len - atomicModifier,\n                            ((MemoryOprInfo) info).clone());\n                } else {\n                    flattenedEntry = new AccessSetObjBm(info, offset, flag - atomicModifier, len);\n                }\n                this.flattenedATable.put(obj, flattenedEntry);\n            } else {\n                if (RaceDetector.detailMode) {\n                    ((AccessSetObjDetailBm) flattenedEntry).insert(offset, flag, len\n                            - atomicModifier, ((MemoryOprInfo) info).clone());\n                } else {\n                    flattenedEntry.insert(offset, flag - atomicModifier);\n                }\n            }\n            return this;\n        }\n        \n        AccessSetObj entry = (AccessSetObj) operatingTable.get(obj);\n\n        if (entry == null) {\n            if (RaceDetector.spaceTreeOn && info instanceof String\n                    && ((String) info).equals(\"ARRAY\")) {\n                entry = new AccessSetObjSt();\n                entry.insert(offset, flag - atomicModifier, len);\n            } else {\n                if (RaceDetector.detailMode) {\n                    entry = new AccessSetObjDetailBm(offset, flag, len - atomicModifier,\n                            ((MemoryOprInfo) info).clone());\n                } else {\n                    entry = new AccessSetObjBm(info, offset, flag - atomicModifier, len);\n                }\n            }\n            operatingTable.put(obj, entry);\n            // update the set size;\n            size += 2;\n        } else {\n            if (RaceDetector.detailMode) {\n                size += ((AccessSetObjDetailBm) entry).insert(offset, flag, len\n                        - atomicModifier, ((MemoryOprInfo) info).clone());\n            } else {\n                size += entry.insert(offset, flag - atomicModifier, len);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Calculate the intersection of two sets\n     */\n    @Override\n    public void calComSet(AccessSet set) {\n        HashMap ht3 = new HashMap();\n        HashMap ht2 = ((AccessSetHt) set).getHt();\n        Set addrSet = ht.keySet();\n        Iterator itr = addrSet.iterator();\n        while (itr.hasNext()) {\n            Long obj = (Long) itr.next();\n            AccessSetObj entry = (AccessSetObj) ht2.get(obj);\n            if (entry == null) {\n\n            } else {\n                AccessSetObj entry2 = (AccessSetObj) ht2.get(obj);\n                entry.and(entry2);\n                ht3.put(obj, entry2);\n            }\n        }\n        System.out.println(\"common set size = \" + ht3.size());\n        addrSet = ht3.keySet();\n        itr = addrSet.iterator();\n        while (itr.hasNext()) {\n            long obj = (Long) itr.next();\n            AccessSetObj entry = (AccessSetObj) ht3.get(obj);\n            if (entry.accessInfo != null)\n                System.out.println(entry.accessInfo.toString() + \":accesses=\"\n                        + entry.accessNum);\n            else\n                System.out.println(\":accesses=\" + entry.accessNum);\n        }\n    }\n\n    @Override\n    public void printStatis() {\n        Set addrSet = this.ht.keySet();\n        Iterator itr = addrSet.iterator();\n        long sizeTotal = 0;\n        while (itr.hasNext()) {\n            long obj = (Long) itr.next();\n            AccessSetObj entry = (AccessSetObj) this.ht.get(obj);\n            sizeTotal += entry.size();\n        }\n    }\n\n    @Override\n    public boolean isLarge() {\n        // TODO: change 4096\n        return (this.ht.size() > 4096);\n    }\n\n}", "class_id": 0, "repo": "RB-DPR/RB-DPR", "file": "core/src/main/java/org/jruby/race/AccessSetHt.java", "last_update_at": "2020-05-30T12:29:14+00:00", "question_id": "372131a3123cd20a5318bc147c894299daa61adc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class AccessSetHt extends AccessSet {\n    // Normal per-object reference table\n    private HashMap<Long, AccessSetObj> ht;\n    // Flattened atomic table for faster atomic-nonatomic intersection\n    private HashMap<Long, AccessSetObj> flattenedATable;\n    // constructor for AccessSetHt\n    public AccessSetHt() {\n        ht = new HashMap<Long, AccessSetObj>();\n        flattenedATable = new HashMap<Long, AccessSetObj>();\n    }\n    public void setHt(HashMap<Long, AccessSetObj> hm) {\n        this.ht = hm;\n    }\n    public HashMap<Long, AccessSetObj> getHt() {\n        return ht;\n    }\n    public HashMap<Long, AccessSetObj> getFlattenedATable() {\n        return this.flattenedATable;\n    }\n    /**\n     * Hashmap print\n     */\n    @Override\n    public void print(){\n        Long obj;\n        AccessSetObj entry;\n        System.out.println(\"Normal accesses\");\n        System.out.print(\"{\");\n        Set addrSet = this.ht.keySet();\n        Iterator itr = addrSet.iterator();\n        while (itr.hasNext()) {\n            obj = (Long) itr.next();\n            System.out.print(obj);\n            entry = (AccessSetObj) this.ht.get(obj);\n            if (entry != null) {\n                System.out.print(\"(\");\n                entry.print();\n                System.out.print(\"),\");\n            }\n        }\n        System.out.println(\"}\");\n        System.out.println(\"Atomic accesses\");\n    }\n    /**\n     * set intersection.\n     */\n    @Override\n    public void intersect(AccessSet set, int taskType) {\n        // perform intersection on reads/writes\n        Long obj;\n        AccessSetObj entry2;\n        AccessSetObj entry;\n        // if incoming set is a hashtable\n        if (set instanceof AccessSetHt) {\n            AccessSetHt setHt = (AccessSetHt) set;\n            HashMap<Long, AccessSetObj> ht2 = setHt.getHt();\n            Set addrSet = ht2.keySet();\n            Iterator itr = addrSet.iterator();\n            while (itr.hasNext()) {\n                obj = (Long) itr.next();\n                entry = (AccessSetObj) this.ht.get(obj);\n                if (entry != null) {\n                    // skip the reduction object on S node\n                    if (entry.accessInfo instanceof RubyReduction\n                            && taskType != RaceTask.RACE_TASK_FINISH) {\n                        continue;\n                    }\n                    entry2 = (AccessSetObj) ht2.get(obj);\n                    entry.intersect(entry2, obj);\n                }\n            }\n            // Intersect my atomic part with incoming non-atomic part\n            // Note: no merge!\n            // Note: use flattened atomic table\n            for (Long objId : ht2.keySet()) {\n                AccessSetObj incomingEntry = (AccessSetObj) ht2.get(objId);\n                AccessSetObj myEntry = (AccessSetObj) this.flattenedATable.get(objId);\n                if (myEntry != null) {\n                    // skip the reduction object on S node\n                    if (!(myEntry.accessInfo instanceof RubyReduction && taskType != RaceTask.RACE_TASK_FINISH)) {\n                        myEntry.intersect(incomingEntry, objId);\n                    }\n                }\n            }\n            // Intersect my non-atomic part with incoming atomic part\n            // Note: no merge!\n            HashMap<Long, AccessSetObj> flattenedAT2 = setHt.getFlattenedATable();\n            for (Long objId : flattenedAT2.keySet()) {\n                AccessSetObj incomingEntry = (AccessSetObj) (flattenedAT2.get(objId));\n                AccessSetObj myEntry = (AccessSetObj) this.ht.get(objId);\n                if (myEntry != null) {\n                    // skip the reduction object on S node\n                    if (!(myEntry.accessInfo instanceof RubyReduction && taskType != RaceTask.RACE_TASK_FINISH)) {\n                        myEntry.intersect(incomingEntry, objId);\n                    }\n                }\n            }\n        }\n        // the incoming log is a list\n        else {\n            AccessSetList setList = (AccessSetList) set;\n            long[] reads = setList.getReads();\n            long writes[] = setList.getWrites();\n            Object[] readInfo = setList.getRdInfo();\n            Object[] writeInfo = setList.getWrtInfo();\n            IRubyObject[] readCommScope = setList.getReadCommScope();\n            IRubyObject[] writeCommScope = setList.getWriteCommScope();\n            for (int i = 0; i < setList.getReadSize(); i += 2) {\n                obj = reads[i];\n                // detect read-write conflicts\n                // Incoming ops vs. atomic ops\n                HashMap<Long, AccessSetObj> workingTable = this.flattenedATable;\n                entry = (AccessSetObj) (workingTable.get(obj));\n                // Only check for non-atomic ops\n                if (readCommScope[i / 2] == null && entry != null) {\n                    if (entry.isIn((int) reads[i + 1], WRT_FLAG)) {\n                        // only find reduction problems on P node\n                        if (readInfo[i / 2] instanceof RubyReduction\n                                && taskType != RaceTask.RACE_TASK_FINISH) {\n                            continue;\n                        }\n                        if (RaceDetector.detailMode) {\n                            RaceDetector.recordRace(obj, (int) reads[i + 1], (MemoryOprInfo) readInfo[i / 2],\n                                    ((AccessSetObjDetailBm) entry).getMemOprInfo(\n                                            (int) reads[i + 1], WRT_FLAG));\n                        } else {\n                            RaceDetector.recordRace(obj, readInfo[i / 2], (int) reads[i + 1]);\n                        }\n                    }\n                }\n                // Incoming ops vs. non-atomic ops\n                workingTable = this.ht;\n                entry = (AccessSetObj) (workingTable.get(obj));\n                if (entry != null) {\n                    if (entry.isIn((int) reads[i + 1], WRT_FLAG)) {\n                        // only find reduction problems on P node\n                        if (readInfo[i / 2] instanceof RubyReduction\n                                && taskType != RaceTask.RACE_TASK_FINISH) {\n                            continue;\n                        }\n                        if (RaceDetector.detailMode) {\n                            RaceDetector.recordRace(obj, (int) reads[i + 1],\n                                    (MemoryOprInfo) readInfo[i / 2], ((AccessSetObjDetailBm) entry)\n                                            .getMemOprInfo((int) reads[i + 1], WRT_FLAG));\n                        } else {\n                            RaceDetector.recordRace(obj, readInfo[i / 2], (int) reads[i + 1]);\n                        }\n                    }\n                }\n            }\n            for (int i = 0; i < setList.getWriteSize(); i += 2) {\n                obj = writes[i];\n                // detect write-write and read-write conflicts\n                // Incoming ops vs. atomic ops\n                HashMap<Long, AccessSetObj> workingTable = this.flattenedATable;\n                entry = (AccessSetObj) (workingTable.get(obj));\n                // Only check for non-atomic ops\n                if (writeCommScope[i / 2] == null && entry != null) {\n                    if (entry.isIn((int) writes[i + 1], WRT_FLAG)\n                        || entry.isIn((int) writes[i + 1], RD_FLAG)) {\n                        // only find reduction problems on P node\n                        if (writeInfo[i / 2] instanceof RubyReduction\n                                && taskType != RaceTask.RACE_TASK_FINISH) {\n                            continue;\n                        }\n                        if (RaceDetector.detailMode) {\n                            if (entry.isIn((int) writes[i + 1], WRT_FLAG))\n                                RaceDetector.recordRace(obj, (int) writes[i + 1],\n                                        (MemoryOprInfo) writeInfo[i / 2],\n                                        ((AccessSetObjDetailBm) entry).getMemOprInfo(\n                                                (int) writes[i + 1], WRT_FLAG));\n                            else\n                                RaceDetector.recordRace(obj, (int) writes[i + 1],\n                                        (MemoryOprInfo) writeInfo[i / 2],\n                                        ((AccessSetObjDetailBm) entry).getMemOprInfo(\n                                                (int) writes[i + 1], RD_FLAG));\n                        } else {\n                            RaceDetector.recordRace(obj, writeInfo[i / 2], (int) writes[i + 1]);\n                        }\n                    }\n                }\n                // Incoming ops vs. non-atomic ops\n                workingTable = this.ht;\n                entry = (AccessSetObj) (workingTable.get(obj));\n                if (entry != null) {\n                    if (entry.isIn((int) writes[i + 1], WRT_FLAG)\n                            || entry.isIn((int) writes[i + 1], RD_FLAG)) {\n                        // only find reduction problems on P node\n                        if (readInfo[i / 2] instanceof RubyReduction\n                                && taskType != RaceTask.RACE_TASK_FINISH) {\n                            continue;\n                        }\n                        if (RaceDetector.detailMode) {\n                            if (entry.isIn((int) writes[i + 1], WRT_FLAG))\n                                RaceDetector.recordRace(obj, (int) writes[i + 1],\n                                        (MemoryOprInfo) writeInfo[i / 2],\n                                        ((AccessSetObjDetailBm) entry).getMemOprInfo(\n                                                (int) writes[i + 1], WRT_FLAG));\n                            else\n                                RaceDetector.recordRace(obj, (int) writes[i + 1],\n                                        (MemoryOprInfo) writeInfo[i / 2],\n                                        ((AccessSetObjDetailBm) entry).getMemOprInfo(\n                                                (int) writes[i + 1], RD_FLAG));\n                        } else {\n                            RaceDetector.recordRace(obj, writeInfo[i / 2],\n                                    (int) writes[i + 1]);\n                        }\n                    }\n                }\n            }\n        }\n        // Perform intersection on methods\n        intersectCall(set);\n    }\n    /**\n     * set merge\n     */\n    @Override\n    public AccessSet merge(AccessSet set) {\n        AccessSetObj entry;\n        Long obj;\n        AccessSetObj entry2;\n        // the incoming log is a hash table\n        if (set instanceof AccessSetHt) {\n            // Merge non-atomic part\n            AccessSetHt setHt = (AccessSetHt) set;\n            HashMap ht2 = setHt.getHt();\n            Set addrSet = ht2.keySet();\n            Iterator itr = addrSet.iterator();\n            while (itr.hasNext()) {\n                obj = (Long) itr.next();\n                entry = (AccessSetObj) this.ht.get(obj);\n                entry2 = (AccessSetObj) ht2.get(obj);\n                if (entry != null) {\n                    size += entry.merge(entry2);\n                } else {\n                    ht.put(obj, entry2);\n                    size += entry2.size();\n                }\n            }\n            // Merge flattened table\n            // Intersect my non-atomic part with incoming atomic part\n            // Note: no merge!\n            HashMap<Long, AccessSetObj> flattenedAT2 = setHt.getFlattenedATable();\n            HashMap<Long, AccessSetObj> myAT = this.flattenedATable;\n            for (Long objId : flattenedAT2.keySet()) {\n                AccessSetObj incomingEntry = (AccessSetObj) (flattenedAT2.get(objId));\n                AccessSetObj myEntry = (AccessSetObj) this.flattenedATable.get(objId);\n                if (myEntry != null) {\n                    myEntry.merge(incomingEntry);\n                } else {\n                    myAT.put(objId, incomingEntry);\n                }\n            }\n        } else { // the incoming log is a list\n            AccessSetList setList = (AccessSetList) set;\n            long[] reads = setList.getReads();\n            long writes[] = setList.getWrites();\n            Object[] readInfo = setList.getRdInfo();\n            Object[] writeInfo = setList.getWrtInfo();\n            IRubyObject[] readCommScope = setList.getReadCommScope();\n            IRubyObject[] writeCommScope = setList.getWriteCommScope();\n            for (int i = 0; i < setList.getReadSize(); i += 2) {\n                obj = reads[i];\n                // Check for atomic ops\n                HashMap<Long, AccessSetObj> workingTable = this.ht;\n                if (readCommScope[i / 2] != null) {\n                    workingTable = this.flattenedATable;\n                }\n                entry = (AccessSetObj) (workingTable.get(obj));\n                // merge reads\n                if (entry == null) {\n                    if (RaceDetector.spaceTreeOn\n                            && readInfo[i / 2] instanceof String\n                            && ((String) readInfo[i / 2]).equals(\"ARRAY\")) {\n                        entry = new AccessSetObjSt();\n                        entry.insert((int) (reads[i + 1]), RD_FLAG);\n                    } else if (RaceDetector.detailMode) {\n                        entry = new AccessSetObjDetailBm((int) (reads[i + 1]),\n                                RD_FLAG, (MemoryOprInfo) readInfo[i / 2]);\n                        size += 2;\n                    } else {\n                        entry = new AccessSetObjBm(readInfo[i / 2],\n                                (int) (reads[i + 1]), 0, 0, RD_FLAG);\n                        size += 2;\n                    }\n                    workingTable.put(obj, entry);\n                } else {\n                    if (RaceDetector.detailMode) {\n                        size += ((AccessSetObjDetailBm) entry).insert((int) reads[i + 1], RD_FLAG,\n                                (MemoryOprInfo) readInfo[i / 2]);\n                    } else {\n                        size += entry.insert((int) reads[i + 1], RD_FLAG);\n                    }\n                }\n            }\n            for (int i = 0; i < setList.getWriteSize(); i += 2) {\n                obj = writes[i];\n                // For atomic ops\n                HashMap<Long, AccessSetObj> workingTable = this.ht;\n                if (writeCommScope[i / 2] != null) {\n                    workingTable = this.flattenedATable;\n                }\n                entry = (AccessSetObj) (workingTable.get(obj));\n                // merge writes\n                if (entry == null) {\n                    if (RaceDetector.spaceTreeOn\n                            && writeInfo[i / 2] instanceof String\n                            && ((String) writeInfo[i / 2]).equals(\"ARRAY\")) {\n                        entry = new AccessSetObjSt();\n                        entry.insert((int) (writes[i + 1]), WRT_FLAG);\n                    } else if (RaceDetector.detailMode) {\n                        entry = new AccessSetObjDetailBm((int) (writes[i + 1]),\n                                WRT_FLAG, (MemoryOprInfo) writeInfo[i / 2]);\n                        size += 2;\n                    } else {\n                        entry = new AccessSetObjBm(writeInfo[i / 2],\n                                (int) (writes[i + 1]), 0, 0, WRT_FLAG);\n                        size += 2;\n                    }\n                    workingTable.put(obj, entry);\n                } else {\n                    if (RaceDetector.detailMode) {\n                        size += ((AccessSetObjDetailBm) entry).insert((int) writes[i + 1], WRT_FLAG,\n                                (MemoryOprInfo) writeInfo[i / 2]);\n                    } else {\n                        size += entry.insert((int) writes[i + 1], WRT_FLAG);\n                    }\n                }\n            }\n        }\n        this.mergeNum += set.getMergeNum();\n        // for commutative\n        mergeCall(set);\n        set.clear();\n        return this;\n    }\n    /**\n     * set intersection and merge\n     */\n    @Override\n    public AccessSet intersectAndMerge(AccessSet set, int taskType) {\n        long obj;\n        AccessSetObj entry;\n        AccessSetObj entry2;\n        // TODO: intersect and merge with atomicTable\n        // the incoming log is a hash table\n        if (set instanceof AccessSetHt) {\n             // Intersect and merge non-atomic part\n            AccessSetHt setHt = (AccessSetHt) set;\n            HashMap<Long, AccessSetObj> ht2 = setHt.getHt();\n            Set addrSet = ht2.keySet();\n            Iterator itr = addrSet.iterator();\n            while (itr.hasNext()) {\n                obj = (Long) itr.next();\n                entry = (AccessSetObj) this.ht.get(obj);\n                if (entry != null) {\n                    entry2 = (AccessSetObj) ht2.get(obj);\n                    // skip the reduction object on S node\n                    if (!(entry.accessInfo instanceof RubyReduction && taskType != RaceTask.RACE_TASK_FINISH)) {\n                        entry.intersect(entry2, obj);\n                    }\n                    size += entry.merge(entry2);\n                } else {// merge\n                    entry2 = (AccessSetObj) ht2.get(obj);\n                    this.ht.put(obj, entry2);\n                    size += entry2.size();\n                }\n            }\n            this.mergeNum += set.getMergeNum();\n            // Intersect my atomic part with incoming non-atomic part\n            // Note: no merge!\n            // Note: use flattened atomic table\n            for (Long objId : ht2.keySet()) {\n                AccessSetObj incomingEntry = (AccessSetObj) ht2.get(objId);\n                AccessSetObj myEntry = (AccessSetObj) this.flattenedATable.get(objId);\n                if (myEntry != null) {\n                    // skip the reduction object on S node\n                    if (!(myEntry.accessInfo instanceof RubyReduction && taskType != RaceTask.RACE_TASK_FINISH)) {\n                        myEntry.intersect(incomingEntry, objId);\n                    }\n                }\n            }\n            // Intersect my non-atomic part with incoming atomic part\n            // Note: no merge!\n            HashMap<Long, AccessSetObj> flattenedAT2 = setHt.getFlattenedATable();\n            for (Long objId : flattenedAT2.keySet()) {\n                AccessSetObj incomingEntry = (AccessSetObj) (flattenedAT2.get(objId));\n                AccessSetObj myEntry = (AccessSetObj) this.ht.get(objId);\n                if (myEntry != null) {\n                    // skip the reduction object on S node\n                    if (!(myEntry.accessInfo instanceof RubyReduction && taskType != RaceTask.RACE_TASK_FINISH)) {\n                        myEntry.intersect(incomingEntry, objId);\n                    }\n                }\n            }\n            // Merge flattened table\n            HashMap<Long, AccessSetObj> myAT = this.flattenedATable;\n            for (Long objId : flattenedAT2.keySet()) {\n                AccessSetObj incomingEntry = (AccessSetObj) (flattenedAT2.get(objId));\n                AccessSetObj myEntry = (AccessSetObj) this.flattenedATable.get(objId);\n                if (myEntry != null) {\n                    myEntry.merge(incomingEntry);\n                } else {\n                    myAT.put(objId, incomingEntry);\n                }\n            }\n            // Deal with ac-ops\n            intersectCall(set);\n            mergeCall(set);\n        }\n        // the incoming log is a list\n        else {\n            this.intersect(set, taskType);\n            this.merge(set);\n        }\n        set.clear();\n        return this;\n    }\n    @Override\n    public void clear() {\n        this.mergeNum = 0;\n        ht.clear();\n        flattenedATable.clear();\n        super.clear();\n    }\n    @Override\n    public long size() {\n        return this.size;\n    }\n    /**\n     * Insert a log into current access-set \n     */\n    @Override\n    public AccessSet insert(long obj, int offset, int flag, int file,\n            int line, Object info, IRubyObject commScope) {\n        if (offset < 0){\n            return this;\n        }\n        HashMap<Long, AccessSetObj> operatingTable = ht;\n        int atomicModifier = 0;\n        // If the incoming flag indicates this is an op in atomic method, change\n        if (flag >= AccessSet.ATOMIC_OP_OFFSET) {\n            atomicModifier = AccessSet.ATOMIC_OP_OFFSET;\n            // Add this operation to flattened table\n            AccessSetObj flattenedEntry = (AccessSetObj) this.flattenedATable.get(obj);\n            if (flattenedEntry == null) {\n                if (RaceDetector.detailMode) {\n                    flattenedEntry = new AccessSetObjDetailBm(offset, flag - atomicModifier,\n                            ((MemoryOprInfo) info).clone());\n                } else {\n                    flattenedEntry = new AccessSetObjBm(info, offset, line, file, flag\n                            - atomicModifier);\n                }\n                this.flattenedATable.put(obj, flattenedEntry);\n            } else {\n                if (RaceDetector.detailMode) {\n                    ((AccessSetObjDetailBm) flattenedEntry).insert(offset, flag - atomicModifier,\n                            ((MemoryOprInfo) info).clone());\n                } else {\n                    flattenedEntry.insert(offset, flag - atomicModifier);\n                }\n            }\n            return this;\n        } \n        AccessSetObj entry = (AccessSetObj) operatingTable.get(obj);\n        if (entry == null) {\n            if (RaceDetector.spaceTreeOn && info instanceof String\n                    && ((String) info).equals(\"ARRAY\")) {\n                entry = new AccessSetObjSt();\n            } else if (RaceDetector.detailMode) {\n                entry = new AccessSetObjDetailBm(offset, flag - atomicModifier,\n                        ((MemoryOprInfo) info).clone());\n            } else {\n                entry = new AccessSetObjBm(info, offset, line, file, flag - atomicModifier);\n            }\n            operatingTable.put(obj, entry);\n            size += 2;\n        } else {\n            if (RaceDetector.detailMode) {\n                size += ((AccessSetObjDetailBm) entry).insert(offset, flag - atomicModifier,\n                        ((MemoryOprInfo) info).clone());\n            } else {\n                size += entry.insert(offset, flag - atomicModifier);\n            }\n        }\n        return this;\n    }\n    /**\n     * Insert a batch of accesses into current set\n     */\n    @Override\n    public AccessSet insert(long obj, int offset, int flag, int len, Object info, IRubyObject commScope) {\n        if (offset < 0)\n            return this;\n        HashMap<Long, AccessSetObj> operatingTable = ht;\n        int atomicModifier = 0;\n        // If the incoming flag indicates this is an op in atomic method, change\n        if (flag >= AccessSet.ATOMIC_OP_OFFSET) {\n            atomicModifier = AccessSet.ATOMIC_OP_OFFSET;\n            // Add this operation to flattened table\n            AccessSetObj flattenedEntry = (AccessSetObj) this.flattenedATable.get(obj);\n            if (flattenedEntry == null) {\n                if (RaceDetector.detailMode) {\n                    flattenedEntry = new AccessSetObjDetailBm(offset, flag, len - atomicModifier,\n                            ((MemoryOprInfo) info).clone());\n                } else {\n                    flattenedEntry = new AccessSetObjBm(info, offset, flag - atomicModifier, len);\n                }\n                this.flattenedATable.put(obj, flattenedEntry);\n            } else {\n                if (RaceDetector.detailMode) {\n                    ((AccessSetObjDetailBm) flattenedEntry).insert(offset, flag, len\n                            - atomicModifier, ((MemoryOprInfo) info).clone());\n                } else {\n                    flattenedEntry.insert(offset, flag - atomicModifier);\n                }\n            }\n            return this;\n        }\n        AccessSetObj entry = (AccessSetObj) operatingTable.get(obj);\n        if (entry == null) {\n            if (RaceDetector.spaceTreeOn && info instanceof String\n                    && ((String) info).equals(\"ARRAY\")) {\n                entry = new AccessSetObjSt();\n                entry.insert(offset, flag - atomicModifier, len);\n            } else {\n                if (RaceDetector.detailMode) {\n                    entry = new AccessSetObjDetailBm(offset, flag, len - atomicModifier,\n                            ((MemoryOprInfo) info).clone());\n                } else {\n                    entry = new AccessSetObjBm(info, offset, flag - atomicModifier, len);\n                }\n            }\n            operatingTable.put(obj, entry);\n            // update the set size;\n            size += 2;\n        } else {\n            if (RaceDetector.detailMode) {\n                size += ((AccessSetObjDetailBm) entry).insert(offset, flag, len\n                        - atomicModifier, ((MemoryOprInfo) info).clone());\n            } else {\n                size += entry.insert(offset, flag - atomicModifier, len);\n            }\n        }\n        return this;\n    }\n    /**\n     * Calculate the intersection of two sets\n     */\n    @Override\n    public void calComSet(AccessSet set) {\n        HashMap ht3 = new HashMap();\n        HashMap ht2 = ((AccessSetHt) set).getHt();\n        Set addrSet = ht.keySet();\n        Iterator itr = addrSet.iterator();\n        while (itr.hasNext()) {\n            Long obj = (Long) itr.next();\n            AccessSetObj entry = (AccessSetObj) ht2.get(obj);\n            if (entry == null) {\n            } else {\n                AccessSetObj entry2 = (AccessSetObj) ht2.get(obj);\n                entry.and(entry2);\n                ht3.put(obj, entry2);\n            }\n        }\n        System.out.println(\"common set size = \" + ht3.size());\n        addrSet = ht3.keySet();\n        itr = addrSet.iterator();\n        while (itr.hasNext()) {\n            long obj = (Long) itr.next();\n            AccessSetObj entry = (AccessSetObj) ht3.get(obj);\n            if (entry.accessInfo != null)\n                System.out.println(entry.accessInfo.toString() + \":accesses=\"\n                        + entry.accessNum);\n            else\n                System.out.println(\":accesses=\" + entry.accessNum);\n        }\n    }\n    @Override\n    public void printStatis() {\n        Set addrSet = this.ht.keySet();\n        Iterator itr = addrSet.iterator();\n        long sizeTotal = 0;\n        while (itr.hasNext()) {\n            long obj = (Long) itr.next();\n            AccessSetObj entry = (AccessSetObj) this.ht.get(obj);\n            sizeTotal += entry.size();\n        }\n    }\n    @Override\n    public boolean isLarge() {\n        // TODO: change 4096\n        return (this.ht.size() > 4096);\n    }\n"]]}
{"hexsha": "c948e031acae3fb8e3242230aca8eefadf580b67", "ext": "java", "lang": "Java", "content": "public class Camera {\n\n\tpublic static int x;\n\tpublic static int y;\n\t\n\tpublic static int clamp(int atual, int min, int max) {\n\t\tif(atual < min) atual = min;\n\t\tif(atual > max) atual = max;\n\t\t\n\t\treturn atual;\n\t}\n\t\n}", "class_id": 0, "repo": "RenilsonMedeiros/Game_01-Clone_Zelda", "file": "src/com/gcstudios/world/Camera.java", "last_update_at": "2020-06-03T13:16:35+00:00", "question_id": "c948e031acae3fb8e3242230aca8eefadf580b67", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Camera {\n\tpublic static int x;\n\tpublic static int y;\n\t\n\tpublic static int clamp(int atual, int min, int max) {\n\t\tif(atual < min) atual = min;\n\t\tif(atual > max) atual = max;\n\t\t\n\t\treturn atual;\n\t}\n\t\n"]]}
{"hexsha": "8770b3d50c88f111d70c40d5262980e3ed5a9828", "ext": "java", "lang": "Java", "content": "public class ListCompare implements Comparator<List<Integer>> {\n    @Override\n    public int compare(List<Integer> left, List<Integer> right) {\n        int result = 0;\n        if (left.size() != right.size()) {\n            result = left.size() < right.size() ? -1 : -2;\n        } else {\n            for (int i = 0; i < left.size(); i++) {\n                int com = left.get(i).compareTo(right.get(i));\n                if (com != 0) {\n                    result = com > 0 ? 1 : 2;\n                } else {\n                    result = 0;\n                }\n            }\n        }\n        return result;\n    }\n}", "class_id": 0, "repo": "YuryMatskevich/ymatskevich", "file": "chapter_003/src/main/java/ru/job4j/comparator/ListCompare.java", "last_update_at": "2020-03-23T18:12:28+00:00", "question_id": "8770b3d50c88f111d70c40d5262980e3ed5a9828", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ListCompare implements Comparator<List<Integer>> {\n    @Override\n    public int compare(List<Integer> left, List<Integer> right) {\n        int result = 0;\n        if (left.size() != right.size()) {\n            result = left.size() < right.size() ? -1 : -2;\n        } else {\n            for (int i = 0; i < left.size(); i++) {\n                int com = left.get(i).compareTo(right.get(i));\n                if (com != 0) {\n                    result = com > 0 ? 1 : 2;\n                } else {\n                    result = 0;\n                }\n            }\n        }\n        return result;\n    }\n"]]}
{"hexsha": "327b1852eacff2a4065c38549285e0dfc84d271d", "ext": "java", "lang": "Java", "content": "@Entity\n@Table(name = \"TESTCASE\")\npublic class TestCase extends AbstractBaseEntity {\n\n    /**\n     * long serialVersionUID\n     */\n    private static final long serialVersionUID = 455667421219565288L;\n\n    /**\n     * String name\n     */\n    @Size(min = 1, max = 255)\n    @Column(name = \"NAME\", unique = true)\n    private String name;\n\n    @Column(name = \"DESCRIPTION\", columnDefinition = \"TEXT\")\n    private String description;\n\n    @Column(name = \"IS_AUTOMATED\")\n    private boolean automated = false;\n\n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"PROJECT_ID\")\n    @Where(clause = \"IS_DELETED=0\")\n    private Project project;\n\n    @Column(name = \"TESTCASE_FOLDER_ID\")\n    private Integer testCaseFolderId;\n\n    @Column(name = \"EXECUTION_DATE\")\n    private LocalDateTime executionDateTime;\n\n    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY)\n    @JoinColumn(name = \"TESTCASE_ID\")\n    @Where(clause = \"IS_LOOK_UP=0 AND IS_DELETED=0\")\n    @OrderBy(\"position ASC\")\n    private List<TestStep> testSteps = new ArrayList<>();\n\n    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY)\n    @JoinColumn(name = \"TESTCASE_ID\")\n    @Where(clause = \"IS_LOOK_UP=1 AND IS_DELETED=0\")\n    @OrderBy(\"position ASC\")\n    private List<TestStep> lookUps = new ArrayList<>();\n\n    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY)\n    @JoinColumn(name = \"TESTCASE_ID\")\n    @Where(clause = \"IS_DELETED=0\")\n    private List<TestCaseTestRun> testCaseTestRunList = new ArrayList<>();\n\n    @Transient\n    private String testCaseFolder = \"\";\n\n    @Transient\n    private ExecutionStatus executionStatus = ExecutionStatus.NOTRUN;\n\n    @Transient\n    private String version = \"\";\n\n    public TestCase() {\n    }\n\n    public TestCase(String name, String description, Project project, Integer testCaseFolderId) {\n        super();\n        this.name = name;\n        this.description = description;\n        this.project = project;\n        this.testCaseFolderId = testCaseFolderId;\n    }\n\n    /**\n     * @return the lookUps\n     */\n    public List<TestStep> getLookUps() {\n        return lookUps;\n    }\n\n    /**\n     * @param lookUps the lookUps to set\n     */\n    public void setLookUps(List<TestStep> lookUps) {\n        this.lookUps = lookUps;\n    }\n\n    /**\n     * @return the name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @param name the name to set\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * @return the description\n     */\n    public String getDescription() {\n        return description;\n    }\n\n    /**\n     * @param description the description to set\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @return the automated\n     */\n    public boolean isAutomated() {\n        return automated;\n    }\n\n    /**\n     * @param automated the automated to set\n     */\n    public void setAutomated(boolean automated) {\n        this.automated = automated;\n    }\n\n    /**\n     * @return the project\n     */\n    public Project getProject() {\n        return project;\n    }\n\n    /**\n     * @param project the project to set\n     */\n    public void setProject(Project project) {\n        this.project = project;\n    }\n\n    /**\n     * @return the testSteps\n     */\n    public List<TestStep> getTestSteps() {\n        return testSteps;\n    }\n\n    /**\n     * @param testSteps the testSteps to set\n     */\n    public void setTestSteps(List<TestStep> testSteps) {\n        this.testSteps = testSteps;\n    }\n\n    /**\n     * @return the testCaseTestRunList\n     */\n    public List<TestCaseTestRun> getTestCaseTestRunList() {\n        return testCaseTestRunList;\n    }\n\n    /**\n     * @param testCaseTestRunList the testCaseTestRunList to set\n     */\n    public void setTestCaseTestRunList(List<TestCaseTestRun> testCaseTestRunList) {\n        this.testCaseTestRunList = testCaseTestRunList;\n    }\n\n    /**\n     * @return the executionStatus\n     */\n    public ExecutionStatus getExecutionStatus() {\n        return executionStatus;\n\n    }\n\n    public void setExecutionStatus(ExecutionStatus executionStatus) {\n        this.executionStatus = executionStatus;\n    }\n\n    public String getVersion() {\n        return version;\n    }\n\n    public void setVersion(String version) {\n        this.version = version;\n    }\n\n    /**\n     * @return the testCaseFolderId\n     */\n    public Integer getTestCaseFolderId() {\n        return testCaseFolderId;\n    }\n\n    /**\n     * @param testCaseFolderId the testCaseFolderId to set\n     */\n    public void setTestCaseFolderId(Integer testCaseFolderId) {\n        this.testCaseFolderId = testCaseFolderId;\n    }\n\n    /**\n     * @return the executionDateTime\n     */\n    public LocalDateTime getExecutionDateTime() {\n        return executionDateTime;\n    }\n\n    /**\n     * @param executionDateTime the executionDateTime to set\n     */\n    public void setExecutionDateTime(LocalDateTime executionDateTime) {\n        this.executionDateTime = executionDateTime;\n    }\n\n    public String getTestCaseFolder() {\n        return testCaseFolder;\n    }\n\n    public void setTestCaseFolder(String testCaseFolder) {\n        this.testCaseFolder = testCaseFolder;\n    }\n\n    public TestCase cloneTestCase() {\n        TestCase newTestCase = new TestCase();\n        newTestCase.setAutomated(automated);\n        newTestCase.setDescription(description);\n        newTestCase.setExecutionDateTime(executionDateTime);\n        newTestCase.setName(generateName());\n        newTestCase.setProject(project);\n        newTestCase.setTestCaseFolderId(testCaseFolderId);\n        testSteps.forEach(testStep -> {\n            TestStep clonedTestStep = testStep.cloneTestStep();\n            newTestCase.getTestSteps().add(clonedTestStep);\n        });\n        lookUps.forEach(lookUp -> {\n            TestStep clonedLookUp = lookUp.cloneTestStep();\n            newTestCase.getLookUps().add(clonedLookUp);\n        });\n        return newTestCase;\n    }\n\n    public String generateName() {\n        String newName = name;\n        String[] splittedName = newName.split(\"_\");\n        try {\n            Integer value = Integer.parseInt(splittedName[splittedName.length - 1]);\n            newName = newName.substring(0, newName.lastIndexOf('_')) + \"_\" + (++value);\n        } catch (NumberFormatException e) {\n            newName = newName + \"_2\";\n        }\n        return newName;\n    }\n\n}", "class_id": 0, "repo": "logo-group/tedam-core", "file": "src/main/java/com/lbs/tedam/model/TestCase.java", "last_update_at": "2020-04-18T14:33:07+00:00", "question_id": "327b1852eacff2a4065c38549285e0dfc84d271d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Entity\n@Table(name = \"TESTCASE\")\npublic class TestCase extends AbstractBaseEntity {\n    /**\n     * long serialVersionUID\n     */\n    private static final long serialVersionUID = 455667421219565288L;\n    /**\n     * String name\n     */\n    @Size(min = 1, max = 255)\n    @Column(name = \"NAME\", unique = true)\n    private String name;\n    @Column(name = \"DESCRIPTION\", columnDefinition = \"TEXT\")\n    private String description;\n    @Column(name = \"IS_AUTOMATED\")\n    private boolean automated = false;\n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"PROJECT_ID\")\n    @Where(clause = \"IS_DELETED=0\")\n    private Project project;\n    @Column(name = \"TESTCASE_FOLDER_ID\")\n    private Integer testCaseFolderId;\n    @Column(name = \"EXECUTION_DATE\")\n    private LocalDateTime executionDateTime;\n    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY)\n    @JoinColumn(name = \"TESTCASE_ID\")\n    @Where(clause = \"IS_LOOK_UP=0 AND IS_DELETED=0\")\n    @OrderBy(\"position ASC\")\n    private List<TestStep> testSteps = new ArrayList<>();\n    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY)\n    @JoinColumn(name = \"TESTCASE_ID\")\n    @Where(clause = \"IS_LOOK_UP=1 AND IS_DELETED=0\")\n    @OrderBy(\"position ASC\")\n    private List<TestStep> lookUps = new ArrayList<>();\n    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY)\n    @JoinColumn(name = \"TESTCASE_ID\")\n    @Where(clause = \"IS_DELETED=0\")\n    private List<TestCaseTestRun> testCaseTestRunList = new ArrayList<>();\n    @Transient\n    private String testCaseFolder = \"\";\n    @Transient\n    private ExecutionStatus executionStatus = ExecutionStatus.NOTRUN;\n    @Transient\n    private String version = \"\";\n    public TestCase() {\n    }\n    public TestCase(String name, String description, Project project, Integer testCaseFolderId) {\n        super();\n        this.name = name;\n        this.description = description;\n        this.project = project;\n        this.testCaseFolderId = testCaseFolderId;\n    }\n    /**\n     * @return the lookUps\n     */\n    public List<TestStep> getLookUps() {\n        return lookUps;\n    }\n    /**\n     * @param lookUps the lookUps to set\n     */\n    public void setLookUps(List<TestStep> lookUps) {\n        this.lookUps = lookUps;\n    }\n    /**\n     * @return the name\n     */\n    public String getName() {\n        return name;\n    }\n    /**\n     * @param name the name to set\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n    /**\n     * @return the description\n     */\n    public String getDescription() {\n        return description;\n    }\n    /**\n     * @param description the description to set\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n    /**\n     * @return the automated\n     */\n    public boolean isAutomated() {\n        return automated;\n    }\n    /**\n     * @param automated the automated to set\n     */\n    public void setAutomated(boolean automated) {\n        this.automated = automated;\n    }\n    /**\n     * @return the project\n     */\n    public Project getProject() {\n        return project;\n    }\n    /**\n     * @param project the project to set\n     */\n    public void setProject(Project project) {\n        this.project = project;\n    }\n    /**\n     * @return the testSteps\n     */\n    public List<TestStep> getTestSteps() {\n        return testSteps;\n    }\n    /**\n     * @param testSteps the testSteps to set\n     */\n    public void setTestSteps(List<TestStep> testSteps) {\n        this.testSteps = testSteps;\n    }\n    /**\n     * @return the testCaseTestRunList\n     */\n    public List<TestCaseTestRun> getTestCaseTestRunList() {\n        return testCaseTestRunList;\n    }\n    /**\n     * @param testCaseTestRunList the testCaseTestRunList to set\n     */\n    public void setTestCaseTestRunList(List<TestCaseTestRun> testCaseTestRunList) {\n        this.testCaseTestRunList = testCaseTestRunList;\n    }\n    /**\n     * @return the executionStatus\n     */\n    public ExecutionStatus getExecutionStatus() {\n        return executionStatus;\n    }\n    public void setExecutionStatus(ExecutionStatus executionStatus) {\n        this.executionStatus = executionStatus;\n    }\n    public String getVersion() {\n        return version;\n    }\n    public void setVersion(String version) {\n        this.version = version;\n    }\n    /**\n     * @return the testCaseFolderId\n     */\n    public Integer getTestCaseFolderId() {\n        return testCaseFolderId;\n    }\n    /**\n     * @param testCaseFolderId the testCaseFolderId to set\n     */\n    public void setTestCaseFolderId(Integer testCaseFolderId) {\n        this.testCaseFolderId = testCaseFolderId;\n    }\n    /**\n     * @return the executionDateTime\n     */\n    public LocalDateTime getExecutionDateTime() {\n        return executionDateTime;\n    }\n    /**\n     * @param executionDateTime the executionDateTime to set\n     */\n    public void setExecutionDateTime(LocalDateTime executionDateTime) {\n        this.executionDateTime = executionDateTime;\n    }\n    public String getTestCaseFolder() {\n        return testCaseFolder;\n    }\n    public void setTestCaseFolder(String testCaseFolder) {\n        this.testCaseFolder = testCaseFolder;\n    }\n    public TestCase cloneTestCase() {\n        TestCase newTestCase = new TestCase();\n        newTestCase.setAutomated(automated);\n        newTestCase.setDescription(description);\n        newTestCase.setExecutionDateTime(executionDateTime);\n        newTestCase.setName(generateName());\n        newTestCase.setProject(project);\n        newTestCase.setTestCaseFolderId(testCaseFolderId);\n        testSteps.forEach(testStep -> {\n            TestStep clonedTestStep = testStep.cloneTestStep();\n            newTestCase.getTestSteps().add(clonedTestStep);\n        });\n        lookUps.forEach(lookUp -> {\n            TestStep clonedLookUp = lookUp.cloneTestStep();\n            newTestCase.getLookUps().add(clonedLookUp);\n        });\n        return newTestCase;\n    }\n    public String generateName() {\n        String newName = name;\n        String[] splittedName = newName.split(\"_\");\n        try {\n            Integer value = Integer.parseInt(splittedName[splittedName.length - 1]);\n            newName = newName.substring(0, newName.lastIndexOf('_')) + \"_\" + (++value);\n        } catch (NumberFormatException e) {\n            newName = newName + \"_2\";\n        }\n        return newName;\n    }\n"]]}
{"hexsha": "8759ef0f0dd054f4346589ace19221ee48f69f33", "ext": "java", "lang": "Java", "content": "public class DwpItemContextMenuHandler extends AbstractItemContextMenuHandler\n{\n    // Initialization flag.\n    boolean m_isInitialized = false;\n\n\t/**\n     * The default constructor.\n     */\n    public DwpItemContextMenuHandler()\n    {\n        super();\n    }\n\n\t/**\n\t * Initialize the handler.\n\t * <p>\n\t * This must be called prior to getting the context menu.\n\t * </p>\n\t * \n\t * @param viewer The <code>AttributeTreeViewer</code> that will use the\n\t * context menu.\n\t */\n\tpublic void init(AttributeTreeViewer viewer)\n\t{\n\t    super.init(viewer);\n\t\tsuper.createContextMenu();\n\t\tm_isInitialized = true;\n\t}\n\n\t/**\n\t * Get a context <code>Menu</code> for the specified <code>IAttribute</code>.\n\t * \n\t * @param attribute The <code>IAttribute</code> to create a context menu for.\n\t * \n\t * @return A reference to a <code>Menu</code> is returned.\n\t * \n     * @see com.wizzer.mle.studio.framework.ui.IAttributeContextMenuHandler#getContextMenu(com.wizzer.mle.studio.framework.attribute.IAttribute, com.wizzer.mle.studio.framework.ui.AttributeTreeViewer)\n     */\n    public Menu getContextMenu(IAttribute attribute, AttributeTreeViewer viewer)\n    {\n        // Initialize the menu, if necessary.\n        if (! m_isInitialized)\n            init(viewer);\n        \n        // Return the context menu.\n        return m_popupMenu;\n    }\n\n}", "class_id": 0, "repo": "magic-lantern-studio/mle-studio", "file": "Studio/plugins/com.wizzer.mle.studio.dwp/src/java/com/wizzer/mle/studio/dwp/ui/DwpItemContextMenuHandler.java", "last_update_at": "2020-08-06T05:15:59+00:00", "question_id": "8759ef0f0dd054f4346589ace19221ee48f69f33", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DwpItemContextMenuHandler extends AbstractItemContextMenuHandler\n{\n    // Initialization flag.\n    boolean m_isInitialized = false;\n\t/**\n     * The default constructor.\n     */\n    public DwpItemContextMenuHandler()\n    {\n        super();\n    }\n\t/**\n\t * Initialize the handler.\n\t * <p>\n\t * This must be called prior to getting the context menu.\n\t * </p>\n\t * \n\t * @param viewer The <code>AttributeTreeViewer</code> that will use the\n\t * context menu.\n\t */\n\tpublic void init(AttributeTreeViewer viewer)\n\t{\n\t    super.init(viewer);\n\t\tsuper.createContextMenu();\n\t\tm_isInitialized = true;\n\t}\n\t/**\n\t * Get a context <code>Menu</code> for the specified <code>IAttribute</code>.\n\t * \n\t * @param attribute The <code>IAttribute</code> to create a context menu for.\n\t * \n\t * @return A reference to a <code>Menu</code> is returned.\n\t * \n     * @see com.wizzer.mle.studio.framework.ui.IAttributeContextMenuHandler#getContextMenu(com.wizzer.mle.studio.framework.attribute.IAttribute, com.wizzer.mle.studio.framework.ui.AttributeTreeViewer)\n     */\n    public Menu getContextMenu(IAttribute attribute, AttributeTreeViewer viewer)\n    {\n        // Initialize the menu, if necessary.\n        if (! m_isInitialized)\n            init(viewer);\n        // Return the context menu.\n        return m_popupMenu;\n    }\n"]]}
{"hexsha": "fab640bf849b789c3b80d7da9e275647abe3f253", "ext": "java", "lang": "Java", "content": "public class ActionImpactCalculator implements Runnable {\r\n\tprivate static final int IMPACT_DECREASE = 1;\r\n\tprivate static final int IMPACT_INCREASE = 2;\r\n\t\r\n\tprivate HashMap<String, HashMap<String, Integer>> impactTable;\r\n\t\r\n\t@Override\r\n\tpublic void run() {\r\n\t\tSystem.out.println(\"Leading Eaop for action observations.\");\r\n\t\tDesign d = new ZIPDesignReader(\"./data/benchmarks/eaop.zip\").read();\r\n\t\t\r\n\t\tif (d == null) {\r\n\t\t\tSystem.out.println(\"Could not read 'eaop.zip'.\");\r\n\t\t\tSystem.exit(1);\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(\"Exploring all possible actions.\");\r\n\t\tSet<Action> actions = d.getPossibleActions();\r\n\t\tSystem.out.printf(\"There are %d possible actions found.\\n\", actions.size());\r\n\t\t\r\n\t\tSystem.out.println(\"Calculating metrics.\");\r\n\t\tMetricSummary summary = d.getMetrics().getSummary();\r\n\t\tSystem.out.println(\"Metrics calculated.\");\r\n\t\t\r\n\t\tSystem.out.println(\"Starting operation. This may take a couple of minutes...\");\r\n\t\timpactTable = new HashMap<String, HashMap<String,Integer>>();\r\n\t\tfor (Action act : actions) {\r\n\t\t\tString type = act.getClass().getEnclosingClass().getSimpleName();\r\n\t\t\t\r\n\t\t\tDesign cdesign = d.copy();\r\n\t\t\tact.perform(cdesign);\r\n\t\t\t\r\n\t\t\tMetricSummary csummary = cdesign.getMetrics().getSummary();\r\n\t\t\t\r\n\t\t\tfor (Entry<String, Double> e : csummary.getMetrics().entrySet()) {\r\n\t\t\t\tif (e.getValue() + 1.0e-5 < summary.get(e.getKey())) {\r\n\t\t\t\t\tregisterImpact(type, e.getKey(), IMPACT_DECREASE);\r\n\t\t\t\t} else \tif (e.getValue() - 1.0e-5 > summary.get(e.getKey())) {\r\n\t\t\t\t\tregisterImpact(type, e.getKey(), IMPACT_INCREASE);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(\"Completed operation.\");\r\n\t\t\r\n\t\tfor (Entry<String, HashMap<String, Integer>> e : impactTable.entrySet()) {\r\n\t\t\tString action = e.getKey();\r\n\t\t\t\r\n\t\t\tSystem.out.printf(\"%s:\\n\", action);\r\n\t\t\t\r\n\t\t\tfor (Entry<String, Integer> me : e.getValue().entrySet()) {\r\n\t\t\t\tString metric = me.getKey();\r\n\t\t\t\tInteger impact = me.getValue();\r\n\t\t\t\t\r\n\t\t\t\tif (impact == null || impact == 0) continue;\r\n\t\t\t\t\r\n\t\t\t\tString impactText = \"increase and decrease\";\r\n\t\t\t\tif (impact == IMPACT_DECREASE)\r\n\t\t\t\t\timpactText = \"decrease\";\r\n\t\t\t\telse if (impact == IMPACT_INCREASE)\r\n\t\t\t\t\timpactText = \"increase\";\r\n\t\t\t\t\r\n\t\t\t\tSystem.out.printf(\"\\t%s: %s\\n\", metric, impactText);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate void registerImpact(String action, String metric, int impact) {\r\n\t\tHashMap<String, Integer> imap = impactTable.get(action);\r\n\t\tif (imap == null) {\r\n\t\t\timap = new HashMap<String, Integer>();\r\n\t\t\timpactTable.put(action, imap);\r\n\t\t}\r\n\t\t\r\n\t\tInteger value = imap.get(metric);\r\n\t\tif (value == null)\r\n\t\t\tvalue = impact;\r\n\t\telse\r\n\t\t\tvalue |= impact;\r\n\t\t\r\n\t\timap.put(metric, value);\r\n\t}\r\n}", "class_id": 0, "repo": "jazzmuesli/a-cma", "file": "A-CMA/src/edu/atilim/acma/ActionImpactCalculator.java", "last_update_at": "2020-01-09T16:38:35+00:00", "question_id": "fab640bf849b789c3b80d7da9e275647abe3f253", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ActionImpactCalculator implements Runnable {\r\n\tprivate static final int IMPACT_DECREASE = 1;\r\n\tprivate static final int IMPACT_INCREASE = 2;\r\n\t\r\n\tprivate HashMap<String, HashMap<String, Integer>> impactTable;\r\n\t\r\n\t@Override\r\n\tpublic void run() {\r\n\t\tSystem.out.println(\"Leading Eaop for action observations.\");\r\n\t\tDesign d = new ZIPDesignReader(\"./data/benchmarks/eaop.zip\").read();\r\n\t\t\r\n\t\tif (d == null) {\r\n\t\t\tSystem.out.println(\"Could not read 'eaop.zip'.\");\r\n\t\t\tSystem.exit(1);\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(\"Exploring all possible actions.\");\r\n\t\tSet<Action> actions = d.getPossibleActions();\r\n\t\tSystem.out.printf(\"There are %d possible actions found.\\n\", actions.size());\r\n\t\t\r\n\t\tSystem.out.println(\"Calculating metrics.\");\r\n\t\tMetricSummary summary = d.getMetrics().getSummary();\r\n\t\tSystem.out.println(\"Metrics calculated.\");\r\n\t\t\r\n\t\tSystem.out.println(\"Starting operation. This may take a couple of minutes...\");\r\n\t\timpactTable = new HashMap<String, HashMap<String,Integer>>();\r\n\t\tfor (Action act : actions) {\r\n\t\t\tString type = act.getClass().getEnclosingClass().getSimpleName();\r\n\t\t\t\r\n\t\t\tDesign cdesign = d.copy();\r\n\t\t\tact.perform(cdesign);\r\n\t\t\t\r\n\t\t\tMetricSummary csummary = cdesign.getMetrics().getSummary();\r\n\t\t\t\r\n\t\t\tfor (Entry<String, Double> e : csummary.getMetrics().entrySet()) {\r\n\t\t\t\tif (e.getValue() + 1.0e-5 < summary.get(e.getKey())) {\r\n\t\t\t\t\tregisterImpact(type, e.getKey(), IMPACT_DECREASE);\r\n\t\t\t\t} else \tif (e.getValue() - 1.0e-5 > summary.get(e.getKey())) {\r\n\t\t\t\t\tregisterImpact(type, e.getKey(), IMPACT_INCREASE);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(\"Completed operation.\");\r\n\t\t\r\n\t\tfor (Entry<String, HashMap<String, Integer>> e : impactTable.entrySet()) {\r\n\t\t\tString action = e.getKey();\r\n\t\t\t\r\n\t\t\tSystem.out.printf(\"%s:\\n\", action);\r\n\t\t\t\r\n\t\t\tfor (Entry<String, Integer> me : e.getValue().entrySet()) {\r\n\t\t\t\tString metric = me.getKey();\r\n\t\t\t\tInteger impact = me.getValue();\r\n\t\t\t\t\r\n\t\t\t\tif (impact == null || impact == 0) continue;\r\n\t\t\t\t\r\n\t\t\t\tString impactText = \"increase and decrease\";\r\n\t\t\t\tif (impact == IMPACT_DECREASE)\r\n\t\t\t\t\timpactText = \"decrease\";\r\n\t\t\t\telse if (impact == IMPACT_INCREASE)\r\n\t\t\t\t\timpactText = \"increase\";\r\n\t\t\t\t\r\n\t\t\t\tSystem.out.printf(\"\\t%s: %s\\n\", metric, impactText);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate void registerImpact(String action, String metric, int impact) {\r\n\t\tHashMap<String, Integer> imap = impactTable.get(action);\r\n\t\tif (imap == null) {\r\n\t\t\timap = new HashMap<String, Integer>();\r\n\t\t\timpactTable.put(action, imap);\r\n\t\t}\r\n\t\t\r\n\t\tInteger value = imap.get(metric);\r\n\t\tif (value == null)\r\n\t\t\tvalue = impact;\r\n\t\telse\r\n\t\t\tvalue |= impact;\r\n\t\t\r\n\t\timap.put(metric, value);\r\n\t}\r\n"]]}
{"hexsha": "9585fac25b2a77cb525150c5270863dcd32ec070", "ext": "java", "lang": "Java", "content": "public class Query22Analyzer {\n\tpublic ArrayList<String> collectDatesList(String result) throws UnsupportedEncodingException {\n\t\tSAXQuery22TemplateTransformer transformer = new SAXQuery22TemplateTransformer();\n\t\ttransformer.transform(new ByteArrayInputStream(result.getBytes(\"UTF-8\")));\n\t\treturn transformer.getDatesList();\n\t}\n}", "class_id": 0, "repo": "jsaveta/SPIMBench", "file": "src/eu/ldbc/semanticpublishing/resultanalyzers/Query22Analyzer.java", "last_update_at": "2020-12-26T12:26:50+00:00", "question_id": "9585fac25b2a77cb525150c5270863dcd32ec070", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Query22Analyzer {\n\tpublic ArrayList<String> collectDatesList(String result) throws UnsupportedEncodingException {\n\t\tSAXQuery22TemplateTransformer transformer = new SAXQuery22TemplateTransformer();\n\t\ttransformer.transform(new ByteArrayInputStream(result.getBytes(\"UTF-8\")));\n\t\treturn transformer.getDatesList();\n\t}\n"]]}
{"hexsha": "2096f9da8bf6293bc5ccfca74d51f46d0f85a1c6", "ext": "java", "lang": "Java", "content": "public class EncryptionUnit {\n    /* The purpose of the EncryptionUnit is to encapsulate all security functionality\n     * for the app. This object will handle the RSA key pair and specific information about\n     * the decryption process, namely the private key, from the rest of the app. This class\n     * will return a private key as a string that can be sent to the ESP32, as well as decrypt\n     * and given message. This object is not intended to do an encryption because the only data\n     * that is transmitted is sent from the ESP.\n     */\n    private String encryptionAlgorithm = \"RSA\";\n    private KeyPairGenerator keyGen;\n    private KeyPair keyPair;\n\n    private SecretKeyFactory symetricKeyFactory;\n    private SecretKey symmetricKey;\n\n    private Cipher cipher;\n    private Cipher dataCipher;\n\n    private IvParameterSpec ivSpec;\n\n\n    /* Constructor\n     * The constructor will create the KeyPairGenerator, use it to create a public\n     * and private key in a KeyPair object, and construct the cipher as well.\n     */\n    public EncryptionUnit(){\n        //Constructs the KeyPairGenerator and the SecretKeyFactory\n        try {\n            keyGen = KeyPairGenerator.getInstance(encryptionAlgorithm);\n            symetricKeyFactory = SecretKeyFactory.getInstance(\"AES/CBC/NoPadding\");\n        } catch (Exception NoSuchAlgorithmException) {\n            Log.d(\"key gen\", \"Algorithm not found\");\n        }\n        //Generates the Private/Public key pair\n        keyPair = keyGen.generateKeyPair();\n        //constructs the Cipher object.\n        try {\n            cipher = Cipher.getInstance(encryptionAlgorithm);\n        } catch (Exception NoSuchAlgorithmException) {\n            Log.d(\"cipher init\", \"Algorithm not found\");\n        }\n        try {\n            dataCipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        } catch (Exception NoSuchAlgorithmException) {\n            Log.d(\"cipher2 init\", \"Algorithm not found\");\n        }\n        //sets the Cipher to decrypt by default\n        try {\n            cipher.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());\n        } catch(Exception InvalidKeyException){\n            Log.d(\"cipther init\", \"Bad Private Key\");\n        }\n\n\n    }\n\n    public String getPubKeyS(){\n        PublicKey pubKey = keyPair.getPublic();\n//        byte[] keyBytes = Base64.encode(pubKey.getEncoded(), Base64.DEFAULT);\n//        String pubKeyS = new String(keyBytes);\n\n        String pubKeyS = pubKey.toString();\n        return pubKeyS;\n    }\n    public byte[] getPubKey(){\n        PublicKey pubKey = keyPair.getPublic();\n        return pubKey.getEncoded();\n    }\n\n    public String getPrivKeyS(){\n        PrivateKey privateKey = keyPair.getPrivate();\n        return privateKey.toString();\n    }\n    public String getSymKeyS(){\n        return symmetricKey.toString();\n    }\n\n    public byte[] getSymKey(){\n        return symmetricKey.getEncoded();\n    }\n\n    /* This function creates a SecretKey object from the encrypted key sent by the board that\n     * java functions can use to decrypt future received sensor data which will have been encrypted with\n     * the symmetric key.\n     * INPUT: keySource, The byte array received via readCharacteristic from the board containing the encrypted\n     *  key, iv, the initialization vector sent by the board (unencrypted).\n     * OUTPUT: No value is returned, but the global variable symmetricKey is set to the SecretKey\n     *  generated from the value sent from the board.\n     */\n    public void createSymmetricKey(byte[] keySource, byte[] iv){\n        byte[] decryptedSource = null;\n        ivSpec = new IvParameterSpec(iv);\n        try {\n            cipher.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());\n        } catch(Exception InvalidKeyException){\n            Log.d(\"cipther init\", \"Bad Private Key\");\n        }\n        try {\n            decryptedSource = cipher.doFinal(keySource);\n        } catch(Exception IllegalBlockSizeException){\n            Log.d(\"decryption\", \"bad block size\");\n        }\n        if (decryptedSource != null) {\n            byte[] keyCliped = Arrays.copyOfRange(decryptedSource, 223, 255);\n            symmetricKey = new SecretKeySpec(keyCliped, \"AES/CBC/NoPadding\");\n        }\n\n        try {\n            dataCipher.init(Cipher.DECRYPT_MODE, symmetricKey, ivSpec);\n        } catch(Exception InvalidKeyException){\n            Log.d(\"cipther init\", \"Bad Private Key\");\n        }\n    }\n\n    /* Decrypts the message sent from the esp\n     * INPUT: The string that was sent from the ESP\n     * OUTPUT: A string that is the decrypted data ONLY if decryption was successful, otherwise an error\n     * message (success means no errors were thrown, this does not mean the decrypted message is correct)\n     */\n    public byte[] decrypt(byte[] message){\n        byte[] data = new byte[0];\n        //decrypts the message\n        try {\n            data = dataCipher.doFinal(message);\n        } catch(Exception IllegalBlockSizeException){\n            Log.d(\"decryption\", \"bad block size\");\n        }\n        byte[] iv_view = dataCipher.getIV();\n        //re-init dataCipher with iv_view\n        return data;\n    }\n\n\n}", "class_id": 0, "repo": "CramerG/Weather-Station-App", "file": "Application/src/main/java/com/WWU/CyberEnvironment/BLE/EncryptionUnit.java", "last_update_at": "2020-06-17T22:13:32+00:00", "question_id": "2096f9da8bf6293bc5ccfca74d51f46d0f85a1c6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EncryptionUnit {\n    /* The purpose of the EncryptionUnit is to encapsulate all security functionality\n     * for the app. This object will handle the RSA key pair and specific information about\n     * the decryption process, namely the private key, from the rest of the app. This class\n     * will return a private key as a string that can be sent to the ESP32, as well as decrypt\n     * and given message. This object is not intended to do an encryption because the only data\n     * that is transmitted is sent from the ESP.\n     */\n    private String encryptionAlgorithm = \"RSA\";\n    private KeyPairGenerator keyGen;\n    private KeyPair keyPair;\n    private SecretKeyFactory symetricKeyFactory;\n    private SecretKey symmetricKey;\n    private Cipher cipher;\n    private Cipher dataCipher;\n    private IvParameterSpec ivSpec;\n    /* Constructor\n     * The constructor will create the KeyPairGenerator, use it to create a public\n     * and private key in a KeyPair object, and construct the cipher as well.\n     */\n    public EncryptionUnit(){\n        //Constructs the KeyPairGenerator and the SecretKeyFactory\n        try {\n            keyGen = KeyPairGenerator.getInstance(encryptionAlgorithm);\n            symetricKeyFactory = SecretKeyFactory.getInstance(\"AES/CBC/NoPadding\");\n        } catch (Exception NoSuchAlgorithmException) {\n            Log.d(\"key gen\", \"Algorithm not found\");\n        }\n        //Generates the Private/Public key pair\n        keyPair = keyGen.generateKeyPair();\n        //constructs the Cipher object.\n        try {\n            cipher = Cipher.getInstance(encryptionAlgorithm);\n        } catch (Exception NoSuchAlgorithmException) {\n            Log.d(\"cipher init\", \"Algorithm not found\");\n        }\n        try {\n            dataCipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        } catch (Exception NoSuchAlgorithmException) {\n            Log.d(\"cipher2 init\", \"Algorithm not found\");\n        }\n        //sets the Cipher to decrypt by default\n        try {\n            cipher.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());\n        } catch(Exception InvalidKeyException){\n            Log.d(\"cipther init\", \"Bad Private Key\");\n        }\n    }\n    public String getPubKeyS(){\n        PublicKey pubKey = keyPair.getPublic();\n//        byte[] keyBytes = Base64.encode(pubKey.getEncoded(), Base64.DEFAULT);\n//        String pubKeyS = new String(keyBytes);\n        String pubKeyS = pubKey.toString();\n        return pubKeyS;\n    }\n    public byte[] getPubKey(){\n        PublicKey pubKey = keyPair.getPublic();\n        return pubKey.getEncoded();\n    }\n    public String getPrivKeyS(){\n        PrivateKey privateKey = keyPair.getPrivate();\n        return privateKey.toString();\n    }\n    public String getSymKeyS(){\n        return symmetricKey.toString();\n    }\n    public byte[] getSymKey(){\n        return symmetricKey.getEncoded();\n    }\n    /* This function creates a SecretKey object from the encrypted key sent by the board that\n     * java functions can use to decrypt future received sensor data which will have been encrypted with\n     * the symmetric key.\n     * INPUT: keySource, The byte array received via readCharacteristic from the board containing the encrypted\n     *  key, iv, the initialization vector sent by the board (unencrypted).\n     * OUTPUT: No value is returned, but the global variable symmetricKey is set to the SecretKey\n     *  generated from the value sent from the board.\n     */\n    public void createSymmetricKey(byte[] keySource, byte[] iv){\n        byte[] decryptedSource = null;\n        ivSpec = new IvParameterSpec(iv);\n        try {\n            cipher.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());\n        } catch(Exception InvalidKeyException){\n            Log.d(\"cipther init\", \"Bad Private Key\");\n        }\n        try {\n            decryptedSource = cipher.doFinal(keySource);\n        } catch(Exception IllegalBlockSizeException){\n            Log.d(\"decryption\", \"bad block size\");\n        }\n        if (decryptedSource != null) {\n            byte[] keyCliped = Arrays.copyOfRange(decryptedSource, 223, 255);\n            symmetricKey = new SecretKeySpec(keyCliped, \"AES/CBC/NoPadding\");\n        }\n        try {\n            dataCipher.init(Cipher.DECRYPT_MODE, symmetricKey, ivSpec);\n        } catch(Exception InvalidKeyException){\n            Log.d(\"cipther init\", \"Bad Private Key\");\n        }\n    }\n    /* Decrypts the message sent from the esp\n     * INPUT: The string that was sent from the ESP\n     * OUTPUT: A string that is the decrypted data ONLY if decryption was successful, otherwise an error\n     * message (success means no errors were thrown, this does not mean the decrypted message is correct)\n     */\n    public byte[] decrypt(byte[] message){\n        byte[] data = new byte[0];\n        //decrypts the message\n        try {\n            data = dataCipher.doFinal(message);\n        } catch(Exception IllegalBlockSizeException){\n            Log.d(\"decryption\", \"bad block size\");\n        }\n        byte[] iv_view = dataCipher.getIV();\n        //re-init dataCipher with iv_view\n        return data;\n    }\n"]]}
{"hexsha": "29b78ee7cd65e40f45c2f175a939fbab2154e803", "ext": "java", "lang": "Java", "content": "public class Is24CsvReadingExample {\n    @SuppressWarnings(\"unused\")\n    private final static Logger LOGGER = LoggerFactory.getLogger(Is24CsvReadingExample.class);\n\n    /**\n     * Start the example application.\n     *\n     * @param args command line arguments\n     */\n    @SuppressWarnings(\"Duplicates\")\n    public static void main(String[] args) {\n        // read example file, if no files were specified as command line arguments\n        if (args.length < 1) {\n            try {\n                read(Is24CsvReadingExample.class.getResourceAsStream(\"is24.csv\"));\n            } catch (Exception ex) {\n                LOGGER.error(\"Can't read example file!\");\n                LOGGER.error(\"> \" + ex.getLocalizedMessage(), ex);\n                System.exit(2);\n            }\n        }\n\n        // read files, that were specified as command line arguments\n        else {\n            for (String arg : args) {\n                try {\n                    read(new File(arg));\n                } catch (Exception ex) {\n                    LOGGER.error(\"Can't read file '{}'!\", arg);\n                    LOGGER.error(\"> \" + ex.getLocalizedMessage(), ex);\n                    System.exit(2);\n                }\n            }\n        }\n    }\n\n    /**\n     * Read a {@link File} into an {@link Is24CsvParser} and print some of its\n     * content to console.\n     *\n     * @param csvFile the CSV file to read\n     * @throws IOException if the file is not readable\n     */\n    protected static void read(File csvFile) throws IOException {\n        LOGGER.info(\"processing file '{}'\", csvFile.getAbsolutePath());\n        if (!csvFile.isFile()) {\n            LOGGER.warn(\"> The provided file is invalid!\");\n            return;\n        }\n        try (Is24CsvParser parser = Is24CsvParser.create(csvFile)) {\n            if (parser == null)\n                LOGGER.warn(\"> Can't create parser!\");\n            else\n                printToConsole(parser);\n        }\n    }\n\n    /**\n     * Read an {@link InputStream} into an {@link Is24CsvParser} and print some of\n     * its content to console.\n     *\n     * @param csvInputStream the input stream to read\n     * @throws IOException if the file is not readable\n     */\n    protected static void read(InputStream csvInputStream) throws IOException {\n        LOGGER.info(\"processing example file\");\n        try (Is24CsvParser parser = Is24CsvParser.create(csvInputStream)) {\n            if (parser == null)\n                LOGGER.warn(\"> Can't create parser!\");\n            else\n                printToConsole(parser);\n        }\n    }\n\n    /**\n     * Print some content of an {@link Is24CsvParser} to console.\n     *\n     * @param parser parser instance\n     */\n    protected static void printToConsole(Is24CsvParser parser) {\n        // process records\n        while (parser.hasNext()) {\n            Is24CsvRecord record = parser.next();\n\n            // get object nr\n            String objectNr = record.getAnbieterObjektId();\n\n            // get object title\n            String objectTitle = record.getUeberschrift();\n\n            // print object information to console\n            LOGGER.info(\"> found object '{}': {}\",\n                    objectNr, objectTitle);\n        }\n    }\n}", "class_id": 0, "repo": "OpenEstate/OpenEstate-IO", "file": "Examples/src/main/java/org/openestate/io/examples/Is24CsvReadingExample.java", "last_update_at": "2020-12-13T07:27:36+00:00", "question_id": "29b78ee7cd65e40f45c2f175a939fbab2154e803", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Is24CsvReadingExample {\n    @SuppressWarnings(\"unused\")\n    private final static Logger LOGGER = LoggerFactory.getLogger(Is24CsvReadingExample.class);\n    /**\n     * Start the example application.\n     *\n     * @param args command line arguments\n     */\n    @SuppressWarnings(\"Duplicates\")\n    public static void main(String[] args) {\n        // read example file, if no files were specified as command line arguments\n        if (args.length < 1) {\n            try {\n                read(Is24CsvReadingExample.class.getResourceAsStream(\"is24.csv\"));\n            } catch (Exception ex) {\n                LOGGER.error(\"Can't read example file!\");\n                LOGGER.error(\"> \" + ex.getLocalizedMessage(), ex);\n                System.exit(2);\n            }\n        }\n        // read files, that were specified as command line arguments\n        else {\n            for (String arg : args) {\n                try {\n                    read(new File(arg));\n                } catch (Exception ex) {\n                    LOGGER.error(\"Can't read file '{}'!\", arg);\n                    LOGGER.error(\"> \" + ex.getLocalizedMessage(), ex);\n                    System.exit(2);\n                }\n            }\n        }\n    }\n    /**\n     * Read a {@link File} into an {@link Is24CsvParser} and print some of its\n     * content to console.\n     *\n     * @param csvFile the CSV file to read\n     * @throws IOException if the file is not readable\n     */\n    protected static void read(File csvFile) throws IOException {\n        LOGGER.info(\"processing file '{}'\", csvFile.getAbsolutePath());\n        if (!csvFile.isFile()) {\n            LOGGER.warn(\"> The provided file is invalid!\");\n            return;\n        }\n        try (Is24CsvParser parser = Is24CsvParser.create(csvFile)) {\n            if (parser == null)\n                LOGGER.warn(\"> Can't create parser!\");\n            else\n                printToConsole(parser);\n        }\n    }\n    /**\n     * Read an {@link InputStream} into an {@link Is24CsvParser} and print some of\n     * its content to console.\n     *\n     * @param csvInputStream the input stream to read\n     * @throws IOException if the file is not readable\n     */\n    protected static void read(InputStream csvInputStream) throws IOException {\n        LOGGER.info(\"processing example file\");\n        try (Is24CsvParser parser = Is24CsvParser.create(csvInputStream)) {\n            if (parser == null)\n                LOGGER.warn(\"> Can't create parser!\");\n            else\n                printToConsole(parser);\n        }\n    }\n    /**\n     * Print some content of an {@link Is24CsvParser} to console.\n     *\n     * @param parser parser instance\n     */\n    protected static void printToConsole(Is24CsvParser parser) {\n        // process records\n        while (parser.hasNext()) {\n            Is24CsvRecord record = parser.next();\n            // get object nr\n            String objectNr = record.getAnbieterObjektId();\n            // get object title\n            String objectTitle = record.getUeberschrift();\n            // print object information to console\n            LOGGER.info(\"> found object '{}': {}\",\n                    objectNr, objectTitle);\n        }\n    }\n"]]}
{"hexsha": "1a239330996bab460acc01363c394b0c03d796e4", "ext": "java", "lang": "Java", "content": "public class PutTransformAction extends ActionType<AcknowledgedResponse> {\n\n    public static final PutTransformAction INSTANCE = new PutTransformAction();\n    public static final String NAME = \"cluster:admin/transform/put\";\n\n    private static final TimeValue MIN_FREQUENCY = TimeValue.timeValueSeconds(1);\n    private static final TimeValue MAX_FREQUENCY = TimeValue.timeValueHours(1);\n\n    private PutTransformAction() {\n        super(NAME, AcknowledgedResponse::new);\n    }\n\n    public static class Request extends AcknowledgedRequest<Request> {\n\n        private final TransformConfig config;\n        private final boolean deferValidation;\n\n        public Request(TransformConfig config, boolean deferValidation) {\n            this.config = config;\n            this.deferValidation = deferValidation;\n        }\n\n        public Request(StreamInput in) throws IOException {\n            super(in);\n            this.config = new TransformConfig(in);\n            if (in.getVersion().onOrAfter(Version.V_7_4_0)) {\n                this.deferValidation = in.readBoolean();\n            } else {\n                this.deferValidation = false;\n            }\n        }\n\n        public static Request fromXContent(final XContentParser parser, final String id, final boolean deferValidation) {\n            return new Request(TransformConfig.fromXContent(parser, id, false), deferValidation);\n        }\n\n        /**\n         * More complex validations with how {@link TransformConfig#getDestination()} and\n         * {@link TransformConfig#getSource()} relate are done in the transport handler.\n         */\n        @Override\n        public ActionRequestValidationException validate() {\n            ActionRequestValidationException validationException = null;\n\n            validationException = config.validate(validationException);\n            validationException = SourceDestValidator.validateRequest(validationException, config.getDestination().getIndex());\n\n            if (TransformStrings.isValidId(config.getId()) == false) {\n                validationException = addValidationError(\n                    TransformMessages.getMessage(TransformMessages.INVALID_ID, TransformField.ID.getPreferredName(), config.getId()),\n                    validationException\n                );\n            }\n            if (TransformStrings.hasValidLengthForId(config.getId()) == false) {\n                validationException = addValidationError(\n                    TransformMessages.getMessage(TransformMessages.ID_TOO_LONG, TransformStrings.ID_LENGTH_LIMIT),\n                    validationException\n                );\n            }\n            TimeValue frequency = config.getFrequency();\n            if (frequency != null) {\n                if (frequency.compareTo(MIN_FREQUENCY) < 0) {\n                    validationException = addValidationError(\n                        \"minimum permitted [\" + TransformField.FREQUENCY + \"] is [\" + MIN_FREQUENCY.getStringRep() + \"]\",\n                        validationException\n                    );\n                } else if (frequency.compareTo(MAX_FREQUENCY) > 0) {\n                    validationException = addValidationError(\n                        \"highest permitted [\" + TransformField.FREQUENCY + \"] is [\" + MAX_FREQUENCY.getStringRep() + \"]\",\n                        validationException\n                    );\n                }\n            }\n\n            return validationException;\n        }\n\n        public TransformConfig getConfig() {\n            return config;\n        }\n\n        public boolean isDeferValidation() {\n            return deferValidation;\n        }\n\n        @Override\n        public void writeTo(StreamOutput out) throws IOException {\n            super.writeTo(out);\n            this.config.writeTo(out);\n            if (out.getVersion().onOrAfter(Version.V_7_4_0)) {\n                out.writeBoolean(this.deferValidation);\n            }\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(config, deferValidation);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            Request other = (Request) obj;\n            return Objects.equals(config, other.config) && this.deferValidation == other.deferValidation;\n        }\n    }\n\n}", "class_id": 0, "repo": "odidev/elasticsearch", "file": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/transform/action/PutTransformAction.java", "last_update_at": "2020-11-13T04:57:47+00:00", "question_id": "1a239330996bab460acc01363c394b0c03d796e4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PutTransformAction extends ActionType<AcknowledgedResponse> {\n    public static final PutTransformAction INSTANCE = new PutTransformAction();\n    public static final String NAME = \"cluster:admin/transform/put\";\n    private static final TimeValue MIN_FREQUENCY = TimeValue.timeValueSeconds(1);\n    private static final TimeValue MAX_FREQUENCY = TimeValue.timeValueHours(1);\n    private PutTransformAction() {\n        super(NAME, AcknowledgedResponse::new);\n    }\n    public static class Request extends AcknowledgedRequest<Request> {\n        private final TransformConfig config;\n        private final boolean deferValidation;\n        public Request(TransformConfig config, boolean deferValidation) {\n            this.config = config;\n            this.deferValidation = deferValidation;\n        }\n        public Request(StreamInput in) throws IOException {\n            super(in);\n            this.config = new TransformConfig(in);\n            if (in.getVersion().onOrAfter(Version.V_7_4_0)) {\n                this.deferValidation = in.readBoolean();\n            } else {\n                this.deferValidation = false;\n            }\n        }\n        public static Request fromXContent(final XContentParser parser, final String id, final boolean deferValidation) {\n            return new Request(TransformConfig.fromXContent(parser, id, false), deferValidation);\n        }\n        /**\n         * More complex validations with how {@link TransformConfig#getDestination()} and\n         * {@link TransformConfig#getSource()} relate are done in the transport handler.\n         */\n        @Override\n        public ActionRequestValidationException validate() {\n            ActionRequestValidationException validationException = null;\n            validationException = config.validate(validationException);\n            validationException = SourceDestValidator.validateRequest(validationException, config.getDestination().getIndex());\n            if (TransformStrings.isValidId(config.getId()) == false) {\n                validationException = addValidationError(\n                    TransformMessages.getMessage(TransformMessages.INVALID_ID, TransformField.ID.getPreferredName(), config.getId()),\n                    validationException\n                );\n            }\n            if (TransformStrings.hasValidLengthForId(config.getId()) == false) {\n                validationException = addValidationError(\n                    TransformMessages.getMessage(TransformMessages.ID_TOO_LONG, TransformStrings.ID_LENGTH_LIMIT),\n                    validationException\n                );\n            }\n            TimeValue frequency = config.getFrequency();\n            if (frequency != null) {\n                if (frequency.compareTo(MIN_FREQUENCY) < 0) {\n                    validationException = addValidationError(\n                        \"minimum permitted [\" + TransformField.FREQUENCY + \"] is [\" + MIN_FREQUENCY.getStringRep() + \"]\",\n                        validationException\n                    );\n                } else if (frequency.compareTo(MAX_FREQUENCY) > 0) {\n                    validationException = addValidationError(\n                        \"highest permitted [\" + TransformField.FREQUENCY + \"] is [\" + MAX_FREQUENCY.getStringRep() + \"]\",\n                        validationException\n                    );\n                }\n            }\n            return validationException;\n        }\n        public TransformConfig getConfig() {\n            return config;\n        }\n        public boolean isDeferValidation() {\n            return deferValidation;\n        }\n        @Override\n        public void writeTo(StreamOutput out) throws IOException {\n            super.writeTo(out);\n            this.config.writeTo(out);\n            if (out.getVersion().onOrAfter(Version.V_7_4_0)) {\n                out.writeBoolean(this.deferValidation);\n            }\n        }\n        @Override\n        public int hashCode() {\n            return Objects.hash(config, deferValidation);\n        }\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            Request other = (Request) obj;\n            return Objects.equals(config, other.config) && this.deferValidation == other.deferValidation;\n        }\n    }\n"]]}
{"hexsha": "24d42a85665fdc773da355db531eb2570d5677ee", "ext": "java", "lang": "Java", "content": "public class TestIoCAnno1 {\n\n\t@Test\n\tpublic void test() {\n\t\tAnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(\"aop.target\");\n\t\tFoo bar = context.getBean(Foo.class);\n\t\tbar.bar();\n\t\tSystem.out.println(bar);\n\n\t\tBarCat.BarCat11 bar1 = context.getBean(BarCat.BarCat11.class);\n\t\tSystem.out.println(\"\u3002\u3002\u3002\u3002\u3002\"+bar1);\n\t\tcontext.close();\n\t}\n\n}", "class_id": 0, "repo": "IThawk/learnCode", "file": "spring5/spring-framework/spring-demo/src/test/java/ioc/test/TestIoCAnno1.java", "last_update_at": "2020-12-26T04:52:15+00:00", "question_id": "24d42a85665fdc773da355db531eb2570d5677ee", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestIoCAnno1 {\n\t@Test\n\tpublic void test() {\n\t\tAnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(\"aop.target\");\n\t\tFoo bar = context.getBean(Foo.class);\n\t\tbar.bar();\n\t\tSystem.out.println(bar);\n\t\tBarCat.BarCat11 bar1 = context.getBean(BarCat.BarCat11.class);\n\t\tSystem.out.println(\"\u3002\u3002\u3002\u3002\u3002\"+bar1);\n\t\tcontext.close();\n\t}\n"]]}
{"hexsha": "09343084dac137b7556062d8077e9fdff9e6951a", "ext": "java", "lang": "Java", "content": "@Slf4j\n@Service\npublic class CouponServiceImpl implements CouponService {\n\n    @Autowired\n    CouponRepository couponRepository;\n    @Autowired\n    CouponUserRepository couponUserRepository;\n\n\n    @Override\n    public Optional<CouponEntity> findById(Integer couponId) {\n        return couponRepository.findById(couponId);\n    }\n\n    @Override\n    public Optional<CouponEntity> findByCode(String code) {\n        return couponRepository.findByCode(code);\n    }\n\n    @Override\n    public Page<CouponEntity> findPage(Integer pageNum, Integer pageSize) {\n        Page<CouponEntity> page = couponRepository.findAll((Specification<CouponEntity>) (root, criteriaQuery, criteriaBuilder) -> {\n\n            Predicate predicate = criteriaBuilder.conjunction();\n            List<Expression<Boolean>> expressions = predicate.getExpressions();\n            expressions.add(criteriaBuilder.equal(root.<Boolean>get(\"deleted\"), false));\n            return predicate;\n        }, PageRequest.of(pageNum, pageSize, new Sort(Sort.Direction.DESC, \"id\")));\n\n        return page;\n    }\n\n\n    @Override\n    public Page<CouponEntity> findByUserIdPage(String userId, Integer pageNum, Integer pageSize) {\n\n        List<CouponUserEntity> couponUserEntities = couponUserRepository.findByUserIdAndDeleted(userId, false).orElseGet(() -> new ArrayList<>());\n        List<Integer> couponIds = couponUserEntities.stream().map(CouponUserEntity::getCouponId).collect(Collectors.toList());\n        Page<CouponEntity> page = couponRepository.findAll((Specification<CouponEntity>) (root, criteriaQuery, criteriaBuilder) -> {\n\n            Predicate predicate = criteriaBuilder.conjunction();\n            List<Expression<Boolean>> expressions = predicate.getExpressions();\n            expressions.add(criteriaBuilder.equal(root.<Boolean>get(\"deleted\"), false));\n            if (!CollectionUtils.isEmpty(couponIds)) {\n                CriteriaBuilder.In<Integer> in = criteriaBuilder.in(root.<Integer>get(\"id\"));\n                for (Integer id : couponIds) {\n                    in.value(id);\n                }\n                expressions.add(criteriaBuilder.and(in));\n            }\n\n\n            return predicate;\n        }, PageRequest.of(pageNum, pageSize, new Sort(Sort.Direction.DESC, \"id\")));\n\n        return page;\n    }\n\n\n    @Override\n    public Optional<List<CouponEntity>> findByIdIn(List<Integer> couponIds) {\n        return couponRepository.findByDeletedAndIdIn(false, couponIds);\n    }\n\n\n    /**\n     * \u68c0\u6d4b\u4f18\u60e0\u5238\u662f\u5426\u9002\u5408\n     *\n     * @param userId\n     * @param couponId\n     * @param checkedGoodsPrice\n     * @return\n     */\n    @Override\n    public CouponEntity checkCoupon(String userId, Integer couponId, Integer userCouponId, BigDecimal checkedGoodsPrice) {\n        CouponEntity couponEntity = couponRepository.findById(couponId).orElseThrow(() -> new BusinessException(\"\u62fc\u56e2\u8bb0\u5f55\u4e0d\u5b58\u5728\"));\n\n        CouponUserEntity couponUserEntity = couponUserRepository.findById(userCouponId).orElseGet(() -> {\n            CouponUserEntity entity = couponUserRepository.findByUserIdAndCouponIdAndDeleted(userId, couponId, false)\n                    .orElseGet(() -> new CouponUserEntity());\n            return entity;\n        });\n        if (!couponId.equals(couponUserEntity.getCouponId())) {\n            throw new BusinessException(\"\u4f18\u60e0\u5238\u672a\u9886\u53d6\");\n        }\n\n        // \u68c0\u67e5\u662f\u5426\u8d85\u671f\n        LocalDateTime now = LocalDateTime.now();\n        CouponTimeTypeEnum commentTypeEnum = CouponTimeTypeEnum.parse(couponEntity.getTimeType());\n        switch (commentTypeEnum) {\n            case TIME_TYPE_TIME: {\n                if (now.isBefore(couponEntity.getStartTime()) || now.isAfter(couponEntity.getEndTime())) {\n                    throw new BusinessException(\"\u4f18\u60e0\u5238\u672a\u9886\u53d6\");\n                }\n                break;\n            }\n            case TIME_TYPE_DAYS: {\n                LocalDateTime expired = couponUserEntity.getAddTime().plusDays(couponEntity.getDays());\n                if (now.isAfter(expired)) {\n                    throw new BusinessException(\"\u4f18\u60e0\u5238\u672a\u9886\u53d6\");\n                }\n                break;\n            }\n            default: {\n                throw new BusinessException(\"\u4f18\u60e0\u5238\u672a\u9886\u53d6\");\n            }\n        }\n\n        // \u68c0\u6d4b\u5546\u54c1\u662f\u5426\u7b26\u5408\n        // TODO \u76ee\u524d\u4ec5\u652f\u6301\u5168\u5e73\u53f0\u5546\u54c1\uff0c\u6240\u4ee5\u4e0d\u9700\u8981\u68c0\u6d4b\n        if (GoodsRestrictionTypeEnum.GOODS_TYPE_ALL.getCode() != couponEntity.getGoodsType()) {\n            throw new BusinessException(\"\u4f18\u60e0\u5238\u672a\u9886\u53d6\");\n        }\n\n        // \u68c0\u6d4b\u8ba2\u5355\u72b6\u6001\n        if (CouponStatusEnum.STATUS_NORMAL.getCode() != couponEntity.getStatus()) {\n            throw new BusinessException(\"\u4f18\u60e0\u5238\u672a\u9886\u53d6\");\n        }\n        // \u68c0\u6d4b\u662f\u5426\u6ee1\u8db3\u6700\u4f4e\u6d88\u8d39\n        if (checkedGoodsPrice.compareTo(couponEntity.getMin()) == -1) {\n            throw new BusinessException(\"\u4f18\u60e0\u5238\u672a\u9886\u53d6\");\n        }\n\n        return couponEntity;\n    }\n}", "class_id": 0, "repo": "bit-go/mouse", "file": "rotor-api/src/main/java/com/mouse/api/service/impl/CouponServiceImpl.java", "last_update_at": "2020-05-24T07:20:25+00:00", "question_id": "09343084dac137b7556062d8077e9fdff9e6951a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Slf4j\n@Service\npublic class CouponServiceImpl implements CouponService {\n    @Autowired\n    CouponRepository couponRepository;\n    @Autowired\n    CouponUserRepository couponUserRepository;\n    @Override\n    public Optional<CouponEntity> findById(Integer couponId) {\n        return couponRepository.findById(couponId);\n    }\n    @Override\n    public Optional<CouponEntity> findByCode(String code) {\n        return couponRepository.findByCode(code);\n    }\n    @Override\n    public Page<CouponEntity> findPage(Integer pageNum, Integer pageSize) {\n        Page<CouponEntity> page = couponRepository.findAll((Specification<CouponEntity>) (root, criteriaQuery, criteriaBuilder) -> {\n            Predicate predicate = criteriaBuilder.conjunction();\n            List<Expression<Boolean>> expressions = predicate.getExpressions();\n            expressions.add(criteriaBuilder.equal(root.<Boolean>get(\"deleted\"), false));\n            return predicate;\n        }, PageRequest.of(pageNum, pageSize, new Sort(Sort.Direction.DESC, \"id\")));\n        return page;\n    }\n    @Override\n    public Page<CouponEntity> findByUserIdPage(String userId, Integer pageNum, Integer pageSize) {\n        List<CouponUserEntity> couponUserEntities = couponUserRepository.findByUserIdAndDeleted(userId, false).orElseGet(() -> new ArrayList<>());\n        List<Integer> couponIds = couponUserEntities.stream().map(CouponUserEntity::getCouponId).collect(Collectors.toList());\n        Page<CouponEntity> page = couponRepository.findAll((Specification<CouponEntity>) (root, criteriaQuery, criteriaBuilder) -> {\n            Predicate predicate = criteriaBuilder.conjunction();\n            List<Expression<Boolean>> expressions = predicate.getExpressions();\n            expressions.add(criteriaBuilder.equal(root.<Boolean>get(\"deleted\"), false));\n            if (!CollectionUtils.isEmpty(couponIds)) {\n                CriteriaBuilder.In<Integer> in = criteriaBuilder.in(root.<Integer>get(\"id\"));\n                for (Integer id : couponIds) {\n                    in.value(id);\n                }\n                expressions.add(criteriaBuilder.and(in));\n            }\n            return predicate;\n        }, PageRequest.of(pageNum, pageSize, new Sort(Sort.Direction.DESC, \"id\")));\n        return page;\n    }\n    @Override\n    public Optional<List<CouponEntity>> findByIdIn(List<Integer> couponIds) {\n        return couponRepository.findByDeletedAndIdIn(false, couponIds);\n    }\n    /**\n     * \u68c0\u6d4b\u4f18\u60e0\u5238\u662f\u5426\u9002\u5408\n     *\n     * @param userId\n     * @param couponId\n     * @param checkedGoodsPrice\n     * @return\n     */\n    @Override\n    public CouponEntity checkCoupon(String userId, Integer couponId, Integer userCouponId, BigDecimal checkedGoodsPrice) {\n        CouponEntity couponEntity = couponRepository.findById(couponId).orElseThrow(() -> new BusinessException(\"\u62fc\u56e2\u8bb0\u5f55\u4e0d\u5b58\u5728\"));\n        CouponUserEntity couponUserEntity = couponUserRepository.findById(userCouponId).orElseGet(() -> {\n            CouponUserEntity entity = couponUserRepository.findByUserIdAndCouponIdAndDeleted(userId, couponId, false)\n                    .orElseGet(() -> new CouponUserEntity());\n            return entity;\n        });\n        if (!couponId.equals(couponUserEntity.getCouponId())) {\n            throw new BusinessException(\"\u4f18\u60e0\u5238\u672a\u9886\u53d6\");\n        }\n        // \u68c0\u67e5\u662f\u5426\u8d85\u671f\n        LocalDateTime now = LocalDateTime.now();\n        CouponTimeTypeEnum commentTypeEnum = CouponTimeTypeEnum.parse(couponEntity.getTimeType());\n        switch (commentTypeEnum) {\n            case TIME_TYPE_TIME: {\n                if (now.isBefore(couponEntity.getStartTime()) || now.isAfter(couponEntity.getEndTime())) {\n                    throw new BusinessException(\"\u4f18\u60e0\u5238\u672a\u9886\u53d6\");\n                }\n                break;\n            }\n            case TIME_TYPE_DAYS: {\n                LocalDateTime expired = couponUserEntity.getAddTime().plusDays(couponEntity.getDays());\n                if (now.isAfter(expired)) {\n                    throw new BusinessException(\"\u4f18\u60e0\u5238\u672a\u9886\u53d6\");\n                }\n                break;\n            }\n            default: {\n                throw new BusinessException(\"\u4f18\u60e0\u5238\u672a\u9886\u53d6\");\n            }\n        }\n        // \u68c0\u6d4b\u5546\u54c1\u662f\u5426\u7b26\u5408\n        // TODO \u76ee\u524d\u4ec5\u652f\u6301\u5168\u5e73\u53f0\u5546\u54c1\uff0c\u6240\u4ee5\u4e0d\u9700\u8981\u68c0\u6d4b\n        if (GoodsRestrictionTypeEnum.GOODS_TYPE_ALL.getCode() != couponEntity.getGoodsType()) {\n            throw new BusinessException(\"\u4f18\u60e0\u5238\u672a\u9886\u53d6\");\n        }\n        // \u68c0\u6d4b\u8ba2\u5355\u72b6\u6001\n        if (CouponStatusEnum.STATUS_NORMAL.getCode() != couponEntity.getStatus()) {\n            throw new BusinessException(\"\u4f18\u60e0\u5238\u672a\u9886\u53d6\");\n        }\n        // \u68c0\u6d4b\u662f\u5426\u6ee1\u8db3\u6700\u4f4e\u6d88\u8d39\n        if (checkedGoodsPrice.compareTo(couponEntity.getMin()) == -1) {\n            throw new BusinessException(\"\u4f18\u60e0\u5238\u672a\u9886\u53d6\");\n        }\n        return couponEntity;\n    }\n"]]}
{"hexsha": "29955dc0f072a31c3c8d1dbf8d6fa21ddfd709dc", "ext": "java", "lang": "Java", "content": "public class NumberFrequency {\n\n    private Map<Integer, TreeMap<Integer, Integer>> save = new HashMap<>();\n\n    public NumberFrequency(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            TreeMap<Integer, Integer> indexMap = save.computeIfAbsent(arr[i], k -> new TreeMap<>());\n            Integer index = indexMap.floorKey(i);\n            if (index == null){\n                indexMap.put(i, 1);\n            } else {\n                indexMap.put(i, indexMap.get(index) + 1);\n            }\n        }\n    }\n\n    public int query(int left, int right, int value) {\n        TreeMap<Integer, Integer> query = save.get(value);\n        if (query == null){\n            return 0;\n        }\n        Integer min = query.floorKey(left);\n        if (min == null){\n            Integer max = query.floorKey(right);\n            if (max == null){\n                return 0;\n            }\n            return query.get(max);\n        }\n        int minCount = query.get(min);\n        minCount = min == left ? minCount - 1 : minCount;\n        Integer max = query.floorKey(right);\n        return query.get(max) - minCount;\n    }\n\n\n    public static void main(String[] args) {\n        NumberFrequency test = new NumberFrequency(new int[]{12,33,4,56,22,2,34,33,22,12,34,56});\n        System.out.println(test.query(0, 11, 33));\n    }\n}", "class_id": 0, "repo": "FFLuoyan/LeetCode", "file": "WeeklyCompetition/src/main/java/org/zongjieli/leetcode/competion/singleweekly/order268/NumberFrequency.java", "last_update_at": "2020-01-03T06:27:33+00:00", "question_id": "29955dc0f072a31c3c8d1dbf8d6fa21ddfd709dc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NumberFrequency {\n    private Map<Integer, TreeMap<Integer, Integer>> save = new HashMap<>();\n    public NumberFrequency(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            TreeMap<Integer, Integer> indexMap = save.computeIfAbsent(arr[i], k -> new TreeMap<>());\n            Integer index = indexMap.floorKey(i);\n            if (index == null){\n                indexMap.put(i, 1);\n            } else {\n                indexMap.put(i, indexMap.get(index) + 1);\n            }\n        }\n    }\n    public int query(int left, int right, int value) {\n        TreeMap<Integer, Integer> query = save.get(value);\n        if (query == null){\n            return 0;\n        }\n        Integer min = query.floorKey(left);\n        if (min == null){\n            Integer max = query.floorKey(right);\n            if (max == null){\n                return 0;\n            }\n            return query.get(max);\n        }\n        int minCount = query.get(min);\n        minCount = min == left ? minCount - 1 : minCount;\n        Integer max = query.floorKey(right);\n        return query.get(max) - minCount;\n    }\n    public static void main(String[] args) {\n        NumberFrequency test = new NumberFrequency(new int[]{12,33,4,56,22,2,34,33,22,12,34,56});\n        System.out.println(test.query(0, 11, 33));\n    }\n"]]}
{"hexsha": "8006237289788fd6b0a041805561ee24f746645b", "ext": "java", "lang": "Java", "content": "public class DnaSequence {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String seq = sc.next(), maxStr = \"\";\n        int minSubstrLen = sc.nextInt(), count;\n        sc.close();\n        double maxRatio = 0.0;\n        for (int i = 0; i <= seq.length() - minSubstrLen; i++) {\n            for (int j = i + minSubstrLen; j <= seq.length(); j++) {\n                count = 0;\n                for (int k = i; k < j; k++) {\n                    if (seq.charAt(k) == 'G' || seq.charAt(k) == 'C') {\n                        count++;\n                    }\n                }\n                if (count * 1.0 / (j - i) > maxRatio) {\n                    maxRatio = count * 1.0 / (j - i);\n                    maxStr = seq.substring(i, j);\n                }\n            }\n        }\n        System.out.printf(\"%s\", maxStr);\n    }\n}", "class_id": 0, "repo": "cyp0633/homework", "file": "ObjectProgramming/two/dna/DnaSequence.java", "last_update_at": "2020-12-14T08:52:40+00:00", "question_id": "8006237289788fd6b0a041805561ee24f746645b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DnaSequence {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String seq = sc.next(), maxStr = \"\";\n        int minSubstrLen = sc.nextInt(), count;\n        sc.close();\n        double maxRatio = 0.0;\n        for (int i = 0; i <= seq.length() - minSubstrLen; i++) {\n            for (int j = i + minSubstrLen; j <= seq.length(); j++) {\n                count = 0;\n                for (int k = i; k < j; k++) {\n                    if (seq.charAt(k) == 'G' || seq.charAt(k) == 'C') {\n                        count++;\n                    }\n                }\n                if (count * 1.0 / (j - i) > maxRatio) {\n                    maxRatio = count * 1.0 / (j - i);\n                    maxStr = seq.substring(i, j);\n                }\n            }\n        }\n        System.out.printf(\"%s\", maxStr);\n    }\n"]]}
{"hexsha": "908b6e8625ad9ea0b57ddddb23fec40061b2171d", "ext": "java", "lang": "Java", "content": "public class GoodsModelAndDtoConversion implements BaseConversion<GoodsModel, GoodsDto> {\n\n    private static class SingletonClassInstance {\n        private static final GoodsModelAndDtoConversion conversion = new GoodsModelAndDtoConversion();\n    }\n\n    private GoodsModelAndDtoConversion() {\n    }\n\n    public static GoodsModelAndDtoConversion getConversion() {\n        return SingletonClassInstance.conversion;\n    }\n\n    @Override\n    public GoodsModel toModel(GoodsDto dto) {\n        GoodsModel model = new GoodsModel();\n        return model;\n    }\n\n    @Override\n    public GoodsDto toDto(GoodsModel model) {\n        GoodsDto dto = new GoodsDto();\n        dto.setId(model.getId());\n        dto.setUserId(model.getUserId());\n        dto.setGoodsName(model.getGoodsName());\n        dto.setGoodsUrl(model.getGoodsUrl());\n        dto.setGoodsPrice(model.getGoodsPrice());\n        dto.setGoodsTotalQty(model.getGoodsTotalQty());\n        dto.setCreationTime(model.getCreationTime());\n        dto.setLastUpdateTime(model.getLastUpdateTime());\n        dto.setRemark(model.getRemark());\n        return dto;\n    }\n}", "class_id": 0, "repo": "yanghui0212/java-dome", "file": "spring-cloud/spring-cloud-dome/goods-server/src/main/java/com/yqh/conversion/GoodsModelAndDtoConversion.java", "last_update_at": "2020-07-08T08:13:41+00:00", "question_id": "908b6e8625ad9ea0b57ddddb23fec40061b2171d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GoodsModelAndDtoConversion implements BaseConversion<GoodsModel, GoodsDto> {\n    private static class SingletonClassInstance {\n        private static final GoodsModelAndDtoConversion conversion = new GoodsModelAndDtoConversion();\n    }\n    private GoodsModelAndDtoConversion() {\n    }\n    public static GoodsModelAndDtoConversion getConversion() {\n        return SingletonClassInstance.conversion;\n    }\n    @Override\n    public GoodsModel toModel(GoodsDto dto) {\n        GoodsModel model = new GoodsModel();\n        return model;\n    }\n    @Override\n    public GoodsDto toDto(GoodsModel model) {\n        GoodsDto dto = new GoodsDto();\n        dto.setId(model.getId());\n        dto.setUserId(model.getUserId());\n        dto.setGoodsName(model.getGoodsName());\n        dto.setGoodsUrl(model.getGoodsUrl());\n        dto.setGoodsPrice(model.getGoodsPrice());\n        dto.setGoodsTotalQty(model.getGoodsTotalQty());\n        dto.setCreationTime(model.getCreationTime());\n        dto.setLastUpdateTime(model.getLastUpdateTime());\n        dto.setRemark(model.getRemark());\n        return dto;\n    }\n"]]}
{"hexsha": "a2aa1bfff4593de1db593dbc940d34ada2d14567", "ext": "java", "lang": "Java", "content": "public class SNLDA extends AbstractSampler {\n\n    public static final int POSITVE = 1;\n    public static final int NEGATIVE = -1;\n    // hyperparameters for fixed-height tree\n    protected double[] alphas;          // [L-1]\n    protected double[] betas;           // [L]\n    protected double[] pis;     // [L-1] mean of bias coins\n    protected double[] gammas;    // [L-1] scale of bias coins\n    protected double rho;\n    protected double mu;\n    protected double[] sigmas;\n\n    // inputs\n    protected int[][] words; // all words\n    protected double[] responses; // [D] continous responses\n    protected int[] labels; // [D] binary responses\n    protected ArrayList<Integer> docIndices; // indices of docs under consideration\n    protected int V;    // vocabulary size\n    protected int[] Ks; // [L-1]: number of children per node at each level\n    protected PathAssumption path;\n    // derived\n    protected int D; // number of documents\n    protected int L;\n    // latent\n    Node[][] z;\n    Node root;\n    // internal\n    private int numTokensAccepted;\n    private double[] docMeans;\n    private boolean isBinary;\n    private Set<Integer> positives;\n    private double uniform;\n    private boolean isRooted;\n\n    // cached probabilities computed at the first level\n    private HashMap<Node, Double> cachedProbabilities;\n\n    public SNLDA() {\n        this.basename = \"SNLDA\";\n    }\n\n    public SNLDA(String bname) {\n        this.basename = bname;\n    }\n\n    public void configure(SNLDA sampler) {\n        this.isBinary = sampler.isBinary;\n        if (this.isBinary) {\n            this.configureBinary(sampler.folder,\n                    sampler.V,\n                    sampler.Ks,\n                    sampler.alphas,\n                    sampler.betas,\n                    sampler.pis,\n                    sampler.gammas,\n                    sampler.mu,\n                    sampler.sigmas,\n                    sampler.initState,\n                    sampler.path,\n                    sampler.paramOptimized,\n                    sampler.isRooted,\n                    sampler.BURN_IN,\n                    sampler.MAX_ITER,\n                    sampler.LAG,\n                    sampler.REP_INTERVAL);\n        } else {\n            this.configureContinuous(sampler.folder,\n                    sampler.V,\n                    sampler.Ks,\n                    sampler.alphas,\n                    sampler.betas,\n                    sampler.pis,\n                    sampler.gammas,\n                    sampler.rho,\n                    sampler.mu,\n                    sampler.sigmas,\n                    sampler.initState,\n                    sampler.path,\n                    sampler.paramOptimized,\n                    sampler.isRooted,\n                    sampler.BURN_IN,\n                    sampler.MAX_ITER,\n                    sampler.LAG,\n                    sampler.REP_INTERVAL);\n        }\n    }\n\n    public void configureBinary(String folder,\n            int V, int[] Ks,\n            double[] alphas,\n            double[] betas,\n            double[] pis,\n            double[] gammas,\n            double mu,\n            double[] sigmas,\n            InitialState initState,\n            PathAssumption pathAssumption,\n            boolean paramOpt, boolean isRooted,\n            int burnin, int maxiter, int samplelag, int repInt) {\n        if (verbose) {\n            logln(\"Configuring ...\");\n        }\n        this.folder = folder;\n        this.V = V;\n        this.uniform = 1.0 / this.V;\n        this.Ks = Ks;\n        this.L = this.Ks.length + 1;\n\n        this.alphas = alphas;\n        this.betas = betas;\n        this.pis = pis;\n        this.gammas = gammas;\n        this.mu = mu;\n        this.sigmas = sigmas;\n\n        this.hyperparams = new ArrayList<Double>();\n        this.sampledParams = new ArrayList<ArrayList<Double>>();\n        this.sampledParams.add(cloneHyperparameters());\n\n        this.BURN_IN = burnin;\n        this.MAX_ITER = maxiter;\n        this.LAG = samplelag;\n        this.REP_INTERVAL = repInt;\n\n        this.initState = initState;\n        this.path = pathAssumption;\n        this.paramOptimized = paramOpt;\n        this.prefix += initState.toString();\n        this.isBinary = true;\n        this.isRooted = isRooted;\n\n        this.setName();\n\n        if (verbose) {\n            logln(\"--- V = \" + V);\n            logln(\"--- Ks = \" + MiscUtils.arrayToString(this.Ks));\n            logln(\"--- folder\\t\" + folder);\n            logln(\"--- alphas:\\t\" + MiscUtils.arrayToString(alphas));\n            logln(\"--- betas:\\t\" + MiscUtils.arrayToString(betas));\n            logln(\"--- pis:\\t\" + MiscUtils.arrayToString(pis));\n            logln(\"--- gammas:\\t\" + MiscUtils.arrayToString(gammas));\n            logln(\"--- rho:\\t\" + MiscUtils.formatDouble(rho));\n            logln(\"--- mu:\\t\" + MiscUtils.formatDouble(mu));\n            logln(\"--- sigmas:\\t\" + MiscUtils.arrayToString(sigmas));\n            logln(\"--- burn-in:\\t\" + BURN_IN);\n            logln(\"--- max iter:\\t\" + MAX_ITER);\n            logln(\"--- sample lag:\\t\" + LAG);\n            logln(\"--- report interval:\\t\" + REP_INTERVAL);\n            logln(\"--- paramopt:\\t\" + paramOptimized);\n            logln(\"--- initialize:\\t\" + this.initState);\n            logln(\"--- path assumption:\\t\" + this.path);\n            logln(\"--- is rooted:\\t\" + this.isRooted);\n        }\n\n        validateInputHyperparameters();\n    }\n\n    public void configureContinuous(String folder,\n            int V, int[] Ks,\n            double[] alphas,\n            double[] betas,\n            double[] pis,\n            double[] gammas,\n            double rho,\n            double mu,\n            double[] sigmas,\n            InitialState initState,\n            PathAssumption pathAssumption,\n            boolean paramOpt, boolean isRooted,\n            int burnin, int maxiter, int samplelag, int repInt) {\n        if (verbose) {\n            logln(\"Configuring ...\");\n        }\n        this.folder = folder;\n        this.V = V;\n        this.uniform = 1.0 / this.V;\n        this.Ks = Ks;\n        this.L = this.Ks.length + 1;\n\n        this.alphas = alphas;\n        this.betas = betas;\n        this.pis = pis;\n        this.gammas = gammas;\n        this.rho = rho;\n        this.mu = mu;\n        this.sigmas = sigmas;\n\n        this.hyperparams = new ArrayList<Double>();\n        this.sampledParams = new ArrayList<ArrayList<Double>>();\n        this.sampledParams.add(cloneHyperparameters());\n\n        this.BURN_IN = burnin;\n        this.MAX_ITER = maxiter;\n        this.LAG = samplelag;\n        this.REP_INTERVAL = repInt;\n\n        this.initState = initState;\n        this.path = pathAssumption;\n        this.paramOptimized = paramOpt;\n        this.prefix += initState.toString();\n        this.isBinary = false;\n        this.isRooted = isRooted;\n\n        this.setName();\n\n        if (verbose) {\n            logln(\"--- V = \" + V);\n            logln(\"--- Ks = \" + MiscUtils.arrayToString(this.Ks));\n            logln(\"--- folder\\t\" + folder);\n            logln(\"--- alphas:\\t\" + MiscUtils.arrayToString(alphas));\n            logln(\"--- betas:\\t\" + MiscUtils.arrayToString(betas));\n            logln(\"--- pis:\\t\" + MiscUtils.arrayToString(pis));\n            logln(\"--- gammas:\\t\" + MiscUtils.arrayToString(gammas));\n            logln(\"--- rho:\\t\" + MiscUtils.formatDouble(rho));\n            logln(\"--- mu:\\t\" + MiscUtils.formatDouble(mu));\n            logln(\"--- sigmas:\\t\" + MiscUtils.arrayToString(sigmas));\n            logln(\"--- burn-in:\\t\" + BURN_IN);\n            logln(\"--- max iter:\\t\" + MAX_ITER);\n            logln(\"--- sample lag:\\t\" + LAG);\n            logln(\"--- report interval:\\t\" + REP_INTERVAL);\n            logln(\"--- paramopt:\\t\" + paramOptimized);\n            logln(\"--- initialize:\\t\" + this.initState);\n            logln(\"--- path assumption:\\t\" + this.path);\n            logln(\"--- is rooted:\\t\" + this.isRooted);\n        }\n\n        validateInputHyperparameters();\n    }\n\n    private void validateInputHyperparameters() {\n        if (L - 1 != Ks.length) {\n            throw new MismatchRuntimeException(L - 1, Ks.length);\n        }\n        if (alphas.length != L - 1) {\n            throw new MismatchRuntimeException(alphas.length, L - 1);\n        }\n        if (betas.length != L) {\n            throw new MismatchRuntimeException(betas.length, L);\n        }\n        if (pis.length != L - 1) {\n            throw new MismatchRuntimeException(pis.length, L - 1);\n        }\n        if (gammas.length != L - 1) {\n            throw new MismatchRuntimeException(gammas.length, L - 1);\n        }\n        if (sigmas.length != L) {\n            throw new MismatchRuntimeException(sigmas.length, L - 1);\n        }\n        if (!isBinary && rho == 0.0) {\n            throw new RuntimeException(\"Rho should not be 0 when the response is continuous\");\n        }\n    }\n\n    protected void setName() {\n        StringBuilder str = new StringBuilder();\n        str.append(this.prefix)\n                .append(\"_\").append(basename);\n        str.append(\"_Ks\");\n        for (int K : Ks) {\n            str.append(\"-\").append(K);\n        }\n        str.append(\"_B-\").append(BURN_IN)\n                .append(\"_M-\").append(MAX_ITER)\n                .append(\"_L-\").append(LAG);\n        str.append(\"_a\");\n        for (double la : alphas) {\n            str.append(\"-\").append(MiscUtils.formatDouble(la));\n        }\n        str.append(\"_b\");\n        for (double b : betas) {\n            str.append(\"-\").append(MiscUtils.formatDouble(b));\n        }\n        str.append(\"_p\");\n        for (double gm : pis) {\n            str.append(\"-\").append(MiscUtils.formatDouble(gm));\n        }\n        str.append(\"_g\");\n        for (double gs : gammas) {\n            str.append(\"-\").append(MiscUtils.formatDouble(gs));\n        }\n        str.append(\"_r-\").append(MiscUtils.formatDouble(rho));\n        str.append(\"_m-\").append(MiscUtils.formatDouble(mu));\n        str.append(\"_s\");\n        for (double s : sigmas) {\n            str.append(\"-\").append(MiscUtils.formatDouble(s));\n        }\n        str.append(\"_opt-\").append(this.paramOptimized);\n        str.append(\"_bin-\").append(this.isBinary);\n        str.append(\"_path-\").append(this.path);\n        str.append(\"_root-\").append(this.isRooted);\n        this.name = str.toString();\n    }\n\n    protected double getAlpha(int l) {\n        return this.alphas[l];\n    }\n\n    protected double getBeta(int l) {\n        return this.betas[l];\n    }\n\n    protected double getPi(int l) {\n        return this.pis[l];\n    }\n\n    protected double getGamma(int l) {\n        return this.gammas[l];\n    }\n\n    protected double getSigma(int l) {\n        return this.sigmas[l];\n    }\n\n    @Override\n    public String getCurrentState() {\n        return this.getSamplerFolderPath() + \"\\n\"\n                + printGlobalTreeSummary() + \"\\n\";\n    }\n\n    public boolean isLeafNode(int level) {\n        return level == L - 1;\n    }\n\n    public double[] getPredictedValues() {\n        return docMeans;\n    }\n\n    /**\n     * Setting up text data.\n     *\n     * @param docWords\n     * @param docIndices\n     */\n    private void setupTextData(int[][] docWords, ArrayList<Integer> docIndices) {\n        this.docIndices = docIndices;\n        if (this.docIndices == null) { // add all documents\n            this.docIndices = new ArrayList<>();\n            for (int dd = 0; dd < docWords.length; dd++) {\n                this.docIndices.add(dd);\n            }\n        }\n        this.numTokens = 0;\n        this.D = this.docIndices.size();\n        this.words = new int[D][];\n        for (int ii = 0; ii < D; ii++) {\n            int dd = this.docIndices.get(ii);\n            this.words[ii] = docWords[dd];\n            this.numTokens += this.words[ii].length;\n        }\n\n        if (verbose) {\n            logln(\"--- # all docs:\\t\" + words.length);\n            logln(\"--- # selected docs:\\t\" + D);\n            logln(\"--- # tokens:\\t\" + numTokens);\n        }\n    }\n\n    /**\n     * Set up continuous responses.\n     *\n     * @param docResponses\n     */\n    public void setContinuousResponses(double[] docResponses) {\n        this.responses = new double[D];\n        for (int ii = 0; ii < D; ii++) {\n            this.responses[ii] = docResponses[this.docIndices.get(ii)];\n        }\n        if (verbose) {\n            logln(\"--- continuous responses:\");\n            logln(\"--- --- mean\\t\" + MiscUtils.formatDouble(\n                    StatUtils.mean(responses)));\n            logln(\"--- --- stdv\\t\" + MiscUtils.formatDouble(\n                    StatUtils.standardDeviation(responses)));\n            int[] histogram = StatUtils.bin(responses, 10);\n            for (int ii = 0; ii < histogram.length; ii++) {\n                logln(\"--- --- \" + ii + \"\\t\" + histogram[ii]);\n            }\n        }\n    }\n\n    /**\n     * Set up binary responses.\n     *\n     * @param docLabels\n     */\n    public void setBinaryResponses(int[] docLabels) {\n        this.labels = new int[D];\n        this.positives = new HashSet<Integer>();\n        for (int ii = 0; ii < D; ii++) {\n            int dd = this.docIndices.get(ii);\n            this.labels[ii] = docLabels[dd];\n            if (this.labels[ii] == POSITVE) {\n                this.positives.add(ii);\n            }\n        }\n        if (verbose) {\n            logln(\"--- binary responses:\");\n            int posCount = this.positives.size();\n            logln(\"--- --- # postive: \" + posCount\n                    + \" (\" + ((double) posCount / D) + \")\");\n            logln(\"--- --- # negative: \" + (D - posCount));\n        }\n    }\n\n    /**\n     * Set up training data with continuous responses.\n     *\n     * @param docWords All documents\n     * @param docIndices Indices of selected documents. If this is null, all\n     * documents are considered.\n     * @param docResponses Continuous responses\n     */\n    public void train(int[][] docWords,\n            ArrayList<Integer> docIndices,\n            double[] docResponses) {\n        setupTextData(docWords, docIndices);\n        setContinuousResponses(docResponses);\n    }\n\n    /**\n     * Set up training data with binary responses.\n     *\n     * @param docWords All documents\n     * @param docIndices Indices of selected documents. If this is null, all\n     * documents are considered.\n     * @param docLabels Binary labels\n     */\n    public void train(int[][] docWords,\n            ArrayList<Integer> docIndices,\n            int[] docLabels) {\n        setupTextData(docWords, docIndices);\n        setBinaryResponses(docLabels);\n    }\n\n    /**\n     * Set up test data.\n     *\n     * @param docWords Test documents\n     * @param docIndices Indices of test documents\n     */\n    public void test(int[][] docWords, ArrayList<Integer> docIndices) {\n        setupTextData(docWords, docIndices);\n    }\n\n    /**\n     * Set up test data.\n     *\n     * @param stateFile Input file storing trained model\n     * @param testStateFile Output file to store assignments\n     * @param predictionFile Output file to store predictions at different test\n     * iterations using the given trained model\n     * @return Prediction on all documents using the given model\n     */\n    public double[] sampleTest(File stateFile, File testStateFile, File predictionFile) {\n        setTestConfigurations(BURN_IN / 2, MAX_ITER / 2, LAG / 2);\n        if (stateFile == null) {\n            stateFile = getFinalStateFile();\n        }\n        inputModel(stateFile.toString()); // input stored model\n        initializeDataStructure(); // initialize data\n\n        // store predictions at different test iterations\n        ArrayList<double[]> predResponsesList = new ArrayList<double[]>();\n\n        // sample topic assignments for test document\n        for (iter = 0; iter < this.testMaxIter; iter++) {\n            isReporting = verbose && iter % testRepInterval == 0;\n            if (isReporting) {\n                String str = \"Iter \" + iter + \"/\" + testMaxIter\n                        + \". current thread: \" + Thread.currentThread().getId();\n                if (iter < BURN_IN) {\n                    logln(\"--- Burning in. \" + str + \"\\n\" + getCurrentState());\n                } else {\n                    logln(\"--- Sampling. \" + str + \"\\n\" + getCurrentState());\n                }\n            }\n\n            if (iter == 0) {\n                sampleZs(!REMOVE, !ADD, !REMOVE, ADD);\n            } else {\n                sampleZs(!REMOVE, !ADD, REMOVE, ADD);\n            }\n\n            // store prediction (on all documents) at a test iteration\n            if (iter >= this.testBurnIn && iter % this.testSampleLag == 0) {\n                double[] predResponses = new double[D];\n                System.arraycopy(docMeans, 0, predResponses, 0, D);\n                predResponsesList.add(predResponses);\n\n                if (responses != null) { // debug\n                    evaluatePerformances();\n                }\n            }\n        }\n\n        // output state file containing the assignments for test documents\n        if (testStateFile != null) {\n            outputState(testStateFile.getAbsolutePath(), false, true);\n        }\n\n        // store predictions if necessary\n        if (predictionFile != null) {\n            PredictionUtils.outputSingleModelRegressions(predictionFile, predResponsesList);\n        }\n\n        // average over all stored predictions\n        double[] predictions = new double[D];\n        for (int dd = 0; dd < D; dd++) {\n            for (double[] predResponses : predResponsesList) {\n                predictions[dd] += predResponses[dd] / predResponsesList.size();\n            }\n        }\n        return predictions;\n    }\n\n    @Override\n    public void initialize() {\n        initialize(null, null);\n    }\n\n    public void initialize(double[][] priorTopics, double[] initEtas) {\n        if (verbose) {\n            logln(\"Initializing ...\");\n        }\n        iter = INIT;\n        isReporting = true;\n        initializeModelStructure(priorTopics, initEtas);\n        initializeDataStructure();\n        initializeAssignments();\n        updateEtas();\n\n        if (verbose) {\n            logln(\"--- Done initializing.\\n\" + printGlobalTree());\n            logln(\"\\n\" + printGlobalTreeSummary() + \"\\n\");\n            getLogLikelihood();\n        }\n\n        outputTopicTopWords(new File(getSamplerFolderPath(), \"init-\" + TopWordFile), 20);\n        validate(\"Initialized\");\n    }\n\n    protected void initializeModelFirstLevelNodes(double[][] priorTopics, double[] initEtas) {\n        int level = 1;\n        for (int kk = 0; kk < Ks[0]; kk++) {\n            // prior topic\n            double[] prior;\n            if (priorTopics == null) {\n                prior = new double[V];\n                Arrays.fill(prior, uniform);\n            } else {\n                prior = priorTopics[kk];\n            }\n\n            // initial eta\n            double eta;\n            if (initEtas != null) {\n                eta = initEtas[kk];\n            } else {\n                eta = SamplerUtils.getGaussian(mu, getSigma(level));\n            }\n\n            // initialize\n            DirMult topic = new DirMult(V, getBeta(1) * V, prior);\n            Node node = new Node(iter, kk, level, topic, root, eta);\n            this.root.addChild(kk, node);\n        }\n    }\n\n    protected void initializeModelStructure(double[][] priorTopics, double[] initEtas) {\n        if (verbose) {\n            logln(\"--- Initializing model structure ...\");\n        }\n\n        // initialize root node\n        DirMult rootTopic = new DirMult(V, getBeta(0) * V, uniform);\n        double rootEta = SamplerUtils.getGaussian(mu, getSigma(0));\n        this.root = new Node(iter, 0, 0, rootTopic, null, rootEta);\n\n        // first level\n        initializeModelFirstLevelNodes(priorTopics, initEtas);\n        Queue<Node> queue = new LinkedList<>();\n        for (Node child : root.getChildren()) {\n            queue.add(child);\n        }\n\n        // from 2nd-level downward\n        while (!queue.isEmpty()) {\n            Node node = queue.poll();\n            int level = node.getLevel();\n            if (level < L - 1) {\n                for (int kk = 0; kk < Ks[level]; kk++) {\n                    DirMult topic = new DirMult(V, getBeta(level + 1) * V, uniform);\n                    Node child = new Node(iter, kk, level + 1, topic, node,\n                            SamplerUtils.getGaussian(mu, getSigma(level)));\n                    node.addChild(kk, child);\n                    queue.add(child);\n                }\n            }\n        }\n\n        // initialize pi's and theta's\n        Stack<Node> stack = new Stack<>();\n        stack.add(root);\n        while (!stack.isEmpty()) {\n            Node node = stack.pop();\n            if (node.getLevel() < L - 1) {\n                node.initializeGlobalTheta();\n                node.initializeGlobalPi();\n                for (Node child : node.getChildren()) {\n                    stack.add(child);\n                }\n            }\n        }\n\n        if (verbose) {\n            logln(\"--- --- Initialized model structure.\\n\" + printGlobalTreeSummary());\n        }\n    }\n\n    protected void initializeDataStructure() {\n        if (verbose) {\n            logln(\"--- Initializing data structure ...\");\n        }\n        this.z = new Node[D][];\n        for (int dd = 0; dd < D; dd++) {\n            this.z[dd] = new Node[words[dd].length];\n        }\n        this.docMeans = new double[D];\n    }\n\n    protected void initializeAssignments() {\n        if (verbose) {\n            logln(\"--- Initializing assignments. \" + initState);\n        }\n        switch (initState) {\n            case RANDOM:\n                initializeRandomAssignments();\n                break;\n            case PRESET:\n                initializePresetAssignments();\n                break;\n            default:\n                throw new RuntimeException(\"Initialization not supported\");\n        }\n    }\n\n    private void initializeRandomAssignments() {\n        sampleZs(!REMOVE, ADD, !REMOVE, ADD, !OBSERVED);\n    }\n\n    private void initializePresetAssignments() {\n//        SLDA slda = new SLDA();\n//        slda.setDebug(false);\n//        slda.setVerbose(verbose);\n//        slda.setLog(false);\n//        \n//        slda.configure(new File(foldFolder, modelFolder).getAbsolutePath(),\n//                trainData.getWordVocab().size(), K,\n//                alpha, beta, rho, mu, sigma,\n//                initState, paramOpt, hasBias,\n//                burn_in, max_iters, sample_lag, report_interval);\n//        \n//        LDA lda = runLDA(words, Ks[0], V, null);\n//        int[][] ldaZs = lda.getZs();\n//\n//        for (int dd = 0; dd < D; dd++) {\n//            for (int nn = 0; nn < words[dd].length; nn++) {\n//                Node sampledNode = sampleNode(dd, nn, root.getChild(ldaZs[dd][nn]));\n//                addToken(dd, nn, sampledNode, ADD, ADD);\n//            }\n//        }\n    }\n\n    /**\n     * Add a token to a node.\n     *\n     * @param dd\n     * @param nn\n     * @param node\n     * @param addToData\n     * @param addToModel\n     */\n    private void addToken(int dd, int nn, Node node,\n            boolean addToData, boolean addToModel) {\n        if (addToModel) {\n            node.getContent().increment(words[dd][nn]);\n            Node tempNode = node;\n            while (tempNode != null) {\n                tempNode.incrementSubtreeWordCount(words[dd][nn]);\n                tempNode = tempNode.getParent();\n            }\n        }\n        if (addToData) {\n            docMeans[dd] += node.pathEta / this.words[dd].length;\n            node.nodeDocCounts.increment(dd);\n            Node tempNode = node;\n            while (tempNode != null) {\n                tempNode.subtreeDocCounts.increment(dd);\n                tempNode = tempNode.getParent();\n            }\n        }\n    }\n\n    /**\n     * Remove a token from a node.\n     *\n     * @param dd\n     * @param nn\n     * @param node\n     * @param removeFromData\n     * @param removeFromModel\n     */\n    private void removeToken(int dd, int nn, Node node,\n            boolean removeFromData, boolean removeFromModel) {\n        if (removeFromData) {\n            docMeans[dd] -= node.pathEta / this.words[dd].length;\n            node.nodeDocCounts.decrement(dd);\n            Node tempNode = node;\n            while (tempNode != null) {\n                tempNode.subtreeDocCounts.decrement(dd);\n                tempNode = tempNode.getParent();\n            }\n        }\n        if (removeFromModel) {\n            node.getContent().decrement(words[dd][nn]);\n            Node tempNode = node;\n            while (tempNode != null) {\n                tempNode.decrementSubtreeWordCount(words[dd][nn]);\n                tempNode = tempNode.getParent();\n            }\n        }\n    }\n\n    @Override\n    public void iterate() {\n        if (isReporting) {\n            System.out.println(\"\\n\");\n            logln(\"Iteration \" + iter + \" / \" + MAX_ITER);\n        }\n        sampleZs(REMOVE, ADD, REMOVE, ADD, OBSERVED);\n        updateEtas();\n    }\n\n    // ONLY FOR DEBUGGING\n    private Node sampleNodeSimple(int dd, int nn, boolean observed) {\n        double[] logprobs = new double[Ks[0]];\n        for (int kk = 0; kk < Ks[0]; kk++) {\n            Node node = root.getChild(kk);\n            logprobs[kk] = Math.log(node.subtreeDocCounts.getCount(dd) + getAlpha(0))\n                    + Math.log(node.getNodeWordProbability(words[dd][nn]));\n            if (observed) {\n                double mean = docMeans[dd] + node.pathEta / words[dd].length;\n                logprobs[kk] += StatUtils.logNormalProbability(responses[dd], mean, Math.sqrt(rho));\n            }\n        }\n        int sampledZ = SamplerUtils.logMaxRescaleSample(logprobs);\n        return root.getChild(sampledZ);\n    }\n\n    /**\n     * Gibbs sample node assignment for all tokens.\n     *\n     * @param removeFromModel\n     * @param addToModel\n     * @param removeFromData\n     * @param addToData\n     * @return Elapsed time\n     */\n    protected long sampleZs(boolean removeFromModel, boolean addToModel,\n            boolean removeFromData, boolean addToData) {\n        if (isReporting) {\n            logln(\"+++ Gibbs sampling Zs ...\");\n        }\n        numTokensChanged = 0;\n        long sTime = System.currentTimeMillis();\n        for (int dd = 0; dd < D; dd++) {\n            for (int nn = 0; nn < words[dd].length; nn++) {\n                // remove\n                removeToken(dd, nn, z[dd][nn], removeFromData, removeFromModel);\n\n                Node sampledNode = sampleNode(dd, nn, root);\n                if (z[dd][nn] == null || !z[dd][nn].equals(sampledNode)) {\n                    numTokensChanged++;\n                }\n                z[dd][nn] = sampledNode;\n\n                // add\n                addToken(dd, nn, z[dd][nn], addToData, addToModel);\n            }\n        }\n\n        long eTime = System.currentTimeMillis() - sTime;\n        if (isReporting) {\n            logln(\"--- --- time: \" + eTime);\n            logln(\"--- --- # tokens: \" + numTokens\n                    + \". # changed: \" + numTokensChanged\n                    + \" (\" + MiscUtils.formatDouble((double) numTokensChanged / numTokens) + \")\"\n            );\n        }\n        return eTime;\n    }\n\n    /**\n     * MH sample node assignment for all tokens.\n     *\n     * @param removeFromModel\n     * @param addToModel\n     * @param removeFromData\n     * @param addToData\n     * @param observed\n     * @return Elapsed time\n     */\n    protected long sampleZs(boolean removeFromModel, boolean addToModel,\n            boolean removeFromData, boolean addToData, boolean observed) {\n        if (isReporting) {\n            logln(\"+++ MH-sampling Zs ...\");\n        }\n        numTokensChanged = 0;\n        numTokensAccepted = 0;\n\n        long sTime = System.currentTimeMillis();\n        for (int dd = 0; dd < D; dd++) {\n            for (int nn = 0; nn < words[dd].length; nn++) {\n                // remove\n                removeToken(dd, nn, z[dd][nn], removeFromData, removeFromModel);\n\n                boolean accept = false;\n                Node sampledNode = sampleNode(dd, nn, root);\n                if (z[dd][nn] == null) {\n                    accept = true;\n                    numTokensChanged++;\n                    numTokensAccepted++;\n                } else if (sampledNode.equals(z[dd][nn])) {\n                    accept = true;\n                    numTokensAccepted++;\n                } else {\n                    if (evaluateProposedNode(dd, nn, z[dd][nn], sampledNode, observed)) {\n                        accept = true;\n                        numTokensAccepted++;\n                    }\n                }\n                if (accept) {\n                    if (z[dd][nn] != null && !z[dd][nn].equals(sampledNode)) {\n                        numTokensChanged++;\n                    }\n                    z[dd][nn] = sampledNode;\n                }\n\n                // add\n                addToken(dd, nn, z[dd][nn], addToData, addToModel);\n            }\n        }\n\n        long eTime = System.currentTimeMillis() - sTime;\n        if (isReporting) {\n            logln(\"--- --- time: \" + eTime);\n            logln(\"--- --- # tokens: \" + numTokens\n                    + \". # changed: \" + numTokensChanged\n                    + \" (\" + MiscUtils.formatDouble((double) numTokensChanged / numTokens) + \")\"\n                    + \". # accepted: \" + numTokensAccepted\n                    + \" (\" + MiscUtils.formatDouble((double) numTokensAccepted / numTokens) + \")\");\n        }\n        return eTime;\n    }\n\n    /**\n     * Recursively sample node level-by-level.\n     *\n     * @param dd\n     * @param nn\n     * @param curNode\n     */\n    private Node sampleNode(int dd, int nn, Node curNode) {\n        if (curNode.isLeaf()) {\n            return curNode;\n        }\n        if (curNode.isRoot()) {\n            cachedProbabilities = new HashMap<>();\n        }\n\n        int level = curNode.getLevel();\n        ArrayList<Node> nodeList = new ArrayList<>();\n        ArrayList<Double> probList = new ArrayList<>();\n\n        // staying at this node\n        double gamma = getGamma(level);\n        double stayprob;\n        if (curNode.isRoot() && !isRooted) {\n            stayprob = 0.0;\n        } else {\n            stayprob = (curNode.nodeDocCounts.getCount(dd) + gamma * curNode.pi)\n                    / (curNode.subtreeDocCounts.getCount(dd) + gamma);\n            double wordprob = curNode.getNodeWordProbability(words[dd][nn]);\n            double prob = stayprob * wordprob;\n            probList.add(prob);\n            nodeList.add(curNode);\n\n            if (curNode.isRoot()) {\n                cachedProbabilities.put(curNode, prob);\n            }\n        }\n\n        // moving to one of the children nodes\n        double alpha = getAlpha(level);\n        double passprob = 1.0 - stayprob;\n        int KK = curNode.getNumChildren();\n        double norm = curNode.getPassingCount(dd) + alpha * KK;\n        for (Node child : curNode.getChildren()) {\n            int kk = child.getIndex();\n            double pathprob = (child.subtreeDocCounts.getCount(dd)\n                    + alpha * KK * curNode.theta[kk]) / norm;\n            double wordprob = child.getSubtreeWordProbability(words[dd][nn]);\n            double prob = passprob * pathprob * wordprob;\n            probList.add(prob);\n            nodeList.add(child);\n\n            if (curNode.isRoot()) {\n                cachedProbabilities.put(child, prob);\n            }\n        }\n\n        int sampledIdx = SamplerUtils.scaleSample(probList);\n        Node sampledNode = nodeList.get(sampledIdx);\n\n        if (sampledNode.equals(curNode)) {\n            return curNode;\n        } else {\n            return sampleNode(dd, nn, sampledNode);\n        }\n    }\n\n    /**\n     * Evaluate proposed node using Metropolis-Hastings algorithm.\n     *\n     * @param dd\n     * @param nn\n     * @param curNode\n     * @param newNode\n     * @param observed\n     */\n    private boolean evaluateProposedNode(int dd, int nn,\n            Node curNode, Node newNode, boolean observed) {\n        double newNodeTrueProb = getTrueLogProbability(dd, nn, newNode, observed);\n        double curNodeTrueProb = getTrueLogProbability(dd, nn, curNode, observed);\n\n        double newNodePropProb = getProporalProbability(dd, nn, newNode);\n        double curNodePropProb = getProporalProbability(dd, nn, curNode);\n\n        double ratio = (newNodeTrueProb * curNodePropProb) / (curNodeTrueProb * newNodePropProb);\n        return rand.nextDouble() < Math.min(1.0, ratio);\n    }\n\n    private double getTrueLogProbability(int dd, int nn, Node node, boolean observed) {\n        double lp = node.getNodeWordProbability(words[dd][nn]);\n        if (observed) {\n            lp *= Math.exp(getResponseLogLikelihood(dd, node));\n        }\n        lp *= getActualPathProbability(dd, nn, node, node);\n        Node source = node.getParent();\n        Node target = node;\n        while (!target.isRoot()) {\n            lp *= getActualPathProbability(dd, nn, source, target);\n            target = source;\n            source = source.getParent();\n        }\n        return lp;\n    }\n\n    private double getActualPathProbability(int dd, int nn, Node source, Node target) {\n        int level = source.getLevel();\n        if (level == L - 1) { // leaf node\n            return 1.0;\n        }\n        double stayprob;\n        if (source.isRoot() && !isRooted) {\n            stayprob = 0.0;\n        } else {\n            stayprob = (source.nodeDocCounts.getCount(dd) + getGamma(level) * source.pi)\n                    / (source.subtreeDocCounts.getCount(dd) + getGamma(level));\n        }\n        if (source.equals(target)) {\n            return (stayprob);\n        }\n\n        double alpha = getAlpha(level);\n        double passprob = 1.0 - stayprob;\n        int KK = source.getNumChildren();\n        double pathprob = (target.subtreeDocCounts.getCount(dd) + alpha * KK * source.theta[target.getIndex()])\n                / (source.getPassingCount(dd) + alpha * KK);\n        return (passprob * pathprob);\n    }\n\n    private double getProporalProbability(int dd, int nn, Node node) {\n        double prob = getProposalPathProbability(dd, nn, node, node);\n        Node source = node.getParent();\n        Node target = node;\n        while (!target.isRoot()) {\n            prob *= getProposalPathProbability(dd, nn, source, target);\n            target = source;\n            source = source.getParent();\n        }\n        return prob;\n    }\n\n    private double getProposalPathProbability(int dd, int nn, Node source, Node target) {\n        int level = source.getLevel();\n        if (level == 0) { // use cached probabilities\n            double totalProb = 0.0;\n            for (double prob : cachedProbabilities.values()) {\n                totalProb += prob;\n            }\n            Double prob = cachedProbabilities.get(target);\n            if (prob == null) {\n                throw new RuntimeException(\"Null probability\");\n            }\n            return (prob / totalProb);\n        } else if (level == L - 1) { // leaf node\n            return 1.0;\n        }\n\n        double gamma = getGamma(level);\n        double num = 0.0;\n        double den = 0.0;\n\n        double stayprob;\n        if (source.isRoot() && !isRooted) {\n            stayprob = 0.0;\n        } else {\n            stayprob = (source.nodeDocCounts.getCount(dd) + gamma * source.pi)\n                    / (source.subtreeDocCounts.getCount(dd) + gamma);\n            double wordprob = source.getNodeWordProbability(words[dd][nn]);\n            double prob = stayprob * wordprob;\n            if (source.equals(target)) {\n                num = prob;\n            }\n            den += prob;\n        }\n\n        double alpha = getAlpha(level);\n        double passprob = 1.0 - stayprob;\n        int KK = source.getNumChildren();\n        double norm = source.getPassingCount(dd) + alpha * KK;\n        for (Node child : source.getChildren()) {\n            int kk = child.getIndex();\n            double pathprob = (child.subtreeDocCounts.getCount(dd)\n                    + alpha * KK * source.theta[kk]) / norm;\n            double wordprob = child.getSubtreeWordProbability(words[dd][nn]);\n            double prob = passprob * pathprob * wordprob;\n            if (target.equals(child)) {\n                num = prob;\n            }\n            den += prob;\n        }\n        return (num / den);\n    }\n\n    private double getResponseLogLikelihood(int dd, Node node) {\n        double aMean = docMeans[dd] + node.pathEta / this.words[dd].length;\n        double resLLh;\n        if (isBinary) {\n            resLLh = getLabelLogLikelihood(labels[dd], aMean);\n        } else {\n            resLLh = StatUtils.logNormalProbability(responses[dd], aMean, Math.sqrt(rho));\n        }\n        return resLLh;\n    }\n\n    private double getLabelLogLikelihood(int label, double dotProb) {\n        double logNorm = Math.log(Math.exp(dotProb) + 1);\n        if (label == POSITVE) {\n            return dotProb - logNorm;\n        } else {\n            return -logNorm;\n        }\n    }\n\n    /**\n     * Update regression parameters using L-BFGS.\n     *\n     * @return Elapsed time\n     */\n    public long updateEtas() {\n        if (isReporting) {\n            logln(\"+++ Updating eta's ...\");\n        }\n        long sTime = System.currentTimeMillis();\n\n        // list of nodes\n        ArrayList<Node> nodeList = getNodeList();\n        int N = nodeList.size();\n\n        // design matrix\n        SparseVector[] designMatrix = new SparseVector[D];\n        for (int aa = 0; aa < D; aa++) {\n            designMatrix[aa] = new SparseVector(N);\n        }\n\n        for (int kk = 0; kk < N; kk++) {\n            Node node = nodeList.get(kk);\n            if (node.isRoot()) {\n                for (int dd = 0; dd < D; dd++) {\n                    designMatrix[dd].set(kk, 1.0);\n                }\n            } else {\n                for (int dd : node.subtreeDocCounts.getIndices()) {\n                    int count = node.subtreeDocCounts.getCount(dd);\n                    double val = (double) count / this.words[dd].length;\n                    designMatrix[dd].change(kk, val);\n                }\n            }\n        }\n\n        // current params\n        double[] etaArray = new double[N];\n        double[] sigmaArray = new double[N];\n        for (int kk = 0; kk < N; kk++) {\n            etaArray[kk] = nodeList.get(kk).eta;\n            sigmaArray[kk] = getSigma(nodeList.get(kk).getLevel());\n        }\n\n        boolean converged = false;\n        if (isBinary) {\n            RidgeLogisticRegressionOptimizable optimizable = new RidgeLogisticRegressionOptimizable(\n                    labels, etaArray, designMatrix, mu, sigmaArray);\n            LimitedMemoryBFGS optimizer = new LimitedMemoryBFGS(optimizable);\n            try {\n                converged = optimizer.optimize();\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n\n            // update regression parameters\n            for (int kk = 0; kk < N; kk++) {\n                nodeList.get(kk).eta = optimizable.getParameter(kk);\n            }\n        } else {\n            RidgeLinearRegressionOptimizable optimizable = new RidgeLinearRegressionOptimizable(\n                    responses, etaArray, designMatrix, rho, mu, sigmaArray);\n            LimitedMemoryBFGS optimizer = new LimitedMemoryBFGS(optimizable);\n\n            try {\n                converged = optimizer.optimize();\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n\n            // update regression parameters\n            for (int kk = 0; kk < N; kk++) {\n                nodeList.get(kk).eta = optimizable.getParameter(kk);\n            }\n        }\n\n        // update document means\n        for (int dd = 0; dd < D; dd++) {\n            docMeans[dd] = 0.0;\n            for (int kk : designMatrix[dd].getIndices()) {\n                docMeans[dd] += designMatrix[dd].get(kk) * nodeList.get(kk).eta;\n            }\n        }\n\n        // update path thetas\n        updatePathEtas();\n\n        long eTime = System.currentTimeMillis() - sTime;\n        if (isReporting) {\n            logln(\"--- converged? \" + converged\n                    + \". \" + designMatrix.length + \" x \" + nodeList.size());\n            logln(\"--- --- time: \" + eTime);\n            evaluatePerformances();\n        }\n        return eTime;\n    }\n\n    protected void evaluatePerformances() {\n        if (isBinary) {\n            double[] predVals = new double[D];\n            for (int d = 0; d < D; d++) {\n                double expDotProd = Math.exp(docMeans[d]);\n                double docPred = expDotProd / (expDotProd + 1);\n                predVals[d] = docPred;\n            }\n\n            ArrayList<RankingItem<Integer>> rankDocs = new ArrayList<RankingItem<Integer>>();\n            for (int d = 0; d < D; d++) {\n                rankDocs.add(new RankingItem<Integer>(d, predVals[d]));\n            }\n            Collections.sort(rankDocs);\n            int[] preds = new int[D];\n            for (int ii = 0; ii < this.positives.size(); ii++) {\n                int d = rankDocs.get(ii).getObject();\n                preds[d] = POSITVE;\n            }\n\n            ClassificationEvaluation eval = new ClassificationEvaluation(labels, preds);\n            eval.computePRF1();\n            for (Measurement measurement : eval.getMeasurements()) {\n                logln(\"--- --- \" + measurement.getName() + \":\\t\" + measurement.getValue());\n            }\n        } else {\n            RegressionEvaluation eval = new RegressionEvaluation(responses, docMeans);\n            eval.computeCorrelationCoefficient();\n            eval.computeMeanSquareError();\n            eval.computeMeanAbsoluteError();\n            eval.computeRSquared();\n            eval.computePredictiveRSquared();\n            ArrayList<Measurement> measurements = eval.getMeasurements();\n            for (Measurement measurement : measurements) {\n                logln(\"--- --- \" + measurement.getName() + \":\\t\" + measurement.getValue());\n            }\n        }\n    }\n\n    /**\n     * Update the eta sum for each path, which is represented by a node.\n     */\n    private void updatePathEtas() {\n        Queue<Node> queue = new LinkedList<>();\n        queue.add(root);\n        while (!queue.isEmpty()) {\n            Node node = queue.poll();\n\n            node.pathEta = node.eta;\n            if (!node.isRoot()) {\n                node.pathEta += node.getParent().pathEta;\n            }\n\n            for (Node child : node.getChildren()) {\n                queue.add(child);\n            }\n        }\n    }\n\n    /**\n     * Flatten the tree.\n     */\n    private ArrayList<Node> getNodeList() {\n        ArrayList<Node> nodeList = new ArrayList<>();\n        Stack<Node> stack = new Stack<>();\n        stack.add(root);\n        while (!stack.isEmpty()) {\n            Node node = stack.pop();\n            for (Node child : node.getChildren()) {\n                stack.add(child);\n            }\n            nodeList.add(node);\n        }\n        return nodeList;\n    }\n\n    @Override\n    public double getLogLikelihood() {\n        return 0.0;\n    }\n\n    @Override\n    public double getLogLikelihood(ArrayList<Double> newParams) {\n        throw new RuntimeException(\"Currently not supported\");\n    }\n\n    @Override\n    public void updateHyperparameters(ArrayList<Double> newParams) {\n        throw new RuntimeException(\"Currently not supported\");\n    }\n\n    @Override\n    public void validate(String msg) {\n        logln(\"Validating ... \" + msg);\n        Stack<Node> stack = new Stack<>();\n        stack.add(root);\n        while (!stack.isEmpty()) {\n            Node node = stack.pop();\n            for (Node child : node.getChildren()) {\n                stack.add(child);\n            }\n            node.validate(msg);\n        }\n    }\n\n    public void outputState(String filepath, boolean outputModel, boolean outputAssignment) {\n        if (verbose) {\n            logln(\"--- Outputing current state to \" + filepath);\n        }\n\n        StringBuilder modelStr = new StringBuilder();\n        if (outputModel) {\n            Stack<Node> stack = new Stack<>();\n            stack.add(root);\n            while (!stack.isEmpty()) {\n                Node node = stack.pop();\n                modelStr.append(Integer.toString(node.born)).append(\"\\n\");\n                modelStr.append(node.getPathString()).append(\"\\n\");\n                modelStr.append(node.eta).append(\"\\n\");\n                modelStr.append(node.pi).append(\"\\n\");\n                if (node.theta != null) {\n                    modelStr.append(MiscUtils.arrayToString(node.theta));\n                }\n                modelStr.append(\"\\n\");\n                modelStr.append(DirMult.output(node.getContent())).append(\"\\n\");\n                modelStr.append(SparseCount.output(node.subtreeWordCounts)).append(\"\\n\");\n                for (Node child : node.getChildren()) {\n                    stack.add(child);\n                }\n            }\n        }\n\n        StringBuilder assignStr = new StringBuilder();\n        if (outputAssignment) {\n            for (int dd = 0; dd < z.length; dd++) {\n                for (int nn = 0; nn < z[dd].length; nn++) {\n                    assignStr.append(dd)\n                            .append(\"\\t\").append(nn)\n                            .append(\"\\t\").append(z[dd][nn].getPathString()).append(\"\\n\");\n                }\n            }\n        }\n\n        try { // output to a compressed file\n            ArrayList<String> contentStrs = new ArrayList<>();\n            contentStrs.add(modelStr.toString());\n            contentStrs.add(assignStr.toString());\n\n            String filename = IOUtils.removeExtension(IOUtils.getFilename(filepath));\n            ArrayList<String> entryFiles = new ArrayList<>();\n            entryFiles.add(filename + ModelFileExt);\n            entryFiles.add(filename + AssignmentFileExt);\n\n            this.outputZipFile(filepath, contentStrs, entryFiles);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"Exception while outputing to \" + filepath);\n        }\n    }\n\n    @Override\n    public void outputState(String filepath) {\n        if (verbose) {\n            logln(\"--- Outputing current state to \" + filepath);\n        }\n        outputState(filepath, true, true);\n    }\n\n    @Override\n    public void inputState(String filepath) {\n        if (verbose) {\n            logln(\"--- Reading state from \" + filepath);\n        }\n        try {\n            inputModel(filepath);\n            inputAssignments(filepath);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"Exception while inputing from \" + filepath);\n        }\n    }\n\n    public void inputModel(String zipFilepath) {\n        if (verbose) {\n            logln(\"--- --- Loading model from \" + zipFilepath);\n        }\n        try {\n            String filename = IOUtils.removeExtension(IOUtils.getFilename(zipFilepath));\n            BufferedReader reader = IOUtils.getBufferedReader(zipFilepath, filename + ModelFileExt);\n            HashMap<String, Node> nodeMap = new HashMap<String, Node>();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                int born = Integer.parseInt(line);\n                String pathStr = reader.readLine();\n                double eta = Double.parseDouble(reader.readLine());\n                double pi = Double.parseDouble(reader.readLine());\n                line = reader.readLine().trim();\n                double[] theta = null;\n                if (!line.isEmpty()) {\n                    theta = MiscUtils.stringToDoubleArray(line);\n                }\n                DirMult topic = DirMult.input(reader.readLine());\n                SparseCount subtreeWordCounts = SparseCount.input(reader.readLine());\n\n                // create node\n                int lastColonIndex = pathStr.lastIndexOf(\":\");\n                Node parent = null;\n                if (lastColonIndex != -1) {\n                    parent = nodeMap.get(pathStr.substring(0, lastColonIndex));\n                }\n                String[] pathIndices = pathStr.split(\":\");\n                int nodeIndex = Integer.parseInt(pathIndices[pathIndices.length - 1]);\n                int nodeLevel = pathIndices.length - 1;\n\n                Node node = new Node(born, nodeIndex, nodeLevel, topic, parent, eta);\n                node.pi = pi;\n                node.theta = theta;\n                node.subtreeWordCounts = subtreeWordCounts;\n\n                if (node.getLevel() == 0) {\n                    root = node;\n                }\n                if (parent != null) {\n                    parent.addChild(node.getIndex(), node);\n                }\n                nodeMap.put(pathStr, node);\n            }\n\n            updatePathEtas();\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"Exception while loading model from \"\n                    + zipFilepath);\n        }\n    }\n\n    /**\n     * Input a set of assignments.\n     *\n     * @param zipFilepath Compressed learned state file\n     */\n    public void inputAssignments(String zipFilepath) {\n        if (verbose) {\n            logln(\"--- --- Loading assignments from \" + zipFilepath);\n        }\n        try {\n            z = new Node[D][];\n            for (int d = 0; d < D; d++) {\n                z[d] = new Node[words[d].length];\n            }\n\n            String filename = IOUtils.removeExtension(IOUtils.getFilename(zipFilepath));\n            BufferedReader reader = IOUtils.getBufferedReader(zipFilepath, filename + AssignmentFileExt);\n            for (int dd = 0; dd < z.length; dd++) {\n                for (int nn = 0; nn < z[dd].length; nn++) {\n                    String[] sline = reader.readLine().split(\"\\t\");\n                    if (dd != Integer.parseInt(sline[0])) {\n                        throw new MismatchRuntimeException(Integer.parseInt(sline[0]), dd);\n                    }\n                    if (nn != Integer.parseInt(sline[1])) {\n                        throw new MismatchRuntimeException(Integer.parseInt(sline[1]), nn);\n                    }\n                    String pathStr = sline[2];\n                    z[dd][nn] = getNode(pathStr);\n                    addToken(dd, nn, z[dd][nn], ADD, ADD);\n                }\n            }\n\n            reader.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"Exception while loading assignments from \"\n                    + zipFilepath);\n        }\n    }\n\n    /**\n     * Parse the node path string.\n     *\n     * @param nodePath The node path string\n     * @return\n     */\n    public int[] parseNodePath(String nodePath) {\n        String[] ss = nodePath.split(\":\");\n        int[] parsedPath = new int[ss.length];\n        for (int i = 0; i < ss.length; i++) {\n            parsedPath[i] = Integer.parseInt(ss[i]);\n        }\n        return parsedPath;\n    }\n\n    /**\n     * Get a node in the tree given a parsed path\n     *\n     * @param parsedPath The parsed path\n     */\n    private Node getNode(int[] parsedPath) {\n        Node node = root;\n        for (int i = 1; i < parsedPath.length; i++) {\n            node = node.getChild(parsedPath[i]);\n        }\n        return node;\n    }\n\n    /**\n     * Get a node in the tree given its path.\n     *\n     * @param pathStr\n     */\n    private Node getNode(String pathStr) {\n        return getNode(parseNodePath(pathStr));\n    }\n\n    /**\n     * Summary of the current tree.\n     *\n     * @return Summary of the current tree\n     */\n    public String printGlobalTreeSummary() {\n        StringBuilder str = new StringBuilder();\n        SparseCount nodeCountPerLevel = new SparseCount();\n        SparseCount obsCountPerLevel = new SparseCount();\n        SparseCount subtreeObsCountPerLvl = new SparseCount();\n\n        Stack<Node> stack = new Stack<Node>();\n        stack.add(root);\n\n        int totalObs = 0;\n        while (!stack.isEmpty()) {\n            Node node = stack.pop();\n            for (Node child : node.getChildren()) {\n                stack.add(child);\n            }\n            if (node.isEmpty()) {\n                continue;\n            }\n\n            int level = node.getLevel();\n            nodeCountPerLevel.increment(level);\n            obsCountPerLevel.changeCount(level, node.nodeDocCounts.getCountSum());\n            subtreeObsCountPerLvl.changeCount(level, node.subtreeDocCounts.getCountSum());\n            totalObs += node.nodeDocCounts.getCountSum();\n        }\n        str.append(\"global tree:\\n\\t>>> node count per level:\\n\");\n        for (int l : nodeCountPerLevel.getSortedIndices()) {\n            int obsCount = obsCountPerLevel.getCount(l);\n            int subtreeObsCount = subtreeObsCountPerLvl.getCount(l);\n            int nodeCount = nodeCountPerLevel.getCount(l);\n            str.append(\"\\t>>> >>> \").append(l)\n                    .append(\" [\")\n                    .append(nodeCount)\n                    .append(\"] [\").append(obsCount)\n                    .append(\", \").append(MiscUtils.formatDouble((double) obsCount / nodeCount))\n                    .append(\", \").append(MiscUtils.formatDouble((double) 100 * obsCount / numTokens)).append(\"%\")\n                    .append(\"] [\").append(subtreeObsCount)\n                    .append(\", \").append(MiscUtils.formatDouble((double) subtreeObsCount / nodeCount))\n                    .append(\", \").append(MiscUtils.formatDouble((double) 100 * subtreeObsCount / numTokens)).append(\"%\")\n                    .append(\"]\\n\");\n        }\n        str.append(\"\\n\");\n        str.append(\"\\t>>> # observations = \").append(totalObs).append(\"\\n\");\n        str.append(\"\\t>>> # nodes = \").append(nodeCountPerLevel.getCountSum()).append(\"\\n\");\n        return str.toString();\n    }\n\n    /**\n     * The current tree.\n     *\n     * @return The current tree\n     */\n    public String printGlobalTree() {\n        SparseCount nodeCountPerLvl = new SparseCount();\n        SparseCount obsCountPerLvl = new SparseCount();\n        SparseCount subtreeObsCountPerLvl = new SparseCount();\n        int totalNumObs = 0;\n        int numWords = 10;\n\n        StringBuilder str = new StringBuilder();\n        str.append(\"global tree\\n\");\n\n        Stack<Node> stack = new Stack<Node>();\n        stack.add(root);\n        while (!stack.isEmpty()) {\n            Node node = stack.pop();\n            String indentation = node.getIndentation();\n\n            ArrayList<RankingItem<Node>> rankChildren = new ArrayList<RankingItem<Node>>();\n            for (Node child : node.getChildren()) {\n                rankChildren.add(new RankingItem<Node>(child, child.eta));\n            }\n            Collections.sort(rankChildren);\n            for (RankingItem<Node> item : rankChildren) {\n                stack.add(item.getObject());\n            }\n\n            // top words according to the distribution\n            str.append(indentation);\n            str.append(node.getPathString())\n                    .append(\" (\").append(node.born)\n                    .append(\"; \").append(node.getContent().getCountSum())\n                    .append(\"; \").append(MiscUtils.formatDouble(node.eta))\n                    .append(\"; \").append(MiscUtils.formatDouble(node.pathEta))\n                    .append(\")\");\n            str.append(\"\\n\");\n\n            if (!node.isEmpty()) {\n                // words with highest probabilities at subtree\n                if (node.getLevel() < L - 1) {\n                    String[] subtreeTopWords = node.getSubtreeTopWords(numWords);\n                    str.append(indentation).append(\"@ subtree: \");\n                    for (String topWord : subtreeTopWords) {\n                        str.append(\" \").append(topWord);\n                    }\n                    str.append(\"\\n\");\n                }\n\n                // words with highest probabilities at node\n                String[] nodeTopWords = node.getNodeTopWords(numWords);\n                str.append(indentation).append(\"@ node: \");\n                for (String topWord : nodeTopWords) {\n                    str.append(\" \").append(topWord);\n                }\n                str.append(\"\\n\");\n\n                // top assigned words\n                str.append(indentation);\n                str.append(node.getTopObservations()).append(\"\\n\\n\");\n\n                int level = node.getLevel();\n                nodeCountPerLvl.increment(level);\n                obsCountPerLvl.changeCount(level, node.nodeDocCounts.getCountSum());\n                subtreeObsCountPerLvl.changeCount(level, node.subtreeDocCounts.getCountSum());\n                totalNumObs += node.getContent().getCountSum();\n            }\n\n        }\n        str.append(\"Tree summary\").append(\"\\n\");\n        for (int l : nodeCountPerLvl.getSortedIndices()) {\n            int obsCount = obsCountPerLvl.getCount(l);\n            int subtreeObsCount = subtreeObsCountPerLvl.getCount(l);\n            int nodeCount = nodeCountPerLvl.getCount(l);\n            str.append(\"\\t>>> \").append(l)\n                    .append(\" [\")\n                    .append(nodeCount)\n                    .append(\"] [\").append(obsCount)\n                    .append(\", \").append(MiscUtils.formatDouble((double) obsCount / nodeCount))\n                    .append(\", \").append(MiscUtils.formatDouble((double) 100 * obsCount / numTokens)).append(\"%\")\n                    .append(\"] [\").append(subtreeObsCount)\n                    .append(\", \").append(MiscUtils.formatDouble((double) subtreeObsCount / nodeCount))\n                    .append(\", \").append(MiscUtils.formatDouble((double) 100 * subtreeObsCount / numTokens)).append(\"%\")\n                    .append(\"]\\n\");\n        }\n        str.append(\"\\t>>> # observations = \").append(totalNumObs).append(\"\\n\");\n        str.append(\"\\t>>> # nodes = \").append(nodeCountPerLvl.getCountSum()).append(\"\\n\");\n        return str.toString();\n    }\n\n    /**\n     * Output top words for each topic in the tree to text file.\n     *\n     * @param outputFile The output file\n     * @param numWords Number of top words\n     */\n    @Override\n    public void outputTopicTopWords(File outputFile, int numWords) {\n        if (this.wordVocab == null) {\n            throw new RuntimeException(\"The word vocab has not been assigned yet\");\n        }\n\n        if (verbose) {\n            logln(\"Outputing top words to file \" + outputFile);\n        }\n\n        StringBuilder str = new StringBuilder();\n        Stack<Node> stack = new Stack<Node>();\n        stack.add(root);\n        while (!stack.isEmpty()) {\n            Node node = stack.pop();\n            String indentation = node.getIndentation();\n\n            ArrayList<RankingItem<Node>> rankChildren = new ArrayList<RankingItem<Node>>();\n            for (Node child : node.getChildren()) {\n                rankChildren.add(new RankingItem<Node>(child, child.eta));\n            }\n            Collections.sort(rankChildren);\n            for (RankingItem<Node> item : rankChildren) {\n                stack.add(item.getObject());\n            }\n\n            // top words according to the distribution\n            str.append(indentation);\n            str.append(node.getPathString())\n                    .append(\" (\")\n                    .append(node.born).append(\"; \")\n                    .append(node.getContent().getCountSum()).append(\"; \")\n                    //.append(MiscUtils.formatDouble(node.eta)).append(\"; eta: \")\n                    .append(MiscUtils.formatDouble(node.pathEta))\n                    .append(\")\");\n            str.append(\" \");\n\n            if (!node.isEmpty()) {\n                // words with highest probabilities at subtree\n                if (node.getLevel() < L - 1) {\n                    String[] subtreeTopWords = node.getSubtreeTopWords(numWords);\n//                    str.append(indentation);\n                    for (String topWord : subtreeTopWords) {\n                        str.append(topWord).append(\" \");\n                    }\n                    str.append(\"\\n\");\n                } else { // words with highest probabilities at node\n                    String[] nodeTopWords = node.getNodeTopWords(numWords);\n//                    str.append(indentation);\n                    for (String topWord : nodeTopWords) {\n                        str.append(topWord).append(\" \");\n                    }\n                    str.append(\"\\n\");\n                }\n\n                // top assigned words\n//                str.append(indentation);\n//                str.append(node.getTopObservations()).append(\"\\n\\n\");\n            }\n            str.append(\"\\n\");\n        }\n\n        try {\n            BufferedWriter writer = IOUtils.getBufferedWriter(outputFile);\n            writer.write(str.toString());\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"Exception while outputing topics \"\n                    + outputFile);\n        }\n    }\n\n    /**\n     * Output posterior distribution over non-rooted nodes in the tree of all\n     * documents.\n     *\n     * @param outputFile Output file\n     */\n    public void outputNodePosteriors(File outputFile) {\n        ArrayList<Node> nodeList = getNodeList();\n        try {\n            BufferedWriter writer = IOUtils.getBufferedWriter(outputFile);\n            for (int dd = 0; dd < D; dd++) {\n                double[] nodePos = new double[nodeList.size()];\n                for (int kk = 0; kk < nodeList.size(); kk++) {\n                    Node node = nodeList.get(kk);\n                    nodePos[kk] = (double) node.nodeDocCounts.getCount(dd) / words[dd].length;\n                }\n                writer.write(Integer.toString(dd));\n                for (int kk = 0; kk < nodePos.length; kk++) {\n                    writer.write(\"\\t\" + nodePos[kk]);\n                }\n                writer.write(\"\\n\");\n            }\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"Exception while output to \" + outputFile);\n        }\n    }\n\n    class Node extends TreeNode<Node, DirMult> {\n\n        protected final int born;\n        protected SparseCount subtreeDocCounts;\n        protected SparseCount nodeDocCounts;\n        protected double[] theta;\n        protected double pi;\n        protected double eta;\n        protected double pathEta;\n        protected SparseCount subtreeWordCounts;\n\n        public Node(int iter, int index, int level, DirMult content, Node parent,\n                double eta) {\n            super(index, level, content, parent);\n            this.born = iter;\n            this.subtreeDocCounts = new SparseCount();\n            this.nodeDocCounts = new SparseCount();\n            this.eta = eta;\n            this.subtreeWordCounts = new SparseCount();\n        }\n\n        void incrementSubtreeWordCount(int vv) {\n            subtreeWordCounts.increment(vv); // currently only for maximal assumption\n        }\n\n        void decrementSubtreeWordCount(int vv) {\n            subtreeWordCounts.decrement(vv); // currently only for maximal assumption\n        }\n\n        double getNodeWordProbability(int vv) {\n            return this.content.getProbability(vv);\n        }\n\n        double getSubtreeWordProbability(int vv) {\n            return (content.getCount(vv) + subtreeWordCounts.getCount(vv)\n                    + content.getConcentration() * content.getCenterElement(vv))\n                    / (content.getCountSum() + subtreeWordCounts.getCountSum()\n                    + content.getConcentration());\n        }\n\n        void setPathEta(double pathEta) {\n            this.pathEta = pathEta;\n        }\n\n        void initializeGlobalPi() {\n            this.pi = getPi(level);\n        }\n\n        void initializeGlobalTheta() {\n            int KK = getNumChildren();\n            this.theta = new double[KK];\n            Arrays.fill(this.theta, 1.0 / KK);\n        }\n\n        /**\n         * Return the number of tokens of a given document which are assigned to\n         * any nodes below this node.\n         *\n         * @param dd Document index\n         */\n        int getPassingCount(int dd) {\n            return subtreeDocCounts.getCount(dd) - nodeDocCounts.getCount(dd);\n        }\n\n        boolean isEmpty() {\n            return this.getContent().isEmpty();\n        }\n\n        String[] getNodeTopWords(int numTopWords) {\n            double[] phi = new double[V];\n            for (int vv = 0; vv < V; vv++) {\n                phi[vv] = getNodeWordProbability(vv);\n            }\n            ArrayList<RankingItem<String>> topicSortedVocab\n                    = IOUtils.getSortedVocab(phi, wordVocab);\n            String[] topWords = new String[numTopWords];\n            for (int i = 0; i < numTopWords; i++) {\n                topWords[i] = topicSortedVocab.get(i).getObject();\n            }\n            return topWords;\n        }\n\n        String[] getSubtreeTopWords(int numTopWords) {\n            double[] phi = new double[V];\n            for (int vv = 0; vv < V; vv++) {\n                phi[vv] = getSubtreeWordProbability(vv);\n            }\n            ArrayList<RankingItem<String>> topicSortedVocab\n                    = IOUtils.getSortedVocab(phi, wordVocab);\n            String[] topWords = new String[numTopWords];\n            for (int i = 0; i < numTopWords; i++) {\n                topWords[i] = topicSortedVocab.get(i).getObject();\n            }\n            return topWords;\n        }\n\n        String getTopObservations() {\n            return getTopObservations(getContent().getSparseCounts());\n        }\n\n        String getTopObservations(SparseCount counts) {\n            ArrayList<RankingItem<Integer>> rankObs = new ArrayList<RankingItem<Integer>>();\n            for (int obs : counts.getIndices()) {\n                rankObs.add(new RankingItem<Integer>(obs, counts.getCount(obs)));\n            }\n            Collections.sort(rankObs);\n            StringBuilder str = new StringBuilder();\n            for (int ii = 0; ii < Math.min(10, rankObs.size()); ii++) {\n                RankingItem<Integer> obs = rankObs.get(ii);\n                str.append(wordVocab.get(obs.getObject())).append(\":\")\n                        .append(obs.getPrimaryValue()).append(\" \");\n            }\n            return str.toString();\n        }\n\n        void validate(String msg) {\n            this.nodeDocCounts.validate(msg);\n            this.subtreeDocCounts.validate(msg);\n            if (theta != null && theta.length != getNumChildren()) {\n                throw new RuntimeException(msg + \". MISMATCH. \" + this.toString());\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder str = new StringBuilder();\n            str.append(\"[\").append(getPathString());\n            str.append(\", \").append(born);\n            str.append(\", c (\").append(getChildren().size()).append(\")\");\n            // word types\n            str.append(\", (\").append(getContent().getCountSum()).append(\")\");\n            // token counts\n            str.append(\", (\").append(subtreeDocCounts.getCountSum());\n            str.append(\", \").append(nodeDocCounts.getCountSum()).append(\")\");\n            str.append(\", \").append(MiscUtils.formatDouble(eta));\n            str.append(\", \").append(MiscUtils.formatDouble(pathEta));\n            str.append(\"]\");\n            return str.toString();\n        }\n\n        String getIndentation() {\n            StringBuilder str = new StringBuilder();\n            for (int i = 0; i < this.getLevel(); i++) {\n                str.append(\"\\t\");\n            }\n            return str.toString();\n        }\n    }\n\n    public static String getHelpString() {\n        return \"java -cp 'dist/segan.jar' \" + SNLDA.class.getName() + \" -help\";\n    }\n\n    public static String getExampleCmd() {\n        String example = new String();\n        return example;\n    }\n\n    private static void addOpitions() throws Exception {\n        parser = new BasicParser();\n        options = new Options();\n\n        // data input\n        addOption(\"dataset\", \"Dataset\");\n        addOption(\"word-voc-file\", \"Word vocabulary file\");\n        addOption(\"word-file\", \"Document word file\");\n        addOption(\"info-file\", \"Document info file\");\n        addOption(\"selected-docs-file\", \"(Optional) Indices of selected documents\");\n        addOption(\"prior-topic-file\", \"File containing prior topics\");\n        addOption(\"init-eta-file\", \"File containing initial etas\");\n        addOption(\"num-top-words\", \"Number of top words per topic\");\n\n        // data output\n        addOption(\"output-folder\", \"Output folder\");\n\n        // sampling\n        addSamplingOptions();\n\n        // parameters\n        addOption(\"alphas\", \"Alpha\");\n        addOption(\"betas\", \"Beta\");\n        addOption(\"pis\", \"Mean\");\n        addOption(\"gammas\", \"Scale\");\n        addOption(\"rho\", \"Rho\");\n        addOption(\"mu\", \"Mu\");\n        addOption(\"sigmas\", \"Sigmas\");\n        addOption(\"Ks\", \"Number of topics\");\n        addOption(\"path\", \"Path assumption\");\n\n        // configurations\n        addOption(\"init\", \"Initialization\");\n\n        options.addOption(\"train\", false, \"train\");\n        options.addOption(\"test\", false, \"test\");\n        options.addOption(\"parallel\", false, \"parallel\");\n\n        options.addOption(\"v\", false, \"verbose\");\n        options.addOption(\"d\", false, \"debug\");\n        options.addOption(\"z\", false, \"z-normalize\");\n        options.addOption(\"help\", false, \"Help\");\n        options.addOption(\"example\", false, \"Example command\");\n        options.addOption(\"binary\", false, \"Binary responses\");\n        options.addOption(\"root\", false, \"Is rooted\");\n    }\n\n    private static void runModel() throws Exception {\n        // sampling configurations\n        int numTopWords = CLIUtils.getIntegerArgument(cmd, \"num-top-words\", 20);\n        int burnIn = CLIUtils.getIntegerArgument(cmd, \"burnIn\", 500);\n        int maxIters = CLIUtils.getIntegerArgument(cmd, \"maxIter\", 1000);\n        int sampleLag = CLIUtils.getIntegerArgument(cmd, \"sampleLag\", 50);\n        int repInterval = CLIUtils.getIntegerArgument(cmd, \"report\", 25);\n        boolean paramOpt = cmd.hasOption(\"paramOpt\");\n        String init = CLIUtils.getStringArgument(cmd, \"init\", \"random\");\n        InitialState initState;\n        switch (init) {\n            case \"random\":\n                initState = InitialState.RANDOM;\n                break;\n            case \"preset\":\n                initState = InitialState.PRESET;\n                break;\n            default:\n                throw new RuntimeException(\"Initialization \" + init + \" not supported\");\n        }\n\n        // model parameters\n        int[] Ks = CLIUtils.getIntArrayArgument(cmd, \"Ks\", new int[]{15, 4}, \",\");\n        int L = Ks.length + 1;\n\n        double[] alphas = CLIUtils.getDoubleArrayArgument(cmd, \"alphas\", new double[]{2.0, 1.0}, \",\");\n        double[] betas = CLIUtils.getDoubleArrayArgument(cmd, \"betas\", new double[]{0.5, 0.25, 0.1}, \",\");\n        double[] pis = CLIUtils.getDoubleArrayArgument(cmd, \"pis\", new double[]{0.2, 0.2}, \",\");\n        double[] gammas = CLIUtils.getDoubleArrayArgument(cmd, \"gammas\", new double[]{100, 10}, \",\");\n        double rho = CLIUtils.getDoubleArgument(cmd, \"rho\", 1.0);\n        double mu = CLIUtils.getDoubleArgument(cmd, \"mu\", 0.0);\n        double[] sigmas = CLIUtils.getDoubleArrayArgument(cmd, \"sigmas\", new double[]{0.5, 2.5}, \",\");\n        String path = CLIUtils.getStringArgument(cmd, \"path\", \"none\");\n        PathAssumption pathAssumption = getPathAssumption(path);\n\n        // data input\n        String datasetName = cmd.getOptionValue(\"dataset\");\n        String wordVocFile = cmd.getOptionValue(\"word-voc-file\");\n        String docWordFile = cmd.getOptionValue(\"word-file\");\n\n        // data output\n        String outputFolder = cmd.getOptionValue(\"output-folder\");\n\n        double[][] priorTopics = null;\n        if (cmd.hasOption(\"prior-topic-file\")) {\n            String priorTopicFile = cmd.getOptionValue(\"prior-topic-file\");\n            priorTopics = IOUtils.input2DArray(new File(priorTopicFile));\n        }\n\n        double[] initEtas = null;\n        if (cmd.hasOption(\"init-eta-file\")) {\n            String initEtaFile = cmd.getOptionValue(\"init-eta-file\");\n            initEtas = IOUtils.inputArray(new File(initEtaFile));\n        }\n\n        File docInfoFile = null;\n        if (cmd.hasOption(\"info-file\")) {\n            docInfoFile = new File(cmd.getOptionValue(\"info-file\"));\n        }\n\n        SNLDA sampler = new SNLDA();\n        sampler.setVerbose(cmd.hasOption(\"v\"));\n        sampler.setDebug(cmd.hasOption(\"d\"));\n        sampler.setLog(true);\n        sampler.setReport(true);\n\n        boolean isBinary = cmd.hasOption(\"binary\");\n        boolean isRooted = cmd.hasOption(\"root\");\n        ResponseTextDataset contData = new ResponseTextDataset(datasetName);\n        LabelTextDataset binData = new LabelTextDataset(datasetName);\n        int V;\n        if (isBinary) {\n            binData.loadFormattedData(new File(wordVocFile),\n                    new File(docWordFile),\n                    docInfoFile,\n                    null);\n            V = binData.getWordVocab().size();\n            sampler.setWordVocab(binData.getWordVocab());\n            sampler.configureBinary(outputFolder, V, Ks,\n                    alphas, betas, pis, gammas, mu, sigmas,\n                    initState, pathAssumption, paramOpt, isRooted,\n                    burnIn, maxIters, sampleLag, repInterval);\n        } else {\n            contData.loadFormattedData(new File(wordVocFile),\n                    new File(docWordFile),\n                    docInfoFile,\n                    null);\n            V = contData.getWordVocab().size();\n            sampler.setWordVocab(contData.getWordVocab());\n            sampler.configureContinuous(outputFolder, V, Ks,\n                    alphas, betas, pis, gammas, rho, mu, sigmas,\n                    initState, pathAssumption, paramOpt, isRooted,\n                    burnIn, maxIters, sampleLag, repInterval);\n        }\n\n        File samplerFolder = new File(sampler.getSamplerFolderPath());\n        IOUtils.createFolder(samplerFolder);\n\n        if (isTraining()) {\n            ArrayList<Integer> trainDocIndices;\n            if (isBinary) {\n                trainDocIndices = sampler.getSelectedDocIndices(binData.getDocIds());\n                sampler.train(binData.getWords(), trainDocIndices, binData.getSingleLabels());\n            } else {\n                trainDocIndices = sampler.getSelectedDocIndices(contData.getDocIds());\n                double[] docResponses = contData.getResponses();\n                if (cmd.hasOption(\"z\")) { // z-normalization\n                    ZNormalizer zNorm = new ZNormalizer(docResponses);\n                    docResponses = zNorm.normalize(docResponses);\n                }\n                sampler.train(contData.getWords(), trainDocIndices, docResponses);\n            }\n\n            sampler.initialize(priorTopics, initEtas);\n            sampler.metaIterate();\n            sampler.outputTopicTopWords(new File(samplerFolder, TopWordFile), numTopWords);\n            sampler.outputNodePosteriors(new File(samplerFolder, \"train-node-posteriors.txt\"));\n        }\n\n        if (isTesting()) {\n            int[][] testWords;\n            ArrayList<Integer> testDocIndices;\n            if (isBinary) {\n                testWords = binData.getWords();\n                testDocIndices = sampler.getSelectedDocIndices(binData.getDocIds());\n\n            } else {\n                testWords = contData.getWords();\n                testDocIndices = sampler.getSelectedDocIndices(contData.getDocIds());\n            }\n\n            File testAssignmentFolder = new File(samplerFolder, AbstractSampler.IterAssignmentFolder);\n            IOUtils.createFolder(testAssignmentFolder);\n\n            File testPredFolder = new File(samplerFolder, AbstractSampler.IterPredictionFolder);\n            IOUtils.createFolder(testPredFolder);\n\n            double[] predictions;\n            if (cmd.hasOption(\"parallel\")) { // using multiple stored models\n                predictions = SNLDA.parallelTest(testWords, testDocIndices, testPredFolder, testAssignmentFolder, sampler);\n            } else { // using the last model\n                File stateFile = sampler.getFinalStateFile();\n                File outputPredFile = new File(testPredFolder, \"iter-\" + sampler.MAX_ITER + \".txt\");\n                File outputStateFile = new File(testPredFolder, \"iter-\" + sampler.MAX_ITER + \".zip\");\n                sampler.test(testWords, testDocIndices);\n                predictions = sampler.sampleTest(stateFile, outputStateFile, outputPredFile);\n                sampler.outputNodePosteriors(new File(samplerFolder, \"test-node-posteriors.txt\"));\n            }\n\n            File teResultFolder = new File(samplerFolder,\n                    AbstractExperiment.TEST_PREFIX + AbstractExperiment.RESULT_FOLDER);\n            IOUtils.createFolder(teResultFolder);\n\n            if (isBinary) {\n                PredictionUtils.outputClassificationPredictions(\n                        new File(teResultFolder, AbstractExperiment.PREDICTION_FILE),\n                        binData.getDocIds(), binData.getSingleLabels(), predictions);\n                PredictionUtils.outputBinaryClassificationResults(\n                        new File(teResultFolder, AbstractExperiment.RESULT_FILE),\n                        binData.getSingleLabels(), predictions);\n            } else {\n                double[] docResponses = contData.getResponses();\n                if (cmd.hasOption(\"z\")) { // z-normalization\n                    ZNormalizer zNorm = new ZNormalizer(docResponses);\n                    docResponses = zNorm.normalize(docResponses);\n                }\n                PredictionUtils.outputRegressionPredictions(\n                        new File(teResultFolder, AbstractExperiment.PREDICTION_FILE),\n                        contData.getDocIds(), docResponses, predictions);\n                PredictionUtils.outputRegressionResults(\n                        new File(teResultFolder, AbstractExperiment.RESULT_FILE), docResponses,\n                        predictions);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            long sTime = System.currentTimeMillis();\n\n            addOpitions();\n\n            cmd = parser.parse(options, args);\n            if (cmd.hasOption(\"help\")) {\n                CLIUtils.printHelp(getHelpString(), options);\n                return;\n            } else if (cmd.hasOption(\"example\")) {\n                System.out.println(getExampleCmd());\n                return;\n            }\n\n            runModel();\n\n            // date and time\n            DateFormat df = new SimpleDateFormat(\"dd/MM/yy HH:mm:ss\");\n            Date dateobj = new Date();\n            long eTime = (System.currentTimeMillis() - sTime) / 1000;\n            System.out.println(\"Elapsed time: \" + eTime + \"s\");\n            System.out.println(\"End time: \" + df.format(dateobj));\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException();\n        }\n    }\n\n    /**\n     * Run Gibbs sampling on test data using multiple models learned which are\n     * stored in the ReportFolder. The runs on multiple models are parallel.\n     *\n     * @param newWords Words of new documents\n     * @param newDocIndices Indices of test documents\n     * @param iterPredFolder Output folder\n     * @param iterStateFolder Folder to store assignments\n     * @param sampler The configured sampler\n     */\n    public static double[] parallelTest(int[][] newWords,\n            ArrayList<Integer> newDocIndices,\n            File iterPredFolder,\n            File iterStateFolder,\n            SNLDA sampler) {\n        File reportFolder = new File(sampler.getSamplerFolderPath(), ReportFolder);\n        if (!reportFolder.exists()) {\n            throw new RuntimeException(\"Report folder not found. \" + reportFolder);\n        }\n        String[] filenames = reportFolder.list();\n        double[] avgPredictions = null;\n        try {\n            IOUtils.createFolder(iterPredFolder);\n            ArrayList<Thread> threads = new ArrayList<Thread>();\n            ArrayList<File> partPredFiles = new ArrayList<>();\n            for (String filename : filenames) { // all learned models\n                if (!filename.contains(\"zip\")) {\n                    continue;\n                }\n\n                File stateFile = new File(reportFolder, filename);\n\n                String stateFilename = IOUtils.removeExtension(filename);\n                File iterOutputPredFile = new File(iterPredFolder, stateFilename + \".txt\");\n                File iterOutputStateFile = new File(iterStateFolder, stateFilename + \".zip\");\n\n                SNLDATestRunner runner = new SNLDATestRunner(sampler,\n                        newWords, newDocIndices,\n                        stateFile.getAbsolutePath(),\n                        iterOutputStateFile.getAbsolutePath(),\n                        iterOutputPredFile.getAbsolutePath());\n                Thread thread = new Thread(runner);\n                threads.add(thread);\n                partPredFiles.add(iterOutputPredFile);\n            }\n\n            // run MAX_NUM_PARALLEL_THREADS threads at a time\n            runThreads(threads);\n\n            // average predictions\n            avgPredictions = PredictionUtils.computeMultipleAverage(partPredFiles);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"Exception while sampling during parallel test.\");\n        }\n        return avgPredictions;\n    }\n}", "class_id": 0, "repo": "vietansegan/segan", "file": "src/sampler/supervised/regression/SNLDA.java", "last_update_at": "2020-06-22T11:45:53+00:00", "question_id": "a2aa1bfff4593de1db593dbc940d34ada2d14567", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SNLDA extends AbstractSampler {\n    public static final int POSITVE = 1;\n    public static final int NEGATIVE = -1;\n    // hyperparameters for fixed-height tree\n    protected double[] alphas;          // [L-1]\n    protected double[] betas;           // [L]\n    protected double[] pis;     // [L-1] mean of bias coins\n    protected double[] gammas;    // [L-1] scale of bias coins\n    protected double rho;\n    protected double mu;\n    protected double[] sigmas;\n    // inputs\n    protected int[][] words; // all words\n    protected double[] responses; // [D] continous responses\n    protected int[] labels; // [D] binary responses\n    protected ArrayList<Integer> docIndices; // indices of docs under consideration\n    protected int V;    // vocabulary size\n    protected int[] Ks; // [L-1]: number of children per node at each level\n    protected PathAssumption path;\n    // derived\n    protected int D; // number of documents\n    protected int L;\n    // latent\n    Node[][] z;\n    Node root;\n    // internal\n    private int numTokensAccepted;\n    private double[] docMeans;\n    private boolean isBinary;\n    private Set<Integer> positives;\n    private double uniform;\n    private boolean isRooted;\n    // cached probabilities computed at the first level\n    private HashMap<Node, Double> cachedProbabilities;\n    public SNLDA() {\n        this.basename = \"SNLDA\";\n    }\n    public SNLDA(String bname) {\n        this.basename = bname;\n    }\n    public void configure(SNLDA sampler) {\n        this.isBinary = sampler.isBinary;\n        if (this.isBinary) {\n            this.configureBinary(sampler.folder,\n                    sampler.V,\n                    sampler.Ks,\n                    sampler.alphas,\n                    sampler.betas,\n                    sampler.pis,\n                    sampler.gammas,\n                    sampler.mu,\n                    sampler.sigmas,\n                    sampler.initState,\n                    sampler.path,\n                    sampler.paramOptimized,\n                    sampler.isRooted,\n                    sampler.BURN_IN,\n                    sampler.MAX_ITER,\n                    sampler.LAG,\n                    sampler.REP_INTERVAL);\n        } else {\n            this.configureContinuous(sampler.folder,\n                    sampler.V,\n                    sampler.Ks,\n                    sampler.alphas,\n                    sampler.betas,\n                    sampler.pis,\n                    sampler.gammas,\n                    sampler.rho,\n                    sampler.mu,\n                    sampler.sigmas,\n                    sampler.initState,\n                    sampler.path,\n                    sampler.paramOptimized,\n                    sampler.isRooted,\n                    sampler.BURN_IN,\n                    sampler.MAX_ITER,\n                    sampler.LAG,\n                    sampler.REP_INTERVAL);\n        }\n    }\n    public void configureBinary(String folder,\n            int V, int[] Ks,\n            double[] alphas,\n            double[] betas,\n            double[] pis,\n            double[] gammas,\n            double mu,\n            double[] sigmas,\n            InitialState initState,\n            PathAssumption pathAssumption,\n            boolean paramOpt, boolean isRooted,\n            int burnin, int maxiter, int samplelag, int repInt) {\n        if (verbose) {\n            logln(\"Configuring ...\");\n        }\n        this.folder = folder;\n        this.V = V;\n        this.uniform = 1.0 / this.V;\n        this.Ks = Ks;\n        this.L = this.Ks.length + 1;\n        this.alphas = alphas;\n        this.betas = betas;\n        this.pis = pis;\n        this.gammas = gammas;\n        this.mu = mu;\n        this.sigmas = sigmas;\n        this.hyperparams = new ArrayList<Double>();\n        this.sampledParams = new ArrayList<ArrayList<Double>>();\n        this.sampledParams.add(cloneHyperparameters());\n        this.BURN_IN = burnin;\n        this.MAX_ITER = maxiter;\n        this.LAG = samplelag;\n        this.REP_INTERVAL = repInt;\n        this.initState = initState;\n        this.path = pathAssumption;\n        this.paramOptimized = paramOpt;\n        this.prefix += initState.toString();\n        this.isBinary = true;\n        this.isRooted = isRooted;\n        this.setName();\n        if (verbose) {\n            logln(\"--- V = \" + V);\n            logln(\"--- Ks = \" + MiscUtils.arrayToString(this.Ks));\n            logln(\"--- folder\\t\" + folder);\n            logln(\"--- alphas:\\t\" + MiscUtils.arrayToString(alphas));\n            logln(\"--- betas:\\t\" + MiscUtils.arrayToString(betas));\n            logln(\"--- pis:\\t\" + MiscUtils.arrayToString(pis));\n            logln(\"--- gammas:\\t\" + MiscUtils.arrayToString(gammas));\n            logln(\"--- rho:\\t\" + MiscUtils.formatDouble(rho));\n            logln(\"--- mu:\\t\" + MiscUtils.formatDouble(mu));\n            logln(\"--- sigmas:\\t\" + MiscUtils.arrayToString(sigmas));\n            logln(\"--- burn-in:\\t\" + BURN_IN);\n            logln(\"--- max iter:\\t\" + MAX_ITER);\n            logln(\"--- sample lag:\\t\" + LAG);\n            logln(\"--- report interval:\\t\" + REP_INTERVAL);\n            logln(\"--- paramopt:\\t\" + paramOptimized);\n            logln(\"--- initialize:\\t\" + this.initState);\n            logln(\"--- path assumption:\\t\" + this.path);\n            logln(\"--- is rooted:\\t\" + this.isRooted);\n        }\n        validateInputHyperparameters();\n    }\n    public void configureContinuous(String folder,\n            int V, int[] Ks,\n            double[] alphas,\n            double[] betas,\n            double[] pis,\n            double[] gammas,\n            double rho,\n            double mu,\n            double[] sigmas,\n            InitialState initState,\n            PathAssumption pathAssumption,\n            boolean paramOpt, boolean isRooted,\n            int burnin, int maxiter, int samplelag, int repInt) {\n        if (verbose) {\n            logln(\"Configuring ...\");\n        }\n        this.folder = folder;\n        this.V = V;\n        this.uniform = 1.0 / this.V;\n        this.Ks = Ks;\n        this.L = this.Ks.length + 1;\n        this.alphas = alphas;\n        this.betas = betas;\n        this.pis = pis;\n        this.gammas = gammas;\n        this.rho = rho;\n        this.mu = mu;\n        this.sigmas = sigmas;\n        this.hyperparams = new ArrayList<Double>();\n        this.sampledParams = new ArrayList<ArrayList<Double>>();\n        this.sampledParams.add(cloneHyperparameters());\n        this.BURN_IN = burnin;\n        this.MAX_ITER = maxiter;\n        this.LAG = samplelag;\n        this.REP_INTERVAL = repInt;\n        this.initState = initState;\n        this.path = pathAssumption;\n        this.paramOptimized = paramOpt;\n        this.prefix += initState.toString();\n        this.isBinary = false;\n        this.isRooted = isRooted;\n        this.setName();\n        if (verbose) {\n            logln(\"--- V = \" + V);\n            logln(\"--- Ks = \" + MiscUtils.arrayToString(this.Ks));\n            logln(\"--- folder\\t\" + folder);\n            logln(\"--- alphas:\\t\" + MiscUtils.arrayToString(alphas));\n            logln(\"--- betas:\\t\" + MiscUtils.arrayToString(betas));\n            logln(\"--- pis:\\t\" + MiscUtils.arrayToString(pis));\n            logln(\"--- gammas:\\t\" + MiscUtils.arrayToString(gammas));\n            logln(\"--- rho:\\t\" + MiscUtils.formatDouble(rho));\n            logln(\"--- mu:\\t\" + MiscUtils.formatDouble(mu));\n            logln(\"--- sigmas:\\t\" + MiscUtils.arrayToString(sigmas));\n            logln(\"--- burn-in:\\t\" + BURN_IN);\n            logln(\"--- max iter:\\t\" + MAX_ITER);\n            logln(\"--- sample lag:\\t\" + LAG);\n            logln(\"--- report interval:\\t\" + REP_INTERVAL);\n            logln(\"--- paramopt:\\t\" + paramOptimized);\n            logln(\"--- initialize:\\t\" + this.initState);\n            logln(\"--- path assumption:\\t\" + this.path);\n            logln(\"--- is rooted:\\t\" + this.isRooted);\n        }\n        validateInputHyperparameters();\n    }\n    private void validateInputHyperparameters() {\n        if (L - 1 != Ks.length) {\n            throw new MismatchRuntimeException(L - 1, Ks.length);\n        }\n        if (alphas.length != L - 1) {\n            throw new MismatchRuntimeException(alphas.length, L - 1);\n        }\n        if (betas.length != L) {\n            throw new MismatchRuntimeException(betas.length, L);\n        }\n        if (pis.length != L - 1) {\n            throw new MismatchRuntimeException(pis.length, L - 1);\n        }\n        if (gammas.length != L - 1) {\n            throw new MismatchRuntimeException(gammas.length, L - 1);\n        }\n        if (sigmas.length != L) {\n            throw new MismatchRuntimeException(sigmas.length, L - 1);\n        }\n        if (!isBinary && rho == 0.0) {\n            throw new RuntimeException(\"Rho should not be 0 when the response is continuous\");\n        }\n    }\n    protected void setName() {\n        StringBuilder str = new StringBuilder();\n        str.append(this.prefix)\n                .append(\"_\").append(basename);\n        str.append(\"_Ks\");\n        for (int K : Ks) {\n            str.append(\"-\").append(K);\n        }\n        str.append(\"_B-\").append(BURN_IN)\n                .append(\"_M-\").append(MAX_ITER)\n                .append(\"_L-\").append(LAG);\n        str.append(\"_a\");\n        for (double la : alphas) {\n            str.append(\"-\").append(MiscUtils.formatDouble(la));\n        }\n        str.append(\"_b\");\n        for (double b : betas) {\n            str.append(\"-\").append(MiscUtils.formatDouble(b));\n        }\n        str.append(\"_p\");\n        for (double gm : pis) {\n            str.append(\"-\").append(MiscUtils.formatDouble(gm));\n        }\n        str.append(\"_g\");\n        for (double gs : gammas) {\n            str.append(\"-\").append(MiscUtils.formatDouble(gs));\n        }\n        str.append(\"_r-\").append(MiscUtils.formatDouble(rho));\n        str.append(\"_m-\").append(MiscUtils.formatDouble(mu));\n        str.append(\"_s\");\n        for (double s : sigmas) {\n            str.append(\"-\").append(MiscUtils.formatDouble(s));\n        }\n        str.append(\"_opt-\").append(this.paramOptimized);\n        str.append(\"_bin-\").append(this.isBinary);\n        str.append(\"_path-\").append(this.path);\n        str.append(\"_root-\").append(this.isRooted);\n        this.name = str.toString();\n    }\n    protected double getAlpha(int l) {\n        return this.alphas[l];\n    }\n    protected double getBeta(int l) {\n        return this.betas[l];\n    }\n    protected double getPi(int l) {\n        return this.pis[l];\n    }\n    protected double getGamma(int l) {\n        return this.gammas[l];\n    }\n    protected double getSigma(int l) {\n        return this.sigmas[l];\n    }\n    @Override\n    public String getCurrentState() {\n        return this.getSamplerFolderPath() + \"\\n\"\n                + printGlobalTreeSummary() + \"\\n\";\n    }\n    public boolean isLeafNode(int level) {\n        return level == L - 1;\n    }\n    public double[] getPredictedValues() {\n        return docMeans;\n    }\n    /**\n     * Setting up text data.\n     *\n     * @param docWords\n     * @param docIndices\n     */\n    private void setupTextData(int[][] docWords, ArrayList<Integer> docIndices) {\n        this.docIndices = docIndices;\n        if (this.docIndices == null) { // add all documents\n            this.docIndices = new ArrayList<>();\n            for (int dd = 0; dd < docWords.length; dd++) {\n                this.docIndices.add(dd);\n            }\n        }\n        this.numTokens = 0;\n        this.D = this.docIndices.size();\n        this.words = new int[D][];\n        for (int ii = 0; ii < D; ii++) {\n            int dd = this.docIndices.get(ii);\n            this.words[ii] = docWords[dd];\n            this.numTokens += this.words[ii].length;\n        }\n        if (verbose) {\n            logln(\"--- # all docs:\\t\" + words.length);\n            logln(\"--- # selected docs:\\t\" + D);\n            logln(\"--- # tokens:\\t\" + numTokens);\n        }\n    }\n    /**\n     * Set up continuous responses.\n     *\n     * @param docResponses\n     */\n    public void setContinuousResponses(double[] docResponses) {\n        this.responses = new double[D];\n        for (int ii = 0; ii < D; ii++) {\n            this.responses[ii] = docResponses[this.docIndices.get(ii)];\n        }\n        if (verbose) {\n            logln(\"--- continuous responses:\");\n            logln(\"--- --- mean\\t\" + MiscUtils.formatDouble(\n                    StatUtils.mean(responses)));\n            logln(\"--- --- stdv\\t\" + MiscUtils.formatDouble(\n                    StatUtils.standardDeviation(responses)));\n            int[] histogram = StatUtils.bin(responses, 10);\n            for (int ii = 0; ii < histogram.length; ii++) {\n                logln(\"--- --- \" + ii + \"\\t\" + histogram[ii]);\n            }\n        }\n    }\n    /**\n     * Set up binary responses.\n     *\n     * @param docLabels\n     */\n    public void setBinaryResponses(int[] docLabels) {\n        this.labels = new int[D];\n        this.positives = new HashSet<Integer>();\n        for (int ii = 0; ii < D; ii++) {\n            int dd = this.docIndices.get(ii);\n            this.labels[ii] = docLabels[dd];\n            if (this.labels[ii] == POSITVE) {\n                this.positives.add(ii);\n            }\n        }\n        if (verbose) {\n            logln(\"--- binary responses:\");\n            int posCount = this.positives.size();\n            logln(\"--- --- # postive: \" + posCount\n                    + \" (\" + ((double) posCount / D) + \")\");\n            logln(\"--- --- # negative: \" + (D - posCount));\n        }\n    }\n    /**\n     * Set up training data with continuous responses.\n     *\n     * @param docWords All documents\n     * @param docIndices Indices of selected documents. If this is null, all\n     * documents are considered.\n     * @param docResponses Continuous responses\n     */\n    public void train(int[][] docWords,\n            ArrayList<Integer> docIndices,\n            double[] docResponses) {\n        setupTextData(docWords, docIndices);\n        setContinuousResponses(docResponses);\n    }\n    /**\n     * Set up training data with binary responses.\n     *\n     * @param docWords All documents\n     * @param docIndices Indices of selected documents. If this is null, all\n     * documents are considered.\n     * @param docLabels Binary labels\n     */\n    public void train(int[][] docWords,\n            ArrayList<Integer> docIndices,\n            int[] docLabels) {\n        setupTextData(docWords, docIndices);\n        setBinaryResponses(docLabels);\n    }\n    /**\n     * Set up test data.\n     *\n     * @param docWords Test documents\n     * @param docIndices Indices of test documents\n     */\n    public void test(int[][] docWords, ArrayList<Integer> docIndices) {\n        setupTextData(docWords, docIndices);\n    }\n    /**\n     * Set up test data.\n     *\n     * @param stateFile Input file storing trained model\n     * @param testStateFile Output file to store assignments\n     * @param predictionFile Output file to store predictions at different test\n     * iterations using the given trained model\n     * @return Prediction on all documents using the given model\n     */\n    public double[] sampleTest(File stateFile, File testStateFile, File predictionFile) {\n        setTestConfigurations(BURN_IN / 2, MAX_ITER / 2, LAG / 2);\n        if (stateFile == null) {\n            stateFile = getFinalStateFile();\n        }\n        inputModel(stateFile.toString()); // input stored model\n        initializeDataStructure(); // initialize data\n        // store predictions at different test iterations\n        ArrayList<double[]> predResponsesList = new ArrayList<double[]>();\n        // sample topic assignments for test document\n        for (iter = 0; iter < this.testMaxIter; iter++) {\n            isReporting = verbose && iter % testRepInterval == 0;\n            if (isReporting) {\n                String str = \"Iter \" + iter + \"/\" + testMaxIter\n                        + \". current thread: \" + Thread.currentThread().getId();\n                if (iter < BURN_IN) {\n                    logln(\"--- Burning in. \" + str + \"\\n\" + getCurrentState());\n                } else {\n                    logln(\"--- Sampling. \" + str + \"\\n\" + getCurrentState());\n                }\n            }\n            if (iter == 0) {\n                sampleZs(!REMOVE, !ADD, !REMOVE, ADD);\n            } else {\n                sampleZs(!REMOVE, !ADD, REMOVE, ADD);\n            }\n            // store prediction (on all documents) at a test iteration\n            if (iter >= this.testBurnIn && iter % this.testSampleLag == 0) {\n                double[] predResponses = new double[D];\n                System.arraycopy(docMeans, 0, predResponses, 0, D);\n                predResponsesList.add(predResponses);\n                if (responses != null) { // debug\n                    evaluatePerformances();\n                }\n            }\n        }\n        // output state file containing the assignments for test documents\n        if (testStateFile != null) {\n            outputState(testStateFile.getAbsolutePath(), false, true);\n        }\n        // store predictions if necessary\n        if (predictionFile != null) {\n            PredictionUtils.outputSingleModelRegressions(predictionFile, predResponsesList);\n        }\n        // average over all stored predictions\n        double[] predictions = new double[D];\n        for (int dd = 0; dd < D; dd++) {\n            for (double[] predResponses : predResponsesList) {\n                predictions[dd] += predResponses[dd] / predResponsesList.size();\n            }\n        }\n        return predictions;\n    }\n    @Override\n    public void initialize() {\n        initialize(null, null);\n    }\n    public void initialize(double[][] priorTopics, double[] initEtas) {\n        if (verbose) {\n            logln(\"Initializing ...\");\n        }\n        iter = INIT;\n        isReporting = true;\n        initializeModelStructure(priorTopics, initEtas);\n        initializeDataStructure();\n        initializeAssignments();\n        updateEtas();\n        if (verbose) {\n            logln(\"--- Done initializing.\\n\" + printGlobalTree());\n            logln(\"\\n\" + printGlobalTreeSummary() + \"\\n\");\n            getLogLikelihood();\n        }\n        outputTopicTopWords(new File(getSamplerFolderPath(), \"init-\" + TopWordFile), 20);\n        validate(\"Initialized\");\n    }\n    protected void initializeModelFirstLevelNodes(double[][] priorTopics, double[] initEtas) {\n        int level = 1;\n        for (int kk = 0; kk < Ks[0]; kk++) {\n            // prior topic\n            double[] prior;\n            if (priorTopics == null) {\n                prior = new double[V];\n                Arrays.fill(prior, uniform);\n            } else {\n                prior = priorTopics[kk];\n            }\n            // initial eta\n            double eta;\n            if (initEtas != null) {\n                eta = initEtas[kk];\n            } else {\n                eta = SamplerUtils.getGaussian(mu, getSigma(level));\n            }\n            // initialize\n            DirMult topic = new DirMult(V, getBeta(1) * V, prior);\n            Node node = new Node(iter, kk, level, topic, root, eta);\n            this.root.addChild(kk, node);\n        }\n    }\n    protected void initializeModelStructure(double[][] priorTopics, double[] initEtas) {\n        if (verbose) {\n            logln(\"--- Initializing model structure ...\");\n        }\n        // initialize root node\n        DirMult rootTopic = new DirMult(V, getBeta(0) * V, uniform);\n        double rootEta = SamplerUtils.getGaussian(mu, getSigma(0));\n        this.root = new Node(iter, 0, 0, rootTopic, null, rootEta);\n        // first level\n        initializeModelFirstLevelNodes(priorTopics, initEtas);\n        Queue<Node> queue = new LinkedList<>();\n        for (Node child : root.getChildren()) {\n            queue.add(child);\n        }\n        // from 2nd-level downward\n        while (!queue.isEmpty()) {\n            Node node = queue.poll();\n            int level = node.getLevel();\n            if (level < L - 1) {\n                for (int kk = 0; kk < Ks[level]; kk++) {\n                    DirMult topic = new DirMult(V, getBeta(level + 1) * V, uniform);\n                    Node child = new Node(iter, kk, level + 1, topic, node,\n                            SamplerUtils.getGaussian(mu, getSigma(level)));\n                    node.addChild(kk, child);\n                    queue.add(child);\n                }\n            }\n        }\n        // initialize pi's and theta's\n        Stack<Node> stack = new Stack<>();\n        stack.add(root);\n        while (!stack.isEmpty()) {\n            Node node = stack.pop();\n            if (node.getLevel() < L - 1) {\n                node.initializeGlobalTheta();\n                node.initializeGlobalPi();\n                for (Node child : node.getChildren()) {\n                    stack.add(child);\n                }\n            }\n        }\n        if (verbose) {\n            logln(\"--- --- Initialized model structure.\\n\" + printGlobalTreeSummary());\n        }\n    }\n    protected void initializeDataStructure() {\n        if (verbose) {\n            logln(\"--- Initializing data structure ...\");\n        }\n        this.z = new Node[D][];\n        for (int dd = 0; dd < D; dd++) {\n            this.z[dd] = new Node[words[dd].length];\n        }\n        this.docMeans = new double[D];\n    }\n    protected void initializeAssignments() {\n        if (verbose) {\n            logln(\"--- Initializing assignments. \" + initState);\n        }\n        switch (initState) {\n            case RANDOM:\n                initializeRandomAssignments();\n                break;\n            case PRESET:\n                initializePresetAssignments();\n                break;\n            default:\n                throw new RuntimeException(\"Initialization not supported\");\n        }\n    }\n    private void initializeRandomAssignments() {\n        sampleZs(!REMOVE, ADD, !REMOVE, ADD, !OBSERVED);\n    }\n    private void initializePresetAssignments() {\n//        SLDA slda = new SLDA();\n//        slda.setDebug(false);\n//        slda.setVerbose(verbose);\n//        slda.setLog(false);\n//        \n//        slda.configure(new File(foldFolder, modelFolder).getAbsolutePath(),\n//                trainData.getWordVocab().size(), K,\n//                alpha, beta, rho, mu, sigma,\n//                initState, paramOpt, hasBias,\n//                burn_in, max_iters, sample_lag, report_interval);\n//        \n//        LDA lda = runLDA(words, Ks[0], V, null);\n//        int[][] ldaZs = lda.getZs();\n//\n//        for (int dd = 0; dd < D; dd++) {\n//            for (int nn = 0; nn < words[dd].length; nn++) {\n//                Node sampledNode = sampleNode(dd, nn, root.getChild(ldaZs[dd][nn]));\n//                addToken(dd, nn, sampledNode, ADD, ADD);\n//            }\n//        }\n    }\n    /**\n     * Add a token to a node.\n     *\n     * @param dd\n     * @param nn\n     * @param node\n     * @param addToData\n     * @param addToModel\n     */\n    private void addToken(int dd, int nn, Node node,\n            boolean addToData, boolean addToModel) {\n        if (addToModel) {\n            node.getContent().increment(words[dd][nn]);\n            Node tempNode = node;\n            while (tempNode != null) {\n                tempNode.incrementSubtreeWordCount(words[dd][nn]);\n                tempNode = tempNode.getParent();\n            }\n        }\n        if (addToData) {\n            docMeans[dd] += node.pathEta / this.words[dd].length;\n            node.nodeDocCounts.increment(dd);\n            Node tempNode = node;\n            while (tempNode != null) {\n                tempNode.subtreeDocCounts.increment(dd);\n                tempNode = tempNode.getParent();\n            }\n        }\n    }\n    /**\n     * Remove a token from a node.\n     *\n     * @param dd\n     * @param nn\n     * @param node\n     * @param removeFromData\n     * @param removeFromModel\n     */\n    private void removeToken(int dd, int nn, Node node,\n            boolean removeFromData, boolean removeFromModel) {\n        if (removeFromData) {\n            docMeans[dd] -= node.pathEta / this.words[dd].length;\n            node.nodeDocCounts.decrement(dd);\n            Node tempNode = node;\n            while (tempNode != null) {\n                tempNode.subtreeDocCounts.decrement(dd);\n                tempNode = tempNode.getParent();\n            }\n        }\n        if (removeFromModel) {\n            node.getContent().decrement(words[dd][nn]);\n            Node tempNode = node;\n            while (tempNode != null) {\n                tempNode.decrementSubtreeWordCount(words[dd][nn]);\n                tempNode = tempNode.getParent();\n            }\n        }\n    }\n    @Override\n    public void iterate() {\n        if (isReporting) {\n            System.out.println(\"\\n\");\n            logln(\"Iteration \" + iter + \" / \" + MAX_ITER);\n        }\n        sampleZs(REMOVE, ADD, REMOVE, ADD, OBSERVED);\n        updateEtas();\n    }\n    // ONLY FOR DEBUGGING\n    private Node sampleNodeSimple(int dd, int nn, boolean observed) {\n        double[] logprobs = new double[Ks[0]];\n        for (int kk = 0; kk < Ks[0]; kk++) {\n            Node node = root.getChild(kk);\n            logprobs[kk] = Math.log(node.subtreeDocCounts.getCount(dd) + getAlpha(0))\n                    + Math.log(node.getNodeWordProbability(words[dd][nn]));\n            if (observed) {\n                double mean = docMeans[dd] + node.pathEta / words[dd].length;\n                logprobs[kk] += StatUtils.logNormalProbability(responses[dd], mean, Math.sqrt(rho));\n            }\n        }\n        int sampledZ = SamplerUtils.logMaxRescaleSample(logprobs);\n        return root.getChild(sampledZ);\n    }\n    /**\n     * Gibbs sample node assignment for all tokens.\n     *\n     * @param removeFromModel\n     * @param addToModel\n     * @param removeFromData\n     * @param addToData\n     * @return Elapsed time\n     */\n    protected long sampleZs(boolean removeFromModel, boolean addToModel,\n            boolean removeFromData, boolean addToData) {\n        if (isReporting) {\n            logln(\"+++ Gibbs sampling Zs ...\");\n        }\n        numTokensChanged = 0;\n        long sTime = System.currentTimeMillis();\n        for (int dd = 0; dd < D; dd++) {\n            for (int nn = 0; nn < words[dd].length; nn++) {\n                // remove\n                removeToken(dd, nn, z[dd][nn], removeFromData, removeFromModel);\n                Node sampledNode = sampleNode(dd, nn, root);\n                if (z[dd][nn] == null || !z[dd][nn].equals(sampledNode)) {\n                    numTokensChanged++;\n                }\n                z[dd][nn] = sampledNode;\n                // add\n                addToken(dd, nn, z[dd][nn], addToData, addToModel);\n            }\n        }\n        long eTime = System.currentTimeMillis() - sTime;\n        if (isReporting) {\n            logln(\"--- --- time: \" + eTime);\n            logln(\"--- --- # tokens: \" + numTokens\n                    + \". # changed: \" + numTokensChanged\n                    + \" (\" + MiscUtils.formatDouble((double) numTokensChanged / numTokens) + \")\"\n            );\n        }\n        return eTime;\n    }\n    /**\n     * MH sample node assignment for all tokens.\n     *\n     * @param removeFromModel\n     * @param addToModel\n     * @param removeFromData\n     * @param addToData\n     * @param observed\n     * @return Elapsed time\n     */\n    protected long sampleZs(boolean removeFromModel, boolean addToModel,\n            boolean removeFromData, boolean addToData, boolean observed) {\n        if (isReporting) {\n            logln(\"+++ MH-sampling Zs ...\");\n        }\n        numTokensChanged = 0;\n        numTokensAccepted = 0;\n        long sTime = System.currentTimeMillis();\n        for (int dd = 0; dd < D; dd++) {\n            for (int nn = 0; nn < words[dd].length; nn++) {\n                // remove\n                removeToken(dd, nn, z[dd][nn], removeFromData, removeFromModel);\n                boolean accept = false;\n                Node sampledNode = sampleNode(dd, nn, root);\n                if (z[dd][nn] == null) {\n                    accept = true;\n                    numTokensChanged++;\n                    numTokensAccepted++;\n                } else if (sampledNode.equals(z[dd][nn])) {\n                    accept = true;\n                    numTokensAccepted++;\n                } else {\n                    if (evaluateProposedNode(dd, nn, z[dd][nn], sampledNode, observed)) {\n                        accept = true;\n                        numTokensAccepted++;\n                    }\n                }\n                if (accept) {\n                    if (z[dd][nn] != null && !z[dd][nn].equals(sampledNode)) {\n                        numTokensChanged++;\n                    }\n                    z[dd][nn] = sampledNode;\n                }\n                // add\n                addToken(dd, nn, z[dd][nn], addToData, addToModel);\n            }\n        }\n        long eTime = System.currentTimeMillis() - sTime;\n        if (isReporting) {\n            logln(\"--- --- time: \" + eTime);\n            logln(\"--- --- # tokens: \" + numTokens\n                    + \". # changed: \" + numTokensChanged\n                    + \" (\" + MiscUtils.formatDouble((double) numTokensChanged / numTokens) + \")\"\n                    + \". # accepted: \" + numTokensAccepted\n                    + \" (\" + MiscUtils.formatDouble((double) numTokensAccepted / numTokens) + \")\");\n        }\n        return eTime;\n    }\n    /**\n     * Recursively sample node level-by-level.\n     *\n     * @param dd\n     * @param nn\n     * @param curNode\n     */\n    private Node sampleNode(int dd, int nn, Node curNode) {\n        if (curNode.isLeaf()) {\n            return curNode;\n        }\n        if (curNode.isRoot()) {\n            cachedProbabilities = new HashMap<>();\n        }\n        int level = curNode.getLevel();\n        ArrayList<Node> nodeList = new ArrayList<>();\n        ArrayList<Double> probList = new ArrayList<>();\n        // staying at this node\n        double gamma = getGamma(level);\n        double stayprob;\n        if (curNode.isRoot() && !isRooted) {\n            stayprob = 0.0;\n        } else {\n            stayprob = (curNode.nodeDocCounts.getCount(dd) + gamma * curNode.pi)\n                    / (curNode.subtreeDocCounts.getCount(dd) + gamma);\n            double wordprob = curNode.getNodeWordProbability(words[dd][nn]);\n            double prob = stayprob * wordprob;\n            probList.add(prob);\n            nodeList.add(curNode);\n            if (curNode.isRoot()) {\n                cachedProbabilities.put(curNode, prob);\n            }\n        }\n        // moving to one of the children nodes\n        double alpha = getAlpha(level);\n        double passprob = 1.0 - stayprob;\n        int KK = curNode.getNumChildren();\n        double norm = curNode.getPassingCount(dd) + alpha * KK;\n        for (Node child : curNode.getChildren()) {\n            int kk = child.getIndex();\n            double pathprob = (child.subtreeDocCounts.getCount(dd)\n                    + alpha * KK * curNode.theta[kk]) / norm;\n            double wordprob = child.getSubtreeWordProbability(words[dd][nn]);\n            double prob = passprob * pathprob * wordprob;\n            probList.add(prob);\n            nodeList.add(child);\n            if (curNode.isRoot()) {\n                cachedProbabilities.put(child, prob);\n            }\n        }\n        int sampledIdx = SamplerUtils.scaleSample(probList);\n        Node sampledNode = nodeList.get(sampledIdx);\n        if (sampledNode.equals(curNode)) {\n            return curNode;\n        } else {\n            return sampleNode(dd, nn, sampledNode);\n        }\n    }\n    /**\n     * Evaluate proposed node using Metropolis-Hastings algorithm.\n     *\n     * @param dd\n     * @param nn\n     * @param curNode\n     * @param newNode\n     * @param observed\n     */\n    private boolean evaluateProposedNode(int dd, int nn,\n            Node curNode, Node newNode, boolean observed) {\n        double newNodeTrueProb = getTrueLogProbability(dd, nn, newNode, observed);\n        double curNodeTrueProb = getTrueLogProbability(dd, nn, curNode, observed);\n        double newNodePropProb = getProporalProbability(dd, nn, newNode);\n        double curNodePropProb = getProporalProbability(dd, nn, curNode);\n        double ratio = (newNodeTrueProb * curNodePropProb) / (curNodeTrueProb * newNodePropProb);\n        return rand.nextDouble() < Math.min(1.0, ratio);\n    }\n    private double getTrueLogProbability(int dd, int nn, Node node, boolean observed) {\n        double lp = node.getNodeWordProbability(words[dd][nn]);\n        if (observed) {\n            lp *= Math.exp(getResponseLogLikelihood(dd, node));\n        }\n        lp *= getActualPathProbability(dd, nn, node, node);\n        Node source = node.getParent();\n        Node target = node;\n        while (!target.isRoot()) {\n            lp *= getActualPathProbability(dd, nn, source, target);\n            target = source;\n            source = source.getParent();\n        }\n        return lp;\n    }\n    private double getActualPathProbability(int dd, int nn, Node source, Node target) {\n        int level = source.getLevel();\n        if (level == L - 1) { // leaf node\n            return 1.0;\n        }\n        double stayprob;\n        if (source.isRoot() && !isRooted) {\n            stayprob = 0.0;\n        } else {\n            stayprob = (source.nodeDocCounts.getCount(dd) + getGamma(level) * source.pi)\n                    / (source.subtreeDocCounts.getCount(dd) + getGamma(level));\n        }\n        if (source.equals(target)) {\n            return (stayprob);\n        }\n        double alpha = getAlpha(level);\n        double passprob = 1.0 - stayprob;\n        int KK = source.getNumChildren();\n        double pathprob = (target.subtreeDocCounts.getCount(dd) + alpha * KK * source.theta[target.getIndex()])\n                / (source.getPassingCount(dd) + alpha * KK);\n        return (passprob * pathprob);\n    }\n    private double getProporalProbability(int dd, int nn, Node node) {\n        double prob = getProposalPathProbability(dd, nn, node, node);\n        Node source = node.getParent();\n        Node target = node;\n        while (!target.isRoot()) {\n            prob *= getProposalPathProbability(dd, nn, source, target);\n            target = source;\n            source = source.getParent();\n        }\n        return prob;\n    }\n    private double getProposalPathProbability(int dd, int nn, Node source, Node target) {\n        int level = source.getLevel();\n        if (level == 0) { // use cached probabilities\n            double totalProb = 0.0;\n            for (double prob : cachedProbabilities.values()) {\n                totalProb += prob;\n            }\n            Double prob = cachedProbabilities.get(target);\n            if (prob == null) {\n                throw new RuntimeException(\"Null probability\");\n            }\n            return (prob / totalProb);\n        } else if (level == L - 1) { // leaf node\n            return 1.0;\n        }\n        double gamma = getGamma(level);\n        double num = 0.0;\n        double den = 0.0;\n        double stayprob;\n        if (source.isRoot() && !isRooted) {\n            stayprob = 0.0;\n        } else {\n            stayprob = (source.nodeDocCounts.getCount(dd) + gamma * source.pi)\n                    / (source.subtreeDocCounts.getCount(dd) + gamma);\n            double wordprob = source.getNodeWordProbability(words[dd][nn]);\n            double prob = stayprob * wordprob;\n            if (source.equals(target)) {\n                num = prob;\n            }\n            den += prob;\n        }\n        double alpha = getAlpha(level);\n        double passprob = 1.0 - stayprob;\n        int KK = source.getNumChildren();\n        double norm = source.getPassingCount(dd) + alpha * KK;\n        for (Node child : source.getChildren()) {\n            int kk = child.getIndex();\n            double pathprob = (child.subtreeDocCounts.getCount(dd)\n                    + alpha * KK * source.theta[kk]) / norm;\n            double wordprob = child.getSubtreeWordProbability(words[dd][nn]);\n            double prob = passprob * pathprob * wordprob;\n            if (target.equals(child)) {\n                num = prob;\n            }\n            den += prob;\n        }\n        return (num / den);\n    }\n    private double getResponseLogLikelihood(int dd, Node node) {\n        double aMean = docMeans[dd] + node.pathEta / this.words[dd].length;\n        double resLLh;\n        if (isBinary) {\n            resLLh = getLabelLogLikelihood(labels[dd], aMean);\n        } else {\n            resLLh = StatUtils.logNormalProbability(responses[dd], aMean, Math.sqrt(rho));\n        }\n        return resLLh;\n    }\n    private double getLabelLogLikelihood(int label, double dotProb) {\n        double logNorm = Math.log(Math.exp(dotProb) + 1);\n        if (label == POSITVE) {\n            return dotProb - logNorm;\n        } else {\n            return -logNorm;\n        }\n    }\n    /**\n     * Update regression parameters using L-BFGS.\n     *\n     * @return Elapsed time\n     */\n    public long updateEtas() {\n        if (isReporting) {\n            logln(\"+++ Updating eta's ...\");\n        }\n        long sTime = System.currentTimeMillis();\n        // list of nodes\n        ArrayList<Node> nodeList = getNodeList();\n        int N = nodeList.size();\n        // design matrix\n        SparseVector[] designMatrix = new SparseVector[D];\n        for (int aa = 0; aa < D; aa++) {\n            designMatrix[aa] = new SparseVector(N);\n        }\n        for (int kk = 0; kk < N; kk++) {\n            Node node = nodeList.get(kk);\n            if (node.isRoot()) {\n                for (int dd = 0; dd < D; dd++) {\n                    designMatrix[dd].set(kk, 1.0);\n                }\n            } else {\n                for (int dd : node.subtreeDocCounts.getIndices()) {\n                    int count = node.subtreeDocCounts.getCount(dd);\n                    double val = (double) count / this.words[dd].length;\n                    designMatrix[dd].change(kk, val);\n                }\n            }\n        }\n        // current params\n        double[] etaArray = new double[N];\n        double[] sigmaArray = new double[N];\n        for (int kk = 0; kk < N; kk++) {\n            etaArray[kk] = nodeList.get(kk).eta;\n            sigmaArray[kk] = getSigma(nodeList.get(kk).getLevel());\n        }\n        boolean converged = false;\n        if (isBinary) {\n            RidgeLogisticRegressionOptimizable optimizable = new RidgeLogisticRegressionOptimizable(\n                    labels, etaArray, designMatrix, mu, sigmaArray);\n            LimitedMemoryBFGS optimizer = new LimitedMemoryBFGS(optimizable);\n            try {\n                converged = optimizer.optimize();\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n            // update regression parameters\n            for (int kk = 0; kk < N; kk++) {\n                nodeList.get(kk).eta = optimizable.getParameter(kk);\n            }\n        } else {\n            RidgeLinearRegressionOptimizable optimizable = new RidgeLinearRegressionOptimizable(\n                    responses, etaArray, designMatrix, rho, mu, sigmaArray);\n            LimitedMemoryBFGS optimizer = new LimitedMemoryBFGS(optimizable);\n            try {\n                converged = optimizer.optimize();\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n            // update regression parameters\n            for (int kk = 0; kk < N; kk++) {\n                nodeList.get(kk).eta = optimizable.getParameter(kk);\n            }\n        }\n        // update document means\n        for (int dd = 0; dd < D; dd++) {\n            docMeans[dd] = 0.0;\n            for (int kk : designMatrix[dd].getIndices()) {\n                docMeans[dd] += designMatrix[dd].get(kk) * nodeList.get(kk).eta;\n            }\n        }\n        // update path thetas\n        updatePathEtas();\n        long eTime = System.currentTimeMillis() - sTime;\n        if (isReporting) {\n            logln(\"--- converged? \" + converged\n                    + \". \" + designMatrix.length + \" x \" + nodeList.size());\n            logln(\"--- --- time: \" + eTime);\n            evaluatePerformances();\n        }\n        return eTime;\n    }\n    protected void evaluatePerformances() {\n        if (isBinary) {\n            double[] predVals = new double[D];\n            for (int d = 0; d < D; d++) {\n                double expDotProd = Math.exp(docMeans[d]);\n                double docPred = expDotProd / (expDotProd + 1);\n                predVals[d] = docPred;\n            }\n            ArrayList<RankingItem<Integer>> rankDocs = new ArrayList<RankingItem<Integer>>();\n            for (int d = 0; d < D; d++) {\n                rankDocs.add(new RankingItem<Integer>(d, predVals[d]));\n            }\n            Collections.sort(rankDocs);\n            int[] preds = new int[D];\n            for (int ii = 0; ii < this.positives.size(); ii++) {\n                int d = rankDocs.get(ii).getObject();\n                preds[d] = POSITVE;\n            }\n            ClassificationEvaluation eval = new ClassificationEvaluation(labels, preds);\n            eval.computePRF1();\n            for (Measurement measurement : eval.getMeasurements()) {\n                logln(\"--- --- \" + measurement.getName() + \":\\t\" + measurement.getValue());\n            }\n        } else {\n            RegressionEvaluation eval = new RegressionEvaluation(responses, docMeans);\n            eval.computeCorrelationCoefficient();\n            eval.computeMeanSquareError();\n            eval.computeMeanAbsoluteError();\n            eval.computeRSquared();\n            eval.computePredictiveRSquared();\n            ArrayList<Measurement> measurements = eval.getMeasurements();\n            for (Measurement measurement : measurements) {\n                logln(\"--- --- \" + measurement.getName() + \":\\t\" + measurement.getValue());\n            }\n        }\n    }\n    /**\n     * Update the eta sum for each path, which is represented by a node.\n     */\n    private void updatePathEtas() {\n        Queue<Node> queue = new LinkedList<>();\n        queue.add(root);\n        while (!queue.isEmpty()) {\n            Node node = queue.poll();\n            node.pathEta = node.eta;\n            if (!node.isRoot()) {\n                node.pathEta += node.getParent().pathEta;\n            }\n            for (Node child : node.getChildren()) {\n                queue.add(child);\n            }\n        }\n    }\n    /**\n     * Flatten the tree.\n     */\n    private ArrayList<Node> getNodeList() {\n        ArrayList<Node> nodeList = new ArrayList<>();\n        Stack<Node> stack = new Stack<>();\n        stack.add(root);\n        while (!stack.isEmpty()) {\n            Node node = stack.pop();\n            for (Node child : node.getChildren()) {\n                stack.add(child);\n            }\n            nodeList.add(node);\n        }\n        return nodeList;\n    }\n    @Override\n    public double getLogLikelihood() {\n        return 0.0;\n    }\n    @Override\n    public double getLogLikelihood(ArrayList<Double> newParams) {\n        throw new RuntimeException(\"Currently not supported\");\n    }\n    @Override\n    public void updateHyperparameters(ArrayList<Double> newParams) {\n        throw new RuntimeException(\"Currently not supported\");\n    }\n    @Override\n    public void validate(String msg) {\n        logln(\"Validating ... \" + msg);\n        Stack<Node> stack = new Stack<>();\n        stack.add(root);\n        while (!stack.isEmpty()) {\n            Node node = stack.pop();\n            for (Node child : node.getChildren()) {\n                stack.add(child);\n            }\n            node.validate(msg);\n        }\n    }\n    public void outputState(String filepath, boolean outputModel, boolean outputAssignment) {\n        if (verbose) {\n            logln(\"--- Outputing current state to \" + filepath);\n        }\n        StringBuilder modelStr = new StringBuilder();\n        if (outputModel) {\n            Stack<Node> stack = new Stack<>();\n            stack.add(root);\n            while (!stack.isEmpty()) {\n                Node node = stack.pop();\n                modelStr.append(Integer.toString(node.born)).append(\"\\n\");\n                modelStr.append(node.getPathString()).append(\"\\n\");\n                modelStr.append(node.eta).append(\"\\n\");\n                modelStr.append(node.pi).append(\"\\n\");\n                if (node.theta != null) {\n                    modelStr.append(MiscUtils.arrayToString(node.theta));\n                }\n                modelStr.append(\"\\n\");\n                modelStr.append(DirMult.output(node.getContent())).append(\"\\n\");\n                modelStr.append(SparseCount.output(node.subtreeWordCounts)).append(\"\\n\");\n                for (Node child : node.getChildren()) {\n                    stack.add(child);\n                }\n            }\n        }\n        StringBuilder assignStr = new StringBuilder();\n        if (outputAssignment) {\n            for (int dd = 0; dd < z.length; dd++) {\n                for (int nn = 0; nn < z[dd].length; nn++) {\n                    assignStr.append(dd)\n                            .append(\"\\t\").append(nn)\n                            .append(\"\\t\").append(z[dd][nn].getPathString()).append(\"\\n\");\n                }\n            }\n        }\n        try { // output to a compressed file\n            ArrayList<String> contentStrs = new ArrayList<>();\n            contentStrs.add(modelStr.toString());\n            contentStrs.add(assignStr.toString());\n            String filename = IOUtils.removeExtension(IOUtils.getFilename(filepath));\n            ArrayList<String> entryFiles = new ArrayList<>();\n            entryFiles.add(filename + ModelFileExt);\n            entryFiles.add(filename + AssignmentFileExt);\n            this.outputZipFile(filepath, contentStrs, entryFiles);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"Exception while outputing to \" + filepath);\n        }\n    }\n    @Override\n    public void outputState(String filepath) {\n        if (verbose) {\n            logln(\"--- Outputing current state to \" + filepath);\n        }\n        outputState(filepath, true, true);\n    }\n    @Override\n    public void inputState(String filepath) {\n        if (verbose) {\n            logln(\"--- Reading state from \" + filepath);\n        }\n        try {\n            inputModel(filepath);\n            inputAssignments(filepath);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"Exception while inputing from \" + filepath);\n        }\n    }\n    public void inputModel(String zipFilepath) {\n        if (verbose) {\n            logln(\"--- --- Loading model from \" + zipFilepath);\n        }\n        try {\n            String filename = IOUtils.removeExtension(IOUtils.getFilename(zipFilepath));\n            BufferedReader reader = IOUtils.getBufferedReader(zipFilepath, filename + ModelFileExt);\n            HashMap<String, Node> nodeMap = new HashMap<String, Node>();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                int born = Integer.parseInt(line);\n                String pathStr = reader.readLine();\n                double eta = Double.parseDouble(reader.readLine());\n                double pi = Double.parseDouble(reader.readLine());\n                line = reader.readLine().trim();\n                double[] theta = null;\n                if (!line.isEmpty()) {\n                    theta = MiscUtils.stringToDoubleArray(line);\n                }\n                DirMult topic = DirMult.input(reader.readLine());\n                SparseCount subtreeWordCounts = SparseCount.input(reader.readLine());\n                // create node\n                int lastColonIndex = pathStr.lastIndexOf(\":\");\n                Node parent = null;\n                if (lastColonIndex != -1) {\n                    parent = nodeMap.get(pathStr.substring(0, lastColonIndex));\n                }\n                String[] pathIndices = pathStr.split(\":\");\n                int nodeIndex = Integer.parseInt(pathIndices[pathIndices.length - 1]);\n                int nodeLevel = pathIndices.length - 1;\n                Node node = new Node(born, nodeIndex, nodeLevel, topic, parent, eta);\n                node.pi = pi;\n                node.theta = theta;\n                node.subtreeWordCounts = subtreeWordCounts;\n                if (node.getLevel() == 0) {\n                    root = node;\n                }\n                if (parent != null) {\n                    parent.addChild(node.getIndex(), node);\n                }\n                nodeMap.put(pathStr, node);\n            }\n            updatePathEtas();\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"Exception while loading model from \"\n                    + zipFilepath);\n        }\n    }\n    /**\n     * Input a set of assignments.\n     *\n     * @param zipFilepath Compressed learned state file\n     */\n    public void inputAssignments(String zipFilepath) {\n        if (verbose) {\n            logln(\"--- --- Loading assignments from \" + zipFilepath);\n        }\n        try {\n            z = new Node[D][];\n            for (int d = 0; d < D; d++) {\n                z[d] = new Node[words[d].length];\n            }\n            String filename = IOUtils.removeExtension(IOUtils.getFilename(zipFilepath));\n            BufferedReader reader = IOUtils.getBufferedReader(zipFilepath, filename + AssignmentFileExt);\n            for (int dd = 0; dd < z.length; dd++) {\n                for (int nn = 0; nn < z[dd].length; nn++) {\n                    String[] sline = reader.readLine().split(\"\\t\");\n                    if (dd != Integer.parseInt(sline[0])) {\n                        throw new MismatchRuntimeException(Integer.parseInt(sline[0]), dd);\n                    }\n                    if (nn != Integer.parseInt(sline[1])) {\n                        throw new MismatchRuntimeException(Integer.parseInt(sline[1]), nn);\n                    }\n                    String pathStr = sline[2];\n                    z[dd][nn] = getNode(pathStr);\n                    addToken(dd, nn, z[dd][nn], ADD, ADD);\n                }\n            }\n            reader.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"Exception while loading assignments from \"\n                    + zipFilepath);\n        }\n    }\n    /**\n     * Parse the node path string.\n     *\n     * @param nodePath The node path string\n     * @return\n     */\n    public int[] parseNodePath(String nodePath) {\n        String[] ss = nodePath.split(\":\");\n        int[] parsedPath = new int[ss.length];\n        for (int i = 0; i < ss.length; i++) {\n            parsedPath[i] = Integer.parseInt(ss[i]);\n        }\n        return parsedPath;\n    }\n    /**\n     * Get a node in the tree given a parsed path\n     *\n     * @param parsedPath The parsed path\n     */\n    private Node getNode(int[] parsedPath) {\n        Node node = root;\n        for (int i = 1; i < parsedPath.length; i++) {\n            node = node.getChild(parsedPath[i]);\n        }\n        return node;\n    }\n    /**\n     * Get a node in the tree given its path.\n     *\n     * @param pathStr\n     */\n    private Node getNode(String pathStr) {\n        return getNode(parseNodePath(pathStr));\n    }\n    /**\n     * Summary of the current tree.\n     *\n     * @return Summary of the current tree\n     */\n    public String printGlobalTreeSummary() {\n        StringBuilder str = new StringBuilder();\n        SparseCount nodeCountPerLevel = new SparseCount();\n        SparseCount obsCountPerLevel = new SparseCount();\n        SparseCount subtreeObsCountPerLvl = new SparseCount();\n        Stack<Node> stack = new Stack<Node>();\n        stack.add(root);\n        int totalObs = 0;\n        while (!stack.isEmpty()) {\n            Node node = stack.pop();\n            for (Node child : node.getChildren()) {\n                stack.add(child);\n            }\n            if (node.isEmpty()) {\n                continue;\n            }\n            int level = node.getLevel();\n            nodeCountPerLevel.increment(level);\n            obsCountPerLevel.changeCount(level, node.nodeDocCounts.getCountSum());\n            subtreeObsCountPerLvl.changeCount(level, node.subtreeDocCounts.getCountSum());\n            totalObs += node.nodeDocCounts.getCountSum();\n        }\n        str.append(\"global tree:\\n\\t>>> node count per level:\\n\");\n        for (int l : nodeCountPerLevel.getSortedIndices()) {\n            int obsCount = obsCountPerLevel.getCount(l);\n            int subtreeObsCount = subtreeObsCountPerLvl.getCount(l);\n            int nodeCount = nodeCountPerLevel.getCount(l);\n            str.append(\"\\t>>> >>> \").append(l)\n                    .append(\" [\")\n                    .append(nodeCount)\n                    .append(\"] [\").append(obsCount)\n                    .append(\", \").append(MiscUtils.formatDouble((double) obsCount / nodeCount))\n                    .append(\", \").append(MiscUtils.formatDouble((double) 100 * obsCount / numTokens)).append(\"%\")\n                    .append(\"] [\").append(subtreeObsCount)\n                    .append(\", \").append(MiscUtils.formatDouble((double) subtreeObsCount / nodeCount))\n                    .append(\", \").append(MiscUtils.formatDouble((double) 100 * subtreeObsCount / numTokens)).append(\"%\")\n                    .append(\"]\\n\");\n        }\n        str.append(\"\\n\");\n        str.append(\"\\t>>> # observations = \").append(totalObs).append(\"\\n\");\n        str.append(\"\\t>>> # nodes = \").append(nodeCountPerLevel.getCountSum()).append(\"\\n\");\n        return str.toString();\n    }\n    /**\n     * The current tree.\n     *\n     * @return The current tree\n     */\n    public String printGlobalTree() {\n        SparseCount nodeCountPerLvl = new SparseCount();\n        SparseCount obsCountPerLvl = new SparseCount();\n        SparseCount subtreeObsCountPerLvl = new SparseCount();\n        int totalNumObs = 0;\n        int numWords = 10;\n        StringBuilder str = new StringBuilder();\n        str.append(\"global tree\\n\");\n        Stack<Node> stack = new Stack<Node>();\n        stack.add(root);\n        while (!stack.isEmpty()) {\n            Node node = stack.pop();\n            String indentation = node.getIndentation();\n            ArrayList<RankingItem<Node>> rankChildren = new ArrayList<RankingItem<Node>>();\n            for (Node child : node.getChildren()) {\n                rankChildren.add(new RankingItem<Node>(child, child.eta));\n            }\n            Collections.sort(rankChildren);\n            for (RankingItem<Node> item : rankChildren) {\n                stack.add(item.getObject());\n            }\n            // top words according to the distribution\n            str.append(indentation);\n            str.append(node.getPathString())\n                    .append(\" (\").append(node.born)\n                    .append(\"; \").append(node.getContent().getCountSum())\n                    .append(\"; \").append(MiscUtils.formatDouble(node.eta))\n                    .append(\"; \").append(MiscUtils.formatDouble(node.pathEta))\n                    .append(\")\");\n            str.append(\"\\n\");\n            if (!node.isEmpty()) {\n                // words with highest probabilities at subtree\n                if (node.getLevel() < L - 1) {\n                    String[] subtreeTopWords = node.getSubtreeTopWords(numWords);\n                    str.append(indentation).append(\"@ subtree: \");\n                    for (String topWord : subtreeTopWords) {\n                        str.append(\" \").append(topWord);\n                    }\n                    str.append(\"\\n\");\n                }\n                // words with highest probabilities at node\n                String[] nodeTopWords = node.getNodeTopWords(numWords);\n                str.append(indentation).append(\"@ node: \");\n                for (String topWord : nodeTopWords) {\n                    str.append(\" \").append(topWord);\n                }\n                str.append(\"\\n\");\n                // top assigned words\n                str.append(indentation);\n                str.append(node.getTopObservations()).append(\"\\n\\n\");\n                int level = node.getLevel();\n                nodeCountPerLvl.increment(level);\n                obsCountPerLvl.changeCount(level, node.nodeDocCounts.getCountSum());\n                subtreeObsCountPerLvl.changeCount(level, node.subtreeDocCounts.getCountSum());\n                totalNumObs += node.getContent().getCountSum();\n            }\n        }\n        str.append(\"Tree summary\").append(\"\\n\");\n        for (int l : nodeCountPerLvl.getSortedIndices()) {\n            int obsCount = obsCountPerLvl.getCount(l);\n            int subtreeObsCount = subtreeObsCountPerLvl.getCount(l);\n            int nodeCount = nodeCountPerLvl.getCount(l);\n            str.append(\"\\t>>> \").append(l)\n                    .append(\" [\")\n                    .append(nodeCount)\n                    .append(\"] [\").append(obsCount)\n                    .append(\", \").append(MiscUtils.formatDouble((double) obsCount / nodeCount))\n                    .append(\", \").append(MiscUtils.formatDouble((double) 100 * obsCount / numTokens)).append(\"%\")\n                    .append(\"] [\").append(subtreeObsCount)\n                    .append(\", \").append(MiscUtils.formatDouble((double) subtreeObsCount / nodeCount))\n                    .append(\", \").append(MiscUtils.formatDouble((double) 100 * subtreeObsCount / numTokens)).append(\"%\")\n                    .append(\"]\\n\");\n        }\n        str.append(\"\\t>>> # observations = \").append(totalNumObs).append(\"\\n\");\n        str.append(\"\\t>>> # nodes = \").append(nodeCountPerLvl.getCountSum()).append(\"\\n\");\n        return str.toString();\n    }\n    /**\n     * Output top words for each topic in the tree to text file.\n     *\n     * @param outputFile The output file\n     * @param numWords Number of top words\n     */\n    @Override\n    public void outputTopicTopWords(File outputFile, int numWords) {\n        if (this.wordVocab == null) {\n            throw new RuntimeException(\"The word vocab has not been assigned yet\");\n        }\n        if (verbose) {\n            logln(\"Outputing top words to file \" + outputFile);\n        }\n        StringBuilder str = new StringBuilder();\n        Stack<Node> stack = new Stack<Node>();\n        stack.add(root);\n        while (!stack.isEmpty()) {\n            Node node = stack.pop();\n            String indentation = node.getIndentation();\n            ArrayList<RankingItem<Node>> rankChildren = new ArrayList<RankingItem<Node>>();\n            for (Node child : node.getChildren()) {\n                rankChildren.add(new RankingItem<Node>(child, child.eta));\n            }\n            Collections.sort(rankChildren);\n            for (RankingItem<Node> item : rankChildren) {\n                stack.add(item.getObject());\n            }\n            // top words according to the distribution\n            str.append(indentation);\n            str.append(node.getPathString())\n                    .append(\" (\")\n                    .append(node.born).append(\"; \")\n                    .append(node.getContent().getCountSum()).append(\"; \")\n                    //.append(MiscUtils.formatDouble(node.eta)).append(\"; eta: \")\n                    .append(MiscUtils.formatDouble(node.pathEta))\n                    .append(\")\");\n            str.append(\" \");\n            if (!node.isEmpty()) {\n                // words with highest probabilities at subtree\n                if (node.getLevel() < L - 1) {\n                    String[] subtreeTopWords = node.getSubtreeTopWords(numWords);\n//                    str.append(indentation);\n                    for (String topWord : subtreeTopWords) {\n                        str.append(topWord).append(\" \");\n                    }\n                    str.append(\"\\n\");\n                } else { // words with highest probabilities at node\n                    String[] nodeTopWords = node.getNodeTopWords(numWords);\n//                    str.append(indentation);\n                    for (String topWord : nodeTopWords) {\n                        str.append(topWord).append(\" \");\n                    }\n                    str.append(\"\\n\");\n                }\n                // top assigned words\n//                str.append(indentation);\n//                str.append(node.getTopObservations()).append(\"\\n\\n\");\n            }\n            str.append(\"\\n\");\n        }\n        try {\n            BufferedWriter writer = IOUtils.getBufferedWriter(outputFile);\n            writer.write(str.toString());\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"Exception while outputing topics \"\n                    + outputFile);\n        }\n    }\n    /**\n     * Output posterior distribution over non-rooted nodes in the tree of all\n     * documents.\n     *\n     * @param outputFile Output file\n     */\n    public void outputNodePosteriors(File outputFile) {\n        ArrayList<Node> nodeList = getNodeList();\n        try {\n            BufferedWriter writer = IOUtils.getBufferedWriter(outputFile);\n            for (int dd = 0; dd < D; dd++) {\n                double[] nodePos = new double[nodeList.size()];\n                for (int kk = 0; kk < nodeList.size(); kk++) {\n                    Node node = nodeList.get(kk);\n                    nodePos[kk] = (double) node.nodeDocCounts.getCount(dd) / words[dd].length;\n                }\n                writer.write(Integer.toString(dd));\n                for (int kk = 0; kk < nodePos.length; kk++) {\n                    writer.write(\"\\t\" + nodePos[kk]);\n                }\n                writer.write(\"\\n\");\n            }\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"Exception while output to \" + outputFile);\n        }\n    }\n    class Node extends TreeNode<Node, DirMult> {\n        protected final int born;\n        protected SparseCount subtreeDocCounts;\n        protected SparseCount nodeDocCounts;\n        protected double[] theta;\n        protected double pi;\n        protected double eta;\n        protected double pathEta;\n        protected SparseCount subtreeWordCounts;\n        public Node(int iter, int index, int level, DirMult content, Node parent,\n                double eta) {\n            super(index, level, content, parent);\n            this.born = iter;\n            this.subtreeDocCounts = new SparseCount();\n            this.nodeDocCounts = new SparseCount();\n            this.eta = eta;\n            this.subtreeWordCounts = new SparseCount();\n        }\n        void incrementSubtreeWordCount(int vv) {\n            subtreeWordCounts.increment(vv); // currently only for maximal assumption\n        }\n        void decrementSubtreeWordCount(int vv) {\n            subtreeWordCounts.decrement(vv); // currently only for maximal assumption\n        }\n        double getNodeWordProbability(int vv) {\n            return this.content.getProbability(vv);\n        }\n        double getSubtreeWordProbability(int vv) {\n            return (content.getCount(vv) + subtreeWordCounts.getCount(vv)\n                    + content.getConcentration() * content.getCenterElement(vv))\n                    / (content.getCountSum() + subtreeWordCounts.getCountSum()\n                    + content.getConcentration());\n        }\n        void setPathEta(double pathEta) {\n            this.pathEta = pathEta;\n        }\n        void initializeGlobalPi() {\n            this.pi = getPi(level);\n        }\n        void initializeGlobalTheta() {\n            int KK = getNumChildren();\n            this.theta = new double[KK];\n            Arrays.fill(this.theta, 1.0 / KK);\n        }\n        /**\n         * Return the number of tokens of a given document which are assigned to\n         * any nodes below this node.\n         *\n         * @param dd Document index\n         */\n        int getPassingCount(int dd) {\n            return subtreeDocCounts.getCount(dd) - nodeDocCounts.getCount(dd);\n        }\n        boolean isEmpty() {\n            return this.getContent().isEmpty();\n        }\n        String[] getNodeTopWords(int numTopWords) {\n            double[] phi = new double[V];\n            for (int vv = 0; vv < V; vv++) {\n                phi[vv] = getNodeWordProbability(vv);\n            }\n            ArrayList<RankingItem<String>> topicSortedVocab\n                    = IOUtils.getSortedVocab(phi, wordVocab);\n            String[] topWords = new String[numTopWords];\n            for (int i = 0; i < numTopWords; i++) {\n                topWords[i] = topicSortedVocab.get(i).getObject();\n            }\n            return topWords;\n        }\n        String[] getSubtreeTopWords(int numTopWords) {\n            double[] phi = new double[V];\n            for (int vv = 0; vv < V; vv++) {\n                phi[vv] = getSubtreeWordProbability(vv);\n            }\n            ArrayList<RankingItem<String>> topicSortedVocab\n                    = IOUtils.getSortedVocab(phi, wordVocab);\n            String[] topWords = new String[numTopWords];\n            for (int i = 0; i < numTopWords; i++) {\n                topWords[i] = topicSortedVocab.get(i).getObject();\n            }\n            return topWords;\n        }\n        String getTopObservations() {\n            return getTopObservations(getContent().getSparseCounts());\n        }\n        String getTopObservations(SparseCount counts) {\n            ArrayList<RankingItem<Integer>> rankObs = new ArrayList<RankingItem<Integer>>();\n            for (int obs : counts.getIndices()) {\n                rankObs.add(new RankingItem<Integer>(obs, counts.getCount(obs)));\n            }\n            Collections.sort(rankObs);\n            StringBuilder str = new StringBuilder();\n            for (int ii = 0; ii < Math.min(10, rankObs.size()); ii++) {\n                RankingItem<Integer> obs = rankObs.get(ii);\n                str.append(wordVocab.get(obs.getObject())).append(\":\")\n                        .append(obs.getPrimaryValue()).append(\" \");\n            }\n            return str.toString();\n        }\n        void validate(String msg) {\n            this.nodeDocCounts.validate(msg);\n            this.subtreeDocCounts.validate(msg);\n            if (theta != null && theta.length != getNumChildren()) {\n                throw new RuntimeException(msg + \". MISMATCH. \" + this.toString());\n            }\n        }\n        @Override\n        public String toString() {\n            StringBuilder str = new StringBuilder();\n            str.append(\"[\").append(getPathString());\n            str.append(\", \").append(born);\n            str.append(\", c (\").append(getChildren().size()).append(\")\");\n            // word types\n            str.append(\", (\").append(getContent().getCountSum()).append(\")\");\n            // token counts\n            str.append(\", (\").append(subtreeDocCounts.getCountSum());\n            str.append(\", \").append(nodeDocCounts.getCountSum()).append(\")\");\n            str.append(\", \").append(MiscUtils.formatDouble(eta));\n            str.append(\", \").append(MiscUtils.formatDouble(pathEta));\n            str.append(\"]\");\n            return str.toString();\n        }\n        String getIndentation() {\n            StringBuilder str = new StringBuilder();\n            for (int i = 0; i < this.getLevel(); i++) {\n                str.append(\"\\t\");\n            }\n            return str.toString();\n        }\n    }\n    public static String getHelpString() {\n        return \"java -cp 'dist/segan.jar' \" + SNLDA.class.getName() + \" -help\";\n    }\n    public static String getExampleCmd() {\n        String example = new String();\n        return example;\n    }\n    private static void addOpitions() throws Exception {\n        parser = new BasicParser();\n        options = new Options();\n        // data input\n        addOption(\"dataset\", \"Dataset\");\n        addOption(\"word-voc-file\", \"Word vocabulary file\");\n        addOption(\"word-file\", \"Document word file\");\n        addOption(\"info-file\", \"Document info file\");\n        addOption(\"selected-docs-file\", \"(Optional) Indices of selected documents\");\n        addOption(\"prior-topic-file\", \"File containing prior topics\");\n        addOption(\"init-eta-file\", \"File containing initial etas\");\n        addOption(\"num-top-words\", \"Number of top words per topic\");\n        // data output\n        addOption(\"output-folder\", \"Output folder\");\n        // sampling\n        addSamplingOptions();\n        // parameters\n        addOption(\"alphas\", \"Alpha\");\n        addOption(\"betas\", \"Beta\");\n        addOption(\"pis\", \"Mean\");\n        addOption(\"gammas\", \"Scale\");\n        addOption(\"rho\", \"Rho\");\n        addOption(\"mu\", \"Mu\");\n        addOption(\"sigmas\", \"Sigmas\");\n        addOption(\"Ks\", \"Number of topics\");\n        addOption(\"path\", \"Path assumption\");\n        // configurations\n        addOption(\"init\", \"Initialization\");\n        options.addOption(\"train\", false, \"train\");\n        options.addOption(\"test\", false, \"test\");\n        options.addOption(\"parallel\", false, \"parallel\");\n        options.addOption(\"v\", false, \"verbose\");\n        options.addOption(\"d\", false, \"debug\");\n        options.addOption(\"z\", false, \"z-normalize\");\n        options.addOption(\"help\", false, \"Help\");\n        options.addOption(\"example\", false, \"Example command\");\n        options.addOption(\"binary\", false, \"Binary responses\");\n        options.addOption(\"root\", false, \"Is rooted\");\n    }\n    private static void runModel() throws Exception {\n        // sampling configurations\n        int numTopWords = CLIUtils.getIntegerArgument(cmd, \"num-top-words\", 20);\n        int burnIn = CLIUtils.getIntegerArgument(cmd, \"burnIn\", 500);\n        int maxIters = CLIUtils.getIntegerArgument(cmd, \"maxIter\", 1000);\n        int sampleLag = CLIUtils.getIntegerArgument(cmd, \"sampleLag\", 50);\n        int repInterval = CLIUtils.getIntegerArgument(cmd, \"report\", 25);\n        boolean paramOpt = cmd.hasOption(\"paramOpt\");\n        String init = CLIUtils.getStringArgument(cmd, \"init\", \"random\");\n        InitialState initState;\n        switch (init) {\n            case \"random\":\n                initState = InitialState.RANDOM;\n                break;\n            case \"preset\":\n                initState = InitialState.PRESET;\n                break;\n            default:\n                throw new RuntimeException(\"Initialization \" + init + \" not supported\");\n        }\n        // model parameters\n        int[] Ks = CLIUtils.getIntArrayArgument(cmd, \"Ks\", new int[]{15, 4}, \",\");\n        int L = Ks.length + 1;\n        double[] alphas = CLIUtils.getDoubleArrayArgument(cmd, \"alphas\", new double[]{2.0, 1.0}, \",\");\n        double[] betas = CLIUtils.getDoubleArrayArgument(cmd, \"betas\", new double[]{0.5, 0.25, 0.1}, \",\");\n        double[] pis = CLIUtils.getDoubleArrayArgument(cmd, \"pis\", new double[]{0.2, 0.2}, \",\");\n        double[] gammas = CLIUtils.getDoubleArrayArgument(cmd, \"gammas\", new double[]{100, 10}, \",\");\n        double rho = CLIUtils.getDoubleArgument(cmd, \"rho\", 1.0);\n        double mu = CLIUtils.getDoubleArgument(cmd, \"mu\", 0.0);\n        double[] sigmas = CLIUtils.getDoubleArrayArgument(cmd, \"sigmas\", new double[]{0.5, 2.5}, \",\");\n        String path = CLIUtils.getStringArgument(cmd, \"path\", \"none\");\n        PathAssumption pathAssumption = getPathAssumption(path);\n        // data input\n        String datasetName = cmd.getOptionValue(\"dataset\");\n        String wordVocFile = cmd.getOptionValue(\"word-voc-file\");\n        String docWordFile = cmd.getOptionValue(\"word-file\");\n        // data output\n        String outputFolder = cmd.getOptionValue(\"output-folder\");\n        double[][] priorTopics = null;\n        if (cmd.hasOption(\"prior-topic-file\")) {\n            String priorTopicFile = cmd.getOptionValue(\"prior-topic-file\");\n            priorTopics = IOUtils.input2DArray(new File(priorTopicFile));\n        }\n        double[] initEtas = null;\n        if (cmd.hasOption(\"init-eta-file\")) {\n            String initEtaFile = cmd.getOptionValue(\"init-eta-file\");\n            initEtas = IOUtils.inputArray(new File(initEtaFile));\n        }\n        File docInfoFile = null;\n        if (cmd.hasOption(\"info-file\")) {\n            docInfoFile = new File(cmd.getOptionValue(\"info-file\"));\n        }\n        SNLDA sampler = new SNLDA();\n        sampler.setVerbose(cmd.hasOption(\"v\"));\n        sampler.setDebug(cmd.hasOption(\"d\"));\n        sampler.setLog(true);\n        sampler.setReport(true);\n        boolean isBinary = cmd.hasOption(\"binary\");\n        boolean isRooted = cmd.hasOption(\"root\");\n        ResponseTextDataset contData = new ResponseTextDataset(datasetName);\n        LabelTextDataset binData = new LabelTextDataset(datasetName);\n        int V;\n        if (isBinary) {\n            binData.loadFormattedData(new File(wordVocFile),\n                    new File(docWordFile),\n                    docInfoFile,\n                    null);\n            V = binData.getWordVocab().size();\n            sampler.setWordVocab(binData.getWordVocab());\n            sampler.configureBinary(outputFolder, V, Ks,\n                    alphas, betas, pis, gammas, mu, sigmas,\n                    initState, pathAssumption, paramOpt, isRooted,\n                    burnIn, maxIters, sampleLag, repInterval);\n        } else {\n            contData.loadFormattedData(new File(wordVocFile),\n                    new File(docWordFile),\n                    docInfoFile,\n                    null);\n            V = contData.getWordVocab().size();\n            sampler.setWordVocab(contData.getWordVocab());\n            sampler.configureContinuous(outputFolder, V, Ks,\n                    alphas, betas, pis, gammas, rho, mu, sigmas,\n                    initState, pathAssumption, paramOpt, isRooted,\n                    burnIn, maxIters, sampleLag, repInterval);\n        }\n        File samplerFolder = new File(sampler.getSamplerFolderPath());\n        IOUtils.createFolder(samplerFolder);\n        if (isTraining()) {\n            ArrayList<Integer> trainDocIndices;\n            if (isBinary) {\n                trainDocIndices = sampler.getSelectedDocIndices(binData.getDocIds());\n                sampler.train(binData.getWords(), trainDocIndices, binData.getSingleLabels());\n            } else {\n                trainDocIndices = sampler.getSelectedDocIndices(contData.getDocIds());\n                double[] docResponses = contData.getResponses();\n                if (cmd.hasOption(\"z\")) { // z-normalization\n                    ZNormalizer zNorm = new ZNormalizer(docResponses);\n                    docResponses = zNorm.normalize(docResponses);\n                }\n                sampler.train(contData.getWords(), trainDocIndices, docResponses);\n            }\n            sampler.initialize(priorTopics, initEtas);\n            sampler.metaIterate();\n            sampler.outputTopicTopWords(new File(samplerFolder, TopWordFile), numTopWords);\n            sampler.outputNodePosteriors(new File(samplerFolder, \"train-node-posteriors.txt\"));\n        }\n        if (isTesting()) {\n            int[][] testWords;\n            ArrayList<Integer> testDocIndices;\n            if (isBinary) {\n                testWords = binData.getWords();\n                testDocIndices = sampler.getSelectedDocIndices(binData.getDocIds());\n            } else {\n                testWords = contData.getWords();\n                testDocIndices = sampler.getSelectedDocIndices(contData.getDocIds());\n            }\n            File testAssignmentFolder = new File(samplerFolder, AbstractSampler.IterAssignmentFolder);\n            IOUtils.createFolder(testAssignmentFolder);\n            File testPredFolder = new File(samplerFolder, AbstractSampler.IterPredictionFolder);\n            IOUtils.createFolder(testPredFolder);\n            double[] predictions;\n            if (cmd.hasOption(\"parallel\")) { // using multiple stored models\n                predictions = SNLDA.parallelTest(testWords, testDocIndices, testPredFolder, testAssignmentFolder, sampler);\n            } else { // using the last model\n                File stateFile = sampler.getFinalStateFile();\n                File outputPredFile = new File(testPredFolder, \"iter-\" + sampler.MAX_ITER + \".txt\");\n                File outputStateFile = new File(testPredFolder, \"iter-\" + sampler.MAX_ITER + \".zip\");\n                sampler.test(testWords, testDocIndices);\n                predictions = sampler.sampleTest(stateFile, outputStateFile, outputPredFile);\n                sampler.outputNodePosteriors(new File(samplerFolder, \"test-node-posteriors.txt\"));\n            }\n            File teResultFolder = new File(samplerFolder,\n                    AbstractExperiment.TEST_PREFIX + AbstractExperiment.RESULT_FOLDER);\n            IOUtils.createFolder(teResultFolder);\n            if (isBinary) {\n                PredictionUtils.outputClassificationPredictions(\n                        new File(teResultFolder, AbstractExperiment.PREDICTION_FILE),\n                        binData.getDocIds(), binData.getSingleLabels(), predictions);\n                PredictionUtils.outputBinaryClassificationResults(\n                        new File(teResultFolder, AbstractExperiment.RESULT_FILE),\n                        binData.getSingleLabels(), predictions);\n            } else {\n                double[] docResponses = contData.getResponses();\n                if (cmd.hasOption(\"z\")) { // z-normalization\n                    ZNormalizer zNorm = new ZNormalizer(docResponses);\n                    docResponses = zNorm.normalize(docResponses);\n                }\n                PredictionUtils.outputRegressionPredictions(\n                        new File(teResultFolder, AbstractExperiment.PREDICTION_FILE),\n                        contData.getDocIds(), docResponses, predictions);\n                PredictionUtils.outputRegressionResults(\n                        new File(teResultFolder, AbstractExperiment.RESULT_FILE), docResponses,\n                        predictions);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        try {\n            long sTime = System.currentTimeMillis();\n            addOpitions();\n            cmd = parser.parse(options, args);\n            if (cmd.hasOption(\"help\")) {\n                CLIUtils.printHelp(getHelpString(), options);\n                return;\n            } else if (cmd.hasOption(\"example\")) {\n                System.out.println(getExampleCmd());\n                return;\n            }\n            runModel();\n            // date and time\n            DateFormat df = new SimpleDateFormat(\"dd/MM/yy HH:mm:ss\");\n            Date dateobj = new Date();\n            long eTime = (System.currentTimeMillis() - sTime) / 1000;\n            System.out.println(\"Elapsed time: \" + eTime + \"s\");\n            System.out.println(\"End time: \" + df.format(dateobj));\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException();\n        }\n    }\n    /**\n     * Run Gibbs sampling on test data using multiple models learned which are\n     * stored in the ReportFolder. The runs on multiple models are parallel.\n     *\n     * @param newWords Words of new documents\n     * @param newDocIndices Indices of test documents\n     * @param iterPredFolder Output folder\n     * @param iterStateFolder Folder to store assignments\n     * @param sampler The configured sampler\n     */\n    public static double[] parallelTest(int[][] newWords,\n            ArrayList<Integer> newDocIndices,\n            File iterPredFolder,\n            File iterStateFolder,\n            SNLDA sampler) {\n        File reportFolder = new File(sampler.getSamplerFolderPath(), ReportFolder);\n        if (!reportFolder.exists()) {\n            throw new RuntimeException(\"Report folder not found. \" + reportFolder);\n        }\n        String[] filenames = reportFolder.list();\n        double[] avgPredictions = null;\n        try {\n            IOUtils.createFolder(iterPredFolder);\n            ArrayList<Thread> threads = new ArrayList<Thread>();\n            ArrayList<File> partPredFiles = new ArrayList<>();\n            for (String filename : filenames) { // all learned models\n                if (!filename.contains(\"zip\")) {\n                    continue;\n                }\n                File stateFile = new File(reportFolder, filename);\n                String stateFilename = IOUtils.removeExtension(filename);\n                File iterOutputPredFile = new File(iterPredFolder, stateFilename + \".txt\");\n                File iterOutputStateFile = new File(iterStateFolder, stateFilename + \".zip\");\n                SNLDATestRunner runner = new SNLDATestRunner(sampler,\n                        newWords, newDocIndices,\n                        stateFile.getAbsolutePath(),\n                        iterOutputStateFile.getAbsolutePath(),\n                        iterOutputPredFile.getAbsolutePath());\n                Thread thread = new Thread(runner);\n                threads.add(thread);\n                partPredFiles.add(iterOutputPredFile);\n            }\n            // run MAX_NUM_PARALLEL_THREADS threads at a time\n            runThreads(threads);\n            // average predictions\n            avgPredictions = PredictionUtils.computeMultipleAverage(partPredFiles);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"Exception while sampling during parallel test.\");\n        }\n        return avgPredictions;\n    }\n"]]}
{"hexsha": "5f7a618a8e16cdac37543c338859de1a98fbe8b1", "ext": "java", "lang": "Java", "content": "final class DisplayManager {\n\n  private final Model model;\n  private final int boardWidth;\n  private final int boardHeight;\n\n  /**\n   * Constructor for the display manager\n   *\n   * @param model       the model (board) of the level\n   * @param boardWidth  the width of the board\n   * @param boardHeight the height of the board\n   */\n  DisplayManager(Model model, int boardWidth, int boardHeight) {\n    Objects.requireNonNull(model);\n    if (boardWidth <= 0 || boardHeight <= 0) {\n      throw new IllegalArgumentException(\"boardWidth <= 0 || boardHeight <= 0\");\n    }\n    this.model = model;\n    this.boardWidth = boardWidth;\n    this.boardHeight = boardHeight;\n  }\n\n  private void drawBoard(Graphics2D graphics, int startX , int startY, int squareSize) {\n    Objects.requireNonNull(graphics);\n    graphics.setColor(Color.GRAY);\n    var width = boardWidth * squareSize;\n    var height = boardHeight * squareSize;\n    for (int i = 0; i <= boardHeight; i++) {\n      graphics.fill(new Rectangle2D.Float(startX, i * squareSize, width, 1));\n    }\n    for (int j = 0; j <= boardWidth; j++) {\n      graphics.fill(new Rectangle2D.Float(j * squareSize, startY, 1, height));\n    }\n  }\n\n  private void drawElements(Graphics2D graphics, List<Displayable> elements, int x, int y, int squareSize) {\n    for (var element : elements) {\n      graphics.drawImage(element.image().getImage(),\n          x + (element.x() * squareSize) + 1, y + (element.y() * squareSize) + 1,\n          squareSize - 1, squareSize - 1, null);\n    }\n  }\n\n  /**\n   * Renders and displays a frame\n   *\n   * @param graphics the graphic engine zone\n   * @param x        the x coordinate of the top left corner\n   * @param y        the y coordinate of the top left corner\n   * @param width    the width of the viewport\n   * @param height   the height of the viewport\n   */\n  void display(Graphics2D graphics, int x, int y, int width, int height) {\n    Objects.requireNonNull(graphics);\n    if (width < 0 || height < 0) {\n      throw new IllegalArgumentException(\"width < 0 || height < 0\");\n    }\n    var squareSize = Math.min(width / boardWidth, height / boardHeight);\n    drawBoard(graphics, x, y, squareSize);\n    drawElements(graphics, model.displayableElements(), x, y, squareSize);\n  }\n}", "class_id": 0, "repo": "notKamui/Java-is-You", "file": "src/com/notkamui/javaisyou/engine/manager/DisplayManager.java", "last_update_at": "2020-12-14T01:16:37+00:00", "question_id": "5f7a618a8e16cdac37543c338859de1a98fbe8b1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["final class DisplayManager {\n  private final Model model;\n  private final int boardWidth;\n  private final int boardHeight;\n  /**\n   * Constructor for the display manager\n   *\n   * @param model       the model (board) of the level\n   * @param boardWidth  the width of the board\n   * @param boardHeight the height of the board\n   */\n  DisplayManager(Model model, int boardWidth, int boardHeight) {\n    Objects.requireNonNull(model);\n    if (boardWidth <= 0 || boardHeight <= 0) {\n      throw new IllegalArgumentException(\"boardWidth <= 0 || boardHeight <= 0\");\n    }\n    this.model = model;\n    this.boardWidth = boardWidth;\n    this.boardHeight = boardHeight;\n  }\n  private void drawBoard(Graphics2D graphics, int startX , int startY, int squareSize) {\n    Objects.requireNonNull(graphics);\n    graphics.setColor(Color.GRAY);\n    var width = boardWidth * squareSize;\n    var height = boardHeight * squareSize;\n    for (int i = 0; i <= boardHeight; i++) {\n      graphics.fill(new Rectangle2D.Float(startX, i * squareSize, width, 1));\n    }\n    for (int j = 0; j <= boardWidth; j++) {\n      graphics.fill(new Rectangle2D.Float(j * squareSize, startY, 1, height));\n    }\n  }\n  private void drawElements(Graphics2D graphics, List<Displayable> elements, int x, int y, int squareSize) {\n    for (var element : elements) {\n      graphics.drawImage(element.image().getImage(),\n          x + (element.x() * squareSize) + 1, y + (element.y() * squareSize) + 1,\n          squareSize - 1, squareSize - 1, null);\n    }\n  }\n  /**\n   * Renders and displays a frame\n   *\n   * @param graphics the graphic engine zone\n   * @param x        the x coordinate of the top left corner\n   * @param y        the y coordinate of the top left corner\n   * @param width    the width of the viewport\n   * @param height   the height of the viewport\n   */\n  void display(Graphics2D graphics, int x, int y, int width, int height) {\n    Objects.requireNonNull(graphics);\n    if (width < 0 || height < 0) {\n      throw new IllegalArgumentException(\"width < 0 || height < 0\");\n    }\n    var squareSize = Math.min(width / boardWidth, height / boardHeight);\n    drawBoard(graphics, x, y, squareSize);\n    drawElements(graphics, model.displayableElements(), x, y, squareSize);\n  }\n"]]}
{"hexsha": "c5eecbac28a15c265e1d8b614660d6c86efff699", "ext": "java", "lang": "Java", "content": "public class SnappyCodec implements Configurable, CompressionCodec {\r\n  public static final String SNAPPY_BUFFER_SIZE_KEY = \"io.compression.codec.snappy.buffersize\";\r\n  public static final int DEFAULT_SNAPPY_BUFFER_SIZE = 256 * 1024;\r\n\r\n  Configuration conf;\r\n\r\n  public void setConf(Configuration conf) {\r\n    this.conf = conf;\r\n  }\r\n\r\n  public Configuration getConf() {\r\n    return conf;\r\n  }\r\n\r\n  private static boolean nativeSnappyLoaded = false;\r\n\r\n  static {\r\n    if (SnappyNativeCodeLoader.isNativeCodeLoaded()) {\r\n      nativeSnappyLoaded = SnappyCompressor.isNativeSnappyLoaded()\r\n          && SnappyDecompressor.isNativeSnappyLoaded();\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Are the native snappy libraries loaded & initialized? \r\n   * \r\n   * @param conf configuration\r\n   * @return true if loaded & initialized, otherwise false\r\n   */\r\n  public static boolean isNativeSnappyLoaded(Configuration conf) {\r\n    return nativeSnappyLoaded && conf.getBoolean(\"hadoop.native.lib\", true);\r\n  }\r\n\r\n  public CompressionOutputStream createOutputStream(OutputStream out)\r\n      throws IOException {\r\n    return createOutputStream(out, createCompressor());\r\n  }\r\n\r\n  public CompressionOutputStream createOutputStream(OutputStream out,\r\n      Compressor compressor) throws IOException {\r\n    if (!isNativeSnappyLoaded(conf)) {\r\n      throw new RuntimeException(\"native snappy library not available\");\r\n    }\r\n    int bufferSize = conf.getInt(SNAPPY_BUFFER_SIZE_KEY,\r\n        DEFAULT_SNAPPY_BUFFER_SIZE);\r\n\r\n    int compressionOverhead = (bufferSize >> 3) + 128 + 3;\r\n    // int compressionOverhead = 0;\r\n\r\n    return new BlockCompressorStream(out, compressor, bufferSize,\r\n        compressionOverhead);\r\n  }\r\n\r\n  public Class<? extends Compressor> getCompressorType() {\r\n    if (!isNativeSnappyLoaded(conf)) {\r\n      throw new RuntimeException(\"native snappy library not available\");\r\n    }\r\n\r\n    return SnappyCompressor.class;\r\n  }\r\n\r\n  public Compressor createCompressor() {\r\n    if (!isNativeSnappyLoaded(conf)) {\r\n      throw new RuntimeException(\"native snappy library not available\");\r\n    }\r\n    int bufferSize = conf.getInt(SNAPPY_BUFFER_SIZE_KEY,\r\n        DEFAULT_SNAPPY_BUFFER_SIZE);\r\n    return new SnappyCompressor(bufferSize);\r\n  }\r\n\r\n  public CompressionInputStream createInputStream(InputStream in)\r\n      throws IOException {\r\n    return createInputStream(in, createDecompressor());\r\n  }\r\n\r\n  public CompressionInputStream createInputStream(InputStream in,\r\n      Decompressor decompressor) throws IOException {\r\n    if (!isNativeSnappyLoaded(conf)) {\r\n      throw new RuntimeException(\"native snappy library not available\");\r\n    }\r\n\r\n    return new BlockDecompressorStream(in, decompressor, conf.getInt(\r\n        SNAPPY_BUFFER_SIZE_KEY, DEFAULT_SNAPPY_BUFFER_SIZE));\r\n  }\r\n\r\n  public Class<? extends Decompressor> getDecompressorType() {\r\n    if (!isNativeSnappyLoaded(conf)) {\r\n      throw new RuntimeException(\"native snappy library not available\");\r\n    }\r\n\r\n    return SnappyDecompressor.class;\r\n  }\r\n\r\n  public Decompressor createDecompressor() {\r\n    if (!isNativeSnappyLoaded(conf)) {\r\n      throw new RuntimeException(\"native snappy library not available\");\r\n    }\r\n    int bufferSize = conf.getInt(SNAPPY_BUFFER_SIZE_KEY,\r\n        DEFAULT_SNAPPY_BUFFER_SIZE);\r\n    return new SnappyDecompressor(bufferSize);\r\n  }\r\n\r\n  public String getDefaultExtension() {\r\n    return \".snappy\";\r\n  }\r\n}", "class_id": 0, "repo": "abayer/hst", "file": "src/main/java/org/apache/hadoop/io/compress/SnappyCodec.java", "last_update_at": "2020-01-09T15:48:01+00:00", "question_id": "c5eecbac28a15c265e1d8b614660d6c86efff699", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SnappyCodec implements Configurable, CompressionCodec {\r\n  public static final String SNAPPY_BUFFER_SIZE_KEY = \"io.compression.codec.snappy.buffersize\";\r\n  public static final int DEFAULT_SNAPPY_BUFFER_SIZE = 256 * 1024;\r\n\r\n  Configuration conf;\r\n\r\n  public void setConf(Configuration conf) {\r\n    this.conf = conf;\r\n  }\r\n\r\n  public Configuration getConf() {\r\n    return conf;\r\n  }\r\n\r\n  private static boolean nativeSnappyLoaded = false;\r\n\r\n  static {\r\n    if (SnappyNativeCodeLoader.isNativeCodeLoaded()) {\r\n      nativeSnappyLoaded = SnappyCompressor.isNativeSnappyLoaded()\r\n          && SnappyDecompressor.isNativeSnappyLoaded();\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Are the native snappy libraries loaded & initialized? \r\n   * \r\n   * @param conf configuration\r\n   * @return true if loaded & initialized, otherwise false\r\n   */\r\n  public static boolean isNativeSnappyLoaded(Configuration conf) {\r\n    return nativeSnappyLoaded && conf.getBoolean(\"hadoop.native.lib\", true);\r\n  }\r\n\r\n  public CompressionOutputStream createOutputStream(OutputStream out)\r\n      throws IOException {\r\n    return createOutputStream(out, createCompressor());\r\n  }\r\n\r\n  public CompressionOutputStream createOutputStream(OutputStream out,\r\n      Compressor compressor) throws IOException {\r\n    if (!isNativeSnappyLoaded(conf)) {\r\n      throw new RuntimeException(\"native snappy library not available\");\r\n    }\r\n    int bufferSize = conf.getInt(SNAPPY_BUFFER_SIZE_KEY,\r\n        DEFAULT_SNAPPY_BUFFER_SIZE);\r\n\r\n    int compressionOverhead = (bufferSize >> 3) + 128 + 3;\r\n    // int compressionOverhead = 0;\r\n\r\n    return new BlockCompressorStream(out, compressor, bufferSize,\r\n        compressionOverhead);\r\n  }\r\n\r\n  public Class<? extends Compressor> getCompressorType() {\r\n    if (!isNativeSnappyLoaded(conf)) {\r\n      throw new RuntimeException(\"native snappy library not available\");\r\n    }\r\n\r\n    return SnappyCompressor.class;\r\n  }\r\n\r\n  public Compressor createCompressor() {\r\n    if (!isNativeSnappyLoaded(conf)) {\r\n      throw new RuntimeException(\"native snappy library not available\");\r\n    }\r\n    int bufferSize = conf.getInt(SNAPPY_BUFFER_SIZE_KEY,\r\n        DEFAULT_SNAPPY_BUFFER_SIZE);\r\n    return new SnappyCompressor(bufferSize);\r\n  }\r\n\r\n  public CompressionInputStream createInputStream(InputStream in)\r\n      throws IOException {\r\n    return createInputStream(in, createDecompressor());\r\n  }\r\n\r\n  public CompressionInputStream createInputStream(InputStream in,\r\n      Decompressor decompressor) throws IOException {\r\n    if (!isNativeSnappyLoaded(conf)) {\r\n      throw new RuntimeException(\"native snappy library not available\");\r\n    }\r\n\r\n    return new BlockDecompressorStream(in, decompressor, conf.getInt(\r\n        SNAPPY_BUFFER_SIZE_KEY, DEFAULT_SNAPPY_BUFFER_SIZE));\r\n  }\r\n\r\n  public Class<? extends Decompressor> getDecompressorType() {\r\n    if (!isNativeSnappyLoaded(conf)) {\r\n      throw new RuntimeException(\"native snappy library not available\");\r\n    }\r\n\r\n    return SnappyDecompressor.class;\r\n  }\r\n\r\n  public Decompressor createDecompressor() {\r\n    if (!isNativeSnappyLoaded(conf)) {\r\n      throw new RuntimeException(\"native snappy library not available\");\r\n    }\r\n    int bufferSize = conf.getInt(SNAPPY_BUFFER_SIZE_KEY,\r\n        DEFAULT_SNAPPY_BUFFER_SIZE);\r\n    return new SnappyDecompressor(bufferSize);\r\n  }\r\n\r\n  public String getDefaultExtension() {\r\n    return \".snappy\";\r\n  }\r\n"]]}
{"hexsha": "cca4720897a5238d699d6f2848354504c689f40a", "ext": "java", "lang": "Java", "content": "public class ProcessingImageSignatureOverCRUD {\n\n    /**\n    * Following example shows how to process Image Signature over all signature life-cycle.\n    * First document is being signed with Image Signature, then verified for it, searched for same, updating and finally deleting this signature.\n    */\n    public static void run() throws Exception\n    {\n        System.out.print(\"\\n--------------------------------------------------------------------------------------------------------------------\");\n        System.out.print(\"[Example Advanced Usage] # ProcessingImageSignatureOverCRUD : Process Image Signature over all signature life-cycle\\n\");\n\n        // The path to the documents directory.\n        String filePath = Constants.SAMPLE_WORDPROCESSING;\n        String fileName = Paths.get(filePath).getFileName().toString();\n\n        String outputFilePath = new File(Constants.OutputPath, \"ProcessingImageSignatureOverCRUD\\\\\"+ fileName).getPath();\n        List<String> signatureIds = new ArrayList<String>();\n        // -----------------------------------------------------------------------------------------------------------------------------\n        // STEP 1. Sign document with Image Signature\n        // -----------------------------------------------------------------------------------------------------------------------------\n        Signature signature = new Signature(filePath);\n        {\n            ImageSignOptions signOptions = new ImageSignOptions(Constants.ImageHandwrite);\n            signOptions.setVerticalAlignment(VerticalAlignment.Top);\n            signOptions.setHorizontalAlignment(HorizontalAlignment.Center);\n            signOptions.setWidth(100);\n            signOptions.setHeight(40);\n            signOptions.setMargin(new Padding(20));\n\n            // sign document to file\n            SignResult signResult = signature.sign(outputFilePath, signOptions);\n            System.out.print(\"\\nDocument \"+filePath+\" was signed with following signatures:\");\n            for (BaseSignature temp : signResult.getSucceeded())\n            {\n                // collect newly created signature' Id\n                signatureIds.add(temp.getSignatureId());\n                System.out.print(\"Signature : \"+temp.getSignatureType()+\" Id:\"+temp.getSignatureId()+\", Location: \"+temp.getLeft()+\"x\"+temp.getTop()+\". Size: \"+temp.getWidth()+\"x\"+temp.getHeight());\n            }\n        }\n        // -----------------------------------------------------------------------------------------------------------------------------\n        // STEP 2. Search document for Image Signature\n        // -----------------------------------------------------------------------------------------------------------------------------\n        Signature signature2 = new Signature(outputFilePath);\n        {\n            ImageSearchOptions searchOptions = new ImageSearchOptions();\n            // specify special pages to search on\n            searchOptions.setAllPages(true);\n\n\n            // search for image signatures in document\n            List<ImageSignature> signatures = signature2.search(ImageSignature.class,searchOptions);\n            System.out.print(\"\\nSource document contains following Image signature(s).\");\n            // enumerate all signature for output\n            for (ImageSignature imageSignature : signatures)\n            {\n                if (imageSignature != null)\n                {\n                    System.out.print(\"Found Image signature at page \"+imageSignature.getPageNumber()+\" and Image Size '\"+imageSignature.getSize()+\"'.\");\n                    System.out.print(\"Location at \"+imageSignature.getLeft()+\"-\"+imageSignature.getTop()+\". Size is \"+imageSignature.getWidth()+\"x\"+imageSignature.getHeight()+\".\");\n                }\n            }\n            // -----------------------------------------------------------------------------------------------------------------------------\n            // STEP 3. Update document Image Signature after searching it\n            // -----------------------------------------------------------------------------------------------------------------------------\n            List<BaseSignature> signaturesToUpdate = new ArrayList<BaseSignature>();\n            for (ImageSignature imageSignature : signatures)\n            {\n                // change position\n                imageSignature.setLeft(imageSignature.getLeft() + 100);\n                imageSignature.setTop(imageSignature.getTop() + 100);\n                // change size. Please note not all documents support changing signature size\n                imageSignature.setWidth(200);\n                imageSignature.setHeight(50);\n                signaturesToUpdate.add(imageSignature);\n            }\n            UpdateResult updateResult = signature2.update(new ByteArrayOutputStream(), signaturesToUpdate);\n            if (updateResult.getSucceeded().size() == signatures.size())\n            {\n                System.out.print(\"\\nAll signatures were successfully updated!\");\n            }\n            else\n            {\n                System.out.print(\"Successfully updated signatures : \"+updateResult.getSucceeded().size());\n                System.out.print(\"Not updated signatures : \"+updateResult.getFailed().size());\n            }\n            System.out.print(\"List of updated signatures:\");\n            for (BaseSignature temp : updateResult.getSucceeded())\n            {\n                System.out.print(\"Signature# Id:\"+temp.getSignatureId()+\", Location: \"+temp.getLeft()+\"x\"+temp.getTop()+\". Size: \"+temp.getWidth()+\"x\"+temp.getHeight());\n            }\n            // -----------------------------------------------------------------------------------------------------------------------------\n            // STEP 4. Update document Image Signature on saved SignatureId\n            // create list of Image Signature by known SignatureId\n            // -----------------------------------------------------------------------------------------------------------------------------\n            signaturesToUpdate.clear();\n            for ( String item : signatureIds)\n            {\n                ImageSignature temp = new ImageSignature(item);\n                temp.setWidth(150);\n                temp.setHeight(30);\n                temp.setLeft(100);\n                temp.setTop(100);\n\n                signaturesToUpdate.add(temp);\n            }\n            // update all found signatures\n            updateResult = signature2.update(new ByteArrayOutputStream(), signaturesToUpdate);\n            if (updateResult.getSucceeded().size() == signatures.size())\n            {\n                System.out.print(\"\\nAll signatures were successfully updated!\");\n            }\n            else\n            {\n                System.out.print(\"Successfully updated signatures : \"+updateResult.getSucceeded().size());\n                System.out.print(\"Not updated signatures : \"+updateResult.getFailed().size());\n            }\n            System.out.print(\"List of updated signatures:\");\n            for (BaseSignature temp : updateResult.getSucceeded())\n            {\n                System.out.print(\"Signature# Id:\"+temp.getSignatureId()+\", Location: \"+temp.getLeft()+\"x\"+temp.getTop()+\". Size: \"+temp.getWidth()+\"x\"+temp.getHeight());\n            }\n            // -----------------------------------------------------------------------------------------------------------------------------\n            // STEP 5. Delete document Image Signature by id\n            // create list of Image Signature by known SignatureId\n            signaturesToUpdate.clear();\n            for (String item : signatureIds)\n            {\n                ImageSignature temp = new ImageSignature(item);\n                signaturesToUpdate.add(temp);\n            }\n            // delete all signatures\n            DeleteResult deleteResult = signature2.delete(new ByteArrayOutputStream(), signaturesToUpdate);\n            if (deleteResult.getSucceeded().size() == signaturesToUpdate.size())\n            {\n                System.out.print(\"\\nAll signatures were successfully deleted!\");\n            }\n            else\n            {\n                System.out.print(\"Successfully deleted signatures : \"+deleteResult.getSucceeded().size());\n                System.out.print(\"Not deleted signatures : \"+deleteResult.getFailed().size());\n            }\n            System.out.print(\"List of deleted signatures:\");\n            for (BaseSignature temp : deleteResult.getSucceeded())\n            {\n                System.out.print(\"Signature# Id:\"+temp.getSignatureId()+\", Location: \"+temp.getLeft()+\"x\"+temp.getTop()+\". Size: \"+temp.getWidth()+\"x\"+temp.getHeight());\n            }\n        }\n    }\n}", "class_id": 0, "repo": "groupdocs-signature/GroupDocs.Signature-for-Java", "file": "Examples/src/main/java/com/groupdocs/signature/examples/advanced_usage/crud/ProcessingImageSignatureOverCRUD.java", "last_update_at": "2020-08-07T13:27:43+00:00", "question_id": "cca4720897a5238d699d6f2848354504c689f40a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ProcessingImageSignatureOverCRUD {\n    /**\n    * Following example shows how to process Image Signature over all signature life-cycle.\n    * First document is being signed with Image Signature, then verified for it, searched for same, updating and finally deleting this signature.\n    */\n    public static void run() throws Exception\n    {\n        System.out.print(\"\\n--------------------------------------------------------------------------------------------------------------------\");\n        System.out.print(\"[Example Advanced Usage] # ProcessingImageSignatureOverCRUD : Process Image Signature over all signature life-cycle\\n\");\n        // The path to the documents directory.\n        String filePath = Constants.SAMPLE_WORDPROCESSING;\n        String fileName = Paths.get(filePath).getFileName().toString();\n        String outputFilePath = new File(Constants.OutputPath, \"ProcessingImageSignatureOverCRUD\\\\\"+ fileName).getPath();\n        List<String> signatureIds = new ArrayList<String>();\n        // -----------------------------------------------------------------------------------------------------------------------------\n        // STEP 1. Sign document with Image Signature\n        // -----------------------------------------------------------------------------------------------------------------------------\n        Signature signature = new Signature(filePath);\n        {\n            ImageSignOptions signOptions = new ImageSignOptions(Constants.ImageHandwrite);\n            signOptions.setVerticalAlignment(VerticalAlignment.Top);\n            signOptions.setHorizontalAlignment(HorizontalAlignment.Center);\n            signOptions.setWidth(100);\n            signOptions.setHeight(40);\n            signOptions.setMargin(new Padding(20));\n            // sign document to file\n            SignResult signResult = signature.sign(outputFilePath, signOptions);\n            System.out.print(\"\\nDocument \"+filePath+\" was signed with following signatures:\");\n            for (BaseSignature temp : signResult.getSucceeded())\n            {\n                // collect newly created signature' Id\n                signatureIds.add(temp.getSignatureId());\n                System.out.print(\"Signature : \"+temp.getSignatureType()+\" Id:\"+temp.getSignatureId()+\", Location: \"+temp.getLeft()+\"x\"+temp.getTop()+\". Size: \"+temp.getWidth()+\"x\"+temp.getHeight());\n            }\n        }\n        // -----------------------------------------------------------------------------------------------------------------------------\n        // STEP 2. Search document for Image Signature\n        // -----------------------------------------------------------------------------------------------------------------------------\n        Signature signature2 = new Signature(outputFilePath);\n        {\n            ImageSearchOptions searchOptions = new ImageSearchOptions();\n            // specify special pages to search on\n            searchOptions.setAllPages(true);\n            // search for image signatures in document\n            List<ImageSignature> signatures = signature2.search(ImageSignature.class,searchOptions);\n            System.out.print(\"\\nSource document contains following Image signature(s).\");\n            // enumerate all signature for output\n            for (ImageSignature imageSignature : signatures)\n            {\n                if (imageSignature != null)\n                {\n                    System.out.print(\"Found Image signature at page \"+imageSignature.getPageNumber()+\" and Image Size '\"+imageSignature.getSize()+\"'.\");\n                    System.out.print(\"Location at \"+imageSignature.getLeft()+\"-\"+imageSignature.getTop()+\". Size is \"+imageSignature.getWidth()+\"x\"+imageSignature.getHeight()+\".\");\n                }\n            }\n            // -----------------------------------------------------------------------------------------------------------------------------\n            // STEP 3. Update document Image Signature after searching it\n            // -----------------------------------------------------------------------------------------------------------------------------\n            List<BaseSignature> signaturesToUpdate = new ArrayList<BaseSignature>();\n            for (ImageSignature imageSignature : signatures)\n            {\n                // change position\n                imageSignature.setLeft(imageSignature.getLeft() + 100);\n                imageSignature.setTop(imageSignature.getTop() + 100);\n                // change size. Please note not all documents support changing signature size\n                imageSignature.setWidth(200);\n                imageSignature.setHeight(50);\n                signaturesToUpdate.add(imageSignature);\n            }\n            UpdateResult updateResult = signature2.update(new ByteArrayOutputStream(), signaturesToUpdate);\n            if (updateResult.getSucceeded().size() == signatures.size())\n            {\n                System.out.print(\"\\nAll signatures were successfully updated!\");\n            }\n            else\n            {\n                System.out.print(\"Successfully updated signatures : \"+updateResult.getSucceeded().size());\n                System.out.print(\"Not updated signatures : \"+updateResult.getFailed().size());\n            }\n            System.out.print(\"List of updated signatures:\");\n            for (BaseSignature temp : updateResult.getSucceeded())\n            {\n                System.out.print(\"Signature# Id:\"+temp.getSignatureId()+\", Location: \"+temp.getLeft()+\"x\"+temp.getTop()+\". Size: \"+temp.getWidth()+\"x\"+temp.getHeight());\n            }\n            // -----------------------------------------------------------------------------------------------------------------------------\n            // STEP 4. Update document Image Signature on saved SignatureId\n            // create list of Image Signature by known SignatureId\n            // -----------------------------------------------------------------------------------------------------------------------------\n            signaturesToUpdate.clear();\n            for ( String item : signatureIds)\n            {\n                ImageSignature temp = new ImageSignature(item);\n                temp.setWidth(150);\n                temp.setHeight(30);\n                temp.setLeft(100);\n                temp.setTop(100);\n                signaturesToUpdate.add(temp);\n            }\n            // update all found signatures\n            updateResult = signature2.update(new ByteArrayOutputStream(), signaturesToUpdate);\n            if (updateResult.getSucceeded().size() == signatures.size())\n            {\n                System.out.print(\"\\nAll signatures were successfully updated!\");\n            }\n            else\n            {\n                System.out.print(\"Successfully updated signatures : \"+updateResult.getSucceeded().size());\n                System.out.print(\"Not updated signatures : \"+updateResult.getFailed().size());\n            }\n            System.out.print(\"List of updated signatures:\");\n            for (BaseSignature temp : updateResult.getSucceeded())\n            {\n                System.out.print(\"Signature# Id:\"+temp.getSignatureId()+\", Location: \"+temp.getLeft()+\"x\"+temp.getTop()+\". Size: \"+temp.getWidth()+\"x\"+temp.getHeight());\n            }\n            // -----------------------------------------------------------------------------------------------------------------------------\n            // STEP 5. Delete document Image Signature by id\n            // create list of Image Signature by known SignatureId\n            signaturesToUpdate.clear();\n            for (String item : signatureIds)\n            {\n                ImageSignature temp = new ImageSignature(item);\n                signaturesToUpdate.add(temp);\n            }\n            // delete all signatures\n            DeleteResult deleteResult = signature2.delete(new ByteArrayOutputStream(), signaturesToUpdate);\n            if (deleteResult.getSucceeded().size() == signaturesToUpdate.size())\n            {\n                System.out.print(\"\\nAll signatures were successfully deleted!\");\n            }\n            else\n            {\n                System.out.print(\"Successfully deleted signatures : \"+deleteResult.getSucceeded().size());\n                System.out.print(\"Not deleted signatures : \"+deleteResult.getFailed().size());\n            }\n            System.out.print(\"List of deleted signatures:\");\n            for (BaseSignature temp : deleteResult.getSucceeded())\n            {\n                System.out.print(\"Signature# Id:\"+temp.getSignatureId()+\", Location: \"+temp.getLeft()+\"x\"+temp.getTop()+\". Size: \"+temp.getWidth()+\"x\"+temp.getHeight());\n            }\n        }\n    }\n"]]}
{"hexsha": "61a8c9102b7f3de805ed0ec7a46314d109d6702d", "ext": "java", "lang": "Java", "content": "@Slf4j\n@Component\n@AllArgsConstructor\npublic class DatabaseInitializer {\n\n    private final FlywayProperties flywayProperties;\n    private final DataSourceProperties dataSourceProperties;\n\n    /**\n     * \u5148\u521b\u5efa\u6570\u636e\u5e93\uff0c\u518d\u5229\u7528 flyway \u6267\u884c\u811a\u672c\n     * @throws SQLException\n     */\n    @PostConstruct\n    public void init() throws SQLException {\n        log.info(\"DatabaseInitializer uses flyway init-sqls to initiate database\");\n        String url = dataSourceProperties.getUrl();\n        // jdbc url\u6700\u540e\u4e00\u4e2a '/' \u7528\u4e8e\u5206\u5272\u5177\u4f53 schema?\u53c2\u6570\n        int lastSplitIndex = url.lastIndexOf('/');\n        // \u83b7\u53d6spring.datasource.url\u5177\u4f53\u6570\u636e\u5e93schema\u524d\u7684jdbc url\n        String addressUrl = url.substring(0, lastSplitIndex);\n        // \u76f4\u8fde\u6570\u636e\u5e93\u5730\u5740:jdbc:mysql://yourIp:port\n        HikariDataSource dataSource = new HikariDataSource();\n        dataSource.setJdbcUrl(addressUrl);\n        dataSource.setUsername(dataSourceProperties.getUsername());\n        dataSource.setPassword(dataSourceProperties.getPassword());\n        Connection connection = dataSource.getConnection();\n        Statement statement = connection.createStatement();\n        for (String sql : flywayProperties.getInitSqls()) {\n            // \u901a\u8fc7flyway\u7684init-sqls\u914d\u7f6e\u8fdb\u884c\u5efa\u5e93\u4e0e\u6570\u636e\u5e93\u914d\u7f6e\n            // executeUpdate:\u6267\u884c\u7ed9\u5b9a\u7684SQL\u8bed\u53e5\uff0c\u8be5\u8bed\u53e5\u53ef\u4ee5\u662fINSERT\uff0cUPDATE\u6216DELETE\u8bed\u53e5\u6216\u4e0d\u8fd4\u56de\u4efb\u4f55\u5185\u5bb9\u7684SQL\u8bed\u53e5\uff0c\u4f8b\u5982SQL DDL\u8bed\u53e5\u3002\n            statement.executeUpdate(sql);\n        }\n        statement.close();\n        connection.close();\n        dataSource.close();\n        log.info(\"DatabaseInitializer initialize completed\");\n    }\n}", "class_id": 0, "repo": "a1209023760/code-java", "file": "082-flyway/spring-boot-flyway/src/main/java/com/keqi/DatabaseInitializer.java", "last_update_at": "2020-01-06T07:46:27+00:00", "question_id": "61a8c9102b7f3de805ed0ec7a46314d109d6702d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Slf4j\n@Component\n@AllArgsConstructor\npublic class DatabaseInitializer {\n    private final FlywayProperties flywayProperties;\n    private final DataSourceProperties dataSourceProperties;\n    /**\n     * \u5148\u521b\u5efa\u6570\u636e\u5e93\uff0c\u518d\u5229\u7528 flyway \u6267\u884c\u811a\u672c\n     * @throws SQLException\n     */\n    @PostConstruct\n    public void init() throws SQLException {\n        log.info(\"DatabaseInitializer uses flyway init-sqls to initiate database\");\n        String url = dataSourceProperties.getUrl();\n        // jdbc url\u6700\u540e\u4e00\u4e2a '/' \u7528\u4e8e\u5206\u5272\u5177\u4f53 schema?\u53c2\u6570\n        int lastSplitIndex = url.lastIndexOf('/');\n        // \u83b7\u53d6spring.datasource.url\u5177\u4f53\u6570\u636e\u5e93schema\u524d\u7684jdbc url\n        String addressUrl = url.substring(0, lastSplitIndex);\n        // \u76f4\u8fde\u6570\u636e\u5e93\u5730\u5740:jdbc:mysql://yourIp:port\n        HikariDataSource dataSource = new HikariDataSource();\n        dataSource.setJdbcUrl(addressUrl);\n        dataSource.setUsername(dataSourceProperties.getUsername());\n        dataSource.setPassword(dataSourceProperties.getPassword());\n        Connection connection = dataSource.getConnection();\n        Statement statement = connection.createStatement();\n        for (String sql : flywayProperties.getInitSqls()) {\n            // \u901a\u8fc7flyway\u7684init-sqls\u914d\u7f6e\u8fdb\u884c\u5efa\u5e93\u4e0e\u6570\u636e\u5e93\u914d\u7f6e\n            // executeUpdate:\u6267\u884c\u7ed9\u5b9a\u7684SQL\u8bed\u53e5\uff0c\u8be5\u8bed\u53e5\u53ef\u4ee5\u662fINSERT\uff0cUPDATE\u6216DELETE\u8bed\u53e5\u6216\u4e0d\u8fd4\u56de\u4efb\u4f55\u5185\u5bb9\u7684SQL\u8bed\u53e5\uff0c\u4f8b\u5982SQL DDL\u8bed\u53e5\u3002\n            statement.executeUpdate(sql);\n        }\n        statement.close();\n        connection.close();\n        dataSource.close();\n        log.info(\"DatabaseInitializer initialize completed\");\n    }\n"]]}
{"hexsha": "6b130a36718fb7270bcfef6b4ed8c9940deee72e", "ext": "java", "lang": "Java", "content": "public class CharArrayCodec implements BCodec<char[]> {\n\n  /**\n   * Get the char hmap, creates it if it does not already exist.\n   *\n   * @return a <code>char[]</code> value\n   */\n  public static char[] getCharMap() {\n    if (CharArrayCodec.charMap == null)\n      setLocale();\n    return CharArrayCodec.charMap;\n  }\n  /**\n   * Get the locale, sets the locale to default if it is not already set,\n   * and if so also creates the char hmap.\n   *\n   * @return a <code>Locale</code> value\n   */\n  public static Locale getLocale() {\n    if (CharArrayCodec.charMap == null)\n      setLocale();\n    return CharArrayCodec.locale;\n  }\n\n\n  /**\n   * Set the locale to the default, also creates the precompiled charmap\n   */\n  public static void setLocale() {\n    setLocale(Locale.getDefault());\n  }\n\n\n  /**\n   * Set the locale, also creates the precompiled charmap\n   *\n   * @param locale\n   *          a <code>Locale</code> value\n   */\n  public static void setLocale(Locale locale) {\n    CharArrayCodec.locale = locale;\n    CharArrayCodec.charMap = new CompiledLocale().getCompiledLocale(locale);\n  }\n\n  /**\n   * Set the locale and the pre compiled charmap\n   *\n   * @param locale\n   *          a <code>Locale</code> to set\n   * @param charmap\n   *          charmap to set\n   */\n  public static void setLocale(Locale locale, char[] charmap) {\n    CharArrayCodec.locale = locale;\n    CharArrayCodec.charMap = charmap;\n  }\n\n  private static char[] toChars(CharSequence str){\n    char[] val = new char[str.length()];\n    for(int i = 0; i < val.length; i++)\n      val[i] = str.charAt(i);\n    return val;\n  }\n\n\n  private static char[] charMap = null;\n\n  private static Locale locale = null;\n\n  @Override\n  public int compare(char[] first, char[] second) {\n    int n = Math.min(first.length, second.length);\n    int i = 0;\n    char c1,c2;\n    if (charMap == null){\n      while(n-- != 0){\n        c1 = first[i];\n        c2 = second[i];\n        if(c1 != c2) return c1 - c2;\n        i++;\n      }\n    }\n    else {\n      while(n-- != 0){\n        c1 = charMap[(int) first[i]];\n        c2 = charMap[(int) second[i]];\n        if(c1 != c2) return c1-c2;\n        i++;\n      }\n    }\n    return first.length - second.length;\n  }\n\n  @Override\n  public int byteSize(char[] value) {\n    return CodecUtil.byteSize(UtfUtil.utfLength(value), true);\n  }\n\n  @Override\n  public int byteSize(ByteBuffer bb) {\n    return CodecUtil.peekSize(bb, true);\n  }\n\n  @Override\n  public char[] from(ByteBuffer bb) {\n    int length = CodecUtil.getSize(bb, true);\n    return UtfUtil.decodeChars(bb, length);\n  }\n\n  @Override\n  public void to(char[] value, ByteBuffer bb) {\n      CodecUtil.putSize(UtfUtil.utfLength(value), bb, true);\n      UtfUtil.encode(value, bb);\n  }\n\n\n  @Override\n  public int byteCompare(int offset1, byte[] b1, int offset2, byte[] b2) {\n    return charMap == null ? UtfUtil.compare(b1, offset1, b2, offset2) :\n        UtfUtil.compare(b1, offset1, b2, offset2, charMap);\n  }\n\n  @Override\n  public int byteCompare(int offset1, ByteBuffer bb1, int offset2,\n                         ByteBuffer bb2) {\n    return charMap == null ? UtfUtil.compare(bb1, offset1, bb2, offset2) :\n        UtfUtil.compare(bb1, offset1, bb2, offset2, charMap);\n  }\n\n  @Override\n  public int byteCompare(int offset1, int offset2, byte[] b) {\n    return charMap == null ? UtfUtil.compare(b, offset1, b, offset2) :\n        UtfUtil.compare(b, offset1, b, offset2, charMap);\n  }\n\n  /*@Override\n  public boolean equals(Object o) {\n    if(o instanceof CBCharArray) {\n      int ret =  compareTo((CBCharArray) o);\n      return ret == 0;\n    }\n    return false;\n  }*/\n\n\n\n}", "class_id": 0, "repo": "msvens/mellowtech-core", "file": "src/main/java/org/mellowtech/core/codec/CharArrayCodec.java", "last_update_at": "2020-05-19T17:17:15+00:00", "question_id": "6b130a36718fb7270bcfef6b4ed8c9940deee72e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CharArrayCodec implements BCodec<char[]> {\n  /**\n   * Get the char hmap, creates it if it does not already exist.\n   *\n   * @return a <code>char[]</code> value\n   */\n  public static char[] getCharMap() {\n    if (CharArrayCodec.charMap == null)\n      setLocale();\n    return CharArrayCodec.charMap;\n  }\n  /**\n   * Get the locale, sets the locale to default if it is not already set,\n   * and if so also creates the char hmap.\n   *\n   * @return a <code>Locale</code> value\n   */\n  public static Locale getLocale() {\n    if (CharArrayCodec.charMap == null)\n      setLocale();\n    return CharArrayCodec.locale;\n  }\n  /**\n   * Set the locale to the default, also creates the precompiled charmap\n   */\n  public static void setLocale() {\n    setLocale(Locale.getDefault());\n  }\n  /**\n   * Set the locale, also creates the precompiled charmap\n   *\n   * @param locale\n   *          a <code>Locale</code> value\n   */\n  public static void setLocale(Locale locale) {\n    CharArrayCodec.locale = locale;\n    CharArrayCodec.charMap = new CompiledLocale().getCompiledLocale(locale);\n  }\n  /**\n   * Set the locale and the pre compiled charmap\n   *\n   * @param locale\n   *          a <code>Locale</code> to set\n   * @param charmap\n   *          charmap to set\n   */\n  public static void setLocale(Locale locale, char[] charmap) {\n    CharArrayCodec.locale = locale;\n    CharArrayCodec.charMap = charmap;\n  }\n  private static char[] toChars(CharSequence str){\n    char[] val = new char[str.length()];\n    for(int i = 0; i < val.length; i++)\n      val[i] = str.charAt(i);\n    return val;\n  }\n  private static char[] charMap = null;\n  private static Locale locale = null;\n  @Override\n  public int compare(char[] first, char[] second) {\n    int n = Math.min(first.length, second.length);\n    int i = 0;\n    char c1,c2;\n    if (charMap == null){\n      while(n-- != 0){\n        c1 = first[i];\n        c2 = second[i];\n        if(c1 != c2) return c1 - c2;\n        i++;\n      }\n    }\n    else {\n      while(n-- != 0){\n        c1 = charMap[(int) first[i]];\n        c2 = charMap[(int) second[i]];\n        if(c1 != c2) return c1-c2;\n        i++;\n      }\n    }\n    return first.length - second.length;\n  }\n  @Override\n  public int byteSize(char[] value) {\n    return CodecUtil.byteSize(UtfUtil.utfLength(value), true);\n  }\n  @Override\n  public int byteSize(ByteBuffer bb) {\n    return CodecUtil.peekSize(bb, true);\n  }\n  @Override\n  public char[] from(ByteBuffer bb) {\n    int length = CodecUtil.getSize(bb, true);\n    return UtfUtil.decodeChars(bb, length);\n  }\n  @Override\n  public void to(char[] value, ByteBuffer bb) {\n      CodecUtil.putSize(UtfUtil.utfLength(value), bb, true);\n      UtfUtil.encode(value, bb);\n  }\n  @Override\n  public int byteCompare(int offset1, byte[] b1, int offset2, byte[] b2) {\n    return charMap == null ? UtfUtil.compare(b1, offset1, b2, offset2) :\n        UtfUtil.compare(b1, offset1, b2, offset2, charMap);\n  }\n  @Override\n  public int byteCompare(int offset1, ByteBuffer bb1, int offset2,\n                         ByteBuffer bb2) {\n    return charMap == null ? UtfUtil.compare(bb1, offset1, bb2, offset2) :\n        UtfUtil.compare(bb1, offset1, bb2, offset2, charMap);\n  }\n  @Override\n  public int byteCompare(int offset1, int offset2, byte[] b) {\n    return charMap == null ? UtfUtil.compare(b, offset1, b, offset2) :\n        UtfUtil.compare(b, offset1, b, offset2, charMap);\n  }\n  /*@Override\n  public boolean equals(Object o) {\n    if(o instanceof CBCharArray) {\n      int ret =  compareTo((CBCharArray) o);\n      return ret == 0;\n    }\n    return false;\n  }*/\n"]]}
{"hexsha": "79a2ee5af53d547fa81605da5a158b122df9028e", "ext": "java", "lang": "Java", "content": "public class BinaryColumnVector extends ColumnVector {\n\tprivate static final long serialVersionUID = -8529155738773478597L;\n\n\tpublic byte[][] vector;\n\tprivate int nextFree;    // next free position in buffer\n\n\t/**\n\t * Don't call this constructor except for testing purposes.\n\t *\n\t * @param size number of elements in the column vector\n\t */\n\tpublic BinaryColumnVector(int size) {\n\t\tsuper(size);\n\t\tvector = new byte[size][];\n\t}\n\n\t@Override\n\tpublic Object get(int index) {\n\t\treturn vector[index];\n\t}\n\n\t/**\n\t * Additional reset work for BytesColumnVector (releasing scratch bytes for by value strings).\n\t */\n\t@Override\n\tpublic void reset() {\n\t\tsuper.reset();\n\t}\n\n\t/**\n\t * Set a field by reference.\n\t *\n\t * @param elementNum index within column vector to set\n\t * @param sourceBuf  container of source data\n\t * @param start      start byte position within source\n\t * @param length     length of source byte sequence\n\t */\n\tpublic void setRef(int elementNum, byte[] sourceBuf, int start, int length) {\n\t\tvector[elementNum] = sourceBuf;\n\t}\n\n\t/**\n\t * Set a field by actually copying in to a local buffer.\n\t * If you must actually copy data in to the array, use this method.\n\t * DO NOT USE this method unless it's not practical to set data by reference with setRef().\n\t * Setting data by reference tends to run a lot faster than copying data in.\n\t *\n\t * @param elementNum index within column vector to set\n\t * @param sourceBuf  container of source data\n\t */\n\tpublic void setVal(int elementNum, byte[] sourceBuf) {\n\t\tvector[elementNum] = sourceBuf;\n\t}\n\n\t/**\n\t * Copy the current object contents into the output. Only copy selected entries,\n\t * as indicated by selectedInUse and the sel array.\n\t */\n\t@Override\n\tpublic void copySelected(boolean selectedInUse, int[] sel, int size, ColumnVector output) {\n\n\t\t// Output has nulls if and only if input has nulls.\n\t\toutput.noNulls = noNulls;\n\n\t\t// Copy data values over\n\t\tif (selectedInUse) {\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tint i = sel[j];\n\t\t\t\t((BinaryColumnVector) output).setVal(i, vector[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t((BinaryColumnVector) output).setVal(i, vector[i]);\n\t\t\t}\n\t\t}\n\n\t\t// Copy nulls over if needed\n\t\tsuper.copySelected(selectedInUse, sel, size, output);\n\t}\n\n\t@Override\n\tpublic void setElement(int outElementNum, int inputElementNum, ColumnVector inputVector) {\n\t\tif (inputVector.noNulls || !inputVector.isNull[inputElementNum]) {\n\t\t\tisNull[outElementNum] = false;\n\t\t\tBinaryColumnVector in = (BinaryColumnVector) inputVector;\n\t\t\tsetVal(outElementNum, in.vector[inputElementNum]);\n\t\t} else {\n\t\t\tisNull[outElementNum] = true;\n\t\t\tnoNulls = false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void init() {\n\t}\n\n\t@Override\n\tpublic void shallowCopyTo(ColumnVector otherCv) {\n\t\tBinaryColumnVector other = (BinaryColumnVector) otherCv;\n\t\tsuper.shallowCopyTo(other);\n\t\tother.nextFree = nextFree;\n\t\tother.vector = vector;\n\t}\n}", "class_id": 0, "repo": "yangjintao1/myfirstpro", "file": "flink-libraries/flink-table-common/src/main/java/org/apache/flink/table/dataformat/vector/BinaryColumnVector.java", "last_update_at": "2020-01-31T18:26:19+00:00", "question_id": "79a2ee5af53d547fa81605da5a158b122df9028e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BinaryColumnVector extends ColumnVector {\n\tprivate static final long serialVersionUID = -8529155738773478597L;\n\tpublic byte[][] vector;\n\tprivate int nextFree;    // next free position in buffer\n\t/**\n\t * Don't call this constructor except for testing purposes.\n\t *\n\t * @param size number of elements in the column vector\n\t */\n\tpublic BinaryColumnVector(int size) {\n\t\tsuper(size);\n\t\tvector = new byte[size][];\n\t}\n\t@Override\n\tpublic Object get(int index) {\n\t\treturn vector[index];\n\t}\n\t/**\n\t * Additional reset work for BytesColumnVector (releasing scratch bytes for by value strings).\n\t */\n\t@Override\n\tpublic void reset() {\n\t\tsuper.reset();\n\t}\n\t/**\n\t * Set a field by reference.\n\t *\n\t * @param elementNum index within column vector to set\n\t * @param sourceBuf  container of source data\n\t * @param start      start byte position within source\n\t * @param length     length of source byte sequence\n\t */\n\tpublic void setRef(int elementNum, byte[] sourceBuf, int start, int length) {\n\t\tvector[elementNum] = sourceBuf;\n\t}\n\t/**\n\t * Set a field by actually copying in to a local buffer.\n\t * If you must actually copy data in to the array, use this method.\n\t * DO NOT USE this method unless it's not practical to set data by reference with setRef().\n\t * Setting data by reference tends to run a lot faster than copying data in.\n\t *\n\t * @param elementNum index within column vector to set\n\t * @param sourceBuf  container of source data\n\t */\n\tpublic void setVal(int elementNum, byte[] sourceBuf) {\n\t\tvector[elementNum] = sourceBuf;\n\t}\n\t/**\n\t * Copy the current object contents into the output. Only copy selected entries,\n\t * as indicated by selectedInUse and the sel array.\n\t */\n\t@Override\n\tpublic void copySelected(boolean selectedInUse, int[] sel, int size, ColumnVector output) {\n\t\t// Output has nulls if and only if input has nulls.\n\t\toutput.noNulls = noNulls;\n\t\t// Copy data values over\n\t\tif (selectedInUse) {\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tint i = sel[j];\n\t\t\t\t((BinaryColumnVector) output).setVal(i, vector[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t((BinaryColumnVector) output).setVal(i, vector[i]);\n\t\t\t}\n\t\t}\n\t\t// Copy nulls over if needed\n\t\tsuper.copySelected(selectedInUse, sel, size, output);\n\t}\n\t@Override\n\tpublic void setElement(int outElementNum, int inputElementNum, ColumnVector inputVector) {\n\t\tif (inputVector.noNulls || !inputVector.isNull[inputElementNum]) {\n\t\t\tisNull[outElementNum] = false;\n\t\t\tBinaryColumnVector in = (BinaryColumnVector) inputVector;\n\t\t\tsetVal(outElementNum, in.vector[inputElementNum]);\n\t\t} else {\n\t\t\tisNull[outElementNum] = true;\n\t\t\tnoNulls = false;\n\t\t}\n\t}\n\t@Override\n\tpublic void init() {\n\t}\n\t@Override\n\tpublic void shallowCopyTo(ColumnVector otherCv) {\n\t\tBinaryColumnVector other = (BinaryColumnVector) otherCv;\n\t\tsuper.shallowCopyTo(other);\n\t\tother.nextFree = nextFree;\n\t\tother.vector = vector;\n\t}\n"]]}
{"hexsha": "56689567a1d20b80e690d0936b6065cb15190778", "ext": "java", "lang": "Java", "content": "class EqualityFieldKeySelector implements KeySelector<RowData, Integer> {\n\n  private final Schema schema;\n  private final RowType flinkSchema;\n  private final Schema deleteSchema;\n\n  private transient RowDataWrapper rowDataWrapper;\n  private transient StructProjection structProjection;\n  private transient StructLikeWrapper structLikeWrapper;\n\n  EqualityFieldKeySelector(Schema schema, RowType flinkSchema, List<Integer> equalityFieldIds) {\n    this.schema = schema;\n    this.flinkSchema = flinkSchema;\n    this.deleteSchema = TypeUtil.select(schema, Sets.newHashSet(equalityFieldIds));\n  }\n\n  /**\n   * Construct the {@link RowDataWrapper} lazily here because few members in it are not serializable. In this way, we\n   * don't have to serialize them with forcing.\n   */\n  protected RowDataWrapper lazyRowDataWrapper() {\n    if (rowDataWrapper == null) {\n      rowDataWrapper = new RowDataWrapper(flinkSchema, schema.asStruct());\n    }\n    return rowDataWrapper;\n  }\n\n  /**\n   * Construct the {@link StructProjection} lazily because it is not serializable.\n   */\n  protected StructProjection lazyStructProjection() {\n    if (structProjection == null) {\n      structProjection = StructProjection.create(schema, deleteSchema);\n    }\n    return structProjection;\n  }\n\n  /**\n   * Construct the {@link StructLikeWrapper} lazily because it is not serializable.\n   */\n  protected StructLikeWrapper lazyStructLikeWrapper() {\n    if (structLikeWrapper == null) {\n      structLikeWrapper = StructLikeWrapper.forType(deleteSchema.asStruct());\n    }\n    return structLikeWrapper;\n  }\n\n  @Override\n  public Integer getKey(RowData row) {\n    RowDataWrapper wrappedRowData = lazyRowDataWrapper().wrap(row);\n    StructProjection projectedRowData = lazyStructProjection().wrap(wrappedRowData);\n    StructLikeWrapper wrapper = lazyStructLikeWrapper().set(projectedRowData);\n    return wrapper.hashCode();\n  }\n}", "class_id": 0, "repo": "tuxtorres/iceberg", "file": "flink/v1.14/flink/src/main/java/org/apache/iceberg/flink/sink/EqualityFieldKeySelector.java", "last_update_at": "2020-05-27T08:50:04+00:00", "question_id": "56689567a1d20b80e690d0936b6065cb15190778", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class EqualityFieldKeySelector implements KeySelector<RowData, Integer> {\n  private final Schema schema;\n  private final RowType flinkSchema;\n  private final Schema deleteSchema;\n  private transient RowDataWrapper rowDataWrapper;\n  private transient StructProjection structProjection;\n  private transient StructLikeWrapper structLikeWrapper;\n  EqualityFieldKeySelector(Schema schema, RowType flinkSchema, List<Integer> equalityFieldIds) {\n    this.schema = schema;\n    this.flinkSchema = flinkSchema;\n    this.deleteSchema = TypeUtil.select(schema, Sets.newHashSet(equalityFieldIds));\n  }\n  /**\n   * Construct the {@link RowDataWrapper} lazily here because few members in it are not serializable. In this way, we\n   * don't have to serialize them with forcing.\n   */\n  protected RowDataWrapper lazyRowDataWrapper() {\n    if (rowDataWrapper == null) {\n      rowDataWrapper = new RowDataWrapper(flinkSchema, schema.asStruct());\n    }\n    return rowDataWrapper;\n  }\n  /**\n   * Construct the {@link StructProjection} lazily because it is not serializable.\n   */\n  protected StructProjection lazyStructProjection() {\n    if (structProjection == null) {\n      structProjection = StructProjection.create(schema, deleteSchema);\n    }\n    return structProjection;\n  }\n  /**\n   * Construct the {@link StructLikeWrapper} lazily because it is not serializable.\n   */\n  protected StructLikeWrapper lazyStructLikeWrapper() {\n    if (structLikeWrapper == null) {\n      structLikeWrapper = StructLikeWrapper.forType(deleteSchema.asStruct());\n    }\n    return structLikeWrapper;\n  }\n  @Override\n  public Integer getKey(RowData row) {\n    RowDataWrapper wrappedRowData = lazyRowDataWrapper().wrap(row);\n    StructProjection projectedRowData = lazyStructProjection().wrap(wrappedRowData);\n    StructLikeWrapper wrapper = lazyStructLikeWrapper().set(projectedRowData);\n    return wrapper.hashCode();\n  }\n"]]}
{"hexsha": "18f7547b44b2b2974aef71b924ad9511ffe70652", "ext": "java", "lang": "Java", "content": "public class Client implements Serializable {\n\t\n\t/**\n\t * Defines a type of client.\n\t * @author K. Benedyczak\n\t */\n\tpublic static enum Type {\n\t\t/**\n\t\t * The object represents an external client who was somehow \n\t\t * authenticated.\n\t\t */\n\t\tAUTHENTICATED, \n\t\t/**\n\t\t * The object represents an external client who was not authenticated, \n\t\t * i.e. we don't know who it is\n\t\t */\n\t\tANONYMOUS,\n\t\t/**\n\t\t * The object is associated with an operation invoked by the local server\n\t\t * code on its own behalf \n\t\t */\n\t\tLOCAL\n\t}; \n\t\n\tprivate static final long serialVersionUID=1L;\n\t\n\t//for some use cases, credentials are stored in the client object\n\tpublic static final String ATTRIBUTE_CREDENTIALS_USERNAME=\"creds.username\";\n\tpublic static final String ATTRIBUTE_CREDENTIALS_PASSWORD=\"creds.password\";\n\t\n\t//for storing the email address in the attributes\n\tpublic static final String ATTRIBUTE_USER_EMAIL=\"user.email\";\n\t\n\t/**\n\t * Fake DN used to identify an anonymous client. It is used just not to return null.\n\t */\n\tpublic static final String ANONYMOUS_CLIENT_DN = \"CN=ANONYMOUS,O=UNKNOWN,OU=UNKNOWN\";\n\n\t/**\n\t * Fake DN used to identify a local client.\n\t */\n\tpublic static final String LOCAL_CLIENT_DN = \"CN=Local_call\";\n\n\t\n\t//the token by which a client is identified\n\tprivate SecurityTokens secTokens;\n\t\n\t//what kind of client\n\tprivate Type type; \n\t\n\t//the (set of) possible unix login name(s) and groups optionally with the preferred one\n\tprivate Xlogin xlogin;\n\n\t//the role of the client\n\tprivate Role role;\n\t\n\t//list of VOs the user is a member of\n\tprivate String[] vos;\n\t\n\t//VO under which the request is performed, may be null\n\tprivate String vo;\n\t\n\tprivate Queue queue;\n\t\n\t\n\t//all attributes that were established by attribute sources.\n\tprivate SubjectAttributesHolder subjectAttributes;\n\t\n\t//additional attributes may contain things relevant on the target system \n\t//such as license keys, ... In most cases subjectAttributes are what you need.\n\tprivate final Map<String,String> extraAttributes;\n\t\n\t/**\n\t * Constructs an anonymous Client. Setters must be used to fully configure\n\t * the Client.\n\t */\n\tpublic Client() {\n\t\tsetAnonymousClient();\n\t\textraAttributes = new HashMap<String,String>();\n\t\tsetSubjectAttributes(new SubjectAttributesHolder());\n\t\txlogin = new Xlogin();\n\t\trole = new Role();\n\t\tvos = new String[0];\n\t\tqueue = new Queue();\n\t}\n\t\n\tpublic String toString() {\n\t\tStringBuilder cInfo = new StringBuilder();\n\t\t\n\t\tcInfo.append(\"Name: \");\n\t\tcInfo.append(X500NameUtils.getReadableForm(getDistinguishedName()));\n\t\tcInfo.append(\"\\nXlogin: \");\n\t\tcInfo.append(getXlogin());\n\t\tcInfo.append(\"\\nRole: \");\n\t\tcInfo.append(getRole());\n\t\tif (queue.getValidQueues().length > 0) {\n\t\t\tcInfo.append(\"\\nQueues: \");\n\t\t\tcInfo.append(queue);\n\t\t}\n\t\tif (vos.length > 0) {\n\t\t\tcInfo.append(\"\\nVOs: \");\n\t\t\tcInfo.append(Arrays.toString(vos));\n\t\t}\n\t\tif (vo != null) {\n\t\t\tcInfo.append(\"\\nSelected VO: \").append(vo);\n\t\t}\n\t\tif (secTokens != null)\n\t\t{\n\t\t\tcInfo.append(\"\\nSecurity tokens: \");\n\t\t\tcInfo.append(secTokens);\n\t\t}\t\n\t\treturn cInfo.toString(); \n\t}\n\n\n\t/**\n\t * @return type of this client\n\t */\n\tpublic Type getType() {\n\t\treturn type;\n\t}\n\n\t/**\n\t * Makes this client ANONYMOUS \n\t */\n\tpublic void setAnonymousClient() {\n\t\tthis.type = Type.ANONYMOUS;\n\t\tthis.secTokens = null;\n\t}\n\n\t/**\n\t * Makes this client LOCAL \n\t */\n\tpublic void setLocalClient() {\n\t\tthis.type = Type.LOCAL;\n\t\tthis.secTokens = null;\n\t}\n\n\t/**\n\t * Sets the type of this client basing on SecurityTokens - \n\t * it can be AUTHENTICATED or ANONYMOUS. \n\t * @param secTokens security tokens established during authentication \n\t */\n\tpublic void setAuthenticatedClient(SecurityTokens secTokens) {\n\t\tthis.secTokens = secTokens;\n\t\tif (secTokens == null || secTokens.getEffectiveUserName() == null) {\n\t\t\tthis.type = Type.ANONYMOUS;\n\t\t\treturn;\n\t\t}\n\t\tthis.type = Type.AUTHENTICATED;\n\t}\n\n\t/**\n\t * @return Returns the {@link SecurityTokens} or null if \n\t * the client is not of AUTHENTICATED type\n\t */\n\tpublic SecurityTokens getSecurityTokens() {\n\t\treturn secTokens;\n\t}\n\n\t/**\n\t * @return the client's distinguished name. For authenticated \n\t * clients it is the effective user's name. For other types of clients one \n\t * of predefined constants is returned. This method never returns null.\n\t */\n\tpublic String getDistinguishedName() {\n\t\tif (type == Type.ANONYMOUS)\n\t\t\treturn ANONYMOUS_CLIENT_DN;\n\t\telse if (type == Type.LOCAL)\n\t\t\treturn LOCAL_CLIENT_DN;\n\t\telse\n\t\t\treturn secTokens.getEffectiveUserName();\n\t}\n\t\n\t\n\t//****************** INCARNATION AND AUTHZ PART *******************************\n\t\n\t\n\t/**\n\t * @return Returns the role.\n\t */\n\tpublic Role getRole() {\n\t\treturn role;\n\t}\n\t\n\t/**\n\t * @param role The role to set.\n\t */\n\tpublic void setRole(Role role) {\n\t\tthis.role = role;\n\t}\n\n\t\n\tpublic Map<String, String> getExtraAttributes() {\n\t\treturn extraAttributes;\n\t}\n\t\n\t/**\n\t * convenience method for getting the user's xlogin\n\t * @return an {@link Xlogin}\n\t */\n\tpublic Xlogin getXlogin(){\n\t\treturn xlogin;\n\t}\n\t\n\t/**\n\t * convenience method for setting the user's xlogin\n\t */\n\tpublic void setXlogin(Xlogin xlogin){\n\t\tif (xlogin == null)\n\t\t\tthrow new IllegalArgumentException(\"Setting null xlogin is prohibited.\");\n\t\tthis.xlogin=xlogin;\n\t}\n\n\t/**\n\t * Convenience method returning the selected Xlogin name.\n\t */\n\tpublic String getSelectedXloginName() {\n\t\treturn xlogin.getUserName();\n\t}\n\n\t/**\n\t * Convenience method setting the selected Xlogin name.\n\t * @param userName\n\t */\n\tpublic void setSelectedXloginName(String userName) {\n\t\txlogin.setSelectedLogin(userName);\n\t}\n\n\tpublic String getUserEmail(){\n\t\treturn (String)extraAttributes.get(ATTRIBUTE_USER_EMAIL);\n\t}\n\t\n\tpublic void setUserEmail(String email){\n\t\tif(email==null) {\n\t\t\textraAttributes.remove(ATTRIBUTE_USER_EMAIL);\n\t\t}\n\t\telse{\n\t\t\textraAttributes.put(ATTRIBUTE_USER_EMAIL,email);\n\t\t}\n\t}\n\n\tpublic void setSubjectAttributes(SubjectAttributesHolder subjectAttributes) {\n\t\tthis.subjectAttributes = subjectAttributes;\n\t}\n\n\tpublic SubjectAttributesHolder getSubjectAttributes() {\n\t\treturn subjectAttributes;\n\t}\n\n\tpublic String[] getVos() {\n\t\treturn vos;\n\t}\n\n\tpublic void setVos(String[] vos) {\n\t\tif (vos == null)\n\t\t\tthrow new IllegalArgumentException(\"Can not set null VOs array, use empty array instead\");\n\t\tthis.vos = vos;\n\t}\n\n\tpublic Queue getQueue() {\n\t\treturn queue;\n\t}\n\n\tpublic void setQueue(Queue queue) {\n\t\tif (queue == null)\n\t\t\tthrow new IllegalArgumentException(\"Can not set null Queue object, use empty Queue instead\");\n\t\tthis.queue = queue;\n\t}\n\t\n\t/**\n\t * @return the selected VO or null if request is not VO bound\n\t */\n\tpublic String getVo() {\n\t\treturn vo;\n\t}\n\n\t/**\n\t * @param vo the vo to set. Must be one of VOs set for this object\n\t * @throws IllegalArgumentException if argument is not in all client's VOs.\n\t */\n\tpublic void setVo(String vo) {\n\t\tfor (String v: vos)\n\t\t\tif (v.equals(vo))\n\t\t\t{\n\t\t\t\tthis.vo = vo;\n\t\t\t\treturn;\n\t\t\t}\n\t\tthrow new IllegalArgumentException(\"The selected VO '\" + vo + \n\t\t\t\t\"' is not one of the VOs the client is memeber of\");\n\t}\n}", "class_id": 0, "repo": "UNICORE-EU/securityLibrary", "file": "src/main/java/eu/unicore/security/Client.java", "last_update_at": "2020-05-15T18:23:32+00:00", "question_id": "18f7547b44b2b2974aef71b924ad9511ffe70652", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Client implements Serializable {\n\t\n\t/**\n\t * Defines a type of client.\n\t * @author K. Benedyczak\n\t */\n\tpublic static enum Type {\n\t\t/**\n\t\t * The object represents an external client who was somehow \n\t\t * authenticated.\n\t\t */\n\t\tAUTHENTICATED, \n\t\t/**\n\t\t * The object represents an external client who was not authenticated, \n\t\t * i.e. we don't know who it is\n\t\t */\n\t\tANONYMOUS,\n\t\t/**\n\t\t * The object is associated with an operation invoked by the local server\n\t\t * code on its own behalf \n\t\t */\n\t\tLOCAL\n\t}; \n\t\n\tprivate static final long serialVersionUID=1L;\n\t\n\t//for some use cases, credentials are stored in the client object\n\tpublic static final String ATTRIBUTE_CREDENTIALS_USERNAME=\"creds.username\";\n\tpublic static final String ATTRIBUTE_CREDENTIALS_PASSWORD=\"creds.password\";\n\t\n\t//for storing the email address in the attributes\n\tpublic static final String ATTRIBUTE_USER_EMAIL=\"user.email\";\n\t\n\t/**\n\t * Fake DN used to identify an anonymous client. It is used just not to return null.\n\t */\n\tpublic static final String ANONYMOUS_CLIENT_DN = \"CN=ANONYMOUS,O=UNKNOWN,OU=UNKNOWN\";\n\t/**\n\t * Fake DN used to identify a local client.\n\t */\n\tpublic static final String LOCAL_CLIENT_DN = \"CN=Local_call\";\n\t\n\t//the token by which a client is identified\n\tprivate SecurityTokens secTokens;\n\t\n\t//what kind of client\n\tprivate Type type; \n\t\n\t//the (set of) possible unix login name(s) and groups optionally with the preferred one\n\tprivate Xlogin xlogin;\n\t//the role of the client\n\tprivate Role role;\n\t\n\t//list of VOs the user is a member of\n\tprivate String[] vos;\n\t\n\t//VO under which the request is performed, may be null\n\tprivate String vo;\n\t\n\tprivate Queue queue;\n\t\n\t\n\t//all attributes that were established by attribute sources.\n\tprivate SubjectAttributesHolder subjectAttributes;\n\t\n\t//additional attributes may contain things relevant on the target system \n\t//such as license keys, ... In most cases subjectAttributes are what you need.\n\tprivate final Map<String,String> extraAttributes;\n\t\n\t/**\n\t * Constructs an anonymous Client. Setters must be used to fully configure\n\t * the Client.\n\t */\n\tpublic Client() {\n\t\tsetAnonymousClient();\n\t\textraAttributes = new HashMap<String,String>();\n\t\tsetSubjectAttributes(new SubjectAttributesHolder());\n\t\txlogin = new Xlogin();\n\t\trole = new Role();\n\t\tvos = new String[0];\n\t\tqueue = new Queue();\n\t}\n\t\n\tpublic String toString() {\n\t\tStringBuilder cInfo = new StringBuilder();\n\t\t\n\t\tcInfo.append(\"Name: \");\n\t\tcInfo.append(X500NameUtils.getReadableForm(getDistinguishedName()));\n\t\tcInfo.append(\"\\nXlogin: \");\n\t\tcInfo.append(getXlogin());\n\t\tcInfo.append(\"\\nRole: \");\n\t\tcInfo.append(getRole());\n\t\tif (queue.getValidQueues().length > 0) {\n\t\t\tcInfo.append(\"\\nQueues: \");\n\t\t\tcInfo.append(queue);\n\t\t}\n\t\tif (vos.length > 0) {\n\t\t\tcInfo.append(\"\\nVOs: \");\n\t\t\tcInfo.append(Arrays.toString(vos));\n\t\t}\n\t\tif (vo != null) {\n\t\t\tcInfo.append(\"\\nSelected VO: \").append(vo);\n\t\t}\n\t\tif (secTokens != null)\n\t\t{\n\t\t\tcInfo.append(\"\\nSecurity tokens: \");\n\t\t\tcInfo.append(secTokens);\n\t\t}\t\n\t\treturn cInfo.toString(); \n\t}\n\t/**\n\t * @return type of this client\n\t */\n\tpublic Type getType() {\n\t\treturn type;\n\t}\n\t/**\n\t * Makes this client ANONYMOUS \n\t */\n\tpublic void setAnonymousClient() {\n\t\tthis.type = Type.ANONYMOUS;\n\t\tthis.secTokens = null;\n\t}\n\t/**\n\t * Makes this client LOCAL \n\t */\n\tpublic void setLocalClient() {\n\t\tthis.type = Type.LOCAL;\n\t\tthis.secTokens = null;\n\t}\n\t/**\n\t * Sets the type of this client basing on SecurityTokens - \n\t * it can be AUTHENTICATED or ANONYMOUS. \n\t * @param secTokens security tokens established during authentication \n\t */\n\tpublic void setAuthenticatedClient(SecurityTokens secTokens) {\n\t\tthis.secTokens = secTokens;\n\t\tif (secTokens == null || secTokens.getEffectiveUserName() == null) {\n\t\t\tthis.type = Type.ANONYMOUS;\n\t\t\treturn;\n\t\t}\n\t\tthis.type = Type.AUTHENTICATED;\n\t}\n\t/**\n\t * @return Returns the {@link SecurityTokens} or null if \n\t * the client is not of AUTHENTICATED type\n\t */\n\tpublic SecurityTokens getSecurityTokens() {\n\t\treturn secTokens;\n\t}\n\t/**\n\t * @return the client's distinguished name. For authenticated \n\t * clients it is the effective user's name. For other types of clients one \n\t * of predefined constants is returned. This method never returns null.\n\t */\n\tpublic String getDistinguishedName() {\n\t\tif (type == Type.ANONYMOUS)\n\t\t\treturn ANONYMOUS_CLIENT_DN;\n\t\telse if (type == Type.LOCAL)\n\t\t\treturn LOCAL_CLIENT_DN;\n\t\telse\n\t\t\treturn secTokens.getEffectiveUserName();\n\t}\n\t\n\t\n\t//****************** INCARNATION AND AUTHZ PART *******************************\n\t\n\t\n\t/**\n\t * @return Returns the role.\n\t */\n\tpublic Role getRole() {\n\t\treturn role;\n\t}\n\t\n\t/**\n\t * @param role The role to set.\n\t */\n\tpublic void setRole(Role role) {\n\t\tthis.role = role;\n\t}\n\t\n\tpublic Map<String, String> getExtraAttributes() {\n\t\treturn extraAttributes;\n\t}\n\t\n\t/**\n\t * convenience method for getting the user's xlogin\n\t * @return an {@link Xlogin}\n\t */\n\tpublic Xlogin getXlogin(){\n\t\treturn xlogin;\n\t}\n\t\n\t/**\n\t * convenience method for setting the user's xlogin\n\t */\n\tpublic void setXlogin(Xlogin xlogin){\n\t\tif (xlogin == null)\n\t\t\tthrow new IllegalArgumentException(\"Setting null xlogin is prohibited.\");\n\t\tthis.xlogin=xlogin;\n\t}\n\t/**\n\t * Convenience method returning the selected Xlogin name.\n\t */\n\tpublic String getSelectedXloginName() {\n\t\treturn xlogin.getUserName();\n\t}\n\t/**\n\t * Convenience method setting the selected Xlogin name.\n\t * @param userName\n\t */\n\tpublic void setSelectedXloginName(String userName) {\n\t\txlogin.setSelectedLogin(userName);\n\t}\n\tpublic String getUserEmail(){\n\t\treturn (String)extraAttributes.get(ATTRIBUTE_USER_EMAIL);\n\t}\n\t\n\tpublic void setUserEmail(String email){\n\t\tif(email==null) {\n\t\t\textraAttributes.remove(ATTRIBUTE_USER_EMAIL);\n\t\t}\n\t\telse{\n\t\t\textraAttributes.put(ATTRIBUTE_USER_EMAIL,email);\n\t\t}\n\t}\n\tpublic void setSubjectAttributes(SubjectAttributesHolder subjectAttributes) {\n\t\tthis.subjectAttributes = subjectAttributes;\n\t}\n\tpublic SubjectAttributesHolder getSubjectAttributes() {\n\t\treturn subjectAttributes;\n\t}\n\tpublic String[] getVos() {\n\t\treturn vos;\n\t}\n\tpublic void setVos(String[] vos) {\n\t\tif (vos == null)\n\t\t\tthrow new IllegalArgumentException(\"Can not set null VOs array, use empty array instead\");\n\t\tthis.vos = vos;\n\t}\n\tpublic Queue getQueue() {\n\t\treturn queue;\n\t}\n\tpublic void setQueue(Queue queue) {\n\t\tif (queue == null)\n\t\t\tthrow new IllegalArgumentException(\"Can not set null Queue object, use empty Queue instead\");\n\t\tthis.queue = queue;\n\t}\n\t\n\t/**\n\t * @return the selected VO or null if request is not VO bound\n\t */\n\tpublic String getVo() {\n\t\treturn vo;\n\t}\n\t/**\n\t * @param vo the vo to set. Must be one of VOs set for this object\n\t * @throws IllegalArgumentException if argument is not in all client's VOs.\n\t */\n\tpublic void setVo(String vo) {\n\t\tfor (String v: vos)\n\t\t\tif (v.equals(vo))\n\t\t\t{\n\t\t\t\tthis.vo = vo;\n\t\t\t\treturn;\n\t\t\t}\n\t\tthrow new IllegalArgumentException(\"The selected VO '\" + vo + \n\t\t\t\t\"' is not one of the VOs the client is memeber of\");\n\t}\n"]]}
{"hexsha": "c4567262a5c9119a559a4d268436eb9ffc088e2d", "ext": "java", "lang": "Java", "content": "@RunWith(MockitoJUnitRunner.class)\npublic class SynchronizeClockProcessorTest {\n\n    private static final String TEST_ID = \"testOperationId\";\n    private static final String TEST_DEVICE_ID = \"testDevice\";\n    private static final String[] TEST_PATH = new String[] {\"path\", \"to\", \"device\"};\n    private static final String TEST_SOURCE = \"testSource\";\n    private static final ParameterSetOrConfigureOperation TEST_PARAMETER =\n            new ParameterSetOrConfigureOperation(Collections.singletonList(new ValueSetting(\"source\", \"sync\")));\n    private static final RequestSetOrConfigureOperation TEST_REQUEST =\n            new RequestSetOrConfigureOperation(TEST_PARAMETER);\n    private static final String TEST_RESULT_DESCRIPTION = \"result description\";\n    private static final Result TEST_RESULT = new Result(ResultCode.SUCCESSFUL, TEST_RESULT_DESCRIPTION);\n\n\n    @Mock\n    private OperationSynchronizeClock mockedSynchronizeClock;\n    @InjectMocks\n    private SynchronizeClockProcessor testProcessor;\n\n\n    @Test\n    public void testParseParameters() {\n        String source = testProcessor.parseParameters(TEST_REQUEST);\n\n        assertEquals(\"sync\", source);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testParseParametersNullParams() {\n        RequestSetOrConfigureOperation nullParamsRequest = new RequestSetOrConfigureOperation(null);\n\n        assertNull(testProcessor.parseParameters(nullParamsRequest));\n    }\n\n    @Test\n    public void testParseParametersEmptyParams() {\n        RequestSetOrConfigureOperation emptyParamsRequest = new RequestSetOrConfigureOperation(new ParameterSetOrConfigureOperation(null));\n\n        assertNull(testProcessor.parseParameters(emptyParamsRequest));\n    }\n\n    @Test\n    public void testProcessOperation() {\n        testProcessor.processOperation(TEST_DEVICE_ID, TEST_SOURCE);\n\n        verify(mockedSynchronizeClock).synchronizeClock(eq(TEST_DEVICE_ID), eq(TEST_SOURCE));\n    }\n\n    @Test\n    public void testTranslateToOutput() {\n        Output output = testProcessor.translateToOutput(TEST_RESULT, TEST_ID, TEST_DEVICE_ID, TEST_PATH);\n\n        assertEquals(OPENGATE_VERSION, output.getVersion());\n        OutputOperation outputOperation = output.getOperation();\n        Response response = outputOperation.getResponse();\n        assertEquals(TEST_ID, response.getId());\n        assertEquals(TEST_DEVICE_ID, response.getDeviceId());\n        assertArrayEquals(TEST_PATH, response.getPath());\n        assertEquals(SYNCHRONIZE_CLOCK_OPERATION_NAME, response.getName());\n        assertEquals(OperationResultCode.SUCCESSFUL, response.getResultCode());\n        assertEquals(TEST_RESULT_DESCRIPTION, response.getResultDescription());\n        List<Step> steps = response.getSteps();\n        assertNotNull(steps);\n        assertEquals(1, steps.size());\n        Step step = steps.get(0);\n        assertEquals(SYNCHRONIZE_CLOCK_OPERATION_NAME, step.getName());\n        assertEquals(StepResultCode.SUCCESSFUL, step.getResult());\n        assertEquals(TEST_RESULT_DESCRIPTION, step.getDescription());\n    }\n\n    @Test\n    public void testTranslateToOutputResultWithError() {\n        String errorDescription = \"Error description\";\n        Result errorResult = new Result(ResultCode.ERROR_PROCESSING, errorDescription);\n\n        Output output = testProcessor.translateToOutput(errorResult, TEST_ID, TEST_DEVICE_ID, TEST_PATH);\n\n        assertEquals(OPENGATE_VERSION, output.getVersion());\n        OutputOperation outputOperation = output.getOperation();\n        Response response = outputOperation.getResponse();\n        assertEquals(TEST_ID, response.getId());\n        assertEquals(TEST_DEVICE_ID, response.getDeviceId());\n        assertArrayEquals(TEST_PATH, response.getPath());\n        assertEquals(SYNCHRONIZE_CLOCK_OPERATION_NAME, response.getName());\n        assertEquals(OperationResultCode.ERROR_PROCESSING, response.getResultCode());\n        assertEquals(errorDescription, response.getResultDescription());\n        List<Step> steps = response.getSteps();\n        assertNotNull(steps);\n        assertEquals(1, steps.size());\n        Step step = steps.get(0);\n        assertEquals(SYNCHRONIZE_CLOCK_OPERATION_NAME, step.getName());\n        assertEquals(StepResultCode.ERROR, step.getResult());\n        assertEquals(errorDescription, step.getDescription());\n    }\n}", "class_id": 0, "repo": "JesusGranizo/oda", "file": "oda-dispatchers/opengate/src/test/java/es/amplia/oda/dispatcher/opengate/operation/processor/SynchronizeClockProcessorTest.java", "last_update_at": "2020-07-29T08:33:28+00:00", "question_id": "c4567262a5c9119a559a4d268436eb9ffc088e2d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(MockitoJUnitRunner.class)\npublic class SynchronizeClockProcessorTest {\n    private static final String TEST_ID = \"testOperationId\";\n    private static final String TEST_DEVICE_ID = \"testDevice\";\n    private static final String[] TEST_PATH = new String[] {\"path\", \"to\", \"device\"};\n    private static final String TEST_SOURCE = \"testSource\";\n    private static final ParameterSetOrConfigureOperation TEST_PARAMETER =\n            new ParameterSetOrConfigureOperation(Collections.singletonList(new ValueSetting(\"source\", \"sync\")));\n    private static final RequestSetOrConfigureOperation TEST_REQUEST =\n            new RequestSetOrConfigureOperation(TEST_PARAMETER);\n    private static final String TEST_RESULT_DESCRIPTION = \"result description\";\n    private static final Result TEST_RESULT = new Result(ResultCode.SUCCESSFUL, TEST_RESULT_DESCRIPTION);\n    @Mock\n    private OperationSynchronizeClock mockedSynchronizeClock;\n    @InjectMocks\n    private SynchronizeClockProcessor testProcessor;\n    @Test\n    public void testParseParameters() {\n        String source = testProcessor.parseParameters(TEST_REQUEST);\n        assertEquals(\"sync\", source);\n    }\n    @Test(expected = IllegalArgumentException.class)\n    public void testParseParametersNullParams() {\n        RequestSetOrConfigureOperation nullParamsRequest = new RequestSetOrConfigureOperation(null);\n        assertNull(testProcessor.parseParameters(nullParamsRequest));\n    }\n    @Test\n    public void testParseParametersEmptyParams() {\n        RequestSetOrConfigureOperation emptyParamsRequest = new RequestSetOrConfigureOperation(new ParameterSetOrConfigureOperation(null));\n        assertNull(testProcessor.parseParameters(emptyParamsRequest));\n    }\n    @Test\n    public void testProcessOperation() {\n        testProcessor.processOperation(TEST_DEVICE_ID, TEST_SOURCE);\n        verify(mockedSynchronizeClock).synchronizeClock(eq(TEST_DEVICE_ID), eq(TEST_SOURCE));\n    }\n    @Test\n    public void testTranslateToOutput() {\n        Output output = testProcessor.translateToOutput(TEST_RESULT, TEST_ID, TEST_DEVICE_ID, TEST_PATH);\n        assertEquals(OPENGATE_VERSION, output.getVersion());\n        OutputOperation outputOperation = output.getOperation();\n        Response response = outputOperation.getResponse();\n        assertEquals(TEST_ID, response.getId());\n        assertEquals(TEST_DEVICE_ID, response.getDeviceId());\n        assertArrayEquals(TEST_PATH, response.getPath());\n        assertEquals(SYNCHRONIZE_CLOCK_OPERATION_NAME, response.getName());\n        assertEquals(OperationResultCode.SUCCESSFUL, response.getResultCode());\n        assertEquals(TEST_RESULT_DESCRIPTION, response.getResultDescription());\n        List<Step> steps = response.getSteps();\n        assertNotNull(steps);\n        assertEquals(1, steps.size());\n        Step step = steps.get(0);\n        assertEquals(SYNCHRONIZE_CLOCK_OPERATION_NAME, step.getName());\n        assertEquals(StepResultCode.SUCCESSFUL, step.getResult());\n        assertEquals(TEST_RESULT_DESCRIPTION, step.getDescription());\n    }\n    @Test\n    public void testTranslateToOutputResultWithError() {\n        String errorDescription = \"Error description\";\n        Result errorResult = new Result(ResultCode.ERROR_PROCESSING, errorDescription);\n        Output output = testProcessor.translateToOutput(errorResult, TEST_ID, TEST_DEVICE_ID, TEST_PATH);\n        assertEquals(OPENGATE_VERSION, output.getVersion());\n        OutputOperation outputOperation = output.getOperation();\n        Response response = outputOperation.getResponse();\n        assertEquals(TEST_ID, response.getId());\n        assertEquals(TEST_DEVICE_ID, response.getDeviceId());\n        assertArrayEquals(TEST_PATH, response.getPath());\n        assertEquals(SYNCHRONIZE_CLOCK_OPERATION_NAME, response.getName());\n        assertEquals(OperationResultCode.ERROR_PROCESSING, response.getResultCode());\n        assertEquals(errorDescription, response.getResultDescription());\n        List<Step> steps = response.getSteps();\n        assertNotNull(steps);\n        assertEquals(1, steps.size());\n        Step step = steps.get(0);\n        assertEquals(SYNCHRONIZE_CLOCK_OPERATION_NAME, step.getName());\n        assertEquals(StepResultCode.ERROR, step.getResult());\n        assertEquals(errorDescription, step.getDescription());\n    }\n"]]}
{"hexsha": "67d8f5e2b9111ea46886be9b7bf66834322379cd", "ext": "java", "lang": "Java", "content": "public class StoredQCUtils {\n\n    public static Map<SQField, String> getQueryFields(HttpServletRequest servletRequest,\n                                                      String defaultQueryField) {\n        String tmpDefaultQueryField =\n                defaultQueryField == null ?\n                        servletRequest.getParameter(C.DEFAULT_QUERY_FIELD) :\n                        defaultQueryField;\n\n        String idString = servletRequest.getParameter(C.STORED_QUERY_ID);\n        int id = StoredQuery.NOT_YET_LOADED;\n        if (!StringUtils.isBlank(idString)) {\n            try {\n                id = Integer.parseInt(idString);\n            } catch (NumberFormatException e) {\n                //swallow\n            }\n        }\n        String name = servletRequest.getParameter(C.STORED_QUERY_NAME);\n        String maxHits = servletRequest.getParameter(C.MAX_SEARCH_RESULTS);\n        if (StringUtils.isBlank(maxHits) || maxHits.equals(\"default\")) {\n            maxHits = Integer.toString(StoredQuery.RETRIEVE_ALL_HITS);\n        }\n        String priority = servletRequest.getParameter(C.STORED_QUERY_PRIORITY);\n        if (StringUtils.isBlank(priority) || priority.equals(\"default\") ||\n                priority.equals(\"all\")) {\n            priority = Integer.toString(StoredQuery.DEFAULT_PRIORITY);\n        }\n        Map<SQField, String> map = new HashMap<>();\n        map.put(SQField.ID, Integer.toString(id));\n        map.put(SQField.NAME, name);\n        map.put(SQField.DEFAULT_FIELD, tmpDefaultQueryField);\n        map.put(SQField.MAIN_QUERY, servletRequest.getParameter(C.MAIN_QUERY));\n        map.put(SQField.MAIN_QUERY_TRANSLATION, servletRequest.getParameter(C.MAIN_QUERY_TRANSLATION));\n        map.put(SQField.FILTER_QUERY, servletRequest.getParameter(C.FILTER_QUERY));\n        map.put(SQField.FILTER_QUERY_TRANSLATION, servletRequest.getParameter(C.FILTER_QUERY_TRANSLATION));\n        map.put(SQField.GEO_QUERY_STRING, servletRequest.getParameter(C.GEO_QUERY));\n        map.put(SQField.GEO_QUERY_RADIUS_STRING, servletRequest.getParameter(C.GEO_RADIUS));\n        map.put(SQField.HIGHLIGHTING_STYLE, servletRequest.getParameter(C.HIGHLIGHT_STYLE));\n        map.put(SQField.MAX_HITS, maxHits);\n        map.put(SQField.PRIORITY, priority);\n        map.put(SQField.NOTES, servletRequest.getParameter(C.STORED_QUERY_NOTES));\n        return map;\n    }\n\n    public static StoredQuery buildStoredQuery(Map<SQField, String> fields) {\n        int id = StoredQuery.NOT_YET_LOADED;\n        String intVal = fields.get(SQField.ID);\n        if (intVal != null) {\n            try {\n                id = Integer.parseInt(intVal);\n            } catch (NumberFormatException e) {\n\n            }\n        }\n        StoredQueryBuilder storedQueryBuilder = new StoredQueryBuilder(id, fields.get(SQField.NAME));\n        for (Map.Entry<SQField, String> e : fields.entrySet()) {\n            if (e.getKey().equals(SQField.NAME)) {\n                continue;\n            }\n            storedQueryBuilder.add(e.getKey(), e.getValue());\n        }\n        return storedQueryBuilder.build();\n    }\n\n    public static StoredConcept buildStoredConcept(Map<SCField, String> fields) {\n        StoredConceptBuilder storedConceptBuilder = new StoredConceptBuilder(fields.get(SCField.NAME));\n        for (Map.Entry<SCField, String> e : fields.entrySet()) {\n            if (e.getKey().equals(SCField.NAME)) {\n                continue;\n            }\n            storedConceptBuilder.add(e.getKey(), e.getValue());\n        }\n        return storedConceptBuilder.build();\n    }\n}", "class_id": 0, "repo": "mitre/rhapsode", "file": "rhapsode-common/src/main/java/org/rhapsode/app/utils/StoredQCUtils.java", "last_update_at": "2020-12-07T13:00:14+00:00", "question_id": "67d8f5e2b9111ea46886be9b7bf66834322379cd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class StoredQCUtils {\n    public static Map<SQField, String> getQueryFields(HttpServletRequest servletRequest,\n                                                      String defaultQueryField) {\n        String tmpDefaultQueryField =\n                defaultQueryField == null ?\n                        servletRequest.getParameter(C.DEFAULT_QUERY_FIELD) :\n                        defaultQueryField;\n        String idString = servletRequest.getParameter(C.STORED_QUERY_ID);\n        int id = StoredQuery.NOT_YET_LOADED;\n        if (!StringUtils.isBlank(idString)) {\n            try {\n                id = Integer.parseInt(idString);\n            } catch (NumberFormatException e) {\n                //swallow\n            }\n        }\n        String name = servletRequest.getParameter(C.STORED_QUERY_NAME);\n        String maxHits = servletRequest.getParameter(C.MAX_SEARCH_RESULTS);\n        if (StringUtils.isBlank(maxHits) || maxHits.equals(\"default\")) {\n            maxHits = Integer.toString(StoredQuery.RETRIEVE_ALL_HITS);\n        }\n        String priority = servletRequest.getParameter(C.STORED_QUERY_PRIORITY);\n        if (StringUtils.isBlank(priority) || priority.equals(\"default\") ||\n                priority.equals(\"all\")) {\n            priority = Integer.toString(StoredQuery.DEFAULT_PRIORITY);\n        }\n        Map<SQField, String> map = new HashMap<>();\n        map.put(SQField.ID, Integer.toString(id));\n        map.put(SQField.NAME, name);\n        map.put(SQField.DEFAULT_FIELD, tmpDefaultQueryField);\n        map.put(SQField.MAIN_QUERY, servletRequest.getParameter(C.MAIN_QUERY));\n        map.put(SQField.MAIN_QUERY_TRANSLATION, servletRequest.getParameter(C.MAIN_QUERY_TRANSLATION));\n        map.put(SQField.FILTER_QUERY, servletRequest.getParameter(C.FILTER_QUERY));\n        map.put(SQField.FILTER_QUERY_TRANSLATION, servletRequest.getParameter(C.FILTER_QUERY_TRANSLATION));\n        map.put(SQField.GEO_QUERY_STRING, servletRequest.getParameter(C.GEO_QUERY));\n        map.put(SQField.GEO_QUERY_RADIUS_STRING, servletRequest.getParameter(C.GEO_RADIUS));\n        map.put(SQField.HIGHLIGHTING_STYLE, servletRequest.getParameter(C.HIGHLIGHT_STYLE));\n        map.put(SQField.MAX_HITS, maxHits);\n        map.put(SQField.PRIORITY, priority);\n        map.put(SQField.NOTES, servletRequest.getParameter(C.STORED_QUERY_NOTES));\n        return map;\n    }\n    public static StoredQuery buildStoredQuery(Map<SQField, String> fields) {\n        int id = StoredQuery.NOT_YET_LOADED;\n        String intVal = fields.get(SQField.ID);\n        if (intVal != null) {\n            try {\n                id = Integer.parseInt(intVal);\n            } catch (NumberFormatException e) {\n            }\n        }\n        StoredQueryBuilder storedQueryBuilder = new StoredQueryBuilder(id, fields.get(SQField.NAME));\n        for (Map.Entry<SQField, String> e : fields.entrySet()) {\n            if (e.getKey().equals(SQField.NAME)) {\n                continue;\n            }\n            storedQueryBuilder.add(e.getKey(), e.getValue());\n        }\n        return storedQueryBuilder.build();\n    }\n    public static StoredConcept buildStoredConcept(Map<SCField, String> fields) {\n        StoredConceptBuilder storedConceptBuilder = new StoredConceptBuilder(fields.get(SCField.NAME));\n        for (Map.Entry<SCField, String> e : fields.entrySet()) {\n            if (e.getKey().equals(SCField.NAME)) {\n                continue;\n            }\n            storedConceptBuilder.add(e.getKey(), e.getValue());\n        }\n        return storedConceptBuilder.build();\n    }\n"]]}
{"hexsha": "1f6176b4de0b77eb779b265547630c5e00991260", "ext": "java", "lang": "Java", "content": "public class AnswerCommand extends Command<QuizModel> {\n\n    public static final String COMMAND_WORD = \"ans:\";\n    public static final int STARTING_INDEX_OF_ANSWER = 4;\n    public static final Status STATUS = Status.ON_QUESTION;\n\n    private final String answer;\n\n    public AnswerCommand(String answer) {\n        this.answer = answer;\n    }\n\n    @Override\n    public CommandResult execute(QuizModel model) throws CommandException {\n        requireNonNull(model);\n\n        if (!model.hasStarted()) {\n            throw new CommandException(QuizCommandUtil.MESSAGE_QUIZ_NEVER_STARTED);\n        }\n\n        if (!QuizCommandUtil.getStatus().equals(STATUS)) {\n            throw new CommandException(QuizCommandUtil.MESSAGE_UNAVAIL_ON_ANSWER);\n        }\n\n        model.saveAnswer(answer);\n        QuizCard.setQuestion(model.getQuestion());\n        String userAnswerToShow = \"Your answer: \" + answer + \"\\n\\n\";\n        Answer answer = model.getAnswer();\n\n        QuizCommandUtil.setStatus(Status.ON_ANSWER);\n\n        String answerStringToShow = userAnswerToShow + \"\\nCorrect answer: \" + answer.toString()\n                + QuizCommandUtil.SPECIAL_LITERAL\n                + QuizCommandUtil.MESSAGE_AVAIL_ON_ANSWER;\n        QuizCommandUtil.updateCommandResult(answerStringToShow);\n\n        return new QuizCommandResult(answerStringToShow, model.getQuiz(), ANSWER);\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        return other == this // short circuit if same object\n                || (other instanceof AnswerCommand // instanceof handles nulls\n                && answer.equals(((AnswerCommand) other).answer)); // state check\n    }\n}", "class_id": 0, "repo": "chuyiting/tp", "file": "src/main/java/seedu/studybananas/logic/commands/quizcommands/AnswerCommand.java", "last_update_at": "2020-09-30T11:25:21+00:00", "question_id": "1f6176b4de0b77eb779b265547630c5e00991260", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AnswerCommand extends Command<QuizModel> {\n    public static final String COMMAND_WORD = \"ans:\";\n    public static final int STARTING_INDEX_OF_ANSWER = 4;\n    public static final Status STATUS = Status.ON_QUESTION;\n    private final String answer;\n    public AnswerCommand(String answer) {\n        this.answer = answer;\n    }\n    @Override\n    public CommandResult execute(QuizModel model) throws CommandException {\n        requireNonNull(model);\n        if (!model.hasStarted()) {\n            throw new CommandException(QuizCommandUtil.MESSAGE_QUIZ_NEVER_STARTED);\n        }\n        if (!QuizCommandUtil.getStatus().equals(STATUS)) {\n            throw new CommandException(QuizCommandUtil.MESSAGE_UNAVAIL_ON_ANSWER);\n        }\n        model.saveAnswer(answer);\n        QuizCard.setQuestion(model.getQuestion());\n        String userAnswerToShow = \"Your answer: \" + answer + \"\\n\\n\";\n        Answer answer = model.getAnswer();\n        QuizCommandUtil.setStatus(Status.ON_ANSWER);\n        String answerStringToShow = userAnswerToShow + \"\\nCorrect answer: \" + answer.toString()\n                + QuizCommandUtil.SPECIAL_LITERAL\n                + QuizCommandUtil.MESSAGE_AVAIL_ON_ANSWER;\n        QuizCommandUtil.updateCommandResult(answerStringToShow);\n        return new QuizCommandResult(answerStringToShow, model.getQuiz(), ANSWER);\n    }\n    @Override\n    public boolean equals(Object other) {\n        return other == this // short circuit if same object\n                || (other instanceof AnswerCommand // instanceof handles nulls\n                && answer.equals(((AnswerCommand) other).answer)); // state check\n    }\n"]]}
{"hexsha": "dfbafe37aa9d022d5eb6e4c8b3b6525d08803b4e", "ext": "java", "lang": "Java", "content": "public class BooksServlet extends HttpServlet {\r\n\r\n    @Override\r\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n\r\n        if (request.getParameter(\"logout\") != null) {\r\n            request.getSession().invalidate();\r\n            response.sendRedirect(\"/books\");\r\n            return;\r\n        }\r\n\r\n        request.setAttribute(\"books\", BookStore.getBooks());\r\n        RequestDispatcher dispatcher = getServletContext().getRequestDispatcher(\"/public/books.jsp\");\r\n        dispatcher.forward(request, response);\r\n\r\n    }\r\n\r\n}", "class_id": 0, "repo": "AntonVolDev/Examples", "file": "Security/WebSecurityExample-N03/src/main/java/ru/gemini/security/BooksServlet.java", "last_update_at": "2020-07-09T13:29:47+00:00", "question_id": "dfbafe37aa9d022d5eb6e4c8b3b6525d08803b4e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BooksServlet extends HttpServlet {\r\n\r\n    @Override\r\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n\r\n        if (request.getParameter(\"logout\") != null) {\r\n            request.getSession().invalidate();\r\n            response.sendRedirect(\"/books\");\r\n            return;\r\n        }\r\n\r\n        request.setAttribute(\"books\", BookStore.getBooks());\r\n        RequestDispatcher dispatcher = getServletContext().getRequestDispatcher(\"/public/books.jsp\");\r\n        dispatcher.forward(request, response);\r\n\r\n    }\r\n\r\n"]]}
{"hexsha": "72588fc09bc511547775227caac4fef7870f5618", "ext": "java", "lang": "Java", "content": "public class MergeThenTransform extends KeysetProcessor {\n  \n  /** constructors ============================================================ */\n  \n  /** Default constructor */\n  public MergeThenTransform() {}\n  \n  /** methods ================================================================= */\n    \n  /**\n   * Appends an XML attribute value.\n   * @param xml the XML being constructed\n   * @param name the attribute name\n   * @param value the attribute value\n   */\n  protected StringBuilder appendXmlAttribute(StringBuilder xml, \n                                             String name, \n                                             String value) {\n    String s = Val.chkStr(Val.escapeXml(value));\n    xml.append(\" \").append(name).append(\"=\\\"\").append(s).append(\"\\\"\");\n    return xml;\n  }\n  \n  /**\n   * Appends an XML property element.\n   * <br/>&lt;property name=\"[name]\"/&gt;[value]&lt;/property&gt;\n   * @param xml the XML being constructed\n   * @param name the property name\n   * @param value the property value\n   */\n  protected StringBuilder appendPropertyElement(StringBuilder xml, \n                                                String nl,\n                                                String name, \n                                                String value) {\n    String s = Val.chkStr(Val.escapeXml(value));\n    xml.append(nl).append(\"<property\");\n    xml.append(\" \").append(\"name\").append(\"=\\\"\").append(name).append(\"\\\">\");\n    xml.append(s).append(\"</property>\");\n    return xml;\n  }\n  \n  /**\n   * Appends an XML property element based upon a gpt.xml \n   * configuration parameter.\n   * <br/>&lt;property name=\"[name]\"/&gt;[value]&lt;/property&gt;\n   * @param cfgParams the configuration parameters\n   * @param xml the XML being constructed\n   * @param nl the new line prefix\n   * @param cfgKey the configuration parameter key\n   */\n  protected StringBuilder appendPropertyElement(StringAttributeMap cfgParams, \n                                                StringBuilder xml, \n                                                String nl, \n                                                String cfgKey) {\n    if (cfgKey.indexOf(\"*\") == -1) {\n      this.appendPropertyElement(xml,nl,cfgKey,cfgParams.getValue(cfgKey));\n    } else if (cfgKey.equals(\"*\")) {\n      for (StringAttribute attr: cfgParams.values()) {\n        String sKey = attr.getKey();\n        this.appendPropertyElement(xml,nl,sKey,cfgParams.getValue(sKey));\n      }\n    } else {\n      String[] parts = cfgKey.split(\"\\\\*\");\n      for (StringAttribute attr: cfgParams.values()) {\n        String sKey = attr.getKey();\n        boolean bMatches = false;\n        for (String sPart: parts) {\n          int nIdx = sKey.indexOf(sPart);\n          if (nIdx == -1) {\n            bMatches = false;\n            break;\n          } else {\n            bMatches = true;\n            sKey = sKey.substring(nIdx+sPart.length());\n          }\n        }\n        if (bMatches) {\n          sKey = attr.getKey();\n          this.appendPropertyElement(xml,nl,sKey,cfgParams.getValue(sKey));\n        }\n      } \n    }\n    return xml;\n  }\n    \n  /**\n   * Processes the HTTP request.\n   * @param request the HTTP request\n   * @param response HTTP response\n   * @param context request context\n   * @throws Exception if an exception occurs\n   */\n  @Override\n  public void execute(HttpServletRequest request,\n                      HttpServletResponse response, \n                      RequestContext context) \n    throws Exception {\n    String[] keys = this.readKeys(request,context,true);\n    \n    //String sXsltPath = Val.chkStr(request.getParameter(\"xslt\"));\n    //String sMimeType = Val.chkStr(request.getParameter(\"mimeType\"));\n    //String sContentDisposition = Val.chkStr(request.getParameter(\"contentDisposition\"));\n    \n    StringAttributeMap cfgParams = context.getCatalogConfiguration().getParameters();    \n    String sCfgPfx = \"catalog.cart.processor.mergeThenTransform\";\n    String sXsltPath = Val.chkStr(\n        cfgParams.getValue(sCfgPfx+\".xslt\"));\n    String sProperties = Val.chkStr(\n        cfgParams.getValue(sCfgPfx+\".xslt.properties\"));\n    String sMimeType = Val.chkStr(\n        cfgParams.getValue(sCfgPfx+\".response.mimeType\"));\n    String sContentDisposition = Val.chkStr(\n        cfgParams.getValue(sCfgPfx+\".response.contentDisposition\"));\n    \n    if ((keys.length > 0) && (sXsltPath.length() > 0)) {\n      XsltTemplate template = this.getCompiledTemplate(sXsltPath);\n      ServletOutputStream out = response.getOutputStream(); \n      \n      if (sProperties.length() == 0) {\n        sProperties = \"catalog.cart.*\";\n      }\n      \n      if (sMimeType.length() == 0) {\n        sMimeType = \"text/plain\";\n      }\n      response.setContentType(sMimeType+\";charset=UTF-8\"); \n      if (sContentDisposition.length() > 0) {\n        response.addHeader(\"Content-Disposition\",sContentDisposition);\n      }\n      \n      String nl = \"\\r\\n\";\n      try {   \n        StringBuilder sbXmls = new StringBuilder();\n        for (String sKey: keys) {\n          String sXml = Val.chkStr(this.readXml(request,context,sKey));\n          if (sXml.startsWith(\"<?xml \")) {\n            sXml = Val.chkStr(sXml.substring(sXml.indexOf(\"?>\") + 2));\n          }\n          if (sXml.length() > 0) {\n            sbXmls.append(nl).append(sXml);\n          }\n        }\n        \n        if (sbXmls.length() > 0) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"<collection>\");\n          \n          // append client properties\n          sb.append(nl).append(\"<client\");\n          appendXmlAttribute(sb,\"session-id\",request.getSession(true).getId());\n          appendXmlAttribute(sb,\"session-rid\",request.getRequestedSessionId());\n          appendXmlAttribute(sb,\"remote-ip\",request.getRemoteAddr());\n          appendXmlAttribute(sb,\"remote-host\",request.getRemoteHost());\n          appendXmlAttribute(sb,\"remote-user\",context.getUser().getName());\n          appendXmlAttribute(sb,\"user-agent\",request.getHeader(\"User-Agent\"));\n          sb.append(\"/>\");\n                      \n          // append configuration properties\n          sb.append(nl).append(\"<properties>\");\n          this.appendPropertyElement(cfgParams,sb,nl,sProperties);\n          sb.append(nl).append(\"</properties>\");\n          \n          // append the XML records\n          sb.append(nl).append(\"<records>\");\n          sb.append(sbXmls);\n          sb.append(nl).append(\"</records>\");\n          sb.append(nl).append(\"</collection>\");\n          \n          // transform then return the response\n          boolean bTransform = true;\n          if (bTransform) {\n            String sResult = Val.chkStr(template.transform(sb.toString()));\n            if (sResult.length() > 0) {\n              byte[] bytes = sResult.getBytes(\"UTF-8\");\n              out.write(bytes);\n              out.flush();\n            }\n          } else {\n            byte[] bytes = sb.toString().getBytes(\"UTF-8\");\n            out.write(bytes);\n            out.flush();\n          }\n        }\n      } finally {\n        out.flush();\n        out.close();\n      }\n    }\n  }\n\n}", "class_id": 0, "repo": "psanyal/geoportal-server", "file": "geoportal/src/com/esri/gpt/control/cart/MergeThenTransform.java", "last_update_at": "2020-01-21T09:34:14+00:00", "question_id": "72588fc09bc511547775227caac4fef7870f5618", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MergeThenTransform extends KeysetProcessor {\n  /** constructors ============================================================ */\n  /** Default constructor */\n  public MergeThenTransform() {}\n  /** methods ================================================================= */\n  /**\n   * Appends an XML attribute value.\n   * @param xml the XML being constructed\n   * @param name the attribute name\n   * @param value the attribute value\n   */\n  protected StringBuilder appendXmlAttribute(StringBuilder xml, \n                                             String name, \n                                             String value) {\n    String s = Val.chkStr(Val.escapeXml(value));\n    xml.append(\" \").append(name).append(\"=\\\"\").append(s).append(\"\\\"\");\n    return xml;\n  }\n  /**\n   * Appends an XML property element.\n   * <br/>&lt;property name=\"[name]\"/&gt;[value]&lt;/property&gt;\n   * @param xml the XML being constructed\n   * @param name the property name\n   * @param value the property value\n   */\n  protected StringBuilder appendPropertyElement(StringBuilder xml, \n                                                String nl,\n                                                String name, \n                                                String value) {\n    String s = Val.chkStr(Val.escapeXml(value));\n    xml.append(nl).append(\"<property\");\n    xml.append(\" \").append(\"name\").append(\"=\\\"\").append(name).append(\"\\\">\");\n    xml.append(s).append(\"</property>\");\n    return xml;\n  }\n  /**\n   * Appends an XML property element based upon a gpt.xml \n   * configuration parameter.\n   * <br/>&lt;property name=\"[name]\"/&gt;[value]&lt;/property&gt;\n   * @param cfgParams the configuration parameters\n   * @param xml the XML being constructed\n   * @param nl the new line prefix\n   * @param cfgKey the configuration parameter key\n   */\n  protected StringBuilder appendPropertyElement(StringAttributeMap cfgParams, \n                                                StringBuilder xml, \n                                                String nl, \n                                                String cfgKey) {\n    if (cfgKey.indexOf(\"*\") == -1) {\n      this.appendPropertyElement(xml,nl,cfgKey,cfgParams.getValue(cfgKey));\n    } else if (cfgKey.equals(\"*\")) {\n      for (StringAttribute attr: cfgParams.values()) {\n        String sKey = attr.getKey();\n        this.appendPropertyElement(xml,nl,sKey,cfgParams.getValue(sKey));\n      }\n    } else {\n      String[] parts = cfgKey.split(\"\\\\*\");\n      for (StringAttribute attr: cfgParams.values()) {\n        String sKey = attr.getKey();\n        boolean bMatches = false;\n        for (String sPart: parts) {\n          int nIdx = sKey.indexOf(sPart);\n          if (nIdx == -1) {\n            bMatches = false;\n            break;\n          } else {\n            bMatches = true;\n            sKey = sKey.substring(nIdx+sPart.length());\n          }\n        }\n        if (bMatches) {\n          sKey = attr.getKey();\n          this.appendPropertyElement(xml,nl,sKey,cfgParams.getValue(sKey));\n        }\n      } \n    }\n    return xml;\n  }\n  /**\n   * Processes the HTTP request.\n   * @param request the HTTP request\n   * @param response HTTP response\n   * @param context request context\n   * @throws Exception if an exception occurs\n   */\n  @Override\n  public void execute(HttpServletRequest request,\n                      HttpServletResponse response, \n                      RequestContext context) \n    throws Exception {\n    String[] keys = this.readKeys(request,context,true);\n    //String sXsltPath = Val.chkStr(request.getParameter(\"xslt\"));\n    //String sMimeType = Val.chkStr(request.getParameter(\"mimeType\"));\n    //String sContentDisposition = Val.chkStr(request.getParameter(\"contentDisposition\"));\n    StringAttributeMap cfgParams = context.getCatalogConfiguration().getParameters();    \n    String sCfgPfx = \"catalog.cart.processor.mergeThenTransform\";\n    String sXsltPath = Val.chkStr(\n        cfgParams.getValue(sCfgPfx+\".xslt\"));\n    String sProperties = Val.chkStr(\n        cfgParams.getValue(sCfgPfx+\".xslt.properties\"));\n    String sMimeType = Val.chkStr(\n        cfgParams.getValue(sCfgPfx+\".response.mimeType\"));\n    String sContentDisposition = Val.chkStr(\n        cfgParams.getValue(sCfgPfx+\".response.contentDisposition\"));\n    if ((keys.length > 0) && (sXsltPath.length() > 0)) {\n      XsltTemplate template = this.getCompiledTemplate(sXsltPath);\n      ServletOutputStream out = response.getOutputStream(); \n      if (sProperties.length() == 0) {\n        sProperties = \"catalog.cart.*\";\n      }\n      if (sMimeType.length() == 0) {\n        sMimeType = \"text/plain\";\n      }\n      response.setContentType(sMimeType+\";charset=UTF-8\"); \n      if (sContentDisposition.length() > 0) {\n        response.addHeader(\"Content-Disposition\",sContentDisposition);\n      }\n      String nl = \"\\r\\n\";\n      try {   \n        StringBuilder sbXmls = new StringBuilder();\n        for (String sKey: keys) {\n          String sXml = Val.chkStr(this.readXml(request,context,sKey));\n          if (sXml.startsWith(\"<?xml \")) {\n            sXml = Val.chkStr(sXml.substring(sXml.indexOf(\"?>\") + 2));\n          }\n          if (sXml.length() > 0) {\n            sbXmls.append(nl).append(sXml);\n          }\n        }\n        if (sbXmls.length() > 0) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"<collection>\");\n          // append client properties\n          sb.append(nl).append(\"<client\");\n          appendXmlAttribute(sb,\"session-id\",request.getSession(true).getId());\n          appendXmlAttribute(sb,\"session-rid\",request.getRequestedSessionId());\n          appendXmlAttribute(sb,\"remote-ip\",request.getRemoteAddr());\n          appendXmlAttribute(sb,\"remote-host\",request.getRemoteHost());\n          appendXmlAttribute(sb,\"remote-user\",context.getUser().getName());\n          appendXmlAttribute(sb,\"user-agent\",request.getHeader(\"User-Agent\"));\n          sb.append(\"/>\");\n          // append configuration properties\n          sb.append(nl).append(\"<properties>\");\n          this.appendPropertyElement(cfgParams,sb,nl,sProperties);\n          sb.append(nl).append(\"</properties>\");\n          // append the XML records\n          sb.append(nl).append(\"<records>\");\n          sb.append(sbXmls);\n          sb.append(nl).append(\"</records>\");\n          sb.append(nl).append(\"</collection>\");\n          // transform then return the response\n          boolean bTransform = true;\n          if (bTransform) {\n            String sResult = Val.chkStr(template.transform(sb.toString()));\n            if (sResult.length() > 0) {\n              byte[] bytes = sResult.getBytes(\"UTF-8\");\n              out.write(bytes);\n              out.flush();\n            }\n          } else {\n            byte[] bytes = sb.toString().getBytes(\"UTF-8\");\n            out.write(bytes);\n            out.flush();\n          }\n        }\n      } finally {\n        out.flush();\n        out.close();\n      }\n    }\n  }\n"]]}
{"hexsha": "4c8c908349d5cdcc86986d9ea3779cc02b3a87a1", "ext": "java", "lang": "Java", "content": "public class ServerConfigTest\n{\n  private static final DefaultObjectMapper OBJECT_MAPPER = new DefaultObjectMapper();\n\n  @Test\n  public void testSerde() throws Exception\n  {\n    ServerConfig defaultConfig = new ServerConfig();\n    String defaultConfigJson = OBJECT_MAPPER.writeValueAsString(defaultConfig);\n    ServerConfig defaultConfig2 = OBJECT_MAPPER.readValue(defaultConfigJson, ServerConfig.class);\n    Assert.assertEquals(defaultConfig, defaultConfig2);\n    Assert.assertFalse(defaultConfig2.isEnableForwardedRequestCustomizer());\n\n    ServerConfig modifiedConfig = new ServerConfig(\n        999,\n        888,\n        defaultConfig.isEnableRequestLimit(),\n        defaultConfig.getMaxIdleTime(),\n        defaultConfig.getDefaultQueryTimeout(),\n        defaultConfig.getMaxScatterGatherBytes(),\n        defaultConfig.getMaxSubqueryRows(),\n        defaultConfig.getMaxQueryTimeout(),\n        defaultConfig.getMaxRequestHeaderSize(),\n        defaultConfig.getGracefulShutdownTimeout(),\n        defaultConfig.getUnannouncePropagationDelay(),\n        defaultConfig.getInflateBufferSize(),\n        defaultConfig.getCompressionLevel(),\n        true,\n        ImmutableList.of(HttpMethod.OPTIONS)\n    );\n    String modifiedConfigJson = OBJECT_MAPPER.writeValueAsString(modifiedConfig);\n    ServerConfig modifiedConfig2 = OBJECT_MAPPER.readValue(modifiedConfigJson, ServerConfig.class);\n    Assert.assertEquals(modifiedConfig, modifiedConfig2);\n    Assert.assertEquals(999, modifiedConfig2.getNumThreads());\n    Assert.assertEquals(888, modifiedConfig2.getQueueSize());\n    Assert.assertTrue(modifiedConfig2.isEnableForwardedRequestCustomizer());\n    Assert.assertEquals(1, modifiedConfig2.getAllowedHttpMethods().size());\n    Assert.assertTrue(modifiedConfig2.getAllowedHttpMethods().contains(HttpMethod.OPTIONS));\n  }\n\n  @Test\n  public void testEqualsAndHashCode()\n  {\n    EqualsVerifier.forClass(ServerConfig.class)\n                  // this class uses non-final fields for serialization / de-serialization.\n                  // There are no setters that mutate the fields, once the object is instantiated.\n                  .suppress(Warning.NONFINAL_FIELDS)\n                  .usingGetClass()\n                  .verify();\n  }\n}", "class_id": 0, "repo": "weishiuntsai/druid", "file": "server/src/test/java/org/apache/druid/initialization/ServerConfigTest.java", "last_update_at": "2020-10-24T09:19:51+00:00", "question_id": "4c8c908349d5cdcc86986d9ea3779cc02b3a87a1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ServerConfigTest\n{\n  private static final DefaultObjectMapper OBJECT_MAPPER = new DefaultObjectMapper();\n  @Test\n  public void testSerde() throws Exception\n  {\n    ServerConfig defaultConfig = new ServerConfig();\n    String defaultConfigJson = OBJECT_MAPPER.writeValueAsString(defaultConfig);\n    ServerConfig defaultConfig2 = OBJECT_MAPPER.readValue(defaultConfigJson, ServerConfig.class);\n    Assert.assertEquals(defaultConfig, defaultConfig2);\n    Assert.assertFalse(defaultConfig2.isEnableForwardedRequestCustomizer());\n    ServerConfig modifiedConfig = new ServerConfig(\n        999,\n        888,\n        defaultConfig.isEnableRequestLimit(),\n        defaultConfig.getMaxIdleTime(),\n        defaultConfig.getDefaultQueryTimeout(),\n        defaultConfig.getMaxScatterGatherBytes(),\n        defaultConfig.getMaxSubqueryRows(),\n        defaultConfig.getMaxQueryTimeout(),\n        defaultConfig.getMaxRequestHeaderSize(),\n        defaultConfig.getGracefulShutdownTimeout(),\n        defaultConfig.getUnannouncePropagationDelay(),\n        defaultConfig.getInflateBufferSize(),\n        defaultConfig.getCompressionLevel(),\n        true,\n        ImmutableList.of(HttpMethod.OPTIONS)\n    );\n    String modifiedConfigJson = OBJECT_MAPPER.writeValueAsString(modifiedConfig);\n    ServerConfig modifiedConfig2 = OBJECT_MAPPER.readValue(modifiedConfigJson, ServerConfig.class);\n    Assert.assertEquals(modifiedConfig, modifiedConfig2);\n    Assert.assertEquals(999, modifiedConfig2.getNumThreads());\n    Assert.assertEquals(888, modifiedConfig2.getQueueSize());\n    Assert.assertTrue(modifiedConfig2.isEnableForwardedRequestCustomizer());\n    Assert.assertEquals(1, modifiedConfig2.getAllowedHttpMethods().size());\n    Assert.assertTrue(modifiedConfig2.getAllowedHttpMethods().contains(HttpMethod.OPTIONS));\n  }\n  @Test\n  public void testEqualsAndHashCode()\n  {\n    EqualsVerifier.forClass(ServerConfig.class)\n                  // this class uses non-final fields for serialization / de-serialization.\n                  // There are no setters that mutate the fields, once the object is instantiated.\n                  .suppress(Warning.NONFINAL_FIELDS)\n                  .usingGetClass()\n                  .verify();\n  }\n"]]}
{"hexsha": "696952ebc551cce7a2e411bcc24e01c722c3084a", "ext": "java", "lang": "Java", "content": "@Named\n@ViewScoped\npublic class SettingsBean implements Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate Session session;\n    \n    private List<Setting> settings;\n    private Map<Long, String> settingValues;\n\n    @PostConstruct\n    public void init() {\n        session = HibernateUtil.getSessionFactory().openSession();\n        settings = session.createQuery(\"select o from Setting o\", Setting.class).getResultList();\n        settingValues = new HashMap<>();\n        for (Setting setting : settings) {\n            settingValues.put(setting.getId(), setting.getValue());\n        }\n    }\n\n    public void update() {\n\n        session.getTransaction().begin();\n        for (Map.Entry<Long, String> settingValue : settingValues.entrySet()) {\n            Setting setting = session.get(Setting.class, settingValue.getKey());\n            if (settingValue.getValue() != null && settingValue.getValue().trim().length() > 0) setting.setValue(settingValue.getValue());\n            session.update(setting);\n        }\n        session.getTransaction().commit();\n        \n    }\n    \n    /**\n     * @return the users\n     */\n    public List<Setting> getSettings() {\n        return settings;\n    }\n\n    /**\n     * @param settings the users to set\n     */\n    public void setUsers(List<Setting> settings) {\n        this.settings = settings;\n    }\n\n    /**\n     * @return the settingValues\n     */\n    public Map<Long, String> getSettingValues() {\n        return settingValues;\n    }\n\n    /**\n     * @param settingValues the settingValues to set\n     */\n    public void setSettingValues(Map<Long, String> settingValues) {\n        this.settingValues = settingValues;\n    }\n}", "class_id": 0, "repo": "dagvadorj/pesrona", "file": "src/main/java/pesrona/bean/SettingsBean.java", "last_update_at": "2020-08-24T13:36:48+00:00", "question_id": "696952ebc551cce7a2e411bcc24e01c722c3084a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Named\n@ViewScoped\npublic class SettingsBean implements Serializable {\n\tprivate static final long serialVersionUID = 1L;\n\tprivate Session session;\n    private List<Setting> settings;\n    private Map<Long, String> settingValues;\n    @PostConstruct\n    public void init() {\n        session = HibernateUtil.getSessionFactory().openSession();\n        settings = session.createQuery(\"select o from Setting o\", Setting.class).getResultList();\n        settingValues = new HashMap<>();\n        for (Setting setting : settings) {\n            settingValues.put(setting.getId(), setting.getValue());\n        }\n    }\n    public void update() {\n        session.getTransaction().begin();\n        for (Map.Entry<Long, String> settingValue : settingValues.entrySet()) {\n            Setting setting = session.get(Setting.class, settingValue.getKey());\n            if (settingValue.getValue() != null && settingValue.getValue().trim().length() > 0) setting.setValue(settingValue.getValue());\n            session.update(setting);\n        }\n        session.getTransaction().commit();\n    }\n    /**\n     * @return the users\n     */\n    public List<Setting> getSettings() {\n        return settings;\n    }\n    /**\n     * @param settings the users to set\n     */\n    public void setUsers(List<Setting> settings) {\n        this.settings = settings;\n    }\n    /**\n     * @return the settingValues\n     */\n    public Map<Long, String> getSettingValues() {\n        return settingValues;\n    }\n    /**\n     * @param settingValues the settingValues to set\n     */\n    public void setSettingValues(Map<Long, String> settingValues) {\n        this.settingValues = settingValues;\n    }\n"]]}
{"hexsha": "d11f142bbca59ead04a7dda3b551c1120d7dfa96", "ext": "java", "lang": "Java", "content": "public final class ListValueStackTest\n    extends ValueStackTest\n{\n    @Override\n    protected ValueStack<Object> newStack()\n    {\n        final Collection<Object> values = Arrays.asList(o1, o2, o3, o4, o5, o6);\n        return new ListValueStack<>(values);\n    }\n\n    @Override\n    protected void checkNoContents()\n    {\n        assertThat(stack.isEmpty()).isTrue();\n    }\n\n    @Override\n    protected void checkContents(final Object first, final Object... others)\n    {\n        final List<Object> values = new ArrayList<>();\n        values.add(first);\n        Collections.addAll(values, others);\n\n        final int expectedSize = 1 + others.length;\n\n        assertThat(stack.size()).isEqualTo(expectedSize);\n\n        try (\n            final AutoCloseableSoftAssertions soft\n                = new AutoCloseableSoftAssertions();\n        ) {\n            for (int index = 0; index < expectedSize; index++)\n                soft.assertThat(stack.peek(index))\n                    .as(\"element at index %d\", index)\n                    .isEqualTo(values.get(index));\n        }\n\n    }\n}", "class_id": 0, "repo": "fge/grappa", "file": "src/test/java/com/github/fge/grappa/stack/ListValueStackTest.java", "last_update_at": "2020-11-10T05:08:11+00:00", "question_id": "d11f142bbca59ead04a7dda3b551c1120d7dfa96", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class ListValueStackTest\n    extends ValueStackTest\n{\n    @Override\n    protected ValueStack<Object> newStack()\n    {\n        final Collection<Object> values = Arrays.asList(o1, o2, o3, o4, o5, o6);\n        return new ListValueStack<>(values);\n    }\n    @Override\n    protected void checkNoContents()\n    {\n        assertThat(stack.isEmpty()).isTrue();\n    }\n    @Override\n    protected void checkContents(final Object first, final Object... others)\n    {\n        final List<Object> values = new ArrayList<>();\n        values.add(first);\n        Collections.addAll(values, others);\n        final int expectedSize = 1 + others.length;\n        assertThat(stack.size()).isEqualTo(expectedSize);\n        try (\n            final AutoCloseableSoftAssertions soft\n                = new AutoCloseableSoftAssertions();\n        ) {\n            for (int index = 0; index < expectedSize; index++)\n                soft.assertThat(stack.peek(index))\n                    .as(\"element at index %d\", index)\n                    .isEqualTo(values.get(index));\n        }\n    }\n"]]}
{"hexsha": "e384ee8d3706771eda8bc52ccc8bcea0692fb8c0", "ext": "java", "lang": "Java", "content": "class HeapPostCommit implements Serviceable\n{\n    /**************************************************************************\n     * Fields of the class\n     **************************************************************************\n     */\n\n    private AccessFactory access_factory  = null;\n    private Heap          heap            = null;\n    private long          page_number     = ContainerHandle.INVALID_PAGE_NUMBER;\n\n\n    /**************************************************************************\n     * Constructors for This class:\n     **************************************************************************\n     */\n    HeapPostCommit(\n    AccessFactory   access_factory,\n    Heap            heap,\n    long            input_page_number)\n    {\n        this.access_factory = access_factory; \n        this.heap           = heap; \n        this.page_number    = input_page_number; \n    }\n\n    /**************************************************************************\n     * Private/Protected methods of This class:\n     **************************************************************************\n     */\n\n    /**\n     * Reclaim space taken up by committed deleted rows.\n     * <p>\n     * This routine assumes it has been called by an internal transaction which\n     * has performed no work so far, and that it has an exclusive intent table \n     * lock.  It will attempt obtain exclusive row locks on deleted rows, where\n     * successful those rows can be reclaimed as they must be \"committed \n     * deleted\" rows.\n     * <p>\n     * This routine will latch the page and hold the latch due to interface\n     * requirement from Page.purgeAtSlot.\n     *\n     * @param heap_control  The heap, already opened.\n     * @param pageno        number of page to look for committed deletes.\n     *\n     * @see Page#purgeAtSlot\n     * @exception  StandardException  Standard exception policy.\n     **/\n    private final void purgeCommittedDeletes(\n    HeapController      heap_control,\n    long                pageno)\n        throws StandardException\n    {\n        // The following can fail either if it can't get the latch or\n        // somehow the page requested no longer exists. \n\t\n\t//resolve - what will happen if the user page doesnt exist  \n\n        // wait to get the latch on the page \n        Page page = heap_control.getUserPageWait(pageno);\n        boolean purgingDone = false;\n\n        if (page != null)\n        {\n            try\n            {\n                // The number records that can be reclaimed is:\n                // total recs - recs_not_deleted\n                int num_possible_commit_delete = \n                    page.recordCount() - page.nonDeletedRecordCount();\n\n                if (num_possible_commit_delete > 0)\n                {\n                    // loop backward so that purges which affect the slot table \n                    // don't affect the loop (ie. they only move records we \n                    // have already looked at).\n                    for (int slot_no = page.recordCount() - 1; \n                         slot_no >= 0; \n                         slot_no--) \n                    {\n                        boolean row_is_committed_delete = \n                            page.isDeletedAtSlot(slot_no);\n\n                        if (row_is_committed_delete)\n                        {\n                            // At this point we only know that the row is\n                            // deleted, not whether it is committed.\n\n                            // see if we can purge the row, by getting an\n                            // exclusive lock on the row.  If it is marked\n                            // deleted and we can get this lock, then it\n                            // must be a committed delete and we can purge \n                            // it.\n\n                            RecordHandle rh =\n                                page.fetchFromSlot(\n                                    (RecordHandle) null,\n                                    slot_no,\n                                    RowUtil.EMPTY_ROW,\n                                    RowUtil.EMPTY_ROW_FETCH_DESCRIPTOR,\n                                    true);\n\n                            row_is_committed_delete =\n                                heap_control.lockRowAtSlotNoWaitExclusive(rh);\n\n                            if (row_is_committed_delete)\n                            {\n                                purgingDone = true;\n\n                                page.purgeAtSlot(slot_no, 1, false);\n\n                                if (SanityManager.DEBUG)\n                                {\n                                    if (SanityManager.DEBUG_ON(\n                                            \"verbose_heap_post_commit\"))\n                                    {\n                                        SanityManager.DEBUG_PRINT(\n                                            \"HeapPostCommit\", \n                                            \"Purging row[\" + slot_no + \"]\" + \n                                            \"on page:\" + pageno + \".\\n\");\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (page.recordCount() == 0)\n                {\n                    purgingDone = true;\n\n                    // Deallocate the current page with 0 rows on it.\n                    heap_control.removePage(page);\n\n                    // removePage guarantees to unlatch the page even if an\n                    // exception is thrown. The page is protected against reuse\n                    // because removePage locks it with a dealloc lock, so it\n                    // is OK to release the latch even after a purgeAtSlot is\n                    // called.\n                    // @see ContainerHandle#removePage\n\n                    if (SanityManager.DEBUG)\n                    {\n                        if (SanityManager.DEBUG_ON(\"verbose_heap_post_commit\"))\n                        {\n                            SanityManager.DEBUG_PRINT(\n                                \"HeapPostCommit\", \n                                \"Calling Heap removePage().; pagenumber=\"+pageno+\"\\n\");\n                        }\n                    }\n                }\n            }\n            finally\n            {\n                // If no purge happened on the page and the page is not\n                // removed, feel free to unlatch it.  Otherwise, let\n                // transaction commit take care of it.\n\t\t\t\tif (!purgingDone)\n                {\n                    page.unlatch();\n                    page = null;\n                }\n            }\n        }\n        else\n        {\n            if (SanityManager.DEBUG)\n            {\n                if (SanityManager.DEBUG_ON(\"verbose_heap_post_commit\"))\n                {\n                    SanityManager.DEBUG_PRINT(\n                        \"HeapPostCommit\", \n                        \"Get No Wait returned null. page num = \" + \n                        pageno + \"\\n\");\n\n                    SanityManager.showTrace(new Throwable());\n                }\n            }\n        }\n        return;\n    }\n\n    /**************************************************************************\n     * Public Methods implementing the Serviceable interface:\n     **************************************************************************\n     */\n\n    /**\n     * The urgency of this post commit work.\n     * <p>\n     * This determines where this Serviceable is put in the post commit \n     * queue.  Post commit work in the heap can be safely delayed until there\n     * is not user work to do.\n     *\n     * @return false, this work should not be serviced ASAP\n     **/\n    public boolean serviceASAP()\n    {\n        return(true);\n    }\n\n\t// @return true, if this work needs to be done on a user thread immediately\n\tpublic boolean serviceImmediately()\n\t{\n\t\treturn false;\n\t}\t\n\n\n    /**\n     * perform the work described in the postcommit work.\n     * <p>\n     * In this implementation the only work that can be executed by this\n     * post commit processor is this class itself.\n     * <p>\n     *\n     * @return Returns Serviceable.DONE when work has completed, or\n     *         returns Serviceable.REQUEUE if work needs to be requeued.\n     *\n     * @param contextMgr the context manager started by the post commit daemon\n     *\n     * @exception  StandardException  Standard exception policy.\n     **/\n    public int performWork(ContextManager contextMgr)\n        throws StandardException\n    {\n      // Gemstone changes begin.  \n      TransactionManager  tc             = (TransactionManager)\n            this.access_factory.getAndNameTransaction(\n                contextMgr, AccessFactoryGlobals.SYS_TRANS_NAME);\n      // Gemstone changes end.\n\n        TransactionManager  internal_xact  = tc.getInternalTransaction();\n\n        // only requeue if work was not completed in this try.\n        boolean             requeue_work = false;\n\n        HeapController      heapcontroller;\n\n        if (SanityManager.DEBUG)\n        {\n            if (SanityManager.DEBUG_ON(\"verbose_heap_post_commit\"))\n                SanityManager.DEBUG_PRINT(\n                    \"HeapPostCommit\", \"starting internal xact\\n\");\n        }\n\n        try\n        {\n            // This call will attempt to open the heap table locked with \n            // table level IX mode, preparing to do record level locked space \n            // reclamation.  \n            //\n            // The call will either succeed immediately, or throw an exception\n            // which could mean the container does not exist or that the lock\n            // could not be granted immediately. \n\n\t\t\t//Reversed the fix for 4255:\n\t\t\t//page reclaimation is done asynchronosly by raswstore daemon\n\t\t\t//not good to WAIT FOR LOCKS , as it can freeze the daemon\n\t\t\t//If we can not get the lock this reclamation request will \n\t\t\t//requeued.\n\n            heapcontroller = (HeapController)\n                heap.open(\n                    internal_xact,\n                    internal_xact.getRawStoreXact(),\n                    false,\n                    ContainerHandle.MODE_FORUPDATE |\n                    ContainerHandle.MODE_LOCK_NOWAIT,\n                    TransactionController.MODE_RECORD,\n                    internal_xact.getRawStoreXact().newLockingPolicy(\n                        LockingPolicy.MODE_RECORD,\n                        TransactionController.ISOLATION_REPEATABLE_READ, true),\n                    heap,\n                    (DynamicCompiledOpenConglomInfo) null);\n\n            // We got a table intent lock, all deleted rows we encounter can\n            // be reclaimed, once an \"X\" row lock is obtained on them.\n\n            // Process all the rows on the page while holding the latch.\n            purgeCommittedDeletes(heapcontroller, this.page_number);\n\n        }\n        catch (StandardException se)\n        {\n            // exception might have occured either container got dropper or lock not granted.\n            // It is possible by the time this post commit work gets scheduled \n            // that the container has been dropped and that the open container \n            // call will return null - in this case just return assuming no \n            // work to be done.\n\n\t\t\t//If this expcetion is because lock could not be obtained , work is requeued.\n\t\t\tif (se.getMessageId().equals(SQLState.LOCK_TIMEOUT) || \n\t\t\t\tse.getMessageId().equals(SQLState.DEADLOCK))\n\t\t\t{\n\t\t\t\trequeue_work = true;\n\t\t\t}\n\n            // Do not close the controller because that will unlatch the\n            // page.  Let the commit and destroy do release the latch and\n            // close the controller.\n            // heapcontroller.close();\n        }\n            \n        // It is ok to not sync this post work.  If no subsequent log record\n        // is sync'd to disk then it is ok that this transaction not make\n        // it to the database.  If any subsequent transaction is sync'd to\n        // the log file, then this transaction will be sync'd as part of that\n        // work.\n\n        internal_xact.commitNoSync(Transaction.RELEASE_LOCKS);\n        internal_xact.destroy();\n\n\n        if (SanityManager.DEBUG)\n        {\n            if (SanityManager.DEBUG_ON(\"verbose_heap_post_commit\"))\n            {\n                if (requeue_work)\n                    SanityManager.DEBUG_PRINT(\n                        \"HeapPostCommit\", \n                        \"requeueing on page num = \" + page_number);\n            }\n        }\n\n        return(requeue_work ? Serviceable.REQUEUE : Serviceable.DONE);\n    }\n}", "class_id": 0, "repo": "xyxiaoyou/snappy-store", "file": "gemfirexd/core/src/main/java/com/pivotal/gemfirexd/internal/impl/store/access/heap/HeapPostCommit.java", "last_update_at": "2020-04-07T06:35:36+00:00", "question_id": "e384ee8d3706771eda8bc52ccc8bcea0692fb8c0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class HeapPostCommit implements Serviceable\n{\n    /**************************************************************************\n     * Fields of the class\n     **************************************************************************\n     */\n    private AccessFactory access_factory  = null;\n    private Heap          heap            = null;\n    private long          page_number     = ContainerHandle.INVALID_PAGE_NUMBER;\n    /**************************************************************************\n     * Constructors for This class:\n     **************************************************************************\n     */\n    HeapPostCommit(\n    AccessFactory   access_factory,\n    Heap            heap,\n    long            input_page_number)\n    {\n        this.access_factory = access_factory; \n        this.heap           = heap; \n        this.page_number    = input_page_number; \n    }\n    /**************************************************************************\n     * Private/Protected methods of This class:\n     **************************************************************************\n     */\n    /**\n     * Reclaim space taken up by committed deleted rows.\n     * <p>\n     * This routine assumes it has been called by an internal transaction which\n     * has performed no work so far, and that it has an exclusive intent table \n     * lock.  It will attempt obtain exclusive row locks on deleted rows, where\n     * successful those rows can be reclaimed as they must be \"committed \n     * deleted\" rows.\n     * <p>\n     * This routine will latch the page and hold the latch due to interface\n     * requirement from Page.purgeAtSlot.\n     *\n     * @param heap_control  The heap, already opened.\n     * @param pageno        number of page to look for committed deletes.\n     *\n     * @see Page#purgeAtSlot\n     * @exception  StandardException  Standard exception policy.\n     **/\n    private final void purgeCommittedDeletes(\n    HeapController      heap_control,\n    long                pageno)\n        throws StandardException\n    {\n        // The following can fail either if it can't get the latch or\n        // somehow the page requested no longer exists. \n\t\n\t//resolve - what will happen if the user page doesnt exist  \n        // wait to get the latch on the page \n        Page page = heap_control.getUserPageWait(pageno);\n        boolean purgingDone = false;\n        if (page != null)\n        {\n            try\n            {\n                // The number records that can be reclaimed is:\n                // total recs - recs_not_deleted\n                int num_possible_commit_delete = \n                    page.recordCount() - page.nonDeletedRecordCount();\n                if (num_possible_commit_delete > 0)\n                {\n                    // loop backward so that purges which affect the slot table \n                    // don't affect the loop (ie. they only move records we \n                    // have already looked at).\n                    for (int slot_no = page.recordCount() - 1; \n                         slot_no >= 0; \n                         slot_no--) \n                    {\n                        boolean row_is_committed_delete = \n                            page.isDeletedAtSlot(slot_no);\n                        if (row_is_committed_delete)\n                        {\n                            // At this point we only know that the row is\n                            // deleted, not whether it is committed.\n                            // see if we can purge the row, by getting an\n                            // exclusive lock on the row.  If it is marked\n                            // deleted and we can get this lock, then it\n                            // must be a committed delete and we can purge \n                            // it.\n                            RecordHandle rh =\n                                page.fetchFromSlot(\n                                    (RecordHandle) null,\n                                    slot_no,\n                                    RowUtil.EMPTY_ROW,\n                                    RowUtil.EMPTY_ROW_FETCH_DESCRIPTOR,\n                                    true);\n                            row_is_committed_delete =\n                                heap_control.lockRowAtSlotNoWaitExclusive(rh);\n                            if (row_is_committed_delete)\n                            {\n                                purgingDone = true;\n                                page.purgeAtSlot(slot_no, 1, false);\n                                if (SanityManager.DEBUG)\n                                {\n                                    if (SanityManager.DEBUG_ON(\n                                            \"verbose_heap_post_commit\"))\n                                    {\n                                        SanityManager.DEBUG_PRINT(\n                                            \"HeapPostCommit\", \n                                            \"Purging row[\" + slot_no + \"]\" + \n                                            \"on page:\" + pageno + \".\\n\");\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (page.recordCount() == 0)\n                {\n                    purgingDone = true;\n                    // Deallocate the current page with 0 rows on it.\n                    heap_control.removePage(page);\n                    // removePage guarantees to unlatch the page even if an\n                    // exception is thrown. The page is protected against reuse\n                    // because removePage locks it with a dealloc lock, so it\n                    // is OK to release the latch even after a purgeAtSlot is\n                    // called.\n                    // @see ContainerHandle#removePage\n                    if (SanityManager.DEBUG)\n                    {\n                        if (SanityManager.DEBUG_ON(\"verbose_heap_post_commit\"))\n                        {\n                            SanityManager.DEBUG_PRINT(\n                                \"HeapPostCommit\", \n                                \"Calling Heap removePage().; pagenumber=\"+pageno+\"\\n\");\n                        }\n                    }\n                }\n            }\n            finally\n            {\n                // If no purge happened on the page and the page is not\n                // removed, feel free to unlatch it.  Otherwise, let\n                // transaction commit take care of it.\n\t\t\t\tif (!purgingDone)\n                {\n                    page.unlatch();\n                    page = null;\n                }\n            }\n        }\n        else\n        {\n            if (SanityManager.DEBUG)\n            {\n                if (SanityManager.DEBUG_ON(\"verbose_heap_post_commit\"))\n                {\n                    SanityManager.DEBUG_PRINT(\n                        \"HeapPostCommit\", \n                        \"Get No Wait returned null. page num = \" + \n                        pageno + \"\\n\");\n                    SanityManager.showTrace(new Throwable());\n                }\n            }\n        }\n        return;\n    }\n    /**************************************************************************\n     * Public Methods implementing the Serviceable interface:\n     **************************************************************************\n     */\n    /**\n     * The urgency of this post commit work.\n     * <p>\n     * This determines where this Serviceable is put in the post commit \n     * queue.  Post commit work in the heap can be safely delayed until there\n     * is not user work to do.\n     *\n     * @return false, this work should not be serviced ASAP\n     **/\n    public boolean serviceASAP()\n    {\n        return(true);\n    }\n\t// @return true, if this work needs to be done on a user thread immediately\n\tpublic boolean serviceImmediately()\n\t{\n\t\treturn false;\n\t}\t\n    /**\n     * perform the work described in the postcommit work.\n     * <p>\n     * In this implementation the only work that can be executed by this\n     * post commit processor is this class itself.\n     * <p>\n     *\n     * @return Returns Serviceable.DONE when work has completed, or\n     *         returns Serviceable.REQUEUE if work needs to be requeued.\n     *\n     * @param contextMgr the context manager started by the post commit daemon\n     *\n     * @exception  StandardException  Standard exception policy.\n     **/\n    public int performWork(ContextManager contextMgr)\n        throws StandardException\n    {\n      // Gemstone changes begin.  \n      TransactionManager  tc             = (TransactionManager)\n            this.access_factory.getAndNameTransaction(\n                contextMgr, AccessFactoryGlobals.SYS_TRANS_NAME);\n      // Gemstone changes end.\n        TransactionManager  internal_xact  = tc.getInternalTransaction();\n        // only requeue if work was not completed in this try.\n        boolean             requeue_work = false;\n        HeapController      heapcontroller;\n        if (SanityManager.DEBUG)\n        {\n            if (SanityManager.DEBUG_ON(\"verbose_heap_post_commit\"))\n                SanityManager.DEBUG_PRINT(\n                    \"HeapPostCommit\", \"starting internal xact\\n\");\n        }\n        try\n        {\n            // This call will attempt to open the heap table locked with \n            // table level IX mode, preparing to do record level locked space \n            // reclamation.  \n            //\n            // The call will either succeed immediately, or throw an exception\n            // which could mean the container does not exist or that the lock\n            // could not be granted immediately. \n\t\t\t//Reversed the fix for 4255:\n\t\t\t//page reclaimation is done asynchronosly by raswstore daemon\n\t\t\t//not good to WAIT FOR LOCKS , as it can freeze the daemon\n\t\t\t//If we can not get the lock this reclamation request will \n\t\t\t//requeued.\n            heapcontroller = (HeapController)\n                heap.open(\n                    internal_xact,\n                    internal_xact.getRawStoreXact(),\n                    false,\n                    ContainerHandle.MODE_FORUPDATE |\n                    ContainerHandle.MODE_LOCK_NOWAIT,\n                    TransactionController.MODE_RECORD,\n                    internal_xact.getRawStoreXact().newLockingPolicy(\n                        LockingPolicy.MODE_RECORD,\n                        TransactionController.ISOLATION_REPEATABLE_READ, true),\n                    heap,\n                    (DynamicCompiledOpenConglomInfo) null);\n            // We got a table intent lock, all deleted rows we encounter can\n            // be reclaimed, once an \"X\" row lock is obtained on them.\n            // Process all the rows on the page while holding the latch.\n            purgeCommittedDeletes(heapcontroller, this.page_number);\n        }\n        catch (StandardException se)\n        {\n            // exception might have occured either container got dropper or lock not granted.\n            // It is possible by the time this post commit work gets scheduled \n            // that the container has been dropped and that the open container \n            // call will return null - in this case just return assuming no \n            // work to be done.\n\t\t\t//If this expcetion is because lock could not be obtained , work is requeued.\n\t\t\tif (se.getMessageId().equals(SQLState.LOCK_TIMEOUT) || \n\t\t\t\tse.getMessageId().equals(SQLState.DEADLOCK))\n\t\t\t{\n\t\t\t\trequeue_work = true;\n\t\t\t}\n            // Do not close the controller because that will unlatch the\n            // page.  Let the commit and destroy do release the latch and\n            // close the controller.\n            // heapcontroller.close();\n        }\n        // It is ok to not sync this post work.  If no subsequent log record\n        // is sync'd to disk then it is ok that this transaction not make\n        // it to the database.  If any subsequent transaction is sync'd to\n        // the log file, then this transaction will be sync'd as part of that\n        // work.\n        internal_xact.commitNoSync(Transaction.RELEASE_LOCKS);\n        internal_xact.destroy();\n        if (SanityManager.DEBUG)\n        {\n            if (SanityManager.DEBUG_ON(\"verbose_heap_post_commit\"))\n            {\n                if (requeue_work)\n                    SanityManager.DEBUG_PRINT(\n                        \"HeapPostCommit\", \n                        \"requeueing on page num = \" + page_number);\n            }\n        }\n        return(requeue_work ? Serviceable.REQUEUE : Serviceable.DONE);\n    }\n"]]}
{"hexsha": "07512f789654c0ad756fa362edc5312fdc9fe207", "ext": "java", "lang": "Java", "content": "public class LoggingSanitizerTest {\n\n    /**\n     * The same as {@link LoggingSanitizer#SANITIZED_SUFIX}\n     */\n    private String SANITIZED_SUFIX = \" (Sanitized)\";\n\n\n    /**\n     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,\n     * the String received as parameter contains Carriage Return (ASCII 13, \\r) and Line Feed (ASCII 10, \\n) characters.\n     */\n    @Test\n    public void testRemoveCRLFInjectionStringWithCRLF() {\n        final String message = \"DEMO-SP\\\\n2017-04-28; 13:10:29.328 [ajp-nio-8009-exec-10] INFO gOtThEmIlK\\\\n\\\\r\\\\n\\\\r\";\n        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);\n        assertCrlfRemovalApplied(message, messageWithoutCRLFInjection);\n    }\n\n    /**\n     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,\n     * the String received as parameter does contains Carriage Return (ASCII 13, \\r) and Line Feed (ASCII 10, \\n) characters.\n     */\n    @Test\n    public void testRemoveCRLFInjection() {\n        final String message = \"DEMO-SP 2017-04-28; 13:10:29.328 [ajp-nio-8009-exec-10] INFO gOtThEmIlK\";\n        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);\n        assertCrlfRemovalNotApplied(message, messageWithoutCRLFInjection);\n    }\n\n    /**\n     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,\n     * the String received as parameter is an URL.\n     */\n    @Test\n    public void testRemoveCRLFInjectionUrl() {\n        final String message = \"http://localhost$-_.+!*'(),:8080/EidasNode/ColleagueRequest\";\n        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);\n        assertCrlfRemovalNotApplied(message, messageWithoutCRLFInjection);\n    }\n\n    /**\n     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,\n     * the String received as parameter is an URL with CRLF.\n     */\n    @Test\n    public void testRemoveCRLFInjectionUrlWithCRLF() {\n        final String message = \"http://localhost$-_.+!*'(),:8080/\\\\n\\\\rEidasNode/ColleagueRequest\";\n        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);\n        assertCrlfRemovalApplied(message, messageWithoutCRLFInjection);\n    }\n\n    /**\n     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,\n     * the String received as parameter is an ID.\n     */\n    @Test\n    public void testRemoveCRLFInjectionId() {\n        final String message = \"_3WcFUc9H8b8a1kHoS.DfLcmyUR9WREN_2W6ejrWJFPrueVt-I6GcWaZx76EzQzv\";\n        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);\n        assertCrlfRemovalNotApplied(message, messageWithoutCRLFInjection);\n    }\n\n    /**\n     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,\n     * the String received as parameter is an ID with CRLF.\n     */\n    @Test\n    public void testRemoveCRLFInjectionIdWithCRLF() {\n        final String message = \"_3WcFUc9H8b8a1kHoS.DfLcmyUR9WREN_2W6ejrWJFPrueVt-I6GcWaZx76EzQzv\\\\r\";\n        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);\n        assertCrlfRemovalApplied(message, messageWithoutCRLFInjection);\n    }\n\n    /**\n     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,\n     * the String received as parameter is an Hash.\n     */\n    @Test\n    public void testRemoveCRLFInjectionHash() {\n        final String message = \"NU3P2SBD8BRUN9yEWoO5RbZP/BijYjrciZnKtrlxU6zexWYRlOWzdWH0HpofKynOcYVb/eO/OWzK26WtwkoEBA==\";\n        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);\n        assertCrlfRemovalNotApplied(message, messageWithoutCRLFInjection);\n    }\n\n    /**\n     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,\n     * the String received as parameter is an Hash with CRLF.\n     */\n    @Test\n    public void testRemoveCRLFInjectionHashWithCRLF() {\n        final String message = \"NU3P2SBD8BRUN9yEWoO5RbZP/BijYjrciZnKtr\\\\nlxU6zexWYRlOWzdWH0HpofKynOcYVb/eO/OWzK26WtwkoEBA==\";\n        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);\n        assertCrlfRemovalApplied(message, messageWithoutCRLFInjection);\n    }\n\n    /**\n     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,\n     * the String received as parameter is Null.\n     */\n    @Test\n    public void testRemoveCRLFInjectionNullParameter() {\n        final String message = \"NU3P2SBD8BRUN9yEWoO5RbZP/BijYjrciZnKtrlxU6zexWYRlOWzdWH0HpofKynOcYVb/eO/OWzK26WtwkoEBA==\";\n        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);\n        assertCrlfRemovalNotApplied(message,messageWithoutCRLFInjection);\n    }\n\n    /**\n     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,\n     * the String received as parameter is an empty string.\n     */\n    @Test\n    public void testRemoveCRLFInjectionEmptyParameter() {\n        final String message = \"\";\n        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);\n        assertCrlfRemovalNotApplied(message, messageWithoutCRLFInjection);\n    }\n\n\n    /**\n     * Auxiliar method that contains the assertions when CRLF removal was applied.\n     *\n     * @param messageIn the inital string before CRLF removal\n     * @param messageOut the output string after CRLF removal\n     */\n    private void assertCrlfRemovalApplied(String messageIn, String messageOut) {\n        Assert.assertNotEquals(messageIn,messageOut);\n        SANITIZED_SUFIX = \" (Sanitized)\";\n        Assert.assertTrue(\"The Sanitized Sufix was not appended\",messageOut.contains(SANITIZED_SUFIX));\n    }\n\n    /**\n     * Auxiliar method that contains the assertions when CRLF removal was applied.\n     *\n     * @param messageIn the inital string before CRLF removal\n     * @param messageOut the output string after CRLF removal\n     */\n    private void assertCrlfRemovalNotApplied(String messageIn, String messageOut) {\n        Assert.assertEquals(messageIn,messageOut);\n        Assert.assertFalse(\"The Sanitized Sufix was appended\",messageOut.contains(SANITIZED_SUFIX));\n    }\n\n}", "class_id": 0, "repo": "swedenconnect/eidas-eu-mock", "file": "EIDAS-Sources-2.5.0-SNAPSHOT-MDSL/EIDAS-Node/src/test/java/eu/eidas/node/utils/LoggingSanitizerTest.java", "last_update_at": "2020-06-09T08:15:00+00:00", "question_id": "07512f789654c0ad756fa362edc5312fdc9fe207", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LoggingSanitizerTest {\n    /**\n     * The same as {@link LoggingSanitizer#SANITIZED_SUFIX}\n     */\n    private String SANITIZED_SUFIX = \" (Sanitized)\";\n    /**\n     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,\n     * the String received as parameter contains Carriage Return (ASCII 13, \\r) and Line Feed (ASCII 10, \\n) characters.\n     */\n    @Test\n    public void testRemoveCRLFInjectionStringWithCRLF() {\n        final String message = \"DEMO-SP\\\\n2017-04-28; 13:10:29.328 [ajp-nio-8009-exec-10] INFO gOtThEmIlK\\\\n\\\\r\\\\n\\\\r\";\n        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);\n        assertCrlfRemovalApplied(message, messageWithoutCRLFInjection);\n    }\n    /**\n     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,\n     * the String received as parameter does contains Carriage Return (ASCII 13, \\r) and Line Feed (ASCII 10, \\n) characters.\n     */\n    @Test\n    public void testRemoveCRLFInjection() {\n        final String message = \"DEMO-SP 2017-04-28; 13:10:29.328 [ajp-nio-8009-exec-10] INFO gOtThEmIlK\";\n        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);\n        assertCrlfRemovalNotApplied(message, messageWithoutCRLFInjection);\n    }\n    /**\n     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,\n     * the String received as parameter is an URL.\n     */\n    @Test\n    public void testRemoveCRLFInjectionUrl() {\n        final String message = \"http://localhost$-_.+!*'(),:8080/EidasNode/ColleagueRequest\";\n        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);\n        assertCrlfRemovalNotApplied(message, messageWithoutCRLFInjection);\n    }\n    /**\n     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,\n     * the String received as parameter is an URL with CRLF.\n     */\n    @Test\n    public void testRemoveCRLFInjectionUrlWithCRLF() {\n        final String message = \"http://localhost$-_.+!*'(),:8080/\\\\n\\\\rEidasNode/ColleagueRequest\";\n        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);\n        assertCrlfRemovalApplied(message, messageWithoutCRLFInjection);\n    }\n    /**\n     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,\n     * the String received as parameter is an ID.\n     */\n    @Test\n    public void testRemoveCRLFInjectionId() {\n        final String message = \"_3WcFUc9H8b8a1kHoS.DfLcmyUR9WREN_2W6ejrWJFPrueVt-I6GcWaZx76EzQzv\";\n        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);\n        assertCrlfRemovalNotApplied(message, messageWithoutCRLFInjection);\n    }\n    /**\n     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,\n     * the String received as parameter is an ID with CRLF.\n     */\n    @Test\n    public void testRemoveCRLFInjectionIdWithCRLF() {\n        final String message = \"_3WcFUc9H8b8a1kHoS.DfLcmyUR9WREN_2W6ejrWJFPrueVt-I6GcWaZx76EzQzv\\\\r\";\n        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);\n        assertCrlfRemovalApplied(message, messageWithoutCRLFInjection);\n    }\n    /**\n     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,\n     * the String received as parameter is an Hash.\n     */\n    @Test\n    public void testRemoveCRLFInjectionHash() {\n        final String message = \"NU3P2SBD8BRUN9yEWoO5RbZP/BijYjrciZnKtrlxU6zexWYRlOWzdWH0HpofKynOcYVb/eO/OWzK26WtwkoEBA==\";\n        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);\n        assertCrlfRemovalNotApplied(message, messageWithoutCRLFInjection);\n    }\n    /**\n     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,\n     * the String received as parameter is an Hash with CRLF.\n     */\n    @Test\n    public void testRemoveCRLFInjectionHashWithCRLF() {\n        final String message = \"NU3P2SBD8BRUN9yEWoO5RbZP/BijYjrciZnKtr\\\\nlxU6zexWYRlOWzdWH0HpofKynOcYVb/eO/OWzK26WtwkoEBA==\";\n        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);\n        assertCrlfRemovalApplied(message, messageWithoutCRLFInjection);\n    }\n    /**\n     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,\n     * the String received as parameter is Null.\n     */\n    @Test\n    public void testRemoveCRLFInjectionNullParameter() {\n        final String message = \"NU3P2SBD8BRUN9yEWoO5RbZP/BijYjrciZnKtrlxU6zexWYRlOWzdWH0HpofKynOcYVb/eO/OWzK26WtwkoEBA==\";\n        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);\n        assertCrlfRemovalNotApplied(message,messageWithoutCRLFInjection);\n    }\n    /**\n     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,\n     * the String received as parameter is an empty string.\n     */\n    @Test\n    public void testRemoveCRLFInjectionEmptyParameter() {\n        final String message = \"\";\n        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);\n        assertCrlfRemovalNotApplied(message, messageWithoutCRLFInjection);\n    }\n    /**\n     * Auxiliar method that contains the assertions when CRLF removal was applied.\n     *\n     * @param messageIn the inital string before CRLF removal\n     * @param messageOut the output string after CRLF removal\n     */\n    private void assertCrlfRemovalApplied(String messageIn, String messageOut) {\n        Assert.assertNotEquals(messageIn,messageOut);\n        SANITIZED_SUFIX = \" (Sanitized)\";\n        Assert.assertTrue(\"The Sanitized Sufix was not appended\",messageOut.contains(SANITIZED_SUFIX));\n    }\n    /**\n     * Auxiliar method that contains the assertions when CRLF removal was applied.\n     *\n     * @param messageIn the inital string before CRLF removal\n     * @param messageOut the output string after CRLF removal\n     */\n    private void assertCrlfRemovalNotApplied(String messageIn, String messageOut) {\n        Assert.assertEquals(messageIn,messageOut);\n        Assert.assertFalse(\"The Sanitized Sufix was appended\",messageOut.contains(SANITIZED_SUFIX));\n    }\n"]]}
{"hexsha": "a5ed88b60810840a9ad61b3ccf665cecb25aae33", "ext": "java", "lang": "Java", "content": "@SuppressWarnings(\"all\")\npublic class EventBContainerManager extends StateBasedContainerManager {\n  @Override\n  protected List<IContainer> getVisibleContainers(final List<String> handles, final IResourceDescriptions resourceDescriptions) {\n    List<IContainer> result = super.getVisibleContainers(handles, resourceDescriptions);\n    Iterable<IResourceDescription> _allResourceDescriptions = resourceDescriptions.getAllResourceDescriptions();\n    for (final IResourceDescription rd : _allResourceDescriptions) {\n      {\n        IContainer container = super.getContainer(rd, resourceDescriptions);\n        boolean _isEmpty = container.isEmpty();\n        boolean _not = (!_isEmpty);\n        if (_not) {\n          result.add(container);\n        }\n      }\n    }\n    return result;\n  }\n}", "class_id": 0, "repo": "tshoang/XEventB", "file": "ac.soton.xeventb.common/xtend-gen/ac/soton/xeventb/common/EventBContainerManager.java", "last_update_at": "2020-12-01T13:48:27+00:00", "question_id": "a5ed88b60810840a9ad61b3ccf665cecb25aae33", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings(\"all\")\npublic class EventBContainerManager extends StateBasedContainerManager {\n  @Override\n  protected List<IContainer> getVisibleContainers(final List<String> handles, final IResourceDescriptions resourceDescriptions) {\n    List<IContainer> result = super.getVisibleContainers(handles, resourceDescriptions);\n    Iterable<IResourceDescription> _allResourceDescriptions = resourceDescriptions.getAllResourceDescriptions();\n    for (final IResourceDescription rd : _allResourceDescriptions) {\n      {\n        IContainer container = super.getContainer(rd, resourceDescriptions);\n        boolean _isEmpty = container.isEmpty();\n        boolean _not = (!_isEmpty);\n        if (_not) {\n          result.add(container);\n        }\n      }\n    }\n    return result;\n  }\n"]]}
{"hexsha": "1095f883169fe8e73414faba2c65ad8c7b569ea6", "ext": "java", "lang": "Java", "content": "public class FloatType extends NumericType {\n\n  private static FloatType instance = null;\n\n  public static FloatType getType() {\n    if (instance != null) {\n      return instance;\n    }\n    instance = new FloatType();\n    return instance;\n  }\n\n  @Override\n  public boolean isFloatType() {\n    return true;\n  }\n\n  @Override\n  public String getName() {\n    return \"float\";\n  }\n\n  @Override\n  public String getCName() {\n    return \"double\";\n  }\n\n  @Override\n  public Type combine(Type that) {\n    // Combining two equal types always works\n    if (that.equals(this)) {\n      return this;\n    }\n\n    if (that.equals(Type.getIntegerType())) {\n      return Type.getFloatType();\n    }\n\n    // Every remaining type will throw a RuntimeException\n    throw new RuntimeException(\"Type missmatch: cannot combine \" + this.getName() + \" and \" + that.getName());\n  }\n\n}", "class_id": 0, "repo": "EmpTec/KLangCompiler", "file": "src/main/java/de/hsrm/compiler/Klang/types/FloatType.java", "last_update_at": "2020-03-24T18:39:46+00:00", "question_id": "1095f883169fe8e73414faba2c65ad8c7b569ea6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FloatType extends NumericType {\n  private static FloatType instance = null;\n  public static FloatType getType() {\n    if (instance != null) {\n      return instance;\n    }\n    instance = new FloatType();\n    return instance;\n  }\n  @Override\n  public boolean isFloatType() {\n    return true;\n  }\n  @Override\n  public String getName() {\n    return \"float\";\n  }\n  @Override\n  public String getCName() {\n    return \"double\";\n  }\n  @Override\n  public Type combine(Type that) {\n    // Combining two equal types always works\n    if (that.equals(this)) {\n      return this;\n    }\n    if (that.equals(Type.getIntegerType())) {\n      return Type.getFloatType();\n    }\n    // Every remaining type will throw a RuntimeException\n    throw new RuntimeException(\"Type missmatch: cannot combine \" + this.getName() + \" and \" + that.getName());\n  }\n"]]}
{"hexsha": "34ed57f18542aefc1b065339326099827dff7837", "ext": "java", "lang": "Java", "content": "public class ModSetup {\n\n    public static File modConfigDir;\n    public static boolean lostcities = false;\n    private Logger logger;\n\n    private Configuration mainConfig;\n\n    public void preInit(FMLPreInitializationEvent e) {\n        logger = e.getModLog();\n\n        MinecraftForge.EVENT_BUS.register(new ForgeEventHandlers());\n\n        lostcities = Loader.isModLoaded(\"lostcities\");\n\n        modConfigDir = e.getModConfigurationDirectory();\n        mainConfig = new Configuration(new File(modConfigDir.getPath(), \"enigma.cfg\"));\n\n        EnigmaMessages.registerMessages(\"enigma\");\n\n        readMainConfig();\n        ModItems.init();\n        ModBlocks.init();\n        FxAnimationHandler.init();\n    }\n\n    public Logger getLogger() {\n        return logger;\n    }\n\n    private void readMainConfig() {\n        Configuration cfg = mainConfig;\n        try {\n            cfg.load();\n//            cfg.addCustomCategoryComment(GeneralConfiguration.CATEGORY_GENERAL, \"General settings\");\n\n//            GeneralConfiguration.init(cfg);\n        } catch (Exception e1) {\n            FMLLog.log(Level.ERROR, e1, \"Problem loading config file!\");\n        } finally {\n            if (mainConfig.hasChanged()) {\n                mainConfig.save();\n            }\n        }\n    }\n\n    public void init(FMLInitializationEvent e) {\n    }\n\n    public void postInit(FMLPostInitializationEvent e) {\n        mainConfig = null;\n    }\n\n    public World getClientWorld() {\n        throw new IllegalStateException(\"This should only be called from client side\");\n    }\n\n    public EntityPlayer getClientPlayer() {\n        throw new IllegalStateException(\"This should only be called from client side\");\n    }\n\n    public <V> ListenableFuture<V> addScheduledTaskClient(Callable<V> callableToSchedule) {\n        throw new IllegalStateException(\"This should only be called from client side\");\n    }\n\n    public ListenableFuture<Object> addScheduledTaskClient(Runnable runnableToSchedule) {\n        throw new IllegalStateException(\"This should only be called from client side\");\n    }\n\n    public boolean isClient() {\n        return false;\n    }\n}", "class_id": 0, "repo": "McJty/Enigma", "file": "src/main/java/mcjty/enigma/setup/ModSetup.java", "last_update_at": "2020-06-22T08:46:19+00:00", "question_id": "34ed57f18542aefc1b065339326099827dff7837", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ModSetup {\n    public static File modConfigDir;\n    public static boolean lostcities = false;\n    private Logger logger;\n    private Configuration mainConfig;\n    public void preInit(FMLPreInitializationEvent e) {\n        logger = e.getModLog();\n        MinecraftForge.EVENT_BUS.register(new ForgeEventHandlers());\n        lostcities = Loader.isModLoaded(\"lostcities\");\n        modConfigDir = e.getModConfigurationDirectory();\n        mainConfig = new Configuration(new File(modConfigDir.getPath(), \"enigma.cfg\"));\n        EnigmaMessages.registerMessages(\"enigma\");\n        readMainConfig();\n        ModItems.init();\n        ModBlocks.init();\n        FxAnimationHandler.init();\n    }\n    public Logger getLogger() {\n        return logger;\n    }\n    private void readMainConfig() {\n        Configuration cfg = mainConfig;\n        try {\n            cfg.load();\n//            cfg.addCustomCategoryComment(GeneralConfiguration.CATEGORY_GENERAL, \"General settings\");\n//            GeneralConfiguration.init(cfg);\n        } catch (Exception e1) {\n            FMLLog.log(Level.ERROR, e1, \"Problem loading config file!\");\n        } finally {\n            if (mainConfig.hasChanged()) {\n                mainConfig.save();\n            }\n        }\n    }\n    public void init(FMLInitializationEvent e) {\n    }\n    public void postInit(FMLPostInitializationEvent e) {\n        mainConfig = null;\n    }\n    public World getClientWorld() {\n        throw new IllegalStateException(\"This should only be called from client side\");\n    }\n    public EntityPlayer getClientPlayer() {\n        throw new IllegalStateException(\"This should only be called from client side\");\n    }\n    public <V> ListenableFuture<V> addScheduledTaskClient(Callable<V> callableToSchedule) {\n        throw new IllegalStateException(\"This should only be called from client side\");\n    }\n    public ListenableFuture<Object> addScheduledTaskClient(Runnable runnableToSchedule) {\n        throw new IllegalStateException(\"This should only be called from client side\");\n    }\n    public boolean isClient() {\n        return false;\n    }\n"]]}
{"hexsha": "5f190015d0ca9e6efd9166c1747319a5edf26c51", "ext": "java", "lang": "Java", "content": "public class StringArrayUtil {\n\n    public static String[] listToArray(List<String> list) {\n        String[] array = new String[list.size()];\n        return list.toArray(array);\n    }\n\n    public static String[] listToArrayRemoveDuplicates(List<String> list) {\n        if (list == null) {\n            return new String[0];\n        }\n        LinkedHashSet<String> set = new LinkedHashSet<>(list);\n        return listToArray(new ArrayList<>(set));\n    }\n\n    public static List<String> arrayToList(String[] array) {\n        return array != null && array.length != 0 ? new ArrayList<>(Arrays.asList(array)) : new ArrayList<>();\n    }\n\n    public static String joinStringList(List<String> strings, String joinChar, Integer maxLength) {\n        final String str = String.join(joinChar == null ? \", \" : joinChar, strings);\n        return maxLength == null ? str : str.substring(maxLength);\n    }\n\n    public static boolean isAllEmptyOrNull(List<String> strings) {\n        return strings == null || strings.isEmpty() || strings.stream().allMatch(StringUtils::isEmpty);\n    }\n}", "class_id": 0, "repo": "grassrootza/grassroot-platform", "file": "grassroot-core/src/main/java/za/org/grassroot/core/util/StringArrayUtil.java", "last_update_at": "2020-03-06T08:03:41+00:00", "question_id": "5f190015d0ca9e6efd9166c1747319a5edf26c51", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class StringArrayUtil {\n    public static String[] listToArray(List<String> list) {\n        String[] array = new String[list.size()];\n        return list.toArray(array);\n    }\n    public static String[] listToArrayRemoveDuplicates(List<String> list) {\n        if (list == null) {\n            return new String[0];\n        }\n        LinkedHashSet<String> set = new LinkedHashSet<>(list);\n        return listToArray(new ArrayList<>(set));\n    }\n    public static List<String> arrayToList(String[] array) {\n        return array != null && array.length != 0 ? new ArrayList<>(Arrays.asList(array)) : new ArrayList<>();\n    }\n    public static String joinStringList(List<String> strings, String joinChar, Integer maxLength) {\n        final String str = String.join(joinChar == null ? \", \" : joinChar, strings);\n        return maxLength == null ? str : str.substring(maxLength);\n    }\n    public static boolean isAllEmptyOrNull(List<String> strings) {\n        return strings == null || strings.isEmpty() || strings.stream().allMatch(StringUtils::isEmpty);\n    }\n"]]}
{"hexsha": "6573bb34150d1b5d261b5170dee911b127734cea", "ext": "java", "lang": "Java", "content": "public class CommandQueryEngine implements IQueryEngine {\n\tpublic static final Log LOG = LogFactory.getLog(CommandQueryEngine.class);\n\n\tprivate static final MessageFormat SHELL_COMMAND_FORMAT = new MessageFormat(\n\t\t\t\" sudo -u {0} -i \\\"source /etc/profile; {1} -e {2}\\\" \");\n\tprivate static final MessageFormat HIVE_COMMAND_FORMAT = new MessageFormat(\n\t\t\t\" set hive.cli.print.header=true; use {0}; {1} \");\n\tprivate static final IQueryEngine INSTANCE = new CommandQueryEngine();\n\n\tpublic static IQueryEngine getInstance() {\n\t\treturn INSTANCE;\n\t}\n\n\t@Override\n\tpublic QueryResult postQuery(Query query) {\n\t\tJobContext jobCtx = new JobContext();\n\t\tjobCtx.setId(query.getId());\n\t\tjobCtx.setUsername(query.getUsername());\n\t\tjobCtx.setPasswd(query.getPassword());\n\t\tjobCtx.setStoreResult(query.isStoreResult());\n\t\tjobCtx.setCommands(new String[] {\n\t\t\t\t\"bash\",\n\t\t\t\t\"-c\",\n\t\t\t\tbuildExecCommand(query.getUsername(), query.getMode(),\n\t\t\t\t\t\tquery.getDatabase(), query.getSql()) });\n\t\tjobCtx.setWorkDir(EnvironmentConstants.WORKING_DIRECTORY_ROOT\n\t\t\t\t+ File.separator + query.getId());\n\n\t\tJob job = JobAdapter.createJob(query.getMode(), jobCtx);\n\t\tJobManager.putJob(query.getId(), job, jobCtx);\n\n\t\tQueryResult queryRes = new QueryResult();\n\t\tqueryRes.setId(query.getId());\n\t\ttry {\n\t\t\tint exitCode = job.run();\n\t\t\tLOG.info(\"exitcode:\" + exitCode + \" ,id:\" + jobCtx.getId());\n\t\t\tif (0 == exitCode) {\n\t\t\t\tqueryRes.setSuccess(true);\n\t\t\t\tif (jobCtx.isStoreResult()) {\n\t\t\t\t\tString hdfsDataFileAbsolutePath = EnvironmentConstants.HDFS_DATA_ROOT_PATH\n\t\t\t\t\t\t\t+ File.separator\n\t\t\t\t\t\t\t+ Utilities.getLastPartFileName(jobCtx\n\t\t\t\t\t\t\t\t\t.getLocalDataPath());\n\t\t\t\t\tHDFSManager.putFileToHDFS(jobCtx.getLocalDataPath(),\n\t\t\t\t\t\t\thdfsDataFileAbsolutePath);\n\t\t\t\t\tqueryRes.setResultFilePath(hdfsDataFileAbsolutePath);\n\t\t\t\t}\n\t\t\t\tUtilities.fillInColumnsAndData(jobCtx.getStdout().toString(),\n\t\t\t\t\t\tqueryRes);\n\t\t\t} else {\n\t\t\t\tqueryRes.setErrorMsg(jobCtx.getStderr().toString());\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tLOG.error(e);\n\t\t} finally {\n\t\t\tFileUtils.deleteQuietly(new File(jobCtx.getWorkDir()));\n\t\t\tJobManager.removeJob(query.getId());\n\t\t}\n\t\treturn queryRes;\n\t}\n\n\tprivate String getEngineCommandByMode(String mode) {\n\t\tif (\"hive\".equalsIgnoreCase(mode)) {\n\t\t\treturn \"hive\";\n\t\t} else if (\"shark\".equalsIgnoreCase(mode)) {\n\t\t\treturn \"shark-witherror\";\n\t\t}\n\t\treturn mode;\n\t}\n\n\tprivate String buildExecCommand(String username, String mode,\n\t\t\tString database, String sql) {\n\t\tString hiveCommand = HIVE_COMMAND_FORMAT.format(new String[] {\n\t\t\t\tdatabase, sql });\n\t\tString shellCommand = SHELL_COMMAND_FORMAT.format(new String[] {\n\t\t\t\tusername, getEngineCommandByMode(mode), hiveCommand });\n\t\tif (LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"execute command: \" + shellCommand);\n\t\t}\n\t\treturn shellCommand;\n\t}\n}", "class_id": 0, "repo": "xushaomin/polestar", "file": "src/main/java/com/dianping/polestar/engine/CommandQueryEngine.java", "last_update_at": "2020-05-31T03:25:51+00:00", "question_id": "6573bb34150d1b5d261b5170dee911b127734cea", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CommandQueryEngine implements IQueryEngine {\n\tpublic static final Log LOG = LogFactory.getLog(CommandQueryEngine.class);\n\tprivate static final MessageFormat SHELL_COMMAND_FORMAT = new MessageFormat(\n\t\t\t\" sudo -u {0} -i \\\"source /etc/profile; {1} -e {2}\\\" \");\n\tprivate static final MessageFormat HIVE_COMMAND_FORMAT = new MessageFormat(\n\t\t\t\" set hive.cli.print.header=true; use {0}; {1} \");\n\tprivate static final IQueryEngine INSTANCE = new CommandQueryEngine();\n\tpublic static IQueryEngine getInstance() {\n\t\treturn INSTANCE;\n\t}\n\t@Override\n\tpublic QueryResult postQuery(Query query) {\n\t\tJobContext jobCtx = new JobContext();\n\t\tjobCtx.setId(query.getId());\n\t\tjobCtx.setUsername(query.getUsername());\n\t\tjobCtx.setPasswd(query.getPassword());\n\t\tjobCtx.setStoreResult(query.isStoreResult());\n\t\tjobCtx.setCommands(new String[] {\n\t\t\t\t\"bash\",\n\t\t\t\t\"-c\",\n\t\t\t\tbuildExecCommand(query.getUsername(), query.getMode(),\n\t\t\t\t\t\tquery.getDatabase(), query.getSql()) });\n\t\tjobCtx.setWorkDir(EnvironmentConstants.WORKING_DIRECTORY_ROOT\n\t\t\t\t+ File.separator + query.getId());\n\t\tJob job = JobAdapter.createJob(query.getMode(), jobCtx);\n\t\tJobManager.putJob(query.getId(), job, jobCtx);\n\t\tQueryResult queryRes = new QueryResult();\n\t\tqueryRes.setId(query.getId());\n\t\ttry {\n\t\t\tint exitCode = job.run();\n\t\t\tLOG.info(\"exitcode:\" + exitCode + \" ,id:\" + jobCtx.getId());\n\t\t\tif (0 == exitCode) {\n\t\t\t\tqueryRes.setSuccess(true);\n\t\t\t\tif (jobCtx.isStoreResult()) {\n\t\t\t\t\tString hdfsDataFileAbsolutePath = EnvironmentConstants.HDFS_DATA_ROOT_PATH\n\t\t\t\t\t\t\t+ File.separator\n\t\t\t\t\t\t\t+ Utilities.getLastPartFileName(jobCtx\n\t\t\t\t\t\t\t\t\t.getLocalDataPath());\n\t\t\t\t\tHDFSManager.putFileToHDFS(jobCtx.getLocalDataPath(),\n\t\t\t\t\t\t\thdfsDataFileAbsolutePath);\n\t\t\t\t\tqueryRes.setResultFilePath(hdfsDataFileAbsolutePath);\n\t\t\t\t}\n\t\t\t\tUtilities.fillInColumnsAndData(jobCtx.getStdout().toString(),\n\t\t\t\t\t\tqueryRes);\n\t\t\t} else {\n\t\t\t\tqueryRes.setErrorMsg(jobCtx.getStderr().toString());\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tLOG.error(e);\n\t\t} finally {\n\t\t\tFileUtils.deleteQuietly(new File(jobCtx.getWorkDir()));\n\t\t\tJobManager.removeJob(query.getId());\n\t\t}\n\t\treturn queryRes;\n\t}\n\tprivate String getEngineCommandByMode(String mode) {\n\t\tif (\"hive\".equalsIgnoreCase(mode)) {\n\t\t\treturn \"hive\";\n\t\t} else if (\"shark\".equalsIgnoreCase(mode)) {\n\t\t\treturn \"shark-witherror\";\n\t\t}\n\t\treturn mode;\n\t}\n\tprivate String buildExecCommand(String username, String mode,\n\t\t\tString database, String sql) {\n\t\tString hiveCommand = HIVE_COMMAND_FORMAT.format(new String[] {\n\t\t\t\tdatabase, sql });\n\t\tString shellCommand = SHELL_COMMAND_FORMAT.format(new String[] {\n\t\t\t\tusername, getEngineCommandByMode(mode), hiveCommand });\n\t\tif (LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"execute command: \" + shellCommand);\n\t\t}\n\t\treturn shellCommand;\n\t}\n"]]}
{"hexsha": "300ca4f5b3e497ba4b83e54bdedd85b0958887c4", "ext": "java", "lang": "Java", "content": "public class ShapeFileReader\n        extends RecordReader<ShapeKey, ShpRecord>\n{\n\n    /**\n     * file parser\n     */\n    ShpFileParser parser = null;\n    /**\n     * record id\n     */\n    private ShapeKey recordKey = null;\n    /**\n     * primitive bytes value\n     */\n    private ShpRecord recordContent = null;\n    /**\n     * inputstream for .shp file\n     */\n    private FSDataInputStream shpInputStream = null;\n    /**\n     * Iterator of indexes of records\n     */\n    private int[] indexes;\n\n    /**\n     * whether use index, true when using indexes\n     */\n    private boolean useIndex = false;\n\n    /**\n     * current index id\n     */\n    private int indexId = 0;\n\n    /**\n     * empty constructor\n     */\n    public ShapeFileReader()\n    {\n    }\n\n    /**\n     * constructor with index\n     *\n     * @param indexes\n     */\n    public ShapeFileReader(int[] indexes)\n    {\n        this.indexes = indexes;\n        useIndex = true;\n    }\n\n    public void initialize(InputSplit split, TaskAttemptContext context)\n            throws IOException, InterruptedException\n    {\n        FileSplit fileSplit = (FileSplit) split;\n        Path filePath = fileSplit.getPath();\n        FileSystem fileSys = filePath.getFileSystem(context.getConfiguration());\n        shpInputStream = fileSys.open(filePath);\n        //assign inputstream to parser and parse file header to init;\n        parser = new ShpFileParser(shpInputStream);\n        parser.parseShapeFileHead();\n    }\n\n    public boolean nextKeyValue()\n            throws IOException, InterruptedException\n    {\n        if (useIndex) {\n            /**\n             * with index, iterate until end and extract bytes with information from indexes\n             */\n            if (indexId == indexes.length) { return false; }\n            // check offset, if current offset in inputStream not match with information in shx, move it\n            if (shpInputStream.getPos() < indexes[indexId] * 2) {\n                shpInputStream.skip(indexes[indexId] * 2 - shpInputStream.getPos());\n            }\n            int currentLength = indexes[indexId + 1] * 2 - 4;\n            recordKey = new ShapeKey();\n            recordKey.setIndex(parser.parseRecordHeadID());\n            recordContent = parser.parseRecordPrimitiveContent(currentLength);\n            indexId += 2;\n            return true;\n        }\n        else {\n            if (getProgress() >= 1) { return false; }\n            recordKey = new ShapeKey();\n            recordKey.setIndex(parser.parseRecordHeadID());\n            recordContent = parser.parseRecordPrimitiveContent();\n            return true;\n        }\n    }\n\n    public ShapeKey getCurrentKey()\n            throws IOException, InterruptedException\n    {\n        return recordKey;\n    }\n\n    public ShpRecord getCurrentValue()\n            throws IOException, InterruptedException\n    {\n        return recordContent;\n    }\n\n    public float getProgress()\n            throws IOException, InterruptedException\n    {\n        return parser.getProgress();\n    }\n\n    public void close()\n            throws IOException\n    {\n        shpInputStream.close();\n    }\n}", "class_id": 0, "repo": "andreicovaliov/incubator-sedona", "file": "core/src/main/java/org/apache/sedona/core/formatMapper/shapefileParser/shapes/ShapeFileReader.java", "last_update_at": "2020-09-01T01:45:13+00:00", "question_id": "300ca4f5b3e497ba4b83e54bdedd85b0958887c4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ShapeFileReader\n        extends RecordReader<ShapeKey, ShpRecord>\n{\n    /**\n     * file parser\n     */\n    ShpFileParser parser = null;\n    /**\n     * record id\n     */\n    private ShapeKey recordKey = null;\n    /**\n     * primitive bytes value\n     */\n    private ShpRecord recordContent = null;\n    /**\n     * inputstream for .shp file\n     */\n    private FSDataInputStream shpInputStream = null;\n    /**\n     * Iterator of indexes of records\n     */\n    private int[] indexes;\n    /**\n     * whether use index, true when using indexes\n     */\n    private boolean useIndex = false;\n    /**\n     * current index id\n     */\n    private int indexId = 0;\n    /**\n     * empty constructor\n     */\n    public ShapeFileReader()\n    {\n    }\n    /**\n     * constructor with index\n     *\n     * @param indexes\n     */\n    public ShapeFileReader(int[] indexes)\n    {\n        this.indexes = indexes;\n        useIndex = true;\n    }\n    public void initialize(InputSplit split, TaskAttemptContext context)\n            throws IOException, InterruptedException\n    {\n        FileSplit fileSplit = (FileSplit) split;\n        Path filePath = fileSplit.getPath();\n        FileSystem fileSys = filePath.getFileSystem(context.getConfiguration());\n        shpInputStream = fileSys.open(filePath);\n        //assign inputstream to parser and parse file header to init;\n        parser = new ShpFileParser(shpInputStream);\n        parser.parseShapeFileHead();\n    }\n    public boolean nextKeyValue()\n            throws IOException, InterruptedException\n    {\n        if (useIndex) {\n            /**\n             * with index, iterate until end and extract bytes with information from indexes\n             */\n            if (indexId == indexes.length) { return false; }\n            // check offset, if current offset in inputStream not match with information in shx, move it\n            if (shpInputStream.getPos() < indexes[indexId] * 2) {\n                shpInputStream.skip(indexes[indexId] * 2 - shpInputStream.getPos());\n            }\n            int currentLength = indexes[indexId + 1] * 2 - 4;\n            recordKey = new ShapeKey();\n            recordKey.setIndex(parser.parseRecordHeadID());\n            recordContent = parser.parseRecordPrimitiveContent(currentLength);\n            indexId += 2;\n            return true;\n        }\n        else {\n            if (getProgress() >= 1) { return false; }\n            recordKey = new ShapeKey();\n            recordKey.setIndex(parser.parseRecordHeadID());\n            recordContent = parser.parseRecordPrimitiveContent();\n            return true;\n        }\n    }\n    public ShapeKey getCurrentKey()\n            throws IOException, InterruptedException\n    {\n        return recordKey;\n    }\n    public ShpRecord getCurrentValue()\n            throws IOException, InterruptedException\n    {\n        return recordContent;\n    }\n    public float getProgress()\n            throws IOException, InterruptedException\n    {\n        return parser.getProgress();\n    }\n    public void close()\n            throws IOException\n    {\n        shpInputStream.close();\n    }\n"]]}
{"hexsha": "7b7554c7f535b0338dfca8b7708befcc36ca7d1c", "ext": "java", "lang": "Java", "content": "@RunWith(RoboRunner.class)\npublic class UriUtilsLocalTest extends TestCase {\n\n    @Test\n    public void testGenericItemWithinCollectionQuery() {\n        final Uri uri = Uri.parse(\"content://test.com/item/1\");\n        assertTrue(UriUtils.isNumberedEntryWithinCollection(uri));\n        assertEquals(\"item\", UriUtils.getItemDirID(uri));\n    }\n\n    @Test\n    public void testChangingRootOfQuery() {\n        Uri uri = Uri.parse(\"content://test.com/root/item/1\");\n        assertTrue(UriUtils.isItem(\"root\", uri));\n        assertEquals(\"item\", UriUtils.getItemDirID(\"root\", uri));\n        uri = Uri.parse(\"content://test.com/root/root2/item/1\");\n        assertTrue(UriUtils.isItem(\"root/root2\", uri));\n        assertEquals(\"item\", UriUtils.getItemDirID(\"root/root2\", uri));\n    }\n\n    @Test\n    public void testGettingRowIds() {\n        Uri uri = Uri.parse(\"content://test.com\");\n        Map<String, String> result = UriUtils.from(uri).getMappedIds();\n        assertTrue(result.size() == 0);\n\n        uri = Uri.parse(\"content://test.com/parent\");\n        result = UriUtils.from(uri).getMappedIds();\n        assertTrue(result.size() == 0);\n\n        uri = Uri.parse(\"content://test.com/parent/1\");\n        result = UriUtils.from(uri).getMappedIds();\n        assertEquals(result.size(),1);\n        assertTrue(result.containsKey(\"parent\"));\n        assertEquals(\"1\", result.get(\"parent\"));\n\n        uri = Uri.parse(\"content://test.com/parent/1/child\");\n        result = UriUtils.from(uri).getMappedIds();\n        assertTrue(result.size() == 1);\n        assertTrue(result.containsKey(\"parent\"));\n        assertEquals(\"1\", result.get(\"parent\"));\n\n        uri = Uri.parse(\"content://test.com/parent/1/child/6\");\n        result = UriUtils.from(uri).getMappedIds();\n        assertTrue(result.size() == 2);\n        assertTrue(result.containsKey(\"parent\") && result.containsKey(\"child\"));\n        assertEquals(\"1\", result.get(\"parent\"));\n        assertEquals(\"6\", result.get(\"child\"));\n    }\n\n    @Test\n    public void testGettingParentDetails(){\n        Uri uri = Uri.parse(\"content://test.com\");\n        assertEquals(\"\",UriUtils.getParentColumnName(uri));\n        assertEquals(\"\",UriUtils.getParentId(uri));\n        assertEquals(false,UriUtils.hasParent(uri));\n        uri = Uri.parse(\"content://test.com/parent/1/child\");\n        assertEquals(\"parent\",UriUtils.getParentColumnName(uri));\n        assertEquals(\"1\",UriUtils.getParentId(uri));\n        assertEquals(true,UriUtils.hasParent(uri));\n        uri = Uri.parse(\"content://test.com/parent/1/child/6\");\n        assertEquals(\"parent\",UriUtils.getParentColumnName(uri));\n        assertEquals(\"1\",UriUtils.getParentId(uri));\n        assertEquals(true,UriUtils.hasParent(uri));\n        uri = Uri.parse(\"content://test.com/parent/1/child/6/subchild\");\n        assertEquals(\"child\",UriUtils.getParentColumnName(uri));\n        assertEquals(\"6\",UriUtils.getParentId(uri));\n        assertEquals(true,UriUtils.hasParent(uri));\n        uri = Uri.parse(\"content://test.com/parent/1/child/6/subchild/3\");\n        assertEquals(\"child\",UriUtils.getParentColumnName(uri));\n        assertEquals(\"6\",UriUtils.getParentId(uri));\n        assertEquals(true,UriUtils.hasParent(uri));\n    }\n}", "class_id": 0, "repo": "patilswapnilv/SQLiteProvider", "file": "core/src/test/java/novoda/lib/sqliteprovider/util/UriUtilsLocalTest.java", "last_update_at": "2020-05-13T13:31:12+00:00", "question_id": "7b7554c7f535b0338dfca8b7708befcc36ca7d1c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(RoboRunner.class)\npublic class UriUtilsLocalTest extends TestCase {\n    @Test\n    public void testGenericItemWithinCollectionQuery() {\n        final Uri uri = Uri.parse(\"content://test.com/item/1\");\n        assertTrue(UriUtils.isNumberedEntryWithinCollection(uri));\n        assertEquals(\"item\", UriUtils.getItemDirID(uri));\n    }\n    @Test\n    public void testChangingRootOfQuery() {\n        Uri uri = Uri.parse(\"content://test.com/root/item/1\");\n        assertTrue(UriUtils.isItem(\"root\", uri));\n        assertEquals(\"item\", UriUtils.getItemDirID(\"root\", uri));\n        uri = Uri.parse(\"content://test.com/root/root2/item/1\");\n        assertTrue(UriUtils.isItem(\"root/root2\", uri));\n        assertEquals(\"item\", UriUtils.getItemDirID(\"root/root2\", uri));\n    }\n    @Test\n    public void testGettingRowIds() {\n        Uri uri = Uri.parse(\"content://test.com\");\n        Map<String, String> result = UriUtils.from(uri).getMappedIds();\n        assertTrue(result.size() == 0);\n        uri = Uri.parse(\"content://test.com/parent\");\n        result = UriUtils.from(uri).getMappedIds();\n        assertTrue(result.size() == 0);\n        uri = Uri.parse(\"content://test.com/parent/1\");\n        result = UriUtils.from(uri).getMappedIds();\n        assertEquals(result.size(),1);\n        assertTrue(result.containsKey(\"parent\"));\n        assertEquals(\"1\", result.get(\"parent\"));\n        uri = Uri.parse(\"content://test.com/parent/1/child\");\n        result = UriUtils.from(uri).getMappedIds();\n        assertTrue(result.size() == 1);\n        assertTrue(result.containsKey(\"parent\"));\n        assertEquals(\"1\", result.get(\"parent\"));\n        uri = Uri.parse(\"content://test.com/parent/1/child/6\");\n        result = UriUtils.from(uri).getMappedIds();\n        assertTrue(result.size() == 2);\n        assertTrue(result.containsKey(\"parent\") && result.containsKey(\"child\"));\n        assertEquals(\"1\", result.get(\"parent\"));\n        assertEquals(\"6\", result.get(\"child\"));\n    }\n    @Test\n    public void testGettingParentDetails(){\n        Uri uri = Uri.parse(\"content://test.com\");\n        assertEquals(\"\",UriUtils.getParentColumnName(uri));\n        assertEquals(\"\",UriUtils.getParentId(uri));\n        assertEquals(false,UriUtils.hasParent(uri));\n        uri = Uri.parse(\"content://test.com/parent/1/child\");\n        assertEquals(\"parent\",UriUtils.getParentColumnName(uri));\n        assertEquals(\"1\",UriUtils.getParentId(uri));\n        assertEquals(true,UriUtils.hasParent(uri));\n        uri = Uri.parse(\"content://test.com/parent/1/child/6\");\n        assertEquals(\"parent\",UriUtils.getParentColumnName(uri));\n        assertEquals(\"1\",UriUtils.getParentId(uri));\n        assertEquals(true,UriUtils.hasParent(uri));\n        uri = Uri.parse(\"content://test.com/parent/1/child/6/subchild\");\n        assertEquals(\"child\",UriUtils.getParentColumnName(uri));\n        assertEquals(\"6\",UriUtils.getParentId(uri));\n        assertEquals(true,UriUtils.hasParent(uri));\n        uri = Uri.parse(\"content://test.com/parent/1/child/6/subchild/3\");\n        assertEquals(\"child\",UriUtils.getParentColumnName(uri));\n        assertEquals(\"6\",UriUtils.getParentId(uri));\n        assertEquals(true,UriUtils.hasParent(uri));\n    }\n"]]}
{"hexsha": "c24a581418b82478480459a9e205cf5ceec35746", "ext": "java", "lang": "Java", "content": "public class ShakeService extends Service {\n\n    private SensorManager mSensorManager;\n    private float mAccel;\n    private float mAccelCurrent;\n    private float mAccelLast;\n    private final SensorEventListener mSensorListener = new SensorEventListener() {\n        @Override\n        public void onSensorChanged(SensorEvent event) {\n\n            float x = event.values[0];\n            float y = event.values[1];\n            float z = event.values[2];\n            mAccelLast = mAccelCurrent;\n            mAccelCurrent = (float) Math.sqrt((double) (x * x + y * y + z * z));\n            float delta = mAccelCurrent - mAccelLast;\n            mAccel = mAccel * 0.9f + delta;\n\n            if (mAccel > 12) {\n                Intent intent = new Intent(getApplicationContext(), FullscreenActivity.class)\n                        .addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP |\n                                Intent.FLAG_ACTIVITY_SINGLE_TOP |\n                                Intent.FLAG_ACTIVITY_NEW_TASK);\n\n                // only if not already started, should test first !\n\n                startActivity(intent);\n            }\n        }\n\n        @Override\n        public void onAccuracyChanged(Sensor sensor, int accuracy) {\n        }\n    };\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n//        return null;\n    }\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        Log.i(\"SensorEventListener#onCreate\", \"bimbim\");\n        mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);\n        Objects.requireNonNull(mSensorManager).registerListener(mSensorListener, mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER),\n                SensorManager.SENSOR_DELAY_NORMAL);\n        mAccel = 10f;\n        mAccelCurrent = SensorManager.GRAVITY_EARTH;\n        mAccelLast = SensorManager.GRAVITY_EARTH;\n\n\n    }\n}", "class_id": 0, "repo": "bacloud14/transparentruler", "file": "app/src/main/java/com/bacloud/opacityontop/ShakeService.java", "last_update_at": "2020-10-04T10:55:50+00:00", "question_id": "c24a581418b82478480459a9e205cf5ceec35746", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ShakeService extends Service {\n    private SensorManager mSensorManager;\n    private float mAccel;\n    private float mAccelCurrent;\n    private float mAccelLast;\n    private final SensorEventListener mSensorListener = new SensorEventListener() {\n        @Override\n        public void onSensorChanged(SensorEvent event) {\n            float x = event.values[0];\n            float y = event.values[1];\n            float z = event.values[2];\n            mAccelLast = mAccelCurrent;\n            mAccelCurrent = (float) Math.sqrt((double) (x * x + y * y + z * z));\n            float delta = mAccelCurrent - mAccelLast;\n            mAccel = mAccel * 0.9f + delta;\n            if (mAccel > 12) {\n                Intent intent = new Intent(getApplicationContext(), FullscreenActivity.class)\n                        .addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP |\n                                Intent.FLAG_ACTIVITY_SINGLE_TOP |\n                                Intent.FLAG_ACTIVITY_NEW_TASK);\n                // only if not already started, should test first !\n                startActivity(intent);\n            }\n        }\n        @Override\n        public void onAccuracyChanged(Sensor sensor, int accuracy) {\n        }\n    };\n    @Override\n    public IBinder onBind(Intent intent) {\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n//        return null;\n    }\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        Log.i(\"SensorEventListener#onCreate\", \"bimbim\");\n        mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);\n        Objects.requireNonNull(mSensorManager).registerListener(mSensorListener, mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER),\n                SensorManager.SENSOR_DELAY_NORMAL);\n        mAccel = 10f;\n        mAccelCurrent = SensorManager.GRAVITY_EARTH;\n        mAccelLast = SensorManager.GRAVITY_EARTH;\n    }\n"]]}
{"hexsha": "fa644c87a465c66b3e0f57c778797ac4e4986d9c", "ext": "java", "lang": "Java", "content": "public class ReflectiveUtilsTests {\n\n\t\n\t/**\n\t * ReflectiveUtils.getXConstant() method test.\n\t */\n\t@Test\n\tpublic void test_getXConstant() {\n\t\tObject obj = ReflectiveUtils.getXConstant(new Byte((byte) 42));\n\t\tassertNotNull(obj);\n\t\tassertTrue(obj instanceof ByteConstant);\n\t\tByteConstant objAsBC = (ByteConstant) obj;\n\t\tassertEquals(42, objAsBC.byteValue());\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getXConstant() method test.\n\t */\n\t@Test\n\tpublic void test_getXConstant1() {\n\t\tObject obj = ReflectiveUtils.getXConstant(new Short((short) 42));\n\t\tassertNotNull(obj);\n\t\tassertTrue(obj instanceof ShortConstant);\n\t\tShortConstant objAsSC = (ShortConstant) obj;\n\t\tassertEquals(42, objAsSC.shortValue());\n\t}\n\t\t\n\t/**\n\t * ReflectiveUtils.getXConstant() method test.\n\t */\n\t@Test\n\tpublic void test_getXConstant3() {\n\t\tObject obj = ReflectiveUtils.getXConstant(new Integer((int) 42));\n\t\tassertNotNull(obj);\n\t\tassertTrue(obj instanceof IntConstant);\n\t\tIntConstant objAsIC = (IntConstant) obj;\n\t\tassertEquals(42, objAsIC.intValue());\n\t}\t\t\n\t\t\n\t/**\n\t * ReflectiveUtils.getXConstant() method test.\n\t */\n\t@Test\n\tpublic void test_getXConstant4() {\n\t\tObject obj = ReflectiveUtils.getXConstant(new Long((long) 42));\n\t\tassertNotNull(obj);\n\t\tassertTrue(obj instanceof LongConstant);\n\t\tLongConstant objAsLC = (LongConstant) obj;\n\t\tassertEquals(42, objAsLC.longValue());\n\t}\t\t\n\t\n\t/**\n\t * ReflectiveUtils.getXConstant() method test.\n\t */\n\t@Test\n\tpublic void test_getXConstant5() {\n\t\tObject obj = ReflectiveUtils.getXConstant(new Float((float) 42.42));\n\t\tassertNotNull(obj);\n\t\tassertTrue(obj instanceof FloatConstant);\n\t\tFloatConstant objAsFC = (FloatConstant) obj;\n\t\tassertEquals(42.42, objAsFC.floatValue(), 0.00002);\n\t}\t\n\t\n\t/**\n\t * ReflectiveUtils.getXConstant() method test.\n\t */\n\t@Test\n\tpublic void test_getXConstant6() {\n\t\tObject obj = ReflectiveUtils.getXConstant(new Double((double) 42.42));\n\t\tassertNotNull(obj);\n\t\tassertTrue(obj instanceof DoubleConstant);\n\t\tDoubleConstant objAsDC = (DoubleConstant) obj;\n\t\tassertEquals(42.42, objAsDC.doubleValue(), 0.00002);\n\t}\t\n\t\n\t/**\n\t * ReflectiveUtils.getXConstant() method test.\n\t */\n\t@Test\n\tpublic void test_getXConstant7() {\n\t\tObject obj = ReflectiveUtils.getXConstant(new Character((char) 'a'));\n\t\tassertNotNull(obj);\n\t\tassertTrue(obj instanceof CharConstant);\n\t\tCharConstant objAsCC = (CharConstant) obj;\n\t\tassertEquals('a', objAsCC.charValue());\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getXConstant() method test.\n\t */\n\t@Test\n\tpublic void test_getXConstant8() {\n\t\tObject obj = ReflectiveUtils.getXConstant(new Boolean((boolean) true));\n\t\tassertNotNull(obj);\n\t\tassertTrue(obj instanceof BooleanConstant);\n\t\tBooleanConstant objAsBC = (BooleanConstant) obj;\n\t\tassertEquals(true, objAsBC.booleanValue());\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getXConstant() method test.\n\t */\n\t@Test\n\tpublic void test_getXConstant9() {\n\t\tObject obj = ReflectiveUtils.getXConstant(new String(\"hello\"));\n\t\tassertNotNull(obj);\n\t\tassertTrue(obj instanceof StringConstant);\n\t\tStringConstant objAsSC = (StringConstant) obj;\n\t\tassertEquals(\"hello\", objAsSC.stringValue());\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getXConstant() method test.\n\t */\n\t@Test\n\tpublic void test_getXConstant10() {\n\t\n\t\t\n\t\tObject obj = ReflectiveUtils.getXConstant(Weather.SUNNY);\n\t\tassertNotNull(obj);\n\t\tassertTrue(obj instanceof EnumConstantSignature);\n\t\t\n\t\tEnumConstantSignature objAsECS = (EnumConstantSignature) obj;\n\t\tassertEquals(\"Lstx/libjava/tests/mocks/Weather;\", new String(objAsECS.getTypeName()));\n\t\tassertEquals(\"SUNNY\", new String(objAsECS.getEnumConstantName()));\n\t\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getXConstant() method test.\n\t */\n\t@Test\n\tpublic void test_getXConstant11() {\n\t\n\t\tObject obj = ReflectiveUtils.getXConstant(SimpleMath.class);\n\t\tassertNotNull(obj);\n\t\tassertTrue(obj instanceof ClassSignature);\n\t\t\n\t\tClassSignature objAsCS = (ClassSignature) obj;\n\t\tassertEquals(\"Lstx/libjava/tests/mocks/SimpleMath;\", new String(objAsCS.getTypeName()));\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"int\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"I\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName1() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"byte\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"B\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName2() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"short\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"S\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName3() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"long\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"J\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName4() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"boolean\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"Z\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName5() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"char\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"C\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName6() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"double\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"D\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName7() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"float\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"F\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName8() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"void\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"V\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName9() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"java.lang.Object\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"Ljava/lang/Object;\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName10() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"stx.libjava.tests.mocks.ArrayValueAnnotation\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"Lstx/libjava/tests/mocks/ArrayValueAnnotation;\", sig);\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName11() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"[I\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"[I\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName12() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"[[Ljava.lang.Object;\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"[[Ljava/lang/Object;\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor(int.class);\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"I\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor1() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor(byte.class);\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"B\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor2() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor(short.class);\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"S\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor3() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor(long.class);\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"J\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor4() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor(boolean.class);\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"Z\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor5() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor(char.class);\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"C\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor6() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor(double.class);\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"D\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor7() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor(float.class);\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"F\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor8() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor(void.class);\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"V\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor9() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor(java.lang.Object.class);\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"Ljava/lang/Object;\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor10() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor(stx.libjava.tests.mocks.ArrayValueAnnotation.class);\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"Lstx/libjava/tests/mocks/ArrayValueAnnotation;\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor11() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor((new int[5]).getClass());\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"[I\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor12() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor((new Object[5]).getClass());\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"[Ljava/lang/Object;\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getNameFromSig() method test.\n\t */\n\t@Test\n\tpublic void test_getNameFromSig() {\n\t\tString sig = ReflectiveUtils.getNameFromSig(\"I\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"int\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getNameFromSig() method test.\n\t */\n\t@Test\n\tpublic void test_getNameFromSig1() {\n\t\tString sig = ReflectiveUtils.getNameFromSig(\"B\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"byte\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getNameFromSig() method test.\n\t */\n\t@Test\n\tpublic void test_getNameFromSig2() {\n\t\tString sig = ReflectiveUtils.getNameFromSig(\"S\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"short\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getNameFromSig() method test.\n\t */\n\t@Test\n\tpublic void test_getNameFromSig3() {\n\t\tString sig = ReflectiveUtils.getNameFromSig(\"J\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"long\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getNameFromSig() method test.\n\t */\n\t@Test\n\tpublic void test_getNameFromSig4() {\n\t\tString sig = ReflectiveUtils.getNameFromSig(\"Z\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"boolean\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getNameFromSig() method test.\n\t */\n\t@Test\n\tpublic void test_getNameFromSig5() {\n\t\tString sig = ReflectiveUtils.getNameFromSig(\"C\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"char\", sig);\t\n\t}\n\t\n\t\n\t/**\n\t * ReflectiveUtils.getNameFromSig() method test.\n\t */\n\t@Test\n\tpublic void test_getNameFromSig6() {\n\t\tString sig = ReflectiveUtils.getNameFromSig(\"D\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"double\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getNameFromSig() method test.\n\t */\n\t@Test\n\tpublic void test_getNameFromSig7() {\n\t\tString sig = ReflectiveUtils.getNameFromSig(\"F\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"float\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getNameFromSig() method test.\n\t */\n\t@Test\n\tpublic void test_getNameFromSig8() {\n\t\tString sig = ReflectiveUtils.getNameFromSig(\"V\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"void\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getNameFromSig() method test.\n\t */\n\t@Test\n\tpublic void test_getNameFromSig9() {\n\t\tString sig = ReflectiveUtils.getNameFromSig(\"Lstx/libjava/tests/mocks/ArrayValueAnnotation;\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"stx.libjava.tests.mocks.ArrayValueAnnotation\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getNameFromSig() method test.\n\t */\n\t@Test\n\tpublic void test_getNameFromSig10() {\n\t\tString sig = ReflectiveUtils.getNameFromSig(\"[Lstx/libjava/tests/mocks/ArrayValueAnnotation;\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"[Lstx.libjava.tests.mocks.ArrayValueAnnotation;\", sig);\t\n\t}\n}", "class_id": 0, "repo": "GunterMueller/ST_STX_Fork", "file": "build/stx/libjava/tools/java/src-tests/stx/libjava/tools/environment/tests/ReflectiveUtilsTests.java", "last_update_at": "2020-01-23T20:46:08+00:00", "question_id": "fa644c87a465c66b3e0f57c778797ac4e4986d9c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ReflectiveUtilsTests {\n\t\n\t/**\n\t * ReflectiveUtils.getXConstant() method test.\n\t */\n\t@Test\n\tpublic void test_getXConstant() {\n\t\tObject obj = ReflectiveUtils.getXConstant(new Byte((byte) 42));\n\t\tassertNotNull(obj);\n\t\tassertTrue(obj instanceof ByteConstant);\n\t\tByteConstant objAsBC = (ByteConstant) obj;\n\t\tassertEquals(42, objAsBC.byteValue());\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getXConstant() method test.\n\t */\n\t@Test\n\tpublic void test_getXConstant1() {\n\t\tObject obj = ReflectiveUtils.getXConstant(new Short((short) 42));\n\t\tassertNotNull(obj);\n\t\tassertTrue(obj instanceof ShortConstant);\n\t\tShortConstant objAsSC = (ShortConstant) obj;\n\t\tassertEquals(42, objAsSC.shortValue());\n\t}\n\t\t\n\t/**\n\t * ReflectiveUtils.getXConstant() method test.\n\t */\n\t@Test\n\tpublic void test_getXConstant3() {\n\t\tObject obj = ReflectiveUtils.getXConstant(new Integer((int) 42));\n\t\tassertNotNull(obj);\n\t\tassertTrue(obj instanceof IntConstant);\n\t\tIntConstant objAsIC = (IntConstant) obj;\n\t\tassertEquals(42, objAsIC.intValue());\n\t}\t\t\n\t\t\n\t/**\n\t * ReflectiveUtils.getXConstant() method test.\n\t */\n\t@Test\n\tpublic void test_getXConstant4() {\n\t\tObject obj = ReflectiveUtils.getXConstant(new Long((long) 42));\n\t\tassertNotNull(obj);\n\t\tassertTrue(obj instanceof LongConstant);\n\t\tLongConstant objAsLC = (LongConstant) obj;\n\t\tassertEquals(42, objAsLC.longValue());\n\t}\t\t\n\t\n\t/**\n\t * ReflectiveUtils.getXConstant() method test.\n\t */\n\t@Test\n\tpublic void test_getXConstant5() {\n\t\tObject obj = ReflectiveUtils.getXConstant(new Float((float) 42.42));\n\t\tassertNotNull(obj);\n\t\tassertTrue(obj instanceof FloatConstant);\n\t\tFloatConstant objAsFC = (FloatConstant) obj;\n\t\tassertEquals(42.42, objAsFC.floatValue(), 0.00002);\n\t}\t\n\t\n\t/**\n\t * ReflectiveUtils.getXConstant() method test.\n\t */\n\t@Test\n\tpublic void test_getXConstant6() {\n\t\tObject obj = ReflectiveUtils.getXConstant(new Double((double) 42.42));\n\t\tassertNotNull(obj);\n\t\tassertTrue(obj instanceof DoubleConstant);\n\t\tDoubleConstant objAsDC = (DoubleConstant) obj;\n\t\tassertEquals(42.42, objAsDC.doubleValue(), 0.00002);\n\t}\t\n\t\n\t/**\n\t * ReflectiveUtils.getXConstant() method test.\n\t */\n\t@Test\n\tpublic void test_getXConstant7() {\n\t\tObject obj = ReflectiveUtils.getXConstant(new Character((char) 'a'));\n\t\tassertNotNull(obj);\n\t\tassertTrue(obj instanceof CharConstant);\n\t\tCharConstant objAsCC = (CharConstant) obj;\n\t\tassertEquals('a', objAsCC.charValue());\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getXConstant() method test.\n\t */\n\t@Test\n\tpublic void test_getXConstant8() {\n\t\tObject obj = ReflectiveUtils.getXConstant(new Boolean((boolean) true));\n\t\tassertNotNull(obj);\n\t\tassertTrue(obj instanceof BooleanConstant);\n\t\tBooleanConstant objAsBC = (BooleanConstant) obj;\n\t\tassertEquals(true, objAsBC.booleanValue());\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getXConstant() method test.\n\t */\n\t@Test\n\tpublic void test_getXConstant9() {\n\t\tObject obj = ReflectiveUtils.getXConstant(new String(\"hello\"));\n\t\tassertNotNull(obj);\n\t\tassertTrue(obj instanceof StringConstant);\n\t\tStringConstant objAsSC = (StringConstant) obj;\n\t\tassertEquals(\"hello\", objAsSC.stringValue());\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getXConstant() method test.\n\t */\n\t@Test\n\tpublic void test_getXConstant10() {\n\t\n\t\t\n\t\tObject obj = ReflectiveUtils.getXConstant(Weather.SUNNY);\n\t\tassertNotNull(obj);\n\t\tassertTrue(obj instanceof EnumConstantSignature);\n\t\t\n\t\tEnumConstantSignature objAsECS = (EnumConstantSignature) obj;\n\t\tassertEquals(\"Lstx/libjava/tests/mocks/Weather;\", new String(objAsECS.getTypeName()));\n\t\tassertEquals(\"SUNNY\", new String(objAsECS.getEnumConstantName()));\n\t\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getXConstant() method test.\n\t */\n\t@Test\n\tpublic void test_getXConstant11() {\n\t\n\t\tObject obj = ReflectiveUtils.getXConstant(SimpleMath.class);\n\t\tassertNotNull(obj);\n\t\tassertTrue(obj instanceof ClassSignature);\n\t\t\n\t\tClassSignature objAsCS = (ClassSignature) obj;\n\t\tassertEquals(\"Lstx/libjava/tests/mocks/SimpleMath;\", new String(objAsCS.getTypeName()));\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"int\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"I\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName1() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"byte\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"B\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName2() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"short\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"S\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName3() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"long\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"J\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName4() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"boolean\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"Z\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName5() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"char\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"C\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName6() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"double\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"D\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName7() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"float\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"F\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName8() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"void\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"V\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName9() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"java.lang.Object\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"Ljava/lang/Object;\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName10() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"stx.libjava.tests.mocks.ArrayValueAnnotation\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"Lstx/libjava/tests/mocks/ArrayValueAnnotation;\", sig);\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName11() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"[I\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"[I\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getSigFromName() method test.\n\t */\n\t@Test\n\tpublic void test_getSigFromName12() {\n\t\tString sig = ReflectiveUtils.getSigFromName(\"[[Ljava.lang.Object;\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"[[Ljava/lang/Object;\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor(int.class);\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"I\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor1() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor(byte.class);\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"B\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor2() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor(short.class);\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"S\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor3() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor(long.class);\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"J\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor4() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor(boolean.class);\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"Z\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor5() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor(char.class);\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"C\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor6() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor(double.class);\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"D\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor7() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor(float.class);\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"F\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor8() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor(void.class);\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"V\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor9() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor(java.lang.Object.class);\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"Ljava/lang/Object;\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor10() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor(stx.libjava.tests.mocks.ArrayValueAnnotation.class);\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"Lstx/libjava/tests/mocks/ArrayValueAnnotation;\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor11() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor((new int[5]).getClass());\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"[I\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getFieldDescriptor() method test.\n\t */\n\t@Test\n\tpublic void test_getFieldDescriptor12() {\n\t\tString sig = ReflectiveUtils.getFieldDescriptor((new Object[5]).getClass());\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"[Ljava/lang/Object;\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getNameFromSig() method test.\n\t */\n\t@Test\n\tpublic void test_getNameFromSig() {\n\t\tString sig = ReflectiveUtils.getNameFromSig(\"I\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"int\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getNameFromSig() method test.\n\t */\n\t@Test\n\tpublic void test_getNameFromSig1() {\n\t\tString sig = ReflectiveUtils.getNameFromSig(\"B\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"byte\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getNameFromSig() method test.\n\t */\n\t@Test\n\tpublic void test_getNameFromSig2() {\n\t\tString sig = ReflectiveUtils.getNameFromSig(\"S\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"short\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getNameFromSig() method test.\n\t */\n\t@Test\n\tpublic void test_getNameFromSig3() {\n\t\tString sig = ReflectiveUtils.getNameFromSig(\"J\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"long\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getNameFromSig() method test.\n\t */\n\t@Test\n\tpublic void test_getNameFromSig4() {\n\t\tString sig = ReflectiveUtils.getNameFromSig(\"Z\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"boolean\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getNameFromSig() method test.\n\t */\n\t@Test\n\tpublic void test_getNameFromSig5() {\n\t\tString sig = ReflectiveUtils.getNameFromSig(\"C\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"char\", sig);\t\n\t}\n\t\n\t\n\t/**\n\t * ReflectiveUtils.getNameFromSig() method test.\n\t */\n\t@Test\n\tpublic void test_getNameFromSig6() {\n\t\tString sig = ReflectiveUtils.getNameFromSig(\"D\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"double\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getNameFromSig() method test.\n\t */\n\t@Test\n\tpublic void test_getNameFromSig7() {\n\t\tString sig = ReflectiveUtils.getNameFromSig(\"F\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"float\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getNameFromSig() method test.\n\t */\n\t@Test\n\tpublic void test_getNameFromSig8() {\n\t\tString sig = ReflectiveUtils.getNameFromSig(\"V\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"void\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getNameFromSig() method test.\n\t */\n\t@Test\n\tpublic void test_getNameFromSig9() {\n\t\tString sig = ReflectiveUtils.getNameFromSig(\"Lstx/libjava/tests/mocks/ArrayValueAnnotation;\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"stx.libjava.tests.mocks.ArrayValueAnnotation\", sig);\t\n\t}\n\t\n\t/**\n\t * ReflectiveUtils.getNameFromSig() method test.\n\t */\n\t@Test\n\tpublic void test_getNameFromSig10() {\n\t\tString sig = ReflectiveUtils.getNameFromSig(\"[Lstx/libjava/tests/mocks/ArrayValueAnnotation;\");\n\t\tassertNotNull(sig);\n\t\tassertEquals(\"[Lstx.libjava.tests.mocks.ArrayValueAnnotation;\", sig);\t\n\t}\n"]]}
{"hexsha": "0914d1b4442209c610e77c3ba4620a79d6e1a5dd", "ext": "java", "lang": "Java", "content": "public class FileLeafTest {\r\n\r\n\tprivate static Path basePath;\r\n\tprivate FileLeaf leaf;\r\n\tprivate Path file;\r\n\tprivate String fileName;\r\n\tprivate String content;\r\n\r\n\t// structure: rootBase -> parentA -> file\r\n\tprivate FolderComposite rootBase;\r\n\tprivate FolderComposite parentA;\r\n\tprivate FolderComposite parentB;\r\n\r\n\tprivate static Path folderA;\r\n\tprivate static Path folderB;\r\n\r\n\r\n\tprivate static final boolean cleanupFolder = true;\r\n\r\n\t@BeforeClass\r\n\tpublic static void setUpBeforeClass() throws Exception {\r\n\t\tbasePath = Paths.get(FileUtils.getTempDirectoryPath(), \"PeerWasp_Test_Tree\");\r\n\t\tif(!Files.exists(basePath)) {\r\n\t\t\tFiles.createDirectory(basePath);\r\n\t\t}\r\n\r\n\t\tfolderA = basePath.resolve(\"folderA\");\r\n\t\tif(!Files.exists(folderA)) {\r\n\t\t\tFiles.createDirectory(folderA);\r\n\t\t}\r\n\r\n\t\tfolderB = basePath.resolve(\"folderB\");\r\n\t\tif(!Files.exists(folderB)) {\r\n\t\t\tFiles.createDirectory(folderB);\r\n\t\t}\r\n\t}\r\n\r\n\t@AfterClass\r\n\tpublic static void tearDownAfterClass() throws Exception {\r\n\t\tif(cleanupFolder) {\r\n\t\t\tFileUtils.deleteDirectory(basePath.toFile());\r\n\t\t}\r\n\t}\r\n\r\n\t@Before\r\n\tpublic void setUp() throws Exception {\r\n\r\n\t\t// create file with content in folderA\r\n\t\tfileName = \"file1.txt\";\r\n\t\tfile = folderA.resolve(fileName);\r\n\t\tcontent = RandomStringUtils.randomAlphanumeric(1000);\r\n\t\tFiles.write(file, content.getBytes());\r\n\t\tleaf = new TestFileLeaf(file, true);\r\n\t\tleaf.updateContentHash();\r\n\r\n\r\n\t\trootBase = new TestFolderComposite(basePath, true, true); // root\r\n\t\tparentA = new TestFolderComposite(folderA, true, false); // not root\r\n\t\tparentB = new TestFolderComposite(folderB, true, false); // not root\r\n\r\n\t\trootBase.putComponent(parentA.getPath(), parentA);\r\n\t\trootBase.putComponent(parentB.getPath(), parentB);\r\n\t\trootBase.putComponent(leaf.getPath(), leaf);\r\n\r\n\t\tassertNull(rootBase.getParent());\r\n\t\tassertEquals(parentA.getParent(), rootBase);\r\n\t\tassertEquals(parentB.getParent(), rootBase);\r\n\t\tassertEquals(leaf.getParent(), parentA);\r\n\t\tassertNotEquals(leaf.getParent(), parentB);\r\n\t}\r\n\r\n\t@After\r\n\tpublic void tearDown() throws Exception {\r\n\t\tleaf = null;\r\n\t\tcontent = null;\r\n\t\tfile = null;\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testFileLeafCtr() throws IOException {\r\n\t\tString hash = PathUtils.computeFileContentHash(file);\r\n\t\tassertNotNull(hash);\r\n\t\tassertFalse(hash.isEmpty());\r\n\r\n\t\tFileLeaf leafA = new FileLeaf(file, true);\r\n\t\tleafA.updateContentHash();\r\n\t\tassertEquals(hash, leafA.getContentHash());\r\n\r\n\t\tFileLeaf leafB = new FileLeaf(file, false);\r\n\t\tassertEquals(\"\", leafB.getContentHash());\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testIsFile() {\r\n\t\tassertTrue(leaf.isFile());\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testIsFolder() {\r\n\t\tassertFalse(leaf.isFolder());\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testGetAndSetPath() {\r\n\t\tassertNotNull(leaf.getPath());\r\n\t\tassertEquals(file, leaf.getPath());\r\n\r\n\t\t// \"move\" file to folderB by setting the path\r\n\t\tPath fileB = folderB.resolve(file.getFileName());\r\n\t\tleaf.setPath(fileB);\r\n\t\tassertEquals(fileB, leaf.getPath());\r\n\r\n\t\t// \"rename\" file\r\n\t\tPath newName = fileB.resolveSibling(\"newFileName.txt\");\r\n\t\tleaf.setPath(newName);\r\n\t\tassertEquals(newName, leaf.getPath());\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testGetAction() {\r\n\t\tassertNotNull(leaf.getAction());\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testGetAndsetIsActionUploaded() {\r\n\t\tboolean isUploaded = leaf.isUploaded(); // initial expetced false\r\n\t\tassertFalse(leaf.isUploaded());\r\n\r\n\t\tisUploaded = !isUploaded; // toggle and test\r\n\t\tleaf.setIsUploaded(isUploaded);\r\n\t\tassertTrue(leaf.isUploaded());\r\n\r\n\t\tisUploaded = !isUploaded; // toggle and test\r\n\t\tleaf.setIsUploaded(isUploaded);\r\n\t\tassertFalse(leaf.isUploaded());\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testGetAndUpdateContentHash() throws IOException {\r\n\t\tString hash = PathUtils.computeFileContentHash(file);\r\n\t\tassertEquals(hash, leaf.getContentHash());\r\n\r\n\t\tfor(int i = 0; i < 10; ++i) {\r\n\t\t\t// update file and test\r\n\t\t\tString s = RandomStringUtils.randomAlphanumeric(1000);\r\n\t\t\tFiles.write(file, s.getBytes());\r\n\t\t\thash = PathUtils.computeFileContentHash(file);\r\n\t\t\tboolean changed = leaf.updateContentHash();\r\n\t\t\tassertTrue(changed);\r\n\t\t\tassertEquals(hash, leaf.getContentHash());\r\n\t\t}\r\n\r\n\t\t// always same content and test\r\n\t\tString s = RandomStringUtils.randomAlphanumeric(1000);\r\n\t\tFiles.write(file, s.getBytes());\r\n\t\thash = PathUtils.computeFileContentHash(file);\r\n\t\tassertTrue(leaf.updateContentHash());\r\n\t\tfor(int i = 0; i < 10; ++i) {\r\n\t\t\tFiles.write(file, s.getBytes());\r\n\t\t\tboolean changed = leaf.updateContentHash();\r\n\t\t\tassertFalse(changed);\r\n\t\t\tassertEquals(hash, leaf.getContentHash());\r\n\t\t}\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testBubbleContentHashUpdate() throws IOException {\r\n\t\tString rootHash = rootBase.getContentHash();\r\n\t\tassertNotNull(rootHash);\r\n\t\tassertFalse(rootHash.isEmpty());\r\n\r\n\t\tString parentHash = parentA.getContentHash();\r\n\t\tassertNotNull(parentHash);\r\n\t\tassertFalse(parentHash.isEmpty());\r\n\r\n\t\tString s = RandomStringUtils.randomAlphanumeric(1000);\r\n\t\tFiles.write(file, s.getBytes());\r\n\t\tleaf.updateContentHash();\r\n\r\n\t\tassertNotEquals(rootHash, rootBase.getContentHash());\r\n\t\tassertNotEquals(parentHash, parentA.getContentHash());\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testGetAndSetParent() {\r\n\t\tassertEquals(leaf.getParent(), parentA);\r\n\r\n\t\tleaf.setParent(parentB);\r\n\r\n\t\tassertEquals(leaf.getParent(), parentB);\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testIsReady() {\r\n\t\t// root is always \"ready\"\r\n\t\tassertTrue(rootBase.isReady());\r\n\t\t// because root is ready, parent should also be ready\r\n\t\tassertTrue(parentA.isReady());\r\n\t\t// parent is not yet uploaded -> file should not be ready\r\n\t\tassertFalse(leaf.isReady());\r\n\r\n\t\t// parent uploaded -> leaf is ready now\r\n\t\tparentA.setIsUploaded(true);\r\n\t\tassertTrue(leaf.isReady());\r\n\r\n\t\t// parent uploaded -> leaf is ready now\r\n\t\tparentA.setIsUploaded(false);\r\n\t\tassertFalse(leaf.isReady());\r\n\t}\r\n\r\n//\t@Test(expected=NotImplementedException.class)\r\n//\tpublic void testGetAndSetStructureHash() {\r\n//\t\tassertNotNull(leaf.getStructureHash());\r\n//\t\tassertTrue(leaf.getStructureHash().isEmpty());\r\n//\r\n//\t\tleaf.setStructureHash(\"abc\");\r\n//\t\tassertNotNull(leaf.getStructureHash());\r\n//\t\tassertEquals(\"abc\", leaf.getStructureHash());\r\n//\t}\r\n\r\n//\t@Test(expected=NotImplementedException.class)\r\n//\tpublic void testGetComponent() {\r\n//\t\tassertNull(leaf.getComponent(Paths.get(\"aComponent\")));\r\n//\t}\r\n\r\n//\t@Test(expected=NotImplementedException.class)\r\n//\tpublic void testPutComponent() {\r\n//\t\tleaf.putComponent(null, null);\r\n//\t}\r\n//\r\n//\t@Test(expected=NotImplementedException.class)\r\n//\tpublic void testDeleteComponent() {\r\n//\t\tassertNull(leaf.deleteComponent(Paths.get(\"aComponent\")));\r\n//\t}\r\n\r\n}", "class_id": 0, "repo": "PeerWasp/PeerWasp", "file": "peerbox/src/test/java/org/peerbox/watchservice/filetree/FileLeafTest.java", "last_update_at": "2020-05-25T10:50:50+00:00", "question_id": "0914d1b4442209c610e77c3ba4620a79d6e1a5dd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FileLeafTest {\r\n\r\n\tprivate static Path basePath;\r\n\tprivate FileLeaf leaf;\r\n\tprivate Path file;\r\n\tprivate String fileName;\r\n\tprivate String content;\r\n\r\n\t// structure: rootBase -> parentA -> file\r\n\tprivate FolderComposite rootBase;\r\n\tprivate FolderComposite parentA;\r\n\tprivate FolderComposite parentB;\r\n\r\n\tprivate static Path folderA;\r\n\tprivate static Path folderB;\r\n\r\n\r\n\tprivate static final boolean cleanupFolder = true;\r\n\r\n\t@BeforeClass\r\n\tpublic static void setUpBeforeClass() throws Exception {\r\n\t\tbasePath = Paths.get(FileUtils.getTempDirectoryPath(), \"PeerWasp_Test_Tree\");\r\n\t\tif(!Files.exists(basePath)) {\r\n\t\t\tFiles.createDirectory(basePath);\r\n\t\t}\r\n\r\n\t\tfolderA = basePath.resolve(\"folderA\");\r\n\t\tif(!Files.exists(folderA)) {\r\n\t\t\tFiles.createDirectory(folderA);\r\n\t\t}\r\n\r\n\t\tfolderB = basePath.resolve(\"folderB\");\r\n\t\tif(!Files.exists(folderB)) {\r\n\t\t\tFiles.createDirectory(folderB);\r\n\t\t}\r\n\t}\r\n\r\n\t@AfterClass\r\n\tpublic static void tearDownAfterClass() throws Exception {\r\n\t\tif(cleanupFolder) {\r\n\t\t\tFileUtils.deleteDirectory(basePath.toFile());\r\n\t\t}\r\n\t}\r\n\r\n\t@Before\r\n\tpublic void setUp() throws Exception {\r\n\r\n\t\t// create file with content in folderA\r\n\t\tfileName = \"file1.txt\";\r\n\t\tfile = folderA.resolve(fileName);\r\n\t\tcontent = RandomStringUtils.randomAlphanumeric(1000);\r\n\t\tFiles.write(file, content.getBytes());\r\n\t\tleaf = new TestFileLeaf(file, true);\r\n\t\tleaf.updateContentHash();\r\n\r\n\r\n\t\trootBase = new TestFolderComposite(basePath, true, true); // root\r\n\t\tparentA = new TestFolderComposite(folderA, true, false); // not root\r\n\t\tparentB = new TestFolderComposite(folderB, true, false); // not root\r\n\r\n\t\trootBase.putComponent(parentA.getPath(), parentA);\r\n\t\trootBase.putComponent(parentB.getPath(), parentB);\r\n\t\trootBase.putComponent(leaf.getPath(), leaf);\r\n\r\n\t\tassertNull(rootBase.getParent());\r\n\t\tassertEquals(parentA.getParent(), rootBase);\r\n\t\tassertEquals(parentB.getParent(), rootBase);\r\n\t\tassertEquals(leaf.getParent(), parentA);\r\n\t\tassertNotEquals(leaf.getParent(), parentB);\r\n\t}\r\n\r\n\t@After\r\n\tpublic void tearDown() throws Exception {\r\n\t\tleaf = null;\r\n\t\tcontent = null;\r\n\t\tfile = null;\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testFileLeafCtr() throws IOException {\r\n\t\tString hash = PathUtils.computeFileContentHash(file);\r\n\t\tassertNotNull(hash);\r\n\t\tassertFalse(hash.isEmpty());\r\n\r\n\t\tFileLeaf leafA = new FileLeaf(file, true);\r\n\t\tleafA.updateContentHash();\r\n\t\tassertEquals(hash, leafA.getContentHash());\r\n\r\n\t\tFileLeaf leafB = new FileLeaf(file, false);\r\n\t\tassertEquals(\"\", leafB.getContentHash());\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testIsFile() {\r\n\t\tassertTrue(leaf.isFile());\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testIsFolder() {\r\n\t\tassertFalse(leaf.isFolder());\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testGetAndSetPath() {\r\n\t\tassertNotNull(leaf.getPath());\r\n\t\tassertEquals(file, leaf.getPath());\r\n\r\n\t\t// \"move\" file to folderB by setting the path\r\n\t\tPath fileB = folderB.resolve(file.getFileName());\r\n\t\tleaf.setPath(fileB);\r\n\t\tassertEquals(fileB, leaf.getPath());\r\n\r\n\t\t// \"rename\" file\r\n\t\tPath newName = fileB.resolveSibling(\"newFileName.txt\");\r\n\t\tleaf.setPath(newName);\r\n\t\tassertEquals(newName, leaf.getPath());\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testGetAction() {\r\n\t\tassertNotNull(leaf.getAction());\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testGetAndsetIsActionUploaded() {\r\n\t\tboolean isUploaded = leaf.isUploaded(); // initial expetced false\r\n\t\tassertFalse(leaf.isUploaded());\r\n\r\n\t\tisUploaded = !isUploaded; // toggle and test\r\n\t\tleaf.setIsUploaded(isUploaded);\r\n\t\tassertTrue(leaf.isUploaded());\r\n\r\n\t\tisUploaded = !isUploaded; // toggle and test\r\n\t\tleaf.setIsUploaded(isUploaded);\r\n\t\tassertFalse(leaf.isUploaded());\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testGetAndUpdateContentHash() throws IOException {\r\n\t\tString hash = PathUtils.computeFileContentHash(file);\r\n\t\tassertEquals(hash, leaf.getContentHash());\r\n\r\n\t\tfor(int i = 0; i < 10; ++i) {\r\n\t\t\t// update file and test\r\n\t\t\tString s = RandomStringUtils.randomAlphanumeric(1000);\r\n\t\t\tFiles.write(file, s.getBytes());\r\n\t\t\thash = PathUtils.computeFileContentHash(file);\r\n\t\t\tboolean changed = leaf.updateContentHash();\r\n\t\t\tassertTrue(changed);\r\n\t\t\tassertEquals(hash, leaf.getContentHash());\r\n\t\t}\r\n\r\n\t\t// always same content and test\r\n\t\tString s = RandomStringUtils.randomAlphanumeric(1000);\r\n\t\tFiles.write(file, s.getBytes());\r\n\t\thash = PathUtils.computeFileContentHash(file);\r\n\t\tassertTrue(leaf.updateContentHash());\r\n\t\tfor(int i = 0; i < 10; ++i) {\r\n\t\t\tFiles.write(file, s.getBytes());\r\n\t\t\tboolean changed = leaf.updateContentHash();\r\n\t\t\tassertFalse(changed);\r\n\t\t\tassertEquals(hash, leaf.getContentHash());\r\n\t\t}\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testBubbleContentHashUpdate() throws IOException {\r\n\t\tString rootHash = rootBase.getContentHash();\r\n\t\tassertNotNull(rootHash);\r\n\t\tassertFalse(rootHash.isEmpty());\r\n\r\n\t\tString parentHash = parentA.getContentHash();\r\n\t\tassertNotNull(parentHash);\r\n\t\tassertFalse(parentHash.isEmpty());\r\n\r\n\t\tString s = RandomStringUtils.randomAlphanumeric(1000);\r\n\t\tFiles.write(file, s.getBytes());\r\n\t\tleaf.updateContentHash();\r\n\r\n\t\tassertNotEquals(rootHash, rootBase.getContentHash());\r\n\t\tassertNotEquals(parentHash, parentA.getContentHash());\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testGetAndSetParent() {\r\n\t\tassertEquals(leaf.getParent(), parentA);\r\n\r\n\t\tleaf.setParent(parentB);\r\n\r\n\t\tassertEquals(leaf.getParent(), parentB);\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testIsReady() {\r\n\t\t// root is always \"ready\"\r\n\t\tassertTrue(rootBase.isReady());\r\n\t\t// because root is ready, parent should also be ready\r\n\t\tassertTrue(parentA.isReady());\r\n\t\t// parent is not yet uploaded -> file should not be ready\r\n\t\tassertFalse(leaf.isReady());\r\n\r\n\t\t// parent uploaded -> leaf is ready now\r\n\t\tparentA.setIsUploaded(true);\r\n\t\tassertTrue(leaf.isReady());\r\n\r\n\t\t// parent uploaded -> leaf is ready now\r\n\t\tparentA.setIsUploaded(false);\r\n\t\tassertFalse(leaf.isReady());\r\n\t}\r\n\r\n//\t@Test(expected=NotImplementedException.class)\r\n//\tpublic void testGetAndSetStructureHash() {\r\n//\t\tassertNotNull(leaf.getStructureHash());\r\n//\t\tassertTrue(leaf.getStructureHash().isEmpty());\r\n//\r\n//\t\tleaf.setStructureHash(\"abc\");\r\n//\t\tassertNotNull(leaf.getStructureHash());\r\n//\t\tassertEquals(\"abc\", leaf.getStructureHash());\r\n//\t}\r\n\r\n//\t@Test(expected=NotImplementedException.class)\r\n//\tpublic void testGetComponent() {\r\n//\t\tassertNull(leaf.getComponent(Paths.get(\"aComponent\")));\r\n//\t}\r\n\r\n//\t@Test(expected=NotImplementedException.class)\r\n//\tpublic void testPutComponent() {\r\n//\t\tleaf.putComponent(null, null);\r\n//\t}\r\n//\r\n//\t@Test(expected=NotImplementedException.class)\r\n//\tpublic void testDeleteComponent() {\r\n//\t\tassertNull(leaf.deleteComponent(Paths.get(\"aComponent\")));\r\n//\t}\r\n\r\n"]]}
{"hexsha": "6d9d9dd13b76e576fbb2c42bdbb8a9bf2eb6cff8", "ext": "java", "lang": "Java", "content": "public class SmsReceiver extends BroadcastReceiver {\n\t\n\n\tpublic static final String SMS_EXTRA_NAME = \"pdus\";\n\tprivate CallbackContext callback_receive;\n\tprivate boolean isReceiving = true;\n\t\n\t// This broadcast boolean is used to continue or not the message broadcast\n\t// to the other BroadcastReceivers waiting for an incoming SMS (like the native SMS app)\n\tprivate boolean broadcast = false;\n\t\n\t@Override\n\tpublic void onReceive(Context ctx, Intent intent) {\n\t\t\n\t\t// Get the SMS map from Intent\n\t    Bundle extras = intent.getExtras();\n\t    if (extras != null)\n\t    {\n\t\t   // Get received SMS Array\n\t\t\tObject[] smsExtra = (Object[]) extras.get(SMS_EXTRA_NAME);\n\n\t\t\tfor (int i=0; i < smsExtra.length; i++)\n\t\t\t{\n\t\t\t\tSmsMessage sms = SmsMessage.createFromPdu((byte[]) smsExtra[i]);\n\t\t\t\tif(this.isReceiving && this.callback_receive != null) {\n                    String formattedMsg = sms.getOriginatingAddress() + \">\" + sms.getMessageBody();\n\t\t        \tPluginResult result = new PluginResult(PluginResult.Status.OK, formattedMsg);\n\t\t           \tresult.setKeepCallback(true);\n\t\t            callback_receive.sendPluginResult(result);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the plugin is active and we don't want to broadcast to other receivers\n\t\t\tif (this.isReceiving && !broadcast) {\n\t\t\t\tthis.abortBroadcast();\n\t\t\t}\n\t     }\n\t}\n\t\n\tpublic void broadcast(boolean v) {\n\t\tthis.broadcast = v;\n\t}\n\t\n\tpublic void startReceiving(CallbackContext ctx) {\n\t\tthis.callback_receive = ctx;\n\t\tthis.isReceiving = true;\n\t}\n\n\tpublic void stopReceiving() {\n\t\tthis.callback_receive = null;\n\t\tthis.isReceiving = false;\n\t}\n}", "class_id": 0, "repo": "ahmedwahba/cordova-plugin-sms-receiver", "file": "src/android/SmsReceiver.java", "last_update_at": "2020-06-16T22:19:03+00:00", "question_id": "6d9d9dd13b76e576fbb2c42bdbb8a9bf2eb6cff8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SmsReceiver extends BroadcastReceiver {\n\t\n\tpublic static final String SMS_EXTRA_NAME = \"pdus\";\n\tprivate CallbackContext callback_receive;\n\tprivate boolean isReceiving = true;\n\t\n\t// This broadcast boolean is used to continue or not the message broadcast\n\t// to the other BroadcastReceivers waiting for an incoming SMS (like the native SMS app)\n\tprivate boolean broadcast = false;\n\t\n\t@Override\n\tpublic void onReceive(Context ctx, Intent intent) {\n\t\t\n\t\t// Get the SMS map from Intent\n\t    Bundle extras = intent.getExtras();\n\t    if (extras != null)\n\t    {\n\t\t   // Get received SMS Array\n\t\t\tObject[] smsExtra = (Object[]) extras.get(SMS_EXTRA_NAME);\n\t\t\tfor (int i=0; i < smsExtra.length; i++)\n\t\t\t{\n\t\t\t\tSmsMessage sms = SmsMessage.createFromPdu((byte[]) smsExtra[i]);\n\t\t\t\tif(this.isReceiving && this.callback_receive != null) {\n                    String formattedMsg = sms.getOriginatingAddress() + \">\" + sms.getMessageBody();\n\t\t        \tPluginResult result = new PluginResult(PluginResult.Status.OK, formattedMsg);\n\t\t           \tresult.setKeepCallback(true);\n\t\t            callback_receive.sendPluginResult(result);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If the plugin is active and we don't want to broadcast to other receivers\n\t\t\tif (this.isReceiving && !broadcast) {\n\t\t\t\tthis.abortBroadcast();\n\t\t\t}\n\t     }\n\t}\n\t\n\tpublic void broadcast(boolean v) {\n\t\tthis.broadcast = v;\n\t}\n\t\n\tpublic void startReceiving(CallbackContext ctx) {\n\t\tthis.callback_receive = ctx;\n\t\tthis.isReceiving = true;\n\t}\n\tpublic void stopReceiving() {\n\t\tthis.callback_receive = null;\n\t\tthis.isReceiving = false;\n\t}\n"]]}
{"hexsha": "a44bb119eff1f8cc82761a192d68f83d520aa509", "ext": "java", "lang": "Java", "content": "public class TLFileLocationToBeDeprecated extends TLObject {\n    public static final int CONSTRUCTOR_ID = 0xbc7fc6cd;\n\n    protected long volumeId;\n\n    protected int localId;\n\n    private final String _constructor = \"fileLocationToBeDeprecated#bc7fc6cd\";\n\n    public TLFileLocationToBeDeprecated() {\n    }\n\n    public TLFileLocationToBeDeprecated(long volumeId, int localId) {\n        this.volumeId = volumeId;\n        this.localId = localId;\n    }\n\n    @Override\n    public void serializeBody(OutputStream stream) throws IOException {\n        writeLong(volumeId, stream);\n        writeInt(localId, stream);\n    }\n\n    @Override\n    @SuppressWarnings({\"unchecked\", \"SimplifiableConditionalExpression\"})\n    public void deserializeBody(InputStream stream, TLContext context) throws IOException {\n        volumeId = readLong(stream);\n        localId = readInt(stream);\n    }\n\n    @Override\n    public int computeSerializedSize() {\n        int size = SIZE_CONSTRUCTOR_ID;\n        size += SIZE_INT64;\n        size += SIZE_INT32;\n        return size;\n    }\n\n    @Override\n    public String toString() {\n        return _constructor;\n    }\n\n    @Override\n    public int getConstructorId() {\n        return CONSTRUCTOR_ID;\n    }\n\n    public long getVolumeId() {\n        return volumeId;\n    }\n\n    public void setVolumeId(long volumeId) {\n        this.volumeId = volumeId;\n    }\n\n    public int getLocalId() {\n        return localId;\n    }\n\n    public void setLocalId(int localId) {\n        this.localId = localId;\n    }\n}", "class_id": 0, "repo": "J0s3f/kotlogram", "file": "tl/src/main/java/com/github/badoualy/telegram/tl/api/TLFileLocationToBeDeprecated.java", "last_update_at": "2020-05-26T19:14:26+00:00", "question_id": "a44bb119eff1f8cc82761a192d68f83d520aa509", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TLFileLocationToBeDeprecated extends TLObject {\n    public static final int CONSTRUCTOR_ID = 0xbc7fc6cd;\n    protected long volumeId;\n    protected int localId;\n    private final String _constructor = \"fileLocationToBeDeprecated#bc7fc6cd\";\n    public TLFileLocationToBeDeprecated() {\n    }\n    public TLFileLocationToBeDeprecated(long volumeId, int localId) {\n        this.volumeId = volumeId;\n        this.localId = localId;\n    }\n    @Override\n    public void serializeBody(OutputStream stream) throws IOException {\n        writeLong(volumeId, stream);\n        writeInt(localId, stream);\n    }\n    @Override\n    @SuppressWarnings({\"unchecked\", \"SimplifiableConditionalExpression\"})\n    public void deserializeBody(InputStream stream, TLContext context) throws IOException {\n        volumeId = readLong(stream);\n        localId = readInt(stream);\n    }\n    @Override\n    public int computeSerializedSize() {\n        int size = SIZE_CONSTRUCTOR_ID;\n        size += SIZE_INT64;\n        size += SIZE_INT32;\n        return size;\n    }\n    @Override\n    public String toString() {\n        return _constructor;\n    }\n    @Override\n    public int getConstructorId() {\n        return CONSTRUCTOR_ID;\n    }\n    public long getVolumeId() {\n        return volumeId;\n    }\n    public void setVolumeId(long volumeId) {\n        this.volumeId = volumeId;\n    }\n    public int getLocalId() {\n        return localId;\n    }\n    public void setLocalId(int localId) {\n        this.localId = localId;\n    }\n"]]}
{"hexsha": "d2258fe7d3f1d1320a8294d37c49498bd53afe95", "ext": "java", "lang": "Java", "content": "class AccountResourceTest extends ServletTestBase {\n\n    AccountResourceTest() {\n        super(\"/ukelonn\", \"/api\");\n    }\n\n    @Test\n    void testGetAccount() throws Exception {\n        // Create the request and response for the Shiro login\n        HttpServletRequest request = mock(HttpServletRequest.class);\n        HttpSession session = mock(HttpSession.class);\n        when(request.getSession()).thenReturn(session);\n        HttpServletResponse response = mock(HttpServletResponse.class);\n\n        // Create the object to be tested\n        AccountResource resource = new AccountResource();\n\n        // Log the user in to shiro\n        loginUser(request, response, \"jad\", \"1ad\");\n\n        // Create mock OSGi services to inject and inject it\n        MockLogService logservice = new MockLogService();\n        resource.setLogservice(logservice);\n\n        // Inject fake OSGi service UkelonnService\n        UkelonnService ukelonn = mock(UkelonnService.class);\n        when(ukelonn.getAccount(anyString())).thenReturn(getJadAccount());\n        resource.ukelonn = ukelonn;\n\n        // Run the method under test\n        Account result = resource.getAccount(\"jad\");\n\n        // Check the result\n        assertEquals(\"jad\", result.getUsername());\n        assertEquals(673.0, result.getBalance(), 0.0);\n    }\n\n    /**\n     * Test that verifies that a regular user can't access other users than the\n     * one they are logged in as.\n     *\n     * @throws Exception\n     */\n    @Test\n    void testGetAccountOtherUsername() throws Exception {\n        // Create the request and response for the Shiro login\n        HttpServletRequest request = mock(HttpServletRequest.class);\n        HttpSession session = mock(HttpSession.class);\n        when(request.getSession()).thenReturn(session);\n        HttpServletResponse response = mock(HttpServletResponse.class);\n\n        // Log the user in to shiro\n        loginUser(request, response, \"jad\", \"1ad\");\n\n        // Create the object to be tested\n        AccountResource resource = new AccountResource();\n\n        // Create mock OSGi services to inject and inject it\n        MockLogService logservice = new MockLogService();\n        resource.setLogservice(logservice);\n\n        // Inject fake OSGi service UkelonnService\n        UkelonnService ukelonn = mock(UkelonnService.class);\n        resource.ukelonn = ukelonn;\n\n        // Run the method under test with a different username\n        assertThrows(ForbiddenException.class, () -> {\n                resource.getAccount(\"jod\");\n            });\n    }\n\n    /**\n     * Test that verifies that an admin user can access other users than the\n     * one they are logged in as.\n     *\n     * @throws Exception\n     */\n    @Test\n    void testGetAccountWhenLoggedInAsAdministrator() throws Exception {\n        // Create the request and response for the Shiro login\n        HttpServletRequest request = mock(HttpServletRequest.class);\n        HttpSession session = mock(HttpSession.class);\n        when(request.getSession()).thenReturn(session);\n        HttpServletResponse response = mock(HttpServletResponse.class);\n\n        // Log the admin user in to shiro\n        loginUser(request, response, \"admin\", \"admin\");\n\n        // Create the object to be tested\n        AccountResource resource = new AccountResource();\n\n        // Create mock OSGi services to inject and inject it\n        MockLogService logservice = new MockLogService();\n        resource.setLogservice(logservice);\n\n        // Inject fake OSGi service UkelonnService\n        UkelonnService ukelonn = mock(UkelonnService.class);\n        when(ukelonn.getAccount(anyString())).thenReturn(getJadAccount());\n        resource.ukelonn = ukelonn;\n\n        // Run the method under test\n        Account result = resource.getAccount(\"jad\");\n\n        // Check the response\n        assertEquals(\"jad\", result.getUsername());\n        assertEquals(673.0, result.getBalance(), 0.0);\n    }\n\n    @Test\n    void testGetAccountNoUsername() throws Exception {\n        // Create the request and response for the Shiro login\n        HttpServletRequest request = mock(HttpServletRequest.class);\n        HttpSession session = mock(HttpSession.class);\n        when(request.getSession()).thenReturn(session);\n\n        // Create the object to be tested\n        AccountResource resource = new AccountResource();\n\n        // Create mock OSGi services to inject and inject it\n        MockLogService logservice = new MockLogService();\n        resource.setLogservice(logservice);\n\n        // Inject fake OSGi service UkelonnService\n        UkelonnService ukelonn = mock(UkelonnService.class);\n        resource.ukelonn = ukelonn;\n\n        // Run the method under test\n        assertThrows(BadRequestException.class, () -> {\n                resource.getAccount(null);\n            });\n    }\n\n    @Test\n    void testGetAccountUsernameNotPresentInDatabase() throws Exception {\n        // Create the request and response for the Shiro login\n        HttpServletRequest request = mock(HttpServletRequest.class);\n        HttpSession session = mock(HttpSession.class);\n        when(request.getSession()).thenReturn(session);\n        HttpServletResponse response = mock(HttpServletResponse.class);\n\n        // Log the admin user in to shiro\n        loginUser(request, response, \"admin\", \"admin\");\n\n        // Create the object to be tested\n        AccountResource resource = new AccountResource();\n\n        // Create mock OSGi services to inject and inject it\n        MockLogService logservice = new MockLogService();\n        resource.setLogservice(logservice);\n\n        // Inject fake OSGi service UkelonnService\n        UkelonnService ukelonn = mock(UkelonnService.class);\n        when(ukelonn.getAccount(anyString())).thenThrow(UkelonnException.class);\n        resource.ukelonn = ukelonn;\n\n        // Run the method under test\n        assertThrows(InternalServerErrorException.class, () -> {\n                resource.getAccount(\"on\");\n            });\n    }\n\n    @Test\n    void testGetAccountWhenSubjectHasNullPrincipal() {\n        createSubjectWithNullPrincipalAndBindItToThread();\n\n        // Create the object to be tested\n        AccountResource resource = new AccountResource();\n\n        // Create mock OSGi services to inject and inject it\n        MockLogService logservice = new MockLogService();\n        resource.setLogservice(logservice);\n\n        // Inject fake OSGi service UkelonnService\n        UkelonnService ukelonn = mock(UkelonnService.class);\n        resource.ukelonn = ukelonn;\n\n        // Run the method under test\n        assertThrows(InternalServerErrorException.class, () -> {\n                resource.getAccount(\"on\");\n            });\n    }\n}", "class_id": 0, "repo": "steinarb/ukelonn", "file": "ukelonn.web.services/src/test/java/no/priv/bang/ukelonn/api/resources/AccountResourceTest.java", "last_update_at": "2020-12-27T13:00:40+00:00", "question_id": "d2258fe7d3f1d1320a8294d37c49498bd53afe95", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class AccountResourceTest extends ServletTestBase {\n    AccountResourceTest() {\n        super(\"/ukelonn\", \"/api\");\n    }\n    @Test\n    void testGetAccount() throws Exception {\n        // Create the request and response for the Shiro login\n        HttpServletRequest request = mock(HttpServletRequest.class);\n        HttpSession session = mock(HttpSession.class);\n        when(request.getSession()).thenReturn(session);\n        HttpServletResponse response = mock(HttpServletResponse.class);\n        // Create the object to be tested\n        AccountResource resource = new AccountResource();\n        // Log the user in to shiro\n        loginUser(request, response, \"jad\", \"1ad\");\n        // Create mock OSGi services to inject and inject it\n        MockLogService logservice = new MockLogService();\n        resource.setLogservice(logservice);\n        // Inject fake OSGi service UkelonnService\n        UkelonnService ukelonn = mock(UkelonnService.class);\n        when(ukelonn.getAccount(anyString())).thenReturn(getJadAccount());\n        resource.ukelonn = ukelonn;\n        // Run the method under test\n        Account result = resource.getAccount(\"jad\");\n        // Check the result\n        assertEquals(\"jad\", result.getUsername());\n        assertEquals(673.0, result.getBalance(), 0.0);\n    }\n    /**\n     * Test that verifies that a regular user can't access other users than the\n     * one they are logged in as.\n     *\n     * @throws Exception\n     */\n    @Test\n    void testGetAccountOtherUsername() throws Exception {\n        // Create the request and response for the Shiro login\n        HttpServletRequest request = mock(HttpServletRequest.class);\n        HttpSession session = mock(HttpSession.class);\n        when(request.getSession()).thenReturn(session);\n        HttpServletResponse response = mock(HttpServletResponse.class);\n        // Log the user in to shiro\n        loginUser(request, response, \"jad\", \"1ad\");\n        // Create the object to be tested\n        AccountResource resource = new AccountResource();\n        // Create mock OSGi services to inject and inject it\n        MockLogService logservice = new MockLogService();\n        resource.setLogservice(logservice);\n        // Inject fake OSGi service UkelonnService\n        UkelonnService ukelonn = mock(UkelonnService.class);\n        resource.ukelonn = ukelonn;\n        // Run the method under test with a different username\n        assertThrows(ForbiddenException.class, () -> {\n                resource.getAccount(\"jod\");\n            });\n    }\n    /**\n     * Test that verifies that an admin user can access other users than the\n     * one they are logged in as.\n     *\n     * @throws Exception\n     */\n    @Test\n    void testGetAccountWhenLoggedInAsAdministrator() throws Exception {\n        // Create the request and response for the Shiro login\n        HttpServletRequest request = mock(HttpServletRequest.class);\n        HttpSession session = mock(HttpSession.class);\n        when(request.getSession()).thenReturn(session);\n        HttpServletResponse response = mock(HttpServletResponse.class);\n        // Log the admin user in to shiro\n        loginUser(request, response, \"admin\", \"admin\");\n        // Create the object to be tested\n        AccountResource resource = new AccountResource();\n        // Create mock OSGi services to inject and inject it\n        MockLogService logservice = new MockLogService();\n        resource.setLogservice(logservice);\n        // Inject fake OSGi service UkelonnService\n        UkelonnService ukelonn = mock(UkelonnService.class);\n        when(ukelonn.getAccount(anyString())).thenReturn(getJadAccount());\n        resource.ukelonn = ukelonn;\n        // Run the method under test\n        Account result = resource.getAccount(\"jad\");\n        // Check the response\n        assertEquals(\"jad\", result.getUsername());\n        assertEquals(673.0, result.getBalance(), 0.0);\n    }\n    @Test\n    void testGetAccountNoUsername() throws Exception {\n        // Create the request and response for the Shiro login\n        HttpServletRequest request = mock(HttpServletRequest.class);\n        HttpSession session = mock(HttpSession.class);\n        when(request.getSession()).thenReturn(session);\n        // Create the object to be tested\n        AccountResource resource = new AccountResource();\n        // Create mock OSGi services to inject and inject it\n        MockLogService logservice = new MockLogService();\n        resource.setLogservice(logservice);\n        // Inject fake OSGi service UkelonnService\n        UkelonnService ukelonn = mock(UkelonnService.class);\n        resource.ukelonn = ukelonn;\n        // Run the method under test\n        assertThrows(BadRequestException.class, () -> {\n                resource.getAccount(null);\n            });\n    }\n    @Test\n    void testGetAccountUsernameNotPresentInDatabase() throws Exception {\n        // Create the request and response for the Shiro login\n        HttpServletRequest request = mock(HttpServletRequest.class);\n        HttpSession session = mock(HttpSession.class);\n        when(request.getSession()).thenReturn(session);\n        HttpServletResponse response = mock(HttpServletResponse.class);\n        // Log the admin user in to shiro\n        loginUser(request, response, \"admin\", \"admin\");\n        // Create the object to be tested\n        AccountResource resource = new AccountResource();\n        // Create mock OSGi services to inject and inject it\n        MockLogService logservice = new MockLogService();\n        resource.setLogservice(logservice);\n        // Inject fake OSGi service UkelonnService\n        UkelonnService ukelonn = mock(UkelonnService.class);\n        when(ukelonn.getAccount(anyString())).thenThrow(UkelonnException.class);\n        resource.ukelonn = ukelonn;\n        // Run the method under test\n        assertThrows(InternalServerErrorException.class, () -> {\n                resource.getAccount(\"on\");\n            });\n    }\n    @Test\n    void testGetAccountWhenSubjectHasNullPrincipal() {\n        createSubjectWithNullPrincipalAndBindItToThread();\n        // Create the object to be tested\n        AccountResource resource = new AccountResource();\n        // Create mock OSGi services to inject and inject it\n        MockLogService logservice = new MockLogService();\n        resource.setLogservice(logservice);\n        // Inject fake OSGi service UkelonnService\n        UkelonnService ukelonn = mock(UkelonnService.class);\n        resource.ukelonn = ukelonn;\n        // Run the method under test\n        assertThrows(InternalServerErrorException.class, () -> {\n                resource.getAccount(\"on\");\n            });\n    }\n"]]}
{"hexsha": "aee52a7e776d5b80b99cec6deff00aaf4dbdae38", "ext": "java", "lang": "Java", "content": "public class Or\nextends Predicate\n{\n    private static final String OR001 = \"JSONValidator/Or/001: All or rules failed for value '%s' in rule '%s'.\";\n    private List<Validator> rules = new LinkedList<Validator>();\n\n    public Or(String aName, JSONObject aRule, HashMap<String,Validator> aRuleset)\n    throws ValidationException\n    {\n        super(aName);\n        ValidatorUtil.requiresAttribute(aRule, ValidatorUtil.PARAM_RULES, JSONArray.class);\n\n        List<JSONValue> lRules = ((JSONArray) aRule.get(ValidatorUtil.PARAM_RULES)).getValue();\n        for (JSONValue lRule : lRules)\n        {\n            Validator lValidator = ValidatorUtil.buildValidator(lRule, aRuleset);\n            rules.add(lValidator);\n        }\n    }\n\n    public Or(String aName, Validator ... validators) {\n        super(aName);\n        rules.addAll(Arrays.asList(validators));\n    }\n\n    public void validate(JSONValue aValue)\n    throws ValidationException\n    {\n        for (Validator rule1 : rules)\n        {\n            try\n            {\n                rule1.validate(aValue);\n                // If we get here, the current validator succeeded.\n                // We only need a single success!\n                return;\n            }\n            catch (ValidationException e)\n            {\n                // This rule failed. Ignore for the time being.\n                // Try the other ones first.\n            }\n        }\n        // If we get here, then all rules failed.\n        // If all rules fail, we fail as well.\n        throw new ValidationException(String.format(OR001, aValue.toString(), this.getName()));\n    }\n}", "class_id": 0, "repo": "branscha/lib-jsontools", "file": "src/main/java/com/sdicons/json/validator/predicates/Or.java", "last_update_at": "2020-11-14T18:49:11+00:00", "question_id": "aee52a7e776d5b80b99cec6deff00aaf4dbdae38", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Or\nextends Predicate\n{\n    private static final String OR001 = \"JSONValidator/Or/001: All or rules failed for value '%s' in rule '%s'.\";\n    private List<Validator> rules = new LinkedList<Validator>();\n    public Or(String aName, JSONObject aRule, HashMap<String,Validator> aRuleset)\n    throws ValidationException\n    {\n        super(aName);\n        ValidatorUtil.requiresAttribute(aRule, ValidatorUtil.PARAM_RULES, JSONArray.class);\n        List<JSONValue> lRules = ((JSONArray) aRule.get(ValidatorUtil.PARAM_RULES)).getValue();\n        for (JSONValue lRule : lRules)\n        {\n            Validator lValidator = ValidatorUtil.buildValidator(lRule, aRuleset);\n            rules.add(lValidator);\n        }\n    }\n    public Or(String aName, Validator ... validators) {\n        super(aName);\n        rules.addAll(Arrays.asList(validators));\n    }\n    public void validate(JSONValue aValue)\n    throws ValidationException\n    {\n        for (Validator rule1 : rules)\n        {\n            try\n            {\n                rule1.validate(aValue);\n                // If we get here, the current validator succeeded.\n                // We only need a single success!\n                return;\n            }\n            catch (ValidationException e)\n            {\n                // This rule failed. Ignore for the time being.\n                // Try the other ones first.\n            }\n        }\n        // If we get here, then all rules failed.\n        // If all rules fail, we fail as well.\n        throw new ValidationException(String.format(OR001, aValue.toString(), this.getName()));\n    }\n"]]}
{"hexsha": "611780d35f607cc64b3f7e9e2beecf6317a8442d", "ext": "java", "lang": "Java", "content": "public class DepositDataFunction\n        extends PagedBaseFunction<Map.Entry<Long, StatDeposit>, Collection<Map.Entry<Long, StatDeposit>>> {\n\n    private static final String FUNC_NAME = DepositFunction.getMainDescriptor() + \"_data\";\n\n    public DepositDataFunction(Object descriptor, QueryParameters params, String continuationToken) {\n        super(descriptor, params, FUNC_NAME, continuationToken);\n    }\n\n    protected FunctionQueryContext getContext(QueryContext context) {\n        return super.getContext(context, FunctionQueryContext.class);\n    }\n\n    @Override\n    public QueryResult<Map.Entry<Long, StatDeposit>, Collection<Map.Entry<Long, StatDeposit>>> execute(\n            QueryContext context) throws QueryExecutionException {\n        FunctionQueryContext functionContext = getContext(context);\n        DepositParameters parameters = new DepositParameters(\n                getQueryParameters(),\n                getQueryParameters().getDerivedParameters());\n\n        try {\n            Collection<Map.Entry<Long, StatDeposit>> result = functionContext.getSearchDao().getDeposits(\n                    parameters,\n                    TypeUtil.toLocalDateTime(parameters.getFromTime()),\n                    TypeUtil.toLocalDateTime(parameters.getToTime()),\n                    getFromId().orElse(null),\n                    parameters.getSize()\n            );\n            return new BaseQueryResult<>(result::stream, () -> result);\n        } catch (DaoException e) {\n            throw new QueryExecutionException(e);\n        }\n    }\n}", "class_id": 0, "repo": "rbkmoney/fistful-magista", "file": "src/main/java/com/rbkmoney/fistful/magista/query/impl/data/DepositDataFunction.java", "last_update_at": "2020-03-21T06:58:14+00:00", "question_id": "611780d35f607cc64b3f7e9e2beecf6317a8442d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DepositDataFunction\n        extends PagedBaseFunction<Map.Entry<Long, StatDeposit>, Collection<Map.Entry<Long, StatDeposit>>> {\n    private static final String FUNC_NAME = DepositFunction.getMainDescriptor() + \"_data\";\n    public DepositDataFunction(Object descriptor, QueryParameters params, String continuationToken) {\n        super(descriptor, params, FUNC_NAME, continuationToken);\n    }\n    protected FunctionQueryContext getContext(QueryContext context) {\n        return super.getContext(context, FunctionQueryContext.class);\n    }\n    @Override\n    public QueryResult<Map.Entry<Long, StatDeposit>, Collection<Map.Entry<Long, StatDeposit>>> execute(\n            QueryContext context) throws QueryExecutionException {\n        FunctionQueryContext functionContext = getContext(context);\n        DepositParameters parameters = new DepositParameters(\n                getQueryParameters(),\n                getQueryParameters().getDerivedParameters());\n        try {\n            Collection<Map.Entry<Long, StatDeposit>> result = functionContext.getSearchDao().getDeposits(\n                    parameters,\n                    TypeUtil.toLocalDateTime(parameters.getFromTime()),\n                    TypeUtil.toLocalDateTime(parameters.getToTime()),\n                    getFromId().orElse(null),\n                    parameters.getSize()\n            );\n            return new BaseQueryResult<>(result::stream, () -> result);\n        } catch (DaoException e) {\n            throw new QueryExecutionException(e);\n        }\n    }\n"]]}
{"hexsha": "a246f6aea1f675bb4ecfafd72d1ba814ad8ad967", "ext": "java", "lang": "Java", "content": "public class BlogStatus2DB<T> implements DataObject2DB<T> {\n\n\t@Override\n\tpublic int getTotalRecord() {\n\t\tString sql = \"select count(*) from blog_status\";\n\t\tObject[] params = {};\n\t\treturn (int)DBUtils.query(sql, params, new IntegerHandler());\n\t}\n\n\t@Override\n\tpublic int insertData(Object obj) {\n\t\tblog_status status = (blog_status)obj;\n\t\tblog_index index = new blog_index();\n\t\tindex.setIndex_id(status.getStatus_id());\n\t\tindex.setIndex_glance(status.getStatus_content());\n\t\tindex.setIndex_type(\"2\");\n\t\tString sql1 = \"insert into blog_status(status_id,status_content,holder_id) values(?,?,?)\";\n\t\tString sql2 = \"insert into blog_index(index_id,index_type,index_glance,index_title) values(?,?,?,?)\";\n\t\tObject[] param1 = {status.getStatus_id(), status.getStatus_content(), status.getHolder_id()};\n\t\tObject[] param2 = {index.getIndex_id(), index.getIndex_type(), index.getIndex_glance(), index.getIndex_title()};\n\t\tString[] sql = {sql1, sql2};\n\t\tObject[][] params = {param1, param2};\n\t\treturn DBUtils.updateTranscation(sql, params);\n\t}\n\n\t@Override\n\tpublic int deleteData(String id) {\n\t\tString sql1 = \"delete from blog_status where status_id=?\";\n\t\tString sql2 = \"delete from blog_index where index_id=?\";\n\t\tObject[] param1 = {id};\n\t\tObject[] param2 = {id};\n\t\tString[] sql = {sql1, sql2};\n\t\tObject[][] params = {param1, param2};\n\t\treturn DBUtils.updateTranscation(sql, params);\n\t}\n\n\t@Override\n\tpublic int updateData(Object obj) {\n\t\tblog_status status = (blog_status)obj;\n\t\tString sql = \"update blog_status set status_content=? where status_id=?\";\n\t\tObject[] params = {status.getStatus_content(), status.getStatus_id()};\n \t\treturn DBUtils.update(sql, params);\n\t}\n\n\t@Override\n\tpublic blog_page selectData(int currentPage, int pageContain, int pageInFrame) {\n\t\tint totalRecord = getTotalRecord();\n\t\tblog_page page = new blog_page(totalRecord, currentPage, pageContain, pageInFrame);\n\t\tint start = ((page.getCurrentPage() - 1) * page.getPageContain());\n\t\tif(start < 0){\n\t\t\tstart = 0;\n\t\t}\n\t\tString sql = \"select status_id, status_content, publish_date, holder_id from blog_status order by publish_date desc limit ?,?\";\n\t\tObject[] params = {start, page.getPageContain()};\n\t\tpage.setList(DBUtils.query(sql, params, new ListHandler<List<T>>(blog_status.class)));\n\t\treturn page;\n\t}\n\n\t@Override\n\tpublic blog_page selectIndexData(int currentPage, int pageContain, int pageInFrame) {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic T selectByID(String id) {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n}", "class_id": 0, "repo": "yhswjtuILMARE/blog", "file": "src/DAO/BlogStatus2DB.java", "last_update_at": "2020-01-11T00:42:59+00:00", "question_id": "a246f6aea1f675bb4ecfafd72d1ba814ad8ad967", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BlogStatus2DB<T> implements DataObject2DB<T> {\n\t@Override\n\tpublic int getTotalRecord() {\n\t\tString sql = \"select count(*) from blog_status\";\n\t\tObject[] params = {};\n\t\treturn (int)DBUtils.query(sql, params, new IntegerHandler());\n\t}\n\t@Override\n\tpublic int insertData(Object obj) {\n\t\tblog_status status = (blog_status)obj;\n\t\tblog_index index = new blog_index();\n\t\tindex.setIndex_id(status.getStatus_id());\n\t\tindex.setIndex_glance(status.getStatus_content());\n\t\tindex.setIndex_type(\"2\");\n\t\tString sql1 = \"insert into blog_status(status_id,status_content,holder_id) values(?,?,?)\";\n\t\tString sql2 = \"insert into blog_index(index_id,index_type,index_glance,index_title) values(?,?,?,?)\";\n\t\tObject[] param1 = {status.getStatus_id(), status.getStatus_content(), status.getHolder_id()};\n\t\tObject[] param2 = {index.getIndex_id(), index.getIndex_type(), index.getIndex_glance(), index.getIndex_title()};\n\t\tString[] sql = {sql1, sql2};\n\t\tObject[][] params = {param1, param2};\n\t\treturn DBUtils.updateTranscation(sql, params);\n\t}\n\t@Override\n\tpublic int deleteData(String id) {\n\t\tString sql1 = \"delete from blog_status where status_id=?\";\n\t\tString sql2 = \"delete from blog_index where index_id=?\";\n\t\tObject[] param1 = {id};\n\t\tObject[] param2 = {id};\n\t\tString[] sql = {sql1, sql2};\n\t\tObject[][] params = {param1, param2};\n\t\treturn DBUtils.updateTranscation(sql, params);\n\t}\n\t@Override\n\tpublic int updateData(Object obj) {\n\t\tblog_status status = (blog_status)obj;\n\t\tString sql = \"update blog_status set status_content=? where status_id=?\";\n\t\tObject[] params = {status.getStatus_content(), status.getStatus_id()};\n \t\treturn DBUtils.update(sql, params);\n\t}\n\t@Override\n\tpublic blog_page selectData(int currentPage, int pageContain, int pageInFrame) {\n\t\tint totalRecord = getTotalRecord();\n\t\tblog_page page = new blog_page(totalRecord, currentPage, pageContain, pageInFrame);\n\t\tint start = ((page.getCurrentPage() - 1) * page.getPageContain());\n\t\tif(start < 0){\n\t\t\tstart = 0;\n\t\t}\n\t\tString sql = \"select status_id, status_content, publish_date, holder_id from blog_status order by publish_date desc limit ?,?\";\n\t\tObject[] params = {start, page.getPageContain()};\n\t\tpage.setList(DBUtils.query(sql, params, new ListHandler<List<T>>(blog_status.class)));\n\t\treturn page;\n\t}\n\t@Override\n\tpublic blog_page selectIndexData(int currentPage, int pageContain, int pageInFrame) {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\t@Override\n\tpublic T selectByID(String id) {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n"]]}
{"hexsha": "4fc8179d27d40dcab9c6e57dd24e80fd5ab115dc", "ext": "java", "lang": "Java", "content": "public class CommandFreeze implements CommandExecutor {\n\n    private IBasic plugin;\n\n    public CommandFreeze(IBasic plugin) {\n        this.plugin = plugin;\n    }\n\n    @Override\n    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n        if (args.length != 1) {\n            sender.sendMessage(ChatColor.RED + \"Correct Usage: /\" + label + \" <player>\");\n            return true;\n        }\n\n        Player target = Bukkit.getPlayer(args[0]);\n\n        if (target == null) {\n            sender.sendMessage(ChatColor.RED + \"Player '\" + args[0] + \"' is not online.\");\n            return true;\n        }\n\n        FreezeType freezeType = plugin.getFreezeListener().getFreezeType(target);\n\n        if (freezeType == null) {\n            plugin.getFreezeListener().freeze(target, sender, FreezeType.FREEZE);\n            sender.sendMessage(ChatColor.GREEN + target.getName() + \" is now frozen.\");\n            target.sendMessage(ChatColor.RED.toString() + ChatColor.BOLD + \"You are now frozen.\");\n            return true;\n        }\n\n        if (FreezeType.FREEZE == freezeType) {\n            plugin.getFreezeListener().unfreeze(target, FreezeType.FREEZE);\n            sender.sendMessage(ChatColor.RED + target.getName() + \" is now unfrozen.\");\n            target.sendMessage(ChatColor.GREEN.toString() + ChatColor.BOLD + \"You are un-frozen.\");\n            return true;\n        }\n\n        if (FreezeType.HALT == freezeType) {\n            sender.sendMessage(ChatColor.RED + target.getName() + \" is currently halted. Use /halt \" + target.getName() + \" to unhalt.\");\n            return true;\n        }\n\n        // Support in-case extra enums are added.\n        sender.sendMessage(ChatColor.RED + \"Freeze type currently not implemented, inform an Administrator\");\n        return true;\n    }\n}", "class_id": 0, "repo": "IPVP-MC/iBase", "file": "basic/src/main/java/org/ipvp/ibasic/freeze/CommandFreeze.java", "last_update_at": "2020-07-22T06:20:22+00:00", "question_id": "4fc8179d27d40dcab9c6e57dd24e80fd5ab115dc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CommandFreeze implements CommandExecutor {\n    private IBasic plugin;\n    public CommandFreeze(IBasic plugin) {\n        this.plugin = plugin;\n    }\n    @Override\n    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n        if (args.length != 1) {\n            sender.sendMessage(ChatColor.RED + \"Correct Usage: /\" + label + \" <player>\");\n            return true;\n        }\n        Player target = Bukkit.getPlayer(args[0]);\n        if (target == null) {\n            sender.sendMessage(ChatColor.RED + \"Player '\" + args[0] + \"' is not online.\");\n            return true;\n        }\n        FreezeType freezeType = plugin.getFreezeListener().getFreezeType(target);\n        if (freezeType == null) {\n            plugin.getFreezeListener().freeze(target, sender, FreezeType.FREEZE);\n            sender.sendMessage(ChatColor.GREEN + target.getName() + \" is now frozen.\");\n            target.sendMessage(ChatColor.RED.toString() + ChatColor.BOLD + \"You are now frozen.\");\n            return true;\n        }\n        if (FreezeType.FREEZE == freezeType) {\n            plugin.getFreezeListener().unfreeze(target, FreezeType.FREEZE);\n            sender.sendMessage(ChatColor.RED + target.getName() + \" is now unfrozen.\");\n            target.sendMessage(ChatColor.GREEN.toString() + ChatColor.BOLD + \"You are un-frozen.\");\n            return true;\n        }\n        if (FreezeType.HALT == freezeType) {\n            sender.sendMessage(ChatColor.RED + target.getName() + \" is currently halted. Use /halt \" + target.getName() + \" to unhalt.\");\n            return true;\n        }\n        // Support in-case extra enums are added.\n        sender.sendMessage(ChatColor.RED + \"Freeze type currently not implemented, inform an Administrator\");\n        return true;\n    }\n"]]}
{"hexsha": "9d79243d109b602a953ff7ad838b6f6a21f700ed", "ext": "java", "lang": "Java", "content": "public class BinarySearchTreeUtils {\n\n\tprivate BinarySearchTreeUtils() {\n\t\tthrow new AssertionError(\"Non instantiability\");\n\t}\n\t\n\tpublic static <E extends Comparable<? super E>> TreeNode<E> buildBST(List<E> src) {\n\t\tList<E> distinct = src.stream().distinct().collect(Collectors.toList());\n\t\tCollections.sort(distinct);\n\t\treturn buildBST(distinct, 0, distinct.size() -1);\n\t}\n\t\n\tprivate static <E extends Comparable<? super E>> TreeNode<E> buildBST(List<E> src, int left, int right) {\n\t\tif(left > right) {\n\t\t\treturn null;\n\t\t}\n\t\tint mid = left + (right - left) / 2;\n\t\tTreeNode<E> root = new TreeNode<>(src.get(mid));\n\t\troot.left = buildBST(src, left, mid -1);\n\t\troot.right = buildBST(src, mid+1, right);\n\t\treturn root;\n\t}\n}", "class_id": 0, "repo": "vivaciously/education", "file": "java/algo-ds/src/main/java/net/codingartist/algo_ds/tree/BinarySearchTreeUtils.java", "last_update_at": "2020-11-10T13:19:03+00:00", "question_id": "9d79243d109b602a953ff7ad838b6f6a21f700ed", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BinarySearchTreeUtils {\n\tprivate BinarySearchTreeUtils() {\n\t\tthrow new AssertionError(\"Non instantiability\");\n\t}\n\t\n\tpublic static <E extends Comparable<? super E>> TreeNode<E> buildBST(List<E> src) {\n\t\tList<E> distinct = src.stream().distinct().collect(Collectors.toList());\n\t\tCollections.sort(distinct);\n\t\treturn buildBST(distinct, 0, distinct.size() -1);\n\t}\n\t\n\tprivate static <E extends Comparable<? super E>> TreeNode<E> buildBST(List<E> src, int left, int right) {\n\t\tif(left > right) {\n\t\t\treturn null;\n\t\t}\n\t\tint mid = left + (right - left) / 2;\n\t\tTreeNode<E> root = new TreeNode<>(src.get(mid));\n\t\troot.left = buildBST(src, left, mid -1);\n\t\troot.right = buildBST(src, mid+1, right);\n\t\treturn root;\n\t}\n"]]}
{"hexsha": "f612fd0e016f984b7cffce7955ab9d447adef8c9", "ext": "java", "lang": "Java", "content": "public class ImapCrawlerParser extends CrawlerParser\n{\n\n    private static final long serialVersionUID = 6062546853256504993L;\n\n\n\n    static public Store connect2Server(URLName url, ParseContext context) throws MessagingException\n    {\n\n        ImapCrawlerContext imapCrawlerContext = context.get(ImapCrawlerContext.class, new ImapCrawlerContext());\n\n        Properties properties = System.getProperties();\n\n        properties.setProperty(\"mail.store.protocol\", url.getProtocol());\n\n        if(imapCrawlerContext.getIgnoreSSLCertificates())\n        {\n            properties.setProperty(\"mail.imaps.socketFactory.class\", CertificateIgnoringSocketFactory.class.getName());\n            properties.setProperty(\"mail.imaps.socketFactory.fallback\", \"false\");\n        }\n\n        if(!StringUtils.nullOrWhitespace(imapCrawlerContext.getSSLCertificateFilePath()) && \"imaps\".equalsIgnoreCase(url.getProtocol()))\n        {\n            properties.setProperty(\"javax.net.ssl.trustStore\", imapCrawlerContext.getSSLCertificateFilePath());\n            properties.setProperty(\"javax.net.ssl.trustStorePassword\", imapCrawlerContext.getSSLCertificateFilePassword());\n        }\n\n\n        Session session = Session.getDefaultInstance(properties);\n        Store mailStore = session.getStore(url.getProtocol());\n\n\n        String strUserName = imapCrawlerContext.getUserName();\n        if(strUserName == null) strUserName = url.getUsername();\n\n        String strPassword = imapCrawlerContext.getPassword();\n        if(strPassword == null) strPassword = url.getPassword();\n\n        if(!mailStore.isConnected()) mailStore.connect(url.getHost(), url.getPort(), strUserName, strPassword);\n\n\n        return mailStore;\n    }\n\n\n\n    /**\n     * Does this folder hold any subfolders?\n     * \n     * @param folder the folder to be checked\n     * @return true if this folder has any subfolders, false otherwise\n     * @throws MessagingException if it prooves impossible to find out\n     */\n    public static boolean holdsFolders(Folder folder) throws MessagingException\n    {\n        // this if has been added during the work on issue 2005759\n        // gmail returns wrong type, it is necessary to call list() to determine\n        // if a folder actually contains subfolders\n        if((folder.getType() & Folder.HOLDS_FOLDERS) == Folder.HOLDS_FOLDERS)\n        {\n            return folder.list().length > 0;\n        }\n        else\n        {\n            // this means that the folder can't have any subfolders \"by definition\"\n            return false;\n        }\n    }\n\n\n\n\n    /**\n     * Does this folder hold any messages?\n     * \n     * @param folder the folder to be checked\n     * @return true if this folder has any messages, false otherwise\n     * @throws MessagingException if it prooves impossible to find out\n     */\n    public static boolean holdsMessages(Folder folder) throws MessagingException\n    {\n        return (folder.getType() & Folder.HOLDS_MESSAGES) == Folder.HOLDS_MESSAGES;\n    }\n\n\n\n    protected HashMap<Folder, Boolean> m_hsImapFolder2Stickyness = new HashMap<Folder, Boolean>();\n\n\n    protected Leech m_leech;\n\n\n\n    protected Store m_mailStore;\n\n\n\n    protected boolean checkIfInConstraints(String strURL2Check, MimeMessage message, ParseContext context) throws MessagingException\n    {\n        CrawlerContext crawlerContext = context.get(CrawlerContext.class, new CrawlerContext());\n\n\n        if(!crawlerContext.getURLFilter().accept(strURL2Check))\n        {\n            String strType = \"IMAP directory \";\n            if(message != null) strType = \"IMAP message \";\n\n            if(crawlerContext.getVerbose())\n                LoggerFactory.getLogger(CrawlerParser.class.getName()).info(\n                        strType + strURL2Check + \" is outside the URL constraints for this data source. Skipping.\");\n\n            return false;\n        }\n\n\n\n        return true;\n    }\n\n\n\n    protected URLName getMessageUrl(Folder folderOfmessage, MimeMessage message) throws MessagingException\n    {\n        String strUrlName4Folder = folderOfmessage.getURLName().toString();\n        if(!strUrlName4Folder.endsWith(\"/\")) strUrlName4Folder += \"/\";\n\n        // hier ist es bums, ob die id sticky ist oder nicht. Die URL ist der Pointer auf diese, momentane message, mit dem ich die erreichen und\n        // downloaden kann. Fur das inkrementelle indexieren ist dann die dataExistsId relevant, die darf dann NICHT diese Url sein, wenn diese nicht\n        // sticky ist. in diesem Fall (oder vielleicht sogar immer, mal schauen) nehme ich irgendwelche Daten aus dem header (wie w\u00e4rs mit\n        // folder+messageid)\n\n\n        return new URLName(strUrlName4Folder + \";UID=\" + ((UIDFolder) folderOfmessage).getUID(message));\n\n        // if(uidsAreSticky(folderOfmessage))\n        // {\n        //\n        // }\n        // else\n        // {\n        // if(useHeadersHash)\n        // {\n        // return strUrlName4Folder + MailUtil.getMessageIdWithHeadersHash(message);\n        // }\n        // else\n        // {\n        // return strUrlName4Folder + MailUtil.getMessageId((MimeMessage) message);\n        // }\n        // }\n    }\n\n\n\n    @Override\n    protected Iterator<MultiValueHashMap<String, Object>> getSubDataEntitiesInformation(InputStream stream, ContentHandler handler,\n            Metadata metadata, ParseContext context) throws Exception\n    {\n\n        // imap url schema: imap[s]://uname@hostname:port/folder;uidvalidity=385759045/;uid=20. Examples (incl. message-referenzierung)\n        // http://xml.resource.org/public/rfc/html/rfc2192.html#anchor10\n        // allerdings nimmt der Java ImapStore auch URLs mit Passw\u00f6rtern an. Dann geht auch\n        // imap[s]://uname:pwd@hostname:port/folder;uidvalidity=385759045/;uid=20\n\n\n        CrawlerContext crawlerContext = context.get(CrawlerContext.class, new CrawlerContext());\n\n\n        String strContainerURL = metadata.get(Metadata.SOURCE);\n\n        URLName containerURLName = new URLName(strContainerURL);\n\n        if(m_mailStore == null) m_mailStore = connect2Server(containerURLName, context);\n\n        // wenn kein directory angegeben wird, dann crawlen wir einfach den default folder und die inbox\n        LinkedList<Folder> llFolderz2Crawl = new LinkedList<Folder>();\n        if(containerURLName.getFile() != null)\n        {\n            Folder folder = m_mailStore.getFolder(containerURLName.getFile());\n            if(folder != null && folder.exists()) llFolderz2Crawl.add(folder);\n             else\n                 throw new FileNotFoundException(\"Can't find imap folder '\" + folder.getFullName() + \"'\");\n            \n        }\n        else\n        {\n            Folder folder = m_mailStore.getDefaultFolder();\n            if(folder != null && folder.exists()) llFolderz2Crawl.add(folder);\n\n            folder = m_mailStore.getFolder(\"INBOX\");\n            if(folder != null && folder.exists()) llFolderz2Crawl.add(folder);\n        }\n\n\n\n        LinkedList<MultiValueHashMap<String, Object>> llEntityInfo = new LinkedList<MultiValueHashMap<String, Object>>();\n\n\n        for (Folder folder2crawl : llFolderz2Crawl)\n        {\n            // Jetzt haben wir die Containerobjekte - nun geben wir die Daten zu den SubEntities zur\u00fcck\n\n\n            // die subfolder\n            boolean bFolderCanHaveSubFolders = (folder2crawl.getType() & Folder.HOLDS_FOLDERS) == Folder.HOLDS_FOLDERS;\n\n            if(bFolderCanHaveSubFolders)\n            {\n                folder2crawl.open(Folder.READ_ONLY);\n\n\n                Folder[] subFolders = folder2crawl.list();\n                for (Folder subFolder : subFolders)\n                {\n                    URLName urlName = subFolder.getURLName();\n                    URLName urlNameWithPassword =\n                            new URLName(containerURLName.getProtocol(), urlName.getHost(), urlName.getPort(), urlName.getFile(),\n                                    urlName.getUsername(), containerURLName.getPassword());\n\n                    if(!checkIfInConstraints(urlName.toString(), null, context)) continue;\n\n\n                    MultiValueHashMap<String, Object> hsEntityInformation = new MultiValueHashMap<String, Object>();\n\n                    hsEntityInformation.add(CrawlerParser.SOURCEID, urlName);\n                    hsEntityInformation.add(\"urlNameWithPassword\", urlNameWithPassword);\n                    hsEntityInformation.add(\"folder\", subFolder.getFullName());\n\n                    llEntityInfo.add(hsEntityInformation);\n                }\n            }\n\n\n            // die messages\n            boolean bFolderCanHaveMessages = (folder2crawl.getType() & Folder.HOLDS_MESSAGES) == Folder.HOLDS_MESSAGES;\n\n            if(bFolderCanHaveMessages)\n            {\n                if(!folder2crawl.isOpen()) folder2crawl.open(Folder.READ_ONLY);\n\n\n                // wir holen uns alle nicht-deleted messages, und werfen noch die raus, die 'expunged' sind\n                Message[] relevantMessagesOfFolder = folder2crawl.search(new FlagTerm(new Flags(Flags.Flag.DELETED), false));\n                ArrayList<Message> nonDelNonExpungedMessages = new ArrayList<Message>();\n                for (Message message : relevantMessagesOfFolder)\n                    if(!message.isExpunged()) nonDelNonExpungedMessages.add(message);\n                relevantMessagesOfFolder = nonDelNonExpungedMessages.toArray(new Message[0]);\n\n                // die Daten die wir sp\u00e4ter ben\u00f6tigen holen wir uns effizient in einem Rutsch - deswegen ben\u00f6tigen wir auch keinen Thread mit dem\n                // OneAfterOneIterator, um Speicher zu sparen (siehe DirectoryCrawlerParser). Das Array haben wir hier eh. Entweder oder.\n                FetchProfile profile = new FetchProfile();\n                profile.add(UIDFolder.FetchProfileItem.UID);\n                profile.add(\"Message-ID\");\n                folder2crawl.fetch(relevantMessagesOfFolder, profile);\n\n\n                for (int i = 0; i < relevantMessagesOfFolder.length && !crawlerContext.stopRequested(); i++)\n                {\n                    MimeMessage message = (MimeMessage) relevantMessagesOfFolder[i];\n\n                    // hier brauchen wir noch eine URL mit und eine ohne Passwort\n                    URLName urlName = getMessageUrl(folder2crawl, message);\n                    URLName urlNameWithPassword =\n                            new URLName(containerURLName.getProtocol(), urlName.getHost(), urlName.getPort(), urlName.getFile(),\n                                    urlName.getUsername(), containerURLName.getPassword());\n\n\n                    if(!checkIfInConstraints(urlName.toString(), message, context)) continue;\n\n\n                    MultiValueHashMap<String, Object> hsEntityInformation = new MultiValueHashMap<String, Object>();\n\n                    hsEntityInformation.add(CrawlerParser.SOURCEID, urlName);\n                    hsEntityInformation.add(\"urlNameWithPassword\", urlNameWithPassword);\n                    hsEntityInformation.add(\"Message-ID\", message.getHeader(\"Message-ID\")[0]);\n                    hsEntityInformation.add(\"folder\", folder2crawl.getFullName());\n\n                    llEntityInfo.add(hsEntityInformation);\n                }\n            }\n\n            // wir haben die folder abgearbeitet, dann k\u00f6nnen wir diesen Speicher wieder frei geben\n            m_hsImapFolder2Stickyness.clear();\n\n\n\n\n\n            if(folder2crawl.isOpen()) folder2crawl.close(false);\n        }\n\n\n\n        return llEntityInfo.iterator();\n    }\n\n\n\n    @Override\n    public Set<MediaType> getSupportedTypes(ParseContext context)\n    {\n        return Collections.singleton(DatasourceMediaTypes.IMAPFOLDER);\n    }\n\n\n\n    @Override\n    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException,\n            TikaException\n    {\n        super.parse(stream, handler, metadata, context);\n\n\n        // Wenn ein completter crawl fertig ist, dann schliessen wir auch wieder unseren MailStore\n\n        int iCurrentCrawlingDepth = 0;\n        String strDepth = metadata.get(CrawlerParser.CURRENT_CRAWLING_DEPTH);\n        if(strDepth != null) iCurrentCrawlingDepth = Integer.valueOf(strDepth);\n\n\n        if(iCurrentCrawlingDepth != 0) return;\n\n        try\n        {\n\n            m_mailStore.close();\n            m_mailStore = null;\n\n        }\n        catch (MessagingException e)\n        {\n            String strSourceID = metadata.get(Metadata.SOURCE);\n\n            ExceptionUtils.handleException(e, strSourceID, metadata, context.get(CrawlerContext.class, new CrawlerContext()), context,\n                    iCurrentCrawlingDepth, handler);\n        }\n    }\n\n\n\n    @Override\n    protected void processCurrentDataEntity(InputStream stream, Metadata metadata, ContentHandler handler, ParseContext context) throws Exception\n    {\n        // NOP - wie don't process directories - we only process the files inside\n    }\n\n\n\n    @Override\n    protected void processSubDataEntity(MultiValueHashMap<String, Object> subDataEntityInformation, Metadata metadata,\n            ContentHandler handler2use4recursiveCall, ParseContext context) throws Exception\n    {\n\n        URLName urlNameWithPassword = (URLName) subDataEntityInformation.getFirst(\"urlNameWithPassword\");\n\n        String strMessageId = (String) subDataEntityInformation.getFirst(\"Message-ID\");\n        String strMessageFolder = (String) subDataEntityInformation.getFirst(\"folder\");\n\n        String strEntityId = ImapURLStreamProvider.getEntityId(strMessageFolder, strMessageId);\n\n        // wir setzten die hier schon mal - die Daten haben wir in einem prefetching-Schritt schon effizient geladen. Wenn diese hier schon im\n        // Metadata-Objekt stehen, werden sie von der addFirstMetadata nicht nochmal geladen\n        metadata.set(Metadata.SOURCE, urlNameWithPassword.toString());\n        metadata.set(IncrementalCrawlingHistory.dataEntityId, strEntityId);\n        metadata.set(IncrementalCrawlingHistory.dataEntityContentFingerprint,\n                ImapURLStreamProvider.getDataEntityContentFingerprint(strEntityId));\n        URLName urlNameWithoutPassword =\n                new URLName(urlNameWithPassword.getProtocol(), urlNameWithPassword.getHost(), urlNameWithPassword.getPort(),\n                        urlNameWithPassword.getFile(), urlNameWithPassword.getUsername(), \"\");\n        metadata.set(LeechMetadata.RESOURCE_NAME_KEY, urlNameWithoutPassword.toString());\n        if(strMessageId == null)\n            metadata.set(\"Content-Type\", DatasourceMediaTypes.IMAPFOLDER.toString());\n        else\n            metadata.set(\"Content-Type\", \"message/rfc822\");\n\n\n\n        metadata =\n                URLStreamProvider.getURLStreamProvider4Protocol(urlNameWithPassword.getProtocol()).addFirstMetadata(urlNameWithPassword, metadata,\n                        context);\n        InputStream stream = URLStreamProvider.getURLStreamProvider(urlNameWithPassword).getStream(urlNameWithPassword, metadata, context);\n\n        try\n        {\n\n            if(m_leech == null) m_leech = new Leech();\n\n\n            // hier nimmt der dann bei einer message hoffentlich den Tika RFC822Parser\n            Parser parser = m_leech.getParser();\n\n            parser.parse(stream, handler2use4recursiveCall, metadata, context);\n\n        }\n        finally\n        {\n            if(stream != null) stream.close();\n        }\n\n    }\n\n\n\n\n}", "class_id": 0, "repo": "leechcrawler/leech", "file": "src/main/java/de/dfki/km/leech/parser/ImapCrawlerParser.java", "last_update_at": "2020-05-19T17:00:35+00:00", "question_id": "f612fd0e016f984b7cffce7955ab9d447adef8c9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ImapCrawlerParser extends CrawlerParser\n{\n    private static final long serialVersionUID = 6062546853256504993L;\n    static public Store connect2Server(URLName url, ParseContext context) throws MessagingException\n    {\n        ImapCrawlerContext imapCrawlerContext = context.get(ImapCrawlerContext.class, new ImapCrawlerContext());\n        Properties properties = System.getProperties();\n        properties.setProperty(\"mail.store.protocol\", url.getProtocol());\n        if(imapCrawlerContext.getIgnoreSSLCertificates())\n        {\n            properties.setProperty(\"mail.imaps.socketFactory.class\", CertificateIgnoringSocketFactory.class.getName());\n            properties.setProperty(\"mail.imaps.socketFactory.fallback\", \"false\");\n        }\n        if(!StringUtils.nullOrWhitespace(imapCrawlerContext.getSSLCertificateFilePath()) && \"imaps\".equalsIgnoreCase(url.getProtocol()))\n        {\n            properties.setProperty(\"javax.net.ssl.trustStore\", imapCrawlerContext.getSSLCertificateFilePath());\n            properties.setProperty(\"javax.net.ssl.trustStorePassword\", imapCrawlerContext.getSSLCertificateFilePassword());\n        }\n        Session session = Session.getDefaultInstance(properties);\n        Store mailStore = session.getStore(url.getProtocol());\n        String strUserName = imapCrawlerContext.getUserName();\n        if(strUserName == null) strUserName = url.getUsername();\n        String strPassword = imapCrawlerContext.getPassword();\n        if(strPassword == null) strPassword = url.getPassword();\n        if(!mailStore.isConnected()) mailStore.connect(url.getHost(), url.getPort(), strUserName, strPassword);\n        return mailStore;\n    }\n    /**\n     * Does this folder hold any subfolders?\n     * \n     * @param folder the folder to be checked\n     * @return true if this folder has any subfolders, false otherwise\n     * @throws MessagingException if it prooves impossible to find out\n     */\n    public static boolean holdsFolders(Folder folder) throws MessagingException\n    {\n        // this if has been added during the work on issue 2005759\n        // gmail returns wrong type, it is necessary to call list() to determine\n        // if a folder actually contains subfolders\n        if((folder.getType() & Folder.HOLDS_FOLDERS) == Folder.HOLDS_FOLDERS)\n        {\n            return folder.list().length > 0;\n        }\n        else\n        {\n            // this means that the folder can't have any subfolders \"by definition\"\n            return false;\n        }\n    }\n    /**\n     * Does this folder hold any messages?\n     * \n     * @param folder the folder to be checked\n     * @return true if this folder has any messages, false otherwise\n     * @throws MessagingException if it prooves impossible to find out\n     */\n    public static boolean holdsMessages(Folder folder) throws MessagingException\n    {\n        return (folder.getType() & Folder.HOLDS_MESSAGES) == Folder.HOLDS_MESSAGES;\n    }\n    protected HashMap<Folder, Boolean> m_hsImapFolder2Stickyness = new HashMap<Folder, Boolean>();\n    protected Leech m_leech;\n    protected Store m_mailStore;\n    protected boolean checkIfInConstraints(String strURL2Check, MimeMessage message, ParseContext context) throws MessagingException\n    {\n        CrawlerContext crawlerContext = context.get(CrawlerContext.class, new CrawlerContext());\n        if(!crawlerContext.getURLFilter().accept(strURL2Check))\n        {\n            String strType = \"IMAP directory \";\n            if(message != null) strType = \"IMAP message \";\n            if(crawlerContext.getVerbose())\n                LoggerFactory.getLogger(CrawlerParser.class.getName()).info(\n                        strType + strURL2Check + \" is outside the URL constraints for this data source. Skipping.\");\n            return false;\n        }\n        return true;\n    }\n    protected URLName getMessageUrl(Folder folderOfmessage, MimeMessage message) throws MessagingException\n    {\n        String strUrlName4Folder = folderOfmessage.getURLName().toString();\n        if(!strUrlName4Folder.endsWith(\"/\")) strUrlName4Folder += \"/\";\n        // hier ist es bums, ob die id sticky ist oder nicht. Die URL ist der Pointer auf diese, momentane message, mit dem ich die erreichen und\n        // downloaden kann. Fur das inkrementelle indexieren ist dann die dataExistsId relevant, die darf dann NICHT diese Url sein, wenn diese nicht\n        // sticky ist. in diesem Fall (oder vielleicht sogar immer, mal schauen) nehme ich irgendwelche Daten aus dem header (wie w\u00e4rs mit\n        // folder+messageid)\n        return new URLName(strUrlName4Folder + \";UID=\" + ((UIDFolder) folderOfmessage).getUID(message));\n        // if(uidsAreSticky(folderOfmessage))\n        // {\n        //\n        // }\n        // else\n        // {\n        // if(useHeadersHash)\n        // {\n        // return strUrlName4Folder + MailUtil.getMessageIdWithHeadersHash(message);\n        // }\n        // else\n        // {\n        // return strUrlName4Folder + MailUtil.getMessageId((MimeMessage) message);\n        // }\n        // }\n    }\n    @Override\n    protected Iterator<MultiValueHashMap<String, Object>> getSubDataEntitiesInformation(InputStream stream, ContentHandler handler,\n            Metadata metadata, ParseContext context) throws Exception\n    {\n        // imap url schema: imap[s]://uname@hostname:port/folder;uidvalidity=385759045/;uid=20. Examples (incl. message-referenzierung)\n        // http://xml.resource.org/public/rfc/html/rfc2192.html#anchor10\n        // allerdings nimmt der Java ImapStore auch URLs mit Passw\u00f6rtern an. Dann geht auch\n        // imap[s]://uname:pwd@hostname:port/folder;uidvalidity=385759045/;uid=20\n        CrawlerContext crawlerContext = context.get(CrawlerContext.class, new CrawlerContext());\n        String strContainerURL = metadata.get(Metadata.SOURCE);\n        URLName containerURLName = new URLName(strContainerURL);\n        if(m_mailStore == null) m_mailStore = connect2Server(containerURLName, context);\n        // wenn kein directory angegeben wird, dann crawlen wir einfach den default folder und die inbox\n        LinkedList<Folder> llFolderz2Crawl = new LinkedList<Folder>();\n        if(containerURLName.getFile() != null)\n        {\n            Folder folder = m_mailStore.getFolder(containerURLName.getFile());\n            if(folder != null && folder.exists()) llFolderz2Crawl.add(folder);\n             else\n                 throw new FileNotFoundException(\"Can't find imap folder '\" + folder.getFullName() + \"'\");\n        }\n        else\n        {\n            Folder folder = m_mailStore.getDefaultFolder();\n            if(folder != null && folder.exists()) llFolderz2Crawl.add(folder);\n            folder = m_mailStore.getFolder(\"INBOX\");\n            if(folder != null && folder.exists()) llFolderz2Crawl.add(folder);\n        }\n        LinkedList<MultiValueHashMap<String, Object>> llEntityInfo = new LinkedList<MultiValueHashMap<String, Object>>();\n        for (Folder folder2crawl : llFolderz2Crawl)\n        {\n            // Jetzt haben wir die Containerobjekte - nun geben wir die Daten zu den SubEntities zur\u00fcck\n            // die subfolder\n            boolean bFolderCanHaveSubFolders = (folder2crawl.getType() & Folder.HOLDS_FOLDERS) == Folder.HOLDS_FOLDERS;\n            if(bFolderCanHaveSubFolders)\n            {\n                folder2crawl.open(Folder.READ_ONLY);\n                Folder[] subFolders = folder2crawl.list();\n                for (Folder subFolder : subFolders)\n                {\n                    URLName urlName = subFolder.getURLName();\n                    URLName urlNameWithPassword =\n                            new URLName(containerURLName.getProtocol(), urlName.getHost(), urlName.getPort(), urlName.getFile(),\n                                    urlName.getUsername(), containerURLName.getPassword());\n                    if(!checkIfInConstraints(urlName.toString(), null, context)) continue;\n                    MultiValueHashMap<String, Object> hsEntityInformation = new MultiValueHashMap<String, Object>();\n                    hsEntityInformation.add(CrawlerParser.SOURCEID, urlName);\n                    hsEntityInformation.add(\"urlNameWithPassword\", urlNameWithPassword);\n                    hsEntityInformation.add(\"folder\", subFolder.getFullName());\n                    llEntityInfo.add(hsEntityInformation);\n                }\n            }\n            // die messages\n            boolean bFolderCanHaveMessages = (folder2crawl.getType() & Folder.HOLDS_MESSAGES) == Folder.HOLDS_MESSAGES;\n            if(bFolderCanHaveMessages)\n            {\n                if(!folder2crawl.isOpen()) folder2crawl.open(Folder.READ_ONLY);\n                // wir holen uns alle nicht-deleted messages, und werfen noch die raus, die 'expunged' sind\n                Message[] relevantMessagesOfFolder = folder2crawl.search(new FlagTerm(new Flags(Flags.Flag.DELETED), false));\n                ArrayList<Message> nonDelNonExpungedMessages = new ArrayList<Message>();\n                for (Message message : relevantMessagesOfFolder)\n                    if(!message.isExpunged()) nonDelNonExpungedMessages.add(message);\n                relevantMessagesOfFolder = nonDelNonExpungedMessages.toArray(new Message[0]);\n                // die Daten die wir sp\u00e4ter ben\u00f6tigen holen wir uns effizient in einem Rutsch - deswegen ben\u00f6tigen wir auch keinen Thread mit dem\n                // OneAfterOneIterator, um Speicher zu sparen (siehe DirectoryCrawlerParser). Das Array haben wir hier eh. Entweder oder.\n                FetchProfile profile = new FetchProfile();\n                profile.add(UIDFolder.FetchProfileItem.UID);\n                profile.add(\"Message-ID\");\n                folder2crawl.fetch(relevantMessagesOfFolder, profile);\n                for (int i = 0; i < relevantMessagesOfFolder.length && !crawlerContext.stopRequested(); i++)\n                {\n                    MimeMessage message = (MimeMessage) relevantMessagesOfFolder[i];\n                    // hier brauchen wir noch eine URL mit und eine ohne Passwort\n                    URLName urlName = getMessageUrl(folder2crawl, message);\n                    URLName urlNameWithPassword =\n                            new URLName(containerURLName.getProtocol(), urlName.getHost(), urlName.getPort(), urlName.getFile(),\n                                    urlName.getUsername(), containerURLName.getPassword());\n                    if(!checkIfInConstraints(urlName.toString(), message, context)) continue;\n                    MultiValueHashMap<String, Object> hsEntityInformation = new MultiValueHashMap<String, Object>();\n                    hsEntityInformation.add(CrawlerParser.SOURCEID, urlName);\n                    hsEntityInformation.add(\"urlNameWithPassword\", urlNameWithPassword);\n                    hsEntityInformation.add(\"Message-ID\", message.getHeader(\"Message-ID\")[0]);\n                    hsEntityInformation.add(\"folder\", folder2crawl.getFullName());\n                    llEntityInfo.add(hsEntityInformation);\n                }\n            }\n            // wir haben die folder abgearbeitet, dann k\u00f6nnen wir diesen Speicher wieder frei geben\n            m_hsImapFolder2Stickyness.clear();\n            if(folder2crawl.isOpen()) folder2crawl.close(false);\n        }\n        return llEntityInfo.iterator();\n    }\n    @Override\n    public Set<MediaType> getSupportedTypes(ParseContext context)\n    {\n        return Collections.singleton(DatasourceMediaTypes.IMAPFOLDER);\n    }\n    @Override\n    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException,\n            TikaException\n    {\n        super.parse(stream, handler, metadata, context);\n        // Wenn ein completter crawl fertig ist, dann schliessen wir auch wieder unseren MailStore\n        int iCurrentCrawlingDepth = 0;\n        String strDepth = metadata.get(CrawlerParser.CURRENT_CRAWLING_DEPTH);\n        if(strDepth != null) iCurrentCrawlingDepth = Integer.valueOf(strDepth);\n        if(iCurrentCrawlingDepth != 0) return;\n        try\n        {\n            m_mailStore.close();\n            m_mailStore = null;\n        }\n        catch (MessagingException e)\n        {\n            String strSourceID = metadata.get(Metadata.SOURCE);\n            ExceptionUtils.handleException(e, strSourceID, metadata, context.get(CrawlerContext.class, new CrawlerContext()), context,\n                    iCurrentCrawlingDepth, handler);\n        }\n    }\n    @Override\n    protected void processCurrentDataEntity(InputStream stream, Metadata metadata, ContentHandler handler, ParseContext context) throws Exception\n    {\n        // NOP - wie don't process directories - we only process the files inside\n    }\n    @Override\n    protected void processSubDataEntity(MultiValueHashMap<String, Object> subDataEntityInformation, Metadata metadata,\n            ContentHandler handler2use4recursiveCall, ParseContext context) throws Exception\n    {\n        URLName urlNameWithPassword = (URLName) subDataEntityInformation.getFirst(\"urlNameWithPassword\");\n        String strMessageId = (String) subDataEntityInformation.getFirst(\"Message-ID\");\n        String strMessageFolder = (String) subDataEntityInformation.getFirst(\"folder\");\n        String strEntityId = ImapURLStreamProvider.getEntityId(strMessageFolder, strMessageId);\n        // wir setzten die hier schon mal - die Daten haben wir in einem prefetching-Schritt schon effizient geladen. Wenn diese hier schon im\n        // Metadata-Objekt stehen, werden sie von der addFirstMetadata nicht nochmal geladen\n        metadata.set(Metadata.SOURCE, urlNameWithPassword.toString());\n        metadata.set(IncrementalCrawlingHistory.dataEntityId, strEntityId);\n        metadata.set(IncrementalCrawlingHistory.dataEntityContentFingerprint,\n                ImapURLStreamProvider.getDataEntityContentFingerprint(strEntityId));\n        URLName urlNameWithoutPassword =\n                new URLName(urlNameWithPassword.getProtocol(), urlNameWithPassword.getHost(), urlNameWithPassword.getPort(),\n                        urlNameWithPassword.getFile(), urlNameWithPassword.getUsername(), \"\");\n        metadata.set(LeechMetadata.RESOURCE_NAME_KEY, urlNameWithoutPassword.toString());\n        if(strMessageId == null)\n            metadata.set(\"Content-Type\", DatasourceMediaTypes.IMAPFOLDER.toString());\n        else\n            metadata.set(\"Content-Type\", \"message/rfc822\");\n        metadata =\n                URLStreamProvider.getURLStreamProvider4Protocol(urlNameWithPassword.getProtocol()).addFirstMetadata(urlNameWithPassword, metadata,\n                        context);\n        InputStream stream = URLStreamProvider.getURLStreamProvider(urlNameWithPassword).getStream(urlNameWithPassword, metadata, context);\n        try\n        {\n            if(m_leech == null) m_leech = new Leech();\n            // hier nimmt der dann bei einer message hoffentlich den Tika RFC822Parser\n            Parser parser = m_leech.getParser();\n            parser.parse(stream, handler2use4recursiveCall, metadata, context);\n        }\n        finally\n        {\n            if(stream != null) stream.close();\n        }\n    }\n"]]}
{"hexsha": "3adb986857c8c1f1de67fe373e7d21834e7bd83f", "ext": "java", "lang": "Java", "content": "public class Settings implements java.io.Serializable {\n  private final static String FILENAME = \"beanbowlSettings.ser\";\n  private final static int RECENT_FILE_COUNT = 5;\n  transient static Settings settings;\n\n  public List recentFiles;\n\n  private Settings() {\n    recentFiles = new LinkedList();\n  }\n\n  public static void addRecentFile(File file) {\n    if (file != null && !settings.recentFiles.contains(file)) {\n      settings.recentFiles.add(0, file);\n    }\n    while(settings.recentFiles.size() > 5) {\n      settings.recentFiles.remove(4);\n    }\n  }\n\n  public static Iterator getRecentFiles() {\n    return settings.recentFiles.iterator();\n  }\n\n  static {\n    if (getFile().exists()) {\n      try {\n        loadFromFile();\n      } catch (Exception err) {\n        System.err.println(\"Warning - settings could not be loaded: \" + err.getMessage());\n        settings = new Settings();\n      }\n    } else {\n      settings = new Settings();\n    }\n  }\n\n  @Override\nprotected void finalize() {\n    try {\n      saveToFile();\n    } catch (Exception err) {\n      System.err.println(\"Warning - settings could not be saved: \" + err.getMessage());\n    }\n  }\n\n  public static void loadFromFile() throws Exception {\n    InputStream fileIn = new FileInputStream(getFile());\n\t  ObjectInputStream objectIn = new ObjectInputStream(fileIn);\n\t  settings = (Settings) (objectIn.readObject());\n    objectIn.close();\n    fileIn.close();\n  }\n\n  public static void saveToFile() throws Exception {\n    FileOutputStream fileOut = new FileOutputStream(getFile());\n    ObjectOutputStream objectOut = new ObjectOutputStream(fileOut);\n    objectOut.writeObject(settings);\n    objectOut.close();\n    fileOut.close();\n  }\n\n  private static File getFile() {\n    File homeDir = new File(System.getProperties().getProperty(\"user.home\"));\n    return new File(homeDir, FILENAME);\n  }\n\n}", "class_id": 0, "repo": "TeamSPoon/CYC_JRTL_with_CommonLisp_OLD", "file": "platform/main/logicmoo-main/com/netbreeze/bbowl/Settings.java", "last_update_at": "2020-01-17T16:29:19+00:00", "question_id": "3adb986857c8c1f1de67fe373e7d21834e7bd83f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Settings implements java.io.Serializable {\n  private final static String FILENAME = \"beanbowlSettings.ser\";\n  private final static int RECENT_FILE_COUNT = 5;\n  transient static Settings settings;\n  public List recentFiles;\n  private Settings() {\n    recentFiles = new LinkedList();\n  }\n  public static void addRecentFile(File file) {\n    if (file != null && !settings.recentFiles.contains(file)) {\n      settings.recentFiles.add(0, file);\n    }\n    while(settings.recentFiles.size() > 5) {\n      settings.recentFiles.remove(4);\n    }\n  }\n  public static Iterator getRecentFiles() {\n    return settings.recentFiles.iterator();\n  }\n  static {\n    if (getFile().exists()) {\n      try {\n        loadFromFile();\n      } catch (Exception err) {\n        System.err.println(\"Warning - settings could not be loaded: \" + err.getMessage());\n        settings = new Settings();\n      }\n    } else {\n      settings = new Settings();\n    }\n  }\n  @Override\nprotected void finalize() {\n    try {\n      saveToFile();\n    } catch (Exception err) {\n      System.err.println(\"Warning - settings could not be saved: \" + err.getMessage());\n    }\n  }\n  public static void loadFromFile() throws Exception {\n    InputStream fileIn = new FileInputStream(getFile());\n\t  ObjectInputStream objectIn = new ObjectInputStream(fileIn);\n\t  settings = (Settings) (objectIn.readObject());\n    objectIn.close();\n    fileIn.close();\n  }\n  public static void saveToFile() throws Exception {\n    FileOutputStream fileOut = new FileOutputStream(getFile());\n    ObjectOutputStream objectOut = new ObjectOutputStream(fileOut);\n    objectOut.writeObject(settings);\n    objectOut.close();\n    fileOut.close();\n  }\n  private static File getFile() {\n    File homeDir = new File(System.getProperties().getProperty(\"user.home\"));\n    return new File(homeDir, FILENAME);\n  }\n"]]}
{"hexsha": "1e1c1aa9f3d325dd442e59ed0de11008b5165cc0", "ext": "java", "lang": "Java", "content": "public class JsonUtilsTest {\n    private static final String singleLogConfig = \"[{\\\"log_group_name\\\":\\\"test_group\\\"}]\";\n    private static final String multiLogConfig = \"[{\\\"log_group_name\\\":\\\"test_group1\\\"}, {\\\"log_group_name\\\":\\\"test_group2\\\"}, {\\\"log_group_name\\\":\\\"test_group1\\\"}]\";\n    private static final String singleLogConfigWithStream = \"[{\\\"log_group_name\\\":\\\"test_group\\\", \\\"log_stream_name\\\":\\\"test_stream\\\"}]\";\n\n    private static final String LOG_GROUP_NAME = \"log_group_name\";\n\n    private ObjectMapper mapper = new ObjectMapper();\n\n    @Test\n    public void testGetLogGroup() throws IOException {\n        JsonNode node = mapper.readTree(singleLogConfig);\n\n        List<String> groupList = JsonUtils.getMatchingListFromJsonArrayNode(node, LOG_GROUP_NAME);\n\n        Assert.assertEquals(1, groupList.size());\n        Assert.assertEquals(\"test_group\", groupList.get(0));\n    }\n\n    @Test\n    public void testGetMultipleLogGroups() throws IOException {\n        JsonNode node = mapper.readTree(multiLogConfig);\n\n        List<String> groupList = JsonUtils.getMatchingListFromJsonArrayNode(node, LOG_GROUP_NAME);\n\n        Assert.assertEquals(3, groupList.size());\n        Assert.assertTrue(groupList.contains(\"test_group1\"));\n        Assert.assertTrue(groupList.contains(\"test_group2\"));\n    }\n\n    @Test\n    public void testGetLogGroupWithStreamPresent() throws IOException {\n        JsonNode node = mapper.readTree(singleLogConfigWithStream);\n\n        List<String> groupList = JsonUtils.getMatchingListFromJsonArrayNode(node, LOG_GROUP_NAME);\n\n        Assert.assertEquals(1, groupList.size());\n        Assert.assertEquals(\"test_group\", groupList.get(0));\n    }\n}", "class_id": 0, "repo": "kwalczak/aws-xray-sdk-java", "file": "aws-xray-recorder-sdk-core/src/test/java/com/amazonaws/xray/utils/JsonUtilsTest.java", "last_update_at": "2020-01-08T09:32:07+00:00", "question_id": "1e1c1aa9f3d325dd442e59ed0de11008b5165cc0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class JsonUtilsTest {\n    private static final String singleLogConfig = \"[{\\\"log_group_name\\\":\\\"test_group\\\"}]\";\n    private static final String multiLogConfig = \"[{\\\"log_group_name\\\":\\\"test_group1\\\"}, {\\\"log_group_name\\\":\\\"test_group2\\\"}, {\\\"log_group_name\\\":\\\"test_group1\\\"}]\";\n    private static final String singleLogConfigWithStream = \"[{\\\"log_group_name\\\":\\\"test_group\\\", \\\"log_stream_name\\\":\\\"test_stream\\\"}]\";\n    private static final String LOG_GROUP_NAME = \"log_group_name\";\n    private ObjectMapper mapper = new ObjectMapper();\n    @Test\n    public void testGetLogGroup() throws IOException {\n        JsonNode node = mapper.readTree(singleLogConfig);\n        List<String> groupList = JsonUtils.getMatchingListFromJsonArrayNode(node, LOG_GROUP_NAME);\n        Assert.assertEquals(1, groupList.size());\n        Assert.assertEquals(\"test_group\", groupList.get(0));\n    }\n    @Test\n    public void testGetMultipleLogGroups() throws IOException {\n        JsonNode node = mapper.readTree(multiLogConfig);\n        List<String> groupList = JsonUtils.getMatchingListFromJsonArrayNode(node, LOG_GROUP_NAME);\n        Assert.assertEquals(3, groupList.size());\n        Assert.assertTrue(groupList.contains(\"test_group1\"));\n        Assert.assertTrue(groupList.contains(\"test_group2\"));\n    }\n    @Test\n    public void testGetLogGroupWithStreamPresent() throws IOException {\n        JsonNode node = mapper.readTree(singleLogConfigWithStream);\n        List<String> groupList = JsonUtils.getMatchingListFromJsonArrayNode(node, LOG_GROUP_NAME);\n        Assert.assertEquals(1, groupList.size());\n        Assert.assertEquals(\"test_group\", groupList.get(0));\n    }\n"]]}
{"hexsha": "4b8b58342947a1f429e602b2b205acc6b8ac53f5", "ext": "java", "lang": "Java", "content": "@Service\npublic class FileCateServiceImpl implements FileCateService{\n\t\n\t@Autowired\n\tprivate BaseDao<FileCate> baseDao;\n\n\t@Override\n\tpublic List<FileCate> getFileCates() {\n\t\t// TODO Auto-generated method stub\n\t\tString [] sortColum=new String[1];\n\t\tsortColum[0]=\"cateNo\";\n\t\treturn baseDao.selectByCriteria(\"filecates\",baseDao.createCriteria().order(sortColum,\"asc\"), FileCate.class);\n\t\t\n\t}\n\n\t@Override\n\tpublic FileCate getFileCate(String id) {\n\t\t// TODO Auto-generated method stub\n\t\treturn baseDao.selectById(\"filecates\", \"id\", id, FileCate.class);\n\t}\n\n\t@Override\n\tpublic List<FileCate> getFileCatesByParentId(String parentId) {\n\t\t// TODO Auto-generated method stub\n\t\tString [] sortColum=new String[1];\n\t\tsortColum[0]=\"cateNo\";\n\t\treturn baseDao.selectByCriteria(\"filecates\",baseDao.createCriteria().eq(\"parentId\", parentId).order(sortColum,\"asc\"), FileCate.class);\n\t\n\t}\n\t\n\t@Override\n\tpublic List<FileCate>  getchildCatesList(){\n\t\tString [] sortColum=new String[1];\n\t\tsortColum[0]=\"cateNo\";\n\t\treturn baseDao.selectByCriteria(\"filecates\",baseDao.createCriteria().not().eq(\"parentId\", \"0\").order(sortColum,\"asc\"), FileCate.class);\n\t}\n\n\t@Override\n\tpublic void saveFileCate(FileCate fileCate) {\n\t\t// TODO Auto-generated method stub\n\t\tUUID uuid=UUID.randomUUID();\n\t\tfileCate.setId(uuid.toString().replace(\"-\", \"\"));\n\t\tbaseDao.save(\"filecates\", \"id\", fileCate);\n\t}\n\t\n\t\n\t@Override\n\tpublic void removeFileCate(String id){\n\t\tbaseDao.removeById(\"filecates\", \"id\", id);\n\t}\n\t\n\n}", "class_id": 0, "repo": "coder9527/infoplat", "file": "02Engineering_\u5b9e\u65bd/04Code_\u5b9e\u73b0/infoService/src/main/java/com/info/fileService/service/imp/FileCateServiceImpl.java", "last_update_at": "2020-04-02T07:13:29+00:00", "question_id": "4b8b58342947a1f429e602b2b205acc6b8ac53f5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\npublic class FileCateServiceImpl implements FileCateService{\n\t\n\t@Autowired\n\tprivate BaseDao<FileCate> baseDao;\n\t@Override\n\tpublic List<FileCate> getFileCates() {\n\t\t// TODO Auto-generated method stub\n\t\tString [] sortColum=new String[1];\n\t\tsortColum[0]=\"cateNo\";\n\t\treturn baseDao.selectByCriteria(\"filecates\",baseDao.createCriteria().order(sortColum,\"asc\"), FileCate.class);\n\t\t\n\t}\n\t@Override\n\tpublic FileCate getFileCate(String id) {\n\t\t// TODO Auto-generated method stub\n\t\treturn baseDao.selectById(\"filecates\", \"id\", id, FileCate.class);\n\t}\n\t@Override\n\tpublic List<FileCate> getFileCatesByParentId(String parentId) {\n\t\t// TODO Auto-generated method stub\n\t\tString [] sortColum=new String[1];\n\t\tsortColum[0]=\"cateNo\";\n\t\treturn baseDao.selectByCriteria(\"filecates\",baseDao.createCriteria().eq(\"parentId\", parentId).order(sortColum,\"asc\"), FileCate.class);\n\t\n\t}\n\t\n\t@Override\n\tpublic List<FileCate>  getchildCatesList(){\n\t\tString [] sortColum=new String[1];\n\t\tsortColum[0]=\"cateNo\";\n\t\treturn baseDao.selectByCriteria(\"filecates\",baseDao.createCriteria().not().eq(\"parentId\", \"0\").order(sortColum,\"asc\"), FileCate.class);\n\t}\n\t@Override\n\tpublic void saveFileCate(FileCate fileCate) {\n\t\t// TODO Auto-generated method stub\n\t\tUUID uuid=UUID.randomUUID();\n\t\tfileCate.setId(uuid.toString().replace(\"-\", \"\"));\n\t\tbaseDao.save(\"filecates\", \"id\", fileCate);\n\t}\n\t\n\t\n\t@Override\n\tpublic void removeFileCate(String id){\n\t\tbaseDao.removeById(\"filecates\", \"id\", id);\n\t}\n\t\n"]]}
{"hexsha": "f4a2369c27b9baa3be59d7c514a0c1d723b2ba58", "ext": "java", "lang": "Java", "content": "public class StarSystemSpawner implements WorldGenerator.WorldSpawner {\n\t@Override\n\tpublic float getWeight() {\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic RenderLevel getSpawnLevel() {\n\t\treturn RenderLevel.INTERSTELLAR;\n\t}\n\n\t@Override\n\tpublic void spawn(SpaceObject center, PVector pos) {\n\t\tcreateSystem(pos);\n\t}\n\n\tpublic static void createSystem(PVector pos) {\n\t\tStar star = createStar(pos);\n\n\t\t// Generate terrestrial planets\n\t\tint planetCt = (int)v.random(1, 8);\n\t\tfor(int i = 0; i <= planetCt; i++) {\n\t\t\tfloat distance = v.random(.3F, 4) * AU_DISTANCE;\n\t\t\tPlanet planet = createPlanet(star.getPosition().add(PVector.random2D().mult(distance)));\n\t\t\torbit(star, planet, 0);\n\t\t}\n\n\t\t// Generate gas giants\n\t\tint gasGiantCt = (int)v.random(2);\n\t\tfor(int i = 0; i <= gasGiantCt; i++) {\n\t\t\tfloat distance = v.random(3, 6) * AU_DISTANCE;\n\t\t\tPlanet planet = createGasGiant(star.getPosition().add(PVector.random2D().mult(distance)));\n\t\t\torbit(star, planet, 0);\n\t\t}\n\t}\n\n\tpublic static Star createStar(PVector pos) {\n\t\tfloat temperature = (float)Math.exp(v.random((float)Math.log(2400), (float)Math.log(50000))); //TODO: fiddle\n\n\t\tfloat power = pow(10, v.random(29f, 31.5f));\n\t\tfloat mass = v.random(0.8f, 4) * power;\n\t\t//\t\tfloat radius = pow(10, v.random(.7F, 2));\n//\t\tfloat radius = pow(10, v.random(-1f, 1f)) * SUN_RADIUS;\n\t\tfloat density = pow(10, v.random(-.5f, .5f)) * 1408; // Sun's density\n\t\treturn register(new Star(\n\t\t\t\tResources.generateString(\"star\"),\n\t\t\t\tmass, // Mass\n\t\t\t\tdensity, // Density\n\t\t\t\ttemperature,\n\t\t\t\tpos, // Position\n\t\t\t\tnew PVector() // Velocity\n\t\t));\n\t}\n\n\tpublic static Planet createPlanet(PVector pos) {\n\t\tfloat mass = pow(10, v.random(23, 25));\n\t\tfloat density = v.random(3000, 6000);\n\t\tTerrestrialPlanet planet = register(new TerrestrialPlanet(\n\t\t\t\tResources.generateString(\"planet\"),\n\t\t\t\tmass,                    // Mass\n\t\t\t\tdensity,                // Density\n\t\t\t\tpos,                    // Coords\n\t\t\t\tnew PVector(),        // Velocity\n\t\t\t\trandomPlanetColor()    // Color\n\t\t));\n\t\t//\t\tfor(Feature feature : planet.getTerrain().getFeatures()) {\n\t\t//\t\t\tfeature.setPlanet(planet);\n\t\t//\t\t}\n\t\tcreateMoons(planet, (int)v.random(3), .3F * LUNAR_DISTANCE, 2 * LUNAR_DISTANCE);\n\t\treturn planet;\n\t}\n\n\tpublic static GasGiant createGasGiant(PVector pos) {\n\t\tfloat mass = pow(10, v.random(26, 28));\n\t\tfloat density = v.random(800, 1500);\n\t\tGasGiant planet = register(new GasGiant(\n\t\t\t\tResources.generateString(\"gas_giant\"),\n\t\t\t\tmass, // Mass\n\t\t\t\tdensity, // Radius\n\t\t\t\tpos, // Position\n\t\t\t\tnew PVector(), // Velocity\n\t\t\t\trandomPlanetColor() // Color\n\t\t));\n\t\tcreateMoons(planet, (int)v.random(3, 6), 1 * LUNAR_DISTANCE, 20 * LUNAR_DISTANCE);\n\t\treturn planet;\n\t}\n\n\tpublic static List<Moon> createMoons(Planet planet, int count, float minDist, float maxDist) {\n\t\tList<Moon> moons = new ArrayList<>();\n\t\tfor(int i = 0; i < count; i++) {\n\t\t\tfloat distance = v.random(minDist, maxDist);\n\t\t\tMoon moon = createMoon(planet, distance);\n\t\t\torbit(planet, moon, 0);\n\t\t\tmoons.add(moon);\n\t\t}\n\t\tmoons.sort(Comparator.comparingDouble(Moon::getOrbitDistance));\n\t\tfor(int i = 0; i < moons.size(); i++) {\n\t\t\tmoons.get(i).setName((i + 1) + \" \" + planet.getName());\n\t\t}\n\t\treturn moons;\n\t}\n\n\tpublic static Moon createMoon(Planet planet, float distance) {\n\t\tPVector pos = planet.getPosition().add(PVector.random2D().mult(planet.getRadius() + distance));\n\t\tfloat mass = pow(10, v.random(18, 23));\n\t\tfloat density = v.random(2500, 4000);\n\t\treturn register(new Moon(\n\t\t\t\tplanet,\n\t\t\t\tResources.generateString(\"moon\"),\n\t\t\t\tmass, // Mass\n\t\t\t\tdensity,   // Density\n\t\t\t\tpos,  // Coords\n\t\t\t\tnew PVector(),  // Velocity\n\t\t\t\trandomPlanetColor() // Color\n\t\t));\n\t}\n}", "class_id": 0, "repo": "StGerGer/vekta", "file": "src/main/java/vekta/spawner/world/StarSystemSpawner.java", "last_update_at": "2020-12-21T03:53:41+00:00", "question_id": "f4a2369c27b9baa3be59d7c514a0c1d723b2ba58", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class StarSystemSpawner implements WorldGenerator.WorldSpawner {\n\t@Override\n\tpublic float getWeight() {\n\t\treturn 1;\n\t}\n\t@Override\n\tpublic RenderLevel getSpawnLevel() {\n\t\treturn RenderLevel.INTERSTELLAR;\n\t}\n\t@Override\n\tpublic void spawn(SpaceObject center, PVector pos) {\n\t\tcreateSystem(pos);\n\t}\n\tpublic static void createSystem(PVector pos) {\n\t\tStar star = createStar(pos);\n\t\t// Generate terrestrial planets\n\t\tint planetCt = (int)v.random(1, 8);\n\t\tfor(int i = 0; i <= planetCt; i++) {\n\t\t\tfloat distance = v.random(.3F, 4) * AU_DISTANCE;\n\t\t\tPlanet planet = createPlanet(star.getPosition().add(PVector.random2D().mult(distance)));\n\t\t\torbit(star, planet, 0);\n\t\t}\n\t\t// Generate gas giants\n\t\tint gasGiantCt = (int)v.random(2);\n\t\tfor(int i = 0; i <= gasGiantCt; i++) {\n\t\t\tfloat distance = v.random(3, 6) * AU_DISTANCE;\n\t\t\tPlanet planet = createGasGiant(star.getPosition().add(PVector.random2D().mult(distance)));\n\t\t\torbit(star, planet, 0);\n\t\t}\n\t}\n\tpublic static Star createStar(PVector pos) {\n\t\tfloat temperature = (float)Math.exp(v.random((float)Math.log(2400), (float)Math.log(50000))); //TODO: fiddle\n\t\tfloat power = pow(10, v.random(29f, 31.5f));\n\t\tfloat mass = v.random(0.8f, 4) * power;\n\t\t//\t\tfloat radius = pow(10, v.random(.7F, 2));\n//\t\tfloat radius = pow(10, v.random(-1f, 1f)) * SUN_RADIUS;\n\t\tfloat density = pow(10, v.random(-.5f, .5f)) * 1408; // Sun's density\n\t\treturn register(new Star(\n\t\t\t\tResources.generateString(\"star\"),\n\t\t\t\tmass, // Mass\n\t\t\t\tdensity, // Density\n\t\t\t\ttemperature,\n\t\t\t\tpos, // Position\n\t\t\t\tnew PVector() // Velocity\n\t\t));\n\t}\n\tpublic static Planet createPlanet(PVector pos) {\n\t\tfloat mass = pow(10, v.random(23, 25));\n\t\tfloat density = v.random(3000, 6000);\n\t\tTerrestrialPlanet planet = register(new TerrestrialPlanet(\n\t\t\t\tResources.generateString(\"planet\"),\n\t\t\t\tmass,                    // Mass\n\t\t\t\tdensity,                // Density\n\t\t\t\tpos,                    // Coords\n\t\t\t\tnew PVector(),        // Velocity\n\t\t\t\trandomPlanetColor()    // Color\n\t\t));\n\t\t//\t\tfor(Feature feature : planet.getTerrain().getFeatures()) {\n\t\t//\t\t\tfeature.setPlanet(planet);\n\t\t//\t\t}\n\t\tcreateMoons(planet, (int)v.random(3), .3F * LUNAR_DISTANCE, 2 * LUNAR_DISTANCE);\n\t\treturn planet;\n\t}\n\tpublic static GasGiant createGasGiant(PVector pos) {\n\t\tfloat mass = pow(10, v.random(26, 28));\n\t\tfloat density = v.random(800, 1500);\n\t\tGasGiant planet = register(new GasGiant(\n\t\t\t\tResources.generateString(\"gas_giant\"),\n\t\t\t\tmass, // Mass\n\t\t\t\tdensity, // Radius\n\t\t\t\tpos, // Position\n\t\t\t\tnew PVector(), // Velocity\n\t\t\t\trandomPlanetColor() // Color\n\t\t));\n\t\tcreateMoons(planet, (int)v.random(3, 6), 1 * LUNAR_DISTANCE, 20 * LUNAR_DISTANCE);\n\t\treturn planet;\n\t}\n\tpublic static List<Moon> createMoons(Planet planet, int count, float minDist, float maxDist) {\n\t\tList<Moon> moons = new ArrayList<>();\n\t\tfor(int i = 0; i < count; i++) {\n\t\t\tfloat distance = v.random(minDist, maxDist);\n\t\t\tMoon moon = createMoon(planet, distance);\n\t\t\torbit(planet, moon, 0);\n\t\t\tmoons.add(moon);\n\t\t}\n\t\tmoons.sort(Comparator.comparingDouble(Moon::getOrbitDistance));\n\t\tfor(int i = 0; i < moons.size(); i++) {\n\t\t\tmoons.get(i).setName((i + 1) + \" \" + planet.getName());\n\t\t}\n\t\treturn moons;\n\t}\n\tpublic static Moon createMoon(Planet planet, float distance) {\n\t\tPVector pos = planet.getPosition().add(PVector.random2D().mult(planet.getRadius() + distance));\n\t\tfloat mass = pow(10, v.random(18, 23));\n\t\tfloat density = v.random(2500, 4000);\n\t\treturn register(new Moon(\n\t\t\t\tplanet,\n\t\t\t\tResources.generateString(\"moon\"),\n\t\t\t\tmass, // Mass\n\t\t\t\tdensity,   // Density\n\t\t\t\tpos,  // Coords\n\t\t\t\tnew PVector(),  // Velocity\n\t\t\t\trandomPlanetColor() // Color\n\t\t));\n\t}\n"]]}
{"hexsha": "6b7ab53d75c99b08fd5b4002862f6e89ad7c4140", "ext": "java", "lang": "Java", "content": "public class TestMyTime {\n\n\tpublic static void main(String[] args) {\n\t\tMyTime time1 = new MyTime(20, 56, 58);\n\t\tMyTime time2 = new MyTime(20, 59, 58);\n\t\tMyTime time3 = new MyTime(23, 59, 58);\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tSystem.out.println(time1.nextSecond());\n\t\t\tSystem.out.println(time2.nextSecond());\n\t\t\tSystem.out.println(time3.nextSecond());\n\t\t\tSystem.out.println(\"\");\n\t\t}\n\t}\n\n}", "class_id": 0, "repo": "juanip/bootcamp-globant", "file": "topic0/1-oop-exercises/src/ex1_9/TestMyTime.java", "last_update_at": "2020-08-29T20:23:56+00:00", "question_id": "6b7ab53d75c99b08fd5b4002862f6e89ad7c4140", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestMyTime {\n\tpublic static void main(String[] args) {\n\t\tMyTime time1 = new MyTime(20, 56, 58);\n\t\tMyTime time2 = new MyTime(20, 59, 58);\n\t\tMyTime time3 = new MyTime(23, 59, 58);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tSystem.out.println(time1.nextSecond());\n\t\t\tSystem.out.println(time2.nextSecond());\n\t\t\tSystem.out.println(time3.nextSecond());\n\t\t\tSystem.out.println(\"\");\n\t\t}\n\t}\n"]]}
{"hexsha": "c908faee48de2a277a57e3204bd8cf65bfee01be", "ext": "java", "lang": "Java", "content": "public class YangJavaTypeDefTranslator\n        extends YangJavaTypeDef\n        implements JavaCodeGeneratorInfo, JavaCodeGenerator {\n\n    private static final long serialVersionUID = 806201620L;\n\n    /**\n     * File handle to maintain temporary java code fragments as per the code\n     * snippet types.\n     */\n    private transient TempJavaCodeFragmentFiles tempFileHandle;\n\n    /**\n     * Creates a YANG java typedef object.\n     */\n    public YangJavaTypeDefTranslator() {\n        super();\n        setJavaFileInfo(new JavaFileInfoTranslator());\n        getJavaFileInfo().setGeneratedFileTypes(GENERATE_TYPEDEF_CLASS);\n    }\n\n    /**\n     * Returns the generated java file information.\n     *\n     * @return generated java file information\n     */\n    @Override\n    public JavaFileInfoTranslator getJavaFileInfo() {\n\n        if (javaFileInfo == null) {\n            throw new TranslatorException(\"Missing java info in java datamodel node \" +\n                                                  getName() + \" in \" +\n                                                  getLineNumber() + \" at \" +\n                                                  getCharPosition()\n                                                  + \" in \" + getFileName());\n        }\n        return (JavaFileInfoTranslator) javaFileInfo;\n    }\n\n    /**\n     * Sets the java file info object.\n     *\n     * @param javaInfo java file info object\n     */\n    @Override\n    public void setJavaFileInfo(JavaFileInfoTranslator javaInfo) {\n        javaFileInfo = javaInfo;\n    }\n\n    /**\n     * Returns the temporary file handle.\n     *\n     * @return temporary file handle\n     */\n    @Override\n    public TempJavaCodeFragmentFiles getTempJavaCodeFragmentFiles() {\n        return tempFileHandle;\n    }\n\n    /**\n     * Sets temporary file handle.\n     *\n     * @param fileHandle temporary file handle\n     */\n    @Override\n    public void setTempJavaCodeFragmentFiles(TempJavaCodeFragmentFiles fileHandle) {\n        tempFileHandle = fileHandle;\n    }\n\n    /**\n     * Prepare the information for java code generation corresponding to YANG\n     * typedef info.\n     *\n     * @param yangPlugin YANG plugin config\n     * @throws TranslatorException when fails to translate\n     */\n    @Override\n    public void generateCodeEntry(YangPluginConfig yangPlugin) throws TranslatorException {\n        if (getReferredSchema() != null) {\n            throw new InvalidNodeForTranslatorException();\n        }\n        // TODO update the below exception in all related places, remove file\n        // name and other information.\n        YangType typeInTypeDef = this.getTypeDefBaseType();\n        InvalidNodeForTranslatorException exception = new InvalidNodeForTranslatorException();\n        exception.setFileName(this.getFileName());\n        exception.setCharPosition(this.getCharPosition());\n        exception.setLine(this.getLineNumber());\n        if (typeInTypeDef.getDataType() == DERIVED) {\n            YangDerivedInfo derivedInfo = (YangDerivedInfo) typeInTypeDef.getDataTypeExtendedInfo();\n            if (derivedInfo.getEffectiveBuiltInType() == LEAFREF) {\n                throw exception;\n            }\n        } else if (typeInTypeDef.getDataType() == LEAFREF) {\n            throw exception;\n        }\n        updateJNCPackageInfo(this,yangPlugin);\n\n        if(typeInTypeDef.getDataType() == DERIVED){\n\n            this.getTypeList().forEach(yangType -> {\n                ((YangJavaTypeTranslator)yangType).updateJavaQualifiedInfo(yangPlugin.getConflictResolver());\n            });\n        }\n        if(typeInTypeDef.getDataType() == BITS){\n\n            this.getTypeList().forEach(yangType -> {\n                ((YangJavaTypeTranslator)yangType).updateJavaQualifiedInfo(yangPlugin.getConflictResolver());\n            });\n        }\n        ((YangJavaTypeTranslator)typeInTypeDef).updateJavaQualifiedInfo(yangPlugin.getConflictResolver());\n\n//        try {\n//            generateCodeOfNode(this, yangPlugin);\n//        } catch (IOException e) {\n//            throw new TranslatorException(\n//                    \"Failed to prepare generate code entry for typedef node \" + getName()\n//                            + \" in \" + getLineNumber() +\n//                            \" at \" + getCharPosition() +\n//                            \" in \" + getFileName(), e);\n//        }\n    }\n\n    /**\n     * Create a java file using the YANG typedef info.\n     *\n     * @throws TranslatorException when fails to translate\n     */\n    @Override\n    public void generateCodeExit() throws TranslatorException {\n        String classname= YangElement.normalize(this.getName());\n        JavaFileInfoTranslator fileInfo = this.getJavaFileInfo();\n        JavaClass javaClass = new JavaClass(classname, fileInfo.getPackage(),\n                \"Code generated by \"+this.getClass().getSimpleName() +\n                        \"\\n * <p>\"+\n                        \"\\n * See line \"+fileInfo.getLineNumber()+\" in\" +\n                        \"\\n * \"+fileInfo.getYangFileName()+\n                        \"\\n * \"+\n                        \"\\n * @author Auto Generated\");\n        String absoluteDirPath = getAbsolutePackagePath(fileInfo.getBaseCodeGenPath(),\n                fileInfo.getPackageFilePath());\n//        YangJavaModule yangJavaModule = (YangJavaModule)this.getYangJavaModule();\n\n        YangType typeInTypeDef = this.getTypeDefBaseType();\n\n\n        if(typeInTypeDef.getDataType() == ENUMERATION){\n            javaClass.setExtend(YangEnumeration.class.getName());\n\n            javaClass.addMethod(new JavaMethod(classname,\"\")\n                    .setModifiers(\"public\")\n                    .setExceptions(YangException.class.getName())\n                    .addParameter(\"String\",\"value\")\n                    .addLine(\"super(value,\").addLine(\"\\tnew String[] {\")\n                    .addLine(((YangJavaEnumeration)this.getTypeList().get(0).getDataTypeExtendedInfo()).getEnumSet().stream().map(yangEnum ->\"\\t\\t\\\"\"+ yangEnum.getNamedValue()+\"\\\"\").collect(Collectors.joining(\",\\n\\t\\t\")))\n                    .addLine(\"\\t}\").addLine(\");\").addLine(\"check();\")\n            );\n\n            javaClass.addMethod(new JavaMethod(\"setValue\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addParameter(\"String\",\"value\")\n                    .addLine(\"\\tsuper.setValue(value);\")\n                    .addLine(\"\\tcheck();\")\n            );\n            javaClass.addMethod(new JavaMethod(\"check\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addLine(\"\\tsuper.check();\")\n            );\n        }else if(typeInTypeDef.getDataType() == UINT8||typeInTypeDef.getDataType() == UINT16||typeInTypeDef.getDataType() == UINT32 ||typeInTypeDef.getDataType() == UINT64\n                ||typeInTypeDef.getDataType() == INT16||typeInTypeDef.getDataType() == INT32||typeInTypeDef.getDataType() == INT64){\n            String extend=null;\n            String type =null;\n            switch (typeInTypeDef.getDataType()){\n                case UINT8:\n                    extend= YangUInt8.class.getName();\n                    type =\"short\";\n                    break;\n                case INT16:\n                    extend= YangInt16.class.getName();\n                    type =\"short\";\n                    break;\n                case UINT16:\n                    extend= YangUInt16.class.getName();\n                    type =\"int\";\n                    break;\n                case INT32:\n                    extend= YangInt32.class.getName();\n                    type =\"int\";\n                    break;\n                case UINT32:\n                    extend= YangUInt32.class.getName();\n                    type =\"long\";\n                    break;\n                case INT64:\n                    extend= YangInt64.class.getName();\n                    type =\"long\";\n                    break;\n                case UINT64:\n                    extend= YangUInt64.class.getName();\n                    type =BigInteger.class.getName();\n                    break;\n            }\n            javaClass.setExtend(extend);\n            javaClass.addMethod(new JavaMethod(classname,\"\")\n                    .setModifiers(\"public\")\n                    .setExceptions(YangException.class.getName())\n                    .addParameter(\"String\",\"value\")\n                    .addLine(\"super(value);\")\n                    .addLine(\"check();\")\n            );\n            javaClass.addMethod(new JavaMethod(classname,\"\")\n                    .setModifiers(\"public\")\n                    .setExceptions(YangException.class.getName())\n                    .addParameter(type,\"value\")\n                    .addLine(\"super(value);\")\n                    .addLine(\"check();\")\n            );\n\n            javaClass.addMethod(new JavaMethod(\"setValue\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addParameter(\"String\",\"value\")\n                    .addLine(\"super.setValue(value);\")\n                    .addLine(\"check();\")\n            );\n            javaClass.addMethod(new JavaMethod(\"setValue\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addParameter(type,\"value\")\n                    .addLine(\"super.setValue(value);\")\n                    .addLine(\"check();\")\n            );\n            javaClass.addMethod(new JavaMethod(\"check\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addLine(\"super.check();\")\n            );\n        }else if(typeInTypeDef.getDataType() == UNION){\n            javaClass.setExtend(YangUnion.class.getName());\n\n            javaClass.addMethod(new JavaMethod(classname,\"\")\n                    .setModifiers(\"public\")\n                    .setExceptions(YangException.class.getName())\n                    .addParameter(\"String\",\"value\")\n                    .addLine(\"super(value,\").addLine(\"\\tnew String[] {\")\n\n                    .addLine(\n                            ((YangJavaUnion)((YangJavaType)this.getTypeList().get(0)).getDataTypeExtendedInfo()).getTypeList().stream()\n                                    .map( yangType -> \"\\\"\"+((YangJavaType)yangType).getJavaQualifiedInfo().getPkgInfo()+\".\"+ ((YangJavaType)yangType).getJavaQualifiedInfo().getClassInfo()+\"\\\"\").collect(Collectors.joining(\",\"))\n                    )\n                    .addLine(\"}\").addLine(\");\").addLine(\"check();\")\n            );\n\n            javaClass.addMethod(new JavaMethod(\"setValue\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addParameter(\"String\",\"value\")\n                    .addLine(\"super.setValue(value);\")\n                    .addLine(\"check();\")\n            );\n            javaClass.addMethod(new JavaMethod(\"check\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addLine(\"super.check();\")\n            );\n        }else if(typeInTypeDef.getDataType() == STRING ||typeInTypeDef.getDataType()==BINARY){\n\n            String extend=null;\n            switch (typeInTypeDef.getDataType()){\n                case STRING:\n                    extend= YangString.class.getName();\n                    break;\n                case BINARY:\n                    extend=YangBinary.class.getName();\n                    break;\n            }\n            javaClass.setExtend(extend);\n\n            javaClass.addMethod(new JavaMethod(classname,\"\")\n                    .setModifiers(\"public\")\n                    .setExceptions(YangException.class.getName())\n                    .addParameter(\"String\",\"value\")\n                    .addLine(\"super(value);\").addLine(\"check();\")\n            );\n\n            javaClass.addMethod(new JavaMethod(\"setValue\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addParameter(\"String\",\"value\")\n                    .addLine(\"super.setValue(value);\")\n                    .addLine(\"check();\")\n            );\n            javaClass.addMethod(new JavaMethod(\"check\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addLine(\"super.check();\")\n            );\n        }else if(typeInTypeDef.getDataType() == DERIVED){\n            JavaQualifiedTypeInfo javaQualifiedInfo = ((YangJavaTypeTranslator) this.getTypeList().get(0)).getJavaQualifiedInfo();\n            javaClass.setExtend(javaQualifiedInfo.getPkgInfo()+\".\"+javaQualifiedInfo.getClassInfo());\n            javaClass.addMethod(new JavaMethod(classname,\"\")\n                    .setModifiers(\"public\")\n                    .setExceptions(YangException.class.getName())\n                    .addParameter(\"String\",\"value\")\n                    .addLine(\"super(value);\").addLine(\"check();\")\n            );\n\n            javaClass.addMethod(new JavaMethod(\"setValue\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addParameter(\"String\",\"value\")\n                    .addLine(\"super.setValue(value);\")\n                    .addLine(\"check();\")\n            );\n            javaClass.addMethod(new JavaMethod(\"check\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addLine(\"super.check();\")\n            );\n        }else if(typeInTypeDef.getDataType() == BITS){\n            javaClass.setExtend(YangBits.class.getName());\n            Set<Map.Entry<Integer, YangBit>> entries = ((com.airlenet.yang.compiler.datamodel.YangBits) typeInTypeDef.getDataTypeExtendedInfo()).getBitPositionMap().entrySet();\n\n\n\n\n\n            javaClass.addMethod(new JavaMethod(classname,\"\")\n                    .setModifiers(\"public\")\n                    .setExceptions(YangException.class.getName())\n                    .addParameter(\"String\",\"value\")\n                    .addLine(\"super(value,\")\n                    .addLine(\"\\tnew java.math.BigInteger(\\\"\"+ entries.stream().map(entry->entry.getKey().intValue()).collect(Collectors.summarizingInt( position-> 1<<position)).getSum()+\"\\\"),\")\n                    .addLine(\"\\tnew String[] {\"+entries.stream().map(entry->\"\\\"\"+entry.getValue().getBitName()+\"\\\"\").collect(Collectors.joining(\",\"))+\" },\")\n                    .addLine(\"\\tnew int[] {\"+entries.stream().map(entry->entry.getKey().intValue()+\"\").collect(Collectors.joining(\",\"))+\" }\")\n                    .addLine(\");\")\n                    .addLine(\"check();\")\n            );\n\n            javaClass.addMethod(new JavaMethod(\"setValue\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addParameter(\"String\",\"value\")\n                    .addLine(\"super.setValue(value);\")\n                    .addLine(\"check();\")\n            );\n            javaClass.addMethod(new JavaMethod(\"setValue\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addParameter(BigInteger.class.getName(),\"value\")\n                    .addLine(\"super.setValue(value);\")\n                    .addLine(\"check();\")\n            );\n            javaClass.addMethod(new JavaMethod(\"check\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addLine(\"super.check();\")\n            );\n        }\n\n        try {\n            javaClass.write(absoluteDirPath);\n        } catch (IOException e) {\n            throw new TranslatorException(e);\n        }\n//        try {\n//            generateJava(GENERATE_TYPEDEF_CLASS, this);\n//        } catch (IOException e) {\n//            throw new TranslatorException(\n//                    \"Failed to prepare generate code for typedef node \" + getName()\n//                            + \" in \" + getLineNumber() +\n//                            \" at \" + getCharPosition() +\n//                            \" in \" + getFileName(), e);\n//        }\n    }\n}", "class_id": 0, "repo": "airlenet/yang-maven-plugin", "file": "yang-compiler/translator/src/main/java/com/airlenet/yang/compiler/translator/tojava/javamodel/YangJavaTypeDefTranslator.java", "last_update_at": "2020-08-18T06:19:33+00:00", "question_id": "c908faee48de2a277a57e3204bd8cf65bfee01be", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class YangJavaTypeDefTranslator\n        extends YangJavaTypeDef\n        implements JavaCodeGeneratorInfo, JavaCodeGenerator {\n    private static final long serialVersionUID = 806201620L;\n    /**\n     * File handle to maintain temporary java code fragments as per the code\n     * snippet types.\n     */\n    private transient TempJavaCodeFragmentFiles tempFileHandle;\n    /**\n     * Creates a YANG java typedef object.\n     */\n    public YangJavaTypeDefTranslator() {\n        super();\n        setJavaFileInfo(new JavaFileInfoTranslator());\n        getJavaFileInfo().setGeneratedFileTypes(GENERATE_TYPEDEF_CLASS);\n    }\n    /**\n     * Returns the generated java file information.\n     *\n     * @return generated java file information\n     */\n    @Override\n    public JavaFileInfoTranslator getJavaFileInfo() {\n        if (javaFileInfo == null) {\n            throw new TranslatorException(\"Missing java info in java datamodel node \" +\n                                                  getName() + \" in \" +\n                                                  getLineNumber() + \" at \" +\n                                                  getCharPosition()\n                                                  + \" in \" + getFileName());\n        }\n        return (JavaFileInfoTranslator) javaFileInfo;\n    }\n    /**\n     * Sets the java file info object.\n     *\n     * @param javaInfo java file info object\n     */\n    @Override\n    public void setJavaFileInfo(JavaFileInfoTranslator javaInfo) {\n        javaFileInfo = javaInfo;\n    }\n    /**\n     * Returns the temporary file handle.\n     *\n     * @return temporary file handle\n     */\n    @Override\n    public TempJavaCodeFragmentFiles getTempJavaCodeFragmentFiles() {\n        return tempFileHandle;\n    }\n    /**\n     * Sets temporary file handle.\n     *\n     * @param fileHandle temporary file handle\n     */\n    @Override\n    public void setTempJavaCodeFragmentFiles(TempJavaCodeFragmentFiles fileHandle) {\n        tempFileHandle = fileHandle;\n    }\n    /**\n     * Prepare the information for java code generation corresponding to YANG\n     * typedef info.\n     *\n     * @param yangPlugin YANG plugin config\n     * @throws TranslatorException when fails to translate\n     */\n    @Override\n    public void generateCodeEntry(YangPluginConfig yangPlugin) throws TranslatorException {\n        if (getReferredSchema() != null) {\n            throw new InvalidNodeForTranslatorException();\n        }\n        // TODO update the below exception in all related places, remove file\n        // name and other information.\n        YangType typeInTypeDef = this.getTypeDefBaseType();\n        InvalidNodeForTranslatorException exception = new InvalidNodeForTranslatorException();\n        exception.setFileName(this.getFileName());\n        exception.setCharPosition(this.getCharPosition());\n        exception.setLine(this.getLineNumber());\n        if (typeInTypeDef.getDataType() == DERIVED) {\n            YangDerivedInfo derivedInfo = (YangDerivedInfo) typeInTypeDef.getDataTypeExtendedInfo();\n            if (derivedInfo.getEffectiveBuiltInType() == LEAFREF) {\n                throw exception;\n            }\n        } else if (typeInTypeDef.getDataType() == LEAFREF) {\n            throw exception;\n        }\n        updateJNCPackageInfo(this,yangPlugin);\n        if(typeInTypeDef.getDataType() == DERIVED){\n            this.getTypeList().forEach(yangType -> {\n                ((YangJavaTypeTranslator)yangType).updateJavaQualifiedInfo(yangPlugin.getConflictResolver());\n            });\n        }\n        if(typeInTypeDef.getDataType() == BITS){\n            this.getTypeList().forEach(yangType -> {\n                ((YangJavaTypeTranslator)yangType).updateJavaQualifiedInfo(yangPlugin.getConflictResolver());\n            });\n        }\n        ((YangJavaTypeTranslator)typeInTypeDef).updateJavaQualifiedInfo(yangPlugin.getConflictResolver());\n//        try {\n//            generateCodeOfNode(this, yangPlugin);\n//        } catch (IOException e) {\n//            throw new TranslatorException(\n//                    \"Failed to prepare generate code entry for typedef node \" + getName()\n//                            + \" in \" + getLineNumber() +\n//                            \" at \" + getCharPosition() +\n//                            \" in \" + getFileName(), e);\n//        }\n    }\n    /**\n     * Create a java file using the YANG typedef info.\n     *\n     * @throws TranslatorException when fails to translate\n     */\n    @Override\n    public void generateCodeExit() throws TranslatorException {\n        String classname= YangElement.normalize(this.getName());\n        JavaFileInfoTranslator fileInfo = this.getJavaFileInfo();\n        JavaClass javaClass = new JavaClass(classname, fileInfo.getPackage(),\n                \"Code generated by \"+this.getClass().getSimpleName() +\n                        \"\\n * <p>\"+\n                        \"\\n * See line \"+fileInfo.getLineNumber()+\" in\" +\n                        \"\\n * \"+fileInfo.getYangFileName()+\n                        \"\\n * \"+\n                        \"\\n * @author Auto Generated\");\n        String absoluteDirPath = getAbsolutePackagePath(fileInfo.getBaseCodeGenPath(),\n                fileInfo.getPackageFilePath());\n//        YangJavaModule yangJavaModule = (YangJavaModule)this.getYangJavaModule();\n        YangType typeInTypeDef = this.getTypeDefBaseType();\n        if(typeInTypeDef.getDataType() == ENUMERATION){\n            javaClass.setExtend(YangEnumeration.class.getName());\n            javaClass.addMethod(new JavaMethod(classname,\"\")\n                    .setModifiers(\"public\")\n                    .setExceptions(YangException.class.getName())\n                    .addParameter(\"String\",\"value\")\n                    .addLine(\"super(value,\").addLine(\"\\tnew String[] {\")\n                    .addLine(((YangJavaEnumeration)this.getTypeList().get(0).getDataTypeExtendedInfo()).getEnumSet().stream().map(yangEnum ->\"\\t\\t\\\"\"+ yangEnum.getNamedValue()+\"\\\"\").collect(Collectors.joining(\",\\n\\t\\t\")))\n                    .addLine(\"\\t}\").addLine(\");\").addLine(\"check();\")\n            );\n            javaClass.addMethod(new JavaMethod(\"setValue\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addParameter(\"String\",\"value\")\n                    .addLine(\"\\tsuper.setValue(value);\")\n                    .addLine(\"\\tcheck();\")\n            );\n            javaClass.addMethod(new JavaMethod(\"check\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addLine(\"\\tsuper.check();\")\n            );\n        }else if(typeInTypeDef.getDataType() == UINT8||typeInTypeDef.getDataType() == UINT16||typeInTypeDef.getDataType() == UINT32 ||typeInTypeDef.getDataType() == UINT64\n                ||typeInTypeDef.getDataType() == INT16||typeInTypeDef.getDataType() == INT32||typeInTypeDef.getDataType() == INT64){\n            String extend=null;\n            String type =null;\n            switch (typeInTypeDef.getDataType()){\n                case UINT8:\n                    extend= YangUInt8.class.getName();\n                    type =\"short\";\n                    break;\n                case INT16:\n                    extend= YangInt16.class.getName();\n                    type =\"short\";\n                    break;\n                case UINT16:\n                    extend= YangUInt16.class.getName();\n                    type =\"int\";\n                    break;\n                case INT32:\n                    extend= YangInt32.class.getName();\n                    type =\"int\";\n                    break;\n                case UINT32:\n                    extend= YangUInt32.class.getName();\n                    type =\"long\";\n                    break;\n                case INT64:\n                    extend= YangInt64.class.getName();\n                    type =\"long\";\n                    break;\n                case UINT64:\n                    extend= YangUInt64.class.getName();\n                    type =BigInteger.class.getName();\n                    break;\n            }\n            javaClass.setExtend(extend);\n            javaClass.addMethod(new JavaMethod(classname,\"\")\n                    .setModifiers(\"public\")\n                    .setExceptions(YangException.class.getName())\n                    .addParameter(\"String\",\"value\")\n                    .addLine(\"super(value);\")\n                    .addLine(\"check();\")\n            );\n            javaClass.addMethod(new JavaMethod(classname,\"\")\n                    .setModifiers(\"public\")\n                    .setExceptions(YangException.class.getName())\n                    .addParameter(type,\"value\")\n                    .addLine(\"super(value);\")\n                    .addLine(\"check();\")\n            );\n            javaClass.addMethod(new JavaMethod(\"setValue\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addParameter(\"String\",\"value\")\n                    .addLine(\"super.setValue(value);\")\n                    .addLine(\"check();\")\n            );\n            javaClass.addMethod(new JavaMethod(\"setValue\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addParameter(type,\"value\")\n                    .addLine(\"super.setValue(value);\")\n                    .addLine(\"check();\")\n            );\n            javaClass.addMethod(new JavaMethod(\"check\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addLine(\"super.check();\")\n            );\n        }else if(typeInTypeDef.getDataType() == UNION){\n            javaClass.setExtend(YangUnion.class.getName());\n            javaClass.addMethod(new JavaMethod(classname,\"\")\n                    .setModifiers(\"public\")\n                    .setExceptions(YangException.class.getName())\n                    .addParameter(\"String\",\"value\")\n                    .addLine(\"super(value,\").addLine(\"\\tnew String[] {\")\n                    .addLine(\n                            ((YangJavaUnion)((YangJavaType)this.getTypeList().get(0)).getDataTypeExtendedInfo()).getTypeList().stream()\n                                    .map( yangType -> \"\\\"\"+((YangJavaType)yangType).getJavaQualifiedInfo().getPkgInfo()+\".\"+ ((YangJavaType)yangType).getJavaQualifiedInfo().getClassInfo()+\"\\\"\").collect(Collectors.joining(\",\"))\n                    )\n                    .addLine(\"}\").addLine(\");\").addLine(\"check();\")\n            );\n            javaClass.addMethod(new JavaMethod(\"setValue\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addParameter(\"String\",\"value\")\n                    .addLine(\"super.setValue(value);\")\n                    .addLine(\"check();\")\n            );\n            javaClass.addMethod(new JavaMethod(\"check\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addLine(\"super.check();\")\n            );\n        }else if(typeInTypeDef.getDataType() == STRING ||typeInTypeDef.getDataType()==BINARY){\n            String extend=null;\n            switch (typeInTypeDef.getDataType()){\n                case STRING:\n                    extend= YangString.class.getName();\n                    break;\n                case BINARY:\n                    extend=YangBinary.class.getName();\n                    break;\n            }\n            javaClass.setExtend(extend);\n            javaClass.addMethod(new JavaMethod(classname,\"\")\n                    .setModifiers(\"public\")\n                    .setExceptions(YangException.class.getName())\n                    .addParameter(\"String\",\"value\")\n                    .addLine(\"super(value);\").addLine(\"check();\")\n            );\n            javaClass.addMethod(new JavaMethod(\"setValue\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addParameter(\"String\",\"value\")\n                    .addLine(\"super.setValue(value);\")\n                    .addLine(\"check();\")\n            );\n            javaClass.addMethod(new JavaMethod(\"check\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addLine(\"super.check();\")\n            );\n        }else if(typeInTypeDef.getDataType() == DERIVED){\n            JavaQualifiedTypeInfo javaQualifiedInfo = ((YangJavaTypeTranslator) this.getTypeList().get(0)).getJavaQualifiedInfo();\n            javaClass.setExtend(javaQualifiedInfo.getPkgInfo()+\".\"+javaQualifiedInfo.getClassInfo());\n            javaClass.addMethod(new JavaMethod(classname,\"\")\n                    .setModifiers(\"public\")\n                    .setExceptions(YangException.class.getName())\n                    .addParameter(\"String\",\"value\")\n                    .addLine(\"super(value);\").addLine(\"check();\")\n            );\n            javaClass.addMethod(new JavaMethod(\"setValue\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addParameter(\"String\",\"value\")\n                    .addLine(\"super.setValue(value);\")\n                    .addLine(\"check();\")\n            );\n            javaClass.addMethod(new JavaMethod(\"check\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addLine(\"super.check();\")\n            );\n        }else if(typeInTypeDef.getDataType() == BITS){\n            javaClass.setExtend(YangBits.class.getName());\n            Set<Map.Entry<Integer, YangBit>> entries = ((com.airlenet.yang.compiler.datamodel.YangBits) typeInTypeDef.getDataTypeExtendedInfo()).getBitPositionMap().entrySet();\n            javaClass.addMethod(new JavaMethod(classname,\"\")\n                    .setModifiers(\"public\")\n                    .setExceptions(YangException.class.getName())\n                    .addParameter(\"String\",\"value\")\n                    .addLine(\"super(value,\")\n                    .addLine(\"\\tnew java.math.BigInteger(\\\"\"+ entries.stream().map(entry->entry.getKey().intValue()).collect(Collectors.summarizingInt( position-> 1<<position)).getSum()+\"\\\"),\")\n                    .addLine(\"\\tnew String[] {\"+entries.stream().map(entry->\"\\\"\"+entry.getValue().getBitName()+\"\\\"\").collect(Collectors.joining(\",\"))+\" },\")\n                    .addLine(\"\\tnew int[] {\"+entries.stream().map(entry->entry.getKey().intValue()+\"\").collect(Collectors.joining(\",\"))+\" }\")\n                    .addLine(\");\")\n                    .addLine(\"check();\")\n            );\n            javaClass.addMethod(new JavaMethod(\"setValue\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addParameter(\"String\",\"value\")\n                    .addLine(\"super.setValue(value);\")\n                    .addLine(\"check();\")\n            );\n            javaClass.addMethod(new JavaMethod(\"setValue\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addParameter(BigInteger.class.getName(),\"value\")\n                    .addLine(\"super.setValue(value);\")\n                    .addLine(\"check();\")\n            );\n            javaClass.addMethod(new JavaMethod(\"check\",\"void\").setModifiers(\"public\").setExceptions(YangException.class.getName())\n                    .addLine(\"super.check();\")\n            );\n        }\n        try {\n            javaClass.write(absoluteDirPath);\n        } catch (IOException e) {\n            throw new TranslatorException(e);\n        }\n//        try {\n//            generateJava(GENERATE_TYPEDEF_CLASS, this);\n//        } catch (IOException e) {\n//            throw new TranslatorException(\n//                    \"Failed to prepare generate code for typedef node \" + getName()\n//                            + \" in \" + getLineNumber() +\n//                            \" at \" + getCharPosition() +\n//                            \" in \" + getFileName(), e);\n//        }\n    }\n"]]}
{"hexsha": "e37b6cadd228f4d4f6e8eeffd9c481d78a138217", "ext": "java", "lang": "Java", "content": "class Allure2PluginTest {\n\n    private Path directory;\n\n    @BeforeEach\n    void setUp(@TempDir final Path directory) {\n        this.directory = directory;\n    }\n\n    @Test\n    void shouldReadBeforesFromGroups() throws Exception {\n        Set<TestResult> testResults = process(\n                \"allure2/simple-testcase.json\", generateTestResultName(),\n                \"allure2/first-testgroup.json\", generateTestResultContainerName(),\n                \"allure2/second-testgroup.json\", generateTestResultContainerName()\n        ).getResults();\n\n        assertThat(testResults)\n                .hasSize(1)\n                .flatExtracting(TestResult::getBeforeStages)\n                .hasSize(2)\n                .extracting(StageResult::getName)\n                .containsExactlyInAnyOrder(\"mockAuthorization\", \"loadTestConfiguration\");\n    }\n\n    @Test\n    void shouldReadAftersFromGroups() throws Exception {\n        Set<TestResult> testResults = process(\n                \"allure2/simple-testcase.json\", generateTestResultName(),\n                \"allure2/first-testgroup.json\", generateTestResultContainerName(),\n                \"allure2/second-testgroup.json\", generateTestResultContainerName()\n        ).getResults();\n\n        assertThat(testResults)\n                .hasSize(1)\n                .flatExtracting(TestResult::getAfterStages)\n                .hasSize(2)\n                .extracting(StageResult::getName)\n                .containsExactlyInAnyOrder(\"unloadTestConfiguration\", \"cleanUpContext\");\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    void shouldExcludeDuplicatedParams() throws Exception {\n        Set<TestResult> testResults = process(\n                \"allure2/duplicated-params.json\", generateTestResultName()\n        ).getResults();\n\n        assertThat(testResults)\n                .flatExtracting(TestResult::getParameters)\n                .extracting(Parameter::getName, Parameter::getValue)\n                .containsExactlyInAnyOrder(\n                        tuple(\"name\", \"value\"),\n                        tuple(\"name2\", \"value\"),\n                        tuple(\"name\", \"value2\"),\n                        tuple(\"name2\", \"value2\")\n                );\n    }\n\n    @Test\n    void shouldPickUpAttachmentsForTestCase() throws IOException {\n        Set<TestResult> testResults = process(\n                \"allure2/simple-testcase.json\", generateTestResultName(),\n                \"allure2/first-testgroup.json\", generateTestResultContainerName(),\n                \"allure2/second-testgroup.json\", generateTestResultContainerName(),\n                \"allure2/test-sample-attachment.txt\", \"test-sample-attachment.txt\"\n        ).getResults();\n\n        assertThat(testResults)\n                .describedAs(\"Test case is not found\")\n                .hasSize(1)\n                .extracting(TestResult::getTestStage)\n                .flatExtracting(StageResult::getSteps)\n                .describedAs(\"Test case should have one step\")\n                .hasSize(1)\n                .flatExtracting(Step::getAttachments)\n                .describedAs(\"Step should have an attachment\")\n                .hasSize(1)\n                .extracting(Attachment::getName)\n                .containsExactly(\"String attachment in test\");\n    }\n\n    @Test\n    void shouldPickUpAttachmentsForAfters() throws IOException {\n        Set<TestResult> testResults = process(\n                \"allure2/simple-testcase.json\", generateTestResultName(),\n                \"allure2/first-testgroup.json\", generateTestResultContainerName(),\n                \"allure2/second-testgroup.json\", generateTestResultContainerName(),\n                \"allure2/after-sample-attachment.txt\", \"after-sample-attachment.txt\"\n        ).getResults();\n\n        assertThat(testResults)\n                .describedAs(\"Test case is not found\")\n                .hasSize(1)\n                .flatExtracting(TestResult::getAfterStages)\n                .describedAs(\"Test case should have afters\")\n                .hasSize(2)\n                .flatExtracting(StageResult::getAttachments)\n                .describedAs(\"Second after method should have an attachment\")\n                .hasSize(1)\n                .extracting(Attachment::getName)\n                .describedAs(\"Attachment's name is unexpected\")\n                .containsExactly(\"String attachment in after\");\n    }\n\n    @Test\n    void shouldDoNotOverrideAttachmentsForGroups() throws IOException {\n        Set<TestResult> testResults = process(\n                \"allure2/other-testcase.json\", generateTestResultName(),\n                \"allure2/other-testcase.json\", generateTestResultName(),\n                \"allure2/second-testgroup.json\", generateTestResultContainerName(),\n                \"allure2/after-sample-attachment.txt\", \"after-sample-attachment.txt\"\n        ).getResults();\n\n        assertThat(testResults)\n                .describedAs(\"Test cases is not found\")\n                .hasSize(2);\n\n        testResults.forEach(testResult -> assertThat(testResult.getAfterStages())\n                .hasSize(1)\n                .flatExtracting(StageResult::getAttachments)\n                .hasSize(1)\n                .extracting(Attachment::getName)\n                .containsExactly(\"String attachment in after\"));\n\n    }\n\n    @Test\n    void shouldProcessEmptyStatus() throws Exception {\n        Set<TestResult> testResults = process(\n                \"allure2/no-status.json\", generateTestResultName()\n        ).getResults();\n\n        assertThat(testResults)\n                .hasSize(1)\n                .extracting(TestResult::getStatus)\n                .containsExactly(UNKNOWN);\n    }\n\n    @Test\n    void shouldProcessNullStatus() throws Exception {\n        Set<TestResult> testResults = process(\n                \"allure2/null-status.json\", generateTestResultName()\n        ).getResults();\n\n        assertThat(testResults)\n                .hasSize(1)\n                .extracting(TestResult::getStatus)\n                .containsExactly(UNKNOWN);\n    }\n\n    @Test\n    void shouldProcessInvalidStatus() throws Exception {\n        Set<TestResult> testResults = process(\n                \"allure2/invalid-status.json\", generateTestResultName()\n        ).getResults();\n\n        assertThat(testResults)\n                .hasSize(1)\n                .extracting(TestResult::getStatus)\n                .containsExactly(UNKNOWN);\n    }\n\n    @Test\n    void shouldProcessNullStageTime() throws Exception {\n        Set<TestResult> testResults = process(\n                \"allure2/other-testcase.json\", generateTestResultName(),\n                \"allure2/null-before-group.json\", generateTestResultContainerName()\n        ).getResults();\n\n        assertThat(testResults)\n                .hasSize(1);\n    }\n\n    @Test\n    void shouldAddTestResultFormatLabel() throws Exception {\n        Set<TestResult> testResults = process(\n                \"allure2/simple-testcase.json\", generateTestResultName(),\n                \"allure2/first-testgroup.json\", generateTestResultContainerName(),\n                \"allure2/second-testgroup.json\", generateTestResultContainerName()\n        ).getResults();\n\n        assertThat(testResults)\n                .extracting(result -> result.findOneLabel(LabelName.RESULT_FORMAT))\n                .extracting(Optional::get)\n                .containsOnly(Allure2Plugin.ALLURE2_RESULTS_FORMAT);\n    }\n\n    private LaunchResults process(String... strings) throws IOException {\n        Iterator<String> iterator = Arrays.asList(strings).iterator();\n        while (iterator.hasNext()) {\n            String first = iterator.next();\n            String second = iterator.next();\n            copyFile(directory, first, second);\n        }\n        Allure2Plugin reader = new Allure2Plugin();\n        final Configuration configuration = new ConfigurationBuilder().useDefault().build();\n        final DefaultResultsVisitor resultsVisitor = new DefaultResultsVisitor(configuration);\n        reader.readResults(configuration, resultsVisitor, directory);\n        return resultsVisitor.getLaunchResults();\n    }\n\n    private void copyFile(Path dir, String resourceName, String fileName) throws IOException {\n        try (InputStream is = getClass().getClassLoader().getResourceAsStream(resourceName)) {\n            Files.copy(Objects.requireNonNull(is), dir.resolve(fileName));\n        }\n    }\n}", "class_id": 0, "repo": "simple-elf/allure2", "file": "allure-generator/src/test/java/io/qameta/allure/allure2/Allure2PluginTest.java", "last_update_at": "2020-01-02T03:06:44+00:00", "question_id": "e37b6cadd228f4d4f6e8eeffd9c481d78a138217", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Allure2PluginTest {\n    private Path directory;\n    @BeforeEach\n    void setUp(@TempDir final Path directory) {\n        this.directory = directory;\n    }\n    @Test\n    void shouldReadBeforesFromGroups() throws Exception {\n        Set<TestResult> testResults = process(\n                \"allure2/simple-testcase.json\", generateTestResultName(),\n                \"allure2/first-testgroup.json\", generateTestResultContainerName(),\n                \"allure2/second-testgroup.json\", generateTestResultContainerName()\n        ).getResults();\n        assertThat(testResults)\n                .hasSize(1)\n                .flatExtracting(TestResult::getBeforeStages)\n                .hasSize(2)\n                .extracting(StageResult::getName)\n                .containsExactlyInAnyOrder(\"mockAuthorization\", \"loadTestConfiguration\");\n    }\n    @Test\n    void shouldReadAftersFromGroups() throws Exception {\n        Set<TestResult> testResults = process(\n                \"allure2/simple-testcase.json\", generateTestResultName(),\n                \"allure2/first-testgroup.json\", generateTestResultContainerName(),\n                \"allure2/second-testgroup.json\", generateTestResultContainerName()\n        ).getResults();\n        assertThat(testResults)\n                .hasSize(1)\n                .flatExtracting(TestResult::getAfterStages)\n                .hasSize(2)\n                .extracting(StageResult::getName)\n                .containsExactlyInAnyOrder(\"unloadTestConfiguration\", \"cleanUpContext\");\n    }\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    void shouldExcludeDuplicatedParams() throws Exception {\n        Set<TestResult> testResults = process(\n                \"allure2/duplicated-params.json\", generateTestResultName()\n        ).getResults();\n        assertThat(testResults)\n                .flatExtracting(TestResult::getParameters)\n                .extracting(Parameter::getName, Parameter::getValue)\n                .containsExactlyInAnyOrder(\n                        tuple(\"name\", \"value\"),\n                        tuple(\"name2\", \"value\"),\n                        tuple(\"name\", \"value2\"),\n                        tuple(\"name2\", \"value2\")\n                );\n    }\n    @Test\n    void shouldPickUpAttachmentsForTestCase() throws IOException {\n        Set<TestResult> testResults = process(\n                \"allure2/simple-testcase.json\", generateTestResultName(),\n                \"allure2/first-testgroup.json\", generateTestResultContainerName(),\n                \"allure2/second-testgroup.json\", generateTestResultContainerName(),\n                \"allure2/test-sample-attachment.txt\", \"test-sample-attachment.txt\"\n        ).getResults();\n        assertThat(testResults)\n                .describedAs(\"Test case is not found\")\n                .hasSize(1)\n                .extracting(TestResult::getTestStage)\n                .flatExtracting(StageResult::getSteps)\n                .describedAs(\"Test case should have one step\")\n                .hasSize(1)\n                .flatExtracting(Step::getAttachments)\n                .describedAs(\"Step should have an attachment\")\n                .hasSize(1)\n                .extracting(Attachment::getName)\n                .containsExactly(\"String attachment in test\");\n    }\n    @Test\n    void shouldPickUpAttachmentsForAfters() throws IOException {\n        Set<TestResult> testResults = process(\n                \"allure2/simple-testcase.json\", generateTestResultName(),\n                \"allure2/first-testgroup.json\", generateTestResultContainerName(),\n                \"allure2/second-testgroup.json\", generateTestResultContainerName(),\n                \"allure2/after-sample-attachment.txt\", \"after-sample-attachment.txt\"\n        ).getResults();\n        assertThat(testResults)\n                .describedAs(\"Test case is not found\")\n                .hasSize(1)\n                .flatExtracting(TestResult::getAfterStages)\n                .describedAs(\"Test case should have afters\")\n                .hasSize(2)\n                .flatExtracting(StageResult::getAttachments)\n                .describedAs(\"Second after method should have an attachment\")\n                .hasSize(1)\n                .extracting(Attachment::getName)\n                .describedAs(\"Attachment's name is unexpected\")\n                .containsExactly(\"String attachment in after\");\n    }\n    @Test\n    void shouldDoNotOverrideAttachmentsForGroups() throws IOException {\n        Set<TestResult> testResults = process(\n                \"allure2/other-testcase.json\", generateTestResultName(),\n                \"allure2/other-testcase.json\", generateTestResultName(),\n                \"allure2/second-testgroup.json\", generateTestResultContainerName(),\n                \"allure2/after-sample-attachment.txt\", \"after-sample-attachment.txt\"\n        ).getResults();\n        assertThat(testResults)\n                .describedAs(\"Test cases is not found\")\n                .hasSize(2);\n        testResults.forEach(testResult -> assertThat(testResult.getAfterStages())\n                .hasSize(1)\n                .flatExtracting(StageResult::getAttachments)\n                .hasSize(1)\n                .extracting(Attachment::getName)\n                .containsExactly(\"String attachment in after\"));\n    }\n    @Test\n    void shouldProcessEmptyStatus() throws Exception {\n        Set<TestResult> testResults = process(\n                \"allure2/no-status.json\", generateTestResultName()\n        ).getResults();\n        assertThat(testResults)\n                .hasSize(1)\n                .extracting(TestResult::getStatus)\n                .containsExactly(UNKNOWN);\n    }\n    @Test\n    void shouldProcessNullStatus() throws Exception {\n        Set<TestResult> testResults = process(\n                \"allure2/null-status.json\", generateTestResultName()\n        ).getResults();\n        assertThat(testResults)\n                .hasSize(1)\n                .extracting(TestResult::getStatus)\n                .containsExactly(UNKNOWN);\n    }\n    @Test\n    void shouldProcessInvalidStatus() throws Exception {\n        Set<TestResult> testResults = process(\n                \"allure2/invalid-status.json\", generateTestResultName()\n        ).getResults();\n        assertThat(testResults)\n                .hasSize(1)\n                .extracting(TestResult::getStatus)\n                .containsExactly(UNKNOWN);\n    }\n    @Test\n    void shouldProcessNullStageTime() throws Exception {\n        Set<TestResult> testResults = process(\n                \"allure2/other-testcase.json\", generateTestResultName(),\n                \"allure2/null-before-group.json\", generateTestResultContainerName()\n        ).getResults();\n        assertThat(testResults)\n                .hasSize(1);\n    }\n    @Test\n    void shouldAddTestResultFormatLabel() throws Exception {\n        Set<TestResult> testResults = process(\n                \"allure2/simple-testcase.json\", generateTestResultName(),\n                \"allure2/first-testgroup.json\", generateTestResultContainerName(),\n                \"allure2/second-testgroup.json\", generateTestResultContainerName()\n        ).getResults();\n        assertThat(testResults)\n                .extracting(result -> result.findOneLabel(LabelName.RESULT_FORMAT))\n                .extracting(Optional::get)\n                .containsOnly(Allure2Plugin.ALLURE2_RESULTS_FORMAT);\n    }\n    private LaunchResults process(String... strings) throws IOException {\n        Iterator<String> iterator = Arrays.asList(strings).iterator();\n        while (iterator.hasNext()) {\n            String first = iterator.next();\n            String second = iterator.next();\n            copyFile(directory, first, second);\n        }\n        Allure2Plugin reader = new Allure2Plugin();\n        final Configuration configuration = new ConfigurationBuilder().useDefault().build();\n        final DefaultResultsVisitor resultsVisitor = new DefaultResultsVisitor(configuration);\n        reader.readResults(configuration, resultsVisitor, directory);\n        return resultsVisitor.getLaunchResults();\n    }\n    private void copyFile(Path dir, String resourceName, String fileName) throws IOException {\n        try (InputStream is = getClass().getClassLoader().getResourceAsStream(resourceName)) {\n            Files.copy(Objects.requireNonNull(is), dir.resolve(fileName));\n        }\n    }\n"]]}
{"hexsha": "320befaa222b43e1ef85c42ad5f22ef93ab2a7c8", "ext": "java", "lang": "Java", "content": "public final class ExpressionAliases\n{\n    private final Multimap<String, Expression> map;\n\n    public ExpressionAliases()\n    {\n        this.map = ArrayListMultimap.create();\n    }\n\n    public ExpressionAliases(ExpressionAliases expressionAliases)\n    {\n        requireNonNull(expressionAliases, \"symbolAliases are null\");\n        this.map = ArrayListMultimap.create(expressionAliases.map);\n    }\n\n    public void put(String alias, Expression expression)\n    {\n        alias = alias(alias);\n        if (map.containsKey(alias)) {\n            checkState(map.get(alias).contains(expression), \"Alias '%s' points to different expression '%s' and '%s'\", alias, expression, map.get(alias));\n        }\n        else {\n            checkState(!map.values().contains(expression), \"Expression '%s' is already pointed by different alias than '%s', check mapping for '%s'\", expression, alias, map);\n            map.put(alias, expression);\n        }\n    }\n\n    private static String alias(String alias)\n    {\n        return alias.toLowerCase().replace(\"(\", \"\").replace(\")\", \"\").replace(\"\\\"\", \"\");\n    }\n\n    public void updateAssignments(Map<Symbol, Expression> assignments)\n    {\n        ImmutableMultimap.Builder<String, Expression> mapUpdate = ImmutableMultimap.builder();\n        for (Map.Entry<Symbol, Expression> assignment : assignments.entrySet()) {\n            for (String alias : map.keys()) {\n                if (map.get(alias).contains(assignment.getKey().toSymbolReference())) {\n                    mapUpdate.put(alias, assignment.getValue());\n                }\n            }\n        }\n        map.putAll(mapUpdate.build());\n    }\n}", "class_id": 0, "repo": "ruipoliveira/presto", "file": "presto-main/src/test/java/com/facebook/presto/sql/planner/assertions/ExpressionAliases.java", "last_update_at": "2020-12-28T13:25:15+00:00", "question_id": "320befaa222b43e1ef85c42ad5f22ef93ab2a7c8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class ExpressionAliases\n{\n    private final Multimap<String, Expression> map;\n    public ExpressionAliases()\n    {\n        this.map = ArrayListMultimap.create();\n    }\n    public ExpressionAliases(ExpressionAliases expressionAliases)\n    {\n        requireNonNull(expressionAliases, \"symbolAliases are null\");\n        this.map = ArrayListMultimap.create(expressionAliases.map);\n    }\n    public void put(String alias, Expression expression)\n    {\n        alias = alias(alias);\n        if (map.containsKey(alias)) {\n            checkState(map.get(alias).contains(expression), \"Alias '%s' points to different expression '%s' and '%s'\", alias, expression, map.get(alias));\n        }\n        else {\n            checkState(!map.values().contains(expression), \"Expression '%s' is already pointed by different alias than '%s', check mapping for '%s'\", expression, alias, map);\n            map.put(alias, expression);\n        }\n    }\n    private static String alias(String alias)\n    {\n        return alias.toLowerCase().replace(\"(\", \"\").replace(\")\", \"\").replace(\"\\\"\", \"\");\n    }\n    public void updateAssignments(Map<Symbol, Expression> assignments)\n    {\n        ImmutableMultimap.Builder<String, Expression> mapUpdate = ImmutableMultimap.builder();\n        for (Map.Entry<Symbol, Expression> assignment : assignments.entrySet()) {\n            for (String alias : map.keys()) {\n                if (map.get(alias).contains(assignment.getKey().toSymbolReference())) {\n                    mapUpdate.put(alias, assignment.getValue());\n                }\n            }\n        }\n        map.putAll(mapUpdate.build());\n    }\n"]]}
{"hexsha": "5b97ddb89ab8e0b0cf15f57d8403bebc64ef24cb", "ext": "java", "lang": "Java", "content": "@Named\n@ViewScoped\npublic class HelloBean implements Serializable {\n\n\t/**\n\t *\n\t */\n\tprivate static final long serialVersionUID = 1L;\n\n\t@Inject\n\tprivate TesteService service;\n\n\t@Inject\n\tprivate FacesContext context;\n\n\tprivate Map<String, String> mapaCursos;\n\tprivate Map<String, String> mapaLivros;\n\n\tpublic String testeInjectServico() {\n\t\treturn service.getStringTeste();\n\t}\n\n\tpublic String testeInjectContexto() {\n\t\treturn context.toString();\n\t}\n\n\tpublic Map<String, String> getMapaLivros() {\n\t\tmapaLivros = new HashMap<String, String>();\n\t\tmapaLivros.put(\"Livro 1\", \"Effective Java Third Edition\");\n\t\tmapaLivros.put(\"Livro 2\", \"Google Android\");\n\t\tmapaLivros.put(\"Livro 3\", \"Matering JPA\");\n\t\tmapaLivros.put(\"Livro 4\", \"Pro Git\");\n\n\t\treturn mapaLivros;\n\t}\n\n\tpublic void setMapaLivros(Map<String, String> mapaLivros) {\n\t\tthis.mapaLivros = mapaLivros;\n\t}\n\n\tpublic Map<String, String> getMapaCursos() {\n\n\t\tmapaCursos = new HashMap<String, String>();\n\t\tmapaCursos.put(\"Curso 1\", \"Orienta\u00e7\u00e3o a objeto com Java\");\n\t\tmapaCursos.put(\"Curso 2\", \"API Rest com Spring Boot\");\n\t\tmapaCursos.put(\"Curso 3\", \"Java Web com JSF e Primefaces\");\n\t\tmapaCursos.put(\"Curso 4\", \"Git passao a passo\");\n\n\t\treturn mapaCursos;\n\t}\n\n\tpublic void setMapaCursos(Map<String, String> mapaCursos) {\n\t\tthis.mapaCursos = mapaCursos;\n\t}\n\n}", "class_id": 0, "repo": "rmnresende/exemplo-jsf23-cdi-20-tomcat", "file": "src/main/java/br/com/dynamicdev/beans/HelloBean.java", "last_update_at": "2020-12-18T01:50:17+00:00", "question_id": "5b97ddb89ab8e0b0cf15f57d8403bebc64ef24cb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Named\n@ViewScoped\npublic class HelloBean implements Serializable {\n\t/**\n\t *\n\t */\n\tprivate static final long serialVersionUID = 1L;\n\t@Inject\n\tprivate TesteService service;\n\t@Inject\n\tprivate FacesContext context;\n\tprivate Map<String, String> mapaCursos;\n\tprivate Map<String, String> mapaLivros;\n\tpublic String testeInjectServico() {\n\t\treturn service.getStringTeste();\n\t}\n\tpublic String testeInjectContexto() {\n\t\treturn context.toString();\n\t}\n\tpublic Map<String, String> getMapaLivros() {\n\t\tmapaLivros = new HashMap<String, String>();\n\t\tmapaLivros.put(\"Livro 1\", \"Effective Java Third Edition\");\n\t\tmapaLivros.put(\"Livro 2\", \"Google Android\");\n\t\tmapaLivros.put(\"Livro 3\", \"Matering JPA\");\n\t\tmapaLivros.put(\"Livro 4\", \"Pro Git\");\n\t\treturn mapaLivros;\n\t}\n\tpublic void setMapaLivros(Map<String, String> mapaLivros) {\n\t\tthis.mapaLivros = mapaLivros;\n\t}\n\tpublic Map<String, String> getMapaCursos() {\n\t\tmapaCursos = new HashMap<String, String>();\n\t\tmapaCursos.put(\"Curso 1\", \"Orienta\u00e7\u00e3o a objeto com Java\");\n\t\tmapaCursos.put(\"Curso 2\", \"API Rest com Spring Boot\");\n\t\tmapaCursos.put(\"Curso 3\", \"Java Web com JSF e Primefaces\");\n\t\tmapaCursos.put(\"Curso 4\", \"Git passao a passo\");\n\t\treturn mapaCursos;\n\t}\n\tpublic void setMapaCursos(Map<String, String> mapaCursos) {\n\t\tthis.mapaCursos = mapaCursos;\n\t}\n"]]}
{"hexsha": "5488ea67e067453a405e5896520d1af5d8a288be", "ext": "java", "lang": "Java", "content": "public class AstralBlockLootTables extends BlockLootTables {\n\n    @Override\n    protected void addTables() {\n        registerLootTable(REDBULB.get(), onlyWithSilkTouchOrShears(REDBULB.get()));\n        registerLootTable(CYANGRASS.get(), onlyWithSilkTouchOrShears(CYANGRASS.get()));\n        registerLootTable(GENTLEGRASS.get(), onlyWithSilkTouchOrShears(GENTLEGRASS.get()));\n        registerLootTable(WILDWEED.get(), onlyWithSilkTouchOrShears(WILDWEED.get()));\n        registerLootTable(TALL_REDBULB.get(), onlyWithSilkTouchOrShears(TALL_REDBULB.get()));\n        registerLootTable(TALL_CYANGRASS.get(), onlyWithSilkTouchOrShears(TALL_CYANGRASS.get()));\n        registerLootTable(TALL_GENTLEGRASS.get(), onlyWithSilkTouchOrShears(TALL_GENTLEGRASS.get()));\n        registerLootTable(TALL_WILDWEED.get(), onlyWithSilkTouchOrShears(TALL_WILDWEED.get()));\n        registerLootTable(BLUECAP_MUSHROOM.get(), dropping(BLUECAP_MUSHROOM.get()));\n        registerLootTable(RUSTCAP_MUSHROOM.get(), dropping(RUSTCAP_MUSHROOM.get()));\n        registerLootTable(ETHEREAL_PLANKS.get(), dropping(ETHEREAL_PLANKS.get()));\n        registerLootTable(ETHEREAL_TRAPDOOR.get(), dropping(ETHEREAL_TRAPDOOR.get()));\n        registerLootTable(ETHEREAL_DOOR.get(), dropping(ETHEREAL_DOOR.get()));\n        registerLootTable(COMFORTABLE_CUSHION.get(), dropping(COMFORTABLE_CUSHION.get()));\n        registerLootTable(ETHEREAL_SAPLING.get(), dropping(ETHEREAL_SAPLING.get()));\n        registerLootTable(CRYSTAL_WEB.get(), droppingWithSilkTouchOrShearsTag(CRYSTAL_WEB.get(), ItemLootEntry.builder(AstralItems.DREAMCORD.get())));\n        this.registerLootTable(SNOWBERRY_BUSH.get(), new LootTable.Builder()\n                .addLootPool(new LootPool.Builder()\n                        .name(\"ripe\")\n                        .addEntry(ItemLootEntry.builder(AstralItems.SNOWBERRY.get()))\n                        .acceptCondition(BlockStateProperty.builder(SNOWBERRY_BUSH.get())\n                                .fromProperties(StatePropertiesPredicate.Builder.newBuilder().withIntProp(SweetBerryBushBlock.AGE, 3)))\n                        .acceptFunction(SetCount.builder(RandomValueRange.of(2, 3)))\n                        .acceptFunction(ApplyBonus.uniformBonusCount(Enchantments.FORTUNE, 1)))\n                .addLootPool(new LootPool.Builder()\n                        .name(\"unripe\")\n                        .addEntry(ItemLootEntry.builder(AstralItems.SNOWBERRY.get()))\n                        .acceptCondition(BlockStateProperty.builder(SNOWBERRY_BUSH.get())\n                                .fromProperties(StatePropertiesPredicate.Builder.newBuilder().withIntProp(SweetBerryBushBlock.AGE, 2)))\n                        .acceptFunction(SetCount.builder(RandomValueRange.of(1, 2)))\n                        .acceptFunction(ApplyBonus.uniformBonusCount(Enchantments.FORTUNE, 1)))\n                .addLootPool(new LootPool.Builder()\n                        .name(\"not_grown\")\n                        .addEntry(ItemLootEntry.builder(AstralItems.SNOWBERRY.get()))\n                        .acceptCondition(BlockStateProperty.builder(SNOWBERRY_BUSH.get())\n                                .fromProperties(StatePropertiesPredicate.Builder.newBuilder().withIntProp(SweetBerryBushBlock.AGE, 1)))\n                        .acceptFunction(SetCount.builder(RandomValueRange.of(1, 1)))\n                        .acceptFunction(ApplyBonus.uniformBonusCount(Enchantments.FORTUNE, 1)))\n                .addLootPool(new LootPool.Builder()\n                        .name(\"planted\")\n                        .addEntry(ItemLootEntry.builder(AstralItems.SNOWBERRY.get()))\n                        .acceptCondition(BlockStateProperty.builder(SNOWBERRY_BUSH.get())\n                                .fromProperties(StatePropertiesPredicate.Builder.newBuilder().withIntProp(SweetBerryBushBlock.AGE, 0)))\n                        .acceptFunction(SetCount.builder(RandomValueRange.of(1, 1)))\n                        .acceptFunction(ApplyBonus.uniformBonusCount(Enchantments.FORTUNE, 1)))\n                .acceptFunction(ExplosionDecay.builder())\n        );\n        registerLootTable(FEVERWEED_BLOCK.get(), dropping(FEVERWEED_BLOCK.get()));\n        registerLootTable(OFFERING_BRAZIER.get(), dropping(OFFERING_BRAZIER.get()));\n        registerLootTable(ETHER_DIRT.get(), dropping(ETHER_DIRT.get()));\n        registerLootTable(ETHER_GRASS.get(), droppingWithSilkTouch(ETHER_GRASS.get(), ETHER_DIRT.get()));\n        registerLootTable(ETHEREAL_SAPLING.get(), dropping(ETHEREAL_SAPLING.get()));\n        registerLootTable(ETHEREAL_DOOR.get(), dropping(ETHEREAL_DOOR.get()));\n        registerLootTable(ETHEREAL_TRAPDOOR.get(), dropping(ETHEREAL_TRAPDOOR.get()));\n        registerLootTable(ETHEREAL_LOG.get(), dropping(ETHEREAL_LOG.get()));\n        registerLootTable(ETHEREAL_LEAVES.get(), new LootTable.Builder()\n                .addLootPool(new LootPool.Builder()\n                        .rolls(ConstantRange.of(1))\n                        .addEntry(AlternativesLootEntry.builder(ItemLootEntry.builder(ETHEREAL_LEAVES.get())\n                                        .acceptCondition(Constants.SILK_TOUCH_OR_SHEARS),\n                                ItemLootEntry.builder(AstralItems.ETHEREAL_SAPLING_ITEM.get())\n                                        .acceptCondition(SurvivesExplosion.builder())\n                                        .acceptCondition(TableBonus.builder(Enchantments.FORTUNE, .05f, .0625f, 0.083333336f, 0.1f)))))\n                .addLootPool(new LootPool.Builder()\n                        .rolls(ConstantRange.of(1))\n                        .addEntry(ItemLootEntry.builder(AstralItems.METAPHORIC_BONE.get())\n                                .acceptCondition(TableBonus.builder(Enchantments.FORTUNE, 0.02f, 0.022222223f, 0.025f, 0.033333335f, 0.1f))\n                                .acceptFunction(SetCount.builder(RandomValueRange.of(1, 2)))\n                                .acceptFunction(ExplosionDecay.builder()))\n                        .addEntry(ItemLootEntry.builder(AstralItems.METAPHORIC_FLESH.get())\n                                .acceptCondition(TableBonus.builder(Enchantments.FORTUNE, 0.02f, 0.022222223f, 0.025f, 0.033333335f, 0.1f))\n                                .acceptFunction(SetCount.builder(RandomValueRange.of(1, 2)))\n                                .acceptFunction(ExplosionDecay.builder()))\n                        .acceptCondition(Inverted.builder(Constants.SILK_TOUCH_OR_SHEARS))));\n        registerLootTable(ETHERIC_POWDER.get(), dropping(ETHERIC_POWDER.get()));\n        registerLootTable(STRIPPED_ETHEREAL_LOG.get(), dropping(STRIPPED_ETHEREAL_LOG.get()));\n        registerLootTable(STRIPPED_ETHEREAL_WOOD.get(), dropping(STRIPPED_ETHEREAL_WOOD.get()));\n        registerLootTable(ETHEREAL_WOOD.get(), dropping(ETHEREAL_WOOD.get()));\n        registerLootTable(INDEX_OF_KNOWLEDGE.get(), dropping(INDEX_OF_KNOWLEDGE.get()));\n        registerLootTable(METAPHORIC_STONE.get(), droppingWithSilkTouch(METAPHORIC_STONE.get(), METAPHORIC_BONE_BLOCK.get()));\n        registerLootTable(METAPHORIC_BONE_BLOCK.get(), dropping(METAPHORIC_BONE_BLOCK.get()));\n        registerLootTable(METAPHORIC_FLESH_BLOCK.get(), dropping(METAPHORIC_FLESH_BLOCK.get()));\n        registerLootTable(ETHEREAL_SPAWNER.get(), blockNoDrop());\n    }\n\n    @Override\n    @Nonnull\n    protected Iterable<Block> getKnownBlocks() {\n        return BLOCKS.getEntries().stream().map(RegistryObject::get).collect(Collectors.toList());\n    }\n\n    private LootTable.Builder onlyWithSilkTouchOrShears(Block block) {\n        return LootTable.builder()\n                .addLootPool(LootPool.builder()\n                        .rolls(ConstantRange.of(1))\n                        .acceptCondition(Constants.SILK_TOUCH_OR_SHEARS)\n                        .addEntry(ItemLootEntry.builder(block)));\n    }\n\n    private LootTable.Builder droppingWithSilkTouchOrShearsTag(Block block, LootEntry.Builder<?> drops){\n        return dropping(block, Constants.SILK_TOUCH_OR_SHEARS, drops);\n    }\n}", "class_id": 0, "repo": "Alan19/Astral", "file": "src/main/java/com/alan19/astral/data/providers/loottables/AstralBlockLootTables.java", "last_update_at": "2020-06-21T17:13:42+00:00", "question_id": "5488ea67e067453a405e5896520d1af5d8a288be", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AstralBlockLootTables extends BlockLootTables {\n    @Override\n    protected void addTables() {\n        registerLootTable(REDBULB.get(), onlyWithSilkTouchOrShears(REDBULB.get()));\n        registerLootTable(CYANGRASS.get(), onlyWithSilkTouchOrShears(CYANGRASS.get()));\n        registerLootTable(GENTLEGRASS.get(), onlyWithSilkTouchOrShears(GENTLEGRASS.get()));\n        registerLootTable(WILDWEED.get(), onlyWithSilkTouchOrShears(WILDWEED.get()));\n        registerLootTable(TALL_REDBULB.get(), onlyWithSilkTouchOrShears(TALL_REDBULB.get()));\n        registerLootTable(TALL_CYANGRASS.get(), onlyWithSilkTouchOrShears(TALL_CYANGRASS.get()));\n        registerLootTable(TALL_GENTLEGRASS.get(), onlyWithSilkTouchOrShears(TALL_GENTLEGRASS.get()));\n        registerLootTable(TALL_WILDWEED.get(), onlyWithSilkTouchOrShears(TALL_WILDWEED.get()));\n        registerLootTable(BLUECAP_MUSHROOM.get(), dropping(BLUECAP_MUSHROOM.get()));\n        registerLootTable(RUSTCAP_MUSHROOM.get(), dropping(RUSTCAP_MUSHROOM.get()));\n        registerLootTable(ETHEREAL_PLANKS.get(), dropping(ETHEREAL_PLANKS.get()));\n        registerLootTable(ETHEREAL_TRAPDOOR.get(), dropping(ETHEREAL_TRAPDOOR.get()));\n        registerLootTable(ETHEREAL_DOOR.get(), dropping(ETHEREAL_DOOR.get()));\n        registerLootTable(COMFORTABLE_CUSHION.get(), dropping(COMFORTABLE_CUSHION.get()));\n        registerLootTable(ETHEREAL_SAPLING.get(), dropping(ETHEREAL_SAPLING.get()));\n        registerLootTable(CRYSTAL_WEB.get(), droppingWithSilkTouchOrShearsTag(CRYSTAL_WEB.get(), ItemLootEntry.builder(AstralItems.DREAMCORD.get())));\n        this.registerLootTable(SNOWBERRY_BUSH.get(), new LootTable.Builder()\n                .addLootPool(new LootPool.Builder()\n                        .name(\"ripe\")\n                        .addEntry(ItemLootEntry.builder(AstralItems.SNOWBERRY.get()))\n                        .acceptCondition(BlockStateProperty.builder(SNOWBERRY_BUSH.get())\n                                .fromProperties(StatePropertiesPredicate.Builder.newBuilder().withIntProp(SweetBerryBushBlock.AGE, 3)))\n                        .acceptFunction(SetCount.builder(RandomValueRange.of(2, 3)))\n                        .acceptFunction(ApplyBonus.uniformBonusCount(Enchantments.FORTUNE, 1)))\n                .addLootPool(new LootPool.Builder()\n                        .name(\"unripe\")\n                        .addEntry(ItemLootEntry.builder(AstralItems.SNOWBERRY.get()))\n                        .acceptCondition(BlockStateProperty.builder(SNOWBERRY_BUSH.get())\n                                .fromProperties(StatePropertiesPredicate.Builder.newBuilder().withIntProp(SweetBerryBushBlock.AGE, 2)))\n                        .acceptFunction(SetCount.builder(RandomValueRange.of(1, 2)))\n                        .acceptFunction(ApplyBonus.uniformBonusCount(Enchantments.FORTUNE, 1)))\n                .addLootPool(new LootPool.Builder()\n                        .name(\"not_grown\")\n                        .addEntry(ItemLootEntry.builder(AstralItems.SNOWBERRY.get()))\n                        .acceptCondition(BlockStateProperty.builder(SNOWBERRY_BUSH.get())\n                                .fromProperties(StatePropertiesPredicate.Builder.newBuilder().withIntProp(SweetBerryBushBlock.AGE, 1)))\n                        .acceptFunction(SetCount.builder(RandomValueRange.of(1, 1)))\n                        .acceptFunction(ApplyBonus.uniformBonusCount(Enchantments.FORTUNE, 1)))\n                .addLootPool(new LootPool.Builder()\n                        .name(\"planted\")\n                        .addEntry(ItemLootEntry.builder(AstralItems.SNOWBERRY.get()))\n                        .acceptCondition(BlockStateProperty.builder(SNOWBERRY_BUSH.get())\n                                .fromProperties(StatePropertiesPredicate.Builder.newBuilder().withIntProp(SweetBerryBushBlock.AGE, 0)))\n                        .acceptFunction(SetCount.builder(RandomValueRange.of(1, 1)))\n                        .acceptFunction(ApplyBonus.uniformBonusCount(Enchantments.FORTUNE, 1)))\n                .acceptFunction(ExplosionDecay.builder())\n        );\n        registerLootTable(FEVERWEED_BLOCK.get(), dropping(FEVERWEED_BLOCK.get()));\n        registerLootTable(OFFERING_BRAZIER.get(), dropping(OFFERING_BRAZIER.get()));\n        registerLootTable(ETHER_DIRT.get(), dropping(ETHER_DIRT.get()));\n        registerLootTable(ETHER_GRASS.get(), droppingWithSilkTouch(ETHER_GRASS.get(), ETHER_DIRT.get()));\n        registerLootTable(ETHEREAL_SAPLING.get(), dropping(ETHEREAL_SAPLING.get()));\n        registerLootTable(ETHEREAL_DOOR.get(), dropping(ETHEREAL_DOOR.get()));\n        registerLootTable(ETHEREAL_TRAPDOOR.get(), dropping(ETHEREAL_TRAPDOOR.get()));\n        registerLootTable(ETHEREAL_LOG.get(), dropping(ETHEREAL_LOG.get()));\n        registerLootTable(ETHEREAL_LEAVES.get(), new LootTable.Builder()\n                .addLootPool(new LootPool.Builder()\n                        .rolls(ConstantRange.of(1))\n                        .addEntry(AlternativesLootEntry.builder(ItemLootEntry.builder(ETHEREAL_LEAVES.get())\n                                        .acceptCondition(Constants.SILK_TOUCH_OR_SHEARS),\n                                ItemLootEntry.builder(AstralItems.ETHEREAL_SAPLING_ITEM.get())\n                                        .acceptCondition(SurvivesExplosion.builder())\n                                        .acceptCondition(TableBonus.builder(Enchantments.FORTUNE, .05f, .0625f, 0.083333336f, 0.1f)))))\n                .addLootPool(new LootPool.Builder()\n                        .rolls(ConstantRange.of(1))\n                        .addEntry(ItemLootEntry.builder(AstralItems.METAPHORIC_BONE.get())\n                                .acceptCondition(TableBonus.builder(Enchantments.FORTUNE, 0.02f, 0.022222223f, 0.025f, 0.033333335f, 0.1f))\n                                .acceptFunction(SetCount.builder(RandomValueRange.of(1, 2)))\n                                .acceptFunction(ExplosionDecay.builder()))\n                        .addEntry(ItemLootEntry.builder(AstralItems.METAPHORIC_FLESH.get())\n                                .acceptCondition(TableBonus.builder(Enchantments.FORTUNE, 0.02f, 0.022222223f, 0.025f, 0.033333335f, 0.1f))\n                                .acceptFunction(SetCount.builder(RandomValueRange.of(1, 2)))\n                                .acceptFunction(ExplosionDecay.builder()))\n                        .acceptCondition(Inverted.builder(Constants.SILK_TOUCH_OR_SHEARS))));\n        registerLootTable(ETHERIC_POWDER.get(), dropping(ETHERIC_POWDER.get()));\n        registerLootTable(STRIPPED_ETHEREAL_LOG.get(), dropping(STRIPPED_ETHEREAL_LOG.get()));\n        registerLootTable(STRIPPED_ETHEREAL_WOOD.get(), dropping(STRIPPED_ETHEREAL_WOOD.get()));\n        registerLootTable(ETHEREAL_WOOD.get(), dropping(ETHEREAL_WOOD.get()));\n        registerLootTable(INDEX_OF_KNOWLEDGE.get(), dropping(INDEX_OF_KNOWLEDGE.get()));\n        registerLootTable(METAPHORIC_STONE.get(), droppingWithSilkTouch(METAPHORIC_STONE.get(), METAPHORIC_BONE_BLOCK.get()));\n        registerLootTable(METAPHORIC_BONE_BLOCK.get(), dropping(METAPHORIC_BONE_BLOCK.get()));\n        registerLootTable(METAPHORIC_FLESH_BLOCK.get(), dropping(METAPHORIC_FLESH_BLOCK.get()));\n        registerLootTable(ETHEREAL_SPAWNER.get(), blockNoDrop());\n    }\n    @Override\n    @Nonnull\n    protected Iterable<Block> getKnownBlocks() {\n        return BLOCKS.getEntries().stream().map(RegistryObject::get).collect(Collectors.toList());\n    }\n    private LootTable.Builder onlyWithSilkTouchOrShears(Block block) {\n        return LootTable.builder()\n                .addLootPool(LootPool.builder()\n                        .rolls(ConstantRange.of(1))\n                        .acceptCondition(Constants.SILK_TOUCH_OR_SHEARS)\n                        .addEntry(ItemLootEntry.builder(block)));\n    }\n    private LootTable.Builder droppingWithSilkTouchOrShearsTag(Block block, LootEntry.Builder<?> drops){\n        return dropping(block, Constants.SILK_TOUCH_OR_SHEARS, drops);\n    }\n"]]}
{"hexsha": "15a708a8bb51e88715681aa659ea3904159a0dd3", "ext": "java", "lang": "Java", "content": "class GoCDAzureClientTest extends BaseTest {\n\n  @Mock(answer = Answers.RETURNS_DEEP_STUBS)\n  private Azure azure;\n\n  @Mock\n  private NetworkDecorator mockNetworkDecorator;\n\n  private GoCDAzureClient goCDAzureClient;\n  private String resourceGroup = \"AGENTS-group\";\n\n  @BeforeEach\n  void setUp() {\n    initMocks(this);\n    goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);\n\n  }\n\n  @Test\n  void testShouldFetchRunningVirtualMachinesInResourceGroupWithCaseInsensitivityAndWithServerIdTag() {\n    VirtualMachine vm1 = mock(VirtualMachine.class);\n    VirtualMachine vm2 = mock(VirtualMachine.class);\n    VirtualMachine vm3 = mock(VirtualMachine.class);\n\n    when(vm1.resourceGroupName()).thenReturn(\"agents-group\");\n    Map<String, String> tagsMap = new HashMap<String, String>() {{\n      put(GOCD_SERVER_ID_TAG_KEY, \"server_id\");\n    }};\n    when(vm1.tags()).thenReturn(tagsMap);\n    when(vm2.resourceGroupName()).thenReturn(\"another-group\");\n    when(vm3.resourceGroupName()).thenReturn(\"agents-group\");\n    when(vm3.tags()).thenReturn(tagsMap);\n    List<VirtualMachine> machines = asList(vm1, vm2, vm3);\n    when(azure.virtualMachines().list().stream()).thenReturn(machines.stream()).thenReturn(machines.stream());\n    List<VirtualMachine> vms = new GoCDAzureClient(azure, \"agents-group\", mockNetworkDecorator).runningVirtualMachinesWithTag(GOCD_SERVER_ID_TAG_KEY, \"server_id\");\n\n    assertEquals(2, vms.size());\n    assertEquals(vm1, vms.get(0));\n    assertEquals(vm3, vms.get(1));\n\n    vms = new GoCDAzureClient(azure, \"AGENTS-group\", mockNetworkDecorator).runningVirtualMachinesWithTag(GOCD_SERVER_ID_TAG_KEY, \"server_id\");\n\n    assertEquals(2, vms.size());\n    assertEquals(vm1, vms.get(0));\n    assertEquals(vm3, vms.get(1));\n  }\n\n  @Test\n  void testRunningVirtualMachinesShouldNotFetchVmsWithFailedProvisioningState() {\n    VirtualMachine runningVm = mock(VirtualMachine.class);\n    VirtualMachine failedVm = mock(VirtualMachine.class);\n\n    Map<String, String> tagsMap = new HashMap<String, String>() {{\n      put(GOCD_SERVER_ID_TAG_KEY, \"server_id\");\n    }};\n    when(runningVm.resourceGroupName()).thenReturn(\"agents-group\");\n    when(runningVm.tags()).thenReturn(tagsMap);\n    when(runningVm.provisioningState()).thenReturn(\"Succeeded\");\n    when(failedVm.resourceGroupName()).thenReturn(\"agents-group\");\n    when(failedVm.provisioningState()).thenReturn(\"Failed\");\n    when(failedVm.tags()).thenReturn(tagsMap);\n    List<VirtualMachine> machines = asList(runningVm, failedVm);\n    when(azure.virtualMachines().list().stream()).thenReturn(machines.stream()).thenReturn(machines.stream());\n    List<VirtualMachine> vms = new GoCDAzureClient(azure, \"agents-group\", mockNetworkDecorator).runningVirtualMachinesWithTag(GOCD_SERVER_ID_TAG_KEY, \"server_id\");\n\n    assertEquals(1, vms.size());\n    assertEquals(runningVm, vms.get(0));\n  }\n\n  @Test\n  void testShouldFetchVmsWithFailedProvisioningState() {\n    VirtualMachine runningVm = mock(VirtualMachine.class);\n    VirtualMachine failedVm = mock(VirtualMachine.class);\n\n    Map<String, String> tagsMap = new HashMap<String, String>() {{\n      put(GOCD_SERVER_ID_TAG_KEY, \"server_id\");\n    }};\n    when(runningVm.resourceGroupName()).thenReturn(\"agents-group\");\n    when(runningVm.tags()).thenReturn(tagsMap);\n    when(runningVm.provisioningState()).thenReturn(\"Succeeded\");\n    when(failedVm.resourceGroupName()).thenReturn(\"agents-group\");\n    when(failedVm.provisioningState()).thenReturn(\"Failed\");\n    when(failedVm.tags()).thenReturn(tagsMap);\n    List<VirtualMachine> machines = asList(runningVm, failedVm);\n    when(azure.virtualMachines().list().stream()).thenReturn(machines.stream()).thenReturn(machines.stream());\n    List<VirtualMachine> vms = new GoCDAzureClient(azure, \"agents-group\", mockNetworkDecorator).failedProvisioningStateVirtualMachinesWithTag(GOCD_SERVER_ID_TAG_KEY, \"server_id\");\n\n    assertEquals(1, vms.size());\n    assertEquals(failedVm, vms.get(0));\n  }\n\n  @Test\n  void shouldReturnFalseIfNetworkDoesnotExist() {\n    when(azure.networks().getById(\"invalid-network-id\")).thenReturn(null);\n\n    assertFalse(goCDAzureClient.networkExists(\"invalid-network-id\"));\n  }\n\n  @Test\n  void shouldReturnTrueIfNetworkExist() {\n    when(azure.networks().getById(\"invalid-network-id\")).thenReturn(mock(Network.class));\n\n    assertTrue(goCDAzureClient.networkExists(\"invalid-network-id\"));\n  }\n\n  @Test\n  void shouldCheckForInvalidNetworkId() {\n    when(azure.networks().getById(\"some-invalid-format\")).thenThrow(InvalidParameterException.class);\n\n    assertFalse(goCDAzureClient.networkExists(\"some-invalid-format\"));\n  }\n\n  @Test\n  void shouldCheckIfResourceGroupExists() {\n    when(azure.resourceGroups().contain(\"some-resource-group\")).thenReturn(true);\n\n    assertTrue(goCDAzureClient.resourceGroupExists(\"some-resource-group\"));\n  }\n\n  @Test\n  void shouldCheckIfRegionExistsByName() {\n    Location location1 = mock(Location.class);\n    when(location1.name()).thenReturn(\"valid-region-1\");\n    Location location2 = mock(Location.class);\n    when(location2.name()).thenReturn(\"valid-region-2\");\n    List<Location> locations = asList(location1, location2);\n\n    when(azure.getCurrentSubscription().listLocations().stream()).thenReturn(locations.stream()).thenReturn(locations.stream());\n\n    assertTrue(goCDAzureClient.regionExists(\"valid-region-1\"));\n    assertFalse(goCDAzureClient.regionExists(\"invalid-region\"));\n  }\n\n  @Test\n  void shouldCheckIfRegionExistsByDisplayName() {\n    Location location1 = mock(Location.class);\n    when(location1.displayName()).thenReturn(\"Valid Region 1\");\n    Location location2 = mock(Location.class);\n    when(location2.displayName()).thenReturn(\"Valid Region 2\");\n    List<Location> locations = asList(location1, location2);\n\n    when(azure.getCurrentSubscription().listLocations().stream()).thenReturn(locations.stream()).thenReturn(locations.stream());\n\n    assertTrue(goCDAzureClient.regionExists(\"Valid Region 1\"));\n    assertFalse(goCDAzureClient.regionExists(\"Invalid Region\"));\n  }\n\n  @Test\n  void shouldCheckIfNetworkSecurityGroupExists() {\n    when(azure.networkSecurityGroups().getById(\"valid-security-group-id\"))\n        .thenReturn(mock(NetworkSecurityGroup.class));\n    when(azure.networkSecurityGroups().getById(\"invalid-security-group-id\"))\n        .thenReturn(null);\n\n    assertTrue(goCDAzureClient.networkSecurityGroupExists(\"valid-security-group-id\"));\n    assertFalse(goCDAzureClient.networkSecurityGroupExists(\"invalid-security-group-id\"));\n  }\n\n  @Test\n  void shouldCheckIfSubnetExistsInAGivenNetwork() {\n    Network mockNetwork = mock(Network.class, RETURNS_DEEP_STUBS);\n    when(azure.networks().getById(\"rg/test-net\")).thenReturn(mockNetwork);\n    when(mockNetwork.subnets().containsKey(\"test-subnet\")).thenReturn(true);\n\n    assertTrue(goCDAzureClient.subnetExists(\"rg/test-net\", \"test-subnet\"));\n  }\n\n  @Test\n  void shouldReturnSubnetDoesnotExistForAnInvalidNetwork() {\n    when(azure.networks().getById(\"rg/test-net\")).thenReturn(null);\n\n    assertFalse(goCDAzureClient.subnetExists(\"rg/test-net\", \"test-subnet\"));\n  }\n\n  @Test\n  void shouldReturnSubnetDoesnotExistForAnInvalidSubnetInANetwork() {\n    Network mockNetwork = mock(Network.class, RETURNS_DEEP_STUBS);\n    when(mockNetwork.subnets().containsKey(\"test-subnet\")).thenReturn(false);\n    when(azure.networks().getById(\"rg/test-net\")).thenReturn(mockNetwork);\n\n    assertFalse(goCDAzureClient.subnetExists(\"rg/test-net\", \"test-subnet\"));\n  }\n\n  @Test\n  void testBuildVmShouldAddPlatformSpecificOSWithoutPlan() throws Exception {\n    VmConfig mockVMConfig = mock(VmConfig.class, RETURNS_DEEP_STUBS);\n    Region region = mock(Region.class, RETURNS_DEEP_STUBS);\n    WithOS mockOS = mock(WithOS.class);\n    WithGroup mockWithGroup = mock(WithGroup.class);\n    Blank mockStage = mock(Blank.class, RETURNS_DEEP_STUBS);\n    WithNetwork mockWithNetwork = mock(WithNetwork.class, RETURNS_DEEP_STUBS);\n    WithCreate mockWithCreate = mock(WithCreate.class, RETURNS_DEEP_STUBS);\n    PlatformConfigStrategy mockStrategy = mock(PlatformConfigStrategy.class);\n    AzureVMExtension mockExtension = mock(AzureVMExtension.class);\n    Map<String, String> tags = new HashMap<>();\n    List<AzureVMExtension> extensions = asList(mockExtension);\n    VirtualMachine expectedVM = mock(VirtualMachine.class);\n\n    when(mockVMConfig.getRegion()).thenReturn(region);\n    when(mockVMConfig.getImageReference()).thenReturn(null);\n    when(mockVMConfig.getName()).thenReturn(\"vm-name\");\n    when(mockVMConfig.getPlatformStrategy()).thenReturn(mockStrategy);\n    when(mockVMConfig.getTags()).thenReturn(tags);\n    when(mockVMConfig.getOsDiskSize()).thenReturn(Optional.of(45));\n    when(azure.virtualMachines().define(\"vm-name\")).thenReturn(mockStage);\n    when(mockStage.withRegion(region)).thenReturn(mockWithGroup);\n    when(mockWithGroup.withExistingResourceGroup(resourceGroup)).thenReturn(mockWithNetwork);\n    when(mockNetworkDecorator.add(mockWithNetwork, mockVMConfig)).thenReturn(mockOS);\n    when(mockStrategy.addOS(mockOS, mockVMConfig)).thenReturn(mockWithCreate);\n    when(mockStrategy.getExtensions(mockVMConfig)).thenReturn(extensions);\n    when(mockWithCreate.withTags(tags)).thenReturn(mockWithCreate);\n\n    when(mockExtension.addTo(mockWithCreate)).thenReturn(mockWithCreate);\n    when(mockWithCreate.create()).thenReturn(expectedVM);\n\n    VirtualMachine createdVM = goCDAzureClient.createVM(mockVMConfig);\n\n    verify(mockStrategy).addOS(mockOS, mockVMConfig);\n    verify(mockWithCreate).withTags(tags);\n    verify(mockWithCreate, never()).withPlan(any());\n    verify(mockExtension).addTo(mockWithCreate);\n    verify(mockWithCreate).withOSDiskSizeInGB(45);\n    verify(mockWithCreate).create();\n\n    assertEquals(expectedVM, createdVM);\n  }\n\n  @Test\n  void testRunCommandShouldDoNothingForBlankScript() throws Exception {\n    VmConfig mockVMConfig = mock(VmConfig.class, RETURNS_DEEP_STUBS);\n    when(mockVMConfig.getCustomScript()).thenReturn(\" \");\n\n    goCDAzureClient.runCustomScript(mockVMConfig);\n\n    verify(azure, never()).virtualMachines();\n  }\n\n  @Test\n  void testRunCommandShouldInvokeCommandAndGenerateLogs() throws Exception {\n    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, \"AGENTS\", mockNetworkDecorator);\n    VmConfig mockVMConfig = mock(VmConfig.class, RETURNS_DEEP_STUBS);\n    PlatformConfigStrategy mockStrategy = mock(PlatformConfigStrategy.class, RETURNS_DEEP_STUBS);\n    VirtualMachines mockVirtualMachines = mock(VirtualMachines.class);\n    when(mockVMConfig.getPlatformStrategy()).thenReturn(mockStrategy);\n    when(mockVMConfig.getName()).thenReturn(\"vmName\");\n    when(mockVMConfig.getResourceGroup()).thenReturn(\"AGENTS\");\n    when(mockVMConfig.getCustomScript()).thenReturn(\"custom script\");\n    when(azure.virtualMachines()).thenReturn(mockVirtualMachines);\n\n    RunCommandResult runCommandResult = mock(RunCommandResult.class);\n    InstanceViewStatus instanceViewStatus1 = mock(InstanceViewStatus.class);\n    InstanceViewStatus instanceViewStatus2 = mock(InstanceViewStatus.class);\n    when(instanceViewStatus1.message()).thenReturn(\"logs 1\");\n    when(instanceViewStatus2.message()).thenReturn(\"logs 2\");\n    when(runCommandResult.value()).thenReturn(Arrays.asList(instanceViewStatus1, instanceViewStatus2));\n    when(mockStrategy.runScript(\"AGENTS\", \"vmName\", mockVirtualMachines, \"custom script\")).thenReturn(runCommandResult);\n\n    String logs = goCDAzureClient.runCustomScript(mockVMConfig);\n\n    assertEquals(\"logs 1\\nlogs 2\\n\", logs);\n    verify(azure).virtualMachines();\n    verify(mockStrategy).runScript(\"AGENTS\", \"vmName\", mockVirtualMachines, \"custom script\");\n  }\n\n  @Test\n  void testStartAgentShouldInvokeCommand() {\n    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);\n    VmConfig mockVMConfig = mock(VmConfig.class, RETURNS_DEEP_STUBS);\n    AgentConfig agentConfig = mock(AgentConfig.class);\n    PlatformConfigStrategy mockStrategy = mock(PlatformConfigStrategy.class, RETURNS_DEEP_STUBS);\n    VirtualMachines mockVirtualMachines = mock(VirtualMachines.class);\n    when(mockVMConfig.getPlatformStrategy()).thenReturn(mockStrategy);\n    when(mockVMConfig.getName()).thenReturn(\"vmName\");\n    when(mockVMConfig.getResourceGroup()).thenReturn(\"AGENTS\");\n    when(mockVMConfig.getAgentConfig()).thenReturn(agentConfig);\n    when(azure.virtualMachines()).thenReturn(mockVirtualMachines);\n\n    goCDAzureClient.startAgent(mockVMConfig);\n\n    verify(azure).virtualMachines();\n    verify(mockStrategy).startAgent(\"AGENTS\", \"vmName\", mockVirtualMachines, agentConfig);\n  }\n\n  @Test\n  void testInstallAgentShouldInvokeCommand() throws ProvisionFailedException {\n    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);\n    VmConfig mockVMConfig = mock(VmConfig.class, RETURNS_DEEP_STUBS);\n    PlatformConfigStrategy mockStrategy = mock(PlatformConfigStrategy.class, RETURNS_DEEP_STUBS);\n    VirtualMachines mockVirtualMachines = mock(VirtualMachines.class);\n    when(mockVMConfig.getPlatformStrategy()).thenReturn(mockStrategy);\n    when(azure.virtualMachines()).thenReturn(mockVirtualMachines);\n\n    goCDAzureClient.installGoAgent(mockVMConfig);\n\n    verify(azure).virtualMachines();\n    verify(mockStrategy).installGoAgent(mockVirtualMachines, mockVMConfig);\n  }\n\n  @Test\n  void testShouldReRaiseExceptionAndTerminateVMOnCommandExecutionFailure() {\n    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);\n    VmConfig mockVMConfig = mock(VmConfig.class, RETURNS_DEEP_STUBS);\n    VirtualMachine mockVM = mock(VirtualMachine.class);\n    PlatformConfigStrategy mockStrategy = mock(PlatformConfigStrategy.class);\n\n    when(mockVMConfig.getCustomScript()).thenReturn(\"custom script\");\n    when(mockVMConfig.getPlatformStrategy()).thenReturn(mockStrategy);\n    when(mockVMConfig.getResourceGroup()).thenReturn(resourceGroup);\n    when(mockVMConfig.getName()).thenReturn(\"Test-123\");\n    when(mockVM.id()).thenReturn(\"/resources/Test-123\");\n    when(azure.virtualMachines().getByResourceGroup(resourceGroup, \"Test-123\")).thenReturn(mockVM);\n    when(mockStrategy.runScript(eq(resourceGroup), eq(\"Test-123\"), any(), eq(\"custom script\")))\n        .thenThrow(new CloudException(\"script failed\",\n            Response.error(500, ResponseBody.create(MediaType.parse(\"application/json\"), \"boom\")),\n            new CloudError()));\n\n    assertThrows(ProvisionFailedException.class, () -> goCDAzureClient.runCustomScript(mockVMConfig));\n    verify(azure.virtualMachines()).deleteById(\"/resources/Test-123\");\n  }\n\n  @Test\n  void shouldAddTagToTheVirtualMachine() {\n    VirtualMachine mockVM = mock(VirtualMachine.class);\n    VirtualMachine mockVMWithTags = mock(VirtualMachine.class);\n    Update mockUpdate = mock(Update.class, RETURNS_DEEP_STUBS);\n    when(mockVM.update()).thenReturn(mockUpdate);\n    when(azure.virtualMachines().getById(\"vm-id\")).thenReturn(mockVM);\n    when(mockUpdate.withTag(\"tag-1\", \"value-1\").apply()).thenReturn(mockVMWithTags);\n\n    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);\n\n    VirtualMachine vmWithTags = goCDAzureClient.addTag(\"vm-id\", \"tag-1\", \"value-1\");\n\n    verify(mockUpdate.withTag(\"tag-1\", \"value-1\"), times(1)).apply();\n    assertEquals(mockVMWithTags, vmWithTags);\n  }\n\n  @Test\n  void shouldRemoveTagFromVirtualMachine() {\n    VirtualMachine mockVM = mock(VirtualMachine.class);\n    VirtualMachine mockVMWithoutTag = mock(VirtualMachine.class);\n    Update mockUpdate = mock(Update.class, RETURNS_DEEP_STUBS);\n    when(mockVM.update()).thenReturn(mockUpdate);\n    when(azure.virtualMachines().getById(\"vm-id\")).thenReturn(mockVM);\n    when(mockUpdate.withoutTag(\"tag-1\").apply()).thenReturn(mockVMWithoutTag);\n\n    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);\n\n    VirtualMachine vmWithoutTags = goCDAzureClient.removeTag(\"vm-id\", \"tag-1\");\n\n    verify(mockUpdate.withoutTag(\"tag-1\"), times(1)).apply();\n    assertEquals(mockVMWithoutTag, vmWithoutTags);\n  }\n\n  @Test\n  void shouldCleanupNICOnVMCreationFailure() {\n    VmConfig mockVMConfig = mock(VmConfig.class, RETURNS_DEEP_STUBS);\n    NetworkInterface mockNic = mock(NetworkInterface.class);\n    when(mockVMConfig.getName()).thenReturn(\"vm-123\");\n    when(mockVMConfig.getNetworkInterfaceName()).thenReturn(\"nic-vm-123\");\n    when(mockVMConfig.getJobIdentifier().getRepresentation()).thenReturn(\"jobid\");\n    when(azure.virtualMachines().define(\"vm-123\")).thenThrow(new RuntimeException(\"boom\"));\n    when(azure.virtualMachines().getByResourceGroup(anyString(), anyString())).thenReturn(null);\n    when(azure.networkInterfaces().getByResourceGroup(resourceGroup, \"nic-vm-123\")).thenReturn(mockNic);\n    when(mockNic.id()).thenReturn(\"nicId\");\n\n    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);\n\n    ProvisionFailedException exception = assertThrows(ProvisionFailedException.class, () -> goCDAzureClient.createVM(mockVMConfig));\n    assertEquals(\"Failed to create vm with name vm-123 for job jobid due to error: boom\", exception.getMessage());\n\n    verify(azure.networkInterfaces()).getByResourceGroup(resourceGroup, \"nic-vm-123\");\n    verify(azure.networkInterfaces()).deleteById(\"nicId\");\n  }\n\n  @Test\n  void shouldValidateTheImageURNChosenIsCorrespondingToThePlatformSelected() {\n    VirtualMachineImage mockVMImage = mock(VirtualMachineImage.class);\n    OSDiskImage mockDiskImage = mock(OSDiskImage.class);\n\n    when(mockDiskImage.operatingSystem()).thenReturn(OperatingSystemTypes.LINUX);\n    when(mockVMImage.osDiskImage()).thenReturn(mockDiskImage);\n    when(azure.virtualMachineImages().getImage(Region.INDIA_SOUTH, \"pub-1\", \"offer-1\", \"sku-1\", \"version-1\")).thenReturn(mockVMImage);\n\n    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);\n\n    assertFalse(goCDAzureClient.imageValidForPlatform(new ImageURN(\"pub-1:offer-1:sku-1:version-1\"), Platform.WINDOWS, Region.INDIA_SOUTH));\n    assertTrue(goCDAzureClient.imageValidForPlatform(new ImageURN(\"pub-1:offer-1:sku-1:version-1\"), Platform.LINUX, Region.INDIA_SOUTH));\n\n  }\n\n  @Test\n  void shouldTerminateVMAlongWithAssociatedResources() {\n    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);\n\n    VirtualMachine vm = mock(VirtualMachine.class);\n    when(azure.virtualMachines().getById(\"resource-id-to-be-deleted\")).thenReturn(vm);\n    when(vm.id()).thenReturn(\"resource-id-to-be-deleted\");\n    when(vm.osDiskId()).thenReturn(\"os-disk-id\");\n    when(vm.dataDisks()).thenReturn(Collections.emptyMap());\n    when(vm.networkInterfaceIds()).thenReturn(asList(\"nic-1\"));\n\n    goCDAzureClient.terminate(\"resource-id-to-be-deleted\");\n    verify(azure.virtualMachines()).deleteById(\"resource-id-to-be-deleted\");\n    verify(azure.disks()).deleteById(\"os-disk-id\");\n    verify(azure.networkInterfaces()).deleteById(\"nic-1\");\n  }\n\n  @Test\n  void shouldTerminateVMIfNICAndDiskIsNotAttached() {\n    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);\n\n    VirtualMachine vm = mock(VirtualMachine.class);\n    when(azure.virtualMachines().getById(\"resource-id-to-be-deleted\")).thenReturn(vm);\n    when(vm.id()).thenReturn(\"resource-id-to-be-deleted\");\n    when(vm.osDiskId()).thenReturn(null);\n    when(vm.dataDisks()).thenReturn(Collections.emptyMap());\n    when(vm.networkInterfaceIds()).thenReturn(asList(\"\"));\n\n    goCDAzureClient.terminate(\"resource-id-to-be-deleted\");\n    verify(azure.virtualMachines()).deleteById(\"resource-id-to-be-deleted\");\n    verify(azure.disks(), never()).deleteById(null);\n    verify(azure.networkInterfaces(), never()).deleteById(null);\n  }\n\n}", "class_id": 0, "repo": "maheshp/azure-elastic-agent-plugin", "file": "src/test/java/com/thoughtworks/gocd/elasticagent/azure/client/GoCDAzureClientTest.java", "last_update_at": "2020-03-26T02:21:18+00:00", "question_id": "15a708a8bb51e88715681aa659ea3904159a0dd3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class GoCDAzureClientTest extends BaseTest {\n  @Mock(answer = Answers.RETURNS_DEEP_STUBS)\n  private Azure azure;\n  @Mock\n  private NetworkDecorator mockNetworkDecorator;\n  private GoCDAzureClient goCDAzureClient;\n  private String resourceGroup = \"AGENTS-group\";\n  @BeforeEach\n  void setUp() {\n    initMocks(this);\n    goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);\n  }\n  @Test\n  void testShouldFetchRunningVirtualMachinesInResourceGroupWithCaseInsensitivityAndWithServerIdTag() {\n    VirtualMachine vm1 = mock(VirtualMachine.class);\n    VirtualMachine vm2 = mock(VirtualMachine.class);\n    VirtualMachine vm3 = mock(VirtualMachine.class);\n    when(vm1.resourceGroupName()).thenReturn(\"agents-group\");\n    Map<String, String> tagsMap = new HashMap<String, String>() {{\n      put(GOCD_SERVER_ID_TAG_KEY, \"server_id\");\n    }};\n    when(vm1.tags()).thenReturn(tagsMap);\n    when(vm2.resourceGroupName()).thenReturn(\"another-group\");\n    when(vm3.resourceGroupName()).thenReturn(\"agents-group\");\n    when(vm3.tags()).thenReturn(tagsMap);\n    List<VirtualMachine> machines = asList(vm1, vm2, vm3);\n    when(azure.virtualMachines().list().stream()).thenReturn(machines.stream()).thenReturn(machines.stream());\n    List<VirtualMachine> vms = new GoCDAzureClient(azure, \"agents-group\", mockNetworkDecorator).runningVirtualMachinesWithTag(GOCD_SERVER_ID_TAG_KEY, \"server_id\");\n    assertEquals(2, vms.size());\n    assertEquals(vm1, vms.get(0));\n    assertEquals(vm3, vms.get(1));\n    vms = new GoCDAzureClient(azure, \"AGENTS-group\", mockNetworkDecorator).runningVirtualMachinesWithTag(GOCD_SERVER_ID_TAG_KEY, \"server_id\");\n    assertEquals(2, vms.size());\n    assertEquals(vm1, vms.get(0));\n    assertEquals(vm3, vms.get(1));\n  }\n  @Test\n  void testRunningVirtualMachinesShouldNotFetchVmsWithFailedProvisioningState() {\n    VirtualMachine runningVm = mock(VirtualMachine.class);\n    VirtualMachine failedVm = mock(VirtualMachine.class);\n    Map<String, String> tagsMap = new HashMap<String, String>() {{\n      put(GOCD_SERVER_ID_TAG_KEY, \"server_id\");\n    }};\n    when(runningVm.resourceGroupName()).thenReturn(\"agents-group\");\n    when(runningVm.tags()).thenReturn(tagsMap);\n    when(runningVm.provisioningState()).thenReturn(\"Succeeded\");\n    when(failedVm.resourceGroupName()).thenReturn(\"agents-group\");\n    when(failedVm.provisioningState()).thenReturn(\"Failed\");\n    when(failedVm.tags()).thenReturn(tagsMap);\n    List<VirtualMachine> machines = asList(runningVm, failedVm);\n    when(azure.virtualMachines().list().stream()).thenReturn(machines.stream()).thenReturn(machines.stream());\n    List<VirtualMachine> vms = new GoCDAzureClient(azure, \"agents-group\", mockNetworkDecorator).runningVirtualMachinesWithTag(GOCD_SERVER_ID_TAG_KEY, \"server_id\");\n    assertEquals(1, vms.size());\n    assertEquals(runningVm, vms.get(0));\n  }\n  @Test\n  void testShouldFetchVmsWithFailedProvisioningState() {\n    VirtualMachine runningVm = mock(VirtualMachine.class);\n    VirtualMachine failedVm = mock(VirtualMachine.class);\n    Map<String, String> tagsMap = new HashMap<String, String>() {{\n      put(GOCD_SERVER_ID_TAG_KEY, \"server_id\");\n    }};\n    when(runningVm.resourceGroupName()).thenReturn(\"agents-group\");\n    when(runningVm.tags()).thenReturn(tagsMap);\n    when(runningVm.provisioningState()).thenReturn(\"Succeeded\");\n    when(failedVm.resourceGroupName()).thenReturn(\"agents-group\");\n    when(failedVm.provisioningState()).thenReturn(\"Failed\");\n    when(failedVm.tags()).thenReturn(tagsMap);\n    List<VirtualMachine> machines = asList(runningVm, failedVm);\n    when(azure.virtualMachines().list().stream()).thenReturn(machines.stream()).thenReturn(machines.stream());\n    List<VirtualMachine> vms = new GoCDAzureClient(azure, \"agents-group\", mockNetworkDecorator).failedProvisioningStateVirtualMachinesWithTag(GOCD_SERVER_ID_TAG_KEY, \"server_id\");\n    assertEquals(1, vms.size());\n    assertEquals(failedVm, vms.get(0));\n  }\n  @Test\n  void shouldReturnFalseIfNetworkDoesnotExist() {\n    when(azure.networks().getById(\"invalid-network-id\")).thenReturn(null);\n    assertFalse(goCDAzureClient.networkExists(\"invalid-network-id\"));\n  }\n  @Test\n  void shouldReturnTrueIfNetworkExist() {\n    when(azure.networks().getById(\"invalid-network-id\")).thenReturn(mock(Network.class));\n    assertTrue(goCDAzureClient.networkExists(\"invalid-network-id\"));\n  }\n  @Test\n  void shouldCheckForInvalidNetworkId() {\n    when(azure.networks().getById(\"some-invalid-format\")).thenThrow(InvalidParameterException.class);\n    assertFalse(goCDAzureClient.networkExists(\"some-invalid-format\"));\n  }\n  @Test\n  void shouldCheckIfResourceGroupExists() {\n    when(azure.resourceGroups().contain(\"some-resource-group\")).thenReturn(true);\n    assertTrue(goCDAzureClient.resourceGroupExists(\"some-resource-group\"));\n  }\n  @Test\n  void shouldCheckIfRegionExistsByName() {\n    Location location1 = mock(Location.class);\n    when(location1.name()).thenReturn(\"valid-region-1\");\n    Location location2 = mock(Location.class);\n    when(location2.name()).thenReturn(\"valid-region-2\");\n    List<Location> locations = asList(location1, location2);\n    when(azure.getCurrentSubscription().listLocations().stream()).thenReturn(locations.stream()).thenReturn(locations.stream());\n    assertTrue(goCDAzureClient.regionExists(\"valid-region-1\"));\n    assertFalse(goCDAzureClient.regionExists(\"invalid-region\"));\n  }\n  @Test\n  void shouldCheckIfRegionExistsByDisplayName() {\n    Location location1 = mock(Location.class);\n    when(location1.displayName()).thenReturn(\"Valid Region 1\");\n    Location location2 = mock(Location.class);\n    when(location2.displayName()).thenReturn(\"Valid Region 2\");\n    List<Location> locations = asList(location1, location2);\n    when(azure.getCurrentSubscription().listLocations().stream()).thenReturn(locations.stream()).thenReturn(locations.stream());\n    assertTrue(goCDAzureClient.regionExists(\"Valid Region 1\"));\n    assertFalse(goCDAzureClient.regionExists(\"Invalid Region\"));\n  }\n  @Test\n  void shouldCheckIfNetworkSecurityGroupExists() {\n    when(azure.networkSecurityGroups().getById(\"valid-security-group-id\"))\n        .thenReturn(mock(NetworkSecurityGroup.class));\n    when(azure.networkSecurityGroups().getById(\"invalid-security-group-id\"))\n        .thenReturn(null);\n    assertTrue(goCDAzureClient.networkSecurityGroupExists(\"valid-security-group-id\"));\n    assertFalse(goCDAzureClient.networkSecurityGroupExists(\"invalid-security-group-id\"));\n  }\n  @Test\n  void shouldCheckIfSubnetExistsInAGivenNetwork() {\n    Network mockNetwork = mock(Network.class, RETURNS_DEEP_STUBS);\n    when(azure.networks().getById(\"rg/test-net\")).thenReturn(mockNetwork);\n    when(mockNetwork.subnets().containsKey(\"test-subnet\")).thenReturn(true);\n    assertTrue(goCDAzureClient.subnetExists(\"rg/test-net\", \"test-subnet\"));\n  }\n  @Test\n  void shouldReturnSubnetDoesnotExistForAnInvalidNetwork() {\n    when(azure.networks().getById(\"rg/test-net\")).thenReturn(null);\n    assertFalse(goCDAzureClient.subnetExists(\"rg/test-net\", \"test-subnet\"));\n  }\n  @Test\n  void shouldReturnSubnetDoesnotExistForAnInvalidSubnetInANetwork() {\n    Network mockNetwork = mock(Network.class, RETURNS_DEEP_STUBS);\n    when(mockNetwork.subnets().containsKey(\"test-subnet\")).thenReturn(false);\n    when(azure.networks().getById(\"rg/test-net\")).thenReturn(mockNetwork);\n    assertFalse(goCDAzureClient.subnetExists(\"rg/test-net\", \"test-subnet\"));\n  }\n  @Test\n  void testBuildVmShouldAddPlatformSpecificOSWithoutPlan() throws Exception {\n    VmConfig mockVMConfig = mock(VmConfig.class, RETURNS_DEEP_STUBS);\n    Region region = mock(Region.class, RETURNS_DEEP_STUBS);\n    WithOS mockOS = mock(WithOS.class);\n    WithGroup mockWithGroup = mock(WithGroup.class);\n    Blank mockStage = mock(Blank.class, RETURNS_DEEP_STUBS);\n    WithNetwork mockWithNetwork = mock(WithNetwork.class, RETURNS_DEEP_STUBS);\n    WithCreate mockWithCreate = mock(WithCreate.class, RETURNS_DEEP_STUBS);\n    PlatformConfigStrategy mockStrategy = mock(PlatformConfigStrategy.class);\n    AzureVMExtension mockExtension = mock(AzureVMExtension.class);\n    Map<String, String> tags = new HashMap<>();\n    List<AzureVMExtension> extensions = asList(mockExtension);\n    VirtualMachine expectedVM = mock(VirtualMachine.class);\n    when(mockVMConfig.getRegion()).thenReturn(region);\n    when(mockVMConfig.getImageReference()).thenReturn(null);\n    when(mockVMConfig.getName()).thenReturn(\"vm-name\");\n    when(mockVMConfig.getPlatformStrategy()).thenReturn(mockStrategy);\n    when(mockVMConfig.getTags()).thenReturn(tags);\n    when(mockVMConfig.getOsDiskSize()).thenReturn(Optional.of(45));\n    when(azure.virtualMachines().define(\"vm-name\")).thenReturn(mockStage);\n    when(mockStage.withRegion(region)).thenReturn(mockWithGroup);\n    when(mockWithGroup.withExistingResourceGroup(resourceGroup)).thenReturn(mockWithNetwork);\n    when(mockNetworkDecorator.add(mockWithNetwork, mockVMConfig)).thenReturn(mockOS);\n    when(mockStrategy.addOS(mockOS, mockVMConfig)).thenReturn(mockWithCreate);\n    when(mockStrategy.getExtensions(mockVMConfig)).thenReturn(extensions);\n    when(mockWithCreate.withTags(tags)).thenReturn(mockWithCreate);\n    when(mockExtension.addTo(mockWithCreate)).thenReturn(mockWithCreate);\n    when(mockWithCreate.create()).thenReturn(expectedVM);\n    VirtualMachine createdVM = goCDAzureClient.createVM(mockVMConfig);\n    verify(mockStrategy).addOS(mockOS, mockVMConfig);\n    verify(mockWithCreate).withTags(tags);\n    verify(mockWithCreate, never()).withPlan(any());\n    verify(mockExtension).addTo(mockWithCreate);\n    verify(mockWithCreate).withOSDiskSizeInGB(45);\n    verify(mockWithCreate).create();\n    assertEquals(expectedVM, createdVM);\n  }\n  @Test\n  void testRunCommandShouldDoNothingForBlankScript() throws Exception {\n    VmConfig mockVMConfig = mock(VmConfig.class, RETURNS_DEEP_STUBS);\n    when(mockVMConfig.getCustomScript()).thenReturn(\" \");\n    goCDAzureClient.runCustomScript(mockVMConfig);\n    verify(azure, never()).virtualMachines();\n  }\n  @Test\n  void testRunCommandShouldInvokeCommandAndGenerateLogs() throws Exception {\n    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, \"AGENTS\", mockNetworkDecorator);\n    VmConfig mockVMConfig = mock(VmConfig.class, RETURNS_DEEP_STUBS);\n    PlatformConfigStrategy mockStrategy = mock(PlatformConfigStrategy.class, RETURNS_DEEP_STUBS);\n    VirtualMachines mockVirtualMachines = mock(VirtualMachines.class);\n    when(mockVMConfig.getPlatformStrategy()).thenReturn(mockStrategy);\n    when(mockVMConfig.getName()).thenReturn(\"vmName\");\n    when(mockVMConfig.getResourceGroup()).thenReturn(\"AGENTS\");\n    when(mockVMConfig.getCustomScript()).thenReturn(\"custom script\");\n    when(azure.virtualMachines()).thenReturn(mockVirtualMachines);\n    RunCommandResult runCommandResult = mock(RunCommandResult.class);\n    InstanceViewStatus instanceViewStatus1 = mock(InstanceViewStatus.class);\n    InstanceViewStatus instanceViewStatus2 = mock(InstanceViewStatus.class);\n    when(instanceViewStatus1.message()).thenReturn(\"logs 1\");\n    when(instanceViewStatus2.message()).thenReturn(\"logs 2\");\n    when(runCommandResult.value()).thenReturn(Arrays.asList(instanceViewStatus1, instanceViewStatus2));\n    when(mockStrategy.runScript(\"AGENTS\", \"vmName\", mockVirtualMachines, \"custom script\")).thenReturn(runCommandResult);\n    String logs = goCDAzureClient.runCustomScript(mockVMConfig);\n    assertEquals(\"logs 1\\nlogs 2\\n\", logs);\n    verify(azure).virtualMachines();\n    verify(mockStrategy).runScript(\"AGENTS\", \"vmName\", mockVirtualMachines, \"custom script\");\n  }\n  @Test\n  void testStartAgentShouldInvokeCommand() {\n    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);\n    VmConfig mockVMConfig = mock(VmConfig.class, RETURNS_DEEP_STUBS);\n    AgentConfig agentConfig = mock(AgentConfig.class);\n    PlatformConfigStrategy mockStrategy = mock(PlatformConfigStrategy.class, RETURNS_DEEP_STUBS);\n    VirtualMachines mockVirtualMachines = mock(VirtualMachines.class);\n    when(mockVMConfig.getPlatformStrategy()).thenReturn(mockStrategy);\n    when(mockVMConfig.getName()).thenReturn(\"vmName\");\n    when(mockVMConfig.getResourceGroup()).thenReturn(\"AGENTS\");\n    when(mockVMConfig.getAgentConfig()).thenReturn(agentConfig);\n    when(azure.virtualMachines()).thenReturn(mockVirtualMachines);\n    goCDAzureClient.startAgent(mockVMConfig);\n    verify(azure).virtualMachines();\n    verify(mockStrategy).startAgent(\"AGENTS\", \"vmName\", mockVirtualMachines, agentConfig);\n  }\n  @Test\n  void testInstallAgentShouldInvokeCommand() throws ProvisionFailedException {\n    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);\n    VmConfig mockVMConfig = mock(VmConfig.class, RETURNS_DEEP_STUBS);\n    PlatformConfigStrategy mockStrategy = mock(PlatformConfigStrategy.class, RETURNS_DEEP_STUBS);\n    VirtualMachines mockVirtualMachines = mock(VirtualMachines.class);\n    when(mockVMConfig.getPlatformStrategy()).thenReturn(mockStrategy);\n    when(azure.virtualMachines()).thenReturn(mockVirtualMachines);\n    goCDAzureClient.installGoAgent(mockVMConfig);\n    verify(azure).virtualMachines();\n    verify(mockStrategy).installGoAgent(mockVirtualMachines, mockVMConfig);\n  }\n  @Test\n  void testShouldReRaiseExceptionAndTerminateVMOnCommandExecutionFailure() {\n    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);\n    VmConfig mockVMConfig = mock(VmConfig.class, RETURNS_DEEP_STUBS);\n    VirtualMachine mockVM = mock(VirtualMachine.class);\n    PlatformConfigStrategy mockStrategy = mock(PlatformConfigStrategy.class);\n    when(mockVMConfig.getCustomScript()).thenReturn(\"custom script\");\n    when(mockVMConfig.getPlatformStrategy()).thenReturn(mockStrategy);\n    when(mockVMConfig.getResourceGroup()).thenReturn(resourceGroup);\n    when(mockVMConfig.getName()).thenReturn(\"Test-123\");\n    when(mockVM.id()).thenReturn(\"/resources/Test-123\");\n    when(azure.virtualMachines().getByResourceGroup(resourceGroup, \"Test-123\")).thenReturn(mockVM);\n    when(mockStrategy.runScript(eq(resourceGroup), eq(\"Test-123\"), any(), eq(\"custom script\")))\n        .thenThrow(new CloudException(\"script failed\",\n            Response.error(500, ResponseBody.create(MediaType.parse(\"application/json\"), \"boom\")),\n            new CloudError()));\n    assertThrows(ProvisionFailedException.class, () -> goCDAzureClient.runCustomScript(mockVMConfig));\n    verify(azure.virtualMachines()).deleteById(\"/resources/Test-123\");\n  }\n  @Test\n  void shouldAddTagToTheVirtualMachine() {\n    VirtualMachine mockVM = mock(VirtualMachine.class);\n    VirtualMachine mockVMWithTags = mock(VirtualMachine.class);\n    Update mockUpdate = mock(Update.class, RETURNS_DEEP_STUBS);\n    when(mockVM.update()).thenReturn(mockUpdate);\n    when(azure.virtualMachines().getById(\"vm-id\")).thenReturn(mockVM);\n    when(mockUpdate.withTag(\"tag-1\", \"value-1\").apply()).thenReturn(mockVMWithTags);\n    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);\n    VirtualMachine vmWithTags = goCDAzureClient.addTag(\"vm-id\", \"tag-1\", \"value-1\");\n    verify(mockUpdate.withTag(\"tag-1\", \"value-1\"), times(1)).apply();\n    assertEquals(mockVMWithTags, vmWithTags);\n  }\n  @Test\n  void shouldRemoveTagFromVirtualMachine() {\n    VirtualMachine mockVM = mock(VirtualMachine.class);\n    VirtualMachine mockVMWithoutTag = mock(VirtualMachine.class);\n    Update mockUpdate = mock(Update.class, RETURNS_DEEP_STUBS);\n    when(mockVM.update()).thenReturn(mockUpdate);\n    when(azure.virtualMachines().getById(\"vm-id\")).thenReturn(mockVM);\n    when(mockUpdate.withoutTag(\"tag-1\").apply()).thenReturn(mockVMWithoutTag);\n    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);\n    VirtualMachine vmWithoutTags = goCDAzureClient.removeTag(\"vm-id\", \"tag-1\");\n    verify(mockUpdate.withoutTag(\"tag-1\"), times(1)).apply();\n    assertEquals(mockVMWithoutTag, vmWithoutTags);\n  }\n  @Test\n  void shouldCleanupNICOnVMCreationFailure() {\n    VmConfig mockVMConfig = mock(VmConfig.class, RETURNS_DEEP_STUBS);\n    NetworkInterface mockNic = mock(NetworkInterface.class);\n    when(mockVMConfig.getName()).thenReturn(\"vm-123\");\n    when(mockVMConfig.getNetworkInterfaceName()).thenReturn(\"nic-vm-123\");\n    when(mockVMConfig.getJobIdentifier().getRepresentation()).thenReturn(\"jobid\");\n    when(azure.virtualMachines().define(\"vm-123\")).thenThrow(new RuntimeException(\"boom\"));\n    when(azure.virtualMachines().getByResourceGroup(anyString(), anyString())).thenReturn(null);\n    when(azure.networkInterfaces().getByResourceGroup(resourceGroup, \"nic-vm-123\")).thenReturn(mockNic);\n    when(mockNic.id()).thenReturn(\"nicId\");\n    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);\n    ProvisionFailedException exception = assertThrows(ProvisionFailedException.class, () -> goCDAzureClient.createVM(mockVMConfig));\n    assertEquals(\"Failed to create vm with name vm-123 for job jobid due to error: boom\", exception.getMessage());\n    verify(azure.networkInterfaces()).getByResourceGroup(resourceGroup, \"nic-vm-123\");\n    verify(azure.networkInterfaces()).deleteById(\"nicId\");\n  }\n  @Test\n  void shouldValidateTheImageURNChosenIsCorrespondingToThePlatformSelected() {\n    VirtualMachineImage mockVMImage = mock(VirtualMachineImage.class);\n    OSDiskImage mockDiskImage = mock(OSDiskImage.class);\n    when(mockDiskImage.operatingSystem()).thenReturn(OperatingSystemTypes.LINUX);\n    when(mockVMImage.osDiskImage()).thenReturn(mockDiskImage);\n    when(azure.virtualMachineImages().getImage(Region.INDIA_SOUTH, \"pub-1\", \"offer-1\", \"sku-1\", \"version-1\")).thenReturn(mockVMImage);\n    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);\n    assertFalse(goCDAzureClient.imageValidForPlatform(new ImageURN(\"pub-1:offer-1:sku-1:version-1\"), Platform.WINDOWS, Region.INDIA_SOUTH));\n    assertTrue(goCDAzureClient.imageValidForPlatform(new ImageURN(\"pub-1:offer-1:sku-1:version-1\"), Platform.LINUX, Region.INDIA_SOUTH));\n  }\n  @Test\n  void shouldTerminateVMAlongWithAssociatedResources() {\n    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);\n    VirtualMachine vm = mock(VirtualMachine.class);\n    when(azure.virtualMachines().getById(\"resource-id-to-be-deleted\")).thenReturn(vm);\n    when(vm.id()).thenReturn(\"resource-id-to-be-deleted\");\n    when(vm.osDiskId()).thenReturn(\"os-disk-id\");\n    when(vm.dataDisks()).thenReturn(Collections.emptyMap());\n    when(vm.networkInterfaceIds()).thenReturn(asList(\"nic-1\"));\n    goCDAzureClient.terminate(\"resource-id-to-be-deleted\");\n    verify(azure.virtualMachines()).deleteById(\"resource-id-to-be-deleted\");\n    verify(azure.disks()).deleteById(\"os-disk-id\");\n    verify(azure.networkInterfaces()).deleteById(\"nic-1\");\n  }\n  @Test\n  void shouldTerminateVMIfNICAndDiskIsNotAttached() {\n    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);\n    VirtualMachine vm = mock(VirtualMachine.class);\n    when(azure.virtualMachines().getById(\"resource-id-to-be-deleted\")).thenReturn(vm);\n    when(vm.id()).thenReturn(\"resource-id-to-be-deleted\");\n    when(vm.osDiskId()).thenReturn(null);\n    when(vm.dataDisks()).thenReturn(Collections.emptyMap());\n    when(vm.networkInterfaceIds()).thenReturn(asList(\"\"));\n    goCDAzureClient.terminate(\"resource-id-to-be-deleted\");\n    verify(azure.virtualMachines()).deleteById(\"resource-id-to-be-deleted\");\n    verify(azure.disks(), never()).deleteById(null);\n    verify(azure.networkInterfaces(), never()).deleteById(null);\n  }\n"]]}
{"hexsha": "6bc8ee2c40dd91b5ee529c3fce1b9c0109ad3e5e", "ext": "java", "lang": "Java", "content": "public class DefaultQueryParser extends QueryParserBase<SolrDataQuery> {\n\n\tprivate static final Logger LOGGER = LoggerFactory.getLogger(DefaultQueryParser.class);\n\n\t/**\n\t * Convert given Query into a SolrQuery executable via {@link org.apache.solr.client.solrj.SolrClient}\n\t * \n\t * @param query\n\t * @return\n\t */\n\t@Override\n\tpublic final SolrQuery doConstructSolrQuery(SolrDataQuery query) {\n\t\tAssert.notNull(query, \"Cannot construct solrQuery from null value.\");\n\t\tAssert.notNull(query.getCriteria(), \"Query has to have a criteria.\");\n\t\t\n\t\tSolrQuery solrQuery = new SolrQuery();\n\t\tsolrQuery.setParam(CommonParams.Q, getQueryString(query));\n\t\tif (query instanceof Query) {\n\t\t\tprocessQueryOptions(solrQuery, (Query) query);\n\t\t}\n\t\tif (query instanceof FacetQuery) {\n\t\t\tprocessFacetOptions(solrQuery, (FacetQuery) query);\n\t\t}\n\t\tif (query instanceof HighlightQuery) {\n\t\t\tprocessHighlightOptions(solrQuery, (HighlightQuery) query);\n\t\t}\n\n\t\treturn solrQuery;\n\t}\n\n\tprivate void processQueryOptions(SolrQuery solrQuery, Query query) {\n\t\tappendPagination(solrQuery, query.getOffset(), query.getRows());\n\t\tappendProjectionOnFields(solrQuery, query.getProjectionOnFields());\n\t\tappendFilterQuery(solrQuery, query.getFilterQueries());\n\t\tappendSort(solrQuery, query.getSort());\n\t\tappendDefaultOperator(solrQuery, query.getDefaultOperator());\n\t\tappendTimeAllowed(solrQuery, query.getTimeAllowed());\n\t\tappendDefType(solrQuery, query.getDefType());\n\t\tappendRequestHandler(solrQuery, query.getRequestHandler());\n\t\tappendReRankQueryHandler(solrQuery,query.getRqqValue());\n\n\t\tprocessGroupOptions(solrQuery, query);\n\t\tprocessStatsOptions(solrQuery, query);\n\t\tprocessSpellcheckOptions(solrQuery, query);\n\n\t\tLOGGER.info(solrQuery.toQueryString());\n\t\t\n\t\tif (LOGGER.isDebugEnabled()) {\n\t\t\tLOGGER.debug(\"Constructed SolrQuery:\\r\\n %s\", solrQuery);\n\t\t}\n\t}\n\n\t/**\n\t * @param solrQuery\n\t * @param rqqValue\n\t */\n\tprivate void appendReRankQueryHandler(SolrQuery solrQuery, String rqqValue) {\n\t\tif(StringUtils.isNotBlank(rqqValue)) {\n\t\t\tsolrQuery.set(\"rq\", \"{!rerank reRankQuery=$rqq reRankDocs=1000 reRankWeight=3}\");\n\t\t\tsolrQuery.set(\"rqq\", rqqValue);\n\t\t}\n\t}\n\n\tprivate void processFacetOptions(SolrQuery solrQuery, FacetQuery query) {\n\t\tif (enableFaceting(solrQuery, query)) {\n\t\t\tappendFacetingOnFields(solrQuery, (FacetQuery) query);\n\t\t\tappendFacetingQueries(solrQuery, (FacetQuery) query);\n\t\t\tappendFacetingOnPivot(solrQuery, (FacetQuery) query);\n\t\t\tappendRangeFacetingOnFields(solrQuery, (FacetQuery) query);\n\t\t}\n\t}\n\n\tprivate void setObjectNameOnGroupQuery(Query query, Object object, String name) {\n\n\t\tif (query instanceof NamedObjectsQuery) {\n\t\t\t((NamedObjectsQuery) query).setName(object, name);\n\t\t}\n\t}\n\n\tprivate void processStatsOptions(SolrQuery solrQuery, Query query) {\n\t\tStatsOptions statsOptions = query.getStatsOptions();\n\n\t\tif (statsOptions == null\n\t\t\t\t|| (CollectionUtils.isEmpty(statsOptions.getFields()) && CollectionUtils.isEmpty(statsOptions.getFacets())\n\t\t\t\t\t\t&& CollectionUtils.isEmpty(statsOptions.getSelectiveFacets()))) {\n\t\t\treturn;\n\t\t}\n\n\t\tsolrQuery.set(StatsParams.STATS, true);\n\n\t\tfor (Field field : statsOptions.getFields()) {\n\t\t\tsolrQuery.add(StatsParams.STATS_FIELD, field.getName());\n\n\t\t\tString selectiveCalcDistinctParam = CommonParams.FIELD + \".\" + field.getName() + \".\"\n\t\t\t\t\t+ StatsParams.STATS_CALC_DISTINCT;\n\t\t\tBoolean selectiveCountDistincts = statsOptions.isSelectiveCalcDistincts(field);\n\n\t\t\tif (selectiveCountDistincts != null) {\n\t\t\t\tsolrQuery.add(selectiveCalcDistinctParam, String.valueOf(selectiveCountDistincts.booleanValue()));\n\t\t\t}\n\n\t\t}\n\n\t\tfor (Field field : statsOptions.getFacets()) {\n\t\t\tsolrQuery.add(StatsParams.STATS_FACET, field.getName());\n\t\t}\n\n\t\tfor (Entry<Field, Collection<Field>> entry : statsOptions.getSelectiveFacets().entrySet()) {\n\n\t\t\tField field = entry.getKey();\n\t\t\tString prefix = CommonParams.FIELD + \".\" + field.getName() + \".\";\n\n\t\t\tString paramName = prefix + StatsParams.STATS_FACET;\n\t\t\tfor (Field facetField : entry.getValue()) {\n\t\t\t\tsolrQuery.add(paramName, facetField.getName());\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tprivate void processGroupOptions(SolrQuery solrQuery, Query query) {\n\n\t\tGroupOptions groupOptions = query.getGroupOptions();\n\n\t\tif (groupOptions == null || (CollectionUtils.isEmpty(groupOptions.getGroupByFields())\n\t\t\t\t&& CollectionUtils.isEmpty(groupOptions.getGroupByFunctions())\n\t\t\t\t&& CollectionUtils.isEmpty(groupOptions.getGroupByQueries()))) {\n\t\t\treturn;\n\t\t}\n\n\t\tsolrQuery.set(GroupParams.GROUP, true);\n\t\tsolrQuery.set(GroupParams.GROUP_MAIN, groupOptions.isGroupMain());\n\t\tsolrQuery.set(GroupParams.GROUP_FORMAT, \"grouped\");\n\n\t\tif (!CollectionUtils.isEmpty(groupOptions.getGroupByFields())) {\n\t\t\tfor (Field field : groupOptions.getGroupByFields()) {\n\t\t\t\tsolrQuery.add(GroupParams.GROUP_FIELD, field.getName());\n\t\t\t}\n\t\t}\n\n\t\tif (!CollectionUtils.isEmpty(groupOptions.getGroupByFunctions())) {\n\t\t\tfor (Function function : groupOptions.getGroupByFunctions()) {\n\t\t\t\tString functionFragment = createFunctionFragment(function, 0);\n\t\t\t\tsetObjectNameOnGroupQuery(query, function, functionFragment);\n\t\t\t\tsolrQuery.add(GroupParams.GROUP_FUNC, functionFragment);\n\t\t\t}\n\t\t}\n\n\t\tif (!CollectionUtils.isEmpty(groupOptions.getGroupByQueries())) {\n\t\t\tfor (Query groupQuery : groupOptions.getGroupByQueries()) {\n\t\t\t\tString queryFragment = getQueryString(groupQuery);\n\t\t\t\tsetObjectNameOnGroupQuery(query, groupQuery, queryFragment);\n\t\t\t\tsolrQuery.add(GroupParams.GROUP_QUERY, queryFragment);\n\t\t\t}\n\t\t}\n\n\t\tif (groupOptions.getSort() != null) {\n\n\t\t\tfor (Order order : groupOptions.getSort()) {\n\t\t\t\tsolrQuery.add(GroupParams.GROUP_SORT,\n\t\t\t\t\t\torder.getProperty().trim() + \" \" + (order.isAscending() ? ORDER.asc : ORDER.desc));\n\t\t\t}\n\t\t}\n\n\t\tif (groupOptions.getCachePercent() > 0) {\n\t\t\tsolrQuery.add(GroupParams.GROUP_CACHE_PERCENTAGE, String.valueOf(groupOptions.getCachePercent()));\n\t\t}\n\n\t\tif (groupOptions.getLimit() != null) {\n\t\t\tsolrQuery.set(GroupParams.GROUP_LIMIT, groupOptions.getLimit());\n\t\t}\n\n\t\tif (groupOptions.getOffset() != null && groupOptions.getOffset() >= 0) {\n\t\t\tsolrQuery.set(GroupParams.GROUP_OFFSET, groupOptions.getOffset());\n\t\t}\n\n\t\tsolrQuery.set(GroupParams.GROUP_TOTAL_COUNT, groupOptions.isTotalCount());\n\t\tsolrQuery.set(GroupParams.GROUP_FACET, groupOptions.isGroupFacets());\n\t\tsolrQuery.set(GroupParams.GROUP_TRUNCATE, groupOptions.isTruncateFacets());\n\t}\n\n\tprivate void processSpellcheckOptions(SolrQuery solrQuery, Query query) {\n\n\t\tif (query.getSpellcheckOptions() == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tSpellcheckOptions options = query.getSpellcheckOptions();\n\n\t\tif (options.getQuery() != null && options.getQuery().getCriteria() != null) {\n\t\t\tsolrQuery.set(SpellingParams.SPELLCHECK_Q, createQueryStringFromCriteria(options.getQuery().getCriteria()));\n\t\t}\n\n\t\tModifiableSolrParams params = new ModifiableSolrParams();\n\t\tparams.add(\"spellcheck\", \"on\");\n\t\tfor (Entry<String, Object> entry : options.getParams().entrySet()) {\n\n\t\t\tif (entry.getValue() instanceof Iterable<?>) {\n\t\t\t\tfor (Object o : ((Iterable<?>) entry.getValue())) {\n\t\t\t\t\tparams.add(entry.getKey(), o.toString());\n\t\t\t\t}\n\t\t\t} else if (ObjectUtils.isArray(entry.getValue())) {\n\t\t\t\tfor (Object o : ObjectUtils.toObjectArray(entry.getValue())) {\n\t\t\t\t\tparams.add(entry.getKey(), o.toString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tparams.add(entry.getKey(), entry.getValue().toString());\n\t\t\t}\n\t\t}\n\t\tsolrQuery.add(params);\n\t}\n\n\t/**\n\t * Append highlighting parameters to {@link SolrQuery}\n\t * \n\t * @param solrQuery\n\t * @param query\n\t */\n\tprotected void processHighlightOptions(SolrQuery solrQuery, HighlightQuery query) {\n\t\tif (query.hasHighlightOptions()) {\n\t\t\tHighlightOptions highlightOptions = query.getHighlightOptions();\n\t\t\tsolrQuery.setHighlight(true);\n\t\t\tif (!highlightOptions.hasFields()) {\n\t\t\t\tsolrQuery.addHighlightField(HighlightOptions.ALL_FIELDS.getName());\n\t\t\t} else {\n\t\t\t\tfor (Field field : highlightOptions.getFields()) {\n\t\t\t\t\tsolrQuery.addHighlightField(field.getName());\n\t\t\t\t}\n\t\t\t\tfor (FieldWithHighlightParameters fieldWithHighlightParameters : highlightOptions\n\t\t\t\t\t\t.getFieldsWithHighlightParameters()) {\n\t\t\t\t\taddPerFieldHighlightParameters(solrQuery, fieldWithHighlightParameters);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (HighlightParameter option : highlightOptions.getHighlightParameters()) {\n\t\t\t\taddOptionToSolrQuery(solrQuery, option);\n\t\t\t}\n\t\t\tif (highlightOptions.hasQuery()) {\n\t\t\t\tsolrQuery.add(HighlightParams.Q, getQueryString(highlightOptions.getQuery()));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void addOptionToSolrQuery(SolrQuery solrQuery, QueryParameter option) {\n\t\tif (option != null && StringUtils.isNotBlank(option.getName())) {\n\t\t\tsolrQuery.add(option.getName(), conversionService.convert(option.getValue(), String.class));\n\t\t}\n\t}\n\n\tprivate void addFieldSpecificParameterToSolrQuery(SolrQuery solrQuery, Field field, QueryParameter option) {\n\t\tif (option != null && field != null && StringUtils.isNotBlank(option.getName())) {\n\t\t\tif (option.getValue() == null) {\n\t\t\t\tsolrQuery.add(createPerFieldOverrideParameterName(field, option.getName()), (String) null);\n\t\t\t} else {\n\t\t\t\tString value = option.getValue().toString();\n\t\t\t\tif (conversionService.canConvert(option.getValue().getClass(), String.class)) {\n\t\t\t\t\tvalue = conversionService.convert(option.getValue(), String.class);\n\t\t\t\t}\n\t\t\t\tsolrQuery.add(createPerFieldOverrideParameterName(field, option.getName()), value);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void addPerFieldHighlightParameters(SolrQuery solrQuery, FieldWithHighlightParameters field) {\n\t\tfor (HighlightParameter option : field) {\n\t\t\taddFieldSpecificParameterToSolrQuery(solrQuery, field, option);\n\t\t}\n\t}\n\n\tprotected String createPerFieldOverrideParameterName(Field field, String parameterName) {\n\t\treturn \"f.\" + field.getName() + \".\" + parameterName;\n\t}\n\n\tprivate boolean enableFaceting(SolrQuery solrQuery, FacetQuery query) {\n\t\tFacetOptions facetOptions = query.getFacetOptions();\n\t\tif (facetOptions == null || !facetOptions.hasFacets()) {\n\t\t\treturn false;\n\t\t}\n\t\tsolrQuery.setFacet(true);\n\t\tsolrQuery.setFacetMinCount(facetOptions.getFacetMinCount());\n\t\tsolrQuery.setFacetLimit(facetOptions.getPageable().getPageSize());\n\t\tif (facetOptions.getPageable().getPageNumber() > 0) {\n\t\t\tlong offset = Math.max(0, facetOptions.getPageable().getOffset());\n\t\t\tsolrQuery.set(FacetParams.FACET_OFFSET, \"\" + offset);\n\t\t}\n\t\tif (FacetOptions.FacetSort.INDEX.equals(facetOptions.getFacetSort())) {\n\t\t\tsolrQuery.setFacetSort(FacetParams.FACET_SORT_INDEX);\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate void appendFacetingOnFields(SolrQuery solrQuery, FacetQuery query) {\n\t\tFacetOptions facetOptions = query.getFacetOptions();\n\t\tsolrQuery.addFacetField(convertFieldListToStringArray(facetOptions.getFacetOnFields()));\n\t\tif (facetOptions.hasFacetPrefix()) {\n\t\t\tsolrQuery.setFacetPrefix(facetOptions.getFacetPrefix());\n\t\t}\n\t\tfor (FieldWithFacetParameters parametrizedField : facetOptions.getFieldsWithParameters()) {\n\t\t\taddPerFieldFacetParameters(solrQuery, parametrizedField);\n\t\t\tif (parametrizedField.getSort() != null && FacetOptions.FacetSort.INDEX.equals(parametrizedField.getSort())) {\n\t\t\t\taddFieldSpecificParameterToSolrQuery(solrQuery, parametrizedField,\n\t\t\t\t\t\tnew FacetParameter(FacetParams.FACET_SORT, FacetParams.FACET_SORT_INDEX));\n\t\t\t}\n\n\t\t}\n\t}\n\n\tprivate void addPerFieldFacetParameters(SolrQuery solrQuery, FieldWithFacetParameters field) {\n\t\tfor (FacetParameter parameter : field) {\n\t\t\taddFieldSpecificParameterToSolrQuery(solrQuery, field, parameter);\n\t\t}\n\t}\n\n\tprivate void appendRangeFacetingOnFields(SolrQuery solrQuery, FacetQuery query) {\n\t\tFacetOptions facetRangeOptions = query.getFacetOptions();\n\n\t\tif (facetRangeOptions == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (FieldWithRangeParameters<?, ?, ?> rangeField : facetRangeOptions.getFieldsWithRangeParameters()) {\n\n\t\t\tif (rangeField instanceof FieldWithDateRangeParameters) {\n\t\t\t\tappendFieldFacetingByDateRange(solrQuery, (FieldWithDateRangeParameters) rangeField);\n\t\t\t} else if (rangeField instanceof FieldWithNumericRangeParameters) {\n\t\t\t\tappendFieldFacetingByNumberRange(solrQuery, (FieldWithNumericRangeParameters) rangeField);\n\t\t\t}\n\n\t\t\tif (rangeField.getHardEnd() != null && rangeField.getHardEnd()) {\n\t\t\t\tFacetParameter param = new FacetParameter(FacetParams.FACET_RANGE_HARD_END, true);\n\t\t\t\taddFieldSpecificParameterToSolrQuery(solrQuery, rangeField, param);\n\t\t\t}\n\t\t\tif (rangeField.getOther() != null) {\n\t\t\t\tFacetParameter param = new FacetParameter(FacetParams.FACET_RANGE_OTHER, rangeField.getOther());\n\t\t\t\taddFieldSpecificParameterToSolrQuery(solrQuery, rangeField, param);\n\t\t\t}\n\n\t\t\tif (rangeField.getInclude() != null) {\n\t\t\t\tFacetParameter param = new FacetParameter(FacetParams.FACET_RANGE_INCLUDE, rangeField.getInclude());\n\t\t\t\taddFieldSpecificParameterToSolrQuery(solrQuery, rangeField, param);\n\t\t\t}\n\n\t\t}\n\t}\n\n\tprivate void appendFieldFacetingByNumberRange(SolrQuery solrQuery, FieldWithNumericRangeParameters field) {\n\t\tsolrQuery.addNumericRangeFacet( //\n\t\t\t\tfield.getName(), //\n\t\t\t\tfield.getStart(), //\n\t\t\t\tfield.getEnd(), //\n\t\t\t\tfield.getGap());\n\t}\n\n\tprivate void appendFieldFacetingByDateRange(SolrQuery solrQuery, FieldWithDateRangeParameters field) {\n\t\tsolrQuery.addDateRangeFacet( //\n\t\t\t\tfield.getName(), //\n\t\t\t\tfield.getStart(), //\n\t\t\t\tfield.getEnd(), //\n\t\t\t\tfield.getGap());\n\t}\n\n\tprivate void appendFacetingQueries(SolrQuery solrQuery, FacetQuery query) {\n\t\tFacetOptions facetOptions = query.getFacetOptions();\n\t\tfor (SolrDataQuery fq : facetOptions.getFacetQueries()) {\n\t\t\tString facetQueryString = getQueryString(fq);\n\t\t\tif (StringUtils.isNotBlank(facetQueryString)) {\n\t\t\t\tsolrQuery.addFacetQuery(facetQueryString);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void appendFacetingOnPivot(SolrQuery solrQuery, FacetQuery query) {\n\n\t\tFacetOptions facetOptions = query.getFacetOptions();\n\t\tString[] pivotFields = convertFieldListToStringArray(facetOptions.getFacetOnPivots());\n\t\tsolrQuery.addFacetPivotField(pivotFields);\n\t}\n\n\t/**\n\t * Set filter filter queries for {@link SolrQuery}\n\t * \n\t * @param solrQuery\n\t * @param filterQueries\n\t */\n\tprotected void appendFilterQuery(SolrQuery solrQuery, List<FilterQuery> filterQueries) {\n\t\tif (CollectionUtils.isEmpty(filterQueries)) {\n\t\t\treturn;\n\t\t}\n\t\tList<String> filterQueryStrings = getFilterQueryStrings(filterQueries);\n\n\t\tif (!filterQueryStrings.isEmpty()) {\n\t\t\tsolrQuery.setFilterQueries(convertStringListToArray(filterQueryStrings));\n\t\t}\n\t}\n\n\t/**\n\t * Append sorting parameters to {@link SolrQuery}\n\t * \n\t * @param solrQuery\n\t * @param sort\n\t */\n\tprotected void appendSort(SolrQuery solrQuery, @Nullable Sort sort) {\n\t\tif (sort == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (Order order : sort) {\n\t\t\tsolrQuery.addSort(order.getProperty(), order.isAscending() ? ORDER.asc : ORDER.desc);\n\t\t}\n\t}\n\n\tprivate String[] convertFieldListToStringArray(List<? extends Field> fields) {\n\t\tString[] strResult = new String[fields.size()];\n\t\tfor (int i = 0; i < fields.size(); i++) {\n\t\t\tstrResult[i] = fields.get(i).getName();\n\t\t}\n\t\treturn strResult;\n\t}\n\n\tprivate String[] convertStringListToArray(List<String> listOfString) {\n\t\tString[] strResult = new String[listOfString.size()];\n\t\tlistOfString.toArray(strResult);\n\t\treturn strResult;\n\t}\n\n\tprivate List<String> getFilterQueryStrings(List<FilterQuery> filterQueries) {\n\t\tList<String> filterQueryStrings = new ArrayList<>(filterQueries.size());\n\n\t\tfor (FilterQuery filterQuery : filterQueries) {\n\t\t\tString filterQueryString = getQueryString(filterQuery);\n\t\t\tif (StringUtils.isNotBlank(filterQueryString)) {\n\t\t\t\tfilterQueryStrings.add(filterQueryString);\n\t\t\t}\n\t\t}\n\t\treturn filterQueryStrings;\n\t}\n\n}", "class_id": 0, "repo": "Navneet-gupta01/spring-data-solr2", "file": "src/main/java/org/springframework/data/solr/core/DefaultQueryParser.java", "last_update_at": "2020-02-12T19:40:19+00:00", "question_id": "6bc8ee2c40dd91b5ee529c3fce1b9c0109ad3e5e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DefaultQueryParser extends QueryParserBase<SolrDataQuery> {\n\tprivate static final Logger LOGGER = LoggerFactory.getLogger(DefaultQueryParser.class);\n\t/**\n\t * Convert given Query into a SolrQuery executable via {@link org.apache.solr.client.solrj.SolrClient}\n\t * \n\t * @param query\n\t * @return\n\t */\n\t@Override\n\tpublic final SolrQuery doConstructSolrQuery(SolrDataQuery query) {\n\t\tAssert.notNull(query, \"Cannot construct solrQuery from null value.\");\n\t\tAssert.notNull(query.getCriteria(), \"Query has to have a criteria.\");\n\t\t\n\t\tSolrQuery solrQuery = new SolrQuery();\n\t\tsolrQuery.setParam(CommonParams.Q, getQueryString(query));\n\t\tif (query instanceof Query) {\n\t\t\tprocessQueryOptions(solrQuery, (Query) query);\n\t\t}\n\t\tif (query instanceof FacetQuery) {\n\t\t\tprocessFacetOptions(solrQuery, (FacetQuery) query);\n\t\t}\n\t\tif (query instanceof HighlightQuery) {\n\t\t\tprocessHighlightOptions(solrQuery, (HighlightQuery) query);\n\t\t}\n\t\treturn solrQuery;\n\t}\n\tprivate void processQueryOptions(SolrQuery solrQuery, Query query) {\n\t\tappendPagination(solrQuery, query.getOffset(), query.getRows());\n\t\tappendProjectionOnFields(solrQuery, query.getProjectionOnFields());\n\t\tappendFilterQuery(solrQuery, query.getFilterQueries());\n\t\tappendSort(solrQuery, query.getSort());\n\t\tappendDefaultOperator(solrQuery, query.getDefaultOperator());\n\t\tappendTimeAllowed(solrQuery, query.getTimeAllowed());\n\t\tappendDefType(solrQuery, query.getDefType());\n\t\tappendRequestHandler(solrQuery, query.getRequestHandler());\n\t\tappendReRankQueryHandler(solrQuery,query.getRqqValue());\n\t\tprocessGroupOptions(solrQuery, query);\n\t\tprocessStatsOptions(solrQuery, query);\n\t\tprocessSpellcheckOptions(solrQuery, query);\n\t\tLOGGER.info(solrQuery.toQueryString());\n\t\t\n\t\tif (LOGGER.isDebugEnabled()) {\n\t\t\tLOGGER.debug(\"Constructed SolrQuery:\\r\\n %s\", solrQuery);\n\t\t}\n\t}\n\t/**\n\t * @param solrQuery\n\t * @param rqqValue\n\t */\n\tprivate void appendReRankQueryHandler(SolrQuery solrQuery, String rqqValue) {\n\t\tif(StringUtils.isNotBlank(rqqValue)) {\n\t\t\tsolrQuery.set(\"rq\", \"{!rerank reRankQuery=$rqq reRankDocs=1000 reRankWeight=3}\");\n\t\t\tsolrQuery.set(\"rqq\", rqqValue);\n\t\t}\n\t}\n\tprivate void processFacetOptions(SolrQuery solrQuery, FacetQuery query) {\n\t\tif (enableFaceting(solrQuery, query)) {\n\t\t\tappendFacetingOnFields(solrQuery, (FacetQuery) query);\n\t\t\tappendFacetingQueries(solrQuery, (FacetQuery) query);\n\t\t\tappendFacetingOnPivot(solrQuery, (FacetQuery) query);\n\t\t\tappendRangeFacetingOnFields(solrQuery, (FacetQuery) query);\n\t\t}\n\t}\n\tprivate void setObjectNameOnGroupQuery(Query query, Object object, String name) {\n\t\tif (query instanceof NamedObjectsQuery) {\n\t\t\t((NamedObjectsQuery) query).setName(object, name);\n\t\t}\n\t}\n\tprivate void processStatsOptions(SolrQuery solrQuery, Query query) {\n\t\tStatsOptions statsOptions = query.getStatsOptions();\n\t\tif (statsOptions == null\n\t\t\t\t|| (CollectionUtils.isEmpty(statsOptions.getFields()) && CollectionUtils.isEmpty(statsOptions.getFacets())\n\t\t\t\t\t\t&& CollectionUtils.isEmpty(statsOptions.getSelectiveFacets()))) {\n\t\t\treturn;\n\t\t}\n\t\tsolrQuery.set(StatsParams.STATS, true);\n\t\tfor (Field field : statsOptions.getFields()) {\n\t\t\tsolrQuery.add(StatsParams.STATS_FIELD, field.getName());\n\t\t\tString selectiveCalcDistinctParam = CommonParams.FIELD + \".\" + field.getName() + \".\"\n\t\t\t\t\t+ StatsParams.STATS_CALC_DISTINCT;\n\t\t\tBoolean selectiveCountDistincts = statsOptions.isSelectiveCalcDistincts(field);\n\t\t\tif (selectiveCountDistincts != null) {\n\t\t\t\tsolrQuery.add(selectiveCalcDistinctParam, String.valueOf(selectiveCountDistincts.booleanValue()));\n\t\t\t}\n\t\t}\n\t\tfor (Field field : statsOptions.getFacets()) {\n\t\t\tsolrQuery.add(StatsParams.STATS_FACET, field.getName());\n\t\t}\n\t\tfor (Entry<Field, Collection<Field>> entry : statsOptions.getSelectiveFacets().entrySet()) {\n\t\t\tField field = entry.getKey();\n\t\t\tString prefix = CommonParams.FIELD + \".\" + field.getName() + \".\";\n\t\t\tString paramName = prefix + StatsParams.STATS_FACET;\n\t\t\tfor (Field facetField : entry.getValue()) {\n\t\t\t\tsolrQuery.add(paramName, facetField.getName());\n\t\t\t}\n\t\t}\n\t}\n\tprivate void processGroupOptions(SolrQuery solrQuery, Query query) {\n\t\tGroupOptions groupOptions = query.getGroupOptions();\n\t\tif (groupOptions == null || (CollectionUtils.isEmpty(groupOptions.getGroupByFields())\n\t\t\t\t&& CollectionUtils.isEmpty(groupOptions.getGroupByFunctions())\n\t\t\t\t&& CollectionUtils.isEmpty(groupOptions.getGroupByQueries()))) {\n\t\t\treturn;\n\t\t}\n\t\tsolrQuery.set(GroupParams.GROUP, true);\n\t\tsolrQuery.set(GroupParams.GROUP_MAIN, groupOptions.isGroupMain());\n\t\tsolrQuery.set(GroupParams.GROUP_FORMAT, \"grouped\");\n\t\tif (!CollectionUtils.isEmpty(groupOptions.getGroupByFields())) {\n\t\t\tfor (Field field : groupOptions.getGroupByFields()) {\n\t\t\t\tsolrQuery.add(GroupParams.GROUP_FIELD, field.getName());\n\t\t\t}\n\t\t}\n\t\tif (!CollectionUtils.isEmpty(groupOptions.getGroupByFunctions())) {\n\t\t\tfor (Function function : groupOptions.getGroupByFunctions()) {\n\t\t\t\tString functionFragment = createFunctionFragment(function, 0);\n\t\t\t\tsetObjectNameOnGroupQuery(query, function, functionFragment);\n\t\t\t\tsolrQuery.add(GroupParams.GROUP_FUNC, functionFragment);\n\t\t\t}\n\t\t}\n\t\tif (!CollectionUtils.isEmpty(groupOptions.getGroupByQueries())) {\n\t\t\tfor (Query groupQuery : groupOptions.getGroupByQueries()) {\n\t\t\t\tString queryFragment = getQueryString(groupQuery);\n\t\t\t\tsetObjectNameOnGroupQuery(query, groupQuery, queryFragment);\n\t\t\t\tsolrQuery.add(GroupParams.GROUP_QUERY, queryFragment);\n\t\t\t}\n\t\t}\n\t\tif (groupOptions.getSort() != null) {\n\t\t\tfor (Order order : groupOptions.getSort()) {\n\t\t\t\tsolrQuery.add(GroupParams.GROUP_SORT,\n\t\t\t\t\t\torder.getProperty().trim() + \" \" + (order.isAscending() ? ORDER.asc : ORDER.desc));\n\t\t\t}\n\t\t}\n\t\tif (groupOptions.getCachePercent() > 0) {\n\t\t\tsolrQuery.add(GroupParams.GROUP_CACHE_PERCENTAGE, String.valueOf(groupOptions.getCachePercent()));\n\t\t}\n\t\tif (groupOptions.getLimit() != null) {\n\t\t\tsolrQuery.set(GroupParams.GROUP_LIMIT, groupOptions.getLimit());\n\t\t}\n\t\tif (groupOptions.getOffset() != null && groupOptions.getOffset() >= 0) {\n\t\t\tsolrQuery.set(GroupParams.GROUP_OFFSET, groupOptions.getOffset());\n\t\t}\n\t\tsolrQuery.set(GroupParams.GROUP_TOTAL_COUNT, groupOptions.isTotalCount());\n\t\tsolrQuery.set(GroupParams.GROUP_FACET, groupOptions.isGroupFacets());\n\t\tsolrQuery.set(GroupParams.GROUP_TRUNCATE, groupOptions.isTruncateFacets());\n\t}\n\tprivate void processSpellcheckOptions(SolrQuery solrQuery, Query query) {\n\t\tif (query.getSpellcheckOptions() == null) {\n\t\t\treturn;\n\t\t}\n\t\tSpellcheckOptions options = query.getSpellcheckOptions();\n\t\tif (options.getQuery() != null && options.getQuery().getCriteria() != null) {\n\t\t\tsolrQuery.set(SpellingParams.SPELLCHECK_Q, createQueryStringFromCriteria(options.getQuery().getCriteria()));\n\t\t}\n\t\tModifiableSolrParams params = new ModifiableSolrParams();\n\t\tparams.add(\"spellcheck\", \"on\");\n\t\tfor (Entry<String, Object> entry : options.getParams().entrySet()) {\n\t\t\tif (entry.getValue() instanceof Iterable<?>) {\n\t\t\t\tfor (Object o : ((Iterable<?>) entry.getValue())) {\n\t\t\t\t\tparams.add(entry.getKey(), o.toString());\n\t\t\t\t}\n\t\t\t} else if (ObjectUtils.isArray(entry.getValue())) {\n\t\t\t\tfor (Object o : ObjectUtils.toObjectArray(entry.getValue())) {\n\t\t\t\t\tparams.add(entry.getKey(), o.toString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tparams.add(entry.getKey(), entry.getValue().toString());\n\t\t\t}\n\t\t}\n\t\tsolrQuery.add(params);\n\t}\n\t/**\n\t * Append highlighting parameters to {@link SolrQuery}\n\t * \n\t * @param solrQuery\n\t * @param query\n\t */\n\tprotected void processHighlightOptions(SolrQuery solrQuery, HighlightQuery query) {\n\t\tif (query.hasHighlightOptions()) {\n\t\t\tHighlightOptions highlightOptions = query.getHighlightOptions();\n\t\t\tsolrQuery.setHighlight(true);\n\t\t\tif (!highlightOptions.hasFields()) {\n\t\t\t\tsolrQuery.addHighlightField(HighlightOptions.ALL_FIELDS.getName());\n\t\t\t} else {\n\t\t\t\tfor (Field field : highlightOptions.getFields()) {\n\t\t\t\t\tsolrQuery.addHighlightField(field.getName());\n\t\t\t\t}\n\t\t\t\tfor (FieldWithHighlightParameters fieldWithHighlightParameters : highlightOptions\n\t\t\t\t\t\t.getFieldsWithHighlightParameters()) {\n\t\t\t\t\taddPerFieldHighlightParameters(solrQuery, fieldWithHighlightParameters);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (HighlightParameter option : highlightOptions.getHighlightParameters()) {\n\t\t\t\taddOptionToSolrQuery(solrQuery, option);\n\t\t\t}\n\t\t\tif (highlightOptions.hasQuery()) {\n\t\t\t\tsolrQuery.add(HighlightParams.Q, getQueryString(highlightOptions.getQuery()));\n\t\t\t}\n\t\t}\n\t}\n\tprivate void addOptionToSolrQuery(SolrQuery solrQuery, QueryParameter option) {\n\t\tif (option != null && StringUtils.isNotBlank(option.getName())) {\n\t\t\tsolrQuery.add(option.getName(), conversionService.convert(option.getValue(), String.class));\n\t\t}\n\t}\n\tprivate void addFieldSpecificParameterToSolrQuery(SolrQuery solrQuery, Field field, QueryParameter option) {\n\t\tif (option != null && field != null && StringUtils.isNotBlank(option.getName())) {\n\t\t\tif (option.getValue() == null) {\n\t\t\t\tsolrQuery.add(createPerFieldOverrideParameterName(field, option.getName()), (String) null);\n\t\t\t} else {\n\t\t\t\tString value = option.getValue().toString();\n\t\t\t\tif (conversionService.canConvert(option.getValue().getClass(), String.class)) {\n\t\t\t\t\tvalue = conversionService.convert(option.getValue(), String.class);\n\t\t\t\t}\n\t\t\t\tsolrQuery.add(createPerFieldOverrideParameterName(field, option.getName()), value);\n\t\t\t}\n\t\t}\n\t}\n\tprivate void addPerFieldHighlightParameters(SolrQuery solrQuery, FieldWithHighlightParameters field) {\n\t\tfor (HighlightParameter option : field) {\n\t\t\taddFieldSpecificParameterToSolrQuery(solrQuery, field, option);\n\t\t}\n\t}\n\tprotected String createPerFieldOverrideParameterName(Field field, String parameterName) {\n\t\treturn \"f.\" + field.getName() + \".\" + parameterName;\n\t}\n\tprivate boolean enableFaceting(SolrQuery solrQuery, FacetQuery query) {\n\t\tFacetOptions facetOptions = query.getFacetOptions();\n\t\tif (facetOptions == null || !facetOptions.hasFacets()) {\n\t\t\treturn false;\n\t\t}\n\t\tsolrQuery.setFacet(true);\n\t\tsolrQuery.setFacetMinCount(facetOptions.getFacetMinCount());\n\t\tsolrQuery.setFacetLimit(facetOptions.getPageable().getPageSize());\n\t\tif (facetOptions.getPageable().getPageNumber() > 0) {\n\t\t\tlong offset = Math.max(0, facetOptions.getPageable().getOffset());\n\t\t\tsolrQuery.set(FacetParams.FACET_OFFSET, \"\" + offset);\n\t\t}\n\t\tif (FacetOptions.FacetSort.INDEX.equals(facetOptions.getFacetSort())) {\n\t\t\tsolrQuery.setFacetSort(FacetParams.FACET_SORT_INDEX);\n\t\t}\n\t\treturn true;\n\t}\n\tprivate void appendFacetingOnFields(SolrQuery solrQuery, FacetQuery query) {\n\t\tFacetOptions facetOptions = query.getFacetOptions();\n\t\tsolrQuery.addFacetField(convertFieldListToStringArray(facetOptions.getFacetOnFields()));\n\t\tif (facetOptions.hasFacetPrefix()) {\n\t\t\tsolrQuery.setFacetPrefix(facetOptions.getFacetPrefix());\n\t\t}\n\t\tfor (FieldWithFacetParameters parametrizedField : facetOptions.getFieldsWithParameters()) {\n\t\t\taddPerFieldFacetParameters(solrQuery, parametrizedField);\n\t\t\tif (parametrizedField.getSort() != null && FacetOptions.FacetSort.INDEX.equals(parametrizedField.getSort())) {\n\t\t\t\taddFieldSpecificParameterToSolrQuery(solrQuery, parametrizedField,\n\t\t\t\t\t\tnew FacetParameter(FacetParams.FACET_SORT, FacetParams.FACET_SORT_INDEX));\n\t\t\t}\n\t\t}\n\t}\n\tprivate void addPerFieldFacetParameters(SolrQuery solrQuery, FieldWithFacetParameters field) {\n\t\tfor (FacetParameter parameter : field) {\n\t\t\taddFieldSpecificParameterToSolrQuery(solrQuery, field, parameter);\n\t\t}\n\t}\n\tprivate void appendRangeFacetingOnFields(SolrQuery solrQuery, FacetQuery query) {\n\t\tFacetOptions facetRangeOptions = query.getFacetOptions();\n\t\tif (facetRangeOptions == null) {\n\t\t\treturn;\n\t\t}\n\t\tfor (FieldWithRangeParameters<?, ?, ?> rangeField : facetRangeOptions.getFieldsWithRangeParameters()) {\n\t\t\tif (rangeField instanceof FieldWithDateRangeParameters) {\n\t\t\t\tappendFieldFacetingByDateRange(solrQuery, (FieldWithDateRangeParameters) rangeField);\n\t\t\t} else if (rangeField instanceof FieldWithNumericRangeParameters) {\n\t\t\t\tappendFieldFacetingByNumberRange(solrQuery, (FieldWithNumericRangeParameters) rangeField);\n\t\t\t}\n\t\t\tif (rangeField.getHardEnd() != null && rangeField.getHardEnd()) {\n\t\t\t\tFacetParameter param = new FacetParameter(FacetParams.FACET_RANGE_HARD_END, true);\n\t\t\t\taddFieldSpecificParameterToSolrQuery(solrQuery, rangeField, param);\n\t\t\t}\n\t\t\tif (rangeField.getOther() != null) {\n\t\t\t\tFacetParameter param = new FacetParameter(FacetParams.FACET_RANGE_OTHER, rangeField.getOther());\n\t\t\t\taddFieldSpecificParameterToSolrQuery(solrQuery, rangeField, param);\n\t\t\t}\n\t\t\tif (rangeField.getInclude() != null) {\n\t\t\t\tFacetParameter param = new FacetParameter(FacetParams.FACET_RANGE_INCLUDE, rangeField.getInclude());\n\t\t\t\taddFieldSpecificParameterToSolrQuery(solrQuery, rangeField, param);\n\t\t\t}\n\t\t}\n\t}\n\tprivate void appendFieldFacetingByNumberRange(SolrQuery solrQuery, FieldWithNumericRangeParameters field) {\n\t\tsolrQuery.addNumericRangeFacet( //\n\t\t\t\tfield.getName(), //\n\t\t\t\tfield.getStart(), //\n\t\t\t\tfield.getEnd(), //\n\t\t\t\tfield.getGap());\n\t}\n\tprivate void appendFieldFacetingByDateRange(SolrQuery solrQuery, FieldWithDateRangeParameters field) {\n\t\tsolrQuery.addDateRangeFacet( //\n\t\t\t\tfield.getName(), //\n\t\t\t\tfield.getStart(), //\n\t\t\t\tfield.getEnd(), //\n\t\t\t\tfield.getGap());\n\t}\n\tprivate void appendFacetingQueries(SolrQuery solrQuery, FacetQuery query) {\n\t\tFacetOptions facetOptions = query.getFacetOptions();\n\t\tfor (SolrDataQuery fq : facetOptions.getFacetQueries()) {\n\t\t\tString facetQueryString = getQueryString(fq);\n\t\t\tif (StringUtils.isNotBlank(facetQueryString)) {\n\t\t\t\tsolrQuery.addFacetQuery(facetQueryString);\n\t\t\t}\n\t\t}\n\t}\n\tprivate void appendFacetingOnPivot(SolrQuery solrQuery, FacetQuery query) {\n\t\tFacetOptions facetOptions = query.getFacetOptions();\n\t\tString[] pivotFields = convertFieldListToStringArray(facetOptions.getFacetOnPivots());\n\t\tsolrQuery.addFacetPivotField(pivotFields);\n\t}\n\t/**\n\t * Set filter filter queries for {@link SolrQuery}\n\t * \n\t * @param solrQuery\n\t * @param filterQueries\n\t */\n\tprotected void appendFilterQuery(SolrQuery solrQuery, List<FilterQuery> filterQueries) {\n\t\tif (CollectionUtils.isEmpty(filterQueries)) {\n\t\t\treturn;\n\t\t}\n\t\tList<String> filterQueryStrings = getFilterQueryStrings(filterQueries);\n\t\tif (!filterQueryStrings.isEmpty()) {\n\t\t\tsolrQuery.setFilterQueries(convertStringListToArray(filterQueryStrings));\n\t\t}\n\t}\n\t/**\n\t * Append sorting parameters to {@link SolrQuery}\n\t * \n\t * @param solrQuery\n\t * @param sort\n\t */\n\tprotected void appendSort(SolrQuery solrQuery, @Nullable Sort sort) {\n\t\tif (sort == null) {\n\t\t\treturn;\n\t\t}\n\t\tfor (Order order : sort) {\n\t\t\tsolrQuery.addSort(order.getProperty(), order.isAscending() ? ORDER.asc : ORDER.desc);\n\t\t}\n\t}\n\tprivate String[] convertFieldListToStringArray(List<? extends Field> fields) {\n\t\tString[] strResult = new String[fields.size()];\n\t\tfor (int i = 0; i < fields.size(); i++) {\n\t\t\tstrResult[i] = fields.get(i).getName();\n\t\t}\n\t\treturn strResult;\n\t}\n\tprivate String[] convertStringListToArray(List<String> listOfString) {\n\t\tString[] strResult = new String[listOfString.size()];\n\t\tlistOfString.toArray(strResult);\n\t\treturn strResult;\n\t}\n\tprivate List<String> getFilterQueryStrings(List<FilterQuery> filterQueries) {\n\t\tList<String> filterQueryStrings = new ArrayList<>(filterQueries.size());\n\t\tfor (FilterQuery filterQuery : filterQueries) {\n\t\t\tString filterQueryString = getQueryString(filterQuery);\n\t\t\tif (StringUtils.isNotBlank(filterQueryString)) {\n\t\t\t\tfilterQueryStrings.add(filterQueryString);\n\t\t\t}\n\t\t}\n\t\treturn filterQueryStrings;\n\t}\n"]]}
{"hexsha": "ffe7406a7609939ddb7d8d29b954183a1d2856ac", "ext": "java", "lang": "Java", "content": "public class CelsiusConverterBOTest {\n\n    public CelsiusConverterBOTest() {\n    }\n\n    @Test\n    public void shouldConvertFromCelsiusToFahrenheit() {\n        //given\n        CelsiusConverterBO celsiusConverterBO = new CelsiusConverterBO();\n        double tempToConvert = ConstantsForTests.CELSIUS;\n        double convertedTemp = 0.0;\n\n        //when\n        convertedTemp = celsiusConverterBO.toFahrenheit(tempToConvert);\n\n        //then\n        assertEquals(ConstantsForTests.FAHRENHEIT, convertedTemp, ConstantsForTests.DELTA);\n    }\n\n    @Test\n    public void shouldConvertFromCelsiusToKelvin() {\n        //given\n        CelsiusConverterBO celsiusConverterBO = new CelsiusConverterBO();\n        double tempToConvert = ConstantsForTests.CELSIUS;\n        double convertedTemp = 0.0;\n\n        //when\n        convertedTemp = celsiusConverterBO.toKelvin(tempToConvert);\n\n        //then\n        assertEquals(ConstantsForTests.KELVIN, convertedTemp, ConstantsForTests.DELTA);\n    }\n\n    @Test\n    public void shouldConvertFromCelsiusToRankine() {\n        //given\n        CelsiusConverterBO celsiusConverterBO = new CelsiusConverterBO();\n        double tempToConvert = ConstantsForTests.CELSIUS;\n        double convertedTemp = 0.0;\n\n        //when\n        convertedTemp = celsiusConverterBO.toRankine(tempToConvert);\n\n        //then\n        assertEquals(ConstantsForTests.RANKINE, convertedTemp, ConstantsForTests.DELTA);\n    }\n\n    @Test\n    public void shouldConvertFromCelsiusToReaumur() {\n        //given\n        CelsiusConverterBO celsiusConverterBO = new CelsiusConverterBO();\n        double tempToConvert = ConstantsForTests.CELSIUS;\n        double convertedTemp = 0.0;\n\n        //when\n        convertedTemp = celsiusConverterBO.toReaumur(tempToConvert);\n        //then\n        assertEquals(ConstantsForTests.REAUMUR, convertedTemp, ConstantsForTests.DELTA);\n    }\n\n}", "class_id": 0, "repo": "RafalPolak/Java", "file": "TemperatureConverter/src/test/java/pl/rpolak/temperatureconverter/celsius/bo/CelsiusConverterBOTest.java", "last_update_at": "2020-10-12T17:35:02+00:00", "question_id": "ffe7406a7609939ddb7d8d29b954183a1d2856ac", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CelsiusConverterBOTest {\n    public CelsiusConverterBOTest() {\n    }\n    @Test\n    public void shouldConvertFromCelsiusToFahrenheit() {\n        //given\n        CelsiusConverterBO celsiusConverterBO = new CelsiusConverterBO();\n        double tempToConvert = ConstantsForTests.CELSIUS;\n        double convertedTemp = 0.0;\n        //when\n        convertedTemp = celsiusConverterBO.toFahrenheit(tempToConvert);\n        //then\n        assertEquals(ConstantsForTests.FAHRENHEIT, convertedTemp, ConstantsForTests.DELTA);\n    }\n    @Test\n    public void shouldConvertFromCelsiusToKelvin() {\n        //given\n        CelsiusConverterBO celsiusConverterBO = new CelsiusConverterBO();\n        double tempToConvert = ConstantsForTests.CELSIUS;\n        double convertedTemp = 0.0;\n        //when\n        convertedTemp = celsiusConverterBO.toKelvin(tempToConvert);\n        //then\n        assertEquals(ConstantsForTests.KELVIN, convertedTemp, ConstantsForTests.DELTA);\n    }\n    @Test\n    public void shouldConvertFromCelsiusToRankine() {\n        //given\n        CelsiusConverterBO celsiusConverterBO = new CelsiusConverterBO();\n        double tempToConvert = ConstantsForTests.CELSIUS;\n        double convertedTemp = 0.0;\n        //when\n        convertedTemp = celsiusConverterBO.toRankine(tempToConvert);\n        //then\n        assertEquals(ConstantsForTests.RANKINE, convertedTemp, ConstantsForTests.DELTA);\n    }\n    @Test\n    public void shouldConvertFromCelsiusToReaumur() {\n        //given\n        CelsiusConverterBO celsiusConverterBO = new CelsiusConverterBO();\n        double tempToConvert = ConstantsForTests.CELSIUS;\n        double convertedTemp = 0.0;\n        //when\n        convertedTemp = celsiusConverterBO.toReaumur(tempToConvert);\n        //then\n        assertEquals(ConstantsForTests.REAUMUR, convertedTemp, ConstantsForTests.DELTA);\n    }\n"]]}
{"hexsha": "f976d592164f77c32e8e5ff324db9bcca9393430", "ext": "java", "lang": "Java", "content": "public class EnvironmentVariable {\n    public static void main(String[] args) {\n        // \u4f7f\u7528 System.getenv() \u83b7\u53d6\u6240\u6709\u73af\u5883\u53d8\u91cf\n        Map<String, String> map = System.getenv();\n        System.out.println(map);\n        // \u4f7f\u7528 System.getenv(\"xxx\") \u83b7\u53d6\u6307\u5b9a\u7684\u73af\u5883\u53d8\u91cf\n        System.out.println(System.getenv(\"JAVA_HOME\"));\n    }\n}", "class_id": 0, "repo": "hanqi-pingfanzhilu/javacookbook", "file": "src/main/java/pers/hq/javacookbook/environment/EnvironmentVariable.java", "last_update_at": "2020-07-26T10:22:06+00:00", "question_id": "f976d592164f77c32e8e5ff324db9bcca9393430", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EnvironmentVariable {\n    public static void main(String[] args) {\n        // \u4f7f\u7528 System.getenv() \u83b7\u53d6\u6240\u6709\u73af\u5883\u53d8\u91cf\n        Map<String, String> map = System.getenv();\n        System.out.println(map);\n        // \u4f7f\u7528 System.getenv(\"xxx\") \u83b7\u53d6\u6307\u5b9a\u7684\u73af\u5883\u53d8\u91cf\n        System.out.println(System.getenv(\"JAVA_HOME\"));\n    }\n"]]}
{"hexsha": "ce4087cfa0e19ec9e27c4dfc66c095d3f1a8c929", "ext": "java", "lang": "Java", "content": "@Service\npublic class DefaultShippingRateService implements ShippingRateService {\n    private final ShippingRates shippingRates;\n\n    @Inject\n    public DefaultShippingRateService(ShippingRates shippingRates) {\n        this.shippingRates = shippingRates;\n    }\n\n    private ShippingRate findShippingRate(List<ShippingRate> rates, Double value) {\n        ShippingRate rate = null;\n        for (ShippingRate rt : rates) {\n            if (rt.getLowerBound() <= value) {\n                if (rate == null || rate.getLowerBound() < rt.getLowerBound()) {\n                    rate = rt;\n                }\n            }\n        }\n        return rate;\n    }\n\n    @Override\n    public ShippingRate findShippingRateFor(ShippingType shippingType, ShippingRateType type, String countryCode,\n        String stateCode, String zipCode, Double value) {\n        ShippingRate shippingRate = null;\n        List<ShippingRate> shippingRateList = null;\n\n        if (zipCode != null) {\n            shippingRateList = shippingRates.forZip(shippingType, type, countryCode, zipCode);\n        }\n\n        if ((shippingRateList == null || shippingRateList.size() == 0) && stateCode != null) {\n            shippingRateList = shippingRates.forState(shippingType, type, countryCode, stateCode);\n        }\n\n        if ((shippingRateList == null || shippingRateList.size() == 0) && countryCode != null) {\n            shippingRateList = shippingRates.forCountry(shippingType, type, countryCode);\n        }\n\n        if (shippingRateList == null || shippingRateList.size() == 0)\n            return null;\n\n        return findShippingRate(shippingRateList, value);\n    }\n\n}", "class_id": 0, "repo": "commerceboard/geecommerce", "file": "modules/core/shipping/provider/table-rate/src/com/geecommerce/shipping/tablerate/service/DefaultShippingRateService.java", "last_update_at": "2020-04-22T02:43:51+00:00", "question_id": "ce4087cfa0e19ec9e27c4dfc66c095d3f1a8c929", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\npublic class DefaultShippingRateService implements ShippingRateService {\n    private final ShippingRates shippingRates;\n    @Inject\n    public DefaultShippingRateService(ShippingRates shippingRates) {\n        this.shippingRates = shippingRates;\n    }\n    private ShippingRate findShippingRate(List<ShippingRate> rates, Double value) {\n        ShippingRate rate = null;\n        for (ShippingRate rt : rates) {\n            if (rt.getLowerBound() <= value) {\n                if (rate == null || rate.getLowerBound() < rt.getLowerBound()) {\n                    rate = rt;\n                }\n            }\n        }\n        return rate;\n    }\n    @Override\n    public ShippingRate findShippingRateFor(ShippingType shippingType, ShippingRateType type, String countryCode,\n        String stateCode, String zipCode, Double value) {\n        ShippingRate shippingRate = null;\n        List<ShippingRate> shippingRateList = null;\n        if (zipCode != null) {\n            shippingRateList = shippingRates.forZip(shippingType, type, countryCode, zipCode);\n        }\n        if ((shippingRateList == null || shippingRateList.size() == 0) && stateCode != null) {\n            shippingRateList = shippingRates.forState(shippingType, type, countryCode, stateCode);\n        }\n        if ((shippingRateList == null || shippingRateList.size() == 0) && countryCode != null) {\n            shippingRateList = shippingRates.forCountry(shippingType, type, countryCode);\n        }\n        if (shippingRateList == null || shippingRateList.size() == 0)\n            return null;\n        return findShippingRate(shippingRateList, value);\n    }\n"]]}
{"hexsha": "bbb58af9e881f947b2321472f5d5393ed8eb998e", "ext": "java", "lang": "Java", "content": "public class InterfaceDemoTest {\n    public static void main(String[] args) {\n        AnimalLivable animalLivable = new AnimalLivable();\n        animalLivable.eat();\n        animalLivable.sleep();\n    }\n}", "class_id": 0, "repo": "MYHUNBT/JavaSECode", "file": "day07/src/com/neusoft/InterfaceDemoTest.java", "last_update_at": "2020-08-13T00:43:25+00:00", "question_id": "bbb58af9e881f947b2321472f5d5393ed8eb998e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class InterfaceDemoTest {\n    public static void main(String[] args) {\n        AnimalLivable animalLivable = new AnimalLivable();\n        animalLivable.eat();\n        animalLivable.sleep();\n    }\n"]]}
{"hexsha": "7d76c12ede26efc84372403866f00634c05d1f5f", "ext": "java", "lang": "Java", "content": "public class ApiErrorFactory \n{\n\t//COMMON\n\tpublic static final int ERROR_UNKNOWN = 0;\n\tpublic static final int ERROR_JSON = 1;\n\tpublic static final int ERROR_NO_BALANCE = 2;\n\tpublic static final int ERROR_NOT_YET_RELEASED = 3;\n\t\n\t//VALIDATION\n\tpublic static final int ERROR_INVALID_SIGNATURE = 101;\n\tpublic static final int ERROR_INVALID_ADDRESS = 102;\n\tpublic static final int ERROR_INVALID_SEED = 103;\n\tpublic static final int ERROR_INVALID_AMOUNT = 104;\n\tpublic static final int ERROR_INVALID_FEE = 105;\n\tpublic static final int ERROR_INVALID_SENDER = 106;\n\tpublic static final int ERROR_INVALID_RECIPIENT = 107;\n\tpublic static final int ERROR_INVALID_NAME_LENGTH = 108;\n\tpublic static final int ERROR_INVALID_VALUE_LENGTH = 109;\n\tpublic static final int ERROR_INVALID_NAME_OWNER = 110;\n\tpublic static final int ERROR_INVALID_BUYER = 111;\n\tpublic static final int ERROR_INVALID_PUBLIC_KEY = 112;\n\tpublic static final int ERROR_INVALID_OPTIONS_LENGTH = 113;\n\tpublic static final int ERROR_INVALID_OPTION_LENGTH = 114;\n\tpublic static final int ERROR_INVALID_DATA = 115;\n\tpublic static final int ERROR_INVALID_DATA_LENGTH = 116;\n\tpublic static final int ERROR_INVALID_UPDATE_VALUE = 117;\n\tpublic static final int ERROR_KEY_ALREADY_EXISTS = 118;\n\tpublic static final int ERROR_KEY_NOT_EXISTS = 119;\n\tpublic static final int ERROR_LAST_KEY_IS_DEFAULT_KEY_ERROR = 120;\n\tpublic static final int ERROR_FEE_LESS_REQUIRED = 121;\n\tpublic static final int ERROR_WALLET_NOT_IN_SYNC = 122;\n\tpublic static final int ERROR_INVALID_NETWORK_ADDRESS = 123;\n\t\n\t//WALLET\n\tpublic static final int ERROR_WALLET_NO_EXISTS = 201;\n\tpublic static final int ERROR_WALLET_ADDRESS_NO_EXISTS = 202;\n\tpublic static final int ERROR_WALLET_LOCKED = 203;\n\tpublic static final int ERROR_WALLET_ALREADY_EXISTS = 204;\n\tpublic static final int ERROR_WALLET_API_CALL_FORBIDDEN_BY_USER = 205;\n\t\n\t//BLOCKS\n\tpublic static final int ERROR_BLOCK_NO_EXISTS = 301;\n\t\n\t//TRANSACTIONS\n\tpublic static final int ERROR_TRANSACTION_NO_EXISTS = 311;\n\tpublic static final int ERROR_PUBLIC_KEY_NOT_FOUND = 304;\t\n\t\t\n\t//NAMING\n\tpublic static final int ERROR_NAME_NO_EXISTS = 401;\n\tpublic static final int ERROR_NAME_ALREADY_EXISTS = 402;\n\tpublic static final int ERROR_NAME_ALREADY_FOR_SALE = 403;\n\tpublic static final int ERROR_NAME_NOT_LOWER_CASE = 404;\n\tpublic static final int ERROR_NAME_SALE_NO_EXISTS = 410;\n\tpublic static final int ERROR_BUYER_ALREADY_OWNER = 411;\n\t\n\t//POLLS\n\tpublic static final int ERROR_POLL_NO_EXISTS = 501;\n\tpublic static final int ERROR_POLL_ALREADY_EXISTS = 502;\n\tpublic static final int ERROR_DUPLICATE_OPTION = 503;\n\tpublic static final int ERROR_POLL_OPTION_NO_EXISTS = 504;\n\tpublic static final int ERROR_ALREADY_VOTED_FOR_THAT_OPTION = 505;\n\t\n\t//ASSET\n\tpublic static final int ERROR_INVALID_ASSET_ID = 601;\n\t\n\t//NAME PAYMENTS\n\tpublic static final int ERROR_NAME_NOT_REGISTERED = 701;\n\tpublic static final int ERROR_NAME_FOR_SALE = 702;\n\tpublic static final int ERROR_NAME_WITH_SPACE = 703;\n\t\n\t//ATs\n\tpublic static final int ERROR_INVALID_DESC_LENGTH = 801;\n\tpublic static final int ERROR_EMPTY_CODE = 802;\n\tpublic static final int ERROR_DATA_SIZE = 803;\n\tpublic static final int ERROR_NULL_PAGES = 804;\n\tpublic static final int ERROR_INVALID_TYPE_LENGTH = 805;\n\tpublic static final int ERROR_INVALID_TAGS_LENGTH = 806;\n\tpublic static final int ERROR_INVALID_CREATION_BYTES = 809;\n\t\n\t//BLOG/Namestorage\n\tpublic static final int ERROR_BODY_EMPTY = 901;\n\tpublic static final int ERROR_BLOG_DISABLED = 902;\n\tpublic static final int ERROR_NAME_NOT_OWNER = 903;\n\tpublic static final int ERROR_TX_AMOUNT = 904;\n\tpublic static final int ERROR_BLOG_ENTRY_NO_EXISTS = 905;\n\tpublic static final int ERROR_BLOG_EMPTY = 906;\n\tpublic static final int ERROR_POSTID_EMPTY = 907;\n\tpublic static final int ERROR_POST_NOT_EXISTING = 908;\n\tpublic static final int ERROR_COMMENTING_DISABLED = 909;\n\tpublic static final int ERROR_COMMENT_NOT_EXISTING = 910;\n\tpublic static final int ERROR_INVALID_COMMENT_OWNER = 911;\n\t\n\t//Messages\n\tpublic static final int ERROR_MESSAGE_FORMAT_NOT_HEX = 1001;\n\tpublic static final int ERROR_MESSAGE_BLANK = 1002;\n\tpublic static final int ERROR_NO_PUBLIC_KEY = 1003;\n\tpublic static final int ERROR_MESSAGESIZE_EXCEEDED = 1004;\n\n\t\n\tpublic static int BATCH_TX_AMOUNT = 50;\n\t\n\t\n\tprivate static ApiErrorFactory  instance;\n\t\n\tpublic static ApiErrorFactory  getInstance()\n\t{\n\t\tif(instance == null)\n\t\t{\n\t\t\tinstance = new ApiErrorFactory();\n\t\t}\n\t\t\n\t\treturn instance;\n\t}\n\t\n\tprivate Map<Integer, String> errorMessages;\n\t\n\tpublic ApiErrorFactory()\n\t{\n\t\tthis.errorMessages = new HashMap<Integer, String>();\n\t\t\n\t\t//COMMON\n\t\tthis.errorMessages.put(ERROR_UNKNOWN, Lang.getInstance().translate(\"unknown error\"));\n\t\tthis.errorMessages.put(ERROR_JSON, Lang.getInstance().translate(\"failed to parse json message\"));\n\t\tthis.errorMessages.put(ERROR_NO_BALANCE, Lang.getInstance().translate(\"not enough balance\"));\n\t\tthis.errorMessages.put(ERROR_NOT_YET_RELEASED, Lang.getInstance().translate(\"that feature is not yet released\"));\n\t\t\n\t\t//VALIDATION\t\t\n\t\tthis.errorMessages.put(ERROR_INVALID_SIGNATURE, Lang.getInstance().translate(\"invalid signature\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_ADDRESS, Lang.getInstance().translate(\"invalid address\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_SEED, Lang.getInstance().translate(\"invalid seed\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_AMOUNT, Lang.getInstance().translate(\"invalid amount\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_FEE, Lang.getInstance().translate(\"invalid fee\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_SENDER, Lang.getInstance().translate(\"invalid sender\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_RECIPIENT, Lang.getInstance().translate(\"invalid recipient\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_NAME_LENGTH, Lang.getInstance().translate(\"invalid name length\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_VALUE_LENGTH, Lang.getInstance().translate(\"invalid value length\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_NAME_OWNER, Lang.getInstance().translate(\"invalid name owner\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_BUYER, Lang.getInstance().translate(\"invalid buyer\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_PUBLIC_KEY, Lang.getInstance().translate(\"invalid public key\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_OPTIONS_LENGTH, Lang.getInstance().translate(\"invalid options length\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_OPTION_LENGTH, Lang.getInstance().translate(\"invalid option length\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_DATA, Lang.getInstance().translate(\"invalid data\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_DATA_LENGTH, Lang.getInstance().translate(\"invalid data length\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_UPDATE_VALUE, Lang.getInstance().translate(\"invalid update value\"));\n\t\tthis.errorMessages.put(ERROR_KEY_ALREADY_EXISTS, Lang.getInstance().translate(\"key already exists, edit is false\"));\n\t\tthis.errorMessages.put(ERROR_KEY_NOT_EXISTS, Lang.getInstance().translate(\"the key does not exist\"));\n\t\tthis.errorMessages.put(ERROR_LAST_KEY_IS_DEFAULT_KEY_ERROR, Lang.getInstance().translate((\"you can't delete the key \\\"%key%\\\" if it is the only key\")).replace(\"%key%\", Qorakeys.DEFAULT.toString()));\n\t\tthis.errorMessages.put(ERROR_FEE_LESS_REQUIRED, Lang.getInstance().translate(\"fee less required\"));\n\t\tthis.errorMessages.put(ERROR_WALLET_NOT_IN_SYNC, Lang.getInstance().translate(\"wallet needs to be synchronized\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_NETWORK_ADDRESS, Lang.getInstance().translate(\"invalid network address\"));\n\t\t\t\t\n\t\t//WALLET\n\t\tthis.errorMessages.put(ERROR_WALLET_NO_EXISTS, Lang.getInstance().translate(\"wallet does not exist\"));\n\t\tthis.errorMessages.put(ERROR_WALLET_ADDRESS_NO_EXISTS, Lang.getInstance().translate(\"address does not exist in wallet\"));\n\t\tthis.errorMessages.put(ERROR_WALLET_LOCKED, Lang.getInstance().translate(\"wallet is locked\"));\n\t\tthis.errorMessages.put(ERROR_WALLET_ALREADY_EXISTS, Lang.getInstance().translate(\"wallet already exists\"));\n\t\tthis.errorMessages.put(ERROR_WALLET_API_CALL_FORBIDDEN_BY_USER, Lang.getInstance().translate(\"user denied api call\"));\n\t\t\n\t\t//BLOCK\n\t\tthis.errorMessages.put(ERROR_BLOCK_NO_EXISTS, Lang.getInstance().translate(\"block does not exist\"));\n\t\t\n\t\t//TRANSACTIONS\n\t\tthis.errorMessages.put(ERROR_TRANSACTION_NO_EXISTS, Lang.getInstance().translate(\"transactions does not exist\"));\n\t\tthis.errorMessages.put(ERROR_PUBLIC_KEY_NOT_FOUND, Lang.getInstance().translate(\"public key not found\"));\n\t\t\n\t\t//NAMING\n\t\tthis.errorMessages.put(ERROR_NAME_NO_EXISTS, Lang.getInstance().translate(\"name does not exist\"));\n\t\tthis.errorMessages.put(ERROR_NAME_ALREADY_EXISTS, Lang.getInstance().translate(\"name already exists\"));\n\t\tthis.errorMessages.put(ERROR_NAME_ALREADY_FOR_SALE, Lang.getInstance().translate(\"name already for sale\"));\n\t\tthis.errorMessages.put(ERROR_NAME_NOT_LOWER_CASE, Lang.getInstance().translate(\"name must be lower case\"));\n\t\tthis.errorMessages.put(ERROR_NAME_SALE_NO_EXISTS, Lang.getInstance().translate(\"namesale does not exist\"));\n\t\tthis.errorMessages.put(ERROR_BUYER_ALREADY_OWNER, Lang.getInstance().translate(\"buyer is already owner\"));\n\t\t\n\t\t//POLLS\n\t\tthis.errorMessages.put(ERROR_POLL_NO_EXISTS, Lang.getInstance().translate(\"poll does not exist\"));\n\t\tthis.errorMessages.put(ERROR_POLL_ALREADY_EXISTS, Lang.getInstance().translate(\"poll already exists\"));\n\t\tthis.errorMessages.put(ERROR_DUPLICATE_OPTION, Lang.getInstance().translate(\"not all options are unique\"));\n\t\tthis.errorMessages.put(ERROR_POLL_OPTION_NO_EXISTS, Lang.getInstance().translate(\"option does not exist\"));\n\t\tthis.errorMessages.put(ERROR_ALREADY_VOTED_FOR_THAT_OPTION, Lang.getInstance().translate(\"already voted for that option\"));\n\t\t\n\t\t//ASSETS\n\t\tthis.errorMessages.put(ERROR_INVALID_ASSET_ID, Lang.getInstance().translate(\"invalid asset id\"));\n\t\t\n\t\t//NAME PAYMENTS\n\t\tthis.errorMessages.put(ERROR_NAME_NOT_REGISTERED, Lang.getInstance().translate(NameResult.NAME_NOT_REGISTERED.getStatusMessage()));\n\t\tthis.errorMessages.put(ERROR_NAME_FOR_SALE, Lang.getInstance().translate(NameResult.NAME_FOR_SALE.getStatusMessage()));\n\t\tthis.errorMessages.put(ERROR_NAME_WITH_SPACE, Lang.getInstance().translate(NameResult.NAME_WITH_SPACE.getStatusMessage()));\n\t\t\n\t\t//AT\n\t\tthis.errorMessages.put(ERROR_INVALID_CREATION_BYTES, Lang.getInstance().translate(\"error in creation bytes\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_DESC_LENGTH, Lang.getInstance().translate(\"invalid description length. max length \") + AT_Constants.DESC_MAX_LENGTH);\n\t\tthis.errorMessages.put(ERROR_EMPTY_CODE, Lang.getInstance().translate(\"code is empty\"));\n\t\tthis.errorMessages.put(ERROR_DATA_SIZE, Lang.getInstance().translate(\"invalid data length\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_TYPE_LENGTH, Lang.getInstance().translate(\"invalid type length\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_TAGS_LENGTH, Lang.getInstance().translate(\"invalid tags length\"));\n\t\tthis.errorMessages.put(ERROR_NULL_PAGES, Lang.getInstance().translate(\"invalid pages\"));\n\t\t\n\t\t//BLOG\n\t\tthis.errorMessages.put(ERROR_BODY_EMPTY, Lang.getInstance().translate(\"invalid body it must not be empty\"));\n\t\tthis.errorMessages.put(ERROR_BLOG_DISABLED, Lang.getInstance().translate(\"this blog is disabled\"));\n\t\tthis.errorMessages.put(ERROR_NAME_NOT_OWNER, Lang.getInstance().translate(\"the creator address does not own the author name\"));\n\t\tthis.errorMessages.put(ERROR_TX_AMOUNT, Lang.getInstance().translate(\"the data size is too large - currently only %BATCH_TX_AMOUNT% arbitrary transactions are allowed at once!\").replace(\"%BATCH_TX_AMOUNT%\", String.valueOf(BATCH_TX_AMOUNT)));\n\t\tthis.errorMessages.put(ERROR_BLOG_ENTRY_NO_EXISTS, Lang.getInstance().translate(\"transaction with this signature contains no entries!\"));\n\t\tthis.errorMessages.put(ERROR_BLOG_EMPTY, Lang.getInstance().translate(\"this blog is empty\"));\n\t\tthis.errorMessages.put(ERROR_POSTID_EMPTY, Lang.getInstance().translate(\"the attribute postid is empty! this is the signature of the post you want to comment\"));\n\t\tthis.errorMessages.put(ERROR_POST_NOT_EXISTING, Lang.getInstance().translate(\"for the given postid no blogpost to comment was found\"));\n\t\tthis.errorMessages.put(ERROR_COMMENTING_DISABLED, Lang.getInstance().translate(\"commenting is for this blog disabled\"));\n\t\tthis.errorMessages.put(ERROR_COMMENT_NOT_EXISTING, Lang.getInstance().translate(\"for the given signature no comment was found\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_COMMENT_OWNER, Lang.getInstance().translate(\"invalid comment owner\"));\n\t\t\n\t\t\n\t\t//MESSAGES\n\t\tthis.errorMessages.put(ERROR_MESSAGE_FORMAT_NOT_HEX, Lang.getInstance().translate(\"the Message format is not hex - correct the text or use isTextMessage = true\"));\n\t\tthis.errorMessages.put(ERROR_MESSAGE_BLANK, Lang.getInstance().translate(\"The message attribute is missing or content is blank\"));\n\t\tthis.errorMessages.put(ERROR_NO_PUBLIC_KEY, Lang.getInstance().translate(\"The recipient has not yet performed any action in the blockchain.\\nYou can't send an encrypted message to him.\"));\n\t\tthis.errorMessages.put(ERROR_MESSAGESIZE_EXCEEDED, Lang.getInstance().translate(\"Message size exceeded!\"));\n\n\t}\n\t\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic WebApplicationException createError(int error)\n\t{\n\n\t\tJSONObject jsonObject = new JSONObject();\n\t\tjsonObject.put(\"error\", error);\n\t\tif ( error > Transaction.AT_ERROR )\n\t\t{\n\t\t\tjsonObject.put(\"message\", AT_Error.getATError(error - Transaction.AT_ERROR) );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tjsonObject.put(\"message\", this.errorMessages.get(error));\n\t\t}\n\t\t\n\t\t\n\t\treturn new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(jsonObject.toJSONString()).build());\n\t}\n}", "class_id": 0, "repo": "marcomoesman/Qora", "file": "src/main/java/api/ApiErrorFactory.java", "last_update_at": "2020-09-10T16:14:00+00:00", "question_id": "7d76c12ede26efc84372403866f00634c05d1f5f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ApiErrorFactory \n{\n\t//COMMON\n\tpublic static final int ERROR_UNKNOWN = 0;\n\tpublic static final int ERROR_JSON = 1;\n\tpublic static final int ERROR_NO_BALANCE = 2;\n\tpublic static final int ERROR_NOT_YET_RELEASED = 3;\n\t\n\t//VALIDATION\n\tpublic static final int ERROR_INVALID_SIGNATURE = 101;\n\tpublic static final int ERROR_INVALID_ADDRESS = 102;\n\tpublic static final int ERROR_INVALID_SEED = 103;\n\tpublic static final int ERROR_INVALID_AMOUNT = 104;\n\tpublic static final int ERROR_INVALID_FEE = 105;\n\tpublic static final int ERROR_INVALID_SENDER = 106;\n\tpublic static final int ERROR_INVALID_RECIPIENT = 107;\n\tpublic static final int ERROR_INVALID_NAME_LENGTH = 108;\n\tpublic static final int ERROR_INVALID_VALUE_LENGTH = 109;\n\tpublic static final int ERROR_INVALID_NAME_OWNER = 110;\n\tpublic static final int ERROR_INVALID_BUYER = 111;\n\tpublic static final int ERROR_INVALID_PUBLIC_KEY = 112;\n\tpublic static final int ERROR_INVALID_OPTIONS_LENGTH = 113;\n\tpublic static final int ERROR_INVALID_OPTION_LENGTH = 114;\n\tpublic static final int ERROR_INVALID_DATA = 115;\n\tpublic static final int ERROR_INVALID_DATA_LENGTH = 116;\n\tpublic static final int ERROR_INVALID_UPDATE_VALUE = 117;\n\tpublic static final int ERROR_KEY_ALREADY_EXISTS = 118;\n\tpublic static final int ERROR_KEY_NOT_EXISTS = 119;\n\tpublic static final int ERROR_LAST_KEY_IS_DEFAULT_KEY_ERROR = 120;\n\tpublic static final int ERROR_FEE_LESS_REQUIRED = 121;\n\tpublic static final int ERROR_WALLET_NOT_IN_SYNC = 122;\n\tpublic static final int ERROR_INVALID_NETWORK_ADDRESS = 123;\n\t\n\t//WALLET\n\tpublic static final int ERROR_WALLET_NO_EXISTS = 201;\n\tpublic static final int ERROR_WALLET_ADDRESS_NO_EXISTS = 202;\n\tpublic static final int ERROR_WALLET_LOCKED = 203;\n\tpublic static final int ERROR_WALLET_ALREADY_EXISTS = 204;\n\tpublic static final int ERROR_WALLET_API_CALL_FORBIDDEN_BY_USER = 205;\n\t\n\t//BLOCKS\n\tpublic static final int ERROR_BLOCK_NO_EXISTS = 301;\n\t\n\t//TRANSACTIONS\n\tpublic static final int ERROR_TRANSACTION_NO_EXISTS = 311;\n\tpublic static final int ERROR_PUBLIC_KEY_NOT_FOUND = 304;\t\n\t\t\n\t//NAMING\n\tpublic static final int ERROR_NAME_NO_EXISTS = 401;\n\tpublic static final int ERROR_NAME_ALREADY_EXISTS = 402;\n\tpublic static final int ERROR_NAME_ALREADY_FOR_SALE = 403;\n\tpublic static final int ERROR_NAME_NOT_LOWER_CASE = 404;\n\tpublic static final int ERROR_NAME_SALE_NO_EXISTS = 410;\n\tpublic static final int ERROR_BUYER_ALREADY_OWNER = 411;\n\t\n\t//POLLS\n\tpublic static final int ERROR_POLL_NO_EXISTS = 501;\n\tpublic static final int ERROR_POLL_ALREADY_EXISTS = 502;\n\tpublic static final int ERROR_DUPLICATE_OPTION = 503;\n\tpublic static final int ERROR_POLL_OPTION_NO_EXISTS = 504;\n\tpublic static final int ERROR_ALREADY_VOTED_FOR_THAT_OPTION = 505;\n\t\n\t//ASSET\n\tpublic static final int ERROR_INVALID_ASSET_ID = 601;\n\t\n\t//NAME PAYMENTS\n\tpublic static final int ERROR_NAME_NOT_REGISTERED = 701;\n\tpublic static final int ERROR_NAME_FOR_SALE = 702;\n\tpublic static final int ERROR_NAME_WITH_SPACE = 703;\n\t\n\t//ATs\n\tpublic static final int ERROR_INVALID_DESC_LENGTH = 801;\n\tpublic static final int ERROR_EMPTY_CODE = 802;\n\tpublic static final int ERROR_DATA_SIZE = 803;\n\tpublic static final int ERROR_NULL_PAGES = 804;\n\tpublic static final int ERROR_INVALID_TYPE_LENGTH = 805;\n\tpublic static final int ERROR_INVALID_TAGS_LENGTH = 806;\n\tpublic static final int ERROR_INVALID_CREATION_BYTES = 809;\n\t\n\t//BLOG/Namestorage\n\tpublic static final int ERROR_BODY_EMPTY = 901;\n\tpublic static final int ERROR_BLOG_DISABLED = 902;\n\tpublic static final int ERROR_NAME_NOT_OWNER = 903;\n\tpublic static final int ERROR_TX_AMOUNT = 904;\n\tpublic static final int ERROR_BLOG_ENTRY_NO_EXISTS = 905;\n\tpublic static final int ERROR_BLOG_EMPTY = 906;\n\tpublic static final int ERROR_POSTID_EMPTY = 907;\n\tpublic static final int ERROR_POST_NOT_EXISTING = 908;\n\tpublic static final int ERROR_COMMENTING_DISABLED = 909;\n\tpublic static final int ERROR_COMMENT_NOT_EXISTING = 910;\n\tpublic static final int ERROR_INVALID_COMMENT_OWNER = 911;\n\t\n\t//Messages\n\tpublic static final int ERROR_MESSAGE_FORMAT_NOT_HEX = 1001;\n\tpublic static final int ERROR_MESSAGE_BLANK = 1002;\n\tpublic static final int ERROR_NO_PUBLIC_KEY = 1003;\n\tpublic static final int ERROR_MESSAGESIZE_EXCEEDED = 1004;\n\t\n\tpublic static int BATCH_TX_AMOUNT = 50;\n\t\n\t\n\tprivate static ApiErrorFactory  instance;\n\t\n\tpublic static ApiErrorFactory  getInstance()\n\t{\n\t\tif(instance == null)\n\t\t{\n\t\t\tinstance = new ApiErrorFactory();\n\t\t}\n\t\t\n\t\treturn instance;\n\t}\n\t\n\tprivate Map<Integer, String> errorMessages;\n\t\n\tpublic ApiErrorFactory()\n\t{\n\t\tthis.errorMessages = new HashMap<Integer, String>();\n\t\t\n\t\t//COMMON\n\t\tthis.errorMessages.put(ERROR_UNKNOWN, Lang.getInstance().translate(\"unknown error\"));\n\t\tthis.errorMessages.put(ERROR_JSON, Lang.getInstance().translate(\"failed to parse json message\"));\n\t\tthis.errorMessages.put(ERROR_NO_BALANCE, Lang.getInstance().translate(\"not enough balance\"));\n\t\tthis.errorMessages.put(ERROR_NOT_YET_RELEASED, Lang.getInstance().translate(\"that feature is not yet released\"));\n\t\t\n\t\t//VALIDATION\t\t\n\t\tthis.errorMessages.put(ERROR_INVALID_SIGNATURE, Lang.getInstance().translate(\"invalid signature\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_ADDRESS, Lang.getInstance().translate(\"invalid address\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_SEED, Lang.getInstance().translate(\"invalid seed\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_AMOUNT, Lang.getInstance().translate(\"invalid amount\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_FEE, Lang.getInstance().translate(\"invalid fee\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_SENDER, Lang.getInstance().translate(\"invalid sender\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_RECIPIENT, Lang.getInstance().translate(\"invalid recipient\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_NAME_LENGTH, Lang.getInstance().translate(\"invalid name length\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_VALUE_LENGTH, Lang.getInstance().translate(\"invalid value length\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_NAME_OWNER, Lang.getInstance().translate(\"invalid name owner\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_BUYER, Lang.getInstance().translate(\"invalid buyer\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_PUBLIC_KEY, Lang.getInstance().translate(\"invalid public key\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_OPTIONS_LENGTH, Lang.getInstance().translate(\"invalid options length\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_OPTION_LENGTH, Lang.getInstance().translate(\"invalid option length\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_DATA, Lang.getInstance().translate(\"invalid data\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_DATA_LENGTH, Lang.getInstance().translate(\"invalid data length\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_UPDATE_VALUE, Lang.getInstance().translate(\"invalid update value\"));\n\t\tthis.errorMessages.put(ERROR_KEY_ALREADY_EXISTS, Lang.getInstance().translate(\"key already exists, edit is false\"));\n\t\tthis.errorMessages.put(ERROR_KEY_NOT_EXISTS, Lang.getInstance().translate(\"the key does not exist\"));\n\t\tthis.errorMessages.put(ERROR_LAST_KEY_IS_DEFAULT_KEY_ERROR, Lang.getInstance().translate((\"you can't delete the key \\\"%key%\\\" if it is the only key\")).replace(\"%key%\", Qorakeys.DEFAULT.toString()));\n\t\tthis.errorMessages.put(ERROR_FEE_LESS_REQUIRED, Lang.getInstance().translate(\"fee less required\"));\n\t\tthis.errorMessages.put(ERROR_WALLET_NOT_IN_SYNC, Lang.getInstance().translate(\"wallet needs to be synchronized\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_NETWORK_ADDRESS, Lang.getInstance().translate(\"invalid network address\"));\n\t\t\t\t\n\t\t//WALLET\n\t\tthis.errorMessages.put(ERROR_WALLET_NO_EXISTS, Lang.getInstance().translate(\"wallet does not exist\"));\n\t\tthis.errorMessages.put(ERROR_WALLET_ADDRESS_NO_EXISTS, Lang.getInstance().translate(\"address does not exist in wallet\"));\n\t\tthis.errorMessages.put(ERROR_WALLET_LOCKED, Lang.getInstance().translate(\"wallet is locked\"));\n\t\tthis.errorMessages.put(ERROR_WALLET_ALREADY_EXISTS, Lang.getInstance().translate(\"wallet already exists\"));\n\t\tthis.errorMessages.put(ERROR_WALLET_API_CALL_FORBIDDEN_BY_USER, Lang.getInstance().translate(\"user denied api call\"));\n\t\t\n\t\t//BLOCK\n\t\tthis.errorMessages.put(ERROR_BLOCK_NO_EXISTS, Lang.getInstance().translate(\"block does not exist\"));\n\t\t\n\t\t//TRANSACTIONS\n\t\tthis.errorMessages.put(ERROR_TRANSACTION_NO_EXISTS, Lang.getInstance().translate(\"transactions does not exist\"));\n\t\tthis.errorMessages.put(ERROR_PUBLIC_KEY_NOT_FOUND, Lang.getInstance().translate(\"public key not found\"));\n\t\t\n\t\t//NAMING\n\t\tthis.errorMessages.put(ERROR_NAME_NO_EXISTS, Lang.getInstance().translate(\"name does not exist\"));\n\t\tthis.errorMessages.put(ERROR_NAME_ALREADY_EXISTS, Lang.getInstance().translate(\"name already exists\"));\n\t\tthis.errorMessages.put(ERROR_NAME_ALREADY_FOR_SALE, Lang.getInstance().translate(\"name already for sale\"));\n\t\tthis.errorMessages.put(ERROR_NAME_NOT_LOWER_CASE, Lang.getInstance().translate(\"name must be lower case\"));\n\t\tthis.errorMessages.put(ERROR_NAME_SALE_NO_EXISTS, Lang.getInstance().translate(\"namesale does not exist\"));\n\t\tthis.errorMessages.put(ERROR_BUYER_ALREADY_OWNER, Lang.getInstance().translate(\"buyer is already owner\"));\n\t\t\n\t\t//POLLS\n\t\tthis.errorMessages.put(ERROR_POLL_NO_EXISTS, Lang.getInstance().translate(\"poll does not exist\"));\n\t\tthis.errorMessages.put(ERROR_POLL_ALREADY_EXISTS, Lang.getInstance().translate(\"poll already exists\"));\n\t\tthis.errorMessages.put(ERROR_DUPLICATE_OPTION, Lang.getInstance().translate(\"not all options are unique\"));\n\t\tthis.errorMessages.put(ERROR_POLL_OPTION_NO_EXISTS, Lang.getInstance().translate(\"option does not exist\"));\n\t\tthis.errorMessages.put(ERROR_ALREADY_VOTED_FOR_THAT_OPTION, Lang.getInstance().translate(\"already voted for that option\"));\n\t\t\n\t\t//ASSETS\n\t\tthis.errorMessages.put(ERROR_INVALID_ASSET_ID, Lang.getInstance().translate(\"invalid asset id\"));\n\t\t\n\t\t//NAME PAYMENTS\n\t\tthis.errorMessages.put(ERROR_NAME_NOT_REGISTERED, Lang.getInstance().translate(NameResult.NAME_NOT_REGISTERED.getStatusMessage()));\n\t\tthis.errorMessages.put(ERROR_NAME_FOR_SALE, Lang.getInstance().translate(NameResult.NAME_FOR_SALE.getStatusMessage()));\n\t\tthis.errorMessages.put(ERROR_NAME_WITH_SPACE, Lang.getInstance().translate(NameResult.NAME_WITH_SPACE.getStatusMessage()));\n\t\t\n\t\t//AT\n\t\tthis.errorMessages.put(ERROR_INVALID_CREATION_BYTES, Lang.getInstance().translate(\"error in creation bytes\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_DESC_LENGTH, Lang.getInstance().translate(\"invalid description length. max length \") + AT_Constants.DESC_MAX_LENGTH);\n\t\tthis.errorMessages.put(ERROR_EMPTY_CODE, Lang.getInstance().translate(\"code is empty\"));\n\t\tthis.errorMessages.put(ERROR_DATA_SIZE, Lang.getInstance().translate(\"invalid data length\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_TYPE_LENGTH, Lang.getInstance().translate(\"invalid type length\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_TAGS_LENGTH, Lang.getInstance().translate(\"invalid tags length\"));\n\t\tthis.errorMessages.put(ERROR_NULL_PAGES, Lang.getInstance().translate(\"invalid pages\"));\n\t\t\n\t\t//BLOG\n\t\tthis.errorMessages.put(ERROR_BODY_EMPTY, Lang.getInstance().translate(\"invalid body it must not be empty\"));\n\t\tthis.errorMessages.put(ERROR_BLOG_DISABLED, Lang.getInstance().translate(\"this blog is disabled\"));\n\t\tthis.errorMessages.put(ERROR_NAME_NOT_OWNER, Lang.getInstance().translate(\"the creator address does not own the author name\"));\n\t\tthis.errorMessages.put(ERROR_TX_AMOUNT, Lang.getInstance().translate(\"the data size is too large - currently only %BATCH_TX_AMOUNT% arbitrary transactions are allowed at once!\").replace(\"%BATCH_TX_AMOUNT%\", String.valueOf(BATCH_TX_AMOUNT)));\n\t\tthis.errorMessages.put(ERROR_BLOG_ENTRY_NO_EXISTS, Lang.getInstance().translate(\"transaction with this signature contains no entries!\"));\n\t\tthis.errorMessages.put(ERROR_BLOG_EMPTY, Lang.getInstance().translate(\"this blog is empty\"));\n\t\tthis.errorMessages.put(ERROR_POSTID_EMPTY, Lang.getInstance().translate(\"the attribute postid is empty! this is the signature of the post you want to comment\"));\n\t\tthis.errorMessages.put(ERROR_POST_NOT_EXISTING, Lang.getInstance().translate(\"for the given postid no blogpost to comment was found\"));\n\t\tthis.errorMessages.put(ERROR_COMMENTING_DISABLED, Lang.getInstance().translate(\"commenting is for this blog disabled\"));\n\t\tthis.errorMessages.put(ERROR_COMMENT_NOT_EXISTING, Lang.getInstance().translate(\"for the given signature no comment was found\"));\n\t\tthis.errorMessages.put(ERROR_INVALID_COMMENT_OWNER, Lang.getInstance().translate(\"invalid comment owner\"));\n\t\t\n\t\t\n\t\t//MESSAGES\n\t\tthis.errorMessages.put(ERROR_MESSAGE_FORMAT_NOT_HEX, Lang.getInstance().translate(\"the Message format is not hex - correct the text or use isTextMessage = true\"));\n\t\tthis.errorMessages.put(ERROR_MESSAGE_BLANK, Lang.getInstance().translate(\"The message attribute is missing or content is blank\"));\n\t\tthis.errorMessages.put(ERROR_NO_PUBLIC_KEY, Lang.getInstance().translate(\"The recipient has not yet performed any action in the blockchain.\\nYou can't send an encrypted message to him.\"));\n\t\tthis.errorMessages.put(ERROR_MESSAGESIZE_EXCEEDED, Lang.getInstance().translate(\"Message size exceeded!\"));\n\t}\n\t\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic WebApplicationException createError(int error)\n\t{\n\t\tJSONObject jsonObject = new JSONObject();\n\t\tjsonObject.put(\"error\", error);\n\t\tif ( error > Transaction.AT_ERROR )\n\t\t{\n\t\t\tjsonObject.put(\"message\", AT_Error.getATError(error - Transaction.AT_ERROR) );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tjsonObject.put(\"message\", this.errorMessages.get(error));\n\t\t}\n\t\t\n\t\t\n\t\treturn new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(jsonObject.toJSONString()).build());\n\t}\n"]]}
{"hexsha": "14c9502fd410f4499cfc677fad2f4078828dba00", "ext": "java", "lang": "Java", "content": "@WebServlet(\"/comments-size\")\npublic class ServletSize extends HttpServlet {\n\n  private int numberOfComments;\n\n  public int loadComments() throws IOException {\n    Query commentsQuery = new Query(\"Comment\"); // Get previous stored comments\n\n    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();\n    \n    // Prepare to instance the past stored comments\n    PreparedQuery comments = datastore.prepare(commentsQuery);\n\n    return (int)comments.countEntities();\n  }\n  \n  @Override\n  public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    response.setContentType(\"text/html;\");\n    response.getWriter().println(loadComments());\n  }\n}", "class_id": 0, "repo": "RicardoChapaRomero/step2020-My-Portfolio", "file": "portfolio/src/main/java/com/google/sps/servlets/ServletSize.java", "last_update_at": "2020-07-03T21:11:25+00:00", "question_id": "14c9502fd410f4499cfc677fad2f4078828dba00", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@WebServlet(\"/comments-size\")\npublic class ServletSize extends HttpServlet {\n  private int numberOfComments;\n  public int loadComments() throws IOException {\n    Query commentsQuery = new Query(\"Comment\"); // Get previous stored comments\n    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();\n    // Prepare to instance the past stored comments\n    PreparedQuery comments = datastore.prepare(commentsQuery);\n    return (int)comments.countEntities();\n  }\n  @Override\n  public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    response.setContentType(\"text/html;\");\n    response.getWriter().println(loadComments());\n  }\n"]]}
{"hexsha": "f6fe006954ef098ff1b1a60e656fdba79ec8114e", "ext": "java", "lang": "Java", "content": "public class SharedMapCache extends AbstractValueAdaptingCache {\n\n    private final Map<Key, Value> store;\n    private final String name;\n\n    protected SharedMapCache(String name) {\n        super(false);\n        this.name = name;\n        this.store = new SharedOffHeapMap(2048);\n    }\n\n    @Override\n    protected Object lookup(Object o) {\n        Key key = Key.of((String) o);\n        Value value = store.get(key);\n        return (value == null ? null : value.get());\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public Object getNativeCache() {\n        return store;\n    }\n\n    @Override\n    public <T> T get(Object o, Callable<T> callable) {\n        if (this.store.containsKey(Key.of((String) o))) {\n            return (T) this.get(o).get();\n        } else {\n            synchronized(this.store) {\n                if (this.store.containsKey(Key.of((String) o))) {\n                    return (T) this.get(o).get();\n                } else {\n                    Object value;\n                    try {\n                        value = callable.call();\n                    } catch (Throwable t) {\n                        throw new ValueRetrievalException(o, callable, t);\n                    }\n\n                    this.put(o, value);\n                    return (T) value;\n                }\n            }\n        }\n\n    }\n\n    @Override\n    public void put(Object o, Object o1) {\n        store.put(Key.of((String) o), Value.of(o1));\n    }\n\n    @Override\n    public ValueWrapper putIfAbsent(Object o, Object o1) {\n        Object existing = this.store.putIfAbsent(Key.of((String) o), Value.of(this.toStoreValue(o1)));\n        return this.toValueWrapper(existing);\n    }\n\n    @Override\n    public void evict(Object o) {\n        store.remove(Key.of((String) o));\n    }\n\n    @Override\n    public void clear() {\n        store.clear();\n    }\n}", "class_id": 0, "repo": "graphaware/offheap", "file": "src/main/java/com/graphaware/offheap/cache/SharedMapCache.java", "last_update_at": "2020-02-01T10:39:52+00:00", "question_id": "f6fe006954ef098ff1b1a60e656fdba79ec8114e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SharedMapCache extends AbstractValueAdaptingCache {\n    private final Map<Key, Value> store;\n    private final String name;\n    protected SharedMapCache(String name) {\n        super(false);\n        this.name = name;\n        this.store = new SharedOffHeapMap(2048);\n    }\n    @Override\n    protected Object lookup(Object o) {\n        Key key = Key.of((String) o);\n        Value value = store.get(key);\n        return (value == null ? null : value.get());\n    }\n    @Override\n    public String getName() {\n        return name;\n    }\n    @Override\n    public Object getNativeCache() {\n        return store;\n    }\n    @Override\n    public <T> T get(Object o, Callable<T> callable) {\n        if (this.store.containsKey(Key.of((String) o))) {\n            return (T) this.get(o).get();\n        } else {\n            synchronized(this.store) {\n                if (this.store.containsKey(Key.of((String) o))) {\n                    return (T) this.get(o).get();\n                } else {\n                    Object value;\n                    try {\n                        value = callable.call();\n                    } catch (Throwable t) {\n                        throw new ValueRetrievalException(o, callable, t);\n                    }\n                    this.put(o, value);\n                    return (T) value;\n                }\n            }\n        }\n    }\n    @Override\n    public void put(Object o, Object o1) {\n        store.put(Key.of((String) o), Value.of(o1));\n    }\n    @Override\n    public ValueWrapper putIfAbsent(Object o, Object o1) {\n        Object existing = this.store.putIfAbsent(Key.of((String) o), Value.of(this.toStoreValue(o1)));\n        return this.toValueWrapper(existing);\n    }\n    @Override\n    public void evict(Object o) {\n        store.remove(Key.of((String) o));\n    }\n    @Override\n    public void clear() {\n        store.clear();\n    }\n"]]}
{"hexsha": "4e0feaadb88a73f8cd16c8a17885fed4045b4e8a", "ext": "java", "lang": "Java", "content": "public class ExternalAPIAccessFilter implements Filter {\n    private static final Logger logger = Logger.getLogger(ExternalAPIAccessFilter.class.getName());\n    private static String appName = \"\";\n\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        appName = filterConfig.getInitParameter(\"app_name\");\n    }\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n\n\n        logger.info(\"Get Patient Record request received \");\n\n        HttpServletRequest httpServletRequest = (HttpServletRequest) request;\n        HttpServletResponse httpServletResponse = (HttpServletResponse) response;\n\n        String reg_url = httpServletRequest.getRequestURL().toString();\n        // no token validation  for healthCheck request\n        if (reg_url.contains(\"healthCheck\")) {\n            chain.doFilter(request, response);\n        } else {\n\n            String headerAuthToken = ((HttpServletRequest) request).getHeader(\"Authorization\");\n            String userID = \"\";\n\n            // validate the incoming authorization token by calling dev keycloak and produce the principal user identifier associated with the token\n            Client client = ClientBuilder.newClient();\n\n            KeycloakConfig kc = getConfig();\n\n            String url = kc.getAuthServerUrl();\n            String path = kc.getPathPrefix() + \"/\" + kc.getRealm() + \"/\" + kc.getPathSuffix();\n\n            WebTarget target = client.target(url).path(path);\n\n            Boolean isUserAllowedAccess = false;\n\n            try {\n                Response kcResponse = target\n                        .request()\n                        .header(\"Authorization\", \"Bearer \" + headerAuthToken)\n                        .get();\n\n                String entityResponse = kcResponse.readEntity(String.class);\n\n                JSONParser parser = new JSONParser();\n                JSONObject users = (JSONObject) parser.parse(entityResponse);\n                userID = users.get(\"sub\").toString();\n\n                ((HttpServletRequest) request).getHeader(\"Authorization\");\n\n                if (kcResponse.getStatus() == HttpStatus.SC_OK) { // user is authorized in keycloak, so get the user record and ID associated with the token\n               /* String entityResponse = kcResponse.readEntity(String.class);\n                JSONParser parser = new JSONParser();\n                JSONObject users = (JSONObject) parser.parse(entityResponse);\n                userID = users.get(\"sub\").toString();\n                logger.info(\"userId: \"+userID);*/\n\n                    isUserAllowedAccess = UserCache.getExternalUserApplicationAccess(userID, appName);\n\n\n                } else { // user is not authorized with this token\n                    httpServletResponse.sendError(403, \"Access is Forbidden\");\n                    return;\n                }\n\n            } catch (Exception ex) {\n                httpServletResponse.sendError(403, \"Access is Forbidden\");\n                return;\n            }\n\n            MutableHttpServletRequest mutableRequest = new MutableHttpServletRequest(httpServletRequest);\n\n            mutableRequest.putHeader(\"user_id\", userID);\n\n            if (!isUserAllowedAccess) {\n                httpServletResponse.sendError(403, \"Access is Forbidden\");\n                return;\n            } else {\n\n                chain.doFilter(mutableRequest, response);\n                return;\n            }\n\n        }\n    }\n\n    @Override\n    public void destroy() {\n\n    }\n\n    private KeycloakConfig getConfig() throws IOException {\n        JsonNode jsonnode =  ConfigManager.getConfigurationAsJson(\"keycloak_filter\",\"ex_access_filter\");\n        KeycloakConfig keycloakConfig = new KeycloakConfig();\n        keycloakConfig.setAuthServerUrl(jsonnode.get(\"auth-server-url\").asText());\n        keycloakConfig.setRealm(jsonnode.get(\"realm\").asText());\n        keycloakConfig.setPathPrefix(jsonnode.get(\"path_prefix\").asText());\n        keycloakConfig.setPathSuffix(jsonnode.get(\"path_suffix\").asText());\n        return keycloakConfig;\n    }\n}", "class_id": 0, "repo": "endeavourhealth/Api", "file": "src/main/java/org/endeavourhealth/coreui/framework/ExternalAPIAccessFilter.java", "last_update_at": "2020-08-10T08:32:17+00:00", "question_id": "4e0feaadb88a73f8cd16c8a17885fed4045b4e8a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ExternalAPIAccessFilter implements Filter {\n    private static final Logger logger = Logger.getLogger(ExternalAPIAccessFilter.class.getName());\n    private static String appName = \"\";\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        appName = filterConfig.getInitParameter(\"app_name\");\n    }\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        logger.info(\"Get Patient Record request received \");\n        HttpServletRequest httpServletRequest = (HttpServletRequest) request;\n        HttpServletResponse httpServletResponse = (HttpServletResponse) response;\n        String reg_url = httpServletRequest.getRequestURL().toString();\n        // no token validation  for healthCheck request\n        if (reg_url.contains(\"healthCheck\")) {\n            chain.doFilter(request, response);\n        } else {\n            String headerAuthToken = ((HttpServletRequest) request).getHeader(\"Authorization\");\n            String userID = \"\";\n            // validate the incoming authorization token by calling dev keycloak and produce the principal user identifier associated with the token\n            Client client = ClientBuilder.newClient();\n            KeycloakConfig kc = getConfig();\n            String url = kc.getAuthServerUrl();\n            String path = kc.getPathPrefix() + \"/\" + kc.getRealm() + \"/\" + kc.getPathSuffix();\n            WebTarget target = client.target(url).path(path);\n            Boolean isUserAllowedAccess = false;\n            try {\n                Response kcResponse = target\n                        .request()\n                        .header(\"Authorization\", \"Bearer \" + headerAuthToken)\n                        .get();\n                String entityResponse = kcResponse.readEntity(String.class);\n                JSONParser parser = new JSONParser();\n                JSONObject users = (JSONObject) parser.parse(entityResponse);\n                userID = users.get(\"sub\").toString();\n                ((HttpServletRequest) request).getHeader(\"Authorization\");\n                if (kcResponse.getStatus() == HttpStatus.SC_OK) { // user is authorized in keycloak, so get the user record and ID associated with the token\n               /* String entityResponse = kcResponse.readEntity(String.class);\n                JSONParser parser = new JSONParser();\n                JSONObject users = (JSONObject) parser.parse(entityResponse);\n                userID = users.get(\"sub\").toString();\n                logger.info(\"userId: \"+userID);*/\n                    isUserAllowedAccess = UserCache.getExternalUserApplicationAccess(userID, appName);\n                } else { // user is not authorized with this token\n                    httpServletResponse.sendError(403, \"Access is Forbidden\");\n                    return;\n                }\n            } catch (Exception ex) {\n                httpServletResponse.sendError(403, \"Access is Forbidden\");\n                return;\n            }\n            MutableHttpServletRequest mutableRequest = new MutableHttpServletRequest(httpServletRequest);\n            mutableRequest.putHeader(\"user_id\", userID);\n            if (!isUserAllowedAccess) {\n                httpServletResponse.sendError(403, \"Access is Forbidden\");\n                return;\n            } else {\n                chain.doFilter(mutableRequest, response);\n                return;\n            }\n        }\n    }\n    @Override\n    public void destroy() {\n    }\n    private KeycloakConfig getConfig() throws IOException {\n        JsonNode jsonnode =  ConfigManager.getConfigurationAsJson(\"keycloak_filter\",\"ex_access_filter\");\n        KeycloakConfig keycloakConfig = new KeycloakConfig();\n        keycloakConfig.setAuthServerUrl(jsonnode.get(\"auth-server-url\").asText());\n        keycloakConfig.setRealm(jsonnode.get(\"realm\").asText());\n        keycloakConfig.setPathPrefix(jsonnode.get(\"path_prefix\").asText());\n        keycloakConfig.setPathSuffix(jsonnode.get(\"path_suffix\").asText());\n        return keycloakConfig;\n    }\n"]]}
{"hexsha": "0c2f366cff190ea650d6a32a477a52b155cbc83b", "ext": "java", "lang": "Java", "content": "final class UtilDigesterBeanDefinitionParser extends AbstractEncryptionBeanDefinitionParser {\n\n    private static final String SCOPE_ATTRIBUTE = \"scope\";\n    \n    private static final String PARAM_ALGORITHM = \"algorithm\"; \n    private static final String PARAM_CONFIG_BEAN = \"config-bean\"; \n    private static final String PARAM_PROVIDER_BEAN = \"provider-bean\"; \n    private static final String PARAM_PROVIDER_NAME = \"provider-name\"; \n    private static final String PARAM_STRING_OUTPUT_TYPE = \"string-output-type\"; \n    \n    static final int UTIL_TYPE_BASIC = 0;\n    static final int UTIL_TYPE_STRONG = 1;\n    static final int UTIL_TYPE_CONFIGURABLE = 2;\n    \n    private final int utilType;\n    \n    \n    UtilDigesterBeanDefinitionParser(final int utilType) {\n        super();\n        this.utilType = utilType;\n    }\n\n    \n    @Override\n    protected Class<?> getBeanClass(final Element element) {\n        if (this.utilType == UTIL_TYPE_BASIC) {\n            return BasicPasswordEncryptor.class;\n        } else if (this.utilType == UTIL_TYPE_STRONG) {\n            return StrongPasswordEncryptor.class;\n        } else if (this.utilType == UTIL_TYPE_CONFIGURABLE) {\n            return ConfigurablePasswordEncryptor.class;\n        } else {\n            throw new IllegalArgumentException(\"Unknown util type: \" + this.utilType);\n        }\n    }\n\n\n    @Override\n    protected void doParse(final Element element, final BeanDefinitionBuilder builder) {\n        \n        processStringAttribute(element, builder, PARAM_ALGORITHM, \"algorithm\");\n        processBeanAttribute(element, builder, PARAM_CONFIG_BEAN, \"config\");\n        processBeanAttribute(element, builder, PARAM_PROVIDER_BEAN, \"provider\");\n        processStringAttribute(element, builder, PARAM_PROVIDER_NAME, \"providerName\");\n        processStringAttribute(element, builder, PARAM_STRING_OUTPUT_TYPE, \"stringOutputType\");\n        \n        String scope = element.getAttribute(SCOPE_ATTRIBUTE);\n        if (StringUtils.hasLength(scope)) {\n            builder.setScope(scope);\n        }\n        \n    }\n    \n    \n}", "class_id": 0, "repo": "xiaowenyu/jasypt", "file": "jasypt-spring4/src/main/java/org/jasypt/spring4/xml/encryption/UtilDigesterBeanDefinitionParser.java", "last_update_at": "2020-07-23T22:18:32+00:00", "question_id": "0c2f366cff190ea650d6a32a477a52b155cbc83b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["final class UtilDigesterBeanDefinitionParser extends AbstractEncryptionBeanDefinitionParser {\n    private static final String SCOPE_ATTRIBUTE = \"scope\";\n    private static final String PARAM_ALGORITHM = \"algorithm\"; \n    private static final String PARAM_CONFIG_BEAN = \"config-bean\"; \n    private static final String PARAM_PROVIDER_BEAN = \"provider-bean\"; \n    private static final String PARAM_PROVIDER_NAME = \"provider-name\"; \n    private static final String PARAM_STRING_OUTPUT_TYPE = \"string-output-type\"; \n    static final int UTIL_TYPE_BASIC = 0;\n    static final int UTIL_TYPE_STRONG = 1;\n    static final int UTIL_TYPE_CONFIGURABLE = 2;\n    private final int utilType;\n    UtilDigesterBeanDefinitionParser(final int utilType) {\n        super();\n        this.utilType = utilType;\n    }\n    @Override\n    protected Class<?> getBeanClass(final Element element) {\n        if (this.utilType == UTIL_TYPE_BASIC) {\n            return BasicPasswordEncryptor.class;\n        } else if (this.utilType == UTIL_TYPE_STRONG) {\n            return StrongPasswordEncryptor.class;\n        } else if (this.utilType == UTIL_TYPE_CONFIGURABLE) {\n            return ConfigurablePasswordEncryptor.class;\n        } else {\n            throw new IllegalArgumentException(\"Unknown util type: \" + this.utilType);\n        }\n    }\n    @Override\n    protected void doParse(final Element element, final BeanDefinitionBuilder builder) {\n        processStringAttribute(element, builder, PARAM_ALGORITHM, \"algorithm\");\n        processBeanAttribute(element, builder, PARAM_CONFIG_BEAN, \"config\");\n        processBeanAttribute(element, builder, PARAM_PROVIDER_BEAN, \"provider\");\n        processStringAttribute(element, builder, PARAM_PROVIDER_NAME, \"providerName\");\n        processStringAttribute(element, builder, PARAM_STRING_OUTPUT_TYPE, \"stringOutputType\");\n        String scope = element.getAttribute(SCOPE_ATTRIBUTE);\n        if (StringUtils.hasLength(scope)) {\n            builder.setScope(scope);\n        }\n    }\n"]]}
{"hexsha": "3b8822d52e95cd91642341425a04098e1b94030c", "ext": "java", "lang": "Java", "content": "public class SQFLintServer {\n\tprivate final Options options;\n\t\n\tpublic SQFLintServer(Options options) {\n\t\tthis.options = options;\n\t}\n\t\n\tpublic void start() {\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t\twhile (true) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!processMessage(new JSONObject(br.readLine()))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} catch (JSONException ex) {\n\t\t\t\t\tLogger.getLogger(SQFLintServer.class.getName()).log(Level.SEVERE, null, ex);\n\t\t\t\t\tSystem.err.println(\"Error parsing client message\");\n\t\t\t\t}\n\t\t\t}\n\t\t}  catch (IOException ex) {\n\t\t\tLogger.getLogger(SQFLintServer.class.getName()).log(Level.SEVERE, null, ex);\n\t\t}\n\t}\n\t\n\tprivate boolean processMessage(JSONObject message) {\n\t\tLogUtil.benchLog(options, this, \"/ClientMessage\", \"Client message received\");\n\t\t\n\t\tString filePath = null; // declare here to use in catch block\n\t\ttry {\n\t\t\tif (message.has(\"type\") && \"exit\".equals(message.getString(\"type\"))) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// read filepath\n\t\t\tfilePath = message.getString(\"file\");\n\t\t\t\n\t\t\tLogUtil.benchLog(options, this, filePath, \"Starting\");\n\t\t\t\n\t\t\t// Apply file specific options\n\t\t\tOptions fileOptions = new Options(options, new ServerOutput(filePath));\n\t\t\tfileOptions.setRootPath(Paths.get(filePath).toAbsolutePath().getParent().toString());\n\t\t\tfileOptions.getSkippedVariables().clear();\n\n\t\t\tif (message.has(\"options\")) {\n\t\t\t\tthis.applyOptions(message.getJSONObject(\"options\"), fileOptions);\n\t\t\t}\n\n\t\t\tSqfFile sqfFile = new SqfFile(\n\t\t\t\tfileOptions,\n\t\t\t\tmessage.has(\"contents\") ?\n\t\t\t\t\tmessage.getString(\"contents\")\n\t\t\t\t\t:\n\t\t\t\t\tStreamUtil.streamToString(new FileInputStream(filePath)),\n\t\t\t\tfilePath\n\t\t\t);\n\n\t\t\tsqfFile.process();\n\n\t\t\tfileOptions.getOutputFormatter().print(sqfFile);\n\n\t\t\tLogUtil.benchLog(options, this, filePath, \"Done\");\n\n\t\t} catch (JSONException ex) {\n\t\t\tLogger.getLogger(SQFLintServer.class.getName()).log(Level.SEVERE, null, ex);\n\t\t} catch (Exception ex) {\n\t\t\tLogger.getLogger(SQFLintServer.class.getName()).log(Level.SEVERE, \"Error when parsing {0}\", filePath);\n\t\t\tLogger.getLogger(SQFLintServer.class.getName()).log(Level.SEVERE, null, ex);\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tprivate void applyOptions(JSONObject data, Options fileOptions) {\n\t\ttry {\n\t\t\t// @TODO: Clear options?\n\t\t\t\n\t\t\tif (data.has(\"checkPaths\")) {\n\t\t\t\tfileOptions.setCheckPaths(data.getBoolean(\"checkPaths\"));\n\t\t\t}\n\t\t\t\n\t\t\tif (data.has(\"pathsRoot\")) {\n\t\t\t\tfileOptions.setRootPath(data.getString(\"pathsRoot\"));\n\t\t\t}\n\t\t\t\n\t\t\tif (data.has(\"ignoredVariables\")) {\n\t\t\t\tJSONArray vars = data.getJSONArray(\"ignoredVariables\");\n\t\t\t\tfor (int i = 0; i < vars.length(); i++) {\n\t\t\t\t\tfileOptions.getSkippedVariables().add(vars.getString(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\tif (data.has(\"includePrefixes\")) {\n\t\t\t\tfileOptions.getIncludePaths().clear();\n\t\t\t\tJSONObject paths = data.getJSONObject(\"includePrefixes\");\n\t\t\t\tfor (String key : paths.keySet()) {\n\t\t\t\t\tfileOptions.getIncludePaths().put(key, paths.getString(key));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (data.has(\"contextSeparation\")) {\n\t\t\t\tfileOptions.setContextSeparationEnabled(data.getBoolean(\"contextSeparation\"));\n\t\t\t}\n\t\t\t\n\t\t} catch (JSONException ex) {\n\t\t\tLogger.getLogger(SQFLintServer.class.getName()).log(Level.SEVERE, null, ex);\n\t\t}\n\t}\n\t\n}", "class_id": 0, "repo": "RZSenfo/sqflint", "file": "src/cz/zipek/sqflint/SQFLintServer.java", "last_update_at": "2020-12-25T15:25:16+00:00", "question_id": "3b8822d52e95cd91642341425a04098e1b94030c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SQFLintServer {\n\tprivate final Options options;\n\t\n\tpublic SQFLintServer(Options options) {\n\t\tthis.options = options;\n\t}\n\t\n\tpublic void start() {\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\twhile (true) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!processMessage(new JSONObject(br.readLine()))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} catch (JSONException ex) {\n\t\t\t\t\tLogger.getLogger(SQFLintServer.class.getName()).log(Level.SEVERE, null, ex);\n\t\t\t\t\tSystem.err.println(\"Error parsing client message\");\n\t\t\t\t}\n\t\t\t}\n\t\t}  catch (IOException ex) {\n\t\t\tLogger.getLogger(SQFLintServer.class.getName()).log(Level.SEVERE, null, ex);\n\t\t}\n\t}\n\t\n\tprivate boolean processMessage(JSONObject message) {\n\t\tLogUtil.benchLog(options, this, \"/ClientMessage\", \"Client message received\");\n\t\t\n\t\tString filePath = null; // declare here to use in catch block\n\t\ttry {\n\t\t\tif (message.has(\"type\") && \"exit\".equals(message.getString(\"type\"))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// read filepath\n\t\t\tfilePath = message.getString(\"file\");\n\t\t\t\n\t\t\tLogUtil.benchLog(options, this, filePath, \"Starting\");\n\t\t\t\n\t\t\t// Apply file specific options\n\t\t\tOptions fileOptions = new Options(options, new ServerOutput(filePath));\n\t\t\tfileOptions.setRootPath(Paths.get(filePath).toAbsolutePath().getParent().toString());\n\t\t\tfileOptions.getSkippedVariables().clear();\n\t\t\tif (message.has(\"options\")) {\n\t\t\t\tthis.applyOptions(message.getJSONObject(\"options\"), fileOptions);\n\t\t\t}\n\t\t\tSqfFile sqfFile = new SqfFile(\n\t\t\t\tfileOptions,\n\t\t\t\tmessage.has(\"contents\") ?\n\t\t\t\t\tmessage.getString(\"contents\")\n\t\t\t\t\t:\n\t\t\t\t\tStreamUtil.streamToString(new FileInputStream(filePath)),\n\t\t\t\tfilePath\n\t\t\t);\n\t\t\tsqfFile.process();\n\t\t\tfileOptions.getOutputFormatter().print(sqfFile);\n\t\t\tLogUtil.benchLog(options, this, filePath, \"Done\");\n\t\t} catch (JSONException ex) {\n\t\t\tLogger.getLogger(SQFLintServer.class.getName()).log(Level.SEVERE, null, ex);\n\t\t} catch (Exception ex) {\n\t\t\tLogger.getLogger(SQFLintServer.class.getName()).log(Level.SEVERE, \"Error when parsing {0}\", filePath);\n\t\t\tLogger.getLogger(SQFLintServer.class.getName()).log(Level.SEVERE, null, ex);\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tprivate void applyOptions(JSONObject data, Options fileOptions) {\n\t\ttry {\n\t\t\t// @TODO: Clear options?\n\t\t\t\n\t\t\tif (data.has(\"checkPaths\")) {\n\t\t\t\tfileOptions.setCheckPaths(data.getBoolean(\"checkPaths\"));\n\t\t\t}\n\t\t\t\n\t\t\tif (data.has(\"pathsRoot\")) {\n\t\t\t\tfileOptions.setRootPath(data.getString(\"pathsRoot\"));\n\t\t\t}\n\t\t\t\n\t\t\tif (data.has(\"ignoredVariables\")) {\n\t\t\t\tJSONArray vars = data.getJSONArray(\"ignoredVariables\");\n\t\t\t\tfor (int i = 0; i < vars.length(); i++) {\n\t\t\t\t\tfileOptions.getSkippedVariables().add(vars.getString(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\tif (data.has(\"includePrefixes\")) {\n\t\t\t\tfileOptions.getIncludePaths().clear();\n\t\t\t\tJSONObject paths = data.getJSONObject(\"includePrefixes\");\n\t\t\t\tfor (String key : paths.keySet()) {\n\t\t\t\t\tfileOptions.getIncludePaths().put(key, paths.getString(key));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (data.has(\"contextSeparation\")) {\n\t\t\t\tfileOptions.setContextSeparationEnabled(data.getBoolean(\"contextSeparation\"));\n\t\t\t}\n\t\t\t\n\t\t} catch (JSONException ex) {\n\t\t\tLogger.getLogger(SQFLintServer.class.getName()).log(Level.SEVERE, null, ex);\n\t\t}\n\t}\n\t\n"]]}
{"hexsha": "38aa23fa3e61ae0006a50f9755e6c17f8e2129e5", "ext": "java", "lang": "Java", "content": "public abstract class AbstractResource implements Resource {\n    public AbstractResource() {\n    }\n\n    public boolean exists() {\n        Log logger;\n        if (this.isFile()) {\n            try {\n                return this.getFile().exists();\n            } catch (IOException var4) {\n                logger = LogFactory.getLog(this.getClass());\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Could not retrieve File for existence check of \" + this.getDescription(), var4);\n                }\n            }\n        }\n\n        try {\n            this.getInputStream().close();\n            return true;\n        } catch (Throwable var3) {\n            logger = LogFactory.getLog(this.getClass());\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Could not retrieve InputStream for existence check of \" + this.getDescription(), var3);\n            }\n\n            return false;\n        }\n    }\n\n    public boolean isReadable() {\n        return this.exists();\n    }\n\n    public boolean isOpen() {\n        return false;\n    }\n\n    public boolean isFile() {\n        return false;\n    }\n\n    public URL getURL() throws IOException {\n        throw new FileNotFoundException(this.getDescription() + \" cannot be resolved to URL\");\n    }\n\n    public URI getURI() throws IOException {\n        URL url = this.getURL();\n\n        try {\n            return ResourceUtils.toURI(url);\n        } catch (URISyntaxException var3) {\n            throw new NestedIOException(\"Invalid URI [\" + url + \"]\", var3);\n        }\n    }\n\n    public File getFile() throws IOException {\n        throw new FileNotFoundException(this.getDescription() + \" cannot be resolved to absolute file path\");\n    }\n\n    public ReadableByteChannel readableChannel() throws IOException {\n        return Channels.newChannel(this.getInputStream());\n    }\n\n    public long contentLength() throws IOException {\n        InputStream is = this.getInputStream();\n        boolean var16 = false;\n\n        long var6;\n        try {\n            var16 = true;\n            long size = 0L;\n            byte[] buf = new byte[256];\n\n            while(true) {\n                int read;\n                if ((read = is.read(buf)) == -1) {\n                    var6 = size;\n                    var16 = false;\n                    break;\n                }\n\n                size += (long)read;\n            }\n        } finally {\n            if (var16) {\n                try {\n                    is.close();\n                } catch (IOException var17) {\n                    Log logger = LogFactory.getLog(this.getClass());\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Could not close content-length InputStream for \" + this.getDescription(), var17);\n                    }\n                }\n\n            }\n        }\n\n        try {\n            is.close();\n        } catch (IOException var18) {\n            Log logger = LogFactory.getLog(this.getClass());\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Could not close content-length InputStream for \" + this.getDescription(), var18);\n            }\n        }\n\n        return var6;\n    }\n\n    public long lastModified() throws IOException {\n        File fileToCheck = this.getFileForLastModifiedCheck();\n        long lastModified = fileToCheck.lastModified();\n        if (lastModified == 0L && !fileToCheck.exists()) {\n            throw new FileNotFoundException(this.getDescription() + \" cannot be resolved in the file system for checking its last-modified timestamp\");\n        } else {\n            return lastModified;\n        }\n    }\n\n    protected File getFileForLastModifiedCheck() throws IOException {\n        return this.getFile();\n    }\n\n    public Resource createRelative(String relativePath) throws IOException {\n        throw new FileNotFoundException(\"Cannot create a relative resource for \" + this.getDescription());\n    }\n\n    \n    public String getFilename() {\n        return null;\n    }\n\n    public boolean equals( Object other) {\n        return this == other || other instanceof Resource && ((Resource)other).getDescription().equals(this.getDescription());\n    }\n\n    public int hashCode() {\n        return this.getDescription().hashCode();\n    }\n\n    public String toString() {\n        return this.getDescription();\n    }\n}", "class_id": 0, "repo": "guoshucan/mpaas", "file": "ghost.framework.module/src/main/java/ghost/framework/module/io/AbstractResource.java", "last_update_at": "2020-09-29T10:24:03+00:00", "question_id": "38aa23fa3e61ae0006a50f9755e6c17f8e2129e5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class AbstractResource implements Resource {\n    public AbstractResource() {\n    }\n    public boolean exists() {\n        Log logger;\n        if (this.isFile()) {\n            try {\n                return this.getFile().exists();\n            } catch (IOException var4) {\n                logger = LogFactory.getLog(this.getClass());\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Could not retrieve File for existence check of \" + this.getDescription(), var4);\n                }\n            }\n        }\n        try {\n            this.getInputStream().close();\n            return true;\n        } catch (Throwable var3) {\n            logger = LogFactory.getLog(this.getClass());\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Could not retrieve InputStream for existence check of \" + this.getDescription(), var3);\n            }\n            return false;\n        }\n    }\n    public boolean isReadable() {\n        return this.exists();\n    }\n    public boolean isOpen() {\n        return false;\n    }\n    public boolean isFile() {\n        return false;\n    }\n    public URL getURL() throws IOException {\n        throw new FileNotFoundException(this.getDescription() + \" cannot be resolved to URL\");\n    }\n    public URI getURI() throws IOException {\n        URL url = this.getURL();\n        try {\n            return ResourceUtils.toURI(url);\n        } catch (URISyntaxException var3) {\n            throw new NestedIOException(\"Invalid URI [\" + url + \"]\", var3);\n        }\n    }\n    public File getFile() throws IOException {\n        throw new FileNotFoundException(this.getDescription() + \" cannot be resolved to absolute file path\");\n    }\n    public ReadableByteChannel readableChannel() throws IOException {\n        return Channels.newChannel(this.getInputStream());\n    }\n    public long contentLength() throws IOException {\n        InputStream is = this.getInputStream();\n        boolean var16 = false;\n        long var6;\n        try {\n            var16 = true;\n            long size = 0L;\n            byte[] buf = new byte[256];\n            while(true) {\n                int read;\n                if ((read = is.read(buf)) == -1) {\n                    var6 = size;\n                    var16 = false;\n                    break;\n                }\n                size += (long)read;\n            }\n        } finally {\n            if (var16) {\n                try {\n                    is.close();\n                } catch (IOException var17) {\n                    Log logger = LogFactory.getLog(this.getClass());\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Could not close content-length InputStream for \" + this.getDescription(), var17);\n                    }\n                }\n            }\n        }\n        try {\n            is.close();\n        } catch (IOException var18) {\n            Log logger = LogFactory.getLog(this.getClass());\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Could not close content-length InputStream for \" + this.getDescription(), var18);\n            }\n        }\n        return var6;\n    }\n    public long lastModified() throws IOException {\n        File fileToCheck = this.getFileForLastModifiedCheck();\n        long lastModified = fileToCheck.lastModified();\n        if (lastModified == 0L && !fileToCheck.exists()) {\n            throw new FileNotFoundException(this.getDescription() + \" cannot be resolved in the file system for checking its last-modified timestamp\");\n        } else {\n            return lastModified;\n        }\n    }\n    protected File getFileForLastModifiedCheck() throws IOException {\n        return this.getFile();\n    }\n    public Resource createRelative(String relativePath) throws IOException {\n        throw new FileNotFoundException(\"Cannot create a relative resource for \" + this.getDescription());\n    }\n    public String getFilename() {\n        return null;\n    }\n    public boolean equals( Object other) {\n        return this == other || other instanceof Resource && ((Resource)other).getDescription().equals(this.getDescription());\n    }\n    public int hashCode() {\n        return this.getDescription().hashCode();\n    }\n    public String toString() {\n        return this.getDescription();\n    }\n"]]}
{"hexsha": "4c7b003c483b4ab8973c1a26e7e72c8d8d72c0ee", "ext": "java", "lang": "Java", "content": "@Endpoint(id = \"oauthTokens\", enableByDefault = false)\n@RequiredArgsConstructor\n@Slf4j\npublic class OAuth20TokenManagementEndpoint {\n    /**\n     * The Ticket registry.\n     */\n    private final TicketRegistry ticketRegistry;\n\n    /**\n     * Gets access tokens.\n     *\n     * @return the access tokens\n     */\n    @ReadOperation\n    public Collection<Ticket> getTokens() {\n        return ticketRegistry.getTickets(ticket -> (ticket instanceof AccessToken || ticket instanceof RefreshToken) && !ticket.isExpired())\n            .sorted(Comparator.comparing(Ticket::getId))\n            .collect(Collectors.toList());\n    }\n\n\n    /**\n     * Gets access token.\n     *\n     * @param ticketId the ticket id\n     * @return the access token\n     */\n    @ReadOperation\n    public Ticket getToken(@Selector final String ticketId) {\n        var ticket = (Ticket) ticketRegistry.getTicket(ticketId, AccessToken.class);\n        if (ticket == null) {\n            ticket = ticketRegistry.getTicket(ticketId, RefreshToken.class);\n        }\n        if (ticket == null) {\n            LOGGER.debug(\"Ticket [{}] is not found\", ticketId);\n            return null;\n        }\n        if (ticket.isExpired()) {\n            LOGGER.debug(\"Ticket [{}] is has expired\", ticketId);\n            return null;\n        }\n        return ticket;\n    }\n\n    /**\n     * Delete access token.\n     *\n     * @param ticketId the ticket id\n     */\n    @DeleteOperation\n    public void deleteToken(@Selector final String ticketId) {\n        val ticket = getToken(ticketId);\n        if (ticket != null) {\n            ticketRegistry.deleteTicket(ticketId);\n        }\n    }\n}", "class_id": 0, "repo": "cedric-lamalle/cas", "file": "support/cas-server-support-oauth/src/main/java/org/apereo/cas/support/oauth/web/mgmt/OAuth20TokenManagementEndpoint.java", "last_update_at": "2020-12-26T19:11:34+00:00", "question_id": "4c7b003c483b4ab8973c1a26e7e72c8d8d72c0ee", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Endpoint(id = \"oauthTokens\", enableByDefault = false)\n@RequiredArgsConstructor\n@Slf4j\npublic class OAuth20TokenManagementEndpoint {\n    /**\n     * The Ticket registry.\n     */\n    private final TicketRegistry ticketRegistry;\n    /**\n     * Gets access tokens.\n     *\n     * @return the access tokens\n     */\n    @ReadOperation\n    public Collection<Ticket> getTokens() {\n        return ticketRegistry.getTickets(ticket -> (ticket instanceof AccessToken || ticket instanceof RefreshToken) && !ticket.isExpired())\n            .sorted(Comparator.comparing(Ticket::getId))\n            .collect(Collectors.toList());\n    }\n    /**\n     * Gets access token.\n     *\n     * @param ticketId the ticket id\n     * @return the access token\n     */\n    @ReadOperation\n    public Ticket getToken(@Selector final String ticketId) {\n        var ticket = (Ticket) ticketRegistry.getTicket(ticketId, AccessToken.class);\n        if (ticket == null) {\n            ticket = ticketRegistry.getTicket(ticketId, RefreshToken.class);\n        }\n        if (ticket == null) {\n            LOGGER.debug(\"Ticket [{}] is not found\", ticketId);\n            return null;\n        }\n        if (ticket.isExpired()) {\n            LOGGER.debug(\"Ticket [{}] is has expired\", ticketId);\n            return null;\n        }\n        return ticket;\n    }\n    /**\n     * Delete access token.\n     *\n     * @param ticketId the ticket id\n     */\n    @DeleteOperation\n    public void deleteToken(@Selector final String ticketId) {\n        val ticket = getToken(ticketId);\n        if (ticket != null) {\n            ticketRegistry.deleteTicket(ticketId);\n        }\n    }\n"]]}
{"hexsha": "f35033385385fcf1569c01f2476ce3de0ccf8307", "ext": "java", "lang": "Java", "content": "public class VersioningInterest implements CCNCategorizedStatistics {\n\t\n\t// ==============================================================================\n\t// Public API\n\n\t/**\n\t * @param handle\n\t * @param listener\n\t */\n\tpublic VersioningInterest(CCNHandle handle) {\n\t\t_handle = handle;\n\t}\n\t\n\t/**\n\t * Express an interest for #name.  We will assume that #name does not\n\t * include a version, and we construct an interest that will only match\n\t * 3 additional components to #name (version/segment/digest).\n\t * \n\t * When the default CCN timeout is exceeded, we stop responding.\n\t * \n\t * If there is already an interest for the same (name, listener), no action is taken.\n\t * \n\t * The return value from #listener is ignored, the listener does not need to re-express\n\t * an interest.  Interests are re-expressed automatically until canceled.\n\t * \n\t * @param name\n\t * @param listener\n\t * @throws IOException \n\t */\n\tpublic void expressInterest(ContentName name, CCNContentHandler handler) throws IOException {\n\t\texpressInterest(name, handler, null, null);\n\t}\n\n\t/**\n\t * As above, and provide a set of versions to exclude\n\t * The return value from #listener is ignored, the listener does not need to re-express\n\t * an interest.  Interests are re-expressed automatically until canceled.\n\t * \n\t * @param name\n\t * @param handler\n\t * @param retrySeconds\n\t * @param exclusions may be null\n\t * @throws IOException \n\t */\n\tpublic void expressInterest(ContentName name, CCNContentHandler handler, Set<VersionNumber> exclusions) throws IOException {\n\t\texpressInterest(name, handler, exclusions, null);\n\t}\n\t\n\t/**\n\t * As above, and provide a set of versions to exclude and a hard floor startingVersion, any version\n\t * before that will be ignored.\n\t * \n\t * The return value from #listener is ignored, the listener does not need to re-express\n\t * an interest.  Interests are re-expressed automatically until canceled.\n\t * \n\t * @param name\n\t * @param handler\n\t * @param retrySeconds\n\t * @param exclusions may be null\n\t * @param startingVersion the minimum version to include (may be null)\n\t * @throws IOException \n\t */\n\tpublic void expressInterest(ContentName name, CCNContentHandler handler, Set<VersionNumber> exclusions, VersionNumber startingVeersion) throws IOException {\n\t\taddInterest(name, handler, exclusions, startingVeersion);\n\t}\n\t\n\t/**\n\t * Kill off all interests.\n\t */\n\t\n\tpublic void close() {\n\t\tremoveAll();\n\t}\n\n\t/**\n\t * Cancel a specific interest\n\t * @param name\n\t * @param handler\n\t */\n\tpublic void cancelInterest(ContentName name, CCNContentHandler handler) {\n\t\tremoveInterest(name, handler);\n\t}\n\n\t/**\n\t * in case we're GC'd without a close().  Don't rely on this.\n\t */\n\tprotected void finalize() throws Throwable {\n\t\ttry {\n\t\t\tremoveAll();\n\t\t} finally {\n\t\t\tsuper.finalize();\n\t\t}\n\t}\n\t\n\t/**\n\t * return the statistics for the interests corresponding to name\n\t * @param name A ContentName or a URI-encoded string\n\t * @return May be null if no interest expressed for name\n\t */\n\tpublic CCNStats getStatsByName(Object name) throws ClassCastException {\n\t\tContentName cn = null;\n\t\tif( name instanceof ContentName )\n\t\t\tcn = (ContentName) name;\n\t\telse if( name instanceof String )\n\t\t\ttry {\n\t\t\t\tcn = ContentName.fromURI((String) name);\n\t\t\t} catch (MalformedContentNameStringException e) {\n\t\t\t}\n\t\n\t\tif( null == cn )\n\t\t\tthrow new ClassCastException(\"Name must be a ContentName or a URI string\");\n\t\t\n\t\tsynchronized(_map) {\n\t\t\tBasenameState data = _map.get(cn);\n\t\t\tif( null != data )\n\t\t\t\treturn data.getStats();\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\tpublic Object[] getCategoryNames() {\n\t\tsynchronized(_map) {\n\t\t\treturn _map.keySet().toArray();\n\t\t}\n\t}\n\t\n\t// ==============================================================================\n\t// Internal implementation\n\tprivate final CCNHandle _handle;\n\tprivate final Map<ContentName, BasenameState> _map = new HashMap<ContentName, BasenameState>();\n\n\tprivate void addInterest(ContentName name, CCNContentHandler handler, Set<VersionNumber> exclusions, VersionNumber startingVersion) throws IOException {\n\t\tBasenameState data;\n\t\t\n\t\tsynchronized(_map) {\n\t\t\tdata = _map.get(name);\n\t\t\tif( null == data ) {\n\t\t\t\tdata = new BasenameState(_handle, name, exclusions, startingVersion);\n\t\t\t\t_map.put(name, data);\n\t\t\t\tdata.addListener(handler);\n\t\t\t\tdata.start();\n\t\t\t} else {\n\t\t\t\tdata.addListener(handler);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Remove a listener.  If it is the last listener, remove from map and\n\t * kill all interests.\n\t * @param name\n\t * @param listener\n\t */\n\tprivate void removeInterest(ContentName name, CCNContentHandler handler) {\n\t\tBasenameState data;\n\t\t\n\t\tsynchronized(_map) {\n\t\t\tdata = _map.get(name);\n\t\t\tif( null != data ) {\n\t\t\t\tdata.removeListener(handler);\n\t\t\t\tif( data.size() == 0 ) {\n\t\t\t\t\tdata.stop();\n\t\t\t\t\t_map.remove(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void removeAll() {\n\t\tsynchronized(_map) {\n\t\t\tIterator<BasenameState> iter = _map.values().iterator();\n\t\t\twhile( iter.hasNext() ) {\n\t\t\t\tBasenameState bns = iter.next();\n\t\t\t\tbns.stop();\n\t\t\t\titer.remove();\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ======================================================================\n\t// This is the state stored per base name\n\t\n\tprivate static class BasenameState implements CCNContentHandler, CCNStatistics {\n\t\t\n\t\tpublic BasenameState(CCNHandle handle, ContentName basename, Set<VersionNumber> exclusions, VersionNumber startingVersion) {\n\t\t\t_vim = new VersioningInterestManager(handle, basename, exclusions, startingVersion, this);\n\t\t}\n\t\t\n\t\t/**\n\t\t * @param listener\n\t\t * @param retrySeconds IGNORED, not implemented\n\t\t * @return true if added, false if existed or only retrySeconds updated\n\t\t */\n\t\tpublic boolean addListener(CCNContentHandler handler) {\n\t\t\tif( handler == null) return false;\n\t\t\tsynchronized(_handlers) {\n\t\t\t\treturn _handlers.add(handler);\n\t\t\t}\n\t\t}\n\t\t\n\t\t/**\n\t\t * @return true if removed, false if not found\n\t\t */\n\t\tpublic boolean removeListener(CCNContentHandler handler) {\n\t\t\tif( handler == null) return false;\n\t\t\tsynchronized(_handlers) {\n\t\t\t\treturn _handlers.remove(handler);\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tpublic int size() {\n\t\t\tsynchronized(_handlers) {\n\t\t\t\treturn _handlers.size();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * start issuing interests.  No data is passed to\n\t\t * any listener in the stopped state\n\t\t * @throws IOException \n\t\t */\n\t\tpublic void start() throws IOException {\n\t\t\t_running = true;\n\t\t\t_vim.start();\n\t\t}\n\t\t\n\t\t/**\n\t\t * Cancel all interests for the name\n\t\t */\n\t\tpublic void stop() {\n\t\t\t_running = false;\n\t\t\t_vim.stop();\n\t\t}\n\t\t\n\t\t/**\n\t\t * Pass any received data up to the user.\n\t\t * @param data\n\t\t * @param interest\n\t\t * @return null\n\t\t */\n\t\tpublic Interest handleContent(ContentObject data, Interest interest) {\n\t\t\t// when we're stopped, we do not pass any data\n\t\t\tif( ! _running )\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tsynchronized(_handlers) {\n\t\t\t\tfor(CCNContentHandler handler : _handlers) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\thandler.handleContent(data, interest);\n\t\t\t\t\t} catch(Exception e){\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tpublic CCNStats getStats() {\n\t\t\treturn _vim.getStats();\n\t\t}\n\t\t\n\t\t// =======\n\t\t\n\t\tprivate final Set<CCNContentHandler> _handlers = new HashSet<CCNContentHandler>();\n\t\tprivate final VersioningInterestManager _vim;\n\t\tprivate boolean _running = false;\n\n\t}\n\n}", "class_id": 0, "repo": "buptn/CCNxTomcat", "file": "ccn/org/ccnx/ccn/profiles/versioning/VersioningInterest.java", "last_update_at": "2020-10-13T14:17:19+00:00", "question_id": "f35033385385fcf1569c01f2476ce3de0ccf8307", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class VersioningInterest implements CCNCategorizedStatistics {\n\t\n\t// ==============================================================================\n\t// Public API\n\t/**\n\t * @param handle\n\t * @param listener\n\t */\n\tpublic VersioningInterest(CCNHandle handle) {\n\t\t_handle = handle;\n\t}\n\t\n\t/**\n\t * Express an interest for #name.  We will assume that #name does not\n\t * include a version, and we construct an interest that will only match\n\t * 3 additional components to #name (version/segment/digest).\n\t * \n\t * When the default CCN timeout is exceeded, we stop responding.\n\t * \n\t * If there is already an interest for the same (name, listener), no action is taken.\n\t * \n\t * The return value from #listener is ignored, the listener does not need to re-express\n\t * an interest.  Interests are re-expressed automatically until canceled.\n\t * \n\t * @param name\n\t * @param listener\n\t * @throws IOException \n\t */\n\tpublic void expressInterest(ContentName name, CCNContentHandler handler) throws IOException {\n\t\texpressInterest(name, handler, null, null);\n\t}\n\t/**\n\t * As above, and provide a set of versions to exclude\n\t * The return value from #listener is ignored, the listener does not need to re-express\n\t * an interest.  Interests are re-expressed automatically until canceled.\n\t * \n\t * @param name\n\t * @param handler\n\t * @param retrySeconds\n\t * @param exclusions may be null\n\t * @throws IOException \n\t */\n\tpublic void expressInterest(ContentName name, CCNContentHandler handler, Set<VersionNumber> exclusions) throws IOException {\n\t\texpressInterest(name, handler, exclusions, null);\n\t}\n\t\n\t/**\n\t * As above, and provide a set of versions to exclude and a hard floor startingVersion, any version\n\t * before that will be ignored.\n\t * \n\t * The return value from #listener is ignored, the listener does not need to re-express\n\t * an interest.  Interests are re-expressed automatically until canceled.\n\t * \n\t * @param name\n\t * @param handler\n\t * @param retrySeconds\n\t * @param exclusions may be null\n\t * @param startingVersion the minimum version to include (may be null)\n\t * @throws IOException \n\t */\n\tpublic void expressInterest(ContentName name, CCNContentHandler handler, Set<VersionNumber> exclusions, VersionNumber startingVeersion) throws IOException {\n\t\taddInterest(name, handler, exclusions, startingVeersion);\n\t}\n\t\n\t/**\n\t * Kill off all interests.\n\t */\n\t\n\tpublic void close() {\n\t\tremoveAll();\n\t}\n\t/**\n\t * Cancel a specific interest\n\t * @param name\n\t * @param handler\n\t */\n\tpublic void cancelInterest(ContentName name, CCNContentHandler handler) {\n\t\tremoveInterest(name, handler);\n\t}\n\t/**\n\t * in case we're GC'd without a close().  Don't rely on this.\n\t */\n\tprotected void finalize() throws Throwable {\n\t\ttry {\n\t\t\tremoveAll();\n\t\t} finally {\n\t\t\tsuper.finalize();\n\t\t}\n\t}\n\t\n\t/**\n\t * return the statistics for the interests corresponding to name\n\t * @param name A ContentName or a URI-encoded string\n\t * @return May be null if no interest expressed for name\n\t */\n\tpublic CCNStats getStatsByName(Object name) throws ClassCastException {\n\t\tContentName cn = null;\n\t\tif( name instanceof ContentName )\n\t\t\tcn = (ContentName) name;\n\t\telse if( name instanceof String )\n\t\t\ttry {\n\t\t\t\tcn = ContentName.fromURI((String) name);\n\t\t\t} catch (MalformedContentNameStringException e) {\n\t\t\t}\n\t\n\t\tif( null == cn )\n\t\t\tthrow new ClassCastException(\"Name must be a ContentName or a URI string\");\n\t\t\n\t\tsynchronized(_map) {\n\t\t\tBasenameState data = _map.get(cn);\n\t\t\tif( null != data )\n\t\t\t\treturn data.getStats();\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\tpublic Object[] getCategoryNames() {\n\t\tsynchronized(_map) {\n\t\t\treturn _map.keySet().toArray();\n\t\t}\n\t}\n\t\n\t// ==============================================================================\n\t// Internal implementation\n\tprivate final CCNHandle _handle;\n\tprivate final Map<ContentName, BasenameState> _map = new HashMap<ContentName, BasenameState>();\n\tprivate void addInterest(ContentName name, CCNContentHandler handler, Set<VersionNumber> exclusions, VersionNumber startingVersion) throws IOException {\n\t\tBasenameState data;\n\t\t\n\t\tsynchronized(_map) {\n\t\t\tdata = _map.get(name);\n\t\t\tif( null == data ) {\n\t\t\t\tdata = new BasenameState(_handle, name, exclusions, startingVersion);\n\t\t\t\t_map.put(name, data);\n\t\t\t\tdata.addListener(handler);\n\t\t\t\tdata.start();\n\t\t\t} else {\n\t\t\t\tdata.addListener(handler);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Remove a listener.  If it is the last listener, remove from map and\n\t * kill all interests.\n\t * @param name\n\t * @param listener\n\t */\n\tprivate void removeInterest(ContentName name, CCNContentHandler handler) {\n\t\tBasenameState data;\n\t\t\n\t\tsynchronized(_map) {\n\t\t\tdata = _map.get(name);\n\t\t\tif( null != data ) {\n\t\t\t\tdata.removeListener(handler);\n\t\t\t\tif( data.size() == 0 ) {\n\t\t\t\t\tdata.stop();\n\t\t\t\t\t_map.remove(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void removeAll() {\n\t\tsynchronized(_map) {\n\t\t\tIterator<BasenameState> iter = _map.values().iterator();\n\t\t\twhile( iter.hasNext() ) {\n\t\t\t\tBasenameState bns = iter.next();\n\t\t\t\tbns.stop();\n\t\t\t\titer.remove();\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ======================================================================\n\t// This is the state stored per base name\n\t\n\tprivate static class BasenameState implements CCNContentHandler, CCNStatistics {\n\t\t\n\t\tpublic BasenameState(CCNHandle handle, ContentName basename, Set<VersionNumber> exclusions, VersionNumber startingVersion) {\n\t\t\t_vim = new VersioningInterestManager(handle, basename, exclusions, startingVersion, this);\n\t\t}\n\t\t\n\t\t/**\n\t\t * @param listener\n\t\t * @param retrySeconds IGNORED, not implemented\n\t\t * @return true if added, false if existed or only retrySeconds updated\n\t\t */\n\t\tpublic boolean addListener(CCNContentHandler handler) {\n\t\t\tif( handler == null) return false;\n\t\t\tsynchronized(_handlers) {\n\t\t\t\treturn _handlers.add(handler);\n\t\t\t}\n\t\t}\n\t\t\n\t\t/**\n\t\t * @return true if removed, false if not found\n\t\t */\n\t\tpublic boolean removeListener(CCNContentHandler handler) {\n\t\t\tif( handler == null) return false;\n\t\t\tsynchronized(_handlers) {\n\t\t\t\treturn _handlers.remove(handler);\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tpublic int size() {\n\t\t\tsynchronized(_handlers) {\n\t\t\t\treturn _handlers.size();\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * start issuing interests.  No data is passed to\n\t\t * any listener in the stopped state\n\t\t * @throws IOException \n\t\t */\n\t\tpublic void start() throws IOException {\n\t\t\t_running = true;\n\t\t\t_vim.start();\n\t\t}\n\t\t\n\t\t/**\n\t\t * Cancel all interests for the name\n\t\t */\n\t\tpublic void stop() {\n\t\t\t_running = false;\n\t\t\t_vim.stop();\n\t\t}\n\t\t\n\t\t/**\n\t\t * Pass any received data up to the user.\n\t\t * @param data\n\t\t * @param interest\n\t\t * @return null\n\t\t */\n\t\tpublic Interest handleContent(ContentObject data, Interest interest) {\n\t\t\t// when we're stopped, we do not pass any data\n\t\t\tif( ! _running )\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tsynchronized(_handlers) {\n\t\t\t\tfor(CCNContentHandler handler : _handlers) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\thandler.handleContent(data, interest);\n\t\t\t\t\t} catch(Exception e){\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tpublic CCNStats getStats() {\n\t\t\treturn _vim.getStats();\n\t\t}\n\t\t\n\t\t// =======\n\t\t\n\t\tprivate final Set<CCNContentHandler> _handlers = new HashSet<CCNContentHandler>();\n\t\tprivate final VersioningInterestManager _vim;\n\t\tprivate boolean _running = false;\n\t}\n"]]}
{"hexsha": "13b7843b755ed20bcd5f9cb5b0e3c17b369ace0d", "ext": "java", "lang": "Java", "content": "public class NetworkAnalyser {\n\t\n\tprivate static final Logger logger = LoggerFactory.getLogger(NetworkAnalyser.class);\n\t\n\tprivate static final String DUPLICATE_HOSTNAME_CODE = \"Multiverse.Verify.DuplicateHostname\";\n\tprivate static final String DUPLICATE_MAC_CODE = \"Multiverse.Verify.DuplicateMacAddress\";\n\tprivate static final String DUPLICATE_IP_CODE = \"Multiverse.Verify.DuplicateIpAddress\";\n\tprivate static final String DUPLICATE_VLAN_CODE = \"Multiverse.Verify.DuplicateVlan\";\n\tprivate static final String BAG_BGP_PEER_CODE = \"Multiverse.Verify.MisconfiguredBgpPeer\";\n\t\n\tprivate final Neo4jWrapper neo4j;\n\n\tpublic NetworkAnalyser(Neo4jWrapper neo4j) {\n\t\tthis.neo4j = neo4j;\n\t}\n\t\n\tpublic void verifyNetwork(String networkId, Handler<AsyncResult<VerificationReport>> resultHandler) {\n\t\tPromise<ReportMessage> pDupHost = Promise.promise();\n\t\tPromise<ReportMessage> pDupMac = Promise.promise();\n\t\tPromise<ReportMessage> pDupIp = Promise.promise();\n\t\tPromise<ReportMessage> pDupVlan = Promise.promise();\n\t\tPromise<ReportMessage> pBadBgp = Promise.promise();\n\t\t\n\t\tverifyDupHostname(networkId, pDupHost);\n\t\tverifyDupMacAddress(networkId, pDupMac);\n\t\tverifyDupIpAddress(networkId, pDupIp);\n\t\tverifyDupVlan(networkId, pDupVlan);\n\t\tverifyBadBgp(networkId, pBadBgp);\n\t\t\n\t\tCompositeFuture.all(pDupHost.future(), pDupMac.future(), pDupIp.future(), pDupVlan.future(), pBadBgp.future())\n\t\t\t\t.onComplete(done -> {\n\t\t\tif (done.succeeded()) {\n\t\t\t\tVerificationReport report = new VerificationReport();\n\t\t\t\treport.setTimestamp(OffsetDateTime.now().toLocalDateTime().toString());\n\t\t\t\treport.setNetId(networkId);\n\t\t\t\t\n\t\t\t\tList<ReportMessage> reportMsgs = new ArrayList<ReportMessage>();\n\t\t\t\treportMsgs.add(pDupHost.future().result());\n\t\t\t\treportMsgs.add(pDupMac.future().result());\n\t\t\t\treportMsgs.add(pDupIp.future().result());\n\t\t\t\treportMsgs.add(pDupVlan.future().result());\n\t\t\t\treportMsgs.add(pBadBgp.future().result());\n\t\t\t\t\n\t\t\t\treport.setReports(reportMsgs);\n\t\t\t\tresultHandler.handle(Future.succeededFuture(report));\n\t\t\t} else {\n\t\t\t\tresultHandler.handle(Future.failedFuture(\"Failed to verify network. \" + done.cause().getMessage()));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic void verifyDupHostname(String networkId, Handler<AsyncResult<ReportMessage>> resultHandler) {\n\t\tneo4j.find(networkId, CypherQuery.Verify.DUPLICATE_HOSTNAME, result -> {\n\t\t\tif (result.succeeded()) {\n\t\t\t\tReportMessage report = new ReportMessage();\n\t\t\t\treport.setCode(DUPLICATE_HOSTNAME_CODE);\n\t\t\t\tList<String> messages = new ArrayList<String>();\n\t\t\t\tfor(JsonObject row: result.result()) {\n\t\t\t\t\t// Hostname, count\n\t\t\t\t\tString msg = \"Hostname <\" + row.getString(\"hostname\") + \"> is used on \" \n\t\t\t\t\t\t\t+ row.getInteger(\"count\") + \" devices\"; \n\t\t\t\t\tmessages.add(msg);\n\t\t\t\t}\n\t\t\t\treport.setMessages(messages);\n\t\t\t\tresultHandler.handle(Future.succeededFuture(report));\n\t\t\t} else {\n\t\t\t\tresultHandler.handle(Future.failedFuture(result.cause()));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic void verifyDupMacAddress(String networkId, Handler<AsyncResult<ReportMessage>> resultHandler) {\n\t\tneo4j.find(networkId, CypherQuery.Verify.DUPLICATE_MAC, result -> {\n\t\t\tif (result.succeeded()) {\n\t\t\t\tReportMessage report = new ReportMessage();\n\t\t\t\treport.setCode(DUPLICATE_MAC_CODE);\n\t\t\t\tList<String> messages = new ArrayList<String>();\n\t\t\t\tfor(JsonObject row: result.result()) {\n\t\t\t\t\t// deviceName, itfName, dupMacAddr\n\t\t\t\t\tString msg = \"Duplicate MACADDR <\" + row.getString(\"dupMacAddr\") + \"> on device \"\n\t\t\t\t\t\t\t+ \"<\" + row.getString(\"deviceName\") + \"> \" \n\t\t\t\t\t\t\t+ \"interface <\" + row.getString(\"itfName\") + \">\"; \n\t\t\t\t\tmessages.add(msg);\n\t\t\t\t}\n\t\t\t\treport.setMessages(messages);\n\t\t\t\tresultHandler.handle(Future.succeededFuture(report));\n\t\t\t} else {\n\t\t\t\tresultHandler.handle(Future.failedFuture(result.cause()));\n\t\t\t}\n\t\t});\n\t}\n\t\n\tpublic void verifyDupIpAddress(String networkId, Handler<AsyncResult<ReportMessage>> resultHandler) {\n\t\tneo4j.find(networkId, CypherQuery.Verify.DUPLICATE_IP, result -> {\n\t\t\tif (result.succeeded()) {\n\t\t\t\tReportMessage report = new ReportMessage();\n\t\t\t\treport.setCode(DUPLICATE_IP_CODE);\n\t\t\t\tList<String> messages = new ArrayList<String>();\n\t\t\t\tfor(JsonObject row: result.result()) {\n\t\t\t\t\t// deviceName, itfName, dupIpAddr\n\t\t\t\t\tString msg = \"Duplicate IPADDR <\" + row.getString(\"dupIpAddr\") + \"> on device \"\n\t\t\t\t\t\t\t+ \"<\" + row.getString(\"deviceName\") + \"> \" \n\t\t\t\t\t\t\t+ \"interface <\" + row.getString(\"itfName\") + \">\"; \n\t\t\t\t\tmessages.add(msg);\n\t\t\t\t}\n\t\t\t\treport.setMessages(messages);\n\t\t\t\tresultHandler.handle(Future.succeededFuture(report));\n\t\t\t} else {\n\t\t\t\tresultHandler.handle(Future.failedFuture(result.cause()));\n\t\t\t}\n\t\t});\n\t}\n\t\n\tpublic void verifyDupVlan(String networkId, Handler<AsyncResult<ReportMessage>> resultHandler) {\n\t\tneo4j.find(networkId, CypherQuery.Verify.DUPLICATE_VLAN, result -> {\n\t\t\tif (result.succeeded()) {\n\t\t\t\tReportMessage report = new ReportMessage();\n\t\t\t\treport.setCode(DUPLICATE_VLAN_CODE);\n\t\t\t\tList<String> messages = new ArrayList<String>();\n\t\t\t\tfor(JsonObject row: result.result()) {\n\t\t\t\t\t// deviceName1, itfName1, netAddr1,\n\t\t\t\t\t// deviceName2, itfName2, netAddr2, vlan\n\t\t\t\t\tString msg = \"VLAN <\" + row.getString(\"vlan\") + \"> is associated with \"\n\t\t\t\t\t\t\t+ \"subnet <\" + row.getString(\"netAddr1\") + \"> on device <\" + row.getString(\"deviceName1\") + \"> \"\n\t\t\t\t\t\t\t+ \"interface <\" + row.getString(\"itfName1\") + \"> \"\n\t\t\t\t\t\t\t+ \"and \"\n\t\t\t\t\t\t\t+ \"subnet <\" + row.getString(\"netAddr2\") + \"> on device <\" + row.getString(\"deviceName2\") + \"> \"\n\t\t\t\t\t\t\t+ \"interface <\" + row.getString(\"itfName2\") + \"> \";\n\t\t\t\t\tmessages.add(msg);\n\t\t\t\t}\n\t\t\t\treport.setMessages(messages);\n\t\t\t\tresultHandler.handle(Future.succeededFuture(report));\n\t\t\t} else {\n\t\t\t\tresultHandler.handle(Future.failedFuture(result.cause()));\n\t\t\t}\n\t\t});\n\t}\n\t\n\tpublic void verifyBadBgp(String networkId, Handler<AsyncResult<ReportMessage>> resultHandler) {\n\t\tneo4j.find(networkId, CypherQuery.Verify.BAD_BGP_PEER, result -> {\n\t\t\tif (result.succeeded()) {\n\t\t\t\tReportMessage report = new ReportMessage();\n\t\t\t\treport.setCode(BAG_BGP_PEER_CODE);\n\t\t\t\tList<String> messages = new ArrayList<String>();\n\t\t\t\tfor(JsonObject row: result.result()) {\n\t\t\t\t\t// deviceName1, ipAddr1, lAsn1, rAsn1, rAddr1,\n\t\t\t\t\t// deviceName2, ipAddr2, lAsn2, rAsn2, rAddr2\n\t\t\t\t\tString msg = \"BGP peer between \"\n\t\t\t\t\t\t\t+ \"device <\" + row.getString(\"deviceName1\") + \"> on <\" + row.getString(\"ipAddr1\") + \"> \"\n\t\t\t\t\t\t\t+ String.format(\"(LocalAsn=%s, RemoteAsn=%s, remoteAddr=%s)\",\n\t\t\t\t\t\t\t\t\trow.getString(\"lAsn1\"), row.getString(\"rAsn1\") , row.getString(\"rAddr1\"))\n\t\t\t\t\t\t\t+ \" and \"\n\t\t\t\t\t\t\t+ \"device <\" + row.getString(\"deviceName2\") + \"> on <\" + row.getString(\"ipAddr2\") + \"> \"\n\t\t\t\t\t\t\t+ String.format(\"(LocalAsn=%s, RemoteAsn=%s, remoteAddr=%s)\",\n\t\t\t\t\t\t\t\t\trow.getString(\"lAsn2\"), row.getString(\"rAsn2\") , row.getString(\"rAddr2\"))\n\t\t\t\t\t\t\t+ \" does not match\";\n\t\t\t\t\tmessages.add(msg);\n\t\t\t\t}\n\t\t\t\treport.setMessages(messages);\n\t\t\t\tresultHandler.handle(Future.succeededFuture(report));\n\t\t\t} else {\n\t\t\t\tresultHandler.handle(Future.failedFuture(result.cause()));\n\t\t\t}\n\t\t});\n\t}\n}", "class_id": 0, "repo": "MheniMerz/multiverse-controller", "file": "digitaltwin-microservice/src/main/java/io/nms/central/microservice/digitaltwin/impl/NetworkAnalyser.java", "last_update_at": "2020-09-14T16:05:39+00:00", "question_id": "13b7843b755ed20bcd5f9cb5b0e3c17b369ace0d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NetworkAnalyser {\n\t\n\tprivate static final Logger logger = LoggerFactory.getLogger(NetworkAnalyser.class);\n\t\n\tprivate static final String DUPLICATE_HOSTNAME_CODE = \"Multiverse.Verify.DuplicateHostname\";\n\tprivate static final String DUPLICATE_MAC_CODE = \"Multiverse.Verify.DuplicateMacAddress\";\n\tprivate static final String DUPLICATE_IP_CODE = \"Multiverse.Verify.DuplicateIpAddress\";\n\tprivate static final String DUPLICATE_VLAN_CODE = \"Multiverse.Verify.DuplicateVlan\";\n\tprivate static final String BAG_BGP_PEER_CODE = \"Multiverse.Verify.MisconfiguredBgpPeer\";\n\t\n\tprivate final Neo4jWrapper neo4j;\n\tpublic NetworkAnalyser(Neo4jWrapper neo4j) {\n\t\tthis.neo4j = neo4j;\n\t}\n\t\n\tpublic void verifyNetwork(String networkId, Handler<AsyncResult<VerificationReport>> resultHandler) {\n\t\tPromise<ReportMessage> pDupHost = Promise.promise();\n\t\tPromise<ReportMessage> pDupMac = Promise.promise();\n\t\tPromise<ReportMessage> pDupIp = Promise.promise();\n\t\tPromise<ReportMessage> pDupVlan = Promise.promise();\n\t\tPromise<ReportMessage> pBadBgp = Promise.promise();\n\t\t\n\t\tverifyDupHostname(networkId, pDupHost);\n\t\tverifyDupMacAddress(networkId, pDupMac);\n\t\tverifyDupIpAddress(networkId, pDupIp);\n\t\tverifyDupVlan(networkId, pDupVlan);\n\t\tverifyBadBgp(networkId, pBadBgp);\n\t\t\n\t\tCompositeFuture.all(pDupHost.future(), pDupMac.future(), pDupIp.future(), pDupVlan.future(), pBadBgp.future())\n\t\t\t\t.onComplete(done -> {\n\t\t\tif (done.succeeded()) {\n\t\t\t\tVerificationReport report = new VerificationReport();\n\t\t\t\treport.setTimestamp(OffsetDateTime.now().toLocalDateTime().toString());\n\t\t\t\treport.setNetId(networkId);\n\t\t\t\t\n\t\t\t\tList<ReportMessage> reportMsgs = new ArrayList<ReportMessage>();\n\t\t\t\treportMsgs.add(pDupHost.future().result());\n\t\t\t\treportMsgs.add(pDupMac.future().result());\n\t\t\t\treportMsgs.add(pDupIp.future().result());\n\t\t\t\treportMsgs.add(pDupVlan.future().result());\n\t\t\t\treportMsgs.add(pBadBgp.future().result());\n\t\t\t\t\n\t\t\t\treport.setReports(reportMsgs);\n\t\t\t\tresultHandler.handle(Future.succeededFuture(report));\n\t\t\t} else {\n\t\t\t\tresultHandler.handle(Future.failedFuture(\"Failed to verify network. \" + done.cause().getMessage()));\n\t\t\t}\n\t\t});\n\t}\n\tpublic void verifyDupHostname(String networkId, Handler<AsyncResult<ReportMessage>> resultHandler) {\n\t\tneo4j.find(networkId, CypherQuery.Verify.DUPLICATE_HOSTNAME, result -> {\n\t\t\tif (result.succeeded()) {\n\t\t\t\tReportMessage report = new ReportMessage();\n\t\t\t\treport.setCode(DUPLICATE_HOSTNAME_CODE);\n\t\t\t\tList<String> messages = new ArrayList<String>();\n\t\t\t\tfor(JsonObject row: result.result()) {\n\t\t\t\t\t// Hostname, count\n\t\t\t\t\tString msg = \"Hostname <\" + row.getString(\"hostname\") + \"> is used on \" \n\t\t\t\t\t\t\t+ row.getInteger(\"count\") + \" devices\"; \n\t\t\t\t\tmessages.add(msg);\n\t\t\t\t}\n\t\t\t\treport.setMessages(messages);\n\t\t\t\tresultHandler.handle(Future.succeededFuture(report));\n\t\t\t} else {\n\t\t\t\tresultHandler.handle(Future.failedFuture(result.cause()));\n\t\t\t}\n\t\t});\n\t}\n\tpublic void verifyDupMacAddress(String networkId, Handler<AsyncResult<ReportMessage>> resultHandler) {\n\t\tneo4j.find(networkId, CypherQuery.Verify.DUPLICATE_MAC, result -> {\n\t\t\tif (result.succeeded()) {\n\t\t\t\tReportMessage report = new ReportMessage();\n\t\t\t\treport.setCode(DUPLICATE_MAC_CODE);\n\t\t\t\tList<String> messages = new ArrayList<String>();\n\t\t\t\tfor(JsonObject row: result.result()) {\n\t\t\t\t\t// deviceName, itfName, dupMacAddr\n\t\t\t\t\tString msg = \"Duplicate MACADDR <\" + row.getString(\"dupMacAddr\") + \"> on device \"\n\t\t\t\t\t\t\t+ \"<\" + row.getString(\"deviceName\") + \"> \" \n\t\t\t\t\t\t\t+ \"interface <\" + row.getString(\"itfName\") + \">\"; \n\t\t\t\t\tmessages.add(msg);\n\t\t\t\t}\n\t\t\t\treport.setMessages(messages);\n\t\t\t\tresultHandler.handle(Future.succeededFuture(report));\n\t\t\t} else {\n\t\t\t\tresultHandler.handle(Future.failedFuture(result.cause()));\n\t\t\t}\n\t\t});\n\t}\n\t\n\tpublic void verifyDupIpAddress(String networkId, Handler<AsyncResult<ReportMessage>> resultHandler) {\n\t\tneo4j.find(networkId, CypherQuery.Verify.DUPLICATE_IP, result -> {\n\t\t\tif (result.succeeded()) {\n\t\t\t\tReportMessage report = new ReportMessage();\n\t\t\t\treport.setCode(DUPLICATE_IP_CODE);\n\t\t\t\tList<String> messages = new ArrayList<String>();\n\t\t\t\tfor(JsonObject row: result.result()) {\n\t\t\t\t\t// deviceName, itfName, dupIpAddr\n\t\t\t\t\tString msg = \"Duplicate IPADDR <\" + row.getString(\"dupIpAddr\") + \"> on device \"\n\t\t\t\t\t\t\t+ \"<\" + row.getString(\"deviceName\") + \"> \" \n\t\t\t\t\t\t\t+ \"interface <\" + row.getString(\"itfName\") + \">\"; \n\t\t\t\t\tmessages.add(msg);\n\t\t\t\t}\n\t\t\t\treport.setMessages(messages);\n\t\t\t\tresultHandler.handle(Future.succeededFuture(report));\n\t\t\t} else {\n\t\t\t\tresultHandler.handle(Future.failedFuture(result.cause()));\n\t\t\t}\n\t\t});\n\t}\n\t\n\tpublic void verifyDupVlan(String networkId, Handler<AsyncResult<ReportMessage>> resultHandler) {\n\t\tneo4j.find(networkId, CypherQuery.Verify.DUPLICATE_VLAN, result -> {\n\t\t\tif (result.succeeded()) {\n\t\t\t\tReportMessage report = new ReportMessage();\n\t\t\t\treport.setCode(DUPLICATE_VLAN_CODE);\n\t\t\t\tList<String> messages = new ArrayList<String>();\n\t\t\t\tfor(JsonObject row: result.result()) {\n\t\t\t\t\t// deviceName1, itfName1, netAddr1,\n\t\t\t\t\t// deviceName2, itfName2, netAddr2, vlan\n\t\t\t\t\tString msg = \"VLAN <\" + row.getString(\"vlan\") + \"> is associated with \"\n\t\t\t\t\t\t\t+ \"subnet <\" + row.getString(\"netAddr1\") + \"> on device <\" + row.getString(\"deviceName1\") + \"> \"\n\t\t\t\t\t\t\t+ \"interface <\" + row.getString(\"itfName1\") + \"> \"\n\t\t\t\t\t\t\t+ \"and \"\n\t\t\t\t\t\t\t+ \"subnet <\" + row.getString(\"netAddr2\") + \"> on device <\" + row.getString(\"deviceName2\") + \"> \"\n\t\t\t\t\t\t\t+ \"interface <\" + row.getString(\"itfName2\") + \"> \";\n\t\t\t\t\tmessages.add(msg);\n\t\t\t\t}\n\t\t\t\treport.setMessages(messages);\n\t\t\t\tresultHandler.handle(Future.succeededFuture(report));\n\t\t\t} else {\n\t\t\t\tresultHandler.handle(Future.failedFuture(result.cause()));\n\t\t\t}\n\t\t});\n\t}\n\t\n\tpublic void verifyBadBgp(String networkId, Handler<AsyncResult<ReportMessage>> resultHandler) {\n\t\tneo4j.find(networkId, CypherQuery.Verify.BAD_BGP_PEER, result -> {\n\t\t\tif (result.succeeded()) {\n\t\t\t\tReportMessage report = new ReportMessage();\n\t\t\t\treport.setCode(BAG_BGP_PEER_CODE);\n\t\t\t\tList<String> messages = new ArrayList<String>();\n\t\t\t\tfor(JsonObject row: result.result()) {\n\t\t\t\t\t// deviceName1, ipAddr1, lAsn1, rAsn1, rAddr1,\n\t\t\t\t\t// deviceName2, ipAddr2, lAsn2, rAsn2, rAddr2\n\t\t\t\t\tString msg = \"BGP peer between \"\n\t\t\t\t\t\t\t+ \"device <\" + row.getString(\"deviceName1\") + \"> on <\" + row.getString(\"ipAddr1\") + \"> \"\n\t\t\t\t\t\t\t+ String.format(\"(LocalAsn=%s, RemoteAsn=%s, remoteAddr=%s)\",\n\t\t\t\t\t\t\t\t\trow.getString(\"lAsn1\"), row.getString(\"rAsn1\") , row.getString(\"rAddr1\"))\n\t\t\t\t\t\t\t+ \" and \"\n\t\t\t\t\t\t\t+ \"device <\" + row.getString(\"deviceName2\") + \"> on <\" + row.getString(\"ipAddr2\") + \"> \"\n\t\t\t\t\t\t\t+ String.format(\"(LocalAsn=%s, RemoteAsn=%s, remoteAddr=%s)\",\n\t\t\t\t\t\t\t\t\trow.getString(\"lAsn2\"), row.getString(\"rAsn2\") , row.getString(\"rAddr2\"))\n\t\t\t\t\t\t\t+ \" does not match\";\n\t\t\t\t\tmessages.add(msg);\n\t\t\t\t}\n\t\t\t\treport.setMessages(messages);\n\t\t\t\tresultHandler.handle(Future.succeededFuture(report));\n\t\t\t} else {\n\t\t\t\tresultHandler.handle(Future.failedFuture(result.cause()));\n\t\t\t}\n\t\t});\n\t}\n"]]}
{"hexsha": "7dbf614e5287401f356ffad615bbbfb2b01433c6", "ext": "java", "lang": "Java", "content": "public class Particle {\n\n\tprotected Bitmap mImage;\n\t\n\t@Px\n\tpublic float mCurrentX;\n\t@Px\n\tpublic float mCurrentY;\n\t\n\tpublic float mScale = 1f;\n\tpublic int mAlpha = 255;\n\t\n\tpublic float mInitialRotation = 0f;\n\t\n\tpublic float mRotationSpeed = 0f;\n\t\n\tpublic float mSpeedX = 0f;\n\tpublic float mSpeedY = 0f;\n\n\tpublic float mAccelerationX;\n\tpublic float mAccelerationY;\n\n\tprivate Matrix mMatrix;\n\tprivate Paint mPaint;\n\n\t@Px\n\tprivate float mInitialX;\n\t@Px\n\tprivate float mInitialY;\n\n\tprivate float mRotation;\n\n\tprivate long mTimeToLive;\n\n\tprotected long mStartingMillisecond;\n\n\t@Px\n\tprivate int mBitmapHalfWidth;\n\t@Px\n\tprivate int mBitmapHalfHeight;\n\n\tprivate List<ParticleModifier> mModifiers;\n\n\n\tprotected Particle() {\t\t\n\t\tmMatrix = new Matrix();\n\t\tmPaint = new Paint();\n\t}\n\t\n\tpublic Particle(Bitmap bitmap) {\n\t\tthis();\n\t\tmImage = bitmap;\n\t}\n\n\tpublic void init() {\n\t\tmScale = 1;\n\t\tmAlpha = 255;\t\n\t}\n\t\n\tpublic void configure(long timeToLive, @Px float emitterX, @Px float emitterY) {\n\t\tmBitmapHalfWidth = mImage.getWidth()/2;\n\t\tmBitmapHalfHeight = mImage.getHeight()/2;\n\t\t\n\t\tmInitialX = emitterX - mBitmapHalfWidth;\n\t\tmInitialY = emitterY - mBitmapHalfHeight;\n\t\tmCurrentX = mInitialX;\n\t\tmCurrentY = mInitialY;\n\t\t\n\t\tmTimeToLive = timeToLive;\n\t}\n\n\tpublic boolean update(long milliseconds) {\n\t\tlong realMilliseconds = milliseconds - mStartingMillisecond;\n\t\tif (realMilliseconds > mTimeToLive) {\n\t\t\treturn false;\n\t\t}\n\t\tmCurrentX = mInitialX+mSpeedX*realMilliseconds+mAccelerationX*realMilliseconds*realMilliseconds;\n\t\tmCurrentY = mInitialY+mSpeedY*realMilliseconds+mAccelerationY*realMilliseconds*realMilliseconds;\n\t\tmRotation = mInitialRotation + mRotationSpeed*realMilliseconds/1000;\n\t\tfor (int i=0; i<mModifiers.size(); i++) {\n\t\t\tmModifiers.get(i).apply(this, realMilliseconds);\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic void draw(@NonNull Canvas c) {\n\t\tmMatrix.reset();\n\t\tmMatrix.postRotate(mRotation, mBitmapHalfWidth, mBitmapHalfHeight);\n\t\tmMatrix.postScale(mScale, mScale, mBitmapHalfWidth, mBitmapHalfHeight);\n\t\tmMatrix.postTranslate(mCurrentX, mCurrentY);\n\t\tmPaint.setAlpha(mAlpha);\t\t\n\t\tc.drawBitmap(mImage, mMatrix, mPaint);\n\t}\n\n\tpublic Particle activate(long startingMillisecond, @NonNull List<ParticleModifier> modifiers) {\n\t\tmStartingMillisecond = startingMillisecond;\n\t\t// We do store a reference to the list, there is no need to copy, since the modifiers do not care about states\n\t\tmModifiers = modifiers;\n\t\treturn this;\n\t}\n}", "class_id": 0, "repo": "ninjitaru/androidx-particles", "file": "lib/src/main/java/androidx/particles/Particle.java", "last_update_at": "2020-06-24T22:05:04+00:00", "question_id": "7dbf614e5287401f356ffad615bbbfb2b01433c6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Particle {\n\tprotected Bitmap mImage;\n\t\n\t@Px\n\tpublic float mCurrentX;\n\t@Px\n\tpublic float mCurrentY;\n\t\n\tpublic float mScale = 1f;\n\tpublic int mAlpha = 255;\n\t\n\tpublic float mInitialRotation = 0f;\n\t\n\tpublic float mRotationSpeed = 0f;\n\t\n\tpublic float mSpeedX = 0f;\n\tpublic float mSpeedY = 0f;\n\tpublic float mAccelerationX;\n\tpublic float mAccelerationY;\n\tprivate Matrix mMatrix;\n\tprivate Paint mPaint;\n\t@Px\n\tprivate float mInitialX;\n\t@Px\n\tprivate float mInitialY;\n\tprivate float mRotation;\n\tprivate long mTimeToLive;\n\tprotected long mStartingMillisecond;\n\t@Px\n\tprivate int mBitmapHalfWidth;\n\t@Px\n\tprivate int mBitmapHalfHeight;\n\tprivate List<ParticleModifier> mModifiers;\n\tprotected Particle() {\t\t\n\t\tmMatrix = new Matrix();\n\t\tmPaint = new Paint();\n\t}\n\t\n\tpublic Particle(Bitmap bitmap) {\n\t\tthis();\n\t\tmImage = bitmap;\n\t}\n\tpublic void init() {\n\t\tmScale = 1;\n\t\tmAlpha = 255;\t\n\t}\n\t\n\tpublic void configure(long timeToLive, @Px float emitterX, @Px float emitterY) {\n\t\tmBitmapHalfWidth = mImage.getWidth()/2;\n\t\tmBitmapHalfHeight = mImage.getHeight()/2;\n\t\t\n\t\tmInitialX = emitterX - mBitmapHalfWidth;\n\t\tmInitialY = emitterY - mBitmapHalfHeight;\n\t\tmCurrentX = mInitialX;\n\t\tmCurrentY = mInitialY;\n\t\t\n\t\tmTimeToLive = timeToLive;\n\t}\n\tpublic boolean update(long milliseconds) {\n\t\tlong realMilliseconds = milliseconds - mStartingMillisecond;\n\t\tif (realMilliseconds > mTimeToLive) {\n\t\t\treturn false;\n\t\t}\n\t\tmCurrentX = mInitialX+mSpeedX*realMilliseconds+mAccelerationX*realMilliseconds*realMilliseconds;\n\t\tmCurrentY = mInitialY+mSpeedY*realMilliseconds+mAccelerationY*realMilliseconds*realMilliseconds;\n\t\tmRotation = mInitialRotation + mRotationSpeed*realMilliseconds/1000;\n\t\tfor (int i=0; i<mModifiers.size(); i++) {\n\t\t\tmModifiers.get(i).apply(this, realMilliseconds);\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic void draw(@NonNull Canvas c) {\n\t\tmMatrix.reset();\n\t\tmMatrix.postRotate(mRotation, mBitmapHalfWidth, mBitmapHalfHeight);\n\t\tmMatrix.postScale(mScale, mScale, mBitmapHalfWidth, mBitmapHalfHeight);\n\t\tmMatrix.postTranslate(mCurrentX, mCurrentY);\n\t\tmPaint.setAlpha(mAlpha);\t\t\n\t\tc.drawBitmap(mImage, mMatrix, mPaint);\n\t}\n\tpublic Particle activate(long startingMillisecond, @NonNull List<ParticleModifier> modifiers) {\n\t\tmStartingMillisecond = startingMillisecond;\n\t\t// We do store a reference to the list, there is no need to copy, since the modifiers do not care about states\n\t\tmModifiers = modifiers;\n\t\treturn this;\n\t}\n"]]}
{"hexsha": "1f894ea3b3200ee91e1e6d51f7b5960f95264c32", "ext": "java", "lang": "Java", "content": "public class VmtUser2LdapUserAdapterTest {\r\n\t@Test\r\n\tpublic void tetl2v(){\r\n\t\tLdapUser user=new LdapUser();\r\n\t\tuser.setCstnetId(\"test@teset.com\");\r\n\t\tuser.setCurrentDisplay(\"display\");\r\n\t\tuser.setDn(\"dn\");\r\n\t\tuser.setName(\"name\");\r\n\t\tuser.setStatus(\"refuse\");\r\n\t\tuser.setUmtId(\"123\");\r\n\t\tVmtUser vmtUser=VmtUser2LdapUserAdapter.convert(user);\r\n\t\tAssert.assertEquals(user.getCstnetId(), vmtUser.getCstnetId());\r\n\t\tAssert.assertEquals(user.getCurrentDisplay(), vmtUser.getCurrentDisplay());\r\n\t\tAssert.assertEquals(user.getDn(), vmtUser.getDn());\r\n\t\tAssert.assertEquals(user.getName(), vmtUser.getName());\r\n\t\tAssert.assertEquals(user.getStatus(), vmtUser.getStatus());\r\n\t\tAssert.assertEquals(user.getUmtId(), vmtUser.getUmtId());\r\n\t}\r\n\t@Test\r\n\tpublic void testbatch(){\r\n\t\tList<LdapUser> users=null;\r\n\t\tAssert.assertTrue(CommonUtils.isNull(users));\r\n\t\tusers=new ArrayList<>();\r\n\t\tAssert.assertTrue(CommonUtils.isNull(users));\r\n\t\tLdapUser user1=new LdapUser();\r\n\t\tuser1.setCstnetId(\"test@teset.com\");\r\n\t\tuser1.setCurrentDisplay(\"display\");\r\n\t\tuser1.setDn(\"dn\");\r\n\t\tuser1.setName(\"name\");\r\n\t\tuser1.setStatus(\"refuse\");\r\n\t\tuser1.setUmtId(\"123\");\r\n\t\t\r\n\t\tLdapUser user2=new LdapUser();\r\n\t\tuser2.setCstnetId(\"test@teset.com\");\r\n\t\tuser2.setCurrentDisplay(\"display\");\r\n\t\tuser2.setDn(\"dn\");\r\n\t\tuser2.setName(\"name\");\r\n\t\tuser2.setStatus(\"refuse\");\r\n\t\tuser2.setUmtId(\"123\");\r\n\t\tusers.add(user1);\r\n\t\tusers.add(user2);\r\n\t\tList<VmtUser> vmtUsers=VmtUser2LdapUserAdapter.convert(users);\r\n\t\tAssert.assertEquals(2, vmtUsers.size());\r\n\t\tVmtUser vmtUser1=vmtUsers.get(0);\r\n\t\tVmtUser vmtUser2=vmtUsers.get(1);\r\n\t\tAssert.assertEquals(user1.getCstnetId(), vmtUser1.getCstnetId());\r\n\t\tAssert.assertEquals(user1.getCurrentDisplay(), vmtUser1.getCurrentDisplay());\r\n\t\tAssert.assertEquals(user1.getDn(), vmtUser1.getDn());\r\n\t\tAssert.assertEquals(user1.getName(), vmtUser1.getName());\r\n\t\tAssert.assertEquals(user1.getStatus(), vmtUser1.getStatus());\r\n\t\tAssert.assertEquals(user1.getUmtId(), vmtUser1.getUmtId());\r\n\t\t\r\n\t\tAssert.assertEquals(user2.getCstnetId(), vmtUser2.getCstnetId());\r\n\t\tAssert.assertEquals(user2.getCurrentDisplay(), vmtUser2.getCurrentDisplay());\r\n\t\tAssert.assertEquals(user2.getDn(), vmtUser2.getDn());\r\n\t\tAssert.assertEquals(user2.getName(), vmtUser2.getName());\r\n\t\tAssert.assertEquals(user2.getStatus(), vmtUser2.getStatus());\r\n\t\tAssert.assertEquals(user2.getUmtId(), vmtUser2.getUmtId());\r\n\t\t\r\n\t\t\r\n\t}\r\n\r\n}", "class_id": 0, "repo": "ducklingcloud/vmt", "file": "test/src/test/java/net/duckling/vmt/common/adapter/VmtUser2LdapUserAdapterTest.java", "last_update_at": "2020-06-08T03:48:55+00:00", "question_id": "1f894ea3b3200ee91e1e6d51f7b5960f95264c32", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class VmtUser2LdapUserAdapterTest {\r\n\t@Test\r\n\tpublic void tetl2v(){\r\n\t\tLdapUser user=new LdapUser();\r\n\t\tuser.setCstnetId(\"test@teset.com\");\r\n\t\tuser.setCurrentDisplay(\"display\");\r\n\t\tuser.setDn(\"dn\");\r\n\t\tuser.setName(\"name\");\r\n\t\tuser.setStatus(\"refuse\");\r\n\t\tuser.setUmtId(\"123\");\r\n\t\tVmtUser vmtUser=VmtUser2LdapUserAdapter.convert(user);\r\n\t\tAssert.assertEquals(user.getCstnetId(), vmtUser.getCstnetId());\r\n\t\tAssert.assertEquals(user.getCurrentDisplay(), vmtUser.getCurrentDisplay());\r\n\t\tAssert.assertEquals(user.getDn(), vmtUser.getDn());\r\n\t\tAssert.assertEquals(user.getName(), vmtUser.getName());\r\n\t\tAssert.assertEquals(user.getStatus(), vmtUser.getStatus());\r\n\t\tAssert.assertEquals(user.getUmtId(), vmtUser.getUmtId());\r\n\t}\r\n\t@Test\r\n\tpublic void testbatch(){\r\n\t\tList<LdapUser> users=null;\r\n\t\tAssert.assertTrue(CommonUtils.isNull(users));\r\n\t\tusers=new ArrayList<>();\r\n\t\tAssert.assertTrue(CommonUtils.isNull(users));\r\n\t\tLdapUser user1=new LdapUser();\r\n\t\tuser1.setCstnetId(\"test@teset.com\");\r\n\t\tuser1.setCurrentDisplay(\"display\");\r\n\t\tuser1.setDn(\"dn\");\r\n\t\tuser1.setName(\"name\");\r\n\t\tuser1.setStatus(\"refuse\");\r\n\t\tuser1.setUmtId(\"123\");\r\n\t\t\r\n\t\tLdapUser user2=new LdapUser();\r\n\t\tuser2.setCstnetId(\"test@teset.com\");\r\n\t\tuser2.setCurrentDisplay(\"display\");\r\n\t\tuser2.setDn(\"dn\");\r\n\t\tuser2.setName(\"name\");\r\n\t\tuser2.setStatus(\"refuse\");\r\n\t\tuser2.setUmtId(\"123\");\r\n\t\tusers.add(user1);\r\n\t\tusers.add(user2);\r\n\t\tList<VmtUser> vmtUsers=VmtUser2LdapUserAdapter.convert(users);\r\n\t\tAssert.assertEquals(2, vmtUsers.size());\r\n\t\tVmtUser vmtUser1=vmtUsers.get(0);\r\n\t\tVmtUser vmtUser2=vmtUsers.get(1);\r\n\t\tAssert.assertEquals(user1.getCstnetId(), vmtUser1.getCstnetId());\r\n\t\tAssert.assertEquals(user1.getCurrentDisplay(), vmtUser1.getCurrentDisplay());\r\n\t\tAssert.assertEquals(user1.getDn(), vmtUser1.getDn());\r\n\t\tAssert.assertEquals(user1.getName(), vmtUser1.getName());\r\n\t\tAssert.assertEquals(user1.getStatus(), vmtUser1.getStatus());\r\n\t\tAssert.assertEquals(user1.getUmtId(), vmtUser1.getUmtId());\r\n\t\t\r\n\t\tAssert.assertEquals(user2.getCstnetId(), vmtUser2.getCstnetId());\r\n\t\tAssert.assertEquals(user2.getCurrentDisplay(), vmtUser2.getCurrentDisplay());\r\n\t\tAssert.assertEquals(user2.getDn(), vmtUser2.getDn());\r\n\t\tAssert.assertEquals(user2.getName(), vmtUser2.getName());\r\n\t\tAssert.assertEquals(user2.getStatus(), vmtUser2.getStatus());\r\n\t\tAssert.assertEquals(user2.getUmtId(), vmtUser2.getUmtId());\r\n\t\t\r\n\t\t\r\n\t}\r\n\r\n"]]}
{"hexsha": "fbb847b445407c3fe5c71244e7d927866222f275", "ext": "java", "lang": "Java", "content": "public class Wrapperz {\n\t/*\n\t * Character - char\n\t * Boolean - boolean\n\t * Byte - byte\n\t * Short - short\n\t * Integer - int\n\t * Long - long\n\t * Float - float\n\t * Double - double\n\t \n\t * Auto-Boxing\n\t * Boxing - implicit conversion from primitive to wrapper\n\t * Unboxing - implicit conversion from wrapper to primitive\n\t */\n\tstatic int myInt = 3;\n\tstatic Integer myInteger = 5;\n\tstatic Double myDouble = 45.93;\n\t\n\tpublic static int addEmUp(int a, int b) {\n\t\treturn a+b;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint result = addEmUp(myInt, myInteger);\n\t\tSystem.out.println(result);\n\t\tInteger i = 0;\n\t\ti = i.MAX_VALUE;\n\t\tSystem.out.println(i);\n\t}\n\n}", "class_id": 0, "repo": "2010USFJava/BardoiN", "file": "ProjectMayhem/src/com/revature/wrapperz/Wrapperz.java", "last_update_at": "2020-10-20T16:19:05+00:00", "question_id": "fbb847b445407c3fe5c71244e7d927866222f275", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Wrapperz {\n\t/*\n\t * Character - char\n\t * Boolean - boolean\n\t * Byte - byte\n\t * Short - short\n\t * Integer - int\n\t * Long - long\n\t * Float - float\n\t * Double - double\n\t \n\t * Auto-Boxing\n\t * Boxing - implicit conversion from primitive to wrapper\n\t * Unboxing - implicit conversion from wrapper to primitive\n\t */\n\tstatic int myInt = 3;\n\tstatic Integer myInteger = 5;\n\tstatic Double myDouble = 45.93;\n\t\n\tpublic static int addEmUp(int a, int b) {\n\t\treturn a+b;\n\t}\n\tpublic static void main(String[] args) {\n\t\tint result = addEmUp(myInt, myInteger);\n\t\tSystem.out.println(result);\n\t\tInteger i = 0;\n\t\ti = i.MAX_VALUE;\n\t\tSystem.out.println(i);\n\t}\n"]]}
{"hexsha": "7e2cd5bf76a4cc1a86cef3d144d27bf3dddf8a08", "ext": "java", "lang": "Java", "content": "public class TileEntityRopeLadderRenderer extends TileEntitySpecialRenderer {\n\n\t@Override\n\tpublic void renderTileEntityAt(TileEntity tileentity, double x, double y, double z, float f) {\n\n\t\tTileEntityRopeLadder rope = (TileEntityRopeLadder)tileentity;\n\t\tGL11.glPushMatrix();\n\t\tbindTexture(TextureMap.locationBlocksTexture);\n\t\tlong ticks = OpenMods.proxy.getTicks(rope.worldObj);\n\t\tdouble offset = 0.0;\n\t\tif (rope.shouldAnimate()) {\n\t\t\toffset = (MathHelper.sin((float)(rope.yCoord + ((double)ticks / 5))) / 50);\n\t\t}\n\t\tForgeDirection rot = rope.getRotation();\n\t\tGL11.glTranslated(x + 0.5 + (offset * rot.offsetX), y + 0.5, z + 0.5\n\t\t\t\t+ (offset * rot.offsetZ));\n\t\tGL11.glRotatef(BlockUtils.getRotationFromDirection(rot), 0, 1, 0);\n\t\tGL11.glDisable(GL11.GL_LIGHTING);\n\n\t\tBlock b = OpenBlocks.Blocks.ropeLadder;\n\t\tTessellator t = Tessellator.instance;\n\t\tGL11.glColor4f(1, 1, 1, 1);\n\t\tOpenRenderHelper.renderBlocks.setRenderBounds(-0.5, -0.5, -0.5, 0.5, 0.5, -0.4375);\n\t\tt.startDrawingQuads();\n\n\t\tOpenRenderHelper.renderBlocks.renderFaceZNeg(b, 0, 0, 0, b.getBlockTextureFromSide(0));\n\t\tOpenRenderHelper.renderBlocks.renderFaceZPos(b, 0, 0, 0, b.getBlockTextureFromSide(0));\n\n\t\tt.draw();\n\n\t\tGL11.glEnable(GL11.GL_LIGHTING);\n\n\t\tGL11.glPopMatrix();\n\t}\n\n}", "class_id": 0, "repo": "RTLArchive/OpenBlocks", "file": "src/openblocks/client/renderer/tileentity/TileEntityRopeLadderRenderer.java", "last_update_at": "2020-03-01T20:45:19+00:00", "question_id": "7e2cd5bf76a4cc1a86cef3d144d27bf3dddf8a08", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TileEntityRopeLadderRenderer extends TileEntitySpecialRenderer {\n\t@Override\n\tpublic void renderTileEntityAt(TileEntity tileentity, double x, double y, double z, float f) {\n\t\tTileEntityRopeLadder rope = (TileEntityRopeLadder)tileentity;\n\t\tGL11.glPushMatrix();\n\t\tbindTexture(TextureMap.locationBlocksTexture);\n\t\tlong ticks = OpenMods.proxy.getTicks(rope.worldObj);\n\t\tdouble offset = 0.0;\n\t\tif (rope.shouldAnimate()) {\n\t\t\toffset = (MathHelper.sin((float)(rope.yCoord + ((double)ticks / 5))) / 50);\n\t\t}\n\t\tForgeDirection rot = rope.getRotation();\n\t\tGL11.glTranslated(x + 0.5 + (offset * rot.offsetX), y + 0.5, z + 0.5\n\t\t\t\t+ (offset * rot.offsetZ));\n\t\tGL11.glRotatef(BlockUtils.getRotationFromDirection(rot), 0, 1, 0);\n\t\tGL11.glDisable(GL11.GL_LIGHTING);\n\t\tBlock b = OpenBlocks.Blocks.ropeLadder;\n\t\tTessellator t = Tessellator.instance;\n\t\tGL11.glColor4f(1, 1, 1, 1);\n\t\tOpenRenderHelper.renderBlocks.setRenderBounds(-0.5, -0.5, -0.5, 0.5, 0.5, -0.4375);\n\t\tt.startDrawingQuads();\n\t\tOpenRenderHelper.renderBlocks.renderFaceZNeg(b, 0, 0, 0, b.getBlockTextureFromSide(0));\n\t\tOpenRenderHelper.renderBlocks.renderFaceZPos(b, 0, 0, 0, b.getBlockTextureFromSide(0));\n\t\tt.draw();\n\t\tGL11.glEnable(GL11.GL_LIGHTING);\n\t\tGL11.glPopMatrix();\n\t}\n"]]}
{"hexsha": "b7e2a194dbd0fec6cf557ec454a4d945e94c7783", "ext": "java", "lang": "Java", "content": "public class HTTPAuthentication implements Serializable {\n\n\t/**\n\t * serialVersionUID\n\t */\n\tprivate static final long serialVersionUID = -590744458307191489L;\n\n\t/**\n\t * \n\t * @param ras\n\t * @return\n\t */\n\tpublic static CredentialsProvider createBasicAuthentication(WebAppService ras) {\n\t\tHTTPHeader[] headers = ras.getAuthentication();\n\t\tString username = \"\";\n\t\tString password = \"\";\n\t\tif (headers != null && headers.length > 0) {\n\t\t\tfor (HTTPHeader header : headers) {\n\t\t\t\tif (header.getKey().equals(\"username\")) {\n\t\t\t\t\tusername = header.getValue();\n\t\t\t\t} else if (header.getKey().equals(\"password\")) {\n\t\t\t\t\tpassword = header.getValue();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tUsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);\n\t\tCredentialsProvider provider = new BasicCredentialsProvider();\n\t\t// Create the authentication scope\n\t\t// AuthScope scope = new AuthScope(\"www.verisign.com\", 443,\n\t\t// \"realm\"),\n\t\t// AuthScope scope = new AuthScope(\"localhost\", 8080,\n\t\t// AuthScope.ANY_REALM);\n\t\tAuthScope scope = new AuthScope(AuthScope.ANY_HOST, AuthScope.ANY_PORT, AuthScope.ANY_REALM);\n\t\tprovider.setCredentials(scope, credentials);\n\t\treturn provider;\n\t}\n\n\t/**\n\t * \n\t * @param realm\n\t * @return\n\t */\n\tpublic static DigestScheme createDigestAuthentication(String realm) {\n\t\tDigestScheme digestAuth = new DigestScheme();\n\t\tdigestAuth.overrideParamter(\"algorithm\", \"MD5\");\n\t\tif (realm != null && !realm.equals(\"\")) {\n\t\t\tdigestAuth.overrideParamter(\"realm\", realm);\n\t\t} else\n\t\t\tdigestAuth.overrideParamter(\"realm\", AuthScope.ANY_HOST);\n\t\tdigestAuth.overrideParamter(\"nonce\", Long.toString(new Random().nextLong(), 36));\n\t\tdigestAuth.overrideParamter(\"qop\", \"auth\");\n\t\tdigestAuth.overrideParamter(\"nc\", \"0\");\n\t\tdigestAuth.overrideParamter(\"cnonce\", DigestScheme.createCnonce());\n\t\treturn digestAuth;\n\t}\n\n}", "class_id": 0, "repo": "CloudBPM/SwinFlowCloud-CloudSide", "file": "core.microservice/src/main/java/com/cloudibpm/core/microservice/HTTPAuthentication.java", "last_update_at": "2020-11-23T01:56:12+00:00", "question_id": "b7e2a194dbd0fec6cf557ec454a4d945e94c7783", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HTTPAuthentication implements Serializable {\n\t/**\n\t * serialVersionUID\n\t */\n\tprivate static final long serialVersionUID = -590744458307191489L;\n\t/**\n\t * \n\t * @param ras\n\t * @return\n\t */\n\tpublic static CredentialsProvider createBasicAuthentication(WebAppService ras) {\n\t\tHTTPHeader[] headers = ras.getAuthentication();\n\t\tString username = \"\";\n\t\tString password = \"\";\n\t\tif (headers != null && headers.length > 0) {\n\t\t\tfor (HTTPHeader header : headers) {\n\t\t\t\tif (header.getKey().equals(\"username\")) {\n\t\t\t\t\tusername = header.getValue();\n\t\t\t\t} else if (header.getKey().equals(\"password\")) {\n\t\t\t\t\tpassword = header.getValue();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tUsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);\n\t\tCredentialsProvider provider = new BasicCredentialsProvider();\n\t\t// Create the authentication scope\n\t\t// AuthScope scope = new AuthScope(\"www.verisign.com\", 443,\n\t\t// \"realm\"),\n\t\t// AuthScope scope = new AuthScope(\"localhost\", 8080,\n\t\t// AuthScope.ANY_REALM);\n\t\tAuthScope scope = new AuthScope(AuthScope.ANY_HOST, AuthScope.ANY_PORT, AuthScope.ANY_REALM);\n\t\tprovider.setCredentials(scope, credentials);\n\t\treturn provider;\n\t}\n\t/**\n\t * \n\t * @param realm\n\t * @return\n\t */\n\tpublic static DigestScheme createDigestAuthentication(String realm) {\n\t\tDigestScheme digestAuth = new DigestScheme();\n\t\tdigestAuth.overrideParamter(\"algorithm\", \"MD5\");\n\t\tif (realm != null && !realm.equals(\"\")) {\n\t\t\tdigestAuth.overrideParamter(\"realm\", realm);\n\t\t} else\n\t\t\tdigestAuth.overrideParamter(\"realm\", AuthScope.ANY_HOST);\n\t\tdigestAuth.overrideParamter(\"nonce\", Long.toString(new Random().nextLong(), 36));\n\t\tdigestAuth.overrideParamter(\"qop\", \"auth\");\n\t\tdigestAuth.overrideParamter(\"nc\", \"0\");\n\t\tdigestAuth.overrideParamter(\"cnonce\", DigestScheme.createCnonce());\n\t\treturn digestAuth;\n\t}\n"]]}
{"hexsha": "828385e62ed47607e8cda42b1acdeb61773ad6b5", "ext": "java", "lang": "Java", "content": "public class GetParam implements ParamSplit {\n  /**\n   * The Matrix id.\n   */\n  public final int matrixId;\n\n  /**\n   * Creates a new Get parameter.\n   *\n   * @param matrixId the matrix id\n   */\n  public GetParam(int matrixId) {\n    this.matrixId = matrixId;\n  }\n\n  public GetParam() {\n    this(-1);\n  }\n\n  /**\n   * Gets matrix id.\n   *\n   * @return the matrix id\n   */\n  public int getMatrixId() {\n    return matrixId;\n  }\n\n  @Override\n  public List<PartitionGetParam> split() {\n    List<PartitionKey> parts =\n        PSAgentContext.get().getMatrixPartitionRouter().getPartitionKeyList(matrixId);\n    int size = parts.size();\n\n    List<PartitionGetParam> partParams = new ArrayList<PartitionGetParam>(size);\n\n    for (int i = 0; i < size; i++) {\n      partParams.add(new PartitionGetParam(matrixId, parts.get(i)));\n    }\n\n    return partParams;\n  }\n}", "class_id": 0, "repo": "ericzhang-cn/angel", "file": "angel-ps/core/src/main/java/com/tencent/angel/ml/matrix/psf/get/base/GetParam.java", "last_update_at": "2020-08-25T02:17:39+00:00", "question_id": "828385e62ed47607e8cda42b1acdeb61773ad6b5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GetParam implements ParamSplit {\n  /**\n   * The Matrix id.\n   */\n  public final int matrixId;\n  /**\n   * Creates a new Get parameter.\n   *\n   * @param matrixId the matrix id\n   */\n  public GetParam(int matrixId) {\n    this.matrixId = matrixId;\n  }\n  public GetParam() {\n    this(-1);\n  }\n  /**\n   * Gets matrix id.\n   *\n   * @return the matrix id\n   */\n  public int getMatrixId() {\n    return matrixId;\n  }\n  @Override\n  public List<PartitionGetParam> split() {\n    List<PartitionKey> parts =\n        PSAgentContext.get().getMatrixPartitionRouter().getPartitionKeyList(matrixId);\n    int size = parts.size();\n    List<PartitionGetParam> partParams = new ArrayList<PartitionGetParam>(size);\n    for (int i = 0; i < size; i++) {\n      partParams.add(new PartitionGetParam(matrixId, parts.get(i)));\n    }\n    return partParams;\n  }\n"]]}
{"hexsha": "0d1e5cfa865ae7c784962c2db150dff34152e794", "ext": "java", "lang": "Java", "content": "@DisplayName(\"A payment\")\n@DisplayNameGeneration(DisplayNameGenerator.IndicativeSentences.class)\n@IndicativeSentencesGeneration(separator = \" \", generator = DisplayNameGenerator.ReplaceUnderscores.class)\npublic class PaymentTests {\n\n    private EventLog eventLog;\n    private PaymentProcessor paymentProcessor;\n    private Payment payment;\n    private PaymentRef ref;\n\n    @BeforeEach\n    public void setUp() {\n        paymentProcessor = mock(PaymentProcessor.class);\n        eventLog = mock(EventLog.class);\n        ref = new PaymentRef();\n        payment = Payment.builder()\n                .amount(Amount.of(15, 0))\n                .paymentProcessor(paymentProcessor)\n                .eventLog(eventLog)\n                .ref(ref)\n                .build();\n    }\n\n    @Test\n    public void should_start_in_the_new_state() {\n        assertThat(payment.isNew()).isTrue();\n    }\n\n    @Test\n    public void should_request_a_payment_from_the_payment_processor() {\n        payment.request();\n        assertThat(payment.isRequested()).isTrue();\n        verify(paymentProcessor).request(payment);\n    }\n\n    @Test\n    public void should_publish_an_event_when_it_requests_a_payment_from_the_payment_processor() {\n        payment.request();\n        verify(eventLog).publish(eq(new Topic(\"payments\")), isA(PaymentRequestedEvent.class));\n    }\n\n    @Test\n    public void should_reflect_a_successful_payment() {\n        payment.request();\n        payment.markSuccessful();\n        assertThat(payment.isSuccessful()).isTrue();\n    }\n\n    @Test\n    public void should_publish_an_event_when_a_payment_request_succeeds() {\n        payment.request();\n        verify(eventLog).publish(eq(new Topic(\"payments\")), isA(PaymentRequestedEvent.class));\n        payment.markSuccessful();\n        verify(eventLog).publish(eq(new Topic(\"payments\")), isA(PaymentSuccessfulEvent.class));\n    }\n\n    @Test\n    public void should_reflect_a_failed_payment() {\n        payment.request();\n        payment.markFailed();\n        assertThat(payment.isFailed()).isTrue();\n    }\n\n    @Test\n    public void should_publish_an_event_when_a_payment_request_fails() {\n        payment.request();\n        verify(eventLog).publish(eq(new Topic(\"payments\")), isA(PaymentRequestedEvent.class));\n        payment.markFailed();\n        verify(eventLog).publish(eq(new Topic(\"payments\")), isA(PaymentFailedEvent.class));\n    }\n\n    @Test\n    public void should_only_request_payment_from_the_payment_processor_if_it_is_in_the_new_state() {\n        payment.request();\n        payment.markSuccessful();\n        assertThatIllegalStateException().isThrownBy(payment::request);\n    }\n\n    @Test\n    public void should_only_mark_a_requested_payment_as_successful() {\n        assertThatIllegalStateException().isThrownBy(payment::markSuccessful);\n    }\n\n    @Test\n    public void should_only_mark_a_requested_payment_as_failed() {\n        assertThatIllegalStateException().isThrownBy(payment::markFailed);\n    }\n\n    @Test\n    public void accumulator_function_should_return_an_added_payment() {\n        PaymentAddedEvent paymentAddedEvent = new PaymentAddedEvent(ref, payment.state());\n\n        assertThat(payment.accumulatorFunction().apply(payment.identity(), paymentAddedEvent)).isEqualTo(payment);\n    }\n\n    @Test\n    public void accumulator_function_should_return_a_requested_payment() {\n        Payment expectedPayment = Payment.builder()\n                .ref(ref)\n                .eventLog(eventLog)\n                .paymentProcessor(paymentProcessor)\n                .amount(Amount.of(15, 0))\n                .build();\n        expectedPayment.request();\n\n        PaymentRequestedEvent pre = new PaymentRequestedEvent(ref);\n\n        assertThat(payment.accumulatorFunction().apply(payment, pre)).isEqualTo(expectedPayment);\n    }\n\n    @Test\n    public void accumulator_function_should_return_a_successful_payment() {\n        Payment expectedPayment = Payment.builder()\n                .ref(ref)\n                .eventLog(eventLog)\n                .paymentProcessor(paymentProcessor)\n                .amount(Amount.of(15, 0))\n                .build();\n        expectedPayment.request();\n        expectedPayment.markSuccessful();\n\n        PaymentSuccessfulEvent pse = new PaymentSuccessfulEvent(ref);\n\n        assertThat(payment.accumulatorFunction().apply(payment, pse)).isEqualTo(expectedPayment);\n    }\n\n    @Test\n    public void accumulator_function_should_return_a_failed_payment() {\n        Payment expectedPayment = Payment.builder()\n                .ref(ref)\n                .eventLog(eventLog)\n                .paymentProcessor(paymentProcessor)\n                .amount(Amount.of(15, 0))\n                .build();\n        expectedPayment.request();\n        expectedPayment.markFailed();\n\n        PaymentFailedEvent pfe = new PaymentFailedEvent(ref);\n\n        assertThat(payment.accumulatorFunction().apply(payment, pfe)).isEqualTo(expectedPayment);\n    }\n\n    @Test\n    public void accumulator_function_should_throw_an_exception_with_an_unknown_event_type() {\n        assertThatIllegalStateException().isThrownBy(() -> payment.accumulatorFunction().apply(payment, () -> null));\n    }\n\n}", "class_id": 0, "repo": "punit1128/ddd-punit", "file": "src/test/java/com/mattstine/dddworkshop/pizzashop/payments/PaymentTests.java", "last_update_at": "2020-11-15T04:46:31+00:00", "question_id": "0d1e5cfa865ae7c784962c2db150dff34152e794", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@DisplayName(\"A payment\")\n@DisplayNameGeneration(DisplayNameGenerator.IndicativeSentences.class)\n@IndicativeSentencesGeneration(separator = \" \", generator = DisplayNameGenerator.ReplaceUnderscores.class)\npublic class PaymentTests {\n    private EventLog eventLog;\n    private PaymentProcessor paymentProcessor;\n    private Payment payment;\n    private PaymentRef ref;\n    @BeforeEach\n    public void setUp() {\n        paymentProcessor = mock(PaymentProcessor.class);\n        eventLog = mock(EventLog.class);\n        ref = new PaymentRef();\n        payment = Payment.builder()\n                .amount(Amount.of(15, 0))\n                .paymentProcessor(paymentProcessor)\n                .eventLog(eventLog)\n                .ref(ref)\n                .build();\n    }\n    @Test\n    public void should_start_in_the_new_state() {\n        assertThat(payment.isNew()).isTrue();\n    }\n    @Test\n    public void should_request_a_payment_from_the_payment_processor() {\n        payment.request();\n        assertThat(payment.isRequested()).isTrue();\n        verify(paymentProcessor).request(payment);\n    }\n    @Test\n    public void should_publish_an_event_when_it_requests_a_payment_from_the_payment_processor() {\n        payment.request();\n        verify(eventLog).publish(eq(new Topic(\"payments\")), isA(PaymentRequestedEvent.class));\n    }\n    @Test\n    public void should_reflect_a_successful_payment() {\n        payment.request();\n        payment.markSuccessful();\n        assertThat(payment.isSuccessful()).isTrue();\n    }\n    @Test\n    public void should_publish_an_event_when_a_payment_request_succeeds() {\n        payment.request();\n        verify(eventLog).publish(eq(new Topic(\"payments\")), isA(PaymentRequestedEvent.class));\n        payment.markSuccessful();\n        verify(eventLog).publish(eq(new Topic(\"payments\")), isA(PaymentSuccessfulEvent.class));\n    }\n    @Test\n    public void should_reflect_a_failed_payment() {\n        payment.request();\n        payment.markFailed();\n        assertThat(payment.isFailed()).isTrue();\n    }\n    @Test\n    public void should_publish_an_event_when_a_payment_request_fails() {\n        payment.request();\n        verify(eventLog).publish(eq(new Topic(\"payments\")), isA(PaymentRequestedEvent.class));\n        payment.markFailed();\n        verify(eventLog).publish(eq(new Topic(\"payments\")), isA(PaymentFailedEvent.class));\n    }\n    @Test\n    public void should_only_request_payment_from_the_payment_processor_if_it_is_in_the_new_state() {\n        payment.request();\n        payment.markSuccessful();\n        assertThatIllegalStateException().isThrownBy(payment::request);\n    }\n    @Test\n    public void should_only_mark_a_requested_payment_as_successful() {\n        assertThatIllegalStateException().isThrownBy(payment::markSuccessful);\n    }\n    @Test\n    public void should_only_mark_a_requested_payment_as_failed() {\n        assertThatIllegalStateException().isThrownBy(payment::markFailed);\n    }\n    @Test\n    public void accumulator_function_should_return_an_added_payment() {\n        PaymentAddedEvent paymentAddedEvent = new PaymentAddedEvent(ref, payment.state());\n        assertThat(payment.accumulatorFunction().apply(payment.identity(), paymentAddedEvent)).isEqualTo(payment);\n    }\n    @Test\n    public void accumulator_function_should_return_a_requested_payment() {\n        Payment expectedPayment = Payment.builder()\n                .ref(ref)\n                .eventLog(eventLog)\n                .paymentProcessor(paymentProcessor)\n                .amount(Amount.of(15, 0))\n                .build();\n        expectedPayment.request();\n        PaymentRequestedEvent pre = new PaymentRequestedEvent(ref);\n        assertThat(payment.accumulatorFunction().apply(payment, pre)).isEqualTo(expectedPayment);\n    }\n    @Test\n    public void accumulator_function_should_return_a_successful_payment() {\n        Payment expectedPayment = Payment.builder()\n                .ref(ref)\n                .eventLog(eventLog)\n                .paymentProcessor(paymentProcessor)\n                .amount(Amount.of(15, 0))\n                .build();\n        expectedPayment.request();\n        expectedPayment.markSuccessful();\n        PaymentSuccessfulEvent pse = new PaymentSuccessfulEvent(ref);\n        assertThat(payment.accumulatorFunction().apply(payment, pse)).isEqualTo(expectedPayment);\n    }\n    @Test\n    public void accumulator_function_should_return_a_failed_payment() {\n        Payment expectedPayment = Payment.builder()\n                .ref(ref)\n                .eventLog(eventLog)\n                .paymentProcessor(paymentProcessor)\n                .amount(Amount.of(15, 0))\n                .build();\n        expectedPayment.request();\n        expectedPayment.markFailed();\n        PaymentFailedEvent pfe = new PaymentFailedEvent(ref);\n        assertThat(payment.accumulatorFunction().apply(payment, pfe)).isEqualTo(expectedPayment);\n    }\n    @Test\n    public void accumulator_function_should_throw_an_exception_with_an_unknown_event_type() {\n        assertThatIllegalStateException().isThrownBy(() -> payment.accumulatorFunction().apply(payment, () -> null));\n    }\n"]]}
{"hexsha": "3a62418f6aeee79bc6266838be3fbdcc3747ddd3", "ext": "java", "lang": "Java", "content": "public class SchubFormDataServiceImpl implements SchubFormDataService\n{\n    protected ObjectMapper fObjectMapper;\n    protected ProcessEngine fProcessEngine;\n\n    public SchubFormDataServiceImpl()\n    {\n        fObjectMapper = new ObjectMapper();\n        \n        ProcessEngineProvider prov = getProcessEngineProvider();\n        fProcessEngine = prov.getDefaultProcessEngine();\n    }\n\n    @Override\n    public List<FormDataEntryDTO> getFormData(UriInfo uriInfo, String defId,\n        String taskId)\n    {\n        //TODO: support for locked fields?\n        \n        List<FormDataEntryDTO> list = new ArrayList<FormDataEntryDTO>();\n        \n        if(taskId != null && !taskId.isEmpty())\n        {\n            TaskFormData data = fProcessEngine.getFormService().getTaskFormData(taskId);\n\n            for(FormField field : data.getFormFields())\n            {\n                FormDataEntryDTO dto = new FormDataEntryDTO(field);\n                list.add(dto);\n            }\n        }\n        \n        if(defId != null && !defId.isEmpty())\n        {\n            StartFormData data = fProcessEngine.getFormService().getStartFormData(defId);\n            \n            for(FormField field : data.getFormFields())\n            {\n                FormDataEntryDTO dto = new FormDataEntryDTO(field);\n                list.add(dto);\n            }\n        }\n        \n        return list;\n    }\n\n    \n    protected ProcessEngineProvider getProcessEngineProvider()\n    {\n        ServiceLoader<ProcessEngineProvider> serviceLoader =\n            ServiceLoader.load(ProcessEngineProvider.class);\n        Iterator<ProcessEngineProvider> iterator = serviceLoader.iterator();\n    \n        if(iterator.hasNext())\n        {\n          ProcessEngineProvider provider = iterator.next();\n          return provider;\n        }\n        else\n        {\n          throw new RestException(Status.INTERNAL_SERVER_ERROR,\n              \"No process engine provider found\");\n        }\n    }\n}", "class_id": 0, "repo": "iisys-hof/camunda-rest-extension", "file": "src/main/java/de/hofuniversity/iisys/camunda/rest/services/SchubFormDataServiceImpl.java", "last_update_at": "2020-01-11T03:33:48+00:00", "question_id": "3a62418f6aeee79bc6266838be3fbdcc3747ddd3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SchubFormDataServiceImpl implements SchubFormDataService\n{\n    protected ObjectMapper fObjectMapper;\n    protected ProcessEngine fProcessEngine;\n    public SchubFormDataServiceImpl()\n    {\n        fObjectMapper = new ObjectMapper();\n        ProcessEngineProvider prov = getProcessEngineProvider();\n        fProcessEngine = prov.getDefaultProcessEngine();\n    }\n    @Override\n    public List<FormDataEntryDTO> getFormData(UriInfo uriInfo, String defId,\n        String taskId)\n    {\n        //TODO: support for locked fields?\n        List<FormDataEntryDTO> list = new ArrayList<FormDataEntryDTO>();\n        if(taskId != null && !taskId.isEmpty())\n        {\n            TaskFormData data = fProcessEngine.getFormService().getTaskFormData(taskId);\n            for(FormField field : data.getFormFields())\n            {\n                FormDataEntryDTO dto = new FormDataEntryDTO(field);\n                list.add(dto);\n            }\n        }\n        if(defId != null && !defId.isEmpty())\n        {\n            StartFormData data = fProcessEngine.getFormService().getStartFormData(defId);\n            for(FormField field : data.getFormFields())\n            {\n                FormDataEntryDTO dto = new FormDataEntryDTO(field);\n                list.add(dto);\n            }\n        }\n        return list;\n    }\n    protected ProcessEngineProvider getProcessEngineProvider()\n    {\n        ServiceLoader<ProcessEngineProvider> serviceLoader =\n            ServiceLoader.load(ProcessEngineProvider.class);\n        Iterator<ProcessEngineProvider> iterator = serviceLoader.iterator();\n        if(iterator.hasNext())\n        {\n          ProcessEngineProvider provider = iterator.next();\n          return provider;\n        }\n        else\n        {\n          throw new RestException(Status.INTERNAL_SERVER_ERROR,\n              \"No process engine provider found\");\n        }\n    }\n"]]}
{"hexsha": "e03ebcc2bf06aa2643cabea8d7ed9cedab7b3182", "ext": "java", "lang": "Java", "content": "public class FilterBySpaceImplementation<Current, Other> implements FilterBySpace<Current, Other> {\n    @Getter\n    private FilterExpressionType expressionType;\n\n    @Getter\n    private MetaClass<Other> mappingSpace;\n\n    @Getter\n    private MetaField<? extends MetaClass<Current>, ?> mappingKeyField;\n\n    @Getter\n    private Index mappingIndex;\n\n    @Getter\n    private Tuple mappingIndexTuple;\n\n    @Getter\n    private MetaField<? extends MetaClass<Current>, ?> currentField;\n\n    @Getter\n    private MetaField<? extends MetaClass<Other>, ?> otherField;\n\n    @Getter\n    private final FilterBySpaceUseFieldsImplementation<Current, Other, ?> bySpaceUseFields;\n\n    @Getter\n    private final FilterBySpaceUseStringFieldsImplementation<Current, Other> bySpaceUseStringFields;\n\n    @Getter\n    private final FilterBySpaceUseNumberFieldsImplementation<Current, Other> bySpaceUseNumberFields;\n\n    @Getter\n    private final FilterBySpaceUseNumbersImplementation<Current> bySpaceUseNumbers;\n\n    @Getter\n    private final FilterBySpaceUseStringsImplementation<Current> bySpaceUseStrings;\n\n    @Getter\n    private final FilterBySpaceUseValuesImplementation<Current, ?> bySpaceUseValues;\n\n    public FilterBySpaceImplementation(FilterRule<Current> rule) {\n        bySpaceUseFields = new FilterBySpaceUseFieldsImplementation<>(rule);\n        bySpaceUseStringFields = new FilterBySpaceUseStringFieldsImplementation<>(rule);\n        bySpaceUseNumberFields = new FilterBySpaceUseNumberFieldsImplementation<>(rule);\n        bySpaceUseNumbers = new FilterBySpaceUseNumbersImplementation<>(rule);\n        bySpaceUseStrings = new FilterBySpaceUseStringsImplementation<>(rule);\n        bySpaceUseValues = new FilterBySpaceUseValuesImplementation<>(rule);\n    }\n\n    FilterBySpaceImplementation<Current, Other> bySpace(MetaClass<Other> mappingSpace, MetaField<? extends MetaClass<Current>, ?> mappingField) {\n        this.mappingSpace = mappingSpace;\n        mappingKeyField = mappingField;\n        return this;\n    }\n\n    final FilterBySpaceImplementation<Current, Other> byIndex(Index index, Tuple tuple) {\n        mappingIndex = index;\n        mappingIndexTuple = tuple;\n        return this;\n    }\n\n    @Override\n    public <FieldType> FilterBySpaceUseFields<Current, Other, FieldType> currentField(MetaField<? extends MetaClass<Current>, FieldType> currentField) {\n        expressionType = FIELD;\n        this.currentField = currentField;\n        return cast(bySpaceUseFields);\n    }\n\n    @Override\n    public FilterBySpaceUseStringFields<Current, Other> currentString(MetaField<? extends MetaClass<Current>, String> currentField) {\n        expressionType = STRING_FIELD;\n        this.currentField = currentField;\n        return bySpaceUseStringFields;\n    }\n\n    @Override\n    public FilterBySpaceUseNumberFields<Current, Other> currentNumber(MetaField<? extends MetaClass<Current>, ? extends Number> currentField) {\n        expressionType = NUMBER_FIELD;\n        this.currentField = currentField;\n        return bySpaceUseNumberFields;\n    }\n\n    @Override\n    public FilterBySpaceUseNumbers<Current> otherNumber(MetaField<? extends MetaClass<Other>, ? extends Number> otherField) {\n        expressionType = NUMBER_VALUE;\n        this.otherField = otherField;\n        return bySpaceUseNumbers;\n    }\n\n    @Override\n    public FilterBySpaceUseStrings<Current> otherString(MetaField<? extends MetaClass<Other>, String> otherField) {\n        expressionType = STRING_VALUE;\n        this.otherField = otherField;\n        return bySpaceUseStrings;\n    }\n\n    @Override\n    public <FieldType> FilterBySpaceUseValues<Current, FieldType> otherField(MetaField<? extends MetaClass<Other>, FieldType> otherField) {\n        expressionType = VALUE;\n        this.otherField = otherField;\n        return cast(bySpaceUseValues);\n    }\n}", "class_id": 0, "repo": "art-community/art", "file": "storage/src/main/java/io/art/storage/filter/implementation/FilterBySpaceImplementation.java", "last_update_at": "2020-03-29T16:47:57+00:00", "question_id": "e03ebcc2bf06aa2643cabea8d7ed9cedab7b3182", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FilterBySpaceImplementation<Current, Other> implements FilterBySpace<Current, Other> {\n    @Getter\n    private FilterExpressionType expressionType;\n    @Getter\n    private MetaClass<Other> mappingSpace;\n    @Getter\n    private MetaField<? extends MetaClass<Current>, ?> mappingKeyField;\n    @Getter\n    private Index mappingIndex;\n    @Getter\n    private Tuple mappingIndexTuple;\n    @Getter\n    private MetaField<? extends MetaClass<Current>, ?> currentField;\n    @Getter\n    private MetaField<? extends MetaClass<Other>, ?> otherField;\n    @Getter\n    private final FilterBySpaceUseFieldsImplementation<Current, Other, ?> bySpaceUseFields;\n    @Getter\n    private final FilterBySpaceUseStringFieldsImplementation<Current, Other> bySpaceUseStringFields;\n    @Getter\n    private final FilterBySpaceUseNumberFieldsImplementation<Current, Other> bySpaceUseNumberFields;\n    @Getter\n    private final FilterBySpaceUseNumbersImplementation<Current> bySpaceUseNumbers;\n    @Getter\n    private final FilterBySpaceUseStringsImplementation<Current> bySpaceUseStrings;\n    @Getter\n    private final FilterBySpaceUseValuesImplementation<Current, ?> bySpaceUseValues;\n    public FilterBySpaceImplementation(FilterRule<Current> rule) {\n        bySpaceUseFields = new FilterBySpaceUseFieldsImplementation<>(rule);\n        bySpaceUseStringFields = new FilterBySpaceUseStringFieldsImplementation<>(rule);\n        bySpaceUseNumberFields = new FilterBySpaceUseNumberFieldsImplementation<>(rule);\n        bySpaceUseNumbers = new FilterBySpaceUseNumbersImplementation<>(rule);\n        bySpaceUseStrings = new FilterBySpaceUseStringsImplementation<>(rule);\n        bySpaceUseValues = new FilterBySpaceUseValuesImplementation<>(rule);\n    }\n    FilterBySpaceImplementation<Current, Other> bySpace(MetaClass<Other> mappingSpace, MetaField<? extends MetaClass<Current>, ?> mappingField) {\n        this.mappingSpace = mappingSpace;\n        mappingKeyField = mappingField;\n        return this;\n    }\n    final FilterBySpaceImplementation<Current, Other> byIndex(Index index, Tuple tuple) {\n        mappingIndex = index;\n        mappingIndexTuple = tuple;\n        return this;\n    }\n    @Override\n    public <FieldType> FilterBySpaceUseFields<Current, Other, FieldType> currentField(MetaField<? extends MetaClass<Current>, FieldType> currentField) {\n        expressionType = FIELD;\n        this.currentField = currentField;\n        return cast(bySpaceUseFields);\n    }\n    @Override\n    public FilterBySpaceUseStringFields<Current, Other> currentString(MetaField<? extends MetaClass<Current>, String> currentField) {\n        expressionType = STRING_FIELD;\n        this.currentField = currentField;\n        return bySpaceUseStringFields;\n    }\n    @Override\n    public FilterBySpaceUseNumberFields<Current, Other> currentNumber(MetaField<? extends MetaClass<Current>, ? extends Number> currentField) {\n        expressionType = NUMBER_FIELD;\n        this.currentField = currentField;\n        return bySpaceUseNumberFields;\n    }\n    @Override\n    public FilterBySpaceUseNumbers<Current> otherNumber(MetaField<? extends MetaClass<Other>, ? extends Number> otherField) {\n        expressionType = NUMBER_VALUE;\n        this.otherField = otherField;\n        return bySpaceUseNumbers;\n    }\n    @Override\n    public FilterBySpaceUseStrings<Current> otherString(MetaField<? extends MetaClass<Other>, String> otherField) {\n        expressionType = STRING_VALUE;\n        this.otherField = otherField;\n        return bySpaceUseStrings;\n    }\n    @Override\n    public <FieldType> FilterBySpaceUseValues<Current, FieldType> otherField(MetaField<? extends MetaClass<Other>, FieldType> otherField) {\n        expressionType = VALUE;\n        this.otherField = otherField;\n        return cast(bySpaceUseValues);\n    }\n"]]}
{"hexsha": "aebb3f5ecb32edc2a6733e788e542683e8eaf0c4", "ext": "java", "lang": "Java", "content": "public class MultiOptionListFormField extends OptionListFormField {\n\n\tprivate final class HistoryAwareValueChangeListener implements\n\t\t\tValueChangeListener {\n\t\tprivate static final long serialVersionUID = 1L;\n\n\t\tprivate Collection<String> currentValue = MultiOptionListFormField.this\n\t\t\t\t.getValues();\n\n\t\t@Override\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic void valueChange(ValueChangeEvent event) {\n\t\t\tif (!currentValue.equals(event.getProperty().getValue())) {\n\t\t\t\tcurrentValue = (Set<String>) event.getProperty().getValue();\n\n\t\t\t\tfireValueChangeEvent();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n\tprivate ObjectProperty<Set<Object>> listProperty = new ObjectProperty(\n\t\t\tnew HashSet(), Set.class);\n\n\t/**\n\t * Nur f\u00fcr Tests.\n\t * \n\t * @param config\n\t *            Formular-Konfiguration\n\t * @param optionList\n\t *            Auswahl-Box-Modell\n\t * @param eventRouter\n\t *            EventRouter\n\t */\n\tMultiOptionListFormField(\n\t\t\tFormFieldConfig config,\n\t\t\tOptionList optionList,\n\t\t\tEventRouter<FormFieldChangeEventHandler, FormFieldChangeEvent> eventRouter) {\n\t\tthis(config, optionList);\n\t\tthis.eventRouter = eventRouter;\n\t}\n\n\t/**\n\t * Konstruktor mit Paramtern.\n\t * \n\t * @param config\n\t *            Formular-Konfiguration\n\t * @param optionList\n\t *            Auswahl-Box-Modell\n\t */\n\tpublic MultiOptionListFormField(FormFieldConfig config, OptionList optionList) {\n\t\tsuper(config, optionList, false);\n\t\tif (config.getDefault() != null) {\n\t\t\tHashSet<Object> set = hashSetOf(config.getDefault());\n\t\t\tlistProperty.setValue(set);\n\t\t}\n\t\tlistProperty.addValueChangeListener(new HistoryAwareValueChangeListener());\n\n\t}\n\n\tprivate static final HashSet<Object> hashSetOf(Object... values) {\n\t\treturn new HashSet<Object>(asList(values));\n\t}\n\n\t@Override\n\tpublic ObjectProperty<String> getProperty() {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\tpublic ObjectProperty<Set<Object>> getListProperty() {\n\t\treturn listProperty;\n\t}\n\n\t@Override\n\tpublic String getValue() {\n\t\treturn this.listProperty.getValue().size() == 1 ? (String) this.listProperty\n\t\t\t\t.getValue().iterator().next()\n\t\t\t\t: null;\n\t}\n\n\t/**\n\t * Setzt die selektierten Eintr\u00e4ge.\n\t * \n\t * @param values\n\t *            zu selektierenden Eintr\u00e4ge\n\t */\n\tpublic void setValues(Collection<String> values) {\n\t\tlistProperty.setValue(new HashSet<Object>(values));\n\t\tif (values.size() == 0) {\n\t\t\tsuper.setValue(null);\n\t\t} else if (values.size() == 1) {\n\t\t\tsuper.setValue(values.iterator().next());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setValue(String value) {\n\t\tsetValues(value == null ? new HashSet<String>() : Arrays.asList(value));\n\t}\n\n\t/**\n\t * Selektiert einen Eintrag.\n\t * \n\t * @return selektierter Eintrag\n\t */\n\tpublic Set<String> getValues() {\n\t\tHashSet<String> set = new HashSet<String>();\n\t\tfor (Object element : listProperty.getValue()) {\n\t\t\tset.add((String) element);\n\t\t}\n\t\treturn set;\n\t}\n\n}", "class_id": 0, "repo": "aounhaider1/Crud2Go", "file": "eai-portal-domain-crudportlet/src/main/java/de/unioninvestment/eai/portal/portlet/crud/domain/model/MultiOptionListFormField.java", "last_update_at": "2020-08-25T10:59:00+00:00", "question_id": "aebb3f5ecb32edc2a6733e788e542683e8eaf0c4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MultiOptionListFormField extends OptionListFormField {\n\tprivate final class HistoryAwareValueChangeListener implements\n\t\t\tValueChangeListener {\n\t\tprivate static final long serialVersionUID = 1L;\n\t\tprivate Collection<String> currentValue = MultiOptionListFormField.this\n\t\t\t\t.getValues();\n\t\t@Override\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic void valueChange(ValueChangeEvent event) {\n\t\t\tif (!currentValue.equals(event.getProperty().getValue())) {\n\t\t\t\tcurrentValue = (Set<String>) event.getProperty().getValue();\n\t\t\t\tfireValueChangeEvent();\n\t\t\t}\n\t\t}\n\t}\n\tprivate static final long serialVersionUID = 1L;\n\t@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n\tprivate ObjectProperty<Set<Object>> listProperty = new ObjectProperty(\n\t\t\tnew HashSet(), Set.class);\n\t/**\n\t * Nur f\u00fcr Tests.\n\t * \n\t * @param config\n\t *            Formular-Konfiguration\n\t * @param optionList\n\t *            Auswahl-Box-Modell\n\t * @param eventRouter\n\t *            EventRouter\n\t */\n\tMultiOptionListFormField(\n\t\t\tFormFieldConfig config,\n\t\t\tOptionList optionList,\n\t\t\tEventRouter<FormFieldChangeEventHandler, FormFieldChangeEvent> eventRouter) {\n\t\tthis(config, optionList);\n\t\tthis.eventRouter = eventRouter;\n\t}\n\t/**\n\t * Konstruktor mit Paramtern.\n\t * \n\t * @param config\n\t *            Formular-Konfiguration\n\t * @param optionList\n\t *            Auswahl-Box-Modell\n\t */\n\tpublic MultiOptionListFormField(FormFieldConfig config, OptionList optionList) {\n\t\tsuper(config, optionList, false);\n\t\tif (config.getDefault() != null) {\n\t\t\tHashSet<Object> set = hashSetOf(config.getDefault());\n\t\t\tlistProperty.setValue(set);\n\t\t}\n\t\tlistProperty.addValueChangeListener(new HistoryAwareValueChangeListener());\n\t}\n\tprivate static final HashSet<Object> hashSetOf(Object... values) {\n\t\treturn new HashSet<Object>(asList(values));\n\t}\n\t@Override\n\tpublic ObjectProperty<String> getProperty() {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\tpublic ObjectProperty<Set<Object>> getListProperty() {\n\t\treturn listProperty;\n\t}\n\t@Override\n\tpublic String getValue() {\n\t\treturn this.listProperty.getValue().size() == 1 ? (String) this.listProperty\n\t\t\t\t.getValue().iterator().next()\n\t\t\t\t: null;\n\t}\n\t/**\n\t * Setzt die selektierten Eintr\u00e4ge.\n\t * \n\t * @param values\n\t *            zu selektierenden Eintr\u00e4ge\n\t */\n\tpublic void setValues(Collection<String> values) {\n\t\tlistProperty.setValue(new HashSet<Object>(values));\n\t\tif (values.size() == 0) {\n\t\t\tsuper.setValue(null);\n\t\t} else if (values.size() == 1) {\n\t\t\tsuper.setValue(values.iterator().next());\n\t\t}\n\t}\n\t@Override\n\tpublic void setValue(String value) {\n\t\tsetValues(value == null ? new HashSet<String>() : Arrays.asList(value));\n\t}\n\t/**\n\t * Selektiert einen Eintrag.\n\t * \n\t * @return selektierter Eintrag\n\t */\n\tpublic Set<String> getValues() {\n\t\tHashSet<String> set = new HashSet<String>();\n\t\tfor (Object element : listProperty.getValue()) {\n\t\t\tset.add((String) element);\n\t\t}\n\t\treturn set;\n\t}\n"]]}
{"hexsha": "2cc6a074eb6321bdac1d18228d84b9ee6d635704", "ext": "java", "lang": "Java", "content": "@Test(testName = \"client.hotrod.query.RemoteQueryDslConditionsIspnDirTest\", groups = \"functional\")\npublic class RemoteQueryDslConditionsIspnDirTest extends RemoteQueryDslConditionsTest {\n\n   private static final String TEST_CACHE_NAME = \"testCache\";\n\n   @Override\n   protected void createCacheManagers() throws Throwable {\n      GlobalConfigurationBuilder globalBuilder = new GlobalConfigurationBuilder().clusteredDefault();\n      globalBuilder.serialization().addContextInitializers(TestDomainSCI.INSTANCE, NotIndexedSCI.INSTANCE);\n      createClusteredCaches(1, globalBuilder, new ConfigurationBuilder(), true);\n\n      ConfigurationBuilder cfg = getConfigurationBuilder();\n      manager(0).defineConfiguration(TEST_CACHE_NAME, cfg.build());\n      cache = manager(0).getCache(TEST_CACHE_NAME);\n\n      hotRodServer = HotRodClientTestingUtil.startHotRodServer(manager(0));\n\n      org.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder = HotRodClientTestingUtil.newRemoteConfigurationBuilder();\n      clientBuilder.addServer().host(\"127.0.0.1\").port(hotRodServer.getPort()).addContextInitializers(TestDomainSCI.INSTANCE, NotIndexedSCI.INSTANCE);\n      remoteCacheManager = new RemoteCacheManager(clientBuilder.build());\n      remoteCache = remoteCacheManager.getCache(TEST_CACHE_NAME);\n   }\n\n   @Override\n   protected ConfigurationBuilder getConfigurationBuilder() {\n      ConfigurationBuilder builder = super.getConfigurationBuilder();\n      builder.indexing().addProperty(\"default.directory_provider\", \"local-heap\");\n      return builder;\n   }\n}", "class_id": 0, "repo": "liang0/infinispan", "file": "client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsIspnDirTest.java", "last_update_at": "2020-06-18T17:55:05+00:00", "question_id": "2cc6a074eb6321bdac1d18228d84b9ee6d635704", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Test(testName = \"client.hotrod.query.RemoteQueryDslConditionsIspnDirTest\", groups = \"functional\")\npublic class RemoteQueryDslConditionsIspnDirTest extends RemoteQueryDslConditionsTest {\n   private static final String TEST_CACHE_NAME = \"testCache\";\n   @Override\n   protected void createCacheManagers() throws Throwable {\n      GlobalConfigurationBuilder globalBuilder = new GlobalConfigurationBuilder().clusteredDefault();\n      globalBuilder.serialization().addContextInitializers(TestDomainSCI.INSTANCE, NotIndexedSCI.INSTANCE);\n      createClusteredCaches(1, globalBuilder, new ConfigurationBuilder(), true);\n      ConfigurationBuilder cfg = getConfigurationBuilder();\n      manager(0).defineConfiguration(TEST_CACHE_NAME, cfg.build());\n      cache = manager(0).getCache(TEST_CACHE_NAME);\n      hotRodServer = HotRodClientTestingUtil.startHotRodServer(manager(0));\n      org.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder = HotRodClientTestingUtil.newRemoteConfigurationBuilder();\n      clientBuilder.addServer().host(\"127.0.0.1\").port(hotRodServer.getPort()).addContextInitializers(TestDomainSCI.INSTANCE, NotIndexedSCI.INSTANCE);\n      remoteCacheManager = new RemoteCacheManager(clientBuilder.build());\n      remoteCache = remoteCacheManager.getCache(TEST_CACHE_NAME);\n   }\n   @Override\n   protected ConfigurationBuilder getConfigurationBuilder() {\n      ConfigurationBuilder builder = super.getConfigurationBuilder();\n      builder.indexing().addProperty(\"default.directory_provider\", \"local-heap\");\n      return builder;\n   }\n"]]}
{"hexsha": "f8ec9fca2e74b41fa164e2bc4a24848c9a8b33d2", "ext": "java", "lang": "Java", "content": "public class WriteStreamDataprocServerlessAcceptanceTestBase\n    extends DataprocServerlessAcceptanceTestBase {\n\n  public WriteStreamDataprocServerlessAcceptanceTestBase(String connectorJarPrefix) {\n    super(connectorJarPrefix);\n  }\n\n  @Test\n  public void testBatch() throws Exception {\n    String testName = \"write-stream-test\";\n    String jsonFileName = \"write_stream_data.json\";\n    String jsonFileUri = context.testBaseGcsDir + \"/\" + testName + \"/json/\" + jsonFileName;\n\n    AcceptanceTestUtils.uploadToGcs(\n        getClass().getResourceAsStream(\"/acceptance/\" + jsonFileName),\n        jsonFileUri,\n        \"application/json\");\n\n    OperationSnapshot operationSnapshot =\n        createAndRunPythonBatch(\n            context,\n            testName,\n            \"write_stream.py\",\n            null,\n            Arrays.asList(\n                context.testBaseGcsDir + \"/\" + testName + \"/json/\",\n                context.bqDataset,\n                context.bqStreamTable,\n                AcceptanceTestUtils.BUCKET),\n            240);\n    assertThat(operationSnapshot.isDone()).isTrue();\n    assertThat(operationSnapshot.getErrorMessage()).isEmpty();\n\n    int numOfRows = getNumOfRowsOfBqTable(context.bqDataset, context.bqStreamTable);\n    assertThat(numOfRows).isEqualTo(2);\n  }\n}", "class_id": 0, "repo": "askdre/spk-bq-con-askdre", "file": "spark-bigquery-tests/src/main/java/com/google/cloud/spark/bigquery/acceptance/WriteStreamDataprocServerlessAcceptanceTestBase.java", "last_update_at": "2020-01-15T16:33:28+00:00", "question_id": "f8ec9fca2e74b41fa164e2bc4a24848c9a8b33d2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class WriteStreamDataprocServerlessAcceptanceTestBase\n    extends DataprocServerlessAcceptanceTestBase {\n  public WriteStreamDataprocServerlessAcceptanceTestBase(String connectorJarPrefix) {\n    super(connectorJarPrefix);\n  }\n  @Test\n  public void testBatch() throws Exception {\n    String testName = \"write-stream-test\";\n    String jsonFileName = \"write_stream_data.json\";\n    String jsonFileUri = context.testBaseGcsDir + \"/\" + testName + \"/json/\" + jsonFileName;\n    AcceptanceTestUtils.uploadToGcs(\n        getClass().getResourceAsStream(\"/acceptance/\" + jsonFileName),\n        jsonFileUri,\n        \"application/json\");\n    OperationSnapshot operationSnapshot =\n        createAndRunPythonBatch(\n            context,\n            testName,\n            \"write_stream.py\",\n            null,\n            Arrays.asList(\n                context.testBaseGcsDir + \"/\" + testName + \"/json/\",\n                context.bqDataset,\n                context.bqStreamTable,\n                AcceptanceTestUtils.BUCKET),\n            240);\n    assertThat(operationSnapshot.isDone()).isTrue();\n    assertThat(operationSnapshot.getErrorMessage()).isEmpty();\n    int numOfRows = getNumOfRowsOfBqTable(context.bqDataset, context.bqStreamTable);\n    assertThat(numOfRows).isEqualTo(2);\n  }\n"]]}
{"hexsha": "77f357ef74ebc08199f5a3073ebb0eaa7f8aee9d", "ext": "java", "lang": "Java", "content": "public class HelloController implements Controller, Initializable {\n    private Stage primaryStage;\n    private ResourceBundle resourceBundle;\n\n    @Override\n    public void initialize(URL url, ResourceBundle resourceBundle) {\n        this.resourceBundle = resourceBundle;\n    }\n\n    public void setPrimaryStage(Stage primaryStage) {\n        this.primaryStage = primaryStage;\n    }\n\n    @FXML\n    private void sayHello() {\n        System.out.println(\"say hello\");\n        Alert alert = new Alert(Alert.AlertType.INFORMATION);\n        alert.setTitle(\"Say Hello\");\n        alert.setContentText(resourceBundle.getString(\"say.hello\"));\n        alert.initModality(Modality.WINDOW_MODAL);\n        System.out.println(\"say hi\");\n        alert.initOwner(primaryStage);\n        alert.showAndWait();\n    }\n}", "class_id": 0, "repo": "jupiter-projects/viewfx", "file": "sample/hellofx/src/main/java/com/example/controller/HelloController.java", "last_update_at": "2020-07-26T19:06:06+00:00", "question_id": "77f357ef74ebc08199f5a3073ebb0eaa7f8aee9d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HelloController implements Controller, Initializable {\n    private Stage primaryStage;\n    private ResourceBundle resourceBundle;\n    @Override\n    public void initialize(URL url, ResourceBundle resourceBundle) {\n        this.resourceBundle = resourceBundle;\n    }\n    public void setPrimaryStage(Stage primaryStage) {\n        this.primaryStage = primaryStage;\n    }\n    @FXML\n    private void sayHello() {\n        System.out.println(\"say hello\");\n        Alert alert = new Alert(Alert.AlertType.INFORMATION);\n        alert.setTitle(\"Say Hello\");\n        alert.setContentText(resourceBundle.getString(\"say.hello\"));\n        alert.initModality(Modality.WINDOW_MODAL);\n        System.out.println(\"say hi\");\n        alert.initOwner(primaryStage);\n        alert.showAndWait();\n    }\n"]]}
{"hexsha": "d6d0822b925dc65ce3da92dfc0a2fccb02823fad", "ext": "java", "lang": "Java", "content": "public class BuildStatusTest {\r\n\t\r\n\t@Test\r\n\tpublic void testOrder() {\r\n\t\tassertEquals(6, BuildStatus.values().length);\r\n\t\tassertEquals(0, BuildStatus.FORK.ordinal());\r\n\t\tassertEquals(1, BuildStatus.LOCK.ordinal());\r\n\t\tassertEquals(2, BuildStatus.BUILD_MDEPS.ordinal());\r\n\t\tassertEquals(3, BuildStatus.ACTUALIZE_PATCHES.ordinal());\r\n\t\tassertEquals(4, BuildStatus.BUILD.ordinal());\r\n\t\tassertEquals(5, BuildStatus.DONE.ordinal());\r\n\t}\r\n}", "class_id": 0, "repo": "ProjectKaiser/pk-scm-wf", "file": "src/test/java/org/scm4j/releaser/BuildStatusTest.java", "last_update_at": "2020-12-03T18:09:28+00:00", "question_id": "d6d0822b925dc65ce3da92dfc0a2fccb02823fad", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BuildStatusTest {\r\n\t\r\n\t@Test\r\n\tpublic void testOrder() {\r\n\t\tassertEquals(6, BuildStatus.values().length);\r\n\t\tassertEquals(0, BuildStatus.FORK.ordinal());\r\n\t\tassertEquals(1, BuildStatus.LOCK.ordinal());\r\n\t\tassertEquals(2, BuildStatus.BUILD_MDEPS.ordinal());\r\n\t\tassertEquals(3, BuildStatus.ACTUALIZE_PATCHES.ordinal());\r\n\t\tassertEquals(4, BuildStatus.BUILD.ordinal());\r\n\t\tassertEquals(5, BuildStatus.DONE.ordinal());\r\n\t}\r\n"]]}
{"hexsha": "d731776d74d38dead201cbec35cbfea8e65e063f", "ext": "java", "lang": "Java", "content": "@BeanDefinition(builderScope = \"private\", metaScope = \"private\", factoryName = \"of\")\npublic final class MarginError implements ImmutableBean {\n\n  /**\n   * The error reason.\n   */\n  @PropertyDefinition(validate = \"notEmpty\")\n  private final String reason;\n  /**\n   * The error message.\n   */\n  @PropertyDefinition(validate = \"notNull\")\n  private final String message;\n  /**\n   * The optional error type, such as an exception class name.\n   */\n  @PropertyDefinition(get = \"optional\")\n  private final String type;\n\n  @PropertyDefinition(validate = \"notNull\")\n  private final Map<String, String> attributes;\n\n  //------------------------- AUTOGENERATED START -------------------------\n  /**\n   * The meta-bean for {@code MarginError}.\n   * @return the meta-bean, not null\n   */\n  public static MetaBean meta() {\n    return MarginError.Meta.INSTANCE;\n  }\n\n  static {\n    MetaBean.register(MarginError.Meta.INSTANCE);\n  }\n\n  /**\n   * Obtains an instance.\n   * @param reason  the value of the property, not empty\n   * @param message  the value of the property, not null\n   * @param type  the value of the property\n   * @param attributes  the value of the property, not null\n   * @return the instance\n   */\n  public static MarginError of(\n      String reason,\n      String message,\n      String type,\n      Map<String, String> attributes) {\n    return new MarginError(\n      reason,\n      message,\n      type,\n      attributes);\n  }\n\n  private MarginError(\n      String reason,\n      String message,\n      String type,\n      Map<String, String> attributes) {\n    JodaBeanUtils.notEmpty(reason, \"reason\");\n    JodaBeanUtils.notNull(message, \"message\");\n    JodaBeanUtils.notNull(attributes, \"attributes\");\n    this.reason = reason;\n    this.message = message;\n    this.type = type;\n    this.attributes = Collections.unmodifiableMap(new HashMap<>(attributes));\n  }\n\n  @Override\n  public MetaBean metaBean() {\n    return MarginError.Meta.INSTANCE;\n  }\n\n  //-----------------------------------------------------------------------\n  /**\n   * Gets the error reason.\n   * @return the value of the property, not empty\n   */\n  public String getReason() {\n    return reason;\n  }\n\n  //-----------------------------------------------------------------------\n  /**\n   * Gets the error message.\n   * @return the value of the property, not null\n   */\n  public String getMessage() {\n    return message;\n  }\n\n  //-----------------------------------------------------------------------\n  /**\n   * Gets the optional error type, such as an exception class name.\n   * @return the optional value of the property, not null\n   */\n  public Optional<String> getType() {\n    return Optional.ofNullable(type);\n  }\n\n  //-----------------------------------------------------------------------\n  /**\n   * Gets the attributes.\n   * @return the value of the property, not null\n   */\n  public Map<String, String> getAttributes() {\n    return attributes;\n  }\n\n  //-----------------------------------------------------------------------\n  @Override\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (obj != null && obj.getClass() == this.getClass()) {\n      MarginError other = (MarginError) obj;\n      return JodaBeanUtils.equal(reason, other.reason) &&\n          JodaBeanUtils.equal(message, other.message) &&\n          JodaBeanUtils.equal(type, other.type) &&\n          JodaBeanUtils.equal(attributes, other.attributes);\n    }\n    return false;\n  }\n\n  @Override\n  public int hashCode() {\n    int hash = getClass().hashCode();\n    hash = hash * 31 + JodaBeanUtils.hashCode(reason);\n    hash = hash * 31 + JodaBeanUtils.hashCode(message);\n    hash = hash * 31 + JodaBeanUtils.hashCode(type);\n    hash = hash * 31 + JodaBeanUtils.hashCode(attributes);\n    return hash;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder buf = new StringBuilder(160);\n    buf.append(\"MarginError{\");\n    buf.append(\"reason\").append('=').append(JodaBeanUtils.toString(reason)).append(',').append(' ');\n    buf.append(\"message\").append('=').append(JodaBeanUtils.toString(message)).append(',').append(' ');\n    buf.append(\"type\").append('=').append(JodaBeanUtils.toString(type)).append(',').append(' ');\n    buf.append(\"attributes\").append('=').append(JodaBeanUtils.toString(attributes));\n    buf.append('}');\n    return buf.toString();\n  }\n\n  //-----------------------------------------------------------------------\n  /**\n   * The meta-bean for {@code MarginError}.\n   */\n  private static final class Meta extends DirectMetaBean {\n    /**\n     * The singleton instance of the meta-bean.\n     */\n    static final Meta INSTANCE = new Meta();\n\n    /**\n     * The meta-property for the {@code reason} property.\n     */\n    private final MetaProperty<String> reason = DirectMetaProperty.ofImmutable(\n        this, \"reason\", MarginError.class, String.class);\n    /**\n     * The meta-property for the {@code message} property.\n     */\n    private final MetaProperty<String> message = DirectMetaProperty.ofImmutable(\n        this, \"message\", MarginError.class, String.class);\n    /**\n     * The meta-property for the {@code type} property.\n     */\n    private final MetaProperty<String> type = DirectMetaProperty.ofImmutable(\n        this, \"type\", MarginError.class, String.class);\n    /**\n     * The meta-property for the {@code attributes} property.\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\" })\n    private final MetaProperty<Map<String, String>> attributes = DirectMetaProperty.ofImmutable(\n        this, \"attributes\", MarginError.class, (Class) Map.class);\n    /**\n     * The meta-properties.\n     */\n    private final Map<String, MetaProperty<?>> metaPropertyMap$ = new DirectMetaPropertyMap(\n        this, null,\n        \"reason\",\n        \"message\",\n        \"type\",\n        \"attributes\");\n\n    /**\n     * Restricted constructor.\n     */\n    private Meta() {\n    }\n\n    @Override\n    protected MetaProperty<?> metaPropertyGet(String propertyName) {\n      switch (propertyName.hashCode()) {\n        case -934964668:  // reason\n          return reason;\n        case 954925063:  // message\n          return message;\n        case 3575610:  // type\n          return type;\n        case 405645655:  // attributes\n          return attributes;\n      }\n      return super.metaPropertyGet(propertyName);\n    }\n\n    @Override\n    public BeanBuilder<? extends MarginError> builder() {\n      return new MarginError.Builder();\n    }\n\n    @Override\n    public Class<? extends MarginError> beanType() {\n      return MarginError.class;\n    }\n\n    @Override\n    public Map<String, MetaProperty<?>> metaPropertyMap() {\n      return metaPropertyMap$;\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    protected Object propertyGet(Bean bean, String propertyName, boolean quiet) {\n      switch (propertyName.hashCode()) {\n        case -934964668:  // reason\n          return ((MarginError) bean).getReason();\n        case 954925063:  // message\n          return ((MarginError) bean).getMessage();\n        case 3575610:  // type\n          return ((MarginError) bean).type;\n        case 405645655:  // attributes\n          return ((MarginError) bean).getAttributes();\n      }\n      return super.propertyGet(bean, propertyName, quiet);\n    }\n\n    @Override\n    protected void propertySet(Bean bean, String propertyName, Object newValue, boolean quiet) {\n      metaProperty(propertyName);\n      if (quiet) {\n        return;\n      }\n      throw new UnsupportedOperationException(\"Property cannot be written: \" + propertyName);\n    }\n\n  }\n\n  //-----------------------------------------------------------------------\n  /**\n   * The bean-builder for {@code MarginError}.\n   */\n  private static final class Builder extends DirectPrivateBeanBuilder<MarginError> {\n\n    private String reason;\n    private String message;\n    private String type;\n    private Map<String, String> attributes = Collections.emptyMap();\n\n    /**\n     * Restricted constructor.\n     */\n    private Builder() {\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public Object get(String propertyName) {\n      switch (propertyName.hashCode()) {\n        case -934964668:  // reason\n          return reason;\n        case 954925063:  // message\n          return message;\n        case 3575610:  // type\n          return type;\n        case 405645655:  // attributes\n          return attributes;\n        default:\n          throw new NoSuchElementException(\"Unknown property: \" + propertyName);\n      }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Builder set(String propertyName, Object newValue) {\n      switch (propertyName.hashCode()) {\n        case -934964668:  // reason\n          this.reason = (String) newValue;\n          break;\n        case 954925063:  // message\n          this.message = (String) newValue;\n          break;\n        case 3575610:  // type\n          this.type = (String) newValue;\n          break;\n        case 405645655:  // attributes\n          this.attributes = (Map<String, String>) newValue;\n          break;\n        default:\n          throw new NoSuchElementException(\"Unknown property: \" + propertyName);\n      }\n      return this;\n    }\n\n    @Override\n    public MarginError build() {\n      return new MarginError(\n          reason,\n          message,\n          type,\n          attributes);\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public String toString() {\n      StringBuilder buf = new StringBuilder(160);\n      buf.append(\"MarginError.Builder{\");\n      buf.append(\"reason\").append('=').append(JodaBeanUtils.toString(reason)).append(',').append(' ');\n      buf.append(\"message\").append('=').append(JodaBeanUtils.toString(message)).append(',').append(' ');\n      buf.append(\"type\").append('=').append(JodaBeanUtils.toString(type)).append(',').append(' ');\n      buf.append(\"attributes\").append('=').append(JodaBeanUtils.toString(attributes));\n      buf.append('}');\n      return buf.toString();\n    }\n\n  }\n\n  //-------------------------- AUTOGENERATED END --------------------------\n}", "class_id": 0, "repo": "OpenGamma/ServiceClient", "file": "modules/margin/src/main/java/com/opengamma/sdk/margin/MarginError.java", "last_update_at": "2020-07-06T15:48:26+00:00", "question_id": "d731776d74d38dead201cbec35cbfea8e65e063f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@BeanDefinition(builderScope = \"private\", metaScope = \"private\", factoryName = \"of\")\npublic final class MarginError implements ImmutableBean {\n  /**\n   * The error reason.\n   */\n  @PropertyDefinition(validate = \"notEmpty\")\n  private final String reason;\n  /**\n   * The error message.\n   */\n  @PropertyDefinition(validate = \"notNull\")\n  private final String message;\n  /**\n   * The optional error type, such as an exception class name.\n   */\n  @PropertyDefinition(get = \"optional\")\n  private final String type;\n  @PropertyDefinition(validate = \"notNull\")\n  private final Map<String, String> attributes;\n  //------------------------- AUTOGENERATED START -------------------------\n  /**\n   * The meta-bean for {@code MarginError}.\n   * @return the meta-bean, not null\n   */\n  public static MetaBean meta() {\n    return MarginError.Meta.INSTANCE;\n  }\n  static {\n    MetaBean.register(MarginError.Meta.INSTANCE);\n  }\n  /**\n   * Obtains an instance.\n   * @param reason  the value of the property, not empty\n   * @param message  the value of the property, not null\n   * @param type  the value of the property\n   * @param attributes  the value of the property, not null\n   * @return the instance\n   */\n  public static MarginError of(\n      String reason,\n      String message,\n      String type,\n      Map<String, String> attributes) {\n    return new MarginError(\n      reason,\n      message,\n      type,\n      attributes);\n  }\n  private MarginError(\n      String reason,\n      String message,\n      String type,\n      Map<String, String> attributes) {\n    JodaBeanUtils.notEmpty(reason, \"reason\");\n    JodaBeanUtils.notNull(message, \"message\");\n    JodaBeanUtils.notNull(attributes, \"attributes\");\n    this.reason = reason;\n    this.message = message;\n    this.type = type;\n    this.attributes = Collections.unmodifiableMap(new HashMap<>(attributes));\n  }\n  @Override\n  public MetaBean metaBean() {\n    return MarginError.Meta.INSTANCE;\n  }\n  //-----------------------------------------------------------------------\n  /**\n   * Gets the error reason.\n   * @return the value of the property, not empty\n   */\n  public String getReason() {\n    return reason;\n  }\n  //-----------------------------------------------------------------------\n  /**\n   * Gets the error message.\n   * @return the value of the property, not null\n   */\n  public String getMessage() {\n    return message;\n  }\n  //-----------------------------------------------------------------------\n  /**\n   * Gets the optional error type, such as an exception class name.\n   * @return the optional value of the property, not null\n   */\n  public Optional<String> getType() {\n    return Optional.ofNullable(type);\n  }\n  //-----------------------------------------------------------------------\n  /**\n   * Gets the attributes.\n   * @return the value of the property, not null\n   */\n  public Map<String, String> getAttributes() {\n    return attributes;\n  }\n  //-----------------------------------------------------------------------\n  @Override\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (obj != null && obj.getClass() == this.getClass()) {\n      MarginError other = (MarginError) obj;\n      return JodaBeanUtils.equal(reason, other.reason) &&\n          JodaBeanUtils.equal(message, other.message) &&\n          JodaBeanUtils.equal(type, other.type) &&\n          JodaBeanUtils.equal(attributes, other.attributes);\n    }\n    return false;\n  }\n  @Override\n  public int hashCode() {\n    int hash = getClass().hashCode();\n    hash = hash * 31 + JodaBeanUtils.hashCode(reason);\n    hash = hash * 31 + JodaBeanUtils.hashCode(message);\n    hash = hash * 31 + JodaBeanUtils.hashCode(type);\n    hash = hash * 31 + JodaBeanUtils.hashCode(attributes);\n    return hash;\n  }\n  @Override\n  public String toString() {\n    StringBuilder buf = new StringBuilder(160);\n    buf.append(\"MarginError{\");\n    buf.append(\"reason\").append('=').append(JodaBeanUtils.toString(reason)).append(',').append(' ');\n    buf.append(\"message\").append('=').append(JodaBeanUtils.toString(message)).append(',').append(' ');\n    buf.append(\"type\").append('=').append(JodaBeanUtils.toString(type)).append(',').append(' ');\n    buf.append(\"attributes\").append('=').append(JodaBeanUtils.toString(attributes));\n    buf.append('}');\n    return buf.toString();\n  }\n  //-----------------------------------------------------------------------\n  /**\n   * The meta-bean for {@code MarginError}.\n   */\n  private static final class Meta extends DirectMetaBean {\n    /**\n     * The singleton instance of the meta-bean.\n     */\n    static final Meta INSTANCE = new Meta();\n    /**\n     * The meta-property for the {@code reason} property.\n     */\n    private final MetaProperty<String> reason = DirectMetaProperty.ofImmutable(\n        this, \"reason\", MarginError.class, String.class);\n    /**\n     * The meta-property for the {@code message} property.\n     */\n    private final MetaProperty<String> message = DirectMetaProperty.ofImmutable(\n        this, \"message\", MarginError.class, String.class);\n    /**\n     * The meta-property for the {@code type} property.\n     */\n    private final MetaProperty<String> type = DirectMetaProperty.ofImmutable(\n        this, \"type\", MarginError.class, String.class);\n    /**\n     * The meta-property for the {@code attributes} property.\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\" })\n    private final MetaProperty<Map<String, String>> attributes = DirectMetaProperty.ofImmutable(\n        this, \"attributes\", MarginError.class, (Class) Map.class);\n    /**\n     * The meta-properties.\n     */\n    private final Map<String, MetaProperty<?>> metaPropertyMap$ = new DirectMetaPropertyMap(\n        this, null,\n        \"reason\",\n        \"message\",\n        \"type\",\n        \"attributes\");\n    /**\n     * Restricted constructor.\n     */\n    private Meta() {\n    }\n    @Override\n    protected MetaProperty<?> metaPropertyGet(String propertyName) {\n      switch (propertyName.hashCode()) {\n        case -934964668:  // reason\n          return reason;\n        case 954925063:  // message\n          return message;\n        case 3575610:  // type\n          return type;\n        case 405645655:  // attributes\n          return attributes;\n      }\n      return super.metaPropertyGet(propertyName);\n    }\n    @Override\n    public BeanBuilder<? extends MarginError> builder() {\n      return new MarginError.Builder();\n    }\n    @Override\n    public Class<? extends MarginError> beanType() {\n      return MarginError.class;\n    }\n    @Override\n    public Map<String, MetaProperty<?>> metaPropertyMap() {\n      return metaPropertyMap$;\n    }\n    //-----------------------------------------------------------------------\n    @Override\n    protected Object propertyGet(Bean bean, String propertyName, boolean quiet) {\n      switch (propertyName.hashCode()) {\n        case -934964668:  // reason\n          return ((MarginError) bean).getReason();\n        case 954925063:  // message\n          return ((MarginError) bean).getMessage();\n        case 3575610:  // type\n          return ((MarginError) bean).type;\n        case 405645655:  // attributes\n          return ((MarginError) bean).getAttributes();\n      }\n      return super.propertyGet(bean, propertyName, quiet);\n    }\n    @Override\n    protected void propertySet(Bean bean, String propertyName, Object newValue, boolean quiet) {\n      metaProperty(propertyName);\n      if (quiet) {\n        return;\n      }\n      throw new UnsupportedOperationException(\"Property cannot be written: \" + propertyName);\n    }\n  }\n  //-----------------------------------------------------------------------\n  /**\n   * The bean-builder for {@code MarginError}.\n   */\n  private static final class Builder extends DirectPrivateBeanBuilder<MarginError> {\n    private String reason;\n    private String message;\n    private String type;\n    private Map<String, String> attributes = Collections.emptyMap();\n    /**\n     * Restricted constructor.\n     */\n    private Builder() {\n    }\n    //-----------------------------------------------------------------------\n    @Override\n    public Object get(String propertyName) {\n      switch (propertyName.hashCode()) {\n        case -934964668:  // reason\n          return reason;\n        case 954925063:  // message\n          return message;\n        case 3575610:  // type\n          return type;\n        case 405645655:  // attributes\n          return attributes;\n        default:\n          throw new NoSuchElementException(\"Unknown property: \" + propertyName);\n      }\n    }\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Builder set(String propertyName, Object newValue) {\n      switch (propertyName.hashCode()) {\n        case -934964668:  // reason\n          this.reason = (String) newValue;\n          break;\n        case 954925063:  // message\n          this.message = (String) newValue;\n          break;\n        case 3575610:  // type\n          this.type = (String) newValue;\n          break;\n        case 405645655:  // attributes\n          this.attributes = (Map<String, String>) newValue;\n          break;\n        default:\n          throw new NoSuchElementException(\"Unknown property: \" + propertyName);\n      }\n      return this;\n    }\n    @Override\n    public MarginError build() {\n      return new MarginError(\n          reason,\n          message,\n          type,\n          attributes);\n    }\n    //-----------------------------------------------------------------------\n    @Override\n    public String toString() {\n      StringBuilder buf = new StringBuilder(160);\n      buf.append(\"MarginError.Builder{\");\n      buf.append(\"reason\").append('=').append(JodaBeanUtils.toString(reason)).append(',').append(' ');\n      buf.append(\"message\").append('=').append(JodaBeanUtils.toString(message)).append(',').append(' ');\n      buf.append(\"type\").append('=').append(JodaBeanUtils.toString(type)).append(',').append(' ');\n      buf.append(\"attributes\").append('=').append(JodaBeanUtils.toString(attributes));\n      buf.append('}');\n      return buf.toString();\n    }\n  }\n  //-------------------------- AUTOGENERATED END --------------------------\n"]]}
{"hexsha": "bcd8fd4fb52bfe540c2022c05c1ed53ca81ebdeb", "ext": "java", "lang": "Java", "content": "public class GallopingSearchJava {\n  public static int find(ColumnVector values, int key, int start, int end) {\n    assert (end != 0);\n    assert (start < end);\n\n    int bound = Math.max(start, 1);\n    while (bound < end && values.getInt(bound) < key) {\n      bound *= 2;\n    }\n    return binarySearch(values, key, Math.max(start, bound / 2), Math.min(bound + 1, end));\n  }\n\n  public static int binarySearch(ColumnVector vector, int key, int start, int end) {\n    assert (0 <= start);\n    assert (start < end);\n\n    int L = start;\n    int R = end;\n    while (L < R) {\n      int M = (L + R) / 2;\n      if (vector.getInt(M) < key) {\n        L = M + 1;\n      } else if (vector.getInt(M) > key) {\n        R = M - 1;\n      } else {\n        while (start < M && vector.getInt(M - 1) == key) {\n          M -= 1;\n        }\n        return M;\n      }\n    }\n    while (start < L && vector.getInt(L - 1) == key) {\n      L -= 1;\n    }\n\n    return Math.min((L < end && vector.getInt(L) < key) ? L + 1 : L, end);\n  }\n}", "class_id": 0, "repo": "PerFuchs/edge-frames", "file": "src/main/scala/leapfrogTriejoin/GallopingSearchJava.java", "last_update_at": "2020-12-15T12:20:51+00:00", "question_id": "bcd8fd4fb52bfe540c2022c05c1ed53ca81ebdeb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GallopingSearchJava {\n  public static int find(ColumnVector values, int key, int start, int end) {\n    assert (end != 0);\n    assert (start < end);\n    int bound = Math.max(start, 1);\n    while (bound < end && values.getInt(bound) < key) {\n      bound *= 2;\n    }\n    return binarySearch(values, key, Math.max(start, bound / 2), Math.min(bound + 1, end));\n  }\n  public static int binarySearch(ColumnVector vector, int key, int start, int end) {\n    assert (0 <= start);\n    assert (start < end);\n    int L = start;\n    int R = end;\n    while (L < R) {\n      int M = (L + R) / 2;\n      if (vector.getInt(M) < key) {\n        L = M + 1;\n      } else if (vector.getInt(M) > key) {\n        R = M - 1;\n      } else {\n        while (start < M && vector.getInt(M - 1) == key) {\n          M -= 1;\n        }\n        return M;\n      }\n    }\n    while (start < L && vector.getInt(L - 1) == key) {\n      L -= 1;\n    }\n    return Math.min((L < end && vector.getInt(L) < key) ? L + 1 : L, end);\n  }\n"]]}
{"hexsha": "bbd7840f29894d8dba6056ef50d3f0feaa82da43", "ext": "java", "lang": "Java", "content": "public class IoVsNio {\n\n    public static void main(String[] args) throws Exception {\n        File file = new File(\"C:\\\\Users\\\\leoca\\\\AppData\\\\Local\\\\Temp\\\\io-vs-nio5577439411617059014.data\");\n        createFile(25);\n        System.out.println(file.getAbsolutePath());\n        //  withNio(file);\n        withIO(file);\n        // withNio(file);\n\n\n    }\n\n    public static File createFile(final long sizeInMB) {\n        File file = null;\n        try {\n            file = File.createTempFile(\"io-vs-nio\", \".data\");\n            file.createNewFile();\n\n            RandomAccessFile raf = new RandomAccessFile(file, \"rw\");\n            raf.setLength(sizeInMB * 100000000);\n            raf.close();\n\n            return file;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static long withIO(File origin) throws Exception {\n        File destination = new File(origin.getAbsolutePath() + \".io-\" + UUID.randomUUID());\n        long time1 = System.currentTimeMillis();\n        InputStream is = new FileInputStream(origin);\n        FileOutputStream fos = new FileOutputStream(destination);\n        byte[] buf = new byte[64 * 1024];\n        int len = 0;\n        while ((len = is.read(buf)) != -1) {\n            fos.write(buf, 0, len);\n        }\n        fos.flush();\n        fos.close();\n        is.close();\n        long time2 = System.currentTimeMillis();\n        System.out.println(\"Time taken: \" + (time2 - time1) + \" ms with IO\");\n        destination.delete();\n        return time2 - time1;\n\n    }\n\n    public static long withNio(File origin) throws Exception {\n        File destination = new File(origin.getAbsolutePath() + \".nio\" + UUID.randomUUID());\n        long time1 = System.currentTimeMillis();\n        FileInputStream is = new FileInputStream(origin);\n        FileOutputStream fos = new FileOutputStream(destination);\n        FileChannel f = is.getChannel();\n        FileChannel f2 = fos.getChannel();\n        ByteBuffer buf = ByteBuffer.allocateDirect(64 * 1024);\n        long len = 0;\n        while ((len = f.read(buf)) != -1) {\n            buf.flip();\n            f2.write(buf);\n            buf.clear();\n        }\n        f2.close();\n        f.close();\n        long time2 = System.currentTimeMillis();\n        System.out.println(\"Time taken: \" + (time2 - time1) + \" ms with NIO\");\n        destination.delete();\n        return time2 - time1;\n    }\n\n}", "class_id": 0, "repo": "leocamachocr/java-examples", "file": "files-channel/src/main/java/com/leoc/file/comparison/IoVsNio.java", "last_update_at": "2020-05-29T01:57:47+00:00", "question_id": "bbd7840f29894d8dba6056ef50d3f0feaa82da43", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class IoVsNio {\n    public static void main(String[] args) throws Exception {\n        File file = new File(\"C:\\\\Users\\\\leoca\\\\AppData\\\\Local\\\\Temp\\\\io-vs-nio5577439411617059014.data\");\n        createFile(25);\n        System.out.println(file.getAbsolutePath());\n        //  withNio(file);\n        withIO(file);\n        // withNio(file);\n    }\n    public static File createFile(final long sizeInMB) {\n        File file = null;\n        try {\n            file = File.createTempFile(\"io-vs-nio\", \".data\");\n            file.createNewFile();\n            RandomAccessFile raf = new RandomAccessFile(file, \"rw\");\n            raf.setLength(sizeInMB * 100000000);\n            raf.close();\n            return file;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n    public static long withIO(File origin) throws Exception {\n        File destination = new File(origin.getAbsolutePath() + \".io-\" + UUID.randomUUID());\n        long time1 = System.currentTimeMillis();\n        InputStream is = new FileInputStream(origin);\n        FileOutputStream fos = new FileOutputStream(destination);\n        byte[] buf = new byte[64 * 1024];\n        int len = 0;\n        while ((len = is.read(buf)) != -1) {\n            fos.write(buf, 0, len);\n        }\n        fos.flush();\n        fos.close();\n        is.close();\n        long time2 = System.currentTimeMillis();\n        System.out.println(\"Time taken: \" + (time2 - time1) + \" ms with IO\");\n        destination.delete();\n        return time2 - time1;\n    }\n    public static long withNio(File origin) throws Exception {\n        File destination = new File(origin.getAbsolutePath() + \".nio\" + UUID.randomUUID());\n        long time1 = System.currentTimeMillis();\n        FileInputStream is = new FileInputStream(origin);\n        FileOutputStream fos = new FileOutputStream(destination);\n        FileChannel f = is.getChannel();\n        FileChannel f2 = fos.getChannel();\n        ByteBuffer buf = ByteBuffer.allocateDirect(64 * 1024);\n        long len = 0;\n        while ((len = f.read(buf)) != -1) {\n            buf.flip();\n            f2.write(buf);\n            buf.clear();\n        }\n        f2.close();\n        f.close();\n        long time2 = System.currentTimeMillis();\n        System.out.println(\"Time taken: \" + (time2 - time1) + \" ms with NIO\");\n        destination.delete();\n        return time2 - time1;\n    }\n"]]}
{"hexsha": "64f987239e854877551ba53d4c5929dcd3af5657", "ext": "java", "lang": "Java", "content": "@RunWith(JUnit4.class)\n@SmallTest\npublic class LoaderObserverTest {\n\n    @Test\n    public void testOnChanged() {\n        ImmediateLoaderCallbacks callback = new ImmediateLoaderCallbacks(mock(Context.class));\n        @SuppressWarnings(\"unchecked\")\n        LoaderManagerImpl.LoaderObserver<Boolean> observer = new LoaderManagerImpl.LoaderObserver<>(\n                mock(Loader.class), callback);\n        assertFalse(\"LoaderObserver should not have delivered data before onChanged\",\n                observer.hasDeliveredData());\n        assertFalse(\"onLoadFinished should not be called before onChanged\",\n                callback.mOnLoadFinished);\n\n\n        observer.onChanged(true);\n        assertTrue(\"LoaderObserver should have delivered data after onChanged\",\n                observer.hasDeliveredData());\n        assertTrue(\"onLoadFinished should be called after onChanged\",\n                callback.mOnLoadFinished);\n    }\n\n    @Test\n    public void testReset() {\n        ImmediateLoaderCallbacks callback = new ImmediateLoaderCallbacks(mock(Context.class));\n        @SuppressWarnings(\"unchecked\")\n        LoaderManagerImpl.LoaderObserver<Boolean> observer = new LoaderManagerImpl.LoaderObserver<>(\n                mock(Loader.class), callback);\n        assertFalse(\"onLoaderReset shouldn't be called before onChanged+reset\",\n                callback.mOnLoaderReset);\n\n        observer.reset();\n        assertFalse(\"onLoaderReset should not be called after only reset\",\n                callback.mOnLoaderReset);\n    }\n\n    @Test\n    public void testResetWithOnChanged() {\n        ImmediateLoaderCallbacks callback = new ImmediateLoaderCallbacks(mock(Context.class));\n        @SuppressWarnings(\"unchecked\")\n        LoaderManagerImpl.LoaderObserver<Boolean> observer = new LoaderManagerImpl.LoaderObserver<>(\n                mock(Loader.class), callback);\n        assertFalse(\"onLoaderReset shouldn't be called before onChanged+reset\",\n                callback.mOnLoaderReset);\n\n        observer.onChanged(true);\n        observer.reset();\n        assertTrue(\"onLoaderReset should be called after onChanged+reset\",\n                callback.mOnLoaderReset);\n    }\n}", "class_id": 0, "repo": "digitalbuddha/androidx", "file": "loader/loader/src/androidTest/java/androidx/loader/app/LoaderObserverTest.java", "last_update_at": "2020-09-06T20:07:54+00:00", "question_id": "64f987239e854877551ba53d4c5929dcd3af5657", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(JUnit4.class)\n@SmallTest\npublic class LoaderObserverTest {\n    @Test\n    public void testOnChanged() {\n        ImmediateLoaderCallbacks callback = new ImmediateLoaderCallbacks(mock(Context.class));\n        @SuppressWarnings(\"unchecked\")\n        LoaderManagerImpl.LoaderObserver<Boolean> observer = new LoaderManagerImpl.LoaderObserver<>(\n                mock(Loader.class), callback);\n        assertFalse(\"LoaderObserver should not have delivered data before onChanged\",\n                observer.hasDeliveredData());\n        assertFalse(\"onLoadFinished should not be called before onChanged\",\n                callback.mOnLoadFinished);\n        observer.onChanged(true);\n        assertTrue(\"LoaderObserver should have delivered data after onChanged\",\n                observer.hasDeliveredData());\n        assertTrue(\"onLoadFinished should be called after onChanged\",\n                callback.mOnLoadFinished);\n    }\n    @Test\n    public void testReset() {\n        ImmediateLoaderCallbacks callback = new ImmediateLoaderCallbacks(mock(Context.class));\n        @SuppressWarnings(\"unchecked\")\n        LoaderManagerImpl.LoaderObserver<Boolean> observer = new LoaderManagerImpl.LoaderObserver<>(\n                mock(Loader.class), callback);\n        assertFalse(\"onLoaderReset shouldn't be called before onChanged+reset\",\n                callback.mOnLoaderReset);\n        observer.reset();\n        assertFalse(\"onLoaderReset should not be called after only reset\",\n                callback.mOnLoaderReset);\n    }\n    @Test\n    public void testResetWithOnChanged() {\n        ImmediateLoaderCallbacks callback = new ImmediateLoaderCallbacks(mock(Context.class));\n        @SuppressWarnings(\"unchecked\")\n        LoaderManagerImpl.LoaderObserver<Boolean> observer = new LoaderManagerImpl.LoaderObserver<>(\n                mock(Loader.class), callback);\n        assertFalse(\"onLoaderReset shouldn't be called before onChanged+reset\",\n                callback.mOnLoaderReset);\n        observer.onChanged(true);\n        observer.reset();\n        assertTrue(\"onLoaderReset should be called after onChanged+reset\",\n                callback.mOnLoaderReset);\n    }\n"]]}
{"hexsha": "ff680b66ce6919d62f4c73c63911436bef7a4a17", "ext": "java", "lang": "Java", "content": "public class DecimalToHex {\n  public static String toHex(int number) {\n    char[] hexTable = {\n      '0', '1', '2', '3',\n      '4', '5', '6', '7',\n      '8', '9', 'a', 'b',\n      'c', 'd', 'e', 'f'\n    };\n\n    boolean isNegative = number < 0;\n    number = Math.abs(number);\n    StringBuilder result = new StringBuilder();\n    do {\n      result.append(hexTable[number % 16]);\n      number /= 16;\n    } while (number != 0);\n    return isNegative ? result.append(\"-\").reverse().toString() : result.reverse().toString();\n  }\n}", "class_id": 0, "repo": "letscode-17/Java", "file": "src/main/java/com/examplehub/conversions/DecimalToHex.java", "last_update_at": "2020-12-14T03:41:58+00:00", "question_id": "ff680b66ce6919d62f4c73c63911436bef7a4a17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DecimalToHex {\n  public static String toHex(int number) {\n    char[] hexTable = {\n      '0', '1', '2', '3',\n      '4', '5', '6', '7',\n      '8', '9', 'a', 'b',\n      'c', 'd', 'e', 'f'\n    };\n    boolean isNegative = number < 0;\n    number = Math.abs(number);\n    StringBuilder result = new StringBuilder();\n    do {\n      result.append(hexTable[number % 16]);\n      number /= 16;\n    } while (number != 0);\n    return isNegative ? result.append(\"-\").reverse().toString() : result.reverse().toString();\n  }\n"]]}
{"hexsha": "e5550e0714b6404f6bbb5089cfab0cd14305c35a", "ext": "java", "lang": "Java", "content": "@Service\n@RequiredArgsConstructor\npublic class PollNodeServiceImpl implements PollNodeService {\n\n    private final PollNodeRepository pollNodeRepository;\n\n    @Override\n    @NotNullArgs\n    public PollNode create(PollNode node) {\n        return pollNodeRepository.save(node);\n    }\n\n    @Override\n    public PollNode update(PollNode node) {\n        if (node.getId() == null) {\n            throw new ReckueIllegalArgumentException(\"The parameter is null\");\n        }\n        PollNode savedPollNode = pollNodeRepository\n                .findById(node.getId())\n                .orElseThrow(() -> new PollNodeNotFoundException(node.getId()));\n        savedPollNode.setTitle(node.getTitle());\n        savedPollNode.setItems(node.getItems());\n        return pollNodeRepository.save(savedPollNode);\n    }\n\n    @Override\n    public List<PollNode> findAll() {\n        return pollNodeRepository.findAll();\n    }\n\n    @Override\n    public List<PollNode> findAll(Integer limit, Integer offset, String sort, Boolean desc) {\n        if (limit == null) limit = 10;\n        if (offset == null) offset = 0;\n        if (StringUtils.isEmpty(sort)) sort = \"id\";\n        if (desc == null) desc = false;\n\n        if (limit < 0 || offset < 0) {\n            throw new ReckueIllegalArgumentException(\"Limit or offset is incorrect\");\n        }\n        return findAllByTypeAndDesc(sort, desc).stream()\n                .limit(limit)\n                .skip(offset)\n                .collect(Collectors.toList());\n    }\n\n    public List<PollNode> findAllByTypeAndDesc(String sort, boolean desc) {\n        if (desc) {\n            List<PollNode> node = findAllBySortType(sort);\n            Collections.reverse(node);\n            return node;\n        }\n        return findAllBySortType(sort);\n    }\n\n    public List<PollNode> findAllBySortType(String sort) {\n\n        switch (sort) {\n            case \"title\":\n                return findAllAndSortByTitle();\n            case \"id\":\n                return findAllAndSortById();\n        }\n        throw new ReckueIllegalArgumentException(\"Such field as \" + sort + \" doesn't exist\");\n    }\n\n    public List<PollNode> findAllAndSortById() {\n        return findAll().stream()\n                .sorted(Comparator.comparing(PollNode::getId))\n                .collect(Collectors.toList());\n    }\n\n    public List<PollNode> findAllAndSortByTitle() {\n        return findAll().stream()\n                .sorted(Comparator.comparing(PollNode::getTitle))\n                .collect(Collectors.toList());\n    }\n\n    @Override\n    public PollNode findById(String id) {\n        return pollNodeRepository.findById(id).orElseThrow(\n                () -> new PollNodeNotFoundException(id));\n    }\n\n    @Override\n    public void deleteById(String id) {\n        if (pollNodeRepository.existsById(id)) {\n            pollNodeRepository.deleteById(id);\n        } else {\n            throw new PollNodeNotFoundException(id);\n        }\n    }\n}", "class_id": 0, "repo": "reckue/note-api", "file": "src/main/java/com/reckue/post/service/impl/PollNodeServiceImpl.java", "last_update_at": "2020-07-13T09:28:32+00:00", "question_id": "e5550e0714b6404f6bbb5089cfab0cd14305c35a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\n@RequiredArgsConstructor\npublic class PollNodeServiceImpl implements PollNodeService {\n    private final PollNodeRepository pollNodeRepository;\n    @Override\n    @NotNullArgs\n    public PollNode create(PollNode node) {\n        return pollNodeRepository.save(node);\n    }\n    @Override\n    public PollNode update(PollNode node) {\n        if (node.getId() == null) {\n            throw new ReckueIllegalArgumentException(\"The parameter is null\");\n        }\n        PollNode savedPollNode = pollNodeRepository\n                .findById(node.getId())\n                .orElseThrow(() -> new PollNodeNotFoundException(node.getId()));\n        savedPollNode.setTitle(node.getTitle());\n        savedPollNode.setItems(node.getItems());\n        return pollNodeRepository.save(savedPollNode);\n    }\n    @Override\n    public List<PollNode> findAll() {\n        return pollNodeRepository.findAll();\n    }\n    @Override\n    public List<PollNode> findAll(Integer limit, Integer offset, String sort, Boolean desc) {\n        if (limit == null) limit = 10;\n        if (offset == null) offset = 0;\n        if (StringUtils.isEmpty(sort)) sort = \"id\";\n        if (desc == null) desc = false;\n        if (limit < 0 || offset < 0) {\n            throw new ReckueIllegalArgumentException(\"Limit or offset is incorrect\");\n        }\n        return findAllByTypeAndDesc(sort, desc).stream()\n                .limit(limit)\n                .skip(offset)\n                .collect(Collectors.toList());\n    }\n    public List<PollNode> findAllByTypeAndDesc(String sort, boolean desc) {\n        if (desc) {\n            List<PollNode> node = findAllBySortType(sort);\n            Collections.reverse(node);\n            return node;\n        }\n        return findAllBySortType(sort);\n    }\n    public List<PollNode> findAllBySortType(String sort) {\n        switch (sort) {\n            case \"title\":\n                return findAllAndSortByTitle();\n            case \"id\":\n                return findAllAndSortById();\n        }\n        throw new ReckueIllegalArgumentException(\"Such field as \" + sort + \" doesn't exist\");\n    }\n    public List<PollNode> findAllAndSortById() {\n        return findAll().stream()\n                .sorted(Comparator.comparing(PollNode::getId))\n                .collect(Collectors.toList());\n    }\n    public List<PollNode> findAllAndSortByTitle() {\n        return findAll().stream()\n                .sorted(Comparator.comparing(PollNode::getTitle))\n                .collect(Collectors.toList());\n    }\n    @Override\n    public PollNode findById(String id) {\n        return pollNodeRepository.findById(id).orElseThrow(\n                () -> new PollNodeNotFoundException(id));\n    }\n    @Override\n    public void deleteById(String id) {\n        if (pollNodeRepository.existsById(id)) {\n            pollNodeRepository.deleteById(id);\n        } else {\n            throw new PollNodeNotFoundException(id);\n        }\n    }\n"]]}
{"hexsha": "67a3303bc899ae4afeabcaafcc90982e3bf6fa50", "ext": "java", "lang": "Java", "content": "public class RepositoryUtils<T> {\n\n    private BaseRepository<T, Long> repository;\n\n    public RepositoryUtils(BaseRepository<T, Long> repository) {\n        this.repository = repository;\n    }\n\n    public static<T> RepositoryUtils<T> getInstance(BaseRepository<T, Long> repository) {\n        return new RepositoryUtils<>(repository);\n    }\n\n    public T one(long id) {\n        return this.repository.findById(id).orElse(null);\n    }\n\n    public long count(Specification<T> specification) {\n        return this.repository.count(specification);\n    }\n\n    public List<T> list(Specification<T> specification) {\n        return this.repository.findAll(specification);\n    }\n\n    public List<T> list(Specification<T> specification, Sort sort) {\n        return this.repository.findAll(specification, sort);\n    }\n\n    public ListResponse<T> listResponse(Specification<T> specification) {\n        ListResponse<T> response = new ListResponse<>();\n        response.setList(list(specification));\n        return response;\n    }\n}", "class_id": 0, "repo": "oldlie/xmy", "file": "src/main/java/com/oldlie/health/medicalappointment/util/RepositoryUtils.java", "last_update_at": "2020-10-08T10:05:19+00:00", "question_id": "67a3303bc899ae4afeabcaafcc90982e3bf6fa50", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RepositoryUtils<T> {\n    private BaseRepository<T, Long> repository;\n    public RepositoryUtils(BaseRepository<T, Long> repository) {\n        this.repository = repository;\n    }\n    public static<T> RepositoryUtils<T> getInstance(BaseRepository<T, Long> repository) {\n        return new RepositoryUtils<>(repository);\n    }\n    public T one(long id) {\n        return this.repository.findById(id).orElse(null);\n    }\n    public long count(Specification<T> specification) {\n        return this.repository.count(specification);\n    }\n    public List<T> list(Specification<T> specification) {\n        return this.repository.findAll(specification);\n    }\n    public List<T> list(Specification<T> specification, Sort sort) {\n        return this.repository.findAll(specification, sort);\n    }\n    public ListResponse<T> listResponse(Specification<T> specification) {\n        ListResponse<T> response = new ListResponse<>();\n        response.setList(list(specification));\n        return response;\n    }\n"]]}
{"hexsha": "c2de2df13e6f0b3d046af53e90c838e39b8fba77", "ext": "java", "lang": "Java", "content": "@SuppressWarnings({\"unchecked\"})\npublic class TestDistortImageOps {\n\n\tRandom rand = new Random(234);\n\tint width = 20;\n\tint height = 30;\n\n\t/**\n\t * Checks to see if the two ways of specifying interpolation work\n\t */\n\t@Test\n\tpublic void scale_InterpTypeStyle() {\n\t\tGrayF32 input = new GrayF32(width,height);\n\t\tGrayF32 output = new GrayF32(width,height);\n\n\t\tGImageMiscOps.fillUniform(input, rand, 0, 100);\n\n\t\tDistortImageOps.scale(input,output, BorderType.ZERO, InterpolationType.BILINEAR);\n\n\t\tInterpolatePixelS<GrayF32> interp = FactoryInterpolation.bilinearPixelS(input, BorderType.EXTENDED);\n\t\tinterp.setImage(input);\n\n\t\tfloat scaleX = (float)input.width/(float)output.width;\n\t\tfloat scaleY = (float)input.height/(float)output.height;\n\n\t\tif( input.getDataType().isInteger() ) {\n\t\t\tfor( int i = 0; i < output.height; i++ ) {\n\t\t\t\tfor( int j = 0; j < output.width; j++ ) {\n\t\t\t\t\tfloat val = interp.get(j*scaleX,i*scaleY);\n\t\t\t\t\tassertEquals((int)val,output.get(j,i),1e-4);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor( int i = 0; i < output.height; i++ ) {\n\t\t\t\tfor( int j = 0; j < output.width; j++ ) {\n\t\t\t\t\tfloat val = interp.get(j*scaleX,i*scaleY);\n\t\t\t\t\tassertEquals(val,output.get(j,i),1e-4);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Very simple test for rotation accuracy.\n\t */\n\t@Test\n\tpublic void rotate_SanityCheck() {\n\t\tGrayF32 input = new GrayF32(width,height);\n\t\tGrayF32 output = new GrayF32(height,width);\n\n\t\tGImageMiscOps.fillUniform(input, rand, 0, 100);\n\n\t\tDistortImageOps.rotate(input, output,BorderType.ZERO, InterpolationType.BILINEAR, (float) Math.PI / 2f);\n\n\t\tdouble error = 0;\n\t\t// the outside pixels are ignored because numerical round off can cause those to be skipped\n\t\tfor( int y = 1; y < input.height-1; y++ ) {\n\t\t\tfor( int x = 1; x < input.width-1; x++ ) {\n\t\t\t\tint xx = output.width-y;\n\t\t\t\tint yy = x;\n\n\t\t\t\tdouble e = input.get(x,y)-output.get(xx,yy);\n\t\t\t\terror += Math.abs(e);\n\t\t\t}\n\t\t}\n\t\tassertTrue(error / (width * height) < 0.1);\n\t}\n\n\t/**\n\t * boundBox that checks to see if it is contained inside the output image.\n\t */\n\t@Test\n\tpublic void boundBox_check() {\n\n\t\t// basic sanity check\n\t\tAffine2D_F32 affine = new Affine2D_F32(1,0,0,1,2,3);\n\t\tPixelTransformAffine_F32 transform = new PixelTransformAffine_F32(affine);\n\t\tRectangleLength2D_I32 found = DistortImageOps.boundBox(10,20,30,40,transform);\n\t\t\n\t\tassertEquals(2,found.x0);\n\t\tassertEquals(3,found.y0);\n\t\tassertEquals(10,found.width);\n\t\tassertEquals(20,found.height);\n\t\t\n\t\t// bottom right border\n\t\tfound = DistortImageOps.boundBox(10,20,8,18,transform);\n\t\tassertEquals(2,found.x0);\n\t\tassertEquals(3,found.y0);\n\t\tassertEquals(6,found.width);\n\t\tassertEquals(15,found.height);\n\t\t\n\t\t// top right border\n\t\taffine.set(new Affine2D_F32(1,0,0,1,-2,-3));\n\t\tfound = DistortImageOps.boundBox(10,20,8,18,transform);\n\t\tassertEquals(0,found.x0);\n\t\tassertEquals(0,found.y0);\n\t\tassertEquals(8,found.width);\n\t\tassertEquals(17,found.height);\n\t}\n\n\t@Test\n\tpublic void boundBox() {\n\n\t\t// basic sanity check\n\t\tAffine2D_F32 affine = new Affine2D_F32(1,0,0,1,2,3);\n\t\tPixelTransformAffine_F32 transform = new PixelTransformAffine_F32(affine);\n\t\tRectangleLength2D_I32 found = DistortImageOps.boundBox(10,20,transform);\n\n\t\tassertEquals(2,found.x0);\n\t\tassertEquals(3,found.y0);\n\t\tassertEquals(10,found.width);\n\t\tassertEquals(20,found.height);\n\t}\n\n\t@Test\n\tpublic void boundBox_F32() {\n\n\t\t// basic sanity check\n\t\tAffine2D_F32 affine = new Affine2D_F32(1,0,0,1,2,3);\n\t\tPixelTransformAffine_F32 transform = new PixelTransformAffine_F32(affine);\n\t\tRectangleLength2D_F32 found = DistortImageOps.boundBox_F32(10,20,transform);\n\n\t\tassertEquals(2,found.x0,1e-4);\n\t\tassertEquals(3,found.y0,1e-4);\n\t\tassertEquals(10,found.width,1e-4);\n\t\tassertEquals(20,found.height,1e-4);\n\t}\n\n\t@Test\n\tpublic void boundBox_F64() {\n\t\t// basic sanity check\n\t\tAffine2D_F64 affine = new Affine2D_F64(1,0,0,1,2,3);\n\t\tPixelTransformAffine_F64 transform = new PixelTransformAffine_F64(affine);\n\t\tRectangleLength2D_F64 found = DistortImageOps.boundBox_F64(10, 20, transform);\n\n\t\tassertEquals(2,found.x0,1e-8);\n\t\tassertEquals(3,found.y0,1e-8);\n\t\tassertEquals(10,found.width,1e-8);\n\t\tassertEquals(20,found.height,1e-8);\n\t}\n}", "class_id": 0, "repo": "yannickhildebrandt/BoofCV", "file": "main/boofcv-ip/test/boofcv/alg/distort/TestDistortImageOps.java", "last_update_at": "2020-02-02T00:17:35+00:00", "question_id": "c2de2df13e6f0b3d046af53e90c838e39b8fba77", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings({\"unchecked\"})\npublic class TestDistortImageOps {\n\tRandom rand = new Random(234);\n\tint width = 20;\n\tint height = 30;\n\t/**\n\t * Checks to see if the two ways of specifying interpolation work\n\t */\n\t@Test\n\tpublic void scale_InterpTypeStyle() {\n\t\tGrayF32 input = new GrayF32(width,height);\n\t\tGrayF32 output = new GrayF32(width,height);\n\t\tGImageMiscOps.fillUniform(input, rand, 0, 100);\n\t\tDistortImageOps.scale(input,output, BorderType.ZERO, InterpolationType.BILINEAR);\n\t\tInterpolatePixelS<GrayF32> interp = FactoryInterpolation.bilinearPixelS(input, BorderType.EXTENDED);\n\t\tinterp.setImage(input);\n\t\tfloat scaleX = (float)input.width/(float)output.width;\n\t\tfloat scaleY = (float)input.height/(float)output.height;\n\t\tif( input.getDataType().isInteger() ) {\n\t\t\tfor( int i = 0; i < output.height; i++ ) {\n\t\t\t\tfor( int j = 0; j < output.width; j++ ) {\n\t\t\t\t\tfloat val = interp.get(j*scaleX,i*scaleY);\n\t\t\t\t\tassertEquals((int)val,output.get(j,i),1e-4);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor( int i = 0; i < output.height; i++ ) {\n\t\t\t\tfor( int j = 0; j < output.width; j++ ) {\n\t\t\t\t\tfloat val = interp.get(j*scaleX,i*scaleY);\n\t\t\t\t\tassertEquals(val,output.get(j,i),1e-4);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Very simple test for rotation accuracy.\n\t */\n\t@Test\n\tpublic void rotate_SanityCheck() {\n\t\tGrayF32 input = new GrayF32(width,height);\n\t\tGrayF32 output = new GrayF32(height,width);\n\t\tGImageMiscOps.fillUniform(input, rand, 0, 100);\n\t\tDistortImageOps.rotate(input, output,BorderType.ZERO, InterpolationType.BILINEAR, (float) Math.PI / 2f);\n\t\tdouble error = 0;\n\t\t// the outside pixels are ignored because numerical round off can cause those to be skipped\n\t\tfor( int y = 1; y < input.height-1; y++ ) {\n\t\t\tfor( int x = 1; x < input.width-1; x++ ) {\n\t\t\t\tint xx = output.width-y;\n\t\t\t\tint yy = x;\n\t\t\t\tdouble e = input.get(x,y)-output.get(xx,yy);\n\t\t\t\terror += Math.abs(e);\n\t\t\t}\n\t\t}\n\t\tassertTrue(error / (width * height) < 0.1);\n\t}\n\t/**\n\t * boundBox that checks to see if it is contained inside the output image.\n\t */\n\t@Test\n\tpublic void boundBox_check() {\n\t\t// basic sanity check\n\t\tAffine2D_F32 affine = new Affine2D_F32(1,0,0,1,2,3);\n\t\tPixelTransformAffine_F32 transform = new PixelTransformAffine_F32(affine);\n\t\tRectangleLength2D_I32 found = DistortImageOps.boundBox(10,20,30,40,transform);\n\t\t\n\t\tassertEquals(2,found.x0);\n\t\tassertEquals(3,found.y0);\n\t\tassertEquals(10,found.width);\n\t\tassertEquals(20,found.height);\n\t\t\n\t\t// bottom right border\n\t\tfound = DistortImageOps.boundBox(10,20,8,18,transform);\n\t\tassertEquals(2,found.x0);\n\t\tassertEquals(3,found.y0);\n\t\tassertEquals(6,found.width);\n\t\tassertEquals(15,found.height);\n\t\t\n\t\t// top right border\n\t\taffine.set(new Affine2D_F32(1,0,0,1,-2,-3));\n\t\tfound = DistortImageOps.boundBox(10,20,8,18,transform);\n\t\tassertEquals(0,found.x0);\n\t\tassertEquals(0,found.y0);\n\t\tassertEquals(8,found.width);\n\t\tassertEquals(17,found.height);\n\t}\n\t@Test\n\tpublic void boundBox() {\n\t\t// basic sanity check\n\t\tAffine2D_F32 affine = new Affine2D_F32(1,0,0,1,2,3);\n\t\tPixelTransformAffine_F32 transform = new PixelTransformAffine_F32(affine);\n\t\tRectangleLength2D_I32 found = DistortImageOps.boundBox(10,20,transform);\n\t\tassertEquals(2,found.x0);\n\t\tassertEquals(3,found.y0);\n\t\tassertEquals(10,found.width);\n\t\tassertEquals(20,found.height);\n\t}\n\t@Test\n\tpublic void boundBox_F32() {\n\t\t// basic sanity check\n\t\tAffine2D_F32 affine = new Affine2D_F32(1,0,0,1,2,3);\n\t\tPixelTransformAffine_F32 transform = new PixelTransformAffine_F32(affine);\n\t\tRectangleLength2D_F32 found = DistortImageOps.boundBox_F32(10,20,transform);\n\t\tassertEquals(2,found.x0,1e-4);\n\t\tassertEquals(3,found.y0,1e-4);\n\t\tassertEquals(10,found.width,1e-4);\n\t\tassertEquals(20,found.height,1e-4);\n\t}\n\t@Test\n\tpublic void boundBox_F64() {\n\t\t// basic sanity check\n\t\tAffine2D_F64 affine = new Affine2D_F64(1,0,0,1,2,3);\n\t\tPixelTransformAffine_F64 transform = new PixelTransformAffine_F64(affine);\n\t\tRectangleLength2D_F64 found = DistortImageOps.boundBox_F64(10, 20, transform);\n\t\tassertEquals(2,found.x0,1e-8);\n\t\tassertEquals(3,found.y0,1e-8);\n\t\tassertEquals(10,found.width,1e-8);\n\t\tassertEquals(20,found.height,1e-8);\n\t}\n"]]}
{"hexsha": "4b65791b0251df886f359e813fc44c5bbe5cbe52", "ext": "java", "lang": "Java", "content": "public class Intersect\n{\n    private static HashMap<String,ArrayList<String>> rules;\n    private static boolean ignoreNTs;\n    public static void main(String [] argv) throws Exception\n    {\n        String file1;\n        String file2;\n        String outputPrefix;\n        if (argv[0].equals(\"-X\")) {\n            file1 = argv[1];\n            file2 = argv[2];\n            outputPrefix = argv[3];\n            ignoreNTs = true;\n        }\n        else {\n            file1 = argv[0];\n            file2 = argv[1];\n            outputPrefix = argv[2];\n            ignoreNTs = false;\n        }\n        getRulesFromFile(file1);\n\n        Scanner scanner;\n        if (file2.endsWith(\".gz\"))\n            scanner = new Scanner(new GZIPInputStream(new FileInputStream(new File(file2))), \"UTF-8\");\n        else\n            scanner = new Scanner(new File(file2), \"UTF-8\");\n        PrintStream firstGrammar = new PrintStream(new FileOutputStream(outputPrefix + \".1\"));\n        PrintStream secondGrammar = new PrintStream(new FileOutputStream(outputPrefix + \".2\"));\n        while (scanner.hasNextLine()) {\n            String s = scanner.nextLine();\n            String r = repr(s);\n            if (rules.containsKey(r)) {\n                secondGrammar.println(s);\n                for (String x : rules.get(r))\n                    firstGrammar.println(x);\n                rules.get(r).clear();\n            }\n        }\n        scanner.close();\n        firstGrammar.close();\n        secondGrammar.close();\n        return;\n    }\n\n    private static String repr(String s)\n    {\n        String r = s.substring(0, s.lastIndexOf(\"|||\"));\n        if (ignoreNTs) \n            r = r.replaceAll(\"\\\\[[^]]+?\\\\]\", \"[X]\");\n        return r;\n    }\n\n    private static void getRulesFromFile(String filename) throws IOException\n    {\n        rules = new HashMap<String,ArrayList<String>>();\n        Scanner scanner;\n        if (filename.endsWith(\".gz\")) {\n            scanner = new Scanner(new GZIPInputStream(new FileInputStream(new File(filename))), \"UTF-8\");\n        }\n        else {\n            scanner = new Scanner(new File(filename), \"UTF-8\");\n        }\n        while (scanner.hasNextLine()) {\n            String s = scanner.nextLine();\n            String r = repr(s);\n            if (rules.containsKey(r))\n                rules.get(r).add(s);\n            else {\n                ArrayList<String> al = new ArrayList<String>();\n                al.add(s);\n                rules.put(r, al);\n            }\n        }\n        scanner.close();\n        return;\n    }\n}", "class_id": 0, "repo": "jweese/thrax", "file": "src/edu/jhu/thrax/util/Intersect.java", "last_update_at": "2020-11-11T02:46:11+00:00", "question_id": "4b65791b0251df886f359e813fc44c5bbe5cbe52", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Intersect\n{\n    private static HashMap<String,ArrayList<String>> rules;\n    private static boolean ignoreNTs;\n    public static void main(String [] argv) throws Exception\n    {\n        String file1;\n        String file2;\n        String outputPrefix;\n        if (argv[0].equals(\"-X\")) {\n            file1 = argv[1];\n            file2 = argv[2];\n            outputPrefix = argv[3];\n            ignoreNTs = true;\n        }\n        else {\n            file1 = argv[0];\n            file2 = argv[1];\n            outputPrefix = argv[2];\n            ignoreNTs = false;\n        }\n        getRulesFromFile(file1);\n        Scanner scanner;\n        if (file2.endsWith(\".gz\"))\n            scanner = new Scanner(new GZIPInputStream(new FileInputStream(new File(file2))), \"UTF-8\");\n        else\n            scanner = new Scanner(new File(file2), \"UTF-8\");\n        PrintStream firstGrammar = new PrintStream(new FileOutputStream(outputPrefix + \".1\"));\n        PrintStream secondGrammar = new PrintStream(new FileOutputStream(outputPrefix + \".2\"));\n        while (scanner.hasNextLine()) {\n            String s = scanner.nextLine();\n            String r = repr(s);\n            if (rules.containsKey(r)) {\n                secondGrammar.println(s);\n                for (String x : rules.get(r))\n                    firstGrammar.println(x);\n                rules.get(r).clear();\n            }\n        }\n        scanner.close();\n        firstGrammar.close();\n        secondGrammar.close();\n        return;\n    }\n    private static String repr(String s)\n    {\n        String r = s.substring(0, s.lastIndexOf(\"|||\"));\n        if (ignoreNTs) \n            r = r.replaceAll(\"\\\\[[^]]+?\\\\]\", \"[X]\");\n        return r;\n    }\n    private static void getRulesFromFile(String filename) throws IOException\n    {\n        rules = new HashMap<String,ArrayList<String>>();\n        Scanner scanner;\n        if (filename.endsWith(\".gz\")) {\n            scanner = new Scanner(new GZIPInputStream(new FileInputStream(new File(filename))), \"UTF-8\");\n        }\n        else {\n            scanner = new Scanner(new File(filename), \"UTF-8\");\n        }\n        while (scanner.hasNextLine()) {\n            String s = scanner.nextLine();\n            String r = repr(s);\n            if (rules.containsKey(r))\n                rules.get(r).add(s);\n            else {\n                ArrayList<String> al = new ArrayList<String>();\n                al.add(s);\n                rules.put(r, al);\n            }\n        }\n        scanner.close();\n        return;\n    }\n"]]}
{"hexsha": "874f71e1aeb093c23b280ff35d06969d93d16e7a", "ext": "java", "lang": "Java", "content": "@Getter\n@Setter\n@Slf4j\npublic class GeneratorContext {\n\n\t@RequiredArgsConstructor\n\tprivate static final class GeneratorId {\n\n\t\tprivate final String id;\n\n\t\tprivate final GeneratorTable table;\n\n\t\t@Override\n\t\tpublic boolean equals(final Object obj) {\n\t\t\tif (obj instanceof GeneratorId) {\n\t\t\t\tfinal GeneratorId other = (GeneratorId) obj;\n\t\t\t\treturn this.id.equals(other.id) && Objects.equals(this.table, other.table);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tif (this.table == null) {\n\t\t\t\treturn this.id.hashCode();\n\t\t\t}\n\t\t\treturn this.id.hashCode() << 2 | this.table.getName().hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (this.table == null) {\n\t\t\t\treturn this.id;\n\t\t\t}\n\t\t\treturn this.id + '.' + this.table.getName();\n\t\t}\n\n\t}\n\n\t/**\n\t * The settings key for the JPA provider.\n\t *\n\t * Contains either the fully qualified class name of an extension of {@link JpaProvider} or the simple name of one\n\t * of the classes from {@code org.fastnate.generator.provider}.\n\t *\n\t * Defaults to {@code HibernateProvider}.\n\t */\n\tpublic static final String PROVIDER_KEY = \"fastnate.generator.jpa.provider\";\n\n\t/** The settings key for the path to the persistence.xml, either relative to the current directory or absolute. */\n\tpublic static final String PERSISTENCE_FILE_KEY = \"fastnate.generator.persistence.file\";\n\n\t/**\n\t * The settings key for the name of the persistence unit in the persistence.xml. The first persistence unit is used,\n\t * if none is explicitly set.\n\t */\n\tpublic static final String PERSISTENCE_UNIT_KEY = \"fastnate.generator.persistence.unit\";\n\n\t/**\n\t * The settings key for the target SQL dialect.\n\t *\n\t * <p>\n\t * Contains either the fully qualified name of a class that extends {@link GeneratorDialect} or the simple class\n\t * name of one of the classes from {@code org.fastnate.generator.dialect}. The suffix 'Dialect' may be omitted in\n\t * that case. For example 'MySql' would map to {@code org.fastnate.generator.dialect.MySqlDialect}.\n\t * </p>\n\t *\n\t * <p>\n\t * If no dialect is set explicitly then the configured {@link #PERSISTENCE_FILE_KEY persistence.xml} is scanned for\n\t * a connection URL or provider specific dialect, which would be converted to our known dialects.\n\t * </p>\n\t *\n\t * <p>\n\t * If nothing is found, H2 is used as default.\n\t * </p>\n\t */\n\tpublic static final String DIALECT_KEY = \"fastnate.generator.dialect\";\n\n\t/** The settings key for {@link #writeNullValues}. */\n\tpublic static final String NULL_VALUES_KEY = \"fastnate.generator.null.values\";\n\n\t/** The settings key for {@link #writeRelativeIds}. */\n\tpublic static final String RELATIVE_IDS_KEY = \"fastnate.generator.relative.ids\";\n\n\t/** The settings key for the {@link #uniquePropertyQuality}. */\n\tpublic static final String UNIQUE_PROPERTIES_QUALITY_KEY = \"fastnate.generator.unique.properties.quality\";\n\n\t/** The settings key for the {@link #maxUniqueProperties}. */\n\tpublic static final String UNIQUE_PROPERTIES_MAX_KEY = \"fastnate.generator.unique.properties.max\";\n\n\t/** The settings key for {@link #preferSequenceCurentValue}. */\n\tpublic static final String PREFER_SEQUENCE_CURRENT_VALUE = \"fastnate.generator.prefer.sequence.current.value\";\n\n\t/**\n\t * Tries to read any persistence file defined in the settings.\n\t *\n\t * @param settings\n\t *            the current settings\n\t */\n\tprivate static void readPersistenceFile(final Properties settings) {\n\t\tString persistenceFilePath = settings.getProperty(PERSISTENCE_FILE_KEY);\n\t\tif (StringUtils.isEmpty(persistenceFilePath)) {\n\t\t\tfinal URL url = GeneratorContext.class.getResource(\"/META-INF/persistence.xml\");\n\t\t\tif (url == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpersistenceFilePath = url.toString();\n\t\t} else {\n\t\t\tfinal File persistenceFile = new File(persistenceFilePath);\n\t\t\tif (persistenceFile.isFile()) {\n\t\t\t\tpersistenceFilePath = persistenceFile.toURI().toString();\n\t\t\t}\n\t\t}\n\n\t\tfinal String persistenceUnit = settings.getProperty(PERSISTENCE_UNIT_KEY);\n\t\ttry {\n\t\t\tfinal Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder()\n\t\t\t\t\t.parse(persistenceFilePath);\n\t\t\tfinal NodeList persistenceUnits = document.getElementsByTagName(\"persistence-unit\");\n\t\t\tfor (int i = 0; i < persistenceUnits.getLength(); i++) {\n\t\t\t\tfinal Element persistenceUnitElement = (Element) persistenceUnits.item(i);\n\t\t\t\tif (StringUtils.isEmpty(persistenceUnit)\n\t\t\t\t\t\t|| persistenceUnit.equals(persistenceUnitElement.getAttribute(\"name\"))) {\n\t\t\t\t\tfinal NodeList properties = persistenceUnitElement.getElementsByTagName(\"property\");\n\t\t\t\t\tfor (int i2 = 0; i2 < properties.getLength(); i2++) {\n\t\t\t\t\t\tfinal Element property = (Element) properties.item(i2);\n\t\t\t\t\t\tfinal String name = property.getAttribute(\"name\");\n\t\t\t\t\t\tif (!settings.containsKey(name)) {\n\t\t\t\t\t\t\tsettings.put(name, property.getAttribute(\"value\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (final IOException | SAXException | ParserConfigurationException e) {\n\t\t\tlog.error(\"Could not read \" + persistenceFilePath + \": \" + e, e);\n\t\t}\n\t}\n\n\t/** Identifies the SQL dialect for generating SQL statements. Encapsulates the database specifica. */\n\tprivate GeneratorDialect dialect;\n\n\t/** Identifies the JPA provider to indicate implementation specific details. */\n\tprivate JpaProvider provider;\n\n\t/** The maximum count of columns that are used when referencing an entity using it's unique properties. */\n\tprivate int maxUniqueProperties = 1;\n\n\t/**\n\t * Indicates what kind of properties are used for referencing an entity with its unique properties.\n\t */\n\tprivate UniquePropertyQuality uniquePropertyQuality = UniquePropertyQuality.onlyRequiredPrimitives;\n\n\t/**\n\t * Indiciates to use \"currval\" of a sequence if the referenced entity is the last created entity for that sequence\n\t * before checking for {@link #uniquePropertyQuality unique properties}.\n\t */\n\tprivate boolean preferSequenceCurentValue = true;\n\n\t/**\n\t * Indicates that we write into a schema that is not empty. By default we write all IDs as absolute values and\n\t * change the sequences / table generators at the end. But this would crash if there is data in the database already\n\t * that uses the same IDs. So in the case of incremental updates, one should set this setting to {@code true} -\n\t * which will generate relative IDs which respect the existing IDs.\n\t */\n\tprivate boolean writeRelativeIds;\n\n\t/** Indicates to include null values in statements. */\n\tprivate boolean writeNullValues;\n\n\t/** Contains the settings that were given during creation, resp. as read from the persistence configuration. */\n\tprivate final Properties settings;\n\n\t/** Contains the extracted metadata to every known class of an {@link Entity}. */\n\tprivate final Map<Class<?>, EntityClass<?>> descriptions = new HashMap<>();\n\n\t/** The mapping from the {@link Entity#name() name of an entity} to the {@link #descriptions extracted metadata}. */\n\tprivate final Map<String, EntityClass<?>> descriptionsByName = new HashMap<>();\n\n\t/** Mapping from the names of all known database table to their description (including column information). */\n\tprivate final Map<String, GeneratorTable> tables = new HashMap<>();\n\n\t/** Contains the state of single entities, maps from an entity name to the mapping of an id to its state. */\n\tprivate final Map<String, Map<Object, GenerationState>> states = new HashMap<>();\n\n\t/** Mapping from the name of a generator to the generator itself. */\n\t@Getter(AccessLevel.NONE)\n\tprivate final Map<GeneratorId, IdGenerator> generators = new HashMap<>();\n\n\t/** The default sequence generator, if none is explicitly specified in a {@link GeneratedValue}. */\n\tprivate SequenceIdGenerator defaultSequenceGenerator;\n\n\t/** The default table generator, if none is explicitly specified in a {@link GeneratedValue}. */\n\tprivate TableIdGenerator defaultTableGenerator;\n\n\t/** All listeners of this context. */\n\tprivate List<ContextModelListener> contextModelListeners = new ArrayList<>();\n\n\t/**\n\t * Creates a default generator context.\n\t */\n\tpublic GeneratorContext() {\n\t\tthis(new H2Dialect());\n\t}\n\n\t/**\n\t * Creates a generator context for a dialect.\n\t *\n\t * @param dialect\n\t *            the database dialect to use during generation\n\t */\n\tpublic GeneratorContext(final GeneratorDialect dialect) {\n\t\tthis.dialect = dialect;\n\t\tthis.provider = new HibernateProvider();\n\t\tthis.settings = new Properties();\n\t}\n\n\t/**\n\t * Creates a new instance of {@link GeneratorContext}.\n\t *\n\t * @param settings\n\t *            contains the settings\n\t */\n\tpublic GeneratorContext(final Properties settings) {\n\t\tthis.settings = settings;\n\n\t\treadPersistenceFile(settings);\n\n\t\tString providerName = settings.getProperty(PROVIDER_KEY, \"HibernateProvider\");\n\t\tif (providerName.indexOf('.') < 0) {\n\t\t\tproviderName = JpaProvider.class.getPackage().getName() + '.' + providerName;\n\t\t}\n\t\ttry {\n\t\t\tthis.provider = (JpaProvider) Class.forName(providerName).newInstance();\n\t\t\tthis.provider.initialize(settings);\n\t\t} catch (final InstantiationException | IllegalAccessException | ClassNotFoundException\n\t\t\t\t| ClassCastException e) {\n\t\t\tthrow new IllegalArgumentException(\"Can't instantiate provider: \" + providerName, e);\n\t\t}\n\n\t\tString dialectName = settings.getProperty(DIALECT_KEY, \"H2Dialect\");\n\t\tif (dialectName.indexOf('.') < 0) {\n\t\t\tdialectName = GeneratorDialect.class.getPackage().getName() + '.' + dialectName;\n\t\t\tif (!dialectName.endsWith(\"Dialect\")) {\n\t\t\t\tdialectName += \"Dialect\";\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tthis.dialect = (GeneratorDialect) Class.forName(dialectName).newInstance();\n\t\t} catch (final InstantiationException | IllegalAccessException | ClassNotFoundException\n\t\t\t\t| ClassCastException e) {\n\t\t\tthrow new IllegalArgumentException(\"Can't instantiate dialect: \" + dialectName, e);\n\t\t}\n\n\t\tthis.writeRelativeIds = Boolean\n\t\t\t\t.parseBoolean(settings.getProperty(RELATIVE_IDS_KEY, String.valueOf(this.writeRelativeIds)));\n\t\tthis.writeNullValues = Boolean\n\t\t\t\t.parseBoolean(settings.getProperty(NULL_VALUES_KEY, String.valueOf(this.writeNullValues)));\n\t\tthis.uniquePropertyQuality = UniquePropertyQuality\n\t\t\t\t.valueOf(settings.getProperty(UNIQUE_PROPERTIES_QUALITY_KEY, this.uniquePropertyQuality.name()));\n\t\tthis.maxUniqueProperties = Integer\n\t\t\t\t.parseInt(settings.getProperty(UNIQUE_PROPERTIES_MAX_KEY, String.valueOf(this.maxUniqueProperties)));\n\t\tthis.preferSequenceCurentValue = Boolean.parseBoolean(\n\t\t\t\tsettings.getProperty(PREFER_SEQUENCE_CURRENT_VALUE, String.valueOf(this.preferSequenceCurentValue)));\n\t}\n\n\t/**\n\t * Adds a new listener to this context.\n\t *\n\t * @param listener\n\t *            the listener that is interested in new discovered model elements\n\t */\n\tpublic void addContextModelListener(final ContextModelListener listener) {\n\t\tthis.contextModelListeners.add(listener);\n\t}\n\n\tprivate <K, T> T addContextObject(final Map<K, ? super T> objects,\n\t\t\tfinal BiConsumer<ContextModelListener, ? super T> listenerFunction, final K key, final T object) {\n\t\tobjects.put(key, object);\n\t\tfireContextObjectAdded(listenerFunction, object);\n\t\treturn object;\n\t}\n\n\t/**\n\t * Fires an event to all {@link #getContextModelListeners() listeners}.\n\t *\n\t * @param listenerFunction\n\t *            the function that is called on the listeners\n\t * @param contextObject\n\t *            the object to offer to the listener function\n\t */\n\tprotected <T> void fireContextObjectAdded(final BiConsumer<ContextModelListener, T> listenerFunction,\n\t\t\tfinal T contextObject) {\n\t\tfor (final ContextModelListener listener : this.contextModelListeners) {\n\t\t\tlistenerFunction.accept(listener, contextObject);\n\t\t}\n\t}\n\n\tprivate IdGenerator getDefaultSequenceGenerator() {\n\t\tif (this.defaultSequenceGenerator == null) {\n\t\t\tfinal Map<String, Object> defaults = Stream\n\t\t\t\t\t.of(new SimpleEntry<String, Object>(\"sequenceName\", this.provider.getDefaultSequence()),\n\t\t\t\t\t\t\tnew SimpleEntry<String, Object>(\"allocationSize\", Integer.valueOf(1)))\n\t\t\t\t\t.collect(Collectors.toMap(SimpleEntry::getKey, SimpleEntry::getValue));\n\t\t\tthis.defaultSequenceGenerator = new SequenceIdGenerator(\n\t\t\t\t\tAnnotationDefaults.create(SequenceGenerator.class, defaults), this.dialect, this.writeRelativeIds);\n\t\t\tfireContextObjectAdded(ContextModelListener::foundGenerator, this.defaultSequenceGenerator);\n\t\t}\n\t\treturn this.defaultSequenceGenerator;\n\t}\n\n\tprivate IdGenerator getDefaultTableGenerator() {\n\t\tif (this.defaultTableGenerator == null) {\n\t\t\tfinal Map<String, Object> defaults = Stream\n\t\t\t\t\t.of(new SimpleEntry<String, Object>(\"pkColumnValue\", \"default\"),\n\t\t\t\t\t\t\tnew SimpleEntry<String, Object>(\"allocationSize\", Integer.valueOf(1)))\n\t\t\t\t\t.collect(Collectors.toMap(SimpleEntry::getKey, SimpleEntry::getValue));\n\t\t\tthis.defaultTableGenerator = new TableIdGenerator(AnnotationDefaults.create(TableGenerator.class, defaults),\n\t\t\t\t\tthis);\n\t\t\tfireContextObjectAdded(ContextModelListener::foundGenerator, this.defaultTableGenerator);\n\t\t}\n\t\treturn this.defaultTableGenerator;\n\t}\n\n\t/**\n\t * Finds the description for a class.\n\t *\n\t * @param entityClass\n\t *            the class to lookup\n\t * @return the description for the class or {@code null} if the class is not an {@link Entity}\n\t */\n\tpublic <E> EntityClass<E> getDescription(final Class<E> entityClass) {\n\t\t// Lookup description\n\t\tEntityClass<E> description = (EntityClass<E>) this.descriptions.get(entityClass);\n\t\tif (description == null) {\n\t\t\tif (!entityClass.isAnnotationPresent(Entity.class)) {\n\t\t\t\t// Step up to find the parent description\n\t\t\t\tfinal Class<?> superClass = entityClass.getSuperclass();\n\t\t\t\tif (superClass == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\treturn (EntityClass<E>) getDescription(superClass);\n\t\t\t}\n\n\t\t\t// Create the description\n\t\t\tdescription = new EntityClass<>(this, entityClass);\n\n\t\t\t// First remember the description (to prevent endless loops)\n\t\t\tthis.descriptions.put(entityClass, description);\n\t\t\tthis.descriptionsByName.put(description.getEntityName(), description);\n\n\t\t\t// And now build the properties\n\t\t\tdescription.build();\n\n\t\t\t// And notify listeners\n\t\t\tfireContextObjectAdded(ContextModelListener::foundEntityClass, description);\n\t\t}\n\t\treturn description;\n\t}\n\n\t/**\n\t * Finds the description for the class of an entity.\n\t *\n\t * @param entity\n\t *            the entity to lookup\n\t * @return the description for the class of the entity\n\t * @throws IllegalArgumentException\n\t *             if the given object is no {@link Entity}\n\t */\n\tpublic <E> EntityClass<E> getDescription(final E entity) {\n\t\tif (entity == null) {\n\t\t\tthrow new IllegalArgumentException(\"Can't inspect null entity\");\n\t\t}\n\t\tfinal EntityClass<E> description = (EntityClass<E>) getDescription(entity.getClass());\n\t\tif (description == null) {\n\t\t\tthrow new IllegalArgumentException(entity.getClass() + \" is not an entity class\");\n\t\t}\n\t\treturn description;\n\t}\n\n\t/**\n\t * Finds the correct generator for the given annotation.\n\t *\n\t * @param generatedValue\n\t *            the annotation of the current primary key\n\t * @param table\n\t *            the name of the current table\n\t * @param column\n\t *            the name of the current column\n\t * @return the generator that is responsible for managing the values\n\t */\n\t@SuppressWarnings(\"null\")\n\tpublic IdGenerator getGenerator(final GeneratedValue generatedValue, final GeneratorTable table,\n\t\t\tfinal GeneratorColumn column) {\n\t\tGenerationType strategy = generatedValue.strategy();\n\t\tfinal String name = generatedValue.generator();\n\t\tif (StringUtils.isNotEmpty(name)) {\n\t\t\tModelException.test(strategy != GenerationType.IDENTITY,\n\t\t\t\t\t\"Generator for GenerationType.IDENTITY not allowed\");\n\t\t\tIdGenerator generator = this.generators.get(new GeneratorId(name, table));\n\t\t\tif (generator == null) {\n\t\t\t\tgenerator = this.generators.get(new GeneratorId(name, null));\n\t\t\t\tModelException.test(generator != null, \"Generator '{}' not found\", name);\n\n\t\t\t\tfinal IdGenerator derived = generator.derive(table);\n\t\t\t\tif (derived != generator) {\n\t\t\t\t\treturn addContextObject(this.generators, ContextModelListener::foundGenerator,\n\t\t\t\t\t\t\tnew GeneratorId(name, table), derived);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn generator;\n\t\t}\n\t\tif (strategy == GenerationType.AUTO) {\n\t\t\tstrategy = this.dialect.getAutoGenerationType();\n\t\t}\n\t\tswitch (strategy) {\n\t\t\tcase IDENTITY:\n\t\t\t\treturn addContextObject(this.generators, ContextModelListener::foundGenerator,\n\t\t\t\t\t\tnew GeneratorId(column.getName(), table), new IdentityValue(this, table, column));\n\t\t\tcase TABLE:\n\t\t\t\treturn getDefaultTableGenerator();\n\t\t\tcase SEQUENCE:\n\t\t\t\treturn getDefaultSequenceGenerator();\n\t\t\tcase AUTO:\n\t\t\tdefault:\n\t\t\t\tthrow new ModelException(\"Unknown GenerationType: \" + strategy);\n\t\t}\n\t}\n\n\t/**\n\t * The entity states for the given entity class.\n\t *\n\t * @param entityClass\n\t *            the current entity class\n\t * @return the states of the entities of that class (with their IDs as keys)\n\t */\n\tMap<Object, GenerationState> getStates(final EntityClass<?> entityClass) {\n\t\tMap<Object, GenerationState> entityStates = this.states.get(entityClass.getEntityName());\n\t\tif (entityStates == null) {\n\t\t\tentityStates = new HashMap<>();\n\t\t\tthis.states.put(entityClass.getEntityName(), entityStates);\n\t\t}\n\t\treturn entityStates;\n\t}\n\n\t/**\n\t * Registers the {@link TableGenerator} and {@link SequenceGenerator} declared at the given element.\n\t *\n\t * If neither annotation is present, nothing happens.\n\t *\n\t * @param element\n\t *            the inspected class, method or field\n\t * @param table\n\t *            the table of the current entity\n\t */\n\tpublic void registerGenerators(final AnnotatedElement element, final GeneratorTable table) {\n\t\tfinal SequenceGenerator sequenceGenerator = element.getAnnotation(SequenceGenerator.class);\n\t\tif (sequenceGenerator != null) {\n\t\t\tGeneratorId key = new GeneratorId(sequenceGenerator.name(), null);\n\t\t\tfinal IdGenerator existingGenerator = this.generators.get(key);\n\t\t\tif (!(existingGenerator instanceof SequenceIdGenerator) || !((SequenceIdGenerator) existingGenerator)\n\t\t\t\t\t.getSequenceName().equals(sequenceGenerator.sequenceName())) {\n\t\t\t\tif (existingGenerator != null) {\n\t\t\t\t\tkey = new GeneratorId(sequenceGenerator.name(), table);\n\t\t\t\t}\n\t\t\t\taddContextObject(this.generators, ContextModelListener::foundGenerator, key,\n\t\t\t\t\t\tnew SequenceIdGenerator(sequenceGenerator, this.dialect, this.writeRelativeIds));\n\t\t\t}\n\t\t}\n\n\t\tfinal TableGenerator tableGenerator = element.getAnnotation(TableGenerator.class);\n\t\tif (tableGenerator != null) {\n\t\t\tfinal GeneratorId key = new GeneratorId(tableGenerator.name(), null);\n\t\t\tif (!this.generators.containsKey(key)) {\n\t\t\t\taddContextObject(this.generators, ContextModelListener::foundGenerator, key,\n\t\t\t\t\t\tnew TableIdGenerator(tableGenerator, this));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Removes a listener from this context.\n\t *\n\t * @param listener\n\t *            the listener that is not interested anymore\n\t */\n\tpublic void removeContextModelListener(final ContextModelListener listener) {\n\t\tthis.contextModelListeners.remove(listener);\n\t}\n\n\t/**\n\t * Finds resp. builds the metadata to the given table.\n\t *\n\t * @param tableName\n\t *            the name of the table from the database\n\t * @return the metadata for the given table\n\t */\n\tpublic GeneratorTable resolveTable(final String tableName) {\n\t\tfinal GeneratorTable table = this.tables.get(tableName);\n\t\tif (table != null) {\n\t\t\treturn table;\n\t\t}\n\t\treturn addContextObject(this.tables, ContextModelListener::foundTable, tableName,\n\t\t\t\tnew GeneratorTable(this.tables.size(), tableName, this));\n\t}\n\n\t/**\n\t * Builds all statements that are necessary to align ID generators in the database with the current IDs.\n\t *\n\t * @param writer\n\t *            the target of any write operation\n\t * @throws IOException\n\t *             if the writer throws one\n\t */\n\tpublic void writeAlignmentStatements(final StatementsWriter writer) throws IOException {\n\t\tfor (final IdGenerator generator : this.generators.values()) {\n\t\t\tgenerator.alignNextValue(writer);\n\t\t}\n\t\tif (this.defaultSequenceGenerator != null) {\n\t\t\tthis.defaultSequenceGenerator.alignNextValue(writer);\n\t\t}\n\t\tif (this.defaultTableGenerator != null) {\n\t\t\tthis.defaultTableGenerator.alignNextValue(writer);\n\t\t}\n\t}\n}", "class_id": 0, "repo": "ahofmeister/org.fastnate", "file": "fastnate-generator/src/main/java/org/fastnate/generator/context/GeneratorContext.java", "last_update_at": "2020-10-11T20:17:06+00:00", "question_id": "874f71e1aeb093c23b280ff35d06969d93d16e7a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Getter\n@Setter\n@Slf4j\npublic class GeneratorContext {\n\t@RequiredArgsConstructor\n\tprivate static final class GeneratorId {\n\t\tprivate final String id;\n\t\tprivate final GeneratorTable table;\n\t\t@Override\n\t\tpublic boolean equals(final Object obj) {\n\t\t\tif (obj instanceof GeneratorId) {\n\t\t\t\tfinal GeneratorId other = (GeneratorId) obj;\n\t\t\t\treturn this.id.equals(other.id) && Objects.equals(this.table, other.table);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tif (this.table == null) {\n\t\t\t\treturn this.id.hashCode();\n\t\t\t}\n\t\t\treturn this.id.hashCode() << 2 | this.table.getName().hashCode();\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (this.table == null) {\n\t\t\t\treturn this.id;\n\t\t\t}\n\t\t\treturn this.id + '.' + this.table.getName();\n\t\t}\n\t}\n\t/**\n\t * The settings key for the JPA provider.\n\t *\n\t * Contains either the fully qualified class name of an extension of {@link JpaProvider} or the simple name of one\n\t * of the classes from {@code org.fastnate.generator.provider}.\n\t *\n\t * Defaults to {@code HibernateProvider}.\n\t */\n\tpublic static final String PROVIDER_KEY = \"fastnate.generator.jpa.provider\";\n\t/** The settings key for the path to the persistence.xml, either relative to the current directory or absolute. */\n\tpublic static final String PERSISTENCE_FILE_KEY = \"fastnate.generator.persistence.file\";\n\t/**\n\t * The settings key for the name of the persistence unit in the persistence.xml. The first persistence unit is used,\n\t * if none is explicitly set.\n\t */\n\tpublic static final String PERSISTENCE_UNIT_KEY = \"fastnate.generator.persistence.unit\";\n\t/**\n\t * The settings key for the target SQL dialect.\n\t *\n\t * <p>\n\t * Contains either the fully qualified name of a class that extends {@link GeneratorDialect} or the simple class\n\t * name of one of the classes from {@code org.fastnate.generator.dialect}. The suffix 'Dialect' may be omitted in\n\t * that case. For example 'MySql' would map to {@code org.fastnate.generator.dialect.MySqlDialect}.\n\t * </p>\n\t *\n\t * <p>\n\t * If no dialect is set explicitly then the configured {@link #PERSISTENCE_FILE_KEY persistence.xml} is scanned for\n\t * a connection URL or provider specific dialect, which would be converted to our known dialects.\n\t * </p>\n\t *\n\t * <p>\n\t * If nothing is found, H2 is used as default.\n\t * </p>\n\t */\n\tpublic static final String DIALECT_KEY = \"fastnate.generator.dialect\";\n\t/** The settings key for {@link #writeNullValues}. */\n\tpublic static final String NULL_VALUES_KEY = \"fastnate.generator.null.values\";\n\t/** The settings key for {@link #writeRelativeIds}. */\n\tpublic static final String RELATIVE_IDS_KEY = \"fastnate.generator.relative.ids\";\n\t/** The settings key for the {@link #uniquePropertyQuality}. */\n\tpublic static final String UNIQUE_PROPERTIES_QUALITY_KEY = \"fastnate.generator.unique.properties.quality\";\n\t/** The settings key for the {@link #maxUniqueProperties}. */\n\tpublic static final String UNIQUE_PROPERTIES_MAX_KEY = \"fastnate.generator.unique.properties.max\";\n\t/** The settings key for {@link #preferSequenceCurentValue}. */\n\tpublic static final String PREFER_SEQUENCE_CURRENT_VALUE = \"fastnate.generator.prefer.sequence.current.value\";\n\t/**\n\t * Tries to read any persistence file defined in the settings.\n\t *\n\t * @param settings\n\t *            the current settings\n\t */\n\tprivate static void readPersistenceFile(final Properties settings) {\n\t\tString persistenceFilePath = settings.getProperty(PERSISTENCE_FILE_KEY);\n\t\tif (StringUtils.isEmpty(persistenceFilePath)) {\n\t\t\tfinal URL url = GeneratorContext.class.getResource(\"/META-INF/persistence.xml\");\n\t\t\tif (url == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpersistenceFilePath = url.toString();\n\t\t} else {\n\t\t\tfinal File persistenceFile = new File(persistenceFilePath);\n\t\t\tif (persistenceFile.isFile()) {\n\t\t\t\tpersistenceFilePath = persistenceFile.toURI().toString();\n\t\t\t}\n\t\t}\n\t\tfinal String persistenceUnit = settings.getProperty(PERSISTENCE_UNIT_KEY);\n\t\ttry {\n\t\t\tfinal Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder()\n\t\t\t\t\t.parse(persistenceFilePath);\n\t\t\tfinal NodeList persistenceUnits = document.getElementsByTagName(\"persistence-unit\");\n\t\t\tfor (int i = 0; i < persistenceUnits.getLength(); i++) {\n\t\t\t\tfinal Element persistenceUnitElement = (Element) persistenceUnits.item(i);\n\t\t\t\tif (StringUtils.isEmpty(persistenceUnit)\n\t\t\t\t\t\t|| persistenceUnit.equals(persistenceUnitElement.getAttribute(\"name\"))) {\n\t\t\t\t\tfinal NodeList properties = persistenceUnitElement.getElementsByTagName(\"property\");\n\t\t\t\t\tfor (int i2 = 0; i2 < properties.getLength(); i2++) {\n\t\t\t\t\t\tfinal Element property = (Element) properties.item(i2);\n\t\t\t\t\t\tfinal String name = property.getAttribute(\"name\");\n\t\t\t\t\t\tif (!settings.containsKey(name)) {\n\t\t\t\t\t\t\tsettings.put(name, property.getAttribute(\"value\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (final IOException | SAXException | ParserConfigurationException e) {\n\t\t\tlog.error(\"Could not read \" + persistenceFilePath + \": \" + e, e);\n\t\t}\n\t}\n\t/** Identifies the SQL dialect for generating SQL statements. Encapsulates the database specifica. */\n\tprivate GeneratorDialect dialect;\n\t/** Identifies the JPA provider to indicate implementation specific details. */\n\tprivate JpaProvider provider;\n\t/** The maximum count of columns that are used when referencing an entity using it's unique properties. */\n\tprivate int maxUniqueProperties = 1;\n\t/**\n\t * Indicates what kind of properties are used for referencing an entity with its unique properties.\n\t */\n\tprivate UniquePropertyQuality uniquePropertyQuality = UniquePropertyQuality.onlyRequiredPrimitives;\n\t/**\n\t * Indiciates to use \"currval\" of a sequence if the referenced entity is the last created entity for that sequence\n\t * before checking for {@link #uniquePropertyQuality unique properties}.\n\t */\n\tprivate boolean preferSequenceCurentValue = true;\n\t/**\n\t * Indicates that we write into a schema that is not empty. By default we write all IDs as absolute values and\n\t * change the sequences / table generators at the end. But this would crash if there is data in the database already\n\t * that uses the same IDs. So in the case of incremental updates, one should set this setting to {@code true} -\n\t * which will generate relative IDs which respect the existing IDs.\n\t */\n\tprivate boolean writeRelativeIds;\n\t/** Indicates to include null values in statements. */\n\tprivate boolean writeNullValues;\n\t/** Contains the settings that were given during creation, resp. as read from the persistence configuration. */\n\tprivate final Properties settings;\n\t/** Contains the extracted metadata to every known class of an {@link Entity}. */\n\tprivate final Map<Class<?>, EntityClass<?>> descriptions = new HashMap<>();\n\t/** The mapping from the {@link Entity#name() name of an entity} to the {@link #descriptions extracted metadata}. */\n\tprivate final Map<String, EntityClass<?>> descriptionsByName = new HashMap<>();\n\t/** Mapping from the names of all known database table to their description (including column information). */\n\tprivate final Map<String, GeneratorTable> tables = new HashMap<>();\n\t/** Contains the state of single entities, maps from an entity name to the mapping of an id to its state. */\n\tprivate final Map<String, Map<Object, GenerationState>> states = new HashMap<>();\n\t/** Mapping from the name of a generator to the generator itself. */\n\t@Getter(AccessLevel.NONE)\n\tprivate final Map<GeneratorId, IdGenerator> generators = new HashMap<>();\n\t/** The default sequence generator, if none is explicitly specified in a {@link GeneratedValue}. */\n\tprivate SequenceIdGenerator defaultSequenceGenerator;\n\t/** The default table generator, if none is explicitly specified in a {@link GeneratedValue}. */\n\tprivate TableIdGenerator defaultTableGenerator;\n\t/** All listeners of this context. */\n\tprivate List<ContextModelListener> contextModelListeners = new ArrayList<>();\n\t/**\n\t * Creates a default generator context.\n\t */\n\tpublic GeneratorContext() {\n\t\tthis(new H2Dialect());\n\t}\n\t/**\n\t * Creates a generator context for a dialect.\n\t *\n\t * @param dialect\n\t *            the database dialect to use during generation\n\t */\n\tpublic GeneratorContext(final GeneratorDialect dialect) {\n\t\tthis.dialect = dialect;\n\t\tthis.provider = new HibernateProvider();\n\t\tthis.settings = new Properties();\n\t}\n\t/**\n\t * Creates a new instance of {@link GeneratorContext}.\n\t *\n\t * @param settings\n\t *            contains the settings\n\t */\n\tpublic GeneratorContext(final Properties settings) {\n\t\tthis.settings = settings;\n\t\treadPersistenceFile(settings);\n\t\tString providerName = settings.getProperty(PROVIDER_KEY, \"HibernateProvider\");\n\t\tif (providerName.indexOf('.') < 0) {\n\t\t\tproviderName = JpaProvider.class.getPackage().getName() + '.' + providerName;\n\t\t}\n\t\ttry {\n\t\t\tthis.provider = (JpaProvider) Class.forName(providerName).newInstance();\n\t\t\tthis.provider.initialize(settings);\n\t\t} catch (final InstantiationException | IllegalAccessException | ClassNotFoundException\n\t\t\t\t| ClassCastException e) {\n\t\t\tthrow new IllegalArgumentException(\"Can't instantiate provider: \" + providerName, e);\n\t\t}\n\t\tString dialectName = settings.getProperty(DIALECT_KEY, \"H2Dialect\");\n\t\tif (dialectName.indexOf('.') < 0) {\n\t\t\tdialectName = GeneratorDialect.class.getPackage().getName() + '.' + dialectName;\n\t\t\tif (!dialectName.endsWith(\"Dialect\")) {\n\t\t\t\tdialectName += \"Dialect\";\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tthis.dialect = (GeneratorDialect) Class.forName(dialectName).newInstance();\n\t\t} catch (final InstantiationException | IllegalAccessException | ClassNotFoundException\n\t\t\t\t| ClassCastException e) {\n\t\t\tthrow new IllegalArgumentException(\"Can't instantiate dialect: \" + dialectName, e);\n\t\t}\n\t\tthis.writeRelativeIds = Boolean\n\t\t\t\t.parseBoolean(settings.getProperty(RELATIVE_IDS_KEY, String.valueOf(this.writeRelativeIds)));\n\t\tthis.writeNullValues = Boolean\n\t\t\t\t.parseBoolean(settings.getProperty(NULL_VALUES_KEY, String.valueOf(this.writeNullValues)));\n\t\tthis.uniquePropertyQuality = UniquePropertyQuality\n\t\t\t\t.valueOf(settings.getProperty(UNIQUE_PROPERTIES_QUALITY_KEY, this.uniquePropertyQuality.name()));\n\t\tthis.maxUniqueProperties = Integer\n\t\t\t\t.parseInt(settings.getProperty(UNIQUE_PROPERTIES_MAX_KEY, String.valueOf(this.maxUniqueProperties)));\n\t\tthis.preferSequenceCurentValue = Boolean.parseBoolean(\n\t\t\t\tsettings.getProperty(PREFER_SEQUENCE_CURRENT_VALUE, String.valueOf(this.preferSequenceCurentValue)));\n\t}\n\t/**\n\t * Adds a new listener to this context.\n\t *\n\t * @param listener\n\t *            the listener that is interested in new discovered model elements\n\t */\n\tpublic void addContextModelListener(final ContextModelListener listener) {\n\t\tthis.contextModelListeners.add(listener);\n\t}\n\tprivate <K, T> T addContextObject(final Map<K, ? super T> objects,\n\t\t\tfinal BiConsumer<ContextModelListener, ? super T> listenerFunction, final K key, final T object) {\n\t\tobjects.put(key, object);\n\t\tfireContextObjectAdded(listenerFunction, object);\n\t\treturn object;\n\t}\n\t/**\n\t * Fires an event to all {@link #getContextModelListeners() listeners}.\n\t *\n\t * @param listenerFunction\n\t *            the function that is called on the listeners\n\t * @param contextObject\n\t *            the object to offer to the listener function\n\t */\n\tprotected <T> void fireContextObjectAdded(final BiConsumer<ContextModelListener, T> listenerFunction,\n\t\t\tfinal T contextObject) {\n\t\tfor (final ContextModelListener listener : this.contextModelListeners) {\n\t\t\tlistenerFunction.accept(listener, contextObject);\n\t\t}\n\t}\n\tprivate IdGenerator getDefaultSequenceGenerator() {\n\t\tif (this.defaultSequenceGenerator == null) {\n\t\t\tfinal Map<String, Object> defaults = Stream\n\t\t\t\t\t.of(new SimpleEntry<String, Object>(\"sequenceName\", this.provider.getDefaultSequence()),\n\t\t\t\t\t\t\tnew SimpleEntry<String, Object>(\"allocationSize\", Integer.valueOf(1)))\n\t\t\t\t\t.collect(Collectors.toMap(SimpleEntry::getKey, SimpleEntry::getValue));\n\t\t\tthis.defaultSequenceGenerator = new SequenceIdGenerator(\n\t\t\t\t\tAnnotationDefaults.create(SequenceGenerator.class, defaults), this.dialect, this.writeRelativeIds);\n\t\t\tfireContextObjectAdded(ContextModelListener::foundGenerator, this.defaultSequenceGenerator);\n\t\t}\n\t\treturn this.defaultSequenceGenerator;\n\t}\n\tprivate IdGenerator getDefaultTableGenerator() {\n\t\tif (this.defaultTableGenerator == null) {\n\t\t\tfinal Map<String, Object> defaults = Stream\n\t\t\t\t\t.of(new SimpleEntry<String, Object>(\"pkColumnValue\", \"default\"),\n\t\t\t\t\t\t\tnew SimpleEntry<String, Object>(\"allocationSize\", Integer.valueOf(1)))\n\t\t\t\t\t.collect(Collectors.toMap(SimpleEntry::getKey, SimpleEntry::getValue));\n\t\t\tthis.defaultTableGenerator = new TableIdGenerator(AnnotationDefaults.create(TableGenerator.class, defaults),\n\t\t\t\t\tthis);\n\t\t\tfireContextObjectAdded(ContextModelListener::foundGenerator, this.defaultTableGenerator);\n\t\t}\n\t\treturn this.defaultTableGenerator;\n\t}\n\t/**\n\t * Finds the description for a class.\n\t *\n\t * @param entityClass\n\t *            the class to lookup\n\t * @return the description for the class or {@code null} if the class is not an {@link Entity}\n\t */\n\tpublic <E> EntityClass<E> getDescription(final Class<E> entityClass) {\n\t\t// Lookup description\n\t\tEntityClass<E> description = (EntityClass<E>) this.descriptions.get(entityClass);\n\t\tif (description == null) {\n\t\t\tif (!entityClass.isAnnotationPresent(Entity.class)) {\n\t\t\t\t// Step up to find the parent description\n\t\t\t\tfinal Class<?> superClass = entityClass.getSuperclass();\n\t\t\t\tif (superClass == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn (EntityClass<E>) getDescription(superClass);\n\t\t\t}\n\t\t\t// Create the description\n\t\t\tdescription = new EntityClass<>(this, entityClass);\n\t\t\t// First remember the description (to prevent endless loops)\n\t\t\tthis.descriptions.put(entityClass, description);\n\t\t\tthis.descriptionsByName.put(description.getEntityName(), description);\n\t\t\t// And now build the properties\n\t\t\tdescription.build();\n\t\t\t// And notify listeners\n\t\t\tfireContextObjectAdded(ContextModelListener::foundEntityClass, description);\n\t\t}\n\t\treturn description;\n\t}\n\t/**\n\t * Finds the description for the class of an entity.\n\t *\n\t * @param entity\n\t *            the entity to lookup\n\t * @return the description for the class of the entity\n\t * @throws IllegalArgumentException\n\t *             if the given object is no {@link Entity}\n\t */\n\tpublic <E> EntityClass<E> getDescription(final E entity) {\n\t\tif (entity == null) {\n\t\t\tthrow new IllegalArgumentException(\"Can't inspect null entity\");\n\t\t}\n\t\tfinal EntityClass<E> description = (EntityClass<E>) getDescription(entity.getClass());\n\t\tif (description == null) {\n\t\t\tthrow new IllegalArgumentException(entity.getClass() + \" is not an entity class\");\n\t\t}\n\t\treturn description;\n\t}\n\t/**\n\t * Finds the correct generator for the given annotation.\n\t *\n\t * @param generatedValue\n\t *            the annotation of the current primary key\n\t * @param table\n\t *            the name of the current table\n\t * @param column\n\t *            the name of the current column\n\t * @return the generator that is responsible for managing the values\n\t */\n\t@SuppressWarnings(\"null\")\n\tpublic IdGenerator getGenerator(final GeneratedValue generatedValue, final GeneratorTable table,\n\t\t\tfinal GeneratorColumn column) {\n\t\tGenerationType strategy = generatedValue.strategy();\n\t\tfinal String name = generatedValue.generator();\n\t\tif (StringUtils.isNotEmpty(name)) {\n\t\t\tModelException.test(strategy != GenerationType.IDENTITY,\n\t\t\t\t\t\"Generator for GenerationType.IDENTITY not allowed\");\n\t\t\tIdGenerator generator = this.generators.get(new GeneratorId(name, table));\n\t\t\tif (generator == null) {\n\t\t\t\tgenerator = this.generators.get(new GeneratorId(name, null));\n\t\t\t\tModelException.test(generator != null, \"Generator '{}' not found\", name);\n\t\t\t\tfinal IdGenerator derived = generator.derive(table);\n\t\t\t\tif (derived != generator) {\n\t\t\t\t\treturn addContextObject(this.generators, ContextModelListener::foundGenerator,\n\t\t\t\t\t\t\tnew GeneratorId(name, table), derived);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn generator;\n\t\t}\n\t\tif (strategy == GenerationType.AUTO) {\n\t\t\tstrategy = this.dialect.getAutoGenerationType();\n\t\t}\n\t\tswitch (strategy) {\n\t\t\tcase IDENTITY:\n\t\t\t\treturn addContextObject(this.generators, ContextModelListener::foundGenerator,\n\t\t\t\t\t\tnew GeneratorId(column.getName(), table), new IdentityValue(this, table, column));\n\t\t\tcase TABLE:\n\t\t\t\treturn getDefaultTableGenerator();\n\t\t\tcase SEQUENCE:\n\t\t\t\treturn getDefaultSequenceGenerator();\n\t\t\tcase AUTO:\n\t\t\tdefault:\n\t\t\t\tthrow new ModelException(\"Unknown GenerationType: \" + strategy);\n\t\t}\n\t}\n\t/**\n\t * The entity states for the given entity class.\n\t *\n\t * @param entityClass\n\t *            the current entity class\n\t * @return the states of the entities of that class (with their IDs as keys)\n\t */\n\tMap<Object, GenerationState> getStates(final EntityClass<?> entityClass) {\n\t\tMap<Object, GenerationState> entityStates = this.states.get(entityClass.getEntityName());\n\t\tif (entityStates == null) {\n\t\t\tentityStates = new HashMap<>();\n\t\t\tthis.states.put(entityClass.getEntityName(), entityStates);\n\t\t}\n\t\treturn entityStates;\n\t}\n\t/**\n\t * Registers the {@link TableGenerator} and {@link SequenceGenerator} declared at the given element.\n\t *\n\t * If neither annotation is present, nothing happens.\n\t *\n\t * @param element\n\t *            the inspected class, method or field\n\t * @param table\n\t *            the table of the current entity\n\t */\n\tpublic void registerGenerators(final AnnotatedElement element, final GeneratorTable table) {\n\t\tfinal SequenceGenerator sequenceGenerator = element.getAnnotation(SequenceGenerator.class);\n\t\tif (sequenceGenerator != null) {\n\t\t\tGeneratorId key = new GeneratorId(sequenceGenerator.name(), null);\n\t\t\tfinal IdGenerator existingGenerator = this.generators.get(key);\n\t\t\tif (!(existingGenerator instanceof SequenceIdGenerator) || !((SequenceIdGenerator) existingGenerator)\n\t\t\t\t\t.getSequenceName().equals(sequenceGenerator.sequenceName())) {\n\t\t\t\tif (existingGenerator != null) {\n\t\t\t\t\tkey = new GeneratorId(sequenceGenerator.name(), table);\n\t\t\t\t}\n\t\t\t\taddContextObject(this.generators, ContextModelListener::foundGenerator, key,\n\t\t\t\t\t\tnew SequenceIdGenerator(sequenceGenerator, this.dialect, this.writeRelativeIds));\n\t\t\t}\n\t\t}\n\t\tfinal TableGenerator tableGenerator = element.getAnnotation(TableGenerator.class);\n\t\tif (tableGenerator != null) {\n\t\t\tfinal GeneratorId key = new GeneratorId(tableGenerator.name(), null);\n\t\t\tif (!this.generators.containsKey(key)) {\n\t\t\t\taddContextObject(this.generators, ContextModelListener::foundGenerator, key,\n\t\t\t\t\t\tnew TableIdGenerator(tableGenerator, this));\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Removes a listener from this context.\n\t *\n\t * @param listener\n\t *            the listener that is not interested anymore\n\t */\n\tpublic void removeContextModelListener(final ContextModelListener listener) {\n\t\tthis.contextModelListeners.remove(listener);\n\t}\n\t/**\n\t * Finds resp. builds the metadata to the given table.\n\t *\n\t * @param tableName\n\t *            the name of the table from the database\n\t * @return the metadata for the given table\n\t */\n\tpublic GeneratorTable resolveTable(final String tableName) {\n\t\tfinal GeneratorTable table = this.tables.get(tableName);\n\t\tif (table != null) {\n\t\t\treturn table;\n\t\t}\n\t\treturn addContextObject(this.tables, ContextModelListener::foundTable, tableName,\n\t\t\t\tnew GeneratorTable(this.tables.size(), tableName, this));\n\t}\n\t/**\n\t * Builds all statements that are necessary to align ID generators in the database with the current IDs.\n\t *\n\t * @param writer\n\t *            the target of any write operation\n\t * @throws IOException\n\t *             if the writer throws one\n\t */\n\tpublic void writeAlignmentStatements(final StatementsWriter writer) throws IOException {\n\t\tfor (final IdGenerator generator : this.generators.values()) {\n\t\t\tgenerator.alignNextValue(writer);\n\t\t}\n\t\tif (this.defaultSequenceGenerator != null) {\n\t\t\tthis.defaultSequenceGenerator.alignNextValue(writer);\n\t\t}\n\t\tif (this.defaultTableGenerator != null) {\n\t\t\tthis.defaultTableGenerator.alignNextValue(writer);\n\t\t}\n\t}\n"]]}
{"hexsha": "0e329b1f30629aebe33f9da7a79931d96525d81f", "ext": "java", "lang": "Java", "content": "class SequentialSearchST<Key, Value> {\n    private int N;\n    private Node first;\n    private class Node {\n        Key key;\n        Value val;\n        Node next;\n\n        public Node(Key key, Value val, Node next) {\n            this.key = key;\n            this.val = val;\n            this.next = next;\n        }\n    }\n\n    public Value get(Key key) {\n        for (Node x = first; x != null; x = x.next) {\n            if (key.equals(x.key)) return x.val;\n        }\n        return null;\n    }\n\n    public void put(Key key, Value val) {\n        for (Node x = first; x != null; x = x.next) {\n            if (key.equals(x.key)) {\n                x.val = val;\n                return;\n            }\n        }\n        first = new Node(key, val, first);\n        N++;\n    }\n\n    public Key delete(Key key) {\n        Node prev = null;\n        for (Node x = first; x != null; prev = x, x = x.next) {\n            if (key.equals(x.key)) {\n                prev.next = x.next;\n                N--;\n                return key;\n            }\n        }\n        return null;\n    }\n\n    public int size() {\n        return N;\n    }\n\n    public Iterable<Key> keys() {\n        List<Key> list = new ArrayList<Key>();\n        for (Node x = first; x != null; x = x.next) {\n            list.add(x.key);\n        }\n        return list;\n    }\n}", "class_id": 1, "repo": "HuangStomach/follow-gaylear", "file": "algs4/3.Search/3.4/Exercises/3.4.2.java", "last_update_at": "2020-06-20T13:28:56+00:00", "question_id": "0e329b1f30629aebe33f9da7a79931d96525d81f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class SequentialSearchST<Key, Value> {\n    private int N;\n    private Node first;\n    private class Node {\n        Key key;\n        Value val;\n        Node next;\n        public Node(Key key, Value val, Node next) {\n            this.key = key;\n            this.val = val;\n            this.next = next;\n        }\n    }\n    public Value get(Key key) {\n        for (Node x = first; x != null; x = x.next) {\n            if (key.equals(x.key)) return x.val;\n        }\n        return null;\n    }\n    public void put(Key key, Value val) {\n        for (Node x = first; x != null; x = x.next) {\n            if (key.equals(x.key)) {\n                x.val = val;\n                return;\n            }\n        }\n        first = new Node(key, val, first);\n        N++;\n    }\n    public Key delete(Key key) {\n        Node prev = null;\n        for (Node x = first; x != null; prev = x, x = x.next) {\n            if (key.equals(x.key)) {\n                prev.next = x.next;\n                N--;\n                return key;\n            }\n        }\n        return null;\n    }\n    public int size() {\n        return N;\n    }\n    public Iterable<Key> keys() {\n        List<Key> list = new ArrayList<Key>();\n        for (Node x = first; x != null; x = x.next) {\n            list.add(x.key);\n        }\n        return list;\n    }\n"]]}
{"hexsha": "ca6718a336d4b3b5c422d113ce1b8f56b8a3ab55", "ext": "java", "lang": "Java", "content": "public class SBTabDocument<T> implements TreeNodeChangeListener {\r\n\r\n\tprivate static final transient Logger LOGGER = LogManager.getLogger(SBTabController.class);\r\n\r\n\tprivate T tempDoc;\r\n\r\n\tprivate File tempDocFile;\r\n\r\n\tboolean changed;\r\n\r\n\t/**\r\n\t * Constructor for Document\r\n\t *\r\n\t * @param T doc\r\n\t * \r\n\t * @param File file\r\n\t */\r\n\tpublic SBTabDocument(T doc,File file) {\r\n\t\ttry {\r\n\t\t\ttempDoc = doc;\r\n\t\t\ttempDocFile = file;\r\n\r\n\t\t\tif (tempDoc instanceof AbstractTreeNode) {\r\n\t\t\t\t((AbstractTreeNode) tempDoc).addTreeNodeChangeListener(this);\r\n\t\t\t}\t\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\t\r\n\t\tchanged = false;\r\n\t}\r\n\r\n\r\n\t@Override\r\n\tpublic void propertyChange(PropertyChangeEvent evt) {\r\n\t\tSystem.out.println(\"change\");\r\n\t\tchanged = true;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void nodeAdded(TreeNode node) {\r\n\t\tSystem.out.println(\"new entry\");\r\n\t\tchanged = true;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void nodeRemoved(TreeNodeRemovedEvent event) {\r\n\t\tTreeNode parent = event.getPreviousParent();\r\n\t\tSystem.out.println(\"Child of \" + parent.toString() + \" removed\");\r\n\t\tchanged = true;\r\n\t}\r\n\t\r\n\tpublic void setTempDoc(T doc) {\r\n\t\ttempDoc=doc;\r\n\t}\r\n\t\r\n\tpublic T getTempDoc() {\r\n\t\treturn tempDoc;\r\n\t}\r\n\t\r\n\tpublic void setFile(File file) {\r\n\t\ttempDocFile=file;\r\n\t}\r\n\t\r\n\t/**\r\n\t * \r\n\t * @return temporary File or null\r\n\t */\r\n\tpublic File getFile() {\r\n\t\tif (tempDocFile!=null) {\r\n\t\treturn tempDocFile;\r\n\t\t}\r\n\t\telse return null;\r\n\t}\r\n\t\r\n\t/**\r\n\t * if document has unsaved changes, returns true \r\n\t * \r\n\t * @return boolean changed\r\n\t */\r\n\tpublic boolean getChanged() {\r\n\t\treturn changed;\r\n\t}\r\n\t\r\n\t/**\r\n\t * \r\n\t * @param bool \r\n\t */\r\n\tpublic void setChanged(boolean bool) {\r\n\t\tchanged=bool;\r\n\t}\r\n}", "class_id": 0, "repo": "draeger-lab/SBTabEditor", "file": "src/main/java/de/sbtab/controller/SBTabDocument.java", "last_update_at": "2020-02-15T01:06:43+00:00", "question_id": "ca6718a336d4b3b5c422d113ce1b8f56b8a3ab55", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SBTabDocument<T> implements TreeNodeChangeListener {\r\n\r\n\tprivate static final transient Logger LOGGER = LogManager.getLogger(SBTabController.class);\r\n\r\n\tprivate T tempDoc;\r\n\r\n\tprivate File tempDocFile;\r\n\r\n\tboolean changed;\r\n\r\n\t/**\r\n\t * Constructor for Document\r\n\t *\r\n\t * @param T doc\r\n\t * \r\n\t * @param File file\r\n\t */\r\n\tpublic SBTabDocument(T doc,File file) {\r\n\t\ttry {\r\n\t\t\ttempDoc = doc;\r\n\t\t\ttempDocFile = file;\r\n\r\n\t\t\tif (tempDoc instanceof AbstractTreeNode) {\r\n\t\t\t\t((AbstractTreeNode) tempDoc).addTreeNodeChangeListener(this);\r\n\t\t\t}\t\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\t\r\n\t\tchanged = false;\r\n\t}\r\n\r\n\r\n\t@Override\r\n\tpublic void propertyChange(PropertyChangeEvent evt) {\r\n\t\tSystem.out.println(\"change\");\r\n\t\tchanged = true;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void nodeAdded(TreeNode node) {\r\n\t\tSystem.out.println(\"new entry\");\r\n\t\tchanged = true;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void nodeRemoved(TreeNodeRemovedEvent event) {\r\n\t\tTreeNode parent = event.getPreviousParent();\r\n\t\tSystem.out.println(\"Child of \" + parent.toString() + \" removed\");\r\n\t\tchanged = true;\r\n\t}\r\n\t\r\n\tpublic void setTempDoc(T doc) {\r\n\t\ttempDoc=doc;\r\n\t}\r\n\t\r\n\tpublic T getTempDoc() {\r\n\t\treturn tempDoc;\r\n\t}\r\n\t\r\n\tpublic void setFile(File file) {\r\n\t\ttempDocFile=file;\r\n\t}\r\n\t\r\n\t/**\r\n\t * \r\n\t * @return temporary File or null\r\n\t */\r\n\tpublic File getFile() {\r\n\t\tif (tempDocFile!=null) {\r\n\t\treturn tempDocFile;\r\n\t\t}\r\n\t\telse return null;\r\n\t}\r\n\t\r\n\t/**\r\n\t * if document has unsaved changes, returns true \r\n\t * \r\n\t * @return boolean changed\r\n\t */\r\n\tpublic boolean getChanged() {\r\n\t\treturn changed;\r\n\t}\r\n\t\r\n\t/**\r\n\t * \r\n\t * @param bool \r\n\t */\r\n\tpublic void setChanged(boolean bool) {\r\n\t\tchanged=bool;\r\n\t}\r\n"]]}
{"hexsha": "6a5919bb5a1a6e3ceda0a214dc0fefe2dec4fd93", "ext": "java", "lang": "Java", "content": "@InjectionContainerContext(value = ModuleContainerForTests.class, disableRequiresNewTransaction = true)\n@RunWith(InjectionJUnitTestRunner.class)\n@TransactionAttribute\npublic class JPANewTransactionScopeDisabledUnitT {\n\n    @Inject\n    private TransactedApplication application;\n\n    @Inject\n    private TransactionManager transactionManager;\n\n    @BeforeClass\n    public static void initClass() {\n        TransactionLogging.enableLogging = true;\n    }\n\n    @AfterClass\n    public static void destroy() {\n        TransactionLogging.enableLogging = false;\n\n        /*\n\n        TODO: REDO this as the static context and the \"thread aware\" container will\n        always fail in strange ways\n\n        InjectContainer container = ModuleContainerForTests.container;\n        TransactedApplication application = container.get(TransactedApplication.class);\n        Collection<Person> persons = application.findAllPersons();\n\n        assertEquals(0, persons.size());\n        */\n\n    }\n\n\n    @Test\n    public void testSingleTransactionWithOpenMainTx2() {\n\n        Person person = StubUtil.createPerson();\n        application.createPersonNewTx(person);\n        // Rollback the transaction, will not rollback the req new (as it should be committed)\n        transactionManager.rollback();\n\n\n        Person foundPerson = application.findPerson(person.getId());\n        assertNull(foundPerson);\n\n\n        assertFalse(transactionManager.isActive());\n\n    }\n\n    @Test\n    public void testSingleTransaction2() {\n\n        Person person = StubUtil.createPerson();\n        Person foundPerson = application.depthyTransactionsNewTx(person);\n\n        assertEquals(foundPerson.getName(), person.getName());\n\n        assertTrue(transactionManager.isActive());\n\n    }\n\n    @Test\n    public void testSingleTransactionWithErrorAndLogging2() {\n\n        Person person = StubUtil.createPerson();\n        Logging log = StubUtil.createLogg(\"A log message\");\n        // This code can not work without REQUIRES_NEW and is just a proof of how the restrictions must be handled.\n\n        try {\n            Person foundPerson = application.complexTransactionsNewTx(person, log);\n            assertEquals(\"Expected error\", foundPerson.getName());\n        } catch (Exception e) {\n            assertEquals(\"Transaction is marked for rollback only\", e.getMessage());\n            assertFalse(transactionManager.isActive());\n        }\n    }\n\n}", "class_id": 0, "repo": "viktor-thell-seal/real-testing", "file": "plugin/inject-transaction/src/test/java/test/com/hrodberaht/inject/extension/transaction/JPANewTransactionScopeDisabledUnitT.java", "last_update_at": "2020-01-26T19:22:55+00:00", "question_id": "6a5919bb5a1a6e3ceda0a214dc0fefe2dec4fd93", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@InjectionContainerContext(value = ModuleContainerForTests.class, disableRequiresNewTransaction = true)\n@RunWith(InjectionJUnitTestRunner.class)\n@TransactionAttribute\npublic class JPANewTransactionScopeDisabledUnitT {\n    @Inject\n    private TransactedApplication application;\n    @Inject\n    private TransactionManager transactionManager;\n    @BeforeClass\n    public static void initClass() {\n        TransactionLogging.enableLogging = true;\n    }\n    @AfterClass\n    public static void destroy() {\n        TransactionLogging.enableLogging = false;\n        /*\n        TODO: REDO this as the static context and the \"thread aware\" container will\n        always fail in strange ways\n        InjectContainer container = ModuleContainerForTests.container;\n        TransactedApplication application = container.get(TransactedApplication.class);\n        Collection<Person> persons = application.findAllPersons();\n        assertEquals(0, persons.size());\n        */\n    }\n    @Test\n    public void testSingleTransactionWithOpenMainTx2() {\n        Person person = StubUtil.createPerson();\n        application.createPersonNewTx(person);\n        // Rollback the transaction, will not rollback the req new (as it should be committed)\n        transactionManager.rollback();\n        Person foundPerson = application.findPerson(person.getId());\n        assertNull(foundPerson);\n        assertFalse(transactionManager.isActive());\n    }\n    @Test\n    public void testSingleTransaction2() {\n        Person person = StubUtil.createPerson();\n        Person foundPerson = application.depthyTransactionsNewTx(person);\n        assertEquals(foundPerson.getName(), person.getName());\n        assertTrue(transactionManager.isActive());\n    }\n    @Test\n    public void testSingleTransactionWithErrorAndLogging2() {\n        Person person = StubUtil.createPerson();\n        Logging log = StubUtil.createLogg(\"A log message\");\n        // This code can not work without REQUIRES_NEW and is just a proof of how the restrictions must be handled.\n        try {\n            Person foundPerson = application.complexTransactionsNewTx(person, log);\n            assertEquals(\"Expected error\", foundPerson.getName());\n        } catch (Exception e) {\n            assertEquals(\"Transaction is marked for rollback only\", e.getMessage());\n            assertFalse(transactionManager.isActive());\n        }\n    }\n"]]}
{"hexsha": "d345998f428ae9625b0a6d0ea6e07bb3411208d0", "ext": "java", "lang": "Java", "content": "public class MainFormController {\n    public AnchorPane root;\n    public Label lblMainDate;\n    public ImageView imgItem;\n    public ImageView imgAgent;\n    public ImageView imgCompany;\n    public ImageView imgEmployee;\n    public ImageView imgOrder;\n    public Label lblMenu;\n    public Label lblDescription;\n\n    public void initialize (){\n        FadeTransition ft = new FadeTransition(Duration.millis(2000), root);\n        ft.setFromValue(0.0);\n        ft.setToValue(2.0);\n        ft.play();\n\n        //setCurrentDate\n        lblMainDate.setText(LocalDate.now()\n                + \" | \" + LocalTime.now().getHour()+\".\"+ LocalTime.now().getMinute());\n    }\n\n    public void navigate(javafx.scene.input.MouseEvent mouseEvent) throws IOException {\n        if (mouseEvent.getSource() instanceof ImageView){\n            ImageView icon = (ImageView) mouseEvent.getSource();\n\n            Parent root = null;\n\n            switch(icon.getId()){\n                case \"imgItem\":\n                    root = FXMLLoader.load(this.getClass().getResource(\"/view/ManageItemForm.fxml\"));\n                    break;\n                case \"imgAgent\":\n                    root = FXMLLoader.load(this.getClass().getResource(\"/view/ManageAgentForm.fxml\"));\n                    break;\n                case \"imgCompany\":\n                    root = FXMLLoader.load(this.getClass().getResource(\"/view/ManageCompanyForm.fxml\"));\n                    break;\n                case \"imgEmployee\":\n                    root = FXMLLoader.load(this.getClass().getResource(\"/view/ManageEmployeeForm.fxml\"));\n                    break;\n                case \"imgOrder\":\n                    root = FXMLLoader.load(this.getClass().getResource(\"/view/PlaceOrderForm.fxml\"));\n                    break;\n            }\n\n            if (root != null){\n                Scene subScene = new Scene(root);\n                Stage primaryStage = (Stage) this.root.getScene().getWindow();\n                primaryStage.setScene(subScene);\n                primaryStage.centerOnScreen();\n\n                TranslateTransition tt = new TranslateTransition(Duration.millis(350), subScene.getRoot());\n                tt.setFromX(-subScene.getWidth());\n                tt.setToX(0);\n                tt.play();\n\n            }\n        }\n    }\n\n    public void playMouseExitAnimation(MouseEvent mouseEvent) {\n        if (mouseEvent.getSource() instanceof ImageView){\n            ImageView icon = (ImageView) mouseEvent.getSource();\n            ScaleTransition scaleT =new ScaleTransition(Duration.millis(200), icon);\n            scaleT.setToX(1);\n            scaleT.setToY(1);\n            scaleT.play();\n\n            icon.setEffect(null);\n            lblMenu.setText(\"Welcome\");\n            lblDescription.setText(\"Please select one of above main operations to proceed\");\n        }\n    }\n\n    public void playMouseEnterAnimation(MouseEvent mouseEvent) {\n        if (mouseEvent.getSource() instanceof ImageView){\n            ImageView icon = (ImageView) mouseEvent.getSource();\n\n            switch(icon.getId()){\n                case \"imgItem\":\n                    lblMenu.setText(\"Manage Items\");\n                    lblDescription.setText(\"Click to add, edit, delete, search or view items\");\n                    break;\n                case \"imgAgent\":\n                    lblMenu.setText(\"Manage Agents\");\n                    lblDescription.setText(\"Click to add, edit, delete, search or view agents\");\n                    break;\n                case \"imgCompany\":\n                    lblMenu.setText(\"Manage Companies\");\n                    lblDescription.setText(\"Click to add, edit, delete, search or view companies\");\n                    break;\n                case \"imgEmployee\":\n                    lblMenu.setText(\"Manage Employees\");\n                    lblDescription.setText(\"Click to add, edit, delete, search or view employees\");\n                    break;\n                case \"imgOrder\":\n                    lblMenu.setText(\"Place Orders\");\n                    lblDescription.setText(\"Click if you want to place orders or manage orders\");\n                    break;\n            }\n\n            ScaleTransition scaleT =new ScaleTransition(Duration.millis(200), icon);\n            scaleT.setToX(1.2);\n            scaleT.setToY(1.2);\n            scaleT.play();\n\n            DropShadow glow = new DropShadow();\n            glow.setColor(Color.CORNFLOWERBLUE);\n            glow.setWidth(20);\n            glow.setHeight(20);\n            glow.setRadius(20);\n            icon.setEffect(glow);\n        }\n    }\n}", "class_id": 0, "repo": "nchathura/Lyfe-Pharmacy", "file": "src/controller/MainFormController.java", "last_update_at": "2020-08-05T08:23:01+00:00", "question_id": "d345998f428ae9625b0a6d0ea6e07bb3411208d0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MainFormController {\n    public AnchorPane root;\n    public Label lblMainDate;\n    public ImageView imgItem;\n    public ImageView imgAgent;\n    public ImageView imgCompany;\n    public ImageView imgEmployee;\n    public ImageView imgOrder;\n    public Label lblMenu;\n    public Label lblDescription;\n    public void initialize (){\n        FadeTransition ft = new FadeTransition(Duration.millis(2000), root);\n        ft.setFromValue(0.0);\n        ft.setToValue(2.0);\n        ft.play();\n        //setCurrentDate\n        lblMainDate.setText(LocalDate.now()\n                + \" | \" + LocalTime.now().getHour()+\".\"+ LocalTime.now().getMinute());\n    }\n    public void navigate(javafx.scene.input.MouseEvent mouseEvent) throws IOException {\n        if (mouseEvent.getSource() instanceof ImageView){\n            ImageView icon = (ImageView) mouseEvent.getSource();\n            Parent root = null;\n            switch(icon.getId()){\n                case \"imgItem\":\n                    root = FXMLLoader.load(this.getClass().getResource(\"/view/ManageItemForm.fxml\"));\n                    break;\n                case \"imgAgent\":\n                    root = FXMLLoader.load(this.getClass().getResource(\"/view/ManageAgentForm.fxml\"));\n                    break;\n                case \"imgCompany\":\n                    root = FXMLLoader.load(this.getClass().getResource(\"/view/ManageCompanyForm.fxml\"));\n                    break;\n                case \"imgEmployee\":\n                    root = FXMLLoader.load(this.getClass().getResource(\"/view/ManageEmployeeForm.fxml\"));\n                    break;\n                case \"imgOrder\":\n                    root = FXMLLoader.load(this.getClass().getResource(\"/view/PlaceOrderForm.fxml\"));\n                    break;\n            }\n            if (root != null){\n                Scene subScene = new Scene(root);\n                Stage primaryStage = (Stage) this.root.getScene().getWindow();\n                primaryStage.setScene(subScene);\n                primaryStage.centerOnScreen();\n                TranslateTransition tt = new TranslateTransition(Duration.millis(350), subScene.getRoot());\n                tt.setFromX(-subScene.getWidth());\n                tt.setToX(0);\n                tt.play();\n            }\n        }\n    }\n    public void playMouseExitAnimation(MouseEvent mouseEvent) {\n        if (mouseEvent.getSource() instanceof ImageView){\n            ImageView icon = (ImageView) mouseEvent.getSource();\n            ScaleTransition scaleT =new ScaleTransition(Duration.millis(200), icon);\n            scaleT.setToX(1);\n            scaleT.setToY(1);\n            scaleT.play();\n            icon.setEffect(null);\n            lblMenu.setText(\"Welcome\");\n            lblDescription.setText(\"Please select one of above main operations to proceed\");\n        }\n    }\n    public void playMouseEnterAnimation(MouseEvent mouseEvent) {\n        if (mouseEvent.getSource() instanceof ImageView){\n            ImageView icon = (ImageView) mouseEvent.getSource();\n            switch(icon.getId()){\n                case \"imgItem\":\n                    lblMenu.setText(\"Manage Items\");\n                    lblDescription.setText(\"Click to add, edit, delete, search or view items\");\n                    break;\n                case \"imgAgent\":\n                    lblMenu.setText(\"Manage Agents\");\n                    lblDescription.setText(\"Click to add, edit, delete, search or view agents\");\n                    break;\n                case \"imgCompany\":\n                    lblMenu.setText(\"Manage Companies\");\n                    lblDescription.setText(\"Click to add, edit, delete, search or view companies\");\n                    break;\n                case \"imgEmployee\":\n                    lblMenu.setText(\"Manage Employees\");\n                    lblDescription.setText(\"Click to add, edit, delete, search or view employees\");\n                    break;\n                case \"imgOrder\":\n                    lblMenu.setText(\"Place Orders\");\n                    lblDescription.setText(\"Click if you want to place orders or manage orders\");\n                    break;\n            }\n            ScaleTransition scaleT =new ScaleTransition(Duration.millis(200), icon);\n            scaleT.setToX(1.2);\n            scaleT.setToY(1.2);\n            scaleT.play();\n            DropShadow glow = new DropShadow();\n            glow.setColor(Color.CORNFLOWERBLUE);\n            glow.setWidth(20);\n            glow.setHeight(20);\n            glow.setRadius(20);\n            icon.setEffect(glow);\n        }\n    }\n"]]}
{"hexsha": "105268f0a720ff7f616d129d86e10494ec305a22", "ext": "java", "lang": "Java", "content": "@Component(\"guiaDetalleMapper\")\npublic class GuiaDetalleMapper implements Mapper<GuiaDetallesDTO, GuiaDetalles> {\n\n    private Mapper<DetAdicionalDTO, DetAdicional> detAdicionalMapper;\n\n    @Override\n    public GuiaDetalles convert(final GuiaDetallesDTO guiaDetallesDTO) {\n        if (guiaDetallesDTO == null) {\n            return null;\n        }\n        final GuiaDetalles detalle = new GuiaDetalles();\n        detalle.setCodigoInterno(guiaDetallesDTO.getCodigoInterno());\n        detalle.setCodigoAdicional(guiaDetallesDTO.getCodigoAdicional());\n        detalle.setDescripcion(guiaDetallesDTO.getDescripcion());\n        detalle.setCantidad(guiaDetallesDTO.getCantidad());\n        detalle.setDetAdicional(getDetAdicionalMapper().convertAll(guiaDetallesDTO.getDetAdicional()));\n        return detalle;\n    }\n\n    protected Mapper<DetAdicionalDTO, DetAdicional> getDetAdicionalMapper() {\n        return detAdicionalMapper;\n    }\n\n    @Autowired\n    @Qualifier(\"detAdicionalMapper\")\n    public void setDetAdicionalMapper(Mapper<DetAdicionalDTO, DetAdicional> detAdicionalMapper) {\n        this.detAdicionalMapper = detAdicionalMapper;\n    }\n    \n}", "class_id": 0, "repo": "marlonalexis/veronica", "file": "veronica-mapper/src/main/java/com/rolandopalermo/facturacion/ec/mapper/bol/GuiaDetalleMapper.java", "last_update_at": "2020-06-03T14:12:31+00:00", "question_id": "105268f0a720ff7f616d129d86e10494ec305a22", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component(\"guiaDetalleMapper\")\npublic class GuiaDetalleMapper implements Mapper<GuiaDetallesDTO, GuiaDetalles> {\n    private Mapper<DetAdicionalDTO, DetAdicional> detAdicionalMapper;\n    @Override\n    public GuiaDetalles convert(final GuiaDetallesDTO guiaDetallesDTO) {\n        if (guiaDetallesDTO == null) {\n            return null;\n        }\n        final GuiaDetalles detalle = new GuiaDetalles();\n        detalle.setCodigoInterno(guiaDetallesDTO.getCodigoInterno());\n        detalle.setCodigoAdicional(guiaDetallesDTO.getCodigoAdicional());\n        detalle.setDescripcion(guiaDetallesDTO.getDescripcion());\n        detalle.setCantidad(guiaDetallesDTO.getCantidad());\n        detalle.setDetAdicional(getDetAdicionalMapper().convertAll(guiaDetallesDTO.getDetAdicional()));\n        return detalle;\n    }\n    protected Mapper<DetAdicionalDTO, DetAdicional> getDetAdicionalMapper() {\n        return detAdicionalMapper;\n    }\n    @Autowired\n    @Qualifier(\"detAdicionalMapper\")\n    public void setDetAdicionalMapper(Mapper<DetAdicionalDTO, DetAdicional> detAdicionalMapper) {\n        this.detAdicionalMapper = detAdicionalMapper;\n    }\n"]]}
{"hexsha": "b483f3bd9f9de9ef18cf4706a05bf986224b5487", "ext": "java", "lang": "Java", "content": "public class MathFFT {\n\n    public static double log2(double N)\n    {\n\n        // calculate log2 N indirectly\n        // using log() method\n\n        return (Math.log(N) / Math.log(2));\n    }\n\n}", "class_id": 0, "repo": "Dunateo/Music-analyz", "file": "src/main/java/model/math/MathFFT.java", "last_update_at": "2020-11-16T16:20:41+00:00", "question_id": "b483f3bd9f9de9ef18cf4706a05bf986224b5487", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MathFFT {\n    public static double log2(double N)\n    {\n        // calculate log2 N indirectly\n        // using log() method\n        return (Math.log(N) / Math.log(2));\n    }\n"]]}
{"hexsha": "f3909e6a2afaf2dfbe0b062794b512f8ba17e02a", "ext": "java", "lang": "Java", "content": "public final class GetFileHash {\n\n  private static final byte HORIZONTAL_TAB = 9;\n  private static final byte LINE_FEED = 10;\n  private static final byte CARRIAGE_RETURN = 13;\n  private static final byte SPACE = 32;\n\n  private GetFileHash() {}\n\n  // Gets the 32-bit MurmurHash2 of the .jar file\n  public static long getFileHash(Path path) throws IOException {\n\n    // Reads .jar file and turns it into byte[]\n    byte[] fileByteArray = Files.readAllBytes(path);\n\n    // ArrayList with no whitespace\n    List<Byte> noWs = new ArrayList<>();\n\n    // Remove any whitespace characters\n    for (byte b : fileByteArray) {\n      if (!isWhitespaceCharacter(b)) {\n        noWs.add(b);\n      }\n    }\n\n    // Convert Byte ArrayList to byte array\n    byte[] result = new byte[noWs.size()];\n    for (int i = 0; i < noWs.size(); i++) {\n      result[i] = noWs.get(i).byteValue();\n    }\n\n    return Murmur2.hash(result, result.length, 1);\n\n  }\n\n  // Determines if the byte is a whitespace character (look at an ASCII table)\n  private static boolean isWhitespaceCharacter(byte b) {\n    return b == HORIZONTAL_TAB || b == LINE_FEED || b == CARRIAGE_RETURN || b == SPACE;\n  }\n\n}", "class_id": 0, "repo": "Hextical/updater", "file": "src/main/java/com/hexii/updater/filehandler/GetFileHash.java", "last_update_at": "2020-04-22T03:50:11+00:00", "question_id": "f3909e6a2afaf2dfbe0b062794b512f8ba17e02a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class GetFileHash {\n  private static final byte HORIZONTAL_TAB = 9;\n  private static final byte LINE_FEED = 10;\n  private static final byte CARRIAGE_RETURN = 13;\n  private static final byte SPACE = 32;\n  private GetFileHash() {}\n  // Gets the 32-bit MurmurHash2 of the .jar file\n  public static long getFileHash(Path path) throws IOException {\n    // Reads .jar file and turns it into byte[]\n    byte[] fileByteArray = Files.readAllBytes(path);\n    // ArrayList with no whitespace\n    List<Byte> noWs = new ArrayList<>();\n    // Remove any whitespace characters\n    for (byte b : fileByteArray) {\n      if (!isWhitespaceCharacter(b)) {\n        noWs.add(b);\n      }\n    }\n    // Convert Byte ArrayList to byte array\n    byte[] result = new byte[noWs.size()];\n    for (int i = 0; i < noWs.size(); i++) {\n      result[i] = noWs.get(i).byteValue();\n    }\n    return Murmur2.hash(result, result.length, 1);\n  }\n  // Determines if the byte is a whitespace character (look at an ASCII table)\n  private static boolean isWhitespaceCharacter(byte b) {\n    return b == HORIZONTAL_TAB || b == LINE_FEED || b == CARRIAGE_RETURN || b == SPACE;\n  }\n"]]}
{"hexsha": "087d155b749678dc43772e44a9501b8e591257d7", "ext": "java", "lang": "Java", "content": "public class ImageEntityDefinition {\n    private final double myHeight;\n    private final double myWidth;\n    private final String myImageLocation;\n    private final List<ConditionalBehavior> myBehaviors;\n    private final String myName;\n    private Map<String, String> myVariables = new HashMap<>();\n    private boolean stationary = false;\n\n    /**\n     * @param name The Name identifying the type of entity.\n     * @param height The starting height of entity instances.\n     * @param width The starting height of entity instances.\n     * @param imageLocation The String with the filepath of this entity's image.\n     * @param behaviors The List of conditional behaviors that entity instances will execute.\n     */\n    public ImageEntityDefinition(String name, double height, double width, String imageLocation, List<ConditionalBehavior> behaviors){\n        myName = name;\n        myHeight = height;\n        myWidth = width;\n        myImageLocation = imageLocation;\n        myBehaviors = behaviors;\n    }\n\n    /**\n     * Creates an instance of this Entity type at a specified location.\n     * @param xpos The X position of the created instance.\n     * @param ypos The Y position of the created instance.\n     * @return An instance of this definition's type at the specified location.\n     */\n    public ImageEntity makeInstanceAt(Double xpos, Double ypos){\n        ImageEntity newEntity = new ImageEntity(myName, myImageLocation, xpos, ypos, myWidth, myHeight);\n        newEntity.setConditionalBehaviors(myBehaviors);\n        newEntity.setVariables(myVariables);\n        newEntity.makeNonStationaryProperty(stationary);\n        return newEntity;\n    }\n\n    /**\n     * @return The String representation of this entity type.\n     */\n    @Override\n    public String toString() {\n        return myName + \": (\" + myHeight + \" x \" + myWidth + \")\";\n    }\n\n    /**\n     * @return The starting height of entity instances.\n     */\n    public double getHeight() {\n        return myHeight;\n    }\n\n    /**\n     * @return The starting height of entity instances.\n     */\n    public double getWidth() {\n        return myWidth;\n    }\n\n    /**\n     * @param entityVariables The starting names and values of variables created instances should have.\n     */\n    public void setVariables(Map<String, String> entityVariables) { myVariables = entityVariables; }\n\n    /**\n     * @param isStationary True if this entity should NOT move onscreen based on camera moves.\n     */\n    public void setStationary(boolean isStationary){stationary = isStationary;}\n\n    /**\n     * @return True if this entity does NOT move onscreen based on camera moves.\n     */\n    public boolean getStationary() {\n        return stationary;\n    }\n}", "class_id": 0, "repo": "samuel-thompsonn/game-engine-public-copy", "file": "src/ooga/data/entities/ImageEntityDefinition.java", "last_update_at": "2020-11-02T15:52:12+00:00", "question_id": "087d155b749678dc43772e44a9501b8e591257d7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ImageEntityDefinition {\n    private final double myHeight;\n    private final double myWidth;\n    private final String myImageLocation;\n    private final List<ConditionalBehavior> myBehaviors;\n    private final String myName;\n    private Map<String, String> myVariables = new HashMap<>();\n    private boolean stationary = false;\n    /**\n     * @param name The Name identifying the type of entity.\n     * @param height The starting height of entity instances.\n     * @param width The starting height of entity instances.\n     * @param imageLocation The String with the filepath of this entity's image.\n     * @param behaviors The List of conditional behaviors that entity instances will execute.\n     */\n    public ImageEntityDefinition(String name, double height, double width, String imageLocation, List<ConditionalBehavior> behaviors){\n        myName = name;\n        myHeight = height;\n        myWidth = width;\n        myImageLocation = imageLocation;\n        myBehaviors = behaviors;\n    }\n    /**\n     * Creates an instance of this Entity type at a specified location.\n     * @param xpos The X position of the created instance.\n     * @param ypos The Y position of the created instance.\n     * @return An instance of this definition's type at the specified location.\n     */\n    public ImageEntity makeInstanceAt(Double xpos, Double ypos){\n        ImageEntity newEntity = new ImageEntity(myName, myImageLocation, xpos, ypos, myWidth, myHeight);\n        newEntity.setConditionalBehaviors(myBehaviors);\n        newEntity.setVariables(myVariables);\n        newEntity.makeNonStationaryProperty(stationary);\n        return newEntity;\n    }\n    /**\n     * @return The String representation of this entity type.\n     */\n    @Override\n    public String toString() {\n        return myName + \": (\" + myHeight + \" x \" + myWidth + \")\";\n    }\n    /**\n     * @return The starting height of entity instances.\n     */\n    public double getHeight() {\n        return myHeight;\n    }\n    /**\n     * @return The starting height of entity instances.\n     */\n    public double getWidth() {\n        return myWidth;\n    }\n    /**\n     * @param entityVariables The starting names and values of variables created instances should have.\n     */\n    public void setVariables(Map<String, String> entityVariables) { myVariables = entityVariables; }\n    /**\n     * @param isStationary True if this entity should NOT move onscreen based on camera moves.\n     */\n    public void setStationary(boolean isStationary){stationary = isStationary;}\n    /**\n     * @return True if this entity does NOT move onscreen based on camera moves.\n     */\n    public boolean getStationary() {\n        return stationary;\n    }\n"]]}
{"hexsha": "65bf28103b1aa0b286f52418bbf009864303ce59", "ext": "java", "lang": "Java", "content": "public class APDUTransceiveSuccessfulResponseTest {\n\n    @Test\n    public void testFromPayload() throws Exception {\n        byte[] apdu = new byte[]{(byte) 0x00,(byte) 0x03,(byte) 0x53,(byte) 0xFE, (byte) 0xA5};\n        APDUTransceiveSuccessfulResponse transceiveApduCommand = new APDUTransceiveSuccessfulResponse();\n        transceiveApduCommand.parsePayload(apdu);\n        assertArrayEquals(transceiveApduCommand.getPayload(),apdu);\n    }\n\n    @Test\n    public void testGetPayload() throws Exception {\n        byte[] apdu = new byte[]{(byte) 0x00,(byte) 0x03,(byte) 0x53,(byte) 0xFE, (byte) 0xA5};\n        APDUTransceiveSuccessfulResponse transceiveApduCommand = new APDUTransceiveSuccessfulResponse(apdu);\n        assertArrayEquals(transceiveApduCommand.getPayload(),apdu);\n    }\n\n    @Test\n    public void testGetCommandCode() throws Exception {\n        APDUTransceiveSuccessfulResponse transceiveApduCommand = new APDUTransceiveSuccessfulResponse();\n        assertEquals(transceiveApduCommand.getCommandCode(),(byte)0x02);\n    }\n\n    @Test\n    public void testGetCommandFamily() throws Exception {\n        APDUTransceiveSuccessfulResponse transceiveApduCommand = new APDUTransceiveSuccessfulResponse();\n        assertArrayEquals(transceiveApduCommand.getCommandFamily(),new byte[]{0x00,0x04});\n    }\n}", "class_id": 0, "repo": "TapTrack/TCMPTappy-Android", "file": "commandfamily-type4/src/test/java/com/taptrack/tcmptappy2/commandfamilies/type4/responses/APDUTransceiveSuccessfulResponseTest.java", "last_update_at": "2020-06-02T04:37:38+00:00", "question_id": "65bf28103b1aa0b286f52418bbf009864303ce59", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class APDUTransceiveSuccessfulResponseTest {\n    @Test\n    public void testFromPayload() throws Exception {\n        byte[] apdu = new byte[]{(byte) 0x00,(byte) 0x03,(byte) 0x53,(byte) 0xFE, (byte) 0xA5};\n        APDUTransceiveSuccessfulResponse transceiveApduCommand = new APDUTransceiveSuccessfulResponse();\n        transceiveApduCommand.parsePayload(apdu);\n        assertArrayEquals(transceiveApduCommand.getPayload(),apdu);\n    }\n    @Test\n    public void testGetPayload() throws Exception {\n        byte[] apdu = new byte[]{(byte) 0x00,(byte) 0x03,(byte) 0x53,(byte) 0xFE, (byte) 0xA5};\n        APDUTransceiveSuccessfulResponse transceiveApduCommand = new APDUTransceiveSuccessfulResponse(apdu);\n        assertArrayEquals(transceiveApduCommand.getPayload(),apdu);\n    }\n    @Test\n    public void testGetCommandCode() throws Exception {\n        APDUTransceiveSuccessfulResponse transceiveApduCommand = new APDUTransceiveSuccessfulResponse();\n        assertEquals(transceiveApduCommand.getCommandCode(),(byte)0x02);\n    }\n    @Test\n    public void testGetCommandFamily() throws Exception {\n        APDUTransceiveSuccessfulResponse transceiveApduCommand = new APDUTransceiveSuccessfulResponse();\n        assertArrayEquals(transceiveApduCommand.getCommandFamily(),new byte[]{0x00,0x04});\n    }\n"]]}
{"hexsha": "d7aa85b09a9222d12a401472dc73286720a10017", "ext": "java", "lang": "Java", "content": "public class GeneTreeHomologyReader{\n\tpublic static void main(String[] args)  throws IOException, NewickIOException {\n\t\tif(args.length != 1){\n\t\t\tSystem.err.println(\"Usage: java -classpath jprime.jar se.cbb.jprime.apps.phylotools.GeneTreeHomologyReader gene_tree_name\");\n\t\t\tSystem.out.println(\"Exiting now...\");\n\t\t\tSystem.exit(1);\n\t\t}\n\t\tSystem.out.println(\"Input true reconciliation file is \" + args[0]);\t\t\t\t\t\t\t\t\n\t\tString treepath = parseTreeFromReconciliationFile(args[0]);\n\t\tFile gFile = new File(treepath);\n\t\tBufferedWriter writer = new BufferedWriter(new FileWriter(args[0]+\".original\"));\n\t\t\n\t\tPrIMENewickTree sRaw = PrIMENewickTreeReader.readTree(gFile, false, true);\n\t\t//System.out.println(\"Tree is \" + sRaw.toString());\n\t\t//System.out.println(sRaw.toString());\t\t\n\t\tSystem.out.println(\"Extracting true reconciliation events...\");\n\t\tSystem.out.println(\"The tree is : \" + sRaw);\n\t\tList<NewickVertex> vertices = sRaw.getVerticesAsList();\n\t\tint[] dupStatus = sRaw.getVertexDuplicationValues();\n\t\tfor (NewickVertex v : vertices) {\n\t\t\tint id = v.getNumber();\n\t\t\tif(dupStatus[id] != Integer.MAX_VALUE){\n\t\t\t\tArrayList<NewickVertex> children = v.getChildren();\n\t\t\t\t//String lchild = getLeafIds(children.get(0));\n\t\t\t\t//String rchild = getLeafIds(children.get(1));\n\t\t\t\tString lchild = getLeafNames(children.get(0));\n\t\t\t\tString rchild = getLeafNames(children.get(1));\n\t\t\t\t//System.out.println(\"The childern ids are \" + lchild + \" and \" + rchild);\n\t\t\t\t//System.out.println(\"The node number \" + id + \" has dupStatus = \" + dupStatus[id]);\n\t\t\t\twriter.write(\"[\"+lchild+\", \"+rchild+\"]\"+\"\\t\"+dupStatus[id]+\"\\n\");\n\t\t\t\tSystem.out.println(\"[\"+lchild+\", \"+rchild+\"]\"+\"\\t\"+dupStatus[id]);\n\t\t\t}\n\t\t}\n\t\twriter.flush();\n\t\twriter.close();\n\t\tgFile.deleteOnExit();\n\t\tSystem.out.println(\"Done...\");\n\t\tSystem.out.println(\"True values has been written to \" + args[0]+\".original\");\n\t}\n\t\n\tprivate static String parseTreeFromReconciliationFile(String fileName) {\n\t\ttry {\n\t\t\tString gfileName = \"treeFromReconFile.tree\";\n\t\t\tFile f = new File(gfileName);\n\t\t\tif(f.exists())\n\t\t\t    f.delete();\n\t\t\tBufferedReader buf = new BufferedReader(new FileReader(fileName));\n\t\t\tBufferedWriter bw = new BufferedWriter(new FileWriter(gfileName));\t\t\n\t\t\tString line = \"\";\n\t\t\twhile((line = buf.readLine()) != null){\n\t\t\t\tline = line.trim();\n\t\t\t\tif(line.charAt(0) == '#')\n\t\t\t\t\tcontinue;\n\t\t\t\telse {\n\t//\t\t\t\tStringTokenizer stk = new StringTokenizer(line);\n\t//\t\t\t\tString tree = \"\";\n\t//\t\t\t\t\n\t//\t\t\t\t// true reconciliations is the last token\n\t//\t\t\t\twhile(stk.hasMoreTokens())\n\t//\t\t\t\t\ttree = stk.nextToken();\n\t\t\t\t\tString[] token = line.split(\";\");\n\t\t\t\t\t\n\t\t\t\t\tString trueFile = \"\";\n\t\t\t\t\tif(token.length == 1)\n\t\t\t\t\t\ttrueFile = token[0].trim();\n\t\t\t\t\telse\n\t\t\t\t\t\ttrueFile = token[4].trim();\n\t\t\t\t\tbw.write(trueFile);\n\t\t\t\t\tbw.flush();\n\t\t\t\t\tbw.close();\n\t\t\t\t\tbuf.close();\n\t\t\t\t\t\n\t\t\t\t\treturn gfileName;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbw.flush();\n\t\t\tbw.close();\n\t\t\tbuf.close();\n\t\t}catch(Exception ex){\n\t\t\tSystem.err.println(\"Error in reading reconciliation file\");\n\t\t\tSystem.err.println(\"Reason: \" + ex.getMessage());\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static String getLeafNames(NewickVertex vertex){\t\t \n\t\t String lNames = getLeafNamesRecursive(vertex);\n\t\treturn lNames;\n\t}\n\n\tprivate static String getLeafNamesRecursive(NewickVertex vertex) {\n\t\tif(vertex.isLeaf())\n\t\t\treturn vertex.getName();\n\t\telse {\n\t\t\tArrayList<NewickVertex> ch = vertex.getChildren();\n\t\t\treturn getLeafNamesRecursive(ch.get(0)) + \" \" + getLeafNamesRecursive(ch.get(1));\n\t\t}\n\t}\n\t\n\tpublic static String getLeafIds(NewickVertex vertex){\n\t\tString lNames = \"\";\n\t\tlNames += getLeafIdsRecursive(vertex);\n\t\treturn lNames + \"\";\n\t}\n\n\tprivate static String getLeafIdsRecursive(NewickVertex vertex) {\n\t\tif(vertex.isLeaf())\n\t\t\treturn vertex.getNumber()+\"\";\n\t\telse {\n\t\t\tArrayList<NewickVertex> ch = vertex.getChildren();\n\t\t\treturn getLeafIdsRecursive(ch.get(0)) + \" \" + getLeafIdsRecursive(ch.get(1));\n\t\t}\n\t}\n}", "class_id": 0, "repo": "edvinvp/jprime", "file": "src/main/java/se/cbb/jprime/apps/phylotools/GeneTreeHomologyReader.java", "last_update_at": "2020-09-04T13:53:04+00:00", "question_id": "d7aa85b09a9222d12a401472dc73286720a10017", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GeneTreeHomologyReader{\n\tpublic static void main(String[] args)  throws IOException, NewickIOException {\n\t\tif(args.length != 1){\n\t\t\tSystem.err.println(\"Usage: java -classpath jprime.jar se.cbb.jprime.apps.phylotools.GeneTreeHomologyReader gene_tree_name\");\n\t\t\tSystem.out.println(\"Exiting now...\");\n\t\t\tSystem.exit(1);\n\t\t}\n\t\tSystem.out.println(\"Input true reconciliation file is \" + args[0]);\t\t\t\t\t\t\t\t\n\t\tString treepath = parseTreeFromReconciliationFile(args[0]);\n\t\tFile gFile = new File(treepath);\n\t\tBufferedWriter writer = new BufferedWriter(new FileWriter(args[0]+\".original\"));\n\t\t\n\t\tPrIMENewickTree sRaw = PrIMENewickTreeReader.readTree(gFile, false, true);\n\t\t//System.out.println(\"Tree is \" + sRaw.toString());\n\t\t//System.out.println(sRaw.toString());\t\t\n\t\tSystem.out.println(\"Extracting true reconciliation events...\");\n\t\tSystem.out.println(\"The tree is : \" + sRaw);\n\t\tList<NewickVertex> vertices = sRaw.getVerticesAsList();\n\t\tint[] dupStatus = sRaw.getVertexDuplicationValues();\n\t\tfor (NewickVertex v : vertices) {\n\t\t\tint id = v.getNumber();\n\t\t\tif(dupStatus[id] != Integer.MAX_VALUE){\n\t\t\t\tArrayList<NewickVertex> children = v.getChildren();\n\t\t\t\t//String lchild = getLeafIds(children.get(0));\n\t\t\t\t//String rchild = getLeafIds(children.get(1));\n\t\t\t\tString lchild = getLeafNames(children.get(0));\n\t\t\t\tString rchild = getLeafNames(children.get(1));\n\t\t\t\t//System.out.println(\"The childern ids are \" + lchild + \" and \" + rchild);\n\t\t\t\t//System.out.println(\"The node number \" + id + \" has dupStatus = \" + dupStatus[id]);\n\t\t\t\twriter.write(\"[\"+lchild+\", \"+rchild+\"]\"+\"\\t\"+dupStatus[id]+\"\\n\");\n\t\t\t\tSystem.out.println(\"[\"+lchild+\", \"+rchild+\"]\"+\"\\t\"+dupStatus[id]);\n\t\t\t}\n\t\t}\n\t\twriter.flush();\n\t\twriter.close();\n\t\tgFile.deleteOnExit();\n\t\tSystem.out.println(\"Done...\");\n\t\tSystem.out.println(\"True values has been written to \" + args[0]+\".original\");\n\t}\n\t\n\tprivate static String parseTreeFromReconciliationFile(String fileName) {\n\t\ttry {\n\t\t\tString gfileName = \"treeFromReconFile.tree\";\n\t\t\tFile f = new File(gfileName);\n\t\t\tif(f.exists())\n\t\t\t    f.delete();\n\t\t\tBufferedReader buf = new BufferedReader(new FileReader(fileName));\n\t\t\tBufferedWriter bw = new BufferedWriter(new FileWriter(gfileName));\t\t\n\t\t\tString line = \"\";\n\t\t\twhile((line = buf.readLine()) != null){\n\t\t\t\tline = line.trim();\n\t\t\t\tif(line.charAt(0) == '#')\n\t\t\t\t\tcontinue;\n\t\t\t\telse {\n\t//\t\t\t\tStringTokenizer stk = new StringTokenizer(line);\n\t//\t\t\t\tString tree = \"\";\n\t//\t\t\t\t\n\t//\t\t\t\t// true reconciliations is the last token\n\t//\t\t\t\twhile(stk.hasMoreTokens())\n\t//\t\t\t\t\ttree = stk.nextToken();\n\t\t\t\t\tString[] token = line.split(\";\");\n\t\t\t\t\t\n\t\t\t\t\tString trueFile = \"\";\n\t\t\t\t\tif(token.length == 1)\n\t\t\t\t\t\ttrueFile = token[0].trim();\n\t\t\t\t\telse\n\t\t\t\t\t\ttrueFile = token[4].trim();\n\t\t\t\t\tbw.write(trueFile);\n\t\t\t\t\tbw.flush();\n\t\t\t\t\tbw.close();\n\t\t\t\t\tbuf.close();\n\t\t\t\t\t\n\t\t\t\t\treturn gfileName;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbw.flush();\n\t\t\tbw.close();\n\t\t\tbuf.close();\n\t\t}catch(Exception ex){\n\t\t\tSystem.err.println(\"Error in reading reconciliation file\");\n\t\t\tSystem.err.println(\"Reason: \" + ex.getMessage());\n\t\t}\n\t\treturn null;\n\t}\n\tpublic static String getLeafNames(NewickVertex vertex){\t\t \n\t\t String lNames = getLeafNamesRecursive(vertex);\n\t\treturn lNames;\n\t}\n\tprivate static String getLeafNamesRecursive(NewickVertex vertex) {\n\t\tif(vertex.isLeaf())\n\t\t\treturn vertex.getName();\n\t\telse {\n\t\t\tArrayList<NewickVertex> ch = vertex.getChildren();\n\t\t\treturn getLeafNamesRecursive(ch.get(0)) + \" \" + getLeafNamesRecursive(ch.get(1));\n\t\t}\n\t}\n\t\n\tpublic static String getLeafIds(NewickVertex vertex){\n\t\tString lNames = \"\";\n\t\tlNames += getLeafIdsRecursive(vertex);\n\t\treturn lNames + \"\";\n\t}\n\tprivate static String getLeafIdsRecursive(NewickVertex vertex) {\n\t\tif(vertex.isLeaf())\n\t\t\treturn vertex.getNumber()+\"\";\n\t\telse {\n\t\t\tArrayList<NewickVertex> ch = vertex.getChildren();\n\t\t\treturn getLeafIdsRecursive(ch.get(0)) + \" \" + getLeafIdsRecursive(ch.get(1));\n\t\t}\n\t}\n"]]}
{"hexsha": "02e655cc0cdb7b64e1985ab4e63200e8b36b4491", "ext": "java", "lang": "Java", "content": "public class BottleRefill {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int num, count;\n        while (sc.hasNextInt()) {\n            num = sc.nextInt();\n            if (num == 0) {\n                break;\n            }\n            count = 0;\n            while (num >= 2) {\n                count += num / 3;\n                num = num / 3 + num % 3;\n                if (num == 2) {\n                    count++;\n                    break;\n                }\n            }\n            System.out.printf(\"%d \", count);\n        }\n        sc.close();\n    }\n}", "class_id": 0, "repo": "cyp0633/homework", "file": "ObjectProgramming/two/bottle/BottleRefill.java", "last_update_at": "2020-12-14T08:52:40+00:00", "question_id": "02e655cc0cdb7b64e1985ab4e63200e8b36b4491", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BottleRefill {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int num, count;\n        while (sc.hasNextInt()) {\n            num = sc.nextInt();\n            if (num == 0) {\n                break;\n            }\n            count = 0;\n            while (num >= 2) {\n                count += num / 3;\n                num = num / 3 + num % 3;\n                if (num == 2) {\n                    count++;\n                    break;\n                }\n            }\n            System.out.printf(\"%d \", count);\n        }\n        sc.close();\n    }\n"]]}
{"hexsha": "f664df3b792a7bfc8a4428d77b5c2fffb8ff5eed", "ext": "java", "lang": "Java", "content": "public class EProperties extends Properties implements Value<EProperties> {\n   public static Logger log = LoggerFactory.getLogger(EProperties.class);\n   \n   /** When set to true, EProperties will emit some debug logging. */\n   public static boolean debug=false;\n   \n   /** When set to true, eproperties will print warnings for potentially \n    * unresolved substitutions.  */\n   public static boolean validateOnLoad=true;\n   \n   /** This is a formatting option for the 'save' function. */\n   public static int INDENT_SPACES=3;\n   \n   /** An internal list of Key objects.  This maintains the order of the keys, \n    * useful for saving the properties object in the same order in which it \n    * was read. */\n   private List<Key> keys = new ArrayList<Key>();\n   \n   // if this properties object is nested inside of another, then the\n   // 'thisKey' is the value of the key that owns this object.  If this \n   // is the 'root' object, then thisKey is null;\n   String thisKey=null;\n\n   /** List of listeners... */\n   List<PropertyListener> listeners = null;\n   \n   /** \n    * Root EProperties objects will have a source URL, corresponding to \n    * the file from which it was loaded.  If File A includes File B, then\n    * File A will have a sourceURL, but not a includeURL.  File B will have a \n    * sourceURL AND an includeURL.\n    */\n   URL sourceURL=null;\n   \n   /** If this properties object is included via an include processor, \n    * then includeURL is set.  This is later used when writing properties\n    * out.  If the includeURL at a particular level is non-null, then \n    * rather than writing the actual properties, it writes the include\n    * url.  For example\n    * foo=[http://bar.com/baz.properties]\n    */\n   String includeURL=null;\n\n   /** Parent, if this object has a parent. */\n   EProperties parent = null;\n   \n   /** */\n   static CacheManager cacheManager=CacheManager.getInstance();\n   \n   /** lastModification is a unique number indicating the state of the source\n    * at the last time load() was called.  Now - in the case of a File URL, \n    * this will simply be the last modification time.  <p>\n    * \n    * This property is used to determine if the underlying property store \n    * has changed - ie, has the file, or http url, or database been modified, \n    * requiring a reload. <p>  \n    * \n    * However, in a case \n    * where properties are in a database, we don't modification time.  So an \n    * alternate method may be chosen.  This could be as simple as a the hashcode\n    * of a string composed of the concatenation of all the keys and values. \n    * How expensive this is depends on the relative proximity of the database, \n    * and the number of properties.  If such a calculation is expensive, \n    * the the monitoring thread should be slowed to an appropriate rate.  \n    * */\n   long lastModification=-1;\n   \n   public static boolean showVersion=true;\n   private static volatile boolean versionShown=false;\n   \n   static synchronized final void showVersion() {\n      if (showVersion == false)\n         return;\n      \n      if (versionShown)\n         return;\n      \n      versionShown=true;\n      \n      InputStream is=null;\n      Properties p=null;\n      try {\n         is=EProperties.class.getResourceAsStream(\"version.properties\");\n         if (is != null) {\n            p=new Properties();\n            p.load(is);\n         }\n      } catch (Throwable t) {\n         t.printStackTrace();\n      } finally {\n         if (is != null)\n            try {is.close();} catch (Exception ex) {}\n      }\n      StringBuilder message=new StringBuilder();\n      String version=\"UNKNOWN\";\n      if (p != null)\n         version=p.getProperty(\"version\");\n      if (version == null)\n         version=\"ERROR\";\n      int dlen=14;\n      if (version.length() > dlen)\n         version=version.substring(0,dlen);\n      else if (version.length() < dlen) {\n         int add=dlen-version.length();\n         for (int i=0; i<add; i++)\n            version=version+\" \";\n      }\n      \n      message.append(\"+-----------------------------------------------------------+\\n\");\n      message.append(\"|         Loading EProperties version \"+version   +\"        |\\n\");\n      message.append(\"| For more info, see the EProperties project on googlecode. |\\n\");\n      message.append(\"|         http://code.google.com/p/eproperties/             |\\n\");\n      message.append(\"+-----------------------------------------------------------+\\n\");\n\n      log.info(message.toString());\n   }\n\n   /** Constructs a sub-properties object, the parent collection is passed\n    * into the constructor. */\n   public EProperties(EProperties par) {\n      this();\n      parent=par;\n   }\n   \n   /** Empty constructor.  Most commonly used as a public API, with \n    * a load() operation called soon after.  */\n   public EProperties() {\n      showVersion();\n   }\n   \n   /** Sets the URL from which this file was included. */\n   public void setIncludedURL(String iurl) {\n      includeURL=iurl;\n   }\n   \n   public void setOwner(EProperties p) {\n      this.parent=p;\n   }\n   \n   /** \n    * Merges 2 property sets at the same level.  Any potentially duplicate\n    * keys would be overwritten by the new values.\n    * \n    * This operation will caused subsequent save() operations to write the \n    * merged proeprties.  \n    * \n    * This is called by the parser to implement root property includes. \n    */\n   public void merge(EProperties p) {\n      log.debug(\"Merging \"+p.size()+\" new properties.  Current path is '\"+getPath()+\"'\");\n      log.debug(\"Merging, this.findSourceURL(): \"+findSourceURL());\n      log.debug(\"Merging, p.findSourceURL(): \"+p.findSourceURL());\n      \n      List<Key> keys = p.getKeys();\n      int size=keys.size();\n      for (int i = 0; i < size; i++) {\n         Key key = keys.get(i);\n\n         // 21 jul 2009 - experimental.  I think we should merge the\n         // pre-substitution values, not the derrived values.  \n         \n         //Object val = p.get(key); \n         Object val=p.preSubstitutionGet(key);\n         \n         if (val instanceof Value)\n            ((Value)val).setOwner(this);\n         \n         this.put(key, val);\n      }\n   }\n   \n   /** \n    * Deep merge in more intelligent than merge.  Merge is draconian, \n    * totally overwriting any property (including potentially deeply \n    * nested properties) with the new value. \n    * \n    * Deep merge attempts to deal with nesting of properties.  Both strings \n    * and list values are still treated as atomic, and overwritten. But\n    * deeper trees of properties a merged in a truer sense of the word.  It \n    * is more additive, with the merging properties taking precidece, but\n    * not overwriting, rather merging deep trees.\n    */\n   public void deepMerge(EProperties p) {\n      log.debug(\"Deep-Merging \"+p.size()+\" new properties.  Current path is '\"+getPath()+\"'\");\n      log.debug(\"Deep-Merging, this.findSourceURL(): \"+findSourceURL());\n      log.debug(\"Deep-Merging, p.findSourceURL(): \"+p.findSourceURL());\n      \n      List<Key> keys=p.getKeys();\n      for (Key key:keys) {\n         String keyString=key.toString();\n         \n         Object val=p.preSubstitutionGet(keyString);\n         \n         log.debug(\"Deep-Merge: pre-substitution get returns \"+\n               (val == null? \"null\":(val.getClass().getName()+\", \"+val)));\n         \n         if (val instanceof EProperties) {\n            EProperties mergingProps=(EProperties)val;\n            \n            Object existingVal=preSubstitutionGet(keyString);\n            if (existingVal != null && existingVal instanceof EProperties) {\n               EProperties existingProps=(EProperties)existingVal;\n               existingProps.deepMerge(mergingProps);\n            } else {\n               this.put(keyString, val);\n            }\n         } else {\n            //log.debug(\"Deep merge, pre-substitution value for key '\"+key+\"' is \"+val);\n            \n            if (val instanceof Value) \n               ((Value)val).setOwner(this);\n            this.put(keyString, val);\n         }\n      }\n   }\n   \n   \n   /** See flatten(String delim). */\n   public EProperties flatten() {\n      return flatten(\"|\");\n   }\n   \n   /** Flattens properties with the inbound delimiter. */\n   public EProperties flatten(String delim) {\n      return flatten(\"\", delim);\n   }\n   \n   /**\n    * Flattens the property structure.  Nested properties are prefixed\n    * with the name of the nesting structure.  For instance, if we have:\n    * \n    * foo=bar\n    * blah={\n    *   bing=bat\n    * }\n    * \n    * Flatten would flatten the structure to:\n    * foo=bar\n    * blah|bing=bat\n    * \n    * The delimiter is configurable (inbound on the method) with the \n    * default delimeter being the pipe character: '|'.\n    * \n    * */\n   protected EProperties flatten(String prefix, String delim) {\n      EProperties flat=new EProperties();\n      for (Key key:keys) {\n         Object val=get(key);\n         \n         if (val == null) {\n            log.warn(\"flatten: value is null for key \"+key);\n            if (!empty(prefix))\n               flat.put(prefix+delim+key, val);\n            else \n               flat.put(key.toString(), val);\n         } else if (val instanceof EProperties) {\n            EProperties epval=(EProperties)val;\n            // recursion\n            EProperties nestedFlat=null;\n            if (!empty(prefix))\n               nestedFlat=epval.flatten(prefix+delim+key.toString(), delim);\n            else \n               nestedFlat=epval.flatten(key.toString(), delim);\n            \n            flat.addAll(nestedFlat);\n         } else if (val instanceof List) {\n            if (!empty(prefix))\n               flat.put(prefix+delim+key, val.toString());\n            else \n               flat.put(key.toString(), val.toString());\n         } else {\n            if (!empty(prefix))\n               flat.put(prefix+delim+key, val.toString());\n            else \n               flat.put(key.toString(), val.toString());\n         }\n      }\n      return flat;\n   }\n   \n   private static final boolean empty(String s) {\n      if (s == null || s.length() == 0)\n         return true;\n      return false;\n   }\n\n   /** */\n   public void addAll(Properties p) {\n      Enumeration keyset=p.keys();\n      while (keyset.hasMoreElements()) {\n         Object key=keyset.nextElement();\n         Object value=p.get(key);\n         put(key, value);\n      }\n   }\n   \n   /** This method scans the properties tree, and returns a report of what\n    * properties have un-resolved substitutions.  */\n   public String validate() {\n      int size=keys.size();\n      \n      StringBuilder sb=new StringBuilder();\n      \n      for (int i=0; i<size; i++) {\n         Key key=keys.get(i);\n         \n         // substitutions should have happened at the point that\n         // this is called.\n         Object value=get(key);\n         key.removeHit();\n         if (value instanceof String) {\n            String s=(String)value;\n            if (SubstitutionProcessor.containsTokens(s)) {\n               // this is an error.  Tokens should have been \n               // replaced by values here.\n               sb.append(\"Warning: Value for key '\"+key+\"' defined in terms of \"+\n                     \"un-resolvable substitution: '\"+s+\"'\\n\");\n            }\n         } else if (value instanceof List) {\n            List<String> list=(List<String>)value;\n            for (int j=0; j<list.size(); j++) {\n               String lv=list.get(j);\n               if (SubstitutionProcessor.containsTokens(lv)) {\n                  sb.append(\"Warning: List item value for key '\"+key+\"[\"+j+\"]' defined \"+\n                        \"in terms of un-resolvable substitution: '\"+lv+\"'\\n\");\n               }\n            }\n         } else if (value instanceof EProperties) {\n            EProperties props=(EProperties)value;\n            // maybe should indent here... \n            sb.append(props.validate());\n         } else {\n            // not really sure what this object is, if not one of the \n            // above types. I'm confused - but I'm not going to validate.\n         }\n      }\n      return sb.toString();\n   }\n   \n   public void list(PrintStream ps) {\n      list((OutputStream)ps);\n   }\n   \n   /** */\n   public void list(OutputStream os) {\n      list(os, false);\n   }\n   \n   public void list(OutputStream ps, boolean hits) {\n      list(new PrintWriter(new OutputStreamWriter(ps), true), 0, hits);\n   }\n   \n   /** */\n   public void list(PrintWriter pw) {\n      list(pw,0);\n   }\n   \n   public void list(PrintWriter pw, int depth) {\n      list(pw, depth, false);\n   }\n   \n   \n   /** */\n   public void list(PrintWriter pw, int depth, boolean printhits) {\n      int size=keys.size();\n      StringBuilder sb=new StringBuilder();\n      for (int i=0; i<depth; i++) \n         sb.append(\"  \");\n      String pad=sb.toString();\n      \n      for (int i=0; i<size; i++) {\n         Key key=keys.get(i);\n         Object value=get(key);\n         key.removeHit();\n         \n         String keystring=null;\n         if (printhits)\n            keystring=key+\"[\"+key.getHitCount()+\"]\";\n         else\n            keystring=key.toString();\n         \n         if (value instanceof EProperties) {\n            pw.println(pad+keystring+\" = {\");\n            ((EProperties)value).list(pw, depth+1, printhits);\n            pw.println(pad+\"}\");\n         } else if (value instanceof List) {\n//            String s=value.toString();\n//            // this will be a list starting and ending with []\n//            // replace those with ()\n//            s=s.substring(1, s.length()-1);\n            List l=(List)value;\n            StringBuilder sbb=new StringBuilder();\n            for (Object item:l) {\n               String sitem=item.toString();\n               sitem=sitem.replace(\"\\\"\", \"\\\\\\\"\"); // escape quotes in list strings.\n               sbb.append(\"\\\"\"+sitem+\"\\\", \");\n            }\n            String s=sbb.toString();\n            // trim the final , \n            s=s.substring(0, s.length()-2);\n            \n            pw.println (pad+keystring+\"=(\"+s+\")\");\n         }else {\n            pw.println (pad+keystring+\"=\"+value);\n         }\n      }\n   }\n   \n   public String list() {\n      ByteArrayOutputStream baos=new ByteArrayOutputStream();\n      PrintWriter pw=new PrintWriter(new OutputStreamWriter(baos), true);\n      list(pw);\n      pw.flush();\n      return baos.toString();\n   }\n   \n   public String list(int depth) {\n      ByteArrayOutputStream baos=new ByteArrayOutputStream();\n      PrintWriter pw=new PrintWriter(new OutputStreamWriter(baos), true);\n      list(pw, depth);\n      pw.flush();\n      return baos.toString();\n   }\n   ///////////////////////  Lineage  ////////////////////////////\n   public void setParent(EProperties p, String key) {\n      parent=p;\n      thisKey=key;\n   }\n   \n   /** */\n   public String getPath() {\n      StringBuilder sb=new StringBuilder();\n      String key=thisKey;\n      EProperties nextParent=parent;\n      while (nextParent != null) {\n         sb.insert(0, \"->\"+key);\n         \n         key=parent.thisKey;\n         if (key == null)\n            key=\"UNKNOWN\";\n         \n         nextParent=nextParent.parent;\n      }\n      return sb.toString();\n    }\n   \n   /**\n    * This is the sole method for putting objects into the EProperties object.\n    * \n    * This is synchronized to prevent concurrent access with load/read operations.\n    */\n   @Override\n   public synchronized Object put(Object k, Object v) {\n      if (k == null) {\n         throw new NullPointerException(\"Key cannot be null in EProperties.\");\n      }\n      Key key = null;\n      // \n      if (k instanceof String) {\n         key = new Key((String) k);\n      } else if (k instanceof Key) {\n         key = (Key) k;\n      } else {\n         throw new Error(\"Keys in EProperties must be [Key | String], not \"+k.getClass().getName());\n      }\n      \n      String keyString=key.toString();\n      \n      if (keyString.indexOf(\"->\") != -1) {\n         // this is a complex key.\n         return putWithComplexKey(keyString, v);\n         // FIXME: This does not account for listeners to keys/properties at any level\n      }\n      \n      // Prevent duplicate keys, preserve order, notify listeners\n      int keyIndex = keys.indexOf(key);\n      if (keyIndex == -1)\n         keys.add(key);\n      else {\n         //Key existingKey = keys.get(keys.indexOf(key));\n         //existingKey.notifyListeners(v);\n         key=keys.get(keyIndex); // replace created key w/ existing key\n      }\n      \n      // build a value object.\n      // There are 3 and only 3 types of values:\n      //   1) String values.\n      //   2) List Values, and\n      //   3) EProperties values.\n      // \n      // attempting to put any\n      \n      Object returnVal=v;\n      Value value=null;\n      \n      if (v == null) {\n         // Allowing us to call put(key, null). Setting a property to \n         // null is defined as removing that property.\n         //super.put(key, v);\n         super.remove(key);\n      } else if (v instanceof String) {\n         value=new StringValue((String)v, this);\n         super.put(key, value);\n      } else if (v instanceof List) {\n         value=new ListValue((List)v, this);\n         super.put(key, value);\n      } else if (v instanceof EProperties) {\n         super.put(key, v);\n         \n         // set parent.\n         //setParent((EProperties)v, key.toString());\n         ((EProperties)v).setParent(this, key.toString());\n      } else if (v instanceof StringValue ||\n                 v instanceof ListValue) {\n         Value vv=(Value)v;\n         \n         log.debug(\"Putting raw StringValue or ListValue: persistent: \"+\n               vv.getPersistentValue()+\" runtime: \"+vv.getRuntimeValue());\n         super.put(key, v);\n      } else {\n         throw new Error(\"EProperties put() values can only be: \"+\n               \"[String | List<String> | EProperties | StringValue | ListValue].  \"+\n               \"Not \"+v.getClass().getName());\n      }\n\n      if (this.listeners != null) {\n         notifyListeners(key, value);\n      }\n      // This will do nothing if there are no listeners.\n      key.notifyListeners(returnVal);\n\n      return returnVal;\n   }\n   \n   /** \n    * putWithCompleKey() works much like getWithComplexKey().  I will give a \n    * simple example under 2 different conditions.\n    * \n    * In both examples, the key is nested->foo.  In both cases the put method\n    * has been called on a properties object we'll call 'root'.  \n    * \n    * Case 1: The 'root' EProperties object already has a nested properties\n    *         object named 'nested'.  In this case, we simply get a handle\n    *         to the deeper properties object called 'nested' and on it\n    *         we call put(key, val) with the key being a simple key 'foo' \n    *         and the value being the inbound value.  ALL BEHAVIORS OF PUT\n    *         AT THAT POINT ARE IDENTICAL. Ie, if the value does not already \n    *         exist, it is added.  If the value does exist, IN ANY FORM - ie\n    *         String, List or nested Properties - it is overwritten with \n    *         the inbound object value.\n    *         \n    * Case 2: The 'root' EProperties object does not already have a nested\n    *         properties object called 'nested'.  In this case, a new properties\n    *         object is created, named 'nested' and added to 'root'.  \n    *         \n    * For keys with more than 2 levels of depth (ie, a->b->c), the process\n    * above is repeated until the last key (c in this example) is found - and \n    * that key represents the inbound value in the nested objects a->b that\n    * either already exist, or are created by this method.\n    */\n   private synchronized Object putWithComplexKey(String key, Object value) {\n      String keys[] = key.split(\"\\\\-\\\\>\");\n      \n      log.debug (\"getComplexKey(): \"+Arrays.asList(keys));\n      \n      EProperties next = this;\n      String currentPath = \"\";\n      \n      //StringBuilder path=new StringBuilder();\n      \n      for (int i = 0; i < keys.length - 1; i++) {\n         // currentPath is used for debugging.\n         EProperties prev=next;\n         next=prev.getProperties(keys[i]);\n         if (next == null) {\n            // Create nested props that do not exist.\n            next=new EProperties();\n            prev.put(keys[i], next);\n         }\n      }\n      \n      return next.put(keys[keys.length-1], value);\n   }\n\n   /** */\n   @Override\n   public synchronized void putAll(Map m) {\n      Iterator i=m.keySet().iterator();\n      while (i.hasNext()) {\n         Object key=i.next();\n         Object val=m.get(key);\n         put(key, val);\n      }\n   }\n\n   /** */\n   @Override\n   public Object remove(Object k) {\n      Key key = null;\n      if (k instanceof String) {\n         key = new Key((String) k);\n      } else if (k instanceof Key) {\n         key = (Key) k;\n      } else {\n         throw new Error(\"Keys in EProperties must be [Key, String].\");\n      }\n      keys.remove(key);\n     \n      Object returnVal=super.remove(key);\n      \n      notifyListeners(key, returnVal);\n      \n      return returnVal;\n   }\n   \n   /** Logs 'hits' to keys.  This allows us to know what properties are being\n    * used in a long running JVM.  See Key.getHitCount(). */\n   private void keyHit(Object key) {\n      if (key instanceof String)\n         key=new Key((String)key);\n      int index=keys.indexOf(key);\n      \n      if (index < 0) {\n      } else {\n         Key thekey=keys.get(index);\n         thekey.hit();\n      }\n   }\n   \n   /**\n    * All getters funnel to this location.  This is the 'super' get.  \n    */\n   @Override\n   public Object get(Object key) {\n      Object val=null;\n      \n      if (key instanceof String) { \n         String skey=(String)key;\n         if (skey.indexOf(\"->\") > 0)\n            val=getWithComplexKey(skey);\n         else {\n            val=super.get(key);\n            if (val != null)\n               keyHit(key);\n         }\n      } else { \n         val=super.get(key);\n         if (val != null)\n            keyHit(key);\n      }\n\n      log.debug(\"get, key: '\"+key+\"', keyclass: \"+key.getClass().getName());\n      log.debug (\"get, val: '\"+val+\"' valClass: \"+(val == null?\"\":val.getClass().getName()));\n      if (val instanceof Value) {\n         Value vv=(Value)val;\n         log.debug(\"   Value.getPersistent: '\" + vv.getPersistentValue()+\"'\");\n         log.debug(\"   Value.getRuntime   : '\"+vv.getRuntimeValue()+\"'\");\n      }\n      \n      // At this point, val could be null.\n      if (val == null)\n         return val;\n      \n      // here, we'll process substitutions if they exist...\n      if (val instanceof StringValue) {\n         Object rtval=((StringValue)val).getRuntimeValue();\n         \n         if (rtval instanceof String &&\n            SubstitutionProcessor.containsTokens((String)rtval)) {\n            log.warn(\"Value for key '\"+key+\"' defined in terms of \"+\n                     \"un-resolvable substitution: '\"+rtval+\"'\");\n         }\n         return rtval;\n      }\n      else if (val instanceof ListValue) {\n         List<String> list=((ListValue)val).getRuntimeValue();\n         for (int j=0; j<list.size(); j++) {\n            String lv=list.get(j);\n            if (SubstitutionProcessor.containsTokens(lv)) {\n               log.warn(\"List item value for key '\"+key+\"[\"+j+\"]' defined \"+\n                     \"in terms of un-resolvable substitution: '\"+lv+\"'\\n\");\n            }\n         }\n         return list;\n      }\n      \n      // this can and will be EProperties as well as primitives.\n      return val;\n   }\n   \n   private Object preSubstitutionGet(Object key) {\n      log.debug(\"Pre-sub get \"+key);\n      return super.get(key);\n   }\n   \n   /** */\n   public Object internalGetValue(Object key) {\n      // note, this key must be a Key, not a String\n      return super.get(key);\n   }\n   \n   /** */\n   public EProperties internalResolveProperties(String path) {\n      if (path.indexOf(\"->\") == -1)\n         return this;\n      \n      String keys[] = path.split(\"\\\\-\\\\>\");\n      \n      log.debug (\"getComplexKey(): \"+Arrays.asList(keys));\n      \n      EProperties next = this;\n      String currentPath = \"\";\n      \n      //StringBuilder path=new StringBuilder();\n      \n      for (int i = 0; i < keys.length - 1; i++) {\n         // currentPath is used for debugging.\n         if (currentPath.equals(\"\"))\n            currentPath = keys[i];\n         else\n            currentPath = currentPath + \"->\" + keys[i];\n\n         Object nextTarget = next.get(keys[i]);\n         if (nextTarget == null) {\n            return null;\n         } else if (nextTarget instanceof EProperties) {\n            next = (EProperties) nextTarget;\n         } else {\n            log.debug(\"getComplexKey(): [\" + path\n                  + \"]: Returning null because object at path \"\n                  + currentPath + \" is not EProperties, it is \"\n                  + nextTarget.getClass().getName());\n            return null;\n         }\n      }\n      // here, we are pointed at the correct eproperties object.\n      //return next.get(keys[keys.length-1]);\n      return next;\n   }\n   \n   /** */\n   public Key internalResolveKey(String path) {\n      EProperties p=null;\n      String finalKey=null;\n      if (path.indexOf(\"->\") != -1) {\n         p=internalResolveProperties(path); // can return null;\n         \n         String keyelements[]=path.split(\"\\\\-\\\\>\");\n         finalKey=keyelements[keyelements.length-1];\n      } else {\n         p=this;\n         finalKey=path;\n      }\n      if (p == null)\n         return null;\n      List<Key> keys=p.getKeys();\n      for (Key key:keys) {\n         if (key.toString().equals(finalKey))\n            return key;\n      }\n      return null;\n   }\n   \n   /** */\n   public Object get(String key, Object def) {\n      Object ret = get(key);\n      if (ret == null)\n         return def;\n      else\n         return ret;\n   }\n\n   /** */\n   public List<Key> getKeys() {\n      return keys;\n   }\n\n   /** */\n   public Object get(int keyNum) {\n      return get(getKey(keyNum));\n   }\n\n   /** */\n   public Key getKey(int i) {\n      return keys.get(i);\n   }\n\n   /** Returns a list of keys that start with the input string. */\n   public List<Key> getKeys(String s) {\n      List<Key> prefixKeys = new ArrayList<Key>();\n      int size = keys.size();\n      for (int i = 0; i < size; i++) {\n         Key key = keys.get(i);\n         if (key.toString().startsWith(s))\n            prefixKeys.add(key);\n      }\n      return prefixKeys;\n   }\n   \n   @Override\n   public synchronized Enumeration keys() {\n      Vector v=new Vector();\n      \n      int size = keys.size();\n      for (int i = 0; i < size; i++) {\n         Key key = keys.get(i);\n         v.add(key.toString());\n      }\n      return v.elements();\n   }\n   \n   @Override\n   public synchronized Collection values() {\n      Vector v=new Vector();\n      int size = keys.size();\n      for (int i = 0; i < size; i++) {\n         v.add(get(i));\n      }\n      return v;\n   }\n   \n   @Override \n   public synchronized Enumeration elements() {\n      return new VectorEnumerator((Vector)values());\n   }\n   \n   public static class VectorEnumerator implements Enumeration {\n      Vector v=null;\n      int index=0;\n      public VectorEnumerator(Vector v) {\n         this.v=v;\n      }\n      public boolean hasMoreElements() {\n         if (index < v.size())\n            return true;\n         return false;\n      }\n      public Object nextElement() {\n         index++;\n         return v.get(index-1);\n      }\n   }\n   \n   @Override\n   public synchronized Set keySet() {\n      HashSet hashSet=new HashSet();\n      \n      int size = keys.size();\n      for (int i = 0; i < size; i++) {\n         Key key = keys.get(i);\n         hashSet.add(key.toString());\n      }\n      \n      return hashSet;\n   }\n   \n   @Override\n   public Set<Map.Entry<Object, Object>> entrySet() {\n      // This sucks to have to do, but Entry is a private class in \n      // hashmap.  And entrySet() is called fromn putAll().  Meaning I\n      // MUST override this or people who copy this properties object\n      // by constructing a new one, and calling putAll() and then assuming\n      // that the keys are strings will fail. (Spring.  Spring sucks.)\n      HashMap map=new HashMap();\n      for (Key key:keys) {\n         map.put(key.toString(), get(key));\n      }\n      return map.entrySet();\n   }\n   \n   @Override\n   public Enumeration<String> propertyNames() {\n      return keys();\n   }\n   \n   //@Override // this is an override only in 1.6\n   public Set<String> stringPropertyNames() {\n      return keySet();\n   }\n   \n   @Override \n   public synchronized boolean containsKey(Object key) {\n      Object val=get(key);\n      if (val != null)\n         return true;\n      return false;\n   }\n   \n   @Override\n   public synchronized boolean contains(Object value) {\n      if (value == null)\n         return false;\n      // inefficient, but functional.\n      int size = keys.size();\n      for (int i = 0; i < size; i++) {\n         Object val=get(i);\n         if (val.equals(value))\n            return true;\n      }\n      return false;\n   }\n   \n   @Override \n   public synchronized String toString() {\n      return list();\n   }\n\n   ///////////////////////// Load/Save Methods ////////////////////////////\n   /** This is the 'master' load() method.  All other load methods delegate\n    * here for actual property loading.  */\n   @Override\n   public synchronized void load(InputStream is) \n   throws IOException {\n      InputStream cis=cacheManager.getInputStream(is, sourceURL);\n      \n      EPropertiesParser parser=new EPropertiesParser(cis);\n      parser.setSourceURL(sourceURL);\n\n      try {\n         parser.parse(this);\n      } catch (Exception ex) {\n         // this constructor is only available in Java 1.6\n         //throw new IOException(\"Error parsing EProperties.\", ex);\n         ex.printStackTrace();\n         throw new IOException(\"Error parsing Properties. \"+ex.getMessage());\n      } finally {\n         if (cis != null) {\n            try {\n               cis.close();\n            } catch (Exception clex) {\n               clex.printStackTrace();\n            }\n         }\n      }\n      if (validateOnLoad)\n         validate();\n   }\n   \n//   @Override\n//   public synchronized void load(Reader r) {\n//      throw new RuntimeException(\"not implemented.\");\n//   }\n   \n   /**\n    * Loads properties with a string representing either a URL or \n    * a file.  \n    * \n    * @param surl\n    */\n   public void load(String surl) throws IOException {\n      URL url=null;\n      \n      surl=URLUtil.convertClasspathURL(surl);\n      \n      String lcurl=surl.toLowerCase();\n\n      if (lcurl.startsWith(\"http://\") || lcurl.startsWith(\"https://\") ||\n          lcurl.startsWith(\"file:/\") || lcurl.startsWith(\"jar:file:/\")) {\n         url=new URL(surl);\n      } else {\n         url=(new File(surl)).toURI().toURL();\n      }\n      load(url);\n   }\n   \n   /** */\n   public synchronized void load(URL url) \n      throws IOException {\n      setSourceURL(url);\n      InputStream is=null;\n      try {\n         is=cacheManager.getInputStream(url);\n         \n         load(is);\n         \n         lastModification=URLUtil.lastMod(url);\n         log.debug(\"Last Mod is '\"+lastModification+\"'\");\n      } finally {\n         if (is != null)\n            is.close();\n      }\n   }\n   \n   /** */\n   public boolean isSourceModified() {\n      // FIXME, 18 AUG 2010 - possible NPE. sourceURL could be null.\n      URL surl=sourceURL;\n      if (surl == null) {\n         surl=findSourceURL();\n      }\n      if (surl == null) \n         return false;\n      \n      try {\n         \n         long lastMod=URLUtil.lastMod(surl);\n         \n         if (lastMod != lastModification) \n            return true;\n      } catch (Exception ex) {\n         log.error(\"Error checking source modification\", ex);\n      }\n      return false;\n   }\n   \n   /** */\n   public void load(File f) \n    throws IOException {\n      load(f.toURI().toURL());\n   }\n   \n   /** Reloads this EProperties object from its sourceURL. If this EProperties\n    * object does not have a sourceURL, this method does nothing.\n    */\n   public void reload() \n      throws IOException {\n      if (sourceURL != null) {\n         load(sourceURL);\n      } else {\n         log.warn(\"reload() called on EProperties, but sourceURL is null.  noop.\");\n      }\n   }\n   \n   /** */\n   public URL getSourceURL() {\n      URL url = sourceURL;\n      if (url != null)\n         return url;\n      \n      EProperties next = parent;\n      while (next != null && url == null) {\n         url = next.sourceURL;\n         next = next.parent;\n      }\n      return url;\n   }\n\n   /** */\n   public void setSourceURL(URL url) {\n      log.debug(\"Setting source URL '\"+url+\"'\");\n      sourceURL = url;\n   }\n\n   /** */\n   public final URL findSourceURL() {\n      EProperties props = this;\n      URL url = sourceURL;\n      while (url == null && props != null) {\n         props = props.parent;\n         if (props != null)\n            url = props.sourceURL;\n      }\n      return url;\n   }\n   \n   /** Save to the file currently identified by sourceURL.  sourceURL must be\n    * file based - and not http based - we can't magically save to an \n    * http stream.\n    * \n    * If this method is called on a properties object without a sourceURL, \n    * this method searches up the tree to find a properties object that\n    * does have a source URL - and that object is saved if it can be found, \n    * and has a file:// based source url.\n    * \n    * @return Returns true if a save has been executed, false if not possible.\n    * @throws IOException\n    */\n   public boolean save() throws IOException {\n      if (sourceURL != null) {\n         if (sourceURL.getProtocol() != null\n               && sourceURL.getProtocol().equals(\"file\")) {\n\n            File f;\n            try {\n               f = new File(sourceURL.toURI());\n            } catch (Exception ex) {\n               // this constructor is only available in Java 1.6\n               //throw new IOException(\"Unable to form File from URL.\", ex);\n               ex.printStackTrace();\n               throw new IOException(\"Unable to form File from URL. \"+ex.getMessage());\n            }\n            save(f);\n         } else {\n            log.debug(\"Cannot save properties with URL \" + sourceURL);\n         }\n         return true;\n      } else {\n         if (parent != null) {\n            return parent.save();\n         } else {\n            return false;\n         }\n      }\n   }\n   \n   public void save(File f) throws IOException {\n      save(new FileWriter(f));\n   }\n   \n   public void save(OutputStream os)\n   throws IOException {\n      save(new OutputStreamWriter(os));\n   }\n   \n   public void save(Writer w) \n   throws IOException {\n      save(w, 0);\n   }\n   \n   /** */\n   private synchronized void save(Writer w, int indent) \n      throws IOException {\n      String pad=\"\";\n      if (indent > 0) {\n         StringBuilder sb=new StringBuilder();\n         for (int i=0; i<INDENT_SPACES*indent; i++) {\n            sb.append(\" \");\n         }\n         pad=sb.toString();\n      }\n      \n      try {\n         int size=keys.size();\n         for (int i=0; i<size; i++) {\n            Key key=keys.get(i);\n            \n            // writing key= is the same for string, list, properties, or\n            // inclusion.\n            \n            // first, write comment lines if they exist\n            String comments=key.getComments();\n            if (comments != null) {\n               // trim off trailing newline, then pad, then append newline\n               comments=comments.trim(); \n               \n               comments=pad+comments;\n               comments=comments.replace(\"\\n\", \"\\n\"+pad);\n               comments=comments+\"\\n\";\n               \n               w.write(comments);\n            }\n            w.write(pad+key.toString()+\"=\");\n            \n            // now, write the value, depending on its type.\n            Object val=preSubstitutionGet(key);\n            \n            if (val == null) {\n               w.write(\"\\n\"); // null is an unquoted empty line.\n               // this will allow for the definition of a non-null\n               // empty string as \"\".\n            } else if (val instanceof StringValue) {\n               String s=(String) ((StringValue)val).getPersistentValue();\n               w.write(\"\\\"\"+s+\"\\\"\\n\");\n            } else if (val instanceof EProperties) {\n               EProperties pval=(EProperties)val;\n               \n               if (pval.includeURL != null) {\n                  // these properties were included.\n                  w.write(\"[\"+pval.includeURL+\"]\\n\");\n               } else {\n                  w.write(\"{\\n\");\n                  pval.save(w, indent+1);\n                  w.write(pad+\"}\\n\");\n               }\n            } else if (val instanceof ListValue) {\n               List list=(List)((ListValue)val).getPersistentValue();\n               \n               if (list.size() == 0) {\n                  w.write(\"( )\\n\");\n               } else {\n                  \n                  String keypad=pad(key.toString().length()+2, \" \");\n                  w.write(\"(\");\n                  int lsize=list.size();\n                  for (int j=0; j<lsize; j++) {\n                     w.write(\"\\\"\"+list.get(j)+\"\\\"\");\n                     \n                     if (j == lsize-1) // last element\n                        w.write(\")\\n\");\n                     else \n                        w.write(\", \\n\"+pad+keypad);\n                  }\n               }\n            } else {\n               log.error(\"What kind of value?? \"+val.getClass().getName());\n            }\n            \n            // append this newline for whitespace readability\n            //if (i != size-1)\n            //   w.write(\"\\n\");\n         }\n         // end of the for loop.\n      } finally {\n         if (w != null)\n            w.flush();\n      }\n   }\n   \n   /** */\n   public void save(String filename) \n      throws IOException {\n      save(new FileOutputStream(filename));\n   }\n   \n   private static final String pad(int pad, String padChar) {\n      StringBuilder sb=new StringBuilder();\n      for (int i=0; i<pad; i++) {\n         sb.append(padChar);\n      }\n      return sb.toString();\n   }\n   \n   /////////////////////////   Convience Put Methods  ////////////////////\n   /** */\n   public void putBoolean(String key, boolean value) {\n      String val = null;\n      if (value)\n         val = \"true\";\n      else\n         val = \"false\";\n      put(key, val);\n   }\n\n   /** */\n   public void putInt(String key, int i) {\n      String val = \"\" + i;\n      put(key, val);\n   }\n\n   /** */\n   public void putLong(String key, long l) {\n      String val = \"\" + l;\n      put(key, val);\n   }\n   \n   @Override\n   public Object setProperty(String k, String v) {\n      return put(k, v);\n   }\n   \n   /////////////////////////  Token Substitution  /////////////////////////\n   /**\n    * This method will search up a tree of EProoperties objects, looking for \n    * a match.  It will return the first match.\n    * \n    * @param s\n    * @return\n    */\n   public String findProperty(String s) {\n      String val=getString(s, null);\n      log.debug(\"findProperty(): Path='\"+getPath()+\"', \"+s+\"=\"+val);\n            \n      if (val != null)\n         return val;\n      else {\n         if (parent != null) {\n            return parent.findProperty(s);\n         } else {\n            log.debug(\"findProperty(): parent is null at Path='\"+getPath()+\"'\");\n         }\n      }\n      \n      return val;\n   }\n   \n   /**\n    * This method will search up a tree of EProoperties objects, looking for \n    * a match.  It will return the first match.\n    * \n    * @param s\n    * @return\n    */\n   public Object findValue(String s) {\n      Object val=get(s, null);\n      log.debug(\"findValue(): Path='\"+getPath()+\"', \"+s+\"=\"+val);\n            \n      if (val != null)\n         return val;\n      else {\n         if (parent != null) {\n            return parent.findValue(s);\n         } else {\n            log.debug(\"findValue(): parent is null at Path='\"+getPath()+\"'\");\n         }\n      }\n      \n      return val;\n   }\n   \n   // /////////////////////// Accessor Methods ///////////////////////////\n   public EProperties getProperties(Key key) {\n      return getProperties(key.toString());\n   }\n\n   \n   private Object getWithComplexKey(String key) {\n      // a complex key uses a pointer syntax find properties\n      // deeper in a structure.\n      // for instance:\n      // String s=(String)get(\"system->user.home\");\n      // is equivalent to\n      // String s=(String)getProperties(\"system\").get(\"user.home\");\n      //\n      // Which brings up the issue of error handling. What if one of the\n      // indirections returns a null nested property object!!\n      // At that we simply return null - as if you requested a value \n      // from an EProperties object where the key does not exist.\n      //\n      // The final key can return any type of object (String, Vector,\n      // Properties),\n      // however all of the initial keys must return a nested EProperties\n      // object. If they do not, then it returns null.\n      String keys[] = key.split(\"\\\\-\\\\>\");\n      \n      log.debug (\"getComplexKey(): \"+Arrays.asList(keys));\n      \n      EProperties next = this;\n      String currentPath = \"\";\n      \n      //StringBuilder path=new StringBuilder();\n      \n      for (int i = 0; i < keys.length - 1; i++) {\n         // currentPath is used for debugging.\n         if (currentPath.equals(\"\"))\n            currentPath = keys[i];\n         else\n            currentPath = currentPath + \"->\" + keys[i];\n\n         Object nextTarget = next.get(keys[i]);\n         if (nextTarget == null) {\n            return null;\n         } else if (nextTarget instanceof EProperties) {\n            next = (EProperties) nextTarget;\n         } else {\n            log.debug(\"getComplexKey(): [\" + key\n                  + \"]: Returning null because object at path \"\n                  + currentPath + \" is not EProperties, it is \"\n                  + nextTarget.getClass().getName());\n            return null;\n         }\n      }\n      // here, we are pointed at the correct eproperties object.\n      return next.get(keys[keys.length-1]);\n   }\n\n   /** */\n   @Override\n   public String getProperty(String key) {\n      return getProperty(key, null);\n   }\n\n   /** */\n   @Override\n   public String getProperty(String key, String def) {\n      Object val = get(key);\n      \n      if (val == null)\n         return def;\n      if (val instanceof String)\n         return (String)val;\n      else\n         return def;\n   }\n\n   /** */\n   public String getString(String key) {\n      return getProperty(key);\n   }\n\n   /** */\n   public String getString(String key, String def) {\n      return getProperty(key, def);\n   }\n\n   /** */\n   public List<String> getList(String key) {\n      Object val = get(key);\n      if (val == null)\n         return null;\n      if (val instanceof List)\n         return (List<String>)val;\n      \n      // Automagically convert strings to lists.  If the return \n      // value is a string, it will be parsed as a csv list.\n      // this method is quite dumb.  First, any and all substitutions\n      // are processed when retrieving the String, not in the list.\n      // Second, if the value is a single string - with no commas, \n      // a single element list with the String as the only element \n      // is returned.\n      if (val instanceof String) {\n         List<String> l=convertStringToList((String)val);\n         return l;\n      }\n      \n      return null;\n   }\n   \n   /** converts a string to a list. */\n   private static final List<String> convertStringToList(String s) {\n      List<String> l=new ArrayList<String>();\n      String parsed[]=s.split(\"\\\\,\");\n      for (String p:parsed) \n         l.add(p);\n      return l;\n   }\n   \n   /** Returns a list with a default value if the list is null. **/\n   public List<String> getList(String key, List<String>def) {\n      List<String>rval=getList(key);\n      if (rval != null)\n         return rval;\n      return def;\n   }\n\n   /** Returns a nested EProperties object if one is available for the\n    * given key.  If not, it returns null. */\n   public EProperties getProperties(String key) {\n      Object val = get(key);\n      if (val == null)\n         return null;\n\n      if (val instanceof EProperties)\n         return (EProperties) val;\n      else\n         return null;\n   }\n\n   /** Returns a boolean.  Booleans are stored as Strings.  If the \n    * string representing the key begins with [t|T], then this\n    * method returns true - otherwise it return false.  If the \n    * key is not defined (null as a string) then this method returns\n    * false by default. */\n   public boolean getBoolean(String key) {\n      return getBoolean(key, false);\n   }\n\n   /** Boolean is a string.  If the string starts with [t | T] then \n    * this method returns true.  Otherwise, it returns false.  */\n   public boolean getBoolean(String key, boolean def) {\n      Object val = get(key);\n      \n      if (val == null)\n         return def;\n      if (val instanceof String) {\n         String s = (String) val;\n         s=s.toLowerCase().trim();\n         if (s.startsWith(\"t\"))\n            return true;\n         else\n            return false;\n      } else\n         return def;\n   }\n\n   /** Returns an integer.  Integers are stored as Strings.  If the \n    * string available with the inbound 'key' is null, or does not \n    * parse to an integer, then this method returns -1.  */\n   public int getInt(String key) {\n      return getInt(key, -1);\n   }\n\n   /** Returns an integer.  Integers are stored as Strings.  If the \n    * string available with the inbound 'key' is null, or does not \n    * parse to an integer, then this method returns the default\n    * value passed in.  */\n   public int getInt(String key, int def) {\n      Object val = get(key);\n      if (val == null) {\n         return def;\n      }\n      if (val instanceof String) {\n         String s = (String)val;\n         try {\n            return Integer.parseInt(s.trim());\n         } catch (NumberFormatException ex) {\n            log.error(\"Cannot parse int from '\" + s.trim()\n                  + \"', returning default of \" + def);\n            return def;\n         }\n      } else\n         return def;\n   }\n\n   /** Returns a long.  Longs are stored as Strings.  If the \n    * string available with the inbound 'key' is null, or does not \n    * parse to a long, then this method returns -1.  */\n   public long getLong(String key) {\n      return getLong(key, -1);\n   }\n\n   /** Returns a long.  Longs are stored as Strings.  If the \n    * string available with the inbound 'key' is null, or does not \n    * parse to a long, then this method returns the default\n    * value passed in.  */\n   public long getLong(String key, long def) {\n      Object val = get(key);\n      if (val == null)\n         return def;\n      if (val instanceof String) {\n         String s = (String)val;\n         try {\n            return Long.parseLong(s.trim());\n         } catch (NumberFormatException ex) {\n            log.error(\"Cannot parse long from \" + s.trim()\n                  + \", returning default of \" + def);\n            return def;\n         }\n      } else\n         return def;\n   }\n\n   /** Returns a float.  Floats are stored as Strings.  If the \n    * string available with the inbound 'key' is null, or does not \n    * parse to a float, then this method returns 0.0f.  */\n   public float getFloat(String key) {\n      return getFloat(key, 0.0f);\n   }\n\n   /** Returns a float.  Floats are stored as Strings.  If the \n    * string available with the inbound 'key' is null, or does not \n    * parse to a float, then this method returns the defualt value\n    * passed in.  */\n   public float getFloat(String key, float def) {\n      Object val = get(key);\n      if (val == null) {\n         return def;\n      }\n      if (val instanceof String) {\n         String s = (String) val;\n         try {\n            return Float.parseFloat(s.trim());\n         } catch (NumberFormatException ex) {\n            log.error(\"Cannot parse float from '\" + s.trim()\n                  + \"', returning default of \" + def);\n            return def;\n         }\n      } else\n         return def;\n   }\n\n   /** Returns a double.  Double are stored as Strings.  If the \n    * string available with the inbound 'key' is null, or does not \n    * parse to a double, then this method returns 0.0f.  */\n   public double getDouble(String key) {\n      return getDouble(key, 0.0f);\n   }\n\n   /** Returns a double.  Double are stored as Strings.  If the \n    * string available with the inbound 'key' is null, or does not \n    * parse to a double, then this method returns the defualt value\n    * passed in.  */\n   public double getDouble(String key, double def) {\n      Object val = get(key);\n      if (val == null) {\n         return def;\n      }\n      if (val instanceof String) {\n         String s = (String) val;\n         try {\n            return Double.parseDouble(s.trim());\n         } catch (NumberFormatException ex) {\n            log.error(\"Cannot parse double from '\" + s.trim()\n                  + \"', returning default of \" + def);\n            return def;\n         }\n      } else\n         return def;\n   }\n\n   // ///////////////////// Listener Infrastructure //////////////////////\n   /** */\n   public void addListener(PropertyListener listener) {\n      if (listeners == null)\n         listeners = new ArrayList<PropertyListener>();\n      listeners.remove(listener); // prevent duplicates\n      listeners.add(listener);\n   }\n\n   /** */\n   public void removeListener(PropertyListener obs) {\n      if (listeners != null)\n         listeners.remove(obs);\n   }\n\n   /** */\n   void notifyListeners(Key key, Object value) {\n      if (listeners == null)\n         return;\n\n      // generate the event\n      PropertyChangeEvent evt = new PropertyChangeEvent(key, value);\n\n      for (int i = 0; i < listeners.size(); i++) {\n         PropertyListener obs = listeners.get(i);\n         obs.propertyChange(evt);\n      }\n   }\n\n   @Override\n   public EProperties getPersistentValue() {\n      return this;\n   }\n\n   @Override\n   public Object getRuntimeValue() {\n      return this;\n   }\n}", "class_id": 0, "repo": "turnsk/eproperties", "file": "src/main/java/net/jmatrix/eproperties/EProperties.java", "last_update_at": "2020-11-24T08:03:38+00:00", "question_id": "f664df3b792a7bfc8a4428d77b5c2fffb8ff5eed", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EProperties extends Properties implements Value<EProperties> {\n   public static Logger log = LoggerFactory.getLogger(EProperties.class);\n   /** When set to true, EProperties will emit some debug logging. */\n   public static boolean debug=false;\n   /** When set to true, eproperties will print warnings for potentially \n    * unresolved substitutions.  */\n   public static boolean validateOnLoad=true;\n   /** This is a formatting option for the 'save' function. */\n   public static int INDENT_SPACES=3;\n   /** An internal list of Key objects.  This maintains the order of the keys, \n    * useful for saving the properties object in the same order in which it \n    * was read. */\n   private List<Key> keys = new ArrayList<Key>();\n   // if this properties object is nested inside of another, then the\n   // 'thisKey' is the value of the key that owns this object.  If this \n   // is the 'root' object, then thisKey is null;\n   String thisKey=null;\n   /** List of listeners... */\n   List<PropertyListener> listeners = null;\n   /** \n    * Root EProperties objects will have a source URL, corresponding to \n    * the file from which it was loaded.  If File A includes File B, then\n    * File A will have a sourceURL, but not a includeURL.  File B will have a \n    * sourceURL AND an includeURL.\n    */\n   URL sourceURL=null;\n   /** If this properties object is included via an include processor, \n    * then includeURL is set.  This is later used when writing properties\n    * out.  If the includeURL at a particular level is non-null, then \n    * rather than writing the actual properties, it writes the include\n    * url.  For example\n    * foo=[http://bar.com/baz.properties]\n    */\n   String includeURL=null;\n   /** Parent, if this object has a parent. */\n   EProperties parent = null;\n   /** */\n   static CacheManager cacheManager=CacheManager.getInstance();\n   /** lastModification is a unique number indicating the state of the source\n    * at the last time load() was called.  Now - in the case of a File URL, \n    * this will simply be the last modification time.  <p>\n    * \n    * This property is used to determine if the underlying property store \n    * has changed - ie, has the file, or http url, or database been modified, \n    * requiring a reload. <p>  \n    * \n    * However, in a case \n    * where properties are in a database, we don't modification time.  So an \n    * alternate method may be chosen.  This could be as simple as a the hashcode\n    * of a string composed of the concatenation of all the keys and values. \n    * How expensive this is depends on the relative proximity of the database, \n    * and the number of properties.  If such a calculation is expensive, \n    * the the monitoring thread should be slowed to an appropriate rate.  \n    * */\n   long lastModification=-1;\n   public static boolean showVersion=true;\n   private static volatile boolean versionShown=false;\n   static synchronized final void showVersion() {\n      if (showVersion == false)\n         return;\n      if (versionShown)\n         return;\n      versionShown=true;\n      InputStream is=null;\n      Properties p=null;\n      try {\n         is=EProperties.class.getResourceAsStream(\"version.properties\");\n         if (is != null) {\n            p=new Properties();\n            p.load(is);\n         }\n      } catch (Throwable t) {\n         t.printStackTrace();\n      } finally {\n         if (is != null)\n            try {is.close();} catch (Exception ex) {}\n      }\n      StringBuilder message=new StringBuilder();\n      String version=\"UNKNOWN\";\n      if (p != null)\n         version=p.getProperty(\"version\");\n      if (version == null)\n         version=\"ERROR\";\n      int dlen=14;\n      if (version.length() > dlen)\n         version=version.substring(0,dlen);\n      else if (version.length() < dlen) {\n         int add=dlen-version.length();\n         for (int i=0; i<add; i++)\n            version=version+\" \";\n      }\n      message.append(\"+-----------------------------------------------------------+\\n\");\n      message.append(\"|         Loading EProperties version \"+version   +\"        |\\n\");\n      message.append(\"| For more info, see the EProperties project on googlecode. |\\n\");\n      message.append(\"|         http://code.google.com/p/eproperties/             |\\n\");\n      message.append(\"+-----------------------------------------------------------+\\n\");\n      log.info(message.toString());\n   }\n   /** Constructs a sub-properties object, the parent collection is passed\n    * into the constructor. */\n   public EProperties(EProperties par) {\n      this();\n      parent=par;\n   }\n   /** Empty constructor.  Most commonly used as a public API, with \n    * a load() operation called soon after.  */\n   public EProperties() {\n      showVersion();\n   }\n   /** Sets the URL from which this file was included. */\n   public void setIncludedURL(String iurl) {\n      includeURL=iurl;\n   }\n   public void setOwner(EProperties p) {\n      this.parent=p;\n   }\n   /** \n    * Merges 2 property sets at the same level.  Any potentially duplicate\n    * keys would be overwritten by the new values.\n    * \n    * This operation will caused subsequent save() operations to write the \n    * merged proeprties.  \n    * \n    * This is called by the parser to implement root property includes. \n    */\n   public void merge(EProperties p) {\n      log.debug(\"Merging \"+p.size()+\" new properties.  Current path is '\"+getPath()+\"'\");\n      log.debug(\"Merging, this.findSourceURL(): \"+findSourceURL());\n      log.debug(\"Merging, p.findSourceURL(): \"+p.findSourceURL());\n      List<Key> keys = p.getKeys();\n      int size=keys.size();\n      for (int i = 0; i < size; i++) {\n         Key key = keys.get(i);\n         // 21 jul 2009 - experimental.  I think we should merge the\n         // pre-substitution values, not the derrived values.  \n         //Object val = p.get(key); \n         Object val=p.preSubstitutionGet(key);\n         if (val instanceof Value)\n            ((Value)val).setOwner(this);\n         this.put(key, val);\n      }\n   }\n   /** \n    * Deep merge in more intelligent than merge.  Merge is draconian, \n    * totally overwriting any property (including potentially deeply \n    * nested properties) with the new value. \n    * \n    * Deep merge attempts to deal with nesting of properties.  Both strings \n    * and list values are still treated as atomic, and overwritten. But\n    * deeper trees of properties a merged in a truer sense of the word.  It \n    * is more additive, with the merging properties taking precidece, but\n    * not overwriting, rather merging deep trees.\n    */\n   public void deepMerge(EProperties p) {\n      log.debug(\"Deep-Merging \"+p.size()+\" new properties.  Current path is '\"+getPath()+\"'\");\n      log.debug(\"Deep-Merging, this.findSourceURL(): \"+findSourceURL());\n      log.debug(\"Deep-Merging, p.findSourceURL(): \"+p.findSourceURL());\n      List<Key> keys=p.getKeys();\n      for (Key key:keys) {\n         String keyString=key.toString();\n         Object val=p.preSubstitutionGet(keyString);\n         log.debug(\"Deep-Merge: pre-substitution get returns \"+\n               (val == null? \"null\":(val.getClass().getName()+\", \"+val)));\n         if (val instanceof EProperties) {\n            EProperties mergingProps=(EProperties)val;\n            Object existingVal=preSubstitutionGet(keyString);\n            if (existingVal != null && existingVal instanceof EProperties) {\n               EProperties existingProps=(EProperties)existingVal;\n               existingProps.deepMerge(mergingProps);\n            } else {\n               this.put(keyString, val);\n            }\n         } else {\n            //log.debug(\"Deep merge, pre-substitution value for key '\"+key+\"' is \"+val);\n            if (val instanceof Value) \n               ((Value)val).setOwner(this);\n            this.put(keyString, val);\n         }\n      }\n   }\n   /** See flatten(String delim). */\n   public EProperties flatten() {\n      return flatten(\"|\");\n   }\n   /** Flattens properties with the inbound delimiter. */\n   public EProperties flatten(String delim) {\n      return flatten(\"\", delim);\n   }\n   /**\n    * Flattens the property structure.  Nested properties are prefixed\n    * with the name of the nesting structure.  For instance, if we have:\n    * \n    * foo=bar\n    * blah={\n    *   bing=bat\n    * }\n    * \n    * Flatten would flatten the structure to:\n    * foo=bar\n    * blah|bing=bat\n    * \n    * The delimiter is configurable (inbound on the method) with the \n    * default delimeter being the pipe character: '|'.\n    * \n    * */\n   protected EProperties flatten(String prefix, String delim) {\n      EProperties flat=new EProperties();\n      for (Key key:keys) {\n         Object val=get(key);\n         if (val == null) {\n            log.warn(\"flatten: value is null for key \"+key);\n            if (!empty(prefix))\n               flat.put(prefix+delim+key, val);\n            else \n               flat.put(key.toString(), val);\n         } else if (val instanceof EProperties) {\n            EProperties epval=(EProperties)val;\n            // recursion\n            EProperties nestedFlat=null;\n            if (!empty(prefix))\n               nestedFlat=epval.flatten(prefix+delim+key.toString(), delim);\n            else \n               nestedFlat=epval.flatten(key.toString(), delim);\n            flat.addAll(nestedFlat);\n         } else if (val instanceof List) {\n            if (!empty(prefix))\n               flat.put(prefix+delim+key, val.toString());\n            else \n               flat.put(key.toString(), val.toString());\n         } else {\n            if (!empty(prefix))\n               flat.put(prefix+delim+key, val.toString());\n            else \n               flat.put(key.toString(), val.toString());\n         }\n      }\n      return flat;\n   }\n   private static final boolean empty(String s) {\n      if (s == null || s.length() == 0)\n         return true;\n      return false;\n   }\n   /** */\n   public void addAll(Properties p) {\n      Enumeration keyset=p.keys();\n      while (keyset.hasMoreElements()) {\n         Object key=keyset.nextElement();\n         Object value=p.get(key);\n         put(key, value);\n      }\n   }\n   /** This method scans the properties tree, and returns a report of what\n    * properties have un-resolved substitutions.  */\n   public String validate() {\n      int size=keys.size();\n      StringBuilder sb=new StringBuilder();\n      for (int i=0; i<size; i++) {\n         Key key=keys.get(i);\n         // substitutions should have happened at the point that\n         // this is called.\n         Object value=get(key);\n         key.removeHit();\n         if (value instanceof String) {\n            String s=(String)value;\n            if (SubstitutionProcessor.containsTokens(s)) {\n               // this is an error.  Tokens should have been \n               // replaced by values here.\n               sb.append(\"Warning: Value for key '\"+key+\"' defined in terms of \"+\n                     \"un-resolvable substitution: '\"+s+\"'\\n\");\n            }\n         } else if (value instanceof List) {\n            List<String> list=(List<String>)value;\n            for (int j=0; j<list.size(); j++) {\n               String lv=list.get(j);\n               if (SubstitutionProcessor.containsTokens(lv)) {\n                  sb.append(\"Warning: List item value for key '\"+key+\"[\"+j+\"]' defined \"+\n                        \"in terms of un-resolvable substitution: '\"+lv+\"'\\n\");\n               }\n            }\n         } else if (value instanceof EProperties) {\n            EProperties props=(EProperties)value;\n            // maybe should indent here... \n            sb.append(props.validate());\n         } else {\n            // not really sure what this object is, if not one of the \n            // above types. I'm confused - but I'm not going to validate.\n         }\n      }\n      return sb.toString();\n   }\n   public void list(PrintStream ps) {\n      list((OutputStream)ps);\n   }\n   /** */\n   public void list(OutputStream os) {\n      list(os, false);\n   }\n   public void list(OutputStream ps, boolean hits) {\n      list(new PrintWriter(new OutputStreamWriter(ps), true), 0, hits);\n   }\n   /** */\n   public void list(PrintWriter pw) {\n      list(pw,0);\n   }\n   public void list(PrintWriter pw, int depth) {\n      list(pw, depth, false);\n   }\n   /** */\n   public void list(PrintWriter pw, int depth, boolean printhits) {\n      int size=keys.size();\n      StringBuilder sb=new StringBuilder();\n      for (int i=0; i<depth; i++) \n         sb.append(\"  \");\n      String pad=sb.toString();\n      for (int i=0; i<size; i++) {\n         Key key=keys.get(i);\n         Object value=get(key);\n         key.removeHit();\n         String keystring=null;\n         if (printhits)\n            keystring=key+\"[\"+key.getHitCount()+\"]\";\n         else\n            keystring=key.toString();\n         if (value instanceof EProperties) {\n            pw.println(pad+keystring+\" = {\");\n            ((EProperties)value).list(pw, depth+1, printhits);\n            pw.println(pad+\"}\");\n         } else if (value instanceof List) {\n//            String s=value.toString();\n//            // this will be a list starting and ending with []\n//            // replace those with ()\n//            s=s.substring(1, s.length()-1);\n            List l=(List)value;\n            StringBuilder sbb=new StringBuilder();\n            for (Object item:l) {\n               String sitem=item.toString();\n               sitem=sitem.replace(\"\\\"\", \"\\\\\\\"\"); // escape quotes in list strings.\n               sbb.append(\"\\\"\"+sitem+\"\\\", \");\n            }\n            String s=sbb.toString();\n            // trim the final , \n            s=s.substring(0, s.length()-2);\n            pw.println (pad+keystring+\"=(\"+s+\")\");\n         }else {\n            pw.println (pad+keystring+\"=\"+value);\n         }\n      }\n   }\n   public String list() {\n      ByteArrayOutputStream baos=new ByteArrayOutputStream();\n      PrintWriter pw=new PrintWriter(new OutputStreamWriter(baos), true);\n      list(pw);\n      pw.flush();\n      return baos.toString();\n   }\n   public String list(int depth) {\n      ByteArrayOutputStream baos=new ByteArrayOutputStream();\n      PrintWriter pw=new PrintWriter(new OutputStreamWriter(baos), true);\n      list(pw, depth);\n      pw.flush();\n      return baos.toString();\n   }\n   ///////////////////////  Lineage  ////////////////////////////\n   public void setParent(EProperties p, String key) {\n      parent=p;\n      thisKey=key;\n   }\n   /** */\n   public String getPath() {\n      StringBuilder sb=new StringBuilder();\n      String key=thisKey;\n      EProperties nextParent=parent;\n      while (nextParent != null) {\n         sb.insert(0, \"->\"+key);\n         key=parent.thisKey;\n         if (key == null)\n            key=\"UNKNOWN\";\n         nextParent=nextParent.parent;\n      }\n      return sb.toString();\n    }\n   /**\n    * This is the sole method for putting objects into the EProperties object.\n    * \n    * This is synchronized to prevent concurrent access with load/read operations.\n    */\n   @Override\n   public synchronized Object put(Object k, Object v) {\n      if (k == null) {\n         throw new NullPointerException(\"Key cannot be null in EProperties.\");\n      }\n      Key key = null;\n      // \n      if (k instanceof String) {\n         key = new Key((String) k);\n      } else if (k instanceof Key) {\n         key = (Key) k;\n      } else {\n         throw new Error(\"Keys in EProperties must be [Key | String], not \"+k.getClass().getName());\n      }\n      String keyString=key.toString();\n      if (keyString.indexOf(\"->\") != -1) {\n         // this is a complex key.\n         return putWithComplexKey(keyString, v);\n         // FIXME: This does not account for listeners to keys/properties at any level\n      }\n      // Prevent duplicate keys, preserve order, notify listeners\n      int keyIndex = keys.indexOf(key);\n      if (keyIndex == -1)\n         keys.add(key);\n      else {\n         //Key existingKey = keys.get(keys.indexOf(key));\n         //existingKey.notifyListeners(v);\n         key=keys.get(keyIndex); // replace created key w/ existing key\n      }\n      // build a value object.\n      // There are 3 and only 3 types of values:\n      //   1) String values.\n      //   2) List Values, and\n      //   3) EProperties values.\n      // \n      // attempting to put any\n      Object returnVal=v;\n      Value value=null;\n      if (v == null) {\n         // Allowing us to call put(key, null). Setting a property to \n         // null is defined as removing that property.\n         //super.put(key, v);\n         super.remove(key);\n      } else if (v instanceof String) {\n         value=new StringValue((String)v, this);\n         super.put(key, value);\n      } else if (v instanceof List) {\n         value=new ListValue((List)v, this);\n         super.put(key, value);\n      } else if (v instanceof EProperties) {\n         super.put(key, v);\n         // set parent.\n         //setParent((EProperties)v, key.toString());\n         ((EProperties)v).setParent(this, key.toString());\n      } else if (v instanceof StringValue ||\n                 v instanceof ListValue) {\n         Value vv=(Value)v;\n         log.debug(\"Putting raw StringValue or ListValue: persistent: \"+\n               vv.getPersistentValue()+\" runtime: \"+vv.getRuntimeValue());\n         super.put(key, v);\n      } else {\n         throw new Error(\"EProperties put() values can only be: \"+\n               \"[String | List<String> | EProperties | StringValue | ListValue].  \"+\n               \"Not \"+v.getClass().getName());\n      }\n      if (this.listeners != null) {\n         notifyListeners(key, value);\n      }\n      // This will do nothing if there are no listeners.\n      key.notifyListeners(returnVal);\n      return returnVal;\n   }\n   /** \n    * putWithCompleKey() works much like getWithComplexKey().  I will give a \n    * simple example under 2 different conditions.\n    * \n    * In both examples, the key is nested->foo.  In both cases the put method\n    * has been called on a properties object we'll call 'root'.  \n    * \n    * Case 1: The 'root' EProperties object already has a nested properties\n    *         object named 'nested'.  In this case, we simply get a handle\n    *         to the deeper properties object called 'nested' and on it\n    *         we call put(key, val) with the key being a simple key 'foo' \n    *         and the value being the inbound value.  ALL BEHAVIORS OF PUT\n    *         AT THAT POINT ARE IDENTICAL. Ie, if the value does not already \n    *         exist, it is added.  If the value does exist, IN ANY FORM - ie\n    *         String, List or nested Properties - it is overwritten with \n    *         the inbound object value.\n    *         \n    * Case 2: The 'root' EProperties object does not already have a nested\n    *         properties object called 'nested'.  In this case, a new properties\n    *         object is created, named 'nested' and added to 'root'.  \n    *         \n    * For keys with more than 2 levels of depth (ie, a->b->c), the process\n    * above is repeated until the last key (c in this example) is found - and \n    * that key represents the inbound value in the nested objects a->b that\n    * either already exist, or are created by this method.\n    */\n   private synchronized Object putWithComplexKey(String key, Object value) {\n      String keys[] = key.split(\"\\\\-\\\\>\");\n      log.debug (\"getComplexKey(): \"+Arrays.asList(keys));\n      EProperties next = this;\n      String currentPath = \"\";\n      //StringBuilder path=new StringBuilder();\n      for (int i = 0; i < keys.length - 1; i++) {\n         // currentPath is used for debugging.\n         EProperties prev=next;\n         next=prev.getProperties(keys[i]);\n         if (next == null) {\n            // Create nested props that do not exist.\n            next=new EProperties();\n            prev.put(keys[i], next);\n         }\n      }\n      return next.put(keys[keys.length-1], value);\n   }\n   /** */\n   @Override\n   public synchronized void putAll(Map m) {\n      Iterator i=m.keySet().iterator();\n      while (i.hasNext()) {\n         Object key=i.next();\n         Object val=m.get(key);\n         put(key, val);\n      }\n   }\n   /** */\n   @Override\n   public Object remove(Object k) {\n      Key key = null;\n      if (k instanceof String) {\n         key = new Key((String) k);\n      } else if (k instanceof Key) {\n         key = (Key) k;\n      } else {\n         throw new Error(\"Keys in EProperties must be [Key, String].\");\n      }\n      keys.remove(key);\n      Object returnVal=super.remove(key);\n      notifyListeners(key, returnVal);\n      return returnVal;\n   }\n   /** Logs 'hits' to keys.  This allows us to know what properties are being\n    * used in a long running JVM.  See Key.getHitCount(). */\n   private void keyHit(Object key) {\n      if (key instanceof String)\n         key=new Key((String)key);\n      int index=keys.indexOf(key);\n      if (index < 0) {\n      } else {\n         Key thekey=keys.get(index);\n         thekey.hit();\n      }\n   }\n   /**\n    * All getters funnel to this location.  This is the 'super' get.  \n    */\n   @Override\n   public Object get(Object key) {\n      Object val=null;\n      if (key instanceof String) { \n         String skey=(String)key;\n         if (skey.indexOf(\"->\") > 0)\n            val=getWithComplexKey(skey);\n         else {\n            val=super.get(key);\n            if (val != null)\n               keyHit(key);\n         }\n      } else { \n         val=super.get(key);\n         if (val != null)\n            keyHit(key);\n      }\n      log.debug(\"get, key: '\"+key+\"', keyclass: \"+key.getClass().getName());\n      log.debug (\"get, val: '\"+val+\"' valClass: \"+(val == null?\"\":val.getClass().getName()));\n      if (val instanceof Value) {\n         Value vv=(Value)val;\n         log.debug(\"   Value.getPersistent: '\" + vv.getPersistentValue()+\"'\");\n         log.debug(\"   Value.getRuntime   : '\"+vv.getRuntimeValue()+\"'\");\n      }\n      // At this point, val could be null.\n      if (val == null)\n         return val;\n      // here, we'll process substitutions if they exist...\n      if (val instanceof StringValue) {\n         Object rtval=((StringValue)val).getRuntimeValue();\n         if (rtval instanceof String &&\n            SubstitutionProcessor.containsTokens((String)rtval)) {\n            log.warn(\"Value for key '\"+key+\"' defined in terms of \"+\n                     \"un-resolvable substitution: '\"+rtval+\"'\");\n         }\n         return rtval;\n      }\n      else if (val instanceof ListValue) {\n         List<String> list=((ListValue)val).getRuntimeValue();\n         for (int j=0; j<list.size(); j++) {\n            String lv=list.get(j);\n            if (SubstitutionProcessor.containsTokens(lv)) {\n               log.warn(\"List item value for key '\"+key+\"[\"+j+\"]' defined \"+\n                     \"in terms of un-resolvable substitution: '\"+lv+\"'\\n\");\n            }\n         }\n         return list;\n      }\n      // this can and will be EProperties as well as primitives.\n      return val;\n   }\n   private Object preSubstitutionGet(Object key) {\n      log.debug(\"Pre-sub get \"+key);\n      return super.get(key);\n   }\n   /** */\n   public Object internalGetValue(Object key) {\n      // note, this key must be a Key, not a String\n      return super.get(key);\n   }\n   /** */\n   public EProperties internalResolveProperties(String path) {\n      if (path.indexOf(\"->\") == -1)\n         return this;\n      String keys[] = path.split(\"\\\\-\\\\>\");\n      log.debug (\"getComplexKey(): \"+Arrays.asList(keys));\n      EProperties next = this;\n      String currentPath = \"\";\n      //StringBuilder path=new StringBuilder();\n      for (int i = 0; i < keys.length - 1; i++) {\n         // currentPath is used for debugging.\n         if (currentPath.equals(\"\"))\n            currentPath = keys[i];\n         else\n            currentPath = currentPath + \"->\" + keys[i];\n         Object nextTarget = next.get(keys[i]);\n         if (nextTarget == null) {\n            return null;\n         } else if (nextTarget instanceof EProperties) {\n            next = (EProperties) nextTarget;\n         } else {\n            log.debug(\"getComplexKey(): [\" + path\n                  + \"]: Returning null because object at path \"\n                  + currentPath + \" is not EProperties, it is \"\n                  + nextTarget.getClass().getName());\n            return null;\n         }\n      }\n      // here, we are pointed at the correct eproperties object.\n      //return next.get(keys[keys.length-1]);\n      return next;\n   }\n   /** */\n   public Key internalResolveKey(String path) {\n      EProperties p=null;\n      String finalKey=null;\n      if (path.indexOf(\"->\") != -1) {\n         p=internalResolveProperties(path); // can return null;\n         String keyelements[]=path.split(\"\\\\-\\\\>\");\n         finalKey=keyelements[keyelements.length-1];\n      } else {\n         p=this;\n         finalKey=path;\n      }\n      if (p == null)\n         return null;\n      List<Key> keys=p.getKeys();\n      for (Key key:keys) {\n         if (key.toString().equals(finalKey))\n            return key;\n      }\n      return null;\n   }\n   /** */\n   public Object get(String key, Object def) {\n      Object ret = get(key);\n      if (ret == null)\n         return def;\n      else\n         return ret;\n   }\n   /** */\n   public List<Key> getKeys() {\n      return keys;\n   }\n   /** */\n   public Object get(int keyNum) {\n      return get(getKey(keyNum));\n   }\n   /** */\n   public Key getKey(int i) {\n      return keys.get(i);\n   }\n   /** Returns a list of keys that start with the input string. */\n   public List<Key> getKeys(String s) {\n      List<Key> prefixKeys = new ArrayList<Key>();\n      int size = keys.size();\n      for (int i = 0; i < size; i++) {\n         Key key = keys.get(i);\n         if (key.toString().startsWith(s))\n            prefixKeys.add(key);\n      }\n      return prefixKeys;\n   }\n   @Override\n   public synchronized Enumeration keys() {\n      Vector v=new Vector();\n      int size = keys.size();\n      for (int i = 0; i < size; i++) {\n         Key key = keys.get(i);\n         v.add(key.toString());\n      }\n      return v.elements();\n   }\n   @Override\n   public synchronized Collection values() {\n      Vector v=new Vector();\n      int size = keys.size();\n      for (int i = 0; i < size; i++) {\n         v.add(get(i));\n      }\n      return v;\n   }\n   @Override \n   public synchronized Enumeration elements() {\n      return new VectorEnumerator((Vector)values());\n   }\n   public static class VectorEnumerator implements Enumeration {\n      Vector v=null;\n      int index=0;\n      public VectorEnumerator(Vector v) {\n         this.v=v;\n      }\n      public boolean hasMoreElements() {\n         if (index < v.size())\n            return true;\n         return false;\n      }\n      public Object nextElement() {\n         index++;\n         return v.get(index-1);\n      }\n   }\n   @Override\n   public synchronized Set keySet() {\n      HashSet hashSet=new HashSet();\n      int size = keys.size();\n      for (int i = 0; i < size; i++) {\n         Key key = keys.get(i);\n         hashSet.add(key.toString());\n      }\n      return hashSet;\n   }\n   @Override\n   public Set<Map.Entry<Object, Object>> entrySet() {\n      // This sucks to have to do, but Entry is a private class in \n      // hashmap.  And entrySet() is called fromn putAll().  Meaning I\n      // MUST override this or people who copy this properties object\n      // by constructing a new one, and calling putAll() and then assuming\n      // that the keys are strings will fail. (Spring.  Spring sucks.)\n      HashMap map=new HashMap();\n      for (Key key:keys) {\n         map.put(key.toString(), get(key));\n      }\n      return map.entrySet();\n   }\n   @Override\n   public Enumeration<String> propertyNames() {\n      return keys();\n   }\n   //@Override // this is an override only in 1.6\n   public Set<String> stringPropertyNames() {\n      return keySet();\n   }\n   @Override \n   public synchronized boolean containsKey(Object key) {\n      Object val=get(key);\n      if (val != null)\n         return true;\n      return false;\n   }\n   @Override\n   public synchronized boolean contains(Object value) {\n      if (value == null)\n         return false;\n      // inefficient, but functional.\n      int size = keys.size();\n      for (int i = 0; i < size; i++) {\n         Object val=get(i);\n         if (val.equals(value))\n            return true;\n      }\n      return false;\n   }\n   @Override \n   public synchronized String toString() {\n      return list();\n   }\n   ///////////////////////// Load/Save Methods ////////////////////////////\n   /** This is the 'master' load() method.  All other load methods delegate\n    * here for actual property loading.  */\n   @Override\n   public synchronized void load(InputStream is) \n   throws IOException {\n      InputStream cis=cacheManager.getInputStream(is, sourceURL);\n      EPropertiesParser parser=new EPropertiesParser(cis);\n      parser.setSourceURL(sourceURL);\n      try {\n         parser.parse(this);\n      } catch (Exception ex) {\n         // this constructor is only available in Java 1.6\n         //throw new IOException(\"Error parsing EProperties.\", ex);\n         ex.printStackTrace();\n         throw new IOException(\"Error parsing Properties. \"+ex.getMessage());\n      } finally {\n         if (cis != null) {\n            try {\n               cis.close();\n            } catch (Exception clex) {\n               clex.printStackTrace();\n            }\n         }\n      }\n      if (validateOnLoad)\n         validate();\n   }\n//   @Override\n//   public synchronized void load(Reader r) {\n//      throw new RuntimeException(\"not implemented.\");\n//   }\n   /**\n    * Loads properties with a string representing either a URL or \n    * a file.  \n    * \n    * @param surl\n    */\n   public void load(String surl) throws IOException {\n      URL url=null;\n      surl=URLUtil.convertClasspathURL(surl);\n      String lcurl=surl.toLowerCase();\n      if (lcurl.startsWith(\"http://\") || lcurl.startsWith(\"https://\") ||\n          lcurl.startsWith(\"file:/\") || lcurl.startsWith(\"jar:file:/\")) {\n         url=new URL(surl);\n      } else {\n         url=(new File(surl)).toURI().toURL();\n      }\n      load(url);\n   }\n   /** */\n   public synchronized void load(URL url) \n      throws IOException {\n      setSourceURL(url);\n      InputStream is=null;\n      try {\n         is=cacheManager.getInputStream(url);\n         load(is);\n         lastModification=URLUtil.lastMod(url);\n         log.debug(\"Last Mod is '\"+lastModification+\"'\");\n      } finally {\n         if (is != null)\n            is.close();\n      }\n   }\n   /** */\n   public boolean isSourceModified() {\n      // FIXME, 18 AUG 2010 - possible NPE. sourceURL could be null.\n      URL surl=sourceURL;\n      if (surl == null) {\n         surl=findSourceURL();\n      }\n      if (surl == null) \n         return false;\n      try {\n         long lastMod=URLUtil.lastMod(surl);\n         if (lastMod != lastModification) \n            return true;\n      } catch (Exception ex) {\n         log.error(\"Error checking source modification\", ex);\n      }\n      return false;\n   }\n   /** */\n   public void load(File f) \n    throws IOException {\n      load(f.toURI().toURL());\n   }\n   /** Reloads this EProperties object from its sourceURL. If this EProperties\n    * object does not have a sourceURL, this method does nothing.\n    */\n   public void reload() \n      throws IOException {\n      if (sourceURL != null) {\n         load(sourceURL);\n      } else {\n         log.warn(\"reload() called on EProperties, but sourceURL is null.  noop.\");\n      }\n   }\n   /** */\n   public URL getSourceURL() {\n      URL url = sourceURL;\n      if (url != null)\n         return url;\n      EProperties next = parent;\n      while (next != null && url == null) {\n         url = next.sourceURL;\n         next = next.parent;\n      }\n      return url;\n   }\n   /** */\n   public void setSourceURL(URL url) {\n      log.debug(\"Setting source URL '\"+url+\"'\");\n      sourceURL = url;\n   }\n   /** */\n   public final URL findSourceURL() {\n      EProperties props = this;\n      URL url = sourceURL;\n      while (url == null && props != null) {\n         props = props.parent;\n         if (props != null)\n            url = props.sourceURL;\n      }\n      return url;\n   }\n   /** Save to the file currently identified by sourceURL.  sourceURL must be\n    * file based - and not http based - we can't magically save to an \n    * http stream.\n    * \n    * If this method is called on a properties object without a sourceURL, \n    * this method searches up the tree to find a properties object that\n    * does have a source URL - and that object is saved if it can be found, \n    * and has a file:// based source url.\n    * \n    * @return Returns true if a save has been executed, false if not possible.\n    * @throws IOException\n    */\n   public boolean save() throws IOException {\n      if (sourceURL != null) {\n         if (sourceURL.getProtocol() != null\n               && sourceURL.getProtocol().equals(\"file\")) {\n            File f;\n            try {\n               f = new File(sourceURL.toURI());\n            } catch (Exception ex) {\n               // this constructor is only available in Java 1.6\n               //throw new IOException(\"Unable to form File from URL.\", ex);\n               ex.printStackTrace();\n               throw new IOException(\"Unable to form File from URL. \"+ex.getMessage());\n            }\n            save(f);\n         } else {\n            log.debug(\"Cannot save properties with URL \" + sourceURL);\n         }\n         return true;\n      } else {\n         if (parent != null) {\n            return parent.save();\n         } else {\n            return false;\n         }\n      }\n   }\n   public void save(File f) throws IOException {\n      save(new FileWriter(f));\n   }\n   public void save(OutputStream os)\n   throws IOException {\n      save(new OutputStreamWriter(os));\n   }\n   public void save(Writer w) \n   throws IOException {\n      save(w, 0);\n   }\n   /** */\n   private synchronized void save(Writer w, int indent) \n      throws IOException {\n      String pad=\"\";\n      if (indent > 0) {\n         StringBuilder sb=new StringBuilder();\n         for (int i=0; i<INDENT_SPACES*indent; i++) {\n            sb.append(\" \");\n         }\n         pad=sb.toString();\n      }\n      try {\n         int size=keys.size();\n         for (int i=0; i<size; i++) {\n            Key key=keys.get(i);\n            // writing key= is the same for string, list, properties, or\n            // inclusion.\n            // first, write comment lines if they exist\n            String comments=key.getComments();\n            if (comments != null) {\n               // trim off trailing newline, then pad, then append newline\n               comments=comments.trim(); \n               comments=pad+comments;\n               comments=comments.replace(\"\\n\", \"\\n\"+pad);\n               comments=comments+\"\\n\";\n               w.write(comments);\n            }\n            w.write(pad+key.toString()+\"=\");\n            // now, write the value, depending on its type.\n            Object val=preSubstitutionGet(key);\n            if (val == null) {\n               w.write(\"\\n\"); // null is an unquoted empty line.\n               // this will allow for the definition of a non-null\n               // empty string as \"\".\n            } else if (val instanceof StringValue) {\n               String s=(String) ((StringValue)val).getPersistentValue();\n               w.write(\"\\\"\"+s+\"\\\"\\n\");\n            } else if (val instanceof EProperties) {\n               EProperties pval=(EProperties)val;\n               if (pval.includeURL != null) {\n                  // these properties were included.\n                  w.write(\"[\"+pval.includeURL+\"]\\n\");\n               } else {\n                  w.write(\"{\\n\");\n                  pval.save(w, indent+1);\n                  w.write(pad+\"}\\n\");\n               }\n            } else if (val instanceof ListValue) {\n               List list=(List)((ListValue)val).getPersistentValue();\n               if (list.size() == 0) {\n                  w.write(\"( )\\n\");\n               } else {\n                  String keypad=pad(key.toString().length()+2, \" \");\n                  w.write(\"(\");\n                  int lsize=list.size();\n                  for (int j=0; j<lsize; j++) {\n                     w.write(\"\\\"\"+list.get(j)+\"\\\"\");\n                     if (j == lsize-1) // last element\n                        w.write(\")\\n\");\n                     else \n                        w.write(\", \\n\"+pad+keypad);\n                  }\n               }\n            } else {\n               log.error(\"What kind of value?? \"+val.getClass().getName());\n            }\n            // append this newline for whitespace readability\n            //if (i != size-1)\n            //   w.write(\"\\n\");\n         }\n         // end of the for loop.\n      } finally {\n         if (w != null)\n            w.flush();\n      }\n   }\n   /** */\n   public void save(String filename) \n      throws IOException {\n      save(new FileOutputStream(filename));\n   }\n   private static final String pad(int pad, String padChar) {\n      StringBuilder sb=new StringBuilder();\n      for (int i=0; i<pad; i++) {\n         sb.append(padChar);\n      }\n      return sb.toString();\n   }\n   /////////////////////////   Convience Put Methods  ////////////////////\n   /** */\n   public void putBoolean(String key, boolean value) {\n      String val = null;\n      if (value)\n         val = \"true\";\n      else\n         val = \"false\";\n      put(key, val);\n   }\n   /** */\n   public void putInt(String key, int i) {\n      String val = \"\" + i;\n      put(key, val);\n   }\n   /** */\n   public void putLong(String key, long l) {\n      String val = \"\" + l;\n      put(key, val);\n   }\n   @Override\n   public Object setProperty(String k, String v) {\n      return put(k, v);\n   }\n   /////////////////////////  Token Substitution  /////////////////////////\n   /**\n    * This method will search up a tree of EProoperties objects, looking for \n    * a match.  It will return the first match.\n    * \n    * @param s\n    * @return\n    */\n   public String findProperty(String s) {\n      String val=getString(s, null);\n      log.debug(\"findProperty(): Path='\"+getPath()+\"', \"+s+\"=\"+val);\n      if (val != null)\n         return val;\n      else {\n         if (parent != null) {\n            return parent.findProperty(s);\n         } else {\n            log.debug(\"findProperty(): parent is null at Path='\"+getPath()+\"'\");\n         }\n      }\n      return val;\n   }\n   /**\n    * This method will search up a tree of EProoperties objects, looking for \n    * a match.  It will return the first match.\n    * \n    * @param s\n    * @return\n    */\n   public Object findValue(String s) {\n      Object val=get(s, null);\n      log.debug(\"findValue(): Path='\"+getPath()+\"', \"+s+\"=\"+val);\n      if (val != null)\n         return val;\n      else {\n         if (parent != null) {\n            return parent.findValue(s);\n         } else {\n            log.debug(\"findValue(): parent is null at Path='\"+getPath()+\"'\");\n         }\n      }\n      return val;\n   }\n   // /////////////////////// Accessor Methods ///////////////////////////\n   public EProperties getProperties(Key key) {\n      return getProperties(key.toString());\n   }\n   private Object getWithComplexKey(String key) {\n      // a complex key uses a pointer syntax find properties\n      // deeper in a structure.\n      // for instance:\n      // String s=(String)get(\"system->user.home\");\n      // is equivalent to\n      // String s=(String)getProperties(\"system\").get(\"user.home\");\n      //\n      // Which brings up the issue of error handling. What if one of the\n      // indirections returns a null nested property object!!\n      // At that we simply return null - as if you requested a value \n      // from an EProperties object where the key does not exist.\n      //\n      // The final key can return any type of object (String, Vector,\n      // Properties),\n      // however all of the initial keys must return a nested EProperties\n      // object. If they do not, then it returns null.\n      String keys[] = key.split(\"\\\\-\\\\>\");\n      log.debug (\"getComplexKey(): \"+Arrays.asList(keys));\n      EProperties next = this;\n      String currentPath = \"\";\n      //StringBuilder path=new StringBuilder();\n      for (int i = 0; i < keys.length - 1; i++) {\n         // currentPath is used for debugging.\n         if (currentPath.equals(\"\"))\n            currentPath = keys[i];\n         else\n            currentPath = currentPath + \"->\" + keys[i];\n         Object nextTarget = next.get(keys[i]);\n         if (nextTarget == null) {\n            return null;\n         } else if (nextTarget instanceof EProperties) {\n            next = (EProperties) nextTarget;\n         } else {\n            log.debug(\"getComplexKey(): [\" + key\n                  + \"]: Returning null because object at path \"\n                  + currentPath + \" is not EProperties, it is \"\n                  + nextTarget.getClass().getName());\n            return null;\n         }\n      }\n      // here, we are pointed at the correct eproperties object.\n      return next.get(keys[keys.length-1]);\n   }\n   /** */\n   @Override\n   public String getProperty(String key) {\n      return getProperty(key, null);\n   }\n   /** */\n   @Override\n   public String getProperty(String key, String def) {\n      Object val = get(key);\n      if (val == null)\n         return def;\n      if (val instanceof String)\n         return (String)val;\n      else\n         return def;\n   }\n   /** */\n   public String getString(String key) {\n      return getProperty(key);\n   }\n   /** */\n   public String getString(String key, String def) {\n      return getProperty(key, def);\n   }\n   /** */\n   public List<String> getList(String key) {\n      Object val = get(key);\n      if (val == null)\n         return null;\n      if (val instanceof List)\n         return (List<String>)val;\n      // Automagically convert strings to lists.  If the return \n      // value is a string, it will be parsed as a csv list.\n      // this method is quite dumb.  First, any and all substitutions\n      // are processed when retrieving the String, not in the list.\n      // Second, if the value is a single string - with no commas, \n      // a single element list with the String as the only element \n      // is returned.\n      if (val instanceof String) {\n         List<String> l=convertStringToList((String)val);\n         return l;\n      }\n      return null;\n   }\n   /** converts a string to a list. */\n   private static final List<String> convertStringToList(String s) {\n      List<String> l=new ArrayList<String>();\n      String parsed[]=s.split(\"\\\\,\");\n      for (String p:parsed) \n         l.add(p);\n      return l;\n   }\n   /** Returns a list with a default value if the list is null. **/\n   public List<String> getList(String key, List<String>def) {\n      List<String>rval=getList(key);\n      if (rval != null)\n         return rval;\n      return def;\n   }\n   /** Returns a nested EProperties object if one is available for the\n    * given key.  If not, it returns null. */\n   public EProperties getProperties(String key) {\n      Object val = get(key);\n      if (val == null)\n         return null;\n      if (val instanceof EProperties)\n         return (EProperties) val;\n      else\n         return null;\n   }\n   /** Returns a boolean.  Booleans are stored as Strings.  If the \n    * string representing the key begins with [t|T], then this\n    * method returns true - otherwise it return false.  If the \n    * key is not defined (null as a string) then this method returns\n    * false by default. */\n   public boolean getBoolean(String key) {\n      return getBoolean(key, false);\n   }\n   /** Boolean is a string.  If the string starts with [t | T] then \n    * this method returns true.  Otherwise, it returns false.  */\n   public boolean getBoolean(String key, boolean def) {\n      Object val = get(key);\n      if (val == null)\n         return def;\n      if (val instanceof String) {\n         String s = (String) val;\n         s=s.toLowerCase().trim();\n         if (s.startsWith(\"t\"))\n            return true;\n         else\n            return false;\n      } else\n         return def;\n   }\n   /** Returns an integer.  Integers are stored as Strings.  If the \n    * string available with the inbound 'key' is null, or does not \n    * parse to an integer, then this method returns -1.  */\n   public int getInt(String key) {\n      return getInt(key, -1);\n   }\n   /** Returns an integer.  Integers are stored as Strings.  If the \n    * string available with the inbound 'key' is null, or does not \n    * parse to an integer, then this method returns the default\n    * value passed in.  */\n   public int getInt(String key, int def) {\n      Object val = get(key);\n      if (val == null) {\n         return def;\n      }\n      if (val instanceof String) {\n         String s = (String)val;\n         try {\n            return Integer.parseInt(s.trim());\n         } catch (NumberFormatException ex) {\n            log.error(\"Cannot parse int from '\" + s.trim()\n                  + \"', returning default of \" + def);\n            return def;\n         }\n      } else\n         return def;\n   }\n   /** Returns a long.  Longs are stored as Strings.  If the \n    * string available with the inbound 'key' is null, or does not \n    * parse to a long, then this method returns -1.  */\n   public long getLong(String key) {\n      return getLong(key, -1);\n   }\n   /** Returns a long.  Longs are stored as Strings.  If the \n    * string available with the inbound 'key' is null, or does not \n    * parse to a long, then this method returns the default\n    * value passed in.  */\n   public long getLong(String key, long def) {\n      Object val = get(key);\n      if (val == null)\n         return def;\n      if (val instanceof String) {\n         String s = (String)val;\n         try {\n            return Long.parseLong(s.trim());\n         } catch (NumberFormatException ex) {\n            log.error(\"Cannot parse long from \" + s.trim()\n                  + \", returning default of \" + def);\n            return def;\n         }\n      } else\n         return def;\n   }\n   /** Returns a float.  Floats are stored as Strings.  If the \n    * string available with the inbound 'key' is null, or does not \n    * parse to a float, then this method returns 0.0f.  */\n   public float getFloat(String key) {\n      return getFloat(key, 0.0f);\n   }\n   /** Returns a float.  Floats are stored as Strings.  If the \n    * string available with the inbound 'key' is null, or does not \n    * parse to a float, then this method returns the defualt value\n    * passed in.  */\n   public float getFloat(String key, float def) {\n      Object val = get(key);\n      if (val == null) {\n         return def;\n      }\n      if (val instanceof String) {\n         String s = (String) val;\n         try {\n            return Float.parseFloat(s.trim());\n         } catch (NumberFormatException ex) {\n            log.error(\"Cannot parse float from '\" + s.trim()\n                  + \"', returning default of \" + def);\n            return def;\n         }\n      } else\n         return def;\n   }\n   /** Returns a double.  Double are stored as Strings.  If the \n    * string available with the inbound 'key' is null, or does not \n    * parse to a double, then this method returns 0.0f.  */\n   public double getDouble(String key) {\n      return getDouble(key, 0.0f);\n   }\n   /** Returns a double.  Double are stored as Strings.  If the \n    * string available with the inbound 'key' is null, or does not \n    * parse to a double, then this method returns the defualt value\n    * passed in.  */\n   public double getDouble(String key, double def) {\n      Object val = get(key);\n      if (val == null) {\n         return def;\n      }\n      if (val instanceof String) {\n         String s = (String) val;\n         try {\n            return Double.parseDouble(s.trim());\n         } catch (NumberFormatException ex) {\n            log.error(\"Cannot parse double from '\" + s.trim()\n                  + \"', returning default of \" + def);\n            return def;\n         }\n      } else\n         return def;\n   }\n   // ///////////////////// Listener Infrastructure //////////////////////\n   /** */\n   public void addListener(PropertyListener listener) {\n      if (listeners == null)\n         listeners = new ArrayList<PropertyListener>();\n      listeners.remove(listener); // prevent duplicates\n      listeners.add(listener);\n   }\n   /** */\n   public void removeListener(PropertyListener obs) {\n      if (listeners != null)\n         listeners.remove(obs);\n   }\n   /** */\n   void notifyListeners(Key key, Object value) {\n      if (listeners == null)\n         return;\n      // generate the event\n      PropertyChangeEvent evt = new PropertyChangeEvent(key, value);\n      for (int i = 0; i < listeners.size(); i++) {\n         PropertyListener obs = listeners.get(i);\n         obs.propertyChange(evt);\n      }\n   }\n   @Override\n   public EProperties getPersistentValue() {\n      return this;\n   }\n   @Override\n   public Object getRuntimeValue() {\n      return this;\n   }\n"]]}
{"hexsha": "c63559d3be42f326bb942434a9722814a61aa588", "ext": "java", "lang": "Java", "content": "public class ManuscriptDatabaseStorageImplTest extends ContextUnitTest {\n    private static Logger log = Logger.getLogger(ManuscriptDatabaseStorageImplTest.class);\n    private static final String TEST_JOURNAL_CODE = \"test\";\n    private static final String TEST_JOURNAL_NAME = \"Test Journal\";\n    private static final String TEST_MANUSCRIPT_ID_1 = \"MS_TEST_12345\";\n    private static final String TEST_MANUSCRIPT_ID_2 = \"MS_TEST_99999\";\n\n    private StoragePath collectionPath = new StoragePath();\n    private StoragePath manuscriptPath1 = new StoragePath();\n    private StoragePath manuscriptPath2 = new StoragePath();\n\n    public ManuscriptDatabaseStorageImplTest() {\n        collectionPath = StoragePath.createJournalPath(TEST_JOURNAL_CODE);\n        manuscriptPath1 = StoragePath.createManuscriptPath(TEST_JOURNAL_CODE, TEST_MANUSCRIPT_ID_1);\n        manuscriptPath2 = StoragePath.createManuscriptPath(TEST_JOURNAL_CODE, TEST_MANUSCRIPT_ID_2);\n    }\n\n    @Before\n    public void setUp() {\n        super.setUp();\n        // Create a journal\n        DryadJournalConcept journal = null;\n        try {\n            DryadJournalConcept journalConcept = new DryadJournalConcept();\n            journalConcept.setFullName(TEST_JOURNAL_NAME);\n            journalConcept.setJournalID(TEST_JOURNAL_CODE);\n            Context context = new Context();\n            JournalUtils.addDryadJournalConcept(context, journalConcept);\n            journal = JournalConceptDatabaseStorageImpl.getJournalConceptByCodeOrISSN(context, TEST_JOURNAL_CODE);\n            context.complete();\n        } catch (Exception ex) {\n            fail(\"Exception setting up test journal: \" + ex);\n        }\n\n        // Create a manuscript\n        Manuscript manuscript = new Manuscript();\n        manuscript.configureTestValues();\n        manuscript.setManuscriptId(TEST_MANUSCRIPT_ID_1);\n        try {\n            DatabaseManager.deleteByValue(context, ManuscriptDatabaseStorageImpl.MANUSCRIPT_TABLE, ManuscriptDatabaseStorageImpl.COLUMN_MSID, TEST_MANUSCRIPT_ID_1);\n            TableRow manuscriptRow = ManuscriptDatabaseStorageImpl.tableRowFromManuscript(manuscript, journal.getConceptID());\n            manuscriptRow.setColumn(ManuscriptDatabaseStorageImpl.COLUMN_VERSION, 1);\n            manuscriptRow.setColumn(ManuscriptDatabaseStorageImpl.COLUMN_ACTIVE, ManuscriptDatabaseStorageImpl.ACTIVE_TRUE);\n            DatabaseManager.insert(context, manuscriptRow);\n            context.commit();\n        } catch (Exception ex) {\n            fail(\"Exception setting up test manuscript: \" + ex);\n        }\n    }\n\n    @Override\n    public void tearDown() {\n        try {\n            DatabaseManager.deleteByValue(context, ManuscriptDatabaseStorageImpl.MANUSCRIPT_TABLE, ManuscriptDatabaseStorageImpl.COLUMN_MSID, TEST_MANUSCRIPT_ID_1);\n            DatabaseManager.deleteByValue(context, ManuscriptDatabaseStorageImpl.MANUSCRIPT_TABLE, ManuscriptDatabaseStorageImpl.COLUMN_MSID, TEST_MANUSCRIPT_ID_2);\n        } catch (SQLException ex) {\n            fail(\"Exception clearing test journal and manuscript: \" + ex);\n        }\n        super.tearDown();\n    }\n\n    /**\n     * Test of objectExists method, of class ManuscriptDatabaseStorageImpl.\n     */\n    @Test\n    public void testObjectExists() throws Exception {\n        log.info(\"objectExists\");\n        StoragePath path = collectionPath;\n        Manuscript manuscript = new Manuscript();\n        manuscript.setManuscriptId(TEST_MANUSCRIPT_ID_1);\n        ManuscriptDatabaseStorageImpl instance = new ManuscriptDatabaseStorageImpl();\n        Boolean expResult = Boolean.TRUE;\n        Boolean result = instance.objectExists(path, manuscript);\n        assertEquals(\"Test manuscript should exist\", expResult, result);\n    }\n\n    /**\n     * Test of addAll method, of class ManuscriptDatabaseStorageImpl.\n     */\n    @Test\n    public void testAddAll() throws Exception {\n        log.info(\"addAll\");\n        StoragePath path = collectionPath;\n        List<Manuscript> manuscripts = new ArrayList<Manuscript>();\n        ManuscriptDatabaseStorageImpl instance = new ManuscriptDatabaseStorageImpl();\n        instance.addAll(path, manuscripts);\n        Integer expectedSize = 1;\n        Integer actualSize = manuscripts.size();\n        assertEquals(\"There should be 1  manuscript\", expectedSize, actualSize);\n    }\n\n    /**\n     * Test of createObject method, of class ManuscriptDatabaseStorageImpl.\n     */\n    @Test\n    public void testCreateObject() throws Exception {\n        log.info(\"createObject\");\n        StoragePath path = manuscriptPath2;\n        ManuscriptDatabaseStorageImpl instance = new ManuscriptDatabaseStorageImpl();\n        Manuscript manuscript = instance.readObject(path);\n        assertNull(\"Object must not exist before creating\", manuscript);\n        manuscript = new Manuscript();\n        manuscript.configureTestValues();\n        manuscript.setManuscriptId(TEST_MANUSCRIPT_ID_2);\n        path = collectionPath;\n        instance.createObject(path, manuscript);\n        Boolean exists = instance.objectExists(path, manuscript);\n        assertTrue(\"Newly saved object should exist\", exists);\n    }\n\n    /**\n     * Test of readObject method, of class ManuscriptDatabaseStorageImpl.\n     */\n    @Test\n    public void testReadObject() throws Exception {\n        log.info(\"readObject\");\n        StoragePath path = manuscriptPath1;\n        ManuscriptDatabaseStorageImpl instance = new ManuscriptDatabaseStorageImpl();\n        String expManuscriptId = TEST_MANUSCRIPT_ID_1;\n        Manuscript result = instance.readObject(path);\n        assertEquals(\"Read object should have same id as original\", expManuscriptId, result.getManuscriptId());\n    }\n\n    /**\n     * Test of deleteObject method, of class ManuscriptDatabaseStorageImpl.\n     */\n    @Test\n    public void testDeleteObject() throws Exception {\n        log.info(\"deleteObject\");\n        StoragePath path = manuscriptPath1;\n        ManuscriptDatabaseStorageImpl instance = new ManuscriptDatabaseStorageImpl();\n        instance.deleteObject(path);\n        Manuscript dummyManuscript = new Manuscript();\n        dummyManuscript.setManuscriptId(TEST_MANUSCRIPT_ID_1);\n        dummyManuscript.setStatus(Manuscript.STATUS_ACCEPTED);\n        Boolean exists = instance.objectExists(path, dummyManuscript);\n        assertFalse(\"Deleted object should not exist\", exists);\n    }\n\n    /**\n     * Test of updateObject method, of class ManuscriptDatabaseStorageImpl.\n     */\n    @Test\n    public void testUpdateObject() throws Exception {\n        log.info(\"updateObject\");\n        StoragePath path = manuscriptPath1;\n        Manuscript manuscript = new Manuscript();\n        manuscript.configureTestValues();\n        manuscript.setManuscriptId(TEST_MANUSCRIPT_ID_1);\n        String updatedTitle = \"Updated Title\";\n        manuscript.setTitle(updatedTitle);\n        ManuscriptDatabaseStorageImpl instance = new ManuscriptDatabaseStorageImpl();\n        instance.updateObject(path, manuscript);\n        manuscript = instance.readObject(path);\n        assertEquals(updatedTitle, manuscript.getTitle());\n\n        // version should change internally!\n        String query = \"SELECT * FROM MANUSCRIPT where msid = ? and active = ?\";\n        TableRow row = DatabaseManager.querySingleTable(context, ManuscriptDatabaseStorageImpl.MANUSCRIPT_TABLE, query, manuscript.getManuscriptId(), ManuscriptDatabaseStorageImpl.ACTIVE_TRUE);\n    }\n}", "class_id": 0, "repo": "daisieh/dryad-repo", "file": "dspace/modules/dryad-rest-webapp/src/test/java/org/datadryad/rest/storage/rdbms/ManuscriptDatabaseStorageImplTest.java", "last_update_at": "2020-02-08T08:49:27+00:00", "question_id": "c63559d3be42f326bb942434a9722814a61aa588", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ManuscriptDatabaseStorageImplTest extends ContextUnitTest {\n    private static Logger log = Logger.getLogger(ManuscriptDatabaseStorageImplTest.class);\n    private static final String TEST_JOURNAL_CODE = \"test\";\n    private static final String TEST_JOURNAL_NAME = \"Test Journal\";\n    private static final String TEST_MANUSCRIPT_ID_1 = \"MS_TEST_12345\";\n    private static final String TEST_MANUSCRIPT_ID_2 = \"MS_TEST_99999\";\n    private StoragePath collectionPath = new StoragePath();\n    private StoragePath manuscriptPath1 = new StoragePath();\n    private StoragePath manuscriptPath2 = new StoragePath();\n    public ManuscriptDatabaseStorageImplTest() {\n        collectionPath = StoragePath.createJournalPath(TEST_JOURNAL_CODE);\n        manuscriptPath1 = StoragePath.createManuscriptPath(TEST_JOURNAL_CODE, TEST_MANUSCRIPT_ID_1);\n        manuscriptPath2 = StoragePath.createManuscriptPath(TEST_JOURNAL_CODE, TEST_MANUSCRIPT_ID_2);\n    }\n    @Before\n    public void setUp() {\n        super.setUp();\n        // Create a journal\n        DryadJournalConcept journal = null;\n        try {\n            DryadJournalConcept journalConcept = new DryadJournalConcept();\n            journalConcept.setFullName(TEST_JOURNAL_NAME);\n            journalConcept.setJournalID(TEST_JOURNAL_CODE);\n            Context context = new Context();\n            JournalUtils.addDryadJournalConcept(context, journalConcept);\n            journal = JournalConceptDatabaseStorageImpl.getJournalConceptByCodeOrISSN(context, TEST_JOURNAL_CODE);\n            context.complete();\n        } catch (Exception ex) {\n            fail(\"Exception setting up test journal: \" + ex);\n        }\n        // Create a manuscript\n        Manuscript manuscript = new Manuscript();\n        manuscript.configureTestValues();\n        manuscript.setManuscriptId(TEST_MANUSCRIPT_ID_1);\n        try {\n            DatabaseManager.deleteByValue(context, ManuscriptDatabaseStorageImpl.MANUSCRIPT_TABLE, ManuscriptDatabaseStorageImpl.COLUMN_MSID, TEST_MANUSCRIPT_ID_1);\n            TableRow manuscriptRow = ManuscriptDatabaseStorageImpl.tableRowFromManuscript(manuscript, journal.getConceptID());\n            manuscriptRow.setColumn(ManuscriptDatabaseStorageImpl.COLUMN_VERSION, 1);\n            manuscriptRow.setColumn(ManuscriptDatabaseStorageImpl.COLUMN_ACTIVE, ManuscriptDatabaseStorageImpl.ACTIVE_TRUE);\n            DatabaseManager.insert(context, manuscriptRow);\n            context.commit();\n        } catch (Exception ex) {\n            fail(\"Exception setting up test manuscript: \" + ex);\n        }\n    }\n    @Override\n    public void tearDown() {\n        try {\n            DatabaseManager.deleteByValue(context, ManuscriptDatabaseStorageImpl.MANUSCRIPT_TABLE, ManuscriptDatabaseStorageImpl.COLUMN_MSID, TEST_MANUSCRIPT_ID_1);\n            DatabaseManager.deleteByValue(context, ManuscriptDatabaseStorageImpl.MANUSCRIPT_TABLE, ManuscriptDatabaseStorageImpl.COLUMN_MSID, TEST_MANUSCRIPT_ID_2);\n        } catch (SQLException ex) {\n            fail(\"Exception clearing test journal and manuscript: \" + ex);\n        }\n        super.tearDown();\n    }\n    /**\n     * Test of objectExists method, of class ManuscriptDatabaseStorageImpl.\n     */\n    @Test\n    public void testObjectExists() throws Exception {\n        log.info(\"objectExists\");\n        StoragePath path = collectionPath;\n        Manuscript manuscript = new Manuscript();\n        manuscript.setManuscriptId(TEST_MANUSCRIPT_ID_1);\n        ManuscriptDatabaseStorageImpl instance = new ManuscriptDatabaseStorageImpl();\n        Boolean expResult = Boolean.TRUE;\n        Boolean result = instance.objectExists(path, manuscript);\n        assertEquals(\"Test manuscript should exist\", expResult, result);\n    }\n    /**\n     * Test of addAll method, of class ManuscriptDatabaseStorageImpl.\n     */\n    @Test\n    public void testAddAll() throws Exception {\n        log.info(\"addAll\");\n        StoragePath path = collectionPath;\n        List<Manuscript> manuscripts = new ArrayList<Manuscript>();\n        ManuscriptDatabaseStorageImpl instance = new ManuscriptDatabaseStorageImpl();\n        instance.addAll(path, manuscripts);\n        Integer expectedSize = 1;\n        Integer actualSize = manuscripts.size();\n        assertEquals(\"There should be 1  manuscript\", expectedSize, actualSize);\n    }\n    /**\n     * Test of createObject method, of class ManuscriptDatabaseStorageImpl.\n     */\n    @Test\n    public void testCreateObject() throws Exception {\n        log.info(\"createObject\");\n        StoragePath path = manuscriptPath2;\n        ManuscriptDatabaseStorageImpl instance = new ManuscriptDatabaseStorageImpl();\n        Manuscript manuscript = instance.readObject(path);\n        assertNull(\"Object must not exist before creating\", manuscript);\n        manuscript = new Manuscript();\n        manuscript.configureTestValues();\n        manuscript.setManuscriptId(TEST_MANUSCRIPT_ID_2);\n        path = collectionPath;\n        instance.createObject(path, manuscript);\n        Boolean exists = instance.objectExists(path, manuscript);\n        assertTrue(\"Newly saved object should exist\", exists);\n    }\n    /**\n     * Test of readObject method, of class ManuscriptDatabaseStorageImpl.\n     */\n    @Test\n    public void testReadObject() throws Exception {\n        log.info(\"readObject\");\n        StoragePath path = manuscriptPath1;\n        ManuscriptDatabaseStorageImpl instance = new ManuscriptDatabaseStorageImpl();\n        String expManuscriptId = TEST_MANUSCRIPT_ID_1;\n        Manuscript result = instance.readObject(path);\n        assertEquals(\"Read object should have same id as original\", expManuscriptId, result.getManuscriptId());\n    }\n    /**\n     * Test of deleteObject method, of class ManuscriptDatabaseStorageImpl.\n     */\n    @Test\n    public void testDeleteObject() throws Exception {\n        log.info(\"deleteObject\");\n        StoragePath path = manuscriptPath1;\n        ManuscriptDatabaseStorageImpl instance = new ManuscriptDatabaseStorageImpl();\n        instance.deleteObject(path);\n        Manuscript dummyManuscript = new Manuscript();\n        dummyManuscript.setManuscriptId(TEST_MANUSCRIPT_ID_1);\n        dummyManuscript.setStatus(Manuscript.STATUS_ACCEPTED);\n        Boolean exists = instance.objectExists(path, dummyManuscript);\n        assertFalse(\"Deleted object should not exist\", exists);\n    }\n    /**\n     * Test of updateObject method, of class ManuscriptDatabaseStorageImpl.\n     */\n    @Test\n    public void testUpdateObject() throws Exception {\n        log.info(\"updateObject\");\n        StoragePath path = manuscriptPath1;\n        Manuscript manuscript = new Manuscript();\n        manuscript.configureTestValues();\n        manuscript.setManuscriptId(TEST_MANUSCRIPT_ID_1);\n        String updatedTitle = \"Updated Title\";\n        manuscript.setTitle(updatedTitle);\n        ManuscriptDatabaseStorageImpl instance = new ManuscriptDatabaseStorageImpl();\n        instance.updateObject(path, manuscript);\n        manuscript = instance.readObject(path);\n        assertEquals(updatedTitle, manuscript.getTitle());\n        // version should change internally!\n        String query = \"SELECT * FROM MANUSCRIPT where msid = ? and active = ?\";\n        TableRow row = DatabaseManager.querySingleTable(context, ManuscriptDatabaseStorageImpl.MANUSCRIPT_TABLE, query, manuscript.getManuscriptId(), ManuscriptDatabaseStorageImpl.ACTIVE_TRUE);\n    }\n"]]}
{"hexsha": "4bf26f31aafe4f78aeb843511bd7f32277f6001a", "ext": "java", "lang": "Java", "content": "public class BinaryMinHeap<T> {\n    private List<Node> allNodes = new ArrayList<>();\n    private Map<T,Integer> nodePosition = new HashMap<>();\n\n    public class Node {\n        int weight;\n        T key;\n    }\n\n    /**\n     * Checks where the key exists in heap or not\n     */\n    public boolean containsData(T key){\n        return nodePosition.containsKey(key);\n    }\n\n    /**\n     * Add key and its weight to they heap\n     */\n    public void add(int weight,T key) {\n        Node node = new Node();\n        node.weight = weight;\n        node.key = key;\n        allNodes.add(node);\n        int size = allNodes.size();\n        int current = size - 1;\n        int parentIndex = (current - 1) / 2;\n        nodePosition.put(node.key, current);\n\n        while (parentIndex >= 0) {\n            Node parentNode = allNodes.get(parentIndex);\n            Node currentNode = allNodes.get(current);\n            if (parentNode.weight > currentNode.weight) {\n                swap(parentNode,currentNode);\n                updatePositionMap(parentNode.key,currentNode.key,parentIndex,current);\n                current = parentIndex;\n                parentIndex = (parentIndex - 1) / 2;\n            } else {\n                break;\n            }\n        }\n    }\n\n    /**\n     * Get the heap min without extracting the key\n     */\n    public T min(){\n        return allNodes.get(0).key;\n    }\n\n    /**\n     * Checks with heap is empty or not\n     */\n    public boolean empty(){\n        return allNodes.size() == 0;\n    }\n\n    /**\n     * Decreases the weight of given key to newWeight\n     */\n    public void decrease(T data, int newWeight){\n        Integer position = nodePosition.get(data);\n        allNodes.get(position).weight = newWeight;\n        int parent = (position -1 )/2;\n        while(parent >= 0){\n            if(allNodes.get(parent).weight > allNodes.get(position).weight){\n                swap(allNodes.get(parent), allNodes.get(position));\n                updatePositionMap(allNodes.get(parent).key,allNodes.get(position).key,parent,position);\n                position = parent;\n                parent = (parent-1)/2;\n            }else{\n                break;\n            }\n        }\n    }\n\n    /**\n     * Get the weight of given key\n     */\n    public Integer getWeight(T key) {\n        Integer position = nodePosition.get(key);\n        if( position == null ) {\n            return null;\n        } else {\n            return allNodes.get(position).weight;\n        }\n    }\n\n    /**\n     * Returns the min node of the heap\n     */\n    public Node extractMinNode() {\n        int size = allNodes.size() -1;\n        Node minNode = new Node();\n        minNode.key = allNodes.get(0).key;\n        minNode.weight = allNodes.get(0).weight;\n\n        int lastNodeWeight = allNodes.get(size).weight;\n        allNodes.get(0).weight = lastNodeWeight;\n        allNodes.get(0).key = allNodes.get(size).key;\n        nodePosition.remove(minNode.key);\n        nodePosition.remove(allNodes.get(0));\n        nodePosition.put(allNodes.get(0).key, 0);\n        allNodes.remove(size);\n\n        int currentIndex = 0;\n        size--;\n        while(true){\n            int left = 2*currentIndex + 1;\n            int right = 2*currentIndex + 2;\n            if(left > size){\n                break;\n            }\n            if(right > size){\n                right = left;\n            }\n            int smallerIndex = allNodes.get(left).weight <= allNodes.get(right).weight ? left : right;\n            if(allNodes.get(currentIndex).weight > allNodes.get(smallerIndex).weight){\n                swap(allNodes.get(currentIndex), allNodes.get(smallerIndex));\n                updatePositionMap(allNodes.get(currentIndex).key,allNodes.get(smallerIndex).key,currentIndex,smallerIndex);\n                currentIndex = smallerIndex;\n            }else{\n                break;\n            }\n        }\n        return minNode;\n    }\n    /**\n     * Extract min value key from the heap\n     */\n    public T extractMin(){\n        Node node = extractMinNode();\n        return node.key;\n    }\n\n    private void printPositionMap(){\n        System.out.println(nodePosition);\n    }\n\n    private void swap(Node node1,Node node2){\n        int weight = node1.weight;\n        T data = node1.key;\n\n        node1.key = node2.key;\n        node1.weight = node2.weight;\n\n        node2.key = data;\n        node2.weight = weight;\n    }\n\n    private void updatePositionMap(T data1, T data2, int pos1, int pos2){\n        nodePosition.remove(data1);\n        nodePosition.remove(data2);\n        nodePosition.put(data1, pos1);\n        nodePosition.put(data2, pos2);\n    }\n\n    public void printHeap(){\n        for(Node n : allNodes){\n            System.out.println(n.weight + \" \" + n.key);\n        }\n    }\n\n    public static void main(String args[]){\n        BinaryMinHeap<String> heap = new BinaryMinHeap<String>();\n        heap.add(3, \"Tushar\");\n        heap.add(4, \"Ani\");\n        heap.add(8, \"Vijay\");\n        heap.add(10, \"Pramila\");\n        heap.add(5, \"Roy\");\n        heap.add(6, \"NTF\");\n        heap.add(2,\"AFR\");\n        heap.decrease(\"Pramila\", 1);\n        heap.printHeap();\n        heap.printPositionMap();\n    }\n}", "class_id": 0, "repo": "Bishwa05/Algorithms", "file": "src/graph/BinaryMinHeap.java", "last_update_at": "2020-02-27T13:44:37+00:00", "question_id": "4bf26f31aafe4f78aeb843511bd7f32277f6001a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BinaryMinHeap<T> {\n    private List<Node> allNodes = new ArrayList<>();\n    private Map<T,Integer> nodePosition = new HashMap<>();\n    public class Node {\n        int weight;\n        T key;\n    }\n    /**\n     * Checks where the key exists in heap or not\n     */\n    public boolean containsData(T key){\n        return nodePosition.containsKey(key);\n    }\n    /**\n     * Add key and its weight to they heap\n     */\n    public void add(int weight,T key) {\n        Node node = new Node();\n        node.weight = weight;\n        node.key = key;\n        allNodes.add(node);\n        int size = allNodes.size();\n        int current = size - 1;\n        int parentIndex = (current - 1) / 2;\n        nodePosition.put(node.key, current);\n        while (parentIndex >= 0) {\n            Node parentNode = allNodes.get(parentIndex);\n            Node currentNode = allNodes.get(current);\n            if (parentNode.weight > currentNode.weight) {\n                swap(parentNode,currentNode);\n                updatePositionMap(parentNode.key,currentNode.key,parentIndex,current);\n                current = parentIndex;\n                parentIndex = (parentIndex - 1) / 2;\n            } else {\n                break;\n            }\n        }\n    }\n    /**\n     * Get the heap min without extracting the key\n     */\n    public T min(){\n        return allNodes.get(0).key;\n    }\n    /**\n     * Checks with heap is empty or not\n     */\n    public boolean empty(){\n        return allNodes.size() == 0;\n    }\n    /**\n     * Decreases the weight of given key to newWeight\n     */\n    public void decrease(T data, int newWeight){\n        Integer position = nodePosition.get(data);\n        allNodes.get(position).weight = newWeight;\n        int parent = (position -1 )/2;\n        while(parent >= 0){\n            if(allNodes.get(parent).weight > allNodes.get(position).weight){\n                swap(allNodes.get(parent), allNodes.get(position));\n                updatePositionMap(allNodes.get(parent).key,allNodes.get(position).key,parent,position);\n                position = parent;\n                parent = (parent-1)/2;\n            }else{\n                break;\n            }\n        }\n    }\n    /**\n     * Get the weight of given key\n     */\n    public Integer getWeight(T key) {\n        Integer position = nodePosition.get(key);\n        if( position == null ) {\n            return null;\n        } else {\n            return allNodes.get(position).weight;\n        }\n    }\n    /**\n     * Returns the min node of the heap\n     */\n    public Node extractMinNode() {\n        int size = allNodes.size() -1;\n        Node minNode = new Node();\n        minNode.key = allNodes.get(0).key;\n        minNode.weight = allNodes.get(0).weight;\n        int lastNodeWeight = allNodes.get(size).weight;\n        allNodes.get(0).weight = lastNodeWeight;\n        allNodes.get(0).key = allNodes.get(size).key;\n        nodePosition.remove(minNode.key);\n        nodePosition.remove(allNodes.get(0));\n        nodePosition.put(allNodes.get(0).key, 0);\n        allNodes.remove(size);\n        int currentIndex = 0;\n        size--;\n        while(true){\n            int left = 2*currentIndex + 1;\n            int right = 2*currentIndex + 2;\n            if(left > size){\n                break;\n            }\n            if(right > size){\n                right = left;\n            }\n            int smallerIndex = allNodes.get(left).weight <= allNodes.get(right).weight ? left : right;\n            if(allNodes.get(currentIndex).weight > allNodes.get(smallerIndex).weight){\n                swap(allNodes.get(currentIndex), allNodes.get(smallerIndex));\n                updatePositionMap(allNodes.get(currentIndex).key,allNodes.get(smallerIndex).key,currentIndex,smallerIndex);\n                currentIndex = smallerIndex;\n            }else{\n                break;\n            }\n        }\n        return minNode;\n    }\n    /**\n     * Extract min value key from the heap\n     */\n    public T extractMin(){\n        Node node = extractMinNode();\n        return node.key;\n    }\n    private void printPositionMap(){\n        System.out.println(nodePosition);\n    }\n    private void swap(Node node1,Node node2){\n        int weight = node1.weight;\n        T data = node1.key;\n        node1.key = node2.key;\n        node1.weight = node2.weight;\n        node2.key = data;\n        node2.weight = weight;\n    }\n    private void updatePositionMap(T data1, T data2, int pos1, int pos2){\n        nodePosition.remove(data1);\n        nodePosition.remove(data2);\n        nodePosition.put(data1, pos1);\n        nodePosition.put(data2, pos2);\n    }\n    public void printHeap(){\n        for(Node n : allNodes){\n            System.out.println(n.weight + \" \" + n.key);\n        }\n    }\n    public static void main(String args[]){\n        BinaryMinHeap<String> heap = new BinaryMinHeap<String>();\n        heap.add(3, \"Tushar\");\n        heap.add(4, \"Ani\");\n        heap.add(8, \"Vijay\");\n        heap.add(10, \"Pramila\");\n        heap.add(5, \"Roy\");\n        heap.add(6, \"NTF\");\n        heap.add(2,\"AFR\");\n        heap.decrease(\"Pramila\", 1);\n        heap.printHeap();\n        heap.printPositionMap();\n    }\n"]]}
{"hexsha": "612b8d4b1754a9a7fe63a33486713d10d2ab1701", "ext": "java", "lang": "Java", "content": "public class CustomProcessor implements ProcedureResultProcessor {\n  private ProcedureProcessorContext context;\n  \n  @Override\n  public void close() {\n    this.context = null;\n  }\n\n  @Override\n  public List<Object> getNextResultRow(int resultSetNumber)\n      throws InterruptedException {\n    if (resultSetNumber == 1) return test(1);\n    else return test(resultSetNumber);\n  }\n\n  @Override\n  public Object[] getOutParameters() throws InterruptedException {\n    // TODO Auto-generated method stub\n    return null;\n  }\n\n  @Override\n  public void init(ProcedureProcessorContext context) {\n    this.context = context;\n  }\n  \n  private List<Object> test(int num) throws InterruptedException{\n    //Log.getLogWriter().info(\"in custom processor\");\n    System.out.println(\"in custom processor\");\n    IncomingResultSet[] inSets = context.getIncomingResultSets(num);\n    //Log.getLogWriter().info(\"custom process result\");\n    if (inSets.length != SQLTest.numOfStores) {\n      throw new TestException(\"does not get results set from all the nodes\");\n    }\n    for (IncomingResultSet inSet : inSets) {\n      \n      List<Object> nextRow = inSet.waitPeekRow();\n      if (nextRow == IncomingResultSet.END_OF_RESULTS) continue;\n      \n      List<Object> takeRow = inSet.takeRow();\n      for (Object o: takeRow) {\n        //Log.getLogWriter().info(o + \",\");\n        System.out.println(o + \",\");\n      }\n      return takeRow;\n    }\n    return null;\n  }\n\n}", "class_id": 0, "repo": "xyxiaoyou/snappy-store", "file": "tests/sql/src/main/java/sql/sqlDAP/CustomProcessor.java", "last_update_at": "2020-04-07T06:35:36+00:00", "question_id": "612b8d4b1754a9a7fe63a33486713d10d2ab1701", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CustomProcessor implements ProcedureResultProcessor {\n  private ProcedureProcessorContext context;\n  @Override\n  public void close() {\n    this.context = null;\n  }\n  @Override\n  public List<Object> getNextResultRow(int resultSetNumber)\n      throws InterruptedException {\n    if (resultSetNumber == 1) return test(1);\n    else return test(resultSetNumber);\n  }\n  @Override\n  public Object[] getOutParameters() throws InterruptedException {\n    // TODO Auto-generated method stub\n    return null;\n  }\n  @Override\n  public void init(ProcedureProcessorContext context) {\n    this.context = context;\n  }\n  private List<Object> test(int num) throws InterruptedException{\n    //Log.getLogWriter().info(\"in custom processor\");\n    System.out.println(\"in custom processor\");\n    IncomingResultSet[] inSets = context.getIncomingResultSets(num);\n    //Log.getLogWriter().info(\"custom process result\");\n    if (inSets.length != SQLTest.numOfStores) {\n      throw new TestException(\"does not get results set from all the nodes\");\n    }\n    for (IncomingResultSet inSet : inSets) {\n      List<Object> nextRow = inSet.waitPeekRow();\n      if (nextRow == IncomingResultSet.END_OF_RESULTS) continue;\n      List<Object> takeRow = inSet.takeRow();\n      for (Object o: takeRow) {\n        //Log.getLogWriter().info(o + \",\");\n        System.out.println(o + \",\");\n      }\n      return takeRow;\n    }\n    return null;\n  }\n"]]}
{"hexsha": "ccc147858c14857014520f932a19b0fb954d531f", "ext": "java", "lang": "Java", "content": "public class BubbleSort extends SortStub {\n\n  @Override\n  public void onDoSort(int[] inputData) {\n    super.onDoSort(inputData);\n\n    int len = inputData != null ? inputData.length : -1;\n    if (len > -1) {\n      for (int i = 0; i < len; i++) {\n        for (int j = len - 1; j > i; j--) {\n          if (inputData[j] < inputData[j - 1]) {\n            _exchange(inputData, j, j - 1);\n          }\n        }\n      }\n    }\n  }\n\n  private void _exchange(int[] array, int sourceIndex, int targetIndex) {\n    int len = array != null ? array.length : -1;\n\n    if (sourceIndex < 0 || targetIndex < 0 || sourceIndex >= len || targetIndex >= len) return;\n\n    int temp = array[targetIndex];\n    array[targetIndex] = array[sourceIndex];\n    array[sourceIndex] = temp;\n  }\n}", "class_id": 0, "repo": "nutshellfool/algorithmShare", "file": "src/main/java/me/lirui/algo/sort/BubbleSort.java", "last_update_at": "2020-06-05T12:44:21+00:00", "question_id": "ccc147858c14857014520f932a19b0fb954d531f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BubbleSort extends SortStub {\n  @Override\n  public void onDoSort(int[] inputData) {\n    super.onDoSort(inputData);\n    int len = inputData != null ? inputData.length : -1;\n    if (len > -1) {\n      for (int i = 0; i < len; i++) {\n        for (int j = len - 1; j > i; j--) {\n          if (inputData[j] < inputData[j - 1]) {\n            _exchange(inputData, j, j - 1);\n          }\n        }\n      }\n    }\n  }\n  private void _exchange(int[] array, int sourceIndex, int targetIndex) {\n    int len = array != null ? array.length : -1;\n    if (sourceIndex < 0 || targetIndex < 0 || sourceIndex >= len || targetIndex >= len) return;\n    int temp = array[targetIndex];\n    array[targetIndex] = array[sourceIndex];\n    array[sourceIndex] = temp;\n  }\n"]]}
{"hexsha": "4f248da82bb29dffe2f3b35145a9a4712f3910e2", "ext": "java", "lang": "Java", "content": "public class TestVeritestingDumpXML {\n\n    void testHarness(DumpXMLEqCheck v, char c0, char c1, char c2, char c3, char c4, char c5, char c6, char c7, char c8) {\n        int outSPF = SPFWrapper(v, c0, c1, c2, c3, c4, c5, c6, c7, c8);\n        int outJR = JRWrapper(v, c0, c1, c2, c3, c4, c5, c6, c7, c8);\n        checkEquality(outSPF, outJR);\n    }\n\n    public void checkEquality(int outSPF, int outJR) {\n        if (outSPF == outJR) System.out.println(\"Match\");\n        else {\n            System.out.println(\"Mismatch\");\n            assert(false);\n        }\n//        assert(outSPF == outJR);\n    }\n\n    public int SPFWrapper(DumpXMLEqCheck v, char c0, char c1, char c2, char c3, char c4, char c5,\n                                        char c6, char c7, char c8) {\n        return NonVeritest(v, c0, c1, c2, c3, c4, c5, c6, c7, c8);\n    }\n\n    // This is a special method. Call this method to prevent SPF from veritesting any regions that appear in any\n    // function or method call higher up in the stack. In the future, this call to SPFWrapperInner can be changed to\n    // be a generic method call if other no-veritesting methods need to be invoked.\n    private int NonVeritest(DumpXMLEqCheck v, char c0, char c1, char c2, char c3, char c4, char c5,\n                                         char c6, char c7, char c8){\n        return SPFWrapperInner(v, c0, c1, c2, c3, c4, c5, c6, c7, c8);\n    }\n\n    private int SPFWrapperInner(DumpXMLEqCheck v, char c0, char c1, char c2, char c3, char c4, char c5,\n                                              char c6, char c7, char c8) {\n        int ret = v.testFunction(c0, c1, c2, c3, c4, c5, c6, c7, c8);\n        return ret;\n    }\n\n    public int JRWrapper(DumpXMLEqCheck v, char c0, char c1, char c2, char c3, char c4, char c5, char c6,\n                                       char c7, char c8) {\n        return v.testFunction(c0, c1, c2, c3, c4, c5, c6, c7, c8);\n    }\n\n    public void runTest(DumpXMLEqCheck t) {\n        testHarness(t, '1', '2', '3', '4', '5', '6', '7', '8', '9');\n    }\n}", "class_id": 0, "repo": "sohah/ContractDR", "file": "src/examples/veritesting/nanoxml/TestVeritestingDumpXML.java", "last_update_at": "2020-02-12T21:34:57+00:00", "question_id": "4f248da82bb29dffe2f3b35145a9a4712f3910e2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestVeritestingDumpXML {\n    void testHarness(DumpXMLEqCheck v, char c0, char c1, char c2, char c3, char c4, char c5, char c6, char c7, char c8) {\n        int outSPF = SPFWrapper(v, c0, c1, c2, c3, c4, c5, c6, c7, c8);\n        int outJR = JRWrapper(v, c0, c1, c2, c3, c4, c5, c6, c7, c8);\n        checkEquality(outSPF, outJR);\n    }\n    public void checkEquality(int outSPF, int outJR) {\n        if (outSPF == outJR) System.out.println(\"Match\");\n        else {\n            System.out.println(\"Mismatch\");\n            assert(false);\n        }\n//        assert(outSPF == outJR);\n    }\n    public int SPFWrapper(DumpXMLEqCheck v, char c0, char c1, char c2, char c3, char c4, char c5,\n                                        char c6, char c7, char c8) {\n        return NonVeritest(v, c0, c1, c2, c3, c4, c5, c6, c7, c8);\n    }\n    // This is a special method. Call this method to prevent SPF from veritesting any regions that appear in any\n    // function or method call higher up in the stack. In the future, this call to SPFWrapperInner can be changed to\n    // be a generic method call if other no-veritesting methods need to be invoked.\n    private int NonVeritest(DumpXMLEqCheck v, char c0, char c1, char c2, char c3, char c4, char c5,\n                                         char c6, char c7, char c8){\n        return SPFWrapperInner(v, c0, c1, c2, c3, c4, c5, c6, c7, c8);\n    }\n    private int SPFWrapperInner(DumpXMLEqCheck v, char c0, char c1, char c2, char c3, char c4, char c5,\n                                              char c6, char c7, char c8) {\n        int ret = v.testFunction(c0, c1, c2, c3, c4, c5, c6, c7, c8);\n        return ret;\n    }\n    public int JRWrapper(DumpXMLEqCheck v, char c0, char c1, char c2, char c3, char c4, char c5, char c6,\n                                       char c7, char c8) {\n        return v.testFunction(c0, c1, c2, c3, c4, c5, c6, c7, c8);\n    }\n    public void runTest(DumpXMLEqCheck t) {\n        testHarness(t, '1', '2', '3', '4', '5', '6', '7', '8', '9');\n    }\n"]]}
{"hexsha": "0445c22da4d333b6ddd4f895492be66d958cd572", "ext": "java", "lang": "Java", "content": "public class ExecutionLayerConfiguration {\n\n  private final Spec spec;\n  private final Optional<String> engineEndpoint;\n  private final Version engineVersion;\n  private final Optional<String> engineJwtSecretFile;\n  private final Optional<String> builderEndpoint;\n\n  private ExecutionLayerConfiguration(\n      final Spec spec,\n      final Optional<String> engineEndpoint,\n      final Version engineVersion,\n      final Optional<String> engineJwtSecretFile,\n      final Optional<String> builderEndpoint) {\n    this.spec = spec;\n    this.engineEndpoint = engineEndpoint;\n    this.engineVersion = engineVersion;\n    this.engineJwtSecretFile = engineJwtSecretFile;\n    this.builderEndpoint = builderEndpoint;\n  }\n\n  public static Builder builder() {\n    return new Builder();\n  }\n\n  public boolean isEnabled() {\n    return spec.isMilestoneSupported(SpecMilestone.BELLATRIX);\n  }\n\n  public Spec getSpec() {\n    return spec;\n  }\n\n  public String getEngineEndpoint() {\n    return engineEndpoint.orElseThrow(\n        () ->\n            new InvalidConfigurationException(\n                \"Invalid configuration. --ee-endpoint parameter is mandatory when Bellatrix milestone is enabled\"));\n  }\n\n  public Optional<String> getEngineJwtSecretFile() {\n    return engineJwtSecretFile;\n  }\n\n  public Version getEngineVersion() {\n    return engineVersion;\n  }\n\n  public Optional<String> getBuilderEndpoint() {\n    return builderEndpoint;\n  }\n\n  public static class Builder {\n    private Spec spec;\n    private Optional<String> engineEndpoint = Optional.empty();\n    private Version engineVersion = Version.DEFAULT_VERSION;\n    private Optional<String> engineJwtSecretFile = Optional.empty();\n    private Optional<String> builderEndpoint = Optional.empty();\n\n    private Builder() {}\n\n    public ExecutionLayerConfiguration build() {\n      validateStubEndpoints();\n      return new ExecutionLayerConfiguration(\n          spec, engineEndpoint, engineVersion, engineJwtSecretFile, builderEndpoint);\n    }\n\n    public Builder engineEndpoint(final String engineEndpoint) {\n      this.engineEndpoint = Optional.ofNullable(engineEndpoint);\n      return this;\n    }\n\n    public Builder engineVersion(final Version version) {\n      this.engineVersion = version;\n      return this;\n    }\n\n    public Builder specProvider(final Spec spec) {\n      this.spec = spec;\n      return this;\n    }\n\n    public Builder engineJwtSecretFile(final String jwtSecretFile) {\n      this.engineJwtSecretFile = Optional.ofNullable(jwtSecretFile).filter(StringUtils::isNotBlank);\n      return this;\n    }\n\n    public Builder builderEndpoint(final String builderEndpoint) {\n      this.builderEndpoint = Optional.ofNullable(builderEndpoint);\n      return this;\n    }\n\n    private void validateStubEndpoints() {\n      final boolean engineIsStub =\n          engineEndpoint.map(endpoint -> endpoint.equals(STUB_ENDPOINT_IDENTIFIER)).orElse(false);\n      final boolean builderIsStub =\n          builderEndpoint.map(endpoint -> endpoint.equals(STUB_ENDPOINT_IDENTIFIER)).orElse(false);\n\n      checkState(\n          engineIsStub == builderIsStub || builderEndpoint.isEmpty(),\n          \"mixed configuration with stubbed and non-stubbed execution layer endpoints is not supported\");\n    }\n  }\n}", "class_id": 0, "repo": "courtneyeh/teku", "file": "services/executionlayer/src/main/java/tech/pegasys/teku/services/executionlayer/ExecutionLayerConfiguration.java", "last_update_at": "2020-10-19T13:21:49+00:00", "question_id": "0445c22da4d333b6ddd4f895492be66d958cd572", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ExecutionLayerConfiguration {\n  private final Spec spec;\n  private final Optional<String> engineEndpoint;\n  private final Version engineVersion;\n  private final Optional<String> engineJwtSecretFile;\n  private final Optional<String> builderEndpoint;\n  private ExecutionLayerConfiguration(\n      final Spec spec,\n      final Optional<String> engineEndpoint,\n      final Version engineVersion,\n      final Optional<String> engineJwtSecretFile,\n      final Optional<String> builderEndpoint) {\n    this.spec = spec;\n    this.engineEndpoint = engineEndpoint;\n    this.engineVersion = engineVersion;\n    this.engineJwtSecretFile = engineJwtSecretFile;\n    this.builderEndpoint = builderEndpoint;\n  }\n  public static Builder builder() {\n    return new Builder();\n  }\n  public boolean isEnabled() {\n    return spec.isMilestoneSupported(SpecMilestone.BELLATRIX);\n  }\n  public Spec getSpec() {\n    return spec;\n  }\n  public String getEngineEndpoint() {\n    return engineEndpoint.orElseThrow(\n        () ->\n            new InvalidConfigurationException(\n                \"Invalid configuration. --ee-endpoint parameter is mandatory when Bellatrix milestone is enabled\"));\n  }\n  public Optional<String> getEngineJwtSecretFile() {\n    return engineJwtSecretFile;\n  }\n  public Version getEngineVersion() {\n    return engineVersion;\n  }\n  public Optional<String> getBuilderEndpoint() {\n    return builderEndpoint;\n  }\n  public static class Builder {\n    private Spec spec;\n    private Optional<String> engineEndpoint = Optional.empty();\n    private Version engineVersion = Version.DEFAULT_VERSION;\n    private Optional<String> engineJwtSecretFile = Optional.empty();\n    private Optional<String> builderEndpoint = Optional.empty();\n    private Builder() {}\n    public ExecutionLayerConfiguration build() {\n      validateStubEndpoints();\n      return new ExecutionLayerConfiguration(\n          spec, engineEndpoint, engineVersion, engineJwtSecretFile, builderEndpoint);\n    }\n    public Builder engineEndpoint(final String engineEndpoint) {\n      this.engineEndpoint = Optional.ofNullable(engineEndpoint);\n      return this;\n    }\n    public Builder engineVersion(final Version version) {\n      this.engineVersion = version;\n      return this;\n    }\n    public Builder specProvider(final Spec spec) {\n      this.spec = spec;\n      return this;\n    }\n    public Builder engineJwtSecretFile(final String jwtSecretFile) {\n      this.engineJwtSecretFile = Optional.ofNullable(jwtSecretFile).filter(StringUtils::isNotBlank);\n      return this;\n    }\n    public Builder builderEndpoint(final String builderEndpoint) {\n      this.builderEndpoint = Optional.ofNullable(builderEndpoint);\n      return this;\n    }\n    private void validateStubEndpoints() {\n      final boolean engineIsStub =\n          engineEndpoint.map(endpoint -> endpoint.equals(STUB_ENDPOINT_IDENTIFIER)).orElse(false);\n      final boolean builderIsStub =\n          builderEndpoint.map(endpoint -> endpoint.equals(STUB_ENDPOINT_IDENTIFIER)).orElse(false);\n      checkState(\n          engineIsStub == builderIsStub || builderEndpoint.isEmpty(),\n          \"mixed configuration with stubbed and non-stubbed execution layer endpoints is not supported\");\n    }\n  }\n"]]}
{"hexsha": "d79faf19151178e5e36d66964728ae9f51a4895c", "ext": "java", "lang": "Java", "content": "public class BaseFrame extends JFrame\n        implements XmlConvertible<BaseFrame>, LocalizedComponent,\n                    Titled, Foregrounded, Backgrounded, Enabled {\n    /**\n     *\n     */\n    private static final long serialVersionUID = -2623088843557577651L;\n    public BaseFrame () throws HeadlessException\n    {\n        super();\n    }\n\n    public BaseFrame (GraphicsConfiguration gc)\n    {\n        super(gc);\n    }\n\n    public BaseFrame (String title) throws HeadlessException\n    {\n        super(title);\n    }\n\n    public BaseFrame (String title, GraphicsConfiguration gc)\n    {\n        super(title, gc);\n    }\n\n    protected XmlProxyConvertible<?> getFrameConverter (final Element elem)\n    {\n        return (null == elem) ? null : BaseFrameReflectiveProxy.BASEFRM;\n    }\n    /*\n     * @see net.community.chest.dom.transform.XmlConvertible#fromXml(org.w3c.dom.Element)\n     */\n    @Override\n    @CoVariantReturn\n    public BaseFrame fromXml (Element elem) throws Exception\n    {\n        final XmlProxyConvertible<?>    proxy=getFrameConverter(elem);\n        @SuppressWarnings(\"unchecked\")\n        final Object                    co=\n            ((XmlProxyConvertible<Object>) proxy).fromXml(this, elem);\n        if (co != this)\n            throw new IllegalStateException(ClassUtil.getExceptionLocation(getClass(), \"fromXml\") + \" mismatched updated instances\");\n\n        return this;\n    }\n\n    public BaseFrame (Element elem) throws Exception\n    {\n        final Object    inst=fromXml(elem);\n        if (inst != this)\n            throw new IllegalStateException(ClassUtil.getConstructorExceptionLocation(getClass()) + \"[\" + Window.class.getSimpleName() + \"] mismatched instances\");\n    }\n    /*\n     * @see net.community.chest.dom.transform.XmlConvertible#toXml(org.w3c.dom.Document)\n     */\n    @Override\n    public Element toXml (Document doc) throws Exception\n    {\n        // TODO implement toXml\n        throw new UnsupportedOperationException(ClassUtil.getExceptionLocation(getClass(), \"toXml\") + \" N/A\");\n    }\n\n    private Locale    _lcl    /* =null */;\n    /*\n     * @see net.community.chest.ui.helpers.LocalizedComponent#getDisplayLocale()\n     */\n    @Override\n    public synchronized Locale getDisplayLocale ()\n    {\n        if (null == _lcl)\n            _lcl = Locale.getDefault();\n        return _lcl;\n    }\n    /*\n     * @see net.community.chest.ui.helpers.LocalizedComponent#setDisplayLocale(java.util.Locale)\n     */\n    @Override\n    public synchronized void setDisplayLocale (Locale l)\n    {\n        if (_lcl != l)    // debug breakpoint\n            _lcl = l;\n    }\n\n    public <C extends Component> C addConstrainedComponent (C comp, Node constValue)\n    {\n        return ContainerReflectiveProxy.addConstrainedComponent(this, comp, constValue);\n    }\n\n    public FocusTraversalPolicy setFocusTraversalPolicy (List<Component> comps)\n    {\n        if ((null == comps) || (comps.size() <= 0))\n            return getFocusTraversalPolicy();\n\n        final ByComponentFocusTraversalPolicy    p=new ByComponentFocusTraversalPolicy(comps);\n        setFocusTraversalPolicy(p);\n        return p;\n    }\n\n    public FocusTraversalPolicy setFocusTraversalPolicy (Component ... comps)\n    {\n        return setFocusTraversalPolicy(((null == comps) || (comps.length <= 0)) ? null : Arrays.asList(comps));\n    }\n\n    public FocusTraversalPolicy setFocusTraversalPolicy (String ... comps)\n    {\n        if ((null == comps) || (comps.length <= 0))\n            return getFocusTraversalPolicy();\n\n        final ByNameFocusTraversalPolicy    p=new ByNameFocusTraversalPolicy(comps);\n        setFocusTraversalPolicy(p);\n        return p;\n    }\n}", "class_id": 0, "repo": "lgoldstein/communitychest", "file": "chest/gui/swing/src/main/java/net/community/chest/swing/component/frame/BaseFrame.java", "last_update_at": "2020-08-12T07:40:11+00:00", "question_id": "d79faf19151178e5e36d66964728ae9f51a4895c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BaseFrame extends JFrame\n        implements XmlConvertible<BaseFrame>, LocalizedComponent,\n                    Titled, Foregrounded, Backgrounded, Enabled {\n    /**\n     *\n     */\n    private static final long serialVersionUID = -2623088843557577651L;\n    public BaseFrame () throws HeadlessException\n    {\n        super();\n    }\n    public BaseFrame (GraphicsConfiguration gc)\n    {\n        super(gc);\n    }\n    public BaseFrame (String title) throws HeadlessException\n    {\n        super(title);\n    }\n    public BaseFrame (String title, GraphicsConfiguration gc)\n    {\n        super(title, gc);\n    }\n    protected XmlProxyConvertible<?> getFrameConverter (final Element elem)\n    {\n        return (null == elem) ? null : BaseFrameReflectiveProxy.BASEFRM;\n    }\n    /*\n     * @see net.community.chest.dom.transform.XmlConvertible#fromXml(org.w3c.dom.Element)\n     */\n    @Override\n    @CoVariantReturn\n    public BaseFrame fromXml (Element elem) throws Exception\n    {\n        final XmlProxyConvertible<?>    proxy=getFrameConverter(elem);\n        @SuppressWarnings(\"unchecked\")\n        final Object                    co=\n            ((XmlProxyConvertible<Object>) proxy).fromXml(this, elem);\n        if (co != this)\n            throw new IllegalStateException(ClassUtil.getExceptionLocation(getClass(), \"fromXml\") + \" mismatched updated instances\");\n        return this;\n    }\n    public BaseFrame (Element elem) throws Exception\n    {\n        final Object    inst=fromXml(elem);\n        if (inst != this)\n            throw new IllegalStateException(ClassUtil.getConstructorExceptionLocation(getClass()) + \"[\" + Window.class.getSimpleName() + \"] mismatched instances\");\n    }\n    /*\n     * @see net.community.chest.dom.transform.XmlConvertible#toXml(org.w3c.dom.Document)\n     */\n    @Override\n    public Element toXml (Document doc) throws Exception\n    {\n        // TODO implement toXml\n        throw new UnsupportedOperationException(ClassUtil.getExceptionLocation(getClass(), \"toXml\") + \" N/A\");\n    }\n    private Locale    _lcl    /* =null */;\n    /*\n     * @see net.community.chest.ui.helpers.LocalizedComponent#getDisplayLocale()\n     */\n    @Override\n    public synchronized Locale getDisplayLocale ()\n    {\n        if (null == _lcl)\n            _lcl = Locale.getDefault();\n        return _lcl;\n    }\n    /*\n     * @see net.community.chest.ui.helpers.LocalizedComponent#setDisplayLocale(java.util.Locale)\n     */\n    @Override\n    public synchronized void setDisplayLocale (Locale l)\n    {\n        if (_lcl != l)    // debug breakpoint\n            _lcl = l;\n    }\n    public <C extends Component> C addConstrainedComponent (C comp, Node constValue)\n    {\n        return ContainerReflectiveProxy.addConstrainedComponent(this, comp, constValue);\n    }\n    public FocusTraversalPolicy setFocusTraversalPolicy (List<Component> comps)\n    {\n        if ((null == comps) || (comps.size() <= 0))\n            return getFocusTraversalPolicy();\n        final ByComponentFocusTraversalPolicy    p=new ByComponentFocusTraversalPolicy(comps);\n        setFocusTraversalPolicy(p);\n        return p;\n    }\n    public FocusTraversalPolicy setFocusTraversalPolicy (Component ... comps)\n    {\n        return setFocusTraversalPolicy(((null == comps) || (comps.length <= 0)) ? null : Arrays.asList(comps));\n    }\n    public FocusTraversalPolicy setFocusTraversalPolicy (String ... comps)\n    {\n        if ((null == comps) || (comps.length <= 0))\n            return getFocusTraversalPolicy();\n        final ByNameFocusTraversalPolicy    p=new ByNameFocusTraversalPolicy(comps);\n        setFocusTraversalPolicy(p);\n        return p;\n    }\n"]]}
{"hexsha": "fc23781727c40a92464bbeb45243c7bcfc8fbac7", "ext": "java", "lang": "Java", "content": "@Service\npublic class SignUpServiceImpl implements SignUpService {\n\t\n\tprivate SignUpClient signUpClient;\n\tprivate String headerPrefix;\n\tprivate TextEncryptor textEncryptor;\n\n\t@Override\n\tpublic void signUp(TopicUser user) {\n\t\tString token = null;\n\t\tString encryptedPassword = textEncryptor.encrypt(user.getPassword());\n\t\tuser.setPassword(encryptedPassword);\n\t\tResponseEntity<Object> entity = signUpClient.signUp(user);\n\t\tif(entity.getStatusCode() == CREATED){\n\t\t\tString username = user.getUsername();\n\t\t\ttoken = entity.getHeaders().getFirst(headerPrefix);\n\t\t\tTopicWebUtils.bindUserSession(username, token);\n\t\t}\n\t}\n\t\n\t@Autowired\n\tpublic void setSignUpClient(SignUpClient signUpClient) {\n\t\tthis.signUpClient = signUpClient;\n\t}\n\t\n\t@Autowired\n\tpublic void setTextEncryptor(TextEncryptor textEncryptor) {\n\t\tthis.textEncryptor = textEncryptor;\n\t}\n\n\t@Value(Constants.HEADER_STRING)\n\tpublic void setHeaderPrefix(String headerPrefix) {\n\t\tthis.headerPrefix = headerPrefix;\n\t}\n\t\n\t\n\n}", "class_id": 0, "repo": "rajasushanth/topic-web", "file": "src/main/java/com/starkinc/wtopic/serviceImpl/SignUpServiceImpl.java", "last_update_at": "2020-04-29T23:08:17+00:00", "question_id": "fc23781727c40a92464bbeb45243c7bcfc8fbac7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\npublic class SignUpServiceImpl implements SignUpService {\n\t\n\tprivate SignUpClient signUpClient;\n\tprivate String headerPrefix;\n\tprivate TextEncryptor textEncryptor;\n\t@Override\n\tpublic void signUp(TopicUser user) {\n\t\tString token = null;\n\t\tString encryptedPassword = textEncryptor.encrypt(user.getPassword());\n\t\tuser.setPassword(encryptedPassword);\n\t\tResponseEntity<Object> entity = signUpClient.signUp(user);\n\t\tif(entity.getStatusCode() == CREATED){\n\t\t\tString username = user.getUsername();\n\t\t\ttoken = entity.getHeaders().getFirst(headerPrefix);\n\t\t\tTopicWebUtils.bindUserSession(username, token);\n\t\t}\n\t}\n\t\n\t@Autowired\n\tpublic void setSignUpClient(SignUpClient signUpClient) {\n\t\tthis.signUpClient = signUpClient;\n\t}\n\t\n\t@Autowired\n\tpublic void setTextEncryptor(TextEncryptor textEncryptor) {\n\t\tthis.textEncryptor = textEncryptor;\n\t}\n\t@Value(Constants.HEADER_STRING)\n\tpublic void setHeaderPrefix(String headerPrefix) {\n\t\tthis.headerPrefix = headerPrefix;\n\t}\n\t\n\t\n"]]}
{"hexsha": "3322c7ca293d1884e176aaafe5ce71a642c17d17", "ext": "java", "lang": "Java", "content": "public class EqualTest {\n\t\n\tprivate Equal equal; \n\t\n\t@Before\n\tpublic void init() {\n\t\tequal = new Equal(TestUtils.createElementsExtract());\n\t}\n\t\n\t@Test\n\tpublic void testInvalidWhere() {\n\t\tboolean valid = equal.isValid(\"\");\n\t\tassertFalse(valid);\n\t}\n\t\n\t@Test\n\tpublic void testValidWhere() {\n\t\tboolean valid = equal.isValid(\"test.test=1\");\n\t\tassertTrue(valid);\n\t}\n\t\n\t@Test\n\tpublic void testValidPredicateNumeric() {\n\t\tPredicate<String> predicate = equal.generate(\"test.test=1\");\n\t\tassertNotNull(predicate);\n\t\t\n\t\tList<String> objects = Arrays.asList(new String[]{\"test.test=1\",\"testsss.test=1\",\"testa=1\", \"test[1].test=1\"});\n\t\t\n\t\tList<String> filteredObjects = objects.stream().filter(predicate).collect(Collectors.toList());\n\t\n\t\tassertEquals(2, filteredObjects.size());\n\t}\n\t\n\t@Test\n\tpublic void testValidPredicateString() {\n\t\tPredicate<String> predicate = equal.generate(\"test.test='1'\");\n\t\tassertNotNull(predicate);\n\t\t\n\t\tList<String> objects = Arrays.asList(new String[]{\"test.test=1\",\"testsss.test=1\",\"testa=1\", \"test[1].test=1\"});\n\t\t\n\t\tList<String> filteredObjects = objects.stream().filter(predicate).collect(Collectors.toList());\n\t\n\t\tassertEquals(2, filteredObjects.size());\n\t}\n\t\n\t@Test\n\tpublic void testValidPredicateField() {\n\t\tPredicate<String> predicate = equal.generate(\"test.test=test.test\");\n\t\tassertNotNull(predicate);\n\t\t\n\t\tList<String> objects = Arrays.asList(new String[]{\"test.test=1\",\"testsss.test=1\",\"testa=1\", \"test[1].test=1\"});\n\t\t\n\t\tList<String> filteredObjects = objects.stream().filter(predicate).collect(Collectors.toList());\n\t\n\t\tassertEquals(2, filteredObjects.size());\n\t}\n}", "class_id": 0, "repo": "villanianalytics/unSQL", "file": "src/test/java/com/github/villanianalytics/unsql/condition/impl/EqualTest.java", "last_update_at": "2020-03-25T14:24:47+00:00", "question_id": "3322c7ca293d1884e176aaafe5ce71a642c17d17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EqualTest {\n\t\n\tprivate Equal equal; \n\t\n\t@Before\n\tpublic void init() {\n\t\tequal = new Equal(TestUtils.createElementsExtract());\n\t}\n\t\n\t@Test\n\tpublic void testInvalidWhere() {\n\t\tboolean valid = equal.isValid(\"\");\n\t\tassertFalse(valid);\n\t}\n\t\n\t@Test\n\tpublic void testValidWhere() {\n\t\tboolean valid = equal.isValid(\"test.test=1\");\n\t\tassertTrue(valid);\n\t}\n\t\n\t@Test\n\tpublic void testValidPredicateNumeric() {\n\t\tPredicate<String> predicate = equal.generate(\"test.test=1\");\n\t\tassertNotNull(predicate);\n\t\t\n\t\tList<String> objects = Arrays.asList(new String[]{\"test.test=1\",\"testsss.test=1\",\"testa=1\", \"test[1].test=1\"});\n\t\t\n\t\tList<String> filteredObjects = objects.stream().filter(predicate).collect(Collectors.toList());\n\t\n\t\tassertEquals(2, filteredObjects.size());\n\t}\n\t\n\t@Test\n\tpublic void testValidPredicateString() {\n\t\tPredicate<String> predicate = equal.generate(\"test.test='1'\");\n\t\tassertNotNull(predicate);\n\t\t\n\t\tList<String> objects = Arrays.asList(new String[]{\"test.test=1\",\"testsss.test=1\",\"testa=1\", \"test[1].test=1\"});\n\t\t\n\t\tList<String> filteredObjects = objects.stream().filter(predicate).collect(Collectors.toList());\n\t\n\t\tassertEquals(2, filteredObjects.size());\n\t}\n\t\n\t@Test\n\tpublic void testValidPredicateField() {\n\t\tPredicate<String> predicate = equal.generate(\"test.test=test.test\");\n\t\tassertNotNull(predicate);\n\t\t\n\t\tList<String> objects = Arrays.asList(new String[]{\"test.test=1\",\"testsss.test=1\",\"testa=1\", \"test[1].test=1\"});\n\t\t\n\t\tList<String> filteredObjects = objects.stream().filter(predicate).collect(Collectors.toList());\n\t\n\t\tassertEquals(2, filteredObjects.size());\n\t}\n"]]}
{"hexsha": "0d08bfd1af738f36d4c952a17268e0a01c77e0a3", "ext": "java", "lang": "Java", "content": "public final class ConfigurationInfo {\n    private final Map<String, String> settings;\n    private final String name;\n    private final String label;\n    private final String description;\n    private final String provider;\n    private final String contents;\n\n    ConfigurationInfo(Configuration config) {\n        this.settings = config.getSettings();\n        this.name = config.getName();\n        this.label = config.getLabel();\n        this.description = config.getDescription();\n        this.provider = config.getProvider();\n        this.contents = config.getContents();\n    }\n\n    private ConfigurationInfo(CompositeData cd) {\n        this.settings = createMap(cd.get(\"settings\"));\n        this.name = (String) cd.get(\"name\");\n        this.label = (String) cd.get(\"label\");\n        this.description = (String) cd.get(\"description\");\n        this.provider = (String) cd.get(\"provider\");\n        this.contents = (String) cd.get(\"contents\");\n    }\n\n    private static Map<String, String> createMap(Object o) {\n        if (o instanceof TabularData) {\n            TabularData td = (TabularData) o;\n            Collection<?> values = td.values();\n            Map<String, String> map = new HashMap<>(values.size());\n            for (Object value : td.values()) {\n                if (value instanceof CompositeData) {\n                    CompositeData cdRow = (CompositeData) value;\n                    Object k = cdRow.get(\"key\");\n                    Object v = cdRow.get(\"value\");\n                    if (k instanceof String && v instanceof String) {\n                        map.put((String) k, (String) v);\n                    }\n                }\n            }\n            return Collections.unmodifiableMap(map);\n        }\n        return Collections.emptyMap();\n    }\n\n    /**\n     * Returns the provider of the configuration associated with this\n     * {@code ConfigurationInfo} (for example, {@code \"OpenJDK\"}).\n     *\n     * @return the provider, or {@code null} if doesn't exist\n     *\n     * @see Configuration#getProvider()\n     */\n    public String getProvider() {\n        return provider;\n    }\n\n    /**\n     * Returns the textual representation of the configuration associated with\n     * this {@code ConfigurationInfo}, typically the contents of the\n     * configuration file that was used to create the configuration.\n     *\n     * @return contents, or {@code null} if doesn't exist\n     *\n     * @see Configuration#getContents()\n     */\n    public String getContents() {\n        return contents;\n    }\n\n    /**\n     * Returns the settings for the configuration associated with this\n     * {@code ConfigurationInfo}.\n     *\n     * @return a {@code Map} with settings, not {@code null}\n     *\n     * @see Configuration#getSettings()\n     */\n    public Map<String, String> getSettings() {\n        return settings;\n    }\n\n    /**\n     * Returns the human-readable name (for example, {@code \"Continuous\"} or {@code \"Profiling\"}) for\n     * the configuration associated with this {@code ConfigurationInfo}\n     *\n     * @return the label, or {@code null} if doesn't exist\n     *\n     * @see Configuration#getLabel()\n     */\n    public String getLabel() {\n        return label;\n    }\n\n    /**\n     * Returns the name of the configuration associated with this\n     * {@code ConfigurationInfo} (for example, {@code \"default\"}).\n     *\n     * @return the name, or {@code null} if doesn't exist\n     *\n     * @see Configuration#getLabel()\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns a short sentence that describes the configuration associated with\n     * this {@code ConfigurationInfo} (for example, {@code \"Low\n     * overhead configuration safe for continuous use in production\n     * environments\"}.\n     *\n     * @return the description, or {@code null} if doesn't exist\n     */\n    public String getDescription() {\n        return description;\n    }\n\n    /**\n     * Returns a {@code ConfigurationInfo} object represented by the specified\n     * {@code CompositeData}.\n     * <p>\n     * The following table shows the required attributes that the specified {@code CompositeData} must contain.\n     * <blockquote>\n     * <table class=\"striped\">\n     * <caption>Required names and types for CompositeData</caption>\n     * <thead>\n     * <tr>\n     * <th scope=\"col\" style=\"text-align:left\">Name</th>\n     * <th scope=\"col\" style=\"text-align:left\">Type</th>\n     * </tr>\n     * </thead>\n     * <tbody>\n     * <tr>\n     * <th scope=\"row\">name</th>\n     * <td>{@code String}</td>\n     * </tr>\n     * <tr>\n     * <th scope=\"row\">label</th>\n     * <td>{@code String}</td>\n     * </tr>\n     * <tr>\n     * <th scope=\"row\">description</th>\n     * <td>{@code String}</td>\n     * </tr>\n     * <tr>\n     * <th scope=\"row\">provider</th>\n     * <td>{@code String}</td>\n     * </tr>\n     * <tr>\n     * <th scope=\"row\">contents</th>\n     * <td>{@code String}</td>\n     * </tr>\n     *\n     * <tr>\n     * <th scope=\"row\">settings</th>\n     * <td>{@code javax.management.openmbean.TabularData} with a\n     * {@code TabularType} with the keys {@code \"key\"} and {@code \"value\"}, both\n     * of the {@code String} type</td>\n     * </tr>\n     * </tbody>\n     * </table>\n     * </blockquote>\n     *\n     * @param cd {@code CompositeData} representing a {@code ConfigurationInfo}\n     *\n     * @throws IllegalArgumentException if {@code cd} does not represent a\n     *         {@code ConfigurationInfo} with the required attributes\n     *\n     * @return a {@code ConfigurationInfo} object represented by {@code cd} if\n     *         {@code cd} is not {@code null}, {@code null} otherwise\n     */\n    public static ConfigurationInfo from(CompositeData cd) {\n        if (cd == null) {\n            return null;\n        }\n        return new ConfigurationInfo(cd);\n    }\n\n    /**\n     * Returns a description of the configuration that is associated with this\n     * {@code ConfigurationInfo}.\n     *\n     * @return the description of the configuration, not {@code null}\n     */\n    @Override\n    public String toString() {\n        Stringifier s = new Stringifier();\n        s.add(\"name\", name);\n        s.add(\"label\", label);\n        s.add(\"description\", description);\n        s.add(\"provider\", provider);\n        return s.toString();\n    }\n}", "class_id": 0, "repo": "vitahlin/kennen", "file": "javar/jdk8-analysis/src/jdk/management/jfr/ConfigurationInfo.java", "last_update_at": "2020-07-21T01:20:56+00:00", "question_id": "0d08bfd1af738f36d4c952a17268e0a01c77e0a3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class ConfigurationInfo {\n    private final Map<String, String> settings;\n    private final String name;\n    private final String label;\n    private final String description;\n    private final String provider;\n    private final String contents;\n    ConfigurationInfo(Configuration config) {\n        this.settings = config.getSettings();\n        this.name = config.getName();\n        this.label = config.getLabel();\n        this.description = config.getDescription();\n        this.provider = config.getProvider();\n        this.contents = config.getContents();\n    }\n    private ConfigurationInfo(CompositeData cd) {\n        this.settings = createMap(cd.get(\"settings\"));\n        this.name = (String) cd.get(\"name\");\n        this.label = (String) cd.get(\"label\");\n        this.description = (String) cd.get(\"description\");\n        this.provider = (String) cd.get(\"provider\");\n        this.contents = (String) cd.get(\"contents\");\n    }\n    private static Map<String, String> createMap(Object o) {\n        if (o instanceof TabularData) {\n            TabularData td = (TabularData) o;\n            Collection<?> values = td.values();\n            Map<String, String> map = new HashMap<>(values.size());\n            for (Object value : td.values()) {\n                if (value instanceof CompositeData) {\n                    CompositeData cdRow = (CompositeData) value;\n                    Object k = cdRow.get(\"key\");\n                    Object v = cdRow.get(\"value\");\n                    if (k instanceof String && v instanceof String) {\n                        map.put((String) k, (String) v);\n                    }\n                }\n            }\n            return Collections.unmodifiableMap(map);\n        }\n        return Collections.emptyMap();\n    }\n    /**\n     * Returns the provider of the configuration associated with this\n     * {@code ConfigurationInfo} (for example, {@code \"OpenJDK\"}).\n     *\n     * @return the provider, or {@code null} if doesn't exist\n     *\n     * @see Configuration#getProvider()\n     */\n    public String getProvider() {\n        return provider;\n    }\n    /**\n     * Returns the textual representation of the configuration associated with\n     * this {@code ConfigurationInfo}, typically the contents of the\n     * configuration file that was used to create the configuration.\n     *\n     * @return contents, or {@code null} if doesn't exist\n     *\n     * @see Configuration#getContents()\n     */\n    public String getContents() {\n        return contents;\n    }\n    /**\n     * Returns the settings for the configuration associated with this\n     * {@code ConfigurationInfo}.\n     *\n     * @return a {@code Map} with settings, not {@code null}\n     *\n     * @see Configuration#getSettings()\n     */\n    public Map<String, String> getSettings() {\n        return settings;\n    }\n    /**\n     * Returns the human-readable name (for example, {@code \"Continuous\"} or {@code \"Profiling\"}) for\n     * the configuration associated with this {@code ConfigurationInfo}\n     *\n     * @return the label, or {@code null} if doesn't exist\n     *\n     * @see Configuration#getLabel()\n     */\n    public String getLabel() {\n        return label;\n    }\n    /**\n     * Returns the name of the configuration associated with this\n     * {@code ConfigurationInfo} (for example, {@code \"default\"}).\n     *\n     * @return the name, or {@code null} if doesn't exist\n     *\n     * @see Configuration#getLabel()\n     */\n    public String getName() {\n        return name;\n    }\n    /**\n     * Returns a short sentence that describes the configuration associated with\n     * this {@code ConfigurationInfo} (for example, {@code \"Low\n     * overhead configuration safe for continuous use in production\n     * environments\"}.\n     *\n     * @return the description, or {@code null} if doesn't exist\n     */\n    public String getDescription() {\n        return description;\n    }\n    /**\n     * Returns a {@code ConfigurationInfo} object represented by the specified\n     * {@code CompositeData}.\n     * <p>\n     * The following table shows the required attributes that the specified {@code CompositeData} must contain.\n     * <blockquote>\n     * <table class=\"striped\">\n     * <caption>Required names and types for CompositeData</caption>\n     * <thead>\n     * <tr>\n     * <th scope=\"col\" style=\"text-align:left\">Name</th>\n     * <th scope=\"col\" style=\"text-align:left\">Type</th>\n     * </tr>\n     * </thead>\n     * <tbody>\n     * <tr>\n     * <th scope=\"row\">name</th>\n     * <td>{@code String}</td>\n     * </tr>\n     * <tr>\n     * <th scope=\"row\">label</th>\n     * <td>{@code String}</td>\n     * </tr>\n     * <tr>\n     * <th scope=\"row\">description</th>\n     * <td>{@code String}</td>\n     * </tr>\n     * <tr>\n     * <th scope=\"row\">provider</th>\n     * <td>{@code String}</td>\n     * </tr>\n     * <tr>\n     * <th scope=\"row\">contents</th>\n     * <td>{@code String}</td>\n     * </tr>\n     *\n     * <tr>\n     * <th scope=\"row\">settings</th>\n     * <td>{@code javax.management.openmbean.TabularData} with a\n     * {@code TabularType} with the keys {@code \"key\"} and {@code \"value\"}, both\n     * of the {@code String} type</td>\n     * </tr>\n     * </tbody>\n     * </table>\n     * </blockquote>\n     *\n     * @param cd {@code CompositeData} representing a {@code ConfigurationInfo}\n     *\n     * @throws IllegalArgumentException if {@code cd} does not represent a\n     *         {@code ConfigurationInfo} with the required attributes\n     *\n     * @return a {@code ConfigurationInfo} object represented by {@code cd} if\n     *         {@code cd} is not {@code null}, {@code null} otherwise\n     */\n    public static ConfigurationInfo from(CompositeData cd) {\n        if (cd == null) {\n            return null;\n        }\n        return new ConfigurationInfo(cd);\n    }\n    /**\n     * Returns a description of the configuration that is associated with this\n     * {@code ConfigurationInfo}.\n     *\n     * @return the description of the configuration, not {@code null}\n     */\n    @Override\n    public String toString() {\n        Stringifier s = new Stringifier();\n        s.add(\"name\", name);\n        s.add(\"label\", label);\n        s.add(\"description\", description);\n        s.add(\"provider\", provider);\n        return s.toString();\n    }\n"]]}
{"hexsha": "25b63ad81351c7672f3627e300e0de5dd5a12f22", "ext": "java", "lang": "Java", "content": "public class RlpEncodeUtilTest {\n\n  private final PublicKey recipient1 =\n      PublicKey.from(Base64.getDecoder().decode(\"arhIcNa+MuYXZabmzJD5B33F3dZgqb0hEbM3FZsylSg=\"));\n  private final PublicKey recipient2 =\n      PublicKey.from(Base64.getDecoder().decode(\"B687sgdtqsem2qEXO8h8UqvW1Mb3yKo7id5hPFLwCmY=\"));\n  private final PublicKey recipient3 =\n      PublicKey.from(Base64.getDecoder().decode(\"HEkOUBXbgGCQ5+WDFUAhucXm/n5zUrfGkgdJY/5lfCs=\"));\n\n  @Test\n  public void bouncyCastleHexDecodeDoesSameAsTuweniFromHexString() {\n    byte[] tuweniVal =\n        Bytes.fromHexString(\"5375ba871e5c3d0f1d055b5da0ac02ea035bed38\").toArrayUnsafe();\n\n    byte[] myval = Hex.decode(\"5375ba871e5c3d0f1d055b5da0ac02ea035bed38\");\n\n    assertThat(tuweniVal).isEqualTo(myval);\n    assertThat(Arrays.equals(tuweniVal, myval)).isTrue();\n  }\n\n  @Test\n  public void encoodeListDoesSameAsTuweni() {\n\n    final List<PublicKey> members = List.of(recipient1, recipient2, recipient3);\n\n    List<byte[]> sortedKeys =\n        members.stream()\n            .distinct()\n            .map(PublicKey::getKeyBytes)\n            .sorted(Comparator.comparing(Arrays::hashCode))\n            .collect(Collectors.toList());\n\n    final byte[] rlpEncoded =\n        RLP.encodeList(listWriter -> sortedKeys.forEach(listWriter::writeByteArray)).toArray();\n\n    assertThat(rlpEncoded).isEqualTo(RlpEncodeUtil.encodeList(sortedKeys));\n  }\n\n  @Test\n  public void encoodeListDoesSameAsTuweni55Length() {\n\n    final byte[] data = new byte[54];\n    Arrays.fill(data, (byte) 1);\n\n    final List<PublicKey> members = List.of(PublicKey.from(data));\n\n    List<byte[]> sortedKeys =\n        members.stream()\n            .distinct()\n            .map(PublicKey::getKeyBytes)\n            .sorted(Comparator.comparing(Arrays::hashCode))\n            .collect(Collectors.toList());\n\n    final byte[] rlpEncoded =\n        RLP.encodeList(listWriter -> sortedKeys.forEach(listWriter::writeByteArray)).toArray();\n\n    assertThat(rlpEncoded).isEqualTo(RlpEncodeUtil.encodeList(sortedKeys));\n  }\n\n  @Test\n  public void encodeRLPElementNull() {\n    byte[] result = RlpEncodeUtil.encodeRLPElement(null);\n    assertThat(result).isEqualTo(new byte[] {(byte) 0x80});\n  }\n\n  @Test\n  public void encodeRLPElementEmpty() {\n    byte[] result = RlpEncodeUtil.encodeRLPElement(new byte[0]);\n    assertThat(result).isEqualTo(new byte[] {(byte) 0x80});\n  }\n\n  @Test\n  public void encodeRLPElementLength55OrUnder() {\n    final byte[] data = new byte[54];\n    Arrays.fill(data, (byte) 1);\n    byte[] result = RlpEncodeUtil.encodeRLPElement(data);\n    assertThat(result)\n        .isEqualTo(\n            new byte[] {\n              -74, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n              1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n            });\n  }\n\n  @Test\n  public void encodeRLPElementLengthGreaterThan55() {\n    final byte[] data = new byte[300];\n    Arrays.fill(data, (byte) 1);\n\n    final byte[] result = RlpEncodeUtil.encodeRLPElement(data);\n\n    final byte[] expected = new byte[303];\n    expected[0] = -71;\n    expected[1] = 44;\n    Arrays.fill(expected, 2, 303, (byte) 1);\n\n    assertThat(result.length).isEqualTo(expected.length);\n    assertThat(result).isEqualTo(expected);\n  }\n\n  @Test\n  public void encodeRLPElementLengthOnlyOne() {\n    final byte[] data = new byte[] {9};\n    byte[] result = RlpEncodeUtil.encodeRLPElement(data);\n    assertThat(result).isEqualTo(new byte[] {9});\n  }\n}", "class_id": 0, "repo": "AskRajeshRaccha/tessera", "file": "enclave/enclave-api/src/test/java/com/quorum/tessera/enclave/internal/RlpEncodeUtilTest.java", "last_update_at": "2020-08-18T19:39:41+00:00", "question_id": "25b63ad81351c7672f3627e300e0de5dd5a12f22", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RlpEncodeUtilTest {\n  private final PublicKey recipient1 =\n      PublicKey.from(Base64.getDecoder().decode(\"arhIcNa+MuYXZabmzJD5B33F3dZgqb0hEbM3FZsylSg=\"));\n  private final PublicKey recipient2 =\n      PublicKey.from(Base64.getDecoder().decode(\"B687sgdtqsem2qEXO8h8UqvW1Mb3yKo7id5hPFLwCmY=\"));\n  private final PublicKey recipient3 =\n      PublicKey.from(Base64.getDecoder().decode(\"HEkOUBXbgGCQ5+WDFUAhucXm/n5zUrfGkgdJY/5lfCs=\"));\n  @Test\n  public void bouncyCastleHexDecodeDoesSameAsTuweniFromHexString() {\n    byte[] tuweniVal =\n        Bytes.fromHexString(\"5375ba871e5c3d0f1d055b5da0ac02ea035bed38\").toArrayUnsafe();\n    byte[] myval = Hex.decode(\"5375ba871e5c3d0f1d055b5da0ac02ea035bed38\");\n    assertThat(tuweniVal).isEqualTo(myval);\n    assertThat(Arrays.equals(tuweniVal, myval)).isTrue();\n  }\n  @Test\n  public void encoodeListDoesSameAsTuweni() {\n    final List<PublicKey> members = List.of(recipient1, recipient2, recipient3);\n    List<byte[]> sortedKeys =\n        members.stream()\n            .distinct()\n            .map(PublicKey::getKeyBytes)\n            .sorted(Comparator.comparing(Arrays::hashCode))\n            .collect(Collectors.toList());\n    final byte[] rlpEncoded =\n        RLP.encodeList(listWriter -> sortedKeys.forEach(listWriter::writeByteArray)).toArray();\n    assertThat(rlpEncoded).isEqualTo(RlpEncodeUtil.encodeList(sortedKeys));\n  }\n  @Test\n  public void encoodeListDoesSameAsTuweni55Length() {\n    final byte[] data = new byte[54];\n    Arrays.fill(data, (byte) 1);\n    final List<PublicKey> members = List.of(PublicKey.from(data));\n    List<byte[]> sortedKeys =\n        members.stream()\n            .distinct()\n            .map(PublicKey::getKeyBytes)\n            .sorted(Comparator.comparing(Arrays::hashCode))\n            .collect(Collectors.toList());\n    final byte[] rlpEncoded =\n        RLP.encodeList(listWriter -> sortedKeys.forEach(listWriter::writeByteArray)).toArray();\n    assertThat(rlpEncoded).isEqualTo(RlpEncodeUtil.encodeList(sortedKeys));\n  }\n  @Test\n  public void encodeRLPElementNull() {\n    byte[] result = RlpEncodeUtil.encodeRLPElement(null);\n    assertThat(result).isEqualTo(new byte[] {(byte) 0x80});\n  }\n  @Test\n  public void encodeRLPElementEmpty() {\n    byte[] result = RlpEncodeUtil.encodeRLPElement(new byte[0]);\n    assertThat(result).isEqualTo(new byte[] {(byte) 0x80});\n  }\n  @Test\n  public void encodeRLPElementLength55OrUnder() {\n    final byte[] data = new byte[54];\n    Arrays.fill(data, (byte) 1);\n    byte[] result = RlpEncodeUtil.encodeRLPElement(data);\n    assertThat(result)\n        .isEqualTo(\n            new byte[] {\n              -74, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n              1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n            });\n  }\n  @Test\n  public void encodeRLPElementLengthGreaterThan55() {\n    final byte[] data = new byte[300];\n    Arrays.fill(data, (byte) 1);\n    final byte[] result = RlpEncodeUtil.encodeRLPElement(data);\n    final byte[] expected = new byte[303];\n    expected[0] = -71;\n    expected[1] = 44;\n    Arrays.fill(expected, 2, 303, (byte) 1);\n    assertThat(result.length).isEqualTo(expected.length);\n    assertThat(result).isEqualTo(expected);\n  }\n  @Test\n  public void encodeRLPElementLengthOnlyOne() {\n    final byte[] data = new byte[] {9};\n    byte[] result = RlpEncodeUtil.encodeRLPElement(data);\n    assertThat(result).isEqualTo(new byte[] {9});\n  }\n"]]}
{"hexsha": "ca4a6b806eddc887f25f11f5f5d9a9d74a97a738", "ext": "java", "lang": "Java", "content": "public class EdCompInstGMOSNorth extends EdCompInstGMOS<InstGmosNorth> {\n    public EdCompInstGMOSNorth() {\n        super();\n    }\n\n    @Override protected void init() {\n        super.init();\n\n        // Add the property change listeners defined in InstGmosCommon.\n        final InstGmosNorth inst = getDataObject();\n        inst.addPropertyChangeListener(InstGmosNorth.FPUNIT_PROP.getName(), updateParallacticAnglePCL);\n        inst.addPropertyChangeListener(InstGmosNorth.FPUNIT_PROP.getName(), updateUnboundedAnglePCL);\n    }\n\n    @Override protected void cleanup() {\n        super.cleanup();\n\n        final InstGmosNorth inst = getDataObject();\n        inst.removePropertyChangeListener(InstGmosNorth.FPUNIT_PROP.getName(), updateParallacticAnglePCL);\n        inst.removePropertyChangeListener(InstGmosNorth.FPUNIT_PROP.getName(), updateUnboundedAnglePCL);\n    }\n}", "class_id": 0, "repo": "cquiroz/ocs", "file": "bundle/jsky.app.ot/src/main/java/jsky/app/ot/gemini/gmos/EdCompInstGMOSNorth.java", "last_update_at": "2020-04-10T01:37:41+00:00", "question_id": "ca4a6b806eddc887f25f11f5f5d9a9d74a97a738", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EdCompInstGMOSNorth extends EdCompInstGMOS<InstGmosNorth> {\n    public EdCompInstGMOSNorth() {\n        super();\n    }\n    @Override protected void init() {\n        super.init();\n        // Add the property change listeners defined in InstGmosCommon.\n        final InstGmosNorth inst = getDataObject();\n        inst.addPropertyChangeListener(InstGmosNorth.FPUNIT_PROP.getName(), updateParallacticAnglePCL);\n        inst.addPropertyChangeListener(InstGmosNorth.FPUNIT_PROP.getName(), updateUnboundedAnglePCL);\n    }\n    @Override protected void cleanup() {\n        super.cleanup();\n        final InstGmosNorth inst = getDataObject();\n        inst.removePropertyChangeListener(InstGmosNorth.FPUNIT_PROP.getName(), updateParallacticAnglePCL);\n        inst.removePropertyChangeListener(InstGmosNorth.FPUNIT_PROP.getName(), updateUnboundedAnglePCL);\n    }\n"]]}
{"hexsha": "29c4c5eba17d7a15997d4615015aa5837cf0563e", "ext": "java", "lang": "Java", "content": "public class MainScreen extends Screen {\n\t\n\t///private boolean choosingMultiplayer = false;\n\t\n\tprivate Room room;\n\t\n\t//private String ip = null; //ip you're trying to connect to. when null, you're not trying to connect to a server, when initialized, this means you're trying to connect to a server.\n\tprivate int selectedMario;\n\t\n\tprivate final BufferedImage[] MARIO_COLORS = {\n\t\tnull,\n\t\tnull,\n\t\tnull,\n\t\tnull,\n\t\tnull,\n\t\tnull\n\t};\n\t\n\tprivate TextButton\teditorButton,\n\t\t\t\t\t\tnewGame,\n\t\t\t\t\t\tloadGame,\n\t\t\t\t\t\tsingleButton,\n\t\t\t\t\t\t//multiButton,\n\t\t\t\t\t\ttitle,\n\t\t\t\t\t\tcouldntLoad,\n\t\t\t\t\t\tquit;\n\t\n\tprivate static final int SPACE_FROM_TOP = 150, SPACE_BETWEEN = 2;\n\t\n\tprivate static final Font FONT_TITLE = new Font(\"Courier\", Font.PLAIN, 100);\n\t\n\tprivate boolean editorSelected, loadFailed;\n\t\n\tpublic MainScreen(){\n\t\teditorSelected = false;\n\t\tloadFailed = false;\n\t\tfor(int i = 0; i < MARIO_COLORS.length; i++){\n\t\t\tHero h = new Hero();\n\t\t\th.setSpriteColor(i);\n\t\t\tMARIO_COLORS[i] = (h.IMAGE[0]).getBuffer();\n\t\t}\n\t\tselectedMario = (int)(Math.random()*6);\n\t\tboolean underground = Math.random() > 0.5;\n\t\troom = new Room(underground, -1);\n\t\troom.add(new TGoomba(500,0,32,32));\n\t\tTKoopa koopa = new TKoopa(3000,0);\n\t\troom.add(koopa);\n\t\tkoopa.makeShell(true);\n\t\tkoopa.vel.x = -TKoopa.SHELL_SPEED;\n\t\troom.add(new TBlock(32*5,32*4, TBlock.QUESTION_BLOCK));\n\t\troom.add(new TBlock(32*4,32*2, TBlock.BRICK));\n\t\troom.add(new TBlock(32*3,32*2, TBlock.BRICK));\n\t\troom.add(new TBlock(32*5,32*2, TBlock.BRICK));\n\t\troom.add(new TBlock(32*6,32*2, TBlock.QUESTION_BLOCK_DEACTIVATED));\n\t\troom.add(new TBlock(32*7,32*2, TBlock.BRICK));\n\t\tTPipe pipe = new TPipe();\n\t\tpipe.setPos(-32*7, 32*5);\n\t\tTPirhana pirhana = new TPirhana();\n\t\troom.add(pipe);\n\t\troom.add(pirhana);\n\t\tpipe.addPirhana(pirhana);\n\t\troom.add(new TBlock(-32*5, 0, TBlock.BRICK, null, true));\n\t\t\n\t\tnewGame = new TextButton(\"NEW\", Wuigi.FONT_BIG);\n\t\tloadGame = new TextButton(\"LOAD\", Wuigi.FONT_BIG);\n\t\teditorButton = new TextButton(\"LEVEL EDITOR\", Wuigi.FONT_BIG);\n\t\tsingleButton = new TextButton(\"SINGLEPLAYER\", Wuigi.FONT_BIG);\n\t\tcouldntLoad = new TextButton(\"LOAD FAILED\", Wuigi.FONT_BIG, TextButton.TITLE);\n\t\t//multiButton = new TextRect(\"ONLINE\", Wuigi.FONT_BIG);\n\t\ttitle = new TextButton(\"WUIGI\", FONT_TITLE, Color.WHITE);\n\t\tquit = new TextButton(\"QUIT\", Wuigi.FONT_BIG);\n\t\tint height = editorButton.getHeight();\n\t\t\n\t\ttitle.setPos(0, SPACE_FROM_TOP - title.getHeight() - 50);\n\t\teditorButton.setPos(0, SPACE_FROM_TOP);\n\t\tnewGame.setPos(0, SPACE_FROM_TOP);\n\t\tloadGame.setPos(newGame.getWidth() + SPACE_BETWEEN*20, SPACE_FROM_TOP);\n\t\tsingleButton.setPos(0, SPACE_FROM_TOP + height + SPACE_BETWEEN);\n\t\t//multiButton.setPos(0, SPACE_FROM_TOP + (height + SPACE_BETWEEN)*2);\n\t\tcouldntLoad.setPos(0,SPACE_FROM_TOP + (height + SPACE_BETWEEN) * 2);\n\t\tquit.setPos(0, SPACE_FROM_TOP + (height + SPACE_BETWEEN)*4);\n\t}\n\t\n\tpublic void loadFailed(){\n\t\tloadFailed = true;\n\t\teditorSelected = false;\n\t}\n\t\n\tpublic void draw(Graphics g) {\n\t\troom.draw(g,null,null);\n    \t\n    \ttitle.draw(g);\n    \t\n\t\tif(!editorSelected){\n\t    \teditorButton.draw(g);\n\t\t}else{\n\t\t\tloadGame.draw(g);\n\t\t\tnewGame.draw(g);\n\t\t}\n\t\tif(loadFailed){\n\t\t\tcouldntLoad.draw(g);\n\t\t}\n\t    singleButton.draw(g);\n\t    //multiButton.draw(g);\n\t    quit.draw(g);\n\t    \n\t    //unused multiplayer code\n\t    /*g.setColor(Color.WHITE);\n\t\tg.setFont(Wuigi.FONT_BIG);\n\t\tif(connection != null && connection.disconnect){\n\t\t\t\tg.setColor(Color.RED);\n\t\t\t\tg.setFont(Wuigi.FONT_PLAIN);\n\t\t\t\tg.drawString(\"Lost connection\", 5,360);\n\t\t\t}\n\t\t}else if(ip != null){ //you chose client\n\t\t\tg.setFont(Wuigi.FONT_BIG);\n\t\t\tg.setColor(Color.RED);\n\t\t\tg.drawString(\"Type the IP:\", 5,340);\n\t\t\tg.setColor(Color.WHITE);\n\t\t\tg.drawString(ip, 5,380);\n\t\t}else{\n\t\t\tg.setFont(Wuigi.FONT_BIG);\n\t\t\tif(ScreenPanel.mouse.y > 300 && ScreenPanel.mouse.y < 340)\n\t\t\t\tg.setColor(Color.GREEN);\n\t\t\tg.drawString(\"Make a Call\", 5,340);\n\t\t\tif(ScreenPanel.mouse.y > 340 && ScreenPanel.mouse.y < 380)\n\t\t\t\tg.setColor(Color.GREEN);\n\t\t\telse\n\t\t\t\tg.setColor(Color.WHITE);\n\t\t\tg.drawString(\"Wait for Call\", 5,380);\n\t\t}\n\t\tg.setFont(Wuigi.FONT_BIG);\n\t\tif(connection != null && connection.waitingForConnect){\n\t\t\tg.setColor(Color.RED);\n\t\t\tg.drawString(\"Waiting for connection\", 5,Wuigi.H-10);\n\t\t}*/\n\t\t((Graphics2D)g).setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.25f));\n\t\tfor(int i = 0; i < 6; i++){\n\t\t\t//figure out coordinates of mario\n\t\t\tint x = i, y= 0;\n\t\t\tif(i > 2){\n\t\t\t\tx -= 3;\n\t\t\t\ty = 1;\n\t\t\t}\n\n\t\t\tif(i == selectedMario)\n\t\t\t\t((Graphics2D)g).setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f));\n\t\t\t//draw the mario itself\n\t\t\tg.drawImage(\n\t\t\t\tMARIO_COLORS[i],\n\t\t\t\t428 + x*128,\n\t\t\t\t100 + y*80,\n\t\t\t\t80,\n\t\t\t\t80,\n\t\t\t\tnull//(java.awt.image.ImageObserver)this\n\t\t\t);\n\n\t\t\tif(i == selectedMario)\n\t\t\t\t((Graphics2D)g).setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.25f));\n\t\t}\n\t\t((Graphics2D)g).setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f));\n\n\t}\n\n\tpublic void key(KeyEvent e, boolean down) {\n\t\tint code = e.getKeyCode();\n\t\t//char c = e.getKeyChar();\n\t\t\n\t\tif(!down) return; //continue only if you're pressing the key down\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t//if(ip == null){\n\t\tif(code == KeyEvent.VK_ENTER || code == KeyEvent.VK_SPACE || code == KeyEvent.VK_ESCAPE){\n\t\t\tcontroller.levelEditor(selectedMario);\n\t\t}\n\t\treturn; //continue only if you're typing the IP of the server to connect to\n\t\t//}\n\t\t\n\t\t/*if(code == KeyEvent.VK_ENTER ){\n\t\t\tConnector connection = ScreenPanel.connection;\n\t\t\tconnection = new Client(ip, 3456);\n\t\t\tconnection.waitingForConnect = true;\n\t\t\tconnection.start();\n\t\t\treturn;\n\t\t}\n\t\tif(code == KeyEvent.VK_BACK_SPACE ){\n\t\t\tif(ip.length() > 0)\n\t\t\t\tip = (new StringBuffer(ip).deleteCharAt(ip.length()-1)).toString();\n\t\t\treturn;\n\t\t}\n\t\tif(c != KeyEvent.CHAR_UNDEFINED){\n\t\t\tip += c;\n\t\t\treturn;\n\t\t}*/\n\n\t}\n\n\tpublic void mouse(MouseEvent e, boolean down) {\n\t\tif(down)return;\n\t\tint x = e.getX(), y = e.getY();\n\t\tif(quit.contains(x,y)){\n\t\t\tSystem.exit(0);\n\t\t}\n\t\tif(!editorSelected){\n\t\t\tif(editorButton.contains(x,y)){\n\t\t\t\t//controller.loadGame(selectedMario);\n\t\t\t\teditorSelected = true;\n\t\t\t}\n\t\t}else{\n\t\t\tif(loadGame.contains(x,y)){\n\t\t\t\tloadFailed = false;\n\t\t\t\tcontroller.loadLevelEditor(selectedMario);\n\t\t\t}else if(newGame.contains(x,y)){\n\t\t\t\tcontroller.levelEditor(selectedMario);\n\t\t\t}\n\t\t}\n\t\tif(singleButton.contains(x,y)){\n\t\t\tloadFailed = false;\n\t\t\tcontroller.singlePlayer(selectedMario);\n\t\t}\n\t\t/*Connector connection = ScreenPanel.connection;\n\t\tif(multiButton.contains(x,y) && !choosingMultiplayer){\n\t\t\tchoosingMultiplayer = true;\n\t\t}else if(choosingMultiplayer && connection == null && ip == null){\n\t\t\tif(y > 300 && y < 340){\n\t\t\t\tip = \"\"; //this means that we chose client\n\t\t\t}else if(y > 340 && y < 380){\n\t\t\t\tconnection = new Server(3456);\n\t\t\t\tconnection.waitingForConnect = true;\n\t\t\t\tconnection.start();\n\t\t\t}\n\t\t}*/\n\t\t\n\t\tfor(int i = 0; i < 6; i++){\n\t\t\tint xpos = i, ypos= 0;\n\t\t\tif(i > 2){\n\t\t\t\txpos -= 3;\n\t\t\t\typos = 1;\n\t\t\t}\n\t\t\tif(x > 428 + xpos*128 && x < 508 + xpos*128 &&\n\t\t\t\ty > 100 + ypos*80 && y < 180 + ypos*80){\n\t\t\t\tselectedMario = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic void think() {\n\t\t/*Connector connection = ScreenPanel.connection;\n\t\tif(connection != null && connection.waitingForConnect && !connection.connected){\n\t\t\tString m = connection.getLastMessage();\n\t\t\tif(m != null){\n\t\t\t\tif(m.equals(\"connect\")){\n\t\t\t\t\tconnection.connected = true;\n\t\t\t\t\tconnection.waitingForConnect = false;\n\t\t\t\t\tcontroller.levelEditor(selectedMario);\n\t\t\t\t}else if(m.equals(\"disconnect\")){\n\t\t\t\t\tconnection.disconnect();\n\t\t\t\t}else{\n\t\t\t\t\tconnection.message(m); //throw the message back in\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\troom.think(null,true);\n\n\t}\n\n}", "class_id": 0, "repo": "rweichler/wuigi", "file": "src/MainScreen.java", "last_update_at": "2020-08-24T18:54:48+00:00", "question_id": "29c4c5eba17d7a15997d4615015aa5837cf0563e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MainScreen extends Screen {\n\t\n\t///private boolean choosingMultiplayer = false;\n\t\n\tprivate Room room;\n\t\n\t//private String ip = null; //ip you're trying to connect to. when null, you're not trying to connect to a server, when initialized, this means you're trying to connect to a server.\n\tprivate int selectedMario;\n\t\n\tprivate final BufferedImage[] MARIO_COLORS = {\n\t\tnull,\n\t\tnull,\n\t\tnull,\n\t\tnull,\n\t\tnull,\n\t\tnull\n\t};\n\t\n\tprivate TextButton\teditorButton,\n\t\t\t\t\t\tnewGame,\n\t\t\t\t\t\tloadGame,\n\t\t\t\t\t\tsingleButton,\n\t\t\t\t\t\t//multiButton,\n\t\t\t\t\t\ttitle,\n\t\t\t\t\t\tcouldntLoad,\n\t\t\t\t\t\tquit;\n\t\n\tprivate static final int SPACE_FROM_TOP = 150, SPACE_BETWEEN = 2;\n\t\n\tprivate static final Font FONT_TITLE = new Font(\"Courier\", Font.PLAIN, 100);\n\t\n\tprivate boolean editorSelected, loadFailed;\n\t\n\tpublic MainScreen(){\n\t\teditorSelected = false;\n\t\tloadFailed = false;\n\t\tfor(int i = 0; i < MARIO_COLORS.length; i++){\n\t\t\tHero h = new Hero();\n\t\t\th.setSpriteColor(i);\n\t\t\tMARIO_COLORS[i] = (h.IMAGE[0]).getBuffer();\n\t\t}\n\t\tselectedMario = (int)(Math.random()*6);\n\t\tboolean underground = Math.random() > 0.5;\n\t\troom = new Room(underground, -1);\n\t\troom.add(new TGoomba(500,0,32,32));\n\t\tTKoopa koopa = new TKoopa(3000,0);\n\t\troom.add(koopa);\n\t\tkoopa.makeShell(true);\n\t\tkoopa.vel.x = -TKoopa.SHELL_SPEED;\n\t\troom.add(new TBlock(32*5,32*4, TBlock.QUESTION_BLOCK));\n\t\troom.add(new TBlock(32*4,32*2, TBlock.BRICK));\n\t\troom.add(new TBlock(32*3,32*2, TBlock.BRICK));\n\t\troom.add(new TBlock(32*5,32*2, TBlock.BRICK));\n\t\troom.add(new TBlock(32*6,32*2, TBlock.QUESTION_BLOCK_DEACTIVATED));\n\t\troom.add(new TBlock(32*7,32*2, TBlock.BRICK));\n\t\tTPipe pipe = new TPipe();\n\t\tpipe.setPos(-32*7, 32*5);\n\t\tTPirhana pirhana = new TPirhana();\n\t\troom.add(pipe);\n\t\troom.add(pirhana);\n\t\tpipe.addPirhana(pirhana);\n\t\troom.add(new TBlock(-32*5, 0, TBlock.BRICK, null, true));\n\t\t\n\t\tnewGame = new TextButton(\"NEW\", Wuigi.FONT_BIG);\n\t\tloadGame = new TextButton(\"LOAD\", Wuigi.FONT_BIG);\n\t\teditorButton = new TextButton(\"LEVEL EDITOR\", Wuigi.FONT_BIG);\n\t\tsingleButton = new TextButton(\"SINGLEPLAYER\", Wuigi.FONT_BIG);\n\t\tcouldntLoad = new TextButton(\"LOAD FAILED\", Wuigi.FONT_BIG, TextButton.TITLE);\n\t\t//multiButton = new TextRect(\"ONLINE\", Wuigi.FONT_BIG);\n\t\ttitle = new TextButton(\"WUIGI\", FONT_TITLE, Color.WHITE);\n\t\tquit = new TextButton(\"QUIT\", Wuigi.FONT_BIG);\n\t\tint height = editorButton.getHeight();\n\t\t\n\t\ttitle.setPos(0, SPACE_FROM_TOP - title.getHeight() - 50);\n\t\teditorButton.setPos(0, SPACE_FROM_TOP);\n\t\tnewGame.setPos(0, SPACE_FROM_TOP);\n\t\tloadGame.setPos(newGame.getWidth() + SPACE_BETWEEN*20, SPACE_FROM_TOP);\n\t\tsingleButton.setPos(0, SPACE_FROM_TOP + height + SPACE_BETWEEN);\n\t\t//multiButton.setPos(0, SPACE_FROM_TOP + (height + SPACE_BETWEEN)*2);\n\t\tcouldntLoad.setPos(0,SPACE_FROM_TOP + (height + SPACE_BETWEEN) * 2);\n\t\tquit.setPos(0, SPACE_FROM_TOP + (height + SPACE_BETWEEN)*4);\n\t}\n\t\n\tpublic void loadFailed(){\n\t\tloadFailed = true;\n\t\teditorSelected = false;\n\t}\n\t\n\tpublic void draw(Graphics g) {\n\t\troom.draw(g,null,null);\n    \t\n    \ttitle.draw(g);\n    \t\n\t\tif(!editorSelected){\n\t    \teditorButton.draw(g);\n\t\t}else{\n\t\t\tloadGame.draw(g);\n\t\t\tnewGame.draw(g);\n\t\t}\n\t\tif(loadFailed){\n\t\t\tcouldntLoad.draw(g);\n\t\t}\n\t    singleButton.draw(g);\n\t    //multiButton.draw(g);\n\t    quit.draw(g);\n\t    \n\t    //unused multiplayer code\n\t    /*g.setColor(Color.WHITE);\n\t\tg.setFont(Wuigi.FONT_BIG);\n\t\tif(connection != null && connection.disconnect){\n\t\t\t\tg.setColor(Color.RED);\n\t\t\t\tg.setFont(Wuigi.FONT_PLAIN);\n\t\t\t\tg.drawString(\"Lost connection\", 5,360);\n\t\t\t}\n\t\t}else if(ip != null){ //you chose client\n\t\t\tg.setFont(Wuigi.FONT_BIG);\n\t\t\tg.setColor(Color.RED);\n\t\t\tg.drawString(\"Type the IP:\", 5,340);\n\t\t\tg.setColor(Color.WHITE);\n\t\t\tg.drawString(ip, 5,380);\n\t\t}else{\n\t\t\tg.setFont(Wuigi.FONT_BIG);\n\t\t\tif(ScreenPanel.mouse.y > 300 && ScreenPanel.mouse.y < 340)\n\t\t\t\tg.setColor(Color.GREEN);\n\t\t\tg.drawString(\"Make a Call\", 5,340);\n\t\t\tif(ScreenPanel.mouse.y > 340 && ScreenPanel.mouse.y < 380)\n\t\t\t\tg.setColor(Color.GREEN);\n\t\t\telse\n\t\t\t\tg.setColor(Color.WHITE);\n\t\t\tg.drawString(\"Wait for Call\", 5,380);\n\t\t}\n\t\tg.setFont(Wuigi.FONT_BIG);\n\t\tif(connection != null && connection.waitingForConnect){\n\t\t\tg.setColor(Color.RED);\n\t\t\tg.drawString(\"Waiting for connection\", 5,Wuigi.H-10);\n\t\t}*/\n\t\t((Graphics2D)g).setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.25f));\n\t\tfor(int i = 0; i < 6; i++){\n\t\t\t//figure out coordinates of mario\n\t\t\tint x = i, y= 0;\n\t\t\tif(i > 2){\n\t\t\t\tx -= 3;\n\t\t\t\ty = 1;\n\t\t\t}\n\t\t\tif(i == selectedMario)\n\t\t\t\t((Graphics2D)g).setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f));\n\t\t\t//draw the mario itself\n\t\t\tg.drawImage(\n\t\t\t\tMARIO_COLORS[i],\n\t\t\t\t428 + x*128,\n\t\t\t\t100 + y*80,\n\t\t\t\t80,\n\t\t\t\t80,\n\t\t\t\tnull//(java.awt.image.ImageObserver)this\n\t\t\t);\n\t\t\tif(i == selectedMario)\n\t\t\t\t((Graphics2D)g).setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.25f));\n\t\t}\n\t\t((Graphics2D)g).setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f));\n\t}\n\tpublic void key(KeyEvent e, boolean down) {\n\t\tint code = e.getKeyCode();\n\t\t//char c = e.getKeyChar();\n\t\t\n\t\tif(!down) return; //continue only if you're pressing the key down\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t//if(ip == null){\n\t\tif(code == KeyEvent.VK_ENTER || code == KeyEvent.VK_SPACE || code == KeyEvent.VK_ESCAPE){\n\t\t\tcontroller.levelEditor(selectedMario);\n\t\t}\n\t\treturn; //continue only if you're typing the IP of the server to connect to\n\t\t//}\n\t\t\n\t\t/*if(code == KeyEvent.VK_ENTER ){\n\t\t\tConnector connection = ScreenPanel.connection;\n\t\t\tconnection = new Client(ip, 3456);\n\t\t\tconnection.waitingForConnect = true;\n\t\t\tconnection.start();\n\t\t\treturn;\n\t\t}\n\t\tif(code == KeyEvent.VK_BACK_SPACE ){\n\t\t\tif(ip.length() > 0)\n\t\t\t\tip = (new StringBuffer(ip).deleteCharAt(ip.length()-1)).toString();\n\t\t\treturn;\n\t\t}\n\t\tif(c != KeyEvent.CHAR_UNDEFINED){\n\t\t\tip += c;\n\t\t\treturn;\n\t\t}*/\n\t}\n\tpublic void mouse(MouseEvent e, boolean down) {\n\t\tif(down)return;\n\t\tint x = e.getX(), y = e.getY();\n\t\tif(quit.contains(x,y)){\n\t\t\tSystem.exit(0);\n\t\t}\n\t\tif(!editorSelected){\n\t\t\tif(editorButton.contains(x,y)){\n\t\t\t\t//controller.loadGame(selectedMario);\n\t\t\t\teditorSelected = true;\n\t\t\t}\n\t\t}else{\n\t\t\tif(loadGame.contains(x,y)){\n\t\t\t\tloadFailed = false;\n\t\t\t\tcontroller.loadLevelEditor(selectedMario);\n\t\t\t}else if(newGame.contains(x,y)){\n\t\t\t\tcontroller.levelEditor(selectedMario);\n\t\t\t}\n\t\t}\n\t\tif(singleButton.contains(x,y)){\n\t\t\tloadFailed = false;\n\t\t\tcontroller.singlePlayer(selectedMario);\n\t\t}\n\t\t/*Connector connection = ScreenPanel.connection;\n\t\tif(multiButton.contains(x,y) && !choosingMultiplayer){\n\t\t\tchoosingMultiplayer = true;\n\t\t}else if(choosingMultiplayer && connection == null && ip == null){\n\t\t\tif(y > 300 && y < 340){\n\t\t\t\tip = \"\"; //this means that we chose client\n\t\t\t}else if(y > 340 && y < 380){\n\t\t\t\tconnection = new Server(3456);\n\t\t\t\tconnection.waitingForConnect = true;\n\t\t\t\tconnection.start();\n\t\t\t}\n\t\t}*/\n\t\t\n\t\tfor(int i = 0; i < 6; i++){\n\t\t\tint xpos = i, ypos= 0;\n\t\t\tif(i > 2){\n\t\t\t\txpos -= 3;\n\t\t\t\typos = 1;\n\t\t\t}\n\t\t\tif(x > 428 + xpos*128 && x < 508 + xpos*128 &&\n\t\t\t\ty > 100 + ypos*80 && y < 180 + ypos*80){\n\t\t\t\tselectedMario = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpublic void think() {\n\t\t/*Connector connection = ScreenPanel.connection;\n\t\tif(connection != null && connection.waitingForConnect && !connection.connected){\n\t\t\tString m = connection.getLastMessage();\n\t\t\tif(m != null){\n\t\t\t\tif(m.equals(\"connect\")){\n\t\t\t\t\tconnection.connected = true;\n\t\t\t\t\tconnection.waitingForConnect = false;\n\t\t\t\t\tcontroller.levelEditor(selectedMario);\n\t\t\t\t}else if(m.equals(\"disconnect\")){\n\t\t\t\t\tconnection.disconnect();\n\t\t\t\t}else{\n\t\t\t\t\tconnection.message(m); //throw the message back in\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\troom.think(null,true);\n\t}\n"]]}
{"hexsha": "7f60a2a0cf07b17a81254108d3bcdeb141b3471e", "ext": "java", "lang": "Java", "content": "public class TimeHelper {\n    private final Map<String, Long> mMap;\n\n    private TimeHelper() {\n        mMap = new ArrayMap<>();\n    }\n\n    public void start(@NonNull String id) {\n        if (TextUtils.isEmpty(id) || mMap.containsKey(id)) {\n            new IllegalArgumentException(\"Illegal id\")\n                    .printStackTrace();\n\n            return;\n        }\n\n        mMap.put(id, System.currentTimeMillis());\n    }\n\n    public long stop(@NonNull String id) {\n        if (TextUtils.isEmpty(id) || !mMap.containsKey(id)) {\n            new IllegalArgumentException(\"Illegal id\")\n                    .printStackTrace();\n\n            return 0L;\n        }\n\n        final long startTIme = mMap.remove(id);\n\n        return System.currentTimeMillis() - startTIme;\n    }\n\n    public static TimeHelper getInstance() {\n        return Holder.sInstance;\n    }\n\n    private interface Holder {\n        TimeHelper sInstance = new TimeHelper();\n    }\n}", "class_id": 0, "repo": "huazhouwang/Synapse", "file": "app/src/main/java/io/whz/synapse/track/TimeHelper.java", "last_update_at": "2020-05-20T05:26:58+00:00", "question_id": "7f60a2a0cf07b17a81254108d3bcdeb141b3471e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TimeHelper {\n    private final Map<String, Long> mMap;\n    private TimeHelper() {\n        mMap = new ArrayMap<>();\n    }\n    public void start(@NonNull String id) {\n        if (TextUtils.isEmpty(id) || mMap.containsKey(id)) {\n            new IllegalArgumentException(\"Illegal id\")\n                    .printStackTrace();\n            return;\n        }\n        mMap.put(id, System.currentTimeMillis());\n    }\n    public long stop(@NonNull String id) {\n        if (TextUtils.isEmpty(id) || !mMap.containsKey(id)) {\n            new IllegalArgumentException(\"Illegal id\")\n                    .printStackTrace();\n            return 0L;\n        }\n        final long startTIme = mMap.remove(id);\n        return System.currentTimeMillis() - startTIme;\n    }\n    public static TimeHelper getInstance() {\n        return Holder.sInstance;\n    }\n    private interface Holder {\n        TimeHelper sInstance = new TimeHelper();\n    }\n"]]}
{"hexsha": "9b9ef24c8655a74c129369dc367521d188e417d8", "ext": "java", "lang": "Java", "content": "public class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        BottomNavigationView navView = findViewById(R.id.nav_view);\n        // Passing each menu ID as a set of Ids because each\n        // menu should be considered as top level destinations.\n        AppBarConfiguration appBarConfiguration = new AppBarConfiguration.Builder(\n                R.id.navigation_home, R.id.navigation_favorites, R.id.navigation_search, R.id.navigation_profile)\n                .build();\n        NavController navController = Navigation.findNavController(this, R.id.nav_host_fragment);\n        NavigationUI.setupActionBarWithNavController(this, navController, appBarConfiguration);\n        NavigationUI.setupWithNavController(navView, navController);\n        getSupportActionBar().setDisplayHomeAsUpEnabled(false);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        if (item.getItemId() == android.R.id.home) {\n            //Title bar back press triggers onBackPressed()\n            onBackPressed();\n            return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    @Override\n    public void onBackPressed() {\n        if (getFragmentManager().getBackStackEntryCount() > 0 ) {\n            getFragmentManager().popBackStack();\n        }\n        else {\n            super.onBackPressed();\n        }\n\n    }\n\n}", "class_id": 0, "repo": "tomas99batista/Homies_Marketplace", "file": "projAndroid/HomiesMarketPlaceApp/app/src/main/java/com/example/homiesmarketplaceapp/MainActivity.java", "last_update_at": "2020-06-04T16:42:46+00:00", "question_id": "9b9ef24c8655a74c129369dc367521d188e417d8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        BottomNavigationView navView = findViewById(R.id.nav_view);\n        // Passing each menu ID as a set of Ids because each\n        // menu should be considered as top level destinations.\n        AppBarConfiguration appBarConfiguration = new AppBarConfiguration.Builder(\n                R.id.navigation_home, R.id.navigation_favorites, R.id.navigation_search, R.id.navigation_profile)\n                .build();\n        NavController navController = Navigation.findNavController(this, R.id.nav_host_fragment);\n        NavigationUI.setupActionBarWithNavController(this, navController, appBarConfiguration);\n        NavigationUI.setupWithNavController(navView, navController);\n        getSupportActionBar().setDisplayHomeAsUpEnabled(false);\n    }\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        if (item.getItemId() == android.R.id.home) {\n            //Title bar back press triggers onBackPressed()\n            onBackPressed();\n            return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    @Override\n    public void onBackPressed() {\n        if (getFragmentManager().getBackStackEntryCount() > 0 ) {\n            getFragmentManager().popBackStack();\n        }\n        else {\n            super.onBackPressed();\n        }\n    }\n"]]}
{"hexsha": "5d697c3187eab40f7dd3596f4be730d766fd7fe1", "ext": "java", "lang": "Java", "content": "public class LoggingFilter implements ClientRequestFilter, ClientResponseFilter {\n\n  private final Logger LOG = LoggerFactory.getLogger(LoggingFilter.class);\n\n  @Override\n  public void filter(ClientRequestContext requestContext) throws IOException {\n    ObjectMapper mapper = new ObjectMapper();\n    mapper.registerModule(new JavaTimeModule());\n\n    LOG.info(System.getProperty(\"line.separator\") + \"!!! Test Request\" + System\n            .getProperty(\"line.separator\") + \"!!! URL: {}\" + System.getProperty(\"line.separator\")\n            + \"!!! Method: {}\" + System.getProperty(\"line.separator\") + \"!!! Body: {}\",\n        requestContext.getUri(),\n        requestContext.getMethod(),\n        mapper.writerWithDefaultPrettyPrinter().writeValueAsString(requestContext.getEntity()));\n  }\n\n  @Override\n  public void filter(ClientRequestContext clientRequestContext,\n      ClientResponseContext clientResponseContext) throws IOException {\n    LOG.info(System.getProperty(\"line.separator\") + \"!!! Test Response \" + System\n            .getProperty(\"line.separator\") + \"!!! Body: {} \" + System.getProperty(\"line.separator\")\n            + \"!!! Status: {}\",\n        responseToString(clientResponseContext),\n        clientResponseContext.getStatus());\n  }\n\n  private String responseToString(ClientResponseContext clientResponseContext) {\n    InputStream inputStream = clientResponseContext.getEntityStream();\n    if (inputStream == null) {\n      return \"\";\n    } else {\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      try {\n        IOUtils.copy(inputStream, baos);\n        InputStream restoredStream = new ByteArrayInputStream(\n            baos.toString().getBytes(StandardCharsets.UTF_8));\n        clientResponseContext.setEntityStream(restoredStream);\n      } catch (IOException e) {\n        // nothing to do\n      }\n      return baos.toString();\n    }\n  }\n}", "class_id": 0, "repo": "hhstechgroup/geo-services-api", "file": "src/test/java/gov/ca/cwds/geo/web/rest/LoggingFilter.java", "last_update_at": "2020-10-31T21:31:55+00:00", "question_id": "5d697c3187eab40f7dd3596f4be730d766fd7fe1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LoggingFilter implements ClientRequestFilter, ClientResponseFilter {\n  private final Logger LOG = LoggerFactory.getLogger(LoggingFilter.class);\n  @Override\n  public void filter(ClientRequestContext requestContext) throws IOException {\n    ObjectMapper mapper = new ObjectMapper();\n    mapper.registerModule(new JavaTimeModule());\n    LOG.info(System.getProperty(\"line.separator\") + \"!!! Test Request\" + System\n            .getProperty(\"line.separator\") + \"!!! URL: {}\" + System.getProperty(\"line.separator\")\n            + \"!!! Method: {}\" + System.getProperty(\"line.separator\") + \"!!! Body: {}\",\n        requestContext.getUri(),\n        requestContext.getMethod(),\n        mapper.writerWithDefaultPrettyPrinter().writeValueAsString(requestContext.getEntity()));\n  }\n  @Override\n  public void filter(ClientRequestContext clientRequestContext,\n      ClientResponseContext clientResponseContext) throws IOException {\n    LOG.info(System.getProperty(\"line.separator\") + \"!!! Test Response \" + System\n            .getProperty(\"line.separator\") + \"!!! Body: {} \" + System.getProperty(\"line.separator\")\n            + \"!!! Status: {}\",\n        responseToString(clientResponseContext),\n        clientResponseContext.getStatus());\n  }\n  private String responseToString(ClientResponseContext clientResponseContext) {\n    InputStream inputStream = clientResponseContext.getEntityStream();\n    if (inputStream == null) {\n      return \"\";\n    } else {\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      try {\n        IOUtils.copy(inputStream, baos);\n        InputStream restoredStream = new ByteArrayInputStream(\n            baos.toString().getBytes(StandardCharsets.UTF_8));\n        clientResponseContext.setEntityStream(restoredStream);\n      } catch (IOException e) {\n        // nothing to do\n      }\n      return baos.toString();\n    }\n  }\n"]]}
{"hexsha": "0da3c430cadcb83ec8c41116b7dcb920cd7f580c", "ext": "java", "lang": "Java", "content": "public class Codec {\r\n\t/**\r\n\t * All possible chars for representing a number as a String\r\n\t */\r\n\tprivate static final char[] DIGIT_ALL = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\".toCharArray();\r\n\tprivate static final char[] DIGITS    = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray();\r\n\tprivate static final String ASCII_LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n\tprivate static final String ENCODING = \"ISO-8859-1\";\r\n\r\n\t/**\r\n\t * @param text , text in plain format\r\n\t * @param algorithm   MD5 OR SHA1\r\n\t * @return hash in algorithm\r\n\t */\r\n\tprivate static String getHash(String text, String algorithm) {\r\n\t\treturn encodeString(digest(text, algorithm));\r\n\t}\r\n\r\n\tpublic static byte[] digest(String text, String algorithm) {\r\n\t\ttry {\r\n\t\t\tMessageDigest md = MessageDigest.getInstance(algorithm);\r\n\t\t\treturn md.digest(text.getBytes());\r\n\t\t} catch (NoSuchAlgorithmException ex) {\r\n\t\t\tthrow new RuntimeException(ex.getMessage(), ex);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static String md5(String txt) {\r\n\t\treturn getHash(txt, \"MD5\");\r\n\t}\r\n\r\n\tpublic static String sha1(String txt) {\r\n\t\treturn getHash(txt, \"SHA1\");\r\n\t}\r\n\r\n\tpublic static final String encodeHex(byte bytes[]) {\r\n\t\tStringBuffer sb = new StringBuffer();\r\n\t\tfor (int i = 0; i < bytes.length; ++i) {\r\n\t\t\tsb.append(Integer.toHexString((bytes[i] & 0xFF) | 0x100).substring(1, 3));\r\n\t\t}\r\n\t\treturn sb.toString();\r\n\t}\r\n\r\n\tpublic static final byte[] decodeHex(String hex) {\r\n\t\tchar chars[] = hex.toCharArray();\r\n\t\tbyte bytes[] = new byte[chars.length / 2];\r\n\t\tint byteCount = 0;\r\n\t\tfor (int i = 0; i < chars.length; i += 2) {\r\n\t\t\tint newByte = 0;\r\n\t\t\tnewByte |= hexCharToByte(chars[i]);\r\n\t\t\tnewByte <<= 4;\r\n\t\t\tnewByte |= hexCharToByte(chars[i + 1]);\r\n\t\t\tbytes[byteCount] = (byte) newByte;\r\n\t\t\tbyteCount++;\r\n\t\t}\r\n\t\treturn bytes;\r\n\t}\r\n\r\n\tpublic static String encodeBase64(String data) {\r\n\t\tbyte bytes[] = null;\r\n\t\ttry {\r\n\t\t\tbytes = data.getBytes(ENCODING);\r\n\t\t\treturn encodeBase64(bytes);\r\n\t\t} catch (UnsupportedEncodingException uee) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static String encodeBase64(byte data[]) {\r\n\t\tint len = data.length;\r\n\t\tStringBuffer ret = new StringBuffer((len / 3 + 1) * 4);\r\n\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\tint c = data[i] >> 2 & 0x3f;\r\n\t\t\tret.append(ASCII_LETTERS.charAt(c));\r\n\t\t\tc = data[i] << 4 & 0x3f;\r\n\t\t\tif (++i < len)\r\n\t\t\t\tc |= data[i] >> 4 & 0xf;\r\n\t\t\tret.append(ASCII_LETTERS.charAt(c));\r\n\t\t\tif (i < len) {\r\n\t\t\t\tc = data[i] << 2 & 0x3f;\r\n\t\t\t\tif (++i < len)\r\n\t\t\t\t\tc |= data[i] >> 6 & 3;\r\n\t\t\t\tret.append(ASCII_LETTERS.charAt(c));\r\n\t\t\t} else {\r\n\t\t\t\ti++;\r\n\t\t\t\tret.append('=');\r\n\t\t\t}\r\n\t\t\tif (i < len) {\r\n\t\t\t\tc = data[i] & 0x3f;\r\n\t\t\t\tret.append(ASCII_LETTERS.charAt(c));\r\n\t\t\t} else {\r\n\t\t\t\tret.append('=');\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn ret.toString();\r\n\t}\r\n\r\n\tpublic static String decodeBase64(String data) {\r\n\t\tbyte bytes[] = null;\r\n\t\ttry {\r\n\t\t\tbytes = data.getBytes(ENCODING);\r\n\t\t\treturn decodeBase64(bytes);\r\n\t\t} catch (UnsupportedEncodingException uee) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static String decodeBase64(byte data[]) {\r\n\t\tint len = data.length;\r\n\t\tStringBuffer ret = new StringBuffer((len * 3) / 4);\r\n\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\tint c = ASCII_LETTERS.indexOf(data[i]);\r\n\t\t\ti++;\r\n\t\t\tint c1 = ASCII_LETTERS.indexOf(data[i]);\r\n\t\t\tc = c << 2 | c1 >> 4 & 3;\r\n\t\t\tret.append((char) c);\r\n\t\t\tif (++i < len) {\r\n\t\t\t\tc = data[i];\r\n\t\t\t\tif (61 == c)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tc = ASCII_LETTERS.indexOf(c);\r\n\t\t\t\tc1 = c1 << 4 & 0xf0 | c >> 2 & 0xf;\r\n\t\t\t\tret.append((char) c1);\r\n\t\t\t}\r\n\t\t\tif (++i >= len)\r\n\t\t\t\tcontinue;\r\n\t\t\tc1 = data[i];\r\n\t\t\tif (61 == c1)\r\n\t\t\t\tbreak;\r\n\t\t\tc1 = ASCII_LETTERS.indexOf(c1);\r\n\t\t\tc = c << 6 & 0xc0 | c1;\r\n\t\t\tret.append((char) c);\r\n\t\t}\r\n\r\n\t\treturn ret.toString();\r\n\t}\r\n\r\n\tpublic static String encodeString(byte[] data) {\r\n\t\treturn encodeString(data, 0);\r\n\t}\r\n\r\n\tpublic static byte[] decodeString(String data) {\r\n\t\treturn decodeString(data, 0);\r\n\t}\r\n\r\n\tpublic static String encodeString(byte[] data, int index) {\r\n\t\treturn toBigIntegerString(new BigInteger(attachOddEven(data)), getDigits(DIGIT_ALL, index));\r\n\t}\r\n\r\n\tpublic static byte[] decodeString(String data, int index) {\r\n\t\treturn verifyOddEven(toBigInteger(data, getDigits(DIGIT_ALL, index)).toByteArray());\r\n\t}\r\n\r\n\tpublic static String encodeString(byte[] data, char[] digits) {\r\n\t\treturn toBigIntegerString(new BigInteger(attachOddEven(data)), digits);\r\n\t}\r\n\r\n\tpublic static byte[] decodeString(String data, char[] digits) {\r\n\t\treturn verifyOddEven(toBigInteger(data, digits).toByteArray());\r\n\t}\r\n\r\n\tpublic static String encodeNumbers(int[] data) {\r\n\t\tint[] value = new int[data.length + 1];\r\n\t\tvalue[0] = data.length;\r\n\t\tSystem.arraycopy(data, 0, value, 1, data.length);\r\n\t\tByteBuffer byteBuffer = ByteBuffer.allocate(value.length * 4);\r\n        IntBuffer intBuffer = byteBuffer.asIntBuffer();\r\n        intBuffer.put(value);\r\n        byte[] bytes = byteBuffer.array();\r\n\t\treturn encodeString(bytes, 0);\r\n\t}\r\n\r\n\tpublic static int[] decodeNumbers(String data) {\r\n\t\tbyte[] bytes = decodeString(data, 0);\r\n\t\tbyte[] buf = new byte[4];\r\n\t\tSystem.arraycopy(bytes, 0, buf, 0, buf.length);\r\n\t\tint size = ByteBuffer.wrap(buf).getInt();\r\n\t\tint[] values = new int[size];\r\n\t\tfor(int i=0; i<values.length; i++) {\r\n\t\t\tSystem.arraycopy(bytes, (i+1)*4, buf, 0, buf.length);\r\n\t\t\tvalues[i] = ByteBuffer.wrap(buf).getInt();\r\n\t\t}\r\n\t\treturn values;\r\n\t}\r\n\r\n\tprivate static byte[] attachOddEven(byte[] value) {\r\n\t\t// Add 1 byte odd even data on header\r\n\t\tbyte[] odd = new byte[] {(byte)(value.length%2+1)};\r\n\t\tbyte[] data = new byte[value.length + 1];\r\n\t\tSystem.arraycopy(odd, 0, data, 0, odd.length);\r\n\t\tSystem.arraycopy(value, 0, data, odd.length, value.length);\r\n\t\treturn data;\r\n\t}\r\n\r\n\tprivate static byte[] verifyOddEven(byte[] data) {\r\n\t\t//Cut 1 byte odd even data.\r\n\t\tint odd = (int)(((data.length - 1)%2) + 1);\r\n\t\tif((int)data[0] != odd) {\r\n\t\t\tthrow new IllegalArgumentException(\"Odd-even error.\");\r\n\t\t}\r\n\t\tbyte[] value = new byte[data.length-1];\r\n\t\tSystem.arraycopy(data, 1, value, 0, value.length);\r\n\t\treturn value;\r\n\t}\r\n\r\n\tprivate  static String toBigIntegerString(BigInteger big, char[] digits) {\r\n\t\tint radix = digits.length;\r\n\t\tStringBuffer sb = new StringBuffer();\r\n\t\tif (big.signum() == -1) {\r\n\t\t\tsb.append('-');\r\n\t\t}\r\n\t\tBigInteger i = new BigInteger(big.abs().toByteArray());\r\n\t\tBigInteger r = new BigInteger(Integer.toString(radix));\r\n\t\tdo {\r\n\t\t\tBigInteger dr[] = i.divideAndRemainder(r);\r\n\t\t\tsb.insert(0, digits[dr[1].intValue()]);\r\n\t\t\ti = dr[0];\r\n\t\t} while (!i.equals(BigInteger.ZERO));\r\n\t\treturn sb.toString();\r\n\t}\r\n\r\n\tprivate static BigInteger toBigInteger(String value, char[] digits)\r\n\t{\r\n\t\tint radix = digits.length;\r\n\t\tint signum = 1;\r\n\t\tBigInteger big = new BigInteger(BigInteger.ZERO.toByteArray());\r\n\t\tBigInteger r = new BigInteger(Integer.toString(radix));\r\n\t\tchar buf[] = value.toCharArray();\r\n\t\tif (buf[buf.length - 1] == '-') {\r\n\t\t\tsignum = -1;\r\n\t\t\tchar temp[] = new char[buf.length - 1];\r\n\t\t\tSystem.arraycopy(buf, 0, temp, 0, buf.length - 1);\r\n\t\t\tbuf = temp;\r\n\t\t}\r\n\t\tfor (int i = buf.length - 1; i >= 0; i--) {\r\n\t\t\tint num = binarySearch(digits, buf[i]);\r\n\t\t\tBigInteger v = new BigInteger(Integer.toString(num));\r\n\t\t\tbig = big.add(v.multiply(r.pow(buf.length - 1 - i)));\r\n\t\t}\r\n\t\tif (signum == -1)\r\n\t\t\treturn big.negate();\r\n\t\telse\r\n\t\t\treturn big;\r\n\t}\r\n\r\n\tstatic int binarySearch(char[] array, char key) {\r\n\t\tint i= 0;\r\n\t\tfor(char c : array) {\r\n\t\t\tif(key == c) {\r\n\t\t\t\treturn i;\r\n\t\t\t} else {\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n\r\n\tprivate static int[] getIntegerArray(int num, int index)\r\n    {\r\n    \tif(num < index) {\r\n    \t\tthrow new IllegalArgumentException(index + \" > \" + num );\r\n    \t}\r\n\t\tint[] array = new int[num];\r\n\t\tfor(int i=0; i<index; i++) {\r\n\t\t\tarray[i] = num - index + i;\r\n\t\t}\r\n\t\tfor(int i=index; i<num; i++) {\r\n\t\t\tarray[i] = i-index;\r\n\t\t}\r\n        return array;\r\n    }\r\n\r\n    static char[] getDigits(char[] objs, int index)\r\n    {\r\n\t\tint num = objs.length;\r\n\t\tint[] r = getIntegerArray(num, index);\r\n\t\tchar[] ret   = new char[num];\r\n\t\tfor(int i=0; i<num; i++) {\r\n\t\t\tret[i] = objs[ r[i] ];\r\n\t\t}\r\n        return ret;\r\n\t}\r\n\r\n    static char[] getDigits(int index) {\r\n    \treturn getDigits(DIGITS, index);\r\n\t}\r\n\r\n\tprivate static final byte hexCharToByte(char ch) {\r\n\t\tswitch (ch) {\r\n\t\tcase 48: // '0'\r\n\t\t\treturn 0;\r\n\r\n\t\tcase 49: // '1'\r\n\t\t\treturn 1;\r\n\r\n\t\tcase 50: // '2'\r\n\t\t\treturn 2;\r\n\r\n\t\tcase 51: // '3'\r\n\t\t\treturn 3;\r\n\r\n\t\tcase 52: // '4'\r\n\t\t\treturn 4;\r\n\r\n\t\tcase 53: // '5'\r\n\t\t\treturn 5;\r\n\r\n\t\tcase 54: // '6'\r\n\t\t\treturn 6;\r\n\r\n\t\tcase 55: // '7'\r\n\t\t\treturn 7;\r\n\r\n\t\tcase 56: // '8'\r\n\t\t\treturn 8;\r\n\r\n\t\tcase 57: // '9'\r\n\t\t\treturn 9;\r\n\r\n\t\tcase 97: // 'a'\r\n\t\t\treturn 10;\r\n\r\n\t\tcase 98: // 'b'\r\n\t\t\treturn 11;\r\n\r\n\t\tcase 99: // 'c'\r\n\t\t\treturn 12;\r\n\r\n\t\tcase 100: // 'd'\r\n\t\t\treturn 13;\r\n\r\n\t\tcase 101: // 'e'\r\n\t\t\treturn 14;\r\n\r\n\t\tcase 102: // 'f'\r\n\t\t\treturn 15;\r\n\r\n\t\tcase 58: // ':'\r\n\t\tcase 59: // ';'\r\n\t\tcase 60: // '<'\r\n\t\tcase 61: // '='\r\n\t\tcase 62: // '>'\r\n\t\tcase 63: // '?'\r\n\t\tcase 64: // '@'\r\n\t\tcase 65: // 'A'\r\n\t\tcase 66: // 'B'\r\n\t\tcase 67: // 'C'\r\n\t\tcase 68: // 'D'\r\n\t\tcase 69: // 'E'\r\n\t\tcase 70: // 'F'\r\n\t\tcase 71: // 'G'\r\n\t\tcase 72: // 'H'\r\n\t\tcase 73: // 'I'\r\n\t\tcase 74: // 'J'\r\n\t\tcase 75: // 'K'\r\n\t\tcase 76: // 'L'\r\n\t\tcase 77: // 'M'\r\n\t\tcase 78: // 'N'\r\n\t\tcase 79: // 'O'\r\n\t\tcase 80: // 'P'\r\n\t\tcase 81: // 'Q'\r\n\t\tcase 82: // 'R'\r\n\t\tcase 83: // 'S'\r\n\t\tcase 84: // 'T'\r\n\t\tcase 85: // 'U'\r\n\t\tcase 86: // 'V'\r\n\t\tcase 87: // 'W'\r\n\t\tcase 88: // 'X'\r\n\t\tcase 89: // 'Y'\r\n\t\tcase 90: // 'Z'\r\n\t\tcase 91: // '['\r\n\t\tcase 92: // '\\\\'\r\n\t\tcase 93: // ']'\r\n\t\tcase 94: // '^'\r\n\t\tcase 95: // '_'\r\n\t\tcase 96: // '`'\r\n\t\tdefault:\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n    ///////////////////////////////////////////////////\r\n    static protected Random random;\r\n    static\r\n    {\r\n\t\tCalendar now = Calendar.getInstance();\r\n\t\tlong seed = now.getTime().getTime();\r\n        random = new Random( seed );\r\n    }\r\n\r\n    public static int getRandom(int min, int max) {\r\n\t\tint tmin, tmax;\r\n\t\tif(max<min) {\r\n\t\t\ttmin = max;\r\n\t\t\ttmax = min;\r\n\t\t} else {\r\n\t\t\ttmin = min;\r\n\t\t\ttmax = max;\r\n\t\t}\r\n\t\tif(max==min)\r\n\t\t\treturn max;\r\n        int ret = random.nextInt(tmax-tmin+1);\r\n        return tmin + ret;\r\n    }\r\n\r\n    public static int[] getRandomArray(int n) {\r\n\t\tint[] array = new int[n];\r\n\t\tfor(int i=0; i<n; i++)\r\n\t\t{\r\n\t\t\tarray[i] =i;\r\n\t\t}\r\n\t\tfor(int i=0; i<n; i++)\r\n\t\t{\r\n\t\t\tint r = getRandom(i, (n-1));\r\n\t\t\tint tmp = array[i];\r\n\t\t\tarray[i] = array[r];\r\n\t\t\tarray[r] = tmp;\r\n\t\t}\r\n        return array;\r\n    }\r\n\r\n    public static int[] getRandomArrayArray(int n, int num) {\r\n\t\tint[] array = getRandomArray(n);\r\n\t\tint[] ret   = new int[num];\r\n\t\tfor(int i=0; i<num; i++)\r\n\t\t{\r\n\t\t\tif(i < n)\r\n\t\t\t{\r\n\t\t\t\tret[i] = array[i];\r\n\t\t\t} else\r\n\t\t\t{\r\n\t\t\t\tint r = getRandom(0, n-1);\r\n\t\t\t\tret[i] = array[r];\r\n\t\t\t}\r\n\t\t}\r\n        return ret;\r\n    }\r\n\r\n    public static <T> T[] getRandomArray(Class<T> type, T[] objs) {\r\n\t\tint n = objs.length;\r\n\t\tif(n <= 1)\r\n\t\t\treturn objs;\r\n\t\tint[] r = getRandomArray(n);\r\n\t\tfor(int i=0; i<n; i++) {\r\n\t\t\tT obj = objs[i];\r\n\t\t\tobjs[i] = objs[ r[i] ];\r\n\t\t\tobjs[ r[i] ] = obj;\r\n\t\t}\r\n        return objs;\r\n\t}\r\n/*\r\n    public static <T> T[] getRandomArray(Class<T> type, T[] objs, int num) {\r\n\t\tint n = objs.length;\r\n\t\tif(n <= 1)\r\n\t\t\treturn objs;\r\n\t\t//int[] r = getIntegerArray(n, num);\r\n\t\tT[] array = getRandomArray(type, objs);\r\n\t\tT[] ret   = new T[num];\r\n\t\tfor(int i=0; i<num; i++) {\r\n\t\t\tret[i] = array[ r[i] ];\r\n\t\t}\r\n        return objs;\r\n\t}\r\n*/\r\n    /**\r\n     *\r\n     * @param format 9: Z: z: X: *:\r\n     * @return\r\n     */\r\n    public static String getRandom(String format)\r\n    {\r\n        StringBuffer sb = new StringBuffer();\r\n        int length = format.length();\r\n        for(int i=0 ; i<length; i++ )\r\n        {\r\n\t\t\tchar f = format.charAt(i);\r\n\t        char ch;\r\n\t        if(f=='9') {\r\n           \t\tch = getDigitChar();\r\n\t\t\t} else if(f=='X') {\r\n           \t\tch = getASCIIChar();\r\n\t\t\t} else if(f=='Z') {\r\n           \t\tch = Character.toUpperCase( getASCIIChar() );\r\n\t\t\t} else if(f=='z') {\r\n           \t\tch = Character.toLowerCase( getASCIIChar() );\r\n\t\t\t} else if(f=='*') {\r\n           \t\tch = getCodeChar();\r\n\t\t\t} else {\r\n           \t\tch = f;\r\n           \t}\r\n            sb.append(ch);\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    public static boolean getRandomBoolean()\r\n    {\r\n\t\tboolean[] b = new boolean[] {true, false};\r\n\t\tint r = random.nextInt(2);\r\n        return b[r];\r\n    }\r\n\r\n    static char getASCIIChar()\r\n    {\r\n\t\tchar[] chars = new char[] {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','1','2','3','4','5','6','7','8','9','0'};\r\n\t\tint r = random.nextInt(36);\r\n\t\tchar ch;\r\n\t\tboolean b = getRandomBoolean();\r\n\t\tif(b) {\r\n\t\t\tch = Character.toUpperCase(chars[r]);\r\n\t\t} else {\r\n\t\t\tch = chars[r];\r\n\t\t}\r\n        return ch;\r\n    }\r\n\r\n    static char getDigitChar()\r\n    {\r\n\t\tint r = random.nextInt(10);\r\n\t\tchar ch = String.valueOf(r).charAt(0);\r\n        return ch;\r\n    }\r\n\r\n    static char getCodeChar()\r\n    {\r\n\t\tchar[] chars = new char[] {'!','\\\"','#','$','%','&','\\'','(',')','*','+',',','-','.','/',':',';','<','=','>','?','[','\\\\',']','^','_','{','|','}','~',' '};\r\n\t\tint r = random.nextInt(31);\r\n\t\tchar ch = chars[r];\r\n        return ch;\r\n    }\r\n}", "class_id": 0, "repo": "combivators/tiny-service", "file": "src/main/java/net/tiny/ws/auth/Codec.java", "last_update_at": "2020-01-31T18:22:30+00:00", "question_id": "0da3c430cadcb83ec8c41116b7dcb920cd7f580c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Codec {\r\n\t/**\r\n\t * All possible chars for representing a number as a String\r\n\t */\r\n\tprivate static final char[] DIGIT_ALL = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\".toCharArray();\r\n\tprivate static final char[] DIGITS    = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray();\r\n\tprivate static final String ASCII_LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n\tprivate static final String ENCODING = \"ISO-8859-1\";\r\n\r\n\t/**\r\n\t * @param text , text in plain format\r\n\t * @param algorithm   MD5 OR SHA1\r\n\t * @return hash in algorithm\r\n\t */\r\n\tprivate static String getHash(String text, String algorithm) {\r\n\t\treturn encodeString(digest(text, algorithm));\r\n\t}\r\n\r\n\tpublic static byte[] digest(String text, String algorithm) {\r\n\t\ttry {\r\n\t\t\tMessageDigest md = MessageDigest.getInstance(algorithm);\r\n\t\t\treturn md.digest(text.getBytes());\r\n\t\t} catch (NoSuchAlgorithmException ex) {\r\n\t\t\tthrow new RuntimeException(ex.getMessage(), ex);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static String md5(String txt) {\r\n\t\treturn getHash(txt, \"MD5\");\r\n\t}\r\n\r\n\tpublic static String sha1(String txt) {\r\n\t\treturn getHash(txt, \"SHA1\");\r\n\t}\r\n\r\n\tpublic static final String encodeHex(byte bytes[]) {\r\n\t\tStringBuffer sb = new StringBuffer();\r\n\t\tfor (int i = 0; i < bytes.length; ++i) {\r\n\t\t\tsb.append(Integer.toHexString((bytes[i] & 0xFF) | 0x100).substring(1, 3));\r\n\t\t}\r\n\t\treturn sb.toString();\r\n\t}\r\n\r\n\tpublic static final byte[] decodeHex(String hex) {\r\n\t\tchar chars[] = hex.toCharArray();\r\n\t\tbyte bytes[] = new byte[chars.length / 2];\r\n\t\tint byteCount = 0;\r\n\t\tfor (int i = 0; i < chars.length; i += 2) {\r\n\t\t\tint newByte = 0;\r\n\t\t\tnewByte |= hexCharToByte(chars[i]);\r\n\t\t\tnewByte <<= 4;\r\n\t\t\tnewByte |= hexCharToByte(chars[i + 1]);\r\n\t\t\tbytes[byteCount] = (byte) newByte;\r\n\t\t\tbyteCount++;\r\n\t\t}\r\n\t\treturn bytes;\r\n\t}\r\n\r\n\tpublic static String encodeBase64(String data) {\r\n\t\tbyte bytes[] = null;\r\n\t\ttry {\r\n\t\t\tbytes = data.getBytes(ENCODING);\r\n\t\t\treturn encodeBase64(bytes);\r\n\t\t} catch (UnsupportedEncodingException uee) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static String encodeBase64(byte data[]) {\r\n\t\tint len = data.length;\r\n\t\tStringBuffer ret = new StringBuffer((len / 3 + 1) * 4);\r\n\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\tint c = data[i] >> 2 & 0x3f;\r\n\t\t\tret.append(ASCII_LETTERS.charAt(c));\r\n\t\t\tc = data[i] << 4 & 0x3f;\r\n\t\t\tif (++i < len)\r\n\t\t\t\tc |= data[i] >> 4 & 0xf;\r\n\t\t\tret.append(ASCII_LETTERS.charAt(c));\r\n\t\t\tif (i < len) {\r\n\t\t\t\tc = data[i] << 2 & 0x3f;\r\n\t\t\t\tif (++i < len)\r\n\t\t\t\t\tc |= data[i] >> 6 & 3;\r\n\t\t\t\tret.append(ASCII_LETTERS.charAt(c));\r\n\t\t\t} else {\r\n\t\t\t\ti++;\r\n\t\t\t\tret.append('=');\r\n\t\t\t}\r\n\t\t\tif (i < len) {\r\n\t\t\t\tc = data[i] & 0x3f;\r\n\t\t\t\tret.append(ASCII_LETTERS.charAt(c));\r\n\t\t\t} else {\r\n\t\t\t\tret.append('=');\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn ret.toString();\r\n\t}\r\n\r\n\tpublic static String decodeBase64(String data) {\r\n\t\tbyte bytes[] = null;\r\n\t\ttry {\r\n\t\t\tbytes = data.getBytes(ENCODING);\r\n\t\t\treturn decodeBase64(bytes);\r\n\t\t} catch (UnsupportedEncodingException uee) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static String decodeBase64(byte data[]) {\r\n\t\tint len = data.length;\r\n\t\tStringBuffer ret = new StringBuffer((len * 3) / 4);\r\n\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\tint c = ASCII_LETTERS.indexOf(data[i]);\r\n\t\t\ti++;\r\n\t\t\tint c1 = ASCII_LETTERS.indexOf(data[i]);\r\n\t\t\tc = c << 2 | c1 >> 4 & 3;\r\n\t\t\tret.append((char) c);\r\n\t\t\tif (++i < len) {\r\n\t\t\t\tc = data[i];\r\n\t\t\t\tif (61 == c)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tc = ASCII_LETTERS.indexOf(c);\r\n\t\t\t\tc1 = c1 << 4 & 0xf0 | c >> 2 & 0xf;\r\n\t\t\t\tret.append((char) c1);\r\n\t\t\t}\r\n\t\t\tif (++i >= len)\r\n\t\t\t\tcontinue;\r\n\t\t\tc1 = data[i];\r\n\t\t\tif (61 == c1)\r\n\t\t\t\tbreak;\r\n\t\t\tc1 = ASCII_LETTERS.indexOf(c1);\r\n\t\t\tc = c << 6 & 0xc0 | c1;\r\n\t\t\tret.append((char) c);\r\n\t\t}\r\n\r\n\t\treturn ret.toString();\r\n\t}\r\n\r\n\tpublic static String encodeString(byte[] data) {\r\n\t\treturn encodeString(data, 0);\r\n\t}\r\n\r\n\tpublic static byte[] decodeString(String data) {\r\n\t\treturn decodeString(data, 0);\r\n\t}\r\n\r\n\tpublic static String encodeString(byte[] data, int index) {\r\n\t\treturn toBigIntegerString(new BigInteger(attachOddEven(data)), getDigits(DIGIT_ALL, index));\r\n\t}\r\n\r\n\tpublic static byte[] decodeString(String data, int index) {\r\n\t\treturn verifyOddEven(toBigInteger(data, getDigits(DIGIT_ALL, index)).toByteArray());\r\n\t}\r\n\r\n\tpublic static String encodeString(byte[] data, char[] digits) {\r\n\t\treturn toBigIntegerString(new BigInteger(attachOddEven(data)), digits);\r\n\t}\r\n\r\n\tpublic static byte[] decodeString(String data, char[] digits) {\r\n\t\treturn verifyOddEven(toBigInteger(data, digits).toByteArray());\r\n\t}\r\n\r\n\tpublic static String encodeNumbers(int[] data) {\r\n\t\tint[] value = new int[data.length + 1];\r\n\t\tvalue[0] = data.length;\r\n\t\tSystem.arraycopy(data, 0, value, 1, data.length);\r\n\t\tByteBuffer byteBuffer = ByteBuffer.allocate(value.length * 4);\r\n        IntBuffer intBuffer = byteBuffer.asIntBuffer();\r\n        intBuffer.put(value);\r\n        byte[] bytes = byteBuffer.array();\r\n\t\treturn encodeString(bytes, 0);\r\n\t}\r\n\r\n\tpublic static int[] decodeNumbers(String data) {\r\n\t\tbyte[] bytes = decodeString(data, 0);\r\n\t\tbyte[] buf = new byte[4];\r\n\t\tSystem.arraycopy(bytes, 0, buf, 0, buf.length);\r\n\t\tint size = ByteBuffer.wrap(buf).getInt();\r\n\t\tint[] values = new int[size];\r\n\t\tfor(int i=0; i<values.length; i++) {\r\n\t\t\tSystem.arraycopy(bytes, (i+1)*4, buf, 0, buf.length);\r\n\t\t\tvalues[i] = ByteBuffer.wrap(buf).getInt();\r\n\t\t}\r\n\t\treturn values;\r\n\t}\r\n\r\n\tprivate static byte[] attachOddEven(byte[] value) {\r\n\t\t// Add 1 byte odd even data on header\r\n\t\tbyte[] odd = new byte[] {(byte)(value.length%2+1)};\r\n\t\tbyte[] data = new byte[value.length + 1];\r\n\t\tSystem.arraycopy(odd, 0, data, 0, odd.length);\r\n\t\tSystem.arraycopy(value, 0, data, odd.length, value.length);\r\n\t\treturn data;\r\n\t}\r\n\r\n\tprivate static byte[] verifyOddEven(byte[] data) {\r\n\t\t//Cut 1 byte odd even data.\r\n\t\tint odd = (int)(((data.length - 1)%2) + 1);\r\n\t\tif((int)data[0] != odd) {\r\n\t\t\tthrow new IllegalArgumentException(\"Odd-even error.\");\r\n\t\t}\r\n\t\tbyte[] value = new byte[data.length-1];\r\n\t\tSystem.arraycopy(data, 1, value, 0, value.length);\r\n\t\treturn value;\r\n\t}\r\n\r\n\tprivate  static String toBigIntegerString(BigInteger big, char[] digits) {\r\n\t\tint radix = digits.length;\r\n\t\tStringBuffer sb = new StringBuffer();\r\n\t\tif (big.signum() == -1) {\r\n\t\t\tsb.append('-');\r\n\t\t}\r\n\t\tBigInteger i = new BigInteger(big.abs().toByteArray());\r\n\t\tBigInteger r = new BigInteger(Integer.toString(radix));\r\n\t\tdo {\r\n\t\t\tBigInteger dr[] = i.divideAndRemainder(r);\r\n\t\t\tsb.insert(0, digits[dr[1].intValue()]);\r\n\t\t\ti = dr[0];\r\n\t\t} while (!i.equals(BigInteger.ZERO));\r\n\t\treturn sb.toString();\r\n\t}\r\n\r\n\tprivate static BigInteger toBigInteger(String value, char[] digits)\r\n\t{\r\n\t\tint radix = digits.length;\r\n\t\tint signum = 1;\r\n\t\tBigInteger big = new BigInteger(BigInteger.ZERO.toByteArray());\r\n\t\tBigInteger r = new BigInteger(Integer.toString(radix));\r\n\t\tchar buf[] = value.toCharArray();\r\n\t\tif (buf[buf.length - 1] == '-') {\r\n\t\t\tsignum = -1;\r\n\t\t\tchar temp[] = new char[buf.length - 1];\r\n\t\t\tSystem.arraycopy(buf, 0, temp, 0, buf.length - 1);\r\n\t\t\tbuf = temp;\r\n\t\t}\r\n\t\tfor (int i = buf.length - 1; i >= 0; i--) {\r\n\t\t\tint num = binarySearch(digits, buf[i]);\r\n\t\t\tBigInteger v = new BigInteger(Integer.toString(num));\r\n\t\t\tbig = big.add(v.multiply(r.pow(buf.length - 1 - i)));\r\n\t\t}\r\n\t\tif (signum == -1)\r\n\t\t\treturn big.negate();\r\n\t\telse\r\n\t\t\treturn big;\r\n\t}\r\n\r\n\tstatic int binarySearch(char[] array, char key) {\r\n\t\tint i= 0;\r\n\t\tfor(char c : array) {\r\n\t\t\tif(key == c) {\r\n\t\t\t\treturn i;\r\n\t\t\t} else {\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n\r\n\tprivate static int[] getIntegerArray(int num, int index)\r\n    {\r\n    \tif(num < index) {\r\n    \t\tthrow new IllegalArgumentException(index + \" > \" + num );\r\n    \t}\r\n\t\tint[] array = new int[num];\r\n\t\tfor(int i=0; i<index; i++) {\r\n\t\t\tarray[i] = num - index + i;\r\n\t\t}\r\n\t\tfor(int i=index; i<num; i++) {\r\n\t\t\tarray[i] = i-index;\r\n\t\t}\r\n        return array;\r\n    }\r\n\r\n    static char[] getDigits(char[] objs, int index)\r\n    {\r\n\t\tint num = objs.length;\r\n\t\tint[] r = getIntegerArray(num, index);\r\n\t\tchar[] ret   = new char[num];\r\n\t\tfor(int i=0; i<num; i++) {\r\n\t\t\tret[i] = objs[ r[i] ];\r\n\t\t}\r\n        return ret;\r\n\t}\r\n\r\n    static char[] getDigits(int index) {\r\n    \treturn getDigits(DIGITS, index);\r\n\t}\r\n\r\n\tprivate static final byte hexCharToByte(char ch) {\r\n\t\tswitch (ch) {\r\n\t\tcase 48: // '0'\r\n\t\t\treturn 0;\r\n\r\n\t\tcase 49: // '1'\r\n\t\t\treturn 1;\r\n\r\n\t\tcase 50: // '2'\r\n\t\t\treturn 2;\r\n\r\n\t\tcase 51: // '3'\r\n\t\t\treturn 3;\r\n\r\n\t\tcase 52: // '4'\r\n\t\t\treturn 4;\r\n\r\n\t\tcase 53: // '5'\r\n\t\t\treturn 5;\r\n\r\n\t\tcase 54: // '6'\r\n\t\t\treturn 6;\r\n\r\n\t\tcase 55: // '7'\r\n\t\t\treturn 7;\r\n\r\n\t\tcase 56: // '8'\r\n\t\t\treturn 8;\r\n\r\n\t\tcase 57: // '9'\r\n\t\t\treturn 9;\r\n\r\n\t\tcase 97: // 'a'\r\n\t\t\treturn 10;\r\n\r\n\t\tcase 98: // 'b'\r\n\t\t\treturn 11;\r\n\r\n\t\tcase 99: // 'c'\r\n\t\t\treturn 12;\r\n\r\n\t\tcase 100: // 'd'\r\n\t\t\treturn 13;\r\n\r\n\t\tcase 101: // 'e'\r\n\t\t\treturn 14;\r\n\r\n\t\tcase 102: // 'f'\r\n\t\t\treturn 15;\r\n\r\n\t\tcase 58: // ':'\r\n\t\tcase 59: // ';'\r\n\t\tcase 60: // '<'\r\n\t\tcase 61: // '='\r\n\t\tcase 62: // '>'\r\n\t\tcase 63: // '?'\r\n\t\tcase 64: // '@'\r\n\t\tcase 65: // 'A'\r\n\t\tcase 66: // 'B'\r\n\t\tcase 67: // 'C'\r\n\t\tcase 68: // 'D'\r\n\t\tcase 69: // 'E'\r\n\t\tcase 70: // 'F'\r\n\t\tcase 71: // 'G'\r\n\t\tcase 72: // 'H'\r\n\t\tcase 73: // 'I'\r\n\t\tcase 74: // 'J'\r\n\t\tcase 75: // 'K'\r\n\t\tcase 76: // 'L'\r\n\t\tcase 77: // 'M'\r\n\t\tcase 78: // 'N'\r\n\t\tcase 79: // 'O'\r\n\t\tcase 80: // 'P'\r\n\t\tcase 81: // 'Q'\r\n\t\tcase 82: // 'R'\r\n\t\tcase 83: // 'S'\r\n\t\tcase 84: // 'T'\r\n\t\tcase 85: // 'U'\r\n\t\tcase 86: // 'V'\r\n\t\tcase 87: // 'W'\r\n\t\tcase 88: // 'X'\r\n\t\tcase 89: // 'Y'\r\n\t\tcase 90: // 'Z'\r\n\t\tcase 91: // '['\r\n\t\tcase 92: // '\\\\'\r\n\t\tcase 93: // ']'\r\n\t\tcase 94: // '^'\r\n\t\tcase 95: // '_'\r\n\t\tcase 96: // '`'\r\n\t\tdefault:\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n    ///////////////////////////////////////////////////\r\n    static protected Random random;\r\n    static\r\n    {\r\n\t\tCalendar now = Calendar.getInstance();\r\n\t\tlong seed = now.getTime().getTime();\r\n        random = new Random( seed );\r\n    }\r\n\r\n    public static int getRandom(int min, int max) {\r\n\t\tint tmin, tmax;\r\n\t\tif(max<min) {\r\n\t\t\ttmin = max;\r\n\t\t\ttmax = min;\r\n\t\t} else {\r\n\t\t\ttmin = min;\r\n\t\t\ttmax = max;\r\n\t\t}\r\n\t\tif(max==min)\r\n\t\t\treturn max;\r\n        int ret = random.nextInt(tmax-tmin+1);\r\n        return tmin + ret;\r\n    }\r\n\r\n    public static int[] getRandomArray(int n) {\r\n\t\tint[] array = new int[n];\r\n\t\tfor(int i=0; i<n; i++)\r\n\t\t{\r\n\t\t\tarray[i] =i;\r\n\t\t}\r\n\t\tfor(int i=0; i<n; i++)\r\n\t\t{\r\n\t\t\tint r = getRandom(i, (n-1));\r\n\t\t\tint tmp = array[i];\r\n\t\t\tarray[i] = array[r];\r\n\t\t\tarray[r] = tmp;\r\n\t\t}\r\n        return array;\r\n    }\r\n\r\n    public static int[] getRandomArrayArray(int n, int num) {\r\n\t\tint[] array = getRandomArray(n);\r\n\t\tint[] ret   = new int[num];\r\n\t\tfor(int i=0; i<num; i++)\r\n\t\t{\r\n\t\t\tif(i < n)\r\n\t\t\t{\r\n\t\t\t\tret[i] = array[i];\r\n\t\t\t} else\r\n\t\t\t{\r\n\t\t\t\tint r = getRandom(0, n-1);\r\n\t\t\t\tret[i] = array[r];\r\n\t\t\t}\r\n\t\t}\r\n        return ret;\r\n    }\r\n\r\n    public static <T> T[] getRandomArray(Class<T> type, T[] objs) {\r\n\t\tint n = objs.length;\r\n\t\tif(n <= 1)\r\n\t\t\treturn objs;\r\n\t\tint[] r = getRandomArray(n);\r\n\t\tfor(int i=0; i<n; i++) {\r\n\t\t\tT obj = objs[i];\r\n\t\t\tobjs[i] = objs[ r[i] ];\r\n\t\t\tobjs[ r[i] ] = obj;\r\n\t\t}\r\n        return objs;\r\n\t}\r\n/*\r\n    public static <T> T[] getRandomArray(Class<T> type, T[] objs, int num) {\r\n\t\tint n = objs.length;\r\n\t\tif(n <= 1)\r\n\t\t\treturn objs;\r\n\t\t//int[] r = getIntegerArray(n, num);\r\n\t\tT[] array = getRandomArray(type, objs);\r\n\t\tT[] ret   = new T[num];\r\n\t\tfor(int i=0; i<num; i++) {\r\n\t\t\tret[i] = array[ r[i] ];\r\n\t\t}\r\n        return objs;\r\n\t}\r\n*/\r\n    /**\r\n     *\r\n     * @param format 9: Z: z: X: *:\r\n     * @return\r\n     */\r\n    public static String getRandom(String format)\r\n    {\r\n        StringBuffer sb = new StringBuffer();\r\n        int length = format.length();\r\n        for(int i=0 ; i<length; i++ )\r\n        {\r\n\t\t\tchar f = format.charAt(i);\r\n\t        char ch;\r\n\t        if(f=='9') {\r\n           \t\tch = getDigitChar();\r\n\t\t\t} else if(f=='X') {\r\n           \t\tch = getASCIIChar();\r\n\t\t\t} else if(f=='Z') {\r\n           \t\tch = Character.toUpperCase( getASCIIChar() );\r\n\t\t\t} else if(f=='z') {\r\n           \t\tch = Character.toLowerCase( getASCIIChar() );\r\n\t\t\t} else if(f=='*') {\r\n           \t\tch = getCodeChar();\r\n\t\t\t} else {\r\n           \t\tch = f;\r\n           \t}\r\n            sb.append(ch);\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    public static boolean getRandomBoolean()\r\n    {\r\n\t\tboolean[] b = new boolean[] {true, false};\r\n\t\tint r = random.nextInt(2);\r\n        return b[r];\r\n    }\r\n\r\n    static char getASCIIChar()\r\n    {\r\n\t\tchar[] chars = new char[] {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','1','2','3','4','5','6','7','8','9','0'};\r\n\t\tint r = random.nextInt(36);\r\n\t\tchar ch;\r\n\t\tboolean b = getRandomBoolean();\r\n\t\tif(b) {\r\n\t\t\tch = Character.toUpperCase(chars[r]);\r\n\t\t} else {\r\n\t\t\tch = chars[r];\r\n\t\t}\r\n        return ch;\r\n    }\r\n\r\n    static char getDigitChar()\r\n    {\r\n\t\tint r = random.nextInt(10);\r\n\t\tchar ch = String.valueOf(r).charAt(0);\r\n        return ch;\r\n    }\r\n\r\n    static char getCodeChar()\r\n    {\r\n\t\tchar[] chars = new char[] {'!','\\\"','#','$','%','&','\\'','(',')','*','+',',','-','.','/',':',';','<','=','>','?','[','\\\\',']','^','_','{','|','}','~',' '};\r\n\t\tint r = random.nextInt(31);\r\n\t\tchar ch = chars[r];\r\n        return ch;\r\n    }\r\n"]]}
{"hexsha": "75dbbaf2513905b9ccb5a1e6708702fcb62ae9eb", "ext": "java", "lang": "Java", "content": "public class MapObject implements Cloneable\n{\n    private Properties properties = new Properties();\n    private ObjectGroup objectGroup;\n    private Rectangle2D.Double bounds = new Rectangle2D.Double();\n    private Shape shape = new Rectangle();\n    private String name = \"Object\";\n    private String type = \"\";\n    private String imageSource = \"\";\n    private Image image;\n    private Image scaledImage;\n    private Tile tile;\n\n    public MapObject(double x, double y, double width, double height) {\n        bounds = new Rectangle2D.Double(x, y, width, height);\n    }\n\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        MapObject clone = (MapObject) super.clone();\n        clone.bounds = (Rectangle2D.Double) bounds.clone();\n        clone.properties = (Properties) properties.clone();\n        return clone;\n    }\n\n    /**\n     * @return the object group this object is part of\n     */\n    public ObjectGroup getObjectGroup() {\n        return objectGroup;\n    }\n\n    /**\n     * Sets the object group this object is part of. Should only be called by\n     * the object group.\n     *\n     * @param objectGroup the object group this object is part of\n     */\n    public void setObjectGroup(ObjectGroup objectGroup) {\n        this.objectGroup = objectGroup;\n    }\n\n    public Rectangle2D.Double getBounds() {\n        return bounds;\n    }\n\n    public void setBounds(Rectangle2D.Double bounds) {\n        this.bounds = bounds;\n    }\n\n    public Shape getShape() {\n        return shape;\n    }\n\n    public void setShape(Shape shape) {\n        this.shape = shape;\n    }\n\n    public String getImageSource() {\n        return imageSource;\n    }\n\n    public void setImageSource(String source) {\n        if (imageSource.equals(source))\n            return;\n\n        imageSource = source;\n\n        // Attempt to read the image\n        if (imageSource.length() > 0) {\n            try {\n                image = ImageIO.read(new File(imageSource));\n            } catch (IOException e) {\n                image = null;\n            }\n        } else {\n            image = null;\n        }\n\n        scaledImage = null;\n    }\n\n    public Tile getTile(){\n        return tile;\n    }\n\n    public void setTile(Tile tile){\n        this.tile = tile;\n    }\n\n    /**\n     * Returns the image to be used when drawing this object. This image is\n     * scaled to the size of the object.\n     *\n     * @param zoom the requested zoom level of the image\n     * @return the image to be used when drawing this object\n     */\n    public Image getImage(double zoom) {\n        if (image == null)\n            return null;\n\n        final int zoomedWidth = (int) (getWidth() * zoom);\n        final int zoomedHeight = (int) (getHeight() * zoom);\n\n        if (scaledImage == null || scaledImage.getWidth(null) != zoomedWidth\n                || scaledImage.getHeight(null) != zoomedHeight)\n        {\n            scaledImage = image.getScaledInstance(zoomedWidth, zoomedHeight,\n                    Image.SCALE_SMOOTH);\n        }\n\n        return scaledImage;\n    }\n\n    public double getX() {\n        return bounds.x;\n    }\n\n    public void setX(double x) {\n        bounds.x = x;\n    }\n\n    public double getY() {\n        return bounds.y;\n    }\n\n    public void setY(double y) {\n        bounds.y = y;\n    }\n\n    public void translate(double dx, double dy) {\n        bounds.x += dx;\n        bounds.y += dy;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public double getWidth() {\n        return bounds.width;\n    }\n\n    public void setWidth(double width) {\n        bounds.width = width;\n    }\n\n    public void setHeight(double height) {\n        bounds.height = height;\n    }\n\n    public double getHeight() {\n        return bounds.height;\n    }\n\n    public Properties getProperties() {\n        return properties;\n    }\n\n    public void setProperties(Properties p) {\n        properties = p;\n    }\n\n    @Override\n    public String toString() {\n        return type + \" (\" + getX() + \",\" + getY() + \")\";\n    }\n}", "class_id": 0, "repo": "OpenTiled/OpenTiled-Java-Client", "file": "src/tiled/core/MapObject.java", "last_update_at": "2020-06-11T03:04:48+00:00", "question_id": "75dbbaf2513905b9ccb5a1e6708702fcb62ae9eb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MapObject implements Cloneable\n{\n    private Properties properties = new Properties();\n    private ObjectGroup objectGroup;\n    private Rectangle2D.Double bounds = new Rectangle2D.Double();\n    private Shape shape = new Rectangle();\n    private String name = \"Object\";\n    private String type = \"\";\n    private String imageSource = \"\";\n    private Image image;\n    private Image scaledImage;\n    private Tile tile;\n    public MapObject(double x, double y, double width, double height) {\n        bounds = new Rectangle2D.Double(x, y, width, height);\n    }\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        MapObject clone = (MapObject) super.clone();\n        clone.bounds = (Rectangle2D.Double) bounds.clone();\n        clone.properties = (Properties) properties.clone();\n        return clone;\n    }\n    /**\n     * @return the object group this object is part of\n     */\n    public ObjectGroup getObjectGroup() {\n        return objectGroup;\n    }\n    /**\n     * Sets the object group this object is part of. Should only be called by\n     * the object group.\n     *\n     * @param objectGroup the object group this object is part of\n     */\n    public void setObjectGroup(ObjectGroup objectGroup) {\n        this.objectGroup = objectGroup;\n    }\n    public Rectangle2D.Double getBounds() {\n        return bounds;\n    }\n    public void setBounds(Rectangle2D.Double bounds) {\n        this.bounds = bounds;\n    }\n    public Shape getShape() {\n        return shape;\n    }\n    public void setShape(Shape shape) {\n        this.shape = shape;\n    }\n    public String getImageSource() {\n        return imageSource;\n    }\n    public void setImageSource(String source) {\n        if (imageSource.equals(source))\n            return;\n        imageSource = source;\n        // Attempt to read the image\n        if (imageSource.length() > 0) {\n            try {\n                image = ImageIO.read(new File(imageSource));\n            } catch (IOException e) {\n                image = null;\n            }\n        } else {\n            image = null;\n        }\n        scaledImage = null;\n    }\n    public Tile getTile(){\n        return tile;\n    }\n    public void setTile(Tile tile){\n        this.tile = tile;\n    }\n    /**\n     * Returns the image to be used when drawing this object. This image is\n     * scaled to the size of the object.\n     *\n     * @param zoom the requested zoom level of the image\n     * @return the image to be used when drawing this object\n     */\n    public Image getImage(double zoom) {\n        if (image == null)\n            return null;\n        final int zoomedWidth = (int) (getWidth() * zoom);\n        final int zoomedHeight = (int) (getHeight() * zoom);\n        if (scaledImage == null || scaledImage.getWidth(null) != zoomedWidth\n                || scaledImage.getHeight(null) != zoomedHeight)\n        {\n            scaledImage = image.getScaledInstance(zoomedWidth, zoomedHeight,\n                    Image.SCALE_SMOOTH);\n        }\n        return scaledImage;\n    }\n    public double getX() {\n        return bounds.x;\n    }\n    public void setX(double x) {\n        bounds.x = x;\n    }\n    public double getY() {\n        return bounds.y;\n    }\n    public void setY(double y) {\n        bounds.y = y;\n    }\n    public void translate(double dx, double dy) {\n        bounds.x += dx;\n        bounds.y += dy;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public String getType() {\n        return type;\n    }\n    public void setType(String type) {\n        this.type = type;\n    }\n    public double getWidth() {\n        return bounds.width;\n    }\n    public void setWidth(double width) {\n        bounds.width = width;\n    }\n    public void setHeight(double height) {\n        bounds.height = height;\n    }\n    public double getHeight() {\n        return bounds.height;\n    }\n    public Properties getProperties() {\n        return properties;\n    }\n    public void setProperties(Properties p) {\n        properties = p;\n    }\n    @Override\n    public String toString() {\n        return type + \" (\" + getX() + \",\" + getY() + \")\";\n    }\n"]]}
{"hexsha": "6fe74af6c99647a56667d387a66aa6551b413ffd", "ext": "java", "lang": "Java", "content": "public class SpecialFood extends ItemFood\n{\n    protected int[] hunger;\n    protected float[] saturation;\n    protected String[] unlocalizedNames;\n    protected String[] iconNames;\n    protected IIcon[] icons;\n\n    public SpecialFood(int[] hunger, float[] saturation, String[] textureNames, String[] iconNames)\n    {\n        super(0, 0, false);\n        this.hunger = hunger;\n        this.saturation = saturation;\n        this.unlocalizedNames = textureNames;\n        this.iconNames = iconNames;\n    }\n\n    @Override\n    public ItemStack onEaten (ItemStack stack, World world, EntityPlayer player)\n    {\n        stack.stackSize--;\n        int damage = stack.getItemDamage();\n        player.getFoodStats().addStats(hunger[damage], saturation[damage]);\n        world.playSoundAtEntity(player, \"random.burp\", 0.5F, world.rand.nextFloat() * 0.1F + 0.9F);\n        this.onFoodEaten(stack, world, player);\n        return stack;\n    }\n\n    @Override\n    @SideOnly(Side.CLIENT)\n    public IIcon getIconFromDamage (int meta)\n    {\n        return icons[0];\n    }\n\n    @SideOnly(Side.CLIENT)\n    @Override\n    public void registerIcons (IIconRegister iconRegister)\n    {\n        this.icons = new IIcon[iconNames.length];\n\n        for (int i = 0; i < this.icons.length; ++i)\n        {\n            this.icons[i] = iconRegister.registerIcon(\"tinker:\" + iconNames[i]);\n        }\n    }\n\n    @Override\n    public String getUnlocalizedName (ItemStack stack)\n    {\n        int arr = MathHelper.clamp_int(stack.getItemDamage(), 0, unlocalizedNames.length);\n        return getUnlocalizedName() + \".\" + unlocalizedNames[arr];\n    }\n\n    @Override\n    public void getSubItems (Item b, CreativeTabs tab, List list)\n    {\n        for (int i = 0; i < unlocalizedNames.length; i++)\n            list.add(new ItemStack(b, 1, i));\n    }\n}", "class_id": 0, "repo": "Mrkwtkr/TinkersConstruct", "file": "src/main/java/tconstruct/world/items/SpecialFood.java", "last_update_at": "2020-01-20T20:24:40+00:00", "question_id": "6fe74af6c99647a56667d387a66aa6551b413ffd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SpecialFood extends ItemFood\n{\n    protected int[] hunger;\n    protected float[] saturation;\n    protected String[] unlocalizedNames;\n    protected String[] iconNames;\n    protected IIcon[] icons;\n    public SpecialFood(int[] hunger, float[] saturation, String[] textureNames, String[] iconNames)\n    {\n        super(0, 0, false);\n        this.hunger = hunger;\n        this.saturation = saturation;\n        this.unlocalizedNames = textureNames;\n        this.iconNames = iconNames;\n    }\n    @Override\n    public ItemStack onEaten (ItemStack stack, World world, EntityPlayer player)\n    {\n        stack.stackSize--;\n        int damage = stack.getItemDamage();\n        player.getFoodStats().addStats(hunger[damage], saturation[damage]);\n        world.playSoundAtEntity(player, \"random.burp\", 0.5F, world.rand.nextFloat() * 0.1F + 0.9F);\n        this.onFoodEaten(stack, world, player);\n        return stack;\n    }\n    @Override\n    @SideOnly(Side.CLIENT)\n    public IIcon getIconFromDamage (int meta)\n    {\n        return icons[0];\n    }\n    @SideOnly(Side.CLIENT)\n    @Override\n    public void registerIcons (IIconRegister iconRegister)\n    {\n        this.icons = new IIcon[iconNames.length];\n        for (int i = 0; i < this.icons.length; ++i)\n        {\n            this.icons[i] = iconRegister.registerIcon(\"tinker:\" + iconNames[i]);\n        }\n    }\n    @Override\n    public String getUnlocalizedName (ItemStack stack)\n    {\n        int arr = MathHelper.clamp_int(stack.getItemDamage(), 0, unlocalizedNames.length);\n        return getUnlocalizedName() + \".\" + unlocalizedNames[arr];\n    }\n    @Override\n    public void getSubItems (Item b, CreativeTabs tab, List list)\n    {\n        for (int i = 0; i < unlocalizedNames.length; i++)\n            list.add(new ItemStack(b, 1, i));\n    }\n"]]}
{"hexsha": "f00cefb6c7ab5e31256f7952232e39c564f67481", "ext": "java", "lang": "Java", "content": "public class MinterSDK {\n    @SuppressWarnings(\"unused\")\n    public final static String DEFAULT_COIN = BuildConfig.DEFAULT_COIN_NAME;\n    @SuppressWarnings(\"unused\")\n    public final static BigInteger DEFAULT_COIN_ID = BigInteger.ZERO;\n    public final static String PREFIX_ADDRESS = \"Mx\";\n    public final static String PREFIX_TX = \"Mt\";\n    public final static String PREFIX_CHECK = \"Mc\";\n    public final static String PREFIX_PUBLIC_KEY = \"Mp\";\n    private static MinterSDK INSTANCE;\n\n    private MinterSDK() {\n    }\n\n    public static void initialize() throws NativeLoadException {\n        if (INSTANCE != null) {\n            return;\n        }\n\n        INSTANCE = new MinterSDK();\n\n        NativeSecp256k1.init();\n        NativeBip39.init();\n\n        if (!NativeSecp256k1.isEnabled()) {\n            throw new NativeLoadException(NativeSecp256k1.getError());\n        }\n\n        if (!NativeBip39.isEnabled()) {\n            throw new NativeLoadException(NativeBip39.getError());\n        }\n\n        Security.insertProviderAt(new BouncyCastleProvider(), 1);\n    }\n\n    /**\n     * Use this if you are catched {@link UnsatisfiedLinkError} and loaded native libraries by yourself, if not, it will crash at unexpected place\n     * @param enabledNativeLibs\n     */\n    public static void setEnabledNativeLibs(boolean enabledNativeLibs) {\n        NativeSecp256k1.setEnabled(enabledNativeLibs);\n        NativeBip39.setEnabled(enabledNativeLibs);\n    }\n\n    public static MinterSDK getInstance() {\n        if (INSTANCE == null) {\n            throw new IllegalStateException(\"Did you forget to call MinterSDK.initialize()?\");\n        }\n        return INSTANCE;\n    }\n\n\n}", "class_id": 0, "repo": "MinterTeam/minter-android-core", "file": "src/main/java/network/minter/core/MinterSDK.java", "last_update_at": "2020-11-18T05:20:52+00:00", "question_id": "f00cefb6c7ab5e31256f7952232e39c564f67481", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MinterSDK {\n    @SuppressWarnings(\"unused\")\n    public final static String DEFAULT_COIN = BuildConfig.DEFAULT_COIN_NAME;\n    @SuppressWarnings(\"unused\")\n    public final static BigInteger DEFAULT_COIN_ID = BigInteger.ZERO;\n    public final static String PREFIX_ADDRESS = \"Mx\";\n    public final static String PREFIX_TX = \"Mt\";\n    public final static String PREFIX_CHECK = \"Mc\";\n    public final static String PREFIX_PUBLIC_KEY = \"Mp\";\n    private static MinterSDK INSTANCE;\n    private MinterSDK() {\n    }\n    public static void initialize() throws NativeLoadException {\n        if (INSTANCE != null) {\n            return;\n        }\n        INSTANCE = new MinterSDK();\n        NativeSecp256k1.init();\n        NativeBip39.init();\n        if (!NativeSecp256k1.isEnabled()) {\n            throw new NativeLoadException(NativeSecp256k1.getError());\n        }\n        if (!NativeBip39.isEnabled()) {\n            throw new NativeLoadException(NativeBip39.getError());\n        }\n        Security.insertProviderAt(new BouncyCastleProvider(), 1);\n    }\n    /**\n     * Use this if you are catched {@link UnsatisfiedLinkError} and loaded native libraries by yourself, if not, it will crash at unexpected place\n     * @param enabledNativeLibs\n     */\n    public static void setEnabledNativeLibs(boolean enabledNativeLibs) {\n        NativeSecp256k1.setEnabled(enabledNativeLibs);\n        NativeBip39.setEnabled(enabledNativeLibs);\n    }\n    public static MinterSDK getInstance() {\n        if (INSTANCE == null) {\n            throw new IllegalStateException(\"Did you forget to call MinterSDK.initialize()?\");\n        }\n        return INSTANCE;\n    }\n"]]}
{"hexsha": "10b8e273f487ec2151d7e0443e9ab5aea275390e", "ext": "java", "lang": "Java", "content": "public class AVRSymbol {\n\n    public final String symbol;\n    public final int value;\n\n    AVRSymbol(String sym, int v) {\n        symbol = sym;\n        value = v;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public int getEncodingValue() {\n        return value;\n    }\n\n    public static class GPR extends AVRSymbol {\n\n        private static HashMap<String, GPR> set = new HashMap<String, GPR>();\n\n        private static GPR newGPR(String n, int v) {\n            GPR obj = new GPR(n, v);\n            set.put(n, obj);\n            return obj;\n        }\n\n        GPR(String sym, int v) {\n            super(sym, v);\n        }\n\n        public static final GPR R0 = newGPR(\"r0\", 0);\n        public static final GPR R1 = newGPR(\"r1\", 1);\n        public static final GPR R2 = newGPR(\"r2\", 2);\n        public static final GPR R3 = newGPR(\"r3\", 3);\n        public static final GPR R4 = newGPR(\"r4\", 4);\n        public static final GPR R5 = newGPR(\"r5\", 5);\n        public static final GPR R6 = newGPR(\"r6\", 6);\n        public static final GPR R7 = newGPR(\"r7\", 7);\n        public static final GPR R8 = newGPR(\"r8\", 8);\n        public static final GPR R9 = newGPR(\"r9\", 9);\n        public static final GPR R10 = newGPR(\"r10\", 10);\n        public static final GPR R11 = newGPR(\"r11\", 11);\n        public static final GPR R12 = newGPR(\"r12\", 12);\n        public static final GPR R13 = newGPR(\"r13\", 13);\n        public static final GPR R14 = newGPR(\"r14\", 14);\n        public static final GPR R15 = newGPR(\"r15\", 15);\n        public static final GPR R16 = newGPR(\"r16\", 16);\n        public static final GPR R17 = newGPR(\"r17\", 17);\n        public static final GPR R18 = newGPR(\"r18\", 18);\n        public static final GPR R19 = newGPR(\"r19\", 19);\n        public static final GPR R20 = newGPR(\"r20\", 20);\n        public static final GPR R21 = newGPR(\"r21\", 21);\n        public static final GPR R22 = newGPR(\"r22\", 22);\n        public static final GPR R23 = newGPR(\"r23\", 23);\n        public static final GPR R24 = newGPR(\"r24\", 24);\n        public static final GPR R25 = newGPR(\"r25\", 25);\n        public static final GPR R26 = newGPR(\"r26\", 26);\n        public static final GPR R27 = newGPR(\"r27\", 27);\n        public static final GPR R28 = newGPR(\"r28\", 28);\n        public static final GPR R29 = newGPR(\"r29\", 29);\n        public static final GPR R30 = newGPR(\"r30\", 30);\n        public static final GPR R31 = newGPR(\"r31\", 31);\n    }\n\n    public static GPR get_GPR(String name) {\n        return (GPR)GPR.set.get(name);\n    }\n\n    public static class ADR extends AVRSymbol {\n\n        private static HashMap<String, ADR> set = new HashMap<String, ADR>();\n\n        private static ADR newADR(String n, int v) {\n            ADR obj = new ADR(n, v);\n            set.put(n, obj);\n            return obj;\n        }\n\n        ADR(String sym, int v) {\n            super(sym, v);\n        }\n\n        public static final ADR X = newADR(\"X\", 26);\n        public static final ADR Y = newADR(\"Y\", 28);\n        public static final ADR Z = newADR(\"Z\", 30);\n    }\n\n    public static ADR get_ADR(String name) {\n        return (ADR)ADR.set.get(name);\n    }\n\n    public static class HGPR extends AVRSymbol.GPR {\n\n        public final int encoding;\n\n        public int getEncodingValue() {\n            return encoding;\n        }\n\n        private static HashMap<String, HGPR> set = new HashMap<String, HGPR>();\n\n        private static HGPR newHGPR(String n, int v, int ev) {\n            HGPR obj = new HGPR(n, v, ev);\n            set.put(n, obj);\n            return obj;\n        }\n\n        HGPR(String sym, int v, int ev) {\n            super(sym, v);\n            encoding = ev;\n        }\n\n        public static final HGPR R16 = newHGPR(\"r16\", 16, 0);\n        public static final HGPR R17 = newHGPR(\"r17\", 17, 1);\n        public static final HGPR R18 = newHGPR(\"r18\", 18, 2);\n        public static final HGPR R19 = newHGPR(\"r19\", 19, 3);\n        public static final HGPR R20 = newHGPR(\"r20\", 20, 4);\n        public static final HGPR R21 = newHGPR(\"r21\", 21, 5);\n        public static final HGPR R22 = newHGPR(\"r22\", 22, 6);\n        public static final HGPR R23 = newHGPR(\"r23\", 23, 7);\n        public static final HGPR R24 = newHGPR(\"r24\", 24, 8);\n        public static final HGPR R25 = newHGPR(\"r25\", 25, 9);\n        public static final HGPR R26 = newHGPR(\"r26\", 26, 10);\n        public static final HGPR R27 = newHGPR(\"r27\", 27, 11);\n        public static final HGPR R28 = newHGPR(\"r28\", 28, 12);\n        public static final HGPR R29 = newHGPR(\"r29\", 29, 13);\n        public static final HGPR R30 = newHGPR(\"r30\", 30, 14);\n        public static final HGPR R31 = newHGPR(\"r31\", 31, 15);\n    }\n\n    public static HGPR get_HGPR(String name) {\n        return (HGPR)HGPR.set.get(name);\n    }\n\n    public static class EGPR extends AVRSymbol.GPR {\n\n        public final int encoding;\n\n        public int getEncodingValue() {\n            return encoding;\n        }\n\n        private static HashMap<String, EGPR> set = new HashMap<String, EGPR>();\n\n        private static EGPR newEGPR(String n, int v, int ev) {\n            EGPR obj = new EGPR(n, v, ev);\n            set.put(n, obj);\n            return obj;\n        }\n\n        EGPR(String sym, int v, int ev) {\n            super(sym, v);\n            encoding = ev;\n        }\n\n        public static final EGPR R0 = newEGPR(\"r0\", 0, 0);\n        public static final EGPR R2 = newEGPR(\"r2\", 2, 1);\n        public static final EGPR R4 = newEGPR(\"r4\", 4, 2);\n        public static final EGPR R6 = newEGPR(\"r6\", 6, 3);\n        public static final EGPR R8 = newEGPR(\"r8\", 8, 4);\n        public static final EGPR R10 = newEGPR(\"r10\", 10, 5);\n        public static final EGPR R12 = newEGPR(\"r12\", 12, 6);\n        public static final EGPR R14 = newEGPR(\"r14\", 14, 7);\n        public static final EGPR R16 = newEGPR(\"r16\", 16, 8);\n        public static final EGPR R18 = newEGPR(\"r18\", 18, 9);\n        public static final EGPR R20 = newEGPR(\"r20\", 20, 10);\n        public static final EGPR R22 = newEGPR(\"r22\", 22, 11);\n        public static final EGPR R24 = newEGPR(\"r24\", 24, 12);\n        public static final EGPR R26 = newEGPR(\"r26\", 26, 13);\n        public static final EGPR R28 = newEGPR(\"r28\", 28, 14);\n        public static final EGPR R30 = newEGPR(\"r30\", 30, 15);\n    }\n\n    public static EGPR get_EGPR(String name) {\n        return (EGPR)EGPR.set.get(name);\n    }\n\n    public static class MGPR extends AVRSymbol.GPR {\n\n        public final int encoding;\n\n        public int getEncodingValue() {\n            return encoding;\n        }\n\n        private static HashMap<String, MGPR> set = new HashMap<String, MGPR>();\n\n        private static MGPR newMGPR(String n, int v, int ev) {\n            MGPR obj = new MGPR(n, v, ev);\n            set.put(n, obj);\n            return obj;\n        }\n\n        MGPR(String sym, int v, int ev) {\n            super(sym, v);\n            encoding = ev;\n        }\n\n        public static final MGPR R16 = newMGPR(\"r16\", 16, 0);\n        public static final MGPR R17 = newMGPR(\"r17\", 17, 1);\n        public static final MGPR R18 = newMGPR(\"r18\", 18, 2);\n        public static final MGPR R19 = newMGPR(\"r19\", 19, 3);\n        public static final MGPR R20 = newMGPR(\"r20\", 20, 4);\n        public static final MGPR R21 = newMGPR(\"r21\", 21, 5);\n        public static final MGPR R22 = newMGPR(\"r22\", 22, 6);\n        public static final MGPR R23 = newMGPR(\"r23\", 23, 7);\n    }\n\n    public static MGPR get_MGPR(String name) {\n        return (MGPR)MGPR.set.get(name);\n    }\n\n    public static class YZ extends AVRSymbol.ADR {\n\n        public final int encoding;\n\n        public int getEncodingValue() {\n            return encoding;\n        }\n\n        private static HashMap<String, YZ> set = new HashMap<String, YZ>();\n\n        private static YZ newYZ(String n, int v, int ev) {\n            YZ obj = new YZ(n, v, ev);\n            set.put(n, obj);\n            return obj;\n        }\n\n        YZ(String sym, int v, int ev) {\n            super(sym, v);\n            encoding = ev;\n        }\n\n        public static final YZ Y = newYZ(\"Y\", 28, 1);\n        public static final YZ Z = newYZ(\"Z\", 30, 0);\n    }\n\n    public static YZ get_YZ(String name) {\n        return (YZ)YZ.set.get(name);\n    }\n\n    public static class RDL extends AVRSymbol.GPR {\n\n        public final int encoding;\n\n        public int getEncodingValue() {\n            return encoding;\n        }\n\n        private static HashMap<String, RDL> set = new HashMap<String, RDL>();\n\n        private static RDL newRDL(String n, int v, int ev) {\n            RDL obj = new RDL(n, v, ev);\n            set.put(n, obj);\n            return obj;\n        }\n\n        RDL(String sym, int v, int ev) {\n            super(sym, v);\n            encoding = ev;\n        }\n\n        public static final RDL R24 = newRDL(\"r24\", 24, 0);\n        public static final RDL R26 = newRDL(\"r26\", 26, 1);\n        public static final RDL R28 = newRDL(\"r28\", 28, 2);\n        public static final RDL R30 = newRDL(\"r30\", 30, 3);\n    }\n\n    public static RDL get_RDL(String name) {\n        return (RDL)RDL.set.get(name);\n    }\n\n    public static class R0 extends AVRSymbol.GPR {\n\n        public final int encoding;\n\n        public int getEncodingValue() {\n            return encoding;\n        }\n\n        private static HashMap<String, R0> set = new HashMap<String, R0>();\n\n        private static R0 newR0(String n, int v, int ev) {\n            R0 obj = new R0(n, v, ev);\n            set.put(n, obj);\n            return obj;\n        }\n\n        R0(String sym, int v, int ev) {\n            super(sym, v);\n            encoding = ev;\n        }\n\n        public static final R0 R0 = newR0(\"r0\", 0, 0);\n    }\n\n    public static R0 get_R0(String name) {\n        return (R0)R0.set.get(name);\n    }\n\n    public static class RZ extends AVRSymbol.ADR {\n\n        public final int encoding;\n\n        public int getEncodingValue() {\n            return encoding;\n        }\n\n        private static HashMap<String, RZ> set = new HashMap<String, RZ>();\n\n        private static RZ newRZ(String n, int v, int ev) {\n            RZ obj = new RZ(n, v, ev);\n            set.put(n, obj);\n            return obj;\n        }\n\n        RZ(String sym, int v, int ev) {\n            super(sym, v);\n            encoding = ev;\n        }\n\n        public static final RZ Z = newRZ(\"Z\", 30, 0);\n    }\n\n    public static RZ get_RZ(String name) {\n        return (RZ)RZ.set.get(name);\n    }\n\n}", "class_id": 0, "repo": "comawill/avrora", "file": "src/avrora/arch/avr/AVRSymbol.java", "last_update_at": "2020-03-24T10:37:38+00:00", "question_id": "10b8e273f487ec2151d7e0443e9ab5aea275390e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AVRSymbol {\n    public final String symbol;\n    public final int value;\n    AVRSymbol(String sym, int v) {\n        symbol = sym;\n        value = v;\n    }\n    public int getValue() {\n        return value;\n    }\n    public int getEncodingValue() {\n        return value;\n    }\n    public static class GPR extends AVRSymbol {\n        private static HashMap<String, GPR> set = new HashMap<String, GPR>();\n        private static GPR newGPR(String n, int v) {\n            GPR obj = new GPR(n, v);\n            set.put(n, obj);\n            return obj;\n        }\n        GPR(String sym, int v) {\n            super(sym, v);\n        }\n        public static final GPR R0 = newGPR(\"r0\", 0);\n        public static final GPR R1 = newGPR(\"r1\", 1);\n        public static final GPR R2 = newGPR(\"r2\", 2);\n        public static final GPR R3 = newGPR(\"r3\", 3);\n        public static final GPR R4 = newGPR(\"r4\", 4);\n        public static final GPR R5 = newGPR(\"r5\", 5);\n        public static final GPR R6 = newGPR(\"r6\", 6);\n        public static final GPR R7 = newGPR(\"r7\", 7);\n        public static final GPR R8 = newGPR(\"r8\", 8);\n        public static final GPR R9 = newGPR(\"r9\", 9);\n        public static final GPR R10 = newGPR(\"r10\", 10);\n        public static final GPR R11 = newGPR(\"r11\", 11);\n        public static final GPR R12 = newGPR(\"r12\", 12);\n        public static final GPR R13 = newGPR(\"r13\", 13);\n        public static final GPR R14 = newGPR(\"r14\", 14);\n        public static final GPR R15 = newGPR(\"r15\", 15);\n        public static final GPR R16 = newGPR(\"r16\", 16);\n        public static final GPR R17 = newGPR(\"r17\", 17);\n        public static final GPR R18 = newGPR(\"r18\", 18);\n        public static final GPR R19 = newGPR(\"r19\", 19);\n        public static final GPR R20 = newGPR(\"r20\", 20);\n        public static final GPR R21 = newGPR(\"r21\", 21);\n        public static final GPR R22 = newGPR(\"r22\", 22);\n        public static final GPR R23 = newGPR(\"r23\", 23);\n        public static final GPR R24 = newGPR(\"r24\", 24);\n        public static final GPR R25 = newGPR(\"r25\", 25);\n        public static final GPR R26 = newGPR(\"r26\", 26);\n        public static final GPR R27 = newGPR(\"r27\", 27);\n        public static final GPR R28 = newGPR(\"r28\", 28);\n        public static final GPR R29 = newGPR(\"r29\", 29);\n        public static final GPR R30 = newGPR(\"r30\", 30);\n        public static final GPR R31 = newGPR(\"r31\", 31);\n    }\n    public static GPR get_GPR(String name) {\n        return (GPR)GPR.set.get(name);\n    }\n    public static class ADR extends AVRSymbol {\n        private static HashMap<String, ADR> set = new HashMap<String, ADR>();\n        private static ADR newADR(String n, int v) {\n            ADR obj = new ADR(n, v);\n            set.put(n, obj);\n            return obj;\n        }\n        ADR(String sym, int v) {\n            super(sym, v);\n        }\n        public static final ADR X = newADR(\"X\", 26);\n        public static final ADR Y = newADR(\"Y\", 28);\n        public static final ADR Z = newADR(\"Z\", 30);\n    }\n    public static ADR get_ADR(String name) {\n        return (ADR)ADR.set.get(name);\n    }\n    public static class HGPR extends AVRSymbol.GPR {\n        public final int encoding;\n        public int getEncodingValue() {\n            return encoding;\n        }\n        private static HashMap<String, HGPR> set = new HashMap<String, HGPR>();\n        private static HGPR newHGPR(String n, int v, int ev) {\n            HGPR obj = new HGPR(n, v, ev);\n            set.put(n, obj);\n            return obj;\n        }\n        HGPR(String sym, int v, int ev) {\n            super(sym, v);\n            encoding = ev;\n        }\n        public static final HGPR R16 = newHGPR(\"r16\", 16, 0);\n        public static final HGPR R17 = newHGPR(\"r17\", 17, 1);\n        public static final HGPR R18 = newHGPR(\"r18\", 18, 2);\n        public static final HGPR R19 = newHGPR(\"r19\", 19, 3);\n        public static final HGPR R20 = newHGPR(\"r20\", 20, 4);\n        public static final HGPR R21 = newHGPR(\"r21\", 21, 5);\n        public static final HGPR R22 = newHGPR(\"r22\", 22, 6);\n        public static final HGPR R23 = newHGPR(\"r23\", 23, 7);\n        public static final HGPR R24 = newHGPR(\"r24\", 24, 8);\n        public static final HGPR R25 = newHGPR(\"r25\", 25, 9);\n        public static final HGPR R26 = newHGPR(\"r26\", 26, 10);\n        public static final HGPR R27 = newHGPR(\"r27\", 27, 11);\n        public static final HGPR R28 = newHGPR(\"r28\", 28, 12);\n        public static final HGPR R29 = newHGPR(\"r29\", 29, 13);\n        public static final HGPR R30 = newHGPR(\"r30\", 30, 14);\n        public static final HGPR R31 = newHGPR(\"r31\", 31, 15);\n    }\n    public static HGPR get_HGPR(String name) {\n        return (HGPR)HGPR.set.get(name);\n    }\n    public static class EGPR extends AVRSymbol.GPR {\n        public final int encoding;\n        public int getEncodingValue() {\n            return encoding;\n        }\n        private static HashMap<String, EGPR> set = new HashMap<String, EGPR>();\n        private static EGPR newEGPR(String n, int v, int ev) {\n            EGPR obj = new EGPR(n, v, ev);\n            set.put(n, obj);\n            return obj;\n        }\n        EGPR(String sym, int v, int ev) {\n            super(sym, v);\n            encoding = ev;\n        }\n        public static final EGPR R0 = newEGPR(\"r0\", 0, 0);\n        public static final EGPR R2 = newEGPR(\"r2\", 2, 1);\n        public static final EGPR R4 = newEGPR(\"r4\", 4, 2);\n        public static final EGPR R6 = newEGPR(\"r6\", 6, 3);\n        public static final EGPR R8 = newEGPR(\"r8\", 8, 4);\n        public static final EGPR R10 = newEGPR(\"r10\", 10, 5);\n        public static final EGPR R12 = newEGPR(\"r12\", 12, 6);\n        public static final EGPR R14 = newEGPR(\"r14\", 14, 7);\n        public static final EGPR R16 = newEGPR(\"r16\", 16, 8);\n        public static final EGPR R18 = newEGPR(\"r18\", 18, 9);\n        public static final EGPR R20 = newEGPR(\"r20\", 20, 10);\n        public static final EGPR R22 = newEGPR(\"r22\", 22, 11);\n        public static final EGPR R24 = newEGPR(\"r24\", 24, 12);\n        public static final EGPR R26 = newEGPR(\"r26\", 26, 13);\n        public static final EGPR R28 = newEGPR(\"r28\", 28, 14);\n        public static final EGPR R30 = newEGPR(\"r30\", 30, 15);\n    }\n    public static EGPR get_EGPR(String name) {\n        return (EGPR)EGPR.set.get(name);\n    }\n    public static class MGPR extends AVRSymbol.GPR {\n        public final int encoding;\n        public int getEncodingValue() {\n            return encoding;\n        }\n        private static HashMap<String, MGPR> set = new HashMap<String, MGPR>();\n        private static MGPR newMGPR(String n, int v, int ev) {\n            MGPR obj = new MGPR(n, v, ev);\n            set.put(n, obj);\n            return obj;\n        }\n        MGPR(String sym, int v, int ev) {\n            super(sym, v);\n            encoding = ev;\n        }\n        public static final MGPR R16 = newMGPR(\"r16\", 16, 0);\n        public static final MGPR R17 = newMGPR(\"r17\", 17, 1);\n        public static final MGPR R18 = newMGPR(\"r18\", 18, 2);\n        public static final MGPR R19 = newMGPR(\"r19\", 19, 3);\n        public static final MGPR R20 = newMGPR(\"r20\", 20, 4);\n        public static final MGPR R21 = newMGPR(\"r21\", 21, 5);\n        public static final MGPR R22 = newMGPR(\"r22\", 22, 6);\n        public static final MGPR R23 = newMGPR(\"r23\", 23, 7);\n    }\n    public static MGPR get_MGPR(String name) {\n        return (MGPR)MGPR.set.get(name);\n    }\n    public static class YZ extends AVRSymbol.ADR {\n        public final int encoding;\n        public int getEncodingValue() {\n            return encoding;\n        }\n        private static HashMap<String, YZ> set = new HashMap<String, YZ>();\n        private static YZ newYZ(String n, int v, int ev) {\n            YZ obj = new YZ(n, v, ev);\n            set.put(n, obj);\n            return obj;\n        }\n        YZ(String sym, int v, int ev) {\n            super(sym, v);\n            encoding = ev;\n        }\n        public static final YZ Y = newYZ(\"Y\", 28, 1);\n        public static final YZ Z = newYZ(\"Z\", 30, 0);\n    }\n    public static YZ get_YZ(String name) {\n        return (YZ)YZ.set.get(name);\n    }\n    public static class RDL extends AVRSymbol.GPR {\n        public final int encoding;\n        public int getEncodingValue() {\n            return encoding;\n        }\n        private static HashMap<String, RDL> set = new HashMap<String, RDL>();\n        private static RDL newRDL(String n, int v, int ev) {\n            RDL obj = new RDL(n, v, ev);\n            set.put(n, obj);\n            return obj;\n        }\n        RDL(String sym, int v, int ev) {\n            super(sym, v);\n            encoding = ev;\n        }\n        public static final RDL R24 = newRDL(\"r24\", 24, 0);\n        public static final RDL R26 = newRDL(\"r26\", 26, 1);\n        public static final RDL R28 = newRDL(\"r28\", 28, 2);\n        public static final RDL R30 = newRDL(\"r30\", 30, 3);\n    }\n    public static RDL get_RDL(String name) {\n        return (RDL)RDL.set.get(name);\n    }\n    public static class R0 extends AVRSymbol.GPR {\n        public final int encoding;\n        public int getEncodingValue() {\n            return encoding;\n        }\n        private static HashMap<String, R0> set = new HashMap<String, R0>();\n        private static R0 newR0(String n, int v, int ev) {\n            R0 obj = new R0(n, v, ev);\n            set.put(n, obj);\n            return obj;\n        }\n        R0(String sym, int v, int ev) {\n            super(sym, v);\n            encoding = ev;\n        }\n        public static final R0 R0 = newR0(\"r0\", 0, 0);\n    }\n    public static R0 get_R0(String name) {\n        return (R0)R0.set.get(name);\n    }\n    public static class RZ extends AVRSymbol.ADR {\n        public final int encoding;\n        public int getEncodingValue() {\n            return encoding;\n        }\n        private static HashMap<String, RZ> set = new HashMap<String, RZ>();\n        private static RZ newRZ(String n, int v, int ev) {\n            RZ obj = new RZ(n, v, ev);\n            set.put(n, obj);\n            return obj;\n        }\n        RZ(String sym, int v, int ev) {\n            super(sym, v);\n            encoding = ev;\n        }\n        public static final RZ Z = newRZ(\"Z\", 30, 0);\n    }\n    public static RZ get_RZ(String name) {\n        return (RZ)RZ.set.get(name);\n    }\n"]]}
{"hexsha": "8b7c1370f4e3490d080d8f8bb611a8ce21de42a9", "ext": "java", "lang": "Java", "content": "public class SpringDemo8 {\n\n\t@Test\n\tpublic void demo1() {\n\t\tApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext8.xml\");\n\t\tProductService productService = (ProductService) context.getBean(\"productService\");\n\t\tproductService.save();\n\n\t\t((ClassPathXmlApplicationContext) context).close();\n\t}\n\n\t@Test\n\tpublic void demo2() {\n\t\tApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext8.xml\");\n\t\tOrderService service = (OrderService) context.getBean(\"orderService\");\n\t\tservice.save();\n\n\t\t((ClassPathXmlApplicationContext) context).close();\n\t}\n}", "class_id": 0, "repo": "huruiyi/Java201808", "file": "spring-basic/src/main/java/com/example/Spring/demo8/SpringDemo8.java", "last_update_at": "2020-09-27T02:40:43+00:00", "question_id": "8b7c1370f4e3490d080d8f8bb611a8ce21de42a9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SpringDemo8 {\n\t@Test\n\tpublic void demo1() {\n\t\tApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext8.xml\");\n\t\tProductService productService = (ProductService) context.getBean(\"productService\");\n\t\tproductService.save();\n\t\t((ClassPathXmlApplicationContext) context).close();\n\t}\n\t@Test\n\tpublic void demo2() {\n\t\tApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext8.xml\");\n\t\tOrderService service = (OrderService) context.getBean(\"orderService\");\n\t\tservice.save();\n\t\t((ClassPathXmlApplicationContext) context).close();\n\t}\n"]]}
{"hexsha": "1f64c40df7f6f68c27f9cc59b2e40bba2f38aa12", "ext": "java", "lang": "Java", "content": "@ObfuscatedName(\"it\")\n@Implements(\"VarbitDefinition\")\npublic class VarbitDefinition extends DualNode {\n\t@ObfuscatedName(\"c\")\n\t@ObfuscatedSignature(\n\t\tsignature = \"Lhz;\"\n\t)\n\t@Export(\"VarbitDefinition_archive\")\n\tpublic static AbstractArchive VarbitDefinition_archive;\n\t@ObfuscatedName(\"x\")\n\t@ObfuscatedSignature(\n\t\tsignature = \"Let;\"\n\t)\n\t@Export(\"VarbitDefinition_cached\")\n\tpublic static EvictingDualNodeHashTable VarbitDefinition_cached;\n\t@ObfuscatedName(\"a\")\n\t@Export(\"BZip2Decompressor_block\")\n\tstatic int[] BZip2Decompressor_block;\n\t@ObfuscatedName(\"t\")\n\t@ObfuscatedGetter(\n\t\tintValue = -1892165457\n\t)\n\t@Export(\"baseVar\")\n\tpublic int baseVar;\n\t@ObfuscatedName(\"g\")\n\t@ObfuscatedGetter(\n\t\tintValue = 810805195\n\t)\n\t@Export(\"startBit\")\n\tpublic int startBit;\n\t@ObfuscatedName(\"l\")\n\t@ObfuscatedGetter(\n\t\tintValue = 1776174069\n\t)\n\t@Export(\"endBit\")\n\tpublic int endBit;\n\n\tstatic {\n\t\tVarbitDefinition_cached = new EvictingDualNodeHashTable(64);\n\t}\n\n\tVarbitDefinition() {\n\t}\n\n\t@ObfuscatedName(\"x\")\n\t@ObfuscatedSignature(\n\t\tsignature = \"(Lkz;I)V\",\n\t\tgarbageValue = \"-1056617467\"\n\t)\n\t@Export(\"decode\")\n\tvoid decode(Buffer var1) {\n\t\twhile (true) {\n\t\t\tint var2 = var1.readUnsignedByte();\n\t\t\tif (var2 == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.decodeNext(var1, var2);\n\t\t}\n\t}\n\n\t@ObfuscatedName(\"t\")\n\t@ObfuscatedSignature(\n\t\tsignature = \"(Lkz;IB)V\",\n\t\tgarbageValue = \"26\"\n\t)\n\t@Export(\"decodeNext\")\n\tvoid decodeNext(Buffer var1, int var2) {\n\t\tif (var2 == 1) {\n\t\t\tthis.baseVar = var1.readUnsignedShort();\n\t\t\tthis.startBit = var1.readUnsignedByte();\n\t\t\tthis.endBit = var1.readUnsignedByte();\n\t\t}\n\n\t}\n\n\t@ObfuscatedName(\"g\")\n\t@ObfuscatedSignature(\n\t\tsignature = \"(IIII)V\",\n\t\tgarbageValue = \"944071832\"\n\t)\n\tstatic final void method4499(int var0, int var1, int var2) {\n\t\tint var3;\n\t\tfor (var3 = 0; var3 < 8; ++var3) {\n\t\t\tfor (int var4 = 0; var4 < 8; ++var4) {\n\t\t\t\tTiles.Tiles_heights[var0][var3 + var1][var4 + var2] = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (var1 > 0) {\n\t\t\tfor (var3 = 1; var3 < 8; ++var3) {\n\t\t\t\tTiles.Tiles_heights[var0][var1][var3 + var2] = Tiles.Tiles_heights[var0][var1 - 1][var3 + var2];\n\t\t\t}\n\t\t}\n\n\t\tif (var2 > 0) {\n\t\t\tfor (var3 = 1; var3 < 8; ++var3) {\n\t\t\t\tTiles.Tiles_heights[var0][var3 + var1][var2] = Tiles.Tiles_heights[var0][var3 + var1][var2 - 1];\n\t\t\t}\n\t\t}\n\n\t\tif (var1 > 0 && Tiles.Tiles_heights[var0][var1 - 1][var2] != 0) {\n\t\t\tTiles.Tiles_heights[var0][var1][var2] = Tiles.Tiles_heights[var0][var1 - 1][var2];\n\t\t} else if (var2 > 0 && Tiles.Tiles_heights[var0][var1][var2 - 1] != 0) {\n\t\t\tTiles.Tiles_heights[var0][var1][var2] = Tiles.Tiles_heights[var0][var1][var2 - 1];\n\t\t} else if (var1 > 0 && var2 > 0 && Tiles.Tiles_heights[var0][var1 - 1][var2 - 1] != 0) {\n\t\t\tTiles.Tiles_heights[var0][var1][var2] = Tiles.Tiles_heights[var0][var1 - 1][var2 - 1];\n\t\t}\n\n\t}\n}", "class_id": 0, "repo": "ItsAsta/runelite", "file": "runescape-client/src/main/java/VarbitDefinition.java", "last_update_at": "2020-03-05T10:12:08+00:00", "question_id": "1f64c40df7f6f68c27f9cc59b2e40bba2f38aa12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ObfuscatedName(\"it\")\n@Implements(\"VarbitDefinition\")\npublic class VarbitDefinition extends DualNode {\n\t@ObfuscatedName(\"c\")\n\t@ObfuscatedSignature(\n\t\tsignature = \"Lhz;\"\n\t)\n\t@Export(\"VarbitDefinition_archive\")\n\tpublic static AbstractArchive VarbitDefinition_archive;\n\t@ObfuscatedName(\"x\")\n\t@ObfuscatedSignature(\n\t\tsignature = \"Let;\"\n\t)\n\t@Export(\"VarbitDefinition_cached\")\n\tpublic static EvictingDualNodeHashTable VarbitDefinition_cached;\n\t@ObfuscatedName(\"a\")\n\t@Export(\"BZip2Decompressor_block\")\n\tstatic int[] BZip2Decompressor_block;\n\t@ObfuscatedName(\"t\")\n\t@ObfuscatedGetter(\n\t\tintValue = -1892165457\n\t)\n\t@Export(\"baseVar\")\n\tpublic int baseVar;\n\t@ObfuscatedName(\"g\")\n\t@ObfuscatedGetter(\n\t\tintValue = 810805195\n\t)\n\t@Export(\"startBit\")\n\tpublic int startBit;\n\t@ObfuscatedName(\"l\")\n\t@ObfuscatedGetter(\n\t\tintValue = 1776174069\n\t)\n\t@Export(\"endBit\")\n\tpublic int endBit;\n\tstatic {\n\t\tVarbitDefinition_cached = new EvictingDualNodeHashTable(64);\n\t}\n\tVarbitDefinition() {\n\t}\n\t@ObfuscatedName(\"x\")\n\t@ObfuscatedSignature(\n\t\tsignature = \"(Lkz;I)V\",\n\t\tgarbageValue = \"-1056617467\"\n\t)\n\t@Export(\"decode\")\n\tvoid decode(Buffer var1) {\n\t\twhile (true) {\n\t\t\tint var2 = var1.readUnsignedByte();\n\t\t\tif (var2 == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.decodeNext(var1, var2);\n\t\t}\n\t}\n\t@ObfuscatedName(\"t\")\n\t@ObfuscatedSignature(\n\t\tsignature = \"(Lkz;IB)V\",\n\t\tgarbageValue = \"26\"\n\t)\n\t@Export(\"decodeNext\")\n\tvoid decodeNext(Buffer var1, int var2) {\n\t\tif (var2 == 1) {\n\t\t\tthis.baseVar = var1.readUnsignedShort();\n\t\t\tthis.startBit = var1.readUnsignedByte();\n\t\t\tthis.endBit = var1.readUnsignedByte();\n\t\t}\n\t}\n\t@ObfuscatedName(\"g\")\n\t@ObfuscatedSignature(\n\t\tsignature = \"(IIII)V\",\n\t\tgarbageValue = \"944071832\"\n\t)\n\tstatic final void method4499(int var0, int var1, int var2) {\n\t\tint var3;\n\t\tfor (var3 = 0; var3 < 8; ++var3) {\n\t\t\tfor (int var4 = 0; var4 < 8; ++var4) {\n\t\t\t\tTiles.Tiles_heights[var0][var3 + var1][var4 + var2] = 0;\n\t\t\t}\n\t\t}\n\t\tif (var1 > 0) {\n\t\t\tfor (var3 = 1; var3 < 8; ++var3) {\n\t\t\t\tTiles.Tiles_heights[var0][var1][var3 + var2] = Tiles.Tiles_heights[var0][var1 - 1][var3 + var2];\n\t\t\t}\n\t\t}\n\t\tif (var2 > 0) {\n\t\t\tfor (var3 = 1; var3 < 8; ++var3) {\n\t\t\t\tTiles.Tiles_heights[var0][var3 + var1][var2] = Tiles.Tiles_heights[var0][var3 + var1][var2 - 1];\n\t\t\t}\n\t\t}\n\t\tif (var1 > 0 && Tiles.Tiles_heights[var0][var1 - 1][var2] != 0) {\n\t\t\tTiles.Tiles_heights[var0][var1][var2] = Tiles.Tiles_heights[var0][var1 - 1][var2];\n\t\t} else if (var2 > 0 && Tiles.Tiles_heights[var0][var1][var2 - 1] != 0) {\n\t\t\tTiles.Tiles_heights[var0][var1][var2] = Tiles.Tiles_heights[var0][var1][var2 - 1];\n\t\t} else if (var1 > 0 && var2 > 0 && Tiles.Tiles_heights[var0][var1 - 1][var2 - 1] != 0) {\n\t\t\tTiles.Tiles_heights[var0][var1][var2] = Tiles.Tiles_heights[var0][var1 - 1][var2 - 1];\n\t\t}\n\t}\n"]]}
{"hexsha": "d487db49a3830a9f3761971957cad5fe5d8ef01c", "ext": "java", "lang": "Java", "content": "@Service\n@Transactional\npublic class RoomTaskService {\n\n    private final Logger log = LoggerFactory.getLogger(RoomTaskService.class);\n\n    private final RoomTaskRepository roomTaskRepository;\n\n    private final RoomTaskMapper roomTaskMapper;\n\n    private final RoomService roomService;\n\n    private final NotificationService notificationService;\n\n    public RoomTaskService(RoomTaskRepository roomTaskRepository, RoomTaskMapper roomTaskMapper, NotificationService notificationService, RoomService roomService) {\n        this.roomTaskRepository = roomTaskRepository;\n        this.roomTaskMapper = roomTaskMapper;\n        this.notificationService = notificationService;\n        this.roomService = roomService;\n    }\n\n    /**\n     * Save a roomTask.\n     *\n     * @param roomTaskDTO the entity to save\n     * @return the persisted entity\n     */\n    public RoomTaskDTO save(RoomTaskDTO roomTaskDTO) {\n        log.debug(\"Request to save RoomTask : {}\", roomTaskDTO);\n        RoomTask roomTask = roomTaskMapper.toEntity(roomTaskDTO);\n\n        boolean sendNotification = roomTask.getId() == null;\n\n        roomTask = roomTaskRepository.save(roomTask);\n\n        if(sendNotification)\n            sendNotificationRoomies(roomTask, true);\n\n        RoomTaskDTO result = roomTaskMapper.toDto(roomTask);\n        return result;\n    }\n\n    /**\n     * Get all the roomTasks.\n     *\n     * @param pageable the pagination information\n     * @return the list of entities\n     */\n    @Transactional(readOnly = true)\n    public Page<RoomTaskDTO> findAll(Pageable pageable) {\n        log.debug(\"Request to get all RoomTasks\");\n        return roomTaskRepository.findAll(pageable)\n            .map(roomTaskMapper::toDto);\n    }\n\n\n    /**\n     * Get one roomTask by id.\n     *\n     * @param id the id of the entity\n     * @return the entity\n     */\n    @Transactional(readOnly = true)\n    public Optional<RoomTaskDTO> findOne(Long id) {\n        log.debug(\"Request to get RoomTask : {}\", id);\n        return roomTaskRepository.findById(id)\n            .map(roomTaskMapper::toDto);\n    }\n\n    /**\n     * Delete the roomTask by id.\n     *\n     * @param id the id of the entity\n     */\n    public void delete(Long id) {\n        log.debug(\"Request to delete RoomTask : {}\", id);\n        roomTaskRepository.deleteById(id);\n    }\n\n    @Transactional(readOnly = true)\n    public List<RoomTaskDTO> findAllByRoom(Long id) {\n        log.debug(\"Request to get all RoomTasks by room id\");\n        return roomTaskMapper.toDto(roomTaskRepository.findByRoomId(id));\n    }\n\n\n    /**\n     * Task that sends task notifications every 30 minutes.\n     * Scheduled task.\n     */\n    @Scheduled(cron = \"0 0/30 * * * *\")\n    public void scheduledRoomTasksNotification(){\n        log.info(\"Room Tasks notification execution: {}\", Instant.now().toString());\n\n        Instant startTime = Instant.now().plus(Duration.ofMinutes(59));\n        Instant endTime = Instant.now().plus(Duration.ofMinutes(91));\n\n        List<RoomTask> roomTasks = roomTaskRepository.findByDeadlineBetween(startTime, endTime);\n\n        log.info(\"{} tasks found between {}, {}\", roomTasks.size(), startTime.toString(), endTime.toString());\n\n        for(RoomTask roomTask : roomTasks)\n            sendNotificationRoomies(roomTask, false);\n    }\n\n    private void sendNotificationRoomies(RoomTask roomTask, Boolean isNew) {\n        try {\n            if(roomTask.getState().equals(RoomTaskState.COMPLETED))\n                return;\n\n            RoomDTO room = roomService.findOne(roomTask.getRoom().getId()).get();\n\n            //Notify room owner\n            sendNotification(roomTask, room.getOwnerId(), isNew);\n\n            //Notify roomies\n            for (RoomieDTO roomie : room.getRoomies())\n                    sendNotification(roomTask, roomie.getId(), isNew);\n\n        } catch (NullPointerException e){\n            log.error(\"Error sending notification: {}\", e.getMessage());\n        }\n    }\n\n    private void sendNotification(RoomTask roomTask, Long recipientId, boolean isNew){\n        NotificationDTO notification = new NotificationDTO();\n        notification.setCreated(Instant.now());\n        notification.setState(NotificationState.NEW);\n        notification.setType(NotificationType.TODO);\n        notification.setEntityId(roomTask.getId());\n        notification.setRecipientId(recipientId);\n\n        if(isNew)\n            notification.setTitle(\"A new task has been added to the room!\");\n        else\n            notification.setTitle(\"One of your room tasks needs to be completed soon!\");\n\n        notification.setBody(String.format(\"%s, deadline: %s UTC\", roomTask.getTitle(), roomTask.getDeadline().toString()));\n\n        notificationService.save(notification);\n    }\n}", "class_id": 0, "repo": "afermon/roomie-web", "file": "src/main/java/com/cosmicode/roomie/service/RoomTaskService.java", "last_update_at": "2020-06-15T18:16:37+00:00", "question_id": "d487db49a3830a9f3761971957cad5fe5d8ef01c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\n@Transactional\npublic class RoomTaskService {\n    private final Logger log = LoggerFactory.getLogger(RoomTaskService.class);\n    private final RoomTaskRepository roomTaskRepository;\n    private final RoomTaskMapper roomTaskMapper;\n    private final RoomService roomService;\n    private final NotificationService notificationService;\n    public RoomTaskService(RoomTaskRepository roomTaskRepository, RoomTaskMapper roomTaskMapper, NotificationService notificationService, RoomService roomService) {\n        this.roomTaskRepository = roomTaskRepository;\n        this.roomTaskMapper = roomTaskMapper;\n        this.notificationService = notificationService;\n        this.roomService = roomService;\n    }\n    /**\n     * Save a roomTask.\n     *\n     * @param roomTaskDTO the entity to save\n     * @return the persisted entity\n     */\n    public RoomTaskDTO save(RoomTaskDTO roomTaskDTO) {\n        log.debug(\"Request to save RoomTask : {}\", roomTaskDTO);\n        RoomTask roomTask = roomTaskMapper.toEntity(roomTaskDTO);\n        boolean sendNotification = roomTask.getId() == null;\n        roomTask = roomTaskRepository.save(roomTask);\n        if(sendNotification)\n            sendNotificationRoomies(roomTask, true);\n        RoomTaskDTO result = roomTaskMapper.toDto(roomTask);\n        return result;\n    }\n    /**\n     * Get all the roomTasks.\n     *\n     * @param pageable the pagination information\n     * @return the list of entities\n     */\n    @Transactional(readOnly = true)\n    public Page<RoomTaskDTO> findAll(Pageable pageable) {\n        log.debug(\"Request to get all RoomTasks\");\n        return roomTaskRepository.findAll(pageable)\n            .map(roomTaskMapper::toDto);\n    }\n    /**\n     * Get one roomTask by id.\n     *\n     * @param id the id of the entity\n     * @return the entity\n     */\n    @Transactional(readOnly = true)\n    public Optional<RoomTaskDTO> findOne(Long id) {\n        log.debug(\"Request to get RoomTask : {}\", id);\n        return roomTaskRepository.findById(id)\n            .map(roomTaskMapper::toDto);\n    }\n    /**\n     * Delete the roomTask by id.\n     *\n     * @param id the id of the entity\n     */\n    public void delete(Long id) {\n        log.debug(\"Request to delete RoomTask : {}\", id);\n        roomTaskRepository.deleteById(id);\n    }\n    @Transactional(readOnly = true)\n    public List<RoomTaskDTO> findAllByRoom(Long id) {\n        log.debug(\"Request to get all RoomTasks by room id\");\n        return roomTaskMapper.toDto(roomTaskRepository.findByRoomId(id));\n    }\n    /**\n     * Task that sends task notifications every 30 minutes.\n     * Scheduled task.\n     */\n    @Scheduled(cron = \"0 0/30 * * * *\")\n    public void scheduledRoomTasksNotification(){\n        log.info(\"Room Tasks notification execution: {}\", Instant.now().toString());\n        Instant startTime = Instant.now().plus(Duration.ofMinutes(59));\n        Instant endTime = Instant.now().plus(Duration.ofMinutes(91));\n        List<RoomTask> roomTasks = roomTaskRepository.findByDeadlineBetween(startTime, endTime);\n        log.info(\"{} tasks found between {}, {}\", roomTasks.size(), startTime.toString(), endTime.toString());\n        for(RoomTask roomTask : roomTasks)\n            sendNotificationRoomies(roomTask, false);\n    }\n    private void sendNotificationRoomies(RoomTask roomTask, Boolean isNew) {\n        try {\n            if(roomTask.getState().equals(RoomTaskState.COMPLETED))\n                return;\n            RoomDTO room = roomService.findOne(roomTask.getRoom().getId()).get();\n            //Notify room owner\n            sendNotification(roomTask, room.getOwnerId(), isNew);\n            //Notify roomies\n            for (RoomieDTO roomie : room.getRoomies())\n                    sendNotification(roomTask, roomie.getId(), isNew);\n        } catch (NullPointerException e){\n            log.error(\"Error sending notification: {}\", e.getMessage());\n        }\n    }\n    private void sendNotification(RoomTask roomTask, Long recipientId, boolean isNew){\n        NotificationDTO notification = new NotificationDTO();\n        notification.setCreated(Instant.now());\n        notification.setState(NotificationState.NEW);\n        notification.setType(NotificationType.TODO);\n        notification.setEntityId(roomTask.getId());\n        notification.setRecipientId(recipientId);\n        if(isNew)\n            notification.setTitle(\"A new task has been added to the room!\");\n        else\n            notification.setTitle(\"One of your room tasks needs to be completed soon!\");\n        notification.setBody(String.format(\"%s, deadline: %s UTC\", roomTask.getTitle(), roomTask.getDeadline().toString()));\n        notificationService.save(notification);\n    }\n"]]}
{"hexsha": "b6959d90635d8f83441a52883f47993e723e69d6", "ext": "java", "lang": "Java", "content": "public class CrashHandler implements UncaughtExceptionHandler {\n\n    public static final String INTENT_ACTION_RESTART_ACTIVITY = \"com.dudu.crash\";\n\n    public static final String TAG = \"CrashHandler\";\n\n    private static CrashHandler mInstance;\n\n    private Context mContext;\n\n    private UncaughtExceptionHandler mDefaultHandler;\n\n    private CrashHandler() {\n\n    }\n\n    public static CrashHandler getInstance() {\n        if (mInstance == null) {\n            mInstance = new CrashHandler();\n        }\n\n        return mInstance;\n    }\n\n    private static void killCurrentProcess() {\n        android.os.Process.killProcess(android.os.Process.myPid());\n        System.exit(10);\n    }\n\n    public static Class<? extends Activity> getLauncherActivity(Context context) {\n        Intent intent = context.getPackageManager().getLaunchIntentForPackage(context.getPackageName());\n        if (intent != null) {\n            try {\n                return (Class<? extends Activity>) Class.forName(intent.getComponent().getClassName());\n            } catch (ClassNotFoundException e) {\n            }\n        }\n        return null;\n    }\n\n    private static Class<? extends Activity> getRestartActivityClassWithIntentFilter(Context context) {\n        List<ResolveInfo> resolveInfos = context.getPackageManager().queryIntentActivities(\n                new Intent().setAction(INTENT_ACTION_RESTART_ACTIVITY),\n                PackageManager.GET_RESOLVED_FILTER);\n\n        for (ResolveInfo info : resolveInfos) {\n            if (info.activityInfo.packageName.equalsIgnoreCase(context.getPackageName())) {\n                try {\n                    return (Class<? extends Activity>) Class.forName(info.activityInfo.name);\n                } catch (ClassNotFoundException e) {\n                    //Should not happen, print it to the log!\n                    Log.e(\"TAG\", \"Failed when resolving the restart activity class via intent filter, stack trace follows!\", e);\n                }\n            }\n        }\n\n        return null;\n    }\n\n    public void restartApplicationWithIntent(Intent intent) {\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n        mContext.startActivity(intent);\n        killCurrentProcess();\n    }\n\n    private void restartApp() {\n        restartApplicationWithIntent(new Intent(mContext, CrashHandler.getLauncherActivity(mContext)));\n    }\n\n    public void init(Context context) {\n        mContext = context.getApplicationContext();\n        mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();\n        Thread.setDefaultUncaughtExceptionHandler(this);\n    }\n\n    @Override\n    public void uncaughtException(Thread thread, Throwable ex) {\n//        try {\n//            Class<? extends Activity> restartClass = getRestartActivityClassWithIntentFilter(mContext);\n//            if (restartClass != null) {\n//                Intent intent = new Intent(mContext, restartClass);\n//                intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);//\u53bb\u6389\u52a8\u753b\u6548\u679c\n//                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n//                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);\n//                Bundle args = new Bundle();\n//                args.putString(\"msg\", getMsgFromThrowable(ex));\n//                intent.putExtras(args);\n//                mContext.startActivity(intent);\n//            }\n//        } catch (Exception e) {\n//            e.printStackTrace();\n//        }\n\n\n//        getRestartActivityClassWithIntentFilter(mContext);\n\n        ex.printStackTrace();\n        restartApp();\n\n        if (mDefaultHandler != null) {\n            mDefaultHandler.uncaughtException(thread, ex);\n        } else {\n            android.os.Process.killProcess(android.os.Process.myPid());\n            System.exit(10);\n        }\n    }\n\n    private String getMsgFromThrowable(Throwable ex) {\n        StringWriter stringWriter = new StringWriter();\n        ex.printStackTrace(new PrintWriter(stringWriter));\n        return stringWriter.toString();\n    }\n}", "class_id": 0, "repo": "davyjoneswang/AndroidMediaKit", "file": "app/src/main/java/org/greenleaf/mav/CrashHandler.java", "last_update_at": "2020-10-26T06:53:27+00:00", "question_id": "b6959d90635d8f83441a52883f47993e723e69d6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CrashHandler implements UncaughtExceptionHandler {\n    public static final String INTENT_ACTION_RESTART_ACTIVITY = \"com.dudu.crash\";\n    public static final String TAG = \"CrashHandler\";\n    private static CrashHandler mInstance;\n    private Context mContext;\n    private UncaughtExceptionHandler mDefaultHandler;\n    private CrashHandler() {\n    }\n    public static CrashHandler getInstance() {\n        if (mInstance == null) {\n            mInstance = new CrashHandler();\n        }\n        return mInstance;\n    }\n    private static void killCurrentProcess() {\n        android.os.Process.killProcess(android.os.Process.myPid());\n        System.exit(10);\n    }\n    public static Class<? extends Activity> getLauncherActivity(Context context) {\n        Intent intent = context.getPackageManager().getLaunchIntentForPackage(context.getPackageName());\n        if (intent != null) {\n            try {\n                return (Class<? extends Activity>) Class.forName(intent.getComponent().getClassName());\n            } catch (ClassNotFoundException e) {\n            }\n        }\n        return null;\n    }\n    private static Class<? extends Activity> getRestartActivityClassWithIntentFilter(Context context) {\n        List<ResolveInfo> resolveInfos = context.getPackageManager().queryIntentActivities(\n                new Intent().setAction(INTENT_ACTION_RESTART_ACTIVITY),\n                PackageManager.GET_RESOLVED_FILTER);\n        for (ResolveInfo info : resolveInfos) {\n            if (info.activityInfo.packageName.equalsIgnoreCase(context.getPackageName())) {\n                try {\n                    return (Class<? extends Activity>) Class.forName(info.activityInfo.name);\n                } catch (ClassNotFoundException e) {\n                    //Should not happen, print it to the log!\n                    Log.e(\"TAG\", \"Failed when resolving the restart activity class via intent filter, stack trace follows!\", e);\n                }\n            }\n        }\n        return null;\n    }\n    public void restartApplicationWithIntent(Intent intent) {\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n        mContext.startActivity(intent);\n        killCurrentProcess();\n    }\n    private void restartApp() {\n        restartApplicationWithIntent(new Intent(mContext, CrashHandler.getLauncherActivity(mContext)));\n    }\n    public void init(Context context) {\n        mContext = context.getApplicationContext();\n        mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();\n        Thread.setDefaultUncaughtExceptionHandler(this);\n    }\n    @Override\n    public void uncaughtException(Thread thread, Throwable ex) {\n//        try {\n//            Class<? extends Activity> restartClass = getRestartActivityClassWithIntentFilter(mContext);\n//            if (restartClass != null) {\n//                Intent intent = new Intent(mContext, restartClass);\n//                intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);//\u53bb\u6389\u52a8\u753b\u6548\u679c\n//                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n//                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);\n//                Bundle args = new Bundle();\n//                args.putString(\"msg\", getMsgFromThrowable(ex));\n//                intent.putExtras(args);\n//                mContext.startActivity(intent);\n//            }\n//        } catch (Exception e) {\n//            e.printStackTrace();\n//        }\n//        getRestartActivityClassWithIntentFilter(mContext);\n        ex.printStackTrace();\n        restartApp();\n        if (mDefaultHandler != null) {\n            mDefaultHandler.uncaughtException(thread, ex);\n        } else {\n            android.os.Process.killProcess(android.os.Process.myPid());\n            System.exit(10);\n        }\n    }\n    private String getMsgFromThrowable(Throwable ex) {\n        StringWriter stringWriter = new StringWriter();\n        ex.printStackTrace(new PrintWriter(stringWriter));\n        return stringWriter.toString();\n    }\n"]]}
{"hexsha": "e016aad04f98aba884732f9d3248fe553d62ea84", "ext": "java", "lang": "Java", "content": "@Extension(\n        name = \"create\",\n        namespace = \"file\",\n        description = \"Create a file or a folder in the given location\",\n        parameters = {\n                @Parameter(\n                        name = \"uri\",\n                        description = \"Absolute file path which needs to be created.\",\n                        type = DataType.STRING,\n                        dynamic = true\n                ),\n                @Parameter(\n                        name = \"is.directory\",\n                        description = \"This flag is used when creating file path is a directory\",\n                        type = DataType.BOOL,\n                        dynamic = true,\n                        optional = true,\n                        defaultValue = \"false\"\n                ),\n                @Parameter(\n                        name = \"file.system.options\",\n                        description = \"The file options in key:value pairs separated by commas. \\n\" +\n                                \"eg:'USER_DIR_IS_ROOT:false,PASSIVE_MODE:true,AVOID_PERMISSION_CHECK:true,\" +\n                                \"IDENTITY:file://demo/.ssh/id_rsa,IDENTITY_PASS_PHRASE:wso2carbon'\\n\" +\n                                \"Note: when IDENTITY is used, use a RSA PRIVATE KEY\",\n                        type = DataType.STRING,\n                        optional = true,\n                        defaultValue = \"<Empty_String>\"\n                )\n        },\n        parameterOverloads = {\n                @ParameterOverload(\n                        parameterNames = {\"uri\"}\n                ),\n                @ParameterOverload(\n                        parameterNames = {\"uri\", \"is.directory\"}\n                ),\n                @ParameterOverload(\n                        parameterNames = {\"uri\", \"is.directory\", \"file.system.options\"}\n                )\n        },\n        examples = {\n                @Example(\n                        syntax = \"from CreateFileStream#file:create('/User/wso2/source/test.txt', false)\",\n                        description = \"Creates a file in the given path with the name of 'test.txt'.\"\n                ),\n                @Example(\n                        syntax = \"from CreateFileStream#file:create('/User/wso2/source/', true)\",\n                        description = \"Creates a folder in the given path with the name of 'source'.\"\n                )\n        }\n)\npublic class FileCreateExtension extends StreamFunctionProcessor {\n    private static final Logger log = Logger.getLogger(FileCreateExtension.class);\n    private int inputExecutorLength;\n    private String fileSystemOptions = null;\n\n    @Override\n    protected StateFactory init(AbstractDefinition inputDefinition, ExpressionExecutor[] attributeExpressionExecutors,\n                                ConfigReader configReader, boolean outputExpectsExpiredEvents,\n                                SiddhiQueryContext siddhiQueryContext) {\n        inputExecutorLength = attributeExpressionExecutors.length;\n        if (inputExecutorLength == 3 &&\n                attributeExpressionExecutors[2] instanceof ConstantExpressionExecutor) {\n            fileSystemOptions = ((ConstantExpressionExecutor) attributeExpressionExecutors[2]).getValue().toString();\n        }\n        return null;\n    }\n\n    @Override\n    public List<Attribute> getReturnAttributes() {\n        return new ArrayList<>();\n    }\n\n    @Override\n    public ProcessingMode getProcessingMode() {\n        return ProcessingMode.BATCH;\n    }\n\n    @Override\n    protected Object[] process(Object[] data) {\n        String fileSourcePath = (String) data[0];\n        boolean isDirectory;\n        if (inputExecutorLength >= 2) {\n            isDirectory = (Boolean) data[1];\n        } else {\n            isDirectory = false;\n        }\n        FileObject rootFileObject = Utils.getFileObject(fileSourcePath, fileSystemOptions);\n        try {\n            if (isDirectory) {\n                rootFileObject.createFolder();\n            } else {\n                rootFileObject.createFile();\n            }\n        } catch (FileSystemException e) {\n            throw new SiddhiAppRuntimeException(\"Failure occurred when creating the file \" + fileSourcePath, e);\n        }\n        return new Object[0];\n    }\n\n    @Override\n    protected Object[] process(Object data) {\n        return new Object[0];\n    }\n\n    @Override\n    public void start() {\n\n    }\n\n    @Override\n    public void stop() {\n\n    }\n}", "class_id": 0, "repo": "dnwick/siddhi-io-file", "file": "component/src/main/java/io/siddhi/extension/execution/file/FileCreateExtension.java", "last_update_at": "2020-06-24T05:02:47+00:00", "question_id": "e016aad04f98aba884732f9d3248fe553d62ea84", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Extension(\n        name = \"create\",\n        namespace = \"file\",\n        description = \"Create a file or a folder in the given location\",\n        parameters = {\n                @Parameter(\n                        name = \"uri\",\n                        description = \"Absolute file path which needs to be created.\",\n                        type = DataType.STRING,\n                        dynamic = true\n                ),\n                @Parameter(\n                        name = \"is.directory\",\n                        description = \"This flag is used when creating file path is a directory\",\n                        type = DataType.BOOL,\n                        dynamic = true,\n                        optional = true,\n                        defaultValue = \"false\"\n                ),\n                @Parameter(\n                        name = \"file.system.options\",\n                        description = \"The file options in key:value pairs separated by commas. \\n\" +\n                                \"eg:'USER_DIR_IS_ROOT:false,PASSIVE_MODE:true,AVOID_PERMISSION_CHECK:true,\" +\n                                \"IDENTITY:file://demo/.ssh/id_rsa,IDENTITY_PASS_PHRASE:wso2carbon'\\n\" +\n                                \"Note: when IDENTITY is used, use a RSA PRIVATE KEY\",\n                        type = DataType.STRING,\n                        optional = true,\n                        defaultValue = \"<Empty_String>\"\n                )\n        },\n        parameterOverloads = {\n                @ParameterOverload(\n                        parameterNames = {\"uri\"}\n                ),\n                @ParameterOverload(\n                        parameterNames = {\"uri\", \"is.directory\"}\n                ),\n                @ParameterOverload(\n                        parameterNames = {\"uri\", \"is.directory\", \"file.system.options\"}\n                )\n        },\n        examples = {\n                @Example(\n                        syntax = \"from CreateFileStream#file:create('/User/wso2/source/test.txt', false)\",\n                        description = \"Creates a file in the given path with the name of 'test.txt'.\"\n                ),\n                @Example(\n                        syntax = \"from CreateFileStream#file:create('/User/wso2/source/', true)\",\n                        description = \"Creates a folder in the given path with the name of 'source'.\"\n                )\n        }\n)\npublic class FileCreateExtension extends StreamFunctionProcessor {\n    private static final Logger log = Logger.getLogger(FileCreateExtension.class);\n    private int inputExecutorLength;\n    private String fileSystemOptions = null;\n    @Override\n    protected StateFactory init(AbstractDefinition inputDefinition, ExpressionExecutor[] attributeExpressionExecutors,\n                                ConfigReader configReader, boolean outputExpectsExpiredEvents,\n                                SiddhiQueryContext siddhiQueryContext) {\n        inputExecutorLength = attributeExpressionExecutors.length;\n        if (inputExecutorLength == 3 &&\n                attributeExpressionExecutors[2] instanceof ConstantExpressionExecutor) {\n            fileSystemOptions = ((ConstantExpressionExecutor) attributeExpressionExecutors[2]).getValue().toString();\n        }\n        return null;\n    }\n    @Override\n    public List<Attribute> getReturnAttributes() {\n        return new ArrayList<>();\n    }\n    @Override\n    public ProcessingMode getProcessingMode() {\n        return ProcessingMode.BATCH;\n    }\n    @Override\n    protected Object[] process(Object[] data) {\n        String fileSourcePath = (String) data[0];\n        boolean isDirectory;\n        if (inputExecutorLength >= 2) {\n            isDirectory = (Boolean) data[1];\n        } else {\n            isDirectory = false;\n        }\n        FileObject rootFileObject = Utils.getFileObject(fileSourcePath, fileSystemOptions);\n        try {\n            if (isDirectory) {\n                rootFileObject.createFolder();\n            } else {\n                rootFileObject.createFile();\n            }\n        } catch (FileSystemException e) {\n            throw new SiddhiAppRuntimeException(\"Failure occurred when creating the file \" + fileSourcePath, e);\n        }\n        return new Object[0];\n    }\n    @Override\n    protected Object[] process(Object data) {\n        return new Object[0];\n    }\n    @Override\n    public void start() {\n    }\n    @Override\n    public void stop() {\n    }\n"]]}
{"hexsha": "df6ff0d20cbd8696208275a2ac68007fbec79201", "ext": "java", "lang": "Java", "content": "public class GetPresenceRequestApi extends RequestApi {\n    @JSONHint(ignore = true)\n    private static final Logger Log = LoggerFactory\n            .getLogger(GetPresenceRequestApi.class);\n\n    public Object content;\n\n    @Override\n    public ResponseApi doRequest(GlobalSNSWebSocket globalSNSWebSocket) {\n        final String logPrefix = \"doRequest() : \";\n        ResponseApi ret = null;\n        if (globalSNSWebSocket == null) {\n            Log.error(logPrefix + \"globalSNSWebSocket is null.\",\n                    new Throwable());\n            return ret;\n        }\n        String jid = globalSNSWebSocket.getJid();\n        if (jid == null || \"\".equals(jid)) {\n            Log.error(logPrefix + \"globalSNSWebSocket's jid is invalid\",\n                    new Throwable());\n            return ret;\n        }\n        int presence = WebSocketApiProcessor.getInstance().getDisplayPresence(\n                jid);\n        if (presence == -1) {\n            Log.error(logPrefix + \"presence is invalid\", new Throwable());\n            return ret;\n        }\n        GetPresenceResponseApi response = new GetPresenceResponseApi();\n        response.id = id;\n        response.request = request;\n        response.version = version;\n        ((GetPresenceResponseApi.Content) response.content).presence = presence;\n        ret = response;\n        return ret;\n    }\n\n}", "class_id": 0, "repo": "rebecca-NES/rebecca", "file": "src/openfire/src/plugins/globalSNS/src/java/jp/co/nec/necst/spf/globalSNS/WebSocketServer/WebSocketApi/GetPresenceRequestApi.java", "last_update_at": "2020-04-06T23:28:15+00:00", "question_id": "df6ff0d20cbd8696208275a2ac68007fbec79201", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GetPresenceRequestApi extends RequestApi {\n    @JSONHint(ignore = true)\n    private static final Logger Log = LoggerFactory\n            .getLogger(GetPresenceRequestApi.class);\n    public Object content;\n    @Override\n    public ResponseApi doRequest(GlobalSNSWebSocket globalSNSWebSocket) {\n        final String logPrefix = \"doRequest() : \";\n        ResponseApi ret = null;\n        if (globalSNSWebSocket == null) {\n            Log.error(logPrefix + \"globalSNSWebSocket is null.\",\n                    new Throwable());\n            return ret;\n        }\n        String jid = globalSNSWebSocket.getJid();\n        if (jid == null || \"\".equals(jid)) {\n            Log.error(logPrefix + \"globalSNSWebSocket's jid is invalid\",\n                    new Throwable());\n            return ret;\n        }\n        int presence = WebSocketApiProcessor.getInstance().getDisplayPresence(\n                jid);\n        if (presence == -1) {\n            Log.error(logPrefix + \"presence is invalid\", new Throwable());\n            return ret;\n        }\n        GetPresenceResponseApi response = new GetPresenceResponseApi();\n        response.id = id;\n        response.request = request;\n        response.version = version;\n        ((GetPresenceResponseApi.Content) response.content).presence = presence;\n        ret = response;\n        return ret;\n    }\n"]]}
{"hexsha": "5a9151cdab968b79fc588b9fc48a6421b5a8c539", "ext": "java", "lang": "Java", "content": "public class PuppetPropertiesHandler {\n    static List<InstanceProperty> getComponentInstanceProperties(ComponentType componentType, List<Fact> facts) {\n        List<InstanceProperty> instanceProperties = new ArrayList<>();\n        facts.forEach(fact -> instanceProperties.add(new InstanceProperty(fact.getName(),\n            fact.getValue().getClass().getSimpleName(),\n            fact.getValue())));\n        EDMMPropertyMapperImplementation propMapper = new EDMMPropertyMapperImplementation();\n        instanceProperties.forEach(instanceProperty -> instanceProperty.setKey(propMapper.mapToEDMMPropertyKey(\n            componentType,\n            instanceProperty.getKey())));\n        List<InstanceProperty> toBeRemoved = new ArrayList<>();\n        for (InstanceProperty instanceProperty : instanceProperties) {\n            if (instanceProperty.getKey() == null) {\n                toBeRemoved.add(instanceProperty);\n            }\n        }\n        instanceProperties.removeAll(toBeRemoved);\n        return instanceProperties;\n    }\n\n    private static String readPrivateKeyFileIntoString(String privateKeyLocation) {\n        StringBuilder privateKey = new StringBuilder();\n        try (Stream<String> stream = Files.lines(Paths.get(privateKeyLocation))) {\n            stream.forEach(line -> privateKey.append(line).append(\"\\n\"));\n        } catch (IOException e) {\n            throw new InstanceTransformationException(\"Failed to convert private key!\", e.getCause());\n        }\n        return privateKey.toString();\n    }\n\n    private static String generatePublicKeyFromPrivateKeyLocation(String privateKeyLocation) {\n        String privateKeyString = readPrivateKeyFileIntoString(privateKeyLocation);\n        privateKeyString = privateKeyString.replace(\"-----BEGIN RSA PRIVATE KEY-----\\n\", \"\");\n        privateKeyString = privateKeyString.replace(\"-----END RSA PRIVATE KEY-----\", \"\");\n        try {\n            byte[] decoded = Base64.decodeBase64(privateKeyString);\n            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(decoded);\n            java.security.Security.addProvider(\n                new org.bouncycastle.jce.provider.BouncyCastleProvider()\n            );\n            KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n            PrivateKey privateKey = keyFactory.generatePrivate(keySpec);\n            RSAPrivateCrtKey privateCrtKey = (RSAPrivateCrtKey) privateKey;\n            RSAPublicKeySpec publicKeySpec = new RSAPublicKeySpec(privateCrtKey.getModulus(),\n                privateCrtKey.getPublicExponent());\n            PublicKey publicKey = keyFactory.generatePublic(publicKeySpec);\n\n            java.util.Base64.Encoder encoder = java.util.Base64.getEncoder();\n\n            return encoder.encodeToString(publicKey.getEncoded());\n        } catch (InvalidKeySpecException | NoSuchAlgorithmException e) {\n            throw new InstanceTransformationException(\"Failed to convert public key\", e.getCause());\n        }\n    }\n}", "class_id": 0, "repo": "UST-EDMM/transformation-framework", "file": "TOSCin/src/main/java/io/github/edmm/plugins/puppet/util/PuppetPropertiesHandler.java", "last_update_at": "2020-03-30T13:02:46+00:00", "question_id": "5a9151cdab968b79fc588b9fc48a6421b5a8c539", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PuppetPropertiesHandler {\n    static List<InstanceProperty> getComponentInstanceProperties(ComponentType componentType, List<Fact> facts) {\n        List<InstanceProperty> instanceProperties = new ArrayList<>();\n        facts.forEach(fact -> instanceProperties.add(new InstanceProperty(fact.getName(),\n            fact.getValue().getClass().getSimpleName(),\n            fact.getValue())));\n        EDMMPropertyMapperImplementation propMapper = new EDMMPropertyMapperImplementation();\n        instanceProperties.forEach(instanceProperty -> instanceProperty.setKey(propMapper.mapToEDMMPropertyKey(\n            componentType,\n            instanceProperty.getKey())));\n        List<InstanceProperty> toBeRemoved = new ArrayList<>();\n        for (InstanceProperty instanceProperty : instanceProperties) {\n            if (instanceProperty.getKey() == null) {\n                toBeRemoved.add(instanceProperty);\n            }\n        }\n        instanceProperties.removeAll(toBeRemoved);\n        return instanceProperties;\n    }\n    private static String readPrivateKeyFileIntoString(String privateKeyLocation) {\n        StringBuilder privateKey = new StringBuilder();\n        try (Stream<String> stream = Files.lines(Paths.get(privateKeyLocation))) {\n            stream.forEach(line -> privateKey.append(line).append(\"\\n\"));\n        } catch (IOException e) {\n            throw new InstanceTransformationException(\"Failed to convert private key!\", e.getCause());\n        }\n        return privateKey.toString();\n    }\n    private static String generatePublicKeyFromPrivateKeyLocation(String privateKeyLocation) {\n        String privateKeyString = readPrivateKeyFileIntoString(privateKeyLocation);\n        privateKeyString = privateKeyString.replace(\"-----BEGIN RSA PRIVATE KEY-----\\n\", \"\");\n        privateKeyString = privateKeyString.replace(\"-----END RSA PRIVATE KEY-----\", \"\");\n        try {\n            byte[] decoded = Base64.decodeBase64(privateKeyString);\n            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(decoded);\n            java.security.Security.addProvider(\n                new org.bouncycastle.jce.provider.BouncyCastleProvider()\n            );\n            KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n            PrivateKey privateKey = keyFactory.generatePrivate(keySpec);\n            RSAPrivateCrtKey privateCrtKey = (RSAPrivateCrtKey) privateKey;\n            RSAPublicKeySpec publicKeySpec = new RSAPublicKeySpec(privateCrtKey.getModulus(),\n                privateCrtKey.getPublicExponent());\n            PublicKey publicKey = keyFactory.generatePublic(publicKeySpec);\n            java.util.Base64.Encoder encoder = java.util.Base64.getEncoder();\n            return encoder.encodeToString(publicKey.getEncoded());\n        } catch (InvalidKeySpecException | NoSuchAlgorithmException e) {\n            throw new InstanceTransformationException(\"Failed to convert public key\", e.getCause());\n        }\n    }\n"]]}
{"hexsha": "4dc6e4dcb47ccb81335c3ad3a0a35509ef12b238", "ext": "java", "lang": "Java", "content": "public class ChunkSnapshot\n{\n\tprivate final int x;\n\tprivate final int z;\n\tprivate final boolean worldHasNoSky;\n\tprivate final ExtendedBlockStorage[] ebsArr;\n\tprivate final byte[] biomeArray;\n\n\tprivate ChunkSnapshot(int x, int z, boolean worldHasNoSky, ExtendedBlockStorage[] ebsArr, byte[] biomeArray)\n\t{\n\t\tthis.x = x;\n\t\tthis.z = z;\n\t\tthis.worldHasNoSky = worldHasNoSky;\n\t\tthis.ebsArr = ebsArr;\n\t\tthis.biomeArray = biomeArray;\n\t}\n\n\tpublic static ChunkSnapshot of(Chunk chunk)\n\t{\n\t\tExtendedBlockStorage[] ebsOld = chunk.getBlockStorageArray();\n\t\tExtendedBlockStorage[] ebsNew = new ExtendedBlockStorage[ebsOld.length];\n\t\tfor(int i = 0; i < ebsOld.length; i++)\n\t\t\tebsNew[i] = ebsOld[i] == null ? null : ebsOld[i].copy();\n\t\tbyte[] biomeArray = chunk.getBiomeArray();\n\t\treturn new ChunkSnapshot(chunk.xPosition, chunk.zPosition, chunk.worldObj.provider.hasNoSky, ebsNew, Arrays.copyOf(biomeArray, biomeArray.length));\n\t}\n\n\tpublic int getX()\n\t{\n\t\treturn x;\n\t}\n\n\tpublic int getZ()\n\t{\n\t\treturn z;\n\t}\n\n\tpublic boolean isWorldHasNoSky()\n\t{\n\t\treturn worldHasNoSky;\n\t}\n\n\tpublic ExtendedBlockStorage[] getEbsArr()\n\t{\n\t\treturn ebsArr;\n\t}\n\n\tpublic byte[] getBiomeArray()\n\t{\n\t\treturn biomeArray;\n\t}\n\n\tpublic void release()\n\t{\n\t\tfor(ExtendedBlockStorage ebs : ebsArr)\n\t\t\tif(ebs != null)\n\t\t\t\tebs.release();\n\t}\n\n\tpublic ChunkSnapshot copy()\n\t{\n\t\tExtendedBlockStorage[] ebsOld = ebsArr;\n\t\tExtendedBlockStorage[] ebsNew = new ExtendedBlockStorage[ebsOld.length];\n\t\tfor(int i = 0; i < ebsOld.length; i++)\n\t\t\tebsNew[i] = ebsOld[i] == null ? null : ebsOld[i].copy();\n\t\tbyte[] biomeArray = this.biomeArray;\n\t\treturn new ChunkSnapshot(getX(), getZ(), isWorldHasNoSky(), ebsNew, Arrays.copyOf(biomeArray, biomeArray.length));\n\t}\n\n\tprivate static void rangeCheck(int x, int z)\n\t{\n\t\tif((x & 0xFFFFFFF0) != 0 || (z & 0xFFFFFFF0) != 0)\n\t\t\tthrow new IllegalArgumentException();\n\t}\n\n\tpublic Block getBlock(int x, int y, int z)\n\t{\n\t\trangeCheck(x, z);\n\t\tExtendedBlockStorage ebs = ebsArr[y >> 4];\n\t\tif(ebs != null)\n\t\t\treturn ebs.getBlockByExtId(x, y & 15, z);\n\t\treturn Blocks.air;\n\t}\n\n\tpublic int getBlockId(int x, int y, int z)\n\t{\n\t\trangeCheck(x, z);\n\t\tExtendedBlockStorage ebs = ebsArr[y >> 4];\n\t\tif(ebs != null)\n\t\t\treturn ebs.getSlot().getBlockId(x, y & 15, z);\n\t\treturn 0;\n\t}\n\n\tpublic int getBlockMeta(int x, int y, int z)\n\t{\n\t\trangeCheck(x, z);\n\t\tExtendedBlockStorage ebs = ebsArr[y >> 4];\n\t\tif(ebs != null)\n\t\t\treturn ebs.getExtBlockMetadata(x, y & 15, z);\n\t\treturn 0;\n\t}\n\n\tpublic int getBlockIdAndMeta(int x, int y, int z)\n\t{\n\t\trangeCheck(x, z);\n\t\tExtendedBlockStorage ebs = ebsArr[y >> 4];\n\t\tif(ebs != null)\n\t\t\treturn ebs.getSlot().getBlockIdAndMeta(x, y & 15, z);\n\t\treturn 0;\n\t}\n\n\tpublic void setBlock(int x, int y, int z, int blockId, int meta)\n\t{\n\t\trangeCheck(x, z);\n\t\tExtendedBlockStorage ebs = ebsArr[y >> 4];\n\t\tif(ebs == null)\n\t\t\tebs = ebsArr[y >> 4] = new ExtendedBlockStorage(y >> 4 << 4, true);\n\t\tebs.getSlot().setBlockIdAndMeta(x, y & 15, z, blockId, meta);\n\t\tif(ebs.isEmpty())\n\t\t\tebs.incBlockRefCount();\n\t}\n\n\tpublic void setBlock(int x, int y, int z, Block block, int meta)\n\t{\n\t\tsetBlock(x, y, z, Block.getIdFromBlock(block), meta);\n\t}\n\n\tpublic int getTopFilledSegment()\n\t{\n\t\tfor (int i = ebsArr.length - 1; i >= 0; --i)\n\t\t\tif(ebsArr[i] != null)\n\t\t\t\treturn ebsArr[i].getYLocation();\n\n\t\treturn 0;\n\t}\n}", "class_id": 0, "repo": "TechCatOther/ultramine_core", "file": "src/main/java/org/ultramine/server/chunk/ChunkSnapshot.java", "last_update_at": "2020-02-02T15:45:30+00:00", "question_id": "4dc6e4dcb47ccb81335c3ad3a0a35509ef12b238", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ChunkSnapshot\n{\n\tprivate final int x;\n\tprivate final int z;\n\tprivate final boolean worldHasNoSky;\n\tprivate final ExtendedBlockStorage[] ebsArr;\n\tprivate final byte[] biomeArray;\n\tprivate ChunkSnapshot(int x, int z, boolean worldHasNoSky, ExtendedBlockStorage[] ebsArr, byte[] biomeArray)\n\t{\n\t\tthis.x = x;\n\t\tthis.z = z;\n\t\tthis.worldHasNoSky = worldHasNoSky;\n\t\tthis.ebsArr = ebsArr;\n\t\tthis.biomeArray = biomeArray;\n\t}\n\tpublic static ChunkSnapshot of(Chunk chunk)\n\t{\n\t\tExtendedBlockStorage[] ebsOld = chunk.getBlockStorageArray();\n\t\tExtendedBlockStorage[] ebsNew = new ExtendedBlockStorage[ebsOld.length];\n\t\tfor(int i = 0; i < ebsOld.length; i++)\n\t\t\tebsNew[i] = ebsOld[i] == null ? null : ebsOld[i].copy();\n\t\tbyte[] biomeArray = chunk.getBiomeArray();\n\t\treturn new ChunkSnapshot(chunk.xPosition, chunk.zPosition, chunk.worldObj.provider.hasNoSky, ebsNew, Arrays.copyOf(biomeArray, biomeArray.length));\n\t}\n\tpublic int getX()\n\t{\n\t\treturn x;\n\t}\n\tpublic int getZ()\n\t{\n\t\treturn z;\n\t}\n\tpublic boolean isWorldHasNoSky()\n\t{\n\t\treturn worldHasNoSky;\n\t}\n\tpublic ExtendedBlockStorage[] getEbsArr()\n\t{\n\t\treturn ebsArr;\n\t}\n\tpublic byte[] getBiomeArray()\n\t{\n\t\treturn biomeArray;\n\t}\n\tpublic void release()\n\t{\n\t\tfor(ExtendedBlockStorage ebs : ebsArr)\n\t\t\tif(ebs != null)\n\t\t\t\tebs.release();\n\t}\n\tpublic ChunkSnapshot copy()\n\t{\n\t\tExtendedBlockStorage[] ebsOld = ebsArr;\n\t\tExtendedBlockStorage[] ebsNew = new ExtendedBlockStorage[ebsOld.length];\n\t\tfor(int i = 0; i < ebsOld.length; i++)\n\t\t\tebsNew[i] = ebsOld[i] == null ? null : ebsOld[i].copy();\n\t\tbyte[] biomeArray = this.biomeArray;\n\t\treturn new ChunkSnapshot(getX(), getZ(), isWorldHasNoSky(), ebsNew, Arrays.copyOf(biomeArray, biomeArray.length));\n\t}\n\tprivate static void rangeCheck(int x, int z)\n\t{\n\t\tif((x & 0xFFFFFFF0) != 0 || (z & 0xFFFFFFF0) != 0)\n\t\t\tthrow new IllegalArgumentException();\n\t}\n\tpublic Block getBlock(int x, int y, int z)\n\t{\n\t\trangeCheck(x, z);\n\t\tExtendedBlockStorage ebs = ebsArr[y >> 4];\n\t\tif(ebs != null)\n\t\t\treturn ebs.getBlockByExtId(x, y & 15, z);\n\t\treturn Blocks.air;\n\t}\n\tpublic int getBlockId(int x, int y, int z)\n\t{\n\t\trangeCheck(x, z);\n\t\tExtendedBlockStorage ebs = ebsArr[y >> 4];\n\t\tif(ebs != null)\n\t\t\treturn ebs.getSlot().getBlockId(x, y & 15, z);\n\t\treturn 0;\n\t}\n\tpublic int getBlockMeta(int x, int y, int z)\n\t{\n\t\trangeCheck(x, z);\n\t\tExtendedBlockStorage ebs = ebsArr[y >> 4];\n\t\tif(ebs != null)\n\t\t\treturn ebs.getExtBlockMetadata(x, y & 15, z);\n\t\treturn 0;\n\t}\n\tpublic int getBlockIdAndMeta(int x, int y, int z)\n\t{\n\t\trangeCheck(x, z);\n\t\tExtendedBlockStorage ebs = ebsArr[y >> 4];\n\t\tif(ebs != null)\n\t\t\treturn ebs.getSlot().getBlockIdAndMeta(x, y & 15, z);\n\t\treturn 0;\n\t}\n\tpublic void setBlock(int x, int y, int z, int blockId, int meta)\n\t{\n\t\trangeCheck(x, z);\n\t\tExtendedBlockStorage ebs = ebsArr[y >> 4];\n\t\tif(ebs == null)\n\t\t\tebs = ebsArr[y >> 4] = new ExtendedBlockStorage(y >> 4 << 4, true);\n\t\tebs.getSlot().setBlockIdAndMeta(x, y & 15, z, blockId, meta);\n\t\tif(ebs.isEmpty())\n\t\t\tebs.incBlockRefCount();\n\t}\n\tpublic void setBlock(int x, int y, int z, Block block, int meta)\n\t{\n\t\tsetBlock(x, y, z, Block.getIdFromBlock(block), meta);\n\t}\n\tpublic int getTopFilledSegment()\n\t{\n\t\tfor (int i = ebsArr.length - 1; i >= 0; --i)\n\t\t\tif(ebsArr[i] != null)\n\t\t\t\treturn ebsArr[i].getYLocation();\n\t\treturn 0;\n\t}\n"]]}
{"hexsha": "7e83519156b98ea9cffe6fd01cbd116d45fc3197", "ext": "java", "lang": "Java", "content": "public class SecretsManagerSample {\n\n    public static void getSecret(String secretName, String region) {\n        String endpoint =(\"secretsmanager.\" + region + \".amazonaws.com\");\n        AwsClientBuilder.EndpointConfiguration config = new AwsClientBuilder.EndpointConfiguration(endpoint, region);\n        AWSSecretsManagerClientBuilder clientBuilder = AWSSecretsManagerClientBuilder.standard();\n        clientBuilder.setEndpointConfiguration(config);\n        AWSSecretsManager client = clientBuilder.build();\n        String secret = null;\n        ByteBuffer binarySecretData;\n        GetSecretValueRequest getSecretValueRequest = new GetSecretValueRequest().withSecretId(secretName);\n        GetSecretValueResult getSecretValueResponse = null;\n        try {\n            getSecretValueResponse = client.getSecretValue(getSecretValueRequest);\n\n        } catch(ResourceNotFoundException e) {\n            System.out.println(\"The requested secret \" + secretName + \" was not found\");\n        } catch (InvalidRequestException e) {\n            System.out.println(\"The request was invalid due to: \" + e.getMessage());\n        } catch (InvalidParameterException e) {\n            System.out.println(\"The request had invalid params: \" + e.getMessage());\n        }\n\n        if(getSecretValueResponse == null) {\n            return;\n        }\n\n        // Decrypted secret using the associated KMS CMK\n        // Depending on whether the secret was a string or binary, one of these fields will be populated\n        if(getSecretValueResponse.getSecretString() != null) {\n            secret = getSecretValueResponse.getSecretString();\n        }\n        else {\n            binarySecretData = getSecretValueResponse.getSecretBinary();\n        }\n\n        // Your code goes here.\n        System.out.println(\"Secret Name : \" + secretName + \"\\t Secret Value : \" + secret + \"\\n\");\n    }\n    public static void main(String[] args) throws IOException {\n        // Call the program with maven as mvn clean compile exec:java -Dexec.mainClass=com.amazonaws.samples.KMSEncryptionSample -Dexec.args=\"arg1 arg2\"\n        try {\n            System.out.println(\"Retreiving Secrets based on the secret id and region entered as command line arguements: \\n\");\n            SecretsManagerSample.getSecret(args[0], args[1]);\n        } catch (AmazonServiceException ase) {\n            System.out.println(\"Caught an AmazonServiceException, which means your request made it \"\n                    + \"to Amazon AWS, but was rejected with an error response for some reason.\");\n            System.out.println(\"Error Message:    \" + ase.getMessage());\n            System.out.println(\"HTTP Status Code: \" + ase.getStatusCode());\n            System.out.println(\"AWS Error Code:   \" + ase.getErrorCode());\n            System.out.println(\"Error Type:       \" + ase.getErrorType());\n            System.out.println(\"Request ID:       \" + ase.getRequestId());\n        } catch (AmazonClientException ace) {\n            System.out.println(\"Caught an AmazonClientException, which means the client encountered \"\n                    + \"a serious internal problem while trying to communicate with AWS, \"\n                    + \"such as not being able to access the network.\");\n            System.out.println(\"Error Message: \" + ace.getMessage());\n        }\n    }\n}", "class_id": 0, "repo": "samuel-72/AWS-Secretsmanager", "file": "src/main/java/com/amazonaws/samples/SecretsManagerSample.java", "last_update_at": "2020-09-25T06:20:30+00:00", "question_id": "7e83519156b98ea9cffe6fd01cbd116d45fc3197", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SecretsManagerSample {\n    public static void getSecret(String secretName, String region) {\n        String endpoint =(\"secretsmanager.\" + region + \".amazonaws.com\");\n        AwsClientBuilder.EndpointConfiguration config = new AwsClientBuilder.EndpointConfiguration(endpoint, region);\n        AWSSecretsManagerClientBuilder clientBuilder = AWSSecretsManagerClientBuilder.standard();\n        clientBuilder.setEndpointConfiguration(config);\n        AWSSecretsManager client = clientBuilder.build();\n        String secret = null;\n        ByteBuffer binarySecretData;\n        GetSecretValueRequest getSecretValueRequest = new GetSecretValueRequest().withSecretId(secretName);\n        GetSecretValueResult getSecretValueResponse = null;\n        try {\n            getSecretValueResponse = client.getSecretValue(getSecretValueRequest);\n        } catch(ResourceNotFoundException e) {\n            System.out.println(\"The requested secret \" + secretName + \" was not found\");\n        } catch (InvalidRequestException e) {\n            System.out.println(\"The request was invalid due to: \" + e.getMessage());\n        } catch (InvalidParameterException e) {\n            System.out.println(\"The request had invalid params: \" + e.getMessage());\n        }\n        if(getSecretValueResponse == null) {\n            return;\n        }\n        // Decrypted secret using the associated KMS CMK\n        // Depending on whether the secret was a string or binary, one of these fields will be populated\n        if(getSecretValueResponse.getSecretString() != null) {\n            secret = getSecretValueResponse.getSecretString();\n        }\n        else {\n            binarySecretData = getSecretValueResponse.getSecretBinary();\n        }\n        // Your code goes here.\n        System.out.println(\"Secret Name : \" + secretName + \"\\t Secret Value : \" + secret + \"\\n\");\n    }\n    public static void main(String[] args) throws IOException {\n        // Call the program with maven as mvn clean compile exec:java -Dexec.mainClass=com.amazonaws.samples.KMSEncryptionSample -Dexec.args=\"arg1 arg2\"\n        try {\n            System.out.println(\"Retreiving Secrets based on the secret id and region entered as command line arguements: \\n\");\n            SecretsManagerSample.getSecret(args[0], args[1]);\n        } catch (AmazonServiceException ase) {\n            System.out.println(\"Caught an AmazonServiceException, which means your request made it \"\n                    + \"to Amazon AWS, but was rejected with an error response for some reason.\");\n            System.out.println(\"Error Message:    \" + ase.getMessage());\n            System.out.println(\"HTTP Status Code: \" + ase.getStatusCode());\n            System.out.println(\"AWS Error Code:   \" + ase.getErrorCode());\n            System.out.println(\"Error Type:       \" + ase.getErrorType());\n            System.out.println(\"Request ID:       \" + ase.getRequestId());\n        } catch (AmazonClientException ace) {\n            System.out.println(\"Caught an AmazonClientException, which means the client encountered \"\n                    + \"a serious internal problem while trying to communicate with AWS, \"\n                    + \"such as not being able to access the network.\");\n            System.out.println(\"Error Message: \" + ace.getMessage());\n        }\n    }\n"]]}
{"hexsha": "ba6bd19862484398fb77a257adb873a9f8ee25c3", "ext": "java", "lang": "Java", "content": "public class MediaManager {\n\t\n\tpublic MediaManager()\n\t{\n\t\tmMediaItemList = new ArrayList<MediaItem>();\n\t}\n\n\tprivate String[] getFilesOfDirectory(String folder) {\n\t\tFile file = new File(Environment.getExternalStorageDirectory(), folder);\n\t\tif (file.exists()) {\n\t\t\tif (file.isDirectory()) {\n\t\t\t\treturn file.list();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tprivate String getBitmapFileAddr(String addr)\n\t{\n\t\tFile file = new File(Environment.getExternalStorageDirectory(), addr);\n\t\tif(file.exists())\n\t\t{\n\t\t\treturn file.getAbsolutePath();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn \"\";\n\t\t}\n\t}\n\t\n\tpublic enum MediaType\n\t{\n\t\tMovie,\n\t\tAudio\n\t}\n\t\n\tpublic void LoadMedia(MediaType mediaType)\n\t{\n\t\tmMediaItemList.clear();\n\t\tString[] files = getFilesOfDirectory(mediaType.toString());\n\t\tfor(int i =0; i<files.length; i++)\n\t\t{\n\t\t\tif(files[i].contains(\".3gp\"))\n\t\t\t{\n\t\t\t\tMediaItem item = new MediaItem();\n\t\t\t\tString name = files[i].substring(0, files[i].length()-4);\n\t\t\t\titem.setName(name);\n\t\t\t\titem.setImageAddr(getBitmapFileAddr(mediaType.toString() + File.separator + name + \".png\"));\n\t\t\t\titem.setPath(Environment.getExternalStorageDirectory() +File.separator+ mediaType.toString() + File.separator+files[i]);\n\t\t\t\titem.setAngle(INIT_ANGLE + SEP_ANGLE * mMediaItemList.size());\n\t\t\t\titem.setTransform(new ESTransform());\n\t\t\t\tmMediaItemList.add(item);\n\t\t\t}\n\t\t\t\n\t\t\tif(files[i].contains(\".mp3\"))\n\t\t\t{\n\t\t\t\tMediaItem item = new MediaItem();\n\t\t\t\tString name = files[i].substring(0, files[i].length()-4);\n\t\t\t\titem.setName(name);\n\t\t\t\titem.setImageAddr(getBitmapFileAddr(mediaType.toString() + File.separator + name + \".png\"));\n\t\t\t\titem.setPath(Environment.getExternalStorageDirectory() +File.separator+ mediaType.toString() + File.separator+files[i]);\n\t\t\t\titem.setAngle(INIT_ANGLE + SEP_ANGLE * mMediaItemList.size());\n\t\t\t\titem.setTransform(new ESTransform());\n\t\t\t\tmMediaItemList.add(item);\n\t\t\t}\n\t\t}\n\t}\n\tpublic static Bitmap LoadBitmapFile(String path) throws Exception{\n\t\tFileInputStream in;\n\t\tBufferedInputStream buf;\n\t\ttry {\n\t\t\t//in = new FileInputStream(\"/sdcard/test2.png\");\n\t\t\tin = new FileInputStream(path);\n\t\t\tbuf = new BufferedInputStream(in);\n\t\t\tbyte[] bMapArray = new byte[buf.available()];\n\t\t\tbuf.read(bMapArray);\n\t\t\tBitmapFactory.Options bmOption = new BitmapFactory.Options();\n\t        bmOption.inPreferredConfig = Config.ARGB_8888;\n\t        bmOption.inSampleSize = 2;\n\t\t\tBitmap bMap = BitmapFactory.decodeByteArray(bMapArray, 0,\n\t\t\t\t\tbMapArray.length,bmOption);\n\t\t\tif (in != null) {\n\t\t\t\tin.close();\n\t\t\t}\n\t\t\tif (buf != null) {\n\t\t\t\tbuf.close();\n\t\t\t}\n\t\t\treturn bMap;\n\t\t} catch (Exception e) {\n\t\t\tLog.e(\"Error reading file\", e.toString());\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * \n\t * @param ids\n\t * @return\n\t */\n\tstatic int[] genTextureIds(int[] ids) {\n\t\tGLES20.glGenTextures(ids.length, ids, 0);\n\t\treturn ids;\n\t}\n\t\n\tpublic static int[] combine(int[] a, int[] b)\n\t{\n\t\tint alen = a.length;\n\t\tint blen = b.length;\n\t\tint clen = alen+blen;\n\t\n\t\tint[] c = new int[clen];\n\t\tSystem.arraycopy(a,0,c,0,alen);\n\t\tSystem.arraycopy(b,0,c,alen,blen);\n\t\n\t\treturn c;\n\t}\n\t\n\t///\n    //  Load texture from resource\n    //\n    public static int loadTexture ( Bitmap bitmap )\n    {\n    \t//long time1 = System.currentTimeMillis();\n        int[] textureId = new int[1];\n            \n        GLES20.glGenTextures ( 1, textureId, 0 );\n        GLES20.glBindTexture ( GLES20.GL_TEXTURE_2D, textureId[0] );\n    \n        GLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR );\n        GLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR );\n        GLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE );\n        GLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE );\n        \n        GLES20.glEnable(GLES20.GL_BLEND);\n        GLES20.glBlendFunc(GLES20.GL_ONE, GLES20.GL_ONE_MINUS_SRC_ALPHA);\n        \n        try{\n        GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bitmap, 0);\n        }\n        catch(Exception ex)\n        {\n        \tex.printStackTrace();\n        }\n        \n       // Log.d(\"bitmap\", \"load bitmap:\" + bitmap + \" return :\" + textureId[0]);\n//        long timediff = System.currentTimeMillis() - time1;\n//        \n//        Log.d(\"performance\", \"load texture:\" + timediff);\n        \n        return textureId[0];\n    }\n    \n    /**\n     * bind texture with a general texture id, and draw the texture\n     * @author aaronli\n     * @since Mar 12,2013\n     * @param textureId\n     * @param b\n     */\n    public static void loadSingleTexImage(int textureId, Bitmap b) {\n    \t//long time1 = System.currentTimeMillis();\n    \tGLES20.glBindTexture ( GLES20.GL_TEXTURE_2D, textureId );\n    \tGLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR );\n\t\tGLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR );\n\t\tGLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE );\n\t\tGLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE );\n\t\t\n\t\tGLES20.glEnable(GLES20.GL_BLEND);\n\t\tGLES20.glBlendFunc(GLES20.GL_ONE, GLES20.GL_ONE_MINUS_SRC_ALPHA);\n\t\t\n\t\ttry{\n\t\t\tGLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, b, 0);\n\t\t}\n\t\tcatch(Exception ex)\n\t\t{\n\t\t\tex.printStackTrace();\n\t\t}\n\t\t//long timediff = System.currentTimeMillis() - time1;\n//     //  \n       //Log.d(\"performance\", \"load texture: \" + textureId + \"     \" + timediff);\n    \t\n    }\n    \n    public static Bitmap loadProperImage(String path, int reqWidth, int reqHeight)\n    {\n    \t // First decode with inJustDecodeBounds=true to check dimensions\n        final BitmapFactory.Options options = new BitmapFactory.Options();\n        options.inJustDecodeBounds = true;\n        BitmapFactory.decodeFile(path, options);\n\n        // Calculate inSampleSize\n        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);\n\n        // Decode bitmap with inSampleSize set\n        options.inJustDecodeBounds = false;\n        return BitmapFactory.decodeFile(path, options);\n    }\n\n\tpublic static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {\n\t\t// Raw height and width of image\n\t\tfinal int height = options.outHeight;\n\t\tfinal int width = options.outWidth;\n\t\tint inSampleSize = 1;\n\n\t\tif (height > reqHeight || width > reqWidth) {\n\t\t\tif (width > height) {\n\t\t\t\tinSampleSize = Math.round((float) height / (float) reqHeight);\n\t\t\t} else {\n\t\t\t\tinSampleSize = Math.round((float) width / (float) reqWidth);\n\t\t\t}\n\t\t}\n\t\treturn inSampleSize;\n\t}\n    \n    \n    public static void releaseTexture(int id)\n    {\n    \t GLES20.glDeleteTextures(1, IntBuffer.wrap(new int[] {id}));\n    }\n    public static int getTitleTextureId(String text, int fontSize, int color, Align align)\n    {\n    \treturn getTextureIdByText(text, fontSize, color, 550, 50,0,35, align);\n    }\n    \n    public static int getTitleTextureId(String text, int fontSize, int color)\n    {\n    \treturn getTextureIdByText(text, fontSize, color, 550, 50,0,35);\n    }\n    \n    public static int getIconTextureId(String text, int fontSize, int color)\n    {\n    \treturn getTextureIdByText(text, fontSize, color, 128, 128, 10,115);\n    }\n    \n    private static int getTextureIdByText(String text, int fontSize, int color, int w, int h, int x, int y,Align align )\n    {\n    \t//long time1 = System.currentTimeMillis();\n    \t\n    \t// Create an empty, mutable bitmap\n    \tBitmap bitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);\n    \t// get a canvas to paint over the bitmap\n    \tCanvas canvas = new Canvas(bitmap);\n    \tbitmap.eraseColor(0);\n\n    \t// Draw the text\n    \tPaint textPaint = new Paint();\n    \ttextPaint.setTextSize(fontSize);\n    \ttextPaint.setAntiAlias(true);\n    \ttextPaint.setTextAlign(align);\n    \ttextPaint.setFakeBoldText(true);\n    \t//textPaint.setARGB(0xff, 0xff, 0x00, 0x00);\n    \ttextPaint.setColor(color);\n    \t// deleted by aaronli Jul8 2013/ removed the shadow of titles\n    \t//textPaint.setShadowLayer(5f, 2f, 2f, Color.argb(180, 0, 0, 0));\n    \t\n    \t// draw the text centered\n\t\tcanvas.drawText(text, x, y, textPaint);\n\n\t\tint[] textureId = new int[1];\n\t\tGLES20.glGenTextures(1, textureId, 0);\n\t\tGLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId[0]);\n\n\t\tGLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,\n\t\t\t\tGLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);\n\t\tGLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,\n\t\t\t\tGLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);\n\t\tGLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S,\n\t\t\t\tGLES20.GL_CLAMP_TO_EDGE);\n\t\tGLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T,\n\t\t\t\tGLES20.GL_CLAMP_TO_EDGE);\n\n\t\tGLES20.glEnable(GLES20.GL_BLEND);\n\t\tGLES20.glBlendFunc(GLES20.GL_ONE, GLES20.GL_ONE_MINUS_SRC_ALPHA);\n\n\t\t// Use the Android GLUtils to specify a two-dimensional texture image\n\t\t// from our bitmap\n\t\tGLUtils.texImage2D(GL10.GL_TEXTURE_2D, 0, bitmap, 0);\n\t\tMediaManager.saveImageToExternal(bitmap, \"/mnt/sdcard/5.png\");\n\t\tLog.d(\"getTextTextureId\", \"save img\");\n\n    \t//Clean up\n    \tbitmap.recycle();\n    \t\n    \t //long timediff = System.currentTimeMillis() - time1;\n         \n        // Log.d(\"performance\", \"load texture(draw text):\" + timediff);\n    \t\n    \treturn textureId[0];\n    }\n    \n    private static int getTextureIdByText(String text, int fontSize, int color, int w, int h, int x, int y)\n    {\n    \t//long time1 = System.currentTimeMillis();\n    \t\n    \t// Create an empty, mutable bitmap\n    \tBitmap bitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);\n    \t// get a canvas to paint over the bitmap\n    \tCanvas canvas = new Canvas(bitmap);\n    \tbitmap.eraseColor(0);\n\n    \t// Draw the text\n    \tPaint textPaint = new Paint();\n    \ttextPaint.setTextSize(fontSize);\n    \ttextPaint.setAntiAlias(true);\n    \ttextPaint.setTextAlign(Align.CENTER);\n    \ttextPaint.setFakeBoldText(true);\n    \t//textPaint.setARGB(0xff, 0xff, 0x00, 0x00);\n    \ttextPaint.setColor(color);\n    \ttextPaint.setShadowLayer(5f, 2f, 2f, Color.argb(180, 0, 0, 0));\n    \t\n    \t// draw the text centered\n\t\tcanvas.drawText(text, x, y, textPaint);\n\n\t\tint[] textureId = new int[1];\n\t\tGLES20.glGenTextures(1, textureId, 0);\n\t\tGLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId[0]);\n\n\t\tGLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,\n\t\t\t\tGLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);\n\t\tGLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,\n\t\t\t\tGLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);\n\t\tGLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S,\n\t\t\t\tGLES20.GL_CLAMP_TO_EDGE);\n\t\tGLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T,\n\t\t\t\tGLES20.GL_CLAMP_TO_EDGE);\n\n\t\tGLES20.glEnable(GLES20.GL_BLEND);\n\t\tGLES20.glBlendFunc(GLES20.GL_ONE, GLES20.GL_ONE_MINUS_SRC_ALPHA);\n\n\t\t// Use the Android GLUtils to specify a two-dimensional texture image\n\t\t// from our bitmap\n\t\tGLUtils.texImage2D(GL10.GL_TEXTURE_2D, 0, bitmap, 0);\n\t\tMediaManager.saveImageToExternal(bitmap, \"/mnt/sdcard/5.png\");\n\t\tLog.d(\"getTextTextureId\", \"save img\");\n\n    \t//Clean up\n    \tbitmap.recycle();\n    \t\n    \t //long timediff = System.currentTimeMillis() - time1;\n         \n        // Log.d(\"performance\", \"load texture(draw text):\" + timediff);\n    \t\n    \treturn textureId[0];\n    }\n    \n    public static Bitmap getDimImage(Bitmap bitmap)\n\t{\n    \tlong timea = System.currentTimeMillis();\n    \tint opacity = 64;\n\n        Bitmap mutableBitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true);\n\n        //draw the bitmap into a canvas\n        Canvas canvas = new Canvas(mutableBitmap);\n\n        //create a color with the specified opacity\n        int colour = (opacity & 0xFF) << 24;\n\n        //draw the colour over the bitmap using PorterDuff mode DST_IN\n        canvas.drawColor(colour, PorterDuff.Mode.DST_IN);\n        \n        long diff = System.currentTimeMillis() - timea;\n        Log.d(\"bitmapspeed\", \"bitmapspeed for dim1: \" + diff);\n        //now return the adjusted bitmap\n        return mutableBitmap;\n\t}\n    \n    public static Bitmap getDimImage2(Bitmap bitmap)\n\t{\n    \tlong timea = System.currentTimeMillis();\n    \t //make sure bitmap is mutable (copy of needed)\n        Bitmap mutableBitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true);\n\n        int h = bitmap.getHeight();\n        int w = bitmap.getWidth();\n        int[] pixels = new  int[w*h];\n        \n        bitmap.getPixels(pixels, 0, w, 0, 0, w,h);\n        \n        for(int i=0; i< pixels.length; i++)\n        {\n        \tint pixel = pixels[i];\n        \tint a = (pixel & 0xFF000000) >> 24;\n        \tint r = ((pixel & 0x00FF0000) >> 16)/2;\n        \tint g = ((pixel & 0x0000FF00) >> 8)/2;\n        \tint b = (pixel & 0x000000FF)/2;\n        \tpixels[i] = Color.argb(a, r, g, b);\n        }\n        mutableBitmap.setPixels(pixels, 0, w, 0, 0, w, h);\n        \n        long diff = System.currentTimeMillis() - timea;\n        Log.d(\"bitmapspeed\", \"bitmapspeed for dim2: \" + diff);\n        \n        //now return the adjusted bitmap\n        return mutableBitmap;\n\t}\n    \n\tpublic static Bitmap getDimImage3(Bitmap oriImage)\n\t{\n\t\tlong timea = System.currentTimeMillis();\n\t\t\n\t\tint width = oriImage.getWidth();\n\t\tint height = oriImage.getHeight();\n\t\tint argb = 0;\n\t\tBitmap bmapCoverDim = Bitmap.createBitmap(width,height, Config.ARGB_8888);\n\t\tfor (int i = 0; i < width; i++) {\n\t\t\tfor (int j = 0; j < height; j++) {\n\t\t\t\targb = oriImage.getPixel(i, j);\n\t\t\t\tint alpha = argb >> 24;\n\t\t\t\tint red = (argb & 0x00FF0000) >> 16;\n\t\t\t\tint green = (argb & 0x0000FF00) >> 8;\n\t\t\t\tint blue = (argb & 0x000000FF); \n\t\t\t\tred = (int) (red * 0.5f);\n\t\t\t\tgreen = (int) (green * 0.5f);\n\t\t\t\tblue = (int) (blue * 0.5f);\n\t\t\t\tbmapCoverDim.setPixel(i, j, Color.argb(alpha, red, green, blue));\n\t\t\t}\n\t\t}\n\t\t\n        long diff = System.currentTimeMillis() - timea;\n        Log.d(\"bitmapspeed\", \"bitmapspeed for dim3: \" + diff);\n        \n\t\treturn bmapCoverDim;\n\t}\n\t\n\tpublic static void saveImageToExternalWithFullQuality(Bitmap bmp, String path) {\n\t\tOutputStream os = null;\n\t\ttry {\n\t\t\tos = new FileOutputStream(path);\n\t\t\tbmp.compress(CompressFormat.PNG, 100, os);\n\t\t\tLog.w(\"mediaManager\", \"saveImage to :\" + path);\n\t\t\tos.flush();\n\t\t\tos.close();\n\t\t} catch (Exception e) {\n\t\t\tLog.w(\"mediaManager\", \"saveImage fail:\" + e.toString());\n\t\t}\n\t}\n  \n    public static void saveImageToExternal(Bitmap bmp, String path)\n\t{\n\t\tOutputStream os = null;\n\t\ttry {\n\t\t\tos = new FileOutputStream(path);\n\t\t\tbmp.compress(CompressFormat.PNG, 80, os);\n\t\t\tLog.w(\"mediaManager\",\"saveImage to :\" + path);\n\t\t\tos.flush();\n\t\t\tos.close();\n\t\t} catch (Exception e) {\n\t\t\tLog.w(\"mediaManager\",\"saveImage fail:\" + e.toString());\n\t\t}\n\t}\n    \n    public static void saveImageToInternal(Context context, Bitmap bmp, String fileName){\n    \tFileOutputStream fos;\n\t\ttry {\n\t\t\tfos = context.openFileOutput(fileName, Context.MODE_PRIVATE);\n\t\t\tbmp.compress(CompressFormat.PNG, 80, fos);\n\t\t\t\n\t    \ttry {\n\t    \t\tfos.flush();\n\t\t\t\tfos.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t} catch (FileNotFoundException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    }\n    \n    public static void saveImageToInternal(Bitmap bmp, String fullFilePath){\n    \tFileOutputStream fos;\n\t\ttry {\n\t\t\tFile file = new File(fullFilePath);\n\t\t\tfos = new FileOutputStream(file);\n\t\t\tbmp.compress(CompressFormat.PNG, 80, fos);\n\t    \ttry {\n\t    \t\tfos.flush();\n\t\t\t\tfos.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t} catch (FileNotFoundException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    }\n    \n    \n    \n    public static boolean deleteInternalFile(Context context, String mPath)\n    {\n    \tFile file = context.getFilesDir();\n    \treturn file.delete();\n    }\n    \n\tpublic static File getDataDir(Context context) {\n\t\treturn context.getDir(\"data\", Context.MODE_PRIVATE);\n\t}\n    \n    public static File getLargeIconDir(Context context)\n    {\n    \tFile file = context.getDir(\"icon_l\", Context.MODE_PRIVATE);\n    \treturn file;\n    }\n    public static File getDimIconDir(Context context)\n    {\n    \tFile file = context.getDir(\"icon_ld\", Context.MODE_PRIVATE);\n    \treturn file;\n    }\n    \n    public static File getMirrorIconDir(Context context)\n    {\n    \tFile file = context.getDir(\"icon_lm\", Context.MODE_PRIVATE);\n    \treturn file;\n    }\n    \n    public static File getSmallIconDir(Context context)\n    {\n    \tFile file = context.getDir(\"icon_s\", Context.MODE_PRIVATE);\n    \treturn file;\n    }\n    \n\tpublic static Bitmap loadInternalImage(Context context, String fileName) {\n\t\tString path = Environment.getDataDirectory().toString() + File.separator + \"data\" + File.separator + context.getPackageName() + File.separator + \"files\" + File.separator +fileName;\n\t\tLog.d(\"mediaMgr\", \"loadInternalImage path:\" + path);\n\t\treturn BitmapFactory.decodeFile(path);\n\t}\n\t\n\tpublic static File getDir(Context context, String name)\n\t{\n\t\treturn context.getDir(name, Context.MODE_PRIVATE);\n\t}\n\t\n\t\n\tpublic static String getInternalFilePath(Context context, String fileName) {\n\t\treturn Environment.getDataDirectory().toString() + File.separator + \"data\" + File.separator + context.getPackageName() + File.separator + \"files\" + File.separator +fileName;\n\t}\n\n\n    public static Bitmap getReflectionImage(Bitmap bmap) {\n    \tlong timea = System.currentTimeMillis();\n\n\t\t// change image color to dim\n    \tint pixelCount =0;\n\t\tint width = bmap.getWidth();\n\t\tint oriHeight = bmap.getHeight();\n\t\tint height = (int) (bmap.getHeight() * 1.5f);\n\t\tint MAX_PIXEL_COUNT = width * height -1;\n\t\t//Bitmap copyBmp = bmap.copy(Config.ARGB_8888, true);\n\t\t\n\t\tBitmap bmapMirror = Bitmap.createBitmap(width, height, Config.ARGB_8888);\n\t\tint[] pixels = new int[width * height];\n\t\tbmap.getPixels(pixels, 0, width, 0, 0, width, oriHeight);\n\t\tpixelCount = width* oriHeight -1;\n\n\t\tint half = (int) (bmap.getHeight() / 2);\n\t\t//int[] mirrorPixel = new int[width * (height-oriHeight)];\n\n\t\tfor(int i=oriHeight-1; i>=height - oriHeight; i--)\n\t\t{\n\t\t\tint alpha = 0;\n\t\t\tif (oriHeight - 1 > 128) {\n\t\t\t\talpha = (int) (128 * ((i - 128) * 1.0f / half));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\talpha = (int) (128 * ((i - half) * 1.0f / half));\n\t\t\t}\n\t\t\t//Log.d(\"performance\", \"load pixel row:\" + i + \" alpha:\" + alpha);\n\t\t\tint[] row = new int[width];\n\t\t\tbmap.getPixels(row, 0, width, 0, i, width, 1);\n\t\t\tfor (int j = 0; j < row.length; j++) {\n\t\t\t\tint argb = row[j];\n\t\t\t\tint a = (argb & 0xFF000000) >> 24;\n\t\t\t\tint red = (argb & 0x00FF0000) >> 16;\n\t\t\t\tint green = (argb & 0x0000FF00) >> 8;\n\t\t\t\tint blue = (argb & 0x000000FF);\n\t\t\t\t//Log.d(\"performance\", \"load pixel row:\" + i + \" alpha:\" + alpha + \"  a:\" + a);\n\t\t\t\tint pixel = Color.argb(alpha, red, green, blue);\n\t\t\t\t\n\t\t\t\tif (a == 0) {\n\t\t\t\t\tpixels[pixelCount] = row[j];\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tpixels[pixelCount] = pixel;\n\t\t\t\t}\n\t\t\t\tpixelCount++;\n\t\t\t\tif(pixelCount>MAX_PIXEL_COUNT)\n\t\t\t\t{\n\t\t\t\t\tLog.w(\"getReflectionImage\", \"the pixel count larger than max count\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t}\n\n\t\tLog.d(\"mirror test\", \"mirror test\");\n\t\tbmapMirror.setPixels(pixels,0,width,0,0,width, height);\t\t\n\t\t\n        long diff = System.currentTimeMillis() - timea;\n        Log.d(\"bitmapspeed\", \"bitmapspeed for dim2: \" + diff);\n        \n\t\treturn bmapMirror;\n\t}\n    \n    //covert to list view icon\n\tpublic static Bitmap getIconForListView(Bitmap largeImg)\n\t{\n\t\tfloat scaleFactor = 80f/largeImg.getHeight();\n\t\tMatrix m = new Matrix();\n\t\tm.postScale(scaleFactor, scaleFactor);\n\t\treturn Bitmap.createBitmap(largeImg, 0, 0, largeImg.getWidth(), largeImg.getHeight(), m, false);\n\t}\n\t\n\t\n\tpublic static Bitmap generateMovieThumbnail(String path)\n\t{\n\t\treturn ThumbnailUtils.createVideoThumbnail(path, Thumbnails.MINI_KIND);\t\n\t}\n\t\n\tpublic static List<File> getAllImagesFiles()\n\t{\n\t\tString cameraImagePath = \"/mnt/sdcard/DCIM/Camera/\";\n\t\tString photoPath =  Global.PATH_PHOTO_DATA;\n\t\tString externalPath = \"/mnt/extsd/\";\n\t\tList<File> fileList = new ArrayList<File>();\n\t\tFile cameraDir = new File(cameraImagePath);\n\t\ttraverseDirForPhoto(cameraDir, fileList);\n\t\tFile photoDir = new File(photoPath);\n\t\ttraverseDirForPhoto(photoDir, fileList);\n\t\tFile externalDir = new File(externalPath);\n\t\ttraverseDirForPhoto(externalDir, fileList); \n\t\tLog.d(\"getAllImagesFiles\", \"count:\" + fileList.size());\n\t\treturn fileList;\n\t}\n\t\n\tprivate static void traverseDirForPhoto(File dir, List<File> theList) {\n\t\tFile[] files = dir.listFiles();\n\t\tif (files != null) {\n\t\t\tfor (int i = 0; i < files.length; i++) {\n\t\t\t    // skip all files or folders starting with a dot\n\t\t\t    if (files[i].getName().startsWith(\".\")) {\n\t\t\t        continue;\n\t\t\t    }\n\t\t\t    \n\t\t\t\tif (files[i].isDirectory()) {\n\t\t\t\t\ttraverseDirForPhoto(files[i], theList);\n\t\t\t\t} else {\n\t\t\t\t\tif (!files[i].isHidden() && (files[i].getName().contains(Global.FILE_TYPE_PNG) || files[i].getName().contains(Global.FILE_TYPE_JPG))) {\n\t\t\t\t\t\ttheList.add(files[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static Bitmap bitmapResizeToLargePreviewIcon(Bitmap bmp) {\n\t\tfinal float MAX_W  = 256;\n\t\tfinal float MAX_H = 256;\n\t\tint h = bmp.getHeight();\n\t\tint w = bmp.getWidth();\n\t\tdouble scale = 1;\n\t\tif (h > w) {\n\t\t\tif (h < MAX_H) {\n\t\t\t\treturn bmp;\n\t\t\t}\n\t\t\tscale = MAX_H / h;\n\n\t\t} else {\n\t\t\tif (w < MAX_W) {\n\t\t\t\treturn bmp;\n\t\t\t}\n\t\t\tscale = MAX_W / w;\n\t\t}\n\t\th = (int) (h * scale);\n\t\tw = (int) (w * scale);\n\t\treturn Bitmap.createScaledBitmap(bmp, w, h, false);\n\t}\n\t\n\tpublic static Bitmap bitmapResizeToUserIcon(Bitmap bmp)\n\t{\n\t\tBitmap mutable = Bitmap.createBitmap(80, 80, Bitmap.Config.ARGB_8888);\n\t\tCanvas canvas = new Canvas(mutable);\n\t\tPaint paint = new Paint();\n\t\tpaint.setFilterBitmap(false);\n\n\t\tint oriH = bmp.getHeight();\n\t\tint oriW = bmp.getWidth();\n\t\tint h = 0;\n\t\tint w = 0;\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tBitmap resizeBmp = null;\n\t\tBitmap cropedBmp = null;\n\t\tif (oriH > 80) {\n\t\t\t//for pixel > 80;\n\t\t\tif (oriH > oriW) {\n\t\t\t\tw = 80;\n\t\t\t\th = (int) ((80f / oriW) * oriH);\n\t\t\t\tLog.d(\"usericon\", \"1 w:\" + w + \" h:\" + h + \" ow:\" + oriW + \" oh:\" + oriH);\n\t\t\t\tresizeBmp = Bitmap.createScaledBitmap(bmp, w, h, true);\n\t\t\t\tcropedBmp = Bitmap.createBitmap(resizeBmp, 0, (int) ((h - 80) / 2), 80, 80);\n\t\t\t} else {\n\t\t\t\th = 80;\n\t\t\t\tw = (int) ((80f / oriH) * oriW);\n\t\t\t\tLog.d(\"usericon\", \"2 w:\" + w + \" h:\" + h + \" ow:\" + oriW + \" oh:\" + oriH);\n\t\t\t\tresizeBmp = Bitmap.createScaledBitmap(bmp, w, h, true);\n\t\t\t\tcropedBmp = Bitmap.createBitmap(resizeBmp, (int) ((w - 80) / 2), 0, 80, 80);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//for pixel < 80;\n\t\t\ty = (int)((80 - oriH)/2);\n\t\t\tif(oriW >80)\n\t\t\t{\n\t\t\t\tcropedBmp = Bitmap.createBitmap(bmp, (int) ((oriW - 80) / 2), 0, 80, oriH);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcropedBmp = bmp;\n\t\t\t\tx = (int)((80 - oriW)/2);\n\t\t\t}\n\t\t}\n\t\t//Log.d(\"usericon\", \"3 w:\" + cropedBmp.getWidth() + \" h:\" + cropedBmp.getHeight() + \" ow:\" + mask.getWidth() + \" oh:\" + mask.getHeight());\n\t\t// Bitmap resizeBmp = bmp.createScaledBitmap(bmp, dstWidth, dstHeight,\n\t\t// filter)\n\n\t\tcanvas.drawBitmap(cropedBmp,x, y, paint);\n\t\treturn mutable;\n\t}\n\t\n\tpublic static Bitmap bitmapResizeToUserIcon300(Bitmap bmp)\n\t{\n\t\tBitmap mutable = Bitmap.createBitmap(300, 300, Bitmap.Config.ARGB_8888);\n\t\tCanvas canvas = new Canvas(mutable);\n\t\tPaint paint = new Paint();\n\t\tpaint.setFilterBitmap(false);\n\n\t\tint oriH = bmp.getHeight();\n\t\tint oriW = bmp.getWidth();\n\t\tint h = 0;\n\t\tint w = 0;\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tBitmap resizeBmp = null;\n\t\tBitmap cropedBmp = null;\n\t\tif (oriH > 30) {\n\t\t\t//for pixel > 300;\n\t\t\tif (oriH > oriW) {\n\t\t\t\tw = 300;\n\t\t\t\th = (int) ((300f / oriW) * oriH);\n\t\t\t\tLog.d(\"usericon\", \"1 w:\" + w + \" h:\" + h + \" ow:\" + oriW + \" oh:\" + oriH);\n\t\t\t\tresizeBmp = Bitmap.createScaledBitmap(bmp, w, h, true);\n\t\t\t\tcropedBmp = Bitmap.createBitmap(resizeBmp, 0, (int) ((h - 300) / 2), 300, 300);\n\t\t\t} else {\n\t\t\t\th = 300;\n\t\t\t\tw = (int) ((300f / oriH) * oriW);\n\t\t\t\tLog.d(\"usericon\", \"2 w:\" + w + \" h:\" + h + \" ow:\" + oriW + \" oh:\" + oriH);\n\t\t\t\tresizeBmp = Bitmap.createScaledBitmap(bmp, w, h, true);\n\t\t\t\tcropedBmp = Bitmap.createBitmap(resizeBmp, (int) ((w - 300) / 2), 0, 300, 300);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//for pixel < 300;\n\t\t\ty = (int)((300 - oriH)/2);\n\t\t\tif(oriW >300)\n\t\t\t{\n\t\t\t\tcropedBmp = Bitmap.createBitmap(bmp, (int) ((oriW - 300) / 2), 0, 300, oriH);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcropedBmp = bmp;\n\t\t\t\tx = (int)((300 - oriW)/2);\n\t\t\t}\n\t\t}\n\t\t//Log.d(\"usericon\", \"3 w:\" + cropedBmp.getWidth() + \" h:\" + cropedBmp.getHeight() + \" ow:\" + mask.getWidth() + \" oh:\" + mask.getHeight());\n\t\t// Bitmap resizeBmp = bmp.createScaledBitmap(bmp, dstWidth, dstHeight,\n\t\t// filter)\n\n\t\tcanvas.drawBitmap(cropedBmp,x, y, paint);\n\t\treturn mutable;\n\t}\n\t\n\t\n\tpublic static Bitmap generateUserIcon(Bitmap bmp, Bitmap bg, Bitmap mask, Bitmap cover) {\n\n\t\tif (bmp != null && bg != null && mask != null && cover != null) {\n\t\t\tBitmap mutable = Bitmap.createBitmap(80, 80, Bitmap.Config.ARGB_8888);\n\t\t\tCanvas canvas = new Canvas(mutable);\n\t\t\tPaint paint = new Paint();\n\t\t\tpaint.setFilterBitmap(false);\n\t\t\tcanvas.drawBitmap(bmp, 0, 0, paint);\n\t\t\tpaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));\n\t\t\tcanvas.drawBitmap(mask, 0, 0, paint);\n\t\t\tpaint.setXfermode(null);\n\t\t\tcanvas.drawBitmap(cover, 0, 0, paint);\n\n\t\t\treturn mutable;\n\t\t}\n\t\treturn null;\n\n\t}\n\t\n\tpublic static Bitmap generateUserIcon300(Bitmap bmp, Bitmap bg, Bitmap mask, Bitmap cover) {\n\n\t\tif (bmp != null && bg != null && mask != null && cover != null) {\n\t\t\tBitmap mutable = Bitmap.createBitmap(300, 300, Bitmap.Config.ARGB_8888);\n\t\t\tCanvas canvas = new Canvas(mutable);\n\t\t\tPaint paint = new Paint();\n\t\t\tpaint.setFilterBitmap(false);\n\t\t\tcanvas.drawBitmap(bmp, 0, 0, paint);\n\t\t\tpaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));\n\t\t\tcanvas.drawBitmap(mask, 0, 0, paint);\n\t\t\tpaint.setXfermode(null);\n\t\t\tcanvas.drawBitmap(cover, 0, 0, paint);\n\n\t\t\treturn mutable;\n\t\t}\n\t\treturn null;\n\n\t}\n\t\n\tprivate List<MediaItem> mMediaItemList;\n\t\n\tpublic List<MediaItem> getMediaItemList() {\n\t\treturn mMediaItemList;\n\t}\n\n\tpublic void setmMediaItemList(List<MediaItem> mediaItemList) {\n\t\tthis.mMediaItemList = mediaItemList;\n\t}\n\t\n\tpublic boolean changeFilePermission(File file) {\n\n\t\ttry {\n\t\t\tif (file.exists()) {\n\t\t\t\tString command = \"chmod 777 \" + file.getAbsolutePath();\n\t\t\t\tLog.i(\"zyl\", \"command = \" + command);\n\t\t\t\tRuntime runtime = Runtime.getRuntime();\n\t\t\t\tProcess proc = runtime.exec(command);\n\t\t\t\tproc.getOutputStream();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tLog.i(\"zyl\", \"chmod fail!!!!\");\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate final float INIT_ANGLE = -75;\n\tprivate final float SEP_ANGLE = 15;\n\t\n\t\n\tpublic static Bitmap getMovieLargeIcon(Bitmap oriBmp, Bitmap bmpBg, Bitmap bmpTop) {\n\t\ttry {\n\t\t\tif (oriBmp != null && bmpBg != null) {\n\t\t\t\tBitmap bmp = oriBmp;\n\t\t\t\tfloat scale = 296f / bmp.getWidth();\n\t\t\t\tMatrix matrix = new Matrix();\n\t\t\t\tmatrix.postScale(scale, scale);\n\n\t\t\t\tBitmap resizedBitmap = Bitmap.createBitmap(bmp, 0, 0, bmp.getWidth(), bmp.getHeight(), matrix, true);\n\t\t\t\tint cuty = (int) (resizedBitmap.getHeight() / 2 - 89);\n\t\t\t\tBitmap cropBitmap = null;\n\t\t\t\tif (resizedBitmap.getHeight() > 178) {\n\t\t\t\t\tcropBitmap = Bitmap.createBitmap(resizedBitmap, 0, cuty, resizedBitmap.getWidth(), 178);\n\t\t\t\t} else {\n\t\t\t\t\tcropBitmap = Bitmap.createBitmap(resizedBitmap, 0, 0, resizedBitmap.getWidth(), resizedBitmap.getHeight());\n\t\t\t\t}\n\n\t\t\t\tBitmap mutableBm = bmpBg.copy(Bitmap.Config.ARGB_8888, true);\n\t\t\t\tCanvas canvas = new Canvas(mutableBm);\n\t\t\t\tcanvas.drawBitmap(cropBitmap, 0, 60, null);\n\n\t\t\t\treturn mutableBm;\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t}\n\t\treturn null;\n\n\t}\n\t\n\tpublic static Bitmap getMusicLargeIcon(Bitmap bmp, Bitmap bmpBg, Bitmap bmpTop)\n\t{\n\t\tif (bmp == null || bmpBg == null || bmpTop == null) {\n\t\t\treturn null;\n\t\t}\t\n\t\t\n\t\ttry {\n\t\t\tfloat scale = 300f / bmp.getHeight();\n\t\t\tMatrix matrix = new Matrix();\n\t\t\tmatrix.postScale(scale, scale);\n\n\t\t\tBitmap resizedBitmap = Bitmap.createBitmap(bmp, 0, 0, bmp.getWidth(), bmp.getHeight(), matrix, true);\n\t\t\tint cutx = (int) (resizedBitmap.getWidth() / 2 - 150);\n\t\t\tBitmap cropBitmap = null;\n\t\t\tint moveX = 0;\n\t\t\tif (resizedBitmap.getWidth() > 300) {\n\t\t\t\tcropBitmap = Bitmap.createBitmap(resizedBitmap, cutx, 0, 300, resizedBitmap.getHeight());\n\t\t\t} else {\n\t\t\t\tmoveX = (int)((300 - resizedBitmap.getWidth())/2);\n\t\t\t\tcropBitmap = Bitmap.createBitmap(resizedBitmap, 0, 0, resizedBitmap.getWidth(), resizedBitmap.getHeight());\n\t\t\t}\n\t\t\tresizedBitmap.recycle();\n\n\t\t\tBitmap mutableBm = bmpBg.copy(Bitmap.Config.ARGB_8888, true);\n\t\t\tCanvas canvas = new Canvas(mutableBm);\n\t\t\t\n\t\t\tcanvas.drawBitmap(cropBitmap, 40 + moveX, 10, null);\n\t\t\tcanvas.drawBitmap(bmpTop, 0, 0, null);\n\t\t\t\n\t\t\tcropBitmap.recycle();\n\t\t\tbmpBg.recycle();\n\t\t\tbmpTop.recycle();\n\t\t\t\n\t\t\treturn mutableBm;\n\n\t\t} catch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static Bitmap getPhotoLargeIcon(Bitmap orgImage, Bitmap bottom, Bitmap top, int w, int h, int leftMargin, int topMargin)\n\t{\n\t\tBitmap bmpBg = bottom;\n\t\tBitmap bmpTop = top;\n\t\tBitmap bmp = orgImage;\n\t\tfloat scale = (float)h / bmp.getHeight();\n\t\tMatrix matrix = new Matrix();\n\t\tmatrix.postScale(scale, scale);\n\n\t\tBitmap resizedBitmap = Bitmap.createBitmap(bmp, 0, 0, bmp.getWidth(), bmp.getHeight(), matrix, true);\n\t\tint cutx = (int) (resizedBitmap.getWidth() / 2 - w/2);\n\t\tBitmap cropBitmap = null;\n\t\tint moveX = 0;\n\t\tif (resizedBitmap.getWidth() > w) {\n\t\t\tcropBitmap = Bitmap.createBitmap(resizedBitmap, cutx, 0, w, resizedBitmap.getHeight());\n\t\t} else {\n\t\t\tmoveX = (int)((w - resizedBitmap.getWidth())/2);\n\t\t\tcropBitmap = Bitmap.createBitmap(resizedBitmap, 0, 0, resizedBitmap.getWidth(), resizedBitmap.getHeight());\n\t\t}\n\n\t\tBitmap mutableBm = bmpBg.copy(Bitmap.Config.ARGB_8888, true);\n\t\tCanvas canvas = new Canvas(mutableBm);\n\t\t\n\t\tcanvas.drawBitmap(cropBitmap, leftMargin + moveX, topMargin, null);\n\t\tcanvas.drawBitmap(bmpTop, 0, 0, null);\n\t\t\n\t\treturn mutableBm;\n\t}\n\t\n\tpublic static Bitmap getEbookLargeIcon(Bitmap bitmap, Bitmap iconBg)\n\t{\n\t\tBitmap bmpBg = iconBg;\n\t\t//Bitmap bmp = bitmap;\n\t\tint h = 278;\n\t\tint w = 191;\n\t\t\n\t\tBitmap cropBitmap = ThumbnailUtils.extractThumbnail(bitmap, w, h);\n\n\t\tBitmap mutableBm = bmpBg.copy(Bitmap.Config.ARGB_8888, true);\n\t\tCanvas canvas = new Canvas(mutableBm);\n\t\t\n\t\tcanvas.drawBitmap(cropBitmap, 55, 17, null);\n\t\t\n\t\treturn mutableBm;\n\t}\n\t\n\tpublic static Bitmap getGameLargeIcon(Bitmap bitmap, Bitmap iconBg, Bitmap iconTop)\n\t{\n\t\tBitmap cropBitmap = ThumbnailUtils.extractThumbnail(bitmap, 300, 300);\n\n\t\t\tBitmap mutable = Bitmap.createBitmap(300, 300, Bitmap.Config.ARGB_8888);\n\t\t\tCanvas canvas = new Canvas(mutable);\n\t\t\tPaint paint = new Paint();\n\t\t\tpaint.setFilterBitmap(false);\n\t\t\tcanvas.drawBitmap(cropBitmap, 0, 0, paint);\n\t\t\tpaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));\n\t\t\tcanvas.drawBitmap(iconBg, 0, 0, paint);\n\t\t\tpaint.setXfermode(null);\n\t\t\tcanvas.drawBitmap(iconTop, 0, 0, paint);\n\n\t\t\treturn mutable;\n\t}\n\t\n\tpublic static Bitmap getGameLargeIcon2(Bitmap bitmap, Bitmap iconBg, Bitmap iconTop)\n\t{\n\t\tBitmap cropBitmap = null;\n\t\tif (bitmap.getHeight() >= 300 || bitmap.getWidth() >= 300) {\n\t\t\tcropBitmap = ThumbnailUtils.extractThumbnail(bitmap, 300, 300);\n\t\t}else{\n\t\t\tLog.d(\"gameLargeIconSize\", \"w:\" + bitmap.getWidth() + \" h:\" + bitmap.getHeight());\n\t\t\tcropBitmap = bitmap;\n\t\t}\n\n\t\t\tBitmap mutable = Bitmap.createBitmap(300, 300, Bitmap.Config.ARGB_8888);\n\t\t\tCanvas canvas = new Canvas(mutable);\n\t\t\tPaint paint = new Paint();\n\t\t\tpaint.setFilterBitmap(false);\n\t\t\tcanvas.drawBitmap(cropBitmap, 0, 0, paint);\n\t\t\tpaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));\n\t\t\tcanvas.drawBitmap(iconBg, 0, 0, paint);\n\t\t\tpaint.setXfermode(null);\n\t\t\tcanvas.drawBitmap(iconTop, 0, 0, paint);\n\n\t\t\treturn mutable;\n\t}\n\t\n\tpublic static Bitmap getIconForGooglePlayItem(Bitmap bitmap, Bitmap iconBg, Bitmap iconTop) {\n\t\tif (bitmap.getWidth() < 300) {\n\t\t\tbitmap = Bitmap.createScaledBitmap(bitmap, 96, 96, false);\n\t\t}\n\t\t\n\t\tBitmap mutable = Bitmap.createBitmap(300, 300, Bitmap.Config.ARGB_8888);\n\t\tCanvas canvas = new Canvas(mutable);\n\t\tPaint paint = new Paint();\n\t\tcanvas.drawBitmap(iconBg, 0, 0, paint);\n\t\tcanvas.drawBitmap(bitmap, 98, 52, paint);\n\t\t\n//\t\tif (iconTop != null) {\n//\t\t\tcanvas.drawBitmap(iconTop, 0, 0, paint);\n//\t\t}\n\t\t\n\t\treturn mutable;\n\t}\n\n}", "class_id": 0, "repo": "zoozooll/MyExercise", "file": "meep/MeepLib/src/com/oregonscientific/meep/opengl/MediaManager.java", "last_update_at": "2020-08-06T06:24:06+00:00", "question_id": "ba6bd19862484398fb77a257adb873a9f8ee25c3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MediaManager {\n\t\n\tpublic MediaManager()\n\t{\n\t\tmMediaItemList = new ArrayList<MediaItem>();\n\t}\n\tprivate String[] getFilesOfDirectory(String folder) {\n\t\tFile file = new File(Environment.getExternalStorageDirectory(), folder);\n\t\tif (file.exists()) {\n\t\t\tif (file.isDirectory()) {\n\t\t\t\treturn file.list();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tprivate String getBitmapFileAddr(String addr)\n\t{\n\t\tFile file = new File(Environment.getExternalStorageDirectory(), addr);\n\t\tif(file.exists())\n\t\t{\n\t\t\treturn file.getAbsolutePath();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn \"\";\n\t\t}\n\t}\n\t\n\tpublic enum MediaType\n\t{\n\t\tMovie,\n\t\tAudio\n\t}\n\t\n\tpublic void LoadMedia(MediaType mediaType)\n\t{\n\t\tmMediaItemList.clear();\n\t\tString[] files = getFilesOfDirectory(mediaType.toString());\n\t\tfor(int i =0; i<files.length; i++)\n\t\t{\n\t\t\tif(files[i].contains(\".3gp\"))\n\t\t\t{\n\t\t\t\tMediaItem item = new MediaItem();\n\t\t\t\tString name = files[i].substring(0, files[i].length()-4);\n\t\t\t\titem.setName(name);\n\t\t\t\titem.setImageAddr(getBitmapFileAddr(mediaType.toString() + File.separator + name + \".png\"));\n\t\t\t\titem.setPath(Environment.getExternalStorageDirectory() +File.separator+ mediaType.toString() + File.separator+files[i]);\n\t\t\t\titem.setAngle(INIT_ANGLE + SEP_ANGLE * mMediaItemList.size());\n\t\t\t\titem.setTransform(new ESTransform());\n\t\t\t\tmMediaItemList.add(item);\n\t\t\t}\n\t\t\t\n\t\t\tif(files[i].contains(\".mp3\"))\n\t\t\t{\n\t\t\t\tMediaItem item = new MediaItem();\n\t\t\t\tString name = files[i].substring(0, files[i].length()-4);\n\t\t\t\titem.setName(name);\n\t\t\t\titem.setImageAddr(getBitmapFileAddr(mediaType.toString() + File.separator + name + \".png\"));\n\t\t\t\titem.setPath(Environment.getExternalStorageDirectory() +File.separator+ mediaType.toString() + File.separator+files[i]);\n\t\t\t\titem.setAngle(INIT_ANGLE + SEP_ANGLE * mMediaItemList.size());\n\t\t\t\titem.setTransform(new ESTransform());\n\t\t\t\tmMediaItemList.add(item);\n\t\t\t}\n\t\t}\n\t}\n\tpublic static Bitmap LoadBitmapFile(String path) throws Exception{\n\t\tFileInputStream in;\n\t\tBufferedInputStream buf;\n\t\ttry {\n\t\t\t//in = new FileInputStream(\"/sdcard/test2.png\");\n\t\t\tin = new FileInputStream(path);\n\t\t\tbuf = new BufferedInputStream(in);\n\t\t\tbyte[] bMapArray = new byte[buf.available()];\n\t\t\tbuf.read(bMapArray);\n\t\t\tBitmapFactory.Options bmOption = new BitmapFactory.Options();\n\t        bmOption.inPreferredConfig = Config.ARGB_8888;\n\t        bmOption.inSampleSize = 2;\n\t\t\tBitmap bMap = BitmapFactory.decodeByteArray(bMapArray, 0,\n\t\t\t\t\tbMapArray.length,bmOption);\n\t\t\tif (in != null) {\n\t\t\t\tin.close();\n\t\t\t}\n\t\t\tif (buf != null) {\n\t\t\t\tbuf.close();\n\t\t\t}\n\t\t\treturn bMap;\n\t\t} catch (Exception e) {\n\t\t\tLog.e(\"Error reading file\", e.toString());\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * \n\t * @param ids\n\t * @return\n\t */\n\tstatic int[] genTextureIds(int[] ids) {\n\t\tGLES20.glGenTextures(ids.length, ids, 0);\n\t\treturn ids;\n\t}\n\t\n\tpublic static int[] combine(int[] a, int[] b)\n\t{\n\t\tint alen = a.length;\n\t\tint blen = b.length;\n\t\tint clen = alen+blen;\n\t\n\t\tint[] c = new int[clen];\n\t\tSystem.arraycopy(a,0,c,0,alen);\n\t\tSystem.arraycopy(b,0,c,alen,blen);\n\t\n\t\treturn c;\n\t}\n\t\n\t///\n    //  Load texture from resource\n    //\n    public static int loadTexture ( Bitmap bitmap )\n    {\n    \t//long time1 = System.currentTimeMillis();\n        int[] textureId = new int[1];\n        GLES20.glGenTextures ( 1, textureId, 0 );\n        GLES20.glBindTexture ( GLES20.GL_TEXTURE_2D, textureId[0] );\n        GLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR );\n        GLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR );\n        GLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE );\n        GLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE );\n        GLES20.glEnable(GLES20.GL_BLEND);\n        GLES20.glBlendFunc(GLES20.GL_ONE, GLES20.GL_ONE_MINUS_SRC_ALPHA);\n        try{\n        GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bitmap, 0);\n        }\n        catch(Exception ex)\n        {\n        \tex.printStackTrace();\n        }\n       // Log.d(\"bitmap\", \"load bitmap:\" + bitmap + \" return :\" + textureId[0]);\n//        long timediff = System.currentTimeMillis() - time1;\n//        \n//        Log.d(\"performance\", \"load texture:\" + timediff);\n        return textureId[0];\n    }\n    /**\n     * bind texture with a general texture id, and draw the texture\n     * @author aaronli\n     * @since Mar 12,2013\n     * @param textureId\n     * @param b\n     */\n    public static void loadSingleTexImage(int textureId, Bitmap b) {\n    \t//long time1 = System.currentTimeMillis();\n    \tGLES20.glBindTexture ( GLES20.GL_TEXTURE_2D, textureId );\n    \tGLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR );\n\t\tGLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR );\n\t\tGLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE );\n\t\tGLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE );\n\t\t\n\t\tGLES20.glEnable(GLES20.GL_BLEND);\n\t\tGLES20.glBlendFunc(GLES20.GL_ONE, GLES20.GL_ONE_MINUS_SRC_ALPHA);\n\t\t\n\t\ttry{\n\t\t\tGLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, b, 0);\n\t\t}\n\t\tcatch(Exception ex)\n\t\t{\n\t\t\tex.printStackTrace();\n\t\t}\n\t\t//long timediff = System.currentTimeMillis() - time1;\n//     //  \n       //Log.d(\"performance\", \"load texture: \" + textureId + \"     \" + timediff);\n    \t\n    }\n    public static Bitmap loadProperImage(String path, int reqWidth, int reqHeight)\n    {\n    \t // First decode with inJustDecodeBounds=true to check dimensions\n        final BitmapFactory.Options options = new BitmapFactory.Options();\n        options.inJustDecodeBounds = true;\n        BitmapFactory.decodeFile(path, options);\n        // Calculate inSampleSize\n        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);\n        // Decode bitmap with inSampleSize set\n        options.inJustDecodeBounds = false;\n        return BitmapFactory.decodeFile(path, options);\n    }\n\tpublic static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {\n\t\t// Raw height and width of image\n\t\tfinal int height = options.outHeight;\n\t\tfinal int width = options.outWidth;\n\t\tint inSampleSize = 1;\n\t\tif (height > reqHeight || width > reqWidth) {\n\t\t\tif (width > height) {\n\t\t\t\tinSampleSize = Math.round((float) height / (float) reqHeight);\n\t\t\t} else {\n\t\t\t\tinSampleSize = Math.round((float) width / (float) reqWidth);\n\t\t\t}\n\t\t}\n\t\treturn inSampleSize;\n\t}\n    public static void releaseTexture(int id)\n    {\n    \t GLES20.glDeleteTextures(1, IntBuffer.wrap(new int[] {id}));\n    }\n    public static int getTitleTextureId(String text, int fontSize, int color, Align align)\n    {\n    \treturn getTextureIdByText(text, fontSize, color, 550, 50,0,35, align);\n    }\n    public static int getTitleTextureId(String text, int fontSize, int color)\n    {\n    \treturn getTextureIdByText(text, fontSize, color, 550, 50,0,35);\n    }\n    public static int getIconTextureId(String text, int fontSize, int color)\n    {\n    \treturn getTextureIdByText(text, fontSize, color, 128, 128, 10,115);\n    }\n    private static int getTextureIdByText(String text, int fontSize, int color, int w, int h, int x, int y,Align align )\n    {\n    \t//long time1 = System.currentTimeMillis();\n    \t\n    \t// Create an empty, mutable bitmap\n    \tBitmap bitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);\n    \t// get a canvas to paint over the bitmap\n    \tCanvas canvas = new Canvas(bitmap);\n    \tbitmap.eraseColor(0);\n    \t// Draw the text\n    \tPaint textPaint = new Paint();\n    \ttextPaint.setTextSize(fontSize);\n    \ttextPaint.setAntiAlias(true);\n    \ttextPaint.setTextAlign(align);\n    \ttextPaint.setFakeBoldText(true);\n    \t//textPaint.setARGB(0xff, 0xff, 0x00, 0x00);\n    \ttextPaint.setColor(color);\n    \t// deleted by aaronli Jul8 2013/ removed the shadow of titles\n    \t//textPaint.setShadowLayer(5f, 2f, 2f, Color.argb(180, 0, 0, 0));\n    \t\n    \t// draw the text centered\n\t\tcanvas.drawText(text, x, y, textPaint);\n\t\tint[] textureId = new int[1];\n\t\tGLES20.glGenTextures(1, textureId, 0);\n\t\tGLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId[0]);\n\t\tGLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,\n\t\t\t\tGLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);\n\t\tGLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,\n\t\t\t\tGLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);\n\t\tGLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S,\n\t\t\t\tGLES20.GL_CLAMP_TO_EDGE);\n\t\tGLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T,\n\t\t\t\tGLES20.GL_CLAMP_TO_EDGE);\n\t\tGLES20.glEnable(GLES20.GL_BLEND);\n\t\tGLES20.glBlendFunc(GLES20.GL_ONE, GLES20.GL_ONE_MINUS_SRC_ALPHA);\n\t\t// Use the Android GLUtils to specify a two-dimensional texture image\n\t\t// from our bitmap\n\t\tGLUtils.texImage2D(GL10.GL_TEXTURE_2D, 0, bitmap, 0);\n\t\tMediaManager.saveImageToExternal(bitmap, \"/mnt/sdcard/5.png\");\n\t\tLog.d(\"getTextTextureId\", \"save img\");\n    \t//Clean up\n    \tbitmap.recycle();\n    \t\n    \t //long timediff = System.currentTimeMillis() - time1;\n        // Log.d(\"performance\", \"load texture(draw text):\" + timediff);\n    \t\n    \treturn textureId[0];\n    }\n    private static int getTextureIdByText(String text, int fontSize, int color, int w, int h, int x, int y)\n    {\n    \t//long time1 = System.currentTimeMillis();\n    \t\n    \t// Create an empty, mutable bitmap\n    \tBitmap bitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);\n    \t// get a canvas to paint over the bitmap\n    \tCanvas canvas = new Canvas(bitmap);\n    \tbitmap.eraseColor(0);\n    \t// Draw the text\n    \tPaint textPaint = new Paint();\n    \ttextPaint.setTextSize(fontSize);\n    \ttextPaint.setAntiAlias(true);\n    \ttextPaint.setTextAlign(Align.CENTER);\n    \ttextPaint.setFakeBoldText(true);\n    \t//textPaint.setARGB(0xff, 0xff, 0x00, 0x00);\n    \ttextPaint.setColor(color);\n    \ttextPaint.setShadowLayer(5f, 2f, 2f, Color.argb(180, 0, 0, 0));\n    \t\n    \t// draw the text centered\n\t\tcanvas.drawText(text, x, y, textPaint);\n\t\tint[] textureId = new int[1];\n\t\tGLES20.glGenTextures(1, textureId, 0);\n\t\tGLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId[0]);\n\t\tGLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,\n\t\t\t\tGLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);\n\t\tGLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,\n\t\t\t\tGLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);\n\t\tGLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S,\n\t\t\t\tGLES20.GL_CLAMP_TO_EDGE);\n\t\tGLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T,\n\t\t\t\tGLES20.GL_CLAMP_TO_EDGE);\n\t\tGLES20.glEnable(GLES20.GL_BLEND);\n\t\tGLES20.glBlendFunc(GLES20.GL_ONE, GLES20.GL_ONE_MINUS_SRC_ALPHA);\n\t\t// Use the Android GLUtils to specify a two-dimensional texture image\n\t\t// from our bitmap\n\t\tGLUtils.texImage2D(GL10.GL_TEXTURE_2D, 0, bitmap, 0);\n\t\tMediaManager.saveImageToExternal(bitmap, \"/mnt/sdcard/5.png\");\n\t\tLog.d(\"getTextTextureId\", \"save img\");\n    \t//Clean up\n    \tbitmap.recycle();\n    \t\n    \t //long timediff = System.currentTimeMillis() - time1;\n        // Log.d(\"performance\", \"load texture(draw text):\" + timediff);\n    \t\n    \treturn textureId[0];\n    }\n    public static Bitmap getDimImage(Bitmap bitmap)\n\t{\n    \tlong timea = System.currentTimeMillis();\n    \tint opacity = 64;\n        Bitmap mutableBitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true);\n        //draw the bitmap into a canvas\n        Canvas canvas = new Canvas(mutableBitmap);\n        //create a color with the specified opacity\n        int colour = (opacity & 0xFF) << 24;\n        //draw the colour over the bitmap using PorterDuff mode DST_IN\n        canvas.drawColor(colour, PorterDuff.Mode.DST_IN);\n        long diff = System.currentTimeMillis() - timea;\n        Log.d(\"bitmapspeed\", \"bitmapspeed for dim1: \" + diff);\n        //now return the adjusted bitmap\n        return mutableBitmap;\n\t}\n    public static Bitmap getDimImage2(Bitmap bitmap)\n\t{\n    \tlong timea = System.currentTimeMillis();\n    \t //make sure bitmap is mutable (copy of needed)\n        Bitmap mutableBitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true);\n        int h = bitmap.getHeight();\n        int w = bitmap.getWidth();\n        int[] pixels = new  int[w*h];\n        bitmap.getPixels(pixels, 0, w, 0, 0, w,h);\n        for(int i=0; i< pixels.length; i++)\n        {\n        \tint pixel = pixels[i];\n        \tint a = (pixel & 0xFF000000) >> 24;\n        \tint r = ((pixel & 0x00FF0000) >> 16)/2;\n        \tint g = ((pixel & 0x0000FF00) >> 8)/2;\n        \tint b = (pixel & 0x000000FF)/2;\n        \tpixels[i] = Color.argb(a, r, g, b);\n        }\n        mutableBitmap.setPixels(pixels, 0, w, 0, 0, w, h);\n        long diff = System.currentTimeMillis() - timea;\n        Log.d(\"bitmapspeed\", \"bitmapspeed for dim2: \" + diff);\n        //now return the adjusted bitmap\n        return mutableBitmap;\n\t}\n\tpublic static Bitmap getDimImage3(Bitmap oriImage)\n\t{\n\t\tlong timea = System.currentTimeMillis();\n\t\t\n\t\tint width = oriImage.getWidth();\n\t\tint height = oriImage.getHeight();\n\t\tint argb = 0;\n\t\tBitmap bmapCoverDim = Bitmap.createBitmap(width,height, Config.ARGB_8888);\n\t\tfor (int i = 0; i < width; i++) {\n\t\t\tfor (int j = 0; j < height; j++) {\n\t\t\t\targb = oriImage.getPixel(i, j);\n\t\t\t\tint alpha = argb >> 24;\n\t\t\t\tint red = (argb & 0x00FF0000) >> 16;\n\t\t\t\tint green = (argb & 0x0000FF00) >> 8;\n\t\t\t\tint blue = (argb & 0x000000FF); \n\t\t\t\tred = (int) (red * 0.5f);\n\t\t\t\tgreen = (int) (green * 0.5f);\n\t\t\t\tblue = (int) (blue * 0.5f);\n\t\t\t\tbmapCoverDim.setPixel(i, j, Color.argb(alpha, red, green, blue));\n\t\t\t}\n\t\t}\n\t\t\n        long diff = System.currentTimeMillis() - timea;\n        Log.d(\"bitmapspeed\", \"bitmapspeed for dim3: \" + diff);\n\t\treturn bmapCoverDim;\n\t}\n\t\n\tpublic static void saveImageToExternalWithFullQuality(Bitmap bmp, String path) {\n\t\tOutputStream os = null;\n\t\ttry {\n\t\t\tos = new FileOutputStream(path);\n\t\t\tbmp.compress(CompressFormat.PNG, 100, os);\n\t\t\tLog.w(\"mediaManager\", \"saveImage to :\" + path);\n\t\t\tos.flush();\n\t\t\tos.close();\n\t\t} catch (Exception e) {\n\t\t\tLog.w(\"mediaManager\", \"saveImage fail:\" + e.toString());\n\t\t}\n\t}\n    public static void saveImageToExternal(Bitmap bmp, String path)\n\t{\n\t\tOutputStream os = null;\n\t\ttry {\n\t\t\tos = new FileOutputStream(path);\n\t\t\tbmp.compress(CompressFormat.PNG, 80, os);\n\t\t\tLog.w(\"mediaManager\",\"saveImage to :\" + path);\n\t\t\tos.flush();\n\t\t\tos.close();\n\t\t} catch (Exception e) {\n\t\t\tLog.w(\"mediaManager\",\"saveImage fail:\" + e.toString());\n\t\t}\n\t}\n    public static void saveImageToInternal(Context context, Bitmap bmp, String fileName){\n    \tFileOutputStream fos;\n\t\ttry {\n\t\t\tfos = context.openFileOutput(fileName, Context.MODE_PRIVATE);\n\t\t\tbmp.compress(CompressFormat.PNG, 80, fos);\n\t\t\t\n\t    \ttry {\n\t    \t\tfos.flush();\n\t\t\t\tfos.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t} catch (FileNotFoundException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    }\n    public static void saveImageToInternal(Bitmap bmp, String fullFilePath){\n    \tFileOutputStream fos;\n\t\ttry {\n\t\t\tFile file = new File(fullFilePath);\n\t\t\tfos = new FileOutputStream(file);\n\t\t\tbmp.compress(CompressFormat.PNG, 80, fos);\n\t    \ttry {\n\t    \t\tfos.flush();\n\t\t\t\tfos.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t} catch (FileNotFoundException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    }\n    public static boolean deleteInternalFile(Context context, String mPath)\n    {\n    \tFile file = context.getFilesDir();\n    \treturn file.delete();\n    }\n\tpublic static File getDataDir(Context context) {\n\t\treturn context.getDir(\"data\", Context.MODE_PRIVATE);\n\t}\n    public static File getLargeIconDir(Context context)\n    {\n    \tFile file = context.getDir(\"icon_l\", Context.MODE_PRIVATE);\n    \treturn file;\n    }\n    public static File getDimIconDir(Context context)\n    {\n    \tFile file = context.getDir(\"icon_ld\", Context.MODE_PRIVATE);\n    \treturn file;\n    }\n    public static File getMirrorIconDir(Context context)\n    {\n    \tFile file = context.getDir(\"icon_lm\", Context.MODE_PRIVATE);\n    \treturn file;\n    }\n    public static File getSmallIconDir(Context context)\n    {\n    \tFile file = context.getDir(\"icon_s\", Context.MODE_PRIVATE);\n    \treturn file;\n    }\n\tpublic static Bitmap loadInternalImage(Context context, String fileName) {\n\t\tString path = Environment.getDataDirectory().toString() + File.separator + \"data\" + File.separator + context.getPackageName() + File.separator + \"files\" + File.separator +fileName;\n\t\tLog.d(\"mediaMgr\", \"loadInternalImage path:\" + path);\n\t\treturn BitmapFactory.decodeFile(path);\n\t}\n\t\n\tpublic static File getDir(Context context, String name)\n\t{\n\t\treturn context.getDir(name, Context.MODE_PRIVATE);\n\t}\n\t\n\t\n\tpublic static String getInternalFilePath(Context context, String fileName) {\n\t\treturn Environment.getDataDirectory().toString() + File.separator + \"data\" + File.separator + context.getPackageName() + File.separator + \"files\" + File.separator +fileName;\n\t}\n    public static Bitmap getReflectionImage(Bitmap bmap) {\n    \tlong timea = System.currentTimeMillis();\n\t\t// change image color to dim\n    \tint pixelCount =0;\n\t\tint width = bmap.getWidth();\n\t\tint oriHeight = bmap.getHeight();\n\t\tint height = (int) (bmap.getHeight() * 1.5f);\n\t\tint MAX_PIXEL_COUNT = width * height -1;\n\t\t//Bitmap copyBmp = bmap.copy(Config.ARGB_8888, true);\n\t\t\n\t\tBitmap bmapMirror = Bitmap.createBitmap(width, height, Config.ARGB_8888);\n\t\tint[] pixels = new int[width * height];\n\t\tbmap.getPixels(pixels, 0, width, 0, 0, width, oriHeight);\n\t\tpixelCount = width* oriHeight -1;\n\t\tint half = (int) (bmap.getHeight() / 2);\n\t\t//int[] mirrorPixel = new int[width * (height-oriHeight)];\n\t\tfor(int i=oriHeight-1; i>=height - oriHeight; i--)\n\t\t{\n\t\t\tint alpha = 0;\n\t\t\tif (oriHeight - 1 > 128) {\n\t\t\t\talpha = (int) (128 * ((i - 128) * 1.0f / half));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\talpha = (int) (128 * ((i - half) * 1.0f / half));\n\t\t\t}\n\t\t\t//Log.d(\"performance\", \"load pixel row:\" + i + \" alpha:\" + alpha);\n\t\t\tint[] row = new int[width];\n\t\t\tbmap.getPixels(row, 0, width, 0, i, width, 1);\n\t\t\tfor (int j = 0; j < row.length; j++) {\n\t\t\t\tint argb = row[j];\n\t\t\t\tint a = (argb & 0xFF000000) >> 24;\n\t\t\t\tint red = (argb & 0x00FF0000) >> 16;\n\t\t\t\tint green = (argb & 0x0000FF00) >> 8;\n\t\t\t\tint blue = (argb & 0x000000FF);\n\t\t\t\t//Log.d(\"performance\", \"load pixel row:\" + i + \" alpha:\" + alpha + \"  a:\" + a);\n\t\t\t\tint pixel = Color.argb(alpha, red, green, blue);\n\t\t\t\t\n\t\t\t\tif (a == 0) {\n\t\t\t\t\tpixels[pixelCount] = row[j];\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tpixels[pixelCount] = pixel;\n\t\t\t\t}\n\t\t\t\tpixelCount++;\n\t\t\t\tif(pixelCount>MAX_PIXEL_COUNT)\n\t\t\t\t{\n\t\t\t\t\tLog.w(\"getReflectionImage\", \"the pixel count larger than max count\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t}\n\t\tLog.d(\"mirror test\", \"mirror test\");\n\t\tbmapMirror.setPixels(pixels,0,width,0,0,width, height);\t\t\n\t\t\n        long diff = System.currentTimeMillis() - timea;\n        Log.d(\"bitmapspeed\", \"bitmapspeed for dim2: \" + diff);\n\t\treturn bmapMirror;\n\t}\n    //covert to list view icon\n\tpublic static Bitmap getIconForListView(Bitmap largeImg)\n\t{\n\t\tfloat scaleFactor = 80f/largeImg.getHeight();\n\t\tMatrix m = new Matrix();\n\t\tm.postScale(scaleFactor, scaleFactor);\n\t\treturn Bitmap.createBitmap(largeImg, 0, 0, largeImg.getWidth(), largeImg.getHeight(), m, false);\n\t}\n\t\n\t\n\tpublic static Bitmap generateMovieThumbnail(String path)\n\t{\n\t\treturn ThumbnailUtils.createVideoThumbnail(path, Thumbnails.MINI_KIND);\t\n\t}\n\t\n\tpublic static List<File> getAllImagesFiles()\n\t{\n\t\tString cameraImagePath = \"/mnt/sdcard/DCIM/Camera/\";\n\t\tString photoPath =  Global.PATH_PHOTO_DATA;\n\t\tString externalPath = \"/mnt/extsd/\";\n\t\tList<File> fileList = new ArrayList<File>();\n\t\tFile cameraDir = new File(cameraImagePath);\n\t\ttraverseDirForPhoto(cameraDir, fileList);\n\t\tFile photoDir = new File(photoPath);\n\t\ttraverseDirForPhoto(photoDir, fileList);\n\t\tFile externalDir = new File(externalPath);\n\t\ttraverseDirForPhoto(externalDir, fileList); \n\t\tLog.d(\"getAllImagesFiles\", \"count:\" + fileList.size());\n\t\treturn fileList;\n\t}\n\t\n\tprivate static void traverseDirForPhoto(File dir, List<File> theList) {\n\t\tFile[] files = dir.listFiles();\n\t\tif (files != null) {\n\t\t\tfor (int i = 0; i < files.length; i++) {\n\t\t\t    // skip all files or folders starting with a dot\n\t\t\t    if (files[i].getName().startsWith(\".\")) {\n\t\t\t        continue;\n\t\t\t    }\n\t\t\t    \n\t\t\t\tif (files[i].isDirectory()) {\n\t\t\t\t\ttraverseDirForPhoto(files[i], theList);\n\t\t\t\t} else {\n\t\t\t\t\tif (!files[i].isHidden() && (files[i].getName().contains(Global.FILE_TYPE_PNG) || files[i].getName().contains(Global.FILE_TYPE_JPG))) {\n\t\t\t\t\t\ttheList.add(files[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static Bitmap bitmapResizeToLargePreviewIcon(Bitmap bmp) {\n\t\tfinal float MAX_W  = 256;\n\t\tfinal float MAX_H = 256;\n\t\tint h = bmp.getHeight();\n\t\tint w = bmp.getWidth();\n\t\tdouble scale = 1;\n\t\tif (h > w) {\n\t\t\tif (h < MAX_H) {\n\t\t\t\treturn bmp;\n\t\t\t}\n\t\t\tscale = MAX_H / h;\n\t\t} else {\n\t\t\tif (w < MAX_W) {\n\t\t\t\treturn bmp;\n\t\t\t}\n\t\t\tscale = MAX_W / w;\n\t\t}\n\t\th = (int) (h * scale);\n\t\tw = (int) (w * scale);\n\t\treturn Bitmap.createScaledBitmap(bmp, w, h, false);\n\t}\n\t\n\tpublic static Bitmap bitmapResizeToUserIcon(Bitmap bmp)\n\t{\n\t\tBitmap mutable = Bitmap.createBitmap(80, 80, Bitmap.Config.ARGB_8888);\n\t\tCanvas canvas = new Canvas(mutable);\n\t\tPaint paint = new Paint();\n\t\tpaint.setFilterBitmap(false);\n\t\tint oriH = bmp.getHeight();\n\t\tint oriW = bmp.getWidth();\n\t\tint h = 0;\n\t\tint w = 0;\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tBitmap resizeBmp = null;\n\t\tBitmap cropedBmp = null;\n\t\tif (oriH > 80) {\n\t\t\t//for pixel > 80;\n\t\t\tif (oriH > oriW) {\n\t\t\t\tw = 80;\n\t\t\t\th = (int) ((80f / oriW) * oriH);\n\t\t\t\tLog.d(\"usericon\", \"1 w:\" + w + \" h:\" + h + \" ow:\" + oriW + \" oh:\" + oriH);\n\t\t\t\tresizeBmp = Bitmap.createScaledBitmap(bmp, w, h, true);\n\t\t\t\tcropedBmp = Bitmap.createBitmap(resizeBmp, 0, (int) ((h - 80) / 2), 80, 80);\n\t\t\t} else {\n\t\t\t\th = 80;\n\t\t\t\tw = (int) ((80f / oriH) * oriW);\n\t\t\t\tLog.d(\"usericon\", \"2 w:\" + w + \" h:\" + h + \" ow:\" + oriW + \" oh:\" + oriH);\n\t\t\t\tresizeBmp = Bitmap.createScaledBitmap(bmp, w, h, true);\n\t\t\t\tcropedBmp = Bitmap.createBitmap(resizeBmp, (int) ((w - 80) / 2), 0, 80, 80);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//for pixel < 80;\n\t\t\ty = (int)((80 - oriH)/2);\n\t\t\tif(oriW >80)\n\t\t\t{\n\t\t\t\tcropedBmp = Bitmap.createBitmap(bmp, (int) ((oriW - 80) / 2), 0, 80, oriH);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcropedBmp = bmp;\n\t\t\t\tx = (int)((80 - oriW)/2);\n\t\t\t}\n\t\t}\n\t\t//Log.d(\"usericon\", \"3 w:\" + cropedBmp.getWidth() + \" h:\" + cropedBmp.getHeight() + \" ow:\" + mask.getWidth() + \" oh:\" + mask.getHeight());\n\t\t// Bitmap resizeBmp = bmp.createScaledBitmap(bmp, dstWidth, dstHeight,\n\t\t// filter)\n\t\tcanvas.drawBitmap(cropedBmp,x, y, paint);\n\t\treturn mutable;\n\t}\n\t\n\tpublic static Bitmap bitmapResizeToUserIcon300(Bitmap bmp)\n\t{\n\t\tBitmap mutable = Bitmap.createBitmap(300, 300, Bitmap.Config.ARGB_8888);\n\t\tCanvas canvas = new Canvas(mutable);\n\t\tPaint paint = new Paint();\n\t\tpaint.setFilterBitmap(false);\n\t\tint oriH = bmp.getHeight();\n\t\tint oriW = bmp.getWidth();\n\t\tint h = 0;\n\t\tint w = 0;\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tBitmap resizeBmp = null;\n\t\tBitmap cropedBmp = null;\n\t\tif (oriH > 30) {\n\t\t\t//for pixel > 300;\n\t\t\tif (oriH > oriW) {\n\t\t\t\tw = 300;\n\t\t\t\th = (int) ((300f / oriW) * oriH);\n\t\t\t\tLog.d(\"usericon\", \"1 w:\" + w + \" h:\" + h + \" ow:\" + oriW + \" oh:\" + oriH);\n\t\t\t\tresizeBmp = Bitmap.createScaledBitmap(bmp, w, h, true);\n\t\t\t\tcropedBmp = Bitmap.createBitmap(resizeBmp, 0, (int) ((h - 300) / 2), 300, 300);\n\t\t\t} else {\n\t\t\t\th = 300;\n\t\t\t\tw = (int) ((300f / oriH) * oriW);\n\t\t\t\tLog.d(\"usericon\", \"2 w:\" + w + \" h:\" + h + \" ow:\" + oriW + \" oh:\" + oriH);\n\t\t\t\tresizeBmp = Bitmap.createScaledBitmap(bmp, w, h, true);\n\t\t\t\tcropedBmp = Bitmap.createBitmap(resizeBmp, (int) ((w - 300) / 2), 0, 300, 300);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//for pixel < 300;\n\t\t\ty = (int)((300 - oriH)/2);\n\t\t\tif(oriW >300)\n\t\t\t{\n\t\t\t\tcropedBmp = Bitmap.createBitmap(bmp, (int) ((oriW - 300) / 2), 0, 300, oriH);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcropedBmp = bmp;\n\t\t\t\tx = (int)((300 - oriW)/2);\n\t\t\t}\n\t\t}\n\t\t//Log.d(\"usericon\", \"3 w:\" + cropedBmp.getWidth() + \" h:\" + cropedBmp.getHeight() + \" ow:\" + mask.getWidth() + \" oh:\" + mask.getHeight());\n\t\t// Bitmap resizeBmp = bmp.createScaledBitmap(bmp, dstWidth, dstHeight,\n\t\t// filter)\n\t\tcanvas.drawBitmap(cropedBmp,x, y, paint);\n\t\treturn mutable;\n\t}\n\t\n\t\n\tpublic static Bitmap generateUserIcon(Bitmap bmp, Bitmap bg, Bitmap mask, Bitmap cover) {\n\t\tif (bmp != null && bg != null && mask != null && cover != null) {\n\t\t\tBitmap mutable = Bitmap.createBitmap(80, 80, Bitmap.Config.ARGB_8888);\n\t\t\tCanvas canvas = new Canvas(mutable);\n\t\t\tPaint paint = new Paint();\n\t\t\tpaint.setFilterBitmap(false);\n\t\t\tcanvas.drawBitmap(bmp, 0, 0, paint);\n\t\t\tpaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));\n\t\t\tcanvas.drawBitmap(mask, 0, 0, paint);\n\t\t\tpaint.setXfermode(null);\n\t\t\tcanvas.drawBitmap(cover, 0, 0, paint);\n\t\t\treturn mutable;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static Bitmap generateUserIcon300(Bitmap bmp, Bitmap bg, Bitmap mask, Bitmap cover) {\n\t\tif (bmp != null && bg != null && mask != null && cover != null) {\n\t\t\tBitmap mutable = Bitmap.createBitmap(300, 300, Bitmap.Config.ARGB_8888);\n\t\t\tCanvas canvas = new Canvas(mutable);\n\t\t\tPaint paint = new Paint();\n\t\t\tpaint.setFilterBitmap(false);\n\t\t\tcanvas.drawBitmap(bmp, 0, 0, paint);\n\t\t\tpaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));\n\t\t\tcanvas.drawBitmap(mask, 0, 0, paint);\n\t\t\tpaint.setXfermode(null);\n\t\t\tcanvas.drawBitmap(cover, 0, 0, paint);\n\t\t\treturn mutable;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tprivate List<MediaItem> mMediaItemList;\n\t\n\tpublic List<MediaItem> getMediaItemList() {\n\t\treturn mMediaItemList;\n\t}\n\tpublic void setmMediaItemList(List<MediaItem> mediaItemList) {\n\t\tthis.mMediaItemList = mediaItemList;\n\t}\n\t\n\tpublic boolean changeFilePermission(File file) {\n\t\ttry {\n\t\t\tif (file.exists()) {\n\t\t\t\tString command = \"chmod 777 \" + file.getAbsolutePath();\n\t\t\t\tLog.i(\"zyl\", \"command = \" + command);\n\t\t\t\tRuntime runtime = Runtime.getRuntime();\n\t\t\t\tProcess proc = runtime.exec(command);\n\t\t\t\tproc.getOutputStream();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tLog.i(\"zyl\", \"chmod fail!!!!\");\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn false;\n\t}\n\tprivate final float INIT_ANGLE = -75;\n\tprivate final float SEP_ANGLE = 15;\n\t\n\t\n\tpublic static Bitmap getMovieLargeIcon(Bitmap oriBmp, Bitmap bmpBg, Bitmap bmpTop) {\n\t\ttry {\n\t\t\tif (oriBmp != null && bmpBg != null) {\n\t\t\t\tBitmap bmp = oriBmp;\n\t\t\t\tfloat scale = 296f / bmp.getWidth();\n\t\t\t\tMatrix matrix = new Matrix();\n\t\t\t\tmatrix.postScale(scale, scale);\n\t\t\t\tBitmap resizedBitmap = Bitmap.createBitmap(bmp, 0, 0, bmp.getWidth(), bmp.getHeight(), matrix, true);\n\t\t\t\tint cuty = (int) (resizedBitmap.getHeight() / 2 - 89);\n\t\t\t\tBitmap cropBitmap = null;\n\t\t\t\tif (resizedBitmap.getHeight() > 178) {\n\t\t\t\t\tcropBitmap = Bitmap.createBitmap(resizedBitmap, 0, cuty, resizedBitmap.getWidth(), 178);\n\t\t\t\t} else {\n\t\t\t\t\tcropBitmap = Bitmap.createBitmap(resizedBitmap, 0, 0, resizedBitmap.getWidth(), resizedBitmap.getHeight());\n\t\t\t\t}\n\t\t\t\tBitmap mutableBm = bmpBg.copy(Bitmap.Config.ARGB_8888, true);\n\t\t\t\tCanvas canvas = new Canvas(mutableBm);\n\t\t\t\tcanvas.drawBitmap(cropBitmap, 0, 60, null);\n\t\t\t\treturn mutableBm;\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static Bitmap getMusicLargeIcon(Bitmap bmp, Bitmap bmpBg, Bitmap bmpTop)\n\t{\n\t\tif (bmp == null || bmpBg == null || bmpTop == null) {\n\t\t\treturn null;\n\t\t}\t\n\t\t\n\t\ttry {\n\t\t\tfloat scale = 300f / bmp.getHeight();\n\t\t\tMatrix matrix = new Matrix();\n\t\t\tmatrix.postScale(scale, scale);\n\t\t\tBitmap resizedBitmap = Bitmap.createBitmap(bmp, 0, 0, bmp.getWidth(), bmp.getHeight(), matrix, true);\n\t\t\tint cutx = (int) (resizedBitmap.getWidth() / 2 - 150);\n\t\t\tBitmap cropBitmap = null;\n\t\t\tint moveX = 0;\n\t\t\tif (resizedBitmap.getWidth() > 300) {\n\t\t\t\tcropBitmap = Bitmap.createBitmap(resizedBitmap, cutx, 0, 300, resizedBitmap.getHeight());\n\t\t\t} else {\n\t\t\t\tmoveX = (int)((300 - resizedBitmap.getWidth())/2);\n\t\t\t\tcropBitmap = Bitmap.createBitmap(resizedBitmap, 0, 0, resizedBitmap.getWidth(), resizedBitmap.getHeight());\n\t\t\t}\n\t\t\tresizedBitmap.recycle();\n\t\t\tBitmap mutableBm = bmpBg.copy(Bitmap.Config.ARGB_8888, true);\n\t\t\tCanvas canvas = new Canvas(mutableBm);\n\t\t\t\n\t\t\tcanvas.drawBitmap(cropBitmap, 40 + moveX, 10, null);\n\t\t\tcanvas.drawBitmap(bmpTop, 0, 0, null);\n\t\t\t\n\t\t\tcropBitmap.recycle();\n\t\t\tbmpBg.recycle();\n\t\t\tbmpTop.recycle();\n\t\t\t\n\t\t\treturn mutableBm;\n\t\t} catch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static Bitmap getPhotoLargeIcon(Bitmap orgImage, Bitmap bottom, Bitmap top, int w, int h, int leftMargin, int topMargin)\n\t{\n\t\tBitmap bmpBg = bottom;\n\t\tBitmap bmpTop = top;\n\t\tBitmap bmp = orgImage;\n\t\tfloat scale = (float)h / bmp.getHeight();\n\t\tMatrix matrix = new Matrix();\n\t\tmatrix.postScale(scale, scale);\n\t\tBitmap resizedBitmap = Bitmap.createBitmap(bmp, 0, 0, bmp.getWidth(), bmp.getHeight(), matrix, true);\n\t\tint cutx = (int) (resizedBitmap.getWidth() / 2 - w/2);\n\t\tBitmap cropBitmap = null;\n\t\tint moveX = 0;\n\t\tif (resizedBitmap.getWidth() > w) {\n\t\t\tcropBitmap = Bitmap.createBitmap(resizedBitmap, cutx, 0, w, resizedBitmap.getHeight());\n\t\t} else {\n\t\t\tmoveX = (int)((w - resizedBitmap.getWidth())/2);\n\t\t\tcropBitmap = Bitmap.createBitmap(resizedBitmap, 0, 0, resizedBitmap.getWidth(), resizedBitmap.getHeight());\n\t\t}\n\t\tBitmap mutableBm = bmpBg.copy(Bitmap.Config.ARGB_8888, true);\n\t\tCanvas canvas = new Canvas(mutableBm);\n\t\t\n\t\tcanvas.drawBitmap(cropBitmap, leftMargin + moveX, topMargin, null);\n\t\tcanvas.drawBitmap(bmpTop, 0, 0, null);\n\t\t\n\t\treturn mutableBm;\n\t}\n\t\n\tpublic static Bitmap getEbookLargeIcon(Bitmap bitmap, Bitmap iconBg)\n\t{\n\t\tBitmap bmpBg = iconBg;\n\t\t//Bitmap bmp = bitmap;\n\t\tint h = 278;\n\t\tint w = 191;\n\t\t\n\t\tBitmap cropBitmap = ThumbnailUtils.extractThumbnail(bitmap, w, h);\n\t\tBitmap mutableBm = bmpBg.copy(Bitmap.Config.ARGB_8888, true);\n\t\tCanvas canvas = new Canvas(mutableBm);\n\t\t\n\t\tcanvas.drawBitmap(cropBitmap, 55, 17, null);\n\t\t\n\t\treturn mutableBm;\n\t}\n\t\n\tpublic static Bitmap getGameLargeIcon(Bitmap bitmap, Bitmap iconBg, Bitmap iconTop)\n\t{\n\t\tBitmap cropBitmap = ThumbnailUtils.extractThumbnail(bitmap, 300, 300);\n\t\t\tBitmap mutable = Bitmap.createBitmap(300, 300, Bitmap.Config.ARGB_8888);\n\t\t\tCanvas canvas = new Canvas(mutable);\n\t\t\tPaint paint = new Paint();\n\t\t\tpaint.setFilterBitmap(false);\n\t\t\tcanvas.drawBitmap(cropBitmap, 0, 0, paint);\n\t\t\tpaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));\n\t\t\tcanvas.drawBitmap(iconBg, 0, 0, paint);\n\t\t\tpaint.setXfermode(null);\n\t\t\tcanvas.drawBitmap(iconTop, 0, 0, paint);\n\t\t\treturn mutable;\n\t}\n\t\n\tpublic static Bitmap getGameLargeIcon2(Bitmap bitmap, Bitmap iconBg, Bitmap iconTop)\n\t{\n\t\tBitmap cropBitmap = null;\n\t\tif (bitmap.getHeight() >= 300 || bitmap.getWidth() >= 300) {\n\t\t\tcropBitmap = ThumbnailUtils.extractThumbnail(bitmap, 300, 300);\n\t\t}else{\n\t\t\tLog.d(\"gameLargeIconSize\", \"w:\" + bitmap.getWidth() + \" h:\" + bitmap.getHeight());\n\t\t\tcropBitmap = bitmap;\n\t\t}\n\t\t\tBitmap mutable = Bitmap.createBitmap(300, 300, Bitmap.Config.ARGB_8888);\n\t\t\tCanvas canvas = new Canvas(mutable);\n\t\t\tPaint paint = new Paint();\n\t\t\tpaint.setFilterBitmap(false);\n\t\t\tcanvas.drawBitmap(cropBitmap, 0, 0, paint);\n\t\t\tpaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));\n\t\t\tcanvas.drawBitmap(iconBg, 0, 0, paint);\n\t\t\tpaint.setXfermode(null);\n\t\t\tcanvas.drawBitmap(iconTop, 0, 0, paint);\n\t\t\treturn mutable;\n\t}\n\t\n\tpublic static Bitmap getIconForGooglePlayItem(Bitmap bitmap, Bitmap iconBg, Bitmap iconTop) {\n\t\tif (bitmap.getWidth() < 300) {\n\t\t\tbitmap = Bitmap.createScaledBitmap(bitmap, 96, 96, false);\n\t\t}\n\t\t\n\t\tBitmap mutable = Bitmap.createBitmap(300, 300, Bitmap.Config.ARGB_8888);\n\t\tCanvas canvas = new Canvas(mutable);\n\t\tPaint paint = new Paint();\n\t\tcanvas.drawBitmap(iconBg, 0, 0, paint);\n\t\tcanvas.drawBitmap(bitmap, 98, 52, paint);\n\t\t\n//\t\tif (iconTop != null) {\n//\t\t\tcanvas.drawBitmap(iconTop, 0, 0, paint);\n//\t\t}\n\t\t\n\t\treturn mutable;\n\t}\n"]]}
{"hexsha": "88393beba770a5b7c52d1c075589065f964bc5c6", "ext": "java", "lang": "Java", "content": "class JSSESupport implements SSLSupport, SSLSessionManager {\n\n    private static final org.apache.juli.logging.Log log =\n        org.apache.juli.logging.LogFactory.getLog(JSSESupport.class);\n\n    private static final StringManager sm =\n        StringManager.getManager(\"org.apache.tomcat.util.net.jsse.res\");\n\n    private static final Map<SSLSession,Integer> keySizeCache =\n            new WeakHashMap<>();\n\n    protected SSLSocket ssl;\n    protected SSLSession session;\n\n    Listener listener = new Listener();\n\n    JSSESupport(SSLSocket sock){\n        ssl=sock;\n        session = sock.getSession();\n        sock.addHandshakeCompletedListener(listener);\n    }\n\n    JSSESupport(SSLSession session) {\n        this.session = session;\n    }\n\n    @Override\n    public String getCipherSuite() throws IOException {\n        // Look up the current SSLSession\n        if (session == null)\n            return null;\n        return session.getCipherSuite();\n    }\n\n    @Override\n    public Object[] getPeerCertificateChain()\n        throws IOException {\n        return getPeerCertificateChain(false);\n    }\n\n    protected java.security.cert.X509Certificate [] getX509Certificates(\n            SSLSession session) {\n        Certificate [] certs=null;\n        try {\n            certs = session.getPeerCertificates();\n        } catch( Throwable t ) {\n            log.debug(sm.getString(\"jsseSupport.clientCertError\"), t);\n            return null;\n        }\n        if( certs==null ) return null;\n\n        java.security.cert.X509Certificate [] x509Certs =\n            new java.security.cert.X509Certificate[certs.length];\n        for(int i=0; i < certs.length; i++) {\n            if (certs[i] instanceof java.security.cert.X509Certificate ) {\n                // always currently true with the JSSE 1.1.x\n                x509Certs[i] = (java.security.cert.X509Certificate) certs[i];\n            } else {\n                try {\n                    byte [] buffer = certs[i].getEncoded();\n                    CertificateFactory cf =\n                        CertificateFactory.getInstance(\"X.509\");\n                    ByteArrayInputStream stream =\n                        new ByteArrayInputStream(buffer);\n                    x509Certs[i] = (java.security.cert.X509Certificate)\n                            cf.generateCertificate(stream);\n                } catch(Exception ex) {\n                    log.info(sm.getString(\n                            \"jseeSupport.certTranslationError\", certs[i]), ex);\n                    return null;\n                }\n            }\n            if(log.isTraceEnabled())\n                log.trace(\"Cert #\" + i + \" = \" + x509Certs[i]);\n        }\n        if(x509Certs.length < 1)\n            return null;\n        return x509Certs;\n    }\n\n    @Override\n    public Object[] getPeerCertificateChain(boolean force)\n        throws IOException {\n        // Look up the current SSLSession\n        if (session == null)\n            return null;\n\n        // Convert JSSE's certificate format to the ones we need\n        X509Certificate [] jsseCerts = null;\n        try {\n            jsseCerts = session.getPeerCertificateChain();\n        } catch(Exception bex) {\n            // ignore.\n        }\n        if (jsseCerts == null)\n            jsseCerts = new X509Certificate[0];\n        if(jsseCerts.length <= 0 && force && ssl != null) {\n            session.invalidate();\n            handShake();\n            session = ssl.getSession();\n        }\n        return getX509Certificates(session);\n    }\n\n    protected void handShake() throws IOException {\n        if( ssl.getWantClientAuth() ) {\n            log.debug(sm.getString(\"jsseSupport.noCertWant\"));\n        } else {\n            ssl.setNeedClientAuth(true);\n        }\n\n        if (ssl.getEnabledCipherSuites().length == 0) {\n            // Handshake is never going to be successful.\n            // Assume this is because handshakes are disabled\n            log.warn(sm.getString(\"jsseSupport.serverRenegDisabled\"));\n            session.invalidate();\n            ssl.close();\n            return;\n        }\n\n        InputStream in = ssl.getInputStream();\n        int oldTimeout = ssl.getSoTimeout();\n        ssl.setSoTimeout(1000);\n        byte[] b = new byte[1];\n        listener.reset();\n        ssl.startHandshake();\n        int maxTries = 60; // 60 * 1000 = example 1 minute time out\n        for (int i = 0; i < maxTries; i++) {\n            if (log.isTraceEnabled())\n                log.trace(\"Reading for try #\" + i);\n            try {\n                int read = in.read(b);\n                if (read > 0) {\n                    // Shouldn't happen as all input should have been swallowed\n                    // before trying to do the handshake. If it does, something\n                    // went wrong so lets bomb out now.\n                    throw new SSLException(\n                            sm.getString(\"jsseSupport.unexpectedData\"));\n                }\n            } catch(SSLException sslex) {\n                log.info(sm.getString(\"jsseSupport.clientCertError\"), sslex);\n                throw sslex;\n            } catch (IOException e) {\n                // ignore - presumably the timeout\n            }\n            if (listener.completed) {\n                break;\n            }\n        }\n        ssl.setSoTimeout(oldTimeout);\n        if (listener.completed == false) {\n            throw new SocketException(\"SSL Cert handshake timeout\");\n        }\n\n    }\n\n    /**\n     * Copied from <code>org.apache.catalina.valves.CertificateValve</code>\n     */\n    @Override\n    public Integer getKeySize()\n        throws IOException {\n        // Look up the current SSLSession\n        SSLSupport.CipherData c_aux[]=ciphers;\n        if (session == null)\n            return null;\n\n        Integer keySize = null;\n        synchronized(keySizeCache) {\n            keySize = keySizeCache.get(session);\n        }\n\n        if (keySize == null) {\n            int size = 0;\n            String cipherSuite = session.getCipherSuite();\n            for (int i = 0; i < c_aux.length; i++) {\n                if (cipherSuite.indexOf(c_aux[i].phrase) >= 0) {\n                    size = c_aux[i].keySize;\n                    break;\n                }\n            }\n            keySize = Integer.valueOf(size);\n            synchronized(keySizeCache) {\n                keySizeCache.put(session, keySize);\n            }\n        }\n        return keySize;\n    }\n\n    @Override\n    public String getSessionId()\n        throws IOException {\n        // Look up the current SSLSession\n        if (session == null)\n            return null;\n        // Expose ssl_session (getId)\n        byte [] ssl_session = session.getId();\n        if ( ssl_session == null)\n            return null;\n        StringBuilder buf=new StringBuilder();\n        for(int x=0; x<ssl_session.length; x++) {\n            String digit=Integer.toHexString(ssl_session[x]);\n            if (digit.length()<2) buf.append('0');\n            if (digit.length()>2) digit=digit.substring(digit.length()-2);\n            buf.append(digit);\n        }\n        return buf.toString();\n    }\n\n\n    private static class Listener implements HandshakeCompletedListener {\n        volatile boolean completed = false;\n        @Override\n        public void handshakeCompleted(HandshakeCompletedEvent event) {\n            completed = true;\n        }\n        void reset() {\n            completed = false;\n        }\n    }\n\n    /**\n     * Invalidate the session this support object is associated with.\n     */\n    @Override\n    public void invalidateSession() {\n        session.invalidate();\n    }\n}", "class_id": 0, "repo": "lanchunqiu/apache-tomcat-8.0.11-src", "file": "java/org/apache/tomcat/util/net/jsse/JSSESupport.java", "last_update_at": "2020-12-16T16:04:51+00:00", "question_id": "88393beba770a5b7c52d1c075589065f964bc5c6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class JSSESupport implements SSLSupport, SSLSessionManager {\n    private static final org.apache.juli.logging.Log log =\n        org.apache.juli.logging.LogFactory.getLog(JSSESupport.class);\n    private static final StringManager sm =\n        StringManager.getManager(\"org.apache.tomcat.util.net.jsse.res\");\n    private static final Map<SSLSession,Integer> keySizeCache =\n            new WeakHashMap<>();\n    protected SSLSocket ssl;\n    protected SSLSession session;\n    Listener listener = new Listener();\n    JSSESupport(SSLSocket sock){\n        ssl=sock;\n        session = sock.getSession();\n        sock.addHandshakeCompletedListener(listener);\n    }\n    JSSESupport(SSLSession session) {\n        this.session = session;\n    }\n    @Override\n    public String getCipherSuite() throws IOException {\n        // Look up the current SSLSession\n        if (session == null)\n            return null;\n        return session.getCipherSuite();\n    }\n    @Override\n    public Object[] getPeerCertificateChain()\n        throws IOException {\n        return getPeerCertificateChain(false);\n    }\n    protected java.security.cert.X509Certificate [] getX509Certificates(\n            SSLSession session) {\n        Certificate [] certs=null;\n        try {\n            certs = session.getPeerCertificates();\n        } catch( Throwable t ) {\n            log.debug(sm.getString(\"jsseSupport.clientCertError\"), t);\n            return null;\n        }\n        if( certs==null ) return null;\n        java.security.cert.X509Certificate [] x509Certs =\n            new java.security.cert.X509Certificate[certs.length];\n        for(int i=0; i < certs.length; i++) {\n            if (certs[i] instanceof java.security.cert.X509Certificate ) {\n                // always currently true with the JSSE 1.1.x\n                x509Certs[i] = (java.security.cert.X509Certificate) certs[i];\n            } else {\n                try {\n                    byte [] buffer = certs[i].getEncoded();\n                    CertificateFactory cf =\n                        CertificateFactory.getInstance(\"X.509\");\n                    ByteArrayInputStream stream =\n                        new ByteArrayInputStream(buffer);\n                    x509Certs[i] = (java.security.cert.X509Certificate)\n                            cf.generateCertificate(stream);\n                } catch(Exception ex) {\n                    log.info(sm.getString(\n                            \"jseeSupport.certTranslationError\", certs[i]), ex);\n                    return null;\n                }\n            }\n            if(log.isTraceEnabled())\n                log.trace(\"Cert #\" + i + \" = \" + x509Certs[i]);\n        }\n        if(x509Certs.length < 1)\n            return null;\n        return x509Certs;\n    }\n    @Override\n    public Object[] getPeerCertificateChain(boolean force)\n        throws IOException {\n        // Look up the current SSLSession\n        if (session == null)\n            return null;\n        // Convert JSSE's certificate format to the ones we need\n        X509Certificate [] jsseCerts = null;\n        try {\n            jsseCerts = session.getPeerCertificateChain();\n        } catch(Exception bex) {\n            // ignore.\n        }\n        if (jsseCerts == null)\n            jsseCerts = new X509Certificate[0];\n        if(jsseCerts.length <= 0 && force && ssl != null) {\n            session.invalidate();\n            handShake();\n            session = ssl.getSession();\n        }\n        return getX509Certificates(session);\n    }\n    protected void handShake() throws IOException {\n        if( ssl.getWantClientAuth() ) {\n            log.debug(sm.getString(\"jsseSupport.noCertWant\"));\n        } else {\n            ssl.setNeedClientAuth(true);\n        }\n        if (ssl.getEnabledCipherSuites().length == 0) {\n            // Handshake is never going to be successful.\n            // Assume this is because handshakes are disabled\n            log.warn(sm.getString(\"jsseSupport.serverRenegDisabled\"));\n            session.invalidate();\n            ssl.close();\n            return;\n        }\n        InputStream in = ssl.getInputStream();\n        int oldTimeout = ssl.getSoTimeout();\n        ssl.setSoTimeout(1000);\n        byte[] b = new byte[1];\n        listener.reset();\n        ssl.startHandshake();\n        int maxTries = 60; // 60 * 1000 = example 1 minute time out\n        for (int i = 0; i < maxTries; i++) {\n            if (log.isTraceEnabled())\n                log.trace(\"Reading for try #\" + i);\n            try {\n                int read = in.read(b);\n                if (read > 0) {\n                    // Shouldn't happen as all input should have been swallowed\n                    // before trying to do the handshake. If it does, something\n                    // went wrong so lets bomb out now.\n                    throw new SSLException(\n                            sm.getString(\"jsseSupport.unexpectedData\"));\n                }\n            } catch(SSLException sslex) {\n                log.info(sm.getString(\"jsseSupport.clientCertError\"), sslex);\n                throw sslex;\n            } catch (IOException e) {\n                // ignore - presumably the timeout\n            }\n            if (listener.completed) {\n                break;\n            }\n        }\n        ssl.setSoTimeout(oldTimeout);\n        if (listener.completed == false) {\n            throw new SocketException(\"SSL Cert handshake timeout\");\n        }\n    }\n    /**\n     * Copied from <code>org.apache.catalina.valves.CertificateValve</code>\n     */\n    @Override\n    public Integer getKeySize()\n        throws IOException {\n        // Look up the current SSLSession\n        SSLSupport.CipherData c_aux[]=ciphers;\n        if (session == null)\n            return null;\n        Integer keySize = null;\n        synchronized(keySizeCache) {\n            keySize = keySizeCache.get(session);\n        }\n        if (keySize == null) {\n            int size = 0;\n            String cipherSuite = session.getCipherSuite();\n            for (int i = 0; i < c_aux.length; i++) {\n                if (cipherSuite.indexOf(c_aux[i].phrase) >= 0) {\n                    size = c_aux[i].keySize;\n                    break;\n                }\n            }\n            keySize = Integer.valueOf(size);\n            synchronized(keySizeCache) {\n                keySizeCache.put(session, keySize);\n            }\n        }\n        return keySize;\n    }\n    @Override\n    public String getSessionId()\n        throws IOException {\n        // Look up the current SSLSession\n        if (session == null)\n            return null;\n        // Expose ssl_session (getId)\n        byte [] ssl_session = session.getId();\n        if ( ssl_session == null)\n            return null;\n        StringBuilder buf=new StringBuilder();\n        for(int x=0; x<ssl_session.length; x++) {\n            String digit=Integer.toHexString(ssl_session[x]);\n            if (digit.length()<2) buf.append('0');\n            if (digit.length()>2) digit=digit.substring(digit.length()-2);\n            buf.append(digit);\n        }\n        return buf.toString();\n    }\n    private static class Listener implements HandshakeCompletedListener {\n        volatile boolean completed = false;\n        @Override\n        public void handshakeCompleted(HandshakeCompletedEvent event) {\n            completed = true;\n        }\n        void reset() {\n            completed = false;\n        }\n    }\n    /**\n     * Invalidate the session this support object is associated with.\n     */\n    @Override\n    public void invalidateSession() {\n        session.invalidate();\n    }\n"]]}
{"hexsha": "931e9971f7f4e826dfe7b99d4ec3cdb18740c0d5", "ext": "java", "lang": "Java", "content": "public class MongoCmdOptionsBuilder extends AbstractBuilder<IMongoCmdOptions> {\n\n\tprotected static final TypedProperty<Integer> SYNC_DELAY = TypedProperty.with(\"syncDelay\", Integer.class);\n\tprotected static final TypedProperty<String> STORAGE_ENGINE = TypedProperty.with(\"storageEngine\", String.class);\n\tprotected static final TypedProperty<Boolean> VERBOSE = TypedProperty.with(\"verbose\", Boolean.class);\n\tprotected static final TypedProperty<Boolean> NOPREALLOC = TypedProperty.with(\"noprealloc\", Boolean.class);\n\tprotected static final TypedProperty<Boolean> SMALLFILES = TypedProperty.with(\"smallfiles\", Boolean.class);\n\tprotected static final TypedProperty<Boolean> NOJOURNAL = TypedProperty.with(\"nojournal\", Boolean.class);\n\tprotected static final TypedProperty<Boolean> ENABLE_TEXTSEARCH = TypedProperty.with(\"enableTextSearch\", Boolean.class);\n\tprotected static final TypedProperty<Boolean> ENABLE_AUTH = TypedProperty.with(\"auth\", Boolean.class);\n\tprotected static final TypedProperty<Boolean> MASTER = TypedProperty.with(\"master\", Boolean.class);\n\n\n\tpublic MongoCmdOptionsBuilder() {\n\t\tproperty(SYNC_DELAY).setDefault(0);\n\t\tproperty(STORAGE_ENGINE).setDefault(null);\n\t\tproperty(VERBOSE).setDefault(false);\n\t\tproperty(NOPREALLOC).setDefault(true);\n\t\tproperty(SMALLFILES).setDefault(true);\n\t\tproperty(NOJOURNAL).setDefault(true);\n\t\tproperty(ENABLE_TEXTSEARCH).setDefault(false);\n\t\tproperty(ENABLE_AUTH).setDefault(false);\n\t\tproperty(MASTER).setDefault(false);\n\t}\n\n\tpublic MongoCmdOptionsBuilder useNoPrealloc(boolean value) {\n\t\tset(NOPREALLOC, value);\n\t\treturn this;\n\t}\n\n\tpublic MongoCmdOptionsBuilder useSmallFiles(boolean value) {\n\t\tset(SMALLFILES, value);\n\t\treturn this;\n\t}\n\n\tpublic MongoCmdOptionsBuilder useNoJournal(boolean value) {\n\t\tset(NOJOURNAL, value);\n\t\treturn this;\n\t}\n\n\tpublic MongoCmdOptionsBuilder syncDelay(int delay) {\n\t\tset(SYNC_DELAY, delay);\n\t\treturn this;\n\t}\n\n\tpublic MongoCmdOptionsBuilder verbose(boolean verbose) {\n\t\tset(VERBOSE, verbose);\n\t\treturn this;\n\t}\n\n\tpublic MongoCmdOptionsBuilder enableTextSearch(boolean verbose) {\n\t\tset(ENABLE_TEXTSEARCH, verbose);\n\t\treturn this;\n\t}\n\n\tpublic MongoCmdOptionsBuilder useStorageEngine(String storageEngine) {\n\t\tset(STORAGE_ENGINE, storageEngine);\n\t\treturn this;\n\t}\n\n\tpublic MongoCmdOptionsBuilder enableAuth(boolean enable) {\n\t\tset(ENABLE_AUTH, enable);\n\t\treturn this;\n\t}\n\n\tpublic MongoCmdOptionsBuilder master(boolean enable) {\n\t\tset(MASTER, enable);\n\t\treturn this;\n\t}\n\n\tpublic MongoCmdOptionsBuilder defaultSyncDelay() {\n\t\tset(SYNC_DELAY, null);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic IMongoCmdOptions build() {\n\t\tInteger syncDelay = get(SYNC_DELAY, null);\n\t\tString storageEngine = get(STORAGE_ENGINE, null);\n\t\tboolean verbose = get(VERBOSE);\n\t\tboolean noPrealloc = get(NOPREALLOC);\n\t\tboolean smallFiles = get(SMALLFILES);\n\t\tboolean noJournal = get(NOJOURNAL);\n\t\tboolean enableTextSearch = get(ENABLE_TEXTSEARCH);\n\t\tboolean auth = get(ENABLE_AUTH);\n\t\tboolean master = get(MASTER);\n\t\treturn new MongoCmdOptions(syncDelay, storageEngine, verbose, noPrealloc, smallFiles, noJournal, enableTextSearch, auth, master);\n\t}\n\n\tstatic class MongoCmdOptions implements IMongoCmdOptions {\n\n\t\tprivate final Integer _syncDelay;\n\t\tprivate final boolean _verbose;\n\t\tprivate final boolean _noPrealloc;\n\t\tprivate final boolean _smallFiles;\n\t\tprivate final boolean _noJournal;\n\t\tprivate final boolean _enableTextSearch;\n\t\tprivate final boolean _auth;\n\t\tprivate final boolean _master;\n\t\tprivate final String _storageEngine;\n\n\t\tpublic MongoCmdOptions(Integer syncDelay, String storageEngine, boolean verbose, boolean noPrealloc, boolean smallFiles,\n                               boolean noJournal, boolean enableTextSearch, boolean auth, boolean master) {\n\t\t\t_syncDelay = syncDelay;\n\t\t\t_storageEngine = storageEngine;\n\t\t\t_verbose = verbose;\n\t\t\t_noPrealloc = noPrealloc;\n\t\t\t_smallFiles = smallFiles;\n\t\t\t_noJournal = noJournal;\n\t\t\t_enableTextSearch = enableTextSearch;\n\t\t\t_auth = auth;\n\t\t\t_master = master;\n\t\t}\n\n\t\t@Override\n\t\tpublic Integer syncDelay() {\n\t\t\treturn _syncDelay;\n\t\t}\n\n\t\t@Override\n\t\tpublic String storageEngine() {\n\t\t\treturn _storageEngine;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isVerbose() {\n\t\t\treturn _verbose;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean useNoPrealloc() {\n\t\t\treturn _noPrealloc;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean useSmallFiles() {\n\t\t\treturn _smallFiles;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean useNoJournal() {\n\t\t\treturn _noJournal;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean enableTextSearch() {\n\t\t\treturn _enableTextSearch;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean auth() {\n\t\t\treturn _auth;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean master() {\n\t\t\treturn _master;\n\t\t}\n\t}\n}", "class_id": 0, "repo": "rsixel/de.flapdoodle.embed.mongo", "file": "src/main/java/de/flapdoodle/embed/mongo/config/MongoCmdOptionsBuilder.java", "last_update_at": "2020-02-24T16:55:07+00:00", "question_id": "931e9971f7f4e826dfe7b99d4ec3cdb18740c0d5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MongoCmdOptionsBuilder extends AbstractBuilder<IMongoCmdOptions> {\n\tprotected static final TypedProperty<Integer> SYNC_DELAY = TypedProperty.with(\"syncDelay\", Integer.class);\n\tprotected static final TypedProperty<String> STORAGE_ENGINE = TypedProperty.with(\"storageEngine\", String.class);\n\tprotected static final TypedProperty<Boolean> VERBOSE = TypedProperty.with(\"verbose\", Boolean.class);\n\tprotected static final TypedProperty<Boolean> NOPREALLOC = TypedProperty.with(\"noprealloc\", Boolean.class);\n\tprotected static final TypedProperty<Boolean> SMALLFILES = TypedProperty.with(\"smallfiles\", Boolean.class);\n\tprotected static final TypedProperty<Boolean> NOJOURNAL = TypedProperty.with(\"nojournal\", Boolean.class);\n\tprotected static final TypedProperty<Boolean> ENABLE_TEXTSEARCH = TypedProperty.with(\"enableTextSearch\", Boolean.class);\n\tprotected static final TypedProperty<Boolean> ENABLE_AUTH = TypedProperty.with(\"auth\", Boolean.class);\n\tprotected static final TypedProperty<Boolean> MASTER = TypedProperty.with(\"master\", Boolean.class);\n\tpublic MongoCmdOptionsBuilder() {\n\t\tproperty(SYNC_DELAY).setDefault(0);\n\t\tproperty(STORAGE_ENGINE).setDefault(null);\n\t\tproperty(VERBOSE).setDefault(false);\n\t\tproperty(NOPREALLOC).setDefault(true);\n\t\tproperty(SMALLFILES).setDefault(true);\n\t\tproperty(NOJOURNAL).setDefault(true);\n\t\tproperty(ENABLE_TEXTSEARCH).setDefault(false);\n\t\tproperty(ENABLE_AUTH).setDefault(false);\n\t\tproperty(MASTER).setDefault(false);\n\t}\n\tpublic MongoCmdOptionsBuilder useNoPrealloc(boolean value) {\n\t\tset(NOPREALLOC, value);\n\t\treturn this;\n\t}\n\tpublic MongoCmdOptionsBuilder useSmallFiles(boolean value) {\n\t\tset(SMALLFILES, value);\n\t\treturn this;\n\t}\n\tpublic MongoCmdOptionsBuilder useNoJournal(boolean value) {\n\t\tset(NOJOURNAL, value);\n\t\treturn this;\n\t}\n\tpublic MongoCmdOptionsBuilder syncDelay(int delay) {\n\t\tset(SYNC_DELAY, delay);\n\t\treturn this;\n\t}\n\tpublic MongoCmdOptionsBuilder verbose(boolean verbose) {\n\t\tset(VERBOSE, verbose);\n\t\treturn this;\n\t}\n\tpublic MongoCmdOptionsBuilder enableTextSearch(boolean verbose) {\n\t\tset(ENABLE_TEXTSEARCH, verbose);\n\t\treturn this;\n\t}\n\tpublic MongoCmdOptionsBuilder useStorageEngine(String storageEngine) {\n\t\tset(STORAGE_ENGINE, storageEngine);\n\t\treturn this;\n\t}\n\tpublic MongoCmdOptionsBuilder enableAuth(boolean enable) {\n\t\tset(ENABLE_AUTH, enable);\n\t\treturn this;\n\t}\n\tpublic MongoCmdOptionsBuilder master(boolean enable) {\n\t\tset(MASTER, enable);\n\t\treturn this;\n\t}\n\tpublic MongoCmdOptionsBuilder defaultSyncDelay() {\n\t\tset(SYNC_DELAY, null);\n\t\treturn this;\n\t}\n\t@Override\n\tpublic IMongoCmdOptions build() {\n\t\tInteger syncDelay = get(SYNC_DELAY, null);\n\t\tString storageEngine = get(STORAGE_ENGINE, null);\n\t\tboolean verbose = get(VERBOSE);\n\t\tboolean noPrealloc = get(NOPREALLOC);\n\t\tboolean smallFiles = get(SMALLFILES);\n\t\tboolean noJournal = get(NOJOURNAL);\n\t\tboolean enableTextSearch = get(ENABLE_TEXTSEARCH);\n\t\tboolean auth = get(ENABLE_AUTH);\n\t\tboolean master = get(MASTER);\n\t\treturn new MongoCmdOptions(syncDelay, storageEngine, verbose, noPrealloc, smallFiles, noJournal, enableTextSearch, auth, master);\n\t}\n\tstatic class MongoCmdOptions implements IMongoCmdOptions {\n\t\tprivate final Integer _syncDelay;\n\t\tprivate final boolean _verbose;\n\t\tprivate final boolean _noPrealloc;\n\t\tprivate final boolean _smallFiles;\n\t\tprivate final boolean _noJournal;\n\t\tprivate final boolean _enableTextSearch;\n\t\tprivate final boolean _auth;\n\t\tprivate final boolean _master;\n\t\tprivate final String _storageEngine;\n\t\tpublic MongoCmdOptions(Integer syncDelay, String storageEngine, boolean verbose, boolean noPrealloc, boolean smallFiles,\n                               boolean noJournal, boolean enableTextSearch, boolean auth, boolean master) {\n\t\t\t_syncDelay = syncDelay;\n\t\t\t_storageEngine = storageEngine;\n\t\t\t_verbose = verbose;\n\t\t\t_noPrealloc = noPrealloc;\n\t\t\t_smallFiles = smallFiles;\n\t\t\t_noJournal = noJournal;\n\t\t\t_enableTextSearch = enableTextSearch;\n\t\t\t_auth = auth;\n\t\t\t_master = master;\n\t\t}\n\t\t@Override\n\t\tpublic Integer syncDelay() {\n\t\t\treturn _syncDelay;\n\t\t}\n\t\t@Override\n\t\tpublic String storageEngine() {\n\t\t\treturn _storageEngine;\n\t\t}\n\t\t@Override\n\t\tpublic boolean isVerbose() {\n\t\t\treturn _verbose;\n\t\t}\n\t\t@Override\n\t\tpublic boolean useNoPrealloc() {\n\t\t\treturn _noPrealloc;\n\t\t}\n\t\t@Override\n\t\tpublic boolean useSmallFiles() {\n\t\t\treturn _smallFiles;\n\t\t}\n\t\t@Override\n\t\tpublic boolean useNoJournal() {\n\t\t\treturn _noJournal;\n\t\t}\n\t\t@Override\n\t\tpublic boolean enableTextSearch() {\n\t\t\treturn _enableTextSearch;\n\t\t}\n\t\t@Override\n\t\tpublic boolean auth() {\n\t\t\treturn _auth;\n\t\t}\n\t\t@Override\n\t\tpublic boolean master() {\n\t\t\treturn _master;\n\t\t}\n\t}\n"]]}
{"hexsha": "ac464fab858ccb9e68428a213ef2d63a96ef44b1", "ext": "java", "lang": "Java", "content": "public class ProfileActivity extends AppCompatActivity implements HintListener, UserListener, ErrorListener {\n\n    private boolean inProgress;\n    private boolean clicked;\n    private HintManager hintManager;\n    private UserManager userManager;\n    private View progressBar;\n    private View updateForm;\n    private TextInputEditText firstNameField;\n    private TextInputEditText lastNameField;\n    private TextInputEditText cityField;\n    private TextInputEditText phoneField;\n    private HintSpinner provinceField;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_profile);\n\n        Toolbar toolbar = findViewById(R.id.profile_toolbar);\n        MRKUtil.setToolbar(this, toolbar);\n\n        hintManager = new HintManager(this, this);\n\n        userManager = new UserManager(this, this);\n\n        progressBar = findViewById(R.id.profile_progress);\n        updateForm = findViewById(R.id.profile_form);\n\n        firstNameField = findViewById(R.id.profile_name_first);\n        lastNameField = findViewById(R.id.profile_name_last);\n        cityField = findViewById(R.id.profile_city);\n        phoneField = findViewById(R.id.profile_phone);\n        phoneField.setOnEditorActionListener((textView, id, keyEvent) -> {\n            if (MRKUtil.checkIme(id)) {\n                attemptModify();\n                return true;\n            }\n            return false;\n        });\n\n        provinceField = findViewById(R.id.profile_province);\n        provinceField.setOnItemClickListener((adapterView, view, position, l) -> SpinnerUtil.getClickedItemId(adapterView, position, provinceField));\n\n        Button modifyButton = findViewById(R.id.profile_button_modify);\n        modifyButton.setOnClickListener(view -> attemptModify());\n\n        Button passwordButton = findViewById(R.id.profile_button_password);\n        passwordButton.setOnClickListener(v -> goToPasswordChange());\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        clicked = false;\n        showProgress(true);\n        hintManager.getProvinces(new ErrorListener() {\n        });\n        setUserData();\n    }\n\n    @Override\n    protected void onPause() {\n        hintManager.cancelCalls();\n        userManager.cancelCalls();\n        super.onPause();\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        MRKUtil.backButtonClicked(this, item);\n        return super.onOptionsItemSelected(item);\n    }\n\n    private void setUserData() {\n        UserData user = SharedPrefUtil.getInstance(this).getUserData();\n        firstNameField.setText(user.getFirstName());\n        lastNameField.setText(user.getLastName());\n        cityField.setText(user.getCity());\n        phoneField.setText(user.getPhone());\n        provinceField.setText(user.getProvince());\n        provinceField.setItemId(user.getPrvId());\n    }\n\n    private void showProgress(final boolean show) {\n        inProgress = show;\n        MRKUtil.showProgressBar(this, updateForm, progressBar, show);\n    }\n\n    private void goToPasswordChange() {\n        if (!clicked) {\n            clicked = true;\n            startActivity(new Intent(this, PasswordActivity.class));\n        }\n    }\n\n    private void attemptModify() {\n        if (inProgress) {\n            return;\n        }\n\n        inProgress = true;\n\n        firstNameField.setError(null);\n        cityField.setError(null);\n        provinceField.setError(null);\n        phoneField.setError(null);\n\n        String firstName = firstNameField.getText().toString();\n        String lastName = lastNameField.getText().toString();\n        String city = cityField.getText().toString();\n        String phone = phoneField.getText().toString();\n        Long province = provinceField.getItemId();\n\n        boolean cancel = false;\n        View focusView = null;\n\n        if (!ValidUtil.phoneValid(this, phone, phoneField, true)) {\n            focusView = phoneField;\n            cancel = true;\n        }\n\n        if (ValidUtil.spinnerEmpty(this, province, provinceField)) {\n            focusView = provinceField;\n            cancel = true;\n        }\n\n        if (ValidUtil.fieldEmpty(this, city, cityField)) {\n            focusView = cityField;\n            cancel = true;\n        }\n\n        if (ValidUtil.fieldEmpty(this, firstName, firstNameField)) {\n            focusView = firstNameField;\n            cancel = true;\n        }\n\n        if (cancel) {\n            focusView.requestFocus();\n            inProgress = false;\n        } else {\n            showProgress(true);\n            userManager.updateProfile(new UserData(firstName, lastName, city, province, phone), this);\n        }\n    }\n\n    @Override\n    public void provincesReceived(List<HintData> provinces) {\n        SpinnerUtil.setHintAdapter(this, provinceField, provinces);\n        showProgress(false);\n    }\n\n    @Override\n    public void profileUpdated(UserData user) {\n        SharedPrefUtil.getInstance(this).saveUserData(user);\n        showProgress(false);\n        MRKUtil.toast(this, getString(R.string.toast_profile_edited));\n    }\n\n    @Override\n    public void unhandledError(Activity activity, String error) {\n        showProgress(false);\n        MRKUtil.connectionProblem(this);\n    }\n\n}", "class_id": 0, "repo": "bbeny123/marketplace", "file": "client/app/src/main/java/kwasilewski/marketplace/activity/ProfileActivity.java", "last_update_at": "2020-05-15T07:59:41+00:00", "question_id": "ac464fab858ccb9e68428a213ef2d63a96ef44b1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ProfileActivity extends AppCompatActivity implements HintListener, UserListener, ErrorListener {\n    private boolean inProgress;\n    private boolean clicked;\n    private HintManager hintManager;\n    private UserManager userManager;\n    private View progressBar;\n    private View updateForm;\n    private TextInputEditText firstNameField;\n    private TextInputEditText lastNameField;\n    private TextInputEditText cityField;\n    private TextInputEditText phoneField;\n    private HintSpinner provinceField;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_profile);\n        Toolbar toolbar = findViewById(R.id.profile_toolbar);\n        MRKUtil.setToolbar(this, toolbar);\n        hintManager = new HintManager(this, this);\n        userManager = new UserManager(this, this);\n        progressBar = findViewById(R.id.profile_progress);\n        updateForm = findViewById(R.id.profile_form);\n        firstNameField = findViewById(R.id.profile_name_first);\n        lastNameField = findViewById(R.id.profile_name_last);\n        cityField = findViewById(R.id.profile_city);\n        phoneField = findViewById(R.id.profile_phone);\n        phoneField.setOnEditorActionListener((textView, id, keyEvent) -> {\n            if (MRKUtil.checkIme(id)) {\n                attemptModify();\n                return true;\n            }\n            return false;\n        });\n        provinceField = findViewById(R.id.profile_province);\n        provinceField.setOnItemClickListener((adapterView, view, position, l) -> SpinnerUtil.getClickedItemId(adapterView, position, provinceField));\n        Button modifyButton = findViewById(R.id.profile_button_modify);\n        modifyButton.setOnClickListener(view -> attemptModify());\n        Button passwordButton = findViewById(R.id.profile_button_password);\n        passwordButton.setOnClickListener(v -> goToPasswordChange());\n    }\n    @Override\n    protected void onResume() {\n        super.onResume();\n        clicked = false;\n        showProgress(true);\n        hintManager.getProvinces(new ErrorListener() {\n        });\n        setUserData();\n    }\n    @Override\n    protected void onPause() {\n        hintManager.cancelCalls();\n        userManager.cancelCalls();\n        super.onPause();\n    }\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        MRKUtil.backButtonClicked(this, item);\n        return super.onOptionsItemSelected(item);\n    }\n    private void setUserData() {\n        UserData user = SharedPrefUtil.getInstance(this).getUserData();\n        firstNameField.setText(user.getFirstName());\n        lastNameField.setText(user.getLastName());\n        cityField.setText(user.getCity());\n        phoneField.setText(user.getPhone());\n        provinceField.setText(user.getProvince());\n        provinceField.setItemId(user.getPrvId());\n    }\n    private void showProgress(final boolean show) {\n        inProgress = show;\n        MRKUtil.showProgressBar(this, updateForm, progressBar, show);\n    }\n    private void goToPasswordChange() {\n        if (!clicked) {\n            clicked = true;\n            startActivity(new Intent(this, PasswordActivity.class));\n        }\n    }\n    private void attemptModify() {\n        if (inProgress) {\n            return;\n        }\n        inProgress = true;\n        firstNameField.setError(null);\n        cityField.setError(null);\n        provinceField.setError(null);\n        phoneField.setError(null);\n        String firstName = firstNameField.getText().toString();\n        String lastName = lastNameField.getText().toString();\n        String city = cityField.getText().toString();\n        String phone = phoneField.getText().toString();\n        Long province = provinceField.getItemId();\n        boolean cancel = false;\n        View focusView = null;\n        if (!ValidUtil.phoneValid(this, phone, phoneField, true)) {\n            focusView = phoneField;\n            cancel = true;\n        }\n        if (ValidUtil.spinnerEmpty(this, province, provinceField)) {\n            focusView = provinceField;\n            cancel = true;\n        }\n        if (ValidUtil.fieldEmpty(this, city, cityField)) {\n            focusView = cityField;\n            cancel = true;\n        }\n        if (ValidUtil.fieldEmpty(this, firstName, firstNameField)) {\n            focusView = firstNameField;\n            cancel = true;\n        }\n        if (cancel) {\n            focusView.requestFocus();\n            inProgress = false;\n        } else {\n            showProgress(true);\n            userManager.updateProfile(new UserData(firstName, lastName, city, province, phone), this);\n        }\n    }\n    @Override\n    public void provincesReceived(List<HintData> provinces) {\n        SpinnerUtil.setHintAdapter(this, provinceField, provinces);\n        showProgress(false);\n    }\n    @Override\n    public void profileUpdated(UserData user) {\n        SharedPrefUtil.getInstance(this).saveUserData(user);\n        showProgress(false);\n        MRKUtil.toast(this, getString(R.string.toast_profile_edited));\n    }\n    @Override\n    public void unhandledError(Activity activity, String error) {\n        showProgress(false);\n        MRKUtil.connectionProblem(this);\n    }\n"]]}
{"hexsha": "754c82af254148b524468c9b7604e020fa21c2c7", "ext": "java", "lang": "Java", "content": "public class RestCountriesJacksonTest {\n\n    /**\n     * This test uses Jackson for inspecting the JSON returned\n     * by REST services.\n     *\n     * @throws java.io.IOException\n     */\n    @Test\n    public void getCapitalHappyPath() throws java.io.IOException {\n        ObjectMapper mapper = new ObjectMapper();\n\n        // Get info about european country.\n        Response response = get(\"http://restcountries.eu/rest/v1/name/switzerland\");\n        JsonNode countryInfo = mapper.readTree(response.asInputStream()).get(0);\n\n        // Confirm value of capital.\n        JsonNode capital = countryInfo.get(\"capital\");\n        String capitalAsText = capital.textValue();\n        assertEquals(\"Bern\", capitalAsText);\n\n        // Confirm French name for country.\n        assertEquals(\"Suisse\", countryInfo.path(\"translations\").path(\"fr\").asText());\n\n        // 'path' avoids NullPointerException when item is missing\n        assertEquals(\"\", countryInfo.path(\"anUnknownPropertyZ\").path(\"fr\").asText());\n\n        // or 'get' will throw NullPointerException\n        assertEquals(\"Suisse\", countryInfo.get(\"translations\").get(\"fr\").textValue());\n        try {\n            countryInfo.get(\"anUnknownPropertyZ\").get(\"fr\").textValue();\n            fail(\"Expected NullPointerException to be thrown in middle of chain.\");\n        } catch (NullPointerException npex) {\n            // Expected NullPointerException due to get(\"anUnknownPropertyZ\").\n        }\n\n        // Confirm population.\n        assertTrue(\"Expected population > 8M.\", 8000000 < countryInfo.get(\"population\").asInt());\n\n        // 'path' avoids NullPointerException.\n        assertEquals(0, countryInfo.path(\"anUnknownPropertyZ\").asInt());\n\n        // Confirm measure of income distribution of a nation's residents.\n        assertTrue(\"Expected Gini coefficient > 30\", 30.0d < countryInfo.get(\"gini\").asDouble());\n\n        // 'path' avoids NullPointerException.\n        assertEquals(0.0d, countryInfo.path(\"anUnknownPropertyZ\").asDouble(), 0.001d);\n\n    }\n\n}", "class_id": 0, "repo": "jimtyhurst/rest-assured-samples", "file": "src/test/java/com/tyhurst/samples/resttests/RestCountriesJacksonTest.java", "last_update_at": "2020-04-22T17:36:38+00:00", "question_id": "754c82af254148b524468c9b7604e020fa21c2c7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RestCountriesJacksonTest {\n    /**\n     * This test uses Jackson for inspecting the JSON returned\n     * by REST services.\n     *\n     * @throws java.io.IOException\n     */\n    @Test\n    public void getCapitalHappyPath() throws java.io.IOException {\n        ObjectMapper mapper = new ObjectMapper();\n        // Get info about european country.\n        Response response = get(\"http://restcountries.eu/rest/v1/name/switzerland\");\n        JsonNode countryInfo = mapper.readTree(response.asInputStream()).get(0);\n        // Confirm value of capital.\n        JsonNode capital = countryInfo.get(\"capital\");\n        String capitalAsText = capital.textValue();\n        assertEquals(\"Bern\", capitalAsText);\n        // Confirm French name for country.\n        assertEquals(\"Suisse\", countryInfo.path(\"translations\").path(\"fr\").asText());\n        // 'path' avoids NullPointerException when item is missing\n        assertEquals(\"\", countryInfo.path(\"anUnknownPropertyZ\").path(\"fr\").asText());\n        // or 'get' will throw NullPointerException\n        assertEquals(\"Suisse\", countryInfo.get(\"translations\").get(\"fr\").textValue());\n        try {\n            countryInfo.get(\"anUnknownPropertyZ\").get(\"fr\").textValue();\n            fail(\"Expected NullPointerException to be thrown in middle of chain.\");\n        } catch (NullPointerException npex) {\n            // Expected NullPointerException due to get(\"anUnknownPropertyZ\").\n        }\n        // Confirm population.\n        assertTrue(\"Expected population > 8M.\", 8000000 < countryInfo.get(\"population\").asInt());\n        // 'path' avoids NullPointerException.\n        assertEquals(0, countryInfo.path(\"anUnknownPropertyZ\").asInt());\n        // Confirm measure of income distribution of a nation's residents.\n        assertTrue(\"Expected Gini coefficient > 30\", 30.0d < countryInfo.get(\"gini\").asDouble());\n        // 'path' avoids NullPointerException.\n        assertEquals(0.0d, countryInfo.path(\"anUnknownPropertyZ\").asDouble(), 0.001d);\n    }\n"]]}
{"hexsha": "54a40c69ca15b8560a14b2677f485c8defef63fd", "ext": "java", "lang": "Java", "content": "public class Client {\r\n\r\n\tpublic static void main(String[] args) throws IOException, InterruptedException {\r\n\t\tRMIRegistry rMIRegistry = RMIRegistry.builder().build();\r\n\r\n\t\tService routingService = (Service) rMIRegistry.getStub(\"localhost\", 3333, \"tunnel\");\r\n\t\tService routedService = routingService.getService();\r\n\r\n\t\troutedService.useThisService();\r\n\t\tThread.sleep(5000);\r\n\t\troutingService.useThisService();\r\n\t}\r\n}", "class_id": 0, "repo": "sv-giampa/CoarseRMI", "file": "examples/RMI Pointer/AgileRMI - Pointer Routing/src/test/agilermi/pointer/routing/Client.java", "last_update_at": "2020-12-29T15:35:21+00:00", "question_id": "54a40c69ca15b8560a14b2677f485c8defef63fd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Client {\r\n\r\n\tpublic static void main(String[] args) throws IOException, InterruptedException {\r\n\t\tRMIRegistry rMIRegistry = RMIRegistry.builder().build();\r\n\r\n\t\tService routingService = (Service) rMIRegistry.getStub(\"localhost\", 3333, \"tunnel\");\r\n\t\tService routedService = routingService.getService();\r\n\r\n\t\troutedService.useThisService();\r\n\t\tThread.sleep(5000);\r\n\t\troutingService.useThisService();\r\n\t}\r\n"]]}
{"hexsha": "7143d367ebe41f7fb07abe10fac5c371b57a7275", "ext": "java", "lang": "Java", "content": "public final class SearchPanelRenderer {\n  private final static int MAX_AVATARS = 3;\n\n  /** Profile provider, for avatars. */\n  private final ProfileManager profiles;\n\n  public SearchPanelRenderer(ProfileManager profiles) {\n    this.profiles = profiles;\n  }\n\n  /**\n   * Renders a digest model into a digest view.\n   */\n  public void render(Digest digest, DigestView digestUi) {\n    Collection<Profile> avatars = CollectionUtils.createQueue();\n    if (digest.getAuthor() != null) {\n      avatars.add(profiles.getProfile(digest.getAuthor()));\n    }\n    for (ParticipantId other : digest.getParticipantsSnippet()) {\n      if (avatars.size() < MAX_AVATARS) {\n        avatars.add(profiles.getProfile(other));\n      } else {\n        break;\n      }\n    }\n\n    digestUi.setAvatars(avatars);\n    digestUi.setTitleText(digest.getTitle());\n    digestUi.setSnippet(digest.getSnippet());\n    digestUi.setMessageCounts(digest.getUnreadCount(), digest.getBlipCount());\n    digestUi.setTimestamp(\n        DateUtils.getInstance().formatPastDate((long) digest.getLastModifiedTime()));\n  }\n}", "class_id": 0, "repo": "eburgueno/incubator-wave", "file": "wave/src/main/java/org/waveprotocol/box/webclient/search/SearchPanelRenderer.java", "last_update_at": "2020-04-29T17:03:26+00:00", "question_id": "7143d367ebe41f7fb07abe10fac5c371b57a7275", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class SearchPanelRenderer {\n  private final static int MAX_AVATARS = 3;\n  /** Profile provider, for avatars. */\n  private final ProfileManager profiles;\n  public SearchPanelRenderer(ProfileManager profiles) {\n    this.profiles = profiles;\n  }\n  /**\n   * Renders a digest model into a digest view.\n   */\n  public void render(Digest digest, DigestView digestUi) {\n    Collection<Profile> avatars = CollectionUtils.createQueue();\n    if (digest.getAuthor() != null) {\n      avatars.add(profiles.getProfile(digest.getAuthor()));\n    }\n    for (ParticipantId other : digest.getParticipantsSnippet()) {\n      if (avatars.size() < MAX_AVATARS) {\n        avatars.add(profiles.getProfile(other));\n      } else {\n        break;\n      }\n    }\n    digestUi.setAvatars(avatars);\n    digestUi.setTitleText(digest.getTitle());\n    digestUi.setSnippet(digest.getSnippet());\n    digestUi.setMessageCounts(digest.getUnreadCount(), digest.getBlipCount());\n    digestUi.setTimestamp(\n        DateUtils.getInstance().formatPastDate((long) digest.getLastModifiedTime()));\n  }\n"]]}
{"hexsha": "8f562c77f7141a4538231d77819cd6f7fdaf05a6", "ext": "java", "lang": "Java", "content": "public class KmSpo2Task extends AsyncTask<Void,Void,Void> {\n\n    private static final String TAG = \"KmSpo2Task\";\n\n\n    private String deviceCode = null;\n    private String currDay = WatchUtils.getCurrentDate();\n    private String userId = null;\n\n    private Gson gson = new Gson();\n\n    private NohttpUtils nohttpUtils;\n\n\n    @Override\n    protected void onPreExecute() {\n        super.onPreExecute();\n        deviceCode = MyApp.getInstance().getMacAddress();\n        userId = (String) SharedPreferencesUtils.readObject(MyApp.getContext(), Commont.USER_ID_DATA);\n        nohttpUtils = NohttpUtils.getNoHttpUtils();\n    }\n\n    @Override\n    protected Void doInBackground(Void... voids) {\n\n        if(deviceCode == null || userId == null)\n            return null;\n        findSpo2Data(deviceCode);\n\n        return null;\n    }\n\n    private void findSpo2Data(String deviceCode) {\n        String where = \"bleMac = ? and dateStr = ?\";\n        List<B31Spo2hBean> currList = LitePal.where(where,deviceCode,\n                currDay).find(B31Spo2hBean.class);\n        if(currList == null)\n            return;\n        //\u8840\u6c27\n        List<Map<String,Object>> spo2List = new ArrayList<>();\n\n        //\u547c\u5438\u7387\n        List<Map<String,Object>> breatheRateList = new ArrayList<>();\n\n\n        for(B31Spo2hBean b31Spo2hBean : currList){\n            Spo2hOriginData spo2hOriginData = gson.fromJson(b31Spo2hBean.getSpo2hOriginData(),Spo2hOriginData.class);\n            Map<String,Object> map = new HashMap<>();\n            map.put(\"AccountId\",userId);\n            map.put(\"DeviceCode\",deviceCode);\n            map.put(\"Bo\",spo2hOriginData.getOxygenValue());\n            map.put(\"TestTime\",spo2hOriginData.getmTime().getDateAndClockForSleepSecond());\n            spo2List.add(map);\n\n\n\n            Map<String,Object> map2 = new HashMap<>();\n            map2.put(\"AccountId\",userId);\n            map2.put(\"DeviceCode\",deviceCode);\n            map2.put(\"Value\",spo2hOriginData.getRespirationRate());\n            map2.put(\"TestTime\",spo2hOriginData.getmTime().getDateAndClockForSleepSecond());\n            breatheRateList.add(map2);\n\n\n        }\n\n        //\u4e0a\u4f20\u8840\u6c27\n        if(spo2List.size()>0){\n            String spo2Url = KmConstance.uploadBloodOxygen();\n            nohttpUtils.getModelRequestJSONObject(0x01,spo2Url,gson.toJson(spo2List),onResponseListener);\n        }\n\n        if(breatheRateList.size()>0){\n            String breathRatesUrl = KmConstance.uploadSpo2BreathRates();\n            nohttpUtils.getModelRequestJSONObject(0x02,breathRatesUrl,gson.toJson(breatheRateList),onResponseListener);\n\n        }\n\n    }\n\n\n    @Override\n    protected void onPostExecute(Void aVoid) {\n        super.onPostExecute(aVoid);\n        if(nohttpUtils != null)\n            nohttpUtils.cancleHttpPost();\n    }\n\n    @Override\n    protected void onCancelled(Void aVoid) {\n        super.onCancelled(aVoid);\n\n    }\n\n    @Override\n    protected void onCancelled() {\n        super.onCancelled();\n\n    }\n\n    private OnResponseListener<JSONObject> onResponseListener = new OnResponseListener<JSONObject>() {\n        @Override\n        public void onStart(int what) {\n\n        }\n\n        @Override\n        public void onSucceed(int what, Response<JSONObject> response) {\n            //Log.e(TAG,\"------what=\"+what+\"---response=\"+response.get());\n        }\n\n        @Override\n        public void onFailed(int what, Response<JSONObject> response) {\n\n        }\n\n        @Override\n        public void onFinish(int what) {\n\n        }\n    };\n}", "class_id": 0, "repo": "18271261642/RaceFitPro", "file": "app/src/main/java/com/example/bozhilun/android/b31/km/KmSpo2Task.java", "last_update_at": "2020-02-02T17:46:00+00:00", "question_id": "8f562c77f7141a4538231d77819cd6f7fdaf05a6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class KmSpo2Task extends AsyncTask<Void,Void,Void> {\n    private static final String TAG = \"KmSpo2Task\";\n    private String deviceCode = null;\n    private String currDay = WatchUtils.getCurrentDate();\n    private String userId = null;\n    private Gson gson = new Gson();\n    private NohttpUtils nohttpUtils;\n    @Override\n    protected void onPreExecute() {\n        super.onPreExecute();\n        deviceCode = MyApp.getInstance().getMacAddress();\n        userId = (String) SharedPreferencesUtils.readObject(MyApp.getContext(), Commont.USER_ID_DATA);\n        nohttpUtils = NohttpUtils.getNoHttpUtils();\n    }\n    @Override\n    protected Void doInBackground(Void... voids) {\n        if(deviceCode == null || userId == null)\n            return null;\n        findSpo2Data(deviceCode);\n        return null;\n    }\n    private void findSpo2Data(String deviceCode) {\n        String where = \"bleMac = ? and dateStr = ?\";\n        List<B31Spo2hBean> currList = LitePal.where(where,deviceCode,\n                currDay).find(B31Spo2hBean.class);\n        if(currList == null)\n            return;\n        //\u8840\u6c27\n        List<Map<String,Object>> spo2List = new ArrayList<>();\n        //\u547c\u5438\u7387\n        List<Map<String,Object>> breatheRateList = new ArrayList<>();\n        for(B31Spo2hBean b31Spo2hBean : currList){\n            Spo2hOriginData spo2hOriginData = gson.fromJson(b31Spo2hBean.getSpo2hOriginData(),Spo2hOriginData.class);\n            Map<String,Object> map = new HashMap<>();\n            map.put(\"AccountId\",userId);\n            map.put(\"DeviceCode\",deviceCode);\n            map.put(\"Bo\",spo2hOriginData.getOxygenValue());\n            map.put(\"TestTime\",spo2hOriginData.getmTime().getDateAndClockForSleepSecond());\n            spo2List.add(map);\n            Map<String,Object> map2 = new HashMap<>();\n            map2.put(\"AccountId\",userId);\n            map2.put(\"DeviceCode\",deviceCode);\n            map2.put(\"Value\",spo2hOriginData.getRespirationRate());\n            map2.put(\"TestTime\",spo2hOriginData.getmTime().getDateAndClockForSleepSecond());\n            breatheRateList.add(map2);\n        }\n        //\u4e0a\u4f20\u8840\u6c27\n        if(spo2List.size()>0){\n            String spo2Url = KmConstance.uploadBloodOxygen();\n            nohttpUtils.getModelRequestJSONObject(0x01,spo2Url,gson.toJson(spo2List),onResponseListener);\n        }\n        if(breatheRateList.size()>0){\n            String breathRatesUrl = KmConstance.uploadSpo2BreathRates();\n            nohttpUtils.getModelRequestJSONObject(0x02,breathRatesUrl,gson.toJson(breatheRateList),onResponseListener);\n        }\n    }\n    @Override\n    protected void onPostExecute(Void aVoid) {\n        super.onPostExecute(aVoid);\n        if(nohttpUtils != null)\n            nohttpUtils.cancleHttpPost();\n    }\n    @Override\n    protected void onCancelled(Void aVoid) {\n        super.onCancelled(aVoid);\n    }\n    @Override\n    protected void onCancelled() {\n        super.onCancelled();\n    }\n    private OnResponseListener<JSONObject> onResponseListener = new OnResponseListener<JSONObject>() {\n        @Override\n        public void onStart(int what) {\n        }\n        @Override\n        public void onSucceed(int what, Response<JSONObject> response) {\n            //Log.e(TAG,\"------what=\"+what+\"---response=\"+response.get());\n        }\n        @Override\n        public void onFailed(int what, Response<JSONObject> response) {\n        }\n        @Override\n        public void onFinish(int what) {\n        }\n    };\n"]]}
{"hexsha": "71a9eae8332650a9501d7dbb7b04182e27f247b8", "ext": "java", "lang": "Java", "content": "public class CursorUtils {\n\n    public static <T> T readCurrentEntity(Class<T> type, Cursor cursor, TableStruct tableStruct) {\n        long st = System.currentTimeMillis();\n        try {\n            T entity = type.newInstance();\n            for (FCMap fcMap : tableStruct.fcmaps) {\n                int index = cursor.getColumnIndex(fcMap.columnName);\n                if (index > -1) {\n                    Object value = fcMap.translator.readColumnValue(cursor, index, fcMap.field);\n                    if (value != null) {\n                        fcMap.field.set(entity, value);\n                    }\n                }\n            }\n            if (OrmConfig.Debug) {\n                Log.d(\"CursorUtils\", \"readCurrentEntity With ColumnIndexMap cost:\" + (System.currentTimeMillis() - st));\n            }\n            return entity;\n        } catch (InstantiationException e) {\n            throw new RuntimeException(e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static <T> T readCurrentEntity(Class<T> type, Cursor cursor, Map<String, Integer> columnIndex) {\n        long st = System.currentTimeMillis();\n        try {\n            T entity = type.newInstance();\n            Field fields[] = type.getDeclaredFields();\n            for (Field field : fields) {\n                field.setAccessible(true);\n                Column column = field.getAnnotation(Column.class);\n                if (column != null) {\n                    String columnName = TableUtils.getColumnName(field, column);\n                    Class<?> fieldType = field.getType();\n                    Object value = OrmConfig.getTranslator(fieldType).readColumnValue(cursor, columnIndex.get(columnName), field);\n                    if (value != null) {\n                        field.set(entity, value);\n                    }\n                }\n            }\n            if (OrmConfig.Debug) {\n                Log.d(\"CursorUtils\", \"readCurrentEntity With ColumnIndexMap cost:\" + (System.currentTimeMillis() - st));\n            }\n            return entity;\n        } catch (InstantiationException e) {\n            throw new RuntimeException(e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static <T> List<T> readEntities(Class<T> type, Cursor cursor, Map<String, Integer> columnIndex) {\n        ArrayList<T> arrayList = new ArrayList<T>();\n        while (cursor.moveToNext()) {\n            arrayList.add(readCurrentEntity(type, cursor, columnIndex));\n        }\n        return arrayList;\n    }\n\n    public static <T> T readCurrentEntity(Class<T> type, Cursor cursor) {\n        long st = System.currentTimeMillis();\n        try {\n            T entity = type.newInstance();\n            Field fields[] = type.getDeclaredFields();\n            for (Field field : fields) {\n                field.setAccessible(true);\n                Column column = field.getAnnotation(Column.class);\n                if (column != null) {\n                    String columnName = TableUtils.getColumnName(field);\n                    Class<?> fieldType = field.getType();\n                    int index = cursor.getColumnIndex(columnName);\n                    if (index > -1) {\n                        Object value = OrmConfig.getTranslator(fieldType).readColumnValue(cursor, index, field);\n                        if (value != null) {\n                            field.set(entity, value);\n                        }\n                    }\n                }\n            }\n            if (OrmConfig.Debug) {\n                Log.d(\"CursorUtils\", \"readCurrentEntity cost:\" + (System.currentTimeMillis() - st));\n            }\n            return entity;\n        } catch (InstantiationException e) {\n            throw new RuntimeException(e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}", "class_id": 0, "repo": "muyuballs/Orm", "file": "droid-orm/src/main/java/info/breezes/orm/utils/CursorUtils.java", "last_update_at": "2020-05-04T02:36:43+00:00", "question_id": "71a9eae8332650a9501d7dbb7b04182e27f247b8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CursorUtils {\n    public static <T> T readCurrentEntity(Class<T> type, Cursor cursor, TableStruct tableStruct) {\n        long st = System.currentTimeMillis();\n        try {\n            T entity = type.newInstance();\n            for (FCMap fcMap : tableStruct.fcmaps) {\n                int index = cursor.getColumnIndex(fcMap.columnName);\n                if (index > -1) {\n                    Object value = fcMap.translator.readColumnValue(cursor, index, fcMap.field);\n                    if (value != null) {\n                        fcMap.field.set(entity, value);\n                    }\n                }\n            }\n            if (OrmConfig.Debug) {\n                Log.d(\"CursorUtils\", \"readCurrentEntity With ColumnIndexMap cost:\" + (System.currentTimeMillis() - st));\n            }\n            return entity;\n        } catch (InstantiationException e) {\n            throw new RuntimeException(e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    public static <T> T readCurrentEntity(Class<T> type, Cursor cursor, Map<String, Integer> columnIndex) {\n        long st = System.currentTimeMillis();\n        try {\n            T entity = type.newInstance();\n            Field fields[] = type.getDeclaredFields();\n            for (Field field : fields) {\n                field.setAccessible(true);\n                Column column = field.getAnnotation(Column.class);\n                if (column != null) {\n                    String columnName = TableUtils.getColumnName(field, column);\n                    Class<?> fieldType = field.getType();\n                    Object value = OrmConfig.getTranslator(fieldType).readColumnValue(cursor, columnIndex.get(columnName), field);\n                    if (value != null) {\n                        field.set(entity, value);\n                    }\n                }\n            }\n            if (OrmConfig.Debug) {\n                Log.d(\"CursorUtils\", \"readCurrentEntity With ColumnIndexMap cost:\" + (System.currentTimeMillis() - st));\n            }\n            return entity;\n        } catch (InstantiationException e) {\n            throw new RuntimeException(e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    public static <T> List<T> readEntities(Class<T> type, Cursor cursor, Map<String, Integer> columnIndex) {\n        ArrayList<T> arrayList = new ArrayList<T>();\n        while (cursor.moveToNext()) {\n            arrayList.add(readCurrentEntity(type, cursor, columnIndex));\n        }\n        return arrayList;\n    }\n    public static <T> T readCurrentEntity(Class<T> type, Cursor cursor) {\n        long st = System.currentTimeMillis();\n        try {\n            T entity = type.newInstance();\n            Field fields[] = type.getDeclaredFields();\n            for (Field field : fields) {\n                field.setAccessible(true);\n                Column column = field.getAnnotation(Column.class);\n                if (column != null) {\n                    String columnName = TableUtils.getColumnName(field);\n                    Class<?> fieldType = field.getType();\n                    int index = cursor.getColumnIndex(columnName);\n                    if (index > -1) {\n                        Object value = OrmConfig.getTranslator(fieldType).readColumnValue(cursor, index, field);\n                        if (value != null) {\n                            field.set(entity, value);\n                        }\n                    }\n                }\n            }\n            if (OrmConfig.Debug) {\n                Log.d(\"CursorUtils\", \"readCurrentEntity cost:\" + (System.currentTimeMillis() - st));\n            }\n            return entity;\n        } catch (InstantiationException e) {\n            throw new RuntimeException(e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n    }\n"]]}
{"hexsha": "789caa9d57380aa5b19155abaa7eb53645d02aaf", "ext": "java", "lang": "Java", "content": "public class VideoViewController extends FrameLayout {\n\n    private VideoView mVideoView;\n    private ImageView mCoverImageView;\n    private ImageButton mPlayImageButton;\n\n    public VideoViewController(@NonNull Context context) {\n        this(context, null);\n    }\n\n    public VideoViewController(@NonNull Context context, @Nullable AttributeSet attrs) {\n        this(context, attrs, -1);\n    }\n\n    public VideoViewController(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        this(context, attrs, defStyleAttr, -1);\n    }\n\n    public VideoViewController(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) {\n        super(context, attrs, defStyleAttr, defStyleRes);\n        mVideoView = new VideoView(context);\n        addView(mVideoView, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));\n\n        mCoverImageView = new ImageView(context);\n        mCoverImageView.setBackgroundColor(Color.BLACK);\n        addView(mCoverImageView, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));\n\n        mPlayImageButton = new ImageButton(context);\n        mPlayImageButton.setBackgroundResource(android.R.color.transparent);\n        mPlayImageButton.setImageResource(R.drawable.ic_play);\n        LayoutParams playParams = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);\n        playParams.gravity = Gravity.CENTER;\n        addView(mPlayImageButton, playParams);\n    }\n\n\n    private void resetState() {\n        this.setVisibility(VISIBLE);\n        mVideoView.setVisibility(INVISIBLE);\n        mCoverImageView.setVisibility(VISIBLE);\n        mPlayImageButton.setVisibility(VISIBLE);\n    }\n\n    public void show(Bitmap coverBitmap, String videoPath) {\n        resetState();\n        mCoverImageView.setImageBitmap(coverBitmap);\n        mVideoView.setOnCompletionListener(mp -> {\n           resetState();\n           mp.release();\n        });\n        mPlayImageButton.setOnClickListener(v -> {\n            mVideoView.setVisibility(VISIBLE);\n            mCoverImageView.setVisibility(INVISIBLE);\n            mPlayImageButton.setVisibility(INVISIBLE);\n            mVideoView.setVideoPath(videoPath);\n            mVideoView.start();\n        });\n    }\n\n    public void hide() {\n        if(mVideoView.isPlaying()){\n            mVideoView.stopPlayback();\n        }\n        this.setVisibility(INVISIBLE);\n        mVideoView.setVisibility(INVISIBLE);\n        mCoverImageView.setVisibility(INVISIBLE);\n        mPlayImageButton.setVisibility(INVISIBLE);\n    }\n}", "class_id": 0, "repo": "KobeMing/CameraModule", "file": "cameraui/src/main/java/com/pm/cameraui/widget/VideoViewController.java", "last_update_at": "2020-12-11T06:55:18+00:00", "question_id": "789caa9d57380aa5b19155abaa7eb53645d02aaf", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class VideoViewController extends FrameLayout {\n    private VideoView mVideoView;\n    private ImageView mCoverImageView;\n    private ImageButton mPlayImageButton;\n    public VideoViewController(@NonNull Context context) {\n        this(context, null);\n    }\n    public VideoViewController(@NonNull Context context, @Nullable AttributeSet attrs) {\n        this(context, attrs, -1);\n    }\n    public VideoViewController(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        this(context, attrs, defStyleAttr, -1);\n    }\n    public VideoViewController(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) {\n        super(context, attrs, defStyleAttr, defStyleRes);\n        mVideoView = new VideoView(context);\n        addView(mVideoView, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));\n        mCoverImageView = new ImageView(context);\n        mCoverImageView.setBackgroundColor(Color.BLACK);\n        addView(mCoverImageView, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));\n        mPlayImageButton = new ImageButton(context);\n        mPlayImageButton.setBackgroundResource(android.R.color.transparent);\n        mPlayImageButton.setImageResource(R.drawable.ic_play);\n        LayoutParams playParams = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);\n        playParams.gravity = Gravity.CENTER;\n        addView(mPlayImageButton, playParams);\n    }\n    private void resetState() {\n        this.setVisibility(VISIBLE);\n        mVideoView.setVisibility(INVISIBLE);\n        mCoverImageView.setVisibility(VISIBLE);\n        mPlayImageButton.setVisibility(VISIBLE);\n    }\n    public void show(Bitmap coverBitmap, String videoPath) {\n        resetState();\n        mCoverImageView.setImageBitmap(coverBitmap);\n        mVideoView.setOnCompletionListener(mp -> {\n           resetState();\n           mp.release();\n        });\n        mPlayImageButton.setOnClickListener(v -> {\n            mVideoView.setVisibility(VISIBLE);\n            mCoverImageView.setVisibility(INVISIBLE);\n            mPlayImageButton.setVisibility(INVISIBLE);\n            mVideoView.setVideoPath(videoPath);\n            mVideoView.start();\n        });\n    }\n    public void hide() {\n        if(mVideoView.isPlaying()){\n            mVideoView.stopPlayback();\n        }\n        this.setVisibility(INVISIBLE);\n        mVideoView.setVisibility(INVISIBLE);\n        mCoverImageView.setVisibility(INVISIBLE);\n        mPlayImageButton.setVisibility(INVISIBLE);\n    }\n"]]}
{"hexsha": "3b3b5d70ff3d2c91f7fc2e714c2484c0624ad0c6", "ext": "java", "lang": "Java", "content": "public class NetDatacenterBroker extends SimEntity {\n\n\t// TODO: remove unnecessary variables\n\n\t/** The list of submitted VMs. */\n\tprivate List<? extends Vm> vmList;\n\n\t/** The list of created VMs. */\n\tprivate List<? extends Vm> vmsCreatedList;\n\n\t/** The list of submitted {@link NetworkCloudlet NetworkCloudlets}. */\n\tprivate List<? extends NetworkCloudlet> cloudletList;\n\n\t/** The list of submitted {@link AppCloudlet AppCloudlets}. */\n\tprivate List<? extends AppCloudlet> appCloudletList;\n\n\t/** The list of submitted {@link AppCloudlet AppCloudlets}.\n         * @todo attribute appears to be redundant with {@link #appCloudletList}\n         */\n\tprivate final Map<Integer, Integer> appCloudletRecieved;\n\n\t/** The list of submitted {@link Cloudlet Cloudlets}.\n         */\n\tprivate List<? extends Cloudlet> cloudletSubmittedList;\n\n\t/** The list of received {@link Cloudlet Cloudlets}.\n         * @todo attribute appears to be redundant with {@link #cloudletSubmittedList}\n         */\n\tprivate List<? extends Cloudlet> cloudletReceivedList;\n\n\t/** The number of submitted cloudlets. */\n\tprivate int cloudletsSubmitted;\n\n\t/** The number of VMs requested. */\n\tprivate int vmsRequested;\n\n\t/** The acks sent to VMs. */\n\tprivate int vmsAcks;\n\n\t/** The number of VMs destroyed. */\n\tprivate int vmsDestroyed;\n\n\t/** The list of datacenter IDs. */\n\tprivate List<Integer> datacenterIdsList;\n\n\t/** The datacenter requested IDs list. \n         * @todo attribute appears to be redundant with {@link #datacenterIdsList}\n         */\n\tprivate List<Integer> datacenterRequestedIdsList;\n\n\t/** The VMs to datacenters map where each key is a VM id\n         * and the corresponding value is the datacenter where the VM is placed. */\n\tprivate Map<Integer, Integer> vmsToDatacentersMap;\n\n\t/** The datacenter characteristics map where each key \n         * is the datacenter id and each value is the datacenter itself. */\n\tprivate Map<Integer, DatacenterCharacteristics> datacenterCharacteristicsList;\n\n\tpublic static NetworkDatacenter linkDC;\n\n\tpublic boolean createvmflag = true;\n\n\tpublic static int cachedcloudlet = 0;\n\n\t/**\n\t * Creates a new DatacenterBroker object.\n\t * \n\t * @param name name to be associated with this entity\n\t * \n\t * @throws Exception the exception\n\t * \n\t * @pre name != null\n\t * @post $none\n\t */\n\tpublic NetDatacenterBroker(String name) throws Exception {\n\t\tsuper(name);\n\n\t\tsetVmList(new ArrayList<NetworkVm>());\n\t\tsetVmsCreatedList(new ArrayList<NetworkVm>());\n\t\tsetCloudletList(new ArrayList<NetworkCloudlet>());\n\t\tsetAppCloudletList(new ArrayList<AppCloudlet>());\n\t\tsetCloudletSubmittedList(new ArrayList<Cloudlet>());\n\t\tsetCloudletReceivedList(new ArrayList<Cloudlet>());\n\t\tappCloudletRecieved = new HashMap<Integer, Integer>();\n\n\t\tcloudletsSubmitted = 0;\n\t\tsetVmsRequested(0);\n\t\tsetVmsAcks(0);\n\t\tsetVmsDestroyed(0);\n\n\t\tsetDatacenterIdsList(new LinkedList<Integer>());\n\t\tsetDatacenterRequestedIdsList(new ArrayList<Integer>());\n\t\tsetVmsToDatacentersMap(new HashMap<Integer, Integer>());\n\t\tsetDatacenterCharacteristicsList(new HashMap<Integer, DatacenterCharacteristics>());\n\n\t}\n\n\t/**\n\t * Sends to the broker the list with virtual machines that must be\n\t * created.\n\t * \n\t * @param list the list\n\t * \n\t * @pre list !=null\n\t * @post $none\n\t */\n\tpublic void submitVmList(List<? extends Vm> list) {\n\t\tgetVmList().addAll(list);\n\t}\n\n\t/**\n\t * Sends to the broker the list of cloudlets.\n\t * \n\t * @param list the list\n\t * \n\t * @pre list !=null\n\t * @post $none\n\t */\n\tpublic void submitCloudletList(List<? extends NetworkCloudlet> list) {\n\t\tgetCloudletList().addAll(list);\n\t}\n\n\tpublic static void setLinkDC(NetworkDatacenter alinkDC) {\n\t\tlinkDC = alinkDC;\n\t}\n\n\t/**\n\t * Processes events available for this Broker.\n\t * \n\t * @param ev a SimEvent object\n\t * \n\t * @pre ev != null\n\t * @post $none\n\t */\n\t@Override\n\tpublic void processEvent(SimEvent ev) {\n\t\tswitch (ev.getTag()) {\n\t\t// Resource characteristics request\n\t\t\tcase CloudSimTags.RESOURCE_CHARACTERISTICS_REQUEST:\n\t\t\t\tprocessResourceCharacteristicsRequest(ev);\n\t\t\t\tbreak;\n\t\t\t// Resource characteristics answer\n\t\t\tcase CloudSimTags.RESOURCE_CHARACTERISTICS:\n\t\t\t\tprocessResourceCharacteristics(ev);\n\t\t\t\tbreak;\n\t\t\t// VM Creation answer\n\n\t\t\t// A finished cloudlet returned\n\t\t\tcase CloudSimTags.CLOUDLET_RETURN:\n\t\t\t\tprocessCloudletReturn(ev);\n\t\t\t\tbreak;\n\t\t\t// if the simulation finishes\n\t\t\tcase CloudSimTags.END_OF_SIMULATION:\n\t\t\t\tshutdownEntity();\n\t\t\t\tbreak;\n\t\t\tcase CloudSimTags.NextCycle:\n\t\t\t\tif (NetworkConstants.BASE) {\n\t\t\t\t\tcreateVmsInDatacenterBase(linkDC.getId());\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t// other unknown tags are processed by this method\n\t\t\tdefault:\n\t\t\t\tprocessOtherEvent(ev);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Processes the return of a request for the characteristics of a Datacenter.\n\t * \n\t * @param ev a SimEvent object\n\t * \n\t * @pre ev != $null\n\t * @post $none\n\t */\n\tprotected void processResourceCharacteristics(SimEvent ev) {\n\t\tDatacenterCharacteristics characteristics = (DatacenterCharacteristics) ev.getData();\n\t\tgetDatacenterCharacteristicsList().put(characteristics.getId(), characteristics);\n\n\t\tif (getDatacenterCharacteristicsList().size() == getDatacenterIdsList().size()) {\n\t\t\tsetDatacenterRequestedIdsList(new ArrayList<Integer>());\n\t\t\tcreateVmsInDatacenterBase(getDatacenterIdsList().get(0));\n\t\t}\n\t}\n\n\t/**\n\t * Processes a request for the characteristics of a Datacenter.\n\t * \n\t * @param ev a SimEvent object\n\t * \n\t * @pre ev != $null\n\t * @post $none\n\t */\n\n\tprotected void processResourceCharacteristicsRequest(SimEvent ev) {\n\t\tsetDatacenterIdsList(CloudSim.getCloudResourceList());\n\t\tsetDatacenterCharacteristicsList(new HashMap<Integer, DatacenterCharacteristics>());\n\n\t\tLog.printConcatLine(CloudSim.clock(), \": \", getName(), \": Cloud Resource List received with \",\n\t\t\t\tgetDatacenterIdsList().size(), \" resource(s)\");\n\n\t\tfor (Integer datacenterId : getDatacenterIdsList()) {\n\t\t\tsendNow(datacenterId, CloudSimTags.RESOURCE_CHARACTERISTICS, getId());\n\t\t}\n\t}\n\n\t/**\n\t * Processes the ack received due to a request for VM creation.\n\t * \n\t * @param ev a SimEvent object\n\t * \n\t * @pre ev != null\n\t * @post $none\n\t */\n\n\t/**\n\t * Processes a cloudlet return event.\n\t * \n\t * @param ev a SimEvent object\n\t * \n\t * @pre ev != $null\n\t * @post $none\n\t */\n\tprotected void processCloudletReturn(SimEvent ev) {\n\t\tCloudlet cloudlet = (Cloudlet) ev.getData();\n\t\tgetCloudletReceivedList().add(cloudlet);\n\t\tcloudletsSubmitted--;\n\t\t// all cloudlets executed\n\t\tif (getCloudletList().size() == 0 && cloudletsSubmitted == 0 && NetworkConstants.iteration > 10) {\n\t\t\tLog.printConcatLine(CloudSim.clock(), \": \", getName(), \": All Cloudlets executed. Finishing...\");\n\t\t\tclearDatacenters();\n\t\t\tfinishExecution();\n\t\t} else { // some cloudlets haven't finished yet\n\t\t\tif (getAppCloudletList().size() > 0 && cloudletsSubmitted == 0) {\n\t\t\t\t// all the cloudlets sent finished. It means that some bount\n\t\t\t\t// cloudlet is waiting its VM be created\n\t\t\t\tclearDatacenters();\n\t\t\t\tcreateVmsInDatacenterBase(0);\n\t\t\t}\n\n\t\t}\n\t}\n\n\t/**\n\t * Processes non-default received events that aren't processed by\n         * the {@link #processEvent(org.cloudbus.cloudsim.core.SimEvent)} method.\n         * This method should be overridden by subclasses in other to process\n         * new defined events.\n\t * \n\t * @param ev a SimEvent object\n\t * \n\t * @pre ev != null\n\t * @post $none\n\t */\n\tprotected void processOtherEvent(SimEvent ev) {\n\t\tif (ev == null) {\n\t\t\tLog.printConcatLine(getName(), \".processOtherEvent(): Error - an event is null.\");\n\t\t\treturn;\n\t\t}\n\n\t\tLog.printConcatLine(getName(), \".processOtherEvent(): \",\n\t\t\t\t\"Error - event unknown by this DatacenterBroker.\");\n\t}\n\n\t/**\n\t * Creates virtual machines in a datacenter and submit/schedule cloudlets to them.\n\t * \n\t * @param datacenterId Id of the Datacenter to create the VMs\n\t * \n\t * @pre $none\n\t * @post $none\n\t */\n\tprotected void createVmsInDatacenterBase(int datacenterId) {\n\t\t// send as much vms as possible for this datacenter before trying the\n\t\t// next one\n\t\tint requestedVms = 0;\n\n\t\t// All host will have two VMs (assumption) VM is the minimum unit\n\t\tif (createvmflag) {\n\t\t\tCreateVMs(datacenterId);\n\t\t\tcreatevmflag = false;\n\t\t}\n\n\t\t// generate Application execution Requests\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tthis.getAppCloudletList().add(\n\t\t\t\t\tnew WorkflowApp(AppCloudlet.APP_Workflow, NetworkConstants.currentAppId, 0, 0, getId()));\n\t\t\tNetworkConstants.currentAppId++;\n\n\t\t}\n\t\tint k = 0;\n\n\t\t// schedule the application on VMs\n\t\tfor (AppCloudlet app : this.getAppCloudletList()) {\n\n\t\t\tList<Integer> vmids = new ArrayList<Integer>();\n\t\t\tint numVms = linkDC.getVmList().size();\n\t\t\tUniformDistr ufrnd = new UniformDistr(0, numVms, 5);\n\t\t\tfor (int i = 0; i < app.numbervm; i++) {\n\n\t\t\t\tint vmid = (int) ufrnd.sample();\n\t\t\t\tvmids.add(vmid);\n\n\t\t\t}\n\n\t\t\tif (vmids != null) {\n\t\t\t\tif (!vmids.isEmpty()) {\n\n\t\t\t\t\tapp.createCloudletList(vmids);\n\t\t\t\t\tfor (int i = 0; i < app.numbervm; i++) {\n\t\t\t\t\t\tapp.clist.get(i).setUserId(getId());\n\t\t\t\t\t\tappCloudletRecieved.put(app.appID, app.numbervm);\n\t\t\t\t\t\tthis.getCloudletSubmittedList().add(app.clist.get(i));\n\t\t\t\t\t\tcloudletsSubmitted++;\n\n\t\t\t\t\t\t// Sending cloudlet\n\t\t\t\t\t\tsendNow(\n\t\t\t\t\t\t\t\tgetVmsToDatacentersMap().get(this.getVmList().get(0).getId()),\n\t\t\t\t\t\t\t\tCloudSimTags.CLOUDLET_SUBMIT,\n\t\t\t\t\t\t\t\tapp.clist.get(i));\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(\"app\" + (k++));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tsetAppCloudletList(new ArrayList<AppCloudlet>());\n\t\tif (NetworkConstants.iteration < 10) {\n\n\t\t\tNetworkConstants.iteration++;\n\t\t\tthis.schedule(getId(), NetworkConstants.nexttime, CloudSimTags.NextCycle);\n\t\t}\n\n\t\tsetVmsRequested(requestedVms);\n\t\tsetVmsAcks(0);\n\t}\n\n        /**\n         * Creates virtual machines in a datacenter\n         * @param datacenterId The id of the datacenter where to create the VMs.\n         */\n\tprivate void CreateVMs(int datacenterId) {\n\t\t// two VMs per host\n\t\tint numVM = linkDC.getHostList().size() * NetworkConstants.maxhostVM;\n\t\tfor (int i = 0; i < numVM; i++) {\n\t\t\tint vmid = i;\n\t\t\tint mips = 1;\n\t\t\tlong size = 10000; // image size (MB)\n\t\t\tint ram = 512; // vm memory (MB)\n\t\t\tlong bw = 1000;\n\t\t\tint pesNumber = NetworkConstants.HOST_PEs / NetworkConstants.maxhostVM;\n\t\t\tString vmm = \"Xen\"; // VMM name\n\n\t\t\t// create VM\n\t\t\tNetworkVm vm = new NetworkVm(\n\t\t\t\t\tvmid,\n\t\t\t\t\tgetId(),\n\t\t\t\t\tmips,\n\t\t\t\t\tpesNumber,\n\t\t\t\t\tram,\n\t\t\t\t\tbw,\n\t\t\t\t\tsize,\n\t\t\t\t\tvmm,\n\t\t\t\t\tnew NetworkCloudletSpaceSharedScheduler());\n\t\t\tlinkDC.processVmCreateNetwork(vm);\n\t\t\t// add the VM to the vmList\n\t\t\tgetVmList().add(vm);\n\t\t\tgetVmsToDatacentersMap().put(vmid, datacenterId);\n\t\t\tgetVmsCreatedList().add(VmList.getById(getVmList(), vmid));\n\t\t}\n\t}\n\n\t/**\n\t * Sends request to destroy all VMs running on the datacenter.\n\t * \n\t * @pre $none\n\t * @post $none /** Destroy the virtual machines running in datacenters.\n\t * \n\t * @pre $none\n\t * @post $none\n\t */\n\tprotected void clearDatacenters() {\n\t\tfor (Vm vm : getVmsCreatedList()) {\n\t\t\tLog.printConcatLine(CloudSim.clock(), \": \", getName(), \": Destroying VM #\", vm.getId());\n\t\t\tsendNow(getVmsToDatacentersMap().get(vm.getId()), CloudSimTags.VM_DESTROY, vm);\n\t\t}\n\n\t\tgetVmsCreatedList().clear();\n\t}\n\n\t/**\n\t * Sends an internal event communicating the end of the simulation.\n\t * \n\t * @pre $none\n\t * @post $none\n\t */\n\tprivate void finishExecution() {\n\t\tsendNow(getId(), CloudSimTags.END_OF_SIMULATION);\n\t}\n\n\t@Override\n\tpublic void shutdownEntity() {\n\t\tLog.printConcatLine(getName(), \" is shutting down...\");\n\t}\n\n\t@Override\n\tpublic void startEntity() {\n\t\tLog.printConcatLine(getName(), \" is starting...\");\n\t\tschedule(getId(), 0, CloudSimTags.RESOURCE_CHARACTERISTICS_REQUEST);\n\t}\n\n\t/**\n\t * Gets the vm list.\n\t * \n\t * @param <T> the generic type\n\t * @return the vm list\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T extends Vm> List<T> getVmList() {\n\t\treturn (List<T>) vmList;\n\t}\n\n\t/**\n\t * Sets the vm list.\n\t * \n\t * @param <T> the generic type\n\t * @param vmList the new vm list\n\t */\n\tprotected <T extends Vm> void setVmList(List<T> vmList) {\n\t\tthis.vmList = vmList;\n\t}\n\n\t/**\n\t * Gets the cloudlet list.\n\t * \n\t * @param <T> the generic type\n\t * @return the cloudlet list\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T extends NetworkCloudlet> List<T> getCloudletList() {\n\t\treturn (List<T>) cloudletList;\n\t}\n\n\t/**\n\t * Sets the cloudlet list.\n\t * \n\t * @param <T> the generic type\n\t * @param cloudletList the new cloudlet list\n\t */\n\tprotected <T extends NetworkCloudlet> void setCloudletList(List<T> cloudletList) {\n\t\tthis.cloudletList = cloudletList;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T extends AppCloudlet> List<T> getAppCloudletList() {\n\t\treturn (List<T>) appCloudletList;\n\t}\n\n\tpublic <T extends AppCloudlet> void setAppCloudletList(List<T> appCloudletList) {\n\t\tthis.appCloudletList = appCloudletList;\n\t}\n\n\t/**\n\t * Gets the cloudlet submitted list.\n\t * \n\t * @param <T> the generic type\n\t * @return the cloudlet submitted list\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T extends Cloudlet> List<T> getCloudletSubmittedList() {\n\t\treturn (List<T>) cloudletSubmittedList;\n\t}\n\n\t/**\n\t * Sets the cloudlet submitted list.\n\t * \n\t * @param <T> the generic type\n\t * @param cloudletSubmittedList the new cloudlet submitted list\n\t */\n\tprotected <T extends Cloudlet> void setCloudletSubmittedList(List<T> cloudletSubmittedList) {\n\t\tthis.cloudletSubmittedList = cloudletSubmittedList;\n\t}\n\n\t/**\n\t * Gets the cloudlet received list.\n\t * \n\t * @param <T> the generic type\n\t * @return the cloudlet received list\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T extends Cloudlet> List<T> getCloudletReceivedList() {\n\t\treturn (List<T>) cloudletReceivedList;\n\t}\n\n\t/**\n\t * Sets the cloudlet received list.\n\t * \n\t * @param <T> the generic type\n\t * @param cloudletReceivedList the new cloudlet received list\n\t */\n\tprotected <T extends Cloudlet> void setCloudletReceivedList(List<T> cloudletReceivedList) {\n\t\tthis.cloudletReceivedList = cloudletReceivedList;\n\t}\n\n\t/**\n\t * Gets the vm list.\n\t * \n\t * @param <T> the generic type\n\t * @return the vm list\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T extends Vm> List<T> getVmsCreatedList() {\n\t\treturn (List<T>) vmsCreatedList;\n\t}\n\n\t/**\n\t * Sets the vm list.\n\t * \n\t * @param <T> the generic type\n\t * @param vmsCreatedList the vms created list\n\t */\n\tprotected <T extends Vm> void setVmsCreatedList(List<T> vmsCreatedList) {\n\t\tthis.vmsCreatedList = vmsCreatedList;\n\t}\n\n\t/**\n\t * Gets the vms requested.\n\t * \n\t * @return the vms requested\n\t */\n\tprotected int getVmsRequested() {\n\t\treturn vmsRequested;\n\t}\n\n\t/**\n\t * Sets the vms requested.\n\t * \n\t * @param vmsRequested the new vms requested\n\t */\n\tprotected void setVmsRequested(int vmsRequested) {\n\t\tthis.vmsRequested = vmsRequested;\n\t}\n\n\t/**\n\t * Gets the vms acks.\n\t * \n\t * @return the vms acks\n\t */\n\tprotected int getVmsAcks() {\n\t\treturn vmsAcks;\n\t}\n\n\t/**\n\t * Sets the vms acks.\n\t * \n\t * @param vmsAcks the new vms acks\n\t */\n\tprotected void setVmsAcks(int vmsAcks) {\n\t\tthis.vmsAcks = vmsAcks;\n\t}\n\n\t/**\n\t * Increment vms acks.\n\t */\n\tprotected void incrementVmsAcks() {\n\t\tvmsAcks++;\n\t}\n\n\t/**\n\t * Gets the vms destroyed.\n\t * \n\t * @return the vms destroyed\n\t */\n\tprotected int getVmsDestroyed() {\n\t\treturn vmsDestroyed;\n\t}\n\n\t/**\n\t * Sets the vms destroyed.\n\t * \n\t * @param vmsDestroyed the new vms destroyed\n\t */\n\tprotected void setVmsDestroyed(int vmsDestroyed) {\n\t\tthis.vmsDestroyed = vmsDestroyed;\n\t}\n\n\t/**\n\t * Gets the datacenter ids list.\n\t * \n\t * @return the datacenter ids list\n\t */\n\tprotected List<Integer> getDatacenterIdsList() {\n\t\treturn datacenterIdsList;\n\t}\n\n\t/**\n\t * Sets the datacenter ids list.\n\t * \n\t * @param datacenterIdsList the new datacenter ids list\n\t */\n\tprotected void setDatacenterIdsList(List<Integer> datacenterIdsList) {\n\t\tthis.datacenterIdsList = datacenterIdsList;\n\t}\n\n\t/**\n\t * Gets the vms to datacenters map.\n\t * \n\t * @return the vms to datacenters map\n\t */\n\tprotected Map<Integer, Integer> getVmsToDatacentersMap() {\n\t\treturn vmsToDatacentersMap;\n\t}\n\n\t/**\n\t * Sets the vms to datacenters map.\n\t * \n\t * @param vmsToDatacentersMap the vms to datacenters map\n\t */\n\tprotected void setVmsToDatacentersMap(Map<Integer, Integer> vmsToDatacentersMap) {\n\t\tthis.vmsToDatacentersMap = vmsToDatacentersMap;\n\t}\n\n\t/**\n\t * Gets the datacenter characteristics list.\n\t * \n\t * @return the datacenter characteristics list\n\t */\n\tprotected Map<Integer, DatacenterCharacteristics> getDatacenterCharacteristicsList() {\n\t\treturn datacenterCharacteristicsList;\n\t}\n\n\t/**\n\t * Sets the datacenter characteristics list.\n\t * \n\t * @param datacenterCharacteristicsList the datacenter characteristics list\n\t */\n\tprotected void setDatacenterCharacteristicsList(\n\t\t\tMap<Integer, DatacenterCharacteristics> datacenterCharacteristicsList) {\n\t\tthis.datacenterCharacteristicsList = datacenterCharacteristicsList;\n\t}\n\n\t/**\n\t * Gets the datacenter requested ids list.\n\t * \n\t * @return the datacenter requested ids list\n\t */\n\tprotected List<Integer> getDatacenterRequestedIdsList() {\n\t\treturn datacenterRequestedIdsList;\n\t}\n\n\t/**\n\t * Sets the datacenter requested ids list.\n\t * \n\t * @param datacenterRequestedIdsList the new datacenter requested ids list\n\t */\n\tprotected void setDatacenterRequestedIdsList(List<Integer> datacenterRequestedIdsList) {\n\t\tthis.datacenterRequestedIdsList = datacenterRequestedIdsList;\n\t}\n\n}", "class_id": 0, "repo": "wildd0g/cloudsim", "file": "modules/cloudsim/src/main/java/org/cloudbus/cloudsim/network/datacenter/NetDatacenterBroker.java", "last_update_at": "2020-04-04T21:49:17+00:00", "question_id": "3b3b5d70ff3d2c91f7fc2e714c2484c0624ad0c6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NetDatacenterBroker extends SimEntity {\n\t// TODO: remove unnecessary variables\n\t/** The list of submitted VMs. */\n\tprivate List<? extends Vm> vmList;\n\t/** The list of created VMs. */\n\tprivate List<? extends Vm> vmsCreatedList;\n\t/** The list of submitted {@link NetworkCloudlet NetworkCloudlets}. */\n\tprivate List<? extends NetworkCloudlet> cloudletList;\n\t/** The list of submitted {@link AppCloudlet AppCloudlets}. */\n\tprivate List<? extends AppCloudlet> appCloudletList;\n\t/** The list of submitted {@link AppCloudlet AppCloudlets}.\n         * @todo attribute appears to be redundant with {@link #appCloudletList}\n         */\n\tprivate final Map<Integer, Integer> appCloudletRecieved;\n\t/** The list of submitted {@link Cloudlet Cloudlets}.\n         */\n\tprivate List<? extends Cloudlet> cloudletSubmittedList;\n\t/** The list of received {@link Cloudlet Cloudlets}.\n         * @todo attribute appears to be redundant with {@link #cloudletSubmittedList}\n         */\n\tprivate List<? extends Cloudlet> cloudletReceivedList;\n\t/** The number of submitted cloudlets. */\n\tprivate int cloudletsSubmitted;\n\t/** The number of VMs requested. */\n\tprivate int vmsRequested;\n\t/** The acks sent to VMs. */\n\tprivate int vmsAcks;\n\t/** The number of VMs destroyed. */\n\tprivate int vmsDestroyed;\n\t/** The list of datacenter IDs. */\n\tprivate List<Integer> datacenterIdsList;\n\t/** The datacenter requested IDs list. \n         * @todo attribute appears to be redundant with {@link #datacenterIdsList}\n         */\n\tprivate List<Integer> datacenterRequestedIdsList;\n\t/** The VMs to datacenters map where each key is a VM id\n         * and the corresponding value is the datacenter where the VM is placed. */\n\tprivate Map<Integer, Integer> vmsToDatacentersMap;\n\t/** The datacenter characteristics map where each key \n         * is the datacenter id and each value is the datacenter itself. */\n\tprivate Map<Integer, DatacenterCharacteristics> datacenterCharacteristicsList;\n\tpublic static NetworkDatacenter linkDC;\n\tpublic boolean createvmflag = true;\n\tpublic static int cachedcloudlet = 0;\n\t/**\n\t * Creates a new DatacenterBroker object.\n\t * \n\t * @param name name to be associated with this entity\n\t * \n\t * @throws Exception the exception\n\t * \n\t * @pre name != null\n\t * @post $none\n\t */\n\tpublic NetDatacenterBroker(String name) throws Exception {\n\t\tsuper(name);\n\t\tsetVmList(new ArrayList<NetworkVm>());\n\t\tsetVmsCreatedList(new ArrayList<NetworkVm>());\n\t\tsetCloudletList(new ArrayList<NetworkCloudlet>());\n\t\tsetAppCloudletList(new ArrayList<AppCloudlet>());\n\t\tsetCloudletSubmittedList(new ArrayList<Cloudlet>());\n\t\tsetCloudletReceivedList(new ArrayList<Cloudlet>());\n\t\tappCloudletRecieved = new HashMap<Integer, Integer>();\n\t\tcloudletsSubmitted = 0;\n\t\tsetVmsRequested(0);\n\t\tsetVmsAcks(0);\n\t\tsetVmsDestroyed(0);\n\t\tsetDatacenterIdsList(new LinkedList<Integer>());\n\t\tsetDatacenterRequestedIdsList(new ArrayList<Integer>());\n\t\tsetVmsToDatacentersMap(new HashMap<Integer, Integer>());\n\t\tsetDatacenterCharacteristicsList(new HashMap<Integer, DatacenterCharacteristics>());\n\t}\n\t/**\n\t * Sends to the broker the list with virtual machines that must be\n\t * created.\n\t * \n\t * @param list the list\n\t * \n\t * @pre list !=null\n\t * @post $none\n\t */\n\tpublic void submitVmList(List<? extends Vm> list) {\n\t\tgetVmList().addAll(list);\n\t}\n\t/**\n\t * Sends to the broker the list of cloudlets.\n\t * \n\t * @param list the list\n\t * \n\t * @pre list !=null\n\t * @post $none\n\t */\n\tpublic void submitCloudletList(List<? extends NetworkCloudlet> list) {\n\t\tgetCloudletList().addAll(list);\n\t}\n\tpublic static void setLinkDC(NetworkDatacenter alinkDC) {\n\t\tlinkDC = alinkDC;\n\t}\n\t/**\n\t * Processes events available for this Broker.\n\t * \n\t * @param ev a SimEvent object\n\t * \n\t * @pre ev != null\n\t * @post $none\n\t */\n\t@Override\n\tpublic void processEvent(SimEvent ev) {\n\t\tswitch (ev.getTag()) {\n\t\t// Resource characteristics request\n\t\t\tcase CloudSimTags.RESOURCE_CHARACTERISTICS_REQUEST:\n\t\t\t\tprocessResourceCharacteristicsRequest(ev);\n\t\t\t\tbreak;\n\t\t\t// Resource characteristics answer\n\t\t\tcase CloudSimTags.RESOURCE_CHARACTERISTICS:\n\t\t\t\tprocessResourceCharacteristics(ev);\n\t\t\t\tbreak;\n\t\t\t// VM Creation answer\n\t\t\t// A finished cloudlet returned\n\t\t\tcase CloudSimTags.CLOUDLET_RETURN:\n\t\t\t\tprocessCloudletReturn(ev);\n\t\t\t\tbreak;\n\t\t\t// if the simulation finishes\n\t\t\tcase CloudSimTags.END_OF_SIMULATION:\n\t\t\t\tshutdownEntity();\n\t\t\t\tbreak;\n\t\t\tcase CloudSimTags.NextCycle:\n\t\t\t\tif (NetworkConstants.BASE) {\n\t\t\t\t\tcreateVmsInDatacenterBase(linkDC.getId());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// other unknown tags are processed by this method\n\t\t\tdefault:\n\t\t\t\tprocessOtherEvent(ev);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/**\n\t * Processes the return of a request for the characteristics of a Datacenter.\n\t * \n\t * @param ev a SimEvent object\n\t * \n\t * @pre ev != $null\n\t * @post $none\n\t */\n\tprotected void processResourceCharacteristics(SimEvent ev) {\n\t\tDatacenterCharacteristics characteristics = (DatacenterCharacteristics) ev.getData();\n\t\tgetDatacenterCharacteristicsList().put(characteristics.getId(), characteristics);\n\t\tif (getDatacenterCharacteristicsList().size() == getDatacenterIdsList().size()) {\n\t\t\tsetDatacenterRequestedIdsList(new ArrayList<Integer>());\n\t\t\tcreateVmsInDatacenterBase(getDatacenterIdsList().get(0));\n\t\t}\n\t}\n\t/**\n\t * Processes a request for the characteristics of a Datacenter.\n\t * \n\t * @param ev a SimEvent object\n\t * \n\t * @pre ev != $null\n\t * @post $none\n\t */\n\tprotected void processResourceCharacteristicsRequest(SimEvent ev) {\n\t\tsetDatacenterIdsList(CloudSim.getCloudResourceList());\n\t\tsetDatacenterCharacteristicsList(new HashMap<Integer, DatacenterCharacteristics>());\n\t\tLog.printConcatLine(CloudSim.clock(), \": \", getName(), \": Cloud Resource List received with \",\n\t\t\t\tgetDatacenterIdsList().size(), \" resource(s)\");\n\t\tfor (Integer datacenterId : getDatacenterIdsList()) {\n\t\t\tsendNow(datacenterId, CloudSimTags.RESOURCE_CHARACTERISTICS, getId());\n\t\t}\n\t}\n\t/**\n\t * Processes the ack received due to a request for VM creation.\n\t * \n\t * @param ev a SimEvent object\n\t * \n\t * @pre ev != null\n\t * @post $none\n\t */\n\t/**\n\t * Processes a cloudlet return event.\n\t * \n\t * @param ev a SimEvent object\n\t * \n\t * @pre ev != $null\n\t * @post $none\n\t */\n\tprotected void processCloudletReturn(SimEvent ev) {\n\t\tCloudlet cloudlet = (Cloudlet) ev.getData();\n\t\tgetCloudletReceivedList().add(cloudlet);\n\t\tcloudletsSubmitted--;\n\t\t// all cloudlets executed\n\t\tif (getCloudletList().size() == 0 && cloudletsSubmitted == 0 && NetworkConstants.iteration > 10) {\n\t\t\tLog.printConcatLine(CloudSim.clock(), \": \", getName(), \": All Cloudlets executed. Finishing...\");\n\t\t\tclearDatacenters();\n\t\t\tfinishExecution();\n\t\t} else { // some cloudlets haven't finished yet\n\t\t\tif (getAppCloudletList().size() > 0 && cloudletsSubmitted == 0) {\n\t\t\t\t// all the cloudlets sent finished. It means that some bount\n\t\t\t\t// cloudlet is waiting its VM be created\n\t\t\t\tclearDatacenters();\n\t\t\t\tcreateVmsInDatacenterBase(0);\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Processes non-default received events that aren't processed by\n         * the {@link #processEvent(org.cloudbus.cloudsim.core.SimEvent)} method.\n         * This method should be overridden by subclasses in other to process\n         * new defined events.\n\t * \n\t * @param ev a SimEvent object\n\t * \n\t * @pre ev != null\n\t * @post $none\n\t */\n\tprotected void processOtherEvent(SimEvent ev) {\n\t\tif (ev == null) {\n\t\t\tLog.printConcatLine(getName(), \".processOtherEvent(): Error - an event is null.\");\n\t\t\treturn;\n\t\t}\n\t\tLog.printConcatLine(getName(), \".processOtherEvent(): \",\n\t\t\t\t\"Error - event unknown by this DatacenterBroker.\");\n\t}\n\t/**\n\t * Creates virtual machines in a datacenter and submit/schedule cloudlets to them.\n\t * \n\t * @param datacenterId Id of the Datacenter to create the VMs\n\t * \n\t * @pre $none\n\t * @post $none\n\t */\n\tprotected void createVmsInDatacenterBase(int datacenterId) {\n\t\t// send as much vms as possible for this datacenter before trying the\n\t\t// next one\n\t\tint requestedVms = 0;\n\t\t// All host will have two VMs (assumption) VM is the minimum unit\n\t\tif (createvmflag) {\n\t\t\tCreateVMs(datacenterId);\n\t\t\tcreatevmflag = false;\n\t\t}\n\t\t// generate Application execution Requests\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tthis.getAppCloudletList().add(\n\t\t\t\t\tnew WorkflowApp(AppCloudlet.APP_Workflow, NetworkConstants.currentAppId, 0, 0, getId()));\n\t\t\tNetworkConstants.currentAppId++;\n\t\t}\n\t\tint k = 0;\n\t\t// schedule the application on VMs\n\t\tfor (AppCloudlet app : this.getAppCloudletList()) {\n\t\t\tList<Integer> vmids = new ArrayList<Integer>();\n\t\t\tint numVms = linkDC.getVmList().size();\n\t\t\tUniformDistr ufrnd = new UniformDistr(0, numVms, 5);\n\t\t\tfor (int i = 0; i < app.numbervm; i++) {\n\t\t\t\tint vmid = (int) ufrnd.sample();\n\t\t\t\tvmids.add(vmid);\n\t\t\t}\n\t\t\tif (vmids != null) {\n\t\t\t\tif (!vmids.isEmpty()) {\n\t\t\t\t\tapp.createCloudletList(vmids);\n\t\t\t\t\tfor (int i = 0; i < app.numbervm; i++) {\n\t\t\t\t\t\tapp.clist.get(i).setUserId(getId());\n\t\t\t\t\t\tappCloudletRecieved.put(app.appID, app.numbervm);\n\t\t\t\t\t\tthis.getCloudletSubmittedList().add(app.clist.get(i));\n\t\t\t\t\t\tcloudletsSubmitted++;\n\t\t\t\t\t\t// Sending cloudlet\n\t\t\t\t\t\tsendNow(\n\t\t\t\t\t\t\t\tgetVmsToDatacentersMap().get(this.getVmList().get(0).getId()),\n\t\t\t\t\t\t\t\tCloudSimTags.CLOUDLET_SUBMIT,\n\t\t\t\t\t\t\t\tapp.clist.get(i));\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(\"app\" + (k++));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsetAppCloudletList(new ArrayList<AppCloudlet>());\n\t\tif (NetworkConstants.iteration < 10) {\n\t\t\tNetworkConstants.iteration++;\n\t\t\tthis.schedule(getId(), NetworkConstants.nexttime, CloudSimTags.NextCycle);\n\t\t}\n\t\tsetVmsRequested(requestedVms);\n\t\tsetVmsAcks(0);\n\t}\n        /**\n         * Creates virtual machines in a datacenter\n         * @param datacenterId The id of the datacenter where to create the VMs.\n         */\n\tprivate void CreateVMs(int datacenterId) {\n\t\t// two VMs per host\n\t\tint numVM = linkDC.getHostList().size() * NetworkConstants.maxhostVM;\n\t\tfor (int i = 0; i < numVM; i++) {\n\t\t\tint vmid = i;\n\t\t\tint mips = 1;\n\t\t\tlong size = 10000; // image size (MB)\n\t\t\tint ram = 512; // vm memory (MB)\n\t\t\tlong bw = 1000;\n\t\t\tint pesNumber = NetworkConstants.HOST_PEs / NetworkConstants.maxhostVM;\n\t\t\tString vmm = \"Xen\"; // VMM name\n\t\t\t// create VM\n\t\t\tNetworkVm vm = new NetworkVm(\n\t\t\t\t\tvmid,\n\t\t\t\t\tgetId(),\n\t\t\t\t\tmips,\n\t\t\t\t\tpesNumber,\n\t\t\t\t\tram,\n\t\t\t\t\tbw,\n\t\t\t\t\tsize,\n\t\t\t\t\tvmm,\n\t\t\t\t\tnew NetworkCloudletSpaceSharedScheduler());\n\t\t\tlinkDC.processVmCreateNetwork(vm);\n\t\t\t// add the VM to the vmList\n\t\t\tgetVmList().add(vm);\n\t\t\tgetVmsToDatacentersMap().put(vmid, datacenterId);\n\t\t\tgetVmsCreatedList().add(VmList.getById(getVmList(), vmid));\n\t\t}\n\t}\n\t/**\n\t * Sends request to destroy all VMs running on the datacenter.\n\t * \n\t * @pre $none\n\t * @post $none /** Destroy the virtual machines running in datacenters.\n\t * \n\t * @pre $none\n\t * @post $none\n\t */\n\tprotected void clearDatacenters() {\n\t\tfor (Vm vm : getVmsCreatedList()) {\n\t\t\tLog.printConcatLine(CloudSim.clock(), \": \", getName(), \": Destroying VM #\", vm.getId());\n\t\t\tsendNow(getVmsToDatacentersMap().get(vm.getId()), CloudSimTags.VM_DESTROY, vm);\n\t\t}\n\t\tgetVmsCreatedList().clear();\n\t}\n\t/**\n\t * Sends an internal event communicating the end of the simulation.\n\t * \n\t * @pre $none\n\t * @post $none\n\t */\n\tprivate void finishExecution() {\n\t\tsendNow(getId(), CloudSimTags.END_OF_SIMULATION);\n\t}\n\t@Override\n\tpublic void shutdownEntity() {\n\t\tLog.printConcatLine(getName(), \" is shutting down...\");\n\t}\n\t@Override\n\tpublic void startEntity() {\n\t\tLog.printConcatLine(getName(), \" is starting...\");\n\t\tschedule(getId(), 0, CloudSimTags.RESOURCE_CHARACTERISTICS_REQUEST);\n\t}\n\t/**\n\t * Gets the vm list.\n\t * \n\t * @param <T> the generic type\n\t * @return the vm list\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T extends Vm> List<T> getVmList() {\n\t\treturn (List<T>) vmList;\n\t}\n\t/**\n\t * Sets the vm list.\n\t * \n\t * @param <T> the generic type\n\t * @param vmList the new vm list\n\t */\n\tprotected <T extends Vm> void setVmList(List<T> vmList) {\n\t\tthis.vmList = vmList;\n\t}\n\t/**\n\t * Gets the cloudlet list.\n\t * \n\t * @param <T> the generic type\n\t * @return the cloudlet list\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T extends NetworkCloudlet> List<T> getCloudletList() {\n\t\treturn (List<T>) cloudletList;\n\t}\n\t/**\n\t * Sets the cloudlet list.\n\t * \n\t * @param <T> the generic type\n\t * @param cloudletList the new cloudlet list\n\t */\n\tprotected <T extends NetworkCloudlet> void setCloudletList(List<T> cloudletList) {\n\t\tthis.cloudletList = cloudletList;\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T extends AppCloudlet> List<T> getAppCloudletList() {\n\t\treturn (List<T>) appCloudletList;\n\t}\n\tpublic <T extends AppCloudlet> void setAppCloudletList(List<T> appCloudletList) {\n\t\tthis.appCloudletList = appCloudletList;\n\t}\n\t/**\n\t * Gets the cloudlet submitted list.\n\t * \n\t * @param <T> the generic type\n\t * @return the cloudlet submitted list\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T extends Cloudlet> List<T> getCloudletSubmittedList() {\n\t\treturn (List<T>) cloudletSubmittedList;\n\t}\n\t/**\n\t * Sets the cloudlet submitted list.\n\t * \n\t * @param <T> the generic type\n\t * @param cloudletSubmittedList the new cloudlet submitted list\n\t */\n\tprotected <T extends Cloudlet> void setCloudletSubmittedList(List<T> cloudletSubmittedList) {\n\t\tthis.cloudletSubmittedList = cloudletSubmittedList;\n\t}\n\t/**\n\t * Gets the cloudlet received list.\n\t * \n\t * @param <T> the generic type\n\t * @return the cloudlet received list\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T extends Cloudlet> List<T> getCloudletReceivedList() {\n\t\treturn (List<T>) cloudletReceivedList;\n\t}\n\t/**\n\t * Sets the cloudlet received list.\n\t * \n\t * @param <T> the generic type\n\t * @param cloudletReceivedList the new cloudlet received list\n\t */\n\tprotected <T extends Cloudlet> void setCloudletReceivedList(List<T> cloudletReceivedList) {\n\t\tthis.cloudletReceivedList = cloudletReceivedList;\n\t}\n\t/**\n\t * Gets the vm list.\n\t * \n\t * @param <T> the generic type\n\t * @return the vm list\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T extends Vm> List<T> getVmsCreatedList() {\n\t\treturn (List<T>) vmsCreatedList;\n\t}\n\t/**\n\t * Sets the vm list.\n\t * \n\t * @param <T> the generic type\n\t * @param vmsCreatedList the vms created list\n\t */\n\tprotected <T extends Vm> void setVmsCreatedList(List<T> vmsCreatedList) {\n\t\tthis.vmsCreatedList = vmsCreatedList;\n\t}\n\t/**\n\t * Gets the vms requested.\n\t * \n\t * @return the vms requested\n\t */\n\tprotected int getVmsRequested() {\n\t\treturn vmsRequested;\n\t}\n\t/**\n\t * Sets the vms requested.\n\t * \n\t * @param vmsRequested the new vms requested\n\t */\n\tprotected void setVmsRequested(int vmsRequested) {\n\t\tthis.vmsRequested = vmsRequested;\n\t}\n\t/**\n\t * Gets the vms acks.\n\t * \n\t * @return the vms acks\n\t */\n\tprotected int getVmsAcks() {\n\t\treturn vmsAcks;\n\t}\n\t/**\n\t * Sets the vms acks.\n\t * \n\t * @param vmsAcks the new vms acks\n\t */\n\tprotected void setVmsAcks(int vmsAcks) {\n\t\tthis.vmsAcks = vmsAcks;\n\t}\n\t/**\n\t * Increment vms acks.\n\t */\n\tprotected void incrementVmsAcks() {\n\t\tvmsAcks++;\n\t}\n\t/**\n\t * Gets the vms destroyed.\n\t * \n\t * @return the vms destroyed\n\t */\n\tprotected int getVmsDestroyed() {\n\t\treturn vmsDestroyed;\n\t}\n\t/**\n\t * Sets the vms destroyed.\n\t * \n\t * @param vmsDestroyed the new vms destroyed\n\t */\n\tprotected void setVmsDestroyed(int vmsDestroyed) {\n\t\tthis.vmsDestroyed = vmsDestroyed;\n\t}\n\t/**\n\t * Gets the datacenter ids list.\n\t * \n\t * @return the datacenter ids list\n\t */\n\tprotected List<Integer> getDatacenterIdsList() {\n\t\treturn datacenterIdsList;\n\t}\n\t/**\n\t * Sets the datacenter ids list.\n\t * \n\t * @param datacenterIdsList the new datacenter ids list\n\t */\n\tprotected void setDatacenterIdsList(List<Integer> datacenterIdsList) {\n\t\tthis.datacenterIdsList = datacenterIdsList;\n\t}\n\t/**\n\t * Gets the vms to datacenters map.\n\t * \n\t * @return the vms to datacenters map\n\t */\n\tprotected Map<Integer, Integer> getVmsToDatacentersMap() {\n\t\treturn vmsToDatacentersMap;\n\t}\n\t/**\n\t * Sets the vms to datacenters map.\n\t * \n\t * @param vmsToDatacentersMap the vms to datacenters map\n\t */\n\tprotected void setVmsToDatacentersMap(Map<Integer, Integer> vmsToDatacentersMap) {\n\t\tthis.vmsToDatacentersMap = vmsToDatacentersMap;\n\t}\n\t/**\n\t * Gets the datacenter characteristics list.\n\t * \n\t * @return the datacenter characteristics list\n\t */\n\tprotected Map<Integer, DatacenterCharacteristics> getDatacenterCharacteristicsList() {\n\t\treturn datacenterCharacteristicsList;\n\t}\n\t/**\n\t * Sets the datacenter characteristics list.\n\t * \n\t * @param datacenterCharacteristicsList the datacenter characteristics list\n\t */\n\tprotected void setDatacenterCharacteristicsList(\n\t\t\tMap<Integer, DatacenterCharacteristics> datacenterCharacteristicsList) {\n\t\tthis.datacenterCharacteristicsList = datacenterCharacteristicsList;\n\t}\n\t/**\n\t * Gets the datacenter requested ids list.\n\t * \n\t * @return the datacenter requested ids list\n\t */\n\tprotected List<Integer> getDatacenterRequestedIdsList() {\n\t\treturn datacenterRequestedIdsList;\n\t}\n\t/**\n\t * Sets the datacenter requested ids list.\n\t * \n\t * @param datacenterRequestedIdsList the new datacenter requested ids list\n\t */\n\tprotected void setDatacenterRequestedIdsList(List<Integer> datacenterRequestedIdsList) {\n\t\tthis.datacenterRequestedIdsList = datacenterRequestedIdsList;\n\t}\n"]]}
{"hexsha": "82cde573ee27b8e140b79ba9b3a8091d3135b421", "ext": "java", "lang": "Java", "content": "public class TestApiControllerIT {\n\n    @Test\n    public void testMethodTest() throws Exception {\n        final String requestURL = \"http://localhost:8002//test\";\n        final HttpClient client = HttpClientBuilder.create().build();\n        final HttpResponse response = client.execute(new HttpGet(requestURL));\n        assertEquals(response.getStatusLine().getStatusCode(), 501);\n    }\n}", "class_id": 0, "repo": "Cadcorp/swagger-codegen", "file": "samples/server/petstore/spring-mvc/src/test/java/io/swagger/api/TestApiControllerIT.java", "last_update_at": "2020-09-06T18:36:28+00:00", "question_id": "82cde573ee27b8e140b79ba9b3a8091d3135b421", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestApiControllerIT {\n    @Test\n    public void testMethodTest() throws Exception {\n        final String requestURL = \"http://localhost:8002//test\";\n        final HttpClient client = HttpClientBuilder.create().build();\n        final HttpResponse response = client.execute(new HttpGet(requestURL));\n        assertEquals(response.getStatusLine().getStatusCode(), 501);\n    }\n"]]}
{"hexsha": "89934386cfcaee1a5dac439ec3f086d90d6ed548", "ext": "java", "lang": "Java", "content": "public class SingletonInstanceServerSocket extends SingletonInstance {\n\n    private static int serverInstanceCount = 0;\n    private final Server singletonServer;\n    private final String fullName;\n\n    public SingletonInstanceServerSocket(final long poll_ms, final int portNumber) {\n        super(poll_ms);\n\n        // Gather the local InetAddress, loopback is prioritized\n        InetAddress ilh = null;\n        try {\n            ilh = InetAddress.getByName(null); // loopback\n        } catch (final UnknownHostException e1) { }\n        if(null == ilh) {\n            try {\n                ilh = InetAddress.getByName(\"localhost\");\n                if(null!=ilh && !ilh.isLoopbackAddress()) { ilh = null; }\n            } catch (final UnknownHostException e1) { }\n        }\n        if(null == ilh) {\n            try {\n                ilh = InetAddress.getByAddress(new byte[] { 127, 0, 0, 1 } );\n                if(null!=ilh && !ilh.isLoopbackAddress()) { ilh = null; }\n            } catch (final UnknownHostException e) { }\n        }\n        if(null == ilh) {\n            try {\n                ilh = InetAddress.getLocalHost();\n            } catch (final UnknownHostException e) { }\n        }\n        if(null == ilh) {\n            throw new RuntimeException(infoPrefix()+\" EEE Could not determine local InetAddress\");\n        }\n\n        fullName = ilh.toString()+\":\"+portNumber;\n        singletonServer = new Server(ilh, portNumber);\n        Runtime.getRuntime().addShutdownHook(new InterruptSource.Thread() {\n            @Override\n            public void run() {\n                singletonServer.kill();\n            }\n        });\n    }\n\n    public final InetAddress getLocalInetAddress() {\n        return singletonServer.getLocalInetAddress();\n    }\n\n    public final int getPortNumber() {\n        return singletonServer.getPortNumber();\n    }\n\n    @Override\n    public final String getName() { return fullName; }\n\n    @Override\n    protected boolean tryLockImpl() {\n        if( singletonServer.isRunning() ) {\n            return false; // same JVM .. server socket already installed !\n        }\n\n        // check if other JVM's locked the server socket ..\n        final Socket clientSocket = singletonServer.connect();\n        if(null != clientSocket) {\n            try {\n                clientSocket.close();\n            } catch (final IOException e) { }\n            return false;\n        }\n\n        if( !singletonServer.start() ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    @Override\n    protected boolean unlockImpl() {\n        return singletonServer.shutdown();\n    }\n\n    public class Server implements Runnable {\n       private final InetAddress localInetAddress;\n       private final int portNumber;\n\n       private volatile boolean shallQuit = false;\n       private volatile boolean alive = false;\n\n       private final Object syncOnStartStop = new Object();\n       private ServerSocket serverSocket = null;\n       private Thread serverThread = null;  // allowing kill() to force-stop last server-thread\n\n       public Server(final InetAddress localInetAddress, final int portNumber) {\n           this.localInetAddress = localInetAddress;\n           this.portNumber = portNumber;\n       }\n\n       public final InetAddress getLocalInetAddress() { return localInetAddress; }\n       public final int getPortNumber() { return portNumber; }\n\n       public final boolean start() {\n           if(alive) return true;\n\n           final String sname;\n           synchronized (Server.class) {\n               serverInstanceCount++;\n               sname = \"SingletonServerSocket\"+serverInstanceCount+\"-\"+fullName;\n           }\n           synchronized (syncOnStartStop) {\n               shallQuit = false;\n               serverThread = new InterruptSource.Thread(null, this, sname);\n               serverThread.setDaemon(true);  // be a daemon, don't keep the JVM running\n               serverThread.start();\n               try {\n                   while( !alive && !shallQuit ) {\n                       syncOnStartStop.wait();\n                   }\n               } catch (final InterruptedException ie) {\n                   final InterruptedException ie2 = SourcedInterruptedException.wrap(ie);\n                   shutdown(false);\n                   throw new InterruptedRuntimeException(ie2);\n               }\n           }\n           final boolean ok = isBound();\n           if(!ok) {\n               shutdown(true);\n           }\n           return ok;\n       }\n\n       public final boolean shutdown() {\n           return shutdown(true);\n       }\n       private final boolean shutdown(final boolean wait) {\n           if(!alive) return true;\n\n           try {\n               synchronized (syncOnStartStop) {\n                   shallQuit = true;\n                   connect();\n                   if( wait ) {\n                       try {\n                           while( alive ) {\n                               syncOnStartStop.wait();\n                           }\n                       } catch (final InterruptedException ie) {\n                           throw new InterruptedRuntimeException(ie);\n                       }\n                   }\n               }\n           } finally {\n               if(alive) {\n                   System.err.println(infoPrefix()+\" EEE \"+getName()+\" - Unable to remove lock: ServerThread still alive ?\");\n                   kill();\n               }\n           }\n           return true;\n       }\n\n       /**\n        * Brutally kill server thread and close socket regardless.\n        * This is out last chance for JVM shutdown.\n        */\n       @SuppressWarnings(\"deprecation\")\n       public final void kill() {\n           if(alive) {\n                System.err.println(infoPrefix()+\" XXX \"+getName()+\" - Kill @ JVM Shutdown\");\n           }\n           alive = false;\n           shallQuit = false;\n           if(null != serverThread && serverThread.isAlive() ) {\n               try {\n                   serverThread.stop();\n               } catch(final Throwable t) { }\n           }\n           if(null != serverSocket) {\n               try {\n                   final ServerSocket ss = serverSocket;\n                   serverSocket = null;\n                   ss.close();\n               } catch (final Throwable t) { }\n           }\n       }\n\n       public final boolean isRunning() { return alive; }\n\n       public final boolean isBound() {\n           return alive && null != serverSocket && serverSocket.isBound() ;\n       }\n\n       public final Socket connect() {\n           try {\n               return new Socket(localInetAddress, portNumber);\n           } catch (final Exception e) { }\n           return null;\n       }\n\n       @Override\n       public void run() {\n           if(DEBUG) {\n               System.err.println(infoPrefix()+\" III - Start\");\n           }\n           try {\n               synchronized (syncOnStartStop) {\n                   try {\n                       serverSocket = new ServerSocket(portNumber, 1, localInetAddress);\n                       serverSocket.setReuseAddress(true); // reuse same port w/ subsequent instance, i.e. overcome TO state when JVM crashed\n                       alive = true;\n                   } catch (final IOException e) {\n                       System.err.println(infoPrefix()+\" III - Unable to install ServerSocket: \"+e.getMessage());\n                       shallQuit = true;\n                   } finally {\n                       syncOnStartStop.notifyAll();\n                   }\n               }\n\n               while (!shallQuit) {\n                   try {\n                       final Socket clientSocket = serverSocket.accept();\n                       clientSocket.close();\n                   } catch (final IOException ioe) {\n                       System.err.println(infoPrefix()+\" EEE - Exception during accept: \" + ioe.getMessage());\n                   }\n               }\n           } catch(final ThreadDeath td) {\n               if( DEBUG ) {\n                   ExceptionUtils.dumpThrowable(\"\", td);\n               }\n           } finally {\n               synchronized (syncOnStartStop) {\n                   if(DEBUG) {\n                       System.err.println(infoPrefix()+\" III - Stopping: alive \"+alive+\", shallQuit \"+shallQuit+\", hasSocket \"+(null!=serverSocket));\n                   }\n                   if(null != serverSocket) {\n                       try {\n                           serverSocket.close();\n                       } catch (final IOException e) {\n                           System.err.println(infoPrefix()+\" EEE - Exception during close: \" + e.getMessage());\n                       }\n                   }\n                   serverSocket = null;\n                   alive = false;\n                   syncOnStartStop.notifyAll();\n               }\n           }\n       }\n    }\n}", "class_id": 0, "repo": "sgothel/jaulib", "file": "test/java/jau/test/util/parallel/locks/impl/SingletonInstanceServerSocket.java", "last_update_at": "2020-12-02T18:14:10+00:00", "question_id": "89934386cfcaee1a5dac439ec3f086d90d6ed548", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SingletonInstanceServerSocket extends SingletonInstance {\n    private static int serverInstanceCount = 0;\n    private final Server singletonServer;\n    private final String fullName;\n    public SingletonInstanceServerSocket(final long poll_ms, final int portNumber) {\n        super(poll_ms);\n        // Gather the local InetAddress, loopback is prioritized\n        InetAddress ilh = null;\n        try {\n            ilh = InetAddress.getByName(null); // loopback\n        } catch (final UnknownHostException e1) { }\n        if(null == ilh) {\n            try {\n                ilh = InetAddress.getByName(\"localhost\");\n                if(null!=ilh && !ilh.isLoopbackAddress()) { ilh = null; }\n            } catch (final UnknownHostException e1) { }\n        }\n        if(null == ilh) {\n            try {\n                ilh = InetAddress.getByAddress(new byte[] { 127, 0, 0, 1 } );\n                if(null!=ilh && !ilh.isLoopbackAddress()) { ilh = null; }\n            } catch (final UnknownHostException e) { }\n        }\n        if(null == ilh) {\n            try {\n                ilh = InetAddress.getLocalHost();\n            } catch (final UnknownHostException e) { }\n        }\n        if(null == ilh) {\n            throw new RuntimeException(infoPrefix()+\" EEE Could not determine local InetAddress\");\n        }\n        fullName = ilh.toString()+\":\"+portNumber;\n        singletonServer = new Server(ilh, portNumber);\n        Runtime.getRuntime().addShutdownHook(new InterruptSource.Thread() {\n            @Override\n            public void run() {\n                singletonServer.kill();\n            }\n        });\n    }\n    public final InetAddress getLocalInetAddress() {\n        return singletonServer.getLocalInetAddress();\n    }\n    public final int getPortNumber() {\n        return singletonServer.getPortNumber();\n    }\n    @Override\n    public final String getName() { return fullName; }\n    @Override\n    protected boolean tryLockImpl() {\n        if( singletonServer.isRunning() ) {\n            return false; // same JVM .. server socket already installed !\n        }\n        // check if other JVM's locked the server socket ..\n        final Socket clientSocket = singletonServer.connect();\n        if(null != clientSocket) {\n            try {\n                clientSocket.close();\n            } catch (final IOException e) { }\n            return false;\n        }\n        if( !singletonServer.start() ) {\n            return false;\n        }\n        return true;\n    }\n    @Override\n    protected boolean unlockImpl() {\n        return singletonServer.shutdown();\n    }\n    public class Server implements Runnable {\n       private final InetAddress localInetAddress;\n       private final int portNumber;\n       private volatile boolean shallQuit = false;\n       private volatile boolean alive = false;\n       private final Object syncOnStartStop = new Object();\n       private ServerSocket serverSocket = null;\n       private Thread serverThread = null;  // allowing kill() to force-stop last server-thread\n       public Server(final InetAddress localInetAddress, final int portNumber) {\n           this.localInetAddress = localInetAddress;\n           this.portNumber = portNumber;\n       }\n       public final InetAddress getLocalInetAddress() { return localInetAddress; }\n       public final int getPortNumber() { return portNumber; }\n       public final boolean start() {\n           if(alive) return true;\n           final String sname;\n           synchronized (Server.class) {\n               serverInstanceCount++;\n               sname = \"SingletonServerSocket\"+serverInstanceCount+\"-\"+fullName;\n           }\n           synchronized (syncOnStartStop) {\n               shallQuit = false;\n               serverThread = new InterruptSource.Thread(null, this, sname);\n               serverThread.setDaemon(true);  // be a daemon, don't keep the JVM running\n               serverThread.start();\n               try {\n                   while( !alive && !shallQuit ) {\n                       syncOnStartStop.wait();\n                   }\n               } catch (final InterruptedException ie) {\n                   final InterruptedException ie2 = SourcedInterruptedException.wrap(ie);\n                   shutdown(false);\n                   throw new InterruptedRuntimeException(ie2);\n               }\n           }\n           final boolean ok = isBound();\n           if(!ok) {\n               shutdown(true);\n           }\n           return ok;\n       }\n       public final boolean shutdown() {\n           return shutdown(true);\n       }\n       private final boolean shutdown(final boolean wait) {\n           if(!alive) return true;\n           try {\n               synchronized (syncOnStartStop) {\n                   shallQuit = true;\n                   connect();\n                   if( wait ) {\n                       try {\n                           while( alive ) {\n                               syncOnStartStop.wait();\n                           }\n                       } catch (final InterruptedException ie) {\n                           throw new InterruptedRuntimeException(ie);\n                       }\n                   }\n               }\n           } finally {\n               if(alive) {\n                   System.err.println(infoPrefix()+\" EEE \"+getName()+\" - Unable to remove lock: ServerThread still alive ?\");\n                   kill();\n               }\n           }\n           return true;\n       }\n       /**\n        * Brutally kill server thread and close socket regardless.\n        * This is out last chance for JVM shutdown.\n        */\n       @SuppressWarnings(\"deprecation\")\n       public final void kill() {\n           if(alive) {\n                System.err.println(infoPrefix()+\" XXX \"+getName()+\" - Kill @ JVM Shutdown\");\n           }\n           alive = false;\n           shallQuit = false;\n           if(null != serverThread && serverThread.isAlive() ) {\n               try {\n                   serverThread.stop();\n               } catch(final Throwable t) { }\n           }\n           if(null != serverSocket) {\n               try {\n                   final ServerSocket ss = serverSocket;\n                   serverSocket = null;\n                   ss.close();\n               } catch (final Throwable t) { }\n           }\n       }\n       public final boolean isRunning() { return alive; }\n       public final boolean isBound() {\n           return alive && null != serverSocket && serverSocket.isBound() ;\n       }\n       public final Socket connect() {\n           try {\n               return new Socket(localInetAddress, portNumber);\n           } catch (final Exception e) { }\n           return null;\n       }\n       @Override\n       public void run() {\n           if(DEBUG) {\n               System.err.println(infoPrefix()+\" III - Start\");\n           }\n           try {\n               synchronized (syncOnStartStop) {\n                   try {\n                       serverSocket = new ServerSocket(portNumber, 1, localInetAddress);\n                       serverSocket.setReuseAddress(true); // reuse same port w/ subsequent instance, i.e. overcome TO state when JVM crashed\n                       alive = true;\n                   } catch (final IOException e) {\n                       System.err.println(infoPrefix()+\" III - Unable to install ServerSocket: \"+e.getMessage());\n                       shallQuit = true;\n                   } finally {\n                       syncOnStartStop.notifyAll();\n                   }\n               }\n               while (!shallQuit) {\n                   try {\n                       final Socket clientSocket = serverSocket.accept();\n                       clientSocket.close();\n                   } catch (final IOException ioe) {\n                       System.err.println(infoPrefix()+\" EEE - Exception during accept: \" + ioe.getMessage());\n                   }\n               }\n           } catch(final ThreadDeath td) {\n               if( DEBUG ) {\n                   ExceptionUtils.dumpThrowable(\"\", td);\n               }\n           } finally {\n               synchronized (syncOnStartStop) {\n                   if(DEBUG) {\n                       System.err.println(infoPrefix()+\" III - Stopping: alive \"+alive+\", shallQuit \"+shallQuit+\", hasSocket \"+(null!=serverSocket));\n                   }\n                   if(null != serverSocket) {\n                       try {\n                           serverSocket.close();\n                       } catch (final IOException e) {\n                           System.err.println(infoPrefix()+\" EEE - Exception during close: \" + e.getMessage());\n                       }\n                   }\n                   serverSocket = null;\n                   alive = false;\n                   syncOnStartStop.notifyAll();\n               }\n           }\n       }\n    }\n"]]}
{"hexsha": "5d823e0dc1a0d5be1d5e8e16b8f449191a205c3e", "ext": "java", "lang": "Java", "content": "public class XGBoostJavaVariableImportance implements XGBoostVariableImportance {\n    \n    private final String[] _featureNames;\n    \n    public XGBoostJavaVariableImportance(XGBoostModelInfo modelInfo) {\n        _featureNames = XGBoostUtils.assembleFeatureNames(modelInfo.dataInfo())._names;\n    }\n\n    @Override\n    public Map<String, FeatureScore> getFeatureScores(byte[] boosterBytes) {\n        Predictor predictor = PredictorFactory.makePredictor(boosterBytes, false);\n        Map<String, FeatureScore> featureScore = new HashMap<>();\n        if (!(predictor.getBooster() instanceof GBTree)) {\n            return featureScore;\n        }\n        GBTree gbm = (GBTree) predictor.getBooster();\n        final RegTree[][] trees = gbm.getGroupedTrees();\n        for (final RegTree[] treeGroup : trees) {\n            for (int j = 0; j < treeGroup.length; j++) {\n                RegTree t = treeGroup[j];\n                for (int k = 0; k < t.getNodes().length; k++) {\n                    RegTreeNode node = t.getNodes()[k];\n                    if (node.isLeaf()) continue;\n                    RegTreeNodeStat stat = t.getStats()[k];\n                    FeatureScore fs = new FeatureScore();\n                    fs._gain = stat.getGain();\n                    fs._cover = stat.getCover();\n                    final String fid = _featureNames[node.getSplitIndex()];\n                    if (featureScore.containsKey(fid)) {\n                        featureScore.get(fid).add(fs);\n                    } else {\n                        featureScore.put(fid, fs);\n                    }\n                }\n            }\n        }\n        return featureScore;\n    }\n\n}", "class_id": 0, "repo": "kernelrich/h2o-3", "file": "h2o-extensions/xgboost/src/main/java/hex/tree/xgboost/predict/XGBoostJavaVariableImportance.java", "last_update_at": "2020-09-23T19:26:30+00:00", "question_id": "5d823e0dc1a0d5be1d5e8e16b8f449191a205c3e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class XGBoostJavaVariableImportance implements XGBoostVariableImportance {\n    private final String[] _featureNames;\n    public XGBoostJavaVariableImportance(XGBoostModelInfo modelInfo) {\n        _featureNames = XGBoostUtils.assembleFeatureNames(modelInfo.dataInfo())._names;\n    }\n    @Override\n    public Map<String, FeatureScore> getFeatureScores(byte[] boosterBytes) {\n        Predictor predictor = PredictorFactory.makePredictor(boosterBytes, false);\n        Map<String, FeatureScore> featureScore = new HashMap<>();\n        if (!(predictor.getBooster() instanceof GBTree)) {\n            return featureScore;\n        }\n        GBTree gbm = (GBTree) predictor.getBooster();\n        final RegTree[][] trees = gbm.getGroupedTrees();\n        for (final RegTree[] treeGroup : trees) {\n            for (int j = 0; j < treeGroup.length; j++) {\n                RegTree t = treeGroup[j];\n                for (int k = 0; k < t.getNodes().length; k++) {\n                    RegTreeNode node = t.getNodes()[k];\n                    if (node.isLeaf()) continue;\n                    RegTreeNodeStat stat = t.getStats()[k];\n                    FeatureScore fs = new FeatureScore();\n                    fs._gain = stat.getGain();\n                    fs._cover = stat.getCover();\n                    final String fid = _featureNames[node.getSplitIndex()];\n                    if (featureScore.containsKey(fid)) {\n                        featureScore.get(fid).add(fs);\n                    } else {\n                        featureScore.put(fid, fs);\n                    }\n                }\n            }\n        }\n        return featureScore;\n    }\n"]]}
{"hexsha": "12b7df7d34834ca6490a0291db05919ed1c0c3b0", "ext": "java", "lang": "Java", "content": "public class StatelessNiFiSourceConnector extends SourceConnector {\n    static final String OUTPUT_PORT_NAME = \"output.port\";\n    static final String TOPIC_NAME = \"topics\";\n\n    static final String TOPIC_NAME_ATTRIBUTE = \"topic.name.attribute\";\n    static final String KEY_ATTRIBUTE = \"key.attribute\";\n    static final String HEADER_REGEX = \"header.attribute.regex\";\n\n    private Map<String, String> properties;\n    private boolean primaryNodeOnly;\n\n    @Override\n    public void start(final Map<String, String> properties) {\n        this.properties = new HashMap<>(properties);\n\n        final StatelessDataflow dataflow = StatelessKafkaConnectorUtil.createDataflow(properties);\n        primaryNodeOnly = dataflow.isSourcePrimaryNodeOnly();\n        dataflow.shutdown();\n    }\n\n    @Override\n    public Class<? extends Task> taskClass() {\n        return StatelessNiFiSourceTask.class;\n    }\n\n    @Override\n    public List<Map<String, String>> taskConfigs(final int maxTasks) {\n        final int numTasks = primaryNodeOnly ? 1 : maxTasks;\n\n        final List<Map<String, String>> configs = new ArrayList<>();\n        for (int i=0; i < numTasks; i++) {\n            final Map<String, String> taskConfig = new HashMap<>(properties);\n            taskConfig.put(\"task.index\", String.valueOf(i));\n            configs.add(taskConfig);\n        }\n\n        return configs;\n    }\n\n    @Override\n    public void stop() {\n\n    }\n\n    @Override\n    public ConfigDef config() {\n        final ConfigDef configDef = new ConfigDef();\n        StatelessKafkaConnectorUtil.addCommonConfigElements(configDef);\n\n        configDef.define(OUTPUT_PORT_NAME, ConfigDef.Type.STRING, null, ConfigDef.Importance.HIGH, \"The name of the Output Port to pull data from\");\n        configDef.define(TOPIC_NAME, ConfigDef.Type.STRING, null, ConfigDef.Importance.HIGH,\n            \"The name of the Kafka topic to send data to. Either the topics or topic.name.attribute configuration must be specified.\");\n\n        configDef.define(TOPIC_NAME_ATTRIBUTE, ConfigDef.Type.STRING, null, ConfigDef.Importance.MEDIUM,\n            \"Specifies the name of a FlowFile attribute to use for determining which Kafka Topic a FlowFile\"\n            + \" will be sent to. Either the topic.name or topic.name.attribute configuration must be specified. If both are specified, the topic.name.attribute will be preferred, but if a FlowFile\"\n            + \" does not have the specified attribute name, then the topic.name property will serve as the default topic name to use.\");\n\n        configDef.define(KEY_ATTRIBUTE, ConfigDef.Type.STRING, null, ConfigDef.Importance.MEDIUM, \"Specifies the name of a FlowFile attribute to use for determining the Kafka Message key. If not\"\n            + \" specified, the message key will be null. If specified, the value of the attribute with the given name will be used as the message key.\");\n\n        configDef.define(HEADER_REGEX, ConfigDef.Type.STRING, null, new ConnectRegularExpressionValidator(), ConfigDef.Importance.MEDIUM,\n            \"Specifies a Regular Expression to evaluate against all FlowFile attributes. Any attribute whose name\"\n            + \" matches the Regular Expression will be converted into a Kafka message header with the name of the attribute used as header key and the value of the attribute used as the header\"\n            + \" value.\");\n\n        return configDef;\n    }\n\n    @Override\n    public String version() {\n        return StatelessKafkaConnectorUtil.getVersion();\n    }\n}", "class_id": 0, "repo": "Shin-X/nifi", "file": "nifi-external/nifi-kafka-connect/nifi-kafka-connector/src/main/java/org/apache/nifi/kafka/connect/StatelessNiFiSourceConnector.java", "last_update_at": "2020-07-12T04:12:30+00:00", "question_id": "12b7df7d34834ca6490a0291db05919ed1c0c3b0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class StatelessNiFiSourceConnector extends SourceConnector {\n    static final String OUTPUT_PORT_NAME = \"output.port\";\n    static final String TOPIC_NAME = \"topics\";\n    static final String TOPIC_NAME_ATTRIBUTE = \"topic.name.attribute\";\n    static final String KEY_ATTRIBUTE = \"key.attribute\";\n    static final String HEADER_REGEX = \"header.attribute.regex\";\n    private Map<String, String> properties;\n    private boolean primaryNodeOnly;\n    @Override\n    public void start(final Map<String, String> properties) {\n        this.properties = new HashMap<>(properties);\n        final StatelessDataflow dataflow = StatelessKafkaConnectorUtil.createDataflow(properties);\n        primaryNodeOnly = dataflow.isSourcePrimaryNodeOnly();\n        dataflow.shutdown();\n    }\n    @Override\n    public Class<? extends Task> taskClass() {\n        return StatelessNiFiSourceTask.class;\n    }\n    @Override\n    public List<Map<String, String>> taskConfigs(final int maxTasks) {\n        final int numTasks = primaryNodeOnly ? 1 : maxTasks;\n        final List<Map<String, String>> configs = new ArrayList<>();\n        for (int i=0; i < numTasks; i++) {\n            final Map<String, String> taskConfig = new HashMap<>(properties);\n            taskConfig.put(\"task.index\", String.valueOf(i));\n            configs.add(taskConfig);\n        }\n        return configs;\n    }\n    @Override\n    public void stop() {\n    }\n    @Override\n    public ConfigDef config() {\n        final ConfigDef configDef = new ConfigDef();\n        StatelessKafkaConnectorUtil.addCommonConfigElements(configDef);\n        configDef.define(OUTPUT_PORT_NAME, ConfigDef.Type.STRING, null, ConfigDef.Importance.HIGH, \"The name of the Output Port to pull data from\");\n        configDef.define(TOPIC_NAME, ConfigDef.Type.STRING, null, ConfigDef.Importance.HIGH,\n            \"The name of the Kafka topic to send data to. Either the topics or topic.name.attribute configuration must be specified.\");\n        configDef.define(TOPIC_NAME_ATTRIBUTE, ConfigDef.Type.STRING, null, ConfigDef.Importance.MEDIUM,\n            \"Specifies the name of a FlowFile attribute to use for determining which Kafka Topic a FlowFile\"\n            + \" will be sent to. Either the topic.name or topic.name.attribute configuration must be specified. If both are specified, the topic.name.attribute will be preferred, but if a FlowFile\"\n            + \" does not have the specified attribute name, then the topic.name property will serve as the default topic name to use.\");\n        configDef.define(KEY_ATTRIBUTE, ConfigDef.Type.STRING, null, ConfigDef.Importance.MEDIUM, \"Specifies the name of a FlowFile attribute to use for determining the Kafka Message key. If not\"\n            + \" specified, the message key will be null. If specified, the value of the attribute with the given name will be used as the message key.\");\n        configDef.define(HEADER_REGEX, ConfigDef.Type.STRING, null, new ConnectRegularExpressionValidator(), ConfigDef.Importance.MEDIUM,\n            \"Specifies a Regular Expression to evaluate against all FlowFile attributes. Any attribute whose name\"\n            + \" matches the Regular Expression will be converted into a Kafka message header with the name of the attribute used as header key and the value of the attribute used as the header\"\n            + \" value.\");\n        return configDef;\n    }\n    @Override\n    public String version() {\n        return StatelessKafkaConnectorUtil.getVersion();\n    }\n"]]}
{"hexsha": "76cc88da55396369697c278c4afdddd7141ac044", "ext": "java", "lang": "Java", "content": "public class BlockWallSign extends BlockSign {\n\n\tpublic static final PropertyDirection FACING = PropertyDirection.create(\"facing\", EnumFacing.Plane.HORIZONTAL);\n\n\tpublic BlockWallSign() {\n\t\tthis.setDefaultState(this.blockState.getBaseState().withProperty(FACING, EnumFacing.NORTH));\n\t}\n\n\t@SuppressWarnings (\"incomplete-switch\")\n\tpublic void setBlockBoundsBasedOnState(IBlockAccess worldIn, BlockPos pos) {\n\t\tEnumFacing enumfacing = (EnumFacing) worldIn.getBlockState(pos).getValue(FACING);\n\t\tfloat f = 0.28125F;\n\t\tfloat f1 = 0.78125F;\n\t\tfloat f2 = 0.0F;\n\t\tfloat f3 = 1.0F;\n\t\tfloat f4 = 0.125F;\n\t\tthis.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);\n\n\t\tswitch (enumfacing) {\n\t\t\tcase NORTH:\n\t\t\t\tthis.setBlockBounds(f2, f, 1.0F - f4, f3, f1, 1.0F);\n\t\t\t\tbreak;\n\n\t\t\tcase SOUTH:\n\t\t\t\tthis.setBlockBounds(f2, f, 0.0F, f3, f1, f4);\n\t\t\t\tbreak;\n\n\t\t\tcase WEST:\n\t\t\t\tthis.setBlockBounds(1.0F - f4, f, f2, 1.0F, f1, f3);\n\t\t\t\tbreak;\n\n\t\t\tcase EAST:\n\t\t\t\tthis.setBlockBounds(0.0F, f, f2, f4, f1, f3);\n\t\t}\n\t}\n\n\t/**\n\t * Called when a neighboring block changes.\n\t */\n\tpublic void onNeighborBlockChange(World worldIn, BlockPos pos, IBlockState state, Block neighborBlock) {\n\t\tEnumFacing enumfacing = (EnumFacing) state.getValue(FACING);\n\n\t\tif (!worldIn.getBlockState(pos.offset(enumfacing.getOpposite())).getBlock().getMaterial().isSolid()) {\n\t\t\tthis.dropBlockAsItem(worldIn, pos, state, 0);\n\t\t\tworldIn.setBlockToAir(pos);\n\t\t}\n\n\t\tsuper.onNeighborBlockChange(worldIn, pos, state, neighborBlock);\n\t}\n\n\t/**\n\t * Convert the given metadata into a BlockState for this Block\n\t */\n\tpublic IBlockState getStateFromMeta(int meta) {\n\t\tEnumFacing enumfacing = EnumFacing.getFront(meta);\n\n\t\tif (enumfacing.getAxis() == EnumFacing.Axis.Y) {\n\t\t\tenumfacing = EnumFacing.NORTH;\n\t\t}\n\n\t\treturn this.getDefaultState().withProperty(FACING, enumfacing);\n\t}\n\n\t/**\n\t * Convert the BlockState into the correct metadata value\n\t */\n\tpublic int getMetaFromState(IBlockState state) {\n\t\treturn ((EnumFacing) state.getValue(FACING)).getIndex();\n\t}\n\n\tprotected BlockState createBlockState() {\n\t\treturn new BlockState(this, new IProperty[] {FACING});\n\t}\n\n}", "class_id": 0, "repo": "NotroDan/implario", "file": "core/src/net/minecraft/block/BlockWallSign.java", "last_update_at": "2020-07-30T17:49:46+00:00", "question_id": "76cc88da55396369697c278c4afdddd7141ac044", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BlockWallSign extends BlockSign {\n\tpublic static final PropertyDirection FACING = PropertyDirection.create(\"facing\", EnumFacing.Plane.HORIZONTAL);\n\tpublic BlockWallSign() {\n\t\tthis.setDefaultState(this.blockState.getBaseState().withProperty(FACING, EnumFacing.NORTH));\n\t}\n\t@SuppressWarnings (\"incomplete-switch\")\n\tpublic void setBlockBoundsBasedOnState(IBlockAccess worldIn, BlockPos pos) {\n\t\tEnumFacing enumfacing = (EnumFacing) worldIn.getBlockState(pos).getValue(FACING);\n\t\tfloat f = 0.28125F;\n\t\tfloat f1 = 0.78125F;\n\t\tfloat f2 = 0.0F;\n\t\tfloat f3 = 1.0F;\n\t\tfloat f4 = 0.125F;\n\t\tthis.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);\n\t\tswitch (enumfacing) {\n\t\t\tcase NORTH:\n\t\t\t\tthis.setBlockBounds(f2, f, 1.0F - f4, f3, f1, 1.0F);\n\t\t\t\tbreak;\n\t\t\tcase SOUTH:\n\t\t\t\tthis.setBlockBounds(f2, f, 0.0F, f3, f1, f4);\n\t\t\t\tbreak;\n\t\t\tcase WEST:\n\t\t\t\tthis.setBlockBounds(1.0F - f4, f, f2, 1.0F, f1, f3);\n\t\t\t\tbreak;\n\t\t\tcase EAST:\n\t\t\t\tthis.setBlockBounds(0.0F, f, f2, f4, f1, f3);\n\t\t}\n\t}\n\t/**\n\t * Called when a neighboring block changes.\n\t */\n\tpublic void onNeighborBlockChange(World worldIn, BlockPos pos, IBlockState state, Block neighborBlock) {\n\t\tEnumFacing enumfacing = (EnumFacing) state.getValue(FACING);\n\t\tif (!worldIn.getBlockState(pos.offset(enumfacing.getOpposite())).getBlock().getMaterial().isSolid()) {\n\t\t\tthis.dropBlockAsItem(worldIn, pos, state, 0);\n\t\t\tworldIn.setBlockToAir(pos);\n\t\t}\n\t\tsuper.onNeighborBlockChange(worldIn, pos, state, neighborBlock);\n\t}\n\t/**\n\t * Convert the given metadata into a BlockState for this Block\n\t */\n\tpublic IBlockState getStateFromMeta(int meta) {\n\t\tEnumFacing enumfacing = EnumFacing.getFront(meta);\n\t\tif (enumfacing.getAxis() == EnumFacing.Axis.Y) {\n\t\t\tenumfacing = EnumFacing.NORTH;\n\t\t}\n\t\treturn this.getDefaultState().withProperty(FACING, enumfacing);\n\t}\n\t/**\n\t * Convert the BlockState into the correct metadata value\n\t */\n\tpublic int getMetaFromState(IBlockState state) {\n\t\treturn ((EnumFacing) state.getValue(FACING)).getIndex();\n\t}\n\tprotected BlockState createBlockState() {\n\t\treturn new BlockState(this, new IProperty[] {FACING});\n\t}\n"]]}
{"hexsha": "59ec5aac2939187bfdce37408bda681df066ab53", "ext": "java", "lang": "Java", "content": "public class FeatureFactory<E extends Tag>\n{\n\n    public MultiMap<E, Marker> planSteps = new MultiMap();\n    public Map<Double, FactoryEvent> events = new LinkedHashMap();\n//    private MultiMap<Bar, Edge> planEdgeToBar;\n    public PlanSkeleton plan;\n    // map between forced-step-added-plan-edges and their features\n    public Map<Edge, Set<Tag>> newEdgeFeatures = new LinkedHashMap();\n\n    protected E feature;\n\n    public FeatureFactory(E feature)\n    {\n        this.feature = feature;\n    }\n\n    /**\n     * If using this function to announce the creation of new profiles edgeToBar should\n     * be updated in PlanSkeleton.\n     */\n    public void add( Collection<Profile> newProfiles, Iterable<Bar> planBars, double heightOffset )\n    {\n        for ( Bar b : planBars )\n            for ( Marker m : b.mould.markersOn( b ) )\n                if ( m.feature.getClass() == feature.getClass() )\n                    planSteps.put( (E) m.feature, m );\n\n        for ( Global global : plan.plan.globals )\n            for ( Profile profile : newProfiles ) // add each profile once\n            {\n                List<Loop<Bar>> chainStarts = profile.globalProfiles.get(global).chainStarts;\n                // here we only loop over profiles defined by a global. Other profiles (from forced steps) aren't processed.\n\n                for ( int valency = 0; valency < chainStarts.size(); valency++ )\n                    for ( Bar bar : chainStarts.get( valency ) )\n                        for ( Marker m : bar.mould.markersOn( bar ) )\n                            // if the profile marker has the correct class\n                            if ( feature.getClass().isInstance(m.feature) )//was class == class\n                            {\n                                double height = -m.y + heightOffset;\n                                FactoryEvent evt = events.get( height );\n                                if ( evt == null )\n                                {\n                                    evt = createFactoryEvent( height, global, chainStarts.size() == 1 ? 0 : valency ); // was 1-valency...\n                                    events.put( height, evt );\n                                }\n\n                                // for plan markers with the same feature\n                                for ( Marker planMarker : planSteps.get( (E) m.feature ) )\n                                    // if the plan marker is on a bar with the correct profile\n                                    if ( plan.plan.profiles.get( planMarker.bar ) == profile )\n                                        // schedule an plan marker at this height, along with the profile feature\n                                        evt.changesToMake.add( new Anchor( (E) m.feature, planMarker ) );\n                            }\n            }\n    }\n\n    public void add( PlanSkeleton plan )\n    {\n        this.plan = plan;\n        add( new LinkedHashSet<Profile>( plan.plan.profiles.values() ), plan.plan.points.eIterator(), 0 ); // add each profile once\n    }\n\n    public FactoryEvent createFactoryEvent( double height, Global g, int valency )\n    {\n        return new FactoryEvent( height, g, valency );\n    }\n\n    /**\n     * An anchor that hasn't yet been resolved to\n     */\n    public class Anchor\n    {\n        public E profileFeature;\n        public Marker planMarker;\n\n        private Anchor( E step, Marker planMarker )\n        {\n            this.profileFeature = step;\n            this.planMarker = planMarker;\n        }\n    }\n\n    public void addToSkeleton( Skeleton skel )\n    {\n        for (HeightEvent he : events.values())\n            skel.qu.add( he );\n\n        // we add more events mid-sequence, so best to keep this clear\n        events.clear();\n    }\n\n    /**\n     * a map from each plan marker, to the points it generated\n     * @param points\n     */\n    public void addPoints ( MultiMap<Marker, Matrix4d> points )\n    {\n        // override me!\n    }\n\n    public class FactoryEvent implements HeightEvent\n    {\n        Global global;\n        int valency;\n        double height;\n        public Set<Anchor> changesToMake = new LinkedHashSet();\n        public Map<Loop<Bar>, Machine> profiles = new LinkedHashMap();\n\n        public FactoryEvent( double height, Global global, int valency )\n        {\n            this.height = height;\n            this.global = global;\n            this.valency = valency;\n        }\n\n        public double getHeight()\n        {\n            return height;\n        }\n\n        public boolean process( Skeleton skel_ )\n        {\n            PlanSkeleton skel = (PlanSkeleton)skel_;\n//            List<Matrix4d> pts = new ArrayList();\n            MultiMap<Marker, Matrix4d> pts = new MultiMap();\n\n            for ( Anchor anchor : changesToMake )\n            {\n                \n                final Marker planM = anchor.planMarker;\n\n                Set<Corner> edges = plan.findLiveEdgesFrom( planM.bar );\n\n                // the plan is valid for these corners, but is the edge's profile valid?\n                Iterator<Corner> eit = edges.iterator();\n                while ( eit.hasNext() )\n                {\n                    Corner c = eit.next();\n                    if ( skel.getGlobalForEdge( c.nextL ) != global )\n                    {\n                        eit.remove();\n                        continue;\n                    }\n                    if ( skel.getValencyForEdge( c.nextL ) != valency )\n                        eit.remove();\n                }\n\n                LinearForm3D ceiling = new LinearForm3D( 0, 0, 1, -height );\n\n                edges:\n                for ( Corner c : edges )\n                {\n                    Tuple3d start = c.nextL.linearForm.collide( c.prevL.linearForm, ceiling);\n                    Tuple3d end = c.nextL.linearForm.collide( c.nextC.nextL.linearForm, ceiling);\n\n                    // translation component of the\n                    Vector3d tran = null;\n                    switch ( (Marker.Type) planM.properties.get( Marker.TYPE ) )\n                    {\n                        case AbsEnd:\n                        case AbsStart:\n                            // do a straight projection (this isn't rotated to the current frame of the bar - eg: won't work with nested features)\n                            Vector3d delta = new Vector3d(end); delta.sub(start);\n                            Ray3d atSPlane = new Ray3d( start, delta );\n                            Point3d res = atSPlane.projectSegment( new Point3d (planM.x, planM.y, 0 ) );\n                            tran = res == null ? null : new Vector3d ( res );\n                            break;\n                        case Rel:\n                            // relative to line length\n                            Line reference = new Line( planM.bar.start, planM.bar.end );\n                            double p = reference.findPPram( planM );\n                            tran = new Vector3d (end);\n                            tran.sub( start );\n                            tran.scale( p );\n                            tran.add( start ); // dir is now the translation component\n                            break;\n                    }\n\n                    // point didn't project onto polygon at current height, move onto nextl\n                    if (tran == null)\n                        continue edges;\n\n                    // we only compensate for rotation around the vertical line :(\n                    Matrix3d orientation = new Matrix3d();\n                    Vector3d eDir = c.nextL.direction();\n                    eDir.normalize();\n\n                    // fixme: rotation conversion to jme space occurs here. it shouldn't. hack!\n                    AxisAngle4d aa = new AxisAngle4d( new Vector3d (0,1,0), -Math.atan2( eDir.y, eDir.x) );\n                    orientation.set( aa );\n                    pts.put( planM, new Matrix4d(orientation, tran, 1) );\n                }\n            }\n\n            FeatureFactory.this.addPoints( pts );\n\n           \n            return false; // not doing anything :)\n        }\n    }\n}", "class_id": 0, "repo": "Gustl22/siteplan", "file": "src/org/twak/siteplan/campskeleton/FeatureFactory.java", "last_update_at": "2020-11-09T08:03:36+00:00", "question_id": "59ec5aac2939187bfdce37408bda681df066ab53", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FeatureFactory<E extends Tag>\n{\n    public MultiMap<E, Marker> planSteps = new MultiMap();\n    public Map<Double, FactoryEvent> events = new LinkedHashMap();\n//    private MultiMap<Bar, Edge> planEdgeToBar;\n    public PlanSkeleton plan;\n    // map between forced-step-added-plan-edges and their features\n    public Map<Edge, Set<Tag>> newEdgeFeatures = new LinkedHashMap();\n    protected E feature;\n    public FeatureFactory(E feature)\n    {\n        this.feature = feature;\n    }\n    /**\n     * If using this function to announce the creation of new profiles edgeToBar should\n     * be updated in PlanSkeleton.\n     */\n    public void add( Collection<Profile> newProfiles, Iterable<Bar> planBars, double heightOffset )\n    {\n        for ( Bar b : planBars )\n            for ( Marker m : b.mould.markersOn( b ) )\n                if ( m.feature.getClass() == feature.getClass() )\n                    planSteps.put( (E) m.feature, m );\n        for ( Global global : plan.plan.globals )\n            for ( Profile profile : newProfiles ) // add each profile once\n            {\n                List<Loop<Bar>> chainStarts = profile.globalProfiles.get(global).chainStarts;\n                // here we only loop over profiles defined by a global. Other profiles (from forced steps) aren't processed.\n                for ( int valency = 0; valency < chainStarts.size(); valency++ )\n                    for ( Bar bar : chainStarts.get( valency ) )\n                        for ( Marker m : bar.mould.markersOn( bar ) )\n                            // if the profile marker has the correct class\n                            if ( feature.getClass().isInstance(m.feature) )//was class == class\n                            {\n                                double height = -m.y + heightOffset;\n                                FactoryEvent evt = events.get( height );\n                                if ( evt == null )\n                                {\n                                    evt = createFactoryEvent( height, global, chainStarts.size() == 1 ? 0 : valency ); // was 1-valency...\n                                    events.put( height, evt );\n                                }\n                                // for plan markers with the same feature\n                                for ( Marker planMarker : planSteps.get( (E) m.feature ) )\n                                    // if the plan marker is on a bar with the correct profile\n                                    if ( plan.plan.profiles.get( planMarker.bar ) == profile )\n                                        // schedule an plan marker at this height, along with the profile feature\n                                        evt.changesToMake.add( new Anchor( (E) m.feature, planMarker ) );\n                            }\n            }\n    }\n    public void add( PlanSkeleton plan )\n    {\n        this.plan = plan;\n        add( new LinkedHashSet<Profile>( plan.plan.profiles.values() ), plan.plan.points.eIterator(), 0 ); // add each profile once\n    }\n    public FactoryEvent createFactoryEvent( double height, Global g, int valency )\n    {\n        return new FactoryEvent( height, g, valency );\n    }\n    /**\n     * An anchor that hasn't yet been resolved to\n     */\n    public class Anchor\n    {\n        public E profileFeature;\n        public Marker planMarker;\n        private Anchor( E step, Marker planMarker )\n        {\n            this.profileFeature = step;\n            this.planMarker = planMarker;\n        }\n    }\n    public void addToSkeleton( Skeleton skel )\n    {\n        for (HeightEvent he : events.values())\n            skel.qu.add( he );\n        // we add more events mid-sequence, so best to keep this clear\n        events.clear();\n    }\n    /**\n     * a map from each plan marker, to the points it generated\n     * @param points\n     */\n    public void addPoints ( MultiMap<Marker, Matrix4d> points )\n    {\n        // override me!\n    }\n    public class FactoryEvent implements HeightEvent\n    {\n        Global global;\n        int valency;\n        double height;\n        public Set<Anchor> changesToMake = new LinkedHashSet();\n        public Map<Loop<Bar>, Machine> profiles = new LinkedHashMap();\n        public FactoryEvent( double height, Global global, int valency )\n        {\n            this.height = height;\n            this.global = global;\n            this.valency = valency;\n        }\n        public double getHeight()\n        {\n            return height;\n        }\n        public boolean process( Skeleton skel_ )\n        {\n            PlanSkeleton skel = (PlanSkeleton)skel_;\n//            List<Matrix4d> pts = new ArrayList();\n            MultiMap<Marker, Matrix4d> pts = new MultiMap();\n            for ( Anchor anchor : changesToMake )\n            {\n                final Marker planM = anchor.planMarker;\n                Set<Corner> edges = plan.findLiveEdgesFrom( planM.bar );\n                // the plan is valid for these corners, but is the edge's profile valid?\n                Iterator<Corner> eit = edges.iterator();\n                while ( eit.hasNext() )\n                {\n                    Corner c = eit.next();\n                    if ( skel.getGlobalForEdge( c.nextL ) != global )\n                    {\n                        eit.remove();\n                        continue;\n                    }\n                    if ( skel.getValencyForEdge( c.nextL ) != valency )\n                        eit.remove();\n                }\n                LinearForm3D ceiling = new LinearForm3D( 0, 0, 1, -height );\n                edges:\n                for ( Corner c : edges )\n                {\n                    Tuple3d start = c.nextL.linearForm.collide( c.prevL.linearForm, ceiling);\n                    Tuple3d end = c.nextL.linearForm.collide( c.nextC.nextL.linearForm, ceiling);\n                    // translation component of the\n                    Vector3d tran = null;\n                    switch ( (Marker.Type) planM.properties.get( Marker.TYPE ) )\n                    {\n                        case AbsEnd:\n                        case AbsStart:\n                            // do a straight projection (this isn't rotated to the current frame of the bar - eg: won't work with nested features)\n                            Vector3d delta = new Vector3d(end); delta.sub(start);\n                            Ray3d atSPlane = new Ray3d( start, delta );\n                            Point3d res = atSPlane.projectSegment( new Point3d (planM.x, planM.y, 0 ) );\n                            tran = res == null ? null : new Vector3d ( res );\n                            break;\n                        case Rel:\n                            // relative to line length\n                            Line reference = new Line( planM.bar.start, planM.bar.end );\n                            double p = reference.findPPram( planM );\n                            tran = new Vector3d (end);\n                            tran.sub( start );\n                            tran.scale( p );\n                            tran.add( start ); // dir is now the translation component\n                            break;\n                    }\n                    // point didn't project onto polygon at current height, move onto nextl\n                    if (tran == null)\n                        continue edges;\n                    // we only compensate for rotation around the vertical line :(\n                    Matrix3d orientation = new Matrix3d();\n                    Vector3d eDir = c.nextL.direction();\n                    eDir.normalize();\n                    // fixme: rotation conversion to jme space occurs here. it shouldn't. hack!\n                    AxisAngle4d aa = new AxisAngle4d( new Vector3d (0,1,0), -Math.atan2( eDir.y, eDir.x) );\n                    orientation.set( aa );\n                    pts.put( planM, new Matrix4d(orientation, tran, 1) );\n                }\n            }\n            FeatureFactory.this.addPoints( pts );\n            return false; // not doing anything :)\n        }\n    }\n"]]}
{"hexsha": "2d11fce266e2875c55bdd4c93208ce4a8221c3d9", "ext": "java", "lang": "Java", "content": "public class WithinFunctionTest extends AbstractScalarFunctionsTest {\n\n    private static final String FNAME = WithinFunction.NAME;\n\n    @Test\n    public void testEvaluateWithNullArgs() throws Exception {\n        assertEvaluate(\"within(geopoint, geoshape)\", null, Literal.newGeoPoint(null), Literal.newGeoShape(\"POINT (10 10)\"));\n        assertEvaluate(\"within(geopoint, geoshape)\", null, Literal.newGeoPoint(\"POINT (10 10)\"), Literal.newGeoShape(null));\n    }\n\n    @Test\n    public void testEvaluatePointLiteralWithinPolygonLiteral() {\n        assertEvaluate(\"within(geopoint, geoshape)\", true,\n            Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value(\"POINT (10 10)\")),\n            Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value(\"POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))\"))\n        );\n    }\n\n    @Test\n    public void testEvaluateShapeWithinShape() {\n        assertEvaluate(\"within(geoshape, geoshape)\", true,\n            Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value(\"LINESTRING (8 15, 13 24)\")),\n            Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value(\"POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))\"))\n        );\n    }\n\n    @Test\n    public void testEvaluateShapeIsNotWithinShape() {\n        assertEvaluate(\"within(geoshape, geoshape)\", false,\n            Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value(\"LINESTRING (8 15, 40 74)\")),\n            Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value(\"POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))\"))\n        );\n    }\n\n    @Test\n    public void testEvaluateObjectWithinShape() {\n        assertEvaluate(\"within(geopoint, geoshape)\", true,\n            Literal.of(ImmutableMap.<String, Object>of(\"type\", \"Point\", \"coordinates\", new double[]{10.0, 10.0})),\n            Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value(\"POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))\"))\n        );\n    }\n\n    @Test\n    public void testNormalizeWithReferenceAndLiteral() throws Exception {\n        Symbol normalizedSymbol = normalize(FNAME, createReference(\"foo\", DataTypes.GEO_POINT),\n            Literal.newGeoShape(\"POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))\"));\n        assertThat(normalizedSymbol, isFunction(FNAME));\n    }\n\n    @Test\n    public void testNormalizeWithTwoStringLiterals() throws Exception {\n        assertNormalize(\"within('POINT (10 10)', 'POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))')\", isLiteral(true));\n    }\n\n    @Test\n    public void testNormalizeWithStringLiteralAndReference() throws Exception {\n        Symbol normalized = normalize(FNAME,\n            createReference(\"point\", DataTypes.GEO_POINT),\n            Literal.of(\"POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))\"));\n        assertThat(normalized, instanceOf(Function.class));\n        Function function = (Function) normalized;\n        Symbol symbol = function.arguments().get(1);\n        assertThat(symbol.valueType(), equalTo(DataTypes.GEO_SHAPE));\n    }\n\n    @Test\n    public void testNormalizeWithFirstArgAsStringReference() throws Exception {\n        Symbol normalized = normalize(FNAME,\n            createReference(\"location\", DataTypes.STRING),\n            Literal.newGeoShape(\"POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))\"));\n        assertThat(normalized.symbolType(), is(SymbolType.FUNCTION));\n    }\n\n    @Test\n    public void testNormalizeWithSecondArgAsStringReference() throws Exception {\n        Symbol normalized = normalize(FNAME,\n            Literal.newGeoPoint(new Double[]{0.0d, 0.0d}),\n            createReference(\"location\", DataTypes.STRING));\n        assertThat(normalized.symbolType(), is(SymbolType.FUNCTION));\n        assertThat(((Function) normalized).info().ident().name(), is(WithinFunction.NAME));\n    }\n\n    @Test\n    public void testFirstArgumentWithInvalidType() throws Exception {\n        expectedException.expect(ConversionException.class);\n        getFunction(FNAME, DataTypes.LONG, DataTypes.GEO_POINT);\n    }\n\n    @Test\n    public void testSecondArgumentWithInvalidType() throws Exception {\n        expectedException.expect(ConversionException.class);\n        getFunction(FNAME, DataTypes.GEO_POINT, DataTypes.LONG);\n    }\n\n    @Test\n    public void testNormalizeFromObject() throws Exception {\n        Symbol normalized = normalize(FNAME,\n            Literal.of(\"POINT (1.0 0.0)\"),\n            Literal.of(ImmutableMap.<String, Object>of(\"type\", \"Point\", \"coordinates\", new double[]{0.0, 1.0})));\n        assertThat(normalized.symbolType(), is(SymbolType.LITERAL));\n        assertThat(((Literal) normalized).value(), is(Boolean.FALSE));\n    }\n}", "class_id": 0, "repo": "yutiansut/crate", "file": "sql/src/test/java/io/crate/expression/scalar/geo/WithinFunctionTest.java", "last_update_at": "2020-02-03T11:59:41+00:00", "question_id": "2d11fce266e2875c55bdd4c93208ce4a8221c3d9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class WithinFunctionTest extends AbstractScalarFunctionsTest {\n    private static final String FNAME = WithinFunction.NAME;\n    @Test\n    public void testEvaluateWithNullArgs() throws Exception {\n        assertEvaluate(\"within(geopoint, geoshape)\", null, Literal.newGeoPoint(null), Literal.newGeoShape(\"POINT (10 10)\"));\n        assertEvaluate(\"within(geopoint, geoshape)\", null, Literal.newGeoPoint(\"POINT (10 10)\"), Literal.newGeoShape(null));\n    }\n    @Test\n    public void testEvaluatePointLiteralWithinPolygonLiteral() {\n        assertEvaluate(\"within(geopoint, geoshape)\", true,\n            Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value(\"POINT (10 10)\")),\n            Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value(\"POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))\"))\n        );\n    }\n    @Test\n    public void testEvaluateShapeWithinShape() {\n        assertEvaluate(\"within(geoshape, geoshape)\", true,\n            Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value(\"LINESTRING (8 15, 13 24)\")),\n            Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value(\"POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))\"))\n        );\n    }\n    @Test\n    public void testEvaluateShapeIsNotWithinShape() {\n        assertEvaluate(\"within(geoshape, geoshape)\", false,\n            Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value(\"LINESTRING (8 15, 40 74)\")),\n            Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value(\"POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))\"))\n        );\n    }\n    @Test\n    public void testEvaluateObjectWithinShape() {\n        assertEvaluate(\"within(geopoint, geoshape)\", true,\n            Literal.of(ImmutableMap.<String, Object>of(\"type\", \"Point\", \"coordinates\", new double[]{10.0, 10.0})),\n            Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value(\"POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))\"))\n        );\n    }\n    @Test\n    public void testNormalizeWithReferenceAndLiteral() throws Exception {\n        Symbol normalizedSymbol = normalize(FNAME, createReference(\"foo\", DataTypes.GEO_POINT),\n            Literal.newGeoShape(\"POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))\"));\n        assertThat(normalizedSymbol, isFunction(FNAME));\n    }\n    @Test\n    public void testNormalizeWithTwoStringLiterals() throws Exception {\n        assertNormalize(\"within('POINT (10 10)', 'POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))')\", isLiteral(true));\n    }\n    @Test\n    public void testNormalizeWithStringLiteralAndReference() throws Exception {\n        Symbol normalized = normalize(FNAME,\n            createReference(\"point\", DataTypes.GEO_POINT),\n            Literal.of(\"POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))\"));\n        assertThat(normalized, instanceOf(Function.class));\n        Function function = (Function) normalized;\n        Symbol symbol = function.arguments().get(1);\n        assertThat(symbol.valueType(), equalTo(DataTypes.GEO_SHAPE));\n    }\n    @Test\n    public void testNormalizeWithFirstArgAsStringReference() throws Exception {\n        Symbol normalized = normalize(FNAME,\n            createReference(\"location\", DataTypes.STRING),\n            Literal.newGeoShape(\"POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))\"));\n        assertThat(normalized.symbolType(), is(SymbolType.FUNCTION));\n    }\n    @Test\n    public void testNormalizeWithSecondArgAsStringReference() throws Exception {\n        Symbol normalized = normalize(FNAME,\n            Literal.newGeoPoint(new Double[]{0.0d, 0.0d}),\n            createReference(\"location\", DataTypes.STRING));\n        assertThat(normalized.symbolType(), is(SymbolType.FUNCTION));\n        assertThat(((Function) normalized).info().ident().name(), is(WithinFunction.NAME));\n    }\n    @Test\n    public void testFirstArgumentWithInvalidType() throws Exception {\n        expectedException.expect(ConversionException.class);\n        getFunction(FNAME, DataTypes.LONG, DataTypes.GEO_POINT);\n    }\n    @Test\n    public void testSecondArgumentWithInvalidType() throws Exception {\n        expectedException.expect(ConversionException.class);\n        getFunction(FNAME, DataTypes.GEO_POINT, DataTypes.LONG);\n    }\n    @Test\n    public void testNormalizeFromObject() throws Exception {\n        Symbol normalized = normalize(FNAME,\n            Literal.of(\"POINT (1.0 0.0)\"),\n            Literal.of(ImmutableMap.<String, Object>of(\"type\", \"Point\", \"coordinates\", new double[]{0.0, 1.0})));\n        assertThat(normalized.symbolType(), is(SymbolType.LITERAL));\n        assertThat(((Literal) normalized).value(), is(Boolean.FALSE));\n    }\n"]]}
{"hexsha": "fb0bfa1a52807b4d3670993650f05d0011c60482", "ext": "java", "lang": "Java", "content": "public class InlineSegmentWranglerTest\n{\n  @Rule\n  public ExpectedException expectedException = ExpectedException.none();\n\n  private final InlineSegmentWrangler factory = new InlineSegmentWrangler();\n\n  private final InlineDataSource inlineDataSource = InlineDataSource.fromIterable(\n      ImmutableList.of(\n          new Object[]{\"foo\", 1L},\n          new Object[]{\"bar\", 2L}\n      ),\n      RowSignature.builder().add(\"str\", ValueType.STRING).add(\"long\", ValueType.LONG).build()\n  );\n\n  @Test\n  public void test_getSegmentsForIntervals_nonInline()\n  {\n    expectedException.expect(ClassCastException.class);\n    expectedException.expectMessage(\"TableDataSource cannot be cast\");\n\n    final Iterable<Segment> ignored = factory.getSegmentsForIntervals(\n        new TableDataSource(\"foo\"),\n        Intervals.ONLY_ETERNITY\n    );\n  }\n\n  @Test\n  public void test_getSegmentsForIntervals_inline()\n  {\n    final List<Segment> segments = ImmutableList.copyOf(\n        factory.getSegmentsForIntervals(\n            inlineDataSource,\n            Intervals.ONLY_ETERNITY\n        )\n    );\n\n    Assert.assertEquals(1, segments.size());\n\n    final Segment segment = Iterables.getOnlyElement(segments);\n    Assert.assertThat(segment, CoreMatchers.instanceOf(RowBasedSegment.class));\n  }\n}", "class_id": 0, "repo": "weishiuntsai/druid", "file": "server/src/test/java/org/apache/druid/segment/InlineSegmentWranglerTest.java", "last_update_at": "2020-11-02T01:48:43+00:00", "question_id": "fb0bfa1a52807b4d3670993650f05d0011c60482", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class InlineSegmentWranglerTest\n{\n  @Rule\n  public ExpectedException expectedException = ExpectedException.none();\n  private final InlineSegmentWrangler factory = new InlineSegmentWrangler();\n  private final InlineDataSource inlineDataSource = InlineDataSource.fromIterable(\n      ImmutableList.of(\n          new Object[]{\"foo\", 1L},\n          new Object[]{\"bar\", 2L}\n      ),\n      RowSignature.builder().add(\"str\", ValueType.STRING).add(\"long\", ValueType.LONG).build()\n  );\n  @Test\n  public void test_getSegmentsForIntervals_nonInline()\n  {\n    expectedException.expect(ClassCastException.class);\n    expectedException.expectMessage(\"TableDataSource cannot be cast\");\n    final Iterable<Segment> ignored = factory.getSegmentsForIntervals(\n        new TableDataSource(\"foo\"),\n        Intervals.ONLY_ETERNITY\n    );\n  }\n  @Test\n  public void test_getSegmentsForIntervals_inline()\n  {\n    final List<Segment> segments = ImmutableList.copyOf(\n        factory.getSegmentsForIntervals(\n            inlineDataSource,\n            Intervals.ONLY_ETERNITY\n        )\n    );\n    Assert.assertEquals(1, segments.size());\n    final Segment segment = Iterables.getOnlyElement(segments);\n    Assert.assertThat(segment, CoreMatchers.instanceOf(RowBasedSegment.class));\n  }\n"]]}
{"hexsha": "164cf028d5d4b440494a45ab7117d3007973708a", "ext": "java", "lang": "Java", "content": "public class QuickSort {\n    public static void main(String args[]) {\n        int A[] = {23, 45, 1, 4, 58, 85, 100, 12, 32, 13, 45};\n        quickSort(A, 0, A.length-1);\n\n        for(int i: A) {\n            System.out.print(i + \" \");\n        }\n    }\n\n    private static void quickSort(int A[], int start, int end) {\n        if(start < end) {\n            int partition = partition(A, start, end);\n            quickSort(A, start, partition-1);\n            quickSort(A, partition+1, end);\n        }\n    }\n\n    /* This method creates a sub-array in-place comparing each element with the last element of the given array amd returns the\n    index of the in-place sorted element which splits the whole sub-array in two unsorted in-place sub-array..\n    After the whole comparison the last element will be sorted in-place in the array and there will be two sub-array such that\n    they will be unsorted in nature but all the elements of them will either be smaller or larger than this in-place sorted element.\n\n    If the numbers compared are smaller than the last element than they are swapped such that after the last element is in-place they\n    form the elements of left sub-array and vice versa for elements greater than the last element. (Done by the loop in the method)\n     */\n    private static int partition(int A[], int start, int end) {\n        int i = start-1, x = A[end], temp;\n        for(int j=start; j<end; j++) {\n            if(A[j]<=x) {\n                i += 1;\n                temp = A[i];\n                A[i] = A[j];\n                A[j] = temp;\n            }\n        }\n        /* i now holds the last element of sub-array and therefore to sort the last element in-pace we need to swap it with the first\n        element of the right sub-array. */\n\n        temp = A[i+1];\n        A[i+1] = A[end];\n        A[end] = temp;\n\n        return i+1;\n    }\n\n    private static int hoarePartition(int A[], int start, int end) {\n        int i = start-1;\n        /*\n        x=A[p}\n        i=p-1\n        j=r+1\n        repeat:\n            j=j-1\n            until A[j]<=x\n        repeat:\n            i=i+1\n            until A[i]>=x\n        if(i<j)\n        exchange A[i] with A[j]\n        else\n        return j\n        */\n        return i+1;\n    }\n\n    /* TODO: Create a randomized version for partitioning by randomly choosing any element of the array for in-place sorting rather\n    than always choosing only first or last element.\n    randomly choose any element from array.\n    swap with first or last element and then execute normal partitioning algorithm\n    */\n}", "class_id": 0, "repo": "aayush-goyal/AlgorithmsAndDataStructures", "file": "src/SearchingAndSorting/Sorting/QuickSort.java", "last_update_at": "2020-03-17T12:36:47+00:00", "question_id": "164cf028d5d4b440494a45ab7117d3007973708a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class QuickSort {\n    public static void main(String args[]) {\n        int A[] = {23, 45, 1, 4, 58, 85, 100, 12, 32, 13, 45};\n        quickSort(A, 0, A.length-1);\n        for(int i: A) {\n            System.out.print(i + \" \");\n        }\n    }\n    private static void quickSort(int A[], int start, int end) {\n        if(start < end) {\n            int partition = partition(A, start, end);\n            quickSort(A, start, partition-1);\n            quickSort(A, partition+1, end);\n        }\n    }\n    /* This method creates a sub-array in-place comparing each element with the last element of the given array amd returns the\n    index of the in-place sorted element which splits the whole sub-array in two unsorted in-place sub-array..\n    After the whole comparison the last element will be sorted in-place in the array and there will be two sub-array such that\n    they will be unsorted in nature but all the elements of them will either be smaller or larger than this in-place sorted element.\n    If the numbers compared are smaller than the last element than they are swapped such that after the last element is in-place they\n    form the elements of left sub-array and vice versa for elements greater than the last element. (Done by the loop in the method)\n     */\n    private static int partition(int A[], int start, int end) {\n        int i = start-1, x = A[end], temp;\n        for(int j=start; j<end; j++) {\n            if(A[j]<=x) {\n                i += 1;\n                temp = A[i];\n                A[i] = A[j];\n                A[j] = temp;\n            }\n        }\n        /* i now holds the last element of sub-array and therefore to sort the last element in-pace we need to swap it with the first\n        element of the right sub-array. */\n        temp = A[i+1];\n        A[i+1] = A[end];\n        A[end] = temp;\n        return i+1;\n    }\n    private static int hoarePartition(int A[], int start, int end) {\n        int i = start-1;\n        /*\n        x=A[p}\n        i=p-1\n        j=r+1\n        repeat:\n            j=j-1\n            until A[j]<=x\n        repeat:\n            i=i+1\n            until A[i]>=x\n        if(i<j)\n        exchange A[i] with A[j]\n        else\n        return j\n        */\n        return i+1;\n    }\n    /* TODO: Create a randomized version for partitioning by randomly choosing any element of the array for in-place sorting rather\n    than always choosing only first or last element.\n    randomly choose any element from array.\n    swap with first or last element and then execute normal partitioning algorithm\n    */\n"]]}
{"hexsha": "080d89d04cc07bf8055ea12adb37fd71049e8b54", "ext": "java", "lang": "Java", "content": "class InputReferenceCompiler\n        implements RowExpressionVisitor<BytecodeNode, Scope>\n{\n    private final BiFunction<Scope, Integer, BytecodeExpression> blockResolver;\n    private final BiFunction<Scope, Integer, BytecodeExpression> positionResolver;\n    private final CallSiteBinder callSiteBinder;\n\n    public InputReferenceCompiler(\n            BiFunction<Scope, Integer, BytecodeExpression> blockResolver,\n            BiFunction<Scope, Integer, BytecodeExpression> positionResolver,\n            CallSiteBinder callSiteBinder)\n    {\n        this.blockResolver = requireNonNull(blockResolver, \"blockResolver is null\");\n        this.positionResolver = requireNonNull(positionResolver, \"positionResolver is null\");\n        this.callSiteBinder = requireNonNull(callSiteBinder, \"callSiteBinder is null\");\n    }\n\n    public static BytecodeNode generateInputReference(CallSiteBinder callSiteBinder, Scope scope, Type type, BytecodeExpression block, BytecodeExpression position)\n    {\n        return new InputReferenceNode(callSiteBinder, scope, type, block, position);\n    }\n\n    @Override\n    public BytecodeNode visitInputReference(InputReferenceExpression node, Scope scope)\n    {\n        int field = node.getField();\n        Type type = node.getType();\n\n        BytecodeExpression block = blockResolver.apply(scope, field);\n        BytecodeExpression position = positionResolver.apply(scope, field);\n\n        return generateInputReference(callSiteBinder, scope, type, block, position);\n    }\n\n    @Override\n    public BytecodeNode visitCall(CallExpression call, Scope scope)\n    {\n        throw new UnsupportedOperationException(\"not yet implemented\");\n    }\n\n    @Override\n    public BytecodeNode visitSpecialForm(SpecialForm specialForm, Scope context)\n    {\n        throw new UnsupportedOperationException(\"not yet implemented\");\n    }\n\n    @Override\n    public BytecodeNode visitConstant(ConstantExpression literal, Scope scope)\n    {\n        throw new UnsupportedOperationException(\"not yet implemented\");\n    }\n\n    @Override\n    public BytecodeNode visitLambda(LambdaDefinitionExpression lambda, Scope context)\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public BytecodeNode visitVariableReference(VariableReferenceExpression reference, Scope context)\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    static class InputReferenceNode\n            implements BytecodeNode\n    {\n        private final BytecodeNode body;\n        private final BytecodeExpression block;\n        private final BytecodeExpression position;\n\n        private InputReferenceNode(CallSiteBinder callSiteBinder, Scope scope, Type type, BytecodeExpression block, BytecodeExpression position)\n        {\n            // Generate body based on block and position\n            Variable wasNullVariable = scope.getVariable(\"wasNull\");\n            Class<?> javaType = type.getJavaType();\n            if (!javaType.isPrimitive() && javaType != Slice.class) {\n                javaType = Object.class;\n            }\n\n            IfStatement ifStatement = new IfStatement();\n            ifStatement.condition(block.invoke(\"isNull\", boolean.class, position));\n\n            ifStatement.ifTrue()\n                    .putVariable(wasNullVariable, true)\n                    .pushJavaDefault(javaType);\n\n            String methodName = \"get\" + Primitives.wrap(javaType).getSimpleName();\n            ifStatement.ifFalse(constantType(callSiteBinder, type).invoke(methodName, javaType, block, position));\n\n            this.body = ifStatement;\n            this.block = block;\n            this.position = position;\n        }\n\n        @Override\n        public List<BytecodeNode> getChildNodes()\n        {\n            return ImmutableList.of();\n        }\n\n        @Override\n        public void accept(MethodVisitor visitor, MethodGenerationContext generationContext)\n        {\n            body.accept(visitor, generationContext);\n        }\n\n        @Override\n        public <T> T accept(BytecodeNode parent, BytecodeVisitor<T> visitor)\n        {\n            return visitor.visitIf(parent, (IfStatement) body);\n        }\n\n        public BytecodeNode produceBlockAndPosition()\n        {\n            BytecodeBlock blockAndPosition = new BytecodeBlock();\n            blockAndPosition.append(block);\n            blockAndPosition.append(position);\n            return blockAndPosition;\n        }\n    }\n}", "class_id": 0, "repo": "guerremdq/presto", "file": "presto-main/src/main/java/io/prestosql/sql/gen/InputReferenceCompiler.java", "last_update_at": "2020-05-11T14:32:37+00:00", "question_id": "080d89d04cc07bf8055ea12adb37fd71049e8b54", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class InputReferenceCompiler\n        implements RowExpressionVisitor<BytecodeNode, Scope>\n{\n    private final BiFunction<Scope, Integer, BytecodeExpression> blockResolver;\n    private final BiFunction<Scope, Integer, BytecodeExpression> positionResolver;\n    private final CallSiteBinder callSiteBinder;\n    public InputReferenceCompiler(\n            BiFunction<Scope, Integer, BytecodeExpression> blockResolver,\n            BiFunction<Scope, Integer, BytecodeExpression> positionResolver,\n            CallSiteBinder callSiteBinder)\n    {\n        this.blockResolver = requireNonNull(blockResolver, \"blockResolver is null\");\n        this.positionResolver = requireNonNull(positionResolver, \"positionResolver is null\");\n        this.callSiteBinder = requireNonNull(callSiteBinder, \"callSiteBinder is null\");\n    }\n    public static BytecodeNode generateInputReference(CallSiteBinder callSiteBinder, Scope scope, Type type, BytecodeExpression block, BytecodeExpression position)\n    {\n        return new InputReferenceNode(callSiteBinder, scope, type, block, position);\n    }\n    @Override\n    public BytecodeNode visitInputReference(InputReferenceExpression node, Scope scope)\n    {\n        int field = node.getField();\n        Type type = node.getType();\n        BytecodeExpression block = blockResolver.apply(scope, field);\n        BytecodeExpression position = positionResolver.apply(scope, field);\n        return generateInputReference(callSiteBinder, scope, type, block, position);\n    }\n    @Override\n    public BytecodeNode visitCall(CallExpression call, Scope scope)\n    {\n        throw new UnsupportedOperationException(\"not yet implemented\");\n    }\n    @Override\n    public BytecodeNode visitSpecialForm(SpecialForm specialForm, Scope context)\n    {\n        throw new UnsupportedOperationException(\"not yet implemented\");\n    }\n    @Override\n    public BytecodeNode visitConstant(ConstantExpression literal, Scope scope)\n    {\n        throw new UnsupportedOperationException(\"not yet implemented\");\n    }\n    @Override\n    public BytecodeNode visitLambda(LambdaDefinitionExpression lambda, Scope context)\n    {\n        throw new UnsupportedOperationException();\n    }\n    @Override\n    public BytecodeNode visitVariableReference(VariableReferenceExpression reference, Scope context)\n    {\n        throw new UnsupportedOperationException();\n    }\n    static class InputReferenceNode\n            implements BytecodeNode\n    {\n        private final BytecodeNode body;\n        private final BytecodeExpression block;\n        private final BytecodeExpression position;\n        private InputReferenceNode(CallSiteBinder callSiteBinder, Scope scope, Type type, BytecodeExpression block, BytecodeExpression position)\n        {\n            // Generate body based on block and position\n            Variable wasNullVariable = scope.getVariable(\"wasNull\");\n            Class<?> javaType = type.getJavaType();\n            if (!javaType.isPrimitive() && javaType != Slice.class) {\n                javaType = Object.class;\n            }\n            IfStatement ifStatement = new IfStatement();\n            ifStatement.condition(block.invoke(\"isNull\", boolean.class, position));\n            ifStatement.ifTrue()\n                    .putVariable(wasNullVariable, true)\n                    .pushJavaDefault(javaType);\n            String methodName = \"get\" + Primitives.wrap(javaType).getSimpleName();\n            ifStatement.ifFalse(constantType(callSiteBinder, type).invoke(methodName, javaType, block, position));\n            this.body = ifStatement;\n            this.block = block;\n            this.position = position;\n        }\n        @Override\n        public List<BytecodeNode> getChildNodes()\n        {\n            return ImmutableList.of();\n        }\n        @Override\n        public void accept(MethodVisitor visitor, MethodGenerationContext generationContext)\n        {\n            body.accept(visitor, generationContext);\n        }\n        @Override\n        public <T> T accept(BytecodeNode parent, BytecodeVisitor<T> visitor)\n        {\n            return visitor.visitIf(parent, (IfStatement) body);\n        }\n        public BytecodeNode produceBlockAndPosition()\n        {\n            BytecodeBlock blockAndPosition = new BytecodeBlock();\n            blockAndPosition.append(block);\n            blockAndPosition.append(position);\n            return blockAndPosition;\n        }\n    }\n"]]}
{"hexsha": "6d292050425fb000cbdaa7dd96734a7c4f9d92d4", "ext": "java", "lang": "Java", "content": "public class MethodOverloadingTestCase extends BaseTestCase implements LogChute\r\n{\r\n    String logData;\r\n    \r\n    /**\r\n    * VTL file extension.\r\n    */\r\n   private static final String TMPL_FILE_EXT = \"vm\";\r\n\r\n   /**\r\n    * Comparison file extension.\r\n    */\r\n   private static final String CMP_FILE_EXT = \"cmp\";\r\n\r\n   /**\r\n    * Comparison file extension.\r\n    */\r\n   private static final String RESULT_FILE_EXT = \"res\";\r\n\r\n   /**\r\n    * Path for templates. This property will override the\r\n    * value in the default velocity properties file.\r\n    */\r\n   private final static String FILE_RESOURCE_LOADER_PATH = TEST_COMPARE_DIR + \"/methodoverloading\";\r\n\r\n   /**\r\n    * Results relative to the build directory.\r\n    */\r\n   private static final String RESULTS_DIR = TEST_RESULT_DIR + \"/methodoverloading\";\r\n\r\n   /**\r\n    * Results relative to the build directory.\r\n    */\r\n   private static final String COMPARE_DIR = TEST_COMPARE_DIR + \"/methodoverloading/compare\";\r\n\r\n    /**\r\n     * Default constructor.\r\n     */\r\n    public MethodOverloadingTestCase(String name)\r\n    {\r\n        super(name);\r\n    }\r\n\r\n    public void setUp()\r\n    {\r\n        assureResultsDirectoryExists(RESULTS_DIR);\r\n    }\r\n\r\n    public static Test suite()\r\n    {\r\n       return new TestSuite(MethodOverloadingTestCase.class);\r\n    }\r\n\r\n    public void testMethodOverloading()\r\n    throws Exception\r\n    {\r\n        /**\r\n         * test overloading in a single template\r\n         */\r\n        testFile(\"single\");\r\n\r\n        assertTrue(logData.indexOf(\"IllegalArgumentException\") == -1);\r\n    }\r\n\r\n    public void testParsedMethodOverloading()\r\n    throws Exception\r\n    {\r\n        /**\r\n         * test overloading in a file included with #parse\r\n         */\r\n        testFile(\"main\");\r\n        \r\n        assertTrue(logData.indexOf(\"IllegalArgumentException\") == -1);\r\n        \r\n    }\r\n    \r\n    public void testFile(String basefilename)\r\n    throws Exception\r\n    {\r\n        \r\n        VelocityEngine ve = new VelocityEngine();\r\n        ve.addProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, FILE_RESOURCE_LOADER_PATH);\r\n        ve.setProperty(VelocityEngine.RUNTIME_LOG_LOGSYSTEM, this );\r\n        ve.init();\r\n        \r\n        Template template;\r\n        FileOutputStream fos;\r\n        Writer fwriter;\r\n        Context context;\r\n        \r\n        template = ve.getTemplate( getFileName(null, basefilename, TMPL_FILE_EXT) );\r\n        \r\n        fos = new FileOutputStream (\r\n                getFileName(RESULTS_DIR, basefilename, RESULT_FILE_EXT));\r\n        \r\n        fwriter = new BufferedWriter( new OutputStreamWriter(fos) );\r\n        \r\n        context = new VelocityContext();\r\n        setupContext(context);\r\n        template.merge(context, fwriter);\r\n        fwriter.flush();\r\n        fwriter.close();\r\n        \r\n        if (!isMatch(RESULTS_DIR, COMPARE_DIR, basefilename, RESULT_FILE_EXT, CMP_FILE_EXT))\r\n        {\r\n            fail(\"Output incorrect.\");\r\n        }\r\n    }\r\n        \r\n    public void setupContext(Context context)\r\n    {\r\n      context.put(\"test\", this);\r\n      context.put(\"nullValue\", null);  \r\n    } \r\n    \r\n    \r\n    public String overloadedMethod ( Integer s )\r\n    {\r\n        return \"Integer\";\r\n    }\r\n    \r\n    public String overloadedMethod ( String s )\r\n    {\r\n        return \"String\";\r\n    }\r\n    \r\n    \r\n    public String overloadedMethod2 ( Integer s )\r\n    {\r\n        return \"Integer\";\r\n    }\r\n    \r\n    public String overloadedMethod2 ( String i )\r\n    {\r\n        return \"String\";\r\n    }\r\n\r\n\r\n    public void log(int level, String message)\r\n    {\r\n        String out = \"\";\r\n\r\n        /*\r\n         * Start with the appropriate prefix\r\n         */\r\n        switch( level )\r\n        {\r\n            case DEBUG_ID :\r\n                out = DEBUG_PREFIX;\r\n                break;\r\n            case INFO_ID :\r\n                out = INFO_PREFIX;\r\n                break;\r\n            case TRACE_ID :\r\n                out = TRACE_PREFIX;\r\n                break;\r\n            case WARN_ID :\r\n                out = WARN_PREFIX;\r\n                break;\r\n            case ERROR_ID :\r\n                out = ERROR_PREFIX;\r\n                break;\r\n            default :\r\n                out = INFO_PREFIX;\r\n                break;\r\n        }\r\n\r\n        logData += \"\\n\" + out + message;\r\n    }\r\n\r\n    public void init( RuntimeServices rs )\r\n    {\r\n        // do nothing with it\r\n    }\r\n\r\n    public void log(int level, String message, Throwable t)\r\n    {\r\n        // ignore the Throwable, we're not testing this method here\r\n        log(level, message);\r\n    }\r\n\r\n    public boolean isLevelEnabled(int level)\r\n    {\r\n        return true;\r\n    }\r\n}", "class_id": 0, "repo": "1CharlesStern/Web-Verifier", "file": "src/test/org/apache/velocity/test/MethodOverloadingTestCase.java", "last_update_at": "2020-06-09T08:15:00+00:00", "question_id": "6d292050425fb000cbdaa7dd96734a7c4f9d92d4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MethodOverloadingTestCase extends BaseTestCase implements LogChute\r\n{\r\n    String logData;\r\n    \r\n    /**\r\n    * VTL file extension.\r\n    */\r\n   private static final String TMPL_FILE_EXT = \"vm\";\r\n\r\n   /**\r\n    * Comparison file extension.\r\n    */\r\n   private static final String CMP_FILE_EXT = \"cmp\";\r\n\r\n   /**\r\n    * Comparison file extension.\r\n    */\r\n   private static final String RESULT_FILE_EXT = \"res\";\r\n\r\n   /**\r\n    * Path for templates. This property will override the\r\n    * value in the default velocity properties file.\r\n    */\r\n   private final static String FILE_RESOURCE_LOADER_PATH = TEST_COMPARE_DIR + \"/methodoverloading\";\r\n\r\n   /**\r\n    * Results relative to the build directory.\r\n    */\r\n   private static final String RESULTS_DIR = TEST_RESULT_DIR + \"/methodoverloading\";\r\n\r\n   /**\r\n    * Results relative to the build directory.\r\n    */\r\n   private static final String COMPARE_DIR = TEST_COMPARE_DIR + \"/methodoverloading/compare\";\r\n\r\n    /**\r\n     * Default constructor.\r\n     */\r\n    public MethodOverloadingTestCase(String name)\r\n    {\r\n        super(name);\r\n    }\r\n\r\n    public void setUp()\r\n    {\r\n        assureResultsDirectoryExists(RESULTS_DIR);\r\n    }\r\n\r\n    public static Test suite()\r\n    {\r\n       return new TestSuite(MethodOverloadingTestCase.class);\r\n    }\r\n\r\n    public void testMethodOverloading()\r\n    throws Exception\r\n    {\r\n        /**\r\n         * test overloading in a single template\r\n         */\r\n        testFile(\"single\");\r\n\r\n        assertTrue(logData.indexOf(\"IllegalArgumentException\") == -1);\r\n    }\r\n\r\n    public void testParsedMethodOverloading()\r\n    throws Exception\r\n    {\r\n        /**\r\n         * test overloading in a file included with #parse\r\n         */\r\n        testFile(\"main\");\r\n        \r\n        assertTrue(logData.indexOf(\"IllegalArgumentException\") == -1);\r\n        \r\n    }\r\n    \r\n    public void testFile(String basefilename)\r\n    throws Exception\r\n    {\r\n        \r\n        VelocityEngine ve = new VelocityEngine();\r\n        ve.addProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, FILE_RESOURCE_LOADER_PATH);\r\n        ve.setProperty(VelocityEngine.RUNTIME_LOG_LOGSYSTEM, this );\r\n        ve.init();\r\n        \r\n        Template template;\r\n        FileOutputStream fos;\r\n        Writer fwriter;\r\n        Context context;\r\n        \r\n        template = ve.getTemplate( getFileName(null, basefilename, TMPL_FILE_EXT) );\r\n        \r\n        fos = new FileOutputStream (\r\n                getFileName(RESULTS_DIR, basefilename, RESULT_FILE_EXT));\r\n        \r\n        fwriter = new BufferedWriter( new OutputStreamWriter(fos) );\r\n        \r\n        context = new VelocityContext();\r\n        setupContext(context);\r\n        template.merge(context, fwriter);\r\n        fwriter.flush();\r\n        fwriter.close();\r\n        \r\n        if (!isMatch(RESULTS_DIR, COMPARE_DIR, basefilename, RESULT_FILE_EXT, CMP_FILE_EXT))\r\n        {\r\n            fail(\"Output incorrect.\");\r\n        }\r\n    }\r\n        \r\n    public void setupContext(Context context)\r\n    {\r\n      context.put(\"test\", this);\r\n      context.put(\"nullValue\", null);  \r\n    } \r\n    \r\n    \r\n    public String overloadedMethod ( Integer s )\r\n    {\r\n        return \"Integer\";\r\n    }\r\n    \r\n    public String overloadedMethod ( String s )\r\n    {\r\n        return \"String\";\r\n    }\r\n    \r\n    \r\n    public String overloadedMethod2 ( Integer s )\r\n    {\r\n        return \"Integer\";\r\n    }\r\n    \r\n    public String overloadedMethod2 ( String i )\r\n    {\r\n        return \"String\";\r\n    }\r\n\r\n\r\n    public void log(int level, String message)\r\n    {\r\n        String out = \"\";\r\n\r\n        /*\r\n         * Start with the appropriate prefix\r\n         */\r\n        switch( level )\r\n        {\r\n            case DEBUG_ID :\r\n                out = DEBUG_PREFIX;\r\n                break;\r\n            case INFO_ID :\r\n                out = INFO_PREFIX;\r\n                break;\r\n            case TRACE_ID :\r\n                out = TRACE_PREFIX;\r\n                break;\r\n            case WARN_ID :\r\n                out = WARN_PREFIX;\r\n                break;\r\n            case ERROR_ID :\r\n                out = ERROR_PREFIX;\r\n                break;\r\n            default :\r\n                out = INFO_PREFIX;\r\n                break;\r\n        }\r\n\r\n        logData += \"\\n\" + out + message;\r\n    }\r\n\r\n    public void init( RuntimeServices rs )\r\n    {\r\n        // do nothing with it\r\n    }\r\n\r\n    public void log(int level, String message, Throwable t)\r\n    {\r\n        // ignore the Throwable, we're not testing this method here\r\n        log(level, message);\r\n    }\r\n\r\n    public boolean isLevelEnabled(int level)\r\n    {\r\n        return true;\r\n    }\r\n"]]}
{"hexsha": "3917982c1fdc78abf81711dbaacc636d46db79c3", "ext": "java", "lang": "Java", "content": "public class DeleteExpiredDataResponse implements ToXContentObject {\n\n    private static final ParseField DELETED = new ParseField(\"deleted\");\n\n    public DeleteExpiredDataResponse(boolean deleted) {\n        this.deleted = deleted;\n    }\n\n    public static final ConstructingObjectParser<DeleteExpiredDataResponse, Void> PARSER =\n        new ConstructingObjectParser<>(\"delete_expired_data_response\", true,\n            a -> new DeleteExpiredDataResponse((Boolean) a[0]));\n\n    static {\n        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), DELETED);\n    }\n\n    public static DeleteExpiredDataResponse fromXContent(XContentParser parser) throws IOException {\n        return PARSER.parse(parser, null);\n    }\n\n    private final Boolean deleted;\n\n    public Boolean getDeleted() {\n        return deleted;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(deleted);\n    }\n\n    @Override\n    public XContentBuilder toXContent(XContentBuilder builder, ToXContent.Params params) throws IOException {\n        builder.startObject();\n        if (deleted != null) {\n            builder.field(DELETED.getPreferredName(), deleted);\n        }\n        builder.endObject();\n        return builder;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        DeleteExpiredDataResponse response = (DeleteExpiredDataResponse) obj;\n        return Objects.equals(deleted, response.deleted);\n    }\n}", "class_id": 0, "repo": "ZenMX/elasticsearch", "file": "client/rest-high-level/src/main/java/org/elasticsearch/client/ml/DeleteExpiredDataResponse.java", "last_update_at": "2020-07-09T19:01:20+00:00", "question_id": "3917982c1fdc78abf81711dbaacc636d46db79c3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DeleteExpiredDataResponse implements ToXContentObject {\n    private static final ParseField DELETED = new ParseField(\"deleted\");\n    public DeleteExpiredDataResponse(boolean deleted) {\n        this.deleted = deleted;\n    }\n    public static final ConstructingObjectParser<DeleteExpiredDataResponse, Void> PARSER =\n        new ConstructingObjectParser<>(\"delete_expired_data_response\", true,\n            a -> new DeleteExpiredDataResponse((Boolean) a[0]));\n    static {\n        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), DELETED);\n    }\n    public static DeleteExpiredDataResponse fromXContent(XContentParser parser) throws IOException {\n        return PARSER.parse(parser, null);\n    }\n    private final Boolean deleted;\n    public Boolean getDeleted() {\n        return deleted;\n    }\n    @Override\n    public int hashCode() {\n        return Objects.hash(deleted);\n    }\n    @Override\n    public XContentBuilder toXContent(XContentBuilder builder, ToXContent.Params params) throws IOException {\n        builder.startObject();\n        if (deleted != null) {\n            builder.field(DELETED.getPreferredName(), deleted);\n        }\n        builder.endObject();\n        return builder;\n    }\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        DeleteExpiredDataResponse response = (DeleteExpiredDataResponse) obj;\n        return Objects.equals(deleted, response.deleted);\n    }\n"]]}
{"hexsha": "675d3239af4e007f4f522b60e4a9f5e3b70ba816", "ext": "java", "lang": "Java", "content": "public class XslCompileUriResolver implements URIResolver {\n\n  private CompilerContext _cc;\n  private OXPath10Expression _expr;\n\n  public XslCompileUriResolver(CompilerContext cc, OXPath10Expression expr) {\n    _cc = cc;\n    _expr = expr;\n  }\n\n  public Source resolve(String href, String base) throws TransformerException {\n    OXslSheet xslSheet = _cc.compileXslt(href);\n    _expr.setXslSheet(xslSheet.uri, xslSheet);\n    return new StreamSource(new StringReader(xslSheet.sheetBody));\n  }\n}", "class_id": 0, "repo": "test-coverage-enforce-bot/wso2-ode", "file": "bpel-compiler/src/main/java/org/apache/ode/bpel/elang/xpath10/compiler/XslCompileUriResolver.java", "last_update_at": "2020-08-25T07:00:51+00:00", "question_id": "675d3239af4e007f4f522b60e4a9f5e3b70ba816", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class XslCompileUriResolver implements URIResolver {\n  private CompilerContext _cc;\n  private OXPath10Expression _expr;\n  public XslCompileUriResolver(CompilerContext cc, OXPath10Expression expr) {\n    _cc = cc;\n    _expr = expr;\n  }\n  public Source resolve(String href, String base) throws TransformerException {\n    OXslSheet xslSheet = _cc.compileXslt(href);\n    _expr.setXslSheet(xslSheet.uri, xslSheet);\n    return new StreamSource(new StringReader(xslSheet.sheetBody));\n  }\n"]]}
{"hexsha": "ee94ed59650d7bdb1cb15c5247d1e3990690ce94", "ext": "java", "lang": "Java", "content": "class OrderedCode {\n  // We want to encode a few extra symbols in strings:\n  //      <sep>           Separator between items\n  //      <infinity>      Infinite string\n  //\n  // Therefore we need an alphabet with at least 258 characters.  We\n  // achieve this by using two-letter sequences starting with '\\0' and '\\xff'\n  // as extra symbols:\n  //      <sep>           encoded as =>           \\0\\1\n  //      \\0              encoded as =>           \\0\\xff\n  //      \\xff            encoded as =>           \\xff\\x00\n  //      <infinity>      encoded as =>           \\xff\\xff\n  //\n  // The remaining two letter sequences starting with '\\0' and '\\xff'\n  // are currently unused.\n\n  static final byte ESCAPE1 = 0x00;\n  static final byte NULL_CHARACTER = (byte) 0xff; // Combined with ESCAPE1\n  static final byte SEPARATOR = 0x01; // Combined with ESCAPE1\n\n  static final byte ESCAPE2 = (byte) 0xff;\n  static final byte INFINITY = (byte) 0xff; // Combined with ESCAPE2\n  static final byte FF_CHARACTER = 0x00; // Combined with ESCAPE2\n\n  static final byte[] ESCAPE1_SEPARATOR = {ESCAPE1, SEPARATOR};\n\n  static final byte[] INFINITY_ENCODED = {ESCAPE2, INFINITY};\n\n  static final byte[] INFINITY_ENCODED_DECREASING = {invert(ESCAPE2), invert(INFINITY)};\n\n  /**\n   * This array maps encoding length to header bits in the first two bytes for SignedNumIncreasing\n   * encoding.\n   */\n  private static final byte[][] LENGTH_TO_HEADER_BITS = {\n    {0, 0},\n    {(byte) 0x80, 0},\n    {(byte) 0xc0, 0},\n    {(byte) 0xe0, 0},\n    {(byte) 0xf0, 0},\n    {(byte) 0xf8, 0},\n    {(byte) 0xfc, 0},\n    {(byte) 0xfe, 0},\n    {(byte) 0xff, 0},\n    {(byte) 0xff, (byte) 0x80},\n    {(byte) 0xff, (byte) 0xc0}\n  };\n\n  /**\n   * This array maps encoding lengths to the header bits that overlap with the payload and need\n   * fixing during readSignedNumIncreasing.\n   */\n  private static final long[] LENGTH_TO_MASK = {\n    0L,\n    0x80L,\n    0xc000L,\n    0xe00000L,\n    0xf0000000L,\n    0xf800000000L,\n    0xfc0000000000L,\n    0xfe000000000000L,\n    0xff00000000000000L,\n    0x8000000000000000L,\n    0L\n  };\n\n  /**\n   * This array maps the number of bits in a number to the encoding length produced by\n   * WriteSignedNumIncreasing. For positive numbers, the number of bits is 1 plus the most\n   * significant bit position (the highest bit position in a positive long is 63). For a negative\n   * number n, we count the bits in ~n. That is, length = BITS_TO_LENGTH[log2Floor(n < 0 ? ~n : n) +\n   * 1].\n   */\n  private static final short[] BITS_TO_LENGTH = {\n    1, 1, 1, 1, 1, 1, 1,\n    2, 2, 2, 2, 2, 2, 2,\n    3, 3, 3, 3, 3, 3, 3,\n    4, 4, 4, 4, 4, 4, 4,\n    5, 5, 5, 5, 5, 5, 5,\n    6, 6, 6, 6, 6, 6, 6,\n    7, 7, 7, 7, 7, 7, 7,\n    8, 8, 8, 8, 8, 8, 8,\n    9, 9, 9, 9, 9, 9, 9,\n    10\n  };\n\n  // stores the current encoded value as a list of byte arrays. Note that this\n  // is manipulated as we read/write items.\n  // Note that every item will fit on at most one array. One array may\n  // have more than one item (eg when used for decoding). While encoding,\n  // one array will have exactly one item. While returning the encoded array\n  // we will merge all the arrays in this list.\n  private final ArrayList<byte[]> encodedArrays = new ArrayList<>();\n\n  // This is the current position on the first array. Will be non-zero\n  // only if the ordered code was created using encoded byte array.\n  private int firstArrayPosition = 0;\n\n  /** Creates OrderedCode from scratch. Typically used at encoding time. */\n  public OrderedCode() {}\n\n  /**\n   * Creates OrderedCode from a given encoded byte array. Typically used at decoding time.\n   *\n   * <p><b> For better performance, it uses the input array provided (not a copy). Therefore the\n   * input array should not be modified.</b>\n   */\n  public OrderedCode(byte[] encodedByteArray) {\n    encodedArrays.add(encodedByteArray);\n  }\n\n  /**\n   * Adds the given byte array item to the OrderedCode. It encodes the input byte array, followed by\n   * a separator and appends the result to its internal encoded byte array store.\n   *\n   * <p>It works with the input array, so the input array 'value' should not be modified till the\n   * method returns.\n   *\n   * @param value bytes to be written.\n   * @see #readBytes()\n   */\n  public void writeBytes(byte[] value) {\n    writeBytes(value, false);\n  }\n\n  public void writeBytesDecreasing(byte[] value) {\n    writeBytes(value, true);\n  }\n\n  private void writeBytes(byte[] value, boolean invert) {\n    // Determine the length of the encoded array\n    int encodedLength = 2; // for separator\n    for (byte b : value) {\n      if ((b == ESCAPE1) || (b == ESCAPE2)) {\n        encodedLength += 2;\n      } else {\n        encodedLength++;\n      }\n    }\n\n    byte[] encodedArray = new byte[encodedLength];\n    int copyStart = 0;\n    int outIndex = 0;\n    for (int i = 0; i < value.length; i++) {\n      byte b = value[i];\n      if (b == ESCAPE1) {\n        arraycopy(invert, value, copyStart, encodedArray, outIndex, i - copyStart);\n        outIndex += i - copyStart;\n        encodedArray[outIndex++] = convert(invert, ESCAPE1);\n        encodedArray[outIndex++] = convert(invert, NULL_CHARACTER);\n        copyStart = i + 1;\n      } else if (b == ESCAPE2) {\n        arraycopy(invert, value, copyStart, encodedArray, outIndex, i - copyStart);\n        outIndex += i - copyStart;\n        encodedArray[outIndex++] = convert(invert, ESCAPE2);\n        encodedArray[outIndex++] = convert(invert, FF_CHARACTER);\n        copyStart = i + 1;\n      }\n    }\n    if (copyStart < value.length) {\n      arraycopy(invert, value, copyStart, encodedArray, outIndex, value.length - copyStart);\n      outIndex += value.length - copyStart;\n    }\n    encodedArray[outIndex++] = convert(invert, ESCAPE1);\n    encodedArray[outIndex] = convert(invert, SEPARATOR);\n\n    encodedArrays.add(encodedArray);\n  }\n\n  private static byte convert(boolean invert, byte val) {\n    return invert ? (byte) ~val : val;\n  }\n\n  private static byte invert(byte val) {\n    return convert(true, val);\n  }\n\n  private void arraycopy(\n      boolean invert, byte[] src, int srcPos, byte[] dest, int destPos, int length) {\n    System.arraycopy(src, srcPos, dest, destPos, length);\n    if (invert) {\n      for (int i = destPos; i < destPos + length; i++) {\n        dest[i] = (byte) ~dest[i];\n      }\n    }\n  }\n\n  /**\n   * Encodes the long item, in big-endian format, and appends the result to its internal encoded\n   * byte array store.\n   *\n   * @see #readNumIncreasing()\n   */\n  public void writeNumIncreasing(long value) {\n    // Values are encoded with a single byte length prefix, followed\n    // by the actual value in big-endian format with leading 0 bytes\n    // dropped.\n    byte[] bufer = new byte[9]; // 8 bytes for value plus one byte for length\n    int len = 0;\n    while (value != 0) {\n      len++;\n      bufer[9 - len] = (byte) (value & 0xff);\n      value >>>= 8;\n    }\n    bufer[9 - len - 1] = (byte) len;\n    len++;\n    byte[] encodedArray = new byte[len];\n    System.arraycopy(bufer, 9 - len, encodedArray, 0, len);\n    encodedArrays.add(encodedArray);\n  }\n\n  public void writeNumIncreasing(UnsignedInteger unsignedInt) {\n    writeNumIncreasing(unsignedInt.longValue());\n  }\n\n  /**\n   * Encodes the long item, in big-endian format, and appends the result to its internal encoded\n   * byte array store.\n   *\n   * @see #readNumIncreasing()\n   */\n  public void writeNumDecreasing(long value) {\n    // Values are encoded with a complemented single byte length prefix,\n    // followed by the complement of the actual value in big-endian format with\n    // leading 0xff bytes dropped.\n    byte[] bufer = new byte[9]; // 8 bytes for value plus one byte for length\n    int len = 0;\n    while (value != 0) {\n      len++;\n      bufer[9 - len] = (byte) ~(value & 0xff);\n      value >>>= 8;\n    }\n    bufer[9 - len - 1] = (byte) ~len;\n    len++;\n    byte[] encodedArray = new byte[len];\n    System.arraycopy(bufer, 9 - len, encodedArray, 0, len);\n    encodedArrays.add(encodedArray);\n  }\n\n  public void writeNumDecreasing(UnsignedInteger unsignedInt) {\n    writeNumDecreasing(unsignedInt.longValue());\n  }\n\n  /** Return floor(log2(n)) for positive integer n. Returns -1 iff n == 0. */\n  @VisibleForTesting\n  int log2Floor(long n) {\n    checkArgument(n >= 0);\n    return n == 0 ? -1 : LongMath.log2(n, RoundingMode.FLOOR);\n  }\n\n  /** Calculates the encoding length in bytes of the signed number n. */\n  @VisibleForTesting\n  int getSignedEncodingLength(long n) {\n    return BITS_TO_LENGTH[log2Floor(n < 0 ? ~n : n) + 1];\n  }\n\n  /** @see #readSignedNumIncreasing() */\n  public void writeSignedNumIncreasing(long val) {\n    long x = val < 0 ? ~val : val;\n    if (x < 64) { // Fast path for encoding length == 1.\n      byte[] encodedArray = new byte[] {(byte) (LENGTH_TO_HEADER_BITS[1][0] ^ val)};\n      encodedArrays.add(encodedArray);\n      return;\n    }\n    // buf = val in network byte order, sign extended to 10 bytes.\n    byte signByte = val < 0 ? (byte) 0xff : 0;\n    byte[] buf = new byte[2 + Longs.BYTES];\n    buf[0] = buf[1] = signByte;\n    System.arraycopy(Longs.toByteArray(val), 0, buf, 2, Longs.BYTES);\n    int len = getSignedEncodingLength(x);\n    if (len < 2) {\n      throw new IllegalStateException(\n          \"Invalid length (\" + len + \")\" + \" returned by getSignedEncodingLength(\" + x + \")\");\n    }\n    int beginIndex = buf.length - len;\n    buf[beginIndex] ^= LENGTH_TO_HEADER_BITS[len][0];\n    buf[beginIndex + 1] ^= LENGTH_TO_HEADER_BITS[len][1];\n\n    byte[] encodedArray = new byte[len];\n    System.arraycopy(buf, beginIndex, encodedArray, 0, len);\n    encodedArrays.add(encodedArray);\n  }\n\n  public void writeSignedNumDecreasing(long val) {\n    writeSignedNumIncreasing(~val);\n  }\n\n  /**\n   * Encodes and appends INFINITY item to its internal encoded byte array store.\n   *\n   * @see #readInfinity()\n   */\n  public void writeInfinity() {\n    writeTrailingBytes(INFINITY_ENCODED);\n  }\n\n  /**\n   * Encodes and appends INFINITY item which would come before any real string.\n   *\n   * @see #readInfinityDecreasing()\n   */\n  public void writeInfinityDecreasing() {\n    writeTrailingBytes(INFINITY_ENCODED_DECREASING);\n  }\n\n  /**\n   * Appends the byte array item to its internal encoded byte array store. This is used for the last\n   * item and is not encoded.\n   *\n   * <p>It stores the input array in the store, so the input array 'value' should not be modified.\n   *\n   * @param value bytes to be written.\n   * @see #readTrailingBytes()\n   */\n  public void writeTrailingBytes(byte[] value) {\n    if ((value == null) || (value.length == 0)) {\n      throw new IllegalArgumentException(\"Value cannot be null or have 0 elements\");\n    }\n\n    encodedArrays.add(value);\n  }\n\n  /**\n   * Returns the next byte array item from its encoded byte array store and removes the item from\n   * the store.\n   *\n   * @see #writeBytes(byte[])\n   */\n  public byte[] readBytes() {\n    return readBytes(false);\n  }\n\n  public byte[] readBytesDecreasing() {\n    return readBytes(true);\n  }\n\n  private byte[] readBytes(boolean invert) {\n    if (encodedArrays.isEmpty() || ((encodedArrays.get(0)).length - firstArrayPosition <= 0)) {\n      throw new IllegalArgumentException(\"Invalid encoded byte array\");\n    }\n\n    // Determine the length of the decoded array\n    // We only scan up to \"length-2\" since a valid string must end with\n    // a two character terminator: 'ESCAPE1 SEPARATOR'\n    byte[] store = encodedArrays.get(0);\n    int decodedLength = 0;\n    boolean valid = false;\n    int i = firstArrayPosition;\n    while (i < store.length - 1) {\n      byte b = store[i++];\n      if (b == convert(invert, ESCAPE1)) {\n        b = store[i++];\n        if (b == convert(invert, SEPARATOR)) {\n          valid = true;\n          break;\n        } else if (b == convert(invert, NULL_CHARACTER)) {\n          decodedLength++;\n        } else {\n          throw new IllegalArgumentException(\"Invalid encoded byte array\");\n        }\n      } else if (b == convert(invert, ESCAPE2)) {\n        b = store[i++];\n        if (b == convert(invert, FF_CHARACTER)) {\n          decodedLength++;\n        } else {\n          throw new IllegalArgumentException(\"Invalid encoded byte array\");\n        }\n      } else {\n        decodedLength++;\n      }\n    }\n    if (!valid) {\n      throw new IllegalArgumentException(\"Invalid encoded byte array\");\n    }\n\n    byte[] decodedArray = new byte[decodedLength];\n    int copyStart = firstArrayPosition;\n    int outIndex = 0;\n    int j = firstArrayPosition;\n    while (j < store.length - 1) {\n      byte b = store[j++]; // note that j has been incremented\n      if (b == convert(invert, ESCAPE1)) {\n        arraycopy(invert, store, copyStart, decodedArray, outIndex, j - copyStart - 1);\n        outIndex += j - copyStart - 1;\n        // ESCAPE1 SEPARATOR ends component\n        // ESCAPE1 NULL_CHARACTER represents '\\0'\n        b = store[j++];\n        if (b == convert(invert, SEPARATOR)) {\n          if ((store.length - j) == 0) {\n            // we are done with the first array\n            encodedArrays.remove(0);\n            firstArrayPosition = 0;\n          } else {\n            firstArrayPosition = j;\n          }\n          return decodedArray;\n        } else if (b == convert(invert, NULL_CHARACTER)) {\n          decodedArray[outIndex++] = 0x00;\n        } // else not required - handled during length determination\n        copyStart = j;\n      } else if (b == convert(invert, ESCAPE2)) {\n        arraycopy(invert, store, copyStart, decodedArray, outIndex, j - copyStart - 1);\n        outIndex += j - copyStart - 1;\n        // ESCAPE2 FF_CHARACTER represents '\\xff'\n        // ESCAPE2 INFINITY is an error\n        b = store[j++];\n        if (b == convert(invert, FF_CHARACTER)) {\n          decodedArray[outIndex++] = (byte) 0xff;\n        } // else not required - handled during length determination\n        copyStart = j;\n      }\n    }\n    // not required due to the first phase, but need to entertain the compiler\n    throw new IllegalArgumentException(\"Invalid encoded byte array\");\n  }\n\n  /**\n   * Returns the next long item (encoded in big-endian format via {@code writeNumIncreasing(long)})\n   * from its internal encoded byte array store and removes the item from the store.\n   *\n   * @see #writeNumIncreasing(long)\n   */\n  public long readNumIncreasing() {\n    if (encodedArrays.isEmpty() || ((encodedArrays.get(0)).length - firstArrayPosition < 1)) {\n      throw new IllegalArgumentException(\"Invalid encoded byte array\");\n    }\n\n    byte[] store = encodedArrays.get(0);\n    // Decode length byte\n    int len = store[firstArrayPosition];\n    if ((firstArrayPosition + len + 1 > store.length) || len > 8) {\n      throw new IllegalArgumentException(\"Invalid encoded byte array\");\n    }\n\n    long result = 0;\n    for (int i = 0; i < len; i++) {\n      result <<= 8;\n      result |= (store[firstArrayPosition + i + 1] & 0xff);\n    }\n\n    if ((store.length - firstArrayPosition - len - 1) == 0) {\n      // we are done with the first array\n      encodedArrays.remove(0);\n      firstArrayPosition = 0;\n    } else {\n      firstArrayPosition = firstArrayPosition + len + 1;\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns the next long item (encoded in big-endian format via {@code writeNumDecreasing(long)})\n   * from its internal encoded byte array store and removes the item from the store.\n   *\n   * @see #writeNumDecreasing(long)\n   */\n  public long readNumDecreasing() {\n    if (encodedArrays.isEmpty() || ((encodedArrays.get(0)).length - firstArrayPosition < 1)) {\n      throw new IllegalArgumentException(\"Invalid encoded byte array\");\n    }\n\n    byte[] store = encodedArrays.get(0);\n    // Decode length byte\n    int len = ~store[firstArrayPosition] & 0xff;\n    if ((firstArrayPosition + len + 1 > store.length) || len > 8) {\n      throw new IllegalArgumentException(\"Invalid encoded byte array\");\n    }\n\n    long result = 0;\n    for (int i = 0; i < len; i++) {\n      result <<= 8;\n      result |= (~store[firstArrayPosition + i + 1] & 0xff);\n    }\n\n    if ((store.length - firstArrayPosition - len - 1) == 0) {\n      // we are done with the first array\n      encodedArrays.remove(0);\n      firstArrayPosition = 0;\n    } else {\n      firstArrayPosition = firstArrayPosition + len + 1;\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns the next long item (encoded via {@code writeSignedNumIncreasing(long)}) from its\n   * internal encoded byte array store and removes the item from the store.\n   *\n   * @see #writeSignedNumIncreasing(long)\n   */\n  public long readSignedNumIncreasing() {\n    if (encodedArrays.isEmpty() || ((encodedArrays.get(0)).length - firstArrayPosition < 1)) {\n      throw new IllegalArgumentException(\"Invalid encoded byte array\");\n    }\n\n    byte[] store = encodedArrays.get(0);\n\n    long xorMask = ((store[firstArrayPosition] & 0x80) == 0) ? ~0L : 0L;\n    // Store first byte as an int rather than a (signed) byte -- to avoid\n    // accidental byte-to-int promotion later which would extend the byte's\n    // sign bit (if any).\n    int firstByte = (store[firstArrayPosition] & 0xff) ^ (int) (xorMask & 0xff);\n\n    // Now calculate and test length, and set x to raw (unmasked) result.\n    int len;\n    long x;\n    if (firstByte != 0xff) {\n      len = 7 - log2Floor(firstByte ^ 0xff);\n      if (store.length - firstArrayPosition < len) {\n        throw new IllegalArgumentException(\"Invalid encoded byte array\");\n      }\n      x = xorMask; // Sign extend using xorMask.\n      for (int i = firstArrayPosition; i < firstArrayPosition + len; i++) {\n        x = (x << 8) | (store[i] & 0xff);\n      }\n    } else {\n      len = 8;\n      if (store.length - firstArrayPosition < len) {\n        throw new IllegalArgumentException(\"Invalid encoded byte array\");\n      }\n      int secondByte = (store[firstArrayPosition + 1] & 0xff) ^ (int) (xorMask & 0xff);\n      if (secondByte >= 0x80) {\n        if (secondByte < 0xc0) {\n          len = 9;\n        } else {\n          int thirdByte = (store[firstArrayPosition + 2] & 0xff) ^ (int) (xorMask & 0xff);\n          if (secondByte == 0xc0 && thirdByte < 0x80) {\n            len = 10;\n          } else {\n            // Either len > 10 or len == 10 and #bits > 63.\n            throw new IllegalArgumentException(\"Invalid encoded byte array\");\n          }\n        }\n        if (store.length - firstArrayPosition < len) {\n          throw new IllegalArgumentException(\"Invalid encoded byte array\");\n        }\n      }\n      x =\n          Longs.fromByteArray(\n              Arrays.copyOfRange(store, firstArrayPosition + len - 8, firstArrayPosition + len));\n    }\n\n    x ^= LENGTH_TO_MASK[len]; // Remove spurious header bits.\n\n    if (len != getSignedEncodingLength(x)) {\n      throw new IllegalArgumentException(\"Invalid encoded byte array\");\n    }\n\n    if ((store.length - firstArrayPosition - len) == 0) {\n      // We are done with the first array.\n      encodedArrays.remove(0);\n      firstArrayPosition = 0;\n    } else {\n      firstArrayPosition = firstArrayPosition + len;\n    }\n\n    return x;\n  }\n\n  public long readSignedNumDecreasing() {\n    return ~readSignedNumIncreasing();\n  }\n\n  /**\n   * Removes INFINITY item from its internal encoded byte array store if present. Returns whether\n   * INFINITY was present.\n   *\n   * @see #writeInfinity()\n   */\n  public boolean readInfinity() {\n    return readInfinityInternal(INFINITY_ENCODED);\n  }\n\n  /**\n   * Removes INFINITY item from its internal encoded byte array store if present. Returns whether\n   * INFINITY was present.\n   *\n   * @see #writeInfinityDecreasing()\n   */\n  public boolean readInfinityDecreasing() {\n    return readInfinityInternal(INFINITY_ENCODED_DECREASING);\n  }\n\n  private boolean readInfinityInternal(byte[] codes) {\n    if (encodedArrays.isEmpty() || ((encodedArrays.get(0)).length - firstArrayPosition < 1)) {\n      throw new IllegalArgumentException(\"Invalid encoded byte array\");\n    }\n    byte[] store = encodedArrays.get(0);\n    if (store.length - firstArrayPosition < 2) {\n      return false;\n    }\n    if ((store[firstArrayPosition] == codes[0]) && (store[firstArrayPosition + 1] == codes[1])) {\n      if ((store.length - firstArrayPosition - 2) == 0) {\n        // we are done with the first array\n        encodedArrays.remove(0);\n        firstArrayPosition = 0;\n      } else {\n        firstArrayPosition = firstArrayPosition + 2;\n      }\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Returns the trailing byte array item from its internal encoded byte array store and removes the\n   * item from the store.\n   *\n   * @see #writeTrailingBytes(byte[])\n   */\n  public byte[] readTrailingBytes() {\n    // one item is contained within one byte array\n    if (encodedArrays.size() != 1) {\n      throw new IllegalArgumentException(\"Invalid encoded byte array\");\n    }\n\n    byte[] store = encodedArrays.get(0);\n    encodedArrays.remove(0);\n    assert encodedArrays.isEmpty();\n    return Arrays.copyOfRange(store, firstArrayPosition, store.length);\n  }\n\n  /**\n   * Returns the encoded bytes that represents the current state of the OrderedCode.\n   *\n   * <p><b> NOTE: This method returns OrederedCode's internal array (not a copy) for better\n   * performance. Therefore the returned array should not be modified.</b>\n   */\n  public byte[] getEncodedBytes() {\n    if (encodedArrays.isEmpty()) {\n      return new byte[0];\n    }\n    if ((encodedArrays.size() == 1) && (firstArrayPosition == 0)) {\n      return encodedArrays.get(0);\n    }\n\n    int totalLength = 0;\n\n    for (int i = 0; i < encodedArrays.size(); i++) {\n      byte[] bytes = encodedArrays.get(i);\n      if (i == 0) {\n        totalLength += bytes.length - firstArrayPosition;\n      } else {\n        totalLength += bytes.length;\n      }\n    }\n\n    byte[] encodedBytes = new byte[totalLength];\n    int destPos = 0;\n    for (int i = 0; i < encodedArrays.size(); i++) {\n      byte[] bytes = encodedArrays.get(i);\n      if (i == 0) {\n        System.arraycopy(\n            bytes, firstArrayPosition, encodedBytes, destPos, bytes.length - firstArrayPosition);\n        destPos += bytes.length - firstArrayPosition;\n      } else {\n        System.arraycopy(bytes, 0, encodedBytes, destPos, bytes.length);\n        destPos += bytes.length;\n      }\n    }\n\n    // replace the store with merged array, so that repeated calls\n    // don't need to merge. The reads can handle both the versions.\n    encodedArrays.clear();\n    encodedArrays.add(encodedBytes);\n    firstArrayPosition = 0;\n\n    return encodedBytes;\n  }\n\n  /**\n   * Returns true if it has more encoded bytes that haven't been read, false otherwise. Return value\n   * of true doesn't imply anything about validity of remaining data.\n   *\n   * @return true if it has more encoded bytes that haven't been read, false otherwise.\n   */\n  public boolean hasRemainingEncodedBytes() {\n    // We delete an array after fully consuming it.\n    return encodedArrays.size() != 0;\n  }\n}", "class_id": 0, "repo": "a-satyateja/beam", "file": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/spanner/OrderedCode.java", "last_update_at": "2020-07-13T23:52:12+00:00", "question_id": "ee94ed59650d7bdb1cb15c5247d1e3990690ce94", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class OrderedCode {\n  // We want to encode a few extra symbols in strings:\n  //      <sep>           Separator between items\n  //      <infinity>      Infinite string\n  //\n  // Therefore we need an alphabet with at least 258 characters.  We\n  // achieve this by using two-letter sequences starting with '\\0' and '\\xff'\n  // as extra symbols:\n  //      <sep>           encoded as =>           \\0\\1\n  //      \\0              encoded as =>           \\0\\xff\n  //      \\xff            encoded as =>           \\xff\\x00\n  //      <infinity>      encoded as =>           \\xff\\xff\n  //\n  // The remaining two letter sequences starting with '\\0' and '\\xff'\n  // are currently unused.\n  static final byte ESCAPE1 = 0x00;\n  static final byte NULL_CHARACTER = (byte) 0xff; // Combined with ESCAPE1\n  static final byte SEPARATOR = 0x01; // Combined with ESCAPE1\n  static final byte ESCAPE2 = (byte) 0xff;\n  static final byte INFINITY = (byte) 0xff; // Combined with ESCAPE2\n  static final byte FF_CHARACTER = 0x00; // Combined with ESCAPE2\n  static final byte[] ESCAPE1_SEPARATOR = {ESCAPE1, SEPARATOR};\n  static final byte[] INFINITY_ENCODED = {ESCAPE2, INFINITY};\n  static final byte[] INFINITY_ENCODED_DECREASING = {invert(ESCAPE2), invert(INFINITY)};\n  /**\n   * This array maps encoding length to header bits in the first two bytes for SignedNumIncreasing\n   * encoding.\n   */\n  private static final byte[][] LENGTH_TO_HEADER_BITS = {\n    {0, 0},\n    {(byte) 0x80, 0},\n    {(byte) 0xc0, 0},\n    {(byte) 0xe0, 0},\n    {(byte) 0xf0, 0},\n    {(byte) 0xf8, 0},\n    {(byte) 0xfc, 0},\n    {(byte) 0xfe, 0},\n    {(byte) 0xff, 0},\n    {(byte) 0xff, (byte) 0x80},\n    {(byte) 0xff, (byte) 0xc0}\n  };\n  /**\n   * This array maps encoding lengths to the header bits that overlap with the payload and need\n   * fixing during readSignedNumIncreasing.\n   */\n  private static final long[] LENGTH_TO_MASK = {\n    0L,\n    0x80L,\n    0xc000L,\n    0xe00000L,\n    0xf0000000L,\n    0xf800000000L,\n    0xfc0000000000L,\n    0xfe000000000000L,\n    0xff00000000000000L,\n    0x8000000000000000L,\n    0L\n  };\n  /**\n   * This array maps the number of bits in a number to the encoding length produced by\n   * WriteSignedNumIncreasing. For positive numbers, the number of bits is 1 plus the most\n   * significant bit position (the highest bit position in a positive long is 63). For a negative\n   * number n, we count the bits in ~n. That is, length = BITS_TO_LENGTH[log2Floor(n < 0 ? ~n : n) +\n   * 1].\n   */\n  private static final short[] BITS_TO_LENGTH = {\n    1, 1, 1, 1, 1, 1, 1,\n    2, 2, 2, 2, 2, 2, 2,\n    3, 3, 3, 3, 3, 3, 3,\n    4, 4, 4, 4, 4, 4, 4,\n    5, 5, 5, 5, 5, 5, 5,\n    6, 6, 6, 6, 6, 6, 6,\n    7, 7, 7, 7, 7, 7, 7,\n    8, 8, 8, 8, 8, 8, 8,\n    9, 9, 9, 9, 9, 9, 9,\n    10\n  };\n  // stores the current encoded value as a list of byte arrays. Note that this\n  // is manipulated as we read/write items.\n  // Note that every item will fit on at most one array. One array may\n  // have more than one item (eg when used for decoding). While encoding,\n  // one array will have exactly one item. While returning the encoded array\n  // we will merge all the arrays in this list.\n  private final ArrayList<byte[]> encodedArrays = new ArrayList<>();\n  // This is the current position on the first array. Will be non-zero\n  // only if the ordered code was created using encoded byte array.\n  private int firstArrayPosition = 0;\n  /** Creates OrderedCode from scratch. Typically used at encoding time. */\n  public OrderedCode() {}\n  /**\n   * Creates OrderedCode from a given encoded byte array. Typically used at decoding time.\n   *\n   * <p><b> For better performance, it uses the input array provided (not a copy). Therefore the\n   * input array should not be modified.</b>\n   */\n  public OrderedCode(byte[] encodedByteArray) {\n    encodedArrays.add(encodedByteArray);\n  }\n  /**\n   * Adds the given byte array item to the OrderedCode. It encodes the input byte array, followed by\n   * a separator and appends the result to its internal encoded byte array store.\n   *\n   * <p>It works with the input array, so the input array 'value' should not be modified till the\n   * method returns.\n   *\n   * @param value bytes to be written.\n   * @see #readBytes()\n   */\n  public void writeBytes(byte[] value) {\n    writeBytes(value, false);\n  }\n  public void writeBytesDecreasing(byte[] value) {\n    writeBytes(value, true);\n  }\n  private void writeBytes(byte[] value, boolean invert) {\n    // Determine the length of the encoded array\n    int encodedLength = 2; // for separator\n    for (byte b : value) {\n      if ((b == ESCAPE1) || (b == ESCAPE2)) {\n        encodedLength += 2;\n      } else {\n        encodedLength++;\n      }\n    }\n    byte[] encodedArray = new byte[encodedLength];\n    int copyStart = 0;\n    int outIndex = 0;\n    for (int i = 0; i < value.length; i++) {\n      byte b = value[i];\n      if (b == ESCAPE1) {\n        arraycopy(invert, value, copyStart, encodedArray, outIndex, i - copyStart);\n        outIndex += i - copyStart;\n        encodedArray[outIndex++] = convert(invert, ESCAPE1);\n        encodedArray[outIndex++] = convert(invert, NULL_CHARACTER);\n        copyStart = i + 1;\n      } else if (b == ESCAPE2) {\n        arraycopy(invert, value, copyStart, encodedArray, outIndex, i - copyStart);\n        outIndex += i - copyStart;\n        encodedArray[outIndex++] = convert(invert, ESCAPE2);\n        encodedArray[outIndex++] = convert(invert, FF_CHARACTER);\n        copyStart = i + 1;\n      }\n    }\n    if (copyStart < value.length) {\n      arraycopy(invert, value, copyStart, encodedArray, outIndex, value.length - copyStart);\n      outIndex += value.length - copyStart;\n    }\n    encodedArray[outIndex++] = convert(invert, ESCAPE1);\n    encodedArray[outIndex] = convert(invert, SEPARATOR);\n    encodedArrays.add(encodedArray);\n  }\n  private static byte convert(boolean invert, byte val) {\n    return invert ? (byte) ~val : val;\n  }\n  private static byte invert(byte val) {\n    return convert(true, val);\n  }\n  private void arraycopy(\n      boolean invert, byte[] src, int srcPos, byte[] dest, int destPos, int length) {\n    System.arraycopy(src, srcPos, dest, destPos, length);\n    if (invert) {\n      for (int i = destPos; i < destPos + length; i++) {\n        dest[i] = (byte) ~dest[i];\n      }\n    }\n  }\n  /**\n   * Encodes the long item, in big-endian format, and appends the result to its internal encoded\n   * byte array store.\n   *\n   * @see #readNumIncreasing()\n   */\n  public void writeNumIncreasing(long value) {\n    // Values are encoded with a single byte length prefix, followed\n    // by the actual value in big-endian format with leading 0 bytes\n    // dropped.\n    byte[] bufer = new byte[9]; // 8 bytes for value plus one byte for length\n    int len = 0;\n    while (value != 0) {\n      len++;\n      bufer[9 - len] = (byte) (value & 0xff);\n      value >>>= 8;\n    }\n    bufer[9 - len - 1] = (byte) len;\n    len++;\n    byte[] encodedArray = new byte[len];\n    System.arraycopy(bufer, 9 - len, encodedArray, 0, len);\n    encodedArrays.add(encodedArray);\n  }\n  public void writeNumIncreasing(UnsignedInteger unsignedInt) {\n    writeNumIncreasing(unsignedInt.longValue());\n  }\n  /**\n   * Encodes the long item, in big-endian format, and appends the result to its internal encoded\n   * byte array store.\n   *\n   * @see #readNumIncreasing()\n   */\n  public void writeNumDecreasing(long value) {\n    // Values are encoded with a complemented single byte length prefix,\n    // followed by the complement of the actual value in big-endian format with\n    // leading 0xff bytes dropped.\n    byte[] bufer = new byte[9]; // 8 bytes for value plus one byte for length\n    int len = 0;\n    while (value != 0) {\n      len++;\n      bufer[9 - len] = (byte) ~(value & 0xff);\n      value >>>= 8;\n    }\n    bufer[9 - len - 1] = (byte) ~len;\n    len++;\n    byte[] encodedArray = new byte[len];\n    System.arraycopy(bufer, 9 - len, encodedArray, 0, len);\n    encodedArrays.add(encodedArray);\n  }\n  public void writeNumDecreasing(UnsignedInteger unsignedInt) {\n    writeNumDecreasing(unsignedInt.longValue());\n  }\n  /** Return floor(log2(n)) for positive integer n. Returns -1 iff n == 0. */\n  @VisibleForTesting\n  int log2Floor(long n) {\n    checkArgument(n >= 0);\n    return n == 0 ? -1 : LongMath.log2(n, RoundingMode.FLOOR);\n  }\n  /** Calculates the encoding length in bytes of the signed number n. */\n  @VisibleForTesting\n  int getSignedEncodingLength(long n) {\n    return BITS_TO_LENGTH[log2Floor(n < 0 ? ~n : n) + 1];\n  }\n  /** @see #readSignedNumIncreasing() */\n  public void writeSignedNumIncreasing(long val) {\n    long x = val < 0 ? ~val : val;\n    if (x < 64) { // Fast path for encoding length == 1.\n      byte[] encodedArray = new byte[] {(byte) (LENGTH_TO_HEADER_BITS[1][0] ^ val)};\n      encodedArrays.add(encodedArray);\n      return;\n    }\n    // buf = val in network byte order, sign extended to 10 bytes.\n    byte signByte = val < 0 ? (byte) 0xff : 0;\n    byte[] buf = new byte[2 + Longs.BYTES];\n    buf[0] = buf[1] = signByte;\n    System.arraycopy(Longs.toByteArray(val), 0, buf, 2, Longs.BYTES);\n    int len = getSignedEncodingLength(x);\n    if (len < 2) {\n      throw new IllegalStateException(\n          \"Invalid length (\" + len + \")\" + \" returned by getSignedEncodingLength(\" + x + \")\");\n    }\n    int beginIndex = buf.length - len;\n    buf[beginIndex] ^= LENGTH_TO_HEADER_BITS[len][0];\n    buf[beginIndex + 1] ^= LENGTH_TO_HEADER_BITS[len][1];\n    byte[] encodedArray = new byte[len];\n    System.arraycopy(buf, beginIndex, encodedArray, 0, len);\n    encodedArrays.add(encodedArray);\n  }\n  public void writeSignedNumDecreasing(long val) {\n    writeSignedNumIncreasing(~val);\n  }\n  /**\n   * Encodes and appends INFINITY item to its internal encoded byte array store.\n   *\n   * @see #readInfinity()\n   */\n  public void writeInfinity() {\n    writeTrailingBytes(INFINITY_ENCODED);\n  }\n  /**\n   * Encodes and appends INFINITY item which would come before any real string.\n   *\n   * @see #readInfinityDecreasing()\n   */\n  public void writeInfinityDecreasing() {\n    writeTrailingBytes(INFINITY_ENCODED_DECREASING);\n  }\n  /**\n   * Appends the byte array item to its internal encoded byte array store. This is used for the last\n   * item and is not encoded.\n   *\n   * <p>It stores the input array in the store, so the input array 'value' should not be modified.\n   *\n   * @param value bytes to be written.\n   * @see #readTrailingBytes()\n   */\n  public void writeTrailingBytes(byte[] value) {\n    if ((value == null) || (value.length == 0)) {\n      throw new IllegalArgumentException(\"Value cannot be null or have 0 elements\");\n    }\n    encodedArrays.add(value);\n  }\n  /**\n   * Returns the next byte array item from its encoded byte array store and removes the item from\n   * the store.\n   *\n   * @see #writeBytes(byte[])\n   */\n  public byte[] readBytes() {\n    return readBytes(false);\n  }\n  public byte[] readBytesDecreasing() {\n    return readBytes(true);\n  }\n  private byte[] readBytes(boolean invert) {\n    if (encodedArrays.isEmpty() || ((encodedArrays.get(0)).length - firstArrayPosition <= 0)) {\n      throw new IllegalArgumentException(\"Invalid encoded byte array\");\n    }\n    // Determine the length of the decoded array\n    // We only scan up to \"length-2\" since a valid string must end with\n    // a two character terminator: 'ESCAPE1 SEPARATOR'\n    byte[] store = encodedArrays.get(0);\n    int decodedLength = 0;\n    boolean valid = false;\n    int i = firstArrayPosition;\n    while (i < store.length - 1) {\n      byte b = store[i++];\n      if (b == convert(invert, ESCAPE1)) {\n        b = store[i++];\n        if (b == convert(invert, SEPARATOR)) {\n          valid = true;\n          break;\n        } else if (b == convert(invert, NULL_CHARACTER)) {\n          decodedLength++;\n        } else {\n          throw new IllegalArgumentException(\"Invalid encoded byte array\");\n        }\n      } else if (b == convert(invert, ESCAPE2)) {\n        b = store[i++];\n        if (b == convert(invert, FF_CHARACTER)) {\n          decodedLength++;\n        } else {\n          throw new IllegalArgumentException(\"Invalid encoded byte array\");\n        }\n      } else {\n        decodedLength++;\n      }\n    }\n    if (!valid) {\n      throw new IllegalArgumentException(\"Invalid encoded byte array\");\n    }\n    byte[] decodedArray = new byte[decodedLength];\n    int copyStart = firstArrayPosition;\n    int outIndex = 0;\n    int j = firstArrayPosition;\n    while (j < store.length - 1) {\n      byte b = store[j++]; // note that j has been incremented\n      if (b == convert(invert, ESCAPE1)) {\n        arraycopy(invert, store, copyStart, decodedArray, outIndex, j - copyStart - 1);\n        outIndex += j - copyStart - 1;\n        // ESCAPE1 SEPARATOR ends component\n        // ESCAPE1 NULL_CHARACTER represents '\\0'\n        b = store[j++];\n        if (b == convert(invert, SEPARATOR)) {\n          if ((store.length - j) == 0) {\n            // we are done with the first array\n            encodedArrays.remove(0);\n            firstArrayPosition = 0;\n          } else {\n            firstArrayPosition = j;\n          }\n          return decodedArray;\n        } else if (b == convert(invert, NULL_CHARACTER)) {\n          decodedArray[outIndex++] = 0x00;\n        } // else not required - handled during length determination\n        copyStart = j;\n      } else if (b == convert(invert, ESCAPE2)) {\n        arraycopy(invert, store, copyStart, decodedArray, outIndex, j - copyStart - 1);\n        outIndex += j - copyStart - 1;\n        // ESCAPE2 FF_CHARACTER represents '\\xff'\n        // ESCAPE2 INFINITY is an error\n        b = store[j++];\n        if (b == convert(invert, FF_CHARACTER)) {\n          decodedArray[outIndex++] = (byte) 0xff;\n        } // else not required - handled during length determination\n        copyStart = j;\n      }\n    }\n    // not required due to the first phase, but need to entertain the compiler\n    throw new IllegalArgumentException(\"Invalid encoded byte array\");\n  }\n  /**\n   * Returns the next long item (encoded in big-endian format via {@code writeNumIncreasing(long)})\n   * from its internal encoded byte array store and removes the item from the store.\n   *\n   * @see #writeNumIncreasing(long)\n   */\n  public long readNumIncreasing() {\n    if (encodedArrays.isEmpty() || ((encodedArrays.get(0)).length - firstArrayPosition < 1)) {\n      throw new IllegalArgumentException(\"Invalid encoded byte array\");\n    }\n    byte[] store = encodedArrays.get(0);\n    // Decode length byte\n    int len = store[firstArrayPosition];\n    if ((firstArrayPosition + len + 1 > store.length) || len > 8) {\n      throw new IllegalArgumentException(\"Invalid encoded byte array\");\n    }\n    long result = 0;\n    for (int i = 0; i < len; i++) {\n      result <<= 8;\n      result |= (store[firstArrayPosition + i + 1] & 0xff);\n    }\n    if ((store.length - firstArrayPosition - len - 1) == 0) {\n      // we are done with the first array\n      encodedArrays.remove(0);\n      firstArrayPosition = 0;\n    } else {\n      firstArrayPosition = firstArrayPosition + len + 1;\n    }\n    return result;\n  }\n  /**\n   * Returns the next long item (encoded in big-endian format via {@code writeNumDecreasing(long)})\n   * from its internal encoded byte array store and removes the item from the store.\n   *\n   * @see #writeNumDecreasing(long)\n   */\n  public long readNumDecreasing() {\n    if (encodedArrays.isEmpty() || ((encodedArrays.get(0)).length - firstArrayPosition < 1)) {\n      throw new IllegalArgumentException(\"Invalid encoded byte array\");\n    }\n    byte[] store = encodedArrays.get(0);\n    // Decode length byte\n    int len = ~store[firstArrayPosition] & 0xff;\n    if ((firstArrayPosition + len + 1 > store.length) || len > 8) {\n      throw new IllegalArgumentException(\"Invalid encoded byte array\");\n    }\n    long result = 0;\n    for (int i = 0; i < len; i++) {\n      result <<= 8;\n      result |= (~store[firstArrayPosition + i + 1] & 0xff);\n    }\n    if ((store.length - firstArrayPosition - len - 1) == 0) {\n      // we are done with the first array\n      encodedArrays.remove(0);\n      firstArrayPosition = 0;\n    } else {\n      firstArrayPosition = firstArrayPosition + len + 1;\n    }\n    return result;\n  }\n  /**\n   * Returns the next long item (encoded via {@code writeSignedNumIncreasing(long)}) from its\n   * internal encoded byte array store and removes the item from the store.\n   *\n   * @see #writeSignedNumIncreasing(long)\n   */\n  public long readSignedNumIncreasing() {\n    if (encodedArrays.isEmpty() || ((encodedArrays.get(0)).length - firstArrayPosition < 1)) {\n      throw new IllegalArgumentException(\"Invalid encoded byte array\");\n    }\n    byte[] store = encodedArrays.get(0);\n    long xorMask = ((store[firstArrayPosition] & 0x80) == 0) ? ~0L : 0L;\n    // Store first byte as an int rather than a (signed) byte -- to avoid\n    // accidental byte-to-int promotion later which would extend the byte's\n    // sign bit (if any).\n    int firstByte = (store[firstArrayPosition] & 0xff) ^ (int) (xorMask & 0xff);\n    // Now calculate and test length, and set x to raw (unmasked) result.\n    int len;\n    long x;\n    if (firstByte != 0xff) {\n      len = 7 - log2Floor(firstByte ^ 0xff);\n      if (store.length - firstArrayPosition < len) {\n        throw new IllegalArgumentException(\"Invalid encoded byte array\");\n      }\n      x = xorMask; // Sign extend using xorMask.\n      for (int i = firstArrayPosition; i < firstArrayPosition + len; i++) {\n        x = (x << 8) | (store[i] & 0xff);\n      }\n    } else {\n      len = 8;\n      if (store.length - firstArrayPosition < len) {\n        throw new IllegalArgumentException(\"Invalid encoded byte array\");\n      }\n      int secondByte = (store[firstArrayPosition + 1] & 0xff) ^ (int) (xorMask & 0xff);\n      if (secondByte >= 0x80) {\n        if (secondByte < 0xc0) {\n          len = 9;\n        } else {\n          int thirdByte = (store[firstArrayPosition + 2] & 0xff) ^ (int) (xorMask & 0xff);\n          if (secondByte == 0xc0 && thirdByte < 0x80) {\n            len = 10;\n          } else {\n            // Either len > 10 or len == 10 and #bits > 63.\n            throw new IllegalArgumentException(\"Invalid encoded byte array\");\n          }\n        }\n        if (store.length - firstArrayPosition < len) {\n          throw new IllegalArgumentException(\"Invalid encoded byte array\");\n        }\n      }\n      x =\n          Longs.fromByteArray(\n              Arrays.copyOfRange(store, firstArrayPosition + len - 8, firstArrayPosition + len));\n    }\n    x ^= LENGTH_TO_MASK[len]; // Remove spurious header bits.\n    if (len != getSignedEncodingLength(x)) {\n      throw new IllegalArgumentException(\"Invalid encoded byte array\");\n    }\n    if ((store.length - firstArrayPosition - len) == 0) {\n      // We are done with the first array.\n      encodedArrays.remove(0);\n      firstArrayPosition = 0;\n    } else {\n      firstArrayPosition = firstArrayPosition + len;\n    }\n    return x;\n  }\n  public long readSignedNumDecreasing() {\n    return ~readSignedNumIncreasing();\n  }\n  /**\n   * Removes INFINITY item from its internal encoded byte array store if present. Returns whether\n   * INFINITY was present.\n   *\n   * @see #writeInfinity()\n   */\n  public boolean readInfinity() {\n    return readInfinityInternal(INFINITY_ENCODED);\n  }\n  /**\n   * Removes INFINITY item from its internal encoded byte array store if present. Returns whether\n   * INFINITY was present.\n   *\n   * @see #writeInfinityDecreasing()\n   */\n  public boolean readInfinityDecreasing() {\n    return readInfinityInternal(INFINITY_ENCODED_DECREASING);\n  }\n  private boolean readInfinityInternal(byte[] codes) {\n    if (encodedArrays.isEmpty() || ((encodedArrays.get(0)).length - firstArrayPosition < 1)) {\n      throw new IllegalArgumentException(\"Invalid encoded byte array\");\n    }\n    byte[] store = encodedArrays.get(0);\n    if (store.length - firstArrayPosition < 2) {\n      return false;\n    }\n    if ((store[firstArrayPosition] == codes[0]) && (store[firstArrayPosition + 1] == codes[1])) {\n      if ((store.length - firstArrayPosition - 2) == 0) {\n        // we are done with the first array\n        encodedArrays.remove(0);\n        firstArrayPosition = 0;\n      } else {\n        firstArrayPosition = firstArrayPosition + 2;\n      }\n      return true;\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Returns the trailing byte array item from its internal encoded byte array store and removes the\n   * item from the store.\n   *\n   * @see #writeTrailingBytes(byte[])\n   */\n  public byte[] readTrailingBytes() {\n    // one item is contained within one byte array\n    if (encodedArrays.size() != 1) {\n      throw new IllegalArgumentException(\"Invalid encoded byte array\");\n    }\n    byte[] store = encodedArrays.get(0);\n    encodedArrays.remove(0);\n    assert encodedArrays.isEmpty();\n    return Arrays.copyOfRange(store, firstArrayPosition, store.length);\n  }\n  /**\n   * Returns the encoded bytes that represents the current state of the OrderedCode.\n   *\n   * <p><b> NOTE: This method returns OrederedCode's internal array (not a copy) for better\n   * performance. Therefore the returned array should not be modified.</b>\n   */\n  public byte[] getEncodedBytes() {\n    if (encodedArrays.isEmpty()) {\n      return new byte[0];\n    }\n    if ((encodedArrays.size() == 1) && (firstArrayPosition == 0)) {\n      return encodedArrays.get(0);\n    }\n    int totalLength = 0;\n    for (int i = 0; i < encodedArrays.size(); i++) {\n      byte[] bytes = encodedArrays.get(i);\n      if (i == 0) {\n        totalLength += bytes.length - firstArrayPosition;\n      } else {\n        totalLength += bytes.length;\n      }\n    }\n    byte[] encodedBytes = new byte[totalLength];\n    int destPos = 0;\n    for (int i = 0; i < encodedArrays.size(); i++) {\n      byte[] bytes = encodedArrays.get(i);\n      if (i == 0) {\n        System.arraycopy(\n            bytes, firstArrayPosition, encodedBytes, destPos, bytes.length - firstArrayPosition);\n        destPos += bytes.length - firstArrayPosition;\n      } else {\n        System.arraycopy(bytes, 0, encodedBytes, destPos, bytes.length);\n        destPos += bytes.length;\n      }\n    }\n    // replace the store with merged array, so that repeated calls\n    // don't need to merge. The reads can handle both the versions.\n    encodedArrays.clear();\n    encodedArrays.add(encodedBytes);\n    firstArrayPosition = 0;\n    return encodedBytes;\n  }\n  /**\n   * Returns true if it has more encoded bytes that haven't been read, false otherwise. Return value\n   * of true doesn't imply anything about validity of remaining data.\n   *\n   * @return true if it has more encoded bytes that haven't been read, false otherwise.\n   */\n  public boolean hasRemainingEncodedBytes() {\n    // We delete an array after fully consuming it.\n    return encodedArrays.size() != 0;\n  }\n"]]}
{"hexsha": "babb512fdaf5f1f2c15a5a8b4cf2fd2069aa0fe1", "ext": "java", "lang": "Java", "content": "public class AllCapitals {\n    public static void main(String[] args) {\n        String inputPathString = \"/home/stoianov/home/Java Advanced/04.Files and Directories/04. Java-Advanced-Files-and-Streams-Exercises-Resources/input.txt\";\n        String outputPathString = \"/home/stoianov/home/Java Advanced/04.Files and Directories/04. Java-Advanced-Files-and-Streams-Exercises-Resources/output.txt\";\n\n        Path inputPath = Paths.get(inputPathString);\n        Path outputPath = Paths.get(outputPathString);\n\n        try (BufferedReader reader = Files.newBufferedReader(inputPath);\n             BufferedWriter writer = Files.newBufferedWriter(outputPath)) {\n            String line = reader.readLine();\n\n            while (line != null) {\n                writer.write(String.format(\"%s%n\", line.toUpperCase()));\n                line = reader.readLine();\n            }\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n}", "class_id": 0, "repo": "stoianov00/Java", "file": "Java Advanced/04.Files and Directories/src/AllCapitals.java", "last_update_at": "2020-01-06T08:41:53+00:00", "question_id": "babb512fdaf5f1f2c15a5a8b4cf2fd2069aa0fe1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AllCapitals {\n    public static void main(String[] args) {\n        String inputPathString = \"/home/stoianov/home/Java Advanced/04.Files and Directories/04. Java-Advanced-Files-and-Streams-Exercises-Resources/input.txt\";\n        String outputPathString = \"/home/stoianov/home/Java Advanced/04.Files and Directories/04. Java-Advanced-Files-and-Streams-Exercises-Resources/output.txt\";\n        Path inputPath = Paths.get(inputPathString);\n        Path outputPath = Paths.get(outputPathString);\n        try (BufferedReader reader = Files.newBufferedReader(inputPath);\n             BufferedWriter writer = Files.newBufferedWriter(outputPath)) {\n            String line = reader.readLine();\n            while (line != null) {\n                writer.write(String.format(\"%s%n\", line.toUpperCase()));\n                line = reader.readLine();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n"]]}
{"hexsha": "93e79422889aa11d4c9cdc1f8b909d253b6d7415", "ext": "java", "lang": "Java", "content": "public class ReflectUtils {\n\n\tprivate static Class<?> androidBase64Class;\n\t\n\tprivate static Class<?> jdkBase64EncoderClass;\n\t\n\tprivate static Class<?> jdkBase64DecoderClass;\n\t\n\tprivate static Object jdkNewEncoder;\n\t\n\tprivate static Object jdkNewDecoder; \n\t\n\tprivate static Map<String, Field> fields = new ConcurrentHashMap<String, Field>();\n\t\n\tstatic{\n\t    try\n        {\n            androidBase64Class = Class.forName(\"android.util.Base64\");\n        }\n        catch (ClassNotFoundException e)\n        {\n        }\n\t    \n        try {\n\t\t\tClass<?> base64 = Class.forName(\"java.util.Base64\");\n\t\t\tjdkNewEncoder = base64.getMethod(\"getEncoder\").invoke(null);\n\t\t\tjdkNewDecoder = base64.getMethod(\"getDecoder\").invoke(null);\n\t\t} catch (Exception e1) {\n\t\t}\n\t    \n\t    try{\n\t        jdkBase64EncoderClass = Class.forName(\"sun.misc.BASE64Encoder\");\n\t    }catch (ClassNotFoundException e) {\n        }\n\t    \n\t    try{\n\t        jdkBase64DecoderClass = Class.forName(\"sun.misc.BASE64Decoder\");\n\t    }catch (ClassNotFoundException e) {\n        }\n\t    \n\t}\n\t\n\tpublic static String toBase64(byte[] data)\n\t{\n\t    if(androidBase64Class != null){\n\t        try{\n\t            Method m = androidBase64Class.getMethod(\"encode\", byte[].class, int.class);\n\t            return new String((byte[])m.invoke(null, data, 2), Charset.defaultCharset());\n\t        }catch (Exception e) {\n\t        \tthrow new ServiceException(e);\n            }\n\t    }\n\t    \n\t    if(jdkNewEncoder != null) {\n\t    \ttry{\n\t            Method m = jdkNewEncoder.getClass().getMethod(\"encode\", byte[].class);\n\t            return new String((byte[])m.invoke(jdkNewEncoder, data), \"UTF-8\").replaceAll(\"\\\\s\", \"\");\n\t        }catch (Exception e) {\n\t        \tthrow new ServiceException(e);\n            }\n\t    }\n\t    \n\t    if(jdkBase64EncoderClass != null){\n\t        try{\n\t            Method m = jdkBase64EncoderClass.getMethod(\"encode\", byte[].class);\n\t            return ((String)m.invoke(jdkBase64EncoderClass.getConstructor().newInstance(), data)).replaceAll(\"\\\\s\", \"\");\n\t        }catch (Exception e) {\n\t        \tthrow new ServiceException(e);\n            }\n\t    }\n\t    \n\t    throw new ServiceException(\"Failed to find a base64 encoder\");\n\t}\n\t\n\tpublic static byte[] fromBase64(String b64Data) throws UnsupportedEncodingException\n\t{\n\t    if(androidBase64Class != null){\n\t        try{\n\t            Method m = androidBase64Class.getMethod(\"decode\", byte[].class, int.class);\n\t            return (byte[])m.invoke(null, b64Data.getBytes(\"UTF-8\"), 2);\n\t        }catch (Exception e) {\n\t        \tthrow new ServiceException(e);\n            }\n\t    }\n\t    \n\t    if(jdkNewDecoder != null) {\n\t    \ttry{\n\t            Method m = jdkNewDecoder.getClass().getMethod(\"decode\", byte[].class);\n\t            return (byte[])m.invoke(jdkNewDecoder, b64Data.getBytes(\"UTF-8\"));\n\t        }catch (Exception e) {\n\t        \tthrow new ServiceException(e);\n            }\n\t    }\n\t    \n\t    if(jdkBase64DecoderClass != null){\n\t        try{\n                Method m = jdkBase64DecoderClass.getMethod(\"decodeBuffer\", String.class);\n                return (byte[])m.invoke(jdkBase64DecoderClass.getConstructor().newInstance(), b64Data);\n            }catch (Exception e) {\n            \tthrow new ServiceException(e);\n            }\n\t    }\n\t    throw new ServiceException(\"Failed to find a base64 decoder\");\n\t}\n\t\n\t\n\tpublic static void setInnerClient(Object obj, ObsClient obsClient) {\n\t\tif(obj != null && obsClient != null) {\n\t\t\tClass<?> clazz = obj.getClass();\n\t\t\tString name = clazz.getName();\n\t\t\tField f = fields.get(name);\n\t\t\ttry {\n\t\t\t\tif(f == null) {\n\t\t\t\t\tf = getFieldFromClass(clazz, \"innerClient\");\n\t\t\t\t\tf.setAccessible(true);\n\t\t\t\t\tfields.put(name, f);\n\t\t\t\t}\n\t\t\t\tf.set(obj, obsClient);\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new ObsException(e.getMessage(), e);\n\t\t\t} \n\t\t}\n\t}\n\n\tprivate static Field getFieldFromClass(Class<?> clazz, String key) {\n\t\tdo {\n\t\t\ttry {\n\t\t\t\treturn clazz.getDeclaredField(key);\n\t\t\t} catch (NoSuchFieldException e) {\n\t\t\t\tclazz = clazz.getSuperclass();\n\t\t\t} \n\t\t}while(clazz != null);\n\t\treturn null;\n\t}\n\t\n}", "class_id": 0, "repo": "chenpan19941104/huaweicloud-sdk-java-obs", "file": "app/src/main/java/com/obs/services/internal/utils/ReflectUtils.java", "last_update_at": "2020-05-27T07:06:22+00:00", "question_id": "93e79422889aa11d4c9cdc1f8b909d253b6d7415", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ReflectUtils {\n\tprivate static Class<?> androidBase64Class;\n\t\n\tprivate static Class<?> jdkBase64EncoderClass;\n\t\n\tprivate static Class<?> jdkBase64DecoderClass;\n\t\n\tprivate static Object jdkNewEncoder;\n\t\n\tprivate static Object jdkNewDecoder; \n\t\n\tprivate static Map<String, Field> fields = new ConcurrentHashMap<String, Field>();\n\t\n\tstatic{\n\t    try\n        {\n            androidBase64Class = Class.forName(\"android.util.Base64\");\n        }\n        catch (ClassNotFoundException e)\n        {\n        }\n\t    \n        try {\n\t\t\tClass<?> base64 = Class.forName(\"java.util.Base64\");\n\t\t\tjdkNewEncoder = base64.getMethod(\"getEncoder\").invoke(null);\n\t\t\tjdkNewDecoder = base64.getMethod(\"getDecoder\").invoke(null);\n\t\t} catch (Exception e1) {\n\t\t}\n\t    \n\t    try{\n\t        jdkBase64EncoderClass = Class.forName(\"sun.misc.BASE64Encoder\");\n\t    }catch (ClassNotFoundException e) {\n        }\n\t    \n\t    try{\n\t        jdkBase64DecoderClass = Class.forName(\"sun.misc.BASE64Decoder\");\n\t    }catch (ClassNotFoundException e) {\n        }\n\t    \n\t}\n\t\n\tpublic static String toBase64(byte[] data)\n\t{\n\t    if(androidBase64Class != null){\n\t        try{\n\t            Method m = androidBase64Class.getMethod(\"encode\", byte[].class, int.class);\n\t            return new String((byte[])m.invoke(null, data, 2), Charset.defaultCharset());\n\t        }catch (Exception e) {\n\t        \tthrow new ServiceException(e);\n            }\n\t    }\n\t    \n\t    if(jdkNewEncoder != null) {\n\t    \ttry{\n\t            Method m = jdkNewEncoder.getClass().getMethod(\"encode\", byte[].class);\n\t            return new String((byte[])m.invoke(jdkNewEncoder, data), \"UTF-8\").replaceAll(\"\\\\s\", \"\");\n\t        }catch (Exception e) {\n\t        \tthrow new ServiceException(e);\n            }\n\t    }\n\t    \n\t    if(jdkBase64EncoderClass != null){\n\t        try{\n\t            Method m = jdkBase64EncoderClass.getMethod(\"encode\", byte[].class);\n\t            return ((String)m.invoke(jdkBase64EncoderClass.getConstructor().newInstance(), data)).replaceAll(\"\\\\s\", \"\");\n\t        }catch (Exception e) {\n\t        \tthrow new ServiceException(e);\n            }\n\t    }\n\t    \n\t    throw new ServiceException(\"Failed to find a base64 encoder\");\n\t}\n\t\n\tpublic static byte[] fromBase64(String b64Data) throws UnsupportedEncodingException\n\t{\n\t    if(androidBase64Class != null){\n\t        try{\n\t            Method m = androidBase64Class.getMethod(\"decode\", byte[].class, int.class);\n\t            return (byte[])m.invoke(null, b64Data.getBytes(\"UTF-8\"), 2);\n\t        }catch (Exception e) {\n\t        \tthrow new ServiceException(e);\n            }\n\t    }\n\t    \n\t    if(jdkNewDecoder != null) {\n\t    \ttry{\n\t            Method m = jdkNewDecoder.getClass().getMethod(\"decode\", byte[].class);\n\t            return (byte[])m.invoke(jdkNewDecoder, b64Data.getBytes(\"UTF-8\"));\n\t        }catch (Exception e) {\n\t        \tthrow new ServiceException(e);\n            }\n\t    }\n\t    \n\t    if(jdkBase64DecoderClass != null){\n\t        try{\n                Method m = jdkBase64DecoderClass.getMethod(\"decodeBuffer\", String.class);\n                return (byte[])m.invoke(jdkBase64DecoderClass.getConstructor().newInstance(), b64Data);\n            }catch (Exception e) {\n            \tthrow new ServiceException(e);\n            }\n\t    }\n\t    throw new ServiceException(\"Failed to find a base64 decoder\");\n\t}\n\t\n\t\n\tpublic static void setInnerClient(Object obj, ObsClient obsClient) {\n\t\tif(obj != null && obsClient != null) {\n\t\t\tClass<?> clazz = obj.getClass();\n\t\t\tString name = clazz.getName();\n\t\t\tField f = fields.get(name);\n\t\t\ttry {\n\t\t\t\tif(f == null) {\n\t\t\t\t\tf = getFieldFromClass(clazz, \"innerClient\");\n\t\t\t\t\tf.setAccessible(true);\n\t\t\t\t\tfields.put(name, f);\n\t\t\t\t}\n\t\t\t\tf.set(obj, obsClient);\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new ObsException(e.getMessage(), e);\n\t\t\t} \n\t\t}\n\t}\n\tprivate static Field getFieldFromClass(Class<?> clazz, String key) {\n\t\tdo {\n\t\t\ttry {\n\t\t\t\treturn clazz.getDeclaredField(key);\n\t\t\t} catch (NoSuchFieldException e) {\n\t\t\t\tclazz = clazz.getSuperclass();\n\t\t\t} \n\t\t}while(clazz != null);\n\t\treturn null;\n\t}\n\t\n"]]}
