{"hexsha": "8e6ec8b4781105359a31470e02995ef7cb2a492b", "ext": "c", "lang": "C", "content": "static int\nBBox_init(polypaths_planar_overrideBBoxObject *self, PyObject *args)\n{\n    assert(polypaths_planar_overrideBBox_Check(self));\n    if (PyTuple_GET_SIZE(args) != 1) {\n        PyErr_SetString(PyExc_TypeError, \n            \"BoundingBox: wrong number of arguments\");\n        return -1;\n    }\n    return BBox_init_from_points(self, PyTuple_GET_ITEM(args, 0));\n}", "item_id": 1, "repo": "apolcyn/polypaths_planar_override", "file": "lib/polypaths_planar_override/cbox.c", "last_update_at": "2018-10-19T00:14:58+00:00", "question_id": "8e6ec8b4781105359a31470e02995ef7cb2a492b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nBBox_init(polypaths_planar_overrideBBoxObject *self, PyObject *args)\n{\n    assert(polypaths_planar_overrideBBox_Check(self));\n    if (PyTuple_GET_SIZE(args) != 1) {\n        PyErr_SetString(PyExc_TypeError, \n            \"BoundingBox: wrong number of arguments\");\n        return -1;\n    }\n    return BBox_init_from_points(self, PyTuple_GET_ITEM(args, 0));\n"]], "pred": {"ppl": 3.104403018951416, "ppl_lower": 3.684885263442993, "ppl/lowercase_ppl": -1.151319485721879, "ppl/zlib": 0.004779837267815959, "Min_5.0% Prob": 8.94844420750936, "Min_10.0% Prob": 7.048683863419753, "Min_20.0% Prob": 4.862189928690593, "Min_30.0% Prob": 3.6311842024326326, "Min_40.0% Prob": 2.79315939159305, "Min_50.0% Prob": 2.2527605605256906, "Min_60.0% Prob": 1.8980812428082212}}
{"hexsha": "038e918cdf95482a81a8134fbac34db19ce67685", "ext": "c", "lang": "C", "content": "unt camellia_decenc_cbc_pad(uchar *newc, uchar *newiv, CAMELLIA_KEY *cmNEWkey, \n                            uchar *oldc, uchar *oldiv, CAMELLIA_KEY *cmOLDkey)\n{\n\tuchar foo[CM_BLOCKSIZE];\n\tunt Byte, pByte;\n\n\t//\u524d\u56de\u306e\u8a70\u3081\u7269\u3092foo[]\u306b\u304b\u304d\u51fa\u3059\u3002\n\tcamellia_decrypt_cbc(foo, oldc, oldiv, cmOLDkey);\n\tByte = foo[CM_BLOCKSIZE-1] & 0x0f;\n\tpByte = CM_BLOCKSIZE - Byte;\n\n\t//\u65b0\u305f\u306b\u8a70\u3081\u7269\u3092\u7528\u610f\n\tcamellia_padding(&foo[Byte], pByte);\n\tfoo[CM_BLOCKSIZE-1] &= 0x0f;\n\tfoo[CM_BLOCKSIZE-1] |= Byte;\n\tcamellia_encrypt_cbc(newc, foo, newiv, cmNEWkey);\n\n\treturn 1;\n}", "item_id": 11, "repo": "umedoblock/fugou", "file": "omoide/src/camellia/camellia_cbc.c", "last_update_at": "2018-12-05T14:37:59+00:00", "question_id": "038e918cdf95482a81a8134fbac34db19ce67685_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unt camellia_decenc_cbc_pad(uchar *newc, uchar *newiv, CAMELLIA_KEY *cmNEWkey, \n                            uchar *oldc, uchar *oldiv, CAMELLIA_KEY *cmOLDkey)\n{\n\tuchar foo[CM_BLOCKSIZE];\n\tunt Byte, pByte;\n\t//\u524d\u56de\u306e\u8a70\u3081\u7269\u3092foo[]\u306b\u304b\u304d\u51fa\u3059\u3002\n\tcamellia_decrypt_cbc(foo, oldc, oldiv, cmOLDkey);\n\tByte = foo[CM_BLOCKSIZE-1] & 0x0f;\n\tpByte = CM_BLOCKSIZE - Byte;\n\t//\u65b0\u305f\u306b\u8a70\u3081\u7269\u3092\u7528\u610f\n\tcamellia_padding(&foo[Byte], pByte);\n\tfoo[CM_BLOCKSIZE-1] &= 0x0f;\n\tfoo[CM_BLOCKSIZE-1] |= Byte;\n\tcamellia_encrypt_cbc(newc, foo, newiv, cmNEWkey);\n\treturn 1;\n"]], "pred": {"ppl": 3.702561616897583, "ppl_lower": 3.778855800628662, "ppl/lowercase_ppl": -1.0155813357181427, "ppl/zlib": 0.004077959218044638, "Min_5.0% Prob": 9.700291266808144, "Min_10.0% Prob": 7.922248913691594, "Min_20.0% Prob": 5.432781980587886, "Min_30.0% Prob": 4.061668333373492, "Min_40.0% Prob": 3.212261603275935, "Min_50.0% Prob": 2.594854956944332, "Min_60.0% Prob": 2.1804742094223637}}
{"hexsha": "a2f85868afaa0f14a2b41f159db57e10a5cab4f2", "ext": "c", "lang": "C", "content": "void SendDataCPU(void)\n{\n    // Send data to Computer via USB\n    for (kk = 0; kk < 6; kk++)\n    {\n        U1TXREG = varCPU[kk];\n        while(!U1STAbits.TRMT);\n        \n        Nop();\n        Nop();\n        Nop();\n        Nop();\n        Nop();\n        Nop();\n    }\n    for (kk = 0; kk < 30; kk++)\n        Nop();\n}", "item_id": 1, "repo": "moverlin/Kirtley_picogrid", "file": "Software/SSR_Power_Grid/Firmware/Diesel_Generator/MicroChip/Housekeeper/Main_v3_DG_HK.c", "last_update_at": "2018-12-15T01:46:58+00:00", "question_id": "a2f85868afaa0f14a2b41f159db57e10a5cab4f2_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void SendDataCPU(void)\n{\n    // Send data to Computer via USB\n    for (kk = 0; kk < 6; kk++)\n    {\n        U1TXREG = varCPU[kk];\n        while(!U1STAbits.TRMT);\n        Nop();\n        Nop();\n        Nop();\n        Nop();\n        Nop();\n        Nop();\n    }\n    for (kk = 0; kk < 30; kk++)\n        Nop();\n"]], "pred": {"ppl": 3.0861687660217285, "ppl_lower": 4.423823833465576, "ppl/lowercase_ppl": -1.3195175051656536, "ppl/zlib": 0.007177900892192438, "Min_5.0% Prob": 9.413739760716757, "Min_10.0% Prob": 7.075781186421712, "Min_20.0% Prob": 4.823308210372925, "Min_30.0% Prob": 3.5279017498618677, "Min_40.0% Prob": 2.77963651239872, "Min_50.0% Prob": 2.249128905908456, "Min_60.0% Prob": 1.8757472949984826}}
{"hexsha": "651b4b2ad6d22f4cb2a2bdb0a7f74b626cbaa118", "ext": "c", "lang": "C", "content": "static void\nsock_send (anidb_session_t *session, char *msg, char *out)\n{\n\tint n;\n\n//\tprintf(\"send: '%s'\\n\", msg);\n\n\tsend(session->socket, msg, strlen(msg) + 1, 0);\n\tn = recv(session->socket, out, 1000, 0);\n\n\tout[n-1] = '\\0';\n\n//\tprintf(\"recv: '%s'\\n\", out);\n}", "item_id": 4, "repo": "chrippa/hashfs", "file": "src/lib/libanidb/anidb.c", "last_update_at": "2018-02-03T19:12:58+00:00", "question_id": "651b4b2ad6d22f4cb2a2bdb0a7f74b626cbaa118_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nsock_send (anidb_session_t *session, char *msg, char *out)\n{\n\tint n;\n//\tprintf(\"send: '%s'\\n\", msg);\n\tsend(session->socket, msg, strlen(msg) + 1, 0);\n\tn = recv(session->socket, out, 1000, 0);\n\tout[n-1] = '\\0';\n//\tprintf(\"recv: '%s'\\n\", out);\n"]], "pred": {"ppl": 2.574857711791992, "ppl_lower": 2.574857711791992, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0054988039246071894, "Min_5.0% Prob": 7.376678546269734, "Min_10.0% Prob": 5.585233589013417, "Min_20.0% Prob": 3.8682855665683746, "Min_30.0% Prob": 2.9227949695454702, "Min_40.0% Prob": 2.300127449692512, "Min_50.0% Prob": 1.887775252099897, "Min_60.0% Prob": 1.5875347814433378}}
{"hexsha": "ecf01cd97c44c1ae60dac30466fdb8b722512bc7", "ext": "h", "lang": "C", "content": "class TOutputFiles {\npublic:\n    TOutputFiles(const NCatboostOptions::TOutputFilesOptions& params,\n                 const TString& namesPrefix) {\n        InitializeFiles(params, namesPrefix);\n    }\n    TString NamesPrefix;\n    TString TimeLeftLogFile;\n    TString LearnErrorLogFile;\n    TString TestErrorLogFile;\n    TString SnapshotFile;\n    TString MetaFile;\n    static TString AlignFilePath(const TString& baseDir, const TString& fileName, const TString& namePrefix = \"\");\n\nprivate:\n    void InitializeFiles(const NCatboostOptions::TOutputFilesOptions& params, const TString& namesPrefix);\n}", "item_id": 1, "repo": "smokarizadeh/catboost", "file": "catboost/libs/algo/learn_context.h", "last_update_at": "2018-08-06T14:13:12+00:00", "question_id": "ecf01cd97c44c1ae60dac30466fdb8b722512bc7_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class TOutputFiles {\npublic:\n    TOutputFiles(const NCatboostOptions::TOutputFilesOptions& params,\n                 const TString& namesPrefix) {\n        InitializeFiles(params, namesPrefix);\n    }\n    TString NamesPrefix;\n    TString TimeLeftLogFile;\n    TString LearnErrorLogFile;\n    TString TestErrorLogFile;\n    TString SnapshotFile;\n    TString MetaFile;\n    static TString AlignFilePath(const TString& baseDir, const TString& fileName, const TString& namePrefix = \"\");\nprivate:\n    void InitializeFiles(const NCatboostOptions::TOutputFilesOptions& params, const TString& namesPrefix);\n"]], "pred": {"ppl": 2.5023193359375, "ppl_lower": 5.395031452178955, "ppl/lowercase_ppl": -1.8375984358173556, "ppl/zlib": 0.003728528602315443, "Min_5.0% Prob": 7.7840123772621155, "Min_10.0% Prob": 6.365582048892975, "Min_20.0% Prob": 4.244398545473814, "Min_30.0% Prob": 2.9759298112927652, "Min_40.0% Prob": 2.283359022094653, "Min_50.0% Prob": 1.8254835752361431, "Min_60.0% Prob": 1.5317836326109815}}
{"hexsha": "f6b97381f1199f2248acbfb69603c9f4fcd73b4b", "ext": "c", "lang": "C", "content": "int BTESH2_SetAddrDWordTMMU(BTESH2_CpuState *cpu,\n\tbtesh2_vaddr addr, u32 val)\n{\n\tbtesh2_vaddr addr1;\n\n\tif(cpu->status)\n\t\treturn(-1);\n\n\tif(((addr&0x80000000) ||\n\t\t!(BTESH2_GetRegQWord(cpu, BTESH2_REG_MMUCR)&BTESH2_MMUCR_AT)) &&\n\t\t((addr>>29)<6))\n\t{\n\t\treturn(BTESH2_SetAddrDWordFMMU_NoAT_I(cpu, addr, val));\n\t}\n\n\taddr1=BTESH2_TMMU_MapVirtToPhys(cpu, addr);\n\treturn(BTESH2_SetAddrDWordPhy2(cpu, addr1, val));\n}", "item_id": 7, "repo": "cr88192/bgbtech_shxemu", "file": "sh2emu/btesh2/btesh2_tlbmmu.c", "last_update_at": "2018-04-12T20:42:03+00:00", "question_id": "f6b97381f1199f2248acbfb69603c9f4fcd73b4b_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int BTESH2_SetAddrDWordTMMU(BTESH2_CpuState *cpu,\n\tbtesh2_vaddr addr, u32 val)\n{\n\tbtesh2_vaddr addr1;\n\tif(cpu->status)\n\t\treturn(-1);\n\tif(((addr&0x80000000) ||\n\t\t!(BTESH2_GetRegQWord(cpu, BTESH2_REG_MMUCR)&BTESH2_MMUCR_AT)) &&\n\t\t((addr>>29)<6))\n\t{\n\t\treturn(BTESH2_SetAddrDWordFMMU_NoAT_I(cpu, addr, val));\n\t}\n\taddr1=BTESH2_TMMU_MapVirtToPhys(cpu, addr);\n\treturn(BTESH2_SetAddrDWordPhy2(cpu, addr1, val));\n"]], "pred": {"ppl": 2.5461299419403076, "ppl_lower": 3.578148126602173, "ppl/lowercase_ppl": -1.3640917162761472, "ppl/zlib": 0.0038302235103098233, "Min_5.0% Prob": 6.662231878800825, "Min_10.0% Prob": 5.347668513007786, "Min_20.0% Prob": 3.9566549367093025, "Min_30.0% Prob": 2.990063253422858, "Min_40.0% Prob": 2.3109747905480233, "Min_50.0% Prob": 1.8664863355958663, "Min_60.0% Prob": 1.5590465896326553}}
{"hexsha": "2ac945f52b3aeabfda5cb9ad4ffa04a99e0ac346", "ext": "c", "lang": "C", "content": "void ED_view3d_distance_set(RegionView3D *rv3d, const float dist)\n{\n\tfloat viewinv[4];\n\tfloat tvec[3];\n\n\tBLI_assert(dist >= 0.0f);\n\n\tcopy_v3_fl3(tvec, 0.0f, 0.0f, rv3d->dist - dist);\n\t/* rv3d->viewinv isn't always valid */\n#if 0\n\tmul_mat3_m4_v3(rv3d->viewinv, tvec);\n#else\n\tinvert_qt_qt_normalized(viewinv, rv3d->viewquat);\n\tmul_qt_v3(viewinv, tvec);\n#endif\n\tsub_v3_v3(rv3d->ofs, tvec);\n\n\trv3d->dist = dist;\n}", "item_id": 122, "repo": "1-MillionParanoidTterabytes/Blender-2.79b-blackened", "file": "source/blender/editors/space_view3d/view3d_edit.c", "last_update_at": "2018-06-18T01:50:32+00:00", "question_id": "2ac945f52b3aeabfda5cb9ad4ffa04a99e0ac346_122", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void ED_view3d_distance_set(RegionView3D *rv3d, const float dist)\n{\n\tfloat viewinv[4];\n\tfloat tvec[3];\n\tBLI_assert(dist >= 0.0f);\n\tcopy_v3_fl3(tvec, 0.0f, 0.0f, rv3d->dist - dist);\n\t/* rv3d->viewinv isn't always valid */\n#if 0\n\tmul_mat3_m4_v3(rv3d->viewinv, tvec);\n#else\n\tinvert_qt_qt_normalized(viewinv, rv3d->viewquat);\n\tmul_qt_v3(viewinv, tvec);\n#endif\n\tsub_v3_v3(rv3d->ofs, tvec);\n\trv3d->dist = dist;\n"]], "pred": {"ppl": 2.5769078731536865, "ppl_lower": 2.686403512954712, "ppl/lowercase_ppl": -1.0439610873407161, "ppl/zlib": 0.0037121183583602663, "Min_5.0% Prob": 8.090211296081543, "Min_10.0% Prob": 6.0457160245804555, "Min_20.0% Prob": 4.061130207638408, "Min_30.0% Prob": 3.0169369452632964, "Min_40.0% Prob": 2.3243688121438026, "Min_50.0% Prob": 1.8892210445532174, "Min_60.0% Prob": 1.5747190601546173}}
{"hexsha": "0e3beb8a497b19f44113ea931aade6c9a513aae3", "ext": "c", "lang": "C", "content": "int encuentras(char titulo[])\n{\n    int encontrado = 0;\n    actual = primero;\n    while (actual != NULL && encontrado == 0)\n    {\n\n        if (strcmp(titulo, actual->titulo) == 0)\n        {\n            encontrado++;\n        }\n        else\n        {\n            anterior = actual;\n            actual = actual->next;\n        }\n    }\n    return encontrado;\n}", "item_id": 3, "repo": "Am3ra/CS", "file": "CS2/DataStructures/LL/LibroLL.c", "last_update_at": "2018-08-22T20:17:01+00:00", "question_id": "0e3beb8a497b19f44113ea931aade6c9a513aae3_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int encuentras(char titulo[])\n{\n    int encontrado = 0;\n    actual = primero;\n    while (actual != NULL && encontrado == 0)\n    {\n        if (strcmp(titulo, actual->titulo) == 0)\n        {\n            encontrado++;\n        }\n        else\n        {\n            anterior = actual;\n            actual = actual->next;\n        }\n    }\n    return encontrado;\n"]], "pred": {"ppl": 2.558422088623047, "ppl_lower": 2.688854932785034, "ppl/lowercase_ppl": -1.0529329604677897, "ppl/zlib": 0.005218837204582014, "Min_5.0% Prob": 9.839934349060059, "Min_10.0% Prob": 7.327999305725098, "Min_20.0% Prob": 4.435263534386952, "Min_30.0% Prob": 3.0620300695300102, "Min_40.0% Prob": 2.3193669430045194, "Min_50.0% Prob": 1.863212841735394, "Min_60.0% Prob": 1.5790993028203957}}
{"hexsha": "6323ef783b9e7c97dfc7c14da3749f0a6e9c7a59", "ext": "h", "lang": "C", "content": "interface GEOCarInfo : PBCodable <NSCopying> {\n\n\tGEOScreenResolution _screenResolution;\n\tint _deviceConnection;\n\tint _interactionModel;\n\tNSString* _manufacturer;\n\tNSString* _model;\n\tSCD_Struct_GE20 _has;\n\n}", "item_id": 0, "repo": "lechium/tvOS10Headers", "file": "System/Library/PrivateFrameworks/GeoServices.framework/GEOCarInfo.h", "last_update_at": "2018-08-04T20:16:32+00:00", "question_id": "6323ef783b9e7c97dfc7c14da3749f0a6e9c7a59_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface GEOCarInfo : PBCodable <NSCopying> {\n\tGEOScreenResolution _screenResolution;\n\tint _deviceConnection;\n\tint _interactionModel;\n\tNSString* _manufacturer;\n\tNSString* _model;\n\tSCD_Struct_GE20 _has;\n"]], "pred": {"ppl": 3.4978480339050293, "ppl_lower": 13.186469078063965, "ppl/lowercase_ppl": -2.0598135158057036, "ppl/zlib": 0.008130830726905526, "Min_5.0% Prob": 9.117571830749512, "Min_10.0% Prob": 7.016317571912493, "Min_20.0% Prob": 5.140139214197794, "Min_30.0% Prob": 4.000737775927004, "Min_40.0% Prob": 3.17619071106116, "Min_50.0% Prob": 2.5325192530688487, "Min_60.0% Prob": 2.095167496241629}}
{"hexsha": "ae95685d3e591be2b22dae3c92e13599823a3e25", "ext": "c", "lang": "C", "content": "static int Audio_Mic1_Mode_Select_Get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tpr_debug(\"%s() mAudio_Analog_Mic1_mode = %d\\n\", __func__, mAudio_Analog_Mic1_mode);\n\tucontrol->value.integer.value[0] = mAudio_Analog_Mic1_mode;\n\treturn 0;\n}", "item_id": 74, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_codec_63xx.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "ae95685d3e591be2b22dae3c92e13599823a3e25_74", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int Audio_Mic1_Mode_Select_Get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tpr_debug(\"%s() mAudio_Analog_Mic1_mode = %d\\n\", __func__, mAudio_Analog_Mic1_mode);\n\tucontrol->value.integer.value[0] = mAudio_Analog_Mic1_mode;\n\treturn 0;\n"]], "pred": {"ppl": 1.9841067790985107, "ppl_lower": 2.2303240299224854, "ppl/lowercase_ppl": -1.1707288008304888, "ppl/zlib": 0.0038710103249975556, "Min_5.0% Prob": 6.571448644002278, "Min_10.0% Prob": 4.955007096131642, "Min_20.0% Prob": 3.22994207094113, "Min_30.0% Prob": 2.2636334374547005, "Min_40.0% Prob": 1.709407658665441, "Min_50.0% Prob": 1.3695072877996912, "Min_60.0% Prob": 1.1416900629944091}}
{"hexsha": "fdc67a8897a4a203be3250eeed2dffb8f8aa02ed", "ext": "c", "lang": "C", "content": "Bool XCheckNotMaskEvent (Display *dpy, long mask, XEvent *event)\n{\n\tregister _XQEvent *prev, *qelt;\n\tunsigned long qe_serial = 0;\n\tint n;\t\t\t/* time through count */\n\n        LockDisplay(dpy);\n\tprev = NULL;\n\tfor (n = 3; --n >= 0;) {\n\t    for (qelt = prev ? prev->next : dpy->head;\n\t\t qelt;\n\t\t prev = qelt, qelt = qelt->next) {\n\t\tif (qelt->event.type >= LASTEvent\n                    || !(_Xevent_to_mask[qelt->event.type] & mask)) {\n\t\t    *event = qelt->event;\n\t\t    _XDeq(dpy, prev, qelt);\n\t\t    UnlockDisplay(dpy);\n\t\t    return True;\n\t\t}\n\t    }\n\t    if (prev)\n\t\tqe_serial = prev->qserial_num;\n\t    switch (n) {\n\t      case 2:\n\t\t_XEventsQueued(dpy, QueuedAfterReading);\n\t\tbreak;\n\t      case 1:\n\t\t_XFlush(dpy);\n\t\tbreak;\n\t    }\n\t    if (prev && prev->qserial_num != qe_serial)\n\t\t/* another thread has snatched this event */\n\t\tprev = NULL;\n\t}\n\tUnlockDisplay(dpy);\n\treturn False;\n}", "item_id": 0, "repo": "larsclausen/xglamo", "file": "hw/dmx/input/ChkNotMaskEv.c", "last_update_at": "2018-11-01T06:58:35+00:00", "question_id": "fdc67a8897a4a203be3250eeed2dffb8f8aa02ed_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["Bool XCheckNotMaskEvent (Display *dpy, long mask, XEvent *event)\n{\n\tregister _XQEvent *prev, *qelt;\n\tunsigned long qe_serial = 0;\n\tint n;\t\t\t/* time through count */\n        LockDisplay(dpy);\n\tprev = NULL;\n\tfor (n = 3; --n >= 0;) {\n\t    for (qelt = prev ? prev->next : dpy->head;\n\t\t qelt;\n\t\t prev = qelt, qelt = qelt->next) {\n\t\tif (qelt->event.type >= LASTEvent\n                    || !(_Xevent_to_mask[qelt->event.type] & mask)) {\n\t\t    *event = qelt->event;\n\t\t    _XDeq(dpy, prev, qelt);\n\t\t    UnlockDisplay(dpy);\n\t\t    return True;\n\t\t}\n\t    }\n\t    if (prev)\n\t\tqe_serial = prev->qserial_num;\n\t    switch (n) {\n\t      case 2:\n\t\t_XEventsQueued(dpy, QueuedAfterReading);\n\t\tbreak;\n\t      case 1:\n\t\t_XFlush(dpy);\n\t\tbreak;\n\t    }\n\t    if (prev && prev->qserial_num != qe_serial)\n\t\t/* another thread has snatched this event */\n\t\tprev = NULL;\n\t}\n\tUnlockDisplay(dpy);\n\treturn False;\n"]], "pred": {"ppl": 2.1270391941070557, "ppl_lower": 2.730804443359375, "ppl/lowercase_ppl": -1.3310653503691012, "ppl/zlib": 0.0016624030021828073, "Min_5.0% Prob": 7.45722754796346, "Min_10.0% Prob": 5.3445883248303385, "Min_20.0% Prob": 3.380115218259193, "Min_30.0% Prob": 2.4106768696968044, "Min_40.0% Prob": 1.8661347243609845, "Min_50.0% Prob": 1.5013340132878745, "Min_60.0% Prob": 1.2579561481501773}}
{"hexsha": "c342a2bd23d35860aab57193cd695a466621ef0c", "ext": "c", "lang": "C", "content": "int main(char argc, char **argv)\n{\n\tint retval = 255;\n\n\tinit_signals();\n\tinit_vars();\n\tparse_args(argc, argv);\n\tinit_shell();\n\tretval = ush_main_loop();\n\tuninit_shell();\n\treturn retval;\n}", "item_id": 3, "repo": "noahb01/ush", "file": "src/main.c", "last_update_at": "2018-02-12T01:49:26+00:00", "question_id": "c342a2bd23d35860aab57193cd695a466621ef0c_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(char argc, char **argv)\n{\n\tint retval = 255;\n\tinit_signals();\n\tinit_vars();\n\tparse_args(argc, argv);\n\tinit_shell();\n\tretval = ush_main_loop();\n\tuninit_shell();\n\treturn retval;\n"]], "pred": {"ppl": 3.7482588291168213, "ppl_lower": 3.7482588291168213, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.010486439840638897, "Min_5.0% Prob": 8.345489025115967, "Min_10.0% Prob": 7.45997542142868, "Min_20.0% Prob": 5.284237891435623, "Min_30.0% Prob": 4.0224933077891665, "Min_40.0% Prob": 3.144398109479384, "Min_50.0% Prob": 2.6186367629504783, "Min_60.0% Prob": 2.2203629799947446}}
{"hexsha": "c6019705f7fc09fa7f066201c8b3319375bed2ca", "ext": "c", "lang": "C", "content": "static int handle_unrecognized_command(context_t *context)\n{\n    log_write(context->log, \"[%s] received unrecognized command %s at state %s\",\n        context->uuid, context->command, state_string(context->state));\n\n    if (buffer_shift_read_after(&context->in_message, CRLF, sizeof(CRLF) - 1) < 0) {\n        return -1;\n    }\n\n    return BUFFER_TAILQ_PUSH_BACK_STRING(&context->out_message_queue,\n        \"500 Syntax error, command unrecognized\" CRLF);\n}", "item_id": 3, "repo": "elsid/smtp-server", "file": "src/protocol.c", "last_update_at": "2018-01-09T04:36:14+00:00", "question_id": "c6019705f7fc09fa7f066201c8b3319375bed2ca_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int handle_unrecognized_command(context_t *context)\n{\n    log_write(context->log, \"[%s] received unrecognized command %s at state %s\",\n        context->uuid, context->command, state_string(context->state));\n    if (buffer_shift_read_after(&context->in_message, CRLF, sizeof(CRLF) - 1) < 0) {\n        return -1;\n    }\n    return BUFFER_TAILQ_PUSH_BACK_STRING(&context->out_message_queue,\n        \"500 Syntax error, command unrecognized\" CRLF);\n"]], "pred": {"ppl": 4.090059280395508, "ppl_lower": 4.378568649291992, "ppl/lowercase_ppl": -1.0483915776311787, "ppl/zlib": 0.0050126671314373854, "Min_5.0% Prob": 8.430873666490827, "Min_10.0% Prob": 7.073314189910889, "Min_20.0% Prob": 5.2920926540128645, "Min_30.0% Prob": 4.094970949152683, "Min_40.0% Prob": 3.307630074402643, "Min_50.0% Prob": 2.7393834383427342, "Min_60.0% Prob": 2.3407731154497635}}
{"hexsha": "ce62987c67acf5f3c9afa731f3cda369023a60b9", "ext": "c", "lang": "C", "content": "JNICALL Java_com_mylexz_utils_PrimitiveData_addStrArray\n  (JNIEnv *env, jobject thiz, jstring element, jobjectArray arrStr, jint size){\n\t  jint __desc = __getDescriptor(env, thiz);\n\t  if(__desc == -1)return;\n\t  PDATA *pdata = __content(__current, __desc);\n\t  const char *elem = (*env)->GetStringUTFChars(env, element, 0);\n\t  if(((jint)(*env)->GetArrayLength(env, arrStr)) < size){\n\t  \t(*env)->ReleaseStringUTFChars(env, element, elem);\n\t  \treturn;\n\t  }\n\t  extern int checkExistsElem(char *, FILE *, char *, off_t);\n\t  extern void __passToFile(char *, FILE *, int, int);\n\t  \n\t// Copying pointers from pdata to temp and rdfiles\n\t  FILE* rd = pdata->rd;\n\t  char* temp = pdata->temp;\n\t  int* errnum = &(pdata->errnum);\n\t  off_t offset = ftell(rd);\n\t  if(checkExistsElem(temp, rd, elem, offset)){\n\t\t  fseek(rd, offset, 0);\n\t\t  *errnum = -2;\n\t\t  (*env)->ReleaseStringUTFChars(env, element, elem);\n\t\t  return;\n\t}\n\t// writing first content\n\tfprintf(rd, \"%c%c%s%c\", ID_ARR, STR, elem, BUKA);\n\t// writing content array\n\tsize_t x = 0;\n\tfor (; x < size; x++){\n\t\tjstring a = (jstring) (*env)->GetObjectArrayElement(env, arrStr, x);\n\t\tconst char *n = (*env)->GetStringUTFChars(env, a, 0);\n\t\tstrcpy(temp, n);\n\t\tedStr(temp, ENC);\n\t\t__passToFile(temp, rd, x, size);\n\t\t(*env)->ReleaseStringUTFChars(env, a, n);\n\t}\n    fseek(rd, offset, 0);\n\t*errnum = 0;\n\t(*env)->ReleaseStringUTFChars(env, element, elem);\n\treturn;\n\t  \n  }", "item_id": 51, "repo": "AlexzPurewoko/PANRI", "file": "mylexzlibrary/src/main/c/com_mylexz_utils_PrimitiveData.c", "last_update_at": "2018-09-03T11:58:48+00:00", "question_id": "ce62987c67acf5f3c9afa731f3cda369023a60b9_51", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["JNICALL Java_com_mylexz_utils_PrimitiveData_addStrArray\n  (JNIEnv *env, jobject thiz, jstring element, jobjectArray arrStr, jint size){\n\t  jint __desc = __getDescriptor(env, thiz);\n\t  if(__desc == -1)return;\n\t  PDATA *pdata = __content(__current, __desc);\n\t  const char *elem = (*env)->GetStringUTFChars(env, element, 0);\n\t  if(((jint)(*env)->GetArrayLength(env, arrStr)) < size){\n\t  \t(*env)->ReleaseStringUTFChars(env, element, elem);\n\t  \treturn;\n\t  }\n\t  extern int checkExistsElem(char *, FILE *, char *, off_t);\n\t  extern void __passToFile(char *, FILE *, int, int);\n\t  \n\t// Copying pointers from pdata to temp and rdfiles\n\t  FILE* rd = pdata->rd;\n\t  char* temp = pdata->temp;\n\t  int* errnum = &(pdata->errnum);\n\t  off_t offset = ftell(rd);\n\t  if(checkExistsElem(temp, rd, elem, offset)){\n\t\t  fseek(rd, offset, 0);\n\t\t  *errnum = -2;\n\t\t  (*env)->ReleaseStringUTFChars(env, element, elem);\n\t\t  return;\n\t}\n\t// writing first content\n\tfprintf(rd, \"%c%c%s%c\", ID_ARR, STR, elem, BUKA);\n\t// writing content array\n\tsize_t x = 0;\n\tfor (; x < size; x++){\n\t\tjstring a = (jstring) (*env)->GetObjectArrayElement(env, arrStr, x);\n\t\tconst char *n = (*env)->GetStringUTFChars(env, a, 0);\n\t\tstrcpy(temp, n);\n\t\tedStr(temp, ENC);\n\t\t__passToFile(temp, rd, x, size);\n\t\t(*env)->ReleaseStringUTFChars(env, a, n);\n\t}\n    fseek(rd, offset, 0);\n\t*errnum = 0;\n\t(*env)->ReleaseStringUTFChars(env, element, elem);\n\treturn;\n\t  \n"]], "pred": {"ppl": 2.972853899002075, "ppl_lower": 3.584319829940796, "ppl/lowercase_ppl": -1.1716773598878556, "ppl/zlib": 0.001746029487487557, "Min_5.0% Prob": 7.932321581347235, "Min_10.0% Prob": 6.4293679903293475, "Min_20.0% Prob": 4.4984582683135725, "Min_30.0% Prob": 3.384411870748147, "Min_40.0% Prob": 2.6677165463052948, "Min_50.0% Prob": 2.1628666581521774, "Min_60.0% Prob": 1.811186094490019}}
{"hexsha": "5706fdf060ecdef7ef541b71b9c1ca2c95dd2181", "ext": "c", "lang": "C", "content": "ssh_string pki_signature_to_blob(const ssh_signature sig)\n{\n    ssh_string sig_blob = NULL;\n\n    switch(sig->type) {\n        case SSH_KEYTYPE_DSS:\n            sig_blob = pki_dsa_signature_to_blob(sig);\n            break;\n        case SSH_KEYTYPE_RSA:\n        case SSH_KEYTYPE_RSA1:\n            sig_blob = ssh_string_copy(sig->rsa_sig);\n            break;\n        case SSH_KEYTYPE_ECDSA:\n#ifdef HAVE_OPENSSL_ECC\n        {\n            ssh_string r;\n            ssh_string s;\n            ssh_buffer b;\n            int rc;\n\n            b = ssh_buffer_new();\n            if (b == NULL) {\n                return NULL;\n            }\n\n            r = make_bignum_string(sig->ecdsa_sig->r);\n            if (r == NULL) {\n                ssh_buffer_free(b);\n                return NULL;\n            }\n            rc = buffer_add_ssh_string(b, r);\n            ssh_string_free(r);\n            if (rc < 0) {\n                ssh_buffer_free(b);\n                return NULL;\n            }\n\n            s = make_bignum_string(sig->ecdsa_sig->s);\n            if (s == NULL) {\n                ssh_buffer_free(b);\n                return NULL;\n            }\n            rc = buffer_add_ssh_string(b, s);\n            ssh_string_free(s);\n            if (rc < 0) {\n                ssh_buffer_free(b);\n                return NULL;\n            }\n\n            sig_blob = ssh_string_new(buffer_get_rest_len(b));\n            if (sig_blob == NULL) {\n                ssh_buffer_free(b);\n                return NULL;\n            }\n\n            ssh_string_fill(sig_blob, buffer_get_rest(b), buffer_get_rest_len(b));\n            ssh_buffer_free(b);\n            break;\n        }\n#endif\n        case SSH_KEYTYPE_ED25519:\n            sig_blob = pki_ed25519_sig_to_blob(sig);\n            break;\n        default:\n        case SSH_KEYTYPE_UNKNOWN:\n            ssh_pki_log(\"Unknown signature key type: %s\", sig->type_c);\n            return NULL;\n    }\n\n    return sig_blob;\n}", "item_id": 16, "repo": "nelyj/tmate", "file": "libssh/src/pki_crypto.c", "last_update_at": "2018-09-09T01:58:52+00:00", "question_id": "5706fdf060ecdef7ef541b71b9c1ca2c95dd2181_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ssh_string pki_signature_to_blob(const ssh_signature sig)\n{\n    ssh_string sig_blob = NULL;\n    switch(sig->type) {\n        case SSH_KEYTYPE_DSS:\n            sig_blob = pki_dsa_signature_to_blob(sig);\n            break;\n        case SSH_KEYTYPE_RSA:\n        case SSH_KEYTYPE_RSA1:\n            sig_blob = ssh_string_copy(sig->rsa_sig);\n            break;\n        case SSH_KEYTYPE_ECDSA:\n#ifdef HAVE_OPENSSL_ECC\n        {\n            ssh_string r;\n            ssh_string s;\n            ssh_buffer b;\n            int rc;\n            b = ssh_buffer_new();\n            if (b == NULL) {\n                return NULL;\n            }\n            r = make_bignum_string(sig->ecdsa_sig->r);\n            if (r == NULL) {\n                ssh_buffer_free(b);\n                return NULL;\n            }\n            rc = buffer_add_ssh_string(b, r);\n            ssh_string_free(r);\n            if (rc < 0) {\n                ssh_buffer_free(b);\n                return NULL;\n            }\n            s = make_bignum_string(sig->ecdsa_sig->s);\n            if (s == NULL) {\n                ssh_buffer_free(b);\n                return NULL;\n            }\n            rc = buffer_add_ssh_string(b, s);\n            ssh_string_free(s);\n            if (rc < 0) {\n                ssh_buffer_free(b);\n                return NULL;\n            }\n            sig_blob = ssh_string_new(buffer_get_rest_len(b));\n            if (sig_blob == NULL) {\n                ssh_buffer_free(b);\n                return NULL;\n            }\n            ssh_string_fill(sig_blob, buffer_get_rest(b), buffer_get_rest_len(b));\n            ssh_buffer_free(b);\n            break;\n        }\n#endif\n        case SSH_KEYTYPE_ED25519:\n            sig_blob = pki_ed25519_sig_to_blob(sig);\n            break;\n        default:\n        case SSH_KEYTYPE_UNKNOWN:\n            ssh_pki_log(\"Unknown signature key type: %s\", sig->type_c);\n            return NULL;\n    }\n    return sig_blob;\n"]], "pred": {"ppl": 1.495140552520752, "ppl_lower": 1.6034646034240723, "ppl/lowercase_ppl": -1.1739008752094902, "ppl/zlib": 0.0008276136162295447, "Min_5.0% Prob": 5.016622427971132, "Min_10.0% Prob": 3.3755925874556265, "Min_20.0% Prob": 1.9532711972152033, "Min_30.0% Prob": 1.3366439734455398, "Min_40.0% Prob": 1.0041016040624204, "Min_50.0% Prob": 0.8051565458460552, "Min_60.0% Prob": 0.6716578009874802}}
{"hexsha": "46e47df84691c0495963bb51a7c9d498a0413fb9", "ext": "c", "lang": "C", "content": "void process_png_file() {\n\tuint16_t transparent_color=0x0000;\n\n\tprintf(\"uint16_t bitmap[%d][%d] ={\\n\", height, width);\n\tfor(int y = 0; y < height; y++) {\n\t\tprintf(\"{ \");\n\t\tpng_bytep row = row_pointers[y];\n\t\tfor(int x = 0; x < width; x++) {\n\t\t\tpng_bytep px = &(row[x * 4]);\n\t\t\tuint16_t u16col = (px[2]>>3) + ((px[1]>>2)<<5) + ((px[0]>>3)<<11);\n\t\t\tif (0x0000==px[3]) transparent_color = u16col;\n\t\t\t//printf(\"%4d, %4d = RGBA(%3d, %3d, %3d, %3d) = 0x%04X\\n\", x, y, px[0], px[1], px[2], px[3], u16col);\n\t\t\tprintf(\"0x%04X, \", u16col);\n\t\t}\n\t\tprintf(\" },\\n\");\n\t}\n\tprintf(\"};\\nuint16_t transparent_color=0x%04X;\\n\", transparent_color);\n}", "item_id": 1, "repo": "renato-grottesi/microbit", "file": "png2h/png2h.c", "last_update_at": "2018-11-04T18:15:03+00:00", "question_id": "46e47df84691c0495963bb51a7c9d498a0413fb9_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void process_png_file() {\n\tuint16_t transparent_color=0x0000;\n\tprintf(\"uint16_t bitmap[%d][%d] ={\\n\", height, width);\n\tfor(int y = 0; y < height; y++) {\n\t\tprintf(\"{ \");\n\t\tpng_bytep row = row_pointers[y];\n\t\tfor(int x = 0; x < width; x++) {\n\t\t\tpng_bytep px = &(row[x * 4]);\n\t\t\tuint16_t u16col = (px[2]>>3) + ((px[1]>>2)<<5) + ((px[0]>>3)<<11);\n\t\t\tif (0x0000==px[3]) transparent_color = u16col;\n\t\t\t//printf(\"%4d, %4d = RGBA(%3d, %3d, %3d, %3d) = 0x%04X\\n\", x, y, px[0], px[1], px[2], px[3], u16col);\n\t\t\tprintf(\"0x%04X, \", u16col);\n\t\t}\n\t\tprintf(\" },\\n\");\n\t}\n\tprintf(\"};\\nuint16_t transparent_color=0x%04X;\\n\", transparent_color);\n"]], "pred": {"ppl": 1.9745928049087524, "ppl_lower": 1.986433506011963, "ppl/lowercase_ppl": -1.0087874082198331, "ppl/zlib": 0.0020248875070428816, "Min_5.0% Prob": 7.0225695441750915, "Min_10.0% Prob": 5.037447066868053, "Min_20.0% Prob": 3.0740287242566837, "Min_30.0% Prob": 2.202152480097378, "Min_40.0% Prob": 1.6861464381765794, "Min_50.0% Prob": 1.3525258222736463, "Min_60.0% Prob": 1.1319697731424396}}
{"hexsha": "c1ef6abdafe8ab7afa1c51c45d99971beda7fe5f", "ext": "c", "lang": "C", "content": "void\np6est_coarsen_layers_ext (p6est_t * p6est, int coarsen_recursive,\n                          int callback_orphans,\n                          p6est_coarsen_layer_t coarsen_fn,\n                          p6est_init_t init_fn, p6est_replace_t replace_fn)\n{\n  p4est_t            *columns = p6est->columns;\n  sc_array_t         *layers = p6est->layers;\n  sc_array_t          view;\n  p4est_topidx_t      jt;\n  p4est_tree_t       *tree;\n  sc_array_t         *tquadrants;\n  p4est_quadrant_t   *col;\n  size_t              first, last, zz, count;\n\n  P4EST_GLOBAL_PRODUCTIONF (\"Into p6est_coarsen_layers with %lld total layers\"\n                            \" in %lld total columns\\n\", (long long)\n                            p6est->global_first_layer[p6est->mpisize],\n                            (long long) p6est->columns->global_num_quadrants);\n  p4est_log_indent_push ();\n\n  for (jt = columns->first_local_tree; jt <= columns->last_local_tree; ++jt) {\n    tree = p4est_tree_array_index (columns->trees, jt);\n    tquadrants = &tree->quadrants;\n\n    for (zz = 0; zz < tquadrants->elem_count; ++zz) {\n      col = p4est_quadrant_array_index (tquadrants, zz);\n      P6EST_COLUMN_GET_RANGE (col, &first, &last);\n\n      count = last - first;\n      sc_array_init_view (&view, layers, first, count);\n      p6est_coarsen_all_layers (p6est, jt, col, 0, &view,\n                                coarsen_recursive, callback_orphans,\n                                coarsen_fn, init_fn, replace_fn);\n      P4EST_ASSERT (view.elem_count > 0);\n      P4EST_ASSERT (view.elem_count <= count);\n      last = first + view.elem_count;\n      P6EST_COLUMN_SET_RANGE (col, first, last);\n    }\n  }\n  p6est_compress_columns (p6est);\n  p6est_update_offsets (p6est);\n  P4EST_ASSERT (p6est->user_data_pool->elem_count == layers->elem_count);\n\n  p4est_log_indent_pop ();\n  P4EST_GLOBAL_PRODUCTIONF\n    (\"Done p6est_coarsen_layers with %lld total layers \"\n     \" in %lld total columns\\n\",\n     (long long) p6est->global_first_layer[p6est->mpisize],\n     (long long) p6est->columns->global_num_quadrants);\n}", "item_id": 29, "repo": "jmark/p4wrap", "file": "sites/workstation/gcc/p4est/src/p6est.c", "last_update_at": "2018-06-27T14:29:52+00:00", "question_id": "c1ef6abdafe8ab7afa1c51c45d99971beda7fe5f_29", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\np6est_coarsen_layers_ext (p6est_t * p6est, int coarsen_recursive,\n                          int callback_orphans,\n                          p6est_coarsen_layer_t coarsen_fn,\n                          p6est_init_t init_fn, p6est_replace_t replace_fn)\n{\n  p4est_t            *columns = p6est->columns;\n  sc_array_t         *layers = p6est->layers;\n  sc_array_t          view;\n  p4est_topidx_t      jt;\n  p4est_tree_t       *tree;\n  sc_array_t         *tquadrants;\n  p4est_quadrant_t   *col;\n  size_t              first, last, zz, count;\n  P4EST_GLOBAL_PRODUCTIONF (\"Into p6est_coarsen_layers with %lld total layers\"\n                            \" in %lld total columns\\n\", (long long)\n                            p6est->global_first_layer[p6est->mpisize],\n                            (long long) p6est->columns->global_num_quadrants);\n  p4est_log_indent_push ();\n  for (jt = columns->first_local_tree; jt <= columns->last_local_tree; ++jt) {\n    tree = p4est_tree_array_index (columns->trees, jt);\n    tquadrants = &tree->quadrants;\n    for (zz = 0; zz < tquadrants->elem_count; ++zz) {\n      col = p4est_quadrant_array_index (tquadrants, zz);\n      P6EST_COLUMN_GET_RANGE (col, &first, &last);\n      count = last - first;\n      sc_array_init_view (&view, layers, first, count);\n      p6est_coarsen_all_layers (p6est, jt, col, 0, &view,\n                                coarsen_recursive, callback_orphans,\n                                coarsen_fn, init_fn, replace_fn);\n      P4EST_ASSERT (view.elem_count > 0);\n      P4EST_ASSERT (view.elem_count <= count);\n      last = first + view.elem_count;\n      P6EST_COLUMN_SET_RANGE (col, first, last);\n    }\n  }\n  p6est_compress_columns (p6est);\n  p6est_update_offsets (p6est);\n  P4EST_ASSERT (p6est->user_data_pool->elem_count == layers->elem_count);\n  p4est_log_indent_pop ();\n  P4EST_GLOBAL_PRODUCTIONF\n    (\"Done p6est_coarsen_layers with %lld total layers \"\n     \" in %lld total columns\\n\",\n     (long long) p6est->global_first_layer[p6est->mpisize],\n     (long long) p6est->columns->global_num_quadrants);\n"]], "pred": {"ppl": 1.8876572847366333, "ppl_lower": 2.0357964038848877, "ppl/lowercase_ppl": -1.1189142507885934, "ppl/zlib": 0.0008999100967862773, "Min_5.0% Prob": 6.451715613666334, "Min_10.0% Prob": 4.586108857935125, "Min_20.0% Prob": 2.8925067290183035, "Min_30.0% Prob": 2.0679135256414782, "Min_40.0% Prob": 1.579083432149022, "Min_50.0% Prob": 1.268313349080608, "Min_60.0% Prob": 1.0598013320036472}}
{"hexsha": "86a3af82daa645cbeb897ddc2d1fe0d8d3b956f1", "ext": "c", "lang": "C", "content": "static char *test_pc_at_reset_vector_on_init()\n{\n\tmemory = MEM_init();\n\n\t/* Put something into the reset vector */\n\tMEM_write(memory, MEM_RESET_VECTOR, 0x0F);\n\tMEM_write(memory, MEM_RESET_VECTOR + 1, 0x33);\n\n\tcpu = CPU_init(memory);\n\n\tmu_assert(\"PC not set to addr in reset vector\", cpu->PC == 0x330F);\n\n\tCPU_delete(&cpu);\n\treturn 0;\n}", "item_id": 1, "repo": "akydd/nes_emulator", "file": "test_cpu.c", "last_update_at": "2018-03-21T21:39:47+00:00", "question_id": "86a3af82daa645cbeb897ddc2d1fe0d8d3b956f1_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static char *test_pc_at_reset_vector_on_init()\n{\n\tmemory = MEM_init();\n\t/* Put something into the reset vector */\n\tMEM_write(memory, MEM_RESET_VECTOR, 0x0F);\n\tMEM_write(memory, MEM_RESET_VECTOR + 1, 0x33);\n\tcpu = CPU_init(memory);\n\tmu_assert(\"PC not set to addr in reset vector\", cpu->PC == 0x330F);\n\tCPU_delete(&cpu);\n\treturn 0;\n"]], "pred": {"ppl": 3.645472526550293, "ppl_lower": 3.9935216903686523, "ppl/lowercase_ppl": -1.07049745975726, "ppl/zlib": 0.0058528778007789295, "Min_5.0% Prob": 7.7492209162030905, "Min_10.0% Prob": 6.602819238390241, "Min_20.0% Prob": 4.9578686007137955, "Min_30.0% Prob": 3.8885669030926446, "Min_40.0% Prob": 3.1357888498548734, "Min_50.0% Prob": 2.5761937152695014, "Min_60.0% Prob": 2.159342274488358}}
{"hexsha": "f8555e125e8c8657d40cf3baaf0ee970e950877b", "ext": "c", "lang": "C", "content": "void spu_cdda_pan(int left_pan, int right_pan) {\n    if(left_pan < 16)\n        left_pan = ~(left_pan - 16);\n\n    left_pan &= 0x1f;\n\n    if(right_pan < 16)\n        right_pan = ~(right_pan - 16);\n\n    right_pan &= 0x1f;\n\n    g2_fifo_wait();\n    g2_write_32(SNDREGADDR(0x2040),\n                (g2_read_32(SNDREGADDR(0x2040)) & ~0xff) | (left_pan << 0));\n    g2_write_32(SNDREGADDR(0x2044),\n                (g2_read_32(SNDREGADDR(0x2044)) & ~0xff) | (right_pan << 0));\n}", "item_id": 7, "repo": "GravisZro/kos", "file": "dreamcast/hardware/spu.c", "last_update_at": "2018-08-14T01:07:53+00:00", "question_id": "f8555e125e8c8657d40cf3baaf0ee970e950877b_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void spu_cdda_pan(int left_pan, int right_pan) {\n    if(left_pan < 16)\n        left_pan = ~(left_pan - 16);\n    left_pan &= 0x1f;\n    if(right_pan < 16)\n        right_pan = ~(right_pan - 16);\n    right_pan &= 0x1f;\n    g2_fifo_wait();\n    g2_write_32(SNDREGADDR(0x2040),\n                (g2_read_32(SNDREGADDR(0x2040)) & ~0xff) | (left_pan << 0));\n    g2_write_32(SNDREGADDR(0x2044),\n                (g2_read_32(SNDREGADDR(0x2044)) & ~0xff) | (right_pan << 0));\n"]], "pred": {"ppl": 2.3248825073242188, "ppl_lower": 2.3429031372070312, "ppl/lowercase_ppl": -1.0091520601475377, "ppl/zlib": 0.0043044362412153194, "Min_5.0% Prob": 7.2463074922561646, "Min_10.0% Prob": 5.348828196525574, "Min_20.0% Prob": 3.6945943584044776, "Min_30.0% Prob": 2.733363073733118, "Min_40.0% Prob": 2.103672619132946, "Min_50.0% Prob": 1.6906346365188558, "Min_60.0% Prob": 1.4108249124320638}}
{"hexsha": "5fc47f3e5d3b786f5c45c643fc53f60d9b0858bd", "ext": "c", "lang": "C", "content": "Bool VG_(maybe_Z_demangle) ( const HChar* sym, \n                             /*OUT*/HChar* so, Int soLen,\n                             /*OUT*/HChar* fn, Int fnLen,\n                             /*OUT*/Bool* isWrap,\n                             /*OUT*/Int*  eclassTag,\n                             /*OUT*/Int*  eclassPrio )\n{\n#  define EMITSO(ch)                           \\\n      do {                                     \\\n         if (so) {                             \\\n            if (soi >= soLen) {                \\\n               so[soLen-1] = 0; oflow = True;  \\\n            } else {                           \\\n               so[soi++] = ch; so[soi] = 0;    \\\n            }                                  \\\n         }                                     \\\n      } while (0)\n#  define EMITFN(ch)                           \\\n      do {                                     \\\n         if (fni >= fnLen) {                   \\\n            fn[fnLen-1] = 0; oflow = True;     \\\n         } else {                              \\\n            fn[fni++] = ch; fn[fni] = 0;       \\\n         }                                     \\\n      } while (0)\n\n   Bool error, oflow, valid, fn_is_encoded, is_VG_Z_prefixed;\n   Int  soi, fni, i;\n\n   vg_assert(soLen > 0 || (soLen == 0 && so == NULL));\n   vg_assert(fnLen > 0);\n   error = False;\n   oflow = False;\n   soi = 0;\n   fni = 0;\n\n   valid =     sym[0] == '_'\n           &&  sym[1] == 'v'\n           &&  sym[2] == 'g'\n           && (sym[3] == 'r' || sym[3] == 'w')\n           &&  VG_(isdigit)(sym[4])\n           &&  VG_(isdigit)(sym[5])\n           &&  VG_(isdigit)(sym[6])\n           &&  VG_(isdigit)(sym[7])\n           &&  VG_(isdigit)(sym[8])\n           &&  sym[9] == 'Z'\n           && (sym[10] == 'Z' || sym[10] == 'U')\n           &&  sym[11] == '_';\n\n   if (valid\n       && sym[4] == '0' && sym[5] == '0' && sym[6] == '0' && sym[7] == '0'\n       && sym[8] != '0') {\n      /* If the eclass tag is 0000 (meaning \"no eclass\"), the priority\n         must be 0 too. */\n      valid = False;\n   }\n\n   if (!valid)\n      return False;\n\n   fn_is_encoded = sym[10] == 'Z';\n\n   if (isWrap)\n      *isWrap = sym[3] == 'w';\n\n   if (eclassTag) {\n      *eclassTag =    1000 * ((Int)sym[4] - '0')\n                   +  100 * ((Int)sym[5] - '0')\n                   +  10 * ((Int)sym[6] - '0')\n                   +  1 * ((Int)sym[7] - '0');\n      vg_assert(*eclassTag >= 0 && *eclassTag <= 9999);\n   }\n\n   if (eclassPrio) {\n      *eclassPrio = ((Int)sym[8]) - '0';\n      vg_assert(*eclassPrio >= 0 && *eclassPrio <= 9);\n   }\n\n   /* Now check the soname prefix isn't \"VG_Z_\", as described in\n      pub_tool_redir.h. */\n   is_VG_Z_prefixed =\n      sym[12] == 'V' &&\n      sym[13] == 'G' &&\n      sym[14] == '_' &&\n      sym[15] == 'Z' &&\n      sym[16] == '_';\n   if (is_VG_Z_prefixed) {\n      vg_assert2(0, \"symbol with a 'VG_Z_' prefix: %s.\\n\"\n                    \"see pub_tool_redir.h for an explanation.\", sym);\n   }\n\n   /* Now scan the Z-encoded soname. */\n   i = 12;\n   while (True) {\n\n      if (sym[i] == '_')\n      /* Found the delimiter.  Move on to the fnname loop. */\n         break;\n\n      if (sym[i] == 0) {\n         error = True;\n         goto out;\n      }\n\n      if (sym[i] != 'Z') {\n         EMITSO(sym[i]);\n         i++;\n         continue;\n      }\n\n      /* We've got a Z-escape. */\n      i++;\n      switch (sym[i]) {\n         case 'a': EMITSO('*'); break;\n         case 'c': EMITSO(':'); break;\n         case 'd': EMITSO('.'); break;\n         case 'h': EMITSO('-'); break;\n         case 'p': EMITSO('+'); break;\n         case 's': EMITSO(' '); break;\n         case 'u': EMITSO('_'); break;\n         case 'A': EMITSO('@'); break;\n         case 'D': EMITSO('$'); break;\n         case 'L': EMITSO('('); break;\n         case 'R': EMITSO(')'); break;\n         case 'Z': EMITSO('Z'); break;\n         default: error = True; goto out;\n      }\n      i++;\n   }\n\n   vg_assert(sym[i] == '_');\n   i++;\n\n   /* Now deal with the function name part. */\n   if (!fn_is_encoded) {\n\n      /* simple; just copy. */\n      while (True) {\n         if (sym[i] == 0)\n            break;\n         EMITFN(sym[i]);\n         i++;\n      }\n      goto out;\n\n   }\n\n   /* else use a Z-decoding loop like with soname */\n   while (True) {\n\n      if (sym[i] == 0)\n         break;\n\n      if (sym[i] != 'Z') {\n         EMITFN(sym[i]);\n         i++;\n         continue;\n      }\n\n      /* We've got a Z-escape. */\n      i++;\n      switch (sym[i]) {\n         case 'a': EMITFN('*'); break;\n         case 'c': EMITFN(':'); break;\n         case 'd': EMITFN('.'); break;\n         case 'h': EMITFN('-'); break;\n         case 'p': EMITFN('+'); break;\n         case 's': EMITFN(' '); break;\n         case 'u': EMITFN('_'); break;\n         case 'A': EMITFN('@'); break;\n         case 'D': EMITFN('$'); break;\n         case 'L': EMITFN('('); break;\n         case 'R': EMITFN(')'); break;\n         case 'Z': EMITFN('Z'); break;\n         default: error = True; goto out;\n      }\n      i++;\n   }\n\n  out:\n   EMITSO(0);\n   EMITFN(0);\n\n   if (error) {\n      /* Something's wrong.  Give up. */\n      VG_(message)(Vg_UserMsg,\n                   \"m_demangle: error Z-demangling: %s\\n\", sym);\n      return False;\n   }\n   if (oflow) {\n      /* It didn't fit.  Give up. */\n      VG_(message)(Vg_UserMsg,\n                   \"m_demangle: oflow Z-demangling: %s\\n\", sym);\n      return False;\n   }\n\n   return True;\n}", "item_id": 1, "repo": "sjcappella/avalanche", "file": "valgrind/coregrind/m_demangle/demangle.c", "last_update_at": "2018-03-30T15:27:51+00:00", "question_id": "5fc47f3e5d3b786f5c45c643fc53f60d9b0858bd_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["Bool VG_(maybe_Z_demangle) ( const HChar* sym, \n                             /*OUT*/HChar* so, Int soLen,\n                             /*OUT*/HChar* fn, Int fnLen,\n                             /*OUT*/Bool* isWrap,\n                             /*OUT*/Int*  eclassTag,\n                             /*OUT*/Int*  eclassPrio )\n{\n#  define EMITSO(ch)                           \\\n      do {                                     \\\n         if (so) {                             \\\n            if (soi >= soLen) {                \\\n               so[soLen-1] = 0; oflow = True;  \\\n            } else {                           \\\n               so[soi++] = ch; so[soi] = 0;    \\\n            }                                  \\\n         }                                     \\\n      } while (0)\n#  define EMITFN(ch)                           \\\n      do {                                     \\\n         if (fni >= fnLen) {                   \\\n            fn[fnLen-1] = 0; oflow = True;     \\\n         } else {                              \\\n            fn[fni++] = ch; fn[fni] = 0;       \\\n         }                                     \\\n      } while (0)\n   Bool error, oflow, valid, fn_is_encoded, is_VG_Z_prefixed;\n   Int  soi, fni, i;\n   vg_assert(soLen > 0 || (soLen == 0 && so == NULL));\n   vg_assert(fnLen > 0);\n   error = False;\n   oflow = False;\n   soi = 0;\n   fni = 0;\n   valid =     sym[0] == '_'\n           &&  sym[1] == 'v'\n           &&  sym[2] == 'g'\n           && (sym[3] == 'r' || sym[3] == 'w')\n           &&  VG_(isdigit)(sym[4])\n           &&  VG_(isdigit)(sym[5])\n           &&  VG_(isdigit)(sym[6])\n           &&  VG_(isdigit)(sym[7])\n           &&  VG_(isdigit)(sym[8])\n           &&  sym[9] == 'Z'\n           && (sym[10] == 'Z' || sym[10] == 'U')\n           &&  sym[11] == '_';\n   if (valid\n       && sym[4] == '0' && sym[5] == '0' && sym[6] == '0' && sym[7] == '0'\n       && sym[8] != '0') {\n      /* If the eclass tag is 0000 (meaning \"no eclass\"), the priority\n         must be 0 too. */\n      valid = False;\n   }\n   if (!valid)\n      return False;\n   fn_is_encoded = sym[10] == 'Z';\n   if (isWrap)\n      *isWrap = sym[3] == 'w';\n   if (eclassTag) {\n      *eclassTag =    1000 * ((Int)sym[4] - '0')\n                   +  100 * ((Int)sym[5] - '0')\n                   +  10 * ((Int)sym[6] - '0')\n                   +  1 * ((Int)sym[7] - '0');\n      vg_assert(*eclassTag >= 0 && *eclassTag <= 9999);\n   }\n   if (eclassPrio) {\n      *eclassPrio = ((Int)sym[8]) - '0';\n      vg_assert(*eclassPrio >= 0 && *eclassPrio <= 9);\n   }\n   /* Now check the soname prefix isn't \"VG_Z_\", as described in\n      pub_tool_redir.h. */\n   is_VG_Z_prefixed =\n      sym[12] == 'V' &&\n      sym[13] == 'G' &&\n      sym[14] == '_' &&\n      sym[15] == 'Z' &&\n      sym[16] == '_';\n   if (is_VG_Z_prefixed) {\n      vg_assert2(0, \"symbol with a 'VG_Z_' prefix: %s.\\n\"\n                    \"see pub_tool_redir.h for an explanation.\", sym);\n   }\n   /* Now scan the Z-encoded soname. */\n   i = 12;\n   while (True) {\n      if (sym[i] == '_')\n      /* Found the delimiter.  Move on to the fnname loop. */\n         break;\n      if (sym[i] == 0) {\n         error = True;\n         goto out;\n      }\n      if (sym[i] != 'Z') {\n         EMITSO(sym[i]);\n         i++;\n         continue;\n      }\n      /* We've got a Z-escape. */\n      i++;\n      switch (sym[i]) {\n         case 'a': EMITSO('*'); break;\n         case 'c': EMITSO(':'); break;\n         case 'd': EMITSO('.'); break;\n         case 'h': EMITSO('-'); break;\n         case 'p': EMITSO('+'); break;\n         case 's': EMITSO(' '); break;\n         case 'u': EMITSO('_'); break;\n         case 'A': EMITSO('@'); break;\n         case 'D': EMITSO('$'); break;\n         case 'L': EMITSO('('); break;\n         case 'R': EMITSO(')'); break;\n         case 'Z': EMITSO('Z'); break;\n         default: error = True; goto out;\n      }\n      i++;\n   }\n   vg_assert(sym[i] == '_');\n   i++;\n   /* Now deal with the function name part. */\n   if (!fn_is_encoded) {\n      /* simple; just copy. */\n      while (True) {\n         if (sym[i] == 0)\n            break;\n         EMITFN(sym[i]);\n         i++;\n      }\n      goto out;\n   }\n   /* else use a Z-decoding loop like with soname */\n   while (True) {\n      if (sym[i] == 0)\n         break;\n      if (sym[i] != 'Z') {\n         EMITFN(sym[i]);\n         i++;\n         continue;\n      }\n      /* We've got a Z-escape. */\n      i++;\n      switch (sym[i]) {\n         case 'a': EMITFN('*'); break;\n         case 'c': EMITFN(':'); break;\n         case 'd': EMITFN('.'); break;\n         case 'h': EMITFN('-'); break;\n         case 'p': EMITFN('+'); break;\n         case 's': EMITFN(' '); break;\n         case 'u': EMITFN('_'); break;\n         case 'A': EMITFN('@'); break;\n         case 'D': EMITFN('$'); break;\n         case 'L': EMITFN('('); break;\n         case 'R': EMITFN(')'); break;\n         case 'Z': EMITFN('Z'); break;\n         default: error = True; goto out;\n      }\n      i++;\n   }\n  out:\n   EMITSO(0);\n   EMITFN(0);\n   if (error) {\n      /* Something's wrong.  Give up. */\n      VG_(message)(Vg_UserMsg,\n                   \"m_demangle: error Z-demangling: %s\\n\", sym);\n      return False;\n   }\n   if (oflow) {\n      /* It didn't fit.  Give up. */\n      VG_(message)(Vg_UserMsg,\n                   \"m_demangle: oflow Z-demangling: %s\\n\", sym);\n      return False;\n   }\n   return True;\n"]], "pred": {"ppl": 1.8738211393356323, "ppl_lower": 2.0327906608581543, "ppl/lowercase_ppl": -1.1296695070162444, "ppl/zlib": 0.0004397617198906392, "Min_5.0% Prob": 6.3383422084883145, "Min_10.0% Prob": 4.607249646794562, "Min_20.0% Prob": 2.88859233055629, "Min_30.0% Prob": 2.0477394064754444, "Min_40.0% Prob": 1.5578599061115592, "Min_50.0% Prob": 1.2538670752518273, "Min_60.0% Prob": 1.0471285416814538}}
{"hexsha": "0dbfa60e1c29bd15177250bd5caf7d90b9874076", "ext": "c", "lang": "C", "content": "void tdeletechar(int n) {\n  int dst, src, size;\n  Character *line;\n\n  LIMIT(n, 0, terminal.col - terminal.cursor.x);\n\n  dst = terminal.cursor.x;\n  src = terminal.cursor.x + n;\n  size = terminal.col - src;\n  line = terminal.line[terminal.cursor.y];\n\n  memmove(&line[dst], &line[src], size * sizeof(Character));\n  tclearregion(terminal.col - n, terminal.cursor.y, terminal.col - 1,\n               terminal.cursor.y);\n}", "item_id": 34, "repo": "yursha/terminal-emulator", "file": "bw.c", "last_update_at": "2018-08-16T21:11:56+00:00", "question_id": "0dbfa60e1c29bd15177250bd5caf7d90b9874076_34", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void tdeletechar(int n) {\n  int dst, src, size;\n  Character *line;\n  LIMIT(n, 0, terminal.col - terminal.cursor.x);\n  dst = terminal.cursor.x;\n  src = terminal.cursor.x + n;\n  size = terminal.col - src;\n  line = terminal.line[terminal.cursor.y];\n  memmove(&line[dst], &line[src], size * sizeof(Character));\n  tclearregion(terminal.col - n, terminal.cursor.y, terminal.col - 1,\n               terminal.cursor.y);\n"]], "pred": {"ppl": 2.660926580429077, "ppl_lower": 2.7352089881896973, "ppl/lowercase_ppl": -1.0281334065674017, "ppl/zlib": 0.0047974235325735646, "Min_5.0% Prob": 9.59869909286499, "Min_10.0% Prob": 7.214950237955366, "Min_20.0% Prob": 4.353853201044017, "Min_30.0% Prob": 3.117948525331237, "Min_40.0% Prob": 2.4192358922150174, "Min_50.0% Prob": 1.9625514687819254, "Min_60.0% Prob": 1.636506565187252}}
{"hexsha": "ab98a3da709534dacefa70125230269da8c56f09", "ext": "c", "lang": "C", "content": "void k_uart_console_init(void)\n{\n    KUARTConf conf = k_uart_conf_defaults();\n    conf.baud_rate = K_UART_CONSOLE_BAUDRATE;\n    // TODO: allow more configuration of console UART device\n\n    k_uart_init(K_UART_CONSOLE, &conf);\n}", "item_id": 3, "repo": "srjustice/kubos", "file": "hal/kubos-hal/source/uart.c", "last_update_at": "2018-01-05T00:15:13+00:00", "question_id": "ab98a3da709534dacefa70125230269da8c56f09_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void k_uart_console_init(void)\n{\n    KUARTConf conf = k_uart_conf_defaults();\n    conf.baud_rate = K_UART_CONSOLE_BAUDRATE;\n    // TODO: allow more configuration of console UART device\n    k_uart_init(K_UART_CONSOLE, &conf);\n"]], "pred": {"ppl": 4.304254531860352, "ppl_lower": 5.255375862121582, "ppl/lowercase_ppl": -1.136782012392036, "ppl/zlib": 0.008688118806870624, "Min_5.0% Prob": 7.9998791217803955, "Min_10.0% Prob": 6.8450427585177955, "Min_20.0% Prob": 5.479225317637126, "Min_30.0% Prob": 4.339065851988615, "Min_40.0% Prob": 3.499002296063635, "Min_50.0% Prob": 2.840428332271783, "Min_60.0% Prob": 2.417203137820417}}
{"hexsha": "4e2870d3c26c76b83261f2ba834f4420335c7950", "ext": "c", "lang": "C", "content": "static HRESULT WINAPI rendertarget_DrawGlyphRun(IDWriteBitmapRenderTarget1 *iface,\n    FLOAT baselineOriginX, FLOAT baselineOriginY, DWRITE_MEASURING_MODE measuring_mode,\n    DWRITE_GLYPH_RUN const* glyph_run, IDWriteRenderingParams* params, COLORREF textColor,\n    RECT *blackbox_rect)\n{\n    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget1(iface);\n    FIXME(\"(%p)->(%f %f %d %p %p 0x%08x %p): stub\\n\", This, baselineOriginX, baselineOriginY,\n        measuring_mode, glyph_run, params, textColor, blackbox_rect);\n    return E_NOTIMPL;\n}", "item_id": 4, "repo": "Svyatpro/winelastd3d10", "file": "dlls/dwrite/gdiinterop.c", "last_update_at": "2018-12-26T05:06:47+00:00", "question_id": "4e2870d3c26c76b83261f2ba834f4420335c7950_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static HRESULT WINAPI rendertarget_DrawGlyphRun(IDWriteBitmapRenderTarget1 *iface,\n    FLOAT baselineOriginX, FLOAT baselineOriginY, DWRITE_MEASURING_MODE measuring_mode,\n    DWRITE_GLYPH_RUN const* glyph_run, IDWriteRenderingParams* params, COLORREF textColor,\n    RECT *blackbox_rect)\n{\n    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget1(iface);\n    FIXME(\"(%p)->(%f %f %d %p %p 0x%08x %p): stub\\n\", This, baselineOriginX, baselineOriginY,\n        measuring_mode, glyph_run, params, textColor, blackbox_rect);\n    return E_NOTIMPL;\n"]], "pred": {"ppl": 1.4635714292526245, "ppl_lower": 2.748749017715454, "ppl/lowercase_ppl": -2.654764964189793, "ppl/zlib": 0.001147227810545132, "Min_5.0% Prob": 5.2331441879272464, "Min_10.0% Prob": 3.2876889020204545, "Min_20.0% Prob": 1.876446209102869, "Min_30.0% Prob": 1.2670774424112723, "Min_40.0% Prob": 0.9578056092787948, "Min_50.0% Prob": 0.7614757993861156, "Min_60.0% Prob": 0.6368212363402146}}
{"hexsha": "d923330e171e5ed9091c639b1a62f0351f74c61c", "ext": "c", "lang": "C", "content": "void\nxcwm_window_remove_damage(xcwm_window_t *window)\n{\n    xcb_xfixes_region_t region = xcb_generate_id(window->context->conn);\n    xcb_rectangle_t rect;\n    xcb_void_cookie_t cookie;\n\n    if (!window) {\n        return;\n    }\n\n    rect.x = window->dmg_bounds.x;\n    rect.y = window->dmg_bounds.y;\n    rect.width = window->dmg_bounds.width;\n    rect.height = window->dmg_bounds.height;\n\n    xcb_xfixes_create_region(window->context->conn,\n                             region,\n                             1,\n                             &rect);\n\n    cookie = xcb_damage_subtract_checked(window->context->conn,\n                                         window->damage,\n                                         region,\n                                         0);\n\n    if (!(_xcwm_request_check(window->context->conn, cookie,\n                              \"Failed to subtract damage\"))) {\n        window->dmg_bounds.x = 0;\n        window->dmg_bounds.y = 0;\n        window->dmg_bounds.width = 0;\n        window->dmg_bounds.height = 0;\n    }\n    return;\n}", "item_id": 5, "repo": "jon-turney/libxcwm", "file": "src/libxcwm/window.c", "last_update_at": "2018-11-21T12:42:10+00:00", "question_id": "d923330e171e5ed9091c639b1a62f0351f74c61c_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nxcwm_window_remove_damage(xcwm_window_t *window)\n{\n    xcb_xfixes_region_t region = xcb_generate_id(window->context->conn);\n    xcb_rectangle_t rect;\n    xcb_void_cookie_t cookie;\n    if (!window) {\n        return;\n    }\n    rect.x = window->dmg_bounds.x;\n    rect.y = window->dmg_bounds.y;\n    rect.width = window->dmg_bounds.width;\n    rect.height = window->dmg_bounds.height;\n    xcb_xfixes_create_region(window->context->conn,\n                             region,\n                             1,\n                             &rect);\n    cookie = xcb_damage_subtract_checked(window->context->conn,\n                                         window->damage,\n                                         region,\n                                         0);\n    if (!(_xcwm_request_check(window->context->conn, cookie,\n                              \"Failed to subtract damage\"))) {\n        window->dmg_bounds.x = 0;\n        window->dmg_bounds.y = 0;\n        window->dmg_bounds.width = 0;\n        window->dmg_bounds.height = 0;\n    }\n    return;\n"]], "pred": {"ppl": 1.790895938873291, "ppl_lower": 1.7976347208023071, "ppl/lowercase_ppl": -1.0064452280782858, "ppl/zlib": 0.0018153147013777935, "Min_5.0% Prob": 6.653689473867416, "Min_10.0% Prob": 4.519267953932285, "Min_20.0% Prob": 2.701573955095731, "Min_30.0% Prob": 1.9096406423011605, "Min_40.0% Prob": 1.4554696168665213, "Min_50.0% Prob": 1.1672510419824593, "Min_60.0% Prob": 0.972810708323191}}
{"hexsha": "1912d2b54f9c18bf78cd92c9dcd6a0fbe5beab90", "ext": "c", "lang": "C", "content": "void\ntest__parseGPHDUri__NegativeTestMissingValue(void **state)\n{\n\tchar* uri_missing_value = \"pxf://1.2.3.4:5678/some/path/and/table.tbl?FRAGMENTER=\";\n\n\t/* Setting the test -- code omitted -- */\n\tPG_TRY();\n\t{\n\t\t/* This will throw a ereport(ERROR).*/\n\t\tGPHDUri* parsed = parseGPHDUri(uri_missing_value);\n\t}\n\tPG_CATCH();\n\t{\n\t\tCurrentMemoryContext = 1;\n\t\tErrorData *edata = CopyErrorData();\n\n\t\t/*Validate the type of expected error */\n\t\tassert_true(edata->sqlerrcode == ERRCODE_SYNTAX_ERROR);\n\t\tassert_true(edata->elevel == ERROR);\n\t\tassert_string_equal(edata->message, \"Invalid URI pxf://1.2.3.4:5678/some/path/and/table.tbl?FRAGMENTER=: option 'FRAGMENTER=' missing value after '='\");\n\t\telog_dismiss(INFO);\n\t\treturn;\n\t}\n\tPG_END_TRY();\n\n\tassert_true(false);\n}", "item_id": 8, "repo": "dcomingore/hawq", "file": "src/backend/access/external/test/pxfuriparser_test.c", "last_update_at": "2018-08-30T01:45:36+00:00", "question_id": "1912d2b54f9c18bf78cd92c9dcd6a0fbe5beab90_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\ntest__parseGPHDUri__NegativeTestMissingValue(void **state)\n{\n\tchar* uri_missing_value = \"pxf://1.2.3.4:5678/some/path/and/table.tbl?FRAGMENTER=\";\n\t/* Setting the test -- code omitted -- */\n\tPG_TRY();\n\t{\n\t\t/* This will throw a ereport(ERROR).*/\n\t\tGPHDUri* parsed = parseGPHDUri(uri_missing_value);\n\t}\n\tPG_CATCH();\n\t{\n\t\tCurrentMemoryContext = 1;\n\t\tErrorData *edata = CopyErrorData();\n\t\t/*Validate the type of expected error */\n\t\tassert_true(edata->sqlerrcode == ERRCODE_SYNTAX_ERROR);\n\t\tassert_true(edata->elevel == ERROR);\n\t\tassert_string_equal(edata->message, \"Invalid URI pxf://1.2.3.4:5678/some/path/and/table.tbl?FRAGMENTER=: option 'FRAGMENTER=' missing value after '='\");\n\t\telog_dismiss(INFO);\n\t\treturn;\n\t}\n\tPG_END_TRY();\n\tassert_true(false);\n"]], "pred": {"ppl": 3.1432864665985107, "ppl_lower": 4.817093372344971, "ppl/lowercase_ppl": -1.37275247249841, "ppl/zlib": 0.002567867484265198, "Min_5.0% Prob": 8.288623015085856, "Min_10.0% Prob": 6.704646971917922, "Min_20.0% Prob": 4.68928847615681, "Min_30.0% Prob": 3.569466265251762, "Min_40.0% Prob": 2.8044134143769273, "Min_50.0% Prob": 2.2779226105355614, "Min_60.0% Prob": 1.9139516173126667}}
{"hexsha": "bb6da4fce2d7632f3ea07eedd8c087b534314651", "ext": "c", "lang": "C", "content": "static void test4()\n{\n\tchar *m = mm(0, pgsz * 5, PROT_READ|PROT_WRITE);\n\n\tmprotect(m, pgsz, PROT_WRITE);\n\tVALGRIND_CHECK_MEM_IS_DEFINED(m, pgsz); /* OK */\n\tm[44] = 'y';\t\t/* OK */\n\n\tmprotect(m, pgsz*5, PROT_NONE);\n\tm[55] = 'x';\t\t/* permission fault, but no tool complaint */\n}", "item_id": 4, "repo": "sjcappella/avalanche", "file": "valgrind/memcheck/tests/addressable.c", "last_update_at": "2018-03-30T15:27:51+00:00", "question_id": "bb6da4fce2d7632f3ea07eedd8c087b534314651_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void test4()\n{\n\tchar *m = mm(0, pgsz * 5, PROT_READ|PROT_WRITE);\n\tmprotect(m, pgsz, PROT_WRITE);\n\tVALGRIND_CHECK_MEM_IS_DEFINED(m, pgsz); /* OK */\n\tm[44] = 'y';\t\t/* OK */\n\tmprotect(m, pgsz*5, PROT_NONE);\n\tm[55] = 'x';\t\t/* permission fault, but no tool complaint */\n"]], "pred": {"ppl": 4.151513576507568, "ppl_lower": 4.843963146209717, "ppl/lowercase_ppl": -1.1083689217692454, "ppl/zlib": 0.006778442785619924, "Min_5.0% Prob": 8.151668207986015, "Min_10.0% Prob": 6.652904374258859, "Min_20.0% Prob": 5.001793452671596, "Min_30.0% Prob": 4.058851877848308, "Min_40.0% Prob": 3.3967665966067995, "Min_50.0% Prob": 2.829285266143935, "Min_60.0% Prob": 2.3823991165984246}}
{"hexsha": "836f998db7a6e5c204f73097460edde865bbbf6b", "ext": "c", "lang": "C", "content": "void BTSH_Op_FMOV_RegLdR0m_DR(BTESH2_CpuState *cpu, BTESH2_Opcode *op)\n{\n\tcpu->ptcpc=op->pc;\n\tcpu->fregs[op->rn^0]=BTESH2_GetAddrDWord(cpu,\n\t\tcpu->regs[op->rm]+cpu->regs[op->ro]+0);\n\tcpu->fregs[op->rn^1]=BTESH2_GetAddrDWord(cpu,\n\t\tcpu->regs[op->rm]+cpu->regs[op->ro]+4);\n}", "item_id": 61, "repo": "cr88192/bgbtech_shxemu", "file": "sh2emu/btesh2/btesh2_opfpari_0.c", "last_update_at": "2018-04-12T20:42:03+00:00", "question_id": "836f998db7a6e5c204f73097460edde865bbbf6b_61", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void BTSH_Op_FMOV_RegLdR0m_DR(BTESH2_CpuState *cpu, BTESH2_Opcode *op)\n{\n\tcpu->ptcpc=op->pc;\n\tcpu->fregs[op->rn^0]=BTESH2_GetAddrDWord(cpu,\n\t\tcpu->regs[op->rm]+cpu->regs[op->ro]+0);\n\tcpu->fregs[op->rn^1]=BTESH2_GetAddrDWord(cpu,\n\t\tcpu->regs[op->rm]+cpu->regs[op->ro]+4);\n"]], "pred": {"ppl": 3.157757520675659, "ppl_lower": 3.8868961334228516, "ppl/lowercase_ppl": -1.1806727903990015, "ppl/zlib": 0.007665747535503751, "Min_5.0% Prob": 8.120622098445892, "Min_10.0% Prob": 6.745609849691391, "Min_20.0% Prob": 5.046023398637772, "Min_30.0% Prob": 3.7447261636455855, "Min_40.0% Prob": 2.871389158302918, "Min_50.0% Prob": 2.3109604549128564, "Min_60.0% Prob": 1.9280822940393894}}
{"hexsha": "80574feb01fb1c6b8bde23b18b39b4436b316cbf", "ext": "c", "lang": "C", "content": "static inline UWord ROLW ( UWord w, Int n )\n{\n   Int bpw = 8 * sizeof(UWord);\n   w = (w << n) | (w >> (bpw-n));\n   return w;\n}", "item_id": 3, "repo": "sjcappella/avalanche", "file": "valgrind/coregrind/m_execontext.c", "last_update_at": "2018-03-30T15:27:51+00:00", "question_id": "80574feb01fb1c6b8bde23b18b39b4436b316cbf_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline UWord ROLW ( UWord w, Int n )\n{\n   Int bpw = 8 * sizeof(UWord);\n   w = (w << n) | (w >> (bpw-n));\n   return w;\n"]], "pred": {"ppl": 3.9517900943756104, "ppl_lower": 4.279644966125488, "ppl/lowercase_ppl": -1.0579997140501505, "ppl/zlib": 0.012379897880213347, "Min_5.0% Prob": 7.688832998275757, "Min_10.0% Prob": 6.708594703674317, "Min_20.0% Prob": 5.160412831739946, "Min_30.0% Prob": 4.1492670213474945, "Min_40.0% Prob": 3.297120143537936, "Min_50.0% Prob": 2.701954172089182, "Min_60.0% Prob": 2.324586103505948}}
{"hexsha": "b77ff66e5a2465fd9182441562e417e4d968ffc3", "ext": "c", "lang": "C", "content": "es_result_e\nset_callback_for_userdata(es_read_userdata_cb readcb,\n                          es_write_userdata_cb writecb,\n                          es_free_userdata free_userdata)\n{\n  if (!g_enrollee) {\n    OC_ERR(\"Enrollee is not initialized!\");\n    return ES_ERROR;\n  }\n\n  if (!readcb && !writecb) {\n    OC_ERR(\"Invalid user attributes read/write callback!\");\n    return ES_ERROR;\n  }\n\n  g_enrollee->read_cb = readcb;\n  g_enrollee->write_cb = writecb;\n  g_enrollee->free_userdata = free_userdata;\n  return ES_OK;\n}", "item_id": 7, "repo": "agrkush/iotivity-constrained", "file": "service/easy-setup/enrollee/resourcehandler.c", "last_update_at": "2018-07-19T13:43:52+00:00", "question_id": "b77ff66e5a2465fd9182441562e417e4d968ffc3_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["es_result_e\nset_callback_for_userdata(es_read_userdata_cb readcb,\n                          es_write_userdata_cb writecb,\n                          es_free_userdata free_userdata)\n{\n  if (!g_enrollee) {\n    OC_ERR(\"Enrollee is not initialized!\");\n    return ES_ERROR;\n  }\n  if (!readcb && !writecb) {\n    OC_ERR(\"Invalid user attributes read/write callback!\");\n    return ES_ERROR;\n  }\n  g_enrollee->read_cb = readcb;\n  g_enrollee->write_cb = writecb;\n  g_enrollee->free_userdata = free_userdata;\n  return ES_OK;\n"]], "pred": {"ppl": 2.606206178665161, "ppl_lower": 2.934049129486084, "ppl/lowercase_ppl": -1.1236959778404945, "ppl/zlib": 0.004201296458255235, "Min_5.0% Prob": 8.533238463931614, "Min_10.0% Prob": 6.378892660140991, "Min_20.0% Prob": 4.169373886005299, "Min_30.0% Prob": 3.07606296560594, "Min_40.0% Prob": 2.4018161733810968, "Min_50.0% Prob": 1.9229913919923767, "Min_60.0% Prob": 1.5986244765309883}}
{"hexsha": "921a0b518ba4d28af3e7c4d7b1274975696a7833", "ext": "h", "lang": "C", "content": "interface PUPhotosSharingCollectionViewItemSublayout : NSObject {\n    struct CGRect { \n        struct CGPoint { \n            double x; \n            double y; \n        } origin; \n        struct CGSize { \n            double width; \n            double height; \n        } size; \n    }  _badgesContainerFrame;\n    unsigned long long  _badgesCorner;\n    struct UIOffset { \n        double horizontal; \n        double vertical; \n    }  _badgesOffset;\n    double  _bottomBadgeInset;\n    struct CGRect { \n        struct CGPoint { \n            double x; \n            double y; \n        } origin; \n        struct CGSize { \n            double width; \n            double height; \n        } size; \n    }  _floatingBadgesContainerFrame;\n    NSIndexPath * _indexPath;\n    struct CGRect { \n        struct CGPoint { \n            double x; \n            double y; \n        } origin; \n        struct CGSize { \n            double width; \n            double height; \n        } size; \n    }  _itemFrame;\n    struct CGPoint { \n        double x; \n        double y; \n    }  _optionBadgeCenter;\n    UICollectionViewLayoutAttributes * _optionBadgeLayoutAttributes;\n    struct CGPoint { \n        double x; \n        double y; \n    }  _selectionBadgeCenter;\n    UICollectionViewLayoutAttributes * _selectionBadgeLayoutAttributes;\n    struct CGRect { \n        struct CGPoint { \n            double x; \n            double y; \n        } origin; \n        struct CGSize { \n            double width; \n            double height; \n        } size; \n    }  _visibleItemFrame;\n}", "item_id": 0, "repo": "shaojiankui/iOS10-Runtime-Headers", "file": "Frameworks/PhotosUI.framework/PUPhotosSharingCollectionViewItemSublayout.h", "last_update_at": "2018-10-08T04:12:25+00:00", "question_id": "921a0b518ba4d28af3e7c4d7b1274975696a7833_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface PUPhotosSharingCollectionViewItemSublayout : NSObject {\n    struct CGRect { \n        struct CGPoint { \n            double x; \n            double y; \n        } origin; \n        struct CGSize { \n            double width; \n            double height; \n        } size; \n    }  _badgesContainerFrame;\n    unsigned long long  _badgesCorner;\n    struct UIOffset { \n        double horizontal; \n        double vertical; \n    }  _badgesOffset;\n    double  _bottomBadgeInset;\n    struct CGRect { \n        struct CGPoint { \n            double x; \n            double y; \n        } origin; \n        struct CGSize { \n            double width; \n            double height; \n        } size; \n    }  _floatingBadgesContainerFrame;\n    NSIndexPath * _indexPath;\n    struct CGRect { \n        struct CGPoint { \n            double x; \n            double y; \n        } origin; \n        struct CGSize { \n            double width; \n            double height; \n        } size; \n    }  _itemFrame;\n    struct CGPoint { \n        double x; \n        double y; \n    }  _optionBadgeCenter;\n    UICollectionViewLayoutAttributes * _optionBadgeLayoutAttributes;\n    struct CGPoint { \n        double x; \n        double y; \n    }  _selectionBadgeCenter;\n    UICollectionViewLayoutAttributes * _selectionBadgeLayoutAttributes;\n    struct CGRect { \n        struct CGPoint { \n            double x; \n            double y; \n        } origin; \n        struct CGSize { \n            double width; \n            double height; \n        } size; \n    }  _visibleItemFrame;\n"]], "pred": {"ppl": 1.6316776275634766, "ppl_lower": 1.8480629920959473, "ppl/lowercase_ppl": -1.2543446493591932, "ppl/zlib": 0.001483662742120157, "Min_5.0% Prob": 6.3627313659304665, "Min_10.0% Prob": 4.42720775944846, "Min_20.0% Prob": 2.445466062689529, "Min_30.0% Prob": 1.6420122007967715, "Min_40.0% Prob": 1.2268821053921677, "Min_50.0% Prob": 0.9792134771371269, "Min_60.0% Prob": 0.8179333993855407}}
{"hexsha": "4ff722b875c5ef6aad956e53e84f206df760b1c8", "ext": "c", "lang": "C", "content": "void hal_reboot(void)\n{\n    printf(\"reboot!\\n\");\n    vPortETSIntrLock();\n    krhino_sched_disable();\n    delay();\n    delay();\n    rom_i2c_writeReg(0x67, 4, 1, 8);\n    rom_i2c_writeReg(0x67, 4, 2, 0x81);\n    while(1) {\n        system_restart();\n        aos_msleep(100);\n    }\n}", "item_id": 0, "repo": "ruoranluomu/AliOS-Things", "file": "platform/mcu/esp8266/hal/misc.c", "last_update_at": "2018-11-28T03:19:22+00:00", "question_id": "4ff722b875c5ef6aad956e53e84f206df760b1c8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void hal_reboot(void)\n{\n    printf(\"reboot!\\n\");\n    vPortETSIntrLock();\n    krhino_sched_disable();\n    delay();\n    delay();\n    rom_i2c_writeReg(0x67, 4, 1, 8);\n    rom_i2c_writeReg(0x67, 4, 2, 0x81);\n    while(1) {\n        system_restart();\n        aos_msleep(100);\n    }\n"]], "pred": {"ppl": 3.6622397899627686, "ppl_lower": 5.054791450500488, "ppl/lowercase_ppl": -1.2482612249060179, "ppl/zlib": 0.007211527359500437, "Min_5.0% Prob": 9.076690196990967, "Min_10.0% Prob": 7.144850107339712, "Min_20.0% Prob": 5.043259804065411, "Min_30.0% Prob": 3.938635153648181, "Min_40.0% Prob": 3.1420107008172917, "Min_50.0% Prob": 2.5741295518783422, "Min_60.0% Prob": 2.163736950128506}}
{"hexsha": "9e029e62e46e673107afa1edfe5985addeb5743c", "ext": "c", "lang": "C", "content": "static int\nmacip_acl_interface_add_del_acl (u32 sw_if_index, u8 is_add,\n\t\t\t\t u32 acl_list_index)\n{\n  acl_main_t *am = &acl_main;\n  int rv = -1;\n  if (is_add)\n    {\n      rv = macip_acl_interface_add_acl (am, sw_if_index, acl_list_index);\n    }\n  else\n    {\n      rv = macip_acl_interface_del_acl (am, sw_if_index);\n    }\n  return rv;\n}", "item_id": 28, "repo": "LabNConsulting/vpp-marvell", "file": "src/plugins/acl/acl.c", "last_update_at": "2018-12-10T09:59:19+00:00", "question_id": "9e029e62e46e673107afa1edfe5985addeb5743c_28", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nmacip_acl_interface_add_del_acl (u32 sw_if_index, u8 is_add,\n\t\t\t\t u32 acl_list_index)\n{\n  acl_main_t *am = &acl_main;\n  int rv = -1;\n  if (is_add)\n    {\n      rv = macip_acl_interface_add_acl (am, sw_if_index, acl_list_index);\n    }\n  else\n    {\n      rv = macip_acl_interface_del_acl (am, sw_if_index);\n    }\n  return rv;\n"]], "pred": {"ppl": 1.7661610841751099, "ppl_lower": 1.7661610841751099, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0033459312480247218, "Min_5.0% Prob": 6.078335642814636, "Min_10.0% Prob": 4.314650774002075, "Min_20.0% Prob": 2.6786082820458845, "Min_30.0% Prob": 1.890422449428208, "Min_40.0% Prob": 1.4244554699821905, "Min_50.0% Prob": 1.136495097495436, "Min_60.0% Prob": 0.9535418287498143}}
{"hexsha": "55acd95e4c2ad8dd9ace80d0857bd3a5752bd53e", "ext": "c", "lang": "C", "content": "Token token_duplicate(Token source)\n{\n  Token token;\n\n  token.type   = source.type;\n  token.line   = source.line;\n  token.col    = source.col;\n\n  if(source.lexeme != NULL)\n    token.lexeme = string_copy(source.lexeme, strlen(source.lexeme));\n\n  return token;\n}", "item_id": 1, "repo": "dlains/cube", "file": "src/token.c", "last_update_at": "2018-08-20T00:28:37+00:00", "question_id": "55acd95e4c2ad8dd9ace80d0857bd3a5752bd53e_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["Token token_duplicate(Token source)\n{\n  Token token;\n  token.type   = source.type;\n  token.line   = source.line;\n  token.col    = source.col;\n  if(source.lexeme != NULL)\n    token.lexeme = string_copy(source.lexeme, strlen(source.lexeme));\n  return token;\n"]], "pred": {"ppl": 2.8382201194763184, "ppl_lower": 3.126601219177246, "ppl/lowercase_ppl": -1.0927641159278838, "ppl/zlib": 0.007194325084198159, "Min_5.0% Prob": 9.363605260848999, "Min_10.0% Prob": 6.481295347213745, "Min_20.0% Prob": 4.460902730623881, "Min_30.0% Prob": 3.289798291666167, "Min_40.0% Prob": 2.616175353124335, "Min_50.0% Prob": 2.0803181456917144, "Min_60.0% Prob": 1.7494366491113655}}
{"hexsha": "9e364f9e4de2f93c694cae0b58beb6f8f68c3d8a", "ext": "c", "lang": "C", "content": "static int\nbce_init_tx_chain(struct bce_tx_ring *txr)\n{\n\tstruct tx_bd *txbd;\n\tint i, rc = 0;\n\n\t/* Set the initial TX producer/consumer indices. */\n\ttxr->tx_prod = 0;\n\ttxr->tx_cons = 0;\n\ttxr->tx_prod_bseq = 0;\n\ttxr->used_tx_bd = 0;\n\ttxr->max_tx_bd = USABLE_TX_BD(txr);\n\n\t/*\n\t * The NetXtreme II supports a linked-list structre called\n\t * a Buffer Descriptor Chain (or BD chain).  A BD chain\n\t * consists of a series of 1 or more chain pages, each of which\n\t * consists of a fixed number of BD entries.\n\t * The last BD entry on each page is a pointer to the next page\n\t * in the chain, and the last pointer in the BD chain\n\t * points back to the beginning of the chain.\n\t */\n\n\t/* Set the TX next pointer chain entries. */\n\tfor (i = 0; i < txr->tx_pages; i++) {\n\t\tint j;\n\n\t\ttxbd = &txr->tx_bd_chain[i][USABLE_TX_BD_PER_PAGE];\n\n\t\t/* Check if we've reached the last page. */\n\t\tif (i == (txr->tx_pages - 1))\n\t\t\tj = 0;\n\t\telse\n\t\t\tj = i + 1;\n\n\t\ttxbd->tx_bd_haddr_hi =\n\t\t    htole32(BCE_ADDR_HI(txr->tx_bd_chain_paddr[j]));\n\t\ttxbd->tx_bd_haddr_lo =\n\t\t    htole32(BCE_ADDR_LO(txr->tx_bd_chain_paddr[j]));\n\t}\n\tbce_init_tx_context(txr);\n\n\treturn(rc);\n}", "item_id": 49, "repo": "jorisgio/DragonFlyBSD", "file": "sys/dev/netif/bce/if_bce.c", "last_update_at": "2018-01-12T03:55:33+00:00", "question_id": "9e364f9e4de2f93c694cae0b58beb6f8f68c3d8a_49", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nbce_init_tx_chain(struct bce_tx_ring *txr)\n{\n\tstruct tx_bd *txbd;\n\tint i, rc = 0;\n\t/* Set the initial TX producer/consumer indices. */\n\ttxr->tx_prod = 0;\n\ttxr->tx_cons = 0;\n\ttxr->tx_prod_bseq = 0;\n\ttxr->used_tx_bd = 0;\n\ttxr->max_tx_bd = USABLE_TX_BD(txr);\n\t/*\n\t * The NetXtreme II supports a linked-list structre called\n\t * a Buffer Descriptor Chain (or BD chain).  A BD chain\n\t * consists of a series of 1 or more chain pages, each of which\n\t * consists of a fixed number of BD entries.\n\t * The last BD entry on each page is a pointer to the next page\n\t * in the chain, and the last pointer in the BD chain\n\t * points back to the beginning of the chain.\n\t */\n\t/* Set the TX next pointer chain entries. */\n\tfor (i = 0; i < txr->tx_pages; i++) {\n\t\tint j;\n\t\ttxbd = &txr->tx_bd_chain[i][USABLE_TX_BD_PER_PAGE];\n\t\t/* Check if we've reached the last page. */\n\t\tif (i == (txr->tx_pages - 1))\n\t\t\tj = 0;\n\t\telse\n\t\t\tj = i + 1;\n\t\ttxbd->tx_bd_haddr_hi =\n\t\t    htole32(BCE_ADDR_HI(txr->tx_bd_chain_paddr[j]));\n\t\ttxbd->tx_bd_haddr_lo =\n\t\t    htole32(BCE_ADDR_LO(txr->tx_bd_chain_paddr[j]));\n\t}\n\tbce_init_tx_context(txr);\n\treturn(rc);\n"]], "pred": {"ppl": 1.9864710569381714, "ppl_lower": 2.3000900745391846, "ppl/lowercase_ppl": -1.213573951250338, "ppl/zlib": 0.0011957486520710573, "Min_5.0% Prob": 5.903997898101807, "Min_10.0% Prob": 4.318058271034091, "Min_20.0% Prob": 2.8857193004851247, "Min_30.0% Prob": 2.156603413859224, "Min_40.0% Prob": 1.6875933405815386, "Min_50.0% Prob": 1.3676945380574348, "Min_60.0% Prob": 1.142506419191003}}
{"hexsha": "5a5c0aa596461e158761df79396b8ebe48584b92", "ext": "h", "lang": "C", "content": "off_t lseek(int fd, off_t offset, int whence) {\n\tunion {\n\t\toff_t o64;\n\t\tuint32 u32[2];\n\t} arg, ret;\n\targ.o64 = offset;\n\tasm volatile(\"int $0x80\" : \"=a\" (ret.u32[0]), \"=d\" (ret.u32[1]) : \"0\" (13), \"b\" (fd), \"c\" (arg.u32[0]), \"d\"(arg.u32[1]), \"S\"(whence));\n\treturn ret.o64;\n}", "item_id": 0, "repo": "TreyAJenkins/TextOS2", "file": "src/include/kernel/TextOS.h", "last_update_at": "2018-01-13T19:53:49+00:00", "question_id": "5a5c0aa596461e158761df79396b8ebe48584b92_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["off_t lseek(int fd, off_t offset, int whence) {\n\tunion {\n\t\toff_t o64;\n\t\tuint32 u32[2];\n\t} arg, ret;\n\targ.o64 = offset;\n\tasm volatile(\"int $0x80\" : \"=a\" (ret.u32[0]), \"=d\" (ret.u32[1]) : \"0\" (13), \"b\" (fd), \"c\" (arg.u32[0]), \"d\"(arg.u32[1]), \"S\"(whence));\n\treturn ret.o64;\n"]], "pred": {"ppl": 1.8321198225021362, "ppl_lower": 1.9622769355773926, "ppl/lowercase_ppl": -1.113352297337974, "ppl/zlib": 0.0032728306454542235, "Min_5.0% Prob": 6.163987040519714, "Min_10.0% Prob": 4.602638803422451, "Min_20.0% Prob": 2.8071016957983375, "Min_30.0% Prob": 1.963947140922149, "Min_40.0% Prob": 1.497679790132679, "Min_50.0% Prob": 1.2062956620939076, "Min_60.0% Prob": 1.0079069767186108}}
{"hexsha": "bb3f1938bad77ab7fc4811b63dda6cf98311f809", "ext": "c", "lang": "C", "content": "int32_t KEYSCAN_StructInit(stc_keyscan_init_t *pstcKeyscanInit)\n{\n    int32_t i32Ret = LL_OK;\n\n    if (NULL == pstcKeyscanInit) {\n        i32Ret = LL_ERR_INVD_PARAM;\n    } else {\n        pstcKeyscanInit->u32HizCycle = KEYSCAN_HIZ_CYCLE_4;\n        pstcKeyscanInit->u32LowCycle = KEYSCAN_LOW_CYCLE_4;\n        pstcKeyscanInit->u32KeyClock = KEYSCAN_CLK_HCLK;\n        pstcKeyscanInit->u32KeyOut   = KEYSCAN_OUT_0T1;\n        pstcKeyscanInit->u32KeyIn    = KEYSCAN_IN_0;\n    }\n    return i32Ret;\n}", "item_id": 0, "repo": "BreederBai/rt-thread", "file": "bsp/hc32/libraries/hc32f4a0_ddl/drivers/hc32_ll_driver/src/hc32_ll_keyscan.c", "last_update_at": "2018-11-27T02:48:44+00:00", "question_id": "bb3f1938bad77ab7fc4811b63dda6cf98311f809_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int32_t KEYSCAN_StructInit(stc_keyscan_init_t *pstcKeyscanInit)\n{\n    int32_t i32Ret = LL_OK;\n    if (NULL == pstcKeyscanInit) {\n        i32Ret = LL_ERR_INVD_PARAM;\n    } else {\n        pstcKeyscanInit->u32HizCycle = KEYSCAN_HIZ_CYCLE_4;\n        pstcKeyscanInit->u32LowCycle = KEYSCAN_LOW_CYCLE_4;\n        pstcKeyscanInit->u32KeyClock = KEYSCAN_CLK_HCLK;\n        pstcKeyscanInit->u32KeyOut   = KEYSCAN_OUT_0T1;\n        pstcKeyscanInit->u32KeyIn    = KEYSCAN_IN_0;\n    }\n    return i32Ret;\n"]], "pred": {"ppl": 1.885325312614441, "ppl_lower": 2.9677326679229736, "ppl/lowercase_ppl": -1.7154984832338471, "ppl/zlib": 0.0027689973172320085, "Min_5.0% Prob": 6.929741165854714, "Min_10.0% Prob": 4.9663015863169795, "Min_20.0% Prob": 2.9610696181337883, "Min_30.0% Prob": 2.0847865871020725, "Min_40.0% Prob": 1.577540300826126, "Min_50.0% Prob": 1.2718860575626803, "Min_60.0% Prob": 1.056517641380403}}
{"hexsha": "df356c375ba004290f2c4a213f5291ad70995822", "ext": "c", "lang": "C", "content": "static void tscpu_fast_initial_sw_workaround(void)\n{\n\tint i = 0;\n\tunsigned long flags;\n\t/* tscpu_printk(\"tscpu_fast_initial_sw_workaround\\n\"); */\n\n\t/* tscpu_thermal_clock_on(); */\n\n\tmt_ptp_lock(&flags);\n\n\tfor (i = 0; i < TS_LEN_ARRAY(tscpu_g_bank); i++) {\n\t\ttscpu_switch_bank(i);\n\t\ttscpu_thermal_fast_init();\n\t}\n\n\tmt_ptp_unlock(&flags);\n\n}", "item_id": 1, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_cpu.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "df356c375ba004290f2c4a213f5291ad70995822_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void tscpu_fast_initial_sw_workaround(void)\n{\n\tint i = 0;\n\tunsigned long flags;\n\t/* tscpu_printk(\"tscpu_fast_initial_sw_workaround\\n\"); */\n\t/* tscpu_thermal_clock_on(); */\n\tmt_ptp_lock(&flags);\n\tfor (i = 0; i < TS_LEN_ARRAY(tscpu_g_bank); i++) {\n\t\ttscpu_switch_bank(i);\n\t\ttscpu_thermal_fast_init();\n\t}\n\tmt_ptp_unlock(&flags);\n"]], "pred": {"ppl": 4.153717517852783, "ppl_lower": 4.313448905944824, "ppl/lowercase_ppl": -1.0264985779649367, "ppl/zlib": 0.006780970098566151, "Min_5.0% Prob": 8.605082094669342, "Min_10.0% Prob": 7.37568137049675, "Min_20.0% Prob": 5.61722195148468, "Min_30.0% Prob": 4.293672959009807, "Min_40.0% Prob": 3.430664638057351, "Min_50.0% Prob": 2.8170987935736775, "Min_60.0% Prob": 2.373872699060788}}
{"hexsha": "efdfd1b6782a78bcdf0006425c0e40f83dfa5a71", "ext": "c", "lang": "C", "content": "void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])\n{\n  /*****************************************************************************\n  ** this function takes a flag and a variable number of arguments\n  ** depending on the value of the flag and returns either a construct \n  ** containing probability estimates, a merged vector or a double value \n  ** representing an entropy or mutual information\n  *****************************************************************************/\n  \n  int flag, numberOfSamples, checkSamples, thirdCheckSamples, numberOfFeatures, checkFeatures, thirdCheckFeatures;\n  int vectorMismatch, columnMismatch, weightLength, weightWidth;\n  double *dataVector, *condVector, *targetVector, *firstVector, *secondVector, *output, *weightVector;\n  double *weightOutput, *jointWeight, *firstWeight, *secondWeight, *jointOutput, *firstOutput, *secondOutput;\n  double *numStates, *numJointStates, *numFirstStates, *numSecondStates;\n  WeightedProbState state;\n  WeightedJointProbState jointState;\n  int i;\n\n  switch (nrhs)\n  {\n    case 3:\n    {\n        /*printf(\"Must be H_w(X)\\n\");*/\n        break;\n    }\n    case 4:\n    {\n        /*printf(\"Must be H_w(XY), H_w(X|Y), I_w(X;Y)\\n\");*/\n        break;\n    }\n    case 5:\n    {\n        /*printf(\"Must be I_w(X;Y|Z)\\n\");*/\n        break;\n    }\n    default:\n    {\n        printf(\"Incorrect number of arguments, format is WeightedMIToolbox(\\\"FLAG\\\",varargin)\\n\");\n        break;\n    }\n  }\n  \n  vectorMismatch = 0;\n  columnMismatch = 0;\n\n  /* number to function map\n  ** 1 = H(X)\n  ** 2 = H(XY)\n  ** 3 = H(X|Y)\n  ** 4 = I(X;Y)\n  ** 5 = I(X;Y|Z)\n  ** 6 = calculateWeightedProbability\n  ** 7 = calculateWeightedJointProbability\n  */\n  \n  flag = *mxGetPr(prhs[0]);\n  weightLength = mxGetM(prhs[1]);\n  weightWidth = mxGetN(prhs[1]);\n  weightVector = (double *) mxGetPr(prhs[1]);\n  \n  switch (flag)\n  {\n    case 1:\n    {\n      /*\n      **H(X)\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      numberOfFeatures = mxGetN(prhs[2]);\n      dataVector = (double *) mxGetPr(prhs[2]);\n\n      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);\n      output = (double *)mxGetPr(plhs[0]);\n\n      if ((numberOfFeatures == 1) && (weightWidth == 1))\n      {\n        if (numberOfSamples == weightLength)\n        {\n          /*double calculateWeightedEntropy(double *dataVector, double *weightVector, int vectorLength);*/\n          *output = calculateWeightedEntropy(dataVector,weightVector,numberOfSamples);\n        }\n        else\n        {\n          vectorMismatch = 1;\n        }\n      }\n      else\n      {\n        columnMismatch = 1;\n      }\n      \n      break;\n    }/*case 1 - H(X)*/\n    case 2:\n    {\n      /*\n      **H(XY)\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      checkSamples = mxGetM(prhs[3]);\n      \n      numberOfFeatures = mxGetN(prhs[2]);\n      checkFeatures = mxGetN(prhs[3]);\n\n      firstVector = mxGetPr(prhs[2]);\n      secondVector = mxGetPr(prhs[3]);\n\n      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);\n      output = (double *)mxGetPr(plhs[0]);\n\n      if ((numberOfFeatures == 1) && (checkFeatures == 1) && (weightWidth == 1))\n      {\n        if ((numberOfSamples == 0) && (checkSamples == 0) && (weightLength == 0))\n        {\n          *output = 0.0;\n        }\n        else if ((numberOfSamples == 0) && (weightLength == checkSamples))\n        {\n          *output = calculateWeightedEntropy(secondVector,weightVector,numberOfSamples);\n        }\n        else if ((checkSamples == 0) && (weightLength == numberOfSamples))\n        {\n          *output = calculateWeightedEntropy(firstVector,weightVector,numberOfSamples);\n        }\n        else if ((numberOfSamples == checkSamples) && (numberOfSamples == weightLength))\n        {\n          /*double calculateWeightedJointEntropy(double *firstVector, double *secondVector, double *weightVector, int vectorLength);*/\n          *output = calculateWeightedJointEntropy(firstVector,secondVector,weightVector,numberOfSamples);\n        }\n        else\n        {\n          vectorMismatch = 1;\n        }\n      }\n      else\n      {\n        columnMismatch = 1;\n      }\n      \n      break;\n    }/*case 2 - H(XY)*/\n    case 3:\n    {\n      /*\n      **H(X|Y)\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      checkSamples = mxGetM(prhs[3]);\n      \n      numberOfFeatures = mxGetN(prhs[2]);\n      checkFeatures = mxGetN(prhs[3]);\n\n      dataVector = mxGetPr(prhs[2]);\n      condVector = mxGetPr(prhs[3]);\n\n      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);\n      output = (double *)mxGetPr(plhs[0]);\n\n      if ((numberOfFeatures == 1) && (checkFeatures == 1) && (weightWidth == 1))\n      {\n        if (numberOfSamples == 0)\n        {\n          *output = 0.0;\n        }\n        else if ((checkSamples == 0) && (weightLength == numberOfSamples))\n        {\n          *output = calculateWeightedEntropy(dataVector,weightVector,numberOfSamples);\n        }\n        else if ((numberOfSamples == checkSamples) && (numberOfSamples == weightLength))\n        {\n          /*double calculateWeightedConditionalEntropy(double *dataVector, double *condVector, double *weightVector, int vectorLength);*/\n          *output = calculateWeightedConditionalEntropy(dataVector,condVector,weightVector,numberOfSamples);\n        }\n        else\n        {\n          vectorMismatch = 1;\n        }\n      }\n      else\n      {\n        columnMismatch = 1;\n      }\n      break;\n    }/*case 3 - H(X|Y)*/\n    case 4:\n    {\n      /*\n      **I(X;Y)\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      checkSamples = mxGetM(prhs[3]);\n      \n      numberOfFeatures = mxGetN(prhs[2]);\n      checkFeatures = mxGetN(prhs[3]);\n\n      firstVector = mxGetPr(prhs[2]);\n      secondVector = mxGetPr(prhs[3]);\n\n      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);\n      output = (double *)mxGetPr(plhs[0]);\n\n      if ((numberOfFeatures == 1) && (checkFeatures == 1) && (weightWidth == 1))\n      {\n        if ((numberOfSamples == 0) || (checkSamples == 0))\n        {\n          *output = 0.0;\n        }\n        else if ((numberOfSamples == checkSamples) && (numberOfSamples == weightLength))\n        {\n          /*double calculateWeightedMutualInformation(double *firstVector, double *secondVector, double *weightVector, int vectorLength);*/\n          *output = calculateWeightedMutualInformation(firstVector,secondVector,weightVector,numberOfSamples);\n        }\n        else\n        {\n          vectorMismatch = 1;\n        }\n      }\n      else\n      {\n        columnMismatch = 1;\n      }\n      break;\n    }/*case 4 - I(X;Y)*/\n    case 5:\n    {\n      /*\n      **I(X;Y|Z)\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      checkSamples = mxGetM(prhs[3]);\n      thirdCheckSamples = mxGetM(prhs[4]);\n      \n      numberOfFeatures = mxGetN(prhs[2]);\n      checkFeatures = mxGetN(prhs[3]);\n      thirdCheckFeatures = mxGetN(prhs[4]);\n\n      firstVector = mxGetPr(prhs[2]);\n      targetVector = mxGetPr(prhs[3]);\n      condVector = mxGetPr(prhs[4]);\n\n      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);\n      output = (double *)mxGetPr(plhs[0]);\n      \n      if ((numberOfFeatures == 1) && (checkFeatures == 1) && (weightWidth == 1))\n      {\n        if ((numberOfSamples == 0) || (checkSamples == 0))\n        {\n          *output = 0.0;\n        }\n        else if ((numberOfSamples == checkSamples) && (numberOfSamples == weightLength))\n        {\n          if ((thirdCheckSamples == 0) || (thirdCheckFeatures != 1))\n          {\n            *output = calculateWeightedMutualInformation(firstVector,targetVector,weightVector,numberOfSamples);\n          }\n          else if (numberOfSamples == thirdCheckSamples)\n          {\n            /*double calculateWeightedConditionalMutualInformation(double *firstVector, double *targetVector, double *condVector, double *weightVector, int vectorLength);*/\n            *output = calculateWeightedConditionalMutualInformation(firstVector,targetVector,condVector,weightVector,numberOfSamples);\n          }\n          else\n          {\n            vectorMismatch = 1;\n          }\n        }\n        else\n        {\n          vectorMismatch = 1;\n        }\n      }\n      else\n      {\n        columnMismatch = 1;\n      }\n      break;\n    }/*case 5 - I(X;Y|Z)*/\n    case 6:\n    {\n      /*\n      **calculateWeightedProbability\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      dataVector = (double *) mxGetPr(prhs[2]);\n\n      /*WeightedProbabilityState calculateWeightedProbability(double *dataVector, double *weightVector, int vectorLength);*/\n      state = calculateWeightedProbability(dataVector,weightVector,numberOfSamples);\n      \n      plhs[0] = mxCreateDoubleMatrix(state.numStates,1,mxREAL);\n      plhs[1] = mxCreateDoubleMatrix(state.numStates,1,mxREAL);\n      plhs[2] = mxCreateDoubleMatrix(1,1,mxREAL);\n      output = (double *)mxGetPr(plhs[0]);\n      weightOutput = (double *)mxGetPr(plhs[1]);\n      numStates = (double *) mxGetPr(plhs[2]);\n      \n      *numStates = state.numStates;\n      \n      for (i = 0; i < state.numStates; i++)\n      {\n        output[i] = state.probabilityVector[i];\n        weightOutput[i] = state.stateWeightVector[i];\n      }\n      \n      break;\n    }/*case 6 - calculateWeightedProbability*/\n    case 7:\n    {\n      /*\n      **calculateWeightedJointProbability\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      firstVector = (double *) mxGetPr(prhs[2]);\n      secondVector = (double *) mxGetPr(prhs[3]);\n\n      /*JointProbabilityState calculateJointProbability(double *firstVector, double *secondVector, double *weightVector, int vectorLength);*/\n      jointState = calculateWeightedJointProbability(firstVector,secondVector,weightVector,numberOfSamples);\n      \n      plhs[0] = mxCreateDoubleMatrix(jointState.numJointStates,1,mxREAL);\n      plhs[1] = mxCreateDoubleMatrix(jointState.numJointStates,1,mxREAL);\n      plhs[2] = mxCreateDoubleMatrix(1,1,mxREAL);\n      plhs[3] = mxCreateDoubleMatrix(jointState.numFirstStates,1,mxREAL);\n      plhs[4] = mxCreateDoubleMatrix(jointState.numFirstStates,1,mxREAL);\n      plhs[5] = mxCreateDoubleMatrix(1,1,mxREAL);\n      plhs[6] = mxCreateDoubleMatrix(jointState.numSecondStates,1,mxREAL);\n      plhs[7] = mxCreateDoubleMatrix(jointState.numSecondStates,1,mxREAL);\n      plhs[8] = mxCreateDoubleMatrix(1,1,mxREAL);\n\n      jointOutput = (double *)mxGetPr(plhs[0]);\n      jointWeight = (double *)mxGetPr(plhs[1]);\n      numJointStates = (double *) mxGetPr(plhs[2]);\n      firstOutput = (double *)mxGetPr(plhs[3]);\n      firstWeight = (double *)mxGetPr(plhs[4]);\n      numFirstStates = (double *) mxGetPr(plhs[5]);\n      secondOutput = (double *)mxGetPr(plhs[6]);\n      secondWeight = (double *)mxGetPr(plhs[7]);\n      numSecondStates = (double *) mxGetPr(plhs[8]);\n      \n      *numJointStates = jointState.numJointStates;\n      *numFirstStates = jointState.numFirstStates;\n      *numSecondStates = jointState.numSecondStates;\n      \n      for (i = 0; i < jointState.numJointStates; i++)\n      {\n        jointOutput[i] = jointState.jointProbabilityVector[i];\n        jointWeight[i] = jointState.jointWeightVector[i];\n      }\n      for (i = 0; i < jointState.numFirstStates; i++)\n      {\n        firstOutput[i] = jointState.firstProbabilityVector[i];\n        firstWeight[i] = jointState.firstWeightVector[i];\n      }\n      for (i = 0; i < jointState.numSecondStates; i++)\n      {\n        secondOutput[i] = jointState.secondProbabilityVector[i];\n        secondWeight[i] = jointState.secondWeightVector[i];\n      }\n      \n      break;\n    }/*case 7 - calculateWeightedJointProbability */\n    default:\n    {\n      printf(\"Unrecognised flag\\n\");\n      break;\n    }/*default*/\n  }/*switch(flag)*/\n \n  if (columnMismatch)\n  {\n    printf(\"No columns in one or more inputs\\n\");\n    *output = -1.0;\n  }\n  else if (vectorMismatch)\n  {\n    printf(\"Vector lengths do not match, they must all be the same length\\n\");\n    *output = -1.0;\n  }\n\n  return;\n}", "item_id": 0, "repo": "alecuba16/alecuba16-FEASTR", "file": "src/MIToolbox/WeightedMIToolboxMex.c", "last_update_at": "2018-10-30T03:17:26+00:00", "question_id": "efdfd1b6782a78bcdf0006425c0e40f83dfa5a71_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])\n{\n  /*****************************************************************************\n  ** this function takes a flag and a variable number of arguments\n  ** depending on the value of the flag and returns either a construct \n  ** containing probability estimates, a merged vector or a double value \n  ** representing an entropy or mutual information\n  *****************************************************************************/\n  int flag, numberOfSamples, checkSamples, thirdCheckSamples, numberOfFeatures, checkFeatures, thirdCheckFeatures;\n  int vectorMismatch, columnMismatch, weightLength, weightWidth;\n  double *dataVector, *condVector, *targetVector, *firstVector, *secondVector, *output, *weightVector;\n  double *weightOutput, *jointWeight, *firstWeight, *secondWeight, *jointOutput, *firstOutput, *secondOutput;\n  double *numStates, *numJointStates, *numFirstStates, *numSecondStates;\n  WeightedProbState state;\n  WeightedJointProbState jointState;\n  int i;\n  switch (nrhs)\n  {\n    case 3:\n    {\n        /*printf(\"Must be H_w(X)\\n\");*/\n        break;\n    }\n    case 4:\n    {\n        /*printf(\"Must be H_w(XY), H_w(X|Y), I_w(X;Y)\\n\");*/\n        break;\n    }\n    case 5:\n    {\n        /*printf(\"Must be I_w(X;Y|Z)\\n\");*/\n        break;\n    }\n    default:\n    {\n        printf(\"Incorrect number of arguments, format is WeightedMIToolbox(\\\"FLAG\\\",varargin)\\n\");\n        break;\n    }\n  }\n  vectorMismatch = 0;\n  columnMismatch = 0;\n  /* number to function map\n  ** 1 = H(X)\n  ** 2 = H(XY)\n  ** 3 = H(X|Y)\n  ** 4 = I(X;Y)\n  ** 5 = I(X;Y|Z)\n  ** 6 = calculateWeightedProbability\n  ** 7 = calculateWeightedJointProbability\n  */\n  flag = *mxGetPr(prhs[0]);\n  weightLength = mxGetM(prhs[1]);\n  weightWidth = mxGetN(prhs[1]);\n  weightVector = (double *) mxGetPr(prhs[1]);\n  switch (flag)\n  {\n    case 1:\n    {\n      /*\n      **H(X)\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      numberOfFeatures = mxGetN(prhs[2]);\n      dataVector = (double *) mxGetPr(prhs[2]);\n      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);\n      output = (double *)mxGetPr(plhs[0]);\n      if ((numberOfFeatures == 1) && (weightWidth == 1))\n      {\n        if (numberOfSamples == weightLength)\n        {\n          /*double calculateWeightedEntropy(double *dataVector, double *weightVector, int vectorLength);*/\n          *output = calculateWeightedEntropy(dataVector,weightVector,numberOfSamples);\n        }\n        else\n        {\n          vectorMismatch = 1;\n        }\n      }\n      else\n      {\n        columnMismatch = 1;\n      }\n      break;\n    }/*case 1 - H(X)*/\n    case 2:\n    {\n      /*\n      **H(XY)\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      checkSamples = mxGetM(prhs[3]);\n      numberOfFeatures = mxGetN(prhs[2]);\n      checkFeatures = mxGetN(prhs[3]);\n      firstVector = mxGetPr(prhs[2]);\n      secondVector = mxGetPr(prhs[3]);\n      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);\n      output = (double *)mxGetPr(plhs[0]);\n      if ((numberOfFeatures == 1) && (checkFeatures == 1) && (weightWidth == 1))\n      {\n        if ((numberOfSamples == 0) && (checkSamples == 0) && (weightLength == 0))\n        {\n          *output = 0.0;\n        }\n        else if ((numberOfSamples == 0) && (weightLength == checkSamples))\n        {\n          *output = calculateWeightedEntropy(secondVector,weightVector,numberOfSamples);\n        }\n        else if ((checkSamples == 0) && (weightLength == numberOfSamples))\n        {\n          *output = calculateWeightedEntropy(firstVector,weightVector,numberOfSamples);\n        }\n        else if ((numberOfSamples == checkSamples) && (numberOfSamples == weightLength))\n        {\n          /*double calculateWeightedJointEntropy(double *firstVector, double *secondVector, double *weightVector, int vectorLength);*/\n          *output = calculateWeightedJointEntropy(firstVector,secondVector,weightVector,numberOfSamples);\n        }\n        else\n        {\n          vectorMismatch = 1;\n        }\n      }\n      else\n      {\n        columnMismatch = 1;\n      }\n      break;\n    }/*case 2 - H(XY)*/\n    case 3:\n    {\n      /*\n      **H(X|Y)\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      checkSamples = mxGetM(prhs[3]);\n      numberOfFeatures = mxGetN(prhs[2]);\n      checkFeatures = mxGetN(prhs[3]);\n      dataVector = mxGetPr(prhs[2]);\n      condVector = mxGetPr(prhs[3]);\n      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);\n      output = (double *)mxGetPr(plhs[0]);\n      if ((numberOfFeatures == 1) && (checkFeatures == 1) && (weightWidth == 1))\n      {\n        if (numberOfSamples == 0)\n        {\n          *output = 0.0;\n        }\n        else if ((checkSamples == 0) && (weightLength == numberOfSamples))\n        {\n          *output = calculateWeightedEntropy(dataVector,weightVector,numberOfSamples);\n        }\n        else if ((numberOfSamples == checkSamples) && (numberOfSamples == weightLength))\n        {\n          /*double calculateWeightedConditionalEntropy(double *dataVector, double *condVector, double *weightVector, int vectorLength);*/\n          *output = calculateWeightedConditionalEntropy(dataVector,condVector,weightVector,numberOfSamples);\n        }\n        else\n        {\n          vectorMismatch = 1;\n        }\n      }\n      else\n      {\n        columnMismatch = 1;\n      }\n      break;\n    }/*case 3 - H(X|Y)*/\n    case 4:\n    {\n      /*\n      **I(X;Y)\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      checkSamples = mxGetM(prhs[3]);\n      numberOfFeatures = mxGetN(prhs[2]);\n      checkFeatures = mxGetN(prhs[3]);\n      firstVector = mxGetPr(prhs[2]);\n      secondVector = mxGetPr(prhs[3]);\n      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);\n      output = (double *)mxGetPr(plhs[0]);\n      if ((numberOfFeatures == 1) && (checkFeatures == 1) && (weightWidth == 1))\n      {\n        if ((numberOfSamples == 0) || (checkSamples == 0))\n        {\n          *output = 0.0;\n        }\n        else if ((numberOfSamples == checkSamples) && (numberOfSamples == weightLength))\n        {\n          /*double calculateWeightedMutualInformation(double *firstVector, double *secondVector, double *weightVector, int vectorLength);*/\n          *output = calculateWeightedMutualInformation(firstVector,secondVector,weightVector,numberOfSamples);\n        }\n        else\n        {\n          vectorMismatch = 1;\n        }\n      }\n      else\n      {\n        columnMismatch = 1;\n      }\n      break;\n    }/*case 4 - I(X;Y)*/\n    case 5:\n    {\n      /*\n      **I(X;Y|Z)\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      checkSamples = mxGetM(prhs[3]);\n      thirdCheckSamples = mxGetM(prhs[4]);\n      numberOfFeatures = mxGetN(prhs[2]);\n      checkFeatures = mxGetN(prhs[3]);\n      thirdCheckFeatures = mxGetN(prhs[4]);\n      firstVector = mxGetPr(prhs[2]);\n      targetVector = mxGetPr(prhs[3]);\n      condVector = mxGetPr(prhs[4]);\n      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);\n      output = (double *)mxGetPr(plhs[0]);\n      if ((numberOfFeatures == 1) && (checkFeatures == 1) && (weightWidth == 1))\n      {\n        if ((numberOfSamples == 0) || (checkSamples == 0))\n        {\n          *output = 0.0;\n        }\n        else if ((numberOfSamples == checkSamples) && (numberOfSamples == weightLength))\n        {\n          if ((thirdCheckSamples == 0) || (thirdCheckFeatures != 1))\n          {\n            *output = calculateWeightedMutualInformation(firstVector,targetVector,weightVector,numberOfSamples);\n          }\n          else if (numberOfSamples == thirdCheckSamples)\n          {\n            /*double calculateWeightedConditionalMutualInformation(double *firstVector, double *targetVector, double *condVector, double *weightVector, int vectorLength);*/\n            *output = calculateWeightedConditionalMutualInformation(firstVector,targetVector,condVector,weightVector,numberOfSamples);\n          }\n          else\n          {\n            vectorMismatch = 1;\n          }\n        }\n        else\n        {\n          vectorMismatch = 1;\n        }\n      }\n      else\n      {\n        columnMismatch = 1;\n      }\n      break;\n    }/*case 5 - I(X;Y|Z)*/\n    case 6:\n    {\n      /*\n      **calculateWeightedProbability\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      dataVector = (double *) mxGetPr(prhs[2]);\n      /*WeightedProbabilityState calculateWeightedProbability(double *dataVector, double *weightVector, int vectorLength);*/\n      state = calculateWeightedProbability(dataVector,weightVector,numberOfSamples);\n      plhs[0] = mxCreateDoubleMatrix(state.numStates,1,mxREAL);\n      plhs[1] = mxCreateDoubleMatrix(state.numStates,1,mxREAL);\n      plhs[2] = mxCreateDoubleMatrix(1,1,mxREAL);\n      output = (double *)mxGetPr(plhs[0]);\n      weightOutput = (double *)mxGetPr(plhs[1]);\n      numStates = (double *) mxGetPr(plhs[2]);\n      *numStates = state.numStates;\n      for (i = 0; i < state.numStates; i++)\n      {\n        output[i] = state.probabilityVector[i];\n        weightOutput[i] = state.stateWeightVector[i];\n      }\n      break;\n    }/*case 6 - calculateWeightedProbability*/\n    case 7:\n    {\n      /*\n      **calculateWeightedJointProbability\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      firstVector = (double *) mxGetPr(prhs[2]);\n      secondVector = (double *) mxGetPr(prhs[3]);\n      /*JointProbabilityState calculateJointProbability(double *firstVector, double *secondVector, double *weightVector, int vectorLength);*/\n      jointState = calculateWeightedJointProbability(firstVector,secondVector,weightVector,numberOfSamples);\n      plhs[0] = mxCreateDoubleMatrix(jointState.numJointStates,1,mxREAL);\n      plhs[1] = mxCreateDoubleMatrix(jointState.numJointStates,1,mxREAL);\n      plhs[2] = mxCreateDoubleMatrix(1,1,mxREAL);\n      plhs[3] = mxCreateDoubleMatrix(jointState.numFirstStates,1,mxREAL);\n      plhs[4] = mxCreateDoubleMatrix(jointState.numFirstStates,1,mxREAL);\n      plhs[5] = mxCreateDoubleMatrix(1,1,mxREAL);\n      plhs[6] = mxCreateDoubleMatrix(jointState.numSecondStates,1,mxREAL);\n      plhs[7] = mxCreateDoubleMatrix(jointState.numSecondStates,1,mxREAL);\n      plhs[8] = mxCreateDoubleMatrix(1,1,mxREAL);\n      jointOutput = (double *)mxGetPr(plhs[0]);\n      jointWeight = (double *)mxGetPr(plhs[1]);\n      numJointStates = (double *) mxGetPr(plhs[2]);\n      firstOutput = (double *)mxGetPr(plhs[3]);\n      firstWeight = (double *)mxGetPr(plhs[4]);\n      numFirstStates = (double *) mxGetPr(plhs[5]);\n      secondOutput = (double *)mxGetPr(plhs[6]);\n      secondWeight = (double *)mxGetPr(plhs[7]);\n      numSecondStates = (double *) mxGetPr(plhs[8]);\n      *numJointStates = jointState.numJointStates;\n      *numFirstStates = jointState.numFirstStates;\n      *numSecondStates = jointState.numSecondStates;\n      for (i = 0; i < jointState.numJointStates; i++)\n      {\n        jointOutput[i] = jointState.jointProbabilityVector[i];\n        jointWeight[i] = jointState.jointWeightVector[i];\n      }\n      for (i = 0; i < jointState.numFirstStates; i++)\n      {\n        firstOutput[i] = jointState.firstProbabilityVector[i];\n        firstWeight[i] = jointState.firstWeightVector[i];\n      }\n      for (i = 0; i < jointState.numSecondStates; i++)\n      {\n        secondOutput[i] = jointState.secondProbabilityVector[i];\n        secondWeight[i] = jointState.secondWeightVector[i];\n      }\n      break;\n    }/*case 7 - calculateWeightedJointProbability */\n    default:\n    {\n      printf(\"Unrecognised flag\\n\");\n      break;\n    }/*default*/\n  }/*switch(flag)*/\n  if (columnMismatch)\n  {\n    printf(\"No columns in one or more inputs\\n\");\n    *output = -1.0;\n  }\n  else if (vectorMismatch)\n  {\n    printf(\"Vector lengths do not match, they must all be the same length\\n\");\n    *output = -1.0;\n  }\n  return;\n"]], "pred": {"ppl": 2.187586784362793, "ppl_lower": 2.3090660572052, "ppl/lowercase_ppl": -1.069039595662685, "ppl/zlib": 0.0004275254021377653, "Min_5.0% Prob": 7.065340631148395, "Min_10.0% Prob": 5.3194384832008215, "Min_20.0% Prob": 3.513701650734041, "Min_30.0% Prob": 2.5332298366462482, "Min_40.0% Prob": 1.93726014896025, "Min_50.0% Prob": 1.5609486021553467, "Min_60.0% Prob": 1.3043465781227654}}
{"hexsha": "862cecb3338cbd440646299c9de25c205ae84a8e", "ext": "c", "lang": "C", "content": "Status EXC_OP_NIP(CStack *stack)\n{\n\tif (stack->is_empty(stack)) return CSTACK_EMPTY;\n\tsize_t top_size;\n\tvoid *top_type;\n\tvoid *top = stack->pop(stack, &top_size, &top_type, NULL);\n\tvoid *second = stack->pop(stack, NULL, NULL, NULL);\n\tif (second != NULL) free(second);\n\tstack->push(stack, top, top_size, top_type, true);\n\treturn OPERATION_EXECUTED;\n}", "item_id": 17, "repo": "Yirain/BTC-tool", "file": "src/machine/operation.c", "last_update_at": "2018-07-14T07:05:21+00:00", "question_id": "862cecb3338cbd440646299c9de25c205ae84a8e_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["Status EXC_OP_NIP(CStack *stack)\n{\n\tif (stack->is_empty(stack)) return CSTACK_EMPTY;\n\tsize_t top_size;\n\tvoid *top_type;\n\tvoid *top = stack->pop(stack, &top_size, &top_type, NULL);\n\tvoid *second = stack->pop(stack, NULL, NULL, NULL);\n\tif (second != NULL) free(second);\n\tstack->push(stack, top, top_size, top_type, true);\n\treturn OPERATION_EXECUTED;\n"]], "pred": {"ppl": 3.7043638229370117, "ppl_lower": 4.093908309936523, "ppl/lowercase_ppl": -1.076355611780893, "ppl/zlib": 0.006295728539881178, "Min_5.0% Prob": 8.376908506665911, "Min_10.0% Prob": 7.027364117758615, "Min_20.0% Prob": 5.256939130170005, "Min_30.0% Prob": 4.043323173409417, "Min_40.0% Prob": 3.208554965576955, "Min_50.0% Prob": 2.5843053460121155, "Min_60.0% Prob": 2.1768179012572064}}
{"hexsha": "9a7ad5c738de91170f8a66d181e30c28492947a6", "ext": "c", "lang": "C", "content": "static PyObject* gsl_sf_debye_3_e_wrap(PyObject *self, PyObject *args) {\nPyObject* returned_object;\nint int_result;\ndouble x=0.0;\ngsl_sf_result result;\n\nif (!PyArg_ParseTuple(args, \"d\", &x)) {\n  /* say a little bit more */\n  return NULL;\n}\nint_result=gsl_sf_debye_3_e(x, &result);\n\nif (int_result!=GSL_SUCCESS) {\n  const char* message;\n  message=gsl_strerror(int_result);\n  /* raise exception */\n  PyErr_SetString(gsl_module_error,message);\n  return NULL;\n}\nreturned_object=Py_BuildValue(\"(dd)\",result.val, result.err);\nreturn returned_object;\n}", "item_id": 67, "repo": "juhnowski/FishingRod", "file": "production/pygsl-0.9.5/src/sf_functions.c", "last_update_at": "2018-10-02T06:18:07+00:00", "question_id": "9a7ad5c738de91170f8a66d181e30c28492947a6_67", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static PyObject* gsl_sf_debye_3_e_wrap(PyObject *self, PyObject *args) {\nPyObject* returned_object;\nint int_result;\ndouble x=0.0;\ngsl_sf_result result;\nif (!PyArg_ParseTuple(args, \"d\", &x)) {\n  /* say a little bit more */\n  return NULL;\n}\nint_result=gsl_sf_debye_3_e(x, &result);\nif (int_result!=GSL_SUCCESS) {\n  const char* message;\n  message=gsl_strerror(int_result);\n  /* raise exception */\n  PyErr_SetString(gsl_module_error,message);\n  return NULL;\n}\nreturned_object=Py_BuildValue(\"(dd)\",result.val, result.err);\nreturn returned_object;\n"]], "pred": {"ppl": 1.9918566942214966, "ppl_lower": 3.136807680130005, "ppl/lowercase_ppl": -1.6590625616379617, "ppl/zlib": 0.002187514971183157, "Min_5.0% Prob": 6.029706859588623, "Min_10.0% Prob": 4.651358729317074, "Min_20.0% Prob": 3.187536304905301, "Min_30.0% Prob": 2.2709284296724945, "Min_40.0% Prob": 1.7289494158590542, "Min_50.0% Prob": 1.3765986423121295, "Min_60.0% Prob": 1.151600075292663}}
{"hexsha": "ab976c859304a6318dd57f177fea481456397267", "ext": "c", "lang": "C", "content": "static struct allocator *find_allocator(const struct allocator_vtable *vtable)\n{\n\t/* Loop through allocators in list */\n\tstruct allocator *ap = head.next;\n\twhile (ap->next != NULL) {\n\t\t/* Exit now if this is the allocator we are looking for */\n\t\tif (ap->vtable == vtable)\n\t\t\treturn ap;\n\n\t\t/* Check next allocator in list */\n\t\tap = ap->next;\n\t}\n\n\t/* Create new allocator */\n\tap = new_allocator(vtable);\n\tif (!ap)\n\t\treturn NULL;\n\n\t/* Add allocator to end of list */\n\tap->next = &tail;\n\tap->prev = tail.prev;\n\ttail.prev->next = ap;\n\ttail.prev = ap;\n\treturn ap;\n}", "item_id": 2, "repo": "tronkko/t7", "file": "libt7/src/allocator.c", "last_update_at": "2018-05-13T20:07:23+00:00", "question_id": "ab976c859304a6318dd57f177fea481456397267_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static struct allocator *find_allocator(const struct allocator_vtable *vtable)\n{\n\t/* Loop through allocators in list */\n\tstruct allocator *ap = head.next;\n\twhile (ap->next != NULL) {\n\t\t/* Exit now if this is the allocator we are looking for */\n\t\tif (ap->vtable == vtable)\n\t\t\treturn ap;\n\t\t/* Check next allocator in list */\n\t\tap = ap->next;\n\t}\n\t/* Create new allocator */\n\tap = new_allocator(vtable);\n\tif (!ap)\n\t\treturn NULL;\n\t/* Add allocator to end of list */\n\tap->next = &tail;\n\tap->prev = tail.prev;\n\ttail.prev->next = ap;\n\ttail.prev = ap;\n\treturn ap;\n"]], "pred": {"ppl": 2.127286195755005, "ppl_lower": 2.179358720779419, "ppl/lowercase_ppl": -1.032037731184722, "ppl/zlib": 0.0026767626981668976, "Min_5.0% Prob": 6.872595262527466, "Min_10.0% Prob": 5.168795549869538, "Min_20.0% Prob": 3.335451262753184, "Min_30.0% Prob": 2.43186959722003, "Min_40.0% Prob": 1.8628346562022116, "Min_50.0% Prob": 1.5020711434625307, "Min_60.0% Prob": 1.262808695602102}}
{"hexsha": "cbae544022a07a67df776c245225634977e661c1", "ext": "c", "lang": "C", "content": "GT_INLINE gt_status gt_sam_attribute_generate_XB(gt_sam_attribute_func_params* func_params) {\n  if (func_params->alignment_info->map == NULL) return -1; // Don't print anything\n  gt_attributes *attr=func_params->alignment_info->map->attributes;\n  if(attr==NULL) return -1;\n  void *pp=gt_attributes_get(attr,GT_ATTR_ID_BIS_TYPE);\n  if(pp==NULL) return -1;\n  uint64_t bis_type=*(uint64_t *)pp;\n  if(bis_type>=5 || !bis_type) return -1;\n  char XB_char_value=\"UCGM\"[(int)bis_type-1];\n  gt_string_clear(func_params->return_s);\n  gt_string_append_char(func_params->return_s,XB_char_value);\n  gt_string_append_eos(func_params->return_s);\n  return 0; // OK\n}", "item_id": 39, "repo": "MarcosFernandez/gemtols-cnv", "file": "GEMTools/src/gt_sam_attributes.c", "last_update_at": "2018-07-26T08:57:07+00:00", "question_id": "cbae544022a07a67df776c245225634977e661c1_39", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["GT_INLINE gt_status gt_sam_attribute_generate_XB(gt_sam_attribute_func_params* func_params) {\n  if (func_params->alignment_info->map == NULL) return -1; // Don't print anything\n  gt_attributes *attr=func_params->alignment_info->map->attributes;\n  if(attr==NULL) return -1;\n  void *pp=gt_attributes_get(attr,GT_ATTR_ID_BIS_TYPE);\n  if(pp==NULL) return -1;\n  uint64_t bis_type=*(uint64_t *)pp;\n  if(bis_type>=5 || !bis_type) return -1;\n  char XB_char_value=\"UCGM\"[(int)bis_type-1];\n  gt_string_clear(func_params->return_s);\n  gt_string_append_char(func_params->return_s,XB_char_value);\n  gt_string_append_eos(func_params->return_s);\n  return 0; // OK\n"]], "pred": {"ppl": 3.340529441833496, "ppl_lower": 3.705089807510376, "ppl/lowercase_ppl": -1.0858765202029357, "ppl/zlib": 0.0038048243215942036, "Min_5.0% Prob": 7.2698163619408245, "Min_10.0% Prob": 6.2206702048961935, "Min_20.0% Prob": 4.819478952659751, "Min_30.0% Prob": 3.7377117440104484, "Min_40.0% Prob": 2.9456939830958286, "Min_50.0% Prob": 2.397779507312312, "Min_60.0% Prob": 2.0089353486803008}}
{"hexsha": "4cdffa46d401a5ea6120ba5d350e453158166a31", "ext": "c", "lang": "C", "content": "static\nvoid ufs_qcom_clk_scale_notify(struct ufs_hba *hba)\n{\n\tstruct ufs_qcom_host *host = hba->priv;\n\tstruct ufs_pa_layer_attr *dev_req_params = &host->dev_req_params;\n\n\tif (!dev_req_params)\n\t\treturn;\n\n\tufs_qcom_cfg_timers(hba, dev_req_params->gear_rx,\n\t\t\t\tdev_req_params->pwr_rx,\n\t\t\t\tdev_req_params->hs_rate);\n}", "item_id": 28, "repo": "SIIS-cloud/pileus", "file": "difc-kernel/pileus-kernel/drivers/scsi/ufs/ufs-qcom.c", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "4cdffa46d401a5ea6120ba5d350e453158166a31_28", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static\nvoid ufs_qcom_clk_scale_notify(struct ufs_hba *hba)\n{\n\tstruct ufs_qcom_host *host = hba->priv;\n\tstruct ufs_pa_layer_attr *dev_req_params = &host->dev_req_params;\n\tif (!dev_req_params)\n\t\treturn;\n\tufs_qcom_cfg_timers(hba, dev_req_params->gear_rx,\n\t\t\t\tdev_req_params->pwr_rx,\n\t\t\t\tdev_req_params->hs_rate);\n"]], "pred": {"ppl": 1.7617229223251343, "ppl_lower": 1.7617229223251343, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.003217569678106667, "Min_5.0% Prob": 5.84543378012521, "Min_10.0% Prob": 4.412389516830444, "Min_20.0% Prob": 2.6501297334144853, "Min_30.0% Prob": 1.85329124907201, "Min_40.0% Prob": 1.4149984078387083, "Min_50.0% Prob": 1.1382309859366835, "Min_60.0% Prob": 0.9476287483991114}}
{"hexsha": "751529a0216635b6d41da94bb4662327459fd5b6", "ext": "h", "lang": "C", "content": "namespace MediaPlayer\n{\n    /// Service offer player widget for video content.\n    ///\n    class ServiceInterface : public QObject, public Foundation::ServiceInterface \n    {\n        Q_OBJECT\n    public:\n        virtual ~ServiceInterface() {};\n    public slots:\n        virtual bool IsMimeTypeSupported(const QString &mime_type) = 0;\n\n        /// Gives player widget playing given media in eternal loop.\n        /// If player is asked more than once for same url only one instance of player \n        /// widget is created and returned.\n        /// @param url url of video content\n        /// @return pointer to player widget if success otherwise return 0.\n        virtual QWidget* GetPlayerWidget(const QString &url) = 0;\n\n        /// Delete existing video widget associated with given url.\n        /// Be sure that you are not using the player widget after you have called this method.\n        /// @param url url of video content\n        virtual void DeletePlayerWidget(const QString &url) = 0;\n    }", "item_id": 0, "repo": "mattire/naali", "file": "Interfaces/MediaPlayerService.h", "last_update_at": "2018-04-02T15:38:10+00:00", "question_id": "751529a0216635b6d41da94bb4662327459fd5b6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace MediaPlayer\n{\n    /// Service offer player widget for video content.\n    ///\n    class ServiceInterface : public QObject, public Foundation::ServiceInterface \n    {\n        Q_OBJECT\n    public:\n        virtual ~ServiceInterface() {};\n    public slots:\n        virtual bool IsMimeTypeSupported(const QString &mime_type) = 0;\n        /// Gives player widget playing given media in eternal loop.\n        /// If player is asked more than once for same url only one instance of player \n        /// widget is created and returned.\n        /// @param url url of video content\n        /// @return pointer to player widget if success otherwise return 0.\n        virtual QWidget* GetPlayerWidget(const QString &url) = 0;\n        /// Delete existing video widget associated with given url.\n        /// Be sure that you are not using the player widget after you have called this method.\n        /// @param url url of video content\n        virtual void DeletePlayerWidget(const QString &url) = 0;\n"]], "pred": {"ppl": 4.789006233215332, "ppl_lower": 5.441132068634033, "ppl/lowercase_ppl": -1.0815056814096022, "ppl/zlib": 0.003457666496531823, "Min_5.0% Prob": 9.879764278729757, "Min_10.0% Prob": 7.898686190446218, "Min_20.0% Prob": 5.706700652837753, "Min_30.0% Prob": 4.486554159058465, "Min_40.0% Prob": 3.6489475903411708, "Min_50.0% Prob": 3.036861894031366, "Min_60.0% Prob": 2.578401772201889}}
{"hexsha": "87a485c65a80ec2f246d08c28cec28ad3a0b6666", "ext": "c", "lang": "C", "content": "static AccCache *CreateAccCache(XFInfo *xfinfo, const int b)\n{\n   AccCache *ac;\n   IntVec size;\n   int vsize, bl;\n\n   size = GetBlockSize(xfinfo,b),\n   \n   vsize = 0;\n   for (bl=1;bl<=IntVecSize(size);bl++) vsize += size[bl];\n   \n   ac = (AccCache *)New(&obcaStack,sizeof(AccCache));\n   ac->baseclass = b;\n   ac->bVector  = CreateDVector(&obcaStack,vsize); \n   ZeroDVector(ac->bVector);\n   ac->bTriMat = CreateBlockTriMat(&obcaStack,size);    \n   ZeroBlockTriMat(ac->bTriMat);\n   ac->next = xfinfo->headac;\n   xfinfo->headac = ac;\n   return(ac);\n}", "item_id": 48, "repo": "didw/HTS", "file": "HTKLib/HAdapt.c", "last_update_at": "2018-04-19T08:30:07+00:00", "question_id": "87a485c65a80ec2f246d08c28cec28ad3a0b6666_48", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static AccCache *CreateAccCache(XFInfo *xfinfo, const int b)\n{\n   AccCache *ac;\n   IntVec size;\n   int vsize, bl;\n   size = GetBlockSize(xfinfo,b),\n   vsize = 0;\n   for (bl=1;bl<=IntVecSize(size);bl++) vsize += size[bl];\n   ac = (AccCache *)New(&obcaStack,sizeof(AccCache));\n   ac->baseclass = b;\n   ac->bVector  = CreateDVector(&obcaStack,vsize); \n   ZeroDVector(ac->bVector);\n   ac->bTriMat = CreateBlockTriMat(&obcaStack,size);    \n   ZeroBlockTriMat(ac->bTriMat);\n   ac->next = xfinfo->headac;\n   xfinfo->headac = ac;\n   return(ac);\n"]], "pred": {"ppl": 4.361512660980225, "ppl_lower": 5.081491947174072, "ppl/lowercase_ppl": -1.1037371038341277, "ppl/zlib": 0.005260067634938454, "Min_5.0% Prob": 9.588580751419068, "Min_10.0% Prob": 7.802664075578962, "Min_20.0% Prob": 5.820719125658967, "Min_30.0% Prob": 4.477614087324876, "Min_40.0% Prob": 3.577125674763391, "Min_50.0% Prob": 2.914191181461016, "Min_60.0% Prob": 2.445432438987952}}
{"hexsha": "85723ec87beec8d68c7e1023c556465fb50781af", "ext": "c", "lang": "C", "content": "int target_ftm_set_bootchart(char status)\n{\n\tint ret;\n\n\tret = ftm_set_item(LGFTM_BOOTCHART, &status);\n\n\tif (ret < 0)\n\t\treturn -1;\n\n\treturn 0;\n}", "item_id": 10, "repo": "jaehyek/lk", "file": "target/msm8952_common/lge_target_ftm.c", "last_update_at": "2018-09-16T12:35:42+00:00", "question_id": "85723ec87beec8d68c7e1023c556465fb50781af_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int target_ftm_set_bootchart(char status)\n{\n\tint ret;\n\tret = ftm_set_item(LGFTM_BOOTCHART, &status);\n\tif (ret < 0)\n\t\treturn -1;\n\treturn 0;\n"]], "pred": {"ppl": 5.370401859283447, "ppl_lower": 5.992236614227295, "ppl/lowercase_ppl": -1.065180448185114, "ppl/zlib": 0.014007522832098628, "Min_5.0% Prob": 9.934869130452475, "Min_10.0% Prob": 8.659763881138392, "Min_20.0% Prob": 6.57972036089216, "Min_30.0% Prob": 4.967009283247448, "Min_40.0% Prob": 4.024105680840356, "Min_50.0% Prob": 3.2826913164721594, "Min_60.0% Prob": 2.79758407660695}}
{"hexsha": "e7a2c51d3199d3fb5bce34f37f2f52f32e83a636", "ext": "c", "lang": "C", "content": "int\nmain(argc, argv)\n\tint argc;\n\tregister char *argv[];\n{\n\tint ch, errs;\n\n\t/* Start disks transferring immediately. */\n\tsync();\n\n\twhile ((ch = getopt(argc, argv, \"aFft:v\")) != EOF)\n\t\tswitch (ch) {\n\t\tcase 'a':\n\t\t\tallflag = 1;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tfake = 1;\n\t\t\tbreak;\n\t\tcase 'f':\n#ifdef\tnotnow\n\t\t\tfflag = MNT_FORCE;\n#endif\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tmaketypelist(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tvflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\t/* NOTREACHED */\n\t\t}\n\targc -= optind;\n\targv += optind;\n\n\tif (argc == 0 && !allflag || argc != 0 && allflag)\n\t\tusage();\n\n\tif (allflag) {\n\t\tif (setfsent() == 0)\n\t\t\terr(1, \"%s\", _PATH_FSTAB);\n\t\terrs = umountall();\n\t} else\n\t\tfor (errs = 0; *argv != NULL; ++argv)\n\t\t\tif (umountfs(*argv) == 0)\n\t\t\t\terrs = 1;\n\texit(errs);\n}", "item_id": 0, "repo": "igor-m/retrobsd-with-double-precison", "file": "src/cmd/umount/umount.c", "last_update_at": "2018-02-22T20:42:10+00:00", "question_id": "e7a2c51d3199d3fb5bce34f37f2f52f32e83a636_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nmain(argc, argv)\n\tint argc;\n\tregister char *argv[];\n{\n\tint ch, errs;\n\t/* Start disks transferring immediately. */\n\tsync();\n\twhile ((ch = getopt(argc, argv, \"aFft:v\")) != EOF)\n\t\tswitch (ch) {\n\t\tcase 'a':\n\t\t\tallflag = 1;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tfake = 1;\n\t\t\tbreak;\n\t\tcase 'f':\n#ifdef\tnotnow\n\t\t\tfflag = MNT_FORCE;\n#endif\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tmaketypelist(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tvflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\t/* NOTREACHED */\n\t\t}\n\targc -= optind;\n\targv += optind;\n\tif (argc == 0 && !allflag || argc != 0 && allflag)\n\t\tusage();\n\tif (allflag) {\n\t\tif (setfsent() == 0)\n\t\t\terr(1, \"%s\", _PATH_FSTAB);\n\t\terrs = umountall();\n\t} else\n\t\tfor (errs = 0; *argv != NULL; ++argv)\n\t\t\tif (umountfs(*argv) == 0)\n\t\t\t\terrs = 1;\n\texit(errs);\n"]], "pred": {"ppl": 1.8255908489227295, "ppl_lower": 2.1860740184783936, "ppl/lowercase_ppl": -1.299389363608749, "ppl/zlib": 0.0013773539759088947, "Min_5.0% Prob": 6.124763978155036, "Min_10.0% Prob": 4.373602219116994, "Min_20.0% Prob": 2.7978393201586567, "Min_30.0% Prob": 1.9726916316707255, "Min_40.0% Prob": 1.4975617370462115, "Min_50.0% Prob": 1.201015747406266, "Min_60.0% Prob": 1.004853524601692}}
{"hexsha": "88ce019626ef8aeb971c637606c6eb7aec4e27f6", "ext": "h", "lang": "C", "content": "class FilterRender {\npublic:\n\tstatic void* render(void *data, uint width, uint height, Config* config);\n\nprivate:\n\tstatic void* doFlip(void *data, uint width, uint height, bool isLR);\n\tstatic void* doSlice(void *data, uint width, uint height, std::vector<Geometry::Point>);\n\tstatic void* doColor(void *data, uint width, uint height, u_int8_t r, u_int8_t g, u_int8_t b ,u_int8_t a);\n\tstatic void* doAuto(void *data, uint width, uint height);\n}", "item_id": 0, "repo": "louisja1/SlicerCore", "file": "src/FilterRender.h", "last_update_at": "2018-06-26T08:04:10+00:00", "question_id": "88ce019626ef8aeb971c637606c6eb7aec4e27f6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class FilterRender {\npublic:\n\tstatic void* render(void *data, uint width, uint height, Config* config);\nprivate:\n\tstatic void* doFlip(void *data, uint width, uint height, bool isLR);\n\tstatic void* doSlice(void *data, uint width, uint height, std::vector<Geometry::Point>);\n\tstatic void* doColor(void *data, uint width, uint height, u_int8_t r, u_int8_t g, u_int8_t b ,u_int8_t a);\n\tstatic void* doAuto(void *data, uint width, uint height);\n"]], "pred": {"ppl": 3.3373682498931885, "ppl_lower": 3.85488224029541, "ppl/lowercase_ppl": -1.1196150013558175, "ppl/zlib": 0.006410545464147598, "Min_5.0% Prob": 8.287513324192592, "Min_10.0% Prob": 6.897758897145589, "Min_20.0% Prob": 5.179344352086385, "Min_30.0% Prob": 3.823240066352098, "Min_40.0% Prob": 3.002232846666555, "Min_50.0% Prob": 2.401894603988954, "Min_60.0% Prob": 2.0140020255222106}}
{"hexsha": "fecd166f4c24431102ac68587ad03086e10c5612", "ext": "c", "lang": "C", "content": "void nextThread() {\n\tif(currentProcess->process.currentThread->thread.status == RUNNING) {\n\t\tcurrentProcess->process.currentThread->thread.status = READY;\n\t}\n\t\n\tif(currentProcess->process.currentThread->next == NULL){\n\t\t\n\t\tcurrentProcess->process.currentThread = currentProcess->process.threads;\n\t\t\n\t\tif(currentProcess->process.currentThread->thread.status == READY){\n\t\t\tcurrentProcess->process.currentThread->thread.status = RUNNING;\n\t\t\treturn;\n\t\t}\n\t}\n\t\t\n\twhile(currentProcess->process.currentThread->next->thread.status != READY) {\n\t\tcurrentProcess->process.currentThread = currentProcess->process.currentThread->next;\t\n\t}\n\n\tcurrentProcess->process.currentThread = currentProcess->process.currentThread->next;\n\tcurrentProcess->process.currentThread->thread.status = RUNNING;\n\n}", "item_id": 13, "repo": "asantoflaminio/TP2_SO", "file": "Kernel/scheduler.c", "last_update_at": "2018-05-17T19:08:44+00:00", "question_id": "fecd166f4c24431102ac68587ad03086e10c5612_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void nextThread() {\n\tif(currentProcess->process.currentThread->thread.status == RUNNING) {\n\t\tcurrentProcess->process.currentThread->thread.status = READY;\n\t}\n\t\n\tif(currentProcess->process.currentThread->next == NULL){\n\t\t\n\t\tcurrentProcess->process.currentThread = currentProcess->process.threads;\n\t\t\n\t\tif(currentProcess->process.currentThread->thread.status == READY){\n\t\t\tcurrentProcess->process.currentThread->thread.status = RUNNING;\n\t\t\treturn;\n\t\t}\n\t}\n\t\t\n\twhile(currentProcess->process.currentThread->next->thread.status != READY) {\n\t\tcurrentProcess->process.currentThread = currentProcess->process.currentThread->next;\t\n\t}\n\tcurrentProcess->process.currentThread = currentProcess->process.currentThread->next;\n\tcurrentProcess->process.currentThread->thread.status = RUNNING;\n"]], "pred": {"ppl": 1.8403161764144897, "ppl_lower": 1.9792003631591797, "ppl/lowercase_ppl": -1.1192835777036498, "ppl/zlib": 0.003244347829078857, "Min_5.0% Prob": 5.928464499386874, "Min_10.0% Prob": 4.392743266147116, "Min_20.0% Prob": 2.7740474317936186, "Min_30.0% Prob": 1.9757454361714109, "Min_40.0% Prob": 1.5202611711748102, "Min_50.0% Prob": 1.2197622909384258, "Min_60.0% Prob": 1.0164086284430724}}
{"hexsha": "6a8959b9373cae4321b3da9a46b94332c12fffc0", "ext": "c", "lang": "C", "content": "void* listen_for_command(void* arg)\n{\n\tint sock = socket(AF_INET, SOCK_DGRAM, 0);       //socket initailization\n\tstruct sockaddr_storage serverAddr;\n\tchar myMsg[1024];\n\t//char stop = ' ';\n\t_Bool stopping = false;\n\tint b;\n\n\t//binding \n\tstruct sockaddr_in sockName;\n\tmemset((char*)&sockName, 0, sizeof(sockName));\n\tsockName.sin_family = AF_INET;\n\tsockName.sin_port = htons(SERVER_PORT);\n\tsockName.sin_addr.s_addr = htonl(INADDR_ANY);\n\tsocklen_t serverAddrSize;\n\n\tif(bind(sock, (struct sockaddr *)&sockName, sizeof(sockName)))\n\t{\n\t\tperror(\"binding failed\");\n\t\texit(1);\n\t}\n\t\n\tserverAddrSize = sizeof(serverAddr);\n\t\n\t//send msg to server\n\twhile((b = recvfrom(sock, myMsg, 1024, 0, (struct sockaddr *)&serverAddr, &serverAddrSize)) > 0 && !stopping)\n\t{\n\t\tmyMsg[b] = '\\0';\n\t\tprintf(\"%d\\n\", myMsg[b]);\n\t\tchar* msgsss = verifyCommand(myMsg, sock, serverAddr);\n\t\tif (strcmp(msgsss, \"stop\\n\") == 0)\n\t\t{\n\t\t\tstopping = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tsendto(sock, msgsss, 1024, 0, (struct sockaddr *)&serverAddr, serverAddrSize);\n\t\tfree(msgsss);\n\t}\n\t\n\tclose(sock);\n\tpthread_exit(0);\n}", "item_id": 10, "repo": "wasong/cmpt433", "file": "as3_alt/server.c", "last_update_at": "2018-07-01T01:16:57+00:00", "question_id": "6a8959b9373cae4321b3da9a46b94332c12fffc0_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void* listen_for_command(void* arg)\n{\n\tint sock = socket(AF_INET, SOCK_DGRAM, 0);       //socket initailization\n\tstruct sockaddr_storage serverAddr;\n\tchar myMsg[1024];\n\t//char stop = ' ';\n\t_Bool stopping = false;\n\tint b;\n\t//binding \n\tstruct sockaddr_in sockName;\n\tmemset((char*)&sockName, 0, sizeof(sockName));\n\tsockName.sin_family = AF_INET;\n\tsockName.sin_port = htons(SERVER_PORT);\n\tsockName.sin_addr.s_addr = htonl(INADDR_ANY);\n\tsocklen_t serverAddrSize;\n\tif(bind(sock, (struct sockaddr *)&sockName, sizeof(sockName)))\n\t{\n\t\tperror(\"binding failed\");\n\t\texit(1);\n\t}\n\t\n\tserverAddrSize = sizeof(serverAddr);\n\t\n\t//send msg to server\n\twhile((b = recvfrom(sock, myMsg, 1024, 0, (struct sockaddr *)&serverAddr, &serverAddrSize)) > 0 && !stopping)\n\t{\n\t\tmyMsg[b] = '\\0';\n\t\tprintf(\"%d\\n\", myMsg[b]);\n\t\tchar* msgsss = verifyCommand(myMsg, sock, serverAddr);\n\t\tif (strcmp(msgsss, \"stop\\n\") == 0)\n\t\t{\n\t\t\tstopping = true;\n\t\t\tbreak;\n\t\t}\n\t\tsendto(sock, msgsss, 1024, 0, (struct sockaddr *)&serverAddr, serverAddrSize);\n\t\tfree(msgsss);\n\t}\n\t\n\tclose(sock);\n\tpthread_exit(0);\n"]], "pred": {"ppl": 2.12343430519104, "ppl_lower": 2.332002878189087, "ppl/lowercase_ppl": -1.1244202495779052, "ppl/zlib": 0.0013996928127332714, "Min_5.0% Prob": 6.948880859043287, "Min_10.0% Prob": 5.014926027744375, "Min_20.0% Prob": 3.321211317118178, "Min_30.0% Prob": 2.418170761766163, "Min_40.0% Prob": 1.8581669086471517, "Min_50.0% Prob": 1.4950114955999336, "Min_60.0% Prob": 1.2528239685594509}}
{"hexsha": "d4e46a36351257641c3bc85db38f2fbdf6396eef", "ext": "h", "lang": "C", "content": "static inline void ahci_port_clb_wr(__DN(t) *_dev, uint64_t _regval)\n{\n    // No MB0 or RSVD fields present\n    // No MB1 fields present\n    // No pre-read of register required\n    mackerel_write_addr_64(_dev->b, 0x0, _regval);\n}", "item_id": 14, "repo": "daleoooo/barrelfish", "file": "build/x86_64/include/dev/ahci_port_dev.h", "last_update_at": "2018-03-30T08:02:50+00:00", "question_id": "d4e46a36351257641c3bc85db38f2fbdf6396eef_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void ahci_port_clb_wr(__DN(t) *_dev, uint64_t _regval)\n{\n    // No MB0 or RSVD fields present\n    // No MB1 fields present\n    // No pre-read of register required\n    mackerel_write_addr_64(_dev->b, 0x0, _regval);\n"]], "pred": {"ppl": 10.129819869995117, "ppl_lower": 11.324689865112305, "ppl/lowercase_ppl": -1.048154844550962, "ppl/zlib": 0.0136204913897993, "Min_5.0% Prob": 9.940841913223267, "Min_10.0% Prob": 8.397658507029215, "Min_20.0% Prob": 7.093709627787272, "Min_30.0% Prob": 6.094624916712443, "Min_40.0% Prob": 5.230845517582363, "Min_50.0% Prob": 4.492130462328593, "Min_60.0% Prob": 3.8261699941423206}}
{"hexsha": "75ad89e0870041af48629ba90d9e4baf8ef9a5b0", "ext": "c", "lang": "C", "content": "static void ae_test_read(ae_mux_t *self,\n                         const struct epoll_event *event,\n                         void *ctx)\n{\n     uint64_t overflows = 0;\n     ae_res_t e;\n     ae_res_init(&e);\n     if(!ae_timer_read(&e, ctx, &overflows))\n     {\n          AE_LR(&e);\n          return;\n     }\n     \n     AE_LD(\"sup: %\"PRIu64\"\", overflows);\n}", "item_id": 0, "repo": "jopeg/libae", "file": "test/ae-test.c", "last_update_at": "2018-07-03T16:58:33+00:00", "question_id": "75ad89e0870041af48629ba90d9e4baf8ef9a5b0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void ae_test_read(ae_mux_t *self,\n                         const struct epoll_event *event,\n                         void *ctx)\n{\n     uint64_t overflows = 0;\n     ae_res_t e;\n     ae_res_init(&e);\n     if(!ae_timer_read(&e, ctx, &overflows))\n     {\n          AE_LR(&e);\n          return;\n     }\n     AE_LD(\"sup: %\"PRIu64\"\", overflows);\n"]], "pred": {"ppl": 5.433314323425293, "ppl_lower": 5.728970050811768, "ppl/lowercase_ppl": -1.0313057036185211, "ppl/zlib": 0.008462746601912027, "Min_5.0% Prob": 9.701830705006918, "Min_10.0% Prob": 8.01791656934298, "Min_20.0% Prob": 6.0477417065547066, "Min_30.0% Prob": 4.7188771039247515, "Min_40.0% Prob": 3.906116973679021, "Min_50.0% Prob": 3.2742738314528963, "Min_60.0% Prob": 2.8133369367569685}}
{"hexsha": "5d9c804e9b3caeb80be46cb8cb59b21ad4f48d66", "ext": "c", "lang": "C", "content": "static int\ncheckaddfile (file, repository, tag, options, rcsnode)\n    char *file;\n    char *repository;\n    char *tag;\n    char *options;\n    RCSNode **rcsnode;\n{\n    char rcs[PATH_MAX];\n    char fname[PATH_MAX];\n    mode_t omask;\n    int retcode = 0;\n    int newfile = 0;\n    RCSNode *rcsfile = NULL;\n\n    if (tag)\n    {\n        (void) sprintf (rcs, \"%s/%s%s\", repository, file, RCSEXT);\n\tif (! isreadable (rcs))\n\t{\n\t    (void) sprintf(rcs, \"%s/%s\", repository, CVSATTIC);\n\t    omask = umask (cvsumask);\n\t    if (CVS_MKDIR (rcs, 0777) != 0 && errno != EEXIST)\n\t\terror (1, errno, \"cannot make directory `%s'\", rcs);;\n\t    (void) umask (omask);\n\t    (void) sprintf (rcs, \"%s/%s/%s%s\", repository, CVSATTIC, file,\n\t\t\t    RCSEXT);\n\t}\n    }\n    else\n\tlocate_rcs (file, repository, rcs);\n\n    if (isreadable(rcs))\n    {\n\t/* file has existed in the past.  Prepare to resurrect. */\n\tchar oldfile[PATH_MAX];\n\tchar *rev;\n\n\tif ((rcsfile = *rcsnode) == NULL)\n\t{\n\t    error (0, 0, \"could not find parsed rcsfile %s\", file);\n\t    return (1);\n\t}\n\n\tif (tag == NULL)\n\t{\n\t    /* we are adding on the trunk, so move the file out of the\n\t       Attic. */\n\t    strcpy (oldfile, rcs);\n\t    sprintf (rcs, \"%s/%s%s\", repository, file, RCSEXT);\n\t    \n\t    if (strcmp (oldfile, rcs) == 0\n\t\t|| CVS_RENAME (oldfile, rcs) != 0\n\t\t|| isreadable (oldfile)\n\t\t|| !isreadable (rcs))\n\t    {\n\t\terror (0, 0, \"failed to move `%s' out of the attic.\",\n\t\t       file);\n\t\treturn (1);\n\t    }\n\t    free (rcsfile->path);\n\t    rcsfile->path = xstrdup (rcs);\n\t}\n\n\trev = RCS_getversion (rcsfile, tag, NULL, 1, (int *) NULL);\n\t/* and lock it */\n\tif (lock_RCS (file, rcsfile, rev, repository)) {\n\t    error (0, 0, \"cannot lock `%s'.\", rcs);\n\t    free (rev);\n\t    return (1);\n\t}\n\n\tfree (rev);\n    } else {\n\t/* this is the first time we have ever seen this file; create\n\t   an rcs file.  */\n\trun_setup (\"%s%s -x,v/ -i\", Rcsbin, RCS);\n\n\t(void) sprintf (fname, \"%s/%s%s\", CVSADM, file, CVSEXT_LOG);\n\t/* If the file does not exist, no big deal.  In particular, the\n\t   server does not (yet at least) create CVSEXT_LOG files.  */\n\tif (isfile (fname))\n\t    run_args (\"-t%s/%s%s\", CVSADM, file, CVSEXT_LOG);\n\n\t/* Set RCS keyword expansion options.  */\n\tif (options && options[0] == '-' && options[1] == 'k')\n\t    run_arg (options);\n\trun_arg (rcs);\n\tif ((retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL)) != 0)\n\t{\n\t    error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,\n\t\t   \"could not create %s\", rcs);\n\t    return (1);\n\t}\n\tnewfile = 1;\n    }\n\n    /* when adding a file for the first time, and using a tag, we need\n       to create a dead revision on the trunk.  */\n    if (tag && newfile)\n    {\n\tchar *tmp;\n\n\t/* move the new file out of the way. */\n\t(void) sprintf (fname, \"%s/%s%s\", CVSADM, CVSPREFIX, file);\n\trename_file (file, fname);\n\tcopy_file (DEVNULL, file);\n\n\ttmp = xmalloc (strlen (file) + strlen (tag) + 80);\n\t/* commit a dead revision. */\n\t(void) sprintf (tmp, \"file %s was initially added on branch %s.\",\n\t\t\tfile, tag);\n\tretcode = RCS_checkin (rcs, NULL, tmp, NULL,\n\t\t\t       RCS_FLAGS_DEAD | RCS_FLAGS_QUIET);\n\tfree (tmp);\n\tif (retcode != 0)\n\t{\n\t    error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,\n\t\t   \"could not create initial dead revision %s\", rcs);\n\t    return (1);\n\t}\n\n\t/* put the new file back where it was */\n\trename_file (fname, file);\n\n\tassert (rcsfile == NULL);\n\trcsfile = RCS_parse (file, repository);\n\tif (rcsfile == NULL)\n\t{\n\t    error (0, 0, \"could not read %s\", rcs);\n\t    return (1);\n\t}\n\tif (rcsnode != NULL)\n\t{\n\t    assert (*rcsnode == NULL);\n\t    *rcsnode = rcsfile;\n\t}\n\n\t/* and lock it once again. */\n\tif (lock_RCS (file, rcsfile, NULL, repository)) {\n\t    error (0, 0, \"cannot lock `%s'.\", rcs);\n\t    return (1);\n\t}\n    }\n\n    if (tag != NULL)\n    {\n\t/* when adding with a tag, we need to stub a branch, if it\n\t   doesn't already exist.  */\n\n\tif (rcsfile == NULL)\n\t{\n\t    if (rcsnode != NULL && *rcsnode != NULL)\n\t\trcsfile = *rcsnode;\n\t    else\n\t    {\n\t\trcsfile = RCS_parse (file, repository);\n\t\tif (rcsfile == NULL)\n\t\t{\n\t\t    error (0, 0, \"could not read %s\", rcs);\n\t\t    return (1);\n\t\t}\n\t    }\n\t}\n\n\tif (!RCS_nodeisbranch (rcsfile, tag)) {\n\t    /* branch does not exist.  Stub it.  */\n\t    char *head;\n\t    char *magicrev;\n\t    \n\t    head = RCS_getversion (rcsfile, NULL, NULL, 0, (int *) NULL);\n\t    magicrev = RCS_magicrev (rcsfile, head);\n\n\t    retcode = RCS_settag (rcsfile, tag, magicrev);\n\n\t    free (head);\n\t    free (magicrev);\n\n\t    if (retcode != 0)\n\t    {\n\t\terror (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,\n\t\t       \"could not stub branch %s for %s\", tag, rcs);\n\t\treturn (1);\n\t    }\n\t}\n\telse\n\t{\n\t    /* lock the branch. (stubbed branches need not be locked.)  */\n\t    if (lock_RCS (file, rcsfile, NULL, repository)) {\n\t\terror (0, 0, \"cannot lock `%s'.\", rcs);\n\t\treturn (1);\n\t    }\n\t} \n\n\tif (rcsnode && *rcsnode != rcsfile)\n\t{\n\t    freercsnode(rcsnode);\n\t    *rcsnode = rcsfile;\n\t}\n    }\n\n    fileattr_newfile (file);\n\n    fix_rcs_modes (rcs, file);\n    return (0);\n}", "item_id": 18, "repo": "aaliomer/exos", "file": "bin/CVS/src/commit.c", "last_update_at": "2018-01-23T23:07:19+00:00", "question_id": "5d9c804e9b3caeb80be46cb8cb59b21ad4f48d66_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\ncheckaddfile (file, repository, tag, options, rcsnode)\n    char *file;\n    char *repository;\n    char *tag;\n    char *options;\n    RCSNode **rcsnode;\n{\n    char rcs[PATH_MAX];\n    char fname[PATH_MAX];\n    mode_t omask;\n    int retcode = 0;\n    int newfile = 0;\n    RCSNode *rcsfile = NULL;\n    if (tag)\n    {\n        (void) sprintf (rcs, \"%s/%s%s\", repository, file, RCSEXT);\n\tif (! isreadable (rcs))\n\t{\n\t    (void) sprintf(rcs, \"%s/%s\", repository, CVSATTIC);\n\t    omask = umask (cvsumask);\n\t    if (CVS_MKDIR (rcs, 0777) != 0 && errno != EEXIST)\n\t\terror (1, errno, \"cannot make directory `%s'\", rcs);;\n\t    (void) umask (omask);\n\t    (void) sprintf (rcs, \"%s/%s/%s%s\", repository, CVSATTIC, file,\n\t\t\t    RCSEXT);\n\t}\n    }\n    else\n\tlocate_rcs (file, repository, rcs);\n    if (isreadable(rcs))\n    {\n\t/* file has existed in the past.  Prepare to resurrect. */\n\tchar oldfile[PATH_MAX];\n\tchar *rev;\n\tif ((rcsfile = *rcsnode) == NULL)\n\t{\n\t    error (0, 0, \"could not find parsed rcsfile %s\", file);\n\t    return (1);\n\t}\n\tif (tag == NULL)\n\t{\n\t    /* we are adding on the trunk, so move the file out of the\n\t       Attic. */\n\t    strcpy (oldfile, rcs);\n\t    sprintf (rcs, \"%s/%s%s\", repository, file, RCSEXT);\n\t    \n\t    if (strcmp (oldfile, rcs) == 0\n\t\t|| CVS_RENAME (oldfile, rcs) != 0\n\t\t|| isreadable (oldfile)\n\t\t|| !isreadable (rcs))\n\t    {\n\t\terror (0, 0, \"failed to move `%s' out of the attic.\",\n\t\t       file);\n\t\treturn (1);\n\t    }\n\t    free (rcsfile->path);\n\t    rcsfile->path = xstrdup (rcs);\n\t}\n\trev = RCS_getversion (rcsfile, tag, NULL, 1, (int *) NULL);\n\t/* and lock it */\n\tif (lock_RCS (file, rcsfile, rev, repository)) {\n\t    error (0, 0, \"cannot lock `%s'.\", rcs);\n\t    free (rev);\n\t    return (1);\n\t}\n\tfree (rev);\n    } else {\n\t/* this is the first time we have ever seen this file; create\n\t   an rcs file.  */\n\trun_setup (\"%s%s -x,v/ -i\", Rcsbin, RCS);\n\t(void) sprintf (fname, \"%s/%s%s\", CVSADM, file, CVSEXT_LOG);\n\t/* If the file does not exist, no big deal.  In particular, the\n\t   server does not (yet at least) create CVSEXT_LOG files.  */\n\tif (isfile (fname))\n\t    run_args (\"-t%s/%s%s\", CVSADM, file, CVSEXT_LOG);\n\t/* Set RCS keyword expansion options.  */\n\tif (options && options[0] == '-' && options[1] == 'k')\n\t    run_arg (options);\n\trun_arg (rcs);\n\tif ((retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL)) != 0)\n\t{\n\t    error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,\n\t\t   \"could not create %s\", rcs);\n\t    return (1);\n\t}\n\tnewfile = 1;\n    }\n    /* when adding a file for the first time, and using a tag, we need\n       to create a dead revision on the trunk.  */\n    if (tag && newfile)\n    {\n\tchar *tmp;\n\t/* move the new file out of the way. */\n\t(void) sprintf (fname, \"%s/%s%s\", CVSADM, CVSPREFIX, file);\n\trename_file (file, fname);\n\tcopy_file (DEVNULL, file);\n\ttmp = xmalloc (strlen (file) + strlen (tag) + 80);\n\t/* commit a dead revision. */\n\t(void) sprintf (tmp, \"file %s was initially added on branch %s.\",\n\t\t\tfile, tag);\n\tretcode = RCS_checkin (rcs, NULL, tmp, NULL,\n\t\t\t       RCS_FLAGS_DEAD | RCS_FLAGS_QUIET);\n\tfree (tmp);\n\tif (retcode != 0)\n\t{\n\t    error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,\n\t\t   \"could not create initial dead revision %s\", rcs);\n\t    return (1);\n\t}\n\t/* put the new file back where it was */\n\trename_file (fname, file);\n\tassert (rcsfile == NULL);\n\trcsfile = RCS_parse (file, repository);\n\tif (rcsfile == NULL)\n\t{\n\t    error (0, 0, \"could not read %s\", rcs);\n\t    return (1);\n\t}\n\tif (rcsnode != NULL)\n\t{\n\t    assert (*rcsnode == NULL);\n\t    *rcsnode = rcsfile;\n\t}\n\t/* and lock it once again. */\n\tif (lock_RCS (file, rcsfile, NULL, repository)) {\n\t    error (0, 0, \"cannot lock `%s'.\", rcs);\n\t    return (1);\n\t}\n    }\n    if (tag != NULL)\n    {\n\t/* when adding with a tag, we need to stub a branch, if it\n\t   doesn't already exist.  */\n\tif (rcsfile == NULL)\n\t{\n\t    if (rcsnode != NULL && *rcsnode != NULL)\n\t\trcsfile = *rcsnode;\n\t    else\n\t    {\n\t\trcsfile = RCS_parse (file, repository);\n\t\tif (rcsfile == NULL)\n\t\t{\n\t\t    error (0, 0, \"could not read %s\", rcs);\n\t\t    return (1);\n\t\t}\n\t    }\n\t}\n\tif (!RCS_nodeisbranch (rcsfile, tag)) {\n\t    /* branch does not exist.  Stub it.  */\n\t    char *head;\n\t    char *magicrev;\n\t    \n\t    head = RCS_getversion (rcsfile, NULL, NULL, 0, (int *) NULL);\n\t    magicrev = RCS_magicrev (rcsfile, head);\n\t    retcode = RCS_settag (rcsfile, tag, magicrev);\n\t    free (head);\n\t    free (magicrev);\n\t    if (retcode != 0)\n\t    {\n\t\terror (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,\n\t\t       \"could not stub branch %s for %s\", tag, rcs);\n\t\treturn (1);\n\t    }\n\t}\n\telse\n\t{\n\t    /* lock the branch. (stubbed branches need not be locked.)  */\n\t    if (lock_RCS (file, rcsfile, NULL, repository)) {\n\t\terror (0, 0, \"cannot lock `%s'.\", rcs);\n\t\treturn (1);\n\t    }\n\t} \n\tif (rcsnode && *rcsnode != rcsfile)\n\t{\n\t    freercsnode(rcsnode);\n\t    *rcsnode = rcsfile;\n\t}\n    }\n    fileattr_newfile (file);\n    fix_rcs_modes (rcs, file);\n    return (0);\n"]], "pred": {"ppl": 2.436614513397217, "ppl_lower": 2.6900486946105957, "ppl/lowercase_ppl": -1.1111033569316173, "ppl/zlib": 0.0005254333813179732, "Min_5.0% Prob": 6.807641337899601, "Min_10.0% Prob": 5.272302730410707, "Min_20.0% Prob": 3.669118369911231, "Min_30.0% Prob": 2.7681715913068237, "Min_40.0% Prob": 2.1732928763829116, "Min_50.0% Prob": 1.770198023380482, "Min_60.0% Prob": 1.4829139884889466}}
{"hexsha": "fa66449539d2c49041222f397900aed9c04acb03", "ext": "c", "lang": "C", "content": "quatd_t\nqd_slerp(quatd_t q0, quatd_t q1, double t)\n{\n  // See http://en.wikipedia.org/wiki/Slerp\n  if (t >= 1.0) return q1;\n  if (t <= 0.0) return q0;\n\n  double qdot = qd_dot(q0, q1);\n\n  quatd_t q1prim;\n  if (qdot < 0.0) {\n    q1prim = -q1;\n    qdot = -qdot;\n  } else {\n    q1prim = q1;\n  }\n\n  if (qdot < -1.0)  qdot = -1.0;\n  if (qdot > 1.0)  qdot = 1.0;\n  assert(qdot >= -1.0);\n  assert(qdot <= 1.0);\n\n  double qang = acos(qdot);\n  double s0 = sin((1.0-t)*qang) / sin(qang);\n  double s1 = sin(t*qang) / sin(qang);\n\n  if (qang) { // If slerping between the same points, qang will be 0, so s0 will be NaN or Inf.\n    quatd_t res = s0 * q0 + s1 * q1prim;\n    return res;\n  }\n\n  return q0;\n}", "item_id": 11, "repo": "openorbit/vmath", "file": "src/vmath-quaternions.c", "last_update_at": "2018-09-13T02:13:20+00:00", "question_id": "fa66449539d2c49041222f397900aed9c04acb03_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["quatd_t\nqd_slerp(quatd_t q0, quatd_t q1, double t)\n{\n  // See http://en.wikipedia.org/wiki/Slerp\n  if (t >= 1.0) return q1;\n  if (t <= 0.0) return q0;\n  double qdot = qd_dot(q0, q1);\n  quatd_t q1prim;\n  if (qdot < 0.0) {\n    q1prim = -q1;\n    qdot = -qdot;\n  } else {\n    q1prim = q1;\n  }\n  if (qdot < -1.0)  qdot = -1.0;\n  if (qdot > 1.0)  qdot = 1.0;\n  assert(qdot >= -1.0);\n  assert(qdot <= 1.0);\n  double qang = acos(qdot);\n  double s0 = sin((1.0-t)*qang) / sin(qang);\n  double s1 = sin(t*qang) / sin(qang);\n  if (qang) { // If slerping between the same points, qang will be 0, so s0 will be NaN or Inf.\n    quatd_t res = s0 * q0 + s1 * q1prim;\n    return res;\n  }\n  return q0;\n"]], "pred": {"ppl": 1.9825475215911865, "ppl_lower": 2.0253493785858154, "ppl/lowercase_ppl": -1.0312099871278904, "ppl/zlib": 0.0021188317175770163, "Min_5.0% Prob": 5.820301869336297, "Min_10.0% Prob": 4.587204279218401, "Min_20.0% Prob": 3.032138642290948, "Min_30.0% Prob": 2.2044295941321357, "Min_40.0% Prob": 1.6942392205163626, "Min_50.0% Prob": 1.362643660987947, "Min_60.0% Prob": 1.1417795453710315}}
{"hexsha": "3e0596414bff363fd84683ef6318e53f7a3abc1d", "ext": "c", "lang": "C", "content": "static void ROL() {\n    BYTE result = cpu.operand << 1;\n    result |= GET_FLAG(FLAG_C);\n    CALC_C(cpu.operand & 0x80);\n    CALC_Z(result);\n    CALC_N(result);\n    Memory_WriteByte(MAP_CPU, cpu.operaddr, result);\n}", "item_id": 24, "repo": "allie/badpce", "file": "src/cpu/instructions.partial.c", "last_update_at": "2018-09-02T23:40:36+00:00", "question_id": "3e0596414bff363fd84683ef6318e53f7a3abc1d_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void ROL() {\n    BYTE result = cpu.operand << 1;\n    result |= GET_FLAG(FLAG_C);\n    CALC_C(cpu.operand & 0x80);\n    CALC_Z(result);\n    CALC_N(result);\n    Memory_WriteByte(MAP_CPU, cpu.operaddr, result);\n"]], "pred": {"ppl": 3.8997490406036377, "ppl_lower": 4.747971534729004, "ppl/lowercase_ppl": -1.1446127668285497, "ppl/zlib": 0.009385601396565333, "Min_5.0% Prob": 9.087995052337646, "Min_10.0% Prob": 7.219612757364909, "Min_20.0% Prob": 5.542077620824178, "Min_30.0% Prob": 4.251408303225482, "Min_40.0% Prob": 3.314087874180562, "Min_50.0% Prob": 2.7145845112593276, "Min_60.0% Prob": 2.28732751716267}}
{"hexsha": "a2f9fca1f77fe001b017d5314ebe479483ffd5d2", "ext": "h", "lang": "C", "content": "interface MPCRadioStreamPing : NSObject {\n    double  _timestamp;\n    long long  _type;\n    NSData * _value;\n}", "item_id": 0, "repo": "shaojiankui/iOS10-Runtime-Headers", "file": "PrivateFrameworks/MediaPlaybackCore.framework/MPCRadioStreamPing.h", "last_update_at": "2018-10-08T04:12:25+00:00", "question_id": "a2f9fca1f77fe001b017d5314ebe479483ffd5d2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface MPCRadioStreamPing : NSObject {\n    double  _timestamp;\n    long long  _type;\n    NSData * _value;\n"]], "pred": {"ppl": 9.826902389526367, "ppl_lower": 23.152809143066406, "ppl/lowercase_ppl": -1.3750310440874054, "ppl/zlib": 0.02262498778658081, "Min_5.0% Prob": 10.278444290161133, "Min_10.0% Prob": 8.263554890950521, "Min_20.0% Prob": 6.929183006286621, "Min_30.0% Prob": 6.175652718544006, "Min_40.0% Prob": 5.142443750585828, "Min_50.0% Prob": 4.389809581968519, "Min_60.0% Prob": 3.8767357014474415}}
{"hexsha": "1c043b91bd954aa5b04f5dd18116b5d6ba31c942", "ext": "c", "lang": "C", "content": "static unsigned int __stdcall _oi_thread_handler(void * args) {\n    (*((thread_t*)args)->func)(((thread_t*)args)->data);\n    _endthreadex(0);\n    return 0;\n}", "item_id": 0, "repo": "geky/oi", "file": "src/oi/thread.c", "last_update_at": "2018-01-14T01:07:07+00:00", "question_id": "1c043b91bd954aa5b04f5dd18116b5d6ba31c942_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static unsigned int __stdcall _oi_thread_handler(void * args) {\n    (*((thread_t*)args)->func)(((thread_t*)args)->data);\n    _endthreadex(0);\n    return 0;\n"]], "pred": {"ppl": 4.363827705383301, "ppl_lower": 4.363827705383301, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.012701289537056158, "Min_5.0% Prob": 9.963871002197266, "Min_10.0% Prob": 7.52601375579834, "Min_20.0% Prob": 5.441524440591985, "Min_30.0% Prob": 4.368360316052156, "Min_40.0% Prob": 3.5340454396994216, "Min_50.0% Prob": 2.8929067562366355, "Min_60.0% Prob": 2.4912733834455993}}
{"hexsha": "acdea7d84dbadf50e03f33dece646ce6a8cc9293", "ext": "h", "lang": "C", "content": "class idCompiler\n{\nprivate:\n\tstatic bool\t\tpunctuationValid[ 256 ];\n\t// RB begin\n\tstatic const char*\t\tpunctuation[];\n\t// RB end\n\t\n\tidParser\t\tparser;\n\tidParser*\t\tparserPtr;\n\tidToken\t\t\ttoken;\n\t\n\tidTypeDef*\t\timmediateType;\n\teval_t\t\t\timmediate;\n\t\n\tbool\t\t\teof;\n\tbool\t\t\tconsole;\n\tbool\t\t\tcallthread;\n\tint\t\t\t\tbraceDepth;\n\tint\t\t\t\tloopDepth;\n\tint\t\t\t\tcurrentLineNumber;\n\tint\t\t\t\tcurrentFileNumber;\n\tint\t\t\t\terrorCount;\n\t\n\tidVarDef*\t\tscope;\t\t\t\t// the function being parsed, or NULL\n\tconst idVarDef*\tbasetype;\t\t\t// for accessing fields\n\t\n\tfloat\t\t\tDivide( float numerator, float denominator );\n\tvoid\t\t\tError( VERIFY_FORMAT_STRING const char* error, ... ) const;\n\tvoid\t\t\tWarning( VERIFY_FORMAT_STRING const char* message, ... ) const;\n\tidVarDef*\t\tOptimizeOpcode( const opcode_t* op, idVarDef* var_a, idVarDef* var_b );\n\tidVarDef*\t\tEmitOpcode( const opcode_t* op, idVarDef* var_a, idVarDef* var_b );\n\tidVarDef*\t\tEmitOpcode( int op, idVarDef* var_a, idVarDef* var_b );\n\tbool\t\t\tEmitPush( idVarDef* expression, const idTypeDef* funcArg );\n\tvoid\t\t\tNextToken();\n\tvoid\t\t\tExpectToken( const char* string );\n\tbool\t\t\tCheckToken( const char* string );\n\tvoid\t\t\tParseName( idStr& name );\n\tvoid\t\t\tSkipOutOfFunction();\n\tvoid\t\t\tSkipToSemicolon();\n\tidTypeDef*\t\tCheckType();\n\tidTypeDef*\t\tParseType();\n\tidVarDef*\t\tFindImmediate( const idTypeDef* type, const eval_t* eval, const char* string ) const;\n\tidVarDef*\t\tGetImmediate( idTypeDef* type, const eval_t* eval, const char* string );\n\tidVarDef*\t\tVirtualFunctionConstant( idVarDef* func );\n\tidVarDef*\t\tSizeConstant( int size );\n\tidVarDef*\t\tJumpConstant( int value );\n\tidVarDef*\t\tJumpDef( int jumpfrom, int jumpto );\n\tidVarDef*\t\tJumpTo( int jumpto );\n\tidVarDef*\t\tJumpFrom( int jumpfrom );\n\tidVarDef*\t\tParseImmediate();\n\tidVarDef*\t\tEmitFunctionParms( int op, idVarDef* func, int startarg, int startsize, idVarDef* object );\n\tidVarDef*\t\tParseFunctionCall( idVarDef* func );\n\tidVarDef*\t\tParseObjectCall( idVarDef* object, idVarDef* func );\n\tidVarDef*\t\tParseEventCall( idVarDef* object, idVarDef* func );\n\tidVarDef*\t\tParseSysObjectCall( idVarDef* func );\n\tidVarDef*\t\tLookupDef( const char* name, const idVarDef* baseobj );\n\tidVarDef*\t\tParseValue();\n\tidVarDef*\t\tGetTerm();\n\tbool\t\t\tTypeMatches( etype_t type1, etype_t type2 ) const;\n\tidVarDef*\t\tGetExpression( int priority );\n\tidTypeDef*\t\tGetTypeForEventArg( char argType );\n\tvoid\t\t\tPatchLoop( int start, int continuePos );\n\tvoid\t\t\tParseReturnStatement();\n\tvoid\t\t\tParseWhileStatement();\n\tvoid\t\t\tParseForStatement();\n\tvoid\t\t\tParseDoWhileStatement();\n\tvoid\t\t\tParseIfStatement();\n\tvoid\t\t\tParseStatement();\n\tvoid\t\t\tParseObjectDef( const char* objname );\n\tidTypeDef*\t\tParseFunction( idTypeDef* returnType, const char* name );\n\tvoid\t\t\tParseFunctionDef( idTypeDef* returnType, const char* name );\n\tvoid\t\t\tParseVariableDef( idTypeDef* type, const char* name );\n\tvoid\t\t\tParseEventDef( idTypeDef* type, const char* name );\n\tvoid\t\t\tParseDefs();\n\tvoid\t\t\tParseNamespace( idVarDef* newScope );\n\t\npublic :\n\t// RB: added const\n\tstatic const opcode_t\topcodes[];\n\t// RB end\n\t\n\tidCompiler();\n\tvoid\t\t\tCompileFile( const char* text, const char* filename, bool console );\n}", "item_id": 0, "repo": "vic3t3chn0/OpenKrown", "file": "neo/d3xp/script/Script_Compiler.h", "last_update_at": "2018-11-07T22:44:23+00:00", "question_id": "acdea7d84dbadf50e03f33dece646ce6a8cc9293_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class idCompiler\n{\nprivate:\n\tstatic bool\t\tpunctuationValid[ 256 ];\n\t// RB begin\n\tstatic const char*\t\tpunctuation[];\n\t// RB end\n\t\n\tidParser\t\tparser;\n\tidParser*\t\tparserPtr;\n\tidToken\t\t\ttoken;\n\t\n\tidTypeDef*\t\timmediateType;\n\teval_t\t\t\timmediate;\n\t\n\tbool\t\t\teof;\n\tbool\t\t\tconsole;\n\tbool\t\t\tcallthread;\n\tint\t\t\t\tbraceDepth;\n\tint\t\t\t\tloopDepth;\n\tint\t\t\t\tcurrentLineNumber;\n\tint\t\t\t\tcurrentFileNumber;\n\tint\t\t\t\terrorCount;\n\t\n\tidVarDef*\t\tscope;\t\t\t\t// the function being parsed, or NULL\n\tconst idVarDef*\tbasetype;\t\t\t// for accessing fields\n\t\n\tfloat\t\t\tDivide( float numerator, float denominator );\n\tvoid\t\t\tError( VERIFY_FORMAT_STRING const char* error, ... ) const;\n\tvoid\t\t\tWarning( VERIFY_FORMAT_STRING const char* message, ... ) const;\n\tidVarDef*\t\tOptimizeOpcode( const opcode_t* op, idVarDef* var_a, idVarDef* var_b );\n\tidVarDef*\t\tEmitOpcode( const opcode_t* op, idVarDef* var_a, idVarDef* var_b );\n\tidVarDef*\t\tEmitOpcode( int op, idVarDef* var_a, idVarDef* var_b );\n\tbool\t\t\tEmitPush( idVarDef* expression, const idTypeDef* funcArg );\n\tvoid\t\t\tNextToken();\n\tvoid\t\t\tExpectToken( const char* string );\n\tbool\t\t\tCheckToken( const char* string );\n\tvoid\t\t\tParseName( idStr& name );\n\tvoid\t\t\tSkipOutOfFunction();\n\tvoid\t\t\tSkipToSemicolon();\n\tidTypeDef*\t\tCheckType();\n\tidTypeDef*\t\tParseType();\n\tidVarDef*\t\tFindImmediate( const idTypeDef* type, const eval_t* eval, const char* string ) const;\n\tidVarDef*\t\tGetImmediate( idTypeDef* type, const eval_t* eval, const char* string );\n\tidVarDef*\t\tVirtualFunctionConstant( idVarDef* func );\n\tidVarDef*\t\tSizeConstant( int size );\n\tidVarDef*\t\tJumpConstant( int value );\n\tidVarDef*\t\tJumpDef( int jumpfrom, int jumpto );\n\tidVarDef*\t\tJumpTo( int jumpto );\n\tidVarDef*\t\tJumpFrom( int jumpfrom );\n\tidVarDef*\t\tParseImmediate();\n\tidVarDef*\t\tEmitFunctionParms( int op, idVarDef* func, int startarg, int startsize, idVarDef* object );\n\tidVarDef*\t\tParseFunctionCall( idVarDef* func );\n\tidVarDef*\t\tParseObjectCall( idVarDef* object, idVarDef* func );\n\tidVarDef*\t\tParseEventCall( idVarDef* object, idVarDef* func );\n\tidVarDef*\t\tParseSysObjectCall( idVarDef* func );\n\tidVarDef*\t\tLookupDef( const char* name, const idVarDef* baseobj );\n\tidVarDef*\t\tParseValue();\n\tidVarDef*\t\tGetTerm();\n\tbool\t\t\tTypeMatches( etype_t type1, etype_t type2 ) const;\n\tidVarDef*\t\tGetExpression( int priority );\n\tidTypeDef*\t\tGetTypeForEventArg( char argType );\n\tvoid\t\t\tPatchLoop( int start, int continuePos );\n\tvoid\t\t\tParseReturnStatement();\n\tvoid\t\t\tParseWhileStatement();\n\tvoid\t\t\tParseForStatement();\n\tvoid\t\t\tParseDoWhileStatement();\n\tvoid\t\t\tParseIfStatement();\n\tvoid\t\t\tParseStatement();\n\tvoid\t\t\tParseObjectDef( const char* objname );\n\tidTypeDef*\t\tParseFunction( idTypeDef* returnType, const char* name );\n\tvoid\t\t\tParseFunctionDef( idTypeDef* returnType, const char* name );\n\tvoid\t\t\tParseVariableDef( idTypeDef* type, const char* name );\n\tvoid\t\t\tParseEventDef( idTypeDef* type, const char* name );\n\tvoid\t\t\tParseDefs();\n\tvoid\t\t\tParseNamespace( idVarDef* newScope );\n\t\npublic :\n\t// RB: added const\n\tstatic const opcode_t\topcodes[];\n\t// RB end\n\t\n\tidCompiler();\n\tvoid\t\t\tCompileFile( const char* text, const char* filename, bool console );\n"]], "pred": {"ppl": 2.462669849395752, "ppl_lower": 2.812490940093994, "ppl/lowercase_ppl": -1.1473787072900132, "ppl/zlib": 0.0009177658513843112, "Min_5.0% Prob": 7.432698502260096, "Min_10.0% Prob": 5.724009130515304, "Min_20.0% Prob": 3.8981618255961177, "Min_30.0% Prob": 2.8791623172027614, "Min_40.0% Prob": 2.2285764029017288, "Min_50.0% Prob": 1.7995329108635973, "Min_60.0% Prob": 1.5031741316579161}}
{"hexsha": "b71717ce3358f1f1db43661e002a0fc0c57dff92", "ext": "c", "lang": "C", "content": "int8_t mpack_expect_i8(mpack_reader_t* reader) {\n    mpack_tag_t var = mpack_read_tag(reader);\n    if (var.type == mpack_type_uint) {\n        if (var.v.u <= INT8_MAX)\n            return (int8_t)var.v.u;\n    } else if (var.type == mpack_type_int) {\n        if (var.v.i >= INT8_MIN && var.v.i <= INT8_MAX)\n            return (int8_t)var.v.i;\n    }\n    mpack_reader_flag_error(reader, mpack_error_type);\n    return 0;\n}", "item_id": 7, "repo": "thingforward/slyft-tutorials", "file": "slyft-tut-3/lib/private_lib/mpack/mpack-expect.c", "last_update_at": "2018-03-30T02:13:01+00:00", "question_id": "b71717ce3358f1f1db43661e002a0fc0c57dff92_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int8_t mpack_expect_i8(mpack_reader_t* reader) {\n    mpack_tag_t var = mpack_read_tag(reader);\n    if (var.type == mpack_type_uint) {\n        if (var.v.u <= INT8_MAX)\n            return (int8_t)var.v.u;\n    } else if (var.type == mpack_type_int) {\n        if (var.v.i >= INT8_MIN && var.v.i <= INT8_MAX)\n            return (int8_t)var.v.i;\n    }\n    mpack_reader_flag_error(reader, mpack_error_type);\n    return 0;\n"]], "pred": {"ppl": 1.5482908487319946, "ppl_lower": 1.6457678079605103, "ppl/lowercase_ppl": -1.1396663706555128, "ppl/zlib": 0.00228875206438115, "Min_5.0% Prob": 6.124242663383484, "Min_10.0% Prob": 3.7543803944307217, "Min_20.0% Prob": 2.0948986453669414, "Min_30.0% Prob": 1.4345528836239059, "Min_40.0% Prob": 1.0986966117950423, "Min_50.0% Prob": 0.8774499037324197, "Min_60.0% Prob": 0.7294422862831643}}
{"hexsha": "f8e6e63035d02662a37b037103da54a359aab876", "ext": "c", "lang": "C", "content": "static void\npropagate_follows(grammar_t self, int *changed)\n{\n    int i, j, k;\n\n    /* Go through the kernels and propagate stuff */\n    for (i = 0; i < self->kernel_count; i++) {\n        kernel_t kernel = self->kernels[i];\n\n        /* Go through each kernel item */\n        for (j = 0; j < kernel->count; j++) {\n            /* Go through the productions */\n            for (k = -1; k < self->production_count; k++) {\n                /* See if we propagate */\n                if (k < 0 || kernel->propagates_table[j][k]) {\n                    int pi;\n                    int offset;\n\n                    /* Work out the production and offset */\n                    if (k < 0) {\n                        offset = decode(self, kernel->pairs[j], &pi);\n                    } else {\n                        pi = k;\n                        offset = 0;\n                    }\n\n                    /* Propagate everything in the follows table */\n                    propagate_kernel_item_follows(\n                        self, kernel, j,\n                        self->productions[pi], offset,\n                        changed);\n                }\n            }\n        }\n    }\n}", "item_id": 19, "repo": "da4089/tpc", "file": "grammar.c", "last_update_at": "2018-04-21T07:52:20+00:00", "question_id": "f8e6e63035d02662a37b037103da54a359aab876_19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\npropagate_follows(grammar_t self, int *changed)\n{\n    int i, j, k;\n    /* Go through the kernels and propagate stuff */\n    for (i = 0; i < self->kernel_count; i++) {\n        kernel_t kernel = self->kernels[i];\n        /* Go through each kernel item */\n        for (j = 0; j < kernel->count; j++) {\n            /* Go through the productions */\n            for (k = -1; k < self->production_count; k++) {\n                /* See if we propagate */\n                if (k < 0 || kernel->propagates_table[j][k]) {\n                    int pi;\n                    int offset;\n                    /* Work out the production and offset */\n                    if (k < 0) {\n                        offset = decode(self, kernel->pairs[j], &pi);\n                    } else {\n                        pi = k;\n                        offset = 0;\n                    }\n                    /* Propagate everything in the follows table */\n                    propagate_kernel_item_follows(\n                        self, kernel, j,\n                        self->productions[pi], offset,\n                        changed);\n                }\n            }\n        }\n    }\n"]], "pred": {"ppl": 2.66121506690979, "ppl_lower": 2.680799961090088, "ppl/lowercase_ppl": -1.0074913783530828, "ppl/zlib": 0.002422729729126781, "Min_5.0% Prob": 8.391280396779377, "Min_10.0% Prob": 6.225259327119397, "Min_20.0% Prob": 4.117008878338721, "Min_30.0% Prob": 3.044381132151218, "Min_40.0% Prob": 2.3945704164505006, "Min_50.0% Prob": 1.9406300296259533, "Min_60.0% Prob": 1.6303770693732387}}
{"hexsha": "cf1fe79b9a833586a14663a1bdd856cb721c3ff8", "ext": "c", "lang": "C", "content": "uint_t\ntcp_read_rwbuf_ncs (T_TCP_CEP *cep, void *data, uint_t len)\n{\n\tuint_t\toffset;\n\n\t/* \u901a\u4fe1\u7aef\u70b9\u3092\u30ed\u30c3\u30af\u3059\u308b\u3002*/\n\tsyscall(wai_sem(cep->semid_lock));\n\n\t/* len \u3068\u53d7\u4fe1\u30a6\u30a3\u30f3\u30c9\u30d0\u30c3\u30d5\u30a1\u306e\u30c7\u30fc\u30bf\u6570\u306e\u5c0f\u3055\u3044\u65b9\u3092\u53d6\u308a\u51fa\u3059\u30c7\u30fc\u30bf\u6570\u306b\u3059\u308b\u3002*/\n\tif (len > cep->rwbuf_count)\n\t\tlen = cep->rwbuf_count;\n\n\t/* \u8aad\u307f\u51fa\u3057\u30dd\u30a4\u30f3\u30bf\u304c\u30e9\u30a6\u30f3\u30c9\u3059\u308b\u3068\u304d\u306e\u51e6\u7406 */\n\tif (len > cep->rbufsz - (cep->rbuf_rptr - (uint8_t*)cep->rbuf)) {\n\t\toffset = (uint_t)(cep->rbufsz - (cep->rbuf_rptr -(uint8_t*)cep->rbuf));\n\t\tmemcpy(data, cep->rbuf_rptr, (size_t)offset);\n\t\tcep->rwbuf_count -= offset;\n\t\tcep->rbuf_rptr   = (uint8_t*)cep->rbuf;\n\t\t}\n\telse\n\t\toffset = 0;\n\n\tmemcpy((void*)((uint8_t*)data + offset), cep->rbuf_rptr, (size_t)(len - offset));\n\tcep->rwbuf_count -= len - offset;\n\tcep->rbuf_rptr  += len - offset;\n\n\t/* \u901a\u4fe1\u7aef\u70b9\u306e\u30ed\u30c3\u30af\u3092\u89e3\u9664\u3059\u308b\u3002*/\n\tsyscall(sig_sem(cep->semid_lock));\n\n\treturn len;\n\t}", "item_id": 7, "repo": "robotan0921/mruby_on_tinet-tecs", "file": "asp3/tinet/netinet/tcp_subr_ncs.c", "last_update_at": "2018-04-03T08:52:05+00:00", "question_id": "cf1fe79b9a833586a14663a1bdd856cb721c3ff8_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["uint_t\ntcp_read_rwbuf_ncs (T_TCP_CEP *cep, void *data, uint_t len)\n{\n\tuint_t\toffset;\n\t/* \u901a\u4fe1\u7aef\u70b9\u3092\u30ed\u30c3\u30af\u3059\u308b\u3002*/\n\tsyscall(wai_sem(cep->semid_lock));\n\t/* len \u3068\u53d7\u4fe1\u30a6\u30a3\u30f3\u30c9\u30d0\u30c3\u30d5\u30a1\u306e\u30c7\u30fc\u30bf\u6570\u306e\u5c0f\u3055\u3044\u65b9\u3092\u53d6\u308a\u51fa\u3059\u30c7\u30fc\u30bf\u6570\u306b\u3059\u308b\u3002*/\n\tif (len > cep->rwbuf_count)\n\t\tlen = cep->rwbuf_count;\n\t/* \u8aad\u307f\u51fa\u3057\u30dd\u30a4\u30f3\u30bf\u304c\u30e9\u30a6\u30f3\u30c9\u3059\u308b\u3068\u304d\u306e\u51e6\u7406 */\n\tif (len > cep->rbufsz - (cep->rbuf_rptr - (uint8_t*)cep->rbuf)) {\n\t\toffset = (uint_t)(cep->rbufsz - (cep->rbuf_rptr -(uint8_t*)cep->rbuf));\n\t\tmemcpy(data, cep->rbuf_rptr, (size_t)offset);\n\t\tcep->rwbuf_count -= offset;\n\t\tcep->rbuf_rptr   = (uint8_t*)cep->rbuf;\n\t\t}\n\telse\n\t\toffset = 0;\n\tmemcpy((void*)((uint8_t*)data + offset), cep->rbuf_rptr, (size_t)(len - offset));\n\tcep->rwbuf_count -= len - offset;\n\tcep->rbuf_rptr  += len - offset;\n\t/* \u901a\u4fe1\u7aef\u70b9\u306e\u30ed\u30c3\u30af\u3092\u89e3\u9664\u3059\u308b\u3002*/\n\tsyscall(sig_sem(cep->semid_lock));\n\treturn len;\n"]], "pred": {"ppl": 2.0533175468444824, "ppl_lower": 2.1171672344207764, "ppl/lowercase_ppl": -1.042562922931574, "ppl/zlib": 0.0015082951795024621, "Min_5.0% Prob": 6.860250541142055, "Min_10.0% Prob": 5.096197111662044, "Min_20.0% Prob": 3.3195876298948774, "Min_30.0% Prob": 2.3445479269175564, "Min_40.0% Prob": 1.7838914182489318, "Min_50.0% Prob": 1.4382334739676919, "Min_60.0% Prob": 1.2018799348410694}}
{"hexsha": "ecc2fc0bed423de59ae0c245442703afd1aa8e0d", "ext": "h", "lang": "C", "content": "class rioreceive\n{\n\tpublic:\n\t\tvoid init();\n\t\tvoid get(std::vector<int> &centre_xs, std::vector<double> &angles, std::vector<double> &distances, std::string& message);\n\t\tvoid test();\n\n\tprivate:\n\t\tint sockfd;\n\t\tstruct sockaddr_in addr;\n}", "item_id": 0, "repo": "swan58/2018-PowerUp", "file": "5663/src/include/rioreceive.h", "last_update_at": "2018-01-26T05:58:48+00:00", "question_id": "ecc2fc0bed423de59ae0c245442703afd1aa8e0d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class rioreceive\n{\n\tpublic:\n\t\tvoid init();\n\t\tvoid get(std::vector<int> &centre_xs, std::vector<double> &angles, std::vector<double> &distances, std::string& message);\n\t\tvoid test();\n\tprivate:\n\t\tint sockfd;\n\t\tstruct sockaddr_in addr;\n"]], "pred": {"ppl": 5.225693225860596, "ppl_lower": 5.225693225860596, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.010807761201674553, "Min_5.0% Prob": 10.318635940551758, "Min_10.0% Prob": 7.908419026268853, "Min_20.0% Prob": 5.997061106893751, "Min_30.0% Prob": 4.903875218497382, "Min_40.0% Prob": 3.983022979564137, "Min_50.0% Prob": 3.2309841215610504, "Min_60.0% Prob": 2.7444436842745}}
{"hexsha": "960624e1518955a53d27cd7ddb71a3be8731398b", "ext": "c", "lang": "C", "content": "static void\narc4_randomstir (void)\n{\n\tu_int8_t key[256];\n\tint r, n;\n\tstruct timeval tv_now;\n\n\t/*\n\t * XXX read_random() returns unsafe numbers if the entropy\n\t * device is not loaded -- MarkM.\n\t */\n\tr = read_random(key, ARC4_KEYBYTES);\n\tgetmicrouptime(&tv_now);\n\tmtx_lock(&arc4_mtx);\n\t/* If r == 0 || -1, just use what was on the stack. */\n\tif (r > 0) {\n\t\tfor (n = r; n < sizeof(key); n++)\n\t\t\tkey[n] = key[n % r];\n\t}\n\n\tfor (n = 0; n < 256; n++) {\n\t\tarc4_j = (arc4_j + arc4_sbox[n] + key[n]) % 256;\n\t\tarc4_swap(&arc4_sbox[n], &arc4_sbox[arc4_j]);\n\t}\n\tarc4_i = arc4_j = 0;\n\n\t/* Reset for next reseed cycle. */\n\tarc4_t_reseed = tv_now.tv_sec + ARC4_RESEED_SECONDS;\n\tarc4_numruns = 0;\n\n\t/*\n\t * Throw away the first N words of output, as suggested in the\n\t * paper \"Weaknesses in the Key Scheduling Algorithm of RC4\"\n\t * by Fluher, Mantin, and Shamir.  (N = 256 in our case.)\n\t */\n\tfor (n = 0; n < 256*4; n++)\n\t\tarc4_randbyte();\n\tmtx_unlock(&arc4_mtx);\n}", "item_id": 1, "repo": "dcui/FreeBSD-9.3_kernel", "file": "sys/libkern/arc4random.c", "last_update_at": "2018-01-11T01:01:38+00:00", "question_id": "960624e1518955a53d27cd7ddb71a3be8731398b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\narc4_randomstir (void)\n{\n\tu_int8_t key[256];\n\tint r, n;\n\tstruct timeval tv_now;\n\t/*\n\t * XXX read_random() returns unsafe numbers if the entropy\n\t * device is not loaded -- MarkM.\n\t */\n\tr = read_random(key, ARC4_KEYBYTES);\n\tgetmicrouptime(&tv_now);\n\tmtx_lock(&arc4_mtx);\n\t/* If r == 0 || -1, just use what was on the stack. */\n\tif (r > 0) {\n\t\tfor (n = r; n < sizeof(key); n++)\n\t\t\tkey[n] = key[n % r];\n\t}\n\tfor (n = 0; n < 256; n++) {\n\t\tarc4_j = (arc4_j + arc4_sbox[n] + key[n]) % 256;\n\t\tarc4_swap(&arc4_sbox[n], &arc4_sbox[arc4_j]);\n\t}\n\tarc4_i = arc4_j = 0;\n\t/* Reset for next reseed cycle. */\n\tarc4_t_reseed = tv_now.tv_sec + ARC4_RESEED_SECONDS;\n\tarc4_numruns = 0;\n\t/*\n\t * Throw away the first N words of output, as suggested in the\n\t * paper \"Weaknesses in the Key Scheduling Algorithm of RC4\"\n\t * by Fluher, Mantin, and Shamir.  (N = 256 in our case.)\n\t */\n\tfor (n = 0; n < 256*4; n++)\n\t\tarc4_randbyte();\n\tmtx_unlock(&arc4_mtx);\n"]], "pred": {"ppl": 2.414949893951416, "ppl_lower": 2.758519411087036, "ppl/lowercase_ppl": -1.1508662688260227, "ppl/zlib": 0.0015468044544615647, "Min_5.0% Prob": 6.933094154704701, "Min_10.0% Prob": 5.315956772698296, "Min_20.0% Prob": 3.6990662813186646, "Min_30.0% Prob": 2.7659994028780583, "Min_40.0% Prob": 2.1657865012248796, "Min_50.0% Prob": 1.7545532595300883, "Min_60.0% Prob": 1.4671105121187593}}
{"hexsha": "dfab238654a3003a955a6790101ab660b9b1767b", "ext": "c", "lang": "C", "content": "static int matchString(const char **strptr, const char *against)\n{\n    const char *str = *strptr;\n    while (*against != 0) {\n        if (*str != *against)\n            return 0;\n        str++;\n        against++;\n    }\n    *strptr = str;\n    return 1;\n}", "item_id": 0, "repo": "isabella232/incubator-retired-corinthia", "file": "DocFormats/core/src/css/CSSSyntax.c", "last_update_at": "2018-03-24T18:39:35+00:00", "question_id": "dfab238654a3003a955a6790101ab660b9b1767b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int matchString(const char **strptr, const char *against)\n{\n    const char *str = *strptr;\n    while (*against != 0) {\n        if (*str != *against)\n            return 0;\n        str++;\n        against++;\n    }\n    *strptr = str;\n    return 1;\n"]], "pred": {"ppl": 2.0466320514678955, "ppl_lower": 2.136981964111328, "ppl/lowercase_ppl": -1.060317320709629, "ppl/zlib": 0.005115682431316762, "Min_5.0% Prob": 7.86800229549408, "Min_10.0% Prob": 5.580188751220703, "Min_20.0% Prob": 3.261493707404417, "Min_30.0% Prob": 2.2873601214243817, "Min_40.0% Prob": 1.8022987360463423, "Min_50.0% Prob": 1.4412484039920708, "Min_60.0% Prob": 1.195591980072025}}
{"hexsha": "c8f4fd03545e3ae97891921e1d8c918d317db6a6", "ext": "c", "lang": "C", "content": "char* get_end(char *p)\r\n{\r\n\tif (!p) return p;\r\n\tchar c = *p;\r\n\tif (('p' <= c) && (c <= 'z'))\r\n\t\treturn p + 1;\r\n\telse switch (c)\r\n\t{\r\n\tcase 'N':\treturn get_end(p + 1);\r\n\tcase 'C':\r\n\tcase 'D':\r\n\tcase 'E':\r\n\tcase 'I':\treturn get_end(get_end(p + 1));\r\n\t}\r\n\treturn NULL;\r\n}", "item_id": 0, "repo": "asterix314/poj-problems", "file": "poj/1126.c", "last_update_at": "2018-10-24T03:52:06+00:00", "question_id": "c8f4fd03545e3ae97891921e1d8c918d317db6a6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["char* get_end(char *p)\r\n{\r\n\tif (!p) return p;\r\n\tchar c = *p;\r\n\tif (('p' <= c) && (c <= 'z'))\r\n\t\treturn p + 1;\r\n\telse switch (c)\r\n\t{\r\n\tcase 'N':\treturn get_end(p + 1);\r\n\tcase 'C':\r\n\tcase 'D':\r\n\tcase 'E':\r\n\tcase 'I':\treturn get_end(get_end(p + 1));\r\n\t}\r\n\treturn NULL;\r\n"]], "pred": {"ppl": 2.704418420791626, "ppl_lower": 2.741658926010132, "ppl/lowercase_ppl": -1.0137465848461193, "ppl/zlib": 0.006218043047665756, "Min_5.0% Prob": 7.269710620244344, "Min_10.0% Prob": 5.63502443753756, "Min_20.0% Prob": 3.9999372959136963, "Min_30.0% Prob": 3.0949402287602426, "Min_40.0% Prob": 2.4172332176455744, "Min_50.0% Prob": 1.965875235002707, "Min_60.0% Prob": 1.6629771473875017}}
{"hexsha": "0c114c6d73450c3b69405ae74a3c6a13e4fee696", "ext": "c", "lang": "C", "content": "static void callback_recv(void *p_cookie, int status, const struct mdns_entry *entries)\n{\n    int ret = 0;\n    struct mdns_entry *entry = NULL;\n    service_state_t *state = NULL;\n    service_t *service = NULL;\n\n    service_t *node, *next;\n    int find = 0;\n    uint8_t required = 0;\n    if (p_cookie == NULL) {\n        return;\n    }\n    if (status < 0) {\n        log_e(\"get entries err, status = %d\", status);\n        return;\n    }\n\n    state = (service_state_t *)p_cookie;\n    service = hal_malloc(sizeof(service_t));\n    memset(service, 0, sizeof(service_t));\n\n    if (service == NULL) {\n        return ;\n    }\n    entry = (struct mdns_entry *)entries;\n    while (entry != NULL) {\n        switch (entry->type) {\n            case RR_A:\n                break;\n            case RR_PTR:\n                /*\n                                if (entry->data.PTR.domain != NULL) {\n                                    strncpy(service->srv_name, entry->data.PTR.domain, SERVICE_NAME_LEN_MAX);\n                                }\n                */\n                break;\n            case RR_TXT: {\n                txt_item_t *txt_next = entry->data.TXT;\n                while (txt_next != NULL) {\n                    txt_item_t *txt;\n                    txt = hal_malloc(sizeof(txt_item_t));\n                    memset(txt, 0, sizeof(txt_item_t));\n                    if (txt == NULL) {\n                        goto err;\n                    }\n                    memcpy(txt->txt, txt_next->txt, strlen(txt_next->txt));\n                    txt->next = service->txt_items;\n                    service->txt_items = txt;\n                    txt_next = txt_next->next;\n                };\n            }\n            break;\n            case RR_AAAA:\n                required |= 0x01;\n                memcpy(&service->id.ip6, entry->data.AAAA.addr.s6_addr, sizeof(service->id.ip6));\n                break;\n            case RR_SRV: {\n                char *name = NULL;\n                char *type = NULL;\n                char *last = NULL;\n                int num = get_char_num(entry->name, '.');\n                if (num == 2) {\n                    name = UMESH_SRV_DEFAULT_NANE;\n                    char *type = (char *)strtok_r(entry->name, \".\", &last);\n                    if (type == NULL || strlen(type) == 0) {\n                        break;\n                    }\n                } else if (num == 3) {\n                    name = (char *)strtok_r(entry->name, \".\", &last);\n                    type = (char *)strtok_r(NULL, \".\", &last);\n                    if (name == NULL || strlen(name) == 0) {\n                        break;\n                    }\n                    if (type == NULL || strlen(type) == 0) {\n                        break;\n                    }\n                } else {\n                    log_w(\"mdns srv: unknow format!\");\n                    break;\n                }\n\n                required |= 0x02;\n\n                strncpy(service->srv_name, name, SERVICE_NAME_LEN_MAX);\n                strncpy(service->srv_type, type, SERVICE_TYPE_LEN_MAX);\n                service->ttl = entry->ttl;\n                log_d(\" srv type = %s,TTL = %d\", type, service->ttl);\n                if (service->ttl == 0) {\n                    service->ttl = SERVICE_TTL;\n                }\n                service->id.port = entry->data.SRV.port;\n            }\n            break;\n            default:\n                break;\n        }\n\n        entry = entry->next;\n    };\n\n    if ((required & 0x03) != 0x03) {\n        log_e(\"service not complete\");\n        ret = UMESH_SRV_ERR_SERVICE_INCOMPLETE;\n        goto err;\n    }\n    hal_mutex_lock(state->lock);\n    list_for_each_entry_safe(node, next, &state->found_service_list, linked_list, service_t) {\n        if (!strcmp(node->srv_name, service->srv_name) && !strcmp(node->srv_type, service->srv_type)) {\n            node->last_update = hal_now_ms();\n            find = 1;\n            break;\n        }\n    }\n\n    if (!find && list_entry_number(&state->found_service_list) < SERVICE_MAX_FOUND_NUM) {\n        log_d(\"add serivce to found list:%s-%s\", service->srv_type, service->srv_name);\n        service->last_update = hal_now_ms();\n        list_add_tail(&service->linked_list, &state->found_service_list);\n        if (state->found_cb) {\n            state->found_cb(service, PEER_FOUND, state->found_cb_ctx);\n        }\n    }  else {\n        ret = umesh_service_free(service);\n    }\n    hal_mutex_unlock(state->lock);\n    return;\nerr:\n    log_e(\"service incomplete, discarded! ret = %d\", ret);\n    if (service != NULL) {\n        umesh_service_free(service);\n    }\n    return;\n}", "item_id": 8, "repo": "HelloAllen8893/AliOS-Things", "file": "components/network/umesh2/local_comm/src/umesh_api.c", "last_update_at": "2018-11-28T03:19:22+00:00", "question_id": "0c114c6d73450c3b69405ae74a3c6a13e4fee696_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void callback_recv(void *p_cookie, int status, const struct mdns_entry *entries)\n{\n    int ret = 0;\n    struct mdns_entry *entry = NULL;\n    service_state_t *state = NULL;\n    service_t *service = NULL;\n    service_t *node, *next;\n    int find = 0;\n    uint8_t required = 0;\n    if (p_cookie == NULL) {\n        return;\n    }\n    if (status < 0) {\n        log_e(\"get entries err, status = %d\", status);\n        return;\n    }\n    state = (service_state_t *)p_cookie;\n    service = hal_malloc(sizeof(service_t));\n    memset(service, 0, sizeof(service_t));\n    if (service == NULL) {\n        return ;\n    }\n    entry = (struct mdns_entry *)entries;\n    while (entry != NULL) {\n        switch (entry->type) {\n            case RR_A:\n                break;\n            case RR_PTR:\n                /*\n                                if (entry->data.PTR.domain != NULL) {\n                                    strncpy(service->srv_name, entry->data.PTR.domain, SERVICE_NAME_LEN_MAX);\n                                }\n                */\n                break;\n            case RR_TXT: {\n                txt_item_t *txt_next = entry->data.TXT;\n                while (txt_next != NULL) {\n                    txt_item_t *txt;\n                    txt = hal_malloc(sizeof(txt_item_t));\n                    memset(txt, 0, sizeof(txt_item_t));\n                    if (txt == NULL) {\n                        goto err;\n                    }\n                    memcpy(txt->txt, txt_next->txt, strlen(txt_next->txt));\n                    txt->next = service->txt_items;\n                    service->txt_items = txt;\n                    txt_next = txt_next->next;\n                };\n            }\n            break;\n            case RR_AAAA:\n                required |= 0x01;\n                memcpy(&service->id.ip6, entry->data.AAAA.addr.s6_addr, sizeof(service->id.ip6));\n                break;\n            case RR_SRV: {\n                char *name = NULL;\n                char *type = NULL;\n                char *last = NULL;\n                int num = get_char_num(entry->name, '.');\n                if (num == 2) {\n                    name = UMESH_SRV_DEFAULT_NANE;\n                    char *type = (char *)strtok_r(entry->name, \".\", &last);\n                    if (type == NULL || strlen(type) == 0) {\n                        break;\n                    }\n                } else if (num == 3) {\n                    name = (char *)strtok_r(entry->name, \".\", &last);\n                    type = (char *)strtok_r(NULL, \".\", &last);\n                    if (name == NULL || strlen(name) == 0) {\n                        break;\n                    }\n                    if (type == NULL || strlen(type) == 0) {\n                        break;\n                    }\n                } else {\n                    log_w(\"mdns srv: unknow format!\");\n                    break;\n                }\n                required |= 0x02;\n                strncpy(service->srv_name, name, SERVICE_NAME_LEN_MAX);\n                strncpy(service->srv_type, type, SERVICE_TYPE_LEN_MAX);\n                service->ttl = entry->ttl;\n                log_d(\" srv type = %s,TTL = %d\", type, service->ttl);\n                if (service->ttl == 0) {\n                    service->ttl = SERVICE_TTL;\n                }\n                service->id.port = entry->data.SRV.port;\n            }\n            break;\n            default:\n                break;\n        }\n        entry = entry->next;\n    };\n    if ((required & 0x03) != 0x03) {\n        log_e(\"service not complete\");\n        ret = UMESH_SRV_ERR_SERVICE_INCOMPLETE;\n        goto err;\n    }\n    hal_mutex_lock(state->lock);\n    list_for_each_entry_safe(node, next, &state->found_service_list, linked_list, service_t) {\n        if (!strcmp(node->srv_name, service->srv_name) && !strcmp(node->srv_type, service->srv_type)) {\n            node->last_update = hal_now_ms();\n            find = 1;\n            break;\n        }\n    }\n    if (!find && list_entry_number(&state->found_service_list) < SERVICE_MAX_FOUND_NUM) {\n        log_d(\"add serivce to found list:%s-%s\", service->srv_type, service->srv_name);\n        service->last_update = hal_now_ms();\n        list_add_tail(&service->linked_list, &state->found_service_list);\n        if (state->found_cb) {\n            state->found_cb(service, PEER_FOUND, state->found_cb_ctx);\n        }\n    }  else {\n        ret = umesh_service_free(service);\n    }\n    hal_mutex_unlock(state->lock);\n    return;\nerr:\n    log_e(\"service incomplete, discarded! ret = %d\", ret);\n    if (service != NULL) {\n        umesh_service_free(service);\n    }\n    return;\n"]], "pred": {"ppl": 1.9470679759979248, "ppl_lower": 1.9723052978515625, "ppl/lowercase_ppl": -1.0193275481944708, "ppl/zlib": 0.0005347709783140768, "Min_5.0% Prob": 6.190810764537138, "Min_10.0% Prob": 4.621124994521048, "Min_20.0% Prob": 3.028924052913984, "Min_30.0% Prob": 2.166028838482947, "Min_40.0% Prob": 1.651506732794067, "Min_50.0% Prob": 1.3295408596089675, "Min_60.0% Prob": 1.1106075755188312}}
{"hexsha": "0d12aaaf2468bdedee26fc3fc1668e1fd4c1c739", "ext": "c", "lang": "C", "content": "void iotx_ds_common_update_time(iotx_shadow_pt pshadow, uint32_t new_timestamp)\n{\n    HAL_MutexLock(pshadow->mutex);\n    pshadow->inner_data.time.base_system_time = utils_time_get_ms();\n    pshadow->inner_data.time.epoch_time = new_timestamp;\n    HAL_MutexUnlock(pshadow->mutex);\n\n    log_info(\"update system time\");\n}", "item_id": 5, "repo": "qrsforever/leiot_sdk", "file": "src/shadow/shadow_common.c", "last_update_at": "2018-09-28T05:06:17+00:00", "question_id": "0d12aaaf2468bdedee26fc3fc1668e1fd4c1c739_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void iotx_ds_common_update_time(iotx_shadow_pt pshadow, uint32_t new_timestamp)\n{\n    HAL_MutexLock(pshadow->mutex);\n    pshadow->inner_data.time.base_system_time = utils_time_get_ms();\n    pshadow->inner_data.time.epoch_time = new_timestamp;\n    HAL_MutexUnlock(pshadow->mutex);\n    log_info(\"update system time\");\n"]], "pred": {"ppl": 3.0790622234344482, "ppl_lower": 3.760673999786377, "ppl/lowercase_ppl": -1.1778131422190365, "ppl/zlib": 0.0061120928136592515, "Min_5.0% Prob": 8.2463169892629, "Min_10.0% Prob": 6.843048731486003, "Min_20.0% Prob": 4.933069677352905, "Min_30.0% Prob": 3.557724737807324, "Min_40.0% Prob": 2.799859880208969, "Min_50.0% Prob": 2.2532972221573195, "Min_60.0% Prob": 1.876999339358391}}
{"hexsha": "ae58658fd0c92c187a5c72421e32cabfd92c22ac", "ext": "c", "lang": "C", "content": "int func6()\n{\n\thash(6);\n\tled_data ++ ;\n\tXGpio_DiscreteWrite(&LED_Gpio, 1, led_data);\n\tfor (int Delay = 0; Delay < 3*LED_DELAY; Delay++);\n\tled_data -- ;\n\tXGpio_DiscreteWrite(&LED_Gpio, 1, led_data);\n\tfor (int Delay = 0; Delay < LED_DELAY; Delay++);\n\tfor(int x=0 ; x<=3 ; x++)\n\t{\n\tled_data ++ ;\n\tXGpio_DiscreteWrite(&LED_Gpio, 1, led_data);\n\tfor (int Delay = 0; Delay < LED_DELAY; Delay++);\n\tled_data -- ;\n\tXGpio_DiscreteWrite(&LED_Gpio, 1, led_data);\n\tfor (int Delay = 0; Delay < LED_DELAY; Delay++);\n\t}\n\tfor (int Delay = 0; Delay < 2*LED_DELAY; Delay++);\n}", "item_id": 6, "repo": "roo16kie/Dividor__Verilog", "file": "program1/led_irpt.c", "last_update_at": "2018-12-13T22:50:33+00:00", "question_id": "ae58658fd0c92c187a5c72421e32cabfd92c22ac_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int func6()\n{\n\thash(6);\n\tled_data ++ ;\n\tXGpio_DiscreteWrite(&LED_Gpio, 1, led_data);\n\tfor (int Delay = 0; Delay < 3*LED_DELAY; Delay++);\n\tled_data -- ;\n\tXGpio_DiscreteWrite(&LED_Gpio, 1, led_data);\n\tfor (int Delay = 0; Delay < LED_DELAY; Delay++);\n\tfor(int x=0 ; x<=3 ; x++)\n\t{\n\tled_data ++ ;\n\tXGpio_DiscreteWrite(&LED_Gpio, 1, led_data);\n\tfor (int Delay = 0; Delay < LED_DELAY; Delay++);\n\tled_data -- ;\n\tXGpio_DiscreteWrite(&LED_Gpio, 1, led_data);\n\tfor (int Delay = 0; Delay < LED_DELAY; Delay++);\n\t}\n\tfor (int Delay = 0; Delay < 2*LED_DELAY; Delay++);\n"]], "pred": {"ppl": 1.9731709957122803, "ppl_lower": 2.2482097148895264, "ppl/lowercase_ppl": -1.1920015934305703, "ppl/zlib": 0.004247761819734081, "Min_5.0% Prob": 7.936772970052866, "Min_10.0% Prob": 5.470488716054846, "Min_20.0% Prob": 3.26911116860531, "Min_30.0% Prob": 2.2540043448040517, "Min_40.0% Prob": 1.7051580626414053, "Min_50.0% Prob": 1.3576829810078967, "Min_60.0% Prob": 1.1337620359402654}}
{"hexsha": "54fe4f710c588207604d8fe76a71f4b670855025", "ext": "c", "lang": "C", "content": "ER\neOutput_getOffset(CELLIDX idx, T_OFF_BUF* offset)\n{\n\tER\t\tercd = E_OK;\n\tCELLCB\t*p_cellcb;\n\tif (VALID_IDX(idx)) {\n\t\tp_cellcb = GET_CELLCB(idx);\n\t}\n\telse {\n\t\treturn(E_ID);\n\t} /* end if VALID_IDX(idx) */\n\n\t/* \u3053\u3053\u306b\u51e6\u7406\u672c\u4f53\u3092\u8a18\u8ff0\u3057\u307e\u3059 #_TEFB_# */\n\toffset->iphdrlen = IP4_HDR_SIZE;\n\toffset->ipmss \t = TCP_MSS;\n\n\tif(is_cEthernetOutput_joined()) {\t\t\t//mikan \u3044\u307e\u3044\u3061\u672a\u5b8c\n\t\toffset->protocolflag |= FLAG_USE_ETHER;\n\t\toffset->ifhdrlen \t  = ETHER_HDR_SIZE;\n\t\toffset->ifalign \t  = NETBUFFER_ALIGN;\n\t\treturn E_OK;\n\t}\n\n\treturn E_ID;\n}", "item_id": 1, "repo": "robotan0921/mruby_on_tinet-tecs", "file": "asp3/tinet/netinet/tIPv4Output.c", "last_update_at": "2018-04-03T08:52:05+00:00", "question_id": "54fe4f710c588207604d8fe76a71f4b670855025_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ER\neOutput_getOffset(CELLIDX idx, T_OFF_BUF* offset)\n{\n\tER\t\tercd = E_OK;\n\tCELLCB\t*p_cellcb;\n\tif (VALID_IDX(idx)) {\n\t\tp_cellcb = GET_CELLCB(idx);\n\t}\n\telse {\n\t\treturn(E_ID);\n\t} /* end if VALID_IDX(idx) */\n\t/* \u3053\u3053\u306b\u51e6\u7406\u672c\u4f53\u3092\u8a18\u8ff0\u3057\u307e\u3059 #_TEFB_# */\n\toffset->iphdrlen = IP4_HDR_SIZE;\n\toffset->ipmss \t = TCP_MSS;\n\tif(is_cEthernetOutput_joined()) {\t\t\t//mikan \u3044\u307e\u3044\u3061\u672a\u5b8c\n\t\toffset->protocolflag |= FLAG_USE_ETHER;\n\t\toffset->ifhdrlen \t  = ETHER_HDR_SIZE;\n\t\toffset->ifalign \t  = NETBUFFER_ALIGN;\n\t\treturn E_OK;\n\t}\n\treturn E_ID;\n"]], "pred": {"ppl": 3.2958662509918213, "ppl_lower": 4.988927841186523, "ppl/lowercase_ppl": -1.34758343012401, "ppl/zlib": 0.003081832124120137, "Min_5.0% Prob": 8.677285466875349, "Min_10.0% Prob": 6.974757364818028, "Min_20.0% Prob": 5.013002063546862, "Min_30.0% Prob": 3.770460312565168, "Min_40.0% Prob": 2.9414759050788626, "Min_50.0% Prob": 2.3770064285823276, "Min_60.0% Prob": 1.9863871944225615}}
{"hexsha": "4f3e7642740bc08ef0dbbfd9f04d03fb4be60715", "ext": "c", "lang": "C", "content": "svm_msg_q_t *\nsvm_msg_q_alloc (svm_msg_q_cfg_t * cfg)\n{\n  svm_msg_q_ring_t *ring;\n  svm_msg_q_t *mq;\n  uword size;\n  int i;\n\n  if (!cfg)\n    return 0;\n\n  mq = clib_mem_alloc_aligned (sizeof (svm_msg_q_t), CLIB_CACHE_LINE_BYTES);\n  memset (mq, 0, sizeof (*mq));\n  mq->q = svm_queue_init (cfg->q_nitems, sizeof (svm_msg_q_msg_t),\n\t\t\t  cfg->consumer_pid, 0);\n  vec_validate (mq->rings, cfg->n_rings - 1);\n  for (i = 0; i < cfg->n_rings; i++)\n    {\n      ring = &mq->rings[i];\n      ring->elsize = cfg->ring_cfgs[i].elsize;\n      ring->nitems = cfg->ring_cfgs[i].nitems;\n      if (cfg->ring_cfgs[i].data)\n\tring->data = cfg->ring_cfgs[i].data;\n      else\n\t{\n\t  size = (uword) ring->nitems * ring->elsize;\n\t  ring->data = clib_mem_alloc_aligned (size, CLIB_CACHE_LINE_BYTES);\n\t}\n    }\n\n  return mq;\n}", "item_id": 0, "repo": "kanehuange/vpp", "file": "src/svm/message_queue.c", "last_update_at": "2018-09-04T09:01:23+00:00", "question_id": "4f3e7642740bc08ef0dbbfd9f04d03fb4be60715_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["svm_msg_q_t *\nsvm_msg_q_alloc (svm_msg_q_cfg_t * cfg)\n{\n  svm_msg_q_ring_t *ring;\n  svm_msg_q_t *mq;\n  uword size;\n  int i;\n  if (!cfg)\n    return 0;\n  mq = clib_mem_alloc_aligned (sizeof (svm_msg_q_t), CLIB_CACHE_LINE_BYTES);\n  memset (mq, 0, sizeof (*mq));\n  mq->q = svm_queue_init (cfg->q_nitems, sizeof (svm_msg_q_msg_t),\n\t\t\t  cfg->consumer_pid, 0);\n  vec_validate (mq->rings, cfg->n_rings - 1);\n  for (i = 0; i < cfg->n_rings; i++)\n    {\n      ring = &mq->rings[i];\n      ring->elsize = cfg->ring_cfgs[i].elsize;\n      ring->nitems = cfg->ring_cfgs[i].nitems;\n      if (cfg->ring_cfgs[i].data)\n\tring->data = cfg->ring_cfgs[i].data;\n      else\n\t{\n\t  size = (uword) ring->nitems * ring->elsize;\n\t  ring->data = clib_mem_alloc_aligned (size, CLIB_CACHE_LINE_BYTES);\n\t}\n    }\n  return mq;\n"]], "pred": {"ppl": 1.5748217105865479, "ppl_lower": 1.6520605087280273, "ppl/lowercase_ppl": -1.105432284969929, "ppl/zlib": 0.0012307373068900984, "Min_5.0% Prob": 4.863123994124563, "Min_10.0% Prob": 3.2957742458734756, "Min_20.0% Prob": 2.0795978009700775, "Min_30.0% Prob": 1.4910139167665417, "Min_40.0% Prob": 1.1371503649160075, "Min_50.0% Prob": 0.907374008915064, "Min_60.0% Prob": 0.7572918951927506}}
{"hexsha": "9977ee713654e075e81c0392d1ffe82b6d65ca4e", "ext": "c", "lang": "C", "content": "int qmi_parse_pds_get_gps_service_state_response(struct qmi_msg *msg, struct qmi_pds_get_gps_service_state_response *res)\n{\n\tvoid *tlv_buf = &msg->svc.tlv;\n\tunsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);\n\tstruct tlv *tlv;\n\tint i;\n\tuint32_t found[1] = {};\n\n\tmemset(res, 0, sizeof(*res));\n\n\t__qmi_alloc_reset();\n\twhile ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {\n\t\tunsigned int cur_tlv_len = le16_to_cpu(tlv->len);\n\t\tunsigned int ofs = 0;\n\n\t\tswitch(tlv->type) {\n\t\tcase 0x01:\n\t\t\tif (found[0] & (1 << 1))\n\t\t\t\tbreak;\n\n\t\t\tfound[0] |= (1 << 1);\n\t\t\tres->set.state = 1;\n\t\t\tres->data.state.gps_service_state = *(uint8_t *) get_next(1);\n\t\t\tres->data.state.tracking_session_state = *(uint8_t *) get_next(1);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror_len:\n\tfprintf(stderr, \"%s: Invalid TLV length in message, tlv=0x%02x, len=%d\\n\",\n\t        __func__, tlv->type, le16_to_cpu(tlv->len));\n\treturn QMI_ERROR_INVALID_DATA;\n}", "item_id": 5, "repo": "ECRS/Asus-RT-N16", "file": "release/src/router/uqmi/qmi-message-pds.c", "last_update_at": "2018-08-21T03:43:31+00:00", "question_id": "9977ee713654e075e81c0392d1ffe82b6d65ca4e_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int qmi_parse_pds_get_gps_service_state_response(struct qmi_msg *msg, struct qmi_pds_get_gps_service_state_response *res)\n{\n\tvoid *tlv_buf = &msg->svc.tlv;\n\tunsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);\n\tstruct tlv *tlv;\n\tint i;\n\tuint32_t found[1] = {};\n\tmemset(res, 0, sizeof(*res));\n\t__qmi_alloc_reset();\n\twhile ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {\n\t\tunsigned int cur_tlv_len = le16_to_cpu(tlv->len);\n\t\tunsigned int ofs = 0;\n\t\tswitch(tlv->type) {\n\t\tcase 0x01:\n\t\t\tif (found[0] & (1 << 1))\n\t\t\t\tbreak;\n\t\t\tfound[0] |= (1 << 1);\n\t\t\tres->set.state = 1;\n\t\t\tres->data.state.gps_service_state = *(uint8_t *) get_next(1);\n\t\t\tres->data.state.tracking_session_state = *(uint8_t *) get_next(1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nerror_len:\n\tfprintf(stderr, \"%s: Invalid TLV length in message, tlv=0x%02x, len=%d\\n\",\n\t        __func__, tlv->type, le16_to_cpu(tlv->len));\n\treturn QMI_ERROR_INVALID_DATA;\n"]], "pred": {"ppl": 1.3775925636291504, "ppl_lower": 1.5210798978805542, "ppl/lowercase_ppl": -1.3093084591681585, "ppl/zlib": 0.0006355901916950324, "Min_5.0% Prob": 4.5623055126356045, "Min_10.0% Prob": 2.8295913105425625, "Min_20.0% Prob": 1.5666417394481276, "Min_30.0% Prob": 1.0650764024020105, "Min_40.0% Prob": 0.802835745013157, "Min_50.0% Prob": 0.6403977150738529, "Min_60.0% Prob": 0.534223720939962}}
{"hexsha": "87e968aceb9ca3266b2a1de9ff1297c7d2f77f7f", "ext": "c", "lang": "C", "content": "void bvconst_add2(uint32_t *bv, uint32_t k, uint32_t *a1, uint32_t *a2) {\n  uint64_t aux;\n\n  assert(k>0);\n  aux = 0;\n  do {\n    aux += ((uint64_t) (*a1)) + ((uint64_t) (*a2));\n    *bv = (uint32_t) aux;\n    aux >>= 32;\n    a1 ++;\n    a2 ++;\n    bv ++;\n    k --;\n  } while (k > 0);\n}", "item_id": 51, "repo": "maelvls/ocamlyices2", "file": "ext/yices/src/terms/bv_constants.c", "last_update_at": "2018-11-23T00:16:01+00:00", "question_id": "87e968aceb9ca3266b2a1de9ff1297c7d2f77f7f_51", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void bvconst_add2(uint32_t *bv, uint32_t k, uint32_t *a1, uint32_t *a2) {\n  uint64_t aux;\n  assert(k>0);\n  aux = 0;\n  do {\n    aux += ((uint64_t) (*a1)) + ((uint64_t) (*a2));\n    *bv = (uint32_t) aux;\n    aux >>= 32;\n    a1 ++;\n    a2 ++;\n    bv ++;\n    k --;\n  } while (k > 0);\n"]], "pred": {"ppl": 2.5045254230499268, "ppl_lower": 2.5045254230499268, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.005738120404451736, "Min_5.0% Prob": 7.377661977495466, "Min_10.0% Prob": 5.585247627894083, "Min_20.0% Prob": 3.8593217326748754, "Min_30.0% Prob": 2.870923120924767, "Min_40.0% Prob": 2.2421983054706027, "Min_50.0% Prob": 1.8156261655348767, "Min_60.0% Prob": 1.5362572949379683}}
{"hexsha": "56dd26ea5d357cfcfd99cb5a5b48278749598a54", "ext": "c", "lang": "C", "content": "long sys_fcntl(unsigned long fd, long cmd, long arg)\n{\n\tstruct file *file;\n\n\tif (fd > NR_OPEN || !(file = (CURRENT_TASK() )->file[fd]))\n\t\treturn -EBADF;\n\n\tswitch (cmd) {\n\tcase F_DUPFD:\n\t\treturn dupfd(fd, arg);\n\tdefault:\n\t\treturn -EIO;\n\t}\n}", "item_id": 2, "repo": "menqgingyu/JunOS-V0.5", "file": "kernel/fs/fcntl.c", "last_update_at": "2018-03-04T03:01:56+00:00", "question_id": "56dd26ea5d357cfcfd99cb5a5b48278749598a54_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["long sys_fcntl(unsigned long fd, long cmd, long arg)\n{\n\tstruct file *file;\n\tif (fd > NR_OPEN || !(file = (CURRENT_TASK() )->file[fd]))\n\t\treturn -EBADF;\n\tswitch (cmd) {\n\tcase F_DUPFD:\n\t\treturn dupfd(fd, arg);\n\tdefault:\n\t\treturn -EIO;\n\t}\n"]], "pred": {"ppl": 2.497174024581909, "ppl_lower": 3.219172477722168, "ppl/lowercase_ppl": -1.2775085365423575, "ppl/zlib": 0.00489390215151915, "Min_5.0% Prob": 8.283512401580811, "Min_10.0% Prob": 6.17882100018588, "Min_20.0% Prob": 3.9166865673932163, "Min_30.0% Prob": 2.836313570990707, "Min_40.0% Prob": 2.2223270894451574, "Min_50.0% Prob": 1.8187100063670765, "Min_60.0% Prob": 1.5299775734205137}}
{"hexsha": "9681a7cb7e4eef11575b3e6e38fc7168eda43f0a", "ext": "c", "lang": "C", "content": "TEST_CASE(mktime_1)\n{\n  struct tm tm;\n  time_t t = 0;\n  TEST_FAIL_IF(mktime(localtime(&t)) != 0);\n  t = time(NULL);\n  TEST_FAIL_IF(time(NULL) - mktime(localtime(&t)) > 1);\n  TEST(1);\n}", "item_id": 13, "repo": "block8437/FailSafeC", "file": "test/unix/time.test.c", "last_update_at": "2018-02-10T02:52:09+00:00", "question_id": "9681a7cb7e4eef11575b3e6e38fc7168eda43f0a_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["TEST_CASE(mktime_1)\n{\n  struct tm tm;\n  time_t t = 0;\n  TEST_FAIL_IF(mktime(localtime(&t)) != 0);\n  t = time(NULL);\n  TEST_FAIL_IF(time(NULL) - mktime(localtime(&t)) > 1);\n  TEST(1);\n"]], "pred": {"ppl": 2.717683792114258, "ppl_lower": 3.3610310554504395, "ppl/lowercase_ppl": -1.2125145775971324, "ppl/zlib": 0.008926606879633646, "Min_5.0% Prob": 7.899394869804382, "Min_10.0% Prob": 6.188039090898302, "Min_20.0% Prob": 4.252632009355645, "Min_30.0% Prob": 3.115164919146176, "Min_40.0% Prob": 2.4762776776363977, "Min_50.0% Prob": 1.998239441619565, "Min_60.0% Prob": 1.6653492447502654}}
{"hexsha": "655175928e7e666dc5dcb7db8a2652bce8102f62", "ext": "c", "lang": "C", "content": "static struct ieee80211_node *\nmwl_node_alloc(struct ieee80211vap *vap, const uint8_t mac[IEEE80211_ADDR_LEN])\n{\n\tstruct ieee80211com *ic = vap->iv_ic;\n\tstruct mwl_softc *sc = ic->ic_ifp->if_softc;\n\tconst size_t space = sizeof(struct mwl_node);\n\tstruct mwl_node *mn;\n\n\tmn = malloc(space, M_80211_NODE, M_NOWAIT|M_ZERO);\n\tif (mn == NULL) {\n\t\t/* XXX stat+msg */\n\t\treturn NULL;\n\t}\n\tDPRINTF(sc, MWL_DEBUG_NODE, \"%s: mn %p\\n\", __func__, mn);\n\treturn &mn->mn_node;\n}", "item_id": 51, "repo": "dcui/FreeBSD-9.3_kernel", "file": "sys/dev/mwl/if_mwl.c", "last_update_at": "2018-01-11T01:01:38+00:00", "question_id": "655175928e7e666dc5dcb7db8a2652bce8102f62_51", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static struct ieee80211_node *\nmwl_node_alloc(struct ieee80211vap *vap, const uint8_t mac[IEEE80211_ADDR_LEN])\n{\n\tstruct ieee80211com *ic = vap->iv_ic;\n\tstruct mwl_softc *sc = ic->ic_ifp->if_softc;\n\tconst size_t space = sizeof(struct mwl_node);\n\tstruct mwl_node *mn;\n\tmn = malloc(space, M_80211_NODE, M_NOWAIT|M_ZERO);\n\tif (mn == NULL) {\n\t\t/* XXX stat+msg */\n\t\treturn NULL;\n\t}\n\tDPRINTF(sc, MWL_DEBUG_NODE, \"%s: mn %p\\n\", __func__, mn);\n\treturn &mn->mn_node;\n"]], "pred": {"ppl": 1.482193112373352, "ppl_lower": 2.3203461170196533, "ppl/lowercase_ppl": -2.1389264164065622, "ppl/zlib": 0.0012944829724673716, "Min_5.0% Prob": 5.130657304417003, "Min_10.0% Prob": 3.344478213268778, "Min_20.0% Prob": 1.8956589850973575, "Min_30.0% Prob": 1.3071818575263023, "Min_40.0% Prob": 0.9812013401075247, "Min_50.0% Prob": 0.7898149243257462, "Min_60.0% Prob": 0.6557636681972203}}
{"hexsha": "39661e8cbdda950f95dc5083bb4b7b6c042e193f", "ext": "c", "lang": "C", "content": "TEST test_raster_null_raster()\n{\n    unsigned char buffer[1];\n    ASSERT_EAARLIO_ERR(\n        EAARLIO_NULL, eaarlio_tld_unpack_raster(\n                          (unsigned char *)&buffer, 1, NULL, NULL, 0, 0));\n    PASS();\n}", "item_id": 12, "repo": "usgs/eaarl-io", "file": "library/tests/test_tld_unpack.c", "last_update_at": "2018-11-16T06:44:19+00:00", "question_id": "39661e8cbdda950f95dc5083bb4b7b6c042e193f_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["TEST test_raster_null_raster()\n{\n    unsigned char buffer[1];\n    ASSERT_EAARLIO_ERR(\n        EAARLIO_NULL, eaarlio_tld_unpack_raster(\n                          (unsigned char *)&buffer, 1, NULL, NULL, 0, 0));\n    PASS();\n"]], "pred": {"ppl": 5.3355536460876465, "ppl_lower": 9.244572639465332, "ppl/lowercase_ppl": -1.3282646876358395, "ppl/zlib": 0.01123753460121279, "Min_5.0% Prob": 9.413580417633057, "Min_10.0% Prob": 7.880079567432404, "Min_20.0% Prob": 5.849618448930628, "Min_30.0% Prob": 4.748716363540063, "Min_40.0% Prob": 3.8862321206501553, "Min_50.0% Prob": 3.248053805394606, "Min_60.0% Prob": 2.7636427373256325}}
{"hexsha": "47e987f5f40938c18c24e90791ceebb45ea4030c", "ext": "c", "lang": "C", "content": "JNICALL Java_com_bitmark_cryptography_crypto_sodium_SodiumJNI_crypto_1auth_1hmacsha512_1bytes(JNIEnv *jenv, jclass jcls) {\n  jint jresult = 0 ;\n  size_t result;\n  \n  (void)jenv;\n  (void)jcls;\n  result = crypto_auth_hmacsha512_bytes();\n  jresult = (jint)result; \n  return jresult;\n}", "item_id": 172, "repo": "bitmark-inc/bitmark-sdk-java", "file": "cryptography/jni/sodium_wrap.c", "last_update_at": "2018-09-21T05:01:42+00:00", "question_id": "47e987f5f40938c18c24e90791ceebb45ea4030c_172", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["JNICALL Java_com_bitmark_cryptography_crypto_sodium_SodiumJNI_crypto_1auth_1hmacsha512_1bytes(JNIEnv *jenv, jclass jcls) {\n  jint jresult = 0 ;\n  size_t result;\n  (void)jenv;\n  (void)jcls;\n  result = crypto_auth_hmacsha512_bytes();\n  jresult = (jint)result; \n  return jresult;\n"]], "pred": {"ppl": 2.060415267944336, "ppl_lower": 3.0756165981292725, "ppl/lowercase_ppl": -1.5541481101361585, "ppl/zlib": 0.003886599725088339, "Min_5.0% Prob": 6.151646852493286, "Min_10.0% Prob": 4.79623924768888, "Min_20.0% Prob": 3.2661847930688124, "Min_30.0% Prob": 2.3673334633692718, "Min_40.0% Prob": 1.81433507355933, "Min_50.0% Prob": 1.455880791715418, "Min_60.0% Prob": 1.2138528280207912}}
{"hexsha": "d1e594c3e741e39d8d103b170a6975b463fa4d95", "ext": "c", "lang": "C", "content": "struct IndexData * IndexDataCreate()\n{\n\tstruct IndexData * ret = malloc( sizeof( struct IndexData ) );\n\tret->indexcount = 0;\n#ifdef USE_IBO\n\tret->ido = 0;\n#else\n\tret->indexdata = 0;\n#endif\n}", "item_id": 21, "repo": "cnlohr/bridgesim", "file": "src/cclient/graphics/graphicscore.c", "last_update_at": "2018-05-09T22:27:33+00:00", "question_id": "d1e594c3e741e39d8d103b170a6975b463fa4d95_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct IndexData * IndexDataCreate()\n{\n\tstruct IndexData * ret = malloc( sizeof( struct IndexData ) );\n\tret->indexcount = 0;\n#ifdef USE_IBO\n\tret->ido = 0;\n#else\n\tret->indexdata = 0;\n#endif\n"]], "pred": {"ppl": 4.578751564025879, "ppl_lower": 5.543118953704834, "ppl/lowercase_ppl": -1.1256261601662865, "ppl/zlib": 0.012171411013555377, "Min_5.0% Prob": 9.344317436218262, "Min_10.0% Prob": 8.283013411930629, "Min_20.0% Prob": 6.175732629639762, "Min_30.0% Prob": 4.772350140980312, "Min_40.0% Prob": 3.716324717834078, "Min_50.0% Prob": 3.056014428122176, "Min_60.0% Prob": 2.572967758012372}}
{"hexsha": "077ade691ebc998d455a13f561b09ece94a1f115", "ext": "h", "lang": "C", "content": "class ModApiHttp : public ModApiBase {\nprivate:\n#if USE_CURL\n\t// Helpers for HTTP fetch functions\n\tstatic void read_http_fetch_request(lua_State *L, HTTPFetchRequest &req);\n\tstatic void push_http_fetch_result(lua_State *L, HTTPFetchResult &res, bool completed = true);\n\n\t// http_fetch_async({url=, timeout=, post_data=})\n\tstatic int l_http_fetch_async(lua_State *L);\n\n\t// http_fetch_async_get(handle)\n\tstatic int l_http_fetch_async_get(lua_State *L);\n\n\t// request_http_api()\n\tstatic int l_request_http_api(lua_State *L);\n#endif\n\npublic:\n\tstatic void Initialize(lua_State *L, int top);\n}", "item_id": 0, "repo": "crazyBaboon/MathWorlds", "file": "src/script/lua_api/l_http.h", "last_update_at": "2018-03-01T13:03:01+00:00", "question_id": "077ade691ebc998d455a13f561b09ece94a1f115_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class ModApiHttp : public ModApiBase {\nprivate:\n#if USE_CURL\n\t// Helpers for HTTP fetch functions\n\tstatic void read_http_fetch_request(lua_State *L, HTTPFetchRequest &req);\n\tstatic void push_http_fetch_result(lua_State *L, HTTPFetchResult &res, bool completed = true);\n\t// http_fetch_async({url=, timeout=, post_data=})\n\tstatic int l_http_fetch_async(lua_State *L);\n\t// http_fetch_async_get(handle)\n\tstatic int l_http_fetch_async_get(lua_State *L);\n\t// request_http_api()\n\tstatic int l_request_http_api(lua_State *L);\n#endif\npublic:\n\tstatic void Initialize(lua_State *L, int top);\n"]], "pred": {"ppl": 3.2248995304107666, "ppl_lower": 3.948702573776245, "ppl/lowercase_ppl": -1.17293104070997, "ppl/zlib": 0.004137462178097022, "Min_5.0% Prob": 7.689338827133179, "Min_10.0% Prob": 6.4049739122390745, "Min_20.0% Prob": 4.689932363789256, "Min_30.0% Prob": 3.6033440376481702, "Min_40.0% Prob": 2.8433199155043405, "Min_50.0% Prob": 2.3175412756032667, "Min_60.0% Prob": 1.957783276275281}}
{"hexsha": "fecd166f4c24431102ac68587ad03086e10c5612", "ext": "c", "lang": "C", "content": "void runScheduler(){\n\tif(currentProcess->process.PID == 0 && allProcess > 1 && allProcessForeground > 0){\n\t\tcurrentProcess->process.status = LOCKED;\n\t}\n\n\tif(numberOfTicks < QUANTUM) {\n\t\t\t\n\t\tnumberOfTicks++;\n\t\tdisableTickInter();\n\t\tcheckIfThreadChange();\n\t\tenableTickInter();\n\t\treturn;\n\t}\n\t\n\t\n\tnumberOfTicks = 0;\n\n\n\tif(currentProcess->process.status == RUNNING){\n\t\tcurrentProcess->process.status = READY;\n\t}\n\n\tcurrentProcess = currentProcess->next;\n\n\twhile(currentProcess->process.status != READY){\n\t\tcurrentProcess = currentProcess->next;\n\t}\n\t\n\tcurrentProcess->process.status = RUNNING;\n}", "item_id": 0, "repo": "asantoflaminio/TP2_SO", "file": "Kernel/scheduler.c", "last_update_at": "2018-05-17T19:08:44+00:00", "question_id": "fecd166f4c24431102ac68587ad03086e10c5612_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void runScheduler(){\n\tif(currentProcess->process.PID == 0 && allProcess > 1 && allProcessForeground > 0){\n\t\tcurrentProcess->process.status = LOCKED;\n\t}\n\tif(numberOfTicks < QUANTUM) {\n\t\t\t\n\t\tnumberOfTicks++;\n\t\tdisableTickInter();\n\t\tcheckIfThreadChange();\n\t\tenableTickInter();\n\t\treturn;\n\t}\n\t\n\t\n\tnumberOfTicks = 0;\n\tif(currentProcess->process.status == RUNNING){\n\t\tcurrentProcess->process.status = READY;\n\t}\n\tcurrentProcess = currentProcess->next;\n\twhile(currentProcess->process.status != READY){\n\t\tcurrentProcess = currentProcess->next;\n\t}\n\t\n\tcurrentProcess->process.status = RUNNING;\n"]], "pred": {"ppl": 3.42470121383667, "ppl_lower": 3.97345232963562, "ppl/lowercase_ppl": -1.1207306028071566, "ppl/zlib": 0.0047165296209686815, "Min_5.0% Prob": 8.135898637771607, "Min_10.0% Prob": 6.606697445824032, "Min_20.0% Prob": 4.906201828357785, "Min_30.0% Prob": 3.7200180979875417, "Min_40.0% Prob": 2.975819856968037, "Min_50.0% Prob": 2.427499453226725, "Min_60.0% Prob": 2.0387170635163785}}
{"hexsha": "52041092ea22f29a5386520d8f56251651b5062c", "ext": "c", "lang": "C", "content": "void smt2_set_info(const char *name, aval_t value) {\n  smt2_globals_t *g;\n  smt2_keyword_t kw;\n  uint32_t n, version;\n\n  g = &__smt2_globals;\n\n  n = kwlen(name);\n  kw = smt2_string_to_keyword(name, n);\n\n  switch (kw) {\n  case SMT2_KW_ERROR_BEHAVIOR:\n  case SMT2_KW_NAME:\n  case SMT2_KW_AUTHORS:\n  case SMT2_KW_VERSION:\n  case SMT2_KW_REASON_UNKNOWN:\n  case SMT2_KW_ALL_STATISTICS:\n    print_error(\"can't overwrite %s\", name);\n    break;\n\n  case SMT2_KW_SMT_LIB_VERSION:\n    // quick hack to switch parser if 2.5 is selected\n    if (g->smtlib_version != 0) {\n      print_error(\"can't set :smt-lib-version twice\");\n    } else if (aval_is_known_version(g->avtbl, value, &version)) {\n      assert(version == 2000 || version == 2500);\n      g->smtlib_version = version;\n      if (version == 2500) {\n\tsmt2_lexer_activate_two_dot_five();\n      }\n      report_success();\n    } else {\n      print_error(\"unsupported :smt-lib-version\");\n    }\n    break;\n\n  default:\n    add_info(g, name, value);\n    report_success();\n    break;\n  }\n}", "item_id": 99, "repo": "maelvls/ocamlyices2", "file": "ext/yices/src/frontend/smt2/smt2_commands.c", "last_update_at": "2018-11-23T00:16:01+00:00", "question_id": "52041092ea22f29a5386520d8f56251651b5062c_99", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void smt2_set_info(const char *name, aval_t value) {\n  smt2_globals_t *g;\n  smt2_keyword_t kw;\n  uint32_t n, version;\n  g = &__smt2_globals;\n  n = kwlen(name);\n  kw = smt2_string_to_keyword(name, n);\n  switch (kw) {\n  case SMT2_KW_ERROR_BEHAVIOR:\n  case SMT2_KW_NAME:\n  case SMT2_KW_AUTHORS:\n  case SMT2_KW_VERSION:\n  case SMT2_KW_REASON_UNKNOWN:\n  case SMT2_KW_ALL_STATISTICS:\n    print_error(\"can't overwrite %s\", name);\n    break;\n  case SMT2_KW_SMT_LIB_VERSION:\n    // quick hack to switch parser if 2.5 is selected\n    if (g->smtlib_version != 0) {\n      print_error(\"can't set :smt-lib-version twice\");\n    } else if (aval_is_known_version(g->avtbl, value, &version)) {\n      assert(version == 2000 || version == 2500);\n      g->smtlib_version = version;\n      if (version == 2500) {\n\tsmt2_lexer_activate_two_dot_five();\n      }\n      report_success();\n    } else {\n      print_error(\"unsupported :smt-lib-version\");\n    }\n    break;\n  default:\n    add_info(g, name, value);\n    report_success();\n    break;\n  }\n"]], "pred": {"ppl": 2.5980770587921143, "ppl_lower": 2.8004002571105957, "ppl/lowercase_ppl": -1.0785431604696039, "ppl/zlib": 0.0018794716114596687, "Min_5.0% Prob": 7.705877802588723, "Min_10.0% Prob": 6.056103614243594, "Min_20.0% Prob": 4.032831552353772, "Min_30.0% Prob": 3.0180417245084588, "Min_40.0% Prob": 2.3432042159266393, "Min_50.0% Prob": 1.901854600841643, "Min_60.0% Prob": 1.5932255181431207}}
{"hexsha": "8876e7f3bfa35524c53cdb237e34bf62c286cfd7", "ext": "c", "lang": "C", "content": "static int\nport_imirror_lt_fields_parse(int unit,\n                             const bcmltd_field_t *key,\n                             const bcmltd_field_t *data,\n                             port_imirror_t *imirror)\n{\n    const bcmltd_field_t *gen_field;\n    uint32_t fid;\n    uint64_t fval;\n\n    SHR_FUNC_ENTER(unit);\n\n    sal_memset(imirror, 0, sizeof(*imirror));\n\n    /* Parse key field */\n    gen_field = key;\n    while (gen_field) {\n        fid = gen_field->id;\n        fval = gen_field->data;\n\n        switch (fid) {\n        case PORT_ING_MIRRORt_PORT_IDf:\n            imirror->port = fval;\n            SHR_BITSET(imirror->fbmp, fid);\n            break;\n        case PORT_ING_MIRRORt_MIRROR_INSTANCE_IDf:\n            imirror->instance_id = fval;\n            SHR_BITSET(imirror->fbmp, fid);\n            break;\n        default:\n            SHR_RETURN_VAL_EXIT(SHR_E_PARAM);\n        }\n        gen_field = gen_field->next;\n    }\n\n    /* Parse data field */\n    gen_field = data;\n    while (gen_field) {\n        fid = gen_field->id;\n        fval = gen_field->data;\n\n        switch (fid) {\n        case PORT_ING_MIRRORt_MIRROR_ENABLEf:\n            imirror->enable = fval;\n            SHR_BITSET(imirror->fbmp, fid);\n            break;\n        default:\n            SHR_RETURN_VAL_EXIT(SHR_E_PARAM);\n        }\n        gen_field = gen_field->next;\n    }\n\nexit:\n    SHR_FUNC_EXIT();\n}", "item_id": 0, "repo": "lguohan/SDKLT", "file": "src/bcmport/main/bcmport_imm.c", "last_update_at": "2018-01-31T07:21:49+00:00", "question_id": "8876e7f3bfa35524c53cdb237e34bf62c286cfd7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nport_imirror_lt_fields_parse(int unit,\n                             const bcmltd_field_t *key,\n                             const bcmltd_field_t *data,\n                             port_imirror_t *imirror)\n{\n    const bcmltd_field_t *gen_field;\n    uint32_t fid;\n    uint64_t fval;\n    SHR_FUNC_ENTER(unit);\n    sal_memset(imirror, 0, sizeof(*imirror));\n    /* Parse key field */\n    gen_field = key;\n    while (gen_field) {\n        fid = gen_field->id;\n        fval = gen_field->data;\n        switch (fid) {\n        case PORT_ING_MIRRORt_PORT_IDf:\n            imirror->port = fval;\n            SHR_BITSET(imirror->fbmp, fid);\n            break;\n        case PORT_ING_MIRRORt_MIRROR_INSTANCE_IDf:\n            imirror->instance_id = fval;\n            SHR_BITSET(imirror->fbmp, fid);\n            break;\n        default:\n            SHR_RETURN_VAL_EXIT(SHR_E_PARAM);\n        }\n        gen_field = gen_field->next;\n    }\n    /* Parse data field */\n    gen_field = data;\n    while (gen_field) {\n        fid = gen_field->id;\n        fval = gen_field->data;\n        switch (fid) {\n        case PORT_ING_MIRRORt_MIRROR_ENABLEf:\n            imirror->enable = fval;\n            SHR_BITSET(imirror->fbmp, fid);\n            break;\n        default:\n            SHR_RETURN_VAL_EXIT(SHR_E_PARAM);\n        }\n        gen_field = gen_field->next;\n    }\nexit:\n    SHR_FUNC_EXIT();\n"]], "pred": {"ppl": 1.2385309934616089, "ppl_lower": 1.619539737701416, "ppl/lowercase_ppl": -2.253779383720255, "ppl/zlib": 0.0005167294556363228, "Min_5.0% Prob": 3.633085260391235, "Min_10.0% Prob": 2.0395341974496843, "Min_20.0% Prob": 1.0699149952456355, "Min_30.0% Prob": 0.7126299793005533, "Min_40.0% Prob": 0.5360519133939116, "Min_50.0% Prob": 0.4277687912401725, "Min_60.0% Prob": 0.35699555561273544}}
{"hexsha": "774ed3fc9c97140400eba133562eac4e551115c4", "ext": "c", "lang": "C", "content": "void dvmDdmSendThreadNameChange(int threadId, StringObject* newName)\n{\n    if (!gDvm.ddmThreadNotification)\n        return;\n\n    size_t stringLen = dvmStringLen(newName);\n    const u2* chars = dvmStringChars(newName);\n\n    /*\n     * Output format:\n     *  (4b) thread ID\n     *  (4b) stringLen\n     *  (xb) string chars\n     */\n    int bufLen = 4 + 4 + (stringLen * 2);\n    u1 buf[bufLen];\n\n    set4BE(&buf[0x00], threadId);\n    set4BE(&buf[0x04], stringLen);\n    u2* outChars = (u2*) &buf[0x08];\n    while (stringLen--)\n        set2BE((u1*) (outChars++), *chars++);\n\n    dvmDbgDdmSendChunk(CHUNK_TYPE(\"THNM\"), bufLen, buf);\n}", "item_id": 6, "repo": "mcoughli/platform-dalvik", "file": "vm/Ddm.c", "last_update_at": "2018-03-07T04:33:50+00:00", "question_id": "774ed3fc9c97140400eba133562eac4e551115c4_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void dvmDdmSendThreadNameChange(int threadId, StringObject* newName)\n{\n    if (!gDvm.ddmThreadNotification)\n        return;\n    size_t stringLen = dvmStringLen(newName);\n    const u2* chars = dvmStringChars(newName);\n    /*\n     * Output format:\n     *  (4b) thread ID\n     *  (4b) stringLen\n     *  (xb) string chars\n     */\n    int bufLen = 4 + 4 + (stringLen * 2);\n    u1 buf[bufLen];\n    set4BE(&buf[0x00], threadId);\n    set4BE(&buf[0x04], stringLen);\n    u2* outChars = (u2*) &buf[0x08];\n    while (stringLen--)\n        set2BE((u1*) (outChars++), *chars++);\n    dvmDbgDdmSendChunk(CHUNK_TYPE(\"THNM\"), bufLen, buf);\n"]], "pred": {"ppl": 3.0587546825408936, "ppl_lower": 3.970107078552246, "ppl/lowercase_ppl": -1.2332588234869375, "ppl/zlib": 0.003297958308675661, "Min_5.0% Prob": 7.697219491004944, "Min_10.0% Prob": 6.30052152633667, "Min_20.0% Prob": 4.603958592695348, "Min_30.0% Prob": 3.5057750657985083, "Min_40.0% Prob": 2.746041107411478, "Min_50.0% Prob": 2.22144302574452, "Min_60.0% Prob": 1.8666758011003919}}
{"hexsha": "ea5a0ad4946ded29145c2bd5514b9379b4a85101", "ext": "c", "lang": "C", "content": "static int\nrp_event_notif_match_subscr(const char *ntf_xpath, const char *subscr_xpath)\n{\n    /* specific subscription for this notification */\n    if (!strcmp(ntf_xpath, subscr_xpath)) {\n        return 1;\n    }\n\n    /* whole module subscription */\n    if (!strcmp(subscr_xpath + strlen(subscr_xpath) - 4, \"*//.\") && !strncmp(ntf_xpath, subscr_xpath, strlen(subscr_xpath) - 4)) {\n        return 1;\n    }\n\n    return 0;\n}", "item_id": 50, "repo": "ADTRAN/sysrepo", "file": "src/request_processor.c", "last_update_at": "2018-09-09T08:39:47+00:00", "question_id": "ea5a0ad4946ded29145c2bd5514b9379b4a85101_50", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nrp_event_notif_match_subscr(const char *ntf_xpath, const char *subscr_xpath)\n{\n    /* specific subscription for this notification */\n    if (!strcmp(ntf_xpath, subscr_xpath)) {\n        return 1;\n    }\n    /* whole module subscription */\n    if (!strcmp(subscr_xpath + strlen(subscr_xpath) - 4, \"*//.\") && !strncmp(ntf_xpath, subscr_xpath, strlen(subscr_xpath) - 4)) {\n        return 1;\n    }\n    return 0;\n"]], "pred": {"ppl": 2.6346664428710938, "ppl_lower": 2.6346664428710938, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.004868123551933677, "Min_5.0% Prob": 8.266077450343541, "Min_10.0% Prob": 6.516483211517334, "Min_20.0% Prob": 4.34407738049825, "Min_30.0% Prob": 3.128022315767076, "Min_40.0% Prob": 2.4030020954708258, "Min_50.0% Prob": 1.941224676022927, "Min_60.0% Prob": 1.6230653511360287}}
{"hexsha": "02a113cae40488f23acabe7f0714840b3b481ffd", "ext": "c", "lang": "C", "content": "int** zigzagLevelOrder(struct TreeNode* root, int** columnSizes, int* returnSize)\n{\n\tstruct TreeNode** queue;\n\tint front, rear;\n\tint QueueSize;\n\tstruct TreeNode** stack;\n\tint top;\n\tint level, i;\n    int j, k;\n\tint** result;\n\tstruct TreeNode* T;\n\t*returnSize = 0;\n\n\tif(root == NULL)\n\t\treturn NULL;\n\n\tfront = 0;\n\trear = -1;\n\ttop = -1;\n\tlevel = 0;\n    j = 1;\n    k = 0;\n\t*columnSizes = (int*)malloc(sizeof(int));\n\tresult = (int**)malloc(sizeof(int*));\n    queue = (struct TreeNode**)malloc(sizeof(struct TreeNode*));\n    stack = (struct TreeNode**)malloc(sizeof(struct TreeNode*));\n\tqueue[++rear] = root;\n\tQueueSize= rear - front + 1;\n\twhile(QueueSize > 0)\n\t{\n\t\ti = 0;\n        \n        result = (int**)realloc(result, (level+1)*sizeof(int*));\n        result[level] = (int*)malloc(sizeof(int));\n\t\tif(level % 2 == 0)\n\t\t{\n\t\t\twhile(QueueSize > 0)\n\t\t\t{\n\t\t\t\tT = queue[front++];\n                result[level] = (int*)realloc(result[level], (i+1)*sizeof(int));\n\t\t\t\tresult[level][i++] = T->val;\n\t\t\t\tif(T->left)\n                {\n                    queue = (struct TreeNode**)realloc(queue, (++j)*sizeof(struct TreeNode*));\n                    queue[++rear] = T->left;\n                }\n\t\t\t\tif(T->right)\n                {\n                    queue = (struct TreeNode**)realloc(queue, (++j)*sizeof(struct TreeNode*));\n                    queue[++rear] = T->right;\n                }\n\t\t\t\tQueueSize--;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile(QueueSize > 0)\n\t\t\t{\n\t\t\t\tT = queue[front++];\n                stack = (struct TreeNode**)realloc(stack, (++k)*sizeof(struct TreeNode*));\n\t\t\t\tstack[++top] = T;\n\t\t\t\tif(T->left)\n                {\n                    queue = (struct TreeNode**)realloc(queue, (++j)*sizeof(struct TreeNode*));\n                    queue[++rear] = T->left;\n                }\n\t\t\t\tif(T->right)\n                {\n                    queue = (struct TreeNode**)realloc(queue, (++j)*sizeof(struct TreeNode*));\n                    queue[++rear] = T->right;\n                }\n\t\t\t\tQueueSize--;\n\t\t\t}\n\t\t\twhile(top != -1)\n\t\t\t{\n\t\t\t\tT = stack[top--];\n                result[level] = (int*)realloc(result[level], (i+1)*sizeof(int));\n\t\t\t\tresult[level][i++] = T->val;\n\t\t\t}\n\t\t}\n        (*columnSizes) = (int*)realloc((*columnSizes), (level+1)*sizeof(int));\n\t\t(*columnSizes)[level++] = i;\n\t\tQueueSize = rear - front + 1;\n\t}\n\n\t*returnSize = level;\n\treturn result;\n}", "item_id": 0, "repo": "VamosC/LeetCode", "file": "Tree/103BinaryTreeZigzagLevel OrderTraversal/src/103.c", "last_update_at": "2018-04-23T08:48:46+00:00", "question_id": "02a113cae40488f23acabe7f0714840b3b481ffd_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int** zigzagLevelOrder(struct TreeNode* root, int** columnSizes, int* returnSize)\n{\n\tstruct TreeNode** queue;\n\tint front, rear;\n\tint QueueSize;\n\tstruct TreeNode** stack;\n\tint top;\n\tint level, i;\n    int j, k;\n\tint** result;\n\tstruct TreeNode* T;\n\t*returnSize = 0;\n\tif(root == NULL)\n\t\treturn NULL;\n\tfront = 0;\n\trear = -1;\n\ttop = -1;\n\tlevel = 0;\n    j = 1;\n    k = 0;\n\t*columnSizes = (int*)malloc(sizeof(int));\n\tresult = (int**)malloc(sizeof(int*));\n    queue = (struct TreeNode**)malloc(sizeof(struct TreeNode*));\n    stack = (struct TreeNode**)malloc(sizeof(struct TreeNode*));\n\tqueue[++rear] = root;\n\tQueueSize= rear - front + 1;\n\twhile(QueueSize > 0)\n\t{\n\t\ti = 0;\n        result = (int**)realloc(result, (level+1)*sizeof(int*));\n        result[level] = (int*)malloc(sizeof(int));\n\t\tif(level % 2 == 0)\n\t\t{\n\t\t\twhile(QueueSize > 0)\n\t\t\t{\n\t\t\t\tT = queue[front++];\n                result[level] = (int*)realloc(result[level], (i+1)*sizeof(int));\n\t\t\t\tresult[level][i++] = T->val;\n\t\t\t\tif(T->left)\n                {\n                    queue = (struct TreeNode**)realloc(queue, (++j)*sizeof(struct TreeNode*));\n                    queue[++rear] = T->left;\n                }\n\t\t\t\tif(T->right)\n                {\n                    queue = (struct TreeNode**)realloc(queue, (++j)*sizeof(struct TreeNode*));\n                    queue[++rear] = T->right;\n                }\n\t\t\t\tQueueSize--;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile(QueueSize > 0)\n\t\t\t{\n\t\t\t\tT = queue[front++];\n                stack = (struct TreeNode**)realloc(stack, (++k)*sizeof(struct TreeNode*));\n\t\t\t\tstack[++top] = T;\n\t\t\t\tif(T->left)\n                {\n                    queue = (struct TreeNode**)realloc(queue, (++j)*sizeof(struct TreeNode*));\n                    queue[++rear] = T->left;\n                }\n\t\t\t\tif(T->right)\n                {\n                    queue = (struct TreeNode**)realloc(queue, (++j)*sizeof(struct TreeNode*));\n                    queue[++rear] = T->right;\n                }\n\t\t\t\tQueueSize--;\n\t\t\t}\n\t\t\twhile(top != -1)\n\t\t\t{\n\t\t\t\tT = stack[top--];\n                result[level] = (int*)realloc(result[level], (i+1)*sizeof(int));\n\t\t\t\tresult[level][i++] = T->val;\n\t\t\t}\n\t\t}\n        (*columnSizes) = (int*)realloc((*columnSizes), (level+1)*sizeof(int));\n\t\t(*columnSizes)[level++] = i;\n\t\tQueueSize = rear - front + 1;\n\t}\n\t*returnSize = level;\n\treturn result;\n"]], "pred": {"ppl": 1.3757914304733276, "ppl_lower": 1.4092316627502441, "ppl/lowercase_ppl": -1.0752767714183498, "ppl/zlib": 0.0005843024749658402, "Min_5.0% Prob": 4.08931400288235, "Min_10.0% Prob": 2.671654675783736, "Min_20.0% Prob": 1.5268750631109962, "Min_30.0% Prob": 1.0525474456041606, "Min_40.0% Prob": 0.794080224070261, "Min_50.0% Prob": 0.636620038026844, "Min_60.0% Prob": 0.5318806149036012}}
{"hexsha": "64655db5ced32871a85d4f40915dfefc2a7c8712", "ext": "c", "lang": "C", "content": "static int\nmemset_init(struct benchmark *bench, struct benchmark_args *args)\n{\n\tassert(bench != NULL);\n\tassert(args != NULL);\n\tassert(args->opts != NULL);\n\n\tint ret = 0;\n\n\tstruct memset_bench *mb = malloc(sizeof (struct memset_bench));\n\tif (!mb) {\n\t\tperror(\"malloc\");\n\t\treturn -1;\n\t}\n\n\tmb->pargs = args->opts;\n\tmb->pargs->chunk_size = args->dsize;\n\n\tenum operation_mode op_mode = parse_op_mode(mb->pargs->mode);\n\tif (op_mode == OP_MODE_UNKNOWN) {\n\t\tfprintf(stderr, \"Invalid operation mode argument '%s'\",\n\t\t\tmb->pargs->mode);\n\t\tret = -1;\n\t\tgoto err_free_mb;\n\t}\n\n\tsize_t size = MAX_OFFSET + mb->pargs->chunk_size;\n\tsize_t large = size * args->n_ops_per_thread * args->n_threads;\n\n\tsize_t small = size * args->n_threads;\n\n\tmb->fsize = (op_mode == OP_MODE_STAT) ? small : large;\n\n\tmb->n_randoms = args->n_ops_per_thread * args->n_threads;\n\tmb->randoms = malloc(mb->n_randoms * sizeof (*mb->randoms));\n\tif (!mb->randoms) {\n\t\tperror(\"malloc\");\n\t\tret = -1;\n\t\tgoto err_free_mb;\n\t}\n\n\tunsigned int seed = mb->pargs->seed;\n\tfor (int i = 0; i < mb->n_randoms; i++)\n\t\tmb->randoms[i] = rand_r(&seed) % args->n_ops_per_thread;\n\n\tmb->flags = O_CREAT | O_EXCL | O_RDWR;\n\n\t/* create a pmem file */\n\tmb->fd = open(args->fname, mb->flags, args->fmode);\n\tif (mb->fd == -1) {\n\t\tperror(args->fname);\n\t\tret = -1;\n\t\tgoto err_free_randoms;\n\t}\n\n\t/* allocate the pmem */\n\tif ((errno = posix_fallocate(mb->fd, 0, mb->fsize)) != 0) {\n\t\tperror(\"posix_fallocate\");\n\t\tret = -1;\n\t\tgoto err_close_file;\n\t}\n\n\t/* memory map it */\n\tmb->pmem_addr = pmem_map(mb->fd);\n\tif (mb->pmem_addr == NULL) {\n\t\tperror(\"pmem_map\");\n\t\tret = -1;\n\t\tgoto err_close_file;\n\t}\n\n\t/* set proper func_dest() depending on benchmark args */\n\tmb->func_dest = assign_mode_func(mb->pargs->mode);\n\tif (mb->func_dest == NULL) {\n\t\tfprintf(stderr, \"wrong mode parameter -- '%s'\",\n\t\t\t\tmb->pargs->mode);\n\t\tret = -1;\n\t\tgoto err_unmap;\n\t}\n\n\tif (mb->pargs->memset)\n\t\tmb->func_op = (mb->pargs->persist) ?\n\t\t\t\tlibc_memset_persist : libc_memset;\n\telse\n\t\tmb->func_op = (mb->pargs->persist) ?\n\t\t\t\tlibpmem_memset_persist : libpmem_memset_nodrain;\n\n\tif (!mb->pargs->no_warmup) {\n\t\tif (do_warmup(\n\t\t\tmb, args->n_threads * args->n_ops_per_thread) != 0) {\n\t\t\tfprintf(stderr, \"do_warmup() function failed.\");\n\t\t\tret = -1;\n\t\t\tgoto err_unmap;\n\t\t}\n\t}\n\n\tclose(mb->fd);\n\n\tpmembench_set_priv(bench, mb);\n\n\treturn 0;\n\nerr_unmap:\n\tmunmap(mb->pmem_addr, mb->fsize);\nerr_close_file:\n\tclose(mb->fd);\nerr_free_randoms:\n\tfree(mb->randoms);\nerr_free_mb:\n\tfree(mb);\n\n\treturn ret;\n}", "item_id": 4, "repo": "jessesleeping/my_peloton", "file": "third_party/nvml/src/benchmarks/pmem_memset.c", "last_update_at": "2018-11-06T07:06:49+00:00", "question_id": "64655db5ced32871a85d4f40915dfefc2a7c8712_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nmemset_init(struct benchmark *bench, struct benchmark_args *args)\n{\n\tassert(bench != NULL);\n\tassert(args != NULL);\n\tassert(args->opts != NULL);\n\tint ret = 0;\n\tstruct memset_bench *mb = malloc(sizeof (struct memset_bench));\n\tif (!mb) {\n\t\tperror(\"malloc\");\n\t\treturn -1;\n\t}\n\tmb->pargs = args->opts;\n\tmb->pargs->chunk_size = args->dsize;\n\tenum operation_mode op_mode = parse_op_mode(mb->pargs->mode);\n\tif (op_mode == OP_MODE_UNKNOWN) {\n\t\tfprintf(stderr, \"Invalid operation mode argument '%s'\",\n\t\t\tmb->pargs->mode);\n\t\tret = -1;\n\t\tgoto err_free_mb;\n\t}\n\tsize_t size = MAX_OFFSET + mb->pargs->chunk_size;\n\tsize_t large = size * args->n_ops_per_thread * args->n_threads;\n\tsize_t small = size * args->n_threads;\n\tmb->fsize = (op_mode == OP_MODE_STAT) ? small : large;\n\tmb->n_randoms = args->n_ops_per_thread * args->n_threads;\n\tmb->randoms = malloc(mb->n_randoms * sizeof (*mb->randoms));\n\tif (!mb->randoms) {\n\t\tperror(\"malloc\");\n\t\tret = -1;\n\t\tgoto err_free_mb;\n\t}\n\tunsigned int seed = mb->pargs->seed;\n\tfor (int i = 0; i < mb->n_randoms; i++)\n\t\tmb->randoms[i] = rand_r(&seed) % args->n_ops_per_thread;\n\tmb->flags = O_CREAT | O_EXCL | O_RDWR;\n\t/* create a pmem file */\n\tmb->fd = open(args->fname, mb->flags, args->fmode);\n\tif (mb->fd == -1) {\n\t\tperror(args->fname);\n\t\tret = -1;\n\t\tgoto err_free_randoms;\n\t}\n\t/* allocate the pmem */\n\tif ((errno = posix_fallocate(mb->fd, 0, mb->fsize)) != 0) {\n\t\tperror(\"posix_fallocate\");\n\t\tret = -1;\n\t\tgoto err_close_file;\n\t}\n\t/* memory map it */\n\tmb->pmem_addr = pmem_map(mb->fd);\n\tif (mb->pmem_addr == NULL) {\n\t\tperror(\"pmem_map\");\n\t\tret = -1;\n\t\tgoto err_close_file;\n\t}\n\t/* set proper func_dest() depending on benchmark args */\n\tmb->func_dest = assign_mode_func(mb->pargs->mode);\n\tif (mb->func_dest == NULL) {\n\t\tfprintf(stderr, \"wrong mode parameter -- '%s'\",\n\t\t\t\tmb->pargs->mode);\n\t\tret = -1;\n\t\tgoto err_unmap;\n\t}\n\tif (mb->pargs->memset)\n\t\tmb->func_op = (mb->pargs->persist) ?\n\t\t\t\tlibc_memset_persist : libc_memset;\n\telse\n\t\tmb->func_op = (mb->pargs->persist) ?\n\t\t\t\tlibpmem_memset_persist : libpmem_memset_nodrain;\n\tif (!mb->pargs->no_warmup) {\n\t\tif (do_warmup(\n\t\t\tmb, args->n_threads * args->n_ops_per_thread) != 0) {\n\t\t\tfprintf(stderr, \"do_warmup() function failed.\");\n\t\t\tret = -1;\n\t\t\tgoto err_unmap;\n\t\t}\n\t}\n\tclose(mb->fd);\n\tpmembench_set_priv(bench, mb);\n\treturn 0;\nerr_unmap:\n\tmunmap(mb->pmem_addr, mb->fsize);\nerr_close_file:\n\tclose(mb->fd);\nerr_free_randoms:\n\tfree(mb->randoms);\nerr_free_mb:\n\tfree(mb);\n\treturn ret;\n"]], "pred": {"ppl": 1.8690223693847656, "ppl_lower": 1.9345896244049072, "ppl/lowercase_ppl": -1.0551309116928125, "ppl/zlib": 0.0006980083672321274, "Min_5.0% Prob": 6.184509688732671, "Min_10.0% Prob": 4.555161959984723, "Min_20.0% Prob": 2.901235439321574, "Min_30.0% Prob": 2.05295772397635, "Min_40.0% Prob": 1.5572783051646135, "Min_50.0% Prob": 1.2503717313766654, "Min_60.0% Prob": 1.0433044528598527}}
{"hexsha": "5a5ce4e0ca764a9b0333d41085a4a154262ce591", "ext": "h", "lang": "C", "content": "inline void InsertTailList(\n\tplist_entry ListHead,\n\tplist_entry Entry\n)\n{\n\tplist_entry Blink;\n\n\tBlink = ListHead->Blink;\n\tEntry->Flink = ListHead;\n\tEntry->Blink = Blink;\n\tBlink->Flink = Entry;\n\tListHead->Blink = Entry;\n\treturn;\n}", "item_id": 3, "repo": "wyc6668205/common", "file": "list_entry.h", "last_update_at": "2018-11-16T02:53:08+00:00", "question_id": "5a5ce4e0ca764a9b0333d41085a4a154262ce591_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["inline void InsertTailList(\n\tplist_entry ListHead,\n\tplist_entry Entry\n)\n{\n\tplist_entry Blink;\n\tBlink = ListHead->Blink;\n\tEntry->Flink = ListHead;\n\tEntry->Blink = Blink;\n\tBlink->Flink = Entry;\n\tListHead->Blink = Entry;\n\treturn;\n"]], "pred": {"ppl": 2.0088794231414795, "ppl_lower": 3.437628984451294, "ppl/lowercase_ppl": -1.7701011770302557, "ppl/zlib": 0.00596219714260619, "Min_5.0% Prob": 8.788000345230103, "Min_10.0% Prob": 6.066967010498047, "Min_20.0% Prob": 3.4592927429411144, "Min_30.0% Prob": 2.313914484211377, "Min_40.0% Prob": 1.7672429758350592, "Min_50.0% Prob": 1.3943160282388487, "Min_60.0% Prob": 1.1706621983425325}}
{"hexsha": "5c9f565ea0e88840c3c3c7a031e20180c3c8025d", "ext": "c", "lang": "C", "content": "static void iser_free_ib_conn_res(struct iser_conn *iser_conn,\n\t\t\t\t  bool destroy)\n{\n\tstruct ib_conn *ib_conn = &iser_conn->ib_conn;\n\tstruct iser_device *device = ib_conn->device;\n\n\tiser_info(\"freeing conn %p cma_id %p qp %p\\n\",\n\t\t  iser_conn, ib_conn->cma_id, ib_conn->qp);\n\n\tif (ib_conn->qp != NULL) {\n\t\tib_conn->comp->active_qps--;\n\t\trdma_destroy_qp(ib_conn->cma_id);\n\t\tib_conn->qp = NULL;\n\t}\n\n\tif (destroy) {\n\t\tif (iser_conn->rx_descs)\n\t\t\tiser_free_rx_descriptors(iser_conn);\n\n\t\tif (device != NULL) {\n\t\t\tiser_device_try_release(device);\n\t\t\tib_conn->device = NULL;\n\t\t}\n\t}\n}", "item_id": 14, "repo": "SIIS-cloud/pileus", "file": "difc-kernel/pileus-kernel/drivers/infiniband/ulp/iser/iser_verbs.c", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "5c9f565ea0e88840c3c3c7a031e20180c3c8025d_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void iser_free_ib_conn_res(struct iser_conn *iser_conn,\n\t\t\t\t  bool destroy)\n{\n\tstruct ib_conn *ib_conn = &iser_conn->ib_conn;\n\tstruct iser_device *device = ib_conn->device;\n\tiser_info(\"freeing conn %p cma_id %p qp %p\\n\",\n\t\t  iser_conn, ib_conn->cma_id, ib_conn->qp);\n\tif (ib_conn->qp != NULL) {\n\t\tib_conn->comp->active_qps--;\n\t\trdma_destroy_qp(ib_conn->cma_id);\n\t\tib_conn->qp = NULL;\n\t}\n\tif (destroy) {\n\t\tif (iser_conn->rx_descs)\n\t\t\tiser_free_rx_descriptors(iser_conn);\n\t\tif (device != NULL) {\n\t\t\tiser_device_try_release(device);\n\t\t\tib_conn->device = NULL;\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.8790234327316284, "ppl_lower": 1.967029094696045, "ppl/lowercase_ppl": -1.0725675473442133, "ppl/zlib": 0.0022936443316580045, "Min_5.0% Prob": 5.302000320874727, "Min_10.0% Prob": 4.08318406564218, "Min_20.0% Prob": 2.7059076764366843, "Min_30.0% Prob": 1.9992512442716739, "Min_40.0% Prob": 1.5487398493019018, "Min_50.0% Prob": 1.2597248816631572, "Min_60.0% Prob": 1.0500186723967393}}
{"hexsha": "fd1867128f756754c01e89d416b432f573e59ede", "ext": "c", "lang": "C", "content": "bool dble_less_than(double x, double y, int precision)\n{\n\t// LOCAL VARIABLES\n\tbool retVal = false;  // Prove this wrong\n\tbool success = true;  // Set this to false if anything fails\n\tdouble dbleMask = 0;  // \"Mask\" to remove undesired values of doubles\n\tdouble xVal = truncate_double(x, precision);\n\tdouble yVal = truncate_double(y, precision);\n\t\n\t// INPUT VALIDATION\n\tif (precision < 1)\n\t{\n\t\tHARKLE_ERROR(Harklemath, dble_greater_than, Invalid precision);\n\t\tsuccess = false;\n\t}\n\t\n\t// CALC PRECISION\n\tif (true == success)\n\t{\n\t\tdbleMask = calc_precision(precision);\n\t\t\n\t\tif (!dbleMask)\n\t\t{\n\t\t\tHARKLE_ERROR(Harklemath, dble_greater_than, calc_precision failed);\n\t\t\tsuccess = false;\n\t\t}\n\t\t// fprintf(stdout, \"\\nx == %.15f\\ty == %.15f\\tdbleMask == %.15f\\n\", x, y, dbleMask);  // DEBUGGING\n\t\t// fprintf(stdout, \"\\nxTrunc == %.15f\\tyTrunc == %.15f\\tprecision == %d\\n\\t\\t\", xVal, yVal, precision);  // DEBUGGING\n\t}\n\t\n\t// COMPARE DOUBLES\n\tif (true == success)\n\t{\n\t\t// fprintf(stdout, \"\\nx == %.15f\\ty == %.15f\\tdbleMask == %.15f\\n\", x, y, dbleMask);  // DEBUGGING\n\t\t// fprintf(stdout, \"x < y == %.15f < %.15f == %s\\n\", x, y, (x < y) ? \"true\" : \"false\");  // DEBUGGING\n\t\t// fprintf(stdout, \"(x + dbleMask) < (y + dbleMask) == %.15f < %.15f == %s\\n\", \\\n\t\t// \tx + dbleMask, y + dbleMask, ((x + dbleMask) < (y + dbleMask)) ? \"true\" : \"false\");  // DEBUGGING\n\t\t// fprintf(stdout, \"(x - dbleMask) < (y - dbleMask) == %.15f < %.15f == %s\\n\\t\\t\", \\\n\t\t// \tx - dbleMask, y - dbleMask, ((x - dbleMask) < (y - dbleMask)) ? \"true\" : \"false\");  // DEBUGGING\n\t\tif (xVal < yVal)\n\t\t// if (x < y && (x + dbleMask) < (y + dbleMask) && (x - dbleMask) < (y - dbleMask))\n\t\t{\n\t\t\tretVal = true;\t\n\t\t}\t\t\n\t}\t\n\t\n\t// DONE\n\treturn retVal;\n}", "item_id": 2, "repo": "joshuadugie/Latissimus_Dorsi", "file": "3-Internals/Harklemath.c", "last_update_at": "2018-07-13T14:18:56+00:00", "question_id": "fd1867128f756754c01e89d416b432f573e59ede_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool dble_less_than(double x, double y, int precision)\n{\n\t// LOCAL VARIABLES\n\tbool retVal = false;  // Prove this wrong\n\tbool success = true;  // Set this to false if anything fails\n\tdouble dbleMask = 0;  // \"Mask\" to remove undesired values of doubles\n\tdouble xVal = truncate_double(x, precision);\n\tdouble yVal = truncate_double(y, precision);\n\t\n\t// INPUT VALIDATION\n\tif (precision < 1)\n\t{\n\t\tHARKLE_ERROR(Harklemath, dble_greater_than, Invalid precision);\n\t\tsuccess = false;\n\t}\n\t\n\t// CALC PRECISION\n\tif (true == success)\n\t{\n\t\tdbleMask = calc_precision(precision);\n\t\t\n\t\tif (!dbleMask)\n\t\t{\n\t\t\tHARKLE_ERROR(Harklemath, dble_greater_than, calc_precision failed);\n\t\t\tsuccess = false;\n\t\t}\n\t\t// fprintf(stdout, \"\\nx == %.15f\\ty == %.15f\\tdbleMask == %.15f\\n\", x, y, dbleMask);  // DEBUGGING\n\t\t// fprintf(stdout, \"\\nxTrunc == %.15f\\tyTrunc == %.15f\\tprecision == %d\\n\\t\\t\", xVal, yVal, precision);  // DEBUGGING\n\t}\n\t\n\t// COMPARE DOUBLES\n\tif (true == success)\n\t{\n\t\t// fprintf(stdout, \"\\nx == %.15f\\ty == %.15f\\tdbleMask == %.15f\\n\", x, y, dbleMask);  // DEBUGGING\n\t\t// fprintf(stdout, \"x < y == %.15f < %.15f == %s\\n\", x, y, (x < y) ? \"true\" : \"false\");  // DEBUGGING\n\t\t// fprintf(stdout, \"(x + dbleMask) < (y + dbleMask) == %.15f < %.15f == %s\\n\", \\\n\t\t// \tx + dbleMask, y + dbleMask, ((x + dbleMask) < (y + dbleMask)) ? \"true\" : \"false\");  // DEBUGGING\n\t\t// fprintf(stdout, \"(x - dbleMask) < (y - dbleMask) == %.15f < %.15f == %s\\n\\t\\t\", \\\n\t\t// \tx - dbleMask, y - dbleMask, ((x - dbleMask) < (y - dbleMask)) ? \"true\" : \"false\");  // DEBUGGING\n\t\tif (xVal < yVal)\n\t\t// if (x < y && (x + dbleMask) < (y + dbleMask) && (x - dbleMask) < (y - dbleMask))\n\t\t{\n\t\t\tretVal = true;\t\n\t\t}\t\t\n\t}\t\n\t\n\t// DONE\n\treturn retVal;\n"]], "pred": {"ppl": 1.8619085550308228, "ppl_lower": 2.0259292125701904, "ppl/lowercase_ppl": -1.1358206540337812, "ppl/zlib": 0.0010535628245672078, "Min_5.0% Prob": 6.370058222820885, "Min_10.0% Prob": 4.560762485391216, "Min_20.0% Prob": 2.8390388792636347, "Min_30.0% Prob": 2.0264248907175646, "Min_40.0% Prob": 1.5427462835400518, "Min_50.0% Prob": 1.2419946200497136, "Min_60.0% Prob": 1.035109760242764}}
{"hexsha": "505beecabe729c9b19ad0cb1d30f2f1538377e1c", "ext": "c", "lang": "C", "content": "static void _ceu_pre_1 (tceu_app* _ceu_app, tceu_org* __ceu_this) {\n/* NODE: BlockI 800 */\n\n#line 160 \"./arch/sdl.ceu\"\n    ceu_vector_init(&((CEU_SDL*)__ceu_this)->title,0,sizeof(char),\n                (byte*)((CEU_SDL*)__ceu_this)->title_mem);\n/* NODE: Stmts 818 */\n\n#line 160 \"./arch/sdl.ceu\"\n    {/* NODE: Dcl_mode 31 */\n/* NODE: Dcl_var 802 */\n/* NODE: Dcl_var 805 */\n/* NODE: Dcl_var 807 */\n/* NODE: Dcl_var 810 */\n/* NODE: Dcl_mode 38 */\n/* NODE: Dcl_var 813 */\n/* NODE: Dcl_var 816 */\n/* NODE: Dcl_fun 53 */\n\n#line 160 \"./arch/sdl.ceu\"\n    }}", "item_id": 34, "repo": "LucasMW/beam_duel", "file": "build/_ceu_app.c", "last_update_at": "2018-01-21T01:25:48+00:00", "question_id": "505beecabe729c9b19ad0cb1d30f2f1538377e1c_34", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void _ceu_pre_1 (tceu_app* _ceu_app, tceu_org* __ceu_this) {\n/* NODE: BlockI 800 */\n#line 160 \"./arch/sdl.ceu\"\n    ceu_vector_init(&((CEU_SDL*)__ceu_this)->title,0,sizeof(char),\n                (byte*)((CEU_SDL*)__ceu_this)->title_mem);\n/* NODE: Stmts 818 */\n#line 160 \"./arch/sdl.ceu\"\n    {/* NODE: Dcl_mode 31 */\n/* NODE: Dcl_var 802 */\n/* NODE: Dcl_var 805 */\n/* NODE: Dcl_var 807 */\n/* NODE: Dcl_var 810 */\n/* NODE: Dcl_mode 38 */\n/* NODE: Dcl_var 813 */\n/* NODE: Dcl_var 816 */\n/* NODE: Dcl_fun 53 */\n#line 160 \"./arch/sdl.ceu\"\n"]], "pred": {"ppl": 3.3998825550079346, "ppl_lower": 3.685438632965088, "ppl/lowercase_ppl": -1.0659033811444512, "ppl/zlib": 0.005015331509757293, "Min_5.0% Prob": 8.154089348656791, "Min_10.0% Prob": 6.6346489531653265, "Min_20.0% Prob": 4.7823818155697415, "Min_30.0% Prob": 3.701748324292047, "Min_40.0% Prob": 2.9494147963289703, "Min_50.0% Prob": 2.4259621784090997, "Min_60.0% Prob": 2.0413930343597064}}
{"hexsha": "3a343eb658ba44692072715f6c9e97703a458355", "ext": "c", "lang": "C", "content": "void\nNC_hashmap_verify(NC_hashmap* hash, NC_dim** dims)\n{\n    unsigned long i;\n    if(hash->count == 0) {\n\tfprintf(stderr,\"<empty>\\n\");\n\tgoto done;\n    }\n    for(i=0;i<hash->size;i++) {\n\thEntry* e = &hash->table[i];\n\tif(e->flags == ACTIVE) {\n           fprintf(stderr,\"[%d] key=%lu data=%ld\",(int)i,e->key,e->data-1);\n\t    if(dims != NULL) {\n\t        fprintf(stderr,\" name=%s\",dims[e->data-1]->name->cp);\n\t    }\t\n\t    fprintf(stderr,\"\\n\");\n\t}\n    }\n\ndone:\n    fflush(stderr);\n}", "item_id": 11, "repo": "khou2020/netcdf-c", "file": "libsrc/nc_hashmap.c", "last_update_at": "2018-02-28T20:59:58+00:00", "question_id": "3a343eb658ba44692072715f6c9e97703a458355_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nNC_hashmap_verify(NC_hashmap* hash, NC_dim** dims)\n{\n    unsigned long i;\n    if(hash->count == 0) {\n\tfprintf(stderr,\"<empty>\\n\");\n\tgoto done;\n    }\n    for(i=0;i<hash->size;i++) {\n\thEntry* e = &hash->table[i];\n\tif(e->flags == ACTIVE) {\n           fprintf(stderr,\"[%d] key=%lu data=%ld\",(int)i,e->key,e->data-1);\n\t    if(dims != NULL) {\n\t        fprintf(stderr,\" name=%s\",dims[e->data-1]->name->cp);\n\t    }\t\n\t    fprintf(stderr,\"\\n\");\n\t}\n    }\ndone:\n    fflush(stderr);\n"]], "pred": {"ppl": 3.491912364959717, "ppl_lower": 3.661512613296509, "ppl/lowercase_ppl": -1.0379278020084082, "ppl/zlib": 0.004267745876168426, "Min_5.0% Prob": 8.787525272369384, "Min_10.0% Prob": 7.187391530899775, "Min_20.0% Prob": 4.953523347544116, "Min_30.0% Prob": 3.8376435711979866, "Min_40.0% Prob": 3.013409756297289, "Min_50.0% Prob": 2.459274621611392, "Min_60.0% Prob": 2.077877536820349}}
{"hexsha": "92f861d3700ce961f7d437bd91b58ed41318148d", "ext": "c", "lang": "C", "content": "void crc16_final(crc16_ctx *inCtx, unsigned short *outResult )\n{\n    inCtx->crc = update_crc16(inCtx->crc, 0);\n    inCtx->crc = update_crc16(inCtx->crc, 0);\n    *outResult = inCtx->crc & 0xffffu;\n}", "item_id": 8, "repo": "HelloAllen8893/AliOS-Things", "file": "platform/mcu/bk7231u/hal/ota.c", "last_update_at": "2018-11-28T03:19:22+00:00", "question_id": "92f861d3700ce961f7d437bd91b58ed41318148d_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void crc16_final(crc16_ctx *inCtx, unsigned short *outResult )\n{\n    inCtx->crc = update_crc16(inCtx->crc, 0);\n    inCtx->crc = update_crc16(inCtx->crc, 0);\n    *outResult = inCtx->crc & 0xffffu;\n"]], "pred": {"ppl": 2.6998050212860107, "ppl_lower": 3.055480718612671, "ppl/lowercase_ppl": -1.1246072556831659, "ppl/zlib": 0.008636343965775548, "Min_5.0% Prob": 8.399680995941162, "Min_10.0% Prob": 6.305656766891479, "Min_20.0% Prob": 4.164214116334915, "Min_30.0% Prob": 3.0873641431331635, "Min_40.0% Prob": 2.4185363449156285, "Min_50.0% Prob": 1.9667553322017193, "Min_60.0% Prob": 1.6508302296201387}}
{"hexsha": "748e427bc2b13e6a6444ebe2c9f1c3ea93aab6b4", "ext": "c", "lang": "C", "content": "int mip_lpwg_enable_sensing(struct i2c_client *client, bool enable)\n{\n\tu8 wbuf[4];\n\n\twbuf[0] = MIP_R0_LPWG;\n\twbuf[1] = MIP_R1_LPWG_ENABLE_SENSING;\n\twbuf[2] = enable;\n\n\tif (FT8707_I2C_Write(client, wbuf, 3)) {\n\t\tTOUCH_ERR(\"mip_lpwg_enable_sensing failed\\n\");\n\t\treturn TOUCH_FAIL;\n\t}\n\n\treturn 0;\n}", "item_id": 8, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/drivers/input/touchscreen/mediatek/unified_driver_4/FT8707/lgtp_device_ft8707.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "748e427bc2b13e6a6444ebe2c9f1c3ea93aab6b4_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int mip_lpwg_enable_sensing(struct i2c_client *client, bool enable)\n{\n\tu8 wbuf[4];\n\twbuf[0] = MIP_R0_LPWG;\n\twbuf[1] = MIP_R1_LPWG_ENABLE_SENSING;\n\twbuf[2] = enable;\n\tif (FT8707_I2C_Write(client, wbuf, 3)) {\n\t\tTOUCH_ERR(\"mip_lpwg_enable_sensing failed\\n\");\n\t\treturn TOUCH_FAIL;\n\t}\n\treturn 0;\n"]], "pred": {"ppl": 2.456857681274414, "ppl_lower": 3.1134564876556396, "ppl/lowercase_ppl": -1.2634940336866056, "ppl/zlib": 0.004240014943783764, "Min_5.0% Prob": 7.421998202800751, "Min_10.0% Prob": 5.839366212487221, "Min_20.0% Prob": 3.9413127675652504, "Min_30.0% Prob": 2.856251834606638, "Min_40.0% Prob": 2.2282790759435067, "Min_50.0% Prob": 1.7874713631846555, "Min_60.0% Prob": 1.5010572106254345}}
{"hexsha": "c1ba92b1192de5d2ab3937aca1a51e42136a1a6b", "ext": "h", "lang": "C", "content": "auto sieve(unsigned int limit) {\n    std::vector<unsigned int> candidates(limit, 1u, std::vector<unsigned int>::allocator_type());\n    std::vector<unsigned int> out; \n    out.push_back(2);\n    for(auto i = 3u; i < limit; i += 2){\n       if(candidates[i] == 0) { continue; }\n        out.push_back(i);\n        for(auto j = 2*i; j < limit; j += i) {\n            candidates[j] = 0u;\n        }\n    }\n\n    return out;\n}", "item_id": 0, "repo": "pviafore/modern-cpp-challenge", "file": "prime.h", "last_update_at": "2018-07-06T18:10:32+00:00", "question_id": "c1ba92b1192de5d2ab3937aca1a51e42136a1a6b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["auto sieve(unsigned int limit) {\n    std::vector<unsigned int> candidates(limit, 1u, std::vector<unsigned int>::allocator_type());\n    std::vector<unsigned int> out; \n    out.push_back(2);\n    for(auto i = 3u; i < limit; i += 2){\n       if(candidates[i] == 0) { continue; }\n        out.push_back(i);\n        for(auto j = 2*i; j < limit; j += i) {\n            candidates[j] = 0u;\n        }\n    }\n    return out;\n"]], "pred": {"ppl": 2.5504050254821777, "ppl_lower": 2.5504050254821777, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0043546613026979025, "Min_5.0% Prob": 7.021484783717564, "Min_10.0% Prob": 5.560501225789388, "Min_20.0% Prob": 3.8494510809580484, "Min_30.0% Prob": 2.8528757704340895, "Min_40.0% Prob": 2.269809483504686, "Min_50.0% Prob": 1.8372492438012904, "Min_60.0% Prob": 1.5530390206562437}}
{"hexsha": "f1efb943b6fec3cfeb67856b03ec15dc11fbd4d2", "ext": "h", "lang": "C", "content": "class CSampleDlg : public CDialog\n{\n//\npublic:\n\tCSampleDlg(CWnd* pParent = NULL);\t// default constractor\n\n\t//{{AFX_DATA(CSampleDlg)\n\tenum { IDD = IDD_SAMPLE_DIALOG };\n\n\t//}}AFX_DATA\n\n\t//{{AFX_VIRTUAL(CSampleDlg)\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);\t// support DDX/DDV\n\t//}}AFX_VIRTUAL\n\nprotected:\n\tHICON m_hIcon;\n\n\t//{{AFX_MSG(CSampleDlg)\n\tvirtual BOOL OnInitDialog();\n\tafx_msg void OnPaint();\n\tafx_msg HCURSOR OnQueryDragIcon();\n\tafx_msg void OnPrint();\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\n}", "item_id": 0, "repo": "huanlin/easy-braille-edit", "file": "Doc/Braille Printers/Gemini/Samples/Sample2/SampleDlg.h", "last_update_at": "2018-05-09T07:44:31+00:00", "question_id": "f1efb943b6fec3cfeb67856b03ec15dc11fbd4d2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class CSampleDlg : public CDialog\n{\n//\npublic:\n\tCSampleDlg(CWnd* pParent = NULL);\t// default constractor\n\t//{{AFX_DATA(CSampleDlg)\n\tenum { IDD = IDD_SAMPLE_DIALOG };\n\t//}}AFX_DATA\n\t//{{AFX_VIRTUAL(CSampleDlg)\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);\t// support DDX/DDV\n\t//}}AFX_VIRTUAL\nprotected:\n\tHICON m_hIcon;\n\t//{{AFX_MSG(CSampleDlg)\n\tvirtual BOOL OnInitDialog();\n\tafx_msg void OnPaint();\n\tafx_msg HCURSOR OnQueryDragIcon();\n\tafx_msg void OnPrint();\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\n"]], "pred": {"ppl": 1.6245592832565308, "ppl_lower": 3.1764285564422607, "ppl/lowercase_ppl": -2.3818433002697783, "ppl/zlib": 0.0015602462015879808, "Min_5.0% Prob": 7.23798714984547, "Min_10.0% Prob": 4.421340973480888, "Min_20.0% Prob": 2.380776358728713, "Min_30.0% Prob": 1.6126942019647277, "Min_40.0% Prob": 1.2120824255441365, "Min_50.0% Prob": 0.9694883216469854, "Min_60.0% Prob": 0.813040029223923}}
{"hexsha": "53d650966beca97aaf0ebe62b116b10a5ea32871", "ext": "c", "lang": "C", "content": "void\nFtsGetQDMirrorInfo(char **hostname, uint16 *port)\n{\n\tAssert(hostname != NULL);\n\tAssert(port != NULL);\n\n\tif (ftsQDMirrorInfo->name[0] == 0 || ftsQDMirrorInfo->port == 0)\n\t{\n\t\t*hostname = NULL;\n\t\t*port = 0;\n\t\treturn;\n\t}\n\n\t*hostname = ftsQDMirrorInfo->name;\n\t*port = ftsQDMirrorInfo->port;\n\treturn;\n}", "item_id": 27, "repo": "YangHao666666/hawq", "file": "src/backend/cdb/cdbfts.c", "last_update_at": "2018-08-30T01:45:36+00:00", "question_id": "53d650966beca97aaf0ebe62b116b10a5ea32871_27", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nFtsGetQDMirrorInfo(char **hostname, uint16 *port)\n{\n\tAssert(hostname != NULL);\n\tAssert(port != NULL);\n\tif (ftsQDMirrorInfo->name[0] == 0 || ftsQDMirrorInfo->port == 0)\n\t{\n\t\t*hostname = NULL;\n\t\t*port = 0;\n\t\treturn;\n\t}\n\t*hostname = ftsQDMirrorInfo->name;\n\t*port = ftsQDMirrorInfo->port;\n\treturn;\n"]], "pred": {"ppl": 2.753321886062622, "ppl_lower": 2.917109251022339, "ppl/lowercase_ppl": -1.057054243337794, "ppl/zlib": 0.005957694948539762, "Min_5.0% Prob": 8.917644421259562, "Min_10.0% Prob": 7.013999095329871, "Min_20.0% Prob": 4.6275992746706365, "Min_30.0% Prob": 3.3129328089516337, "Min_40.0% Prob": 2.5271070889451286, "Min_50.0% Prob": 2.022566893691386, "Min_60.0% Prob": 1.703419830934031}}
{"hexsha": "b85ba71a6f77e974d82ccdd635109f36d0ddaac8", "ext": "h", "lang": "C", "content": "static virNetworkPtr\nremoteNetworkCreateXML(virConnectPtr conn, const char *xml)\n{\n    virNetworkPtr rv = NULL;\n    struct private_data *priv = conn->privateData;\n    remote_network_create_xml_args args;\n    remote_network_create_xml_ret ret;\n\n    remoteDriverLock(priv);\n\n    args.xml = (char *)xml;\n\n    memset(&ret, 0, sizeof(ret));\n\n    if (call(conn, priv, 0, REMOTE_PROC_NETWORK_CREATE_XML,\n             (xdrproc_t)xdr_remote_network_create_xml_args, (char *)&args,\n             (xdrproc_t)xdr_remote_network_create_xml_ret, (char *)&ret) == -1) {\n        goto done;\n    }\n\n    rv = get_nonnull_network(conn, ret.net);\n    xdr_free((xdrproc_t)xdr_remote_network_create_xml_ret, (char *)&ret);\n\ndone:\n    remoteDriverUnlock(priv);\n    return rv;\n}", "item_id": 154, "repo": "SIIS-cloud/pileus", "file": "libvirt/pileus-libvirt-1.2.12/src/remote/remote_client_bodies.h", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "b85ba71a6f77e974d82ccdd635109f36d0ddaac8_154", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static virNetworkPtr\nremoteNetworkCreateXML(virConnectPtr conn, const char *xml)\n{\n    virNetworkPtr rv = NULL;\n    struct private_data *priv = conn->privateData;\n    remote_network_create_xml_args args;\n    remote_network_create_xml_ret ret;\n    remoteDriverLock(priv);\n    args.xml = (char *)xml;\n    memset(&ret, 0, sizeof(ret));\n    if (call(conn, priv, 0, REMOTE_PROC_NETWORK_CREATE_XML,\n             (xdrproc_t)xdr_remote_network_create_xml_args, (char *)&args,\n             (xdrproc_t)xdr_remote_network_create_xml_ret, (char *)&ret) == -1) {\n        goto done;\n    }\n    rv = get_nonnull_network(conn, ret.net);\n    xdr_free((xdrproc_t)xdr_remote_network_create_xml_ret, (char *)&ret);\ndone:\n    remoteDriverUnlock(priv);\n    return rv;\n"]], "pred": {"ppl": 1.7645918130874634, "ppl_lower": 2.4034409523010254, "ppl/lowercase_ppl": -1.5440596789521217, "ppl/zlib": 0.0016461431775834652, "Min_5.0% Prob": 5.693569830485752, "Min_10.0% Prob": 4.004646356616702, "Min_20.0% Prob": 2.628326704459531, "Min_30.0% Prob": 1.8666264530093897, "Min_40.0% Prob": 1.4197810859685498, "Min_50.0% Prob": 1.1389040305877902, "Min_60.0% Prob": 0.9496746649175682}}
{"hexsha": "139f976a5c28f8dd2830fd45366ce3fb9c794544", "ext": "h", "lang": "C", "content": "interface ICShaderCache : NSObject {\n@private\n    NSMutableDictionary *_programs;\n    ICShaderFactory *_shaderFactory;\n}", "item_id": 0, "repo": "starbugs/icedcoffee", "file": "icedcoffee/ICShaderCache.h", "last_update_at": "2018-11-09T11:13:12+00:00", "question_id": "139f976a5c28f8dd2830fd45366ce3fb9c794544_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface ICShaderCache : NSObject {\n@private\n    NSMutableDictionary *_programs;\n    ICShaderFactory *_shaderFactory;\n"]], "pred": {"ppl": 7.989528179168701, "ppl_lower": 13.751574516296387, "ppl/lowercase_ppl": -1.261302793989237, "ppl/zlib": 0.019982035640542257, "Min_5.0% Prob": 10.278444290161133, "Min_10.0% Prob": 8.131226857503256, "Min_20.0% Prob": 6.871375969478062, "Min_30.0% Prob": 6.121886563301087, "Min_40.0% Prob": 4.879719751221793, "Min_50.0% Prob": 3.9855754607253604, "Min_60.0% Prob": 3.505844099181039}}
{"hexsha": "0ea925238d379dc010b281b4b60e34536a1eb9c5", "ext": "h", "lang": "C", "content": "interface _HDDataFaker : NSObject <_HDDemoDataModuleDelegate> {\n    long long  _activityType;\n    NSArray * _modules;\n    id /* block */  _objectHandler;\n    NSOperationQueue * _operationQueue;\n    HKQuantity * _speed;\n}", "item_id": 0, "repo": "shaojiankui/iOS10-Runtime-Headers", "file": "PrivateFrameworks/HealthDaemon.framework/_HDDataFaker.h", "last_update_at": "2018-10-08T04:12:25+00:00", "question_id": "0ea925238d379dc010b281b4b60e34536a1eb9c5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface _HDDataFaker : NSObject <_HDDemoDataModuleDelegate> {\n    long long  _activityType;\n    NSArray * _modules;\n    id /* block */  _objectHandler;\n    NSOperationQueue * _operationQueue;\n    HKQuantity * _speed;\n"]], "pred": {"ppl": 8.142545700073242, "ppl_lower": 16.303604125976562, "ppl/lowercase_ppl": -1.3310678433613998, "ppl/zlib": 0.012709714367808251, "Min_5.0% Prob": 9.76822821299235, "Min_10.0% Prob": 8.63008181254069, "Min_20.0% Prob": 6.834559954129732, "Min_30.0% Prob": 5.6101035356521605, "Min_40.0% Prob": 4.759193808944137, "Min_50.0% Prob": 4.079677171566907, "Min_60.0% Prob": 3.488961620301735}}
{"hexsha": "56b89f9ca944a79b3e7fa9bc393c471b09a0134f", "ext": "c", "lang": "C", "content": "static int __Pyx_modinit_function_export_code(void) {\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__Pyx_modinit_function_export_code\", 0);\n  /*--- Function export code ---*/\n  __Pyx_RefNannyFinishContext();\n  return 0;\n}", "item_id": 74, "repo": "jm-begon/globally-induced-forest", "file": "gif/tree/_criterion.c", "last_update_at": "2018-10-13T13:14:05+00:00", "question_id": "56b89f9ca944a79b3e7fa9bc393c471b09a0134f_74", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int __Pyx_modinit_function_export_code(void) {\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__Pyx_modinit_function_export_code\", 0);\n  /*--- Function export code ---*/\n  __Pyx_RefNannyFinishContext();\n  return 0;\n"]], "pred": {"ppl": 3.2449612617492676, "ppl_lower": 5.605441093444824, "ppl/lowercase_ppl": -1.4643893917054382, "ppl/zlib": 0.008174329251785725, "Min_5.0% Prob": 8.134712934494019, "Min_10.0% Prob": 6.984430313110352, "Min_20.0% Prob": 5.059756615582635, "Min_30.0% Prob": 3.7631995448699365, "Min_40.0% Prob": 2.93196838583265, "Min_50.0% Prob": 2.3503088054501196, "Min_60.0% Prob": 1.9911600709713708}}
{"hexsha": "67c2cee6d2d9eedb91b9cb60846563cef25bc8f4", "ext": "c", "lang": "C", "content": "void LayerTraverseForArray(BiTree T) {\n    if (T == NULL) return;\n    BiTree trees[100];\n    int in = 0;\n    int out = 0;\n    trees[in++] = T; // \u5148\u4fdd\u5b58\u4e8c\u53c9\u6811\u6839\u8282\u70b9\n    while (in > out) {\n        if (trees[out] != NULL) {\n            printf(\"%d ->\", trees[out] -> data);\n            if (trees[out] -> lChildNode) {\n                trees[in++] = trees[out] -> lChildNode;\n            }\n            if (trees[out] -> rChildNode) {\n                trees[in++] = trees[out] -> rChildNode;\n            }\n        }\n        out++;\n    }\n}", "item_id": 4, "repo": "yongyuandouneng/YNAlgorithm", "file": "YNAlgorithm/DataStructure/Tree.c", "last_update_at": "2018-12-24T16:34:25+00:00", "question_id": "67c2cee6d2d9eedb91b9cb60846563cef25bc8f4_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void LayerTraverseForArray(BiTree T) {\n    if (T == NULL) return;\n    BiTree trees[100];\n    int in = 0;\n    int out = 0;\n    trees[in++] = T; // \u5148\u4fdd\u5b58\u4e8c\u53c9\u6811\u6839\u8282\u70b9\n    while (in > out) {\n        if (trees[out] != NULL) {\n            printf(\"%d ->\", trees[out] -> data);\n            if (trees[out] -> lChildNode) {\n                trees[in++] = trees[out] -> lChildNode;\n            }\n            if (trees[out] -> rChildNode) {\n                trees[in++] = trees[out] -> rChildNode;\n            }\n        }\n        out++;\n    }\n"]], "pred": {"ppl": 2.4516749382019043, "ppl_lower": 2.7130160331726074, "ppl/lowercase_ppl": -1.1129490746088797, "ppl/zlib": 0.0036014917237803252, "Min_5.0% Prob": 8.223017480638292, "Min_10.0% Prob": 6.368936445977953, "Min_20.0% Prob": 4.052690003369306, "Min_30.0% Prob": 2.8981916350977763, "Min_40.0% Prob": 2.223518915375074, "Min_50.0% Prob": 1.7919549831843122, "Min_60.0% Prob": 1.4967917613520296}}
{"hexsha": "312b1f8c47cb4836dd8f195a9d9e1aa98bf0acef", "ext": "c", "lang": "C", "content": "void\nnls_decrypt(nls_ctx *c, UCHAR *buf, int nbytes)\n{\n    WORD\tt = 0, t3 = 0;\n    int\t\ti;\n\n    /* handle any previously buffered bytes */\n    if (c->nbuf != 0) {\n\twhile (c->nbuf != 0 && nbytes != 0) {\n\t    *buf ^= (c->sbuf >> (32 - c->nbuf)) & 0xFF;\n\t    c->mbuf ^= *buf << (32 - c->nbuf);\n\t    ++buf;\n\t    c->nbuf -= 8;\n\t    --nbytes;\n\t}\n\tif (c->nbuf != 0) /* not a whole word yet */\n\t    return;\n\t/* LFSR already cycled */\n\tmacfunc(c, c->mbuf);\n    }\n\n    /* now do lots at a time, if there's enough */\n    while (4*N <= nbytes)\n    {\n#if NLS_LONG_OUTPUT\n\tif (c->CtrModF16 < (F16-18)) {\n#endif /*NLS_LONG_OUTPUT*/\n\t    DROUND( 0,A,B,C,D,E,F,G,H);\n\t    DROUND( 1,H,A,B,C,D,E,F,G);\n\t    DROUND( 2,G,H,A,B,C,D,E,F);\n\t    DROUND( 3,F,G,H,A,B,C,D,E);\n\t    DROUND( 4,E,F,G,H,A,B,C,D);\n\t    DROUND( 5,D,E,F,G,H,A,B,C);\n\t    DROUND( 6,C,D,E,F,G,H,A,B);\n\t    DROUND( 7,B,C,D,E,F,G,H,A);\n\t    DROUND( 8,A,B,C,D,E,F,G,H);\n\t    DROUND( 9,H,A,B,C,D,E,F,G);\n\t    DROUND(10,G,H,A,B,C,D,E,F);\n\t    DROUND(11,F,G,H,A,B,C,D,E);\n\t    DROUND(12,E,F,G,H,A,B,C,D);\n\t    DROUND(13,D,E,F,G,H,A,B,C);\n\t    DROUND(14,C,D,E,F,G,H,A,B);\n\t    DROUND(15,B,C,D,E,F,G,H,A);\n\t    DROUND(16,A,B,C,D,E,F,G,H);\n\t    buf += 4*N;\n\t    nbytes -= 4*N;\n\t    /* fix alignment of MAC buffer */\n\t    t = c->M[7];\n\t    for (i = NMAC-1; i > 0; --i)\n\t\tc->M[i] = c->M[i-1];\n\t    c->M[0] = t;\n\t    /* fix alignment of CRC buffer */\n\t    t = c->CRC[0];\n\t    for (i = 1; i < NMAC; ++i)\n\t\tc->CRC[i-1] = c->CRC[i];\n\t    c->CRC[NMAC-1] = t;\n#if NLS_LONG_OUTPUT\n\t    c->CtrModF16 += 17;\n\t}\n\telse {\n\t    do {\n\t\tcycle(c);\n\t\tt = nltap(c);\n\t\tt3 = BYTE2WORD(buf);\n\t\tt ^= t3;\n\t\tmacfunc(c, t);\n\t\tWORD2BYTE(t, buf);\n\t\tbuf += 4;\n\t\tnbytes -= 4;\n\t    } while (F16-18 < c->CtrModF16);\n\t}\n#endif /*NLS_LONG_OUTPUT*/\n    }\n\n    /* do small or odd size buffers the slow way */\n    while (4 <= nbytes) {\n\tcycle(c);\n\tt = nltap(c);\n\tt3 = BYTE2WORD(buf);\n\tt ^= t3;\n\tmacfunc(c, t);\n\tWORD2BYTE(t, buf);\n\tnbytes -= 4;\n\tbuf += 4;\n    }\n\n    /* handle any trailing bytes */\n    if (nbytes != 0) {\n\tcycle(c);\n\tc->sbuf = nltap(c);\n\tc->mbuf = 0;\n\tc->nbuf = 32;\n\twhile (c->nbuf != 0 && nbytes != 0) {\n\t    *buf ^= (c->sbuf >> (32 - c->nbuf)) & 0xFF;\n\t    c->mbuf ^= *buf << (32 - c->nbuf);\n\t    ++buf;\n\t    c->nbuf -= 8;\n\t    --nbytes;\n\t}\n    }\n}", "item_id": 12, "repo": "iadgov/simon-speck-supercop", "file": "crypto_stream/nlsv2/e/v2/sync/2/e/nlsfast.c", "last_update_at": "2018-03-09T14:52:25+00:00", "question_id": "312b1f8c47cb4836dd8f195a9d9e1aa98bf0acef_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nnls_decrypt(nls_ctx *c, UCHAR *buf, int nbytes)\n{\n    WORD\tt = 0, t3 = 0;\n    int\t\ti;\n    /* handle any previously buffered bytes */\n    if (c->nbuf != 0) {\n\twhile (c->nbuf != 0 && nbytes != 0) {\n\t    *buf ^= (c->sbuf >> (32 - c->nbuf)) & 0xFF;\n\t    c->mbuf ^= *buf << (32 - c->nbuf);\n\t    ++buf;\n\t    c->nbuf -= 8;\n\t    --nbytes;\n\t}\n\tif (c->nbuf != 0) /* not a whole word yet */\n\t    return;\n\t/* LFSR already cycled */\n\tmacfunc(c, c->mbuf);\n    }\n    /* now do lots at a time, if there's enough */\n    while (4*N <= nbytes)\n    {\n#if NLS_LONG_OUTPUT\n\tif (c->CtrModF16 < (F16-18)) {\n#endif /*NLS_LONG_OUTPUT*/\n\t    DROUND( 0,A,B,C,D,E,F,G,H);\n\t    DROUND( 1,H,A,B,C,D,E,F,G);\n\t    DROUND( 2,G,H,A,B,C,D,E,F);\n\t    DROUND( 3,F,G,H,A,B,C,D,E);\n\t    DROUND( 4,E,F,G,H,A,B,C,D);\n\t    DROUND( 5,D,E,F,G,H,A,B,C);\n\t    DROUND( 6,C,D,E,F,G,H,A,B);\n\t    DROUND( 7,B,C,D,E,F,G,H,A);\n\t    DROUND( 8,A,B,C,D,E,F,G,H);\n\t    DROUND( 9,H,A,B,C,D,E,F,G);\n\t    DROUND(10,G,H,A,B,C,D,E,F);\n\t    DROUND(11,F,G,H,A,B,C,D,E);\n\t    DROUND(12,E,F,G,H,A,B,C,D);\n\t    DROUND(13,D,E,F,G,H,A,B,C);\n\t    DROUND(14,C,D,E,F,G,H,A,B);\n\t    DROUND(15,B,C,D,E,F,G,H,A);\n\t    DROUND(16,A,B,C,D,E,F,G,H);\n\t    buf += 4*N;\n\t    nbytes -= 4*N;\n\t    /* fix alignment of MAC buffer */\n\t    t = c->M[7];\n\t    for (i = NMAC-1; i > 0; --i)\n\t\tc->M[i] = c->M[i-1];\n\t    c->M[0] = t;\n\t    /* fix alignment of CRC buffer */\n\t    t = c->CRC[0];\n\t    for (i = 1; i < NMAC; ++i)\n\t\tc->CRC[i-1] = c->CRC[i];\n\t    c->CRC[NMAC-1] = t;\n#if NLS_LONG_OUTPUT\n\t    c->CtrModF16 += 17;\n\t}\n\telse {\n\t    do {\n\t\tcycle(c);\n\t\tt = nltap(c);\n\t\tt3 = BYTE2WORD(buf);\n\t\tt ^= t3;\n\t\tmacfunc(c, t);\n\t\tWORD2BYTE(t, buf);\n\t\tbuf += 4;\n\t\tnbytes -= 4;\n\t    } while (F16-18 < c->CtrModF16);\n\t}\n#endif /*NLS_LONG_OUTPUT*/\n    }\n    /* do small or odd size buffers the slow way */\n    while (4 <= nbytes) {\n\tcycle(c);\n\tt = nltap(c);\n\tt3 = BYTE2WORD(buf);\n\tt ^= t3;\n\tmacfunc(c, t);\n\tWORD2BYTE(t, buf);\n\tnbytes -= 4;\n\tbuf += 4;\n    }\n    /* handle any trailing bytes */\n    if (nbytes != 0) {\n\tcycle(c);\n\tc->sbuf = nltap(c);\n\tc->mbuf = 0;\n\tc->nbuf = 32;\n\twhile (c->nbuf != 0 && nbytes != 0) {\n\t    *buf ^= (c->sbuf >> (32 - c->nbuf)) & 0xFF;\n\t    c->mbuf ^= *buf << (32 - c->nbuf);\n\t    ++buf;\n\t    c->nbuf -= 8;\n\t    --nbytes;\n\t}\n    }\n"]], "pred": {"ppl": 1.8626683950424194, "ppl_lower": 1.9093824625015259, "ppl/lowercase_ppl": -1.0398221698637766, "ppl/zlib": 0.0007883524469329818, "Min_5.0% Prob": 6.779300362456079, "Min_10.0% Prob": 4.879029858346079, "Min_20.0% Prob": 2.970388857903434, "Min_30.0% Prob": 2.060100830385303, "Min_40.0% Prob": 1.5531973541967006, "Min_50.0% Prob": 1.2449105130472091, "Min_60.0% Prob": 1.037993387982411}}
{"hexsha": "99adea3b455e4d978d45150b9835dd540e41a000", "ext": "c", "lang": "C", "content": "static int set_outfile(char *outfile, char addfile) {\n    int flags = O_WRONLY;\n    if (addfile == TRUE) {\n        flags |= O_APPEND | O_CREAT;\n    } else {\n        flags |= O_CREAT | O_TRUNC;\n    }\n\n    int output;\n    output = open(outfile, flags, (mode_t) 0644);\n    CHECK_ON_ERROR(output, BAD_RESULT, \"Couldn't open output file\")\n\n    return use_dup2(output, STDOUT_FILENO, \"Couldn't redirect output\");\n}", "item_id": 14, "repo": "Dimonchik0036/shell", "file": "execute.c", "last_update_at": "2018-02-27T09:58:42+00:00", "question_id": "99adea3b455e4d978d45150b9835dd540e41a000_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int set_outfile(char *outfile, char addfile) {\n    int flags = O_WRONLY;\n    if (addfile == TRUE) {\n        flags |= O_APPEND | O_CREAT;\n    } else {\n        flags |= O_CREAT | O_TRUNC;\n    }\n    int output;\n    output = open(outfile, flags, (mode_t) 0644);\n    CHECK_ON_ERROR(output, BAD_RESULT, \"Couldn't open output file\")\n    return use_dup2(output, STDOUT_FILENO, \"Couldn't redirect output\");\n"]], "pred": {"ppl": 3.1340103149414062, "ppl_lower": 3.8062636852264404, "ppl/lowercase_ppl": -1.1701237214823053, "ppl/zlib": 0.00458760415755306, "Min_5.0% Prob": 9.015924113137382, "Min_10.0% Prob": 7.219901180267334, "Min_20.0% Prob": 4.637583782595973, "Min_30.0% Prob": 3.485007584095001, "Min_40.0% Prob": 2.7609555636133467, "Min_50.0% Prob": 2.259275510152684, "Min_60.0% Prob": 1.9131347075342497}}
{"hexsha": "c825ffcc91a581d35f2e33ba86676e2933016dca", "ext": "c", "lang": "C", "content": "void* p_OpenScreen(int width, int height, bool_t fullscreen, int samples, bool_t vsync, bool_t resizable) {\n    GLFWwindow* win;\n\n    /* set flags */\n    glfwWindowHint(GLFW_SAMPLES, samples);\n    glfwWindowHint(GLFW_RESIZABLE, resizable);\n#ifdef USE_RETINA\n    glfwWindowHint(GLFW_COCOA_RETINA_FRAMEBUFFER, GLFW_TRUE);\n#else\n    glfwWindowHint(GLFW_COCOA_RETINA_FRAMEBUFFER, GLFW_FALSE);\n#endif\n\n    /* create window */\n    win = glfwCreateWindow(width, height, \"\", fullscreen ? glfwGetPrimaryMonitor() : NULL, NULL);\n    glfwMakeContextCurrent(win);\n\n    /* set vsync */\n    glfwSwapInterval(vsync ? 1 : 0);\n\n    return win;\n}", "item_id": 3, "repo": "JaviCervera/spark", "file": "src/platform_glfw.c", "last_update_at": "2018-05-28T09:14:02+00:00", "question_id": "c825ffcc91a581d35f2e33ba86676e2933016dca_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void* p_OpenScreen(int width, int height, bool_t fullscreen, int samples, bool_t vsync, bool_t resizable) {\n    GLFWwindow* win;\n    /* set flags */\n    glfwWindowHint(GLFW_SAMPLES, samples);\n    glfwWindowHint(GLFW_RESIZABLE, resizable);\n#ifdef USE_RETINA\n    glfwWindowHint(GLFW_COCOA_RETINA_FRAMEBUFFER, GLFW_TRUE);\n#else\n    glfwWindowHint(GLFW_COCOA_RETINA_FRAMEBUFFER, GLFW_FALSE);\n#endif\n    /* create window */\n    win = glfwCreateWindow(width, height, \"\", fullscreen ? glfwGetPrimaryMonitor() : NULL, NULL);\n    glfwMakeContextCurrent(win);\n    /* set vsync */\n    glfwSwapInterval(vsync ? 1 : 0);\n    return win;\n"]], "pred": {"ppl": 1.8835434913635254, "ppl_lower": 2.270124673843384, "ppl/lowercase_ppl": -1.2948408547216188, "ppl/zlib": 0.001895673169459102, "Min_5.0% Prob": 6.4524229764938354, "Min_10.0% Prob": 4.825982868671417, "Min_20.0% Prob": 3.002981185913086, "Min_30.0% Prob": 2.08714180278617, "Min_40.0% Prob": 1.5898420904972115, "Min_50.0% Prob": 1.2702615641254356, "Min_60.0% Prob": 1.0564259926023944}}
{"hexsha": "d6469d4f8aba819a52bef6ad77c5ef428a5d518a", "ext": "h", "lang": "C", "content": "class DepthCalibrator\n{\npublic:\n  DepthCalibrator(ros::NodeHandle& nh);\n\n  /**\n     * @brief If pixel depth calibration has been performed, and points clouds have been stored, performs depth\n   * correction calculations\n     *\n     * Calculates the depth correction coefficients d1 and d2 using the point clouds previously stored.\n     * Depth correction for each pixel is of the form D*e^(d1 + d2 * z), where D is the pixel depth error found from the\n     * calibrateCameraPixelDepth callback, z is the depth of the given pixel, and d1 and d2 are the depth coefficients\n   * to be solved for.\n     *\n     *\n     * @param[in] request Empty\n     * @param[out] response Empty\n     * @return True if the call succeeded\n     */\n  bool calibrateCameraDepth(std_srvs::Empty::Request& request, std_srvs::Empty::Response& response);\n\n  /**\n     * @brief Finds the depth error for each pixel in the point cloud\n     *\n     * Finds the calibration target and compares each pixel depth value to the expected depth value based upon the\n     * pose of the target found.  Stores the resulting depth compensation values as a point cloud for use in the\n     * depth correction nodelet.\n     *\n     * @param[in] request Empty\n     * @param[out] response Empty\n     * @return True if the call succeeded\n     */\n  bool calibrateCameraPixelDepth(std_srvs::Empty::Request& request, std_srvs::Empty::Response& response);\n\n  /**\n     * @brief Sets the flag to store the next point cloud retrieved for later use when performing depth correction\n   * calculations\n     *\n     * @param[in] request Empty\n     * @param[out] response Empty\n     * @return True if the call succeeded\n     */\n  bool setStoreCloud(std_srvs::Empty::Request& request, std_srvs::Empty::Response& response);\n\n  /**\n     * @brief Updates the last_cloud_ data, and if the store_point_cloud_ boolean is set, stores the latest cloud,\n   * image, and target pose\n     *\n     * @param[in] cloud The latest point cloud received\n     * @param[in] image The latest RGB image received\n     * @return True if the call succeeded\n     */\n  void updateInputData(const sensor_msgs::PointCloud2ConstPtr& cloud, const sensor_msgs::ImageConstPtr& image);\n\nprivate:\n  const static unsigned int VERSION_NUMBER_; /**< @brief Version number for the calibration package  */\n\n  ros::NodeHandle nh_; /**< @brief ROS node handle */\n  bool save_data_;     /**< @brief Flag to determine whether to save calibration results or not */\n\n  typedef message_filters::sync_policies::ApproximateTime< sensor_msgs::PointCloud2, sensor_msgs::Image > PolicyType;\n  typedef message_filters::Subscriber< sensor_msgs::PointCloud2 > PointCloudSubscriberType;\n  typedef message_filters::Subscriber< sensor_msgs::Image > ImageSubscriberType;\n  typedef message_filters::Synchronizer< PolicyType > SynchronizerType;\n  boost::shared_ptr< PointCloudSubscriberType > point_cloud_sub_; /**< @brief Point cloud subscriber */\n  boost::shared_ptr< ImageSubscriberType > image_sub_;            /**< @brief RGB image subscriber */\n  boost::shared_ptr< SynchronizerType > synchronizer_; /**< @brief Syncronizer for point cloud and image data */\n\n  ros::ServiceClient get_target_pose_;       /**< @brief Service to call target locator to get target pose */\n  ros::ServiceServer calibrate_depth_;       /**< @brief Service to compute depth coefficients d1 and d2 */\n  ros::ServiceServer calibrate_pixel_depth_; /**< @brief Service to calculate pixel depth error */\n  ros::ServiceServer set_store_cloud_;       /**< @brief Service to set and store next point cloud available */\n\n  int num_views_;        /**< @brief Number of times to find the calibration target to get average pose */\n  int num_attempts_;     /**< @brief Number of attempts allowed for finding calibration target before failing */\n  int num_point_clouds_; /**< @brief Number of point clouds to save and check when performing pixel depth error\n                            calculations */\n  std::string filename_; /**< @brief Name of the calibration files to save */\n  std::string filepath_; /**< @brief Pathway to the location to save calibration files */\n  geometry_msgs::Pose\n      target_initial_pose_; /**< @brief The initial pose guess of the calibration target for the target finder service\n                               */\n\n  double std_dev_error_;          /**< @brief The standard deviation error allowed for finding the target pose */\n  double depth_error_threshold_;  /**< @brief The depth error allowed for calculating the pixel depth error map */\n  boost::mutex data_lock_;        /**< @brief Lock for data subscription */\n  sensor_msgs::Image last_image_; /**< @brief The last color image received */\n  pcl::PointCloud< pcl::PointXYZ > last_cloud_; /**< @brief The last point cloud received */\n  pcl::PointCloud< pcl::PointXYZ >\n      correction_cloud_; /**< @brief The point cloud containing the depth correction values */\n  std::vector< pcl::PointCloud< pcl::PointXYZ >, Eigen::aligned_allocator< pcl::PointCloud< pcl::PointXYZ > > >\n      saved_clouds_;\n  /**< @brief The vector of stored point clouds used to compute the distance coefficients */\n  std::vector< std::vector< double > >\n      plane_equations_;                 /**< @brief A vector of plane equations for each point cloud in saved_clouds_ */\n  std::vector< cv::Mat > saved_images_; /**< @brief A vector of rgb images for each point cloud in saved_clouds_ */\n  std::vector< geometry_msgs::Pose > saved_target_poses_; /**< @brief A vector of target poses for each point cloud in\n                                                             saved_clouds_ */\n\n  /**\n     * @brief Stores the calibration results in a YAML formated file\n     *\n     * @param[in] yaml_file The name and pathway of the file to be saved\n     * @param[in] dp The depth correction coefficients to be saved\n     */\n  void storeCalibration(const std::string& yaml_file, const double dp[2]);\n\n  /**\n     * @brief Populates and calls the target finder service\n     *\n     * @param[in] final_cost The desired final cost for the service call\n     * @param[out] target_pose The pose of the target returned from the service call\n     * @return True if the service call succeeds\n     */\n  bool findTarget(const double& final_cost, geometry_msgs::Pose& target_pose);\n\n  /**\n     * @brief Calls the findTarget function multiple times (num_views) and returns the average plane equation and the\n   * last target pose found\n     *\n     * @param[out] plane_eq The average plane equation results found from averaging the results from all of the target\n   * poses found\n     * @param[out] target_pose The pose of the target found from the last service call\n     * @return True if the target was successfully found before the number of failures (num_attempts) was reached\n     */\n  bool findAveragePlane(std::vector< double >& plane_eq, geometry_msgs::Pose& target_pose);\n\n  bool findAveragePointCloud(pcl::PointCloud< pcl::PointXYZ >& final_cloud);\n}", "item_id": 1, "repo": "smith-doug/industrial_calibration", "file": "rgbd_depth_correction/include/depth_calibration/depth_calibration.h", "last_update_at": "2018-07-26T02:03:58+00:00", "question_id": "d6469d4f8aba819a52bef6ad77c5ef428a5d518a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class DepthCalibrator\n{\npublic:\n  DepthCalibrator(ros::NodeHandle& nh);\n  /**\n     * @brief If pixel depth calibration has been performed, and points clouds have been stored, performs depth\n   * correction calculations\n     *\n     * Calculates the depth correction coefficients d1 and d2 using the point clouds previously stored.\n     * Depth correction for each pixel is of the form D*e^(d1 + d2 * z), where D is the pixel depth error found from the\n     * calibrateCameraPixelDepth callback, z is the depth of the given pixel, and d1 and d2 are the depth coefficients\n   * to be solved for.\n     *\n     *\n     * @param[in] request Empty\n     * @param[out] response Empty\n     * @return True if the call succeeded\n     */\n  bool calibrateCameraDepth(std_srvs::Empty::Request& request, std_srvs::Empty::Response& response);\n  /**\n     * @brief Finds the depth error for each pixel in the point cloud\n     *\n     * Finds the calibration target and compares each pixel depth value to the expected depth value based upon the\n     * pose of the target found.  Stores the resulting depth compensation values as a point cloud for use in the\n     * depth correction nodelet.\n     *\n     * @param[in] request Empty\n     * @param[out] response Empty\n     * @return True if the call succeeded\n     */\n  bool calibrateCameraPixelDepth(std_srvs::Empty::Request& request, std_srvs::Empty::Response& response);\n  /**\n     * @brief Sets the flag to store the next point cloud retrieved for later use when performing depth correction\n   * calculations\n     *\n     * @param[in] request Empty\n     * @param[out] response Empty\n     * @return True if the call succeeded\n     */\n  bool setStoreCloud(std_srvs::Empty::Request& request, std_srvs::Empty::Response& response);\n  /**\n     * @brief Updates the last_cloud_ data, and if the store_point_cloud_ boolean is set, stores the latest cloud,\n   * image, and target pose\n     *\n     * @param[in] cloud The latest point cloud received\n     * @param[in] image The latest RGB image received\n     * @return True if the call succeeded\n     */\n  void updateInputData(const sensor_msgs::PointCloud2ConstPtr& cloud, const sensor_msgs::ImageConstPtr& image);\nprivate:\n  const static unsigned int VERSION_NUMBER_; /**< @brief Version number for the calibration package  */\n  ros::NodeHandle nh_; /**< @brief ROS node handle */\n  bool save_data_;     /**< @brief Flag to determine whether to save calibration results or not */\n  typedef message_filters::sync_policies::ApproximateTime< sensor_msgs::PointCloud2, sensor_msgs::Image > PolicyType;\n  typedef message_filters::Subscriber< sensor_msgs::PointCloud2 > PointCloudSubscriberType;\n  typedef message_filters::Subscriber< sensor_msgs::Image > ImageSubscriberType;\n  typedef message_filters::Synchronizer< PolicyType > SynchronizerType;\n  boost::shared_ptr< PointCloudSubscriberType > point_cloud_sub_; /**< @brief Point cloud subscriber */\n  boost::shared_ptr< ImageSubscriberType > image_sub_;            /**< @brief RGB image subscriber */\n  boost::shared_ptr< SynchronizerType > synchronizer_; /**< @brief Syncronizer for point cloud and image data */\n  ros::ServiceClient get_target_pose_;       /**< @brief Service to call target locator to get target pose */\n  ros::ServiceServer calibrate_depth_;       /**< @brief Service to compute depth coefficients d1 and d2 */\n  ros::ServiceServer calibrate_pixel_depth_; /**< @brief Service to calculate pixel depth error */\n  ros::ServiceServer set_store_cloud_;       /**< @brief Service to set and store next point cloud available */\n  int num_views_;        /**< @brief Number of times to find the calibration target to get average pose */\n  int num_attempts_;     /**< @brief Number of attempts allowed for finding calibration target before failing */\n  int num_point_clouds_; /**< @brief Number of point clouds to save and check when performing pixel depth error\n                            calculations */\n  std::string filename_; /**< @brief Name of the calibration files to save */\n  std::string filepath_; /**< @brief Pathway to the location to save calibration files */\n  geometry_msgs::Pose\n      target_initial_pose_; /**< @brief The initial pose guess of the calibration target for the target finder service\n                               */\n  double std_dev_error_;          /**< @brief The standard deviation error allowed for finding the target pose */\n  double depth_error_threshold_;  /**< @brief The depth error allowed for calculating the pixel depth error map */\n  boost::mutex data_lock_;        /**< @brief Lock for data subscription */\n  sensor_msgs::Image last_image_; /**< @brief The last color image received */\n  pcl::PointCloud< pcl::PointXYZ > last_cloud_; /**< @brief The last point cloud received */\n  pcl::PointCloud< pcl::PointXYZ >\n      correction_cloud_; /**< @brief The point cloud containing the depth correction values */\n  std::vector< pcl::PointCloud< pcl::PointXYZ >, Eigen::aligned_allocator< pcl::PointCloud< pcl::PointXYZ > > >\n      saved_clouds_;\n  /**< @brief The vector of stored point clouds used to compute the distance coefficients */\n  std::vector< std::vector< double > >\n      plane_equations_;                 /**< @brief A vector of plane equations for each point cloud in saved_clouds_ */\n  std::vector< cv::Mat > saved_images_; /**< @brief A vector of rgb images for each point cloud in saved_clouds_ */\n  std::vector< geometry_msgs::Pose > saved_target_poses_; /**< @brief A vector of target poses for each point cloud in\n                                                             saved_clouds_ */\n  /**\n     * @brief Stores the calibration results in a YAML formated file\n     *\n     * @param[in] yaml_file The name and pathway of the file to be saved\n     * @param[in] dp The depth correction coefficients to be saved\n     */\n  void storeCalibration(const std::string& yaml_file, const double dp[2]);\n  /**\n     * @brief Populates and calls the target finder service\n     *\n     * @param[in] final_cost The desired final cost for the service call\n     * @param[out] target_pose The pose of the target returned from the service call\n     * @return True if the service call succeeds\n     */\n  bool findTarget(const double& final_cost, geometry_msgs::Pose& target_pose);\n  /**\n     * @brief Calls the findTarget function multiple times (num_views) and returns the average plane equation and the\n   * last target pose found\n     *\n     * @param[out] plane_eq The average plane equation results found from averaging the results from all of the target\n   * poses found\n     * @param[out] target_pose The pose of the target found from the last service call\n     * @return True if the target was successfully found before the number of failures (num_attempts) was reached\n     */\n  bool findAveragePlane(std::vector< double >& plane_eq, geometry_msgs::Pose& target_pose);\n  bool findAveragePointCloud(pcl::PointCloud< pcl::PointXYZ >& final_cloud);\n"]], "pred": {"ppl": 2.4433367252349854, "ppl_lower": 2.665614366531372, "ppl/lowercase_ppl": -1.0974629458318483, "ppl/zlib": 0.00045005774078419626, "Min_5.0% Prob": 6.572481828577378, "Min_10.0% Prob": 5.371305019247766, "Min_20.0% Prob": 3.8059952381779167, "Min_30.0% Prob": 2.8287320614250655, "Min_40.0% Prob": 2.197838338633913, "Min_50.0% Prob": 1.7808309548959107, "Min_60.0% Prob": 1.4893317472578602}}
{"hexsha": "9c7ca375ff660a322422d65fb1ae12349978085a", "ext": "c", "lang": "C", "content": "static void\nlinevector_add (vec, text, len, vers, pos)\n    struct linevector *vec;\n    char *text;\n    size_t len;\n    RCSVers *vers;\n    unsigned int pos;\n{\n    char *textend;\n    unsigned int i;\n    unsigned int nnew;\n    char *p;\n    struct line *lines;\n\n    if (len == 0)\n\treturn;\n\n    textend = text + len;\n\n    /* Count the number of lines we will need to add.  */\n    nnew = 1;\n    for (p = text; p < textend; ++p)\n\tif (*p == '\\n' && p + 1 < textend)\n\t    ++nnew;\n    /* Allocate the struct line's.  */\n    lines = block_alloc (nnew * sizeof (struct line));\n\n    /* Expand VEC->VECTOR if needed.  */\n    if (vec->nlines + nnew >= vec->lines_alloced)\n    {\n\tif (vec->lines_alloced == 0)\n\t    vec->lines_alloced = 10;\n\twhile (vec->nlines + nnew >= vec->lines_alloced)\n\t    vec->lines_alloced *= 2;\n\tvec->vector = xrealloc (vec->vector,\n\t\t\t\tvec->lines_alloced * sizeof (*vec->vector));\n    }\n\n    /* Make room for the new lines in VEC->VECTOR.  */\n    for (i = vec->nlines + nnew - 1; i >= pos + nnew; --i)\n\tvec->vector[i] = vec->vector[i - nnew];\n\n    if (pos > vec->nlines)\n\terror (1, 0, \"invalid rcs file: line to add out of range\");\n\n    /* Actually add the lines, to LINES and VEC->VECTOR.  */\n    i = pos;\n    lines[0].text = text;\n    lines[0].vers = vers;\n    lines[0].has_newline = 0;\n    vec->vector[i++] = &lines[0];\n    for (p = text; p < textend; ++p)\n\tif (*p == '\\n')\n\t{\n\t    *p = '\\0';\n\t    lines[i - pos - 1].has_newline = 1;\n\t    if (p + 1 == textend)\n\t\t/* If there are no characters beyond the last newline, we\n\t\t   don't consider it another line.  */\n\t\tbreak;\n\t    lines[i - pos - 1].len = p - lines[i - pos - 1].text;\n\t    lines[i - pos].text = p + 1;\n\t    lines[i - pos].vers = vers;\n\t    lines[i - pos].has_newline = 0;\n\t    vec->vector[i] = &lines[i - pos];\n\t    ++i;\n\t}\n    lines[i - pos - 1].len = p - lines[i - pos - 1].text;\n    vec->nlines += nnew;\n}", "item_id": 22, "repo": "aaliomer/exos", "file": "bin/CVS/src/rcs.c", "last_update_at": "2018-01-23T23:07:19+00:00", "question_id": "9c7ca375ff660a322422d65fb1ae12349978085a_22", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nlinevector_add (vec, text, len, vers, pos)\n    struct linevector *vec;\n    char *text;\n    size_t len;\n    RCSVers *vers;\n    unsigned int pos;\n{\n    char *textend;\n    unsigned int i;\n    unsigned int nnew;\n    char *p;\n    struct line *lines;\n    if (len == 0)\n\treturn;\n    textend = text + len;\n    /* Count the number of lines we will need to add.  */\n    nnew = 1;\n    for (p = text; p < textend; ++p)\n\tif (*p == '\\n' && p + 1 < textend)\n\t    ++nnew;\n    /* Allocate the struct line's.  */\n    lines = block_alloc (nnew * sizeof (struct line));\n    /* Expand VEC->VECTOR if needed.  */\n    if (vec->nlines + nnew >= vec->lines_alloced)\n    {\n\tif (vec->lines_alloced == 0)\n\t    vec->lines_alloced = 10;\n\twhile (vec->nlines + nnew >= vec->lines_alloced)\n\t    vec->lines_alloced *= 2;\n\tvec->vector = xrealloc (vec->vector,\n\t\t\t\tvec->lines_alloced * sizeof (*vec->vector));\n    }\n    /* Make room for the new lines in VEC->VECTOR.  */\n    for (i = vec->nlines + nnew - 1; i >= pos + nnew; --i)\n\tvec->vector[i] = vec->vector[i - nnew];\n    if (pos > vec->nlines)\n\terror (1, 0, \"invalid rcs file: line to add out of range\");\n    /* Actually add the lines, to LINES and VEC->VECTOR.  */\n    i = pos;\n    lines[0].text = text;\n    lines[0].vers = vers;\n    lines[0].has_newline = 0;\n    vec->vector[i++] = &lines[0];\n    for (p = text; p < textend; ++p)\n\tif (*p == '\\n')\n\t{\n\t    *p = '\\0';\n\t    lines[i - pos - 1].has_newline = 1;\n\t    if (p + 1 == textend)\n\t\t/* If there are no characters beyond the last newline, we\n\t\t   don't consider it another line.  */\n\t\tbreak;\n\t    lines[i - pos - 1].len = p - lines[i - pos - 1].text;\n\t    lines[i - pos].text = p + 1;\n\t    lines[i - pos].vers = vers;\n\t    lines[i - pos].has_newline = 0;\n\t    vec->vector[i] = &lines[i - pos];\n\t    ++i;\n\t}\n    lines[i - pos - 1].len = p - lines[i - pos - 1].text;\n    vec->nlines += nnew;\n"]], "pred": {"ppl": 1.85310697555542, "ppl_lower": 1.8910434246063232, "ppl/lowercase_ppl": -1.0328517910332669, "ppl/zlib": 0.0008496744857349241, "Min_5.0% Prob": 5.90149566374327, "Min_10.0% Prob": 4.247643859762895, "Min_20.0% Prob": 2.8131625013131845, "Min_30.0% Prob": 2.0020536411749688, "Min_40.0% Prob": 1.5279785827611034, "Min_50.0% Prob": 1.2300792495475004, "Min_60.0% Prob": 1.0271456378140373}}
{"hexsha": "cd850e652da89f9db13c39af1ce0189f9fbdba9c", "ext": "c", "lang": "C", "content": "int DrawFrame(const VulkanDevice *device, float dt)\n{\n   VkRect2D backBufferRect = {\n      .offset = {\n         .x = 0,\n         .y = 0,\n      },\n      .extent = {\n         .width = device->surfaceWidth,\n         .height = device->surfaceHeight,\n      },\n   };\n\n   uint32_t curFrame = s_frameNum++ % ARRAY_COUNT(device->frames);\n   VK_VERIFY(device->vkWaitForFences(device->device, 1, &device->frames[curFrame].frameComplete, VK_TRUE, UINT64_MAX));\n   VK_VERIFY(device->vkResetFences(device->device, 1, &device->frames[curFrame].frameComplete));\n\n   VkFence nullFence = VK_NULL_HANDLE;\n   uint32_t imageIdx;\n   VkResult result = device->vkAcquireNextImageKHR(device->device, device->swapchain, UINT64_MAX,\n      device->frames[curFrame].imageAcquired, nullFence, &imageIdx);\n   if (result == VK_ERROR_OUT_OF_DATE_KHR) {\n      return 0;\n   }\n   ASSERT(result == VK_SUCCESS);\n\n   VkCommandBuffer commandBuffer = device->frames[curFrame].commandBuffer;\n\n   VkCommandBufferBeginInfo beginInfo = {\n      .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,\n      .pNext = NULL,\n      .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,\n      .pInheritanceInfo = NULL,\n   };\n\n   VK_VERIFY(device->vkBeginCommandBuffer(commandBuffer, &beginInfo));\n\n   VkClearValue clearValue = {\n      .color.float32 = { 0.086f, 0.086f, 0.1137f, 1.0f, },\n   };\n   VkRenderPassBeginInfo passInfo = {\n      .sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,\n      .pNext = NULL,\n      .renderPass = s_resources.renderPass,\n      .framebuffer = s_resources.framebuffers[imageIdx].framebuffer,\n      .renderArea = backBufferRect,\n      .clearValueCount = 1,\n      .pClearValues = &clearValue,\n   };\n   device->vkCmdBeginRenderPass(commandBuffer, &passInfo, VK_SUBPASS_CONTENTS_INLINE);\n\n   device->vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, s_resources.pipeline);\n\n   s_cubeRot += dt * CUBE_SPIN_SPEED;\n   s_cubeRot -= floorf(s_cubeRot);\n\n   ShaderMatrices matrices;\n   Mat4 worldFromLocal, viewFromWorld, viewFromLocal, clipFromView;\n   mat4RotY(&worldFromLocal, s_cubeRot * (2.0f * PI));\n\n   Vec3 eye = { 0.0f, 1.5f, -3.0f };\n   Vec3 target = { 0.0f, 0.0f, 0.0f };\n   Vec3 up = { 0.0f, 1.0f, 0.0f };\n   mat4LookAt(&viewFromWorld, eye, target, up);\n   mat4Mul(&viewFromLocal, &viewFromWorld, &worldFromLocal);\n\n   mat4PerspectiveFov(&clipFromView, PI / 2.0f, device->surfaceWidth / (float)device->surfaceHeight, 1.0f, 100.0f);\n   mat4Mul(&matrices.clipFromLocal, &clipFromView, &viewFromLocal);\n\n   device->vkCmdPushConstants(commandBuffer, s_resources.pipelineLayout, VK_SHADER_STAGE_VERTEX_BIT, 0, sizeof(matrices), &matrices);\n\n   device->vkCmdDraw(commandBuffer, 36, 1, 0, 0);\n\n   device->vkCmdEndRenderPass(commandBuffer);\n   VK_VERIFY(device->vkEndCommandBuffer(commandBuffer));\n\n   VkPipelineStageFlags stageFlags = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;\n   VkSubmitInfo submitInfo = {\n      .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,\n      .pNext = NULL,\n      .waitSemaphoreCount = 1,\n      .pWaitSemaphores = &device->frames[curFrame].imageAcquired,\n      .pWaitDstStageMask = &stageFlags,\n      .commandBufferCount = 1,\n      .pCommandBuffers = &commandBuffer,\n      .signalSemaphoreCount = 1,\n      .pSignalSemaphores = &device->frames[curFrame].drawComplete,\n   };\n\n   VK_VERIFY(device->vkQueueSubmit(device->queue, 1, &submitInfo, device->frames[curFrame].frameComplete));\n\n   VkResult presentResult;\n   VkPresentInfoKHR presentInfo = { \n      .sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,\n      .pNext = NULL,\n      .waitSemaphoreCount = 1,\n      .pWaitSemaphores = &device->frames[curFrame].drawComplete,\n      .swapchainCount = 1,\n      .pSwapchains = &device->swapchain,\n      .pImageIndices = &imageIdx,\n      .pResults = &presentResult,\n   };\n\n   VK_VERIFY(device->vkQueuePresentKHR(device->queue, &presentInfo));\n   VK_VERIFY(presentResult);\n\n   return 1;\n}", "item_id": 10, "repo": "fahickman/vkdemo", "file": "vkdemo.c", "last_update_at": "2018-07-04T21:07:18+00:00", "question_id": "cd850e652da89f9db13c39af1ce0189f9fbdba9c_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int DrawFrame(const VulkanDevice *device, float dt)\n{\n   VkRect2D backBufferRect = {\n      .offset = {\n         .x = 0,\n         .y = 0,\n      },\n      .extent = {\n         .width = device->surfaceWidth,\n         .height = device->surfaceHeight,\n      },\n   };\n   uint32_t curFrame = s_frameNum++ % ARRAY_COUNT(device->frames);\n   VK_VERIFY(device->vkWaitForFences(device->device, 1, &device->frames[curFrame].frameComplete, VK_TRUE, UINT64_MAX));\n   VK_VERIFY(device->vkResetFences(device->device, 1, &device->frames[curFrame].frameComplete));\n   VkFence nullFence = VK_NULL_HANDLE;\n   uint32_t imageIdx;\n   VkResult result = device->vkAcquireNextImageKHR(device->device, device->swapchain, UINT64_MAX,\n      device->frames[curFrame].imageAcquired, nullFence, &imageIdx);\n   if (result == VK_ERROR_OUT_OF_DATE_KHR) {\n      return 0;\n   }\n   ASSERT(result == VK_SUCCESS);\n   VkCommandBuffer commandBuffer = device->frames[curFrame].commandBuffer;\n   VkCommandBufferBeginInfo beginInfo = {\n      .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,\n      .pNext = NULL,\n      .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,\n      .pInheritanceInfo = NULL,\n   };\n   VK_VERIFY(device->vkBeginCommandBuffer(commandBuffer, &beginInfo));\n   VkClearValue clearValue = {\n      .color.float32 = { 0.086f, 0.086f, 0.1137f, 1.0f, },\n   };\n   VkRenderPassBeginInfo passInfo = {\n      .sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,\n      .pNext = NULL,\n      .renderPass = s_resources.renderPass,\n      .framebuffer = s_resources.framebuffers[imageIdx].framebuffer,\n      .renderArea = backBufferRect,\n      .clearValueCount = 1,\n      .pClearValues = &clearValue,\n   };\n   device->vkCmdBeginRenderPass(commandBuffer, &passInfo, VK_SUBPASS_CONTENTS_INLINE);\n   device->vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, s_resources.pipeline);\n   s_cubeRot += dt * CUBE_SPIN_SPEED;\n   s_cubeRot -= floorf(s_cubeRot);\n   ShaderMatrices matrices;\n   Mat4 worldFromLocal, viewFromWorld, viewFromLocal, clipFromView;\n   mat4RotY(&worldFromLocal, s_cubeRot * (2.0f * PI));\n   Vec3 eye = { 0.0f, 1.5f, -3.0f };\n   Vec3 target = { 0.0f, 0.0f, 0.0f };\n   Vec3 up = { 0.0f, 1.0f, 0.0f };\n   mat4LookAt(&viewFromWorld, eye, target, up);\n   mat4Mul(&viewFromLocal, &viewFromWorld, &worldFromLocal);\n   mat4PerspectiveFov(&clipFromView, PI / 2.0f, device->surfaceWidth / (float)device->surfaceHeight, 1.0f, 100.0f);\n   mat4Mul(&matrices.clipFromLocal, &clipFromView, &viewFromLocal);\n   device->vkCmdPushConstants(commandBuffer, s_resources.pipelineLayout, VK_SHADER_STAGE_VERTEX_BIT, 0, sizeof(matrices), &matrices);\n   device->vkCmdDraw(commandBuffer, 36, 1, 0, 0);\n   device->vkCmdEndRenderPass(commandBuffer);\n   VK_VERIFY(device->vkEndCommandBuffer(commandBuffer));\n   VkPipelineStageFlags stageFlags = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;\n   VkSubmitInfo submitInfo = {\n      .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,\n      .pNext = NULL,\n      .waitSemaphoreCount = 1,\n      .pWaitSemaphores = &device->frames[curFrame].imageAcquired,\n      .pWaitDstStageMask = &stageFlags,\n      .commandBufferCount = 1,\n      .pCommandBuffers = &commandBuffer,\n      .signalSemaphoreCount = 1,\n      .pSignalSemaphores = &device->frames[curFrame].drawComplete,\n   };\n   VK_VERIFY(device->vkQueueSubmit(device->queue, 1, &submitInfo, device->frames[curFrame].frameComplete));\n   VkResult presentResult;\n   VkPresentInfoKHR presentInfo = { \n      .sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,\n      .pNext = NULL,\n      .waitSemaphoreCount = 1,\n      .pWaitSemaphores = &device->frames[curFrame].drawComplete,\n      .swapchainCount = 1,\n      .pSwapchains = &device->swapchain,\n      .pImageIndices = &imageIdx,\n      .pResults = &presentResult,\n   };\n   VK_VERIFY(device->vkQueuePresentKHR(device->queue, &presentInfo));\n   VK_VERIFY(presentResult);\n   return 1;\n"]], "pred": {"ppl": 1.5365972518920898, "ppl_lower": 1.764304757118225, "ppl/lowercase_ppl": -1.321684906726505, "ppl/zlib": 0.00032201678786780464, "Min_5.0% Prob": 4.9666872398526065, "Min_10.0% Prob": 3.4395828609373056, "Min_20.0% Prob": 2.0341094311545875, "Min_30.0% Prob": 1.4152226657454485, "Min_40.0% Prob": 1.0703049958945414, "Min_50.0% Prob": 0.8591399597233698, "Min_60.0% Prob": 0.7166877552864277}}
{"hexsha": "ce75e0481e95ff417ab4d85498e3dbcc7c80f829", "ext": "h", "lang": "C", "content": "interface IMBookshelfBackgroundView : UIView\n{\n    UIImageView *_topShelfImageView;\t// 8 = 0x8\n    struct CGPoint _offset;\t// 16 = 0x10\n    double _shelfHeight;\t// 32 = 0x20\n    _Bool _useAlternateSize;\t// 40 = 0x28\n    IMBookshelfImageGenerator *_imageGenerator;\t// 48 = 0x30\n    IMLibraryTiledBackgroundView *_shelves;\t// 56 = 0x38\n    IMBookshelfImageConfiguration *_imageConfiguration;\t// 64 = 0x40\n    IMLibraryTileView *_topGradientView;\t// 72 = 0x48\n}", "item_id": 0, "repo": "lechium/tvOS10Headers", "file": "Applications/Podcasts/IMBookshelfBackgroundView.h", "last_update_at": "2018-08-04T20:16:32+00:00", "question_id": "ce75e0481e95ff417ab4d85498e3dbcc7c80f829_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface IMBookshelfBackgroundView : UIView\n{\n    UIImageView *_topShelfImageView;\t// 8 = 0x8\n    struct CGPoint _offset;\t// 16 = 0x10\n    double _shelfHeight;\t// 32 = 0x20\n    _Bool _useAlternateSize;\t// 40 = 0x28\n    IMBookshelfImageGenerator *_imageGenerator;\t// 48 = 0x30\n    IMLibraryTiledBackgroundView *_shelves;\t// 56 = 0x38\n    IMBookshelfImageConfiguration *_imageConfiguration;\t// 64 = 0x40\n    IMLibraryTileView *_topGradientView;\t// 72 = 0x48\n"]], "pred": {"ppl": 2.972803831100464, "ppl_lower": 3.415250301361084, "ppl/lowercase_ppl": -1.1273469654257038, "ppl/zlib": 0.0042725708170761375, "Min_5.0% Prob": 8.602106624179417, "Min_10.0% Prob": 6.800343463295384, "Min_20.0% Prob": 4.786898450973706, "Min_30.0% Prob": 3.5944962090459365, "Min_40.0% Prob": 2.731171547506864, "Min_50.0% Prob": 2.1784453773015766, "Min_60.0% Prob": 1.8251237196501535}}
{"hexsha": "694e8cddd5c13e1760e7c9cd5fc0170876a9df04", "ext": "c", "lang": "C", "content": "static bool __power_supply_is_supplied_by(struct power_supply *supplier,\n\t\t\t\t\t struct power_supply *supply)\n{\n\tint i;\n\n\tif (!supply->supplied_from && !supplier->supplied_to)\n\t\treturn false;\n\n\t/* Support both supplied_to and supplied_from modes */\n\tif (supply->supplied_from) {\n\t\tif (!supplier->name)\n\t\t\treturn false;\n\t\tfor (i = 0; i < supply->num_supplies; i++)\n\t\t\tif (!strcmp(supplier->name, supply->supplied_from[i]))\n\t\t\t\treturn true;\n\t} else {\n\t\tif (!supply->name)\n\t\t\treturn false;\n\t\tfor (i = 0; i < supplier->num_supplicants; i++)\n\t\t\tif (!strcmp(supplier->supplied_to[i], supply->name))\n\t\t\t\treturn true;\n\t}\n\n\treturn false;\n}", "item_id": 0, "repo": "bradchesney79/illacceptanything", "file": "linux/drivers/power/power_supply_core.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "694e8cddd5c13e1760e7c9cd5fc0170876a9df04_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static bool __power_supply_is_supplied_by(struct power_supply *supplier,\n\t\t\t\t\t struct power_supply *supply)\n{\n\tint i;\n\tif (!supply->supplied_from && !supplier->supplied_to)\n\t\treturn false;\n\t/* Support both supplied_to and supplied_from modes */\n\tif (supply->supplied_from) {\n\t\tif (!supplier->name)\n\t\t\treturn false;\n\t\tfor (i = 0; i < supply->num_supplies; i++)\n\t\t\tif (!strcmp(supplier->name, supply->supplied_from[i]))\n\t\t\t\treturn true;\n\t} else {\n\t\tif (!supply->name)\n\t\t\treturn false;\n\t\tfor (i = 0; i < supplier->num_supplicants; i++)\n\t\t\tif (!strcmp(supplier->supplied_to[i], supply->name))\n\t\t\t\treturn true;\n\t}\n\treturn false;\n"]], "pred": {"ppl": 1.5377514362335205, "ppl_lower": 1.5410982370376587, "ppl/lowercase_ppl": -1.005052179366388, "ppl/zlib": 0.0017212849723586409, "Min_5.0% Prob": 5.554354190826416, "Min_10.0% Prob": 3.620488066673279, "Min_20.0% Prob": 2.063215840096567, "Min_30.0% Prob": 1.4237955519324774, "Min_40.0% Prob": 1.0745039228892441, "Min_50.0% Prob": 0.8599647423108072, "Min_60.0% Prob": 0.7208012766877564}}
{"hexsha": "9eea3a10a7307de6b68ff5398cc80c651c6a7a2d", "ext": "c", "lang": "C", "content": "static void\nrndr_blockcode(hoedown_buffer *ob, const hoedown_buffer *text, const hoedown_buffer *lang, const hoedown_renderer_data *data)\n{\n\tif (ob->size) hoedown_buffer_putc(ob, '\\n');\n\n\tif (lang) {\n\t\tHOEDOWN_BUFPUTSL(ob, \"<pre><code class=\\\"language-\");\n\t\tescape_html(ob, lang->data, lang->size);\n\t\tHOEDOWN_BUFPUTSL(ob, \"\\\">\");\n\t} else {\n\t\tHOEDOWN_BUFPUTSL(ob, \"<pre><code>\");\n\t}\n\n\tif (text)\n\t\tescape_html(ob, text->data, text->size);\n\n\tHOEDOWN_BUFPUTSL(ob, \"</code></pre>\\n\");\n}", "item_id": 2, "repo": "guardianproject/cwac-anddown", "file": "anddown/jni/src/html.c", "last_update_at": "2018-12-14T13:44:25+00:00", "question_id": "9eea3a10a7307de6b68ff5398cc80c651c6a7a2d_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nrndr_blockcode(hoedown_buffer *ob, const hoedown_buffer *text, const hoedown_buffer *lang, const hoedown_renderer_data *data)\n{\n\tif (ob->size) hoedown_buffer_putc(ob, '\\n');\n\tif (lang) {\n\t\tHOEDOWN_BUFPUTSL(ob, \"<pre><code class=\\\"language-\");\n\t\tescape_html(ob, lang->data, lang->size);\n\t\tHOEDOWN_BUFPUTSL(ob, \"\\\">\");\n\t} else {\n\t\tHOEDOWN_BUFPUTSL(ob, \"<pre><code>\");\n\t}\n\tif (text)\n\t\tescape_html(ob, text->data, text->size);\n\tHOEDOWN_BUFPUTSL(ob, \"</code></pre>\\n\");\n"]], "pred": {"ppl": 1.4389580488204956, "ppl_lower": 1.5698297023773193, "ppl/lowercase_ppl": -1.2391955449691072, "ppl/zlib": 0.0014793466441934305, "Min_5.0% Prob": 5.17525954246521, "Min_10.0% Prob": 3.2717263954026357, "Min_20.0% Prob": 1.7780165038136548, "Min_30.0% Prob": 1.221970346494345, "Min_40.0% Prob": 0.9129257744914571, "Min_50.0% Prob": 0.7276011810851438, "Min_60.0% Prob": 0.6092878737028458}}
{"hexsha": "f690ad6e94d23678ec10f30a9f64199e7e29d2a7", "ext": "c", "lang": "C", "content": "int Yodiwo_Plegma_ConfigDescription_ToJson(char* jsonStart, size_t jsonSize, Yodiwo_Plegma_ConfigDescription_t *value)\n{\n\tchar *json = jsonStart, *jsonEnd = json + jsonSize;\n\tint len;\n\tjson += snprintf(json, jsonEnd - json, \"{ \\\"DefaultValue\\\" : \\\"\"); if (json >= jsonEnd) return -1;\n\tjson += strcpy_escaped(json, value->DefaultValue); if (json + 1 >= jsonEnd) return -1;\n\t*json = '\\\"'; json++;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Description\\\" : \\\"\"); if (json >= jsonEnd) return -1;\n\tjson += strcpy_escaped(json, value->Description); if (json + 1 >= jsonEnd) return -1;\n\t*json = '\\\"'; json++;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Label\\\" : \\\"\"); if (json >= jsonEnd) return -1;\n\tjson += strcpy_escaped(json, value->Label); if (json + 1 >= jsonEnd) return -1;\n\t*json = '\\\"'; json++;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Name\\\" : \\\"\"); if (json >= jsonEnd) return -1;\n\tjson += strcpy_escaped(json, value->Name); if (json + 1 >= jsonEnd) return -1;\n\t*json = '\\\"'; json++;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Required\\\" : %s\", (value->Required) ? \"true\" : \"false\"); if (json >= jsonEnd) return -1;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Type\\\" : \\\"\"); if (json >= jsonEnd) return -1;\n\tjson += strcpy_escaped(json, value->Type); if (json + 1 >= jsonEnd) return -1;\n\t*json = '\\\"'; json++;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Minimum\\\" : %lf\", value->Minimum); if (json >= jsonEnd) return -1;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Maximum\\\" : %lf\", value->Maximum); if (json >= jsonEnd) return -1;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Stepsize\\\" : %lf\", value->Stepsize); if (json >= jsonEnd) return -1;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"ReadOnly\\\" : %s\", (value->ReadOnly) ? \"true\" : \"false\"); if (json >= jsonEnd) return -1;\n\t*json = '}'; json++;\n\t*json = '\\0'; json++;\n\treturn json - jsonStart;\n}", "item_id": 41, "repo": "yodiwo/plegma", "file": "C/linux_node/libsrc/yodiwo/yodiwo_api.c", "last_update_at": "2018-02-26T09:38:38+00:00", "question_id": "f690ad6e94d23678ec10f30a9f64199e7e29d2a7_41", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int Yodiwo_Plegma_ConfigDescription_ToJson(char* jsonStart, size_t jsonSize, Yodiwo_Plegma_ConfigDescription_t *value)\n{\n\tchar *json = jsonStart, *jsonEnd = json + jsonSize;\n\tint len;\n\tjson += snprintf(json, jsonEnd - json, \"{ \\\"DefaultValue\\\" : \\\"\"); if (json >= jsonEnd) return -1;\n\tjson += strcpy_escaped(json, value->DefaultValue); if (json + 1 >= jsonEnd) return -1;\n\t*json = '\\\"'; json++;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Description\\\" : \\\"\"); if (json >= jsonEnd) return -1;\n\tjson += strcpy_escaped(json, value->Description); if (json + 1 >= jsonEnd) return -1;\n\t*json = '\\\"'; json++;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Label\\\" : \\\"\"); if (json >= jsonEnd) return -1;\n\tjson += strcpy_escaped(json, value->Label); if (json + 1 >= jsonEnd) return -1;\n\t*json = '\\\"'; json++;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Name\\\" : \\\"\"); if (json >= jsonEnd) return -1;\n\tjson += strcpy_escaped(json, value->Name); if (json + 1 >= jsonEnd) return -1;\n\t*json = '\\\"'; json++;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Required\\\" : %s\", (value->Required) ? \"true\" : \"false\"); if (json >= jsonEnd) return -1;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Type\\\" : \\\"\"); if (json >= jsonEnd) return -1;\n\tjson += strcpy_escaped(json, value->Type); if (json + 1 >= jsonEnd) return -1;\n\t*json = '\\\"'; json++;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Minimum\\\" : %lf\", value->Minimum); if (json >= jsonEnd) return -1;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Maximum\\\" : %lf\", value->Maximum); if (json >= jsonEnd) return -1;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Stepsize\\\" : %lf\", value->Stepsize); if (json >= jsonEnd) return -1;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"ReadOnly\\\" : %s\", (value->ReadOnly) ? \"true\" : \"false\"); if (json >= jsonEnd) return -1;\n\t*json = '}'; json++;\n\t*json = '\\0'; json++;\n\treturn json - jsonStart;\n"]], "pred": {"ppl": 1.484366536140442, "ppl_lower": 1.5232021808624268, "ppl/lowercase_ppl": -1.065386046193503, "ppl/zlib": 0.0010505002825959263, "Min_5.0% Prob": 5.349890311559041, "Min_10.0% Prob": 3.528322002780971, "Min_20.0% Prob": 1.9588753534135994, "Min_30.0% Prob": 1.3172662773908212, "Min_40.0% Prob": 0.9888210601011821, "Min_50.0% Prob": 0.7909119331479144, "Min_60.0% Prob": 0.6588923361647104}}
{"hexsha": "c42ec6f00688d39df0464e1e099ebc5743a7e81c", "ext": "c", "lang": "C", "content": "static int disassemble(char *Instruction, char *Arg1, char *Arg2)\n{\n\tunsigned int ReferencePC=memory_core.pc+2;\n\tunsigned int Displacement;\n\tBCC_Instr Instr;\n\tMemory_RetrWordFromPC(&Instr.Code);\n\tDisplacement=Instr.Bits.Displacement;\n\tswitch(Instr.Bits.Condition) {\n\tcase 0: /* BRA */\n\t\tsprintf(Instruction, \"BRA\");\n\t\tbreak;\n\tcase 1: /* BSR */\n\t\tsprintf(Instruction, \"BSR\");\n\t\tbreak;\n\tcase 2: /* BHI */\n\t\tsprintf(Instruction, \"BHI\");\n\t\tbreak;\n\tcase 3: /* BLS */\n\t\tsprintf(Instruction, \"BLS\");\n\t\tbreak;\n\tcase 4: /* BCC */\n\t\tsprintf(Instruction, \"BCC\");\n\t\tbreak;\n\tcase 5: /* BCS */\n\t\tsprintf(Instruction, \"BCS\");\n\t\tbreak;\n\tcase 6: /* BNE */\n\t\tsprintf(Instruction, \"BNE\");\n\t\tbreak;\n\tcase 7: /* BEQ */\n\t\tsprintf(Instruction, \"BEQ\");\n\t\tbreak;\n\tcase 8: /* BVC */\n\t\tsprintf(Instruction, \"BVC\");\n\t\tbreak;\n\tcase 9: /* BVS */\n\t\tsprintf(Instruction, \"BVS\");\n\t\tbreak;\n\tcase 10: /* BPL */\n\t\tsprintf(Instruction, \"BPL\");\n\t\tbreak;\n\tcase 11: /* BMI */\n\t\tsprintf(Instruction, \"BMI\");\n\t\tbreak;\n\tcase 12: /* BGE */\n\t\tsprintf(Instruction, \"BGE\");\n\t\tbreak;\n\tcase 13: /* BLT */\n\t\tsprintf(Instruction, \"BLT\");\n\t\tbreak;\n\tcase 14: /* BGT */\n\t\tsprintf(Instruction, \"BGT\");\n\t\tbreak;\n\tcase 15: /* BLE */\n\t\tsprintf(Instruction, \"BLE\");\n\t\tbreak;\n\t}\n\n\tif(Displacement==0) {\n\t\tMemory_RetrWordFromPC(&Displacement);\n\t\tDisplacement = (short)Displacement;\n/*\t\tsprintf(&Instruction[3], \".W\");*/\n\t}\n/*\telse\n\t\tsprintf(&Instruction[3], \".B\");*/\n\tsprintf(Arg1, \"0x%08lX\", ReferencePC+Displacement);\n\tArg2[0]=0;\t\n\treturn 0;\n}", "item_id": 1, "repo": "zecke/pharo-vm-1", "file": "processors/ARM/skyeye/arch/coldfire/instruction/i_bcc.c", "last_update_at": "2018-11-01T20:54:57+00:00", "question_id": "c42ec6f00688d39df0464e1e099ebc5743a7e81c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int disassemble(char *Instruction, char *Arg1, char *Arg2)\n{\n\tunsigned int ReferencePC=memory_core.pc+2;\n\tunsigned int Displacement;\n\tBCC_Instr Instr;\n\tMemory_RetrWordFromPC(&Instr.Code);\n\tDisplacement=Instr.Bits.Displacement;\n\tswitch(Instr.Bits.Condition) {\n\tcase 0: /* BRA */\n\t\tsprintf(Instruction, \"BRA\");\n\t\tbreak;\n\tcase 1: /* BSR */\n\t\tsprintf(Instruction, \"BSR\");\n\t\tbreak;\n\tcase 2: /* BHI */\n\t\tsprintf(Instruction, \"BHI\");\n\t\tbreak;\n\tcase 3: /* BLS */\n\t\tsprintf(Instruction, \"BLS\");\n\t\tbreak;\n\tcase 4: /* BCC */\n\t\tsprintf(Instruction, \"BCC\");\n\t\tbreak;\n\tcase 5: /* BCS */\n\t\tsprintf(Instruction, \"BCS\");\n\t\tbreak;\n\tcase 6: /* BNE */\n\t\tsprintf(Instruction, \"BNE\");\n\t\tbreak;\n\tcase 7: /* BEQ */\n\t\tsprintf(Instruction, \"BEQ\");\n\t\tbreak;\n\tcase 8: /* BVC */\n\t\tsprintf(Instruction, \"BVC\");\n\t\tbreak;\n\tcase 9: /* BVS */\n\t\tsprintf(Instruction, \"BVS\");\n\t\tbreak;\n\tcase 10: /* BPL */\n\t\tsprintf(Instruction, \"BPL\");\n\t\tbreak;\n\tcase 11: /* BMI */\n\t\tsprintf(Instruction, \"BMI\");\n\t\tbreak;\n\tcase 12: /* BGE */\n\t\tsprintf(Instruction, \"BGE\");\n\t\tbreak;\n\tcase 13: /* BLT */\n\t\tsprintf(Instruction, \"BLT\");\n\t\tbreak;\n\tcase 14: /* BGT */\n\t\tsprintf(Instruction, \"BGT\");\n\t\tbreak;\n\tcase 15: /* BLE */\n\t\tsprintf(Instruction, \"BLE\");\n\t\tbreak;\n\t}\n\tif(Displacement==0) {\n\t\tMemory_RetrWordFromPC(&Displacement);\n\t\tDisplacement = (short)Displacement;\n/*\t\tsprintf(&Instruction[3], \".W\");*/\n\t}\n/*\telse\n\t\tsprintf(&Instruction[3], \".B\");*/\n\tsprintf(Arg1, \"0x%08lX\", ReferencePC+Displacement);\n\tArg2[0]=0;\t\n\treturn 0;\n"]], "pred": {"ppl": 1.4601722955703735, "ppl_lower": 1.5105046033859253, "ppl/lowercase_ppl": -1.0895230024519464, "ppl/zlib": 0.0008193819035111986, "Min_5.0% Prob": 5.159949880657774, "Min_10.0% Prob": 3.3172900160746788, "Min_20.0% Prob": 1.8614260116109143, "Min_30.0% Prob": 1.2611875633245766, "Min_40.0% Prob": 0.946604313243806, "Min_50.0% Prob": 0.7569652327099763, "Min_60.0% Prob": 0.6321136002475282}}
{"hexsha": "e2d6015282dadd03c6e74e4c95822f2d21160ac5", "ext": "c", "lang": "C", "content": "static CDFstatus ValidateAttributeEntryLink (struct CDFstruct *CDF, vFILE *fp, \n                                      Int32 num, Logical zEntry, OFF_T EDRhead,\n                                             Int32 numEntries, Int32 maxEntry, \n                                             Logical debug)\n{\n  CDFstatus status;\n  OFF_T offset, nextAEDR;\n  Int32 entryNum, lastNum, *visits;\n  int ix, iy;\n  \n  offset = EDRhead;\n  lastNum = 0;\n  visits = (Int32 *) cdf_AllocateMemory ((size_t)numEntries * sizeof(Int32), NULL);\n  if (visits == NULL) return BAD_MALLOC;\n  for (ix = 0; ix < numEntries; ++ix) visits[ix] = 0;\n  ix = 0;\n  while (offset != 0) {\n    status = ValidateAEDR (CDF, fp, offset, num, maxEntry, zEntry, debug);\n    if (status != CDF_OK) { \n      cdf_FreeMemory (visits, NULL);\n      return status;\n    }\n    status = ReadAEDR64 (fp, offset,\n                         AEDR_NUM, &entryNum,\n                         AEDR_AEDRNEXT, &nextAEDR,\n                         AEDR_NULL);\n    if (ix > 0) {\n      for (iy = 0; iy < ix; ++iy) {\n        if (visits[iy] == entryNum) {\n          cdf_FreeMemory (visits, NULL);\n          return QuitCDF (\"CDF: entry number is repeating in an attribute entry link: \", (OFF_T) -1,\n                          4, 1, &entryNum, 0, debug);\n        }\n      }\n    }\n    if (ix == (int) numEntries) {\n      cdf_FreeMemory (visits, NULL);\n      return QuitCDF (\"CDF: number of entries is more than maximum in an attribute entry link: \", (OFF_T) -1,\n                      4, 1, &ix, 0, debug);\n    }\n    visits[ix] = entryNum;\n    ++ix;\n    if (lastNum < entryNum) lastNum = entryNum;\n    offset = nextAEDR;\n  }\n  if (lastNum != maxEntry) {\n    cdf_FreeMemory (visits, NULL);\n    return QuitCDF (\"CDF: last entry number is not the maximum entry number in  an attribute entry link: \", (OFF_T) -1,\n                    4, 2, &lastNum, &maxEntry, debug);\n  }\n  cdf_FreeMemory (visits, NULL);\n  return CDF_OK;\n}", "item_id": 14, "repo": "rstoneback/pysatCDF", "file": "cdf36_3-dist/src/lib/cdfvalidator64.c", "last_update_at": "2018-01-26T19:45:48+00:00", "question_id": "e2d6015282dadd03c6e74e4c95822f2d21160ac5_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static CDFstatus ValidateAttributeEntryLink (struct CDFstruct *CDF, vFILE *fp, \n                                      Int32 num, Logical zEntry, OFF_T EDRhead,\n                                             Int32 numEntries, Int32 maxEntry, \n                                             Logical debug)\n{\n  CDFstatus status;\n  OFF_T offset, nextAEDR;\n  Int32 entryNum, lastNum, *visits;\n  int ix, iy;\n  offset = EDRhead;\n  lastNum = 0;\n  visits = (Int32 *) cdf_AllocateMemory ((size_t)numEntries * sizeof(Int32), NULL);\n  if (visits == NULL) return BAD_MALLOC;\n  for (ix = 0; ix < numEntries; ++ix) visits[ix] = 0;\n  ix = 0;\n  while (offset != 0) {\n    status = ValidateAEDR (CDF, fp, offset, num, maxEntry, zEntry, debug);\n    if (status != CDF_OK) { \n      cdf_FreeMemory (visits, NULL);\n      return status;\n    }\n    status = ReadAEDR64 (fp, offset,\n                         AEDR_NUM, &entryNum,\n                         AEDR_AEDRNEXT, &nextAEDR,\n                         AEDR_NULL);\n    if (ix > 0) {\n      for (iy = 0; iy < ix; ++iy) {\n        if (visits[iy] == entryNum) {\n          cdf_FreeMemory (visits, NULL);\n          return QuitCDF (\"CDF: entry number is repeating in an attribute entry link: \", (OFF_T) -1,\n                          4, 1, &entryNum, 0, debug);\n        }\n      }\n    }\n    if (ix == (int) numEntries) {\n      cdf_FreeMemory (visits, NULL);\n      return QuitCDF (\"CDF: number of entries is more than maximum in an attribute entry link: \", (OFF_T) -1,\n                      4, 1, &ix, 0, debug);\n    }\n    visits[ix] = entryNum;\n    ++ix;\n    if (lastNum < entryNum) lastNum = entryNum;\n    offset = nextAEDR;\n  }\n  if (lastNum != maxEntry) {\n    cdf_FreeMemory (visits, NULL);\n    return QuitCDF (\"CDF: last entry number is not the maximum entry number in  an attribute entry link: \", (OFF_T) -1,\n                    4, 2, &lastNum, &maxEntry, debug);\n  }\n  cdf_FreeMemory (visits, NULL);\n  return CDF_OK;\n"]], "pred": {"ppl": 2.0515995025634766, "ppl_lower": 2.5274593830108643, "ppl/lowercase_ppl": -1.2902715550355073, "ppl/zlib": 0.001077390905652509, "Min_5.0% Prob": 6.813459171968348, "Min_10.0% Prob": 5.034963652707528, "Min_20.0% Prob": 3.2914331918177395, "Min_30.0% Prob": 2.3397189368660323, "Min_40.0% Prob": 1.7835301357469913, "Min_50.0% Prob": 1.4337210100576065, "Min_60.0% Prob": 1.1968951477120284}}
{"hexsha": "11466f7394ed835e3bf4a6318e91cc20f45752cf", "ext": "c", "lang": "C", "content": "void itoa16bits(uint16_t number, char* ascii) {\n\tint i, j, k;\n\ti = 0;\n\tfor (k = 10000; k > 10; k /= 10) {\n\t\tj = number/k;\n\t\tascii[i] = j + 48;\n\t\t++i;\n\t\tnumber %= k;\n\t}\n\tj = number/k;\n\tascii[i] = j + 48;\n\t++i;\n\tj = number%k;\n\tascii[i] = j + 48;\n}", "item_id": 4, "repo": "daniel5555/Mikromedia-plus-STM32-MP3-player", "file": "utils.c", "last_update_at": "2018-10-06T19:56:36+00:00", "question_id": "11466f7394ed835e3bf4a6318e91cc20f45752cf_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void itoa16bits(uint16_t number, char* ascii) {\n\tint i, j, k;\n\ti = 0;\n\tfor (k = 10000; k > 10; k /= 10) {\n\t\tj = number/k;\n\t\tascii[i] = j + 48;\n\t\t++i;\n\t\tnumber %= k;\n\t}\n\tj = number/k;\n\tascii[i] = j + 48;\n\t++i;\n\tj = number%k;\n\tascii[i] = j + 48;\n"]], "pred": {"ppl": 2.3725221157073975, "ppl_lower": 2.3725221157073975, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.005798346128507399, "Min_5.0% Prob": 7.493623324802944, "Min_10.0% Prob": 5.70614013671875, "Min_20.0% Prob": 3.7513294027697657, "Min_30.0% Prob": 2.800044745206833, "Min_40.0% Prob": 2.1284191364482528, "Min_50.0% Prob": 1.7287343517913447, "Min_60.0% Prob": 1.4368067432335148}}
{"hexsha": "8998689299fdc270786615c8a2402528f6850ecc", "ext": "c", "lang": "C", "content": "u32 bq24261_get_minsys_status(void)\n{\n\tu32 ret = 0;\n\tu8 val = 0;\n\n\tret = bq24261_read_interface((u8) (bq24261_CON5),\n\t\t\t\t     (&val),\n\t\t\t\t     (u8) (CON5_MINSYS_STATUS_MASK), (u8) (CON5_MINSYS_STATUS_SHIFT)\n\t    );\n\treturn val;\n}", "item_id": 10, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/drivers/power/mt81xx/bq24261.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "8998689299fdc270786615c8a2402528f6850ecc_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["u32 bq24261_get_minsys_status(void)\n{\n\tu32 ret = 0;\n\tu8 val = 0;\n\tret = bq24261_read_interface((u8) (bq24261_CON5),\n\t\t\t\t     (&val),\n\t\t\t\t     (u8) (CON5_MINSYS_STATUS_MASK), (u8) (CON5_MINSYS_STATUS_SHIFT)\n\t    );\n\treturn val;\n"]], "pred": {"ppl": 2.2851133346557617, "ppl_lower": 2.767772674560547, "ppl/lowercase_ppl": -1.2318776174950266, "ppl/zlib": 0.005101331003258456, "Min_5.0% Prob": 6.56588077545166, "Min_10.0% Prob": 5.0356690516838665, "Min_20.0% Prob": 3.356250016777604, "Min_30.0% Prob": 2.5499809980392456, "Min_40.0% Prob": 2.005562925228366, "Min_50.0% Prob": 1.6315092455376596, "Min_60.0% Prob": 1.3811312473758504}}
{"hexsha": "9e57b77ecd34ef3367ed64b4105c5ce65e3c724f", "ext": "c", "lang": "C", "content": "static struct f71805f_data *f71805f_update_device(struct device *dev)\n{\n\tstruct f71805f_data *data = dev_get_drvdata(dev);\n\tint nr, apnr;\n\n\tmutex_lock(&data->update_lock);\n\n\t/* Limit registers cache is refreshed after 60 seconds */\n\tif (time_after(jiffies, data->last_updated + 60 * HZ)\n\t || !data->valid) {\n\t\tfor (nr = 0; nr < 11; nr++) {\n\t\t\tif (!(data->has_in & (1 << nr)))\n\t\t\t\tcontinue;\n\t\t\tdata->in_high[nr] = f71805f_read8(data,\n\t\t\t\t\t    F71805F_REG_IN_HIGH(nr));\n\t\t\tdata->in_low[nr] = f71805f_read8(data,\n\t\t\t\t\t   F71805F_REG_IN_LOW(nr));\n\t\t}\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tdata->fan_low[nr] = f71805f_read16(data,\n\t\t\t\t\t    F71805F_REG_FAN_LOW(nr));\n\t\t\tdata->fan_target[nr] = f71805f_read16(data,\n\t\t\t\t\t       F71805F_REG_FAN_TARGET(nr));\n\t\t\tdata->pwm_freq[nr] = f71805f_read8(data,\n\t\t\t\t\t     F71805F_REG_PWM_FREQ(nr));\n\t\t}\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tdata->temp_high[nr] = f71805f_read8(data,\n\t\t\t\t\t      F71805F_REG_TEMP_HIGH(nr));\n\t\t\tdata->temp_hyst[nr] = f71805f_read8(data,\n\t\t\t\t\t      F71805F_REG_TEMP_HYST(nr));\n\t\t}\n\t\tdata->temp_mode = f71805f_read8(data, F71805F_REG_TEMP_MODE);\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tfor (apnr = 0; apnr < 3; apnr++) {\n\t\t\t\tdata->auto_points[nr].temp[apnr] =\n\t\t\t\t\tf71805f_read8(data,\n\t\t\t\t\tF71805F_REG_PWM_AUTO_POINT_TEMP(nr,\n\t\t\t\t\t\t\t\t\tapnr));\n\t\t\t\tdata->auto_points[nr].fan[apnr] =\n\t\t\t\t\tf71805f_read16(data,\n\t\t\t\t\tF71805F_REG_PWM_AUTO_POINT_FAN(nr,\n\t\t\t\t\t\t\t\t       apnr));\n\t\t\t}\n\t\t}\n\n\t\tdata->last_limits = jiffies;\n\t}\n\n\t/* Measurement registers cache is refreshed after 1 second */\n\tif (time_after(jiffies, data->last_updated + HZ)\n\t || !data->valid) {\n\t\tfor (nr = 0; nr < 11; nr++) {\n\t\t\tif (!(data->has_in & (1 << nr)))\n\t\t\t\tcontinue;\n\t\t\tdata->in[nr] = f71805f_read8(data,\n\t\t\t\t       F71805F_REG_IN(nr));\n\t\t}\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tdata->fan[nr] = f71805f_read16(data,\n\t\t\t\t\tF71805F_REG_FAN(nr));\n\t\t\tdata->fan_ctrl[nr] = f71805f_read8(data,\n\t\t\t\t\t     F71805F_REG_FAN_CTRL(nr));\n\t\t\tdata->pwm[nr] = f71805f_read8(data,\n\t\t\t\t\tF71805F_REG_PWM_DUTY(nr));\n\t\t}\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tdata->temp[nr] = f71805f_read8(data,\n\t\t\t\t\t F71805F_REG_TEMP(nr));\n\t\t}\n\t\tdata->alarms = f71805f_read8(data, F71805F_REG_STATUS(0))\n\t\t\t+ (f71805f_read8(data, F71805F_REG_STATUS(1)) << 8)\n\t\t\t+ (f71805f_read8(data, F71805F_REG_STATUS(2)) << 16);\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = 1;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}", "item_id": 10, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/drivers/hwmon/f71805f.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "9e57b77ecd34ef3367ed64b4105c5ce65e3c724f_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static struct f71805f_data *f71805f_update_device(struct device *dev)\n{\n\tstruct f71805f_data *data = dev_get_drvdata(dev);\n\tint nr, apnr;\n\tmutex_lock(&data->update_lock);\n\t/* Limit registers cache is refreshed after 60 seconds */\n\tif (time_after(jiffies, data->last_updated + 60 * HZ)\n\t || !data->valid) {\n\t\tfor (nr = 0; nr < 11; nr++) {\n\t\t\tif (!(data->has_in & (1 << nr)))\n\t\t\t\tcontinue;\n\t\t\tdata->in_high[nr] = f71805f_read8(data,\n\t\t\t\t\t    F71805F_REG_IN_HIGH(nr));\n\t\t\tdata->in_low[nr] = f71805f_read8(data,\n\t\t\t\t\t   F71805F_REG_IN_LOW(nr));\n\t\t}\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tdata->fan_low[nr] = f71805f_read16(data,\n\t\t\t\t\t    F71805F_REG_FAN_LOW(nr));\n\t\t\tdata->fan_target[nr] = f71805f_read16(data,\n\t\t\t\t\t       F71805F_REG_FAN_TARGET(nr));\n\t\t\tdata->pwm_freq[nr] = f71805f_read8(data,\n\t\t\t\t\t     F71805F_REG_PWM_FREQ(nr));\n\t\t}\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tdata->temp_high[nr] = f71805f_read8(data,\n\t\t\t\t\t      F71805F_REG_TEMP_HIGH(nr));\n\t\t\tdata->temp_hyst[nr] = f71805f_read8(data,\n\t\t\t\t\t      F71805F_REG_TEMP_HYST(nr));\n\t\t}\n\t\tdata->temp_mode = f71805f_read8(data, F71805F_REG_TEMP_MODE);\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tfor (apnr = 0; apnr < 3; apnr++) {\n\t\t\t\tdata->auto_points[nr].temp[apnr] =\n\t\t\t\t\tf71805f_read8(data,\n\t\t\t\t\tF71805F_REG_PWM_AUTO_POINT_TEMP(nr,\n\t\t\t\t\t\t\t\t\tapnr));\n\t\t\t\tdata->auto_points[nr].fan[apnr] =\n\t\t\t\t\tf71805f_read16(data,\n\t\t\t\t\tF71805F_REG_PWM_AUTO_POINT_FAN(nr,\n\t\t\t\t\t\t\t\t       apnr));\n\t\t\t}\n\t\t}\n\t\tdata->last_limits = jiffies;\n\t}\n\t/* Measurement registers cache is refreshed after 1 second */\n\tif (time_after(jiffies, data->last_updated + HZ)\n\t || !data->valid) {\n\t\tfor (nr = 0; nr < 11; nr++) {\n\t\t\tif (!(data->has_in & (1 << nr)))\n\t\t\t\tcontinue;\n\t\t\tdata->in[nr] = f71805f_read8(data,\n\t\t\t\t       F71805F_REG_IN(nr));\n\t\t}\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tdata->fan[nr] = f71805f_read16(data,\n\t\t\t\t\tF71805F_REG_FAN(nr));\n\t\t\tdata->fan_ctrl[nr] = f71805f_read8(data,\n\t\t\t\t\t     F71805F_REG_FAN_CTRL(nr));\n\t\t\tdata->pwm[nr] = f71805f_read8(data,\n\t\t\t\t\tF71805F_REG_PWM_DUTY(nr));\n\t\t}\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tdata->temp[nr] = f71805f_read8(data,\n\t\t\t\t\t F71805F_REG_TEMP(nr));\n\t\t}\n\t\tdata->alarms = f71805f_read8(data, F71805F_REG_STATUS(0))\n\t\t\t+ (f71805f_read8(data, F71805F_REG_STATUS(1)) << 8)\n\t\t\t+ (f71805f_read8(data, F71805F_REG_STATUS(2)) << 16);\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = 1;\n\t}\n\tmutex_unlock(&data->update_lock);\n\treturn data;\n"]], "pred": {"ppl": 1.3878252506256104, "ppl_lower": 1.4287046194076538, "ppl/lowercase_ppl": -1.0885775321045386, "ppl/zlib": 0.0004862580920369224, "Min_5.0% Prob": 4.753087242444356, "Min_10.0% Prob": 2.9624796655832553, "Min_20.0% Prob": 1.6090772940466802, "Min_30.0% Prob": 1.0903690796942005, "Min_40.0% Prob": 0.818685556213146, "Min_50.0% Prob": 0.6558812193011176, "Min_60.0% Prob": 0.546883496435955}}
{"hexsha": "ef1571ef0753a638cfdedef0d904069aa73b75cd", "ext": "c", "lang": "C", "content": "static int UartMon_readPolling(UART_Handle handle, void *buffer, size_t size)\n{\n    UartMon_Object *obj = handle->object;\n\n    int bytes_read = UART_readPolling(obj->hUart_in, buffer, size);\n    if (bytes_read > 0) {\n        /* We should forward with polling functionality too, since this function\n         * may be called while interrupts are disabled\n         */\n        UART_writePolling(obj->hUart_debug, buffer, bytes_read);\n    }\n    return bytes_read;\n}", "item_id": 3, "repo": "mdlewisfb/OpenCellular", "file": "firmware/ec/src/devices/uart/UartMon.c", "last_update_at": "2018-10-25T20:06:51+00:00", "question_id": "ef1571ef0753a638cfdedef0d904069aa73b75cd_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int UartMon_readPolling(UART_Handle handle, void *buffer, size_t size)\n{\n    UartMon_Object *obj = handle->object;\n    int bytes_read = UART_readPolling(obj->hUart_in, buffer, size);\n    if (bytes_read > 0) {\n        /* We should forward with polling functionality too, since this function\n         * may be called while interrupts are disabled\n         */\n        UART_writePolling(obj->hUart_debug, buffer, bytes_read);\n    }\n    return bytes_read;\n"]], "pred": {"ppl": 3.7198894023895264, "ppl_lower": 3.992525577545166, "ppl/lowercase_ppl": -1.0538406002903393, "ppl/zlib": 0.005033310104607831, "Min_5.0% Prob": 8.525780950273786, "Min_10.0% Prob": 6.953209366117205, "Min_20.0% Prob": 5.086885801383427, "Min_30.0% Prob": 3.9290749777195066, "Min_40.0% Prob": 3.17668490660818, "Min_50.0% Prob": 2.58976382162008, "Min_60.0% Prob": 2.1902805747854157}}
{"hexsha": "c886a8cb0ed9d168be8fd96a1a5e0317bf0fc3fe", "ext": "c", "lang": "C", "content": "bool ica_at_complianceTest(uint8_t *at_cmd, int16_t at_cmd_len)\n{\n    bool        ret = true;\n    uint8_t     idx;\n\n    if (at_cmd_len == (strlen(LORA_AT_CTEST) + 2) &&\n        strcmp(&at_cmd[strlen(LORA_AT_CTEST)], \"=?\") == 0) {\n        snprintf(atcmd, ATCMD_SIZE,\n                 \"\\r\\n%s:[idx]\\r\\n\", LORA_AT_CTEST);\n    } else if (at_cmd_len >= (strlen(LORA_AT_CTEST) + 2) &&\n               at_cmd[strlen(LORA_AT_CTEST)] == '=') {\n        idx = strtol(&at_cmd[strlen(LORA_AT_CTEST) + 1], NULL, 16);\n        ret = lora_compliance_test(idx);\n        if (ret == true) {\n            snprintf(atcmd, ATCMD_SIZE, \"\\r\\nOK\\r\\n\");\n        }\n    } else {\n        ret = false;\n    }\n\n    return ret;\n}", "item_id": 41, "repo": "HelloAllen8893/AliOS-Things", "file": "components/wireless/lorawan/lorawan_4_4_2/linkwan/linkwan_ica_at.c", "last_update_at": "2018-11-28T03:19:22+00:00", "question_id": "c886a8cb0ed9d168be8fd96a1a5e0317bf0fc3fe_41", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool ica_at_complianceTest(uint8_t *at_cmd, int16_t at_cmd_len)\n{\n    bool        ret = true;\n    uint8_t     idx;\n    if (at_cmd_len == (strlen(LORA_AT_CTEST) + 2) &&\n        strcmp(&at_cmd[strlen(LORA_AT_CTEST)], \"=?\") == 0) {\n        snprintf(atcmd, ATCMD_SIZE,\n                 \"\\r\\n%s:[idx]\\r\\n\", LORA_AT_CTEST);\n    } else if (at_cmd_len >= (strlen(LORA_AT_CTEST) + 2) &&\n               at_cmd[strlen(LORA_AT_CTEST)] == '=') {\n        idx = strtol(&at_cmd[strlen(LORA_AT_CTEST) + 1], NULL, 16);\n        ret = lora_compliance_test(idx);\n        if (ret == true) {\n            snprintf(atcmd, ATCMD_SIZE, \"\\r\\nOK\\r\\n\");\n        }\n    } else {\n        ret = false;\n    }\n    return ret;\n"]], "pred": {"ppl": 2.2141218185424805, "ppl_lower": 2.4065208435058594, "ppl/lowercase_ppl": -1.1048318583417387, "ppl/zlib": 0.0025476149189039557, "Min_5.0% Prob": 7.59739875793457, "Min_10.0% Prob": 5.4412832490859495, "Min_20.0% Prob": 3.550575581289107, "Min_30.0% Prob": 2.567806706954074, "Min_40.0% Prob": 1.9746973133015056, "Min_50.0% Prob": 1.590617921972467, "Min_60.0% Prob": 1.3281500890039868}}
{"hexsha": "aaa17f4d65b538f54670a5d2213ae24f45955977", "ext": "c", "lang": "C", "content": "err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg)\n{\n\terr_t err = ERR_OK;\n\tu8_t first_msg = 0;\n\tu32_t tmp = 0;\n\tsys_arch_sem_wait(&(mbox->mutex), 0);\n\n\tLWIP_DEBUGF(SYS_DEBUG, (\"mbox %p msg %p\\n\", (void *)mbox, (void *)msg));\n\t/* Check if the queue is full */\n\ttmp = (mbox->rear + 1) % mbox->queue_size;\n\tif (tmp == mbox->front) {\n\t\tLWIP_DEBUGF(SYS_DEBUG, (\"Queue Full, returning error\\n\"));\n\t\terr = ERR_MEM;\n\t\tgoto errout_with_mutex;\n\t}\n\n\tif (mbox->rear == mbox->front) {\n\t\tfirst_msg = 1;\n\t} else {\n\t\tfirst_msg = 0;\n\t}\n\n\tmbox->rear = tmp;\n\tmbox->msgs[mbox->rear] = msg;\n\tLWIP_DEBUGF(SYS_DEBUG, (\"Post SUCCESS\\n\"));\n\n\t/* If msg was posted to an empty queue, Release semaphore for\n\t   some fetch api blocked on this sem due to Empty queue. */\n\tif (first_msg && mbox->wait_fetch) {\n\t\tsys_sem_signal(&(mbox->mail));\n\t}\n\nerrout_with_mutex:\n\tsys_sem_signal(&(mbox->mutex));\n\n\treturn err;\n}", "item_id": 2, "repo": "chhee66/TizenRT", "file": "os/net/lwip/sys/arch/sys_arch.c", "last_update_at": "2018-04-23T12:39:01+00:00", "question_id": "aaa17f4d65b538f54670a5d2213ae24f45955977_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg)\n{\n\terr_t err = ERR_OK;\n\tu8_t first_msg = 0;\n\tu32_t tmp = 0;\n\tsys_arch_sem_wait(&(mbox->mutex), 0);\n\tLWIP_DEBUGF(SYS_DEBUG, (\"mbox %p msg %p\\n\", (void *)mbox, (void *)msg));\n\t/* Check if the queue is full */\n\ttmp = (mbox->rear + 1) % mbox->queue_size;\n\tif (tmp == mbox->front) {\n\t\tLWIP_DEBUGF(SYS_DEBUG, (\"Queue Full, returning error\\n\"));\n\t\terr = ERR_MEM;\n\t\tgoto errout_with_mutex;\n\t}\n\tif (mbox->rear == mbox->front) {\n\t\tfirst_msg = 1;\n\t} else {\n\t\tfirst_msg = 0;\n\t}\n\tmbox->rear = tmp;\n\tmbox->msgs[mbox->rear] = msg;\n\tLWIP_DEBUGF(SYS_DEBUG, (\"Post SUCCESS\\n\"));\n\t/* If msg was posted to an empty queue, Release semaphore for\n\t   some fetch api blocked on this sem due to Empty queue. */\n\tif (first_msg && mbox->wait_fetch) {\n\t\tsys_sem_signal(&(mbox->mail));\n\t}\nerrout_with_mutex:\n\tsys_sem_signal(&(mbox->mutex));\n\treturn err;\n"]], "pred": {"ppl": 2.3509976863861084, "ppl_lower": 2.455556869506836, "ppl/lowercase_ppl": -1.0509028493538872, "ppl/zlib": 0.001842327123835482, "Min_5.0% Prob": 7.603036755009701, "Min_10.0% Prob": 5.453170568515093, "Min_20.0% Prob": 3.6869243006163006, "Min_30.0% Prob": 2.7120783173737406, "Min_40.0% Prob": 2.1208436544748803, "Min_50.0% Prob": 1.7076045710480574, "Min_60.0% Prob": 1.4243239359930158}}
{"hexsha": "165f7a45f3f88921bc4ed5ca5698e6c5c6d26fb8", "ext": "c", "lang": "C", "content": "static int MmalGraph_init(MmalGraphObject *self, PyObject *args, PyObject *kwds) {\n\n\tint display = -1;\n\tstatic char *kwlist[] = {\"display\", NULL};\n\n\tif (!PyArg_ParseTupleAndKeywords(args, kwds, \"|i\", kwlist, &display)) {\n\n\t\treturn -1;\n\t}\n\n\tif (display >= 0) {\n\n\t\tself->display_num = display;\n\t}\n\n\treturn 0;\n}", "item_id": 3, "repo": "amaork/pylibmmal", "file": "src/mmal_graph.c", "last_update_at": "2018-12-11T18:41:59+00:00", "question_id": "165f7a45f3f88921bc4ed5ca5698e6c5c6d26fb8_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int MmalGraph_init(MmalGraphObject *self, PyObject *args, PyObject *kwds) {\n\tint display = -1;\n\tstatic char *kwlist[] = {\"display\", NULL};\n\tif (!PyArg_ParseTupleAndKeywords(args, kwds, \"|i\", kwlist, &display)) {\n\t\treturn -1;\n\t}\n\tif (display >= 0) {\n\t\tself->display_num = display;\n\t}\n\treturn 0;\n"]], "pred": {"ppl": 2.300604820251465, "ppl_lower": 3.3229258060455322, "ppl/lowercase_ppl": -1.4412937356695128, "ppl/zlib": 0.004084176733786797, "Min_5.0% Prob": 9.070242484410604, "Min_10.0% Prob": 6.188736617565155, "Min_20.0% Prob": 3.8119532251358033, "Min_30.0% Prob": 2.663532281392499, "Min_40.0% Prob": 2.073105629980564, "Min_50.0% Prob": 1.6656305396131106, "Min_60.0% Prob": 1.3881236353251887}}
{"hexsha": "b85ba71a6f77e974d82ccdd635109f36d0ddaac8", "ext": "h", "lang": "C", "content": "static int\nremoteDomainRestore(virConnectPtr conn, const char *from)\n{\n    int rv = -1;\n    struct private_data *priv = conn->privateData;\n    remote_domain_restore_args args;\n\n    remoteDriverLock(priv);\n\n    args.from = (char *)from;\n\n    if (call(conn, priv, 0, REMOTE_PROC_DOMAIN_RESTORE,\n             (xdrproc_t)xdr_remote_domain_restore_args, (char *)&args,\n             (xdrproc_t)xdr_void, (char *)NULL) == -1) {\n        goto done;\n    }\n\n    rv = 0;\n\ndone:\n    remoteDriverUnlock(priv);\n    return rv;\n}", "item_id": 97, "repo": "SIIS-cloud/pileus", "file": "libvirt/pileus-libvirt-1.2.12/src/remote/remote_client_bodies.h", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "b85ba71a6f77e974d82ccdd635109f36d0ddaac8_97", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nremoteDomainRestore(virConnectPtr conn, const char *from)\n{\n    int rv = -1;\n    struct private_data *priv = conn->privateData;\n    remote_domain_restore_args args;\n    remoteDriverLock(priv);\n    args.from = (char *)from;\n    if (call(conn, priv, 0, REMOTE_PROC_DOMAIN_RESTORE,\n             (xdrproc_t)xdr_remote_domain_restore_args, (char *)&args,\n             (xdrproc_t)xdr_void, (char *)NULL) == -1) {\n        goto done;\n    }\n    rv = 0;\ndone:\n    remoteDriverUnlock(priv);\n    return rv;\n"]], "pred": {"ppl": 1.968609094619751, "ppl_lower": 3.131258487701416, "ppl/lowercase_ppl": -1.6852045985406732, "ppl/zlib": 0.0024018696810059847, "Min_5.0% Prob": 6.186479727427165, "Min_10.0% Prob": 4.337644275866057, "Min_20.0% Prob": 2.974997957547506, "Min_30.0% Prob": 2.209014754357009, "Min_40.0% Prob": 1.6910060436870806, "Min_50.0% Prob": 1.35267411247466, "Min_60.0% Prob": 1.1341684252147077}}
{"hexsha": "bbd97466b6d9cca41438ea793ee4772a2366211a", "ext": "c", "lang": "C", "content": "void Manage_Series(REBSER *series)\n/*\n**\t\tWhen a series is first created, it is in a state of being\n**\t\tmanually memory managed.  Thus, you can call Free_Series on\n**\t\tit if you are sure you do not need it.  This will transition\n**\t\ta manually managed series to be one managed by the GC.  There\n**\t\tis no way to transition it back--once a series has become\n**\t\tmanaged, only the GC can free it.\n**\n**\t\tAll series that wind up in user-visible values *must* be\n**\t\tmanaged, because the user can make copies of values\n**\t\tcontaining that series.  When these copies are made, it's\n**\t\tno longer safe to assume it's okay to free the original.\n**\n***********************************************************************/\n{\n\tREBSER ** const last_ptr\n\t\t= &cast(REBSER**, GC_Manuals->data)[GC_Manuals->tail - 1];\n\n\tassert(!SERIES_GET_FLAG(series, SER_MANAGED));\n\tSERIES_SET_FLAG(series, SER_MANAGED);\n\n\t// Note: Code repeated in Free_Series()\n\tassert(GC_Manuals->tail >= 1);\n\tif (*last_ptr != series) {\n\t\t// If the series is not the last manually added series, then\n\t\t// find where it is, then move the last manually added series\n\t\t// to that position to preserve it when we chop off the tail\n\t\t// (instead of keeping the series we want to free).\n\t\tREBSER **current_ptr = last_ptr - 1;\n\t\twhile (*current_ptr != series) {\n\t\t\tassert(current_ptr > cast(REBSER**, GC_Manuals->data));\n\t\t\t--current_ptr;\n\t\t}\n\t\t*current_ptr = *last_ptr;\n\t}\n\tGC_Manuals->tail--; // !!! Should it ever shrink or save memory?\n}", "item_id": 16, "repo": "codebybrett/rebol-source-scripting", "file": "201508-source-format-change/install-20151015-source-scanner/core/m-pools.c", "last_update_at": "2018-03-30T15:45:16+00:00", "question_id": "bbd97466b6d9cca41438ea793ee4772a2366211a_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void Manage_Series(REBSER *series)\n/*\n**\t\tWhen a series is first created, it is in a state of being\n**\t\tmanually memory managed.  Thus, you can call Free_Series on\n**\t\tit if you are sure you do not need it.  This will transition\n**\t\ta manually managed series to be one managed by the GC.  There\n**\t\tis no way to transition it back--once a series has become\n**\t\tmanaged, only the GC can free it.\n**\n**\t\tAll series that wind up in user-visible values *must* be\n**\t\tmanaged, because the user can make copies of values\n**\t\tcontaining that series.  When these copies are made, it's\n**\t\tno longer safe to assume it's okay to free the original.\n**\n***********************************************************************/\n{\n\tREBSER ** const last_ptr\n\t\t= &cast(REBSER**, GC_Manuals->data)[GC_Manuals->tail - 1];\n\tassert(!SERIES_GET_FLAG(series, SER_MANAGED));\n\tSERIES_SET_FLAG(series, SER_MANAGED);\n\t// Note: Code repeated in Free_Series()\n\tassert(GC_Manuals->tail >= 1);\n\tif (*last_ptr != series) {\n\t\t// If the series is not the last manually added series, then\n\t\t// find where it is, then move the last manually added series\n\t\t// to that position to preserve it when we chop off the tail\n\t\t// (instead of keeping the series we want to free).\n\t\tREBSER **current_ptr = last_ptr - 1;\n\t\twhile (*current_ptr != series) {\n\t\t\tassert(current_ptr > cast(REBSER**, GC_Manuals->data));\n\t\t\t--current_ptr;\n\t\t}\n\t\t*current_ptr = *last_ptr;\n\t}\n\tGC_Manuals->tail--; // !!! Should it ever shrink or save memory?\n"]], "pred": {"ppl": 4.074306488037109, "ppl_lower": 4.665841102600098, "ppl/lowercase_ppl": -1.096509945801539, "ppl/zlib": 0.002018247909805488, "Min_5.0% Prob": 7.649015525976817, "Min_10.0% Prob": 6.436936428149541, "Min_20.0% Prob": 4.9610311075584175, "Min_30.0% Prob": 4.00560947885252, "Min_40.0% Prob": 3.2958347681241156, "Min_50.0% Prob": 2.747398025432571, "Min_60.0% Prob": 2.3270932003703133}}
{"hexsha": "88f885a5092d38d9d5352b5897953a1b37fe7fb4", "ext": "c", "lang": "C", "content": "void generic_sendmsg (const char *fmt, ...)\n{\n\tva_list ap;\n\tfprintf(outstream, \"@\");\n\tva_start(ap, fmt);\n\tvfprintf(outstream, fmt, ap);\n\tva_end(ap);\n\tfprintf(outstream, \"\\n\");\n}", "item_id": 0, "repo": "svenskan/pronunciation", "file": "vendor/mpg123/src/control_generic.c", "last_update_at": "2018-04-25T22:29:34+00:00", "question_id": "88f885a5092d38d9d5352b5897953a1b37fe7fb4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void generic_sendmsg (const char *fmt, ...)\n{\n\tva_list ap;\n\tfprintf(outstream, \"@\");\n\tva_start(ap, fmt);\n\tvfprintf(outstream, fmt, ap);\n\tva_end(ap);\n\tfprintf(outstream, \"\\n\");\n"]], "pred": {"ppl": 2.962195873260498, "ppl_lower": 2.962195873260498, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.008757506793358476, "Min_5.0% Prob": 8.924100240071615, "Min_10.0% Prob": 7.186352593558175, "Min_20.0% Prob": 4.835099109013876, "Min_30.0% Prob": 3.515997439622879, "Min_40.0% Prob": 2.673828687767188, "Min_50.0% Prob": 2.1903170909027794, "Min_60.0% Prob": 1.8074845409641662}}
{"hexsha": "e9fc79c40cef53289f1618b9bcae35720f39d765", "ext": "c", "lang": "C", "content": "YY_RULE(int) yy_range()\n{  int yypos0= yypos, yythunkpos0= yythunkpos;\n  yyprintf((stderr, \"%s\\n\", \"range\"));\n  {  int yypos21= yypos, yythunkpos21= yythunkpos;  if (!yy_char()) goto l22;  if (!yymatchChar('-')) goto l22;  if (!yy_char()) goto l22;  goto l21;\n  l22:;\t  yypos= yypos21; yythunkpos= yythunkpos21;  if (!yy_char()) goto l20;\n  }\n  l21:;\t\n  yyprintf((stderr, \"  ok   %s @ %s\\n\", \"range\", yybuf+yypos));\n  return 1;\n  l20:;\t  yypos= yypos0; yythunkpos= yythunkpos0;\n  yyprintf((stderr, \"  fail %s @ %s\\n\", \"range\", yybuf+yypos));\n  return 0;\n}", "item_id": 34, "repo": "r-lyeh/scriptorium", "file": "ruby/tinyrb-ist/vendor/peg/leg.c", "last_update_at": "2018-01-08T03:02:37+00:00", "question_id": "e9fc79c40cef53289f1618b9bcae35720f39d765_34", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["YY_RULE(int) yy_range()\n{  int yypos0= yypos, yythunkpos0= yythunkpos;\n  yyprintf((stderr, \"%s\\n\", \"range\"));\n  {  int yypos21= yypos, yythunkpos21= yythunkpos;  if (!yy_char()) goto l22;  if (!yymatchChar('-')) goto l22;  if (!yy_char()) goto l22;  goto l21;\n  l22:;\t  yypos= yypos21; yythunkpos= yythunkpos21;  if (!yy_char()) goto l20;\n  }\n  l21:;\t\n  yyprintf((stderr, \"  ok   %s @ %s\\n\", \"range\", yybuf+yypos));\n  return 1;\n  l20:;\t  yypos= yypos0; yythunkpos= yythunkpos0;\n  yyprintf((stderr, \"  fail %s @ %s\\n\", \"range\", yybuf+yypos));\n  return 0;\n"]], "pred": {"ppl": 1.319875717163086, "ppl_lower": 1.4400049448013306, "ppl/lowercase_ppl": -1.3138636916882538, "ppl/zlib": 0.0012172700811456847, "Min_5.0% Prob": 4.48805798803057, "Min_10.0% Prob": 2.6454750203660558, "Min_20.0% Prob": 1.387118990091901, "Min_30.0% Prob": 0.9311085248279364, "Min_40.0% Prob": 0.6971889987233622, "Min_50.0% Prob": 0.5569538408302227, "Min_60.0% Prob": 0.4636230234222544}}
{"hexsha": "e7ec6e86c60a44ef3c227784777a281297d77697", "ext": "c", "lang": "C", "content": "int setConnTimeout(int conn_timeout){\n  if (conn_timeout <= 0) {\n    Log(ERROR, \"Connection timout must be greater than zero\");\n    sprintf(NpsErrDesc, \"%s\", \"Connection timout must be greater than zero\");\n    return -1;\n  }\n  NpsConnTimeout=conn_timeout;\n  return 0;\n}", "item_id": 1, "repo": "Ingenico-NPS-Latam/nps-sdk-c", "file": "npsSdk.c", "last_update_at": "2018-05-31T17:55:31+00:00", "question_id": "e7ec6e86c60a44ef3c227784777a281297d77697_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int setConnTimeout(int conn_timeout){\n  if (conn_timeout <= 0) {\n    Log(ERROR, \"Connection timout must be greater than zero\");\n    sprintf(NpsErrDesc, \"%s\", \"Connection timout must be greater than zero\");\n    return -1;\n  }\n  NpsConnTimeout=conn_timeout;\n  return 0;\n"]], "pred": {"ppl": 3.859891414642334, "ppl_lower": 4.218082904815674, "ppl/lowercase_ppl": -1.06570347908144, "ppl/zlib": 0.008494585233706808, "Min_5.0% Prob": 8.553868770599365, "Min_10.0% Prob": 7.08139165242513, "Min_20.0% Prob": 5.0927854379018145, "Min_30.0% Prob": 4.042436648298193, "Min_40.0% Prob": 3.2556172725227146, "Min_50.0% Prob": 2.665772517853313, "Min_60.0% Prob": 2.24994987718485}}
{"hexsha": "3d1a1307259533a4e9010bd1bc617353da07e815", "ext": "h", "lang": "C", "content": "NS_SCRIPTABLE nsIRDFXMLParser : public nsISupports {\n public: \n\n  NS_DECLARE_STATIC_IID_ACCESSOR(NS_IRDFXMLPARSER_IID)\n\n  /**\n     * Create a stream listener that can be used to asynchronously\n     * parse RDF/XML.\n     * @param aSink the RDF datasource the will receive the data\n     * @param aBaseURI the base URI used to resolve relative\n     *   references in the RDF/XML\n     * @return an nsIStreamListener object to handle the data\n     */\n  /* nsIStreamListener parseAsync (in nsIRDFDataSource aSink, in nsIURI aBaseURI); */\n  NS_SCRIPTABLE NS_IMETHOD ParseAsync(nsIRDFDataSource *aSink, nsIURI *aBaseURI, nsIStreamListener **_retval NS_OUTPARAM) = 0;\n\n  /**\n     * Parse a string of RDF/XML\n     * @param aSink the RDF datasource that will receive the data\n     * @param aBaseURI the base URI used to resolve relative\n     *   references in the RDF/XML\n     * @param aSource a UTF8 string containing RDF/XML data.\n     */\n  /* void parseString (in nsIRDFDataSource aSink, in nsIURI aBaseURI, in AUTF8String aSource); */\n  NS_SCRIPTABLE NS_IMETHOD ParseString(nsIRDFDataSource *aSink, nsIURI *aBaseURI, const nsACString & aSource) = 0;\n\n}", "item_id": 0, "repo": "akiellor/selenium", "file": "third_party/gecko-2/mac/include/nsIRDFXMLParser.h", "last_update_at": "2018-08-24T18:01:34+00:00", "question_id": "3d1a1307259533a4e9010bd1bc617353da07e815_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["NS_SCRIPTABLE nsIRDFXMLParser : public nsISupports {\n public: \n  NS_DECLARE_STATIC_IID_ACCESSOR(NS_IRDFXMLPARSER_IID)\n  /**\n     * Create a stream listener that can be used to asynchronously\n     * parse RDF/XML.\n     * @param aSink the RDF datasource the will receive the data\n     * @param aBaseURI the base URI used to resolve relative\n     *   references in the RDF/XML\n     * @return an nsIStreamListener object to handle the data\n     */\n  /* nsIStreamListener parseAsync (in nsIRDFDataSource aSink, in nsIURI aBaseURI); */\n  NS_SCRIPTABLE NS_IMETHOD ParseAsync(nsIRDFDataSource *aSink, nsIURI *aBaseURI, nsIStreamListener **_retval NS_OUTPARAM) = 0;\n  /**\n     * Parse a string of RDF/XML\n     * @param aSink the RDF datasource that will receive the data\n     * @param aBaseURI the base URI used to resolve relative\n     *   references in the RDF/XML\n     * @param aSource a UTF8 string containing RDF/XML data.\n     */\n  /* void parseString (in nsIRDFDataSource aSink, in nsIURI aBaseURI, in AUTF8String aSource); */\n  NS_SCRIPTABLE NS_IMETHOD ParseString(nsIRDFDataSource *aSink, nsIURI *aBaseURI, const nsACString & aSource) = 0;\n"]], "pred": {"ppl": 1.7119016647338867, "ppl_lower": 3.2399094104766846, "ppl/lowercase_ppl": -2.1866346584704552, "ppl/zlib": 0.0011973381675862219, "Min_5.0% Prob": 5.524738219049242, "Min_10.0% Prob": 3.9399372403686113, "Min_20.0% Prob": 2.545226052602132, "Min_30.0% Prob": 1.7875051826106763, "Min_40.0% Prob": 1.3468311089430227, "Min_50.0% Prob": 1.0774979746060338, "Min_60.0% Prob": 0.8975005652860631}}
{"hexsha": "154e35644c750239d8b26b3b469042a5d1d97c5a", "ext": "c", "lang": "C", "content": "TEST_FUNCTION(wsio_dowork_with_NULL_handle_does_nothing)\n{\n    // arrange\n\n    // act\n    wsio_get_interface_description()->concrete_io_dowork(NULL);\n\n    // assert\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n}", "item_id": 49, "repo": "InfiniteYuan1/gprs_a9_azure", "file": "libs/azure/src/c-utility/tests/wsio_ut/wsio_ut.c", "last_update_at": "2018-03-17T00:26:14+00:00", "question_id": "154e35644c750239d8b26b3b469042a5d1d97c5a_49", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["TEST_FUNCTION(wsio_dowork_with_NULL_handle_does_nothing)\n{\n    // arrange\n    // act\n    wsio_get_interface_description()->concrete_io_dowork(NULL);\n    // assert\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n"]], "pred": {"ppl": 2.130929708480835, "ppl_lower": 3.272770404815674, "ppl/lowercase_ppl": -1.567145240862908, "ppl/zlib": 0.004089504688352728, "Min_5.0% Prob": 8.816530418395995, "Min_10.0% Prob": 6.3699760913848875, "Min_20.0% Prob": 3.6646949648857117, "Min_30.0% Prob": 2.534600525854095, "Min_40.0% Prob": 1.886719878408171, "Min_50.0% Prob": 1.5267226131579195, "Min_60.0% Prob": 1.2607733205363656}}
{"hexsha": "168b79695ed5d43bcb40a595fde3d855454980fa", "ext": "h", "lang": "C", "content": "static void sigchld(int, siginfo_t* sinfo, void*)\n    {\n        assert(sinfo);\n        assert(sinfo->si_signo == SIGCHLD);\n        int status = 0;\n        ext::hash_set<pid_t>::iterator i = children_.find(sinfo->si_pid);\n\n        switch (sinfo->si_code)\n        {\n        case CLD_EXITED:\n        case CLD_KILLED:\n        case CLD_DUMPED:\n        #if DEBUG\n            std::clog << __func__<< \": si_pid=\" << sinfo->si_pid;\n            std::clog << \" si_code=\" << sinfo->si_code << std::endl;\n        #endif\n            if (i != children_.end())\n            {\n                children_.erase(i);\n                waitpid(sinfo->si_pid, &status, 0);\n            }\n            break;\n        }\n    }", "item_id": 0, "repo": "cristivlas/zerobugs", "file": "server/forked_server.h", "last_update_at": "2018-06-24T16:15:19+00:00", "question_id": "168b79695ed5d43bcb40a595fde3d855454980fa_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void sigchld(int, siginfo_t* sinfo, void*)\n    {\n        assert(sinfo);\n        assert(sinfo->si_signo == SIGCHLD);\n        int status = 0;\n        ext::hash_set<pid_t>::iterator i = children_.find(sinfo->si_pid);\n        switch (sinfo->si_code)\n        {\n        case CLD_EXITED:\n        case CLD_KILLED:\n        case CLD_DUMPED:\n        #if DEBUG\n            std::clog << __func__<< \": si_pid=\" << sinfo->si_pid;\n            std::clog << \" si_code=\" << sinfo->si_code << std::endl;\n        #endif\n            if (i != children_.end())\n            {\n                children_.erase(i);\n                waitpid(sinfo->si_pid, &status, 0);\n            }\n            break;\n        }\n"]], "pred": {"ppl": 2.0815985202789307, "ppl_lower": 2.383922576904297, "ppl/lowercase_ppl": -1.1849740468546957, "ppl/zlib": 0.0023200510060705833, "Min_5.0% Prob": 7.301494641737505, "Min_10.0% Prob": 5.1541097993436065, "Min_20.0% Prob": 3.3502176455829455, "Min_30.0% Prob": 2.3750661185809543, "Min_40.0% Prob": 1.8287499162458605, "Min_50.0% Prob": 1.4619377312592716, "Min_60.0% Prob": 1.2242211099647518}}
{"hexsha": "087acf4d89284af5607acd0152ce721584243ba5", "ext": "c", "lang": "C", "content": "int perl_eval(const char *code, char **result) {\n  SV* ret_sv = eval_pv(code, FALSE);\n  if (SvTRUE(ERRSV))\n  {\n    STRLEN len;\n    char *errmsg = SvPV(ERRSV, len);\n    *result = eperl_alloc(len+1);\n    memcpy(*result, errmsg, len+1);\n    return 0;\n  } else if (result != NULL) {\n    sv_to_json(ret_sv, result);\n  }\n  return 1;\n}", "item_id": 5, "repo": "waisbrot/erlang_perl", "file": "c_src/perl_drv.c", "last_update_at": "2018-06-02T18:47:17+00:00", "question_id": "087acf4d89284af5607acd0152ce721584243ba5_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int perl_eval(const char *code, char **result) {\n  SV* ret_sv = eval_pv(code, FALSE);\n  if (SvTRUE(ERRSV))\n  {\n    STRLEN len;\n    char *errmsg = SvPV(ERRSV, len);\n    *result = eperl_alloc(len+1);\n    memcpy(*result, errmsg, len+1);\n    return 0;\n  } else if (result != NULL) {\n    sv_to_json(ret_sv, result);\n  }\n  return 1;\n"]], "pred": {"ppl": 2.6668930053710938, "ppl_lower": 3.92248797416687, "ppl/lowercase_ppl": -1.3933188471283433, "ppl/zlib": 0.004605230640488434, "Min_5.0% Prob": 7.769610325495402, "Min_10.0% Prob": 5.622075190910926, "Min_20.0% Prob": 4.005353901121351, "Min_30.0% Prob": 3.038462776963304, "Min_40.0% Prob": 2.3973229473287407, "Min_50.0% Prob": 1.9509333983279658, "Min_60.0% Prob": 1.636206710150084}}
{"hexsha": "01bd50efd8cfcab981b9784c6335cc672a115272", "ext": "h", "lang": "C", "content": "class AppObject \r\n{\r\npublic:\r\n\tAppObject() :  mesh(NULL),  cage(NULL), meshSelection(NULL), \r\n\t\t hasSdfFacets(false), refCount(new int(1)), m_myWo(NULL)\r\n\t{\r\n\t\t//fileSeparator = \"\\\\\";\r\n\t}\r\n\r\n\tvoid unloadMesh();\r\n\t\t\r\n\t~AppObject() \r\n\t{\r\n\t\t--(*refCount);\r\n\t\tif (*refCount == 0)\r\n\t\t{\r\n\t\t\tdelete mesh;\r\n\t\t\tdelete cage;\r\n\t\t\tdelete meshSelection;\r\n\t\t\tdelete refCount;\r\n\t\t}\r\n\t}", "item_id": 0, "repo": "hsiaoairplane/3d-watermark-lsd", "file": "AppObject.h", "last_update_at": "2018-07-20T02:44:11+00:00", "question_id": "01bd50efd8cfcab981b9784c6335cc672a115272_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class AppObject \r\n{\r\npublic:\r\n\tAppObject() :  mesh(NULL),  cage(NULL), meshSelection(NULL), \r\n\t\t hasSdfFacets(false), refCount(new int(1)), m_myWo(NULL)\r\n\t{\r\n\t\t//fileSeparator = \"\\\\\";\r\n\t}\r\n\r\n\tvoid unloadMesh();\r\n\t\t\r\n\t~AppObject() \r\n\t{\r\n\t\t--(*refCount);\r\n\t\tif (*refCount == 0)\r\n\t\t{\r\n\t\t\tdelete mesh;\r\n\t\t\tdelete cage;\r\n\t\t\tdelete meshSelection;\r\n\t\t\tdelete refCount;\r\n\t\t}\r\n"]], "pred": {"ppl": 4.448155879974365, "ppl_lower": 4.857821464538574, "ppl/lowercase_ppl": -1.05902920711838, "ppl/zlib": 0.00657484405855721, "Min_5.0% Prob": 8.923314869403839, "Min_10.0% Prob": 7.979581147432327, "Min_20.0% Prob": 6.167673505842686, "Min_30.0% Prob": 4.673804217328628, "Min_40.0% Prob": 3.6188046904710625, "Min_50.0% Prob": 2.9648932580962595, "Min_60.0% Prob": 2.497712684353602}}
{"hexsha": "15c4552fd1af99b1fdb7d8a2dc39e8abcf921c68", "ext": "c", "lang": "C", "content": "static void files_plugin_start(struct plugin_t * plugin)\n{\n  struct file_server_t * file_server = plugin->data;\n\n  size_t cwd_capacity = 256;\n  char * cwd = malloc(cwd_capacity);\n\n  while (getcwd(cwd, cwd_capacity) == NULL) {\n    cwd_capacity *= 2;\n    cwd = realloc(cwd, cwd_capacity);\n  }\n\n  size_t cwd_length = strlen(cwd);\n\n  if (cwd_length + 1 >= cwd_capacity) {\n    cwd = realloc(cwd, cwd_capacity + 1);\n  }\n\n  cwd_length++;\n  cwd[cwd_length - 1] = '/';\n  cwd[cwd_length] = 0;\n\n  file_server->cwd = cwd;\n  file_server->cwd_length = cwd_length;\n\n  hash_table_init_with_string_keys(&file_server->open_files, open_file_removed_from_hash);\n  file_server->open_files_count = 0;\n\n  void * root = server_config_plugin_get(plugin->config_context, \"push_files\");\n  if (root) {\n    server_config_plugin_each(file_server, root, init_push_file);\n  }\n\n  log_append(plugin->log, LOG_INFO, \"Files plugin started\");\n}", "item_id": 7, "repo": "gregory144/prism-web-server", "file": "src/plugins/files/main.c", "last_update_at": "2018-09-25T05:02:17+00:00", "question_id": "15c4552fd1af99b1fdb7d8a2dc39e8abcf921c68_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void files_plugin_start(struct plugin_t * plugin)\n{\n  struct file_server_t * file_server = plugin->data;\n  size_t cwd_capacity = 256;\n  char * cwd = malloc(cwd_capacity);\n  while (getcwd(cwd, cwd_capacity) == NULL) {\n    cwd_capacity *= 2;\n    cwd = realloc(cwd, cwd_capacity);\n  }\n  size_t cwd_length = strlen(cwd);\n  if (cwd_length + 1 >= cwd_capacity) {\n    cwd = realloc(cwd, cwd_capacity + 1);\n  }\n  cwd_length++;\n  cwd[cwd_length - 1] = '/';\n  cwd[cwd_length] = 0;\n  file_server->cwd = cwd;\n  file_server->cwd_length = cwd_length;\n  hash_table_init_with_string_keys(&file_server->open_files, open_file_removed_from_hash);\n  file_server->open_files_count = 0;\n  void * root = server_config_plugin_get(plugin->config_context, \"push_files\");\n  if (root) {\n    server_config_plugin_each(file_server, root, init_push_file);\n  }\n  log_append(plugin->log, LOG_INFO, \"Files plugin started\");\n"]], "pred": {"ppl": 2.178234338760376, "ppl_lower": 2.3143835067749023, "ppl/lowercase_ppl": -1.077877454155811, "ppl/zlib": 0.0019222583019182448, "Min_5.0% Prob": 6.943034489949544, "Min_10.0% Prob": 5.1401372342496305, "Min_20.0% Prob": 3.3424301767349243, "Min_30.0% Prob": 2.4765660406223367, "Min_40.0% Prob": 1.9209229755401611, "Min_50.0% Prob": 1.5481946680972234, "Min_60.0% Prob": 1.2986691621277067}}
{"hexsha": "6cd6842f459f98b6364b6a9620cda589ecd06443", "ext": "c", "lang": "C", "content": "TSS2_RC\niesys_MU_BYTE_array_Unmarshal(\n    const uint8_t *buffer,\n    size_t size,\n    size_t *offset,\n    size_t count,\n    BYTE *dst)\n{\n    LOG_TRACE(\"called: count=%zu buffer=%p size=%zu offset=%p dst=%p\",\n        count, buffer, size, offset, dst);\n    return_if_null(buffer, \"src=NULL\", TSS2_ESYS_RC_BAD_REFERENCE);\n\n    size_t offset_loc = (offset != NULL)? *offset : 0;\n    if (dst != NULL)\n        memset(dst, 0, sizeof(*dst));\n\n    if (count > size || size - count < offset_loc) {\n        LOG_ERROR(\"not enough space in target buffer\");\n        return TSS2_ESYS_RC_INSUFFICIENT_BUFFER;\n    }\n\n    if (dst != NULL)\n        memcpy(dst, &buffer[offset_loc], count);\n    offset_loc += count;\n\n    if (offset != NULL)\n        *offset = offset_loc;\n    return TSS2_RC_SUCCESS;\n}", "item_id": 1, "repo": "aqinwenky/tpm2-tss", "file": "src/tss2-esys/esys_mu.c", "last_update_at": "2018-04-11T13:56:07+00:00", "question_id": "6cd6842f459f98b6364b6a9620cda589ecd06443_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["TSS2_RC\niesys_MU_BYTE_array_Unmarshal(\n    const uint8_t *buffer,\n    size_t size,\n    size_t *offset,\n    size_t count,\n    BYTE *dst)\n{\n    LOG_TRACE(\"called: count=%zu buffer=%p size=%zu offset=%p dst=%p\",\n        count, buffer, size, offset, dst);\n    return_if_null(buffer, \"src=NULL\", TSS2_ESYS_RC_BAD_REFERENCE);\n    size_t offset_loc = (offset != NULL)? *offset : 0;\n    if (dst != NULL)\n        memset(dst, 0, sizeof(*dst));\n    if (count > size || size - count < offset_loc) {\n        LOG_ERROR(\"not enough space in target buffer\");\n        return TSS2_ESYS_RC_INSUFFICIENT_BUFFER;\n    }\n    if (dst != NULL)\n        memcpy(dst, &buffer[offset_loc], count);\n    offset_loc += count;\n    if (offset != NULL)\n        *offset = offset_loc;\n    return TSS2_RC_SUCCESS;\n"]], "pred": {"ppl": 2.121126890182495, "ppl_lower": 2.4936776161193848, "ppl/lowercase_ppl": -1.2151893261246758, "ppl/zlib": 0.0019231393847393584, "Min_5.0% Prob": 7.362527676991054, "Min_10.0% Prob": 5.375057861722749, "Min_20.0% Prob": 3.319712925765474, "Min_30.0% Prob": 2.43052657998421, "Min_40.0% Prob": 1.8605494266218048, "Min_50.0% Prob": 1.5044956095770103, "Min_60.0% Prob": 1.2520756438995402}}
{"hexsha": "208c69870d617204421aac4073f3cc72fd1bab21", "ext": "c", "lang": "C", "content": "void __gfx_gen_pixels(int c, unsigned int w, unsigned char* pixels)\n{\n\tunsigned int x, y;\n\tuint8_t* fnt = gfx_font();\n\n\tif(c != 0 && w != 0)\n  {\n    for(y = 0; y < gfx_font_height; y++)\n    {\n      for(x = 0; x < gfx_font_width; x++)\n      {\n        if(fnt[c * gfx_font_height + y] >> (7 - x) & 1)\n        {\n          pixels[x + (y * w)] = 1;\n        }\n      }\n    }\n  }\n}", "item_id": 0, "repo": "RelativisticMechanic/stdgfx", "file": "libgfx/gfx_putc.c", "last_update_at": "2018-03-15T10:15:59+00:00", "question_id": "208c69870d617204421aac4073f3cc72fd1bab21_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void __gfx_gen_pixels(int c, unsigned int w, unsigned char* pixels)\n{\n\tunsigned int x, y;\n\tuint8_t* fnt = gfx_font();\n\tif(c != 0 && w != 0)\n  {\n    for(y = 0; y < gfx_font_height; y++)\n    {\n      for(x = 0; x < gfx_font_width; x++)\n      {\n        if(fnt[c * gfx_font_height + y] >> (7 - x) & 1)\n        {\n          pixels[x + (y * w)] = 1;\n        }\n      }\n    }\n  }\n"]], "pred": {"ppl": 2.65700364112854, "ppl_lower": 2.65700364112854, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0046533287484171754, "Min_5.0% Prob": 7.2110196352005005, "Min_10.0% Prob": 5.4782351606032424, "Min_20.0% Prob": 3.7187858784899994, "Min_30.0% Prob": 2.8896417851541556, "Min_40.0% Prob": 2.329609430011581, "Min_50.0% Prob": 1.9079764332882194, "Min_60.0% Prob": 1.6180308312177658}}
{"hexsha": "887339108bfe36faf63e5b4598e4a368dc3af5df", "ext": "c", "lang": "C", "content": "void matrusseV2_2(matrix_t * A, matrix_t * B, matrix_t * C, int k) {\n\n    uint32_t m = A->m;\n    uint32_t blocksize = TAILLE_BLOC;\n    uint32_t l = A->n;\n    uint32_t n = B->nbColonneInt;\n    uint32_t nbits = B->n;\n\n    for (int start = 0; start < m/blocksize; ++start) {\n        //progressBar(start,m/blocksize-1);\n\n        for (int i = 0; i < l/k; ++i) {\n            //alocating table of 2^k * B->nbColonneInt\n            uint64_t * T = malloc((n*sizeof(uint64_t))<<k);\n            matrix_t * Bbloc = getBloc(B, i*k, i+k);\n            fillTable2(T, Bbloc, k, k);\n            for (int s = 0; s < blocksize; ++s) {\n                uint64_t j = start*blocksize + s;\n                int64_t id = extract(A,j, k*i, k);\n                uint64_t * Tline = T+id*n;\n                xorMatrixRow(C, j, Tline);\n            }\n            freeBloc(Bbloc);\n            free(T);\n        }\n\n        int kReste = l%k;\n        if (kReste != 0) {\n            calculResteK(A, B, C, kReste, n, l, blocksize, start*blocksize);\n        }\n    }\n\n    uint32_t blocksizeReste = m%blocksize;\n    if(blocksizeReste != 0) {\n\n        int start = m - blocksizeReste;\n\n        for (int i = 0; i < l/k; ++i) {\n            //alocating table of 2^k * B->nbColonneInt\n            uint64_t * T = malloc((n*sizeof(uint64_t))<<k);\n            matrix_t * Bbloc = getBloc(B, i*k, i+k);\n            fillTable(T, Bbloc, k);\n            for (int s = 0; s < blocksizeReste; ++s) { //scanning throught the last block\n                uint64_t j = start + s;\n                int64_t id = extract(A,j, k*i, k);\n                uint64_t * Tline = T+id*n;\n                xorMatrixRow(C, j, Tline);\n            }\n            free(Bbloc);\n            Bbloc = NULL;\n            free(T);\n            T = NULL;\n        }\n        uint32_t kReste = l%k;\n        if (kReste != 0) {\n            //not multiplying by blocksize because start is already the beginning of the last bloc\n            calculResteK(A, B, C, kReste, n, l, blocksizeReste, start);\n        }\n    }\n}", "item_id": 5, "repo": "Drapsag74/matrusse", "file": "src/fourRussianAlgorithmV2.c", "last_update_at": "2018-12-14T14:37:48+00:00", "question_id": "887339108bfe36faf63e5b4598e4a368dc3af5df_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void matrusseV2_2(matrix_t * A, matrix_t * B, matrix_t * C, int k) {\n    uint32_t m = A->m;\n    uint32_t blocksize = TAILLE_BLOC;\n    uint32_t l = A->n;\n    uint32_t n = B->nbColonneInt;\n    uint32_t nbits = B->n;\n    for (int start = 0; start < m/blocksize; ++start) {\n        //progressBar(start,m/blocksize-1);\n        for (int i = 0; i < l/k; ++i) {\n            //alocating table of 2^k * B->nbColonneInt\n            uint64_t * T = malloc((n*sizeof(uint64_t))<<k);\n            matrix_t * Bbloc = getBloc(B, i*k, i+k);\n            fillTable2(T, Bbloc, k, k);\n            for (int s = 0; s < blocksize; ++s) {\n                uint64_t j = start*blocksize + s;\n                int64_t id = extract(A,j, k*i, k);\n                uint64_t * Tline = T+id*n;\n                xorMatrixRow(C, j, Tline);\n            }\n            freeBloc(Bbloc);\n            free(T);\n        }\n        int kReste = l%k;\n        if (kReste != 0) {\n            calculResteK(A, B, C, kReste, n, l, blocksize, start*blocksize);\n        }\n    }\n    uint32_t blocksizeReste = m%blocksize;\n    if(blocksizeReste != 0) {\n        int start = m - blocksizeReste;\n        for (int i = 0; i < l/k; ++i) {\n            //alocating table of 2^k * B->nbColonneInt\n            uint64_t * T = malloc((n*sizeof(uint64_t))<<k);\n            matrix_t * Bbloc = getBloc(B, i*k, i+k);\n            fillTable(T, Bbloc, k);\n            for (int s = 0; s < blocksizeReste; ++s) { //scanning throught the last block\n                uint64_t j = start + s;\n                int64_t id = extract(A,j, k*i, k);\n                uint64_t * Tline = T+id*n;\n                xorMatrixRow(C, j, Tline);\n            }\n            free(Bbloc);\n            Bbloc = NULL;\n            free(T);\n            T = NULL;\n        }\n        uint32_t kReste = l%k;\n        if (kReste != 0) {\n            //not multiplying by blocksize because start is already the beginning of the last bloc\n            calculResteK(A, B, C, kReste, n, l, blocksizeReste, start);\n        }\n    }\n"]], "pred": {"ppl": 2.4425814151763916, "ppl_lower": 2.6159422397613525, "ppl/lowercase_ppl": -1.0767801345785093, "ppl/zlib": 0.0015450786109039237, "Min_5.0% Prob": 7.8011885065781446, "Min_10.0% Prob": 5.941785809281584, "Min_20.0% Prob": 3.9479839561821577, "Min_30.0% Prob": 2.868414903228933, "Min_40.0% Prob": 2.2057605939389817, "Min_50.0% Prob": 1.7808614270616845, "Min_60.0% Prob": 1.4887739059356389}}
{"hexsha": "45b4e415a1ae5f8837cef7ee0b35c3debdb4754c", "ext": "c", "lang": "C", "content": "int mystricmp(const char *s1, const char *s2)\r\n{\r\n   int c1, c2;\r\n\r\n   do {\r\n      c1 = mytolower(*(s1++));\r\n      c2 = mytolower(*(s2++));\r\n   } while ((c1) && (c1 == c2));\r\n\r\n   return c1 - c2;\r\n}", "item_id": 0, "repo": "kamil-cc/allegro-bcc", "file": "docs/src/makedoc/makemisc.c", "last_update_at": "2018-04-21T12:43:01+00:00", "question_id": "45b4e415a1ae5f8837cef7ee0b35c3debdb4754c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int mystricmp(const char *s1, const char *s2)\r\n{\r\n   int c1, c2;\r\n\r\n   do {\r\n      c1 = mytolower(*(s1++));\r\n      c2 = mytolower(*(s2++));\r\n   } while ((c1) && (c1 == c2));\r\n\r\n   return c1 - c2;\r\n"]], "pred": {"ppl": 2.1265199184417725, "ppl_lower": 2.1265199184417725, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.00567283310105419, "Min_5.0% Prob": 8.000093579292297, "Min_10.0% Prob": 5.894152032004462, "Min_20.0% Prob": 3.5786275330342745, "Min_30.0% Prob": 2.527043143553393, "Min_40.0% Prob": 1.8790635486182414, "Min_50.0% Prob": 1.5231763112973025, "Min_60.0% Prob": 1.257054630797683}}
{"hexsha": "32040ace00ea2431a18428dca5c34c0c4ebde10c", "ext": "c", "lang": "C", "content": "int hypfs_vm_create_files(struct dentry *root)\n{\n\tstruct dentry *dir, *file;\n\tstruct diag2fc_data *data;\n\tunsigned int count = 0;\n\tint rc, i;\n\n\tdata = diag2fc_store(guest_query, &count, 0);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t/* Hpervisor Info */\n\tdir = hypfs_mkdir(root, \"hyp\");\n\tif (IS_ERR(dir)) {\n\t\trc = PTR_ERR(dir);\n\t\tgoto failed;\n\t}\n\tfile = hypfs_create_str(dir, \"type\", \"z/VM Hypervisor\");\n\tif (IS_ERR(file)) {\n\t\trc = PTR_ERR(file);\n\t\tgoto failed;\n\t}\n\n\t/* physical cpus */\n\tdir = hypfs_mkdir(root, \"cpus\");\n\tif (IS_ERR(dir)) {\n\t\trc = PTR_ERR(dir);\n\t\tgoto failed;\n\t}\n\tfile = hypfs_create_u64(dir, \"count\", data->lcpus);\n\tif (IS_ERR(file)) {\n\t\trc = PTR_ERR(file);\n\t\tgoto failed;\n\t}\n\n\t/* guests */\n\tdir = hypfs_mkdir(root, \"systems\");\n\tif (IS_ERR(dir)) {\n\t\trc = PTR_ERR(dir);\n\t\tgoto failed;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\trc = hpyfs_vm_create_guest(dir, &(data[i]));\n\t\tif (rc)\n\t\t\tgoto failed;\n\t}\n\tdiag2fc_free(data);\n\treturn 0;\n\nfailed:\n\tdiag2fc_free(data);\n\treturn rc;\n}", "item_id": 3, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/arch/s390/hypfs/hypfs_vm.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "32040ace00ea2431a18428dca5c34c0c4ebde10c_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int hypfs_vm_create_files(struct dentry *root)\n{\n\tstruct dentry *dir, *file;\n\tstruct diag2fc_data *data;\n\tunsigned int count = 0;\n\tint rc, i;\n\tdata = diag2fc_store(guest_query, &count, 0);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\t/* Hpervisor Info */\n\tdir = hypfs_mkdir(root, \"hyp\");\n\tif (IS_ERR(dir)) {\n\t\trc = PTR_ERR(dir);\n\t\tgoto failed;\n\t}\n\tfile = hypfs_create_str(dir, \"type\", \"z/VM Hypervisor\");\n\tif (IS_ERR(file)) {\n\t\trc = PTR_ERR(file);\n\t\tgoto failed;\n\t}\n\t/* physical cpus */\n\tdir = hypfs_mkdir(root, \"cpus\");\n\tif (IS_ERR(dir)) {\n\t\trc = PTR_ERR(dir);\n\t\tgoto failed;\n\t}\n\tfile = hypfs_create_u64(dir, \"count\", data->lcpus);\n\tif (IS_ERR(file)) {\n\t\trc = PTR_ERR(file);\n\t\tgoto failed;\n\t}\n\t/* guests */\n\tdir = hypfs_mkdir(root, \"systems\");\n\tif (IS_ERR(dir)) {\n\t\trc = PTR_ERR(dir);\n\t\tgoto failed;\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\trc = hpyfs_vm_create_guest(dir, &(data[i]));\n\t\tif (rc)\n\t\t\tgoto failed;\n\t}\n\tdiag2fc_free(data);\n\treturn 0;\nfailed:\n\tdiag2fc_free(data);\n\treturn rc;\n"]], "pred": {"ppl": 2.0244407653808594, "ppl_lower": 2.1767497062683105, "ppl/lowercase_ppl": -1.1028498162863118, "ppl/zlib": 0.0018130938230689953, "Min_5.0% Prob": 8.028334949327553, "Min_10.0% Prob": 5.668999768318014, "Min_20.0% Prob": 3.362418957133042, "Min_30.0% Prob": 2.3318556949392066, "Min_40.0% Prob": 1.7673705463836853, "Min_50.0% Prob": 1.4127211039494567, "Min_60.0% Prob": 1.176068431601316}}
{"hexsha": "be5eab08edc7d9a05186969e889c309ea32eec48", "ext": "h", "lang": "C", "content": "class SensorData : public Streamable\n{\npublic:\n  ENUM(Sensor,\n    gyroX,\n    gyroY,\n    gyroZ,\n    accX,\n    accY,\n    accZ,\n    batteryLevel,\n    fsrLFL,     //the feetsensors of the Nao-Robot\n    fsrLFR,\n    fsrLBL,\n    fsrLBR,\n    fsrRFL,\n    fsrRFR,\n    fsrRBL,\n    fsrRBR,\n    usL,\n    usR,\n    angleX,\n    angleY\n  );\n\n  enum\n  {\n    off = JointData::off /**< A special value to indicate that the sensor is missing. */\n  };\n\n  ENUM(UsActuatorMode,\n    leftToLeft,\n    leftToRight,\n    rightToLeft,\n    rightToRight\n  );\n\n  float data[numOfSensors]; /**< The data of all sensors. */\n  float currents[JointData::numOfJoints]; /**< The currents of all motors. */\n  unsigned char temperatures[JointData::numOfJoints]; /**< The temperature of all motors. */\n  unsigned timeStamp; /**< The time when the sensor data was received. */\n\n  UsActuatorMode usActuatorMode; /**< The ultrasonice measure method which was used for measuring \\c data[usL] and \\c data[usR]. */\n  unsigned usTimeStamp; /**< The time when the ultrasonic measurements were taken. */\n\n  /**\n  * Default constructor.\n  */\n  SensorData() : timeStamp(0), usActuatorMode(leftToLeft), usTimeStamp(0)\n  {\n    for(int i = 0; i < numOfSensors; ++i)\n      data[i] = off;\n    for(int i = 0; i < JointData::numOfJoints; ++i)\n      currents[i] = temperatures[i] = 0;\n  }", "item_id": 0, "repo": "ToyotaResearchInstitute/rad-robot", "file": "Modules-old/bhwalk/Representations/Infrastructure/SensorData.h", "last_update_at": "2018-09-22T10:31:27+00:00", "question_id": "be5eab08edc7d9a05186969e889c309ea32eec48_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class SensorData : public Streamable\n{\npublic:\n  ENUM(Sensor,\n    gyroX,\n    gyroY,\n    gyroZ,\n    accX,\n    accY,\n    accZ,\n    batteryLevel,\n    fsrLFL,     //the feetsensors of the Nao-Robot\n    fsrLFR,\n    fsrLBL,\n    fsrLBR,\n    fsrRFL,\n    fsrRFR,\n    fsrRBL,\n    fsrRBR,\n    usL,\n    usR,\n    angleX,\n    angleY\n  );\n  enum\n  {\n    off = JointData::off /**< A special value to indicate that the sensor is missing. */\n  };\n  ENUM(UsActuatorMode,\n    leftToLeft,\n    leftToRight,\n    rightToLeft,\n    rightToRight\n  );\n  float data[numOfSensors]; /**< The data of all sensors. */\n  float currents[JointData::numOfJoints]; /**< The currents of all motors. */\n  unsigned char temperatures[JointData::numOfJoints]; /**< The temperature of all motors. */\n  unsigned timeStamp; /**< The time when the sensor data was received. */\n  UsActuatorMode usActuatorMode; /**< The ultrasonice measure method which was used for measuring \\c data[usL] and \\c data[usR]. */\n  unsigned usTimeStamp; /**< The time when the ultrasonic measurements were taken. */\n  /**\n  * Default constructor.\n  */\n  SensorData() : timeStamp(0), usActuatorMode(leftToLeft), usTimeStamp(0)\n  {\n    for(int i = 0; i < numOfSensors; ++i)\n      data[i] = off;\n    for(int i = 0; i < JointData::numOfJoints; ++i)\n      currents[i] = temperatures[i] = 0;\n"]], "pred": {"ppl": 2.6299405097961426, "ppl_lower": 2.9927873611450195, "ppl/lowercase_ppl": -1.1336599145704092, "ppl/zlib": 0.0017298054133890253, "Min_5.0% Prob": 8.753806858062744, "Min_10.0% Prob": 6.60997814655304, "Min_20.0% Prob": 4.282928431388175, "Min_30.0% Prob": 3.0984262559587594, "Min_40.0% Prob": 2.3826735362705618, "Min_50.0% Prob": 1.9236642060720401, "Min_60.0% Prob": 1.612105095488551}}
{"hexsha": "2abd326fe504166fb44429f64f93ae57aadcd94f", "ext": "h", "lang": "C", "content": "class MenuLayer2 : public CCLayer\n{\n\tpublic :\n\n\t\tCREATE_FUNC ( MenuLayer2 );\n\n\tprotected :\n\n\t\tvirtual KDbool\t\tinit ( KDvoid );\n\n\t\tKDvoid\t\t\t\tmenuCallback        ( CCObject* pSender );\n\t\tKDvoid\t\t\t\tmenuCallbackOpacity ( CCObject* pSender );\n\t\tKDvoid\t\t\t\tmenuCallbackAlign   ( CCObject* pSender );\n\n\t\tKDvoid\t\t\t\talignMenusH ( KDvoid );\n\t\tKDvoid\t\t\t\talignMenusV ( KDvoid );\n\n\tprotected :\n\n\t\tCCPoint\t\t\t\tm_tCenteredMenu;\n\t\tKDbool\t\t\t\tm_bAlignedH; \n}", "item_id": 1, "repo": "mcodegeeks/OpenKODE-Framework", "file": "03_Tutorial/T02_XMCocos2D/Source/Test/TestMenu.h", "last_update_at": "2018-06-18T10:32:53+00:00", "question_id": "2abd326fe504166fb44429f64f93ae57aadcd94f_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class MenuLayer2 : public CCLayer\n{\n\tpublic :\n\t\tCREATE_FUNC ( MenuLayer2 );\n\tprotected :\n\t\tvirtual KDbool\t\tinit ( KDvoid );\n\t\tKDvoid\t\t\t\tmenuCallback        ( CCObject* pSender );\n\t\tKDvoid\t\t\t\tmenuCallbackOpacity ( CCObject* pSender );\n\t\tKDvoid\t\t\t\tmenuCallbackAlign   ( CCObject* pSender );\n\t\tKDvoid\t\t\t\talignMenusH ( KDvoid );\n\t\tKDvoid\t\t\t\talignMenusV ( KDvoid );\n\tprotected :\n\t\tCCPoint\t\t\t\tm_tCenteredMenu;\n\t\tKDbool\t\t\t\tm_bAlignedH; \n"]], "pred": {"ppl": 1.8189343214035034, "ppl_lower": 3.953579902648926, "ppl/lowercase_ppl": -2.2977344811527813, "ppl/zlib": 0.0028488132947818113, "Min_5.0% Prob": 7.215034431881374, "Min_10.0% Prob": 4.85227716596503, "Min_20.0% Prob": 2.886486971225494, "Min_30.0% Prob": 1.992316577840468, "Min_40.0% Prob": 1.4911105249745724, "Min_50.0% Prob": 1.201136907293778, "Min_60.0% Prob": 0.9966082429079514}}
{"hexsha": "f8e559e0665135bd935b5e3a04fe8fe495abe150", "ext": "c", "lang": "C", "content": "void SimonEncrypt96(uint64_t *SR, uint64_t *SL, const uint64_t *k)\n{\n\tuint64_t x = SL[0]; uint64_t y = SR[0];\n\tuint64_t tmp = 0;\n\tint i;\n\n\tfor (i = 0; i < 52; i++)\n\t{\n\t\ttmp = x;\n\t\tx = y ^ ROTL2(1, x, 48) & ROTL2(8, x, 48) ^ ROTL2(2, x, 48) ^ k[i];\n\t\ty = tmp;\n\t};\n\tSL[0] = x & 0xffffffffffff; SR[0] = y & 0xffffffffffff;\n}", "item_id": 4, "repo": "iadgov/simon-speck-supercop", "file": "crypto_aead/simonjambu128v2/ref/Simon.c", "last_update_at": "2018-03-09T14:52:25+00:00", "question_id": "f8e559e0665135bd935b5e3a04fe8fe495abe150_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void SimonEncrypt96(uint64_t *SR, uint64_t *SL, const uint64_t *k)\n{\n\tuint64_t x = SL[0]; uint64_t y = SR[0];\n\tuint64_t tmp = 0;\n\tint i;\n\tfor (i = 0; i < 52; i++)\n\t{\n\t\ttmp = x;\n\t\tx = y ^ ROTL2(1, x, 48) & ROTL2(8, x, 48) ^ ROTL2(2, x, 48) ^ k[i];\n\t\ty = tmp;\n\t};\n\tSL[0] = x & 0xffffffffffff; SR[0] = y & 0xffffffffffff;\n"]], "pred": {"ppl": 3.008091688156128, "ppl_lower": 3.0888419151306152, "ppl/lowercase_ppl": -1.0240535796333248, "ppl/zlib": 0.005827015275438767, "Min_5.0% Prob": 8.680488639407688, "Min_10.0% Prob": 6.418458248439588, "Min_20.0% Prob": 4.407860902639536, "Min_30.0% Prob": 3.3379367034314043, "Min_40.0% Prob": 2.640554569567306, "Min_50.0% Prob": 2.1638768301768736, "Min_60.0% Prob": 1.8360654252060389}}
{"hexsha": "7c7f720cb2b6d920b5eee25af711b5faaf6765bb", "ext": "c", "lang": "C", "content": "struct gv *gvLoadByQuery(struct sqlConnection *conn, char *query)\n/* Load all gv from table that satisfy the query given.  \n * Where query is of the form 'select * from example where something=something'\n * or 'select example.* from example, anotherTable where example.something = \n * anotherTable.something'.\n * Dispose of this with gvFreeList(). */\n{\nstruct gv *list = NULL, *el;\nstruct sqlResult *sr;\nchar **row;\n\nsr = sqlGetResult(conn, query);\nwhile ((row = sqlNextRow(sr)) != NULL)\n    {\n    el = gvLoad(row);\n    slAddHead(&list, el);\n    }\nslReverse(&list);\nsqlFreeResult(&sr);\nreturn list;\n}", "item_id": 4, "repo": "bowhan/kent", "file": "src/hg/lib/gv.c", "last_update_at": "2018-03-14T22:19:20+00:00", "question_id": "7c7f720cb2b6d920b5eee25af711b5faaf6765bb_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct gv *gvLoadByQuery(struct sqlConnection *conn, char *query)\n/* Load all gv from table that satisfy the query given.  \n * Where query is of the form 'select * from example where something=something'\n * or 'select example.* from example, anotherTable where example.something = \n * anotherTable.something'.\n * Dispose of this with gvFreeList(). */\n{\nstruct gv *list = NULL, *el;\nstruct sqlResult *sr;\nchar **row;\nsr = sqlGetResult(conn, query);\nwhile ((row = sqlNextRow(sr)) != NULL)\n    {\n    el = gvLoad(row);\n    slAddHead(&list, el);\n    }\nslReverse(&list);\nsqlFreeResult(&sr);\nreturn list;\n"]], "pred": {"ppl": 1.3127899169921875, "ppl_lower": 2.688429355621338, "ppl/lowercase_ppl": -3.633806712311224, "ppl/zlib": 0.0007934535866709418, "Min_5.0% Prob": 5.537629942099254, "Min_10.0% Prob": 2.8422121451132827, "Min_20.0% Prob": 1.3888932678068209, "Min_30.0% Prob": 0.9182769716467841, "Min_40.0% Prob": 0.6857595462530541, "Min_50.0% Prob": 0.547183568957367, "Min_60.0% Prob": 0.4551895691215939}}
{"hexsha": "a8c52d29ccb5789358b670abeb5ef02944bc4aca", "ext": "c", "lang": "C", "content": "int qmi_set_wds_get_current_settings_request(struct qmi_msg *msg, struct qmi_wds_get_current_settings_request *req)\n{\n\tqmi_init_request_message(msg, QMI_SERVICE_WDS);\n\tmsg->svc.message = cpu_to_le16(0x002D);\n\n\tif (req->set.requested_settings) {\n\t\tvoid *buf;\n\t\tunsigned int ofs;\n\n\t\t__qmi_alloc_reset();\n\t\tput_tlv_var(uint32_t, cpu_to_le32(req->data.requested_settings), 4);\n\n\t\tbuf = __qmi_get_buf(&ofs);\n\t\ttlv_new(msg, 0x10, ofs, buf);\n\t}\n\n\treturn 0;\n}", "item_id": 18, "repo": "ECRS/Asus-RT-N16", "file": "release/src/router/uqmi/qmi-message-wds.c", "last_update_at": "2018-08-21T03:43:31+00:00", "question_id": "a8c52d29ccb5789358b670abeb5ef02944bc4aca_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int qmi_set_wds_get_current_settings_request(struct qmi_msg *msg, struct qmi_wds_get_current_settings_request *req)\n{\n\tqmi_init_request_message(msg, QMI_SERVICE_WDS);\n\tmsg->svc.message = cpu_to_le16(0x002D);\n\tif (req->set.requested_settings) {\n\t\tvoid *buf;\n\t\tunsigned int ofs;\n\t\t__qmi_alloc_reset();\n\t\tput_tlv_var(uint32_t, cpu_to_le32(req->data.requested_settings), 4);\n\t\tbuf = __qmi_get_buf(&ofs);\n\t\ttlv_new(msg, 0x10, ofs, buf);\n\t}\n\treturn 0;\n"]], "pred": {"ppl": 1.9927024841308594, "ppl_lower": 2.120584487915039, "ppl/lowercase_ppl": -1.0902113809053235, "ppl/zlib": 0.002453707294203562, "Min_5.0% Prob": 6.387129020690918, "Min_10.0% Prob": 4.8171820640563965, "Min_20.0% Prob": 3.088301270507103, "Min_30.0% Prob": 2.2242084810366998, "Min_40.0% Prob": 1.7078043166762111, "Min_50.0% Prob": 1.3751558888395992, "Min_60.0% Prob": 1.155171105552178}}
{"hexsha": "7951df687eec80e44c89cacad8ffbf2d7048f11d", "ext": "c", "lang": "C", "content": "int mal_routing_register_consumer_pubsub_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_register_ack,\n    mal_routing_on_message_fn *on_deregister_ack,\n    mal_routing_on_message_fn *on_notify) {\n  clog_info(mal_logger, \" *** mal_routing_register_consumer_pubsub_handler: %hd %hhd %hd %hd\\n\", area, area_version, service, operation);\n\n  // Allocates a new structure and initialize it\n  mal_routing_handler_t *handler = mal_routing_new_handler(MAL_ACTOR_CONSUMER_PUBSUB_HANDLER, area, area_version, service, operation);\n  if (handler == NULL) return -1;\n\n  handler->spec.consumer_pubsub_handler.on_register_ack = on_register_ack;\n  handler->spec.consumer_pubsub_handler.on_deregister_ack = on_deregister_ack;\n  handler->spec.consumer_pubsub_handler.on_notify = on_notify;\n  return mal_routing_register_handler(mal_routing, handler);\n}", "item_id": 13, "repo": "georgeslabreche/ccsdsmo-malc", "file": "mal/src/mal_routing.c", "last_update_at": "2018-01-27T00:46:04+00:00", "question_id": "7951df687eec80e44c89cacad8ffbf2d7048f11d_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int mal_routing_register_consumer_pubsub_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_register_ack,\n    mal_routing_on_message_fn *on_deregister_ack,\n    mal_routing_on_message_fn *on_notify) {\n  clog_info(mal_logger, \" *** mal_routing_register_consumer_pubsub_handler: %hd %hhd %hd %hd\\n\", area, area_version, service, operation);\n  // Allocates a new structure and initialize it\n  mal_routing_handler_t *handler = mal_routing_new_handler(MAL_ACTOR_CONSUMER_PUBSUB_HANDLER, area, area_version, service, operation);\n  if (handler == NULL) return -1;\n  handler->spec.consumer_pubsub_handler.on_register_ack = on_register_ack;\n  handler->spec.consumer_pubsub_handler.on_deregister_ack = on_deregister_ack;\n  handler->spec.consumer_pubsub_handler.on_notify = on_notify;\n  return mal_routing_register_handler(mal_routing, handler);\n"]], "pred": {"ppl": 2.0506937503814697, "ppl_lower": 2.1764473915100098, "ppl/lowercase_ppl": -1.0828704685535502, "ppl/zlib": 0.002028751838195385, "Min_5.0% Prob": 7.486367786631865, "Min_10.0% Prob": 5.268435750688825, "Min_20.0% Prob": 3.3064737592424667, "Min_30.0% Prob": 2.3633578760283336, "Min_40.0% Prob": 1.7884718617754625, "Min_50.0% Prob": 1.4384155523677526, "Min_60.0% Prob": 1.2011240862466623}}
{"hexsha": "dcf766ae070622959503b15bfca548995f80dcaf", "ext": "c", "lang": "C", "content": "static int stxReadThread(StxThread* thread, EmbFile* file)\n{\n    int j, colorNameLength, sectionNameLength;\n    int somethingSomething, somethingSomething2, somethingElse, numberOfOtherDescriptors; /* TODO: determine what these represent */\n    int codeLength = 0;\n    char* codeBuff = 0;\n    char* codeNameBuff = 0;\n    char* sectionNameBuff = 0;\n    EmbColor col;\n    unsigned char whatIsthis; /* TODO: determine what this represents */\n\n    if(!thread) { embLog_error(\"format-stx.c stxReadThread(), thread argument is null\\n\"); return 0; }\n    if(!file) { embLog_error(\"format-stx.c stxReadThread(), file argument is null\\n\"); return 0; }\n\n    codeLength = binaryReadUInt8(file);\n    codeBuff = (char*)malloc(codeLength);\n    if(!codeBuff) { embLog_error(\"format-stx.c stxReadThread(), unable to allocate memory for codeBuff\\n\"); return 0; }\n    binaryReadBytes(file, (unsigned char*)codeBuff, codeLength); /* TODO: check return value */\n    thread->colorCode = codeBuff;\n    colorNameLength = binaryReadUInt8(file);\n    codeNameBuff = (char*)malloc(colorNameLength);\n    if(!codeNameBuff) { embLog_error(\"format-stx.c stxReadThread(), unable to allocate memory for codeNameBuff\\n\"); return 0; }\n    binaryReadBytes(file, (unsigned char*)codeNameBuff, colorNameLength); /* TODO: check return value */\n    thread->colorName = codeNameBuff;\n\n    col.r = binaryReadUInt8(file);\n    col.b = binaryReadUInt8(file);\n    col.g = binaryReadUInt8(file);\n\n    whatIsthis = binaryReadUInt8(file);\n\n    sectionNameLength = binaryReadUInt8(file);\n    sectionNameBuff = (char*)malloc(sectionNameLength);\n    if(!sectionNameBuff) { embLog_error(\"format-stx.c stxReadThread(), unable to allocate memory for sectionNameBuff\\n\"); return 0; }\n    binaryReadBytes(file, (unsigned char*)sectionNameBuff, sectionNameLength); /* TODO: check return value */\n    thread->sectionName = sectionNameBuff;\n\n    somethingSomething = binaryReadInt32(file);\n    somethingSomething2 = binaryReadInt32(file);\n    somethingElse = binaryReadInt32(file);\n    numberOfOtherDescriptors = binaryReadInt16(file);\n\n    thread->subDescriptors = (SubDescriptor*)malloc(sizeof(SubDescriptor) * numberOfOtherDescriptors);\n    if(!thread->subDescriptors) { embLog_error(\"format-stx.c stxReadThread(), unable to allocate memory for thread->subDescriptors\\n\"); return 0; }\n    for(j = 0; j < numberOfOtherDescriptors; j++)\n    {\n        SubDescriptor sd;\n        char* subCodeBuff, *subColorNameBuff;\n        int subCodeLength, subColorNameLength;\n\n        sd.someNum = binaryReadInt16(file);\n        /* Debug.Assert(sd.someNum == 1); TODO: review */\n        sd.someInt = binaryReadInt32(file);\n        subCodeLength = binaryReadUInt8(file);\n        subCodeBuff = (char*)malloc(subCodeLength);\n        if(!subCodeBuff) { embLog_error(\"format-stx.c stxReadThread(), unable to allocate memory for subCodeBuff\\n\"); return 0; }\n        binaryReadBytes(file, (unsigned char*)subCodeBuff, subCodeLength); /* TODO: check return value */\n        sd.colorCode = subCodeBuff;\n        subColorNameLength = binaryReadUInt8(file);\n        subColorNameBuff = (char*)malloc(subColorNameLength);\n        if(!subColorNameBuff) { embLog_error(\"format-stx.c stxReadThread(), unable to allocate memory for subColorNameBuff\\n\"); return 0; }\n        binaryReadBytes(file, (unsigned char*)subColorNameBuff, subColorNameLength); /* TODO: check return value */\n        sd.colorName = subColorNameBuff;\n        sd.someOtherInt = binaryReadInt32(file);\n        thread->subDescriptors[j] = sd;\n    }\n    return 1;\n}", "item_id": 0, "repo": "Drahflow/Embroidermodder", "file": "libembroidery/format-stx.c", "last_update_at": "2018-08-13T14:56:33+00:00", "question_id": "dcf766ae070622959503b15bfca548995f80dcaf_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int stxReadThread(StxThread* thread, EmbFile* file)\n{\n    int j, colorNameLength, sectionNameLength;\n    int somethingSomething, somethingSomething2, somethingElse, numberOfOtherDescriptors; /* TODO: determine what these represent */\n    int codeLength = 0;\n    char* codeBuff = 0;\n    char* codeNameBuff = 0;\n    char* sectionNameBuff = 0;\n    EmbColor col;\n    unsigned char whatIsthis; /* TODO: determine what this represents */\n    if(!thread) { embLog_error(\"format-stx.c stxReadThread(), thread argument is null\\n\"); return 0; }\n    if(!file) { embLog_error(\"format-stx.c stxReadThread(), file argument is null\\n\"); return 0; }\n    codeLength = binaryReadUInt8(file);\n    codeBuff = (char*)malloc(codeLength);\n    if(!codeBuff) { embLog_error(\"format-stx.c stxReadThread(), unable to allocate memory for codeBuff\\n\"); return 0; }\n    binaryReadBytes(file, (unsigned char*)codeBuff, codeLength); /* TODO: check return value */\n    thread->colorCode = codeBuff;\n    colorNameLength = binaryReadUInt8(file);\n    codeNameBuff = (char*)malloc(colorNameLength);\n    if(!codeNameBuff) { embLog_error(\"format-stx.c stxReadThread(), unable to allocate memory for codeNameBuff\\n\"); return 0; }\n    binaryReadBytes(file, (unsigned char*)codeNameBuff, colorNameLength); /* TODO: check return value */\n    thread->colorName = codeNameBuff;\n    col.r = binaryReadUInt8(file);\n    col.b = binaryReadUInt8(file);\n    col.g = binaryReadUInt8(file);\n    whatIsthis = binaryReadUInt8(file);\n    sectionNameLength = binaryReadUInt8(file);\n    sectionNameBuff = (char*)malloc(sectionNameLength);\n    if(!sectionNameBuff) { embLog_error(\"format-stx.c stxReadThread(), unable to allocate memory for sectionNameBuff\\n\"); return 0; }\n    binaryReadBytes(file, (unsigned char*)sectionNameBuff, sectionNameLength); /* TODO: check return value */\n    thread->sectionName = sectionNameBuff;\n    somethingSomething = binaryReadInt32(file);\n    somethingSomething2 = binaryReadInt32(file);\n    somethingElse = binaryReadInt32(file);\n    numberOfOtherDescriptors = binaryReadInt16(file);\n    thread->subDescriptors = (SubDescriptor*)malloc(sizeof(SubDescriptor) * numberOfOtherDescriptors);\n    if(!thread->subDescriptors) { embLog_error(\"format-stx.c stxReadThread(), unable to allocate memory for thread->subDescriptors\\n\"); return 0; }\n    for(j = 0; j < numberOfOtherDescriptors; j++)\n    {\n        SubDescriptor sd;\n        char* subCodeBuff, *subColorNameBuff;\n        int subCodeLength, subColorNameLength;\n        sd.someNum = binaryReadInt16(file);\n        /* Debug.Assert(sd.someNum == 1); TODO: review */\n        sd.someInt = binaryReadInt32(file);\n        subCodeLength = binaryReadUInt8(file);\n        subCodeBuff = (char*)malloc(subCodeLength);\n        if(!subCodeBuff) { embLog_error(\"format-stx.c stxReadThread(), unable to allocate memory for subCodeBuff\\n\"); return 0; }\n        binaryReadBytes(file, (unsigned char*)subCodeBuff, subCodeLength); /* TODO: check return value */\n        sd.colorCode = subCodeBuff;\n        subColorNameLength = binaryReadUInt8(file);\n        subColorNameBuff = (char*)malloc(subColorNameLength);\n        if(!subColorNameBuff) { embLog_error(\"format-stx.c stxReadThread(), unable to allocate memory for subColorNameBuff\\n\"); return 0; }\n        binaryReadBytes(file, (unsigned char*)subColorNameBuff, subColorNameLength); /* TODO: check return value */\n        sd.colorName = subColorNameBuff;\n        sd.someOtherInt = binaryReadInt32(file);\n        thread->subDescriptors[j] = sd;\n    }\n    return 1;\n"]], "pred": {"ppl": 1.584599494934082, "ppl_lower": 1.6824945211410522, "ppl/lowercase_ppl": -1.1302231337378028, "ppl/zlib": 0.0005819616824461948, "Min_5.0% Prob": 5.87345739439422, "Min_10.0% Prob": 3.950406954568975, "Min_20.0% Prob": 2.249244369274261, "Min_30.0% Prob": 1.530335300535061, "Min_40.0% Prob": 1.1496745257303664, "Min_50.0% Prob": 0.9211069696820696, "Min_60.0% Prob": 0.7680998181405387}}
{"hexsha": "36cd278e68c04b98eb1ffa068e9fe4ba097cb7a9", "ext": "c", "lang": "C", "content": "static void\n_virtio_scsi_dev_unregister_cb(void *io_device)\n{\n\tstruct virtio_scsi_dev *svdev = io_device;\n\tstruct virtio_dev *vdev = &svdev->vdev;\n\tbool finish_module;\n\tbdev_virtio_remove_cb remove_cb;\n\tvoid *remove_ctx;\n\n\tassert(spdk_ring_count(svdev->ctrlq_ring) == 0);\n\tspdk_ring_free(svdev->ctrlq_ring);\n\tspdk_poller_unregister(&svdev->mgmt_poller);\n\n\tvirtio_dev_release_queue(vdev, VIRTIO_SCSI_EVENTQ);\n\tvirtio_dev_release_queue(vdev, VIRTIO_SCSI_CONTROLQ);\n\n\tvirtio_dev_stop(vdev);\n\tvirtio_dev_destruct(vdev);\n\n\tpthread_mutex_lock(&g_virtio_scsi_mutex);\n\tTAILQ_REMOVE(&g_virtio_scsi_devs, svdev, tailq);\n\tpthread_mutex_unlock(&g_virtio_scsi_mutex);\n\n\tremove_cb = svdev->remove_cb;\n\tremove_ctx = svdev->remove_ctx;\n\tspdk_dma_free(svdev->eventq_ios);\n\tfree(svdev);\n\n\tif (remove_cb) {\n\t\tremove_cb(remove_ctx, 0);\n\t}\n\n\tfinish_module = TAILQ_EMPTY(&g_virtio_scsi_devs);\n\n\tif (g_bdev_virtio_finish && finish_module) {\n\t\tspdk_bdev_module_finish_done();\n\t}\n}", "item_id": 53, "repo": "mlx3im/spdk_test", "file": "lib/bdev/virtio/bdev_virtio_scsi.c", "last_update_at": "2018-11-21T11:05:28+00:00", "question_id": "36cd278e68c04b98eb1ffa068e9fe4ba097cb7a9_53", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\n_virtio_scsi_dev_unregister_cb(void *io_device)\n{\n\tstruct virtio_scsi_dev *svdev = io_device;\n\tstruct virtio_dev *vdev = &svdev->vdev;\n\tbool finish_module;\n\tbdev_virtio_remove_cb remove_cb;\n\tvoid *remove_ctx;\n\tassert(spdk_ring_count(svdev->ctrlq_ring) == 0);\n\tspdk_ring_free(svdev->ctrlq_ring);\n\tspdk_poller_unregister(&svdev->mgmt_poller);\n\tvirtio_dev_release_queue(vdev, VIRTIO_SCSI_EVENTQ);\n\tvirtio_dev_release_queue(vdev, VIRTIO_SCSI_CONTROLQ);\n\tvirtio_dev_stop(vdev);\n\tvirtio_dev_destruct(vdev);\n\tpthread_mutex_lock(&g_virtio_scsi_mutex);\n\tTAILQ_REMOVE(&g_virtio_scsi_devs, svdev, tailq);\n\tpthread_mutex_unlock(&g_virtio_scsi_mutex);\n\tremove_cb = svdev->remove_cb;\n\tremove_ctx = svdev->remove_ctx;\n\tspdk_dma_free(svdev->eventq_ios);\n\tfree(svdev);\n\tif (remove_cb) {\n\t\tremove_cb(remove_ctx, 0);\n\t}\n\tfinish_module = TAILQ_EMPTY(&g_virtio_scsi_devs);\n\tif (g_bdev_virtio_finish && finish_module) {\n\t\tspdk_bdev_module_finish_done();\n\t}\n"]], "pred": {"ppl": 1.875884771347046, "ppl_lower": 2.0406932830810547, "ppl/lowercase_ppl": -1.1338607355929842, "ppl/zlib": 0.0015231971578079802, "Min_5.0% Prob": 6.650269334966486, "Min_10.0% Prob": 4.7785799132453075, "Min_20.0% Prob": 2.968230213721593, "Min_30.0% Prob": 2.0779028517228584, "Min_40.0% Prob": 1.5735392700052924, "Min_50.0% Prob": 1.2605295486448125, "Min_60.0% Prob": 1.0507173361123057}}
{"hexsha": "b16dbb2c1d4e543c948df336f8715ff2abf06f34", "ext": "c", "lang": "C", "content": "static int ftm_check_validation(void)\n{\n\tunsigned long long ptn = 0;\n\tunsigned int size = FTM_ROUND_TO_PAGE(strlen(FTM_MAGIC_STRING) + 1, FTM_PAGE_MASK);\n\tunsigned char data[size];\n\n\tif (ftm_valid > FTM_NOT_MATCHED_MAGIC)\n\t\treturn NO_ERROR;\n\n\tif (!target_is_emmc_boot()) {\n\t\tdprintf(CRITICAL, \"%s: target is not emmc boot\\n\", __func__);\n\t\tgoto invalidated;\n\t}\n\n\tptn = ftm_get_partition_offset();\n\n\tif (ptn == 0) {\n\t\tdprintf(CRITICAL, \"%s: failed get offset\\n\", __func__);\n\t\tgoto invalidated;\n\t}\n\n\t/* read first page from ftm partition */\n\tif (mmc_read(ptn + (LGFTM_MAGIC_ITEM * FTM_PAGE_SIZE), (unsigned int *)data, size)) {\n\t\tdprintf(CRITICAL, \"%s: mmc read failure\\n\", __func__);\n\t\tgoto invalidated;\n\t}\n\n\tif (!strcmp((void *)data, FTM_MAGIC_STRING)) {\n\t\tftm_valid = FTM_VALID;\n\t} else {\n\t\tftm_valid = FTM_NOT_MATCHED_MAGIC;\n\t\tdprintf(CRITICAL, \"%s: FTM magic string is not equal. %s\\n\", __func__, data);\n\t}\n\n\treturn NO_ERROR;\n\ninvalidated:\n\tftm_valid = FTM_INVALID;\n\treturn ERROR;\n}", "item_id": 2, "repo": "jaehyek/lk", "file": "platform/lge_shared/lge_ftm.c", "last_update_at": "2018-09-16T12:35:42+00:00", "question_id": "b16dbb2c1d4e543c948df336f8715ff2abf06f34_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int ftm_check_validation(void)\n{\n\tunsigned long long ptn = 0;\n\tunsigned int size = FTM_ROUND_TO_PAGE(strlen(FTM_MAGIC_STRING) + 1, FTM_PAGE_MASK);\n\tunsigned char data[size];\n\tif (ftm_valid > FTM_NOT_MATCHED_MAGIC)\n\t\treturn NO_ERROR;\n\tif (!target_is_emmc_boot()) {\n\t\tdprintf(CRITICAL, \"%s: target is not emmc boot\\n\", __func__);\n\t\tgoto invalidated;\n\t}\n\tptn = ftm_get_partition_offset();\n\tif (ptn == 0) {\n\t\tdprintf(CRITICAL, \"%s: failed get offset\\n\", __func__);\n\t\tgoto invalidated;\n\t}\n\t/* read first page from ftm partition */\n\tif (mmc_read(ptn + (LGFTM_MAGIC_ITEM * FTM_PAGE_SIZE), (unsigned int *)data, size)) {\n\t\tdprintf(CRITICAL, \"%s: mmc read failure\\n\", __func__);\n\t\tgoto invalidated;\n\t}\n\tif (!strcmp((void *)data, FTM_MAGIC_STRING)) {\n\t\tftm_valid = FTM_VALID;\n\t} else {\n\t\tftm_valid = FTM_NOT_MATCHED_MAGIC;\n\t\tdprintf(CRITICAL, \"%s: FTM magic string is not equal. %s\\n\", __func__, data);\n\t}\n\treturn NO_ERROR;\ninvalidated:\n\tftm_valid = FTM_INVALID;\n\treturn ERROR;\n"]], "pred": {"ppl": 2.2474546432495117, "ppl_lower": 2.4683408737182617, "ppl/lowercase_ppl": -1.1157669841974787, "ppl/zlib": 0.0017377646055384485, "Min_5.0% Prob": 7.278097970145089, "Min_10.0% Prob": 5.400238807811293, "Min_20.0% Prob": 3.577170807739784, "Min_30.0% Prob": 2.593400177154832, "Min_40.0% Prob": 2.0119135146425373, "Min_50.0% Prob": 1.6186706324475348, "Min_60.0% Prob": 1.349704482212293}}
{"hexsha": "0cbfbbd3294da2ab5ef285bffc8cf9b09e9e1932", "ext": "c", "lang": "C", "content": "int make_FOOD(BOX** b, SNAKE* left, SNAKE* right)\n{\n    *b = (BOX*) malloc(sizeof(BOX));\n    int startx,starty;\n\n    // we don't want food to be placed in the snake\n    while(TRUE)\n    {\n        startx = 2 * (rand() % (COLS / 2 - 2)) + 1;\n        starty = rand() % (LINES - 2 - 2) + 1;\n        if(!check_SNAKE(left, startx, starty) && !check_SNAKE(right, startx, starty))\n            break;\n    }\n   \n    (*b)->startx = startx;\n    (*b)->starty = starty;\n    (*b)->width = 2;\n    (*b)->height = 1;\n    (*b)->content = ' ' | A_REVERSE;\n    return 0;\n}", "item_id": 3, "repo": "gongbudaizhe/bilib", "file": "demos/snake_game.c", "last_update_at": "2018-08-28T04:18:09+00:00", "question_id": "0cbfbbd3294da2ab5ef285bffc8cf9b09e9e1932_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int make_FOOD(BOX** b, SNAKE* left, SNAKE* right)\n{\n    *b = (BOX*) malloc(sizeof(BOX));\n    int startx,starty;\n    // we don't want food to be placed in the snake\n    while(TRUE)\n    {\n        startx = 2 * (rand() % (COLS / 2 - 2)) + 1;\n        starty = rand() % (LINES - 2 - 2) + 1;\n        if(!check_SNAKE(left, startx, starty) && !check_SNAKE(right, startx, starty))\n            break;\n    }\n    (*b)->startx = startx;\n    (*b)->starty = starty;\n    (*b)->width = 2;\n    (*b)->height = 1;\n    (*b)->content = ' ' | A_REVERSE;\n    return 0;\n"]], "pred": {"ppl": 2.619248390197754, "ppl_lower": 2.7771811485290527, "ppl/lowercase_ppl": -1.0608056924673805, "ppl/zlib": 0.00314669085832181, "Min_5.0% Prob": 7.639774625951594, "Min_10.0% Prob": 5.756271300108536, "Min_20.0% Prob": 3.951443286045738, "Min_30.0% Prob": 2.9768903281377708, "Min_40.0% Prob": 2.3423533705613946, "Min_50.0% Prob": 1.913989663381001, "Min_60.0% Prob": 1.6072580062871358}}
{"hexsha": "72705ffb3fb44e73e2627954d282445331a96524", "ext": "c", "lang": "C", "content": "static PyObject *bpy_user_map(PyObject *UNUSED(self), PyObject *args, PyObject *kwds)\n{\n#if 0  /* If someone knows how to get a proper 'self' in that case... */\n\tBPy_StructRNA *pyrna = (BPy_StructRNA *)self;\n\tMain *bmain = pyrna->ptr.data;\n#else\n\tMain *bmain = G.main;  /* XXX Ugly, but should work! */\n#endif\n\n\tstatic const char *kwlist[] = {\"subset\", \"key_types\", \"value_types\", NULL};\n\tPyObject *subset = NULL;\n\n\tPyObject *key_types = NULL;\n\tPyObject *val_types = NULL;\n\tBLI_bitmap *key_types_bitmap = NULL;\n\tBLI_bitmap *val_types_bitmap = NULL;\n\n\tPyObject *ret = NULL;\n\n\n\tif (!PyArg_ParseTupleAndKeywords(\n\t        args, kwds, \"|O$O!O!:user_map\", (char **)kwlist,\n\t        &subset,\n\t        &PySet_Type, &key_types,\n\t        &PySet_Type, &val_types))\n\t{\n\t\treturn NULL;\n\t}\n\n\tif (key_types) {\n\t\tkey_types_bitmap = pyrna_set_to_enum_bitmap(\n\t\t        rna_enum_id_type_items, key_types, sizeof(short), true, USHRT_MAX, \"key types\");\n\t\tif (key_types_bitmap == NULL) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (val_types) {\n\t\tval_types_bitmap = pyrna_set_to_enum_bitmap(\n\t\t        rna_enum_id_type_items, val_types, sizeof(short), true, USHRT_MAX, \"value types\");\n\t\tif (val_types_bitmap == NULL) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tIDUserMapData data_cb = {NULL};\n\n\tif (subset) {\n\t\tPyObject *subset_fast = PySequence_Fast(subset, \"user_map\");\n\t\tif (subset_fast == NULL) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tPyObject **subset_array = PySequence_Fast_ITEMS(subset_fast);\n\t\tPy_ssize_t subset_len = PySequence_Fast_GET_SIZE(subset_fast);\n\n\t\tdata_cb.user_map = _PyDict_NewPresized(subset_len);\n\t\tdata_cb.is_subset = true;\n\t\tfor (; subset_len; subset_array++, subset_len--) {\n\t\t\tPyObject *set = PySet_New(NULL);\n\t\t\tPyDict_SetItem(data_cb.user_map, *subset_array, set);\n\t\t\tPy_DECREF(set);\n\t\t}\n\t\tPy_DECREF(subset_fast);\n\t}\n\telse {\n\t\tdata_cb.user_map = PyDict_New();\n\t}\n\n\tdata_cb.types_bitmap = key_types_bitmap;\n\n\tListBase *lb_array[MAX_LIBARRAY];\n\tint lb_index;\n\tlb_index = set_listbasepointers(bmain, lb_array);\n\n\twhile (lb_index--) {\n\n\t\tif (val_types_bitmap && lb_array[lb_index]->first) {\n\t\t\tif (!id_check_type(lb_array[lb_index]->first, val_types_bitmap)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tfor (ID *id = lb_array[lb_index]->first; id; id = id->next) {\n\t\t\t/* One-time init, ID is just used as placeholder here, we abuse this in iterator callback\n\t\t\t * to avoid having to rebuild a complete bpyrna object each time for the key searching\n\t\t\t * (where only ID pointer value is used). */\n\t\t\tif (data_cb.py_id_key_lookup_only == NULL) {\n\t\t\t\tdata_cb.py_id_key_lookup_only = pyrna_id_CreatePyObject(id);\n\t\t\t}\n\n\t\t\tif (!data_cb.is_subset) {\n\t\t\t\tPyObject *key = data_cb.py_id_key_lookup_only;\n\t\t\t\tPyObject *set;\n\n\t\t\t\tRNA_id_pointer_create(id, &((BPy_StructRNA *)key)->ptr);\n\n\t\t\t\t/* We have to insert the key now, otherwise ID unused would be missing from final dict... */\n\t\t\t\tif ((set = PyDict_GetItem(data_cb.user_map, key)) == NULL) {\n\t\t\t\t\t/* Cannot use our placeholder key here! */\n\t\t\t\t\tkey = pyrna_id_CreatePyObject(id);\n\t\t\t\t\tset = PySet_New(NULL);\n\t\t\t\t\tPyDict_SetItem(data_cb.user_map, key, set);\n\t\t\t\t\tPy_DECREF(set);\n\t\t\t\t\tPy_DECREF(key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdata_cb.id_curr = id;\n\t\t\tBKE_library_foreach_ID_link(NULL, id, foreach_libblock_id_user_map_callback, &data_cb, IDWALK_CB_NOP);\n\n\t\t\tif (data_cb.py_id_curr) {\n\t\t\t\tPy_DECREF(data_cb.py_id_curr);\n\t\t\t\tdata_cb.py_id_curr = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = data_cb.user_map;\n\n\nerror:\n\n\tPy_XDECREF(data_cb.py_id_key_lookup_only);\n\n\tif (key_types_bitmap) {\n\t\tMEM_freeN(key_types_bitmap);\n\t}\n\n\tif (val_types_bitmap) {\n\t\tMEM_freeN(val_types_bitmap);\n\t}\n\n\treturn ret;\n\n}", "item_id": 1, "repo": "1-MillionParanoidTterabytes/Blender-2.79b-blackened", "file": "source/blender/python/intern/bpy_rna_id_collection.c", "last_update_at": "2018-06-18T01:50:32+00:00", "question_id": "72705ffb3fb44e73e2627954d282445331a96524_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static PyObject *bpy_user_map(PyObject *UNUSED(self), PyObject *args, PyObject *kwds)\n{\n#if 0  /* If someone knows how to get a proper 'self' in that case... */\n\tBPy_StructRNA *pyrna = (BPy_StructRNA *)self;\n\tMain *bmain = pyrna->ptr.data;\n#else\n\tMain *bmain = G.main;  /* XXX Ugly, but should work! */\n#endif\n\tstatic const char *kwlist[] = {\"subset\", \"key_types\", \"value_types\", NULL};\n\tPyObject *subset = NULL;\n\tPyObject *key_types = NULL;\n\tPyObject *val_types = NULL;\n\tBLI_bitmap *key_types_bitmap = NULL;\n\tBLI_bitmap *val_types_bitmap = NULL;\n\tPyObject *ret = NULL;\n\tif (!PyArg_ParseTupleAndKeywords(\n\t        args, kwds, \"|O$O!O!:user_map\", (char **)kwlist,\n\t        &subset,\n\t        &PySet_Type, &key_types,\n\t        &PySet_Type, &val_types))\n\t{\n\t\treturn NULL;\n\t}\n\tif (key_types) {\n\t\tkey_types_bitmap = pyrna_set_to_enum_bitmap(\n\t\t        rna_enum_id_type_items, key_types, sizeof(short), true, USHRT_MAX, \"key types\");\n\t\tif (key_types_bitmap == NULL) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\tif (val_types) {\n\t\tval_types_bitmap = pyrna_set_to_enum_bitmap(\n\t\t        rna_enum_id_type_items, val_types, sizeof(short), true, USHRT_MAX, \"value types\");\n\t\tif (val_types_bitmap == NULL) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\tIDUserMapData data_cb = {NULL};\n\tif (subset) {\n\t\tPyObject *subset_fast = PySequence_Fast(subset, \"user_map\");\n\t\tif (subset_fast == NULL) {\n\t\t\tgoto error;\n\t\t}\n\t\tPyObject **subset_array = PySequence_Fast_ITEMS(subset_fast);\n\t\tPy_ssize_t subset_len = PySequence_Fast_GET_SIZE(subset_fast);\n\t\tdata_cb.user_map = _PyDict_NewPresized(subset_len);\n\t\tdata_cb.is_subset = true;\n\t\tfor (; subset_len; subset_array++, subset_len--) {\n\t\t\tPyObject *set = PySet_New(NULL);\n\t\t\tPyDict_SetItem(data_cb.user_map, *subset_array, set);\n\t\t\tPy_DECREF(set);\n\t\t}\n\t\tPy_DECREF(subset_fast);\n\t}\n\telse {\n\t\tdata_cb.user_map = PyDict_New();\n\t}\n\tdata_cb.types_bitmap = key_types_bitmap;\n\tListBase *lb_array[MAX_LIBARRAY];\n\tint lb_index;\n\tlb_index = set_listbasepointers(bmain, lb_array);\n\twhile (lb_index--) {\n\t\tif (val_types_bitmap && lb_array[lb_index]->first) {\n\t\t\tif (!id_check_type(lb_array[lb_index]->first, val_types_bitmap)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor (ID *id = lb_array[lb_index]->first; id; id = id->next) {\n\t\t\t/* One-time init, ID is just used as placeholder here, we abuse this in iterator callback\n\t\t\t * to avoid having to rebuild a complete bpyrna object each time for the key searching\n\t\t\t * (where only ID pointer value is used). */\n\t\t\tif (data_cb.py_id_key_lookup_only == NULL) {\n\t\t\t\tdata_cb.py_id_key_lookup_only = pyrna_id_CreatePyObject(id);\n\t\t\t}\n\t\t\tif (!data_cb.is_subset) {\n\t\t\t\tPyObject *key = data_cb.py_id_key_lookup_only;\n\t\t\t\tPyObject *set;\n\t\t\t\tRNA_id_pointer_create(id, &((BPy_StructRNA *)key)->ptr);\n\t\t\t\t/* We have to insert the key now, otherwise ID unused would be missing from final dict... */\n\t\t\t\tif ((set = PyDict_GetItem(data_cb.user_map, key)) == NULL) {\n\t\t\t\t\t/* Cannot use our placeholder key here! */\n\t\t\t\t\tkey = pyrna_id_CreatePyObject(id);\n\t\t\t\t\tset = PySet_New(NULL);\n\t\t\t\t\tPyDict_SetItem(data_cb.user_map, key, set);\n\t\t\t\t\tPy_DECREF(set);\n\t\t\t\t\tPy_DECREF(key);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdata_cb.id_curr = id;\n\t\t\tBKE_library_foreach_ID_link(NULL, id, foreach_libblock_id_user_map_callback, &data_cb, IDWALK_CB_NOP);\n\t\t\tif (data_cb.py_id_curr) {\n\t\t\t\tPy_DECREF(data_cb.py_id_curr);\n\t\t\t\tdata_cb.py_id_curr = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tret = data_cb.user_map;\nerror:\n\tPy_XDECREF(data_cb.py_id_key_lookup_only);\n\tif (key_types_bitmap) {\n\t\tMEM_freeN(key_types_bitmap);\n\t}\n\tif (val_types_bitmap) {\n\t\tMEM_freeN(val_types_bitmap);\n\t}\n\treturn ret;\n"]], "pred": {"ppl": 2.02890682220459, "ppl_lower": 2.652135133743286, "ppl/lowercase_ppl": -1.3786133904084614, "ppl/zlib": 0.000514169430795917, "Min_5.0% Prob": 6.279576731663124, "Min_10.0% Prob": 4.844015979299359, "Min_20.0% Prob": 3.2763641356837514, "Min_30.0% Prob": 2.328462826757649, "Min_40.0% Prob": 1.7639060771334143, "Min_50.0% Prob": 1.4152523763167968, "Min_60.0% Prob": 1.1804626867510104}}
{"hexsha": "ab79fb02978eae62b2787b88284693886a925492", "ext": "c", "lang": "C", "content": "int iaxc_callback(iaxc_event e)\n{\n\t//printf(\"Received iaxc event type 0x%x\\n\", e.type);\n\tswitch ( e.type ) \n\t{\n\tcase IAXC_EVENT_LEVELS:\n\t\treturn levels_callback(e.ev.levels.input, e.ev.levels.output);\n\tcase IAXC_EVENT_NETSTAT:\n\t\treturn netstat_callback(e.ev.netstats);\n\tcase IAXC_EVENT_TEXT:\n\t\tprocess_text_message(e.ev.text.message);\n\t\tbreak;\n\tcase IAXC_EVENT_STATE:\n\t\treturn state_callback(e.ev.call);\n\tcase IAXC_EVENT_VIDEO:\n\t\tif ( !video )\n\t\t\treturn 0;\n\n\t\tif ( !e.ev.video.encoded )\n\t\t\treturn display_video(e.ev.video,\n\t\t\t\t\te.ev.video.source == IAXC_SOURCE_REMOTE);\n\t\telse\n\t\t\tfprintf(stderr, \"We cannot handle encoded video in callbacks yet\\n\");\n\t\tbreak;\n\n\tcase IAXC_EVENT_AUDIO:\n\t\tfprintf(stderr, \"Got %s %s audio\\n\",\n\t\t\t\te.ev.audio.source == IAXC_SOURCE_REMOTE ? \"remote\" : \"local\",\n\t\t\t\te.ev.audio.encoded ? \"encoded\" : \"raw\");\n\t\tbreak;\n\tcase IAXC_EVENT_VIDCAP_ERROR:\n\t\tfprintf(stderr, \"\\nVIDEO CAPTURE DEVICE ERROR\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}", "item_id": 6, "repo": "tamiel/iaxclient", "file": "simpleclient/vtestcall/vtestcall.c", "last_update_at": "2018-05-08T12:04:06+00:00", "question_id": "ab79fb02978eae62b2787b88284693886a925492_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int iaxc_callback(iaxc_event e)\n{\n\t//printf(\"Received iaxc event type 0x%x\\n\", e.type);\n\tswitch ( e.type ) \n\t{\n\tcase IAXC_EVENT_LEVELS:\n\t\treturn levels_callback(e.ev.levels.input, e.ev.levels.output);\n\tcase IAXC_EVENT_NETSTAT:\n\t\treturn netstat_callback(e.ev.netstats);\n\tcase IAXC_EVENT_TEXT:\n\t\tprocess_text_message(e.ev.text.message);\n\t\tbreak;\n\tcase IAXC_EVENT_STATE:\n\t\treturn state_callback(e.ev.call);\n\tcase IAXC_EVENT_VIDEO:\n\t\tif ( !video )\n\t\t\treturn 0;\n\t\tif ( !e.ev.video.encoded )\n\t\t\treturn display_video(e.ev.video,\n\t\t\t\t\te.ev.video.source == IAXC_SOURCE_REMOTE);\n\t\telse\n\t\t\tfprintf(stderr, \"We cannot handle encoded video in callbacks yet\\n\");\n\t\tbreak;\n\tcase IAXC_EVENT_AUDIO:\n\t\tfprintf(stderr, \"Got %s %s audio\\n\",\n\t\t\t\te.ev.audio.source == IAXC_SOURCE_REMOTE ? \"remote\" : \"local\",\n\t\t\t\te.ev.audio.encoded ? \"encoded\" : \"raw\");\n\t\tbreak;\n\tcase IAXC_EVENT_VIDCAP_ERROR:\n\t\tfprintf(stderr, \"\\nVIDEO CAPTURE DEVICE ERROR\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n"]], "pred": {"ppl": 2.302076816558838, "ppl_lower": 2.4148824214935303, "ppl/lowercase_ppl": -1.0573737705155246, "ppl/zlib": 0.0018653505128184325, "Min_5.0% Prob": 6.739217021248558, "Min_10.0% Prob": 5.417465485466851, "Min_20.0% Prob": 3.6706360630936676, "Min_30.0% Prob": 2.6760271833661724, "Min_40.0% Prob": 2.0584792471849003, "Min_50.0% Prob": 1.6590169836979425, "Min_60.0% Prob": 1.3898222126448765}}
{"hexsha": "520d6b876aee995fd379a8d816e32ad6d684b86d", "ext": "c", "lang": "C", "content": "void hwInit(void)\n{\n  qbufferInit();\n  ledInit();\n\n  uartInit();\n  dxlportInit();\n  flashInit();\n  resetInit();\n}", "item_id": 0, "repo": "ROBOTIS-GIT/XelNetwork_PowerXel", "file": "powerXel_boot/src/hw/hw.c", "last_update_at": "2018-09-18T08:59:25+00:00", "question_id": "520d6b876aee995fd379a8d816e32ad6d684b86d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void hwInit(void)\n{\n  qbufferInit();\n  ledInit();\n  uartInit();\n  dxlportInit();\n  flashInit();\n  resetInit();\n"]], "pred": {"ppl": 7.238096714019775, "ppl_lower": 8.886659622192383, "ppl/lowercase_ppl": -1.1036663992018734, "ppl/zlib": 0.026748084959911614, "Min_5.0% Prob": 9.155189037322998, "Min_10.0% Prob": 8.743744373321533, "Min_20.0% Prob": 7.062986400392321, "Min_30.0% Prob": 5.724744209876428, "Min_40.0% Prob": 4.578259242905511, "Min_50.0% Prob": 3.7911704856416453, "Min_60.0% Prob": 3.3093233737680645}}
{"hexsha": "ed476dc8604ce07efd20e09a32f4cd8f05cdf2e8", "ext": "c", "lang": "C", "content": "static int feature_node_lua_get_exons(lua_State *L)\n{\n  GtGenomeNode **gn = check_genome_node(L, 1);\n  GtArray *exons = gt_array_new(sizeof (GtGenomeNode*));\n  unsigned long i = 0;\n  GtFeatureNode *fn;\n  /* make sure we get a feature node */\n  fn = gt_feature_node_try_cast(*gn);\n  luaL_argcheck(L, fn, 1, \"not a feature node\");\n  gt_feature_node_get_exons(fn, exons);\n  lua_newtable(L);\n  for (i = 0; i < gt_array_size(exons); i++) {\n    lua_pushnumber(L, i+1);\n    gt_lua_genome_node_push(L, (GtGenomeNode*)\n                            gt_genome_node_ref(*(GtGenomeNode**)\n                                               gt_array_get(exons, i)));\n    lua_rawset(L, -3);\n  }\n  gt_array_delete(exons);\n  return 1;\n}", "item_id": 8, "repo": "thmourikis/erv_annotator", "file": "dist/linux/genometools/src/gtlua/genome_node_lua.c", "last_update_at": "2018-09-30T00:45:55+00:00", "question_id": "ed476dc8604ce07efd20e09a32f4cd8f05cdf2e8_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int feature_node_lua_get_exons(lua_State *L)\n{\n  GtGenomeNode **gn = check_genome_node(L, 1);\n  GtArray *exons = gt_array_new(sizeof (GtGenomeNode*));\n  unsigned long i = 0;\n  GtFeatureNode *fn;\n  /* make sure we get a feature node */\n  fn = gt_feature_node_try_cast(*gn);\n  luaL_argcheck(L, fn, 1, \"not a feature node\");\n  gt_feature_node_get_exons(fn, exons);\n  lua_newtable(L);\n  for (i = 0; i < gt_array_size(exons); i++) {\n    lua_pushnumber(L, i+1);\n    gt_lua_genome_node_push(L, (GtGenomeNode*)\n                            gt_genome_node_ref(*(GtGenomeNode**)\n                                               gt_array_get(exons, i)));\n    lua_rawset(L, -3);\n  }\n  gt_array_delete(exons);\n  return 1;\n"]], "pred": {"ppl": 1.6282750368118286, "ppl_lower": 2.1085684299468994, "ppl/lowercase_ppl": -1.5302088522447908, "ppl/zlib": 0.001455287148781918, "Min_5.0% Prob": 6.266344342912946, "Min_10.0% Prob": 4.04147169507783, "Min_20.0% Prob": 2.3274661974381594, "Min_30.0% Prob": 1.6103543802426104, "Min_40.0% Prob": 1.218930889954086, "Min_50.0% Prob": 0.976910153272618, "Min_60.0% Prob": 0.8139497071488984}}
{"hexsha": "48dc05815cd8d08cc9c305eda4489aa53a919a18", "ext": "c", "lang": "C", "content": "static int\nbcmtm_egr_sp_thd_init(int unit)\n{\n    bcmdrd_sid_t sid = 0;\n    bcmdrd_fid_t fid;\n    bcmltd_sid_t ltid = TM_THD_EGR_SERVICE_POOLt;\n    size_t num_fid = TM_THD_EGR_SERVICE_POOLt_FIELD_COUNT;\n    size_t count = 0;\n    bcmbd_pt_dyn_info_t pt_dyn_info;\n    uint32_t limit = 0;\n    uint32_t ltmbuf = 0;\n    uint32_t fval = 0;\n    int pipe = 0;\n\n    SHR_FUNC_ENTER(unit);\n\n    limit = bcmtm_device_info[unit].num_cells - (44 + bcmtm_dev_buf_info.asf_rsvd) - 44;\n    while(count < num_fid) {\n        if (count == TM_THD_EGR_SERVICE_POOLt_TM_THD_SERVICE_POOL_IDf) {\n            count++;\n            continue;\n        }\n        ltmbuf = 0;\n        switch(count) {\n            case TM_THD_EGR_SERVICE_POOLt_SHARED_LIMIT_CELLSf:\n                sid = MMU_THDM_DB_POOL_SHARED_LIMITr;\n                fid = SHARED_LIMITf;\n                fval = limit;\n                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));\n                break;\n            case TM_THD_EGR_SERVICE_POOLt_SHARED_RESUME_LIMIT_CELLSf:\n                sid = MMU_THDM_DB_POOL_RESUME_LIMITr;\n                fid = RESUME_LIMITf;\n                fval = limit/8;\n                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));\n                break;\n            case TM_THD_EGR_SERVICE_POOLt_YELLOW_SHARED_LIMIT_CELLSf:\n                sid = MMU_THDM_DB_POOL_YELLOW_SHARED_LIMITr;\n                fid = YELLOW_SHARED_LIMITf;\n                fval = limit/8;\n                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));\n                break;\n            case TM_THD_EGR_SERVICE_POOLt_YELLOW_SHARED_RESUME_LIMIT_CELLSf:\n                sid = MMU_THDM_DB_POOL_YELLOW_RESUME_LIMITr;\n                fid = YELLOW_RESUME_LIMITf;\n                fval = limit/8;\n                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));\n                break;\n            case TM_THD_EGR_SERVICE_POOLt_RED_SHARED_LIMIT_CELLSf:\n                sid = MMU_THDM_DB_POOL_RED_SHARED_LIMITr;\n                fid = RED_SHARED_LIMITf;\n                fval = limit/8;\n                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));\n                break;\n            case TM_THD_EGR_SERVICE_POOLt_RED_SHARED_RESUME_LIMIT_CELLSf:\n                sid = MMU_THDM_DB_POOL_RED_RESUME_LIMITr;\n                fid = RED_RESUME_LIMITf;\n                fval = limit/8;\n                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));\n                break;\n            default:\n                sid = 0;\n                break;\n        }\n        for (pipe = 0; pipe < 4 && sid != 0 ; pipe++) {\n            BCMTM_PT_DYN_INFO(pt_dyn_info, 0, pipe);\n                SHR_IF_ERR_EXIT(bcmtm_pt_indexed_write(unit, sid, ltid,\n                            (void*)&pt_dyn_info, &ltmbuf));\n        }\n        count++;\n    }\nexit:\n    SHR_FUNC_EXIT();\n}", "item_id": 9, "repo": "lguohan/SDKLT", "file": "src/bcmtm/chip/bcm56960_a0/bcm56960_a0_bcmtm_thd.c", "last_update_at": "2018-01-31T07:21:49+00:00", "question_id": "48dc05815cd8d08cc9c305eda4489aa53a919a18_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nbcmtm_egr_sp_thd_init(int unit)\n{\n    bcmdrd_sid_t sid = 0;\n    bcmdrd_fid_t fid;\n    bcmltd_sid_t ltid = TM_THD_EGR_SERVICE_POOLt;\n    size_t num_fid = TM_THD_EGR_SERVICE_POOLt_FIELD_COUNT;\n    size_t count = 0;\n    bcmbd_pt_dyn_info_t pt_dyn_info;\n    uint32_t limit = 0;\n    uint32_t ltmbuf = 0;\n    uint32_t fval = 0;\n    int pipe = 0;\n    SHR_FUNC_ENTER(unit);\n    limit = bcmtm_device_info[unit].num_cells - (44 + bcmtm_dev_buf_info.asf_rsvd) - 44;\n    while(count < num_fid) {\n        if (count == TM_THD_EGR_SERVICE_POOLt_TM_THD_SERVICE_POOL_IDf) {\n            count++;\n            continue;\n        }\n        ltmbuf = 0;\n        switch(count) {\n            case TM_THD_EGR_SERVICE_POOLt_SHARED_LIMIT_CELLSf:\n                sid = MMU_THDM_DB_POOL_SHARED_LIMITr;\n                fid = SHARED_LIMITf;\n                fval = limit;\n                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));\n                break;\n            case TM_THD_EGR_SERVICE_POOLt_SHARED_RESUME_LIMIT_CELLSf:\n                sid = MMU_THDM_DB_POOL_RESUME_LIMITr;\n                fid = RESUME_LIMITf;\n                fval = limit/8;\n                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));\n                break;\n            case TM_THD_EGR_SERVICE_POOLt_YELLOW_SHARED_LIMIT_CELLSf:\n                sid = MMU_THDM_DB_POOL_YELLOW_SHARED_LIMITr;\n                fid = YELLOW_SHARED_LIMITf;\n                fval = limit/8;\n                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));\n                break;\n            case TM_THD_EGR_SERVICE_POOLt_YELLOW_SHARED_RESUME_LIMIT_CELLSf:\n                sid = MMU_THDM_DB_POOL_YELLOW_RESUME_LIMITr;\n                fid = YELLOW_RESUME_LIMITf;\n                fval = limit/8;\n                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));\n                break;\n            case TM_THD_EGR_SERVICE_POOLt_RED_SHARED_LIMIT_CELLSf:\n                sid = MMU_THDM_DB_POOL_RED_SHARED_LIMITr;\n                fid = RED_SHARED_LIMITf;\n                fval = limit/8;\n                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));\n                break;\n            case TM_THD_EGR_SERVICE_POOLt_RED_SHARED_RESUME_LIMIT_CELLSf:\n                sid = MMU_THDM_DB_POOL_RED_RESUME_LIMITr;\n                fid = RED_RESUME_LIMITf;\n                fval = limit/8;\n                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));\n                break;\n            default:\n                sid = 0;\n                break;\n        }\n        for (pipe = 0; pipe < 4 && sid != 0 ; pipe++) {\n            BCMTM_PT_DYN_INFO(pt_dyn_info, 0, pipe);\n                SHR_IF_ERR_EXIT(bcmtm_pt_indexed_write(unit, sid, ltid,\n                            (void*)&pt_dyn_info, &ltmbuf));\n        }\n        count++;\n    }\nexit:\n    SHR_FUNC_EXIT();\n"]], "pred": {"ppl": 1.3326852321624756, "ppl_lower": 1.581273078918457, "ppl/lowercase_ppl": -1.5955321897471055, "ppl/zlib": 0.0004551440228216519, "Min_5.0% Prob": 4.457468182432885, "Min_10.0% Prob": 2.746431881306218, "Min_20.0% Prob": 1.433002831058248, "Min_30.0% Prob": 0.9594142372184281, "Min_40.0% Prob": 0.7182052645628503, "Min_50.0% Prob": 0.574921350484392, "Min_60.0% Prob": 0.4792763831254477}}
{"hexsha": "bde7fdb25304bec4c2eb661993c355f21401164d", "ext": "c", "lang": "C", "content": "void* dR_list_next(dR_List* list)\n{\n    void* ret;\n    if(list->iterator!=NULL)\n    {\n        if(list->iterator->next == NULL)\n        {\n            list->iterator = NULL;\n            ret = NULL;\n        }\n        else\n        {\n            list->iterator = list->iterator->next;\n            ret = list->iterator->element;\n        }\n    }\n    else\n    {\n        list->iterator = list->first;\n        if(list->iterator!=NULL)\n        {\n            ret = list->iterator->element;\n        }\n        else\n        {\n            ret = NULL;\n        }\n    }\n    return ret;\n}", "item_id": 18, "repo": "mrjel/deepracin", "file": "src/dR_core.c", "last_update_at": "2018-10-22T18:13:30+00:00", "question_id": "bde7fdb25304bec4c2eb661993c355f21401164d_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void* dR_list_next(dR_List* list)\n{\n    void* ret;\n    if(list->iterator!=NULL)\n    {\n        if(list->iterator->next == NULL)\n        {\n            list->iterator = NULL;\n            ret = NULL;\n        }\n        else\n        {\n            list->iterator = list->iterator->next;\n            ret = list->iterator->element;\n        }\n    }\n    else\n    {\n        list->iterator = list->first;\n        if(list->iterator!=NULL)\n        {\n            ret = list->iterator->element;\n        }\n        else\n        {\n            ret = NULL;\n        }\n    }\n    return ret;\n"]], "pred": {"ppl": 1.848656415939331, "ppl_lower": 1.8679578304290771, "ppl/lowercase_ppl": -1.016903730493134, "ppl/zlib": 0.0036574947236908484, "Min_5.0% Prob": 6.557530045509338, "Min_10.0% Prob": 4.641406346769894, "Min_20.0% Prob": 2.8489601419252506, "Min_30.0% Prob": 1.9930570709939097, "Min_40.0% Prob": 1.5173076885368895, "Min_50.0% Prob": 1.2216046155375593, "Min_60.0% Prob": 1.0209950738422133}}
{"hexsha": "bd6433558eb0d8ef557e592dcd1761355c44422c", "ext": "c", "lang": "C", "content": "static void powerdown_cleanup(int toi_or_resume)\n{\n\tif (!toi_or_resume)\n\t\treturn;\n\n\tCLOSE_FILE(lid_file);\n\tCLOSE_FILE(alarm_file);\n\tCLOSE_FILE(epoch_file);\n}", "item_id": 2, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/kernel/power/tuxonice_power_off.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "bd6433558eb0d8ef557e592dcd1761355c44422c_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void powerdown_cleanup(int toi_or_resume)\n{\n\tif (!toi_or_resume)\n\t\treturn;\n\tCLOSE_FILE(lid_file);\n\tCLOSE_FILE(alarm_file);\n\tCLOSE_FILE(epoch_file);\n"]], "pred": {"ppl": 4.6965556144714355, "ppl_lower": 5.222105026245117, "ppl/lowercase_ppl": -1.068573296328807, "ppl/zlib": 0.013334736138507408, "Min_5.0% Prob": 8.8257417678833, "Min_10.0% Prob": 7.86974252973284, "Min_20.0% Prob": 6.342987982432048, "Min_30.0% Prob": 4.803481055342632, "Min_40.0% Prob": 3.769490393900102, "Min_50.0% Prob": 3.0613203186255236, "Min_60.0% Prob": 2.6136322994918926}}
{"hexsha": "8c898955d4ab7621c3ef57b0340db119fe3ec01e", "ext": "h", "lang": "C", "content": "namespace mlperf {\n\n/// \\addtogroup LoadgenAPI\n/// @{\n\n/// \\brief Represents a unique identifier for a sample of an issued query.\n/// \\details As currently implemented, the id is a pointer to an internal\n/// loadgen struct.\ntypedef uintptr_t ResponseId;\n\n/// \\brief An index into the QuerySampleLibrary corresponding to a\n/// single sample.\ntypedef size_t QuerySampleIndex;\n\n/// \\brief Represents the smallest unit of input inference can run on.\n/// A query consists of one or more samples.\nstruct QuerySample {\n  ResponseId id;\n  QuerySampleIndex index;\n};\n\n/// \\brief Represents a single response to QuerySample\nstruct QuerySampleResponse {\n  ResponseId id;\n  uintptr_t data;\n  size_t size;  ///< Size in bytes.\n};\n\n/// \\brief A latency in nanoseconds, as recorded by the loadgen.\ntypedef int64_t QuerySampleLatency;\n\n/// @}\n\n}", "item_id": 0, "repo": "goldgeisser/inference", "file": "loadgen/query_sample.h", "last_update_at": "2018-11-20T16:59:07+00:00", "question_id": "8c898955d4ab7621c3ef57b0340db119fe3ec01e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace mlperf {\n/// \\addtogroup LoadgenAPI\n/// @{\n/// \\brief Represents a unique identifier for a sample of an issued query.\n/// \\details As currently implemented, the id is a pointer to an internal\n/// loadgen struct.\ntypedef uintptr_t ResponseId;\n/// \\brief An index into the QuerySampleLibrary corresponding to a\n/// single sample.\ntypedef size_t QuerySampleIndex;\n/// \\brief Represents the smallest unit of input inference can run on.\n/// A query consists of one or more samples.\nstruct QuerySample {\n  ResponseId id;\n  QuerySampleIndex index;\n};\n/// \\brief Represents a single response to QuerySample\nstruct QuerySampleResponse {\n  ResponseId id;\n  uintptr_t data;\n  size_t size;  ///< Size in bytes.\n};\n/// \\brief A latency in nanoseconds, as recorded by the loadgen.\ntypedef int64_t QuerySampleLatency;\n/// @}\n"]], "pred": {"ppl": 3.8849918842315674, "ppl_lower": 4.422055244445801, "ppl/lowercase_ppl": -1.0954105718404599, "ppl/zlib": 0.003350915789670482, "Min_5.0% Prob": 8.381256103515625, "Min_10.0% Prob": 6.796259994506836, "Min_20.0% Prob": 5.0995643520355225, "Min_30.0% Prob": 4.034611167907715, "Min_40.0% Prob": 3.236338426571081, "Min_50.0% Prob": 2.6831580334239535, "Min_60.0% Prob": 2.264521023937014}}
{"hexsha": "7ee707011970a3ed2b3f554e4a47167bedd6b9ce", "ext": "c", "lang": "C", "content": "static short\nFUNC_STDCALL(rb_dl_callback_short_18_3_stdcall)(DLSTACK_TYPE stack0, DLSTACK_TYPE stack1, DLSTACK_TYPE stack2, DLSTACK_TYPE stack3, DLSTACK_TYPE stack4, DLSTACK_TYPE stack5, DLSTACK_TYPE stack6, DLSTACK_TYPE stack7, DLSTACK_TYPE stack8, DLSTACK_TYPE stack9, DLSTACK_TYPE stack10, DLSTACK_TYPE stack11, DLSTACK_TYPE stack12, DLSTACK_TYPE stack13, DLSTACK_TYPE stack14, DLSTACK_TYPE stack15, DLSTACK_TYPE stack16, DLSTACK_TYPE stack17)\n{\n    VALUE ret, cb, args[18];\n\n    args[0] = PTR2NUM(stack0);\n    args[1] = PTR2NUM(stack1);\n    args[2] = PTR2NUM(stack2);\n    args[3] = PTR2NUM(stack3);\n    args[4] = PTR2NUM(stack4);\n    args[5] = PTR2NUM(stack5);\n    args[6] = PTR2NUM(stack6);\n    args[7] = PTR2NUM(stack7);\n    args[8] = PTR2NUM(stack8);\n    args[9] = PTR2NUM(stack9);\n    args[10] = PTR2NUM(stack10);\n    args[11] = PTR2NUM(stack11);\n    args[12] = PTR2NUM(stack12);\n    args[13] = PTR2NUM(stack13);\n    args[14] = PTR2NUM(stack14);\n    args[15] = PTR2NUM(stack15);\n    args[16] = PTR2NUM(stack16);\n    args[17] = PTR2NUM(stack17);\n    cb = rb_ary_entry(rb_ary_entry(rb_DLStdcallCallbackProcs, 3), 78);\n    ret = rb_funcall2(cb, rb_dl_cb_call, 18, args);\n    return NUM2INT(ret);\n}", "item_id": 193, "repo": "ArekX/RAGE", "file": "win32/deps/ruby211/ext/dl/callback-3.c", "last_update_at": "2018-03-26T13:27:36+00:00", "question_id": "7ee707011970a3ed2b3f554e4a47167bedd6b9ce_193", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static short\nFUNC_STDCALL(rb_dl_callback_short_18_3_stdcall)(DLSTACK_TYPE stack0, DLSTACK_TYPE stack1, DLSTACK_TYPE stack2, DLSTACK_TYPE stack3, DLSTACK_TYPE stack4, DLSTACK_TYPE stack5, DLSTACK_TYPE stack6, DLSTACK_TYPE stack7, DLSTACK_TYPE stack8, DLSTACK_TYPE stack9, DLSTACK_TYPE stack10, DLSTACK_TYPE stack11, DLSTACK_TYPE stack12, DLSTACK_TYPE stack13, DLSTACK_TYPE stack14, DLSTACK_TYPE stack15, DLSTACK_TYPE stack16, DLSTACK_TYPE stack17)\n{\n    VALUE ret, cb, args[18];\n    args[0] = PTR2NUM(stack0);\n    args[1] = PTR2NUM(stack1);\n    args[2] = PTR2NUM(stack2);\n    args[3] = PTR2NUM(stack3);\n    args[4] = PTR2NUM(stack4);\n    args[5] = PTR2NUM(stack5);\n    args[6] = PTR2NUM(stack6);\n    args[7] = PTR2NUM(stack7);\n    args[8] = PTR2NUM(stack8);\n    args[9] = PTR2NUM(stack9);\n    args[10] = PTR2NUM(stack10);\n    args[11] = PTR2NUM(stack11);\n    args[12] = PTR2NUM(stack12);\n    args[13] = PTR2NUM(stack13);\n    args[14] = PTR2NUM(stack14);\n    args[15] = PTR2NUM(stack15);\n    args[16] = PTR2NUM(stack16);\n    args[17] = PTR2NUM(stack17);\n    cb = rb_ary_entry(rb_ary_entry(rb_DLStdcallCallbackProcs, 3), 78);\n    ret = rb_funcall2(cb, rb_dl_cb_call, 18, args);\n    return NUM2INT(ret);\n"]], "pred": {"ppl": 1.502982497215271, "ppl_lower": 1.6421869993209839, "ppl/lowercase_ppl": -1.217393804352082, "ppl/zlib": 0.0011776053915327858, "Min_5.0% Prob": 6.001613335950034, "Min_10.0% Prob": 3.8720492281411825, "Min_20.0% Prob": 2.0364485400189696, "Min_30.0% Prob": 1.3602886633880773, "Min_40.0% Prob": 1.0203648568741828, "Min_50.0% Prob": 0.8163159160986604, "Min_60.0% Prob": 0.6802714178878068}}
{"hexsha": "b547c6aa8c9230d64661ddfcd09bf26ca0a8fd0c", "ext": "h", "lang": "C", "content": "_pure_ static inline size_t\nstr_cmp(const char *restrict sa, const char *restrict sb)\n{\n    if (!sa || !sb)\n        return 1;\n\n    size_t i = 0;\n\n    while (sa[i] == sb[i])\n        if (!sa[i++])\n            return 0;\n\n    return i + 1;\n}", "item_id": 0, "repo": "frankurcrazy/glorytun", "file": "src/str.h", "last_update_at": "2018-10-26T08:46:57+00:00", "question_id": "b547c6aa8c9230d64661ddfcd09bf26ca0a8fd0c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["_pure_ static inline size_t\nstr_cmp(const char *restrict sa, const char *restrict sb)\n{\n    if (!sa || !sb)\n        return 1;\n    size_t i = 0;\n    while (sa[i] == sb[i])\n        if (!sa[i++])\n            return 0;\n    return i + 1;\n"]], "pred": {"ppl": 2.6649398803710938, "ppl_lower": 2.6649398803710938, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.006854416072749375, "Min_5.0% Prob": 7.322241187095642, "Min_10.0% Prob": 6.190763738420275, "Min_20.0% Prob": 4.092370259134393, "Min_30.0% Prob": 3.1049641221761703, "Min_40.0% Prob": 2.4074092507362366, "Min_50.0% Prob": 1.9420793967631955, "Min_60.0% Prob": 1.6443151715946824}}
{"hexsha": "f4de8b84c5c25188503c2672b3818a474ad0db9c", "ext": "c", "lang": "C", "content": "int lov_fini_setattr_set(struct lov_request_set *set)\n{\n\tint rc = 0;\n\n\tif (set == NULL)\n\t\treturn 0;\n\tLASSERT(set->set_exp);\n\tif (atomic_read(&set->set_completes)) {\n\t\trc = common_attr_done(set);\n\t\t/* FIXME update qos data here */\n\t}\n\n\tlov_put_reqset(set);\n\treturn rc;\n}", "item_id": 14, "repo": "SIIS-cloud/pileus", "file": "difc-kernel/pileus-kernel/drivers/staging/lustre/lustre/lov/lov_request.c", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "f4de8b84c5c25188503c2672b3818a474ad0db9c_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int lov_fini_setattr_set(struct lov_request_set *set)\n{\n\tint rc = 0;\n\tif (set == NULL)\n\t\treturn 0;\n\tLASSERT(set->set_exp);\n\tif (atomic_read(&set->set_completes)) {\n\t\trc = common_attr_done(set);\n\t\t/* FIXME update qos data here */\n\t}\n\tlov_put_reqset(set);\n\treturn rc;\n"]], "pred": {"ppl": 4.768845081329346, "ppl_lower": 6.229522705078125, "ppl/lowercase_ppl": -1.1710484941209751, "ppl/zlib": 0.007889414920553282, "Min_5.0% Prob": 8.864370584487915, "Min_10.0% Prob": 7.526673952738444, "Min_20.0% Prob": 5.9047461946805315, "Min_30.0% Prob": 4.573208357836749, "Min_40.0% Prob": 3.755581889833723, "Min_50.0% Prob": 3.0698700720264065, "Min_60.0% Prob": 2.603240225766156}}
{"hexsha": "595fd4e4d662637c48068d1689c2e5498f906458", "ext": "h", "lang": "C", "content": "void  test_pavgw_xmm1xmm2()\n{\n\tint foo[4] = { 10, 20, 30, 40 };\n\tclock_t t1 = clock();\n\tfor (int iterator = 0; iterator < 1000000; iterator++)\n\t{\n\t\trun_pavgw_xmm1xmm2_5_times(foo);\n\t}\n\tclock_t t2 = clock();\n\tfor (int iterator = 0; iterator < 1000000; iterator++)\n\t{\n\t\trun_pavgw_xmm1xmm2_105_times(foo);\n\t}\n\tclock_t t3 = clock();\n\tclock_t clk = (t3 - t2) - (t2 - t1);\n\tstd::cout << \"pavgw takes \" << clk << std::endl;\n}", "item_id": 22, "repo": "helloguo/intrinsictests", "file": "simpletests/simpletests/sse2.h", "last_update_at": "2018-06-18T13:29:24+00:00", "question_id": "595fd4e4d662637c48068d1689c2e5498f906458_22", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void  test_pavgw_xmm1xmm2()\n{\n\tint foo[4] = { 10, 20, 30, 40 };\n\tclock_t t1 = clock();\n\tfor (int iterator = 0; iterator < 1000000; iterator++)\n\t{\n\t\trun_pavgw_xmm1xmm2_5_times(foo);\n\t}\n\tclock_t t2 = clock();\n\tfor (int iterator = 0; iterator < 1000000; iterator++)\n\t{\n\t\trun_pavgw_xmm1xmm2_105_times(foo);\n\t}\n\tclock_t t3 = clock();\n\tclock_t clk = (t3 - t2) - (t2 - t1);\n\tstd::cout << \"pavgw takes \" << clk << std::endl;\n"]], "pred": {"ppl": 2.5280308723449707, "ppl_lower": 2.5280308723449707, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0046141327779692515, "Min_5.0% Prob": 8.268729383295232, "Min_10.0% Prob": 6.705220103263855, "Min_20.0% Prob": 4.258745177586873, "Min_30.0% Prob": 3.0289401474283704, "Min_40.0% Prob": 2.2947624197436705, "Min_50.0% Prob": 1.8549500503909908, "Min_60.0% Prob": 1.5427101506541172}}
{"hexsha": "8f5450d7db4523c033f5a329ad5ae1fd59048c7d", "ext": "c", "lang": "C", "content": "static char *\nGetMapIntString(struct Mapper mapper[], int state)\n{\n    struct Mapper *m;    \n    for (m = mapper; m->s != NULL; m++) {\n        if (m->i == state) {\n            return m->s;\n        }\n    }\n    return NULL;\n}", "item_id": 32, "repo": "tamiel/iaxclient", "file": "contrib/tcl/iaxclient.c", "last_update_at": "2018-05-08T12:04:06+00:00", "question_id": "8f5450d7db4523c033f5a329ad5ae1fd59048c7d_32", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static char *\nGetMapIntString(struct Mapper mapper[], int state)\n{\n    struct Mapper *m;    \n    for (m = mapper; m->s != NULL; m++) {\n        if (m->i == state) {\n            return m->s;\n        }\n    }\n    return NULL;\n"]], "pred": {"ppl": 3.5391199588775635, "ppl_lower": 3.9490511417388916, "ppl/lowercase_ppl": -1.0867150368202994, "ppl/zlib": 0.008716400669328647, "Min_5.0% Prob": 8.087116877237955, "Min_10.0% Prob": 7.079994133540562, "Min_20.0% Prob": 5.348258590698242, "Min_30.0% Prob": 3.979359932567762, "Min_40.0% Prob": 3.107268905447375, "Min_50.0% Prob": 2.5214645877862587, "Min_60.0% Prob": 2.1100474951115062}}
{"hexsha": "ca8ce3141cd6ceacd8760b28d4149c04f8e5519c", "ext": "c", "lang": "C", "content": "void FactVarSlotErrorMessage2(\n  Environment *theEnv,\n  Fact *theFact,\n  const char *varSlot)\n  {\n   char tempBuffer[20];\n   \n   PrintErrorID(theEnv,\"PRNTUTIL\",13,false);\n   \n   WriteString(theEnv,STDERR,\"The variable/slot reference ?\");\n   WriteString(theEnv,STDERR,varSlot);\n   WriteString(theEnv,STDERR,\" is invalid because the referenced fact \");\n   gensprintf(tempBuffer,\"f-%lld\",theFact->factIndex);\n   WriteString(theEnv,STDERR,tempBuffer);\n   WriteString(theEnv,STDERR,\" does not contain the specified slot.\\n\");\n  }", "item_id": 22, "repo": "Pointer2VoidStar/CLIPS", "file": "src/prntutil.c", "last_update_at": "2018-05-18T07:39:56+00:00", "question_id": "ca8ce3141cd6ceacd8760b28d4149c04f8e5519c_22", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void FactVarSlotErrorMessage2(\n  Environment *theEnv,\n  Fact *theFact,\n  const char *varSlot)\n  {\n   char tempBuffer[20];\n   PrintErrorID(theEnv,\"PRNTUTIL\",13,false);\n   WriteString(theEnv,STDERR,\"The variable/slot reference ?\");\n   WriteString(theEnv,STDERR,varSlot);\n   WriteString(theEnv,STDERR,\" is invalid because the referenced fact \");\n   gensprintf(tempBuffer,\"f-%lld\",theFact->factIndex);\n   WriteString(theEnv,STDERR,tempBuffer);\n   WriteString(theEnv,STDERR,\" does not contain the specified slot.\\n\");\n"]], "pred": {"ppl": 3.1893954277038574, "ppl_lower": 5.8417134284973145, "ppl/lowercase_ppl": -1.521793756381182, "ppl/zlib": 0.004172055315609322, "Min_5.0% Prob": 8.727570215861002, "Min_10.0% Prob": 6.848620944552952, "Min_20.0% Prob": 4.857299029827118, "Min_30.0% Prob": 3.66692414438283, "Min_40.0% Prob": 2.8678233517954745, "Min_50.0% Prob": 2.3128093159447114, "Min_60.0% Prob": 1.931530575449061}}
{"hexsha": "eb91c016cb7866a84c654e97ea1e6dbc2f17805f", "ext": "c", "lang": "C", "content": "void\n_Tick ( Context * cntx, int32 findWordFlag )\n{\n    byte * token = ( byte* ) _DataStack_Pop ( ) ;\n    if ( token )\n    {\n        Word * word = 0 ;\n        if ( findWordFlag ) \n        {\n            word = Finder_FindQualifiedIDWord ( cntx->Finder0, token ) ;\n        }\n        if ( word )\n        {\n            token = ( byte * ) word ;\n        }\n        else\n        {\n            Lexer * lexer = cntx->Lexer0 ;\n            Lexer_ParseObject ( lexer, token ) ; // create a string from a 'raw' token\n            if ( GetState ( lexer, KNOWN_OBJECT ) ) token = ( byte* ) lexer->Literal ;\n        }\n        //if ( ! Compiling ) __CfrTil_SourceCode_Init ( _CfrTil_ ) ;\n    }\n    DSP_Push ( ( int32 ) token ) ;\n}", "item_id": 9, "repo": "dennisj001/openvmtil", "file": "src/basis/context.c", "last_update_at": "2018-02-14T16:36:55+00:00", "question_id": "eb91c016cb7866a84c654e97ea1e6dbc2f17805f_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\n_Tick ( Context * cntx, int32 findWordFlag )\n{\n    byte * token = ( byte* ) _DataStack_Pop ( ) ;\n    if ( token )\n    {\n        Word * word = 0 ;\n        if ( findWordFlag ) \n        {\n            word = Finder_FindQualifiedIDWord ( cntx->Finder0, token ) ;\n        }\n        if ( word )\n        {\n            token = ( byte * ) word ;\n        }\n        else\n        {\n            Lexer * lexer = cntx->Lexer0 ;\n            Lexer_ParseObject ( lexer, token ) ; // create a string from a 'raw' token\n            if ( GetState ( lexer, KNOWN_OBJECT ) ) token = ( byte* ) lexer->Literal ;\n        }\n        //if ( ! Compiling ) __CfrTil_SourceCode_Init ( _CfrTil_ ) ;\n    }\n    DSP_Push ( ( int32 ) token ) ;\n"]], "pred": {"ppl": 4.373665809631348, "ppl_lower": 5.797937870025635, "ppl/lowercase_ppl": -1.191041277891734, "ppl/zlib": 0.004327277171559952, "Min_5.0% Prob": 8.698246757189432, "Min_10.0% Prob": 7.134910563627879, "Min_20.0% Prob": 5.412614326087796, "Min_30.0% Prob": 4.3195149441287946, "Min_40.0% Prob": 3.4900282323360443, "Min_50.0% Prob": 2.888747702284557, "Min_60.0% Prob": 2.4525234403253413}}
{"hexsha": "1ecfa9d89747e74a8c5dc7ee15b139f12a480d86", "ext": "c", "lang": "C", "content": "static int sign(OSSL_LIB_CTX *libctx, unsigned char **sig, size_t *sig_len)\n{\n    int rv = 0;\n    EVP_PKEY *pkey = NULL;\n    EVP_PKEY_CTX *ctx = NULL;\n    EVP_MD *md = NULL;\n    const unsigned char *ppriv_key = NULL;\n\n    *sig = NULL;\n\n    /* Load DER-encoded RSA private key. */\n    ppriv_key = rsa_priv_key;\n    pkey = d2i_PrivateKey_ex(EVP_PKEY_RSA, NULL, &ppriv_key,\n                             sizeof(rsa_priv_key), libctx, propq);\n    if (pkey == NULL) {\n        fprintf(stderr, \"Failed to load private key\\n\");\n        goto end;\n    }\n\n    /* Fetch hash algorithm we want to use. */\n    md = EVP_MD_fetch(libctx, \"SHA256\", propq);\n    if (md == NULL) {\n        fprintf(stderr, \"Failed to fetch hash algorithm\\n\");\n        goto end;\n    }\n\n    /* Create signing context. */\n    ctx = EVP_PKEY_CTX_new_from_pkey(libctx, pkey, propq);\n    if (ctx == NULL) {\n        fprintf(stderr, \"Failed to create signing context\\n\");\n        goto end;\n    }\n\n    /* Initialize context for signing and set options. */\n    if (EVP_PKEY_sign_init(ctx) == 0) {\n        fprintf(stderr, \"Failed to initialize signing context\\n\");\n        goto end;\n    }\n\n    if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PSS_PADDING) == 0) {\n        fprintf(stderr, \"Failed to configure padding\\n\");\n        goto end;\n    }\n\n    if (EVP_PKEY_CTX_set_signature_md(ctx, md) == 0) {\n        fprintf(stderr, \"Failed to configure digest type\\n\");\n        goto end;\n    }\n\n    /* Determine length of signature. */\n    if (EVP_PKEY_sign(ctx, NULL, sig_len,\n                      test_digest, sizeof(test_digest)) == 0) {\n        fprintf(stderr, \"Failed to get signature length\\n\");\n        goto end;\n    }\n\n    /* Allocate memory for signature. */\n    *sig = OPENSSL_malloc(*sig_len);\n    if (*sig == NULL) {\n        fprintf(stderr, \"Failed to allocate memory for signature\\n\");\n        goto end;\n    }\n\n    /* Generate signature. */\n    if (EVP_PKEY_sign(ctx, *sig, sig_len,\n                      test_digest, sizeof(test_digest)) != 1) {\n        fprintf(stderr, \"Failed to sign\\n\");\n        goto end;\n    }\n\n    rv = 1;\nend:\n    EVP_PKEY_CTX_free(ctx);\n    EVP_PKEY_free(pkey);\n    EVP_MD_free(md);\n\n    if (rv == 0)\n        OPENSSL_free(*sig);\n\n    return rv;\n}", "item_id": 0, "repo": "mbroz/openssl", "file": "demos/signature/rsa_pss_direct.c", "last_update_at": "2018-08-08T17:10:46+00:00", "question_id": "1ecfa9d89747e74a8c5dc7ee15b139f12a480d86_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int sign(OSSL_LIB_CTX *libctx, unsigned char **sig, size_t *sig_len)\n{\n    int rv = 0;\n    EVP_PKEY *pkey = NULL;\n    EVP_PKEY_CTX *ctx = NULL;\n    EVP_MD *md = NULL;\n    const unsigned char *ppriv_key = NULL;\n    *sig = NULL;\n    /* Load DER-encoded RSA private key. */\n    ppriv_key = rsa_priv_key;\n    pkey = d2i_PrivateKey_ex(EVP_PKEY_RSA, NULL, &ppriv_key,\n                             sizeof(rsa_priv_key), libctx, propq);\n    if (pkey == NULL) {\n        fprintf(stderr, \"Failed to load private key\\n\");\n        goto end;\n    }\n    /* Fetch hash algorithm we want to use. */\n    md = EVP_MD_fetch(libctx, \"SHA256\", propq);\n    if (md == NULL) {\n        fprintf(stderr, \"Failed to fetch hash algorithm\\n\");\n        goto end;\n    }\n    /* Create signing context. */\n    ctx = EVP_PKEY_CTX_new_from_pkey(libctx, pkey, propq);\n    if (ctx == NULL) {\n        fprintf(stderr, \"Failed to create signing context\\n\");\n        goto end;\n    }\n    /* Initialize context for signing and set options. */\n    if (EVP_PKEY_sign_init(ctx) == 0) {\n        fprintf(stderr, \"Failed to initialize signing context\\n\");\n        goto end;\n    }\n    if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PSS_PADDING) == 0) {\n        fprintf(stderr, \"Failed to configure padding\\n\");\n        goto end;\n    }\n    if (EVP_PKEY_CTX_set_signature_md(ctx, md) == 0) {\n        fprintf(stderr, \"Failed to configure digest type\\n\");\n        goto end;\n    }\n    /* Determine length of signature. */\n    if (EVP_PKEY_sign(ctx, NULL, sig_len,\n                      test_digest, sizeof(test_digest)) == 0) {\n        fprintf(stderr, \"Failed to get signature length\\n\");\n        goto end;\n    }\n    /* Allocate memory for signature. */\n    *sig = OPENSSL_malloc(*sig_len);\n    if (*sig == NULL) {\n        fprintf(stderr, \"Failed to allocate memory for signature\\n\");\n        goto end;\n    }\n    /* Generate signature. */\n    if (EVP_PKEY_sign(ctx, *sig, sig_len,\n                      test_digest, sizeof(test_digest)) != 1) {\n        fprintf(stderr, \"Failed to sign\\n\");\n        goto end;\n    }\n    rv = 1;\nend:\n    EVP_PKEY_CTX_free(ctx);\n    EVP_PKEY_free(pkey);\n    EVP_MD_free(md);\n    if (rv == 0)\n        OPENSSL_free(*sig);\n    return rv;\n"]], "pred": {"ppl": 1.39223051071167, "ppl_lower": 1.5649291276931763, "ppl/lowercase_ppl": -1.3533722191979332, "ppl/zlib": 0.000483076124055796, "Min_5.0% Prob": 4.346839305831165, "Min_10.0% Prob": 2.8676541742072046, "Min_20.0% Prob": 1.6064314378235869, "Min_30.0% Prob": 1.0972355748137155, "Min_40.0% Prob": 0.8261757158841104, "Min_50.0% Prob": 0.6614165254223976, "Min_60.0% Prob": 0.5522905013841007}}
{"hexsha": "51b1acc11ed44401ca88989699ae999d6b1f28a8", "ext": "h", "lang": "C", "content": "interface TRDeviceSetupServer : NSObject <TRTransferServerDelegate> {\n    NSMutableArray * _accountsToAuthenticate;\n    NSMutableDictionary * _cachedAuthInfo;\n    bool  _cancelledSetupInProgress;\n    NSData * _dataToSend;\n    NSObject<OS_dispatch_semaphore> * _dataToSendSemaphore;\n    <TRDeviceSetupServerDelegate> * _delegate;\n    int  _notifyToken;\n    bool  _notifyTokenIsValid;\n    bool  _setupInProgress;\n    bool  _started;\n    TRTransferServer * _transferServer;\n}", "item_id": 0, "repo": "shaojiankui/iOS10-Runtime-Headers", "file": "PrivateFrameworks/TouchRemote.framework/TRDeviceSetupServer.h", "last_update_at": "2018-10-08T04:12:25+00:00", "question_id": "51b1acc11ed44401ca88989699ae999d6b1f28a8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface TRDeviceSetupServer : NSObject <TRTransferServerDelegate> {\n    NSMutableArray * _accountsToAuthenticate;\n    NSMutableDictionary * _cachedAuthInfo;\n    bool  _cancelledSetupInProgress;\n    NSData * _dataToSend;\n    NSObject<OS_dispatch_semaphore> * _dataToSendSemaphore;\n    <TRDeviceSetupServerDelegate> * _delegate;\n    int  _notifyToken;\n    bool  _notifyTokenIsValid;\n    bool  _setupInProgress;\n    bool  _started;\n    TRTransferServer * _transferServer;\n"]], "pred": {"ppl": 3.427447557449341, "ppl_lower": 4.680201530456543, "ppl/lowercase_ppl": -1.252899281863929, "ppl/zlib": 0.0050073814301297625, "Min_5.0% Prob": 8.301965713500977, "Min_10.0% Prob": 6.67528281893049, "Min_20.0% Prob": 4.859572139279596, "Min_30.0% Prob": 3.7288100638172845, "Min_40.0% Prob": 3.0386492157804557, "Min_50.0% Prob": 2.464629067745927, "Min_60.0% Prob": 2.0554577822966333}}
{"hexsha": "24735321e895312d09417e6b47aeed787d3b2018", "ext": "c", "lang": "C", "content": "int\nxenHypervisorGetVcpuMax(virConnectPtr conn,\n                        virDomainDefPtr def)\n{\n    xen_getdomaininfo dominfo;\n    int ret;\n    int maxcpu;\n    xenUnifiedPrivatePtr priv = conn->privateData;\n\n    /* inactive domain */\n    if (def->id < 0) {\n        maxcpu = MAX_VIRT_CPUS;\n    } else {\n        XEN_GETDOMAININFO_CLEAR(dominfo);\n        ret = virXen_getdomaininfo(priv->handle, def->id,\n                                   &dominfo);\n\n        if ((ret < 0) || (XEN_GETDOMAININFO_DOMAIN(dominfo) != def->id))\n            return -1;\n        maxcpu = XEN_GETDOMAININFO_MAXCPUID(dominfo) + 1;\n    }\n\n    return maxcpu;\n}", "item_id": 30, "repo": "SIIS-cloud/pileus", "file": "libvirt/pileus-libvirt-1.2.12/src/xen/xen_hypervisor.c", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "24735321e895312d09417e6b47aeed787d3b2018_30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nxenHypervisorGetVcpuMax(virConnectPtr conn,\n                        virDomainDefPtr def)\n{\n    xen_getdomaininfo dominfo;\n    int ret;\n    int maxcpu;\n    xenUnifiedPrivatePtr priv = conn->privateData;\n    /* inactive domain */\n    if (def->id < 0) {\n        maxcpu = MAX_VIRT_CPUS;\n    } else {\n        XEN_GETDOMAININFO_CLEAR(dominfo);\n        ret = virXen_getdomaininfo(priv->handle, def->id,\n                                   &dominfo);\n        if ((ret < 0) || (XEN_GETDOMAININFO_DOMAIN(dominfo) != def->id))\n            return -1;\n        maxcpu = XEN_GETDOMAININFO_MAXCPUID(dominfo) + 1;\n    }\n    return maxcpu;\n"]], "pred": {"ppl": 2.8072781562805176, "ppl_lower": 3.6118507385253906, "ppl/lowercase_ppl": -1.244139864620214, "ppl/zlib": 0.003287310147339332, "Min_5.0% Prob": 6.907188112085516, "Min_10.0% Prob": 6.004981691187078, "Min_20.0% Prob": 4.223923076282848, "Min_30.0% Prob": 3.197552744186286, "Min_40.0% Prob": 2.5307764634490013, "Min_50.0% Prob": 2.0441770469685934, "Min_60.0% Prob": 1.7168815984929864}}
{"hexsha": "1ddb3fc1772b04a2265a9ea2b20c298ee4f30163", "ext": "c", "lang": "C", "content": "static int _set_status_v1(domid_t  domid,\n                          int readonly,\n                          int mapflag,\n                          grant_entry_header_t *shah, \n                          struct active_grant_entry *act)\n{\n    int rc = GNTST_okay;\n    union grant_combo scombo, prev_scombo, new_scombo;\n    uint16_t mask = GTF_type_mask;\n\n    /*\n     * We bound the number of times we retry CMPXCHG on memory locations that\n     * we share with a guest OS. The reason is that the guest can modify that\n     * location at a higher rate than we can read-modify-CMPXCHG, so the guest\n     * could cause us to livelock. There are a few cases where it is valid for\n     * the guest to race our updates (e.g., to change the GTF_readonly flag),\n     * so we allow a few retries before failing.\n     */\n    int retries = 0;\n\n    /* if this is a grant mapping operation we should ensure GTF_sub_page\n       is not set */\n    if (mapflag)\n        mask |= GTF_sub_page;\n\n    scombo.word = *(u32 *)shah;\n\n    /*\n     * This loop attempts to set the access (reading/writing) flags\n     * in the grant table entry.  It tries a cmpxchg on the field\n     * up to five times, and then fails under the assumption that \n     * the guest is misbehaving.\n     */\n    for ( ; ; )\n    {\n        /* If not already pinned, check the grant domid and type. */\n        if ( !act->pin &&\n             (((scombo.shorts.flags & mask) !=\n               GTF_permit_access) ||\n              (scombo.shorts.domid != domid)) )\n            PIN_FAIL(done, GNTST_general_error,\n                     \"Bad flags (%x) or dom (%d). (expected dom %d)\\n\",\n                     scombo.shorts.flags, scombo.shorts.domid,\n                     domid);\n\n        new_scombo = scombo;\n        new_scombo.shorts.flags |= GTF_reading;\n\n        if ( !readonly )\n        {\n            new_scombo.shorts.flags |= GTF_writing;\n            if ( unlikely(scombo.shorts.flags & GTF_readonly) )\n                PIN_FAIL(done, GNTST_general_error,\n                         \"Attempt to write-pin a r/o grant entry.\\n\");\n        }\n\n        prev_scombo.word = cmpxchg((u32 *)shah,\n                                   scombo.word, new_scombo.word);\n        if ( likely(prev_scombo.word == scombo.word) )\n            break;\n\n        if ( retries++ == 4 )\n            PIN_FAIL(done, GNTST_general_error,\n                     \"Shared grant entry is unstable.\\n\");\n\n        scombo = prev_scombo;\n    }\n\ndone:\n    return rc;\n}", "item_id": 5, "repo": "zhiming-shen/Xen-Blanket-NG", "file": "xen/xen-4.2.2/xen/common/grant_table.c", "last_update_at": "2018-02-02T00:15:26+00:00", "question_id": "1ddb3fc1772b04a2265a9ea2b20c298ee4f30163_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int _set_status_v1(domid_t  domid,\n                          int readonly,\n                          int mapflag,\n                          grant_entry_header_t *shah, \n                          struct active_grant_entry *act)\n{\n    int rc = GNTST_okay;\n    union grant_combo scombo, prev_scombo, new_scombo;\n    uint16_t mask = GTF_type_mask;\n    /*\n     * We bound the number of times we retry CMPXCHG on memory locations that\n     * we share with a guest OS. The reason is that the guest can modify that\n     * location at a higher rate than we can read-modify-CMPXCHG, so the guest\n     * could cause us to livelock. There are a few cases where it is valid for\n     * the guest to race our updates (e.g., to change the GTF_readonly flag),\n     * so we allow a few retries before failing.\n     */\n    int retries = 0;\n    /* if this is a grant mapping operation we should ensure GTF_sub_page\n       is not set */\n    if (mapflag)\n        mask |= GTF_sub_page;\n    scombo.word = *(u32 *)shah;\n    /*\n     * This loop attempts to set the access (reading/writing) flags\n     * in the grant table entry.  It tries a cmpxchg on the field\n     * up to five times, and then fails under the assumption that \n     * the guest is misbehaving.\n     */\n    for ( ; ; )\n    {\n        /* If not already pinned, check the grant domid and type. */\n        if ( !act->pin &&\n             (((scombo.shorts.flags & mask) !=\n               GTF_permit_access) ||\n              (scombo.shorts.domid != domid)) )\n            PIN_FAIL(done, GNTST_general_error,\n                     \"Bad flags (%x) or dom (%d). (expected dom %d)\\n\",\n                     scombo.shorts.flags, scombo.shorts.domid,\n                     domid);\n        new_scombo = scombo;\n        new_scombo.shorts.flags |= GTF_reading;\n        if ( !readonly )\n        {\n            new_scombo.shorts.flags |= GTF_writing;\n            if ( unlikely(scombo.shorts.flags & GTF_readonly) )\n                PIN_FAIL(done, GNTST_general_error,\n                         \"Attempt to write-pin a r/o grant entry.\\n\");\n        }\n        prev_scombo.word = cmpxchg((u32 *)shah,\n                                   scombo.word, new_scombo.word);\n        if ( likely(prev_scombo.word == scombo.word) )\n            break;\n        if ( retries++ == 4 )\n            PIN_FAIL(done, GNTST_general_error,\n                     \"Shared grant entry is unstable.\\n\");\n        scombo = prev_scombo;\n    }\ndone:\n    return rc;\n"]], "pred": {"ppl": 3.35127592086792, "ppl_lower": 3.5446078777313232, "ppl/lowercase_ppl": -1.046377646285533, "ppl/zlib": 0.0012390790422382744, "Min_5.0% Prob": 8.414057958126069, "Min_10.0% Prob": 6.641501724720001, "Min_20.0% Prob": 4.725876417011023, "Min_30.0% Prob": 3.6467784037192663, "Min_40.0% Prob": 2.930525782704353, "Min_50.0% Prob": 2.397161995470524, "Min_60.0% Prob": 2.011139611915375}}
{"hexsha": "daeff356501b1cbc3009d3c4c9daa00bc413ad43", "ext": "c", "lang": "C", "content": "static void check_alloc() {\n  frame_t *frame = alloc_frame();\n\n  CU_ASSERT(frame != NULL);\n\n  free_frame(frame);\n}", "item_id": 1, "repo": "userlocalhost2000/newt", "file": "tests/unit/test_frame.c", "last_update_at": "2018-05-23T23:59:30+00:00", "question_id": "daeff356501b1cbc3009d3c4c9daa00bc413ad43_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void check_alloc() {\n  frame_t *frame = alloc_frame();\n  CU_ASSERT(frame != NULL);\n  free_frame(frame);\n"]], "pred": {"ppl": 4.447431564331055, "ppl_lower": 6.007351875305176, "ppl/lowercase_ppl": -1.2014687990417467, "ppl/zlib": 0.01604652422572927, "Min_5.0% Prob": 9.562214374542236, "Min_10.0% Prob": 8.15417194366455, "Min_20.0% Prob": 6.043427228927612, "Min_30.0% Prob": 4.507621755202611, "Min_40.0% Prob": 3.480259695473839, "Min_50.0% Prob": 2.9510941675731113, "Min_60.0% Prob": 2.544871850013733}}
{"hexsha": "ec662537837488947ea43e811d65e6b3c12ea304", "ext": "c", "lang": "C", "content": "static void coroae_int(void) {\n\tuwsgi_log(\"Brutally killing worker %d (pid: %d)...\\n\", uwsgi.mywid, uwsgi.mypid);\n\tuwsgi.workers[uwsgi.mywid].manage_next_request = 0;\n\tSvREFCNT_dec(ucoroae.watchers);\n\n\tcoroae_condvar_call(ucoroae.condvar, \"send\");\n}", "item_id": 16, "repo": "StanYaha/Blog", "file": "vmaig_blog/uwsgi-2.0.14/plugins/coroae/coroae.c", "last_update_at": "2018-11-24T16:10:49+00:00", "question_id": "ec662537837488947ea43e811d65e6b3c12ea304_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void coroae_int(void) {\n\tuwsgi_log(\"Brutally killing worker %d (pid: %d)...\\n\", uwsgi.mywid, uwsgi.mypid);\n\tuwsgi.workers[uwsgi.mywid].manage_next_request = 0;\n\tSvREFCNT_dec(ucoroae.watchers);\n\tcoroae_condvar_call(ucoroae.condvar, \"send\");\n"]], "pred": {"ppl": 5.7820820808410645, "ppl_lower": 6.248972415924072, "ppl/lowercase_ppl": -1.0442527909542763, "ppl/zlib": 0.009536759996841645, "Min_5.0% Prob": 10.249404525756836, "Min_10.0% Prob": 9.076422171159225, "Min_20.0% Prob": 6.646971059882122, "Min_30.0% Prob": 5.104743187768118, "Min_40.0% Prob": 4.217207372188568, "Min_50.0% Prob": 3.4972849935293198, "Min_60.0% Prob": 2.9235242924519946}}
{"hexsha": "2fcdb078fe71a8925f78b63496c09123444f8888", "ext": "c", "lang": "C", "content": "int crypto_hash(unsigned char *hashval,\r\n\t\tconst unsigned char *data,\r\n\t\tunsigned long long databytelen)\r\n{\r\n  uint8_t state[SIZE512];\r\n  uint8_t message_block[SIZE512];\r\n  uint32_t i, j, w;\r\n  uint32_t bytes_remaining;\r\n  uint64_t full_message_blocks = databytelen/64;\r\n\r\n\r\n\r\n  //Setting initial state\r\n  for(i=0;i<(SIZE512/sizeof(uint32_t));i++)\r\n  {\r\n    ((uint32_t*)state)[i] = 0;\r\n  }\r\n\r\n  //256BIT_HASH_SPECIFIC line\r\n  state[55] = 1; //Initial value for hash length 256 bit when saving state in row order!\r\n\r\n  while(full_message_blocks--)\r\n  {\r\n    for (i = 0; i < SIZE512; i++) {\r\n      message_block[(i%8)*8+i/8] = data[i]; //zeilenweise speichern\r\n  }\r\n\t\t\r\n  P((uint32_t*)state, (uint32_t*)message_block);\r\n\r\n  for (i = 0; i < SIZE512; i++) {\r\n    message_block[(i%8)*8+i/8] = data[i]; //zeilenweise speichern\r\n  }\r\n  Q((uint32_t*)state, (uint32_t*)message_block);\r\n    data += SIZE512;\r\n  }\r\n\t\r\n\r\n\t//Padding\r\n  bytes_remaining = ((uint32_t)databytelen)%64;\r\n  if(bytes_remaining > (SIZE512-64/8-1)) //if only one padding block is needed (64 bit w + 1 byte for appending bit 1)\r\n  {\r\n    for(j=0;j<2;j++)\r\n    {  \r\n      for(i=0;i<bytes_remaining;i++)\r\n      {\r\n    \t  message_block[(i%8)*8+i/8] = data[i]; //zeilenweise speichern\r\n      }    \t\r\n    \t//setting padding bit 1\r\n  \r\n  \t\tmessage_block[(i%8)*8+i/8] = 0x80;\r\n      i++;\r\n      for(;i<SIZE512;i++)\r\n      {\r\n        message_block[(i%8)*8+i/8] = 0;\r\n      }\r\n\r\n      if(j==0)\r\n      {\r\n        P((uint32_t*)state, (uint32_t*)message_block);\r\n      }\r\n      else\r\n      {\r\n        Q((uint32_t*)state, (uint32_t*)message_block);\r\n      }\r\n    }\r\n  }\r\n\r\n  w = (-((uint32_t)8*databytelen)-65)&0x1FF;\r\n  databytelen = (8*databytelen+w+65)/(SIZE512*8);\r\n  \r\n\r\n  for(j=0;j<2;j++)     //j is 2 at this moment\r\n  {\r\n    i=0;\r\n    if(bytes_remaining <= (SIZE512-64/8-1))\r\n    {\r\n      for(;i<bytes_remaining;i++)\r\n      {\r\n    \tmessage_block[(i%8)*8+i/8] = data[i]; //zeilenweise speichern\r\n\t  }\r\n      message_block[(i%8)*8+i/8] = 0x80;\r\n      i++;\r\n    }\r\n\r\n    for(;i<(SIZE512-(64/8));i++)\r\n  \t{\r\n  \t  message_block[(i%8)*8+i/8] = 0;\r\n  \t}\r\n\r\n    full_message_blocks = databytelen; //temp copy of padding value\r\n    for(i=SIZE512-1;i>=(SIZE512-64/8);i--)\r\n    {\r\n      message_block[(i%8)*8+i/8] = (uint8_t)full_message_blocks;\r\n      full_message_blocks >>= 8;\r\n    }\r\n\r\n    if(j==0)\r\n    {\r\n      P((uint32_t*)state, (uint32_t*)message_block);\r\n    }\r\n    else\r\n    {\r\n      Q((uint32_t*)state, (uint32_t*)message_block);\r\n    }\r\n  }\r\n\r\n  for (i = 0; i < SIZE512/sizeof(uint32_t); i++) {\r\n    ((uint32_t*)message_block)[i] = ((uint32_t*)state)[i];\r\n  }\r\n\r\n  w = 0;     //round constant\r\n  \r\n\r\n  for(i=0;i<10;i++)\r\n  {\r\n  \tRND512P((uint32_t*)state, w);\r\n  \tw += 0x01010101;\r\n  }\r\n\r\n  for (i = 0; i < 2*COLS512; i++) {\r\n    ((uint32_t*)state)[i] ^= ((uint32_t*)message_block)[i];\r\n  }\r\n\r\n  for (i = SIZE512-HASH_BIT_LEN/8; i < SIZE512; i++) {\r\n    hashval[i-(SIZE512-HASH_BIT_LEN/8)] = state[(i%8)*8+i/8]; //zeilenweise speichern\r\n  }\r\n\r\n\r\n  return 0;\r\n}", "item_id": 5, "repo": "iadgov/simon-speck-supercop", "file": "crypto_hash/groestl256/thumb-asm-small/hash.c", "last_update_at": "2018-03-09T14:52:25+00:00", "question_id": "2fcdb078fe71a8925f78b63496c09123444f8888_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int crypto_hash(unsigned char *hashval,\r\n\t\tconst unsigned char *data,\r\n\t\tunsigned long long databytelen)\r\n{\r\n  uint8_t state[SIZE512];\r\n  uint8_t message_block[SIZE512];\r\n  uint32_t i, j, w;\r\n  uint32_t bytes_remaining;\r\n  uint64_t full_message_blocks = databytelen/64;\r\n\r\n\r\n\r\n  //Setting initial state\r\n  for(i=0;i<(SIZE512/sizeof(uint32_t));i++)\r\n  {\r\n    ((uint32_t*)state)[i] = 0;\r\n  }\r\n\r\n  //256BIT_HASH_SPECIFIC line\r\n  state[55] = 1; //Initial value for hash length 256 bit when saving state in row order!\r\n\r\n  while(full_message_blocks--)\r\n  {\r\n    for (i = 0; i < SIZE512; i++) {\r\n      message_block[(i%8)*8+i/8] = data[i]; //zeilenweise speichern\r\n  }\r\n\t\t\r\n  P((uint32_t*)state, (uint32_t*)message_block);\r\n\r\n  for (i = 0; i < SIZE512; i++) {\r\n    message_block[(i%8)*8+i/8] = data[i]; //zeilenweise speichern\r\n  }\r\n  Q((uint32_t*)state, (uint32_t*)message_block);\r\n    data += SIZE512;\r\n  }\r\n\t\r\n\r\n\t//Padding\r\n  bytes_remaining = ((uint32_t)databytelen)%64;\r\n  if(bytes_remaining > (SIZE512-64/8-1)) //if only one padding block is needed (64 bit w + 1 byte for appending bit 1)\r\n  {\r\n    for(j=0;j<2;j++)\r\n    {  \r\n      for(i=0;i<bytes_remaining;i++)\r\n      {\r\n    \t  message_block[(i%8)*8+i/8] = data[i]; //zeilenweise speichern\r\n      }    \t\r\n    \t//setting padding bit 1\r\n  \r\n  \t\tmessage_block[(i%8)*8+i/8] = 0x80;\r\n      i++;\r\n      for(;i<SIZE512;i++)\r\n      {\r\n        message_block[(i%8)*8+i/8] = 0;\r\n      }\r\n\r\n      if(j==0)\r\n      {\r\n        P((uint32_t*)state, (uint32_t*)message_block);\r\n      }\r\n      else\r\n      {\r\n        Q((uint32_t*)state, (uint32_t*)message_block);\r\n      }\r\n    }\r\n  }\r\n\r\n  w = (-((uint32_t)8*databytelen)-65)&0x1FF;\r\n  databytelen = (8*databytelen+w+65)/(SIZE512*8);\r\n  \r\n\r\n  for(j=0;j<2;j++)     //j is 2 at this moment\r\n  {\r\n    i=0;\r\n    if(bytes_remaining <= (SIZE512-64/8-1))\r\n    {\r\n      for(;i<bytes_remaining;i++)\r\n      {\r\n    \tmessage_block[(i%8)*8+i/8] = data[i]; //zeilenweise speichern\r\n\t  }\r\n      message_block[(i%8)*8+i/8] = 0x80;\r\n      i++;\r\n    }\r\n\r\n    for(;i<(SIZE512-(64/8));i++)\r\n  \t{\r\n  \t  message_block[(i%8)*8+i/8] = 0;\r\n  \t}\r\n\r\n    full_message_blocks = databytelen; //temp copy of padding value\r\n    for(i=SIZE512-1;i>=(SIZE512-64/8);i--)\r\n    {\r\n      message_block[(i%8)*8+i/8] = (uint8_t)full_message_blocks;\r\n      full_message_blocks >>= 8;\r\n    }\r\n\r\n    if(j==0)\r\n    {\r\n      P((uint32_t*)state, (uint32_t*)message_block);\r\n    }\r\n    else\r\n    {\r\n      Q((uint32_t*)state, (uint32_t*)message_block);\r\n    }\r\n  }\r\n\r\n  for (i = 0; i < SIZE512/sizeof(uint32_t); i++) {\r\n    ((uint32_t*)message_block)[i] = ((uint32_t*)state)[i];\r\n  }\r\n\r\n  w = 0;     //round constant\r\n  \r\n\r\n  for(i=0;i<10;i++)\r\n  {\r\n  \tRND512P((uint32_t*)state, w);\r\n  \tw += 0x01010101;\r\n  }\r\n\r\n  for (i = 0; i < 2*COLS512; i++) {\r\n    ((uint32_t*)state)[i] ^= ((uint32_t*)message_block)[i];\r\n  }\r\n\r\n  for (i = SIZE512-HASH_BIT_LEN/8; i < SIZE512; i++) {\r\n    hashval[i-(SIZE512-HASH_BIT_LEN/8)] = state[(i%8)*8+i/8]; //zeilenweise speichern\r\n  }\r\n\r\n\r\n  return 0;\r\n"]], "pred": {"ppl": 2.4132912158966064, "ppl_lower": 2.4126179218292236, "ppl/lowercase_ppl": -0.9996832738335896, "ppl/zlib": 0.0009607322416583245, "Min_5.0% Prob": 6.892287488077201, "Min_10.0% Prob": 5.350700731370964, "Min_20.0% Prob": 3.7178150427107717, "Min_30.0% Prob": 2.7812947632830127, "Min_40.0% Prob": 2.161830608339065, "Min_50.0% Prob": 1.7539682471705509, "Min_60.0% Prob": 1.4688991310308896}}
{"hexsha": "5a6331acc75a41db4102022dbe2ae9259f3a8633", "ext": "c", "lang": "C", "content": "PUBLIC int process_ksig(endpoint_t proc_nr_e, int signo)\r\n{\r\n  register struct mproc *rmp;\r\n  int proc_nr;\r\n  pid_t proc_id, id;\r\n\r\n  if(pm_isokendpt(proc_nr_e, &proc_nr) != OK || proc_nr < 0) {\r\n\tprintf(\"PM: process_ksig: %d?? not ok\\n\", proc_nr_e);\r\n\treturn EDEADSRCDST; /* process is gone. */\r\n  }\r\n  rmp = &mproc[proc_nr];\r\n  if ((rmp->mp_flags & (IN_USE | EXITING)) != IN_USE) {\r\n#if 0\r\n\tprintf(\"PM: process_ksig: %d?? exiting / not in use\\n\", proc_nr_e);\r\n#endif\r\n\treturn EDEADSRCDST; /* process is gone. */\r\n  }\r\n  proc_id = rmp->mp_pid;\r\n  mp = &mproc[0];\t\t\t/* pretend signals are from PM */\r\n  mp->mp_procgrp = rmp->mp_procgrp;\t/* get process group right */\r\n\r\n  /* For SIGVTALRM and SIGPROF, see if we need to restart a\r\n   * virtual timer. For SIGINT, SIGWINCH and SIGQUIT, use proc_id 0\r\n   * to indicate a broadcast to the recipient's process group.  For\r\n   * SIGKILL, use proc_id -1 to indicate a systemwide broadcast.\r\n   */\r\n  switch (signo) {\r\n      case SIGINT:\r\n      case SIGQUIT:\r\n      case SIGWINCH:\r\n  \tid = 0; break;\t/* broadcast to process group */\r\n      case SIGVTALRM:\r\n      case SIGPROF:\r\n      \tcheck_vtimer(proc_nr, signo);\r\n      \t/* fall-through */\r\n      default:\r\n  \tid = proc_id;\r\n  \tbreak;\r\n  }\r\n  check_sig(id, signo, TRUE /* ksig */);\r\n\r\n  /* If SIGSNDELAY is set, an earlier sys_stop() failed because the process was\r\n   * still sending, and the kernel hereby tells us that the process is now done\r\n   * with that. We can now try to resume what we planned to do in the first\r\n   * place: set up a signal handler. However, the process's message may have\r\n   * been a call to PM, in which case the process may have changed any of its\r\n   * signal settings. The process may also have forked, exited etcetera.\r\n   */\r\n  if (signo == SIGSNDELAY && (rmp->mp_flags & DELAY_CALL)) {\r\n\trmp->mp_flags &= ~DELAY_CALL;\r\n\r\n\t/*\r\n\t * If the FS_CALL flag is still set we have a process which is stopped\r\n\t * and we only need to wait for a reply from VFS. We are going to check\r\n\t * the pending signal then\r\n\t */\r\n\tif (rmp->mp_flags & FS_CALL)\r\n\t\treturn OK;\r\n\tif (rmp->mp_flags & PM_SIG_PENDING)\r\n\t\tpanic(\"process_ksig: bad process state\");\r\n\r\n\t/* Process as many normal signals as possible. */\r\n\tcheck_pending(rmp);\r\n\r\n\tif (rmp->mp_flags & DELAY_CALL)\r\n\t\tpanic(\"process_ksig: multiple delay calls?\");\r\n  }\r\n  \r\n  /* See if the process is still alive */\r\n  if ((mproc[proc_nr].mp_flags & (IN_USE | EXITING)) == IN_USE)  {\r\n      return OK; /* signal has been delivered */\r\n  }\r\n  else {\r\n      return EDEADSRCDST; /* process is gone */\r\n  }\r\n}", "item_id": 5, "repo": "ducis/operating-system-labs", "file": "src.clean/servers/pm/signal.c", "last_update_at": "2018-03-01T14:11:47+00:00", "question_id": "5a6331acc75a41db4102022dbe2ae9259f3a8633_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["PUBLIC int process_ksig(endpoint_t proc_nr_e, int signo)\r\n{\r\n  register struct mproc *rmp;\r\n  int proc_nr;\r\n  pid_t proc_id, id;\r\n\r\n  if(pm_isokendpt(proc_nr_e, &proc_nr) != OK || proc_nr < 0) {\r\n\tprintf(\"PM: process_ksig: %d?? not ok\\n\", proc_nr_e);\r\n\treturn EDEADSRCDST; /* process is gone. */\r\n  }\r\n  rmp = &mproc[proc_nr];\r\n  if ((rmp->mp_flags & (IN_USE | EXITING)) != IN_USE) {\r\n#if 0\r\n\tprintf(\"PM: process_ksig: %d?? exiting / not in use\\n\", proc_nr_e);\r\n#endif\r\n\treturn EDEADSRCDST; /* process is gone. */\r\n  }\r\n  proc_id = rmp->mp_pid;\r\n  mp = &mproc[0];\t\t\t/* pretend signals are from PM */\r\n  mp->mp_procgrp = rmp->mp_procgrp;\t/* get process group right */\r\n\r\n  /* For SIGVTALRM and SIGPROF, see if we need to restart a\r\n   * virtual timer. For SIGINT, SIGWINCH and SIGQUIT, use proc_id 0\r\n   * to indicate a broadcast to the recipient's process group.  For\r\n   * SIGKILL, use proc_id -1 to indicate a systemwide broadcast.\r\n   */\r\n  switch (signo) {\r\n      case SIGINT:\r\n      case SIGQUIT:\r\n      case SIGWINCH:\r\n  \tid = 0; break;\t/* broadcast to process group */\r\n      case SIGVTALRM:\r\n      case SIGPROF:\r\n      \tcheck_vtimer(proc_nr, signo);\r\n      \t/* fall-through */\r\n      default:\r\n  \tid = proc_id;\r\n  \tbreak;\r\n  }\r\n  check_sig(id, signo, TRUE /* ksig */);\r\n\r\n  /* If SIGSNDELAY is set, an earlier sys_stop() failed because the process was\r\n   * still sending, and the kernel hereby tells us that the process is now done\r\n   * with that. We can now try to resume what we planned to do in the first\r\n   * place: set up a signal handler. However, the process's message may have\r\n   * been a call to PM, in which case the process may have changed any of its\r\n   * signal settings. The process may also have forked, exited etcetera.\r\n   */\r\n  if (signo == SIGSNDELAY && (rmp->mp_flags & DELAY_CALL)) {\r\n\trmp->mp_flags &= ~DELAY_CALL;\r\n\r\n\t/*\r\n\t * If the FS_CALL flag is still set we have a process which is stopped\r\n\t * and we only need to wait for a reply from VFS. We are going to check\r\n\t * the pending signal then\r\n\t */\r\n\tif (rmp->mp_flags & FS_CALL)\r\n\t\treturn OK;\r\n\tif (rmp->mp_flags & PM_SIG_PENDING)\r\n\t\tpanic(\"process_ksig: bad process state\");\r\n\r\n\t/* Process as many normal signals as possible. */\r\n\tcheck_pending(rmp);\r\n\r\n\tif (rmp->mp_flags & DELAY_CALL)\r\n\t\tpanic(\"process_ksig: multiple delay calls?\");\r\n  }\r\n  \r\n  /* See if the process is still alive */\r\n  if ((mproc[proc_nr].mp_flags & (IN_USE | EXITING)) == IN_USE)  {\r\n      return OK; /* signal has been delivered */\r\n  }\r\n  else {\r\n      return EDEADSRCDST; /* process is gone */\r\n  }\r\n"]], "pred": {"ppl": 3.0341367721557617, "ppl_lower": 3.676886796951294, "ppl/lowercase_ppl": -1.1731099993937293, "ppl/zlib": 0.0009702158738848815, "Min_5.0% Prob": 7.167507857084274, "Min_10.0% Prob": 5.807851642370224, "Min_20.0% Prob": 4.2493242006748915, "Min_30.0% Prob": 3.3236849870946674, "Min_40.0% Prob": 2.6845831618799516, "Min_50.0% Prob": 2.1981943102549613, "Min_60.0% Prob": 1.8458109297878407}}
{"hexsha": "1e3a6cfbd50359eab00b8b6c94ab00942d85e644", "ext": "h", "lang": "C", "content": "class input {\npublic:\n\tinput(std::string, std::string, std::string, bool);\n\t~input() {};\n\thcube* makeHostCube(long, bool);\n\tstd::vector<long> dim;\n\tstd::valarray<double> data;\n\tstd::string in_fits_filename, in_params_filename, in_config_filename;\n\txml_document<> config;\n\txml_document<> params;\n\tstd::vector<int> wavelengths;\n\tstd::map<std::string, std::string> config_host;\t\t\t// dictionary containing all config items related to the host.\n\tstd::map<std::string, std::string> config_device;\t\t// dictionary containing all config items related to the device.\n\tstd::list<process_stages> stages;\n\tstd::map<process_stages, std::map<std::string, std::string>> stage_parameters;\nprivate:\n\tvoid readXMLFile(xml_document<>&, string, bool);\n\tvoid readFITSFile(std::valarray<double>&, std::vector<long>&, string, bool);\n\tvoid processConfigFile(string, bool);\n\tvoid processSimulationParametersFile(string, bool);\n\tvoid processFITSFile(string, bool);\n}", "item_id": 0, "repo": "oxford-pcs/sdcuda", "file": "cinput.h", "last_update_at": "2018-01-22T21:54:27+00:00", "question_id": "1e3a6cfbd50359eab00b8b6c94ab00942d85e644_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class input {\npublic:\n\tinput(std::string, std::string, std::string, bool);\n\t~input() {};\n\thcube* makeHostCube(long, bool);\n\tstd::vector<long> dim;\n\tstd::valarray<double> data;\n\tstd::string in_fits_filename, in_params_filename, in_config_filename;\n\txml_document<> config;\n\txml_document<> params;\n\tstd::vector<int> wavelengths;\n\tstd::map<std::string, std::string> config_host;\t\t\t// dictionary containing all config items related to the host.\n\tstd::map<std::string, std::string> config_device;\t\t// dictionary containing all config items related to the device.\n\tstd::list<process_stages> stages;\n\tstd::map<process_stages, std::map<std::string, std::string>> stage_parameters;\nprivate:\n\tvoid readXMLFile(xml_document<>&, string, bool);\n\tvoid readFITSFile(std::valarray<double>&, std::vector<long>&, string, bool);\n\tvoid processConfigFile(string, bool);\n\tvoid processSimulationParametersFile(string, bool);\n\tvoid processFITSFile(string, bool);\n"]], "pred": {"ppl": 3.4837734699249268, "ppl_lower": 3.5833582878112793, "ppl/lowercase_ppl": -1.0225815487731469, "ppl/zlib": 0.0034478343556987863, "Min_5.0% Prob": 8.840203921000162, "Min_10.0% Prob": 6.9579371611277265, "Min_20.0% Prob": 4.878697141272123, "Min_30.0% Prob": 3.72100307630456, "Min_40.0% Prob": 2.988478869926639, "Min_50.0% Prob": 2.4573912892442245, "Min_60.0% Prob": 2.0692891601372407}}
{"hexsha": "5ea3afa093a48e3c18921a5a3d433247ce35f4ff", "ext": "c", "lang": "C", "content": "int nhap() {\n  int n;\n  printf(\"Nhap vao so phan tu cua day (n<5): \");\n  scanf(\"%i\", &n);\n  while (n <= 5) {\n    printf(\"Du lieu khong hop le. Nhap vao so phan tu cua day (n<5): \");\n    scanf(\"%i\", &n);\n  }\n  return n;\n}", "item_id": 0, "repo": "lamhoangtung/Bai-tap-Lap-trinh-can-ban", "file": "De thi/ngoc-bai2.c", "last_update_at": "2018-03-30T14:20:05+00:00", "question_id": "5ea3afa093a48e3c18921a5a3d433247ce35f4ff_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int nhap() {\n  int n;\n  printf(\"Nhap vao so phan tu cua day (n<5): \");\n  scanf(\"%i\", &n);\n  while (n <= 5) {\n    printf(\"Du lieu khong hop le. Nhap vao so phan tu cua day (n<5): \");\n    scanf(\"%i\", &n);\n  }\n  return n;\n"]], "pred": {"ppl": 2.2157886028289795, "ppl_lower": 2.46867299079895, "ppl/lowercase_ppl": -1.1358361618102708, "ppl/zlib": 0.005765278032603386, "Min_5.0% Prob": 6.481507873535156, "Min_10.0% Prob": 5.323966479301452, "Min_20.0% Prob": 3.595533537864685, "Min_30.0% Prob": 2.567140914740101, "Min_40.0% Prob": 1.9877115715204217, "Min_50.0% Prob": 1.5802203031400075, "Min_60.0% Prob": 1.3310236842822163}}
{"hexsha": "37bfcb619ea9766dcc4d299e8139771526faa0d8", "ext": "c", "lang": "C", "content": "static GtOptionParser* gt_tagerator_option_parser_new(void *tool_arguments)\n{\n  TageratorOptions *arguments = tool_arguments;\n  GtOptionParser *op;\n  GtOption *option, *optionrw, *optiononline, *optioncmp, *optionesaindex,\n           *optionpckindex, *optionmaxdepth, *optionbest;\n\n  gt_assert(arguments != NULL);\n  op = gt_option_parser_new(\"[options] -q tagfile [-esa|-pck] indexname\",\n                         \"Map short sequence tags in given index.\");\n  gt_option_parser_set_mailaddress(op,\"<kurtz@zbh.uni-hamburg.de>\");\n  option = gt_option_new_filenamearray(\"q\",\n                                    \"Specify files containing the short \"\n                                    \"sequence tags\",\n                                    arguments->tagfiles);\n  gt_option_parser_add_option(op, option);\n  gt_option_is_mandatory(option);\n\n  option = gt_option_new_long(\"e\",\n                           \"Specify the allowed number of differences \"\n                           \"(replacements/insertions/deletions)\",\n                           &arguments->userdefinedmaxdistance,\n                           -1L);\n  gt_option_parser_add_option(op, option);\n\n  optionesaindex = gt_option_new_string(\"esa\",\n                                     \"Specify index (enhanced suffix array)\",\n                                     arguments->indexname, NULL);\n  gt_option_parser_add_option(op, optionesaindex);\n  arguments->refoptionesaindex = gt_option_ref(optionesaindex);\n\n  optionpckindex = gt_option_new_string(\"pck\",\n                                     \"Specify index (packed index)\",\n                                     arguments->indexname, NULL);\n  gt_option_parser_add_option(op, optionpckindex);\n  arguments->refoptionpckindex = gt_option_ref(optionpckindex);\n  gt_option_exclude(optionesaindex,optionpckindex);\n  gt_option_is_mandatory_either(optionesaindex,optionpckindex);\n\n  optionmaxdepth = gt_option_new_int(\"maxdepth\",\n                                  \"Use the data in the .pbt file only up to \"\n                                  \"this depth (only relevant with option -pck)\",\n                                  &arguments->userdefinedmaxdepth,\n                                  -1);\n  gt_option_parser_add_option(op, optionmaxdepth);\n  gt_option_is_development_option(optionmaxdepth);\n\n  optiononline = gt_option_new_bool(\"online\",\"Perform online searches\",\n                                    &arguments->doonline, false);\n  gt_option_parser_add_option(op, optiononline);\n  gt_option_is_development_option(optiononline);\n\n  optioncmp = gt_option_new_bool(\"cmp\",\"compare results of offline and online \"\n                                 \"searches\",\n                                 &arguments->docompare, false);\n  gt_option_parser_add_option(op, optioncmp);\n  gt_option_exclude(optiononline,optioncmp);\n  gt_option_is_development_option(optioncmp);\n\n  optionrw = gt_option_new_bool(\"rw\",\"Replace wildcard in tag by random char\",\n                             &arguments->replacewildcard, false);\n  gt_option_parser_add_option(op, optionrw);\n  gt_option_is_development_option(optionrw);\n\n  option = gt_option_new_bool(\"nod\",\"Do not compute direct matches\",\n                           &arguments->nofwdmatch, false);\n  gt_option_parser_add_option(op, option);\n\n  option = gt_option_new_bool(\"nop\",\"Do not compute palindromic matches \"\n                           \"(i.e. no reverse complemented matches.)\",\n                             &arguments->norcmatch, false);\n  gt_option_parser_add_option(op, option);\n\n  optionbest = gt_option_new_bool(\"best\",\"Compute only best matches, i.e. only \"\n                                  \"for smallest edit distance with matches\",\n                                  &arguments->best, false);\n  gt_option_parser_add_option(op, optionbest);\n  gt_option_exclude(optiononline,optionbest);\n  gt_option_exclude(optioncmp,optionbest);\n\n  option = gt_option_new_ulong_min(\"maxocc\",\n                                   \"specify max number of match-occurrences\",\n                                   &arguments->maxintervalwidth,0,1UL);\n  gt_option_parser_add_option(op, option);\n\n  option = gt_option_new_bool(\"skpp\",\n                           \"Skip prefix of pattern (only in pdiff mode)\",\n                           &arguments->skpp, false);\n  gt_option_parser_add_option(op, option);\n\n  option = gt_option_new_bool(\"withwildcards\",\"output matches containing \"\n                              \"wildcard characters (e.g. N); only relevant for \"\n                              \"approximate matching\",\n                              &arguments->nowildcards, true);\n  gt_option_parser_add_option(op, option);\n\n  option = gt_option_new_stringarray(\"output\",\n                                     gt_str_get(arguments->outputhelp),\n                                     arguments->outputspec);\n  gt_option_parser_add_option(op, option);\n\n  option = gt_option_new_verbose(&arguments->verbose);\n  gt_option_parser_add_option(op, option);\n\n  return op;\n}", "item_id": 2, "repo": "jamescasbon/genometools", "file": "src/tools/gt_tagerator.c", "last_update_at": "2018-11-30T20:04:01+00:00", "question_id": "37bfcb619ea9766dcc4d299e8139771526faa0d8_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static GtOptionParser* gt_tagerator_option_parser_new(void *tool_arguments)\n{\n  TageratorOptions *arguments = tool_arguments;\n  GtOptionParser *op;\n  GtOption *option, *optionrw, *optiononline, *optioncmp, *optionesaindex,\n           *optionpckindex, *optionmaxdepth, *optionbest;\n  gt_assert(arguments != NULL);\n  op = gt_option_parser_new(\"[options] -q tagfile [-esa|-pck] indexname\",\n                         \"Map short sequence tags in given index.\");\n  gt_option_parser_set_mailaddress(op,\"<kurtz@zbh.uni-hamburg.de>\");\n  option = gt_option_new_filenamearray(\"q\",\n                                    \"Specify files containing the short \"\n                                    \"sequence tags\",\n                                    arguments->tagfiles);\n  gt_option_parser_add_option(op, option);\n  gt_option_is_mandatory(option);\n  option = gt_option_new_long(\"e\",\n                           \"Specify the allowed number of differences \"\n                           \"(replacements/insertions/deletions)\",\n                           &arguments->userdefinedmaxdistance,\n                           -1L);\n  gt_option_parser_add_option(op, option);\n  optionesaindex = gt_option_new_string(\"esa\",\n                                     \"Specify index (enhanced suffix array)\",\n                                     arguments->indexname, NULL);\n  gt_option_parser_add_option(op, optionesaindex);\n  arguments->refoptionesaindex = gt_option_ref(optionesaindex);\n  optionpckindex = gt_option_new_string(\"pck\",\n                                     \"Specify index (packed index)\",\n                                     arguments->indexname, NULL);\n  gt_option_parser_add_option(op, optionpckindex);\n  arguments->refoptionpckindex = gt_option_ref(optionpckindex);\n  gt_option_exclude(optionesaindex,optionpckindex);\n  gt_option_is_mandatory_either(optionesaindex,optionpckindex);\n  optionmaxdepth = gt_option_new_int(\"maxdepth\",\n                                  \"Use the data in the .pbt file only up to \"\n                                  \"this depth (only relevant with option -pck)\",\n                                  &arguments->userdefinedmaxdepth,\n                                  -1);\n  gt_option_parser_add_option(op, optionmaxdepth);\n  gt_option_is_development_option(optionmaxdepth);\n  optiononline = gt_option_new_bool(\"online\",\"Perform online searches\",\n                                    &arguments->doonline, false);\n  gt_option_parser_add_option(op, optiononline);\n  gt_option_is_development_option(optiononline);\n  optioncmp = gt_option_new_bool(\"cmp\",\"compare results of offline and online \"\n                                 \"searches\",\n                                 &arguments->docompare, false);\n  gt_option_parser_add_option(op, optioncmp);\n  gt_option_exclude(optiononline,optioncmp);\n  gt_option_is_development_option(optioncmp);\n  optionrw = gt_option_new_bool(\"rw\",\"Replace wildcard in tag by random char\",\n                             &arguments->replacewildcard, false);\n  gt_option_parser_add_option(op, optionrw);\n  gt_option_is_development_option(optionrw);\n  option = gt_option_new_bool(\"nod\",\"Do not compute direct matches\",\n                           &arguments->nofwdmatch, false);\n  gt_option_parser_add_option(op, option);\n  option = gt_option_new_bool(\"nop\",\"Do not compute palindromic matches \"\n                           \"(i.e. no reverse complemented matches.)\",\n                             &arguments->norcmatch, false);\n  gt_option_parser_add_option(op, option);\n  optionbest = gt_option_new_bool(\"best\",\"Compute only best matches, i.e. only \"\n                                  \"for smallest edit distance with matches\",\n                                  &arguments->best, false);\n  gt_option_parser_add_option(op, optionbest);\n  gt_option_exclude(optiononline,optionbest);\n  gt_option_exclude(optioncmp,optionbest);\n  option = gt_option_new_ulong_min(\"maxocc\",\n                                   \"specify max number of match-occurrences\",\n                                   &arguments->maxintervalwidth,0,1UL);\n  gt_option_parser_add_option(op, option);\n  option = gt_option_new_bool(\"skpp\",\n                           \"Skip prefix of pattern (only in pdiff mode)\",\n                           &arguments->skpp, false);\n  gt_option_parser_add_option(op, option);\n  option = gt_option_new_bool(\"withwildcards\",\"output matches containing \"\n                              \"wildcard characters (e.g. N); only relevant for \"\n                              \"approximate matching\",\n                              &arguments->nowildcards, true);\n  gt_option_parser_add_option(op, option);\n  option = gt_option_new_stringarray(\"output\",\n                                     gt_str_get(arguments->outputhelp),\n                                     arguments->outputspec);\n  gt_option_parser_add_option(op, option);\n  option = gt_option_new_verbose(&arguments->verbose);\n  gt_option_parser_add_option(op, option);\n  return op;\n"]], "pred": {"ppl": 1.9385184049606323, "ppl_lower": 2.061837673187256, "ppl/lowercase_ppl": -1.0931733696693784, "ppl/zlib": 0.0005562386323680182, "Min_5.0% Prob": 6.4152522367589615, "Min_10.0% Prob": 4.896416397655711, "Min_20.0% Prob": 3.128643787666863, "Min_30.0% Prob": 2.18669488748499, "Min_40.0% Prob": 1.6517441428305175, "Min_50.0% Prob": 1.3243868677264514, "Min_60.0% Prob": 1.1045241575372111}}
{"hexsha": "a5c7ff8abd59458ac67e174b927373247ef12d87", "ext": "c", "lang": "C", "content": "void cwrt_task(void *pvParameter)\n{\n    configASSERT(configUSE_RECURSIVE_MUTEXES);\n    vTaskDelay(10);\n    rt_init();\n\tcwrt_setup();\n    unsigned long last = 0;\n    while(1) {\n\t\tcwrt_process(&last);\n        unsigned long now = upTime();\n        if (now < last || now - last > 50) {\n            taskYIELD();\n            last = now;\n        }\n    }\n}", "item_id": 0, "repo": "latproc/clockwork_esp32", "file": "main/clockwork_esp32.c", "last_update_at": "2018-01-22T15:42:02+00:00", "question_id": "a5c7ff8abd59458ac67e174b927373247ef12d87_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void cwrt_task(void *pvParameter)\n{\n    configASSERT(configUSE_RECURSIVE_MUTEXES);\n    vTaskDelay(10);\n    rt_init();\n\tcwrt_setup();\n    unsigned long last = 0;\n    while(1) {\n\t\tcwrt_process(&last);\n        unsigned long now = upTime();\n        if (now < last || now - last > 50) {\n            taskYIELD();\n            last = now;\n        }\n    }\n"]], "pred": {"ppl": 3.959023952484131, "ppl_lower": 6.211309909820557, "ppl/lowercase_ppl": -1.3273074878766724, "ppl/zlib": 0.006142846063574139, "Min_5.0% Prob": 7.576040665308635, "Min_10.0% Prob": 6.623395112844614, "Min_20.0% Prob": 5.084481835365295, "Min_30.0% Prob": 3.9675362965999503, "Min_40.0% Prob": 3.2097981365827413, "Min_50.0% Prob": 2.6565180831786357, "Min_60.0% Prob": 2.2654463786490355}}
{"hexsha": "6f157363c2b31b14066cf5ef45d92cfbec456031", "ext": "c", "lang": "C", "content": "int\nmain (int argc, char * ARRAY VALIDPTR LOC(PROGRAM_NAME_LOC) * START NONNULL ARRAY SIZE(argc * 4) argv)\n    CHECK_TYPE GLOBAL(PROGRAM_NAME_LOC)\n{\n  exit (EXIT_STATUS);\n\n  // pmr: csolve needs returns before the ends of function bodies to make the heap\n  // constraints work ok\n  return 0;\n}", "item_id": 0, "repo": "ucsd-progsys/csolve-bak", "file": "external/gnu-coreutils/src/true.c", "last_update_at": "2018-04-24T10:43:07+00:00", "question_id": "6f157363c2b31b14066cf5ef45d92cfbec456031_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nmain (int argc, char * ARRAY VALIDPTR LOC(PROGRAM_NAME_LOC) * START NONNULL ARRAY SIZE(argc * 4) argv)\n    CHECK_TYPE GLOBAL(PROGRAM_NAME_LOC)\n{\n  exit (EXIT_STATUS);\n  // pmr: csolve needs returns before the ends of function bodies to make the heap\n  // constraints work ok\n  return 0;\n"]], "pred": {"ppl": 8.711691856384277, "ppl_lower": 21.799135208129883, "ppl/lowercase_ppl": -1.4237163046502457, "ppl/zlib": 0.009494149188530504, "Min_5.0% Prob": 10.801448440551757, "Min_10.0% Prob": 9.379391280087559, "Min_20.0% Prob": 7.415621562437578, "Min_30.0% Prob": 6.099924051400387, "Min_40.0% Prob": 4.99271362749013, "Min_50.0% Prob": 4.162235767191107, "Min_60.0% Prob": 3.5607817127849115}}
{"hexsha": "b14983e5a0f4f2c9b9d92dd41909a6fa9e6f2a99", "ext": "c", "lang": "C", "content": "EXPORT(sqInt)\nprimitiveDrawString(void)\n{\n    sqInt bitmapOop;\n    void *bitmapPtr;\n    sqInt h;\n    sqInt result;\n    char *utf8;\n    sqInt utf8Length;\n    sqInt utf8Oop;\n    sqInt w;\n\n\tutf8Oop = stackValue(3);\n\t/* begin asCString: */\n\tsuccess(isBytes(utf8Oop));\n\tutf8 = (failed()\n\t\t? 0\n\t\t: ((char *) (firstIndexableField(utf8Oop))));\n\tw = stackIntegerValue(2);\n\th = stackIntegerValue(1);\n\tbitmapOop = stackValue(0);\n\t/* begin cWordsPtr:minSize: */\n\tsuccess((isWords(bitmapOop))\n\t && ((stSizeOf(bitmapOop)) >= (w * h)));\n\tbitmapPtr = (failed()\n\t\t? 0\n\t\t: ((void *) (firstIndexableField(bitmapOop))));\n\tif (failed()) {\n\t\treturn null;\n\t}\n\tutf8Length = stSizeOf(utf8Oop);\n\tunicodeDrawString(utf8, utf8Length, &w, &h, bitmapPtr);\n\tresult = makePointwithxValueyValue(w, h);\n\tpopthenPush(5, result);\n\treturn 0;\n}", "item_id": 3, "repo": "pavel-krivanek/opensmalltalk-vm", "file": "src/plugins/UnicodePlugin/UnicodePlugin.c", "last_update_at": "2018-11-18T16:49:56+00:00", "question_id": "b14983e5a0f4f2c9b9d92dd41909a6fa9e6f2a99_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["EXPORT(sqInt)\nprimitiveDrawString(void)\n{\n    sqInt bitmapOop;\n    void *bitmapPtr;\n    sqInt h;\n    sqInt result;\n    char *utf8;\n    sqInt utf8Length;\n    sqInt utf8Oop;\n    sqInt w;\n\tutf8Oop = stackValue(3);\n\t/* begin asCString: */\n\tsuccess(isBytes(utf8Oop));\n\tutf8 = (failed()\n\t\t? 0\n\t\t: ((char *) (firstIndexableField(utf8Oop))));\n\tw = stackIntegerValue(2);\n\th = stackIntegerValue(1);\n\tbitmapOop = stackValue(0);\n\t/* begin cWordsPtr:minSize: */\n\tsuccess((isWords(bitmapOop))\n\t && ((stSizeOf(bitmapOop)) >= (w * h)));\n\tbitmapPtr = (failed()\n\t\t? 0\n\t\t: ((void *) (firstIndexableField(bitmapOop))));\n\tif (failed()) {\n\t\treturn null;\n\t}\n\tutf8Length = stSizeOf(utf8Oop);\n\tunicodeDrawString(utf8, utf8Length, &w, &h, bitmapPtr);\n\tresult = makePointwithxValueyValue(w, h);\n\tpopthenPush(5, result);\n\treturn 0;\n"]], "pred": {"ppl": 3.2346081733703613, "ppl_lower": 4.403112411499023, "ppl/lowercase_ppl": -1.2627155707354984, "ppl/zlib": 0.0029644136352448215, "Min_5.0% Prob": 9.825777783113367, "Min_10.0% Prob": 7.756926284116857, "Min_20.0% Prob": 5.214584853719263, "Min_30.0% Prob": 3.7515238240069033, "Min_40.0% Prob": 2.8890542732003857, "Min_50.0% Prob": 2.33390941979254, "Min_60.0% Prob": 1.9528207323039133}}
{"hexsha": "f0f5d657ffbdba29fcd65c553f69f3cf5db3f342", "ext": "c", "lang": "C", "content": "stack * createstack (){\n\tstack * new = malloc(sizeof(stack));\n\tnew->top = -1;\n\treturn new;\n}", "item_id": 0, "repo": "ShanManage/UCSC", "file": "1st_sem/DSA/stack/structimpliment.c", "last_update_at": "2018-11-25T14:34:33+00:00", "question_id": "f0f5d657ffbdba29fcd65c553f69f3cf5db3f342_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["stack * createstack (){\n\tstack * new = malloc(sizeof(stack));\n\tnew->top = -1;\n\treturn new;\n"]], "pred": {"ppl": 4.822692394256592, "ppl_lower": 4.822692394256592, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.01895581156783534, "Min_5.0% Prob": 11.643108367919922, "Min_10.0% Prob": 9.405297438303629, "Min_20.0% Prob": 6.072632244655064, "Min_30.0% Prob": 4.790692389011383, "Min_40.0% Prob": 3.7495402225426266, "Min_50.0% Prob": 3.0581108132998147, "Min_60.0% Prob": 2.660786364759718}}
{"hexsha": "e7cd28714534062c473f49c8139e25a0ca4f2333", "ext": "c", "lang": "C", "content": "static void create_branch_atom(simplex_solver_t *solver, thvar_t x) {\n  xrational_t *bound;\n  int32_t new_idx, lb, ub;\n  literal_t l;\n\n  assert(arith_var_is_int(&solver->vtbl, x) & ! arith_var_value_is_int(&solver->vtbl, x));\n\n  bound = &solver->bound;\n  lb = arith_var_lower_index(&solver->vtbl, x);\n  ub = arith_var_upper_index(&solver->vtbl, x);\n  if (lb >= 0 && ub >= 0) {\n    xq_set(bound, solver->bstack.bound + lb);\n    xq_add(bound, solver->bstack.bound + ub);\n    q_set32(&solver->aux, 2);\n    xq_div(bound, &solver->aux);\n  } else {\n    xq_set(bound, arith_var_value(&solver->vtbl, x));\n  }\n  xq_ceil(bound);\n  assert(xq_is_integer(bound));\n\n#if 0\n  printf(\"\\n---> Branch & bound\\n\\n\");\n  print_simplex_matrix(stdout, solver);\n  print_simplex_bounds(stdout, solver);\n  printf(\"\\n\");\n  print_simplex_assignment(stdout, solver);\n#endif\n\n  l = get_literal_for_ge_atom(&solver->atbl, x, true, &bound->main, &new_idx);\n  solver->last_branch_atom = var_of(l);\n\n  /*\n   * If support periodic calls to make_integer_feasible is enabled,\n   * then the branch atom may not be new.\n   */\n  // assert(new_idx >= 0);\n  if (new_idx >= 0) {\n    build_binary_lemmas_for_atom(solver, x, new_idx);\n    attach_atom_to_arith_var(&solver->vtbl, x, new_idx);\n\n#if TRACE_BB || TRACE_INTFEAS\n    //    printf(\"---> Branch & bound: create \");\n    print_simplex_atomdef(stdout, solver, var_of(l));\n#endif\n\n    solver->stats.num_branch_atoms ++;\n  }\n}", "item_id": 172, "repo": "maelvls/ocamlyices2", "file": "ext/yices/src/solvers/simplex/simplex.c", "last_update_at": "2018-11-23T00:16:01+00:00", "question_id": "e7cd28714534062c473f49c8139e25a0ca4f2333_172", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void create_branch_atom(simplex_solver_t *solver, thvar_t x) {\n  xrational_t *bound;\n  int32_t new_idx, lb, ub;\n  literal_t l;\n  assert(arith_var_is_int(&solver->vtbl, x) & ! arith_var_value_is_int(&solver->vtbl, x));\n  bound = &solver->bound;\n  lb = arith_var_lower_index(&solver->vtbl, x);\n  ub = arith_var_upper_index(&solver->vtbl, x);\n  if (lb >= 0 && ub >= 0) {\n    xq_set(bound, solver->bstack.bound + lb);\n    xq_add(bound, solver->bstack.bound + ub);\n    q_set32(&solver->aux, 2);\n    xq_div(bound, &solver->aux);\n  } else {\n    xq_set(bound, arith_var_value(&solver->vtbl, x));\n  }\n  xq_ceil(bound);\n  assert(xq_is_integer(bound));\n#if 0\n  printf(\"\\n---> Branch & bound\\n\\n\");\n  print_simplex_matrix(stdout, solver);\n  print_simplex_bounds(stdout, solver);\n  printf(\"\\n\");\n  print_simplex_assignment(stdout, solver);\n#endif\n  l = get_literal_for_ge_atom(&solver->atbl, x, true, &bound->main, &new_idx);\n  solver->last_branch_atom = var_of(l);\n  /*\n   * If support periodic calls to make_integer_feasible is enabled,\n   * then the branch atom may not be new.\n   */\n  // assert(new_idx >= 0);\n  if (new_idx >= 0) {\n    build_binary_lemmas_for_atom(solver, x, new_idx);\n    attach_atom_to_arith_var(&solver->vtbl, x, new_idx);\n#if TRACE_BB || TRACE_INTFEAS\n    //    printf(\"---> Branch & bound: create \");\n    print_simplex_atomdef(stdout, solver, var_of(l));\n#endif\n    solver->stats.num_branch_atoms ++;\n  }\n"]], "pred": {"ppl": 3.353797674179077, "ppl_lower": 3.4296071529388428, "ppl/lowercase_ppl": -1.0184716198380799, "ppl/zlib": 0.001970836055117871, "Min_5.0% Prob": 8.980173768668338, "Min_10.0% Prob": 7.100449238793325, "Min_20.0% Prob": 4.960094819549753, "Min_30.0% Prob": 3.741576090871289, "Min_40.0% Prob": 2.956099827419265, "Min_50.0% Prob": 2.406851949126625, "Min_60.0% Prob": 2.015592331071916}}
{"hexsha": "12fd50a0d39f350216a7bf29648ed4493444da7d", "ext": "c", "lang": "C", "content": "PUBLIC FILE *sys_driver_1(FILE *output, int lines, char *file_name)\n{\n    char path[80];\n\n    if(!(_input_file = fopen(file_name, \"r\"))){\n        sys_searchenv(file_name, \"CGKLIB\", path);   /*Library to be modified....*/\n        if(!*path) {\n            errno = ENOENT;\n            return NULL;\n        }\n\n        if(!(_input_file = fopen(path, \"r\"))){\n            return NULL;\n        }\n    }\n\n    strncpy(_file_name, file_name, sizeof(_file_name));\n    _input_line = 0;\n    sys_driver_2(output, lines);\n\n    return _input_file;\n}", "item_id": 5, "repo": "Mookel/cgkits", "file": "compiler/lib/syslib.c", "last_update_at": "2018-10-09T05:33:13+00:00", "question_id": "12fd50a0d39f350216a7bf29648ed4493444da7d_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["PUBLIC FILE *sys_driver_1(FILE *output, int lines, char *file_name)\n{\n    char path[80];\n    if(!(_input_file = fopen(file_name, \"r\"))){\n        sys_searchenv(file_name, \"CGKLIB\", path);   /*Library to be modified....*/\n        if(!*path) {\n            errno = ENOENT;\n            return NULL;\n        }\n        if(!(_input_file = fopen(path, \"r\"))){\n            return NULL;\n        }\n    }\n    strncpy(_file_name, file_name, sizeof(_file_name));\n    _input_line = 0;\n    sys_driver_2(output, lines);\n    return _input_file;\n"]], "pred": {"ppl": 3.9864418506622314, "ppl_lower": 4.70393705368042, "ppl/lowercase_ppl": -1.1196766754752254, "ppl/zlib": 0.005047076884269825, "Min_5.0% Prob": 9.339742077721489, "Min_10.0% Prob": 7.70999476784154, "Min_20.0% Prob": 5.6899859089600415, "Min_30.0% Prob": 4.295338524015326, "Min_40.0% Prob": 3.363345627721987, "Min_50.0% Prob": 2.7377242572997744, "Min_60.0% Prob": 2.3015874620330963}}
{"hexsha": "fc0a92ef6cd26feaa8c872f843b1d960bf8f2e90", "ext": "c", "lang": "C", "content": "void peturb(double *lvParam) {\n\t//printf(\"Starting peturb...\\n\");\n\n\tconst double SIGMA = 0.01;\n\t//printf(\"lvParam_before %f, %f, %f\\n\", lvParam[0], lvParam[1], lvParam[2]);\n\tlvParam[0] = lvParam[0] * exp(gsl_ran_gaussian(r, SIGMA));\n\tlvParam[1] = lvParam[1] * exp(gsl_ran_gaussian(r, SIGMA));\n\tlvParam[2] = lvParam[2] * exp(gsl_ran_gaussian(r, SIGMA));\n\t//printf(\"lvParam_after  %f, %f, %f\\n\", lvParam[0], lvParam[1], lvParam[2]);\n}", "item_id": 4, "repo": "scania/scania-pmcmc", "file": "MPI/main/bayeskit.c", "last_update_at": "2018-01-31T04:07:03+00:00", "question_id": "fc0a92ef6cd26feaa8c872f843b1d960bf8f2e90_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void peturb(double *lvParam) {\n\t//printf(\"Starting peturb...\\n\");\n\tconst double SIGMA = 0.01;\n\t//printf(\"lvParam_before %f, %f, %f\\n\", lvParam[0], lvParam[1], lvParam[2]);\n\tlvParam[0] = lvParam[0] * exp(gsl_ran_gaussian(r, SIGMA));\n\tlvParam[1] = lvParam[1] * exp(gsl_ran_gaussian(r, SIGMA));\n\tlvParam[2] = lvParam[2] * exp(gsl_ran_gaussian(r, SIGMA));\n\t//printf(\"lvParam_after  %f, %f, %f\\n\", lvParam[0], lvParam[1], lvParam[2]);\n"]], "pred": {"ppl": 2.1106934547424316, "ppl_lower": 2.1052515506744385, "ppl/lowercase_ppl": -0.9965441414315324, "ppl/zlib": 0.0039947408825165035, "Min_5.0% Prob": 7.578350162506103, "Min_10.0% Prob": 5.47953766868228, "Min_20.0% Prob": 3.518347056139083, "Min_30.0% Prob": 2.470636890994178, "Min_40.0% Prob": 1.8638331382535398, "Min_50.0% Prob": 1.493161590632406, "Min_60.0% Prob": 1.2448059843256256}}
{"hexsha": "cab87f5ce6d377d5686937e9025eb3782f85d79e", "ext": "c", "lang": "C", "content": "static int drv260x_parse_dt(struct device *dev,\n\t\t\t    struct drv260x_data *haptics)\n{\n\tstruct device_node *np = dev->of_node;\n\tunsigned int voltage;\n\tint error;\n\n\terror = of_property_read_u32(np, \"mode\", &haptics->mode);\n\tif (error) {\n\t\tdev_err(dev, \"%s: No entry for mode\\n\", __func__);\n\t\treturn error;\n\t}\n\n\terror = of_property_read_u32(np, \"library-sel\", &haptics->library);\n\tif (error) {\n\t\tdev_err(dev, \"%s: No entry for library selection\\n\",\n\t\t\t__func__);\n\t\treturn error;\n\t}\n\n\terror = of_property_read_u32(np, \"vib-rated-mv\", &voltage);\n\tif (!error)\n\t\thaptics->rated_voltage = drv260x_calculate_voltage(voltage);\n\n\n\terror = of_property_read_u32(np, \"vib-overdrive-mv\", &voltage);\n\tif (!error)\n\t\thaptics->overdrive_voltage = drv260x_calculate_voltage(voltage);\n\n\treturn 0;\n}", "item_id": 4, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/drivers/input/misc/drv260x.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "cab87f5ce6d377d5686937e9025eb3782f85d79e_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int drv260x_parse_dt(struct device *dev,\n\t\t\t    struct drv260x_data *haptics)\n{\n\tstruct device_node *np = dev->of_node;\n\tunsigned int voltage;\n\tint error;\n\terror = of_property_read_u32(np, \"mode\", &haptics->mode);\n\tif (error) {\n\t\tdev_err(dev, \"%s: No entry for mode\\n\", __func__);\n\t\treturn error;\n\t}\n\terror = of_property_read_u32(np, \"library-sel\", &haptics->library);\n\tif (error) {\n\t\tdev_err(dev, \"%s: No entry for library selection\\n\",\n\t\t\t__func__);\n\t\treturn error;\n\t}\n\terror = of_property_read_u32(np, \"vib-rated-mv\", &voltage);\n\tif (!error)\n\t\thaptics->rated_voltage = drv260x_calculate_voltage(voltage);\n\terror = of_property_read_u32(np, \"vib-overdrive-mv\", &voltage);\n\tif (!error)\n\t\thaptics->overdrive_voltage = drv260x_calculate_voltage(voltage);\n\treturn 0;\n"]], "pred": {"ppl": 1.7072923183441162, "ppl_lower": 1.7083041667938232, "ppl/lowercase_ppl": -1.00110764165281, "ppl/zlib": 0.0017367164804686587, "Min_5.0% Prob": 6.988158197963939, "Min_10.0% Prob": 4.703789268221174, "Min_20.0% Prob": 2.6229826416288105, "Min_30.0% Prob": 1.780067284724542, "Min_40.0% Prob": 1.3413467537279107, "Min_50.0% Prob": 1.0689155516077087, "Min_60.0% Prob": 0.8921977633608161}}
{"hexsha": "c8f90929df14fcdef90c13c04c0c5a9e503bf47e", "ext": "c", "lang": "C", "content": "static int fpc1020_supply_init(fpc1020_data_t *fpc1020)\n{\n\tint error = 0;\n\n\t/*Determine is we should use external regulator for\n\tpower sully to the bezel. */\n\tif (fpc1020->use_regulator_for_bezel) {\n\t\t/*error = fpc1020_regulator_configure(fpc1020); */\n\t\tif (error) {\n\t\t\tdev_err(&fpc1020->spi->dev,\n\t\t\t\t\t\"fpc1020_probe - regulator configuration failed.\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\t/*error = fpc1020_regulator_set(fpc1020, true);*/\n\t\tif (error) {\n\t\t\tdev_err(&fpc1020->spi->dev,\n\t\t\t\t\t\"fpc1020_probe - regulator enable failed.\\n\");\n\t\t\tgoto err;\n\t\t}\n\t }\n\nerr:\n\treturn error;\n}", "item_id": 12, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/drivers/input/fingerprint/fpc1020_main.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "c8f90929df14fcdef90c13c04c0c5a9e503bf47e_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int fpc1020_supply_init(fpc1020_data_t *fpc1020)\n{\n\tint error = 0;\n\t/*Determine is we should use external regulator for\n\tpower sully to the bezel. */\n\tif (fpc1020->use_regulator_for_bezel) {\n\t\t/*error = fpc1020_regulator_configure(fpc1020); */\n\t\tif (error) {\n\t\t\tdev_err(&fpc1020->spi->dev,\n\t\t\t\t\t\"fpc1020_probe - regulator configuration failed.\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\t/*error = fpc1020_regulator_set(fpc1020, true);*/\n\t\tif (error) {\n\t\t\tdev_err(&fpc1020->spi->dev,\n\t\t\t\t\t\"fpc1020_probe - regulator enable failed.\\n\");\n\t\t\tgoto err;\n\t\t}\n\t }\nerr:\n\treturn error;\n"]], "pred": {"ppl": 2.385634422302246, "ppl_lower": 2.396650552749634, "ppl/lowercase_ppl": -1.005298735369299, "ppl/zlib": 0.0031965628460491904, "Min_5.0% Prob": 8.162653752735682, "Min_10.0% Prob": 5.8180674484797885, "Min_20.0% Prob": 3.9181733340547797, "Min_30.0% Prob": 2.8383445620536802, "Min_40.0% Prob": 2.1584024660681425, "Min_50.0% Prob": 1.7411346487097548, "Min_60.0% Prob": 1.448023875508109}}
{"hexsha": "9ea019461b76d247624a20142ae092ef7e100b28", "ext": "c", "lang": "C", "content": "char *RKLastTwoPartsOfPath(const char *path) {\n    char *a0 = strchr((char *)path, '/');\n    char *a1 = strchr(a0 + 1, '/');\n    char *a2 = strchr(a1 + 1, '/');\n    if (a0 == NULL) {\n        return a0;\n    } else if (a1 != NULL) {\n        if (a2 == NULL) {\n            return a1;\n        } else if (a2 != NULL) {\n            do {\n                a0 = a1;\n                a1 = a2;\n                a2 = strchr(a2 + 1, '/');\n            } while (a2 != NULL);\n        }\n    }\n    return a0 + 1;\n}", "item_id": 16, "repo": "OURadar/radarkit", "file": "source/RKMisc.c", "last_update_at": "2018-03-16T16:41:48+00:00", "question_id": "9ea019461b76d247624a20142ae092ef7e100b28_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["char *RKLastTwoPartsOfPath(const char *path) {\n    char *a0 = strchr((char *)path, '/');\n    char *a1 = strchr(a0 + 1, '/');\n    char *a2 = strchr(a1 + 1, '/');\n    if (a0 == NULL) {\n        return a0;\n    } else if (a1 != NULL) {\n        if (a2 == NULL) {\n            return a1;\n        } else if (a2 != NULL) {\n            do {\n                a0 = a1;\n                a1 = a2;\n                a2 = strchr(a2 + 1, '/');\n            } while (a2 != NULL);\n        }\n    }\n    return a0 + 1;\n"]], "pred": {"ppl": 2.1005916595458984, "ppl_lower": 2.283827066421509, "ppl/lowercase_ppl": -1.1126803822569904, "ppl/zlib": 0.003825871379836478, "Min_5.0% Prob": 7.4969551298353405, "Min_10.0% Prob": 5.466819458537632, "Min_20.0% Prob": 3.340224317602209, "Min_30.0% Prob": 2.385118534256305, "Min_40.0% Prob": 1.825218562980493, "Min_50.0% Prob": 1.4719733308128855, "Min_60.0% Prob": 1.2409325042806034}}
{"hexsha": "fd8754ce9fdfa65fb27a1e98816c674e8691e1f4", "ext": "c", "lang": "C", "content": "static int\nMHD_poll_all (struct MHD_Daemon *daemon,\n\t      int may_block)\n{\n  unsigned int num_connections;\n  struct MHD_Connection *pos;\n  struct MHD_Connection *next;\n\n  if ( (MHD_USE_SUSPEND_RESUME == (daemon->options & MHD_USE_SUSPEND_RESUME)) &&\n       (MHD_YES == resume_suspended_connections (daemon)) )\n    may_block = MHD_NO;\n\n  /* count number of connections and thus determine poll set size */\n  num_connections = 0;\n  for (pos = daemon->connections_head; NULL != pos; pos = pos->next)\n    num_connections++;\n  {\n    MHD_UNSIGNED_LONG_LONG ltimeout;\n    unsigned int i;\n    int timeout;\n    unsigned int poll_server;\n    int poll_listen;\n    int poll_pipe;\n    struct pollfd *p;\n\n    p = malloc(sizeof (struct pollfd) * (2 + num_connections));\n    if (NULL == p)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG(daemon,\n                 \"Error allocating memory: %s\\n\",\n                 MHD_strerror_(errno));\n#endif\n        return MHD_NO;\n      }\n    memset (p, 0, sizeof (struct pollfd) * (2 + num_connections));\n    poll_server = 0;\n    poll_listen = -1;\n    if ( (MHD_INVALID_SOCKET != daemon->socket_fd) &&\n\t (daemon->connections < daemon->connection_limit) &&\n         (MHD_NO == daemon->at_limit) )\n      {\n\t/* only listen if we are not at the connection limit */\n\tp[poll_server].fd = daemon->socket_fd;\n\tp[poll_server].events = POLLIN;\n\tp[poll_server].revents = 0;\n\tpoll_listen = (int) poll_server;\n\tpoll_server++;\n      }\n    poll_pipe = -1;\n    if (MHD_INVALID_PIPE_ != daemon->wpipe[0])\n      {\n\tp[poll_server].fd = daemon->wpipe[0];\n\tp[poll_server].events = POLLIN;\n\tp[poll_server].revents = 0;\n        poll_pipe = (int) poll_server;\n\tpoll_server++;\n      }\n    if (may_block == MHD_NO)\n      timeout = 0;\n    else if ( (0 != (daemon->options & MHD_USE_THREAD_PER_CONNECTION)) ||\n\t      (MHD_YES != MHD_get_timeout (daemon, &ltimeout)) )\n      timeout = -1;\n    else\n      timeout = (ltimeout > INT_MAX) ? INT_MAX : (int) ltimeout;\n\n    i = 0;\n    for (pos = daemon->connections_head; NULL != pos; pos = pos->next)\n      {\n\tp[poll_server+i].fd = pos->socket_fd;\n\tswitch (pos->event_loop_info)\n\t  {\n\t  case MHD_EVENT_LOOP_INFO_READ:\n\t    p[poll_server+i].events |= POLLIN;\n\t    break;\n\t  case MHD_EVENT_LOOP_INFO_WRITE:\n\t    p[poll_server+i].events |= POLLOUT;\n\t    if (pos->read_buffer_size > pos->read_buffer_offset)\n\t      p[poll_server+i].events |= POLLIN;\n\t    break;\n\t  case MHD_EVENT_LOOP_INFO_BLOCK:\n\t    if (pos->read_buffer_size > pos->read_buffer_offset)\n\t      p[poll_server+i].events |= POLLIN;\n\t    break;\n\t  case MHD_EVENT_LOOP_INFO_CLEANUP:\n\t    timeout = 0; /* clean up \"pos\" immediately */\n\t    break;\n\t  }\n\ti++;\n      }\n    if (0 == poll_server + num_connections)\n      {\n        free(p);\n        return MHD_YES;\n      }\n    if (MHD_sys_poll_(p, poll_server + num_connections, timeout) < 0)\n      {\n\tif (EINTR == MHD_socket_errno_)\n      {\n        free(p);\n        return MHD_YES;\n      }\n#ifdef HAVE_MESSAGES\n\tMHD_DLOG (daemon,\n\t\t  \"poll failed: %s\\n\",\n\t\t  MHD_socket_last_strerr_ ());\n#endif\n        free(p);\n\treturn MHD_NO;\n      }\n    /* handle pipe FD */\n    /* do it before any other processing so\n       new signals will be processed in next loop */\n    if ( (-1 != poll_pipe) &&\n         (0 != (p[poll_pipe].revents & POLLIN)) )\n      MHD_pipe_drain_ (daemon->wpipe[0]);\n\n    /* handle shutdown */\n    if (MHD_YES == daemon->shutdown)\n      {\n        free(p);\n        return MHD_NO;\n      }\n    i = 0;\n    next = daemon->connections_head;\n    while (NULL != (pos = next))\n      {\n\tnext = pos->next;\n        /* first, sanity checks */\n        if (i >= num_connections)\n          continue; /* connection list changed somehow, retry later ... */\n        if (p[poll_server+i].fd != pos->socket_fd)\n          continue; /* fd mismatch, something else happened, retry later ... */\n        call_handlers (pos,\n                       0 != (p[poll_server+i].revents & POLLIN),\n                       0 != (p[poll_server+i].revents & POLLOUT),\n                       MHD_NO);\n      }\n    /* handle 'listen' FD */\n    if ( (-1 != poll_listen) &&\n\t (0 != (p[poll_listen].revents & POLLIN)) )\n      (void) MHD_accept_connection (daemon);\n\n    free(p);\n  }\n  return MHD_YES;\n}", "item_id": 24, "repo": "mfrigillana/sqlnotebook", "file": "ext/libmicrohttpd/mhd/src/microhttpd/daemon.c", "last_update_at": "2018-11-03T06:56:49+00:00", "question_id": "fd8754ce9fdfa65fb27a1e98816c674e8691e1f4_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nMHD_poll_all (struct MHD_Daemon *daemon,\n\t      int may_block)\n{\n  unsigned int num_connections;\n  struct MHD_Connection *pos;\n  struct MHD_Connection *next;\n  if ( (MHD_USE_SUSPEND_RESUME == (daemon->options & MHD_USE_SUSPEND_RESUME)) &&\n       (MHD_YES == resume_suspended_connections (daemon)) )\n    may_block = MHD_NO;\n  /* count number of connections and thus determine poll set size */\n  num_connections = 0;\n  for (pos = daemon->connections_head; NULL != pos; pos = pos->next)\n    num_connections++;\n  {\n    MHD_UNSIGNED_LONG_LONG ltimeout;\n    unsigned int i;\n    int timeout;\n    unsigned int poll_server;\n    int poll_listen;\n    int poll_pipe;\n    struct pollfd *p;\n    p = malloc(sizeof (struct pollfd) * (2 + num_connections));\n    if (NULL == p)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG(daemon,\n                 \"Error allocating memory: %s\\n\",\n                 MHD_strerror_(errno));\n#endif\n        return MHD_NO;\n      }\n    memset (p, 0, sizeof (struct pollfd) * (2 + num_connections));\n    poll_server = 0;\n    poll_listen = -1;\n    if ( (MHD_INVALID_SOCKET != daemon->socket_fd) &&\n\t (daemon->connections < daemon->connection_limit) &&\n         (MHD_NO == daemon->at_limit) )\n      {\n\t/* only listen if we are not at the connection limit */\n\tp[poll_server].fd = daemon->socket_fd;\n\tp[poll_server].events = POLLIN;\n\tp[poll_server].revents = 0;\n\tpoll_listen = (int) poll_server;\n\tpoll_server++;\n      }\n    poll_pipe = -1;\n    if (MHD_INVALID_PIPE_ != daemon->wpipe[0])\n      {\n\tp[poll_server].fd = daemon->wpipe[0];\n\tp[poll_server].events = POLLIN;\n\tp[poll_server].revents = 0;\n        poll_pipe = (int) poll_server;\n\tpoll_server++;\n      }\n    if (may_block == MHD_NO)\n      timeout = 0;\n    else if ( (0 != (daemon->options & MHD_USE_THREAD_PER_CONNECTION)) ||\n\t      (MHD_YES != MHD_get_timeout (daemon, &ltimeout)) )\n      timeout = -1;\n    else\n      timeout = (ltimeout > INT_MAX) ? INT_MAX : (int) ltimeout;\n    i = 0;\n    for (pos = daemon->connections_head; NULL != pos; pos = pos->next)\n      {\n\tp[poll_server+i].fd = pos->socket_fd;\n\tswitch (pos->event_loop_info)\n\t  {\n\t  case MHD_EVENT_LOOP_INFO_READ:\n\t    p[poll_server+i].events |= POLLIN;\n\t    break;\n\t  case MHD_EVENT_LOOP_INFO_WRITE:\n\t    p[poll_server+i].events |= POLLOUT;\n\t    if (pos->read_buffer_size > pos->read_buffer_offset)\n\t      p[poll_server+i].events |= POLLIN;\n\t    break;\n\t  case MHD_EVENT_LOOP_INFO_BLOCK:\n\t    if (pos->read_buffer_size > pos->read_buffer_offset)\n\t      p[poll_server+i].events |= POLLIN;\n\t    break;\n\t  case MHD_EVENT_LOOP_INFO_CLEANUP:\n\t    timeout = 0; /* clean up \"pos\" immediately */\n\t    break;\n\t  }\n\ti++;\n      }\n    if (0 == poll_server + num_connections)\n      {\n        free(p);\n        return MHD_YES;\n      }\n    if (MHD_sys_poll_(p, poll_server + num_connections, timeout) < 0)\n      {\n\tif (EINTR == MHD_socket_errno_)\n      {\n        free(p);\n        return MHD_YES;\n      }\n#ifdef HAVE_MESSAGES\n\tMHD_DLOG (daemon,\n\t\t  \"poll failed: %s\\n\",\n\t\t  MHD_socket_last_strerr_ ());\n#endif\n        free(p);\n\treturn MHD_NO;\n      }\n    /* handle pipe FD */\n    /* do it before any other processing so\n       new signals will be processed in next loop */\n    if ( (-1 != poll_pipe) &&\n         (0 != (p[poll_pipe].revents & POLLIN)) )\n      MHD_pipe_drain_ (daemon->wpipe[0]);\n    /* handle shutdown */\n    if (MHD_YES == daemon->shutdown)\n      {\n        free(p);\n        return MHD_NO;\n      }\n    i = 0;\n    next = daemon->connections_head;\n    while (NULL != (pos = next))\n      {\n\tnext = pos->next;\n        /* first, sanity checks */\n        if (i >= num_connections)\n          continue; /* connection list changed somehow, retry later ... */\n        if (p[poll_server+i].fd != pos->socket_fd)\n          continue; /* fd mismatch, something else happened, retry later ... */\n        call_handlers (pos,\n                       0 != (p[poll_server+i].revents & POLLIN),\n                       0 != (p[poll_server+i].revents & POLLOUT),\n                       MHD_NO);\n      }\n    /* handle 'listen' FD */\n    if ( (-1 != poll_listen) &&\n\t (0 != (p[poll_listen].revents & POLLIN)) )\n      (void) MHD_accept_connection (daemon);\n    free(p);\n  }\n  return MHD_YES;\n"]], "pred": {"ppl": 1.5164523124694824, "ppl_lower": 1.978453278541565, "ppl/lowercase_ppl": -1.6387094760961791, "ppl/zlib": 0.0002993340056568478, "Min_5.0% Prob": 4.798450128704894, "Min_10.0% Prob": 3.2943335093703925, "Min_20.0% Prob": 1.9754913780911296, "Min_30.0% Prob": 1.3695126337796644, "Min_40.0% Prob": 1.0363835323474444, "Min_50.0% Prob": 0.8323656124210462, "Min_60.0% Prob": 0.6946004514375832}}
{"hexsha": "da1610f35a336ac8442985c8798a063e2a6844cf", "ext": "h", "lang": "C", "content": "interface PKPayment : NSObject <NSSecureCoding> {\n    PKContact * _billingContact;\n    PKContact * _shippingContact;\n    PKShippingMethod * _shippingMethod;\n    PKPaymentToken * _token;\n}", "item_id": 0, "repo": "shaojiankui/iOS10-Runtime-Headers", "file": "PrivateFrameworks/PassKitCore.framework/PKPayment.h", "last_update_at": "2018-10-08T04:12:25+00:00", "question_id": "da1610f35a336ac8442985c8798a063e2a6844cf_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface PKPayment : NSObject <NSSecureCoding> {\n    PKContact * _billingContact;\n    PKContact * _shippingContact;\n    PKShippingMethod * _shippingMethod;\n    PKPaymentToken * _token;\n"]], "pred": {"ppl": 2.3941802978515625, "ppl_lower": 4.712595462799072, "ppl/lowercase_ppl": -1.77567715361145, "ppl/zlib": 0.007275340972381069, "Min_5.0% Prob": 8.53477923075358, "Min_10.0% Prob": 5.687971830368042, "Min_20.0% Prob": 3.6821002463499704, "Min_30.0% Prob": 2.785999642478095, "Min_40.0% Prob": 2.1575728952884674, "Min_50.0% Prob": 1.7414278784145911, "Min_60.0% Prob": 1.453640404661807}}
{"hexsha": "c4671dfd971444beb4b46dc8c97ddbceafa3ecdf", "ext": "h", "lang": "C", "content": "class People{\npublic:\n\tPeople(Mediator *mediator);\n\t~People();\npublic:\n\tMediator *mediator_;\n}", "item_id": 0, "repo": "HelenXR/design_patterns_HelenXR-Dev-", "file": "behavioral_patterns/mediator/source/people.h", "last_update_at": "2018-10-10T17:17:27+00:00", "question_id": "c4671dfd971444beb4b46dc8c97ddbceafa3ecdf_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class People{\npublic:\n\tPeople(Mediator *mediator);\n\t~People();\npublic:\n\tMediator *mediator_;\n"]], "pred": {"ppl": 5.794541358947754, "ppl_lower": 8.305984497070312, "ppl/lowercase_ppl": -1.2049385866145643, "ppl/zlib": 0.027887560783941764, "Min_5.0% Prob": 8.584412574768066, "Min_10.0% Prob": 8.287990887959799, "Min_20.0% Prob": 6.627532618386405, "Min_30.0% Prob": 5.207593094218861, "Min_40.0% Prob": 4.186144725481669, "Min_50.0% Prob": 3.4686957378136483, "Min_60.0% Prob": 3.024401760914109}}
{"hexsha": "f2104d16e7b028e38ae3b04a9ee950e63eb8aaf6", "ext": "c", "lang": "C", "content": "void LBF_Disable_EXTI_ExtPort( uint16_t  GPIO_Pin)\n{\n    if ( GPIO_Pin == CONN_POS2_PIN )  //PA6 --> EXTI5_9\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_6); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_6); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_6); \n    }\n    // CAUTION: Conflict if also using INT1_ACC_GYR_PIN (from LSM6DS3)\n    // as it also uses pin6 (PC6)\n\n    if ( GPIO_Pin == CONN_POS3_PIN )  //PA4 --> EXTI4\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_4); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_4); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_4); \n    }\n\n    if ( GPIO_Pin == CONN_POS4_PIN )  //PA3 --> EXTI3\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_3); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_3); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_3); \n    }\n\n    if ( GPIO_Pin == CONN_POS5_PIN )  //PA2 --> EXTI2\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_2); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_2); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_2); \n    }\n\n    if ( GPIO_Pin == CONN_POS7_PIN )  //PA1 --> EXTI1\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_1); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_1); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_1); \n    }\n\n    if ( GPIO_Pin == CONN_POS8_PIN )  //PA0 --> EXTI0\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_0); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_0); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_0); \n    }\n\n    if ( GPIO_Pin == CONN_POS10_PIN )  //PB8 --> EXTI5_9\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_8); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_8); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_8); \n    }\n\n    if ( GPIO_Pin == CONN_POS11_PIN )  //PB9 --> EXTI5_9\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_9); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_9); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_9); \n    }\n\n}", "item_id": 1, "repo": "LimiFrog/LimiFrog-SW", "file": "libraries/LimiFrog-Lib/src/LBF_API/LBF_EXTI_ExtPort_lowlevAPI.c", "last_update_at": "2018-10-24T08:41:06+00:00", "question_id": "f2104d16e7b028e38ae3b04a9ee950e63eb8aaf6_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void LBF_Disable_EXTI_ExtPort( uint16_t  GPIO_Pin)\n{\n    if ( GPIO_Pin == CONN_POS2_PIN )  //PA6 --> EXTI5_9\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_6); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_6); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_6); \n    }\n    // CAUTION: Conflict if also using INT1_ACC_GYR_PIN (from LSM6DS3)\n    // as it also uses pin6 (PC6)\n    if ( GPIO_Pin == CONN_POS3_PIN )  //PA4 --> EXTI4\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_4); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_4); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_4); \n    }\n    if ( GPIO_Pin == CONN_POS4_PIN )  //PA3 --> EXTI3\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_3); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_3); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_3); \n    }\n    if ( GPIO_Pin == CONN_POS5_PIN )  //PA2 --> EXTI2\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_2); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_2); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_2); \n    }\n    if ( GPIO_Pin == CONN_POS7_PIN )  //PA1 --> EXTI1\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_1); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_1); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_1); \n    }\n    if ( GPIO_Pin == CONN_POS8_PIN )  //PA0 --> EXTI0\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_0); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_0); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_0); \n    }\n    if ( GPIO_Pin == CONN_POS10_PIN )  //PB8 --> EXTI5_9\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_8); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_8); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_8); \n    }\n    if ( GPIO_Pin == CONN_POS11_PIN )  //PB9 --> EXTI5_9\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_9); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_9); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_9); \n    }\n"]], "pred": {"ppl": 1.3698029518127441, "ppl_lower": 1.5046136379241943, "ppl/lowercase_ppl": -1.2983130667417975, "ppl/zlib": 0.0008789578176027252, "Min_5.0% Prob": 4.868973166334863, "Min_10.0% Prob": 2.9526661242924486, "Min_20.0% Prob": 1.57205031112786, "Min_30.0% Prob": 1.0513459291572385, "Min_40.0% Prob": 0.7869683733508264, "Min_50.0% Prob": 0.6299340562104011, "Min_60.0% Prob": 0.5251262002089777}}
{"hexsha": "7562b9526edd0dbcf7925ed77b06d0420ed0c75b", "ext": "c", "lang": "C", "content": "int32_t aos_pwrmgmt_wifi_powersave_suspend(uint32_t suspend_module)\n{\n    int32_t ret;\n\n    ret = pwrmgmt_wifi_powersave_suspend(suspend_module);\n    return ret;\n}", "item_id": 6, "repo": "HelloAllen8893/AliOS-Things", "file": "core/osal/aos/pwrmgmt.c", "last_update_at": "2018-11-28T03:19:22+00:00", "question_id": "7562b9526edd0dbcf7925ed77b06d0420ed0c75b_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int32_t aos_pwrmgmt_wifi_powersave_suspend(uint32_t suspend_module)\n{\n    int32_t ret;\n    ret = pwrmgmt_wifi_powersave_suspend(suspend_module);\n    return ret;\n"]], "pred": {"ppl": 2.6216516494750977, "ppl_lower": 2.6216516494750977, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.009936129069247976, "Min_5.0% Prob": 8.801317811012268, "Min_10.0% Prob": 6.398514747619629, "Min_20.0% Prob": 4.177880220115185, "Min_30.0% Prob": 3.077102169394493, "Min_40.0% Prob": 2.3764379005879164, "Min_50.0% Prob": 1.9174084078520537, "Min_60.0% Prob": 1.6033796241584544}}
{"hexsha": "6830c84fa7de231061b7cbc7a0e6b49a89f28bd3", "ext": "c", "lang": "C", "content": "static value redirect( value s ) {\n\tmcontext *c = CONTEXT();\n\tval_check(s,string);\n\tHEADERS_NOT_SENT(\"Redirection\");\n\tap_table_set(c->r->headers_out,\"Location\",val_string(s));\n\tc->r->status = REDIRECT;\n\treturn val_true;\n}", "item_id": 3, "repo": "r-lyeh/scriptorium", "file": "neko/src/libs/mod_neko/cgi.c", "last_update_at": "2018-01-08T03:02:37+00:00", "question_id": "6830c84fa7de231061b7cbc7a0e6b49a89f28bd3_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static value redirect( value s ) {\n\tmcontext *c = CONTEXT();\n\tval_check(s,string);\n\tHEADERS_NOT_SENT(\"Redirection\");\n\tap_table_set(c->r->headers_out,\"Location\",val_string(s));\n\tc->r->status = REDIRECT;\n\treturn val_true;\n"]], "pred": {"ppl": 5.181938171386719, "ppl_lower": 6.016796588897705, "ppl/lowercase_ppl": -1.0907960928702034, "ppl/zlib": 0.009190944975696837, "Min_5.0% Prob": 10.34648871421814, "Min_10.0% Prob": 9.025852799415588, "Min_20.0% Prob": 6.844202181872199, "Min_30.0% Prob": 5.023620550449078, "Min_40.0% Prob": 4.049731599933961, "Min_50.0% Prob": 3.285172841230104, "Min_60.0% Prob": 2.74072887447591}}
{"hexsha": "3f37565a6090a282ad57626de8cc5f592d921aac", "ext": "c", "lang": "C", "content": "void print_pfxt(const struct pfx_record *pfx_record, void *data)\n{\n  char ip_pfx[INET6_ADDRSTRLEN];\n  char rec[TEST_BUF_LEN];\n  lrtr_ip_addr_to_str(&(*pfx_record).prefix, ip_pfx, sizeof(ip_pfx));\n  snprintf(rec, sizeof(rec), \"%\" PRIu32 \",%s/%\" PRIu8 \",%\" PRIu8 \"\\n\",\n           (*pfx_record).asn, ip_pfx, (*pfx_record).min_len,\n           (*pfx_record).max_len);\n  strcat((char *)data, rec);\n}", "item_id": 0, "repo": "salsh/libhistoryrpki", "file": "test/roafetchlib-test-config.c", "last_update_at": "2018-08-07T16:15:11+00:00", "question_id": "3f37565a6090a282ad57626de8cc5f592d921aac_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void print_pfxt(const struct pfx_record *pfx_record, void *data)\n{\n  char ip_pfx[INET6_ADDRSTRLEN];\n  char rec[TEST_BUF_LEN];\n  lrtr_ip_addr_to_str(&(*pfx_record).prefix, ip_pfx, sizeof(ip_pfx));\n  snprintf(rec, sizeof(rec), \"%\" PRIu32 \",%s/%\" PRIu8 \",%\" PRIu8 \"\\n\",\n           (*pfx_record).asn, ip_pfx, (*pfx_record).min_len,\n           (*pfx_record).max_len);\n  strcat((char *)data, rec);\n"]], "pred": {"ppl": 2.9132590293884277, "ppl_lower": 3.6330387592315674, "ppl/lowercase_ppl": -1.2064927765843805, "ppl/zlib": 0.004530815236811445, "Min_5.0% Prob": 9.40202385187149, "Min_10.0% Prob": 6.804676574819228, "Min_20.0% Prob": 4.475330894333975, "Min_30.0% Prob": 3.324924483895302, "Min_40.0% Prob": 2.604339244535991, "Min_50.0% Prob": 2.121872390366413, "Min_60.0% Prob": 1.7890799693408466}}
{"hexsha": "2a511de37361d5dd5980337de8f35cb5e4df4314", "ext": "c", "lang": "C", "content": "size_t wcstombs(char* mbstr, const wchar_t *wcstr, size_t max)\n{\n  int count = 0;\n\n  while ((count < max) && (*wcstr != 0))\n  {\n    *mbstr++ = *wcstr++;\n    count++;\n  }\n  return count;\n}", "item_id": 1, "repo": "lunixbochs/ags", "file": "Android/library/jni/libc.c", "last_update_at": "2018-03-29T11:50:29+00:00", "question_id": "2a511de37361d5dd5980337de8f35cb5e4df4314_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["size_t wcstombs(char* mbstr, const wchar_t *wcstr, size_t max)\n{\n  int count = 0;\n  while ((count < max) && (*wcstr != 0))\n  {\n    *mbstr++ = *wcstr++;\n    count++;\n  }\n  return count;\n"]], "pred": {"ppl": 2.157294273376465, "ppl_lower": 2.157294273376465, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.00586912049815368, "Min_5.0% Prob": 6.9216578006744385, "Min_10.0% Prob": 4.888105899095535, "Min_20.0% Prob": 3.1723668505163753, "Min_30.0% Prob": 2.4193530225753785, "Min_40.0% Prob": 1.8800712731831215, "Min_50.0% Prob": 1.5177788587157117, "Min_60.0% Prob": 1.2904979496025573}}
{"hexsha": "3237c2875448890e183441754d4993ba5578d690", "ext": "h", "lang": "C", "content": "static inline uint16 fold_32bit_checksum (uint32 sum)\n{\n   /*  Fold 32-bit sum to 16 bits */\n   while (sum>>16) {\n      sum = (sum & 0xffff) + (sum >> 16);\n   }\n   sum = ~sum & 0xffff;\n   if (sum == 0) {\n      sum = 0xffff;\n   }\n   return (sum);\n}", "item_id": 0, "repo": "aaliomer/exos", "file": "include/exos/netinet/cksum.h", "last_update_at": "2018-01-23T23:07:19+00:00", "question_id": "3237c2875448890e183441754d4993ba5578d690_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline uint16 fold_32bit_checksum (uint32 sum)\n{\n   /*  Fold 32-bit sum to 16 bits */\n   while (sum>>16) {\n      sum = (sum & 0xffff) + (sum >> 16);\n   }\n   sum = ~sum & 0xffff;\n   if (sum == 0) {\n      sum = 0xffff;\n   }\n   return (sum);\n"]], "pred": {"ppl": 2.1254491806030273, "ppl_lower": 2.0242927074432373, "ppl/lowercase_ppl": -0.9353264071169841, "ppl/zlib": 0.004742032447460826, "Min_5.0% Prob": 6.942744445800781, "Min_10.0% Prob": 5.110167004845359, "Min_20.0% Prob": 3.4726003408432007, "Min_30.0% Prob": 2.466686115545385, "Min_40.0% Prob": 1.8581459355419097, "Min_50.0% Prob": 1.511460707049098, "Min_60.0% Prob": 1.252844230690296}}
{"hexsha": "f137cbe98ad9927271ef0e85122efb8b856d3018", "ext": "c", "lang": "C", "content": "void __glXDispSwap_TexImage2D(GLbyte * pc)\n{\n    const GLvoid * const pixels = (const GLvoid *) (pc + 52);\n    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);\n\n    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );\n    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );\n    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) bswap_CARD32( & hdr->rowLength )) );\n    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) bswap_CARD32( & hdr->skipRows )) );\n    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) bswap_CARD32( & hdr->skipPixels )) );\n    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) bswap_CARD32( & hdr->alignment )) );\n\n    CALL_TexImage2D( GET_DISPATCH(), (\n         (GLenum  )bswap_ENUM   ( pc + 20 ),\n         (GLint   )bswap_CARD32 ( pc + 24 ),\n         (GLint   )bswap_CARD32 ( pc + 28 ),\n         (GLsizei )bswap_CARD32 ( pc + 32 ),\n         (GLsizei )bswap_CARD32 ( pc + 36 ),\n         (GLint   )bswap_CARD32 ( pc + 40 ),\n         (GLenum  )bswap_ENUM   ( pc + 44 ),\n         (GLenum  )bswap_ENUM   ( pc + 48 ),\n        pixels\n    ) );\n}", "item_id": 26, "repo": "larsclausen/xglamo", "file": "glx/indirect_dispatch_swap.c", "last_update_at": "2018-11-01T06:58:35+00:00", "question_id": "f137cbe98ad9927271ef0e85122efb8b856d3018_26", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void __glXDispSwap_TexImage2D(GLbyte * pc)\n{\n    const GLvoid * const pixels = (const GLvoid *) (pc + 52);\n    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);\n    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );\n    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );\n    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) bswap_CARD32( & hdr->rowLength )) );\n    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) bswap_CARD32( & hdr->skipRows )) );\n    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) bswap_CARD32( & hdr->skipPixels )) );\n    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) bswap_CARD32( & hdr->alignment )) );\n    CALL_TexImage2D( GET_DISPATCH(), (\n         (GLenum  )bswap_ENUM   ( pc + 20 ),\n         (GLint   )bswap_CARD32 ( pc + 24 ),\n         (GLint   )bswap_CARD32 ( pc + 28 ),\n         (GLsizei )bswap_CARD32 ( pc + 32 ),\n         (GLsizei )bswap_CARD32 ( pc + 36 ),\n         (GLint   )bswap_CARD32 ( pc + 40 ),\n         (GLenum  )bswap_ENUM   ( pc + 44 ),\n         (GLenum  )bswap_ENUM   ( pc + 48 ),\n        pixels\n    ) );\n"]], "pred": {"ppl": 1.4093382358551025, "ppl_lower": 1.9507569074630737, "ppl/lowercase_ppl": -1.9474730490663323, "ppl/zlib": 0.0008958753471132063, "Min_5.0% Prob": 4.599155306816101, "Min_10.0% Prob": 3.0101189219726705, "Min_20.0% Prob": 1.7019837743971709, "Min_30.0% Prob": 1.1422018851852045, "Min_40.0% Prob": 0.8595841379274347, "Min_50.0% Prob": 0.6861048345004944, "Min_60.0% Prob": 0.5725501413774964}}
{"hexsha": "a29aec400085a6a10fb93ec306d1caa0c6ee84dc", "ext": "c", "lang": "C", "content": "VALUE\nrb_rational_uminus(VALUE self)\n{\n    const int unused = (assert(RB_TYPE_P(self, T_RATIONAL)), 0);\n    get_dat1(self);\n    (void)unused;\n    return f_rational_new2(CLASS_OF(self), rb_int_uminus(dat->num), dat->den);\n}", "item_id": 15, "repo": "tenebrousedge/ruby-packer", "file": "ruby/rational.c", "last_update_at": "2018-04-01T14:10:23+00:00", "question_id": "a29aec400085a6a10fb93ec306d1caa0c6ee84dc_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["VALUE\nrb_rational_uminus(VALUE self)\n{\n    const int unused = (assert(RB_TYPE_P(self, T_RATIONAL)), 0);\n    get_dat1(self);\n    (void)unused;\n    return f_rational_new2(CLASS_OF(self), rb_int_uminus(dat->num), dat->den);\n"]], "pred": {"ppl": 3.7055721282958984, "ppl_lower": 5.002216815948486, "ppl/lowercase_ppl": -1.2290692330901438, "ppl/zlib": 0.0075713159966422135, "Min_5.0% Prob": 10.783482313156128, "Min_10.0% Prob": 8.555241796705458, "Min_20.0% Prob": 5.780623536360891, "Min_30.0% Prob": 4.149907845875313, "Min_40.0% Prob": 3.2531586289405823, "Min_50.0% Prob": 2.6162726962938905, "Min_60.0% Prob": 2.1824591714118062}}
{"hexsha": "c03997e33ffd6e6a6f377f305763b867d87ff445", "ext": "h", "lang": "C", "content": "class Att_relay : public TinyMachine {\n  \n    public:\n      Att_relay( void ) : TinyMachine() {};\n  \n      short relay_pin;\n      short led_pin;\n             \n      enum { OFF, ON, BLINK_ON, BLINK_OFF } STATES; \n      enum { EVT_TIMER, EVT_COUNTER_ON,EVT_COUNTER_OFF, EVT_TOGGLE, ELSE } EVENTS; \n      enum { ACT_LED_OFF, ACT_LED_ON, ACT_RELAY_ON, ACT_RELAY_OFF } ACTIONS; \n      // store prev relay state while blinking, so after blink know to blink on or off.\n      bool prev_relay_state;\n\n      short on_blink = 3;\n      short off_blink = 5;\n      atm_timer_millis timer;\n      atm_counter counter_on, counter_off;  \n      \n      Att_relay & begin( short relay_pin, short l_pin);\n\n      Att_relay & setBlink( short repeat, bool on_off ) ;\n\n  \n      int event( int id );\n  \n      void action( int id ); \n  \n  }", "item_id": 0, "repo": "harmon25/Atm_custom", "file": "Att_relay.h", "last_update_at": "2018-01-11T01:54:12+00:00", "question_id": "c03997e33ffd6e6a6f377f305763b867d87ff445_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Att_relay : public TinyMachine {\n    public:\n      Att_relay( void ) : TinyMachine() {};\n      short relay_pin;\n      short led_pin;\n      enum { OFF, ON, BLINK_ON, BLINK_OFF } STATES; \n      enum { EVT_TIMER, EVT_COUNTER_ON,EVT_COUNTER_OFF, EVT_TOGGLE, ELSE } EVENTS; \n      enum { ACT_LED_OFF, ACT_LED_ON, ACT_RELAY_ON, ACT_RELAY_OFF } ACTIONS; \n      // store prev relay state while blinking, so after blink know to blink on or off.\n      bool prev_relay_state;\n      short on_blink = 3;\n      short off_blink = 5;\n      atm_timer_millis timer;\n      atm_counter counter_on, counter_off;  \n      Att_relay & begin( short relay_pin, short l_pin);\n      Att_relay & setBlink( short repeat, bool on_off ) ;\n      int event( int id );\n      void action( int id ); \n"]], "pred": {"ppl": 4.221554756164551, "ppl_lower": 4.988149166107178, "ppl/lowercase_ppl": -1.115859632460856, "ppl/zlib": 0.003750529911008523, "Min_5.0% Prob": 8.700697008768717, "Min_10.0% Prob": 7.073239587968396, "Min_20.0% Prob": 5.252983331680298, "Min_30.0% Prob": 4.167273800860169, "Min_40.0% Prob": 3.3883201236724854, "Min_50.0% Prob": 2.829528734087944, "Min_60.0% Prob": 2.391525289193194}}
{"hexsha": "7591d8901f9a24ddd61d035500116c617e4df3f6", "ext": "c", "lang": "C", "content": "static int tegra_sor_dp_train_fast(struct tegra_sor *sor,\n\t\t\t\t   struct drm_dp_link *link)\n{\n\tunsigned int i;\n\tu8 pattern;\n\tu32 value;\n\tint err;\n\n\t/* setup lane parameters */\n\tvalue = SOR_LANE_DRIVE_CURRENT_LANE3(0x40) |\n\t\tSOR_LANE_DRIVE_CURRENT_LANE2(0x40) |\n\t\tSOR_LANE_DRIVE_CURRENT_LANE1(0x40) |\n\t\tSOR_LANE_DRIVE_CURRENT_LANE0(0x40);\n\ttegra_sor_writel(sor, value, SOR_LANE_DRIVE_CURRENT_0);\n\n\tvalue = SOR_LANE_PREEMPHASIS_LANE3(0x0f) |\n\t\tSOR_LANE_PREEMPHASIS_LANE2(0x0f) |\n\t\tSOR_LANE_PREEMPHASIS_LANE1(0x0f) |\n\t\tSOR_LANE_PREEMPHASIS_LANE0(0x0f);\n\ttegra_sor_writel(sor, value, SOR_LANE_PREEMPHASIS_0);\n\n\tvalue = SOR_LANE_POST_CURSOR_LANE3(0x00) |\n\t\tSOR_LANE_POST_CURSOR_LANE2(0x00) |\n\t\tSOR_LANE_POST_CURSOR_LANE1(0x00) |\n\t\tSOR_LANE_POST_CURSOR_LANE0(0x00);\n\ttegra_sor_writel(sor, value, SOR_LANE_POST_CURSOR_0);\n\n\t/* disable LVDS mode */\n\ttegra_sor_writel(sor, 0, SOR_LVDS);\n\n\tvalue = tegra_sor_readl(sor, SOR_DP_PADCTL_0);\n\tvalue |= SOR_DP_PADCTL_TX_PU_ENABLE;\n\tvalue &= ~SOR_DP_PADCTL_TX_PU_MASK;\n\tvalue |= SOR_DP_PADCTL_TX_PU(2); /* XXX: don't hardcode? */\n\ttegra_sor_writel(sor, value, SOR_DP_PADCTL_0);\n\n\tvalue = tegra_sor_readl(sor, SOR_DP_PADCTL_0);\n\tvalue |= SOR_DP_PADCTL_CM_TXD_3 | SOR_DP_PADCTL_CM_TXD_2 |\n\t\t SOR_DP_PADCTL_CM_TXD_1 | SOR_DP_PADCTL_CM_TXD_0;\n\ttegra_sor_writel(sor, value, SOR_DP_PADCTL_0);\n\n\tusleep_range(10, 100);\n\n\tvalue = tegra_sor_readl(sor, SOR_DP_PADCTL_0);\n\tvalue &= ~(SOR_DP_PADCTL_CM_TXD_3 | SOR_DP_PADCTL_CM_TXD_2 |\n\t\t   SOR_DP_PADCTL_CM_TXD_1 | SOR_DP_PADCTL_CM_TXD_0);\n\ttegra_sor_writel(sor, value, SOR_DP_PADCTL_0);\n\n\terr = tegra_dpaux_prepare(sor->dpaux, DP_SET_ANSI_8B10B);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0, value = 0; i < link->num_lanes; i++) {\n\t\tunsigned long lane = SOR_DP_TPG_CHANNEL_CODING |\n\t\t\t\t     SOR_DP_TPG_SCRAMBLER_NONE |\n\t\t\t\t     SOR_DP_TPG_PATTERN_TRAIN1;\n\t\tvalue = (value << 8) | lane;\n\t}\n\n\ttegra_sor_writel(sor, value, SOR_DP_TPG);\n\n\tpattern = DP_TRAINING_PATTERN_1;\n\n\terr = tegra_dpaux_train(sor->dpaux, link, pattern);\n\tif (err < 0)\n\t\treturn err;\n\n\tvalue = tegra_sor_readl(sor, SOR_DP_SPARE_0);\n\tvalue |= SOR_DP_SPARE_SEQ_ENABLE;\n\tvalue &= ~SOR_DP_SPARE_PANEL_INTERNAL;\n\tvalue |= SOR_DP_SPARE_MACRO_SOR_CLK;\n\ttegra_sor_writel(sor, value, SOR_DP_SPARE_0);\n\n\tfor (i = 0, value = 0; i < link->num_lanes; i++) {\n\t\tunsigned long lane = SOR_DP_TPG_CHANNEL_CODING |\n\t\t\t\t     SOR_DP_TPG_SCRAMBLER_NONE |\n\t\t\t\t     SOR_DP_TPG_PATTERN_TRAIN2;\n\t\tvalue = (value << 8) | lane;\n\t}\n\n\ttegra_sor_writel(sor, value, SOR_DP_TPG);\n\n\tpattern = DP_LINK_SCRAMBLING_DISABLE | DP_TRAINING_PATTERN_2;\n\n\terr = tegra_dpaux_train(sor->dpaux, link, pattern);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0, value = 0; i < link->num_lanes; i++) {\n\t\tunsigned long lane = SOR_DP_TPG_CHANNEL_CODING |\n\t\t\t\t     SOR_DP_TPG_SCRAMBLER_GALIOS |\n\t\t\t\t     SOR_DP_TPG_PATTERN_NONE;\n\t\tvalue = (value << 8) | lane;\n\t}\n\n\ttegra_sor_writel(sor, value, SOR_DP_TPG);\n\n\tpattern = DP_TRAINING_PATTERN_DISABLE;\n\n\terr = tegra_dpaux_train(sor->dpaux, link, pattern);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}", "item_id": 0, "repo": "SIIS-cloud/pileus", "file": "difc-kernel/pileus-kernel/drivers/gpu/drm/tegra/sor.c", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "7591d8901f9a24ddd61d035500116c617e4df3f6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int tegra_sor_dp_train_fast(struct tegra_sor *sor,\n\t\t\t\t   struct drm_dp_link *link)\n{\n\tunsigned int i;\n\tu8 pattern;\n\tu32 value;\n\tint err;\n\t/* setup lane parameters */\n\tvalue = SOR_LANE_DRIVE_CURRENT_LANE3(0x40) |\n\t\tSOR_LANE_DRIVE_CURRENT_LANE2(0x40) |\n\t\tSOR_LANE_DRIVE_CURRENT_LANE1(0x40) |\n\t\tSOR_LANE_DRIVE_CURRENT_LANE0(0x40);\n\ttegra_sor_writel(sor, value, SOR_LANE_DRIVE_CURRENT_0);\n\tvalue = SOR_LANE_PREEMPHASIS_LANE3(0x0f) |\n\t\tSOR_LANE_PREEMPHASIS_LANE2(0x0f) |\n\t\tSOR_LANE_PREEMPHASIS_LANE1(0x0f) |\n\t\tSOR_LANE_PREEMPHASIS_LANE0(0x0f);\n\ttegra_sor_writel(sor, value, SOR_LANE_PREEMPHASIS_0);\n\tvalue = SOR_LANE_POST_CURSOR_LANE3(0x00) |\n\t\tSOR_LANE_POST_CURSOR_LANE2(0x00) |\n\t\tSOR_LANE_POST_CURSOR_LANE1(0x00) |\n\t\tSOR_LANE_POST_CURSOR_LANE0(0x00);\n\ttegra_sor_writel(sor, value, SOR_LANE_POST_CURSOR_0);\n\t/* disable LVDS mode */\n\ttegra_sor_writel(sor, 0, SOR_LVDS);\n\tvalue = tegra_sor_readl(sor, SOR_DP_PADCTL_0);\n\tvalue |= SOR_DP_PADCTL_TX_PU_ENABLE;\n\tvalue &= ~SOR_DP_PADCTL_TX_PU_MASK;\n\tvalue |= SOR_DP_PADCTL_TX_PU(2); /* XXX: don't hardcode? */\n\ttegra_sor_writel(sor, value, SOR_DP_PADCTL_0);\n\tvalue = tegra_sor_readl(sor, SOR_DP_PADCTL_0);\n\tvalue |= SOR_DP_PADCTL_CM_TXD_3 | SOR_DP_PADCTL_CM_TXD_2 |\n\t\t SOR_DP_PADCTL_CM_TXD_1 | SOR_DP_PADCTL_CM_TXD_0;\n\ttegra_sor_writel(sor, value, SOR_DP_PADCTL_0);\n\tusleep_range(10, 100);\n\tvalue = tegra_sor_readl(sor, SOR_DP_PADCTL_0);\n\tvalue &= ~(SOR_DP_PADCTL_CM_TXD_3 | SOR_DP_PADCTL_CM_TXD_2 |\n\t\t   SOR_DP_PADCTL_CM_TXD_1 | SOR_DP_PADCTL_CM_TXD_0);\n\ttegra_sor_writel(sor, value, SOR_DP_PADCTL_0);\n\terr = tegra_dpaux_prepare(sor->dpaux, DP_SET_ANSI_8B10B);\n\tif (err < 0)\n\t\treturn err;\n\tfor (i = 0, value = 0; i < link->num_lanes; i++) {\n\t\tunsigned long lane = SOR_DP_TPG_CHANNEL_CODING |\n\t\t\t\t     SOR_DP_TPG_SCRAMBLER_NONE |\n\t\t\t\t     SOR_DP_TPG_PATTERN_TRAIN1;\n\t\tvalue = (value << 8) | lane;\n\t}\n\ttegra_sor_writel(sor, value, SOR_DP_TPG);\n\tpattern = DP_TRAINING_PATTERN_1;\n\terr = tegra_dpaux_train(sor->dpaux, link, pattern);\n\tif (err < 0)\n\t\treturn err;\n\tvalue = tegra_sor_readl(sor, SOR_DP_SPARE_0);\n\tvalue |= SOR_DP_SPARE_SEQ_ENABLE;\n\tvalue &= ~SOR_DP_SPARE_PANEL_INTERNAL;\n\tvalue |= SOR_DP_SPARE_MACRO_SOR_CLK;\n\ttegra_sor_writel(sor, value, SOR_DP_SPARE_0);\n\tfor (i = 0, value = 0; i < link->num_lanes; i++) {\n\t\tunsigned long lane = SOR_DP_TPG_CHANNEL_CODING |\n\t\t\t\t     SOR_DP_TPG_SCRAMBLER_NONE |\n\t\t\t\t     SOR_DP_TPG_PATTERN_TRAIN2;\n\t\tvalue = (value << 8) | lane;\n\t}\n\ttegra_sor_writel(sor, value, SOR_DP_TPG);\n\tpattern = DP_LINK_SCRAMBLING_DISABLE | DP_TRAINING_PATTERN_2;\n\terr = tegra_dpaux_train(sor->dpaux, link, pattern);\n\tif (err < 0)\n\t\treturn err;\n\tfor (i = 0, value = 0; i < link->num_lanes; i++) {\n\t\tunsigned long lane = SOR_DP_TPG_CHANNEL_CODING |\n\t\t\t\t     SOR_DP_TPG_SCRAMBLER_GALIOS |\n\t\t\t\t     SOR_DP_TPG_PATTERN_NONE;\n\t\tvalue = (value << 8) | lane;\n\t}\n\ttegra_sor_writel(sor, value, SOR_DP_TPG);\n\tpattern = DP_TRAINING_PATTERN_DISABLE;\n\terr = tegra_dpaux_train(sor->dpaux, link, pattern);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n"]], "pred": {"ppl": 1.3910404443740845, "ppl_lower": 1.6722564697265625, "ppl/lowercase_ppl": -1.5578572835595366, "ppl/zlib": 0.00045399173077415234, "Min_5.0% Prob": 4.502384629904055, "Min_10.0% Prob": 3.0003052482417987, "Min_20.0% Prob": 1.6437466828444718, "Min_30.0% Prob": 1.1023055169064844, "Min_40.0% Prob": 0.825395344288036, "Min_50.0% Prob": 0.6607188655204416, "Min_60.0% Prob": 0.5507976065938915}}
{"hexsha": "975b78e6bb712e43333475591cfa8b98746d155a", "ext": "h", "lang": "C", "content": "class ClosedCube_TCA9538 {\npublic:\n\tClosedCube_TCA9538();\n\n\tvoid begin(uint8_t address);\n\tvoid init(TCA9538_Registers regs);\n\n\tTCA9538_Input readInput();\n\n\tvoid writePolarity(TCA9538_PolarityInversion polarity);\n\t\n\tvoid writeOutput(TCA9538_Output output);\n\tTCA9538_Output readOutput();\n\n\tvoid writeConfig(TCA9538_Config config);\n\nprivate:\n\n\tuint8_t writeData(TCA9538_Commands cmd, uint8_t rawData);\n\tuint8_t _address;\n}", "item_id": 0, "repo": "closedcube/ClosedCube_TCA9538_Arduino", "file": "src/ClosedCube_TCA9538.h", "last_update_at": "2018-07-16T23:04:17+00:00", "question_id": "975b78e6bb712e43333475591cfa8b98746d155a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class ClosedCube_TCA9538 {\npublic:\n\tClosedCube_TCA9538();\n\tvoid begin(uint8_t address);\n\tvoid init(TCA9538_Registers regs);\n\tTCA9538_Input readInput();\n\tvoid writePolarity(TCA9538_PolarityInversion polarity);\n\t\n\tvoid writeOutput(TCA9538_Output output);\n\tTCA9538_Output readOutput();\n\tvoid writeConfig(TCA9538_Config config);\nprivate:\n\tuint8_t writeData(TCA9538_Commands cmd, uint8_t rawData);\n\tuint8_t _address;\n"]], "pred": {"ppl": 2.627817153930664, "ppl_lower": 2.976736545562744, "ppl/lowercase_ppl": -1.129041665302248, "ppl/zlib": 0.004391606918508858, "Min_5.0% Prob": 7.364997016059028, "Min_10.0% Prob": 6.115495774481031, "Min_20.0% Prob": 4.094811097995655, "Min_30.0% Prob": 3.0431968452675, "Min_40.0% Prob": 2.370053886969884, "Min_50.0% Prob": 1.9223576071573065, "Min_60.0% Prob": 1.6193624195044063}}
{"hexsha": "2f44617c4687e7c91e628440ca23b94a7610af92", "ext": "c", "lang": "C", "content": "int16_t st_ulaw2linear16(\r\n\tunsigned char\tu_val)\r\n{\r\n\tint16_t\t\tt;\r\n\r\n\t/* Complement to obtain normal u-law value. */\r\n\tu_val = ~u_val;\r\n\r\n\t/*\r\n\t * Extract and bias the quantization bits. Then\r\n\t * shift up by the segment number and subtract out the bias.\r\n\t */\r\n\tt = ((u_val & QUANT_MASK) << 3) + BIAS;\r\n\tt <<= ((unsigned)u_val & SEG_MASK) >> SEG_SHIFT;\r\n\r\n\treturn ((u_val & SIGN_BIT) ? (BIAS - t) : (t - BIAS));\r\n}", "item_id": 4, "repo": "PFigs/portfolio", "file": "Integrated Services Networks (C)/source/g711.c", "last_update_at": "2018-09-07T09:27:18+00:00", "question_id": "2f44617c4687e7c91e628440ca23b94a7610af92_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int16_t st_ulaw2linear16(\r\n\tunsigned char\tu_val)\r\n{\r\n\tint16_t\t\tt;\r\n\r\n\t/* Complement to obtain normal u-law value. */\r\n\tu_val = ~u_val;\r\n\r\n\t/*\r\n\t * Extract and bias the quantization bits. Then\r\n\t * shift up by the segment number and subtract out the bias.\r\n\t */\r\n\tt = ((u_val & QUANT_MASK) << 3) + BIAS;\r\n\tt <<= ((unsigned)u_val & SEG_MASK) >> SEG_SHIFT;\r\n\r\n\treturn ((u_val & SIGN_BIT) ? (BIAS - t) : (t - BIAS));\r\n"]], "pred": {"ppl": 2.2169337272644043, "ppl_lower": 2.729740858078003, "ppl/lowercase_ppl": -1.2613680439347794, "ppl/zlib": 0.002773954833476831, "Min_5.0% Prob": 6.3305840492248535, "Min_10.0% Prob": 4.905088437928094, "Min_20.0% Prob": 3.2850738312747025, "Min_30.0% Prob": 2.4891787854107945, "Min_40.0% Prob": 1.949018119960218, "Min_50.0% Prob": 1.580734637075214, "Min_60.0% Prob": 1.3312032223754637}}
{"hexsha": "23256ddc014602ea2e0ee0fa1cecfde1bbe33704", "ext": "c", "lang": "C", "content": "void cdbdisp_clearCdbPgResults(CdbPgResults* cdb_pgresults)\n{\n\tint i = 0;\n\n\tif (!cdb_pgresults)\n\t\treturn;\n\n\tfor (i = 0; i < cdb_pgresults->numResults; i++)\n\t\tPQclear(cdb_pgresults->pg_results[i]);\n\n\tcdb_pgresults->numResults = 0;\n}", "item_id": 19, "repo": "hellomokey/gp", "file": "src/backend/cdb/dispatcher/cdbdispatchresult.c", "last_update_at": "2018-11-26T07:09:44+00:00", "question_id": "23256ddc014602ea2e0ee0fa1cecfde1bbe33704_19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void cdbdisp_clearCdbPgResults(CdbPgResults* cdb_pgresults)\n{\n\tint i = 0;\n\tif (!cdb_pgresults)\n\t\treturn;\n\tfor (i = 0; i < cdb_pgresults->numResults; i++)\n\t\tPQclear(cdb_pgresults->pg_results[i]);\n\tcdb_pgresults->numResults = 0;\n"]], "pred": {"ppl": 2.4311511516571045, "ppl_lower": 2.506133794784546, "ppl/lowercase_ppl": -1.0341935793568753, "ppl/zlib": 0.006730036895015025, "Min_5.0% Prob": 8.069872935612997, "Min_10.0% Prob": 6.14204728603363, "Min_20.0% Prob": 3.9039670576651893, "Min_30.0% Prob": 2.8649726857741675, "Min_40.0% Prob": 2.200295528396964, "Min_50.0% Prob": 1.7707316301142175, "Min_60.0% Prob": 1.4790951153780851}}
{"hexsha": "72ff10a4de7baffd8adb3a0195cad67ba439e179", "ext": "h", "lang": "C", "content": "double operator[](size_t i) const\r\n    {\r\n        assert(i < 3);\r\n        double* res = (double*)&m_v;\r\n        return res[i];\r\n    }", "item_id": 0, "repo": "dentoyan/e3vector", "file": "e3vector.h", "last_update_at": "2018-12-11T09:42:46+00:00", "question_id": "72ff10a4de7baffd8adb3a0195cad67ba439e179_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["double operator[](size_t i) const\r\n    {\r\n        assert(i < 3);\r\n        double* res = (double*)&m_v;\r\n        return res[i];\r\n"]], "pred": {"ppl": 4.075026512145996, "ppl_lower": 4.075026512145996, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.01404877252719759, "Min_5.0% Prob": 9.800718307495117, "Min_10.0% Prob": 7.894345998764038, "Min_20.0% Prob": 5.59225606918335, "Min_30.0% Prob": 4.223670303821564, "Min_40.0% Prob": 3.4093713415296456, "Min_50.0% Prob": 2.769699805726608, "Min_60.0% Prob": 2.3916539097470895}}
{"hexsha": "336b06586c00d14f8cfa7f189181d6dd35b54f08", "ext": "c", "lang": "C", "content": "int olio_socket_create(olio_socket * sock)\n{\n  sock->socket = socket(PF_INET, SOCK_STREAM|SOCK_DGRAM, 0);\n  if (sock->socket < 0)\n    return 1;\n  if (fcntl(sock->socket, F_SETFL, O_NONBLOCK) != 0)\n    return 1;\n\n  SO_KEEPALIVE\nSO_REUSEADDR\n\n}", "item_id": 0, "repo": "jabr/olio", "file": "socket.c", "last_update_at": "2018-11-25T05:53:52+00:00", "question_id": "336b06586c00d14f8cfa7f189181d6dd35b54f08_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int olio_socket_create(olio_socket * sock)\n{\n  sock->socket = socket(PF_INET, SOCK_STREAM|SOCK_DGRAM, 0);\n  if (sock->socket < 0)\n    return 1;\n  if (fcntl(sock->socket, F_SETFL, O_NONBLOCK) != 0)\n    return 1;\n  SO_KEEPALIVE\nSO_REUSEADDR\n"]], "pred": {"ppl": 3.0316083431243896, "ppl_lower": 4.066173076629639, "ppl/lowercase_ppl": -1.2647288556064642, "ppl/zlib": 0.006681284849428433, "Min_5.0% Prob": 8.35631529490153, "Min_10.0% Prob": 6.817209680875142, "Min_20.0% Prob": 4.826050817966461, "Min_30.0% Prob": 3.521959528326988, "Min_40.0% Prob": 2.7361772023141384, "Min_50.0% Prob": 2.2076329284658036, "Min_60.0% Prob": 1.8453642838738031}}
{"hexsha": "05594430cb378d518d4a0bd550f3c5613d57fad0", "ext": "c", "lang": "C", "content": "static void*\nbuild_hpet(void)\n{\n    struct acpi_20_hpet *hpet = malloc_high(sizeof(*hpet));\n    if (!hpet) {\n        warn_noalloc();\n        return NULL;\n    }\n\n    memset(hpet, 0, sizeof(*hpet));\n    /* Note timer_block_id value must be kept in sync with value advertised by\n     * emulated hpet\n     */\n    hpet->timer_block_id = cpu_to_le32(0x8086a201);\n    hpet->addr.address = cpu_to_le32(ACPI_HPET_ADDRESS);\n    build_header((void*)hpet, HPET_SIGNATURE, sizeof(*hpet), 1);\n\n    return hpet;\n}", "item_id": 4, "repo": "silverneko/HWs", "file": "qemu-shack-ibtc/roms/seabios/src/acpi.c", "last_update_at": "2018-05-15T00:12:19+00:00", "question_id": "05594430cb378d518d4a0bd550f3c5613d57fad0_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void*\nbuild_hpet(void)\n{\n    struct acpi_20_hpet *hpet = malloc_high(sizeof(*hpet));\n    if (!hpet) {\n        warn_noalloc();\n        return NULL;\n    }\n    memset(hpet, 0, sizeof(*hpet));\n    /* Note timer_block_id value must be kept in sync with value advertised by\n     * emulated hpet\n     */\n    hpet->timer_block_id = cpu_to_le32(0x8086a201);\n    hpet->addr.address = cpu_to_le32(ACPI_HPET_ADDRESS);\n    build_header((void*)hpet, HPET_SIGNATURE, sizeof(*hpet), 1);\n    return hpet;\n"]], "pred": {"ppl": 2.7985424995422363, "ppl_lower": 3.1009809970855713, "ppl/lowercase_ppl": -1.0997180948353245, "ppl/zlib": 0.003430329152591842, "Min_5.0% Prob": 7.940585374832153, "Min_10.0% Prob": 6.397517347335816, "Min_20.0% Prob": 4.414689171314239, "Min_30.0% Prob": 3.2363753875096637, "Min_40.0% Prob": 2.5274741780012846, "Min_50.0% Prob": 2.0451815814524887, "Min_60.0% Prob": 1.7118645642573636}}
{"hexsha": "33a414b4ebe05992543d49bda2717e96d4a88215", "ext": "c", "lang": "C", "content": "const char *region_file_name(int n) \n{  \n  region *r;\n  r = id_to_region(n);\n  if (r) \n    return(r->name); \n  return(NULL);\n}", "item_id": 6, "repo": "OS2World/MM-SOUND-Snd", "file": "sources/snd-region.c", "last_update_at": "2018-08-27T17:57:08+00:00", "question_id": "33a414b4ebe05992543d49bda2717e96d4a88215_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["const char *region_file_name(int n) \n{  \n  region *r;\n  r = id_to_region(n);\n  if (r) \n    return(r->name); \n  return(NULL);\n"]], "pred": {"ppl": 5.262348651885986, "ppl_lower": 5.951696872711182, "ppl/lowercase_ppl": -1.0741301946245048, "ppl/zlib": 0.01612211105687671, "Min_5.0% Prob": 9.131264209747314, "Min_10.0% Prob": 8.026085376739502, "Min_20.0% Prob": 6.088285142725164, "Min_30.0% Prob": 4.674175648128285, "Min_40.0% Prob": 3.763995859933936, "Min_50.0% Prob": 3.158384380669429, "Min_60.0% Prob": 2.7675483726403294}}
{"hexsha": "18dd4b7fb18f09455bd9953e6900c5c3159d110c", "ext": "c", "lang": "C", "content": "struct circle *new_contact_circle (struct surface *this_srf, struct torus *torus_ptr, int which_side) \n{\n\tint k;\n\tdouble signed_distance, circle_radius;\n\tdouble circle_center[3], circle_atom_vector[3], circle_axis[3];\n\tstruct circle *circle_ptr;\n\tstruct sphere *atm_ptr;\n\n\tatm_ptr = torus_ptr -> atm[which_side];\n\n\t/* computations for circle */\n\tcircle_radius =\n\t\ttorus_ptr -> radius * atm_ptr -> radius /\n\t\t(atm_ptr -> radius + this_srf -> probe_radius);\n\tfor (k = 0; k < 3; k++) {\n\t\tcircle_center[k] =\n\t\t\t(atm_ptr -> radius * torus_ptr -> center[k] +\n\t\t\tthis_srf -> probe_radius * atm_ptr -> center[k])\n\t\t\t/ (atm_ptr -> radius + this_srf -> probe_radius);\n\t\tcircle_atom_vector[k] =\n\t\t\tcircle_center[k] - atm_ptr -> center[k];\n\t\tcircle_axis[k] = (2 * which_side - 1) * torus_ptr -> axis[k];\n\t}\n\n\t/* allocate memory, setup fields */\n\tcircle_ptr = new_circle (circle_center, circle_radius, circle_axis);\n\tif (error()) return(NULL);\n\tlink_circle (this_srf, circle_ptr);\n\tcircle_ptr -> subtype = CONTACT_SUBTYPE;\n\tsigned_distance = (-dot_product (circle_axis, circle_atom_vector));\n\tcircle_ptr -> theta = atan2 (signed_distance, circle_radius);\n\tcircle_ptr -> atm = atm_ptr;\n\ttorus_ptr -> cir[which_side] = circle_ptr;\n\treturn (circle_ptr);\n}", "item_id": 7, "repo": "mlconnolly1951/biohedron", "file": "msp/src/msface.c", "last_update_at": "2018-02-13T20:32:12+00:00", "question_id": "18dd4b7fb18f09455bd9953e6900c5c3159d110c_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct circle *new_contact_circle (struct surface *this_srf, struct torus *torus_ptr, int which_side) \n{\n\tint k;\n\tdouble signed_distance, circle_radius;\n\tdouble circle_center[3], circle_atom_vector[3], circle_axis[3];\n\tstruct circle *circle_ptr;\n\tstruct sphere *atm_ptr;\n\tatm_ptr = torus_ptr -> atm[which_side];\n\t/* computations for circle */\n\tcircle_radius =\n\t\ttorus_ptr -> radius * atm_ptr -> radius /\n\t\t(atm_ptr -> radius + this_srf -> probe_radius);\n\tfor (k = 0; k < 3; k++) {\n\t\tcircle_center[k] =\n\t\t\t(atm_ptr -> radius * torus_ptr -> center[k] +\n\t\t\tthis_srf -> probe_radius * atm_ptr -> center[k])\n\t\t\t/ (atm_ptr -> radius + this_srf -> probe_radius);\n\t\tcircle_atom_vector[k] =\n\t\t\tcircle_center[k] - atm_ptr -> center[k];\n\t\tcircle_axis[k] = (2 * which_side - 1) * torus_ptr -> axis[k];\n\t}\n\t/* allocate memory, setup fields */\n\tcircle_ptr = new_circle (circle_center, circle_radius, circle_axis);\n\tif (error()) return(NULL);\n\tlink_circle (this_srf, circle_ptr);\n\tcircle_ptr -> subtype = CONTACT_SUBTYPE;\n\tsigned_distance = (-dot_product (circle_axis, circle_atom_vector));\n\tcircle_ptr -> theta = atan2 (signed_distance, circle_radius);\n\tcircle_ptr -> atm = atm_ptr;\n\ttorus_ptr -> cir[which_side] = circle_ptr;\n\treturn (circle_ptr);\n"]], "pred": {"ppl": 2.368873119354248, "ppl_lower": 2.4235801696777344, "ppl/lowercase_ppl": -1.0264739222804906, "ppl/zlib": 0.0017818478615831761, "Min_5.0% Prob": 7.487449467182159, "Min_10.0% Prob": 5.657960643370946, "Min_20.0% Prob": 3.735475136588017, "Min_30.0% Prob": 2.74002956557605, "Min_40.0% Prob": 2.1344794136627265, "Min_50.0% Prob": 1.718122861351957, "Min_60.0% Prob": 1.4365264406157046}}
{"hexsha": "e5fb162a96cef8750c1185fe9b8bef4303bc4e60", "ext": "c", "lang": "C", "content": "static void gpsculpt_brush_apply(bContext *C, wmOperator *op, PointerRNA *itemptr)\n{\n\ttGP_BrushEditData *gso = op->customdata;\n\tconst int radius = gso->brush->size;\n\tfloat mousef[2];\n\tint mouse[2];\n\tbool changed = false;\n\t\n\t/* Get latest mouse coordinates */\n\tRNA_float_get_array(itemptr, \"mouse\", mousef);\n\tgso->mval[0] = mouse[0] = (int)(mousef[0]);\n\tgso->mval[1] = mouse[1] = (int)(mousef[1]);\n\t\n\tgso->pressure = RNA_float_get(itemptr, \"pressure\");\n\t\n\tif (RNA_boolean_get(itemptr, \"pen_flip\"))\n\t\tgso->flag |= GP_EDITBRUSH_FLAG_INVERT;\n\telse\n\t\tgso->flag &= ~GP_EDITBRUSH_FLAG_INVERT;\n\t\n\t\n\t/* Store coordinates as reference, if operator just started running */\n\tif (gso->first) {\n\t\tgso->mval_prev[0]  = gso->mval[0];\n\t\tgso->mval_prev[1]  = gso->mval[1];\n\t\tgso->pressure_prev = gso->pressure;\n\t}\n\t\n\t/* Update brush_rect, so that it represents the bounding rectangle of brush */\n\tgso->brush_rect.xmin = mouse[0] - radius;\n\tgso->brush_rect.ymin = mouse[1] - radius;\n\tgso->brush_rect.xmax = mouse[0] + radius;\n\tgso->brush_rect.ymax = mouse[1] + radius;\n\t\n\t\n\t/* Apply brush */\n\tif (gso->brush_type == GP_EDITBRUSH_TYPE_CLONE) {\n\t\tchanged = gpsculpt_brush_apply_clone(C, gso);\n\t}\n\telse {\n\t\tchanged = gpsculpt_brush_apply_standard(C, gso);\n\t}\n\t\n\t\n\t/* Updates */\n\tif (changed) {\n\t\tWM_event_add_notifier(C, NC_GPENCIL | ND_DATA | NA_EDITED, NULL);\n\t}\n\t\n\t/* Store values for next step */\n\tgso->mval_prev[0]  = gso->mval[0];\n\tgso->mval_prev[1]  = gso->mval[1];\n\tgso->pressure_prev = gso->pressure;\n\tgso->first = false;\n}", "item_id": 25, "repo": "1-MillionParanoidTterabytes/Blender-2.79b-blackened", "file": "source/blender/editors/gpencil/gpencil_brush.c", "last_update_at": "2018-06-18T01:50:32+00:00", "question_id": "e5fb162a96cef8750c1185fe9b8bef4303bc4e60_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void gpsculpt_brush_apply(bContext *C, wmOperator *op, PointerRNA *itemptr)\n{\n\ttGP_BrushEditData *gso = op->customdata;\n\tconst int radius = gso->brush->size;\n\tfloat mousef[2];\n\tint mouse[2];\n\tbool changed = false;\n\t\n\t/* Get latest mouse coordinates */\n\tRNA_float_get_array(itemptr, \"mouse\", mousef);\n\tgso->mval[0] = mouse[0] = (int)(mousef[0]);\n\tgso->mval[1] = mouse[1] = (int)(mousef[1]);\n\t\n\tgso->pressure = RNA_float_get(itemptr, \"pressure\");\n\t\n\tif (RNA_boolean_get(itemptr, \"pen_flip\"))\n\t\tgso->flag |= GP_EDITBRUSH_FLAG_INVERT;\n\telse\n\t\tgso->flag &= ~GP_EDITBRUSH_FLAG_INVERT;\n\t\n\t\n\t/* Store coordinates as reference, if operator just started running */\n\tif (gso->first) {\n\t\tgso->mval_prev[0]  = gso->mval[0];\n\t\tgso->mval_prev[1]  = gso->mval[1];\n\t\tgso->pressure_prev = gso->pressure;\n\t}\n\t\n\t/* Update brush_rect, so that it represents the bounding rectangle of brush */\n\tgso->brush_rect.xmin = mouse[0] - radius;\n\tgso->brush_rect.ymin = mouse[1] - radius;\n\tgso->brush_rect.xmax = mouse[0] + radius;\n\tgso->brush_rect.ymax = mouse[1] + radius;\n\t\n\t\n\t/* Apply brush */\n\tif (gso->brush_type == GP_EDITBRUSH_TYPE_CLONE) {\n\t\tchanged = gpsculpt_brush_apply_clone(C, gso);\n\t}\n\telse {\n\t\tchanged = gpsculpt_brush_apply_standard(C, gso);\n\t}\n\t\n\t\n\t/* Updates */\n\tif (changed) {\n\t\tWM_event_add_notifier(C, NC_GPENCIL | ND_DATA | NA_EDITED, NULL);\n\t}\n\t\n\t/* Store values for next step */\n\tgso->mval_prev[0]  = gso->mval[0];\n\tgso->mval_prev[1]  = gso->mval[1];\n\tgso->pressure_prev = gso->pressure;\n\tgso->first = false;\n"]], "pred": {"ppl": 1.9045826196670532, "ppl_lower": 2.3472535610198975, "ppl/lowercase_ppl": -1.3243754437773931, "ppl/zlib": 0.0009806132226570943, "Min_5.0% Prob": 6.322838979608872, "Min_10.0% Prob": 4.738485792103936, "Min_20.0% Prob": 2.9955960442038143, "Min_30.0% Prob": 2.1085304227091517, "Min_40.0% Prob": 1.6035626754164696, "Min_50.0% Prob": 1.2868156229036258, "Min_60.0% Prob": 1.0733824519608306}}
{"hexsha": "b9fcc45f3d2a0823d7decc621b4c7b1479b58f84", "ext": "c", "lang": "C", "content": "static  errval_t timer_remaining__lmp_send(struct timer_binding *_binding, struct event_closure _continuation, uint64_t time)\n{\n    // check that we can accept an outgoing message\n    if ((_binding->tx_msgnum) != 0) {\n        return(FLOUNDER_ERR_TX_BUSY);\n    }\n    \n    // register send continuation\n    if ((_continuation.handler) != NULL) {\n        errval_t _err;\n        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);\n        // may fail if previous continuation hasn't fired yet\n        if (err_is_fail(_err)) {\n            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {\n                return(FLOUNDER_ERR_TX_BUSY);\n            } else {\n                assert(!(\"shouldn't happen\"));\n                return(_err);\n            }\n        }\n    }\n    \n    // store message number and arguments\n    _binding->tx_msgnum = timer_remaining__msgnum;\n    _binding->tx_msg_fragment = 0;\n    ((_binding->tx_union).remaining).time = time;\n    FL_DEBUG(\"lmp TX timer.remaining\\n\");\n    \n    // try to send!\n    timer_remaining__lmp_send_handler(_binding);\n    \n    return(SYS_ERR_OK);\n}", "item_id": 12, "repo": "daleoooo/barrelfish", "file": "build/x86_64/lib/timer/_for_lib_timer/timer_flounder_bindings.c", "last_update_at": "2018-03-30T08:02:50+00:00", "question_id": "b9fcc45f3d2a0823d7decc621b4c7b1479b58f84_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static  errval_t timer_remaining__lmp_send(struct timer_binding *_binding, struct event_closure _continuation, uint64_t time)\n{\n    // check that we can accept an outgoing message\n    if ((_binding->tx_msgnum) != 0) {\n        return(FLOUNDER_ERR_TX_BUSY);\n    }\n    // register send continuation\n    if ((_continuation.handler) != NULL) {\n        errval_t _err;\n        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);\n        // may fail if previous continuation hasn't fired yet\n        if (err_is_fail(_err)) {\n            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {\n                return(FLOUNDER_ERR_TX_BUSY);\n            } else {\n                assert(!(\"shouldn't happen\"));\n                return(_err);\n            }\n        }\n    }\n    // store message number and arguments\n    _binding->tx_msgnum = timer_remaining__msgnum;\n    _binding->tx_msg_fragment = 0;\n    ((_binding->tx_union).remaining).time = time;\n    FL_DEBUG(\"lmp TX timer.remaining\\n\");\n    // try to send!\n    timer_remaining__lmp_send_handler(_binding);\n    return(SYS_ERR_OK);\n"]], "pred": {"ppl": 2.536163330078125, "ppl_lower": 3.0562524795532227, "ppl/lowercase_ppl": -1.2004368533323004, "ppl/zlib": 0.001752641128259945, "Min_5.0% Prob": 7.778673860761854, "Min_10.0% Prob": 5.877190132398863, "Min_20.0% Prob": 4.031287406285604, "Min_30.0% Prob": 2.967299812662918, "Min_40.0% Prob": 2.291598863751683, "Min_50.0% Prob": 1.8533861261235658, "Min_60.0% Prob": 1.5546152826101907}}
{"hexsha": "201f7c63ea5c12a2abaa53263ade88d3a2624fe5", "ext": "c", "lang": "C", "content": "static int\ndmsg_relay_scan_cmp(h2span_relay_t *relay, void *arg)\n{\n\tstruct relay_scan_info *info = arg;\n\n\tif ((intptr_t)relay->source_rt->any.link->node < (intptr_t)info->node)\n\t\treturn(-1);\n\tif ((intptr_t)relay->source_rt->any.link->node > (intptr_t)info->node)\n\t\treturn(1);\n\treturn(0);\n}", "item_id": 8, "repo": "cooljeanius/DragonFlyBSD", "file": "lib/libdmsg/msg_lnk.c", "last_update_at": "2018-01-12T03:55:33+00:00", "question_id": "201f7c63ea5c12a2abaa53263ade88d3a2624fe5_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\ndmsg_relay_scan_cmp(h2span_relay_t *relay, void *arg)\n{\n\tstruct relay_scan_info *info = arg;\n\tif ((intptr_t)relay->source_rt->any.link->node < (intptr_t)info->node)\n\t\treturn(-1);\n\tif ((intptr_t)relay->source_rt->any.link->node > (intptr_t)info->node)\n\t\treturn(1);\n\treturn(0);\n"]], "pred": {"ppl": 3.505326509475708, "ppl_lower": 3.505326509475708, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.007938504249939455, "Min_5.0% Prob": 8.30899953842163, "Min_10.0% Prob": 7.290785422691932, "Min_20.0% Prob": 5.3128837530429545, "Min_30.0% Prob": 4.007919890758319, "Min_40.0% Prob": 3.112268141255929, "Min_50.0% Prob": 2.5199147081145874, "Min_60.0% Prob": 2.105444578286738}}
{"hexsha": "fa037a9c89ffeefd5c1454547a59f7e6e7f9128b", "ext": "c", "lang": "C", "content": "void BUTTONS_init()\n{\n    BUTTON_OUTPORT |= (1 << LEFT_BUTTON_BIT); // pull up LEFT_BUTTON_IO\n    BUTTON_DDRPORT &= ~(1 << LEFT_BUTTON_BIT); // configure LEFT_BUTTON_IO as input\n\n    BUTTON_OUTPORT |= (1 << RIGHT_BUTTON_BIT); // pull up the RIGHT_BUTTON_IO\n    BUTTON_DDRPORT &= ~(1 << RIGHT_BUTTON_BIT); // configure RIGHT_BUTTON_IO as input\n}", "item_id": 1, "repo": "Deni90/tRexRunnerNano", "file": "firmware/tRexRunner.c", "last_update_at": "2018-08-17T06:48:01+00:00", "question_id": "fa037a9c89ffeefd5c1454547a59f7e6e7f9128b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void BUTTONS_init()\n{\n    BUTTON_OUTPORT |= (1 << LEFT_BUTTON_BIT); // pull up LEFT_BUTTON_IO\n    BUTTON_DDRPORT &= ~(1 << LEFT_BUTTON_BIT); // configure LEFT_BUTTON_IO as input\n    BUTTON_OUTPORT |= (1 << RIGHT_BUTTON_BIT); // pull up the RIGHT_BUTTON_IO\n    BUTTON_DDRPORT &= ~(1 << RIGHT_BUTTON_BIT); // configure RIGHT_BUTTON_IO as input\n"]], "pred": {"ppl": 2.2834205627441406, "ppl_lower": 3.1967129707336426, "ppl/lowercase_ppl": -1.4074832067458742, "ppl/zlib": 0.005855847982538926, "Min_5.0% Prob": 8.242868832179479, "Min_10.0% Prob": 6.431447474161784, "Min_20.0% Prob": 4.003562863795988, "Min_30.0% Prob": 2.769216297471777, "Min_40.0% Prob": 2.078456319365946, "Min_50.0% Prob": 1.6604751684125276, "Min_60.0% Prob": 1.3815830257451651}}
{"hexsha": "5c25d22e8ffeb31c8ebe19e811b61c8c4eeb5fa1", "ext": "c", "lang": "C", "content": "void test_udict_const_str(udict_backend_t backend)\n{\n    udict_t *d = udict_create_with_backend(backend);\n    udict_put(d, G_CSTR(\"k1\"), G_CSTR(\"v1\"));\n    udict_put(d, G_CSTR(\"k2\"), G_CSTR(\"v2\"));\n    udict_put(d, G_CSTR(\"k3\"), G_CSTR(\"v3\"));\n\n    UASSERT_STR_EQ(G_AS_STR(udict_get(d, G_CSTR(\"k1\"), G_CSTR(\"\"))), \"v1\");\n    UASSERT_STR_EQ(G_AS_STR(udict_get(d, G_CSTR(\"k2\"), G_CSTR(\"\"))), \"v2\");\n    UASSERT_STR_EQ(G_AS_STR(udict_get(d, G_CSTR(\"k3\"), G_CSTR(\"\"))), \"v3\");\n\n    udict_clear(d);\n    udict_destroy(d);\n}", "item_id": 1, "repo": "YauheniKaratsevich/ugeneric", "file": "test_dict.c", "last_update_at": "2018-10-29T10:08:50+00:00", "question_id": "5c25d22e8ffeb31c8ebe19e811b61c8c4eeb5fa1_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void test_udict_const_str(udict_backend_t backend)\n{\n    udict_t *d = udict_create_with_backend(backend);\n    udict_put(d, G_CSTR(\"k1\"), G_CSTR(\"v1\"));\n    udict_put(d, G_CSTR(\"k2\"), G_CSTR(\"v2\"));\n    udict_put(d, G_CSTR(\"k3\"), G_CSTR(\"v3\"));\n    UASSERT_STR_EQ(G_AS_STR(udict_get(d, G_CSTR(\"k1\"), G_CSTR(\"\"))), \"v1\");\n    UASSERT_STR_EQ(G_AS_STR(udict_get(d, G_CSTR(\"k2\"), G_CSTR(\"\"))), \"v2\");\n    UASSERT_STR_EQ(G_AS_STR(udict_get(d, G_CSTR(\"k3\"), G_CSTR(\"\"))), \"v3\");\n    udict_clear(d);\n    udict_destroy(d);\n"]], "pred": {"ppl": 1.770378589630127, "ppl_lower": 1.7512975931167603, "ppl/lowercase_ppl": -0.9810284556873446, "ppl/zlib": 0.0030221873870921122, "Min_5.0% Prob": 7.209707810328557, "Min_10.0% Prob": 4.7502531959460335, "Min_20.0% Prob": 2.7787632861962686, "Min_30.0% Prob": 1.9092332045428264, "Min_40.0% Prob": 1.426664472264903, "Min_50.0% Prob": 1.1457312722789934, "Min_60.0% Prob": 0.9566136803085008}}
{"hexsha": "f6a0693d54ba910af58c43c633f4acfb62ca837f", "ext": "c", "lang": "C", "content": "struct hedvtx *getVertex (struct hedron *hed, long number) {\n\tstruct hedvtx *vtx = NULL;\n\tlong idx = 0;\n\tidx = number - 1;\n\tif (idx < 0) return (NULL);\n\tif (idx >= hed -> maxvtx) return (NULL);\n\tvtx = *(hed -> vertices + idx);\n\treturn (vtx);\n}", "item_id": 41, "repo": "mlconnolly1951/biohedron", "file": "msp/src/mshedron.c", "last_update_at": "2018-02-13T20:32:12+00:00", "question_id": "f6a0693d54ba910af58c43c633f4acfb62ca837f_41", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct hedvtx *getVertex (struct hedron *hed, long number) {\n\tstruct hedvtx *vtx = NULL;\n\tlong idx = 0;\n\tidx = number - 1;\n\tif (idx < 0) return (NULL);\n\tif (idx >= hed -> maxvtx) return (NULL);\n\tvtx = *(hed -> vertices + idx);\n\treturn (vtx);\n"]], "pred": {"ppl": 3.471052408218384, "ppl_lower": 3.5646727085113525, "ppl/lowercase_ppl": -1.0213863470282678, "ppl/zlib": 0.008133711344100413, "Min_5.0% Prob": 7.51042366027832, "Min_10.0% Prob": 6.417395210266113, "Min_20.0% Prob": 4.949935621023178, "Min_30.0% Prob": 3.765850718816121, "Min_40.0% Prob": 3.0038767635822294, "Min_50.0% Prob": 2.4351353890755596, "Min_60.0% Prob": 2.0611190715285597}}
{"hexsha": "1c51b61ac37e952dd39b79b3b25537a4efea7b9c", "ext": "h", "lang": "C", "content": "class RenderTangents\n{\npublic:\n  RenderTangents(Logger logger, App* app);\n  ~RenderTangents();\n\n  void init();\n\n  void update(Vector<Mesh*>& meshes);\n\n  void draw(VkCommandBuffer cmdBuf, RenderPassHandle pass, const Vec4f& viewport, const Mat3f& N, const Mat4f& MVP);\n\nprivate:\n  Logger logger;\n  App* app = nullptr;\n\n  struct MeshData\n  {\n    Mesh* src = nullptr;\n    uint32_t geometryGeneration = 0;\n    RenderBufferHandle vtx;\n    RenderBufferHandle tan;\n    RenderBufferHandle bnm;\n    uint32_t triangleCount = 0;\n  };\n  Vector<MeshData> meshData;\n  Vector<MeshData> newMeshData;\n  RenderBufferHandle coordSysVtxCol;\n  ShaderHandle vertexShader;\n  ShaderHandle fragmentShader;\n  PipelineHandle pipeline;\n  uint32_t viewport[4];\n\n  void buildPipelines(RenderPassHandle pass);\n}", "item_id": 0, "repo": "cdyk/meshtool", "file": "app/RenderTangents.h", "last_update_at": "2018-12-21T16:04:47+00:00", "question_id": "1c51b61ac37e952dd39b79b3b25537a4efea7b9c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class RenderTangents\n{\npublic:\n  RenderTangents(Logger logger, App* app);\n  ~RenderTangents();\n  void init();\n  void update(Vector<Mesh*>& meshes);\n  void draw(VkCommandBuffer cmdBuf, RenderPassHandle pass, const Vec4f& viewport, const Mat3f& N, const Mat4f& MVP);\nprivate:\n  Logger logger;\n  App* app = nullptr;\n  struct MeshData\n  {\n    Mesh* src = nullptr;\n    uint32_t geometryGeneration = 0;\n    RenderBufferHandle vtx;\n    RenderBufferHandle tan;\n    RenderBufferHandle bnm;\n    uint32_t triangleCount = 0;\n  };\n  Vector<MeshData> meshData;\n  Vector<MeshData> newMeshData;\n  RenderBufferHandle coordSysVtxCol;\n  ShaderHandle vertexShader;\n  ShaderHandle fragmentShader;\n  PipelineHandle pipeline;\n  uint32_t viewport[4];\n  void buildPipelines(RenderPassHandle pass);\n"]], "pred": {"ppl": 3.3305158615112305, "ppl_lower": 3.991536855697632, "ppl/lowercase_ppl": -1.1504821164701087, "ppl/zlib": 0.0032605073316023087, "Min_5.0% Prob": 8.258327704209547, "Min_10.0% Prob": 6.533427167821814, "Min_20.0% Prob": 4.648193264007569, "Min_30.0% Prob": 3.5759634317421334, "Min_40.0% Prob": 2.871894294565374, "Min_50.0% Prob": 2.380241937010828, "Min_60.0% Prob": 1.996956377792539}}
{"hexsha": "c38eef505d75b7a5eb8727c5e4c4a786682398d8", "ext": "c", "lang": "C", "content": "int ss_aes_128_cbc(char *encrypt, char *out_data, char *key)\n{\n    unsigned char iv[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\n#if defined(USE_CRYPTO_OPENSSL)\n    AES_KEY aes;\n    AES_set_encrypt_key((unsigned char*)key, 128, &aes);\n    AES_cbc_encrypt((const unsigned char *)encrypt, (unsigned char *)out_data, 16, &aes, iv, AES_ENCRYPT);\n\n#elif defined(USE_CRYPTO_MBEDTLS)\n    mbedtls_aes_context aes;\n\n    unsigned char output[16];\n\n    mbedtls_aes_setkey_enc( &aes, (unsigned char *)key, 128 );\n    mbedtls_aes_crypt_cbc( &aes, MBEDTLS_AES_ENCRYPT, 16, iv, (unsigned char *)encrypt, output );\n\n    memcpy(out_data, output, 16);\n#else\n\n    aes_context aes;\n\n    unsigned char output[16];\n\n    aes_setkey_enc( &aes, (unsigned char *)key, 128 );\n    aes_crypt_cbc( &aes, AES_ENCRYPT, 16, iv, (unsigned char *)encrypt, output );\n\n    memcpy(out_data, output, 16);\n#endif\n\n    return 0;\n}", "item_id": 20, "repo": "icodesign/Potatso-ssr_obfs", "file": "c/encrypt.c", "last_update_at": "2018-04-10T09:07:58+00:00", "question_id": "c38eef505d75b7a5eb8727c5e4c4a786682398d8_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int ss_aes_128_cbc(char *encrypt, char *out_data, char *key)\n{\n    unsigned char iv[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n#if defined(USE_CRYPTO_OPENSSL)\n    AES_KEY aes;\n    AES_set_encrypt_key((unsigned char*)key, 128, &aes);\n    AES_cbc_encrypt((const unsigned char *)encrypt, (unsigned char *)out_data, 16, &aes, iv, AES_ENCRYPT);\n#elif defined(USE_CRYPTO_MBEDTLS)\n    mbedtls_aes_context aes;\n    unsigned char output[16];\n    mbedtls_aes_setkey_enc( &aes, (unsigned char *)key, 128 );\n    mbedtls_aes_crypt_cbc( &aes, MBEDTLS_AES_ENCRYPT, 16, iv, (unsigned char *)encrypt, output );\n    memcpy(out_data, output, 16);\n#else\n    aes_context aes;\n    unsigned char output[16];\n    aes_setkey_enc( &aes, (unsigned char *)key, 128 );\n    aes_crypt_cbc( &aes, AES_ENCRYPT, 16, iv, (unsigned char *)encrypt, output );\n    memcpy(out_data, output, 16);\n#endif\n    return 0;\n"]], "pred": {"ppl": 1.4756019115447998, "ppl_lower": 1.6695590019226074, "ppl/lowercase_ppl": -1.3174102705799342, "ppl/zlib": 0.0011789878247732233, "Min_5.0% Prob": 4.587267035529727, "Min_10.0% Prob": 3.170265853404999, "Min_20.0% Prob": 1.8633854234919829, "Min_30.0% Prob": 1.2805619651917368, "Min_40.0% Prob": 0.9730095860822235, "Min_50.0% Prob": 0.7787408851428141, "Min_60.0% Prob": 0.648589628262016}}
{"hexsha": "fa4036a6385d29ce156de559c4829e71ef49a055", "ext": "h", "lang": "C", "content": "static uint32_t\nblockmix_xor(const salsa20_blk_t *restrict Bin1,\n    const salsa20_blk_t *restrict Bin2, salsa20_blk_t *restrict Bout,\n    size_t r, int Bin2_in_ROM, const __m128i *restrict S)\n{\n\tconst uint8_t * S0, * S1;\n\t__m128i X0, X1, X2, X3;\n\tsize_t i;\n\n\tif (!S)\n\t\treturn blockmix_salsa8_xor(Bin1, Bin2, Bout, r, Bin2_in_ROM);\n\n\tS0 = (const uint8_t *)S;\n\tS1 = (const uint8_t *)S + S_SIZE_ALL / 2;\n\n\t/* Convert 128-byte blocks to 64-byte blocks */\n\tr *= 2;\n\n\tr--;\n\tif (Bin2_in_ROM) {\n\t\tPREFETCH(&Bin2[r], _MM_HINT_NTA)\n\t\tPREFETCH(&Bin1[r], _MM_HINT_T0)\n\t\tfor (i = 0; i < r; i++) {\n\t\t\tPREFETCH(&Bin2[i], _MM_HINT_NTA)\n\t\t\tPREFETCH(&Bin1[i], _MM_HINT_T0)\n\t\t\tPREFETCH_OUT(&Bout[i], _MM_HINT_T0)\n\t\t}\n\t} else {\n\t\tPREFETCH(&Bin2[r], _MM_HINT_T0)\n\t\tPREFETCH(&Bin1[r], _MM_HINT_T0)\n\t\tfor (i = 0; i < r; i++) {\n\t\t\tPREFETCH(&Bin2[i], _MM_HINT_T0)\n\t\t\tPREFETCH(&Bin1[i], _MM_HINT_T0)\n\t\t\tPREFETCH_OUT(&Bout[i], _MM_HINT_T0)\n\t\t}\n\t}\n\tPREFETCH_OUT(&Bout[r], _MM_HINT_T0);\n\n\t/* X <-- B_{r1 - 1} */\n\tXOR4_2(Bin1[r].q, Bin2[r].q)\n\n\t/* for i = 0 to r1 - 1 do */\n\tfor (i = 0; i < r; i++) {\n\t\t/* X <-- H'(X \\xor B_i) */\n\t\tXOR4(Bin1[i].q)\n\t\tXOR4(Bin2[i].q)\n\t\tPWXFORM\n\t\t/* B'_i <-- X */\n\t\tOUT(Bout[i].q)\n\t}\n\n\t/* Last iteration of the loop above */\n\tXOR4(Bin1[i].q)\n\tXOR4(Bin2[i].q)\n\tPWXFORM\n\n\t/* B'_i <-- H(B'_i) */\n\tSALSA20_8(Bout[i].q)\n\n\treturn _mm_cvtsi128_si32(X0);\n}", "item_id": 3, "repo": "okoto-xyz/jagaricoinR", "file": "src/crypto/yescrypt/yescrypt-simd_c.h", "last_update_at": "2018-05-18T13:10:02+00:00", "question_id": "fa4036a6385d29ce156de559c4829e71ef49a055_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static uint32_t\nblockmix_xor(const salsa20_blk_t *restrict Bin1,\n    const salsa20_blk_t *restrict Bin2, salsa20_blk_t *restrict Bout,\n    size_t r, int Bin2_in_ROM, const __m128i *restrict S)\n{\n\tconst uint8_t * S0, * S1;\n\t__m128i X0, X1, X2, X3;\n\tsize_t i;\n\tif (!S)\n\t\treturn blockmix_salsa8_xor(Bin1, Bin2, Bout, r, Bin2_in_ROM);\n\tS0 = (const uint8_t *)S;\n\tS1 = (const uint8_t *)S + S_SIZE_ALL / 2;\n\t/* Convert 128-byte blocks to 64-byte blocks */\n\tr *= 2;\n\tr--;\n\tif (Bin2_in_ROM) {\n\t\tPREFETCH(&Bin2[r], _MM_HINT_NTA)\n\t\tPREFETCH(&Bin1[r], _MM_HINT_T0)\n\t\tfor (i = 0; i < r; i++) {\n\t\t\tPREFETCH(&Bin2[i], _MM_HINT_NTA)\n\t\t\tPREFETCH(&Bin1[i], _MM_HINT_T0)\n\t\t\tPREFETCH_OUT(&Bout[i], _MM_HINT_T0)\n\t\t}\n\t} else {\n\t\tPREFETCH(&Bin2[r], _MM_HINT_T0)\n\t\tPREFETCH(&Bin1[r], _MM_HINT_T0)\n\t\tfor (i = 0; i < r; i++) {\n\t\t\tPREFETCH(&Bin2[i], _MM_HINT_T0)\n\t\t\tPREFETCH(&Bin1[i], _MM_HINT_T0)\n\t\t\tPREFETCH_OUT(&Bout[i], _MM_HINT_T0)\n\t\t}\n\t}\n\tPREFETCH_OUT(&Bout[r], _MM_HINT_T0);\n\t/* X <-- B_{r1 - 1} */\n\tXOR4_2(Bin1[r].q, Bin2[r].q)\n\t/* for i = 0 to r1 - 1 do */\n\tfor (i = 0; i < r; i++) {\n\t\t/* X <-- H'(X \\xor B_i) */\n\t\tXOR4(Bin1[i].q)\n\t\tXOR4(Bin2[i].q)\n\t\tPWXFORM\n\t\t/* B'_i <-- X */\n\t\tOUT(Bout[i].q)\n\t}\n\t/* Last iteration of the loop above */\n\tXOR4(Bin1[i].q)\n\tXOR4(Bin2[i].q)\n\tPWXFORM\n\t/* B'_i <-- H(B'_i) */\n\tSALSA20_8(Bout[i].q)\n\treturn _mm_cvtsi128_si32(X0);\n"]], "pred": {"ppl": 1.926329493522644, "ppl_lower": 2.0376696586608887, "ppl/lowercase_ppl": -1.0857063024886713, "ppl/zlib": 0.001220887104914994, "Min_5.0% Prob": 6.817557904778457, "Min_10.0% Prob": 4.860923078001999, "Min_20.0% Prob": 3.0107654719641714, "Min_30.0% Prob": 2.1298759470303215, "Min_40.0% Prob": 1.628475924965107, "Min_50.0% Prob": 1.3090352477465212, "Min_60.0% Prob": 1.0922835390552907}}
{"hexsha": "08a6211832b6c677948136e74c7fea4f3653fe93", "ext": "h", "lang": "C", "content": "class YOCTO_CLASS_EXPORT YDelayedPulse {\npublic:\n    int             target;\n    int             ms;\n    int             moving;\n\n    YDelayedPulse()\n        :target(YAPI_INVALID_INT), ms(YAPI_INVALID_INT), moving(YAPI_INVALID_UINT)\n    {}\n\n    bool operator==(const YDelayedPulse& o) const {\n         return (target == o.target) && (ms == o.ms) && (moving == o.moving);\n    }\n}", "item_id": 0, "repo": "amstrudy/yoctopuce-altimeter", "file": "include/yocto/yocto_api/yocto_relay.h", "last_update_at": "2018-02-20T17:39:20+00:00", "question_id": "08a6211832b6c677948136e74c7fea4f3653fe93_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class YOCTO_CLASS_EXPORT YDelayedPulse {\npublic:\n    int             target;\n    int             ms;\n    int             moving;\n    YDelayedPulse()\n        :target(YAPI_INVALID_INT), ms(YAPI_INVALID_INT), moving(YAPI_INVALID_UINT)\n    {}\n    bool operator==(const YDelayedPulse& o) const {\n         return (target == o.target) && (ms == o.ms) && (moving == o.moving);\n    }\n"]], "pred": {"ppl": 3.50801682472229, "ppl_lower": 4.505521774291992, "ppl/lowercase_ppl": -1.1993965669193076, "ppl/zlib": 0.00618251660393808, "Min_5.0% Prob": 9.373388687769571, "Min_10.0% Prob": 7.68235995219304, "Min_20.0% Prob": 5.387190659840901, "Min_30.0% Prob": 3.9753042101860045, "Min_40.0% Prob": 3.0860314269860587, "Min_50.0% Prob": 2.51650347638486, "Min_60.0% Prob": 2.0888133322889053}}
{"hexsha": "a3dafbc05a1183cbfa9af243baa2f6526800d173", "ext": "c", "lang": "C", "content": "int usecSleep(unsigned int dt_us)\n{\n    static struct timespec s;\n    if (dt_us > 0)\n    {\n        s.tv_sec = (dt_us/1000000);\n        s.tv_nsec = (dt_us % 1000000)*1000L;\n        while(nanosleep(&s,&s)==-1 && errno == EINTR)\n        continue;\n    }\n    else {\n        return sleep(0);\n    }\n    return 0;\n}", "item_id": 3, "repo": "adalinbv/aax-utils", "file": "base/timer.c", "last_update_at": "2018-12-10T19:10:20+00:00", "question_id": "a3dafbc05a1183cbfa9af243baa2f6526800d173_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int usecSleep(unsigned int dt_us)\n{\n    static struct timespec s;\n    if (dt_us > 0)\n    {\n        s.tv_sec = (dt_us/1000000);\n        s.tv_nsec = (dt_us % 1000000)*1000L;\n        while(nanosleep(&s,&s)==-1 && errno == EINTR)\n        continue;\n    }\n    else {\n        return sleep(0);\n    }\n    return 0;\n"]], "pred": {"ppl": 2.383953094482422, "ppl_lower": 2.8035953044891357, "ppl/lowercase_ppl": -1.1866367502686888, "ppl/zlib": 0.0046707530853566295, "Min_5.0% Prob": 7.1440690358479815, "Min_10.0% Prob": 5.33181093289302, "Min_20.0% Prob": 3.5979964998033314, "Min_30.0% Prob": 2.748605233866994, "Min_40.0% Prob": 2.148811865936626, "Min_50.0% Prob": 1.7382550122945204, "Min_60.0% Prob": 1.4516711052372513}}
{"hexsha": "72ae298cf875649244dec08a618d9e0852ff6a94", "ext": "c", "lang": "C", "content": "static void rxm_handle_sar_comp(struct rxm_ep *rxm_ep,\n\t\t\t\tstruct rxm_tx_buf *tx_buf)\n{\n\tvoid *app_context;\n\tuint64_t comp_flags, tx_flags;\n\n\tapp_context = tx_buf->app_context;\n\tcomp_flags = ofi_tx_cq_flags(tx_buf->pkt.hdr.op);\n\ttx_flags = tx_buf->flags;\n\n\tif (!rxm_complete_sar(rxm_ep, tx_buf))\n\t\treturn;\n\n\trxm_cq_write_tx_comp(rxm_ep, comp_flags, app_context, tx_flags);\n\tofi_ep_tx_cntr_inc(&rxm_ep->util_ep);\n}", "item_id": 9, "repo": "kamleshbhalui/chapel", "file": "third-party/libfabric/libfabric-src/prov/rxm/src/rxm_cq.c", "last_update_at": "2018-01-31T17:05:32+00:00", "question_id": "72ae298cf875649244dec08a618d9e0852ff6a94_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void rxm_handle_sar_comp(struct rxm_ep *rxm_ep,\n\t\t\t\tstruct rxm_tx_buf *tx_buf)\n{\n\tvoid *app_context;\n\tuint64_t comp_flags, tx_flags;\n\tapp_context = tx_buf->app_context;\n\tcomp_flags = ofi_tx_cq_flags(tx_buf->pkt.hdr.op);\n\ttx_flags = tx_buf->flags;\n\tif (!rxm_complete_sar(rxm_ep, tx_buf))\n\t\treturn;\n\trxm_cq_write_tx_comp(rxm_ep, comp_flags, app_context, tx_flags);\n\tofi_ep_tx_cntr_inc(&rxm_ep->util_ep);\n"]], "pred": {"ppl": 2.45463228225708, "ppl_lower": 2.45463228225708, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.003991008741480839, "Min_5.0% Prob": 6.441474962234497, "Min_10.0% Prob": 5.453102219104767, "Min_20.0% Prob": 3.7839196687791405, "Min_30.0% Prob": 2.8382810508051226, "Min_40.0% Prob": 2.2317317949562536, "Min_50.0% Prob": 1.7980126208689027, "Min_60.0% Prob": 1.497775899764571}}
{"hexsha": "9a4a5bb386bdf3d9377a72f7c3a1ebdc21df3387", "ext": "c", "lang": "C", "content": "native_handle_t* native_handle_create(int numFds, int numInts)\n{\n    native_handle_t* h = malloc(\n            sizeof(native_handle_t) + sizeof(int)*(numFds+numInts));\n\n    if (h) {\n        h->version = sizeof(native_handle_t);\n        h->numFds = numFds;\n        h->numInts = numInts;\n    }\n    return h;\n}", "item_id": 0, "repo": "nicknaym530/android_system_core", "file": "libcutils/native_handle.c", "last_update_at": "2018-11-23T04:37:11+00:00", "question_id": "9a4a5bb386bdf3d9377a72f7c3a1ebdc21df3387_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["native_handle_t* native_handle_create(int numFds, int numInts)\n{\n    native_handle_t* h = malloc(\n            sizeof(native_handle_t) + sizeof(int)*(numFds+numInts));\n    if (h) {\n        h->version = sizeof(native_handle_t);\n        h->numFds = numFds;\n        h->numInts = numInts;\n    }\n    return h;\n"]], "pred": {"ppl": 1.9911017417907715, "ppl_lower": 2.113729476928711, "ppl/lowercase_ppl": -1.0867820790029843, "ppl/zlib": 0.004443149191133307, "Min_5.0% Prob": 6.736619186401367, "Min_10.0% Prob": 4.644879016009244, "Min_20.0% Prob": 3.0078243561412976, "Min_30.0% Prob": 2.251424426541609, "Min_40.0% Prob": 1.717851949126824, "Min_50.0% Prob": 1.3731504622525696, "Min_60.0% Prob": 1.1567259343017056}}
{"hexsha": "10c519fae7b4655a4b159bf6f43e87d0583e98dc", "ext": "h", "lang": "C", "content": "static int remoteDispatchStorageVolLookupByKey(\n    virNetServerPtr server ATTRIBUTE_UNUSED,\n    virNetServerClientPtr client,\n    virNetMessagePtr msg ATTRIBUTE_UNUSED,\n    virNetMessageErrorPtr rerr,\n    remote_storage_vol_lookup_by_key_args *args,\n    remote_storage_vol_lookup_by_key_ret *ret)\n{\n    int rv = -1;\n    virStorageVolPtr vol = NULL;\n    struct daemonClientPrivate *priv =\n        virNetServerClientGetPrivateData(client);\n\n    if (!priv->conn) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"connection not open\"));\n        goto cleanup;\n    }\n\n    if ((vol = virStorageVolLookupByKey(priv->conn, args->key)) == NULL)\n        goto cleanup;\n\n    make_nonnull_storage_vol(&ret->vol, vol);\n    rv = 0;\n\ncleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    virObjectUnref(vol);\n    return rv;\n}", "item_id": 227, "repo": "SIIS-cloud/pileus", "file": "libvirt/pileus-libvirt-1.2.12/daemon/remote_dispatch.h", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "10c519fae7b4655a4b159bf6f43e87d0583e98dc_227", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int remoteDispatchStorageVolLookupByKey(\n    virNetServerPtr server ATTRIBUTE_UNUSED,\n    virNetServerClientPtr client,\n    virNetMessagePtr msg ATTRIBUTE_UNUSED,\n    virNetMessageErrorPtr rerr,\n    remote_storage_vol_lookup_by_key_args *args,\n    remote_storage_vol_lookup_by_key_ret *ret)\n{\n    int rv = -1;\n    virStorageVolPtr vol = NULL;\n    struct daemonClientPrivate *priv =\n        virNetServerClientGetPrivateData(client);\n    if (!priv->conn) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"connection not open\"));\n        goto cleanup;\n    }\n    if ((vol = virStorageVolLookupByKey(priv->conn, args->key)) == NULL)\n        goto cleanup;\n    make_nonnull_storage_vol(&ret->vol, vol);\n    rv = 0;\ncleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    virObjectUnref(vol);\n    return rv;\n"]], "pred": {"ppl": 1.7171598672866821, "ppl_lower": 3.3047776222229004, "ppl/lowercase_ppl": -2.2108965876438225, "ppl/zlib": 0.001302823339943273, "Min_5.0% Prob": 6.082155295780727, "Min_10.0% Prob": 4.053799259251561, "Min_20.0% Prob": 2.4997709547651223, "Min_30.0% Prob": 1.7638731756429562, "Min_40.0% Prob": 1.348773156260622, "Min_50.0% Prob": 1.0835341281867747, "Min_60.0% Prob": 0.9039110553413415}}
{"hexsha": "9ee39c8d1010cda660950bc599d23b0060a97ea2", "ext": "c", "lang": "C", "content": "static int parse_mntr_flags(int *_argc, char ***_argv,\n\t\t\t    struct nl_msg *msg)\n{\n\tstruct nl_msg *flags;\n\tint err = -ENOBUFS;\n\tenum nl80211_mntr_flags flag;\n\tint argc = *_argc;\n\tchar **argv = *_argv;\n\n\tflags = nlmsg_alloc();\n\tif (!flags)\n\t\treturn -ENOMEM;\n\n\twhile (argc) {\n\t\tint ok = 0;\n\t\tfor (flag = __NL80211_MNTR_FLAG_INVALID;\n\t\t     flag <= NL80211_MNTR_FLAG_MAX; flag++) {\n\t\t\tif (strcmp(*argv, mntr_flags[flag]) == 0) {\n\t\t\t\tok = 1;\n\t\t\t\t/*\n\t\t\t\t * This shouldn't be adding \"flag\" if that is\n\t\t\t\t * zero, but due to a problem in the kernel's\n\t\t\t\t * nl80211 code (using NLA_NESTED policy) it\n\t\t\t\t * will reject an empty nested attribute but\n\t\t\t\t * not one that contains an invalid attribute\n\t\t\t\t */\n\t\t\t\tNLA_PUT_FLAG(flags, flag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ok) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\targc--;\n\t\targv++;\n\t}\n\n\tnla_put_nested(msg, NL80211_ATTR_MNTR_FLAGS, flags);\n\terr = 0;\n nla_put_failure:\n out:\n\tnlmsg_free(flags);\n\n\t*_argc = argc;\n\t*_argv = argv;\n\n\treturn err;\n}", "item_id": 0, "repo": "gromaudio/android_external_iw", "file": "interface.c", "last_update_at": "2018-02-01T12:28:41+00:00", "question_id": "9ee39c8d1010cda660950bc599d23b0060a97ea2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int parse_mntr_flags(int *_argc, char ***_argv,\n\t\t\t    struct nl_msg *msg)\n{\n\tstruct nl_msg *flags;\n\tint err = -ENOBUFS;\n\tenum nl80211_mntr_flags flag;\n\tint argc = *_argc;\n\tchar **argv = *_argv;\n\tflags = nlmsg_alloc();\n\tif (!flags)\n\t\treturn -ENOMEM;\n\twhile (argc) {\n\t\tint ok = 0;\n\t\tfor (flag = __NL80211_MNTR_FLAG_INVALID;\n\t\t     flag <= NL80211_MNTR_FLAG_MAX; flag++) {\n\t\t\tif (strcmp(*argv, mntr_flags[flag]) == 0) {\n\t\t\t\tok = 1;\n\t\t\t\t/*\n\t\t\t\t * This shouldn't be adding \"flag\" if that is\n\t\t\t\t * zero, but due to a problem in the kernel's\n\t\t\t\t * nl80211 code (using NLA_NESTED policy) it\n\t\t\t\t * will reject an empty nested attribute but\n\t\t\t\t * not one that contains an invalid attribute\n\t\t\t\t */\n\t\t\t\tNLA_PUT_FLAG(flags, flag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ok) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\targc--;\n\t\targv++;\n\t}\n\tnla_put_nested(msg, NL80211_ATTR_MNTR_FLAGS, flags);\n\terr = 0;\n nla_put_failure:\n out:\n\tnlmsg_free(flags);\n\t*_argc = argc;\n\t*_argv = argv;\n\treturn err;\n"]], "pred": {"ppl": 1.9275106191635132, "ppl_lower": 2.21807861328125, "ppl/lowercase_ppl": -1.213967874094057, "ppl/zlib": 0.0011931442467887688, "Min_5.0% Prob": 6.205727477868398, "Min_10.0% Prob": 4.696825097004573, "Min_20.0% Prob": 3.0407620557804695, "Min_30.0% Prob": 2.166792204976082, "Min_40.0% Prob": 1.637500427980168, "Min_50.0% Prob": 1.3147583618088556, "Min_60.0% Prob": 1.093628954241145}}
{"hexsha": "635b52a51aefb39eca2232d7510d9b1808c37b25", "ext": "c", "lang": "C", "content": "static int lua_estop_display(lua_State *L){\n  int row = luaL_optnumber(L, 1,1);\n  const char * text= luaL_checkstring (L, 2);\n\n  estop_display(row,text);\n  return 1;\n}", "item_id": 4, "repo": "ToyotaResearchInstitute/rad-robot", "file": "Modules-old/estop/lua_estop.c", "last_update_at": "2018-09-22T10:31:27+00:00", "question_id": "635b52a51aefb39eca2232d7510d9b1808c37b25_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int lua_estop_display(lua_State *L){\n  int row = luaL_optnumber(L, 1,1);\n  const char * text= luaL_checkstring (L, 2);\n  estop_display(row,text);\n  return 1;\n"]], "pred": {"ppl": 3.915869951248169, "ppl_lower": 5.951371669769287, "ppl/lowercase_ppl": -1.3066466721544294, "ppl/zlib": 0.01042013369868305, "Min_5.0% Prob": 9.123273849487305, "Min_10.0% Prob": 7.246177400861468, "Min_20.0% Prob": 5.434790475027902, "Min_30.0% Prob": 4.133456772023981, "Min_40.0% Prob": 3.349632133697641, "Min_50.0% Prob": 2.690207936473795, "Min_60.0% Prob": 2.2819288328967313}}
{"hexsha": "38a035809c1e923864c05d95e9fa6f60df89ea89", "ext": "c", "lang": "C", "content": "static void destroyDepsInfo(const vdexDeps_010 *pVdexDeps) {\n  for (u4 i = 0; i < pVdexDeps->numberOfDexFiles; ++i) {\n    free((void *)pVdexDeps->pVdexDepData[i].extraStrings.strings);\n    free((void *)pVdexDeps->pVdexDepData[i].assignTypeSets.pVdexDepSets);\n    free((void *)pVdexDeps->pVdexDepData[i].unassignTypeSets.pVdexDepSets);\n    free((void *)pVdexDeps->pVdexDepData[i].classes.pVdexDepClasses);\n    free((void *)pVdexDeps->pVdexDepData[i].fields.pVdexDepFields);\n    free((void *)pVdexDeps->pVdexDepData[i].methods.pVdexDepMethods);\n    free((void *)pVdexDeps->pVdexDepData[i].unvfyClasses.pVdexDepUnvfyClasses);\n  }\n  free((void *)pVdexDeps->pVdexDepData);\n  free((void *)pVdexDeps);\n}", "item_id": 9, "repo": "yan20160909/vdexExtractor", "file": "src/vdex/vdex_backend_010.c", "last_update_at": "2018-07-13T05:56:21+00:00", "question_id": "38a035809c1e923864c05d95e9fa6f60df89ea89_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void destroyDepsInfo(const vdexDeps_010 *pVdexDeps) {\n  for (u4 i = 0; i < pVdexDeps->numberOfDexFiles; ++i) {\n    free((void *)pVdexDeps->pVdexDepData[i].extraStrings.strings);\n    free((void *)pVdexDeps->pVdexDepData[i].assignTypeSets.pVdexDepSets);\n    free((void *)pVdexDeps->pVdexDepData[i].unassignTypeSets.pVdexDepSets);\n    free((void *)pVdexDeps->pVdexDepData[i].classes.pVdexDepClasses);\n    free((void *)pVdexDeps->pVdexDepData[i].fields.pVdexDepFields);\n    free((void *)pVdexDeps->pVdexDepData[i].methods.pVdexDepMethods);\n    free((void *)pVdexDeps->pVdexDepData[i].unvfyClasses.pVdexDepUnvfyClasses);\n  }\n  free((void *)pVdexDeps->pVdexDepData);\n  free((void *)pVdexDeps);\n"]], "pred": {"ppl": 1.9393192529678345, "ppl_lower": 2.104870080947876, "ppl/lowercase_ppl": -1.123678329378943, "ppl/zlib": 0.002879726134622587, "Min_5.0% Prob": 7.251798936298916, "Min_10.0% Prob": 5.31428310788911, "Min_20.0% Prob": 3.216153673196243, "Min_30.0% Prob": 2.201002982643883, "Min_40.0% Prob": 1.6557515136146246, "Min_50.0% Prob": 1.3240260227111438, "Min_60.0% Prob": 1.1086698091344311}}
{"hexsha": "9d5918d47e841c22f3323e5b03abf87278e87845", "ext": "c", "lang": "C", "content": "static int lastIndexOf( const char *p_string, char p_search, int start_point )\r\n{\r\n\tint loop;\r\n    for ( loop = start_point-1; loop >= 0; -- loop )\r\n\t{\r\n\t\tif ( p_string[loop] == p_search )\r\n\t\t{\r\n\t\t\treturn loop;\r\n\t\t}\r\n\t}\r\n    return -1;\r\n}", "item_id": 1, "repo": "NDGuthrie/bposs", "file": "src/libTRANS/pt_trans.c", "last_update_at": "2018-01-24T16:28:01+00:00", "question_id": "9d5918d47e841c22f3323e5b03abf87278e87845_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int lastIndexOf( const char *p_string, char p_search, int start_point )\r\n{\r\n\tint loop;\r\n    for ( loop = start_point-1; loop >= 0; -- loop )\r\n\t{\r\n\t\tif ( p_string[loop] == p_search )\r\n\t\t{\r\n\t\t\treturn loop;\r\n\t\t}\r\n\t}\r\n    return -1;\r\n"]], "pred": {"ppl": 2.856595277786255, "ppl_lower": 2.917151689529419, "ppl/lowercase_ppl": -1.019985355803956, "ppl/zlib": 0.006601449392176899, "Min_5.0% Prob": 6.974758863449097, "Min_10.0% Prob": 5.688393857744005, "Min_20.0% Prob": 4.2449401428824975, "Min_30.0% Prob": 3.225812846216662, "Min_40.0% Prob": 2.5414260236116557, "Min_50.0% Prob": 2.0725296792023036, "Min_60.0% Prob": 1.7645180425767242}}
{"hexsha": "66dc99495ba4a8aa3f108e866fea970eed5ffa82", "ext": "c", "lang": "C", "content": "ssize_t\nvirStorageFileReadHeader(virStorageSourcePtr src,\n                         ssize_t max_len,\n                         char **buf)\n{\n    ssize_t ret;\n\n    if (!virStorageFileIsInitialized(src)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"storage file backend not initialized\"));\n        return -1;\n    }\n\n    if (!src->drv->backend->storageFileReadHeader) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"storage file header reading is not supported for \"\n                         \"storage type %s (protocol: %s)\"),\n                       virStorageTypeToString(src->type),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        return -2;\n    }\n\n    ret = src->drv->backend->storageFileReadHeader(src, max_len, buf);\n\n    VIR_DEBUG(\"read of storage header %p: ret=%zd\", src, ret);\n\n    return ret;\n}", "item_id": 60, "repo": "SIIS-cloud/pileus", "file": "libvirt/pileus-libvirt-1.2.12/src/storage/storage_driver.c", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "66dc99495ba4a8aa3f108e866fea970eed5ffa82_60", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ssize_t\nvirStorageFileReadHeader(virStorageSourcePtr src,\n                         ssize_t max_len,\n                         char **buf)\n{\n    ssize_t ret;\n    if (!virStorageFileIsInitialized(src)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"storage file backend not initialized\"));\n        return -1;\n    }\n    if (!src->drv->backend->storageFileReadHeader) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"storage file header reading is not supported for \"\n                         \"storage type %s (protocol: %s)\"),\n                       virStorageTypeToString(src->type),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        return -2;\n    }\n    ret = src->drv->backend->storageFileReadHeader(src, max_len, buf);\n    VIR_DEBUG(\"read of storage header %p: ret=%zd\", src, ret);\n    return ret;\n"]], "pred": {"ppl": 2.3246212005615234, "ppl_lower": 3.5024983882904053, "ppl/lowercase_ppl": -1.4859415410919594, "ppl/zlib": 0.002362905045591081, "Min_5.0% Prob": 7.6788261731465655, "Min_10.0% Prob": 5.6633475875854495, "Min_20.0% Prob": 3.6867846110287834, "Min_30.0% Prob": 2.726975618224395, "Min_40.0% Prob": 2.09381013991786, "Min_50.0% Prob": 1.691003088010695, "Min_60.0% Prob": 1.405428905183072}}
{"hexsha": "855240960056a1c3cc5995c6838084d84c5d33a8", "ext": "c", "lang": "C", "content": "int BGBCC_SHXC_EmitCompareVRegVRegVRegQLong(\n\tBGBCC_TransState *ctx,\n\tBGBCC_SHX_Context *sctx,\n\tccxl_type type, ccxl_register dreg, int cmp,\n\tccxl_register sreg, ccxl_register treg)\n{\n\tint csreg, ctreg, cdreg;\n\ts32 imm;\n\tint nm1, nm2, cmp1;\n\tint i;\n\t\n\tswitch(cmp)\n\t{\n\tcase CCXL_CMP_EQ:\n\t\tnm1=BGBCC_SH_NMID_CMPEQ;\n\t\tnm2=BGBCC_SH_NMID_BT;\n\t\tbreak;\n\tcase CCXL_CMP_NE:\n\t\tnm1=BGBCC_SH_NMID_CMPEQ;\n\t\tnm2=BGBCC_SH_NMID_BF;\n\t\tbreak;\n\tcase CCXL_CMP_LT:\n\t\tnm1=BGBCC_SH_NMID_CMPGE;\n\t\tnm2=BGBCC_SH_NMID_BF;\n\t\tbreak;\n\tcase CCXL_CMP_GT:\n\t\tnm1=BGBCC_SH_NMID_CMPGT;\n\t\tnm2=BGBCC_SH_NMID_BT;\n\t\tbreak;\n\tcase CCXL_CMP_LE:\n\t\tnm1=BGBCC_SH_NMID_CMPGT;\n\t\tnm2=BGBCC_SH_NMID_BF;\n\t\tbreak;\n\tcase CCXL_CMP_GE:\n\t\tnm1=BGBCC_SH_NMID_CMPGE;\n\t\tnm2=BGBCC_SH_NMID_BT;\n\t\tbreak;\n\tdefault:\n\t\tnm1=-1;\n\t\tnm2=-1;\n\t\tbreak;\n\t}\n\t\n\tif((nm1>=0) && (nm2>=0))\n\t{\n\t\tcsreg=BGBCC_SHXC_EmitGetRegisterRead(ctx, sctx, sreg);\n\t\tctreg=BGBCC_SHXC_EmitGetRegisterRead(ctx, sctx, treg);\n\t\tcdreg=BGBCC_SHXC_EmitGetRegisterWrite(ctx, sctx, dreg);\n\n\t\tBGBCC_SHXC_CheckSetModeDqSet(ctx, sctx);\n\n\t\tBGBCC_SHXC_EmitOpRegReg(ctx, sctx, nm1, ctreg, csreg);\n\t\tBGBCC_SHXC_EmitOpReg(ctx, sctx, BGBCC_SH_NMID_MOVT, cdreg);\n\t\t\n\t\tif(nm2==BGBCC_SH_NMID_BF)\n\t\t{\n\t\t\tBGBCC_SHXC_EmitOpRegReg(ctx, sctx, BGBCC_SH_NMID_NEG, cdreg, cdreg);\n\t\t\tBGBCC_SHXC_EmitOpRegImm(ctx, sctx, BGBCC_SH_NMID_ADD, cdreg, 1);\n\t\t}\n\t\t\n//\t\tBGBCC_SHX_EmitOpLabel(sctx, nm2, lbl);\n\n\t\tBGBCC_SHXC_EmitReleaseRegister(ctx, sctx, sreg);\n\t\tBGBCC_SHXC_EmitReleaseRegister(ctx, sctx, treg);\n\t\tBGBCC_SHXC_EmitReleaseRegister(ctx, sctx, dreg);\n\t\treturn(1);\n\t}\n\n\tBGBCC_CCXL_StubError(ctx);\n\treturn(0);\n}", "item_id": 3, "repo": "cr88192/bgbtech_shxemu", "file": "sh2emu/bgbcc22/shcc/shx_lqarith.c", "last_update_at": "2018-04-12T20:42:03+00:00", "question_id": "855240960056a1c3cc5995c6838084d84c5d33a8_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int BGBCC_SHXC_EmitCompareVRegVRegVRegQLong(\n\tBGBCC_TransState *ctx,\n\tBGBCC_SHX_Context *sctx,\n\tccxl_type type, ccxl_register dreg, int cmp,\n\tccxl_register sreg, ccxl_register treg)\n{\n\tint csreg, ctreg, cdreg;\n\ts32 imm;\n\tint nm1, nm2, cmp1;\n\tint i;\n\t\n\tswitch(cmp)\n\t{\n\tcase CCXL_CMP_EQ:\n\t\tnm1=BGBCC_SH_NMID_CMPEQ;\n\t\tnm2=BGBCC_SH_NMID_BT;\n\t\tbreak;\n\tcase CCXL_CMP_NE:\n\t\tnm1=BGBCC_SH_NMID_CMPEQ;\n\t\tnm2=BGBCC_SH_NMID_BF;\n\t\tbreak;\n\tcase CCXL_CMP_LT:\n\t\tnm1=BGBCC_SH_NMID_CMPGE;\n\t\tnm2=BGBCC_SH_NMID_BF;\n\t\tbreak;\n\tcase CCXL_CMP_GT:\n\t\tnm1=BGBCC_SH_NMID_CMPGT;\n\t\tnm2=BGBCC_SH_NMID_BT;\n\t\tbreak;\n\tcase CCXL_CMP_LE:\n\t\tnm1=BGBCC_SH_NMID_CMPGT;\n\t\tnm2=BGBCC_SH_NMID_BF;\n\t\tbreak;\n\tcase CCXL_CMP_GE:\n\t\tnm1=BGBCC_SH_NMID_CMPGE;\n\t\tnm2=BGBCC_SH_NMID_BT;\n\t\tbreak;\n\tdefault:\n\t\tnm1=-1;\n\t\tnm2=-1;\n\t\tbreak;\n\t}\n\t\n\tif((nm1>=0) && (nm2>=0))\n\t{\n\t\tcsreg=BGBCC_SHXC_EmitGetRegisterRead(ctx, sctx, sreg);\n\t\tctreg=BGBCC_SHXC_EmitGetRegisterRead(ctx, sctx, treg);\n\t\tcdreg=BGBCC_SHXC_EmitGetRegisterWrite(ctx, sctx, dreg);\n\t\tBGBCC_SHXC_CheckSetModeDqSet(ctx, sctx);\n\t\tBGBCC_SHXC_EmitOpRegReg(ctx, sctx, nm1, ctreg, csreg);\n\t\tBGBCC_SHXC_EmitOpReg(ctx, sctx, BGBCC_SH_NMID_MOVT, cdreg);\n\t\t\n\t\tif(nm2==BGBCC_SH_NMID_BF)\n\t\t{\n\t\t\tBGBCC_SHXC_EmitOpRegReg(ctx, sctx, BGBCC_SH_NMID_NEG, cdreg, cdreg);\n\t\t\tBGBCC_SHXC_EmitOpRegImm(ctx, sctx, BGBCC_SH_NMID_ADD, cdreg, 1);\n\t\t}\n\t\t\n//\t\tBGBCC_SHX_EmitOpLabel(sctx, nm2, lbl);\n\t\tBGBCC_SHXC_EmitReleaseRegister(ctx, sctx, sreg);\n\t\tBGBCC_SHXC_EmitReleaseRegister(ctx, sctx, treg);\n\t\tBGBCC_SHXC_EmitReleaseRegister(ctx, sctx, dreg);\n\t\treturn(1);\n\t}\n\tBGBCC_CCXL_StubError(ctx);\n\treturn(0);\n"]], "pred": {"ppl": 1.1884948015213013, "ppl_lower": 1.5870712995529175, "ppl/lowercase_ppl": -2.6747159455319625, "ppl/zlib": 0.0003453752676512542, "Min_5.0% Prob": 2.824785729672046, "Min_10.0% Prob": 1.6337159466236195, "Min_20.0% Prob": 0.8577672699811282, "Min_30.0% Prob": 0.5760355821472894, "Min_40.0% Prob": 0.4322403448905383, "Min_50.0% Prob": 0.3457083033366418, "Min_60.0% Prob": 0.2880093482262213}}
{"hexsha": "f7b44a0ee40879b665b2e27418bba86e01140acc", "ext": "c", "lang": "C", "content": "int libxl__enum_from_string(const libxl_enum_string_table *t,\n                            const char *s, int *e)\n{\n    if (!t) return ERROR_INVAL;\n\n    for( ; t->s; t++) {\n        if (!strcasecmp(t->s, s)) {\n                *e = t->v;\n                return 0;\n        }\n    }\n    return ERROR_FAIL;\n}", "item_id": 23, "repo": "zhiming-shen/Xen-Blanket-NG", "file": "xen/xen-4.2.2/tools/libxl/libxl_utils.c", "last_update_at": "2018-02-02T00:15:26+00:00", "question_id": "f7b44a0ee40879b665b2e27418bba86e01140acc_23", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int libxl__enum_from_string(const libxl_enum_string_table *t,\n                            const char *s, int *e)\n{\n    if (!t) return ERROR_INVAL;\n    for( ; t->s; t++) {\n        if (!strcasecmp(t->s, s)) {\n                *e = t->v;\n                return 0;\n        }\n    }\n    return ERROR_FAIL;\n"]], "pred": {"ppl": 2.9372317790985107, "ppl_lower": 3.3309760093688965, "ppl/lowercase_ppl": -1.1167532043276704, "ppl/zlib": 0.0061569575203329965, "Min_5.0% Prob": 7.884799289703369, "Min_10.0% Prob": 6.5292001247406, "Min_20.0% Prob": 4.649244325501578, "Min_30.0% Prob": 3.390944294631481, "Min_40.0% Prob": 2.6868124377159845, "Min_50.0% Prob": 2.1626675062162697, "Min_60.0% Prob": 1.7973019304336049}}
{"hexsha": "e9c675999b8322c312bdbe7bfa3b3bcd2d0b6130", "ext": "c", "lang": "C", "content": "static int\ngattm_att_get_permission_req_handler(kernel_msg_id_t const msgid, struct gattm_att_get_permission_req *param,\n        kernel_task_id_t const dest_id, kernel_task_id_t const src_id)\n{\n    struct attm_elmt elmt = ATT_ELEMT_INIT;\n    struct gattm_att_get_permission_rsp *get_att_perm_rsp =\n    KERNEL_MSG_ALLOC(GATTM_ATT_GET_PERMISSION_RSP, src_id, dest_id, gattm_att_get_permission_rsp);\n\n    /* Retrieve attribute permissions */\n    get_att_perm_rsp->status = attmdb_att_get_permission(param->handle, &(get_att_perm_rsp->perm), PERM_MASK_ALL, 0, &elmt);\n    get_att_perm_rsp->ext_perm  = (elmt.info.att->info.max_length & PERM_MASK_EKS);\n\n    /* update handle */\n    get_att_perm_rsp->handle = param->handle;\n\n    /* send command response message. */\n    kernel_msg_send(get_att_perm_rsp);\n\n    /* message is consumed */\n    return (KERNEL_MSG_CONSUMED);\n}", "item_id": 4, "repo": "ruoranluomu/AliOS-Things", "file": "platform/mcu/bk7231u/beken/driver/ble/ble_lib/ip/ble/hl/src/gatt/gattm/gattm_task.c", "last_update_at": "2018-11-28T03:19:22+00:00", "question_id": "e9c675999b8322c312bdbe7bfa3b3bcd2d0b6130_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\ngattm_att_get_permission_req_handler(kernel_msg_id_t const msgid, struct gattm_att_get_permission_req *param,\n        kernel_task_id_t const dest_id, kernel_task_id_t const src_id)\n{\n    struct attm_elmt elmt = ATT_ELEMT_INIT;\n    struct gattm_att_get_permission_rsp *get_att_perm_rsp =\n    KERNEL_MSG_ALLOC(GATTM_ATT_GET_PERMISSION_RSP, src_id, dest_id, gattm_att_get_permission_rsp);\n    /* Retrieve attribute permissions */\n    get_att_perm_rsp->status = attmdb_att_get_permission(param->handle, &(get_att_perm_rsp->perm), PERM_MASK_ALL, 0, &elmt);\n    get_att_perm_rsp->ext_perm  = (elmt.info.att->info.max_length & PERM_MASK_EKS);\n    /* update handle */\n    get_att_perm_rsp->handle = param->handle;\n    /* send command response message. */\n    kernel_msg_send(get_att_perm_rsp);\n    /* message is consumed */\n    return (KERNEL_MSG_CONSUMED);\n"]], "pred": {"ppl": 2.0230164527893066, "ppl_lower": 2.6078238487243652, "ppl/lowercase_ppl": -1.3603890481703185, "ppl/zlib": 0.0017747851159174391, "Min_5.0% Prob": 6.342956823461196, "Min_10.0% Prob": 4.7982203551701135, "Min_20.0% Prob": 3.248954096862248, "Min_30.0% Prob": 2.3147779801062174, "Min_40.0% Prob": 1.759616403946919, "Min_50.0% Prob": 1.4122180963999458, "Min_60.0% Prob": 1.1775177758857829}}
{"hexsha": "3115662c93eee0506e2f89c81b2686ba98005201", "ext": "c", "lang": "C", "content": "static void emit_rebox_value(lily_emit_state *emit, lily_type *new_type,\n        lily_ast *ast)\n{\n    lily_storage *storage = get_storage(emit, new_type);\n\n    /* Don't allow a bare variant to be thrown into an any until it's thrown\n       into an enum box first. */\n    if (new_type->cls->id == SYM_CLASS_ANY &&\n        ast->result->type->cls->flags & CLS_VARIANT_CLASS) {\n        rebox_variant_to_enum(emit, ast);\n    }\n\n    write_4(emit, o_assign, ast->line_num, ast->result->reg_spot,\n            storage->reg_spot);\n\n    ast->result = (lily_sym *)storage;\n}", "item_id": 24, "repo": "r-lyeh/scriptorium", "file": "lily/src/lily_emitter.c", "last_update_at": "2018-01-08T03:02:37+00:00", "question_id": "3115662c93eee0506e2f89c81b2686ba98005201_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void emit_rebox_value(lily_emit_state *emit, lily_type *new_type,\n        lily_ast *ast)\n{\n    lily_storage *storage = get_storage(emit, new_type);\n    /* Don't allow a bare variant to be thrown into an any until it's thrown\n       into an enum box first. */\n    if (new_type->cls->id == SYM_CLASS_ANY &&\n        ast->result->type->cls->flags & CLS_VARIANT_CLASS) {\n        rebox_variant_to_enum(emit, ast);\n    }\n    write_4(emit, o_assign, ast->line_num, ast->result->reg_spot,\n            storage->reg_spot);\n    ast->result = (lily_sym *)storage;\n"]], "pred": {"ppl": 4.354140281677246, "ppl_lower": 4.962590217590332, "ppl/lowercase_ppl": -1.088911853473453, "ppl/zlib": 0.004670245020089114, "Min_5.0% Prob": 8.676932096481323, "Min_10.0% Prob": 7.330755090713501, "Min_20.0% Prob": 5.3980199754238125, "Min_30.0% Prob": 4.247125180562337, "Min_40.0% Prob": 3.470366679877043, "Min_50.0% Prob": 2.8665291115198985, "Min_60.0% Prob": 2.4375900782583173}}
{"hexsha": "ca68dfe6d2116c7f479fc425f6e647ac548b866b", "ext": "h", "lang": "C", "content": "namespace brew {\n\nclass VideoContext :\n        public Object,\n        private ProxyObjectManager<Texture, TextureContextHandle>,\n        private ProxyObjectManager<FrameBuffer, FrameBufferContextHandle>,\n        private ProxyObjectManager<ShaderVariables, ShaderVariablesContextHandle>,\n        private ProxyObjectManager<VertexBuffer, VertexBufferContextHandle>,\n        private ProxyObjectManager<IndexBuffer, IndexBufferContextHandle>,\n        private ProxyObjectManager<Mesh, MeshContextHandle>,\n        private ProxyObjectManager<Shader, ShaderContextHandle>,\n        private ProxyObjectManager<ShaderProgram, ShaderProgramContextHandle>\n{\npublic:\n    /**\n     * Initializes pending context objects. Should not be called manually.\n     */\n    void processPendingOperations();\n\npublic:\n    /**\n     * Creates a new empty texture.\n     * @param width The texture width.\n     * @param height The texture height.\n     * @param color The initial color.\n     * @param format The texture format.\n     * @param filtering The texture filtering.\n     * @param numMipMaps The number of mip-maps to generate.\n     * @return The created texture.\n     */\n    std::shared_ptr<Texture> createTexture(SizeT width,\n                                           SizeT height,\n                                           Color color = Color::BLACK,\n                                           TextureFormat format = Texture::DefaultTextureFormat,\n                                           TextureFiltering filtering = Texture::DefaultTextureFiltering,\n                                           u8 numMipMaps = Texture::DefaultMipMaps\n    );\n\n    /**\n     * Creates a new texture from an existing pixmap.\n     * @param pixmap The source pixmap.\n     * @param format The texture format.\n     * @param filtering The texture filtering.\n     * @param numMipMaps The number of mip-maps to generate.\n     * @return The created texture.\n     */\n    std::shared_ptr<Texture> createTexture(std::shared_ptr<Pixmap> pixmap,\n                                           TextureFormat format = Texture::DefaultTextureFormat,\n                                           TextureFiltering filtering = Texture::DefaultTextureFiltering,\n                                           u8 numMipMaps = Texture::DefaultMipMaps\n    );\n\n    /**\n     * Creates a new texture from an existing pixmap.\n     * @param pixmap The source pixmap.\n     * @param format The texture format.\n     * @param filtering The texture filtering.\n     * @param numMipMaps The number of mip-maps to generate.\n     * @return The created texture.\n     */\n    inline std::shared_ptr<Texture> createTexture(const Pixmap& pixmap,\n                                           TextureFormat format = Texture::DefaultTextureFormat,\n                                           TextureFiltering filtering = Texture::DefaultTextureFiltering,\n                                           u8 numMipMaps = Texture::DefaultMipMaps\n    ) {\n        return createTexture(std::make_shared<Pixmap>(pixmap), format, filtering, numMipMaps);\n    }", "item_id": 0, "repo": "grrrrunz/brew", "file": "src/brew/video/VideoContext.h", "last_update_at": "2018-02-09T16:20:50+00:00", "question_id": "ca68dfe6d2116c7f479fc425f6e647ac548b866b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace brew {\nclass VideoContext :\n        public Object,\n        private ProxyObjectManager<Texture, TextureContextHandle>,\n        private ProxyObjectManager<FrameBuffer, FrameBufferContextHandle>,\n        private ProxyObjectManager<ShaderVariables, ShaderVariablesContextHandle>,\n        private ProxyObjectManager<VertexBuffer, VertexBufferContextHandle>,\n        private ProxyObjectManager<IndexBuffer, IndexBufferContextHandle>,\n        private ProxyObjectManager<Mesh, MeshContextHandle>,\n        private ProxyObjectManager<Shader, ShaderContextHandle>,\n        private ProxyObjectManager<ShaderProgram, ShaderProgramContextHandle>\n{\npublic:\n    /**\n     * Initializes pending context objects. Should not be called manually.\n     */\n    void processPendingOperations();\npublic:\n    /**\n     * Creates a new empty texture.\n     * @param width The texture width.\n     * @param height The texture height.\n     * @param color The initial color.\n     * @param format The texture format.\n     * @param filtering The texture filtering.\n     * @param numMipMaps The number of mip-maps to generate.\n     * @return The created texture.\n     */\n    std::shared_ptr<Texture> createTexture(SizeT width,\n                                           SizeT height,\n                                           Color color = Color::BLACK,\n                                           TextureFormat format = Texture::DefaultTextureFormat,\n                                           TextureFiltering filtering = Texture::DefaultTextureFiltering,\n                                           u8 numMipMaps = Texture::DefaultMipMaps\n    );\n    /**\n     * Creates a new texture from an existing pixmap.\n     * @param pixmap The source pixmap.\n     * @param format The texture format.\n     * @param filtering The texture filtering.\n     * @param numMipMaps The number of mip-maps to generate.\n     * @return The created texture.\n     */\n    std::shared_ptr<Texture> createTexture(std::shared_ptr<Pixmap> pixmap,\n                                           TextureFormat format = Texture::DefaultTextureFormat,\n                                           TextureFiltering filtering = Texture::DefaultTextureFiltering,\n                                           u8 numMipMaps = Texture::DefaultMipMaps\n    );\n    /**\n     * Creates a new texture from an existing pixmap.\n     * @param pixmap The source pixmap.\n     * @param format The texture format.\n     * @param filtering The texture filtering.\n     * @param numMipMaps The number of mip-maps to generate.\n     * @return The created texture.\n     */\n    inline std::shared_ptr<Texture> createTexture(const Pixmap& pixmap,\n                                           TextureFormat format = Texture::DefaultTextureFormat,\n                                           TextureFiltering filtering = Texture::DefaultTextureFiltering,\n                                           u8 numMipMaps = Texture::DefaultMipMaps\n    ) {\n        return createTexture(std::make_shared<Pixmap>(pixmap), format, filtering, numMipMaps);\n"]], "pred": {"ppl": 1.637635588645935, "ppl_lower": 1.6791921854019165, "ppl/lowercase_ppl": -1.0508041991976138, "ppl/zlib": 0.0008262202467770185, "Min_5.0% Prob": 6.295671515994602, "Min_10.0% Prob": 4.187335558133583, "Min_20.0% Prob": 2.399478261973582, "Min_30.0% Prob": 1.6316387478548746, "Min_40.0% Prob": 1.2336284651541385, "Min_50.0% Prob": 0.9870551688490314, "Min_60.0% Prob": 0.8222409334211248}}
{"hexsha": "8ad56a6769a020960774835f291789709f1c3840", "ext": "h", "lang": "C", "content": "class GeoLib\n{\npublic:\n\tGeoLib() {}\n\t~GeoLib() {}\nprivate:\n\tfriend class CGLPolyline;\n\tfriend class Surface;\n}", "item_id": 0, "repo": "yingtaohu/ogs5", "file": "GEO/geo_lib.h", "last_update_at": "2018-07-28T01:46:45+00:00", "question_id": "8ad56a6769a020960774835f291789709f1c3840_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class GeoLib\n{\npublic:\n\tGeoLib() {}\n\t~GeoLib() {}\nprivate:\n\tfriend class CGLPolyline;\n\tfriend class Surface;\n"]], "pred": {"ppl": 5.621914386749268, "ppl_lower": 7.703410625457764, "ppl/lowercase_ppl": -1.1824265873985378, "ppl/zlib": 0.020313791107213992, "Min_5.0% Prob": 8.27735948562622, "Min_10.0% Prob": 7.89337944984436, "Min_20.0% Prob": 6.64679487546285, "Min_30.0% Prob": 5.341193960263179, "Min_40.0% Prob": 4.210438854164547, "Min_50.0% Prob": 3.407865798343783, "Min_60.0% Prob": 2.9266279019691326}}
{"hexsha": "ced9697a9812676ec762fc4fd38d0b7764fd006e", "ext": "c", "lang": "C", "content": "SSH_PACKET_CALLBACK(channel_rcv_eof) {\n  ssh_channel channel;\n  (void)user;\n  (void)type;\n\n  channel = channel_from_msg(session,packet);\n  if (channel == NULL) {\n    SSH_LOG(SSH_LOG_FUNCTIONS, \"%s\", ssh_get_error(session));\n\n    return SSH_PACKET_USED;\n  }\n\n  SSH_LOG(SSH_LOG_PACKET,\n      \"Received eof on channel (%d:%d)\",\n      channel->local_channel,\n      channel->remote_channel);\n  /* channel->remote_window = 0; */\n  channel->remote_eof = 1;\n\n  if(ssh_callbacks_exists(channel->callbacks, channel_eof_function)) {\n      channel->callbacks->channel_eof_function(channel->session,\n                                               channel,\n                                               channel->callbacks->userdata);\n  }\n\n  return SSH_PACKET_USED;\n}", "item_id": 9, "repo": "rvagg/node-libssh", "file": "deps/libssh-0.6.4/src/channels.c", "last_update_at": "2018-03-27T09:55:44+00:00", "question_id": "ced9697a9812676ec762fc4fd38d0b7764fd006e_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["SSH_PACKET_CALLBACK(channel_rcv_eof) {\n  ssh_channel channel;\n  (void)user;\n  (void)type;\n  channel = channel_from_msg(session,packet);\n  if (channel == NULL) {\n    SSH_LOG(SSH_LOG_FUNCTIONS, \"%s\", ssh_get_error(session));\n    return SSH_PACKET_USED;\n  }\n  SSH_LOG(SSH_LOG_PACKET,\n      \"Received eof on channel (%d:%d)\",\n      channel->local_channel,\n      channel->remote_channel);\n  /* channel->remote_window = 0; */\n  channel->remote_eof = 1;\n  if(ssh_callbacks_exists(channel->callbacks, channel_eof_function)) {\n      channel->callbacks->channel_eof_function(channel->session,\n                                               channel,\n                                               channel->callbacks->userdata);\n  }\n  return SSH_PACKET_USED;\n"]], "pred": {"ppl": 2.4925806522369385, "ppl_lower": 3.1858437061309814, "ppl/lowercase_ppl": -1.2686889096782745, "ppl/zlib": 0.0027760443170183283, "Min_5.0% Prob": 6.79949430624644, "Min_10.0% Prob": 5.438141918182373, "Min_20.0% Prob": 3.7596282304502, "Min_30.0% Prob": 2.8091752939410024, "Min_40.0% Prob": 2.210406213709452, "Min_50.0% Prob": 1.8092981310084808, "Min_60.0% Prob": 1.5257366203231277}}
{"hexsha": "698bf4f5ac6c9e93098989c5891feb2611385387", "ext": "c", "lang": "C", "content": "static irqreturn_t tpd_interrupt_handler(int irq, void *dev_id)\n{\n\tTPD_DEBUG_PRINT_INT;\n\ttpd_flag = 1;\n\twake_up_interruptible(&waiter);\n\treturn IRQ_HANDLED;\n}", "item_id": 33, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/drivers/input/touchscreen/mediatek/GT9271TB_hotknot/gt9xx_driver.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "698bf4f5ac6c9e93098989c5891feb2611385387_33", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static irqreturn_t tpd_interrupt_handler(int irq, void *dev_id)\n{\n\tTPD_DEBUG_PRINT_INT;\n\ttpd_flag = 1;\n\twake_up_interruptible(&waiter);\n\treturn IRQ_HANDLED;\n"]], "pred": {"ppl": 1.7127758264541626, "ppl_lower": 2.6957740783691406, "ppl/lowercase_ppl": -1.8428862890303817, "ppl/zlib": 0.003736912116159702, "Min_5.0% Prob": 7.68986701965332, "Min_10.0% Prob": 4.672519189970834, "Min_20.0% Prob": 2.6571513563394547, "Min_30.0% Prob": 1.7670770009810275, "Min_40.0% Prob": 1.3583582151552727, "Min_50.0% Prob": 1.0709597021341324, "Min_60.0% Prob": 0.9029122894545171}}
{"hexsha": "d690d33b2960517c8a01db5579274d0f9cf55728", "ext": "c", "lang": "C", "content": "M3G_API void m3gSetAlphaThreshold(M3GCompositingMode handle,\n                                  M3Gfloat threshold)\n{\n    CompositingMode *compositingMode = (CompositingMode*)handle;\n    M3G_VALIDATE_OBJECT(compositingMode);\n    if (!m3gInRangef(threshold, 0.0f, 1.0f)) {\n        m3gRaiseError(M3G_INTERFACE(compositingMode), M3G_INVALID_VALUE);\n        return;\n    }\n    compositingMode->alphaThreshold = threshold;\n}", "item_id": 6, "repo": "salg/J2ME-Loader", "file": "app/src/main/cpp/src/m3g_compositingmode.c", "last_update_at": "2018-05-02T09:25:55+00:00", "question_id": "d690d33b2960517c8a01db5579274d0f9cf55728_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["M3G_API void m3gSetAlphaThreshold(M3GCompositingMode handle,\n                                  M3Gfloat threshold)\n{\n    CompositingMode *compositingMode = (CompositingMode*)handle;\n    M3G_VALIDATE_OBJECT(compositingMode);\n    if (!m3gInRangef(threshold, 0.0f, 1.0f)) {\n        m3gRaiseError(M3G_INTERFACE(compositingMode), M3G_INVALID_VALUE);\n        return;\n    }\n    compositingMode->alphaThreshold = threshold;\n"]], "pred": {"ppl": 1.8215456008911133, "ppl_lower": 4.056334018707275, "ppl/lowercase_ppl": -2.3350237977060244, "ppl/zlib": 0.002665268319798735, "Min_5.0% Prob": 5.647994450160435, "Min_10.0% Prob": 4.365301660129002, "Min_20.0% Prob": 2.871901170960788, "Min_30.0% Prob": 1.9901946105740287, "Min_40.0% Prob": 1.4998783970851515, "Min_50.0% Prob": 1.1984000603315998, "Min_60.0% Prob": 1.0083194181074346}}
{"hexsha": "6c8defc2e7afa02ff5ac85d420cd06384601919f", "ext": "c", "lang": "C", "content": "static PyObject *\nVec2Array_longest(polypaths_planar_overrideSeq2Object *self)\n{\n\tdouble max_len = -1.0;\n\tdouble L;\n\tPy_ssize_t max_i = -1;\n\tPy_ssize_t i;\n\n\tfor (i = 0; i < Py_SIZE(self); ++i) {\n\t\tL = self->vec[i].x * self->vec[i].x + \n\t\t\tself->vec[i].y * self->vec[i].y;\n\t\tif (L > max_len) {\n\t\t\tmax_len = L;\n\t\t\tmax_i = i;\n\t\t}\n\t}\n\tif (max_i > -1) {\n\t\treturn (PyObject *)polypaths_planar_overrideVec2_FromStruct(&self->vec[max_i]);\n\t} else {\n\t\tPy_RETURN_NONE;\n\t}\n}", "item_id": 38, "repo": "apolcyn/polypaths_planar_override", "file": "lib/polypaths_planar_override/cvector.c", "last_update_at": "2018-10-19T00:14:58+00:00", "question_id": "6c8defc2e7afa02ff5ac85d420cd06384601919f_38", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static PyObject *\nVec2Array_longest(polypaths_planar_overrideSeq2Object *self)\n{\n\tdouble max_len = -1.0;\n\tdouble L;\n\tPy_ssize_t max_i = -1;\n\tPy_ssize_t i;\n\tfor (i = 0; i < Py_SIZE(self); ++i) {\n\t\tL = self->vec[i].x * self->vec[i].x + \n\t\t\tself->vec[i].y * self->vec[i].y;\n\t\tif (L > max_len) {\n\t\t\tmax_len = L;\n\t\t\tmax_i = i;\n\t\t}\n\t}\n\tif (max_i > -1) {\n\t\treturn (PyObject *)polypaths_planar_overrideVec2_FromStruct(&self->vec[max_i]);\n\t} else {\n\t\tPy_RETURN_NONE;\n\t}\n"]], "pred": {"ppl": 2.275402784347534, "ppl_lower": 2.8524937629699707, "ppl/lowercase_ppl": -1.2749310753642937, "ppl/zlib": 0.002968076118399296, "Min_5.0% Prob": 9.370433677326549, "Min_10.0% Prob": 6.2092568978019385, "Min_20.0% Prob": 3.8246526477184704, "Min_30.0% Prob": 2.700335280576222, "Min_40.0% Prob": 2.055646498501301, "Min_50.0% Prob": 1.6480340980963797, "Min_60.0% Prob": 1.3731714345944614}}
{"hexsha": "6259df028241962e7e75a58ca1332ecee0f97a39", "ext": "c", "lang": "C", "content": "int ts_db_get(ts_db * self, char * table, char * key_name, MDB_val * val) {\n\n    // get a value from a given table\n    MDB_val key;\n\n    key.mv_size = strlen(key_name);\n    key.mv_data = key_name;\n\n    int res = mdb_get(self->current_txn->txn, _get_dbi(self, table), &key, val);\n    return res == MDB_NOTFOUND ? TS_KEY_NOT_FOUND : TS_SUCCESS;\n}", "item_id": 9, "repo": "tavoe/tagsystem", "file": "src/tsdb.c", "last_update_at": "2018-11-07T08:31:31+00:00", "question_id": "6259df028241962e7e75a58ca1332ecee0f97a39_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int ts_db_get(ts_db * self, char * table, char * key_name, MDB_val * val) {\n    // get a value from a given table\n    MDB_val key;\n    key.mv_size = strlen(key_name);\n    key.mv_data = key_name;\n    int res = mdb_get(self->current_txn->txn, _get_dbi(self, table), &key, val);\n    return res == MDB_NOTFOUND ? TS_KEY_NOT_FOUND : TS_SUCCESS;\n"]], "pred": {"ppl": 2.9224114418029785, "ppl_lower": 3.5438334941864014, "ppl/lowercase_ppl": -1.1797820769926721, "ppl/zlib": 0.004830671674319685, "Min_5.0% Prob": 8.112640040261406, "Min_10.0% Prob": 6.156750406537737, "Min_20.0% Prob": 4.302239886351994, "Min_30.0% Prob": 3.2388809586680214, "Min_40.0% Prob": 2.6129483486476697, "Min_50.0% Prob": 2.1217813255886235, "Min_60.0% Prob": 1.7887044413405102}}
{"hexsha": "e03d1cb10b0402fb4b8ce4af3c90e26ca64ed93f", "ext": "h", "lang": "C", "content": "interface SSVLoadSoftwareUpdatesOperation : SSVLoadDownloadQueueOperation {\n    NSArray * _appMetadata;\n    NSLock * _lock;\n    long long  _reason;\n    NSArray * _specificApps;\n    id /* block */  _updatesBlock;\n    NSString * _userAgent;\n}", "item_id": 0, "repo": "shaojiankui/iOS10-Runtime-Headers", "file": "PrivateFrameworks/StoreServices.framework/SSVLoadSoftwareUpdatesOperation.h", "last_update_at": "2018-10-08T04:12:25+00:00", "question_id": "e03d1cb10b0402fb4b8ce4af3c90e26ca64ed93f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface SSVLoadSoftwareUpdatesOperation : SSVLoadDownloadQueueOperation {\n    NSArray * _appMetadata;\n    NSLock * _lock;\n    long long  _reason;\n    NSArray * _specificApps;\n    id /* block */  _updatesBlock;\n    NSString * _userAgent;\n"]], "pred": {"ppl": 6.3058013916015625, "ppl_lower": 11.718131065368652, "ppl/lowercase_ppl": -1.3365068225421366, "ppl/zlib": 0.011297362364905863, "Min_5.0% Prob": 9.149945576985678, "Min_10.0% Prob": 7.843614986964634, "Min_20.0% Prob": 6.4319585391453336, "Min_30.0% Prob": 5.200012228705666, "Min_40.0% Prob": 4.290894241168581, "Min_50.0% Prob": 3.564460789835131, "Min_60.0% Prob": 3.0679422068324955}}
{"hexsha": "b4207079b33c970f60153b65d55f237207e07daf", "ext": "c", "lang": "C", "content": "int b16_decode( char *buf, size_t sz, const void *s, size_t len, size_t *errcnt )\n{\n    const uint8_t *p = s;\n    int c, d;\n    size_t i, n, e, err = 0;\n    int st = 0;\n\n    for ( i = n = e = 0; i < len; ++i )\n    {\n        if ( 0 == st )\n        {\n            c = XTOD( p[i] );\n            if ( 0 >  c )\n            {\n                ++err;\n                continue;\n            }\n        }\n        else\n        {\n            d = XTOD( p[i] );\n            if ( 0 >  d )\n                ++err;\n            else if ( n + 1 < sz )\n            {\n                buf[n++] = (c << 4) | d;\n                e = n;\n            }\n            else\n                ++n;\n        }\n        st = !st;\n    }\n    buf[e] = '\\0';\n    if ( errcnt )\n        *errcnt = err;\n    return n;\n}", "item_id": 1, "repo": "irrwahn/utlib", "file": "lib/base16.c", "last_update_at": "2018-06-20T16:07:36+00:00", "question_id": "b4207079b33c970f60153b65d55f237207e07daf_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int b16_decode( char *buf, size_t sz, const void *s, size_t len, size_t *errcnt )\n{\n    const uint8_t *p = s;\n    int c, d;\n    size_t i, n, e, err = 0;\n    int st = 0;\n    for ( i = n = e = 0; i < len; ++i )\n    {\n        if ( 0 == st )\n        {\n            c = XTOD( p[i] );\n            if ( 0 >  c )\n            {\n                ++err;\n                continue;\n            }\n        }\n        else\n        {\n            d = XTOD( p[i] );\n            if ( 0 >  d )\n                ++err;\n            else if ( n + 1 < sz )\n            {\n                buf[n++] = (c << 4) | d;\n                e = n;\n            }\n            else\n                ++n;\n        }\n        st = !st;\n    }\n    buf[e] = '\\0';\n    if ( errcnt )\n        *errcnt = err;\n    return n;\n"]], "pred": {"ppl": 2.3418664932250977, "ppl_lower": 2.337191581726074, "ppl/lowercase_ppl": -0.9976517629031298, "ppl/zlib": 0.0027628190197920618, "Min_5.0% Prob": 6.209780182157244, "Min_10.0% Prob": 4.8614809427942545, "Min_20.0% Prob": 3.4220497106250964, "Min_30.0% Prob": 2.607464988792644, "Min_40.0% Prob": 2.058329041066923, "Min_50.0% Prob": 1.6789301685936802, "Min_60.0% Prob": 1.4159549193685514}}
{"hexsha": "cf3648d1487a2fe7ce0715ef99991e781036c64f", "ext": "c", "lang": "C", "content": "static void iface_stat_create(struct net_device *net_dev,\n\t\t\t      struct in_ifaddr *ifa)\n{\n\tstruct in_device *in_dev = NULL;\n\tconst char *ifname;\n\tstruct iface_stat *entry;\n\t__be32 ipaddr = 0;\n\tstruct iface_stat *new_iface;\n\n\tIF_DEBUG(\"qtaguid: iface_stat: create(%s): ifa=%p netdev=%p\\n\",\n\t\t net_dev ? net_dev->name : \"?\",\n\t\t ifa, net_dev);\n\tif (!net_dev) {\n\t\tpr_err(\"qtaguid: iface_stat: create(): no net dev\\n\");\n\t\treturn;\n\t}\n\n\tifname = net_dev->name;\n\tif (!ifa) {\n\t\tin_dev = in_dev_get(net_dev);\n\t\tif (!in_dev) {\n\t\t\tpr_err(\"qtaguid: iface_stat: create(%s): no inet dev\\n\",\n\t\t\t       ifname);\n\t\t\treturn;\n\t\t}\n\t\tIF_DEBUG(\"qtaguid: iface_stat: create(%s): in_dev=%p\\n\",\n\t\t\t ifname, in_dev);\n\t\tfor (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next) {\n\t\t\tIF_DEBUG(\"qtaguid: iface_stat: create(%s): \"\n\t\t\t\t \"ifa=%p ifa_label=%s\\n\",\n\t\t\t\t ifname, ifa,\n\t\t\t\t ifa->ifa_label ? ifa->ifa_label : \"(null)\");\n\t\t\tif (ifa->ifa_label && !strcmp(ifname, ifa->ifa_label))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ifa) {\n\t\tIF_DEBUG(\"qtaguid: iface_stat: create(%s): no matching IP\\n\",\n\t\t\t ifname);\n\t\tgoto done_put;\n\t}\n\tipaddr = ifa->ifa_local;\n\n\tspin_lock_bh(&iface_stat_list_lock);\n\tentry = get_iface_entry(ifname);\n\tif (entry != NULL) {\n\t\tIF_DEBUG(\"qtaguid: iface_stat: create(%s): entry=%p\\n\",\n\t\t\t ifname, entry);\n\t\tiface_check_stats_reset_and_adjust(net_dev, entry);\n\t\t_iface_stat_set_active(entry, net_dev, true);\n\t\tIF_DEBUG(\"qtaguid: %s(%s): \"\n\t\t\t \"tracking now %d on ip=%pI4\\n\", __func__,\n\t\t\t entry->ifname, true, &ipaddr);\n\t\tgoto done_unlock_put;\n\t}\n\n\tnew_iface = iface_alloc(net_dev);\n\tIF_DEBUG(\"qtaguid: iface_stat: create(%s): done \"\n\t\t \"entry=%p ip=%pI4\\n\", ifname, new_iface, &ipaddr);\ndone_unlock_put:\n\tspin_unlock_bh(&iface_stat_list_lock);\ndone_put:\n\tif (in_dev)\n\t\tin_dev_put(in_dev);\n}", "item_id": 27, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/net/netfilter/xt_qtaguid.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "cf3648d1487a2fe7ce0715ef99991e781036c64f_27", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void iface_stat_create(struct net_device *net_dev,\n\t\t\t      struct in_ifaddr *ifa)\n{\n\tstruct in_device *in_dev = NULL;\n\tconst char *ifname;\n\tstruct iface_stat *entry;\n\t__be32 ipaddr = 0;\n\tstruct iface_stat *new_iface;\n\tIF_DEBUG(\"qtaguid: iface_stat: create(%s): ifa=%p netdev=%p\\n\",\n\t\t net_dev ? net_dev->name : \"?\",\n\t\t ifa, net_dev);\n\tif (!net_dev) {\n\t\tpr_err(\"qtaguid: iface_stat: create(): no net dev\\n\");\n\t\treturn;\n\t}\n\tifname = net_dev->name;\n\tif (!ifa) {\n\t\tin_dev = in_dev_get(net_dev);\n\t\tif (!in_dev) {\n\t\t\tpr_err(\"qtaguid: iface_stat: create(%s): no inet dev\\n\",\n\t\t\t       ifname);\n\t\t\treturn;\n\t\t}\n\t\tIF_DEBUG(\"qtaguid: iface_stat: create(%s): in_dev=%p\\n\",\n\t\t\t ifname, in_dev);\n\t\tfor (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next) {\n\t\t\tIF_DEBUG(\"qtaguid: iface_stat: create(%s): \"\n\t\t\t\t \"ifa=%p ifa_label=%s\\n\",\n\t\t\t\t ifname, ifa,\n\t\t\t\t ifa->ifa_label ? ifa->ifa_label : \"(null)\");\n\t\t\tif (ifa->ifa_label && !strcmp(ifname, ifa->ifa_label))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!ifa) {\n\t\tIF_DEBUG(\"qtaguid: iface_stat: create(%s): no matching IP\\n\",\n\t\t\t ifname);\n\t\tgoto done_put;\n\t}\n\tipaddr = ifa->ifa_local;\n\tspin_lock_bh(&iface_stat_list_lock);\n\tentry = get_iface_entry(ifname);\n\tif (entry != NULL) {\n\t\tIF_DEBUG(\"qtaguid: iface_stat: create(%s): entry=%p\\n\",\n\t\t\t ifname, entry);\n\t\tiface_check_stats_reset_and_adjust(net_dev, entry);\n\t\t_iface_stat_set_active(entry, net_dev, true);\n\t\tIF_DEBUG(\"qtaguid: %s(%s): \"\n\t\t\t \"tracking now %d on ip=%pI4\\n\", __func__,\n\t\t\t entry->ifname, true, &ipaddr);\n\t\tgoto done_unlock_put;\n\t}\n\tnew_iface = iface_alloc(net_dev);\n\tIF_DEBUG(\"qtaguid: iface_stat: create(%s): done \"\n\t\t \"entry=%p ip=%pI4\\n\", ifname, new_iface, &ipaddr);\ndone_unlock_put:\n\tspin_unlock_bh(&iface_stat_list_lock);\ndone_put:\n\tif (in_dev)\n\t\tin_dev_put(in_dev);\n"]], "pred": {"ppl": 1.8021196126937866, "ppl_lower": 1.8601840734481812, "ppl/lowercase_ppl": -1.0538435920925036, "ppl/zlib": 0.0009131217592662651, "Min_5.0% Prob": 5.693085530909096, "Min_10.0% Prob": 4.220066398023123, "Min_20.0% Prob": 2.7016877835382243, "Min_30.0% Prob": 1.9145836966683665, "Min_40.0% Prob": 1.4646285884305388, "Min_50.0% Prob": 1.1769316276784934, "Min_60.0% Prob": 0.9814029428087531}}
{"hexsha": "8b37518f8cee6b7f60010949cbe78d9edc3fe978", "ext": "h", "lang": "C", "content": "class RenderManager {\npublic:\n    /**\n     * The constructor.\n     * @param applicationContext context to bind to this RenderManager\n     * @param windowManager user provided manager used for getting window render\n     */\n    RenderManager(ApplicationContext &applicationContext,\n                  WindowManager &windowManager);\n\n    /**\n     * Check if RenderManager has been successfully initialized.\n     * This usually means if the window has been successfully created.\n     * @return whether the constructor failed or not\n     */\n    bool initialized();\n    \n    /**\n     * Switch current window render (and reload it)\n     * @param window window to get render for\n     * @return return code. 0 on success, -1 on error\n     */\n    int switchWindow(Window &window);\n\n    /**\n     * Updates internally-held window dimensions.\n     * On mobile devices this method is triggered by screen rotation.\n     * Note that this method does not change the size of the window.\n     * @param width new width of the window\n     * @param height new height of the window\n     */\n    void resize(uint32_t width, uint32_t height);\n\n    /**\n     * Render current window render.\n     * This is called every tick.\n     */\n    void render();\n\n    /**\n     * The destructor.\n     * If SDL2 is used, this destructor destroys the physical window.\n     */\n    ~RenderManager();\n\nprivate:\n    int initWindow();\n    int initGL();\n\nprivate:\n    bool m_initialized = false;\n    ApplicationContext &m_applicationContext;\n    WindowManager &m_windowManager;\n    RenderContext m_renderContext;\n\n#ifdef USES_SDL\n    SDL_Window *m_sdlWindow = nullptr;\n    SDL_GL_Context *m_sdlContext = nullptr;\n#endif // USES_SDL\n\n    Window *m_currentWindow = nullptr;\n    WindowRender *m_windowRender = nullptr;\n}", "item_id": 0, "repo": "darsto/spooky", "file": "src/render/RenderManager.h", "last_update_at": "2018-12-16T15:50:44+00:00", "question_id": "8b37518f8cee6b7f60010949cbe78d9edc3fe978_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class RenderManager {\npublic:\n    /**\n     * The constructor.\n     * @param applicationContext context to bind to this RenderManager\n     * @param windowManager user provided manager used for getting window render\n     */\n    RenderManager(ApplicationContext &applicationContext,\n                  WindowManager &windowManager);\n    /**\n     * Check if RenderManager has been successfully initialized.\n     * This usually means if the window has been successfully created.\n     * @return whether the constructor failed or not\n     */\n    bool initialized();\n    /**\n     * Switch current window render (and reload it)\n     * @param window window to get render for\n     * @return return code. 0 on success, -1 on error\n     */\n    int switchWindow(Window &window);\n    /**\n     * Updates internally-held window dimensions.\n     * On mobile devices this method is triggered by screen rotation.\n     * Note that this method does not change the size of the window.\n     * @param width new width of the window\n     * @param height new height of the window\n     */\n    void resize(uint32_t width, uint32_t height);\n    /**\n     * Render current window render.\n     * This is called every tick.\n     */\n    void render();\n    /**\n     * The destructor.\n     * If SDL2 is used, this destructor destroys the physical window.\n     */\n    ~RenderManager();\nprivate:\n    int initWindow();\n    int initGL();\nprivate:\n    bool m_initialized = false;\n    ApplicationContext &m_applicationContext;\n    WindowManager &m_windowManager;\n    RenderContext m_renderContext;\n#ifdef USES_SDL\n    SDL_Window *m_sdlWindow = nullptr;\n    SDL_GL_Context *m_sdlContext = nullptr;\n#endif // USES_SDL\n    Window *m_currentWindow = nullptr;\n    WindowRender *m_windowRender = nullptr;\n"]], "pred": {"ppl": 3.0435383319854736, "ppl_lower": 3.3196094036102295, "ppl/lowercase_ppl": -1.0780096524302587, "ppl/zlib": 0.0016319952545128947, "Min_5.0% Prob": 7.060646181521208, "Min_10.0% Prob": 5.812688999987663, "Min_20.0% Prob": 4.28376956696206, "Min_30.0% Prob": 3.314029380469255, "Min_40.0% Prob": 2.671947957977416, "Min_50.0% Prob": 2.194828065324433, "Min_60.0% Prob": 1.8515142648625122}}
{"hexsha": "9c42be634291d497602a530f758d2e21569bf53a", "ext": "c", "lang": "C", "content": "char* inputEmail(){\n        static char typedEmail[SHORT_STRING_SIZE];\n        scanf(\" %[^\\n]%*c\",typedEmail);\n        while (checkEmail(typedEmail)==0) {\n                printf(\"\\t\\tThat's not an email. Please type in another email: \");\n                scanf(\" %[^\\n]%*c\",typedEmail);\n        }\n        int n=strlen(typedEmail);\n        for (int i=0; i<n;) {\n                if ((typedEmail[i]==' ') && (typedEmail[i+1]==' ')) {\n                        for (int j=i+1; j<n; j++) {\n                                typedEmail[j]=typedEmail[j+1];\n                        }\n                        n--;\n                } else i++;\n        }\n        return typedEmail;\n}", "item_id": 5, "repo": "lamhoangtung/Bai-tap-Lap-trinh-can-ban", "file": "Bai tap lon/main.c", "last_update_at": "2018-03-30T14:20:05+00:00", "question_id": "9c42be634291d497602a530f758d2e21569bf53a_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["char* inputEmail(){\n        static char typedEmail[SHORT_STRING_SIZE];\n        scanf(\" %[^\\n]%*c\",typedEmail);\n        while (checkEmail(typedEmail)==0) {\n                printf(\"\\t\\tThat's not an email. Please type in another email: \");\n                scanf(\" %[^\\n]%*c\",typedEmail);\n        }\n        int n=strlen(typedEmail);\n        for (int i=0; i<n;) {\n                if ((typedEmail[i]==' ') && (typedEmail[i+1]==' ')) {\n                        for (int j=i+1; j<n; j++) {\n                                typedEmail[j]=typedEmail[j+1];\n                        }\n                        n--;\n                } else i++;\n        }\n        return typedEmail;\n"]], "pred": {"ppl": 2.242471218109131, "ppl_lower": 2.384138584136963, "ppl/lowercase_ppl": -1.0758556596243043, "ppl/zlib": 0.0028945465237795857, "Min_5.0% Prob": 7.570106458663941, "Min_10.0% Prob": 5.448131004969279, "Min_20.0% Prob": 3.5403571100462052, "Min_30.0% Prob": 2.570113697222301, "Min_40.0% Prob": 1.9807394748287541, "Min_50.0% Prob": 1.6053549601208597, "Min_60.0% Prob": 1.3463675577843945}}
{"hexsha": "03d33d89fbfea75238f3c892cc1a929ab751579d", "ext": "c", "lang": "C", "content": "void sbob_get(sbob_t *sb, sbob_pad_t pad, void *out, size_t len)\n{\n    int j;\n    size_t i;\n\n    j = sb->l;\n    for (i = 0; i < len; i++) {\n        if (j == SBOB_RATE) {\n            sb->s.b[SBOB_RATE] ^= pad;\n            SBOB_PI(&sb->s);\n            j = 0;\n        }\n        ((uint8_t *) out)[i] = sb->s.b[j++];\n    }\n    sb->l = j;\n}", "item_id": 3, "repo": "iadgov/simon-speck-supercop", "file": "crypto_aead/stribob192r2/ssse3/stribob.c", "last_update_at": "2018-03-09T14:52:25+00:00", "question_id": "03d33d89fbfea75238f3c892cc1a929ab751579d_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void sbob_get(sbob_t *sb, sbob_pad_t pad, void *out, size_t len)\n{\n    int j;\n    size_t i;\n    j = sb->l;\n    for (i = 0; i < len; i++) {\n        if (j == SBOB_RATE) {\n            sb->s.b[SBOB_RATE] ^= pad;\n            SBOB_PI(&sb->s);\n            j = 0;\n        }\n        ((uint8_t *) out)[i] = sb->s.b[j++];\n    }\n    sb->l = j;\n"]], "pred": {"ppl": 2.952216863632202, "ppl_lower": 3.031257152557373, "ppl/lowercase_ppl": -1.0244061822319899, "ppl/zlib": 0.005439981745376744, "Min_5.0% Prob": 8.538749694824219, "Min_10.0% Prob": 6.285402425130209, "Min_20.0% Prob": 4.312119076328893, "Min_30.0% Prob": 3.2646280476387513, "Min_40.0% Prob": 2.620710847869752, "Min_50.0% Prob": 2.1327704560907583, "Min_60.0% Prob": 1.8090958243751145}}
{"hexsha": "01ba74950a39cb2b41656d82f17565f6521db65e", "ext": "c", "lang": "C", "content": "unit_t* protobuf_unit_reserved_id_new()\n{\n    struct protobuf_unit_reserved_id_t* unit = (struct protobuf_unit_reserved_id_t*)malloc(sizeof(struct protobuf_unit_reserved_id_t));\n    unit->super.size    =   sizeof(struct protobuf_unit_reserved_id_t);\n    unit->super.prev    =   NULL;\n    unit->super.mo      =   NULL;\n    unit->super.del     =   free;\n    unit->super.accept  =   protobuf_unit_reserved_id_accept;\n    unit->state         =   0;\n    return (struct unit_t*)(unit);\n}", "item_id": 1, "repo": "libbylg/gpr", "file": "plugins/plugins-protobuf/protobuf_unit_reserved_id.c", "last_update_at": "2018-06-06T05:56:25+00:00", "question_id": "01ba74950a39cb2b41656d82f17565f6521db65e_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unit_t* protobuf_unit_reserved_id_new()\n{\n    struct protobuf_unit_reserved_id_t* unit = (struct protobuf_unit_reserved_id_t*)malloc(sizeof(struct protobuf_unit_reserved_id_t));\n    unit->super.size    =   sizeof(struct protobuf_unit_reserved_id_t);\n    unit->super.prev    =   NULL;\n    unit->super.mo      =   NULL;\n    unit->super.del     =   free;\n    unit->super.accept  =   protobuf_unit_reserved_id_accept;\n    unit->state         =   0;\n    return (struct unit_t*)(unit);\n"]], "pred": {"ppl": 2.605114698410034, "ppl_lower": 2.72479248046875, "ppl/lowercase_ppl": -1.0469103495883234, "ppl/zlib": 0.005440208547362813, "Min_5.0% Prob": 8.728255987167358, "Min_10.0% Prob": 6.74490670596852, "Min_20.0% Prob": 4.518848222844741, "Min_30.0% Prob": 3.182080676450449, "Min_40.0% Prob": 2.383110386737879, "Min_50.0% Prob": 1.920357196873357, "Min_60.0% Prob": 1.6061966474918485}}
{"hexsha": "856cfb40305d7f50984efb8527a86f96bb6858cf", "ext": "c", "lang": "C", "content": "int\nlibxlDomainStart(libxlDriverPrivatePtr driver, virDomainObjPtr vm,\n                 bool start_paused, int restore_fd)\n{\n    libxl_domain_config d_config;\n    virDomainDefPtr def = NULL;\n    virObjectEventPtr event = NULL;\n    libxlSavefileHeader hdr;\n    int ret = -1;\n    uint32_t domid = 0;\n    char *dom_xml = NULL;\n    char *managed_save_path = NULL;\n    int managed_save_fd = -1;\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    libxlDriverConfigPtr cfg;\n#ifdef LIBXL_HAVE_DOMAIN_CREATE_RESTORE_PARAMS\n    libxl_domain_restore_params params;\n#endif\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n    libxl_asyncprogress_how aop_console_how;\n\n    libxl_domain_config_init(&d_config);\n\n    if (libxlDomainObjPrivateInitCtx(vm) < 0)\n        return ret;\n\n    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)\n        return ret;\n\n    cfg = libxlDriverConfigGet(driver);\n    /* If there is a managed saved state restore it instead of starting\n     * from scratch. The old state is removed once the restoring succeeded. */\n    if (restore_fd < 0) {\n        managed_save_path = libxlDomainManagedSavePath(driver, vm);\n        if (managed_save_path == NULL)\n            goto endjob;\n\n        if (virFileExists(managed_save_path)) {\n\n            managed_save_fd = libxlDomainSaveImageOpen(driver, cfg,\n                                                       managed_save_path,\n                                                       &def, &hdr);\n            if (managed_save_fd < 0)\n                goto endjob;\n\n            restore_fd = managed_save_fd;\n\n            if (STRNEQ(vm->def->name, def->name) ||\n                memcmp(vm->def->uuid, def->uuid, VIR_UUID_BUFLEN)) {\n                char vm_uuidstr[VIR_UUID_STRING_BUFLEN];\n                char def_uuidstr[VIR_UUID_STRING_BUFLEN];\n                virUUIDFormat(vm->def->uuid, vm_uuidstr);\n                virUUIDFormat(def->uuid, def_uuidstr);\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"cannot restore domain '%s' uuid %s from a file\"\n                                 \" which belongs to domain '%s' uuid %s\"),\n                               vm->def->name, vm_uuidstr, def->name, def_uuidstr);\n                goto endjob;\n            }\n\n            virDomainObjAssignDef(vm, def, true, NULL);\n            def = NULL;\n\n            if (unlink(managed_save_path) < 0)\n                VIR_WARN(\"Failed to remove the managed state %s\",\n                         managed_save_path);\n\n            vm->hasManagedSave = false;\n        }\n        VIR_FREE(managed_save_path);\n    }\n\n    if (libxlBuildDomainConfig(driver->reservedVNCPorts, vm->def,\n                               priv->ctx, &d_config) < 0)\n        goto endjob;\n\n    if (cfg->autoballoon && libxlDomainFreeMem(priv, &d_config) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"libxenlight failed to get free memory for domain '%s'\"),\n                       d_config.c_info.name);\n        goto endjob;\n    }\n\n    if (virHostdevPrepareDomainDevices(hostdev_mgr, LIBXL_DRIVER_NAME,\n                                       vm->def, VIR_HOSTDEV_SP_PCI) < 0)\n        goto endjob;\n\n    /* Unlock virDomainObj while creating the domain */\n    virObjectUnlock(vm);\n\n    aop_console_how.for_callback = vm;\n    aop_console_how.callback = libxlConsoleCallback;\n    if (restore_fd < 0) {\n        ret = libxl_domain_create_new(priv->ctx, &d_config,\n                                      &domid, NULL, &aop_console_how);\n    } else {\n#ifdef LIBXL_HAVE_DOMAIN_CREATE_RESTORE_PARAMS\n        params.checkpointed_stream = 0;\n        ret = libxl_domain_create_restore(priv->ctx, &d_config, &domid,\n                                          restore_fd, &params, NULL,\n                                          &aop_console_how);\n#else\n        ret = libxl_domain_create_restore(priv->ctx, &d_config, &domid,\n                                          restore_fd, NULL, &aop_console_how);\n#endif\n    }\n    virObjectLock(vm);\n\n    if (ret) {\n        if (restore_fd < 0)\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"libxenlight failed to create new domain '%s'\"),\n                           d_config.c_info.name);\n        else\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"libxenlight failed to restore domain '%s'\"),\n                           d_config.c_info.name);\n        goto endjob;\n    }\n\n    /*\n     * The domain has been successfully created with libxl, so it should\n     * be cleaned up if there are any subsequent failures.\n     */\n    vm->def->id = domid;\n    if (libxlDomainEventsRegister(driver, vm) < 0)\n        goto cleanup_dom;\n\n    if ((dom_xml = virDomainDefFormat(vm->def, 0)) == NULL)\n        goto cleanup_dom;\n\n    if (libxl_userdata_store(priv->ctx, domid, \"libvirt-xml\",\n                             (uint8_t *)dom_xml, strlen(dom_xml) + 1)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libxenlight failed to store userdata\"));\n        goto cleanup_dom;\n    }\n\n    if (libxlDomainSetVcpuAffinities(driver, vm) < 0)\n        goto cleanup_dom;\n\n    if (!start_paused) {\n        libxl_domain_unpause(priv->ctx, domid);\n        virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, VIR_DOMAIN_RUNNING_BOOTED);\n    } else {\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_USER);\n    }\n\n    if (virDomainSaveStatus(driver->xmlopt, cfg->stateDir, vm) < 0)\n        goto cleanup_dom;\n\n    if (virAtomicIntInc(&driver->nactive) == 1 && driver->inhibitCallback)\n        driver->inhibitCallback(true, driver->inhibitOpaque);\n\n    event = virDomainEventLifecycleNewFromObj(vm, VIR_DOMAIN_EVENT_STARTED,\n                                     restore_fd < 0 ?\n                                         VIR_DOMAIN_EVENT_STARTED_BOOTED :\n                                         VIR_DOMAIN_EVENT_STARTED_RESTORED);\n    if (event)\n        libxlDomainEventQueue(driver, event);\n\n    ret = 0;\n    goto endjob;\n\n cleanup_dom:\n    libxl_domain_destroy(priv->ctx, domid, NULL);\n    vm->def->id = -1;\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, VIR_DOMAIN_SHUTOFF_FAILED);\n\n endjob:\n    if (!libxlDomainObjEndJob(driver, vm))\n        vm = NULL;\n\n    libxl_domain_config_dispose(&d_config);\n    VIR_FREE(dom_xml);\n    VIR_FREE(managed_save_path);\n    virDomainDefFree(def);\n    VIR_FORCE_CLOSE(managed_save_fd);\n    virObjectUnref(cfg);\n    return ret;\n}", "item_id": 30, "repo": "SIIS-cloud/pileus", "file": "libvirt/pileus-libvirt-1.2.12/src/libxl/libxl_domain.c", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "856cfb40305d7f50984efb8527a86f96bb6858cf_30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nlibxlDomainStart(libxlDriverPrivatePtr driver, virDomainObjPtr vm,\n                 bool start_paused, int restore_fd)\n{\n    libxl_domain_config d_config;\n    virDomainDefPtr def = NULL;\n    virObjectEventPtr event = NULL;\n    libxlSavefileHeader hdr;\n    int ret = -1;\n    uint32_t domid = 0;\n    char *dom_xml = NULL;\n    char *managed_save_path = NULL;\n    int managed_save_fd = -1;\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    libxlDriverConfigPtr cfg;\n#ifdef LIBXL_HAVE_DOMAIN_CREATE_RESTORE_PARAMS\n    libxl_domain_restore_params params;\n#endif\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n    libxl_asyncprogress_how aop_console_how;\n    libxl_domain_config_init(&d_config);\n    if (libxlDomainObjPrivateInitCtx(vm) < 0)\n        return ret;\n    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)\n        return ret;\n    cfg = libxlDriverConfigGet(driver);\n    /* If there is a managed saved state restore it instead of starting\n     * from scratch. The old state is removed once the restoring succeeded. */\n    if (restore_fd < 0) {\n        managed_save_path = libxlDomainManagedSavePath(driver, vm);\n        if (managed_save_path == NULL)\n            goto endjob;\n        if (virFileExists(managed_save_path)) {\n            managed_save_fd = libxlDomainSaveImageOpen(driver, cfg,\n                                                       managed_save_path,\n                                                       &def, &hdr);\n            if (managed_save_fd < 0)\n                goto endjob;\n            restore_fd = managed_save_fd;\n            if (STRNEQ(vm->def->name, def->name) ||\n                memcmp(vm->def->uuid, def->uuid, VIR_UUID_BUFLEN)) {\n                char vm_uuidstr[VIR_UUID_STRING_BUFLEN];\n                char def_uuidstr[VIR_UUID_STRING_BUFLEN];\n                virUUIDFormat(vm->def->uuid, vm_uuidstr);\n                virUUIDFormat(def->uuid, def_uuidstr);\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"cannot restore domain '%s' uuid %s from a file\"\n                                 \" which belongs to domain '%s' uuid %s\"),\n                               vm->def->name, vm_uuidstr, def->name, def_uuidstr);\n                goto endjob;\n            }\n            virDomainObjAssignDef(vm, def, true, NULL);\n            def = NULL;\n            if (unlink(managed_save_path) < 0)\n                VIR_WARN(\"Failed to remove the managed state %s\",\n                         managed_save_path);\n            vm->hasManagedSave = false;\n        }\n        VIR_FREE(managed_save_path);\n    }\n    if (libxlBuildDomainConfig(driver->reservedVNCPorts, vm->def,\n                               priv->ctx, &d_config) < 0)\n        goto endjob;\n    if (cfg->autoballoon && libxlDomainFreeMem(priv, &d_config) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"libxenlight failed to get free memory for domain '%s'\"),\n                       d_config.c_info.name);\n        goto endjob;\n    }\n    if (virHostdevPrepareDomainDevices(hostdev_mgr, LIBXL_DRIVER_NAME,\n                                       vm->def, VIR_HOSTDEV_SP_PCI) < 0)\n        goto endjob;\n    /* Unlock virDomainObj while creating the domain */\n    virObjectUnlock(vm);\n    aop_console_how.for_callback = vm;\n    aop_console_how.callback = libxlConsoleCallback;\n    if (restore_fd < 0) {\n        ret = libxl_domain_create_new(priv->ctx, &d_config,\n                                      &domid, NULL, &aop_console_how);\n    } else {\n#ifdef LIBXL_HAVE_DOMAIN_CREATE_RESTORE_PARAMS\n        params.checkpointed_stream = 0;\n        ret = libxl_domain_create_restore(priv->ctx, &d_config, &domid,\n                                          restore_fd, &params, NULL,\n                                          &aop_console_how);\n#else\n        ret = libxl_domain_create_restore(priv->ctx, &d_config, &domid,\n                                          restore_fd, NULL, &aop_console_how);\n#endif\n    }\n    virObjectLock(vm);\n    if (ret) {\n        if (restore_fd < 0)\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"libxenlight failed to create new domain '%s'\"),\n                           d_config.c_info.name);\n        else\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"libxenlight failed to restore domain '%s'\"),\n                           d_config.c_info.name);\n        goto endjob;\n    }\n    /*\n     * The domain has been successfully created with libxl, so it should\n     * be cleaned up if there are any subsequent failures.\n     */\n    vm->def->id = domid;\n    if (libxlDomainEventsRegister(driver, vm) < 0)\n        goto cleanup_dom;\n    if ((dom_xml = virDomainDefFormat(vm->def, 0)) == NULL)\n        goto cleanup_dom;\n    if (libxl_userdata_store(priv->ctx, domid, \"libvirt-xml\",\n                             (uint8_t *)dom_xml, strlen(dom_xml) + 1)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libxenlight failed to store userdata\"));\n        goto cleanup_dom;\n    }\n    if (libxlDomainSetVcpuAffinities(driver, vm) < 0)\n        goto cleanup_dom;\n    if (!start_paused) {\n        libxl_domain_unpause(priv->ctx, domid);\n        virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, VIR_DOMAIN_RUNNING_BOOTED);\n    } else {\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_USER);\n    }\n    if (virDomainSaveStatus(driver->xmlopt, cfg->stateDir, vm) < 0)\n        goto cleanup_dom;\n    if (virAtomicIntInc(&driver->nactive) == 1 && driver->inhibitCallback)\n        driver->inhibitCallback(true, driver->inhibitOpaque);\n    event = virDomainEventLifecycleNewFromObj(vm, VIR_DOMAIN_EVENT_STARTED,\n                                     restore_fd < 0 ?\n                                         VIR_DOMAIN_EVENT_STARTED_BOOTED :\n                                         VIR_DOMAIN_EVENT_STARTED_RESTORED);\n    if (event)\n        libxlDomainEventQueue(driver, event);\n    ret = 0;\n    goto endjob;\n cleanup_dom:\n    libxl_domain_destroy(priv->ctx, domid, NULL);\n    vm->def->id = -1;\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, VIR_DOMAIN_SHUTOFF_FAILED);\n endjob:\n    if (!libxlDomainObjEndJob(driver, vm))\n        vm = NULL;\n    libxl_domain_config_dispose(&d_config);\n    VIR_FREE(dom_xml);\n    VIR_FREE(managed_save_path);\n    virDomainDefFree(def);\n    VIR_FORCE_CLOSE(managed_save_fd);\n    virObjectUnref(cfg);\n    return ret;\n"]], "pred": {"ppl": 2.300877094268799, "ppl_lower": 3.312429189682007, "ppl/lowercase_ppl": -1.4372922341875989, "ppl/zlib": 0.00043310311620359287, "Min_5.0% Prob": 6.670905636806114, "Min_10.0% Prob": 5.134129757974662, "Min_20.0% Prob": 3.54421375487365, "Min_30.0% Prob": 2.642815275909075, "Min_40.0% Prob": 2.052668021112899, "Min_50.0% Prob": 1.6625752614231493, "Min_60.0% Prob": 1.3896225098426322}}
{"hexsha": "6c3e3e9185d253fad28e77c74fe76ba930085b8b", "ext": "c", "lang": "C", "content": "static u8 ft5x0x_enter_work(struct ft5x0x_ts_data *ft5x0x_ts)\n{\n\tu8 regval;\n   \t ft5x0x_write_reg(0x00, 0x00); //return to normal mode \n   \t msleep(100);\n\t\n\tif(ft5x0x_read_reg(0x00, &regval)<0)\n\t\tpr_err(\"%s ERROR: could not read register\\n\", __FUNCTION__);\n\telse\n\t{\n\t\tif((regval & 0x70) != 0x00)\n\t\t{\n\t\t\tpr_err(\"%s() - ERROR: The Touch Panel was not put in Work Mode. The Device Mode register contains 0x%02X\\n\", __FUNCTION__, regval);\n\t\t\tenable_irq(IRQ_EINT(6));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tenable_irq(IRQ_EINT(6));\n\treturn 0;\n}", "item_id": 25, "repo": "ADu1975/ADu_Tiny210", "file": "touchscreen/ft5x06_ts.c", "last_update_at": "2018-04-21T00:58:53+00:00", "question_id": "6c3e3e9185d253fad28e77c74fe76ba930085b8b_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static u8 ft5x0x_enter_work(struct ft5x0x_ts_data *ft5x0x_ts)\n{\n\tu8 regval;\n   \t ft5x0x_write_reg(0x00, 0x00); //return to normal mode \n   \t msleep(100);\n\t\n\tif(ft5x0x_read_reg(0x00, &regval)<0)\n\t\tpr_err(\"%s ERROR: could not read register\\n\", __FUNCTION__);\n\telse\n\t{\n\t\tif((regval & 0x70) != 0x00)\n\t\t{\n\t\t\tpr_err(\"%s() - ERROR: The Touch Panel was not put in Work Mode. The Device Mode register contains 0x%02X\\n\", __FUNCTION__, regval);\n\t\t\tenable_irq(IRQ_EINT(6));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tenable_irq(IRQ_EINT(6));\n\treturn 0;\n"]], "pred": {"ppl": 2.6927483081817627, "ppl_lower": 2.9364123344421387, "ppl/lowercase_ppl": -1.0874515309346657, "ppl/zlib": 0.0030478841475757926, "Min_5.0% Prob": 7.169713167043833, "Min_10.0% Prob": 5.62885424723992, "Min_20.0% Prob": 4.104092221993667, "Min_30.0% Prob": 3.0273253766796255, "Min_40.0% Prob": 2.394973225820632, "Min_50.0% Prob": 1.9527943050771048, "Min_60.0% Prob": 1.64618033906327}}
{"hexsha": "9d2255f856edc9b70b053da580eed33bada01390", "ext": "c", "lang": "C", "content": "void\nIdeq_clearData (\n   Ideq   *deq\n) {\nif ( deq == NULL ) {\n   fprintf(stderr, \"\\n fatal error in Ideq_clearData(%p)\"\n           \"\\n deq is NULL\\n\", deq) ;\n   exit(-1) ;\n}\nIV_clearData(&deq->iv) ;\nIdeq_setDefaultFields(deq) ;\n\nreturn ; }", "item_id": 2, "repo": "alleindrach/calculix-desktop", "file": "ccx_prool/SPOOLES.2.2/Ideq/src/basics.c", "last_update_at": "2018-01-25T16:08:31+00:00", "question_id": "9d2255f856edc9b70b053da580eed33bada01390_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nIdeq_clearData (\n   Ideq   *deq\n) {\nif ( deq == NULL ) {\n   fprintf(stderr, \"\\n fatal error in Ideq_clearData(%p)\"\n           \"\\n deq is NULL\\n\", deq) ;\n   exit(-1) ;\n}\nIV_clearData(&deq->iv) ;\nIdeq_setDefaultFields(deq) ;\n"]], "pred": {"ppl": 5.206029891967773, "ppl_lower": 5.414364814758301, "ppl/lowercase_ppl": -1.023783250556801, "ppl/zlib": 0.00976223401411859, "Min_5.0% Prob": 9.115209770202636, "Min_10.0% Prob": 7.732100629806519, "Min_20.0% Prob": 5.968874096870422, "Min_30.0% Prob": 4.745546986979823, "Min_40.0% Prob": 3.926032724903851, "Min_50.0% Prob": 3.2228355379058766, "Min_60.0% Prob": 2.746135556409436}}
{"hexsha": "a287e4fec8653d91e55bb2765e2379984b65bef5", "ext": "c", "lang": "C", "content": "static void tegra_crtc_mode_set_nofb(struct drm_crtc *crtc)\n{\n\tstruct drm_display_mode *mode = &crtc->state->adjusted_mode;\n\tstruct tegra_dc_state *state = to_dc_state(crtc->state);\n\tstruct tegra_dc *dc = to_tegra_dc(crtc);\n\tu32 value;\n\n\ttegra_dc_commit_state(dc, state);\n\n\t/* program display mode */\n\ttegra_dc_set_timings(dc, mode);\n\n\t/* interlacing isn't supported yet, so disable it */\n\tif (dc->soc->supports_interlacing) {\n\t\tvalue = tegra_dc_readl(dc, DC_DISP_INTERLACE_CONTROL);\n\t\tvalue &= ~INTERLACE_ENABLE;\n\t\ttegra_dc_writel(dc, value, DC_DISP_INTERLACE_CONTROL);\n\t}\n\n\tvalue = tegra_dc_readl(dc, DC_CMD_DISPLAY_COMMAND);\n\tvalue &= ~DISP_CTRL_MODE_MASK;\n\tvalue |= DISP_CTRL_MODE_C_DISPLAY;\n\ttegra_dc_writel(dc, value, DC_CMD_DISPLAY_COMMAND);\n\n\tvalue = tegra_dc_readl(dc, DC_CMD_DISPLAY_POWER_CONTROL);\n\tvalue |= PW0_ENABLE | PW1_ENABLE | PW2_ENABLE | PW3_ENABLE |\n\t\t PW4_ENABLE | PM0_ENABLE | PM1_ENABLE;\n\ttegra_dc_writel(dc, value, DC_CMD_DISPLAY_POWER_CONTROL);\n\n\ttegra_dc_commit(dc);\n}", "item_id": 33, "repo": "SIIS-cloud/pileus", "file": "difc-kernel/pileus-kernel/drivers/gpu/drm/tegra/dc.c", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "a287e4fec8653d91e55bb2765e2379984b65bef5_33", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void tegra_crtc_mode_set_nofb(struct drm_crtc *crtc)\n{\n\tstruct drm_display_mode *mode = &crtc->state->adjusted_mode;\n\tstruct tegra_dc_state *state = to_dc_state(crtc->state);\n\tstruct tegra_dc *dc = to_tegra_dc(crtc);\n\tu32 value;\n\ttegra_dc_commit_state(dc, state);\n\t/* program display mode */\n\ttegra_dc_set_timings(dc, mode);\n\t/* interlacing isn't supported yet, so disable it */\n\tif (dc->soc->supports_interlacing) {\n\t\tvalue = tegra_dc_readl(dc, DC_DISP_INTERLACE_CONTROL);\n\t\tvalue &= ~INTERLACE_ENABLE;\n\t\ttegra_dc_writel(dc, value, DC_DISP_INTERLACE_CONTROL);\n\t}\n\tvalue = tegra_dc_readl(dc, DC_CMD_DISPLAY_COMMAND);\n\tvalue &= ~DISP_CTRL_MODE_MASK;\n\tvalue |= DISP_CTRL_MODE_C_DISPLAY;\n\ttegra_dc_writel(dc, value, DC_CMD_DISPLAY_COMMAND);\n\tvalue = tegra_dc_readl(dc, DC_CMD_DISPLAY_POWER_CONTROL);\n\tvalue |= PW0_ENABLE | PW1_ENABLE | PW2_ENABLE | PW3_ENABLE |\n\t\t PW4_ENABLE | PM0_ENABLE | PM1_ENABLE;\n\ttegra_dc_writel(dc, value, DC_CMD_DISPLAY_POWER_CONTROL);\n\ttegra_dc_commit(dc);\n"]], "pred": {"ppl": 1.4088045358657837, "ppl_lower": 1.709447979927063, "ppl/lowercase_ppl": -1.5643582787248818, "ppl/zlib": 0.0008359548728314766, "Min_5.0% Prob": 4.114668885866801, "Min_10.0% Prob": 2.8110777835051217, "Min_20.0% Prob": 1.6472694841213524, "Min_30.0% Prob": 1.1349993275426742, "Min_40.0% Prob": 0.8570033372913409, "Min_50.0% Prob": 0.686564815636181, "Min_60.0% Prob": 0.5723896209219674}}
{"hexsha": "87e8684fbb5ae26011208b1e4e3d02d0b26431a6", "ext": "c", "lang": "C", "content": "TEST_CASE(hostent_2)\r\n{\r\n  struct hostent *phents[1024], *phent2;\r\n  int i = 0, j = 0;\r\n  sethostent(1);\r\n  while (phents[i] = gethostent()) {\r\n    TEST_FAIL_IF(phents[i]->h_name == NULL);\r\n    TEST_FAIL_IF(phents[i]->h_aliases == NULL);\r\n    TEST_FAIL_IF(phents[i]->h_addr_list == NULL);\r\n    TEST_FAIL_IF(phents[i]->h_addr_list[0] == NULL);\r\n    phents[i] = dup_hostent(phents[i]);\r\n    ++i;\r\n  }\r\n  sethostent(1);\r\n  for (j = 0; j < i && (phent2 = gethostent()); ++j) {\r\n    TEST_FAIL_IF(!compare_hostent(phents[j], phent2));\r\n    free_hostent(phents[j]);\r\n  }\r\n  endhostent();\r\n  TEST(i == j);\r\n}", "item_id": 4, "repo": "block8437/FailSafeC", "file": "test/net/gethostent.test.c", "last_update_at": "2018-02-10T02:52:09+00:00", "question_id": "87e8684fbb5ae26011208b1e4e3d02d0b26431a6_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["TEST_CASE(hostent_2)\r\n{\r\n  struct hostent *phents[1024], *phent2;\r\n  int i = 0, j = 0;\r\n  sethostent(1);\r\n  while (phents[i] = gethostent()) {\r\n    TEST_FAIL_IF(phents[i]->h_name == NULL);\r\n    TEST_FAIL_IF(phents[i]->h_aliases == NULL);\r\n    TEST_FAIL_IF(phents[i]->h_addr_list == NULL);\r\n    TEST_FAIL_IF(phents[i]->h_addr_list[0] == NULL);\r\n    phents[i] = dup_hostent(phents[i]);\r\n    ++i;\r\n  }\r\n  sethostent(1);\r\n  for (j = 0; j < i && (phent2 = gethostent()); ++j) {\r\n    TEST_FAIL_IF(!compare_hostent(phents[j], phent2));\r\n    free_hostent(phents[j]);\r\n  }\r\n  endhostent();\r\n  TEST(i == j);\r\n"]], "pred": {"ppl": 1.9981082677841187, "ppl_lower": 2.0912153720855713, "ppl/lowercase_ppl": -1.065796721802348, "ppl/zlib": 0.002725200263143229, "Min_5.0% Prob": 6.94443416595459, "Min_10.0% Prob": 5.043751324926104, "Min_20.0% Prob": 3.187002530055387, "Min_30.0% Prob": 2.2507693132474307, "Min_40.0% Prob": 1.7249818316527776, "Min_50.0% Prob": 1.379557030856715, "Min_60.0% Prob": 1.1536729703629776}}
{"hexsha": "cd55970a730beac9c922670954f3e58beb009dbe", "ext": "c", "lang": "C", "content": "void SystemClock_Config(void)\r\n{\r\n  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};\r\n  RCC_OscInitTypeDef RCC_OscInitStruct = {0};\r\n\r\n  /* Enable HSE Oscillator and activate PLL with HSE as source   */\r\n  /* (Default MSI Oscillator enabled at system reset remains ON) */\r\n  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;\r\n  RCC_OscInitStruct.HSEState = RCC_HSE_ON;\r\n  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;\r\n  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;\r\n  RCC_OscInitStruct.PLL.PLLM = 1;\r\n  RCC_OscInitStruct.PLL.PLLN = 20;\r\n  RCC_OscInitStruct.PLL.PLLR = 2;\r\n  RCC_OscInitStruct.PLL.PLLP = 7;\r\n  RCC_OscInitStruct.PLL.PLLQ = 4;\r\n  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)\r\n  {\r\n    /* Initialization Error */\r\n    while(1);\r\n  }\r\n\r\n  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2\r\n     clocks dividers */\r\n  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);\r\n  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\r\n  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;\r\n  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;\r\n  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;\r\n  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)\r\n  {\r\n    /* Initialization Error */\r\n    while(1);\r\n  }\r\n}", "item_id": 1, "repo": "dpalchak/estoppel", "file": "third_party/st/stm32l4_sdk/v1.12.0/Projects/STM32L476G-EVAL/Examples/DFSDM/DFSDM_Thermometer/Src/main.c", "last_update_at": "2018-08-03T20:06:40+00:00", "question_id": "cd55970a730beac9c922670954f3e58beb009dbe_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void SystemClock_Config(void)\r\n{\r\n  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};\r\n  RCC_OscInitTypeDef RCC_OscInitStruct = {0};\r\n\r\n  /* Enable HSE Oscillator and activate PLL with HSE as source   */\r\n  /* (Default MSI Oscillator enabled at system reset remains ON) */\r\n  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;\r\n  RCC_OscInitStruct.HSEState = RCC_HSE_ON;\r\n  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;\r\n  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;\r\n  RCC_OscInitStruct.PLL.PLLM = 1;\r\n  RCC_OscInitStruct.PLL.PLLN = 20;\r\n  RCC_OscInitStruct.PLL.PLLR = 2;\r\n  RCC_OscInitStruct.PLL.PLLP = 7;\r\n  RCC_OscInitStruct.PLL.PLLQ = 4;\r\n  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)\r\n  {\r\n    /* Initialization Error */\r\n    while(1);\r\n  }\r\n\r\n  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2\r\n     clocks dividers */\r\n  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);\r\n  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\r\n  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;\r\n  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;\r\n  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;\r\n  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)\r\n  {\r\n    /* Initialization Error */\r\n    while(1);\r\n  }\r\n"]], "pred": {"ppl": 1.112835168838501, "ppl_lower": 1.6681276559829712, "ppl/lowercase_ppl": -4.786242769013299, "ppl/zlib": 0.00021729870943983809, "Min_5.0% Prob": 2.0908112016416367, "Min_10.0% Prob": 1.0780465508090151, "Min_20.0% Prob": 0.5375316576138138, "Min_30.0% Prob": 0.3576427370584149, "Min_40.0% Prob": 0.2679065739520668, "Min_50.0% Prob": 0.2141599398492947, "Min_60.0% Prob": 0.17837330529052503}}
{"hexsha": "580b8d3488ff6c54622c01ff6ac51fb360b15fad", "ext": "c", "lang": "C", "content": "void\nwrap_restore_saved()\n{\n    if(!wrap_saved_list)\n\treturn;\n\n    wrap_kill();\n\n    free(wrap_list);\n\n    wrap_list=wrap_saved_list;\n    wrap_count=wrap_saved_count;\n    wrap_tempcount=wrap_saved_tempcount;\n\n    wrap_saved_list=NULL;\n    wrap_saved_count=0;\n    wrap_saved_tempcount=0;\n}", "item_id": 2, "repo": "aaliomer/exos", "file": "bin/CVS/src/wrapper.c", "last_update_at": "2018-01-23T23:07:19+00:00", "question_id": "580b8d3488ff6c54622c01ff6ac51fb360b15fad_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nwrap_restore_saved()\n{\n    if(!wrap_saved_list)\n\treturn;\n    wrap_kill();\n    free(wrap_list);\n    wrap_list=wrap_saved_list;\n    wrap_count=wrap_saved_count;\n    wrap_tempcount=wrap_saved_tempcount;\n    wrap_saved_list=NULL;\n    wrap_saved_count=0;\n    wrap_saved_tempcount=0;\n"]], "pred": {"ppl": 3.177560329437256, "ppl_lower": 3.30085825920105, "ppl/lowercase_ppl": -1.0329282513597426, "ppl/zlib": 0.008758437199612378, "Min_5.0% Prob": 9.52468318939209, "Min_10.0% Prob": 7.510330373590643, "Min_20.0% Prob": 5.0949961651455276, "Min_30.0% Prob": 3.7028235179536484, "Min_40.0% Prob": 2.887251150608063, "Min_50.0% Prob": 2.302712378533263, "Min_60.0% Prob": 1.9356355542481385}}
{"hexsha": "19fca939331151c84921e15fa45f4ad7cf30d950", "ext": "c", "lang": "C", "content": "const char *\nbcmptm_rm_alpm_kt_name(int u, alpm_key_type_t kt)\n{\n    char *name;\n    switch (kt) {\n    case KEY_TYPE_INVALID:\n        name = \"Invalid\";\n        break;\n    case KEY_IPV4:\n        name = \"IPv4\";\n        break;\n    case KEY_IPV6_32:\n        name = \"IPv6-32\";\n        break;\n    case KEY_IPV6_64:\n        name = \"IPv6-64\";\n        break;\n    case KEY_IPV6_128:\n        name = \"IPv6-128\";\n        break;\n    default:\n        name = \"?\";\n        break;\n    }\n    return name;\n}", "item_id": 3, "repo": "lguohan/SDKLT", "file": "src/bcmptm/rm_alpm/rm_alpm_util.c", "last_update_at": "2018-01-31T07:21:49+00:00", "question_id": "19fca939331151c84921e15fa45f4ad7cf30d950_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["const char *\nbcmptm_rm_alpm_kt_name(int u, alpm_key_type_t kt)\n{\n    char *name;\n    switch (kt) {\n    case KEY_TYPE_INVALID:\n        name = \"Invalid\";\n        break;\n    case KEY_IPV4:\n        name = \"IPv4\";\n        break;\n    case KEY_IPV6_32:\n        name = \"IPv6-32\";\n        break;\n    case KEY_IPV6_64:\n        name = \"IPv6-64\";\n        break;\n    case KEY_IPV6_128:\n        name = \"IPv6-128\";\n        break;\n    default:\n        name = \"?\";\n        break;\n    }\n    return name;\n"]], "pred": {"ppl": 1.5344750881195068, "ppl_lower": 1.6270737648010254, "ppl/lowercase_ppl": -1.1368435252543587, "ppl/zlib": 0.002088723709364131, "Min_5.0% Prob": 5.923156094551087, "Min_10.0% Prob": 3.7036139488220217, "Min_20.0% Prob": 2.0863031681627033, "Min_30.0% Prob": 1.423205366420249, "Min_40.0% Prob": 1.0730675803846679, "Min_50.0% Prob": 0.8596558745368383, "Min_60.0% Prob": 0.7168362118090348}}
{"hexsha": "ec79c49de0975651a5e2cdebdd058fc312308537", "ext": "c", "lang": "C", "content": "int mwifiex_recv_packet(struct mwifiex_private *priv, struct sk_buff *skb)\n{\n\tif (!skb)\n\t\treturn -1;\n\n\tpriv->stats.rx_bytes += skb->len;\n\tpriv->stats.rx_packets++;\n\n\tskb->dev = priv->netdev;\n\tskb->protocol = eth_type_trans(skb, priv->netdev);\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\t/* This is required only in case of 11n and USB/PCIE as we alloc\n\t * a buffer of 4K only if its 11N (to be able to receive 4K\n\t * AMSDU packets). In case of SD we allocate buffers based\n\t * on the size of packet and hence this is not needed.\n\t *\n\t * Modifying the truesize here as our allocation for each\n\t * skb is 4K but we only receive 2K packets and this cause\n\t * the kernel to start dropping packets in case where\n\t * application has allocated buffer based on 2K size i.e.\n\t * if there a 64K packet received (in IP fragments and\n\t * application allocates 64K to receive this packet but\n\t * this packet would almost double up because we allocate\n\t * each 1.5K fragment in 4K and pass it up. As soon as the\n\t * 64K limit hits kernel will start to drop rest of the\n\t * fragments. Currently we fail the Filesndl-ht.scr script\n\t * for UDP, hence this fix\n\t */\n\tif ((priv->adapter->iface_type == MWIFIEX_USB ||\n\t     priv->adapter->iface_type == MWIFIEX_PCIE) &&\n\t    (skb->truesize > MWIFIEX_RX_DATA_BUF_SIZE))\n\t\tskb->truesize += (skb->len - MWIFIEX_RX_DATA_BUF_SIZE);\n\n\tif (in_interrupt())\n\t\tnetif_rx(skb);\n\telse\n\t\tnetif_rx_ni(skb);\n\n\treturn 0;\n}", "item_id": 5, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/drivers/net/wireless/mwifiex/util.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "ec79c49de0975651a5e2cdebdd058fc312308537_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int mwifiex_recv_packet(struct mwifiex_private *priv, struct sk_buff *skb)\n{\n\tif (!skb)\n\t\treturn -1;\n\tpriv->stats.rx_bytes += skb->len;\n\tpriv->stats.rx_packets++;\n\tskb->dev = priv->netdev;\n\tskb->protocol = eth_type_trans(skb, priv->netdev);\n\tskb->ip_summed = CHECKSUM_NONE;\n\t/* This is required only in case of 11n and USB/PCIE as we alloc\n\t * a buffer of 4K only if its 11N (to be able to receive 4K\n\t * AMSDU packets). In case of SD we allocate buffers based\n\t * on the size of packet and hence this is not needed.\n\t *\n\t * Modifying the truesize here as our allocation for each\n\t * skb is 4K but we only receive 2K packets and this cause\n\t * the kernel to start dropping packets in case where\n\t * application has allocated buffer based on 2K size i.e.\n\t * if there a 64K packet received (in IP fragments and\n\t * application allocates 64K to receive this packet but\n\t * this packet would almost double up because we allocate\n\t * each 1.5K fragment in 4K and pass it up. As soon as the\n\t * 64K limit hits kernel will start to drop rest of the\n\t * fragments. Currently we fail the Filesndl-ht.scr script\n\t * for UDP, hence this fix\n\t */\n\tif ((priv->adapter->iface_type == MWIFIEX_USB ||\n\t     priv->adapter->iface_type == MWIFIEX_PCIE) &&\n\t    (skb->truesize > MWIFIEX_RX_DATA_BUF_SIZE))\n\t\tskb->truesize += (skb->len - MWIFIEX_RX_DATA_BUF_SIZE);\n\tif (in_interrupt())\n\t\tnetif_rx(skb);\n\telse\n\t\tnetif_rx_ni(skb);\n\treturn 0;\n"]], "pred": {"ppl": 3.6052372455596924, "ppl_lower": 4.042588710784912, "ppl/lowercase_ppl": -1.0892847684675004, "ppl/zlib": 0.0017447450050515712, "Min_5.0% Prob": 7.884368089529184, "Min_10.0% Prob": 6.345794164909507, "Min_20.0% Prob": 4.822370911544224, "Min_30.0% Prob": 3.869394838435095, "Min_40.0% Prob": 3.1375402555150806, "Min_50.0% Prob": 2.552350890199493, "Min_60.0% Prob": 2.1369707880827793}}
{"hexsha": "a8a2d773786fd4a6483dec56e197b93241634bdd", "ext": "c", "lang": "C", "content": "static FILE *checkouthistofile(char *filename, qfits_header **header, qfits_header **hheader)\n{\n  FILE *checkouthistofile;\n  int next;\n  int header_startpos;\n\n  /* First check if there is such a file and if it is a fits */\n  if (qfits_is_fits(filename) != 1) {\n    if (!(checkouthistofile = fopen(filename, \"w+\"))) {\n      return NULL;\n    }\n\n    /* The file cannot have a history header */\n    *hheader = NULL;\n\n    /* Make a default primary header */\n    if ((*header = qfits_header_default()) == NULL)\n      return NULL;\n    \n    qfits_header_add(*header,\"BITPIX\",\"32\",NULL,NULL);\n    qfits_header_add(*header,\"NAXIS\",\"2\",NULL,NULL);\n    qfits_header_add(*header,\"NAXIS1\",\"100\",NULL,NULL);\n    qfits_header_add(*header,\"NAXIS2\",\"1\",NULL,NULL);\n    qfits_header_add(*header,\"EXTEND\",\"T\",NULL,NULL);\n    \n    qfits_header_add(*header,\"BSCALE\",\"1\",NULL,NULL);\n    qfits_header_add(*header,\"BZERO\",\"0\",NULL,NULL);\n    qfits_header_add(*header,\"BUNIT\",\"'count'\",NULL,NULL);\n    qfits_header_add(*header,\"BTYPE\",\"' '\",NULL,NULL);\n    \n    qfits_header_add(*header,\"CDELT1\", \"0.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRPIX1\", \"1.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRVAL1\", \"0.0\",NULL,NULL);\n    qfits_header_add(*header,\"CTYPE1\", \"' '\",NULL,NULL);\n    qfits_header_add(*header,\"CUNIT1\", \"' '\",NULL,NULL);\n    \n    qfits_header_add(*header,\"CDELT2\", \"1.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRPIX2\", \"1.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRVAL2\", \"0.0\",NULL,NULL);\n    qfits_header_add(*header,\"CTYPE2\", \"' '\",NULL,NULL);\n    qfits_header_add(*header,\"CUNIT2\", \"'Y'\",NULL,NULL);\n\n    qfits_header_add(*header, \"TITLE1\", \"' '\", NULL, NULL);\n    qfits_header_add(*header, \"TITLE2\", \"' '\", NULL, NULL);\n    qfits_header_add(*header, \"RADIUS1\", \"0.0\", NULL, NULL);\n    qfits_header_add(*header, \"RADIUS2\", \"0.0\", NULL, NULL);\n    qfits_header_add(*header, \"HISTORY\", \"'Generated by ftstab'\", NULL, NULL);\n  }\n    \n  /* It is a fits file */\n  else {\n\n    /* Now check for the number of extensions */\n    *hheader = checkhheader(filename);\n\n    /* Get the number of extensions */\n    next = qfits_query_n_ext(filename);\n\n    /* Do a refresh immediately */\n    qfits_cache_purge();\n\n    if (*hheader)\n      /* Get the position to put the fileposition */\n      qfits_get_hdrinfo(filename, next, &header_startpos, NULL);\n\n    /* Try to open the file */\n    if (!(checkouthistofile = fopen(filename, \"r+\"))) {\n      return NULL;\n    }\n    /* Go to the right position and delete the rest */\n\n    if (*hheader) {\n      fseek(checkouthistofile, (long) header_startpos, SEEK_SET);\n      if(ftruncate(fileno(stream_), ftell(checkouthistofile)))\n\t;\n      clearerr(stream_);\n    }    \n    else\n      fseek(checkouthistofile, 0L, SEEK_END);\n\n    /* Now make a default extension header */\n    if ((*header = qfits_header_new()) == NULL)\n      return NULL;\n\n    qfits_header_append(*header,\"XTENSION\",\"'IMAGE             '\",\"\",\"\");\n    qfits_header_append(*header,\"END\",\"\",\"\",\"\");\n\n    qfits_header_add(*header,\"BITPIX\",\"32\",NULL,NULL);\n    qfits_header_add(*header,\"NAXIS\",\"2\",NULL,NULL);\n    qfits_header_add(*header,\"NAXIS1\",\"100\",NULL,NULL);\n    qfits_header_add(*header,\"NAXIS2\",\"1\",NULL,NULL);\n    qfits_header_add(*header,\"EXTEND\",\"T\",NULL,NULL);\n    \n    qfits_header_add(*header,\"BSCALE\",\"1\",NULL,NULL);\n    qfits_header_add(*header,\"BZERO\",\"0\",NULL,NULL);\n    qfits_header_add(*header,\"BUNIT\",\"'count'\",NULL,NULL);\n    qfits_header_add(*header,\"BTYPE\",\"' '\",NULL,NULL);\n    \n    qfits_header_add(*header,\"CDELT1\", \"0.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRPIX1\", \"1.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRVAL1\", \"0.0\",NULL,NULL);\n    qfits_header_add(*header,\"CTYPE1\", \"' '\",NULL,NULL);\n    qfits_header_add(*header,\"CUNIT1\", \"' '\",NULL,NULL);\n    \n    qfits_header_add(*header,\"CDELT2\", \"1.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRPIX2\", \"1.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRVAL2\", \"0.0\",NULL,NULL);\n    qfits_header_add(*header,\"CTYPE2\", \"' '\",NULL,NULL);\n    qfits_header_add(*header,\"CUNIT2\", \"'Y'\",NULL,NULL);\n\n    qfits_header_add(*header, \"TITLE1\", \"' '\", NULL, NULL);\n    qfits_header_add(*header, \"TITLE2\", \"' '\", NULL, NULL);\n    qfits_header_add(*header, \"RADIUS1\", \"0.0\", NULL, NULL);\n    qfits_header_add(*header, \"RADIUS2\", \"0.0\", NULL, NULL);\n    qfits_header_add(*header, \"HISTORY\", \"'generated by ftstab'\", NULL, NULL);\n  }\n\n  return checkouthistofile;\n}", "item_id": 60, "repo": "kernsuite-debian/tirific", "file": "src/ftstab.c", "last_update_at": "2018-01-04T08:22:01+00:00", "question_id": "a8a2d773786fd4a6483dec56e197b93241634bdd_60", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static FILE *checkouthistofile(char *filename, qfits_header **header, qfits_header **hheader)\n{\n  FILE *checkouthistofile;\n  int next;\n  int header_startpos;\n  /* First check if there is such a file and if it is a fits */\n  if (qfits_is_fits(filename) != 1) {\n    if (!(checkouthistofile = fopen(filename, \"w+\"))) {\n      return NULL;\n    }\n    /* The file cannot have a history header */\n    *hheader = NULL;\n    /* Make a default primary header */\n    if ((*header = qfits_header_default()) == NULL)\n      return NULL;\n    qfits_header_add(*header,\"BITPIX\",\"32\",NULL,NULL);\n    qfits_header_add(*header,\"NAXIS\",\"2\",NULL,NULL);\n    qfits_header_add(*header,\"NAXIS1\",\"100\",NULL,NULL);\n    qfits_header_add(*header,\"NAXIS2\",\"1\",NULL,NULL);\n    qfits_header_add(*header,\"EXTEND\",\"T\",NULL,NULL);\n    qfits_header_add(*header,\"BSCALE\",\"1\",NULL,NULL);\n    qfits_header_add(*header,\"BZERO\",\"0\",NULL,NULL);\n    qfits_header_add(*header,\"BUNIT\",\"'count'\",NULL,NULL);\n    qfits_header_add(*header,\"BTYPE\",\"' '\",NULL,NULL);\n    qfits_header_add(*header,\"CDELT1\", \"0.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRPIX1\", \"1.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRVAL1\", \"0.0\",NULL,NULL);\n    qfits_header_add(*header,\"CTYPE1\", \"' '\",NULL,NULL);\n    qfits_header_add(*header,\"CUNIT1\", \"' '\",NULL,NULL);\n    qfits_header_add(*header,\"CDELT2\", \"1.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRPIX2\", \"1.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRVAL2\", \"0.0\",NULL,NULL);\n    qfits_header_add(*header,\"CTYPE2\", \"' '\",NULL,NULL);\n    qfits_header_add(*header,\"CUNIT2\", \"'Y'\",NULL,NULL);\n    qfits_header_add(*header, \"TITLE1\", \"' '\", NULL, NULL);\n    qfits_header_add(*header, \"TITLE2\", \"' '\", NULL, NULL);\n    qfits_header_add(*header, \"RADIUS1\", \"0.0\", NULL, NULL);\n    qfits_header_add(*header, \"RADIUS2\", \"0.0\", NULL, NULL);\n    qfits_header_add(*header, \"HISTORY\", \"'Generated by ftstab'\", NULL, NULL);\n  }\n  /* It is a fits file */\n  else {\n    /* Now check for the number of extensions */\n    *hheader = checkhheader(filename);\n    /* Get the number of extensions */\n    next = qfits_query_n_ext(filename);\n    /* Do a refresh immediately */\n    qfits_cache_purge();\n    if (*hheader)\n      /* Get the position to put the fileposition */\n      qfits_get_hdrinfo(filename, next, &header_startpos, NULL);\n    /* Try to open the file */\n    if (!(checkouthistofile = fopen(filename, \"r+\"))) {\n      return NULL;\n    }\n    /* Go to the right position and delete the rest */\n    if (*hheader) {\n      fseek(checkouthistofile, (long) header_startpos, SEEK_SET);\n      if(ftruncate(fileno(stream_), ftell(checkouthistofile)))\n\t;\n      clearerr(stream_);\n    }    \n    else\n      fseek(checkouthistofile, 0L, SEEK_END);\n    /* Now make a default extension header */\n    if ((*header = qfits_header_new()) == NULL)\n      return NULL;\n    qfits_header_append(*header,\"XTENSION\",\"'IMAGE             '\",\"\",\"\");\n    qfits_header_append(*header,\"END\",\"\",\"\",\"\");\n    qfits_header_add(*header,\"BITPIX\",\"32\",NULL,NULL);\n    qfits_header_add(*header,\"NAXIS\",\"2\",NULL,NULL);\n    qfits_header_add(*header,\"NAXIS1\",\"100\",NULL,NULL);\n    qfits_header_add(*header,\"NAXIS2\",\"1\",NULL,NULL);\n    qfits_header_add(*header,\"EXTEND\",\"T\",NULL,NULL);\n    qfits_header_add(*header,\"BSCALE\",\"1\",NULL,NULL);\n    qfits_header_add(*header,\"BZERO\",\"0\",NULL,NULL);\n    qfits_header_add(*header,\"BUNIT\",\"'count'\",NULL,NULL);\n    qfits_header_add(*header,\"BTYPE\",\"' '\",NULL,NULL);\n    qfits_header_add(*header,\"CDELT1\", \"0.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRPIX1\", \"1.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRVAL1\", \"0.0\",NULL,NULL);\n    qfits_header_add(*header,\"CTYPE1\", \"' '\",NULL,NULL);\n    qfits_header_add(*header,\"CUNIT1\", \"' '\",NULL,NULL);\n    qfits_header_add(*header,\"CDELT2\", \"1.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRPIX2\", \"1.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRVAL2\", \"0.0\",NULL,NULL);\n    qfits_header_add(*header,\"CTYPE2\", \"' '\",NULL,NULL);\n    qfits_header_add(*header,\"CUNIT2\", \"'Y'\",NULL,NULL);\n    qfits_header_add(*header, \"TITLE1\", \"' '\", NULL, NULL);\n    qfits_header_add(*header, \"TITLE2\", \"' '\", NULL, NULL);\n    qfits_header_add(*header, \"RADIUS1\", \"0.0\", NULL, NULL);\n    qfits_header_add(*header, \"RADIUS2\", \"0.0\", NULL, NULL);\n    qfits_header_add(*header, \"HISTORY\", \"'generated by ftstab'\", NULL, NULL);\n  }\n  return checkouthistofile;\n"]], "pred": {"ppl": 1.9218555688858032, "ppl_lower": 2.0776262283325195, "ppl/lowercase_ppl": -1.119295727177405, "ppl/zlib": 0.0007500472577074516, "Min_5.0% Prob": 6.296649876762839, "Min_10.0% Prob": 4.698616422858893, "Min_20.0% Prob": 2.9916377654846977, "Min_30.0% Prob": 2.137906845245096, "Min_40.0% Prob": 1.6255614877858342, "Min_50.0% Prob": 1.3060128802575768, "Min_60.0% Prob": 1.0898648142323906}}
{"hexsha": "511fa8678134602823885597f2bcfcfc044108a3", "ext": "c", "lang": "C", "content": "int16_t retrieveGpsMsg(uint16_t      numBytes,\n\t\t\t\t\t   GpsData_t *GPSData,\n\t\t\t\t\t   uint8_t       *outBuffer)\n{\n\tBOOL status = 0;\n\tstatus = COM_buf_get(&(gGpsUartPtr->rec_buf),\n                         outBuffer,\n                         numBytes);\n\tif (status == 0)\n\t\treturn 0; // bad [0]\n\telse // return number of bytes left\n\t\treturn gGpsUartPtr->rec_buf.bytes_in_buffer;\n}", "item_id": 7, "repo": "Erensu/openimu-core", "file": "GPS/src/driverGPS.c", "last_update_at": "2018-09-08T12:28:17+00:00", "question_id": "511fa8678134602823885597f2bcfcfc044108a3_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int16_t retrieveGpsMsg(uint16_t      numBytes,\n\t\t\t\t\t   GpsData_t *GPSData,\n\t\t\t\t\t   uint8_t       *outBuffer)\n{\n\tBOOL status = 0;\n\tstatus = COM_buf_get(&(gGpsUartPtr->rec_buf),\n                         outBuffer,\n                         numBytes);\n\tif (status == 0)\n\t\treturn 0; // bad [0]\n\telse // return number of bytes left\n\t\treturn gGpsUartPtr->rec_buf.bytes_in_buffer;\n"]], "pred": {"ppl": 5.3489089012146, "ppl_lower": 5.407527923583984, "ppl/lowercase_ppl": -1.006499787945126, "ppl/zlib": 0.00783594671219797, "Min_5.0% Prob": 9.460745402744838, "Min_10.0% Prob": 7.727660145078387, "Min_20.0% Prob": 5.787847436707596, "Min_30.0% Prob": 4.68393903428858, "Min_40.0% Prob": 3.8493557501647433, "Min_50.0% Prob": 3.2399396622503125, "Min_60.0% Prob": 2.7610934323139404}}
{"hexsha": "683ed81ef02eb19dd9facc2d4a0a203fecfa854a", "ext": "c", "lang": "C", "content": "static int\ntdfx_attach(device_t dev) { \n\t/*\n\t * The attach routine is called after the probe routine successfully says it\n\t * supports a given card. We now proceed to initialize this card for use with\n\t * the system. I want to map the device memory for userland allocation and\n\t * fill an information structure with information on this card. I'd also like\n\t * to set Write Combining with the MTRR code so that we can hopefully speed\n\t * up memory writes. The last thing is to register the character device\n\t * interface to the card, so we can open it from /dev/3dfxN, where N is a\n\t * small, whole number.\n\t */\n\tstruct tdfx_softc *tdfx_info;\n\t/* rid value tells bus_alloc_resource where to find the addresses of ports or\n\t * of memory ranges in the PCI config space*/\n\tint rid = PCIR_BAR(0);\n\n\t/* Increment the card counter (for the ioctl code) */\n\ttdfx_count++;\n\n\t/* Fill the soft config struct with info about this device*/\n\ttdfx_info = device_get_softc(dev);\n\ttdfx_info->dev = dev;\n\ttdfx_info->vendor = pci_get_vendor(dev);\n\ttdfx_info->type = pci_get_devid(dev) >> 16;\n\ttdfx_info->bus = pci_get_bus(dev);\n\ttdfx_info->dv = pci_get_slot(dev);\n\ttdfx_info->curFile = NULL;\n\n\t/* \n\t *\tGet the Memory Location from the PCI Config, mask out lower word, since\n\t * the config space register is only one word long (this is nicer than a\n\t * bitshift).\n\t */\n\ttdfx_info->addr0 = (pci_read_config(dev, 0x10, 4) & 0xffff0000);\n#ifdef DEBUG\n\tdevice_printf(dev, \"Base0 @ 0x%x\\n\", tdfx_info->addr0);\n#endif\n\t/* Notify the VM that we will be mapping some memory later */\n\ttdfx_info->memrange = bus_alloc_resource_any(dev, SYS_RES_MEMORY,\n\t\t&rid, RF_ACTIVE | RF_SHAREABLE);\n\tif(tdfx_info->memrange == NULL) {\n#ifdef DEBUG\n\t\tdevice_printf(dev, \"Error mapping mem, won't be able to use mmap()\\n\");\n#endif\n\t\ttdfx_info->memrid = 0;\n\t}\n\telse {\n\t\ttdfx_info->memrid = rid;\n#ifdef DEBUG\n\t\tdevice_printf(dev, \"Mapped to: 0x%x\\n\", \n\t\t\t\t(unsigned int)rman_get_start(tdfx_info->memrange));\n#endif\n\t}\n\n\t/* Setup for Voodoo3 and Banshee, PIO and an extram Memrange */\n\tif(pci_get_devid(dev) == PCI_DEVICE_3DFX_VOODOO3 ||\n\t\tpci_get_devid(dev) == PCI_DEVICE_3DFX_BANSHEE) {\n\t\trid = 0x14;\t/* 2nd mem map */\n\t\ttdfx_info->addr1 = (pci_read_config(dev, 0x14, 4) & 0xffff0000);\n#ifdef DEBUG\n\t\tdevice_printf(dev, \"Base1 @ 0x%x\\n\", tdfx_info->addr1);\n#endif\n\t\ttdfx_info->memrange2 = bus_alloc_resource_any(dev,\n\t\t\tSYS_RES_MEMORY, &rid, RF_ACTIVE | RF_SHAREABLE);\n\t\tif(tdfx_info->memrange2 == NULL) {\n#ifdef DEBUG\n\t\t\tdevice_printf(dev, \"Mem1 couldn't be allocated, glide may not work.\");\n#endif\n\t\t\ttdfx_info->memrid2 = 0;\n\t\t}\n\t\telse {\n\t\t\ttdfx_info->memrid2 = rid;\n\t\t}\n\t\t/* Now to map the PIO stuff */\n\t\trid = PCIR_IOBASE0_2;\n\t\ttdfx_info->pio0 = pci_read_config(dev, 0x2c, 2);\n\t\ttdfx_info->pio0max = pci_read_config(dev, 0x30, 2) + tdfx_info->pio0;\n\t\ttdfx_info->piorange = bus_alloc_resource_any(dev,\n\t\t\tSYS_RES_IOPORT, &rid, RF_ACTIVE | RF_SHAREABLE);\n\t\tif(tdfx_info->piorange == NULL) {\n#ifdef DEBUG\n\t\t\tdevice_printf(dev, \"Couldn't map PIO range.\");\n#endif\n\t\t\ttdfx_info->piorid = 0;\n\t\t}\n\t\telse {\n\t\t\ttdfx_info->piorid = rid;\n\t\t}\n\t} else {\n\t  tdfx_info->addr1 = 0;\n\t  tdfx_info->memrange2 = NULL;\n\t  tdfx_info->piorange = NULL;\n\t}\n\n\t/* \n\t *\tSet Writecombining, or at least Uncacheable for the memory region, if we\n\t * are able to\n\t */\n\n\tif(tdfx_setmtrr(dev) != 0) {\n#ifdef DEBUG\n\t\tdevice_printf(dev, \"Some weird error setting MTRRs\");\n#endif\n\t\treturn -1;\n\t}\n\n\t/* \n\t * make_dev registers the cdev to access the 3dfx card from /dev\n\t *\tuse hex here for the dev num, simply to provide better support if > 10\n\t * voodoo cards, for the mad. The user must set the link.\n\t * Why would we want that many voodoo cards anyhow? \n\t */\n\ttdfx_info->devt = make_dev(&tdfx_cdev, device_get_unit(dev),\n\t\tUID_ROOT, GID_WHEEL, 0600, \"3dfx%x\", device_get_unit(dev));\n\ttdfx_info->devt->si_drv1 = tdfx_info;\n\t\n\treturn 0;\n}", "item_id": 1, "repo": "dcui/FreeBSD-9.3_kernel", "file": "sys/dev/tdfx/tdfx_pci.c", "last_update_at": "2018-01-11T01:01:38+00:00", "question_id": "683ed81ef02eb19dd9facc2d4a0a203fecfa854a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\ntdfx_attach(device_t dev) { \n\t/*\n\t * The attach routine is called after the probe routine successfully says it\n\t * supports a given card. We now proceed to initialize this card for use with\n\t * the system. I want to map the device memory for userland allocation and\n\t * fill an information structure with information on this card. I'd also like\n\t * to set Write Combining with the MTRR code so that we can hopefully speed\n\t * up memory writes. The last thing is to register the character device\n\t * interface to the card, so we can open it from /dev/3dfxN, where N is a\n\t * small, whole number.\n\t */\n\tstruct tdfx_softc *tdfx_info;\n\t/* rid value tells bus_alloc_resource where to find the addresses of ports or\n\t * of memory ranges in the PCI config space*/\n\tint rid = PCIR_BAR(0);\n\t/* Increment the card counter (for the ioctl code) */\n\ttdfx_count++;\n\t/* Fill the soft config struct with info about this device*/\n\ttdfx_info = device_get_softc(dev);\n\ttdfx_info->dev = dev;\n\ttdfx_info->vendor = pci_get_vendor(dev);\n\ttdfx_info->type = pci_get_devid(dev) >> 16;\n\ttdfx_info->bus = pci_get_bus(dev);\n\ttdfx_info->dv = pci_get_slot(dev);\n\ttdfx_info->curFile = NULL;\n\t/* \n\t *\tGet the Memory Location from the PCI Config, mask out lower word, since\n\t * the config space register is only one word long (this is nicer than a\n\t * bitshift).\n\t */\n\ttdfx_info->addr0 = (pci_read_config(dev, 0x10, 4) & 0xffff0000);\n#ifdef DEBUG\n\tdevice_printf(dev, \"Base0 @ 0x%x\\n\", tdfx_info->addr0);\n#endif\n\t/* Notify the VM that we will be mapping some memory later */\n\ttdfx_info->memrange = bus_alloc_resource_any(dev, SYS_RES_MEMORY,\n\t\t&rid, RF_ACTIVE | RF_SHAREABLE);\n\tif(tdfx_info->memrange == NULL) {\n#ifdef DEBUG\n\t\tdevice_printf(dev, \"Error mapping mem, won't be able to use mmap()\\n\");\n#endif\n\t\ttdfx_info->memrid = 0;\n\t}\n\telse {\n\t\ttdfx_info->memrid = rid;\n#ifdef DEBUG\n\t\tdevice_printf(dev, \"Mapped to: 0x%x\\n\", \n\t\t\t\t(unsigned int)rman_get_start(tdfx_info->memrange));\n#endif\n\t}\n\t/* Setup for Voodoo3 and Banshee, PIO and an extram Memrange */\n\tif(pci_get_devid(dev) == PCI_DEVICE_3DFX_VOODOO3 ||\n\t\tpci_get_devid(dev) == PCI_DEVICE_3DFX_BANSHEE) {\n\t\trid = 0x14;\t/* 2nd mem map */\n\t\ttdfx_info->addr1 = (pci_read_config(dev, 0x14, 4) & 0xffff0000);\n#ifdef DEBUG\n\t\tdevice_printf(dev, \"Base1 @ 0x%x\\n\", tdfx_info->addr1);\n#endif\n\t\ttdfx_info->memrange2 = bus_alloc_resource_any(dev,\n\t\t\tSYS_RES_MEMORY, &rid, RF_ACTIVE | RF_SHAREABLE);\n\t\tif(tdfx_info->memrange2 == NULL) {\n#ifdef DEBUG\n\t\t\tdevice_printf(dev, \"Mem1 couldn't be allocated, glide may not work.\");\n#endif\n\t\t\ttdfx_info->memrid2 = 0;\n\t\t}\n\t\telse {\n\t\t\ttdfx_info->memrid2 = rid;\n\t\t}\n\t\t/* Now to map the PIO stuff */\n\t\trid = PCIR_IOBASE0_2;\n\t\ttdfx_info->pio0 = pci_read_config(dev, 0x2c, 2);\n\t\ttdfx_info->pio0max = pci_read_config(dev, 0x30, 2) + tdfx_info->pio0;\n\t\ttdfx_info->piorange = bus_alloc_resource_any(dev,\n\t\t\tSYS_RES_IOPORT, &rid, RF_ACTIVE | RF_SHAREABLE);\n\t\tif(tdfx_info->piorange == NULL) {\n#ifdef DEBUG\n\t\t\tdevice_printf(dev, \"Couldn't map PIO range.\");\n#endif\n\t\t\ttdfx_info->piorid = 0;\n\t\t}\n\t\telse {\n\t\t\ttdfx_info->piorid = rid;\n\t\t}\n\t} else {\n\t  tdfx_info->addr1 = 0;\n\t  tdfx_info->memrange2 = NULL;\n\t  tdfx_info->piorange = NULL;\n\t}\n\t/* \n\t *\tSet Writecombining, or at least Uncacheable for the memory region, if we\n\t * are able to\n\t */\n\tif(tdfx_setmtrr(dev) != 0) {\n#ifdef DEBUG\n\t\tdevice_printf(dev, \"Some weird error setting MTRRs\");\n#endif\n\t\treturn -1;\n\t}\n\t/* \n\t * make_dev registers the cdev to access the 3dfx card from /dev\n\t *\tuse hex here for the dev num, simply to provide better support if > 10\n\t * voodoo cards, for the mad. The user must set the link.\n\t * Why would we want that many voodoo cards anyhow? \n\t */\n\ttdfx_info->devt = make_dev(&tdfx_cdev, device_get_unit(dev),\n\t\tUID_ROOT, GID_WHEEL, 0600, \"3dfx%x\", device_get_unit(dev));\n\ttdfx_info->devt->si_drv1 = tdfx_info;\n\t\n\treturn 0;\n"]], "pred": {"ppl": 2.95509934425354, "ppl_lower": 3.147578001022339, "ppl/lowercase_ppl": -1.058236382047151, "ppl/zlib": 0.0006897086373836317, "Min_5.0% Prob": 7.831150494369806, "Min_10.0% Prob": 6.265595426746443, "Min_20.0% Prob": 4.549663525586035, "Min_30.0% Prob": 3.4348254799842834, "Min_40.0% Prob": 2.672429885396456, "Min_50.0% Prob": 2.1608758991011903, "Min_60.0% Prob": 1.8062461151469493}}
{"hexsha": "68a020c11880688c831a48272884224ca8c5205e", "ext": "h", "lang": "C", "content": "class Date {\n\tprivate:\n\t\tuint_fast16_t _year;\n\t\tuint_fast16_t _day;\n\t\tuint_fast16_t _month;\n\tpublic:\n\t\tDate() = default;\n\n\t\t/**\n\t\t * create date based on day, month, year\n\t\t * @param year\n\t\t * @param day\n\t\t * @param month\n\t\t */\n\t\tDate(uint_fast16_t year, uint_fast16_t day, uint_fast16_t month) {\n\t\t\tif (isValidDate(year, day, month)) {\n\t\t\t\t_year = year ;\n\t\t\t\t_day = day;\n\t\t\t\t_month = month;\n\t\t\t}", "item_id": 0, "repo": "smartcalapp/SmartCal-CalDav", "file": "src/calender/Date.h", "last_update_at": "2018-09-11T03:41:02+00:00", "question_id": "68a020c11880688c831a48272884224ca8c5205e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Date {\n\tprivate:\n\t\tuint_fast16_t _year;\n\t\tuint_fast16_t _day;\n\t\tuint_fast16_t _month;\n\tpublic:\n\t\tDate() = default;\n\t\t/**\n\t\t * create date based on day, month, year\n\t\t * @param year\n\t\t * @param day\n\t\t * @param month\n\t\t */\n\t\tDate(uint_fast16_t year, uint_fast16_t day, uint_fast16_t month) {\n\t\t\tif (isValidDate(year, day, month)) {\n\t\t\t\t_year = year ;\n\t\t\t\t_day = day;\n\t\t\t\t_month = month;\n"]], "pred": {"ppl": 1.8005412817001343, "ppl_lower": 1.8609918355941772, "ppl/lowercase_ppl": -1.056151964185798, "ppl/zlib": 0.002940436658764706, "Min_5.0% Prob": 6.08043114344279, "Min_10.0% Prob": 4.387917862998115, "Min_20.0% Prob": 2.7340736018644796, "Min_30.0% Prob": 1.948780127547004, "Min_40.0% Prob": 1.469811168272753, "Min_50.0% Prob": 1.1738720680737207, "Min_60.0% Prob": 0.9846799203639364}}
{"hexsha": "95ec526571ef8fe7db6e3d4a8d5459965cc668eb", "ext": "h", "lang": "C", "content": "static inline void hri_nvmctrl_clear_NONSEC_WRITE_bit(const void *const hw)\n{\n\tNVMCTRL_CRITICAL_SECTION_ENTER();\n\t((Nvmctrl *)hw)->NONSEC.reg &= ~NVMCTRL_NONSEC_WRITE_Msk;\n\tNVMCTRL_CRITICAL_SECTION_LEAVE();\n}", "item_id": 223, "repo": "cazure/rt-thread", "file": "bsp/microchip/saml10/bsp/hri/hri_nvmctrl_l10.h", "last_update_at": "2018-11-27T02:48:44+00:00", "question_id": "95ec526571ef8fe7db6e3d4a8d5459965cc668eb_223", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void hri_nvmctrl_clear_NONSEC_WRITE_bit(const void *const hw)\n{\n\tNVMCTRL_CRITICAL_SECTION_ENTER();\n\t((Nvmctrl *)hw)->NONSEC.reg &= ~NVMCTRL_NONSEC_WRITE_Msk;\n\tNVMCTRL_CRITICAL_SECTION_LEAVE();\n"]], "pred": {"ppl": 1.763134241104126, "ppl_lower": 3.763688087463379, "ppl/lowercase_ppl": -2.3371814639892143, "ppl/zlib": 0.0036824223641649966, "Min_5.0% Prob": 7.380046463012695, "Min_10.0% Prob": 4.9954792022705075, "Min_20.0% Prob": 2.841662219539285, "Min_30.0% Prob": 1.9082571250696978, "Min_40.0% Prob": 1.4317369938158664, "Min_50.0% Prob": 1.1454866625915747, "Min_60.0% Prob": 0.954598720685802}}
{"hexsha": "0f194c9edfcff7cfcda3a35e7c16f20a562fd35a", "ext": "c", "lang": "C", "content": "static void\nlogMaterialf (GLenum  face,\n\t      GLenum  pname,\n\t      GLfloat param)\n{\n    vCnt[materialfIndex].n++;\n    if (logVertexAttribs)\n\tfprintf (logFp, \"glMaterialf (0x%x, 0x%x, %f)\\n\", face, pname, param);\n    (*nativeRenderTable->Materialf) (face, pname, param);\n}", "item_id": 32, "repo": "larsclausen/xglamo", "file": "hw/xgl/glxext/xglglxlog.c", "last_update_at": "2018-11-01T06:58:35+00:00", "question_id": "0f194c9edfcff7cfcda3a35e7c16f20a562fd35a_32", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nlogMaterialf (GLenum  face,\n\t      GLenum  pname,\n\t      GLfloat param)\n{\n    vCnt[materialfIndex].n++;\n    if (logVertexAttribs)\n\tfprintf (logFp, \"glMaterialf (0x%x, 0x%x, %f)\\n\", face, pname, param);\n    (*nativeRenderTable->Materialf) (face, pname, param);\n"]], "pred": {"ppl": 4.237717628479004, "ppl_lower": 5.80347204208374, "ppl/lowercase_ppl": -1.2177466279701739, "ppl/zlib": 0.007934202357917372, "Min_5.0% Prob": 8.804606723785401, "Min_10.0% Prob": 7.625835752487182, "Min_20.0% Prob": 5.603748491832188, "Min_30.0% Prob": 4.3166616559028625, "Min_40.0% Prob": 3.477214308672173, "Min_50.0% Prob": 2.884549553471583, "Min_60.0% Prob": 2.417459108795111}}
{"hexsha": "5963ac12be07e41ca5ebe0ea8de94b8e2f55f0eb", "ext": "c", "lang": "C", "content": "eye_buf_t *eye_create_buf(eye_pool_t *pool, size_t size)\n{\n\teye_buf_t *b;\n\n\tb = eye_calloc_buf(pool);\n\tif (b == NULL) {\n\t\treturn NULL;\n\t}\n\n\tb->start = eye_palloc(pool, size);\n\tif (b->start == NULL) {\n\t\treturn NULL;\n\t}\n\n\tb->pos = b->start;\n\tb->last = b->start;\n\tb->end = b->last+size;\n\n\treturn b;\n}", "item_id": 0, "repo": "eaglc/eyenet", "file": "src/core/eye_buf.c", "last_update_at": "2018-11-12T07:03:41+00:00", "question_id": "5963ac12be07e41ca5ebe0ea8de94b8e2f55f0eb_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["eye_buf_t *eye_create_buf(eye_pool_t *pool, size_t size)\n{\n\teye_buf_t *b;\n\tb = eye_calloc_buf(pool);\n\tif (b == NULL) {\n\t\treturn NULL;\n\t}\n\tb->start = eye_palloc(pool, size);\n\tif (b->start == NULL) {\n\t\treturn NULL;\n\t}\n\tb->pos = b->start;\n\tb->last = b->start;\n\tb->end = b->last+size;\n\treturn b;\n"]], "pred": {"ppl": 1.9613617658615112, "ppl_lower": 2.153122901916504, "ppl/lowercase_ppl": -1.138472221520951, "ppl/zlib": 0.004184093232896584, "Min_5.0% Prob": 8.474519865853447, "Min_10.0% Prob": 5.629603709493365, "Min_20.0% Prob": 3.2238675664211143, "Min_30.0% Prob": 2.229059973562306, "Min_40.0% Prob": 1.6891585137000529, "Min_50.0% Prob": 1.352833404306423, "Min_60.0% Prob": 1.126441932780396}}
{"hexsha": "9b7d5cea8f348e7e27b709472eae0851e70d7836", "ext": "c", "lang": "C", "content": "__interrupt void USER2_ISR(void)     // User Defined trap 2\n{\r\n  // Insert ISR Code here\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n\r\n}", "item_id": 8, "repo": "equinoxorg/Micro-Hydro-ELC", "file": "Controller_Software/Kingfisher_ELC_Workspace/KP_Controller_1/src/Interrupt_SR.c", "last_update_at": "2018-02-06T22:35:38+00:00", "question_id": "9b7d5cea8f348e7e27b709472eae0851e70d7836_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["__interrupt void USER2_ISR(void)     // User Defined trap 2\n{\r\n  // Insert ISR Code here\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n\r\n"]], "pred": {"ppl": 4.093746185302734, "ppl_lower": 6.937338352203369, "ppl/lowercase_ppl": -1.3742266590159509, "ppl/zlib": 0.00791831735149744, "Min_5.0% Prob": 9.720274448394775, "Min_10.0% Prob": 7.766189234597342, "Min_20.0% Prob": 5.52769316037496, "Min_30.0% Prob": 4.273171430048735, "Min_40.0% Prob": 3.4421417790074504, "Min_50.0% Prob": 2.8144988062290044, "Min_60.0% Prob": 2.3622032407116382}}
{"hexsha": "306725ca1144ce776c63feadc8986fa57c557276", "ext": "c", "lang": "C", "content": "void\tq8gr_draw_frame(int x, int y, int sx, int sy, int shadow_type,\n\t\t\tint code, const char *str, void *p)\n{\n    int fg = (p) ? Q8GR_PALETTE_FOREGROUND : Q8GR_PALETTE_WHITE;\n    int bg =       Q8GR_PALETTE_BACKGROUND;\n\n    draw_normal_box(x, y, sx, sy, shadow_type);\n\n    q8gr_puts(x+1, y, fg, bg, code, str);\n}", "item_id": 7, "repo": "yksoft1/QUASI88", "file": "src/q8tk-glib.c", "last_update_at": "2018-09-16T23:47:02+00:00", "question_id": "306725ca1144ce776c63feadc8986fa57c557276_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\tq8gr_draw_frame(int x, int y, int sx, int sy, int shadow_type,\n\t\t\tint code, const char *str, void *p)\n{\n    int fg = (p) ? Q8GR_PALETTE_FOREGROUND : Q8GR_PALETTE_WHITE;\n    int bg =       Q8GR_PALETTE_BACKGROUND;\n    draw_normal_box(x, y, sx, sy, shadow_type);\n    q8gr_puts(x+1, y, fg, bg, code, str);\n"]], "pred": {"ppl": 3.8960087299346924, "ppl_lower": 4.476028919219971, "ppl/lowercase_ppl": -1.1020503377495072, "ppl/zlib": 0.006475964888194139, "Min_5.0% Prob": 8.938013621738978, "Min_10.0% Prob": 7.04074764251709, "Min_20.0% Prob": 5.284773111343384, "Min_30.0% Prob": 4.128766714202033, "Min_40.0% Prob": 3.294407402475675, "Min_50.0% Prob": 2.674649009971242, "Min_60.0% Prob": 2.2588115980500705}}
{"hexsha": "9e065a312285ddb6f354910d5188debfec215410", "ext": "c", "lang": "C", "content": "uint64_t\nar5416GetTsf64(struct ath_hal *ah)\n{\n\tuint32_t low1, low2, u32;\n\n\t/* sync multi-word read */\n\tlow1 = OS_REG_READ(ah, AR_TSF_L32);\n\tu32 = OS_REG_READ(ah, AR_TSF_U32);\n\tlow2 = OS_REG_READ(ah, AR_TSF_L32);\n\tif (low2 < low1) {\t/* roll over */\n\t\t/*\n\t\t * If we are not preempted this will work.  If we are\n\t\t * then we re-reading AR_TSF_U32 does no good as the\n\t\t * low bits will be meaningless.  Likewise reading\n\t\t * L32, U32, U32, then comparing the last two reads\n\t\t * to check for rollover doesn't help if preempted--so\n\t\t * we take this approach as it costs one less PCI read\n\t\t * which can be noticeable when doing things like\n\t\t * timestamping packets in monitor mode.\n\t\t */\n\t\tu32++;\n\t}\n\treturn (((uint64_t) u32) << 32) | ((uint64_t) low2);\n}", "item_id": 2, "repo": "dcui/FreeBSD-9.3_kernel", "file": "sys/dev/ath/ath_hal/ar5416/ar5416_misc.c", "last_update_at": "2018-01-11T01:01:38+00:00", "question_id": "9e065a312285ddb6f354910d5188debfec215410_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["uint64_t\nar5416GetTsf64(struct ath_hal *ah)\n{\n\tuint32_t low1, low2, u32;\n\t/* sync multi-word read */\n\tlow1 = OS_REG_READ(ah, AR_TSF_L32);\n\tu32 = OS_REG_READ(ah, AR_TSF_U32);\n\tlow2 = OS_REG_READ(ah, AR_TSF_L32);\n\tif (low2 < low1) {\t/* roll over */\n\t\t/*\n\t\t * If we are not preempted this will work.  If we are\n\t\t * then we re-reading AR_TSF_U32 does no good as the\n\t\t * low bits will be meaningless.  Likewise reading\n\t\t * L32, U32, U32, then comparing the last two reads\n\t\t * to check for rollover doesn't help if preempted--so\n\t\t * we take this approach as it costs one less PCI read\n\t\t * which can be noticeable when doing things like\n\t\t * timestamping packets in monitor mode.\n\t\t */\n\t\tu32++;\n\t}\n\treturn (((uint64_t) u32) << 32) | ((uint64_t) low2);\n"]], "pred": {"ppl": 2.8522415161132812, "ppl_lower": 3.1548125743865967, "ppl/lowercase_ppl": -1.0961963627517537, "ppl/zlib": 0.002387483330377708, "Min_5.0% Prob": 7.342138022184372, "Min_10.0% Prob": 5.90298768132925, "Min_20.0% Prob": 4.218698996763963, "Min_30.0% Prob": 3.2543698131423637, "Min_40.0% Prob": 2.5717318502756266, "Min_50.0% Prob": 2.094144401404961, "Min_60.0% Prob": 1.7453878697055654}}
{"hexsha": "509b1de5ef7b6fc73ea40b96701359f0e02f739c", "ext": "c", "lang": "C", "content": "bool uart_hal_is_receiver_enabled(uint32_t uartInstance)\n{\n    assert(uartInstance < UART_INSTANCE_COUNT);\n\n    /* get the receiver config based on the uart instance*/\n#if FSL_FEATURE_UART_HAS_LOW_POWER_UART_SUPPORT\n    if (uartInstance == 0)\n    {\n        return HW_UART0_C2.B.RE;\n    }\n    else\n#endif\n    {\n        return HW_UART_C2(uartInstance).B.RE;\n    }\n}", "item_id": 13, "repo": "mjrgh/mbed", "file": "libraries/mbed/targets/hal/TARGET_Freescale/TARGET_KPSDK_MCUS/TARGET_KPSDK_CODE/hal/uart/fsl_uart_hal_common_configurations.c", "last_update_at": "2018-11-22T02:59:15+00:00", "question_id": "509b1de5ef7b6fc73ea40b96701359f0e02f739c_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool uart_hal_is_receiver_enabled(uint32_t uartInstance)\n{\n    assert(uartInstance < UART_INSTANCE_COUNT);\n    /* get the receiver config based on the uart instance*/\n#if FSL_FEATURE_UART_HAS_LOW_POWER_UART_SUPPORT\n    if (uartInstance == 0)\n    {\n        return HW_UART0_C2.B.RE;\n    }\n    else\n#endif\n    {\n        return HW_UART_C2(uartInstance).B.RE;\n    }\n"]], "pred": {"ppl": 2.3571276664733887, "ppl_lower": 3.3752424716949463, "ppl/lowercase_ppl": -1.4187136034116892, "ppl/zlib": 0.0037442960144280103, "Min_5.0% Prob": 7.197589669908796, "Min_10.0% Prob": 5.658675161997477, "Min_20.0% Prob": 3.865700089931488, "Min_30.0% Prob": 2.779404193825192, "Min_40.0% Prob": 2.136922173574567, "Min_50.0% Prob": 1.7207036137580871, "Min_60.0% Prob": 1.4373440685475039}}
{"hexsha": "2d26a2ba67bffbc0a509d7c2b62c5bf14fbc2606", "ext": "c", "lang": "C", "content": "static void cb_server_recv_after(void *handle_, int sid_, char* in_, size_t ilen_)\r\n{\r\n\t// sis_out_binary(\"recv\", in_, ilen_);\r\n\r\n\ts_sis_net_class *cls = (s_sis_net_class *)handle_;\r\n\ts_sis_net_context *cxt = sis_map_kint_get(cls->cxts, sid_);\r\n\tif (!cxt || cxt->status == SIS_NET_DISCONNECT)\r\n\t{\r\n\t\treturn ;\r\n\t}\r\n\tif (cxt->status == SIS_NET_WORKING)\r\n\t{\r\n\t\t//QQQ \u5982\u4f55\u5904\u7406\u5206\u5305\u7684\u95ee\u9898\uff1f\r\n\t\tsis_net_mems_push(cxt->recv_nodes, in_, ilen_);\r\n\t\t// \u53d1\u9001\u901a\u77e5\r\n\t\t// sis_wait_thread_notice(cls->read_thread);\r\n\t}\r\n\telse if (cxt->status == SIS_NET_HANDING)\r\n\t{\r\n\t\tsis_memory_cat(cxt->recv_memory, in_, ilen_);\r\n\t\tint o = sis_ws_recv_hand_ask(cls, cxt);\r\n\t\tif (o == 1) // \u6536\u5230\u6b63\u786e\u7684\u63e1\u624b\u4fe1\u606f\r\n\t\t{\r\n\t\t\tLOG(8)(\"server hand ok. [%d]\\n\", sid_);\r\n\t\t\t// \u8fd9\u91cc\u53d1\u9001\u767b\u5f55\u4fe1\u606f \r\n\t\t\tif (cls->cb_connected)\r\n\t\t\t{\r\n\t\t\t\tcls->cb_connected(cls->cb_source, sid_);\r\n\t\t\t}\t\r\n\t\t\t// \u8bbe\u7f6e\u5de5\u4f5c\u72b6\u6001\t\t\r\n\t\t\tcxt->status = SIS_NET_WORKING;\r\n\t\t\t// \u5982\u679c\u63e1\u624b\u5305\u540e\u6709\u6570\u636e\u5c31\u76f4\u63a5\u901a\u77e5\u5904\u7406\r\n\t\t\tif (sis_memory_get_size(cxt->recv_memory) > 0)\r\n\t\t\t{\r\n\t\t\t\tsis_wait_thread_notice(cls->read_thread);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (o != 0) // \u6536\u5230\u9519\u8bef\u7684\u63e1\u624b\u4fe1\u606f\r\n\t\t{\r\n\t\t\t// \u5982\u679c\u8fd4\u56de<\u96f6 \u5c31\u8bf4\u660e\u6570\u636e\u51fa\u9519\r\n\t\t\t// sis_net_class_close_cxt(cls, sid_);\r\n\t\t\tcxt->status = SIS_NET_DISCONNECT;\r\n\t\t} // == 0 \u8fd8\u6ca1\u6709\u6536\u5230\u6570\u636e\t\t\r\n\t}\r\n}", "item_id": 13, "repo": "coco0O0O/sisdb", "file": "src/core/net/sis_net.c", "last_update_at": "2018-05-26T14:51:54+00:00", "question_id": "2d26a2ba67bffbc0a509d7c2b62c5bf14fbc2606_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void cb_server_recv_after(void *handle_, int sid_, char* in_, size_t ilen_)\r\n{\r\n\t// sis_out_binary(\"recv\", in_, ilen_);\r\n\r\n\ts_sis_net_class *cls = (s_sis_net_class *)handle_;\r\n\ts_sis_net_context *cxt = sis_map_kint_get(cls->cxts, sid_);\r\n\tif (!cxt || cxt->status == SIS_NET_DISCONNECT)\r\n\t{\r\n\t\treturn ;\r\n\t}\r\n\tif (cxt->status == SIS_NET_WORKING)\r\n\t{\r\n\t\t//QQQ \u5982\u4f55\u5904\u7406\u5206\u5305\u7684\u95ee\u9898\uff1f\r\n\t\tsis_net_mems_push(cxt->recv_nodes, in_, ilen_);\r\n\t\t// \u53d1\u9001\u901a\u77e5\r\n\t\t// sis_wait_thread_notice(cls->read_thread);\r\n\t}\r\n\telse if (cxt->status == SIS_NET_HANDING)\r\n\t{\r\n\t\tsis_memory_cat(cxt->recv_memory, in_, ilen_);\r\n\t\tint o = sis_ws_recv_hand_ask(cls, cxt);\r\n\t\tif (o == 1) // \u6536\u5230\u6b63\u786e\u7684\u63e1\u624b\u4fe1\u606f\r\n\t\t{\r\n\t\t\tLOG(8)(\"server hand ok. [%d]\\n\", sid_);\r\n\t\t\t// \u8fd9\u91cc\u53d1\u9001\u767b\u5f55\u4fe1\u606f \r\n\t\t\tif (cls->cb_connected)\r\n\t\t\t{\r\n\t\t\t\tcls->cb_connected(cls->cb_source, sid_);\r\n\t\t\t}\t\r\n\t\t\t// \u8bbe\u7f6e\u5de5\u4f5c\u72b6\u6001\t\t\r\n\t\t\tcxt->status = SIS_NET_WORKING;\r\n\t\t\t// \u5982\u679c\u63e1\u624b\u5305\u540e\u6709\u6570\u636e\u5c31\u76f4\u63a5\u901a\u77e5\u5904\u7406\r\n\t\t\tif (sis_memory_get_size(cxt->recv_memory) > 0)\r\n\t\t\t{\r\n\t\t\t\tsis_wait_thread_notice(cls->read_thread);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (o != 0) // \u6536\u5230\u9519\u8bef\u7684\u63e1\u624b\u4fe1\u606f\r\n\t\t{\r\n\t\t\t// \u5982\u679c\u8fd4\u56de<\u96f6 \u5c31\u8bf4\u660e\u6570\u636e\u51fa\u9519\r\n\t\t\t// sis_net_class_close_cxt(cls, sid_);\r\n\t\t\tcxt->status = SIS_NET_DISCONNECT;\r\n\t\t} // == 0 \u8fd8\u6ca1\u6709\u6536\u5230\u6570\u636e\t\t\r\n\t}\r\n"]], "pred": {"ppl": 2.2477827072143555, "ppl_lower": 2.360452651977539, "ppl/lowercase_ppl": -1.060385803646452, "ppl/zlib": 0.0011472298397559256, "Min_5.0% Prob": 6.159355654860988, "Min_10.0% Prob": 4.853751081408876, "Min_20.0% Prob": 3.4741473188906005, "Min_30.0% Prob": 2.5768151477430807, "Min_40.0% Prob": 2.005318323714715, "Min_50.0% Prob": 1.6155204546111679, "Min_60.0% Prob": 1.3496172446241457}}
{"hexsha": "eceba9c2480355dd23601e4ab5eb4cd4f37a44af", "ext": "c", "lang": "C", "content": "void\ngm_tbl_del(gm_tbl_t *t)\n{\n    int i;\n\n    if (t == NULL) {\n        return;\n    }\n\n    gm_func_del(t->value);\n\n    for (i = 0; i < ALPHABET_LEN; i++) {\n        gm_tbl_del(t->next[i]);\n    }\n\n    ndt_free(t);\n}", "item_id": 2, "repo": "hameerabbasi/gumath", "file": "libgumath/tbl.c", "last_update_at": "2018-12-08T08:37:59+00:00", "question_id": "eceba9c2480355dd23601e4ab5eb4cd4f37a44af_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\ngm_tbl_del(gm_tbl_t *t)\n{\n    int i;\n    if (t == NULL) {\n        return;\n    }\n    gm_func_del(t->value);\n    for (i = 0; i < ALPHABET_LEN; i++) {\n        gm_tbl_del(t->next[i]);\n    }\n    ndt_free(t);\n"]], "pred": {"ppl": 3.2857723236083984, "ppl_lower": 3.7672765254974365, "ppl/lowercase_ppl": -1.1149549462195238, "ppl/zlib": 0.007826327173846966, "Min_5.0% Prob": 8.959906768798827, "Min_10.0% Prob": 7.571610147302801, "Min_20.0% Prob": 4.978972310369665, "Min_30.0% Prob": 3.6597804625829062, "Min_40.0% Prob": 2.8742411211133003, "Min_50.0% Prob": 2.3475682486187326, "Min_60.0% Prob": 1.9733391991731795}}
{"hexsha": "02a4eefdf6e7c43b8e8acd9a87d69f33c2546654", "ext": "c", "lang": "C", "content": "void PI_calcMachin3(PBF calcPI, int arctan_mode){\n    PBF operand1 = BF_create(calcPI->size);\n    PBF operand2 = BF_create(calcPI->size);\n    PBF operand3 = BF_create(calcPI->size);\n    PBF operand4 = BF_create(calcPI->size);\n    PBF operand5 = BF_create(calcPI->size);\n    PBF operand6 = BF_create(calcPI->size);\n    \n    BF_initializeInt(operand1, 239, 0);\n    BF_initializeInt(operand2, 1023, 0);\n    BF_initializeInt(operand3, 5832, 0);\n    BF_initializeInt(operand4, 110443, 0);\n    BF_initializeInt(operand5, 4841182, 0);\n    BF_initializeInt(operand6, 6826318, 0);\n    \n    BF_inv(operand1, operand1);\n    BF_inv(operand2, operand2);\n    BF_inv(operand3, operand3);\n    BF_inv(operand4, operand4);\n    BF_inv(operand5, operand5);\n    BF_inv(operand6, operand6);\n    \n    if(arctan_mode == SERIES){\n        arctan_series(operand1, operand1);\n        arctan_series(operand2, operand2);\n        arctan_series(operand3, operand3);\n        arctan_series(operand4, operand4);\n        arctan_series(operand5, operand5);\n        arctan_series(operand6, operand6);\n    }else if(arctan_mode == EULER){\n        arctan_euler(operand1, operand1);\n        arctan_euler(operand2, operand2);\n        arctan_euler(operand3, operand3);\n        arctan_euler(operand4, operand4);\n        arctan_euler(operand5, operand5);\n        arctan_euler(operand6, operand6);\n    }\n    \n    BF_mulInteger(operand1, operand1, 732);\n    BF_mulInteger(operand2, operand2, 128);\n    BF_mulInteger(operand3, operand3, 272);\n    BF_mulInteger(operand4, operand4, 48);\n    BF_mulInteger(operand5, operand5, 48);\n    BF_mulInteger(operand6, operand6, 400);\n    \n    BF_add(operand1, operand2);\n    BF_sub(operand1, operand3);\n    BF_add(operand1, operand4);\n    BF_sub(operand1, operand5);\n    BF_sub(operand1, operand6);\n    \n    BF_copy(calcPI, operand1);\n    \n    BF_delete(operand1);\n    BF_delete(operand2);\n    BF_delete(operand3);\n    BF_delete(operand4);\n    BF_delete(operand5);\n    BF_delete(operand6);\n}", "item_id": 2, "repo": "ihooni/WHY-PI-", "file": "WHY PI 2.0/project folder/WHY PI 2.0/PI_formula/PI_formula.c", "last_update_at": "2018-07-18T11:47:04+00:00", "question_id": "02a4eefdf6e7c43b8e8acd9a87d69f33c2546654_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void PI_calcMachin3(PBF calcPI, int arctan_mode){\n    PBF operand1 = BF_create(calcPI->size);\n    PBF operand2 = BF_create(calcPI->size);\n    PBF operand3 = BF_create(calcPI->size);\n    PBF operand4 = BF_create(calcPI->size);\n    PBF operand5 = BF_create(calcPI->size);\n    PBF operand6 = BF_create(calcPI->size);\n    BF_initializeInt(operand1, 239, 0);\n    BF_initializeInt(operand2, 1023, 0);\n    BF_initializeInt(operand3, 5832, 0);\n    BF_initializeInt(operand4, 110443, 0);\n    BF_initializeInt(operand5, 4841182, 0);\n    BF_initializeInt(operand6, 6826318, 0);\n    BF_inv(operand1, operand1);\n    BF_inv(operand2, operand2);\n    BF_inv(operand3, operand3);\n    BF_inv(operand4, operand4);\n    BF_inv(operand5, operand5);\n    BF_inv(operand6, operand6);\n    if(arctan_mode == SERIES){\n        arctan_series(operand1, operand1);\n        arctan_series(operand2, operand2);\n        arctan_series(operand3, operand3);\n        arctan_series(operand4, operand4);\n        arctan_series(operand5, operand5);\n        arctan_series(operand6, operand6);\n    }else if(arctan_mode == EULER){\n        arctan_euler(operand1, operand1);\n        arctan_euler(operand2, operand2);\n        arctan_euler(operand3, operand3);\n        arctan_euler(operand4, operand4);\n        arctan_euler(operand5, operand5);\n        arctan_euler(operand6, operand6);\n    }\n    BF_mulInteger(operand1, operand1, 732);\n    BF_mulInteger(operand2, operand2, 128);\n    BF_mulInteger(operand3, operand3, 272);\n    BF_mulInteger(operand4, operand4, 48);\n    BF_mulInteger(operand5, operand5, 48);\n    BF_mulInteger(operand6, operand6, 400);\n    BF_add(operand1, operand2);\n    BF_sub(operand1, operand3);\n    BF_add(operand1, operand4);\n    BF_sub(operand1, operand5);\n    BF_sub(operand1, operand6);\n    BF_copy(calcPI, operand1);\n    BF_delete(operand1);\n    BF_delete(operand2);\n    BF_delete(operand3);\n    BF_delete(operand4);\n    BF_delete(operand5);\n    BF_delete(operand6);\n"]], "pred": {"ppl": 1.5874742269515991, "ppl_lower": 1.6126182079315186, "ppl/lowercase_ppl": -1.0340042285869313, "ppl/zlib": 0.00111629037841015, "Min_5.0% Prob": 5.693453761034234, "Min_10.0% Prob": 3.9741417402508614, "Min_20.0% Prob": 2.2819659012556075, "Min_30.0% Prob": 1.5413190169999276, "Min_40.0% Prob": 1.1559508232619347, "Min_50.0% Prob": 0.9241173386504155, "Min_60.0% Prob": 0.7710772947659383}}
{"hexsha": "ca469d18395872ad767d38c867a958a18386a443", "ext": "c", "lang": "C", "content": "void radeon_vm_init(struct radeon_device *rdev, struct radeon_vm *vm)\n{\n\tvm->id = 0;\n\tvm->fence = NULL;\n\tsx_init(&vm->mutex, \"drm__radeon_vm__mutex\");\n\tINIT_LIST_HEAD(&vm->list);\n\tINIT_LIST_HEAD(&vm->va);\n}", "item_id": 27, "repo": "dcui/FreeBSD-9.3_kernel", "file": "sys/dev/drm2/radeon/radeon_gart.c", "last_update_at": "2018-01-11T01:01:38+00:00", "question_id": "ca469d18395872ad767d38c867a958a18386a443_27", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void radeon_vm_init(struct radeon_device *rdev, struct radeon_vm *vm)\n{\n\tvm->id = 0;\n\tvm->fence = NULL;\n\tsx_init(&vm->mutex, \"drm__radeon_vm__mutex\");\n\tINIT_LIST_HEAD(&vm->list);\n\tINIT_LIST_HEAD(&vm->va);\n"]], "pred": {"ppl": 2.568575859069824, "ppl_lower": 3.181419610977173, "ppl/lowercase_ppl": -1.2268251940662505, "ppl/zlib": 0.006643321161090239, "Min_5.0% Prob": 9.277935862541199, "Min_10.0% Prob": 6.6760627958509655, "Min_20.0% Prob": 4.251602649688721, "Min_30.0% Prob": 3.0487158658175635, "Min_40.0% Prob": 2.3333839907860146, "Min_50.0% Prob": 1.8801147458808762, "Min_60.0% Prob": 1.5918986205782355}}
{"hexsha": "875e51e2b094d0bfb9e94c43de6f86c080198e93", "ext": "c", "lang": "C", "content": "VOID\nWriteA2NMailbox(\n    IN VOID *pNFCAdapte\n)\n{\n    PNFC_ADAPTER pNFCAdp = (PNFC_ADAPTER) pNFCAdapte;\n    u8 i = 0;\n    u32 RegTemp;\n\n    if (!(pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Response)) {\n        pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Content[0] = \n            (pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Content[0]|(pNFCAdp->A2NSeq << 8));\n        pNFCAdp->A2NSeq++;\n    }    \n    \n    for(i = 0; i < pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Length; i++) {\n        HalDelayUs(30);\n        HAL_WRITE32(NFC_INTERFACE_BASE, 0x10, pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Content[i]);\n    }\n    \n    HalDelayUs(30);\n    RegTemp = HAL_READ32(NFC_INTERFACE_BASE,0x24)|BIT1;\n    HAL_WRITE32(NFC_INTERFACE_BASE, 0x24, RegTemp);\n    \n    RegTemp = (HAL_READ32(NFC_INTERFACE_BASE,0x24)&(~BIT1));\n    HAL_WRITE32(NFC_INTERFACE_BASE, 0x24, RegTemp);\n}", "item_id": 0, "repo": "pvvx/RTL00_HelloWorld", "file": "lib/fwlib/rtl8195a/src/rtl8195a_nfc.c", "last_update_at": "2018-02-16T19:35:22+00:00", "question_id": "875e51e2b094d0bfb9e94c43de6f86c080198e93_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["VOID\nWriteA2NMailbox(\n    IN VOID *pNFCAdapte\n)\n{\n    PNFC_ADAPTER pNFCAdp = (PNFC_ADAPTER) pNFCAdapte;\n    u8 i = 0;\n    u32 RegTemp;\n    if (!(pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Response)) {\n        pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Content[0] = \n            (pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Content[0]|(pNFCAdp->A2NSeq << 8));\n        pNFCAdp->A2NSeq++;\n    }    \n    for(i = 0; i < pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Length; i++) {\n        HalDelayUs(30);\n        HAL_WRITE32(NFC_INTERFACE_BASE, 0x10, pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Content[i]);\n    }\n    HalDelayUs(30);\n    RegTemp = HAL_READ32(NFC_INTERFACE_BASE,0x24)|BIT1;\n    HAL_WRITE32(NFC_INTERFACE_BASE, 0x24, RegTemp);\n    RegTemp = (HAL_READ32(NFC_INTERFACE_BASE,0x24)&(~BIT1));\n    HAL_WRITE32(NFC_INTERFACE_BASE, 0x24, RegTemp);\n"]], "pred": {"ppl": 2.266920566558838, "ppl_lower": 2.685732126235962, "ppl/lowercase_ppl": -1.2071437019729006, "ppl/zlib": 0.002518222559689504, "Min_5.0% Prob": 7.371582051982051, "Min_10.0% Prob": 5.654961311298868, "Min_20.0% Prob": 3.7012403076109677, "Min_30.0% Prob": 2.672297198271406, "Min_40.0% Prob": 2.036311257711571, "Min_50.0% Prob": 1.6350432710965042, "Min_60.0% Prob": 1.3637164122394652}}
{"hexsha": "a7e5de57ad5b4c5a5a06f6b07600b247ced65621", "ext": "c", "lang": "C", "content": "ggsea_fill_pair_s ggsea_extend(\n\tstruct ggsea_ctx_s *ctx,\n\tstruct gref_gid_pos_s rpos,\n\tstruct gref_gid_pos_s qpos)\n{\n\t/* forward section */\n\tdebug(\"forward extend\");\n\tstruct gref_section_s const *rfsec = gref_get_section(ctx->r, rpos.gid);\n\tstruct gref_section_s const *qfsec = gref_get_section(ctx->q, qpos.gid);\n\tgaba_fill_t const *fw_max = ggsea_extend_intl(ctx,\n\t\trfsec, rpos.pos,\n\t\tqfsec, qpos.pos);\n\n\t/* reverse section */\n\tdebug(\"reverse extend\");\n\tstruct gref_section_s const *rrsec = gref_get_section(ctx->r, gref_rev_gid(rpos.gid));\n\tstruct gref_section_s const *qrsec = gref_get_section(ctx->q, gref_rev_gid(qpos.gid));\n\tgaba_fill_t const *rv_max = ggsea_extend_intl(ctx,\n\t\trrsec, rrsec->len - rpos.pos,\n\t\tqrsec, qrsec->len - qpos.pos);\n\n\tdebug(\"fw_max(%lld), rv_max(%lld), max(%lld)\",\n\t\tfw_max->max, rv_max->max, fw_max->max + rv_max->max);\n\t/* return max pair */\n\treturn((struct ggsea_fill_pair_s){\n\t\t.fw = fw_max,\n\t\t.rv = rv_max\n\t});\n}", "item_id": 13, "repo": "ocxtal/libggsea", "file": "ggsea.c", "last_update_at": "2018-03-05T01:14:01+00:00", "question_id": "a7e5de57ad5b4c5a5a06f6b07600b247ced65621_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ggsea_fill_pair_s ggsea_extend(\n\tstruct ggsea_ctx_s *ctx,\n\tstruct gref_gid_pos_s rpos,\n\tstruct gref_gid_pos_s qpos)\n{\n\t/* forward section */\n\tdebug(\"forward extend\");\n\tstruct gref_section_s const *rfsec = gref_get_section(ctx->r, rpos.gid);\n\tstruct gref_section_s const *qfsec = gref_get_section(ctx->q, qpos.gid);\n\tgaba_fill_t const *fw_max = ggsea_extend_intl(ctx,\n\t\trfsec, rpos.pos,\n\t\tqfsec, qpos.pos);\n\t/* reverse section */\n\tdebug(\"reverse extend\");\n\tstruct gref_section_s const *rrsec = gref_get_section(ctx->r, gref_rev_gid(rpos.gid));\n\tstruct gref_section_s const *qrsec = gref_get_section(ctx->q, gref_rev_gid(qpos.gid));\n\tgaba_fill_t const *rv_max = ggsea_extend_intl(ctx,\n\t\trrsec, rrsec->len - rpos.pos,\n\t\tqrsec, qrsec->len - qpos.pos);\n\tdebug(\"fw_max(%lld), rv_max(%lld), max(%lld)\",\n\t\tfw_max->max, rv_max->max, fw_max->max + rv_max->max);\n\t/* return max pair */\n\treturn((struct ggsea_fill_pair_s){\n\t\t.fw = fw_max,\n\t\t.rv = rv_max\n\t});\n"]], "pred": {"ppl": 2.203676462173462, "ppl_lower": 2.203676462173462, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0023943244992971203, "Min_5.0% Prob": 7.842905478043989, "Min_10.0% Prob": 5.705651120706038, "Min_20.0% Prob": 3.671028162268075, "Min_30.0% Prob": 2.5887316052209246, "Min_40.0% Prob": 1.9673510870938613, "Min_50.0% Prob": 1.5788630813783542, "Min_60.0% Prob": 1.3165610534364753}}
{"hexsha": "3d81c505cc9aaa697cfcc48a9f34b78be8e7c71b", "ext": "c", "lang": "C", "content": "int main(int argc, char* argv[])\n{\n    char cmd;\n    int key1, key2;\n    FILE* input;\n    Position header = NULL;\n    Position tmpPosition = NULL;\n\n    input = fopen(argv[1], \"r\");\n    header = MakeEmpty();\n\n    while(true)\n    {\n        cmd = fgetc(input);\n        if(feof(input)) break;\n        switch(cmd)\n        {\n        case 'i':\n            fscanf(input, \"%d %d\", &key1, &key2);\n            tmpPosition = Find(key1, header);\n            if(tmpPosition != NULL)\n            {\n                printf(\"Insertion failed: there already is an element with key %d.\\n\", key1);\n                break;\n            }\n            if(key2 == -1)\n                tmpPosition = header;\n            else\n                tmpPosition = Find(key2, header);\n            Insert(key1, header, tmpPosition);\n//          PrintList(header);\n            break;\n        case 'd':\n            fscanf(input, \"%d\", &key1);\n            Delete(key1, header);\n//          PrintList(header);\n            break;\n        case 'f':\n            fscanf(input, \"%d\", &key1);\n            tmpPosition = FindPrevious(key1, header);\n            if (tmpPosition == NULL)\n                printf(\"Could not find %d in the list\\n\", key1);\n            else\n            {\n                if(tmpPosition->element>0)\n                    printf(\"Key of the previous node of %d is %d.\\n\", key1, tmpPosition->element);\n                else\n                    printf(\"Key of the previous node of %d is header.\\n\", key1);\n            }\n            break;\n        case 'p':\n            PrintList(header);\n        }\n    }\n    DeleteList(header);\n    fclose(input);\n    return 0;\n}", "item_id": 0, "repo": "FelisCatusKR/DS_Winter", "file": "Lab_03/main.c", "last_update_at": "2018-01-16T01:21:58+00:00", "question_id": "3d81c505cc9aaa697cfcc48a9f34b78be8e7c71b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(int argc, char* argv[])\n{\n    char cmd;\n    int key1, key2;\n    FILE* input;\n    Position header = NULL;\n    Position tmpPosition = NULL;\n    input = fopen(argv[1], \"r\");\n    header = MakeEmpty();\n    while(true)\n    {\n        cmd = fgetc(input);\n        if(feof(input)) break;\n        switch(cmd)\n        {\n        case 'i':\n            fscanf(input, \"%d %d\", &key1, &key2);\n            tmpPosition = Find(key1, header);\n            if(tmpPosition != NULL)\n            {\n                printf(\"Insertion failed: there already is an element with key %d.\\n\", key1);\n                break;\n            }\n            if(key2 == -1)\n                tmpPosition = header;\n            else\n                tmpPosition = Find(key2, header);\n            Insert(key1, header, tmpPosition);\n//          PrintList(header);\n            break;\n        case 'd':\n            fscanf(input, \"%d\", &key1);\n            Delete(key1, header);\n//          PrintList(header);\n            break;\n        case 'f':\n            fscanf(input, \"%d\", &key1);\n            tmpPosition = FindPrevious(key1, header);\n            if (tmpPosition == NULL)\n                printf(\"Could not find %d in the list\\n\", key1);\n            else\n            {\n                if(tmpPosition->element>0)\n                    printf(\"Key of the previous node of %d is %d.\\n\", key1, tmpPosition->element);\n                else\n                    printf(\"Key of the previous node of %d is header.\\n\", key1);\n            }\n            break;\n        case 'p':\n            PrintList(header);\n        }\n    }\n    DeleteList(header);\n    fclose(input);\n    return 0;\n"]], "pred": {"ppl": 1.8857104778289795, "ppl_lower": 1.9833699464797974, "ppl/lowercase_ppl": -1.0796032774400421, "ppl/zlib": 0.0012151430291223295, "Min_5.0% Prob": 5.9718601599983545, "Min_10.0% Prob": 4.335477010063503, "Min_20.0% Prob": 2.821748173365029, "Min_30.0% Prob": 2.0328800446220807, "Min_40.0% Prob": 1.5629889494913785, "Min_50.0% Prob": 1.2602611292376478, "Min_60.0% Prob": 1.0573907197386558}}
{"hexsha": "3a88ea1647446ebfd247ede85d92ac7e9d8f0720", "ext": "h", "lang": "C", "content": "const override\n\t{\n\t\tstd::vector<FactoryBaseClass*> ret;\n\t\tret.reserve(_factoryMap.size());\n\n\t\tfor (const auto& pair : _factoryMap)\n\t\t{\n\t\t\tret.push_back(pair.second);\n\t\t}", "item_id": 0, "repo": "jowie94/EquinoxEngine", "file": "Equinox/FactoryDictionary.h", "last_update_at": "2018-10-16T20:12:59+00:00", "question_id": "3a88ea1647446ebfd247ede85d92ac7e9d8f0720_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["const override\n\t{\n\t\tstd::vector<FactoryBaseClass*> ret;\n\t\tret.reserve(_factoryMap.size());\n\t\tfor (const auto& pair : _factoryMap)\n\t\t{\n\t\t\tret.push_back(pair.second);\n"]], "pred": {"ppl": 3.895744562149048, "ppl_lower": 4.608354091644287, "ppl/lowercase_ppl": -1.1235295381906016, "ppl/zlib": 0.009854237822469174, "Min_5.0% Prob": 10.232317606608072, "Min_10.0% Prob": 9.10537060101827, "Min_20.0% Prob": 6.173273214927087, "Min_30.0% Prob": 4.51276221871376, "Min_40.0% Prob": 3.433199480175972, "Min_50.0% Prob": 2.7484771006685844, "Min_60.0% Prob": 2.285668010028397}}
{"hexsha": "cb1021965680a8dfb38f2fb7db30e98445ee443c", "ext": "c", "lang": "C", "content": "int main(){\n  char str_a[20]; //A 20-element character array\n  char *pointer; //A pointer meant for character array\n  char *pointer2; //And yet another one\n\n  strcpy(str_a, \"Hello, World!\\n\");\n  pointer = str_a; // Set the first pointer to the start of the array.\n  printf(pointer); //print it\n\n  pointer2 = pointer + 2; //Set teh second one 2 bytes further in.\n  printf(pointer2); //print it\n  strcpy(pointer2, \"y you guys!\\n\"); //Copy into that spot.\n  printf(pointer); //Print again.\n}", "item_id": 0, "repo": "Ethic41/codes", "file": "C/Learning/HTAOE_codes/pointer.c", "last_update_at": "2018-04-28T14:16:39+00:00", "question_id": "cb1021965680a8dfb38f2fb7db30e98445ee443c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(){\n  char str_a[20]; //A 20-element character array\n  char *pointer; //A pointer meant for character array\n  char *pointer2; //And yet another one\n  strcpy(str_a, \"Hello, World!\\n\");\n  pointer = str_a; // Set the first pointer to the start of the array.\n  printf(pointer); //print it\n  pointer2 = pointer + 2; //Set teh second one 2 bytes further in.\n  printf(pointer2); //print it\n  strcpy(pointer2, \"y you guys!\\n\"); //Copy into that spot.\n  printf(pointer); //Print again.\n"]], "pred": {"ppl": 4.81570291519165, "ppl_lower": 4.6562418937683105, "ppl/lowercase_ppl": -0.9785776817585319, "ppl/zlib": 0.006116272447699894, "Min_5.0% Prob": 9.11603696005685, "Min_10.0% Prob": 6.9988795757293705, "Min_20.0% Prob": 5.025945317360662, "Min_30.0% Prob": 4.1163171758043005, "Min_40.0% Prob": 3.4835164395589677, "Min_50.0% Prob": 2.9576479121099544, "Min_60.0% Prob": 2.543344214401747}}
{"hexsha": "28aede9073a119d79e469097384f8e23204ddf12", "ext": "c", "lang": "C", "content": "int main(){\n        char s1[MAXLEN];\n        char s2[MAXLEN];\n        char *res;\n        int pos, status;\n        \n        while (1){\n                printf(\"Please input string to squeeze s1: \");\n                res = fgets(s1, MAXLEN, stdin);\n                if (res == NULL)\n                        return 0;\n                printf(\"Please input the reference string s2: \");\n                res = fgets(s2, MAXLEN, stdin);\n                if (res == NULL)\n                        return 0;\n                eliminate_newline(s1);\n                eliminate_newline(s2);\n                pos = any(s1, s2);\n                if (pos > 0)\n                        printf(\"First position of s2 chars in s1: %d\\n\", pos);\n                else\n                        printf(\"s2 chars not found in s1\\n. \");\n                                \n                status = squeeze(s1, s2);\n                if (status == 0)\n                        printf(\"String after squeezing is: %s\\n\", s1);\n        }\n        \n        return -1;\n}", "item_id": 0, "repo": "chen-chao/coursera", "file": "tcpl/2.types_operators_and_expressions/2-4-5.c", "last_update_at": "2018-07-17T22:18:22+00:00", "question_id": "28aede9073a119d79e469097384f8e23204ddf12_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(){\n        char s1[MAXLEN];\n        char s2[MAXLEN];\n        char *res;\n        int pos, status;\n        while (1){\n                printf(\"Please input string to squeeze s1: \");\n                res = fgets(s1, MAXLEN, stdin);\n                if (res == NULL)\n                        return 0;\n                printf(\"Please input the reference string s2: \");\n                res = fgets(s2, MAXLEN, stdin);\n                if (res == NULL)\n                        return 0;\n                eliminate_newline(s1);\n                eliminate_newline(s2);\n                pos = any(s1, s2);\n                if (pos > 0)\n                        printf(\"First position of s2 chars in s1: %d\\n\", pos);\n                else\n                        printf(\"s2 chars not found in s1\\n. \");\n                status = squeeze(s1, s2);\n                if (status == 0)\n                        printf(\"String after squeezing is: %s\\n\", s1);\n        }\n        return -1;\n"]], "pred": {"ppl": 2.3641440868377686, "ppl_lower": 2.4795048236846924, "ppl/lowercase_ppl": -1.0553718452252172, "ppl/zlib": 0.0026073213579558717, "Min_5.0% Prob": 7.984941925321307, "Min_10.0% Prob": 5.6650565181459696, "Min_20.0% Prob": 3.792854883841106, "Min_30.0% Prob": 2.737819563065256, "Min_40.0% Prob": 2.121960151674492, "Min_50.0% Prob": 1.7155264398615275, "Min_60.0% Prob": 1.434798406603347}}
{"hexsha": "b18178fdf4a5eaa7c8a706b2e32c3770a4db863c", "ext": "h", "lang": "C", "content": "namespace AvalonTools {\nstatic int avalonSSSBits = 0x007FFF;\nstatic int avalonSimilarityBits = 0xF07FFF;\nstd::string getCanonSmiles(RDKit::ROMol &mol, int flags = -1);\nvoid getAvalonCountFP(const RDKit::ROMol &mol,\n                      RDKit::SparseIntVect<boost::uint32_t> &res,\n                      unsigned int nBits = 512, bool isQuery = false,\n                      bool resetVect = true,\n                      unsigned int bitFlags = avalonSSSBits);\nvoid getAvalonFP(const RDKit::ROMol &mol, ExplicitBitVect &res,\n                 unsigned int nBits = 512, bool isQuery = false,\n                 bool resetVect = true, unsigned int bitFlags = avalonSSSBits);\nvoid getAvalonFP(const RDKit::ROMol &mol, std::vector<boost::uint32_t> &res,\n                 unsigned int nBits = 512, bool isQuery = false,\n                 bool resetVect = true, unsigned int bitFlags = avalonSSSBits);\nunsigned int set2DCoords(RDKit::ROMol &mol, bool clearConfs = true);\n\nstd::string getCanonSmiles(const std::string &data, bool isSmiles,\n                           int flags = -1);\nvoid getAvalonCountFP(const std::string &data, bool isSmiles,\n                      RDKit::SparseIntVect<boost::uint32_t> &res,\n                      unsigned int nBits = 512, bool isQuery = false,\n                      unsigned int bitFlags = avalonSSSBits);\nvoid getAvalonFP(const std::string &data, bool isSmiles, ExplicitBitVect &res,\n                 unsigned int nBits = 512, bool isQuery = false,\n                 bool resetVect = true, unsigned int bitFlags = avalonSSSBits);\nvoid getAvalonFP(const std::string &data, bool isSmiles,\n                 std::vector<boost::uint32_t> &res, unsigned int nBits = 512,\n                 bool isQuery = false, bool resetVect = true,\n                 unsigned int bitFlags = avalonSSSBits);\n\nstd::string set2DCoords(const std::string &data, bool isSmiles);\n\nint initCheckMol(const std::string &optString);\nRDKit::ROMOL_SPTR checkMol(int &errors, RDKit::ROMol &inMol);\nRDKit::ROMOL_SPTR checkMol(int &errors, const std::string &data, bool isSmiles);\nstd::pair<std::string, int> checkMolString(const std::string &data,\n                                           bool isSmiles);\nstd::string getCheckMolLog();\n\nvoid closeCheckMolFiles();\n}", "item_id": 0, "repo": "docking-org/rdk", "file": "External/AvalonTools/AvalonTools.h", "last_update_at": "2018-11-29T01:18:46+00:00", "question_id": "b18178fdf4a5eaa7c8a706b2e32c3770a4db863c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace AvalonTools {\nstatic int avalonSSSBits = 0x007FFF;\nstatic int avalonSimilarityBits = 0xF07FFF;\nstd::string getCanonSmiles(RDKit::ROMol &mol, int flags = -1);\nvoid getAvalonCountFP(const RDKit::ROMol &mol,\n                      RDKit::SparseIntVect<boost::uint32_t> &res,\n                      unsigned int nBits = 512, bool isQuery = false,\n                      bool resetVect = true,\n                      unsigned int bitFlags = avalonSSSBits);\nvoid getAvalonFP(const RDKit::ROMol &mol, ExplicitBitVect &res,\n                 unsigned int nBits = 512, bool isQuery = false,\n                 bool resetVect = true, unsigned int bitFlags = avalonSSSBits);\nvoid getAvalonFP(const RDKit::ROMol &mol, std::vector<boost::uint32_t> &res,\n                 unsigned int nBits = 512, bool isQuery = false,\n                 bool resetVect = true, unsigned int bitFlags = avalonSSSBits);\nunsigned int set2DCoords(RDKit::ROMol &mol, bool clearConfs = true);\nstd::string getCanonSmiles(const std::string &data, bool isSmiles,\n                           int flags = -1);\nvoid getAvalonCountFP(const std::string &data, bool isSmiles,\n                      RDKit::SparseIntVect<boost::uint32_t> &res,\n                      unsigned int nBits = 512, bool isQuery = false,\n                      unsigned int bitFlags = avalonSSSBits);\nvoid getAvalonFP(const std::string &data, bool isSmiles, ExplicitBitVect &res,\n                 unsigned int nBits = 512, bool isQuery = false,\n                 bool resetVect = true, unsigned int bitFlags = avalonSSSBits);\nvoid getAvalonFP(const std::string &data, bool isSmiles,\n                 std::vector<boost::uint32_t> &res, unsigned int nBits = 512,\n                 bool isQuery = false, bool resetVect = true,\n                 unsigned int bitFlags = avalonSSSBits);\nstd::string set2DCoords(const std::string &data, bool isSmiles);\nint initCheckMol(const std::string &optString);\nRDKit::ROMOL_SPTR checkMol(int &errors, RDKit::ROMol &inMol);\nRDKit::ROMOL_SPTR checkMol(int &errors, const std::string &data, bool isSmiles);\nstd::pair<std::string, int> checkMolString(const std::string &data,\n                                           bool isSmiles);\nstd::string getCheckMolLog();\nvoid closeCheckMolFiles();\n"]], "pred": {"ppl": 1.9714428186416626, "ppl_lower": 2.2908685207366943, "ppl/lowercase_ppl": -1.2212329660790393, "ppl/zlib": 0.0014411160720359923, "Min_5.0% Prob": 7.001976913876003, "Min_10.0% Prob": 5.085240788655739, "Min_20.0% Prob": 3.209147675804896, "Min_30.0% Prob": 2.23078133595938, "Min_40.0% Prob": 1.6932711803923288, "Min_50.0% Prob": 1.3558747218338119, "Min_60.0% Prob": 1.1318634721143594}}
{"hexsha": "264c01590be5a4d3c4b170ff9e5c6a10fde26fe6", "ext": "c", "lang": "C", "content": "static apr_size_t calc_header_size(serf_bucket_t *hdrs)\n{\n    apr_size_t size = 0;\n\n    serf_bucket_headers_do(hdrs, count_size, &size);\n\n    return size;\n}", "item_id": 5, "repo": "PeterDaveHello/incubator-pagespeed-mod", "file": "third_party/serf/instaweb_bwtp_buckets.c", "last_update_at": "2018-01-04T03:19:47+00:00", "question_id": "264c01590be5a4d3c4b170ff9e5c6a10fde26fe6_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static apr_size_t calc_header_size(serf_bucket_t *hdrs)\n{\n    apr_size_t size = 0;\n    serf_bucket_headers_do(hdrs, count_size, &size);\n    return size;\n"]], "pred": {"ppl": 2.6783528327941895, "ppl_lower": 2.6783528327941895, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.00871860168974101, "Min_5.0% Prob": 8.605241298675537, "Min_10.0% Prob": 7.009593566258748, "Min_20.0% Prob": 4.56317138671875, "Min_30.0% Prob": 3.3046484213126335, "Min_40.0% Prob": 2.474476048006461, "Min_50.0% Prob": 1.9637605002657934, "Min_60.0% Prob": 1.664892164369424}}
{"hexsha": "9dcf074d205f653f0d2599cbb9c7ba23f2130cdc", "ext": "c", "lang": "C", "content": "int main(int argc, char const *argv[]) {\n\n  if (argv[1] == 0) {\n    printf(\"Insira o nome de um arquivo.\\n\");\n    return -1;\n  }\n\n  FILE * fPointer;\n  FILE * fWrite;\n\n  char *file_name = (char *) malloc(strlen(argv[1]) * sizeof(char));\n\n  int i = 0;\n  for(i = 0; i < strlen(argv[1]); i++) {\n    file_name[i] = argv[1][i];\n  }\n\n  fPointer = fopen(file_name, \"r\");\n\n  int file_size = fsize(file_name);\n  char ch;\n\n  int x = 0,\n      new_file = 0,\n      file_number = 0;\n\n  while(1) {\n    ch = fgetc(fPointer);\n\n    if(ch == '/'){\n      if(fgetc(fPointer) == '*') {\n        file_number++;\n\n        if(file_number < 9) {\n          sprintf(file_name, \"0%d.c\", file_number);\n        } else {\n          sprintf(file_name, \"%d.c\", file_number);\n        }\n\n        while(1) {\n          fWrite = fopen(file_name, \"a\");\n          ch = fgetc(fPointer);\n          fprintf(fWrite, \"%c\", ch);\n          printf(\"%c\\n\", ch);\n          if(ch == '*'){\n            if(fgetc(fPointer) == '/') {\n              break;\n            }\n          }\n\n        }\n      }\n    }\n\n\n    if(feof(fPointer)) {\n      break;\n    }\n    x++;\n  }\n\n  fclose(fPointer);\n\n  return 0;\n}", "item_id": 1, "repo": "hugonasciutti/Exercises", "file": "C/Organizer/main2.c", "last_update_at": "2018-07-12T02:24:49+00:00", "question_id": "9dcf074d205f653f0d2599cbb9c7ba23f2130cdc_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(int argc, char const *argv[]) {\n  if (argv[1] == 0) {\n    printf(\"Insira o nome de um arquivo.\\n\");\n    return -1;\n  }\n  FILE * fPointer;\n  FILE * fWrite;\n  char *file_name = (char *) malloc(strlen(argv[1]) * sizeof(char));\n  int i = 0;\n  for(i = 0; i < strlen(argv[1]); i++) {\n    file_name[i] = argv[1][i];\n  }\n  fPointer = fopen(file_name, \"r\");\n  int file_size = fsize(file_name);\n  char ch;\n  int x = 0,\n      new_file = 0,\n      file_number = 0;\n  while(1) {\n    ch = fgetc(fPointer);\n    if(ch == '/'){\n      if(fgetc(fPointer) == '*') {\n        file_number++;\n        if(file_number < 9) {\n          sprintf(file_name, \"0%d.c\", file_number);\n        } else {\n          sprintf(file_name, \"%d.c\", file_number);\n        }\n        while(1) {\n          fWrite = fopen(file_name, \"a\");\n          ch = fgetc(fPointer);\n          fprintf(fWrite, \"%c\", ch);\n          printf(\"%c\\n\", ch);\n          if(ch == '*'){\n            if(fgetc(fPointer) == '/') {\n              break;\n            }\n          }\n        }\n      }\n    }\n    if(feof(fPointer)) {\n      break;\n    }\n    x++;\n  }\n  fclose(fPointer);\n  return 0;\n"]], "pred": {"ppl": 1.878995418548584, "ppl_lower": 1.914798378944397, "ppl/lowercase_ppl": -1.0299253750920205, "ppl/zlib": 0.00142378619004329, "Min_5.0% Prob": 5.192988903626151, "Min_10.0% Prob": 3.998140034468278, "Min_20.0% Prob": 2.712292728216752, "Min_30.0% Prob": 1.9926095255043195, "Min_40.0% Prob": 1.5514458272930072, "Min_50.0% Prob": 1.2520091982147137, "Min_60.0% Prob": 1.0488682965199978}}
{"hexsha": "54b53744b84b1c82076a9295782044e0936a95a7", "ext": "c", "lang": "C", "content": "static void\nhandle_rx_char(char ch)\n{\n\tswitch(ch) {\n\t\tcase 0:\n\t\t\treturn;\n\t\tcase 0x07:\t// BEL\n\t\t\treturn;\n\t\tcase 0x0f:\t// LTRS\n\t\t\treturn;\n\t\tcase 0x0e:\t// FIGS\n\t\t\treturn;\n\t}\n\tif (log_file != NULL)\n\t\tfwrite(&ch, 1, 1, log_file);\n\tfldigi_add_rx(ch);\n}", "item_id": 4, "repo": "K6BSD/bsdtty", "file": "bsdtty.c", "last_update_at": "2018-09-05T19:27:39+00:00", "question_id": "54b53744b84b1c82076a9295782044e0936a95a7_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nhandle_rx_char(char ch)\n{\n\tswitch(ch) {\n\t\tcase 0:\n\t\t\treturn;\n\t\tcase 0x07:\t// BEL\n\t\t\treturn;\n\t\tcase 0x0f:\t// LTRS\n\t\t\treturn;\n\t\tcase 0x0e:\t// FIGS\n\t\t\treturn;\n\t}\n\tif (log_file != NULL)\n\t\tfwrite(&ch, 1, 1, log_file);\n\tfldigi_add_rx(ch);\n"]], "pred": {"ppl": 3.0462677478790283, "ppl_lower": 3.289821147918701, "ppl/lowercase_ppl": -1.0690500624224009, "ppl/zlib": 0.006630459238573361, "Min_5.0% Prob": 8.098239558083671, "Min_10.0% Prob": 6.237222518239703, "Min_20.0% Prob": 4.350554453475135, "Min_30.0% Prob": 3.38736515385764, "Min_40.0% Prob": 2.69570765165346, "Min_50.0% Prob": 2.209170789165156, "Min_60.0% Prob": 1.8589030353441125}}
{"hexsha": "bf08d10d8529fbb86a5090068765fc936794e1c3", "ext": "c", "lang": "C", "content": "static void clean_add_ptr_to_seq_set2(ptr_set2_t *set, void *p) {\n  uint32_t i;\n\n  assert(set->ndeleted == 0 && set->nelems < set->size);\n  i = set->nelems;\n  set->data[i] = p;\n  set->nelems = i + 1;\n}", "item_id": 3, "repo": "maelvls/ocamlyices2", "file": "ext/yices/src/utils/ptr_sets2.c", "last_update_at": "2018-11-23T00:16:01+00:00", "question_id": "bf08d10d8529fbb86a5090068765fc936794e1c3_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void clean_add_ptr_to_seq_set2(ptr_set2_t *set, void *p) {\n  uint32_t i;\n  assert(set->ndeleted == 0 && set->nelems < set->size);\n  i = set->nelems;\n  set->data[i] = p;\n  set->nelems = i + 1;\n"]], "pred": {"ppl": 3.5310685634613037, "ppl_lower": 3.5310685634613037, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0087611148217629, "Min_5.0% Prob": 8.355414509773254, "Min_10.0% Prob": 6.776225831773546, "Min_20.0% Prob": 4.819436412108572, "Min_30.0% Prob": 3.671144185395076, "Min_40.0% Prob": 3.0097713956707404, "Min_50.0% Prob": 2.479100971793135, "Min_60.0% Prob": 2.090502743063302}}
{"hexsha": "f93e4c05d1772227b8a5334da8f209b89ec62807", "ext": "c", "lang": "C", "content": "TT_TEST_ROUTINE_DEFINE(case_ptr_stack)\n{\n    // tt_u32_t param = TT_TEST_ROUTINE_PARAM(tt_u32_t);\n    tt_u32_t v[__q_size] = {0};\n    tt_u32_t i, n;\n    tt_result_t ret;\n    tt_ptrstk_t q;\n\n    TT_TEST_CASE_ENTER()\n    // test start\n\n    for (i = 0; i < __q_size; ++i) {\n        v[i] = i;\n    }\n\n    tt_ptrstk_init(&q, NULL);\n    tt_ptrstk_clear(&q);\n    TT_UT_EQUAL(tt_ptrstk_count(&q), 0, \"\");\n    TT_UT_EQUAL(tt_ptrstk_empty(&q), TT_TRUE, \"\");\n    TT_UT_EQUAL(tt_ptrstk_top(&q), NULL, \"\");\n\n    TT_UT_EQUAL(tt_ptrstk_pop(&q), NULL, \"\");\n\n    {\n        tt_ptrstk_iter_t pos;\n        tt_ptrstk_iter(&q, &pos);\n        i = 0;\n        while (tt_ptrstk_iter_next(&pos) != NULL) {\n            ++i;\n        }\n        TT_UT_EQUAL(i, 0, \"\");\n    }\n\n    for (i = 0; i < __q_size; ++i) {\n        ret = tt_ptrstk_push(&q, &v[i]);\n        TT_UT_SUCCESS(ret, \"\");\n        TT_UT_EQUAL(tt_ptrstk_top(&q), &v[i], \"\");\n    }\n    TT_UT_EQUAL(tt_ptrstk_count(&q), __q_size, \"\");\n\n    {\n        tt_ptrstk_iter_t pos;\n        tt_ptr_t p;\n\n        tt_ptrstk_iter(&q, &pos);\n        i = 0;\n        while ((p = tt_ptrstk_iter_next(&pos)) != NULL) {\n            TT_UT_EQUAL(p, &v[i++], \"\");\n        }\n        TT_UT_EQUAL(i, __q_size, \"\");\n    }\n\n    n = tt_rand_u32() % __q_size;\n    for (i = __q_size - 1; i >= (__q_size - n); --i) {\n        TT_UT_EQUAL(tt_ptrstk_pop(&q), &v[i], \"\");\n        TT_UT_EQUAL(tt_ptrstk_top(&q), &v[i - 1], \"\");\n    }\n    TT_UT_EQUAL(tt_ptrstk_count(&q), __q_size - n, \"\");\n\n    for (i = __q_size - n; i < __q_size; ++i) {\n        ret = tt_ptrstk_push(&q, &v[i]);\n        TT_UT_SUCCESS(ret, \"\");\n    }\n    TT_UT_EQUAL(tt_ptrstk_count(&q), __q_size, \"\");\n\n    for (i = __q_size - 1; i >= (__q_size - q.ptr_per_frame); --i) {\n        TT_UT_EQUAL(tt_ptrstk_pop(&q), &v[i], \"\");\n    }\n    TT_UT_EQUAL(tt_ptrstk_count(&q), (__q_size - q.ptr_per_frame), \"\");\n\n    tt_ptrstk_clear(&q);\n    TT_UT_EQUAL(tt_ptrstk_pop(&q), NULL, \"\");\n    TT_UT_EQUAL(tt_ptrstk_top(&q), NULL, \"\");\n\n    tt_ptrstk_destroy(&q);\n\n    // test end\n    TT_TEST_CASE_LEAVE()\n}", "item_id": 0, "repo": "newser/TitanSDK", "file": "platform/source/algorithm/test_case/tt_ut_stack.c", "last_update_at": "2018-12-07T07:12:06+00:00", "question_id": "f93e4c05d1772227b8a5334da8f209b89ec62807_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["TT_TEST_ROUTINE_DEFINE(case_ptr_stack)\n{\n    // tt_u32_t param = TT_TEST_ROUTINE_PARAM(tt_u32_t);\n    tt_u32_t v[__q_size] = {0};\n    tt_u32_t i, n;\n    tt_result_t ret;\n    tt_ptrstk_t q;\n    TT_TEST_CASE_ENTER()\n    // test start\n    for (i = 0; i < __q_size; ++i) {\n        v[i] = i;\n    }\n    tt_ptrstk_init(&q, NULL);\n    tt_ptrstk_clear(&q);\n    TT_UT_EQUAL(tt_ptrstk_count(&q), 0, \"\");\n    TT_UT_EQUAL(tt_ptrstk_empty(&q), TT_TRUE, \"\");\n    TT_UT_EQUAL(tt_ptrstk_top(&q), NULL, \"\");\n    TT_UT_EQUAL(tt_ptrstk_pop(&q), NULL, \"\");\n    {\n        tt_ptrstk_iter_t pos;\n        tt_ptrstk_iter(&q, &pos);\n        i = 0;\n        while (tt_ptrstk_iter_next(&pos) != NULL) {\n            ++i;\n        }\n        TT_UT_EQUAL(i, 0, \"\");\n    }\n    for (i = 0; i < __q_size; ++i) {\n        ret = tt_ptrstk_push(&q, &v[i]);\n        TT_UT_SUCCESS(ret, \"\");\n        TT_UT_EQUAL(tt_ptrstk_top(&q), &v[i], \"\");\n    }\n    TT_UT_EQUAL(tt_ptrstk_count(&q), __q_size, \"\");\n    {\n        tt_ptrstk_iter_t pos;\n        tt_ptr_t p;\n        tt_ptrstk_iter(&q, &pos);\n        i = 0;\n        while ((p = tt_ptrstk_iter_next(&pos)) != NULL) {\n            TT_UT_EQUAL(p, &v[i++], \"\");\n        }\n        TT_UT_EQUAL(i, __q_size, \"\");\n    }\n    n = tt_rand_u32() % __q_size;\n    for (i = __q_size - 1; i >= (__q_size - n); --i) {\n        TT_UT_EQUAL(tt_ptrstk_pop(&q), &v[i], \"\");\n        TT_UT_EQUAL(tt_ptrstk_top(&q), &v[i - 1], \"\");\n    }\n    TT_UT_EQUAL(tt_ptrstk_count(&q), __q_size - n, \"\");\n    for (i = __q_size - n; i < __q_size; ++i) {\n        ret = tt_ptrstk_push(&q, &v[i]);\n        TT_UT_SUCCESS(ret, \"\");\n    }\n    TT_UT_EQUAL(tt_ptrstk_count(&q), __q_size, \"\");\n    for (i = __q_size - 1; i >= (__q_size - q.ptr_per_frame); --i) {\n        TT_UT_EQUAL(tt_ptrstk_pop(&q), &v[i], \"\");\n    }\n    TT_UT_EQUAL(tt_ptrstk_count(&q), (__q_size - q.ptr_per_frame), \"\");\n    tt_ptrstk_clear(&q);\n    TT_UT_EQUAL(tt_ptrstk_pop(&q), NULL, \"\");\n    TT_UT_EQUAL(tt_ptrstk_top(&q), NULL, \"\");\n    tt_ptrstk_destroy(&q);\n    // test end\n    TT_TEST_CASE_LEAVE()\n"]], "pred": {"ppl": 1.375600814819336, "ppl_lower": 1.4863603115081787, "ppl/lowercase_ppl": -1.2428412680937606, "ppl/zlib": 0.0006051054875013375, "Min_5.0% Prob": 4.571280068042231, "Min_10.0% Prob": 2.8470865879573073, "Min_20.0% Prob": 1.571262395301578, "Min_30.0% Prob": 1.0623070260668113, "Min_40.0% Prob": 0.7968943725558667, "Min_50.0% Prob": 0.6382429953771616, "Min_60.0% Prob": 0.5321367391972722}}
{"hexsha": "9aaa0eac44e084ee1cb9c31116aa48285ea8377b", "ext": "c", "lang": "C", "content": "int\ntarget_supports_disable_randomization (void)\n{\n  struct target_ops *t;\n\n  for (t = &current_target; t != NULL; t = t->beneath)\n    if (t->to_supports_disable_randomization)\n      return t->to_supports_disable_randomization ();\n\n  return 0;\n}", "item_id": 66, "repo": "cooljeanius/DragonFlyBSD", "file": "contrib/gdb-7/gdb/target.c", "last_update_at": "2018-01-12T03:55:33+00:00", "question_id": "9aaa0eac44e084ee1cb9c31116aa48285ea8377b_66", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\ntarget_supports_disable_randomization (void)\n{\n  struct target_ops *t;\n  for (t = &current_target; t != NULL; t = t->beneath)\n    if (t->to_supports_disable_randomization)\n      return t->to_supports_disable_randomization ();\n  return 0;\n"]], "pred": {"ppl": 2.3479626178741455, "ppl_lower": 2.5777907371520996, "ppl/lowercase_ppl": -1.109407730723488, "ppl/zlib": 0.005767216087850444, "Min_5.0% Prob": 8.906633377075195, "Min_10.0% Prob": 6.540124773979187, "Min_20.0% Prob": 3.8832798495012173, "Min_30.0% Prob": 2.82514251768589, "Min_40.0% Prob": 2.151995585858822, "Min_50.0% Prob": 1.7219688306901266, "Min_60.0% Prob": 1.4322147407340553}}
{"hexsha": "a95399562d50d74c079bf3135fae936946b14f30", "ext": "c", "lang": "C", "content": "void tracking_image_accessor_destroy(TrackingImageAccessor *accessor)\n{\n\tIMB_moviecache_free(accessor->cache);\n\tlibmv_FrameAccessorDestroy(accessor->libmv_accessor);\n\tMEM_freeN(accessor);\n}", "item_id": 25, "repo": "1-MillionParanoidTterabytes/Blender-2.79b-blackened", "file": "source/blender/blenkernel/intern/tracking_util.c", "last_update_at": "2018-06-18T01:50:32+00:00", "question_id": "a95399562d50d74c079bf3135fae936946b14f30_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void tracking_image_accessor_destroy(TrackingImageAccessor *accessor)\n{\n\tIMB_moviecache_free(accessor->cache);\n\tlibmv_FrameAccessorDestroy(accessor->libmv_accessor);\n\tMEM_freeN(accessor);\n"]], "pred": {"ppl": 11.515667915344238, "ppl_lower": 15.176478385925293, "ppl/lowercase_ppl": -1.1129587326495722, "ppl/zlib": 0.019394512186732746, "Min_5.0% Prob": 12.064372380574545, "Min_10.0% Prob": 10.805218060811361, "Min_20.0% Prob": 9.162005277780386, "Min_30.0% Prob": 7.276083832979202, "Min_40.0% Prob": 5.899669436308054, "Min_50.0% Prob": 4.840216799215837, "Min_60.0% Prob": 4.059764087200165}}
{"hexsha": "c570e54f40a3b5fa76324ed92f768954222760fb", "ext": "c", "lang": "C", "content": "static tb_pointer_t tb_single_list_itor_item(tb_iterator_ref_t iterator, tb_size_t itor)\n{\n    // check\n    tb_single_list_t* list = (tb_single_list_t*)iterator;\n    tb_assert(list && itor);\n\n    // data\n    return list->element.data(&list->element, (tb_cpointer_t)(((tb_single_list_entry_t*)itor) + 1));\n}", "item_id": 4, "repo": "gari001/tbox", "file": "src/tbox/container/single_list.c", "last_update_at": "2018-07-07T17:14:09+00:00", "question_id": "c570e54f40a3b5fa76324ed92f768954222760fb_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static tb_pointer_t tb_single_list_itor_item(tb_iterator_ref_t iterator, tb_size_t itor)\n{\n    // check\n    tb_single_list_t* list = (tb_single_list_t*)iterator;\n    tb_assert(list && itor);\n    // data\n    return list->element.data(&list->element, (tb_cpointer_t)(((tb_single_list_entry_t*)itor) + 1));\n"]], "pred": {"ppl": 2.277170419692993, "ppl_lower": 2.277170419692993, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.004898414453804813, "Min_5.0% Prob": 7.559865951538086, "Min_10.0% Prob": 5.98879079023997, "Min_20.0% Prob": 3.9141191989183426, "Min_30.0% Prob": 2.696555877859528, "Min_40.0% Prob": 2.072033496687607, "Min_50.0% Prob": 1.643251037390362, "Min_60.0% Prob": 1.3782270032207709}}
{"hexsha": "ec9a327c7e46d6d141f24f194b60533824ec5a4f", "ext": "c", "lang": "C", "content": "void\nmono_gc_add_memory_pressure (gint64 value)\n{\n\t/* FIXME: Use interlocked functions */\n\tLOCK_GC;\n\tmemory_pressure += value;\n\tUNLOCK_GC;\n}", "item_id": 70, "repo": "zlxy/Genesis-3D", "file": "Engine/extlibs/IosLibs/mono-2.6.7/mono/metadata/sgen-gc.c", "last_update_at": "2018-09-30T23:46:57+00:00", "question_id": "ec9a327c7e46d6d141f24f194b60533824ec5a4f_70", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nmono_gc_add_memory_pressure (gint64 value)\n{\n\t/* FIXME: Use interlocked functions */\n\tLOCK_GC;\n\tmemory_pressure += value;\n\tUNLOCK_GC;\n"]], "pred": {"ppl": 4.992051601409912, "ppl_lower": 6.16394567489624, "ppl/lowercase_ppl": -1.1311506259709476, "ppl/zlib": 0.013287991469707421, "Min_5.0% Prob": 8.300281524658203, "Min_10.0% Prob": 7.496312999725342, "Min_20.0% Prob": 6.138928500088778, "Min_30.0% Prob": 4.894937136593987, "Min_40.0% Prob": 3.9470120564751, "Min_50.0% Prob": 3.187928741348201, "Min_60.0% Prob": 2.7349883563378277}}
{"hexsha": "107fe8011a1f935551c4cfef6f93b765921af27b", "ext": "c", "lang": "C", "content": "static int win32_path_to_8(git_buf *dest, const wchar_t *src)\n{\n\tgit_win32_utf8_path utf8_path;\n\n\tif (git_win32_path_to_utf8(utf8_path, src) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to convert path to UTF-8\");\n\t\treturn -1;\n\t}\n\n\t/* Convert backslashes to forward slashes */\n\tgit_path_mkposix(utf8_path);\n\n\treturn git_buf_sets(dest, utf8_path);\n}", "item_id": 1, "repo": "BonexGu/Blik2D", "file": "Blik2D/addon/libgit2-0.22.2_for_blik/src/win32/findfile.c", "last_update_at": "2018-06-06T04:18:03+00:00", "question_id": "107fe8011a1f935551c4cfef6f93b765921af27b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int win32_path_to_8(git_buf *dest, const wchar_t *src)\n{\n\tgit_win32_utf8_path utf8_path;\n\tif (git_win32_path_to_utf8(utf8_path, src) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to convert path to UTF-8\");\n\t\treturn -1;\n\t}\n\t/* Convert backslashes to forward slashes */\n\tgit_path_mkposix(utf8_path);\n\treturn git_buf_sets(dest, utf8_path);\n"]], "pred": {"ppl": 1.9267005920410156, "ppl_lower": 2.1990160942077637, "ppl/lowercase_ppl": -1.2015846500944558, "ppl/zlib": 0.002927718759763117, "Min_5.0% Prob": 6.628968715667725, "Min_10.0% Prob": 4.689730834960938, "Min_20.0% Prob": 3.0230823274581664, "Min_30.0% Prob": 2.1409146449667342, "Min_40.0% Prob": 1.6306878104805946, "Min_50.0% Prob": 1.308219212472816, "Min_60.0% Prob": 1.1016196251618973}}
{"hexsha": "870c67cf1c637cfc78715bd3d821a55195db7d24", "ext": "c", "lang": "C", "content": "static int isn_decode_op1(struct sparc_isn *isn)\n{\n\tstruct sparc_ifmt_op1 *i = to_ifmt(op1, isn);\n\n\t/* Only Call instruction is of op1 type */\n\ti->isn.id = SI_CALL;\n\ti->isn.fmt = SIF_OP1;\n\ti->disp30 = ISN_OP1_DISP(isn->op);\n\treturn 0;\n}", "item_id": 0, "repo": "repk/sporc", "file": "src/cpu/sparc/decoder.c", "last_update_at": "2018-11-10T04:17:56+00:00", "question_id": "870c67cf1c637cfc78715bd3d821a55195db7d24_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int isn_decode_op1(struct sparc_isn *isn)\n{\n\tstruct sparc_ifmt_op1 *i = to_ifmt(op1, isn);\n\t/* Only Call instruction is of op1 type */\n\ti->isn.id = SI_CALL;\n\ti->isn.fmt = SIF_OP1;\n\ti->disp30 = ISN_OP1_DISP(isn->op);\n\treturn 0;\n"]], "pred": {"ppl": 6.675022125244141, "ppl_lower": 7.258322715759277, "ppl/lowercase_ppl": -1.0441305652597352, "ppl/zlib": 0.01078620749388714, "Min_5.0% Prob": 11.17298927307129, "Min_10.0% Prob": 9.202636978842996, "Min_20.0% Prob": 6.866954876028973, "Min_30.0% Prob": 5.472701794760567, "Min_40.0% Prob": 4.502504110336304, "Min_50.0% Prob": 3.7223111583014665, "Min_60.0% Prob": 3.178356028880392}}
{"hexsha": "cfb52f18eb22f22d020e63008c943df637f42ffe", "ext": "c", "lang": "C", "content": "void *\nkalloc(usize size)\n{\n    spin_lock(vm_global_lock);\n\n    void *ret = NULL;\n    int16 sector_id = -1;\n    if (size <= SECTOR0_BOUND)\n    {\n        sector_id = 0;\n    }\n    else if (size <= SECTOR1_BOUND)\n    {\n        sector_id = 1;\n    }\n    else if (size < PAGE_SIZE)\n    {\n        sector_id = 2;\n    }\n\n    if (sector_id >= 0)\n    { ret = vm_alloc(size, sector_id); }\n    else\n    { ret = vm_alloc_multpages(size); }\n    //void *ret = (void *) R_PADDR((paddr) vm_alloc(size, sector_id));\n    kprintf(\"Allocated Virtual: 0x%x Size: %d\\n\", ret, (uint64) size);\n    /* Hack */\n    int32 status = ESUCCESS;\n    if (ret != NULL)\n    {\n        // check if the target page is already mapped\n        // ret val does not cross page boundries\n        if (get_paddr(read_cr3(), (uintptr) ret) == (uintptr) NULL)\n        {\n            uintptr frame = (uintptr) pmalloc(PAGE_SIZE);\n            uint64 map_stat = map_vmem(read_cr3(), (uintptr) ret, frame);\n            status = (frame != (uintptr) NULL) && (map_stat != ESUCCESS);\n        }\n    }\n\n    if (status != ESUCCESS)\n    {\n        ret = NULL;\n    }\n    else\n    {\n        flush_tlb();\n    }\n\n    spin_unlock(vm_global_lock);\n    return ret;\n}", "item_id": 4, "repo": "mohammad-yazdani/curros", "file": "src/vmm.c", "last_update_at": "2018-12-03T13:08:21+00:00", "question_id": "cfb52f18eb22f22d020e63008c943df637f42ffe_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void *\nkalloc(usize size)\n{\n    spin_lock(vm_global_lock);\n    void *ret = NULL;\n    int16 sector_id = -1;\n    if (size <= SECTOR0_BOUND)\n    {\n        sector_id = 0;\n    }\n    else if (size <= SECTOR1_BOUND)\n    {\n        sector_id = 1;\n    }\n    else if (size < PAGE_SIZE)\n    {\n        sector_id = 2;\n    }\n    if (sector_id >= 0)\n    { ret = vm_alloc(size, sector_id); }\n    else\n    { ret = vm_alloc_multpages(size); }\n    //void *ret = (void *) R_PADDR((paddr) vm_alloc(size, sector_id));\n    kprintf(\"Allocated Virtual: 0x%x Size: %d\\n\", ret, (uint64) size);\n    /* Hack */\n    int32 status = ESUCCESS;\n    if (ret != NULL)\n    {\n        // check if the target page is already mapped\n        // ret val does not cross page boundries\n        if (get_paddr(read_cr3(), (uintptr) ret) == (uintptr) NULL)\n        {\n            uintptr frame = (uintptr) pmalloc(PAGE_SIZE);\n            uint64 map_stat = map_vmem(read_cr3(), (uintptr) ret, frame);\n            status = (frame != (uintptr) NULL) && (map_stat != ESUCCESS);\n        }\n    }\n    if (status != ESUCCESS)\n    {\n        ret = NULL;\n    }\n    else\n    {\n        flush_tlb();\n    }\n    spin_unlock(vm_global_lock);\n    return ret;\n"]], "pred": {"ppl": 3.3267035484313965, "ppl_lower": 3.478543758392334, "ppl/lowercase_ppl": -1.0371318886859417, "ppl/zlib": 0.002384884699001251, "Min_5.0% Prob": 9.001906720074741, "Min_10.0% Prob": 7.0297291331821015, "Min_20.0% Prob": 4.894006901317173, "Min_30.0% Prob": 3.7082876951606187, "Min_40.0% Prob": 2.9190207592315143, "Min_50.0% Prob": 2.3818315877517064, "Min_60.0% Prob": 1.9996765060695234}}
{"hexsha": "f9ea73c7054e98e3305565e3cd943fb03427030f", "ext": "h", "lang": "C", "content": "static inline hri_oscctrl_intflag_reg_t hri_oscctrl_get_INTFLAG_reg(const void *const         hw,\n                                                                    hri_oscctrl_intflag_reg_t mask)\n{\n\tuint32_t tmp;\n\ttmp = ((Oscctrl *)hw)->INTFLAG.reg;\n\ttmp &= mask;\n\treturn tmp;\n}", "item_id": 0, "repo": "BreederBai/rt-thread", "file": "bsp/microchip/saml10/bsp/hri/hri_oscctrl_l10.h", "last_update_at": "2018-11-27T02:48:44+00:00", "question_id": "f9ea73c7054e98e3305565e3cd943fb03427030f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline hri_oscctrl_intflag_reg_t hri_oscctrl_get_INTFLAG_reg(const void *const         hw,\n                                                                    hri_oscctrl_intflag_reg_t mask)\n{\n\tuint32_t tmp;\n\ttmp = ((Oscctrl *)hw)->INTFLAG.reg;\n\ttmp &= mask;\n\treturn tmp;\n"]], "pred": {"ppl": 1.574633240699768, "ppl_lower": 1.9946305751800537, "ppl/lowercase_ppl": -1.520759515495722, "ppl/zlib": 0.0030471300812954416, "Min_5.0% Prob": 6.060254216194153, "Min_10.0% Prob": 4.341379854414198, "Min_20.0% Prob": 2.3569575068785955, "Min_30.0% Prob": 1.5493529665781636, "Min_40.0% Prob": 1.1524088692549879, "Min_50.0% Prob": 0.9172759465160495, "Min_60.0% Prob": 0.7618230042782547}}
{"hexsha": "7985ebbb69cd8587569a95ffc9b524311651bd4c", "ext": "h", "lang": "C", "content": "interface TSKernelClock : TSClock {\n\n\tunsigned _service;\n\tunsigned _connection;\n\tIONotificationPortRef _notificationPort;\n\n}", "item_id": 0, "repo": "lechium/tvOS10Headers", "file": "System/Library/PrivateFrameworks/TimeSync.framework/TSKernelClock.h", "last_update_at": "2018-08-04T20:16:32+00:00", "question_id": "7985ebbb69cd8587569a95ffc9b524311651bd4c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface TSKernelClock : TSClock {\n\tunsigned _service;\n\tunsigned _connection;\n\tIONotificationPortRef _notificationPort;\n"]], "pred": {"ppl": 8.883526802062988, "ppl_lower": 17.207826614379883, "ppl/lowercase_ppl": -1.3027040046709006, "ppl/zlib": 0.02228774123010665, "Min_5.0% Prob": 10.278444290161133, "Min_10.0% Prob": 9.795832316080729, "Min_20.0% Prob": 7.430062634604318, "Min_30.0% Prob": 6.103781483390114, "Min_40.0% Prob": 5.1443757057189945, "Min_50.0% Prob": 4.265288720005437, "Min_60.0% Prob": 3.7368235019120304}}
{"hexsha": "049d707753abcbd3e6e024b1d920784bb56d039e", "ext": "h", "lang": "C", "content": "interface _DKEventIntersection : NSObject {\n\n\tNSDate* _startDate;\n\tNSDate* _endDate;\n\tNSArray* _events;\n\n}", "item_id": 0, "repo": "lechium/tvOS10Headers", "file": "System/Library/PrivateFrameworks/CoreDuet.framework/_DKEventIntersection.h", "last_update_at": "2018-08-04T20:16:32+00:00", "question_id": "049d707753abcbd3e6e024b1d920784bb56d039e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface _DKEventIntersection : NSObject {\n\tNSDate* _startDate;\n\tNSDate* _endDate;\n\tNSArray* _events;\n"]], "pred": {"ppl": 4.590646266937256, "ppl_lower": 10.17988109588623, "ppl/lowercase_ppl": -1.5225601323839435, "ppl/zlib": 0.017318418330207103, "Min_5.0% Prob": 10.988111019134521, "Min_10.0% Prob": 8.708817839622498, "Min_20.0% Prob": 6.032271385192871, "Min_30.0% Prob": 4.642199556032817, "Min_40.0% Prob": 3.704326916486025, "Min_50.0% Prob": 3.03956674747169, "Min_60.0% Prob": 2.537260190350935}}
{"hexsha": "bf3a19ae1a02de45b0131a47263a258d24d439de", "ext": "c", "lang": "C", "content": "static int\nScanKey(\n    const char *s1,\n    const char *s2,\n    const char *e1,\n    const char *e2,\n    const char **res1,\n    const char **res2)\n{\n    *res1 = s1;\n    *res2 = s2;\n    /* Scan word chars until : or $ ends the keyword.\n       They must be equal up to that point. */\n    while (s1 < e1 && s2 < e2) {\n\tif ((*s1 == ':' || *s1 == '$') && (*s2 == ':' || *s2 == '$')) {\n\t    /* The keyword part has ended on both sides */\n\n\t    /* To be a bit conservative and not confuse keywords with e.g.\n\t       Tcl namespace variables we only acknowledge these forms:\n\t       keyword$\n\t       keyword:$\n\t       keyword: .*$\n\t       keyword:: .*$\n\t    */\n\t    if (*s1 == ':') {\n\t\ts1++;\n\t\tif (s1 + 1 >= e1) {\n\t\t    return 1;\n\t\t}\n\t\t/* May be a double colon */\n\t\tif (*s1 == ':') {\n\t\t    s1++;\n\t\t}\n\t\t/* Colon must be followed by space or $ */\n\t\tif (*s1 != ' ' && *s1 != '$') {\n\t\t    return 1;\n\t\t}\n\t    }\n\t    if (*s2 == ':') {\n\t\ts2++;\n\t\tif (s2 + 1 >= e2) {\n\t\t    return 1;\n\t\t}\n\t\tif (*s2 == ':') {\n\t\t    s2++;\n\t\t}\n\t\tif (*s2 != ' ' && *s2 != '$') {\n\t\t    return 1;\n\t\t}\n\t    }\n\t    break;\n\t}\n\tif (*s1 != *s2) {\n\t    /* They are not equal keywords */\n\t    return 0;\n\t}\n\t/* Only standard ascii word chars count */\n\tif ((*s1 >= 'a' && *s1 <= 'z') || (*s1 >= 'A' && *s1 <= 'Z')) {\n\t    s1++;\n\t    s2++;\n\t} else {\n\t    /* This did not count as a keyword but is sofar equal. */\n\t    *res1 = s1;\n\t    *res2 = s2;\n\t    return 1;\n\t}\n    }\n    /* Skip all until $ */\n    while (s1 < e1) {\n\tif (*s1 == '$') {\n\t    break;\n\t}\n\ts1++;\n    }\n    while (s2 < e2) {\n\tif (*s2 == '$') {\n\t    break;\n\t}\n\ts2++;\n    }\n    /* At this point s1/2 should point to the dollar ending the keyword. */\n    if (s1 == e1 || s2 == e2) {\n\t/* We reached the end of string without finishing the keyword.\n\t   If a potential keyword is at the end we don't care. */\n\treturn 1;\n    }\n    /* Strings are equal up to this point. Skip the last dollar as well. */\n    *res1 = s1 + 1;\n    *res2 = s2 + 1;\n    return 1;\n}", "item_id": 0, "repo": "pspjuth/DiffUtilTcl", "file": "generic/comparefiles.c", "last_update_at": "2018-01-05T00:23:08+00:00", "question_id": "bf3a19ae1a02de45b0131a47263a258d24d439de_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nScanKey(\n    const char *s1,\n    const char *s2,\n    const char *e1,\n    const char *e2,\n    const char **res1,\n    const char **res2)\n{\n    *res1 = s1;\n    *res2 = s2;\n    /* Scan word chars until : or $ ends the keyword.\n       They must be equal up to that point. */\n    while (s1 < e1 && s2 < e2) {\n\tif ((*s1 == ':' || *s1 == '$') && (*s2 == ':' || *s2 == '$')) {\n\t    /* The keyword part has ended on both sides */\n\t    /* To be a bit conservative and not confuse keywords with e.g.\n\t       Tcl namespace variables we only acknowledge these forms:\n\t       keyword$\n\t       keyword:$\n\t       keyword: .*$\n\t       keyword:: .*$\n\t    */\n\t    if (*s1 == ':') {\n\t\ts1++;\n\t\tif (s1 + 1 >= e1) {\n\t\t    return 1;\n\t\t}\n\t\t/* May be a double colon */\n\t\tif (*s1 == ':') {\n\t\t    s1++;\n\t\t}\n\t\t/* Colon must be followed by space or $ */\n\t\tif (*s1 != ' ' && *s1 != '$') {\n\t\t    return 1;\n\t\t}\n\t    }\n\t    if (*s2 == ':') {\n\t\ts2++;\n\t\tif (s2 + 1 >= e2) {\n\t\t    return 1;\n\t\t}\n\t\tif (*s2 == ':') {\n\t\t    s2++;\n\t\t}\n\t\tif (*s2 != ' ' && *s2 != '$') {\n\t\t    return 1;\n\t\t}\n\t    }\n\t    break;\n\t}\n\tif (*s1 != *s2) {\n\t    /* They are not equal keywords */\n\t    return 0;\n\t}\n\t/* Only standard ascii word chars count */\n\tif ((*s1 >= 'a' && *s1 <= 'z') || (*s1 >= 'A' && *s1 <= 'Z')) {\n\t    s1++;\n\t    s2++;\n\t} else {\n\t    /* This did not count as a keyword but is sofar equal. */\n\t    *res1 = s1;\n\t    *res2 = s2;\n\t    return 1;\n\t}\n    }\n    /* Skip all until $ */\n    while (s1 < e1) {\n\tif (*s1 == '$') {\n\t    break;\n\t}\n\ts1++;\n    }\n    while (s2 < e2) {\n\tif (*s2 == '$') {\n\t    break;\n\t}\n\ts2++;\n    }\n    /* At this point s1/2 should point to the dollar ending the keyword. */\n    if (s1 == e1 || s2 == e2) {\n\t/* We reached the end of string without finishing the keyword.\n\t   If a potential keyword is at the end we don't care. */\n\treturn 1;\n    }\n    /* Strings are equal up to this point. Skip the last dollar as well. */\n    *res1 = s1 + 1;\n    *res2 = s2 + 1;\n    return 1;\n"]], "pred": {"ppl": 2.232682943344116, "ppl_lower": 2.263134479522705, "ppl/lowercase_ppl": -1.0168659701698506, "ppl/zlib": 0.001055458575450789, "Min_5.0% Prob": 6.878935627821015, "Min_10.0% Prob": 5.352724651011025, "Min_20.0% Prob": 3.5976182106769445, "Min_30.0% Prob": 2.60330981317802, "Min_40.0% Prob": 1.9922684773576982, "Min_50.0% Prob": 1.6045711233090718, "Min_60.0% Prob": 1.3376135572951025}}
{"hexsha": "d01d311d0d5449114c65b2eae1b8d1415421293e", "ext": "c", "lang": "C", "content": "static VALUE keychain_item_port(VALUE self)\n{\n\tVALUE integer_str = keychain_item_get_attribute(self, kSecPortItemAttr);\n\tVALUE integer_obj = rb_funcall(integer_str, rb_intern(\"to_i\"), 0);\n\treturn integer_obj;\n}", "item_id": 13, "repo": "WIZARDISHUNGRY/keychain_services", "file": "ext/keychain/item.c", "last_update_at": "2018-02-13T05:41:57+00:00", "question_id": "d01d311d0d5449114c65b2eae1b8d1415421293e_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static VALUE keychain_item_port(VALUE self)\n{\n\tVALUE integer_str = keychain_item_get_attribute(self, kSecPortItemAttr);\n\tVALUE integer_obj = rb_funcall(integer_str, rb_intern(\"to_i\"), 0);\n\treturn integer_obj;\n"]], "pred": {"ppl": 3.0028207302093506, "ppl_lower": 4.531996726989746, "ppl/lowercase_ppl": -1.3743438207886376, "ppl/zlib": 0.007479946192648158, "Min_5.0% Prob": 9.022029876708984, "Min_10.0% Prob": 7.637664658682687, "Min_20.0% Prob": 4.883523027102153, "Min_30.0% Prob": 3.519049608189127, "Min_40.0% Prob": 2.781774339079857, "Min_50.0% Prob": 2.2191220221942975, "Min_60.0% Prob": 1.8385372389026957}}
{"hexsha": "db9152239f9d403fcd42c93ed2f63fc51c367351", "ext": "c", "lang": "C", "content": "ZEPHIR_INIT_CLASS(Phalcon_Db_Adapter_Pdo_Sqlite) {\n\n\tZEPHIR_REGISTER_CLASS_EX(Phalcon\\\\Db\\\\Adapter\\\\Pdo, Sqlite, phalcon, db_adapter_pdo_sqlite, phalcon_db_adapter_pdo_ce, phalcon_db_adapter_pdo_sqlite_method_entry, 0);\n\n\tzend_declare_property_string(phalcon_db_adapter_pdo_sqlite_ce, SL(\"dialectType\"), \"sqlite\", ZEND_ACC_PROTECTED TSRMLS_CC);\n\n\tzend_declare_property_string(phalcon_db_adapter_pdo_sqlite_ce, SL(\"type\"), \"sqlite\", ZEND_ACC_PROTECTED TSRMLS_CC);\n\n\treturn SUCCESS;\n\n}", "item_id": 0, "repo": "davidofferman/cphalcon", "file": "ext/phalcon/db/adapter/pdo/sqlite.zep.c", "last_update_at": "2018-11-12T10:06:15+00:00", "question_id": "db9152239f9d403fcd42c93ed2f63fc51c367351_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ZEPHIR_INIT_CLASS(Phalcon_Db_Adapter_Pdo_Sqlite) {\n\tZEPHIR_REGISTER_CLASS_EX(Phalcon\\\\Db\\\\Adapter\\\\Pdo, Sqlite, phalcon, db_adapter_pdo_sqlite, phalcon_db_adapter_pdo_ce, phalcon_db_adapter_pdo_sqlite_method_entry, 0);\n\tzend_declare_property_string(phalcon_db_adapter_pdo_sqlite_ce, SL(\"dialectType\"), \"sqlite\", ZEND_ACC_PROTECTED TSRMLS_CC);\n\tzend_declare_property_string(phalcon_db_adapter_pdo_sqlite_ce, SL(\"type\"), \"sqlite\", ZEND_ACC_PROTECTED TSRMLS_CC);\n\treturn SUCCESS;\n"]], "pred": {"ppl": 1.1815471649169922, "ppl_lower": 2.4955804347991943, "ppl/lowercase_ppl": -5.481928886783801, "ppl/zlib": 0.0007253249407458391, "Min_5.0% Prob": 2.988189458847046, "Min_10.0% Prob": 1.666767186352185, "Min_20.0% Prob": 0.8335048256409463, "Min_30.0% Prob": 0.5603756541509028, "Min_40.0% Prob": 0.4170494044451622, "Min_50.0% Prob": 0.33520453151785123, "Min_60.0% Prob": 0.27803994182586184}}
{"hexsha": "04b818f8b85cb8b1fcb38f53c8fec2196238b4e9", "ext": "c", "lang": "C", "content": "static int\nstore_register_using_P (const struct regcache *regcache, \n\t\t\tstruct packet_reg *reg)\n{\n  struct gdbarch *gdbarch = get_regcache_arch (regcache);\n  struct remote_state *rs = get_remote_state ();\n  /* Try storing a single register.  */\n  char *buf = rs->buf;\n  gdb_byte regp[MAX_REGISTER_SIZE];\n  char *p;\n\n  if (remote_protocol_packets[PACKET_P].support == PACKET_DISABLE)\n    return 0;\n\n  if (reg->pnum == -1)\n    return 0;\n\n  xsnprintf (buf, get_remote_packet_size (), \"P%s=\", phex_nz (reg->pnum, 0));\n  p = buf + strlen (buf);\n  regcache_raw_collect (regcache, reg->regnum, regp);\n  bin2hex (regp, p, register_size (gdbarch, reg->regnum));\n  putpkt (rs->buf);\n  getpkt (&rs->buf, &rs->buf_size, 0);\n\n  switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_P]))\n    {\n    case PACKET_OK:\n      return 1;\n    case PACKET_ERROR:\n      error (_(\"Could not write register \\\"%s\\\"; remote failure reply '%s'\"),\n\t     gdbarch_register_name (gdbarch, reg->regnum), rs->buf);\n    case PACKET_UNKNOWN:\n      return 0;\n    default:\n      internal_error (__FILE__, __LINE__, _(\"Bad result from packet_ok\"));\n    }\n}", "item_id": 99, "repo": "cooljeanius/DragonFlyBSD", "file": "contrib/gdb-7/gdb/remote.c", "last_update_at": "2018-01-12T03:55:33+00:00", "question_id": "04b818f8b85cb8b1fcb38f53c8fec2196238b4e9_99", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nstore_register_using_P (const struct regcache *regcache, \n\t\t\tstruct packet_reg *reg)\n{\n  struct gdbarch *gdbarch = get_regcache_arch (regcache);\n  struct remote_state *rs = get_remote_state ();\n  /* Try storing a single register.  */\n  char *buf = rs->buf;\n  gdb_byte regp[MAX_REGISTER_SIZE];\n  char *p;\n  if (remote_protocol_packets[PACKET_P].support == PACKET_DISABLE)\n    return 0;\n  if (reg->pnum == -1)\n    return 0;\n  xsnprintf (buf, get_remote_packet_size (), \"P%s=\", phex_nz (reg->pnum, 0));\n  p = buf + strlen (buf);\n  regcache_raw_collect (regcache, reg->regnum, regp);\n  bin2hex (regp, p, register_size (gdbarch, reg->regnum));\n  putpkt (rs->buf);\n  getpkt (&rs->buf, &rs->buf_size, 0);\n  switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_P]))\n    {\n    case PACKET_OK:\n      return 1;\n    case PACKET_ERROR:\n      error (_(\"Could not write register \\\"%s\\\"; remote failure reply '%s'\"),\n\t     gdbarch_register_name (gdbarch, reg->regnum), rs->buf);\n    case PACKET_UNKNOWN:\n      return 0;\n    default:\n      internal_error (__FILE__, __LINE__, _(\"Bad result from packet_ok\"));\n    }\n"]], "pred": {"ppl": 1.7647663354873657, "ppl_lower": 2.0406746864318848, "ppl/lowercase_ppl": -1.2557350522191335, "ppl/zlib": 0.0010143183817774345, "Min_5.0% Prob": 5.779212691567161, "Min_10.0% Prob": 4.229895881631157, "Min_20.0% Prob": 2.6422669284723024, "Min_30.0% Prob": 1.8494958980291178, "Min_40.0% Prob": 1.4096834553744306, "Min_50.0% Prob": 1.133547132699327, "Min_60.0% Prob": 0.9458815372922937}}
{"hexsha": "3eeb553552b92b26d98cf3cf78de38d0e9549ab3", "ext": "c", "lang": "C", "content": "static int adb_setup(void)\n{\n\tstruct adb_dev *dev;\n\tint ret;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&dev->lock);\n\n\tspin_lock_init(&open_lock);\n\n\tinit_waitqueue_head(&dev->read_wq);\n\tinit_waitqueue_head(&dev->write_wq);\n\n\tatomic_set(&dev->open_excl, 0);\n\tatomic_set(&dev->read_excl, 0);\n\tatomic_set(&dev->write_excl, 0);\n\n\tINIT_LIST_HEAD(&dev->tx_idle);\n\n\t_adb_dev = dev;\n\n\tret = misc_register(&adb_device);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\n err:\n\tkfree(dev);\n\tprintk(KERN_ERR \"%s %s %d: adb gadget driver failed to initialize\\n\", __FILE__, __func__,\n\t       __LINE__);\n\treturn ret;\n}", "item_id": 15, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/drivers/usb/gadget/f_adb.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "3eeb553552b92b26d98cf3cf78de38d0e9549ab3_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int adb_setup(void)\n{\n\tstruct adb_dev *dev;\n\tint ret;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&dev->lock);\n\tspin_lock_init(&open_lock);\n\tinit_waitqueue_head(&dev->read_wq);\n\tinit_waitqueue_head(&dev->write_wq);\n\tatomic_set(&dev->open_excl, 0);\n\tatomic_set(&dev->read_excl, 0);\n\tatomic_set(&dev->write_excl, 0);\n\tINIT_LIST_HEAD(&dev->tx_idle);\n\t_adb_dev = dev;\n\tret = misc_register(&adb_device);\n\tif (ret)\n\t\tgoto err;\n\treturn 0;\n err:\n\tkfree(dev);\n\tprintk(KERN_ERR \"%s %s %d: adb gadget driver failed to initialize\\n\", __FILE__, __func__,\n\t       __LINE__);\n\treturn ret;\n"]], "pred": {"ppl": 1.894896388053894, "ppl_lower": 2.410078525543213, "ppl/lowercase_ppl": -1.3762651044554133, "ppl/zlib": 0.0017607828114348917, "Min_5.0% Prob": 6.935990503856114, "Min_10.0% Prob": 4.766957241913368, "Min_20.0% Prob": 2.9827008994959168, "Min_30.0% Prob": 2.10880532623692, "Min_40.0% Prob": 1.5963222571033038, "Min_50.0% Prob": 1.2766777272336185, "Min_60.0% Prob": 1.0684770456210073}}
{"hexsha": "9f0b8bfebddea4407f83f39269459204a2fd2dae", "ext": "h", "lang": "C", "content": "interface GEOCompanionRouteStatus : PBCodable <NSCopying> {\n    unsigned int  _distanceRemainingOnRoute;\n    unsigned int  _distanceToManeuver;\n    unsigned int  _distanceToRoute;\n    int  _feedbackType;\n    bool  _guidancePromptsEnabled;\n    struct { \n        unsigned int timestamp : 1; \n        unsigned int distanceRemainingOnRoute : 1; \n        unsigned int distanceToManeuver : 1; \n        unsigned int distanceToRoute : 1; \n        unsigned int feedbackType : 1; \n        unsigned int remainingTime : 1; \n        unsigned int routeLocationIndex : 1; \n        unsigned int routeLocationOffset : 1; \n        unsigned int stepID : 1; \n        unsigned int guidancePromptsEnabled : 1; \n    }  _has;\n    GEOLocation * _location;\n    unsigned int  _remainingTime;\n    NSData * _routeID;\n    unsigned int  _routeLocationIndex;\n    float  _routeLocationOffset;\n    GEOLatLng * _routeMatchCoordinate;\n    struct { \n        unsigned int *list; \n        unsigned long long count; \n        unsigned long long size; \n    }  _selectedRideIndexs;\n    unsigned int  _stepID;\n    double  _timestamp;\n}", "item_id": 0, "repo": "shaojiankui/iOS10-Runtime-Headers", "file": "PrivateFrameworks/GeoServices.framework/GEOCompanionRouteStatus.h", "last_update_at": "2018-10-08T04:12:25+00:00", "question_id": "9f0b8bfebddea4407f83f39269459204a2fd2dae_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface GEOCompanionRouteStatus : PBCodable <NSCopying> {\n    unsigned int  _distanceRemainingOnRoute;\n    unsigned int  _distanceToManeuver;\n    unsigned int  _distanceToRoute;\n    int  _feedbackType;\n    bool  _guidancePromptsEnabled;\n    struct { \n        unsigned int timestamp : 1; \n        unsigned int distanceRemainingOnRoute : 1; \n        unsigned int distanceToManeuver : 1; \n        unsigned int distanceToRoute : 1; \n        unsigned int feedbackType : 1; \n        unsigned int remainingTime : 1; \n        unsigned int routeLocationIndex : 1; \n        unsigned int routeLocationOffset : 1; \n        unsigned int stepID : 1; \n        unsigned int guidancePromptsEnabled : 1; \n    }  _has;\n    GEOLocation * _location;\n    unsigned int  _remainingTime;\n    NSData * _routeID;\n    unsigned int  _routeLocationIndex;\n    float  _routeLocationOffset;\n    GEOLatLng * _routeMatchCoordinate;\n    struct { \n        unsigned int *list; \n        unsigned long long count; \n        unsigned long long size; \n    }  _selectedRideIndexs;\n    unsigned int  _stepID;\n    double  _timestamp;\n"]], "pred": {"ppl": 1.8415039777755737, "ppl_lower": 2.6476693153381348, "ppl/lowercase_ppl": -1.594673222416547, "ppl/zlib": 0.001754547749926067, "Min_5.0% Prob": 6.5446405708789825, "Min_10.0% Prob": 4.828999802470207, "Min_20.0% Prob": 2.970287204705752, "Min_30.0% Prob": 2.0429330747194436, "Min_40.0% Prob": 1.5330352287327174, "Min_50.0% Prob": 1.2248315520331876, "Min_60.0% Prob": 1.0196931833943288}}
{"hexsha": "154bafcb85ab6b3c941e07c9978cdd89bbbeef30", "ext": "h", "lang": "C", "content": "interface RUILoader : RUIHTTPRequest {\n\n\tRUIParser* _parser;\n\tNSURL* _url;\n\tBOOL _allowNonSecureHTTP;\n\tid<RUIParserDelegate> _parserDelegate;\n\tRUIStyle* _style;\n\n}", "item_id": 0, "repo": "lechium/tvOS10Headers", "file": "System/Library/PrivateFrameworks/RemoteUI.framework/RUILoader.h", "last_update_at": "2018-08-04T20:16:32+00:00", "question_id": "154bafcb85ab6b3c941e07c9978cdd89bbbeef30_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface RUILoader : RUIHTTPRequest {\n\tRUIParser* _parser;\n\tNSURL* _url;\n\tBOOL _allowNonSecureHTTP;\n\tid<RUIParserDelegate> _parserDelegate;\n\tRUIStyle* _style;\n"]], "pred": {"ppl": 6.975965976715088, "ppl_lower": 9.921841621398926, "ppl/lowercase_ppl": -1.181350340131656, "ppl/zlib": 0.014496050816445625, "Min_5.0% Prob": 9.644086837768555, "Min_10.0% Prob": 7.861261208852132, "Min_20.0% Prob": 6.509050369262695, "Min_30.0% Prob": 5.417838480737474, "Min_40.0% Prob": 4.561437080303828, "Min_50.0% Prob": 3.740297273282082, "Min_60.0% Prob": 3.215406826219043}}
{"hexsha": "c484712e6e0aefb1754328829f5e967684ff8ffc", "ext": "h", "lang": "C", "content": "interface _MFMessageMediaPayload : NSObject <NSSecureCoding> {\n    NSString * _accessibilityLabel;\n    UIImage * _image;\n    bool  _isSticker;\n    NSURL * _mediaURL;\n    NSString * _text;\n}", "item_id": 0, "repo": "shaojiankui/iOS10-Runtime-Headers", "file": "Frameworks/MessageUI.framework/_MFMessageMediaPayload.h", "last_update_at": "2018-10-08T04:12:25+00:00", "question_id": "c484712e6e0aefb1754328829f5e967684ff8ffc_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface _MFMessageMediaPayload : NSObject <NSSecureCoding> {\n    NSString * _accessibilityLabel;\n    UIImage * _image;\n    bool  _isSticker;\n    NSURL * _mediaURL;\n    NSString * _text;\n"]], "pred": {"ppl": 4.221199035644531, "ppl_lower": 8.59203815460205, "ppl/lowercase_ppl": -1.4935124464388436, "ppl/zlib": 0.009796729383397838, "Min_5.0% Prob": 8.558709621429443, "Min_10.0% Prob": 7.113616228103638, "Min_20.0% Prob": 5.614299952983856, "Min_30.0% Prob": 4.332709701437699, "Min_40.0% Prob": 3.558703408241272, "Min_50.0% Prob": 2.8534602583386004, "Min_60.0% Prob": 2.41958358766217}}
{"hexsha": "0286a95c28925856222151785828fd9ee0b15fbc", "ext": "c", "lang": "C", "content": "JNICALL\nJava_nsk_jvmti_scenarios_hotswap_HS204_hs204t001_hs204t001_popFrame(JNIEnv * env,\n        jclass klass,\n        jthread thread) {\n    jint state;\n    NSK_DISPLAY0(\"Inside pop_Frame method.....\\n\");\n    if (NSK_CPP_STUB3(GetThreadState,jvmti,thread, &state) == JVMTI_ERROR_NONE) {\n        NSK_DISPLAY0(\" Got the state of thread \\n\");\n        if ( state & JVMTI_THREAD_STATE_SUSPENDED) {\n            NSK_DISPLAY0(\" Thread is already in suspended mode..\\n\");\n            if (!NSK_JVMTI_VERIFY(NSK_CPP_STUB2(PopFrame, jvmti, thread))) {\n                NSK_COMPLAIN0(\" TEST FAILED: UNABLE TO POP FRAME \\n\");\n                nsk_jvmti_setFailStatus();\n                return NSK_FALSE;\n            } else {\n                NSK_DISPLAY0(\" Poped frame safely..\");\n            }\n            /* We should resume that thread for next execution.. */\n            if (!NSK_JVMTI_VERIFY(NSK_CPP_STUB2(ResumeThread, jvmti, thread))) {\n                NSK_COMPLAIN0(\" TEST FAILED: UNABLE TO Resume thread \\n\");\n                nsk_jvmti_setFailStatus();\n                return NSK_FALSE;\n            } else {\n                NSK_DISPLAY0(\" Resumed.. thread for next set of executions...\");\n            }\n        } else {\n            NSK_DISPLAY0(\" Thread is not in Suspened State for poping its status..\");\n        }\n    }\n    return NSK_TRUE;\n}", "item_id": 7, "repo": "iootclab/openjdk", "file": "openjdk11/test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/hotswap/HS204/hs204t001/hs204t001.c", "last_update_at": "2018-06-23T10:04:56+00:00", "question_id": "0286a95c28925856222151785828fd9ee0b15fbc_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["JNICALL\nJava_nsk_jvmti_scenarios_hotswap_HS204_hs204t001_hs204t001_popFrame(JNIEnv * env,\n        jclass klass,\n        jthread thread) {\n    jint state;\n    NSK_DISPLAY0(\"Inside pop_Frame method.....\\n\");\n    if (NSK_CPP_STUB3(GetThreadState,jvmti,thread, &state) == JVMTI_ERROR_NONE) {\n        NSK_DISPLAY0(\" Got the state of thread \\n\");\n        if ( state & JVMTI_THREAD_STATE_SUSPENDED) {\n            NSK_DISPLAY0(\" Thread is already in suspended mode..\\n\");\n            if (!NSK_JVMTI_VERIFY(NSK_CPP_STUB2(PopFrame, jvmti, thread))) {\n                NSK_COMPLAIN0(\" TEST FAILED: UNABLE TO POP FRAME \\n\");\n                nsk_jvmti_setFailStatus();\n                return NSK_FALSE;\n            } else {\n                NSK_DISPLAY0(\" Poped frame safely..\");\n            }\n            /* We should resume that thread for next execution.. */\n            if (!NSK_JVMTI_VERIFY(NSK_CPP_STUB2(ResumeThread, jvmti, thread))) {\n                NSK_COMPLAIN0(\" TEST FAILED: UNABLE TO Resume thread \\n\");\n                nsk_jvmti_setFailStatus();\n                return NSK_FALSE;\n            } else {\n                NSK_DISPLAY0(\" Resumed.. thread for next set of executions...\");\n            }\n        } else {\n            NSK_DISPLAY0(\" Thread is not in Suspened State for poping its status..\");\n        }\n    }\n    return NSK_TRUE;\n"]], "pred": {"ppl": 2.158764123916626, "ppl_lower": 3.0851922035217285, "ppl/lowercase_ppl": -1.4640174267731134, "ppl/zlib": 0.0014492201376532696, "Min_5.0% Prob": 6.694269408350405, "Min_10.0% Prob": 5.075121078085392, "Min_20.0% Prob": 3.4023179690888585, "Min_30.0% Prob": 2.4778466102079295, "Min_40.0% Prob": 1.9097772220427052, "Min_50.0% Prob": 1.5388039403456322, "Min_60.0% Prob": 1.2845827397949836}}
{"hexsha": "8acdcbebba2fface54ed7136d24bf1f38162fb8d", "ext": "c", "lang": "C", "content": "int pcap_thread_set_callback_ipv4(pcap_thread_t* pcap_thread, pcap_thread_layer_callback_t callback_ipv4)\n{\n    if (!pcap_thread) {\n        return PCAP_THREAD_EINVAL;\n    }\n    if (pcap_thread->callback_linux_sll\n        || pcap_thread->callback_ether\n        || pcap_thread->callback_null\n        || pcap_thread->callback_loop\n        || pcap_thread->callback_ieee802\n        || pcap_thread->callback_gre\n        || pcap_thread->callback_ip\n        || pcap_thread->callback_icmp\n        || pcap_thread->callback_icmpv6\n        || pcap_thread->callback_udp\n        || pcap_thread->callback_tcp) {\n        return PCAP_THREAD_ELAYERCB;\n    }\n    if (pcap_thread->running) {\n        return PCAP_THREAD_ERUNNING;\n    }\n\n    pcap_thread->callback_ipv4 = callback_ipv4;\n\n    return PCAP_THREAD_OK;\n}", "item_id": 30, "repo": "jelu/pcap-thread", "file": "pcap_thread.c", "last_update_at": "2018-11-02T04:59:22+00:00", "question_id": "8acdcbebba2fface54ed7136d24bf1f38162fb8d_30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int pcap_thread_set_callback_ipv4(pcap_thread_t* pcap_thread, pcap_thread_layer_callback_t callback_ipv4)\n{\n    if (!pcap_thread) {\n        return PCAP_THREAD_EINVAL;\n    }\n    if (pcap_thread->callback_linux_sll\n        || pcap_thread->callback_ether\n        || pcap_thread->callback_null\n        || pcap_thread->callback_loop\n        || pcap_thread->callback_ieee802\n        || pcap_thread->callback_gre\n        || pcap_thread->callback_ip\n        || pcap_thread->callback_icmp\n        || pcap_thread->callback_icmpv6\n        || pcap_thread->callback_udp\n        || pcap_thread->callback_tcp) {\n        return PCAP_THREAD_ELAYERCB;\n    }\n    if (pcap_thread->running) {\n        return PCAP_THREAD_ERUNNING;\n    }\n    pcap_thread->callback_ipv4 = callback_ipv4;\n    return PCAP_THREAD_OK;\n"]], "pred": {"ppl": 1.8567984104156494, "ppl_lower": 1.986730933189392, "ppl/lowercase_ppl": -1.1092937131074987, "ppl/zlib": 0.0026334200846367733, "Min_5.0% Prob": 6.848094940185547, "Min_10.0% Prob": 4.7097148810114176, "Min_20.0% Prob": 2.859606006689239, "Min_30.0% Prob": 2.0456474812591776, "Min_40.0% Prob": 1.5459305633251603, "Min_50.0% Prob": 1.2360480647872796, "Min_60.0% Prob": 1.034575102409642}}
{"hexsha": "e6a1cffdd2d94d9d9b7f9e2dcbde1d53970dc202", "ext": "c", "lang": "C", "content": "void\nsvn_fs_x__serialize_string_table(svn_temp_serializer__context_t *context,\n                                 string_table_t **st)\n{\n  apr_size_t i, k;\n  string_table_t *string_table = *st;\n  if (string_table == NULL)\n    return;\n\n  /* string table struct */\n  svn_temp_serializer__push(context,\n                            (const void * const *)st,\n                            sizeof(*string_table));\n\n  /* sub-table array (all structs in a single memory block) */\n  svn_temp_serializer__push(context,\n                            (const void * const *)&string_table->sub_tables,\n                            sizeof(*string_table->sub_tables) *\n                            string_table->size);\n\n  /* sub-elements of all sub-tables */\n  for (i = 0; i < string_table->size; ++i)\n    {\n      string_sub_table_t *sub_table = &string_table->sub_tables[i];\n      svn_temp_serializer__add_leaf(context,\n                                    (const void * const *)&sub_table->data,\n                                    sub_table->data_size);\n      svn_temp_serializer__add_leaf(context,\n                    (const void * const *)&sub_table->short_strings,\n                    sub_table->short_string_count * sizeof(string_header_t));\n\n      /* all \"long string\" instances form a single memory block */\n      svn_temp_serializer__push(context,\n                    (const void * const *)&sub_table->long_strings,\n                    sub_table->long_string_count * sizeof(svn_string_t));\n\n      /* serialize actual long string contents */\n      for (k = 0; k < sub_table->long_string_count; ++k)\n        {\n          svn_string_t *string = &sub_table->long_strings[k];\n          svn_temp_serializer__add_leaf(context,\n                                        (const void * const *)&string->data,\n                                        string->len + 1);\n        }\n\n      svn_temp_serializer__pop(context);\n    }\n\n  /* back to the caller's nesting level */\n  svn_temp_serializer__pop(context);\n  svn_temp_serializer__pop(context);\n}", "item_id": 11, "repo": "timgates42/subversion", "file": "subversion/libsvn_fs_x/string_table.c", "last_update_at": "2018-12-24T22:05:09+00:00", "question_id": "e6a1cffdd2d94d9d9b7f9e2dcbde1d53970dc202_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nsvn_fs_x__serialize_string_table(svn_temp_serializer__context_t *context,\n                                 string_table_t **st)\n{\n  apr_size_t i, k;\n  string_table_t *string_table = *st;\n  if (string_table == NULL)\n    return;\n  /* string table struct */\n  svn_temp_serializer__push(context,\n                            (const void * const *)st,\n                            sizeof(*string_table));\n  /* sub-table array (all structs in a single memory block) */\n  svn_temp_serializer__push(context,\n                            (const void * const *)&string_table->sub_tables,\n                            sizeof(*string_table->sub_tables) *\n                            string_table->size);\n  /* sub-elements of all sub-tables */\n  for (i = 0; i < string_table->size; ++i)\n    {\n      string_sub_table_t *sub_table = &string_table->sub_tables[i];\n      svn_temp_serializer__add_leaf(context,\n                                    (const void * const *)&sub_table->data,\n                                    sub_table->data_size);\n      svn_temp_serializer__add_leaf(context,\n                    (const void * const *)&sub_table->short_strings,\n                    sub_table->short_string_count * sizeof(string_header_t));\n      /* all \"long string\" instances form a single memory block */\n      svn_temp_serializer__push(context,\n                    (const void * const *)&sub_table->long_strings,\n                    sub_table->long_string_count * sizeof(svn_string_t));\n      /* serialize actual long string contents */\n      for (k = 0; k < sub_table->long_string_count; ++k)\n        {\n          svn_string_t *string = &sub_table->long_strings[k];\n          svn_temp_serializer__add_leaf(context,\n                                        (const void * const *)&string->data,\n                                        string->len + 1);\n        }\n      svn_temp_serializer__pop(context);\n    }\n  /* back to the caller's nesting level */\n  svn_temp_serializer__pop(context);\n  svn_temp_serializer__pop(context);\n"]], "pred": {"ppl": 1.9372502565383911, "ppl_lower": 1.9798556566238403, "ppl/lowercase_ppl": -1.0328978802603888, "ppl/zlib": 0.0012692314281879313, "Min_5.0% Prob": 7.05846748680904, "Min_10.0% Prob": 4.938682544029366, "Min_20.0% Prob": 3.0758968778585984, "Min_30.0% Prob": 2.164334117692743, "Min_40.0% Prob": 1.6424607133752183, "Min_50.0% Prob": 1.321754310921942, "Min_60.0% Prob": 1.1038334796677383}}
{"hexsha": "aa3b8f1b34d932a90256b13e99b0a6d53ec5c5cc", "ext": "c", "lang": "C", "content": "static int\nisl1208_i2c_get_dtr(struct i2c_client *client)\n{\n\tint dtr = i2c_smbus_read_byte_data(client, ISL1208_REG_DTR);\n\tif (dtr < 0)\n\t\treturn -EIO;\n\n\t/* dtr encodes adjustments of {-60,-40,-20,0,20,40,60} ppm */\n\tdtr = ((dtr & 0x3) * 20) * (dtr & (1 << 2) ? -1 : 1);\n\n\treturn dtr;\n}", "item_id": 4, "repo": "SIIS-cloud/pileus", "file": "difc-kernel/pileus-kernel/drivers/rtc/rtc-isl1208.c", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "aa3b8f1b34d932a90256b13e99b0a6d53ec5c5cc_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nisl1208_i2c_get_dtr(struct i2c_client *client)\n{\n\tint dtr = i2c_smbus_read_byte_data(client, ISL1208_REG_DTR);\n\tif (dtr < 0)\n\t\treturn -EIO;\n\t/* dtr encodes adjustments of {-60,-40,-20,0,20,40,60} ppm */\n\tdtr = ((dtr & 0x3) * 20) * (dtr & (1 << 2) ? -1 : 1);\n\treturn dtr;\n"]], "pred": {"ppl": 2.7518038749694824, "ppl_lower": 3.1391353607177734, "ppl/lowercase_ppl": -1.1300962042100526, "ppl/zlib": 0.004622176489354776, "Min_5.0% Prob": 8.853212237358093, "Min_10.0% Prob": 6.378652572631836, "Min_20.0% Prob": 4.265585076063871, "Min_30.0% Prob": 3.145800403008858, "Min_40.0% Prob": 2.4722430943511426, "Min_50.0% Prob": 2.0189340310171247, "Min_60.0% Prob": 1.694079292123206}}
{"hexsha": "bf0a24a55c7cf1e26c035c599374d09437969295", "ext": "c", "lang": "C", "content": "int\nm2_val_print (type, valaddr, address, stream, format, deref_ref, recurse,\n\t      pretty)\n     struct type *type;\n     char *valaddr;\n     CORE_ADDR address;\n     FILE *stream;\n     int format;\n     int deref_ref;\n     int recurse;\n     enum val_prettyprint pretty;\n{\n  extern int\n  c_val_print PARAMS ((struct type *, char *, CORE_ADDR, FILE *, int, int,\n\t\t       int, enum val_prettyprint));\n  return (c_val_print (type, valaddr, address, stream, format, deref_ref,\n\t\t       recurse, pretty));\n}", "item_id": 0, "repo": "aaliomer/exos", "file": "bin/gdb/gdb/m2-valprint.c", "last_update_at": "2018-01-23T23:07:19+00:00", "question_id": "bf0a24a55c7cf1e26c035c599374d09437969295_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nm2_val_print (type, valaddr, address, stream, format, deref_ref, recurse,\n\t      pretty)\n     struct type *type;\n     char *valaddr;\n     CORE_ADDR address;\n     FILE *stream;\n     int format;\n     int deref_ref;\n     int recurse;\n     enum val_prettyprint pretty;\n{\n  extern int\n  c_val_print PARAMS ((struct type *, char *, CORE_ADDR, FILE *, int, int,\n\t\t       int, enum val_prettyprint));\n  return (c_val_print (type, valaddr, address, stream, format, deref_ref,\n\t\t       recurse, pretty));\n"]], "pred": {"ppl": 2.0538322925567627, "ppl_lower": 2.702357769012451, "ppl/lowercase_ppl": -1.3812898940123082, "ppl/zlib": 0.0031156167055389297, "Min_5.0% Prob": 6.574221716986762, "Min_10.0% Prob": 5.081254389550951, "Min_20.0% Prob": 3.3412634150849447, "Min_30.0% Prob": 2.385464206613876, "Min_40.0% Prob": 1.8110607971644237, "Min_50.0% Prob": 1.4371418306644965, "Min_60.0% Prob": 1.20095196881528}}
{"hexsha": "7f58c735d745049025407806e972bb4c7f124888", "ext": "c", "lang": "C", "content": "static int bpf_fill_maxinsns6(struct bpf_test *self)\n{\n\tunsigned int len = BPF_MAXINSNS;\n\tstruct sock_filter *insn;\n\tint i;\n\n\tinsn = kmalloc_array(len, sizeof(*insn), GFP_KERNEL);\n\tif (!insn)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < len - 1; i++)\n\t\tinsn[i] = __BPF_STMT(BPF_LD | BPF_W | BPF_ABS, SKF_AD_OFF +\n\t\t\t\t     SKF_AD_VLAN_TAG_PRESENT);\n\n\tinsn[len - 1] = __BPF_STMT(BPF_RET | BPF_A, 0);\n\n\tself->u.ptr.insns = insn;\n\tself->u.ptr.len = len;\n\n\treturn 0;\n}", "item_id": 5, "repo": "SIIS-cloud/pileus", "file": "difc-kernel/pileus-kernel/lib/test_bpf.c", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "7f58c735d745049025407806e972bb4c7f124888_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int bpf_fill_maxinsns6(struct bpf_test *self)\n{\n\tunsigned int len = BPF_MAXINSNS;\n\tstruct sock_filter *insn;\n\tint i;\n\tinsn = kmalloc_array(len, sizeof(*insn), GFP_KERNEL);\n\tif (!insn)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < len - 1; i++)\n\t\tinsn[i] = __BPF_STMT(BPF_LD | BPF_W | BPF_ABS, SKF_AD_OFF +\n\t\t\t\t     SKF_AD_VLAN_TAG_PRESENT);\n\tinsn[len - 1] = __BPF_STMT(BPF_RET | BPF_A, 0);\n\tself->u.ptr.insns = insn;\n\tself->u.ptr.len = len;\n\treturn 0;\n"]], "pred": {"ppl": 1.8409322500228882, "ppl_lower": 2.5438921451568604, "ppl/lowercase_ppl": -1.529965481590729, "ppl/zlib": 0.002034240336447978, "Min_5.0% Prob": 6.954298357168834, "Min_10.0% Prob": 4.7474872668584185, "Min_20.0% Prob": 2.8589489671091237, "Min_30.0% Prob": 2.0112936043490968, "Min_40.0% Prob": 1.516246842854109, "Min_50.0% Prob": 1.222646414648649, "Min_60.0% Prob": 1.022237492885826}}
{"hexsha": "adc08a268a5c44d3717836793937f1357b75e06a", "ext": "c", "lang": "C", "content": "int hrstemc_endswith(char *s, char *what) {\n    if (strlen(what) > strlen(s)) {\n        return 0;\n    }\n    if (strcmp(s+strlen(s)-strlen(what), what) == 0) {\n        return 1;\n    }\n    return 0;\n}", "item_id": 2, "repo": "ivoras/hrstemc", "file": "pgdict_hrstemc/hrstemc.c", "last_update_at": "2018-06-06T09:05:14+00:00", "question_id": "adc08a268a5c44d3717836793937f1357b75e06a_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int hrstemc_endswith(char *s, char *what) {\n    if (strlen(what) > strlen(s)) {\n        return 0;\n    }\n    if (strcmp(s+strlen(s)-strlen(what), what) == 0) {\n        return 1;\n    }\n    return 0;\n"]], "pred": {"ppl": 2.6967880725860596, "ppl_lower": 2.6967880725860596, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.008702293527415566, "Min_5.0% Prob": 9.558066248893738, "Min_10.0% Prob": 7.35232537984848, "Min_20.0% Prob": 4.48062850447262, "Min_30.0% Prob": 3.242457308769226, "Min_40.0% Prob": 2.472718347959659, "Min_50.0% Prob": 1.975058723154456, "Min_60.0% Prob": 1.670459445492894}}
{"hexsha": "12615d6fdd78bd944ebf9b0af1430871738316dd", "ext": "c", "lang": "C", "content": "void\tgame(t_shapes *shapes, t_pars *pars, t_game *game)\n{\n  char\t**board;\n  t_pos\t*pos;\n  int\taction;\n  int\tcount;\n\n  init_board(&board, pars, &pos, &count);\n  while (check_loss(board))\n    {\n      pos = rand_next(pos, shapes, pars);\n      while (pos->index != -1)\n\t{\n\t  if ((action = get_action(pars)))\n\t    {\n\t      if (my_pause(game, action))\n\t\tif (apply_action(action, board, pos, shapes))\n\t\t  return ;\n\t      display(board, pos, game, pars);\n\t    }\n\t  if (count >= 400 && !game->pause.paused)\n\t    count = falling_time(board, pos, game, pars);\n\t  while (check_fulline(board, game))\n\t    display(board, pos, game, pars);\n\t  one_turn(&count, game);\n\t}\n    }\n}", "item_id": 3, "repo": "rectoria/PSU_2016_tetris", "file": "game.c", "last_update_at": "2018-10-02T18:35:01+00:00", "question_id": "12615d6fdd78bd944ebf9b0af1430871738316dd_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\tgame(t_shapes *shapes, t_pars *pars, t_game *game)\n{\n  char\t**board;\n  t_pos\t*pos;\n  int\taction;\n  int\tcount;\n  init_board(&board, pars, &pos, &count);\n  while (check_loss(board))\n    {\n      pos = rand_next(pos, shapes, pars);\n      while (pos->index != -1)\n\t{\n\t  if ((action = get_action(pars)))\n\t    {\n\t      if (my_pause(game, action))\n\t\tif (apply_action(action, board, pos, shapes))\n\t\t  return ;\n\t      display(board, pos, game, pars);\n\t    }\n\t  if (count >= 400 && !game->pause.paused)\n\t    count = falling_time(board, pos, game, pars);\n\t  while (check_fulline(board, game))\n\t    display(board, pos, game, pars);\n\t  one_turn(&count, game);\n\t}\n    }\n"]], "pred": {"ppl": 4.359703063964844, "ppl_lower": 4.359703063964844, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.004572683075920808, "Min_5.0% Prob": 8.766354450812706, "Min_10.0% Prob": 6.977869934505886, "Min_20.0% Prob": 5.129729960181496, "Min_30.0% Prob": 4.138994167490703, "Min_40.0% Prob": 3.405568075180054, "Min_50.0% Prob": 2.8585726747112554, "Min_60.0% Prob": 2.4244596018935693}}
{"hexsha": "53f763e6a174d8f5a27fa5c3c54624423cdf8917", "ext": "c", "lang": "C", "content": "static boolean __wss_ping()\n{\n\t/* Disable CODEC operations first */\n\t__wss_regbit_reset(WSSR_IFACE_CTRL, WSSM_PLAYBACK_ENABLE);\n\t/* Now put some harmless values in registers and check them */\n\t__wss_outreg(WSSR_COUNT_LOW, 0xaa);\n\t__wss_outreg(WSSR_COUNT_HIGH, 0x55);\n\treturn (__wss_inreg(WSSR_COUNT_LOW) == 0xaa)\n\t  && (__wss_inreg(WSSR_COUNT_HIGH) == 0x55);\n}", "item_id": 2, "repo": "Marisa-Chan/surreal", "file": "Deps/libmikmod/dos/src/doswss.c", "last_update_at": "2018-09-21T22:13:23+00:00", "question_id": "53f763e6a174d8f5a27fa5c3c54624423cdf8917_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static boolean __wss_ping()\n{\n\t/* Disable CODEC operations first */\n\t__wss_regbit_reset(WSSR_IFACE_CTRL, WSSM_PLAYBACK_ENABLE);\n\t/* Now put some harmless values in registers and check them */\n\t__wss_outreg(WSSR_COUNT_LOW, 0xaa);\n\t__wss_outreg(WSSR_COUNT_HIGH, 0x55);\n\treturn (__wss_inreg(WSSR_COUNT_LOW) == 0xaa)\n\t  && (__wss_inreg(WSSR_COUNT_HIGH) == 0x55);\n"]], "pred": {"ppl": 3.9428365230560303, "ppl_lower": 4.3555450439453125, "ppl/lowercase_ppl": -1.0725631121025643, "ppl/zlib": 0.005788609257360396, "Min_5.0% Prob": 8.538603246212006, "Min_10.0% Prob": 7.308596162235036, "Min_20.0% Prob": 5.71203326477724, "Min_30.0% Prob": 4.376045049405565, "Min_40.0% Prob": 3.382426747377368, "Min_50.0% Prob": 2.7492961011133916, "Min_60.0% Prob": 2.302391914415707}}
{"hexsha": "04dc117226c117711c4a2e30aa587c772e308908", "ext": "c", "lang": "C", "content": "CFTypeRef\nIORegistryEntryCreateCFProperty(\n\tio_registry_entry_t\tentry,\n\tCFStringRef\t\tkey,\n        CFAllocatorRef\t\tallocator,\n\tIOOptionBits   options __unused )\n{\n    IOReturn\t\tkr;\n    CFTypeRef\t\ttype;\n    uint32_t\t \tsize;\n    char *\t \tpropertiesBuffer;\n    CFStringRef  \terrorString;\n    const char *    \tcStr;\n    char *\t    \tbuffer = NULL;\n\n    cStr = CFStringGetCStringPtr( key, kCFStringEncodingMacRoman);\n    if( !cStr) {\n\tCFIndex bufferSize = CFStringGetMaximumSizeForEncoding( CFStringGetLength(key),\n\t       kCFStringEncodingMacRoman) + sizeof('\\0');\n        buffer = malloc( bufferSize);\n        if( buffer && CFStringGetCString( key, buffer, bufferSize, kCFStringEncodingMacRoman))\n            cStr = buffer;\n    }\n\n    if( cStr)\n        kr = io_registry_entry_get_property(entry, (char *) cStr, &propertiesBuffer, &size);\n    else\n        kr = kIOReturnError;\n\n    if( buffer)\n        free( buffer);\n\n    if( kr != kIOReturnSuccess)\n        return( NULL );\n\n    type = (CFMutableDictionaryRef)\n                        IOCFUnserialize(propertiesBuffer, allocator,\n\t\t\t\t\t0, &errorString);\n    if (!type && errorString) {\n\n        if ((cStr = CFStringGetCStringPtr(errorString,\n\t\t\t\t\tkCFStringEncodingMacRoman)))\n            printf(\"%s\\n\", cStr);\n\tCFRelease(errorString);\n    }\n\n    // free propertiesBuffer !\n    vm_deallocate(mach_task_self(), (vm_address_t)propertiesBuffer, size);\n\n    return( type );\n}", "item_id": 38, "repo": "markieeee/mu1ti_path", "file": "multi_path/jelbrek/include/IOKit/IOKitLib.c", "last_update_at": "2018-07-02T16:15:06+00:00", "question_id": "04dc117226c117711c4a2e30aa587c772e308908_38", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["CFTypeRef\nIORegistryEntryCreateCFProperty(\n\tio_registry_entry_t\tentry,\n\tCFStringRef\t\tkey,\n        CFAllocatorRef\t\tallocator,\n\tIOOptionBits   options __unused )\n{\n    IOReturn\t\tkr;\n    CFTypeRef\t\ttype;\n    uint32_t\t \tsize;\n    char *\t \tpropertiesBuffer;\n    CFStringRef  \terrorString;\n    const char *    \tcStr;\n    char *\t    \tbuffer = NULL;\n    cStr = CFStringGetCStringPtr( key, kCFStringEncodingMacRoman);\n    if( !cStr) {\n\tCFIndex bufferSize = CFStringGetMaximumSizeForEncoding( CFStringGetLength(key),\n\t       kCFStringEncodingMacRoman) + sizeof('\\0');\n        buffer = malloc( bufferSize);\n        if( buffer && CFStringGetCString( key, buffer, bufferSize, kCFStringEncodingMacRoman))\n            cStr = buffer;\n    }\n    if( cStr)\n        kr = io_registry_entry_get_property(entry, (char *) cStr, &propertiesBuffer, &size);\n    else\n        kr = kIOReturnError;\n    if( buffer)\n        free( buffer);\n    if( kr != kIOReturnSuccess)\n        return( NULL );\n    type = (CFMutableDictionaryRef)\n                        IOCFUnserialize(propertiesBuffer, allocator,\n\t\t\t\t\t0, &errorString);\n    if (!type && errorString) {\n        if ((cStr = CFStringGetCStringPtr(errorString,\n\t\t\t\t\tkCFStringEncodingMacRoman)))\n            printf(\"%s\\n\", cStr);\n\tCFRelease(errorString);\n    }\n    // free propertiesBuffer !\n    vm_deallocate(mach_task_self(), (vm_address_t)propertiesBuffer, size);\n    return( type );\n"]], "pred": {"ppl": 2.3586201667785645, "ppl_lower": 3.030905246734619, "ppl/lowercase_ppl": -1.2922635493109758, "ppl/zlib": 0.0014593142397186316, "Min_5.0% Prob": 6.295825143655141, "Min_10.0% Prob": 4.93925026555856, "Min_20.0% Prob": 3.4643500906725726, "Min_30.0% Prob": 2.6227476435403028, "Min_40.0% Prob": 2.0735277278969684, "Min_50.0% Prob": 1.698188356248041, "Min_60.0% Prob": 1.4289060067126735}}
{"hexsha": "3c91d3ab18514d926a8787931b798035fe031cb5", "ext": "c", "lang": "C", "content": "void JNICALL testNativeMethodBind(jvmtiEnv* jvmti_env, JNIEnv *jni_env,\n                      jthread thread, jmethodID mid, void* func, void** func_ptr) {\n    jvmtiPhase phase;\n    char *mname;\n    char *signature;\n    jint ret;\n\n    ret = (*jvmti_env)->GetPhase(jvmti_env, &phase);\n    if (ret != JVMTI_ERROR_NONE) {\n      printf(\"Error: GetPhase %d\\n\", ret);\n      iGlobalStatus = 2;\n      return;\n    }\n\n    if (phase != JVMTI_PHASE_START && phase != JVMTI_PHASE_LIVE)\n        return;\n\n    debug_printf(\"bind event: \\n\");\n    print_method_name(mid);\n\n    ret = (*jvmti_env)->GetMethodName(jvmti_env, mid, &mname, &signature, NULL);\n    if (ret == JVMTI_ERROR_NONE) {\n      if (strcmp(mname, \"findLoadedClass\") == 0) {\n        findLoadedClass_func = (findLoadClass_type)func;\n        *func_ptr = (void*)my_findLoadedClass;\n        debug_printf(\"REDIRECTED findLoadedClass\\n\");\n      }\n    }\n}", "item_id": 2, "repo": "iootclab/openjdk", "file": "openjdk11/test/hotspot/jtreg/vmTestbase/nsk/jvmti/unit/MethodBind/JvmtiTest/JvmtiTest.c", "last_update_at": "2018-06-23T10:04:56+00:00", "question_id": "3c91d3ab18514d926a8787931b798035fe031cb5_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void JNICALL testNativeMethodBind(jvmtiEnv* jvmti_env, JNIEnv *jni_env,\n                      jthread thread, jmethodID mid, void* func, void** func_ptr) {\n    jvmtiPhase phase;\n    char *mname;\n    char *signature;\n    jint ret;\n    ret = (*jvmti_env)->GetPhase(jvmti_env, &phase);\n    if (ret != JVMTI_ERROR_NONE) {\n      printf(\"Error: GetPhase %d\\n\", ret);\n      iGlobalStatus = 2;\n      return;\n    }\n    if (phase != JVMTI_PHASE_START && phase != JVMTI_PHASE_LIVE)\n        return;\n    debug_printf(\"bind event: \\n\");\n    print_method_name(mid);\n    ret = (*jvmti_env)->GetMethodName(jvmti_env, mid, &mname, &signature, NULL);\n    if (ret == JVMTI_ERROR_NONE) {\n      if (strcmp(mname, \"findLoadedClass\") == 0) {\n        findLoadedClass_func = (findLoadClass_type)func;\n        *func_ptr = (void*)my_findLoadedClass;\n        debug_printf(\"REDIRECTED findLoadedClass\\n\");\n      }\n    }\n"]], "pred": {"ppl": 2.3921656608581543, "ppl_lower": 3.157737970352173, "ppl/lowercase_ppl": -1.3183411361171602, "ppl/zlib": 0.002061936382746779, "Min_5.0% Prob": 7.140939682722092, "Min_10.0% Prob": 5.505950046308113, "Min_20.0% Prob": 3.67995577508753, "Min_30.0% Prob": 2.7422243471097465, "Min_40.0% Prob": 2.1376417684823945, "Min_50.0% Prob": 1.735825010990522, "Min_60.0% Prob": 1.455998237286905}}
{"hexsha": "880dcb4ba0c15f4b798521b6a0cdee4897042fb9", "ext": "c", "lang": "C", "content": "xuintptr *putOrderedObject(Class *class, MethodBlock *mb, xuintptr *ostack) {\n    long long offset = *((long long *)&ostack[2]);\n    volatile xuintptr *addr = (xuintptr*)((char *)ostack[1] + offset);\n    xuintptr value = ostack[4];\n\n    *addr = value;\n    return ostack;\n}", "item_id": 103, "repo": "webos21/xi", "file": "java/jvm/jamvm/natives.c", "last_update_at": "2018-09-25T10:56:25+00:00", "question_id": "880dcb4ba0c15f4b798521b6a0cdee4897042fb9_103", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["xuintptr *putOrderedObject(Class *class, MethodBlock *mb, xuintptr *ostack) {\n    long long offset = *((long long *)&ostack[2]);\n    volatile xuintptr *addr = (xuintptr*)((char *)ostack[1] + offset);\n    xuintptr value = ostack[4];\n    *addr = value;\n    return ostack;\n"]], "pred": {"ppl": 5.620701789855957, "ppl_lower": 6.1129469871521, "ppl/lowercase_ppl": -1.048627027477264, "ppl/zlib": 0.00997951751300223, "Min_5.0% Prob": 9.111840963363647, "Min_10.0% Prob": 8.356716050042046, "Min_20.0% Prob": 6.231053515484459, "Min_30.0% Prob": 4.961463015654991, "Min_40.0% Prob": 4.084287681077656, "Min_50.0% Prob": 3.370057012885809, "Min_60.0% Prob": 2.851896342018555}}
{"hexsha": "d792299f737c1b6f19106a711f2cf3827b4eab3b", "ext": "c", "lang": "C", "content": "char* get_self_executable_directory()\n{\n\tint rval;\n\tchar link_target[1024];\n\tchar* last_slash;\n\tsize_t result_length;\n\tchar* result;\n\t/* get program name */\n\trval = readlink(\"/proc/self/exe\",link_target,sizeof(link_target));\n\tif (rval == -1)\n\t\tabort();\n\telse\n\t\tlink_target[rval] = '\\0';\n\t/* get last '/' */\n\tlast_slash = strrchr(link_target,'/');\n\tif (last_slash == NULL || last_slash == link_target)\n\t\tabort();\n\tresult_length = last_slash - link_target;\n\tresult = (char*)xmalloc(result_length + 1);\n\tstrncpy(result,link_target,result_length);\n\tresult[result_length] = '\\0';\n\treturn result;\n}", "item_id": 1, "repo": "zyfjeff/webserver", "file": "common.c", "last_update_at": "2018-05-07T13:41:36+00:00", "question_id": "d792299f737c1b6f19106a711f2cf3827b4eab3b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["char* get_self_executable_directory()\n{\n\tint rval;\n\tchar link_target[1024];\n\tchar* last_slash;\n\tsize_t result_length;\n\tchar* result;\n\t/* get program name */\n\trval = readlink(\"/proc/self/exe\",link_target,sizeof(link_target));\n\tif (rval == -1)\n\t\tabort();\n\telse\n\t\tlink_target[rval] = '\\0';\n\t/* get last '/' */\n\tlast_slash = strrchr(link_target,'/');\n\tif (last_slash == NULL || last_slash == link_target)\n\t\tabort();\n\tresult_length = last_slash - link_target;\n\tresult = (char*)xmalloc(result_length + 1);\n\tstrncpy(result,link_target,result_length);\n\tresult[result_length] = '\\0';\n\treturn result;\n"]], "pred": {"ppl": 1.9057725667953491, "ppl_lower": 1.9713770151138306, "ppl/lowercase_ppl": -1.0524817416610395, "ppl/zlib": 0.002223749907727435, "Min_5.0% Prob": 5.908185828815807, "Min_10.0% Prob": 4.591254089189612, "Min_20.0% Prob": 2.9232045399106066, "Min_30.0% Prob": 2.0838660658269688, "Min_40.0% Prob": 1.6030641680016466, "Min_50.0% Prob": 1.2837796630337834, "Min_60.0% Prob": 1.0750207051889396}}
{"hexsha": "018df08a8d269752e6dbbfd82436fd59cb429831", "ext": "c", "lang": "C", "content": "static int yy_init_globals (void)\n{\n        /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from yylex_destroy(), so don't allocate here.\n     */\n\n    (yy_buffer_stack) = 0;\n    (yy_buffer_stack_top) = 0;\n    (yy_buffer_stack_max) = 0;\n    (yy_c_buf_p) = (char *) 0;\n    (yy_init) = 0;\n    (yy_start) = 0;\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    yyin = stdin;\n    yyout = stdout;\n#else\n    yyin = (FILE *) 0;\n    yyout = (FILE *) 0;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * yylex_init()\n     */\n    return 0;\n}", "item_id": 21, "repo": "LTD-Beget/unbound", "file": "util/configlexer.c", "last_update_at": "2018-08-21T03:05:22+00:00", "question_id": "018df08a8d269752e6dbbfd82436fd59cb429831_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int yy_init_globals (void)\n{\n        /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from yylex_destroy(), so don't allocate here.\n     */\n    (yy_buffer_stack) = 0;\n    (yy_buffer_stack_top) = 0;\n    (yy_buffer_stack_max) = 0;\n    (yy_c_buf_p) = (char *) 0;\n    (yy_init) = 0;\n    (yy_start) = 0;\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    yyin = stdin;\n    yyout = stdout;\n#else\n    yyin = (FILE *) 0;\n    yyout = (FILE *) 0;\n#endif\n    /* For future reference: Set errno on error, since we are called by\n     * yylex_init()\n     */\n    return 0;\n"]], "pred": {"ppl": 1.1400976181030273, "ppl_lower": 1.9065990447998047, "ppl/lowercase_ppl": -4.9218359450621545, "ppl/zlib": 0.00039255655286020506, "Min_5.0% Prob": 2.6297815864284835, "Min_10.0% Prob": 1.3449686954263598, "Min_20.0% Prob": 0.6603689825076762, "Min_30.0% Prob": 0.43750006153611654, "Min_40.0% Prob": 0.3304185251376, "Min_50.0% Prob": 0.26328092203529957, "Min_60.0% Prob": 0.21881412416312102}}
{"hexsha": "1a6759498398ede8e1fe2e773c0d7c1f0aa3adf4", "ext": "c", "lang": "C", "content": "typedcode_t node_lplusplus_read(node_t*n)\n{\n    READ_HEADER_ONE;\n    t = x.t;\n    if(is_getlocal(x.c) && (TYPE_IS_INT(x.t) || TYPE_IS_NUMBER(x.t))) {\n        int nr = getlocalnr(x.c);\n        code_free(x.c);x.c=0;\n        if(TYPE_IS_INT(x.t)) {\n           c = abc_inclocal_i(c, nr);\n           c = abc_getlocal(c, nr);\n        } else if(TYPE_IS_NUMBER(x.t)) {\n           c = abc_inclocal(c, nr);\n           c = abc_getlocal(c, nr);\n        } else syntaxerror(\"internal error\");\n    } else {\n        if(TYPE_IS_INT(x.t) || TYPE_IS_UINT(x.t)) {\n            c = abc_increment_i(c);\n            t = TYPE_INT;\n        } else {\n            c = abc_increment(c);\n            t = TYPE_NUMBER;\n        }\n        c = converttype(c, t, x.t);\n        c = toreadwrite(x.c, c, 0, 0, 1);\n        t = x.t;\n    }\n    RET\n}", "item_id": 7, "repo": "svenskan/pronunciation", "file": "vendor/swftools/lib/as3/expr.c", "last_update_at": "2018-04-25T22:29:34+00:00", "question_id": "1a6759498398ede8e1fe2e773c0d7c1f0aa3adf4_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["typedcode_t node_lplusplus_read(node_t*n)\n{\n    READ_HEADER_ONE;\n    t = x.t;\n    if(is_getlocal(x.c) && (TYPE_IS_INT(x.t) || TYPE_IS_NUMBER(x.t))) {\n        int nr = getlocalnr(x.c);\n        code_free(x.c);x.c=0;\n        if(TYPE_IS_INT(x.t)) {\n           c = abc_inclocal_i(c, nr);\n           c = abc_getlocal(c, nr);\n        } else if(TYPE_IS_NUMBER(x.t)) {\n           c = abc_inclocal(c, nr);\n           c = abc_getlocal(c, nr);\n        } else syntaxerror(\"internal error\");\n    } else {\n        if(TYPE_IS_INT(x.t) || TYPE_IS_UINT(x.t)) {\n            c = abc_increment_i(c);\n            t = TYPE_INT;\n        } else {\n            c = abc_increment(c);\n            t = TYPE_NUMBER;\n        }\n        c = converttype(c, t, x.t);\n        c = toreadwrite(x.c, c, 0, 0, 1);\n        t = x.t;\n    }\n    RET\n"]], "pred": {"ppl": 3.3418023586273193, "ppl_lower": 3.4264185428619385, "ppl/lowercase_ppl": -1.0207252847368022, "ppl/zlib": 0.0038546654625339683, "Min_5.0% Prob": 9.125054478645325, "Min_10.0% Prob": 7.289635773861047, "Min_20.0% Prob": 4.975721499813137, "Min_30.0% Prob": 3.716049343052477, "Min_40.0% Prob": 2.932840691010157, "Min_50.0% Prob": 2.3871666967163425, "Min_60.0% Prob": 2.0100955949856503}}
{"hexsha": "6c41e5086e257053d65e89262f44869f3893d6e7", "ext": "h", "lang": "C", "content": "void Update_Channel_Value (Channel* channel, int value) {\n  Serial.println (\"Update_Channel_Value\");\n  \n  if (channel != NULL) {\n    \n    // Set the channel mode corresponding to the specified value\n    Update_Channel_Mode (channel, PIN_MODE_OUTPUT);\n    \n    // Set the channel value\n    (*channel).value = value;\n    \n    // Set the actual hardware's pin's value\n    // TODO: Move this to the platform's schema!\n    digitalWrite ((*channel).address, ((*channel).value == PIN_VALUE_HIGH ? HIGH : LOW));\n    \n    (*channel).isUpdated = true; // TODO: Propagate this change to the platform associated with the channel.\n  }\n  // TODO: Return \"none\" if channel not found (if specified channel is NULL)\n}", "item_id": 11, "repo": "mgub/pixel", "file": "Firmware/Primary_Firmware/Platform.h", "last_update_at": "2018-06-27T23:19:03+00:00", "question_id": "6c41e5086e257053d65e89262f44869f3893d6e7_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void Update_Channel_Value (Channel* channel, int value) {\n  Serial.println (\"Update_Channel_Value\");\n  if (channel != NULL) {\n    // Set the channel mode corresponding to the specified value\n    Update_Channel_Mode (channel, PIN_MODE_OUTPUT);\n    // Set the channel value\n    (*channel).value = value;\n    // Set the actual hardware's pin's value\n    // TODO: Move this to the platform's schema!\n    digitalWrite ((*channel).address, ((*channel).value == PIN_VALUE_HIGH ? HIGH : LOW));\n    (*channel).isUpdated = true; // TODO: Propagate this change to the platform associated with the channel.\n  }\n  // TODO: Return \"none\" if channel not found (if specified channel is NULL)\n"]], "pred": {"ppl": 5.175823211669922, "ppl_lower": 6.306497097015381, "ppl/lowercase_ppl": -1.1201838066648837, "ppl/zlib": 0.004630981411885118, "Min_5.0% Prob": 8.681326484680175, "Min_10.0% Prob": 7.199483132362365, "Min_20.0% Prob": 5.666912633180618, "Min_30.0% Prob": 4.611729774872462, "Min_40.0% Prob": 3.792679964005947, "Min_50.0% Prob": 3.158520718612293, "Min_60.0% Prob": 2.70673912000065}}
{"hexsha": "55a23909fad29635c3535f2e947608df579e25bf", "ext": "h", "lang": "C", "content": "DataType remove( DataType value )\n  {\n    int n = count + 1;\n    DataType* cur = data - 1;\n    while (--n)\n    {\n      if (*(++cur) == value)\n      {\n        if (--n)\n        {\n          memmove( cur, cur+1, sizeof(DataType) * n );\n        }\n        --count;\n        return value;\n      }\n    }\n    return value;\n  }", "item_id": 1, "repo": "r-lyeh/scriptorium", "file": "java/jog/libraries/array_list.h", "last_update_at": "2018-01-08T03:02:37+00:00", "question_id": "55a23909fad29635c3535f2e947608df579e25bf_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["DataType remove( DataType value )\n  {\n    int n = count + 1;\n    DataType* cur = data - 1;\n    while (--n)\n    {\n      if (*(++cur) == value)\n      {\n        if (--n)\n        {\n          memmove( cur, cur+1, sizeof(DataType) * n );\n        }\n        --count;\n        return value;\n      }\n    }\n    return value;\n"]], "pred": {"ppl": 3.0499489307403564, "ppl_lower": 3.380279302597046, "ppl/lowercase_ppl": -1.092217022921057, "ppl/zlib": 0.006717619556985436, "Min_5.0% Prob": 9.14667911529541, "Min_10.0% Prob": 6.629842714829878, "Min_20.0% Prob": 4.59975560686805, "Min_30.0% Prob": 3.4888582663102583, "Min_40.0% Prob": 2.7134334729777443, "Min_50.0% Prob": 2.2164585758000612, "Min_60.0% Prob": 1.8693593610356103}}
{"hexsha": "86486e2eb148e3c17909fdf838ee9f9e535353a0", "ext": "c", "lang": "C", "content": "err long_parse_number(char *str, long *number, int min)\n{\n\tchar\t*end;\n\tlong\tnbr;\n\n\tif (*str == '\\0')\n\t\treturn KO;\n\tnbr = (int)strtol(str, &end, 0);\n\tif (*end != '\\0' || nbr < min)\n\t\treturn KO;\n\t*number = nbr;\n\treturn OK;\n}", "item_id": 0, "repo": "VincentGuinaudeau/buddhabrot", "file": "src/parser.c", "last_update_at": "2018-02-18T01:48:01+00:00", "question_id": "86486e2eb148e3c17909fdf838ee9f9e535353a0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["err long_parse_number(char *str, long *number, int min)\n{\n\tchar\t*end;\n\tlong\tnbr;\n\tif (*str == '\\0')\n\t\treturn KO;\n\tnbr = (int)strtol(str, &end, 0);\n\tif (*end != '\\0' || nbr < min)\n\t\treturn KO;\n\t*number = nbr;\n\treturn OK;\n"]], "pred": {"ppl": 2.642686367034912, "ppl_lower": 2.7987568378448486, "ppl/lowercase_ppl": -1.0590446670129323, "ppl/zlib": 0.0062696513745965085, "Min_5.0% Prob": 9.42747459411621, "Min_10.0% Prob": 6.453208017349243, "Min_20.0% Prob": 4.0758672044390725, "Min_30.0% Prob": 3.0016333777457476, "Min_40.0% Prob": 2.399818893699419, "Min_50.0% Prob": 1.9432904422283173, "Min_60.0% Prob": 1.6203464029822499}}
{"hexsha": "8d5d24466d16739c61b51b6ca7b560ce09a47251", "ext": "c", "lang": "C", "content": "void args_usage(args_t *args, FILE *out) {\n  fprintf(out, \"Usage: %s\", args->program_name);\n  for (int s = 0; s < args->shortcuts->hsize; s++) {\n    hash_element_t *elem = args->shortcuts->htable[s];\n    while (elem != NULL) {\n      fprintf(out, \" [ -%s ]\", elem->key);\n      elem = elem->p;\n    }\n  }\n  fprintf(out, \"\\n\\n\");\n  fprintf(out, \"Try `%s --help` for more help.\\n\\n\", args->program_name);\n}", "item_id": 2, "repo": "MarioProjects/FelixRobot", "file": "FelixiAtros/iatros-v1.0/prhlt/src/args.c", "last_update_at": "2018-05-14T01:46:10+00:00", "question_id": "8d5d24466d16739c61b51b6ca7b560ce09a47251_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void args_usage(args_t *args, FILE *out) {\n  fprintf(out, \"Usage: %s\", args->program_name);\n  for (int s = 0; s < args->shortcuts->hsize; s++) {\n    hash_element_t *elem = args->shortcuts->htable[s];\n    while (elem != NULL) {\n      fprintf(out, \" [ -%s ]\", elem->key);\n      elem = elem->p;\n    }\n  }\n  fprintf(out, \"\\n\\n\");\n  fprintf(out, \"Try `%s --help` for more help.\\n\\n\", args->program_name);\n"]], "pred": {"ppl": 2.8966002464294434, "ppl_lower": 3.1772561073303223, "ppl/lowercase_ppl": -1.0869553028025902, "ppl/zlib": 0.004468645884285836, "Min_5.0% Prob": 8.957294940948486, "Min_10.0% Prob": 6.672577887773514, "Min_20.0% Prob": 4.507628072053194, "Min_30.0% Prob": 3.350906771918138, "Min_40.0% Prob": 2.6003930458655726, "Min_50.0% Prob": 2.124878058462967, "Min_60.0% Prob": 1.7827528294598318}}
{"hexsha": "ce9244c6a533db19a5e950b18810a222c17694e7", "ext": "c", "lang": "C", "content": "static void TestButtons( void )\r\n{\r\n  alt_u8 buttons_tested;\r\n  alt_u8 all_tested;\r\n  /* Variable which holds the last value of edge_capture to avoid \r\n   * \"double counting\" button/switch presses\r\n   */\r\n  int last_tested;\r\n  /* Initialize the Buttons/Switches (SW0-SW3) */\r\n  init_button_pio();\r\n  /* Initialize the variables which keep track of which buttons have been tested. */\r\n  buttons_tested = 0x0;\r\n  all_tested = 0xf;\r\n\r\n  /* Initialize edge_capture to avoid any \"false\" triggers from\r\n   * a previous run.\r\n   */\r\n   \r\n  edge_capture = 0;\r\n  \r\n  /* Set last_tested to a value that edge_capture can never equal\r\n   * to avoid accidental equalities in the while() loop below.\r\n   */\r\n    \r\n  last_tested = 0xffff;\r\n\r\n  /* Print a quick message stating what is happening */\r\n  \r\n  printf(\"\\nA loop will be run until all buttons/switches have been pressed.\\n\\n\");\r\n  printf(\"\\n\\tNOTE:  Once a button press has been detected, for a particular button,\\n\\tany further presses will be ignored!\\n\\n\");\r\n  \r\n  /* Loop until all buttons have been pressed.\r\n   * This happens when buttons_tested == all_tested.\r\n   */\r\n  \r\n  while (  buttons_tested != all_tested )\r\n  { \r\n    if (last_tested == edge_capture)\r\n    {\r\n      continue;\r\n    }\r\n    else\r\n    {\r\n      last_tested = edge_capture;\r\n      switch (edge_capture)\r\n      {\r\n        case 0x1:\r\n          if (buttons_tested & 0x1)\r\n          {\r\n            continue;\r\n          }\r\n          else\r\n          {\r\n            printf(\"\\nButton 1 (SW0) Pressed.\\n\");\r\n            buttons_tested = buttons_tested | 0x1;\r\n          } \r\n          break;\r\n        case 0x2:\r\n          if (buttons_tested & 0x2)\r\n          {\r\n            continue;\r\n          } \r\n          else\r\n          {\r\n            printf(\"\\nButton 2 (SW1) Pressed.\\n\");\r\n            buttons_tested = buttons_tested | 0x2;\r\n          }\r\n          break;\r\n        case 0x4:\r\n          if (buttons_tested & 0x4)\r\n          {\r\n            continue;\r\n          }\r\n          else\r\n          {\r\n            printf(\"\\nButton 3 (SW2) Pressed.\\n\");\r\n            buttons_tested = buttons_tested | 0x4;\r\n          }\r\n          break;\r\n        case 0x8:\r\n          if (buttons_tested & 0x8)\r\n          {\r\n            continue;\r\n          }\r\n          else\r\n          {\r\n            printf(\"\\nButton 4 (SW3) Pressed.\\n\");\r\n            buttons_tested = buttons_tested | 0x8;\r\n          }\r\n          break;\r\n      }\r\n    }\r\n  }\r\n  /* Disable the button pio. */\r\n  disable_button_pio();\r\n\r\n  printf (\"\\nAll Buttons (SW0-SW3) were pressed, at least, once.\\n\");\r\n  usleep(2000000);\r\n  return;\r\n}", "item_id": 9, "repo": "wintermao/test", "file": "ddr_layout_V5/software/Boad_Diagnostics/board_diag.c", "last_update_at": "2018-05-21T08:46:51+00:00", "question_id": "ce9244c6a533db19a5e950b18810a222c17694e7_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void TestButtons( void )\r\n{\r\n  alt_u8 buttons_tested;\r\n  alt_u8 all_tested;\r\n  /* Variable which holds the last value of edge_capture to avoid \r\n   * \"double counting\" button/switch presses\r\n   */\r\n  int last_tested;\r\n  /* Initialize the Buttons/Switches (SW0-SW3) */\r\n  init_button_pio();\r\n  /* Initialize the variables which keep track of which buttons have been tested. */\r\n  buttons_tested = 0x0;\r\n  all_tested = 0xf;\r\n\r\n  /* Initialize edge_capture to avoid any \"false\" triggers from\r\n   * a previous run.\r\n   */\r\n   \r\n  edge_capture = 0;\r\n  \r\n  /* Set last_tested to a value that edge_capture can never equal\r\n   * to avoid accidental equalities in the while() loop below.\r\n   */\r\n    \r\n  last_tested = 0xffff;\r\n\r\n  /* Print a quick message stating what is happening */\r\n  \r\n  printf(\"\\nA loop will be run until all buttons/switches have been pressed.\\n\\n\");\r\n  printf(\"\\n\\tNOTE:  Once a button press has been detected, for a particular button,\\n\\tany further presses will be ignored!\\n\\n\");\r\n  \r\n  /* Loop until all buttons have been pressed.\r\n   * This happens when buttons_tested == all_tested.\r\n   */\r\n  \r\n  while (  buttons_tested != all_tested )\r\n  { \r\n    if (last_tested == edge_capture)\r\n    {\r\n      continue;\r\n    }\r\n    else\r\n    {\r\n      last_tested = edge_capture;\r\n      switch (edge_capture)\r\n      {\r\n        case 0x1:\r\n          if (buttons_tested & 0x1)\r\n          {\r\n            continue;\r\n          }\r\n          else\r\n          {\r\n            printf(\"\\nButton 1 (SW0) Pressed.\\n\");\r\n            buttons_tested = buttons_tested | 0x1;\r\n          } \r\n          break;\r\n        case 0x2:\r\n          if (buttons_tested & 0x2)\r\n          {\r\n            continue;\r\n          } \r\n          else\r\n          {\r\n            printf(\"\\nButton 2 (SW1) Pressed.\\n\");\r\n            buttons_tested = buttons_tested | 0x2;\r\n          }\r\n          break;\r\n        case 0x4:\r\n          if (buttons_tested & 0x4)\r\n          {\r\n            continue;\r\n          }\r\n          else\r\n          {\r\n            printf(\"\\nButton 3 (SW2) Pressed.\\n\");\r\n            buttons_tested = buttons_tested | 0x4;\r\n          }\r\n          break;\r\n        case 0x8:\r\n          if (buttons_tested & 0x8)\r\n          {\r\n            continue;\r\n          }\r\n          else\r\n          {\r\n            printf(\"\\nButton 4 (SW3) Pressed.\\n\");\r\n            buttons_tested = buttons_tested | 0x8;\r\n          }\r\n          break;\r\n      }\r\n    }\r\n  }\r\n  /* Disable the button pio. */\r\n  disable_button_pio();\r\n\r\n  printf (\"\\nAll Buttons (SW0-SW3) were pressed, at least, once.\\n\");\r\n  usleep(2000000);\r\n  return;\r\n"]], "pred": {"ppl": 2.2624073028564453, "ppl_lower": 2.307959794998169, "ppl/lowercase_ppl": -1.0244166898059606, "ppl/zlib": 0.0010334549678980148, "Min_5.0% Prob": 6.44282153757607, "Min_10.0% Prob": 5.097893387438303, "Min_20.0% Prob": 3.4996293233540245, "Min_30.0% Prob": 2.5946159908771516, "Min_40.0% Prob": 2.0139109139849327, "Min_50.0% Prob": 1.6297597959190964, "Min_60.0% Prob": 1.3599351659117864}}
{"hexsha": "6e1db8554c1eb81709bba7f8c8f212d1d50ca0e9", "ext": "c", "lang": "C", "content": "Tex *give_current_object_texture(Object *ob)\n{\n\tMaterial *ma, *node_ma;\n\tTex *tex = NULL;\n\t\n\tif (ob == NULL) return NULL;\n\tif (ob->totcol == 0 && !(ob->type == OB_LAMP)) return NULL;\n\t\n\tif (ob->type == OB_LAMP) {\n\t\ttex = give_current_lamp_texture(ob->data);\n\t}\n\telse {\n\t\tma = give_current_material(ob, ob->actcol);\n\n\t\tif ((node_ma = give_node_material(ma)))\n\t\t\tma = node_ma;\n\n\t\ttex = give_current_material_texture(ma);\n\t}\n\t\n\treturn tex;\n}", "item_id": 21, "repo": "1-MillionParanoidTterabytes/Blender-2.79b-blackened", "file": "source/blender/blenkernel/intern/texture.c", "last_update_at": "2018-06-18T01:50:32+00:00", "question_id": "6e1db8554c1eb81709bba7f8c8f212d1d50ca0e9_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["Tex *give_current_object_texture(Object *ob)\n{\n\tMaterial *ma, *node_ma;\n\tTex *tex = NULL;\n\t\n\tif (ob == NULL) return NULL;\n\tif (ob->totcol == 0 && !(ob->type == OB_LAMP)) return NULL;\n\t\n\tif (ob->type == OB_LAMP) {\n\t\ttex = give_current_lamp_texture(ob->data);\n\t}\n\telse {\n\t\tma = give_current_material(ob, ob->actcol);\n\t\tif ((node_ma = give_node_material(ma)))\n\t\t\tma = node_ma;\n\t\ttex = give_current_material_texture(ma);\n\t}\n\t\n\treturn tex;\n"]], "pred": {"ppl": 2.4795641899108887, "ppl_lower": 2.9735052585601807, "ppl/lowercase_ppl": -1.20004636229785, "ppl/zlib": 0.003982819363420814, "Min_5.0% Prob": 6.71152909596761, "Min_10.0% Prob": 5.05988503757276, "Min_20.0% Prob": 3.576345459008828, "Min_30.0% Prob": 2.764597724223959, "Min_40.0% Prob": 2.1793508518200655, "Min_50.0% Prob": 1.797357125687845, "Min_60.0% Prob": 1.5058211979066205}}
{"hexsha": "a939314a1dc3c74c64cebdfb9eb58237bf8ca9dc", "ext": "c", "lang": "C", "content": "static int\npthru_info_pt_list_init(int unit, size_t sid_max_count)\n{\n    unsigned int size;\n\n    SHR_FUNC_ENTER(unit);\n\n    size = sizeof(bcmltm_pt_list_t *) * sid_max_count;\n\n    /* Allocate PT List pointers */\n    SHR_ALLOC(PTHRU_PT_LIST(unit), size,\n              \"LTM PT Pass Thru info pt_list ptrs\");\n    SHR_NULL_CHECK(PTHRU_PT_LIST(unit), SHR_E_MEMORY);\n    sal_memset(PTHRU_PT_LIST(unit), 0, size);\n\n exit:\n    if (SHR_FUNC_ERR()) {\n        pthru_info_pt_list_cleanup(unit);\n    }\n\n    SHR_FUNC_EXIT();\n}", "item_id": 77, "repo": "lguohan/SDKLT", "file": "src/bcmltm/md/bcmltm_md_pthru.c", "last_update_at": "2018-01-31T07:21:49+00:00", "question_id": "a939314a1dc3c74c64cebdfb9eb58237bf8ca9dc_77", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\npthru_info_pt_list_init(int unit, size_t sid_max_count)\n{\n    unsigned int size;\n    SHR_FUNC_ENTER(unit);\n    size = sizeof(bcmltm_pt_list_t *) * sid_max_count;\n    /* Allocate PT List pointers */\n    SHR_ALLOC(PTHRU_PT_LIST(unit), size,\n              \"LTM PT Pass Thru info pt_list ptrs\");\n    SHR_NULL_CHECK(PTHRU_PT_LIST(unit), SHR_E_MEMORY);\n    sal_memset(PTHRU_PT_LIST(unit), 0, size);\n exit:\n    if (SHR_FUNC_ERR()) {\n        pthru_info_pt_list_cleanup(unit);\n    }\n    SHR_FUNC_EXIT();\n"]], "pred": {"ppl": 2.003479242324829, "ppl_lower": 3.130082845687866, "ppl/lowercase_ppl": -1.6420832162444323, "ppl/zlib": 0.0024212031022091997, "Min_5.0% Prob": 6.738515463742343, "Min_10.0% Prob": 4.995983774011785, "Min_20.0% Prob": 3.269041809770796, "Min_30.0% Prob": 2.2929404283709385, "Min_40.0% Prob": 1.7490756958102187, "Min_50.0% Prob": 1.3954376501022978, "Min_60.0% Prob": 1.1597561085239732}}
{"hexsha": "a50d2b5f365996cf5d4f17090130ce9e27fe5e5a", "ext": "c", "lang": "C", "content": "static struct pipeline* pipelineNew(char ***cmds, unsigned options)\n/* create a new pipeline object. Doesn't start processes */\n{\nstatic char *memPseudoCmd[] = {\"[mem]\", NULL};\nstruct pipeline *pl;\nint iCmd;\n\nAllocVar(pl);\npl->groupLeader = -1;\npl->pipeFd = -1;\npl->options = options;\npl->procName = joinCmds(cmds);\n\nif (cmds[0] == NULL)\n    errAbort(\"no commands in pipeline\");\n\nif (options & pipelineMemInput)\n    {\n    /* add proc for forked process to write memory to pipeline */\n    slAddTail(&pl->procs, plProcNew(memPseudoCmd, pl));\n    }\n\nfor(iCmd = 0; cmds[iCmd] != NULL; iCmd++)\n    slAddTail(&pl->procs, plProcNew(cmds[iCmd], pl));\n\nreturn pl;\n}", "item_id": 12, "repo": "bowhan/kent", "file": "src/lib/pipeline.c", "last_update_at": "2018-03-14T22:19:20+00:00", "question_id": "a50d2b5f365996cf5d4f17090130ce9e27fe5e5a_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static struct pipeline* pipelineNew(char ***cmds, unsigned options)\n/* create a new pipeline object. Doesn't start processes */\n{\nstatic char *memPseudoCmd[] = {\"[mem]\", NULL};\nstruct pipeline *pl;\nint iCmd;\nAllocVar(pl);\npl->groupLeader = -1;\npl->pipeFd = -1;\npl->options = options;\npl->procName = joinCmds(cmds);\nif (cmds[0] == NULL)\n    errAbort(\"no commands in pipeline\");\nif (options & pipelineMemInput)\n    {\n    /* add proc for forked process to write memory to pipeline */\n    slAddTail(&pl->procs, plProcNew(memPseudoCmd, pl));\n    }\nfor(iCmd = 0; cmds[iCmd] != NULL; iCmd++)\n    slAddTail(&pl->procs, plProcNew(cmds[iCmd], pl));\nreturn pl;\n"]], "pred": {"ppl": 3.59096097946167, "ppl_lower": 4.692082405090332, "ppl/lowercase_ppl": -1.2092087703123875, "ppl/zlib": 0.003436612497260681, "Min_5.0% Prob": 8.405964334805807, "Min_10.0% Prob": 6.977746566136678, "Min_20.0% Prob": 4.949040691057841, "Min_30.0% Prob": 3.8301174458530216, "Min_40.0% Prob": 3.0784163984159627, "Min_50.0% Prob": 2.537218753496806, "Min_60.0% Prob": 2.133670524461195}}
{"hexsha": "db2740a1711889c6c3b617b5fc7947353ca868ea", "ext": "c", "lang": "C", "content": "void   LSM6DS3_X_GetAxesRaw( int16_t *pData )\r\n{\r\n    /*Here we could add the check if the parameters are valid*/\r\n  \r\n    uint8_t tempReg[2] = {0,0};\r\n\r\n    LSM6DS3_IO_Read(&tempReg[0], LSM6DS3_XG_MEMS_ADDRESS, LSM6DS3_XG_OUT_X_L_XL, 2);\r\n    pData[0] = ((((int16_t)tempReg[1]) << 8)+(int16_t)tempReg[0]);\r\n\r\n    LSM6DS3_IO_Read(&tempReg[0], LSM6DS3_XG_MEMS_ADDRESS, LSM6DS3_XG_OUT_Y_L_XL, 2);\r\n    pData[1] = ((((int16_t)tempReg[1]) << 8)+(int16_t)tempReg[0]);\r\n\r\n    LSM6DS3_IO_Read(&tempReg[0], LSM6DS3_XG_MEMS_ADDRESS, LSM6DS3_XG_OUT_Z_L_XL, 2);\r\n    pData[2] = ((((int16_t)tempReg[1]) << 8)+(int16_t)tempReg[0]);\r\n    \r\n}", "item_id": 1, "repo": "LimiFrog/LimiFrog-SW", "file": "libraries/Sensor_APIs/LSM6DS3/src/LBF_lsm6ds3.c", "last_update_at": "2018-10-24T08:41:06+00:00", "question_id": "db2740a1711889c6c3b617b5fc7947353ca868ea_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void   LSM6DS3_X_GetAxesRaw( int16_t *pData )\r\n{\r\n    /*Here we could add the check if the parameters are valid*/\r\n  \r\n    uint8_t tempReg[2] = {0,0};\r\n\r\n    LSM6DS3_IO_Read(&tempReg[0], LSM6DS3_XG_MEMS_ADDRESS, LSM6DS3_XG_OUT_X_L_XL, 2);\r\n    pData[0] = ((((int16_t)tempReg[1]) << 8)+(int16_t)tempReg[0]);\r\n\r\n    LSM6DS3_IO_Read(&tempReg[0], LSM6DS3_XG_MEMS_ADDRESS, LSM6DS3_XG_OUT_Y_L_XL, 2);\r\n    pData[1] = ((((int16_t)tempReg[1]) << 8)+(int16_t)tempReg[0]);\r\n\r\n    LSM6DS3_IO_Read(&tempReg[0], LSM6DS3_XG_MEMS_ADDRESS, LSM6DS3_XG_OUT_Z_L_XL, 2);\r\n    pData[2] = ((((int16_t)tempReg[1]) << 8)+(int16_t)tempReg[0]);\r\n    \r\n"]], "pred": {"ppl": 1.651436686515808, "ppl_lower": 1.8649725914001465, "ppl/lowercase_ppl": -1.2424036445355682, "ppl/zlib": 0.0020559247055614966, "Min_5.0% Prob": 5.670035586637609, "Min_10.0% Prob": 4.055114320346287, "Min_20.0% Prob": 2.4571160150425775, "Min_30.0% Prob": 1.6736854807074582, "Min_40.0% Prob": 1.2572185881136517, "Min_50.0% Prob": 1.0060315665117066, "Min_60.0% Prob": 0.8384301356838217}}
{"hexsha": "0a4b98ae675417a93b8984c8e57d0303e06e0168", "ext": "c", "lang": "C", "content": "VL53L010_API VL53L0_Error VL53L010_PerformOffsetCalibration(VL53L0_DEV Dev,\r\n            FixPoint1616_t CalDistanceMilliMeter,\r\n            int32_t* pOffsetMicroMeter) {\r\n    VL53L0_Error Status = VL53L0_ERROR_NONE;\r\n    uint16_t sum_ranging = 0;\r\n    FixPoint1616_t total_count = 0;\r\n    VL53L0_RangingMeasurementData_t RangingMeasurementData;\r\n    FixPoint1616_t StoredMeanRange;\r\n    uint32_t StoredMeanRangeAsInt;\r\n    VL53L0_DeviceParameters_t CurrentParameters;\r\n    uint32_t CalDistanceAsInt_mm;\r\n    int meas = 0;\r\n    LOG_FUNCTION_START(\"\");\r\n\r\n    if (CalDistanceMilliMeter<=0) {\r\n        Status = VL53L0_ERROR_INVALID_PARAMS;\r\n    }\r\n\r\n    if (Status == VL53L0_ERROR_NONE) {\r\n        VL53L010_SetOffsetCalibrationDataMicroMeter(Dev, 0);\r\n    }\r\n\r\n    /* Perform 50 measurements and compute the averages */\r\n    if (Status == VL53L0_ERROR_NONE) {\r\n        sum_ranging = 0;\r\n        total_count = 0;\r\n        for(meas=0;meas<50;meas++)\r\n        {\r\n            Status = VL53L010_PerformSingleRangingMeasurement(Dev, &RangingMeasurementData);\r\n\r\n            if (Status != VL53L0_ERROR_NONE) {\r\n                break;\r\n            }\r\n\r\n            /* The range is valid when RangeStatus = 0 */\r\n            if (RangingMeasurementData.RangeStatus == 0) {\r\n                sum_ranging = sum_ranging + RangingMeasurementData.RangeMilliMeter;\r\n                total_count = total_count + 1;\r\n            }\r\n        }\r\n\r\n        if (total_count == 0) {\r\n            /* no valid values found */\r\n            Status = VL53L0_ERROR_RANGE_ERROR;\r\n        }\r\n    }\r\n\r\n\r\n    if (Status == VL53L0_ERROR_NONE) {\r\n        /* FixPoint1616_t / uint16_t = FixPoint1616_t */\r\n        StoredMeanRange = (FixPoint1616_t)((uint32_t)(sum_ranging<<16) / total_count);\r\n\r\n        StoredMeanRangeAsInt = (StoredMeanRange + 0x8000) >> 16;\r\n\r\n        /* Round Cal Distance to Whole Number.\r\n         * Note that the cal distance is in mm, therefore no resolution is lost.*/\r\n         CalDistanceAsInt_mm = (CalDistanceMilliMeter + 0x8000) >> 16;\r\n\r\n         *pOffsetMicroMeter = (CalDistanceAsInt_mm - StoredMeanRangeAsInt) * 1000;\r\n\r\n        /* Apply the calculated offset */\r\n        if (Status == VL53L0_ERROR_NONE) {\r\n            VL53L010_SETPARAMETERFIELD(Dev, RangeOffsetMicroMeters, *pOffsetMicroMeter);\r\n            Status = VL53L010_SetOffsetCalibrationDataMicroMeter(Dev, *pOffsetMicroMeter);\r\n        }\r\n\r\n    }\r\n\r\n    LOG_FUNCTION_END(Status);\r\n    return Status;\r\n}", "item_id": 44, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/drivers/misc/mediatek/laser/stmvl53l0/vl53l010_api.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "0a4b98ae675417a93b8984c8e57d0303e06e0168_44", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["VL53L010_API VL53L0_Error VL53L010_PerformOffsetCalibration(VL53L0_DEV Dev,\r\n            FixPoint1616_t CalDistanceMilliMeter,\r\n            int32_t* pOffsetMicroMeter) {\r\n    VL53L0_Error Status = VL53L0_ERROR_NONE;\r\n    uint16_t sum_ranging = 0;\r\n    FixPoint1616_t total_count = 0;\r\n    VL53L0_RangingMeasurementData_t RangingMeasurementData;\r\n    FixPoint1616_t StoredMeanRange;\r\n    uint32_t StoredMeanRangeAsInt;\r\n    VL53L0_DeviceParameters_t CurrentParameters;\r\n    uint32_t CalDistanceAsInt_mm;\r\n    int meas = 0;\r\n    LOG_FUNCTION_START(\"\");\r\n\r\n    if (CalDistanceMilliMeter<=0) {\r\n        Status = VL53L0_ERROR_INVALID_PARAMS;\r\n    }\r\n\r\n    if (Status == VL53L0_ERROR_NONE) {\r\n        VL53L010_SetOffsetCalibrationDataMicroMeter(Dev, 0);\r\n    }\r\n\r\n    /* Perform 50 measurements and compute the averages */\r\n    if (Status == VL53L0_ERROR_NONE) {\r\n        sum_ranging = 0;\r\n        total_count = 0;\r\n        for(meas=0;meas<50;meas++)\r\n        {\r\n            Status = VL53L010_PerformSingleRangingMeasurement(Dev, &RangingMeasurementData);\r\n\r\n            if (Status != VL53L0_ERROR_NONE) {\r\n                break;\r\n            }\r\n\r\n            /* The range is valid when RangeStatus = 0 */\r\n            if (RangingMeasurementData.RangeStatus == 0) {\r\n                sum_ranging = sum_ranging + RangingMeasurementData.RangeMilliMeter;\r\n                total_count = total_count + 1;\r\n            }\r\n        }\r\n\r\n        if (total_count == 0) {\r\n            /* no valid values found */\r\n            Status = VL53L0_ERROR_RANGE_ERROR;\r\n        }\r\n    }\r\n\r\n\r\n    if (Status == VL53L0_ERROR_NONE) {\r\n        /* FixPoint1616_t / uint16_t = FixPoint1616_t */\r\n        StoredMeanRange = (FixPoint1616_t)((uint32_t)(sum_ranging<<16) / total_count);\r\n\r\n        StoredMeanRangeAsInt = (StoredMeanRange + 0x8000) >> 16;\r\n\r\n        /* Round Cal Distance to Whole Number.\r\n         * Note that the cal distance is in mm, therefore no resolution is lost.*/\r\n         CalDistanceAsInt_mm = (CalDistanceMilliMeter + 0x8000) >> 16;\r\n\r\n         *pOffsetMicroMeter = (CalDistanceAsInt_mm - StoredMeanRangeAsInt) * 1000;\r\n\r\n        /* Apply the calculated offset */\r\n        if (Status == VL53L0_ERROR_NONE) {\r\n            VL53L010_SETPARAMETERFIELD(Dev, RangeOffsetMicroMeters, *pOffsetMicroMeter);\r\n            Status = VL53L010_SetOffsetCalibrationDataMicroMeter(Dev, *pOffsetMicroMeter);\r\n        }\r\n\r\n    }\r\n\r\n    LOG_FUNCTION_END(Status);\r\n    return Status;\r\n"]], "pred": {"ppl": 1.7400273084640503, "ppl_lower": 2.325185537338257, "ppl/lowercase_ppl": -1.5233771557084164, "ppl/zlib": 0.0007074084388542134, "Min_5.0% Prob": 5.582704134609388, "Min_10.0% Prob": 4.0697169906349595, "Min_20.0% Prob": 2.5914945576780584, "Min_30.0% Prob": 1.82025524995233, "Min_40.0% Prob": 1.3819556890696447, "Min_50.0% Prob": 1.1068018881270318, "Min_60.0% Prob": 0.92338358581421}}
{"hexsha": "a50d2b5f365996cf5d4f17090130ce9e27fe5e5a", "ext": "c", "lang": "C", "content": "static void waitOnOne(struct pipeline *pl)\n/* wait on one process to finish */\n{\nint status;\npid_t pid = waitpid(-pl->groupLeader, &status, 0);\nif (pid < 0)\n    errnoAbort(\"waitpid failed\");\nplProcHandleTerminate(pipelineFindProc(pl, pid), status);\npl->numRunning--;\nassert(pl->numRunning >= 0);\n}", "item_id": 16, "repo": "bowhan/kent", "file": "src/lib/pipeline.c", "last_update_at": "2018-03-14T22:19:20+00:00", "question_id": "a50d2b5f365996cf5d4f17090130ce9e27fe5e5a_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void waitOnOne(struct pipeline *pl)\n/* wait on one process to finish */\n{\nint status;\npid_t pid = waitpid(-pl->groupLeader, &status, 0);\nif (pid < 0)\n    errnoAbort(\"waitpid failed\");\nplProcHandleTerminate(pipelineFindProc(pl, pid), status);\npl->numRunning--;\nassert(pl->numRunning >= 0);\n"]], "pred": {"ppl": 3.8773176670074463, "ppl_lower": 4.683172702789307, "ppl/lowercase_ppl": -1.1393448028154212, "ppl/zlib": 0.0063029934494189055, "Min_5.0% Prob": 8.69407615661621, "Min_10.0% Prob": 7.2257044315338135, "Min_20.0% Prob": 5.26097922098069, "Min_30.0% Prob": 4.075120183729356, "Min_40.0% Prob": 3.240032570702689, "Min_50.0% Prob": 2.689326340475908, "Min_60.0% Prob": 2.245578753333243}}
{"hexsha": "a251ddb2edb7ec8f8cc82e043da7f23406efdebf", "ext": "c", "lang": "C", "content": "static void parseDatabaseLines(struct blastFile *bf, char *line, struct blastQuery *bq)\n/* Process something like:\n * Database: chr22.fa \n *        977 sequences; 95,550,797 total letters\n */\n{\nstatic struct dyString *tmpBuf = NULL;\nchar *words[16];\nint wordCount;\nif (bq->database != NULL)\n    bfError(bf, \"already parse Database:\");\n\nif (tmpBuf == NULL)\n    tmpBuf = dyStringNew(512);\n\n/* parse something like\n * Database: celegans98\n * some versions of blastp include the absolute path, but\n * then split it across lines.\n */\nwordCount = chopLine(line, words);\nif (wordCount < 2)\n    bfError(bf, \"Expecting database name\");\ndyStringClear(tmpBuf);\ndyStringAppend(tmpBuf, words[1]);\nwhile (line = bfNeedNextLine(bf), !isspace(line[0]))\n    {\n    dyStringAppend(tmpBuf, line);\n    }\nbq->database = cloneString(tmpBuf->string);\n\n/* Process something like:\n *        977 sequences; 95,550,797 total letters\n */\nwordCount = chopLine(line, words);\nif (wordCount < 3 || !isdigit(words[0][0]) || !isdigit(words[2][0]))\n    bfError(bf, \"Expecting database info\");\ndecomma(words[0]);\ndecomma(words[2]);\nbq->dbSeqCount = atoi(words[0]);\nbq->dbBaseCount = atoi(words[2]);\n}", "item_id": 6, "repo": "zrhanna/blatq", "file": "blatSrc/lib/blastParse.c", "last_update_at": "2018-03-14T22:19:20+00:00", "question_id": "a251ddb2edb7ec8f8cc82e043da7f23406efdebf_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void parseDatabaseLines(struct blastFile *bf, char *line, struct blastQuery *bq)\n/* Process something like:\n * Database: chr22.fa \n *        977 sequences; 95,550,797 total letters\n */\n{\nstatic struct dyString *tmpBuf = NULL;\nchar *words[16];\nint wordCount;\nif (bq->database != NULL)\n    bfError(bf, \"already parse Database:\");\nif (tmpBuf == NULL)\n    tmpBuf = dyStringNew(512);\n/* parse something like\n * Database: celegans98\n * some versions of blastp include the absolute path, but\n * then split it across lines.\n */\nwordCount = chopLine(line, words);\nif (wordCount < 2)\n    bfError(bf, \"Expecting database name\");\ndyStringClear(tmpBuf);\ndyStringAppend(tmpBuf, words[1]);\nwhile (line = bfNeedNextLine(bf), !isspace(line[0]))\n    {\n    dyStringAppend(tmpBuf, line);\n    }\nbq->database = cloneString(tmpBuf->string);\n/* Process something like:\n *        977 sequences; 95,550,797 total letters\n */\nwordCount = chopLine(line, words);\nif (wordCount < 3 || !isdigit(words[0][0]) || !isdigit(words[2][0]))\n    bfError(bf, \"Expecting database info\");\ndecomma(words[0]);\ndecomma(words[2]);\nbq->dbSeqCount = atoi(words[0]);\nbq->dbBaseCount = atoi(words[2]);\n"]], "pred": {"ppl": 2.94711971282959, "ppl_lower": 3.5321884155273438, "ppl/lowercase_ppl": -1.1675467764601415, "ppl/zlib": 0.002043153733196876, "Min_5.0% Prob": 8.105093365623837, "Min_10.0% Prob": 6.398641387621562, "Min_20.0% Prob": 4.4481229080873375, "Min_30.0% Prob": 3.3978358688764274, "Min_40.0% Prob": 2.6630788346131644, "Min_50.0% Prob": 2.156750554062217, "Min_60.0% Prob": 1.8017417450330369}}
{"hexsha": "cec2808f7a46487741be74664dfa5d8d6b8a532a", "ext": "c", "lang": "C", "content": "void Auddrv_Set_UnderFlow(void)\n{\n\tunsigned long long underflow_time = sched_clock();\t/* in ns (10^9) */\n\n\tpr_debug(\"%s UnderflowCounter = %d\\n\", __func__, UnderflowCounter);\n\tUnderflowTime[UnderflowCounter] = underflow_time;\n\tUnderflowCounter++;\n\tUnderflowCounter %= UnderflowrecordNumber;\n\tif (UnderflowCounter > UnderflowThreshold) {\n\t\tDumpUnderFlowTime();\n\t\tAuddrv_Aee_Dump();\n\t}\n}", "item_id": 2, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/sound/soc/mediatek/common/auddrv_underflow_mach.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "cec2808f7a46487741be74664dfa5d8d6b8a532a_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void Auddrv_Set_UnderFlow(void)\n{\n\tunsigned long long underflow_time = sched_clock();\t/* in ns (10^9) */\n\tpr_debug(\"%s UnderflowCounter = %d\\n\", __func__, UnderflowCounter);\n\tUnderflowTime[UnderflowCounter] = underflow_time;\n\tUnderflowCounter++;\n\tUnderflowCounter %= UnderflowrecordNumber;\n\tif (UnderflowCounter > UnderflowThreshold) {\n\t\tDumpUnderFlowTime();\n\t\tAuddrv_Aee_Dump();\n\t}\n"]], "pred": {"ppl": 5.418256759643555, "ppl_lower": 4.322449684143066, "ppl/lowercase_ppl": -0.8662828183756985, "ppl/zlib": 0.007346844055022247, "Min_5.0% Prob": 10.071821280888148, "Min_10.0% Prob": 7.7614050933292935, "Min_20.0% Prob": 5.899369742189135, "Min_30.0% Prob": 4.709478914737701, "Min_40.0% Prob": 3.857341100062643, "Min_50.0% Prob": 3.240290881906237, "Min_60.0% Prob": 2.774747013690926}}
{"hexsha": "b747e136a0ae17b2651c7ef73e845960c19132ba", "ext": "c", "lang": "C", "content": "int gps_v2_get_identity(GPSV2 *gps_v2, char ret_uid[8], char ret_connected_uid[8], char *ret_position, uint8_t ret_hardware_version[3], uint8_t ret_firmware_version[3], uint16_t *ret_device_identifier) {\n\tDevicePrivate *device_p = gps_v2->p;\n\tGetIdentity_Request request;\n\tGetIdentity_Response response;\n\tint ret;\n\n\tret = packet_header_create(&request.header, sizeof(request), GPS_V2_FUNCTION_GET_IDENTITY, device_p->ipcon_p, device_p);\n\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tret = device_send_request(device_p, (Packet *)&request, (Packet *)&response);\n\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tmemcpy(ret_uid, response.uid, 8);\n\tmemcpy(ret_connected_uid, response.connected_uid, 8);\n\t*ret_position = response.position;\n\tmemcpy(ret_hardware_version, response.hardware_version, 3 * sizeof(uint8_t));\n\tmemcpy(ret_firmware_version, response.firmware_version, 3 * sizeof(uint8_t));\n\t*ret_device_identifier = leconvert_uint16_from(response.device_identifier);\n\n\treturn ret;\n}", "item_id": 40, "repo": "ulrichwi/ros-tinkerforge_sensors", "file": "src/tinkerforge/bricklet_gps_v2.c", "last_update_at": "2018-12-11T16:04:42+00:00", "question_id": "b747e136a0ae17b2651c7ef73e845960c19132ba_40", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int gps_v2_get_identity(GPSV2 *gps_v2, char ret_uid[8], char ret_connected_uid[8], char *ret_position, uint8_t ret_hardware_version[3], uint8_t ret_firmware_version[3], uint16_t *ret_device_identifier) {\n\tDevicePrivate *device_p = gps_v2->p;\n\tGetIdentity_Request request;\n\tGetIdentity_Response response;\n\tint ret;\n\tret = packet_header_create(&request.header, sizeof(request), GPS_V2_FUNCTION_GET_IDENTITY, device_p->ipcon_p, device_p);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\tret = device_send_request(device_p, (Packet *)&request, (Packet *)&response);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\tmemcpy(ret_uid, response.uid, 8);\n\tmemcpy(ret_connected_uid, response.connected_uid, 8);\n\t*ret_position = response.position;\n\tmemcpy(ret_hardware_version, response.hardware_version, 3 * sizeof(uint8_t));\n\tmemcpy(ret_firmware_version, response.firmware_version, 3 * sizeof(uint8_t));\n\t*ret_device_identifier = leconvert_uint16_from(response.device_identifier);\n\treturn ret;\n"]], "pred": {"ppl": 2.3418009281158447, "ppl_lower": 2.4532315731048584, "ppl/lowercase_ppl": -1.0546301530753985, "ppl/zlib": 0.002121995662738767, "Min_5.0% Prob": 7.82909533712599, "Min_10.0% Prob": 5.7657758351918815, "Min_20.0% Prob": 3.7603351656595865, "Min_30.0% Prob": 2.7355274761145094, "Min_40.0% Prob": 2.1111306626571724, "Min_50.0% Prob": 1.697360069870397, "Min_60.0% Prob": 1.4219695177934735}}
{"hexsha": "4823676ad6844e731fa8b954793205d99a5fd9e0", "ext": "c", "lang": "C", "content": "static void do_power()\n{\n  if(IS_INTEGER(peek(0)) && IS_INTEGER(peek(1)))\n  {\n    double b = (double)AS_INTEGER(pop())->value;\n    double a = (double)AS_INTEGER(pop())->value;\n\n    push(AS_OBJECT(create_integer(pow(a, b))));\n    return;\n  }\n\n  if(IS_REAL(peek(0)) && IS_REAL(peek(1)))\n  {\n    double b = AS_REAL(pop())->value;\n    double a = AS_REAL(pop())->value;\n\n    push(AS_OBJECT(create_real(pow(a, b))));\n    return;\n  }\n\n  if(IS_INTEGER(peek(0)) && IS_REAL(peek(1)))\n  {\n    double b = (double)AS_INTEGER(pop())->value;\n    double a = AS_REAL(pop())->value;\n\n    push(AS_OBJECT(create_real(pow(a, b))));\n    return;\n  }\n\n  if(IS_REAL(peek(0)) && IS_INTEGER(peek(1)))\n  {\n    double b = AS_REAL(pop())->value;\n    double a = (double)AS_INTEGER(pop())->value;\n\n    push(AS_OBJECT(create_real(pow(a, b))));\n    return;\n  }\n}", "item_id": 12, "repo": "dlains/cube", "file": "src/vm.c", "last_update_at": "2018-08-20T00:28:37+00:00", "question_id": "4823676ad6844e731fa8b954793205d99a5fd9e0_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void do_power()\n{\n  if(IS_INTEGER(peek(0)) && IS_INTEGER(peek(1)))\n  {\n    double b = (double)AS_INTEGER(pop())->value;\n    double a = (double)AS_INTEGER(pop())->value;\n    push(AS_OBJECT(create_integer(pow(a, b))));\n    return;\n  }\n  if(IS_REAL(peek(0)) && IS_REAL(peek(1)))\n  {\n    double b = AS_REAL(pop())->value;\n    double a = AS_REAL(pop())->value;\n    push(AS_OBJECT(create_real(pow(a, b))));\n    return;\n  }\n  if(IS_INTEGER(peek(0)) && IS_REAL(peek(1)))\n  {\n    double b = (double)AS_INTEGER(pop())->value;\n    double a = AS_REAL(pop())->value;\n    push(AS_OBJECT(create_real(pow(a, b))));\n    return;\n  }\n  if(IS_REAL(peek(0)) && IS_INTEGER(peek(1)))\n  {\n    double b = AS_REAL(pop())->value;\n    double a = (double)AS_INTEGER(pop())->value;\n    push(AS_OBJECT(create_real(pow(a, b))));\n    return;\n  }\n"]], "pred": {"ppl": 1.3756637573242188, "ppl_lower": 1.3896795511245728, "ppl/lowercase_ppl": -1.0317832528427893, "ppl/zlib": 0.0015044167322644751, "Min_5.0% Prob": 4.497291326522827, "Min_10.0% Prob": 2.9302521863499202, "Min_20.0% Prob": 1.5864418251812458, "Min_30.0% Prob": 1.060719944858116, "Min_40.0% Prob": 0.8006667937307308, "Min_50.0% Prob": 0.6392519893075161, "Min_60.0% Prob": 0.531921854201216}}
{"hexsha": "63ecf77d31e5552017e09759b47aeb1545443ee5", "ext": "c", "lang": "C", "content": "void musb_start(struct musb *musb)\n{\n\tu8 devctl = (u8) os_readl(U3D_DEVICE_CONTROL);\n\n\tdev_dbg(musb->controller, \"<== devctl %02x\\n\", devctl);\n\n\tos_printk(K_INFO, \"%s\\n\", __func__);\n\n\tif (musb->is_clk_on == 0) {\n#ifndef CONFIG_MTK_FPGA\n\t\t/* Recovert PHY. And turn on CLK. */\n\t\tusb_phy_recover(musb->is_clk_on);\n\t\tmusb->is_clk_on = 1;\n\n\t\t/* USB 2.0 slew rate calibration */\n\t\tu3phy_ops->u2_slew_rate_calibration(u3phy);\n#endif\n\n\t\t/* disable IP reset and power down, disable U2/U3 ip power down */\n\t\t_ex_mu3d_hal_ssusb_en();\n\n\t\t/* USB PLL Force settings */\n#ifdef CONFIG_PROJECT_PHY\n\t\tusb20_pll_settings(false, false);\n#endif\n\n\t\t/* reset U3D all dev module. */\n\t\tmu3d_hal_rst_dev();\n\n\t\t/*\n\t\t * SW workaround of SSUSB device mode fake disable interrupt\n\t\t * 1. Clear SSUSB_U3_PORT_DIS @ _ex_mu3d_hal_ssusb_en()\n\t\t * 2. Wait SSUSB_U3_MAC_RST_B_STS change to 1. @ mu3d_hal_check_clk_sts()\n\t\t * 3. Delay 50us\n\t\t * 4. Clear U3 interrupt @ mu3d_hal_check_clk_sts()\n\t\t * Recommended value : 50us\n\t\t */\n\t\tudelay(20);\n\n\t\tmusb_restore_context(musb);\n\t}\n\n\t/*Enable Level 1 interrupt (BMU, QMU, MAC3, DMA, MAC2, EPCTL) */\n\tos_writel(U3D_LV1IESR, 0xFFFFFFFF);\n\n\t/* Initialize the default interrupts */\n\t_ex_mu3d_hal_system_intr_en();\n\n#ifdef USB_GADGET_SUPERSPEED\n\t/* HS/FS detected by HW */\n\t/* USB2.0 controller will negotiate for HS mode when the device is reset by the host */\n\tos_writel(U3D_POWER_MANAGEMENT, (os_readl(U3D_POWER_MANAGEMENT) | HS_ENABLE));\n\n\t/* set LPM remote wake up enable by HW */\n\tos_writel(U3D_POWER_MANAGEMENT, (os_readl(U3D_POWER_MANAGEMENT) | LPM_HRWE));\n\tos_writel(U3D_USB2_EPCTL_LPM, (L1_EXIT_EP0_CHK | L1_EXIT_EP_IN_CHK | L1_EXIT_EP_OUT_CHK));\n\tos_writel(U3D_USB2_EPCTL_LPM_FC_CHK,\n\t\t  (L1_EXIT_EP0_FC_CHK | L1_EXIT_EP_IN_FC_CHK | L1_EXIT_EP_OUT_FC_CHK));\n\n#ifdef CONFIG_USBIF_COMPLIANCE\n\t/* Accept LGO_U1/U2 at beginning */\n\tos_writel(U3D_LINK_POWER_CONTROL,\n\t\t  os_readl(U3D_LINK_POWER_CONTROL) | SW_U1_ACCEPT_ENABLE | SW_U2_ACCEPT_ENABLE);\n\n\t/* 3us timeout for PENDING HP */\n\tos_writel(U3D_LINK_HP_TIMER, (os_readl(U3D_LINK_HP_TIMER) & ~(PHP_TIMEOUT_VALUE)) | 0x6);\n\n\t/* set vbus force enable */\n\tos_setmsk(U3D_MISC_CTRL, (VBUS_FRC_EN | VBUS_ON));\n#endif\n\n\t/* device responses to u3_exit from host automatically */\n\tos_writel(U3D_LTSSM_CTRL, os_readl(U3D_LTSSM_CTRL) & ~SOFT_U3_EXIT_EN);\n\n#else\n#ifdef USB_GADGET_DUALSPEED\n\t/* HS/FS detected by HW */\n\tos_writel(U3D_POWER_MANAGEMENT, os_readl(U3D_POWER_MANAGEMENT) | HS_ENABLE);\n#else\n\t/* FS only */\n\tos_writel(U3D_POWER_MANAGEMENT, os_readl(U3D_POWER_MANAGEMENT) & ~HS_ENABLE);\n#endif\n\t/* disable U3 port */\n\tmu3d_hal_u3dev_dis();\n#endif\n\n#ifndef CONFIG_MTK_FPGA\n\t/*if (mt_get_chip_hw_code() == 0x6595) */\n\t{\n\t\tos_printk(K_INFO, \"%s Set Clock to 62.4MHz+\\n\", __func__);\n\t\t/* sys_ck = OSC 124.8MHz/2 = 62.4MHz */\n\t\tos_setmsk(U3D_SSUSB_SYS_CK_CTRL, SSUSB_SYS_CK_DIV2_EN);\n\t\t/* U2 MAC sys_ck = ceil(62.4) = 63 */\n\t\tos_writelmsk(U3D_USB20_TIMING_PARAMETER, 63, TIME_VALUE_1US);\n#ifdef SUPPORT_U3\n\t\t/* U3 MAC sys_ck = ceil(62.4) = 63 */\n\t\tos_writelmsk(U3D_TIMING_PULSE_CTRL, 63, CNT_1US_VALUE);\n#endif\n\t\tos_printk(K_INFO, \"%s Set Clock to 62.4MHz-\\n\", __func__);\n\t}\n#endif\n\n\tos_writel(U3D_LINK_RESET_INFO, os_readl(U3D_LINK_RESET_INFO) & ~WTCHRP);\n\n\t/* U2/U3 detected by HW */\n\tos_writel(U3D_DEVICE_CONF, 0);\n\n\tmusb->is_active = 1;\n\n\tmusb_platform_enable(musb);\n\n#ifdef EP_PROFILING\n\tif (is_prof != 0)\n\t\tschedule_delayed_work(&musb->ep_prof_work, msecs_to_jiffies(POLL_INTERVAL * 1000));\n#endif\n\n\tif (musb->softconnect)\n\t\tmu3d_hal_u3dev_en();\n}", "item_id": 9, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/drivers/misc/mediatek/mu3d/drv/musb_core.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "63ecf77d31e5552017e09759b47aeb1545443ee5_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void musb_start(struct musb *musb)\n{\n\tu8 devctl = (u8) os_readl(U3D_DEVICE_CONTROL);\n\tdev_dbg(musb->controller, \"<== devctl %02x\\n\", devctl);\n\tos_printk(K_INFO, \"%s\\n\", __func__);\n\tif (musb->is_clk_on == 0) {\n#ifndef CONFIG_MTK_FPGA\n\t\t/* Recovert PHY. And turn on CLK. */\n\t\tusb_phy_recover(musb->is_clk_on);\n\t\tmusb->is_clk_on = 1;\n\t\t/* USB 2.0 slew rate calibration */\n\t\tu3phy_ops->u2_slew_rate_calibration(u3phy);\n#endif\n\t\t/* disable IP reset and power down, disable U2/U3 ip power down */\n\t\t_ex_mu3d_hal_ssusb_en();\n\t\t/* USB PLL Force settings */\n#ifdef CONFIG_PROJECT_PHY\n\t\tusb20_pll_settings(false, false);\n#endif\n\t\t/* reset U3D all dev module. */\n\t\tmu3d_hal_rst_dev();\n\t\t/*\n\t\t * SW workaround of SSUSB device mode fake disable interrupt\n\t\t * 1. Clear SSUSB_U3_PORT_DIS @ _ex_mu3d_hal_ssusb_en()\n\t\t * 2. Wait SSUSB_U3_MAC_RST_B_STS change to 1. @ mu3d_hal_check_clk_sts()\n\t\t * 3. Delay 50us\n\t\t * 4. Clear U3 interrupt @ mu3d_hal_check_clk_sts()\n\t\t * Recommended value : 50us\n\t\t */\n\t\tudelay(20);\n\t\tmusb_restore_context(musb);\n\t}\n\t/*Enable Level 1 interrupt (BMU, QMU, MAC3, DMA, MAC2, EPCTL) */\n\tos_writel(U3D_LV1IESR, 0xFFFFFFFF);\n\t/* Initialize the default interrupts */\n\t_ex_mu3d_hal_system_intr_en();\n#ifdef USB_GADGET_SUPERSPEED\n\t/* HS/FS detected by HW */\n\t/* USB2.0 controller will negotiate for HS mode when the device is reset by the host */\n\tos_writel(U3D_POWER_MANAGEMENT, (os_readl(U3D_POWER_MANAGEMENT) | HS_ENABLE));\n\t/* set LPM remote wake up enable by HW */\n\tos_writel(U3D_POWER_MANAGEMENT, (os_readl(U3D_POWER_MANAGEMENT) | LPM_HRWE));\n\tos_writel(U3D_USB2_EPCTL_LPM, (L1_EXIT_EP0_CHK | L1_EXIT_EP_IN_CHK | L1_EXIT_EP_OUT_CHK));\n\tos_writel(U3D_USB2_EPCTL_LPM_FC_CHK,\n\t\t  (L1_EXIT_EP0_FC_CHK | L1_EXIT_EP_IN_FC_CHK | L1_EXIT_EP_OUT_FC_CHK));\n#ifdef CONFIG_USBIF_COMPLIANCE\n\t/* Accept LGO_U1/U2 at beginning */\n\tos_writel(U3D_LINK_POWER_CONTROL,\n\t\t  os_readl(U3D_LINK_POWER_CONTROL) | SW_U1_ACCEPT_ENABLE | SW_U2_ACCEPT_ENABLE);\n\t/* 3us timeout for PENDING HP */\n\tos_writel(U3D_LINK_HP_TIMER, (os_readl(U3D_LINK_HP_TIMER) & ~(PHP_TIMEOUT_VALUE)) | 0x6);\n\t/* set vbus force enable */\n\tos_setmsk(U3D_MISC_CTRL, (VBUS_FRC_EN | VBUS_ON));\n#endif\n\t/* device responses to u3_exit from host automatically */\n\tos_writel(U3D_LTSSM_CTRL, os_readl(U3D_LTSSM_CTRL) & ~SOFT_U3_EXIT_EN);\n#else\n#ifdef USB_GADGET_DUALSPEED\n\t/* HS/FS detected by HW */\n\tos_writel(U3D_POWER_MANAGEMENT, os_readl(U3D_POWER_MANAGEMENT) | HS_ENABLE);\n#else\n\t/* FS only */\n\tos_writel(U3D_POWER_MANAGEMENT, os_readl(U3D_POWER_MANAGEMENT) & ~HS_ENABLE);\n#endif\n\t/* disable U3 port */\n\tmu3d_hal_u3dev_dis();\n#endif\n#ifndef CONFIG_MTK_FPGA\n\t/*if (mt_get_chip_hw_code() == 0x6595) */\n\t{\n\t\tos_printk(K_INFO, \"%s Set Clock to 62.4MHz+\\n\", __func__);\n\t\t/* sys_ck = OSC 124.8MHz/2 = 62.4MHz */\n\t\tos_setmsk(U3D_SSUSB_SYS_CK_CTRL, SSUSB_SYS_CK_DIV2_EN);\n\t\t/* U2 MAC sys_ck = ceil(62.4) = 63 */\n\t\tos_writelmsk(U3D_USB20_TIMING_PARAMETER, 63, TIME_VALUE_1US);\n#ifdef SUPPORT_U3\n\t\t/* U3 MAC sys_ck = ceil(62.4) = 63 */\n\t\tos_writelmsk(U3D_TIMING_PULSE_CTRL, 63, CNT_1US_VALUE);\n#endif\n\t\tos_printk(K_INFO, \"%s Set Clock to 62.4MHz-\\n\", __func__);\n\t}\n#endif\n\tos_writel(U3D_LINK_RESET_INFO, os_readl(U3D_LINK_RESET_INFO) & ~WTCHRP);\n\t/* U2/U3 detected by HW */\n\tos_writel(U3D_DEVICE_CONF, 0);\n\tmusb->is_active = 1;\n\tmusb_platform_enable(musb);\n#ifdef EP_PROFILING\n\tif (is_prof != 0)\n\t\tschedule_delayed_work(&musb->ep_prof_work, msecs_to_jiffies(POLL_INTERVAL * 1000));\n#endif\n\tif (musb->softconnect)\n\t\tmu3d_hal_u3dev_en();\n"]], "pred": {"ppl": 3.1442368030548096, "ppl_lower": 3.9372329711914062, "ppl/lowercase_ppl": -1.1963273832790209, "ppl/zlib": 0.0007472740970439747, "Min_5.0% Prob": 8.131639003753662, "Min_10.0% Prob": 6.44218084858913, "Min_20.0% Prob": 4.682436901564691, "Min_30.0% Prob": 3.5665732100119, "Min_40.0% Prob": 2.8007480440192234, "Min_50.0% Prob": 2.2791959816579017, "Min_60.0% Prob": 1.909021428234717}}
{"hexsha": "c54f9de1e317817c7aba633dea765002c2ca38c8", "ext": "c", "lang": "C", "content": "PUBLIC int do_rs_set_priv(message *m)\r\n{\r\n\tint r, n, nr;\r\n\tstruct vmproc *vmp;\r\n\r\n\tnr = m->VM_RS_NR;\r\n\r\n\tif ((r = vm_isokendpt(nr, &n)) != OK) {\r\n\t\tprintf(\"do_rs_set_priv: message from strange source %d\\n\", nr);\r\n\t\treturn EINVAL;\r\n\t}\r\n\r\n\tvmp = &vmproc[n];\r\n\r\n\tif (m->VM_RS_BUF) {\r\n\t\tr = sys_datacopy(m->m_source, (vir_bytes) m->VM_RS_BUF,\r\n\t\t\t\t SELF, (vir_bytes) vmp->vm_call_mask,\r\n\t\t\t\t sizeof(vmp->vm_call_mask));\r\n\t\tif (r != OK)\r\n\t\t\treturn r;\r\n\t}\r\n\r\n\treturn OK;\r\n}", "item_id": 0, "repo": "ducis/operating-system-labs", "file": "src.clean/servers/vm/rs.c", "last_update_at": "2018-03-01T14:11:47+00:00", "question_id": "c54f9de1e317817c7aba633dea765002c2ca38c8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["PUBLIC int do_rs_set_priv(message *m)\r\n{\r\n\tint r, n, nr;\r\n\tstruct vmproc *vmp;\r\n\r\n\tnr = m->VM_RS_NR;\r\n\r\n\tif ((r = vm_isokendpt(nr, &n)) != OK) {\r\n\t\tprintf(\"do_rs_set_priv: message from strange source %d\\n\", nr);\r\n\t\treturn EINVAL;\r\n\t}\r\n\r\n\tvmp = &vmproc[n];\r\n\r\n\tif (m->VM_RS_BUF) {\r\n\t\tr = sys_datacopy(m->m_source, (vir_bytes) m->VM_RS_BUF,\r\n\t\t\t\t SELF, (vir_bytes) vmp->vm_call_mask,\r\n\t\t\t\t sizeof(vmp->vm_call_mask));\r\n\t\tif (r != OK)\r\n\t\t\treturn r;\r\n\t}\r\n\r\n\treturn OK;\r\n"]], "pred": {"ppl": 2.4267289638519287, "ppl_lower": 3.1914546489715576, "ppl/lowercase_ppl": -1.3089891700824874, "ppl/zlib": 0.003078278628916564, "Min_5.0% Prob": 6.5632380138744, "Min_10.0% Prob": 5.505482798037321, "Min_20.0% Prob": 3.8031666431021183, "Min_30.0% Prob": 2.821174019659069, "Min_40.0% Prob": 2.200891748070717, "Min_50.0% Prob": 1.7731741300894548, "Min_60.0% Prob": 1.4779283022245682}}
{"hexsha": "2fd8c1a81231480b907abbc4ae86eea3f771c31a", "ext": "c", "lang": "C", "content": "UCHAR GarbageChar(PC0C_IO_PORT pWriteIoPort, PC0C_IO_PORT pReadIoPort, PUCHAR pLsr)\r\n{\r\n  if (pWriteIoPort->lineControl.Parity != NO_PARITY && RAND()%2 > 0)\r\n    ParityError(pReadIoPort, pLsr);\r\n\r\n  if (RAND()%2 > 0)\r\n    FrameError(pReadIoPort, pLsr);\r\n\r\n  return (UCHAR)RAND();\r\n}", "item_id": 3, "repo": "ooici/coi-services", "file": "ion/agents/instrument/direct_access/Com0Com/com0com-2.2.2.0/sys/noise.c", "last_update_at": "2018-08-10T01:41:38+00:00", "question_id": "2fd8c1a81231480b907abbc4ae86eea3f771c31a_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["UCHAR GarbageChar(PC0C_IO_PORT pWriteIoPort, PC0C_IO_PORT pReadIoPort, PUCHAR pLsr)\r\n{\r\n  if (pWriteIoPort->lineControl.Parity != NO_PARITY && RAND()%2 > 0)\r\n    ParityError(pReadIoPort, pLsr);\r\n\r\n  if (RAND()%2 > 0)\r\n    FrameError(pReadIoPort, pLsr);\r\n\r\n  return (UCHAR)RAND();\r\n"]], "pred": {"ppl": 4.8894877433776855, "ppl_lower": 7.4690351486206055, "ppl/lowercase_ppl": -1.266953317967662, "ppl/zlib": 0.009069071668822907, "Min_5.0% Prob": 8.92739741007487, "Min_10.0% Prob": 7.6500474489652195, "Min_20.0% Prob": 5.966959008803735, "Min_30.0% Prob": 4.704959484247061, "Min_40.0% Prob": 3.809878859382409, "Min_50.0% Prob": 3.140129403426097, "Min_60.0% Prob": 2.6522012192469377}}
{"hexsha": "9628ceccfa02f195b83f8989a7064f0411bc0ab3", "ext": "c", "lang": "C", "content": "int\t\t\t\t\t\t/* error */\nxfs_dir2_block_replace(\n\txfs_da_args_t\t\t*args)\t\t/* directory operation args */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\tent;\t\t/* leaf entry index */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\n\ttrace_xfs_dir2_block_replace(args);\n\n\t/*\n\t * Lookup the entry in the directory.  Get buffer and entry index.\n\t * This will always succeed since the caller has already done a lookup.\n\t */\n\tif ((error = xfs_dir2_block_lookup_int(args, &bp, &ent))) {\n\t\treturn error;\n\t}\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\thdr = bp->b_addr;\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Point to the data entry we need to change.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(blp[ent].address)));\n\tASSERT(be64_to_cpu(dep->inumber) != args->inumber);\n\t/*\n\t * Change the inode number to the new value.\n\t */\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\txfs_dir3_data_check(dp, bp);\n\treturn 0;\n}", "item_id": 13, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/fs/xfs/libxfs/xfs_dir2_block.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "9628ceccfa02f195b83f8989a7064f0411bc0ab3_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\t\t\t\t\t\t/* error */\nxfs_dir2_block_replace(\n\txfs_da_args_t\t\t*args)\t\t/* directory operation args */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\tent;\t\t/* leaf entry index */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\ttrace_xfs_dir2_block_replace(args);\n\t/*\n\t * Lookup the entry in the directory.  Get buffer and entry index.\n\t * This will always succeed since the caller has already done a lookup.\n\t */\n\tif ((error = xfs_dir2_block_lookup_int(args, &bp, &ent))) {\n\t\treturn error;\n\t}\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\thdr = bp->b_addr;\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Point to the data entry we need to change.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(blp[ent].address)));\n\tASSERT(be64_to_cpu(dep->inumber) != args->inumber);\n\t/*\n\t * Change the inode number to the new value.\n\t */\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\txfs_dir3_data_check(dp, bp);\n\treturn 0;\n"]], "pred": {"ppl": 1.6506147384643555, "ppl_lower": 1.6935162544250488, "ppl/lowercase_ppl": -1.0512008727030877, "ppl/zlib": 0.0007892091138460726, "Min_5.0% Prob": 4.761604420344034, "Min_10.0% Prob": 3.421955276708134, "Min_20.0% Prob": 2.2459722839719882, "Min_30.0% Prob": 1.6194609678274876, "Min_40.0% Prob": 1.2437639525725774, "Min_50.0% Prob": 1.0004833172403975, "Min_60.0% Prob": 0.8367064269700062}}
{"hexsha": "3c4e95296087bdb9f6d02f3c7d14fb34bcbe2d6d", "ext": "c", "lang": "C", "content": "void hprdPrimaryRefSave(struct hprdPrimaryRef *obj, int indent, FILE *f)\n/* Save hprdPrimaryRef to file. */\n{\nif (obj == NULL) return;\nxapIndent(indent, f);\nfprintf(f, \"<primaryRef\");\nfprintf(f, \" db=\\\"%s\\\"\", obj->db);\nfprintf(f, \" id=\\\"%s\\\"\", obj->id);\nif (obj->dbAc != NULL)\n    fprintf(f, \" dbAc=\\\"%s\\\"\", obj->dbAc);\nif (obj->refType != NULL)\n    fprintf(f, \" refType=\\\"%s\\\"\", obj->refType);\nif (obj->refTypeAc != NULL)\n    fprintf(f, \" refTypeAc=\\\"%s\\\"\", obj->refTypeAc);\nfprintf(f, \"/>\\n\");\n}", "item_id": 28, "repo": "CEpBrowser/CEpBrowser--from-UCSC-CGI-BIN", "file": "hg/near/hprdXmlToTab/hprd.c", "last_update_at": "2018-03-14T22:19:20+00:00", "question_id": "3c4e95296087bdb9f6d02f3c7d14fb34bcbe2d6d_28", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void hprdPrimaryRefSave(struct hprdPrimaryRef *obj, int indent, FILE *f)\n/* Save hprdPrimaryRef to file. */\n{\nif (obj == NULL) return;\nxapIndent(indent, f);\nfprintf(f, \"<primaryRef\");\nfprintf(f, \" db=\\\"%s\\\"\", obj->db);\nfprintf(f, \" id=\\\"%s\\\"\", obj->id);\nif (obj->dbAc != NULL)\n    fprintf(f, \" dbAc=\\\"%s\\\"\", obj->dbAc);\nif (obj->refType != NULL)\n    fprintf(f, \" refType=\\\"%s\\\"\", obj->refType);\nif (obj->refTypeAc != NULL)\n    fprintf(f, \" refTypeAc=\\\"%s\\\"\", obj->refTypeAc);\nfprintf(f, \"/>\\n\");\n"]], "pred": {"ppl": 2.128354787826538, "ppl_lower": 2.519258975982666, "ppl/lowercase_ppl": -1.2232285435957153, "ppl/zlib": 0.0033720950052913354, "Min_5.0% Prob": 7.959319829940796, "Min_10.0% Prob": 5.933548402786255, "Min_20.0% Prob": 3.594028850881065, "Min_30.0% Prob": 2.5050347519497715, "Min_40.0% Prob": 1.9025014722492637, "Min_50.0% Prob": 1.516997780940197, "Min_60.0% Prob": 1.2606686759653742}}
{"hexsha": "c3131f38387e6eec8ac71ff8a468250c6273b9d2", "ext": "c", "lang": "C", "content": "int sum(int a, int b)\n{\n\tint c;\n\tc = a + b;\n\treturn c;\n}", "item_id": 1, "repo": "aishikchakraborty/Compilers-Lab", "file": "Assignment 4/ass4_13CS30041_test.c", "last_update_at": "2018-09-03T13:46:30+00:00", "question_id": "c3131f38387e6eec8ac71ff8a468250c6273b9d2_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int sum(int a, int b)\n{\n\tint c;\n\tc = a + b;\n\treturn c;\n"]], "pred": {"ppl": 3.3717777729034424, "ppl_lower": 3.3717777729034424, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.02250815063557782, "Min_5.0% Prob": 10.495960235595703, "Min_10.0% Prob": 7.7802079518636065, "Min_20.0% Prob": 5.002031743526459, "Min_30.0% Prob": 3.7131488588121204, "Min_40.0% Prob": 2.9457050363222756, "Min_50.0% Prob": 2.428232272466024, "Min_60.0% Prob": 2.0611915257241993}}
{"hexsha": "23af64a6d056ce5014f2bcadea60b5a7af2922de", "ext": "c", "lang": "C", "content": "static void ssh2_msg_debug(Ssh ssh, struct Packet *pktin)\r\n{\r\n    /* log the debug message */\r\n    char *msg;\r\n    int msglen;\r\n\r\n    /* XXX maybe we should actually take notice of the return value */\r\n    ssh2_pkt_getbool(pktin);\r\n    ssh_pkt_getstring(pktin, &msg, &msglen);\r\n\r\n    logeventf(ssh, \"Remote debug message: %.*s\", msglen, msg);\r\n}", "item_id": 123, "repo": "ralish/kitty", "file": "0.63_My_PuTTY/ssh.c", "last_update_at": "2018-05-09T12:55:24+00:00", "question_id": "23af64a6d056ce5014f2bcadea60b5a7af2922de_123", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void ssh2_msg_debug(Ssh ssh, struct Packet *pktin)\r\n{\r\n    /* log the debug message */\r\n    char *msg;\r\n    int msglen;\r\n\r\n    /* XXX maybe we should actually take notice of the return value */\r\n    ssh2_pkt_getbool(pktin);\r\n    ssh_pkt_getstring(pktin, &msg, &msglen);\r\n\r\n    logeventf(ssh, \"Remote debug message: %.*s\", msglen, msg);\r\n"]], "pred": {"ppl": 3.3923940658569336, "ppl_lower": 3.565265655517578, "ppl/lowercase_ppl": -1.0406886797745798, "ppl/zlib": 0.005477739400258305, "Min_5.0% Prob": 7.203930377960205, "Min_10.0% Prob": 6.082050919532776, "Min_20.0% Prob": 4.643169025580089, "Min_30.0% Prob": 3.637990183300442, "Min_40.0% Prob": 2.9626102708280087, "Min_50.0% Prob": 2.4073396940700342, "Min_60.0% Prob": 2.031381832206086}}
{"hexsha": "4c98b423dd0b870ec55930c4095eb7fb38af3568", "ext": "c", "lang": "C", "content": "static int __Pyx_BufFmt_ExpectNumber(const char **ts) {\n    int number = __Pyx_BufFmt_ParseNumber(ts);\n    if (number == -1) \n        PyErr_Format(PyExc_ValueError,\\\n                     \"Does not understand character buffer dtype format string ('%c')\", **ts);\n    return number;\n}", "item_id": 57, "repo": "seberg/scipy", "file": "scipy/interpolate/interpnd.c", "last_update_at": "2018-10-04T15:34:14+00:00", "question_id": "4c98b423dd0b870ec55930c4095eb7fb38af3568_57", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int __Pyx_BufFmt_ExpectNumber(const char **ts) {\n    int number = __Pyx_BufFmt_ParseNumber(ts);\n    if (number == -1) \n        PyErr_Format(PyExc_ValueError,\\\n                     \"Does not understand character buffer dtype format string ('%c')\", **ts);\n    return number;\n"]], "pred": {"ppl": 2.749901056289673, "ppl_lower": 7.146827697753906, "ppl/lowercase_ppl": -1.9441842222614396, "ppl/zlib": 0.005324025955264069, "Min_5.0% Prob": 9.206947565078735, "Min_10.0% Prob": 7.004347695244683, "Min_20.0% Prob": 4.59432550933626, "Min_30.0% Prob": 3.311796345092632, "Min_40.0% Prob": 2.5324057458589473, "Min_50.0% Prob": 2.038779534316725, "Min_60.0% Prob": 1.7028771890327334}}
{"hexsha": "e9ad527aaf0ae3e03ce6704bd4e4e01bce483611", "ext": "c", "lang": "C", "content": "static PyObject *\ntypecast_INTEGER_cast(const char *s, Py_ssize_t len, PyObject *curs)\n{\n    char buffer[12];\n\n    if (s == NULL) {Py_INCREF(Py_None); return Py_None;}\n    if (s[len] != '\\0') {\n        strncpy(buffer, s, (size_t) len); buffer[len] = '\\0';\n        s = buffer;\n    }\n    return PyInt_FromString((char *)s, NULL, 0);\n}", "item_id": 0, "repo": "Ademan/psycopg2", "file": "psycopg/typecast_basic.c", "last_update_at": "2018-03-28T16:59:52+00:00", "question_id": "e9ad527aaf0ae3e03ce6704bd4e4e01bce483611_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static PyObject *\ntypecast_INTEGER_cast(const char *s, Py_ssize_t len, PyObject *curs)\n{\n    char buffer[12];\n    if (s == NULL) {Py_INCREF(Py_None); return Py_None;}\n    if (s[len] != '\\0') {\n        strncpy(buffer, s, (size_t) len); buffer[len] = '\\0';\n        s = buffer;\n    }\n    return PyInt_FromString((char *)s, NULL, 0);\n"]], "pred": {"ppl": 2.8112845420837402, "ppl_lower": 4.143309593200684, "ppl/lowercase_ppl": -1.3752300691977364, "ppl/zlib": 0.004656042843723451, "Min_5.0% Prob": 7.54536247253418, "Min_10.0% Prob": 5.909429275072538, "Min_20.0% Prob": 4.1589407258563575, "Min_30.0% Prob": 3.1954638987779616, "Min_40.0% Prob": 2.501404172844357, "Min_50.0% Prob": 2.0577296963823377, "Min_60.0% Prob": 1.715387454463376}}
{"hexsha": "b7ff48652377f2e475020d1609d473a75b52013c", "ext": "c", "lang": "C", "content": "void\nemit_typecode_conversion (from, to)\n     enum typecode from, to;\n{\n  int i;\n\n  DEDUCE_CONVERSION (from, to);\n  for (i = 0; i < conversion_recipe[(int) from][(int) to].nopcodes; ++i)\n    bc_emit_instruction (conversion_recipe[(int) from][(int) to].opcodes[i]);\n}", "item_id": 2, "repo": "aaliomer/exos", "file": "bin/gcc/bc-optab.c", "last_update_at": "2018-01-23T23:07:19+00:00", "question_id": "b7ff48652377f2e475020d1609d473a75b52013c_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nemit_typecode_conversion (from, to)\n     enum typecode from, to;\n{\n  int i;\n  DEDUCE_CONVERSION (from, to);\n  for (i = 0; i < conversion_recipe[(int) from][(int) to].nopcodes; ++i)\n    bc_emit_instruction (conversion_recipe[(int) from][(int) to].opcodes[i]);\n"]], "pred": {"ppl": 5.6278395652771, "ppl_lower": 5.532988548278809, "ppl/lowercase_ppl": -0.990161899666341, "ppl/zlib": 0.010345662468986756, "Min_5.0% Prob": 9.605404663085938, "Min_10.0% Prob": 8.406964635848999, "Min_20.0% Prob": 6.555930478232248, "Min_30.0% Prob": 5.128832217305899, "Min_40.0% Prob": 4.140125144359677, "Min_50.0% Prob": 3.4135818486964262, "Min_60.0% Prob": 2.8749348470797904}}
{"hexsha": "607734e8c18df708d48b0c15378e6575b6cfe0c8", "ext": "c", "lang": "C", "content": "int OSPPCommGetTimeout(\n    OSPTCOMM *ospvComm,\n    unsigned *ospvTimeout)\n{\n    int errorcode = OSPC_ERR_NO_ERROR;\n\n    if (ospvComm == OSPC_OSNULL) {\n        errorcode = OSPC_ERR_COMM_INVALID_ARG;\n        OSPM_DBGERRORLOG(errorcode, \"ospvComm is NULL\");\n    } else\n        *ospvTimeout = ospvComm->HttpTimeout;\n\n    return errorcode;\n}", "item_id": 6, "repo": "TransNexus/osptoolkit", "file": "src/ospcomm.c", "last_update_at": "2018-05-07T18:30:21+00:00", "question_id": "607734e8c18df708d48b0c15378e6575b6cfe0c8_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int OSPPCommGetTimeout(\n    OSPTCOMM *ospvComm,\n    unsigned *ospvTimeout)\n{\n    int errorcode = OSPC_ERR_NO_ERROR;\n    if (ospvComm == OSPC_OSNULL) {\n        errorcode = OSPC_ERR_COMM_INVALID_ARG;\n        OSPM_DBGERRORLOG(errorcode, \"ospvComm is NULL\");\n    } else\n        *ospvTimeout = ospvComm->HttpTimeout;\n    return errorcode;\n"]], "pred": {"ppl": 2.1594908237457275, "ppl_lower": 4.893092632293701, "ppl/lowercase_ppl": -2.06245140285009, "ppl/zlib": 0.00386870585005076, "Min_5.0% Prob": 8.762239297231039, "Min_10.0% Prob": 6.17925869501554, "Min_20.0% Prob": 3.6529566599772525, "Min_30.0% Prob": 2.5254710715264084, "Min_40.0% Prob": 1.9358024114988885, "Min_50.0% Prob": 1.5372320139196827, "Min_60.0% Prob": 1.2889081498607993}}
{"hexsha": "a51cb20e5631590d58e66e9be1161734fde421e2", "ext": "c", "lang": "C", "content": "int\nxenDaemonDomainPinVcpu(virConnectPtr conn,\n                       virDomainDefPtr minidef,\n                       unsigned int vcpu,\n                       unsigned char *cpumap,\n                       int maplen)\n{\n    char buf[VIR_UUID_BUFLEN], mapstr[sizeof(cpumap_t) * 64];\n    size_t i, j;\n    int ret;\n    xenUnifiedPrivatePtr priv = conn->privateData;\n    virDomainDefPtr def = NULL;\n\n    if (maplen > (int)sizeof(cpumap_t)) {\n        virReportError(VIR_ERR_INVALID_ARG, __FUNCTION__);\n        return -1;\n    }\n\n    if (priv->xendConfigVersion < XEND_CONFIG_VERSION_3_0_4) {\n        mapstr[0] = '[';\n        mapstr[1] = 0;\n    } else {\n        mapstr[0] = 0;\n    }\n\n    /* from bit map, build character string of mapped CPU numbers */\n    for (i = 0; i < maplen; i++) for (j = 0; j < 8; j++)\n     if (cpumap[i] & (1 << j)) {\n        snprintf(buf, sizeof(buf), \"%zu,\", (8 * i) + j);\n        strcat(mapstr, buf);\n    }\n    if (priv->xendConfigVersion < XEND_CONFIG_VERSION_3_0_4)\n        mapstr[strlen(mapstr) - 1] = ']';\n    else\n        mapstr[strlen(mapstr) - 1] = 0;\n\n    snprintf(buf, sizeof(buf), \"%d\", vcpu);\n\n    ret = xend_op(conn, minidef->name, \"op\", \"pincpu\", \"vcpu\", buf,\n                  \"cpumap\", mapstr, NULL);\n\n    if (!(def = xenDaemonDomainFetch(conn,\n                                     minidef->id,\n                                     minidef->name,\n                                     NULL)))\n        goto cleanup;\n\n    if (ret == 0) {\n        if (!def->cputune.vcpupin) {\n            if (VIR_ALLOC(def->cputune.vcpupin) < 0)\n                goto cleanup;\n            def->cputune.nvcpupin = 0;\n        }\n        if (virDomainVcpuPinAdd(&def->cputune.vcpupin,\n                                &def->cputune.nvcpupin,\n                                cpumap,\n                                maplen,\n                                vcpu) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"failed to add vcpupin xml entry\"));\n            return -1;\n        }\n    }\n\n    return ret;\n\n cleanup:\n    virDomainDefFree(def);\n    return -1;\n}", "item_id": 33, "repo": "SIIS-cloud/pileus", "file": "libvirt/pileus-libvirt-1.2.12/src/xen/xend_internal.c", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "a51cb20e5631590d58e66e9be1161734fde421e2_33", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nxenDaemonDomainPinVcpu(virConnectPtr conn,\n                       virDomainDefPtr minidef,\n                       unsigned int vcpu,\n                       unsigned char *cpumap,\n                       int maplen)\n{\n    char buf[VIR_UUID_BUFLEN], mapstr[sizeof(cpumap_t) * 64];\n    size_t i, j;\n    int ret;\n    xenUnifiedPrivatePtr priv = conn->privateData;\n    virDomainDefPtr def = NULL;\n    if (maplen > (int)sizeof(cpumap_t)) {\n        virReportError(VIR_ERR_INVALID_ARG, __FUNCTION__);\n        return -1;\n    }\n    if (priv->xendConfigVersion < XEND_CONFIG_VERSION_3_0_4) {\n        mapstr[0] = '[';\n        mapstr[1] = 0;\n    } else {\n        mapstr[0] = 0;\n    }\n    /* from bit map, build character string of mapped CPU numbers */\n    for (i = 0; i < maplen; i++) for (j = 0; j < 8; j++)\n     if (cpumap[i] & (1 << j)) {\n        snprintf(buf, sizeof(buf), \"%zu,\", (8 * i) + j);\n        strcat(mapstr, buf);\n    }\n    if (priv->xendConfigVersion < XEND_CONFIG_VERSION_3_0_4)\n        mapstr[strlen(mapstr) - 1] = ']';\n    else\n        mapstr[strlen(mapstr) - 1] = 0;\n    snprintf(buf, sizeof(buf), \"%d\", vcpu);\n    ret = xend_op(conn, minidef->name, \"op\", \"pincpu\", \"vcpu\", buf,\n                  \"cpumap\", mapstr, NULL);\n    if (!(def = xenDaemonDomainFetch(conn,\n                                     minidef->id,\n                                     minidef->name,\n                                     NULL)))\n        goto cleanup;\n    if (ret == 0) {\n        if (!def->cputune.vcpupin) {\n            if (VIR_ALLOC(def->cputune.vcpupin) < 0)\n                goto cleanup;\n            def->cputune.nvcpupin = 0;\n        }\n        if (virDomainVcpuPinAdd(&def->cputune.vcpupin,\n                                &def->cputune.nvcpupin,\n                                cpumap,\n                                maplen,\n                                vcpu) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"failed to add vcpupin xml entry\"));\n            return -1;\n        }\n    }\n    return ret;\n cleanup:\n    virDomainDefFree(def);\n    return -1;\n"]], "pred": {"ppl": 2.0001535415649414, "ppl_lower": 2.7130560874938965, "ppl/lowercase_ppl": -1.4397594159567342, "ppl/zlib": 0.0008853434845411116, "Min_5.0% Prob": 6.358543104595608, "Min_10.0% Prob": 4.703823497850601, "Min_20.0% Prob": 3.0741040353872338, "Min_30.0% Prob": 2.2253733812683847, "Min_40.0% Prob": 1.7137462019162664, "Min_50.0% Prob": 1.3815469296048408, "Min_60.0% Prob": 1.1563585636677953}}
{"hexsha": "ac7d1c381ff1a9b1d12a048c4cfe2ca34db6f197", "ext": "h", "lang": "C", "content": "static inline void hri_aonpwrseqpwrseq_clear_AON_ST_WAKEUP_CTRL_ARM_ENABLE_bit(const void *const hw)\n{\n\tAON_PWR_SEQ_CRITICAL_SECTION_ENTER();\n\t((AonPwrSeq *)hw)->AON_ST_WAKEUP_CTRL.reg &= ~AON_PWR_SEQ_AON_ST_WAKEUP_CTRL_ARM_ENABLE_Msk;\n\tAON_PWR_SEQ_CRITICAL_SECTION_LEAVE();\n}", "item_id": 13, "repo": "Arrowana/dive-computer", "file": "Dive Computer/hri/hri_aon_pwr_seq_b11.h", "last_update_at": "2018-05-16T23:05:24+00:00", "question_id": "ac7d1c381ff1a9b1d12a048c4cfe2ca34db6f197_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void hri_aonpwrseqpwrseq_clear_AON_ST_WAKEUP_CTRL_ARM_ENABLE_bit(const void *const hw)\n{\n\tAON_PWR_SEQ_CRITICAL_SECTION_ENTER();\n\t((AonPwrSeq *)hw)->AON_ST_WAKEUP_CTRL.reg &= ~AON_PWR_SEQ_AON_ST_WAKEUP_CTRL_ARM_ENABLE_Msk;\n\tAON_PWR_SEQ_CRITICAL_SECTION_LEAVE();\n"]], "pred": {"ppl": 1.7117034196853638, "ppl_lower": 2.842129707336426, "ppl/lowercase_ppl": -1.943395337389884, "ppl/zlib": 0.0029860501474852303, "Min_5.0% Prob": 6.305488858904157, "Min_10.0% Prob": 4.902305620057242, "Min_20.0% Prob": 2.7103516418358375, "Min_30.0% Prob": 1.813295697370036, "Min_40.0% Prob": 1.3567401516977382, "Min_50.0% Prob": 1.0821417820328418, "Min_60.0% Prob": 0.8998241268158524}}
{"hexsha": "e6d321d22988585c03ffcd9c4b6f0537b44ba5a3", "ext": "h", "lang": "C", "content": "class CEDFileSelector : public CGUIFileBrowser\r\n{\r\npublic:\r\n\tCEDFileSelector(float _x, float _y, float _sx, float _sy, char* path=\"$GAME$\", char* label=\"GAME:\");\r\n\tvirtual ~CEDFileSelector();\r\n\r\n\tint filterExt;\t// pouze jake pripony se budou zobrazovat\t(viz. KerServices.h - eEXTensions)\r\n\r\n\tstatic int Compare(CGUITreeItem *aa, CGUITreeItem *bb);\t// setridi: nejdriv adresare, potom levely\r\n\tstatic int CompareLevelDIR(CGUITreeItem *aa, CGUITreeItem *bb);\t// setridi: nejdriv adresare, potom levely, potom ostatni soubory\r\nprotected:\r\n\r\n\tvirtual int TreeHandler(typeID treeItem, int index, int state);\t// nepouzito\r\n\tvirtual int Filter(CGUITreeItem* parent, const char *name, int dir, int first);\t// nepouzito\r\n\tvirtual CGUIFileBrowserItem* AddItem(CGUIFileBrowserItem* fbi, const char* name, int dir);\r\n\t\t// pridavani polozek podle jejich typu voli ikonu, atp.\r\n\r\n\tvirtual int Keyboard(UINT character, UINT state);\t// zarizuje zavreni okna po vyberu polozky\r\n}", "item_id": 1, "repo": "HonzaMD/Krkal2", "file": "src/Editor/editorMenu.h", "last_update_at": "2018-04-01T16:47:52+00:00", "question_id": "e6d321d22988585c03ffcd9c4b6f0537b44ba5a3_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class CEDFileSelector : public CGUIFileBrowser\r\n{\r\npublic:\r\n\tCEDFileSelector(float _x, float _y, float _sx, float _sy, char* path=\"$GAME$\", char* label=\"GAME:\");\r\n\tvirtual ~CEDFileSelector();\r\n\r\n\tint filterExt;\t// pouze jake pripony se budou zobrazovat\t(viz. KerServices.h - eEXTensions)\r\n\r\n\tstatic int Compare(CGUITreeItem *aa, CGUITreeItem *bb);\t// setridi: nejdriv adresare, potom levely\r\n\tstatic int CompareLevelDIR(CGUITreeItem *aa, CGUITreeItem *bb);\t// setridi: nejdriv adresare, potom levely, potom ostatni soubory\r\nprotected:\r\n\r\n\tvirtual int TreeHandler(typeID treeItem, int index, int state);\t// nepouzito\r\n\tvirtual int Filter(CGUITreeItem* parent, const char *name, int dir, int first);\t// nepouzito\r\n\tvirtual CGUIFileBrowserItem* AddItem(CGUIFileBrowserItem* fbi, const char* name, int dir);\r\n\t\t// pridavani polozek podle jejich typu voli ikonu, atp.\r\n\r\n\tvirtual int Keyboard(UINT character, UINT state);\t// zarizuje zavreni okna po vyberu polozky\r\n"]], "pred": {"ppl": 5.454719066619873, "ppl_lower": 5.877172470092773, "ppl/lowercase_ppl": -1.0439702247440503, "ppl/zlib": 0.0035417142333977287, "Min_5.0% Prob": 9.625561966615564, "Min_10.0% Prob": 7.692339692796979, "Min_20.0% Prob": 5.983709405845319, "Min_30.0% Prob": 4.824433635328417, "Min_40.0% Prob": 3.9689036733667615, "Min_50.0% Prob": 3.3162051918131583, "Min_60.0% Prob": 2.8097244741342893}}
{"hexsha": "2ae35d143583022965327b11b8aabd9044caef9e", "ext": "c", "lang": "C", "content": "static void\nmgaScreenFini (KdScreenInfo *screen)\n{\n    MgaScreenInfo *mgas = (MgaScreenInfo *) screen->driver;\n\n    vesaScreenFini (screen);\n    xfree (mgas);\n    screen->driver = 0;\n}", "item_id": 7, "repo": "larsclausen/xglamo", "file": "hw/kdrive/mga/mga.c", "last_update_at": "2018-11-01T06:58:35+00:00", "question_id": "2ae35d143583022965327b11b8aabd9044caef9e_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nmgaScreenFini (KdScreenInfo *screen)\n{\n    MgaScreenInfo *mgas = (MgaScreenInfo *) screen->driver;\n    vesaScreenFini (screen);\n    xfree (mgas);\n    screen->driver = 0;\n"]], "pred": {"ppl": 3.9748034477233887, "ppl_lower": 6.707263946533203, "ppl/lowercase_ppl": -1.3791486779141833, "ppl/zlib": 0.012321208033661907, "Min_5.0% Prob": 7.679965972900391, "Min_10.0% Prob": 6.890065272649129, "Min_20.0% Prob": 5.409694891709548, "Min_30.0% Prob": 4.162877714633941, "Min_40.0% Prob": 3.3259198842225253, "Min_50.0% Prob": 2.7333385032766007, "Min_60.0% Prob": 2.3403305360116065}}
{"hexsha": "d70d925d8edfce36b50331ebabef78a01c90528e", "ext": "c", "lang": "C", "content": "void RCC_Configuration(void)\n{\n    /* Enable peripheral clocks */\n    /* Enable DMA1 clock */\n    RCC_AHBPeriphClock_Enable(RCC_AHBPERIPH_DMA1, ENABLE);\n\n}", "item_id": 2, "repo": "zdh19890814/LiteOS_Kernel", "file": "platform/GD32F103VCT6/Library/Example/DMA/FLASH-RAM/main.c", "last_update_at": "2018-10-18T03:18:39+00:00", "question_id": "d70d925d8edfce36b50331ebabef78a01c90528e_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void RCC_Configuration(void)\n{\n    /* Enable peripheral clocks */\n    /* Enable DMA1 clock */\n    RCC_AHBPeriphClock_Enable(RCC_AHBPERIPH_DMA1, ENABLE);\n"]], "pred": {"ppl": 3.012511968612671, "ppl_lower": 5.214350700378418, "ppl/lowercase_ppl": -1.4975091610159663, "ppl/zlib": 0.009345544676206274, "Min_5.0% Prob": 9.064591407775879, "Min_10.0% Prob": 7.4553382396698, "Min_20.0% Prob": 4.7323748882000265, "Min_30.0% Prob": 3.434850212931633, "Min_40.0% Prob": 2.772743305334678, "Min_50.0% Prob": 2.2211852839047257, "Min_60.0% Prob": 1.842531768605113}}
{"hexsha": "fe5535ad54bf468756a35ecb6de17b26be4d3057", "ext": "c", "lang": "C", "content": "void TDF_PS_PK_free(TDF_PS_PK *pk) {\n\tif (pk == NULL) {\n\t\treturn;\n\t}\n\tBN_free(pk->n);\n\tBN_free(pk->halfn);\n\tOPENSSL_free(pk);\n}", "item_id": 0, "repo": "dstebila/daps", "file": "tdf_ps.c", "last_update_at": "2018-01-08T17:28:09+00:00", "question_id": "fe5535ad54bf468756a35ecb6de17b26be4d3057_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void TDF_PS_PK_free(TDF_PS_PK *pk) {\n\tif (pk == NULL) {\n\t\treturn;\n\t}\n\tBN_free(pk->n);\n\tBN_free(pk->halfn);\n\tOPENSSL_free(pk);\n"]], "pred": {"ppl": 4.516082286834717, "ppl_lower": 5.61325216293335, "ppl/lowercase_ppl": -1.144255054473106, "ppl/zlib": 0.015384131298961996, "Min_5.0% Prob": 9.87964153289795, "Min_10.0% Prob": 8.749173709324428, "Min_20.0% Prob": 6.3370495183127264, "Min_30.0% Prob": 4.810547902470543, "Min_40.0% Prob": 3.7837020914469446, "Min_50.0% Prob": 2.9870267597337565, "Min_60.0% Prob": 2.51319578203351}}
{"hexsha": "b73e87256982933d096078c5b2655e5361bf94f8", "ext": "c", "lang": "C", "content": "uint8_t w3d_Map_GetValue(w3d_Map* map, int x, int y) {\n\tassert(map != NULL);\n\tuint8_t* value = map->dataWall+((x*map->width)+y); \n\treturn *value;\n}", "item_id": 2, "repo": "ftraple/WolfensteinEngine", "file": "source/Map.c", "last_update_at": "2018-10-03T10:41:13+00:00", "question_id": "b73e87256982933d096078c5b2655e5361bf94f8_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["uint8_t w3d_Map_GetValue(w3d_Map* map, int x, int y) {\n\tassert(map != NULL);\n\tuint8_t* value = map->dataWall+((x*map->width)+y); \n\treturn *value;\n"]], "pred": {"ppl": 5.253163814544678, "ppl_lower": 5.799633026123047, "ppl/lowercase_ppl": -1.0596589682787891, "ppl/zlib": 0.012859151367721141, "Min_5.0% Prob": 9.987574577331543, "Min_10.0% Prob": 8.062114238739014, "Min_20.0% Prob": 6.31260686654311, "Min_30.0% Prob": 4.8293123006820675, "Min_40.0% Prob": 3.9305977953804865, "Min_50.0% Prob": 3.266483293736682, "Min_60.0% Prob": 2.7563090815049844}}
{"hexsha": "48f3245153a7d88830fdc5d78cee3561f1d6edeb", "ext": "c", "lang": "C", "content": "int recordTime(char *time_str) {\n  time_t timer;\n  struct tm time_struct;\n\n  timer = time(NULL);\n  localtime_r(&timer, &time_struct);\n\n  // TIME_FORMAT == \"%Y-%m-%d %H:%M:%S\" == \"yyyy-mm-dd HH:mm:ss\"\n  strftime(time_str, TIME_STR_LEN, TIME_FORMAT, &time_struct);\n\n  return 0;\n}", "item_id": 3, "repo": "Ghost-in-the-Bash/sslsplit", "file": "netgrok.c", "last_update_at": "2018-11-27T15:51:16+00:00", "question_id": "48f3245153a7d88830fdc5d78cee3561f1d6edeb_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int recordTime(char *time_str) {\n  time_t timer;\n  struct tm time_struct;\n  timer = time(NULL);\n  localtime_r(&timer, &time_struct);\n  // TIME_FORMAT == \"%Y-%m-%d %H:%M:%S\" == \"yyyy-mm-dd HH:mm:ss\"\n  strftime(time_str, TIME_STR_LEN, TIME_FORMAT, &time_struct);\n  return 0;\n"]], "pred": {"ppl": 2.552119016647339, "ppl_lower": 3.243659019470215, "ppl/lowercase_ppl": -1.2559204570698468, "ppl/zlib": 0.005064454059526411, "Min_5.0% Prob": 7.375787337621053, "Min_10.0% Prob": 5.554525355497996, "Min_20.0% Prob": 3.9755974411964417, "Min_30.0% Prob": 2.950200831567919, "Min_40.0% Prob": 2.333267390727997, "Min_50.0% Prob": 1.8644016205423302, "Min_60.0% Prob": 1.5662633969977096}}
{"hexsha": "d94c67fed9b7ac99fdd48fbbef4055dac9fe7c0c", "ext": "h", "lang": "C", "content": "interface UIDocumentPickerViewController : UIViewController <_UIDocumentPickerRemoteViewControllerContaining> {\n\n\tid<UIDocumentPickerDelegate> _weak_delegate;\n\tBOOL _ignoreApplicationEntitlementForImport;\n\tBOOL _sourceIsManaged;\n\tid<UIDocumentPickerDelegate> _delegate;\n\tunsigned long long _documentPickerMode;\n\t_UIResilientRemoteViewContainerViewController* _childViewController;\n\t_UIRemoteViewService* _remoteViewService;\n\tNSURL* _uploadURL;\n\n}", "item_id": 0, "repo": "lechium/tvOS10Headers", "file": "System/Library/Frameworks/UIKit.framework/UIDocumentPickerViewController.h", "last_update_at": "2018-08-04T20:16:32+00:00", "question_id": "d94c67fed9b7ac99fdd48fbbef4055dac9fe7c0c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface UIDocumentPickerViewController : UIViewController <_UIDocumentPickerRemoteViewControllerContaining> {\n\tid<UIDocumentPickerDelegate> _weak_delegate;\n\tBOOL _ignoreApplicationEntitlementForImport;\n\tBOOL _sourceIsManaged;\n\tid<UIDocumentPickerDelegate> _delegate;\n\tunsigned long long _documentPickerMode;\n\t_UIResilientRemoteViewContainerViewController* _childViewController;\n\t_UIRemoteViewService* _remoteViewService;\n\tNSURL* _uploadURL;\n"]], "pred": {"ppl": 2.9397847652435303, "ppl_lower": 6.236101150512695, "ppl/lowercase_ppl": -1.6973879608733804, "ppl/zlib": 0.00468841899812971, "Min_5.0% Prob": 7.1426012992858885, "Min_10.0% Prob": 5.8229285586964, "Min_20.0% Prob": 4.312343276065329, "Min_30.0% Prob": 3.3108968308993747, "Min_40.0% Prob": 2.6618420773226283, "Min_50.0% Prob": 2.1514081949817725, "Min_60.0% Prob": 1.7936691720570836}}
{"hexsha": "925706c7558daa5e3c4c508659d201d0ddf3885a", "ext": "c", "lang": "C", "content": "const struct exec_info *get_exec_info(const struct exec_info *exec_infos,\n\t\t\t\t      const char *arg0)\n{\n\tconst char *name = path_base(arg0);\n\tconst struct exec_info *ret = NULL;\n\n\tfor (size_t i = 0; exec_infos[i].name != NULL; ++i) {\n\t\t// Exact matches always come first\n\t\tif (strcmp(name, exec_infos[i].name) == 0)\n\t\t\treturn &exec_infos[i];\n\n\t\t// Fallback to {exe}.{type} matching\n\t\tconst size_t name_len = strlen(name);\n\t\tif (name_len > strlen(exec_infos[i].name))\n\t\t\tcontinue;\n\t\tif (exec_infos[i].name[name_len] != '.')\n\t\t\tcontinue;\n\t\tif (strncmp(name, exec_infos[i].name, name_len) != 0)\n\t\t\tcontinue;\n\t\tif (ret == NULL || ret->prefer < exec_infos[i].prefer)\n\t\t\tret = &exec_infos[i];\n\t}\n\n\treturn ret;\n}", "item_id": 1, "repo": "wkennington/cc-wrapper", "file": "src/execinfo.c", "last_update_at": "2018-11-30T04:32:07+00:00", "question_id": "925706c7558daa5e3c4c508659d201d0ddf3885a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["const struct exec_info *get_exec_info(const struct exec_info *exec_infos,\n\t\t\t\t      const char *arg0)\n{\n\tconst char *name = path_base(arg0);\n\tconst struct exec_info *ret = NULL;\n\tfor (size_t i = 0; exec_infos[i].name != NULL; ++i) {\n\t\t// Exact matches always come first\n\t\tif (strcmp(name, exec_infos[i].name) == 0)\n\t\t\treturn &exec_infos[i];\n\t\t// Fallback to {exe}.{type} matching\n\t\tconst size_t name_len = strlen(name);\n\t\tif (name_len > strlen(exec_infos[i].name))\n\t\t\tcontinue;\n\t\tif (exec_infos[i].name[name_len] != '.')\n\t\t\tcontinue;\n\t\tif (strncmp(name, exec_infos[i].name, name_len) != 0)\n\t\t\tcontinue;\n\t\tif (ret == NULL || ret->prefer < exec_infos[i].prefer)\n\t\t\tret = &exec_infos[i];\n\t}\n\treturn ret;\n"]], "pred": {"ppl": 1.8097805976867676, "ppl_lower": 1.86528742313385, "ppl/lowercase_ppl": -1.0509259070392774, "ppl/zlib": 0.0018422534819340015, "Min_5.0% Prob": 5.8517646312713625, "Min_10.0% Prob": 4.205818335215251, "Min_20.0% Prob": 2.6811280670713207, "Min_30.0% Prob": 1.947364478648364, "Min_40.0% Prob": 1.4763684405899438, "Min_50.0% Prob": 1.1892240250630206, "Min_60.0% Prob": 0.9885012981980591}}
{"hexsha": "333231c508fa3033cf5491ed4647ab6d1aa7be86", "ext": "c", "lang": "C", "content": "static jboolean\nPCPathDone(PathConsumerVec *consumer)\n{\n    pathData *pd = (pathData *) consumer;\n    jboolean oom = JNI_FALSE;\n\n    HANDLEENDPATH(pd, {oom = JNI_TRUE;});\n\n    return oom;\n}", "item_id": 24, "repo": "siweilxy/openjdkstudy", "file": "src/java.desktop/share/native/libawt/java2d/pipe/ShapeSpanIterator.c", "last_update_at": "2018-06-23T10:04:56+00:00", "question_id": "333231c508fa3033cf5491ed4647ab6d1aa7be86_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static jboolean\nPCPathDone(PathConsumerVec *consumer)\n{\n    pathData *pd = (pathData *) consumer;\n    jboolean oom = JNI_FALSE;\n    HANDLEENDPATH(pd, {oom = JNI_TRUE;});\n    return oom;\n"]], "pred": {"ppl": 8.24747371673584, "ppl_lower": 10.381098747253418, "ppl/lowercase_ppl": -1.109047362755811, "ppl/zlib": 0.014754593967130199, "Min_5.0% Prob": 11.195892651875814, "Min_10.0% Prob": 9.86472933632987, "Min_20.0% Prob": 8.007361497197833, "Min_30.0% Prob": 6.235594715390887, "Min_40.0% Prob": 5.050477943250111, "Min_50.0% Prob": 4.117213245895174, "Min_60.0% Prob": 3.50002644436304}}
{"hexsha": "aa59444ad530b940e0f4ef33b94ee6b1ab47d5aa", "ext": "c", "lang": "C", "content": "int\tosd_path_split(const char *path, char dir[], char file[], int size)\n{\n    int pos = strlen(path);\n\n    /* dir, file \u306f\u5341\u5206\u306a\u30b5\u30a4\u30ba\u3092\u78ba\u4fdd\u3057\u3066\u3044\u308b\u306f\u305a\u306a\u306e\u3067\u3001\u8efd\u304f\u30c1\u30a7\u30c3\u30af */\n    if (pos == 0 || size <= pos) {\n\tdir[0]  = '\\0';\n\tfile[0] = '\\0';\n\tstrncat(file, path, size-1);\n\tif (pos) fprintf(stderr, \"internal overflow %d\\n\", __LINE__);\n\treturn FALSE;\n    }\n\n\n    if (strcmp(path, \"/\") == 0) {\t/* \"/\" \u306e\u5834\u5408\u3001\u5225\u51e6\u7406\t*/\n\tstrcpy(dir, \"/\");\t\t\t/* \u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306f \"/\"\t*/\n\tstrcpy(file, \"\");\t\t\t/* \u30d5\u30a1\u30a4\u30eb\u306f \"\"\t*/\n\treturn TRUE;\n    }\n\n    if (path[ pos - 1 ] == '/') {\t/* path \u672b\u5c3e\u306e / \u306f\u7121\u8996\t*/\n\tpos --;\n    }\n\n    do {\t\t\t\t/* / \u3092\u672b\u5c3e\u304b\u3089\u63a2\u3059\t*/\n\tif (path[ pos - 1 ] == '/') { break; }\n\tpos --;\n    } while (pos);\n\n    if (pos) {\t\t\t\t/* / \u304c\u898b\u3064\u304b\u3063\u305f\u3089\t*/\n\tstrncpy(dir, path, pos);\t\t/* \u5148\u982d\u301c / \u307e\u3067\u3092\u30b3\u30d4\u30fc*/\n\tif (pos > 1)\n\t    dir[ pos - 1 ] = '\\0';\t\t/* \u672b\u5c3e\u306e / \u306f\u524a\u9664\u3059\u308b\t*/\n\telse\t\t\t\t\t/* \u305f\u3060\u3057\t\t*/ \n\t    dir[ pos ] = '\\0';\t\t\t/* \"/\"\u306e\u5834\u5408\u306f / \u306f\u6b8b\u3059 */\n\n\tstrcpy(file, &path[pos]);\n\n    } else {\t\t\t\t/* / \u304c\u898b\u3064\u304b\u3089\u306a\u304b\u3063\u305f\t*/\n\tstrcpy(dir,  \"\");\t\t\t/* \u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306f \"\"\t*/\n\tstrcpy(file, path);\t\t\t/* \u30d5\u30a1\u30a4\u30eb\u306f path\u5168\u3066\t*/\n    }\n\n    pos = strlen(file);\t\t\t/* \u30d5\u30a1\u30a4\u30eb\u672b\u5c3e\u306e / \u306f\u524a\u9664 */\n    if (pos && file[ pos - 1 ] == '/') { \n\tfile[ pos - 1 ] = '\\0';\n    }\n\n    /*printf(\"SPLT:\\\"%s\\\" = \\\"%s\\\" + \\\"%s\\\")\\n\",path,dir,file);*/\n    return TRUE;\n}", "item_id": 7, "repo": "liberodark/quasi88-libretro", "file": "src/FUNIX/file-op.c", "last_update_at": "2018-09-16T23:47:02+00:00", "question_id": "aa59444ad530b940e0f4ef33b94ee6b1ab47d5aa_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\tosd_path_split(const char *path, char dir[], char file[], int size)\n{\n    int pos = strlen(path);\n    /* dir, file \u306f\u5341\u5206\u306a\u30b5\u30a4\u30ba\u3092\u78ba\u4fdd\u3057\u3066\u3044\u308b\u306f\u305a\u306a\u306e\u3067\u3001\u8efd\u304f\u30c1\u30a7\u30c3\u30af */\n    if (pos == 0 || size <= pos) {\n\tdir[0]  = '\\0';\n\tfile[0] = '\\0';\n\tstrncat(file, path, size-1);\n\tif (pos) fprintf(stderr, \"internal overflow %d\\n\", __LINE__);\n\treturn FALSE;\n    }\n    if (strcmp(path, \"/\") == 0) {\t/* \"/\" \u306e\u5834\u5408\u3001\u5225\u51e6\u7406\t*/\n\tstrcpy(dir, \"/\");\t\t\t/* \u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306f \"/\"\t*/\n\tstrcpy(file, \"\");\t\t\t/* \u30d5\u30a1\u30a4\u30eb\u306f \"\"\t*/\n\treturn TRUE;\n    }\n    if (path[ pos - 1 ] == '/') {\t/* path \u672b\u5c3e\u306e / \u306f\u7121\u8996\t*/\n\tpos --;\n    }\n    do {\t\t\t\t/* / \u3092\u672b\u5c3e\u304b\u3089\u63a2\u3059\t*/\n\tif (path[ pos - 1 ] == '/') { break; }\n\tpos --;\n    } while (pos);\n    if (pos) {\t\t\t\t/* / \u304c\u898b\u3064\u304b\u3063\u305f\u3089\t*/\n\tstrncpy(dir, path, pos);\t\t/* \u5148\u982d\u301c / \u307e\u3067\u3092\u30b3\u30d4\u30fc*/\n\tif (pos > 1)\n\t    dir[ pos - 1 ] = '\\0';\t\t/* \u672b\u5c3e\u306e / \u306f\u524a\u9664\u3059\u308b\t*/\n\telse\t\t\t\t\t/* \u305f\u3060\u3057\t\t*/ \n\t    dir[ pos ] = '\\0';\t\t\t/* \"/\"\u306e\u5834\u5408\u306f / \u306f\u6b8b\u3059 */\n\tstrcpy(file, &path[pos]);\n    } else {\t\t\t\t/* / \u304c\u898b\u3064\u304b\u3089\u306a\u304b\u3063\u305f\t*/\n\tstrcpy(dir,  \"\");\t\t\t/* \u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306f \"\"\t*/\n\tstrcpy(file, path);\t\t\t/* \u30d5\u30a1\u30a4\u30eb\u306f path\u5168\u3066\t*/\n    }\n    pos = strlen(file);\t\t\t/* \u30d5\u30a1\u30a4\u30eb\u672b\u5c3e\u306e / \u306f\u524a\u9664 */\n    if (pos && file[ pos - 1 ] == '/') { \n\tfile[ pos - 1 ] = '\\0';\n    }\n    /*printf(\"SPLT:\\\"%s\\\" = \\\"%s\\\" + \\\"%s\\\")\\n\",path,dir,file);*/\n    return TRUE;\n"]], "pred": {"ppl": 2.2197682857513428, "ppl_lower": 2.246015787124634, "ppl/lowercase_ppl": -1.014741696947207, "ppl/zlib": 0.001080491618765546, "Min_5.0% Prob": 6.367833067389095, "Min_10.0% Prob": 5.023017353871289, "Min_20.0% Prob": 3.396975518149488, "Min_30.0% Prob": 2.4937248992569305, "Min_40.0% Prob": 1.9444082172258812, "Min_50.0% Prob": 1.5797656094764962, "Min_60.0% Prob": 1.3242839492547016}}
{"hexsha": "17c48ea0d85bb127f7584855f9fabb1eb56b95a7", "ext": "c", "lang": "C", "content": "static enum cmd_status cmd_decrypto_3des_exec(char *cmd)\n{\n\tint32_t cnt;\n\tchar mode_str[8];\n\tchar key_str[25];\n\tchar *cipher_str;\n\tuint8_t *plain_buf;\n\tuint8_t *cipher_buf;\n\tint8_t key_len = 0;\n\tuint32_t cipher_len = 0;\n\tCE_3DES_Config des_cfg;\n    enum cmd_status ret = CMD_STATUS_ACKED;\n\n    cipher_str = (char*)cmd_malloc(CE_CIPHER_MAX_LEN);\n    if(cipher_str == NULL) {\n        CMD_ERR(\"malloc failed\\n\");\n        ret = CMD_STATUS_FAIL;\n        goto out_cipher;\n    }\n\n\t/* get param */\n\tcnt = cmd_sscanf(cmd, \"m=%7s k=%s c=%s\", mode_str, key_str, cipher_str);\n\n\t/* check param */\n\tif (cnt != 3) {\n\t\tCMD_ERR(\"invalid param number %d\\n\", cnt);\n\t\tret = CMD_STATUS_INVALID_ARG;\n        goto out_cipher;\n\t}\n\tmemset(&des_cfg, 0, sizeof(des_cfg));\n\tif (cmd_strcmp(mode_str, \"ecb\") == 0) {\n\t\tdes_cfg.mode = CE_CRYPT_MODE_ECB;\n\t} else if (cmd_strcmp(mode_str, \"cbc\") == 0) {\n\t\tdes_cfg.mode = CE_CRYPT_MODE_CBC;\n\t} else {\n\t\tCMD_ERR(\"invalid mode %s\\n\", mode_str);\n\t\tret = CMD_STATUS_INVALID_ARG;\n        goto out_cipher;\n\t}\n\n\tkey_len = cmd_strlen(key_str);\n\tif(24 != key_len) {\n\t\tCMD_ERR(\"invalid param:  key len %d != 24\\n\", key_len);\n\t\tret = CMD_STATUS_INVALID_ARG;\n        goto out_cipher;\n\t}\n\tdes_cfg.src = CE_CTL_KEYSOURCE_INPUT;\n\tmemcpy(des_cfg.key, key_str, key_len);\n\tcipher_len = cmd_strlen(cipher_str);\n\tcipher_len = cipher_len >> 1;\n\tcipher_buf = (uint8_t*)cmd_malloc(cipher_len);\n\tcipher_str_to_arr(cipher_str, cipher_buf);\n\tplain_buf = (uint8_t*)cmd_malloc(cipher_len);\n\tif(HAL_3DES_Decrypt(&des_cfg, (uint8_t*)cipher_buf, (uint8_t*)plain_buf, cipher_len) != HAL_OK) {\n\t\tCMD_ERR(\"3DES encrypt failed\\n\");\n\t\tret =  CMD_STATUS_FAIL;\n        goto out_plain;\n\t}\n\tprintf(\"plaintest:\");\n\tcmd_raw_mode_enable();\n\tcmd_raw_mode_write(plain_buf, cipher_len);\n\tcmd_raw_mode_disable();\n\tprintf(\"\\n\\n\");\n\nout_plain:\n    cmd_free(cipher_buf);\n    cmd_free(plain_buf);\nout_cipher:\n    cmd_free(cipher_str);\n    return ret;\n}", "item_id": 5, "repo": "HelloAllen8893/AliOS-Things", "file": "platform/mcu/xr872/drivers/project/common/cmd/cmd_ce.c", "last_update_at": "2018-11-28T03:19:22+00:00", "question_id": "17c48ea0d85bb127f7584855f9fabb1eb56b95a7_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static enum cmd_status cmd_decrypto_3des_exec(char *cmd)\n{\n\tint32_t cnt;\n\tchar mode_str[8];\n\tchar key_str[25];\n\tchar *cipher_str;\n\tuint8_t *plain_buf;\n\tuint8_t *cipher_buf;\n\tint8_t key_len = 0;\n\tuint32_t cipher_len = 0;\n\tCE_3DES_Config des_cfg;\n    enum cmd_status ret = CMD_STATUS_ACKED;\n    cipher_str = (char*)cmd_malloc(CE_CIPHER_MAX_LEN);\n    if(cipher_str == NULL) {\n        CMD_ERR(\"malloc failed\\n\");\n        ret = CMD_STATUS_FAIL;\n        goto out_cipher;\n    }\n\t/* get param */\n\tcnt = cmd_sscanf(cmd, \"m=%7s k=%s c=%s\", mode_str, key_str, cipher_str);\n\t/* check param */\n\tif (cnt != 3) {\n\t\tCMD_ERR(\"invalid param number %d\\n\", cnt);\n\t\tret = CMD_STATUS_INVALID_ARG;\n        goto out_cipher;\n\t}\n\tmemset(&des_cfg, 0, sizeof(des_cfg));\n\tif (cmd_strcmp(mode_str, \"ecb\") == 0) {\n\t\tdes_cfg.mode = CE_CRYPT_MODE_ECB;\n\t} else if (cmd_strcmp(mode_str, \"cbc\") == 0) {\n\t\tdes_cfg.mode = CE_CRYPT_MODE_CBC;\n\t} else {\n\t\tCMD_ERR(\"invalid mode %s\\n\", mode_str);\n\t\tret = CMD_STATUS_INVALID_ARG;\n        goto out_cipher;\n\t}\n\tkey_len = cmd_strlen(key_str);\n\tif(24 != key_len) {\n\t\tCMD_ERR(\"invalid param:  key len %d != 24\\n\", key_len);\n\t\tret = CMD_STATUS_INVALID_ARG;\n        goto out_cipher;\n\t}\n\tdes_cfg.src = CE_CTL_KEYSOURCE_INPUT;\n\tmemcpy(des_cfg.key, key_str, key_len);\n\tcipher_len = cmd_strlen(cipher_str);\n\tcipher_len = cipher_len >> 1;\n\tcipher_buf = (uint8_t*)cmd_malloc(cipher_len);\n\tcipher_str_to_arr(cipher_str, cipher_buf);\n\tplain_buf = (uint8_t*)cmd_malloc(cipher_len);\n\tif(HAL_3DES_Decrypt(&des_cfg, (uint8_t*)cipher_buf, (uint8_t*)plain_buf, cipher_len) != HAL_OK) {\n\t\tCMD_ERR(\"3DES encrypt failed\\n\");\n\t\tret =  CMD_STATUS_FAIL;\n        goto out_plain;\n\t}\n\tprintf(\"plaintest:\");\n\tcmd_raw_mode_enable();\n\tcmd_raw_mode_write(plain_buf, cipher_len);\n\tcmd_raw_mode_disable();\n\tprintf(\"\\n\\n\");\nout_plain:\n    cmd_free(cipher_buf);\n    cmd_free(plain_buf);\nout_cipher:\n    cmd_free(cipher_str);\n    return ret;\n"]], "pred": {"ppl": 1.8082290887832642, "ppl_lower": 1.958752989768982, "ppl/lowercase_ppl": -1.1349883578492148, "ppl/zlib": 0.0007961666160497001, "Min_5.0% Prob": 6.282153964042664, "Min_10.0% Prob": 4.4420596294188766, "Min_20.0% Prob": 2.7485735279120758, "Min_30.0% Prob": 1.9312931531623228, "Min_40.0% Prob": 1.4736105683116185, "Min_50.0% Prob": 1.1825459405500651, "Min_60.0% Prob": 0.9875435231256979}}
{"hexsha": "428a5c9457d7574e03b03de7b267e80bff3f2e26", "ext": "c", "lang": "C", "content": "void vmx_update_debug_state(struct vcpu *v)\n{\n    unsigned long mask;\n\n    ASSERT(v == current);\n\n    mask = 1u << TRAP_int3;\n    if ( !cpu_has_monitor_trap_flag )\n        mask |= 1u << TRAP_debug;\n\n    if ( v->arch.hvm_vcpu.debug_state_latch )\n        v->arch.hvm_vmx.exception_bitmap |= mask;\n    else\n        v->arch.hvm_vmx.exception_bitmap &= ~mask;\n    vmx_update_exception_bitmap(v);\n}", "item_id": 29, "repo": "zhiming-shen/Xen-Blanket-NG", "file": "xen/xen-4.2.2/xen/arch/x86/hvm/vmx/vmx.c", "last_update_at": "2018-02-02T00:15:26+00:00", "question_id": "428a5c9457d7574e03b03de7b267e80bff3f2e26_29", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void vmx_update_debug_state(struct vcpu *v)\n{\n    unsigned long mask;\n    ASSERT(v == current);\n    mask = 1u << TRAP_int3;\n    if ( !cpu_has_monitor_trap_flag )\n        mask |= 1u << TRAP_debug;\n    if ( v->arch.hvm_vcpu.debug_state_latch )\n        v->arch.hvm_vmx.exception_bitmap |= mask;\n    else\n        v->arch.hvm_vmx.exception_bitmap &= ~mask;\n    vmx_update_exception_bitmap(v);\n"]], "pred": {"ppl": 2.8866045475006104, "ppl_lower": 3.3027923107147217, "ppl/lowercase_ppl": -1.127053840224053, "ppl/zlib": 0.004732504081844196, "Min_5.0% Prob": 7.476911246776581, "Min_10.0% Prob": 6.516836494207382, "Min_20.0% Prob": 4.452129274606705, "Min_30.0% Prob": 3.298535570502281, "Min_40.0% Prob": 2.605811094865203, "Min_50.0% Prob": 2.102189202643471, "Min_60.0% Prob": 1.7658239568478054}}
{"hexsha": "2a824f95e117a6a79ab2516dacaab3dc31cfad35", "ext": "h", "lang": "C", "content": "static inline u32\ninl (u16 port)\n{\n  port_io_args args = { POKE_SIGNATURE, port, sizeof(u32), 0 };\n  if (ioctl(poke_driver_fd, POKE_PORT_READ, &args, sizeof(args)) < 0)\n    return 0;\n  return (u32)args.value;\n}", "item_id": 2, "repo": "Cwndmiao/downloadfile", "file": "sdk/mgmt_tool/third_party/pciutils/lib/i386-io-haiku.h", "last_update_at": "2018-11-14T03:56:42+00:00", "question_id": "2a824f95e117a6a79ab2516dacaab3dc31cfad35_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline u32\ninl (u16 port)\n{\n  port_io_args args = { POKE_SIGNATURE, port, sizeof(u32), 0 };\n  if (ioctl(poke_driver_fd, POKE_PORT_READ, &args, sizeof(args)) < 0)\n    return 0;\n  return (u32)args.value;\n"]], "pred": {"ppl": 4.505741596221924, "ppl_lower": 5.1799445152282715, "ppl/lowercase_ppl": -1.0926306972483708, "ppl/zlib": 0.008907411205716045, "Min_5.0% Prob": 9.275406837463379, "Min_10.0% Prob": 7.961555639902751, "Min_20.0% Prob": 5.693914865192614, "Min_30.0% Prob": 4.3980466867315355, "Min_40.0% Prob": 3.5603373317342055, "Min_50.0% Prob": 2.9431913401931524, "Min_60.0% Prob": 2.478703187714363}}
{"hexsha": "ec9a327c7e46d6d141f24f194b60533824ec5a4f", "ext": "c", "lang": "C", "content": "static int\nrestart_world (void)\n{\n\tint count, i;\n\tSgenThreadInfo *info;\n\tTV_DECLARE (end_sw);\n\tunsigned long usec;\n\n\tfor (i = 0; i < THREAD_HASH_SIZE; ++i) {\n\t\tfor (info = thread_table [i]; info; info = info->next) {\n\t\t\tinfo->stack_start = NULL;\n\t\t\tinfo->stopped_regs = NULL;\n\t\t}\n\t}\n\n\tcount = thread_handshake (restart_signal_num);\n\tTV_GETTIME (end_sw);\n\tusec = TV_ELAPSED (stop_world_time, end_sw);\n\tmax_pause_usec = MAX (usec, max_pause_usec);\n\tDEBUG (2, fprintf (gc_debug_file, \"restarted %d thread(s) (pause time: %d usec, max: %d)\\n\", count, (int)usec, (int)max_pause_usec));\n\treturn count;\n}", "item_id": 83, "repo": "zlxy/Genesis-3D", "file": "Engine/extlibs/IosLibs/mono-2.6.7/mono/metadata/sgen-gc.c", "last_update_at": "2018-09-30T23:46:57+00:00", "question_id": "ec9a327c7e46d6d141f24f194b60533824ec5a4f_83", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nrestart_world (void)\n{\n\tint count, i;\n\tSgenThreadInfo *info;\n\tTV_DECLARE (end_sw);\n\tunsigned long usec;\n\tfor (i = 0; i < THREAD_HASH_SIZE; ++i) {\n\t\tfor (info = thread_table [i]; info; info = info->next) {\n\t\t\tinfo->stack_start = NULL;\n\t\t\tinfo->stopped_regs = NULL;\n\t\t}\n\t}\n\tcount = thread_handshake (restart_signal_num);\n\tTV_GETTIME (end_sw);\n\tusec = TV_ELAPSED (stop_world_time, end_sw);\n\tmax_pause_usec = MAX (usec, max_pause_usec);\n\tDEBUG (2, fprintf (gc_debug_file, \"restarted %d thread(s) (pause time: %d usec, max: %d)\\n\", count, (int)usec, (int)max_pause_usec));\n\treturn count;\n"]], "pred": {"ppl": 2.4571971893310547, "ppl_lower": 3.6217586994171143, "ppl/lowercase_ppl": -1.4315118784462126, "ppl/zlib": 0.0024630721820731124, "Min_5.0% Prob": 7.4279178105867825, "Min_10.0% Prob": 5.907856647784893, "Min_20.0% Prob": 4.029021425067254, "Min_30.0% Prob": 2.9035424813628197, "Min_40.0% Prob": 2.244255372516389, "Min_50.0% Prob": 1.7999095752051002, "Min_60.0% Prob": 1.4991794586530887}}
{"hexsha": "8de8a1b9c31024d009a1f11b0a4fee426c49e677", "ext": "c", "lang": "C", "content": "static void shell_cp( int argc, char **argv )\n{\n  FILE *fps = NULL, *fpd = NULL;\n  void *buf = NULL;\n  size_t datalen, datawrote, total = 0;\n\n  if( argc != 3 )\n  {\n    printf( \"Usage: cp <source> <destination>\\n\" );\n    return;\n  }\n  if( ( fps = fopen( argv[ 1 ], \"rb\" ) ) == NULL )\n    printf( \"Unable to open %s for reading\\n\", argv[ 1 ] );\n  else\n  {\n    if( ( fpd = fopen( argv[ 2 ], \"wb\" ) ) == NULL )\n      printf( \"Unable to open %s for writing\\n\", argv[ 2 ] );\n    else\n    {\n      // Alloc memory\n      if( ( buf = malloc( SHELL_COPY_BUFSIZE ) ) == NULL )\n        printf( \"Not enough memory\\n\" );\n      else\n      {\n        // Do the actual copy\n        while( 1 )\n        {\n          datalen = fread( buf, 1, SHELL_COPY_BUFSIZE, fps );\n          datawrote = fwrite( buf, 1, datalen, fpd );\n          if( datawrote < datalen )\n          {\n            printf( \"Copy error (no space left on target?)\\n\" );\n            break;\n          }\n          total += datalen;\n          if( datalen < SHELL_COPY_BUFSIZE )\n            break;\n        }\n        fflush( fpd );\n        printf( \"%u bytes copied\\n\", ( unsigned int )total );\n      }\n    }\n  }\n  if( fps )\n    fclose( fps );\n  if( fpd )\n    fclose( fpd );\n  if( buf )\n    free( buf );\n}", "item_id": 6, "repo": "dz0ny/Cheerlights", "file": "src/shell.c", "last_update_at": "2018-01-20T13:42:13+00:00", "question_id": "8de8a1b9c31024d009a1f11b0a4fee426c49e677_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void shell_cp( int argc, char **argv )\n{\n  FILE *fps = NULL, *fpd = NULL;\n  void *buf = NULL;\n  size_t datalen, datawrote, total = 0;\n  if( argc != 3 )\n  {\n    printf( \"Usage: cp <source> <destination>\\n\" );\n    return;\n  }\n  if( ( fps = fopen( argv[ 1 ], \"rb\" ) ) == NULL )\n    printf( \"Unable to open %s for reading\\n\", argv[ 1 ] );\n  else\n  {\n    if( ( fpd = fopen( argv[ 2 ], \"wb\" ) ) == NULL )\n      printf( \"Unable to open %s for writing\\n\", argv[ 2 ] );\n    else\n    {\n      // Alloc memory\n      if( ( buf = malloc( SHELL_COPY_BUFSIZE ) ) == NULL )\n        printf( \"Not enough memory\\n\" );\n      else\n      {\n        // Do the actual copy\n        while( 1 )\n        {\n          datalen = fread( buf, 1, SHELL_COPY_BUFSIZE, fps );\n          datawrote = fwrite( buf, 1, datalen, fpd );\n          if( datawrote < datalen )\n          {\n            printf( \"Copy error (no space left on target?)\\n\" );\n            break;\n          }\n          total += datalen;\n          if( datalen < SHELL_COPY_BUFSIZE )\n            break;\n        }\n        fflush( fpd );\n        printf( \"%u bytes copied\\n\", ( unsigned int )total );\n      }\n    }\n  }\n  if( fps )\n    fclose( fps );\n  if( fpd )\n    fclose( fpd );\n  if( buf )\n    free( buf );\n"]], "pred": {"ppl": 1.6174309253692627, "ppl_lower": 1.7348523139953613, "ppl/lowercase_ppl": -1.145751987945307, "ppl/zlib": 0.0009072434753169817, "Min_5.0% Prob": 5.024775660556296, "Min_10.0% Prob": 3.552974949712339, "Min_20.0% Prob": 2.225080513111923, "Min_30.0% Prob": 1.5676821496525257, "Min_40.0% Prob": 1.1954777991852246, "Min_50.0% Prob": 0.9585075103236234, "Min_60.0% Prob": 0.8014993895089804}}
{"hexsha": "6e1db8554c1eb81709bba7f8c8f212d1d50ca0e9", "ext": "c", "lang": "C", "content": "void set_current_particle_texture(ParticleSettings *part, Tex *newtex)\n{\n\tint act = part->texact;\n\n\tif (part->mtex[act] && part->mtex[act]->tex)\n\t\tid_us_min(&part->mtex[act]->tex->id);\n\n\tif (newtex) {\n\t\tif (!part->mtex[act]) {\n\t\t\tpart->mtex[act] = BKE_texture_mtex_add();\n\t\t\tpart->mtex[act]->texco = TEXCO_ORCO;\n\t\t\tpart->mtex[act]->blendtype = MTEX_MUL;\n\t\t}\n\t\t\n\t\tpart->mtex[act]->tex = newtex;\n\t\tid_us_plus(&newtex->id);\n\t}\n\telse if (part->mtex[act]) {\n\t\tMEM_freeN(part->mtex[act]);\n\t\tpart->mtex[act] = NULL;\n\t}\n}", "item_id": 32, "repo": "1-MillionParanoidTterabytes/Blender-2.79b-blackened", "file": "source/blender/blenkernel/intern/texture.c", "last_update_at": "2018-06-18T01:50:32+00:00", "question_id": "6e1db8554c1eb81709bba7f8c8f212d1d50ca0e9_32", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void set_current_particle_texture(ParticleSettings *part, Tex *newtex)\n{\n\tint act = part->texact;\n\tif (part->mtex[act] && part->mtex[act]->tex)\n\t\tid_us_min(&part->mtex[act]->tex->id);\n\tif (newtex) {\n\t\tif (!part->mtex[act]) {\n\t\t\tpart->mtex[act] = BKE_texture_mtex_add();\n\t\t\tpart->mtex[act]->texco = TEXCO_ORCO;\n\t\t\tpart->mtex[act]->blendtype = MTEX_MUL;\n\t\t}\n\t\t\n\t\tpart->mtex[act]->tex = newtex;\n\t\tid_us_plus(&newtex->id);\n\t}\n\telse if (part->mtex[act]) {\n\t\tMEM_freeN(part->mtex[act]);\n\t\tpart->mtex[act] = NULL;\n\t}\n"]], "pred": {"ppl": 2.500030755996704, "ppl_lower": 3.131821632385254, "ppl/lowercase_ppl": -1.2458922254235723, "ppl/zlib": 0.0036074922606187513, "Min_5.0% Prob": 7.740280508995056, "Min_10.0% Prob": 5.845649518966675, "Min_20.0% Prob": 3.9633792233467102, "Min_30.0% Prob": 2.9202184931437176, "Min_40.0% Prob": 2.258981432169676, "Min_50.0% Prob": 1.8247337828874588, "Min_60.0% Prob": 1.5251473394967616}}
{"hexsha": "15c90ec3cf839205ea51ea962251a9b87ffa7e7f", "ext": "c", "lang": "C", "content": "static int acquire_mutex(DDP_SCENARIO_ENUM scenario)\n{\n/* /: primay use mutex 0 */\n\tint mutex_id = 0;\n\tDDP_MANAGER_CONTEXT *content = _get_context();\n\tint mutex_idx_free = content->mutex_idx;\n\n\tASSERT(scenario >= 0 && scenario < DDP_SCENARIO_MAX);\n\twhile (mutex_idx_free) {\n\t\tif (mutex_idx_free & 0x1) {\n\t\t\tcontent->mutex_idx &= (~(0x1 << mutex_id));\n\t\t\tmutex_id += DISP_MUTEX_DDP_FIRST;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_idx_free >>= 1;\n\t\t++mutex_id;\n\t}\n\tASSERT(mutex_id < (DISP_MUTEX_DDP_FIRST + DISP_MUTEX_DDP_COUNT));\n\tDISP_LOG_I(\"scenario %s acquire mutex %d , left mutex 0x%x!\\n\",\n\t\t   ddp_get_scenario_name(scenario), mutex_id, content->mutex_idx);\n\treturn mutex_id;\n}", "item_id": 7, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/drivers/misc/mediatek/video/mt6735/dispsys/ddp_manager.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "15c90ec3cf839205ea51ea962251a9b87ffa7e7f_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int acquire_mutex(DDP_SCENARIO_ENUM scenario)\n{\n/* /: primay use mutex 0 */\n\tint mutex_id = 0;\n\tDDP_MANAGER_CONTEXT *content = _get_context();\n\tint mutex_idx_free = content->mutex_idx;\n\tASSERT(scenario >= 0 && scenario < DDP_SCENARIO_MAX);\n\twhile (mutex_idx_free) {\n\t\tif (mutex_idx_free & 0x1) {\n\t\t\tcontent->mutex_idx &= (~(0x1 << mutex_id));\n\t\t\tmutex_id += DISP_MUTEX_DDP_FIRST;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_idx_free >>= 1;\n\t\t++mutex_id;\n\t}\n\tASSERT(mutex_id < (DISP_MUTEX_DDP_FIRST + DISP_MUTEX_DDP_COUNT));\n\tDISP_LOG_I(\"scenario %s acquire mutex %d , left mutex 0x%x!\\n\",\n\t\t   ddp_get_scenario_name(scenario), mutex_id, content->mutex_idx);\n\treturn mutex_id;\n"]], "pred": {"ppl": 2.410259485244751, "ppl_lower": 2.9116923809051514, "ppl/lowercase_ppl": -1.214837650809987, "ppl/zlib": 0.0024921654728968234, "Min_5.0% Prob": 7.934122145175934, "Min_10.0% Prob": 5.882335439324379, "Min_20.0% Prob": 3.951280826702714, "Min_30.0% Prob": 2.824838946160582, "Min_40.0% Prob": 2.184073089167129, "Min_50.0% Prob": 1.753886220930719, "Min_60.0% Prob": 1.4681845079992235}}
{"hexsha": "e7ec6e86c60a44ef3c227784777a281297d77697", "ext": "c", "lang": "C", "content": "static void print_element_names(xmlDoc *doc, xmlNode * a_node)\n{\n  xmlNode *cur_node = NULL;\n  xmlAttr *cur_attr = NULL;\n  xmlChar *attr;\n  \n  for (cur_node = a_node; cur_node; cur_node = cur_node->next) {\n    if (cur_node->type == XML_ELEMENT_NODE) {\n      Log(DEBUG,\"node type: Element, name: %s, VALUE %s\",cur_node->name, xmlNodeListGetString(doc, cur_node->xmlChildrenNode, 1));\n    }\n    print_element_names(doc, cur_node->children);\n  }\n}", "item_id": 5, "repo": "Ingenico-NPS-Latam/nps-sdk-c", "file": "npsSdk.c", "last_update_at": "2018-05-31T17:55:31+00:00", "question_id": "e7ec6e86c60a44ef3c227784777a281297d77697_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void print_element_names(xmlDoc *doc, xmlNode * a_node)\n{\n  xmlNode *cur_node = NULL;\n  xmlAttr *cur_attr = NULL;\n  xmlChar *attr;\n  for (cur_node = a_node; cur_node; cur_node = cur_node->next) {\n    if (cur_node->type == XML_ELEMENT_NODE) {\n      Log(DEBUG,\"node type: Element, name: %s, VALUE %s\",cur_node->name, xmlNodeListGetString(doc, cur_node->xmlChildrenNode, 1));\n    }\n    print_element_names(doc, cur_node->children);\n  }\n"]], "pred": {"ppl": 2.340318202972412, "ppl_lower": 3.3205130100250244, "ppl/lowercase_ppl": -1.4114286436881278, "ppl/zlib": 0.003387597228290217, "Min_5.0% Prob": 7.9102582931518555, "Min_10.0% Prob": 5.614899943856632, "Min_20.0% Prob": 3.6922860250753513, "Min_30.0% Prob": 2.6982411648712907, "Min_40.0% Prob": 2.0877148037885918, "Min_50.0% Prob": 1.6873159520328045, "Min_60.0% Prob": 1.4131746523666615}}
{"hexsha": "351055def70884d31f01045490c93ee0a26be39a", "ext": "h", "lang": "C", "content": "class IFWL_CustomPanel : public IFWL_Widget {\r\n public:\r\n  static IFWL_CustomPanel* Create(CFWL_WidgetImpProperties& properties,\r\n                                  IFWL_Widget* pOuter);\r\n\r\n  IFWL_Content* GetContent();\r\n  FWL_ERR SetContent(IFWL_Content* pContent);\r\n  FWL_ERR SetProxy(IFWL_Proxy* pProxy);\r\n\r\n protected:\r\n  IFWL_CustomPanel();\r\n}", "item_id": 1, "repo": "f100cleveland/external_pdfium", "file": "xfa/include/fwl/core/fwl_panel.h", "last_update_at": "2018-01-12T03:24:59+00:00", "question_id": "351055def70884d31f01045490c93ee0a26be39a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class IFWL_CustomPanel : public IFWL_Widget {\r\n public:\r\n  static IFWL_CustomPanel* Create(CFWL_WidgetImpProperties& properties,\r\n                                  IFWL_Widget* pOuter);\r\n\r\n  IFWL_Content* GetContent();\r\n  FWL_ERR SetContent(IFWL_Content* pContent);\r\n  FWL_ERR SetProxy(IFWL_Proxy* pProxy);\r\n\r\n protected:\r\n  IFWL_CustomPanel();\r\n"]], "pred": {"ppl": 2.306424140930176, "ppl_lower": 4.424544334411621, "ppl/lowercase_ppl": -1.7795503915585533, "ppl/zlib": 0.004694934461901695, "Min_5.0% Prob": 8.556496620178223, "Min_10.0% Prob": 6.450209220250447, "Min_20.0% Prob": 4.032958293954532, "Min_30.0% Prob": 2.8091015107929707, "Min_40.0% Prob": 2.087452806304304, "Min_50.0% Prob": 1.68258782796806, "Min_60.0% Prob": 1.4078052464349526}}
{"hexsha": "8a9fa109cb725cdbe8db5306a784001c3d1c1dce", "ext": "c", "lang": "C", "content": "int main(void)\n{\n\n\tparent_pid = getpid();\n\tprintf(\"Parent PID=%d\\n\", parent_pid);\n\tif (fork() == 0) {\n\t\tchild_pid = getpid();\n\t\tprintf(\"Child PID=%d\\n\", child_pid);\n\t\treturn 0;\n\t}\n\tsleep(1);\n\treturn 0;\n}", "item_id": 0, "repo": "lucvoo/slibc", "file": "tests/child_pid.c", "last_update_at": "2018-10-05T14:02:32+00:00", "question_id": "8a9fa109cb725cdbe8db5306a784001c3d1c1dce_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(void)\n{\n\tparent_pid = getpid();\n\tprintf(\"Parent PID=%d\\n\", parent_pid);\n\tif (fork() == 0) {\n\t\tchild_pid = getpid();\n\t\tprintf(\"Child PID=%d\\n\", child_pid);\n\t\treturn 0;\n\t}\n\tsleep(1);\n\treturn 0;\n"]], "pred": {"ppl": 2.0599796772003174, "ppl_lower": 2.0686354637145996, "ppl/lowercase_ppl": -1.0058019909367022, "ppl/zlib": 0.005199252642561776, "Min_5.0% Prob": 7.7969783544540405, "Min_10.0% Prob": 4.983472188313802, "Min_20.0% Prob": 3.1333236192402087, "Min_30.0% Prob": 2.3006298446229527, "Min_40.0% Prob": 1.7607723780368503, "Min_50.0% Prob": 1.4220503304774563, "Min_60.0% Prob": 1.2082289263867496}}
{"hexsha": "b85ba71a6f77e974d82ccdd635109f36d0ddaac8", "ext": "h", "lang": "C", "content": "static int\nremoteDomainDetachDeviceFlags(virDomainPtr dom, const char *xml, unsigned int flags)\n{\n    int rv = -1;\n    struct private_data *priv = dom->conn->privateData;\n    remote_domain_detach_device_flags_args args;\n\n    remoteDriverLock(priv);\n\n    make_nonnull_domain(&args.dom, dom);\n    args.xml = (char *)xml;\n    args.flags = flags;\n\n    if (call(dom->conn, priv, 0, REMOTE_PROC_DOMAIN_DETACH_DEVICE_FLAGS,\n             (xdrproc_t)xdr_remote_domain_detach_device_flags_args, (char *)&args,\n             (xdrproc_t)xdr_void, (char *)NULL) == -1) {\n        goto done;\n    }\n\n    rv = 0;\n\ndone:\n    remoteDriverUnlock(priv);\n    return rv;\n}", "item_id": 50, "repo": "SIIS-cloud/pileus", "file": "libvirt/pileus-libvirt-1.2.12/src/remote/remote_client_bodies.h", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "b85ba71a6f77e974d82ccdd635109f36d0ddaac8_50", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nremoteDomainDetachDeviceFlags(virDomainPtr dom, const char *xml, unsigned int flags)\n{\n    int rv = -1;\n    struct private_data *priv = dom->conn->privateData;\n    remote_domain_detach_device_flags_args args;\n    remoteDriverLock(priv);\n    make_nonnull_domain(&args.dom, dom);\n    args.xml = (char *)xml;\n    args.flags = flags;\n    if (call(dom->conn, priv, 0, REMOTE_PROC_DOMAIN_DETACH_DEVICE_FLAGS,\n             (xdrproc_t)xdr_remote_domain_detach_device_flags_args, (char *)&args,\n             (xdrproc_t)xdr_void, (char *)NULL) == -1) {\n        goto done;\n    }\n    rv = 0;\ndone:\n    remoteDriverUnlock(priv);\n    return rv;\n"]], "pred": {"ppl": 1.8798185586929321, "ppl_lower": 3.0522708892822266, "ppl/lowercase_ppl": -1.7679493108387463, "ppl/zlib": 0.0018189488785325437, "Min_5.0% Prob": 5.769082307815552, "Min_10.0% Prob": 4.390957494576772, "Min_20.0% Prob": 2.883058520654837, "Min_30.0% Prob": 2.070489128016763, "Min_40.0% Prob": 1.5696496216906715, "Min_50.0% Prob": 1.2658661746089, "Min_60.0% Prob": 1.0573759102246498}}
{"hexsha": "18ab999bbfb0f1fc1d7c6aa7f47251006cd66572", "ext": "c", "lang": "C", "content": "static void assert_bip32_assumptions(void)\n{\n#define key_off(member) offsetof(struct ext_key,  member)\n#define key_size(member) sizeof(((struct ext_key *)0)->member)\n\n    /* Our ripend buffers must be uint32_t aligned and the correct size */\n    BUILD_ASSERT(key_off(parent160) % sizeof(uint32_t) == 0);\n    BUILD_ASSERT(key_off(hash160) % sizeof(uint32_t) == 0);\n    BUILD_ASSERT(key_size(parent160) == sizeof(struct ripemd160));\n    BUILD_ASSERT(key_size(hash160) == sizeof(struct ripemd160));\n    BUILD_ASSERT(key_size(priv_key) == EC_PRIVATE_KEY_LEN + 1);\n\n    /* Our keys following the parity byte must be uint64_t aligned */\n    BUILD_ASSERT((key_off(priv_key) + 1) % sizeof(uint64_t) == 0);\n    BUILD_ASSERT((key_off(pub_key) + 1) % sizeof(uint64_t) == 0);\n\n    /* child_num must be contigous after priv_key */\n    BUILD_ASSERT((key_off(priv_key) + key_size(priv_key)) == key_off(child_num));\n\n    /* We use priv_key[0] to determine if this extended key is public or\n     * private, If priv_key[0] is BIP32_FLAG_KEY_PRIVATE then this key is private\n     * with a computed public key present. If set to BIP32_FLAG_KEY_PUBLIC then\n     * this is a public key with no private key (A BIP32 'neutered' key).\n     *\n     * For this to work BIP32_FLAG_KEY_PRIVATE must be zero so the whole 33 byte\n     * private key is valid when serialized, and BIP32_FLAG_KEY_PUBLIC cannot be\n     * 2 or 3 as they are valid parity bytes for public keys.\n     */\n    BUILD_ASSERT(BIP32_FLAG_KEY_PRIVATE == 0);\n    BUILD_ASSERT(BIP32_FLAG_KEY_PUBLIC != BIP32_FLAG_KEY_PRIVATE &&\n                 BIP32_FLAG_KEY_PUBLIC != 2u &&\n                 BIP32_FLAG_KEY_PUBLIC != 3u);\n}", "item_id": 0, "repo": "AbinMM/BIP39_libwally-core", "file": "src/bip32.c", "last_update_at": "2018-07-13T02:45:15+00:00", "question_id": "18ab999bbfb0f1fc1d7c6aa7f47251006cd66572_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void assert_bip32_assumptions(void)\n{\n#define key_off(member) offsetof(struct ext_key,  member)\n#define key_size(member) sizeof(((struct ext_key *)0)->member)\n    /* Our ripend buffers must be uint32_t aligned and the correct size */\n    BUILD_ASSERT(key_off(parent160) % sizeof(uint32_t) == 0);\n    BUILD_ASSERT(key_off(hash160) % sizeof(uint32_t) == 0);\n    BUILD_ASSERT(key_size(parent160) == sizeof(struct ripemd160));\n    BUILD_ASSERT(key_size(hash160) == sizeof(struct ripemd160));\n    BUILD_ASSERT(key_size(priv_key) == EC_PRIVATE_KEY_LEN + 1);\n    /* Our keys following the parity byte must be uint64_t aligned */\n    BUILD_ASSERT((key_off(priv_key) + 1) % sizeof(uint64_t) == 0);\n    BUILD_ASSERT((key_off(pub_key) + 1) % sizeof(uint64_t) == 0);\n    /* child_num must be contigous after priv_key */\n    BUILD_ASSERT((key_off(priv_key) + key_size(priv_key)) == key_off(child_num));\n    /* We use priv_key[0] to determine if this extended key is public or\n     * private, If priv_key[0] is BIP32_FLAG_KEY_PRIVATE then this key is private\n     * with a computed public key present. If set to BIP32_FLAG_KEY_PUBLIC then\n     * this is a public key with no private key (A BIP32 'neutered' key).\n     *\n     * For this to work BIP32_FLAG_KEY_PRIVATE must be zero so the whole 33 byte\n     * private key is valid when serialized, and BIP32_FLAG_KEY_PUBLIC cannot be\n     * 2 or 3 as they are valid parity bytes for public keys.\n     */\n    BUILD_ASSERT(BIP32_FLAG_KEY_PRIVATE == 0);\n    BUILD_ASSERT(BIP32_FLAG_KEY_PUBLIC != BIP32_FLAG_KEY_PRIVATE &&\n                 BIP32_FLAG_KEY_PUBLIC != 2u &&\n                 BIP32_FLAG_KEY_PUBLIC != 3u);\n"]], "pred": {"ppl": 2.220696449279785, "ppl_lower": 2.4216527938842773, "ppl/lowercase_ppl": -1.1085825417889394, "ppl/zlib": 0.0012888866923706657, "Min_5.0% Prob": 7.575551331043243, "Min_10.0% Prob": 5.6147207878530025, "Min_20.0% Prob": 3.6215915675275028, "Min_30.0% Prob": 2.5922658750739123, "Min_40.0% Prob": 1.98603582077801, "Min_50.0% Prob": 1.5930394271550619, "Min_60.0% Prob": 1.330675886811235}}
{"hexsha": "a9c8e628093f64c31dbc89666b04a3121549a9f3", "ext": "c", "lang": "C", "content": "static svn_error_t *\ngit_copy_to(enum parse_state *new_state, char *line, svn_patch_t *patch,\n            apr_pool_t *result_pool, apr_pool_t *scratch_pool)\n{\n  SVN_ERR(grab_filename(&patch->new_filename, line + STRLEN_LITERAL(\"copy to \"),\n                        result_pool, scratch_pool));\n\n  patch->operation = svn_diff_op_copied;\n\n  *new_state = state_git_tree_seen;\n  return SVN_NO_ERROR;\n}", "item_id": 30, "repo": "saurabhacellere/subversion", "file": "subversion/libsvn_diff/parse-diff.c", "last_update_at": "2018-12-24T22:05:09+00:00", "question_id": "a9c8e628093f64c31dbc89666b04a3121549a9f3_30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static svn_error_t *\ngit_copy_to(enum parse_state *new_state, char *line, svn_patch_t *patch,\n            apr_pool_t *result_pool, apr_pool_t *scratch_pool)\n{\n  SVN_ERR(grab_filename(&patch->new_filename, line + STRLEN_LITERAL(\"copy to \"),\n                        result_pool, scratch_pool));\n  patch->operation = svn_diff_op_copied;\n  *new_state = state_git_tree_seen;\n  return SVN_NO_ERROR;\n"]], "pred": {"ppl": 3.2399661540985107, "ppl_lower": 4.046217441558838, "ppl/lowercase_ppl": -1.189032504592019, "ppl/zlib": 0.004898178681182432, "Min_5.0% Prob": 9.397703307015556, "Min_10.0% Prob": 7.586070028940837, "Min_20.0% Prob": 5.233089828491211, "Min_30.0% Prob": 3.818578451209598, "Min_40.0% Prob": 2.9337580477197966, "Min_50.0% Prob": 2.3617811799546082, "Min_60.0% Prob": 1.971082236762676}}
{"hexsha": "47de56bca06ba2220bbd8f4b99bcb7beedbb3be9", "ext": "c", "lang": "C", "content": "static void registerlib(lua_State *L, const char *name, lua_CFunction f) {\n  lua_getglobal(L, \"package\");\n  lua_getfield(L, -1, \"preload\");\n  lua_pushcfunction(L, f);\n  lua_setfield(L, -2, name);\n  lua_pop(L, 2);\n}", "item_id": 7, "repo": "ryanplusplus/pil3", "file": "ch31/lproc.c", "last_update_at": "2018-10-02T20:19:34+00:00", "question_id": "47de56bca06ba2220bbd8f4b99bcb7beedbb3be9_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void registerlib(lua_State *L, const char *name, lua_CFunction f) {\n  lua_getglobal(L, \"package\");\n  lua_getfield(L, -1, \"preload\");\n  lua_pushcfunction(L, f);\n  lua_setfield(L, -2, name);\n  lua_pop(L, 2);\n"]], "pred": {"ppl": 1.6285889148712158, "ppl_lower": 1.8519197702407837, "ppl/lowercase_ppl": -1.2634923050852767, "ppl/zlib": 0.0033177819284973937, "Min_5.0% Prob": 6.954845070838928, "Min_10.0% Prob": 4.115305489963955, "Min_20.0% Prob": 2.323760023242549, "Min_30.0% Prob": 1.6403037160634995, "Min_40.0% Prob": 1.2251801242757785, "Min_50.0% Prob": 0.9737187198091609, "Min_60.0% Prob": 0.8208445439180523}}
{"hexsha": "1110d60c11bb50f9c97fb124dc8c7ca92dee5a9a", "ext": "h", "lang": "C", "content": "void methodNodeToProtobuf( MethodNode * mNode, iso_protobuf::Iso* proto, std::set<long> & extraDataNodes){\n      iso_protobuf::Iso_MethodNode * method_node = proto -> add_method_nodes();\n      method_node -> set_id(mNode -> get_id() );\n      method_node -> set_name(mNode -> get_name() );\n      proto ->add_methodcallnames(mNode -> get_name() );\n      // Iterate through the arguments and add types/id\n      const std::vector<DataNode*> & args = mNode -> get_arguments();\n      for (const DataNode * dd : args){\n        method_node -> add_argumenttypes( dd -> get_data_type()  );\n        method_node -> add_argumentids( dd -> get_id());\n        //cout << dd -> get_id() << endl;\n        extraDataNodes.insert( dd-> get_id());\n        assert(dd -> get_type() == DATA_NODE);\n      }\n      // Add invokee/receiver types\n      const DataNode* rcv = mNode -> get_receiver();\n      if (rcv != NULL){\n        std::cerr << \"Debug: invokee type = \"<< rcv -> get_name() << endl;\n        method_node -> set_invokeetype(rcv -> get_data_type());\n        method_node -> set_invokeeid (rcv -> get_id());\n        extraDataNodes.insert( rcv -> get_id());\n        //cout << rcv -> get_id() << endl;\n        assert(rcv -> get_type() == DATA_NODE);\n      } else {\n        // std::cerr << \"Debug: invokee type cleared\"<< endl;\n        method_node -> clear_invokeetype();\n        method_node -> clear_invokeeid();\n      }\n      // Add assignee types\n      const DataNode * assg = mNode -> get_assignee();\n      if (assg != NULL){\n        method_node -> set_assigneetype(assg -> get_data_type());\n        method_node -> set_assigneeid(assg -> get_id());\n        extraDataNodes.insert(assg-> get_id());\n        //cout << assg -> get_id() <<endl;\n        assert(assg -> get_type() == DATA_NODE);\n      } else {\n        method_node -> clear_assigneetype();\n        method_node -> clear_assigneeid();\n      }\n      // Done!\n    }", "item_id": 3, "repo": "cuplv/FixrGraphIso", "file": "src/fixrgraphiso/isomorphismResults.h", "last_update_at": "2018-08-28T23:12:43+00:00", "question_id": "1110d60c11bb50f9c97fb124dc8c7ca92dee5a9a_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void methodNodeToProtobuf( MethodNode * mNode, iso_protobuf::Iso* proto, std::set<long> & extraDataNodes){\n      iso_protobuf::Iso_MethodNode * method_node = proto -> add_method_nodes();\n      method_node -> set_id(mNode -> get_id() );\n      method_node -> set_name(mNode -> get_name() );\n      proto ->add_methodcallnames(mNode -> get_name() );\n      // Iterate through the arguments and add types/id\n      const std::vector<DataNode*> & args = mNode -> get_arguments();\n      for (const DataNode * dd : args){\n        method_node -> add_argumenttypes( dd -> get_data_type()  );\n        method_node -> add_argumentids( dd -> get_id());\n        //cout << dd -> get_id() << endl;\n        extraDataNodes.insert( dd-> get_id());\n        assert(dd -> get_type() == DATA_NODE);\n      }\n      // Add invokee/receiver types\n      const DataNode* rcv = mNode -> get_receiver();\n      if (rcv != NULL){\n        std::cerr << \"Debug: invokee type = \"<< rcv -> get_name() << endl;\n        method_node -> set_invokeetype(rcv -> get_data_type());\n        method_node -> set_invokeeid (rcv -> get_id());\n        extraDataNodes.insert( rcv -> get_id());\n        //cout << rcv -> get_id() << endl;\n        assert(rcv -> get_type() == DATA_NODE);\n      } else {\n        // std::cerr << \"Debug: invokee type cleared\"<< endl;\n        method_node -> clear_invokeetype();\n        method_node -> clear_invokeeid();\n      }\n      // Add assignee types\n      const DataNode * assg = mNode -> get_assignee();\n      if (assg != NULL){\n        method_node -> set_assigneetype(assg -> get_data_type());\n        method_node -> set_assigneeid(assg -> get_id());\n        extraDataNodes.insert(assg-> get_id());\n        //cout << assg -> get_id() <<endl;\n        assert(assg -> get_type() == DATA_NODE);\n      } else {\n        method_node -> clear_assigneetype();\n        method_node -> clear_assigneeid();\n      }\n      // Done!\n"]], "pred": {"ppl": 2.2379584312438965, "ppl_lower": 2.329090118408203, "ppl/lowercase_ppl": -1.0495474559061142, "ppl/zlib": 0.001494552941842011, "Min_5.0% Prob": 7.161070060729981, "Min_10.0% Prob": 5.474198935461826, "Min_20.0% Prob": 3.5627895453111913, "Min_30.0% Prob": 2.5843180622095647, "Min_40.0% Prob": 1.9881548935744335, "Min_50.0% Prob": 1.6015951143722835, "Min_60.0% Prob": 1.3419012040616616}}
{"hexsha": "8e7df5daef45c7ee46c2898f834e917629ebe323", "ext": "h", "lang": "C", "content": "interface RCWeakRef : NSObject {\n    bool  _useWeakStorage;\n    id  _weakPointer;\n    id  _weakStorage;\n}", "item_id": 0, "repo": "shaojiankui/iOS10-Runtime-Headers", "file": "PrivateFrameworks/VoiceMemos.framework/RCWeakRef.h", "last_update_at": "2018-10-08T04:12:25+00:00", "question_id": "8e7df5daef45c7ee46c2898f834e917629ebe323_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface RCWeakRef : NSObject {\n    bool  _useWeakStorage;\n    id  _weakPointer;\n    id  _weakStorage;\n"]], "pred": {"ppl": 7.365417003631592, "ppl_lower": 17.266756057739258, "ppl/lowercase_ppl": -1.4266772927239677, "ppl/zlib": 0.024351166682310403, "Min_5.0% Prob": 10.337848663330078, "Min_10.0% Prob": 9.24445390701294, "Min_20.0% Prob": 7.346796580723354, "Min_30.0% Prob": 5.6547863483428955, "Min_40.0% Prob": 4.706664664404733, "Min_50.0% Prob": 3.8778375685214996, "Min_60.0% Prob": 3.2896051000465047}}
{"hexsha": "ff73cfa5e7ea8d95165ed0e6c722f3199c3bf2a8", "ext": "c", "lang": "C", "content": "void SystemInit (void)\r\n{\r\n#if CORTEX_VECTORS_RAM\r\n\t// Then assume need to map vectors to RAM\r\n\tLPC_SYSCON->SYSMEMREMAP = ((LPC_SYSCON->SYSMEMREMAP)& ~3) | 1;\r\n#else\r\n     //\tLPC_SYSCON->SYSMEMREMAP |= 3; // Map to flash\r\n#endif\r\n    \t\r\n#if (CLOCK_SETUP)                                 /* Clock Setup              */\r\n#if (SYSCLK_SETUP)                                /* System Clock Setup       */\r\n#if (SYSOSC_SETUP)                                /* System Oscillator Setup  */\r\n  uint32_t i;\r\n\r\n  LPC_SYSCON->PDRUNCFG     &= ~(1 << 5);          /* Power-up System Osc      */\r\n  LPC_SYSCON->SYSOSCCTRL    = SYSOSCCTRL_Val;\r\n  for (i = 0; i < 200; i++) __NOP();\r\n  LPC_SYSCON->SYSPLLCLKSEL  = SYSPLLCLKSEL_Val;   /* Select PLL Input         */\r\n  LPC_SYSCON->SYSPLLCLKUEN  = 0x01;               /* Update Clock Source      */\r\n  LPC_SYSCON->SYSPLLCLKUEN  = 0x00;               /* Toggle Update Register   */\r\n  LPC_SYSCON->SYSPLLCLKUEN  = 0x01;\r\n  while (!(LPC_SYSCON->SYSPLLCLKUEN & 0x01));     /* Wait Until Updated       */\r\n#if (SYSPLL_SETUP)                                /* System PLL Setup         */\r\n  LPC_SYSCON->SYSPLLCTRL    = SYSPLLCTRL_Val;\r\n  LPC_SYSCON->PDRUNCFG     &= ~(1 << 7);          /* Power-up SYSPLL          */\r\n  while (!(LPC_SYSCON->SYSPLLSTAT & 0x01));\t      /* Wait Until PLL Locked    */\r\n#endif\r\n#endif\r\n#if (WDTOSC_SETUP)                                /* Watchdog Oscillator Setup*/\r\n  LPC_SYSCON->WDTOSCCTRL    = WDTOSCCTRL_Val;\r\n  LPC_SYSCON->PDRUNCFG     &= ~(1 << 6);          /* Power-up WDT Clock       */\r\n#endif\r\n  LPC_SYSCON->MAINCLKSEL    = MAINCLKSEL_Val;     /* Select PLL Clock Output  */\r\n  LPC_SYSCON->MAINCLKUEN    = 0x01;               /* Update MCLK Clock Source */\r\n  LPC_SYSCON->MAINCLKUEN    = 0x00;               /* Toggle Update Register   */\r\n  LPC_SYSCON->MAINCLKUEN    = 0x01;\r\n  while (!(LPC_SYSCON->MAINCLKUEN & 0x01));       /* Wait Until Updated       */\r\n#endif\r\n\r\n  LPC_SYSCON->SYSAHBCLKDIV  = SYSAHBCLKDIV_Val;\r\n  LPC_SYSCON->SYSAHBCLKCTRL = AHBCLKCTRL_Val;\r\n  LPC_SYSCON->SSP0CLKDIV    = SSP0CLKDIV_Val;\r\n  LPC_SYSCON->UARTCLKDIV    = UARTCLKDIV_Val;\r\n  LPC_SYSCON->SSP1CLKDIV    = SSP1CLKDIV_Val;\r\n#endif\r\n\r\n\r\n#if (MEMMAP_SETUP || MEMMAP_INIT)       /* Memory Mapping Setup               */\r\n  LPC_SYSCON->SYSMEMREMAP = SYSMEMREMAP_Val;\r\n#endif\r\n  SystemCoreClockUpdate();\r\n}", "item_id": 1, "repo": "jrahlf/3D-Non-Contact-Laser-Profilometer", "file": "xpcc/ext/lpc11xx/cmsis/system_LPC11xx.c", "last_update_at": "2018-01-02T23:34:18+00:00", "question_id": "ff73cfa5e7ea8d95165ed0e6c722f3199c3bf2a8_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void SystemInit (void)\r\n{\r\n#if CORTEX_VECTORS_RAM\r\n\t// Then assume need to map vectors to RAM\r\n\tLPC_SYSCON->SYSMEMREMAP = ((LPC_SYSCON->SYSMEMREMAP)& ~3) | 1;\r\n#else\r\n     //\tLPC_SYSCON->SYSMEMREMAP |= 3; // Map to flash\r\n#endif\r\n    \t\r\n#if (CLOCK_SETUP)                                 /* Clock Setup              */\r\n#if (SYSCLK_SETUP)                                /* System Clock Setup       */\r\n#if (SYSOSC_SETUP)                                /* System Oscillator Setup  */\r\n  uint32_t i;\r\n\r\n  LPC_SYSCON->PDRUNCFG     &= ~(1 << 5);          /* Power-up System Osc      */\r\n  LPC_SYSCON->SYSOSCCTRL    = SYSOSCCTRL_Val;\r\n  for (i = 0; i < 200; i++) __NOP();\r\n  LPC_SYSCON->SYSPLLCLKSEL  = SYSPLLCLKSEL_Val;   /* Select PLL Input         */\r\n  LPC_SYSCON->SYSPLLCLKUEN  = 0x01;               /* Update Clock Source      */\r\n  LPC_SYSCON->SYSPLLCLKUEN  = 0x00;               /* Toggle Update Register   */\r\n  LPC_SYSCON->SYSPLLCLKUEN  = 0x01;\r\n  while (!(LPC_SYSCON->SYSPLLCLKUEN & 0x01));     /* Wait Until Updated       */\r\n#if (SYSPLL_SETUP)                                /* System PLL Setup         */\r\n  LPC_SYSCON->SYSPLLCTRL    = SYSPLLCTRL_Val;\r\n  LPC_SYSCON->PDRUNCFG     &= ~(1 << 7);          /* Power-up SYSPLL          */\r\n  while (!(LPC_SYSCON->SYSPLLSTAT & 0x01));\t      /* Wait Until PLL Locked    */\r\n#endif\r\n#endif\r\n#if (WDTOSC_SETUP)                                /* Watchdog Oscillator Setup*/\r\n  LPC_SYSCON->WDTOSCCTRL    = WDTOSCCTRL_Val;\r\n  LPC_SYSCON->PDRUNCFG     &= ~(1 << 6);          /* Power-up WDT Clock       */\r\n#endif\r\n  LPC_SYSCON->MAINCLKSEL    = MAINCLKSEL_Val;     /* Select PLL Clock Output  */\r\n  LPC_SYSCON->MAINCLKUEN    = 0x01;               /* Update MCLK Clock Source */\r\n  LPC_SYSCON->MAINCLKUEN    = 0x00;               /* Toggle Update Register   */\r\n  LPC_SYSCON->MAINCLKUEN    = 0x01;\r\n  while (!(LPC_SYSCON->MAINCLKUEN & 0x01));       /* Wait Until Updated       */\r\n#endif\r\n\r\n  LPC_SYSCON->SYSAHBCLKDIV  = SYSAHBCLKDIV_Val;\r\n  LPC_SYSCON->SYSAHBCLKCTRL = AHBCLKCTRL_Val;\r\n  LPC_SYSCON->SSP0CLKDIV    = SSP0CLKDIV_Val;\r\n  LPC_SYSCON->UARTCLKDIV    = UARTCLKDIV_Val;\r\n  LPC_SYSCON->SSP1CLKDIV    = SSP1CLKDIV_Val;\r\n#endif\r\n\r\n\r\n#if (MEMMAP_SETUP || MEMMAP_INIT)       /* Memory Mapping Setup               */\r\n  LPC_SYSCON->SYSMEMREMAP = SYSMEMREMAP_Val;\r\n#endif\r\n  SystemCoreClockUpdate();\r\n"]], "pred": {"ppl": 1.6188297271728516, "ppl_lower": 1.986599087715149, "ppl/lowercase_ppl": -1.4249931317838038, "ppl/zlib": 0.0006911097525974302, "Min_5.0% Prob": 5.516739888191223, "Min_10.0% Prob": 3.8491482400894164, "Min_20.0% Prob": 2.295406035631895, "Min_30.0% Prob": 1.5924708080788454, "Min_40.0% Prob": 1.2018011330471297, "Min_50.0% Prob": 0.9637692041449739, "Min_60.0% Prob": 0.8038081441529036}}
{"hexsha": "7eb4c80fa9defa43b05514893caa0815195555fa", "ext": "c", "lang": "C", "content": "SWIGINTERN PyObject *_wrap_get_XE_YIELD_IFBA_DIFF_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {\n  PyObject *resultobj = 0;\n  float arg1 ;\n  float arg2 ;\n  float val1 ;\n  int ecode1 = 0 ;\n  float val2 ;\n  int ecode2 = 0 ;\n  PyObject * obj0 = 0 ;\n  PyObject * obj1 = 0 ;\n  float result;\n  \n  if (!PyArg_ParseTuple(args,(char *)\"OO:get_XE_YIELD_IFBA_DIFF_1\",&obj0,&obj1)) SWIG_fail;\n  ecode1 = SWIG_AsVal_float(obj0, &val1);\n  if (!SWIG_IsOK(ecode1)) {\n    SWIG_exception_fail(SWIG_ArgError(ecode1), \"in method '\" \"get_XE_YIELD_IFBA_DIFF_1\" \"', argument \" \"1\"\" of type '\" \"float\"\"'\");\n  } \n  arg1 = (float)(val1);\n  ecode2 = SWIG_AsVal_float(obj1, &val2);\n  if (!SWIG_IsOK(ecode2)) {\n    SWIG_exception_fail(SWIG_ArgError(ecode2), \"in method '\" \"get_XE_YIELD_IFBA_DIFF_1\" \"', argument \" \"2\"\" of type '\" \"float\"\"'\");\n  } \n  arg2 = (float)(val2);\n  result = (float)get_XE_YIELD_IFBA_DIFF_1(arg1,arg2);\n  resultobj = SWIG_From_float((float)(result));\n  return resultobj;\nfail:\n  return NULL;\n}", "item_id": 189, "repo": "robertsj/poropy", "file": "poropy/nucleardata/nucleardata_wrap.c", "last_update_at": "2018-02-11T11:24:14+00:00", "question_id": "7eb4c80fa9defa43b05514893caa0815195555fa_189", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["SWIGINTERN PyObject *_wrap_get_XE_YIELD_IFBA_DIFF_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {\n  PyObject *resultobj = 0;\n  float arg1 ;\n  float arg2 ;\n  float val1 ;\n  int ecode1 = 0 ;\n  float val2 ;\n  int ecode2 = 0 ;\n  PyObject * obj0 = 0 ;\n  PyObject * obj1 = 0 ;\n  float result;\n  if (!PyArg_ParseTuple(args,(char *)\"OO:get_XE_YIELD_IFBA_DIFF_1\",&obj0,&obj1)) SWIG_fail;\n  ecode1 = SWIG_AsVal_float(obj0, &val1);\n  if (!SWIG_IsOK(ecode1)) {\n    SWIG_exception_fail(SWIG_ArgError(ecode1), \"in method '\" \"get_XE_YIELD_IFBA_DIFF_1\" \"', argument \" \"1\"\" of type '\" \"float\"\"'\");\n  } \n  arg1 = (float)(val1);\n  ecode2 = SWIG_AsVal_float(obj1, &val2);\n  if (!SWIG_IsOK(ecode2)) {\n    SWIG_exception_fail(SWIG_ArgError(ecode2), \"in method '\" \"get_XE_YIELD_IFBA_DIFF_1\" \"', argument \" \"2\"\" of type '\" \"float\"\"'\");\n  } \n  arg2 = (float)(val2);\n  result = (float)get_XE_YIELD_IFBA_DIFF_1(arg1,arg2);\n  resultobj = SWIG_From_float((float)(result));\n  return resultobj;\nfail:\n  return NULL;\n"]], "pred": {"ppl": 1.66029953956604, "ppl_lower": 2.5521581172943115, "ppl/lowercase_ppl": -1.8480137265463548, "ppl/zlib": 0.0012674950790295693, "Min_5.0% Prob": 6.1378784504803745, "Min_10.0% Prob": 4.283905969725715, "Min_20.0% Prob": 2.457697887342055, "Min_30.0% Prob": 1.6857084056417293, "Min_40.0% Prob": 1.2658091175758823, "Min_50.0% Prob": 1.0159590153971334, "Min_60.0% Prob": 0.8449322448068148}}
{"hexsha": "c0399fc1ac6e4e1b2b58796cdd0ab370d0e9d37d", "ext": "c", "lang": "C", "content": "int _ArrayListSearch(ArrayList self, void* element){\n    //TODO\n    printf(\"ArrayListSearch function\\n\");\n    return 0;\n}", "item_id": 1, "repo": "touir1/Data-structures-C", "file": "DataStructures/ArrayList/ArrayList.c", "last_update_at": "2018-09-23T16:32:19+00:00", "question_id": "c0399fc1ac6e4e1b2b58796cdd0ab370d0e9d37d_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int _ArrayListSearch(ArrayList self, void* element){\n    //TODO\n    printf(\"ArrayListSearch function\\n\");\n    return 0;\n"]], "pred": {"ppl": 9.121082305908203, "ppl_lower": 9.271942138671875, "ppl/lowercase_ppl": -1.007420827014412, "ppl/zlib": 0.021887014563747465, "Min_5.0% Prob": 12.289833068847656, "Min_10.0% Prob": 9.601075808207193, "Min_20.0% Prob": 6.866366556712559, "Min_30.0% Prob": 5.877897548675537, "Min_40.0% Prob": 4.889698624610901, "Min_50.0% Prob": 4.23655903339386, "Min_60.0% Prob": 3.5919792027700517}}
{"hexsha": "22a4745258654e16e2a04ebe2d10bf669a9162f7", "ext": "h", "lang": "C", "content": "class CivilianImgPathManager\r\n{\r\npublic:\r\n\r\n    static const char* getRandomCivilianImgPathBegin();\r\n\r\nprivate:\r\n    CivilianImgPathManager(void);\r\n    ~CivilianImgPathManager(void);\r\n}", "item_id": 0, "repo": "TyrealGray/AssassinWar", "file": "GameModuleSet/CivilianImgPathManager.h", "last_update_at": "2018-04-17T21:04:31+00:00", "question_id": "22a4745258654e16e2a04ebe2d10bf669a9162f7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class CivilianImgPathManager\r\n{\r\npublic:\r\n\r\n    static const char* getRandomCivilianImgPathBegin();\r\n\r\nprivate:\r\n    CivilianImgPathManager(void);\r\n    ~CivilianImgPathManager(void);\r\n"]], "pred": {"ppl": 4.68271017074585, "ppl_lower": 5.484890937805176, "ppl/lowercase_ppl": -1.102417593644764, "ppl/zlib": 0.01286564198859339, "Min_5.0% Prob": 11.634376525878906, "Min_10.0% Prob": 9.1266876856486, "Min_20.0% Prob": 6.261505126953125, "Min_30.0% Prob": 4.6382411453459, "Min_40.0% Prob": 3.740069436530272, "Min_50.0% Prob": 3.0715649927655857, "Min_60.0% Prob": 2.572161592025724}}
{"hexsha": "d7867156a643510e0a32d44d62f95ae5410fc6c1", "ext": "c", "lang": "C", "content": "LIBXSMM_INLINE void init_buf(float* buf, size_t size, int initPos, int initOne)\n{\n  int i;\n  zero_buf(buf, size);\n  for (i = 0; i < (int)size; ++i) {\n    buf[i] = (float)((initOne != 0) ? 1.0 : ((initPos != 0) ? libxsmm_rand_f64() : (0.05 - libxsmm_rand_f64()/10.0)));\n  }\n}", "item_id": 5, "repo": "egeor/libxsmm", "file": "samples/deeplearning/cnnlayer/layer_example_bf16.c", "last_update_at": "2018-07-05T05:09:09+00:00", "question_id": "d7867156a643510e0a32d44d62f95ae5410fc6c1_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["LIBXSMM_INLINE void init_buf(float* buf, size_t size, int initPos, int initOne)\n{\n  int i;\n  zero_buf(buf, size);\n  for (i = 0; i < (int)size; ++i) {\n    buf[i] = (float)((initOne != 0) ? 1.0 : ((initPos != 0) ? libxsmm_rand_f64() : (0.05 - libxsmm_rand_f64()/10.0)));\n  }\n"]], "pred": {"ppl": 1.6800719499588013, "ppl_lower": 1.7938717603683472, "ppl/lowercase_ppl": -1.1263204180356328, "ppl/zlib": 0.002759769254545382, "Min_5.0% Prob": 6.082756519317627, "Min_10.0% Prob": 4.0910902206714335, "Min_20.0% Prob": 2.381183167298635, "Min_30.0% Prob": 1.6811793770005063, "Min_40.0% Prob": 1.2843125409700653, "Min_50.0% Prob": 1.0324603357500788, "Min_60.0% Prob": 0.8718329840907599}}
{"hexsha": "4fab89f5c5c43003240da57d138c4dae953e3b7f", "ext": "c", "lang": "C", "content": "static void report_error (gravity_parser_t *parser, error_type_t error_type, gtoken_s token, const char *format, ...) {\n    // just one error for each line\n    if (parser->last_error_lineno == token.lineno) return;\n    parser->last_error_lineno = token.lineno;\n\n    // increment internal error counter\n    if (error_type != GRAVITY_WARNING) ++parser->nerrors;\n\n    // get error callback (if any)\n    void *data = (parser->delegate) ? parser->delegate->xdata : NULL;\n    gravity_error_callback error_fn = (parser->delegate) ? ((gravity_delegate_t *)parser->delegate)->error_callback : NULL;\n\n    // build error message\n    char        buffer[1024];\n    va_list        arg;\n    if (format) {\n        va_start (arg, format);\n        vsnprintf(buffer, sizeof(buffer), format, arg);\n        va_end (arg);\n    }\n\n    // setup error struct\n    error_desc_t error_desc = {\n        .lineno = token.lineno,\n        .colno = token.colno,\n        .fileid = token.fileid,\n        .offset = token.position\n    };\n\n    // finally call error callback\n    if (error_fn) error_fn(NULL, error_type, buffer, error_desc, data);\n    else printf(\"%s\\n\", buffer);\n}", "item_id": 1, "repo": "elix22/gravity", "file": "src/compiler/gravity_parser.c", "last_update_at": "2018-07-13T02:14:08+00:00", "question_id": "4fab89f5c5c43003240da57d138c4dae953e3b7f_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void report_error (gravity_parser_t *parser, error_type_t error_type, gtoken_s token, const char *format, ...) {\n    // just one error for each line\n    if (parser->last_error_lineno == token.lineno) return;\n    parser->last_error_lineno = token.lineno;\n    // increment internal error counter\n    if (error_type != GRAVITY_WARNING) ++parser->nerrors;\n    // get error callback (if any)\n    void *data = (parser->delegate) ? parser->delegate->xdata : NULL;\n    gravity_error_callback error_fn = (parser->delegate) ? ((gravity_delegate_t *)parser->delegate)->error_callback : NULL;\n    // build error message\n    char        buffer[1024];\n    va_list        arg;\n    if (format) {\n        va_start (arg, format);\n        vsnprintf(buffer, sizeof(buffer), format, arg);\n        va_end (arg);\n    }\n    // setup error struct\n    error_desc_t error_desc = {\n        .lineno = token.lineno,\n        .colno = token.colno,\n        .fileid = token.fileid,\n        .offset = token.position\n    };\n    // finally call error callback\n    if (error_fn) error_fn(NULL, error_type, buffer, error_desc, data);\n    else printf(\"%s\\n\", buffer);\n"]], "pred": {"ppl": 2.4495441913604736, "ppl_lower": 2.5675394535064697, "ppl/lowercase_ppl": -1.0525125161588649, "ppl/zlib": 0.001784665264752144, "Min_5.0% Prob": 7.215229006374583, "Min_10.0% Prob": 5.695766530718122, "Min_20.0% Prob": 3.8439375413975245, "Min_30.0% Prob": 2.8169837348929074, "Min_40.0% Prob": 2.188787427607116, "Min_50.0% Prob": 1.7768005976380583, "Min_60.0% Prob": 1.4944007249079019}}
{"hexsha": "f904eded3ae3337eb05a9dc97e8e8745e9615f5c", "ext": "c", "lang": "C", "content": "Drand *\nDrand_new ( \n   void \n) {\nDrand   *drand ;\n\nALLOCATE(drand, struct _Drand, 1) ;\nDrand_setDefaultFields(drand) ;\n\nreturn(drand) ; }", "item_id": 0, "repo": "alleindrach/calculix-desktop", "file": "ccx_prool/SPOOLES.2.2/Drand/src/basics.c", "last_update_at": "2018-01-25T16:08:31+00:00", "question_id": "f904eded3ae3337eb05a9dc97e8e8745e9615f5c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["Drand *\nDrand_new ( \n   void \n) {\nDrand   *drand ;\nALLOCATE(drand, struct _Drand, 1) ;\nDrand_setDefaultFields(drand) ;\n"]], "pred": {"ppl": 7.058436393737793, "ppl_lower": 8.36262321472168, "ppl/lowercase_ppl": -1.0867600875452368, "ppl/zlib": 0.017928656449553684, "Min_5.0% Prob": 8.757538795471191, "Min_10.0% Prob": 7.842368125915527, "Min_20.0% Prob": 6.52112078666687, "Min_30.0% Prob": 5.273784486871016, "Min_40.0% Prob": 4.484852714538574, "Min_50.0% Prob": 3.7724936697632074, "Min_60.0% Prob": 3.2445109219927537}}
{"hexsha": "a00ad98e9e5bd6a979ca38715790cae6b11c5532", "ext": "c", "lang": "C", "content": "int wav2adpcm(const char *infile, const char *outfile) {\n\tstruct wavhdr_t wavhdr;\n\tFILE *in, *out;\n\tsize_t pcmsize, adpcmsize;\n\tshort *pcmbuf;\n\tunsigned char *adpcmbuf;\n\n\tin = fopen(infile, \"rb\");\n\tif (in == NULL) {\n\t\tprintf(\"can't open %s\\n\", infile);\n\t\treturn -1;\n\t}\n\tfread(&wavhdr, 1, sizeof(wavhdr), in);\n\n\tif (memcmp(wavhdr.hdr1, \"RIFF\", 4)\n\t\t|| memcmp(wavhdr.hdr2, \"WAVEfmt \", 8)\n\t\t|| memcmp(wavhdr.hdr3, \"data\", 4)\n\t\t|| wavhdr.hdrsize != 0x10\n\t\t|| wavhdr.format != 1\n\t\t|| (wavhdr.channels != 1 && wavhdr.channels != 2)\n\t\t|| wavhdr.bits != 16) {\n\t\tprintf(\"unsupport format\\n\");\n\t\tfclose(in);\n\t\treturn -1;\n\t}\n\n\tpcmsize = wavhdr.datasize;\n\n\tadpcmsize = pcmsize / 4;\n\tpcmbuf = malloc(pcmsize);\n\tadpcmbuf = malloc(adpcmsize);\n\n\tfread(pcmbuf, 1, pcmsize, in);\n\tfclose(in);\n\n\tif (wavhdr.channels == 1) {\n\t\tpcm2adpcm(adpcmbuf, pcmbuf, pcmsize);\n\t}\n\telse {\n\t\t/* For stereo we just deinterleave the input and store the\n\t\tleft and right channel of the ADPCM data separately. */\n\t\tdeinterleave(pcmbuf, pcmsize);\n\t\tpcm2adpcm(adpcmbuf, pcmbuf, pcmsize / 2);\n\t\tpcm2adpcm(adpcmbuf + adpcmsize / 2, pcmbuf + pcmsize / 4, pcmsize / 2);\n\t}\n\n\tout = fopen(outfile, \"wb\");\n\twavhdr.datasize = adpcmsize;\n\twavhdr.format = 20;\t/* ITU G.723 ADPCM (Yamaha) */\n\twavhdr.bits = 4;\n\twavhdr.totalsize = wavhdr.datasize + sizeof(wavhdr) - 8;\n\tfwrite(&wavhdr, 1, sizeof(wavhdr), out);\n\tfwrite(adpcmbuf, 1, adpcmsize, out);\n\tfclose(out);\n\n\treturn 0;\n}", "item_id": 4, "repo": "trigger-death/WiimoteLib.Net", "file": "Wav2ADPCM/wav2adpcm.c", "last_update_at": "2018-09-17T13:50:51+00:00", "question_id": "a00ad98e9e5bd6a979ca38715790cae6b11c5532_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int wav2adpcm(const char *infile, const char *outfile) {\n\tstruct wavhdr_t wavhdr;\n\tFILE *in, *out;\n\tsize_t pcmsize, adpcmsize;\n\tshort *pcmbuf;\n\tunsigned char *adpcmbuf;\n\tin = fopen(infile, \"rb\");\n\tif (in == NULL) {\n\t\tprintf(\"can't open %s\\n\", infile);\n\t\treturn -1;\n\t}\n\tfread(&wavhdr, 1, sizeof(wavhdr), in);\n\tif (memcmp(wavhdr.hdr1, \"RIFF\", 4)\n\t\t|| memcmp(wavhdr.hdr2, \"WAVEfmt \", 8)\n\t\t|| memcmp(wavhdr.hdr3, \"data\", 4)\n\t\t|| wavhdr.hdrsize != 0x10\n\t\t|| wavhdr.format != 1\n\t\t|| (wavhdr.channels != 1 && wavhdr.channels != 2)\n\t\t|| wavhdr.bits != 16) {\n\t\tprintf(\"unsupport format\\n\");\n\t\tfclose(in);\n\t\treturn -1;\n\t}\n\tpcmsize = wavhdr.datasize;\n\tadpcmsize = pcmsize / 4;\n\tpcmbuf = malloc(pcmsize);\n\tadpcmbuf = malloc(adpcmsize);\n\tfread(pcmbuf, 1, pcmsize, in);\n\tfclose(in);\n\tif (wavhdr.channels == 1) {\n\t\tpcm2adpcm(adpcmbuf, pcmbuf, pcmsize);\n\t}\n\telse {\n\t\t/* For stereo we just deinterleave the input and store the\n\t\tleft and right channel of the ADPCM data separately. */\n\t\tdeinterleave(pcmbuf, pcmsize);\n\t\tpcm2adpcm(adpcmbuf, pcmbuf, pcmsize / 2);\n\t\tpcm2adpcm(adpcmbuf + adpcmsize / 2, pcmbuf + pcmsize / 4, pcmsize / 2);\n\t}\n\tout = fopen(outfile, \"wb\");\n\twavhdr.datasize = adpcmsize;\n\twavhdr.format = 20;\t/* ITU G.723 ADPCM (Yamaha) */\n\twavhdr.bits = 4;\n\twavhdr.totalsize = wavhdr.datasize + sizeof(wavhdr) - 8;\n\tfwrite(&wavhdr, 1, sizeof(wavhdr), out);\n\tfwrite(adpcmbuf, 1, adpcmsize, out);\n\tfclose(out);\n\treturn 0;\n"]], "pred": {"ppl": 1.6458786725997925, "ppl_lower": 1.7294846773147583, "ppl/lowercase_ppl": -1.099441395641441, "ppl/zlib": 0.0008049667028892223, "Min_5.0% Prob": 5.403853522406684, "Min_10.0% Prob": 3.736809603155476, "Min_20.0% Prob": 2.3300015950856143, "Min_30.0% Prob": 1.6355384699830182, "Min_40.0% Prob": 1.2390790989196545, "Min_50.0% Prob": 0.9959456863930154, "Min_60.0% Prob": 0.8314268729227313}}
{"hexsha": "1e79be0b322a5cbc6f2a2a24a7e1f4629db74617", "ext": "c", "lang": "C", "content": "static char *\nname_list_to_string(DefElem *def)\n{\n\tStringInfoData string;\n\tListCell *lc;\n\tbool first = true;\n\n\tinitStringInfo(&string);\n\n\tforeach (lc, (List *) def->arg)\n\t{\n\t\tNode *name = (Node *) lfirst(lc);\n\n\t\tif (!first)\n\t\t\tappendStringInfo(&string, \", \");\n\t\telse\n\t\t\tfirst = false;\n\n\t\tif (IsA(name, String))\n\t\t\tappendStringInfoString(&string, quote_identifier(strVal(name)));\n\t\telse if (IsA(name, A_Star))\n\t\t\tappendStringInfoChar(&string, '*');\n\t\telse\n\t\t\telog(ERROR, \"unexpected node type in name list: %d\", (int) nodeTag(name));\n\t}\n\treturn string.data;\n}", "item_id": 11, "repo": "jameswinegar/timescaledb", "file": "tsl/src/remote/dist_copy.c", "last_update_at": "2018-12-18T11:57:43+00:00", "question_id": "1e79be0b322a5cbc6f2a2a24a7e1f4629db74617_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static char *\nname_list_to_string(DefElem *def)\n{\n\tStringInfoData string;\n\tListCell *lc;\n\tbool first = true;\n\tinitStringInfo(&string);\n\tforeach (lc, (List *) def->arg)\n\t{\n\t\tNode *name = (Node *) lfirst(lc);\n\t\tif (!first)\n\t\t\tappendStringInfo(&string, \", \");\n\t\telse\n\t\t\tfirst = false;\n\t\tif (IsA(name, String))\n\t\t\tappendStringInfoString(&string, quote_identifier(strVal(name)));\n\t\telse if (IsA(name, A_Star))\n\t\t\tappendStringInfoChar(&string, '*');\n\t\telse\n\t\t\telog(ERROR, \"unexpected node type in name list: %d\", (int) nodeTag(name));\n\t}\n\treturn string.data;\n"]], "pred": {"ppl": 1.5521920919418335, "ppl_lower": 2.809572696685791, "ppl/lowercase_ppl": -2.349572797246251, "ppl/zlib": 0.0013869658822812582, "Min_5.0% Prob": 4.772508556192571, "Min_10.0% Prob": 3.40259325504303, "Min_20.0% Prob": 2.072120428085327, "Min_30.0% Prob": 1.4432457683246527, "Min_40.0% Prob": 1.102077325889736, "Min_50.0% Prob": 0.8783246344537474, "Min_60.0% Prob": 0.7346390466164074}}
{"hexsha": "9279e491892f6fec20ea72f2810518655dd085b5", "ext": "c", "lang": "C", "content": "int main()\n{\n\tSysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ| SYSCTL_OSC_MAIN);\n    has_lcd_4bitsetup();\n    KeyPad_Lcd_Setup();\n    KeyPad_Setup();\n    while(1)\n    {\n                KeyPad_wait();\n    \t        KeyPad_PassWord_Confirm();\n\n    }\n\n}", "item_id": 0, "repo": "hasan-htp/Real-Time-Password-Security-System", "file": "HAS_Keypad/HAS_Keypad/main.c", "last_update_at": "2018-08-20T21:27:30+00:00", "question_id": "9279e491892f6fec20ea72f2810518655dd085b5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main()\n{\n\tSysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ| SYSCTL_OSC_MAIN);\n    has_lcd_4bitsetup();\n    KeyPad_Lcd_Setup();\n    KeyPad_Setup();\n    while(1)\n    {\n                KeyPad_wait();\n    \t        KeyPad_PassWord_Confirm();\n    }\n"]], "pred": {"ppl": 4.0867085456848145, "ppl_lower": 7.655404090881348, "ppl/lowercase_ppl": -1.4458720895259343, "ppl/zlib": 0.008137224794844156, "Min_5.0% Prob": 9.944051742553711, "Min_10.0% Prob": 8.256207466125488, "Min_20.0% Prob": 5.7163705730438235, "Min_30.0% Prob": 4.383431992015323, "Min_40.0% Prob": 3.430601054430008, "Min_50.0% Prob": 2.8163782639368886, "Min_60.0% Prob": 2.340096389998992}}
{"hexsha": "eef69a4cab424bea5dfdd197756362ccbde9a183", "ext": "c", "lang": "C", "content": "static int\nworker_wrapper(void *arg)\n{\n\tstruct worker_data *w  = arg;\n\tconst bool burst = evt_has_burst_mode(w->dev_id);\n\n\tif (burst)\n\t\treturn order_queue_worker_burst(arg);\n\telse\n\t\treturn order_queue_worker(arg);\n}", "item_id": 3, "repo": "kwame998/jupiter", "file": "dpdk-17.11/app/test-eventdev/test_order_queue.c", "last_update_at": "2018-04-30T05:58:21+00:00", "question_id": "eef69a4cab424bea5dfdd197756362ccbde9a183_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nworker_wrapper(void *arg)\n{\n\tstruct worker_data *w  = arg;\n\tconst bool burst = evt_has_burst_mode(w->dev_id);\n\tif (burst)\n\t\treturn order_queue_worker_burst(arg);\n\telse\n\t\treturn order_queue_worker(arg);\n"]], "pred": {"ppl": 4.241594314575195, "ppl_lower": 4.241594314575195, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.009829518477248021, "Min_5.0% Prob": 9.994840145111084, "Min_10.0% Prob": 8.31220418214798, "Min_20.0% Prob": 5.825669681324678, "Min_30.0% Prob": 4.308711978105398, "Min_40.0% Prob": 3.5001575701376972, "Min_50.0% Prob": 2.858342113189919, "Min_60.0% Prob": 2.400402478014047}}
{"hexsha": "65b20a74f691434a8bef1d74d4dc7b5c9dea48d4", "ext": "c", "lang": "C", "content": "int XIicPs_SetOptions(XIicPs *InstancePtr, u32 Options)\n{\n\tu32 ControlReg;\n\tunsigned int Index;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\tXil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n\tControlReg = XIicPs_ReadReg(InstancePtr->Config.BaseAddress,\n\t\t\t\t      XIICPS_CR_OFFSET);\n\n\t/*\n\t * If repeated start option is requested, set the flag.\n\t * The hold bit in CR will be written by driver when the next transfer\n\t * is initiated.\n\t */\n\tif (Options & XIICPS_REP_START_OPTION) {\n\t\tInstancePtr->IsRepeatedStart = 1;\n\t\tOptions = Options & (~XIICPS_REP_START_OPTION);\n\t}\n\n\t/*\n\t * Loop through the options table, turning the option on.\n\t */\n\tfor (Index = 0; Index < XIICPS_NUM_OPTIONS; Index++) {\n \t\tif (Options & OptionsTable[Index].Option) {\n\t\t\t/*\n\t\t\t * 10-bit option is specially treated, because it is\n\t\t\t * using the 7-bit option, so turning it on means\n\t\t\t * turning 7-bit option off.\n\t\t\t */\n\t\t\tif (OptionsTable[Index].Option &\n\t\t\t\tXIICPS_10_BIT_ADDR_OPTION) {\n\t\t\t\t/* Turn 7-bit off */\n\t\t\t\tControlReg &= ~OptionsTable[Index].Mask;\n \t\t\t} else {\n\t\t\t\t/* Turn 7-bit on */\n\t\t\t\tControlReg |= OptionsTable[Index].Mask;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now write to the control register. Leave it to the upper layers\n\t * to restart the device.\n\t */\n\tXIicPs_WriteReg(InstancePtr->Config.BaseAddress, XIICPS_CR_OFFSET,\n\t\t\t  ControlReg);\n\n\t/*\n\t * Keep a copy of what options this instance has.\n\t */\n\tInstancePtr->Options = XIicPs_GetOptions(InstancePtr);\n\n\treturn XST_SUCCESS;\n}", "item_id": 0, "repo": "kubostech/kubos", "file": "freertos/os/FreeRTOS/Demo/CORTEX_A9_Zynq_ZC702/RTOSDemo_bsp/ps7_cortexa9_0/libsrc/iicps_v2_1/src/xiicps_options.c", "last_update_at": "2018-01-05T00:15:13+00:00", "question_id": "65b20a74f691434a8bef1d74d4dc7b5c9dea48d4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int XIicPs_SetOptions(XIicPs *InstancePtr, u32 Options)\n{\n\tu32 ControlReg;\n\tunsigned int Index;\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\tXil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\tControlReg = XIicPs_ReadReg(InstancePtr->Config.BaseAddress,\n\t\t\t\t      XIICPS_CR_OFFSET);\n\t/*\n\t * If repeated start option is requested, set the flag.\n\t * The hold bit in CR will be written by driver when the next transfer\n\t * is initiated.\n\t */\n\tif (Options & XIICPS_REP_START_OPTION) {\n\t\tInstancePtr->IsRepeatedStart = 1;\n\t\tOptions = Options & (~XIICPS_REP_START_OPTION);\n\t}\n\t/*\n\t * Loop through the options table, turning the option on.\n\t */\n\tfor (Index = 0; Index < XIICPS_NUM_OPTIONS; Index++) {\n \t\tif (Options & OptionsTable[Index].Option) {\n\t\t\t/*\n\t\t\t * 10-bit option is specially treated, because it is\n\t\t\t * using the 7-bit option, so turning it on means\n\t\t\t * turning 7-bit option off.\n\t\t\t */\n\t\t\tif (OptionsTable[Index].Option &\n\t\t\t\tXIICPS_10_BIT_ADDR_OPTION) {\n\t\t\t\t/* Turn 7-bit off */\n\t\t\t\tControlReg &= ~OptionsTable[Index].Mask;\n \t\t\t} else {\n\t\t\t\t/* Turn 7-bit on */\n\t\t\t\tControlReg |= OptionsTable[Index].Mask;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Now write to the control register. Leave it to the upper layers\n\t * to restart the device.\n\t */\n\tXIicPs_WriteReg(InstancePtr->Config.BaseAddress, XIICPS_CR_OFFSET,\n\t\t\t  ControlReg);\n\t/*\n\t * Keep a copy of what options this instance has.\n\t */\n\tInstancePtr->Options = XIicPs_GetOptions(InstancePtr);\n\treturn XST_SUCCESS;\n"]], "pred": {"ppl": 1.934332013130188, "ppl_lower": 2.5346739292144775, "ppl/lowercase_ppl": -1.4096976259255847, "ppl/zlib": 0.000946573965608975, "Min_5.0% Prob": 6.42868299143655, "Min_10.0% Prob": 4.629111143580654, "Min_20.0% Prob": 3.005542067582147, "Min_30.0% Prob": 2.144899450808938, "Min_40.0% Prob": 1.6359871313886871, "Min_50.0% Prob": 1.3180510547611264, "Min_60.0% Prob": 1.1012221059053267}}
{"hexsha": "ca1102ef5f7fb30f08d0b73673f2af49d587b80c", "ext": "c", "lang": "C", "content": "int infra_find_ratelimit(struct infra_cache* infra, uint8_t* name,\n\tsize_t namelen)\n{\n\tint labs = dname_count_labels(name);\n\tstruct domain_limit_data* d = (struct domain_limit_data*)\n\t\tname_tree_lookup(&infra->domain_limits, name, namelen, labs,\n\t\tLDNS_RR_CLASS_IN);\n\tif(!d) return infra_dp_ratelimit;\n\n\tif(d->node.labs == labs && d->lim != -1)\n\t\treturn d->lim; /* exact match */\n\n\t/* find 'below match' */\n\tif(d->node.labs == labs)\n\t\td = (struct domain_limit_data*)d->node.parent;\n\twhile(d) {\n\t\tif(d->below != -1)\n\t\t\treturn d->below;\n\t\td = (struct domain_limit_data*)d->node.parent;\n\t}\n\treturn infra_dp_ratelimit;\n}", "item_id": 20, "repo": "NLnetLabs/unbound.old", "file": "services/cache/infra.c", "last_update_at": "2018-08-21T03:04:10+00:00", "question_id": "ca1102ef5f7fb30f08d0b73673f2af49d587b80c_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int infra_find_ratelimit(struct infra_cache* infra, uint8_t* name,\n\tsize_t namelen)\n{\n\tint labs = dname_count_labels(name);\n\tstruct domain_limit_data* d = (struct domain_limit_data*)\n\t\tname_tree_lookup(&infra->domain_limits, name, namelen, labs,\n\t\tLDNS_RR_CLASS_IN);\n\tif(!d) return infra_dp_ratelimit;\n\tif(d->node.labs == labs && d->lim != -1)\n\t\treturn d->lim; /* exact match */\n\t/* find 'below match' */\n\tif(d->node.labs == labs)\n\t\td = (struct domain_limit_data*)d->node.parent;\n\twhile(d) {\n\t\tif(d->below != -1)\n\t\t\treturn d->below;\n\t\td = (struct domain_limit_data*)d->node.parent;\n\t}\n\treturn infra_dp_ratelimit;\n"]], "pred": {"ppl": 2.4604902267456055, "ppl_lower": 2.507514238357544, "ppl/lowercase_ppl": -1.0210263639875126, "ppl/zlib": 0.00301123949583845, "Min_5.0% Prob": 7.831585627335769, "Min_10.0% Prob": 5.89556176845844, "Min_20.0% Prob": 3.7618186473846436, "Min_30.0% Prob": 2.8287594325934786, "Min_40.0% Prob": 2.206320041896037, "Min_50.0% Prob": 1.7984928312626751, "Min_60.0% Prob": 1.4987237014040444}}
{"hexsha": "56bd2e3833d7189e189358c1dbb5c14ccb1c53c3", "ext": "c", "lang": "C", "content": "void insert_treeEdge_to_dlls(struct s_node *fromv,struct s_node *tov,Edge *e) {\n    \n    if(!fromv || !tov || !e)\n        return;\n    SET_TE(e);\n    \n    if(!fromv->pt1) {\n        fromv->pt1 = e;\n        e->fnext = e->fprev = NULL;\n    }\n    else {\n        e->fnext = fromv->pt1; //place e before fromv's head\n        if(fromv->pt1->from == fromv->key)\n            fromv->pt1->fprev = e; //set fromv's prev pointer to e\n        else\n            fromv->pt1->tprev = e;\n        e->fprev = NULL; //e's prev is null, because first\n        fromv->pt1 = e; //new head is e\n\n\n    }\n    updateTBit_Ins(fromv);\n    /*To Vertex part*/\n    if(!tov->pt1) {\n        tov->pt1 = e;\n        e->tnext = e->tprev = NULL;\n    }\n    else {\n        e->tnext = tov->pt1; //place e before tov's head\n        if(tov->pt1->from == tov->key) \n            tov->pt1->fprev = e;\n        else\n            tov->pt1->tprev = e; //set tov's prev pointer to e\n        e->tprev = NULL; //e's prev is null, because first\n        tov->pt1 = e; //new head is e\n        \n\n    }\n    updateTBit_Ins(tov);\n}", "item_id": 0, "repo": "FrischknechtTobias/Dynamic-Connectivity", "file": "src/dllist.c", "last_update_at": "2018-08-14T15:05:04+00:00", "question_id": "56bd2e3833d7189e189358c1dbb5c14ccb1c53c3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void insert_treeEdge_to_dlls(struct s_node *fromv,struct s_node *tov,Edge *e) {\n    if(!fromv || !tov || !e)\n        return;\n    SET_TE(e);\n    if(!fromv->pt1) {\n        fromv->pt1 = e;\n        e->fnext = e->fprev = NULL;\n    }\n    else {\n        e->fnext = fromv->pt1; //place e before fromv's head\n        if(fromv->pt1->from == fromv->key)\n            fromv->pt1->fprev = e; //set fromv's prev pointer to e\n        else\n            fromv->pt1->tprev = e;\n        e->fprev = NULL; //e's prev is null, because first\n        fromv->pt1 = e; //new head is e\n    }\n    updateTBit_Ins(fromv);\n    /*To Vertex part*/\n    if(!tov->pt1) {\n        tov->pt1 = e;\n        e->tnext = e->tprev = NULL;\n    }\n    else {\n        e->tnext = tov->pt1; //place e before tov's head\n        if(tov->pt1->from == tov->key) \n            tov->pt1->fprev = e;\n        else\n            tov->pt1->tprev = e; //set tov's prev pointer to e\n        e->tprev = NULL; //e's prev is null, because first\n        tov->pt1 = e; //new head is e\n    }\n    updateTBit_Ins(tov);\n"]], "pred": {"ppl": 2.6416025161743164, "ppl_lower": 2.5983870029449463, "ppl/lowercase_ppl": -0.9830192302789552, "ppl/zlib": 0.002625366882979245, "Min_5.0% Prob": 8.193752336502076, "Min_10.0% Prob": 6.411337172112813, "Min_20.0% Prob": 4.247057620301304, "Min_30.0% Prob": 3.11843571547539, "Min_40.0% Prob": 2.4048830044556815, "Min_50.0% Prob": 1.9343672279590884, "Min_60.0% Prob": 1.620051858826993}}
{"hexsha": "73a09de66a4167fe7510b6d84e1e153a61e6ee64", "ext": "c", "lang": "C", "content": "int main(int argc, char **argv)\n{\n\n\n    int fd_out, i;\n    int oflags = O_CREAT | O_WRONLY | O_TRUNC;\n    mode_t mode = S_IRUSR | S_IWUSR;\n    int flag_same = 0;\n\n\n    if(argc < 3){\n        printf(\"Usage: ./fconc.out infile1 infile2 [outfile (default:fconc.out.out)]\\n\");\n        return(2);\n    }\n    else if (argc > 3) {\n\n        for (i=1; i < argc-1; i++){\n            if (!(strcmp(argv[i],argv[argc-1]))) {\n                flag_same = 1;\n                break;\n            }\n        }\n\n        if(flag_same == 1) {\n            printf(\"Warning: The requested output file matches one of the input files. File will be overwritten.\\n\");\n        }\n\n        fd_out = open(\"output_file\", oflags, mode);\n\n        for (i = 1; i < argc - 1; i++) {\n            write_file(fd_out, argv[i]);\n        }\n\n        fd_out = open(argv[argc - 1], oflags, mode);\n        write_file(fd_out, \"output_file\");\n    \tremove(\"output_file\");\n    }\n    else {\n        fd_out = open(\"fconc.out\", oflags, mode);\n        if (fd_out == -1) {\n            perror(\"Open\");\n            exit(1);\n        }\n        for (i = 1; i < argc; i++) {\n            write_file(fd_out, argv[i]);\n        }\n    }\n    return 0;\n}", "item_id": 0, "repo": "steliostss/ntua-os", "file": "askisi1/ask1.2/fconc.c", "last_update_at": "2018-12-28T23:16:09+00:00", "question_id": "73a09de66a4167fe7510b6d84e1e153a61e6ee64_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(int argc, char **argv)\n{\n    int fd_out, i;\n    int oflags = O_CREAT | O_WRONLY | O_TRUNC;\n    mode_t mode = S_IRUSR | S_IWUSR;\n    int flag_same = 0;\n    if(argc < 3){\n        printf(\"Usage: ./fconc.out infile1 infile2 [outfile (default:fconc.out.out)]\\n\");\n        return(2);\n    }\n    else if (argc > 3) {\n        for (i=1; i < argc-1; i++){\n            if (!(strcmp(argv[i],argv[argc-1]))) {\n                flag_same = 1;\n                break;\n            }\n        }\n        if(flag_same == 1) {\n            printf(\"Warning: The requested output file matches one of the input files. File will be overwritten.\\n\");\n        }\n        fd_out = open(\"output_file\", oflags, mode);\n        for (i = 1; i < argc - 1; i++) {\n            write_file(fd_out, argv[i]);\n        }\n        fd_out = open(argv[argc - 1], oflags, mode);\n        write_file(fd_out, \"output_file\");\n    \tremove(\"output_file\");\n    }\n    else {\n        fd_out = open(\"fconc.out\", oflags, mode);\n        if (fd_out == -1) {\n            perror(\"Open\");\n            exit(1);\n        }\n        for (i = 1; i < argc; i++) {\n            write_file(fd_out, argv[i]);\n        }\n    }\n    return 0;\n"]], "pred": {"ppl": 2.0503458976745605, "ppl_lower": 2.1876676082611084, "ppl/lowercase_ppl": -1.0902878543736911, "ppl/zlib": 0.0014865600610556337, "Min_5.0% Prob": 5.917744387279857, "Min_10.0% Prob": 4.411761384540134, "Min_20.0% Prob": 2.9462257676072174, "Min_30.0% Prob": 2.228337465401958, "Min_40.0% Prob": 1.7478659398608156, "Min_50.0% Prob": 1.424717710177016, "Min_60.0% Prob": 1.1920851068059495}}
{"hexsha": "762f91c85ddd2c54584a4f1c7b0c2f0f87ce3840", "ext": "c", "lang": "C", "content": "jobject Tuple_internalCreate(HeapTuple ht, bool mustCopy)\n{\n\tjobject jht;\n\tPtr2Long htH;\n\n\tif(mustCopy)\n\t\tht = heap_copytuple(ht);\n\n\thtH.longVal = 0L; /* ensure that the rest is zeroed out */\n\thtH.ptrVal = ht;\n\tjht = JNI_newObject(s_Tuple_class, s_Tuple_init, htH.longVal);\n\treturn jht;\n}", "item_id": 2, "repo": "YangHao666666/hawq", "file": "src/pl/pljava/src/C/pljava/type/Tuple.c", "last_update_at": "2018-08-30T01:45:36+00:00", "question_id": "762f91c85ddd2c54584a4f1c7b0c2f0f87ce3840_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["jobject Tuple_internalCreate(HeapTuple ht, bool mustCopy)\n{\n\tjobject jht;\n\tPtr2Long htH;\n\tif(mustCopy)\n\t\tht = heap_copytuple(ht);\n\thtH.longVal = 0L; /* ensure that the rest is zeroed out */\n\thtH.ptrVal = ht;\n\tjht = JNI_newObject(s_Tuple_class, s_Tuple_init, htH.longVal);\n\treturn jht;\n"]], "pred": {"ppl": 4.133138656616211, "ppl_lower": 4.839402198791504, "ppl/lowercase_ppl": -1.111169833858466, "ppl/zlib": 0.006855251611729099, "Min_5.0% Prob": 10.243582248687744, "Min_10.0% Prob": 7.81464407994197, "Min_20.0% Prob": 5.473399492410513, "Min_30.0% Prob": 4.229543025677021, "Min_40.0% Prob": 3.380952604688131, "Min_50.0% Prob": 2.7999782910713784, "Min_60.0% Prob": 2.3687831381192574}}
{"hexsha": "a49eb7146e56465cb03867f5af5bd5db3686b85e", "ext": "h", "lang": "C", "content": "const std::string AddNode(const std::string label)\n    {\n        std::string name = \"name\" + std::to_string(NodeCounter);\n        Dot << \"\\\"\" << name << \"\\\" [\\n\"\n               \"label = \" << \"\\\"<f0> \" << label << \"\\\"\\n\"\n               \"shape = \\\"record\\\"\\n\"\n               \"];\" << std::endl;\n        NodeCounter += 1;\n        return name;\n    }", "item_id": 1, "repo": "IKholopov/shishkin_forest", "file": "Framework/DotPrint.h", "last_update_at": "2018-06-20T16:22:31+00:00", "question_id": "a49eb7146e56465cb03867f5af5bd5db3686b85e_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["const std::string AddNode(const std::string label)\n    {\n        std::string name = \"name\" + std::to_string(NodeCounter);\n        Dot << \"\\\"\" << name << \"\\\" [\\n\"\n               \"label = \" << \"\\\"<f0> \" << label << \"\\\"\\n\"\n               \"shape = \\\"record\\\"\\n\"\n               \"];\" << std::endl;\n        NodeCounter += 1;\n        return name;\n"]], "pred": {"ppl": 3.0738604068756104, "ppl_lower": 3.1993701457977295, "ppl/lowercase_ppl": -1.0356385321882933, "ppl/zlib": 0.006490949324737056, "Min_5.0% Prob": 7.151449394226074, "Min_10.0% Prob": 6.005945725874468, "Min_20.0% Prob": 4.463117268952456, "Min_30.0% Prob": 3.432239006866108, "Min_40.0% Prob": 2.7225091457366943, "Min_50.0% Prob": 2.2263157470659776, "Min_60.0% Prob": 1.8734659189076135}}
{"hexsha": "172a1c9ac13998f5cda3279364e0cdeb2042635c", "ext": "c", "lang": "C", "content": "VOID DriverSetInfo(\n    _In_ PROP_OBJECT_INFO *Context,\n    _In_ HWND hwndDlg\n)\n{\n    BOOL                    cond = FALSE, bResult = FALSE, fGroup, bRet;\n    INT                     nEndOfList, nEnd, nStart;\n    DWORD                   i, bytesNeeded, dwServices, dwGroups;\n    LPWSTR                  lpType;\n    SC_HANDLE               SchSCManager = NULL, schService = NULL;\n    LPENUM_SERVICE_STATUS   lpDependencies = NULL;\n    LPQUERY_SERVICE_CONFIG  psci = NULL;\n    LPSERVICE_DESCRIPTION   psd;\n    SERVICE_STATUS_PROCESS  ssp;\n    ENUM_SERVICE_STATUS     ess;\n    WCHAR                   szBuffer[MAX_PATH + 1];\n\n    __try {\n\n        ShowWindow(GetDlgItem(hwndDlg, IDC_QUERYFAIL), FALSE);\n\n        do {\n            SchSCManager = OpenSCManager(\n                NULL,\n                NULL,\n                SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);\n\n            if (SchSCManager == NULL)\n                break;\n\n            schService = OpenService(\n                SchSCManager,\n                Context->lpObjectName,\n                SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS);\n\n            if (schService == NULL)\n                break;\n\n            bytesNeeded = 0;\n            bResult = QueryServiceConfig(\n                schService,\n                NULL,\n                0,\n                &bytesNeeded);\n\n            if ((bResult == FALSE) && (bytesNeeded == 0))\n                break;\n\n            psci = (LPQUERY_SERVICE_CONFIG)supHeapAlloc(bytesNeeded);\n            if (psci == NULL)\n                break;\n\n            //disable comboboxes\n            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDENTSERVICES), FALSE);\n            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE), FALSE);\n            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONGROUP), FALSE);\n\n            bResult = QueryServiceConfig(schService, psci, bytesNeeded, &bytesNeeded);\n            if (bResult) {\n                //set key name (identical to object name)\n                SetDlgItemText(hwndDlg, IDC_SERVICE_KEYNAME, Context->lpObjectName);\n                //set image path info\n                SetDlgItemText(hwndDlg, IDC_SERVICE_IMAGEPATH, psci->lpBinaryPathName);\n                //set display name\n                SetDlgItemText(hwndDlg, IDC_SERVICE_DISPLAYNAME, psci->lpDisplayName);\n                //set load order group\n                SetDlgItemText(hwndDlg, IDC_SERVICE_LOADORDERGROUP, psci->lpLoadOrderGroup);\n\n                //Service Type\n                lpType = T_UnknownType;\n                switch (psci->dwServiceType) {\n                case SERVICE_KERNEL_DRIVER:\n                    lpType = TEXT(\"Kernel-Mode Driver\");\n                    break;\n                case SERVICE_FILE_SYSTEM_DRIVER:\n                    lpType = TEXT(\"File System Driver\");\n                    break;\n                case SERVICE_ADAPTER:\n                    lpType = TEXT(\"Adapter\");\n                    break;\n                case SERVICE_RECOGNIZER_DRIVER:\n                    lpType = TEXT(\"File System Recognizer\");\n                    break;\n                case SERVICE_WIN32_OWN_PROCESS:\n                    lpType = TEXT(\"Own Process\");\n                    break;\n                case SERVICE_WIN32_SHARE_PROCESS:\n                    lpType = TEXT(\"Share Process\");\n                    break;\n                case (SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS):\n                    lpType = TEXT(\"Own Process (Interactive)\");\n                    SetDlgItemText(hwndDlg, ID_SERVICE_NAME, psci->lpServiceStartName);\n                    break;\n                case (SERVICE_WIN32_SHARE_PROCESS | SERVICE_INTERACTIVE_PROCESS):\n                    lpType = TEXT(\"Share Process (Interactive)\");\n                    SetDlgItemText(hwndDlg, ID_SERVICE_NAME, psci->lpServiceStartName);\n                    break;\n                }\n                SetDlgItemText(hwndDlg, ID_SERVICE_TYPE, lpType);\n\n                //Start Type\n                lpType = T_UnknownType;\n                switch (psci->dwStartType) {\n                case SERVICE_AUTO_START:\n                    lpType = TEXT(\"Auto\");\n                    break;\n                case SERVICE_BOOT_START:\n                    lpType = TEXT(\"Boot\");\n                    break;\n                case SERVICE_DEMAND_START:\n                    lpType = TEXT(\"On Demand\");\n                    break;\n                case SERVICE_DISABLED:\n                    lpType = TEXT(\"Disabled\");\n                    break;\n                case SERVICE_SYSTEM_START:\n                    lpType = TEXT(\"System\");\n                    break;\n                }\n                SetDlgItemText(hwndDlg, ID_SERVICE_START, lpType);\n\n                //Error Control\n                lpType = T_Unknown;\n                switch (psci->dwErrorControl) {\n                case SERVICE_ERROR_CRITICAL:\n                    lpType = TEXT(\"Critical\");\n                    break;\n                case SERVICE_ERROR_IGNORE:\n                    lpType = TEXT(\"Ignore\");\n                    break;\n                case SERVICE_ERROR_NORMAL:\n                    lpType = TEXT(\"Normal\");\n                    break;\n                case SERVICE_ERROR_SEVERE:\n                    lpType = TEXT(\"Severe\");\n                    break;\n                }\n                SetDlgItemText(hwndDlg, ID_SERVICE_ERROR, lpType);\n\n                //dwTagId\n                if (psci->dwTagId) {\n                    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));\n                    ultostr(psci->dwTagId, szBuffer);\n                    SetDlgItemText(hwndDlg, ID_SERVICE_TAG, szBuffer);\n                }\n                else {\n                    //not assigned tag\n                    SetDlgItemText(hwndDlg, ID_SERVICE_TAG, L\"\");\n                }\n\n                //State\n                RtlSecureZeroMemory(&ssp, sizeof(ssp));\n                if (QueryServiceStatusEx(schService, SC_STATUS_PROCESS_INFO,\n                    (LPBYTE)&ssp, sizeof(ssp), &bytesNeeded))\n                {\n                    lpType = T_Unknown;\n                    switch (ssp.dwCurrentState) {\n                    case SERVICE_STOPPED:\n                        lpType = TEXT(\"Stopped\");\n                        break;\n                    case SERVICE_START_PENDING:\n                        lpType = TEXT(\"Start Pending\");\n                        break;\n                    case SERVICE_STOP_PENDING:\n                        lpType = TEXT(\"Stop Pending\");\n                        break;\n                    case SERVICE_RUNNING:\n                        lpType = TEXT(\"Running\");\n                        break;\n                    case SERVICE_CONTINUE_PENDING:\n                        lpType = TEXT(\"Continue Pending\");\n                        break;\n                    case SERVICE_PAUSE_PENDING:\n                        lpType = TEXT(\"Pause Pending\");\n                        break;\n                    case SERVICE_PAUSED:\n                        lpType = TEXT(\"Paused\");\n                        break;\n                    }\n                    SetDlgItemText(hwndDlg, ID_SERVICE_CURRENT, lpType);\n                }\n                else {\n                    SetDlgItemText(hwndDlg, ID_SERVICE_CURRENT, T_CannotQuery);\n                }\n\n                //Service Description\n                bRet = FALSE;\n                SetDlgItemText(hwndDlg, ID_SERVICE_DESCRIPTION, L\"\");\n                bytesNeeded = 0x1000;\n                psd = (LPSERVICE_DESCRIPTION)supHeapAlloc(bytesNeeded);\n                if (psd) {\n\n                    bRet = QueryServiceConfig2(\n                        schService,\n                        SERVICE_CONFIG_DESCRIPTION,\n                        (LPBYTE)psd,\n                        bytesNeeded,\n                        &bytesNeeded);\n\n                    if ((bRet == FALSE) && (bytesNeeded != 0)) {\n                        supHeapFree(psd);\n                        psd = (LPSERVICE_DESCRIPTION)supHeapAlloc(bytesNeeded);\n                    }\n                    if (psd) {\n                        //set description or hide window\n                        bRet = QueryServiceConfig2(\n                            schService,\n                            SERVICE_CONFIG_DESCRIPTION,\n                            (LPBYTE)psd,\n                            bytesNeeded,\n                            &bytesNeeded);\n\n                        if (bRet) {\n                            SetDlgItemText(hwndDlg, IDC_SERVICE_DESCRIPTION, psd->lpDescription);\n                        }\n                        supHeapFree(psd);\n                    }\n                }\n                if (bRet == FALSE) {\n                    //not enough memory, hide description window\n                    ShowWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DESCRIPTION), SW_HIDE);\n                }\n\n\n                //Service Dependencies\n                if (psci->lpDependencies) {\n\n                    //first list DependsOnService, DependsOnGroup\n\n                    nEndOfList = 0;\n                    nEnd = 0;\n                    nStart = 0;\n                    dwGroups = 0;\n                    dwServices = 0;\n\n                    //calc total number of symbols\n                    while ((psci->lpDependencies[nEndOfList] != L'\\0') || (psci->lpDependencies[nEndOfList + 1] != L'\\0'))\n                        nEndOfList++;\n\n                    if (nEndOfList > 0) {\n\n                        SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONGROUP, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0);\n                        SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0);\n\n                        //iterate through MULTI_SZ string\n                        do {\n                            while (psci->lpDependencies[nEnd] != TEXT('\\0')) {\n                                nEnd++;\n                            }\n\n                            RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));\n                            //maximum bytes that can be copied is sizeof(szBuffer)\n                            _strncpy(szBuffer, sizeof(szBuffer), &psci->lpDependencies[nStart], nEnd);\n\n                            //check if dependency is a group (has \"+\" before name)\n                            fGroup = (szBuffer[0] == SC_GROUP_IDENTIFIER);\n                            if (fGroup) {\n                                SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONGROUP, CB_ADDSTRING,\n                                    (WPARAM)0, (LPARAM)&szBuffer[1]);\n                                dwGroups++;\n                            }\n                            else {\n                                SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE, CB_ADDSTRING,\n                                    (WPARAM)0, (LPARAM)&szBuffer);\n                                dwServices++;\n                            }\n                            nEnd++;\n                            nStart = nEnd;\n                        } while (nEnd < nEndOfList);\n\n                        //group present, enable combobox\n                        if (dwGroups > 0) {\n                            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONGROUP), TRUE);\n                            SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONGROUP, CB_SETCURSEL,\n                                (WPARAM)0, (LPARAM)0);\n                        }\n                        //service present, enable combobox\n                        if (dwServices > 0) {\n                            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE), TRUE);\n                            SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE, CB_SETCURSEL,\n                                (WPARAM)0, (LPARAM)0);\n                        }\n                    } //if (nEndOfList > 0)\n\n                    //second list services that depends on this service\n                    SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDENTSERVICES, CB_RESETCONTENT,\n                        (WPARAM)0, (LPARAM)0);\n\n                    dwServices = 0;\n                    bytesNeeded = 1024;\n                    bRet = FALSE;\n\n                    //avoid SCM unexpected behaviour by using preallocated buffer\n                    lpDependencies = (LPENUM_SERVICE_STATUS)supHeapAlloc(bytesNeeded);\n                    if (lpDependencies) {\n\n                        bRet = EnumDependentServices(\n                            schService,\n                            SERVICE_STATE_ALL,\n                            lpDependencies,\n                            bytesNeeded,\n                            &bytesNeeded,\n                            &dwServices);\n\n                        if (bRet && (GetLastError() == ERROR_MORE_DATA)) {\n                            //more memory needed for enum\n                            supHeapFree(lpDependencies);\n                            dwServices = 0;\n                            lpDependencies = (LPENUM_SERVICE_STATUS)supHeapAlloc((SIZE_T)bytesNeeded);\n                            if (lpDependencies) {\n\n                                bRet = EnumDependentServices(\n                                    schService,\n                                    SERVICE_STATE_ALL,\n                                    lpDependencies,\n                                    bytesNeeded,\n                                    &bytesNeeded,\n                                    &dwServices);\n\n                            }\n                        }\n\n                        if (lpDependencies) {\n                            //list dependents\n                            if (bRet && dwServices) {\n                                for (i = 0; i < dwServices; i++) {\n                                    ess = *(lpDependencies + i);\n\n                                    SendDlgItemMessage(\n                                        hwndDlg,\n                                        IDC_SERVICE_DEPENDENTSERVICES,\n                                        CB_ADDSTRING,\n                                        (WPARAM)0,\n                                        (LPARAM)ess.lpServiceName);\n                                }\n                                //enable combobox and set current selection to the first item\n                                EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDENTSERVICES), TRUE);\n\n                                SendDlgItemMessage(\n                                    hwndDlg,\n                                    IDC_SERVICE_DEPENDENTSERVICES,\n                                    CB_SETCURSEL,\n                                    (WPARAM)0,\n                                    (LPARAM)0);\n                            }\n                            supHeapFree(lpDependencies);\n                        }\n                    }\n                } //if (psi->lpDependencies)\n            } //bResult != FALSE\n\n            CloseServiceHandle(schService);\n            schService = NULL;\n        } while (cond);\n\n        if (psci != NULL)\n            supHeapFree(psci);\n\n        if (schService)\n            CloseServiceHandle(schService);\n\n        if (SchSCManager)\n            CloseServiceHandle(SchSCManager);\n\n        if (bResult == FALSE) {\n            EnumChildWindows(hwndDlg, DriverShowChildWindows, SW_HIDE);\n            ShowWindow(GetDlgItem(hwndDlg, IDC_QUERYFAIL), SW_SHOW);\n        }\n        else {\n            SetFocus(GetDlgItem(hwndDlg, ID_SERVICE_JUMPTOKEY));\n        }\n\n    }\n    __except (exceptFilter(GetExceptionCode(), GetExceptionInformation())) {\n        EnumChildWindows(hwndDlg, DriverShowChildWindows, SW_HIDE);\n        ShowWindow(GetDlgItem(hwndDlg, IDC_QUERYFAIL), SW_SHOW);\n        return;\n    }\n}", "item_id": 0, "repo": "ralex1975/WinObjEx64", "file": "Source/WinObjEx64/props/propDriver.c", "last_update_at": "2018-12-27T11:43:32+00:00", "question_id": "172a1c9ac13998f5cda3279364e0cdeb2042635c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["VOID DriverSetInfo(\n    _In_ PROP_OBJECT_INFO *Context,\n    _In_ HWND hwndDlg\n)\n{\n    BOOL                    cond = FALSE, bResult = FALSE, fGroup, bRet;\n    INT                     nEndOfList, nEnd, nStart;\n    DWORD                   i, bytesNeeded, dwServices, dwGroups;\n    LPWSTR                  lpType;\n    SC_HANDLE               SchSCManager = NULL, schService = NULL;\n    LPENUM_SERVICE_STATUS   lpDependencies = NULL;\n    LPQUERY_SERVICE_CONFIG  psci = NULL;\n    LPSERVICE_DESCRIPTION   psd;\n    SERVICE_STATUS_PROCESS  ssp;\n    ENUM_SERVICE_STATUS     ess;\n    WCHAR                   szBuffer[MAX_PATH + 1];\n    __try {\n        ShowWindow(GetDlgItem(hwndDlg, IDC_QUERYFAIL), FALSE);\n        do {\n            SchSCManager = OpenSCManager(\n                NULL,\n                NULL,\n                SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);\n            if (SchSCManager == NULL)\n                break;\n            schService = OpenService(\n                SchSCManager,\n                Context->lpObjectName,\n                SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS);\n            if (schService == NULL)\n                break;\n            bytesNeeded = 0;\n            bResult = QueryServiceConfig(\n                schService,\n                NULL,\n                0,\n                &bytesNeeded);\n            if ((bResult == FALSE) && (bytesNeeded == 0))\n                break;\n            psci = (LPQUERY_SERVICE_CONFIG)supHeapAlloc(bytesNeeded);\n            if (psci == NULL)\n                break;\n            //disable comboboxes\n            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDENTSERVICES), FALSE);\n            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE), FALSE);\n            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONGROUP), FALSE);\n            bResult = QueryServiceConfig(schService, psci, bytesNeeded, &bytesNeeded);\n            if (bResult) {\n                //set key name (identical to object name)\n                SetDlgItemText(hwndDlg, IDC_SERVICE_KEYNAME, Context->lpObjectName);\n                //set image path info\n                SetDlgItemText(hwndDlg, IDC_SERVICE_IMAGEPATH, psci->lpBinaryPathName);\n                //set display name\n                SetDlgItemText(hwndDlg, IDC_SERVICE_DISPLAYNAME, psci->lpDisplayName);\n                //set load order group\n                SetDlgItemText(hwndDlg, IDC_SERVICE_LOADORDERGROUP, psci->lpLoadOrderGroup);\n                //Service Type\n                lpType = T_UnknownType;\n                switch (psci->dwServiceType) {\n                case SERVICE_KERNEL_DRIVER:\n                    lpType = TEXT(\"Kernel-Mode Driver\");\n                    break;\n                case SERVICE_FILE_SYSTEM_DRIVER:\n                    lpType = TEXT(\"File System Driver\");\n                    break;\n                case SERVICE_ADAPTER:\n                    lpType = TEXT(\"Adapter\");\n                    break;\n                case SERVICE_RECOGNIZER_DRIVER:\n                    lpType = TEXT(\"File System Recognizer\");\n                    break;\n                case SERVICE_WIN32_OWN_PROCESS:\n                    lpType = TEXT(\"Own Process\");\n                    break;\n                case SERVICE_WIN32_SHARE_PROCESS:\n                    lpType = TEXT(\"Share Process\");\n                    break;\n                case (SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS):\n                    lpType = TEXT(\"Own Process (Interactive)\");\n                    SetDlgItemText(hwndDlg, ID_SERVICE_NAME, psci->lpServiceStartName);\n                    break;\n                case (SERVICE_WIN32_SHARE_PROCESS | SERVICE_INTERACTIVE_PROCESS):\n                    lpType = TEXT(\"Share Process (Interactive)\");\n                    SetDlgItemText(hwndDlg, ID_SERVICE_NAME, psci->lpServiceStartName);\n                    break;\n                }\n                SetDlgItemText(hwndDlg, ID_SERVICE_TYPE, lpType);\n                //Start Type\n                lpType = T_UnknownType;\n                switch (psci->dwStartType) {\n                case SERVICE_AUTO_START:\n                    lpType = TEXT(\"Auto\");\n                    break;\n                case SERVICE_BOOT_START:\n                    lpType = TEXT(\"Boot\");\n                    break;\n                case SERVICE_DEMAND_START:\n                    lpType = TEXT(\"On Demand\");\n                    break;\n                case SERVICE_DISABLED:\n                    lpType = TEXT(\"Disabled\");\n                    break;\n                case SERVICE_SYSTEM_START:\n                    lpType = TEXT(\"System\");\n                    break;\n                }\n                SetDlgItemText(hwndDlg, ID_SERVICE_START, lpType);\n                //Error Control\n                lpType = T_Unknown;\n                switch (psci->dwErrorControl) {\n                case SERVICE_ERROR_CRITICAL:\n                    lpType = TEXT(\"Critical\");\n                    break;\n                case SERVICE_ERROR_IGNORE:\n                    lpType = TEXT(\"Ignore\");\n                    break;\n                case SERVICE_ERROR_NORMAL:\n                    lpType = TEXT(\"Normal\");\n                    break;\n                case SERVICE_ERROR_SEVERE:\n                    lpType = TEXT(\"Severe\");\n                    break;\n                }\n                SetDlgItemText(hwndDlg, ID_SERVICE_ERROR, lpType);\n                //dwTagId\n                if (psci->dwTagId) {\n                    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));\n                    ultostr(psci->dwTagId, szBuffer);\n                    SetDlgItemText(hwndDlg, ID_SERVICE_TAG, szBuffer);\n                }\n                else {\n                    //not assigned tag\n                    SetDlgItemText(hwndDlg, ID_SERVICE_TAG, L\"\");\n                }\n                //State\n                RtlSecureZeroMemory(&ssp, sizeof(ssp));\n                if (QueryServiceStatusEx(schService, SC_STATUS_PROCESS_INFO,\n                    (LPBYTE)&ssp, sizeof(ssp), &bytesNeeded))\n                {\n                    lpType = T_Unknown;\n                    switch (ssp.dwCurrentState) {\n                    case SERVICE_STOPPED:\n                        lpType = TEXT(\"Stopped\");\n                        break;\n                    case SERVICE_START_PENDING:\n                        lpType = TEXT(\"Start Pending\");\n                        break;\n                    case SERVICE_STOP_PENDING:\n                        lpType = TEXT(\"Stop Pending\");\n                        break;\n                    case SERVICE_RUNNING:\n                        lpType = TEXT(\"Running\");\n                        break;\n                    case SERVICE_CONTINUE_PENDING:\n                        lpType = TEXT(\"Continue Pending\");\n                        break;\n                    case SERVICE_PAUSE_PENDING:\n                        lpType = TEXT(\"Pause Pending\");\n                        break;\n                    case SERVICE_PAUSED:\n                        lpType = TEXT(\"Paused\");\n                        break;\n                    }\n                    SetDlgItemText(hwndDlg, ID_SERVICE_CURRENT, lpType);\n                }\n                else {\n                    SetDlgItemText(hwndDlg, ID_SERVICE_CURRENT, T_CannotQuery);\n                }\n                //Service Description\n                bRet = FALSE;\n                SetDlgItemText(hwndDlg, ID_SERVICE_DESCRIPTION, L\"\");\n                bytesNeeded = 0x1000;\n                psd = (LPSERVICE_DESCRIPTION)supHeapAlloc(bytesNeeded);\n                if (psd) {\n                    bRet = QueryServiceConfig2(\n                        schService,\n                        SERVICE_CONFIG_DESCRIPTION,\n                        (LPBYTE)psd,\n                        bytesNeeded,\n                        &bytesNeeded);\n                    if ((bRet == FALSE) && (bytesNeeded != 0)) {\n                        supHeapFree(psd);\n                        psd = (LPSERVICE_DESCRIPTION)supHeapAlloc(bytesNeeded);\n                    }\n                    if (psd) {\n                        //set description or hide window\n                        bRet = QueryServiceConfig2(\n                            schService,\n                            SERVICE_CONFIG_DESCRIPTION,\n                            (LPBYTE)psd,\n                            bytesNeeded,\n                            &bytesNeeded);\n                        if (bRet) {\n                            SetDlgItemText(hwndDlg, IDC_SERVICE_DESCRIPTION, psd->lpDescription);\n                        }\n                        supHeapFree(psd);\n                    }\n                }\n                if (bRet == FALSE) {\n                    //not enough memory, hide description window\n                    ShowWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DESCRIPTION), SW_HIDE);\n                }\n                //Service Dependencies\n                if (psci->lpDependencies) {\n                    //first list DependsOnService, DependsOnGroup\n                    nEndOfList = 0;\n                    nEnd = 0;\n                    nStart = 0;\n                    dwGroups = 0;\n                    dwServices = 0;\n                    //calc total number of symbols\n                    while ((psci->lpDependencies[nEndOfList] != L'\\0') || (psci->lpDependencies[nEndOfList + 1] != L'\\0'))\n                        nEndOfList++;\n                    if (nEndOfList > 0) {\n                        SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONGROUP, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0);\n                        SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0);\n                        //iterate through MULTI_SZ string\n                        do {\n                            while (psci->lpDependencies[nEnd] != TEXT('\\0')) {\n                                nEnd++;\n                            }\n                            RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));\n                            //maximum bytes that can be copied is sizeof(szBuffer)\n                            _strncpy(szBuffer, sizeof(szBuffer), &psci->lpDependencies[nStart], nEnd);\n                            //check if dependency is a group (has \"+\" before name)\n                            fGroup = (szBuffer[0] == SC_GROUP_IDENTIFIER);\n                            if (fGroup) {\n                                SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONGROUP, CB_ADDSTRING,\n                                    (WPARAM)0, (LPARAM)&szBuffer[1]);\n                                dwGroups++;\n                            }\n                            else {\n                                SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE, CB_ADDSTRING,\n                                    (WPARAM)0, (LPARAM)&szBuffer);\n                                dwServices++;\n                            }\n                            nEnd++;\n                            nStart = nEnd;\n                        } while (nEnd < nEndOfList);\n                        //group present, enable combobox\n                        if (dwGroups > 0) {\n                            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONGROUP), TRUE);\n                            SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONGROUP, CB_SETCURSEL,\n                                (WPARAM)0, (LPARAM)0);\n                        }\n                        //service present, enable combobox\n                        if (dwServices > 0) {\n                            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE), TRUE);\n                            SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE, CB_SETCURSEL,\n                                (WPARAM)0, (LPARAM)0);\n                        }\n                    } //if (nEndOfList > 0)\n                    //second list services that depends on this service\n                    SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDENTSERVICES, CB_RESETCONTENT,\n                        (WPARAM)0, (LPARAM)0);\n                    dwServices = 0;\n                    bytesNeeded = 1024;\n                    bRet = FALSE;\n                    //avoid SCM unexpected behaviour by using preallocated buffer\n                    lpDependencies = (LPENUM_SERVICE_STATUS)supHeapAlloc(bytesNeeded);\n                    if (lpDependencies) {\n                        bRet = EnumDependentServices(\n                            schService,\n                            SERVICE_STATE_ALL,\n                            lpDependencies,\n                            bytesNeeded,\n                            &bytesNeeded,\n                            &dwServices);\n                        if (bRet && (GetLastError() == ERROR_MORE_DATA)) {\n                            //more memory needed for enum\n                            supHeapFree(lpDependencies);\n                            dwServices = 0;\n                            lpDependencies = (LPENUM_SERVICE_STATUS)supHeapAlloc((SIZE_T)bytesNeeded);\n                            if (lpDependencies) {\n                                bRet = EnumDependentServices(\n                                    schService,\n                                    SERVICE_STATE_ALL,\n                                    lpDependencies,\n                                    bytesNeeded,\n                                    &bytesNeeded,\n                                    &dwServices);\n                            }\n                        }\n                        if (lpDependencies) {\n                            //list dependents\n                            if (bRet && dwServices) {\n                                for (i = 0; i < dwServices; i++) {\n                                    ess = *(lpDependencies + i);\n                                    SendDlgItemMessage(\n                                        hwndDlg,\n                                        IDC_SERVICE_DEPENDENTSERVICES,\n                                        CB_ADDSTRING,\n                                        (WPARAM)0,\n                                        (LPARAM)ess.lpServiceName);\n                                }\n                                //enable combobox and set current selection to the first item\n                                EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDENTSERVICES), TRUE);\n                                SendDlgItemMessage(\n                                    hwndDlg,\n                                    IDC_SERVICE_DEPENDENTSERVICES,\n                                    CB_SETCURSEL,\n                                    (WPARAM)0,\n                                    (LPARAM)0);\n                            }\n                            supHeapFree(lpDependencies);\n                        }\n                    }\n                } //if (psi->lpDependencies)\n            } //bResult != FALSE\n            CloseServiceHandle(schService);\n            schService = NULL;\n        } while (cond);\n        if (psci != NULL)\n            supHeapFree(psci);\n        if (schService)\n            CloseServiceHandle(schService);\n        if (SchSCManager)\n            CloseServiceHandle(SchSCManager);\n        if (bResult == FALSE) {\n            EnumChildWindows(hwndDlg, DriverShowChildWindows, SW_HIDE);\n            ShowWindow(GetDlgItem(hwndDlg, IDC_QUERYFAIL), SW_SHOW);\n        }\n        else {\n            SetFocus(GetDlgItem(hwndDlg, ID_SERVICE_JUMPTOKEY));\n        }\n    }\n    __except (exceptFilter(GetExceptionCode(), GetExceptionInformation())) {\n        EnumChildWindows(hwndDlg, DriverShowChildWindows, SW_HIDE);\n        ShowWindow(GetDlgItem(hwndDlg, IDC_QUERYFAIL), SW_SHOW);\n        return;\n    }\n"]], "pred": {"ppl": 1.6517601013183594, "ppl_lower": 2.211055278778076, "ppl/lowercase_ppl": -1.5811167198892944, "ppl/zlib": 0.00017000049032321217, "Min_5.0% Prob": 6.020623309939515, "Min_10.0% Prob": 4.120792069855859, "Min_20.0% Prob": 2.4241769937615767, "Min_30.0% Prob": 1.6636687172028948, "Min_40.0% Prob": 1.2525107531505466, "Min_50.0% Prob": 1.0040794439252043, "Min_60.0% Prob": 0.8373695590679927}}
{"hexsha": "ad4b773448d270891e962d3e0e55bac46816639b", "ext": "c", "lang": "C", "content": "void\neventHandler_initialize(jbyte sessionID)\n{\n    jvmtiError error;\n    jint i;\n\n    requestIdCounter = 1;\n    currentSessionID = sessionID;\n\n    /* This is for BEGIN_CALLBACK/END_CALLBACK handling, make sure this\n     *   is done while none of these callbacks are active.\n     */\n    active_callbacks = 0;\n    vm_death_callback_active = JNI_FALSE;\n    callbackLock = debugMonitorCreate(\"JDWP Callback Lock\");\n    callbackBlock = debugMonitorCreate(\"JDWP Callback Block\");\n\n    handlerLock = debugMonitorCreate(\"JDWP Event Handler Lock\");\n\n    for (i = EI_min; i <= EI_max; ++i) {\n        getHandlerChain(i)->first = NULL;\n    }\n\n    /*\n     * Permanently enabled some events.\n     */\n    error = threadControl_setEventMode(JVMTI_ENABLE,\n                                      EI_VM_INIT, NULL);\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't enable vm init events\");\n    }\n    error = threadControl_setEventMode(JVMTI_ENABLE,\n                                      EI_VM_DEATH, NULL);\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't enable vm death events\");\n    }\n    error = threadControl_setEventMode(JVMTI_ENABLE,\n                                      EI_THREAD_START, NULL);\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't enable thread start events\");\n    }\n    error = threadControl_setEventMode(JVMTI_ENABLE,\n                                       EI_THREAD_END, NULL);\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't enable thread end events\");\n    }\n    error = threadControl_setEventMode(JVMTI_ENABLE,\n                                       EI_CLASS_PREPARE, NULL);\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't enable class prepare events\");\n    }\n    error = threadControl_setEventMode(JVMTI_ENABLE,\n                                       EI_GC_FINISH, NULL);\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't enable garbage collection finish events\");\n    }\n\n    (void)memset(&(gdata->callbacks),0,sizeof(gdata->callbacks));\n    /* Event callback for JVMTI_EVENT_SINGLE_STEP */\n    gdata->callbacks.SingleStep                 = &cbSingleStep;\n    /* Event callback for JVMTI_EVENT_BREAKPOINT */\n    gdata->callbacks.Breakpoint                 = &cbBreakpoint;\n    /* Event callback for JVMTI_EVENT_FRAME_POP */\n    gdata->callbacks.FramePop                   = &cbFramePop;\n    /* Event callback for JVMTI_EVENT_EXCEPTION */\n    gdata->callbacks.Exception                  = &cbException;\n    /* Event callback for JVMTI_EVENT_THREAD_START */\n    gdata->callbacks.ThreadStart                = &cbThreadStart;\n    /* Event callback for JVMTI_EVENT_THREAD_END */\n    gdata->callbacks.ThreadEnd                  = &cbThreadEnd;\n    /* Event callback for JVMTI_EVENT_CLASS_PREPARE */\n    gdata->callbacks.ClassPrepare               = &cbClassPrepare;\n    /* Event callback for JVMTI_EVENT_CLASS_LOAD */\n    gdata->callbacks.ClassLoad                  = &cbClassLoad;\n    /* Event callback for JVMTI_EVENT_FIELD_ACCESS */\n    gdata->callbacks.FieldAccess                = &cbFieldAccess;\n    /* Event callback for JVMTI_EVENT_FIELD_MODIFICATION */\n    gdata->callbacks.FieldModification          = &cbFieldModification;\n    /* Event callback for JVMTI_EVENT_EXCEPTION_CATCH */\n    gdata->callbacks.ExceptionCatch             = &cbExceptionCatch;\n    /* Event callback for JVMTI_EVENT_METHOD_ENTRY */\n    gdata->callbacks.MethodEntry                = &cbMethodEntry;\n    /* Event callback for JVMTI_EVENT_METHOD_EXIT */\n    gdata->callbacks.MethodExit                 = &cbMethodExit;\n    /* Event callback for JVMTI_EVENT_MONITOR_CONTENDED_ENTER */\n    gdata->callbacks.MonitorContendedEnter      = &cbMonitorContendedEnter;\n    /* Event callback for JVMTI_EVENT_MONITOR_CONTENDED_ENTERED */\n    gdata->callbacks.MonitorContendedEntered    = &cbMonitorContendedEntered;\n    /* Event callback for JVMTI_EVENT_MONITOR_WAIT */\n    gdata->callbacks.MonitorWait                = &cbMonitorWait;\n    /* Event callback for JVMTI_EVENT_MONITOR_WAITED */\n    gdata->callbacks.MonitorWaited              = &cbMonitorWaited;\n    /* Event callback for JVMTI_EVENT_VM_INIT */\n    gdata->callbacks.VMInit                     = &cbVMInit;\n    /* Event callback for JVMTI_EVENT_VM_DEATH */\n    gdata->callbacks.VMDeath                    = &cbVMDeath;\n    /* Event callback for JVMTI_EVENT_GARBAGE_COLLECTION_FINISH */\n    gdata->callbacks.GarbageCollectionFinish    = &cbGarbageCollectionFinish;\n\n    error = JVMTI_FUNC_PTR(gdata->jvmti,SetEventCallbacks)\n                (gdata->jvmti, &(gdata->callbacks), sizeof(gdata->callbacks));\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't set event callbacks\");\n    }\n\n    /* Notify other modules that the event callbacks are in place */\n    threadControl_onHook();\n\n    /* Get the event helper thread initialized */\n    eventHelper_initialize(sessionID);\n}", "item_id": 37, "repo": "siweilxy/openjdkstudy", "file": "src/jdk.jdwp.agent/share/native/libjdwp/eventHandler.c", "last_update_at": "2018-06-23T10:04:56+00:00", "question_id": "ad4b773448d270891e962d3e0e55bac46816639b_37", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\neventHandler_initialize(jbyte sessionID)\n{\n    jvmtiError error;\n    jint i;\n    requestIdCounter = 1;\n    currentSessionID = sessionID;\n    /* This is for BEGIN_CALLBACK/END_CALLBACK handling, make sure this\n     *   is done while none of these callbacks are active.\n     */\n    active_callbacks = 0;\n    vm_death_callback_active = JNI_FALSE;\n    callbackLock = debugMonitorCreate(\"JDWP Callback Lock\");\n    callbackBlock = debugMonitorCreate(\"JDWP Callback Block\");\n    handlerLock = debugMonitorCreate(\"JDWP Event Handler Lock\");\n    for (i = EI_min; i <= EI_max; ++i) {\n        getHandlerChain(i)->first = NULL;\n    }\n    /*\n     * Permanently enabled some events.\n     */\n    error = threadControl_setEventMode(JVMTI_ENABLE,\n                                      EI_VM_INIT, NULL);\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't enable vm init events\");\n    }\n    error = threadControl_setEventMode(JVMTI_ENABLE,\n                                      EI_VM_DEATH, NULL);\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't enable vm death events\");\n    }\n    error = threadControl_setEventMode(JVMTI_ENABLE,\n                                      EI_THREAD_START, NULL);\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't enable thread start events\");\n    }\n    error = threadControl_setEventMode(JVMTI_ENABLE,\n                                       EI_THREAD_END, NULL);\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't enable thread end events\");\n    }\n    error = threadControl_setEventMode(JVMTI_ENABLE,\n                                       EI_CLASS_PREPARE, NULL);\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't enable class prepare events\");\n    }\n    error = threadControl_setEventMode(JVMTI_ENABLE,\n                                       EI_GC_FINISH, NULL);\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't enable garbage collection finish events\");\n    }\n    (void)memset(&(gdata->callbacks),0,sizeof(gdata->callbacks));\n    /* Event callback for JVMTI_EVENT_SINGLE_STEP */\n    gdata->callbacks.SingleStep                 = &cbSingleStep;\n    /* Event callback for JVMTI_EVENT_BREAKPOINT */\n    gdata->callbacks.Breakpoint                 = &cbBreakpoint;\n    /* Event callback for JVMTI_EVENT_FRAME_POP */\n    gdata->callbacks.FramePop                   = &cbFramePop;\n    /* Event callback for JVMTI_EVENT_EXCEPTION */\n    gdata->callbacks.Exception                  = &cbException;\n    /* Event callback for JVMTI_EVENT_THREAD_START */\n    gdata->callbacks.ThreadStart                = &cbThreadStart;\n    /* Event callback for JVMTI_EVENT_THREAD_END */\n    gdata->callbacks.ThreadEnd                  = &cbThreadEnd;\n    /* Event callback for JVMTI_EVENT_CLASS_PREPARE */\n    gdata->callbacks.ClassPrepare               = &cbClassPrepare;\n    /* Event callback for JVMTI_EVENT_CLASS_LOAD */\n    gdata->callbacks.ClassLoad                  = &cbClassLoad;\n    /* Event callback for JVMTI_EVENT_FIELD_ACCESS */\n    gdata->callbacks.FieldAccess                = &cbFieldAccess;\n    /* Event callback for JVMTI_EVENT_FIELD_MODIFICATION */\n    gdata->callbacks.FieldModification          = &cbFieldModification;\n    /* Event callback for JVMTI_EVENT_EXCEPTION_CATCH */\n    gdata->callbacks.ExceptionCatch             = &cbExceptionCatch;\n    /* Event callback for JVMTI_EVENT_METHOD_ENTRY */\n    gdata->callbacks.MethodEntry                = &cbMethodEntry;\n    /* Event callback for JVMTI_EVENT_METHOD_EXIT */\n    gdata->callbacks.MethodExit                 = &cbMethodExit;\n    /* Event callback for JVMTI_EVENT_MONITOR_CONTENDED_ENTER */\n    gdata->callbacks.MonitorContendedEnter      = &cbMonitorContendedEnter;\n    /* Event callback for JVMTI_EVENT_MONITOR_CONTENDED_ENTERED */\n    gdata->callbacks.MonitorContendedEntered    = &cbMonitorContendedEntered;\n    /* Event callback for JVMTI_EVENT_MONITOR_WAIT */\n    gdata->callbacks.MonitorWait                = &cbMonitorWait;\n    /* Event callback for JVMTI_EVENT_MONITOR_WAITED */\n    gdata->callbacks.MonitorWaited              = &cbMonitorWaited;\n    /* Event callback for JVMTI_EVENT_VM_INIT */\n    gdata->callbacks.VMInit                     = &cbVMInit;\n    /* Event callback for JVMTI_EVENT_VM_DEATH */\n    gdata->callbacks.VMDeath                    = &cbVMDeath;\n    /* Event callback for JVMTI_EVENT_GARBAGE_COLLECTION_FINISH */\n    gdata->callbacks.GarbageCollectionFinish    = &cbGarbageCollectionFinish;\n    error = JVMTI_FUNC_PTR(gdata->jvmti,SetEventCallbacks)\n                (gdata->jvmti, &(gdata->callbacks), sizeof(gdata->callbacks));\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't set event callbacks\");\n    }\n    /* Notify other modules that the event callbacks are in place */\n    threadControl_onHook();\n    /* Get the event helper thread initialized */\n    eventHelper_initialize(sessionID);\n"]], "pred": {"ppl": 1.7571598291397095, "ppl_lower": 1.9499354362487793, "ppl/lowercase_ppl": -1.1846686482579556, "ppl/zlib": 0.0004805616130745177, "Min_5.0% Prob": 6.69371426339243, "Min_10.0% Prob": 4.79134217898051, "Min_20.0% Prob": 2.775110944813373, "Min_30.0% Prob": 1.8791096022571712, "Min_40.0% Prob": 1.408591504111968, "Min_50.0% Prob": 1.1281154489079983, "Min_60.0% Prob": 0.9406194191447499}}
{"hexsha": "be2bfb86925c9e0e8c5d6ce8f63fe00a5e074c4b", "ext": "c", "lang": "C", "content": "SWIGINTERN PyObject *_wrap_gsl_matrix_long_min(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {\n  PyObject *resultobj = 0;\n  gsl_matrix_long *arg1 = (gsl_matrix_long *) 0 ;\n  PyObject * obj0 = 0 ;\n  char *  kwnames[] = {\n    (char *) \"IN\", NULL \n  };\n  double result;\n  \n  \n  PyArrayObject * _PyMatrix1 = NULL;\n  TYPE_VIEW_gsl_matrix_long _matrix1;\n  \n  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)\"O:gsl_matrix_long_min\",kwnames,&obj0)) SWIG_fail;\n  \n  {\n    PyGSL_array_index_t stride;\n    if(PyGSL_MATRIX_CONVERT(obj0, arg1, _PyMatrix1, _matrix1,\n        PyGSL_INPUT_ARRAY, gsl_matrix_long, 1, &stride) != GSL_SUCCESS)\n    goto fail;\t  \n  }\n  \n  result = (double)gsl_matrix_long_min((gsl_matrix_long const *)arg1);\n  resultobj = SWIG_From_double((double)(result));\n  {\n    Py_XDECREF(_PyMatrix1);\n    _PyMatrix1 = NULL;\n    FUNC_MESS_END();\n  }\n  return resultobj;\nfail:\n  {\n    Py_XDECREF(_PyMatrix1);\n    _PyMatrix1 = NULL;\n    FUNC_MESS_END();\n  }\n  return NULL;\n}", "item_id": 161, "repo": "juhnowski/FishingRod", "file": "production/pygsl-0.9.5/swig_src/block_wrap.c", "last_update_at": "2018-10-02T06:18:07+00:00", "question_id": "be2bfb86925c9e0e8c5d6ce8f63fe00a5e074c4b_161", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["SWIGINTERN PyObject *_wrap_gsl_matrix_long_min(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {\n  PyObject *resultobj = 0;\n  gsl_matrix_long *arg1 = (gsl_matrix_long *) 0 ;\n  PyObject * obj0 = 0 ;\n  char *  kwnames[] = {\n    (char *) \"IN\", NULL \n  };\n  double result;\n  PyArrayObject * _PyMatrix1 = NULL;\n  TYPE_VIEW_gsl_matrix_long _matrix1;\n  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)\"O:gsl_matrix_long_min\",kwnames,&obj0)) SWIG_fail;\n  {\n    PyGSL_array_index_t stride;\n    if(PyGSL_MATRIX_CONVERT(obj0, arg1, _PyMatrix1, _matrix1,\n        PyGSL_INPUT_ARRAY, gsl_matrix_long, 1, &stride) != GSL_SUCCESS)\n    goto fail;\t  \n  }\n  result = (double)gsl_matrix_long_min((gsl_matrix_long const *)arg1);\n  resultobj = SWIG_From_double((double)(result));\n  {\n    Py_XDECREF(_PyMatrix1);\n    _PyMatrix1 = NULL;\n    FUNC_MESS_END();\n  }\n  return resultobj;\nfail:\n  {\n    Py_XDECREF(_PyMatrix1);\n    _PyMatrix1 = NULL;\n    FUNC_MESS_END();\n  }\n  return NULL;\n"]], "pred": {"ppl": 3.0398850440979004, "ppl_lower": 4.627533912658691, "ppl/lowercase_ppl": -1.377942928681234, "ppl/zlib": 0.0024013384454895596, "Min_5.0% Prob": 9.64805825551351, "Min_10.0% Prob": 7.5141235673150355, "Min_20.0% Prob": 5.074841771014901, "Min_30.0% Prob": 3.635433721083861, "Min_40.0% Prob": 2.771594225197514, "Min_50.0% Prob": 2.2194881939805597, "Min_60.0% Prob": 1.854914568604615}}
{"hexsha": "931c1bfe92e4796cc96d98227132ec70594d3f37", "ext": "c", "lang": "C", "content": "void frame_picture_mp_p_slice(VideoParameters *p_Vid, InputParameters *p_Inp)\r\n{\r\n  int   rd_pass = 0;\r\n  int   rd_qp = p_Vid->p_curr_frm_struct->qp;\r\n  float rateRatio = 1.0F;\r\n  int   wp_pass=0;\r\n  int   frame_type_pass = 0;\r\n  CodingInfo coding_info;\r\n  FrameCodingMethod best_method = REGULAR; \r\n  int frame_type = P_SLICE; \r\n  int apply_wp = 0;\r\n  int selection;\r\n\r\n  frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);\r\n  store_coding_and_rc_info(p_Vid, &coding_info);\r\n\r\n  if(p_Inp->WPIterMC)\r\n    p_Vid->frameOffsetAvail = 1; \r\n\r\n#if (DBG_IMAGE_MP)\r\n    printf(\"rd_pass = %d: %d (%.0f, %.0f, %.0f)\\n\", rd_pass, \r\n      p_Vid->frame_pic[0]->bits_per_picture, \r\n      p_Vid->frame_pic[0]->distortion.value[0], p_Vid->frame_pic[0]->distortion.value[1], p_Vid->frame_pic[0]->distortion.value[2]);\r\n#endif\r\n\r\n  rd_pass++;\r\n  if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)\r\n  {\r\n    frame_picture_mp_exit(p_Vid, &coding_info);\r\n    return;\r\n  }\r\n\r\n  // for P_Slice, consider WP  \r\n  wp_pass = 0;\r\n  if (p_Inp->GenerateMultiplePPS)\r\n  {\r\n    Slice *dummy_slice = NULL;\r\n\r\n    InitWP(p_Vid, p_Inp, 0);\r\n    if ( p_Inp->WPMCPrecision )\r\n      p_Vid->pWPX->curr_wp_rd_pass = p_Vid->pWPX->wp_rd_passes + 1;\r\n    init_slice_lite(p_Vid, &dummy_slice, 0);\r\n\r\n    if (p_Vid->TestWPPSlice(dummy_slice, 0) == 1)\r\n    {\r\n      // regular WP pass\r\n      p_Vid->active_pps = p_Vid->PicParSet[1];\r\n      if ( p_Inp->WPMCPrecision )\r\n        p_Vid->pWPX->curr_wp_rd_pass->algorithm = WP_REGULAR;\r\n      wp_pass = 1;\r\n    }\r\n    else if ( p_Inp->WPMCPrecision )\r\n    {\r\n      // WPMC pass\r\n      p_Vid->active_pps = p_Vid->PicParSet[1];\r\n      wp_pass = 1;\r\n    }  \r\n\r\n    // The way it is, the code would only reach here if prior conditional using \r\n    // generatemultiplepps is satisfied\r\n    if(wp_pass)\r\n    {\r\n      p_Vid->write_macroblock = FALSE;\r\n      p_Vid->p_curr_frm_struct->qp = p_Vid->qp;\r\n      frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);\r\n      selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);\r\n#if (DBG_IMAGE_MP)\r\n      printf(\"rd_pass = %d, selection = %d\\n\", rd_pass, selection);\r\n#endif\r\n#if (DBG_IMAGE_MP)\r\n      printf(\"rd_pass = %d: %d (%.0f, %.0f, %.0f)\\n\", rd_pass, \r\n        p_Vid->frame_pic[rd_pass]->bits_per_picture, \r\n        p_Vid->frame_pic[rd_pass]->distortion.value[0], p_Vid->frame_pic[rd_pass]->distortion.value[1], p_Vid->frame_pic[rd_pass]->distortion.value[2]);\r\n#endif\r\n\r\n      if (selection)\r\n      {\r\n        swap_frame_buffer(p_Vid, 0, rd_pass); \r\n        store_coding_and_rc_info(p_Vid, &coding_info);\r\n        best_method = EXP_WP;\r\n        apply_wp = 1;\r\n      }\r\n\r\n      if(p_Inp->WPMethod == 0 || p_Inp->WPMCPrecision) \r\n      {\r\n        wp_pass = 0;\r\n        if ( p_Inp->WPMCPrecision )\r\n          p_Vid->pWPX->curr_wp_rd_pass = p_Vid->pWPX->wp_rd_passes + 2;\r\n        if (p_Inp->WPMethod == 0 && p_Vid->TestWPPSlice(dummy_slice, 1) == 1)\r\n        {\r\n          // regular WP pass\r\n          p_Vid->active_pps = p_Vid->PicParSet[1];\r\n          if ( p_Inp->WPMCPrecision )\r\n            p_Vid->pWPX->curr_wp_rd_pass->algorithm = WP_REGULAR;\r\n          wp_pass = 1;\r\n        }\r\n        else if ( p_Inp->WPMCPrecision )\r\n        {\r\n          // WPMC pass\r\n          p_Vid->active_pps = p_Vid->PicParSet[1];\r\n          wp_pass = 1;\r\n        }\r\n\r\n        if(wp_pass)\r\n        {\r\n          p_Vid->write_macroblock = FALSE;\r\n          p_Vid->p_curr_frm_struct->qp = p_Vid->qp;\r\n          free_slice_list(p_Vid->frame_pic[rd_pass]);\r\n          free_storable_picture(p_Vid, p_Vid->enc_frame_picture[rd_pass]);\r\n          frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);\r\n          selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);\r\n#if (DBG_IMAGE_MP)\r\n          printf(\"rd_pass = %d, selection = %d\\n\", rd_pass, selection);\r\n#endif\r\n#if (DBG_IMAGE_MP)\r\n          printf(\"rd_pass = %d: %d (%.0f, %.0f, %.0f)\\n\", rd_pass, \r\n            p_Vid->frame_pic[rd_pass]->bits_per_picture, \r\n            p_Vid->frame_pic[rd_pass]->distortion.value[0], p_Vid->frame_pic[rd_pass]->distortion.value[1], p_Vid->frame_pic[rd_pass]->distortion.value[2]);\r\n#endif\r\n\r\n          if (selection)\r\n          {\r\n            swap_frame_buffer(p_Vid, 0, rd_pass); \r\n            store_coding_and_rc_info(p_Vid, &coding_info);\r\n            best_method = EXP_WP;\r\n            apply_wp = 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      rd_pass++;\r\n      //free_slice(dummy_slice);\r\n\r\n      if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)\r\n      {\r\n        frame_picture_mp_exit(p_Vid, &coding_info);\r\n        free_slice(dummy_slice);\r\n        return;\r\n      }\r\n    }\r\n    free_slice(dummy_slice);\r\n  }\r\n\r\n\r\n  // code as I? or maybe as B?\r\n  frame_type_pass = 0;\r\n  if(p_Inp->RDPSliceITest && (coding_info.intras * 100/p_Vid->FrameSizeInMbs) >= 75)\r\n  {\r\n    frame_type = I_SLICE; \r\n    set_slice_type(p_Vid, p_Inp, I_SLICE);\r\n    populate_frame_slice_type( p_Inp, p_Vid->p_curr_frm_struct, I_SLICE, p_Vid->p_pred->max_num_slices );\r\n    p_Vid->active_pps = p_Vid->PicParSet[0];\r\n    frame_type_pass = 1;\r\n  }\r\n  else if (p_Inp->RDPSliceBTest && p_Vid->active_sps->profile_idc != BASELINE)\r\n  // later need to add some automatic criterion to see if this (coding P as B) may be beneficial \r\n  {\r\n    frame_type = B_SLICE; \r\n    set_slice_type(p_Vid, p_Inp, B_SLICE );\r\n    populate_frame_slice_type( p_Inp, p_Vid->p_curr_frm_struct, B_SLICE, p_Vid->p_pred->max_num_slices );\r\n    p_Vid->active_pps = p_Vid->PicParSet[0];\r\n    frame_type_pass = 1;\r\n  }\r\n\r\n  if(frame_type_pass)\r\n  {\r\n    p_Vid->write_macroblock = FALSE;\r\n    p_Vid->p_curr_frm_struct->qp = p_Vid->qp;\r\n    frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);\r\n    selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);\r\n#if (DBG_IMAGE_MP)\r\n  printf(\"rd_pass = %d, selection = %d\\n\", rd_pass, selection);\r\n#endif\r\n\r\n    if (selection)\r\n    {\r\n      swap_frame_buffer(p_Vid, 0, rd_pass); \r\n      store_coding_and_rc_info(p_Vid, &coding_info);\r\n      best_method = FRAME_TYPE; \r\n    }\r\n    // reset frame_type\r\n    else \r\n      frame_type = P_SLICE;\r\n\r\n    rd_pass++;\r\n    if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)\r\n    {\r\n      frame_picture_mp_exit(p_Vid, &coding_info);\r\n      return;\r\n    }\r\n  }\r\n\r\n  if(p_Vid->EvaluateDBOff)\r\n  {\r\n    // Perform DB off coding pass\r\n    p_Vid->active_pps = (best_method == EXP_WP?p_Vid->PicParSet[1]:p_Vid->PicParSet[0]);\r\n    if(frame_type != P_SLICE)\r\n    {\r\n      set_slice_type(p_Vid, p_Inp, frame_type);\r\n      populate_frame_slice_type( p_Inp, p_Vid->p_curr_frm_struct, frame_type, p_Vid->p_pred->max_num_slices );\r\n    }\r\n    p_Vid->TurnDBOff = 1; \r\n    p_Vid->write_macroblock = FALSE;\r\n    p_Vid->p_curr_frm_struct->qp = p_Vid->qp;\r\n    frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);\r\n    selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);\r\n#if (DBG_IMAGE_MP)\r\n  printf(\"DB OFF, rd_pass = %d, selection = %d\\n\", rd_pass, selection);\r\n#endif\r\n\r\n    if (selection)\r\n    {\r\n      swap_frame_buffer(p_Vid, 0, rd_pass); \r\n      store_coding_and_rc_info(p_Vid, &coding_info);\r\n      best_method = DB_OFF; \r\n    }\r\n\r\n    rd_pass++;\r\n    if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)\r\n    {\r\n      frame_picture_mp_exit(p_Vid, &coding_info);\r\n      return;\r\n    }\r\n  }\r\n\r\n  if(p_Inp->RDPictureFrameQPPSlice)\r\n  {\r\n    // frame QP pass\r\n    p_Vid->active_pps = (apply_wp?p_Vid->PicParSet[1]:p_Vid->PicParSet[0]);\r\n    if(frame_type != P_SLICE)\r\n    {\r\n      set_slice_type(p_Vid, p_Inp, frame_type);\r\n      populate_frame_slice_type( p_Inp, p_Vid->p_curr_frm_struct, I_SLICE, p_Vid->p_pred->max_num_slices );\r\n    }\r\n    p_Vid->qp = (p_Vid->nal_reference_idc==0 ? rd_qp+1:rd_qp-1);\r\n    p_Vid->qp = iClip3( p_Vid->RCMinQP, p_Vid->RCMaxQP, p_Vid->qp );\r\n    if ( p_Inp->RCEnable )\r\n    {\r\n      rateRatio = p_Vid->nal_reference_idc ? 1.15F : 0.85F;\r\n      rc_init_frame_rdpic( p_Vid, p_Inp, rateRatio );\r\n    }\r\n    p_Vid->TurnDBOff = 0;\r\n    p_Vid->write_macroblock = FALSE;\r\n    p_Vid->p_curr_frm_struct->qp = p_Vid->qp;\r\n    frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);\r\n    selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);\r\n#if (DBG_IMAGE_MP)\r\n    printf(\"rd_pass = %d, selection = %d\\n\", rd_pass, selection);\r\n#endif\r\n\r\n    if (selection)\r\n    {\r\n      swap_frame_buffer(p_Vid, 0, rd_pass); \r\n      store_coding_and_rc_info(p_Vid, &coding_info);\r\n      best_method = FRAME_QP;\r\n    }\r\n\r\n    rd_pass++;\r\n    if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)\r\n    {\r\n      frame_picture_mp_exit(p_Vid, &coding_info);\r\n      return;\r\n    }\r\n  }\r\n\r\n  frame_picture_mp_exit(p_Vid, &coding_info);\r\n}", "item_id": 5, "repo": "ratnajitmukherjee/HDRVideoEvaluationFramework", "file": "encoders/jm/lencod/src/image_mp.c", "last_update_at": "2018-07-12T16:29:15+00:00", "question_id": "931c1bfe92e4796cc96d98227132ec70594d3f37_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void frame_picture_mp_p_slice(VideoParameters *p_Vid, InputParameters *p_Inp)\r\n{\r\n  int   rd_pass = 0;\r\n  int   rd_qp = p_Vid->p_curr_frm_struct->qp;\r\n  float rateRatio = 1.0F;\r\n  int   wp_pass=0;\r\n  int   frame_type_pass = 0;\r\n  CodingInfo coding_info;\r\n  FrameCodingMethod best_method = REGULAR; \r\n  int frame_type = P_SLICE; \r\n  int apply_wp = 0;\r\n  int selection;\r\n\r\n  frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);\r\n  store_coding_and_rc_info(p_Vid, &coding_info);\r\n\r\n  if(p_Inp->WPIterMC)\r\n    p_Vid->frameOffsetAvail = 1; \r\n\r\n#if (DBG_IMAGE_MP)\r\n    printf(\"rd_pass = %d: %d (%.0f, %.0f, %.0f)\\n\", rd_pass, \r\n      p_Vid->frame_pic[0]->bits_per_picture, \r\n      p_Vid->frame_pic[0]->distortion.value[0], p_Vid->frame_pic[0]->distortion.value[1], p_Vid->frame_pic[0]->distortion.value[2]);\r\n#endif\r\n\r\n  rd_pass++;\r\n  if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)\r\n  {\r\n    frame_picture_mp_exit(p_Vid, &coding_info);\r\n    return;\r\n  }\r\n\r\n  // for P_Slice, consider WP  \r\n  wp_pass = 0;\r\n  if (p_Inp->GenerateMultiplePPS)\r\n  {\r\n    Slice *dummy_slice = NULL;\r\n\r\n    InitWP(p_Vid, p_Inp, 0);\r\n    if ( p_Inp->WPMCPrecision )\r\n      p_Vid->pWPX->curr_wp_rd_pass = p_Vid->pWPX->wp_rd_passes + 1;\r\n    init_slice_lite(p_Vid, &dummy_slice, 0);\r\n\r\n    if (p_Vid->TestWPPSlice(dummy_slice, 0) == 1)\r\n    {\r\n      // regular WP pass\r\n      p_Vid->active_pps = p_Vid->PicParSet[1];\r\n      if ( p_Inp->WPMCPrecision )\r\n        p_Vid->pWPX->curr_wp_rd_pass->algorithm = WP_REGULAR;\r\n      wp_pass = 1;\r\n    }\r\n    else if ( p_Inp->WPMCPrecision )\r\n    {\r\n      // WPMC pass\r\n      p_Vid->active_pps = p_Vid->PicParSet[1];\r\n      wp_pass = 1;\r\n    }  \r\n\r\n    // The way it is, the code would only reach here if prior conditional using \r\n    // generatemultiplepps is satisfied\r\n    if(wp_pass)\r\n    {\r\n      p_Vid->write_macroblock = FALSE;\r\n      p_Vid->p_curr_frm_struct->qp = p_Vid->qp;\r\n      frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);\r\n      selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);\r\n#if (DBG_IMAGE_MP)\r\n      printf(\"rd_pass = %d, selection = %d\\n\", rd_pass, selection);\r\n#endif\r\n#if (DBG_IMAGE_MP)\r\n      printf(\"rd_pass = %d: %d (%.0f, %.0f, %.0f)\\n\", rd_pass, \r\n        p_Vid->frame_pic[rd_pass]->bits_per_picture, \r\n        p_Vid->frame_pic[rd_pass]->distortion.value[0], p_Vid->frame_pic[rd_pass]->distortion.value[1], p_Vid->frame_pic[rd_pass]->distortion.value[2]);\r\n#endif\r\n\r\n      if (selection)\r\n      {\r\n        swap_frame_buffer(p_Vid, 0, rd_pass); \r\n        store_coding_and_rc_info(p_Vid, &coding_info);\r\n        best_method = EXP_WP;\r\n        apply_wp = 1;\r\n      }\r\n\r\n      if(p_Inp->WPMethod == 0 || p_Inp->WPMCPrecision) \r\n      {\r\n        wp_pass = 0;\r\n        if ( p_Inp->WPMCPrecision )\r\n          p_Vid->pWPX->curr_wp_rd_pass = p_Vid->pWPX->wp_rd_passes + 2;\r\n        if (p_Inp->WPMethod == 0 && p_Vid->TestWPPSlice(dummy_slice, 1) == 1)\r\n        {\r\n          // regular WP pass\r\n          p_Vid->active_pps = p_Vid->PicParSet[1];\r\n          if ( p_Inp->WPMCPrecision )\r\n            p_Vid->pWPX->curr_wp_rd_pass->algorithm = WP_REGULAR;\r\n          wp_pass = 1;\r\n        }\r\n        else if ( p_Inp->WPMCPrecision )\r\n        {\r\n          // WPMC pass\r\n          p_Vid->active_pps = p_Vid->PicParSet[1];\r\n          wp_pass = 1;\r\n        }\r\n\r\n        if(wp_pass)\r\n        {\r\n          p_Vid->write_macroblock = FALSE;\r\n          p_Vid->p_curr_frm_struct->qp = p_Vid->qp;\r\n          free_slice_list(p_Vid->frame_pic[rd_pass]);\r\n          free_storable_picture(p_Vid, p_Vid->enc_frame_picture[rd_pass]);\r\n          frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);\r\n          selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);\r\n#if (DBG_IMAGE_MP)\r\n          printf(\"rd_pass = %d, selection = %d\\n\", rd_pass, selection);\r\n#endif\r\n#if (DBG_IMAGE_MP)\r\n          printf(\"rd_pass = %d: %d (%.0f, %.0f, %.0f)\\n\", rd_pass, \r\n            p_Vid->frame_pic[rd_pass]->bits_per_picture, \r\n            p_Vid->frame_pic[rd_pass]->distortion.value[0], p_Vid->frame_pic[rd_pass]->distortion.value[1], p_Vid->frame_pic[rd_pass]->distortion.value[2]);\r\n#endif\r\n\r\n          if (selection)\r\n          {\r\n            swap_frame_buffer(p_Vid, 0, rd_pass); \r\n            store_coding_and_rc_info(p_Vid, &coding_info);\r\n            best_method = EXP_WP;\r\n            apply_wp = 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      rd_pass++;\r\n      //free_slice(dummy_slice);\r\n\r\n      if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)\r\n      {\r\n        frame_picture_mp_exit(p_Vid, &coding_info);\r\n        free_slice(dummy_slice);\r\n        return;\r\n      }\r\n    }\r\n    free_slice(dummy_slice);\r\n  }\r\n\r\n\r\n  // code as I? or maybe as B?\r\n  frame_type_pass = 0;\r\n  if(p_Inp->RDPSliceITest && (coding_info.intras * 100/p_Vid->FrameSizeInMbs) >= 75)\r\n  {\r\n    frame_type = I_SLICE; \r\n    set_slice_type(p_Vid, p_Inp, I_SLICE);\r\n    populate_frame_slice_type( p_Inp, p_Vid->p_curr_frm_struct, I_SLICE, p_Vid->p_pred->max_num_slices );\r\n    p_Vid->active_pps = p_Vid->PicParSet[0];\r\n    frame_type_pass = 1;\r\n  }\r\n  else if (p_Inp->RDPSliceBTest && p_Vid->active_sps->profile_idc != BASELINE)\r\n  // later need to add some automatic criterion to see if this (coding P as B) may be beneficial \r\n  {\r\n    frame_type = B_SLICE; \r\n    set_slice_type(p_Vid, p_Inp, B_SLICE );\r\n    populate_frame_slice_type( p_Inp, p_Vid->p_curr_frm_struct, B_SLICE, p_Vid->p_pred->max_num_slices );\r\n    p_Vid->active_pps = p_Vid->PicParSet[0];\r\n    frame_type_pass = 1;\r\n  }\r\n\r\n  if(frame_type_pass)\r\n  {\r\n    p_Vid->write_macroblock = FALSE;\r\n    p_Vid->p_curr_frm_struct->qp = p_Vid->qp;\r\n    frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);\r\n    selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);\r\n#if (DBG_IMAGE_MP)\r\n  printf(\"rd_pass = %d, selection = %d\\n\", rd_pass, selection);\r\n#endif\r\n\r\n    if (selection)\r\n    {\r\n      swap_frame_buffer(p_Vid, 0, rd_pass); \r\n      store_coding_and_rc_info(p_Vid, &coding_info);\r\n      best_method = FRAME_TYPE; \r\n    }\r\n    // reset frame_type\r\n    else \r\n      frame_type = P_SLICE;\r\n\r\n    rd_pass++;\r\n    if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)\r\n    {\r\n      frame_picture_mp_exit(p_Vid, &coding_info);\r\n      return;\r\n    }\r\n  }\r\n\r\n  if(p_Vid->EvaluateDBOff)\r\n  {\r\n    // Perform DB off coding pass\r\n    p_Vid->active_pps = (best_method == EXP_WP?p_Vid->PicParSet[1]:p_Vid->PicParSet[0]);\r\n    if(frame_type != P_SLICE)\r\n    {\r\n      set_slice_type(p_Vid, p_Inp, frame_type);\r\n      populate_frame_slice_type( p_Inp, p_Vid->p_curr_frm_struct, frame_type, p_Vid->p_pred->max_num_slices );\r\n    }\r\n    p_Vid->TurnDBOff = 1; \r\n    p_Vid->write_macroblock = FALSE;\r\n    p_Vid->p_curr_frm_struct->qp = p_Vid->qp;\r\n    frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);\r\n    selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);\r\n#if (DBG_IMAGE_MP)\r\n  printf(\"DB OFF, rd_pass = %d, selection = %d\\n\", rd_pass, selection);\r\n#endif\r\n\r\n    if (selection)\r\n    {\r\n      swap_frame_buffer(p_Vid, 0, rd_pass); \r\n      store_coding_and_rc_info(p_Vid, &coding_info);\r\n      best_method = DB_OFF; \r\n    }\r\n\r\n    rd_pass++;\r\n    if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)\r\n    {\r\n      frame_picture_mp_exit(p_Vid, &coding_info);\r\n      return;\r\n    }\r\n  }\r\n\r\n  if(p_Inp->RDPictureFrameQPPSlice)\r\n  {\r\n    // frame QP pass\r\n    p_Vid->active_pps = (apply_wp?p_Vid->PicParSet[1]:p_Vid->PicParSet[0]);\r\n    if(frame_type != P_SLICE)\r\n    {\r\n      set_slice_type(p_Vid, p_Inp, frame_type);\r\n      populate_frame_slice_type( p_Inp, p_Vid->p_curr_frm_struct, I_SLICE, p_Vid->p_pred->max_num_slices );\r\n    }\r\n    p_Vid->qp = (p_Vid->nal_reference_idc==0 ? rd_qp+1:rd_qp-1);\r\n    p_Vid->qp = iClip3( p_Vid->RCMinQP, p_Vid->RCMaxQP, p_Vid->qp );\r\n    if ( p_Inp->RCEnable )\r\n    {\r\n      rateRatio = p_Vid->nal_reference_idc ? 1.15F : 0.85F;\r\n      rc_init_frame_rdpic( p_Vid, p_Inp, rateRatio );\r\n    }\r\n    p_Vid->TurnDBOff = 0;\r\n    p_Vid->write_macroblock = FALSE;\r\n    p_Vid->p_curr_frm_struct->qp = p_Vid->qp;\r\n    frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);\r\n    selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);\r\n#if (DBG_IMAGE_MP)\r\n    printf(\"rd_pass = %d, selection = %d\\n\", rd_pass, selection);\r\n#endif\r\n\r\n    if (selection)\r\n    {\r\n      swap_frame_buffer(p_Vid, 0, rd_pass); \r\n      store_coding_and_rc_info(p_Vid, &coding_info);\r\n      best_method = FRAME_QP;\r\n    }\r\n\r\n    rd_pass++;\r\n    if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)\r\n    {\r\n      frame_picture_mp_exit(p_Vid, &coding_info);\r\n      return;\r\n    }\r\n  }\r\n\r\n  frame_picture_mp_exit(p_Vid, &coding_info);\r\n"]], "pred": {"ppl": 2.907252311706543, "ppl_lower": 3.422187089920044, "ppl/lowercase_ppl": -1.1528018636557953, "ppl/zlib": 0.0006077496653433974, "Min_5.0% Prob": 7.949835964277679, "Min_10.0% Prob": 6.185044342396306, "Min_20.0% Prob": 4.337601806603226, "Min_30.0% Prob": 3.2964485858390535, "Min_40.0% Prob": 2.593975481747998, "Min_50.0% Prob": 2.11752716068419, "Min_60.0% Prob": 1.7778015955431816}}
