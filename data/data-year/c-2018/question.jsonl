{"hexsha": "8e6ec8b4781105359a31470e02995ef7cb2a492b", "ext": "c", "lang": "C", "content": "static int\nBBox_init(polypaths_planar_overrideBBoxObject *self, PyObject *args)\n{\n    assert(polypaths_planar_overrideBBox_Check(self));\n    if (PyTuple_GET_SIZE(args) != 1) {\n        PyErr_SetString(PyExc_TypeError, \n            \"BoundingBox: wrong number of arguments\");\n        return -1;\n    }\n    return BBox_init_from_points(self, PyTuple_GET_ITEM(args, 0));\n}", "item_id": 1, "repo": "apolcyn/polypaths_planar_override", "file": "lib/polypaths_planar_override/cbox.c", "last_update_at": "2018-10-19T00:14:58+00:00", "question_id": "8e6ec8b4781105359a31470e02995ef7cb2a492b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nBBox_init(polypaths_planar_overrideBBoxObject *self, PyObject *args)\n{\n    assert(polypaths_planar_overrideBBox_Check(self));\n    if (PyTuple_GET_SIZE(args) != 1) {\n        PyErr_SetString(PyExc_TypeError, \n            \"BoundingBox: wrong number of arguments\");\n        return -1;\n    }\n    return BBox_init_from_points(self, PyTuple_GET_ITEM(args, 0));\n"]]}
{"hexsha": "038e918cdf95482a81a8134fbac34db19ce67685", "ext": "c", "lang": "C", "content": "unt camellia_decenc_cbc_pad(uchar *newc, uchar *newiv, CAMELLIA_KEY *cmNEWkey, \n                            uchar *oldc, uchar *oldiv, CAMELLIA_KEY *cmOLDkey)\n{\n\tuchar foo[CM_BLOCKSIZE];\n\tunt Byte, pByte;\n\n\t//\u524d\u56de\u306e\u8a70\u3081\u7269\u3092foo[]\u306b\u304b\u304d\u51fa\u3059\u3002\n\tcamellia_decrypt_cbc(foo, oldc, oldiv, cmOLDkey);\n\tByte = foo[CM_BLOCKSIZE-1] & 0x0f;\n\tpByte = CM_BLOCKSIZE - Byte;\n\n\t//\u65b0\u305f\u306b\u8a70\u3081\u7269\u3092\u7528\u610f\n\tcamellia_padding(&foo[Byte], pByte);\n\tfoo[CM_BLOCKSIZE-1] &= 0x0f;\n\tfoo[CM_BLOCKSIZE-1] |= Byte;\n\tcamellia_encrypt_cbc(newc, foo, newiv, cmNEWkey);\n\n\treturn 1;\n}", "item_id": 11, "repo": "umedoblock/fugou", "file": "omoide/src/camellia/camellia_cbc.c", "last_update_at": "2018-12-05T14:37:59+00:00", "question_id": "038e918cdf95482a81a8134fbac34db19ce67685_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unt camellia_decenc_cbc_pad(uchar *newc, uchar *newiv, CAMELLIA_KEY *cmNEWkey, \n                            uchar *oldc, uchar *oldiv, CAMELLIA_KEY *cmOLDkey)\n{\n\tuchar foo[CM_BLOCKSIZE];\n\tunt Byte, pByte;\n\t//\u524d\u56de\u306e\u8a70\u3081\u7269\u3092foo[]\u306b\u304b\u304d\u51fa\u3059\u3002\n\tcamellia_decrypt_cbc(foo, oldc, oldiv, cmOLDkey);\n\tByte = foo[CM_BLOCKSIZE-1] & 0x0f;\n\tpByte = CM_BLOCKSIZE - Byte;\n\t//\u65b0\u305f\u306b\u8a70\u3081\u7269\u3092\u7528\u610f\n\tcamellia_padding(&foo[Byte], pByte);\n\tfoo[CM_BLOCKSIZE-1] &= 0x0f;\n\tfoo[CM_BLOCKSIZE-1] |= Byte;\n\tcamellia_encrypt_cbc(newc, foo, newiv, cmNEWkey);\n\treturn 1;\n"]]}
{"hexsha": "a2f85868afaa0f14a2b41f159db57e10a5cab4f2", "ext": "c", "lang": "C", "content": "void SendDataCPU(void)\n{\n    // Send data to Computer via USB\n    for (kk = 0; kk < 6; kk++)\n    {\n        U1TXREG = varCPU[kk];\n        while(!U1STAbits.TRMT);\n        \n        Nop();\n        Nop();\n        Nop();\n        Nop();\n        Nop();\n        Nop();\n    }\n    for (kk = 0; kk < 30; kk++)\n        Nop();\n}", "item_id": 1, "repo": "moverlin/Kirtley_picogrid", "file": "Software/SSR_Power_Grid/Firmware/Diesel_Generator/MicroChip/Housekeeper/Main_v3_DG_HK.c", "last_update_at": "2018-12-15T01:46:58+00:00", "question_id": "a2f85868afaa0f14a2b41f159db57e10a5cab4f2_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void SendDataCPU(void)\n{\n    // Send data to Computer via USB\n    for (kk = 0; kk < 6; kk++)\n    {\n        U1TXREG = varCPU[kk];\n        while(!U1STAbits.TRMT);\n        Nop();\n        Nop();\n        Nop();\n        Nop();\n        Nop();\n        Nop();\n    }\n    for (kk = 0; kk < 30; kk++)\n        Nop();\n"]]}
{"hexsha": "651b4b2ad6d22f4cb2a2bdb0a7f74b626cbaa118", "ext": "c", "lang": "C", "content": "static void\nsock_send (anidb_session_t *session, char *msg, char *out)\n{\n\tint n;\n\n//\tprintf(\"send: '%s'\\n\", msg);\n\n\tsend(session->socket, msg, strlen(msg) + 1, 0);\n\tn = recv(session->socket, out, 1000, 0);\n\n\tout[n-1] = '\\0';\n\n//\tprintf(\"recv: '%s'\\n\", out);\n}", "item_id": 4, "repo": "chrippa/hashfs", "file": "src/lib/libanidb/anidb.c", "last_update_at": "2018-02-03T19:12:58+00:00", "question_id": "651b4b2ad6d22f4cb2a2bdb0a7f74b626cbaa118_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nsock_send (anidb_session_t *session, char *msg, char *out)\n{\n\tint n;\n//\tprintf(\"send: '%s'\\n\", msg);\n\tsend(session->socket, msg, strlen(msg) + 1, 0);\n\tn = recv(session->socket, out, 1000, 0);\n\tout[n-1] = '\\0';\n//\tprintf(\"recv: '%s'\\n\", out);\n"]]}
{"hexsha": "ecf01cd97c44c1ae60dac30466fdb8b722512bc7", "ext": "h", "lang": "C", "content": "class TOutputFiles {\npublic:\n    TOutputFiles(const NCatboostOptions::TOutputFilesOptions& params,\n                 const TString& namesPrefix) {\n        InitializeFiles(params, namesPrefix);\n    }\n    TString NamesPrefix;\n    TString TimeLeftLogFile;\n    TString LearnErrorLogFile;\n    TString TestErrorLogFile;\n    TString SnapshotFile;\n    TString MetaFile;\n    static TString AlignFilePath(const TString& baseDir, const TString& fileName, const TString& namePrefix = \"\");\n\nprivate:\n    void InitializeFiles(const NCatboostOptions::TOutputFilesOptions& params, const TString& namesPrefix);\n}", "item_id": 1, "repo": "smokarizadeh/catboost", "file": "catboost/libs/algo/learn_context.h", "last_update_at": "2018-08-06T14:13:12+00:00", "question_id": "ecf01cd97c44c1ae60dac30466fdb8b722512bc7_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class TOutputFiles {\npublic:\n    TOutputFiles(const NCatboostOptions::TOutputFilesOptions& params,\n                 const TString& namesPrefix) {\n        InitializeFiles(params, namesPrefix);\n    }\n    TString NamesPrefix;\n    TString TimeLeftLogFile;\n    TString LearnErrorLogFile;\n    TString TestErrorLogFile;\n    TString SnapshotFile;\n    TString MetaFile;\n    static TString AlignFilePath(const TString& baseDir, const TString& fileName, const TString& namePrefix = \"\");\nprivate:\n    void InitializeFiles(const NCatboostOptions::TOutputFilesOptions& params, const TString& namesPrefix);\n"]]}
{"hexsha": "f6b97381f1199f2248acbfb69603c9f4fcd73b4b", "ext": "c", "lang": "C", "content": "int BTESH2_SetAddrDWordTMMU(BTESH2_CpuState *cpu,\n\tbtesh2_vaddr addr, u32 val)\n{\n\tbtesh2_vaddr addr1;\n\n\tif(cpu->status)\n\t\treturn(-1);\n\n\tif(((addr&0x80000000) ||\n\t\t!(BTESH2_GetRegQWord(cpu, BTESH2_REG_MMUCR)&BTESH2_MMUCR_AT)) &&\n\t\t((addr>>29)<6))\n\t{\n\t\treturn(BTESH2_SetAddrDWordFMMU_NoAT_I(cpu, addr, val));\n\t}\n\n\taddr1=BTESH2_TMMU_MapVirtToPhys(cpu, addr);\n\treturn(BTESH2_SetAddrDWordPhy2(cpu, addr1, val));\n}", "item_id": 7, "repo": "cr88192/bgbtech_shxemu", "file": "sh2emu/btesh2/btesh2_tlbmmu.c", "last_update_at": "2018-04-12T20:42:03+00:00", "question_id": "f6b97381f1199f2248acbfb69603c9f4fcd73b4b_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int BTESH2_SetAddrDWordTMMU(BTESH2_CpuState *cpu,\n\tbtesh2_vaddr addr, u32 val)\n{\n\tbtesh2_vaddr addr1;\n\tif(cpu->status)\n\t\treturn(-1);\n\tif(((addr&0x80000000) ||\n\t\t!(BTESH2_GetRegQWord(cpu, BTESH2_REG_MMUCR)&BTESH2_MMUCR_AT)) &&\n\t\t((addr>>29)<6))\n\t{\n\t\treturn(BTESH2_SetAddrDWordFMMU_NoAT_I(cpu, addr, val));\n\t}\n\taddr1=BTESH2_TMMU_MapVirtToPhys(cpu, addr);\n\treturn(BTESH2_SetAddrDWordPhy2(cpu, addr1, val));\n"]]}
{"hexsha": "2ac945f52b3aeabfda5cb9ad4ffa04a99e0ac346", "ext": "c", "lang": "C", "content": "void ED_view3d_distance_set(RegionView3D *rv3d, const float dist)\n{\n\tfloat viewinv[4];\n\tfloat tvec[3];\n\n\tBLI_assert(dist >= 0.0f);\n\n\tcopy_v3_fl3(tvec, 0.0f, 0.0f, rv3d->dist - dist);\n\t/* rv3d->viewinv isn't always valid */\n#if 0\n\tmul_mat3_m4_v3(rv3d->viewinv, tvec);\n#else\n\tinvert_qt_qt_normalized(viewinv, rv3d->viewquat);\n\tmul_qt_v3(viewinv, tvec);\n#endif\n\tsub_v3_v3(rv3d->ofs, tvec);\n\n\trv3d->dist = dist;\n}", "item_id": 122, "repo": "1-MillionParanoidTterabytes/Blender-2.79b-blackened", "file": "source/blender/editors/space_view3d/view3d_edit.c", "last_update_at": "2018-06-18T01:50:32+00:00", "question_id": "2ac945f52b3aeabfda5cb9ad4ffa04a99e0ac346_122", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void ED_view3d_distance_set(RegionView3D *rv3d, const float dist)\n{\n\tfloat viewinv[4];\n\tfloat tvec[3];\n\tBLI_assert(dist >= 0.0f);\n\tcopy_v3_fl3(tvec, 0.0f, 0.0f, rv3d->dist - dist);\n\t/* rv3d->viewinv isn't always valid */\n#if 0\n\tmul_mat3_m4_v3(rv3d->viewinv, tvec);\n#else\n\tinvert_qt_qt_normalized(viewinv, rv3d->viewquat);\n\tmul_qt_v3(viewinv, tvec);\n#endif\n\tsub_v3_v3(rv3d->ofs, tvec);\n\trv3d->dist = dist;\n"]]}
{"hexsha": "0e3beb8a497b19f44113ea931aade6c9a513aae3", "ext": "c", "lang": "C", "content": "int encuentras(char titulo[])\n{\n    int encontrado = 0;\n    actual = primero;\n    while (actual != NULL && encontrado == 0)\n    {\n\n        if (strcmp(titulo, actual->titulo) == 0)\n        {\n            encontrado++;\n        }\n        else\n        {\n            anterior = actual;\n            actual = actual->next;\n        }\n    }\n    return encontrado;\n}", "item_id": 3, "repo": "Am3ra/CS", "file": "CS2/DataStructures/LL/LibroLL.c", "last_update_at": "2018-08-22T20:17:01+00:00", "question_id": "0e3beb8a497b19f44113ea931aade6c9a513aae3_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int encuentras(char titulo[])\n{\n    int encontrado = 0;\n    actual = primero;\n    while (actual != NULL && encontrado == 0)\n    {\n        if (strcmp(titulo, actual->titulo) == 0)\n        {\n            encontrado++;\n        }\n        else\n        {\n            anterior = actual;\n            actual = actual->next;\n        }\n    }\n    return encontrado;\n"]]}
{"hexsha": "6323ef783b9e7c97dfc7c14da3749f0a6e9c7a59", "ext": "h", "lang": "C", "content": "interface GEOCarInfo : PBCodable <NSCopying> {\n\n\tGEOScreenResolution _screenResolution;\n\tint _deviceConnection;\n\tint _interactionModel;\n\tNSString* _manufacturer;\n\tNSString* _model;\n\tSCD_Struct_GE20 _has;\n\n}", "item_id": 0, "repo": "lechium/tvOS10Headers", "file": "System/Library/PrivateFrameworks/GeoServices.framework/GEOCarInfo.h", "last_update_at": "2018-08-04T20:16:32+00:00", "question_id": "6323ef783b9e7c97dfc7c14da3749f0a6e9c7a59_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface GEOCarInfo : PBCodable <NSCopying> {\n\tGEOScreenResolution _screenResolution;\n\tint _deviceConnection;\n\tint _interactionModel;\n\tNSString* _manufacturer;\n\tNSString* _model;\n\tSCD_Struct_GE20 _has;\n"]]}
{"hexsha": "ae95685d3e591be2b22dae3c92e13599823a3e25", "ext": "c", "lang": "C", "content": "static int Audio_Mic1_Mode_Select_Get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tpr_debug(\"%s() mAudio_Analog_Mic1_mode = %d\\n\", __func__, mAudio_Analog_Mic1_mode);\n\tucontrol->value.integer.value[0] = mAudio_Analog_Mic1_mode;\n\treturn 0;\n}", "item_id": 74, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_codec_63xx.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "ae95685d3e591be2b22dae3c92e13599823a3e25_74", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int Audio_Mic1_Mode_Select_Get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tpr_debug(\"%s() mAudio_Analog_Mic1_mode = %d\\n\", __func__, mAudio_Analog_Mic1_mode);\n\tucontrol->value.integer.value[0] = mAudio_Analog_Mic1_mode;\n\treturn 0;\n"]]}
{"hexsha": "fdc67a8897a4a203be3250eeed2dffb8f8aa02ed", "ext": "c", "lang": "C", "content": "Bool XCheckNotMaskEvent (Display *dpy, long mask, XEvent *event)\n{\n\tregister _XQEvent *prev, *qelt;\n\tunsigned long qe_serial = 0;\n\tint n;\t\t\t/* time through count */\n\n        LockDisplay(dpy);\n\tprev = NULL;\n\tfor (n = 3; --n >= 0;) {\n\t    for (qelt = prev ? prev->next : dpy->head;\n\t\t qelt;\n\t\t prev = qelt, qelt = qelt->next) {\n\t\tif (qelt->event.type >= LASTEvent\n                    || !(_Xevent_to_mask[qelt->event.type] & mask)) {\n\t\t    *event = qelt->event;\n\t\t    _XDeq(dpy, prev, qelt);\n\t\t    UnlockDisplay(dpy);\n\t\t    return True;\n\t\t}\n\t    }\n\t    if (prev)\n\t\tqe_serial = prev->qserial_num;\n\t    switch (n) {\n\t      case 2:\n\t\t_XEventsQueued(dpy, QueuedAfterReading);\n\t\tbreak;\n\t      case 1:\n\t\t_XFlush(dpy);\n\t\tbreak;\n\t    }\n\t    if (prev && prev->qserial_num != qe_serial)\n\t\t/* another thread has snatched this event */\n\t\tprev = NULL;\n\t}\n\tUnlockDisplay(dpy);\n\treturn False;\n}", "item_id": 0, "repo": "larsclausen/xglamo", "file": "hw/dmx/input/ChkNotMaskEv.c", "last_update_at": "2018-11-01T06:58:35+00:00", "question_id": "fdc67a8897a4a203be3250eeed2dffb8f8aa02ed_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["Bool XCheckNotMaskEvent (Display *dpy, long mask, XEvent *event)\n{\n\tregister _XQEvent *prev, *qelt;\n\tunsigned long qe_serial = 0;\n\tint n;\t\t\t/* time through count */\n        LockDisplay(dpy);\n\tprev = NULL;\n\tfor (n = 3; --n >= 0;) {\n\t    for (qelt = prev ? prev->next : dpy->head;\n\t\t qelt;\n\t\t prev = qelt, qelt = qelt->next) {\n\t\tif (qelt->event.type >= LASTEvent\n                    || !(_Xevent_to_mask[qelt->event.type] & mask)) {\n\t\t    *event = qelt->event;\n\t\t    _XDeq(dpy, prev, qelt);\n\t\t    UnlockDisplay(dpy);\n\t\t    return True;\n\t\t}\n\t    }\n\t    if (prev)\n\t\tqe_serial = prev->qserial_num;\n\t    switch (n) {\n\t      case 2:\n\t\t_XEventsQueued(dpy, QueuedAfterReading);\n\t\tbreak;\n\t      case 1:\n\t\t_XFlush(dpy);\n\t\tbreak;\n\t    }\n\t    if (prev && prev->qserial_num != qe_serial)\n\t\t/* another thread has snatched this event */\n\t\tprev = NULL;\n\t}\n\tUnlockDisplay(dpy);\n\treturn False;\n"]]}
{"hexsha": "c342a2bd23d35860aab57193cd695a466621ef0c", "ext": "c", "lang": "C", "content": "int main(char argc, char **argv)\n{\n\tint retval = 255;\n\n\tinit_signals();\n\tinit_vars();\n\tparse_args(argc, argv);\n\tinit_shell();\n\tretval = ush_main_loop();\n\tuninit_shell();\n\treturn retval;\n}", "item_id": 3, "repo": "noahb01/ush", "file": "src/main.c", "last_update_at": "2018-02-12T01:49:26+00:00", "question_id": "c342a2bd23d35860aab57193cd695a466621ef0c_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(char argc, char **argv)\n{\n\tint retval = 255;\n\tinit_signals();\n\tinit_vars();\n\tparse_args(argc, argv);\n\tinit_shell();\n\tretval = ush_main_loop();\n\tuninit_shell();\n\treturn retval;\n"]]}
{"hexsha": "c6019705f7fc09fa7f066201c8b3319375bed2ca", "ext": "c", "lang": "C", "content": "static int handle_unrecognized_command(context_t *context)\n{\n    log_write(context->log, \"[%s] received unrecognized command %s at state %s\",\n        context->uuid, context->command, state_string(context->state));\n\n    if (buffer_shift_read_after(&context->in_message, CRLF, sizeof(CRLF) - 1) < 0) {\n        return -1;\n    }\n\n    return BUFFER_TAILQ_PUSH_BACK_STRING(&context->out_message_queue,\n        \"500 Syntax error, command unrecognized\" CRLF);\n}", "item_id": 3, "repo": "elsid/smtp-server", "file": "src/protocol.c", "last_update_at": "2018-01-09T04:36:14+00:00", "question_id": "c6019705f7fc09fa7f066201c8b3319375bed2ca_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int handle_unrecognized_command(context_t *context)\n{\n    log_write(context->log, \"[%s] received unrecognized command %s at state %s\",\n        context->uuid, context->command, state_string(context->state));\n    if (buffer_shift_read_after(&context->in_message, CRLF, sizeof(CRLF) - 1) < 0) {\n        return -1;\n    }\n    return BUFFER_TAILQ_PUSH_BACK_STRING(&context->out_message_queue,\n        \"500 Syntax error, command unrecognized\" CRLF);\n"]]}
{"hexsha": "ce62987c67acf5f3c9afa731f3cda369023a60b9", "ext": "c", "lang": "C", "content": "JNICALL Java_com_mylexz_utils_PrimitiveData_addStrArray\n  (JNIEnv *env, jobject thiz, jstring element, jobjectArray arrStr, jint size){\n\t  jint __desc = __getDescriptor(env, thiz);\n\t  if(__desc == -1)return;\n\t  PDATA *pdata = __content(__current, __desc);\n\t  const char *elem = (*env)->GetStringUTFChars(env, element, 0);\n\t  if(((jint)(*env)->GetArrayLength(env, arrStr)) < size){\n\t  \t(*env)->ReleaseStringUTFChars(env, element, elem);\n\t  \treturn;\n\t  }\n\t  extern int checkExistsElem(char *, FILE *, char *, off_t);\n\t  extern void __passToFile(char *, FILE *, int, int);\n\t  \n\t// Copying pointers from pdata to temp and rdfiles\n\t  FILE* rd = pdata->rd;\n\t  char* temp = pdata->temp;\n\t  int* errnum = &(pdata->errnum);\n\t  off_t offset = ftell(rd);\n\t  if(checkExistsElem(temp, rd, elem, offset)){\n\t\t  fseek(rd, offset, 0);\n\t\t  *errnum = -2;\n\t\t  (*env)->ReleaseStringUTFChars(env, element, elem);\n\t\t  return;\n\t}\n\t// writing first content\n\tfprintf(rd, \"%c%c%s%c\", ID_ARR, STR, elem, BUKA);\n\t// writing content array\n\tsize_t x = 0;\n\tfor (; x < size; x++){\n\t\tjstring a = (jstring) (*env)->GetObjectArrayElement(env, arrStr, x);\n\t\tconst char *n = (*env)->GetStringUTFChars(env, a, 0);\n\t\tstrcpy(temp, n);\n\t\tedStr(temp, ENC);\n\t\t__passToFile(temp, rd, x, size);\n\t\t(*env)->ReleaseStringUTFChars(env, a, n);\n\t}\n    fseek(rd, offset, 0);\n\t*errnum = 0;\n\t(*env)->ReleaseStringUTFChars(env, element, elem);\n\treturn;\n\t  \n  }", "item_id": 51, "repo": "AlexzPurewoko/PANRI", "file": "mylexzlibrary/src/main/c/com_mylexz_utils_PrimitiveData.c", "last_update_at": "2018-09-03T11:58:48+00:00", "question_id": "ce62987c67acf5f3c9afa731f3cda369023a60b9_51", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["JNICALL Java_com_mylexz_utils_PrimitiveData_addStrArray\n  (JNIEnv *env, jobject thiz, jstring element, jobjectArray arrStr, jint size){\n\t  jint __desc = __getDescriptor(env, thiz);\n\t  if(__desc == -1)return;\n\t  PDATA *pdata = __content(__current, __desc);\n\t  const char *elem = (*env)->GetStringUTFChars(env, element, 0);\n\t  if(((jint)(*env)->GetArrayLength(env, arrStr)) < size){\n\t  \t(*env)->ReleaseStringUTFChars(env, element, elem);\n\t  \treturn;\n\t  }\n\t  extern int checkExistsElem(char *, FILE *, char *, off_t);\n\t  extern void __passToFile(char *, FILE *, int, int);\n\t  \n\t// Copying pointers from pdata to temp and rdfiles\n\t  FILE* rd = pdata->rd;\n\t  char* temp = pdata->temp;\n\t  int* errnum = &(pdata->errnum);\n\t  off_t offset = ftell(rd);\n\t  if(checkExistsElem(temp, rd, elem, offset)){\n\t\t  fseek(rd, offset, 0);\n\t\t  *errnum = -2;\n\t\t  (*env)->ReleaseStringUTFChars(env, element, elem);\n\t\t  return;\n\t}\n\t// writing first content\n\tfprintf(rd, \"%c%c%s%c\", ID_ARR, STR, elem, BUKA);\n\t// writing content array\n\tsize_t x = 0;\n\tfor (; x < size; x++){\n\t\tjstring a = (jstring) (*env)->GetObjectArrayElement(env, arrStr, x);\n\t\tconst char *n = (*env)->GetStringUTFChars(env, a, 0);\n\t\tstrcpy(temp, n);\n\t\tedStr(temp, ENC);\n\t\t__passToFile(temp, rd, x, size);\n\t\t(*env)->ReleaseStringUTFChars(env, a, n);\n\t}\n    fseek(rd, offset, 0);\n\t*errnum = 0;\n\t(*env)->ReleaseStringUTFChars(env, element, elem);\n\treturn;\n\t  \n"]]}
{"hexsha": "5706fdf060ecdef7ef541b71b9c1ca2c95dd2181", "ext": "c", "lang": "C", "content": "ssh_string pki_signature_to_blob(const ssh_signature sig)\n{\n    ssh_string sig_blob = NULL;\n\n    switch(sig->type) {\n        case SSH_KEYTYPE_DSS:\n            sig_blob = pki_dsa_signature_to_blob(sig);\n            break;\n        case SSH_KEYTYPE_RSA:\n        case SSH_KEYTYPE_RSA1:\n            sig_blob = ssh_string_copy(sig->rsa_sig);\n            break;\n        case SSH_KEYTYPE_ECDSA:\n#ifdef HAVE_OPENSSL_ECC\n        {\n            ssh_string r;\n            ssh_string s;\n            ssh_buffer b;\n            int rc;\n\n            b = ssh_buffer_new();\n            if (b == NULL) {\n                return NULL;\n            }\n\n            r = make_bignum_string(sig->ecdsa_sig->r);\n            if (r == NULL) {\n                ssh_buffer_free(b);\n                return NULL;\n            }\n            rc = buffer_add_ssh_string(b, r);\n            ssh_string_free(r);\n            if (rc < 0) {\n                ssh_buffer_free(b);\n                return NULL;\n            }\n\n            s = make_bignum_string(sig->ecdsa_sig->s);\n            if (s == NULL) {\n                ssh_buffer_free(b);\n                return NULL;\n            }\n            rc = buffer_add_ssh_string(b, s);\n            ssh_string_free(s);\n            if (rc < 0) {\n                ssh_buffer_free(b);\n                return NULL;\n            }\n\n            sig_blob = ssh_string_new(buffer_get_rest_len(b));\n            if (sig_blob == NULL) {\n                ssh_buffer_free(b);\n                return NULL;\n            }\n\n            ssh_string_fill(sig_blob, buffer_get_rest(b), buffer_get_rest_len(b));\n            ssh_buffer_free(b);\n            break;\n        }\n#endif\n        case SSH_KEYTYPE_ED25519:\n            sig_blob = pki_ed25519_sig_to_blob(sig);\n            break;\n        default:\n        case SSH_KEYTYPE_UNKNOWN:\n            ssh_pki_log(\"Unknown signature key type: %s\", sig->type_c);\n            return NULL;\n    }\n\n    return sig_blob;\n}", "item_id": 16, "repo": "nelyj/tmate", "file": "libssh/src/pki_crypto.c", "last_update_at": "2018-09-09T01:58:52+00:00", "question_id": "5706fdf060ecdef7ef541b71b9c1ca2c95dd2181_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ssh_string pki_signature_to_blob(const ssh_signature sig)\n{\n    ssh_string sig_blob = NULL;\n    switch(sig->type) {\n        case SSH_KEYTYPE_DSS:\n            sig_blob = pki_dsa_signature_to_blob(sig);\n            break;\n        case SSH_KEYTYPE_RSA:\n        case SSH_KEYTYPE_RSA1:\n            sig_blob = ssh_string_copy(sig->rsa_sig);\n            break;\n        case SSH_KEYTYPE_ECDSA:\n#ifdef HAVE_OPENSSL_ECC\n        {\n            ssh_string r;\n            ssh_string s;\n            ssh_buffer b;\n            int rc;\n            b = ssh_buffer_new();\n            if (b == NULL) {\n                return NULL;\n            }\n            r = make_bignum_string(sig->ecdsa_sig->r);\n            if (r == NULL) {\n                ssh_buffer_free(b);\n                return NULL;\n            }\n            rc = buffer_add_ssh_string(b, r);\n            ssh_string_free(r);\n            if (rc < 0) {\n                ssh_buffer_free(b);\n                return NULL;\n            }\n            s = make_bignum_string(sig->ecdsa_sig->s);\n            if (s == NULL) {\n                ssh_buffer_free(b);\n                return NULL;\n            }\n            rc = buffer_add_ssh_string(b, s);\n            ssh_string_free(s);\n            if (rc < 0) {\n                ssh_buffer_free(b);\n                return NULL;\n            }\n            sig_blob = ssh_string_new(buffer_get_rest_len(b));\n            if (sig_blob == NULL) {\n                ssh_buffer_free(b);\n                return NULL;\n            }\n            ssh_string_fill(sig_blob, buffer_get_rest(b), buffer_get_rest_len(b));\n            ssh_buffer_free(b);\n            break;\n        }\n#endif\n        case SSH_KEYTYPE_ED25519:\n            sig_blob = pki_ed25519_sig_to_blob(sig);\n            break;\n        default:\n        case SSH_KEYTYPE_UNKNOWN:\n            ssh_pki_log(\"Unknown signature key type: %s\", sig->type_c);\n            return NULL;\n    }\n    return sig_blob;\n"]]}
{"hexsha": "46e47df84691c0495963bb51a7c9d498a0413fb9", "ext": "c", "lang": "C", "content": "void process_png_file() {\n\tuint16_t transparent_color=0x0000;\n\n\tprintf(\"uint16_t bitmap[%d][%d] ={\\n\", height, width);\n\tfor(int y = 0; y < height; y++) {\n\t\tprintf(\"{ \");\n\t\tpng_bytep row = row_pointers[y];\n\t\tfor(int x = 0; x < width; x++) {\n\t\t\tpng_bytep px = &(row[x * 4]);\n\t\t\tuint16_t u16col = (px[2]>>3) + ((px[1]>>2)<<5) + ((px[0]>>3)<<11);\n\t\t\tif (0x0000==px[3]) transparent_color = u16col;\n\t\t\t//printf(\"%4d, %4d = RGBA(%3d, %3d, %3d, %3d) = 0x%04X\\n\", x, y, px[0], px[1], px[2], px[3], u16col);\n\t\t\tprintf(\"0x%04X, \", u16col);\n\t\t}\n\t\tprintf(\" },\\n\");\n\t}\n\tprintf(\"};\\nuint16_t transparent_color=0x%04X;\\n\", transparent_color);\n}", "item_id": 1, "repo": "renato-grottesi/microbit", "file": "png2h/png2h.c", "last_update_at": "2018-11-04T18:15:03+00:00", "question_id": "46e47df84691c0495963bb51a7c9d498a0413fb9_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void process_png_file() {\n\tuint16_t transparent_color=0x0000;\n\tprintf(\"uint16_t bitmap[%d][%d] ={\\n\", height, width);\n\tfor(int y = 0; y < height; y++) {\n\t\tprintf(\"{ \");\n\t\tpng_bytep row = row_pointers[y];\n\t\tfor(int x = 0; x < width; x++) {\n\t\t\tpng_bytep px = &(row[x * 4]);\n\t\t\tuint16_t u16col = (px[2]>>3) + ((px[1]>>2)<<5) + ((px[0]>>3)<<11);\n\t\t\tif (0x0000==px[3]) transparent_color = u16col;\n\t\t\t//printf(\"%4d, %4d = RGBA(%3d, %3d, %3d, %3d) = 0x%04X\\n\", x, y, px[0], px[1], px[2], px[3], u16col);\n\t\t\tprintf(\"0x%04X, \", u16col);\n\t\t}\n\t\tprintf(\" },\\n\");\n\t}\n\tprintf(\"};\\nuint16_t transparent_color=0x%04X;\\n\", transparent_color);\n"]]}
{"hexsha": "c1ef6abdafe8ab7afa1c51c45d99971beda7fe5f", "ext": "c", "lang": "C", "content": "void\np6est_coarsen_layers_ext (p6est_t * p6est, int coarsen_recursive,\n                          int callback_orphans,\n                          p6est_coarsen_layer_t coarsen_fn,\n                          p6est_init_t init_fn, p6est_replace_t replace_fn)\n{\n  p4est_t            *columns = p6est->columns;\n  sc_array_t         *layers = p6est->layers;\n  sc_array_t          view;\n  p4est_topidx_t      jt;\n  p4est_tree_t       *tree;\n  sc_array_t         *tquadrants;\n  p4est_quadrant_t   *col;\n  size_t              first, last, zz, count;\n\n  P4EST_GLOBAL_PRODUCTIONF (\"Into p6est_coarsen_layers with %lld total layers\"\n                            \" in %lld total columns\\n\", (long long)\n                            p6est->global_first_layer[p6est->mpisize],\n                            (long long) p6est->columns->global_num_quadrants);\n  p4est_log_indent_push ();\n\n  for (jt = columns->first_local_tree; jt <= columns->last_local_tree; ++jt) {\n    tree = p4est_tree_array_index (columns->trees, jt);\n    tquadrants = &tree->quadrants;\n\n    for (zz = 0; zz < tquadrants->elem_count; ++zz) {\n      col = p4est_quadrant_array_index (tquadrants, zz);\n      P6EST_COLUMN_GET_RANGE (col, &first, &last);\n\n      count = last - first;\n      sc_array_init_view (&view, layers, first, count);\n      p6est_coarsen_all_layers (p6est, jt, col, 0, &view,\n                                coarsen_recursive, callback_orphans,\n                                coarsen_fn, init_fn, replace_fn);\n      P4EST_ASSERT (view.elem_count > 0);\n      P4EST_ASSERT (view.elem_count <= count);\n      last = first + view.elem_count;\n      P6EST_COLUMN_SET_RANGE (col, first, last);\n    }\n  }\n  p6est_compress_columns (p6est);\n  p6est_update_offsets (p6est);\n  P4EST_ASSERT (p6est->user_data_pool->elem_count == layers->elem_count);\n\n  p4est_log_indent_pop ();\n  P4EST_GLOBAL_PRODUCTIONF\n    (\"Done p6est_coarsen_layers with %lld total layers \"\n     \" in %lld total columns\\n\",\n     (long long) p6est->global_first_layer[p6est->mpisize],\n     (long long) p6est->columns->global_num_quadrants);\n}", "item_id": 29, "repo": "jmark/p4wrap", "file": "sites/workstation/gcc/p4est/src/p6est.c", "last_update_at": "2018-06-27T14:29:52+00:00", "question_id": "c1ef6abdafe8ab7afa1c51c45d99971beda7fe5f_29", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\np6est_coarsen_layers_ext (p6est_t * p6est, int coarsen_recursive,\n                          int callback_orphans,\n                          p6est_coarsen_layer_t coarsen_fn,\n                          p6est_init_t init_fn, p6est_replace_t replace_fn)\n{\n  p4est_t            *columns = p6est->columns;\n  sc_array_t         *layers = p6est->layers;\n  sc_array_t          view;\n  p4est_topidx_t      jt;\n  p4est_tree_t       *tree;\n  sc_array_t         *tquadrants;\n  p4est_quadrant_t   *col;\n  size_t              first, last, zz, count;\n  P4EST_GLOBAL_PRODUCTIONF (\"Into p6est_coarsen_layers with %lld total layers\"\n                            \" in %lld total columns\\n\", (long long)\n                            p6est->global_first_layer[p6est->mpisize],\n                            (long long) p6est->columns->global_num_quadrants);\n  p4est_log_indent_push ();\n  for (jt = columns->first_local_tree; jt <= columns->last_local_tree; ++jt) {\n    tree = p4est_tree_array_index (columns->trees, jt);\n    tquadrants = &tree->quadrants;\n    for (zz = 0; zz < tquadrants->elem_count; ++zz) {\n      col = p4est_quadrant_array_index (tquadrants, zz);\n      P6EST_COLUMN_GET_RANGE (col, &first, &last);\n      count = last - first;\n      sc_array_init_view (&view, layers, first, count);\n      p6est_coarsen_all_layers (p6est, jt, col, 0, &view,\n                                coarsen_recursive, callback_orphans,\n                                coarsen_fn, init_fn, replace_fn);\n      P4EST_ASSERT (view.elem_count > 0);\n      P4EST_ASSERT (view.elem_count <= count);\n      last = first + view.elem_count;\n      P6EST_COLUMN_SET_RANGE (col, first, last);\n    }\n  }\n  p6est_compress_columns (p6est);\n  p6est_update_offsets (p6est);\n  P4EST_ASSERT (p6est->user_data_pool->elem_count == layers->elem_count);\n  p4est_log_indent_pop ();\n  P4EST_GLOBAL_PRODUCTIONF\n    (\"Done p6est_coarsen_layers with %lld total layers \"\n     \" in %lld total columns\\n\",\n     (long long) p6est->global_first_layer[p6est->mpisize],\n     (long long) p6est->columns->global_num_quadrants);\n"]]}
{"hexsha": "86a3af82daa645cbeb897ddc2d1fe0d8d3b956f1", "ext": "c", "lang": "C", "content": "static char *test_pc_at_reset_vector_on_init()\n{\n\tmemory = MEM_init();\n\n\t/* Put something into the reset vector */\n\tMEM_write(memory, MEM_RESET_VECTOR, 0x0F);\n\tMEM_write(memory, MEM_RESET_VECTOR + 1, 0x33);\n\n\tcpu = CPU_init(memory);\n\n\tmu_assert(\"PC not set to addr in reset vector\", cpu->PC == 0x330F);\n\n\tCPU_delete(&cpu);\n\treturn 0;\n}", "item_id": 1, "repo": "akydd/nes_emulator", "file": "test_cpu.c", "last_update_at": "2018-03-21T21:39:47+00:00", "question_id": "86a3af82daa645cbeb897ddc2d1fe0d8d3b956f1_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static char *test_pc_at_reset_vector_on_init()\n{\n\tmemory = MEM_init();\n\t/* Put something into the reset vector */\n\tMEM_write(memory, MEM_RESET_VECTOR, 0x0F);\n\tMEM_write(memory, MEM_RESET_VECTOR + 1, 0x33);\n\tcpu = CPU_init(memory);\n\tmu_assert(\"PC not set to addr in reset vector\", cpu->PC == 0x330F);\n\tCPU_delete(&cpu);\n\treturn 0;\n"]]}
{"hexsha": "f8555e125e8c8657d40cf3baaf0ee970e950877b", "ext": "c", "lang": "C", "content": "void spu_cdda_pan(int left_pan, int right_pan) {\n    if(left_pan < 16)\n        left_pan = ~(left_pan - 16);\n\n    left_pan &= 0x1f;\n\n    if(right_pan < 16)\n        right_pan = ~(right_pan - 16);\n\n    right_pan &= 0x1f;\n\n    g2_fifo_wait();\n    g2_write_32(SNDREGADDR(0x2040),\n                (g2_read_32(SNDREGADDR(0x2040)) & ~0xff) | (left_pan << 0));\n    g2_write_32(SNDREGADDR(0x2044),\n                (g2_read_32(SNDREGADDR(0x2044)) & ~0xff) | (right_pan << 0));\n}", "item_id": 7, "repo": "GravisZro/kos", "file": "dreamcast/hardware/spu.c", "last_update_at": "2018-08-14T01:07:53+00:00", "question_id": "f8555e125e8c8657d40cf3baaf0ee970e950877b_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void spu_cdda_pan(int left_pan, int right_pan) {\n    if(left_pan < 16)\n        left_pan = ~(left_pan - 16);\n    left_pan &= 0x1f;\n    if(right_pan < 16)\n        right_pan = ~(right_pan - 16);\n    right_pan &= 0x1f;\n    g2_fifo_wait();\n    g2_write_32(SNDREGADDR(0x2040),\n                (g2_read_32(SNDREGADDR(0x2040)) & ~0xff) | (left_pan << 0));\n    g2_write_32(SNDREGADDR(0x2044),\n                (g2_read_32(SNDREGADDR(0x2044)) & ~0xff) | (right_pan << 0));\n"]]}
{"hexsha": "5fc47f3e5d3b786f5c45c643fc53f60d9b0858bd", "ext": "c", "lang": "C", "content": "Bool VG_(maybe_Z_demangle) ( const HChar* sym, \n                             /*OUT*/HChar* so, Int soLen,\n                             /*OUT*/HChar* fn, Int fnLen,\n                             /*OUT*/Bool* isWrap,\n                             /*OUT*/Int*  eclassTag,\n                             /*OUT*/Int*  eclassPrio )\n{\n#  define EMITSO(ch)                           \\\n      do {                                     \\\n         if (so) {                             \\\n            if (soi >= soLen) {                \\\n               so[soLen-1] = 0; oflow = True;  \\\n            } else {                           \\\n               so[soi++] = ch; so[soi] = 0;    \\\n            }                                  \\\n         }                                     \\\n      } while (0)\n#  define EMITFN(ch)                           \\\n      do {                                     \\\n         if (fni >= fnLen) {                   \\\n            fn[fnLen-1] = 0; oflow = True;     \\\n         } else {                              \\\n            fn[fni++] = ch; fn[fni] = 0;       \\\n         }                                     \\\n      } while (0)\n\n   Bool error, oflow, valid, fn_is_encoded, is_VG_Z_prefixed;\n   Int  soi, fni, i;\n\n   vg_assert(soLen > 0 || (soLen == 0 && so == NULL));\n   vg_assert(fnLen > 0);\n   error = False;\n   oflow = False;\n   soi = 0;\n   fni = 0;\n\n   valid =     sym[0] == '_'\n           &&  sym[1] == 'v'\n           &&  sym[2] == 'g'\n           && (sym[3] == 'r' || sym[3] == 'w')\n           &&  VG_(isdigit)(sym[4])\n           &&  VG_(isdigit)(sym[5])\n           &&  VG_(isdigit)(sym[6])\n           &&  VG_(isdigit)(sym[7])\n           &&  VG_(isdigit)(sym[8])\n           &&  sym[9] == 'Z'\n           && (sym[10] == 'Z' || sym[10] == 'U')\n           &&  sym[11] == '_';\n\n   if (valid\n       && sym[4] == '0' && sym[5] == '0' && sym[6] == '0' && sym[7] == '0'\n       && sym[8] != '0') {\n      /* If the eclass tag is 0000 (meaning \"no eclass\"), the priority\n         must be 0 too. */\n      valid = False;\n   }\n\n   if (!valid)\n      return False;\n\n   fn_is_encoded = sym[10] == 'Z';\n\n   if (isWrap)\n      *isWrap = sym[3] == 'w';\n\n   if (eclassTag) {\n      *eclassTag =    1000 * ((Int)sym[4] - '0')\n                   +  100 * ((Int)sym[5] - '0')\n                   +  10 * ((Int)sym[6] - '0')\n                   +  1 * ((Int)sym[7] - '0');\n      vg_assert(*eclassTag >= 0 && *eclassTag <= 9999);\n   }\n\n   if (eclassPrio) {\n      *eclassPrio = ((Int)sym[8]) - '0';\n      vg_assert(*eclassPrio >= 0 && *eclassPrio <= 9);\n   }\n\n   /* Now check the soname prefix isn't \"VG_Z_\", as described in\n      pub_tool_redir.h. */\n   is_VG_Z_prefixed =\n      sym[12] == 'V' &&\n      sym[13] == 'G' &&\n      sym[14] == '_' &&\n      sym[15] == 'Z' &&\n      sym[16] == '_';\n   if (is_VG_Z_prefixed) {\n      vg_assert2(0, \"symbol with a 'VG_Z_' prefix: %s.\\n\"\n                    \"see pub_tool_redir.h for an explanation.\", sym);\n   }\n\n   /* Now scan the Z-encoded soname. */\n   i = 12;\n   while (True) {\n\n      if (sym[i] == '_')\n      /* Found the delimiter.  Move on to the fnname loop. */\n         break;\n\n      if (sym[i] == 0) {\n         error = True;\n         goto out;\n      }\n\n      if (sym[i] != 'Z') {\n         EMITSO(sym[i]);\n         i++;\n         continue;\n      }\n\n      /* We've got a Z-escape. */\n      i++;\n      switch (sym[i]) {\n         case 'a': EMITSO('*'); break;\n         case 'c': EMITSO(':'); break;\n         case 'd': EMITSO('.'); break;\n         case 'h': EMITSO('-'); break;\n         case 'p': EMITSO('+'); break;\n         case 's': EMITSO(' '); break;\n         case 'u': EMITSO('_'); break;\n         case 'A': EMITSO('@'); break;\n         case 'D': EMITSO('$'); break;\n         case 'L': EMITSO('('); break;\n         case 'R': EMITSO(')'); break;\n         case 'Z': EMITSO('Z'); break;\n         default: error = True; goto out;\n      }\n      i++;\n   }\n\n   vg_assert(sym[i] == '_');\n   i++;\n\n   /* Now deal with the function name part. */\n   if (!fn_is_encoded) {\n\n      /* simple; just copy. */\n      while (True) {\n         if (sym[i] == 0)\n            break;\n         EMITFN(sym[i]);\n         i++;\n      }\n      goto out;\n\n   }\n\n   /* else use a Z-decoding loop like with soname */\n   while (True) {\n\n      if (sym[i] == 0)\n         break;\n\n      if (sym[i] != 'Z') {\n         EMITFN(sym[i]);\n         i++;\n         continue;\n      }\n\n      /* We've got a Z-escape. */\n      i++;\n      switch (sym[i]) {\n         case 'a': EMITFN('*'); break;\n         case 'c': EMITFN(':'); break;\n         case 'd': EMITFN('.'); break;\n         case 'h': EMITFN('-'); break;\n         case 'p': EMITFN('+'); break;\n         case 's': EMITFN(' '); break;\n         case 'u': EMITFN('_'); break;\n         case 'A': EMITFN('@'); break;\n         case 'D': EMITFN('$'); break;\n         case 'L': EMITFN('('); break;\n         case 'R': EMITFN(')'); break;\n         case 'Z': EMITFN('Z'); break;\n         default: error = True; goto out;\n      }\n      i++;\n   }\n\n  out:\n   EMITSO(0);\n   EMITFN(0);\n\n   if (error) {\n      /* Something's wrong.  Give up. */\n      VG_(message)(Vg_UserMsg,\n                   \"m_demangle: error Z-demangling: %s\\n\", sym);\n      return False;\n   }\n   if (oflow) {\n      /* It didn't fit.  Give up. */\n      VG_(message)(Vg_UserMsg,\n                   \"m_demangle: oflow Z-demangling: %s\\n\", sym);\n      return False;\n   }\n\n   return True;\n}", "item_id": 1, "repo": "sjcappella/avalanche", "file": "valgrind/coregrind/m_demangle/demangle.c", "last_update_at": "2018-03-30T15:27:51+00:00", "question_id": "5fc47f3e5d3b786f5c45c643fc53f60d9b0858bd_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["Bool VG_(maybe_Z_demangle) ( const HChar* sym, \n                             /*OUT*/HChar* so, Int soLen,\n                             /*OUT*/HChar* fn, Int fnLen,\n                             /*OUT*/Bool* isWrap,\n                             /*OUT*/Int*  eclassTag,\n                             /*OUT*/Int*  eclassPrio )\n{\n#  define EMITSO(ch)                           \\\n      do {                                     \\\n         if (so) {                             \\\n            if (soi >= soLen) {                \\\n               so[soLen-1] = 0; oflow = True;  \\\n            } else {                           \\\n               so[soi++] = ch; so[soi] = 0;    \\\n            }                                  \\\n         }                                     \\\n      } while (0)\n#  define EMITFN(ch)                           \\\n      do {                                     \\\n         if (fni >= fnLen) {                   \\\n            fn[fnLen-1] = 0; oflow = True;     \\\n         } else {                              \\\n            fn[fni++] = ch; fn[fni] = 0;       \\\n         }                                     \\\n      } while (0)\n   Bool error, oflow, valid, fn_is_encoded, is_VG_Z_prefixed;\n   Int  soi, fni, i;\n   vg_assert(soLen > 0 || (soLen == 0 && so == NULL));\n   vg_assert(fnLen > 0);\n   error = False;\n   oflow = False;\n   soi = 0;\n   fni = 0;\n   valid =     sym[0] == '_'\n           &&  sym[1] == 'v'\n           &&  sym[2] == 'g'\n           && (sym[3] == 'r' || sym[3] == 'w')\n           &&  VG_(isdigit)(sym[4])\n           &&  VG_(isdigit)(sym[5])\n           &&  VG_(isdigit)(sym[6])\n           &&  VG_(isdigit)(sym[7])\n           &&  VG_(isdigit)(sym[8])\n           &&  sym[9] == 'Z'\n           && (sym[10] == 'Z' || sym[10] == 'U')\n           &&  sym[11] == '_';\n   if (valid\n       && sym[4] == '0' && sym[5] == '0' && sym[6] == '0' && sym[7] == '0'\n       && sym[8] != '0') {\n      /* If the eclass tag is 0000 (meaning \"no eclass\"), the priority\n         must be 0 too. */\n      valid = False;\n   }\n   if (!valid)\n      return False;\n   fn_is_encoded = sym[10] == 'Z';\n   if (isWrap)\n      *isWrap = sym[3] == 'w';\n   if (eclassTag) {\n      *eclassTag =    1000 * ((Int)sym[4] - '0')\n                   +  100 * ((Int)sym[5] - '0')\n                   +  10 * ((Int)sym[6] - '0')\n                   +  1 * ((Int)sym[7] - '0');\n      vg_assert(*eclassTag >= 0 && *eclassTag <= 9999);\n   }\n   if (eclassPrio) {\n      *eclassPrio = ((Int)sym[8]) - '0';\n      vg_assert(*eclassPrio >= 0 && *eclassPrio <= 9);\n   }\n   /* Now check the soname prefix isn't \"VG_Z_\", as described in\n      pub_tool_redir.h. */\n   is_VG_Z_prefixed =\n      sym[12] == 'V' &&\n      sym[13] == 'G' &&\n      sym[14] == '_' &&\n      sym[15] == 'Z' &&\n      sym[16] == '_';\n   if (is_VG_Z_prefixed) {\n      vg_assert2(0, \"symbol with a 'VG_Z_' prefix: %s.\\n\"\n                    \"see pub_tool_redir.h for an explanation.\", sym);\n   }\n   /* Now scan the Z-encoded soname. */\n   i = 12;\n   while (True) {\n      if (sym[i] == '_')\n      /* Found the delimiter.  Move on to the fnname loop. */\n         break;\n      if (sym[i] == 0) {\n         error = True;\n         goto out;\n      }\n      if (sym[i] != 'Z') {\n         EMITSO(sym[i]);\n         i++;\n         continue;\n      }\n      /* We've got a Z-escape. */\n      i++;\n      switch (sym[i]) {\n         case 'a': EMITSO('*'); break;\n         case 'c': EMITSO(':'); break;\n         case 'd': EMITSO('.'); break;\n         case 'h': EMITSO('-'); break;\n         case 'p': EMITSO('+'); break;\n         case 's': EMITSO(' '); break;\n         case 'u': EMITSO('_'); break;\n         case 'A': EMITSO('@'); break;\n         case 'D': EMITSO('$'); break;\n         case 'L': EMITSO('('); break;\n         case 'R': EMITSO(')'); break;\n         case 'Z': EMITSO('Z'); break;\n         default: error = True; goto out;\n      }\n      i++;\n   }\n   vg_assert(sym[i] == '_');\n   i++;\n   /* Now deal with the function name part. */\n   if (!fn_is_encoded) {\n      /* simple; just copy. */\n      while (True) {\n         if (sym[i] == 0)\n            break;\n         EMITFN(sym[i]);\n         i++;\n      }\n      goto out;\n   }\n   /* else use a Z-decoding loop like with soname */\n   while (True) {\n      if (sym[i] == 0)\n         break;\n      if (sym[i] != 'Z') {\n         EMITFN(sym[i]);\n         i++;\n         continue;\n      }\n      /* We've got a Z-escape. */\n      i++;\n      switch (sym[i]) {\n         case 'a': EMITFN('*'); break;\n         case 'c': EMITFN(':'); break;\n         case 'd': EMITFN('.'); break;\n         case 'h': EMITFN('-'); break;\n         case 'p': EMITFN('+'); break;\n         case 's': EMITFN(' '); break;\n         case 'u': EMITFN('_'); break;\n         case 'A': EMITFN('@'); break;\n         case 'D': EMITFN('$'); break;\n         case 'L': EMITFN('('); break;\n         case 'R': EMITFN(')'); break;\n         case 'Z': EMITFN('Z'); break;\n         default: error = True; goto out;\n      }\n      i++;\n   }\n  out:\n   EMITSO(0);\n   EMITFN(0);\n   if (error) {\n      /* Something's wrong.  Give up. */\n      VG_(message)(Vg_UserMsg,\n                   \"m_demangle: error Z-demangling: %s\\n\", sym);\n      return False;\n   }\n   if (oflow) {\n      /* It didn't fit.  Give up. */\n      VG_(message)(Vg_UserMsg,\n                   \"m_demangle: oflow Z-demangling: %s\\n\", sym);\n      return False;\n   }\n   return True;\n"]]}
{"hexsha": "0dbfa60e1c29bd15177250bd5caf7d90b9874076", "ext": "c", "lang": "C", "content": "void tdeletechar(int n) {\n  int dst, src, size;\n  Character *line;\n\n  LIMIT(n, 0, terminal.col - terminal.cursor.x);\n\n  dst = terminal.cursor.x;\n  src = terminal.cursor.x + n;\n  size = terminal.col - src;\n  line = terminal.line[terminal.cursor.y];\n\n  memmove(&line[dst], &line[src], size * sizeof(Character));\n  tclearregion(terminal.col - n, terminal.cursor.y, terminal.col - 1,\n               terminal.cursor.y);\n}", "item_id": 34, "repo": "yursha/terminal-emulator", "file": "bw.c", "last_update_at": "2018-08-16T21:11:56+00:00", "question_id": "0dbfa60e1c29bd15177250bd5caf7d90b9874076_34", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void tdeletechar(int n) {\n  int dst, src, size;\n  Character *line;\n  LIMIT(n, 0, terminal.col - terminal.cursor.x);\n  dst = terminal.cursor.x;\n  src = terminal.cursor.x + n;\n  size = terminal.col - src;\n  line = terminal.line[terminal.cursor.y];\n  memmove(&line[dst], &line[src], size * sizeof(Character));\n  tclearregion(terminal.col - n, terminal.cursor.y, terminal.col - 1,\n               terminal.cursor.y);\n"]]}
{"hexsha": "ab98a3da709534dacefa70125230269da8c56f09", "ext": "c", "lang": "C", "content": "void k_uart_console_init(void)\n{\n    KUARTConf conf = k_uart_conf_defaults();\n    conf.baud_rate = K_UART_CONSOLE_BAUDRATE;\n    // TODO: allow more configuration of console UART device\n\n    k_uart_init(K_UART_CONSOLE, &conf);\n}", "item_id": 3, "repo": "srjustice/kubos", "file": "hal/kubos-hal/source/uart.c", "last_update_at": "2018-01-05T00:15:13+00:00", "question_id": "ab98a3da709534dacefa70125230269da8c56f09_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void k_uart_console_init(void)\n{\n    KUARTConf conf = k_uart_conf_defaults();\n    conf.baud_rate = K_UART_CONSOLE_BAUDRATE;\n    // TODO: allow more configuration of console UART device\n    k_uart_init(K_UART_CONSOLE, &conf);\n"]]}
{"hexsha": "4e2870d3c26c76b83261f2ba834f4420335c7950", "ext": "c", "lang": "C", "content": "static HRESULT WINAPI rendertarget_DrawGlyphRun(IDWriteBitmapRenderTarget1 *iface,\n    FLOAT baselineOriginX, FLOAT baselineOriginY, DWRITE_MEASURING_MODE measuring_mode,\n    DWRITE_GLYPH_RUN const* glyph_run, IDWriteRenderingParams* params, COLORREF textColor,\n    RECT *blackbox_rect)\n{\n    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget1(iface);\n    FIXME(\"(%p)->(%f %f %d %p %p 0x%08x %p): stub\\n\", This, baselineOriginX, baselineOriginY,\n        measuring_mode, glyph_run, params, textColor, blackbox_rect);\n    return E_NOTIMPL;\n}", "item_id": 4, "repo": "Svyatpro/winelastd3d10", "file": "dlls/dwrite/gdiinterop.c", "last_update_at": "2018-12-26T05:06:47+00:00", "question_id": "4e2870d3c26c76b83261f2ba834f4420335c7950_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static HRESULT WINAPI rendertarget_DrawGlyphRun(IDWriteBitmapRenderTarget1 *iface,\n    FLOAT baselineOriginX, FLOAT baselineOriginY, DWRITE_MEASURING_MODE measuring_mode,\n    DWRITE_GLYPH_RUN const* glyph_run, IDWriteRenderingParams* params, COLORREF textColor,\n    RECT *blackbox_rect)\n{\n    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget1(iface);\n    FIXME(\"(%p)->(%f %f %d %p %p 0x%08x %p): stub\\n\", This, baselineOriginX, baselineOriginY,\n        measuring_mode, glyph_run, params, textColor, blackbox_rect);\n    return E_NOTIMPL;\n"]]}
{"hexsha": "d923330e171e5ed9091c639b1a62f0351f74c61c", "ext": "c", "lang": "C", "content": "void\nxcwm_window_remove_damage(xcwm_window_t *window)\n{\n    xcb_xfixes_region_t region = xcb_generate_id(window->context->conn);\n    xcb_rectangle_t rect;\n    xcb_void_cookie_t cookie;\n\n    if (!window) {\n        return;\n    }\n\n    rect.x = window->dmg_bounds.x;\n    rect.y = window->dmg_bounds.y;\n    rect.width = window->dmg_bounds.width;\n    rect.height = window->dmg_bounds.height;\n\n    xcb_xfixes_create_region(window->context->conn,\n                             region,\n                             1,\n                             &rect);\n\n    cookie = xcb_damage_subtract_checked(window->context->conn,\n                                         window->damage,\n                                         region,\n                                         0);\n\n    if (!(_xcwm_request_check(window->context->conn, cookie,\n                              \"Failed to subtract damage\"))) {\n        window->dmg_bounds.x = 0;\n        window->dmg_bounds.y = 0;\n        window->dmg_bounds.width = 0;\n        window->dmg_bounds.height = 0;\n    }\n    return;\n}", "item_id": 5, "repo": "jon-turney/libxcwm", "file": "src/libxcwm/window.c", "last_update_at": "2018-11-21T12:42:10+00:00", "question_id": "d923330e171e5ed9091c639b1a62f0351f74c61c_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nxcwm_window_remove_damage(xcwm_window_t *window)\n{\n    xcb_xfixes_region_t region = xcb_generate_id(window->context->conn);\n    xcb_rectangle_t rect;\n    xcb_void_cookie_t cookie;\n    if (!window) {\n        return;\n    }\n    rect.x = window->dmg_bounds.x;\n    rect.y = window->dmg_bounds.y;\n    rect.width = window->dmg_bounds.width;\n    rect.height = window->dmg_bounds.height;\n    xcb_xfixes_create_region(window->context->conn,\n                             region,\n                             1,\n                             &rect);\n    cookie = xcb_damage_subtract_checked(window->context->conn,\n                                         window->damage,\n                                         region,\n                                         0);\n    if (!(_xcwm_request_check(window->context->conn, cookie,\n                              \"Failed to subtract damage\"))) {\n        window->dmg_bounds.x = 0;\n        window->dmg_bounds.y = 0;\n        window->dmg_bounds.width = 0;\n        window->dmg_bounds.height = 0;\n    }\n    return;\n"]]}
{"hexsha": "1912d2b54f9c18bf78cd92c9dcd6a0fbe5beab90", "ext": "c", "lang": "C", "content": "void\ntest__parseGPHDUri__NegativeTestMissingValue(void **state)\n{\n\tchar* uri_missing_value = \"pxf://1.2.3.4:5678/some/path/and/table.tbl?FRAGMENTER=\";\n\n\t/* Setting the test -- code omitted -- */\n\tPG_TRY();\n\t{\n\t\t/* This will throw a ereport(ERROR).*/\n\t\tGPHDUri* parsed = parseGPHDUri(uri_missing_value);\n\t}\n\tPG_CATCH();\n\t{\n\t\tCurrentMemoryContext = 1;\n\t\tErrorData *edata = CopyErrorData();\n\n\t\t/*Validate the type of expected error */\n\t\tassert_true(edata->sqlerrcode == ERRCODE_SYNTAX_ERROR);\n\t\tassert_true(edata->elevel == ERROR);\n\t\tassert_string_equal(edata->message, \"Invalid URI pxf://1.2.3.4:5678/some/path/and/table.tbl?FRAGMENTER=: option 'FRAGMENTER=' missing value after '='\");\n\t\telog_dismiss(INFO);\n\t\treturn;\n\t}\n\tPG_END_TRY();\n\n\tassert_true(false);\n}", "item_id": 8, "repo": "dcomingore/hawq", "file": "src/backend/access/external/test/pxfuriparser_test.c", "last_update_at": "2018-08-30T01:45:36+00:00", "question_id": "1912d2b54f9c18bf78cd92c9dcd6a0fbe5beab90_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\ntest__parseGPHDUri__NegativeTestMissingValue(void **state)\n{\n\tchar* uri_missing_value = \"pxf://1.2.3.4:5678/some/path/and/table.tbl?FRAGMENTER=\";\n\t/* Setting the test -- code omitted -- */\n\tPG_TRY();\n\t{\n\t\t/* This will throw a ereport(ERROR).*/\n\t\tGPHDUri* parsed = parseGPHDUri(uri_missing_value);\n\t}\n\tPG_CATCH();\n\t{\n\t\tCurrentMemoryContext = 1;\n\t\tErrorData *edata = CopyErrorData();\n\t\t/*Validate the type of expected error */\n\t\tassert_true(edata->sqlerrcode == ERRCODE_SYNTAX_ERROR);\n\t\tassert_true(edata->elevel == ERROR);\n\t\tassert_string_equal(edata->message, \"Invalid URI pxf://1.2.3.4:5678/some/path/and/table.tbl?FRAGMENTER=: option 'FRAGMENTER=' missing value after '='\");\n\t\telog_dismiss(INFO);\n\t\treturn;\n\t}\n\tPG_END_TRY();\n\tassert_true(false);\n"]]}
{"hexsha": "bb6da4fce2d7632f3ea07eedd8c087b534314651", "ext": "c", "lang": "C", "content": "static void test4()\n{\n\tchar *m = mm(0, pgsz * 5, PROT_READ|PROT_WRITE);\n\n\tmprotect(m, pgsz, PROT_WRITE);\n\tVALGRIND_CHECK_MEM_IS_DEFINED(m, pgsz); /* OK */\n\tm[44] = 'y';\t\t/* OK */\n\n\tmprotect(m, pgsz*5, PROT_NONE);\n\tm[55] = 'x';\t\t/* permission fault, but no tool complaint */\n}", "item_id": 4, "repo": "sjcappella/avalanche", "file": "valgrind/memcheck/tests/addressable.c", "last_update_at": "2018-03-30T15:27:51+00:00", "question_id": "bb6da4fce2d7632f3ea07eedd8c087b534314651_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void test4()\n{\n\tchar *m = mm(0, pgsz * 5, PROT_READ|PROT_WRITE);\n\tmprotect(m, pgsz, PROT_WRITE);\n\tVALGRIND_CHECK_MEM_IS_DEFINED(m, pgsz); /* OK */\n\tm[44] = 'y';\t\t/* OK */\n\tmprotect(m, pgsz*5, PROT_NONE);\n\tm[55] = 'x';\t\t/* permission fault, but no tool complaint */\n"]]}
{"hexsha": "836f998db7a6e5c204f73097460edde865bbbf6b", "ext": "c", "lang": "C", "content": "void BTSH_Op_FMOV_RegLdR0m_DR(BTESH2_CpuState *cpu, BTESH2_Opcode *op)\n{\n\tcpu->ptcpc=op->pc;\n\tcpu->fregs[op->rn^0]=BTESH2_GetAddrDWord(cpu,\n\t\tcpu->regs[op->rm]+cpu->regs[op->ro]+0);\n\tcpu->fregs[op->rn^1]=BTESH2_GetAddrDWord(cpu,\n\t\tcpu->regs[op->rm]+cpu->regs[op->ro]+4);\n}", "item_id": 61, "repo": "cr88192/bgbtech_shxemu", "file": "sh2emu/btesh2/btesh2_opfpari_0.c", "last_update_at": "2018-04-12T20:42:03+00:00", "question_id": "836f998db7a6e5c204f73097460edde865bbbf6b_61", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void BTSH_Op_FMOV_RegLdR0m_DR(BTESH2_CpuState *cpu, BTESH2_Opcode *op)\n{\n\tcpu->ptcpc=op->pc;\n\tcpu->fregs[op->rn^0]=BTESH2_GetAddrDWord(cpu,\n\t\tcpu->regs[op->rm]+cpu->regs[op->ro]+0);\n\tcpu->fregs[op->rn^1]=BTESH2_GetAddrDWord(cpu,\n\t\tcpu->regs[op->rm]+cpu->regs[op->ro]+4);\n"]]}
{"hexsha": "80574feb01fb1c6b8bde23b18b39b4436b316cbf", "ext": "c", "lang": "C", "content": "static inline UWord ROLW ( UWord w, Int n )\n{\n   Int bpw = 8 * sizeof(UWord);\n   w = (w << n) | (w >> (bpw-n));\n   return w;\n}", "item_id": 3, "repo": "sjcappella/avalanche", "file": "valgrind/coregrind/m_execontext.c", "last_update_at": "2018-03-30T15:27:51+00:00", "question_id": "80574feb01fb1c6b8bde23b18b39b4436b316cbf_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline UWord ROLW ( UWord w, Int n )\n{\n   Int bpw = 8 * sizeof(UWord);\n   w = (w << n) | (w >> (bpw-n));\n   return w;\n"]]}
{"hexsha": "b77ff66e5a2465fd9182441562e417e4d968ffc3", "ext": "c", "lang": "C", "content": "es_result_e\nset_callback_for_userdata(es_read_userdata_cb readcb,\n                          es_write_userdata_cb writecb,\n                          es_free_userdata free_userdata)\n{\n  if (!g_enrollee) {\n    OC_ERR(\"Enrollee is not initialized!\");\n    return ES_ERROR;\n  }\n\n  if (!readcb && !writecb) {\n    OC_ERR(\"Invalid user attributes read/write callback!\");\n    return ES_ERROR;\n  }\n\n  g_enrollee->read_cb = readcb;\n  g_enrollee->write_cb = writecb;\n  g_enrollee->free_userdata = free_userdata;\n  return ES_OK;\n}", "item_id": 7, "repo": "agrkush/iotivity-constrained", "file": "service/easy-setup/enrollee/resourcehandler.c", "last_update_at": "2018-07-19T13:43:52+00:00", "question_id": "b77ff66e5a2465fd9182441562e417e4d968ffc3_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["es_result_e\nset_callback_for_userdata(es_read_userdata_cb readcb,\n                          es_write_userdata_cb writecb,\n                          es_free_userdata free_userdata)\n{\n  if (!g_enrollee) {\n    OC_ERR(\"Enrollee is not initialized!\");\n    return ES_ERROR;\n  }\n  if (!readcb && !writecb) {\n    OC_ERR(\"Invalid user attributes read/write callback!\");\n    return ES_ERROR;\n  }\n  g_enrollee->read_cb = readcb;\n  g_enrollee->write_cb = writecb;\n  g_enrollee->free_userdata = free_userdata;\n  return ES_OK;\n"]]}
{"hexsha": "921a0b518ba4d28af3e7c4d7b1274975696a7833", "ext": "h", "lang": "C", "content": "interface PUPhotosSharingCollectionViewItemSublayout : NSObject {\n    struct CGRect { \n        struct CGPoint { \n            double x; \n            double y; \n        } origin; \n        struct CGSize { \n            double width; \n            double height; \n        } size; \n    }  _badgesContainerFrame;\n    unsigned long long  _badgesCorner;\n    struct UIOffset { \n        double horizontal; \n        double vertical; \n    }  _badgesOffset;\n    double  _bottomBadgeInset;\n    struct CGRect { \n        struct CGPoint { \n            double x; \n            double y; \n        } origin; \n        struct CGSize { \n            double width; \n            double height; \n        } size; \n    }  _floatingBadgesContainerFrame;\n    NSIndexPath * _indexPath;\n    struct CGRect { \n        struct CGPoint { \n            double x; \n            double y; \n        } origin; \n        struct CGSize { \n            double width; \n            double height; \n        } size; \n    }  _itemFrame;\n    struct CGPoint { \n        double x; \n        double y; \n    }  _optionBadgeCenter;\n    UICollectionViewLayoutAttributes * _optionBadgeLayoutAttributes;\n    struct CGPoint { \n        double x; \n        double y; \n    }  _selectionBadgeCenter;\n    UICollectionViewLayoutAttributes * _selectionBadgeLayoutAttributes;\n    struct CGRect { \n        struct CGPoint { \n            double x; \n            double y; \n        } origin; \n        struct CGSize { \n            double width; \n            double height; \n        } size; \n    }  _visibleItemFrame;\n}", "item_id": 0, "repo": "shaojiankui/iOS10-Runtime-Headers", "file": "Frameworks/PhotosUI.framework/PUPhotosSharingCollectionViewItemSublayout.h", "last_update_at": "2018-10-08T04:12:25+00:00", "question_id": "921a0b518ba4d28af3e7c4d7b1274975696a7833_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface PUPhotosSharingCollectionViewItemSublayout : NSObject {\n    struct CGRect { \n        struct CGPoint { \n            double x; \n            double y; \n        } origin; \n        struct CGSize { \n            double width; \n            double height; \n        } size; \n    }  _badgesContainerFrame;\n    unsigned long long  _badgesCorner;\n    struct UIOffset { \n        double horizontal; \n        double vertical; \n    }  _badgesOffset;\n    double  _bottomBadgeInset;\n    struct CGRect { \n        struct CGPoint { \n            double x; \n            double y; \n        } origin; \n        struct CGSize { \n            double width; \n            double height; \n        } size; \n    }  _floatingBadgesContainerFrame;\n    NSIndexPath * _indexPath;\n    struct CGRect { \n        struct CGPoint { \n            double x; \n            double y; \n        } origin; \n        struct CGSize { \n            double width; \n            double height; \n        } size; \n    }  _itemFrame;\n    struct CGPoint { \n        double x; \n        double y; \n    }  _optionBadgeCenter;\n    UICollectionViewLayoutAttributes * _optionBadgeLayoutAttributes;\n    struct CGPoint { \n        double x; \n        double y; \n    }  _selectionBadgeCenter;\n    UICollectionViewLayoutAttributes * _selectionBadgeLayoutAttributes;\n    struct CGRect { \n        struct CGPoint { \n            double x; \n            double y; \n        } origin; \n        struct CGSize { \n            double width; \n            double height; \n        } size; \n    }  _visibleItemFrame;\n"]]}
{"hexsha": "4ff722b875c5ef6aad956e53e84f206df760b1c8", "ext": "c", "lang": "C", "content": "void hal_reboot(void)\n{\n    printf(\"reboot!\\n\");\n    vPortETSIntrLock();\n    krhino_sched_disable();\n    delay();\n    delay();\n    rom_i2c_writeReg(0x67, 4, 1, 8);\n    rom_i2c_writeReg(0x67, 4, 2, 0x81);\n    while(1) {\n        system_restart();\n        aos_msleep(100);\n    }\n}", "item_id": 0, "repo": "ruoranluomu/AliOS-Things", "file": "platform/mcu/esp8266/hal/misc.c", "last_update_at": "2018-11-28T03:19:22+00:00", "question_id": "4ff722b875c5ef6aad956e53e84f206df760b1c8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void hal_reboot(void)\n{\n    printf(\"reboot!\\n\");\n    vPortETSIntrLock();\n    krhino_sched_disable();\n    delay();\n    delay();\n    rom_i2c_writeReg(0x67, 4, 1, 8);\n    rom_i2c_writeReg(0x67, 4, 2, 0x81);\n    while(1) {\n        system_restart();\n        aos_msleep(100);\n    }\n"]]}
{"hexsha": "9e029e62e46e673107afa1edfe5985addeb5743c", "ext": "c", "lang": "C", "content": "static int\nmacip_acl_interface_add_del_acl (u32 sw_if_index, u8 is_add,\n\t\t\t\t u32 acl_list_index)\n{\n  acl_main_t *am = &acl_main;\n  int rv = -1;\n  if (is_add)\n    {\n      rv = macip_acl_interface_add_acl (am, sw_if_index, acl_list_index);\n    }\n  else\n    {\n      rv = macip_acl_interface_del_acl (am, sw_if_index);\n    }\n  return rv;\n}", "item_id": 28, "repo": "LabNConsulting/vpp-marvell", "file": "src/plugins/acl/acl.c", "last_update_at": "2018-12-10T09:59:19+00:00", "question_id": "9e029e62e46e673107afa1edfe5985addeb5743c_28", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nmacip_acl_interface_add_del_acl (u32 sw_if_index, u8 is_add,\n\t\t\t\t u32 acl_list_index)\n{\n  acl_main_t *am = &acl_main;\n  int rv = -1;\n  if (is_add)\n    {\n      rv = macip_acl_interface_add_acl (am, sw_if_index, acl_list_index);\n    }\n  else\n    {\n      rv = macip_acl_interface_del_acl (am, sw_if_index);\n    }\n  return rv;\n"]]}
{"hexsha": "55acd95e4c2ad8dd9ace80d0857bd3a5752bd53e", "ext": "c", "lang": "C", "content": "Token token_duplicate(Token source)\n{\n  Token token;\n\n  token.type   = source.type;\n  token.line   = source.line;\n  token.col    = source.col;\n\n  if(source.lexeme != NULL)\n    token.lexeme = string_copy(source.lexeme, strlen(source.lexeme));\n\n  return token;\n}", "item_id": 1, "repo": "dlains/cube", "file": "src/token.c", "last_update_at": "2018-08-20T00:28:37+00:00", "question_id": "55acd95e4c2ad8dd9ace80d0857bd3a5752bd53e_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["Token token_duplicate(Token source)\n{\n  Token token;\n  token.type   = source.type;\n  token.line   = source.line;\n  token.col    = source.col;\n  if(source.lexeme != NULL)\n    token.lexeme = string_copy(source.lexeme, strlen(source.lexeme));\n  return token;\n"]]}
{"hexsha": "9e364f9e4de2f93c694cae0b58beb6f8f68c3d8a", "ext": "c", "lang": "C", "content": "static int\nbce_init_tx_chain(struct bce_tx_ring *txr)\n{\n\tstruct tx_bd *txbd;\n\tint i, rc = 0;\n\n\t/* Set the initial TX producer/consumer indices. */\n\ttxr->tx_prod = 0;\n\ttxr->tx_cons = 0;\n\ttxr->tx_prod_bseq = 0;\n\ttxr->used_tx_bd = 0;\n\ttxr->max_tx_bd = USABLE_TX_BD(txr);\n\n\t/*\n\t * The NetXtreme II supports a linked-list structre called\n\t * a Buffer Descriptor Chain (or BD chain).  A BD chain\n\t * consists of a series of 1 or more chain pages, each of which\n\t * consists of a fixed number of BD entries.\n\t * The last BD entry on each page is a pointer to the next page\n\t * in the chain, and the last pointer in the BD chain\n\t * points back to the beginning of the chain.\n\t */\n\n\t/* Set the TX next pointer chain entries. */\n\tfor (i = 0; i < txr->tx_pages; i++) {\n\t\tint j;\n\n\t\ttxbd = &txr->tx_bd_chain[i][USABLE_TX_BD_PER_PAGE];\n\n\t\t/* Check if we've reached the last page. */\n\t\tif (i == (txr->tx_pages - 1))\n\t\t\tj = 0;\n\t\telse\n\t\t\tj = i + 1;\n\n\t\ttxbd->tx_bd_haddr_hi =\n\t\t    htole32(BCE_ADDR_HI(txr->tx_bd_chain_paddr[j]));\n\t\ttxbd->tx_bd_haddr_lo =\n\t\t    htole32(BCE_ADDR_LO(txr->tx_bd_chain_paddr[j]));\n\t}\n\tbce_init_tx_context(txr);\n\n\treturn(rc);\n}", "item_id": 49, "repo": "jorisgio/DragonFlyBSD", "file": "sys/dev/netif/bce/if_bce.c", "last_update_at": "2018-01-12T03:55:33+00:00", "question_id": "9e364f9e4de2f93c694cae0b58beb6f8f68c3d8a_49", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nbce_init_tx_chain(struct bce_tx_ring *txr)\n{\n\tstruct tx_bd *txbd;\n\tint i, rc = 0;\n\t/* Set the initial TX producer/consumer indices. */\n\ttxr->tx_prod = 0;\n\ttxr->tx_cons = 0;\n\ttxr->tx_prod_bseq = 0;\n\ttxr->used_tx_bd = 0;\n\ttxr->max_tx_bd = USABLE_TX_BD(txr);\n\t/*\n\t * The NetXtreme II supports a linked-list structre called\n\t * a Buffer Descriptor Chain (or BD chain).  A BD chain\n\t * consists of a series of 1 or more chain pages, each of which\n\t * consists of a fixed number of BD entries.\n\t * The last BD entry on each page is a pointer to the next page\n\t * in the chain, and the last pointer in the BD chain\n\t * points back to the beginning of the chain.\n\t */\n\t/* Set the TX next pointer chain entries. */\n\tfor (i = 0; i < txr->tx_pages; i++) {\n\t\tint j;\n\t\ttxbd = &txr->tx_bd_chain[i][USABLE_TX_BD_PER_PAGE];\n\t\t/* Check if we've reached the last page. */\n\t\tif (i == (txr->tx_pages - 1))\n\t\t\tj = 0;\n\t\telse\n\t\t\tj = i + 1;\n\t\ttxbd->tx_bd_haddr_hi =\n\t\t    htole32(BCE_ADDR_HI(txr->tx_bd_chain_paddr[j]));\n\t\ttxbd->tx_bd_haddr_lo =\n\t\t    htole32(BCE_ADDR_LO(txr->tx_bd_chain_paddr[j]));\n\t}\n\tbce_init_tx_context(txr);\n\treturn(rc);\n"]]}
{"hexsha": "5a5c0aa596461e158761df79396b8ebe48584b92", "ext": "h", "lang": "C", "content": "off_t lseek(int fd, off_t offset, int whence) {\n\tunion {\n\t\toff_t o64;\n\t\tuint32 u32[2];\n\t} arg, ret;\n\targ.o64 = offset;\n\tasm volatile(\"int $0x80\" : \"=a\" (ret.u32[0]), \"=d\" (ret.u32[1]) : \"0\" (13), \"b\" (fd), \"c\" (arg.u32[0]), \"d\"(arg.u32[1]), \"S\"(whence));\n\treturn ret.o64;\n}", "item_id": 0, "repo": "TreyAJenkins/TextOS2", "file": "src/include/kernel/TextOS.h", "last_update_at": "2018-01-13T19:53:49+00:00", "question_id": "5a5c0aa596461e158761df79396b8ebe48584b92_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["off_t lseek(int fd, off_t offset, int whence) {\n\tunion {\n\t\toff_t o64;\n\t\tuint32 u32[2];\n\t} arg, ret;\n\targ.o64 = offset;\n\tasm volatile(\"int $0x80\" : \"=a\" (ret.u32[0]), \"=d\" (ret.u32[1]) : \"0\" (13), \"b\" (fd), \"c\" (arg.u32[0]), \"d\"(arg.u32[1]), \"S\"(whence));\n\treturn ret.o64;\n"]]}
{"hexsha": "bb3f1938bad77ab7fc4811b63dda6cf98311f809", "ext": "c", "lang": "C", "content": "int32_t KEYSCAN_StructInit(stc_keyscan_init_t *pstcKeyscanInit)\n{\n    int32_t i32Ret = LL_OK;\n\n    if (NULL == pstcKeyscanInit) {\n        i32Ret = LL_ERR_INVD_PARAM;\n    } else {\n        pstcKeyscanInit->u32HizCycle = KEYSCAN_HIZ_CYCLE_4;\n        pstcKeyscanInit->u32LowCycle = KEYSCAN_LOW_CYCLE_4;\n        pstcKeyscanInit->u32KeyClock = KEYSCAN_CLK_HCLK;\n        pstcKeyscanInit->u32KeyOut   = KEYSCAN_OUT_0T1;\n        pstcKeyscanInit->u32KeyIn    = KEYSCAN_IN_0;\n    }\n    return i32Ret;\n}", "item_id": 0, "repo": "BreederBai/rt-thread", "file": "bsp/hc32/libraries/hc32f4a0_ddl/drivers/hc32_ll_driver/src/hc32_ll_keyscan.c", "last_update_at": "2018-11-27T02:48:44+00:00", "question_id": "bb3f1938bad77ab7fc4811b63dda6cf98311f809_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int32_t KEYSCAN_StructInit(stc_keyscan_init_t *pstcKeyscanInit)\n{\n    int32_t i32Ret = LL_OK;\n    if (NULL == pstcKeyscanInit) {\n        i32Ret = LL_ERR_INVD_PARAM;\n    } else {\n        pstcKeyscanInit->u32HizCycle = KEYSCAN_HIZ_CYCLE_4;\n        pstcKeyscanInit->u32LowCycle = KEYSCAN_LOW_CYCLE_4;\n        pstcKeyscanInit->u32KeyClock = KEYSCAN_CLK_HCLK;\n        pstcKeyscanInit->u32KeyOut   = KEYSCAN_OUT_0T1;\n        pstcKeyscanInit->u32KeyIn    = KEYSCAN_IN_0;\n    }\n    return i32Ret;\n"]]}
{"hexsha": "df356c375ba004290f2c4a213f5291ad70995822", "ext": "c", "lang": "C", "content": "static void tscpu_fast_initial_sw_workaround(void)\n{\n\tint i = 0;\n\tunsigned long flags;\n\t/* tscpu_printk(\"tscpu_fast_initial_sw_workaround\\n\"); */\n\n\t/* tscpu_thermal_clock_on(); */\n\n\tmt_ptp_lock(&flags);\n\n\tfor (i = 0; i < TS_LEN_ARRAY(tscpu_g_bank); i++) {\n\t\ttscpu_switch_bank(i);\n\t\ttscpu_thermal_fast_init();\n\t}\n\n\tmt_ptp_unlock(&flags);\n\n}", "item_id": 1, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_cpu.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "df356c375ba004290f2c4a213f5291ad70995822_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void tscpu_fast_initial_sw_workaround(void)\n{\n\tint i = 0;\n\tunsigned long flags;\n\t/* tscpu_printk(\"tscpu_fast_initial_sw_workaround\\n\"); */\n\t/* tscpu_thermal_clock_on(); */\n\tmt_ptp_lock(&flags);\n\tfor (i = 0; i < TS_LEN_ARRAY(tscpu_g_bank); i++) {\n\t\ttscpu_switch_bank(i);\n\t\ttscpu_thermal_fast_init();\n\t}\n\tmt_ptp_unlock(&flags);\n"]]}
{"hexsha": "efdfd1b6782a78bcdf0006425c0e40f83dfa5a71", "ext": "c", "lang": "C", "content": "void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])\n{\n  /*****************************************************************************\n  ** this function takes a flag and a variable number of arguments\n  ** depending on the value of the flag and returns either a construct \n  ** containing probability estimates, a merged vector or a double value \n  ** representing an entropy or mutual information\n  *****************************************************************************/\n  \n  int flag, numberOfSamples, checkSamples, thirdCheckSamples, numberOfFeatures, checkFeatures, thirdCheckFeatures;\n  int vectorMismatch, columnMismatch, weightLength, weightWidth;\n  double *dataVector, *condVector, *targetVector, *firstVector, *secondVector, *output, *weightVector;\n  double *weightOutput, *jointWeight, *firstWeight, *secondWeight, *jointOutput, *firstOutput, *secondOutput;\n  double *numStates, *numJointStates, *numFirstStates, *numSecondStates;\n  WeightedProbState state;\n  WeightedJointProbState jointState;\n  int i;\n\n  switch (nrhs)\n  {\n    case 3:\n    {\n        /*printf(\"Must be H_w(X)\\n\");*/\n        break;\n    }\n    case 4:\n    {\n        /*printf(\"Must be H_w(XY), H_w(X|Y), I_w(X;Y)\\n\");*/\n        break;\n    }\n    case 5:\n    {\n        /*printf(\"Must be I_w(X;Y|Z)\\n\");*/\n        break;\n    }\n    default:\n    {\n        printf(\"Incorrect number of arguments, format is WeightedMIToolbox(\\\"FLAG\\\",varargin)\\n\");\n        break;\n    }\n  }\n  \n  vectorMismatch = 0;\n  columnMismatch = 0;\n\n  /* number to function map\n  ** 1 = H(X)\n  ** 2 = H(XY)\n  ** 3 = H(X|Y)\n  ** 4 = I(X;Y)\n  ** 5 = I(X;Y|Z)\n  ** 6 = calculateWeightedProbability\n  ** 7 = calculateWeightedJointProbability\n  */\n  \n  flag = *mxGetPr(prhs[0]);\n  weightLength = mxGetM(prhs[1]);\n  weightWidth = mxGetN(prhs[1]);\n  weightVector = (double *) mxGetPr(prhs[1]);\n  \n  switch (flag)\n  {\n    case 1:\n    {\n      /*\n      **H(X)\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      numberOfFeatures = mxGetN(prhs[2]);\n      dataVector = (double *) mxGetPr(prhs[2]);\n\n      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);\n      output = (double *)mxGetPr(plhs[0]);\n\n      if ((numberOfFeatures == 1) && (weightWidth == 1))\n      {\n        if (numberOfSamples == weightLength)\n        {\n          /*double calculateWeightedEntropy(double *dataVector, double *weightVector, int vectorLength);*/\n          *output = calculateWeightedEntropy(dataVector,weightVector,numberOfSamples);\n        }\n        else\n        {\n          vectorMismatch = 1;\n        }\n      }\n      else\n      {\n        columnMismatch = 1;\n      }\n      \n      break;\n    }/*case 1 - H(X)*/\n    case 2:\n    {\n      /*\n      **H(XY)\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      checkSamples = mxGetM(prhs[3]);\n      \n      numberOfFeatures = mxGetN(prhs[2]);\n      checkFeatures = mxGetN(prhs[3]);\n\n      firstVector = mxGetPr(prhs[2]);\n      secondVector = mxGetPr(prhs[3]);\n\n      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);\n      output = (double *)mxGetPr(plhs[0]);\n\n      if ((numberOfFeatures == 1) && (checkFeatures == 1) && (weightWidth == 1))\n      {\n        if ((numberOfSamples == 0) && (checkSamples == 0) && (weightLength == 0))\n        {\n          *output = 0.0;\n        }\n        else if ((numberOfSamples == 0) && (weightLength == checkSamples))\n        {\n          *output = calculateWeightedEntropy(secondVector,weightVector,numberOfSamples);\n        }\n        else if ((checkSamples == 0) && (weightLength == numberOfSamples))\n        {\n          *output = calculateWeightedEntropy(firstVector,weightVector,numberOfSamples);\n        }\n        else if ((numberOfSamples == checkSamples) && (numberOfSamples == weightLength))\n        {\n          /*double calculateWeightedJointEntropy(double *firstVector, double *secondVector, double *weightVector, int vectorLength);*/\n          *output = calculateWeightedJointEntropy(firstVector,secondVector,weightVector,numberOfSamples);\n        }\n        else\n        {\n          vectorMismatch = 1;\n        }\n      }\n      else\n      {\n        columnMismatch = 1;\n      }\n      \n      break;\n    }/*case 2 - H(XY)*/\n    case 3:\n    {\n      /*\n      **H(X|Y)\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      checkSamples = mxGetM(prhs[3]);\n      \n      numberOfFeatures = mxGetN(prhs[2]);\n      checkFeatures = mxGetN(prhs[3]);\n\n      dataVector = mxGetPr(prhs[2]);\n      condVector = mxGetPr(prhs[3]);\n\n      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);\n      output = (double *)mxGetPr(plhs[0]);\n\n      if ((numberOfFeatures == 1) && (checkFeatures == 1) && (weightWidth == 1))\n      {\n        if (numberOfSamples == 0)\n        {\n          *output = 0.0;\n        }\n        else if ((checkSamples == 0) && (weightLength == numberOfSamples))\n        {\n          *output = calculateWeightedEntropy(dataVector,weightVector,numberOfSamples);\n        }\n        else if ((numberOfSamples == checkSamples) && (numberOfSamples == weightLength))\n        {\n          /*double calculateWeightedConditionalEntropy(double *dataVector, double *condVector, double *weightVector, int vectorLength);*/\n          *output = calculateWeightedConditionalEntropy(dataVector,condVector,weightVector,numberOfSamples);\n        }\n        else\n        {\n          vectorMismatch = 1;\n        }\n      }\n      else\n      {\n        columnMismatch = 1;\n      }\n      break;\n    }/*case 3 - H(X|Y)*/\n    case 4:\n    {\n      /*\n      **I(X;Y)\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      checkSamples = mxGetM(prhs[3]);\n      \n      numberOfFeatures = mxGetN(prhs[2]);\n      checkFeatures = mxGetN(prhs[3]);\n\n      firstVector = mxGetPr(prhs[2]);\n      secondVector = mxGetPr(prhs[3]);\n\n      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);\n      output = (double *)mxGetPr(plhs[0]);\n\n      if ((numberOfFeatures == 1) && (checkFeatures == 1) && (weightWidth == 1))\n      {\n        if ((numberOfSamples == 0) || (checkSamples == 0))\n        {\n          *output = 0.0;\n        }\n        else if ((numberOfSamples == checkSamples) && (numberOfSamples == weightLength))\n        {\n          /*double calculateWeightedMutualInformation(double *firstVector, double *secondVector, double *weightVector, int vectorLength);*/\n          *output = calculateWeightedMutualInformation(firstVector,secondVector,weightVector,numberOfSamples);\n        }\n        else\n        {\n          vectorMismatch = 1;\n        }\n      }\n      else\n      {\n        columnMismatch = 1;\n      }\n      break;\n    }/*case 4 - I(X;Y)*/\n    case 5:\n    {\n      /*\n      **I(X;Y|Z)\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      checkSamples = mxGetM(prhs[3]);\n      thirdCheckSamples = mxGetM(prhs[4]);\n      \n      numberOfFeatures = mxGetN(prhs[2]);\n      checkFeatures = mxGetN(prhs[3]);\n      thirdCheckFeatures = mxGetN(prhs[4]);\n\n      firstVector = mxGetPr(prhs[2]);\n      targetVector = mxGetPr(prhs[3]);\n      condVector = mxGetPr(prhs[4]);\n\n      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);\n      output = (double *)mxGetPr(plhs[0]);\n      \n      if ((numberOfFeatures == 1) && (checkFeatures == 1) && (weightWidth == 1))\n      {\n        if ((numberOfSamples == 0) || (checkSamples == 0))\n        {\n          *output = 0.0;\n        }\n        else if ((numberOfSamples == checkSamples) && (numberOfSamples == weightLength))\n        {\n          if ((thirdCheckSamples == 0) || (thirdCheckFeatures != 1))\n          {\n            *output = calculateWeightedMutualInformation(firstVector,targetVector,weightVector,numberOfSamples);\n          }\n          else if (numberOfSamples == thirdCheckSamples)\n          {\n            /*double calculateWeightedConditionalMutualInformation(double *firstVector, double *targetVector, double *condVector, double *weightVector, int vectorLength);*/\n            *output = calculateWeightedConditionalMutualInformation(firstVector,targetVector,condVector,weightVector,numberOfSamples);\n          }\n          else\n          {\n            vectorMismatch = 1;\n          }\n        }\n        else\n        {\n          vectorMismatch = 1;\n        }\n      }\n      else\n      {\n        columnMismatch = 1;\n      }\n      break;\n    }/*case 5 - I(X;Y|Z)*/\n    case 6:\n    {\n      /*\n      **calculateWeightedProbability\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      dataVector = (double *) mxGetPr(prhs[2]);\n\n      /*WeightedProbabilityState calculateWeightedProbability(double *dataVector, double *weightVector, int vectorLength);*/\n      state = calculateWeightedProbability(dataVector,weightVector,numberOfSamples);\n      \n      plhs[0] = mxCreateDoubleMatrix(state.numStates,1,mxREAL);\n      plhs[1] = mxCreateDoubleMatrix(state.numStates,1,mxREAL);\n      plhs[2] = mxCreateDoubleMatrix(1,1,mxREAL);\n      output = (double *)mxGetPr(plhs[0]);\n      weightOutput = (double *)mxGetPr(plhs[1]);\n      numStates = (double *) mxGetPr(plhs[2]);\n      \n      *numStates = state.numStates;\n      \n      for (i = 0; i < state.numStates; i++)\n      {\n        output[i] = state.probabilityVector[i];\n        weightOutput[i] = state.stateWeightVector[i];\n      }\n      \n      break;\n    }/*case 6 - calculateWeightedProbability*/\n    case 7:\n    {\n      /*\n      **calculateWeightedJointProbability\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      firstVector = (double *) mxGetPr(prhs[2]);\n      secondVector = (double *) mxGetPr(prhs[3]);\n\n      /*JointProbabilityState calculateJointProbability(double *firstVector, double *secondVector, double *weightVector, int vectorLength);*/\n      jointState = calculateWeightedJointProbability(firstVector,secondVector,weightVector,numberOfSamples);\n      \n      plhs[0] = mxCreateDoubleMatrix(jointState.numJointStates,1,mxREAL);\n      plhs[1] = mxCreateDoubleMatrix(jointState.numJointStates,1,mxREAL);\n      plhs[2] = mxCreateDoubleMatrix(1,1,mxREAL);\n      plhs[3] = mxCreateDoubleMatrix(jointState.numFirstStates,1,mxREAL);\n      plhs[4] = mxCreateDoubleMatrix(jointState.numFirstStates,1,mxREAL);\n      plhs[5] = mxCreateDoubleMatrix(1,1,mxREAL);\n      plhs[6] = mxCreateDoubleMatrix(jointState.numSecondStates,1,mxREAL);\n      plhs[7] = mxCreateDoubleMatrix(jointState.numSecondStates,1,mxREAL);\n      plhs[8] = mxCreateDoubleMatrix(1,1,mxREAL);\n\n      jointOutput = (double *)mxGetPr(plhs[0]);\n      jointWeight = (double *)mxGetPr(plhs[1]);\n      numJointStates = (double *) mxGetPr(plhs[2]);\n      firstOutput = (double *)mxGetPr(plhs[3]);\n      firstWeight = (double *)mxGetPr(plhs[4]);\n      numFirstStates = (double *) mxGetPr(plhs[5]);\n      secondOutput = (double *)mxGetPr(plhs[6]);\n      secondWeight = (double *)mxGetPr(plhs[7]);\n      numSecondStates = (double *) mxGetPr(plhs[8]);\n      \n      *numJointStates = jointState.numJointStates;\n      *numFirstStates = jointState.numFirstStates;\n      *numSecondStates = jointState.numSecondStates;\n      \n      for (i = 0; i < jointState.numJointStates; i++)\n      {\n        jointOutput[i] = jointState.jointProbabilityVector[i];\n        jointWeight[i] = jointState.jointWeightVector[i];\n      }\n      for (i = 0; i < jointState.numFirstStates; i++)\n      {\n        firstOutput[i] = jointState.firstProbabilityVector[i];\n        firstWeight[i] = jointState.firstWeightVector[i];\n      }\n      for (i = 0; i < jointState.numSecondStates; i++)\n      {\n        secondOutput[i] = jointState.secondProbabilityVector[i];\n        secondWeight[i] = jointState.secondWeightVector[i];\n      }\n      \n      break;\n    }/*case 7 - calculateWeightedJointProbability */\n    default:\n    {\n      printf(\"Unrecognised flag\\n\");\n      break;\n    }/*default*/\n  }/*switch(flag)*/\n \n  if (columnMismatch)\n  {\n    printf(\"No columns in one or more inputs\\n\");\n    *output = -1.0;\n  }\n  else if (vectorMismatch)\n  {\n    printf(\"Vector lengths do not match, they must all be the same length\\n\");\n    *output = -1.0;\n  }\n\n  return;\n}", "item_id": 0, "repo": "alecuba16/alecuba16-FEASTR", "file": "src/MIToolbox/WeightedMIToolboxMex.c", "last_update_at": "2018-10-30T03:17:26+00:00", "question_id": "efdfd1b6782a78bcdf0006425c0e40f83dfa5a71_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])\n{\n  /*****************************************************************************\n  ** this function takes a flag and a variable number of arguments\n  ** depending on the value of the flag and returns either a construct \n  ** containing probability estimates, a merged vector or a double value \n  ** representing an entropy or mutual information\n  *****************************************************************************/\n  int flag, numberOfSamples, checkSamples, thirdCheckSamples, numberOfFeatures, checkFeatures, thirdCheckFeatures;\n  int vectorMismatch, columnMismatch, weightLength, weightWidth;\n  double *dataVector, *condVector, *targetVector, *firstVector, *secondVector, *output, *weightVector;\n  double *weightOutput, *jointWeight, *firstWeight, *secondWeight, *jointOutput, *firstOutput, *secondOutput;\n  double *numStates, *numJointStates, *numFirstStates, *numSecondStates;\n  WeightedProbState state;\n  WeightedJointProbState jointState;\n  int i;\n  switch (nrhs)\n  {\n    case 3:\n    {\n        /*printf(\"Must be H_w(X)\\n\");*/\n        break;\n    }\n    case 4:\n    {\n        /*printf(\"Must be H_w(XY), H_w(X|Y), I_w(X;Y)\\n\");*/\n        break;\n    }\n    case 5:\n    {\n        /*printf(\"Must be I_w(X;Y|Z)\\n\");*/\n        break;\n    }\n    default:\n    {\n        printf(\"Incorrect number of arguments, format is WeightedMIToolbox(\\\"FLAG\\\",varargin)\\n\");\n        break;\n    }\n  }\n  vectorMismatch = 0;\n  columnMismatch = 0;\n  /* number to function map\n  ** 1 = H(X)\n  ** 2 = H(XY)\n  ** 3 = H(X|Y)\n  ** 4 = I(X;Y)\n  ** 5 = I(X;Y|Z)\n  ** 6 = calculateWeightedProbability\n  ** 7 = calculateWeightedJointProbability\n  */\n  flag = *mxGetPr(prhs[0]);\n  weightLength = mxGetM(prhs[1]);\n  weightWidth = mxGetN(prhs[1]);\n  weightVector = (double *) mxGetPr(prhs[1]);\n  switch (flag)\n  {\n    case 1:\n    {\n      /*\n      **H(X)\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      numberOfFeatures = mxGetN(prhs[2]);\n      dataVector = (double *) mxGetPr(prhs[2]);\n      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);\n      output = (double *)mxGetPr(plhs[0]);\n      if ((numberOfFeatures == 1) && (weightWidth == 1))\n      {\n        if (numberOfSamples == weightLength)\n        {\n          /*double calculateWeightedEntropy(double *dataVector, double *weightVector, int vectorLength);*/\n          *output = calculateWeightedEntropy(dataVector,weightVector,numberOfSamples);\n        }\n        else\n        {\n          vectorMismatch = 1;\n        }\n      }\n      else\n      {\n        columnMismatch = 1;\n      }\n      break;\n    }/*case 1 - H(X)*/\n    case 2:\n    {\n      /*\n      **H(XY)\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      checkSamples = mxGetM(prhs[3]);\n      numberOfFeatures = mxGetN(prhs[2]);\n      checkFeatures = mxGetN(prhs[3]);\n      firstVector = mxGetPr(prhs[2]);\n      secondVector = mxGetPr(prhs[3]);\n      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);\n      output = (double *)mxGetPr(plhs[0]);\n      if ((numberOfFeatures == 1) && (checkFeatures == 1) && (weightWidth == 1))\n      {\n        if ((numberOfSamples == 0) && (checkSamples == 0) && (weightLength == 0))\n        {\n          *output = 0.0;\n        }\n        else if ((numberOfSamples == 0) && (weightLength == checkSamples))\n        {\n          *output = calculateWeightedEntropy(secondVector,weightVector,numberOfSamples);\n        }\n        else if ((checkSamples == 0) && (weightLength == numberOfSamples))\n        {\n          *output = calculateWeightedEntropy(firstVector,weightVector,numberOfSamples);\n        }\n        else if ((numberOfSamples == checkSamples) && (numberOfSamples == weightLength))\n        {\n          /*double calculateWeightedJointEntropy(double *firstVector, double *secondVector, double *weightVector, int vectorLength);*/\n          *output = calculateWeightedJointEntropy(firstVector,secondVector,weightVector,numberOfSamples);\n        }\n        else\n        {\n          vectorMismatch = 1;\n        }\n      }\n      else\n      {\n        columnMismatch = 1;\n      }\n      break;\n    }/*case 2 - H(XY)*/\n    case 3:\n    {\n      /*\n      **H(X|Y)\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      checkSamples = mxGetM(prhs[3]);\n      numberOfFeatures = mxGetN(prhs[2]);\n      checkFeatures = mxGetN(prhs[3]);\n      dataVector = mxGetPr(prhs[2]);\n      condVector = mxGetPr(prhs[3]);\n      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);\n      output = (double *)mxGetPr(plhs[0]);\n      if ((numberOfFeatures == 1) && (checkFeatures == 1) && (weightWidth == 1))\n      {\n        if (numberOfSamples == 0)\n        {\n          *output = 0.0;\n        }\n        else if ((checkSamples == 0) && (weightLength == numberOfSamples))\n        {\n          *output = calculateWeightedEntropy(dataVector,weightVector,numberOfSamples);\n        }\n        else if ((numberOfSamples == checkSamples) && (numberOfSamples == weightLength))\n        {\n          /*double calculateWeightedConditionalEntropy(double *dataVector, double *condVector, double *weightVector, int vectorLength);*/\n          *output = calculateWeightedConditionalEntropy(dataVector,condVector,weightVector,numberOfSamples);\n        }\n        else\n        {\n          vectorMismatch = 1;\n        }\n      }\n      else\n      {\n        columnMismatch = 1;\n      }\n      break;\n    }/*case 3 - H(X|Y)*/\n    case 4:\n    {\n      /*\n      **I(X;Y)\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      checkSamples = mxGetM(prhs[3]);\n      numberOfFeatures = mxGetN(prhs[2]);\n      checkFeatures = mxGetN(prhs[3]);\n      firstVector = mxGetPr(prhs[2]);\n      secondVector = mxGetPr(prhs[3]);\n      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);\n      output = (double *)mxGetPr(plhs[0]);\n      if ((numberOfFeatures == 1) && (checkFeatures == 1) && (weightWidth == 1))\n      {\n        if ((numberOfSamples == 0) || (checkSamples == 0))\n        {\n          *output = 0.0;\n        }\n        else if ((numberOfSamples == checkSamples) && (numberOfSamples == weightLength))\n        {\n          /*double calculateWeightedMutualInformation(double *firstVector, double *secondVector, double *weightVector, int vectorLength);*/\n          *output = calculateWeightedMutualInformation(firstVector,secondVector,weightVector,numberOfSamples);\n        }\n        else\n        {\n          vectorMismatch = 1;\n        }\n      }\n      else\n      {\n        columnMismatch = 1;\n      }\n      break;\n    }/*case 4 - I(X;Y)*/\n    case 5:\n    {\n      /*\n      **I(X;Y|Z)\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      checkSamples = mxGetM(prhs[3]);\n      thirdCheckSamples = mxGetM(prhs[4]);\n      numberOfFeatures = mxGetN(prhs[2]);\n      checkFeatures = mxGetN(prhs[3]);\n      thirdCheckFeatures = mxGetN(prhs[4]);\n      firstVector = mxGetPr(prhs[2]);\n      targetVector = mxGetPr(prhs[3]);\n      condVector = mxGetPr(prhs[4]);\n      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);\n      output = (double *)mxGetPr(plhs[0]);\n      if ((numberOfFeatures == 1) && (checkFeatures == 1) && (weightWidth == 1))\n      {\n        if ((numberOfSamples == 0) || (checkSamples == 0))\n        {\n          *output = 0.0;\n        }\n        else if ((numberOfSamples == checkSamples) && (numberOfSamples == weightLength))\n        {\n          if ((thirdCheckSamples == 0) || (thirdCheckFeatures != 1))\n          {\n            *output = calculateWeightedMutualInformation(firstVector,targetVector,weightVector,numberOfSamples);\n          }\n          else if (numberOfSamples == thirdCheckSamples)\n          {\n            /*double calculateWeightedConditionalMutualInformation(double *firstVector, double *targetVector, double *condVector, double *weightVector, int vectorLength);*/\n            *output = calculateWeightedConditionalMutualInformation(firstVector,targetVector,condVector,weightVector,numberOfSamples);\n          }\n          else\n          {\n            vectorMismatch = 1;\n          }\n        }\n        else\n        {\n          vectorMismatch = 1;\n        }\n      }\n      else\n      {\n        columnMismatch = 1;\n      }\n      break;\n    }/*case 5 - I(X;Y|Z)*/\n    case 6:\n    {\n      /*\n      **calculateWeightedProbability\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      dataVector = (double *) mxGetPr(prhs[2]);\n      /*WeightedProbabilityState calculateWeightedProbability(double *dataVector, double *weightVector, int vectorLength);*/\n      state = calculateWeightedProbability(dataVector,weightVector,numberOfSamples);\n      plhs[0] = mxCreateDoubleMatrix(state.numStates,1,mxREAL);\n      plhs[1] = mxCreateDoubleMatrix(state.numStates,1,mxREAL);\n      plhs[2] = mxCreateDoubleMatrix(1,1,mxREAL);\n      output = (double *)mxGetPr(plhs[0]);\n      weightOutput = (double *)mxGetPr(plhs[1]);\n      numStates = (double *) mxGetPr(plhs[2]);\n      *numStates = state.numStates;\n      for (i = 0; i < state.numStates; i++)\n      {\n        output[i] = state.probabilityVector[i];\n        weightOutput[i] = state.stateWeightVector[i];\n      }\n      break;\n    }/*case 6 - calculateWeightedProbability*/\n    case 7:\n    {\n      /*\n      **calculateWeightedJointProbability\n      */\n      numberOfSamples = mxGetM(prhs[2]);\n      firstVector = (double *) mxGetPr(prhs[2]);\n      secondVector = (double *) mxGetPr(prhs[3]);\n      /*JointProbabilityState calculateJointProbability(double *firstVector, double *secondVector, double *weightVector, int vectorLength);*/\n      jointState = calculateWeightedJointProbability(firstVector,secondVector,weightVector,numberOfSamples);\n      plhs[0] = mxCreateDoubleMatrix(jointState.numJointStates,1,mxREAL);\n      plhs[1] = mxCreateDoubleMatrix(jointState.numJointStates,1,mxREAL);\n      plhs[2] = mxCreateDoubleMatrix(1,1,mxREAL);\n      plhs[3] = mxCreateDoubleMatrix(jointState.numFirstStates,1,mxREAL);\n      plhs[4] = mxCreateDoubleMatrix(jointState.numFirstStates,1,mxREAL);\n      plhs[5] = mxCreateDoubleMatrix(1,1,mxREAL);\n      plhs[6] = mxCreateDoubleMatrix(jointState.numSecondStates,1,mxREAL);\n      plhs[7] = mxCreateDoubleMatrix(jointState.numSecondStates,1,mxREAL);\n      plhs[8] = mxCreateDoubleMatrix(1,1,mxREAL);\n      jointOutput = (double *)mxGetPr(plhs[0]);\n      jointWeight = (double *)mxGetPr(plhs[1]);\n      numJointStates = (double *) mxGetPr(plhs[2]);\n      firstOutput = (double *)mxGetPr(plhs[3]);\n      firstWeight = (double *)mxGetPr(plhs[4]);\n      numFirstStates = (double *) mxGetPr(plhs[5]);\n      secondOutput = (double *)mxGetPr(plhs[6]);\n      secondWeight = (double *)mxGetPr(plhs[7]);\n      numSecondStates = (double *) mxGetPr(plhs[8]);\n      *numJointStates = jointState.numJointStates;\n      *numFirstStates = jointState.numFirstStates;\n      *numSecondStates = jointState.numSecondStates;\n      for (i = 0; i < jointState.numJointStates; i++)\n      {\n        jointOutput[i] = jointState.jointProbabilityVector[i];\n        jointWeight[i] = jointState.jointWeightVector[i];\n      }\n      for (i = 0; i < jointState.numFirstStates; i++)\n      {\n        firstOutput[i] = jointState.firstProbabilityVector[i];\n        firstWeight[i] = jointState.firstWeightVector[i];\n      }\n      for (i = 0; i < jointState.numSecondStates; i++)\n      {\n        secondOutput[i] = jointState.secondProbabilityVector[i];\n        secondWeight[i] = jointState.secondWeightVector[i];\n      }\n      break;\n    }/*case 7 - calculateWeightedJointProbability */\n    default:\n    {\n      printf(\"Unrecognised flag\\n\");\n      break;\n    }/*default*/\n  }/*switch(flag)*/\n  if (columnMismatch)\n  {\n    printf(\"No columns in one or more inputs\\n\");\n    *output = -1.0;\n  }\n  else if (vectorMismatch)\n  {\n    printf(\"Vector lengths do not match, they must all be the same length\\n\");\n    *output = -1.0;\n  }\n  return;\n"]]}
{"hexsha": "862cecb3338cbd440646299c9de25c205ae84a8e", "ext": "c", "lang": "C", "content": "Status EXC_OP_NIP(CStack *stack)\n{\n\tif (stack->is_empty(stack)) return CSTACK_EMPTY;\n\tsize_t top_size;\n\tvoid *top_type;\n\tvoid *top = stack->pop(stack, &top_size, &top_type, NULL);\n\tvoid *second = stack->pop(stack, NULL, NULL, NULL);\n\tif (second != NULL) free(second);\n\tstack->push(stack, top, top_size, top_type, true);\n\treturn OPERATION_EXECUTED;\n}", "item_id": 17, "repo": "Yirain/BTC-tool", "file": "src/machine/operation.c", "last_update_at": "2018-07-14T07:05:21+00:00", "question_id": "862cecb3338cbd440646299c9de25c205ae84a8e_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["Status EXC_OP_NIP(CStack *stack)\n{\n\tif (stack->is_empty(stack)) return CSTACK_EMPTY;\n\tsize_t top_size;\n\tvoid *top_type;\n\tvoid *top = stack->pop(stack, &top_size, &top_type, NULL);\n\tvoid *second = stack->pop(stack, NULL, NULL, NULL);\n\tif (second != NULL) free(second);\n\tstack->push(stack, top, top_size, top_type, true);\n\treturn OPERATION_EXECUTED;\n"]]}
{"hexsha": "9a7ad5c738de91170f8a66d181e30c28492947a6", "ext": "c", "lang": "C", "content": "static PyObject* gsl_sf_debye_3_e_wrap(PyObject *self, PyObject *args) {\nPyObject* returned_object;\nint int_result;\ndouble x=0.0;\ngsl_sf_result result;\n\nif (!PyArg_ParseTuple(args, \"d\", &x)) {\n  /* say a little bit more */\n  return NULL;\n}\nint_result=gsl_sf_debye_3_e(x, &result);\n\nif (int_result!=GSL_SUCCESS) {\n  const char* message;\n  message=gsl_strerror(int_result);\n  /* raise exception */\n  PyErr_SetString(gsl_module_error,message);\n  return NULL;\n}\nreturned_object=Py_BuildValue(\"(dd)\",result.val, result.err);\nreturn returned_object;\n}", "item_id": 67, "repo": "juhnowski/FishingRod", "file": "production/pygsl-0.9.5/src/sf_functions.c", "last_update_at": "2018-10-02T06:18:07+00:00", "question_id": "9a7ad5c738de91170f8a66d181e30c28492947a6_67", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static PyObject* gsl_sf_debye_3_e_wrap(PyObject *self, PyObject *args) {\nPyObject* returned_object;\nint int_result;\ndouble x=0.0;\ngsl_sf_result result;\nif (!PyArg_ParseTuple(args, \"d\", &x)) {\n  /* say a little bit more */\n  return NULL;\n}\nint_result=gsl_sf_debye_3_e(x, &result);\nif (int_result!=GSL_SUCCESS) {\n  const char* message;\n  message=gsl_strerror(int_result);\n  /* raise exception */\n  PyErr_SetString(gsl_module_error,message);\n  return NULL;\n}\nreturned_object=Py_BuildValue(\"(dd)\",result.val, result.err);\nreturn returned_object;\n"]]}
{"hexsha": "ab976c859304a6318dd57f177fea481456397267", "ext": "c", "lang": "C", "content": "static struct allocator *find_allocator(const struct allocator_vtable *vtable)\n{\n\t/* Loop through allocators in list */\n\tstruct allocator *ap = head.next;\n\twhile (ap->next != NULL) {\n\t\t/* Exit now if this is the allocator we are looking for */\n\t\tif (ap->vtable == vtable)\n\t\t\treturn ap;\n\n\t\t/* Check next allocator in list */\n\t\tap = ap->next;\n\t}\n\n\t/* Create new allocator */\n\tap = new_allocator(vtable);\n\tif (!ap)\n\t\treturn NULL;\n\n\t/* Add allocator to end of list */\n\tap->next = &tail;\n\tap->prev = tail.prev;\n\ttail.prev->next = ap;\n\ttail.prev = ap;\n\treturn ap;\n}", "item_id": 2, "repo": "tronkko/t7", "file": "libt7/src/allocator.c", "last_update_at": "2018-05-13T20:07:23+00:00", "question_id": "ab976c859304a6318dd57f177fea481456397267_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static struct allocator *find_allocator(const struct allocator_vtable *vtable)\n{\n\t/* Loop through allocators in list */\n\tstruct allocator *ap = head.next;\n\twhile (ap->next != NULL) {\n\t\t/* Exit now if this is the allocator we are looking for */\n\t\tif (ap->vtable == vtable)\n\t\t\treturn ap;\n\t\t/* Check next allocator in list */\n\t\tap = ap->next;\n\t}\n\t/* Create new allocator */\n\tap = new_allocator(vtable);\n\tif (!ap)\n\t\treturn NULL;\n\t/* Add allocator to end of list */\n\tap->next = &tail;\n\tap->prev = tail.prev;\n\ttail.prev->next = ap;\n\ttail.prev = ap;\n\treturn ap;\n"]]}
{"hexsha": "cbae544022a07a67df776c245225634977e661c1", "ext": "c", "lang": "C", "content": "GT_INLINE gt_status gt_sam_attribute_generate_XB(gt_sam_attribute_func_params* func_params) {\n  if (func_params->alignment_info->map == NULL) return -1; // Don't print anything\n  gt_attributes *attr=func_params->alignment_info->map->attributes;\n  if(attr==NULL) return -1;\n  void *pp=gt_attributes_get(attr,GT_ATTR_ID_BIS_TYPE);\n  if(pp==NULL) return -1;\n  uint64_t bis_type=*(uint64_t *)pp;\n  if(bis_type>=5 || !bis_type) return -1;\n  char XB_char_value=\"UCGM\"[(int)bis_type-1];\n  gt_string_clear(func_params->return_s);\n  gt_string_append_char(func_params->return_s,XB_char_value);\n  gt_string_append_eos(func_params->return_s);\n  return 0; // OK\n}", "item_id": 39, "repo": "MarcosFernandez/gemtols-cnv", "file": "GEMTools/src/gt_sam_attributes.c", "last_update_at": "2018-07-26T08:57:07+00:00", "question_id": "cbae544022a07a67df776c245225634977e661c1_39", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["GT_INLINE gt_status gt_sam_attribute_generate_XB(gt_sam_attribute_func_params* func_params) {\n  if (func_params->alignment_info->map == NULL) return -1; // Don't print anything\n  gt_attributes *attr=func_params->alignment_info->map->attributes;\n  if(attr==NULL) return -1;\n  void *pp=gt_attributes_get(attr,GT_ATTR_ID_BIS_TYPE);\n  if(pp==NULL) return -1;\n  uint64_t bis_type=*(uint64_t *)pp;\n  if(bis_type>=5 || !bis_type) return -1;\n  char XB_char_value=\"UCGM\"[(int)bis_type-1];\n  gt_string_clear(func_params->return_s);\n  gt_string_append_char(func_params->return_s,XB_char_value);\n  gt_string_append_eos(func_params->return_s);\n  return 0; // OK\n"]]}
{"hexsha": "4cdffa46d401a5ea6120ba5d350e453158166a31", "ext": "c", "lang": "C", "content": "static\nvoid ufs_qcom_clk_scale_notify(struct ufs_hba *hba)\n{\n\tstruct ufs_qcom_host *host = hba->priv;\n\tstruct ufs_pa_layer_attr *dev_req_params = &host->dev_req_params;\n\n\tif (!dev_req_params)\n\t\treturn;\n\n\tufs_qcom_cfg_timers(hba, dev_req_params->gear_rx,\n\t\t\t\tdev_req_params->pwr_rx,\n\t\t\t\tdev_req_params->hs_rate);\n}", "item_id": 28, "repo": "SIIS-cloud/pileus", "file": "difc-kernel/pileus-kernel/drivers/scsi/ufs/ufs-qcom.c", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "4cdffa46d401a5ea6120ba5d350e453158166a31_28", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static\nvoid ufs_qcom_clk_scale_notify(struct ufs_hba *hba)\n{\n\tstruct ufs_qcom_host *host = hba->priv;\n\tstruct ufs_pa_layer_attr *dev_req_params = &host->dev_req_params;\n\tif (!dev_req_params)\n\t\treturn;\n\tufs_qcom_cfg_timers(hba, dev_req_params->gear_rx,\n\t\t\t\tdev_req_params->pwr_rx,\n\t\t\t\tdev_req_params->hs_rate);\n"]]}
{"hexsha": "751529a0216635b6d41da94bb4662327459fd5b6", "ext": "h", "lang": "C", "content": "namespace MediaPlayer\n{\n    /// Service offer player widget for video content.\n    ///\n    class ServiceInterface : public QObject, public Foundation::ServiceInterface \n    {\n        Q_OBJECT\n    public:\n        virtual ~ServiceInterface() {};\n    public slots:\n        virtual bool IsMimeTypeSupported(const QString &mime_type) = 0;\n\n        /// Gives player widget playing given media in eternal loop.\n        /// If player is asked more than once for same url only one instance of player \n        /// widget is created and returned.\n        /// @param url url of video content\n        /// @return pointer to player widget if success otherwise return 0.\n        virtual QWidget* GetPlayerWidget(const QString &url) = 0;\n\n        /// Delete existing video widget associated with given url.\n        /// Be sure that you are not using the player widget after you have called this method.\n        /// @param url url of video content\n        virtual void DeletePlayerWidget(const QString &url) = 0;\n    }", "item_id": 0, "repo": "mattire/naali", "file": "Interfaces/MediaPlayerService.h", "last_update_at": "2018-04-02T15:38:10+00:00", "question_id": "751529a0216635b6d41da94bb4662327459fd5b6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace MediaPlayer\n{\n    /// Service offer player widget for video content.\n    ///\n    class ServiceInterface : public QObject, public Foundation::ServiceInterface \n    {\n        Q_OBJECT\n    public:\n        virtual ~ServiceInterface() {};\n    public slots:\n        virtual bool IsMimeTypeSupported(const QString &mime_type) = 0;\n        /// Gives player widget playing given media in eternal loop.\n        /// If player is asked more than once for same url only one instance of player \n        /// widget is created and returned.\n        /// @param url url of video content\n        /// @return pointer to player widget if success otherwise return 0.\n        virtual QWidget* GetPlayerWidget(const QString &url) = 0;\n        /// Delete existing video widget associated with given url.\n        /// Be sure that you are not using the player widget after you have called this method.\n        /// @param url url of video content\n        virtual void DeletePlayerWidget(const QString &url) = 0;\n"]]}
{"hexsha": "87a485c65a80ec2f246d08c28cec28ad3a0b6666", "ext": "c", "lang": "C", "content": "static AccCache *CreateAccCache(XFInfo *xfinfo, const int b)\n{\n   AccCache *ac;\n   IntVec size;\n   int vsize, bl;\n\n   size = GetBlockSize(xfinfo,b),\n   \n   vsize = 0;\n   for (bl=1;bl<=IntVecSize(size);bl++) vsize += size[bl];\n   \n   ac = (AccCache *)New(&obcaStack,sizeof(AccCache));\n   ac->baseclass = b;\n   ac->bVector  = CreateDVector(&obcaStack,vsize); \n   ZeroDVector(ac->bVector);\n   ac->bTriMat = CreateBlockTriMat(&obcaStack,size);    \n   ZeroBlockTriMat(ac->bTriMat);\n   ac->next = xfinfo->headac;\n   xfinfo->headac = ac;\n   return(ac);\n}", "item_id": 48, "repo": "didw/HTS", "file": "HTKLib/HAdapt.c", "last_update_at": "2018-04-19T08:30:07+00:00", "question_id": "87a485c65a80ec2f246d08c28cec28ad3a0b6666_48", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static AccCache *CreateAccCache(XFInfo *xfinfo, const int b)\n{\n   AccCache *ac;\n   IntVec size;\n   int vsize, bl;\n   size = GetBlockSize(xfinfo,b),\n   vsize = 0;\n   for (bl=1;bl<=IntVecSize(size);bl++) vsize += size[bl];\n   ac = (AccCache *)New(&obcaStack,sizeof(AccCache));\n   ac->baseclass = b;\n   ac->bVector  = CreateDVector(&obcaStack,vsize); \n   ZeroDVector(ac->bVector);\n   ac->bTriMat = CreateBlockTriMat(&obcaStack,size);    \n   ZeroBlockTriMat(ac->bTriMat);\n   ac->next = xfinfo->headac;\n   xfinfo->headac = ac;\n   return(ac);\n"]]}
{"hexsha": "85723ec87beec8d68c7e1023c556465fb50781af", "ext": "c", "lang": "C", "content": "int target_ftm_set_bootchart(char status)\n{\n\tint ret;\n\n\tret = ftm_set_item(LGFTM_BOOTCHART, &status);\n\n\tif (ret < 0)\n\t\treturn -1;\n\n\treturn 0;\n}", "item_id": 10, "repo": "jaehyek/lk", "file": "target/msm8952_common/lge_target_ftm.c", "last_update_at": "2018-09-16T12:35:42+00:00", "question_id": "85723ec87beec8d68c7e1023c556465fb50781af_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int target_ftm_set_bootchart(char status)\n{\n\tint ret;\n\tret = ftm_set_item(LGFTM_BOOTCHART, &status);\n\tif (ret < 0)\n\t\treturn -1;\n\treturn 0;\n"]]}
{"hexsha": "e7a2c51d3199d3fb5bce34f37f2f52f32e83a636", "ext": "c", "lang": "C", "content": "int\nmain(argc, argv)\n\tint argc;\n\tregister char *argv[];\n{\n\tint ch, errs;\n\n\t/* Start disks transferring immediately. */\n\tsync();\n\n\twhile ((ch = getopt(argc, argv, \"aFft:v\")) != EOF)\n\t\tswitch (ch) {\n\t\tcase 'a':\n\t\t\tallflag = 1;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tfake = 1;\n\t\t\tbreak;\n\t\tcase 'f':\n#ifdef\tnotnow\n\t\t\tfflag = MNT_FORCE;\n#endif\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tmaketypelist(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tvflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\t/* NOTREACHED */\n\t\t}\n\targc -= optind;\n\targv += optind;\n\n\tif (argc == 0 && !allflag || argc != 0 && allflag)\n\t\tusage();\n\n\tif (allflag) {\n\t\tif (setfsent() == 0)\n\t\t\terr(1, \"%s\", _PATH_FSTAB);\n\t\terrs = umountall();\n\t} else\n\t\tfor (errs = 0; *argv != NULL; ++argv)\n\t\t\tif (umountfs(*argv) == 0)\n\t\t\t\terrs = 1;\n\texit(errs);\n}", "item_id": 0, "repo": "igor-m/retrobsd-with-double-precison", "file": "src/cmd/umount/umount.c", "last_update_at": "2018-02-22T20:42:10+00:00", "question_id": "e7a2c51d3199d3fb5bce34f37f2f52f32e83a636_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nmain(argc, argv)\n\tint argc;\n\tregister char *argv[];\n{\n\tint ch, errs;\n\t/* Start disks transferring immediately. */\n\tsync();\n\twhile ((ch = getopt(argc, argv, \"aFft:v\")) != EOF)\n\t\tswitch (ch) {\n\t\tcase 'a':\n\t\t\tallflag = 1;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tfake = 1;\n\t\t\tbreak;\n\t\tcase 'f':\n#ifdef\tnotnow\n\t\t\tfflag = MNT_FORCE;\n#endif\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tmaketypelist(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tvflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\t/* NOTREACHED */\n\t\t}\n\targc -= optind;\n\targv += optind;\n\tif (argc == 0 && !allflag || argc != 0 && allflag)\n\t\tusage();\n\tif (allflag) {\n\t\tif (setfsent() == 0)\n\t\t\terr(1, \"%s\", _PATH_FSTAB);\n\t\terrs = umountall();\n\t} else\n\t\tfor (errs = 0; *argv != NULL; ++argv)\n\t\t\tif (umountfs(*argv) == 0)\n\t\t\t\terrs = 1;\n\texit(errs);\n"]]}
{"hexsha": "88ce019626ef8aeb971c637606c6eb7aec4e27f6", "ext": "h", "lang": "C", "content": "class FilterRender {\npublic:\n\tstatic void* render(void *data, uint width, uint height, Config* config);\n\nprivate:\n\tstatic void* doFlip(void *data, uint width, uint height, bool isLR);\n\tstatic void* doSlice(void *data, uint width, uint height, std::vector<Geometry::Point>);\n\tstatic void* doColor(void *data, uint width, uint height, u_int8_t r, u_int8_t g, u_int8_t b ,u_int8_t a);\n\tstatic void* doAuto(void *data, uint width, uint height);\n}", "item_id": 0, "repo": "louisja1/SlicerCore", "file": "src/FilterRender.h", "last_update_at": "2018-06-26T08:04:10+00:00", "question_id": "88ce019626ef8aeb971c637606c6eb7aec4e27f6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class FilterRender {\npublic:\n\tstatic void* render(void *data, uint width, uint height, Config* config);\nprivate:\n\tstatic void* doFlip(void *data, uint width, uint height, bool isLR);\n\tstatic void* doSlice(void *data, uint width, uint height, std::vector<Geometry::Point>);\n\tstatic void* doColor(void *data, uint width, uint height, u_int8_t r, u_int8_t g, u_int8_t b ,u_int8_t a);\n\tstatic void* doAuto(void *data, uint width, uint height);\n"]]}
{"hexsha": "fecd166f4c24431102ac68587ad03086e10c5612", "ext": "c", "lang": "C", "content": "void nextThread() {\n\tif(currentProcess->process.currentThread->thread.status == RUNNING) {\n\t\tcurrentProcess->process.currentThread->thread.status = READY;\n\t}\n\t\n\tif(currentProcess->process.currentThread->next == NULL){\n\t\t\n\t\tcurrentProcess->process.currentThread = currentProcess->process.threads;\n\t\t\n\t\tif(currentProcess->process.currentThread->thread.status == READY){\n\t\t\tcurrentProcess->process.currentThread->thread.status = RUNNING;\n\t\t\treturn;\n\t\t}\n\t}\n\t\t\n\twhile(currentProcess->process.currentThread->next->thread.status != READY) {\n\t\tcurrentProcess->process.currentThread = currentProcess->process.currentThread->next;\t\n\t}\n\n\tcurrentProcess->process.currentThread = currentProcess->process.currentThread->next;\n\tcurrentProcess->process.currentThread->thread.status = RUNNING;\n\n}", "item_id": 13, "repo": "asantoflaminio/TP2_SO", "file": "Kernel/scheduler.c", "last_update_at": "2018-05-17T19:08:44+00:00", "question_id": "fecd166f4c24431102ac68587ad03086e10c5612_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void nextThread() {\n\tif(currentProcess->process.currentThread->thread.status == RUNNING) {\n\t\tcurrentProcess->process.currentThread->thread.status = READY;\n\t}\n\t\n\tif(currentProcess->process.currentThread->next == NULL){\n\t\t\n\t\tcurrentProcess->process.currentThread = currentProcess->process.threads;\n\t\t\n\t\tif(currentProcess->process.currentThread->thread.status == READY){\n\t\t\tcurrentProcess->process.currentThread->thread.status = RUNNING;\n\t\t\treturn;\n\t\t}\n\t}\n\t\t\n\twhile(currentProcess->process.currentThread->next->thread.status != READY) {\n\t\tcurrentProcess->process.currentThread = currentProcess->process.currentThread->next;\t\n\t}\n\tcurrentProcess->process.currentThread = currentProcess->process.currentThread->next;\n\tcurrentProcess->process.currentThread->thread.status = RUNNING;\n"]]}
{"hexsha": "6a8959b9373cae4321b3da9a46b94332c12fffc0", "ext": "c", "lang": "C", "content": "void* listen_for_command(void* arg)\n{\n\tint sock = socket(AF_INET, SOCK_DGRAM, 0);       //socket initailization\n\tstruct sockaddr_storage serverAddr;\n\tchar myMsg[1024];\n\t//char stop = ' ';\n\t_Bool stopping = false;\n\tint b;\n\n\t//binding \n\tstruct sockaddr_in sockName;\n\tmemset((char*)&sockName, 0, sizeof(sockName));\n\tsockName.sin_family = AF_INET;\n\tsockName.sin_port = htons(SERVER_PORT);\n\tsockName.sin_addr.s_addr = htonl(INADDR_ANY);\n\tsocklen_t serverAddrSize;\n\n\tif(bind(sock, (struct sockaddr *)&sockName, sizeof(sockName)))\n\t{\n\t\tperror(\"binding failed\");\n\t\texit(1);\n\t}\n\t\n\tserverAddrSize = sizeof(serverAddr);\n\t\n\t//send msg to server\n\twhile((b = recvfrom(sock, myMsg, 1024, 0, (struct sockaddr *)&serverAddr, &serverAddrSize)) > 0 && !stopping)\n\t{\n\t\tmyMsg[b] = '\\0';\n\t\tprintf(\"%d\\n\", myMsg[b]);\n\t\tchar* msgsss = verifyCommand(myMsg, sock, serverAddr);\n\t\tif (strcmp(msgsss, \"stop\\n\") == 0)\n\t\t{\n\t\t\tstopping = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tsendto(sock, msgsss, 1024, 0, (struct sockaddr *)&serverAddr, serverAddrSize);\n\t\tfree(msgsss);\n\t}\n\t\n\tclose(sock);\n\tpthread_exit(0);\n}", "item_id": 10, "repo": "wasong/cmpt433", "file": "as3_alt/server.c", "last_update_at": "2018-07-01T01:16:57+00:00", "question_id": "6a8959b9373cae4321b3da9a46b94332c12fffc0_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void* listen_for_command(void* arg)\n{\n\tint sock = socket(AF_INET, SOCK_DGRAM, 0);       //socket initailization\n\tstruct sockaddr_storage serverAddr;\n\tchar myMsg[1024];\n\t//char stop = ' ';\n\t_Bool stopping = false;\n\tint b;\n\t//binding \n\tstruct sockaddr_in sockName;\n\tmemset((char*)&sockName, 0, sizeof(sockName));\n\tsockName.sin_family = AF_INET;\n\tsockName.sin_port = htons(SERVER_PORT);\n\tsockName.sin_addr.s_addr = htonl(INADDR_ANY);\n\tsocklen_t serverAddrSize;\n\tif(bind(sock, (struct sockaddr *)&sockName, sizeof(sockName)))\n\t{\n\t\tperror(\"binding failed\");\n\t\texit(1);\n\t}\n\t\n\tserverAddrSize = sizeof(serverAddr);\n\t\n\t//send msg to server\n\twhile((b = recvfrom(sock, myMsg, 1024, 0, (struct sockaddr *)&serverAddr, &serverAddrSize)) > 0 && !stopping)\n\t{\n\t\tmyMsg[b] = '\\0';\n\t\tprintf(\"%d\\n\", myMsg[b]);\n\t\tchar* msgsss = verifyCommand(myMsg, sock, serverAddr);\n\t\tif (strcmp(msgsss, \"stop\\n\") == 0)\n\t\t{\n\t\t\tstopping = true;\n\t\t\tbreak;\n\t\t}\n\t\tsendto(sock, msgsss, 1024, 0, (struct sockaddr *)&serverAddr, serverAddrSize);\n\t\tfree(msgsss);\n\t}\n\t\n\tclose(sock);\n\tpthread_exit(0);\n"]]}
{"hexsha": "d4e46a36351257641c3bc85db38f2fbdf6396eef", "ext": "h", "lang": "C", "content": "static inline void ahci_port_clb_wr(__DN(t) *_dev, uint64_t _regval)\n{\n    // No MB0 or RSVD fields present\n    // No MB1 fields present\n    // No pre-read of register required\n    mackerel_write_addr_64(_dev->b, 0x0, _regval);\n}", "item_id": 14, "repo": "daleoooo/barrelfish", "file": "build/x86_64/include/dev/ahci_port_dev.h", "last_update_at": "2018-03-30T08:02:50+00:00", "question_id": "d4e46a36351257641c3bc85db38f2fbdf6396eef_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void ahci_port_clb_wr(__DN(t) *_dev, uint64_t _regval)\n{\n    // No MB0 or RSVD fields present\n    // No MB1 fields present\n    // No pre-read of register required\n    mackerel_write_addr_64(_dev->b, 0x0, _regval);\n"]]}
{"hexsha": "75ad89e0870041af48629ba90d9e4baf8ef9a5b0", "ext": "c", "lang": "C", "content": "static void ae_test_read(ae_mux_t *self,\n                         const struct epoll_event *event,\n                         void *ctx)\n{\n     uint64_t overflows = 0;\n     ae_res_t e;\n     ae_res_init(&e);\n     if(!ae_timer_read(&e, ctx, &overflows))\n     {\n          AE_LR(&e);\n          return;\n     }\n     \n     AE_LD(\"sup: %\"PRIu64\"\", overflows);\n}", "item_id": 0, "repo": "jopeg/libae", "file": "test/ae-test.c", "last_update_at": "2018-07-03T16:58:33+00:00", "question_id": "75ad89e0870041af48629ba90d9e4baf8ef9a5b0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void ae_test_read(ae_mux_t *self,\n                         const struct epoll_event *event,\n                         void *ctx)\n{\n     uint64_t overflows = 0;\n     ae_res_t e;\n     ae_res_init(&e);\n     if(!ae_timer_read(&e, ctx, &overflows))\n     {\n          AE_LR(&e);\n          return;\n     }\n     AE_LD(\"sup: %\"PRIu64\"\", overflows);\n"]]}
{"hexsha": "5d9c804e9b3caeb80be46cb8cb59b21ad4f48d66", "ext": "c", "lang": "C", "content": "static int\ncheckaddfile (file, repository, tag, options, rcsnode)\n    char *file;\n    char *repository;\n    char *tag;\n    char *options;\n    RCSNode **rcsnode;\n{\n    char rcs[PATH_MAX];\n    char fname[PATH_MAX];\n    mode_t omask;\n    int retcode = 0;\n    int newfile = 0;\n    RCSNode *rcsfile = NULL;\n\n    if (tag)\n    {\n        (void) sprintf (rcs, \"%s/%s%s\", repository, file, RCSEXT);\n\tif (! isreadable (rcs))\n\t{\n\t    (void) sprintf(rcs, \"%s/%s\", repository, CVSATTIC);\n\t    omask = umask (cvsumask);\n\t    if (CVS_MKDIR (rcs, 0777) != 0 && errno != EEXIST)\n\t\terror (1, errno, \"cannot make directory `%s'\", rcs);;\n\t    (void) umask (omask);\n\t    (void) sprintf (rcs, \"%s/%s/%s%s\", repository, CVSATTIC, file,\n\t\t\t    RCSEXT);\n\t}\n    }\n    else\n\tlocate_rcs (file, repository, rcs);\n\n    if (isreadable(rcs))\n    {\n\t/* file has existed in the past.  Prepare to resurrect. */\n\tchar oldfile[PATH_MAX];\n\tchar *rev;\n\n\tif ((rcsfile = *rcsnode) == NULL)\n\t{\n\t    error (0, 0, \"could not find parsed rcsfile %s\", file);\n\t    return (1);\n\t}\n\n\tif (tag == NULL)\n\t{\n\t    /* we are adding on the trunk, so move the file out of the\n\t       Attic. */\n\t    strcpy (oldfile, rcs);\n\t    sprintf (rcs, \"%s/%s%s\", repository, file, RCSEXT);\n\t    \n\t    if (strcmp (oldfile, rcs) == 0\n\t\t|| CVS_RENAME (oldfile, rcs) != 0\n\t\t|| isreadable (oldfile)\n\t\t|| !isreadable (rcs))\n\t    {\n\t\terror (0, 0, \"failed to move `%s' out of the attic.\",\n\t\t       file);\n\t\treturn (1);\n\t    }\n\t    free (rcsfile->path);\n\t    rcsfile->path = xstrdup (rcs);\n\t}\n\n\trev = RCS_getversion (rcsfile, tag, NULL, 1, (int *) NULL);\n\t/* and lock it */\n\tif (lock_RCS (file, rcsfile, rev, repository)) {\n\t    error (0, 0, \"cannot lock `%s'.\", rcs);\n\t    free (rev);\n\t    return (1);\n\t}\n\n\tfree (rev);\n    } else {\n\t/* this is the first time we have ever seen this file; create\n\t   an rcs file.  */\n\trun_setup (\"%s%s -x,v/ -i\", Rcsbin, RCS);\n\n\t(void) sprintf (fname, \"%s/%s%s\", CVSADM, file, CVSEXT_LOG);\n\t/* If the file does not exist, no big deal.  In particular, the\n\t   server does not (yet at least) create CVSEXT_LOG files.  */\n\tif (isfile (fname))\n\t    run_args (\"-t%s/%s%s\", CVSADM, file, CVSEXT_LOG);\n\n\t/* Set RCS keyword expansion options.  */\n\tif (options && options[0] == '-' && options[1] == 'k')\n\t    run_arg (options);\n\trun_arg (rcs);\n\tif ((retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL)) != 0)\n\t{\n\t    error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,\n\t\t   \"could not create %s\", rcs);\n\t    return (1);\n\t}\n\tnewfile = 1;\n    }\n\n    /* when adding a file for the first time, and using a tag, we need\n       to create a dead revision on the trunk.  */\n    if (tag && newfile)\n    {\n\tchar *tmp;\n\n\t/* move the new file out of the way. */\n\t(void) sprintf (fname, \"%s/%s%s\", CVSADM, CVSPREFIX, file);\n\trename_file (file, fname);\n\tcopy_file (DEVNULL, file);\n\n\ttmp = xmalloc (strlen (file) + strlen (tag) + 80);\n\t/* commit a dead revision. */\n\t(void) sprintf (tmp, \"file %s was initially added on branch %s.\",\n\t\t\tfile, tag);\n\tretcode = RCS_checkin (rcs, NULL, tmp, NULL,\n\t\t\t       RCS_FLAGS_DEAD | RCS_FLAGS_QUIET);\n\tfree (tmp);\n\tif (retcode != 0)\n\t{\n\t    error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,\n\t\t   \"could not create initial dead revision %s\", rcs);\n\t    return (1);\n\t}\n\n\t/* put the new file back where it was */\n\trename_file (fname, file);\n\n\tassert (rcsfile == NULL);\n\trcsfile = RCS_parse (file, repository);\n\tif (rcsfile == NULL)\n\t{\n\t    error (0, 0, \"could not read %s\", rcs);\n\t    return (1);\n\t}\n\tif (rcsnode != NULL)\n\t{\n\t    assert (*rcsnode == NULL);\n\t    *rcsnode = rcsfile;\n\t}\n\n\t/* and lock it once again. */\n\tif (lock_RCS (file, rcsfile, NULL, repository)) {\n\t    error (0, 0, \"cannot lock `%s'.\", rcs);\n\t    return (1);\n\t}\n    }\n\n    if (tag != NULL)\n    {\n\t/* when adding with a tag, we need to stub a branch, if it\n\t   doesn't already exist.  */\n\n\tif (rcsfile == NULL)\n\t{\n\t    if (rcsnode != NULL && *rcsnode != NULL)\n\t\trcsfile = *rcsnode;\n\t    else\n\t    {\n\t\trcsfile = RCS_parse (file, repository);\n\t\tif (rcsfile == NULL)\n\t\t{\n\t\t    error (0, 0, \"could not read %s\", rcs);\n\t\t    return (1);\n\t\t}\n\t    }\n\t}\n\n\tif (!RCS_nodeisbranch (rcsfile, tag)) {\n\t    /* branch does not exist.  Stub it.  */\n\t    char *head;\n\t    char *magicrev;\n\t    \n\t    head = RCS_getversion (rcsfile, NULL, NULL, 0, (int *) NULL);\n\t    magicrev = RCS_magicrev (rcsfile, head);\n\n\t    retcode = RCS_settag (rcsfile, tag, magicrev);\n\n\t    free (head);\n\t    free (magicrev);\n\n\t    if (retcode != 0)\n\t    {\n\t\terror (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,\n\t\t       \"could not stub branch %s for %s\", tag, rcs);\n\t\treturn (1);\n\t    }\n\t}\n\telse\n\t{\n\t    /* lock the branch. (stubbed branches need not be locked.)  */\n\t    if (lock_RCS (file, rcsfile, NULL, repository)) {\n\t\terror (0, 0, \"cannot lock `%s'.\", rcs);\n\t\treturn (1);\n\t    }\n\t} \n\n\tif (rcsnode && *rcsnode != rcsfile)\n\t{\n\t    freercsnode(rcsnode);\n\t    *rcsnode = rcsfile;\n\t}\n    }\n\n    fileattr_newfile (file);\n\n    fix_rcs_modes (rcs, file);\n    return (0);\n}", "item_id": 18, "repo": "aaliomer/exos", "file": "bin/CVS/src/commit.c", "last_update_at": "2018-01-23T23:07:19+00:00", "question_id": "5d9c804e9b3caeb80be46cb8cb59b21ad4f48d66_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\ncheckaddfile (file, repository, tag, options, rcsnode)\n    char *file;\n    char *repository;\n    char *tag;\n    char *options;\n    RCSNode **rcsnode;\n{\n    char rcs[PATH_MAX];\n    char fname[PATH_MAX];\n    mode_t omask;\n    int retcode = 0;\n    int newfile = 0;\n    RCSNode *rcsfile = NULL;\n    if (tag)\n    {\n        (void) sprintf (rcs, \"%s/%s%s\", repository, file, RCSEXT);\n\tif (! isreadable (rcs))\n\t{\n\t    (void) sprintf(rcs, \"%s/%s\", repository, CVSATTIC);\n\t    omask = umask (cvsumask);\n\t    if (CVS_MKDIR (rcs, 0777) != 0 && errno != EEXIST)\n\t\terror (1, errno, \"cannot make directory `%s'\", rcs);;\n\t    (void) umask (omask);\n\t    (void) sprintf (rcs, \"%s/%s/%s%s\", repository, CVSATTIC, file,\n\t\t\t    RCSEXT);\n\t}\n    }\n    else\n\tlocate_rcs (file, repository, rcs);\n    if (isreadable(rcs))\n    {\n\t/* file has existed in the past.  Prepare to resurrect. */\n\tchar oldfile[PATH_MAX];\n\tchar *rev;\n\tif ((rcsfile = *rcsnode) == NULL)\n\t{\n\t    error (0, 0, \"could not find parsed rcsfile %s\", file);\n\t    return (1);\n\t}\n\tif (tag == NULL)\n\t{\n\t    /* we are adding on the trunk, so move the file out of the\n\t       Attic. */\n\t    strcpy (oldfile, rcs);\n\t    sprintf (rcs, \"%s/%s%s\", repository, file, RCSEXT);\n\t    \n\t    if (strcmp (oldfile, rcs) == 0\n\t\t|| CVS_RENAME (oldfile, rcs) != 0\n\t\t|| isreadable (oldfile)\n\t\t|| !isreadable (rcs))\n\t    {\n\t\terror (0, 0, \"failed to move `%s' out of the attic.\",\n\t\t       file);\n\t\treturn (1);\n\t    }\n\t    free (rcsfile->path);\n\t    rcsfile->path = xstrdup (rcs);\n\t}\n\trev = RCS_getversion (rcsfile, tag, NULL, 1, (int *) NULL);\n\t/* and lock it */\n\tif (lock_RCS (file, rcsfile, rev, repository)) {\n\t    error (0, 0, \"cannot lock `%s'.\", rcs);\n\t    free (rev);\n\t    return (1);\n\t}\n\tfree (rev);\n    } else {\n\t/* this is the first time we have ever seen this file; create\n\t   an rcs file.  */\n\trun_setup (\"%s%s -x,v/ -i\", Rcsbin, RCS);\n\t(void) sprintf (fname, \"%s/%s%s\", CVSADM, file, CVSEXT_LOG);\n\t/* If the file does not exist, no big deal.  In particular, the\n\t   server does not (yet at least) create CVSEXT_LOG files.  */\n\tif (isfile (fname))\n\t    run_args (\"-t%s/%s%s\", CVSADM, file, CVSEXT_LOG);\n\t/* Set RCS keyword expansion options.  */\n\tif (options && options[0] == '-' && options[1] == 'k')\n\t    run_arg (options);\n\trun_arg (rcs);\n\tif ((retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL)) != 0)\n\t{\n\t    error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,\n\t\t   \"could not create %s\", rcs);\n\t    return (1);\n\t}\n\tnewfile = 1;\n    }\n    /* when adding a file for the first time, and using a tag, we need\n       to create a dead revision on the trunk.  */\n    if (tag && newfile)\n    {\n\tchar *tmp;\n\t/* move the new file out of the way. */\n\t(void) sprintf (fname, \"%s/%s%s\", CVSADM, CVSPREFIX, file);\n\trename_file (file, fname);\n\tcopy_file (DEVNULL, file);\n\ttmp = xmalloc (strlen (file) + strlen (tag) + 80);\n\t/* commit a dead revision. */\n\t(void) sprintf (tmp, \"file %s was initially added on branch %s.\",\n\t\t\tfile, tag);\n\tretcode = RCS_checkin (rcs, NULL, tmp, NULL,\n\t\t\t       RCS_FLAGS_DEAD | RCS_FLAGS_QUIET);\n\tfree (tmp);\n\tif (retcode != 0)\n\t{\n\t    error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,\n\t\t   \"could not create initial dead revision %s\", rcs);\n\t    return (1);\n\t}\n\t/* put the new file back where it was */\n\trename_file (fname, file);\n\tassert (rcsfile == NULL);\n\trcsfile = RCS_parse (file, repository);\n\tif (rcsfile == NULL)\n\t{\n\t    error (0, 0, \"could not read %s\", rcs);\n\t    return (1);\n\t}\n\tif (rcsnode != NULL)\n\t{\n\t    assert (*rcsnode == NULL);\n\t    *rcsnode = rcsfile;\n\t}\n\t/* and lock it once again. */\n\tif (lock_RCS (file, rcsfile, NULL, repository)) {\n\t    error (0, 0, \"cannot lock `%s'.\", rcs);\n\t    return (1);\n\t}\n    }\n    if (tag != NULL)\n    {\n\t/* when adding with a tag, we need to stub a branch, if it\n\t   doesn't already exist.  */\n\tif (rcsfile == NULL)\n\t{\n\t    if (rcsnode != NULL && *rcsnode != NULL)\n\t\trcsfile = *rcsnode;\n\t    else\n\t    {\n\t\trcsfile = RCS_parse (file, repository);\n\t\tif (rcsfile == NULL)\n\t\t{\n\t\t    error (0, 0, \"could not read %s\", rcs);\n\t\t    return (1);\n\t\t}\n\t    }\n\t}\n\tif (!RCS_nodeisbranch (rcsfile, tag)) {\n\t    /* branch does not exist.  Stub it.  */\n\t    char *head;\n\t    char *magicrev;\n\t    \n\t    head = RCS_getversion (rcsfile, NULL, NULL, 0, (int *) NULL);\n\t    magicrev = RCS_magicrev (rcsfile, head);\n\t    retcode = RCS_settag (rcsfile, tag, magicrev);\n\t    free (head);\n\t    free (magicrev);\n\t    if (retcode != 0)\n\t    {\n\t\terror (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,\n\t\t       \"could not stub branch %s for %s\", tag, rcs);\n\t\treturn (1);\n\t    }\n\t}\n\telse\n\t{\n\t    /* lock the branch. (stubbed branches need not be locked.)  */\n\t    if (lock_RCS (file, rcsfile, NULL, repository)) {\n\t\terror (0, 0, \"cannot lock `%s'.\", rcs);\n\t\treturn (1);\n\t    }\n\t} \n\tif (rcsnode && *rcsnode != rcsfile)\n\t{\n\t    freercsnode(rcsnode);\n\t    *rcsnode = rcsfile;\n\t}\n    }\n    fileattr_newfile (file);\n    fix_rcs_modes (rcs, file);\n    return (0);\n"]]}
{"hexsha": "fa66449539d2c49041222f397900aed9c04acb03", "ext": "c", "lang": "C", "content": "quatd_t\nqd_slerp(quatd_t q0, quatd_t q1, double t)\n{\n  // See http://en.wikipedia.org/wiki/Slerp\n  if (t >= 1.0) return q1;\n  if (t <= 0.0) return q0;\n\n  double qdot = qd_dot(q0, q1);\n\n  quatd_t q1prim;\n  if (qdot < 0.0) {\n    q1prim = -q1;\n    qdot = -qdot;\n  } else {\n    q1prim = q1;\n  }\n\n  if (qdot < -1.0)  qdot = -1.0;\n  if (qdot > 1.0)  qdot = 1.0;\n  assert(qdot >= -1.0);\n  assert(qdot <= 1.0);\n\n  double qang = acos(qdot);\n  double s0 = sin((1.0-t)*qang) / sin(qang);\n  double s1 = sin(t*qang) / sin(qang);\n\n  if (qang) { // If slerping between the same points, qang will be 0, so s0 will be NaN or Inf.\n    quatd_t res = s0 * q0 + s1 * q1prim;\n    return res;\n  }\n\n  return q0;\n}", "item_id": 11, "repo": "openorbit/vmath", "file": "src/vmath-quaternions.c", "last_update_at": "2018-09-13T02:13:20+00:00", "question_id": "fa66449539d2c49041222f397900aed9c04acb03_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["quatd_t\nqd_slerp(quatd_t q0, quatd_t q1, double t)\n{\n  // See http://en.wikipedia.org/wiki/Slerp\n  if (t >= 1.0) return q1;\n  if (t <= 0.0) return q0;\n  double qdot = qd_dot(q0, q1);\n  quatd_t q1prim;\n  if (qdot < 0.0) {\n    q1prim = -q1;\n    qdot = -qdot;\n  } else {\n    q1prim = q1;\n  }\n  if (qdot < -1.0)  qdot = -1.0;\n  if (qdot > 1.0)  qdot = 1.0;\n  assert(qdot >= -1.0);\n  assert(qdot <= 1.0);\n  double qang = acos(qdot);\n  double s0 = sin((1.0-t)*qang) / sin(qang);\n  double s1 = sin(t*qang) / sin(qang);\n  if (qang) { // If slerping between the same points, qang will be 0, so s0 will be NaN or Inf.\n    quatd_t res = s0 * q0 + s1 * q1prim;\n    return res;\n  }\n  return q0;\n"]]}
{"hexsha": "3e0596414bff363fd84683ef6318e53f7a3abc1d", "ext": "c", "lang": "C", "content": "static void ROL() {\n    BYTE result = cpu.operand << 1;\n    result |= GET_FLAG(FLAG_C);\n    CALC_C(cpu.operand & 0x80);\n    CALC_Z(result);\n    CALC_N(result);\n    Memory_WriteByte(MAP_CPU, cpu.operaddr, result);\n}", "item_id": 24, "repo": "allie/badpce", "file": "src/cpu/instructions.partial.c", "last_update_at": "2018-09-02T23:40:36+00:00", "question_id": "3e0596414bff363fd84683ef6318e53f7a3abc1d_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void ROL() {\n    BYTE result = cpu.operand << 1;\n    result |= GET_FLAG(FLAG_C);\n    CALC_C(cpu.operand & 0x80);\n    CALC_Z(result);\n    CALC_N(result);\n    Memory_WriteByte(MAP_CPU, cpu.operaddr, result);\n"]]}
{"hexsha": "a2f9fca1f77fe001b017d5314ebe479483ffd5d2", "ext": "h", "lang": "C", "content": "interface MPCRadioStreamPing : NSObject {\n    double  _timestamp;\n    long long  _type;\n    NSData * _value;\n}", "item_id": 0, "repo": "shaojiankui/iOS10-Runtime-Headers", "file": "PrivateFrameworks/MediaPlaybackCore.framework/MPCRadioStreamPing.h", "last_update_at": "2018-10-08T04:12:25+00:00", "question_id": "a2f9fca1f77fe001b017d5314ebe479483ffd5d2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface MPCRadioStreamPing : NSObject {\n    double  _timestamp;\n    long long  _type;\n    NSData * _value;\n"]]}
{"hexsha": "1c043b91bd954aa5b04f5dd18116b5d6ba31c942", "ext": "c", "lang": "C", "content": "static unsigned int __stdcall _oi_thread_handler(void * args) {\n    (*((thread_t*)args)->func)(((thread_t*)args)->data);\n    _endthreadex(0);\n    return 0;\n}", "item_id": 0, "repo": "geky/oi", "file": "src/oi/thread.c", "last_update_at": "2018-01-14T01:07:07+00:00", "question_id": "1c043b91bd954aa5b04f5dd18116b5d6ba31c942_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static unsigned int __stdcall _oi_thread_handler(void * args) {\n    (*((thread_t*)args)->func)(((thread_t*)args)->data);\n    _endthreadex(0);\n    return 0;\n"]]}
{"hexsha": "acdea7d84dbadf50e03f33dece646ce6a8cc9293", "ext": "h", "lang": "C", "content": "class idCompiler\n{\nprivate:\n\tstatic bool\t\tpunctuationValid[ 256 ];\n\t// RB begin\n\tstatic const char*\t\tpunctuation[];\n\t// RB end\n\t\n\tidParser\t\tparser;\n\tidParser*\t\tparserPtr;\n\tidToken\t\t\ttoken;\n\t\n\tidTypeDef*\t\timmediateType;\n\teval_t\t\t\timmediate;\n\t\n\tbool\t\t\teof;\n\tbool\t\t\tconsole;\n\tbool\t\t\tcallthread;\n\tint\t\t\t\tbraceDepth;\n\tint\t\t\t\tloopDepth;\n\tint\t\t\t\tcurrentLineNumber;\n\tint\t\t\t\tcurrentFileNumber;\n\tint\t\t\t\terrorCount;\n\t\n\tidVarDef*\t\tscope;\t\t\t\t// the function being parsed, or NULL\n\tconst idVarDef*\tbasetype;\t\t\t// for accessing fields\n\t\n\tfloat\t\t\tDivide( float numerator, float denominator );\n\tvoid\t\t\tError( VERIFY_FORMAT_STRING const char* error, ... ) const;\n\tvoid\t\t\tWarning( VERIFY_FORMAT_STRING const char* message, ... ) const;\n\tidVarDef*\t\tOptimizeOpcode( const opcode_t* op, idVarDef* var_a, idVarDef* var_b );\n\tidVarDef*\t\tEmitOpcode( const opcode_t* op, idVarDef* var_a, idVarDef* var_b );\n\tidVarDef*\t\tEmitOpcode( int op, idVarDef* var_a, idVarDef* var_b );\n\tbool\t\t\tEmitPush( idVarDef* expression, const idTypeDef* funcArg );\n\tvoid\t\t\tNextToken();\n\tvoid\t\t\tExpectToken( const char* string );\n\tbool\t\t\tCheckToken( const char* string );\n\tvoid\t\t\tParseName( idStr& name );\n\tvoid\t\t\tSkipOutOfFunction();\n\tvoid\t\t\tSkipToSemicolon();\n\tidTypeDef*\t\tCheckType();\n\tidTypeDef*\t\tParseType();\n\tidVarDef*\t\tFindImmediate( const idTypeDef* type, const eval_t* eval, const char* string ) const;\n\tidVarDef*\t\tGetImmediate( idTypeDef* type, const eval_t* eval, const char* string );\n\tidVarDef*\t\tVirtualFunctionConstant( idVarDef* func );\n\tidVarDef*\t\tSizeConstant( int size );\n\tidVarDef*\t\tJumpConstant( int value );\n\tidVarDef*\t\tJumpDef( int jumpfrom, int jumpto );\n\tidVarDef*\t\tJumpTo( int jumpto );\n\tidVarDef*\t\tJumpFrom( int jumpfrom );\n\tidVarDef*\t\tParseImmediate();\n\tidVarDef*\t\tEmitFunctionParms( int op, idVarDef* func, int startarg, int startsize, idVarDef* object );\n\tidVarDef*\t\tParseFunctionCall( idVarDef* func );\n\tidVarDef*\t\tParseObjectCall( idVarDef* object, idVarDef* func );\n\tidVarDef*\t\tParseEventCall( idVarDef* object, idVarDef* func );\n\tidVarDef*\t\tParseSysObjectCall( idVarDef* func );\n\tidVarDef*\t\tLookupDef( const char* name, const idVarDef* baseobj );\n\tidVarDef*\t\tParseValue();\n\tidVarDef*\t\tGetTerm();\n\tbool\t\t\tTypeMatches( etype_t type1, etype_t type2 ) const;\n\tidVarDef*\t\tGetExpression( int priority );\n\tidTypeDef*\t\tGetTypeForEventArg( char argType );\n\tvoid\t\t\tPatchLoop( int start, int continuePos );\n\tvoid\t\t\tParseReturnStatement();\n\tvoid\t\t\tParseWhileStatement();\n\tvoid\t\t\tParseForStatement();\n\tvoid\t\t\tParseDoWhileStatement();\n\tvoid\t\t\tParseIfStatement();\n\tvoid\t\t\tParseStatement();\n\tvoid\t\t\tParseObjectDef( const char* objname );\n\tidTypeDef*\t\tParseFunction( idTypeDef* returnType, const char* name );\n\tvoid\t\t\tParseFunctionDef( idTypeDef* returnType, const char* name );\n\tvoid\t\t\tParseVariableDef( idTypeDef* type, const char* name );\n\tvoid\t\t\tParseEventDef( idTypeDef* type, const char* name );\n\tvoid\t\t\tParseDefs();\n\tvoid\t\t\tParseNamespace( idVarDef* newScope );\n\t\npublic :\n\t// RB: added const\n\tstatic const opcode_t\topcodes[];\n\t// RB end\n\t\n\tidCompiler();\n\tvoid\t\t\tCompileFile( const char* text, const char* filename, bool console );\n}", "item_id": 0, "repo": "vic3t3chn0/OpenKrown", "file": "neo/d3xp/script/Script_Compiler.h", "last_update_at": "2018-11-07T22:44:23+00:00", "question_id": "acdea7d84dbadf50e03f33dece646ce6a8cc9293_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class idCompiler\n{\nprivate:\n\tstatic bool\t\tpunctuationValid[ 256 ];\n\t// RB begin\n\tstatic const char*\t\tpunctuation[];\n\t// RB end\n\t\n\tidParser\t\tparser;\n\tidParser*\t\tparserPtr;\n\tidToken\t\t\ttoken;\n\t\n\tidTypeDef*\t\timmediateType;\n\teval_t\t\t\timmediate;\n\t\n\tbool\t\t\teof;\n\tbool\t\t\tconsole;\n\tbool\t\t\tcallthread;\n\tint\t\t\t\tbraceDepth;\n\tint\t\t\t\tloopDepth;\n\tint\t\t\t\tcurrentLineNumber;\n\tint\t\t\t\tcurrentFileNumber;\n\tint\t\t\t\terrorCount;\n\t\n\tidVarDef*\t\tscope;\t\t\t\t// the function being parsed, or NULL\n\tconst idVarDef*\tbasetype;\t\t\t// for accessing fields\n\t\n\tfloat\t\t\tDivide( float numerator, float denominator );\n\tvoid\t\t\tError( VERIFY_FORMAT_STRING const char* error, ... ) const;\n\tvoid\t\t\tWarning( VERIFY_FORMAT_STRING const char* message, ... ) const;\n\tidVarDef*\t\tOptimizeOpcode( const opcode_t* op, idVarDef* var_a, idVarDef* var_b );\n\tidVarDef*\t\tEmitOpcode( const opcode_t* op, idVarDef* var_a, idVarDef* var_b );\n\tidVarDef*\t\tEmitOpcode( int op, idVarDef* var_a, idVarDef* var_b );\n\tbool\t\t\tEmitPush( idVarDef* expression, const idTypeDef* funcArg );\n\tvoid\t\t\tNextToken();\n\tvoid\t\t\tExpectToken( const char* string );\n\tbool\t\t\tCheckToken( const char* string );\n\tvoid\t\t\tParseName( idStr& name );\n\tvoid\t\t\tSkipOutOfFunction();\n\tvoid\t\t\tSkipToSemicolon();\n\tidTypeDef*\t\tCheckType();\n\tidTypeDef*\t\tParseType();\n\tidVarDef*\t\tFindImmediate( const idTypeDef* type, const eval_t* eval, const char* string ) const;\n\tidVarDef*\t\tGetImmediate( idTypeDef* type, const eval_t* eval, const char* string );\n\tidVarDef*\t\tVirtualFunctionConstant( idVarDef* func );\n\tidVarDef*\t\tSizeConstant( int size );\n\tidVarDef*\t\tJumpConstant( int value );\n\tidVarDef*\t\tJumpDef( int jumpfrom, int jumpto );\n\tidVarDef*\t\tJumpTo( int jumpto );\n\tidVarDef*\t\tJumpFrom( int jumpfrom );\n\tidVarDef*\t\tParseImmediate();\n\tidVarDef*\t\tEmitFunctionParms( int op, idVarDef* func, int startarg, int startsize, idVarDef* object );\n\tidVarDef*\t\tParseFunctionCall( idVarDef* func );\n\tidVarDef*\t\tParseObjectCall( idVarDef* object, idVarDef* func );\n\tidVarDef*\t\tParseEventCall( idVarDef* object, idVarDef* func );\n\tidVarDef*\t\tParseSysObjectCall( idVarDef* func );\n\tidVarDef*\t\tLookupDef( const char* name, const idVarDef* baseobj );\n\tidVarDef*\t\tParseValue();\n\tidVarDef*\t\tGetTerm();\n\tbool\t\t\tTypeMatches( etype_t type1, etype_t type2 ) const;\n\tidVarDef*\t\tGetExpression( int priority );\n\tidTypeDef*\t\tGetTypeForEventArg( char argType );\n\tvoid\t\t\tPatchLoop( int start, int continuePos );\n\tvoid\t\t\tParseReturnStatement();\n\tvoid\t\t\tParseWhileStatement();\n\tvoid\t\t\tParseForStatement();\n\tvoid\t\t\tParseDoWhileStatement();\n\tvoid\t\t\tParseIfStatement();\n\tvoid\t\t\tParseStatement();\n\tvoid\t\t\tParseObjectDef( const char* objname );\n\tidTypeDef*\t\tParseFunction( idTypeDef* returnType, const char* name );\n\tvoid\t\t\tParseFunctionDef( idTypeDef* returnType, const char* name );\n\tvoid\t\t\tParseVariableDef( idTypeDef* type, const char* name );\n\tvoid\t\t\tParseEventDef( idTypeDef* type, const char* name );\n\tvoid\t\t\tParseDefs();\n\tvoid\t\t\tParseNamespace( idVarDef* newScope );\n\t\npublic :\n\t// RB: added const\n\tstatic const opcode_t\topcodes[];\n\t// RB end\n\t\n\tidCompiler();\n\tvoid\t\t\tCompileFile( const char* text, const char* filename, bool console );\n"]]}
{"hexsha": "b71717ce3358f1f1db43661e002a0fc0c57dff92", "ext": "c", "lang": "C", "content": "int8_t mpack_expect_i8(mpack_reader_t* reader) {\n    mpack_tag_t var = mpack_read_tag(reader);\n    if (var.type == mpack_type_uint) {\n        if (var.v.u <= INT8_MAX)\n            return (int8_t)var.v.u;\n    } else if (var.type == mpack_type_int) {\n        if (var.v.i >= INT8_MIN && var.v.i <= INT8_MAX)\n            return (int8_t)var.v.i;\n    }\n    mpack_reader_flag_error(reader, mpack_error_type);\n    return 0;\n}", "item_id": 7, "repo": "thingforward/slyft-tutorials", "file": "slyft-tut-3/lib/private_lib/mpack/mpack-expect.c", "last_update_at": "2018-03-30T02:13:01+00:00", "question_id": "b71717ce3358f1f1db43661e002a0fc0c57dff92_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int8_t mpack_expect_i8(mpack_reader_t* reader) {\n    mpack_tag_t var = mpack_read_tag(reader);\n    if (var.type == mpack_type_uint) {\n        if (var.v.u <= INT8_MAX)\n            return (int8_t)var.v.u;\n    } else if (var.type == mpack_type_int) {\n        if (var.v.i >= INT8_MIN && var.v.i <= INT8_MAX)\n            return (int8_t)var.v.i;\n    }\n    mpack_reader_flag_error(reader, mpack_error_type);\n    return 0;\n"]]}
{"hexsha": "f8e6e63035d02662a37b037103da54a359aab876", "ext": "c", "lang": "C", "content": "static void\npropagate_follows(grammar_t self, int *changed)\n{\n    int i, j, k;\n\n    /* Go through the kernels and propagate stuff */\n    for (i = 0; i < self->kernel_count; i++) {\n        kernel_t kernel = self->kernels[i];\n\n        /* Go through each kernel item */\n        for (j = 0; j < kernel->count; j++) {\n            /* Go through the productions */\n            for (k = -1; k < self->production_count; k++) {\n                /* See if we propagate */\n                if (k < 0 || kernel->propagates_table[j][k]) {\n                    int pi;\n                    int offset;\n\n                    /* Work out the production and offset */\n                    if (k < 0) {\n                        offset = decode(self, kernel->pairs[j], &pi);\n                    } else {\n                        pi = k;\n                        offset = 0;\n                    }\n\n                    /* Propagate everything in the follows table */\n                    propagate_kernel_item_follows(\n                        self, kernel, j,\n                        self->productions[pi], offset,\n                        changed);\n                }\n            }\n        }\n    }\n}", "item_id": 19, "repo": "da4089/tpc", "file": "grammar.c", "last_update_at": "2018-04-21T07:52:20+00:00", "question_id": "f8e6e63035d02662a37b037103da54a359aab876_19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\npropagate_follows(grammar_t self, int *changed)\n{\n    int i, j, k;\n    /* Go through the kernels and propagate stuff */\n    for (i = 0; i < self->kernel_count; i++) {\n        kernel_t kernel = self->kernels[i];\n        /* Go through each kernel item */\n        for (j = 0; j < kernel->count; j++) {\n            /* Go through the productions */\n            for (k = -1; k < self->production_count; k++) {\n                /* See if we propagate */\n                if (k < 0 || kernel->propagates_table[j][k]) {\n                    int pi;\n                    int offset;\n                    /* Work out the production and offset */\n                    if (k < 0) {\n                        offset = decode(self, kernel->pairs[j], &pi);\n                    } else {\n                        pi = k;\n                        offset = 0;\n                    }\n                    /* Propagate everything in the follows table */\n                    propagate_kernel_item_follows(\n                        self, kernel, j,\n                        self->productions[pi], offset,\n                        changed);\n                }\n            }\n        }\n    }\n"]]}
{"hexsha": "cf1fe79b9a833586a14663a1bdd856cb721c3ff8", "ext": "c", "lang": "C", "content": "uint_t\ntcp_read_rwbuf_ncs (T_TCP_CEP *cep, void *data, uint_t len)\n{\n\tuint_t\toffset;\n\n\t/* \u901a\u4fe1\u7aef\u70b9\u3092\u30ed\u30c3\u30af\u3059\u308b\u3002*/\n\tsyscall(wai_sem(cep->semid_lock));\n\n\t/* len \u3068\u53d7\u4fe1\u30a6\u30a3\u30f3\u30c9\u30d0\u30c3\u30d5\u30a1\u306e\u30c7\u30fc\u30bf\u6570\u306e\u5c0f\u3055\u3044\u65b9\u3092\u53d6\u308a\u51fa\u3059\u30c7\u30fc\u30bf\u6570\u306b\u3059\u308b\u3002*/\n\tif (len > cep->rwbuf_count)\n\t\tlen = cep->rwbuf_count;\n\n\t/* \u8aad\u307f\u51fa\u3057\u30dd\u30a4\u30f3\u30bf\u304c\u30e9\u30a6\u30f3\u30c9\u3059\u308b\u3068\u304d\u306e\u51e6\u7406 */\n\tif (len > cep->rbufsz - (cep->rbuf_rptr - (uint8_t*)cep->rbuf)) {\n\t\toffset = (uint_t)(cep->rbufsz - (cep->rbuf_rptr -(uint8_t*)cep->rbuf));\n\t\tmemcpy(data, cep->rbuf_rptr, (size_t)offset);\n\t\tcep->rwbuf_count -= offset;\n\t\tcep->rbuf_rptr   = (uint8_t*)cep->rbuf;\n\t\t}\n\telse\n\t\toffset = 0;\n\n\tmemcpy((void*)((uint8_t*)data + offset), cep->rbuf_rptr, (size_t)(len - offset));\n\tcep->rwbuf_count -= len - offset;\n\tcep->rbuf_rptr  += len - offset;\n\n\t/* \u901a\u4fe1\u7aef\u70b9\u306e\u30ed\u30c3\u30af\u3092\u89e3\u9664\u3059\u308b\u3002*/\n\tsyscall(sig_sem(cep->semid_lock));\n\n\treturn len;\n\t}", "item_id": 7, "repo": "robotan0921/mruby_on_tinet-tecs", "file": "asp3/tinet/netinet/tcp_subr_ncs.c", "last_update_at": "2018-04-03T08:52:05+00:00", "question_id": "cf1fe79b9a833586a14663a1bdd856cb721c3ff8_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["uint_t\ntcp_read_rwbuf_ncs (T_TCP_CEP *cep, void *data, uint_t len)\n{\n\tuint_t\toffset;\n\t/* \u901a\u4fe1\u7aef\u70b9\u3092\u30ed\u30c3\u30af\u3059\u308b\u3002*/\n\tsyscall(wai_sem(cep->semid_lock));\n\t/* len \u3068\u53d7\u4fe1\u30a6\u30a3\u30f3\u30c9\u30d0\u30c3\u30d5\u30a1\u306e\u30c7\u30fc\u30bf\u6570\u306e\u5c0f\u3055\u3044\u65b9\u3092\u53d6\u308a\u51fa\u3059\u30c7\u30fc\u30bf\u6570\u306b\u3059\u308b\u3002*/\n\tif (len > cep->rwbuf_count)\n\t\tlen = cep->rwbuf_count;\n\t/* \u8aad\u307f\u51fa\u3057\u30dd\u30a4\u30f3\u30bf\u304c\u30e9\u30a6\u30f3\u30c9\u3059\u308b\u3068\u304d\u306e\u51e6\u7406 */\n\tif (len > cep->rbufsz - (cep->rbuf_rptr - (uint8_t*)cep->rbuf)) {\n\t\toffset = (uint_t)(cep->rbufsz - (cep->rbuf_rptr -(uint8_t*)cep->rbuf));\n\t\tmemcpy(data, cep->rbuf_rptr, (size_t)offset);\n\t\tcep->rwbuf_count -= offset;\n\t\tcep->rbuf_rptr   = (uint8_t*)cep->rbuf;\n\t\t}\n\telse\n\t\toffset = 0;\n\tmemcpy((void*)((uint8_t*)data + offset), cep->rbuf_rptr, (size_t)(len - offset));\n\tcep->rwbuf_count -= len - offset;\n\tcep->rbuf_rptr  += len - offset;\n\t/* \u901a\u4fe1\u7aef\u70b9\u306e\u30ed\u30c3\u30af\u3092\u89e3\u9664\u3059\u308b\u3002*/\n\tsyscall(sig_sem(cep->semid_lock));\n\treturn len;\n"]]}
{"hexsha": "ecc2fc0bed423de59ae0c245442703afd1aa8e0d", "ext": "h", "lang": "C", "content": "class rioreceive\n{\n\tpublic:\n\t\tvoid init();\n\t\tvoid get(std::vector<int> &centre_xs, std::vector<double> &angles, std::vector<double> &distances, std::string& message);\n\t\tvoid test();\n\n\tprivate:\n\t\tint sockfd;\n\t\tstruct sockaddr_in addr;\n}", "item_id": 0, "repo": "swan58/2018-PowerUp", "file": "5663/src/include/rioreceive.h", "last_update_at": "2018-01-26T05:58:48+00:00", "question_id": "ecc2fc0bed423de59ae0c245442703afd1aa8e0d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class rioreceive\n{\n\tpublic:\n\t\tvoid init();\n\t\tvoid get(std::vector<int> &centre_xs, std::vector<double> &angles, std::vector<double> &distances, std::string& message);\n\t\tvoid test();\n\tprivate:\n\t\tint sockfd;\n\t\tstruct sockaddr_in addr;\n"]]}
{"hexsha": "960624e1518955a53d27cd7ddb71a3be8731398b", "ext": "c", "lang": "C", "content": "static void\narc4_randomstir (void)\n{\n\tu_int8_t key[256];\n\tint r, n;\n\tstruct timeval tv_now;\n\n\t/*\n\t * XXX read_random() returns unsafe numbers if the entropy\n\t * device is not loaded -- MarkM.\n\t */\n\tr = read_random(key, ARC4_KEYBYTES);\n\tgetmicrouptime(&tv_now);\n\tmtx_lock(&arc4_mtx);\n\t/* If r == 0 || -1, just use what was on the stack. */\n\tif (r > 0) {\n\t\tfor (n = r; n < sizeof(key); n++)\n\t\t\tkey[n] = key[n % r];\n\t}\n\n\tfor (n = 0; n < 256; n++) {\n\t\tarc4_j = (arc4_j + arc4_sbox[n] + key[n]) % 256;\n\t\tarc4_swap(&arc4_sbox[n], &arc4_sbox[arc4_j]);\n\t}\n\tarc4_i = arc4_j = 0;\n\n\t/* Reset for next reseed cycle. */\n\tarc4_t_reseed = tv_now.tv_sec + ARC4_RESEED_SECONDS;\n\tarc4_numruns = 0;\n\n\t/*\n\t * Throw away the first N words of output, as suggested in the\n\t * paper \"Weaknesses in the Key Scheduling Algorithm of RC4\"\n\t * by Fluher, Mantin, and Shamir.  (N = 256 in our case.)\n\t */\n\tfor (n = 0; n < 256*4; n++)\n\t\tarc4_randbyte();\n\tmtx_unlock(&arc4_mtx);\n}", "item_id": 1, "repo": "dcui/FreeBSD-9.3_kernel", "file": "sys/libkern/arc4random.c", "last_update_at": "2018-01-11T01:01:38+00:00", "question_id": "960624e1518955a53d27cd7ddb71a3be8731398b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\narc4_randomstir (void)\n{\n\tu_int8_t key[256];\n\tint r, n;\n\tstruct timeval tv_now;\n\t/*\n\t * XXX read_random() returns unsafe numbers if the entropy\n\t * device is not loaded -- MarkM.\n\t */\n\tr = read_random(key, ARC4_KEYBYTES);\n\tgetmicrouptime(&tv_now);\n\tmtx_lock(&arc4_mtx);\n\t/* If r == 0 || -1, just use what was on the stack. */\n\tif (r > 0) {\n\t\tfor (n = r; n < sizeof(key); n++)\n\t\t\tkey[n] = key[n % r];\n\t}\n\tfor (n = 0; n < 256; n++) {\n\t\tarc4_j = (arc4_j + arc4_sbox[n] + key[n]) % 256;\n\t\tarc4_swap(&arc4_sbox[n], &arc4_sbox[arc4_j]);\n\t}\n\tarc4_i = arc4_j = 0;\n\t/* Reset for next reseed cycle. */\n\tarc4_t_reseed = tv_now.tv_sec + ARC4_RESEED_SECONDS;\n\tarc4_numruns = 0;\n\t/*\n\t * Throw away the first N words of output, as suggested in the\n\t * paper \"Weaknesses in the Key Scheduling Algorithm of RC4\"\n\t * by Fluher, Mantin, and Shamir.  (N = 256 in our case.)\n\t */\n\tfor (n = 0; n < 256*4; n++)\n\t\tarc4_randbyte();\n\tmtx_unlock(&arc4_mtx);\n"]]}
{"hexsha": "dfab238654a3003a955a6790101ab660b9b1767b", "ext": "c", "lang": "C", "content": "static int matchString(const char **strptr, const char *against)\n{\n    const char *str = *strptr;\n    while (*against != 0) {\n        if (*str != *against)\n            return 0;\n        str++;\n        against++;\n    }\n    *strptr = str;\n    return 1;\n}", "item_id": 0, "repo": "isabella232/incubator-retired-corinthia", "file": "DocFormats/core/src/css/CSSSyntax.c", "last_update_at": "2018-03-24T18:39:35+00:00", "question_id": "dfab238654a3003a955a6790101ab660b9b1767b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int matchString(const char **strptr, const char *against)\n{\n    const char *str = *strptr;\n    while (*against != 0) {\n        if (*str != *against)\n            return 0;\n        str++;\n        against++;\n    }\n    *strptr = str;\n    return 1;\n"]]}
{"hexsha": "c8f4fd03545e3ae97891921e1d8c918d317db6a6", "ext": "c", "lang": "C", "content": "char* get_end(char *p)\r\n{\r\n\tif (!p) return p;\r\n\tchar c = *p;\r\n\tif (('p' <= c) && (c <= 'z'))\r\n\t\treturn p + 1;\r\n\telse switch (c)\r\n\t{\r\n\tcase 'N':\treturn get_end(p + 1);\r\n\tcase 'C':\r\n\tcase 'D':\r\n\tcase 'E':\r\n\tcase 'I':\treturn get_end(get_end(p + 1));\r\n\t}\r\n\treturn NULL;\r\n}", "item_id": 0, "repo": "asterix314/poj-problems", "file": "poj/1126.c", "last_update_at": "2018-10-24T03:52:06+00:00", "question_id": "c8f4fd03545e3ae97891921e1d8c918d317db6a6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["char* get_end(char *p)\r\n{\r\n\tif (!p) return p;\r\n\tchar c = *p;\r\n\tif (('p' <= c) && (c <= 'z'))\r\n\t\treturn p + 1;\r\n\telse switch (c)\r\n\t{\r\n\tcase 'N':\treturn get_end(p + 1);\r\n\tcase 'C':\r\n\tcase 'D':\r\n\tcase 'E':\r\n\tcase 'I':\treturn get_end(get_end(p + 1));\r\n\t}\r\n\treturn NULL;\r\n"]]}
{"hexsha": "0c114c6d73450c3b69405ae74a3c6a13e4fee696", "ext": "c", "lang": "C", "content": "static void callback_recv(void *p_cookie, int status, const struct mdns_entry *entries)\n{\n    int ret = 0;\n    struct mdns_entry *entry = NULL;\n    service_state_t *state = NULL;\n    service_t *service = NULL;\n\n    service_t *node, *next;\n    int find = 0;\n    uint8_t required = 0;\n    if (p_cookie == NULL) {\n        return;\n    }\n    if (status < 0) {\n        log_e(\"get entries err, status = %d\", status);\n        return;\n    }\n\n    state = (service_state_t *)p_cookie;\n    service = hal_malloc(sizeof(service_t));\n    memset(service, 0, sizeof(service_t));\n\n    if (service == NULL) {\n        return ;\n    }\n    entry = (struct mdns_entry *)entries;\n    while (entry != NULL) {\n        switch (entry->type) {\n            case RR_A:\n                break;\n            case RR_PTR:\n                /*\n                                if (entry->data.PTR.domain != NULL) {\n                                    strncpy(service->srv_name, entry->data.PTR.domain, SERVICE_NAME_LEN_MAX);\n                                }\n                */\n                break;\n            case RR_TXT: {\n                txt_item_t *txt_next = entry->data.TXT;\n                while (txt_next != NULL) {\n                    txt_item_t *txt;\n                    txt = hal_malloc(sizeof(txt_item_t));\n                    memset(txt, 0, sizeof(txt_item_t));\n                    if (txt == NULL) {\n                        goto err;\n                    }\n                    memcpy(txt->txt, txt_next->txt, strlen(txt_next->txt));\n                    txt->next = service->txt_items;\n                    service->txt_items = txt;\n                    txt_next = txt_next->next;\n                };\n            }\n            break;\n            case RR_AAAA:\n                required |= 0x01;\n                memcpy(&service->id.ip6, entry->data.AAAA.addr.s6_addr, sizeof(service->id.ip6));\n                break;\n            case RR_SRV: {\n                char *name = NULL;\n                char *type = NULL;\n                char *last = NULL;\n                int num = get_char_num(entry->name, '.');\n                if (num == 2) {\n                    name = UMESH_SRV_DEFAULT_NANE;\n                    char *type = (char *)strtok_r(entry->name, \".\", &last);\n                    if (type == NULL || strlen(type) == 0) {\n                        break;\n                    }\n                } else if (num == 3) {\n                    name = (char *)strtok_r(entry->name, \".\", &last);\n                    type = (char *)strtok_r(NULL, \".\", &last);\n                    if (name == NULL || strlen(name) == 0) {\n                        break;\n                    }\n                    if (type == NULL || strlen(type) == 0) {\n                        break;\n                    }\n                } else {\n                    log_w(\"mdns srv: unknow format!\");\n                    break;\n                }\n\n                required |= 0x02;\n\n                strncpy(service->srv_name, name, SERVICE_NAME_LEN_MAX);\n                strncpy(service->srv_type, type, SERVICE_TYPE_LEN_MAX);\n                service->ttl = entry->ttl;\n                log_d(\" srv type = %s,TTL = %d\", type, service->ttl);\n                if (service->ttl == 0) {\n                    service->ttl = SERVICE_TTL;\n                }\n                service->id.port = entry->data.SRV.port;\n            }\n            break;\n            default:\n                break;\n        }\n\n        entry = entry->next;\n    };\n\n    if ((required & 0x03) != 0x03) {\n        log_e(\"service not complete\");\n        ret = UMESH_SRV_ERR_SERVICE_INCOMPLETE;\n        goto err;\n    }\n    hal_mutex_lock(state->lock);\n    list_for_each_entry_safe(node, next, &state->found_service_list, linked_list, service_t) {\n        if (!strcmp(node->srv_name, service->srv_name) && !strcmp(node->srv_type, service->srv_type)) {\n            node->last_update = hal_now_ms();\n            find = 1;\n            break;\n        }\n    }\n\n    if (!find && list_entry_number(&state->found_service_list) < SERVICE_MAX_FOUND_NUM) {\n        log_d(\"add serivce to found list:%s-%s\", service->srv_type, service->srv_name);\n        service->last_update = hal_now_ms();\n        list_add_tail(&service->linked_list, &state->found_service_list);\n        if (state->found_cb) {\n            state->found_cb(service, PEER_FOUND, state->found_cb_ctx);\n        }\n    }  else {\n        ret = umesh_service_free(service);\n    }\n    hal_mutex_unlock(state->lock);\n    return;\nerr:\n    log_e(\"service incomplete, discarded! ret = %d\", ret);\n    if (service != NULL) {\n        umesh_service_free(service);\n    }\n    return;\n}", "item_id": 8, "repo": "HelloAllen8893/AliOS-Things", "file": "components/network/umesh2/local_comm/src/umesh_api.c", "last_update_at": "2018-11-28T03:19:22+00:00", "question_id": "0c114c6d73450c3b69405ae74a3c6a13e4fee696_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void callback_recv(void *p_cookie, int status, const struct mdns_entry *entries)\n{\n    int ret = 0;\n    struct mdns_entry *entry = NULL;\n    service_state_t *state = NULL;\n    service_t *service = NULL;\n    service_t *node, *next;\n    int find = 0;\n    uint8_t required = 0;\n    if (p_cookie == NULL) {\n        return;\n    }\n    if (status < 0) {\n        log_e(\"get entries err, status = %d\", status);\n        return;\n    }\n    state = (service_state_t *)p_cookie;\n    service = hal_malloc(sizeof(service_t));\n    memset(service, 0, sizeof(service_t));\n    if (service == NULL) {\n        return ;\n    }\n    entry = (struct mdns_entry *)entries;\n    while (entry != NULL) {\n        switch (entry->type) {\n            case RR_A:\n                break;\n            case RR_PTR:\n                /*\n                                if (entry->data.PTR.domain != NULL) {\n                                    strncpy(service->srv_name, entry->data.PTR.domain, SERVICE_NAME_LEN_MAX);\n                                }\n                */\n                break;\n            case RR_TXT: {\n                txt_item_t *txt_next = entry->data.TXT;\n                while (txt_next != NULL) {\n                    txt_item_t *txt;\n                    txt = hal_malloc(sizeof(txt_item_t));\n                    memset(txt, 0, sizeof(txt_item_t));\n                    if (txt == NULL) {\n                        goto err;\n                    }\n                    memcpy(txt->txt, txt_next->txt, strlen(txt_next->txt));\n                    txt->next = service->txt_items;\n                    service->txt_items = txt;\n                    txt_next = txt_next->next;\n                };\n            }\n            break;\n            case RR_AAAA:\n                required |= 0x01;\n                memcpy(&service->id.ip6, entry->data.AAAA.addr.s6_addr, sizeof(service->id.ip6));\n                break;\n            case RR_SRV: {\n                char *name = NULL;\n                char *type = NULL;\n                char *last = NULL;\n                int num = get_char_num(entry->name, '.');\n                if (num == 2) {\n                    name = UMESH_SRV_DEFAULT_NANE;\n                    char *type = (char *)strtok_r(entry->name, \".\", &last);\n                    if (type == NULL || strlen(type) == 0) {\n                        break;\n                    }\n                } else if (num == 3) {\n                    name = (char *)strtok_r(entry->name, \".\", &last);\n                    type = (char *)strtok_r(NULL, \".\", &last);\n                    if (name == NULL || strlen(name) == 0) {\n                        break;\n                    }\n                    if (type == NULL || strlen(type) == 0) {\n                        break;\n                    }\n                } else {\n                    log_w(\"mdns srv: unknow format!\");\n                    break;\n                }\n                required |= 0x02;\n                strncpy(service->srv_name, name, SERVICE_NAME_LEN_MAX);\n                strncpy(service->srv_type, type, SERVICE_TYPE_LEN_MAX);\n                service->ttl = entry->ttl;\n                log_d(\" srv type = %s,TTL = %d\", type, service->ttl);\n                if (service->ttl == 0) {\n                    service->ttl = SERVICE_TTL;\n                }\n                service->id.port = entry->data.SRV.port;\n            }\n            break;\n            default:\n                break;\n        }\n        entry = entry->next;\n    };\n    if ((required & 0x03) != 0x03) {\n        log_e(\"service not complete\");\n        ret = UMESH_SRV_ERR_SERVICE_INCOMPLETE;\n        goto err;\n    }\n    hal_mutex_lock(state->lock);\n    list_for_each_entry_safe(node, next, &state->found_service_list, linked_list, service_t) {\n        if (!strcmp(node->srv_name, service->srv_name) && !strcmp(node->srv_type, service->srv_type)) {\n            node->last_update = hal_now_ms();\n            find = 1;\n            break;\n        }\n    }\n    if (!find && list_entry_number(&state->found_service_list) < SERVICE_MAX_FOUND_NUM) {\n        log_d(\"add serivce to found list:%s-%s\", service->srv_type, service->srv_name);\n        service->last_update = hal_now_ms();\n        list_add_tail(&service->linked_list, &state->found_service_list);\n        if (state->found_cb) {\n            state->found_cb(service, PEER_FOUND, state->found_cb_ctx);\n        }\n    }  else {\n        ret = umesh_service_free(service);\n    }\n    hal_mutex_unlock(state->lock);\n    return;\nerr:\n    log_e(\"service incomplete, discarded! ret = %d\", ret);\n    if (service != NULL) {\n        umesh_service_free(service);\n    }\n    return;\n"]]}
{"hexsha": "0d12aaaf2468bdedee26fc3fc1668e1fd4c1c739", "ext": "c", "lang": "C", "content": "void iotx_ds_common_update_time(iotx_shadow_pt pshadow, uint32_t new_timestamp)\n{\n    HAL_MutexLock(pshadow->mutex);\n    pshadow->inner_data.time.base_system_time = utils_time_get_ms();\n    pshadow->inner_data.time.epoch_time = new_timestamp;\n    HAL_MutexUnlock(pshadow->mutex);\n\n    log_info(\"update system time\");\n}", "item_id": 5, "repo": "qrsforever/leiot_sdk", "file": "src/shadow/shadow_common.c", "last_update_at": "2018-09-28T05:06:17+00:00", "question_id": "0d12aaaf2468bdedee26fc3fc1668e1fd4c1c739_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void iotx_ds_common_update_time(iotx_shadow_pt pshadow, uint32_t new_timestamp)\n{\n    HAL_MutexLock(pshadow->mutex);\n    pshadow->inner_data.time.base_system_time = utils_time_get_ms();\n    pshadow->inner_data.time.epoch_time = new_timestamp;\n    HAL_MutexUnlock(pshadow->mutex);\n    log_info(\"update system time\");\n"]]}
{"hexsha": "ae58658fd0c92c187a5c72421e32cabfd92c22ac", "ext": "c", "lang": "C", "content": "int func6()\n{\n\thash(6);\n\tled_data ++ ;\n\tXGpio_DiscreteWrite(&LED_Gpio, 1, led_data);\n\tfor (int Delay = 0; Delay < 3*LED_DELAY; Delay++);\n\tled_data -- ;\n\tXGpio_DiscreteWrite(&LED_Gpio, 1, led_data);\n\tfor (int Delay = 0; Delay < LED_DELAY; Delay++);\n\tfor(int x=0 ; x<=3 ; x++)\n\t{\n\tled_data ++ ;\n\tXGpio_DiscreteWrite(&LED_Gpio, 1, led_data);\n\tfor (int Delay = 0; Delay < LED_DELAY; Delay++);\n\tled_data -- ;\n\tXGpio_DiscreteWrite(&LED_Gpio, 1, led_data);\n\tfor (int Delay = 0; Delay < LED_DELAY; Delay++);\n\t}\n\tfor (int Delay = 0; Delay < 2*LED_DELAY; Delay++);\n}", "item_id": 6, "repo": "roo16kie/Dividor__Verilog", "file": "program1/led_irpt.c", "last_update_at": "2018-12-13T22:50:33+00:00", "question_id": "ae58658fd0c92c187a5c72421e32cabfd92c22ac_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int func6()\n{\n\thash(6);\n\tled_data ++ ;\n\tXGpio_DiscreteWrite(&LED_Gpio, 1, led_data);\n\tfor (int Delay = 0; Delay < 3*LED_DELAY; Delay++);\n\tled_data -- ;\n\tXGpio_DiscreteWrite(&LED_Gpio, 1, led_data);\n\tfor (int Delay = 0; Delay < LED_DELAY; Delay++);\n\tfor(int x=0 ; x<=3 ; x++)\n\t{\n\tled_data ++ ;\n\tXGpio_DiscreteWrite(&LED_Gpio, 1, led_data);\n\tfor (int Delay = 0; Delay < LED_DELAY; Delay++);\n\tled_data -- ;\n\tXGpio_DiscreteWrite(&LED_Gpio, 1, led_data);\n\tfor (int Delay = 0; Delay < LED_DELAY; Delay++);\n\t}\n\tfor (int Delay = 0; Delay < 2*LED_DELAY; Delay++);\n"]]}
{"hexsha": "54fe4f710c588207604d8fe76a71f4b670855025", "ext": "c", "lang": "C", "content": "ER\neOutput_getOffset(CELLIDX idx, T_OFF_BUF* offset)\n{\n\tER\t\tercd = E_OK;\n\tCELLCB\t*p_cellcb;\n\tif (VALID_IDX(idx)) {\n\t\tp_cellcb = GET_CELLCB(idx);\n\t}\n\telse {\n\t\treturn(E_ID);\n\t} /* end if VALID_IDX(idx) */\n\n\t/* \u3053\u3053\u306b\u51e6\u7406\u672c\u4f53\u3092\u8a18\u8ff0\u3057\u307e\u3059 #_TEFB_# */\n\toffset->iphdrlen = IP4_HDR_SIZE;\n\toffset->ipmss \t = TCP_MSS;\n\n\tif(is_cEthernetOutput_joined()) {\t\t\t//mikan \u3044\u307e\u3044\u3061\u672a\u5b8c\n\t\toffset->protocolflag |= FLAG_USE_ETHER;\n\t\toffset->ifhdrlen \t  = ETHER_HDR_SIZE;\n\t\toffset->ifalign \t  = NETBUFFER_ALIGN;\n\t\treturn E_OK;\n\t}\n\n\treturn E_ID;\n}", "item_id": 1, "repo": "robotan0921/mruby_on_tinet-tecs", "file": "asp3/tinet/netinet/tIPv4Output.c", "last_update_at": "2018-04-03T08:52:05+00:00", "question_id": "54fe4f710c588207604d8fe76a71f4b670855025_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ER\neOutput_getOffset(CELLIDX idx, T_OFF_BUF* offset)\n{\n\tER\t\tercd = E_OK;\n\tCELLCB\t*p_cellcb;\n\tif (VALID_IDX(idx)) {\n\t\tp_cellcb = GET_CELLCB(idx);\n\t}\n\telse {\n\t\treturn(E_ID);\n\t} /* end if VALID_IDX(idx) */\n\t/* \u3053\u3053\u306b\u51e6\u7406\u672c\u4f53\u3092\u8a18\u8ff0\u3057\u307e\u3059 #_TEFB_# */\n\toffset->iphdrlen = IP4_HDR_SIZE;\n\toffset->ipmss \t = TCP_MSS;\n\tif(is_cEthernetOutput_joined()) {\t\t\t//mikan \u3044\u307e\u3044\u3061\u672a\u5b8c\n\t\toffset->protocolflag |= FLAG_USE_ETHER;\n\t\toffset->ifhdrlen \t  = ETHER_HDR_SIZE;\n\t\toffset->ifalign \t  = NETBUFFER_ALIGN;\n\t\treturn E_OK;\n\t}\n\treturn E_ID;\n"]]}
{"hexsha": "4f3e7642740bc08ef0dbbfd9f04d03fb4be60715", "ext": "c", "lang": "C", "content": "svm_msg_q_t *\nsvm_msg_q_alloc (svm_msg_q_cfg_t * cfg)\n{\n  svm_msg_q_ring_t *ring;\n  svm_msg_q_t *mq;\n  uword size;\n  int i;\n\n  if (!cfg)\n    return 0;\n\n  mq = clib_mem_alloc_aligned (sizeof (svm_msg_q_t), CLIB_CACHE_LINE_BYTES);\n  memset (mq, 0, sizeof (*mq));\n  mq->q = svm_queue_init (cfg->q_nitems, sizeof (svm_msg_q_msg_t),\n\t\t\t  cfg->consumer_pid, 0);\n  vec_validate (mq->rings, cfg->n_rings - 1);\n  for (i = 0; i < cfg->n_rings; i++)\n    {\n      ring = &mq->rings[i];\n      ring->elsize = cfg->ring_cfgs[i].elsize;\n      ring->nitems = cfg->ring_cfgs[i].nitems;\n      if (cfg->ring_cfgs[i].data)\n\tring->data = cfg->ring_cfgs[i].data;\n      else\n\t{\n\t  size = (uword) ring->nitems * ring->elsize;\n\t  ring->data = clib_mem_alloc_aligned (size, CLIB_CACHE_LINE_BYTES);\n\t}\n    }\n\n  return mq;\n}", "item_id": 0, "repo": "kanehuange/vpp", "file": "src/svm/message_queue.c", "last_update_at": "2018-09-04T09:01:23+00:00", "question_id": "4f3e7642740bc08ef0dbbfd9f04d03fb4be60715_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["svm_msg_q_t *\nsvm_msg_q_alloc (svm_msg_q_cfg_t * cfg)\n{\n  svm_msg_q_ring_t *ring;\n  svm_msg_q_t *mq;\n  uword size;\n  int i;\n  if (!cfg)\n    return 0;\n  mq = clib_mem_alloc_aligned (sizeof (svm_msg_q_t), CLIB_CACHE_LINE_BYTES);\n  memset (mq, 0, sizeof (*mq));\n  mq->q = svm_queue_init (cfg->q_nitems, sizeof (svm_msg_q_msg_t),\n\t\t\t  cfg->consumer_pid, 0);\n  vec_validate (mq->rings, cfg->n_rings - 1);\n  for (i = 0; i < cfg->n_rings; i++)\n    {\n      ring = &mq->rings[i];\n      ring->elsize = cfg->ring_cfgs[i].elsize;\n      ring->nitems = cfg->ring_cfgs[i].nitems;\n      if (cfg->ring_cfgs[i].data)\n\tring->data = cfg->ring_cfgs[i].data;\n      else\n\t{\n\t  size = (uword) ring->nitems * ring->elsize;\n\t  ring->data = clib_mem_alloc_aligned (size, CLIB_CACHE_LINE_BYTES);\n\t}\n    }\n  return mq;\n"]]}
{"hexsha": "9977ee713654e075e81c0392d1ffe82b6d65ca4e", "ext": "c", "lang": "C", "content": "int qmi_parse_pds_get_gps_service_state_response(struct qmi_msg *msg, struct qmi_pds_get_gps_service_state_response *res)\n{\n\tvoid *tlv_buf = &msg->svc.tlv;\n\tunsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);\n\tstruct tlv *tlv;\n\tint i;\n\tuint32_t found[1] = {};\n\n\tmemset(res, 0, sizeof(*res));\n\n\t__qmi_alloc_reset();\n\twhile ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {\n\t\tunsigned int cur_tlv_len = le16_to_cpu(tlv->len);\n\t\tunsigned int ofs = 0;\n\n\t\tswitch(tlv->type) {\n\t\tcase 0x01:\n\t\t\tif (found[0] & (1 << 1))\n\t\t\t\tbreak;\n\n\t\t\tfound[0] |= (1 << 1);\n\t\t\tres->set.state = 1;\n\t\t\tres->data.state.gps_service_state = *(uint8_t *) get_next(1);\n\t\t\tres->data.state.tracking_session_state = *(uint8_t *) get_next(1);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror_len:\n\tfprintf(stderr, \"%s: Invalid TLV length in message, tlv=0x%02x, len=%d\\n\",\n\t        __func__, tlv->type, le16_to_cpu(tlv->len));\n\treturn QMI_ERROR_INVALID_DATA;\n}", "item_id": 5, "repo": "ECRS/Asus-RT-N16", "file": "release/src/router/uqmi/qmi-message-pds.c", "last_update_at": "2018-08-21T03:43:31+00:00", "question_id": "9977ee713654e075e81c0392d1ffe82b6d65ca4e_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int qmi_parse_pds_get_gps_service_state_response(struct qmi_msg *msg, struct qmi_pds_get_gps_service_state_response *res)\n{\n\tvoid *tlv_buf = &msg->svc.tlv;\n\tunsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);\n\tstruct tlv *tlv;\n\tint i;\n\tuint32_t found[1] = {};\n\tmemset(res, 0, sizeof(*res));\n\t__qmi_alloc_reset();\n\twhile ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {\n\t\tunsigned int cur_tlv_len = le16_to_cpu(tlv->len);\n\t\tunsigned int ofs = 0;\n\t\tswitch(tlv->type) {\n\t\tcase 0x01:\n\t\t\tif (found[0] & (1 << 1))\n\t\t\t\tbreak;\n\t\t\tfound[0] |= (1 << 1);\n\t\t\tres->set.state = 1;\n\t\t\tres->data.state.gps_service_state = *(uint8_t *) get_next(1);\n\t\t\tres->data.state.tracking_session_state = *(uint8_t *) get_next(1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nerror_len:\n\tfprintf(stderr, \"%s: Invalid TLV length in message, tlv=0x%02x, len=%d\\n\",\n\t        __func__, tlv->type, le16_to_cpu(tlv->len));\n\treturn QMI_ERROR_INVALID_DATA;\n"]]}
{"hexsha": "87e968aceb9ca3266b2a1de9ff1297c7d2f77f7f", "ext": "c", "lang": "C", "content": "void bvconst_add2(uint32_t *bv, uint32_t k, uint32_t *a1, uint32_t *a2) {\n  uint64_t aux;\n\n  assert(k>0);\n  aux = 0;\n  do {\n    aux += ((uint64_t) (*a1)) + ((uint64_t) (*a2));\n    *bv = (uint32_t) aux;\n    aux >>= 32;\n    a1 ++;\n    a2 ++;\n    bv ++;\n    k --;\n  } while (k > 0);\n}", "item_id": 51, "repo": "maelvls/ocamlyices2", "file": "ext/yices/src/terms/bv_constants.c", "last_update_at": "2018-11-23T00:16:01+00:00", "question_id": "87e968aceb9ca3266b2a1de9ff1297c7d2f77f7f_51", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void bvconst_add2(uint32_t *bv, uint32_t k, uint32_t *a1, uint32_t *a2) {\n  uint64_t aux;\n  assert(k>0);\n  aux = 0;\n  do {\n    aux += ((uint64_t) (*a1)) + ((uint64_t) (*a2));\n    *bv = (uint32_t) aux;\n    aux >>= 32;\n    a1 ++;\n    a2 ++;\n    bv ++;\n    k --;\n  } while (k > 0);\n"]]}
{"hexsha": "56dd26ea5d357cfcfd99cb5a5b48278749598a54", "ext": "c", "lang": "C", "content": "long sys_fcntl(unsigned long fd, long cmd, long arg)\n{\n\tstruct file *file;\n\n\tif (fd > NR_OPEN || !(file = (CURRENT_TASK() )->file[fd]))\n\t\treturn -EBADF;\n\n\tswitch (cmd) {\n\tcase F_DUPFD:\n\t\treturn dupfd(fd, arg);\n\tdefault:\n\t\treturn -EIO;\n\t}\n}", "item_id": 2, "repo": "menqgingyu/JunOS-V0.5", "file": "kernel/fs/fcntl.c", "last_update_at": "2018-03-04T03:01:56+00:00", "question_id": "56dd26ea5d357cfcfd99cb5a5b48278749598a54_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["long sys_fcntl(unsigned long fd, long cmd, long arg)\n{\n\tstruct file *file;\n\tif (fd > NR_OPEN || !(file = (CURRENT_TASK() )->file[fd]))\n\t\treturn -EBADF;\n\tswitch (cmd) {\n\tcase F_DUPFD:\n\t\treturn dupfd(fd, arg);\n\tdefault:\n\t\treturn -EIO;\n\t}\n"]]}
{"hexsha": "9681a7cb7e4eef11575b3e6e38fc7168eda43f0a", "ext": "c", "lang": "C", "content": "TEST_CASE(mktime_1)\n{\n  struct tm tm;\n  time_t t = 0;\n  TEST_FAIL_IF(mktime(localtime(&t)) != 0);\n  t = time(NULL);\n  TEST_FAIL_IF(time(NULL) - mktime(localtime(&t)) > 1);\n  TEST(1);\n}", "item_id": 13, "repo": "block8437/FailSafeC", "file": "test/unix/time.test.c", "last_update_at": "2018-02-10T02:52:09+00:00", "question_id": "9681a7cb7e4eef11575b3e6e38fc7168eda43f0a_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["TEST_CASE(mktime_1)\n{\n  struct tm tm;\n  time_t t = 0;\n  TEST_FAIL_IF(mktime(localtime(&t)) != 0);\n  t = time(NULL);\n  TEST_FAIL_IF(time(NULL) - mktime(localtime(&t)) > 1);\n  TEST(1);\n"]]}
{"hexsha": "655175928e7e666dc5dcb7db8a2652bce8102f62", "ext": "c", "lang": "C", "content": "static struct ieee80211_node *\nmwl_node_alloc(struct ieee80211vap *vap, const uint8_t mac[IEEE80211_ADDR_LEN])\n{\n\tstruct ieee80211com *ic = vap->iv_ic;\n\tstruct mwl_softc *sc = ic->ic_ifp->if_softc;\n\tconst size_t space = sizeof(struct mwl_node);\n\tstruct mwl_node *mn;\n\n\tmn = malloc(space, M_80211_NODE, M_NOWAIT|M_ZERO);\n\tif (mn == NULL) {\n\t\t/* XXX stat+msg */\n\t\treturn NULL;\n\t}\n\tDPRINTF(sc, MWL_DEBUG_NODE, \"%s: mn %p\\n\", __func__, mn);\n\treturn &mn->mn_node;\n}", "item_id": 51, "repo": "dcui/FreeBSD-9.3_kernel", "file": "sys/dev/mwl/if_mwl.c", "last_update_at": "2018-01-11T01:01:38+00:00", "question_id": "655175928e7e666dc5dcb7db8a2652bce8102f62_51", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static struct ieee80211_node *\nmwl_node_alloc(struct ieee80211vap *vap, const uint8_t mac[IEEE80211_ADDR_LEN])\n{\n\tstruct ieee80211com *ic = vap->iv_ic;\n\tstruct mwl_softc *sc = ic->ic_ifp->if_softc;\n\tconst size_t space = sizeof(struct mwl_node);\n\tstruct mwl_node *mn;\n\tmn = malloc(space, M_80211_NODE, M_NOWAIT|M_ZERO);\n\tif (mn == NULL) {\n\t\t/* XXX stat+msg */\n\t\treturn NULL;\n\t}\n\tDPRINTF(sc, MWL_DEBUG_NODE, \"%s: mn %p\\n\", __func__, mn);\n\treturn &mn->mn_node;\n"]]}
{"hexsha": "39661e8cbdda950f95dc5083bb4b7b6c042e193f", "ext": "c", "lang": "C", "content": "TEST test_raster_null_raster()\n{\n    unsigned char buffer[1];\n    ASSERT_EAARLIO_ERR(\n        EAARLIO_NULL, eaarlio_tld_unpack_raster(\n                          (unsigned char *)&buffer, 1, NULL, NULL, 0, 0));\n    PASS();\n}", "item_id": 12, "repo": "usgs/eaarl-io", "file": "library/tests/test_tld_unpack.c", "last_update_at": "2018-11-16T06:44:19+00:00", "question_id": "39661e8cbdda950f95dc5083bb4b7b6c042e193f_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["TEST test_raster_null_raster()\n{\n    unsigned char buffer[1];\n    ASSERT_EAARLIO_ERR(\n        EAARLIO_NULL, eaarlio_tld_unpack_raster(\n                          (unsigned char *)&buffer, 1, NULL, NULL, 0, 0));\n    PASS();\n"]]}
{"hexsha": "47e987f5f40938c18c24e90791ceebb45ea4030c", "ext": "c", "lang": "C", "content": "JNICALL Java_com_bitmark_cryptography_crypto_sodium_SodiumJNI_crypto_1auth_1hmacsha512_1bytes(JNIEnv *jenv, jclass jcls) {\n  jint jresult = 0 ;\n  size_t result;\n  \n  (void)jenv;\n  (void)jcls;\n  result = crypto_auth_hmacsha512_bytes();\n  jresult = (jint)result; \n  return jresult;\n}", "item_id": 172, "repo": "bitmark-inc/bitmark-sdk-java", "file": "cryptography/jni/sodium_wrap.c", "last_update_at": "2018-09-21T05:01:42+00:00", "question_id": "47e987f5f40938c18c24e90791ceebb45ea4030c_172", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["JNICALL Java_com_bitmark_cryptography_crypto_sodium_SodiumJNI_crypto_1auth_1hmacsha512_1bytes(JNIEnv *jenv, jclass jcls) {\n  jint jresult = 0 ;\n  size_t result;\n  (void)jenv;\n  (void)jcls;\n  result = crypto_auth_hmacsha512_bytes();\n  jresult = (jint)result; \n  return jresult;\n"]]}
{"hexsha": "d1e594c3e741e39d8d103b170a6975b463fa4d95", "ext": "c", "lang": "C", "content": "struct IndexData * IndexDataCreate()\n{\n\tstruct IndexData * ret = malloc( sizeof( struct IndexData ) );\n\tret->indexcount = 0;\n#ifdef USE_IBO\n\tret->ido = 0;\n#else\n\tret->indexdata = 0;\n#endif\n}", "item_id": 21, "repo": "cnlohr/bridgesim", "file": "src/cclient/graphics/graphicscore.c", "last_update_at": "2018-05-09T22:27:33+00:00", "question_id": "d1e594c3e741e39d8d103b170a6975b463fa4d95_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct IndexData * IndexDataCreate()\n{\n\tstruct IndexData * ret = malloc( sizeof( struct IndexData ) );\n\tret->indexcount = 0;\n#ifdef USE_IBO\n\tret->ido = 0;\n#else\n\tret->indexdata = 0;\n#endif\n"]]}
{"hexsha": "077ade691ebc998d455a13f561b09ece94a1f115", "ext": "h", "lang": "C", "content": "class ModApiHttp : public ModApiBase {\nprivate:\n#if USE_CURL\n\t// Helpers for HTTP fetch functions\n\tstatic void read_http_fetch_request(lua_State *L, HTTPFetchRequest &req);\n\tstatic void push_http_fetch_result(lua_State *L, HTTPFetchResult &res, bool completed = true);\n\n\t// http_fetch_async({url=, timeout=, post_data=})\n\tstatic int l_http_fetch_async(lua_State *L);\n\n\t// http_fetch_async_get(handle)\n\tstatic int l_http_fetch_async_get(lua_State *L);\n\n\t// request_http_api()\n\tstatic int l_request_http_api(lua_State *L);\n#endif\n\npublic:\n\tstatic void Initialize(lua_State *L, int top);\n}", "item_id": 0, "repo": "crazyBaboon/MathWorlds", "file": "src/script/lua_api/l_http.h", "last_update_at": "2018-03-01T13:03:01+00:00", "question_id": "077ade691ebc998d455a13f561b09ece94a1f115_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class ModApiHttp : public ModApiBase {\nprivate:\n#if USE_CURL\n\t// Helpers for HTTP fetch functions\n\tstatic void read_http_fetch_request(lua_State *L, HTTPFetchRequest &req);\n\tstatic void push_http_fetch_result(lua_State *L, HTTPFetchResult &res, bool completed = true);\n\t// http_fetch_async({url=, timeout=, post_data=})\n\tstatic int l_http_fetch_async(lua_State *L);\n\t// http_fetch_async_get(handle)\n\tstatic int l_http_fetch_async_get(lua_State *L);\n\t// request_http_api()\n\tstatic int l_request_http_api(lua_State *L);\n#endif\npublic:\n\tstatic void Initialize(lua_State *L, int top);\n"]]}
{"hexsha": "fecd166f4c24431102ac68587ad03086e10c5612", "ext": "c", "lang": "C", "content": "void runScheduler(){\n\tif(currentProcess->process.PID == 0 && allProcess > 1 && allProcessForeground > 0){\n\t\tcurrentProcess->process.status = LOCKED;\n\t}\n\n\tif(numberOfTicks < QUANTUM) {\n\t\t\t\n\t\tnumberOfTicks++;\n\t\tdisableTickInter();\n\t\tcheckIfThreadChange();\n\t\tenableTickInter();\n\t\treturn;\n\t}\n\t\n\t\n\tnumberOfTicks = 0;\n\n\n\tif(currentProcess->process.status == RUNNING){\n\t\tcurrentProcess->process.status = READY;\n\t}\n\n\tcurrentProcess = currentProcess->next;\n\n\twhile(currentProcess->process.status != READY){\n\t\tcurrentProcess = currentProcess->next;\n\t}\n\t\n\tcurrentProcess->process.status = RUNNING;\n}", "item_id": 0, "repo": "asantoflaminio/TP2_SO", "file": "Kernel/scheduler.c", "last_update_at": "2018-05-17T19:08:44+00:00", "question_id": "fecd166f4c24431102ac68587ad03086e10c5612_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void runScheduler(){\n\tif(currentProcess->process.PID == 0 && allProcess > 1 && allProcessForeground > 0){\n\t\tcurrentProcess->process.status = LOCKED;\n\t}\n\tif(numberOfTicks < QUANTUM) {\n\t\t\t\n\t\tnumberOfTicks++;\n\t\tdisableTickInter();\n\t\tcheckIfThreadChange();\n\t\tenableTickInter();\n\t\treturn;\n\t}\n\t\n\t\n\tnumberOfTicks = 0;\n\tif(currentProcess->process.status == RUNNING){\n\t\tcurrentProcess->process.status = READY;\n\t}\n\tcurrentProcess = currentProcess->next;\n\twhile(currentProcess->process.status != READY){\n\t\tcurrentProcess = currentProcess->next;\n\t}\n\t\n\tcurrentProcess->process.status = RUNNING;\n"]]}
{"hexsha": "52041092ea22f29a5386520d8f56251651b5062c", "ext": "c", "lang": "C", "content": "void smt2_set_info(const char *name, aval_t value) {\n  smt2_globals_t *g;\n  smt2_keyword_t kw;\n  uint32_t n, version;\n\n  g = &__smt2_globals;\n\n  n = kwlen(name);\n  kw = smt2_string_to_keyword(name, n);\n\n  switch (kw) {\n  case SMT2_KW_ERROR_BEHAVIOR:\n  case SMT2_KW_NAME:\n  case SMT2_KW_AUTHORS:\n  case SMT2_KW_VERSION:\n  case SMT2_KW_REASON_UNKNOWN:\n  case SMT2_KW_ALL_STATISTICS:\n    print_error(\"can't overwrite %s\", name);\n    break;\n\n  case SMT2_KW_SMT_LIB_VERSION:\n    // quick hack to switch parser if 2.5 is selected\n    if (g->smtlib_version != 0) {\n      print_error(\"can't set :smt-lib-version twice\");\n    } else if (aval_is_known_version(g->avtbl, value, &version)) {\n      assert(version == 2000 || version == 2500);\n      g->smtlib_version = version;\n      if (version == 2500) {\n\tsmt2_lexer_activate_two_dot_five();\n      }\n      report_success();\n    } else {\n      print_error(\"unsupported :smt-lib-version\");\n    }\n    break;\n\n  default:\n    add_info(g, name, value);\n    report_success();\n    break;\n  }\n}", "item_id": 99, "repo": "maelvls/ocamlyices2", "file": "ext/yices/src/frontend/smt2/smt2_commands.c", "last_update_at": "2018-11-23T00:16:01+00:00", "question_id": "52041092ea22f29a5386520d8f56251651b5062c_99", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void smt2_set_info(const char *name, aval_t value) {\n  smt2_globals_t *g;\n  smt2_keyword_t kw;\n  uint32_t n, version;\n  g = &__smt2_globals;\n  n = kwlen(name);\n  kw = smt2_string_to_keyword(name, n);\n  switch (kw) {\n  case SMT2_KW_ERROR_BEHAVIOR:\n  case SMT2_KW_NAME:\n  case SMT2_KW_AUTHORS:\n  case SMT2_KW_VERSION:\n  case SMT2_KW_REASON_UNKNOWN:\n  case SMT2_KW_ALL_STATISTICS:\n    print_error(\"can't overwrite %s\", name);\n    break;\n  case SMT2_KW_SMT_LIB_VERSION:\n    // quick hack to switch parser if 2.5 is selected\n    if (g->smtlib_version != 0) {\n      print_error(\"can't set :smt-lib-version twice\");\n    } else if (aval_is_known_version(g->avtbl, value, &version)) {\n      assert(version == 2000 || version == 2500);\n      g->smtlib_version = version;\n      if (version == 2500) {\n\tsmt2_lexer_activate_two_dot_five();\n      }\n      report_success();\n    } else {\n      print_error(\"unsupported :smt-lib-version\");\n    }\n    break;\n  default:\n    add_info(g, name, value);\n    report_success();\n    break;\n  }\n"]]}
{"hexsha": "8876e7f3bfa35524c53cdb237e34bf62c286cfd7", "ext": "c", "lang": "C", "content": "static int\nport_imirror_lt_fields_parse(int unit,\n                             const bcmltd_field_t *key,\n                             const bcmltd_field_t *data,\n                             port_imirror_t *imirror)\n{\n    const bcmltd_field_t *gen_field;\n    uint32_t fid;\n    uint64_t fval;\n\n    SHR_FUNC_ENTER(unit);\n\n    sal_memset(imirror, 0, sizeof(*imirror));\n\n    /* Parse key field */\n    gen_field = key;\n    while (gen_field) {\n        fid = gen_field->id;\n        fval = gen_field->data;\n\n        switch (fid) {\n        case PORT_ING_MIRRORt_PORT_IDf:\n            imirror->port = fval;\n            SHR_BITSET(imirror->fbmp, fid);\n            break;\n        case PORT_ING_MIRRORt_MIRROR_INSTANCE_IDf:\n            imirror->instance_id = fval;\n            SHR_BITSET(imirror->fbmp, fid);\n            break;\n        default:\n            SHR_RETURN_VAL_EXIT(SHR_E_PARAM);\n        }\n        gen_field = gen_field->next;\n    }\n\n    /* Parse data field */\n    gen_field = data;\n    while (gen_field) {\n        fid = gen_field->id;\n        fval = gen_field->data;\n\n        switch (fid) {\n        case PORT_ING_MIRRORt_MIRROR_ENABLEf:\n            imirror->enable = fval;\n            SHR_BITSET(imirror->fbmp, fid);\n            break;\n        default:\n            SHR_RETURN_VAL_EXIT(SHR_E_PARAM);\n        }\n        gen_field = gen_field->next;\n    }\n\nexit:\n    SHR_FUNC_EXIT();\n}", "item_id": 0, "repo": "lguohan/SDKLT", "file": "src/bcmport/main/bcmport_imm.c", "last_update_at": "2018-01-31T07:21:49+00:00", "question_id": "8876e7f3bfa35524c53cdb237e34bf62c286cfd7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nport_imirror_lt_fields_parse(int unit,\n                             const bcmltd_field_t *key,\n                             const bcmltd_field_t *data,\n                             port_imirror_t *imirror)\n{\n    const bcmltd_field_t *gen_field;\n    uint32_t fid;\n    uint64_t fval;\n    SHR_FUNC_ENTER(unit);\n    sal_memset(imirror, 0, sizeof(*imirror));\n    /* Parse key field */\n    gen_field = key;\n    while (gen_field) {\n        fid = gen_field->id;\n        fval = gen_field->data;\n        switch (fid) {\n        case PORT_ING_MIRRORt_PORT_IDf:\n            imirror->port = fval;\n            SHR_BITSET(imirror->fbmp, fid);\n            break;\n        case PORT_ING_MIRRORt_MIRROR_INSTANCE_IDf:\n            imirror->instance_id = fval;\n            SHR_BITSET(imirror->fbmp, fid);\n            break;\n        default:\n            SHR_RETURN_VAL_EXIT(SHR_E_PARAM);\n        }\n        gen_field = gen_field->next;\n    }\n    /* Parse data field */\n    gen_field = data;\n    while (gen_field) {\n        fid = gen_field->id;\n        fval = gen_field->data;\n        switch (fid) {\n        case PORT_ING_MIRRORt_MIRROR_ENABLEf:\n            imirror->enable = fval;\n            SHR_BITSET(imirror->fbmp, fid);\n            break;\n        default:\n            SHR_RETURN_VAL_EXIT(SHR_E_PARAM);\n        }\n        gen_field = gen_field->next;\n    }\nexit:\n    SHR_FUNC_EXIT();\n"]]}
{"hexsha": "774ed3fc9c97140400eba133562eac4e551115c4", "ext": "c", "lang": "C", "content": "void dvmDdmSendThreadNameChange(int threadId, StringObject* newName)\n{\n    if (!gDvm.ddmThreadNotification)\n        return;\n\n    size_t stringLen = dvmStringLen(newName);\n    const u2* chars = dvmStringChars(newName);\n\n    /*\n     * Output format:\n     *  (4b) thread ID\n     *  (4b) stringLen\n     *  (xb) string chars\n     */\n    int bufLen = 4 + 4 + (stringLen * 2);\n    u1 buf[bufLen];\n\n    set4BE(&buf[0x00], threadId);\n    set4BE(&buf[0x04], stringLen);\n    u2* outChars = (u2*) &buf[0x08];\n    while (stringLen--)\n        set2BE((u1*) (outChars++), *chars++);\n\n    dvmDbgDdmSendChunk(CHUNK_TYPE(\"THNM\"), bufLen, buf);\n}", "item_id": 6, "repo": "mcoughli/platform-dalvik", "file": "vm/Ddm.c", "last_update_at": "2018-03-07T04:33:50+00:00", "question_id": "774ed3fc9c97140400eba133562eac4e551115c4_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void dvmDdmSendThreadNameChange(int threadId, StringObject* newName)\n{\n    if (!gDvm.ddmThreadNotification)\n        return;\n    size_t stringLen = dvmStringLen(newName);\n    const u2* chars = dvmStringChars(newName);\n    /*\n     * Output format:\n     *  (4b) thread ID\n     *  (4b) stringLen\n     *  (xb) string chars\n     */\n    int bufLen = 4 + 4 + (stringLen * 2);\n    u1 buf[bufLen];\n    set4BE(&buf[0x00], threadId);\n    set4BE(&buf[0x04], stringLen);\n    u2* outChars = (u2*) &buf[0x08];\n    while (stringLen--)\n        set2BE((u1*) (outChars++), *chars++);\n    dvmDbgDdmSendChunk(CHUNK_TYPE(\"THNM\"), bufLen, buf);\n"]]}
{"hexsha": "ea5a0ad4946ded29145c2bd5514b9379b4a85101", "ext": "c", "lang": "C", "content": "static int\nrp_event_notif_match_subscr(const char *ntf_xpath, const char *subscr_xpath)\n{\n    /* specific subscription for this notification */\n    if (!strcmp(ntf_xpath, subscr_xpath)) {\n        return 1;\n    }\n\n    /* whole module subscription */\n    if (!strcmp(subscr_xpath + strlen(subscr_xpath) - 4, \"*//.\") && !strncmp(ntf_xpath, subscr_xpath, strlen(subscr_xpath) - 4)) {\n        return 1;\n    }\n\n    return 0;\n}", "item_id": 50, "repo": "ADTRAN/sysrepo", "file": "src/request_processor.c", "last_update_at": "2018-09-09T08:39:47+00:00", "question_id": "ea5a0ad4946ded29145c2bd5514b9379b4a85101_50", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nrp_event_notif_match_subscr(const char *ntf_xpath, const char *subscr_xpath)\n{\n    /* specific subscription for this notification */\n    if (!strcmp(ntf_xpath, subscr_xpath)) {\n        return 1;\n    }\n    /* whole module subscription */\n    if (!strcmp(subscr_xpath + strlen(subscr_xpath) - 4, \"*//.\") && !strncmp(ntf_xpath, subscr_xpath, strlen(subscr_xpath) - 4)) {\n        return 1;\n    }\n    return 0;\n"]]}
{"hexsha": "02a113cae40488f23acabe7f0714840b3b481ffd", "ext": "c", "lang": "C", "content": "int** zigzagLevelOrder(struct TreeNode* root, int** columnSizes, int* returnSize)\n{\n\tstruct TreeNode** queue;\n\tint front, rear;\n\tint QueueSize;\n\tstruct TreeNode** stack;\n\tint top;\n\tint level, i;\n    int j, k;\n\tint** result;\n\tstruct TreeNode* T;\n\t*returnSize = 0;\n\n\tif(root == NULL)\n\t\treturn NULL;\n\n\tfront = 0;\n\trear = -1;\n\ttop = -1;\n\tlevel = 0;\n    j = 1;\n    k = 0;\n\t*columnSizes = (int*)malloc(sizeof(int));\n\tresult = (int**)malloc(sizeof(int*));\n    queue = (struct TreeNode**)malloc(sizeof(struct TreeNode*));\n    stack = (struct TreeNode**)malloc(sizeof(struct TreeNode*));\n\tqueue[++rear] = root;\n\tQueueSize= rear - front + 1;\n\twhile(QueueSize > 0)\n\t{\n\t\ti = 0;\n        \n        result = (int**)realloc(result, (level+1)*sizeof(int*));\n        result[level] = (int*)malloc(sizeof(int));\n\t\tif(level % 2 == 0)\n\t\t{\n\t\t\twhile(QueueSize > 0)\n\t\t\t{\n\t\t\t\tT = queue[front++];\n                result[level] = (int*)realloc(result[level], (i+1)*sizeof(int));\n\t\t\t\tresult[level][i++] = T->val;\n\t\t\t\tif(T->left)\n                {\n                    queue = (struct TreeNode**)realloc(queue, (++j)*sizeof(struct TreeNode*));\n                    queue[++rear] = T->left;\n                }\n\t\t\t\tif(T->right)\n                {\n                    queue = (struct TreeNode**)realloc(queue, (++j)*sizeof(struct TreeNode*));\n                    queue[++rear] = T->right;\n                }\n\t\t\t\tQueueSize--;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile(QueueSize > 0)\n\t\t\t{\n\t\t\t\tT = queue[front++];\n                stack = (struct TreeNode**)realloc(stack, (++k)*sizeof(struct TreeNode*));\n\t\t\t\tstack[++top] = T;\n\t\t\t\tif(T->left)\n                {\n                    queue = (struct TreeNode**)realloc(queue, (++j)*sizeof(struct TreeNode*));\n                    queue[++rear] = T->left;\n                }\n\t\t\t\tif(T->right)\n                {\n                    queue = (struct TreeNode**)realloc(queue, (++j)*sizeof(struct TreeNode*));\n                    queue[++rear] = T->right;\n                }\n\t\t\t\tQueueSize--;\n\t\t\t}\n\t\t\twhile(top != -1)\n\t\t\t{\n\t\t\t\tT = stack[top--];\n                result[level] = (int*)realloc(result[level], (i+1)*sizeof(int));\n\t\t\t\tresult[level][i++] = T->val;\n\t\t\t}\n\t\t}\n        (*columnSizes) = (int*)realloc((*columnSizes), (level+1)*sizeof(int));\n\t\t(*columnSizes)[level++] = i;\n\t\tQueueSize = rear - front + 1;\n\t}\n\n\t*returnSize = level;\n\treturn result;\n}", "item_id": 0, "repo": "VamosC/LeetCode", "file": "Tree/103BinaryTreeZigzagLevel OrderTraversal/src/103.c", "last_update_at": "2018-04-23T08:48:46+00:00", "question_id": "02a113cae40488f23acabe7f0714840b3b481ffd_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int** zigzagLevelOrder(struct TreeNode* root, int** columnSizes, int* returnSize)\n{\n\tstruct TreeNode** queue;\n\tint front, rear;\n\tint QueueSize;\n\tstruct TreeNode** stack;\n\tint top;\n\tint level, i;\n    int j, k;\n\tint** result;\n\tstruct TreeNode* T;\n\t*returnSize = 0;\n\tif(root == NULL)\n\t\treturn NULL;\n\tfront = 0;\n\trear = -1;\n\ttop = -1;\n\tlevel = 0;\n    j = 1;\n    k = 0;\n\t*columnSizes = (int*)malloc(sizeof(int));\n\tresult = (int**)malloc(sizeof(int*));\n    queue = (struct TreeNode**)malloc(sizeof(struct TreeNode*));\n    stack = (struct TreeNode**)malloc(sizeof(struct TreeNode*));\n\tqueue[++rear] = root;\n\tQueueSize= rear - front + 1;\n\twhile(QueueSize > 0)\n\t{\n\t\ti = 0;\n        result = (int**)realloc(result, (level+1)*sizeof(int*));\n        result[level] = (int*)malloc(sizeof(int));\n\t\tif(level % 2 == 0)\n\t\t{\n\t\t\twhile(QueueSize > 0)\n\t\t\t{\n\t\t\t\tT = queue[front++];\n                result[level] = (int*)realloc(result[level], (i+1)*sizeof(int));\n\t\t\t\tresult[level][i++] = T->val;\n\t\t\t\tif(T->left)\n                {\n                    queue = (struct TreeNode**)realloc(queue, (++j)*sizeof(struct TreeNode*));\n                    queue[++rear] = T->left;\n                }\n\t\t\t\tif(T->right)\n                {\n                    queue = (struct TreeNode**)realloc(queue, (++j)*sizeof(struct TreeNode*));\n                    queue[++rear] = T->right;\n                }\n\t\t\t\tQueueSize--;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile(QueueSize > 0)\n\t\t\t{\n\t\t\t\tT = queue[front++];\n                stack = (struct TreeNode**)realloc(stack, (++k)*sizeof(struct TreeNode*));\n\t\t\t\tstack[++top] = T;\n\t\t\t\tif(T->left)\n                {\n                    queue = (struct TreeNode**)realloc(queue, (++j)*sizeof(struct TreeNode*));\n                    queue[++rear] = T->left;\n                }\n\t\t\t\tif(T->right)\n                {\n                    queue = (struct TreeNode**)realloc(queue, (++j)*sizeof(struct TreeNode*));\n                    queue[++rear] = T->right;\n                }\n\t\t\t\tQueueSize--;\n\t\t\t}\n\t\t\twhile(top != -1)\n\t\t\t{\n\t\t\t\tT = stack[top--];\n                result[level] = (int*)realloc(result[level], (i+1)*sizeof(int));\n\t\t\t\tresult[level][i++] = T->val;\n\t\t\t}\n\t\t}\n        (*columnSizes) = (int*)realloc((*columnSizes), (level+1)*sizeof(int));\n\t\t(*columnSizes)[level++] = i;\n\t\tQueueSize = rear - front + 1;\n\t}\n\t*returnSize = level;\n\treturn result;\n"]]}
{"hexsha": "64655db5ced32871a85d4f40915dfefc2a7c8712", "ext": "c", "lang": "C", "content": "static int\nmemset_init(struct benchmark *bench, struct benchmark_args *args)\n{\n\tassert(bench != NULL);\n\tassert(args != NULL);\n\tassert(args->opts != NULL);\n\n\tint ret = 0;\n\n\tstruct memset_bench *mb = malloc(sizeof (struct memset_bench));\n\tif (!mb) {\n\t\tperror(\"malloc\");\n\t\treturn -1;\n\t}\n\n\tmb->pargs = args->opts;\n\tmb->pargs->chunk_size = args->dsize;\n\n\tenum operation_mode op_mode = parse_op_mode(mb->pargs->mode);\n\tif (op_mode == OP_MODE_UNKNOWN) {\n\t\tfprintf(stderr, \"Invalid operation mode argument '%s'\",\n\t\t\tmb->pargs->mode);\n\t\tret = -1;\n\t\tgoto err_free_mb;\n\t}\n\n\tsize_t size = MAX_OFFSET + mb->pargs->chunk_size;\n\tsize_t large = size * args->n_ops_per_thread * args->n_threads;\n\n\tsize_t small = size * args->n_threads;\n\n\tmb->fsize = (op_mode == OP_MODE_STAT) ? small : large;\n\n\tmb->n_randoms = args->n_ops_per_thread * args->n_threads;\n\tmb->randoms = malloc(mb->n_randoms * sizeof (*mb->randoms));\n\tif (!mb->randoms) {\n\t\tperror(\"malloc\");\n\t\tret = -1;\n\t\tgoto err_free_mb;\n\t}\n\n\tunsigned int seed = mb->pargs->seed;\n\tfor (int i = 0; i < mb->n_randoms; i++)\n\t\tmb->randoms[i] = rand_r(&seed) % args->n_ops_per_thread;\n\n\tmb->flags = O_CREAT | O_EXCL | O_RDWR;\n\n\t/* create a pmem file */\n\tmb->fd = open(args->fname, mb->flags, args->fmode);\n\tif (mb->fd == -1) {\n\t\tperror(args->fname);\n\t\tret = -1;\n\t\tgoto err_free_randoms;\n\t}\n\n\t/* allocate the pmem */\n\tif ((errno = posix_fallocate(mb->fd, 0, mb->fsize)) != 0) {\n\t\tperror(\"posix_fallocate\");\n\t\tret = -1;\n\t\tgoto err_close_file;\n\t}\n\n\t/* memory map it */\n\tmb->pmem_addr = pmem_map(mb->fd);\n\tif (mb->pmem_addr == NULL) {\n\t\tperror(\"pmem_map\");\n\t\tret = -1;\n\t\tgoto err_close_file;\n\t}\n\n\t/* set proper func_dest() depending on benchmark args */\n\tmb->func_dest = assign_mode_func(mb->pargs->mode);\n\tif (mb->func_dest == NULL) {\n\t\tfprintf(stderr, \"wrong mode parameter -- '%s'\",\n\t\t\t\tmb->pargs->mode);\n\t\tret = -1;\n\t\tgoto err_unmap;\n\t}\n\n\tif (mb->pargs->memset)\n\t\tmb->func_op = (mb->pargs->persist) ?\n\t\t\t\tlibc_memset_persist : libc_memset;\n\telse\n\t\tmb->func_op = (mb->pargs->persist) ?\n\t\t\t\tlibpmem_memset_persist : libpmem_memset_nodrain;\n\n\tif (!mb->pargs->no_warmup) {\n\t\tif (do_warmup(\n\t\t\tmb, args->n_threads * args->n_ops_per_thread) != 0) {\n\t\t\tfprintf(stderr, \"do_warmup() function failed.\");\n\t\t\tret = -1;\n\t\t\tgoto err_unmap;\n\t\t}\n\t}\n\n\tclose(mb->fd);\n\n\tpmembench_set_priv(bench, mb);\n\n\treturn 0;\n\nerr_unmap:\n\tmunmap(mb->pmem_addr, mb->fsize);\nerr_close_file:\n\tclose(mb->fd);\nerr_free_randoms:\n\tfree(mb->randoms);\nerr_free_mb:\n\tfree(mb);\n\n\treturn ret;\n}", "item_id": 4, "repo": "jessesleeping/my_peloton", "file": "third_party/nvml/src/benchmarks/pmem_memset.c", "last_update_at": "2018-11-06T07:06:49+00:00", "question_id": "64655db5ced32871a85d4f40915dfefc2a7c8712_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nmemset_init(struct benchmark *bench, struct benchmark_args *args)\n{\n\tassert(bench != NULL);\n\tassert(args != NULL);\n\tassert(args->opts != NULL);\n\tint ret = 0;\n\tstruct memset_bench *mb = malloc(sizeof (struct memset_bench));\n\tif (!mb) {\n\t\tperror(\"malloc\");\n\t\treturn -1;\n\t}\n\tmb->pargs = args->opts;\n\tmb->pargs->chunk_size = args->dsize;\n\tenum operation_mode op_mode = parse_op_mode(mb->pargs->mode);\n\tif (op_mode == OP_MODE_UNKNOWN) {\n\t\tfprintf(stderr, \"Invalid operation mode argument '%s'\",\n\t\t\tmb->pargs->mode);\n\t\tret = -1;\n\t\tgoto err_free_mb;\n\t}\n\tsize_t size = MAX_OFFSET + mb->pargs->chunk_size;\n\tsize_t large = size * args->n_ops_per_thread * args->n_threads;\n\tsize_t small = size * args->n_threads;\n\tmb->fsize = (op_mode == OP_MODE_STAT) ? small : large;\n\tmb->n_randoms = args->n_ops_per_thread * args->n_threads;\n\tmb->randoms = malloc(mb->n_randoms * sizeof (*mb->randoms));\n\tif (!mb->randoms) {\n\t\tperror(\"malloc\");\n\t\tret = -1;\n\t\tgoto err_free_mb;\n\t}\n\tunsigned int seed = mb->pargs->seed;\n\tfor (int i = 0; i < mb->n_randoms; i++)\n\t\tmb->randoms[i] = rand_r(&seed) % args->n_ops_per_thread;\n\tmb->flags = O_CREAT | O_EXCL | O_RDWR;\n\t/* create a pmem file */\n\tmb->fd = open(args->fname, mb->flags, args->fmode);\n\tif (mb->fd == -1) {\n\t\tperror(args->fname);\n\t\tret = -1;\n\t\tgoto err_free_randoms;\n\t}\n\t/* allocate the pmem */\n\tif ((errno = posix_fallocate(mb->fd, 0, mb->fsize)) != 0) {\n\t\tperror(\"posix_fallocate\");\n\t\tret = -1;\n\t\tgoto err_close_file;\n\t}\n\t/* memory map it */\n\tmb->pmem_addr = pmem_map(mb->fd);\n\tif (mb->pmem_addr == NULL) {\n\t\tperror(\"pmem_map\");\n\t\tret = -1;\n\t\tgoto err_close_file;\n\t}\n\t/* set proper func_dest() depending on benchmark args */\n\tmb->func_dest = assign_mode_func(mb->pargs->mode);\n\tif (mb->func_dest == NULL) {\n\t\tfprintf(stderr, \"wrong mode parameter -- '%s'\",\n\t\t\t\tmb->pargs->mode);\n\t\tret = -1;\n\t\tgoto err_unmap;\n\t}\n\tif (mb->pargs->memset)\n\t\tmb->func_op = (mb->pargs->persist) ?\n\t\t\t\tlibc_memset_persist : libc_memset;\n\telse\n\t\tmb->func_op = (mb->pargs->persist) ?\n\t\t\t\tlibpmem_memset_persist : libpmem_memset_nodrain;\n\tif (!mb->pargs->no_warmup) {\n\t\tif (do_warmup(\n\t\t\tmb, args->n_threads * args->n_ops_per_thread) != 0) {\n\t\t\tfprintf(stderr, \"do_warmup() function failed.\");\n\t\t\tret = -1;\n\t\t\tgoto err_unmap;\n\t\t}\n\t}\n\tclose(mb->fd);\n\tpmembench_set_priv(bench, mb);\n\treturn 0;\nerr_unmap:\n\tmunmap(mb->pmem_addr, mb->fsize);\nerr_close_file:\n\tclose(mb->fd);\nerr_free_randoms:\n\tfree(mb->randoms);\nerr_free_mb:\n\tfree(mb);\n\treturn ret;\n"]]}
{"hexsha": "5a5ce4e0ca764a9b0333d41085a4a154262ce591", "ext": "h", "lang": "C", "content": "inline void InsertTailList(\n\tplist_entry ListHead,\n\tplist_entry Entry\n)\n{\n\tplist_entry Blink;\n\n\tBlink = ListHead->Blink;\n\tEntry->Flink = ListHead;\n\tEntry->Blink = Blink;\n\tBlink->Flink = Entry;\n\tListHead->Blink = Entry;\n\treturn;\n}", "item_id": 3, "repo": "wyc6668205/common", "file": "list_entry.h", "last_update_at": "2018-11-16T02:53:08+00:00", "question_id": "5a5ce4e0ca764a9b0333d41085a4a154262ce591_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["inline void InsertTailList(\n\tplist_entry ListHead,\n\tplist_entry Entry\n)\n{\n\tplist_entry Blink;\n\tBlink = ListHead->Blink;\n\tEntry->Flink = ListHead;\n\tEntry->Blink = Blink;\n\tBlink->Flink = Entry;\n\tListHead->Blink = Entry;\n\treturn;\n"]]}
{"hexsha": "5c9f565ea0e88840c3c3c7a031e20180c3c8025d", "ext": "c", "lang": "C", "content": "static void iser_free_ib_conn_res(struct iser_conn *iser_conn,\n\t\t\t\t  bool destroy)\n{\n\tstruct ib_conn *ib_conn = &iser_conn->ib_conn;\n\tstruct iser_device *device = ib_conn->device;\n\n\tiser_info(\"freeing conn %p cma_id %p qp %p\\n\",\n\t\t  iser_conn, ib_conn->cma_id, ib_conn->qp);\n\n\tif (ib_conn->qp != NULL) {\n\t\tib_conn->comp->active_qps--;\n\t\trdma_destroy_qp(ib_conn->cma_id);\n\t\tib_conn->qp = NULL;\n\t}\n\n\tif (destroy) {\n\t\tif (iser_conn->rx_descs)\n\t\t\tiser_free_rx_descriptors(iser_conn);\n\n\t\tif (device != NULL) {\n\t\t\tiser_device_try_release(device);\n\t\t\tib_conn->device = NULL;\n\t\t}\n\t}\n}", "item_id": 14, "repo": "SIIS-cloud/pileus", "file": "difc-kernel/pileus-kernel/drivers/infiniband/ulp/iser/iser_verbs.c", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "5c9f565ea0e88840c3c3c7a031e20180c3c8025d_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void iser_free_ib_conn_res(struct iser_conn *iser_conn,\n\t\t\t\t  bool destroy)\n{\n\tstruct ib_conn *ib_conn = &iser_conn->ib_conn;\n\tstruct iser_device *device = ib_conn->device;\n\tiser_info(\"freeing conn %p cma_id %p qp %p\\n\",\n\t\t  iser_conn, ib_conn->cma_id, ib_conn->qp);\n\tif (ib_conn->qp != NULL) {\n\t\tib_conn->comp->active_qps--;\n\t\trdma_destroy_qp(ib_conn->cma_id);\n\t\tib_conn->qp = NULL;\n\t}\n\tif (destroy) {\n\t\tif (iser_conn->rx_descs)\n\t\t\tiser_free_rx_descriptors(iser_conn);\n\t\tif (device != NULL) {\n\t\t\tiser_device_try_release(device);\n\t\t\tib_conn->device = NULL;\n\t\t}\n\t}\n"]]}
{"hexsha": "fd1867128f756754c01e89d416b432f573e59ede", "ext": "c", "lang": "C", "content": "bool dble_less_than(double x, double y, int precision)\n{\n\t// LOCAL VARIABLES\n\tbool retVal = false;  // Prove this wrong\n\tbool success = true;  // Set this to false if anything fails\n\tdouble dbleMask = 0;  // \"Mask\" to remove undesired values of doubles\n\tdouble xVal = truncate_double(x, precision);\n\tdouble yVal = truncate_double(y, precision);\n\t\n\t// INPUT VALIDATION\n\tif (precision < 1)\n\t{\n\t\tHARKLE_ERROR(Harklemath, dble_greater_than, Invalid precision);\n\t\tsuccess = false;\n\t}\n\t\n\t// CALC PRECISION\n\tif (true == success)\n\t{\n\t\tdbleMask = calc_precision(precision);\n\t\t\n\t\tif (!dbleMask)\n\t\t{\n\t\t\tHARKLE_ERROR(Harklemath, dble_greater_than, calc_precision failed);\n\t\t\tsuccess = false;\n\t\t}\n\t\t// fprintf(stdout, \"\\nx == %.15f\\ty == %.15f\\tdbleMask == %.15f\\n\", x, y, dbleMask);  // DEBUGGING\n\t\t// fprintf(stdout, \"\\nxTrunc == %.15f\\tyTrunc == %.15f\\tprecision == %d\\n\\t\\t\", xVal, yVal, precision);  // DEBUGGING\n\t}\n\t\n\t// COMPARE DOUBLES\n\tif (true == success)\n\t{\n\t\t// fprintf(stdout, \"\\nx == %.15f\\ty == %.15f\\tdbleMask == %.15f\\n\", x, y, dbleMask);  // DEBUGGING\n\t\t// fprintf(stdout, \"x < y == %.15f < %.15f == %s\\n\", x, y, (x < y) ? \"true\" : \"false\");  // DEBUGGING\n\t\t// fprintf(stdout, \"(x + dbleMask) < (y + dbleMask) == %.15f < %.15f == %s\\n\", \\\n\t\t// \tx + dbleMask, y + dbleMask, ((x + dbleMask) < (y + dbleMask)) ? \"true\" : \"false\");  // DEBUGGING\n\t\t// fprintf(stdout, \"(x - dbleMask) < (y - dbleMask) == %.15f < %.15f == %s\\n\\t\\t\", \\\n\t\t// \tx - dbleMask, y - dbleMask, ((x - dbleMask) < (y - dbleMask)) ? \"true\" : \"false\");  // DEBUGGING\n\t\tif (xVal < yVal)\n\t\t// if (x < y && (x + dbleMask) < (y + dbleMask) && (x - dbleMask) < (y - dbleMask))\n\t\t{\n\t\t\tretVal = true;\t\n\t\t}\t\t\n\t}\t\n\t\n\t// DONE\n\treturn retVal;\n}", "item_id": 2, "repo": "joshuadugie/Latissimus_Dorsi", "file": "3-Internals/Harklemath.c", "last_update_at": "2018-07-13T14:18:56+00:00", "question_id": "fd1867128f756754c01e89d416b432f573e59ede_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool dble_less_than(double x, double y, int precision)\n{\n\t// LOCAL VARIABLES\n\tbool retVal = false;  // Prove this wrong\n\tbool success = true;  // Set this to false if anything fails\n\tdouble dbleMask = 0;  // \"Mask\" to remove undesired values of doubles\n\tdouble xVal = truncate_double(x, precision);\n\tdouble yVal = truncate_double(y, precision);\n\t\n\t// INPUT VALIDATION\n\tif (precision < 1)\n\t{\n\t\tHARKLE_ERROR(Harklemath, dble_greater_than, Invalid precision);\n\t\tsuccess = false;\n\t}\n\t\n\t// CALC PRECISION\n\tif (true == success)\n\t{\n\t\tdbleMask = calc_precision(precision);\n\t\t\n\t\tif (!dbleMask)\n\t\t{\n\t\t\tHARKLE_ERROR(Harklemath, dble_greater_than, calc_precision failed);\n\t\t\tsuccess = false;\n\t\t}\n\t\t// fprintf(stdout, \"\\nx == %.15f\\ty == %.15f\\tdbleMask == %.15f\\n\", x, y, dbleMask);  // DEBUGGING\n\t\t// fprintf(stdout, \"\\nxTrunc == %.15f\\tyTrunc == %.15f\\tprecision == %d\\n\\t\\t\", xVal, yVal, precision);  // DEBUGGING\n\t}\n\t\n\t// COMPARE DOUBLES\n\tif (true == success)\n\t{\n\t\t// fprintf(stdout, \"\\nx == %.15f\\ty == %.15f\\tdbleMask == %.15f\\n\", x, y, dbleMask);  // DEBUGGING\n\t\t// fprintf(stdout, \"x < y == %.15f < %.15f == %s\\n\", x, y, (x < y) ? \"true\" : \"false\");  // DEBUGGING\n\t\t// fprintf(stdout, \"(x + dbleMask) < (y + dbleMask) == %.15f < %.15f == %s\\n\", \\\n\t\t// \tx + dbleMask, y + dbleMask, ((x + dbleMask) < (y + dbleMask)) ? \"true\" : \"false\");  // DEBUGGING\n\t\t// fprintf(stdout, \"(x - dbleMask) < (y - dbleMask) == %.15f < %.15f == %s\\n\\t\\t\", \\\n\t\t// \tx - dbleMask, y - dbleMask, ((x - dbleMask) < (y - dbleMask)) ? \"true\" : \"false\");  // DEBUGGING\n\t\tif (xVal < yVal)\n\t\t// if (x < y && (x + dbleMask) < (y + dbleMask) && (x - dbleMask) < (y - dbleMask))\n\t\t{\n\t\t\tretVal = true;\t\n\t\t}\t\t\n\t}\t\n\t\n\t// DONE\n\treturn retVal;\n"]]}
{"hexsha": "505beecabe729c9b19ad0cb1d30f2f1538377e1c", "ext": "c", "lang": "C", "content": "static void _ceu_pre_1 (tceu_app* _ceu_app, tceu_org* __ceu_this) {\n/* NODE: BlockI 800 */\n\n#line 160 \"./arch/sdl.ceu\"\n    ceu_vector_init(&((CEU_SDL*)__ceu_this)->title,0,sizeof(char),\n                (byte*)((CEU_SDL*)__ceu_this)->title_mem);\n/* NODE: Stmts 818 */\n\n#line 160 \"./arch/sdl.ceu\"\n    {/* NODE: Dcl_mode 31 */\n/* NODE: Dcl_var 802 */\n/* NODE: Dcl_var 805 */\n/* NODE: Dcl_var 807 */\n/* NODE: Dcl_var 810 */\n/* NODE: Dcl_mode 38 */\n/* NODE: Dcl_var 813 */\n/* NODE: Dcl_var 816 */\n/* NODE: Dcl_fun 53 */\n\n#line 160 \"./arch/sdl.ceu\"\n    }}", "item_id": 34, "repo": "LucasMW/beam_duel", "file": "build/_ceu_app.c", "last_update_at": "2018-01-21T01:25:48+00:00", "question_id": "505beecabe729c9b19ad0cb1d30f2f1538377e1c_34", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void _ceu_pre_1 (tceu_app* _ceu_app, tceu_org* __ceu_this) {\n/* NODE: BlockI 800 */\n#line 160 \"./arch/sdl.ceu\"\n    ceu_vector_init(&((CEU_SDL*)__ceu_this)->title,0,sizeof(char),\n                (byte*)((CEU_SDL*)__ceu_this)->title_mem);\n/* NODE: Stmts 818 */\n#line 160 \"./arch/sdl.ceu\"\n    {/* NODE: Dcl_mode 31 */\n/* NODE: Dcl_var 802 */\n/* NODE: Dcl_var 805 */\n/* NODE: Dcl_var 807 */\n/* NODE: Dcl_var 810 */\n/* NODE: Dcl_mode 38 */\n/* NODE: Dcl_var 813 */\n/* NODE: Dcl_var 816 */\n/* NODE: Dcl_fun 53 */\n#line 160 \"./arch/sdl.ceu\"\n"]]}
{"hexsha": "3a343eb658ba44692072715f6c9e97703a458355", "ext": "c", "lang": "C", "content": "void\nNC_hashmap_verify(NC_hashmap* hash, NC_dim** dims)\n{\n    unsigned long i;\n    if(hash->count == 0) {\n\tfprintf(stderr,\"<empty>\\n\");\n\tgoto done;\n    }\n    for(i=0;i<hash->size;i++) {\n\thEntry* e = &hash->table[i];\n\tif(e->flags == ACTIVE) {\n           fprintf(stderr,\"[%d] key=%lu data=%ld\",(int)i,e->key,e->data-1);\n\t    if(dims != NULL) {\n\t        fprintf(stderr,\" name=%s\",dims[e->data-1]->name->cp);\n\t    }\t\n\t    fprintf(stderr,\"\\n\");\n\t}\n    }\n\ndone:\n    fflush(stderr);\n}", "item_id": 11, "repo": "khou2020/netcdf-c", "file": "libsrc/nc_hashmap.c", "last_update_at": "2018-02-28T20:59:58+00:00", "question_id": "3a343eb658ba44692072715f6c9e97703a458355_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nNC_hashmap_verify(NC_hashmap* hash, NC_dim** dims)\n{\n    unsigned long i;\n    if(hash->count == 0) {\n\tfprintf(stderr,\"<empty>\\n\");\n\tgoto done;\n    }\n    for(i=0;i<hash->size;i++) {\n\thEntry* e = &hash->table[i];\n\tif(e->flags == ACTIVE) {\n           fprintf(stderr,\"[%d] key=%lu data=%ld\",(int)i,e->key,e->data-1);\n\t    if(dims != NULL) {\n\t        fprintf(stderr,\" name=%s\",dims[e->data-1]->name->cp);\n\t    }\t\n\t    fprintf(stderr,\"\\n\");\n\t}\n    }\ndone:\n    fflush(stderr);\n"]]}
{"hexsha": "92f861d3700ce961f7d437bd91b58ed41318148d", "ext": "c", "lang": "C", "content": "void crc16_final(crc16_ctx *inCtx, unsigned short *outResult )\n{\n    inCtx->crc = update_crc16(inCtx->crc, 0);\n    inCtx->crc = update_crc16(inCtx->crc, 0);\n    *outResult = inCtx->crc & 0xffffu;\n}", "item_id": 8, "repo": "HelloAllen8893/AliOS-Things", "file": "platform/mcu/bk7231u/hal/ota.c", "last_update_at": "2018-11-28T03:19:22+00:00", "question_id": "92f861d3700ce961f7d437bd91b58ed41318148d_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void crc16_final(crc16_ctx *inCtx, unsigned short *outResult )\n{\n    inCtx->crc = update_crc16(inCtx->crc, 0);\n    inCtx->crc = update_crc16(inCtx->crc, 0);\n    *outResult = inCtx->crc & 0xffffu;\n"]]}
{"hexsha": "748e427bc2b13e6a6444ebe2c9f1c3ea93aab6b4", "ext": "c", "lang": "C", "content": "int mip_lpwg_enable_sensing(struct i2c_client *client, bool enable)\n{\n\tu8 wbuf[4];\n\n\twbuf[0] = MIP_R0_LPWG;\n\twbuf[1] = MIP_R1_LPWG_ENABLE_SENSING;\n\twbuf[2] = enable;\n\n\tif (FT8707_I2C_Write(client, wbuf, 3)) {\n\t\tTOUCH_ERR(\"mip_lpwg_enable_sensing failed\\n\");\n\t\treturn TOUCH_FAIL;\n\t}\n\n\treturn 0;\n}", "item_id": 8, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/drivers/input/touchscreen/mediatek/unified_driver_4/FT8707/lgtp_device_ft8707.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "748e427bc2b13e6a6444ebe2c9f1c3ea93aab6b4_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int mip_lpwg_enable_sensing(struct i2c_client *client, bool enable)\n{\n\tu8 wbuf[4];\n\twbuf[0] = MIP_R0_LPWG;\n\twbuf[1] = MIP_R1_LPWG_ENABLE_SENSING;\n\twbuf[2] = enable;\n\tif (FT8707_I2C_Write(client, wbuf, 3)) {\n\t\tTOUCH_ERR(\"mip_lpwg_enable_sensing failed\\n\");\n\t\treturn TOUCH_FAIL;\n\t}\n\treturn 0;\n"]]}
{"hexsha": "c1ba92b1192de5d2ab3937aca1a51e42136a1a6b", "ext": "h", "lang": "C", "content": "auto sieve(unsigned int limit) {\n    std::vector<unsigned int> candidates(limit, 1u, std::vector<unsigned int>::allocator_type());\n    std::vector<unsigned int> out; \n    out.push_back(2);\n    for(auto i = 3u; i < limit; i += 2){\n       if(candidates[i] == 0) { continue; }\n        out.push_back(i);\n        for(auto j = 2*i; j < limit; j += i) {\n            candidates[j] = 0u;\n        }\n    }\n\n    return out;\n}", "item_id": 0, "repo": "pviafore/modern-cpp-challenge", "file": "prime.h", "last_update_at": "2018-07-06T18:10:32+00:00", "question_id": "c1ba92b1192de5d2ab3937aca1a51e42136a1a6b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["auto sieve(unsigned int limit) {\n    std::vector<unsigned int> candidates(limit, 1u, std::vector<unsigned int>::allocator_type());\n    std::vector<unsigned int> out; \n    out.push_back(2);\n    for(auto i = 3u; i < limit; i += 2){\n       if(candidates[i] == 0) { continue; }\n        out.push_back(i);\n        for(auto j = 2*i; j < limit; j += i) {\n            candidates[j] = 0u;\n        }\n    }\n    return out;\n"]]}
{"hexsha": "f1efb943b6fec3cfeb67856b03ec15dc11fbd4d2", "ext": "h", "lang": "C", "content": "class CSampleDlg : public CDialog\n{\n//\npublic:\n\tCSampleDlg(CWnd* pParent = NULL);\t// default constractor\n\n\t//{{AFX_DATA(CSampleDlg)\n\tenum { IDD = IDD_SAMPLE_DIALOG };\n\n\t//}}AFX_DATA\n\n\t//{{AFX_VIRTUAL(CSampleDlg)\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);\t// support DDX/DDV\n\t//}}AFX_VIRTUAL\n\nprotected:\n\tHICON m_hIcon;\n\n\t//{{AFX_MSG(CSampleDlg)\n\tvirtual BOOL OnInitDialog();\n\tafx_msg void OnPaint();\n\tafx_msg HCURSOR OnQueryDragIcon();\n\tafx_msg void OnPrint();\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\n}", "item_id": 0, "repo": "huanlin/easy-braille-edit", "file": "Doc/Braille Printers/Gemini/Samples/Sample2/SampleDlg.h", "last_update_at": "2018-05-09T07:44:31+00:00", "question_id": "f1efb943b6fec3cfeb67856b03ec15dc11fbd4d2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class CSampleDlg : public CDialog\n{\n//\npublic:\n\tCSampleDlg(CWnd* pParent = NULL);\t// default constractor\n\t//{{AFX_DATA(CSampleDlg)\n\tenum { IDD = IDD_SAMPLE_DIALOG };\n\t//}}AFX_DATA\n\t//{{AFX_VIRTUAL(CSampleDlg)\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);\t// support DDX/DDV\n\t//}}AFX_VIRTUAL\nprotected:\n\tHICON m_hIcon;\n\t//{{AFX_MSG(CSampleDlg)\n\tvirtual BOOL OnInitDialog();\n\tafx_msg void OnPaint();\n\tafx_msg HCURSOR OnQueryDragIcon();\n\tafx_msg void OnPrint();\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\n"]]}
{"hexsha": "53d650966beca97aaf0ebe62b116b10a5ea32871", "ext": "c", "lang": "C", "content": "void\nFtsGetQDMirrorInfo(char **hostname, uint16 *port)\n{\n\tAssert(hostname != NULL);\n\tAssert(port != NULL);\n\n\tif (ftsQDMirrorInfo->name[0] == 0 || ftsQDMirrorInfo->port == 0)\n\t{\n\t\t*hostname = NULL;\n\t\t*port = 0;\n\t\treturn;\n\t}\n\n\t*hostname = ftsQDMirrorInfo->name;\n\t*port = ftsQDMirrorInfo->port;\n\treturn;\n}", "item_id": 27, "repo": "YangHao666666/hawq", "file": "src/backend/cdb/cdbfts.c", "last_update_at": "2018-08-30T01:45:36+00:00", "question_id": "53d650966beca97aaf0ebe62b116b10a5ea32871_27", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nFtsGetQDMirrorInfo(char **hostname, uint16 *port)\n{\n\tAssert(hostname != NULL);\n\tAssert(port != NULL);\n\tif (ftsQDMirrorInfo->name[0] == 0 || ftsQDMirrorInfo->port == 0)\n\t{\n\t\t*hostname = NULL;\n\t\t*port = 0;\n\t\treturn;\n\t}\n\t*hostname = ftsQDMirrorInfo->name;\n\t*port = ftsQDMirrorInfo->port;\n\treturn;\n"]]}
{"hexsha": "b85ba71a6f77e974d82ccdd635109f36d0ddaac8", "ext": "h", "lang": "C", "content": "static virNetworkPtr\nremoteNetworkCreateXML(virConnectPtr conn, const char *xml)\n{\n    virNetworkPtr rv = NULL;\n    struct private_data *priv = conn->privateData;\n    remote_network_create_xml_args args;\n    remote_network_create_xml_ret ret;\n\n    remoteDriverLock(priv);\n\n    args.xml = (char *)xml;\n\n    memset(&ret, 0, sizeof(ret));\n\n    if (call(conn, priv, 0, REMOTE_PROC_NETWORK_CREATE_XML,\n             (xdrproc_t)xdr_remote_network_create_xml_args, (char *)&args,\n             (xdrproc_t)xdr_remote_network_create_xml_ret, (char *)&ret) == -1) {\n        goto done;\n    }\n\n    rv = get_nonnull_network(conn, ret.net);\n    xdr_free((xdrproc_t)xdr_remote_network_create_xml_ret, (char *)&ret);\n\ndone:\n    remoteDriverUnlock(priv);\n    return rv;\n}", "item_id": 154, "repo": "SIIS-cloud/pileus", "file": "libvirt/pileus-libvirt-1.2.12/src/remote/remote_client_bodies.h", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "b85ba71a6f77e974d82ccdd635109f36d0ddaac8_154", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static virNetworkPtr\nremoteNetworkCreateXML(virConnectPtr conn, const char *xml)\n{\n    virNetworkPtr rv = NULL;\n    struct private_data *priv = conn->privateData;\n    remote_network_create_xml_args args;\n    remote_network_create_xml_ret ret;\n    remoteDriverLock(priv);\n    args.xml = (char *)xml;\n    memset(&ret, 0, sizeof(ret));\n    if (call(conn, priv, 0, REMOTE_PROC_NETWORK_CREATE_XML,\n             (xdrproc_t)xdr_remote_network_create_xml_args, (char *)&args,\n             (xdrproc_t)xdr_remote_network_create_xml_ret, (char *)&ret) == -1) {\n        goto done;\n    }\n    rv = get_nonnull_network(conn, ret.net);\n    xdr_free((xdrproc_t)xdr_remote_network_create_xml_ret, (char *)&ret);\ndone:\n    remoteDriverUnlock(priv);\n    return rv;\n"]]}
{"hexsha": "139f976a5c28f8dd2830fd45366ce3fb9c794544", "ext": "h", "lang": "C", "content": "interface ICShaderCache : NSObject {\n@private\n    NSMutableDictionary *_programs;\n    ICShaderFactory *_shaderFactory;\n}", "item_id": 0, "repo": "starbugs/icedcoffee", "file": "icedcoffee/ICShaderCache.h", "last_update_at": "2018-11-09T11:13:12+00:00", "question_id": "139f976a5c28f8dd2830fd45366ce3fb9c794544_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface ICShaderCache : NSObject {\n@private\n    NSMutableDictionary *_programs;\n    ICShaderFactory *_shaderFactory;\n"]]}
{"hexsha": "0ea925238d379dc010b281b4b60e34536a1eb9c5", "ext": "h", "lang": "C", "content": "interface _HDDataFaker : NSObject <_HDDemoDataModuleDelegate> {\n    long long  _activityType;\n    NSArray * _modules;\n    id /* block */  _objectHandler;\n    NSOperationQueue * _operationQueue;\n    HKQuantity * _speed;\n}", "item_id": 0, "repo": "shaojiankui/iOS10-Runtime-Headers", "file": "PrivateFrameworks/HealthDaemon.framework/_HDDataFaker.h", "last_update_at": "2018-10-08T04:12:25+00:00", "question_id": "0ea925238d379dc010b281b4b60e34536a1eb9c5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface _HDDataFaker : NSObject <_HDDemoDataModuleDelegate> {\n    long long  _activityType;\n    NSArray * _modules;\n    id /* block */  _objectHandler;\n    NSOperationQueue * _operationQueue;\n    HKQuantity * _speed;\n"]]}
{"hexsha": "56b89f9ca944a79b3e7fa9bc393c471b09a0134f", "ext": "c", "lang": "C", "content": "static int __Pyx_modinit_function_export_code(void) {\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__Pyx_modinit_function_export_code\", 0);\n  /*--- Function export code ---*/\n  __Pyx_RefNannyFinishContext();\n  return 0;\n}", "item_id": 74, "repo": "jm-begon/globally-induced-forest", "file": "gif/tree/_criterion.c", "last_update_at": "2018-10-13T13:14:05+00:00", "question_id": "56b89f9ca944a79b3e7fa9bc393c471b09a0134f_74", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int __Pyx_modinit_function_export_code(void) {\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__Pyx_modinit_function_export_code\", 0);\n  /*--- Function export code ---*/\n  __Pyx_RefNannyFinishContext();\n  return 0;\n"]]}
{"hexsha": "67c2cee6d2d9eedb91b9cb60846563cef25bc8f4", "ext": "c", "lang": "C", "content": "void LayerTraverseForArray(BiTree T) {\n    if (T == NULL) return;\n    BiTree trees[100];\n    int in = 0;\n    int out = 0;\n    trees[in++] = T; // \u5148\u4fdd\u5b58\u4e8c\u53c9\u6811\u6839\u8282\u70b9\n    while (in > out) {\n        if (trees[out] != NULL) {\n            printf(\"%d ->\", trees[out] -> data);\n            if (trees[out] -> lChildNode) {\n                trees[in++] = trees[out] -> lChildNode;\n            }\n            if (trees[out] -> rChildNode) {\n                trees[in++] = trees[out] -> rChildNode;\n            }\n        }\n        out++;\n    }\n}", "item_id": 4, "repo": "yongyuandouneng/YNAlgorithm", "file": "YNAlgorithm/DataStructure/Tree.c", "last_update_at": "2018-12-24T16:34:25+00:00", "question_id": "67c2cee6d2d9eedb91b9cb60846563cef25bc8f4_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void LayerTraverseForArray(BiTree T) {\n    if (T == NULL) return;\n    BiTree trees[100];\n    int in = 0;\n    int out = 0;\n    trees[in++] = T; // \u5148\u4fdd\u5b58\u4e8c\u53c9\u6811\u6839\u8282\u70b9\n    while (in > out) {\n        if (trees[out] != NULL) {\n            printf(\"%d ->\", trees[out] -> data);\n            if (trees[out] -> lChildNode) {\n                trees[in++] = trees[out] -> lChildNode;\n            }\n            if (trees[out] -> rChildNode) {\n                trees[in++] = trees[out] -> rChildNode;\n            }\n        }\n        out++;\n    }\n"]]}
{"hexsha": "312b1f8c47cb4836dd8f195a9d9e1aa98bf0acef", "ext": "c", "lang": "C", "content": "void\nnls_decrypt(nls_ctx *c, UCHAR *buf, int nbytes)\n{\n    WORD\tt = 0, t3 = 0;\n    int\t\ti;\n\n    /* handle any previously buffered bytes */\n    if (c->nbuf != 0) {\n\twhile (c->nbuf != 0 && nbytes != 0) {\n\t    *buf ^= (c->sbuf >> (32 - c->nbuf)) & 0xFF;\n\t    c->mbuf ^= *buf << (32 - c->nbuf);\n\t    ++buf;\n\t    c->nbuf -= 8;\n\t    --nbytes;\n\t}\n\tif (c->nbuf != 0) /* not a whole word yet */\n\t    return;\n\t/* LFSR already cycled */\n\tmacfunc(c, c->mbuf);\n    }\n\n    /* now do lots at a time, if there's enough */\n    while (4*N <= nbytes)\n    {\n#if NLS_LONG_OUTPUT\n\tif (c->CtrModF16 < (F16-18)) {\n#endif /*NLS_LONG_OUTPUT*/\n\t    DROUND( 0,A,B,C,D,E,F,G,H);\n\t    DROUND( 1,H,A,B,C,D,E,F,G);\n\t    DROUND( 2,G,H,A,B,C,D,E,F);\n\t    DROUND( 3,F,G,H,A,B,C,D,E);\n\t    DROUND( 4,E,F,G,H,A,B,C,D);\n\t    DROUND( 5,D,E,F,G,H,A,B,C);\n\t    DROUND( 6,C,D,E,F,G,H,A,B);\n\t    DROUND( 7,B,C,D,E,F,G,H,A);\n\t    DROUND( 8,A,B,C,D,E,F,G,H);\n\t    DROUND( 9,H,A,B,C,D,E,F,G);\n\t    DROUND(10,G,H,A,B,C,D,E,F);\n\t    DROUND(11,F,G,H,A,B,C,D,E);\n\t    DROUND(12,E,F,G,H,A,B,C,D);\n\t    DROUND(13,D,E,F,G,H,A,B,C);\n\t    DROUND(14,C,D,E,F,G,H,A,B);\n\t    DROUND(15,B,C,D,E,F,G,H,A);\n\t    DROUND(16,A,B,C,D,E,F,G,H);\n\t    buf += 4*N;\n\t    nbytes -= 4*N;\n\t    /* fix alignment of MAC buffer */\n\t    t = c->M[7];\n\t    for (i = NMAC-1; i > 0; --i)\n\t\tc->M[i] = c->M[i-1];\n\t    c->M[0] = t;\n\t    /* fix alignment of CRC buffer */\n\t    t = c->CRC[0];\n\t    for (i = 1; i < NMAC; ++i)\n\t\tc->CRC[i-1] = c->CRC[i];\n\t    c->CRC[NMAC-1] = t;\n#if NLS_LONG_OUTPUT\n\t    c->CtrModF16 += 17;\n\t}\n\telse {\n\t    do {\n\t\tcycle(c);\n\t\tt = nltap(c);\n\t\tt3 = BYTE2WORD(buf);\n\t\tt ^= t3;\n\t\tmacfunc(c, t);\n\t\tWORD2BYTE(t, buf);\n\t\tbuf += 4;\n\t\tnbytes -= 4;\n\t    } while (F16-18 < c->CtrModF16);\n\t}\n#endif /*NLS_LONG_OUTPUT*/\n    }\n\n    /* do small or odd size buffers the slow way */\n    while (4 <= nbytes) {\n\tcycle(c);\n\tt = nltap(c);\n\tt3 = BYTE2WORD(buf);\n\tt ^= t3;\n\tmacfunc(c, t);\n\tWORD2BYTE(t, buf);\n\tnbytes -= 4;\n\tbuf += 4;\n    }\n\n    /* handle any trailing bytes */\n    if (nbytes != 0) {\n\tcycle(c);\n\tc->sbuf = nltap(c);\n\tc->mbuf = 0;\n\tc->nbuf = 32;\n\twhile (c->nbuf != 0 && nbytes != 0) {\n\t    *buf ^= (c->sbuf >> (32 - c->nbuf)) & 0xFF;\n\t    c->mbuf ^= *buf << (32 - c->nbuf);\n\t    ++buf;\n\t    c->nbuf -= 8;\n\t    --nbytes;\n\t}\n    }\n}", "item_id": 12, "repo": "iadgov/simon-speck-supercop", "file": "crypto_stream/nlsv2/e/v2/sync/2/e/nlsfast.c", "last_update_at": "2018-03-09T14:52:25+00:00", "question_id": "312b1f8c47cb4836dd8f195a9d9e1aa98bf0acef_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nnls_decrypt(nls_ctx *c, UCHAR *buf, int nbytes)\n{\n    WORD\tt = 0, t3 = 0;\n    int\t\ti;\n    /* handle any previously buffered bytes */\n    if (c->nbuf != 0) {\n\twhile (c->nbuf != 0 && nbytes != 0) {\n\t    *buf ^= (c->sbuf >> (32 - c->nbuf)) & 0xFF;\n\t    c->mbuf ^= *buf << (32 - c->nbuf);\n\t    ++buf;\n\t    c->nbuf -= 8;\n\t    --nbytes;\n\t}\n\tif (c->nbuf != 0) /* not a whole word yet */\n\t    return;\n\t/* LFSR already cycled */\n\tmacfunc(c, c->mbuf);\n    }\n    /* now do lots at a time, if there's enough */\n    while (4*N <= nbytes)\n    {\n#if NLS_LONG_OUTPUT\n\tif (c->CtrModF16 < (F16-18)) {\n#endif /*NLS_LONG_OUTPUT*/\n\t    DROUND( 0,A,B,C,D,E,F,G,H);\n\t    DROUND( 1,H,A,B,C,D,E,F,G);\n\t    DROUND( 2,G,H,A,B,C,D,E,F);\n\t    DROUND( 3,F,G,H,A,B,C,D,E);\n\t    DROUND( 4,E,F,G,H,A,B,C,D);\n\t    DROUND( 5,D,E,F,G,H,A,B,C);\n\t    DROUND( 6,C,D,E,F,G,H,A,B);\n\t    DROUND( 7,B,C,D,E,F,G,H,A);\n\t    DROUND( 8,A,B,C,D,E,F,G,H);\n\t    DROUND( 9,H,A,B,C,D,E,F,G);\n\t    DROUND(10,G,H,A,B,C,D,E,F);\n\t    DROUND(11,F,G,H,A,B,C,D,E);\n\t    DROUND(12,E,F,G,H,A,B,C,D);\n\t    DROUND(13,D,E,F,G,H,A,B,C);\n\t    DROUND(14,C,D,E,F,G,H,A,B);\n\t    DROUND(15,B,C,D,E,F,G,H,A);\n\t    DROUND(16,A,B,C,D,E,F,G,H);\n\t    buf += 4*N;\n\t    nbytes -= 4*N;\n\t    /* fix alignment of MAC buffer */\n\t    t = c->M[7];\n\t    for (i = NMAC-1; i > 0; --i)\n\t\tc->M[i] = c->M[i-1];\n\t    c->M[0] = t;\n\t    /* fix alignment of CRC buffer */\n\t    t = c->CRC[0];\n\t    for (i = 1; i < NMAC; ++i)\n\t\tc->CRC[i-1] = c->CRC[i];\n\t    c->CRC[NMAC-1] = t;\n#if NLS_LONG_OUTPUT\n\t    c->CtrModF16 += 17;\n\t}\n\telse {\n\t    do {\n\t\tcycle(c);\n\t\tt = nltap(c);\n\t\tt3 = BYTE2WORD(buf);\n\t\tt ^= t3;\n\t\tmacfunc(c, t);\n\t\tWORD2BYTE(t, buf);\n\t\tbuf += 4;\n\t\tnbytes -= 4;\n\t    } while (F16-18 < c->CtrModF16);\n\t}\n#endif /*NLS_LONG_OUTPUT*/\n    }\n    /* do small or odd size buffers the slow way */\n    while (4 <= nbytes) {\n\tcycle(c);\n\tt = nltap(c);\n\tt3 = BYTE2WORD(buf);\n\tt ^= t3;\n\tmacfunc(c, t);\n\tWORD2BYTE(t, buf);\n\tnbytes -= 4;\n\tbuf += 4;\n    }\n    /* handle any trailing bytes */\n    if (nbytes != 0) {\n\tcycle(c);\n\tc->sbuf = nltap(c);\n\tc->mbuf = 0;\n\tc->nbuf = 32;\n\twhile (c->nbuf != 0 && nbytes != 0) {\n\t    *buf ^= (c->sbuf >> (32 - c->nbuf)) & 0xFF;\n\t    c->mbuf ^= *buf << (32 - c->nbuf);\n\t    ++buf;\n\t    c->nbuf -= 8;\n\t    --nbytes;\n\t}\n    }\n"]]}
{"hexsha": "99adea3b455e4d978d45150b9835dd540e41a000", "ext": "c", "lang": "C", "content": "static int set_outfile(char *outfile, char addfile) {\n    int flags = O_WRONLY;\n    if (addfile == TRUE) {\n        flags |= O_APPEND | O_CREAT;\n    } else {\n        flags |= O_CREAT | O_TRUNC;\n    }\n\n    int output;\n    output = open(outfile, flags, (mode_t) 0644);\n    CHECK_ON_ERROR(output, BAD_RESULT, \"Couldn't open output file\")\n\n    return use_dup2(output, STDOUT_FILENO, \"Couldn't redirect output\");\n}", "item_id": 14, "repo": "Dimonchik0036/shell", "file": "execute.c", "last_update_at": "2018-02-27T09:58:42+00:00", "question_id": "99adea3b455e4d978d45150b9835dd540e41a000_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int set_outfile(char *outfile, char addfile) {\n    int flags = O_WRONLY;\n    if (addfile == TRUE) {\n        flags |= O_APPEND | O_CREAT;\n    } else {\n        flags |= O_CREAT | O_TRUNC;\n    }\n    int output;\n    output = open(outfile, flags, (mode_t) 0644);\n    CHECK_ON_ERROR(output, BAD_RESULT, \"Couldn't open output file\")\n    return use_dup2(output, STDOUT_FILENO, \"Couldn't redirect output\");\n"]]}
{"hexsha": "c825ffcc91a581d35f2e33ba86676e2933016dca", "ext": "c", "lang": "C", "content": "void* p_OpenScreen(int width, int height, bool_t fullscreen, int samples, bool_t vsync, bool_t resizable) {\n    GLFWwindow* win;\n\n    /* set flags */\n    glfwWindowHint(GLFW_SAMPLES, samples);\n    glfwWindowHint(GLFW_RESIZABLE, resizable);\n#ifdef USE_RETINA\n    glfwWindowHint(GLFW_COCOA_RETINA_FRAMEBUFFER, GLFW_TRUE);\n#else\n    glfwWindowHint(GLFW_COCOA_RETINA_FRAMEBUFFER, GLFW_FALSE);\n#endif\n\n    /* create window */\n    win = glfwCreateWindow(width, height, \"\", fullscreen ? glfwGetPrimaryMonitor() : NULL, NULL);\n    glfwMakeContextCurrent(win);\n\n    /* set vsync */\n    glfwSwapInterval(vsync ? 1 : 0);\n\n    return win;\n}", "item_id": 3, "repo": "JaviCervera/spark", "file": "src/platform_glfw.c", "last_update_at": "2018-05-28T09:14:02+00:00", "question_id": "c825ffcc91a581d35f2e33ba86676e2933016dca_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void* p_OpenScreen(int width, int height, bool_t fullscreen, int samples, bool_t vsync, bool_t resizable) {\n    GLFWwindow* win;\n    /* set flags */\n    glfwWindowHint(GLFW_SAMPLES, samples);\n    glfwWindowHint(GLFW_RESIZABLE, resizable);\n#ifdef USE_RETINA\n    glfwWindowHint(GLFW_COCOA_RETINA_FRAMEBUFFER, GLFW_TRUE);\n#else\n    glfwWindowHint(GLFW_COCOA_RETINA_FRAMEBUFFER, GLFW_FALSE);\n#endif\n    /* create window */\n    win = glfwCreateWindow(width, height, \"\", fullscreen ? glfwGetPrimaryMonitor() : NULL, NULL);\n    glfwMakeContextCurrent(win);\n    /* set vsync */\n    glfwSwapInterval(vsync ? 1 : 0);\n    return win;\n"]]}
{"hexsha": "d6469d4f8aba819a52bef6ad77c5ef428a5d518a", "ext": "h", "lang": "C", "content": "class DepthCalibrator\n{\npublic:\n  DepthCalibrator(ros::NodeHandle& nh);\n\n  /**\n     * @brief If pixel depth calibration has been performed, and points clouds have been stored, performs depth\n   * correction calculations\n     *\n     * Calculates the depth correction coefficients d1 and d2 using the point clouds previously stored.\n     * Depth correction for each pixel is of the form D*e^(d1 + d2 * z), where D is the pixel depth error found from the\n     * calibrateCameraPixelDepth callback, z is the depth of the given pixel, and d1 and d2 are the depth coefficients\n   * to be solved for.\n     *\n     *\n     * @param[in] request Empty\n     * @param[out] response Empty\n     * @return True if the call succeeded\n     */\n  bool calibrateCameraDepth(std_srvs::Empty::Request& request, std_srvs::Empty::Response& response);\n\n  /**\n     * @brief Finds the depth error for each pixel in the point cloud\n     *\n     * Finds the calibration target and compares each pixel depth value to the expected depth value based upon the\n     * pose of the target found.  Stores the resulting depth compensation values as a point cloud for use in the\n     * depth correction nodelet.\n     *\n     * @param[in] request Empty\n     * @param[out] response Empty\n     * @return True if the call succeeded\n     */\n  bool calibrateCameraPixelDepth(std_srvs::Empty::Request& request, std_srvs::Empty::Response& response);\n\n  /**\n     * @brief Sets the flag to store the next point cloud retrieved for later use when performing depth correction\n   * calculations\n     *\n     * @param[in] request Empty\n     * @param[out] response Empty\n     * @return True if the call succeeded\n     */\n  bool setStoreCloud(std_srvs::Empty::Request& request, std_srvs::Empty::Response& response);\n\n  /**\n     * @brief Updates the last_cloud_ data, and if the store_point_cloud_ boolean is set, stores the latest cloud,\n   * image, and target pose\n     *\n     * @param[in] cloud The latest point cloud received\n     * @param[in] image The latest RGB image received\n     * @return True if the call succeeded\n     */\n  void updateInputData(const sensor_msgs::PointCloud2ConstPtr& cloud, const sensor_msgs::ImageConstPtr& image);\n\nprivate:\n  const static unsigned int VERSION_NUMBER_; /**< @brief Version number for the calibration package  */\n\n  ros::NodeHandle nh_; /**< @brief ROS node handle */\n  bool save_data_;     /**< @brief Flag to determine whether to save calibration results or not */\n\n  typedef message_filters::sync_policies::ApproximateTime< sensor_msgs::PointCloud2, sensor_msgs::Image > PolicyType;\n  typedef message_filters::Subscriber< sensor_msgs::PointCloud2 > PointCloudSubscriberType;\n  typedef message_filters::Subscriber< sensor_msgs::Image > ImageSubscriberType;\n  typedef message_filters::Synchronizer< PolicyType > SynchronizerType;\n  boost::shared_ptr< PointCloudSubscriberType > point_cloud_sub_; /**< @brief Point cloud subscriber */\n  boost::shared_ptr< ImageSubscriberType > image_sub_;            /**< @brief RGB image subscriber */\n  boost::shared_ptr< SynchronizerType > synchronizer_; /**< @brief Syncronizer for point cloud and image data */\n\n  ros::ServiceClient get_target_pose_;       /**< @brief Service to call target locator to get target pose */\n  ros::ServiceServer calibrate_depth_;       /**< @brief Service to compute depth coefficients d1 and d2 */\n  ros::ServiceServer calibrate_pixel_depth_; /**< @brief Service to calculate pixel depth error */\n  ros::ServiceServer set_store_cloud_;       /**< @brief Service to set and store next point cloud available */\n\n  int num_views_;        /**< @brief Number of times to find the calibration target to get average pose */\n  int num_attempts_;     /**< @brief Number of attempts allowed for finding calibration target before failing */\n  int num_point_clouds_; /**< @brief Number of point clouds to save and check when performing pixel depth error\n                            calculations */\n  std::string filename_; /**< @brief Name of the calibration files to save */\n  std::string filepath_; /**< @brief Pathway to the location to save calibration files */\n  geometry_msgs::Pose\n      target_initial_pose_; /**< @brief The initial pose guess of the calibration target for the target finder service\n                               */\n\n  double std_dev_error_;          /**< @brief The standard deviation error allowed for finding the target pose */\n  double depth_error_threshold_;  /**< @brief The depth error allowed for calculating the pixel depth error map */\n  boost::mutex data_lock_;        /**< @brief Lock for data subscription */\n  sensor_msgs::Image last_image_; /**< @brief The last color image received */\n  pcl::PointCloud< pcl::PointXYZ > last_cloud_; /**< @brief The last point cloud received */\n  pcl::PointCloud< pcl::PointXYZ >\n      correction_cloud_; /**< @brief The point cloud containing the depth correction values */\n  std::vector< pcl::PointCloud< pcl::PointXYZ >, Eigen::aligned_allocator< pcl::PointCloud< pcl::PointXYZ > > >\n      saved_clouds_;\n  /**< @brief The vector of stored point clouds used to compute the distance coefficients */\n  std::vector< std::vector< double > >\n      plane_equations_;                 /**< @brief A vector of plane equations for each point cloud in saved_clouds_ */\n  std::vector< cv::Mat > saved_images_; /**< @brief A vector of rgb images for each point cloud in saved_clouds_ */\n  std::vector< geometry_msgs::Pose > saved_target_poses_; /**< @brief A vector of target poses for each point cloud in\n                                                             saved_clouds_ */\n\n  /**\n     * @brief Stores the calibration results in a YAML formated file\n     *\n     * @param[in] yaml_file The name and pathway of the file to be saved\n     * @param[in] dp The depth correction coefficients to be saved\n     */\n  void storeCalibration(const std::string& yaml_file, const double dp[2]);\n\n  /**\n     * @brief Populates and calls the target finder service\n     *\n     * @param[in] final_cost The desired final cost for the service call\n     * @param[out] target_pose The pose of the target returned from the service call\n     * @return True if the service call succeeds\n     */\n  bool findTarget(const double& final_cost, geometry_msgs::Pose& target_pose);\n\n  /**\n     * @brief Calls the findTarget function multiple times (num_views) and returns the average plane equation and the\n   * last target pose found\n     *\n     * @param[out] plane_eq The average plane equation results found from averaging the results from all of the target\n   * poses found\n     * @param[out] target_pose The pose of the target found from the last service call\n     * @return True if the target was successfully found before the number of failures (num_attempts) was reached\n     */\n  bool findAveragePlane(std::vector< double >& plane_eq, geometry_msgs::Pose& target_pose);\n\n  bool findAveragePointCloud(pcl::PointCloud< pcl::PointXYZ >& final_cloud);\n}", "item_id": 1, "repo": "smith-doug/industrial_calibration", "file": "rgbd_depth_correction/include/depth_calibration/depth_calibration.h", "last_update_at": "2018-07-26T02:03:58+00:00", "question_id": "d6469d4f8aba819a52bef6ad77c5ef428a5d518a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class DepthCalibrator\n{\npublic:\n  DepthCalibrator(ros::NodeHandle& nh);\n  /**\n     * @brief If pixel depth calibration has been performed, and points clouds have been stored, performs depth\n   * correction calculations\n     *\n     * Calculates the depth correction coefficients d1 and d2 using the point clouds previously stored.\n     * Depth correction for each pixel is of the form D*e^(d1 + d2 * z), where D is the pixel depth error found from the\n     * calibrateCameraPixelDepth callback, z is the depth of the given pixel, and d1 and d2 are the depth coefficients\n   * to be solved for.\n     *\n     *\n     * @param[in] request Empty\n     * @param[out] response Empty\n     * @return True if the call succeeded\n     */\n  bool calibrateCameraDepth(std_srvs::Empty::Request& request, std_srvs::Empty::Response& response);\n  /**\n     * @brief Finds the depth error for each pixel in the point cloud\n     *\n     * Finds the calibration target and compares each pixel depth value to the expected depth value based upon the\n     * pose of the target found.  Stores the resulting depth compensation values as a point cloud for use in the\n     * depth correction nodelet.\n     *\n     * @param[in] request Empty\n     * @param[out] response Empty\n     * @return True if the call succeeded\n     */\n  bool calibrateCameraPixelDepth(std_srvs::Empty::Request& request, std_srvs::Empty::Response& response);\n  /**\n     * @brief Sets the flag to store the next point cloud retrieved for later use when performing depth correction\n   * calculations\n     *\n     * @param[in] request Empty\n     * @param[out] response Empty\n     * @return True if the call succeeded\n     */\n  bool setStoreCloud(std_srvs::Empty::Request& request, std_srvs::Empty::Response& response);\n  /**\n     * @brief Updates the last_cloud_ data, and if the store_point_cloud_ boolean is set, stores the latest cloud,\n   * image, and target pose\n     *\n     * @param[in] cloud The latest point cloud received\n     * @param[in] image The latest RGB image received\n     * @return True if the call succeeded\n     */\n  void updateInputData(const sensor_msgs::PointCloud2ConstPtr& cloud, const sensor_msgs::ImageConstPtr& image);\nprivate:\n  const static unsigned int VERSION_NUMBER_; /**< @brief Version number for the calibration package  */\n  ros::NodeHandle nh_; /**< @brief ROS node handle */\n  bool save_data_;     /**< @brief Flag to determine whether to save calibration results or not */\n  typedef message_filters::sync_policies::ApproximateTime< sensor_msgs::PointCloud2, sensor_msgs::Image > PolicyType;\n  typedef message_filters::Subscriber< sensor_msgs::PointCloud2 > PointCloudSubscriberType;\n  typedef message_filters::Subscriber< sensor_msgs::Image > ImageSubscriberType;\n  typedef message_filters::Synchronizer< PolicyType > SynchronizerType;\n  boost::shared_ptr< PointCloudSubscriberType > point_cloud_sub_; /**< @brief Point cloud subscriber */\n  boost::shared_ptr< ImageSubscriberType > image_sub_;            /**< @brief RGB image subscriber */\n  boost::shared_ptr< SynchronizerType > synchronizer_; /**< @brief Syncronizer for point cloud and image data */\n  ros::ServiceClient get_target_pose_;       /**< @brief Service to call target locator to get target pose */\n  ros::ServiceServer calibrate_depth_;       /**< @brief Service to compute depth coefficients d1 and d2 */\n  ros::ServiceServer calibrate_pixel_depth_; /**< @brief Service to calculate pixel depth error */\n  ros::ServiceServer set_store_cloud_;       /**< @brief Service to set and store next point cloud available */\n  int num_views_;        /**< @brief Number of times to find the calibration target to get average pose */\n  int num_attempts_;     /**< @brief Number of attempts allowed for finding calibration target before failing */\n  int num_point_clouds_; /**< @brief Number of point clouds to save and check when performing pixel depth error\n                            calculations */\n  std::string filename_; /**< @brief Name of the calibration files to save */\n  std::string filepath_; /**< @brief Pathway to the location to save calibration files */\n  geometry_msgs::Pose\n      target_initial_pose_; /**< @brief The initial pose guess of the calibration target for the target finder service\n                               */\n  double std_dev_error_;          /**< @brief The standard deviation error allowed for finding the target pose */\n  double depth_error_threshold_;  /**< @brief The depth error allowed for calculating the pixel depth error map */\n  boost::mutex data_lock_;        /**< @brief Lock for data subscription */\n  sensor_msgs::Image last_image_; /**< @brief The last color image received */\n  pcl::PointCloud< pcl::PointXYZ > last_cloud_; /**< @brief The last point cloud received */\n  pcl::PointCloud< pcl::PointXYZ >\n      correction_cloud_; /**< @brief The point cloud containing the depth correction values */\n  std::vector< pcl::PointCloud< pcl::PointXYZ >, Eigen::aligned_allocator< pcl::PointCloud< pcl::PointXYZ > > >\n      saved_clouds_;\n  /**< @brief The vector of stored point clouds used to compute the distance coefficients */\n  std::vector< std::vector< double > >\n      plane_equations_;                 /**< @brief A vector of plane equations for each point cloud in saved_clouds_ */\n  std::vector< cv::Mat > saved_images_; /**< @brief A vector of rgb images for each point cloud in saved_clouds_ */\n  std::vector< geometry_msgs::Pose > saved_target_poses_; /**< @brief A vector of target poses for each point cloud in\n                                                             saved_clouds_ */\n  /**\n     * @brief Stores the calibration results in a YAML formated file\n     *\n     * @param[in] yaml_file The name and pathway of the file to be saved\n     * @param[in] dp The depth correction coefficients to be saved\n     */\n  void storeCalibration(const std::string& yaml_file, const double dp[2]);\n  /**\n     * @brief Populates and calls the target finder service\n     *\n     * @param[in] final_cost The desired final cost for the service call\n     * @param[out] target_pose The pose of the target returned from the service call\n     * @return True if the service call succeeds\n     */\n  bool findTarget(const double& final_cost, geometry_msgs::Pose& target_pose);\n  /**\n     * @brief Calls the findTarget function multiple times (num_views) and returns the average plane equation and the\n   * last target pose found\n     *\n     * @param[out] plane_eq The average plane equation results found from averaging the results from all of the target\n   * poses found\n     * @param[out] target_pose The pose of the target found from the last service call\n     * @return True if the target was successfully found before the number of failures (num_attempts) was reached\n     */\n  bool findAveragePlane(std::vector< double >& plane_eq, geometry_msgs::Pose& target_pose);\n  bool findAveragePointCloud(pcl::PointCloud< pcl::PointXYZ >& final_cloud);\n"]]}
{"hexsha": "9c7ca375ff660a322422d65fb1ae12349978085a", "ext": "c", "lang": "C", "content": "static void\nlinevector_add (vec, text, len, vers, pos)\n    struct linevector *vec;\n    char *text;\n    size_t len;\n    RCSVers *vers;\n    unsigned int pos;\n{\n    char *textend;\n    unsigned int i;\n    unsigned int nnew;\n    char *p;\n    struct line *lines;\n\n    if (len == 0)\n\treturn;\n\n    textend = text + len;\n\n    /* Count the number of lines we will need to add.  */\n    nnew = 1;\n    for (p = text; p < textend; ++p)\n\tif (*p == '\\n' && p + 1 < textend)\n\t    ++nnew;\n    /* Allocate the struct line's.  */\n    lines = block_alloc (nnew * sizeof (struct line));\n\n    /* Expand VEC->VECTOR if needed.  */\n    if (vec->nlines + nnew >= vec->lines_alloced)\n    {\n\tif (vec->lines_alloced == 0)\n\t    vec->lines_alloced = 10;\n\twhile (vec->nlines + nnew >= vec->lines_alloced)\n\t    vec->lines_alloced *= 2;\n\tvec->vector = xrealloc (vec->vector,\n\t\t\t\tvec->lines_alloced * sizeof (*vec->vector));\n    }\n\n    /* Make room for the new lines in VEC->VECTOR.  */\n    for (i = vec->nlines + nnew - 1; i >= pos + nnew; --i)\n\tvec->vector[i] = vec->vector[i - nnew];\n\n    if (pos > vec->nlines)\n\terror (1, 0, \"invalid rcs file: line to add out of range\");\n\n    /* Actually add the lines, to LINES and VEC->VECTOR.  */\n    i = pos;\n    lines[0].text = text;\n    lines[0].vers = vers;\n    lines[0].has_newline = 0;\n    vec->vector[i++] = &lines[0];\n    for (p = text; p < textend; ++p)\n\tif (*p == '\\n')\n\t{\n\t    *p = '\\0';\n\t    lines[i - pos - 1].has_newline = 1;\n\t    if (p + 1 == textend)\n\t\t/* If there are no characters beyond the last newline, we\n\t\t   don't consider it another line.  */\n\t\tbreak;\n\t    lines[i - pos - 1].len = p - lines[i - pos - 1].text;\n\t    lines[i - pos].text = p + 1;\n\t    lines[i - pos].vers = vers;\n\t    lines[i - pos].has_newline = 0;\n\t    vec->vector[i] = &lines[i - pos];\n\t    ++i;\n\t}\n    lines[i - pos - 1].len = p - lines[i - pos - 1].text;\n    vec->nlines += nnew;\n}", "item_id": 22, "repo": "aaliomer/exos", "file": "bin/CVS/src/rcs.c", "last_update_at": "2018-01-23T23:07:19+00:00", "question_id": "9c7ca375ff660a322422d65fb1ae12349978085a_22", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nlinevector_add (vec, text, len, vers, pos)\n    struct linevector *vec;\n    char *text;\n    size_t len;\n    RCSVers *vers;\n    unsigned int pos;\n{\n    char *textend;\n    unsigned int i;\n    unsigned int nnew;\n    char *p;\n    struct line *lines;\n    if (len == 0)\n\treturn;\n    textend = text + len;\n    /* Count the number of lines we will need to add.  */\n    nnew = 1;\n    for (p = text; p < textend; ++p)\n\tif (*p == '\\n' && p + 1 < textend)\n\t    ++nnew;\n    /* Allocate the struct line's.  */\n    lines = block_alloc (nnew * sizeof (struct line));\n    /* Expand VEC->VECTOR if needed.  */\n    if (vec->nlines + nnew >= vec->lines_alloced)\n    {\n\tif (vec->lines_alloced == 0)\n\t    vec->lines_alloced = 10;\n\twhile (vec->nlines + nnew >= vec->lines_alloced)\n\t    vec->lines_alloced *= 2;\n\tvec->vector = xrealloc (vec->vector,\n\t\t\t\tvec->lines_alloced * sizeof (*vec->vector));\n    }\n    /* Make room for the new lines in VEC->VECTOR.  */\n    for (i = vec->nlines + nnew - 1; i >= pos + nnew; --i)\n\tvec->vector[i] = vec->vector[i - nnew];\n    if (pos > vec->nlines)\n\terror (1, 0, \"invalid rcs file: line to add out of range\");\n    /* Actually add the lines, to LINES and VEC->VECTOR.  */\n    i = pos;\n    lines[0].text = text;\n    lines[0].vers = vers;\n    lines[0].has_newline = 0;\n    vec->vector[i++] = &lines[0];\n    for (p = text; p < textend; ++p)\n\tif (*p == '\\n')\n\t{\n\t    *p = '\\0';\n\t    lines[i - pos - 1].has_newline = 1;\n\t    if (p + 1 == textend)\n\t\t/* If there are no characters beyond the last newline, we\n\t\t   don't consider it another line.  */\n\t\tbreak;\n\t    lines[i - pos - 1].len = p - lines[i - pos - 1].text;\n\t    lines[i - pos].text = p + 1;\n\t    lines[i - pos].vers = vers;\n\t    lines[i - pos].has_newline = 0;\n\t    vec->vector[i] = &lines[i - pos];\n\t    ++i;\n\t}\n    lines[i - pos - 1].len = p - lines[i - pos - 1].text;\n    vec->nlines += nnew;\n"]]}
{"hexsha": "cd850e652da89f9db13c39af1ce0189f9fbdba9c", "ext": "c", "lang": "C", "content": "int DrawFrame(const VulkanDevice *device, float dt)\n{\n   VkRect2D backBufferRect = {\n      .offset = {\n         .x = 0,\n         .y = 0,\n      },\n      .extent = {\n         .width = device->surfaceWidth,\n         .height = device->surfaceHeight,\n      },\n   };\n\n   uint32_t curFrame = s_frameNum++ % ARRAY_COUNT(device->frames);\n   VK_VERIFY(device->vkWaitForFences(device->device, 1, &device->frames[curFrame].frameComplete, VK_TRUE, UINT64_MAX));\n   VK_VERIFY(device->vkResetFences(device->device, 1, &device->frames[curFrame].frameComplete));\n\n   VkFence nullFence = VK_NULL_HANDLE;\n   uint32_t imageIdx;\n   VkResult result = device->vkAcquireNextImageKHR(device->device, device->swapchain, UINT64_MAX,\n      device->frames[curFrame].imageAcquired, nullFence, &imageIdx);\n   if (result == VK_ERROR_OUT_OF_DATE_KHR) {\n      return 0;\n   }\n   ASSERT(result == VK_SUCCESS);\n\n   VkCommandBuffer commandBuffer = device->frames[curFrame].commandBuffer;\n\n   VkCommandBufferBeginInfo beginInfo = {\n      .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,\n      .pNext = NULL,\n      .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,\n      .pInheritanceInfo = NULL,\n   };\n\n   VK_VERIFY(device->vkBeginCommandBuffer(commandBuffer, &beginInfo));\n\n   VkClearValue clearValue = {\n      .color.float32 = { 0.086f, 0.086f, 0.1137f, 1.0f, },\n   };\n   VkRenderPassBeginInfo passInfo = {\n      .sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,\n      .pNext = NULL,\n      .renderPass = s_resources.renderPass,\n      .framebuffer = s_resources.framebuffers[imageIdx].framebuffer,\n      .renderArea = backBufferRect,\n      .clearValueCount = 1,\n      .pClearValues = &clearValue,\n   };\n   device->vkCmdBeginRenderPass(commandBuffer, &passInfo, VK_SUBPASS_CONTENTS_INLINE);\n\n   device->vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, s_resources.pipeline);\n\n   s_cubeRot += dt * CUBE_SPIN_SPEED;\n   s_cubeRot -= floorf(s_cubeRot);\n\n   ShaderMatrices matrices;\n   Mat4 worldFromLocal, viewFromWorld, viewFromLocal, clipFromView;\n   mat4RotY(&worldFromLocal, s_cubeRot * (2.0f * PI));\n\n   Vec3 eye = { 0.0f, 1.5f, -3.0f };\n   Vec3 target = { 0.0f, 0.0f, 0.0f };\n   Vec3 up = { 0.0f, 1.0f, 0.0f };\n   mat4LookAt(&viewFromWorld, eye, target, up);\n   mat4Mul(&viewFromLocal, &viewFromWorld, &worldFromLocal);\n\n   mat4PerspectiveFov(&clipFromView, PI / 2.0f, device->surfaceWidth / (float)device->surfaceHeight, 1.0f, 100.0f);\n   mat4Mul(&matrices.clipFromLocal, &clipFromView, &viewFromLocal);\n\n   device->vkCmdPushConstants(commandBuffer, s_resources.pipelineLayout, VK_SHADER_STAGE_VERTEX_BIT, 0, sizeof(matrices), &matrices);\n\n   device->vkCmdDraw(commandBuffer, 36, 1, 0, 0);\n\n   device->vkCmdEndRenderPass(commandBuffer);\n   VK_VERIFY(device->vkEndCommandBuffer(commandBuffer));\n\n   VkPipelineStageFlags stageFlags = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;\n   VkSubmitInfo submitInfo = {\n      .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,\n      .pNext = NULL,\n      .waitSemaphoreCount = 1,\n      .pWaitSemaphores = &device->frames[curFrame].imageAcquired,\n      .pWaitDstStageMask = &stageFlags,\n      .commandBufferCount = 1,\n      .pCommandBuffers = &commandBuffer,\n      .signalSemaphoreCount = 1,\n      .pSignalSemaphores = &device->frames[curFrame].drawComplete,\n   };\n\n   VK_VERIFY(device->vkQueueSubmit(device->queue, 1, &submitInfo, device->frames[curFrame].frameComplete));\n\n   VkResult presentResult;\n   VkPresentInfoKHR presentInfo = { \n      .sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,\n      .pNext = NULL,\n      .waitSemaphoreCount = 1,\n      .pWaitSemaphores = &device->frames[curFrame].drawComplete,\n      .swapchainCount = 1,\n      .pSwapchains = &device->swapchain,\n      .pImageIndices = &imageIdx,\n      .pResults = &presentResult,\n   };\n\n   VK_VERIFY(device->vkQueuePresentKHR(device->queue, &presentInfo));\n   VK_VERIFY(presentResult);\n\n   return 1;\n}", "item_id": 10, "repo": "fahickman/vkdemo", "file": "vkdemo.c", "last_update_at": "2018-07-04T21:07:18+00:00", "question_id": "cd850e652da89f9db13c39af1ce0189f9fbdba9c_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int DrawFrame(const VulkanDevice *device, float dt)\n{\n   VkRect2D backBufferRect = {\n      .offset = {\n         .x = 0,\n         .y = 0,\n      },\n      .extent = {\n         .width = device->surfaceWidth,\n         .height = device->surfaceHeight,\n      },\n   };\n   uint32_t curFrame = s_frameNum++ % ARRAY_COUNT(device->frames);\n   VK_VERIFY(device->vkWaitForFences(device->device, 1, &device->frames[curFrame].frameComplete, VK_TRUE, UINT64_MAX));\n   VK_VERIFY(device->vkResetFences(device->device, 1, &device->frames[curFrame].frameComplete));\n   VkFence nullFence = VK_NULL_HANDLE;\n   uint32_t imageIdx;\n   VkResult result = device->vkAcquireNextImageKHR(device->device, device->swapchain, UINT64_MAX,\n      device->frames[curFrame].imageAcquired, nullFence, &imageIdx);\n   if (result == VK_ERROR_OUT_OF_DATE_KHR) {\n      return 0;\n   }\n   ASSERT(result == VK_SUCCESS);\n   VkCommandBuffer commandBuffer = device->frames[curFrame].commandBuffer;\n   VkCommandBufferBeginInfo beginInfo = {\n      .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,\n      .pNext = NULL,\n      .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,\n      .pInheritanceInfo = NULL,\n   };\n   VK_VERIFY(device->vkBeginCommandBuffer(commandBuffer, &beginInfo));\n   VkClearValue clearValue = {\n      .color.float32 = { 0.086f, 0.086f, 0.1137f, 1.0f, },\n   };\n   VkRenderPassBeginInfo passInfo = {\n      .sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,\n      .pNext = NULL,\n      .renderPass = s_resources.renderPass,\n      .framebuffer = s_resources.framebuffers[imageIdx].framebuffer,\n      .renderArea = backBufferRect,\n      .clearValueCount = 1,\n      .pClearValues = &clearValue,\n   };\n   device->vkCmdBeginRenderPass(commandBuffer, &passInfo, VK_SUBPASS_CONTENTS_INLINE);\n   device->vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, s_resources.pipeline);\n   s_cubeRot += dt * CUBE_SPIN_SPEED;\n   s_cubeRot -= floorf(s_cubeRot);\n   ShaderMatrices matrices;\n   Mat4 worldFromLocal, viewFromWorld, viewFromLocal, clipFromView;\n   mat4RotY(&worldFromLocal, s_cubeRot * (2.0f * PI));\n   Vec3 eye = { 0.0f, 1.5f, -3.0f };\n   Vec3 target = { 0.0f, 0.0f, 0.0f };\n   Vec3 up = { 0.0f, 1.0f, 0.0f };\n   mat4LookAt(&viewFromWorld, eye, target, up);\n   mat4Mul(&viewFromLocal, &viewFromWorld, &worldFromLocal);\n   mat4PerspectiveFov(&clipFromView, PI / 2.0f, device->surfaceWidth / (float)device->surfaceHeight, 1.0f, 100.0f);\n   mat4Mul(&matrices.clipFromLocal, &clipFromView, &viewFromLocal);\n   device->vkCmdPushConstants(commandBuffer, s_resources.pipelineLayout, VK_SHADER_STAGE_VERTEX_BIT, 0, sizeof(matrices), &matrices);\n   device->vkCmdDraw(commandBuffer, 36, 1, 0, 0);\n   device->vkCmdEndRenderPass(commandBuffer);\n   VK_VERIFY(device->vkEndCommandBuffer(commandBuffer));\n   VkPipelineStageFlags stageFlags = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;\n   VkSubmitInfo submitInfo = {\n      .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,\n      .pNext = NULL,\n      .waitSemaphoreCount = 1,\n      .pWaitSemaphores = &device->frames[curFrame].imageAcquired,\n      .pWaitDstStageMask = &stageFlags,\n      .commandBufferCount = 1,\n      .pCommandBuffers = &commandBuffer,\n      .signalSemaphoreCount = 1,\n      .pSignalSemaphores = &device->frames[curFrame].drawComplete,\n   };\n   VK_VERIFY(device->vkQueueSubmit(device->queue, 1, &submitInfo, device->frames[curFrame].frameComplete));\n   VkResult presentResult;\n   VkPresentInfoKHR presentInfo = { \n      .sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,\n      .pNext = NULL,\n      .waitSemaphoreCount = 1,\n      .pWaitSemaphores = &device->frames[curFrame].drawComplete,\n      .swapchainCount = 1,\n      .pSwapchains = &device->swapchain,\n      .pImageIndices = &imageIdx,\n      .pResults = &presentResult,\n   };\n   VK_VERIFY(device->vkQueuePresentKHR(device->queue, &presentInfo));\n   VK_VERIFY(presentResult);\n   return 1;\n"]]}
{"hexsha": "ce75e0481e95ff417ab4d85498e3dbcc7c80f829", "ext": "h", "lang": "C", "content": "interface IMBookshelfBackgroundView : UIView\n{\n    UIImageView *_topShelfImageView;\t// 8 = 0x8\n    struct CGPoint _offset;\t// 16 = 0x10\n    double _shelfHeight;\t// 32 = 0x20\n    _Bool _useAlternateSize;\t// 40 = 0x28\n    IMBookshelfImageGenerator *_imageGenerator;\t// 48 = 0x30\n    IMLibraryTiledBackgroundView *_shelves;\t// 56 = 0x38\n    IMBookshelfImageConfiguration *_imageConfiguration;\t// 64 = 0x40\n    IMLibraryTileView *_topGradientView;\t// 72 = 0x48\n}", "item_id": 0, "repo": "lechium/tvOS10Headers", "file": "Applications/Podcasts/IMBookshelfBackgroundView.h", "last_update_at": "2018-08-04T20:16:32+00:00", "question_id": "ce75e0481e95ff417ab4d85498e3dbcc7c80f829_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface IMBookshelfBackgroundView : UIView\n{\n    UIImageView *_topShelfImageView;\t// 8 = 0x8\n    struct CGPoint _offset;\t// 16 = 0x10\n    double _shelfHeight;\t// 32 = 0x20\n    _Bool _useAlternateSize;\t// 40 = 0x28\n    IMBookshelfImageGenerator *_imageGenerator;\t// 48 = 0x30\n    IMLibraryTiledBackgroundView *_shelves;\t// 56 = 0x38\n    IMBookshelfImageConfiguration *_imageConfiguration;\t// 64 = 0x40\n    IMLibraryTileView *_topGradientView;\t// 72 = 0x48\n"]]}
{"hexsha": "694e8cddd5c13e1760e7c9cd5fc0170876a9df04", "ext": "c", "lang": "C", "content": "static bool __power_supply_is_supplied_by(struct power_supply *supplier,\n\t\t\t\t\t struct power_supply *supply)\n{\n\tint i;\n\n\tif (!supply->supplied_from && !supplier->supplied_to)\n\t\treturn false;\n\n\t/* Support both supplied_to and supplied_from modes */\n\tif (supply->supplied_from) {\n\t\tif (!supplier->name)\n\t\t\treturn false;\n\t\tfor (i = 0; i < supply->num_supplies; i++)\n\t\t\tif (!strcmp(supplier->name, supply->supplied_from[i]))\n\t\t\t\treturn true;\n\t} else {\n\t\tif (!supply->name)\n\t\t\treturn false;\n\t\tfor (i = 0; i < supplier->num_supplicants; i++)\n\t\t\tif (!strcmp(supplier->supplied_to[i], supply->name))\n\t\t\t\treturn true;\n\t}\n\n\treturn false;\n}", "item_id": 0, "repo": "bradchesney79/illacceptanything", "file": "linux/drivers/power/power_supply_core.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "694e8cddd5c13e1760e7c9cd5fc0170876a9df04_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static bool __power_supply_is_supplied_by(struct power_supply *supplier,\n\t\t\t\t\t struct power_supply *supply)\n{\n\tint i;\n\tif (!supply->supplied_from && !supplier->supplied_to)\n\t\treturn false;\n\t/* Support both supplied_to and supplied_from modes */\n\tif (supply->supplied_from) {\n\t\tif (!supplier->name)\n\t\t\treturn false;\n\t\tfor (i = 0; i < supply->num_supplies; i++)\n\t\t\tif (!strcmp(supplier->name, supply->supplied_from[i]))\n\t\t\t\treturn true;\n\t} else {\n\t\tif (!supply->name)\n\t\t\treturn false;\n\t\tfor (i = 0; i < supplier->num_supplicants; i++)\n\t\t\tif (!strcmp(supplier->supplied_to[i], supply->name))\n\t\t\t\treturn true;\n\t}\n\treturn false;\n"]]}
{"hexsha": "9eea3a10a7307de6b68ff5398cc80c651c6a7a2d", "ext": "c", "lang": "C", "content": "static void\nrndr_blockcode(hoedown_buffer *ob, const hoedown_buffer *text, const hoedown_buffer *lang, const hoedown_renderer_data *data)\n{\n\tif (ob->size) hoedown_buffer_putc(ob, '\\n');\n\n\tif (lang) {\n\t\tHOEDOWN_BUFPUTSL(ob, \"<pre><code class=\\\"language-\");\n\t\tescape_html(ob, lang->data, lang->size);\n\t\tHOEDOWN_BUFPUTSL(ob, \"\\\">\");\n\t} else {\n\t\tHOEDOWN_BUFPUTSL(ob, \"<pre><code>\");\n\t}\n\n\tif (text)\n\t\tescape_html(ob, text->data, text->size);\n\n\tHOEDOWN_BUFPUTSL(ob, \"</code></pre>\\n\");\n}", "item_id": 2, "repo": "guardianproject/cwac-anddown", "file": "anddown/jni/src/html.c", "last_update_at": "2018-12-14T13:44:25+00:00", "question_id": "9eea3a10a7307de6b68ff5398cc80c651c6a7a2d_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nrndr_blockcode(hoedown_buffer *ob, const hoedown_buffer *text, const hoedown_buffer *lang, const hoedown_renderer_data *data)\n{\n\tif (ob->size) hoedown_buffer_putc(ob, '\\n');\n\tif (lang) {\n\t\tHOEDOWN_BUFPUTSL(ob, \"<pre><code class=\\\"language-\");\n\t\tescape_html(ob, lang->data, lang->size);\n\t\tHOEDOWN_BUFPUTSL(ob, \"\\\">\");\n\t} else {\n\t\tHOEDOWN_BUFPUTSL(ob, \"<pre><code>\");\n\t}\n\tif (text)\n\t\tescape_html(ob, text->data, text->size);\n\tHOEDOWN_BUFPUTSL(ob, \"</code></pre>\\n\");\n"]]}
{"hexsha": "f690ad6e94d23678ec10f30a9f64199e7e29d2a7", "ext": "c", "lang": "C", "content": "int Yodiwo_Plegma_ConfigDescription_ToJson(char* jsonStart, size_t jsonSize, Yodiwo_Plegma_ConfigDescription_t *value)\n{\n\tchar *json = jsonStart, *jsonEnd = json + jsonSize;\n\tint len;\n\tjson += snprintf(json, jsonEnd - json, \"{ \\\"DefaultValue\\\" : \\\"\"); if (json >= jsonEnd) return -1;\n\tjson += strcpy_escaped(json, value->DefaultValue); if (json + 1 >= jsonEnd) return -1;\n\t*json = '\\\"'; json++;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Description\\\" : \\\"\"); if (json >= jsonEnd) return -1;\n\tjson += strcpy_escaped(json, value->Description); if (json + 1 >= jsonEnd) return -1;\n\t*json = '\\\"'; json++;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Label\\\" : \\\"\"); if (json >= jsonEnd) return -1;\n\tjson += strcpy_escaped(json, value->Label); if (json + 1 >= jsonEnd) return -1;\n\t*json = '\\\"'; json++;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Name\\\" : \\\"\"); if (json >= jsonEnd) return -1;\n\tjson += strcpy_escaped(json, value->Name); if (json + 1 >= jsonEnd) return -1;\n\t*json = '\\\"'; json++;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Required\\\" : %s\", (value->Required) ? \"true\" : \"false\"); if (json >= jsonEnd) return -1;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Type\\\" : \\\"\"); if (json >= jsonEnd) return -1;\n\tjson += strcpy_escaped(json, value->Type); if (json + 1 >= jsonEnd) return -1;\n\t*json = '\\\"'; json++;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Minimum\\\" : %lf\", value->Minimum); if (json >= jsonEnd) return -1;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Maximum\\\" : %lf\", value->Maximum); if (json >= jsonEnd) return -1;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Stepsize\\\" : %lf\", value->Stepsize); if (json >= jsonEnd) return -1;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"ReadOnly\\\" : %s\", (value->ReadOnly) ? \"true\" : \"false\"); if (json >= jsonEnd) return -1;\n\t*json = '}'; json++;\n\t*json = '\\0'; json++;\n\treturn json - jsonStart;\n}", "item_id": 41, "repo": "yodiwo/plegma", "file": "C/linux_node/libsrc/yodiwo/yodiwo_api.c", "last_update_at": "2018-02-26T09:38:38+00:00", "question_id": "f690ad6e94d23678ec10f30a9f64199e7e29d2a7_41", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int Yodiwo_Plegma_ConfigDescription_ToJson(char* jsonStart, size_t jsonSize, Yodiwo_Plegma_ConfigDescription_t *value)\n{\n\tchar *json = jsonStart, *jsonEnd = json + jsonSize;\n\tint len;\n\tjson += snprintf(json, jsonEnd - json, \"{ \\\"DefaultValue\\\" : \\\"\"); if (json >= jsonEnd) return -1;\n\tjson += strcpy_escaped(json, value->DefaultValue); if (json + 1 >= jsonEnd) return -1;\n\t*json = '\\\"'; json++;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Description\\\" : \\\"\"); if (json >= jsonEnd) return -1;\n\tjson += strcpy_escaped(json, value->Description); if (json + 1 >= jsonEnd) return -1;\n\t*json = '\\\"'; json++;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Label\\\" : \\\"\"); if (json >= jsonEnd) return -1;\n\tjson += strcpy_escaped(json, value->Label); if (json + 1 >= jsonEnd) return -1;\n\t*json = '\\\"'; json++;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Name\\\" : \\\"\"); if (json >= jsonEnd) return -1;\n\tjson += strcpy_escaped(json, value->Name); if (json + 1 >= jsonEnd) return -1;\n\t*json = '\\\"'; json++;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Required\\\" : %s\", (value->Required) ? \"true\" : \"false\"); if (json >= jsonEnd) return -1;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Type\\\" : \\\"\"); if (json >= jsonEnd) return -1;\n\tjson += strcpy_escaped(json, value->Type); if (json + 1 >= jsonEnd) return -1;\n\t*json = '\\\"'; json++;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Minimum\\\" : %lf\", value->Minimum); if (json >= jsonEnd) return -1;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Maximum\\\" : %lf\", value->Maximum); if (json >= jsonEnd) return -1;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"Stepsize\\\" : %lf\", value->Stepsize); if (json >= jsonEnd) return -1;\n\tjson += snprintf(json, jsonEnd - json, \", \\\"ReadOnly\\\" : %s\", (value->ReadOnly) ? \"true\" : \"false\"); if (json >= jsonEnd) return -1;\n\t*json = '}'; json++;\n\t*json = '\\0'; json++;\n\treturn json - jsonStart;\n"]]}
{"hexsha": "c42ec6f00688d39df0464e1e099ebc5743a7e81c", "ext": "c", "lang": "C", "content": "static int disassemble(char *Instruction, char *Arg1, char *Arg2)\n{\n\tunsigned int ReferencePC=memory_core.pc+2;\n\tunsigned int Displacement;\n\tBCC_Instr Instr;\n\tMemory_RetrWordFromPC(&Instr.Code);\n\tDisplacement=Instr.Bits.Displacement;\n\tswitch(Instr.Bits.Condition) {\n\tcase 0: /* BRA */\n\t\tsprintf(Instruction, \"BRA\");\n\t\tbreak;\n\tcase 1: /* BSR */\n\t\tsprintf(Instruction, \"BSR\");\n\t\tbreak;\n\tcase 2: /* BHI */\n\t\tsprintf(Instruction, \"BHI\");\n\t\tbreak;\n\tcase 3: /* BLS */\n\t\tsprintf(Instruction, \"BLS\");\n\t\tbreak;\n\tcase 4: /* BCC */\n\t\tsprintf(Instruction, \"BCC\");\n\t\tbreak;\n\tcase 5: /* BCS */\n\t\tsprintf(Instruction, \"BCS\");\n\t\tbreak;\n\tcase 6: /* BNE */\n\t\tsprintf(Instruction, \"BNE\");\n\t\tbreak;\n\tcase 7: /* BEQ */\n\t\tsprintf(Instruction, \"BEQ\");\n\t\tbreak;\n\tcase 8: /* BVC */\n\t\tsprintf(Instruction, \"BVC\");\n\t\tbreak;\n\tcase 9: /* BVS */\n\t\tsprintf(Instruction, \"BVS\");\n\t\tbreak;\n\tcase 10: /* BPL */\n\t\tsprintf(Instruction, \"BPL\");\n\t\tbreak;\n\tcase 11: /* BMI */\n\t\tsprintf(Instruction, \"BMI\");\n\t\tbreak;\n\tcase 12: /* BGE */\n\t\tsprintf(Instruction, \"BGE\");\n\t\tbreak;\n\tcase 13: /* BLT */\n\t\tsprintf(Instruction, \"BLT\");\n\t\tbreak;\n\tcase 14: /* BGT */\n\t\tsprintf(Instruction, \"BGT\");\n\t\tbreak;\n\tcase 15: /* BLE */\n\t\tsprintf(Instruction, \"BLE\");\n\t\tbreak;\n\t}\n\n\tif(Displacement==0) {\n\t\tMemory_RetrWordFromPC(&Displacement);\n\t\tDisplacement = (short)Displacement;\n/*\t\tsprintf(&Instruction[3], \".W\");*/\n\t}\n/*\telse\n\t\tsprintf(&Instruction[3], \".B\");*/\n\tsprintf(Arg1, \"0x%08lX\", ReferencePC+Displacement);\n\tArg2[0]=0;\t\n\treturn 0;\n}", "item_id": 1, "repo": "zecke/pharo-vm-1", "file": "processors/ARM/skyeye/arch/coldfire/instruction/i_bcc.c", "last_update_at": "2018-11-01T20:54:57+00:00", "question_id": "c42ec6f00688d39df0464e1e099ebc5743a7e81c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int disassemble(char *Instruction, char *Arg1, char *Arg2)\n{\n\tunsigned int ReferencePC=memory_core.pc+2;\n\tunsigned int Displacement;\n\tBCC_Instr Instr;\n\tMemory_RetrWordFromPC(&Instr.Code);\n\tDisplacement=Instr.Bits.Displacement;\n\tswitch(Instr.Bits.Condition) {\n\tcase 0: /* BRA */\n\t\tsprintf(Instruction, \"BRA\");\n\t\tbreak;\n\tcase 1: /* BSR */\n\t\tsprintf(Instruction, \"BSR\");\n\t\tbreak;\n\tcase 2: /* BHI */\n\t\tsprintf(Instruction, \"BHI\");\n\t\tbreak;\n\tcase 3: /* BLS */\n\t\tsprintf(Instruction, \"BLS\");\n\t\tbreak;\n\tcase 4: /* BCC */\n\t\tsprintf(Instruction, \"BCC\");\n\t\tbreak;\n\tcase 5: /* BCS */\n\t\tsprintf(Instruction, \"BCS\");\n\t\tbreak;\n\tcase 6: /* BNE */\n\t\tsprintf(Instruction, \"BNE\");\n\t\tbreak;\n\tcase 7: /* BEQ */\n\t\tsprintf(Instruction, \"BEQ\");\n\t\tbreak;\n\tcase 8: /* BVC */\n\t\tsprintf(Instruction, \"BVC\");\n\t\tbreak;\n\tcase 9: /* BVS */\n\t\tsprintf(Instruction, \"BVS\");\n\t\tbreak;\n\tcase 10: /* BPL */\n\t\tsprintf(Instruction, \"BPL\");\n\t\tbreak;\n\tcase 11: /* BMI */\n\t\tsprintf(Instruction, \"BMI\");\n\t\tbreak;\n\tcase 12: /* BGE */\n\t\tsprintf(Instruction, \"BGE\");\n\t\tbreak;\n\tcase 13: /* BLT */\n\t\tsprintf(Instruction, \"BLT\");\n\t\tbreak;\n\tcase 14: /* BGT */\n\t\tsprintf(Instruction, \"BGT\");\n\t\tbreak;\n\tcase 15: /* BLE */\n\t\tsprintf(Instruction, \"BLE\");\n\t\tbreak;\n\t}\n\tif(Displacement==0) {\n\t\tMemory_RetrWordFromPC(&Displacement);\n\t\tDisplacement = (short)Displacement;\n/*\t\tsprintf(&Instruction[3], \".W\");*/\n\t}\n/*\telse\n\t\tsprintf(&Instruction[3], \".B\");*/\n\tsprintf(Arg1, \"0x%08lX\", ReferencePC+Displacement);\n\tArg2[0]=0;\t\n\treturn 0;\n"]]}
{"hexsha": "e2d6015282dadd03c6e74e4c95822f2d21160ac5", "ext": "c", "lang": "C", "content": "static CDFstatus ValidateAttributeEntryLink (struct CDFstruct *CDF, vFILE *fp, \n                                      Int32 num, Logical zEntry, OFF_T EDRhead,\n                                             Int32 numEntries, Int32 maxEntry, \n                                             Logical debug)\n{\n  CDFstatus status;\n  OFF_T offset, nextAEDR;\n  Int32 entryNum, lastNum, *visits;\n  int ix, iy;\n  \n  offset = EDRhead;\n  lastNum = 0;\n  visits = (Int32 *) cdf_AllocateMemory ((size_t)numEntries * sizeof(Int32), NULL);\n  if (visits == NULL) return BAD_MALLOC;\n  for (ix = 0; ix < numEntries; ++ix) visits[ix] = 0;\n  ix = 0;\n  while (offset != 0) {\n    status = ValidateAEDR (CDF, fp, offset, num, maxEntry, zEntry, debug);\n    if (status != CDF_OK) { \n      cdf_FreeMemory (visits, NULL);\n      return status;\n    }\n    status = ReadAEDR64 (fp, offset,\n                         AEDR_NUM, &entryNum,\n                         AEDR_AEDRNEXT, &nextAEDR,\n                         AEDR_NULL);\n    if (ix > 0) {\n      for (iy = 0; iy < ix; ++iy) {\n        if (visits[iy] == entryNum) {\n          cdf_FreeMemory (visits, NULL);\n          return QuitCDF (\"CDF: entry number is repeating in an attribute entry link: \", (OFF_T) -1,\n                          4, 1, &entryNum, 0, debug);\n        }\n      }\n    }\n    if (ix == (int) numEntries) {\n      cdf_FreeMemory (visits, NULL);\n      return QuitCDF (\"CDF: number of entries is more than maximum in an attribute entry link: \", (OFF_T) -1,\n                      4, 1, &ix, 0, debug);\n    }\n    visits[ix] = entryNum;\n    ++ix;\n    if (lastNum < entryNum) lastNum = entryNum;\n    offset = nextAEDR;\n  }\n  if (lastNum != maxEntry) {\n    cdf_FreeMemory (visits, NULL);\n    return QuitCDF (\"CDF: last entry number is not the maximum entry number in  an attribute entry link: \", (OFF_T) -1,\n                    4, 2, &lastNum, &maxEntry, debug);\n  }\n  cdf_FreeMemory (visits, NULL);\n  return CDF_OK;\n}", "item_id": 14, "repo": "rstoneback/pysatCDF", "file": "cdf36_3-dist/src/lib/cdfvalidator64.c", "last_update_at": "2018-01-26T19:45:48+00:00", "question_id": "e2d6015282dadd03c6e74e4c95822f2d21160ac5_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static CDFstatus ValidateAttributeEntryLink (struct CDFstruct *CDF, vFILE *fp, \n                                      Int32 num, Logical zEntry, OFF_T EDRhead,\n                                             Int32 numEntries, Int32 maxEntry, \n                                             Logical debug)\n{\n  CDFstatus status;\n  OFF_T offset, nextAEDR;\n  Int32 entryNum, lastNum, *visits;\n  int ix, iy;\n  offset = EDRhead;\n  lastNum = 0;\n  visits = (Int32 *) cdf_AllocateMemory ((size_t)numEntries * sizeof(Int32), NULL);\n  if (visits == NULL) return BAD_MALLOC;\n  for (ix = 0; ix < numEntries; ++ix) visits[ix] = 0;\n  ix = 0;\n  while (offset != 0) {\n    status = ValidateAEDR (CDF, fp, offset, num, maxEntry, zEntry, debug);\n    if (status != CDF_OK) { \n      cdf_FreeMemory (visits, NULL);\n      return status;\n    }\n    status = ReadAEDR64 (fp, offset,\n                         AEDR_NUM, &entryNum,\n                         AEDR_AEDRNEXT, &nextAEDR,\n                         AEDR_NULL);\n    if (ix > 0) {\n      for (iy = 0; iy < ix; ++iy) {\n        if (visits[iy] == entryNum) {\n          cdf_FreeMemory (visits, NULL);\n          return QuitCDF (\"CDF: entry number is repeating in an attribute entry link: \", (OFF_T) -1,\n                          4, 1, &entryNum, 0, debug);\n        }\n      }\n    }\n    if (ix == (int) numEntries) {\n      cdf_FreeMemory (visits, NULL);\n      return QuitCDF (\"CDF: number of entries is more than maximum in an attribute entry link: \", (OFF_T) -1,\n                      4, 1, &ix, 0, debug);\n    }\n    visits[ix] = entryNum;\n    ++ix;\n    if (lastNum < entryNum) lastNum = entryNum;\n    offset = nextAEDR;\n  }\n  if (lastNum != maxEntry) {\n    cdf_FreeMemory (visits, NULL);\n    return QuitCDF (\"CDF: last entry number is not the maximum entry number in  an attribute entry link: \", (OFF_T) -1,\n                    4, 2, &lastNum, &maxEntry, debug);\n  }\n  cdf_FreeMemory (visits, NULL);\n  return CDF_OK;\n"]]}
{"hexsha": "11466f7394ed835e3bf4a6318e91cc20f45752cf", "ext": "c", "lang": "C", "content": "void itoa16bits(uint16_t number, char* ascii) {\n\tint i, j, k;\n\ti = 0;\n\tfor (k = 10000; k > 10; k /= 10) {\n\t\tj = number/k;\n\t\tascii[i] = j + 48;\n\t\t++i;\n\t\tnumber %= k;\n\t}\n\tj = number/k;\n\tascii[i] = j + 48;\n\t++i;\n\tj = number%k;\n\tascii[i] = j + 48;\n}", "item_id": 4, "repo": "daniel5555/Mikromedia-plus-STM32-MP3-player", "file": "utils.c", "last_update_at": "2018-10-06T19:56:36+00:00", "question_id": "11466f7394ed835e3bf4a6318e91cc20f45752cf_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void itoa16bits(uint16_t number, char* ascii) {\n\tint i, j, k;\n\ti = 0;\n\tfor (k = 10000; k > 10; k /= 10) {\n\t\tj = number/k;\n\t\tascii[i] = j + 48;\n\t\t++i;\n\t\tnumber %= k;\n\t}\n\tj = number/k;\n\tascii[i] = j + 48;\n\t++i;\n\tj = number%k;\n\tascii[i] = j + 48;\n"]]}
{"hexsha": "8998689299fdc270786615c8a2402528f6850ecc", "ext": "c", "lang": "C", "content": "u32 bq24261_get_minsys_status(void)\n{\n\tu32 ret = 0;\n\tu8 val = 0;\n\n\tret = bq24261_read_interface((u8) (bq24261_CON5),\n\t\t\t\t     (&val),\n\t\t\t\t     (u8) (CON5_MINSYS_STATUS_MASK), (u8) (CON5_MINSYS_STATUS_SHIFT)\n\t    );\n\treturn val;\n}", "item_id": 10, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/drivers/power/mt81xx/bq24261.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "8998689299fdc270786615c8a2402528f6850ecc_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["u32 bq24261_get_minsys_status(void)\n{\n\tu32 ret = 0;\n\tu8 val = 0;\n\tret = bq24261_read_interface((u8) (bq24261_CON5),\n\t\t\t\t     (&val),\n\t\t\t\t     (u8) (CON5_MINSYS_STATUS_MASK), (u8) (CON5_MINSYS_STATUS_SHIFT)\n\t    );\n\treturn val;\n"]]}
{"hexsha": "9e57b77ecd34ef3367ed64b4105c5ce65e3c724f", "ext": "c", "lang": "C", "content": "static struct f71805f_data *f71805f_update_device(struct device *dev)\n{\n\tstruct f71805f_data *data = dev_get_drvdata(dev);\n\tint nr, apnr;\n\n\tmutex_lock(&data->update_lock);\n\n\t/* Limit registers cache is refreshed after 60 seconds */\n\tif (time_after(jiffies, data->last_updated + 60 * HZ)\n\t || !data->valid) {\n\t\tfor (nr = 0; nr < 11; nr++) {\n\t\t\tif (!(data->has_in & (1 << nr)))\n\t\t\t\tcontinue;\n\t\t\tdata->in_high[nr] = f71805f_read8(data,\n\t\t\t\t\t    F71805F_REG_IN_HIGH(nr));\n\t\t\tdata->in_low[nr] = f71805f_read8(data,\n\t\t\t\t\t   F71805F_REG_IN_LOW(nr));\n\t\t}\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tdata->fan_low[nr] = f71805f_read16(data,\n\t\t\t\t\t    F71805F_REG_FAN_LOW(nr));\n\t\t\tdata->fan_target[nr] = f71805f_read16(data,\n\t\t\t\t\t       F71805F_REG_FAN_TARGET(nr));\n\t\t\tdata->pwm_freq[nr] = f71805f_read8(data,\n\t\t\t\t\t     F71805F_REG_PWM_FREQ(nr));\n\t\t}\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tdata->temp_high[nr] = f71805f_read8(data,\n\t\t\t\t\t      F71805F_REG_TEMP_HIGH(nr));\n\t\t\tdata->temp_hyst[nr] = f71805f_read8(data,\n\t\t\t\t\t      F71805F_REG_TEMP_HYST(nr));\n\t\t}\n\t\tdata->temp_mode = f71805f_read8(data, F71805F_REG_TEMP_MODE);\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tfor (apnr = 0; apnr < 3; apnr++) {\n\t\t\t\tdata->auto_points[nr].temp[apnr] =\n\t\t\t\t\tf71805f_read8(data,\n\t\t\t\t\tF71805F_REG_PWM_AUTO_POINT_TEMP(nr,\n\t\t\t\t\t\t\t\t\tapnr));\n\t\t\t\tdata->auto_points[nr].fan[apnr] =\n\t\t\t\t\tf71805f_read16(data,\n\t\t\t\t\tF71805F_REG_PWM_AUTO_POINT_FAN(nr,\n\t\t\t\t\t\t\t\t       apnr));\n\t\t\t}\n\t\t}\n\n\t\tdata->last_limits = jiffies;\n\t}\n\n\t/* Measurement registers cache is refreshed after 1 second */\n\tif (time_after(jiffies, data->last_updated + HZ)\n\t || !data->valid) {\n\t\tfor (nr = 0; nr < 11; nr++) {\n\t\t\tif (!(data->has_in & (1 << nr)))\n\t\t\t\tcontinue;\n\t\t\tdata->in[nr] = f71805f_read8(data,\n\t\t\t\t       F71805F_REG_IN(nr));\n\t\t}\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tdata->fan[nr] = f71805f_read16(data,\n\t\t\t\t\tF71805F_REG_FAN(nr));\n\t\t\tdata->fan_ctrl[nr] = f71805f_read8(data,\n\t\t\t\t\t     F71805F_REG_FAN_CTRL(nr));\n\t\t\tdata->pwm[nr] = f71805f_read8(data,\n\t\t\t\t\tF71805F_REG_PWM_DUTY(nr));\n\t\t}\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tdata->temp[nr] = f71805f_read8(data,\n\t\t\t\t\t F71805F_REG_TEMP(nr));\n\t\t}\n\t\tdata->alarms = f71805f_read8(data, F71805F_REG_STATUS(0))\n\t\t\t+ (f71805f_read8(data, F71805F_REG_STATUS(1)) << 8)\n\t\t\t+ (f71805f_read8(data, F71805F_REG_STATUS(2)) << 16);\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = 1;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}", "item_id": 10, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/drivers/hwmon/f71805f.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "9e57b77ecd34ef3367ed64b4105c5ce65e3c724f_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static struct f71805f_data *f71805f_update_device(struct device *dev)\n{\n\tstruct f71805f_data *data = dev_get_drvdata(dev);\n\tint nr, apnr;\n\tmutex_lock(&data->update_lock);\n\t/* Limit registers cache is refreshed after 60 seconds */\n\tif (time_after(jiffies, data->last_updated + 60 * HZ)\n\t || !data->valid) {\n\t\tfor (nr = 0; nr < 11; nr++) {\n\t\t\tif (!(data->has_in & (1 << nr)))\n\t\t\t\tcontinue;\n\t\t\tdata->in_high[nr] = f71805f_read8(data,\n\t\t\t\t\t    F71805F_REG_IN_HIGH(nr));\n\t\t\tdata->in_low[nr] = f71805f_read8(data,\n\t\t\t\t\t   F71805F_REG_IN_LOW(nr));\n\t\t}\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tdata->fan_low[nr] = f71805f_read16(data,\n\t\t\t\t\t    F71805F_REG_FAN_LOW(nr));\n\t\t\tdata->fan_target[nr] = f71805f_read16(data,\n\t\t\t\t\t       F71805F_REG_FAN_TARGET(nr));\n\t\t\tdata->pwm_freq[nr] = f71805f_read8(data,\n\t\t\t\t\t     F71805F_REG_PWM_FREQ(nr));\n\t\t}\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tdata->temp_high[nr] = f71805f_read8(data,\n\t\t\t\t\t      F71805F_REG_TEMP_HIGH(nr));\n\t\t\tdata->temp_hyst[nr] = f71805f_read8(data,\n\t\t\t\t\t      F71805F_REG_TEMP_HYST(nr));\n\t\t}\n\t\tdata->temp_mode = f71805f_read8(data, F71805F_REG_TEMP_MODE);\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tfor (apnr = 0; apnr < 3; apnr++) {\n\t\t\t\tdata->auto_points[nr].temp[apnr] =\n\t\t\t\t\tf71805f_read8(data,\n\t\t\t\t\tF71805F_REG_PWM_AUTO_POINT_TEMP(nr,\n\t\t\t\t\t\t\t\t\tapnr));\n\t\t\t\tdata->auto_points[nr].fan[apnr] =\n\t\t\t\t\tf71805f_read16(data,\n\t\t\t\t\tF71805F_REG_PWM_AUTO_POINT_FAN(nr,\n\t\t\t\t\t\t\t\t       apnr));\n\t\t\t}\n\t\t}\n\t\tdata->last_limits = jiffies;\n\t}\n\t/* Measurement registers cache is refreshed after 1 second */\n\tif (time_after(jiffies, data->last_updated + HZ)\n\t || !data->valid) {\n\t\tfor (nr = 0; nr < 11; nr++) {\n\t\t\tif (!(data->has_in & (1 << nr)))\n\t\t\t\tcontinue;\n\t\t\tdata->in[nr] = f71805f_read8(data,\n\t\t\t\t       F71805F_REG_IN(nr));\n\t\t}\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tdata->fan[nr] = f71805f_read16(data,\n\t\t\t\t\tF71805F_REG_FAN(nr));\n\t\t\tdata->fan_ctrl[nr] = f71805f_read8(data,\n\t\t\t\t\t     F71805F_REG_FAN_CTRL(nr));\n\t\t\tdata->pwm[nr] = f71805f_read8(data,\n\t\t\t\t\tF71805F_REG_PWM_DUTY(nr));\n\t\t}\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tdata->temp[nr] = f71805f_read8(data,\n\t\t\t\t\t F71805F_REG_TEMP(nr));\n\t\t}\n\t\tdata->alarms = f71805f_read8(data, F71805F_REG_STATUS(0))\n\t\t\t+ (f71805f_read8(data, F71805F_REG_STATUS(1)) << 8)\n\t\t\t+ (f71805f_read8(data, F71805F_REG_STATUS(2)) << 16);\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = 1;\n\t}\n\tmutex_unlock(&data->update_lock);\n\treturn data;\n"]]}
{"hexsha": "ef1571ef0753a638cfdedef0d904069aa73b75cd", "ext": "c", "lang": "C", "content": "static int UartMon_readPolling(UART_Handle handle, void *buffer, size_t size)\n{\n    UartMon_Object *obj = handle->object;\n\n    int bytes_read = UART_readPolling(obj->hUart_in, buffer, size);\n    if (bytes_read > 0) {\n        /* We should forward with polling functionality too, since this function\n         * may be called while interrupts are disabled\n         */\n        UART_writePolling(obj->hUart_debug, buffer, bytes_read);\n    }\n    return bytes_read;\n}", "item_id": 3, "repo": "mdlewisfb/OpenCellular", "file": "firmware/ec/src/devices/uart/UartMon.c", "last_update_at": "2018-10-25T20:06:51+00:00", "question_id": "ef1571ef0753a638cfdedef0d904069aa73b75cd_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int UartMon_readPolling(UART_Handle handle, void *buffer, size_t size)\n{\n    UartMon_Object *obj = handle->object;\n    int bytes_read = UART_readPolling(obj->hUart_in, buffer, size);\n    if (bytes_read > 0) {\n        /* We should forward with polling functionality too, since this function\n         * may be called while interrupts are disabled\n         */\n        UART_writePolling(obj->hUart_debug, buffer, bytes_read);\n    }\n    return bytes_read;\n"]]}
{"hexsha": "c886a8cb0ed9d168be8fd96a1a5e0317bf0fc3fe", "ext": "c", "lang": "C", "content": "bool ica_at_complianceTest(uint8_t *at_cmd, int16_t at_cmd_len)\n{\n    bool        ret = true;\n    uint8_t     idx;\n\n    if (at_cmd_len == (strlen(LORA_AT_CTEST) + 2) &&\n        strcmp(&at_cmd[strlen(LORA_AT_CTEST)], \"=?\") == 0) {\n        snprintf(atcmd, ATCMD_SIZE,\n                 \"\\r\\n%s:[idx]\\r\\n\", LORA_AT_CTEST);\n    } else if (at_cmd_len >= (strlen(LORA_AT_CTEST) + 2) &&\n               at_cmd[strlen(LORA_AT_CTEST)] == '=') {\n        idx = strtol(&at_cmd[strlen(LORA_AT_CTEST) + 1], NULL, 16);\n        ret = lora_compliance_test(idx);\n        if (ret == true) {\n            snprintf(atcmd, ATCMD_SIZE, \"\\r\\nOK\\r\\n\");\n        }\n    } else {\n        ret = false;\n    }\n\n    return ret;\n}", "item_id": 41, "repo": "HelloAllen8893/AliOS-Things", "file": "components/wireless/lorawan/lorawan_4_4_2/linkwan/linkwan_ica_at.c", "last_update_at": "2018-11-28T03:19:22+00:00", "question_id": "c886a8cb0ed9d168be8fd96a1a5e0317bf0fc3fe_41", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool ica_at_complianceTest(uint8_t *at_cmd, int16_t at_cmd_len)\n{\n    bool        ret = true;\n    uint8_t     idx;\n    if (at_cmd_len == (strlen(LORA_AT_CTEST) + 2) &&\n        strcmp(&at_cmd[strlen(LORA_AT_CTEST)], \"=?\") == 0) {\n        snprintf(atcmd, ATCMD_SIZE,\n                 \"\\r\\n%s:[idx]\\r\\n\", LORA_AT_CTEST);\n    } else if (at_cmd_len >= (strlen(LORA_AT_CTEST) + 2) &&\n               at_cmd[strlen(LORA_AT_CTEST)] == '=') {\n        idx = strtol(&at_cmd[strlen(LORA_AT_CTEST) + 1], NULL, 16);\n        ret = lora_compliance_test(idx);\n        if (ret == true) {\n            snprintf(atcmd, ATCMD_SIZE, \"\\r\\nOK\\r\\n\");\n        }\n    } else {\n        ret = false;\n    }\n    return ret;\n"]]}
{"hexsha": "aaa17f4d65b538f54670a5d2213ae24f45955977", "ext": "c", "lang": "C", "content": "err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg)\n{\n\terr_t err = ERR_OK;\n\tu8_t first_msg = 0;\n\tu32_t tmp = 0;\n\tsys_arch_sem_wait(&(mbox->mutex), 0);\n\n\tLWIP_DEBUGF(SYS_DEBUG, (\"mbox %p msg %p\\n\", (void *)mbox, (void *)msg));\n\t/* Check if the queue is full */\n\ttmp = (mbox->rear + 1) % mbox->queue_size;\n\tif (tmp == mbox->front) {\n\t\tLWIP_DEBUGF(SYS_DEBUG, (\"Queue Full, returning error\\n\"));\n\t\terr = ERR_MEM;\n\t\tgoto errout_with_mutex;\n\t}\n\n\tif (mbox->rear == mbox->front) {\n\t\tfirst_msg = 1;\n\t} else {\n\t\tfirst_msg = 0;\n\t}\n\n\tmbox->rear = tmp;\n\tmbox->msgs[mbox->rear] = msg;\n\tLWIP_DEBUGF(SYS_DEBUG, (\"Post SUCCESS\\n\"));\n\n\t/* If msg was posted to an empty queue, Release semaphore for\n\t   some fetch api blocked on this sem due to Empty queue. */\n\tif (first_msg && mbox->wait_fetch) {\n\t\tsys_sem_signal(&(mbox->mail));\n\t}\n\nerrout_with_mutex:\n\tsys_sem_signal(&(mbox->mutex));\n\n\treturn err;\n}", "item_id": 2, "repo": "chhee66/TizenRT", "file": "os/net/lwip/sys/arch/sys_arch.c", "last_update_at": "2018-04-23T12:39:01+00:00", "question_id": "aaa17f4d65b538f54670a5d2213ae24f45955977_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg)\n{\n\terr_t err = ERR_OK;\n\tu8_t first_msg = 0;\n\tu32_t tmp = 0;\n\tsys_arch_sem_wait(&(mbox->mutex), 0);\n\tLWIP_DEBUGF(SYS_DEBUG, (\"mbox %p msg %p\\n\", (void *)mbox, (void *)msg));\n\t/* Check if the queue is full */\n\ttmp = (mbox->rear + 1) % mbox->queue_size;\n\tif (tmp == mbox->front) {\n\t\tLWIP_DEBUGF(SYS_DEBUG, (\"Queue Full, returning error\\n\"));\n\t\terr = ERR_MEM;\n\t\tgoto errout_with_mutex;\n\t}\n\tif (mbox->rear == mbox->front) {\n\t\tfirst_msg = 1;\n\t} else {\n\t\tfirst_msg = 0;\n\t}\n\tmbox->rear = tmp;\n\tmbox->msgs[mbox->rear] = msg;\n\tLWIP_DEBUGF(SYS_DEBUG, (\"Post SUCCESS\\n\"));\n\t/* If msg was posted to an empty queue, Release semaphore for\n\t   some fetch api blocked on this sem due to Empty queue. */\n\tif (first_msg && mbox->wait_fetch) {\n\t\tsys_sem_signal(&(mbox->mail));\n\t}\nerrout_with_mutex:\n\tsys_sem_signal(&(mbox->mutex));\n\treturn err;\n"]]}
{"hexsha": "165f7a45f3f88921bc4ed5ca5698e6c5c6d26fb8", "ext": "c", "lang": "C", "content": "static int MmalGraph_init(MmalGraphObject *self, PyObject *args, PyObject *kwds) {\n\n\tint display = -1;\n\tstatic char *kwlist[] = {\"display\", NULL};\n\n\tif (!PyArg_ParseTupleAndKeywords(args, kwds, \"|i\", kwlist, &display)) {\n\n\t\treturn -1;\n\t}\n\n\tif (display >= 0) {\n\n\t\tself->display_num = display;\n\t}\n\n\treturn 0;\n}", "item_id": 3, "repo": "amaork/pylibmmal", "file": "src/mmal_graph.c", "last_update_at": "2018-12-11T18:41:59+00:00", "question_id": "165f7a45f3f88921bc4ed5ca5698e6c5c6d26fb8_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int MmalGraph_init(MmalGraphObject *self, PyObject *args, PyObject *kwds) {\n\tint display = -1;\n\tstatic char *kwlist[] = {\"display\", NULL};\n\tif (!PyArg_ParseTupleAndKeywords(args, kwds, \"|i\", kwlist, &display)) {\n\t\treturn -1;\n\t}\n\tif (display >= 0) {\n\t\tself->display_num = display;\n\t}\n\treturn 0;\n"]]}
{"hexsha": "b85ba71a6f77e974d82ccdd635109f36d0ddaac8", "ext": "h", "lang": "C", "content": "static int\nremoteDomainRestore(virConnectPtr conn, const char *from)\n{\n    int rv = -1;\n    struct private_data *priv = conn->privateData;\n    remote_domain_restore_args args;\n\n    remoteDriverLock(priv);\n\n    args.from = (char *)from;\n\n    if (call(conn, priv, 0, REMOTE_PROC_DOMAIN_RESTORE,\n             (xdrproc_t)xdr_remote_domain_restore_args, (char *)&args,\n             (xdrproc_t)xdr_void, (char *)NULL) == -1) {\n        goto done;\n    }\n\n    rv = 0;\n\ndone:\n    remoteDriverUnlock(priv);\n    return rv;\n}", "item_id": 97, "repo": "SIIS-cloud/pileus", "file": "libvirt/pileus-libvirt-1.2.12/src/remote/remote_client_bodies.h", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "b85ba71a6f77e974d82ccdd635109f36d0ddaac8_97", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nremoteDomainRestore(virConnectPtr conn, const char *from)\n{\n    int rv = -1;\n    struct private_data *priv = conn->privateData;\n    remote_domain_restore_args args;\n    remoteDriverLock(priv);\n    args.from = (char *)from;\n    if (call(conn, priv, 0, REMOTE_PROC_DOMAIN_RESTORE,\n             (xdrproc_t)xdr_remote_domain_restore_args, (char *)&args,\n             (xdrproc_t)xdr_void, (char *)NULL) == -1) {\n        goto done;\n    }\n    rv = 0;\ndone:\n    remoteDriverUnlock(priv);\n    return rv;\n"]]}
{"hexsha": "bbd97466b6d9cca41438ea793ee4772a2366211a", "ext": "c", "lang": "C", "content": "void Manage_Series(REBSER *series)\n/*\n**\t\tWhen a series is first created, it is in a state of being\n**\t\tmanually memory managed.  Thus, you can call Free_Series on\n**\t\tit if you are sure you do not need it.  This will transition\n**\t\ta manually managed series to be one managed by the GC.  There\n**\t\tis no way to transition it back--once a series has become\n**\t\tmanaged, only the GC can free it.\n**\n**\t\tAll series that wind up in user-visible values *must* be\n**\t\tmanaged, because the user can make copies of values\n**\t\tcontaining that series.  When these copies are made, it's\n**\t\tno longer safe to assume it's okay to free the original.\n**\n***********************************************************************/\n{\n\tREBSER ** const last_ptr\n\t\t= &cast(REBSER**, GC_Manuals->data)[GC_Manuals->tail - 1];\n\n\tassert(!SERIES_GET_FLAG(series, SER_MANAGED));\n\tSERIES_SET_FLAG(series, SER_MANAGED);\n\n\t// Note: Code repeated in Free_Series()\n\tassert(GC_Manuals->tail >= 1);\n\tif (*last_ptr != series) {\n\t\t// If the series is not the last manually added series, then\n\t\t// find where it is, then move the last manually added series\n\t\t// to that position to preserve it when we chop off the tail\n\t\t// (instead of keeping the series we want to free).\n\t\tREBSER **current_ptr = last_ptr - 1;\n\t\twhile (*current_ptr != series) {\n\t\t\tassert(current_ptr > cast(REBSER**, GC_Manuals->data));\n\t\t\t--current_ptr;\n\t\t}\n\t\t*current_ptr = *last_ptr;\n\t}\n\tGC_Manuals->tail--; // !!! Should it ever shrink or save memory?\n}", "item_id": 16, "repo": "codebybrett/rebol-source-scripting", "file": "201508-source-format-change/install-20151015-source-scanner/core/m-pools.c", "last_update_at": "2018-03-30T15:45:16+00:00", "question_id": "bbd97466b6d9cca41438ea793ee4772a2366211a_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void Manage_Series(REBSER *series)\n/*\n**\t\tWhen a series is first created, it is in a state of being\n**\t\tmanually memory managed.  Thus, you can call Free_Series on\n**\t\tit if you are sure you do not need it.  This will transition\n**\t\ta manually managed series to be one managed by the GC.  There\n**\t\tis no way to transition it back--once a series has become\n**\t\tmanaged, only the GC can free it.\n**\n**\t\tAll series that wind up in user-visible values *must* be\n**\t\tmanaged, because the user can make copies of values\n**\t\tcontaining that series.  When these copies are made, it's\n**\t\tno longer safe to assume it's okay to free the original.\n**\n***********************************************************************/\n{\n\tREBSER ** const last_ptr\n\t\t= &cast(REBSER**, GC_Manuals->data)[GC_Manuals->tail - 1];\n\tassert(!SERIES_GET_FLAG(series, SER_MANAGED));\n\tSERIES_SET_FLAG(series, SER_MANAGED);\n\t// Note: Code repeated in Free_Series()\n\tassert(GC_Manuals->tail >= 1);\n\tif (*last_ptr != series) {\n\t\t// If the series is not the last manually added series, then\n\t\t// find where it is, then move the last manually added series\n\t\t// to that position to preserve it when we chop off the tail\n\t\t// (instead of keeping the series we want to free).\n\t\tREBSER **current_ptr = last_ptr - 1;\n\t\twhile (*current_ptr != series) {\n\t\t\tassert(current_ptr > cast(REBSER**, GC_Manuals->data));\n\t\t\t--current_ptr;\n\t\t}\n\t\t*current_ptr = *last_ptr;\n\t}\n\tGC_Manuals->tail--; // !!! Should it ever shrink or save memory?\n"]]}
{"hexsha": "88f885a5092d38d9d5352b5897953a1b37fe7fb4", "ext": "c", "lang": "C", "content": "void generic_sendmsg (const char *fmt, ...)\n{\n\tva_list ap;\n\tfprintf(outstream, \"@\");\n\tva_start(ap, fmt);\n\tvfprintf(outstream, fmt, ap);\n\tva_end(ap);\n\tfprintf(outstream, \"\\n\");\n}", "item_id": 0, "repo": "svenskan/pronunciation", "file": "vendor/mpg123/src/control_generic.c", "last_update_at": "2018-04-25T22:29:34+00:00", "question_id": "88f885a5092d38d9d5352b5897953a1b37fe7fb4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void generic_sendmsg (const char *fmt, ...)\n{\n\tva_list ap;\n\tfprintf(outstream, \"@\");\n\tva_start(ap, fmt);\n\tvfprintf(outstream, fmt, ap);\n\tva_end(ap);\n\tfprintf(outstream, \"\\n\");\n"]]}
{"hexsha": "e9fc79c40cef53289f1618b9bcae35720f39d765", "ext": "c", "lang": "C", "content": "YY_RULE(int) yy_range()\n{  int yypos0= yypos, yythunkpos0= yythunkpos;\n  yyprintf((stderr, \"%s\\n\", \"range\"));\n  {  int yypos21= yypos, yythunkpos21= yythunkpos;  if (!yy_char()) goto l22;  if (!yymatchChar('-')) goto l22;  if (!yy_char()) goto l22;  goto l21;\n  l22:;\t  yypos= yypos21; yythunkpos= yythunkpos21;  if (!yy_char()) goto l20;\n  }\n  l21:;\t\n  yyprintf((stderr, \"  ok   %s @ %s\\n\", \"range\", yybuf+yypos));\n  return 1;\n  l20:;\t  yypos= yypos0; yythunkpos= yythunkpos0;\n  yyprintf((stderr, \"  fail %s @ %s\\n\", \"range\", yybuf+yypos));\n  return 0;\n}", "item_id": 34, "repo": "r-lyeh/scriptorium", "file": "ruby/tinyrb-ist/vendor/peg/leg.c", "last_update_at": "2018-01-08T03:02:37+00:00", "question_id": "e9fc79c40cef53289f1618b9bcae35720f39d765_34", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["YY_RULE(int) yy_range()\n{  int yypos0= yypos, yythunkpos0= yythunkpos;\n  yyprintf((stderr, \"%s\\n\", \"range\"));\n  {  int yypos21= yypos, yythunkpos21= yythunkpos;  if (!yy_char()) goto l22;  if (!yymatchChar('-')) goto l22;  if (!yy_char()) goto l22;  goto l21;\n  l22:;\t  yypos= yypos21; yythunkpos= yythunkpos21;  if (!yy_char()) goto l20;\n  }\n  l21:;\t\n  yyprintf((stderr, \"  ok   %s @ %s\\n\", \"range\", yybuf+yypos));\n  return 1;\n  l20:;\t  yypos= yypos0; yythunkpos= yythunkpos0;\n  yyprintf((stderr, \"  fail %s @ %s\\n\", \"range\", yybuf+yypos));\n  return 0;\n"]]}
{"hexsha": "e7ec6e86c60a44ef3c227784777a281297d77697", "ext": "c", "lang": "C", "content": "int setConnTimeout(int conn_timeout){\n  if (conn_timeout <= 0) {\n    Log(ERROR, \"Connection timout must be greater than zero\");\n    sprintf(NpsErrDesc, \"%s\", \"Connection timout must be greater than zero\");\n    return -1;\n  }\n  NpsConnTimeout=conn_timeout;\n  return 0;\n}", "item_id": 1, "repo": "Ingenico-NPS-Latam/nps-sdk-c", "file": "npsSdk.c", "last_update_at": "2018-05-31T17:55:31+00:00", "question_id": "e7ec6e86c60a44ef3c227784777a281297d77697_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int setConnTimeout(int conn_timeout){\n  if (conn_timeout <= 0) {\n    Log(ERROR, \"Connection timout must be greater than zero\");\n    sprintf(NpsErrDesc, \"%s\", \"Connection timout must be greater than zero\");\n    return -1;\n  }\n  NpsConnTimeout=conn_timeout;\n  return 0;\n"]]}
{"hexsha": "3d1a1307259533a4e9010bd1bc617353da07e815", "ext": "h", "lang": "C", "content": "NS_SCRIPTABLE nsIRDFXMLParser : public nsISupports {\n public: \n\n  NS_DECLARE_STATIC_IID_ACCESSOR(NS_IRDFXMLPARSER_IID)\n\n  /**\n     * Create a stream listener that can be used to asynchronously\n     * parse RDF/XML.\n     * @param aSink the RDF datasource the will receive the data\n     * @param aBaseURI the base URI used to resolve relative\n     *   references in the RDF/XML\n     * @return an nsIStreamListener object to handle the data\n     */\n  /* nsIStreamListener parseAsync (in nsIRDFDataSource aSink, in nsIURI aBaseURI); */\n  NS_SCRIPTABLE NS_IMETHOD ParseAsync(nsIRDFDataSource *aSink, nsIURI *aBaseURI, nsIStreamListener **_retval NS_OUTPARAM) = 0;\n\n  /**\n     * Parse a string of RDF/XML\n     * @param aSink the RDF datasource that will receive the data\n     * @param aBaseURI the base URI used to resolve relative\n     *   references in the RDF/XML\n     * @param aSource a UTF8 string containing RDF/XML data.\n     */\n  /* void parseString (in nsIRDFDataSource aSink, in nsIURI aBaseURI, in AUTF8String aSource); */\n  NS_SCRIPTABLE NS_IMETHOD ParseString(nsIRDFDataSource *aSink, nsIURI *aBaseURI, const nsACString & aSource) = 0;\n\n}", "item_id": 0, "repo": "akiellor/selenium", "file": "third_party/gecko-2/mac/include/nsIRDFXMLParser.h", "last_update_at": "2018-08-24T18:01:34+00:00", "question_id": "3d1a1307259533a4e9010bd1bc617353da07e815_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["NS_SCRIPTABLE nsIRDFXMLParser : public nsISupports {\n public: \n  NS_DECLARE_STATIC_IID_ACCESSOR(NS_IRDFXMLPARSER_IID)\n  /**\n     * Create a stream listener that can be used to asynchronously\n     * parse RDF/XML.\n     * @param aSink the RDF datasource the will receive the data\n     * @param aBaseURI the base URI used to resolve relative\n     *   references in the RDF/XML\n     * @return an nsIStreamListener object to handle the data\n     */\n  /* nsIStreamListener parseAsync (in nsIRDFDataSource aSink, in nsIURI aBaseURI); */\n  NS_SCRIPTABLE NS_IMETHOD ParseAsync(nsIRDFDataSource *aSink, nsIURI *aBaseURI, nsIStreamListener **_retval NS_OUTPARAM) = 0;\n  /**\n     * Parse a string of RDF/XML\n     * @param aSink the RDF datasource that will receive the data\n     * @param aBaseURI the base URI used to resolve relative\n     *   references in the RDF/XML\n     * @param aSource a UTF8 string containing RDF/XML data.\n     */\n  /* void parseString (in nsIRDFDataSource aSink, in nsIURI aBaseURI, in AUTF8String aSource); */\n  NS_SCRIPTABLE NS_IMETHOD ParseString(nsIRDFDataSource *aSink, nsIURI *aBaseURI, const nsACString & aSource) = 0;\n"]]}
{"hexsha": "154e35644c750239d8b26b3b469042a5d1d97c5a", "ext": "c", "lang": "C", "content": "TEST_FUNCTION(wsio_dowork_with_NULL_handle_does_nothing)\n{\n    // arrange\n\n    // act\n    wsio_get_interface_description()->concrete_io_dowork(NULL);\n\n    // assert\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n}", "item_id": 49, "repo": "InfiniteYuan1/gprs_a9_azure", "file": "libs/azure/src/c-utility/tests/wsio_ut/wsio_ut.c", "last_update_at": "2018-03-17T00:26:14+00:00", "question_id": "154e35644c750239d8b26b3b469042a5d1d97c5a_49", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["TEST_FUNCTION(wsio_dowork_with_NULL_handle_does_nothing)\n{\n    // arrange\n    // act\n    wsio_get_interface_description()->concrete_io_dowork(NULL);\n    // assert\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n"]]}
{"hexsha": "168b79695ed5d43bcb40a595fde3d855454980fa", "ext": "h", "lang": "C", "content": "static void sigchld(int, siginfo_t* sinfo, void*)\n    {\n        assert(sinfo);\n        assert(sinfo->si_signo == SIGCHLD);\n        int status = 0;\n        ext::hash_set<pid_t>::iterator i = children_.find(sinfo->si_pid);\n\n        switch (sinfo->si_code)\n        {\n        case CLD_EXITED:\n        case CLD_KILLED:\n        case CLD_DUMPED:\n        #if DEBUG\n            std::clog << __func__<< \": si_pid=\" << sinfo->si_pid;\n            std::clog << \" si_code=\" << sinfo->si_code << std::endl;\n        #endif\n            if (i != children_.end())\n            {\n                children_.erase(i);\n                waitpid(sinfo->si_pid, &status, 0);\n            }\n            break;\n        }\n    }", "item_id": 0, "repo": "cristivlas/zerobugs", "file": "server/forked_server.h", "last_update_at": "2018-06-24T16:15:19+00:00", "question_id": "168b79695ed5d43bcb40a595fde3d855454980fa_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void sigchld(int, siginfo_t* sinfo, void*)\n    {\n        assert(sinfo);\n        assert(sinfo->si_signo == SIGCHLD);\n        int status = 0;\n        ext::hash_set<pid_t>::iterator i = children_.find(sinfo->si_pid);\n        switch (sinfo->si_code)\n        {\n        case CLD_EXITED:\n        case CLD_KILLED:\n        case CLD_DUMPED:\n        #if DEBUG\n            std::clog << __func__<< \": si_pid=\" << sinfo->si_pid;\n            std::clog << \" si_code=\" << sinfo->si_code << std::endl;\n        #endif\n            if (i != children_.end())\n            {\n                children_.erase(i);\n                waitpid(sinfo->si_pid, &status, 0);\n            }\n            break;\n        }\n"]]}
{"hexsha": "087acf4d89284af5607acd0152ce721584243ba5", "ext": "c", "lang": "C", "content": "int perl_eval(const char *code, char **result) {\n  SV* ret_sv = eval_pv(code, FALSE);\n  if (SvTRUE(ERRSV))\n  {\n    STRLEN len;\n    char *errmsg = SvPV(ERRSV, len);\n    *result = eperl_alloc(len+1);\n    memcpy(*result, errmsg, len+1);\n    return 0;\n  } else if (result != NULL) {\n    sv_to_json(ret_sv, result);\n  }\n  return 1;\n}", "item_id": 5, "repo": "waisbrot/erlang_perl", "file": "c_src/perl_drv.c", "last_update_at": "2018-06-02T18:47:17+00:00", "question_id": "087acf4d89284af5607acd0152ce721584243ba5_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int perl_eval(const char *code, char **result) {\n  SV* ret_sv = eval_pv(code, FALSE);\n  if (SvTRUE(ERRSV))\n  {\n    STRLEN len;\n    char *errmsg = SvPV(ERRSV, len);\n    *result = eperl_alloc(len+1);\n    memcpy(*result, errmsg, len+1);\n    return 0;\n  } else if (result != NULL) {\n    sv_to_json(ret_sv, result);\n  }\n  return 1;\n"]]}
{"hexsha": "01bd50efd8cfcab981b9784c6335cc672a115272", "ext": "h", "lang": "C", "content": "class AppObject \r\n{\r\npublic:\r\n\tAppObject() :  mesh(NULL),  cage(NULL), meshSelection(NULL), \r\n\t\t hasSdfFacets(false), refCount(new int(1)), m_myWo(NULL)\r\n\t{\r\n\t\t//fileSeparator = \"\\\\\";\r\n\t}\r\n\r\n\tvoid unloadMesh();\r\n\t\t\r\n\t~AppObject() \r\n\t{\r\n\t\t--(*refCount);\r\n\t\tif (*refCount == 0)\r\n\t\t{\r\n\t\t\tdelete mesh;\r\n\t\t\tdelete cage;\r\n\t\t\tdelete meshSelection;\r\n\t\t\tdelete refCount;\r\n\t\t}\r\n\t}", "item_id": 0, "repo": "hsiaoairplane/3d-watermark-lsd", "file": "AppObject.h", "last_update_at": "2018-07-20T02:44:11+00:00", "question_id": "01bd50efd8cfcab981b9784c6335cc672a115272_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class AppObject \r\n{\r\npublic:\r\n\tAppObject() :  mesh(NULL),  cage(NULL), meshSelection(NULL), \r\n\t\t hasSdfFacets(false), refCount(new int(1)), m_myWo(NULL)\r\n\t{\r\n\t\t//fileSeparator = \"\\\\\";\r\n\t}\r\n\r\n\tvoid unloadMesh();\r\n\t\t\r\n\t~AppObject() \r\n\t{\r\n\t\t--(*refCount);\r\n\t\tif (*refCount == 0)\r\n\t\t{\r\n\t\t\tdelete mesh;\r\n\t\t\tdelete cage;\r\n\t\t\tdelete meshSelection;\r\n\t\t\tdelete refCount;\r\n\t\t}\r\n"]]}
{"hexsha": "15c4552fd1af99b1fdb7d8a2dc39e8abcf921c68", "ext": "c", "lang": "C", "content": "static void files_plugin_start(struct plugin_t * plugin)\n{\n  struct file_server_t * file_server = plugin->data;\n\n  size_t cwd_capacity = 256;\n  char * cwd = malloc(cwd_capacity);\n\n  while (getcwd(cwd, cwd_capacity) == NULL) {\n    cwd_capacity *= 2;\n    cwd = realloc(cwd, cwd_capacity);\n  }\n\n  size_t cwd_length = strlen(cwd);\n\n  if (cwd_length + 1 >= cwd_capacity) {\n    cwd = realloc(cwd, cwd_capacity + 1);\n  }\n\n  cwd_length++;\n  cwd[cwd_length - 1] = '/';\n  cwd[cwd_length] = 0;\n\n  file_server->cwd = cwd;\n  file_server->cwd_length = cwd_length;\n\n  hash_table_init_with_string_keys(&file_server->open_files, open_file_removed_from_hash);\n  file_server->open_files_count = 0;\n\n  void * root = server_config_plugin_get(plugin->config_context, \"push_files\");\n  if (root) {\n    server_config_plugin_each(file_server, root, init_push_file);\n  }\n\n  log_append(plugin->log, LOG_INFO, \"Files plugin started\");\n}", "item_id": 7, "repo": "gregory144/prism-web-server", "file": "src/plugins/files/main.c", "last_update_at": "2018-09-25T05:02:17+00:00", "question_id": "15c4552fd1af99b1fdb7d8a2dc39e8abcf921c68_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void files_plugin_start(struct plugin_t * plugin)\n{\n  struct file_server_t * file_server = plugin->data;\n  size_t cwd_capacity = 256;\n  char * cwd = malloc(cwd_capacity);\n  while (getcwd(cwd, cwd_capacity) == NULL) {\n    cwd_capacity *= 2;\n    cwd = realloc(cwd, cwd_capacity);\n  }\n  size_t cwd_length = strlen(cwd);\n  if (cwd_length + 1 >= cwd_capacity) {\n    cwd = realloc(cwd, cwd_capacity + 1);\n  }\n  cwd_length++;\n  cwd[cwd_length - 1] = '/';\n  cwd[cwd_length] = 0;\n  file_server->cwd = cwd;\n  file_server->cwd_length = cwd_length;\n  hash_table_init_with_string_keys(&file_server->open_files, open_file_removed_from_hash);\n  file_server->open_files_count = 0;\n  void * root = server_config_plugin_get(plugin->config_context, \"push_files\");\n  if (root) {\n    server_config_plugin_each(file_server, root, init_push_file);\n  }\n  log_append(plugin->log, LOG_INFO, \"Files plugin started\");\n"]]}
{"hexsha": "6cd6842f459f98b6364b6a9620cda589ecd06443", "ext": "c", "lang": "C", "content": "TSS2_RC\niesys_MU_BYTE_array_Unmarshal(\n    const uint8_t *buffer,\n    size_t size,\n    size_t *offset,\n    size_t count,\n    BYTE *dst)\n{\n    LOG_TRACE(\"called: count=%zu buffer=%p size=%zu offset=%p dst=%p\",\n        count, buffer, size, offset, dst);\n    return_if_null(buffer, \"src=NULL\", TSS2_ESYS_RC_BAD_REFERENCE);\n\n    size_t offset_loc = (offset != NULL)? *offset : 0;\n    if (dst != NULL)\n        memset(dst, 0, sizeof(*dst));\n\n    if (count > size || size - count < offset_loc) {\n        LOG_ERROR(\"not enough space in target buffer\");\n        return TSS2_ESYS_RC_INSUFFICIENT_BUFFER;\n    }\n\n    if (dst != NULL)\n        memcpy(dst, &buffer[offset_loc], count);\n    offset_loc += count;\n\n    if (offset != NULL)\n        *offset = offset_loc;\n    return TSS2_RC_SUCCESS;\n}", "item_id": 1, "repo": "aqinwenky/tpm2-tss", "file": "src/tss2-esys/esys_mu.c", "last_update_at": "2018-04-11T13:56:07+00:00", "question_id": "6cd6842f459f98b6364b6a9620cda589ecd06443_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["TSS2_RC\niesys_MU_BYTE_array_Unmarshal(\n    const uint8_t *buffer,\n    size_t size,\n    size_t *offset,\n    size_t count,\n    BYTE *dst)\n{\n    LOG_TRACE(\"called: count=%zu buffer=%p size=%zu offset=%p dst=%p\",\n        count, buffer, size, offset, dst);\n    return_if_null(buffer, \"src=NULL\", TSS2_ESYS_RC_BAD_REFERENCE);\n    size_t offset_loc = (offset != NULL)? *offset : 0;\n    if (dst != NULL)\n        memset(dst, 0, sizeof(*dst));\n    if (count > size || size - count < offset_loc) {\n        LOG_ERROR(\"not enough space in target buffer\");\n        return TSS2_ESYS_RC_INSUFFICIENT_BUFFER;\n    }\n    if (dst != NULL)\n        memcpy(dst, &buffer[offset_loc], count);\n    offset_loc += count;\n    if (offset != NULL)\n        *offset = offset_loc;\n    return TSS2_RC_SUCCESS;\n"]]}
{"hexsha": "208c69870d617204421aac4073f3cc72fd1bab21", "ext": "c", "lang": "C", "content": "void __gfx_gen_pixels(int c, unsigned int w, unsigned char* pixels)\n{\n\tunsigned int x, y;\n\tuint8_t* fnt = gfx_font();\n\n\tif(c != 0 && w != 0)\n  {\n    for(y = 0; y < gfx_font_height; y++)\n    {\n      for(x = 0; x < gfx_font_width; x++)\n      {\n        if(fnt[c * gfx_font_height + y] >> (7 - x) & 1)\n        {\n          pixels[x + (y * w)] = 1;\n        }\n      }\n    }\n  }\n}", "item_id": 0, "repo": "RelativisticMechanic/stdgfx", "file": "libgfx/gfx_putc.c", "last_update_at": "2018-03-15T10:15:59+00:00", "question_id": "208c69870d617204421aac4073f3cc72fd1bab21_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void __gfx_gen_pixels(int c, unsigned int w, unsigned char* pixels)\n{\n\tunsigned int x, y;\n\tuint8_t* fnt = gfx_font();\n\tif(c != 0 && w != 0)\n  {\n    for(y = 0; y < gfx_font_height; y++)\n    {\n      for(x = 0; x < gfx_font_width; x++)\n      {\n        if(fnt[c * gfx_font_height + y] >> (7 - x) & 1)\n        {\n          pixels[x + (y * w)] = 1;\n        }\n      }\n    }\n  }\n"]]}
{"hexsha": "887339108bfe36faf63e5b4598e4a368dc3af5df", "ext": "c", "lang": "C", "content": "void matrusseV2_2(matrix_t * A, matrix_t * B, matrix_t * C, int k) {\n\n    uint32_t m = A->m;\n    uint32_t blocksize = TAILLE_BLOC;\n    uint32_t l = A->n;\n    uint32_t n = B->nbColonneInt;\n    uint32_t nbits = B->n;\n\n    for (int start = 0; start < m/blocksize; ++start) {\n        //progressBar(start,m/blocksize-1);\n\n        for (int i = 0; i < l/k; ++i) {\n            //alocating table of 2^k * B->nbColonneInt\n            uint64_t * T = malloc((n*sizeof(uint64_t))<<k);\n            matrix_t * Bbloc = getBloc(B, i*k, i+k);\n            fillTable2(T, Bbloc, k, k);\n            for (int s = 0; s < blocksize; ++s) {\n                uint64_t j = start*blocksize + s;\n                int64_t id = extract(A,j, k*i, k);\n                uint64_t * Tline = T+id*n;\n                xorMatrixRow(C, j, Tline);\n            }\n            freeBloc(Bbloc);\n            free(T);\n        }\n\n        int kReste = l%k;\n        if (kReste != 0) {\n            calculResteK(A, B, C, kReste, n, l, blocksize, start*blocksize);\n        }\n    }\n\n    uint32_t blocksizeReste = m%blocksize;\n    if(blocksizeReste != 0) {\n\n        int start = m - blocksizeReste;\n\n        for (int i = 0; i < l/k; ++i) {\n            //alocating table of 2^k * B->nbColonneInt\n            uint64_t * T = malloc((n*sizeof(uint64_t))<<k);\n            matrix_t * Bbloc = getBloc(B, i*k, i+k);\n            fillTable(T, Bbloc, k);\n            for (int s = 0; s < blocksizeReste; ++s) { //scanning throught the last block\n                uint64_t j = start + s;\n                int64_t id = extract(A,j, k*i, k);\n                uint64_t * Tline = T+id*n;\n                xorMatrixRow(C, j, Tline);\n            }\n            free(Bbloc);\n            Bbloc = NULL;\n            free(T);\n            T = NULL;\n        }\n        uint32_t kReste = l%k;\n        if (kReste != 0) {\n            //not multiplying by blocksize because start is already the beginning of the last bloc\n            calculResteK(A, B, C, kReste, n, l, blocksizeReste, start);\n        }\n    }\n}", "item_id": 5, "repo": "Drapsag74/matrusse", "file": "src/fourRussianAlgorithmV2.c", "last_update_at": "2018-12-14T14:37:48+00:00", "question_id": "887339108bfe36faf63e5b4598e4a368dc3af5df_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void matrusseV2_2(matrix_t * A, matrix_t * B, matrix_t * C, int k) {\n    uint32_t m = A->m;\n    uint32_t blocksize = TAILLE_BLOC;\n    uint32_t l = A->n;\n    uint32_t n = B->nbColonneInt;\n    uint32_t nbits = B->n;\n    for (int start = 0; start < m/blocksize; ++start) {\n        //progressBar(start,m/blocksize-1);\n        for (int i = 0; i < l/k; ++i) {\n            //alocating table of 2^k * B->nbColonneInt\n            uint64_t * T = malloc((n*sizeof(uint64_t))<<k);\n            matrix_t * Bbloc = getBloc(B, i*k, i+k);\n            fillTable2(T, Bbloc, k, k);\n            for (int s = 0; s < blocksize; ++s) {\n                uint64_t j = start*blocksize + s;\n                int64_t id = extract(A,j, k*i, k);\n                uint64_t * Tline = T+id*n;\n                xorMatrixRow(C, j, Tline);\n            }\n            freeBloc(Bbloc);\n            free(T);\n        }\n        int kReste = l%k;\n        if (kReste != 0) {\n            calculResteK(A, B, C, kReste, n, l, blocksize, start*blocksize);\n        }\n    }\n    uint32_t blocksizeReste = m%blocksize;\n    if(blocksizeReste != 0) {\n        int start = m - blocksizeReste;\n        for (int i = 0; i < l/k; ++i) {\n            //alocating table of 2^k * B->nbColonneInt\n            uint64_t * T = malloc((n*sizeof(uint64_t))<<k);\n            matrix_t * Bbloc = getBloc(B, i*k, i+k);\n            fillTable(T, Bbloc, k);\n            for (int s = 0; s < blocksizeReste; ++s) { //scanning throught the last block\n                uint64_t j = start + s;\n                int64_t id = extract(A,j, k*i, k);\n                uint64_t * Tline = T+id*n;\n                xorMatrixRow(C, j, Tline);\n            }\n            free(Bbloc);\n            Bbloc = NULL;\n            free(T);\n            T = NULL;\n        }\n        uint32_t kReste = l%k;\n        if (kReste != 0) {\n            //not multiplying by blocksize because start is already the beginning of the last bloc\n            calculResteK(A, B, C, kReste, n, l, blocksizeReste, start);\n        }\n    }\n"]]}
{"hexsha": "45b4e415a1ae5f8837cef7ee0b35c3debdb4754c", "ext": "c", "lang": "C", "content": "int mystricmp(const char *s1, const char *s2)\r\n{\r\n   int c1, c2;\r\n\r\n   do {\r\n      c1 = mytolower(*(s1++));\r\n      c2 = mytolower(*(s2++));\r\n   } while ((c1) && (c1 == c2));\r\n\r\n   return c1 - c2;\r\n}", "item_id": 0, "repo": "kamil-cc/allegro-bcc", "file": "docs/src/makedoc/makemisc.c", "last_update_at": "2018-04-21T12:43:01+00:00", "question_id": "45b4e415a1ae5f8837cef7ee0b35c3debdb4754c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int mystricmp(const char *s1, const char *s2)\r\n{\r\n   int c1, c2;\r\n\r\n   do {\r\n      c1 = mytolower(*(s1++));\r\n      c2 = mytolower(*(s2++));\r\n   } while ((c1) && (c1 == c2));\r\n\r\n   return c1 - c2;\r\n"]]}
{"hexsha": "32040ace00ea2431a18428dca5c34c0c4ebde10c", "ext": "c", "lang": "C", "content": "int hypfs_vm_create_files(struct dentry *root)\n{\n\tstruct dentry *dir, *file;\n\tstruct diag2fc_data *data;\n\tunsigned int count = 0;\n\tint rc, i;\n\n\tdata = diag2fc_store(guest_query, &count, 0);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t/* Hpervisor Info */\n\tdir = hypfs_mkdir(root, \"hyp\");\n\tif (IS_ERR(dir)) {\n\t\trc = PTR_ERR(dir);\n\t\tgoto failed;\n\t}\n\tfile = hypfs_create_str(dir, \"type\", \"z/VM Hypervisor\");\n\tif (IS_ERR(file)) {\n\t\trc = PTR_ERR(file);\n\t\tgoto failed;\n\t}\n\n\t/* physical cpus */\n\tdir = hypfs_mkdir(root, \"cpus\");\n\tif (IS_ERR(dir)) {\n\t\trc = PTR_ERR(dir);\n\t\tgoto failed;\n\t}\n\tfile = hypfs_create_u64(dir, \"count\", data->lcpus);\n\tif (IS_ERR(file)) {\n\t\trc = PTR_ERR(file);\n\t\tgoto failed;\n\t}\n\n\t/* guests */\n\tdir = hypfs_mkdir(root, \"systems\");\n\tif (IS_ERR(dir)) {\n\t\trc = PTR_ERR(dir);\n\t\tgoto failed;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\trc = hpyfs_vm_create_guest(dir, &(data[i]));\n\t\tif (rc)\n\t\t\tgoto failed;\n\t}\n\tdiag2fc_free(data);\n\treturn 0;\n\nfailed:\n\tdiag2fc_free(data);\n\treturn rc;\n}", "item_id": 3, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/arch/s390/hypfs/hypfs_vm.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "32040ace00ea2431a18428dca5c34c0c4ebde10c_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int hypfs_vm_create_files(struct dentry *root)\n{\n\tstruct dentry *dir, *file;\n\tstruct diag2fc_data *data;\n\tunsigned int count = 0;\n\tint rc, i;\n\tdata = diag2fc_store(guest_query, &count, 0);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\t/* Hpervisor Info */\n\tdir = hypfs_mkdir(root, \"hyp\");\n\tif (IS_ERR(dir)) {\n\t\trc = PTR_ERR(dir);\n\t\tgoto failed;\n\t}\n\tfile = hypfs_create_str(dir, \"type\", \"z/VM Hypervisor\");\n\tif (IS_ERR(file)) {\n\t\trc = PTR_ERR(file);\n\t\tgoto failed;\n\t}\n\t/* physical cpus */\n\tdir = hypfs_mkdir(root, \"cpus\");\n\tif (IS_ERR(dir)) {\n\t\trc = PTR_ERR(dir);\n\t\tgoto failed;\n\t}\n\tfile = hypfs_create_u64(dir, \"count\", data->lcpus);\n\tif (IS_ERR(file)) {\n\t\trc = PTR_ERR(file);\n\t\tgoto failed;\n\t}\n\t/* guests */\n\tdir = hypfs_mkdir(root, \"systems\");\n\tif (IS_ERR(dir)) {\n\t\trc = PTR_ERR(dir);\n\t\tgoto failed;\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\trc = hpyfs_vm_create_guest(dir, &(data[i]));\n\t\tif (rc)\n\t\t\tgoto failed;\n\t}\n\tdiag2fc_free(data);\n\treturn 0;\nfailed:\n\tdiag2fc_free(data);\n\treturn rc;\n"]]}
{"hexsha": "be5eab08edc7d9a05186969e889c309ea32eec48", "ext": "h", "lang": "C", "content": "class SensorData : public Streamable\n{\npublic:\n  ENUM(Sensor,\n    gyroX,\n    gyroY,\n    gyroZ,\n    accX,\n    accY,\n    accZ,\n    batteryLevel,\n    fsrLFL,     //the feetsensors of the Nao-Robot\n    fsrLFR,\n    fsrLBL,\n    fsrLBR,\n    fsrRFL,\n    fsrRFR,\n    fsrRBL,\n    fsrRBR,\n    usL,\n    usR,\n    angleX,\n    angleY\n  );\n\n  enum\n  {\n    off = JointData::off /**< A special value to indicate that the sensor is missing. */\n  };\n\n  ENUM(UsActuatorMode,\n    leftToLeft,\n    leftToRight,\n    rightToLeft,\n    rightToRight\n  );\n\n  float data[numOfSensors]; /**< The data of all sensors. */\n  float currents[JointData::numOfJoints]; /**< The currents of all motors. */\n  unsigned char temperatures[JointData::numOfJoints]; /**< The temperature of all motors. */\n  unsigned timeStamp; /**< The time when the sensor data was received. */\n\n  UsActuatorMode usActuatorMode; /**< The ultrasonice measure method which was used for measuring \\c data[usL] and \\c data[usR]. */\n  unsigned usTimeStamp; /**< The time when the ultrasonic measurements were taken. */\n\n  /**\n  * Default constructor.\n  */\n  SensorData() : timeStamp(0), usActuatorMode(leftToLeft), usTimeStamp(0)\n  {\n    for(int i = 0; i < numOfSensors; ++i)\n      data[i] = off;\n    for(int i = 0; i < JointData::numOfJoints; ++i)\n      currents[i] = temperatures[i] = 0;\n  }", "item_id": 0, "repo": "ToyotaResearchInstitute/rad-robot", "file": "Modules-old/bhwalk/Representations/Infrastructure/SensorData.h", "last_update_at": "2018-09-22T10:31:27+00:00", "question_id": "be5eab08edc7d9a05186969e889c309ea32eec48_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class SensorData : public Streamable\n{\npublic:\n  ENUM(Sensor,\n    gyroX,\n    gyroY,\n    gyroZ,\n    accX,\n    accY,\n    accZ,\n    batteryLevel,\n    fsrLFL,     //the feetsensors of the Nao-Robot\n    fsrLFR,\n    fsrLBL,\n    fsrLBR,\n    fsrRFL,\n    fsrRFR,\n    fsrRBL,\n    fsrRBR,\n    usL,\n    usR,\n    angleX,\n    angleY\n  );\n  enum\n  {\n    off = JointData::off /**< A special value to indicate that the sensor is missing. */\n  };\n  ENUM(UsActuatorMode,\n    leftToLeft,\n    leftToRight,\n    rightToLeft,\n    rightToRight\n  );\n  float data[numOfSensors]; /**< The data of all sensors. */\n  float currents[JointData::numOfJoints]; /**< The currents of all motors. */\n  unsigned char temperatures[JointData::numOfJoints]; /**< The temperature of all motors. */\n  unsigned timeStamp; /**< The time when the sensor data was received. */\n  UsActuatorMode usActuatorMode; /**< The ultrasonice measure method which was used for measuring \\c data[usL] and \\c data[usR]. */\n  unsigned usTimeStamp; /**< The time when the ultrasonic measurements were taken. */\n  /**\n  * Default constructor.\n  */\n  SensorData() : timeStamp(0), usActuatorMode(leftToLeft), usTimeStamp(0)\n  {\n    for(int i = 0; i < numOfSensors; ++i)\n      data[i] = off;\n    for(int i = 0; i < JointData::numOfJoints; ++i)\n      currents[i] = temperatures[i] = 0;\n"]]}
{"hexsha": "2abd326fe504166fb44429f64f93ae57aadcd94f", "ext": "h", "lang": "C", "content": "class MenuLayer2 : public CCLayer\n{\n\tpublic :\n\n\t\tCREATE_FUNC ( MenuLayer2 );\n\n\tprotected :\n\n\t\tvirtual KDbool\t\tinit ( KDvoid );\n\n\t\tKDvoid\t\t\t\tmenuCallback        ( CCObject* pSender );\n\t\tKDvoid\t\t\t\tmenuCallbackOpacity ( CCObject* pSender );\n\t\tKDvoid\t\t\t\tmenuCallbackAlign   ( CCObject* pSender );\n\n\t\tKDvoid\t\t\t\talignMenusH ( KDvoid );\n\t\tKDvoid\t\t\t\talignMenusV ( KDvoid );\n\n\tprotected :\n\n\t\tCCPoint\t\t\t\tm_tCenteredMenu;\n\t\tKDbool\t\t\t\tm_bAlignedH; \n}", "item_id": 1, "repo": "mcodegeeks/OpenKODE-Framework", "file": "03_Tutorial/T02_XMCocos2D/Source/Test/TestMenu.h", "last_update_at": "2018-06-18T10:32:53+00:00", "question_id": "2abd326fe504166fb44429f64f93ae57aadcd94f_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class MenuLayer2 : public CCLayer\n{\n\tpublic :\n\t\tCREATE_FUNC ( MenuLayer2 );\n\tprotected :\n\t\tvirtual KDbool\t\tinit ( KDvoid );\n\t\tKDvoid\t\t\t\tmenuCallback        ( CCObject* pSender );\n\t\tKDvoid\t\t\t\tmenuCallbackOpacity ( CCObject* pSender );\n\t\tKDvoid\t\t\t\tmenuCallbackAlign   ( CCObject* pSender );\n\t\tKDvoid\t\t\t\talignMenusH ( KDvoid );\n\t\tKDvoid\t\t\t\talignMenusV ( KDvoid );\n\tprotected :\n\t\tCCPoint\t\t\t\tm_tCenteredMenu;\n\t\tKDbool\t\t\t\tm_bAlignedH; \n"]]}
{"hexsha": "f8e559e0665135bd935b5e3a04fe8fe495abe150", "ext": "c", "lang": "C", "content": "void SimonEncrypt96(uint64_t *SR, uint64_t *SL, const uint64_t *k)\n{\n\tuint64_t x = SL[0]; uint64_t y = SR[0];\n\tuint64_t tmp = 0;\n\tint i;\n\n\tfor (i = 0; i < 52; i++)\n\t{\n\t\ttmp = x;\n\t\tx = y ^ ROTL2(1, x, 48) & ROTL2(8, x, 48) ^ ROTL2(2, x, 48) ^ k[i];\n\t\ty = tmp;\n\t};\n\tSL[0] = x & 0xffffffffffff; SR[0] = y & 0xffffffffffff;\n}", "item_id": 4, "repo": "iadgov/simon-speck-supercop", "file": "crypto_aead/simonjambu128v2/ref/Simon.c", "last_update_at": "2018-03-09T14:52:25+00:00", "question_id": "f8e559e0665135bd935b5e3a04fe8fe495abe150_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void SimonEncrypt96(uint64_t *SR, uint64_t *SL, const uint64_t *k)\n{\n\tuint64_t x = SL[0]; uint64_t y = SR[0];\n\tuint64_t tmp = 0;\n\tint i;\n\tfor (i = 0; i < 52; i++)\n\t{\n\t\ttmp = x;\n\t\tx = y ^ ROTL2(1, x, 48) & ROTL2(8, x, 48) ^ ROTL2(2, x, 48) ^ k[i];\n\t\ty = tmp;\n\t};\n\tSL[0] = x & 0xffffffffffff; SR[0] = y & 0xffffffffffff;\n"]]}
{"hexsha": "7c7f720cb2b6d920b5eee25af711b5faaf6765bb", "ext": "c", "lang": "C", "content": "struct gv *gvLoadByQuery(struct sqlConnection *conn, char *query)\n/* Load all gv from table that satisfy the query given.  \n * Where query is of the form 'select * from example where something=something'\n * or 'select example.* from example, anotherTable where example.something = \n * anotherTable.something'.\n * Dispose of this with gvFreeList(). */\n{\nstruct gv *list = NULL, *el;\nstruct sqlResult *sr;\nchar **row;\n\nsr = sqlGetResult(conn, query);\nwhile ((row = sqlNextRow(sr)) != NULL)\n    {\n    el = gvLoad(row);\n    slAddHead(&list, el);\n    }\nslReverse(&list);\nsqlFreeResult(&sr);\nreturn list;\n}", "item_id": 4, "repo": "bowhan/kent", "file": "src/hg/lib/gv.c", "last_update_at": "2018-03-14T22:19:20+00:00", "question_id": "7c7f720cb2b6d920b5eee25af711b5faaf6765bb_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct gv *gvLoadByQuery(struct sqlConnection *conn, char *query)\n/* Load all gv from table that satisfy the query given.  \n * Where query is of the form 'select * from example where something=something'\n * or 'select example.* from example, anotherTable where example.something = \n * anotherTable.something'.\n * Dispose of this with gvFreeList(). */\n{\nstruct gv *list = NULL, *el;\nstruct sqlResult *sr;\nchar **row;\nsr = sqlGetResult(conn, query);\nwhile ((row = sqlNextRow(sr)) != NULL)\n    {\n    el = gvLoad(row);\n    slAddHead(&list, el);\n    }\nslReverse(&list);\nsqlFreeResult(&sr);\nreturn list;\n"]]}
{"hexsha": "a8c52d29ccb5789358b670abeb5ef02944bc4aca", "ext": "c", "lang": "C", "content": "int qmi_set_wds_get_current_settings_request(struct qmi_msg *msg, struct qmi_wds_get_current_settings_request *req)\n{\n\tqmi_init_request_message(msg, QMI_SERVICE_WDS);\n\tmsg->svc.message = cpu_to_le16(0x002D);\n\n\tif (req->set.requested_settings) {\n\t\tvoid *buf;\n\t\tunsigned int ofs;\n\n\t\t__qmi_alloc_reset();\n\t\tput_tlv_var(uint32_t, cpu_to_le32(req->data.requested_settings), 4);\n\n\t\tbuf = __qmi_get_buf(&ofs);\n\t\ttlv_new(msg, 0x10, ofs, buf);\n\t}\n\n\treturn 0;\n}", "item_id": 18, "repo": "ECRS/Asus-RT-N16", "file": "release/src/router/uqmi/qmi-message-wds.c", "last_update_at": "2018-08-21T03:43:31+00:00", "question_id": "a8c52d29ccb5789358b670abeb5ef02944bc4aca_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int qmi_set_wds_get_current_settings_request(struct qmi_msg *msg, struct qmi_wds_get_current_settings_request *req)\n{\n\tqmi_init_request_message(msg, QMI_SERVICE_WDS);\n\tmsg->svc.message = cpu_to_le16(0x002D);\n\tif (req->set.requested_settings) {\n\t\tvoid *buf;\n\t\tunsigned int ofs;\n\t\t__qmi_alloc_reset();\n\t\tput_tlv_var(uint32_t, cpu_to_le32(req->data.requested_settings), 4);\n\t\tbuf = __qmi_get_buf(&ofs);\n\t\ttlv_new(msg, 0x10, ofs, buf);\n\t}\n\treturn 0;\n"]]}
{"hexsha": "7951df687eec80e44c89cacad8ffbf2d7048f11d", "ext": "c", "lang": "C", "content": "int mal_routing_register_consumer_pubsub_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_register_ack,\n    mal_routing_on_message_fn *on_deregister_ack,\n    mal_routing_on_message_fn *on_notify) {\n  clog_info(mal_logger, \" *** mal_routing_register_consumer_pubsub_handler: %hd %hhd %hd %hd\\n\", area, area_version, service, operation);\n\n  // Allocates a new structure and initialize it\n  mal_routing_handler_t *handler = mal_routing_new_handler(MAL_ACTOR_CONSUMER_PUBSUB_HANDLER, area, area_version, service, operation);\n  if (handler == NULL) return -1;\n\n  handler->spec.consumer_pubsub_handler.on_register_ack = on_register_ack;\n  handler->spec.consumer_pubsub_handler.on_deregister_ack = on_deregister_ack;\n  handler->spec.consumer_pubsub_handler.on_notify = on_notify;\n  return mal_routing_register_handler(mal_routing, handler);\n}", "item_id": 13, "repo": "georgeslabreche/ccsdsmo-malc", "file": "mal/src/mal_routing.c", "last_update_at": "2018-01-27T00:46:04+00:00", "question_id": "7951df687eec80e44c89cacad8ffbf2d7048f11d_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int mal_routing_register_consumer_pubsub_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_register_ack,\n    mal_routing_on_message_fn *on_deregister_ack,\n    mal_routing_on_message_fn *on_notify) {\n  clog_info(mal_logger, \" *** mal_routing_register_consumer_pubsub_handler: %hd %hhd %hd %hd\\n\", area, area_version, service, operation);\n  // Allocates a new structure and initialize it\n  mal_routing_handler_t *handler = mal_routing_new_handler(MAL_ACTOR_CONSUMER_PUBSUB_HANDLER, area, area_version, service, operation);\n  if (handler == NULL) return -1;\n  handler->spec.consumer_pubsub_handler.on_register_ack = on_register_ack;\n  handler->spec.consumer_pubsub_handler.on_deregister_ack = on_deregister_ack;\n  handler->spec.consumer_pubsub_handler.on_notify = on_notify;\n  return mal_routing_register_handler(mal_routing, handler);\n"]]}
{"hexsha": "dcf766ae070622959503b15bfca548995f80dcaf", "ext": "c", "lang": "C", "content": "static int stxReadThread(StxThread* thread, EmbFile* file)\n{\n    int j, colorNameLength, sectionNameLength;\n    int somethingSomething, somethingSomething2, somethingElse, numberOfOtherDescriptors; /* TODO: determine what these represent */\n    int codeLength = 0;\n    char* codeBuff = 0;\n    char* codeNameBuff = 0;\n    char* sectionNameBuff = 0;\n    EmbColor col;\n    unsigned char whatIsthis; /* TODO: determine what this represents */\n\n    if(!thread) { embLog_error(\"format-stx.c stxReadThread(), thread argument is null\\n\"); return 0; }\n    if(!file) { embLog_error(\"format-stx.c stxReadThread(), file argument is null\\n\"); return 0; }\n\n    codeLength = binaryReadUInt8(file);\n    codeBuff = (char*)malloc(codeLength);\n    if(!codeBuff) { embLog_error(\"format-stx.c stxReadThread(), unable to allocate memory for codeBuff\\n\"); return 0; }\n    binaryReadBytes(file, (unsigned char*)codeBuff, codeLength); /* TODO: check return value */\n    thread->colorCode = codeBuff;\n    colorNameLength = binaryReadUInt8(file);\n    codeNameBuff = (char*)malloc(colorNameLength);\n    if(!codeNameBuff) { embLog_error(\"format-stx.c stxReadThread(), unable to allocate memory for codeNameBuff\\n\"); return 0; }\n    binaryReadBytes(file, (unsigned char*)codeNameBuff, colorNameLength); /* TODO: check return value */\n    thread->colorName = codeNameBuff;\n\n    col.r = binaryReadUInt8(file);\n    col.b = binaryReadUInt8(file);\n    col.g = binaryReadUInt8(file);\n\n    whatIsthis = binaryReadUInt8(file);\n\n    sectionNameLength = binaryReadUInt8(file);\n    sectionNameBuff = (char*)malloc(sectionNameLength);\n    if(!sectionNameBuff) { embLog_error(\"format-stx.c stxReadThread(), unable to allocate memory for sectionNameBuff\\n\"); return 0; }\n    binaryReadBytes(file, (unsigned char*)sectionNameBuff, sectionNameLength); /* TODO: check return value */\n    thread->sectionName = sectionNameBuff;\n\n    somethingSomething = binaryReadInt32(file);\n    somethingSomething2 = binaryReadInt32(file);\n    somethingElse = binaryReadInt32(file);\n    numberOfOtherDescriptors = binaryReadInt16(file);\n\n    thread->subDescriptors = (SubDescriptor*)malloc(sizeof(SubDescriptor) * numberOfOtherDescriptors);\n    if(!thread->subDescriptors) { embLog_error(\"format-stx.c stxReadThread(), unable to allocate memory for thread->subDescriptors\\n\"); return 0; }\n    for(j = 0; j < numberOfOtherDescriptors; j++)\n    {\n        SubDescriptor sd;\n        char* subCodeBuff, *subColorNameBuff;\n        int subCodeLength, subColorNameLength;\n\n        sd.someNum = binaryReadInt16(file);\n        /* Debug.Assert(sd.someNum == 1); TODO: review */\n        sd.someInt = binaryReadInt32(file);\n        subCodeLength = binaryReadUInt8(file);\n        subCodeBuff = (char*)malloc(subCodeLength);\n        if(!subCodeBuff) { embLog_error(\"format-stx.c stxReadThread(), unable to allocate memory for subCodeBuff\\n\"); return 0; }\n        binaryReadBytes(file, (unsigned char*)subCodeBuff, subCodeLength); /* TODO: check return value */\n        sd.colorCode = subCodeBuff;\n        subColorNameLength = binaryReadUInt8(file);\n        subColorNameBuff = (char*)malloc(subColorNameLength);\n        if(!subColorNameBuff) { embLog_error(\"format-stx.c stxReadThread(), unable to allocate memory for subColorNameBuff\\n\"); return 0; }\n        binaryReadBytes(file, (unsigned char*)subColorNameBuff, subColorNameLength); /* TODO: check return value */\n        sd.colorName = subColorNameBuff;\n        sd.someOtherInt = binaryReadInt32(file);\n        thread->subDescriptors[j] = sd;\n    }\n    return 1;\n}", "item_id": 0, "repo": "Drahflow/Embroidermodder", "file": "libembroidery/format-stx.c", "last_update_at": "2018-08-13T14:56:33+00:00", "question_id": "dcf766ae070622959503b15bfca548995f80dcaf_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int stxReadThread(StxThread* thread, EmbFile* file)\n{\n    int j, colorNameLength, sectionNameLength;\n    int somethingSomething, somethingSomething2, somethingElse, numberOfOtherDescriptors; /* TODO: determine what these represent */\n    int codeLength = 0;\n    char* codeBuff = 0;\n    char* codeNameBuff = 0;\n    char* sectionNameBuff = 0;\n    EmbColor col;\n    unsigned char whatIsthis; /* TODO: determine what this represents */\n    if(!thread) { embLog_error(\"format-stx.c stxReadThread(), thread argument is null\\n\"); return 0; }\n    if(!file) { embLog_error(\"format-stx.c stxReadThread(), file argument is null\\n\"); return 0; }\n    codeLength = binaryReadUInt8(file);\n    codeBuff = (char*)malloc(codeLength);\n    if(!codeBuff) { embLog_error(\"format-stx.c stxReadThread(), unable to allocate memory for codeBuff\\n\"); return 0; }\n    binaryReadBytes(file, (unsigned char*)codeBuff, codeLength); /* TODO: check return value */\n    thread->colorCode = codeBuff;\n    colorNameLength = binaryReadUInt8(file);\n    codeNameBuff = (char*)malloc(colorNameLength);\n    if(!codeNameBuff) { embLog_error(\"format-stx.c stxReadThread(), unable to allocate memory for codeNameBuff\\n\"); return 0; }\n    binaryReadBytes(file, (unsigned char*)codeNameBuff, colorNameLength); /* TODO: check return value */\n    thread->colorName = codeNameBuff;\n    col.r = binaryReadUInt8(file);\n    col.b = binaryReadUInt8(file);\n    col.g = binaryReadUInt8(file);\n    whatIsthis = binaryReadUInt8(file);\n    sectionNameLength = binaryReadUInt8(file);\n    sectionNameBuff = (char*)malloc(sectionNameLength);\n    if(!sectionNameBuff) { embLog_error(\"format-stx.c stxReadThread(), unable to allocate memory for sectionNameBuff\\n\"); return 0; }\n    binaryReadBytes(file, (unsigned char*)sectionNameBuff, sectionNameLength); /* TODO: check return value */\n    thread->sectionName = sectionNameBuff;\n    somethingSomething = binaryReadInt32(file);\n    somethingSomething2 = binaryReadInt32(file);\n    somethingElse = binaryReadInt32(file);\n    numberOfOtherDescriptors = binaryReadInt16(file);\n    thread->subDescriptors = (SubDescriptor*)malloc(sizeof(SubDescriptor) * numberOfOtherDescriptors);\n    if(!thread->subDescriptors) { embLog_error(\"format-stx.c stxReadThread(), unable to allocate memory for thread->subDescriptors\\n\"); return 0; }\n    for(j = 0; j < numberOfOtherDescriptors; j++)\n    {\n        SubDescriptor sd;\n        char* subCodeBuff, *subColorNameBuff;\n        int subCodeLength, subColorNameLength;\n        sd.someNum = binaryReadInt16(file);\n        /* Debug.Assert(sd.someNum == 1); TODO: review */\n        sd.someInt = binaryReadInt32(file);\n        subCodeLength = binaryReadUInt8(file);\n        subCodeBuff = (char*)malloc(subCodeLength);\n        if(!subCodeBuff) { embLog_error(\"format-stx.c stxReadThread(), unable to allocate memory for subCodeBuff\\n\"); return 0; }\n        binaryReadBytes(file, (unsigned char*)subCodeBuff, subCodeLength); /* TODO: check return value */\n        sd.colorCode = subCodeBuff;\n        subColorNameLength = binaryReadUInt8(file);\n        subColorNameBuff = (char*)malloc(subColorNameLength);\n        if(!subColorNameBuff) { embLog_error(\"format-stx.c stxReadThread(), unable to allocate memory for subColorNameBuff\\n\"); return 0; }\n        binaryReadBytes(file, (unsigned char*)subColorNameBuff, subColorNameLength); /* TODO: check return value */\n        sd.colorName = subColorNameBuff;\n        sd.someOtherInt = binaryReadInt32(file);\n        thread->subDescriptors[j] = sd;\n    }\n    return 1;\n"]]}
{"hexsha": "36cd278e68c04b98eb1ffa068e9fe4ba097cb7a9", "ext": "c", "lang": "C", "content": "static void\n_virtio_scsi_dev_unregister_cb(void *io_device)\n{\n\tstruct virtio_scsi_dev *svdev = io_device;\n\tstruct virtio_dev *vdev = &svdev->vdev;\n\tbool finish_module;\n\tbdev_virtio_remove_cb remove_cb;\n\tvoid *remove_ctx;\n\n\tassert(spdk_ring_count(svdev->ctrlq_ring) == 0);\n\tspdk_ring_free(svdev->ctrlq_ring);\n\tspdk_poller_unregister(&svdev->mgmt_poller);\n\n\tvirtio_dev_release_queue(vdev, VIRTIO_SCSI_EVENTQ);\n\tvirtio_dev_release_queue(vdev, VIRTIO_SCSI_CONTROLQ);\n\n\tvirtio_dev_stop(vdev);\n\tvirtio_dev_destruct(vdev);\n\n\tpthread_mutex_lock(&g_virtio_scsi_mutex);\n\tTAILQ_REMOVE(&g_virtio_scsi_devs, svdev, tailq);\n\tpthread_mutex_unlock(&g_virtio_scsi_mutex);\n\n\tremove_cb = svdev->remove_cb;\n\tremove_ctx = svdev->remove_ctx;\n\tspdk_dma_free(svdev->eventq_ios);\n\tfree(svdev);\n\n\tif (remove_cb) {\n\t\tremove_cb(remove_ctx, 0);\n\t}\n\n\tfinish_module = TAILQ_EMPTY(&g_virtio_scsi_devs);\n\n\tif (g_bdev_virtio_finish && finish_module) {\n\t\tspdk_bdev_module_finish_done();\n\t}\n}", "item_id": 53, "repo": "mlx3im/spdk_test", "file": "lib/bdev/virtio/bdev_virtio_scsi.c", "last_update_at": "2018-11-21T11:05:28+00:00", "question_id": "36cd278e68c04b98eb1ffa068e9fe4ba097cb7a9_53", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\n_virtio_scsi_dev_unregister_cb(void *io_device)\n{\n\tstruct virtio_scsi_dev *svdev = io_device;\n\tstruct virtio_dev *vdev = &svdev->vdev;\n\tbool finish_module;\n\tbdev_virtio_remove_cb remove_cb;\n\tvoid *remove_ctx;\n\tassert(spdk_ring_count(svdev->ctrlq_ring) == 0);\n\tspdk_ring_free(svdev->ctrlq_ring);\n\tspdk_poller_unregister(&svdev->mgmt_poller);\n\tvirtio_dev_release_queue(vdev, VIRTIO_SCSI_EVENTQ);\n\tvirtio_dev_release_queue(vdev, VIRTIO_SCSI_CONTROLQ);\n\tvirtio_dev_stop(vdev);\n\tvirtio_dev_destruct(vdev);\n\tpthread_mutex_lock(&g_virtio_scsi_mutex);\n\tTAILQ_REMOVE(&g_virtio_scsi_devs, svdev, tailq);\n\tpthread_mutex_unlock(&g_virtio_scsi_mutex);\n\tremove_cb = svdev->remove_cb;\n\tremove_ctx = svdev->remove_ctx;\n\tspdk_dma_free(svdev->eventq_ios);\n\tfree(svdev);\n\tif (remove_cb) {\n\t\tremove_cb(remove_ctx, 0);\n\t}\n\tfinish_module = TAILQ_EMPTY(&g_virtio_scsi_devs);\n\tif (g_bdev_virtio_finish && finish_module) {\n\t\tspdk_bdev_module_finish_done();\n\t}\n"]]}
{"hexsha": "b16dbb2c1d4e543c948df336f8715ff2abf06f34", "ext": "c", "lang": "C", "content": "static int ftm_check_validation(void)\n{\n\tunsigned long long ptn = 0;\n\tunsigned int size = FTM_ROUND_TO_PAGE(strlen(FTM_MAGIC_STRING) + 1, FTM_PAGE_MASK);\n\tunsigned char data[size];\n\n\tif (ftm_valid > FTM_NOT_MATCHED_MAGIC)\n\t\treturn NO_ERROR;\n\n\tif (!target_is_emmc_boot()) {\n\t\tdprintf(CRITICAL, \"%s: target is not emmc boot\\n\", __func__);\n\t\tgoto invalidated;\n\t}\n\n\tptn = ftm_get_partition_offset();\n\n\tif (ptn == 0) {\n\t\tdprintf(CRITICAL, \"%s: failed get offset\\n\", __func__);\n\t\tgoto invalidated;\n\t}\n\n\t/* read first page from ftm partition */\n\tif (mmc_read(ptn + (LGFTM_MAGIC_ITEM * FTM_PAGE_SIZE), (unsigned int *)data, size)) {\n\t\tdprintf(CRITICAL, \"%s: mmc read failure\\n\", __func__);\n\t\tgoto invalidated;\n\t}\n\n\tif (!strcmp((void *)data, FTM_MAGIC_STRING)) {\n\t\tftm_valid = FTM_VALID;\n\t} else {\n\t\tftm_valid = FTM_NOT_MATCHED_MAGIC;\n\t\tdprintf(CRITICAL, \"%s: FTM magic string is not equal. %s\\n\", __func__, data);\n\t}\n\n\treturn NO_ERROR;\n\ninvalidated:\n\tftm_valid = FTM_INVALID;\n\treturn ERROR;\n}", "item_id": 2, "repo": "jaehyek/lk", "file": "platform/lge_shared/lge_ftm.c", "last_update_at": "2018-09-16T12:35:42+00:00", "question_id": "b16dbb2c1d4e543c948df336f8715ff2abf06f34_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int ftm_check_validation(void)\n{\n\tunsigned long long ptn = 0;\n\tunsigned int size = FTM_ROUND_TO_PAGE(strlen(FTM_MAGIC_STRING) + 1, FTM_PAGE_MASK);\n\tunsigned char data[size];\n\tif (ftm_valid > FTM_NOT_MATCHED_MAGIC)\n\t\treturn NO_ERROR;\n\tif (!target_is_emmc_boot()) {\n\t\tdprintf(CRITICAL, \"%s: target is not emmc boot\\n\", __func__);\n\t\tgoto invalidated;\n\t}\n\tptn = ftm_get_partition_offset();\n\tif (ptn == 0) {\n\t\tdprintf(CRITICAL, \"%s: failed get offset\\n\", __func__);\n\t\tgoto invalidated;\n\t}\n\t/* read first page from ftm partition */\n\tif (mmc_read(ptn + (LGFTM_MAGIC_ITEM * FTM_PAGE_SIZE), (unsigned int *)data, size)) {\n\t\tdprintf(CRITICAL, \"%s: mmc read failure\\n\", __func__);\n\t\tgoto invalidated;\n\t}\n\tif (!strcmp((void *)data, FTM_MAGIC_STRING)) {\n\t\tftm_valid = FTM_VALID;\n\t} else {\n\t\tftm_valid = FTM_NOT_MATCHED_MAGIC;\n\t\tdprintf(CRITICAL, \"%s: FTM magic string is not equal. %s\\n\", __func__, data);\n\t}\n\treturn NO_ERROR;\ninvalidated:\n\tftm_valid = FTM_INVALID;\n\treturn ERROR;\n"]]}
{"hexsha": "0cbfbbd3294da2ab5ef285bffc8cf9b09e9e1932", "ext": "c", "lang": "C", "content": "int make_FOOD(BOX** b, SNAKE* left, SNAKE* right)\n{\n    *b = (BOX*) malloc(sizeof(BOX));\n    int startx,starty;\n\n    // we don't want food to be placed in the snake\n    while(TRUE)\n    {\n        startx = 2 * (rand() % (COLS / 2 - 2)) + 1;\n        starty = rand() % (LINES - 2 - 2) + 1;\n        if(!check_SNAKE(left, startx, starty) && !check_SNAKE(right, startx, starty))\n            break;\n    }\n   \n    (*b)->startx = startx;\n    (*b)->starty = starty;\n    (*b)->width = 2;\n    (*b)->height = 1;\n    (*b)->content = ' ' | A_REVERSE;\n    return 0;\n}", "item_id": 3, "repo": "gongbudaizhe/bilib", "file": "demos/snake_game.c", "last_update_at": "2018-08-28T04:18:09+00:00", "question_id": "0cbfbbd3294da2ab5ef285bffc8cf9b09e9e1932_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int make_FOOD(BOX** b, SNAKE* left, SNAKE* right)\n{\n    *b = (BOX*) malloc(sizeof(BOX));\n    int startx,starty;\n    // we don't want food to be placed in the snake\n    while(TRUE)\n    {\n        startx = 2 * (rand() % (COLS / 2 - 2)) + 1;\n        starty = rand() % (LINES - 2 - 2) + 1;\n        if(!check_SNAKE(left, startx, starty) && !check_SNAKE(right, startx, starty))\n            break;\n    }\n    (*b)->startx = startx;\n    (*b)->starty = starty;\n    (*b)->width = 2;\n    (*b)->height = 1;\n    (*b)->content = ' ' | A_REVERSE;\n    return 0;\n"]]}
{"hexsha": "72705ffb3fb44e73e2627954d282445331a96524", "ext": "c", "lang": "C", "content": "static PyObject *bpy_user_map(PyObject *UNUSED(self), PyObject *args, PyObject *kwds)\n{\n#if 0  /* If someone knows how to get a proper 'self' in that case... */\n\tBPy_StructRNA *pyrna = (BPy_StructRNA *)self;\n\tMain *bmain = pyrna->ptr.data;\n#else\n\tMain *bmain = G.main;  /* XXX Ugly, but should work! */\n#endif\n\n\tstatic const char *kwlist[] = {\"subset\", \"key_types\", \"value_types\", NULL};\n\tPyObject *subset = NULL;\n\n\tPyObject *key_types = NULL;\n\tPyObject *val_types = NULL;\n\tBLI_bitmap *key_types_bitmap = NULL;\n\tBLI_bitmap *val_types_bitmap = NULL;\n\n\tPyObject *ret = NULL;\n\n\n\tif (!PyArg_ParseTupleAndKeywords(\n\t        args, kwds, \"|O$O!O!:user_map\", (char **)kwlist,\n\t        &subset,\n\t        &PySet_Type, &key_types,\n\t        &PySet_Type, &val_types))\n\t{\n\t\treturn NULL;\n\t}\n\n\tif (key_types) {\n\t\tkey_types_bitmap = pyrna_set_to_enum_bitmap(\n\t\t        rna_enum_id_type_items, key_types, sizeof(short), true, USHRT_MAX, \"key types\");\n\t\tif (key_types_bitmap == NULL) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (val_types) {\n\t\tval_types_bitmap = pyrna_set_to_enum_bitmap(\n\t\t        rna_enum_id_type_items, val_types, sizeof(short), true, USHRT_MAX, \"value types\");\n\t\tif (val_types_bitmap == NULL) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tIDUserMapData data_cb = {NULL};\n\n\tif (subset) {\n\t\tPyObject *subset_fast = PySequence_Fast(subset, \"user_map\");\n\t\tif (subset_fast == NULL) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tPyObject **subset_array = PySequence_Fast_ITEMS(subset_fast);\n\t\tPy_ssize_t subset_len = PySequence_Fast_GET_SIZE(subset_fast);\n\n\t\tdata_cb.user_map = _PyDict_NewPresized(subset_len);\n\t\tdata_cb.is_subset = true;\n\t\tfor (; subset_len; subset_array++, subset_len--) {\n\t\t\tPyObject *set = PySet_New(NULL);\n\t\t\tPyDict_SetItem(data_cb.user_map, *subset_array, set);\n\t\t\tPy_DECREF(set);\n\t\t}\n\t\tPy_DECREF(subset_fast);\n\t}\n\telse {\n\t\tdata_cb.user_map = PyDict_New();\n\t}\n\n\tdata_cb.types_bitmap = key_types_bitmap;\n\n\tListBase *lb_array[MAX_LIBARRAY];\n\tint lb_index;\n\tlb_index = set_listbasepointers(bmain, lb_array);\n\n\twhile (lb_index--) {\n\n\t\tif (val_types_bitmap && lb_array[lb_index]->first) {\n\t\t\tif (!id_check_type(lb_array[lb_index]->first, val_types_bitmap)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tfor (ID *id = lb_array[lb_index]->first; id; id = id->next) {\n\t\t\t/* One-time init, ID is just used as placeholder here, we abuse this in iterator callback\n\t\t\t * to avoid having to rebuild a complete bpyrna object each time for the key searching\n\t\t\t * (where only ID pointer value is used). */\n\t\t\tif (data_cb.py_id_key_lookup_only == NULL) {\n\t\t\t\tdata_cb.py_id_key_lookup_only = pyrna_id_CreatePyObject(id);\n\t\t\t}\n\n\t\t\tif (!data_cb.is_subset) {\n\t\t\t\tPyObject *key = data_cb.py_id_key_lookup_only;\n\t\t\t\tPyObject *set;\n\n\t\t\t\tRNA_id_pointer_create(id, &((BPy_StructRNA *)key)->ptr);\n\n\t\t\t\t/* We have to insert the key now, otherwise ID unused would be missing from final dict... */\n\t\t\t\tif ((set = PyDict_GetItem(data_cb.user_map, key)) == NULL) {\n\t\t\t\t\t/* Cannot use our placeholder key here! */\n\t\t\t\t\tkey = pyrna_id_CreatePyObject(id);\n\t\t\t\t\tset = PySet_New(NULL);\n\t\t\t\t\tPyDict_SetItem(data_cb.user_map, key, set);\n\t\t\t\t\tPy_DECREF(set);\n\t\t\t\t\tPy_DECREF(key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdata_cb.id_curr = id;\n\t\t\tBKE_library_foreach_ID_link(NULL, id, foreach_libblock_id_user_map_callback, &data_cb, IDWALK_CB_NOP);\n\n\t\t\tif (data_cb.py_id_curr) {\n\t\t\t\tPy_DECREF(data_cb.py_id_curr);\n\t\t\t\tdata_cb.py_id_curr = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = data_cb.user_map;\n\n\nerror:\n\n\tPy_XDECREF(data_cb.py_id_key_lookup_only);\n\n\tif (key_types_bitmap) {\n\t\tMEM_freeN(key_types_bitmap);\n\t}\n\n\tif (val_types_bitmap) {\n\t\tMEM_freeN(val_types_bitmap);\n\t}\n\n\treturn ret;\n\n}", "item_id": 1, "repo": "1-MillionParanoidTterabytes/Blender-2.79b-blackened", "file": "source/blender/python/intern/bpy_rna_id_collection.c", "last_update_at": "2018-06-18T01:50:32+00:00", "question_id": "72705ffb3fb44e73e2627954d282445331a96524_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static PyObject *bpy_user_map(PyObject *UNUSED(self), PyObject *args, PyObject *kwds)\n{\n#if 0  /* If someone knows how to get a proper 'self' in that case... */\n\tBPy_StructRNA *pyrna = (BPy_StructRNA *)self;\n\tMain *bmain = pyrna->ptr.data;\n#else\n\tMain *bmain = G.main;  /* XXX Ugly, but should work! */\n#endif\n\tstatic const char *kwlist[] = {\"subset\", \"key_types\", \"value_types\", NULL};\n\tPyObject *subset = NULL;\n\tPyObject *key_types = NULL;\n\tPyObject *val_types = NULL;\n\tBLI_bitmap *key_types_bitmap = NULL;\n\tBLI_bitmap *val_types_bitmap = NULL;\n\tPyObject *ret = NULL;\n\tif (!PyArg_ParseTupleAndKeywords(\n\t        args, kwds, \"|O$O!O!:user_map\", (char **)kwlist,\n\t        &subset,\n\t        &PySet_Type, &key_types,\n\t        &PySet_Type, &val_types))\n\t{\n\t\treturn NULL;\n\t}\n\tif (key_types) {\n\t\tkey_types_bitmap = pyrna_set_to_enum_bitmap(\n\t\t        rna_enum_id_type_items, key_types, sizeof(short), true, USHRT_MAX, \"key types\");\n\t\tif (key_types_bitmap == NULL) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\tif (val_types) {\n\t\tval_types_bitmap = pyrna_set_to_enum_bitmap(\n\t\t        rna_enum_id_type_items, val_types, sizeof(short), true, USHRT_MAX, \"value types\");\n\t\tif (val_types_bitmap == NULL) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\tIDUserMapData data_cb = {NULL};\n\tif (subset) {\n\t\tPyObject *subset_fast = PySequence_Fast(subset, \"user_map\");\n\t\tif (subset_fast == NULL) {\n\t\t\tgoto error;\n\t\t}\n\t\tPyObject **subset_array = PySequence_Fast_ITEMS(subset_fast);\n\t\tPy_ssize_t subset_len = PySequence_Fast_GET_SIZE(subset_fast);\n\t\tdata_cb.user_map = _PyDict_NewPresized(subset_len);\n\t\tdata_cb.is_subset = true;\n\t\tfor (; subset_len; subset_array++, subset_len--) {\n\t\t\tPyObject *set = PySet_New(NULL);\n\t\t\tPyDict_SetItem(data_cb.user_map, *subset_array, set);\n\t\t\tPy_DECREF(set);\n\t\t}\n\t\tPy_DECREF(subset_fast);\n\t}\n\telse {\n\t\tdata_cb.user_map = PyDict_New();\n\t}\n\tdata_cb.types_bitmap = key_types_bitmap;\n\tListBase *lb_array[MAX_LIBARRAY];\n\tint lb_index;\n\tlb_index = set_listbasepointers(bmain, lb_array);\n\twhile (lb_index--) {\n\t\tif (val_types_bitmap && lb_array[lb_index]->first) {\n\t\t\tif (!id_check_type(lb_array[lb_index]->first, val_types_bitmap)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor (ID *id = lb_array[lb_index]->first; id; id = id->next) {\n\t\t\t/* One-time init, ID is just used as placeholder here, we abuse this in iterator callback\n\t\t\t * to avoid having to rebuild a complete bpyrna object each time for the key searching\n\t\t\t * (where only ID pointer value is used). */\n\t\t\tif (data_cb.py_id_key_lookup_only == NULL) {\n\t\t\t\tdata_cb.py_id_key_lookup_only = pyrna_id_CreatePyObject(id);\n\t\t\t}\n\t\t\tif (!data_cb.is_subset) {\n\t\t\t\tPyObject *key = data_cb.py_id_key_lookup_only;\n\t\t\t\tPyObject *set;\n\t\t\t\tRNA_id_pointer_create(id, &((BPy_StructRNA *)key)->ptr);\n\t\t\t\t/* We have to insert the key now, otherwise ID unused would be missing from final dict... */\n\t\t\t\tif ((set = PyDict_GetItem(data_cb.user_map, key)) == NULL) {\n\t\t\t\t\t/* Cannot use our placeholder key here! */\n\t\t\t\t\tkey = pyrna_id_CreatePyObject(id);\n\t\t\t\t\tset = PySet_New(NULL);\n\t\t\t\t\tPyDict_SetItem(data_cb.user_map, key, set);\n\t\t\t\t\tPy_DECREF(set);\n\t\t\t\t\tPy_DECREF(key);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdata_cb.id_curr = id;\n\t\t\tBKE_library_foreach_ID_link(NULL, id, foreach_libblock_id_user_map_callback, &data_cb, IDWALK_CB_NOP);\n\t\t\tif (data_cb.py_id_curr) {\n\t\t\t\tPy_DECREF(data_cb.py_id_curr);\n\t\t\t\tdata_cb.py_id_curr = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tret = data_cb.user_map;\nerror:\n\tPy_XDECREF(data_cb.py_id_key_lookup_only);\n\tif (key_types_bitmap) {\n\t\tMEM_freeN(key_types_bitmap);\n\t}\n\tif (val_types_bitmap) {\n\t\tMEM_freeN(val_types_bitmap);\n\t}\n\treturn ret;\n"]]}
{"hexsha": "ab79fb02978eae62b2787b88284693886a925492", "ext": "c", "lang": "C", "content": "int iaxc_callback(iaxc_event e)\n{\n\t//printf(\"Received iaxc event type 0x%x\\n\", e.type);\n\tswitch ( e.type ) \n\t{\n\tcase IAXC_EVENT_LEVELS:\n\t\treturn levels_callback(e.ev.levels.input, e.ev.levels.output);\n\tcase IAXC_EVENT_NETSTAT:\n\t\treturn netstat_callback(e.ev.netstats);\n\tcase IAXC_EVENT_TEXT:\n\t\tprocess_text_message(e.ev.text.message);\n\t\tbreak;\n\tcase IAXC_EVENT_STATE:\n\t\treturn state_callback(e.ev.call);\n\tcase IAXC_EVENT_VIDEO:\n\t\tif ( !video )\n\t\t\treturn 0;\n\n\t\tif ( !e.ev.video.encoded )\n\t\t\treturn display_video(e.ev.video,\n\t\t\t\t\te.ev.video.source == IAXC_SOURCE_REMOTE);\n\t\telse\n\t\t\tfprintf(stderr, \"We cannot handle encoded video in callbacks yet\\n\");\n\t\tbreak;\n\n\tcase IAXC_EVENT_AUDIO:\n\t\tfprintf(stderr, \"Got %s %s audio\\n\",\n\t\t\t\te.ev.audio.source == IAXC_SOURCE_REMOTE ? \"remote\" : \"local\",\n\t\t\t\te.ev.audio.encoded ? \"encoded\" : \"raw\");\n\t\tbreak;\n\tcase IAXC_EVENT_VIDCAP_ERROR:\n\t\tfprintf(stderr, \"\\nVIDEO CAPTURE DEVICE ERROR\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}", "item_id": 6, "repo": "tamiel/iaxclient", "file": "simpleclient/vtestcall/vtestcall.c", "last_update_at": "2018-05-08T12:04:06+00:00", "question_id": "ab79fb02978eae62b2787b88284693886a925492_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int iaxc_callback(iaxc_event e)\n{\n\t//printf(\"Received iaxc event type 0x%x\\n\", e.type);\n\tswitch ( e.type ) \n\t{\n\tcase IAXC_EVENT_LEVELS:\n\t\treturn levels_callback(e.ev.levels.input, e.ev.levels.output);\n\tcase IAXC_EVENT_NETSTAT:\n\t\treturn netstat_callback(e.ev.netstats);\n\tcase IAXC_EVENT_TEXT:\n\t\tprocess_text_message(e.ev.text.message);\n\t\tbreak;\n\tcase IAXC_EVENT_STATE:\n\t\treturn state_callback(e.ev.call);\n\tcase IAXC_EVENT_VIDEO:\n\t\tif ( !video )\n\t\t\treturn 0;\n\t\tif ( !e.ev.video.encoded )\n\t\t\treturn display_video(e.ev.video,\n\t\t\t\t\te.ev.video.source == IAXC_SOURCE_REMOTE);\n\t\telse\n\t\t\tfprintf(stderr, \"We cannot handle encoded video in callbacks yet\\n\");\n\t\tbreak;\n\tcase IAXC_EVENT_AUDIO:\n\t\tfprintf(stderr, \"Got %s %s audio\\n\",\n\t\t\t\te.ev.audio.source == IAXC_SOURCE_REMOTE ? \"remote\" : \"local\",\n\t\t\t\te.ev.audio.encoded ? \"encoded\" : \"raw\");\n\t\tbreak;\n\tcase IAXC_EVENT_VIDCAP_ERROR:\n\t\tfprintf(stderr, \"\\nVIDEO CAPTURE DEVICE ERROR\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n"]]}
{"hexsha": "520d6b876aee995fd379a8d816e32ad6d684b86d", "ext": "c", "lang": "C", "content": "void hwInit(void)\n{\n  qbufferInit();\n  ledInit();\n\n  uartInit();\n  dxlportInit();\n  flashInit();\n  resetInit();\n}", "item_id": 0, "repo": "ROBOTIS-GIT/XelNetwork_PowerXel", "file": "powerXel_boot/src/hw/hw.c", "last_update_at": "2018-09-18T08:59:25+00:00", "question_id": "520d6b876aee995fd379a8d816e32ad6d684b86d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void hwInit(void)\n{\n  qbufferInit();\n  ledInit();\n  uartInit();\n  dxlportInit();\n  flashInit();\n  resetInit();\n"]]}
{"hexsha": "ed476dc8604ce07efd20e09a32f4cd8f05cdf2e8", "ext": "c", "lang": "C", "content": "static int feature_node_lua_get_exons(lua_State *L)\n{\n  GtGenomeNode **gn = check_genome_node(L, 1);\n  GtArray *exons = gt_array_new(sizeof (GtGenomeNode*));\n  unsigned long i = 0;\n  GtFeatureNode *fn;\n  /* make sure we get a feature node */\n  fn = gt_feature_node_try_cast(*gn);\n  luaL_argcheck(L, fn, 1, \"not a feature node\");\n  gt_feature_node_get_exons(fn, exons);\n  lua_newtable(L);\n  for (i = 0; i < gt_array_size(exons); i++) {\n    lua_pushnumber(L, i+1);\n    gt_lua_genome_node_push(L, (GtGenomeNode*)\n                            gt_genome_node_ref(*(GtGenomeNode**)\n                                               gt_array_get(exons, i)));\n    lua_rawset(L, -3);\n  }\n  gt_array_delete(exons);\n  return 1;\n}", "item_id": 8, "repo": "thmourikis/erv_annotator", "file": "dist/linux/genometools/src/gtlua/genome_node_lua.c", "last_update_at": "2018-09-30T00:45:55+00:00", "question_id": "ed476dc8604ce07efd20e09a32f4cd8f05cdf2e8_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int feature_node_lua_get_exons(lua_State *L)\n{\n  GtGenomeNode **gn = check_genome_node(L, 1);\n  GtArray *exons = gt_array_new(sizeof (GtGenomeNode*));\n  unsigned long i = 0;\n  GtFeatureNode *fn;\n  /* make sure we get a feature node */\n  fn = gt_feature_node_try_cast(*gn);\n  luaL_argcheck(L, fn, 1, \"not a feature node\");\n  gt_feature_node_get_exons(fn, exons);\n  lua_newtable(L);\n  for (i = 0; i < gt_array_size(exons); i++) {\n    lua_pushnumber(L, i+1);\n    gt_lua_genome_node_push(L, (GtGenomeNode*)\n                            gt_genome_node_ref(*(GtGenomeNode**)\n                                               gt_array_get(exons, i)));\n    lua_rawset(L, -3);\n  }\n  gt_array_delete(exons);\n  return 1;\n"]]}
{"hexsha": "48dc05815cd8d08cc9c305eda4489aa53a919a18", "ext": "c", "lang": "C", "content": "static int\nbcmtm_egr_sp_thd_init(int unit)\n{\n    bcmdrd_sid_t sid = 0;\n    bcmdrd_fid_t fid;\n    bcmltd_sid_t ltid = TM_THD_EGR_SERVICE_POOLt;\n    size_t num_fid = TM_THD_EGR_SERVICE_POOLt_FIELD_COUNT;\n    size_t count = 0;\n    bcmbd_pt_dyn_info_t pt_dyn_info;\n    uint32_t limit = 0;\n    uint32_t ltmbuf = 0;\n    uint32_t fval = 0;\n    int pipe = 0;\n\n    SHR_FUNC_ENTER(unit);\n\n    limit = bcmtm_device_info[unit].num_cells - (44 + bcmtm_dev_buf_info.asf_rsvd) - 44;\n    while(count < num_fid) {\n        if (count == TM_THD_EGR_SERVICE_POOLt_TM_THD_SERVICE_POOL_IDf) {\n            count++;\n            continue;\n        }\n        ltmbuf = 0;\n        switch(count) {\n            case TM_THD_EGR_SERVICE_POOLt_SHARED_LIMIT_CELLSf:\n                sid = MMU_THDM_DB_POOL_SHARED_LIMITr;\n                fid = SHARED_LIMITf;\n                fval = limit;\n                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));\n                break;\n            case TM_THD_EGR_SERVICE_POOLt_SHARED_RESUME_LIMIT_CELLSf:\n                sid = MMU_THDM_DB_POOL_RESUME_LIMITr;\n                fid = RESUME_LIMITf;\n                fval = limit/8;\n                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));\n                break;\n            case TM_THD_EGR_SERVICE_POOLt_YELLOW_SHARED_LIMIT_CELLSf:\n                sid = MMU_THDM_DB_POOL_YELLOW_SHARED_LIMITr;\n                fid = YELLOW_SHARED_LIMITf;\n                fval = limit/8;\n                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));\n                break;\n            case TM_THD_EGR_SERVICE_POOLt_YELLOW_SHARED_RESUME_LIMIT_CELLSf:\n                sid = MMU_THDM_DB_POOL_YELLOW_RESUME_LIMITr;\n                fid = YELLOW_RESUME_LIMITf;\n                fval = limit/8;\n                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));\n                break;\n            case TM_THD_EGR_SERVICE_POOLt_RED_SHARED_LIMIT_CELLSf:\n                sid = MMU_THDM_DB_POOL_RED_SHARED_LIMITr;\n                fid = RED_SHARED_LIMITf;\n                fval = limit/8;\n                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));\n                break;\n            case TM_THD_EGR_SERVICE_POOLt_RED_SHARED_RESUME_LIMIT_CELLSf:\n                sid = MMU_THDM_DB_POOL_RED_RESUME_LIMITr;\n                fid = RED_RESUME_LIMITf;\n                fval = limit/8;\n                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));\n                break;\n            default:\n                sid = 0;\n                break;\n        }\n        for (pipe = 0; pipe < 4 && sid != 0 ; pipe++) {\n            BCMTM_PT_DYN_INFO(pt_dyn_info, 0, pipe);\n                SHR_IF_ERR_EXIT(bcmtm_pt_indexed_write(unit, sid, ltid,\n                            (void*)&pt_dyn_info, &ltmbuf));\n        }\n        count++;\n    }\nexit:\n    SHR_FUNC_EXIT();\n}", "item_id": 9, "repo": "lguohan/SDKLT", "file": "src/bcmtm/chip/bcm56960_a0/bcm56960_a0_bcmtm_thd.c", "last_update_at": "2018-01-31T07:21:49+00:00", "question_id": "48dc05815cd8d08cc9c305eda4489aa53a919a18_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nbcmtm_egr_sp_thd_init(int unit)\n{\n    bcmdrd_sid_t sid = 0;\n    bcmdrd_fid_t fid;\n    bcmltd_sid_t ltid = TM_THD_EGR_SERVICE_POOLt;\n    size_t num_fid = TM_THD_EGR_SERVICE_POOLt_FIELD_COUNT;\n    size_t count = 0;\n    bcmbd_pt_dyn_info_t pt_dyn_info;\n    uint32_t limit = 0;\n    uint32_t ltmbuf = 0;\n    uint32_t fval = 0;\n    int pipe = 0;\n    SHR_FUNC_ENTER(unit);\n    limit = bcmtm_device_info[unit].num_cells - (44 + bcmtm_dev_buf_info.asf_rsvd) - 44;\n    while(count < num_fid) {\n        if (count == TM_THD_EGR_SERVICE_POOLt_TM_THD_SERVICE_POOL_IDf) {\n            count++;\n            continue;\n        }\n        ltmbuf = 0;\n        switch(count) {\n            case TM_THD_EGR_SERVICE_POOLt_SHARED_LIMIT_CELLSf:\n                sid = MMU_THDM_DB_POOL_SHARED_LIMITr;\n                fid = SHARED_LIMITf;\n                fval = limit;\n                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));\n                break;\n            case TM_THD_EGR_SERVICE_POOLt_SHARED_RESUME_LIMIT_CELLSf:\n                sid = MMU_THDM_DB_POOL_RESUME_LIMITr;\n                fid = RESUME_LIMITf;\n                fval = limit/8;\n                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));\n                break;\n            case TM_THD_EGR_SERVICE_POOLt_YELLOW_SHARED_LIMIT_CELLSf:\n                sid = MMU_THDM_DB_POOL_YELLOW_SHARED_LIMITr;\n                fid = YELLOW_SHARED_LIMITf;\n                fval = limit/8;\n                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));\n                break;\n            case TM_THD_EGR_SERVICE_POOLt_YELLOW_SHARED_RESUME_LIMIT_CELLSf:\n                sid = MMU_THDM_DB_POOL_YELLOW_RESUME_LIMITr;\n                fid = YELLOW_RESUME_LIMITf;\n                fval = limit/8;\n                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));\n                break;\n            case TM_THD_EGR_SERVICE_POOLt_RED_SHARED_LIMIT_CELLSf:\n                sid = MMU_THDM_DB_POOL_RED_SHARED_LIMITr;\n                fid = RED_SHARED_LIMITf;\n                fval = limit/8;\n                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));\n                break;\n            case TM_THD_EGR_SERVICE_POOLt_RED_SHARED_RESUME_LIMIT_CELLSf:\n                sid = MMU_THDM_DB_POOL_RED_RESUME_LIMITr;\n                fid = RED_RESUME_LIMITf;\n                fval = limit/8;\n                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));\n                break;\n            default:\n                sid = 0;\n                break;\n        }\n        for (pipe = 0; pipe < 4 && sid != 0 ; pipe++) {\n            BCMTM_PT_DYN_INFO(pt_dyn_info, 0, pipe);\n                SHR_IF_ERR_EXIT(bcmtm_pt_indexed_write(unit, sid, ltid,\n                            (void*)&pt_dyn_info, &ltmbuf));\n        }\n        count++;\n    }\nexit:\n    SHR_FUNC_EXIT();\n"]]}
{"hexsha": "bde7fdb25304bec4c2eb661993c355f21401164d", "ext": "c", "lang": "C", "content": "void* dR_list_next(dR_List* list)\n{\n    void* ret;\n    if(list->iterator!=NULL)\n    {\n        if(list->iterator->next == NULL)\n        {\n            list->iterator = NULL;\n            ret = NULL;\n        }\n        else\n        {\n            list->iterator = list->iterator->next;\n            ret = list->iterator->element;\n        }\n    }\n    else\n    {\n        list->iterator = list->first;\n        if(list->iterator!=NULL)\n        {\n            ret = list->iterator->element;\n        }\n        else\n        {\n            ret = NULL;\n        }\n    }\n    return ret;\n}", "item_id": 18, "repo": "mrjel/deepracin", "file": "src/dR_core.c", "last_update_at": "2018-10-22T18:13:30+00:00", "question_id": "bde7fdb25304bec4c2eb661993c355f21401164d_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void* dR_list_next(dR_List* list)\n{\n    void* ret;\n    if(list->iterator!=NULL)\n    {\n        if(list->iterator->next == NULL)\n        {\n            list->iterator = NULL;\n            ret = NULL;\n        }\n        else\n        {\n            list->iterator = list->iterator->next;\n            ret = list->iterator->element;\n        }\n    }\n    else\n    {\n        list->iterator = list->first;\n        if(list->iterator!=NULL)\n        {\n            ret = list->iterator->element;\n        }\n        else\n        {\n            ret = NULL;\n        }\n    }\n    return ret;\n"]]}
{"hexsha": "bd6433558eb0d8ef557e592dcd1761355c44422c", "ext": "c", "lang": "C", "content": "static void powerdown_cleanup(int toi_or_resume)\n{\n\tif (!toi_or_resume)\n\t\treturn;\n\n\tCLOSE_FILE(lid_file);\n\tCLOSE_FILE(alarm_file);\n\tCLOSE_FILE(epoch_file);\n}", "item_id": 2, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/kernel/power/tuxonice_power_off.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "bd6433558eb0d8ef557e592dcd1761355c44422c_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void powerdown_cleanup(int toi_or_resume)\n{\n\tif (!toi_or_resume)\n\t\treturn;\n\tCLOSE_FILE(lid_file);\n\tCLOSE_FILE(alarm_file);\n\tCLOSE_FILE(epoch_file);\n"]]}
{"hexsha": "8c898955d4ab7621c3ef57b0340db119fe3ec01e", "ext": "h", "lang": "C", "content": "namespace mlperf {\n\n/// \\addtogroup LoadgenAPI\n/// @{\n\n/// \\brief Represents a unique identifier for a sample of an issued query.\n/// \\details As currently implemented, the id is a pointer to an internal\n/// loadgen struct.\ntypedef uintptr_t ResponseId;\n\n/// \\brief An index into the QuerySampleLibrary corresponding to a\n/// single sample.\ntypedef size_t QuerySampleIndex;\n\n/// \\brief Represents the smallest unit of input inference can run on.\n/// A query consists of one or more samples.\nstruct QuerySample {\n  ResponseId id;\n  QuerySampleIndex index;\n};\n\n/// \\brief Represents a single response to QuerySample\nstruct QuerySampleResponse {\n  ResponseId id;\n  uintptr_t data;\n  size_t size;  ///< Size in bytes.\n};\n\n/// \\brief A latency in nanoseconds, as recorded by the loadgen.\ntypedef int64_t QuerySampleLatency;\n\n/// @}\n\n}", "item_id": 0, "repo": "goldgeisser/inference", "file": "loadgen/query_sample.h", "last_update_at": "2018-11-20T16:59:07+00:00", "question_id": "8c898955d4ab7621c3ef57b0340db119fe3ec01e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace mlperf {\n/// \\addtogroup LoadgenAPI\n/// @{\n/// \\brief Represents a unique identifier for a sample of an issued query.\n/// \\details As currently implemented, the id is a pointer to an internal\n/// loadgen struct.\ntypedef uintptr_t ResponseId;\n/// \\brief An index into the QuerySampleLibrary corresponding to a\n/// single sample.\ntypedef size_t QuerySampleIndex;\n/// \\brief Represents the smallest unit of input inference can run on.\n/// A query consists of one or more samples.\nstruct QuerySample {\n  ResponseId id;\n  QuerySampleIndex index;\n};\n/// \\brief Represents a single response to QuerySample\nstruct QuerySampleResponse {\n  ResponseId id;\n  uintptr_t data;\n  size_t size;  ///< Size in bytes.\n};\n/// \\brief A latency in nanoseconds, as recorded by the loadgen.\ntypedef int64_t QuerySampleLatency;\n/// @}\n"]]}
{"hexsha": "7ee707011970a3ed2b3f554e4a47167bedd6b9ce", "ext": "c", "lang": "C", "content": "static short\nFUNC_STDCALL(rb_dl_callback_short_18_3_stdcall)(DLSTACK_TYPE stack0, DLSTACK_TYPE stack1, DLSTACK_TYPE stack2, DLSTACK_TYPE stack3, DLSTACK_TYPE stack4, DLSTACK_TYPE stack5, DLSTACK_TYPE stack6, DLSTACK_TYPE stack7, DLSTACK_TYPE stack8, DLSTACK_TYPE stack9, DLSTACK_TYPE stack10, DLSTACK_TYPE stack11, DLSTACK_TYPE stack12, DLSTACK_TYPE stack13, DLSTACK_TYPE stack14, DLSTACK_TYPE stack15, DLSTACK_TYPE stack16, DLSTACK_TYPE stack17)\n{\n    VALUE ret, cb, args[18];\n\n    args[0] = PTR2NUM(stack0);\n    args[1] = PTR2NUM(stack1);\n    args[2] = PTR2NUM(stack2);\n    args[3] = PTR2NUM(stack3);\n    args[4] = PTR2NUM(stack4);\n    args[5] = PTR2NUM(stack5);\n    args[6] = PTR2NUM(stack6);\n    args[7] = PTR2NUM(stack7);\n    args[8] = PTR2NUM(stack8);\n    args[9] = PTR2NUM(stack9);\n    args[10] = PTR2NUM(stack10);\n    args[11] = PTR2NUM(stack11);\n    args[12] = PTR2NUM(stack12);\n    args[13] = PTR2NUM(stack13);\n    args[14] = PTR2NUM(stack14);\n    args[15] = PTR2NUM(stack15);\n    args[16] = PTR2NUM(stack16);\n    args[17] = PTR2NUM(stack17);\n    cb = rb_ary_entry(rb_ary_entry(rb_DLStdcallCallbackProcs, 3), 78);\n    ret = rb_funcall2(cb, rb_dl_cb_call, 18, args);\n    return NUM2INT(ret);\n}", "item_id": 193, "repo": "ArekX/RAGE", "file": "win32/deps/ruby211/ext/dl/callback-3.c", "last_update_at": "2018-03-26T13:27:36+00:00", "question_id": "7ee707011970a3ed2b3f554e4a47167bedd6b9ce_193", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static short\nFUNC_STDCALL(rb_dl_callback_short_18_3_stdcall)(DLSTACK_TYPE stack0, DLSTACK_TYPE stack1, DLSTACK_TYPE stack2, DLSTACK_TYPE stack3, DLSTACK_TYPE stack4, DLSTACK_TYPE stack5, DLSTACK_TYPE stack6, DLSTACK_TYPE stack7, DLSTACK_TYPE stack8, DLSTACK_TYPE stack9, DLSTACK_TYPE stack10, DLSTACK_TYPE stack11, DLSTACK_TYPE stack12, DLSTACK_TYPE stack13, DLSTACK_TYPE stack14, DLSTACK_TYPE stack15, DLSTACK_TYPE stack16, DLSTACK_TYPE stack17)\n{\n    VALUE ret, cb, args[18];\n    args[0] = PTR2NUM(stack0);\n    args[1] = PTR2NUM(stack1);\n    args[2] = PTR2NUM(stack2);\n    args[3] = PTR2NUM(stack3);\n    args[4] = PTR2NUM(stack4);\n    args[5] = PTR2NUM(stack5);\n    args[6] = PTR2NUM(stack6);\n    args[7] = PTR2NUM(stack7);\n    args[8] = PTR2NUM(stack8);\n    args[9] = PTR2NUM(stack9);\n    args[10] = PTR2NUM(stack10);\n    args[11] = PTR2NUM(stack11);\n    args[12] = PTR2NUM(stack12);\n    args[13] = PTR2NUM(stack13);\n    args[14] = PTR2NUM(stack14);\n    args[15] = PTR2NUM(stack15);\n    args[16] = PTR2NUM(stack16);\n    args[17] = PTR2NUM(stack17);\n    cb = rb_ary_entry(rb_ary_entry(rb_DLStdcallCallbackProcs, 3), 78);\n    ret = rb_funcall2(cb, rb_dl_cb_call, 18, args);\n    return NUM2INT(ret);\n"]]}
{"hexsha": "b547c6aa8c9230d64661ddfcd09bf26ca0a8fd0c", "ext": "h", "lang": "C", "content": "_pure_ static inline size_t\nstr_cmp(const char *restrict sa, const char *restrict sb)\n{\n    if (!sa || !sb)\n        return 1;\n\n    size_t i = 0;\n\n    while (sa[i] == sb[i])\n        if (!sa[i++])\n            return 0;\n\n    return i + 1;\n}", "item_id": 0, "repo": "frankurcrazy/glorytun", "file": "src/str.h", "last_update_at": "2018-10-26T08:46:57+00:00", "question_id": "b547c6aa8c9230d64661ddfcd09bf26ca0a8fd0c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["_pure_ static inline size_t\nstr_cmp(const char *restrict sa, const char *restrict sb)\n{\n    if (!sa || !sb)\n        return 1;\n    size_t i = 0;\n    while (sa[i] == sb[i])\n        if (!sa[i++])\n            return 0;\n    return i + 1;\n"]]}
{"hexsha": "f4de8b84c5c25188503c2672b3818a474ad0db9c", "ext": "c", "lang": "C", "content": "int lov_fini_setattr_set(struct lov_request_set *set)\n{\n\tint rc = 0;\n\n\tif (set == NULL)\n\t\treturn 0;\n\tLASSERT(set->set_exp);\n\tif (atomic_read(&set->set_completes)) {\n\t\trc = common_attr_done(set);\n\t\t/* FIXME update qos data here */\n\t}\n\n\tlov_put_reqset(set);\n\treturn rc;\n}", "item_id": 14, "repo": "SIIS-cloud/pileus", "file": "difc-kernel/pileus-kernel/drivers/staging/lustre/lustre/lov/lov_request.c", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "f4de8b84c5c25188503c2672b3818a474ad0db9c_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int lov_fini_setattr_set(struct lov_request_set *set)\n{\n\tint rc = 0;\n\tif (set == NULL)\n\t\treturn 0;\n\tLASSERT(set->set_exp);\n\tif (atomic_read(&set->set_completes)) {\n\t\trc = common_attr_done(set);\n\t\t/* FIXME update qos data here */\n\t}\n\tlov_put_reqset(set);\n\treturn rc;\n"]]}
{"hexsha": "595fd4e4d662637c48068d1689c2e5498f906458", "ext": "h", "lang": "C", "content": "void  test_pavgw_xmm1xmm2()\n{\n\tint foo[4] = { 10, 20, 30, 40 };\n\tclock_t t1 = clock();\n\tfor (int iterator = 0; iterator < 1000000; iterator++)\n\t{\n\t\trun_pavgw_xmm1xmm2_5_times(foo);\n\t}\n\tclock_t t2 = clock();\n\tfor (int iterator = 0; iterator < 1000000; iterator++)\n\t{\n\t\trun_pavgw_xmm1xmm2_105_times(foo);\n\t}\n\tclock_t t3 = clock();\n\tclock_t clk = (t3 - t2) - (t2 - t1);\n\tstd::cout << \"pavgw takes \" << clk << std::endl;\n}", "item_id": 22, "repo": "helloguo/intrinsictests", "file": "simpletests/simpletests/sse2.h", "last_update_at": "2018-06-18T13:29:24+00:00", "question_id": "595fd4e4d662637c48068d1689c2e5498f906458_22", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void  test_pavgw_xmm1xmm2()\n{\n\tint foo[4] = { 10, 20, 30, 40 };\n\tclock_t t1 = clock();\n\tfor (int iterator = 0; iterator < 1000000; iterator++)\n\t{\n\t\trun_pavgw_xmm1xmm2_5_times(foo);\n\t}\n\tclock_t t2 = clock();\n\tfor (int iterator = 0; iterator < 1000000; iterator++)\n\t{\n\t\trun_pavgw_xmm1xmm2_105_times(foo);\n\t}\n\tclock_t t3 = clock();\n\tclock_t clk = (t3 - t2) - (t2 - t1);\n\tstd::cout << \"pavgw takes \" << clk << std::endl;\n"]]}
{"hexsha": "8f5450d7db4523c033f5a329ad5ae1fd59048c7d", "ext": "c", "lang": "C", "content": "static char *\nGetMapIntString(struct Mapper mapper[], int state)\n{\n    struct Mapper *m;    \n    for (m = mapper; m->s != NULL; m++) {\n        if (m->i == state) {\n            return m->s;\n        }\n    }\n    return NULL;\n}", "item_id": 32, "repo": "tamiel/iaxclient", "file": "contrib/tcl/iaxclient.c", "last_update_at": "2018-05-08T12:04:06+00:00", "question_id": "8f5450d7db4523c033f5a329ad5ae1fd59048c7d_32", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static char *\nGetMapIntString(struct Mapper mapper[], int state)\n{\n    struct Mapper *m;    \n    for (m = mapper; m->s != NULL; m++) {\n        if (m->i == state) {\n            return m->s;\n        }\n    }\n    return NULL;\n"]]}
{"hexsha": "ca8ce3141cd6ceacd8760b28d4149c04f8e5519c", "ext": "c", "lang": "C", "content": "void FactVarSlotErrorMessage2(\n  Environment *theEnv,\n  Fact *theFact,\n  const char *varSlot)\n  {\n   char tempBuffer[20];\n   \n   PrintErrorID(theEnv,\"PRNTUTIL\",13,false);\n   \n   WriteString(theEnv,STDERR,\"The variable/slot reference ?\");\n   WriteString(theEnv,STDERR,varSlot);\n   WriteString(theEnv,STDERR,\" is invalid because the referenced fact \");\n   gensprintf(tempBuffer,\"f-%lld\",theFact->factIndex);\n   WriteString(theEnv,STDERR,tempBuffer);\n   WriteString(theEnv,STDERR,\" does not contain the specified slot.\\n\");\n  }", "item_id": 22, "repo": "Pointer2VoidStar/CLIPS", "file": "src/prntutil.c", "last_update_at": "2018-05-18T07:39:56+00:00", "question_id": "ca8ce3141cd6ceacd8760b28d4149c04f8e5519c_22", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void FactVarSlotErrorMessage2(\n  Environment *theEnv,\n  Fact *theFact,\n  const char *varSlot)\n  {\n   char tempBuffer[20];\n   PrintErrorID(theEnv,\"PRNTUTIL\",13,false);\n   WriteString(theEnv,STDERR,\"The variable/slot reference ?\");\n   WriteString(theEnv,STDERR,varSlot);\n   WriteString(theEnv,STDERR,\" is invalid because the referenced fact \");\n   gensprintf(tempBuffer,\"f-%lld\",theFact->factIndex);\n   WriteString(theEnv,STDERR,tempBuffer);\n   WriteString(theEnv,STDERR,\" does not contain the specified slot.\\n\");\n"]]}
{"hexsha": "eb91c016cb7866a84c654e97ea1e6dbc2f17805f", "ext": "c", "lang": "C", "content": "void\n_Tick ( Context * cntx, int32 findWordFlag )\n{\n    byte * token = ( byte* ) _DataStack_Pop ( ) ;\n    if ( token )\n    {\n        Word * word = 0 ;\n        if ( findWordFlag ) \n        {\n            word = Finder_FindQualifiedIDWord ( cntx->Finder0, token ) ;\n        }\n        if ( word )\n        {\n            token = ( byte * ) word ;\n        }\n        else\n        {\n            Lexer * lexer = cntx->Lexer0 ;\n            Lexer_ParseObject ( lexer, token ) ; // create a string from a 'raw' token\n            if ( GetState ( lexer, KNOWN_OBJECT ) ) token = ( byte* ) lexer->Literal ;\n        }\n        //if ( ! Compiling ) __CfrTil_SourceCode_Init ( _CfrTil_ ) ;\n    }\n    DSP_Push ( ( int32 ) token ) ;\n}", "item_id": 9, "repo": "dennisj001/openvmtil", "file": "src/basis/context.c", "last_update_at": "2018-02-14T16:36:55+00:00", "question_id": "eb91c016cb7866a84c654e97ea1e6dbc2f17805f_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\n_Tick ( Context * cntx, int32 findWordFlag )\n{\n    byte * token = ( byte* ) _DataStack_Pop ( ) ;\n    if ( token )\n    {\n        Word * word = 0 ;\n        if ( findWordFlag ) \n        {\n            word = Finder_FindQualifiedIDWord ( cntx->Finder0, token ) ;\n        }\n        if ( word )\n        {\n            token = ( byte * ) word ;\n        }\n        else\n        {\n            Lexer * lexer = cntx->Lexer0 ;\n            Lexer_ParseObject ( lexer, token ) ; // create a string from a 'raw' token\n            if ( GetState ( lexer, KNOWN_OBJECT ) ) token = ( byte* ) lexer->Literal ;\n        }\n        //if ( ! Compiling ) __CfrTil_SourceCode_Init ( _CfrTil_ ) ;\n    }\n    DSP_Push ( ( int32 ) token ) ;\n"]]}
{"hexsha": "1ecfa9d89747e74a8c5dc7ee15b139f12a480d86", "ext": "c", "lang": "C", "content": "static int sign(OSSL_LIB_CTX *libctx, unsigned char **sig, size_t *sig_len)\n{\n    int rv = 0;\n    EVP_PKEY *pkey = NULL;\n    EVP_PKEY_CTX *ctx = NULL;\n    EVP_MD *md = NULL;\n    const unsigned char *ppriv_key = NULL;\n\n    *sig = NULL;\n\n    /* Load DER-encoded RSA private key. */\n    ppriv_key = rsa_priv_key;\n    pkey = d2i_PrivateKey_ex(EVP_PKEY_RSA, NULL, &ppriv_key,\n                             sizeof(rsa_priv_key), libctx, propq);\n    if (pkey == NULL) {\n        fprintf(stderr, \"Failed to load private key\\n\");\n        goto end;\n    }\n\n    /* Fetch hash algorithm we want to use. */\n    md = EVP_MD_fetch(libctx, \"SHA256\", propq);\n    if (md == NULL) {\n        fprintf(stderr, \"Failed to fetch hash algorithm\\n\");\n        goto end;\n    }\n\n    /* Create signing context. */\n    ctx = EVP_PKEY_CTX_new_from_pkey(libctx, pkey, propq);\n    if (ctx == NULL) {\n        fprintf(stderr, \"Failed to create signing context\\n\");\n        goto end;\n    }\n\n    /* Initialize context for signing and set options. */\n    if (EVP_PKEY_sign_init(ctx) == 0) {\n        fprintf(stderr, \"Failed to initialize signing context\\n\");\n        goto end;\n    }\n\n    if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PSS_PADDING) == 0) {\n        fprintf(stderr, \"Failed to configure padding\\n\");\n        goto end;\n    }\n\n    if (EVP_PKEY_CTX_set_signature_md(ctx, md) == 0) {\n        fprintf(stderr, \"Failed to configure digest type\\n\");\n        goto end;\n    }\n\n    /* Determine length of signature. */\n    if (EVP_PKEY_sign(ctx, NULL, sig_len,\n                      test_digest, sizeof(test_digest)) == 0) {\n        fprintf(stderr, \"Failed to get signature length\\n\");\n        goto end;\n    }\n\n    /* Allocate memory for signature. */\n    *sig = OPENSSL_malloc(*sig_len);\n    if (*sig == NULL) {\n        fprintf(stderr, \"Failed to allocate memory for signature\\n\");\n        goto end;\n    }\n\n    /* Generate signature. */\n    if (EVP_PKEY_sign(ctx, *sig, sig_len,\n                      test_digest, sizeof(test_digest)) != 1) {\n        fprintf(stderr, \"Failed to sign\\n\");\n        goto end;\n    }\n\n    rv = 1;\nend:\n    EVP_PKEY_CTX_free(ctx);\n    EVP_PKEY_free(pkey);\n    EVP_MD_free(md);\n\n    if (rv == 0)\n        OPENSSL_free(*sig);\n\n    return rv;\n}", "item_id": 0, "repo": "mbroz/openssl", "file": "demos/signature/rsa_pss_direct.c", "last_update_at": "2018-08-08T17:10:46+00:00", "question_id": "1ecfa9d89747e74a8c5dc7ee15b139f12a480d86_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int sign(OSSL_LIB_CTX *libctx, unsigned char **sig, size_t *sig_len)\n{\n    int rv = 0;\n    EVP_PKEY *pkey = NULL;\n    EVP_PKEY_CTX *ctx = NULL;\n    EVP_MD *md = NULL;\n    const unsigned char *ppriv_key = NULL;\n    *sig = NULL;\n    /* Load DER-encoded RSA private key. */\n    ppriv_key = rsa_priv_key;\n    pkey = d2i_PrivateKey_ex(EVP_PKEY_RSA, NULL, &ppriv_key,\n                             sizeof(rsa_priv_key), libctx, propq);\n    if (pkey == NULL) {\n        fprintf(stderr, \"Failed to load private key\\n\");\n        goto end;\n    }\n    /* Fetch hash algorithm we want to use. */\n    md = EVP_MD_fetch(libctx, \"SHA256\", propq);\n    if (md == NULL) {\n        fprintf(stderr, \"Failed to fetch hash algorithm\\n\");\n        goto end;\n    }\n    /* Create signing context. */\n    ctx = EVP_PKEY_CTX_new_from_pkey(libctx, pkey, propq);\n    if (ctx == NULL) {\n        fprintf(stderr, \"Failed to create signing context\\n\");\n        goto end;\n    }\n    /* Initialize context for signing and set options. */\n    if (EVP_PKEY_sign_init(ctx) == 0) {\n        fprintf(stderr, \"Failed to initialize signing context\\n\");\n        goto end;\n    }\n    if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PSS_PADDING) == 0) {\n        fprintf(stderr, \"Failed to configure padding\\n\");\n        goto end;\n    }\n    if (EVP_PKEY_CTX_set_signature_md(ctx, md) == 0) {\n        fprintf(stderr, \"Failed to configure digest type\\n\");\n        goto end;\n    }\n    /* Determine length of signature. */\n    if (EVP_PKEY_sign(ctx, NULL, sig_len,\n                      test_digest, sizeof(test_digest)) == 0) {\n        fprintf(stderr, \"Failed to get signature length\\n\");\n        goto end;\n    }\n    /* Allocate memory for signature. */\n    *sig = OPENSSL_malloc(*sig_len);\n    if (*sig == NULL) {\n        fprintf(stderr, \"Failed to allocate memory for signature\\n\");\n        goto end;\n    }\n    /* Generate signature. */\n    if (EVP_PKEY_sign(ctx, *sig, sig_len,\n                      test_digest, sizeof(test_digest)) != 1) {\n        fprintf(stderr, \"Failed to sign\\n\");\n        goto end;\n    }\n    rv = 1;\nend:\n    EVP_PKEY_CTX_free(ctx);\n    EVP_PKEY_free(pkey);\n    EVP_MD_free(md);\n    if (rv == 0)\n        OPENSSL_free(*sig);\n    return rv;\n"]]}
{"hexsha": "51b1acc11ed44401ca88989699ae999d6b1f28a8", "ext": "h", "lang": "C", "content": "interface TRDeviceSetupServer : NSObject <TRTransferServerDelegate> {\n    NSMutableArray * _accountsToAuthenticate;\n    NSMutableDictionary * _cachedAuthInfo;\n    bool  _cancelledSetupInProgress;\n    NSData * _dataToSend;\n    NSObject<OS_dispatch_semaphore> * _dataToSendSemaphore;\n    <TRDeviceSetupServerDelegate> * _delegate;\n    int  _notifyToken;\n    bool  _notifyTokenIsValid;\n    bool  _setupInProgress;\n    bool  _started;\n    TRTransferServer * _transferServer;\n}", "item_id": 0, "repo": "shaojiankui/iOS10-Runtime-Headers", "file": "PrivateFrameworks/TouchRemote.framework/TRDeviceSetupServer.h", "last_update_at": "2018-10-08T04:12:25+00:00", "question_id": "51b1acc11ed44401ca88989699ae999d6b1f28a8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface TRDeviceSetupServer : NSObject <TRTransferServerDelegate> {\n    NSMutableArray * _accountsToAuthenticate;\n    NSMutableDictionary * _cachedAuthInfo;\n    bool  _cancelledSetupInProgress;\n    NSData * _dataToSend;\n    NSObject<OS_dispatch_semaphore> * _dataToSendSemaphore;\n    <TRDeviceSetupServerDelegate> * _delegate;\n    int  _notifyToken;\n    bool  _notifyTokenIsValid;\n    bool  _setupInProgress;\n    bool  _started;\n    TRTransferServer * _transferServer;\n"]]}
{"hexsha": "24735321e895312d09417e6b47aeed787d3b2018", "ext": "c", "lang": "C", "content": "int\nxenHypervisorGetVcpuMax(virConnectPtr conn,\n                        virDomainDefPtr def)\n{\n    xen_getdomaininfo dominfo;\n    int ret;\n    int maxcpu;\n    xenUnifiedPrivatePtr priv = conn->privateData;\n\n    /* inactive domain */\n    if (def->id < 0) {\n        maxcpu = MAX_VIRT_CPUS;\n    } else {\n        XEN_GETDOMAININFO_CLEAR(dominfo);\n        ret = virXen_getdomaininfo(priv->handle, def->id,\n                                   &dominfo);\n\n        if ((ret < 0) || (XEN_GETDOMAININFO_DOMAIN(dominfo) != def->id))\n            return -1;\n        maxcpu = XEN_GETDOMAININFO_MAXCPUID(dominfo) + 1;\n    }\n\n    return maxcpu;\n}", "item_id": 30, "repo": "SIIS-cloud/pileus", "file": "libvirt/pileus-libvirt-1.2.12/src/xen/xen_hypervisor.c", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "24735321e895312d09417e6b47aeed787d3b2018_30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nxenHypervisorGetVcpuMax(virConnectPtr conn,\n                        virDomainDefPtr def)\n{\n    xen_getdomaininfo dominfo;\n    int ret;\n    int maxcpu;\n    xenUnifiedPrivatePtr priv = conn->privateData;\n    /* inactive domain */\n    if (def->id < 0) {\n        maxcpu = MAX_VIRT_CPUS;\n    } else {\n        XEN_GETDOMAININFO_CLEAR(dominfo);\n        ret = virXen_getdomaininfo(priv->handle, def->id,\n                                   &dominfo);\n        if ((ret < 0) || (XEN_GETDOMAININFO_DOMAIN(dominfo) != def->id))\n            return -1;\n        maxcpu = XEN_GETDOMAININFO_MAXCPUID(dominfo) + 1;\n    }\n    return maxcpu;\n"]]}
{"hexsha": "1ddb3fc1772b04a2265a9ea2b20c298ee4f30163", "ext": "c", "lang": "C", "content": "static int _set_status_v1(domid_t  domid,\n                          int readonly,\n                          int mapflag,\n                          grant_entry_header_t *shah, \n                          struct active_grant_entry *act)\n{\n    int rc = GNTST_okay;\n    union grant_combo scombo, prev_scombo, new_scombo;\n    uint16_t mask = GTF_type_mask;\n\n    /*\n     * We bound the number of times we retry CMPXCHG on memory locations that\n     * we share with a guest OS. The reason is that the guest can modify that\n     * location at a higher rate than we can read-modify-CMPXCHG, so the guest\n     * could cause us to livelock. There are a few cases where it is valid for\n     * the guest to race our updates (e.g., to change the GTF_readonly flag),\n     * so we allow a few retries before failing.\n     */\n    int retries = 0;\n\n    /* if this is a grant mapping operation we should ensure GTF_sub_page\n       is not set */\n    if (mapflag)\n        mask |= GTF_sub_page;\n\n    scombo.word = *(u32 *)shah;\n\n    /*\n     * This loop attempts to set the access (reading/writing) flags\n     * in the grant table entry.  It tries a cmpxchg on the field\n     * up to five times, and then fails under the assumption that \n     * the guest is misbehaving.\n     */\n    for ( ; ; )\n    {\n        /* If not already pinned, check the grant domid and type. */\n        if ( !act->pin &&\n             (((scombo.shorts.flags & mask) !=\n               GTF_permit_access) ||\n              (scombo.shorts.domid != domid)) )\n            PIN_FAIL(done, GNTST_general_error,\n                     \"Bad flags (%x) or dom (%d). (expected dom %d)\\n\",\n                     scombo.shorts.flags, scombo.shorts.domid,\n                     domid);\n\n        new_scombo = scombo;\n        new_scombo.shorts.flags |= GTF_reading;\n\n        if ( !readonly )\n        {\n            new_scombo.shorts.flags |= GTF_writing;\n            if ( unlikely(scombo.shorts.flags & GTF_readonly) )\n                PIN_FAIL(done, GNTST_general_error,\n                         \"Attempt to write-pin a r/o grant entry.\\n\");\n        }\n\n        prev_scombo.word = cmpxchg((u32 *)shah,\n                                   scombo.word, new_scombo.word);\n        if ( likely(prev_scombo.word == scombo.word) )\n            break;\n\n        if ( retries++ == 4 )\n            PIN_FAIL(done, GNTST_general_error,\n                     \"Shared grant entry is unstable.\\n\");\n\n        scombo = prev_scombo;\n    }\n\ndone:\n    return rc;\n}", "item_id": 5, "repo": "zhiming-shen/Xen-Blanket-NG", "file": "xen/xen-4.2.2/xen/common/grant_table.c", "last_update_at": "2018-02-02T00:15:26+00:00", "question_id": "1ddb3fc1772b04a2265a9ea2b20c298ee4f30163_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int _set_status_v1(domid_t  domid,\n                          int readonly,\n                          int mapflag,\n                          grant_entry_header_t *shah, \n                          struct active_grant_entry *act)\n{\n    int rc = GNTST_okay;\n    union grant_combo scombo, prev_scombo, new_scombo;\n    uint16_t mask = GTF_type_mask;\n    /*\n     * We bound the number of times we retry CMPXCHG on memory locations that\n     * we share with a guest OS. The reason is that the guest can modify that\n     * location at a higher rate than we can read-modify-CMPXCHG, so the guest\n     * could cause us to livelock. There are a few cases where it is valid for\n     * the guest to race our updates (e.g., to change the GTF_readonly flag),\n     * so we allow a few retries before failing.\n     */\n    int retries = 0;\n    /* if this is a grant mapping operation we should ensure GTF_sub_page\n       is not set */\n    if (mapflag)\n        mask |= GTF_sub_page;\n    scombo.word = *(u32 *)shah;\n    /*\n     * This loop attempts to set the access (reading/writing) flags\n     * in the grant table entry.  It tries a cmpxchg on the field\n     * up to five times, and then fails under the assumption that \n     * the guest is misbehaving.\n     */\n    for ( ; ; )\n    {\n        /* If not already pinned, check the grant domid and type. */\n        if ( !act->pin &&\n             (((scombo.shorts.flags & mask) !=\n               GTF_permit_access) ||\n              (scombo.shorts.domid != domid)) )\n            PIN_FAIL(done, GNTST_general_error,\n                     \"Bad flags (%x) or dom (%d). (expected dom %d)\\n\",\n                     scombo.shorts.flags, scombo.shorts.domid,\n                     domid);\n        new_scombo = scombo;\n        new_scombo.shorts.flags |= GTF_reading;\n        if ( !readonly )\n        {\n            new_scombo.shorts.flags |= GTF_writing;\n            if ( unlikely(scombo.shorts.flags & GTF_readonly) )\n                PIN_FAIL(done, GNTST_general_error,\n                         \"Attempt to write-pin a r/o grant entry.\\n\");\n        }\n        prev_scombo.word = cmpxchg((u32 *)shah,\n                                   scombo.word, new_scombo.word);\n        if ( likely(prev_scombo.word == scombo.word) )\n            break;\n        if ( retries++ == 4 )\n            PIN_FAIL(done, GNTST_general_error,\n                     \"Shared grant entry is unstable.\\n\");\n        scombo = prev_scombo;\n    }\ndone:\n    return rc;\n"]]}
{"hexsha": "daeff356501b1cbc3009d3c4c9daa00bc413ad43", "ext": "c", "lang": "C", "content": "static void check_alloc() {\n  frame_t *frame = alloc_frame();\n\n  CU_ASSERT(frame != NULL);\n\n  free_frame(frame);\n}", "item_id": 1, "repo": "userlocalhost2000/newt", "file": "tests/unit/test_frame.c", "last_update_at": "2018-05-23T23:59:30+00:00", "question_id": "daeff356501b1cbc3009d3c4c9daa00bc413ad43_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void check_alloc() {\n  frame_t *frame = alloc_frame();\n  CU_ASSERT(frame != NULL);\n  free_frame(frame);\n"]]}
{"hexsha": "ec662537837488947ea43e811d65e6b3c12ea304", "ext": "c", "lang": "C", "content": "static void coroae_int(void) {\n\tuwsgi_log(\"Brutally killing worker %d (pid: %d)...\\n\", uwsgi.mywid, uwsgi.mypid);\n\tuwsgi.workers[uwsgi.mywid].manage_next_request = 0;\n\tSvREFCNT_dec(ucoroae.watchers);\n\n\tcoroae_condvar_call(ucoroae.condvar, \"send\");\n}", "item_id": 16, "repo": "StanYaha/Blog", "file": "vmaig_blog/uwsgi-2.0.14/plugins/coroae/coroae.c", "last_update_at": "2018-11-24T16:10:49+00:00", "question_id": "ec662537837488947ea43e811d65e6b3c12ea304_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void coroae_int(void) {\n\tuwsgi_log(\"Brutally killing worker %d (pid: %d)...\\n\", uwsgi.mywid, uwsgi.mypid);\n\tuwsgi.workers[uwsgi.mywid].manage_next_request = 0;\n\tSvREFCNT_dec(ucoroae.watchers);\n\tcoroae_condvar_call(ucoroae.condvar, \"send\");\n"]]}
{"hexsha": "2fcdb078fe71a8925f78b63496c09123444f8888", "ext": "c", "lang": "C", "content": "int crypto_hash(unsigned char *hashval,\r\n\t\tconst unsigned char *data,\r\n\t\tunsigned long long databytelen)\r\n{\r\n  uint8_t state[SIZE512];\r\n  uint8_t message_block[SIZE512];\r\n  uint32_t i, j, w;\r\n  uint32_t bytes_remaining;\r\n  uint64_t full_message_blocks = databytelen/64;\r\n\r\n\r\n\r\n  //Setting initial state\r\n  for(i=0;i<(SIZE512/sizeof(uint32_t));i++)\r\n  {\r\n    ((uint32_t*)state)[i] = 0;\r\n  }\r\n\r\n  //256BIT_HASH_SPECIFIC line\r\n  state[55] = 1; //Initial value for hash length 256 bit when saving state in row order!\r\n\r\n  while(full_message_blocks--)\r\n  {\r\n    for (i = 0; i < SIZE512; i++) {\r\n      message_block[(i%8)*8+i/8] = data[i]; //zeilenweise speichern\r\n  }\r\n\t\t\r\n  P((uint32_t*)state, (uint32_t*)message_block);\r\n\r\n  for (i = 0; i < SIZE512; i++) {\r\n    message_block[(i%8)*8+i/8] = data[i]; //zeilenweise speichern\r\n  }\r\n  Q((uint32_t*)state, (uint32_t*)message_block);\r\n    data += SIZE512;\r\n  }\r\n\t\r\n\r\n\t//Padding\r\n  bytes_remaining = ((uint32_t)databytelen)%64;\r\n  if(bytes_remaining > (SIZE512-64/8-1)) //if only one padding block is needed (64 bit w + 1 byte for appending bit 1)\r\n  {\r\n    for(j=0;j<2;j++)\r\n    {  \r\n      for(i=0;i<bytes_remaining;i++)\r\n      {\r\n    \t  message_block[(i%8)*8+i/8] = data[i]; //zeilenweise speichern\r\n      }    \t\r\n    \t//setting padding bit 1\r\n  \r\n  \t\tmessage_block[(i%8)*8+i/8] = 0x80;\r\n      i++;\r\n      for(;i<SIZE512;i++)\r\n      {\r\n        message_block[(i%8)*8+i/8] = 0;\r\n      }\r\n\r\n      if(j==0)\r\n      {\r\n        P((uint32_t*)state, (uint32_t*)message_block);\r\n      }\r\n      else\r\n      {\r\n        Q((uint32_t*)state, (uint32_t*)message_block);\r\n      }\r\n    }\r\n  }\r\n\r\n  w = (-((uint32_t)8*databytelen)-65)&0x1FF;\r\n  databytelen = (8*databytelen+w+65)/(SIZE512*8);\r\n  \r\n\r\n  for(j=0;j<2;j++)     //j is 2 at this moment\r\n  {\r\n    i=0;\r\n    if(bytes_remaining <= (SIZE512-64/8-1))\r\n    {\r\n      for(;i<bytes_remaining;i++)\r\n      {\r\n    \tmessage_block[(i%8)*8+i/8] = data[i]; //zeilenweise speichern\r\n\t  }\r\n      message_block[(i%8)*8+i/8] = 0x80;\r\n      i++;\r\n    }\r\n\r\n    for(;i<(SIZE512-(64/8));i++)\r\n  \t{\r\n  \t  message_block[(i%8)*8+i/8] = 0;\r\n  \t}\r\n\r\n    full_message_blocks = databytelen; //temp copy of padding value\r\n    for(i=SIZE512-1;i>=(SIZE512-64/8);i--)\r\n    {\r\n      message_block[(i%8)*8+i/8] = (uint8_t)full_message_blocks;\r\n      full_message_blocks >>= 8;\r\n    }\r\n\r\n    if(j==0)\r\n    {\r\n      P((uint32_t*)state, (uint32_t*)message_block);\r\n    }\r\n    else\r\n    {\r\n      Q((uint32_t*)state, (uint32_t*)message_block);\r\n    }\r\n  }\r\n\r\n  for (i = 0; i < SIZE512/sizeof(uint32_t); i++) {\r\n    ((uint32_t*)message_block)[i] = ((uint32_t*)state)[i];\r\n  }\r\n\r\n  w = 0;     //round constant\r\n  \r\n\r\n  for(i=0;i<10;i++)\r\n  {\r\n  \tRND512P((uint32_t*)state, w);\r\n  \tw += 0x01010101;\r\n  }\r\n\r\n  for (i = 0; i < 2*COLS512; i++) {\r\n    ((uint32_t*)state)[i] ^= ((uint32_t*)message_block)[i];\r\n  }\r\n\r\n  for (i = SIZE512-HASH_BIT_LEN/8; i < SIZE512; i++) {\r\n    hashval[i-(SIZE512-HASH_BIT_LEN/8)] = state[(i%8)*8+i/8]; //zeilenweise speichern\r\n  }\r\n\r\n\r\n  return 0;\r\n}", "item_id": 5, "repo": "iadgov/simon-speck-supercop", "file": "crypto_hash/groestl256/thumb-asm-small/hash.c", "last_update_at": "2018-03-09T14:52:25+00:00", "question_id": "2fcdb078fe71a8925f78b63496c09123444f8888_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int crypto_hash(unsigned char *hashval,\r\n\t\tconst unsigned char *data,\r\n\t\tunsigned long long databytelen)\r\n{\r\n  uint8_t state[SIZE512];\r\n  uint8_t message_block[SIZE512];\r\n  uint32_t i, j, w;\r\n  uint32_t bytes_remaining;\r\n  uint64_t full_message_blocks = databytelen/64;\r\n\r\n\r\n\r\n  //Setting initial state\r\n  for(i=0;i<(SIZE512/sizeof(uint32_t));i++)\r\n  {\r\n    ((uint32_t*)state)[i] = 0;\r\n  }\r\n\r\n  //256BIT_HASH_SPECIFIC line\r\n  state[55] = 1; //Initial value for hash length 256 bit when saving state in row order!\r\n\r\n  while(full_message_blocks--)\r\n  {\r\n    for (i = 0; i < SIZE512; i++) {\r\n      message_block[(i%8)*8+i/8] = data[i]; //zeilenweise speichern\r\n  }\r\n\t\t\r\n  P((uint32_t*)state, (uint32_t*)message_block);\r\n\r\n  for (i = 0; i < SIZE512; i++) {\r\n    message_block[(i%8)*8+i/8] = data[i]; //zeilenweise speichern\r\n  }\r\n  Q((uint32_t*)state, (uint32_t*)message_block);\r\n    data += SIZE512;\r\n  }\r\n\t\r\n\r\n\t//Padding\r\n  bytes_remaining = ((uint32_t)databytelen)%64;\r\n  if(bytes_remaining > (SIZE512-64/8-1)) //if only one padding block is needed (64 bit w + 1 byte for appending bit 1)\r\n  {\r\n    for(j=0;j<2;j++)\r\n    {  \r\n      for(i=0;i<bytes_remaining;i++)\r\n      {\r\n    \t  message_block[(i%8)*8+i/8] = data[i]; //zeilenweise speichern\r\n      }    \t\r\n    \t//setting padding bit 1\r\n  \r\n  \t\tmessage_block[(i%8)*8+i/8] = 0x80;\r\n      i++;\r\n      for(;i<SIZE512;i++)\r\n      {\r\n        message_block[(i%8)*8+i/8] = 0;\r\n      }\r\n\r\n      if(j==0)\r\n      {\r\n        P((uint32_t*)state, (uint32_t*)message_block);\r\n      }\r\n      else\r\n      {\r\n        Q((uint32_t*)state, (uint32_t*)message_block);\r\n      }\r\n    }\r\n  }\r\n\r\n  w = (-((uint32_t)8*databytelen)-65)&0x1FF;\r\n  databytelen = (8*databytelen+w+65)/(SIZE512*8);\r\n  \r\n\r\n  for(j=0;j<2;j++)     //j is 2 at this moment\r\n  {\r\n    i=0;\r\n    if(bytes_remaining <= (SIZE512-64/8-1))\r\n    {\r\n      for(;i<bytes_remaining;i++)\r\n      {\r\n    \tmessage_block[(i%8)*8+i/8] = data[i]; //zeilenweise speichern\r\n\t  }\r\n      message_block[(i%8)*8+i/8] = 0x80;\r\n      i++;\r\n    }\r\n\r\n    for(;i<(SIZE512-(64/8));i++)\r\n  \t{\r\n  \t  message_block[(i%8)*8+i/8] = 0;\r\n  \t}\r\n\r\n    full_message_blocks = databytelen; //temp copy of padding value\r\n    for(i=SIZE512-1;i>=(SIZE512-64/8);i--)\r\n    {\r\n      message_block[(i%8)*8+i/8] = (uint8_t)full_message_blocks;\r\n      full_message_blocks >>= 8;\r\n    }\r\n\r\n    if(j==0)\r\n    {\r\n      P((uint32_t*)state, (uint32_t*)message_block);\r\n    }\r\n    else\r\n    {\r\n      Q((uint32_t*)state, (uint32_t*)message_block);\r\n    }\r\n  }\r\n\r\n  for (i = 0; i < SIZE512/sizeof(uint32_t); i++) {\r\n    ((uint32_t*)message_block)[i] = ((uint32_t*)state)[i];\r\n  }\r\n\r\n  w = 0;     //round constant\r\n  \r\n\r\n  for(i=0;i<10;i++)\r\n  {\r\n  \tRND512P((uint32_t*)state, w);\r\n  \tw += 0x01010101;\r\n  }\r\n\r\n  for (i = 0; i < 2*COLS512; i++) {\r\n    ((uint32_t*)state)[i] ^= ((uint32_t*)message_block)[i];\r\n  }\r\n\r\n  for (i = SIZE512-HASH_BIT_LEN/8; i < SIZE512; i++) {\r\n    hashval[i-(SIZE512-HASH_BIT_LEN/8)] = state[(i%8)*8+i/8]; //zeilenweise speichern\r\n  }\r\n\r\n\r\n  return 0;\r\n"]]}
{"hexsha": "5a6331acc75a41db4102022dbe2ae9259f3a8633", "ext": "c", "lang": "C", "content": "PUBLIC int process_ksig(endpoint_t proc_nr_e, int signo)\r\n{\r\n  register struct mproc *rmp;\r\n  int proc_nr;\r\n  pid_t proc_id, id;\r\n\r\n  if(pm_isokendpt(proc_nr_e, &proc_nr) != OK || proc_nr < 0) {\r\n\tprintf(\"PM: process_ksig: %d?? not ok\\n\", proc_nr_e);\r\n\treturn EDEADSRCDST; /* process is gone. */\r\n  }\r\n  rmp = &mproc[proc_nr];\r\n  if ((rmp->mp_flags & (IN_USE | EXITING)) != IN_USE) {\r\n#if 0\r\n\tprintf(\"PM: process_ksig: %d?? exiting / not in use\\n\", proc_nr_e);\r\n#endif\r\n\treturn EDEADSRCDST; /* process is gone. */\r\n  }\r\n  proc_id = rmp->mp_pid;\r\n  mp = &mproc[0];\t\t\t/* pretend signals are from PM */\r\n  mp->mp_procgrp = rmp->mp_procgrp;\t/* get process group right */\r\n\r\n  /* For SIGVTALRM and SIGPROF, see if we need to restart a\r\n   * virtual timer. For SIGINT, SIGWINCH and SIGQUIT, use proc_id 0\r\n   * to indicate a broadcast to the recipient's process group.  For\r\n   * SIGKILL, use proc_id -1 to indicate a systemwide broadcast.\r\n   */\r\n  switch (signo) {\r\n      case SIGINT:\r\n      case SIGQUIT:\r\n      case SIGWINCH:\r\n  \tid = 0; break;\t/* broadcast to process group */\r\n      case SIGVTALRM:\r\n      case SIGPROF:\r\n      \tcheck_vtimer(proc_nr, signo);\r\n      \t/* fall-through */\r\n      default:\r\n  \tid = proc_id;\r\n  \tbreak;\r\n  }\r\n  check_sig(id, signo, TRUE /* ksig */);\r\n\r\n  /* If SIGSNDELAY is set, an earlier sys_stop() failed because the process was\r\n   * still sending, and the kernel hereby tells us that the process is now done\r\n   * with that. We can now try to resume what we planned to do in the first\r\n   * place: set up a signal handler. However, the process's message may have\r\n   * been a call to PM, in which case the process may have changed any of its\r\n   * signal settings. The process may also have forked, exited etcetera.\r\n   */\r\n  if (signo == SIGSNDELAY && (rmp->mp_flags & DELAY_CALL)) {\r\n\trmp->mp_flags &= ~DELAY_CALL;\r\n\r\n\t/*\r\n\t * If the FS_CALL flag is still set we have a process which is stopped\r\n\t * and we only need to wait for a reply from VFS. We are going to check\r\n\t * the pending signal then\r\n\t */\r\n\tif (rmp->mp_flags & FS_CALL)\r\n\t\treturn OK;\r\n\tif (rmp->mp_flags & PM_SIG_PENDING)\r\n\t\tpanic(\"process_ksig: bad process state\");\r\n\r\n\t/* Process as many normal signals as possible. */\r\n\tcheck_pending(rmp);\r\n\r\n\tif (rmp->mp_flags & DELAY_CALL)\r\n\t\tpanic(\"process_ksig: multiple delay calls?\");\r\n  }\r\n  \r\n  /* See if the process is still alive */\r\n  if ((mproc[proc_nr].mp_flags & (IN_USE | EXITING)) == IN_USE)  {\r\n      return OK; /* signal has been delivered */\r\n  }\r\n  else {\r\n      return EDEADSRCDST; /* process is gone */\r\n  }\r\n}", "item_id": 5, "repo": "ducis/operating-system-labs", "file": "src.clean/servers/pm/signal.c", "last_update_at": "2018-03-01T14:11:47+00:00", "question_id": "5a6331acc75a41db4102022dbe2ae9259f3a8633_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["PUBLIC int process_ksig(endpoint_t proc_nr_e, int signo)\r\n{\r\n  register struct mproc *rmp;\r\n  int proc_nr;\r\n  pid_t proc_id, id;\r\n\r\n  if(pm_isokendpt(proc_nr_e, &proc_nr) != OK || proc_nr < 0) {\r\n\tprintf(\"PM: process_ksig: %d?? not ok\\n\", proc_nr_e);\r\n\treturn EDEADSRCDST; /* process is gone. */\r\n  }\r\n  rmp = &mproc[proc_nr];\r\n  if ((rmp->mp_flags & (IN_USE | EXITING)) != IN_USE) {\r\n#if 0\r\n\tprintf(\"PM: process_ksig: %d?? exiting / not in use\\n\", proc_nr_e);\r\n#endif\r\n\treturn EDEADSRCDST; /* process is gone. */\r\n  }\r\n  proc_id = rmp->mp_pid;\r\n  mp = &mproc[0];\t\t\t/* pretend signals are from PM */\r\n  mp->mp_procgrp = rmp->mp_procgrp;\t/* get process group right */\r\n\r\n  /* For SIGVTALRM and SIGPROF, see if we need to restart a\r\n   * virtual timer. For SIGINT, SIGWINCH and SIGQUIT, use proc_id 0\r\n   * to indicate a broadcast to the recipient's process group.  For\r\n   * SIGKILL, use proc_id -1 to indicate a systemwide broadcast.\r\n   */\r\n  switch (signo) {\r\n      case SIGINT:\r\n      case SIGQUIT:\r\n      case SIGWINCH:\r\n  \tid = 0; break;\t/* broadcast to process group */\r\n      case SIGVTALRM:\r\n      case SIGPROF:\r\n      \tcheck_vtimer(proc_nr, signo);\r\n      \t/* fall-through */\r\n      default:\r\n  \tid = proc_id;\r\n  \tbreak;\r\n  }\r\n  check_sig(id, signo, TRUE /* ksig */);\r\n\r\n  /* If SIGSNDELAY is set, an earlier sys_stop() failed because the process was\r\n   * still sending, and the kernel hereby tells us that the process is now done\r\n   * with that. We can now try to resume what we planned to do in the first\r\n   * place: set up a signal handler. However, the process's message may have\r\n   * been a call to PM, in which case the process may have changed any of its\r\n   * signal settings. The process may also have forked, exited etcetera.\r\n   */\r\n  if (signo == SIGSNDELAY && (rmp->mp_flags & DELAY_CALL)) {\r\n\trmp->mp_flags &= ~DELAY_CALL;\r\n\r\n\t/*\r\n\t * If the FS_CALL flag is still set we have a process which is stopped\r\n\t * and we only need to wait for a reply from VFS. We are going to check\r\n\t * the pending signal then\r\n\t */\r\n\tif (rmp->mp_flags & FS_CALL)\r\n\t\treturn OK;\r\n\tif (rmp->mp_flags & PM_SIG_PENDING)\r\n\t\tpanic(\"process_ksig: bad process state\");\r\n\r\n\t/* Process as many normal signals as possible. */\r\n\tcheck_pending(rmp);\r\n\r\n\tif (rmp->mp_flags & DELAY_CALL)\r\n\t\tpanic(\"process_ksig: multiple delay calls?\");\r\n  }\r\n  \r\n  /* See if the process is still alive */\r\n  if ((mproc[proc_nr].mp_flags & (IN_USE | EXITING)) == IN_USE)  {\r\n      return OK; /* signal has been delivered */\r\n  }\r\n  else {\r\n      return EDEADSRCDST; /* process is gone */\r\n  }\r\n"]]}
{"hexsha": "1e3a6cfbd50359eab00b8b6c94ab00942d85e644", "ext": "h", "lang": "C", "content": "class input {\npublic:\n\tinput(std::string, std::string, std::string, bool);\n\t~input() {};\n\thcube* makeHostCube(long, bool);\n\tstd::vector<long> dim;\n\tstd::valarray<double> data;\n\tstd::string in_fits_filename, in_params_filename, in_config_filename;\n\txml_document<> config;\n\txml_document<> params;\n\tstd::vector<int> wavelengths;\n\tstd::map<std::string, std::string> config_host;\t\t\t// dictionary containing all config items related to the host.\n\tstd::map<std::string, std::string> config_device;\t\t// dictionary containing all config items related to the device.\n\tstd::list<process_stages> stages;\n\tstd::map<process_stages, std::map<std::string, std::string>> stage_parameters;\nprivate:\n\tvoid readXMLFile(xml_document<>&, string, bool);\n\tvoid readFITSFile(std::valarray<double>&, std::vector<long>&, string, bool);\n\tvoid processConfigFile(string, bool);\n\tvoid processSimulationParametersFile(string, bool);\n\tvoid processFITSFile(string, bool);\n}", "item_id": 0, "repo": "oxford-pcs/sdcuda", "file": "cinput.h", "last_update_at": "2018-01-22T21:54:27+00:00", "question_id": "1e3a6cfbd50359eab00b8b6c94ab00942d85e644_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class input {\npublic:\n\tinput(std::string, std::string, std::string, bool);\n\t~input() {};\n\thcube* makeHostCube(long, bool);\n\tstd::vector<long> dim;\n\tstd::valarray<double> data;\n\tstd::string in_fits_filename, in_params_filename, in_config_filename;\n\txml_document<> config;\n\txml_document<> params;\n\tstd::vector<int> wavelengths;\n\tstd::map<std::string, std::string> config_host;\t\t\t// dictionary containing all config items related to the host.\n\tstd::map<std::string, std::string> config_device;\t\t// dictionary containing all config items related to the device.\n\tstd::list<process_stages> stages;\n\tstd::map<process_stages, std::map<std::string, std::string>> stage_parameters;\nprivate:\n\tvoid readXMLFile(xml_document<>&, string, bool);\n\tvoid readFITSFile(std::valarray<double>&, std::vector<long>&, string, bool);\n\tvoid processConfigFile(string, bool);\n\tvoid processSimulationParametersFile(string, bool);\n\tvoid processFITSFile(string, bool);\n"]]}
{"hexsha": "5ea3afa093a48e3c18921a5a3d433247ce35f4ff", "ext": "c", "lang": "C", "content": "int nhap() {\n  int n;\n  printf(\"Nhap vao so phan tu cua day (n<5): \");\n  scanf(\"%i\", &n);\n  while (n <= 5) {\n    printf(\"Du lieu khong hop le. Nhap vao so phan tu cua day (n<5): \");\n    scanf(\"%i\", &n);\n  }\n  return n;\n}", "item_id": 0, "repo": "lamhoangtung/Bai-tap-Lap-trinh-can-ban", "file": "De thi/ngoc-bai2.c", "last_update_at": "2018-03-30T14:20:05+00:00", "question_id": "5ea3afa093a48e3c18921a5a3d433247ce35f4ff_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int nhap() {\n  int n;\n  printf(\"Nhap vao so phan tu cua day (n<5): \");\n  scanf(\"%i\", &n);\n  while (n <= 5) {\n    printf(\"Du lieu khong hop le. Nhap vao so phan tu cua day (n<5): \");\n    scanf(\"%i\", &n);\n  }\n  return n;\n"]]}
{"hexsha": "37bfcb619ea9766dcc4d299e8139771526faa0d8", "ext": "c", "lang": "C", "content": "static GtOptionParser* gt_tagerator_option_parser_new(void *tool_arguments)\n{\n  TageratorOptions *arguments = tool_arguments;\n  GtOptionParser *op;\n  GtOption *option, *optionrw, *optiononline, *optioncmp, *optionesaindex,\n           *optionpckindex, *optionmaxdepth, *optionbest;\n\n  gt_assert(arguments != NULL);\n  op = gt_option_parser_new(\"[options] -q tagfile [-esa|-pck] indexname\",\n                         \"Map short sequence tags in given index.\");\n  gt_option_parser_set_mailaddress(op,\"<kurtz@zbh.uni-hamburg.de>\");\n  option = gt_option_new_filenamearray(\"q\",\n                                    \"Specify files containing the short \"\n                                    \"sequence tags\",\n                                    arguments->tagfiles);\n  gt_option_parser_add_option(op, option);\n  gt_option_is_mandatory(option);\n\n  option = gt_option_new_long(\"e\",\n                           \"Specify the allowed number of differences \"\n                           \"(replacements/insertions/deletions)\",\n                           &arguments->userdefinedmaxdistance,\n                           -1L);\n  gt_option_parser_add_option(op, option);\n\n  optionesaindex = gt_option_new_string(\"esa\",\n                                     \"Specify index (enhanced suffix array)\",\n                                     arguments->indexname, NULL);\n  gt_option_parser_add_option(op, optionesaindex);\n  arguments->refoptionesaindex = gt_option_ref(optionesaindex);\n\n  optionpckindex = gt_option_new_string(\"pck\",\n                                     \"Specify index (packed index)\",\n                                     arguments->indexname, NULL);\n  gt_option_parser_add_option(op, optionpckindex);\n  arguments->refoptionpckindex = gt_option_ref(optionpckindex);\n  gt_option_exclude(optionesaindex,optionpckindex);\n  gt_option_is_mandatory_either(optionesaindex,optionpckindex);\n\n  optionmaxdepth = gt_option_new_int(\"maxdepth\",\n                                  \"Use the data in the .pbt file only up to \"\n                                  \"this depth (only relevant with option -pck)\",\n                                  &arguments->userdefinedmaxdepth,\n                                  -1);\n  gt_option_parser_add_option(op, optionmaxdepth);\n  gt_option_is_development_option(optionmaxdepth);\n\n  optiononline = gt_option_new_bool(\"online\",\"Perform online searches\",\n                                    &arguments->doonline, false);\n  gt_option_parser_add_option(op, optiononline);\n  gt_option_is_development_option(optiononline);\n\n  optioncmp = gt_option_new_bool(\"cmp\",\"compare results of offline and online \"\n                                 \"searches\",\n                                 &arguments->docompare, false);\n  gt_option_parser_add_option(op, optioncmp);\n  gt_option_exclude(optiononline,optioncmp);\n  gt_option_is_development_option(optioncmp);\n\n  optionrw = gt_option_new_bool(\"rw\",\"Replace wildcard in tag by random char\",\n                             &arguments->replacewildcard, false);\n  gt_option_parser_add_option(op, optionrw);\n  gt_option_is_development_option(optionrw);\n\n  option = gt_option_new_bool(\"nod\",\"Do not compute direct matches\",\n                           &arguments->nofwdmatch, false);\n  gt_option_parser_add_option(op, option);\n\n  option = gt_option_new_bool(\"nop\",\"Do not compute palindromic matches \"\n                           \"(i.e. no reverse complemented matches.)\",\n                             &arguments->norcmatch, false);\n  gt_option_parser_add_option(op, option);\n\n  optionbest = gt_option_new_bool(\"best\",\"Compute only best matches, i.e. only \"\n                                  \"for smallest edit distance with matches\",\n                                  &arguments->best, false);\n  gt_option_parser_add_option(op, optionbest);\n  gt_option_exclude(optiononline,optionbest);\n  gt_option_exclude(optioncmp,optionbest);\n\n  option = gt_option_new_ulong_min(\"maxocc\",\n                                   \"specify max number of match-occurrences\",\n                                   &arguments->maxintervalwidth,0,1UL);\n  gt_option_parser_add_option(op, option);\n\n  option = gt_option_new_bool(\"skpp\",\n                           \"Skip prefix of pattern (only in pdiff mode)\",\n                           &arguments->skpp, false);\n  gt_option_parser_add_option(op, option);\n\n  option = gt_option_new_bool(\"withwildcards\",\"output matches containing \"\n                              \"wildcard characters (e.g. N); only relevant for \"\n                              \"approximate matching\",\n                              &arguments->nowildcards, true);\n  gt_option_parser_add_option(op, option);\n\n  option = gt_option_new_stringarray(\"output\",\n                                     gt_str_get(arguments->outputhelp),\n                                     arguments->outputspec);\n  gt_option_parser_add_option(op, option);\n\n  option = gt_option_new_verbose(&arguments->verbose);\n  gt_option_parser_add_option(op, option);\n\n  return op;\n}", "item_id": 2, "repo": "jamescasbon/genometools", "file": "src/tools/gt_tagerator.c", "last_update_at": "2018-11-30T20:04:01+00:00", "question_id": "37bfcb619ea9766dcc4d299e8139771526faa0d8_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static GtOptionParser* gt_tagerator_option_parser_new(void *tool_arguments)\n{\n  TageratorOptions *arguments = tool_arguments;\n  GtOptionParser *op;\n  GtOption *option, *optionrw, *optiononline, *optioncmp, *optionesaindex,\n           *optionpckindex, *optionmaxdepth, *optionbest;\n  gt_assert(arguments != NULL);\n  op = gt_option_parser_new(\"[options] -q tagfile [-esa|-pck] indexname\",\n                         \"Map short sequence tags in given index.\");\n  gt_option_parser_set_mailaddress(op,\"<kurtz@zbh.uni-hamburg.de>\");\n  option = gt_option_new_filenamearray(\"q\",\n                                    \"Specify files containing the short \"\n                                    \"sequence tags\",\n                                    arguments->tagfiles);\n  gt_option_parser_add_option(op, option);\n  gt_option_is_mandatory(option);\n  option = gt_option_new_long(\"e\",\n                           \"Specify the allowed number of differences \"\n                           \"(replacements/insertions/deletions)\",\n                           &arguments->userdefinedmaxdistance,\n                           -1L);\n  gt_option_parser_add_option(op, option);\n  optionesaindex = gt_option_new_string(\"esa\",\n                                     \"Specify index (enhanced suffix array)\",\n                                     arguments->indexname, NULL);\n  gt_option_parser_add_option(op, optionesaindex);\n  arguments->refoptionesaindex = gt_option_ref(optionesaindex);\n  optionpckindex = gt_option_new_string(\"pck\",\n                                     \"Specify index (packed index)\",\n                                     arguments->indexname, NULL);\n  gt_option_parser_add_option(op, optionpckindex);\n  arguments->refoptionpckindex = gt_option_ref(optionpckindex);\n  gt_option_exclude(optionesaindex,optionpckindex);\n  gt_option_is_mandatory_either(optionesaindex,optionpckindex);\n  optionmaxdepth = gt_option_new_int(\"maxdepth\",\n                                  \"Use the data in the .pbt file only up to \"\n                                  \"this depth (only relevant with option -pck)\",\n                                  &arguments->userdefinedmaxdepth,\n                                  -1);\n  gt_option_parser_add_option(op, optionmaxdepth);\n  gt_option_is_development_option(optionmaxdepth);\n  optiononline = gt_option_new_bool(\"online\",\"Perform online searches\",\n                                    &arguments->doonline, false);\n  gt_option_parser_add_option(op, optiononline);\n  gt_option_is_development_option(optiononline);\n  optioncmp = gt_option_new_bool(\"cmp\",\"compare results of offline and online \"\n                                 \"searches\",\n                                 &arguments->docompare, false);\n  gt_option_parser_add_option(op, optioncmp);\n  gt_option_exclude(optiononline,optioncmp);\n  gt_option_is_development_option(optioncmp);\n  optionrw = gt_option_new_bool(\"rw\",\"Replace wildcard in tag by random char\",\n                             &arguments->replacewildcard, false);\n  gt_option_parser_add_option(op, optionrw);\n  gt_option_is_development_option(optionrw);\n  option = gt_option_new_bool(\"nod\",\"Do not compute direct matches\",\n                           &arguments->nofwdmatch, false);\n  gt_option_parser_add_option(op, option);\n  option = gt_option_new_bool(\"nop\",\"Do not compute palindromic matches \"\n                           \"(i.e. no reverse complemented matches.)\",\n                             &arguments->norcmatch, false);\n  gt_option_parser_add_option(op, option);\n  optionbest = gt_option_new_bool(\"best\",\"Compute only best matches, i.e. only \"\n                                  \"for smallest edit distance with matches\",\n                                  &arguments->best, false);\n  gt_option_parser_add_option(op, optionbest);\n  gt_option_exclude(optiononline,optionbest);\n  gt_option_exclude(optioncmp,optionbest);\n  option = gt_option_new_ulong_min(\"maxocc\",\n                                   \"specify max number of match-occurrences\",\n                                   &arguments->maxintervalwidth,0,1UL);\n  gt_option_parser_add_option(op, option);\n  option = gt_option_new_bool(\"skpp\",\n                           \"Skip prefix of pattern (only in pdiff mode)\",\n                           &arguments->skpp, false);\n  gt_option_parser_add_option(op, option);\n  option = gt_option_new_bool(\"withwildcards\",\"output matches containing \"\n                              \"wildcard characters (e.g. N); only relevant for \"\n                              \"approximate matching\",\n                              &arguments->nowildcards, true);\n  gt_option_parser_add_option(op, option);\n  option = gt_option_new_stringarray(\"output\",\n                                     gt_str_get(arguments->outputhelp),\n                                     arguments->outputspec);\n  gt_option_parser_add_option(op, option);\n  option = gt_option_new_verbose(&arguments->verbose);\n  gt_option_parser_add_option(op, option);\n  return op;\n"]]}
{"hexsha": "a5c7ff8abd59458ac67e174b927373247ef12d87", "ext": "c", "lang": "C", "content": "void cwrt_task(void *pvParameter)\n{\n    configASSERT(configUSE_RECURSIVE_MUTEXES);\n    vTaskDelay(10);\n    rt_init();\n\tcwrt_setup();\n    unsigned long last = 0;\n    while(1) {\n\t\tcwrt_process(&last);\n        unsigned long now = upTime();\n        if (now < last || now - last > 50) {\n            taskYIELD();\n            last = now;\n        }\n    }\n}", "item_id": 0, "repo": "latproc/clockwork_esp32", "file": "main/clockwork_esp32.c", "last_update_at": "2018-01-22T15:42:02+00:00", "question_id": "a5c7ff8abd59458ac67e174b927373247ef12d87_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void cwrt_task(void *pvParameter)\n{\n    configASSERT(configUSE_RECURSIVE_MUTEXES);\n    vTaskDelay(10);\n    rt_init();\n\tcwrt_setup();\n    unsigned long last = 0;\n    while(1) {\n\t\tcwrt_process(&last);\n        unsigned long now = upTime();\n        if (now < last || now - last > 50) {\n            taskYIELD();\n            last = now;\n        }\n    }\n"]]}
{"hexsha": "6f157363c2b31b14066cf5ef45d92cfbec456031", "ext": "c", "lang": "C", "content": "int\nmain (int argc, char * ARRAY VALIDPTR LOC(PROGRAM_NAME_LOC) * START NONNULL ARRAY SIZE(argc * 4) argv)\n    CHECK_TYPE GLOBAL(PROGRAM_NAME_LOC)\n{\n  exit (EXIT_STATUS);\n\n  // pmr: csolve needs returns before the ends of function bodies to make the heap\n  // constraints work ok\n  return 0;\n}", "item_id": 0, "repo": "ucsd-progsys/csolve-bak", "file": "external/gnu-coreutils/src/true.c", "last_update_at": "2018-04-24T10:43:07+00:00", "question_id": "6f157363c2b31b14066cf5ef45d92cfbec456031_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nmain (int argc, char * ARRAY VALIDPTR LOC(PROGRAM_NAME_LOC) * START NONNULL ARRAY SIZE(argc * 4) argv)\n    CHECK_TYPE GLOBAL(PROGRAM_NAME_LOC)\n{\n  exit (EXIT_STATUS);\n  // pmr: csolve needs returns before the ends of function bodies to make the heap\n  // constraints work ok\n  return 0;\n"]]}
{"hexsha": "b14983e5a0f4f2c9b9d92dd41909a6fa9e6f2a99", "ext": "c", "lang": "C", "content": "EXPORT(sqInt)\nprimitiveDrawString(void)\n{\n    sqInt bitmapOop;\n    void *bitmapPtr;\n    sqInt h;\n    sqInt result;\n    char *utf8;\n    sqInt utf8Length;\n    sqInt utf8Oop;\n    sqInt w;\n\n\tutf8Oop = stackValue(3);\n\t/* begin asCString: */\n\tsuccess(isBytes(utf8Oop));\n\tutf8 = (failed()\n\t\t? 0\n\t\t: ((char *) (firstIndexableField(utf8Oop))));\n\tw = stackIntegerValue(2);\n\th = stackIntegerValue(1);\n\tbitmapOop = stackValue(0);\n\t/* begin cWordsPtr:minSize: */\n\tsuccess((isWords(bitmapOop))\n\t && ((stSizeOf(bitmapOop)) >= (w * h)));\n\tbitmapPtr = (failed()\n\t\t? 0\n\t\t: ((void *) (firstIndexableField(bitmapOop))));\n\tif (failed()) {\n\t\treturn null;\n\t}\n\tutf8Length = stSizeOf(utf8Oop);\n\tunicodeDrawString(utf8, utf8Length, &w, &h, bitmapPtr);\n\tresult = makePointwithxValueyValue(w, h);\n\tpopthenPush(5, result);\n\treturn 0;\n}", "item_id": 3, "repo": "pavel-krivanek/opensmalltalk-vm", "file": "src/plugins/UnicodePlugin/UnicodePlugin.c", "last_update_at": "2018-11-18T16:49:56+00:00", "question_id": "b14983e5a0f4f2c9b9d92dd41909a6fa9e6f2a99_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["EXPORT(sqInt)\nprimitiveDrawString(void)\n{\n    sqInt bitmapOop;\n    void *bitmapPtr;\n    sqInt h;\n    sqInt result;\n    char *utf8;\n    sqInt utf8Length;\n    sqInt utf8Oop;\n    sqInt w;\n\tutf8Oop = stackValue(3);\n\t/* begin asCString: */\n\tsuccess(isBytes(utf8Oop));\n\tutf8 = (failed()\n\t\t? 0\n\t\t: ((char *) (firstIndexableField(utf8Oop))));\n\tw = stackIntegerValue(2);\n\th = stackIntegerValue(1);\n\tbitmapOop = stackValue(0);\n\t/* begin cWordsPtr:minSize: */\n\tsuccess((isWords(bitmapOop))\n\t && ((stSizeOf(bitmapOop)) >= (w * h)));\n\tbitmapPtr = (failed()\n\t\t? 0\n\t\t: ((void *) (firstIndexableField(bitmapOop))));\n\tif (failed()) {\n\t\treturn null;\n\t}\n\tutf8Length = stSizeOf(utf8Oop);\n\tunicodeDrawString(utf8, utf8Length, &w, &h, bitmapPtr);\n\tresult = makePointwithxValueyValue(w, h);\n\tpopthenPush(5, result);\n\treturn 0;\n"]]}
{"hexsha": "f0f5d657ffbdba29fcd65c553f69f3cf5db3f342", "ext": "c", "lang": "C", "content": "stack * createstack (){\n\tstack * new = malloc(sizeof(stack));\n\tnew->top = -1;\n\treturn new;\n}", "item_id": 0, "repo": "ShanManage/UCSC", "file": "1st_sem/DSA/stack/structimpliment.c", "last_update_at": "2018-11-25T14:34:33+00:00", "question_id": "f0f5d657ffbdba29fcd65c553f69f3cf5db3f342_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["stack * createstack (){\n\tstack * new = malloc(sizeof(stack));\n\tnew->top = -1;\n\treturn new;\n"]]}
{"hexsha": "e7cd28714534062c473f49c8139e25a0ca4f2333", "ext": "c", "lang": "C", "content": "static void create_branch_atom(simplex_solver_t *solver, thvar_t x) {\n  xrational_t *bound;\n  int32_t new_idx, lb, ub;\n  literal_t l;\n\n  assert(arith_var_is_int(&solver->vtbl, x) & ! arith_var_value_is_int(&solver->vtbl, x));\n\n  bound = &solver->bound;\n  lb = arith_var_lower_index(&solver->vtbl, x);\n  ub = arith_var_upper_index(&solver->vtbl, x);\n  if (lb >= 0 && ub >= 0) {\n    xq_set(bound, solver->bstack.bound + lb);\n    xq_add(bound, solver->bstack.bound + ub);\n    q_set32(&solver->aux, 2);\n    xq_div(bound, &solver->aux);\n  } else {\n    xq_set(bound, arith_var_value(&solver->vtbl, x));\n  }\n  xq_ceil(bound);\n  assert(xq_is_integer(bound));\n\n#if 0\n  printf(\"\\n---> Branch & bound\\n\\n\");\n  print_simplex_matrix(stdout, solver);\n  print_simplex_bounds(stdout, solver);\n  printf(\"\\n\");\n  print_simplex_assignment(stdout, solver);\n#endif\n\n  l = get_literal_for_ge_atom(&solver->atbl, x, true, &bound->main, &new_idx);\n  solver->last_branch_atom = var_of(l);\n\n  /*\n   * If support periodic calls to make_integer_feasible is enabled,\n   * then the branch atom may not be new.\n   */\n  // assert(new_idx >= 0);\n  if (new_idx >= 0) {\n    build_binary_lemmas_for_atom(solver, x, new_idx);\n    attach_atom_to_arith_var(&solver->vtbl, x, new_idx);\n\n#if TRACE_BB || TRACE_INTFEAS\n    //    printf(\"---> Branch & bound: create \");\n    print_simplex_atomdef(stdout, solver, var_of(l));\n#endif\n\n    solver->stats.num_branch_atoms ++;\n  }\n}", "item_id": 172, "repo": "maelvls/ocamlyices2", "file": "ext/yices/src/solvers/simplex/simplex.c", "last_update_at": "2018-11-23T00:16:01+00:00", "question_id": "e7cd28714534062c473f49c8139e25a0ca4f2333_172", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void create_branch_atom(simplex_solver_t *solver, thvar_t x) {\n  xrational_t *bound;\n  int32_t new_idx, lb, ub;\n  literal_t l;\n  assert(arith_var_is_int(&solver->vtbl, x) & ! arith_var_value_is_int(&solver->vtbl, x));\n  bound = &solver->bound;\n  lb = arith_var_lower_index(&solver->vtbl, x);\n  ub = arith_var_upper_index(&solver->vtbl, x);\n  if (lb >= 0 && ub >= 0) {\n    xq_set(bound, solver->bstack.bound + lb);\n    xq_add(bound, solver->bstack.bound + ub);\n    q_set32(&solver->aux, 2);\n    xq_div(bound, &solver->aux);\n  } else {\n    xq_set(bound, arith_var_value(&solver->vtbl, x));\n  }\n  xq_ceil(bound);\n  assert(xq_is_integer(bound));\n#if 0\n  printf(\"\\n---> Branch & bound\\n\\n\");\n  print_simplex_matrix(stdout, solver);\n  print_simplex_bounds(stdout, solver);\n  printf(\"\\n\");\n  print_simplex_assignment(stdout, solver);\n#endif\n  l = get_literal_for_ge_atom(&solver->atbl, x, true, &bound->main, &new_idx);\n  solver->last_branch_atom = var_of(l);\n  /*\n   * If support periodic calls to make_integer_feasible is enabled,\n   * then the branch atom may not be new.\n   */\n  // assert(new_idx >= 0);\n  if (new_idx >= 0) {\n    build_binary_lemmas_for_atom(solver, x, new_idx);\n    attach_atom_to_arith_var(&solver->vtbl, x, new_idx);\n#if TRACE_BB || TRACE_INTFEAS\n    //    printf(\"---> Branch & bound: create \");\n    print_simplex_atomdef(stdout, solver, var_of(l));\n#endif\n    solver->stats.num_branch_atoms ++;\n  }\n"]]}
{"hexsha": "12fd50a0d39f350216a7bf29648ed4493444da7d", "ext": "c", "lang": "C", "content": "PUBLIC FILE *sys_driver_1(FILE *output, int lines, char *file_name)\n{\n    char path[80];\n\n    if(!(_input_file = fopen(file_name, \"r\"))){\n        sys_searchenv(file_name, \"CGKLIB\", path);   /*Library to be modified....*/\n        if(!*path) {\n            errno = ENOENT;\n            return NULL;\n        }\n\n        if(!(_input_file = fopen(path, \"r\"))){\n            return NULL;\n        }\n    }\n\n    strncpy(_file_name, file_name, sizeof(_file_name));\n    _input_line = 0;\n    sys_driver_2(output, lines);\n\n    return _input_file;\n}", "item_id": 5, "repo": "Mookel/cgkits", "file": "compiler/lib/syslib.c", "last_update_at": "2018-10-09T05:33:13+00:00", "question_id": "12fd50a0d39f350216a7bf29648ed4493444da7d_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["PUBLIC FILE *sys_driver_1(FILE *output, int lines, char *file_name)\n{\n    char path[80];\n    if(!(_input_file = fopen(file_name, \"r\"))){\n        sys_searchenv(file_name, \"CGKLIB\", path);   /*Library to be modified....*/\n        if(!*path) {\n            errno = ENOENT;\n            return NULL;\n        }\n        if(!(_input_file = fopen(path, \"r\"))){\n            return NULL;\n        }\n    }\n    strncpy(_file_name, file_name, sizeof(_file_name));\n    _input_line = 0;\n    sys_driver_2(output, lines);\n    return _input_file;\n"]]}
{"hexsha": "fc0a92ef6cd26feaa8c872f843b1d960bf8f2e90", "ext": "c", "lang": "C", "content": "void peturb(double *lvParam) {\n\t//printf(\"Starting peturb...\\n\");\n\n\tconst double SIGMA = 0.01;\n\t//printf(\"lvParam_before %f, %f, %f\\n\", lvParam[0], lvParam[1], lvParam[2]);\n\tlvParam[0] = lvParam[0] * exp(gsl_ran_gaussian(r, SIGMA));\n\tlvParam[1] = lvParam[1] * exp(gsl_ran_gaussian(r, SIGMA));\n\tlvParam[2] = lvParam[2] * exp(gsl_ran_gaussian(r, SIGMA));\n\t//printf(\"lvParam_after  %f, %f, %f\\n\", lvParam[0], lvParam[1], lvParam[2]);\n}", "item_id": 4, "repo": "scania/scania-pmcmc", "file": "MPI/main/bayeskit.c", "last_update_at": "2018-01-31T04:07:03+00:00", "question_id": "fc0a92ef6cd26feaa8c872f843b1d960bf8f2e90_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void peturb(double *lvParam) {\n\t//printf(\"Starting peturb...\\n\");\n\tconst double SIGMA = 0.01;\n\t//printf(\"lvParam_before %f, %f, %f\\n\", lvParam[0], lvParam[1], lvParam[2]);\n\tlvParam[0] = lvParam[0] * exp(gsl_ran_gaussian(r, SIGMA));\n\tlvParam[1] = lvParam[1] * exp(gsl_ran_gaussian(r, SIGMA));\n\tlvParam[2] = lvParam[2] * exp(gsl_ran_gaussian(r, SIGMA));\n\t//printf(\"lvParam_after  %f, %f, %f\\n\", lvParam[0], lvParam[1], lvParam[2]);\n"]]}
{"hexsha": "cab87f5ce6d377d5686937e9025eb3782f85d79e", "ext": "c", "lang": "C", "content": "static int drv260x_parse_dt(struct device *dev,\n\t\t\t    struct drv260x_data *haptics)\n{\n\tstruct device_node *np = dev->of_node;\n\tunsigned int voltage;\n\tint error;\n\n\terror = of_property_read_u32(np, \"mode\", &haptics->mode);\n\tif (error) {\n\t\tdev_err(dev, \"%s: No entry for mode\\n\", __func__);\n\t\treturn error;\n\t}\n\n\terror = of_property_read_u32(np, \"library-sel\", &haptics->library);\n\tif (error) {\n\t\tdev_err(dev, \"%s: No entry for library selection\\n\",\n\t\t\t__func__);\n\t\treturn error;\n\t}\n\n\terror = of_property_read_u32(np, \"vib-rated-mv\", &voltage);\n\tif (!error)\n\t\thaptics->rated_voltage = drv260x_calculate_voltage(voltage);\n\n\n\terror = of_property_read_u32(np, \"vib-overdrive-mv\", &voltage);\n\tif (!error)\n\t\thaptics->overdrive_voltage = drv260x_calculate_voltage(voltage);\n\n\treturn 0;\n}", "item_id": 4, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/drivers/input/misc/drv260x.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "cab87f5ce6d377d5686937e9025eb3782f85d79e_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int drv260x_parse_dt(struct device *dev,\n\t\t\t    struct drv260x_data *haptics)\n{\n\tstruct device_node *np = dev->of_node;\n\tunsigned int voltage;\n\tint error;\n\terror = of_property_read_u32(np, \"mode\", &haptics->mode);\n\tif (error) {\n\t\tdev_err(dev, \"%s: No entry for mode\\n\", __func__);\n\t\treturn error;\n\t}\n\terror = of_property_read_u32(np, \"library-sel\", &haptics->library);\n\tif (error) {\n\t\tdev_err(dev, \"%s: No entry for library selection\\n\",\n\t\t\t__func__);\n\t\treturn error;\n\t}\n\terror = of_property_read_u32(np, \"vib-rated-mv\", &voltage);\n\tif (!error)\n\t\thaptics->rated_voltage = drv260x_calculate_voltage(voltage);\n\terror = of_property_read_u32(np, \"vib-overdrive-mv\", &voltage);\n\tif (!error)\n\t\thaptics->overdrive_voltage = drv260x_calculate_voltage(voltage);\n\treturn 0;\n"]]}
{"hexsha": "c8f90929df14fcdef90c13c04c0c5a9e503bf47e", "ext": "c", "lang": "C", "content": "static int fpc1020_supply_init(fpc1020_data_t *fpc1020)\n{\n\tint error = 0;\n\n\t/*Determine is we should use external regulator for\n\tpower sully to the bezel. */\n\tif (fpc1020->use_regulator_for_bezel) {\n\t\t/*error = fpc1020_regulator_configure(fpc1020); */\n\t\tif (error) {\n\t\t\tdev_err(&fpc1020->spi->dev,\n\t\t\t\t\t\"fpc1020_probe - regulator configuration failed.\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\t/*error = fpc1020_regulator_set(fpc1020, true);*/\n\t\tif (error) {\n\t\t\tdev_err(&fpc1020->spi->dev,\n\t\t\t\t\t\"fpc1020_probe - regulator enable failed.\\n\");\n\t\t\tgoto err;\n\t\t}\n\t }\n\nerr:\n\treturn error;\n}", "item_id": 12, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/drivers/input/fingerprint/fpc1020_main.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "c8f90929df14fcdef90c13c04c0c5a9e503bf47e_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int fpc1020_supply_init(fpc1020_data_t *fpc1020)\n{\n\tint error = 0;\n\t/*Determine is we should use external regulator for\n\tpower sully to the bezel. */\n\tif (fpc1020->use_regulator_for_bezel) {\n\t\t/*error = fpc1020_regulator_configure(fpc1020); */\n\t\tif (error) {\n\t\t\tdev_err(&fpc1020->spi->dev,\n\t\t\t\t\t\"fpc1020_probe - regulator configuration failed.\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\t/*error = fpc1020_regulator_set(fpc1020, true);*/\n\t\tif (error) {\n\t\t\tdev_err(&fpc1020->spi->dev,\n\t\t\t\t\t\"fpc1020_probe - regulator enable failed.\\n\");\n\t\t\tgoto err;\n\t\t}\n\t }\nerr:\n\treturn error;\n"]]}
{"hexsha": "9ea019461b76d247624a20142ae092ef7e100b28", "ext": "c", "lang": "C", "content": "char *RKLastTwoPartsOfPath(const char *path) {\n    char *a0 = strchr((char *)path, '/');\n    char *a1 = strchr(a0 + 1, '/');\n    char *a2 = strchr(a1 + 1, '/');\n    if (a0 == NULL) {\n        return a0;\n    } else if (a1 != NULL) {\n        if (a2 == NULL) {\n            return a1;\n        } else if (a2 != NULL) {\n            do {\n                a0 = a1;\n                a1 = a2;\n                a2 = strchr(a2 + 1, '/');\n            } while (a2 != NULL);\n        }\n    }\n    return a0 + 1;\n}", "item_id": 16, "repo": "OURadar/radarkit", "file": "source/RKMisc.c", "last_update_at": "2018-03-16T16:41:48+00:00", "question_id": "9ea019461b76d247624a20142ae092ef7e100b28_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["char *RKLastTwoPartsOfPath(const char *path) {\n    char *a0 = strchr((char *)path, '/');\n    char *a1 = strchr(a0 + 1, '/');\n    char *a2 = strchr(a1 + 1, '/');\n    if (a0 == NULL) {\n        return a0;\n    } else if (a1 != NULL) {\n        if (a2 == NULL) {\n            return a1;\n        } else if (a2 != NULL) {\n            do {\n                a0 = a1;\n                a1 = a2;\n                a2 = strchr(a2 + 1, '/');\n            } while (a2 != NULL);\n        }\n    }\n    return a0 + 1;\n"]]}
{"hexsha": "fd8754ce9fdfa65fb27a1e98816c674e8691e1f4", "ext": "c", "lang": "C", "content": "static int\nMHD_poll_all (struct MHD_Daemon *daemon,\n\t      int may_block)\n{\n  unsigned int num_connections;\n  struct MHD_Connection *pos;\n  struct MHD_Connection *next;\n\n  if ( (MHD_USE_SUSPEND_RESUME == (daemon->options & MHD_USE_SUSPEND_RESUME)) &&\n       (MHD_YES == resume_suspended_connections (daemon)) )\n    may_block = MHD_NO;\n\n  /* count number of connections and thus determine poll set size */\n  num_connections = 0;\n  for (pos = daemon->connections_head; NULL != pos; pos = pos->next)\n    num_connections++;\n  {\n    MHD_UNSIGNED_LONG_LONG ltimeout;\n    unsigned int i;\n    int timeout;\n    unsigned int poll_server;\n    int poll_listen;\n    int poll_pipe;\n    struct pollfd *p;\n\n    p = malloc(sizeof (struct pollfd) * (2 + num_connections));\n    if (NULL == p)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG(daemon,\n                 \"Error allocating memory: %s\\n\",\n                 MHD_strerror_(errno));\n#endif\n        return MHD_NO;\n      }\n    memset (p, 0, sizeof (struct pollfd) * (2 + num_connections));\n    poll_server = 0;\n    poll_listen = -1;\n    if ( (MHD_INVALID_SOCKET != daemon->socket_fd) &&\n\t (daemon->connections < daemon->connection_limit) &&\n         (MHD_NO == daemon->at_limit) )\n      {\n\t/* only listen if we are not at the connection limit */\n\tp[poll_server].fd = daemon->socket_fd;\n\tp[poll_server].events = POLLIN;\n\tp[poll_server].revents = 0;\n\tpoll_listen = (int) poll_server;\n\tpoll_server++;\n      }\n    poll_pipe = -1;\n    if (MHD_INVALID_PIPE_ != daemon->wpipe[0])\n      {\n\tp[poll_server].fd = daemon->wpipe[0];\n\tp[poll_server].events = POLLIN;\n\tp[poll_server].revents = 0;\n        poll_pipe = (int) poll_server;\n\tpoll_server++;\n      }\n    if (may_block == MHD_NO)\n      timeout = 0;\n    else if ( (0 != (daemon->options & MHD_USE_THREAD_PER_CONNECTION)) ||\n\t      (MHD_YES != MHD_get_timeout (daemon, &ltimeout)) )\n      timeout = -1;\n    else\n      timeout = (ltimeout > INT_MAX) ? INT_MAX : (int) ltimeout;\n\n    i = 0;\n    for (pos = daemon->connections_head; NULL != pos; pos = pos->next)\n      {\n\tp[poll_server+i].fd = pos->socket_fd;\n\tswitch (pos->event_loop_info)\n\t  {\n\t  case MHD_EVENT_LOOP_INFO_READ:\n\t    p[poll_server+i].events |= POLLIN;\n\t    break;\n\t  case MHD_EVENT_LOOP_INFO_WRITE:\n\t    p[poll_server+i].events |= POLLOUT;\n\t    if (pos->read_buffer_size > pos->read_buffer_offset)\n\t      p[poll_server+i].events |= POLLIN;\n\t    break;\n\t  case MHD_EVENT_LOOP_INFO_BLOCK:\n\t    if (pos->read_buffer_size > pos->read_buffer_offset)\n\t      p[poll_server+i].events |= POLLIN;\n\t    break;\n\t  case MHD_EVENT_LOOP_INFO_CLEANUP:\n\t    timeout = 0; /* clean up \"pos\" immediately */\n\t    break;\n\t  }\n\ti++;\n      }\n    if (0 == poll_server + num_connections)\n      {\n        free(p);\n        return MHD_YES;\n      }\n    if (MHD_sys_poll_(p, poll_server + num_connections, timeout) < 0)\n      {\n\tif (EINTR == MHD_socket_errno_)\n      {\n        free(p);\n        return MHD_YES;\n      }\n#ifdef HAVE_MESSAGES\n\tMHD_DLOG (daemon,\n\t\t  \"poll failed: %s\\n\",\n\t\t  MHD_socket_last_strerr_ ());\n#endif\n        free(p);\n\treturn MHD_NO;\n      }\n    /* handle pipe FD */\n    /* do it before any other processing so\n       new signals will be processed in next loop */\n    if ( (-1 != poll_pipe) &&\n         (0 != (p[poll_pipe].revents & POLLIN)) )\n      MHD_pipe_drain_ (daemon->wpipe[0]);\n\n    /* handle shutdown */\n    if (MHD_YES == daemon->shutdown)\n      {\n        free(p);\n        return MHD_NO;\n      }\n    i = 0;\n    next = daemon->connections_head;\n    while (NULL != (pos = next))\n      {\n\tnext = pos->next;\n        /* first, sanity checks */\n        if (i >= num_connections)\n          continue; /* connection list changed somehow, retry later ... */\n        if (p[poll_server+i].fd != pos->socket_fd)\n          continue; /* fd mismatch, something else happened, retry later ... */\n        call_handlers (pos,\n                       0 != (p[poll_server+i].revents & POLLIN),\n                       0 != (p[poll_server+i].revents & POLLOUT),\n                       MHD_NO);\n      }\n    /* handle 'listen' FD */\n    if ( (-1 != poll_listen) &&\n\t (0 != (p[poll_listen].revents & POLLIN)) )\n      (void) MHD_accept_connection (daemon);\n\n    free(p);\n  }\n  return MHD_YES;\n}", "item_id": 24, "repo": "mfrigillana/sqlnotebook", "file": "ext/libmicrohttpd/mhd/src/microhttpd/daemon.c", "last_update_at": "2018-11-03T06:56:49+00:00", "question_id": "fd8754ce9fdfa65fb27a1e98816c674e8691e1f4_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nMHD_poll_all (struct MHD_Daemon *daemon,\n\t      int may_block)\n{\n  unsigned int num_connections;\n  struct MHD_Connection *pos;\n  struct MHD_Connection *next;\n  if ( (MHD_USE_SUSPEND_RESUME == (daemon->options & MHD_USE_SUSPEND_RESUME)) &&\n       (MHD_YES == resume_suspended_connections (daemon)) )\n    may_block = MHD_NO;\n  /* count number of connections and thus determine poll set size */\n  num_connections = 0;\n  for (pos = daemon->connections_head; NULL != pos; pos = pos->next)\n    num_connections++;\n  {\n    MHD_UNSIGNED_LONG_LONG ltimeout;\n    unsigned int i;\n    int timeout;\n    unsigned int poll_server;\n    int poll_listen;\n    int poll_pipe;\n    struct pollfd *p;\n    p = malloc(sizeof (struct pollfd) * (2 + num_connections));\n    if (NULL == p)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG(daemon,\n                 \"Error allocating memory: %s\\n\",\n                 MHD_strerror_(errno));\n#endif\n        return MHD_NO;\n      }\n    memset (p, 0, sizeof (struct pollfd) * (2 + num_connections));\n    poll_server = 0;\n    poll_listen = -1;\n    if ( (MHD_INVALID_SOCKET != daemon->socket_fd) &&\n\t (daemon->connections < daemon->connection_limit) &&\n         (MHD_NO == daemon->at_limit) )\n      {\n\t/* only listen if we are not at the connection limit */\n\tp[poll_server].fd = daemon->socket_fd;\n\tp[poll_server].events = POLLIN;\n\tp[poll_server].revents = 0;\n\tpoll_listen = (int) poll_server;\n\tpoll_server++;\n      }\n    poll_pipe = -1;\n    if (MHD_INVALID_PIPE_ != daemon->wpipe[0])\n      {\n\tp[poll_server].fd = daemon->wpipe[0];\n\tp[poll_server].events = POLLIN;\n\tp[poll_server].revents = 0;\n        poll_pipe = (int) poll_server;\n\tpoll_server++;\n      }\n    if (may_block == MHD_NO)\n      timeout = 0;\n    else if ( (0 != (daemon->options & MHD_USE_THREAD_PER_CONNECTION)) ||\n\t      (MHD_YES != MHD_get_timeout (daemon, &ltimeout)) )\n      timeout = -1;\n    else\n      timeout = (ltimeout > INT_MAX) ? INT_MAX : (int) ltimeout;\n    i = 0;\n    for (pos = daemon->connections_head; NULL != pos; pos = pos->next)\n      {\n\tp[poll_server+i].fd = pos->socket_fd;\n\tswitch (pos->event_loop_info)\n\t  {\n\t  case MHD_EVENT_LOOP_INFO_READ:\n\t    p[poll_server+i].events |= POLLIN;\n\t    break;\n\t  case MHD_EVENT_LOOP_INFO_WRITE:\n\t    p[poll_server+i].events |= POLLOUT;\n\t    if (pos->read_buffer_size > pos->read_buffer_offset)\n\t      p[poll_server+i].events |= POLLIN;\n\t    break;\n\t  case MHD_EVENT_LOOP_INFO_BLOCK:\n\t    if (pos->read_buffer_size > pos->read_buffer_offset)\n\t      p[poll_server+i].events |= POLLIN;\n\t    break;\n\t  case MHD_EVENT_LOOP_INFO_CLEANUP:\n\t    timeout = 0; /* clean up \"pos\" immediately */\n\t    break;\n\t  }\n\ti++;\n      }\n    if (0 == poll_server + num_connections)\n      {\n        free(p);\n        return MHD_YES;\n      }\n    if (MHD_sys_poll_(p, poll_server + num_connections, timeout) < 0)\n      {\n\tif (EINTR == MHD_socket_errno_)\n      {\n        free(p);\n        return MHD_YES;\n      }\n#ifdef HAVE_MESSAGES\n\tMHD_DLOG (daemon,\n\t\t  \"poll failed: %s\\n\",\n\t\t  MHD_socket_last_strerr_ ());\n#endif\n        free(p);\n\treturn MHD_NO;\n      }\n    /* handle pipe FD */\n    /* do it before any other processing so\n       new signals will be processed in next loop */\n    if ( (-1 != poll_pipe) &&\n         (0 != (p[poll_pipe].revents & POLLIN)) )\n      MHD_pipe_drain_ (daemon->wpipe[0]);\n    /* handle shutdown */\n    if (MHD_YES == daemon->shutdown)\n      {\n        free(p);\n        return MHD_NO;\n      }\n    i = 0;\n    next = daemon->connections_head;\n    while (NULL != (pos = next))\n      {\n\tnext = pos->next;\n        /* first, sanity checks */\n        if (i >= num_connections)\n          continue; /* connection list changed somehow, retry later ... */\n        if (p[poll_server+i].fd != pos->socket_fd)\n          continue; /* fd mismatch, something else happened, retry later ... */\n        call_handlers (pos,\n                       0 != (p[poll_server+i].revents & POLLIN),\n                       0 != (p[poll_server+i].revents & POLLOUT),\n                       MHD_NO);\n      }\n    /* handle 'listen' FD */\n    if ( (-1 != poll_listen) &&\n\t (0 != (p[poll_listen].revents & POLLIN)) )\n      (void) MHD_accept_connection (daemon);\n    free(p);\n  }\n  return MHD_YES;\n"]]}
{"hexsha": "da1610f35a336ac8442985c8798a063e2a6844cf", "ext": "h", "lang": "C", "content": "interface PKPayment : NSObject <NSSecureCoding> {\n    PKContact * _billingContact;\n    PKContact * _shippingContact;\n    PKShippingMethod * _shippingMethod;\n    PKPaymentToken * _token;\n}", "item_id": 0, "repo": "shaojiankui/iOS10-Runtime-Headers", "file": "PrivateFrameworks/PassKitCore.framework/PKPayment.h", "last_update_at": "2018-10-08T04:12:25+00:00", "question_id": "da1610f35a336ac8442985c8798a063e2a6844cf_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface PKPayment : NSObject <NSSecureCoding> {\n    PKContact * _billingContact;\n    PKContact * _shippingContact;\n    PKShippingMethod * _shippingMethod;\n    PKPaymentToken * _token;\n"]]}
{"hexsha": "c4671dfd971444beb4b46dc8c97ddbceafa3ecdf", "ext": "h", "lang": "C", "content": "class People{\npublic:\n\tPeople(Mediator *mediator);\n\t~People();\npublic:\n\tMediator *mediator_;\n}", "item_id": 0, "repo": "HelenXR/design_patterns_HelenXR-Dev-", "file": "behavioral_patterns/mediator/source/people.h", "last_update_at": "2018-10-10T17:17:27+00:00", "question_id": "c4671dfd971444beb4b46dc8c97ddbceafa3ecdf_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class People{\npublic:\n\tPeople(Mediator *mediator);\n\t~People();\npublic:\n\tMediator *mediator_;\n"]]}
{"hexsha": "f2104d16e7b028e38ae3b04a9ee950e63eb8aaf6", "ext": "c", "lang": "C", "content": "void LBF_Disable_EXTI_ExtPort( uint16_t  GPIO_Pin)\n{\n    if ( GPIO_Pin == CONN_POS2_PIN )  //PA6 --> EXTI5_9\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_6); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_6); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_6); \n    }\n    // CAUTION: Conflict if also using INT1_ACC_GYR_PIN (from LSM6DS3)\n    // as it also uses pin6 (PC6)\n\n    if ( GPIO_Pin == CONN_POS3_PIN )  //PA4 --> EXTI4\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_4); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_4); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_4); \n    }\n\n    if ( GPIO_Pin == CONN_POS4_PIN )  //PA3 --> EXTI3\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_3); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_3); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_3); \n    }\n\n    if ( GPIO_Pin == CONN_POS5_PIN )  //PA2 --> EXTI2\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_2); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_2); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_2); \n    }\n\n    if ( GPIO_Pin == CONN_POS7_PIN )  //PA1 --> EXTI1\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_1); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_1); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_1); \n    }\n\n    if ( GPIO_Pin == CONN_POS8_PIN )  //PA0 --> EXTI0\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_0); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_0); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_0); \n    }\n\n    if ( GPIO_Pin == CONN_POS10_PIN )  //PB8 --> EXTI5_9\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_8); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_8); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_8); \n    }\n\n    if ( GPIO_Pin == CONN_POS11_PIN )  //PB9 --> EXTI5_9\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_9); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_9); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_9); \n    }\n\n}", "item_id": 1, "repo": "LimiFrog/LimiFrog-SW", "file": "libraries/LimiFrog-Lib/src/LBF_API/LBF_EXTI_ExtPort_lowlevAPI.c", "last_update_at": "2018-10-24T08:41:06+00:00", "question_id": "f2104d16e7b028e38ae3b04a9ee950e63eb8aaf6_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void LBF_Disable_EXTI_ExtPort( uint16_t  GPIO_Pin)\n{\n    if ( GPIO_Pin == CONN_POS2_PIN )  //PA6 --> EXTI5_9\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_6); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_6); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_6); \n    }\n    // CAUTION: Conflict if also using INT1_ACC_GYR_PIN (from LSM6DS3)\n    // as it also uses pin6 (PC6)\n    if ( GPIO_Pin == CONN_POS3_PIN )  //PA4 --> EXTI4\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_4); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_4); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_4); \n    }\n    if ( GPIO_Pin == CONN_POS4_PIN )  //PA3 --> EXTI3\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_3); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_3); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_3); \n    }\n    if ( GPIO_Pin == CONN_POS5_PIN )  //PA2 --> EXTI2\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_2); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_2); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_2); \n    }\n    if ( GPIO_Pin == CONN_POS7_PIN )  //PA1 --> EXTI1\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_1); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_1); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_1); \n    }\n    if ( GPIO_Pin == CONN_POS8_PIN )  //PA0 --> EXTI0\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_0); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_0); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_0); \n    }\n    if ( GPIO_Pin == CONN_POS10_PIN )  //PB8 --> EXTI5_9\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_8); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_8); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_8); \n    }\n    if ( GPIO_Pin == CONN_POS11_PIN )  //PB9 --> EXTI5_9\n    {\n        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_9); \n        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_9); \n        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_9); \n    }\n"]]}
{"hexsha": "7562b9526edd0dbcf7925ed77b06d0420ed0c75b", "ext": "c", "lang": "C", "content": "int32_t aos_pwrmgmt_wifi_powersave_suspend(uint32_t suspend_module)\n{\n    int32_t ret;\n\n    ret = pwrmgmt_wifi_powersave_suspend(suspend_module);\n    return ret;\n}", "item_id": 6, "repo": "HelloAllen8893/AliOS-Things", "file": "core/osal/aos/pwrmgmt.c", "last_update_at": "2018-11-28T03:19:22+00:00", "question_id": "7562b9526edd0dbcf7925ed77b06d0420ed0c75b_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int32_t aos_pwrmgmt_wifi_powersave_suspend(uint32_t suspend_module)\n{\n    int32_t ret;\n    ret = pwrmgmt_wifi_powersave_suspend(suspend_module);\n    return ret;\n"]]}
{"hexsha": "6830c84fa7de231061b7cbc7a0e6b49a89f28bd3", "ext": "c", "lang": "C", "content": "static value redirect( value s ) {\n\tmcontext *c = CONTEXT();\n\tval_check(s,string);\n\tHEADERS_NOT_SENT(\"Redirection\");\n\tap_table_set(c->r->headers_out,\"Location\",val_string(s));\n\tc->r->status = REDIRECT;\n\treturn val_true;\n}", "item_id": 3, "repo": "r-lyeh/scriptorium", "file": "neko/src/libs/mod_neko/cgi.c", "last_update_at": "2018-01-08T03:02:37+00:00", "question_id": "6830c84fa7de231061b7cbc7a0e6b49a89f28bd3_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static value redirect( value s ) {\n\tmcontext *c = CONTEXT();\n\tval_check(s,string);\n\tHEADERS_NOT_SENT(\"Redirection\");\n\tap_table_set(c->r->headers_out,\"Location\",val_string(s));\n\tc->r->status = REDIRECT;\n\treturn val_true;\n"]]}
{"hexsha": "3f37565a6090a282ad57626de8cc5f592d921aac", "ext": "c", "lang": "C", "content": "void print_pfxt(const struct pfx_record *pfx_record, void *data)\n{\n  char ip_pfx[INET6_ADDRSTRLEN];\n  char rec[TEST_BUF_LEN];\n  lrtr_ip_addr_to_str(&(*pfx_record).prefix, ip_pfx, sizeof(ip_pfx));\n  snprintf(rec, sizeof(rec), \"%\" PRIu32 \",%s/%\" PRIu8 \",%\" PRIu8 \"\\n\",\n           (*pfx_record).asn, ip_pfx, (*pfx_record).min_len,\n           (*pfx_record).max_len);\n  strcat((char *)data, rec);\n}", "item_id": 0, "repo": "salsh/libhistoryrpki", "file": "test/roafetchlib-test-config.c", "last_update_at": "2018-08-07T16:15:11+00:00", "question_id": "3f37565a6090a282ad57626de8cc5f592d921aac_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void print_pfxt(const struct pfx_record *pfx_record, void *data)\n{\n  char ip_pfx[INET6_ADDRSTRLEN];\n  char rec[TEST_BUF_LEN];\n  lrtr_ip_addr_to_str(&(*pfx_record).prefix, ip_pfx, sizeof(ip_pfx));\n  snprintf(rec, sizeof(rec), \"%\" PRIu32 \",%s/%\" PRIu8 \",%\" PRIu8 \"\\n\",\n           (*pfx_record).asn, ip_pfx, (*pfx_record).min_len,\n           (*pfx_record).max_len);\n  strcat((char *)data, rec);\n"]]}
{"hexsha": "2a511de37361d5dd5980337de8f35cb5e4df4314", "ext": "c", "lang": "C", "content": "size_t wcstombs(char* mbstr, const wchar_t *wcstr, size_t max)\n{\n  int count = 0;\n\n  while ((count < max) && (*wcstr != 0))\n  {\n    *mbstr++ = *wcstr++;\n    count++;\n  }\n  return count;\n}", "item_id": 1, "repo": "lunixbochs/ags", "file": "Android/library/jni/libc.c", "last_update_at": "2018-03-29T11:50:29+00:00", "question_id": "2a511de37361d5dd5980337de8f35cb5e4df4314_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["size_t wcstombs(char* mbstr, const wchar_t *wcstr, size_t max)\n{\n  int count = 0;\n  while ((count < max) && (*wcstr != 0))\n  {\n    *mbstr++ = *wcstr++;\n    count++;\n  }\n  return count;\n"]]}
{"hexsha": "3237c2875448890e183441754d4993ba5578d690", "ext": "h", "lang": "C", "content": "static inline uint16 fold_32bit_checksum (uint32 sum)\n{\n   /*  Fold 32-bit sum to 16 bits */\n   while (sum>>16) {\n      sum = (sum & 0xffff) + (sum >> 16);\n   }\n   sum = ~sum & 0xffff;\n   if (sum == 0) {\n      sum = 0xffff;\n   }\n   return (sum);\n}", "item_id": 0, "repo": "aaliomer/exos", "file": "include/exos/netinet/cksum.h", "last_update_at": "2018-01-23T23:07:19+00:00", "question_id": "3237c2875448890e183441754d4993ba5578d690_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline uint16 fold_32bit_checksum (uint32 sum)\n{\n   /*  Fold 32-bit sum to 16 bits */\n   while (sum>>16) {\n      sum = (sum & 0xffff) + (sum >> 16);\n   }\n   sum = ~sum & 0xffff;\n   if (sum == 0) {\n      sum = 0xffff;\n   }\n   return (sum);\n"]]}
{"hexsha": "f137cbe98ad9927271ef0e85122efb8b856d3018", "ext": "c", "lang": "C", "content": "void __glXDispSwap_TexImage2D(GLbyte * pc)\n{\n    const GLvoid * const pixels = (const GLvoid *) (pc + 52);\n    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);\n\n    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );\n    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );\n    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) bswap_CARD32( & hdr->rowLength )) );\n    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) bswap_CARD32( & hdr->skipRows )) );\n    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) bswap_CARD32( & hdr->skipPixels )) );\n    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) bswap_CARD32( & hdr->alignment )) );\n\n    CALL_TexImage2D( GET_DISPATCH(), (\n         (GLenum  )bswap_ENUM   ( pc + 20 ),\n         (GLint   )bswap_CARD32 ( pc + 24 ),\n         (GLint   )bswap_CARD32 ( pc + 28 ),\n         (GLsizei )bswap_CARD32 ( pc + 32 ),\n         (GLsizei )bswap_CARD32 ( pc + 36 ),\n         (GLint   )bswap_CARD32 ( pc + 40 ),\n         (GLenum  )bswap_ENUM   ( pc + 44 ),\n         (GLenum  )bswap_ENUM   ( pc + 48 ),\n        pixels\n    ) );\n}", "item_id": 26, "repo": "larsclausen/xglamo", "file": "glx/indirect_dispatch_swap.c", "last_update_at": "2018-11-01T06:58:35+00:00", "question_id": "f137cbe98ad9927271ef0e85122efb8b856d3018_26", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void __glXDispSwap_TexImage2D(GLbyte * pc)\n{\n    const GLvoid * const pixels = (const GLvoid *) (pc + 52);\n    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);\n    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );\n    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );\n    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) bswap_CARD32( & hdr->rowLength )) );\n    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) bswap_CARD32( & hdr->skipRows )) );\n    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) bswap_CARD32( & hdr->skipPixels )) );\n    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) bswap_CARD32( & hdr->alignment )) );\n    CALL_TexImage2D( GET_DISPATCH(), (\n         (GLenum  )bswap_ENUM   ( pc + 20 ),\n         (GLint   )bswap_CARD32 ( pc + 24 ),\n         (GLint   )bswap_CARD32 ( pc + 28 ),\n         (GLsizei )bswap_CARD32 ( pc + 32 ),\n         (GLsizei )bswap_CARD32 ( pc + 36 ),\n         (GLint   )bswap_CARD32 ( pc + 40 ),\n         (GLenum  )bswap_ENUM   ( pc + 44 ),\n         (GLenum  )bswap_ENUM   ( pc + 48 ),\n        pixels\n    ) );\n"]]}
{"hexsha": "a29aec400085a6a10fb93ec306d1caa0c6ee84dc", "ext": "c", "lang": "C", "content": "VALUE\nrb_rational_uminus(VALUE self)\n{\n    const int unused = (assert(RB_TYPE_P(self, T_RATIONAL)), 0);\n    get_dat1(self);\n    (void)unused;\n    return f_rational_new2(CLASS_OF(self), rb_int_uminus(dat->num), dat->den);\n}", "item_id": 15, "repo": "tenebrousedge/ruby-packer", "file": "ruby/rational.c", "last_update_at": "2018-04-01T14:10:23+00:00", "question_id": "a29aec400085a6a10fb93ec306d1caa0c6ee84dc_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["VALUE\nrb_rational_uminus(VALUE self)\n{\n    const int unused = (assert(RB_TYPE_P(self, T_RATIONAL)), 0);\n    get_dat1(self);\n    (void)unused;\n    return f_rational_new2(CLASS_OF(self), rb_int_uminus(dat->num), dat->den);\n"]]}
{"hexsha": "c03997e33ffd6e6a6f377f305763b867d87ff445", "ext": "h", "lang": "C", "content": "class Att_relay : public TinyMachine {\n  \n    public:\n      Att_relay( void ) : TinyMachine() {};\n  \n      short relay_pin;\n      short led_pin;\n             \n      enum { OFF, ON, BLINK_ON, BLINK_OFF } STATES; \n      enum { EVT_TIMER, EVT_COUNTER_ON,EVT_COUNTER_OFF, EVT_TOGGLE, ELSE } EVENTS; \n      enum { ACT_LED_OFF, ACT_LED_ON, ACT_RELAY_ON, ACT_RELAY_OFF } ACTIONS; \n      // store prev relay state while blinking, so after blink know to blink on or off.\n      bool prev_relay_state;\n\n      short on_blink = 3;\n      short off_blink = 5;\n      atm_timer_millis timer;\n      atm_counter counter_on, counter_off;  \n      \n      Att_relay & begin( short relay_pin, short l_pin);\n\n      Att_relay & setBlink( short repeat, bool on_off ) ;\n\n  \n      int event( int id );\n  \n      void action( int id ); \n  \n  }", "item_id": 0, "repo": "harmon25/Atm_custom", "file": "Att_relay.h", "last_update_at": "2018-01-11T01:54:12+00:00", "question_id": "c03997e33ffd6e6a6f377f305763b867d87ff445_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Att_relay : public TinyMachine {\n    public:\n      Att_relay( void ) : TinyMachine() {};\n      short relay_pin;\n      short led_pin;\n      enum { OFF, ON, BLINK_ON, BLINK_OFF } STATES; \n      enum { EVT_TIMER, EVT_COUNTER_ON,EVT_COUNTER_OFF, EVT_TOGGLE, ELSE } EVENTS; \n      enum { ACT_LED_OFF, ACT_LED_ON, ACT_RELAY_ON, ACT_RELAY_OFF } ACTIONS; \n      // store prev relay state while blinking, so after blink know to blink on or off.\n      bool prev_relay_state;\n      short on_blink = 3;\n      short off_blink = 5;\n      atm_timer_millis timer;\n      atm_counter counter_on, counter_off;  \n      Att_relay & begin( short relay_pin, short l_pin);\n      Att_relay & setBlink( short repeat, bool on_off ) ;\n      int event( int id );\n      void action( int id ); \n"]]}
{"hexsha": "7591d8901f9a24ddd61d035500116c617e4df3f6", "ext": "c", "lang": "C", "content": "static int tegra_sor_dp_train_fast(struct tegra_sor *sor,\n\t\t\t\t   struct drm_dp_link *link)\n{\n\tunsigned int i;\n\tu8 pattern;\n\tu32 value;\n\tint err;\n\n\t/* setup lane parameters */\n\tvalue = SOR_LANE_DRIVE_CURRENT_LANE3(0x40) |\n\t\tSOR_LANE_DRIVE_CURRENT_LANE2(0x40) |\n\t\tSOR_LANE_DRIVE_CURRENT_LANE1(0x40) |\n\t\tSOR_LANE_DRIVE_CURRENT_LANE0(0x40);\n\ttegra_sor_writel(sor, value, SOR_LANE_DRIVE_CURRENT_0);\n\n\tvalue = SOR_LANE_PREEMPHASIS_LANE3(0x0f) |\n\t\tSOR_LANE_PREEMPHASIS_LANE2(0x0f) |\n\t\tSOR_LANE_PREEMPHASIS_LANE1(0x0f) |\n\t\tSOR_LANE_PREEMPHASIS_LANE0(0x0f);\n\ttegra_sor_writel(sor, value, SOR_LANE_PREEMPHASIS_0);\n\n\tvalue = SOR_LANE_POST_CURSOR_LANE3(0x00) |\n\t\tSOR_LANE_POST_CURSOR_LANE2(0x00) |\n\t\tSOR_LANE_POST_CURSOR_LANE1(0x00) |\n\t\tSOR_LANE_POST_CURSOR_LANE0(0x00);\n\ttegra_sor_writel(sor, value, SOR_LANE_POST_CURSOR_0);\n\n\t/* disable LVDS mode */\n\ttegra_sor_writel(sor, 0, SOR_LVDS);\n\n\tvalue = tegra_sor_readl(sor, SOR_DP_PADCTL_0);\n\tvalue |= SOR_DP_PADCTL_TX_PU_ENABLE;\n\tvalue &= ~SOR_DP_PADCTL_TX_PU_MASK;\n\tvalue |= SOR_DP_PADCTL_TX_PU(2); /* XXX: don't hardcode? */\n\ttegra_sor_writel(sor, value, SOR_DP_PADCTL_0);\n\n\tvalue = tegra_sor_readl(sor, SOR_DP_PADCTL_0);\n\tvalue |= SOR_DP_PADCTL_CM_TXD_3 | SOR_DP_PADCTL_CM_TXD_2 |\n\t\t SOR_DP_PADCTL_CM_TXD_1 | SOR_DP_PADCTL_CM_TXD_0;\n\ttegra_sor_writel(sor, value, SOR_DP_PADCTL_0);\n\n\tusleep_range(10, 100);\n\n\tvalue = tegra_sor_readl(sor, SOR_DP_PADCTL_0);\n\tvalue &= ~(SOR_DP_PADCTL_CM_TXD_3 | SOR_DP_PADCTL_CM_TXD_2 |\n\t\t   SOR_DP_PADCTL_CM_TXD_1 | SOR_DP_PADCTL_CM_TXD_0);\n\ttegra_sor_writel(sor, value, SOR_DP_PADCTL_0);\n\n\terr = tegra_dpaux_prepare(sor->dpaux, DP_SET_ANSI_8B10B);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0, value = 0; i < link->num_lanes; i++) {\n\t\tunsigned long lane = SOR_DP_TPG_CHANNEL_CODING |\n\t\t\t\t     SOR_DP_TPG_SCRAMBLER_NONE |\n\t\t\t\t     SOR_DP_TPG_PATTERN_TRAIN1;\n\t\tvalue = (value << 8) | lane;\n\t}\n\n\ttegra_sor_writel(sor, value, SOR_DP_TPG);\n\n\tpattern = DP_TRAINING_PATTERN_1;\n\n\terr = tegra_dpaux_train(sor->dpaux, link, pattern);\n\tif (err < 0)\n\t\treturn err;\n\n\tvalue = tegra_sor_readl(sor, SOR_DP_SPARE_0);\n\tvalue |= SOR_DP_SPARE_SEQ_ENABLE;\n\tvalue &= ~SOR_DP_SPARE_PANEL_INTERNAL;\n\tvalue |= SOR_DP_SPARE_MACRO_SOR_CLK;\n\ttegra_sor_writel(sor, value, SOR_DP_SPARE_0);\n\n\tfor (i = 0, value = 0; i < link->num_lanes; i++) {\n\t\tunsigned long lane = SOR_DP_TPG_CHANNEL_CODING |\n\t\t\t\t     SOR_DP_TPG_SCRAMBLER_NONE |\n\t\t\t\t     SOR_DP_TPG_PATTERN_TRAIN2;\n\t\tvalue = (value << 8) | lane;\n\t}\n\n\ttegra_sor_writel(sor, value, SOR_DP_TPG);\n\n\tpattern = DP_LINK_SCRAMBLING_DISABLE | DP_TRAINING_PATTERN_2;\n\n\terr = tegra_dpaux_train(sor->dpaux, link, pattern);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0, value = 0; i < link->num_lanes; i++) {\n\t\tunsigned long lane = SOR_DP_TPG_CHANNEL_CODING |\n\t\t\t\t     SOR_DP_TPG_SCRAMBLER_GALIOS |\n\t\t\t\t     SOR_DP_TPG_PATTERN_NONE;\n\t\tvalue = (value << 8) | lane;\n\t}\n\n\ttegra_sor_writel(sor, value, SOR_DP_TPG);\n\n\tpattern = DP_TRAINING_PATTERN_DISABLE;\n\n\terr = tegra_dpaux_train(sor->dpaux, link, pattern);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}", "item_id": 0, "repo": "SIIS-cloud/pileus", "file": "difc-kernel/pileus-kernel/drivers/gpu/drm/tegra/sor.c", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "7591d8901f9a24ddd61d035500116c617e4df3f6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int tegra_sor_dp_train_fast(struct tegra_sor *sor,\n\t\t\t\t   struct drm_dp_link *link)\n{\n\tunsigned int i;\n\tu8 pattern;\n\tu32 value;\n\tint err;\n\t/* setup lane parameters */\n\tvalue = SOR_LANE_DRIVE_CURRENT_LANE3(0x40) |\n\t\tSOR_LANE_DRIVE_CURRENT_LANE2(0x40) |\n\t\tSOR_LANE_DRIVE_CURRENT_LANE1(0x40) |\n\t\tSOR_LANE_DRIVE_CURRENT_LANE0(0x40);\n\ttegra_sor_writel(sor, value, SOR_LANE_DRIVE_CURRENT_0);\n\tvalue = SOR_LANE_PREEMPHASIS_LANE3(0x0f) |\n\t\tSOR_LANE_PREEMPHASIS_LANE2(0x0f) |\n\t\tSOR_LANE_PREEMPHASIS_LANE1(0x0f) |\n\t\tSOR_LANE_PREEMPHASIS_LANE0(0x0f);\n\ttegra_sor_writel(sor, value, SOR_LANE_PREEMPHASIS_0);\n\tvalue = SOR_LANE_POST_CURSOR_LANE3(0x00) |\n\t\tSOR_LANE_POST_CURSOR_LANE2(0x00) |\n\t\tSOR_LANE_POST_CURSOR_LANE1(0x00) |\n\t\tSOR_LANE_POST_CURSOR_LANE0(0x00);\n\ttegra_sor_writel(sor, value, SOR_LANE_POST_CURSOR_0);\n\t/* disable LVDS mode */\n\ttegra_sor_writel(sor, 0, SOR_LVDS);\n\tvalue = tegra_sor_readl(sor, SOR_DP_PADCTL_0);\n\tvalue |= SOR_DP_PADCTL_TX_PU_ENABLE;\n\tvalue &= ~SOR_DP_PADCTL_TX_PU_MASK;\n\tvalue |= SOR_DP_PADCTL_TX_PU(2); /* XXX: don't hardcode? */\n\ttegra_sor_writel(sor, value, SOR_DP_PADCTL_0);\n\tvalue = tegra_sor_readl(sor, SOR_DP_PADCTL_0);\n\tvalue |= SOR_DP_PADCTL_CM_TXD_3 | SOR_DP_PADCTL_CM_TXD_2 |\n\t\t SOR_DP_PADCTL_CM_TXD_1 | SOR_DP_PADCTL_CM_TXD_0;\n\ttegra_sor_writel(sor, value, SOR_DP_PADCTL_0);\n\tusleep_range(10, 100);\n\tvalue = tegra_sor_readl(sor, SOR_DP_PADCTL_0);\n\tvalue &= ~(SOR_DP_PADCTL_CM_TXD_3 | SOR_DP_PADCTL_CM_TXD_2 |\n\t\t   SOR_DP_PADCTL_CM_TXD_1 | SOR_DP_PADCTL_CM_TXD_0);\n\ttegra_sor_writel(sor, value, SOR_DP_PADCTL_0);\n\terr = tegra_dpaux_prepare(sor->dpaux, DP_SET_ANSI_8B10B);\n\tif (err < 0)\n\t\treturn err;\n\tfor (i = 0, value = 0; i < link->num_lanes; i++) {\n\t\tunsigned long lane = SOR_DP_TPG_CHANNEL_CODING |\n\t\t\t\t     SOR_DP_TPG_SCRAMBLER_NONE |\n\t\t\t\t     SOR_DP_TPG_PATTERN_TRAIN1;\n\t\tvalue = (value << 8) | lane;\n\t}\n\ttegra_sor_writel(sor, value, SOR_DP_TPG);\n\tpattern = DP_TRAINING_PATTERN_1;\n\terr = tegra_dpaux_train(sor->dpaux, link, pattern);\n\tif (err < 0)\n\t\treturn err;\n\tvalue = tegra_sor_readl(sor, SOR_DP_SPARE_0);\n\tvalue |= SOR_DP_SPARE_SEQ_ENABLE;\n\tvalue &= ~SOR_DP_SPARE_PANEL_INTERNAL;\n\tvalue |= SOR_DP_SPARE_MACRO_SOR_CLK;\n\ttegra_sor_writel(sor, value, SOR_DP_SPARE_0);\n\tfor (i = 0, value = 0; i < link->num_lanes; i++) {\n\t\tunsigned long lane = SOR_DP_TPG_CHANNEL_CODING |\n\t\t\t\t     SOR_DP_TPG_SCRAMBLER_NONE |\n\t\t\t\t     SOR_DP_TPG_PATTERN_TRAIN2;\n\t\tvalue = (value << 8) | lane;\n\t}\n\ttegra_sor_writel(sor, value, SOR_DP_TPG);\n\tpattern = DP_LINK_SCRAMBLING_DISABLE | DP_TRAINING_PATTERN_2;\n\terr = tegra_dpaux_train(sor->dpaux, link, pattern);\n\tif (err < 0)\n\t\treturn err;\n\tfor (i = 0, value = 0; i < link->num_lanes; i++) {\n\t\tunsigned long lane = SOR_DP_TPG_CHANNEL_CODING |\n\t\t\t\t     SOR_DP_TPG_SCRAMBLER_GALIOS |\n\t\t\t\t     SOR_DP_TPG_PATTERN_NONE;\n\t\tvalue = (value << 8) | lane;\n\t}\n\ttegra_sor_writel(sor, value, SOR_DP_TPG);\n\tpattern = DP_TRAINING_PATTERN_DISABLE;\n\terr = tegra_dpaux_train(sor->dpaux, link, pattern);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n"]]}
{"hexsha": "975b78e6bb712e43333475591cfa8b98746d155a", "ext": "h", "lang": "C", "content": "class ClosedCube_TCA9538 {\npublic:\n\tClosedCube_TCA9538();\n\n\tvoid begin(uint8_t address);\n\tvoid init(TCA9538_Registers regs);\n\n\tTCA9538_Input readInput();\n\n\tvoid writePolarity(TCA9538_PolarityInversion polarity);\n\t\n\tvoid writeOutput(TCA9538_Output output);\n\tTCA9538_Output readOutput();\n\n\tvoid writeConfig(TCA9538_Config config);\n\nprivate:\n\n\tuint8_t writeData(TCA9538_Commands cmd, uint8_t rawData);\n\tuint8_t _address;\n}", "item_id": 0, "repo": "closedcube/ClosedCube_TCA9538_Arduino", "file": "src/ClosedCube_TCA9538.h", "last_update_at": "2018-07-16T23:04:17+00:00", "question_id": "975b78e6bb712e43333475591cfa8b98746d155a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class ClosedCube_TCA9538 {\npublic:\n\tClosedCube_TCA9538();\n\tvoid begin(uint8_t address);\n\tvoid init(TCA9538_Registers regs);\n\tTCA9538_Input readInput();\n\tvoid writePolarity(TCA9538_PolarityInversion polarity);\n\t\n\tvoid writeOutput(TCA9538_Output output);\n\tTCA9538_Output readOutput();\n\tvoid writeConfig(TCA9538_Config config);\nprivate:\n\tuint8_t writeData(TCA9538_Commands cmd, uint8_t rawData);\n\tuint8_t _address;\n"]]}
{"hexsha": "2f44617c4687e7c91e628440ca23b94a7610af92", "ext": "c", "lang": "C", "content": "int16_t st_ulaw2linear16(\r\n\tunsigned char\tu_val)\r\n{\r\n\tint16_t\t\tt;\r\n\r\n\t/* Complement to obtain normal u-law value. */\r\n\tu_val = ~u_val;\r\n\r\n\t/*\r\n\t * Extract and bias the quantization bits. Then\r\n\t * shift up by the segment number and subtract out the bias.\r\n\t */\r\n\tt = ((u_val & QUANT_MASK) << 3) + BIAS;\r\n\tt <<= ((unsigned)u_val & SEG_MASK) >> SEG_SHIFT;\r\n\r\n\treturn ((u_val & SIGN_BIT) ? (BIAS - t) : (t - BIAS));\r\n}", "item_id": 4, "repo": "PFigs/portfolio", "file": "Integrated Services Networks (C)/source/g711.c", "last_update_at": "2018-09-07T09:27:18+00:00", "question_id": "2f44617c4687e7c91e628440ca23b94a7610af92_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int16_t st_ulaw2linear16(\r\n\tunsigned char\tu_val)\r\n{\r\n\tint16_t\t\tt;\r\n\r\n\t/* Complement to obtain normal u-law value. */\r\n\tu_val = ~u_val;\r\n\r\n\t/*\r\n\t * Extract and bias the quantization bits. Then\r\n\t * shift up by the segment number and subtract out the bias.\r\n\t */\r\n\tt = ((u_val & QUANT_MASK) << 3) + BIAS;\r\n\tt <<= ((unsigned)u_val & SEG_MASK) >> SEG_SHIFT;\r\n\r\n\treturn ((u_val & SIGN_BIT) ? (BIAS - t) : (t - BIAS));\r\n"]]}
{"hexsha": "23256ddc014602ea2e0ee0fa1cecfde1bbe33704", "ext": "c", "lang": "C", "content": "void cdbdisp_clearCdbPgResults(CdbPgResults* cdb_pgresults)\n{\n\tint i = 0;\n\n\tif (!cdb_pgresults)\n\t\treturn;\n\n\tfor (i = 0; i < cdb_pgresults->numResults; i++)\n\t\tPQclear(cdb_pgresults->pg_results[i]);\n\n\tcdb_pgresults->numResults = 0;\n}", "item_id": 19, "repo": "hellomokey/gp", "file": "src/backend/cdb/dispatcher/cdbdispatchresult.c", "last_update_at": "2018-11-26T07:09:44+00:00", "question_id": "23256ddc014602ea2e0ee0fa1cecfde1bbe33704_19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void cdbdisp_clearCdbPgResults(CdbPgResults* cdb_pgresults)\n{\n\tint i = 0;\n\tif (!cdb_pgresults)\n\t\treturn;\n\tfor (i = 0; i < cdb_pgresults->numResults; i++)\n\t\tPQclear(cdb_pgresults->pg_results[i]);\n\tcdb_pgresults->numResults = 0;\n"]]}
{"hexsha": "72ff10a4de7baffd8adb3a0195cad67ba439e179", "ext": "h", "lang": "C", "content": "double operator[](size_t i) const\r\n    {\r\n        assert(i < 3);\r\n        double* res = (double*)&m_v;\r\n        return res[i];\r\n    }", "item_id": 0, "repo": "dentoyan/e3vector", "file": "e3vector.h", "last_update_at": "2018-12-11T09:42:46+00:00", "question_id": "72ff10a4de7baffd8adb3a0195cad67ba439e179_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["double operator[](size_t i) const\r\n    {\r\n        assert(i < 3);\r\n        double* res = (double*)&m_v;\r\n        return res[i];\r\n"]]}
{"hexsha": "336b06586c00d14f8cfa7f189181d6dd35b54f08", "ext": "c", "lang": "C", "content": "int olio_socket_create(olio_socket * sock)\n{\n  sock->socket = socket(PF_INET, SOCK_STREAM|SOCK_DGRAM, 0);\n  if (sock->socket < 0)\n    return 1;\n  if (fcntl(sock->socket, F_SETFL, O_NONBLOCK) != 0)\n    return 1;\n\n  SO_KEEPALIVE\nSO_REUSEADDR\n\n}", "item_id": 0, "repo": "jabr/olio", "file": "socket.c", "last_update_at": "2018-11-25T05:53:52+00:00", "question_id": "336b06586c00d14f8cfa7f189181d6dd35b54f08_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int olio_socket_create(olio_socket * sock)\n{\n  sock->socket = socket(PF_INET, SOCK_STREAM|SOCK_DGRAM, 0);\n  if (sock->socket < 0)\n    return 1;\n  if (fcntl(sock->socket, F_SETFL, O_NONBLOCK) != 0)\n    return 1;\n  SO_KEEPALIVE\nSO_REUSEADDR\n"]]}
{"hexsha": "05594430cb378d518d4a0bd550f3c5613d57fad0", "ext": "c", "lang": "C", "content": "static void*\nbuild_hpet(void)\n{\n    struct acpi_20_hpet *hpet = malloc_high(sizeof(*hpet));\n    if (!hpet) {\n        warn_noalloc();\n        return NULL;\n    }\n\n    memset(hpet, 0, sizeof(*hpet));\n    /* Note timer_block_id value must be kept in sync with value advertised by\n     * emulated hpet\n     */\n    hpet->timer_block_id = cpu_to_le32(0x8086a201);\n    hpet->addr.address = cpu_to_le32(ACPI_HPET_ADDRESS);\n    build_header((void*)hpet, HPET_SIGNATURE, sizeof(*hpet), 1);\n\n    return hpet;\n}", "item_id": 4, "repo": "silverneko/HWs", "file": "qemu-shack-ibtc/roms/seabios/src/acpi.c", "last_update_at": "2018-05-15T00:12:19+00:00", "question_id": "05594430cb378d518d4a0bd550f3c5613d57fad0_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void*\nbuild_hpet(void)\n{\n    struct acpi_20_hpet *hpet = malloc_high(sizeof(*hpet));\n    if (!hpet) {\n        warn_noalloc();\n        return NULL;\n    }\n    memset(hpet, 0, sizeof(*hpet));\n    /* Note timer_block_id value must be kept in sync with value advertised by\n     * emulated hpet\n     */\n    hpet->timer_block_id = cpu_to_le32(0x8086a201);\n    hpet->addr.address = cpu_to_le32(ACPI_HPET_ADDRESS);\n    build_header((void*)hpet, HPET_SIGNATURE, sizeof(*hpet), 1);\n    return hpet;\n"]]}
{"hexsha": "33a414b4ebe05992543d49bda2717e96d4a88215", "ext": "c", "lang": "C", "content": "const char *region_file_name(int n) \n{  \n  region *r;\n  r = id_to_region(n);\n  if (r) \n    return(r->name); \n  return(NULL);\n}", "item_id": 6, "repo": "OS2World/MM-SOUND-Snd", "file": "sources/snd-region.c", "last_update_at": "2018-08-27T17:57:08+00:00", "question_id": "33a414b4ebe05992543d49bda2717e96d4a88215_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["const char *region_file_name(int n) \n{  \n  region *r;\n  r = id_to_region(n);\n  if (r) \n    return(r->name); \n  return(NULL);\n"]]}
{"hexsha": "18dd4b7fb18f09455bd9953e6900c5c3159d110c", "ext": "c", "lang": "C", "content": "struct circle *new_contact_circle (struct surface *this_srf, struct torus *torus_ptr, int which_side) \n{\n\tint k;\n\tdouble signed_distance, circle_radius;\n\tdouble circle_center[3], circle_atom_vector[3], circle_axis[3];\n\tstruct circle *circle_ptr;\n\tstruct sphere *atm_ptr;\n\n\tatm_ptr = torus_ptr -> atm[which_side];\n\n\t/* computations for circle */\n\tcircle_radius =\n\t\ttorus_ptr -> radius * atm_ptr -> radius /\n\t\t(atm_ptr -> radius + this_srf -> probe_radius);\n\tfor (k = 0; k < 3; k++) {\n\t\tcircle_center[k] =\n\t\t\t(atm_ptr -> radius * torus_ptr -> center[k] +\n\t\t\tthis_srf -> probe_radius * atm_ptr -> center[k])\n\t\t\t/ (atm_ptr -> radius + this_srf -> probe_radius);\n\t\tcircle_atom_vector[k] =\n\t\t\tcircle_center[k] - atm_ptr -> center[k];\n\t\tcircle_axis[k] = (2 * which_side - 1) * torus_ptr -> axis[k];\n\t}\n\n\t/* allocate memory, setup fields */\n\tcircle_ptr = new_circle (circle_center, circle_radius, circle_axis);\n\tif (error()) return(NULL);\n\tlink_circle (this_srf, circle_ptr);\n\tcircle_ptr -> subtype = CONTACT_SUBTYPE;\n\tsigned_distance = (-dot_product (circle_axis, circle_atom_vector));\n\tcircle_ptr -> theta = atan2 (signed_distance, circle_radius);\n\tcircle_ptr -> atm = atm_ptr;\n\ttorus_ptr -> cir[which_side] = circle_ptr;\n\treturn (circle_ptr);\n}", "item_id": 7, "repo": "mlconnolly1951/biohedron", "file": "msp/src/msface.c", "last_update_at": "2018-02-13T20:32:12+00:00", "question_id": "18dd4b7fb18f09455bd9953e6900c5c3159d110c_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct circle *new_contact_circle (struct surface *this_srf, struct torus *torus_ptr, int which_side) \n{\n\tint k;\n\tdouble signed_distance, circle_radius;\n\tdouble circle_center[3], circle_atom_vector[3], circle_axis[3];\n\tstruct circle *circle_ptr;\n\tstruct sphere *atm_ptr;\n\tatm_ptr = torus_ptr -> atm[which_side];\n\t/* computations for circle */\n\tcircle_radius =\n\t\ttorus_ptr -> radius * atm_ptr -> radius /\n\t\t(atm_ptr -> radius + this_srf -> probe_radius);\n\tfor (k = 0; k < 3; k++) {\n\t\tcircle_center[k] =\n\t\t\t(atm_ptr -> radius * torus_ptr -> center[k] +\n\t\t\tthis_srf -> probe_radius * atm_ptr -> center[k])\n\t\t\t/ (atm_ptr -> radius + this_srf -> probe_radius);\n\t\tcircle_atom_vector[k] =\n\t\t\tcircle_center[k] - atm_ptr -> center[k];\n\t\tcircle_axis[k] = (2 * which_side - 1) * torus_ptr -> axis[k];\n\t}\n\t/* allocate memory, setup fields */\n\tcircle_ptr = new_circle (circle_center, circle_radius, circle_axis);\n\tif (error()) return(NULL);\n\tlink_circle (this_srf, circle_ptr);\n\tcircle_ptr -> subtype = CONTACT_SUBTYPE;\n\tsigned_distance = (-dot_product (circle_axis, circle_atom_vector));\n\tcircle_ptr -> theta = atan2 (signed_distance, circle_radius);\n\tcircle_ptr -> atm = atm_ptr;\n\ttorus_ptr -> cir[which_side] = circle_ptr;\n\treturn (circle_ptr);\n"]]}
{"hexsha": "e5fb162a96cef8750c1185fe9b8bef4303bc4e60", "ext": "c", "lang": "C", "content": "static void gpsculpt_brush_apply(bContext *C, wmOperator *op, PointerRNA *itemptr)\n{\n\ttGP_BrushEditData *gso = op->customdata;\n\tconst int radius = gso->brush->size;\n\tfloat mousef[2];\n\tint mouse[2];\n\tbool changed = false;\n\t\n\t/* Get latest mouse coordinates */\n\tRNA_float_get_array(itemptr, \"mouse\", mousef);\n\tgso->mval[0] = mouse[0] = (int)(mousef[0]);\n\tgso->mval[1] = mouse[1] = (int)(mousef[1]);\n\t\n\tgso->pressure = RNA_float_get(itemptr, \"pressure\");\n\t\n\tif (RNA_boolean_get(itemptr, \"pen_flip\"))\n\t\tgso->flag |= GP_EDITBRUSH_FLAG_INVERT;\n\telse\n\t\tgso->flag &= ~GP_EDITBRUSH_FLAG_INVERT;\n\t\n\t\n\t/* Store coordinates as reference, if operator just started running */\n\tif (gso->first) {\n\t\tgso->mval_prev[0]  = gso->mval[0];\n\t\tgso->mval_prev[1]  = gso->mval[1];\n\t\tgso->pressure_prev = gso->pressure;\n\t}\n\t\n\t/* Update brush_rect, so that it represents the bounding rectangle of brush */\n\tgso->brush_rect.xmin = mouse[0] - radius;\n\tgso->brush_rect.ymin = mouse[1] - radius;\n\tgso->brush_rect.xmax = mouse[0] + radius;\n\tgso->brush_rect.ymax = mouse[1] + radius;\n\t\n\t\n\t/* Apply brush */\n\tif (gso->brush_type == GP_EDITBRUSH_TYPE_CLONE) {\n\t\tchanged = gpsculpt_brush_apply_clone(C, gso);\n\t}\n\telse {\n\t\tchanged = gpsculpt_brush_apply_standard(C, gso);\n\t}\n\t\n\t\n\t/* Updates */\n\tif (changed) {\n\t\tWM_event_add_notifier(C, NC_GPENCIL | ND_DATA | NA_EDITED, NULL);\n\t}\n\t\n\t/* Store values for next step */\n\tgso->mval_prev[0]  = gso->mval[0];\n\tgso->mval_prev[1]  = gso->mval[1];\n\tgso->pressure_prev = gso->pressure;\n\tgso->first = false;\n}", "item_id": 25, "repo": "1-MillionParanoidTterabytes/Blender-2.79b-blackened", "file": "source/blender/editors/gpencil/gpencil_brush.c", "last_update_at": "2018-06-18T01:50:32+00:00", "question_id": "e5fb162a96cef8750c1185fe9b8bef4303bc4e60_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void gpsculpt_brush_apply(bContext *C, wmOperator *op, PointerRNA *itemptr)\n{\n\ttGP_BrushEditData *gso = op->customdata;\n\tconst int radius = gso->brush->size;\n\tfloat mousef[2];\n\tint mouse[2];\n\tbool changed = false;\n\t\n\t/* Get latest mouse coordinates */\n\tRNA_float_get_array(itemptr, \"mouse\", mousef);\n\tgso->mval[0] = mouse[0] = (int)(mousef[0]);\n\tgso->mval[1] = mouse[1] = (int)(mousef[1]);\n\t\n\tgso->pressure = RNA_float_get(itemptr, \"pressure\");\n\t\n\tif (RNA_boolean_get(itemptr, \"pen_flip\"))\n\t\tgso->flag |= GP_EDITBRUSH_FLAG_INVERT;\n\telse\n\t\tgso->flag &= ~GP_EDITBRUSH_FLAG_INVERT;\n\t\n\t\n\t/* Store coordinates as reference, if operator just started running */\n\tif (gso->first) {\n\t\tgso->mval_prev[0]  = gso->mval[0];\n\t\tgso->mval_prev[1]  = gso->mval[1];\n\t\tgso->pressure_prev = gso->pressure;\n\t}\n\t\n\t/* Update brush_rect, so that it represents the bounding rectangle of brush */\n\tgso->brush_rect.xmin = mouse[0] - radius;\n\tgso->brush_rect.ymin = mouse[1] - radius;\n\tgso->brush_rect.xmax = mouse[0] + radius;\n\tgso->brush_rect.ymax = mouse[1] + radius;\n\t\n\t\n\t/* Apply brush */\n\tif (gso->brush_type == GP_EDITBRUSH_TYPE_CLONE) {\n\t\tchanged = gpsculpt_brush_apply_clone(C, gso);\n\t}\n\telse {\n\t\tchanged = gpsculpt_brush_apply_standard(C, gso);\n\t}\n\t\n\t\n\t/* Updates */\n\tif (changed) {\n\t\tWM_event_add_notifier(C, NC_GPENCIL | ND_DATA | NA_EDITED, NULL);\n\t}\n\t\n\t/* Store values for next step */\n\tgso->mval_prev[0]  = gso->mval[0];\n\tgso->mval_prev[1]  = gso->mval[1];\n\tgso->pressure_prev = gso->pressure;\n\tgso->first = false;\n"]]}
{"hexsha": "b9fcc45f3d2a0823d7decc621b4c7b1479b58f84", "ext": "c", "lang": "C", "content": "static  errval_t timer_remaining__lmp_send(struct timer_binding *_binding, struct event_closure _continuation, uint64_t time)\n{\n    // check that we can accept an outgoing message\n    if ((_binding->tx_msgnum) != 0) {\n        return(FLOUNDER_ERR_TX_BUSY);\n    }\n    \n    // register send continuation\n    if ((_continuation.handler) != NULL) {\n        errval_t _err;\n        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);\n        // may fail if previous continuation hasn't fired yet\n        if (err_is_fail(_err)) {\n            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {\n                return(FLOUNDER_ERR_TX_BUSY);\n            } else {\n                assert(!(\"shouldn't happen\"));\n                return(_err);\n            }\n        }\n    }\n    \n    // store message number and arguments\n    _binding->tx_msgnum = timer_remaining__msgnum;\n    _binding->tx_msg_fragment = 0;\n    ((_binding->tx_union).remaining).time = time;\n    FL_DEBUG(\"lmp TX timer.remaining\\n\");\n    \n    // try to send!\n    timer_remaining__lmp_send_handler(_binding);\n    \n    return(SYS_ERR_OK);\n}", "item_id": 12, "repo": "daleoooo/barrelfish", "file": "build/x86_64/lib/timer/_for_lib_timer/timer_flounder_bindings.c", "last_update_at": "2018-03-30T08:02:50+00:00", "question_id": "b9fcc45f3d2a0823d7decc621b4c7b1479b58f84_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static  errval_t timer_remaining__lmp_send(struct timer_binding *_binding, struct event_closure _continuation, uint64_t time)\n{\n    // check that we can accept an outgoing message\n    if ((_binding->tx_msgnum) != 0) {\n        return(FLOUNDER_ERR_TX_BUSY);\n    }\n    // register send continuation\n    if ((_continuation.handler) != NULL) {\n        errval_t _err;\n        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);\n        // may fail if previous continuation hasn't fired yet\n        if (err_is_fail(_err)) {\n            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {\n                return(FLOUNDER_ERR_TX_BUSY);\n            } else {\n                assert(!(\"shouldn't happen\"));\n                return(_err);\n            }\n        }\n    }\n    // store message number and arguments\n    _binding->tx_msgnum = timer_remaining__msgnum;\n    _binding->tx_msg_fragment = 0;\n    ((_binding->tx_union).remaining).time = time;\n    FL_DEBUG(\"lmp TX timer.remaining\\n\");\n    // try to send!\n    timer_remaining__lmp_send_handler(_binding);\n    return(SYS_ERR_OK);\n"]]}
{"hexsha": "201f7c63ea5c12a2abaa53263ade88d3a2624fe5", "ext": "c", "lang": "C", "content": "static int\ndmsg_relay_scan_cmp(h2span_relay_t *relay, void *arg)\n{\n\tstruct relay_scan_info *info = arg;\n\n\tif ((intptr_t)relay->source_rt->any.link->node < (intptr_t)info->node)\n\t\treturn(-1);\n\tif ((intptr_t)relay->source_rt->any.link->node > (intptr_t)info->node)\n\t\treturn(1);\n\treturn(0);\n}", "item_id": 8, "repo": "cooljeanius/DragonFlyBSD", "file": "lib/libdmsg/msg_lnk.c", "last_update_at": "2018-01-12T03:55:33+00:00", "question_id": "201f7c63ea5c12a2abaa53263ade88d3a2624fe5_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\ndmsg_relay_scan_cmp(h2span_relay_t *relay, void *arg)\n{\n\tstruct relay_scan_info *info = arg;\n\tif ((intptr_t)relay->source_rt->any.link->node < (intptr_t)info->node)\n\t\treturn(-1);\n\tif ((intptr_t)relay->source_rt->any.link->node > (intptr_t)info->node)\n\t\treturn(1);\n\treturn(0);\n"]]}
{"hexsha": "fa037a9c89ffeefd5c1454547a59f7e6e7f9128b", "ext": "c", "lang": "C", "content": "void BUTTONS_init()\n{\n    BUTTON_OUTPORT |= (1 << LEFT_BUTTON_BIT); // pull up LEFT_BUTTON_IO\n    BUTTON_DDRPORT &= ~(1 << LEFT_BUTTON_BIT); // configure LEFT_BUTTON_IO as input\n\n    BUTTON_OUTPORT |= (1 << RIGHT_BUTTON_BIT); // pull up the RIGHT_BUTTON_IO\n    BUTTON_DDRPORT &= ~(1 << RIGHT_BUTTON_BIT); // configure RIGHT_BUTTON_IO as input\n}", "item_id": 1, "repo": "Deni90/tRexRunnerNano", "file": "firmware/tRexRunner.c", "last_update_at": "2018-08-17T06:48:01+00:00", "question_id": "fa037a9c89ffeefd5c1454547a59f7e6e7f9128b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void BUTTONS_init()\n{\n    BUTTON_OUTPORT |= (1 << LEFT_BUTTON_BIT); // pull up LEFT_BUTTON_IO\n    BUTTON_DDRPORT &= ~(1 << LEFT_BUTTON_BIT); // configure LEFT_BUTTON_IO as input\n    BUTTON_OUTPORT |= (1 << RIGHT_BUTTON_BIT); // pull up the RIGHT_BUTTON_IO\n    BUTTON_DDRPORT &= ~(1 << RIGHT_BUTTON_BIT); // configure RIGHT_BUTTON_IO as input\n"]]}
{"hexsha": "5c25d22e8ffeb31c8ebe19e811b61c8c4eeb5fa1", "ext": "c", "lang": "C", "content": "void test_udict_const_str(udict_backend_t backend)\n{\n    udict_t *d = udict_create_with_backend(backend);\n    udict_put(d, G_CSTR(\"k1\"), G_CSTR(\"v1\"));\n    udict_put(d, G_CSTR(\"k2\"), G_CSTR(\"v2\"));\n    udict_put(d, G_CSTR(\"k3\"), G_CSTR(\"v3\"));\n\n    UASSERT_STR_EQ(G_AS_STR(udict_get(d, G_CSTR(\"k1\"), G_CSTR(\"\"))), \"v1\");\n    UASSERT_STR_EQ(G_AS_STR(udict_get(d, G_CSTR(\"k2\"), G_CSTR(\"\"))), \"v2\");\n    UASSERT_STR_EQ(G_AS_STR(udict_get(d, G_CSTR(\"k3\"), G_CSTR(\"\"))), \"v3\");\n\n    udict_clear(d);\n    udict_destroy(d);\n}", "item_id": 1, "repo": "YauheniKaratsevich/ugeneric", "file": "test_dict.c", "last_update_at": "2018-10-29T10:08:50+00:00", "question_id": "5c25d22e8ffeb31c8ebe19e811b61c8c4eeb5fa1_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void test_udict_const_str(udict_backend_t backend)\n{\n    udict_t *d = udict_create_with_backend(backend);\n    udict_put(d, G_CSTR(\"k1\"), G_CSTR(\"v1\"));\n    udict_put(d, G_CSTR(\"k2\"), G_CSTR(\"v2\"));\n    udict_put(d, G_CSTR(\"k3\"), G_CSTR(\"v3\"));\n    UASSERT_STR_EQ(G_AS_STR(udict_get(d, G_CSTR(\"k1\"), G_CSTR(\"\"))), \"v1\");\n    UASSERT_STR_EQ(G_AS_STR(udict_get(d, G_CSTR(\"k2\"), G_CSTR(\"\"))), \"v2\");\n    UASSERT_STR_EQ(G_AS_STR(udict_get(d, G_CSTR(\"k3\"), G_CSTR(\"\"))), \"v3\");\n    udict_clear(d);\n    udict_destroy(d);\n"]]}
{"hexsha": "f6a0693d54ba910af58c43c633f4acfb62ca837f", "ext": "c", "lang": "C", "content": "struct hedvtx *getVertex (struct hedron *hed, long number) {\n\tstruct hedvtx *vtx = NULL;\n\tlong idx = 0;\n\tidx = number - 1;\n\tif (idx < 0) return (NULL);\n\tif (idx >= hed -> maxvtx) return (NULL);\n\tvtx = *(hed -> vertices + idx);\n\treturn (vtx);\n}", "item_id": 41, "repo": "mlconnolly1951/biohedron", "file": "msp/src/mshedron.c", "last_update_at": "2018-02-13T20:32:12+00:00", "question_id": "f6a0693d54ba910af58c43c633f4acfb62ca837f_41", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct hedvtx *getVertex (struct hedron *hed, long number) {\n\tstruct hedvtx *vtx = NULL;\n\tlong idx = 0;\n\tidx = number - 1;\n\tif (idx < 0) return (NULL);\n\tif (idx >= hed -> maxvtx) return (NULL);\n\tvtx = *(hed -> vertices + idx);\n\treturn (vtx);\n"]]}
{"hexsha": "1c51b61ac37e952dd39b79b3b25537a4efea7b9c", "ext": "h", "lang": "C", "content": "class RenderTangents\n{\npublic:\n  RenderTangents(Logger logger, App* app);\n  ~RenderTangents();\n\n  void init();\n\n  void update(Vector<Mesh*>& meshes);\n\n  void draw(VkCommandBuffer cmdBuf, RenderPassHandle pass, const Vec4f& viewport, const Mat3f& N, const Mat4f& MVP);\n\nprivate:\n  Logger logger;\n  App* app = nullptr;\n\n  struct MeshData\n  {\n    Mesh* src = nullptr;\n    uint32_t geometryGeneration = 0;\n    RenderBufferHandle vtx;\n    RenderBufferHandle tan;\n    RenderBufferHandle bnm;\n    uint32_t triangleCount = 0;\n  };\n  Vector<MeshData> meshData;\n  Vector<MeshData> newMeshData;\n  RenderBufferHandle coordSysVtxCol;\n  ShaderHandle vertexShader;\n  ShaderHandle fragmentShader;\n  PipelineHandle pipeline;\n  uint32_t viewport[4];\n\n  void buildPipelines(RenderPassHandle pass);\n}", "item_id": 0, "repo": "cdyk/meshtool", "file": "app/RenderTangents.h", "last_update_at": "2018-12-21T16:04:47+00:00", "question_id": "1c51b61ac37e952dd39b79b3b25537a4efea7b9c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class RenderTangents\n{\npublic:\n  RenderTangents(Logger logger, App* app);\n  ~RenderTangents();\n  void init();\n  void update(Vector<Mesh*>& meshes);\n  void draw(VkCommandBuffer cmdBuf, RenderPassHandle pass, const Vec4f& viewport, const Mat3f& N, const Mat4f& MVP);\nprivate:\n  Logger logger;\n  App* app = nullptr;\n  struct MeshData\n  {\n    Mesh* src = nullptr;\n    uint32_t geometryGeneration = 0;\n    RenderBufferHandle vtx;\n    RenderBufferHandle tan;\n    RenderBufferHandle bnm;\n    uint32_t triangleCount = 0;\n  };\n  Vector<MeshData> meshData;\n  Vector<MeshData> newMeshData;\n  RenderBufferHandle coordSysVtxCol;\n  ShaderHandle vertexShader;\n  ShaderHandle fragmentShader;\n  PipelineHandle pipeline;\n  uint32_t viewport[4];\n  void buildPipelines(RenderPassHandle pass);\n"]]}
{"hexsha": "c38eef505d75b7a5eb8727c5e4c4a786682398d8", "ext": "c", "lang": "C", "content": "int ss_aes_128_cbc(char *encrypt, char *out_data, char *key)\n{\n    unsigned char iv[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\n#if defined(USE_CRYPTO_OPENSSL)\n    AES_KEY aes;\n    AES_set_encrypt_key((unsigned char*)key, 128, &aes);\n    AES_cbc_encrypt((const unsigned char *)encrypt, (unsigned char *)out_data, 16, &aes, iv, AES_ENCRYPT);\n\n#elif defined(USE_CRYPTO_MBEDTLS)\n    mbedtls_aes_context aes;\n\n    unsigned char output[16];\n\n    mbedtls_aes_setkey_enc( &aes, (unsigned char *)key, 128 );\n    mbedtls_aes_crypt_cbc( &aes, MBEDTLS_AES_ENCRYPT, 16, iv, (unsigned char *)encrypt, output );\n\n    memcpy(out_data, output, 16);\n#else\n\n    aes_context aes;\n\n    unsigned char output[16];\n\n    aes_setkey_enc( &aes, (unsigned char *)key, 128 );\n    aes_crypt_cbc( &aes, AES_ENCRYPT, 16, iv, (unsigned char *)encrypt, output );\n\n    memcpy(out_data, output, 16);\n#endif\n\n    return 0;\n}", "item_id": 20, "repo": "icodesign/Potatso-ssr_obfs", "file": "c/encrypt.c", "last_update_at": "2018-04-10T09:07:58+00:00", "question_id": "c38eef505d75b7a5eb8727c5e4c4a786682398d8_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int ss_aes_128_cbc(char *encrypt, char *out_data, char *key)\n{\n    unsigned char iv[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n#if defined(USE_CRYPTO_OPENSSL)\n    AES_KEY aes;\n    AES_set_encrypt_key((unsigned char*)key, 128, &aes);\n    AES_cbc_encrypt((const unsigned char *)encrypt, (unsigned char *)out_data, 16, &aes, iv, AES_ENCRYPT);\n#elif defined(USE_CRYPTO_MBEDTLS)\n    mbedtls_aes_context aes;\n    unsigned char output[16];\n    mbedtls_aes_setkey_enc( &aes, (unsigned char *)key, 128 );\n    mbedtls_aes_crypt_cbc( &aes, MBEDTLS_AES_ENCRYPT, 16, iv, (unsigned char *)encrypt, output );\n    memcpy(out_data, output, 16);\n#else\n    aes_context aes;\n    unsigned char output[16];\n    aes_setkey_enc( &aes, (unsigned char *)key, 128 );\n    aes_crypt_cbc( &aes, AES_ENCRYPT, 16, iv, (unsigned char *)encrypt, output );\n    memcpy(out_data, output, 16);\n#endif\n    return 0;\n"]]}
{"hexsha": "fa4036a6385d29ce156de559c4829e71ef49a055", "ext": "h", "lang": "C", "content": "static uint32_t\nblockmix_xor(const salsa20_blk_t *restrict Bin1,\n    const salsa20_blk_t *restrict Bin2, salsa20_blk_t *restrict Bout,\n    size_t r, int Bin2_in_ROM, const __m128i *restrict S)\n{\n\tconst uint8_t * S0, * S1;\n\t__m128i X0, X1, X2, X3;\n\tsize_t i;\n\n\tif (!S)\n\t\treturn blockmix_salsa8_xor(Bin1, Bin2, Bout, r, Bin2_in_ROM);\n\n\tS0 = (const uint8_t *)S;\n\tS1 = (const uint8_t *)S + S_SIZE_ALL / 2;\n\n\t/* Convert 128-byte blocks to 64-byte blocks */\n\tr *= 2;\n\n\tr--;\n\tif (Bin2_in_ROM) {\n\t\tPREFETCH(&Bin2[r], _MM_HINT_NTA)\n\t\tPREFETCH(&Bin1[r], _MM_HINT_T0)\n\t\tfor (i = 0; i < r; i++) {\n\t\t\tPREFETCH(&Bin2[i], _MM_HINT_NTA)\n\t\t\tPREFETCH(&Bin1[i], _MM_HINT_T0)\n\t\t\tPREFETCH_OUT(&Bout[i], _MM_HINT_T0)\n\t\t}\n\t} else {\n\t\tPREFETCH(&Bin2[r], _MM_HINT_T0)\n\t\tPREFETCH(&Bin1[r], _MM_HINT_T0)\n\t\tfor (i = 0; i < r; i++) {\n\t\t\tPREFETCH(&Bin2[i], _MM_HINT_T0)\n\t\t\tPREFETCH(&Bin1[i], _MM_HINT_T0)\n\t\t\tPREFETCH_OUT(&Bout[i], _MM_HINT_T0)\n\t\t}\n\t}\n\tPREFETCH_OUT(&Bout[r], _MM_HINT_T0);\n\n\t/* X <-- B_{r1 - 1} */\n\tXOR4_2(Bin1[r].q, Bin2[r].q)\n\n\t/* for i = 0 to r1 - 1 do */\n\tfor (i = 0; i < r; i++) {\n\t\t/* X <-- H'(X \\xor B_i) */\n\t\tXOR4(Bin1[i].q)\n\t\tXOR4(Bin2[i].q)\n\t\tPWXFORM\n\t\t/* B'_i <-- X */\n\t\tOUT(Bout[i].q)\n\t}\n\n\t/* Last iteration of the loop above */\n\tXOR4(Bin1[i].q)\n\tXOR4(Bin2[i].q)\n\tPWXFORM\n\n\t/* B'_i <-- H(B'_i) */\n\tSALSA20_8(Bout[i].q)\n\n\treturn _mm_cvtsi128_si32(X0);\n}", "item_id": 3, "repo": "okoto-xyz/jagaricoinR", "file": "src/crypto/yescrypt/yescrypt-simd_c.h", "last_update_at": "2018-05-18T13:10:02+00:00", "question_id": "fa4036a6385d29ce156de559c4829e71ef49a055_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static uint32_t\nblockmix_xor(const salsa20_blk_t *restrict Bin1,\n    const salsa20_blk_t *restrict Bin2, salsa20_blk_t *restrict Bout,\n    size_t r, int Bin2_in_ROM, const __m128i *restrict S)\n{\n\tconst uint8_t * S0, * S1;\n\t__m128i X0, X1, X2, X3;\n\tsize_t i;\n\tif (!S)\n\t\treturn blockmix_salsa8_xor(Bin1, Bin2, Bout, r, Bin2_in_ROM);\n\tS0 = (const uint8_t *)S;\n\tS1 = (const uint8_t *)S + S_SIZE_ALL / 2;\n\t/* Convert 128-byte blocks to 64-byte blocks */\n\tr *= 2;\n\tr--;\n\tif (Bin2_in_ROM) {\n\t\tPREFETCH(&Bin2[r], _MM_HINT_NTA)\n\t\tPREFETCH(&Bin1[r], _MM_HINT_T0)\n\t\tfor (i = 0; i < r; i++) {\n\t\t\tPREFETCH(&Bin2[i], _MM_HINT_NTA)\n\t\t\tPREFETCH(&Bin1[i], _MM_HINT_T0)\n\t\t\tPREFETCH_OUT(&Bout[i], _MM_HINT_T0)\n\t\t}\n\t} else {\n\t\tPREFETCH(&Bin2[r], _MM_HINT_T0)\n\t\tPREFETCH(&Bin1[r], _MM_HINT_T0)\n\t\tfor (i = 0; i < r; i++) {\n\t\t\tPREFETCH(&Bin2[i], _MM_HINT_T0)\n\t\t\tPREFETCH(&Bin1[i], _MM_HINT_T0)\n\t\t\tPREFETCH_OUT(&Bout[i], _MM_HINT_T0)\n\t\t}\n\t}\n\tPREFETCH_OUT(&Bout[r], _MM_HINT_T0);\n\t/* X <-- B_{r1 - 1} */\n\tXOR4_2(Bin1[r].q, Bin2[r].q)\n\t/* for i = 0 to r1 - 1 do */\n\tfor (i = 0; i < r; i++) {\n\t\t/* X <-- H'(X \\xor B_i) */\n\t\tXOR4(Bin1[i].q)\n\t\tXOR4(Bin2[i].q)\n\t\tPWXFORM\n\t\t/* B'_i <-- X */\n\t\tOUT(Bout[i].q)\n\t}\n\t/* Last iteration of the loop above */\n\tXOR4(Bin1[i].q)\n\tXOR4(Bin2[i].q)\n\tPWXFORM\n\t/* B'_i <-- H(B'_i) */\n\tSALSA20_8(Bout[i].q)\n\treturn _mm_cvtsi128_si32(X0);\n"]]}
{"hexsha": "08a6211832b6c677948136e74c7fea4f3653fe93", "ext": "h", "lang": "C", "content": "class YOCTO_CLASS_EXPORT YDelayedPulse {\npublic:\n    int             target;\n    int             ms;\n    int             moving;\n\n    YDelayedPulse()\n        :target(YAPI_INVALID_INT), ms(YAPI_INVALID_INT), moving(YAPI_INVALID_UINT)\n    {}\n\n    bool operator==(const YDelayedPulse& o) const {\n         return (target == o.target) && (ms == o.ms) && (moving == o.moving);\n    }\n}", "item_id": 0, "repo": "amstrudy/yoctopuce-altimeter", "file": "include/yocto/yocto_api/yocto_relay.h", "last_update_at": "2018-02-20T17:39:20+00:00", "question_id": "08a6211832b6c677948136e74c7fea4f3653fe93_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class YOCTO_CLASS_EXPORT YDelayedPulse {\npublic:\n    int             target;\n    int             ms;\n    int             moving;\n    YDelayedPulse()\n        :target(YAPI_INVALID_INT), ms(YAPI_INVALID_INT), moving(YAPI_INVALID_UINT)\n    {}\n    bool operator==(const YDelayedPulse& o) const {\n         return (target == o.target) && (ms == o.ms) && (moving == o.moving);\n    }\n"]]}
{"hexsha": "a3dafbc05a1183cbfa9af243baa2f6526800d173", "ext": "c", "lang": "C", "content": "int usecSleep(unsigned int dt_us)\n{\n    static struct timespec s;\n    if (dt_us > 0)\n    {\n        s.tv_sec = (dt_us/1000000);\n        s.tv_nsec = (dt_us % 1000000)*1000L;\n        while(nanosleep(&s,&s)==-1 && errno == EINTR)\n        continue;\n    }\n    else {\n        return sleep(0);\n    }\n    return 0;\n}", "item_id": 3, "repo": "adalinbv/aax-utils", "file": "base/timer.c", "last_update_at": "2018-12-10T19:10:20+00:00", "question_id": "a3dafbc05a1183cbfa9af243baa2f6526800d173_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int usecSleep(unsigned int dt_us)\n{\n    static struct timespec s;\n    if (dt_us > 0)\n    {\n        s.tv_sec = (dt_us/1000000);\n        s.tv_nsec = (dt_us % 1000000)*1000L;\n        while(nanosleep(&s,&s)==-1 && errno == EINTR)\n        continue;\n    }\n    else {\n        return sleep(0);\n    }\n    return 0;\n"]]}
{"hexsha": "72ae298cf875649244dec08a618d9e0852ff6a94", "ext": "c", "lang": "C", "content": "static void rxm_handle_sar_comp(struct rxm_ep *rxm_ep,\n\t\t\t\tstruct rxm_tx_buf *tx_buf)\n{\n\tvoid *app_context;\n\tuint64_t comp_flags, tx_flags;\n\n\tapp_context = tx_buf->app_context;\n\tcomp_flags = ofi_tx_cq_flags(tx_buf->pkt.hdr.op);\n\ttx_flags = tx_buf->flags;\n\n\tif (!rxm_complete_sar(rxm_ep, tx_buf))\n\t\treturn;\n\n\trxm_cq_write_tx_comp(rxm_ep, comp_flags, app_context, tx_flags);\n\tofi_ep_tx_cntr_inc(&rxm_ep->util_ep);\n}", "item_id": 9, "repo": "kamleshbhalui/chapel", "file": "third-party/libfabric/libfabric-src/prov/rxm/src/rxm_cq.c", "last_update_at": "2018-01-31T17:05:32+00:00", "question_id": "72ae298cf875649244dec08a618d9e0852ff6a94_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void rxm_handle_sar_comp(struct rxm_ep *rxm_ep,\n\t\t\t\tstruct rxm_tx_buf *tx_buf)\n{\n\tvoid *app_context;\n\tuint64_t comp_flags, tx_flags;\n\tapp_context = tx_buf->app_context;\n\tcomp_flags = ofi_tx_cq_flags(tx_buf->pkt.hdr.op);\n\ttx_flags = tx_buf->flags;\n\tif (!rxm_complete_sar(rxm_ep, tx_buf))\n\t\treturn;\n\trxm_cq_write_tx_comp(rxm_ep, comp_flags, app_context, tx_flags);\n\tofi_ep_tx_cntr_inc(&rxm_ep->util_ep);\n"]]}
{"hexsha": "9a4a5bb386bdf3d9377a72f7c3a1ebdc21df3387", "ext": "c", "lang": "C", "content": "native_handle_t* native_handle_create(int numFds, int numInts)\n{\n    native_handle_t* h = malloc(\n            sizeof(native_handle_t) + sizeof(int)*(numFds+numInts));\n\n    if (h) {\n        h->version = sizeof(native_handle_t);\n        h->numFds = numFds;\n        h->numInts = numInts;\n    }\n    return h;\n}", "item_id": 0, "repo": "nicknaym530/android_system_core", "file": "libcutils/native_handle.c", "last_update_at": "2018-11-23T04:37:11+00:00", "question_id": "9a4a5bb386bdf3d9377a72f7c3a1ebdc21df3387_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["native_handle_t* native_handle_create(int numFds, int numInts)\n{\n    native_handle_t* h = malloc(\n            sizeof(native_handle_t) + sizeof(int)*(numFds+numInts));\n    if (h) {\n        h->version = sizeof(native_handle_t);\n        h->numFds = numFds;\n        h->numInts = numInts;\n    }\n    return h;\n"]]}
{"hexsha": "10c519fae7b4655a4b159bf6f43e87d0583e98dc", "ext": "h", "lang": "C", "content": "static int remoteDispatchStorageVolLookupByKey(\n    virNetServerPtr server ATTRIBUTE_UNUSED,\n    virNetServerClientPtr client,\n    virNetMessagePtr msg ATTRIBUTE_UNUSED,\n    virNetMessageErrorPtr rerr,\n    remote_storage_vol_lookup_by_key_args *args,\n    remote_storage_vol_lookup_by_key_ret *ret)\n{\n    int rv = -1;\n    virStorageVolPtr vol = NULL;\n    struct daemonClientPrivate *priv =\n        virNetServerClientGetPrivateData(client);\n\n    if (!priv->conn) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"connection not open\"));\n        goto cleanup;\n    }\n\n    if ((vol = virStorageVolLookupByKey(priv->conn, args->key)) == NULL)\n        goto cleanup;\n\n    make_nonnull_storage_vol(&ret->vol, vol);\n    rv = 0;\n\ncleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    virObjectUnref(vol);\n    return rv;\n}", "item_id": 227, "repo": "SIIS-cloud/pileus", "file": "libvirt/pileus-libvirt-1.2.12/daemon/remote_dispatch.h", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "10c519fae7b4655a4b159bf6f43e87d0583e98dc_227", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int remoteDispatchStorageVolLookupByKey(\n    virNetServerPtr server ATTRIBUTE_UNUSED,\n    virNetServerClientPtr client,\n    virNetMessagePtr msg ATTRIBUTE_UNUSED,\n    virNetMessageErrorPtr rerr,\n    remote_storage_vol_lookup_by_key_args *args,\n    remote_storage_vol_lookup_by_key_ret *ret)\n{\n    int rv = -1;\n    virStorageVolPtr vol = NULL;\n    struct daemonClientPrivate *priv =\n        virNetServerClientGetPrivateData(client);\n    if (!priv->conn) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"connection not open\"));\n        goto cleanup;\n    }\n    if ((vol = virStorageVolLookupByKey(priv->conn, args->key)) == NULL)\n        goto cleanup;\n    make_nonnull_storage_vol(&ret->vol, vol);\n    rv = 0;\ncleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    virObjectUnref(vol);\n    return rv;\n"]]}
{"hexsha": "9ee39c8d1010cda660950bc599d23b0060a97ea2", "ext": "c", "lang": "C", "content": "static int parse_mntr_flags(int *_argc, char ***_argv,\n\t\t\t    struct nl_msg *msg)\n{\n\tstruct nl_msg *flags;\n\tint err = -ENOBUFS;\n\tenum nl80211_mntr_flags flag;\n\tint argc = *_argc;\n\tchar **argv = *_argv;\n\n\tflags = nlmsg_alloc();\n\tif (!flags)\n\t\treturn -ENOMEM;\n\n\twhile (argc) {\n\t\tint ok = 0;\n\t\tfor (flag = __NL80211_MNTR_FLAG_INVALID;\n\t\t     flag <= NL80211_MNTR_FLAG_MAX; flag++) {\n\t\t\tif (strcmp(*argv, mntr_flags[flag]) == 0) {\n\t\t\t\tok = 1;\n\t\t\t\t/*\n\t\t\t\t * This shouldn't be adding \"flag\" if that is\n\t\t\t\t * zero, but due to a problem in the kernel's\n\t\t\t\t * nl80211 code (using NLA_NESTED policy) it\n\t\t\t\t * will reject an empty nested attribute but\n\t\t\t\t * not one that contains an invalid attribute\n\t\t\t\t */\n\t\t\t\tNLA_PUT_FLAG(flags, flag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ok) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\targc--;\n\t\targv++;\n\t}\n\n\tnla_put_nested(msg, NL80211_ATTR_MNTR_FLAGS, flags);\n\terr = 0;\n nla_put_failure:\n out:\n\tnlmsg_free(flags);\n\n\t*_argc = argc;\n\t*_argv = argv;\n\n\treturn err;\n}", "item_id": 0, "repo": "gromaudio/android_external_iw", "file": "interface.c", "last_update_at": "2018-02-01T12:28:41+00:00", "question_id": "9ee39c8d1010cda660950bc599d23b0060a97ea2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int parse_mntr_flags(int *_argc, char ***_argv,\n\t\t\t    struct nl_msg *msg)\n{\n\tstruct nl_msg *flags;\n\tint err = -ENOBUFS;\n\tenum nl80211_mntr_flags flag;\n\tint argc = *_argc;\n\tchar **argv = *_argv;\n\tflags = nlmsg_alloc();\n\tif (!flags)\n\t\treturn -ENOMEM;\n\twhile (argc) {\n\t\tint ok = 0;\n\t\tfor (flag = __NL80211_MNTR_FLAG_INVALID;\n\t\t     flag <= NL80211_MNTR_FLAG_MAX; flag++) {\n\t\t\tif (strcmp(*argv, mntr_flags[flag]) == 0) {\n\t\t\t\tok = 1;\n\t\t\t\t/*\n\t\t\t\t * This shouldn't be adding \"flag\" if that is\n\t\t\t\t * zero, but due to a problem in the kernel's\n\t\t\t\t * nl80211 code (using NLA_NESTED policy) it\n\t\t\t\t * will reject an empty nested attribute but\n\t\t\t\t * not one that contains an invalid attribute\n\t\t\t\t */\n\t\t\t\tNLA_PUT_FLAG(flags, flag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ok) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\targc--;\n\t\targv++;\n\t}\n\tnla_put_nested(msg, NL80211_ATTR_MNTR_FLAGS, flags);\n\terr = 0;\n nla_put_failure:\n out:\n\tnlmsg_free(flags);\n\t*_argc = argc;\n\t*_argv = argv;\n\treturn err;\n"]]}
{"hexsha": "635b52a51aefb39eca2232d7510d9b1808c37b25", "ext": "c", "lang": "C", "content": "static int lua_estop_display(lua_State *L){\n  int row = luaL_optnumber(L, 1,1);\n  const char * text= luaL_checkstring (L, 2);\n\n  estop_display(row,text);\n  return 1;\n}", "item_id": 4, "repo": "ToyotaResearchInstitute/rad-robot", "file": "Modules-old/estop/lua_estop.c", "last_update_at": "2018-09-22T10:31:27+00:00", "question_id": "635b52a51aefb39eca2232d7510d9b1808c37b25_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int lua_estop_display(lua_State *L){\n  int row = luaL_optnumber(L, 1,1);\n  const char * text= luaL_checkstring (L, 2);\n  estop_display(row,text);\n  return 1;\n"]]}
{"hexsha": "38a035809c1e923864c05d95e9fa6f60df89ea89", "ext": "c", "lang": "C", "content": "static void destroyDepsInfo(const vdexDeps_010 *pVdexDeps) {\n  for (u4 i = 0; i < pVdexDeps->numberOfDexFiles; ++i) {\n    free((void *)pVdexDeps->pVdexDepData[i].extraStrings.strings);\n    free((void *)pVdexDeps->pVdexDepData[i].assignTypeSets.pVdexDepSets);\n    free((void *)pVdexDeps->pVdexDepData[i].unassignTypeSets.pVdexDepSets);\n    free((void *)pVdexDeps->pVdexDepData[i].classes.pVdexDepClasses);\n    free((void *)pVdexDeps->pVdexDepData[i].fields.pVdexDepFields);\n    free((void *)pVdexDeps->pVdexDepData[i].methods.pVdexDepMethods);\n    free((void *)pVdexDeps->pVdexDepData[i].unvfyClasses.pVdexDepUnvfyClasses);\n  }\n  free((void *)pVdexDeps->pVdexDepData);\n  free((void *)pVdexDeps);\n}", "item_id": 9, "repo": "yan20160909/vdexExtractor", "file": "src/vdex/vdex_backend_010.c", "last_update_at": "2018-07-13T05:56:21+00:00", "question_id": "38a035809c1e923864c05d95e9fa6f60df89ea89_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void destroyDepsInfo(const vdexDeps_010 *pVdexDeps) {\n  for (u4 i = 0; i < pVdexDeps->numberOfDexFiles; ++i) {\n    free((void *)pVdexDeps->pVdexDepData[i].extraStrings.strings);\n    free((void *)pVdexDeps->pVdexDepData[i].assignTypeSets.pVdexDepSets);\n    free((void *)pVdexDeps->pVdexDepData[i].unassignTypeSets.pVdexDepSets);\n    free((void *)pVdexDeps->pVdexDepData[i].classes.pVdexDepClasses);\n    free((void *)pVdexDeps->pVdexDepData[i].fields.pVdexDepFields);\n    free((void *)pVdexDeps->pVdexDepData[i].methods.pVdexDepMethods);\n    free((void *)pVdexDeps->pVdexDepData[i].unvfyClasses.pVdexDepUnvfyClasses);\n  }\n  free((void *)pVdexDeps->pVdexDepData);\n  free((void *)pVdexDeps);\n"]]}
{"hexsha": "9d5918d47e841c22f3323e5b03abf87278e87845", "ext": "c", "lang": "C", "content": "static int lastIndexOf( const char *p_string, char p_search, int start_point )\r\n{\r\n\tint loop;\r\n    for ( loop = start_point-1; loop >= 0; -- loop )\r\n\t{\r\n\t\tif ( p_string[loop] == p_search )\r\n\t\t{\r\n\t\t\treturn loop;\r\n\t\t}\r\n\t}\r\n    return -1;\r\n}", "item_id": 1, "repo": "NDGuthrie/bposs", "file": "src/libTRANS/pt_trans.c", "last_update_at": "2018-01-24T16:28:01+00:00", "question_id": "9d5918d47e841c22f3323e5b03abf87278e87845_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int lastIndexOf( const char *p_string, char p_search, int start_point )\r\n{\r\n\tint loop;\r\n    for ( loop = start_point-1; loop >= 0; -- loop )\r\n\t{\r\n\t\tif ( p_string[loop] == p_search )\r\n\t\t{\r\n\t\t\treturn loop;\r\n\t\t}\r\n\t}\r\n    return -1;\r\n"]]}
{"hexsha": "66dc99495ba4a8aa3f108e866fea970eed5ffa82", "ext": "c", "lang": "C", "content": "ssize_t\nvirStorageFileReadHeader(virStorageSourcePtr src,\n                         ssize_t max_len,\n                         char **buf)\n{\n    ssize_t ret;\n\n    if (!virStorageFileIsInitialized(src)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"storage file backend not initialized\"));\n        return -1;\n    }\n\n    if (!src->drv->backend->storageFileReadHeader) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"storage file header reading is not supported for \"\n                         \"storage type %s (protocol: %s)\"),\n                       virStorageTypeToString(src->type),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        return -2;\n    }\n\n    ret = src->drv->backend->storageFileReadHeader(src, max_len, buf);\n\n    VIR_DEBUG(\"read of storage header %p: ret=%zd\", src, ret);\n\n    return ret;\n}", "item_id": 60, "repo": "SIIS-cloud/pileus", "file": "libvirt/pileus-libvirt-1.2.12/src/storage/storage_driver.c", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "66dc99495ba4a8aa3f108e866fea970eed5ffa82_60", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ssize_t\nvirStorageFileReadHeader(virStorageSourcePtr src,\n                         ssize_t max_len,\n                         char **buf)\n{\n    ssize_t ret;\n    if (!virStorageFileIsInitialized(src)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"storage file backend not initialized\"));\n        return -1;\n    }\n    if (!src->drv->backend->storageFileReadHeader) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"storage file header reading is not supported for \"\n                         \"storage type %s (protocol: %s)\"),\n                       virStorageTypeToString(src->type),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        return -2;\n    }\n    ret = src->drv->backend->storageFileReadHeader(src, max_len, buf);\n    VIR_DEBUG(\"read of storage header %p: ret=%zd\", src, ret);\n    return ret;\n"]]}
{"hexsha": "855240960056a1c3cc5995c6838084d84c5d33a8", "ext": "c", "lang": "C", "content": "int BGBCC_SHXC_EmitCompareVRegVRegVRegQLong(\n\tBGBCC_TransState *ctx,\n\tBGBCC_SHX_Context *sctx,\n\tccxl_type type, ccxl_register dreg, int cmp,\n\tccxl_register sreg, ccxl_register treg)\n{\n\tint csreg, ctreg, cdreg;\n\ts32 imm;\n\tint nm1, nm2, cmp1;\n\tint i;\n\t\n\tswitch(cmp)\n\t{\n\tcase CCXL_CMP_EQ:\n\t\tnm1=BGBCC_SH_NMID_CMPEQ;\n\t\tnm2=BGBCC_SH_NMID_BT;\n\t\tbreak;\n\tcase CCXL_CMP_NE:\n\t\tnm1=BGBCC_SH_NMID_CMPEQ;\n\t\tnm2=BGBCC_SH_NMID_BF;\n\t\tbreak;\n\tcase CCXL_CMP_LT:\n\t\tnm1=BGBCC_SH_NMID_CMPGE;\n\t\tnm2=BGBCC_SH_NMID_BF;\n\t\tbreak;\n\tcase CCXL_CMP_GT:\n\t\tnm1=BGBCC_SH_NMID_CMPGT;\n\t\tnm2=BGBCC_SH_NMID_BT;\n\t\tbreak;\n\tcase CCXL_CMP_LE:\n\t\tnm1=BGBCC_SH_NMID_CMPGT;\n\t\tnm2=BGBCC_SH_NMID_BF;\n\t\tbreak;\n\tcase CCXL_CMP_GE:\n\t\tnm1=BGBCC_SH_NMID_CMPGE;\n\t\tnm2=BGBCC_SH_NMID_BT;\n\t\tbreak;\n\tdefault:\n\t\tnm1=-1;\n\t\tnm2=-1;\n\t\tbreak;\n\t}\n\t\n\tif((nm1>=0) && (nm2>=0))\n\t{\n\t\tcsreg=BGBCC_SHXC_EmitGetRegisterRead(ctx, sctx, sreg);\n\t\tctreg=BGBCC_SHXC_EmitGetRegisterRead(ctx, sctx, treg);\n\t\tcdreg=BGBCC_SHXC_EmitGetRegisterWrite(ctx, sctx, dreg);\n\n\t\tBGBCC_SHXC_CheckSetModeDqSet(ctx, sctx);\n\n\t\tBGBCC_SHXC_EmitOpRegReg(ctx, sctx, nm1, ctreg, csreg);\n\t\tBGBCC_SHXC_EmitOpReg(ctx, sctx, BGBCC_SH_NMID_MOVT, cdreg);\n\t\t\n\t\tif(nm2==BGBCC_SH_NMID_BF)\n\t\t{\n\t\t\tBGBCC_SHXC_EmitOpRegReg(ctx, sctx, BGBCC_SH_NMID_NEG, cdreg, cdreg);\n\t\t\tBGBCC_SHXC_EmitOpRegImm(ctx, sctx, BGBCC_SH_NMID_ADD, cdreg, 1);\n\t\t}\n\t\t\n//\t\tBGBCC_SHX_EmitOpLabel(sctx, nm2, lbl);\n\n\t\tBGBCC_SHXC_EmitReleaseRegister(ctx, sctx, sreg);\n\t\tBGBCC_SHXC_EmitReleaseRegister(ctx, sctx, treg);\n\t\tBGBCC_SHXC_EmitReleaseRegister(ctx, sctx, dreg);\n\t\treturn(1);\n\t}\n\n\tBGBCC_CCXL_StubError(ctx);\n\treturn(0);\n}", "item_id": 3, "repo": "cr88192/bgbtech_shxemu", "file": "sh2emu/bgbcc22/shcc/shx_lqarith.c", "last_update_at": "2018-04-12T20:42:03+00:00", "question_id": "855240960056a1c3cc5995c6838084d84c5d33a8_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int BGBCC_SHXC_EmitCompareVRegVRegVRegQLong(\n\tBGBCC_TransState *ctx,\n\tBGBCC_SHX_Context *sctx,\n\tccxl_type type, ccxl_register dreg, int cmp,\n\tccxl_register sreg, ccxl_register treg)\n{\n\tint csreg, ctreg, cdreg;\n\ts32 imm;\n\tint nm1, nm2, cmp1;\n\tint i;\n\t\n\tswitch(cmp)\n\t{\n\tcase CCXL_CMP_EQ:\n\t\tnm1=BGBCC_SH_NMID_CMPEQ;\n\t\tnm2=BGBCC_SH_NMID_BT;\n\t\tbreak;\n\tcase CCXL_CMP_NE:\n\t\tnm1=BGBCC_SH_NMID_CMPEQ;\n\t\tnm2=BGBCC_SH_NMID_BF;\n\t\tbreak;\n\tcase CCXL_CMP_LT:\n\t\tnm1=BGBCC_SH_NMID_CMPGE;\n\t\tnm2=BGBCC_SH_NMID_BF;\n\t\tbreak;\n\tcase CCXL_CMP_GT:\n\t\tnm1=BGBCC_SH_NMID_CMPGT;\n\t\tnm2=BGBCC_SH_NMID_BT;\n\t\tbreak;\n\tcase CCXL_CMP_LE:\n\t\tnm1=BGBCC_SH_NMID_CMPGT;\n\t\tnm2=BGBCC_SH_NMID_BF;\n\t\tbreak;\n\tcase CCXL_CMP_GE:\n\t\tnm1=BGBCC_SH_NMID_CMPGE;\n\t\tnm2=BGBCC_SH_NMID_BT;\n\t\tbreak;\n\tdefault:\n\t\tnm1=-1;\n\t\tnm2=-1;\n\t\tbreak;\n\t}\n\t\n\tif((nm1>=0) && (nm2>=0))\n\t{\n\t\tcsreg=BGBCC_SHXC_EmitGetRegisterRead(ctx, sctx, sreg);\n\t\tctreg=BGBCC_SHXC_EmitGetRegisterRead(ctx, sctx, treg);\n\t\tcdreg=BGBCC_SHXC_EmitGetRegisterWrite(ctx, sctx, dreg);\n\t\tBGBCC_SHXC_CheckSetModeDqSet(ctx, sctx);\n\t\tBGBCC_SHXC_EmitOpRegReg(ctx, sctx, nm1, ctreg, csreg);\n\t\tBGBCC_SHXC_EmitOpReg(ctx, sctx, BGBCC_SH_NMID_MOVT, cdreg);\n\t\t\n\t\tif(nm2==BGBCC_SH_NMID_BF)\n\t\t{\n\t\t\tBGBCC_SHXC_EmitOpRegReg(ctx, sctx, BGBCC_SH_NMID_NEG, cdreg, cdreg);\n\t\t\tBGBCC_SHXC_EmitOpRegImm(ctx, sctx, BGBCC_SH_NMID_ADD, cdreg, 1);\n\t\t}\n\t\t\n//\t\tBGBCC_SHX_EmitOpLabel(sctx, nm2, lbl);\n\t\tBGBCC_SHXC_EmitReleaseRegister(ctx, sctx, sreg);\n\t\tBGBCC_SHXC_EmitReleaseRegister(ctx, sctx, treg);\n\t\tBGBCC_SHXC_EmitReleaseRegister(ctx, sctx, dreg);\n\t\treturn(1);\n\t}\n\tBGBCC_CCXL_StubError(ctx);\n\treturn(0);\n"]]}
{"hexsha": "f7b44a0ee40879b665b2e27418bba86e01140acc", "ext": "c", "lang": "C", "content": "int libxl__enum_from_string(const libxl_enum_string_table *t,\n                            const char *s, int *e)\n{\n    if (!t) return ERROR_INVAL;\n\n    for( ; t->s; t++) {\n        if (!strcasecmp(t->s, s)) {\n                *e = t->v;\n                return 0;\n        }\n    }\n    return ERROR_FAIL;\n}", "item_id": 23, "repo": "zhiming-shen/Xen-Blanket-NG", "file": "xen/xen-4.2.2/tools/libxl/libxl_utils.c", "last_update_at": "2018-02-02T00:15:26+00:00", "question_id": "f7b44a0ee40879b665b2e27418bba86e01140acc_23", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int libxl__enum_from_string(const libxl_enum_string_table *t,\n                            const char *s, int *e)\n{\n    if (!t) return ERROR_INVAL;\n    for( ; t->s; t++) {\n        if (!strcasecmp(t->s, s)) {\n                *e = t->v;\n                return 0;\n        }\n    }\n    return ERROR_FAIL;\n"]]}
{"hexsha": "e9c675999b8322c312bdbe7bfa3b3bcd2d0b6130", "ext": "c", "lang": "C", "content": "static int\ngattm_att_get_permission_req_handler(kernel_msg_id_t const msgid, struct gattm_att_get_permission_req *param,\n        kernel_task_id_t const dest_id, kernel_task_id_t const src_id)\n{\n    struct attm_elmt elmt = ATT_ELEMT_INIT;\n    struct gattm_att_get_permission_rsp *get_att_perm_rsp =\n    KERNEL_MSG_ALLOC(GATTM_ATT_GET_PERMISSION_RSP, src_id, dest_id, gattm_att_get_permission_rsp);\n\n    /* Retrieve attribute permissions */\n    get_att_perm_rsp->status = attmdb_att_get_permission(param->handle, &(get_att_perm_rsp->perm), PERM_MASK_ALL, 0, &elmt);\n    get_att_perm_rsp->ext_perm  = (elmt.info.att->info.max_length & PERM_MASK_EKS);\n\n    /* update handle */\n    get_att_perm_rsp->handle = param->handle;\n\n    /* send command response message. */\n    kernel_msg_send(get_att_perm_rsp);\n\n    /* message is consumed */\n    return (KERNEL_MSG_CONSUMED);\n}", "item_id": 4, "repo": "ruoranluomu/AliOS-Things", "file": "platform/mcu/bk7231u/beken/driver/ble/ble_lib/ip/ble/hl/src/gatt/gattm/gattm_task.c", "last_update_at": "2018-11-28T03:19:22+00:00", "question_id": "e9c675999b8322c312bdbe7bfa3b3bcd2d0b6130_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\ngattm_att_get_permission_req_handler(kernel_msg_id_t const msgid, struct gattm_att_get_permission_req *param,\n        kernel_task_id_t const dest_id, kernel_task_id_t const src_id)\n{\n    struct attm_elmt elmt = ATT_ELEMT_INIT;\n    struct gattm_att_get_permission_rsp *get_att_perm_rsp =\n    KERNEL_MSG_ALLOC(GATTM_ATT_GET_PERMISSION_RSP, src_id, dest_id, gattm_att_get_permission_rsp);\n    /* Retrieve attribute permissions */\n    get_att_perm_rsp->status = attmdb_att_get_permission(param->handle, &(get_att_perm_rsp->perm), PERM_MASK_ALL, 0, &elmt);\n    get_att_perm_rsp->ext_perm  = (elmt.info.att->info.max_length & PERM_MASK_EKS);\n    /* update handle */\n    get_att_perm_rsp->handle = param->handle;\n    /* send command response message. */\n    kernel_msg_send(get_att_perm_rsp);\n    /* message is consumed */\n    return (KERNEL_MSG_CONSUMED);\n"]]}
{"hexsha": "3115662c93eee0506e2f89c81b2686ba98005201", "ext": "c", "lang": "C", "content": "static void emit_rebox_value(lily_emit_state *emit, lily_type *new_type,\n        lily_ast *ast)\n{\n    lily_storage *storage = get_storage(emit, new_type);\n\n    /* Don't allow a bare variant to be thrown into an any until it's thrown\n       into an enum box first. */\n    if (new_type->cls->id == SYM_CLASS_ANY &&\n        ast->result->type->cls->flags & CLS_VARIANT_CLASS) {\n        rebox_variant_to_enum(emit, ast);\n    }\n\n    write_4(emit, o_assign, ast->line_num, ast->result->reg_spot,\n            storage->reg_spot);\n\n    ast->result = (lily_sym *)storage;\n}", "item_id": 24, "repo": "r-lyeh/scriptorium", "file": "lily/src/lily_emitter.c", "last_update_at": "2018-01-08T03:02:37+00:00", "question_id": "3115662c93eee0506e2f89c81b2686ba98005201_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void emit_rebox_value(lily_emit_state *emit, lily_type *new_type,\n        lily_ast *ast)\n{\n    lily_storage *storage = get_storage(emit, new_type);\n    /* Don't allow a bare variant to be thrown into an any until it's thrown\n       into an enum box first. */\n    if (new_type->cls->id == SYM_CLASS_ANY &&\n        ast->result->type->cls->flags & CLS_VARIANT_CLASS) {\n        rebox_variant_to_enum(emit, ast);\n    }\n    write_4(emit, o_assign, ast->line_num, ast->result->reg_spot,\n            storage->reg_spot);\n    ast->result = (lily_sym *)storage;\n"]]}
{"hexsha": "ca68dfe6d2116c7f479fc425f6e647ac548b866b", "ext": "h", "lang": "C", "content": "namespace brew {\n\nclass VideoContext :\n        public Object,\n        private ProxyObjectManager<Texture, TextureContextHandle>,\n        private ProxyObjectManager<FrameBuffer, FrameBufferContextHandle>,\n        private ProxyObjectManager<ShaderVariables, ShaderVariablesContextHandle>,\n        private ProxyObjectManager<VertexBuffer, VertexBufferContextHandle>,\n        private ProxyObjectManager<IndexBuffer, IndexBufferContextHandle>,\n        private ProxyObjectManager<Mesh, MeshContextHandle>,\n        private ProxyObjectManager<Shader, ShaderContextHandle>,\n        private ProxyObjectManager<ShaderProgram, ShaderProgramContextHandle>\n{\npublic:\n    /**\n     * Initializes pending context objects. Should not be called manually.\n     */\n    void processPendingOperations();\n\npublic:\n    /**\n     * Creates a new empty texture.\n     * @param width The texture width.\n     * @param height The texture height.\n     * @param color The initial color.\n     * @param format The texture format.\n     * @param filtering The texture filtering.\n     * @param numMipMaps The number of mip-maps to generate.\n     * @return The created texture.\n     */\n    std::shared_ptr<Texture> createTexture(SizeT width,\n                                           SizeT height,\n                                           Color color = Color::BLACK,\n                                           TextureFormat format = Texture::DefaultTextureFormat,\n                                           TextureFiltering filtering = Texture::DefaultTextureFiltering,\n                                           u8 numMipMaps = Texture::DefaultMipMaps\n    );\n\n    /**\n     * Creates a new texture from an existing pixmap.\n     * @param pixmap The source pixmap.\n     * @param format The texture format.\n     * @param filtering The texture filtering.\n     * @param numMipMaps The number of mip-maps to generate.\n     * @return The created texture.\n     */\n    std::shared_ptr<Texture> createTexture(std::shared_ptr<Pixmap> pixmap,\n                                           TextureFormat format = Texture::DefaultTextureFormat,\n                                           TextureFiltering filtering = Texture::DefaultTextureFiltering,\n                                           u8 numMipMaps = Texture::DefaultMipMaps\n    );\n\n    /**\n     * Creates a new texture from an existing pixmap.\n     * @param pixmap The source pixmap.\n     * @param format The texture format.\n     * @param filtering The texture filtering.\n     * @param numMipMaps The number of mip-maps to generate.\n     * @return The created texture.\n     */\n    inline std::shared_ptr<Texture> createTexture(const Pixmap& pixmap,\n                                           TextureFormat format = Texture::DefaultTextureFormat,\n                                           TextureFiltering filtering = Texture::DefaultTextureFiltering,\n                                           u8 numMipMaps = Texture::DefaultMipMaps\n    ) {\n        return createTexture(std::make_shared<Pixmap>(pixmap), format, filtering, numMipMaps);\n    }", "item_id": 0, "repo": "grrrrunz/brew", "file": "src/brew/video/VideoContext.h", "last_update_at": "2018-02-09T16:20:50+00:00", "question_id": "ca68dfe6d2116c7f479fc425f6e647ac548b866b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace brew {\nclass VideoContext :\n        public Object,\n        private ProxyObjectManager<Texture, TextureContextHandle>,\n        private ProxyObjectManager<FrameBuffer, FrameBufferContextHandle>,\n        private ProxyObjectManager<ShaderVariables, ShaderVariablesContextHandle>,\n        private ProxyObjectManager<VertexBuffer, VertexBufferContextHandle>,\n        private ProxyObjectManager<IndexBuffer, IndexBufferContextHandle>,\n        private ProxyObjectManager<Mesh, MeshContextHandle>,\n        private ProxyObjectManager<Shader, ShaderContextHandle>,\n        private ProxyObjectManager<ShaderProgram, ShaderProgramContextHandle>\n{\npublic:\n    /**\n     * Initializes pending context objects. Should not be called manually.\n     */\n    void processPendingOperations();\npublic:\n    /**\n     * Creates a new empty texture.\n     * @param width The texture width.\n     * @param height The texture height.\n     * @param color The initial color.\n     * @param format The texture format.\n     * @param filtering The texture filtering.\n     * @param numMipMaps The number of mip-maps to generate.\n     * @return The created texture.\n     */\n    std::shared_ptr<Texture> createTexture(SizeT width,\n                                           SizeT height,\n                                           Color color = Color::BLACK,\n                                           TextureFormat format = Texture::DefaultTextureFormat,\n                                           TextureFiltering filtering = Texture::DefaultTextureFiltering,\n                                           u8 numMipMaps = Texture::DefaultMipMaps\n    );\n    /**\n     * Creates a new texture from an existing pixmap.\n     * @param pixmap The source pixmap.\n     * @param format The texture format.\n     * @param filtering The texture filtering.\n     * @param numMipMaps The number of mip-maps to generate.\n     * @return The created texture.\n     */\n    std::shared_ptr<Texture> createTexture(std::shared_ptr<Pixmap> pixmap,\n                                           TextureFormat format = Texture::DefaultTextureFormat,\n                                           TextureFiltering filtering = Texture::DefaultTextureFiltering,\n                                           u8 numMipMaps = Texture::DefaultMipMaps\n    );\n    /**\n     * Creates a new texture from an existing pixmap.\n     * @param pixmap The source pixmap.\n     * @param format The texture format.\n     * @param filtering The texture filtering.\n     * @param numMipMaps The number of mip-maps to generate.\n     * @return The created texture.\n     */\n    inline std::shared_ptr<Texture> createTexture(const Pixmap& pixmap,\n                                           TextureFormat format = Texture::DefaultTextureFormat,\n                                           TextureFiltering filtering = Texture::DefaultTextureFiltering,\n                                           u8 numMipMaps = Texture::DefaultMipMaps\n    ) {\n        return createTexture(std::make_shared<Pixmap>(pixmap), format, filtering, numMipMaps);\n"]]}
{"hexsha": "8ad56a6769a020960774835f291789709f1c3840", "ext": "h", "lang": "C", "content": "class GeoLib\n{\npublic:\n\tGeoLib() {}\n\t~GeoLib() {}\nprivate:\n\tfriend class CGLPolyline;\n\tfriend class Surface;\n}", "item_id": 0, "repo": "yingtaohu/ogs5", "file": "GEO/geo_lib.h", "last_update_at": "2018-07-28T01:46:45+00:00", "question_id": "8ad56a6769a020960774835f291789709f1c3840_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class GeoLib\n{\npublic:\n\tGeoLib() {}\n\t~GeoLib() {}\nprivate:\n\tfriend class CGLPolyline;\n\tfriend class Surface;\n"]]}
{"hexsha": "ced9697a9812676ec762fc4fd38d0b7764fd006e", "ext": "c", "lang": "C", "content": "SSH_PACKET_CALLBACK(channel_rcv_eof) {\n  ssh_channel channel;\n  (void)user;\n  (void)type;\n\n  channel = channel_from_msg(session,packet);\n  if (channel == NULL) {\n    SSH_LOG(SSH_LOG_FUNCTIONS, \"%s\", ssh_get_error(session));\n\n    return SSH_PACKET_USED;\n  }\n\n  SSH_LOG(SSH_LOG_PACKET,\n      \"Received eof on channel (%d:%d)\",\n      channel->local_channel,\n      channel->remote_channel);\n  /* channel->remote_window = 0; */\n  channel->remote_eof = 1;\n\n  if(ssh_callbacks_exists(channel->callbacks, channel_eof_function)) {\n      channel->callbacks->channel_eof_function(channel->session,\n                                               channel,\n                                               channel->callbacks->userdata);\n  }\n\n  return SSH_PACKET_USED;\n}", "item_id": 9, "repo": "rvagg/node-libssh", "file": "deps/libssh-0.6.4/src/channels.c", "last_update_at": "2018-03-27T09:55:44+00:00", "question_id": "ced9697a9812676ec762fc4fd38d0b7764fd006e_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["SSH_PACKET_CALLBACK(channel_rcv_eof) {\n  ssh_channel channel;\n  (void)user;\n  (void)type;\n  channel = channel_from_msg(session,packet);\n  if (channel == NULL) {\n    SSH_LOG(SSH_LOG_FUNCTIONS, \"%s\", ssh_get_error(session));\n    return SSH_PACKET_USED;\n  }\n  SSH_LOG(SSH_LOG_PACKET,\n      \"Received eof on channel (%d:%d)\",\n      channel->local_channel,\n      channel->remote_channel);\n  /* channel->remote_window = 0; */\n  channel->remote_eof = 1;\n  if(ssh_callbacks_exists(channel->callbacks, channel_eof_function)) {\n      channel->callbacks->channel_eof_function(channel->session,\n                                               channel,\n                                               channel->callbacks->userdata);\n  }\n  return SSH_PACKET_USED;\n"]]}
{"hexsha": "698bf4f5ac6c9e93098989c5891feb2611385387", "ext": "c", "lang": "C", "content": "static irqreturn_t tpd_interrupt_handler(int irq, void *dev_id)\n{\n\tTPD_DEBUG_PRINT_INT;\n\ttpd_flag = 1;\n\twake_up_interruptible(&waiter);\n\treturn IRQ_HANDLED;\n}", "item_id": 33, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/drivers/input/touchscreen/mediatek/GT9271TB_hotknot/gt9xx_driver.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "698bf4f5ac6c9e93098989c5891feb2611385387_33", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static irqreturn_t tpd_interrupt_handler(int irq, void *dev_id)\n{\n\tTPD_DEBUG_PRINT_INT;\n\ttpd_flag = 1;\n\twake_up_interruptible(&waiter);\n\treturn IRQ_HANDLED;\n"]]}
{"hexsha": "d690d33b2960517c8a01db5579274d0f9cf55728", "ext": "c", "lang": "C", "content": "M3G_API void m3gSetAlphaThreshold(M3GCompositingMode handle,\n                                  M3Gfloat threshold)\n{\n    CompositingMode *compositingMode = (CompositingMode*)handle;\n    M3G_VALIDATE_OBJECT(compositingMode);\n    if (!m3gInRangef(threshold, 0.0f, 1.0f)) {\n        m3gRaiseError(M3G_INTERFACE(compositingMode), M3G_INVALID_VALUE);\n        return;\n    }\n    compositingMode->alphaThreshold = threshold;\n}", "item_id": 6, "repo": "salg/J2ME-Loader", "file": "app/src/main/cpp/src/m3g_compositingmode.c", "last_update_at": "2018-05-02T09:25:55+00:00", "question_id": "d690d33b2960517c8a01db5579274d0f9cf55728_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["M3G_API void m3gSetAlphaThreshold(M3GCompositingMode handle,\n                                  M3Gfloat threshold)\n{\n    CompositingMode *compositingMode = (CompositingMode*)handle;\n    M3G_VALIDATE_OBJECT(compositingMode);\n    if (!m3gInRangef(threshold, 0.0f, 1.0f)) {\n        m3gRaiseError(M3G_INTERFACE(compositingMode), M3G_INVALID_VALUE);\n        return;\n    }\n    compositingMode->alphaThreshold = threshold;\n"]]}
{"hexsha": "6c8defc2e7afa02ff5ac85d420cd06384601919f", "ext": "c", "lang": "C", "content": "static PyObject *\nVec2Array_longest(polypaths_planar_overrideSeq2Object *self)\n{\n\tdouble max_len = -1.0;\n\tdouble L;\n\tPy_ssize_t max_i = -1;\n\tPy_ssize_t i;\n\n\tfor (i = 0; i < Py_SIZE(self); ++i) {\n\t\tL = self->vec[i].x * self->vec[i].x + \n\t\t\tself->vec[i].y * self->vec[i].y;\n\t\tif (L > max_len) {\n\t\t\tmax_len = L;\n\t\t\tmax_i = i;\n\t\t}\n\t}\n\tif (max_i > -1) {\n\t\treturn (PyObject *)polypaths_planar_overrideVec2_FromStruct(&self->vec[max_i]);\n\t} else {\n\t\tPy_RETURN_NONE;\n\t}\n}", "item_id": 38, "repo": "apolcyn/polypaths_planar_override", "file": "lib/polypaths_planar_override/cvector.c", "last_update_at": "2018-10-19T00:14:58+00:00", "question_id": "6c8defc2e7afa02ff5ac85d420cd06384601919f_38", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static PyObject *\nVec2Array_longest(polypaths_planar_overrideSeq2Object *self)\n{\n\tdouble max_len = -1.0;\n\tdouble L;\n\tPy_ssize_t max_i = -1;\n\tPy_ssize_t i;\n\tfor (i = 0; i < Py_SIZE(self); ++i) {\n\t\tL = self->vec[i].x * self->vec[i].x + \n\t\t\tself->vec[i].y * self->vec[i].y;\n\t\tif (L > max_len) {\n\t\t\tmax_len = L;\n\t\t\tmax_i = i;\n\t\t}\n\t}\n\tif (max_i > -1) {\n\t\treturn (PyObject *)polypaths_planar_overrideVec2_FromStruct(&self->vec[max_i]);\n\t} else {\n\t\tPy_RETURN_NONE;\n\t}\n"]]}
{"hexsha": "6259df028241962e7e75a58ca1332ecee0f97a39", "ext": "c", "lang": "C", "content": "int ts_db_get(ts_db * self, char * table, char * key_name, MDB_val * val) {\n\n    // get a value from a given table\n    MDB_val key;\n\n    key.mv_size = strlen(key_name);\n    key.mv_data = key_name;\n\n    int res = mdb_get(self->current_txn->txn, _get_dbi(self, table), &key, val);\n    return res == MDB_NOTFOUND ? TS_KEY_NOT_FOUND : TS_SUCCESS;\n}", "item_id": 9, "repo": "tavoe/tagsystem", "file": "src/tsdb.c", "last_update_at": "2018-11-07T08:31:31+00:00", "question_id": "6259df028241962e7e75a58ca1332ecee0f97a39_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int ts_db_get(ts_db * self, char * table, char * key_name, MDB_val * val) {\n    // get a value from a given table\n    MDB_val key;\n    key.mv_size = strlen(key_name);\n    key.mv_data = key_name;\n    int res = mdb_get(self->current_txn->txn, _get_dbi(self, table), &key, val);\n    return res == MDB_NOTFOUND ? TS_KEY_NOT_FOUND : TS_SUCCESS;\n"]]}
{"hexsha": "e03d1cb10b0402fb4b8ce4af3c90e26ca64ed93f", "ext": "h", "lang": "C", "content": "interface SSVLoadSoftwareUpdatesOperation : SSVLoadDownloadQueueOperation {\n    NSArray * _appMetadata;\n    NSLock * _lock;\n    long long  _reason;\n    NSArray * _specificApps;\n    id /* block */  _updatesBlock;\n    NSString * _userAgent;\n}", "item_id": 0, "repo": "shaojiankui/iOS10-Runtime-Headers", "file": "PrivateFrameworks/StoreServices.framework/SSVLoadSoftwareUpdatesOperation.h", "last_update_at": "2018-10-08T04:12:25+00:00", "question_id": "e03d1cb10b0402fb4b8ce4af3c90e26ca64ed93f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface SSVLoadSoftwareUpdatesOperation : SSVLoadDownloadQueueOperation {\n    NSArray * _appMetadata;\n    NSLock * _lock;\n    long long  _reason;\n    NSArray * _specificApps;\n    id /* block */  _updatesBlock;\n    NSString * _userAgent;\n"]]}
{"hexsha": "b4207079b33c970f60153b65d55f237207e07daf", "ext": "c", "lang": "C", "content": "int b16_decode( char *buf, size_t sz, const void *s, size_t len, size_t *errcnt )\n{\n    const uint8_t *p = s;\n    int c, d;\n    size_t i, n, e, err = 0;\n    int st = 0;\n\n    for ( i = n = e = 0; i < len; ++i )\n    {\n        if ( 0 == st )\n        {\n            c = XTOD( p[i] );\n            if ( 0 >  c )\n            {\n                ++err;\n                continue;\n            }\n        }\n        else\n        {\n            d = XTOD( p[i] );\n            if ( 0 >  d )\n                ++err;\n            else if ( n + 1 < sz )\n            {\n                buf[n++] = (c << 4) | d;\n                e = n;\n            }\n            else\n                ++n;\n        }\n        st = !st;\n    }\n    buf[e] = '\\0';\n    if ( errcnt )\n        *errcnt = err;\n    return n;\n}", "item_id": 1, "repo": "irrwahn/utlib", "file": "lib/base16.c", "last_update_at": "2018-06-20T16:07:36+00:00", "question_id": "b4207079b33c970f60153b65d55f237207e07daf_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int b16_decode( char *buf, size_t sz, const void *s, size_t len, size_t *errcnt )\n{\n    const uint8_t *p = s;\n    int c, d;\n    size_t i, n, e, err = 0;\n    int st = 0;\n    for ( i = n = e = 0; i < len; ++i )\n    {\n        if ( 0 == st )\n        {\n            c = XTOD( p[i] );\n            if ( 0 >  c )\n            {\n                ++err;\n                continue;\n            }\n        }\n        else\n        {\n            d = XTOD( p[i] );\n            if ( 0 >  d )\n                ++err;\n            else if ( n + 1 < sz )\n            {\n                buf[n++] = (c << 4) | d;\n                e = n;\n            }\n            else\n                ++n;\n        }\n        st = !st;\n    }\n    buf[e] = '\\0';\n    if ( errcnt )\n        *errcnt = err;\n    return n;\n"]]}
{"hexsha": "cf3648d1487a2fe7ce0715ef99991e781036c64f", "ext": "c", "lang": "C", "content": "static void iface_stat_create(struct net_device *net_dev,\n\t\t\t      struct in_ifaddr *ifa)\n{\n\tstruct in_device *in_dev = NULL;\n\tconst char *ifname;\n\tstruct iface_stat *entry;\n\t__be32 ipaddr = 0;\n\tstruct iface_stat *new_iface;\n\n\tIF_DEBUG(\"qtaguid: iface_stat: create(%s): ifa=%p netdev=%p\\n\",\n\t\t net_dev ? net_dev->name : \"?\",\n\t\t ifa, net_dev);\n\tif (!net_dev) {\n\t\tpr_err(\"qtaguid: iface_stat: create(): no net dev\\n\");\n\t\treturn;\n\t}\n\n\tifname = net_dev->name;\n\tif (!ifa) {\n\t\tin_dev = in_dev_get(net_dev);\n\t\tif (!in_dev) {\n\t\t\tpr_err(\"qtaguid: iface_stat: create(%s): no inet dev\\n\",\n\t\t\t       ifname);\n\t\t\treturn;\n\t\t}\n\t\tIF_DEBUG(\"qtaguid: iface_stat: create(%s): in_dev=%p\\n\",\n\t\t\t ifname, in_dev);\n\t\tfor (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next) {\n\t\t\tIF_DEBUG(\"qtaguid: iface_stat: create(%s): \"\n\t\t\t\t \"ifa=%p ifa_label=%s\\n\",\n\t\t\t\t ifname, ifa,\n\t\t\t\t ifa->ifa_label ? ifa->ifa_label : \"(null)\");\n\t\t\tif (ifa->ifa_label && !strcmp(ifname, ifa->ifa_label))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ifa) {\n\t\tIF_DEBUG(\"qtaguid: iface_stat: create(%s): no matching IP\\n\",\n\t\t\t ifname);\n\t\tgoto done_put;\n\t}\n\tipaddr = ifa->ifa_local;\n\n\tspin_lock_bh(&iface_stat_list_lock);\n\tentry = get_iface_entry(ifname);\n\tif (entry != NULL) {\n\t\tIF_DEBUG(\"qtaguid: iface_stat: create(%s): entry=%p\\n\",\n\t\t\t ifname, entry);\n\t\tiface_check_stats_reset_and_adjust(net_dev, entry);\n\t\t_iface_stat_set_active(entry, net_dev, true);\n\t\tIF_DEBUG(\"qtaguid: %s(%s): \"\n\t\t\t \"tracking now %d on ip=%pI4\\n\", __func__,\n\t\t\t entry->ifname, true, &ipaddr);\n\t\tgoto done_unlock_put;\n\t}\n\n\tnew_iface = iface_alloc(net_dev);\n\tIF_DEBUG(\"qtaguid: iface_stat: create(%s): done \"\n\t\t \"entry=%p ip=%pI4\\n\", ifname, new_iface, &ipaddr);\ndone_unlock_put:\n\tspin_unlock_bh(&iface_stat_list_lock);\ndone_put:\n\tif (in_dev)\n\t\tin_dev_put(in_dev);\n}", "item_id": 27, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/net/netfilter/xt_qtaguid.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "cf3648d1487a2fe7ce0715ef99991e781036c64f_27", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void iface_stat_create(struct net_device *net_dev,\n\t\t\t      struct in_ifaddr *ifa)\n{\n\tstruct in_device *in_dev = NULL;\n\tconst char *ifname;\n\tstruct iface_stat *entry;\n\t__be32 ipaddr = 0;\n\tstruct iface_stat *new_iface;\n\tIF_DEBUG(\"qtaguid: iface_stat: create(%s): ifa=%p netdev=%p\\n\",\n\t\t net_dev ? net_dev->name : \"?\",\n\t\t ifa, net_dev);\n\tif (!net_dev) {\n\t\tpr_err(\"qtaguid: iface_stat: create(): no net dev\\n\");\n\t\treturn;\n\t}\n\tifname = net_dev->name;\n\tif (!ifa) {\n\t\tin_dev = in_dev_get(net_dev);\n\t\tif (!in_dev) {\n\t\t\tpr_err(\"qtaguid: iface_stat: create(%s): no inet dev\\n\",\n\t\t\t       ifname);\n\t\t\treturn;\n\t\t}\n\t\tIF_DEBUG(\"qtaguid: iface_stat: create(%s): in_dev=%p\\n\",\n\t\t\t ifname, in_dev);\n\t\tfor (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next) {\n\t\t\tIF_DEBUG(\"qtaguid: iface_stat: create(%s): \"\n\t\t\t\t \"ifa=%p ifa_label=%s\\n\",\n\t\t\t\t ifname, ifa,\n\t\t\t\t ifa->ifa_label ? ifa->ifa_label : \"(null)\");\n\t\t\tif (ifa->ifa_label && !strcmp(ifname, ifa->ifa_label))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!ifa) {\n\t\tIF_DEBUG(\"qtaguid: iface_stat: create(%s): no matching IP\\n\",\n\t\t\t ifname);\n\t\tgoto done_put;\n\t}\n\tipaddr = ifa->ifa_local;\n\tspin_lock_bh(&iface_stat_list_lock);\n\tentry = get_iface_entry(ifname);\n\tif (entry != NULL) {\n\t\tIF_DEBUG(\"qtaguid: iface_stat: create(%s): entry=%p\\n\",\n\t\t\t ifname, entry);\n\t\tiface_check_stats_reset_and_adjust(net_dev, entry);\n\t\t_iface_stat_set_active(entry, net_dev, true);\n\t\tIF_DEBUG(\"qtaguid: %s(%s): \"\n\t\t\t \"tracking now %d on ip=%pI4\\n\", __func__,\n\t\t\t entry->ifname, true, &ipaddr);\n\t\tgoto done_unlock_put;\n\t}\n\tnew_iface = iface_alloc(net_dev);\n\tIF_DEBUG(\"qtaguid: iface_stat: create(%s): done \"\n\t\t \"entry=%p ip=%pI4\\n\", ifname, new_iface, &ipaddr);\ndone_unlock_put:\n\tspin_unlock_bh(&iface_stat_list_lock);\ndone_put:\n\tif (in_dev)\n\t\tin_dev_put(in_dev);\n"]]}
{"hexsha": "8b37518f8cee6b7f60010949cbe78d9edc3fe978", "ext": "h", "lang": "C", "content": "class RenderManager {\npublic:\n    /**\n     * The constructor.\n     * @param applicationContext context to bind to this RenderManager\n     * @param windowManager user provided manager used for getting window render\n     */\n    RenderManager(ApplicationContext &applicationContext,\n                  WindowManager &windowManager);\n\n    /**\n     * Check if RenderManager has been successfully initialized.\n     * This usually means if the window has been successfully created.\n     * @return whether the constructor failed or not\n     */\n    bool initialized();\n    \n    /**\n     * Switch current window render (and reload it)\n     * @param window window to get render for\n     * @return return code. 0 on success, -1 on error\n     */\n    int switchWindow(Window &window);\n\n    /**\n     * Updates internally-held window dimensions.\n     * On mobile devices this method is triggered by screen rotation.\n     * Note that this method does not change the size of the window.\n     * @param width new width of the window\n     * @param height new height of the window\n     */\n    void resize(uint32_t width, uint32_t height);\n\n    /**\n     * Render current window render.\n     * This is called every tick.\n     */\n    void render();\n\n    /**\n     * The destructor.\n     * If SDL2 is used, this destructor destroys the physical window.\n     */\n    ~RenderManager();\n\nprivate:\n    int initWindow();\n    int initGL();\n\nprivate:\n    bool m_initialized = false;\n    ApplicationContext &m_applicationContext;\n    WindowManager &m_windowManager;\n    RenderContext m_renderContext;\n\n#ifdef USES_SDL\n    SDL_Window *m_sdlWindow = nullptr;\n    SDL_GL_Context *m_sdlContext = nullptr;\n#endif // USES_SDL\n\n    Window *m_currentWindow = nullptr;\n    WindowRender *m_windowRender = nullptr;\n}", "item_id": 0, "repo": "darsto/spooky", "file": "src/render/RenderManager.h", "last_update_at": "2018-12-16T15:50:44+00:00", "question_id": "8b37518f8cee6b7f60010949cbe78d9edc3fe978_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class RenderManager {\npublic:\n    /**\n     * The constructor.\n     * @param applicationContext context to bind to this RenderManager\n     * @param windowManager user provided manager used for getting window render\n     */\n    RenderManager(ApplicationContext &applicationContext,\n                  WindowManager &windowManager);\n    /**\n     * Check if RenderManager has been successfully initialized.\n     * This usually means if the window has been successfully created.\n     * @return whether the constructor failed or not\n     */\n    bool initialized();\n    /**\n     * Switch current window render (and reload it)\n     * @param window window to get render for\n     * @return return code. 0 on success, -1 on error\n     */\n    int switchWindow(Window &window);\n    /**\n     * Updates internally-held window dimensions.\n     * On mobile devices this method is triggered by screen rotation.\n     * Note that this method does not change the size of the window.\n     * @param width new width of the window\n     * @param height new height of the window\n     */\n    void resize(uint32_t width, uint32_t height);\n    /**\n     * Render current window render.\n     * This is called every tick.\n     */\n    void render();\n    /**\n     * The destructor.\n     * If SDL2 is used, this destructor destroys the physical window.\n     */\n    ~RenderManager();\nprivate:\n    int initWindow();\n    int initGL();\nprivate:\n    bool m_initialized = false;\n    ApplicationContext &m_applicationContext;\n    WindowManager &m_windowManager;\n    RenderContext m_renderContext;\n#ifdef USES_SDL\n    SDL_Window *m_sdlWindow = nullptr;\n    SDL_GL_Context *m_sdlContext = nullptr;\n#endif // USES_SDL\n    Window *m_currentWindow = nullptr;\n    WindowRender *m_windowRender = nullptr;\n"]]}
{"hexsha": "9c42be634291d497602a530f758d2e21569bf53a", "ext": "c", "lang": "C", "content": "char* inputEmail(){\n        static char typedEmail[SHORT_STRING_SIZE];\n        scanf(\" %[^\\n]%*c\",typedEmail);\n        while (checkEmail(typedEmail)==0) {\n                printf(\"\\t\\tThat's not an email. Please type in another email: \");\n                scanf(\" %[^\\n]%*c\",typedEmail);\n        }\n        int n=strlen(typedEmail);\n        for (int i=0; i<n;) {\n                if ((typedEmail[i]==' ') && (typedEmail[i+1]==' ')) {\n                        for (int j=i+1; j<n; j++) {\n                                typedEmail[j]=typedEmail[j+1];\n                        }\n                        n--;\n                } else i++;\n        }\n        return typedEmail;\n}", "item_id": 5, "repo": "lamhoangtung/Bai-tap-Lap-trinh-can-ban", "file": "Bai tap lon/main.c", "last_update_at": "2018-03-30T14:20:05+00:00", "question_id": "9c42be634291d497602a530f758d2e21569bf53a_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["char* inputEmail(){\n        static char typedEmail[SHORT_STRING_SIZE];\n        scanf(\" %[^\\n]%*c\",typedEmail);\n        while (checkEmail(typedEmail)==0) {\n                printf(\"\\t\\tThat's not an email. Please type in another email: \");\n                scanf(\" %[^\\n]%*c\",typedEmail);\n        }\n        int n=strlen(typedEmail);\n        for (int i=0; i<n;) {\n                if ((typedEmail[i]==' ') && (typedEmail[i+1]==' ')) {\n                        for (int j=i+1; j<n; j++) {\n                                typedEmail[j]=typedEmail[j+1];\n                        }\n                        n--;\n                } else i++;\n        }\n        return typedEmail;\n"]]}
{"hexsha": "03d33d89fbfea75238f3c892cc1a929ab751579d", "ext": "c", "lang": "C", "content": "void sbob_get(sbob_t *sb, sbob_pad_t pad, void *out, size_t len)\n{\n    int j;\n    size_t i;\n\n    j = sb->l;\n    for (i = 0; i < len; i++) {\n        if (j == SBOB_RATE) {\n            sb->s.b[SBOB_RATE] ^= pad;\n            SBOB_PI(&sb->s);\n            j = 0;\n        }\n        ((uint8_t *) out)[i] = sb->s.b[j++];\n    }\n    sb->l = j;\n}", "item_id": 3, "repo": "iadgov/simon-speck-supercop", "file": "crypto_aead/stribob192r2/ssse3/stribob.c", "last_update_at": "2018-03-09T14:52:25+00:00", "question_id": "03d33d89fbfea75238f3c892cc1a929ab751579d_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void sbob_get(sbob_t *sb, sbob_pad_t pad, void *out, size_t len)\n{\n    int j;\n    size_t i;\n    j = sb->l;\n    for (i = 0; i < len; i++) {\n        if (j == SBOB_RATE) {\n            sb->s.b[SBOB_RATE] ^= pad;\n            SBOB_PI(&sb->s);\n            j = 0;\n        }\n        ((uint8_t *) out)[i] = sb->s.b[j++];\n    }\n    sb->l = j;\n"]]}
{"hexsha": "01ba74950a39cb2b41656d82f17565f6521db65e", "ext": "c", "lang": "C", "content": "unit_t* protobuf_unit_reserved_id_new()\n{\n    struct protobuf_unit_reserved_id_t* unit = (struct protobuf_unit_reserved_id_t*)malloc(sizeof(struct protobuf_unit_reserved_id_t));\n    unit->super.size    =   sizeof(struct protobuf_unit_reserved_id_t);\n    unit->super.prev    =   NULL;\n    unit->super.mo      =   NULL;\n    unit->super.del     =   free;\n    unit->super.accept  =   protobuf_unit_reserved_id_accept;\n    unit->state         =   0;\n    return (struct unit_t*)(unit);\n}", "item_id": 1, "repo": "libbylg/gpr", "file": "plugins/plugins-protobuf/protobuf_unit_reserved_id.c", "last_update_at": "2018-06-06T05:56:25+00:00", "question_id": "01ba74950a39cb2b41656d82f17565f6521db65e_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unit_t* protobuf_unit_reserved_id_new()\n{\n    struct protobuf_unit_reserved_id_t* unit = (struct protobuf_unit_reserved_id_t*)malloc(sizeof(struct protobuf_unit_reserved_id_t));\n    unit->super.size    =   sizeof(struct protobuf_unit_reserved_id_t);\n    unit->super.prev    =   NULL;\n    unit->super.mo      =   NULL;\n    unit->super.del     =   free;\n    unit->super.accept  =   protobuf_unit_reserved_id_accept;\n    unit->state         =   0;\n    return (struct unit_t*)(unit);\n"]]}
{"hexsha": "856cfb40305d7f50984efb8527a86f96bb6858cf", "ext": "c", "lang": "C", "content": "int\nlibxlDomainStart(libxlDriverPrivatePtr driver, virDomainObjPtr vm,\n                 bool start_paused, int restore_fd)\n{\n    libxl_domain_config d_config;\n    virDomainDefPtr def = NULL;\n    virObjectEventPtr event = NULL;\n    libxlSavefileHeader hdr;\n    int ret = -1;\n    uint32_t domid = 0;\n    char *dom_xml = NULL;\n    char *managed_save_path = NULL;\n    int managed_save_fd = -1;\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    libxlDriverConfigPtr cfg;\n#ifdef LIBXL_HAVE_DOMAIN_CREATE_RESTORE_PARAMS\n    libxl_domain_restore_params params;\n#endif\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n    libxl_asyncprogress_how aop_console_how;\n\n    libxl_domain_config_init(&d_config);\n\n    if (libxlDomainObjPrivateInitCtx(vm) < 0)\n        return ret;\n\n    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)\n        return ret;\n\n    cfg = libxlDriverConfigGet(driver);\n    /* If there is a managed saved state restore it instead of starting\n     * from scratch. The old state is removed once the restoring succeeded. */\n    if (restore_fd < 0) {\n        managed_save_path = libxlDomainManagedSavePath(driver, vm);\n        if (managed_save_path == NULL)\n            goto endjob;\n\n        if (virFileExists(managed_save_path)) {\n\n            managed_save_fd = libxlDomainSaveImageOpen(driver, cfg,\n                                                       managed_save_path,\n                                                       &def, &hdr);\n            if (managed_save_fd < 0)\n                goto endjob;\n\n            restore_fd = managed_save_fd;\n\n            if (STRNEQ(vm->def->name, def->name) ||\n                memcmp(vm->def->uuid, def->uuid, VIR_UUID_BUFLEN)) {\n                char vm_uuidstr[VIR_UUID_STRING_BUFLEN];\n                char def_uuidstr[VIR_UUID_STRING_BUFLEN];\n                virUUIDFormat(vm->def->uuid, vm_uuidstr);\n                virUUIDFormat(def->uuid, def_uuidstr);\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"cannot restore domain '%s' uuid %s from a file\"\n                                 \" which belongs to domain '%s' uuid %s\"),\n                               vm->def->name, vm_uuidstr, def->name, def_uuidstr);\n                goto endjob;\n            }\n\n            virDomainObjAssignDef(vm, def, true, NULL);\n            def = NULL;\n\n            if (unlink(managed_save_path) < 0)\n                VIR_WARN(\"Failed to remove the managed state %s\",\n                         managed_save_path);\n\n            vm->hasManagedSave = false;\n        }\n        VIR_FREE(managed_save_path);\n    }\n\n    if (libxlBuildDomainConfig(driver->reservedVNCPorts, vm->def,\n                               priv->ctx, &d_config) < 0)\n        goto endjob;\n\n    if (cfg->autoballoon && libxlDomainFreeMem(priv, &d_config) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"libxenlight failed to get free memory for domain '%s'\"),\n                       d_config.c_info.name);\n        goto endjob;\n    }\n\n    if (virHostdevPrepareDomainDevices(hostdev_mgr, LIBXL_DRIVER_NAME,\n                                       vm->def, VIR_HOSTDEV_SP_PCI) < 0)\n        goto endjob;\n\n    /* Unlock virDomainObj while creating the domain */\n    virObjectUnlock(vm);\n\n    aop_console_how.for_callback = vm;\n    aop_console_how.callback = libxlConsoleCallback;\n    if (restore_fd < 0) {\n        ret = libxl_domain_create_new(priv->ctx, &d_config,\n                                      &domid, NULL, &aop_console_how);\n    } else {\n#ifdef LIBXL_HAVE_DOMAIN_CREATE_RESTORE_PARAMS\n        params.checkpointed_stream = 0;\n        ret = libxl_domain_create_restore(priv->ctx, &d_config, &domid,\n                                          restore_fd, &params, NULL,\n                                          &aop_console_how);\n#else\n        ret = libxl_domain_create_restore(priv->ctx, &d_config, &domid,\n                                          restore_fd, NULL, &aop_console_how);\n#endif\n    }\n    virObjectLock(vm);\n\n    if (ret) {\n        if (restore_fd < 0)\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"libxenlight failed to create new domain '%s'\"),\n                           d_config.c_info.name);\n        else\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"libxenlight failed to restore domain '%s'\"),\n                           d_config.c_info.name);\n        goto endjob;\n    }\n\n    /*\n     * The domain has been successfully created with libxl, so it should\n     * be cleaned up if there are any subsequent failures.\n     */\n    vm->def->id = domid;\n    if (libxlDomainEventsRegister(driver, vm) < 0)\n        goto cleanup_dom;\n\n    if ((dom_xml = virDomainDefFormat(vm->def, 0)) == NULL)\n        goto cleanup_dom;\n\n    if (libxl_userdata_store(priv->ctx, domid, \"libvirt-xml\",\n                             (uint8_t *)dom_xml, strlen(dom_xml) + 1)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libxenlight failed to store userdata\"));\n        goto cleanup_dom;\n    }\n\n    if (libxlDomainSetVcpuAffinities(driver, vm) < 0)\n        goto cleanup_dom;\n\n    if (!start_paused) {\n        libxl_domain_unpause(priv->ctx, domid);\n        virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, VIR_DOMAIN_RUNNING_BOOTED);\n    } else {\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_USER);\n    }\n\n    if (virDomainSaveStatus(driver->xmlopt, cfg->stateDir, vm) < 0)\n        goto cleanup_dom;\n\n    if (virAtomicIntInc(&driver->nactive) == 1 && driver->inhibitCallback)\n        driver->inhibitCallback(true, driver->inhibitOpaque);\n\n    event = virDomainEventLifecycleNewFromObj(vm, VIR_DOMAIN_EVENT_STARTED,\n                                     restore_fd < 0 ?\n                                         VIR_DOMAIN_EVENT_STARTED_BOOTED :\n                                         VIR_DOMAIN_EVENT_STARTED_RESTORED);\n    if (event)\n        libxlDomainEventQueue(driver, event);\n\n    ret = 0;\n    goto endjob;\n\n cleanup_dom:\n    libxl_domain_destroy(priv->ctx, domid, NULL);\n    vm->def->id = -1;\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, VIR_DOMAIN_SHUTOFF_FAILED);\n\n endjob:\n    if (!libxlDomainObjEndJob(driver, vm))\n        vm = NULL;\n\n    libxl_domain_config_dispose(&d_config);\n    VIR_FREE(dom_xml);\n    VIR_FREE(managed_save_path);\n    virDomainDefFree(def);\n    VIR_FORCE_CLOSE(managed_save_fd);\n    virObjectUnref(cfg);\n    return ret;\n}", "item_id": 30, "repo": "SIIS-cloud/pileus", "file": "libvirt/pileus-libvirt-1.2.12/src/libxl/libxl_domain.c", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "856cfb40305d7f50984efb8527a86f96bb6858cf_30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nlibxlDomainStart(libxlDriverPrivatePtr driver, virDomainObjPtr vm,\n                 bool start_paused, int restore_fd)\n{\n    libxl_domain_config d_config;\n    virDomainDefPtr def = NULL;\n    virObjectEventPtr event = NULL;\n    libxlSavefileHeader hdr;\n    int ret = -1;\n    uint32_t domid = 0;\n    char *dom_xml = NULL;\n    char *managed_save_path = NULL;\n    int managed_save_fd = -1;\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    libxlDriverConfigPtr cfg;\n#ifdef LIBXL_HAVE_DOMAIN_CREATE_RESTORE_PARAMS\n    libxl_domain_restore_params params;\n#endif\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n    libxl_asyncprogress_how aop_console_how;\n    libxl_domain_config_init(&d_config);\n    if (libxlDomainObjPrivateInitCtx(vm) < 0)\n        return ret;\n    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)\n        return ret;\n    cfg = libxlDriverConfigGet(driver);\n    /* If there is a managed saved state restore it instead of starting\n     * from scratch. The old state is removed once the restoring succeeded. */\n    if (restore_fd < 0) {\n        managed_save_path = libxlDomainManagedSavePath(driver, vm);\n        if (managed_save_path == NULL)\n            goto endjob;\n        if (virFileExists(managed_save_path)) {\n            managed_save_fd = libxlDomainSaveImageOpen(driver, cfg,\n                                                       managed_save_path,\n                                                       &def, &hdr);\n            if (managed_save_fd < 0)\n                goto endjob;\n            restore_fd = managed_save_fd;\n            if (STRNEQ(vm->def->name, def->name) ||\n                memcmp(vm->def->uuid, def->uuid, VIR_UUID_BUFLEN)) {\n                char vm_uuidstr[VIR_UUID_STRING_BUFLEN];\n                char def_uuidstr[VIR_UUID_STRING_BUFLEN];\n                virUUIDFormat(vm->def->uuid, vm_uuidstr);\n                virUUIDFormat(def->uuid, def_uuidstr);\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"cannot restore domain '%s' uuid %s from a file\"\n                                 \" which belongs to domain '%s' uuid %s\"),\n                               vm->def->name, vm_uuidstr, def->name, def_uuidstr);\n                goto endjob;\n            }\n            virDomainObjAssignDef(vm, def, true, NULL);\n            def = NULL;\n            if (unlink(managed_save_path) < 0)\n                VIR_WARN(\"Failed to remove the managed state %s\",\n                         managed_save_path);\n            vm->hasManagedSave = false;\n        }\n        VIR_FREE(managed_save_path);\n    }\n    if (libxlBuildDomainConfig(driver->reservedVNCPorts, vm->def,\n                               priv->ctx, &d_config) < 0)\n        goto endjob;\n    if (cfg->autoballoon && libxlDomainFreeMem(priv, &d_config) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"libxenlight failed to get free memory for domain '%s'\"),\n                       d_config.c_info.name);\n        goto endjob;\n    }\n    if (virHostdevPrepareDomainDevices(hostdev_mgr, LIBXL_DRIVER_NAME,\n                                       vm->def, VIR_HOSTDEV_SP_PCI) < 0)\n        goto endjob;\n    /* Unlock virDomainObj while creating the domain */\n    virObjectUnlock(vm);\n    aop_console_how.for_callback = vm;\n    aop_console_how.callback = libxlConsoleCallback;\n    if (restore_fd < 0) {\n        ret = libxl_domain_create_new(priv->ctx, &d_config,\n                                      &domid, NULL, &aop_console_how);\n    } else {\n#ifdef LIBXL_HAVE_DOMAIN_CREATE_RESTORE_PARAMS\n        params.checkpointed_stream = 0;\n        ret = libxl_domain_create_restore(priv->ctx, &d_config, &domid,\n                                          restore_fd, &params, NULL,\n                                          &aop_console_how);\n#else\n        ret = libxl_domain_create_restore(priv->ctx, &d_config, &domid,\n                                          restore_fd, NULL, &aop_console_how);\n#endif\n    }\n    virObjectLock(vm);\n    if (ret) {\n        if (restore_fd < 0)\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"libxenlight failed to create new domain '%s'\"),\n                           d_config.c_info.name);\n        else\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"libxenlight failed to restore domain '%s'\"),\n                           d_config.c_info.name);\n        goto endjob;\n    }\n    /*\n     * The domain has been successfully created with libxl, so it should\n     * be cleaned up if there are any subsequent failures.\n     */\n    vm->def->id = domid;\n    if (libxlDomainEventsRegister(driver, vm) < 0)\n        goto cleanup_dom;\n    if ((dom_xml = virDomainDefFormat(vm->def, 0)) == NULL)\n        goto cleanup_dom;\n    if (libxl_userdata_store(priv->ctx, domid, \"libvirt-xml\",\n                             (uint8_t *)dom_xml, strlen(dom_xml) + 1)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libxenlight failed to store userdata\"));\n        goto cleanup_dom;\n    }\n    if (libxlDomainSetVcpuAffinities(driver, vm) < 0)\n        goto cleanup_dom;\n    if (!start_paused) {\n        libxl_domain_unpause(priv->ctx, domid);\n        virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, VIR_DOMAIN_RUNNING_BOOTED);\n    } else {\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_USER);\n    }\n    if (virDomainSaveStatus(driver->xmlopt, cfg->stateDir, vm) < 0)\n        goto cleanup_dom;\n    if (virAtomicIntInc(&driver->nactive) == 1 && driver->inhibitCallback)\n        driver->inhibitCallback(true, driver->inhibitOpaque);\n    event = virDomainEventLifecycleNewFromObj(vm, VIR_DOMAIN_EVENT_STARTED,\n                                     restore_fd < 0 ?\n                                         VIR_DOMAIN_EVENT_STARTED_BOOTED :\n                                         VIR_DOMAIN_EVENT_STARTED_RESTORED);\n    if (event)\n        libxlDomainEventQueue(driver, event);\n    ret = 0;\n    goto endjob;\n cleanup_dom:\n    libxl_domain_destroy(priv->ctx, domid, NULL);\n    vm->def->id = -1;\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, VIR_DOMAIN_SHUTOFF_FAILED);\n endjob:\n    if (!libxlDomainObjEndJob(driver, vm))\n        vm = NULL;\n    libxl_domain_config_dispose(&d_config);\n    VIR_FREE(dom_xml);\n    VIR_FREE(managed_save_path);\n    virDomainDefFree(def);\n    VIR_FORCE_CLOSE(managed_save_fd);\n    virObjectUnref(cfg);\n    return ret;\n"]]}
{"hexsha": "6c3e3e9185d253fad28e77c74fe76ba930085b8b", "ext": "c", "lang": "C", "content": "static u8 ft5x0x_enter_work(struct ft5x0x_ts_data *ft5x0x_ts)\n{\n\tu8 regval;\n   \t ft5x0x_write_reg(0x00, 0x00); //return to normal mode \n   \t msleep(100);\n\t\n\tif(ft5x0x_read_reg(0x00, &regval)<0)\n\t\tpr_err(\"%s ERROR: could not read register\\n\", __FUNCTION__);\n\telse\n\t{\n\t\tif((regval & 0x70) != 0x00)\n\t\t{\n\t\t\tpr_err(\"%s() - ERROR: The Touch Panel was not put in Work Mode. The Device Mode register contains 0x%02X\\n\", __FUNCTION__, regval);\n\t\t\tenable_irq(IRQ_EINT(6));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tenable_irq(IRQ_EINT(6));\n\treturn 0;\n}", "item_id": 25, "repo": "ADu1975/ADu_Tiny210", "file": "touchscreen/ft5x06_ts.c", "last_update_at": "2018-04-21T00:58:53+00:00", "question_id": "6c3e3e9185d253fad28e77c74fe76ba930085b8b_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static u8 ft5x0x_enter_work(struct ft5x0x_ts_data *ft5x0x_ts)\n{\n\tu8 regval;\n   \t ft5x0x_write_reg(0x00, 0x00); //return to normal mode \n   \t msleep(100);\n\t\n\tif(ft5x0x_read_reg(0x00, &regval)<0)\n\t\tpr_err(\"%s ERROR: could not read register\\n\", __FUNCTION__);\n\telse\n\t{\n\t\tif((regval & 0x70) != 0x00)\n\t\t{\n\t\t\tpr_err(\"%s() - ERROR: The Touch Panel was not put in Work Mode. The Device Mode register contains 0x%02X\\n\", __FUNCTION__, regval);\n\t\t\tenable_irq(IRQ_EINT(6));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tenable_irq(IRQ_EINT(6));\n\treturn 0;\n"]]}
{"hexsha": "9d2255f856edc9b70b053da580eed33bada01390", "ext": "c", "lang": "C", "content": "void\nIdeq_clearData (\n   Ideq   *deq\n) {\nif ( deq == NULL ) {\n   fprintf(stderr, \"\\n fatal error in Ideq_clearData(%p)\"\n           \"\\n deq is NULL\\n\", deq) ;\n   exit(-1) ;\n}\nIV_clearData(&deq->iv) ;\nIdeq_setDefaultFields(deq) ;\n\nreturn ; }", "item_id": 2, "repo": "alleindrach/calculix-desktop", "file": "ccx_prool/SPOOLES.2.2/Ideq/src/basics.c", "last_update_at": "2018-01-25T16:08:31+00:00", "question_id": "9d2255f856edc9b70b053da580eed33bada01390_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nIdeq_clearData (\n   Ideq   *deq\n) {\nif ( deq == NULL ) {\n   fprintf(stderr, \"\\n fatal error in Ideq_clearData(%p)\"\n           \"\\n deq is NULL\\n\", deq) ;\n   exit(-1) ;\n}\nIV_clearData(&deq->iv) ;\nIdeq_setDefaultFields(deq) ;\n"]]}
{"hexsha": "a287e4fec8653d91e55bb2765e2379984b65bef5", "ext": "c", "lang": "C", "content": "static void tegra_crtc_mode_set_nofb(struct drm_crtc *crtc)\n{\n\tstruct drm_display_mode *mode = &crtc->state->adjusted_mode;\n\tstruct tegra_dc_state *state = to_dc_state(crtc->state);\n\tstruct tegra_dc *dc = to_tegra_dc(crtc);\n\tu32 value;\n\n\ttegra_dc_commit_state(dc, state);\n\n\t/* program display mode */\n\ttegra_dc_set_timings(dc, mode);\n\n\t/* interlacing isn't supported yet, so disable it */\n\tif (dc->soc->supports_interlacing) {\n\t\tvalue = tegra_dc_readl(dc, DC_DISP_INTERLACE_CONTROL);\n\t\tvalue &= ~INTERLACE_ENABLE;\n\t\ttegra_dc_writel(dc, value, DC_DISP_INTERLACE_CONTROL);\n\t}\n\n\tvalue = tegra_dc_readl(dc, DC_CMD_DISPLAY_COMMAND);\n\tvalue &= ~DISP_CTRL_MODE_MASK;\n\tvalue |= DISP_CTRL_MODE_C_DISPLAY;\n\ttegra_dc_writel(dc, value, DC_CMD_DISPLAY_COMMAND);\n\n\tvalue = tegra_dc_readl(dc, DC_CMD_DISPLAY_POWER_CONTROL);\n\tvalue |= PW0_ENABLE | PW1_ENABLE | PW2_ENABLE | PW3_ENABLE |\n\t\t PW4_ENABLE | PM0_ENABLE | PM1_ENABLE;\n\ttegra_dc_writel(dc, value, DC_CMD_DISPLAY_POWER_CONTROL);\n\n\ttegra_dc_commit(dc);\n}", "item_id": 33, "repo": "SIIS-cloud/pileus", "file": "difc-kernel/pileus-kernel/drivers/gpu/drm/tegra/dc.c", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "a287e4fec8653d91e55bb2765e2379984b65bef5_33", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void tegra_crtc_mode_set_nofb(struct drm_crtc *crtc)\n{\n\tstruct drm_display_mode *mode = &crtc->state->adjusted_mode;\n\tstruct tegra_dc_state *state = to_dc_state(crtc->state);\n\tstruct tegra_dc *dc = to_tegra_dc(crtc);\n\tu32 value;\n\ttegra_dc_commit_state(dc, state);\n\t/* program display mode */\n\ttegra_dc_set_timings(dc, mode);\n\t/* interlacing isn't supported yet, so disable it */\n\tif (dc->soc->supports_interlacing) {\n\t\tvalue = tegra_dc_readl(dc, DC_DISP_INTERLACE_CONTROL);\n\t\tvalue &= ~INTERLACE_ENABLE;\n\t\ttegra_dc_writel(dc, value, DC_DISP_INTERLACE_CONTROL);\n\t}\n\tvalue = tegra_dc_readl(dc, DC_CMD_DISPLAY_COMMAND);\n\tvalue &= ~DISP_CTRL_MODE_MASK;\n\tvalue |= DISP_CTRL_MODE_C_DISPLAY;\n\ttegra_dc_writel(dc, value, DC_CMD_DISPLAY_COMMAND);\n\tvalue = tegra_dc_readl(dc, DC_CMD_DISPLAY_POWER_CONTROL);\n\tvalue |= PW0_ENABLE | PW1_ENABLE | PW2_ENABLE | PW3_ENABLE |\n\t\t PW4_ENABLE | PM0_ENABLE | PM1_ENABLE;\n\ttegra_dc_writel(dc, value, DC_CMD_DISPLAY_POWER_CONTROL);\n\ttegra_dc_commit(dc);\n"]]}
{"hexsha": "87e8684fbb5ae26011208b1e4e3d02d0b26431a6", "ext": "c", "lang": "C", "content": "TEST_CASE(hostent_2)\r\n{\r\n  struct hostent *phents[1024], *phent2;\r\n  int i = 0, j = 0;\r\n  sethostent(1);\r\n  while (phents[i] = gethostent()) {\r\n    TEST_FAIL_IF(phents[i]->h_name == NULL);\r\n    TEST_FAIL_IF(phents[i]->h_aliases == NULL);\r\n    TEST_FAIL_IF(phents[i]->h_addr_list == NULL);\r\n    TEST_FAIL_IF(phents[i]->h_addr_list[0] == NULL);\r\n    phents[i] = dup_hostent(phents[i]);\r\n    ++i;\r\n  }\r\n  sethostent(1);\r\n  for (j = 0; j < i && (phent2 = gethostent()); ++j) {\r\n    TEST_FAIL_IF(!compare_hostent(phents[j], phent2));\r\n    free_hostent(phents[j]);\r\n  }\r\n  endhostent();\r\n  TEST(i == j);\r\n}", "item_id": 4, "repo": "block8437/FailSafeC", "file": "test/net/gethostent.test.c", "last_update_at": "2018-02-10T02:52:09+00:00", "question_id": "87e8684fbb5ae26011208b1e4e3d02d0b26431a6_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["TEST_CASE(hostent_2)\r\n{\r\n  struct hostent *phents[1024], *phent2;\r\n  int i = 0, j = 0;\r\n  sethostent(1);\r\n  while (phents[i] = gethostent()) {\r\n    TEST_FAIL_IF(phents[i]->h_name == NULL);\r\n    TEST_FAIL_IF(phents[i]->h_aliases == NULL);\r\n    TEST_FAIL_IF(phents[i]->h_addr_list == NULL);\r\n    TEST_FAIL_IF(phents[i]->h_addr_list[0] == NULL);\r\n    phents[i] = dup_hostent(phents[i]);\r\n    ++i;\r\n  }\r\n  sethostent(1);\r\n  for (j = 0; j < i && (phent2 = gethostent()); ++j) {\r\n    TEST_FAIL_IF(!compare_hostent(phents[j], phent2));\r\n    free_hostent(phents[j]);\r\n  }\r\n  endhostent();\r\n  TEST(i == j);\r\n"]]}
{"hexsha": "cd55970a730beac9c922670954f3e58beb009dbe", "ext": "c", "lang": "C", "content": "void SystemClock_Config(void)\r\n{\r\n  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};\r\n  RCC_OscInitTypeDef RCC_OscInitStruct = {0};\r\n\r\n  /* Enable HSE Oscillator and activate PLL with HSE as source   */\r\n  /* (Default MSI Oscillator enabled at system reset remains ON) */\r\n  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;\r\n  RCC_OscInitStruct.HSEState = RCC_HSE_ON;\r\n  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;\r\n  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;\r\n  RCC_OscInitStruct.PLL.PLLM = 1;\r\n  RCC_OscInitStruct.PLL.PLLN = 20;\r\n  RCC_OscInitStruct.PLL.PLLR = 2;\r\n  RCC_OscInitStruct.PLL.PLLP = 7;\r\n  RCC_OscInitStruct.PLL.PLLQ = 4;\r\n  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)\r\n  {\r\n    /* Initialization Error */\r\n    while(1);\r\n  }\r\n\r\n  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2\r\n     clocks dividers */\r\n  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);\r\n  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\r\n  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;\r\n  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;\r\n  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;\r\n  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)\r\n  {\r\n    /* Initialization Error */\r\n    while(1);\r\n  }\r\n}", "item_id": 1, "repo": "dpalchak/estoppel", "file": "third_party/st/stm32l4_sdk/v1.12.0/Projects/STM32L476G-EVAL/Examples/DFSDM/DFSDM_Thermometer/Src/main.c", "last_update_at": "2018-08-03T20:06:40+00:00", "question_id": "cd55970a730beac9c922670954f3e58beb009dbe_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void SystemClock_Config(void)\r\n{\r\n  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};\r\n  RCC_OscInitTypeDef RCC_OscInitStruct = {0};\r\n\r\n  /* Enable HSE Oscillator and activate PLL with HSE as source   */\r\n  /* (Default MSI Oscillator enabled at system reset remains ON) */\r\n  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;\r\n  RCC_OscInitStruct.HSEState = RCC_HSE_ON;\r\n  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;\r\n  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;\r\n  RCC_OscInitStruct.PLL.PLLM = 1;\r\n  RCC_OscInitStruct.PLL.PLLN = 20;\r\n  RCC_OscInitStruct.PLL.PLLR = 2;\r\n  RCC_OscInitStruct.PLL.PLLP = 7;\r\n  RCC_OscInitStruct.PLL.PLLQ = 4;\r\n  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)\r\n  {\r\n    /* Initialization Error */\r\n    while(1);\r\n  }\r\n\r\n  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2\r\n     clocks dividers */\r\n  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);\r\n  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\r\n  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;\r\n  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;\r\n  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;\r\n  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)\r\n  {\r\n    /* Initialization Error */\r\n    while(1);\r\n  }\r\n"]]}
{"hexsha": "580b8d3488ff6c54622c01ff6ac51fb360b15fad", "ext": "c", "lang": "C", "content": "void\nwrap_restore_saved()\n{\n    if(!wrap_saved_list)\n\treturn;\n\n    wrap_kill();\n\n    free(wrap_list);\n\n    wrap_list=wrap_saved_list;\n    wrap_count=wrap_saved_count;\n    wrap_tempcount=wrap_saved_tempcount;\n\n    wrap_saved_list=NULL;\n    wrap_saved_count=0;\n    wrap_saved_tempcount=0;\n}", "item_id": 2, "repo": "aaliomer/exos", "file": "bin/CVS/src/wrapper.c", "last_update_at": "2018-01-23T23:07:19+00:00", "question_id": "580b8d3488ff6c54622c01ff6ac51fb360b15fad_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nwrap_restore_saved()\n{\n    if(!wrap_saved_list)\n\treturn;\n    wrap_kill();\n    free(wrap_list);\n    wrap_list=wrap_saved_list;\n    wrap_count=wrap_saved_count;\n    wrap_tempcount=wrap_saved_tempcount;\n    wrap_saved_list=NULL;\n    wrap_saved_count=0;\n    wrap_saved_tempcount=0;\n"]]}
{"hexsha": "19fca939331151c84921e15fa45f4ad7cf30d950", "ext": "c", "lang": "C", "content": "const char *\nbcmptm_rm_alpm_kt_name(int u, alpm_key_type_t kt)\n{\n    char *name;\n    switch (kt) {\n    case KEY_TYPE_INVALID:\n        name = \"Invalid\";\n        break;\n    case KEY_IPV4:\n        name = \"IPv4\";\n        break;\n    case KEY_IPV6_32:\n        name = \"IPv6-32\";\n        break;\n    case KEY_IPV6_64:\n        name = \"IPv6-64\";\n        break;\n    case KEY_IPV6_128:\n        name = \"IPv6-128\";\n        break;\n    default:\n        name = \"?\";\n        break;\n    }\n    return name;\n}", "item_id": 3, "repo": "lguohan/SDKLT", "file": "src/bcmptm/rm_alpm/rm_alpm_util.c", "last_update_at": "2018-01-31T07:21:49+00:00", "question_id": "19fca939331151c84921e15fa45f4ad7cf30d950_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["const char *\nbcmptm_rm_alpm_kt_name(int u, alpm_key_type_t kt)\n{\n    char *name;\n    switch (kt) {\n    case KEY_TYPE_INVALID:\n        name = \"Invalid\";\n        break;\n    case KEY_IPV4:\n        name = \"IPv4\";\n        break;\n    case KEY_IPV6_32:\n        name = \"IPv6-32\";\n        break;\n    case KEY_IPV6_64:\n        name = \"IPv6-64\";\n        break;\n    case KEY_IPV6_128:\n        name = \"IPv6-128\";\n        break;\n    default:\n        name = \"?\";\n        break;\n    }\n    return name;\n"]]}
{"hexsha": "ec79c49de0975651a5e2cdebdd058fc312308537", "ext": "c", "lang": "C", "content": "int mwifiex_recv_packet(struct mwifiex_private *priv, struct sk_buff *skb)\n{\n\tif (!skb)\n\t\treturn -1;\n\n\tpriv->stats.rx_bytes += skb->len;\n\tpriv->stats.rx_packets++;\n\n\tskb->dev = priv->netdev;\n\tskb->protocol = eth_type_trans(skb, priv->netdev);\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\t/* This is required only in case of 11n and USB/PCIE as we alloc\n\t * a buffer of 4K only if its 11N (to be able to receive 4K\n\t * AMSDU packets). In case of SD we allocate buffers based\n\t * on the size of packet and hence this is not needed.\n\t *\n\t * Modifying the truesize here as our allocation for each\n\t * skb is 4K but we only receive 2K packets and this cause\n\t * the kernel to start dropping packets in case where\n\t * application has allocated buffer based on 2K size i.e.\n\t * if there a 64K packet received (in IP fragments and\n\t * application allocates 64K to receive this packet but\n\t * this packet would almost double up because we allocate\n\t * each 1.5K fragment in 4K and pass it up. As soon as the\n\t * 64K limit hits kernel will start to drop rest of the\n\t * fragments. Currently we fail the Filesndl-ht.scr script\n\t * for UDP, hence this fix\n\t */\n\tif ((priv->adapter->iface_type == MWIFIEX_USB ||\n\t     priv->adapter->iface_type == MWIFIEX_PCIE) &&\n\t    (skb->truesize > MWIFIEX_RX_DATA_BUF_SIZE))\n\t\tskb->truesize += (skb->len - MWIFIEX_RX_DATA_BUF_SIZE);\n\n\tif (in_interrupt())\n\t\tnetif_rx(skb);\n\telse\n\t\tnetif_rx_ni(skb);\n\n\treturn 0;\n}", "item_id": 5, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/drivers/net/wireless/mwifiex/util.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "ec79c49de0975651a5e2cdebdd058fc312308537_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int mwifiex_recv_packet(struct mwifiex_private *priv, struct sk_buff *skb)\n{\n\tif (!skb)\n\t\treturn -1;\n\tpriv->stats.rx_bytes += skb->len;\n\tpriv->stats.rx_packets++;\n\tskb->dev = priv->netdev;\n\tskb->protocol = eth_type_trans(skb, priv->netdev);\n\tskb->ip_summed = CHECKSUM_NONE;\n\t/* This is required only in case of 11n and USB/PCIE as we alloc\n\t * a buffer of 4K only if its 11N (to be able to receive 4K\n\t * AMSDU packets). In case of SD we allocate buffers based\n\t * on the size of packet and hence this is not needed.\n\t *\n\t * Modifying the truesize here as our allocation for each\n\t * skb is 4K but we only receive 2K packets and this cause\n\t * the kernel to start dropping packets in case where\n\t * application has allocated buffer based on 2K size i.e.\n\t * if there a 64K packet received (in IP fragments and\n\t * application allocates 64K to receive this packet but\n\t * this packet would almost double up because we allocate\n\t * each 1.5K fragment in 4K and pass it up. As soon as the\n\t * 64K limit hits kernel will start to drop rest of the\n\t * fragments. Currently we fail the Filesndl-ht.scr script\n\t * for UDP, hence this fix\n\t */\n\tif ((priv->adapter->iface_type == MWIFIEX_USB ||\n\t     priv->adapter->iface_type == MWIFIEX_PCIE) &&\n\t    (skb->truesize > MWIFIEX_RX_DATA_BUF_SIZE))\n\t\tskb->truesize += (skb->len - MWIFIEX_RX_DATA_BUF_SIZE);\n\tif (in_interrupt())\n\t\tnetif_rx(skb);\n\telse\n\t\tnetif_rx_ni(skb);\n\treturn 0;\n"]]}
{"hexsha": "a8a2d773786fd4a6483dec56e197b93241634bdd", "ext": "c", "lang": "C", "content": "static FILE *checkouthistofile(char *filename, qfits_header **header, qfits_header **hheader)\n{\n  FILE *checkouthistofile;\n  int next;\n  int header_startpos;\n\n  /* First check if there is such a file and if it is a fits */\n  if (qfits_is_fits(filename) != 1) {\n    if (!(checkouthistofile = fopen(filename, \"w+\"))) {\n      return NULL;\n    }\n\n    /* The file cannot have a history header */\n    *hheader = NULL;\n\n    /* Make a default primary header */\n    if ((*header = qfits_header_default()) == NULL)\n      return NULL;\n    \n    qfits_header_add(*header,\"BITPIX\",\"32\",NULL,NULL);\n    qfits_header_add(*header,\"NAXIS\",\"2\",NULL,NULL);\n    qfits_header_add(*header,\"NAXIS1\",\"100\",NULL,NULL);\n    qfits_header_add(*header,\"NAXIS2\",\"1\",NULL,NULL);\n    qfits_header_add(*header,\"EXTEND\",\"T\",NULL,NULL);\n    \n    qfits_header_add(*header,\"BSCALE\",\"1\",NULL,NULL);\n    qfits_header_add(*header,\"BZERO\",\"0\",NULL,NULL);\n    qfits_header_add(*header,\"BUNIT\",\"'count'\",NULL,NULL);\n    qfits_header_add(*header,\"BTYPE\",\"' '\",NULL,NULL);\n    \n    qfits_header_add(*header,\"CDELT1\", \"0.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRPIX1\", \"1.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRVAL1\", \"0.0\",NULL,NULL);\n    qfits_header_add(*header,\"CTYPE1\", \"' '\",NULL,NULL);\n    qfits_header_add(*header,\"CUNIT1\", \"' '\",NULL,NULL);\n    \n    qfits_header_add(*header,\"CDELT2\", \"1.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRPIX2\", \"1.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRVAL2\", \"0.0\",NULL,NULL);\n    qfits_header_add(*header,\"CTYPE2\", \"' '\",NULL,NULL);\n    qfits_header_add(*header,\"CUNIT2\", \"'Y'\",NULL,NULL);\n\n    qfits_header_add(*header, \"TITLE1\", \"' '\", NULL, NULL);\n    qfits_header_add(*header, \"TITLE2\", \"' '\", NULL, NULL);\n    qfits_header_add(*header, \"RADIUS1\", \"0.0\", NULL, NULL);\n    qfits_header_add(*header, \"RADIUS2\", \"0.0\", NULL, NULL);\n    qfits_header_add(*header, \"HISTORY\", \"'Generated by ftstab'\", NULL, NULL);\n  }\n    \n  /* It is a fits file */\n  else {\n\n    /* Now check for the number of extensions */\n    *hheader = checkhheader(filename);\n\n    /* Get the number of extensions */\n    next = qfits_query_n_ext(filename);\n\n    /* Do a refresh immediately */\n    qfits_cache_purge();\n\n    if (*hheader)\n      /* Get the position to put the fileposition */\n      qfits_get_hdrinfo(filename, next, &header_startpos, NULL);\n\n    /* Try to open the file */\n    if (!(checkouthistofile = fopen(filename, \"r+\"))) {\n      return NULL;\n    }\n    /* Go to the right position and delete the rest */\n\n    if (*hheader) {\n      fseek(checkouthistofile, (long) header_startpos, SEEK_SET);\n      if(ftruncate(fileno(stream_), ftell(checkouthistofile)))\n\t;\n      clearerr(stream_);\n    }    \n    else\n      fseek(checkouthistofile, 0L, SEEK_END);\n\n    /* Now make a default extension header */\n    if ((*header = qfits_header_new()) == NULL)\n      return NULL;\n\n    qfits_header_append(*header,\"XTENSION\",\"'IMAGE             '\",\"\",\"\");\n    qfits_header_append(*header,\"END\",\"\",\"\",\"\");\n\n    qfits_header_add(*header,\"BITPIX\",\"32\",NULL,NULL);\n    qfits_header_add(*header,\"NAXIS\",\"2\",NULL,NULL);\n    qfits_header_add(*header,\"NAXIS1\",\"100\",NULL,NULL);\n    qfits_header_add(*header,\"NAXIS2\",\"1\",NULL,NULL);\n    qfits_header_add(*header,\"EXTEND\",\"T\",NULL,NULL);\n    \n    qfits_header_add(*header,\"BSCALE\",\"1\",NULL,NULL);\n    qfits_header_add(*header,\"BZERO\",\"0\",NULL,NULL);\n    qfits_header_add(*header,\"BUNIT\",\"'count'\",NULL,NULL);\n    qfits_header_add(*header,\"BTYPE\",\"' '\",NULL,NULL);\n    \n    qfits_header_add(*header,\"CDELT1\", \"0.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRPIX1\", \"1.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRVAL1\", \"0.0\",NULL,NULL);\n    qfits_header_add(*header,\"CTYPE1\", \"' '\",NULL,NULL);\n    qfits_header_add(*header,\"CUNIT1\", \"' '\",NULL,NULL);\n    \n    qfits_header_add(*header,\"CDELT2\", \"1.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRPIX2\", \"1.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRVAL2\", \"0.0\",NULL,NULL);\n    qfits_header_add(*header,\"CTYPE2\", \"' '\",NULL,NULL);\n    qfits_header_add(*header,\"CUNIT2\", \"'Y'\",NULL,NULL);\n\n    qfits_header_add(*header, \"TITLE1\", \"' '\", NULL, NULL);\n    qfits_header_add(*header, \"TITLE2\", \"' '\", NULL, NULL);\n    qfits_header_add(*header, \"RADIUS1\", \"0.0\", NULL, NULL);\n    qfits_header_add(*header, \"RADIUS2\", \"0.0\", NULL, NULL);\n    qfits_header_add(*header, \"HISTORY\", \"'generated by ftstab'\", NULL, NULL);\n  }\n\n  return checkouthistofile;\n}", "item_id": 60, "repo": "kernsuite-debian/tirific", "file": "src/ftstab.c", "last_update_at": "2018-01-04T08:22:01+00:00", "question_id": "a8a2d773786fd4a6483dec56e197b93241634bdd_60", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static FILE *checkouthistofile(char *filename, qfits_header **header, qfits_header **hheader)\n{\n  FILE *checkouthistofile;\n  int next;\n  int header_startpos;\n  /* First check if there is such a file and if it is a fits */\n  if (qfits_is_fits(filename) != 1) {\n    if (!(checkouthistofile = fopen(filename, \"w+\"))) {\n      return NULL;\n    }\n    /* The file cannot have a history header */\n    *hheader = NULL;\n    /* Make a default primary header */\n    if ((*header = qfits_header_default()) == NULL)\n      return NULL;\n    qfits_header_add(*header,\"BITPIX\",\"32\",NULL,NULL);\n    qfits_header_add(*header,\"NAXIS\",\"2\",NULL,NULL);\n    qfits_header_add(*header,\"NAXIS1\",\"100\",NULL,NULL);\n    qfits_header_add(*header,\"NAXIS2\",\"1\",NULL,NULL);\n    qfits_header_add(*header,\"EXTEND\",\"T\",NULL,NULL);\n    qfits_header_add(*header,\"BSCALE\",\"1\",NULL,NULL);\n    qfits_header_add(*header,\"BZERO\",\"0\",NULL,NULL);\n    qfits_header_add(*header,\"BUNIT\",\"'count'\",NULL,NULL);\n    qfits_header_add(*header,\"BTYPE\",\"' '\",NULL,NULL);\n    qfits_header_add(*header,\"CDELT1\", \"0.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRPIX1\", \"1.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRVAL1\", \"0.0\",NULL,NULL);\n    qfits_header_add(*header,\"CTYPE1\", \"' '\",NULL,NULL);\n    qfits_header_add(*header,\"CUNIT1\", \"' '\",NULL,NULL);\n    qfits_header_add(*header,\"CDELT2\", \"1.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRPIX2\", \"1.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRVAL2\", \"0.0\",NULL,NULL);\n    qfits_header_add(*header,\"CTYPE2\", \"' '\",NULL,NULL);\n    qfits_header_add(*header,\"CUNIT2\", \"'Y'\",NULL,NULL);\n    qfits_header_add(*header, \"TITLE1\", \"' '\", NULL, NULL);\n    qfits_header_add(*header, \"TITLE2\", \"' '\", NULL, NULL);\n    qfits_header_add(*header, \"RADIUS1\", \"0.0\", NULL, NULL);\n    qfits_header_add(*header, \"RADIUS2\", \"0.0\", NULL, NULL);\n    qfits_header_add(*header, \"HISTORY\", \"'Generated by ftstab'\", NULL, NULL);\n  }\n  /* It is a fits file */\n  else {\n    /* Now check for the number of extensions */\n    *hheader = checkhheader(filename);\n    /* Get the number of extensions */\n    next = qfits_query_n_ext(filename);\n    /* Do a refresh immediately */\n    qfits_cache_purge();\n    if (*hheader)\n      /* Get the position to put the fileposition */\n      qfits_get_hdrinfo(filename, next, &header_startpos, NULL);\n    /* Try to open the file */\n    if (!(checkouthistofile = fopen(filename, \"r+\"))) {\n      return NULL;\n    }\n    /* Go to the right position and delete the rest */\n    if (*hheader) {\n      fseek(checkouthistofile, (long) header_startpos, SEEK_SET);\n      if(ftruncate(fileno(stream_), ftell(checkouthistofile)))\n\t;\n      clearerr(stream_);\n    }    \n    else\n      fseek(checkouthistofile, 0L, SEEK_END);\n    /* Now make a default extension header */\n    if ((*header = qfits_header_new()) == NULL)\n      return NULL;\n    qfits_header_append(*header,\"XTENSION\",\"'IMAGE             '\",\"\",\"\");\n    qfits_header_append(*header,\"END\",\"\",\"\",\"\");\n    qfits_header_add(*header,\"BITPIX\",\"32\",NULL,NULL);\n    qfits_header_add(*header,\"NAXIS\",\"2\",NULL,NULL);\n    qfits_header_add(*header,\"NAXIS1\",\"100\",NULL,NULL);\n    qfits_header_add(*header,\"NAXIS2\",\"1\",NULL,NULL);\n    qfits_header_add(*header,\"EXTEND\",\"T\",NULL,NULL);\n    qfits_header_add(*header,\"BSCALE\",\"1\",NULL,NULL);\n    qfits_header_add(*header,\"BZERO\",\"0\",NULL,NULL);\n    qfits_header_add(*header,\"BUNIT\",\"'count'\",NULL,NULL);\n    qfits_header_add(*header,\"BTYPE\",\"' '\",NULL,NULL);\n    qfits_header_add(*header,\"CDELT1\", \"0.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRPIX1\", \"1.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRVAL1\", \"0.0\",NULL,NULL);\n    qfits_header_add(*header,\"CTYPE1\", \"' '\",NULL,NULL);\n    qfits_header_add(*header,\"CUNIT1\", \"' '\",NULL,NULL);\n    qfits_header_add(*header,\"CDELT2\", \"1.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRPIX2\", \"1.0\",NULL,NULL);\n    qfits_header_add(*header,\"CRVAL2\", \"0.0\",NULL,NULL);\n    qfits_header_add(*header,\"CTYPE2\", \"' '\",NULL,NULL);\n    qfits_header_add(*header,\"CUNIT2\", \"'Y'\",NULL,NULL);\n    qfits_header_add(*header, \"TITLE1\", \"' '\", NULL, NULL);\n    qfits_header_add(*header, \"TITLE2\", \"' '\", NULL, NULL);\n    qfits_header_add(*header, \"RADIUS1\", \"0.0\", NULL, NULL);\n    qfits_header_add(*header, \"RADIUS2\", \"0.0\", NULL, NULL);\n    qfits_header_add(*header, \"HISTORY\", \"'generated by ftstab'\", NULL, NULL);\n  }\n  return checkouthistofile;\n"]]}
{"hexsha": "511fa8678134602823885597f2bcfcfc044108a3", "ext": "c", "lang": "C", "content": "int16_t retrieveGpsMsg(uint16_t      numBytes,\n\t\t\t\t\t   GpsData_t *GPSData,\n\t\t\t\t\t   uint8_t       *outBuffer)\n{\n\tBOOL status = 0;\n\tstatus = COM_buf_get(&(gGpsUartPtr->rec_buf),\n                         outBuffer,\n                         numBytes);\n\tif (status == 0)\n\t\treturn 0; // bad [0]\n\telse // return number of bytes left\n\t\treturn gGpsUartPtr->rec_buf.bytes_in_buffer;\n}", "item_id": 7, "repo": "Erensu/openimu-core", "file": "GPS/src/driverGPS.c", "last_update_at": "2018-09-08T12:28:17+00:00", "question_id": "511fa8678134602823885597f2bcfcfc044108a3_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int16_t retrieveGpsMsg(uint16_t      numBytes,\n\t\t\t\t\t   GpsData_t *GPSData,\n\t\t\t\t\t   uint8_t       *outBuffer)\n{\n\tBOOL status = 0;\n\tstatus = COM_buf_get(&(gGpsUartPtr->rec_buf),\n                         outBuffer,\n                         numBytes);\n\tif (status == 0)\n\t\treturn 0; // bad [0]\n\telse // return number of bytes left\n\t\treturn gGpsUartPtr->rec_buf.bytes_in_buffer;\n"]]}
{"hexsha": "683ed81ef02eb19dd9facc2d4a0a203fecfa854a", "ext": "c", "lang": "C", "content": "static int\ntdfx_attach(device_t dev) { \n\t/*\n\t * The attach routine is called after the probe routine successfully says it\n\t * supports a given card. We now proceed to initialize this card for use with\n\t * the system. I want to map the device memory for userland allocation and\n\t * fill an information structure with information on this card. I'd also like\n\t * to set Write Combining with the MTRR code so that we can hopefully speed\n\t * up memory writes. The last thing is to register the character device\n\t * interface to the card, so we can open it from /dev/3dfxN, where N is a\n\t * small, whole number.\n\t */\n\tstruct tdfx_softc *tdfx_info;\n\t/* rid value tells bus_alloc_resource where to find the addresses of ports or\n\t * of memory ranges in the PCI config space*/\n\tint rid = PCIR_BAR(0);\n\n\t/* Increment the card counter (for the ioctl code) */\n\ttdfx_count++;\n\n\t/* Fill the soft config struct with info about this device*/\n\ttdfx_info = device_get_softc(dev);\n\ttdfx_info->dev = dev;\n\ttdfx_info->vendor = pci_get_vendor(dev);\n\ttdfx_info->type = pci_get_devid(dev) >> 16;\n\ttdfx_info->bus = pci_get_bus(dev);\n\ttdfx_info->dv = pci_get_slot(dev);\n\ttdfx_info->curFile = NULL;\n\n\t/* \n\t *\tGet the Memory Location from the PCI Config, mask out lower word, since\n\t * the config space register is only one word long (this is nicer than a\n\t * bitshift).\n\t */\n\ttdfx_info->addr0 = (pci_read_config(dev, 0x10, 4) & 0xffff0000);\n#ifdef DEBUG\n\tdevice_printf(dev, \"Base0 @ 0x%x\\n\", tdfx_info->addr0);\n#endif\n\t/* Notify the VM that we will be mapping some memory later */\n\ttdfx_info->memrange = bus_alloc_resource_any(dev, SYS_RES_MEMORY,\n\t\t&rid, RF_ACTIVE | RF_SHAREABLE);\n\tif(tdfx_info->memrange == NULL) {\n#ifdef DEBUG\n\t\tdevice_printf(dev, \"Error mapping mem, won't be able to use mmap()\\n\");\n#endif\n\t\ttdfx_info->memrid = 0;\n\t}\n\telse {\n\t\ttdfx_info->memrid = rid;\n#ifdef DEBUG\n\t\tdevice_printf(dev, \"Mapped to: 0x%x\\n\", \n\t\t\t\t(unsigned int)rman_get_start(tdfx_info->memrange));\n#endif\n\t}\n\n\t/* Setup for Voodoo3 and Banshee, PIO and an extram Memrange */\n\tif(pci_get_devid(dev) == PCI_DEVICE_3DFX_VOODOO3 ||\n\t\tpci_get_devid(dev) == PCI_DEVICE_3DFX_BANSHEE) {\n\t\trid = 0x14;\t/* 2nd mem map */\n\t\ttdfx_info->addr1 = (pci_read_config(dev, 0x14, 4) & 0xffff0000);\n#ifdef DEBUG\n\t\tdevice_printf(dev, \"Base1 @ 0x%x\\n\", tdfx_info->addr1);\n#endif\n\t\ttdfx_info->memrange2 = bus_alloc_resource_any(dev,\n\t\t\tSYS_RES_MEMORY, &rid, RF_ACTIVE | RF_SHAREABLE);\n\t\tif(tdfx_info->memrange2 == NULL) {\n#ifdef DEBUG\n\t\t\tdevice_printf(dev, \"Mem1 couldn't be allocated, glide may not work.\");\n#endif\n\t\t\ttdfx_info->memrid2 = 0;\n\t\t}\n\t\telse {\n\t\t\ttdfx_info->memrid2 = rid;\n\t\t}\n\t\t/* Now to map the PIO stuff */\n\t\trid = PCIR_IOBASE0_2;\n\t\ttdfx_info->pio0 = pci_read_config(dev, 0x2c, 2);\n\t\ttdfx_info->pio0max = pci_read_config(dev, 0x30, 2) + tdfx_info->pio0;\n\t\ttdfx_info->piorange = bus_alloc_resource_any(dev,\n\t\t\tSYS_RES_IOPORT, &rid, RF_ACTIVE | RF_SHAREABLE);\n\t\tif(tdfx_info->piorange == NULL) {\n#ifdef DEBUG\n\t\t\tdevice_printf(dev, \"Couldn't map PIO range.\");\n#endif\n\t\t\ttdfx_info->piorid = 0;\n\t\t}\n\t\telse {\n\t\t\ttdfx_info->piorid = rid;\n\t\t}\n\t} else {\n\t  tdfx_info->addr1 = 0;\n\t  tdfx_info->memrange2 = NULL;\n\t  tdfx_info->piorange = NULL;\n\t}\n\n\t/* \n\t *\tSet Writecombining, or at least Uncacheable for the memory region, if we\n\t * are able to\n\t */\n\n\tif(tdfx_setmtrr(dev) != 0) {\n#ifdef DEBUG\n\t\tdevice_printf(dev, \"Some weird error setting MTRRs\");\n#endif\n\t\treturn -1;\n\t}\n\n\t/* \n\t * make_dev registers the cdev to access the 3dfx card from /dev\n\t *\tuse hex here for the dev num, simply to provide better support if > 10\n\t * voodoo cards, for the mad. The user must set the link.\n\t * Why would we want that many voodoo cards anyhow? \n\t */\n\ttdfx_info->devt = make_dev(&tdfx_cdev, device_get_unit(dev),\n\t\tUID_ROOT, GID_WHEEL, 0600, \"3dfx%x\", device_get_unit(dev));\n\ttdfx_info->devt->si_drv1 = tdfx_info;\n\t\n\treturn 0;\n}", "item_id": 1, "repo": "dcui/FreeBSD-9.3_kernel", "file": "sys/dev/tdfx/tdfx_pci.c", "last_update_at": "2018-01-11T01:01:38+00:00", "question_id": "683ed81ef02eb19dd9facc2d4a0a203fecfa854a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\ntdfx_attach(device_t dev) { \n\t/*\n\t * The attach routine is called after the probe routine successfully says it\n\t * supports a given card. We now proceed to initialize this card for use with\n\t * the system. I want to map the device memory for userland allocation and\n\t * fill an information structure with information on this card. I'd also like\n\t * to set Write Combining with the MTRR code so that we can hopefully speed\n\t * up memory writes. The last thing is to register the character device\n\t * interface to the card, so we can open it from /dev/3dfxN, where N is a\n\t * small, whole number.\n\t */\n\tstruct tdfx_softc *tdfx_info;\n\t/* rid value tells bus_alloc_resource where to find the addresses of ports or\n\t * of memory ranges in the PCI config space*/\n\tint rid = PCIR_BAR(0);\n\t/* Increment the card counter (for the ioctl code) */\n\ttdfx_count++;\n\t/* Fill the soft config struct with info about this device*/\n\ttdfx_info = device_get_softc(dev);\n\ttdfx_info->dev = dev;\n\ttdfx_info->vendor = pci_get_vendor(dev);\n\ttdfx_info->type = pci_get_devid(dev) >> 16;\n\ttdfx_info->bus = pci_get_bus(dev);\n\ttdfx_info->dv = pci_get_slot(dev);\n\ttdfx_info->curFile = NULL;\n\t/* \n\t *\tGet the Memory Location from the PCI Config, mask out lower word, since\n\t * the config space register is only one word long (this is nicer than a\n\t * bitshift).\n\t */\n\ttdfx_info->addr0 = (pci_read_config(dev, 0x10, 4) & 0xffff0000);\n#ifdef DEBUG\n\tdevice_printf(dev, \"Base0 @ 0x%x\\n\", tdfx_info->addr0);\n#endif\n\t/* Notify the VM that we will be mapping some memory later */\n\ttdfx_info->memrange = bus_alloc_resource_any(dev, SYS_RES_MEMORY,\n\t\t&rid, RF_ACTIVE | RF_SHAREABLE);\n\tif(tdfx_info->memrange == NULL) {\n#ifdef DEBUG\n\t\tdevice_printf(dev, \"Error mapping mem, won't be able to use mmap()\\n\");\n#endif\n\t\ttdfx_info->memrid = 0;\n\t}\n\telse {\n\t\ttdfx_info->memrid = rid;\n#ifdef DEBUG\n\t\tdevice_printf(dev, \"Mapped to: 0x%x\\n\", \n\t\t\t\t(unsigned int)rman_get_start(tdfx_info->memrange));\n#endif\n\t}\n\t/* Setup for Voodoo3 and Banshee, PIO and an extram Memrange */\n\tif(pci_get_devid(dev) == PCI_DEVICE_3DFX_VOODOO3 ||\n\t\tpci_get_devid(dev) == PCI_DEVICE_3DFX_BANSHEE) {\n\t\trid = 0x14;\t/* 2nd mem map */\n\t\ttdfx_info->addr1 = (pci_read_config(dev, 0x14, 4) & 0xffff0000);\n#ifdef DEBUG\n\t\tdevice_printf(dev, \"Base1 @ 0x%x\\n\", tdfx_info->addr1);\n#endif\n\t\ttdfx_info->memrange2 = bus_alloc_resource_any(dev,\n\t\t\tSYS_RES_MEMORY, &rid, RF_ACTIVE | RF_SHAREABLE);\n\t\tif(tdfx_info->memrange2 == NULL) {\n#ifdef DEBUG\n\t\t\tdevice_printf(dev, \"Mem1 couldn't be allocated, glide may not work.\");\n#endif\n\t\t\ttdfx_info->memrid2 = 0;\n\t\t}\n\t\telse {\n\t\t\ttdfx_info->memrid2 = rid;\n\t\t}\n\t\t/* Now to map the PIO stuff */\n\t\trid = PCIR_IOBASE0_2;\n\t\ttdfx_info->pio0 = pci_read_config(dev, 0x2c, 2);\n\t\ttdfx_info->pio0max = pci_read_config(dev, 0x30, 2) + tdfx_info->pio0;\n\t\ttdfx_info->piorange = bus_alloc_resource_any(dev,\n\t\t\tSYS_RES_IOPORT, &rid, RF_ACTIVE | RF_SHAREABLE);\n\t\tif(tdfx_info->piorange == NULL) {\n#ifdef DEBUG\n\t\t\tdevice_printf(dev, \"Couldn't map PIO range.\");\n#endif\n\t\t\ttdfx_info->piorid = 0;\n\t\t}\n\t\telse {\n\t\t\ttdfx_info->piorid = rid;\n\t\t}\n\t} else {\n\t  tdfx_info->addr1 = 0;\n\t  tdfx_info->memrange2 = NULL;\n\t  tdfx_info->piorange = NULL;\n\t}\n\t/* \n\t *\tSet Writecombining, or at least Uncacheable for the memory region, if we\n\t * are able to\n\t */\n\tif(tdfx_setmtrr(dev) != 0) {\n#ifdef DEBUG\n\t\tdevice_printf(dev, \"Some weird error setting MTRRs\");\n#endif\n\t\treturn -1;\n\t}\n\t/* \n\t * make_dev registers the cdev to access the 3dfx card from /dev\n\t *\tuse hex here for the dev num, simply to provide better support if > 10\n\t * voodoo cards, for the mad. The user must set the link.\n\t * Why would we want that many voodoo cards anyhow? \n\t */\n\ttdfx_info->devt = make_dev(&tdfx_cdev, device_get_unit(dev),\n\t\tUID_ROOT, GID_WHEEL, 0600, \"3dfx%x\", device_get_unit(dev));\n\ttdfx_info->devt->si_drv1 = tdfx_info;\n\t\n\treturn 0;\n"]]}
{"hexsha": "68a020c11880688c831a48272884224ca8c5205e", "ext": "h", "lang": "C", "content": "class Date {\n\tprivate:\n\t\tuint_fast16_t _year;\n\t\tuint_fast16_t _day;\n\t\tuint_fast16_t _month;\n\tpublic:\n\t\tDate() = default;\n\n\t\t/**\n\t\t * create date based on day, month, year\n\t\t * @param year\n\t\t * @param day\n\t\t * @param month\n\t\t */\n\t\tDate(uint_fast16_t year, uint_fast16_t day, uint_fast16_t month) {\n\t\t\tif (isValidDate(year, day, month)) {\n\t\t\t\t_year = year ;\n\t\t\t\t_day = day;\n\t\t\t\t_month = month;\n\t\t\t}", "item_id": 0, "repo": "smartcalapp/SmartCal-CalDav", "file": "src/calender/Date.h", "last_update_at": "2018-09-11T03:41:02+00:00", "question_id": "68a020c11880688c831a48272884224ca8c5205e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Date {\n\tprivate:\n\t\tuint_fast16_t _year;\n\t\tuint_fast16_t _day;\n\t\tuint_fast16_t _month;\n\tpublic:\n\t\tDate() = default;\n\t\t/**\n\t\t * create date based on day, month, year\n\t\t * @param year\n\t\t * @param day\n\t\t * @param month\n\t\t */\n\t\tDate(uint_fast16_t year, uint_fast16_t day, uint_fast16_t month) {\n\t\t\tif (isValidDate(year, day, month)) {\n\t\t\t\t_year = year ;\n\t\t\t\t_day = day;\n\t\t\t\t_month = month;\n"]]}
{"hexsha": "95ec526571ef8fe7db6e3d4a8d5459965cc668eb", "ext": "h", "lang": "C", "content": "static inline void hri_nvmctrl_clear_NONSEC_WRITE_bit(const void *const hw)\n{\n\tNVMCTRL_CRITICAL_SECTION_ENTER();\n\t((Nvmctrl *)hw)->NONSEC.reg &= ~NVMCTRL_NONSEC_WRITE_Msk;\n\tNVMCTRL_CRITICAL_SECTION_LEAVE();\n}", "item_id": 223, "repo": "cazure/rt-thread", "file": "bsp/microchip/saml10/bsp/hri/hri_nvmctrl_l10.h", "last_update_at": "2018-11-27T02:48:44+00:00", "question_id": "95ec526571ef8fe7db6e3d4a8d5459965cc668eb_223", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void hri_nvmctrl_clear_NONSEC_WRITE_bit(const void *const hw)\n{\n\tNVMCTRL_CRITICAL_SECTION_ENTER();\n\t((Nvmctrl *)hw)->NONSEC.reg &= ~NVMCTRL_NONSEC_WRITE_Msk;\n\tNVMCTRL_CRITICAL_SECTION_LEAVE();\n"]]}
{"hexsha": "0f194c9edfcff7cfcda3a35e7c16f20a562fd35a", "ext": "c", "lang": "C", "content": "static void\nlogMaterialf (GLenum  face,\n\t      GLenum  pname,\n\t      GLfloat param)\n{\n    vCnt[materialfIndex].n++;\n    if (logVertexAttribs)\n\tfprintf (logFp, \"glMaterialf (0x%x, 0x%x, %f)\\n\", face, pname, param);\n    (*nativeRenderTable->Materialf) (face, pname, param);\n}", "item_id": 32, "repo": "larsclausen/xglamo", "file": "hw/xgl/glxext/xglglxlog.c", "last_update_at": "2018-11-01T06:58:35+00:00", "question_id": "0f194c9edfcff7cfcda3a35e7c16f20a562fd35a_32", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nlogMaterialf (GLenum  face,\n\t      GLenum  pname,\n\t      GLfloat param)\n{\n    vCnt[materialfIndex].n++;\n    if (logVertexAttribs)\n\tfprintf (logFp, \"glMaterialf (0x%x, 0x%x, %f)\\n\", face, pname, param);\n    (*nativeRenderTable->Materialf) (face, pname, param);\n"]]}
{"hexsha": "5963ac12be07e41ca5ebe0ea8de94b8e2f55f0eb", "ext": "c", "lang": "C", "content": "eye_buf_t *eye_create_buf(eye_pool_t *pool, size_t size)\n{\n\teye_buf_t *b;\n\n\tb = eye_calloc_buf(pool);\n\tif (b == NULL) {\n\t\treturn NULL;\n\t}\n\n\tb->start = eye_palloc(pool, size);\n\tif (b->start == NULL) {\n\t\treturn NULL;\n\t}\n\n\tb->pos = b->start;\n\tb->last = b->start;\n\tb->end = b->last+size;\n\n\treturn b;\n}", "item_id": 0, "repo": "eaglc/eyenet", "file": "src/core/eye_buf.c", "last_update_at": "2018-11-12T07:03:41+00:00", "question_id": "5963ac12be07e41ca5ebe0ea8de94b8e2f55f0eb_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["eye_buf_t *eye_create_buf(eye_pool_t *pool, size_t size)\n{\n\teye_buf_t *b;\n\tb = eye_calloc_buf(pool);\n\tif (b == NULL) {\n\t\treturn NULL;\n\t}\n\tb->start = eye_palloc(pool, size);\n\tif (b->start == NULL) {\n\t\treturn NULL;\n\t}\n\tb->pos = b->start;\n\tb->last = b->start;\n\tb->end = b->last+size;\n\treturn b;\n"]]}
{"hexsha": "9b7d5cea8f348e7e27b709472eae0851e70d7836", "ext": "c", "lang": "C", "content": "__interrupt void USER2_ISR(void)     // User Defined trap 2\n{\r\n  // Insert ISR Code here\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n\r\n}", "item_id": 8, "repo": "equinoxorg/Micro-Hydro-ELC", "file": "Controller_Software/Kingfisher_ELC_Workspace/KP_Controller_1/src/Interrupt_SR.c", "last_update_at": "2018-02-06T22:35:38+00:00", "question_id": "9b7d5cea8f348e7e27b709472eae0851e70d7836_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["__interrupt void USER2_ISR(void)     // User Defined trap 2\n{\r\n  // Insert ISR Code here\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n\r\n"]]}
{"hexsha": "306725ca1144ce776c63feadc8986fa57c557276", "ext": "c", "lang": "C", "content": "void\tq8gr_draw_frame(int x, int y, int sx, int sy, int shadow_type,\n\t\t\tint code, const char *str, void *p)\n{\n    int fg = (p) ? Q8GR_PALETTE_FOREGROUND : Q8GR_PALETTE_WHITE;\n    int bg =       Q8GR_PALETTE_BACKGROUND;\n\n    draw_normal_box(x, y, sx, sy, shadow_type);\n\n    q8gr_puts(x+1, y, fg, bg, code, str);\n}", "item_id": 7, "repo": "yksoft1/QUASI88", "file": "src/q8tk-glib.c", "last_update_at": "2018-09-16T23:47:02+00:00", "question_id": "306725ca1144ce776c63feadc8986fa57c557276_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\tq8gr_draw_frame(int x, int y, int sx, int sy, int shadow_type,\n\t\t\tint code, const char *str, void *p)\n{\n    int fg = (p) ? Q8GR_PALETTE_FOREGROUND : Q8GR_PALETTE_WHITE;\n    int bg =       Q8GR_PALETTE_BACKGROUND;\n    draw_normal_box(x, y, sx, sy, shadow_type);\n    q8gr_puts(x+1, y, fg, bg, code, str);\n"]]}
{"hexsha": "9e065a312285ddb6f354910d5188debfec215410", "ext": "c", "lang": "C", "content": "uint64_t\nar5416GetTsf64(struct ath_hal *ah)\n{\n\tuint32_t low1, low2, u32;\n\n\t/* sync multi-word read */\n\tlow1 = OS_REG_READ(ah, AR_TSF_L32);\n\tu32 = OS_REG_READ(ah, AR_TSF_U32);\n\tlow2 = OS_REG_READ(ah, AR_TSF_L32);\n\tif (low2 < low1) {\t/* roll over */\n\t\t/*\n\t\t * If we are not preempted this will work.  If we are\n\t\t * then we re-reading AR_TSF_U32 does no good as the\n\t\t * low bits will be meaningless.  Likewise reading\n\t\t * L32, U32, U32, then comparing the last two reads\n\t\t * to check for rollover doesn't help if preempted--so\n\t\t * we take this approach as it costs one less PCI read\n\t\t * which can be noticeable when doing things like\n\t\t * timestamping packets in monitor mode.\n\t\t */\n\t\tu32++;\n\t}\n\treturn (((uint64_t) u32) << 32) | ((uint64_t) low2);\n}", "item_id": 2, "repo": "dcui/FreeBSD-9.3_kernel", "file": "sys/dev/ath/ath_hal/ar5416/ar5416_misc.c", "last_update_at": "2018-01-11T01:01:38+00:00", "question_id": "9e065a312285ddb6f354910d5188debfec215410_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["uint64_t\nar5416GetTsf64(struct ath_hal *ah)\n{\n\tuint32_t low1, low2, u32;\n\t/* sync multi-word read */\n\tlow1 = OS_REG_READ(ah, AR_TSF_L32);\n\tu32 = OS_REG_READ(ah, AR_TSF_U32);\n\tlow2 = OS_REG_READ(ah, AR_TSF_L32);\n\tif (low2 < low1) {\t/* roll over */\n\t\t/*\n\t\t * If we are not preempted this will work.  If we are\n\t\t * then we re-reading AR_TSF_U32 does no good as the\n\t\t * low bits will be meaningless.  Likewise reading\n\t\t * L32, U32, U32, then comparing the last two reads\n\t\t * to check for rollover doesn't help if preempted--so\n\t\t * we take this approach as it costs one less PCI read\n\t\t * which can be noticeable when doing things like\n\t\t * timestamping packets in monitor mode.\n\t\t */\n\t\tu32++;\n\t}\n\treturn (((uint64_t) u32) << 32) | ((uint64_t) low2);\n"]]}
{"hexsha": "509b1de5ef7b6fc73ea40b96701359f0e02f739c", "ext": "c", "lang": "C", "content": "bool uart_hal_is_receiver_enabled(uint32_t uartInstance)\n{\n    assert(uartInstance < UART_INSTANCE_COUNT);\n\n    /* get the receiver config based on the uart instance*/\n#if FSL_FEATURE_UART_HAS_LOW_POWER_UART_SUPPORT\n    if (uartInstance == 0)\n    {\n        return HW_UART0_C2.B.RE;\n    }\n    else\n#endif\n    {\n        return HW_UART_C2(uartInstance).B.RE;\n    }\n}", "item_id": 13, "repo": "mjrgh/mbed", "file": "libraries/mbed/targets/hal/TARGET_Freescale/TARGET_KPSDK_MCUS/TARGET_KPSDK_CODE/hal/uart/fsl_uart_hal_common_configurations.c", "last_update_at": "2018-11-22T02:59:15+00:00", "question_id": "509b1de5ef7b6fc73ea40b96701359f0e02f739c_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool uart_hal_is_receiver_enabled(uint32_t uartInstance)\n{\n    assert(uartInstance < UART_INSTANCE_COUNT);\n    /* get the receiver config based on the uart instance*/\n#if FSL_FEATURE_UART_HAS_LOW_POWER_UART_SUPPORT\n    if (uartInstance == 0)\n    {\n        return HW_UART0_C2.B.RE;\n    }\n    else\n#endif\n    {\n        return HW_UART_C2(uartInstance).B.RE;\n    }\n"]]}
{"hexsha": "2d26a2ba67bffbc0a509d7c2b62c5bf14fbc2606", "ext": "c", "lang": "C", "content": "static void cb_server_recv_after(void *handle_, int sid_, char* in_, size_t ilen_)\r\n{\r\n\t// sis_out_binary(\"recv\", in_, ilen_);\r\n\r\n\ts_sis_net_class *cls = (s_sis_net_class *)handle_;\r\n\ts_sis_net_context *cxt = sis_map_kint_get(cls->cxts, sid_);\r\n\tif (!cxt || cxt->status == SIS_NET_DISCONNECT)\r\n\t{\r\n\t\treturn ;\r\n\t}\r\n\tif (cxt->status == SIS_NET_WORKING)\r\n\t{\r\n\t\t//QQQ \u5982\u4f55\u5904\u7406\u5206\u5305\u7684\u95ee\u9898\uff1f\r\n\t\tsis_net_mems_push(cxt->recv_nodes, in_, ilen_);\r\n\t\t// \u53d1\u9001\u901a\u77e5\r\n\t\t// sis_wait_thread_notice(cls->read_thread);\r\n\t}\r\n\telse if (cxt->status == SIS_NET_HANDING)\r\n\t{\r\n\t\tsis_memory_cat(cxt->recv_memory, in_, ilen_);\r\n\t\tint o = sis_ws_recv_hand_ask(cls, cxt);\r\n\t\tif (o == 1) // \u6536\u5230\u6b63\u786e\u7684\u63e1\u624b\u4fe1\u606f\r\n\t\t{\r\n\t\t\tLOG(8)(\"server hand ok. [%d]\\n\", sid_);\r\n\t\t\t// \u8fd9\u91cc\u53d1\u9001\u767b\u5f55\u4fe1\u606f \r\n\t\t\tif (cls->cb_connected)\r\n\t\t\t{\r\n\t\t\t\tcls->cb_connected(cls->cb_source, sid_);\r\n\t\t\t}\t\r\n\t\t\t// \u8bbe\u7f6e\u5de5\u4f5c\u72b6\u6001\t\t\r\n\t\t\tcxt->status = SIS_NET_WORKING;\r\n\t\t\t// \u5982\u679c\u63e1\u624b\u5305\u540e\u6709\u6570\u636e\u5c31\u76f4\u63a5\u901a\u77e5\u5904\u7406\r\n\t\t\tif (sis_memory_get_size(cxt->recv_memory) > 0)\r\n\t\t\t{\r\n\t\t\t\tsis_wait_thread_notice(cls->read_thread);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (o != 0) // \u6536\u5230\u9519\u8bef\u7684\u63e1\u624b\u4fe1\u606f\r\n\t\t{\r\n\t\t\t// \u5982\u679c\u8fd4\u56de<\u96f6 \u5c31\u8bf4\u660e\u6570\u636e\u51fa\u9519\r\n\t\t\t// sis_net_class_close_cxt(cls, sid_);\r\n\t\t\tcxt->status = SIS_NET_DISCONNECT;\r\n\t\t} // == 0 \u8fd8\u6ca1\u6709\u6536\u5230\u6570\u636e\t\t\r\n\t}\r\n}", "item_id": 13, "repo": "coco0O0O/sisdb", "file": "src/core/net/sis_net.c", "last_update_at": "2018-05-26T14:51:54+00:00", "question_id": "2d26a2ba67bffbc0a509d7c2b62c5bf14fbc2606_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void cb_server_recv_after(void *handle_, int sid_, char* in_, size_t ilen_)\r\n{\r\n\t// sis_out_binary(\"recv\", in_, ilen_);\r\n\r\n\ts_sis_net_class *cls = (s_sis_net_class *)handle_;\r\n\ts_sis_net_context *cxt = sis_map_kint_get(cls->cxts, sid_);\r\n\tif (!cxt || cxt->status == SIS_NET_DISCONNECT)\r\n\t{\r\n\t\treturn ;\r\n\t}\r\n\tif (cxt->status == SIS_NET_WORKING)\r\n\t{\r\n\t\t//QQQ \u5982\u4f55\u5904\u7406\u5206\u5305\u7684\u95ee\u9898\uff1f\r\n\t\tsis_net_mems_push(cxt->recv_nodes, in_, ilen_);\r\n\t\t// \u53d1\u9001\u901a\u77e5\r\n\t\t// sis_wait_thread_notice(cls->read_thread);\r\n\t}\r\n\telse if (cxt->status == SIS_NET_HANDING)\r\n\t{\r\n\t\tsis_memory_cat(cxt->recv_memory, in_, ilen_);\r\n\t\tint o = sis_ws_recv_hand_ask(cls, cxt);\r\n\t\tif (o == 1) // \u6536\u5230\u6b63\u786e\u7684\u63e1\u624b\u4fe1\u606f\r\n\t\t{\r\n\t\t\tLOG(8)(\"server hand ok. [%d]\\n\", sid_);\r\n\t\t\t// \u8fd9\u91cc\u53d1\u9001\u767b\u5f55\u4fe1\u606f \r\n\t\t\tif (cls->cb_connected)\r\n\t\t\t{\r\n\t\t\t\tcls->cb_connected(cls->cb_source, sid_);\r\n\t\t\t}\t\r\n\t\t\t// \u8bbe\u7f6e\u5de5\u4f5c\u72b6\u6001\t\t\r\n\t\t\tcxt->status = SIS_NET_WORKING;\r\n\t\t\t// \u5982\u679c\u63e1\u624b\u5305\u540e\u6709\u6570\u636e\u5c31\u76f4\u63a5\u901a\u77e5\u5904\u7406\r\n\t\t\tif (sis_memory_get_size(cxt->recv_memory) > 0)\r\n\t\t\t{\r\n\t\t\t\tsis_wait_thread_notice(cls->read_thread);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (o != 0) // \u6536\u5230\u9519\u8bef\u7684\u63e1\u624b\u4fe1\u606f\r\n\t\t{\r\n\t\t\t// \u5982\u679c\u8fd4\u56de<\u96f6 \u5c31\u8bf4\u660e\u6570\u636e\u51fa\u9519\r\n\t\t\t// sis_net_class_close_cxt(cls, sid_);\r\n\t\t\tcxt->status = SIS_NET_DISCONNECT;\r\n\t\t} // == 0 \u8fd8\u6ca1\u6709\u6536\u5230\u6570\u636e\t\t\r\n\t}\r\n"]]}
{"hexsha": "eceba9c2480355dd23601e4ab5eb4cd4f37a44af", "ext": "c", "lang": "C", "content": "void\ngm_tbl_del(gm_tbl_t *t)\n{\n    int i;\n\n    if (t == NULL) {\n        return;\n    }\n\n    gm_func_del(t->value);\n\n    for (i = 0; i < ALPHABET_LEN; i++) {\n        gm_tbl_del(t->next[i]);\n    }\n\n    ndt_free(t);\n}", "item_id": 2, "repo": "hameerabbasi/gumath", "file": "libgumath/tbl.c", "last_update_at": "2018-12-08T08:37:59+00:00", "question_id": "eceba9c2480355dd23601e4ab5eb4cd4f37a44af_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\ngm_tbl_del(gm_tbl_t *t)\n{\n    int i;\n    if (t == NULL) {\n        return;\n    }\n    gm_func_del(t->value);\n    for (i = 0; i < ALPHABET_LEN; i++) {\n        gm_tbl_del(t->next[i]);\n    }\n    ndt_free(t);\n"]]}
{"hexsha": "02a4eefdf6e7c43b8e8acd9a87d69f33c2546654", "ext": "c", "lang": "C", "content": "void PI_calcMachin3(PBF calcPI, int arctan_mode){\n    PBF operand1 = BF_create(calcPI->size);\n    PBF operand2 = BF_create(calcPI->size);\n    PBF operand3 = BF_create(calcPI->size);\n    PBF operand4 = BF_create(calcPI->size);\n    PBF operand5 = BF_create(calcPI->size);\n    PBF operand6 = BF_create(calcPI->size);\n    \n    BF_initializeInt(operand1, 239, 0);\n    BF_initializeInt(operand2, 1023, 0);\n    BF_initializeInt(operand3, 5832, 0);\n    BF_initializeInt(operand4, 110443, 0);\n    BF_initializeInt(operand5, 4841182, 0);\n    BF_initializeInt(operand6, 6826318, 0);\n    \n    BF_inv(operand1, operand1);\n    BF_inv(operand2, operand2);\n    BF_inv(operand3, operand3);\n    BF_inv(operand4, operand4);\n    BF_inv(operand5, operand5);\n    BF_inv(operand6, operand6);\n    \n    if(arctan_mode == SERIES){\n        arctan_series(operand1, operand1);\n        arctan_series(operand2, operand2);\n        arctan_series(operand3, operand3);\n        arctan_series(operand4, operand4);\n        arctan_series(operand5, operand5);\n        arctan_series(operand6, operand6);\n    }else if(arctan_mode == EULER){\n        arctan_euler(operand1, operand1);\n        arctan_euler(operand2, operand2);\n        arctan_euler(operand3, operand3);\n        arctan_euler(operand4, operand4);\n        arctan_euler(operand5, operand5);\n        arctan_euler(operand6, operand6);\n    }\n    \n    BF_mulInteger(operand1, operand1, 732);\n    BF_mulInteger(operand2, operand2, 128);\n    BF_mulInteger(operand3, operand3, 272);\n    BF_mulInteger(operand4, operand4, 48);\n    BF_mulInteger(operand5, operand5, 48);\n    BF_mulInteger(operand6, operand6, 400);\n    \n    BF_add(operand1, operand2);\n    BF_sub(operand1, operand3);\n    BF_add(operand1, operand4);\n    BF_sub(operand1, operand5);\n    BF_sub(operand1, operand6);\n    \n    BF_copy(calcPI, operand1);\n    \n    BF_delete(operand1);\n    BF_delete(operand2);\n    BF_delete(operand3);\n    BF_delete(operand4);\n    BF_delete(operand5);\n    BF_delete(operand6);\n}", "item_id": 2, "repo": "ihooni/WHY-PI-", "file": "WHY PI 2.0/project folder/WHY PI 2.0/PI_formula/PI_formula.c", "last_update_at": "2018-07-18T11:47:04+00:00", "question_id": "02a4eefdf6e7c43b8e8acd9a87d69f33c2546654_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void PI_calcMachin3(PBF calcPI, int arctan_mode){\n    PBF operand1 = BF_create(calcPI->size);\n    PBF operand2 = BF_create(calcPI->size);\n    PBF operand3 = BF_create(calcPI->size);\n    PBF operand4 = BF_create(calcPI->size);\n    PBF operand5 = BF_create(calcPI->size);\n    PBF operand6 = BF_create(calcPI->size);\n    BF_initializeInt(operand1, 239, 0);\n    BF_initializeInt(operand2, 1023, 0);\n    BF_initializeInt(operand3, 5832, 0);\n    BF_initializeInt(operand4, 110443, 0);\n    BF_initializeInt(operand5, 4841182, 0);\n    BF_initializeInt(operand6, 6826318, 0);\n    BF_inv(operand1, operand1);\n    BF_inv(operand2, operand2);\n    BF_inv(operand3, operand3);\n    BF_inv(operand4, operand4);\n    BF_inv(operand5, operand5);\n    BF_inv(operand6, operand6);\n    if(arctan_mode == SERIES){\n        arctan_series(operand1, operand1);\n        arctan_series(operand2, operand2);\n        arctan_series(operand3, operand3);\n        arctan_series(operand4, operand4);\n        arctan_series(operand5, operand5);\n        arctan_series(operand6, operand6);\n    }else if(arctan_mode == EULER){\n        arctan_euler(operand1, operand1);\n        arctan_euler(operand2, operand2);\n        arctan_euler(operand3, operand3);\n        arctan_euler(operand4, operand4);\n        arctan_euler(operand5, operand5);\n        arctan_euler(operand6, operand6);\n    }\n    BF_mulInteger(operand1, operand1, 732);\n    BF_mulInteger(operand2, operand2, 128);\n    BF_mulInteger(operand3, operand3, 272);\n    BF_mulInteger(operand4, operand4, 48);\n    BF_mulInteger(operand5, operand5, 48);\n    BF_mulInteger(operand6, operand6, 400);\n    BF_add(operand1, operand2);\n    BF_sub(operand1, operand3);\n    BF_add(operand1, operand4);\n    BF_sub(operand1, operand5);\n    BF_sub(operand1, operand6);\n    BF_copy(calcPI, operand1);\n    BF_delete(operand1);\n    BF_delete(operand2);\n    BF_delete(operand3);\n    BF_delete(operand4);\n    BF_delete(operand5);\n    BF_delete(operand6);\n"]]}
{"hexsha": "ca469d18395872ad767d38c867a958a18386a443", "ext": "c", "lang": "C", "content": "void radeon_vm_init(struct radeon_device *rdev, struct radeon_vm *vm)\n{\n\tvm->id = 0;\n\tvm->fence = NULL;\n\tsx_init(&vm->mutex, \"drm__radeon_vm__mutex\");\n\tINIT_LIST_HEAD(&vm->list);\n\tINIT_LIST_HEAD(&vm->va);\n}", "item_id": 27, "repo": "dcui/FreeBSD-9.3_kernel", "file": "sys/dev/drm2/radeon/radeon_gart.c", "last_update_at": "2018-01-11T01:01:38+00:00", "question_id": "ca469d18395872ad767d38c867a958a18386a443_27", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void radeon_vm_init(struct radeon_device *rdev, struct radeon_vm *vm)\n{\n\tvm->id = 0;\n\tvm->fence = NULL;\n\tsx_init(&vm->mutex, \"drm__radeon_vm__mutex\");\n\tINIT_LIST_HEAD(&vm->list);\n\tINIT_LIST_HEAD(&vm->va);\n"]]}
{"hexsha": "875e51e2b094d0bfb9e94c43de6f86c080198e93", "ext": "c", "lang": "C", "content": "VOID\nWriteA2NMailbox(\n    IN VOID *pNFCAdapte\n)\n{\n    PNFC_ADAPTER pNFCAdp = (PNFC_ADAPTER) pNFCAdapte;\n    u8 i = 0;\n    u32 RegTemp;\n\n    if (!(pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Response)) {\n        pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Content[0] = \n            (pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Content[0]|(pNFCAdp->A2NSeq << 8));\n        pNFCAdp->A2NSeq++;\n    }    \n    \n    for(i = 0; i < pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Length; i++) {\n        HalDelayUs(30);\n        HAL_WRITE32(NFC_INTERFACE_BASE, 0x10, pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Content[i]);\n    }\n    \n    HalDelayUs(30);\n    RegTemp = HAL_READ32(NFC_INTERFACE_BASE,0x24)|BIT1;\n    HAL_WRITE32(NFC_INTERFACE_BASE, 0x24, RegTemp);\n    \n    RegTemp = (HAL_READ32(NFC_INTERFACE_BASE,0x24)&(~BIT1));\n    HAL_WRITE32(NFC_INTERFACE_BASE, 0x24, RegTemp);\n}", "item_id": 0, "repo": "pvvx/RTL00_HelloWorld", "file": "lib/fwlib/rtl8195a/src/rtl8195a_nfc.c", "last_update_at": "2018-02-16T19:35:22+00:00", "question_id": "875e51e2b094d0bfb9e94c43de6f86c080198e93_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["VOID\nWriteA2NMailbox(\n    IN VOID *pNFCAdapte\n)\n{\n    PNFC_ADAPTER pNFCAdp = (PNFC_ADAPTER) pNFCAdapte;\n    u8 i = 0;\n    u32 RegTemp;\n    if (!(pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Response)) {\n        pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Content[0] = \n            (pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Content[0]|(pNFCAdp->A2NSeq << 8));\n        pNFCAdp->A2NSeq++;\n    }    \n    for(i = 0; i < pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Length; i++) {\n        HalDelayUs(30);\n        HAL_WRITE32(NFC_INTERFACE_BASE, 0x10, pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Content[i]);\n    }\n    HalDelayUs(30);\n    RegTemp = HAL_READ32(NFC_INTERFACE_BASE,0x24)|BIT1;\n    HAL_WRITE32(NFC_INTERFACE_BASE, 0x24, RegTemp);\n    RegTemp = (HAL_READ32(NFC_INTERFACE_BASE,0x24)&(~BIT1));\n    HAL_WRITE32(NFC_INTERFACE_BASE, 0x24, RegTemp);\n"]]}
{"hexsha": "a7e5de57ad5b4c5a5a06f6b07600b247ced65621", "ext": "c", "lang": "C", "content": "ggsea_fill_pair_s ggsea_extend(\n\tstruct ggsea_ctx_s *ctx,\n\tstruct gref_gid_pos_s rpos,\n\tstruct gref_gid_pos_s qpos)\n{\n\t/* forward section */\n\tdebug(\"forward extend\");\n\tstruct gref_section_s const *rfsec = gref_get_section(ctx->r, rpos.gid);\n\tstruct gref_section_s const *qfsec = gref_get_section(ctx->q, qpos.gid);\n\tgaba_fill_t const *fw_max = ggsea_extend_intl(ctx,\n\t\trfsec, rpos.pos,\n\t\tqfsec, qpos.pos);\n\n\t/* reverse section */\n\tdebug(\"reverse extend\");\n\tstruct gref_section_s const *rrsec = gref_get_section(ctx->r, gref_rev_gid(rpos.gid));\n\tstruct gref_section_s const *qrsec = gref_get_section(ctx->q, gref_rev_gid(qpos.gid));\n\tgaba_fill_t const *rv_max = ggsea_extend_intl(ctx,\n\t\trrsec, rrsec->len - rpos.pos,\n\t\tqrsec, qrsec->len - qpos.pos);\n\n\tdebug(\"fw_max(%lld), rv_max(%lld), max(%lld)\",\n\t\tfw_max->max, rv_max->max, fw_max->max + rv_max->max);\n\t/* return max pair */\n\treturn((struct ggsea_fill_pair_s){\n\t\t.fw = fw_max,\n\t\t.rv = rv_max\n\t});\n}", "item_id": 13, "repo": "ocxtal/libggsea", "file": "ggsea.c", "last_update_at": "2018-03-05T01:14:01+00:00", "question_id": "a7e5de57ad5b4c5a5a06f6b07600b247ced65621_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ggsea_fill_pair_s ggsea_extend(\n\tstruct ggsea_ctx_s *ctx,\n\tstruct gref_gid_pos_s rpos,\n\tstruct gref_gid_pos_s qpos)\n{\n\t/* forward section */\n\tdebug(\"forward extend\");\n\tstruct gref_section_s const *rfsec = gref_get_section(ctx->r, rpos.gid);\n\tstruct gref_section_s const *qfsec = gref_get_section(ctx->q, qpos.gid);\n\tgaba_fill_t const *fw_max = ggsea_extend_intl(ctx,\n\t\trfsec, rpos.pos,\n\t\tqfsec, qpos.pos);\n\t/* reverse section */\n\tdebug(\"reverse extend\");\n\tstruct gref_section_s const *rrsec = gref_get_section(ctx->r, gref_rev_gid(rpos.gid));\n\tstruct gref_section_s const *qrsec = gref_get_section(ctx->q, gref_rev_gid(qpos.gid));\n\tgaba_fill_t const *rv_max = ggsea_extend_intl(ctx,\n\t\trrsec, rrsec->len - rpos.pos,\n\t\tqrsec, qrsec->len - qpos.pos);\n\tdebug(\"fw_max(%lld), rv_max(%lld), max(%lld)\",\n\t\tfw_max->max, rv_max->max, fw_max->max + rv_max->max);\n\t/* return max pair */\n\treturn((struct ggsea_fill_pair_s){\n\t\t.fw = fw_max,\n\t\t.rv = rv_max\n\t});\n"]]}
{"hexsha": "3d81c505cc9aaa697cfcc48a9f34b78be8e7c71b", "ext": "c", "lang": "C", "content": "int main(int argc, char* argv[])\n{\n    char cmd;\n    int key1, key2;\n    FILE* input;\n    Position header = NULL;\n    Position tmpPosition = NULL;\n\n    input = fopen(argv[1], \"r\");\n    header = MakeEmpty();\n\n    while(true)\n    {\n        cmd = fgetc(input);\n        if(feof(input)) break;\n        switch(cmd)\n        {\n        case 'i':\n            fscanf(input, \"%d %d\", &key1, &key2);\n            tmpPosition = Find(key1, header);\n            if(tmpPosition != NULL)\n            {\n                printf(\"Insertion failed: there already is an element with key %d.\\n\", key1);\n                break;\n            }\n            if(key2 == -1)\n                tmpPosition = header;\n            else\n                tmpPosition = Find(key2, header);\n            Insert(key1, header, tmpPosition);\n//          PrintList(header);\n            break;\n        case 'd':\n            fscanf(input, \"%d\", &key1);\n            Delete(key1, header);\n//          PrintList(header);\n            break;\n        case 'f':\n            fscanf(input, \"%d\", &key1);\n            tmpPosition = FindPrevious(key1, header);\n            if (tmpPosition == NULL)\n                printf(\"Could not find %d in the list\\n\", key1);\n            else\n            {\n                if(tmpPosition->element>0)\n                    printf(\"Key of the previous node of %d is %d.\\n\", key1, tmpPosition->element);\n                else\n                    printf(\"Key of the previous node of %d is header.\\n\", key1);\n            }\n            break;\n        case 'p':\n            PrintList(header);\n        }\n    }\n    DeleteList(header);\n    fclose(input);\n    return 0;\n}", "item_id": 0, "repo": "FelisCatusKR/DS_Winter", "file": "Lab_03/main.c", "last_update_at": "2018-01-16T01:21:58+00:00", "question_id": "3d81c505cc9aaa697cfcc48a9f34b78be8e7c71b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(int argc, char* argv[])\n{\n    char cmd;\n    int key1, key2;\n    FILE* input;\n    Position header = NULL;\n    Position tmpPosition = NULL;\n    input = fopen(argv[1], \"r\");\n    header = MakeEmpty();\n    while(true)\n    {\n        cmd = fgetc(input);\n        if(feof(input)) break;\n        switch(cmd)\n        {\n        case 'i':\n            fscanf(input, \"%d %d\", &key1, &key2);\n            tmpPosition = Find(key1, header);\n            if(tmpPosition != NULL)\n            {\n                printf(\"Insertion failed: there already is an element with key %d.\\n\", key1);\n                break;\n            }\n            if(key2 == -1)\n                tmpPosition = header;\n            else\n                tmpPosition = Find(key2, header);\n            Insert(key1, header, tmpPosition);\n//          PrintList(header);\n            break;\n        case 'd':\n            fscanf(input, \"%d\", &key1);\n            Delete(key1, header);\n//          PrintList(header);\n            break;\n        case 'f':\n            fscanf(input, \"%d\", &key1);\n            tmpPosition = FindPrevious(key1, header);\n            if (tmpPosition == NULL)\n                printf(\"Could not find %d in the list\\n\", key1);\n            else\n            {\n                if(tmpPosition->element>0)\n                    printf(\"Key of the previous node of %d is %d.\\n\", key1, tmpPosition->element);\n                else\n                    printf(\"Key of the previous node of %d is header.\\n\", key1);\n            }\n            break;\n        case 'p':\n            PrintList(header);\n        }\n    }\n    DeleteList(header);\n    fclose(input);\n    return 0;\n"]]}
{"hexsha": "3a88ea1647446ebfd247ede85d92ac7e9d8f0720", "ext": "h", "lang": "C", "content": "const override\n\t{\n\t\tstd::vector<FactoryBaseClass*> ret;\n\t\tret.reserve(_factoryMap.size());\n\n\t\tfor (const auto& pair : _factoryMap)\n\t\t{\n\t\t\tret.push_back(pair.second);\n\t\t}", "item_id": 0, "repo": "jowie94/EquinoxEngine", "file": "Equinox/FactoryDictionary.h", "last_update_at": "2018-10-16T20:12:59+00:00", "question_id": "3a88ea1647446ebfd247ede85d92ac7e9d8f0720_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["const override\n\t{\n\t\tstd::vector<FactoryBaseClass*> ret;\n\t\tret.reserve(_factoryMap.size());\n\t\tfor (const auto& pair : _factoryMap)\n\t\t{\n\t\t\tret.push_back(pair.second);\n"]]}
{"hexsha": "cb1021965680a8dfb38f2fb7db30e98445ee443c", "ext": "c", "lang": "C", "content": "int main(){\n  char str_a[20]; //A 20-element character array\n  char *pointer; //A pointer meant for character array\n  char *pointer2; //And yet another one\n\n  strcpy(str_a, \"Hello, World!\\n\");\n  pointer = str_a; // Set the first pointer to the start of the array.\n  printf(pointer); //print it\n\n  pointer2 = pointer + 2; //Set teh second one 2 bytes further in.\n  printf(pointer2); //print it\n  strcpy(pointer2, \"y you guys!\\n\"); //Copy into that spot.\n  printf(pointer); //Print again.\n}", "item_id": 0, "repo": "Ethic41/codes", "file": "C/Learning/HTAOE_codes/pointer.c", "last_update_at": "2018-04-28T14:16:39+00:00", "question_id": "cb1021965680a8dfb38f2fb7db30e98445ee443c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(){\n  char str_a[20]; //A 20-element character array\n  char *pointer; //A pointer meant for character array\n  char *pointer2; //And yet another one\n  strcpy(str_a, \"Hello, World!\\n\");\n  pointer = str_a; // Set the first pointer to the start of the array.\n  printf(pointer); //print it\n  pointer2 = pointer + 2; //Set teh second one 2 bytes further in.\n  printf(pointer2); //print it\n  strcpy(pointer2, \"y you guys!\\n\"); //Copy into that spot.\n  printf(pointer); //Print again.\n"]]}
{"hexsha": "28aede9073a119d79e469097384f8e23204ddf12", "ext": "c", "lang": "C", "content": "int main(){\n        char s1[MAXLEN];\n        char s2[MAXLEN];\n        char *res;\n        int pos, status;\n        \n        while (1){\n                printf(\"Please input string to squeeze s1: \");\n                res = fgets(s1, MAXLEN, stdin);\n                if (res == NULL)\n                        return 0;\n                printf(\"Please input the reference string s2: \");\n                res = fgets(s2, MAXLEN, stdin);\n                if (res == NULL)\n                        return 0;\n                eliminate_newline(s1);\n                eliminate_newline(s2);\n                pos = any(s1, s2);\n                if (pos > 0)\n                        printf(\"First position of s2 chars in s1: %d\\n\", pos);\n                else\n                        printf(\"s2 chars not found in s1\\n. \");\n                                \n                status = squeeze(s1, s2);\n                if (status == 0)\n                        printf(\"String after squeezing is: %s\\n\", s1);\n        }\n        \n        return -1;\n}", "item_id": 0, "repo": "chen-chao/coursera", "file": "tcpl/2.types_operators_and_expressions/2-4-5.c", "last_update_at": "2018-07-17T22:18:22+00:00", "question_id": "28aede9073a119d79e469097384f8e23204ddf12_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(){\n        char s1[MAXLEN];\n        char s2[MAXLEN];\n        char *res;\n        int pos, status;\n        while (1){\n                printf(\"Please input string to squeeze s1: \");\n                res = fgets(s1, MAXLEN, stdin);\n                if (res == NULL)\n                        return 0;\n                printf(\"Please input the reference string s2: \");\n                res = fgets(s2, MAXLEN, stdin);\n                if (res == NULL)\n                        return 0;\n                eliminate_newline(s1);\n                eliminate_newline(s2);\n                pos = any(s1, s2);\n                if (pos > 0)\n                        printf(\"First position of s2 chars in s1: %d\\n\", pos);\n                else\n                        printf(\"s2 chars not found in s1\\n. \");\n                status = squeeze(s1, s2);\n                if (status == 0)\n                        printf(\"String after squeezing is: %s\\n\", s1);\n        }\n        return -1;\n"]]}
{"hexsha": "b18178fdf4a5eaa7c8a706b2e32c3770a4db863c", "ext": "h", "lang": "C", "content": "namespace AvalonTools {\nstatic int avalonSSSBits = 0x007FFF;\nstatic int avalonSimilarityBits = 0xF07FFF;\nstd::string getCanonSmiles(RDKit::ROMol &mol, int flags = -1);\nvoid getAvalonCountFP(const RDKit::ROMol &mol,\n                      RDKit::SparseIntVect<boost::uint32_t> &res,\n                      unsigned int nBits = 512, bool isQuery = false,\n                      bool resetVect = true,\n                      unsigned int bitFlags = avalonSSSBits);\nvoid getAvalonFP(const RDKit::ROMol &mol, ExplicitBitVect &res,\n                 unsigned int nBits = 512, bool isQuery = false,\n                 bool resetVect = true, unsigned int bitFlags = avalonSSSBits);\nvoid getAvalonFP(const RDKit::ROMol &mol, std::vector<boost::uint32_t> &res,\n                 unsigned int nBits = 512, bool isQuery = false,\n                 bool resetVect = true, unsigned int bitFlags = avalonSSSBits);\nunsigned int set2DCoords(RDKit::ROMol &mol, bool clearConfs = true);\n\nstd::string getCanonSmiles(const std::string &data, bool isSmiles,\n                           int flags = -1);\nvoid getAvalonCountFP(const std::string &data, bool isSmiles,\n                      RDKit::SparseIntVect<boost::uint32_t> &res,\n                      unsigned int nBits = 512, bool isQuery = false,\n                      unsigned int bitFlags = avalonSSSBits);\nvoid getAvalonFP(const std::string &data, bool isSmiles, ExplicitBitVect &res,\n                 unsigned int nBits = 512, bool isQuery = false,\n                 bool resetVect = true, unsigned int bitFlags = avalonSSSBits);\nvoid getAvalonFP(const std::string &data, bool isSmiles,\n                 std::vector<boost::uint32_t> &res, unsigned int nBits = 512,\n                 bool isQuery = false, bool resetVect = true,\n                 unsigned int bitFlags = avalonSSSBits);\n\nstd::string set2DCoords(const std::string &data, bool isSmiles);\n\nint initCheckMol(const std::string &optString);\nRDKit::ROMOL_SPTR checkMol(int &errors, RDKit::ROMol &inMol);\nRDKit::ROMOL_SPTR checkMol(int &errors, const std::string &data, bool isSmiles);\nstd::pair<std::string, int> checkMolString(const std::string &data,\n                                           bool isSmiles);\nstd::string getCheckMolLog();\n\nvoid closeCheckMolFiles();\n}", "item_id": 0, "repo": "docking-org/rdk", "file": "External/AvalonTools/AvalonTools.h", "last_update_at": "2018-11-29T01:18:46+00:00", "question_id": "b18178fdf4a5eaa7c8a706b2e32c3770a4db863c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace AvalonTools {\nstatic int avalonSSSBits = 0x007FFF;\nstatic int avalonSimilarityBits = 0xF07FFF;\nstd::string getCanonSmiles(RDKit::ROMol &mol, int flags = -1);\nvoid getAvalonCountFP(const RDKit::ROMol &mol,\n                      RDKit::SparseIntVect<boost::uint32_t> &res,\n                      unsigned int nBits = 512, bool isQuery = false,\n                      bool resetVect = true,\n                      unsigned int bitFlags = avalonSSSBits);\nvoid getAvalonFP(const RDKit::ROMol &mol, ExplicitBitVect &res,\n                 unsigned int nBits = 512, bool isQuery = false,\n                 bool resetVect = true, unsigned int bitFlags = avalonSSSBits);\nvoid getAvalonFP(const RDKit::ROMol &mol, std::vector<boost::uint32_t> &res,\n                 unsigned int nBits = 512, bool isQuery = false,\n                 bool resetVect = true, unsigned int bitFlags = avalonSSSBits);\nunsigned int set2DCoords(RDKit::ROMol &mol, bool clearConfs = true);\nstd::string getCanonSmiles(const std::string &data, bool isSmiles,\n                           int flags = -1);\nvoid getAvalonCountFP(const std::string &data, bool isSmiles,\n                      RDKit::SparseIntVect<boost::uint32_t> &res,\n                      unsigned int nBits = 512, bool isQuery = false,\n                      unsigned int bitFlags = avalonSSSBits);\nvoid getAvalonFP(const std::string &data, bool isSmiles, ExplicitBitVect &res,\n                 unsigned int nBits = 512, bool isQuery = false,\n                 bool resetVect = true, unsigned int bitFlags = avalonSSSBits);\nvoid getAvalonFP(const std::string &data, bool isSmiles,\n                 std::vector<boost::uint32_t> &res, unsigned int nBits = 512,\n                 bool isQuery = false, bool resetVect = true,\n                 unsigned int bitFlags = avalonSSSBits);\nstd::string set2DCoords(const std::string &data, bool isSmiles);\nint initCheckMol(const std::string &optString);\nRDKit::ROMOL_SPTR checkMol(int &errors, RDKit::ROMol &inMol);\nRDKit::ROMOL_SPTR checkMol(int &errors, const std::string &data, bool isSmiles);\nstd::pair<std::string, int> checkMolString(const std::string &data,\n                                           bool isSmiles);\nstd::string getCheckMolLog();\nvoid closeCheckMolFiles();\n"]]}
{"hexsha": "264c01590be5a4d3c4b170ff9e5c6a10fde26fe6", "ext": "c", "lang": "C", "content": "static apr_size_t calc_header_size(serf_bucket_t *hdrs)\n{\n    apr_size_t size = 0;\n\n    serf_bucket_headers_do(hdrs, count_size, &size);\n\n    return size;\n}", "item_id": 5, "repo": "PeterDaveHello/incubator-pagespeed-mod", "file": "third_party/serf/instaweb_bwtp_buckets.c", "last_update_at": "2018-01-04T03:19:47+00:00", "question_id": "264c01590be5a4d3c4b170ff9e5c6a10fde26fe6_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static apr_size_t calc_header_size(serf_bucket_t *hdrs)\n{\n    apr_size_t size = 0;\n    serf_bucket_headers_do(hdrs, count_size, &size);\n    return size;\n"]]}
{"hexsha": "9dcf074d205f653f0d2599cbb9c7ba23f2130cdc", "ext": "c", "lang": "C", "content": "int main(int argc, char const *argv[]) {\n\n  if (argv[1] == 0) {\n    printf(\"Insira o nome de um arquivo.\\n\");\n    return -1;\n  }\n\n  FILE * fPointer;\n  FILE * fWrite;\n\n  char *file_name = (char *) malloc(strlen(argv[1]) * sizeof(char));\n\n  int i = 0;\n  for(i = 0; i < strlen(argv[1]); i++) {\n    file_name[i] = argv[1][i];\n  }\n\n  fPointer = fopen(file_name, \"r\");\n\n  int file_size = fsize(file_name);\n  char ch;\n\n  int x = 0,\n      new_file = 0,\n      file_number = 0;\n\n  while(1) {\n    ch = fgetc(fPointer);\n\n    if(ch == '/'){\n      if(fgetc(fPointer) == '*') {\n        file_number++;\n\n        if(file_number < 9) {\n          sprintf(file_name, \"0%d.c\", file_number);\n        } else {\n          sprintf(file_name, \"%d.c\", file_number);\n        }\n\n        while(1) {\n          fWrite = fopen(file_name, \"a\");\n          ch = fgetc(fPointer);\n          fprintf(fWrite, \"%c\", ch);\n          printf(\"%c\\n\", ch);\n          if(ch == '*'){\n            if(fgetc(fPointer) == '/') {\n              break;\n            }\n          }\n\n        }\n      }\n    }\n\n\n    if(feof(fPointer)) {\n      break;\n    }\n    x++;\n  }\n\n  fclose(fPointer);\n\n  return 0;\n}", "item_id": 1, "repo": "hugonasciutti/Exercises", "file": "C/Organizer/main2.c", "last_update_at": "2018-07-12T02:24:49+00:00", "question_id": "9dcf074d205f653f0d2599cbb9c7ba23f2130cdc_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(int argc, char const *argv[]) {\n  if (argv[1] == 0) {\n    printf(\"Insira o nome de um arquivo.\\n\");\n    return -1;\n  }\n  FILE * fPointer;\n  FILE * fWrite;\n  char *file_name = (char *) malloc(strlen(argv[1]) * sizeof(char));\n  int i = 0;\n  for(i = 0; i < strlen(argv[1]); i++) {\n    file_name[i] = argv[1][i];\n  }\n  fPointer = fopen(file_name, \"r\");\n  int file_size = fsize(file_name);\n  char ch;\n  int x = 0,\n      new_file = 0,\n      file_number = 0;\n  while(1) {\n    ch = fgetc(fPointer);\n    if(ch == '/'){\n      if(fgetc(fPointer) == '*') {\n        file_number++;\n        if(file_number < 9) {\n          sprintf(file_name, \"0%d.c\", file_number);\n        } else {\n          sprintf(file_name, \"%d.c\", file_number);\n        }\n        while(1) {\n          fWrite = fopen(file_name, \"a\");\n          ch = fgetc(fPointer);\n          fprintf(fWrite, \"%c\", ch);\n          printf(\"%c\\n\", ch);\n          if(ch == '*'){\n            if(fgetc(fPointer) == '/') {\n              break;\n            }\n          }\n        }\n      }\n    }\n    if(feof(fPointer)) {\n      break;\n    }\n    x++;\n  }\n  fclose(fPointer);\n  return 0;\n"]]}
{"hexsha": "54b53744b84b1c82076a9295782044e0936a95a7", "ext": "c", "lang": "C", "content": "static void\nhandle_rx_char(char ch)\n{\n\tswitch(ch) {\n\t\tcase 0:\n\t\t\treturn;\n\t\tcase 0x07:\t// BEL\n\t\t\treturn;\n\t\tcase 0x0f:\t// LTRS\n\t\t\treturn;\n\t\tcase 0x0e:\t// FIGS\n\t\t\treturn;\n\t}\n\tif (log_file != NULL)\n\t\tfwrite(&ch, 1, 1, log_file);\n\tfldigi_add_rx(ch);\n}", "item_id": 4, "repo": "K6BSD/bsdtty", "file": "bsdtty.c", "last_update_at": "2018-09-05T19:27:39+00:00", "question_id": "54b53744b84b1c82076a9295782044e0936a95a7_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nhandle_rx_char(char ch)\n{\n\tswitch(ch) {\n\t\tcase 0:\n\t\t\treturn;\n\t\tcase 0x07:\t// BEL\n\t\t\treturn;\n\t\tcase 0x0f:\t// LTRS\n\t\t\treturn;\n\t\tcase 0x0e:\t// FIGS\n\t\t\treturn;\n\t}\n\tif (log_file != NULL)\n\t\tfwrite(&ch, 1, 1, log_file);\n\tfldigi_add_rx(ch);\n"]]}
{"hexsha": "bf08d10d8529fbb86a5090068765fc936794e1c3", "ext": "c", "lang": "C", "content": "static void clean_add_ptr_to_seq_set2(ptr_set2_t *set, void *p) {\n  uint32_t i;\n\n  assert(set->ndeleted == 0 && set->nelems < set->size);\n  i = set->nelems;\n  set->data[i] = p;\n  set->nelems = i + 1;\n}", "item_id": 3, "repo": "maelvls/ocamlyices2", "file": "ext/yices/src/utils/ptr_sets2.c", "last_update_at": "2018-11-23T00:16:01+00:00", "question_id": "bf08d10d8529fbb86a5090068765fc936794e1c3_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void clean_add_ptr_to_seq_set2(ptr_set2_t *set, void *p) {\n  uint32_t i;\n  assert(set->ndeleted == 0 && set->nelems < set->size);\n  i = set->nelems;\n  set->data[i] = p;\n  set->nelems = i + 1;\n"]]}
{"hexsha": "f93e4c05d1772227b8a5334da8f209b89ec62807", "ext": "c", "lang": "C", "content": "TT_TEST_ROUTINE_DEFINE(case_ptr_stack)\n{\n    // tt_u32_t param = TT_TEST_ROUTINE_PARAM(tt_u32_t);\n    tt_u32_t v[__q_size] = {0};\n    tt_u32_t i, n;\n    tt_result_t ret;\n    tt_ptrstk_t q;\n\n    TT_TEST_CASE_ENTER()\n    // test start\n\n    for (i = 0; i < __q_size; ++i) {\n        v[i] = i;\n    }\n\n    tt_ptrstk_init(&q, NULL);\n    tt_ptrstk_clear(&q);\n    TT_UT_EQUAL(tt_ptrstk_count(&q), 0, \"\");\n    TT_UT_EQUAL(tt_ptrstk_empty(&q), TT_TRUE, \"\");\n    TT_UT_EQUAL(tt_ptrstk_top(&q), NULL, \"\");\n\n    TT_UT_EQUAL(tt_ptrstk_pop(&q), NULL, \"\");\n\n    {\n        tt_ptrstk_iter_t pos;\n        tt_ptrstk_iter(&q, &pos);\n        i = 0;\n        while (tt_ptrstk_iter_next(&pos) != NULL) {\n            ++i;\n        }\n        TT_UT_EQUAL(i, 0, \"\");\n    }\n\n    for (i = 0; i < __q_size; ++i) {\n        ret = tt_ptrstk_push(&q, &v[i]);\n        TT_UT_SUCCESS(ret, \"\");\n        TT_UT_EQUAL(tt_ptrstk_top(&q), &v[i], \"\");\n    }\n    TT_UT_EQUAL(tt_ptrstk_count(&q), __q_size, \"\");\n\n    {\n        tt_ptrstk_iter_t pos;\n        tt_ptr_t p;\n\n        tt_ptrstk_iter(&q, &pos);\n        i = 0;\n        while ((p = tt_ptrstk_iter_next(&pos)) != NULL) {\n            TT_UT_EQUAL(p, &v[i++], \"\");\n        }\n        TT_UT_EQUAL(i, __q_size, \"\");\n    }\n\n    n = tt_rand_u32() % __q_size;\n    for (i = __q_size - 1; i >= (__q_size - n); --i) {\n        TT_UT_EQUAL(tt_ptrstk_pop(&q), &v[i], \"\");\n        TT_UT_EQUAL(tt_ptrstk_top(&q), &v[i - 1], \"\");\n    }\n    TT_UT_EQUAL(tt_ptrstk_count(&q), __q_size - n, \"\");\n\n    for (i = __q_size - n; i < __q_size; ++i) {\n        ret = tt_ptrstk_push(&q, &v[i]);\n        TT_UT_SUCCESS(ret, \"\");\n    }\n    TT_UT_EQUAL(tt_ptrstk_count(&q), __q_size, \"\");\n\n    for (i = __q_size - 1; i >= (__q_size - q.ptr_per_frame); --i) {\n        TT_UT_EQUAL(tt_ptrstk_pop(&q), &v[i], \"\");\n    }\n    TT_UT_EQUAL(tt_ptrstk_count(&q), (__q_size - q.ptr_per_frame), \"\");\n\n    tt_ptrstk_clear(&q);\n    TT_UT_EQUAL(tt_ptrstk_pop(&q), NULL, \"\");\n    TT_UT_EQUAL(tt_ptrstk_top(&q), NULL, \"\");\n\n    tt_ptrstk_destroy(&q);\n\n    // test end\n    TT_TEST_CASE_LEAVE()\n}", "item_id": 0, "repo": "newser/TitanSDK", "file": "platform/source/algorithm/test_case/tt_ut_stack.c", "last_update_at": "2018-12-07T07:12:06+00:00", "question_id": "f93e4c05d1772227b8a5334da8f209b89ec62807_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["TT_TEST_ROUTINE_DEFINE(case_ptr_stack)\n{\n    // tt_u32_t param = TT_TEST_ROUTINE_PARAM(tt_u32_t);\n    tt_u32_t v[__q_size] = {0};\n    tt_u32_t i, n;\n    tt_result_t ret;\n    tt_ptrstk_t q;\n    TT_TEST_CASE_ENTER()\n    // test start\n    for (i = 0; i < __q_size; ++i) {\n        v[i] = i;\n    }\n    tt_ptrstk_init(&q, NULL);\n    tt_ptrstk_clear(&q);\n    TT_UT_EQUAL(tt_ptrstk_count(&q), 0, \"\");\n    TT_UT_EQUAL(tt_ptrstk_empty(&q), TT_TRUE, \"\");\n    TT_UT_EQUAL(tt_ptrstk_top(&q), NULL, \"\");\n    TT_UT_EQUAL(tt_ptrstk_pop(&q), NULL, \"\");\n    {\n        tt_ptrstk_iter_t pos;\n        tt_ptrstk_iter(&q, &pos);\n        i = 0;\n        while (tt_ptrstk_iter_next(&pos) != NULL) {\n            ++i;\n        }\n        TT_UT_EQUAL(i, 0, \"\");\n    }\n    for (i = 0; i < __q_size; ++i) {\n        ret = tt_ptrstk_push(&q, &v[i]);\n        TT_UT_SUCCESS(ret, \"\");\n        TT_UT_EQUAL(tt_ptrstk_top(&q), &v[i], \"\");\n    }\n    TT_UT_EQUAL(tt_ptrstk_count(&q), __q_size, \"\");\n    {\n        tt_ptrstk_iter_t pos;\n        tt_ptr_t p;\n        tt_ptrstk_iter(&q, &pos);\n        i = 0;\n        while ((p = tt_ptrstk_iter_next(&pos)) != NULL) {\n            TT_UT_EQUAL(p, &v[i++], \"\");\n        }\n        TT_UT_EQUAL(i, __q_size, \"\");\n    }\n    n = tt_rand_u32() % __q_size;\n    for (i = __q_size - 1; i >= (__q_size - n); --i) {\n        TT_UT_EQUAL(tt_ptrstk_pop(&q), &v[i], \"\");\n        TT_UT_EQUAL(tt_ptrstk_top(&q), &v[i - 1], \"\");\n    }\n    TT_UT_EQUAL(tt_ptrstk_count(&q), __q_size - n, \"\");\n    for (i = __q_size - n; i < __q_size; ++i) {\n        ret = tt_ptrstk_push(&q, &v[i]);\n        TT_UT_SUCCESS(ret, \"\");\n    }\n    TT_UT_EQUAL(tt_ptrstk_count(&q), __q_size, \"\");\n    for (i = __q_size - 1; i >= (__q_size - q.ptr_per_frame); --i) {\n        TT_UT_EQUAL(tt_ptrstk_pop(&q), &v[i], \"\");\n    }\n    TT_UT_EQUAL(tt_ptrstk_count(&q), (__q_size - q.ptr_per_frame), \"\");\n    tt_ptrstk_clear(&q);\n    TT_UT_EQUAL(tt_ptrstk_pop(&q), NULL, \"\");\n    TT_UT_EQUAL(tt_ptrstk_top(&q), NULL, \"\");\n    tt_ptrstk_destroy(&q);\n    // test end\n    TT_TEST_CASE_LEAVE()\n"]]}
{"hexsha": "9aaa0eac44e084ee1cb9c31116aa48285ea8377b", "ext": "c", "lang": "C", "content": "int\ntarget_supports_disable_randomization (void)\n{\n  struct target_ops *t;\n\n  for (t = &current_target; t != NULL; t = t->beneath)\n    if (t->to_supports_disable_randomization)\n      return t->to_supports_disable_randomization ();\n\n  return 0;\n}", "item_id": 66, "repo": "cooljeanius/DragonFlyBSD", "file": "contrib/gdb-7/gdb/target.c", "last_update_at": "2018-01-12T03:55:33+00:00", "question_id": "9aaa0eac44e084ee1cb9c31116aa48285ea8377b_66", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\ntarget_supports_disable_randomization (void)\n{\n  struct target_ops *t;\n  for (t = &current_target; t != NULL; t = t->beneath)\n    if (t->to_supports_disable_randomization)\n      return t->to_supports_disable_randomization ();\n  return 0;\n"]]}
{"hexsha": "a95399562d50d74c079bf3135fae936946b14f30", "ext": "c", "lang": "C", "content": "void tracking_image_accessor_destroy(TrackingImageAccessor *accessor)\n{\n\tIMB_moviecache_free(accessor->cache);\n\tlibmv_FrameAccessorDestroy(accessor->libmv_accessor);\n\tMEM_freeN(accessor);\n}", "item_id": 25, "repo": "1-MillionParanoidTterabytes/Blender-2.79b-blackened", "file": "source/blender/blenkernel/intern/tracking_util.c", "last_update_at": "2018-06-18T01:50:32+00:00", "question_id": "a95399562d50d74c079bf3135fae936946b14f30_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void tracking_image_accessor_destroy(TrackingImageAccessor *accessor)\n{\n\tIMB_moviecache_free(accessor->cache);\n\tlibmv_FrameAccessorDestroy(accessor->libmv_accessor);\n\tMEM_freeN(accessor);\n"]]}
{"hexsha": "c570e54f40a3b5fa76324ed92f768954222760fb", "ext": "c", "lang": "C", "content": "static tb_pointer_t tb_single_list_itor_item(tb_iterator_ref_t iterator, tb_size_t itor)\n{\n    // check\n    tb_single_list_t* list = (tb_single_list_t*)iterator;\n    tb_assert(list && itor);\n\n    // data\n    return list->element.data(&list->element, (tb_cpointer_t)(((tb_single_list_entry_t*)itor) + 1));\n}", "item_id": 4, "repo": "gari001/tbox", "file": "src/tbox/container/single_list.c", "last_update_at": "2018-07-07T17:14:09+00:00", "question_id": "c570e54f40a3b5fa76324ed92f768954222760fb_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static tb_pointer_t tb_single_list_itor_item(tb_iterator_ref_t iterator, tb_size_t itor)\n{\n    // check\n    tb_single_list_t* list = (tb_single_list_t*)iterator;\n    tb_assert(list && itor);\n    // data\n    return list->element.data(&list->element, (tb_cpointer_t)(((tb_single_list_entry_t*)itor) + 1));\n"]]}
{"hexsha": "ec9a327c7e46d6d141f24f194b60533824ec5a4f", "ext": "c", "lang": "C", "content": "void\nmono_gc_add_memory_pressure (gint64 value)\n{\n\t/* FIXME: Use interlocked functions */\n\tLOCK_GC;\n\tmemory_pressure += value;\n\tUNLOCK_GC;\n}", "item_id": 70, "repo": "zlxy/Genesis-3D", "file": "Engine/extlibs/IosLibs/mono-2.6.7/mono/metadata/sgen-gc.c", "last_update_at": "2018-09-30T23:46:57+00:00", "question_id": "ec9a327c7e46d6d141f24f194b60533824ec5a4f_70", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nmono_gc_add_memory_pressure (gint64 value)\n{\n\t/* FIXME: Use interlocked functions */\n\tLOCK_GC;\n\tmemory_pressure += value;\n\tUNLOCK_GC;\n"]]}
{"hexsha": "107fe8011a1f935551c4cfef6f93b765921af27b", "ext": "c", "lang": "C", "content": "static int win32_path_to_8(git_buf *dest, const wchar_t *src)\n{\n\tgit_win32_utf8_path utf8_path;\n\n\tif (git_win32_path_to_utf8(utf8_path, src) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to convert path to UTF-8\");\n\t\treturn -1;\n\t}\n\n\t/* Convert backslashes to forward slashes */\n\tgit_path_mkposix(utf8_path);\n\n\treturn git_buf_sets(dest, utf8_path);\n}", "item_id": 1, "repo": "BonexGu/Blik2D", "file": "Blik2D/addon/libgit2-0.22.2_for_blik/src/win32/findfile.c", "last_update_at": "2018-06-06T04:18:03+00:00", "question_id": "107fe8011a1f935551c4cfef6f93b765921af27b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int win32_path_to_8(git_buf *dest, const wchar_t *src)\n{\n\tgit_win32_utf8_path utf8_path;\n\tif (git_win32_path_to_utf8(utf8_path, src) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to convert path to UTF-8\");\n\t\treturn -1;\n\t}\n\t/* Convert backslashes to forward slashes */\n\tgit_path_mkposix(utf8_path);\n\treturn git_buf_sets(dest, utf8_path);\n"]]}
{"hexsha": "870c67cf1c637cfc78715bd3d821a55195db7d24", "ext": "c", "lang": "C", "content": "static int isn_decode_op1(struct sparc_isn *isn)\n{\n\tstruct sparc_ifmt_op1 *i = to_ifmt(op1, isn);\n\n\t/* Only Call instruction is of op1 type */\n\ti->isn.id = SI_CALL;\n\ti->isn.fmt = SIF_OP1;\n\ti->disp30 = ISN_OP1_DISP(isn->op);\n\treturn 0;\n}", "item_id": 0, "repo": "repk/sporc", "file": "src/cpu/sparc/decoder.c", "last_update_at": "2018-11-10T04:17:56+00:00", "question_id": "870c67cf1c637cfc78715bd3d821a55195db7d24_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int isn_decode_op1(struct sparc_isn *isn)\n{\n\tstruct sparc_ifmt_op1 *i = to_ifmt(op1, isn);\n\t/* Only Call instruction is of op1 type */\n\ti->isn.id = SI_CALL;\n\ti->isn.fmt = SIF_OP1;\n\ti->disp30 = ISN_OP1_DISP(isn->op);\n\treturn 0;\n"]]}
{"hexsha": "cfb52f18eb22f22d020e63008c943df637f42ffe", "ext": "c", "lang": "C", "content": "void *\nkalloc(usize size)\n{\n    spin_lock(vm_global_lock);\n\n    void *ret = NULL;\n    int16 sector_id = -1;\n    if (size <= SECTOR0_BOUND)\n    {\n        sector_id = 0;\n    }\n    else if (size <= SECTOR1_BOUND)\n    {\n        sector_id = 1;\n    }\n    else if (size < PAGE_SIZE)\n    {\n        sector_id = 2;\n    }\n\n    if (sector_id >= 0)\n    { ret = vm_alloc(size, sector_id); }\n    else\n    { ret = vm_alloc_multpages(size); }\n    //void *ret = (void *) R_PADDR((paddr) vm_alloc(size, sector_id));\n    kprintf(\"Allocated Virtual: 0x%x Size: %d\\n\", ret, (uint64) size);\n    /* Hack */\n    int32 status = ESUCCESS;\n    if (ret != NULL)\n    {\n        // check if the target page is already mapped\n        // ret val does not cross page boundries\n        if (get_paddr(read_cr3(), (uintptr) ret) == (uintptr) NULL)\n        {\n            uintptr frame = (uintptr) pmalloc(PAGE_SIZE);\n            uint64 map_stat = map_vmem(read_cr3(), (uintptr) ret, frame);\n            status = (frame != (uintptr) NULL) && (map_stat != ESUCCESS);\n        }\n    }\n\n    if (status != ESUCCESS)\n    {\n        ret = NULL;\n    }\n    else\n    {\n        flush_tlb();\n    }\n\n    spin_unlock(vm_global_lock);\n    return ret;\n}", "item_id": 4, "repo": "mohammad-yazdani/curros", "file": "src/vmm.c", "last_update_at": "2018-12-03T13:08:21+00:00", "question_id": "cfb52f18eb22f22d020e63008c943df637f42ffe_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void *\nkalloc(usize size)\n{\n    spin_lock(vm_global_lock);\n    void *ret = NULL;\n    int16 sector_id = -1;\n    if (size <= SECTOR0_BOUND)\n    {\n        sector_id = 0;\n    }\n    else if (size <= SECTOR1_BOUND)\n    {\n        sector_id = 1;\n    }\n    else if (size < PAGE_SIZE)\n    {\n        sector_id = 2;\n    }\n    if (sector_id >= 0)\n    { ret = vm_alloc(size, sector_id); }\n    else\n    { ret = vm_alloc_multpages(size); }\n    //void *ret = (void *) R_PADDR((paddr) vm_alloc(size, sector_id));\n    kprintf(\"Allocated Virtual: 0x%x Size: %d\\n\", ret, (uint64) size);\n    /* Hack */\n    int32 status = ESUCCESS;\n    if (ret != NULL)\n    {\n        // check if the target page is already mapped\n        // ret val does not cross page boundries\n        if (get_paddr(read_cr3(), (uintptr) ret) == (uintptr) NULL)\n        {\n            uintptr frame = (uintptr) pmalloc(PAGE_SIZE);\n            uint64 map_stat = map_vmem(read_cr3(), (uintptr) ret, frame);\n            status = (frame != (uintptr) NULL) && (map_stat != ESUCCESS);\n        }\n    }\n    if (status != ESUCCESS)\n    {\n        ret = NULL;\n    }\n    else\n    {\n        flush_tlb();\n    }\n    spin_unlock(vm_global_lock);\n    return ret;\n"]]}
{"hexsha": "f9ea73c7054e98e3305565e3cd943fb03427030f", "ext": "h", "lang": "C", "content": "static inline hri_oscctrl_intflag_reg_t hri_oscctrl_get_INTFLAG_reg(const void *const         hw,\n                                                                    hri_oscctrl_intflag_reg_t mask)\n{\n\tuint32_t tmp;\n\ttmp = ((Oscctrl *)hw)->INTFLAG.reg;\n\ttmp &= mask;\n\treturn tmp;\n}", "item_id": 0, "repo": "BreederBai/rt-thread", "file": "bsp/microchip/saml10/bsp/hri/hri_oscctrl_l10.h", "last_update_at": "2018-11-27T02:48:44+00:00", "question_id": "f9ea73c7054e98e3305565e3cd943fb03427030f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline hri_oscctrl_intflag_reg_t hri_oscctrl_get_INTFLAG_reg(const void *const         hw,\n                                                                    hri_oscctrl_intflag_reg_t mask)\n{\n\tuint32_t tmp;\n\ttmp = ((Oscctrl *)hw)->INTFLAG.reg;\n\ttmp &= mask;\n\treturn tmp;\n"]]}
{"hexsha": "7985ebbb69cd8587569a95ffc9b524311651bd4c", "ext": "h", "lang": "C", "content": "interface TSKernelClock : TSClock {\n\n\tunsigned _service;\n\tunsigned _connection;\n\tIONotificationPortRef _notificationPort;\n\n}", "item_id": 0, "repo": "lechium/tvOS10Headers", "file": "System/Library/PrivateFrameworks/TimeSync.framework/TSKernelClock.h", "last_update_at": "2018-08-04T20:16:32+00:00", "question_id": "7985ebbb69cd8587569a95ffc9b524311651bd4c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface TSKernelClock : TSClock {\n\tunsigned _service;\n\tunsigned _connection;\n\tIONotificationPortRef _notificationPort;\n"]]}
{"hexsha": "049d707753abcbd3e6e024b1d920784bb56d039e", "ext": "h", "lang": "C", "content": "interface _DKEventIntersection : NSObject {\n\n\tNSDate* _startDate;\n\tNSDate* _endDate;\n\tNSArray* _events;\n\n}", "item_id": 0, "repo": "lechium/tvOS10Headers", "file": "System/Library/PrivateFrameworks/CoreDuet.framework/_DKEventIntersection.h", "last_update_at": "2018-08-04T20:16:32+00:00", "question_id": "049d707753abcbd3e6e024b1d920784bb56d039e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface _DKEventIntersection : NSObject {\n\tNSDate* _startDate;\n\tNSDate* _endDate;\n\tNSArray* _events;\n"]]}
{"hexsha": "bf3a19ae1a02de45b0131a47263a258d24d439de", "ext": "c", "lang": "C", "content": "static int\nScanKey(\n    const char *s1,\n    const char *s2,\n    const char *e1,\n    const char *e2,\n    const char **res1,\n    const char **res2)\n{\n    *res1 = s1;\n    *res2 = s2;\n    /* Scan word chars until : or $ ends the keyword.\n       They must be equal up to that point. */\n    while (s1 < e1 && s2 < e2) {\n\tif ((*s1 == ':' || *s1 == '$') && (*s2 == ':' || *s2 == '$')) {\n\t    /* The keyword part has ended on both sides */\n\n\t    /* To be a bit conservative and not confuse keywords with e.g.\n\t       Tcl namespace variables we only acknowledge these forms:\n\t       keyword$\n\t       keyword:$\n\t       keyword: .*$\n\t       keyword:: .*$\n\t    */\n\t    if (*s1 == ':') {\n\t\ts1++;\n\t\tif (s1 + 1 >= e1) {\n\t\t    return 1;\n\t\t}\n\t\t/* May be a double colon */\n\t\tif (*s1 == ':') {\n\t\t    s1++;\n\t\t}\n\t\t/* Colon must be followed by space or $ */\n\t\tif (*s1 != ' ' && *s1 != '$') {\n\t\t    return 1;\n\t\t}\n\t    }\n\t    if (*s2 == ':') {\n\t\ts2++;\n\t\tif (s2 + 1 >= e2) {\n\t\t    return 1;\n\t\t}\n\t\tif (*s2 == ':') {\n\t\t    s2++;\n\t\t}\n\t\tif (*s2 != ' ' && *s2 != '$') {\n\t\t    return 1;\n\t\t}\n\t    }\n\t    break;\n\t}\n\tif (*s1 != *s2) {\n\t    /* They are not equal keywords */\n\t    return 0;\n\t}\n\t/* Only standard ascii word chars count */\n\tif ((*s1 >= 'a' && *s1 <= 'z') || (*s1 >= 'A' && *s1 <= 'Z')) {\n\t    s1++;\n\t    s2++;\n\t} else {\n\t    /* This did not count as a keyword but is sofar equal. */\n\t    *res1 = s1;\n\t    *res2 = s2;\n\t    return 1;\n\t}\n    }\n    /* Skip all until $ */\n    while (s1 < e1) {\n\tif (*s1 == '$') {\n\t    break;\n\t}\n\ts1++;\n    }\n    while (s2 < e2) {\n\tif (*s2 == '$') {\n\t    break;\n\t}\n\ts2++;\n    }\n    /* At this point s1/2 should point to the dollar ending the keyword. */\n    if (s1 == e1 || s2 == e2) {\n\t/* We reached the end of string without finishing the keyword.\n\t   If a potential keyword is at the end we don't care. */\n\treturn 1;\n    }\n    /* Strings are equal up to this point. Skip the last dollar as well. */\n    *res1 = s1 + 1;\n    *res2 = s2 + 1;\n    return 1;\n}", "item_id": 0, "repo": "pspjuth/DiffUtilTcl", "file": "generic/comparefiles.c", "last_update_at": "2018-01-05T00:23:08+00:00", "question_id": "bf3a19ae1a02de45b0131a47263a258d24d439de_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nScanKey(\n    const char *s1,\n    const char *s2,\n    const char *e1,\n    const char *e2,\n    const char **res1,\n    const char **res2)\n{\n    *res1 = s1;\n    *res2 = s2;\n    /* Scan word chars until : or $ ends the keyword.\n       They must be equal up to that point. */\n    while (s1 < e1 && s2 < e2) {\n\tif ((*s1 == ':' || *s1 == '$') && (*s2 == ':' || *s2 == '$')) {\n\t    /* The keyword part has ended on both sides */\n\t    /* To be a bit conservative and not confuse keywords with e.g.\n\t       Tcl namespace variables we only acknowledge these forms:\n\t       keyword$\n\t       keyword:$\n\t       keyword: .*$\n\t       keyword:: .*$\n\t    */\n\t    if (*s1 == ':') {\n\t\ts1++;\n\t\tif (s1 + 1 >= e1) {\n\t\t    return 1;\n\t\t}\n\t\t/* May be a double colon */\n\t\tif (*s1 == ':') {\n\t\t    s1++;\n\t\t}\n\t\t/* Colon must be followed by space or $ */\n\t\tif (*s1 != ' ' && *s1 != '$') {\n\t\t    return 1;\n\t\t}\n\t    }\n\t    if (*s2 == ':') {\n\t\ts2++;\n\t\tif (s2 + 1 >= e2) {\n\t\t    return 1;\n\t\t}\n\t\tif (*s2 == ':') {\n\t\t    s2++;\n\t\t}\n\t\tif (*s2 != ' ' && *s2 != '$') {\n\t\t    return 1;\n\t\t}\n\t    }\n\t    break;\n\t}\n\tif (*s1 != *s2) {\n\t    /* They are not equal keywords */\n\t    return 0;\n\t}\n\t/* Only standard ascii word chars count */\n\tif ((*s1 >= 'a' && *s1 <= 'z') || (*s1 >= 'A' && *s1 <= 'Z')) {\n\t    s1++;\n\t    s2++;\n\t} else {\n\t    /* This did not count as a keyword but is sofar equal. */\n\t    *res1 = s1;\n\t    *res2 = s2;\n\t    return 1;\n\t}\n    }\n    /* Skip all until $ */\n    while (s1 < e1) {\n\tif (*s1 == '$') {\n\t    break;\n\t}\n\ts1++;\n    }\n    while (s2 < e2) {\n\tif (*s2 == '$') {\n\t    break;\n\t}\n\ts2++;\n    }\n    /* At this point s1/2 should point to the dollar ending the keyword. */\n    if (s1 == e1 || s2 == e2) {\n\t/* We reached the end of string without finishing the keyword.\n\t   If a potential keyword is at the end we don't care. */\n\treturn 1;\n    }\n    /* Strings are equal up to this point. Skip the last dollar as well. */\n    *res1 = s1 + 1;\n    *res2 = s2 + 1;\n    return 1;\n"]]}
{"hexsha": "d01d311d0d5449114c65b2eae1b8d1415421293e", "ext": "c", "lang": "C", "content": "static VALUE keychain_item_port(VALUE self)\n{\n\tVALUE integer_str = keychain_item_get_attribute(self, kSecPortItemAttr);\n\tVALUE integer_obj = rb_funcall(integer_str, rb_intern(\"to_i\"), 0);\n\treturn integer_obj;\n}", "item_id": 13, "repo": "WIZARDISHUNGRY/keychain_services", "file": "ext/keychain/item.c", "last_update_at": "2018-02-13T05:41:57+00:00", "question_id": "d01d311d0d5449114c65b2eae1b8d1415421293e_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static VALUE keychain_item_port(VALUE self)\n{\n\tVALUE integer_str = keychain_item_get_attribute(self, kSecPortItemAttr);\n\tVALUE integer_obj = rb_funcall(integer_str, rb_intern(\"to_i\"), 0);\n\treturn integer_obj;\n"]]}
{"hexsha": "db9152239f9d403fcd42c93ed2f63fc51c367351", "ext": "c", "lang": "C", "content": "ZEPHIR_INIT_CLASS(Phalcon_Db_Adapter_Pdo_Sqlite) {\n\n\tZEPHIR_REGISTER_CLASS_EX(Phalcon\\\\Db\\\\Adapter\\\\Pdo, Sqlite, phalcon, db_adapter_pdo_sqlite, phalcon_db_adapter_pdo_ce, phalcon_db_adapter_pdo_sqlite_method_entry, 0);\n\n\tzend_declare_property_string(phalcon_db_adapter_pdo_sqlite_ce, SL(\"dialectType\"), \"sqlite\", ZEND_ACC_PROTECTED TSRMLS_CC);\n\n\tzend_declare_property_string(phalcon_db_adapter_pdo_sqlite_ce, SL(\"type\"), \"sqlite\", ZEND_ACC_PROTECTED TSRMLS_CC);\n\n\treturn SUCCESS;\n\n}", "item_id": 0, "repo": "davidofferman/cphalcon", "file": "ext/phalcon/db/adapter/pdo/sqlite.zep.c", "last_update_at": "2018-11-12T10:06:15+00:00", "question_id": "db9152239f9d403fcd42c93ed2f63fc51c367351_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ZEPHIR_INIT_CLASS(Phalcon_Db_Adapter_Pdo_Sqlite) {\n\tZEPHIR_REGISTER_CLASS_EX(Phalcon\\\\Db\\\\Adapter\\\\Pdo, Sqlite, phalcon, db_adapter_pdo_sqlite, phalcon_db_adapter_pdo_ce, phalcon_db_adapter_pdo_sqlite_method_entry, 0);\n\tzend_declare_property_string(phalcon_db_adapter_pdo_sqlite_ce, SL(\"dialectType\"), \"sqlite\", ZEND_ACC_PROTECTED TSRMLS_CC);\n\tzend_declare_property_string(phalcon_db_adapter_pdo_sqlite_ce, SL(\"type\"), \"sqlite\", ZEND_ACC_PROTECTED TSRMLS_CC);\n\treturn SUCCESS;\n"]]}
{"hexsha": "04b818f8b85cb8b1fcb38f53c8fec2196238b4e9", "ext": "c", "lang": "C", "content": "static int\nstore_register_using_P (const struct regcache *regcache, \n\t\t\tstruct packet_reg *reg)\n{\n  struct gdbarch *gdbarch = get_regcache_arch (regcache);\n  struct remote_state *rs = get_remote_state ();\n  /* Try storing a single register.  */\n  char *buf = rs->buf;\n  gdb_byte regp[MAX_REGISTER_SIZE];\n  char *p;\n\n  if (remote_protocol_packets[PACKET_P].support == PACKET_DISABLE)\n    return 0;\n\n  if (reg->pnum == -1)\n    return 0;\n\n  xsnprintf (buf, get_remote_packet_size (), \"P%s=\", phex_nz (reg->pnum, 0));\n  p = buf + strlen (buf);\n  regcache_raw_collect (regcache, reg->regnum, regp);\n  bin2hex (regp, p, register_size (gdbarch, reg->regnum));\n  putpkt (rs->buf);\n  getpkt (&rs->buf, &rs->buf_size, 0);\n\n  switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_P]))\n    {\n    case PACKET_OK:\n      return 1;\n    case PACKET_ERROR:\n      error (_(\"Could not write register \\\"%s\\\"; remote failure reply '%s'\"),\n\t     gdbarch_register_name (gdbarch, reg->regnum), rs->buf);\n    case PACKET_UNKNOWN:\n      return 0;\n    default:\n      internal_error (__FILE__, __LINE__, _(\"Bad result from packet_ok\"));\n    }\n}", "item_id": 99, "repo": "cooljeanius/DragonFlyBSD", "file": "contrib/gdb-7/gdb/remote.c", "last_update_at": "2018-01-12T03:55:33+00:00", "question_id": "04b818f8b85cb8b1fcb38f53c8fec2196238b4e9_99", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nstore_register_using_P (const struct regcache *regcache, \n\t\t\tstruct packet_reg *reg)\n{\n  struct gdbarch *gdbarch = get_regcache_arch (regcache);\n  struct remote_state *rs = get_remote_state ();\n  /* Try storing a single register.  */\n  char *buf = rs->buf;\n  gdb_byte regp[MAX_REGISTER_SIZE];\n  char *p;\n  if (remote_protocol_packets[PACKET_P].support == PACKET_DISABLE)\n    return 0;\n  if (reg->pnum == -1)\n    return 0;\n  xsnprintf (buf, get_remote_packet_size (), \"P%s=\", phex_nz (reg->pnum, 0));\n  p = buf + strlen (buf);\n  regcache_raw_collect (regcache, reg->regnum, regp);\n  bin2hex (regp, p, register_size (gdbarch, reg->regnum));\n  putpkt (rs->buf);\n  getpkt (&rs->buf, &rs->buf_size, 0);\n  switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_P]))\n    {\n    case PACKET_OK:\n      return 1;\n    case PACKET_ERROR:\n      error (_(\"Could not write register \\\"%s\\\"; remote failure reply '%s'\"),\n\t     gdbarch_register_name (gdbarch, reg->regnum), rs->buf);\n    case PACKET_UNKNOWN:\n      return 0;\n    default:\n      internal_error (__FILE__, __LINE__, _(\"Bad result from packet_ok\"));\n    }\n"]]}
{"hexsha": "3eeb553552b92b26d98cf3cf78de38d0e9549ab3", "ext": "c", "lang": "C", "content": "static int adb_setup(void)\n{\n\tstruct adb_dev *dev;\n\tint ret;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&dev->lock);\n\n\tspin_lock_init(&open_lock);\n\n\tinit_waitqueue_head(&dev->read_wq);\n\tinit_waitqueue_head(&dev->write_wq);\n\n\tatomic_set(&dev->open_excl, 0);\n\tatomic_set(&dev->read_excl, 0);\n\tatomic_set(&dev->write_excl, 0);\n\n\tINIT_LIST_HEAD(&dev->tx_idle);\n\n\t_adb_dev = dev;\n\n\tret = misc_register(&adb_device);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\n err:\n\tkfree(dev);\n\tprintk(KERN_ERR \"%s %s %d: adb gadget driver failed to initialize\\n\", __FILE__, __func__,\n\t       __LINE__);\n\treturn ret;\n}", "item_id": 15, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/drivers/usb/gadget/f_adb.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "3eeb553552b92b26d98cf3cf78de38d0e9549ab3_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int adb_setup(void)\n{\n\tstruct adb_dev *dev;\n\tint ret;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&dev->lock);\n\tspin_lock_init(&open_lock);\n\tinit_waitqueue_head(&dev->read_wq);\n\tinit_waitqueue_head(&dev->write_wq);\n\tatomic_set(&dev->open_excl, 0);\n\tatomic_set(&dev->read_excl, 0);\n\tatomic_set(&dev->write_excl, 0);\n\tINIT_LIST_HEAD(&dev->tx_idle);\n\t_adb_dev = dev;\n\tret = misc_register(&adb_device);\n\tif (ret)\n\t\tgoto err;\n\treturn 0;\n err:\n\tkfree(dev);\n\tprintk(KERN_ERR \"%s %s %d: adb gadget driver failed to initialize\\n\", __FILE__, __func__,\n\t       __LINE__);\n\treturn ret;\n"]]}
{"hexsha": "9f0b8bfebddea4407f83f39269459204a2fd2dae", "ext": "h", "lang": "C", "content": "interface GEOCompanionRouteStatus : PBCodable <NSCopying> {\n    unsigned int  _distanceRemainingOnRoute;\n    unsigned int  _distanceToManeuver;\n    unsigned int  _distanceToRoute;\n    int  _feedbackType;\n    bool  _guidancePromptsEnabled;\n    struct { \n        unsigned int timestamp : 1; \n        unsigned int distanceRemainingOnRoute : 1; \n        unsigned int distanceToManeuver : 1; \n        unsigned int distanceToRoute : 1; \n        unsigned int feedbackType : 1; \n        unsigned int remainingTime : 1; \n        unsigned int routeLocationIndex : 1; \n        unsigned int routeLocationOffset : 1; \n        unsigned int stepID : 1; \n        unsigned int guidancePromptsEnabled : 1; \n    }  _has;\n    GEOLocation * _location;\n    unsigned int  _remainingTime;\n    NSData * _routeID;\n    unsigned int  _routeLocationIndex;\n    float  _routeLocationOffset;\n    GEOLatLng * _routeMatchCoordinate;\n    struct { \n        unsigned int *list; \n        unsigned long long count; \n        unsigned long long size; \n    }  _selectedRideIndexs;\n    unsigned int  _stepID;\n    double  _timestamp;\n}", "item_id": 0, "repo": "shaojiankui/iOS10-Runtime-Headers", "file": "PrivateFrameworks/GeoServices.framework/GEOCompanionRouteStatus.h", "last_update_at": "2018-10-08T04:12:25+00:00", "question_id": "9f0b8bfebddea4407f83f39269459204a2fd2dae_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface GEOCompanionRouteStatus : PBCodable <NSCopying> {\n    unsigned int  _distanceRemainingOnRoute;\n    unsigned int  _distanceToManeuver;\n    unsigned int  _distanceToRoute;\n    int  _feedbackType;\n    bool  _guidancePromptsEnabled;\n    struct { \n        unsigned int timestamp : 1; \n        unsigned int distanceRemainingOnRoute : 1; \n        unsigned int distanceToManeuver : 1; \n        unsigned int distanceToRoute : 1; \n        unsigned int feedbackType : 1; \n        unsigned int remainingTime : 1; \n        unsigned int routeLocationIndex : 1; \n        unsigned int routeLocationOffset : 1; \n        unsigned int stepID : 1; \n        unsigned int guidancePromptsEnabled : 1; \n    }  _has;\n    GEOLocation * _location;\n    unsigned int  _remainingTime;\n    NSData * _routeID;\n    unsigned int  _routeLocationIndex;\n    float  _routeLocationOffset;\n    GEOLatLng * _routeMatchCoordinate;\n    struct { \n        unsigned int *list; \n        unsigned long long count; \n        unsigned long long size; \n    }  _selectedRideIndexs;\n    unsigned int  _stepID;\n    double  _timestamp;\n"]]}
{"hexsha": "154bafcb85ab6b3c941e07c9978cdd89bbbeef30", "ext": "h", "lang": "C", "content": "interface RUILoader : RUIHTTPRequest {\n\n\tRUIParser* _parser;\n\tNSURL* _url;\n\tBOOL _allowNonSecureHTTP;\n\tid<RUIParserDelegate> _parserDelegate;\n\tRUIStyle* _style;\n\n}", "item_id": 0, "repo": "lechium/tvOS10Headers", "file": "System/Library/PrivateFrameworks/RemoteUI.framework/RUILoader.h", "last_update_at": "2018-08-04T20:16:32+00:00", "question_id": "154bafcb85ab6b3c941e07c9978cdd89bbbeef30_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface RUILoader : RUIHTTPRequest {\n\tRUIParser* _parser;\n\tNSURL* _url;\n\tBOOL _allowNonSecureHTTP;\n\tid<RUIParserDelegate> _parserDelegate;\n\tRUIStyle* _style;\n"]]}
{"hexsha": "c484712e6e0aefb1754328829f5e967684ff8ffc", "ext": "h", "lang": "C", "content": "interface _MFMessageMediaPayload : NSObject <NSSecureCoding> {\n    NSString * _accessibilityLabel;\n    UIImage * _image;\n    bool  _isSticker;\n    NSURL * _mediaURL;\n    NSString * _text;\n}", "item_id": 0, "repo": "shaojiankui/iOS10-Runtime-Headers", "file": "Frameworks/MessageUI.framework/_MFMessageMediaPayload.h", "last_update_at": "2018-10-08T04:12:25+00:00", "question_id": "c484712e6e0aefb1754328829f5e967684ff8ffc_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface _MFMessageMediaPayload : NSObject <NSSecureCoding> {\n    NSString * _accessibilityLabel;\n    UIImage * _image;\n    bool  _isSticker;\n    NSURL * _mediaURL;\n    NSString * _text;\n"]]}
{"hexsha": "0286a95c28925856222151785828fd9ee0b15fbc", "ext": "c", "lang": "C", "content": "JNICALL\nJava_nsk_jvmti_scenarios_hotswap_HS204_hs204t001_hs204t001_popFrame(JNIEnv * env,\n        jclass klass,\n        jthread thread) {\n    jint state;\n    NSK_DISPLAY0(\"Inside pop_Frame method.....\\n\");\n    if (NSK_CPP_STUB3(GetThreadState,jvmti,thread, &state) == JVMTI_ERROR_NONE) {\n        NSK_DISPLAY0(\" Got the state of thread \\n\");\n        if ( state & JVMTI_THREAD_STATE_SUSPENDED) {\n            NSK_DISPLAY0(\" Thread is already in suspended mode..\\n\");\n            if (!NSK_JVMTI_VERIFY(NSK_CPP_STUB2(PopFrame, jvmti, thread))) {\n                NSK_COMPLAIN0(\" TEST FAILED: UNABLE TO POP FRAME \\n\");\n                nsk_jvmti_setFailStatus();\n                return NSK_FALSE;\n            } else {\n                NSK_DISPLAY0(\" Poped frame safely..\");\n            }\n            /* We should resume that thread for next execution.. */\n            if (!NSK_JVMTI_VERIFY(NSK_CPP_STUB2(ResumeThread, jvmti, thread))) {\n                NSK_COMPLAIN0(\" TEST FAILED: UNABLE TO Resume thread \\n\");\n                nsk_jvmti_setFailStatus();\n                return NSK_FALSE;\n            } else {\n                NSK_DISPLAY0(\" Resumed.. thread for next set of executions...\");\n            }\n        } else {\n            NSK_DISPLAY0(\" Thread is not in Suspened State for poping its status..\");\n        }\n    }\n    return NSK_TRUE;\n}", "item_id": 7, "repo": "iootclab/openjdk", "file": "openjdk11/test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/hotswap/HS204/hs204t001/hs204t001.c", "last_update_at": "2018-06-23T10:04:56+00:00", "question_id": "0286a95c28925856222151785828fd9ee0b15fbc_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["JNICALL\nJava_nsk_jvmti_scenarios_hotswap_HS204_hs204t001_hs204t001_popFrame(JNIEnv * env,\n        jclass klass,\n        jthread thread) {\n    jint state;\n    NSK_DISPLAY0(\"Inside pop_Frame method.....\\n\");\n    if (NSK_CPP_STUB3(GetThreadState,jvmti,thread, &state) == JVMTI_ERROR_NONE) {\n        NSK_DISPLAY0(\" Got the state of thread \\n\");\n        if ( state & JVMTI_THREAD_STATE_SUSPENDED) {\n            NSK_DISPLAY0(\" Thread is already in suspended mode..\\n\");\n            if (!NSK_JVMTI_VERIFY(NSK_CPP_STUB2(PopFrame, jvmti, thread))) {\n                NSK_COMPLAIN0(\" TEST FAILED: UNABLE TO POP FRAME \\n\");\n                nsk_jvmti_setFailStatus();\n                return NSK_FALSE;\n            } else {\n                NSK_DISPLAY0(\" Poped frame safely..\");\n            }\n            /* We should resume that thread for next execution.. */\n            if (!NSK_JVMTI_VERIFY(NSK_CPP_STUB2(ResumeThread, jvmti, thread))) {\n                NSK_COMPLAIN0(\" TEST FAILED: UNABLE TO Resume thread \\n\");\n                nsk_jvmti_setFailStatus();\n                return NSK_FALSE;\n            } else {\n                NSK_DISPLAY0(\" Resumed.. thread for next set of executions...\");\n            }\n        } else {\n            NSK_DISPLAY0(\" Thread is not in Suspened State for poping its status..\");\n        }\n    }\n    return NSK_TRUE;\n"]]}
{"hexsha": "8acdcbebba2fface54ed7136d24bf1f38162fb8d", "ext": "c", "lang": "C", "content": "int pcap_thread_set_callback_ipv4(pcap_thread_t* pcap_thread, pcap_thread_layer_callback_t callback_ipv4)\n{\n    if (!pcap_thread) {\n        return PCAP_THREAD_EINVAL;\n    }\n    if (pcap_thread->callback_linux_sll\n        || pcap_thread->callback_ether\n        || pcap_thread->callback_null\n        || pcap_thread->callback_loop\n        || pcap_thread->callback_ieee802\n        || pcap_thread->callback_gre\n        || pcap_thread->callback_ip\n        || pcap_thread->callback_icmp\n        || pcap_thread->callback_icmpv6\n        || pcap_thread->callback_udp\n        || pcap_thread->callback_tcp) {\n        return PCAP_THREAD_ELAYERCB;\n    }\n    if (pcap_thread->running) {\n        return PCAP_THREAD_ERUNNING;\n    }\n\n    pcap_thread->callback_ipv4 = callback_ipv4;\n\n    return PCAP_THREAD_OK;\n}", "item_id": 30, "repo": "jelu/pcap-thread", "file": "pcap_thread.c", "last_update_at": "2018-11-02T04:59:22+00:00", "question_id": "8acdcbebba2fface54ed7136d24bf1f38162fb8d_30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int pcap_thread_set_callback_ipv4(pcap_thread_t* pcap_thread, pcap_thread_layer_callback_t callback_ipv4)\n{\n    if (!pcap_thread) {\n        return PCAP_THREAD_EINVAL;\n    }\n    if (pcap_thread->callback_linux_sll\n        || pcap_thread->callback_ether\n        || pcap_thread->callback_null\n        || pcap_thread->callback_loop\n        || pcap_thread->callback_ieee802\n        || pcap_thread->callback_gre\n        || pcap_thread->callback_ip\n        || pcap_thread->callback_icmp\n        || pcap_thread->callback_icmpv6\n        || pcap_thread->callback_udp\n        || pcap_thread->callback_tcp) {\n        return PCAP_THREAD_ELAYERCB;\n    }\n    if (pcap_thread->running) {\n        return PCAP_THREAD_ERUNNING;\n    }\n    pcap_thread->callback_ipv4 = callback_ipv4;\n    return PCAP_THREAD_OK;\n"]]}
{"hexsha": "e6a1cffdd2d94d9d9b7f9e2dcbde1d53970dc202", "ext": "c", "lang": "C", "content": "void\nsvn_fs_x__serialize_string_table(svn_temp_serializer__context_t *context,\n                                 string_table_t **st)\n{\n  apr_size_t i, k;\n  string_table_t *string_table = *st;\n  if (string_table == NULL)\n    return;\n\n  /* string table struct */\n  svn_temp_serializer__push(context,\n                            (const void * const *)st,\n                            sizeof(*string_table));\n\n  /* sub-table array (all structs in a single memory block) */\n  svn_temp_serializer__push(context,\n                            (const void * const *)&string_table->sub_tables,\n                            sizeof(*string_table->sub_tables) *\n                            string_table->size);\n\n  /* sub-elements of all sub-tables */\n  for (i = 0; i < string_table->size; ++i)\n    {\n      string_sub_table_t *sub_table = &string_table->sub_tables[i];\n      svn_temp_serializer__add_leaf(context,\n                                    (const void * const *)&sub_table->data,\n                                    sub_table->data_size);\n      svn_temp_serializer__add_leaf(context,\n                    (const void * const *)&sub_table->short_strings,\n                    sub_table->short_string_count * sizeof(string_header_t));\n\n      /* all \"long string\" instances form a single memory block */\n      svn_temp_serializer__push(context,\n                    (const void * const *)&sub_table->long_strings,\n                    sub_table->long_string_count * sizeof(svn_string_t));\n\n      /* serialize actual long string contents */\n      for (k = 0; k < sub_table->long_string_count; ++k)\n        {\n          svn_string_t *string = &sub_table->long_strings[k];\n          svn_temp_serializer__add_leaf(context,\n                                        (const void * const *)&string->data,\n                                        string->len + 1);\n        }\n\n      svn_temp_serializer__pop(context);\n    }\n\n  /* back to the caller's nesting level */\n  svn_temp_serializer__pop(context);\n  svn_temp_serializer__pop(context);\n}", "item_id": 11, "repo": "timgates42/subversion", "file": "subversion/libsvn_fs_x/string_table.c", "last_update_at": "2018-12-24T22:05:09+00:00", "question_id": "e6a1cffdd2d94d9d9b7f9e2dcbde1d53970dc202_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nsvn_fs_x__serialize_string_table(svn_temp_serializer__context_t *context,\n                                 string_table_t **st)\n{\n  apr_size_t i, k;\n  string_table_t *string_table = *st;\n  if (string_table == NULL)\n    return;\n  /* string table struct */\n  svn_temp_serializer__push(context,\n                            (const void * const *)st,\n                            sizeof(*string_table));\n  /* sub-table array (all structs in a single memory block) */\n  svn_temp_serializer__push(context,\n                            (const void * const *)&string_table->sub_tables,\n                            sizeof(*string_table->sub_tables) *\n                            string_table->size);\n  /* sub-elements of all sub-tables */\n  for (i = 0; i < string_table->size; ++i)\n    {\n      string_sub_table_t *sub_table = &string_table->sub_tables[i];\n      svn_temp_serializer__add_leaf(context,\n                                    (const void * const *)&sub_table->data,\n                                    sub_table->data_size);\n      svn_temp_serializer__add_leaf(context,\n                    (const void * const *)&sub_table->short_strings,\n                    sub_table->short_string_count * sizeof(string_header_t));\n      /* all \"long string\" instances form a single memory block */\n      svn_temp_serializer__push(context,\n                    (const void * const *)&sub_table->long_strings,\n                    sub_table->long_string_count * sizeof(svn_string_t));\n      /* serialize actual long string contents */\n      for (k = 0; k < sub_table->long_string_count; ++k)\n        {\n          svn_string_t *string = &sub_table->long_strings[k];\n          svn_temp_serializer__add_leaf(context,\n                                        (const void * const *)&string->data,\n                                        string->len + 1);\n        }\n      svn_temp_serializer__pop(context);\n    }\n  /* back to the caller's nesting level */\n  svn_temp_serializer__pop(context);\n  svn_temp_serializer__pop(context);\n"]]}
{"hexsha": "aa3b8f1b34d932a90256b13e99b0a6d53ec5c5cc", "ext": "c", "lang": "C", "content": "static int\nisl1208_i2c_get_dtr(struct i2c_client *client)\n{\n\tint dtr = i2c_smbus_read_byte_data(client, ISL1208_REG_DTR);\n\tif (dtr < 0)\n\t\treturn -EIO;\n\n\t/* dtr encodes adjustments of {-60,-40,-20,0,20,40,60} ppm */\n\tdtr = ((dtr & 0x3) * 20) * (dtr & (1 << 2) ? -1 : 1);\n\n\treturn dtr;\n}", "item_id": 4, "repo": "SIIS-cloud/pileus", "file": "difc-kernel/pileus-kernel/drivers/rtc/rtc-isl1208.c", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "aa3b8f1b34d932a90256b13e99b0a6d53ec5c5cc_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nisl1208_i2c_get_dtr(struct i2c_client *client)\n{\n\tint dtr = i2c_smbus_read_byte_data(client, ISL1208_REG_DTR);\n\tif (dtr < 0)\n\t\treturn -EIO;\n\t/* dtr encodes adjustments of {-60,-40,-20,0,20,40,60} ppm */\n\tdtr = ((dtr & 0x3) * 20) * (dtr & (1 << 2) ? -1 : 1);\n\treturn dtr;\n"]]}
{"hexsha": "bf0a24a55c7cf1e26c035c599374d09437969295", "ext": "c", "lang": "C", "content": "int\nm2_val_print (type, valaddr, address, stream, format, deref_ref, recurse,\n\t      pretty)\n     struct type *type;\n     char *valaddr;\n     CORE_ADDR address;\n     FILE *stream;\n     int format;\n     int deref_ref;\n     int recurse;\n     enum val_prettyprint pretty;\n{\n  extern int\n  c_val_print PARAMS ((struct type *, char *, CORE_ADDR, FILE *, int, int,\n\t\t       int, enum val_prettyprint));\n  return (c_val_print (type, valaddr, address, stream, format, deref_ref,\n\t\t       recurse, pretty));\n}", "item_id": 0, "repo": "aaliomer/exos", "file": "bin/gdb/gdb/m2-valprint.c", "last_update_at": "2018-01-23T23:07:19+00:00", "question_id": "bf0a24a55c7cf1e26c035c599374d09437969295_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nm2_val_print (type, valaddr, address, stream, format, deref_ref, recurse,\n\t      pretty)\n     struct type *type;\n     char *valaddr;\n     CORE_ADDR address;\n     FILE *stream;\n     int format;\n     int deref_ref;\n     int recurse;\n     enum val_prettyprint pretty;\n{\n  extern int\n  c_val_print PARAMS ((struct type *, char *, CORE_ADDR, FILE *, int, int,\n\t\t       int, enum val_prettyprint));\n  return (c_val_print (type, valaddr, address, stream, format, deref_ref,\n\t\t       recurse, pretty));\n"]]}
{"hexsha": "7f58c735d745049025407806e972bb4c7f124888", "ext": "c", "lang": "C", "content": "static int bpf_fill_maxinsns6(struct bpf_test *self)\n{\n\tunsigned int len = BPF_MAXINSNS;\n\tstruct sock_filter *insn;\n\tint i;\n\n\tinsn = kmalloc_array(len, sizeof(*insn), GFP_KERNEL);\n\tif (!insn)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < len - 1; i++)\n\t\tinsn[i] = __BPF_STMT(BPF_LD | BPF_W | BPF_ABS, SKF_AD_OFF +\n\t\t\t\t     SKF_AD_VLAN_TAG_PRESENT);\n\n\tinsn[len - 1] = __BPF_STMT(BPF_RET | BPF_A, 0);\n\n\tself->u.ptr.insns = insn;\n\tself->u.ptr.len = len;\n\n\treturn 0;\n}", "item_id": 5, "repo": "SIIS-cloud/pileus", "file": "difc-kernel/pileus-kernel/lib/test_bpf.c", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "7f58c735d745049025407806e972bb4c7f124888_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int bpf_fill_maxinsns6(struct bpf_test *self)\n{\n\tunsigned int len = BPF_MAXINSNS;\n\tstruct sock_filter *insn;\n\tint i;\n\tinsn = kmalloc_array(len, sizeof(*insn), GFP_KERNEL);\n\tif (!insn)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < len - 1; i++)\n\t\tinsn[i] = __BPF_STMT(BPF_LD | BPF_W | BPF_ABS, SKF_AD_OFF +\n\t\t\t\t     SKF_AD_VLAN_TAG_PRESENT);\n\tinsn[len - 1] = __BPF_STMT(BPF_RET | BPF_A, 0);\n\tself->u.ptr.insns = insn;\n\tself->u.ptr.len = len;\n\treturn 0;\n"]]}
{"hexsha": "adc08a268a5c44d3717836793937f1357b75e06a", "ext": "c", "lang": "C", "content": "int hrstemc_endswith(char *s, char *what) {\n    if (strlen(what) > strlen(s)) {\n        return 0;\n    }\n    if (strcmp(s+strlen(s)-strlen(what), what) == 0) {\n        return 1;\n    }\n    return 0;\n}", "item_id": 2, "repo": "ivoras/hrstemc", "file": "pgdict_hrstemc/hrstemc.c", "last_update_at": "2018-06-06T09:05:14+00:00", "question_id": "adc08a268a5c44d3717836793937f1357b75e06a_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int hrstemc_endswith(char *s, char *what) {\n    if (strlen(what) > strlen(s)) {\n        return 0;\n    }\n    if (strcmp(s+strlen(s)-strlen(what), what) == 0) {\n        return 1;\n    }\n    return 0;\n"]]}
{"hexsha": "12615d6fdd78bd944ebf9b0af1430871738316dd", "ext": "c", "lang": "C", "content": "void\tgame(t_shapes *shapes, t_pars *pars, t_game *game)\n{\n  char\t**board;\n  t_pos\t*pos;\n  int\taction;\n  int\tcount;\n\n  init_board(&board, pars, &pos, &count);\n  while (check_loss(board))\n    {\n      pos = rand_next(pos, shapes, pars);\n      while (pos->index != -1)\n\t{\n\t  if ((action = get_action(pars)))\n\t    {\n\t      if (my_pause(game, action))\n\t\tif (apply_action(action, board, pos, shapes))\n\t\t  return ;\n\t      display(board, pos, game, pars);\n\t    }\n\t  if (count >= 400 && !game->pause.paused)\n\t    count = falling_time(board, pos, game, pars);\n\t  while (check_fulline(board, game))\n\t    display(board, pos, game, pars);\n\t  one_turn(&count, game);\n\t}\n    }\n}", "item_id": 3, "repo": "rectoria/PSU_2016_tetris", "file": "game.c", "last_update_at": "2018-10-02T18:35:01+00:00", "question_id": "12615d6fdd78bd944ebf9b0af1430871738316dd_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\tgame(t_shapes *shapes, t_pars *pars, t_game *game)\n{\n  char\t**board;\n  t_pos\t*pos;\n  int\taction;\n  int\tcount;\n  init_board(&board, pars, &pos, &count);\n  while (check_loss(board))\n    {\n      pos = rand_next(pos, shapes, pars);\n      while (pos->index != -1)\n\t{\n\t  if ((action = get_action(pars)))\n\t    {\n\t      if (my_pause(game, action))\n\t\tif (apply_action(action, board, pos, shapes))\n\t\t  return ;\n\t      display(board, pos, game, pars);\n\t    }\n\t  if (count >= 400 && !game->pause.paused)\n\t    count = falling_time(board, pos, game, pars);\n\t  while (check_fulline(board, game))\n\t    display(board, pos, game, pars);\n\t  one_turn(&count, game);\n\t}\n    }\n"]]}
{"hexsha": "53f763e6a174d8f5a27fa5c3c54624423cdf8917", "ext": "c", "lang": "C", "content": "static boolean __wss_ping()\n{\n\t/* Disable CODEC operations first */\n\t__wss_regbit_reset(WSSR_IFACE_CTRL, WSSM_PLAYBACK_ENABLE);\n\t/* Now put some harmless values in registers and check them */\n\t__wss_outreg(WSSR_COUNT_LOW, 0xaa);\n\t__wss_outreg(WSSR_COUNT_HIGH, 0x55);\n\treturn (__wss_inreg(WSSR_COUNT_LOW) == 0xaa)\n\t  && (__wss_inreg(WSSR_COUNT_HIGH) == 0x55);\n}", "item_id": 2, "repo": "Marisa-Chan/surreal", "file": "Deps/libmikmod/dos/src/doswss.c", "last_update_at": "2018-09-21T22:13:23+00:00", "question_id": "53f763e6a174d8f5a27fa5c3c54624423cdf8917_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static boolean __wss_ping()\n{\n\t/* Disable CODEC operations first */\n\t__wss_regbit_reset(WSSR_IFACE_CTRL, WSSM_PLAYBACK_ENABLE);\n\t/* Now put some harmless values in registers and check them */\n\t__wss_outreg(WSSR_COUNT_LOW, 0xaa);\n\t__wss_outreg(WSSR_COUNT_HIGH, 0x55);\n\treturn (__wss_inreg(WSSR_COUNT_LOW) == 0xaa)\n\t  && (__wss_inreg(WSSR_COUNT_HIGH) == 0x55);\n"]]}
{"hexsha": "04dc117226c117711c4a2e30aa587c772e308908", "ext": "c", "lang": "C", "content": "CFTypeRef\nIORegistryEntryCreateCFProperty(\n\tio_registry_entry_t\tentry,\n\tCFStringRef\t\tkey,\n        CFAllocatorRef\t\tallocator,\n\tIOOptionBits   options __unused )\n{\n    IOReturn\t\tkr;\n    CFTypeRef\t\ttype;\n    uint32_t\t \tsize;\n    char *\t \tpropertiesBuffer;\n    CFStringRef  \terrorString;\n    const char *    \tcStr;\n    char *\t    \tbuffer = NULL;\n\n    cStr = CFStringGetCStringPtr( key, kCFStringEncodingMacRoman);\n    if( !cStr) {\n\tCFIndex bufferSize = CFStringGetMaximumSizeForEncoding( CFStringGetLength(key),\n\t       kCFStringEncodingMacRoman) + sizeof('\\0');\n        buffer = malloc( bufferSize);\n        if( buffer && CFStringGetCString( key, buffer, bufferSize, kCFStringEncodingMacRoman))\n            cStr = buffer;\n    }\n\n    if( cStr)\n        kr = io_registry_entry_get_property(entry, (char *) cStr, &propertiesBuffer, &size);\n    else\n        kr = kIOReturnError;\n\n    if( buffer)\n        free( buffer);\n\n    if( kr != kIOReturnSuccess)\n        return( NULL );\n\n    type = (CFMutableDictionaryRef)\n                        IOCFUnserialize(propertiesBuffer, allocator,\n\t\t\t\t\t0, &errorString);\n    if (!type && errorString) {\n\n        if ((cStr = CFStringGetCStringPtr(errorString,\n\t\t\t\t\tkCFStringEncodingMacRoman)))\n            printf(\"%s\\n\", cStr);\n\tCFRelease(errorString);\n    }\n\n    // free propertiesBuffer !\n    vm_deallocate(mach_task_self(), (vm_address_t)propertiesBuffer, size);\n\n    return( type );\n}", "item_id": 38, "repo": "markieeee/mu1ti_path", "file": "multi_path/jelbrek/include/IOKit/IOKitLib.c", "last_update_at": "2018-07-02T16:15:06+00:00", "question_id": "04dc117226c117711c4a2e30aa587c772e308908_38", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["CFTypeRef\nIORegistryEntryCreateCFProperty(\n\tio_registry_entry_t\tentry,\n\tCFStringRef\t\tkey,\n        CFAllocatorRef\t\tallocator,\n\tIOOptionBits   options __unused )\n{\n    IOReturn\t\tkr;\n    CFTypeRef\t\ttype;\n    uint32_t\t \tsize;\n    char *\t \tpropertiesBuffer;\n    CFStringRef  \terrorString;\n    const char *    \tcStr;\n    char *\t    \tbuffer = NULL;\n    cStr = CFStringGetCStringPtr( key, kCFStringEncodingMacRoman);\n    if( !cStr) {\n\tCFIndex bufferSize = CFStringGetMaximumSizeForEncoding( CFStringGetLength(key),\n\t       kCFStringEncodingMacRoman) + sizeof('\\0');\n        buffer = malloc( bufferSize);\n        if( buffer && CFStringGetCString( key, buffer, bufferSize, kCFStringEncodingMacRoman))\n            cStr = buffer;\n    }\n    if( cStr)\n        kr = io_registry_entry_get_property(entry, (char *) cStr, &propertiesBuffer, &size);\n    else\n        kr = kIOReturnError;\n    if( buffer)\n        free( buffer);\n    if( kr != kIOReturnSuccess)\n        return( NULL );\n    type = (CFMutableDictionaryRef)\n                        IOCFUnserialize(propertiesBuffer, allocator,\n\t\t\t\t\t0, &errorString);\n    if (!type && errorString) {\n        if ((cStr = CFStringGetCStringPtr(errorString,\n\t\t\t\t\tkCFStringEncodingMacRoman)))\n            printf(\"%s\\n\", cStr);\n\tCFRelease(errorString);\n    }\n    // free propertiesBuffer !\n    vm_deallocate(mach_task_self(), (vm_address_t)propertiesBuffer, size);\n    return( type );\n"]]}
{"hexsha": "3c91d3ab18514d926a8787931b798035fe031cb5", "ext": "c", "lang": "C", "content": "void JNICALL testNativeMethodBind(jvmtiEnv* jvmti_env, JNIEnv *jni_env,\n                      jthread thread, jmethodID mid, void* func, void** func_ptr) {\n    jvmtiPhase phase;\n    char *mname;\n    char *signature;\n    jint ret;\n\n    ret = (*jvmti_env)->GetPhase(jvmti_env, &phase);\n    if (ret != JVMTI_ERROR_NONE) {\n      printf(\"Error: GetPhase %d\\n\", ret);\n      iGlobalStatus = 2;\n      return;\n    }\n\n    if (phase != JVMTI_PHASE_START && phase != JVMTI_PHASE_LIVE)\n        return;\n\n    debug_printf(\"bind event: \\n\");\n    print_method_name(mid);\n\n    ret = (*jvmti_env)->GetMethodName(jvmti_env, mid, &mname, &signature, NULL);\n    if (ret == JVMTI_ERROR_NONE) {\n      if (strcmp(mname, \"findLoadedClass\") == 0) {\n        findLoadedClass_func = (findLoadClass_type)func;\n        *func_ptr = (void*)my_findLoadedClass;\n        debug_printf(\"REDIRECTED findLoadedClass\\n\");\n      }\n    }\n}", "item_id": 2, "repo": "iootclab/openjdk", "file": "openjdk11/test/hotspot/jtreg/vmTestbase/nsk/jvmti/unit/MethodBind/JvmtiTest/JvmtiTest.c", "last_update_at": "2018-06-23T10:04:56+00:00", "question_id": "3c91d3ab18514d926a8787931b798035fe031cb5_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void JNICALL testNativeMethodBind(jvmtiEnv* jvmti_env, JNIEnv *jni_env,\n                      jthread thread, jmethodID mid, void* func, void** func_ptr) {\n    jvmtiPhase phase;\n    char *mname;\n    char *signature;\n    jint ret;\n    ret = (*jvmti_env)->GetPhase(jvmti_env, &phase);\n    if (ret != JVMTI_ERROR_NONE) {\n      printf(\"Error: GetPhase %d\\n\", ret);\n      iGlobalStatus = 2;\n      return;\n    }\n    if (phase != JVMTI_PHASE_START && phase != JVMTI_PHASE_LIVE)\n        return;\n    debug_printf(\"bind event: \\n\");\n    print_method_name(mid);\n    ret = (*jvmti_env)->GetMethodName(jvmti_env, mid, &mname, &signature, NULL);\n    if (ret == JVMTI_ERROR_NONE) {\n      if (strcmp(mname, \"findLoadedClass\") == 0) {\n        findLoadedClass_func = (findLoadClass_type)func;\n        *func_ptr = (void*)my_findLoadedClass;\n        debug_printf(\"REDIRECTED findLoadedClass\\n\");\n      }\n    }\n"]]}
{"hexsha": "880dcb4ba0c15f4b798521b6a0cdee4897042fb9", "ext": "c", "lang": "C", "content": "xuintptr *putOrderedObject(Class *class, MethodBlock *mb, xuintptr *ostack) {\n    long long offset = *((long long *)&ostack[2]);\n    volatile xuintptr *addr = (xuintptr*)((char *)ostack[1] + offset);\n    xuintptr value = ostack[4];\n\n    *addr = value;\n    return ostack;\n}", "item_id": 103, "repo": "webos21/xi", "file": "java/jvm/jamvm/natives.c", "last_update_at": "2018-09-25T10:56:25+00:00", "question_id": "880dcb4ba0c15f4b798521b6a0cdee4897042fb9_103", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["xuintptr *putOrderedObject(Class *class, MethodBlock *mb, xuintptr *ostack) {\n    long long offset = *((long long *)&ostack[2]);\n    volatile xuintptr *addr = (xuintptr*)((char *)ostack[1] + offset);\n    xuintptr value = ostack[4];\n    *addr = value;\n    return ostack;\n"]]}
{"hexsha": "d792299f737c1b6f19106a711f2cf3827b4eab3b", "ext": "c", "lang": "C", "content": "char* get_self_executable_directory()\n{\n\tint rval;\n\tchar link_target[1024];\n\tchar* last_slash;\n\tsize_t result_length;\n\tchar* result;\n\t/* get program name */\n\trval = readlink(\"/proc/self/exe\",link_target,sizeof(link_target));\n\tif (rval == -1)\n\t\tabort();\n\telse\n\t\tlink_target[rval] = '\\0';\n\t/* get last '/' */\n\tlast_slash = strrchr(link_target,'/');\n\tif (last_slash == NULL || last_slash == link_target)\n\t\tabort();\n\tresult_length = last_slash - link_target;\n\tresult = (char*)xmalloc(result_length + 1);\n\tstrncpy(result,link_target,result_length);\n\tresult[result_length] = '\\0';\n\treturn result;\n}", "item_id": 1, "repo": "zyfjeff/webserver", "file": "common.c", "last_update_at": "2018-05-07T13:41:36+00:00", "question_id": "d792299f737c1b6f19106a711f2cf3827b4eab3b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["char* get_self_executable_directory()\n{\n\tint rval;\n\tchar link_target[1024];\n\tchar* last_slash;\n\tsize_t result_length;\n\tchar* result;\n\t/* get program name */\n\trval = readlink(\"/proc/self/exe\",link_target,sizeof(link_target));\n\tif (rval == -1)\n\t\tabort();\n\telse\n\t\tlink_target[rval] = '\\0';\n\t/* get last '/' */\n\tlast_slash = strrchr(link_target,'/');\n\tif (last_slash == NULL || last_slash == link_target)\n\t\tabort();\n\tresult_length = last_slash - link_target;\n\tresult = (char*)xmalloc(result_length + 1);\n\tstrncpy(result,link_target,result_length);\n\tresult[result_length] = '\\0';\n\treturn result;\n"]]}
{"hexsha": "018df08a8d269752e6dbbfd82436fd59cb429831", "ext": "c", "lang": "C", "content": "static int yy_init_globals (void)\n{\n        /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from yylex_destroy(), so don't allocate here.\n     */\n\n    (yy_buffer_stack) = 0;\n    (yy_buffer_stack_top) = 0;\n    (yy_buffer_stack_max) = 0;\n    (yy_c_buf_p) = (char *) 0;\n    (yy_init) = 0;\n    (yy_start) = 0;\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    yyin = stdin;\n    yyout = stdout;\n#else\n    yyin = (FILE *) 0;\n    yyout = (FILE *) 0;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * yylex_init()\n     */\n    return 0;\n}", "item_id": 21, "repo": "LTD-Beget/unbound", "file": "util/configlexer.c", "last_update_at": "2018-08-21T03:05:22+00:00", "question_id": "018df08a8d269752e6dbbfd82436fd59cb429831_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int yy_init_globals (void)\n{\n        /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from yylex_destroy(), so don't allocate here.\n     */\n    (yy_buffer_stack) = 0;\n    (yy_buffer_stack_top) = 0;\n    (yy_buffer_stack_max) = 0;\n    (yy_c_buf_p) = (char *) 0;\n    (yy_init) = 0;\n    (yy_start) = 0;\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    yyin = stdin;\n    yyout = stdout;\n#else\n    yyin = (FILE *) 0;\n    yyout = (FILE *) 0;\n#endif\n    /* For future reference: Set errno on error, since we are called by\n     * yylex_init()\n     */\n    return 0;\n"]]}
{"hexsha": "1a6759498398ede8e1fe2e773c0d7c1f0aa3adf4", "ext": "c", "lang": "C", "content": "typedcode_t node_lplusplus_read(node_t*n)\n{\n    READ_HEADER_ONE;\n    t = x.t;\n    if(is_getlocal(x.c) && (TYPE_IS_INT(x.t) || TYPE_IS_NUMBER(x.t))) {\n        int nr = getlocalnr(x.c);\n        code_free(x.c);x.c=0;\n        if(TYPE_IS_INT(x.t)) {\n           c = abc_inclocal_i(c, nr);\n           c = abc_getlocal(c, nr);\n        } else if(TYPE_IS_NUMBER(x.t)) {\n           c = abc_inclocal(c, nr);\n           c = abc_getlocal(c, nr);\n        } else syntaxerror(\"internal error\");\n    } else {\n        if(TYPE_IS_INT(x.t) || TYPE_IS_UINT(x.t)) {\n            c = abc_increment_i(c);\n            t = TYPE_INT;\n        } else {\n            c = abc_increment(c);\n            t = TYPE_NUMBER;\n        }\n        c = converttype(c, t, x.t);\n        c = toreadwrite(x.c, c, 0, 0, 1);\n        t = x.t;\n    }\n    RET\n}", "item_id": 7, "repo": "svenskan/pronunciation", "file": "vendor/swftools/lib/as3/expr.c", "last_update_at": "2018-04-25T22:29:34+00:00", "question_id": "1a6759498398ede8e1fe2e773c0d7c1f0aa3adf4_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["typedcode_t node_lplusplus_read(node_t*n)\n{\n    READ_HEADER_ONE;\n    t = x.t;\n    if(is_getlocal(x.c) && (TYPE_IS_INT(x.t) || TYPE_IS_NUMBER(x.t))) {\n        int nr = getlocalnr(x.c);\n        code_free(x.c);x.c=0;\n        if(TYPE_IS_INT(x.t)) {\n           c = abc_inclocal_i(c, nr);\n           c = abc_getlocal(c, nr);\n        } else if(TYPE_IS_NUMBER(x.t)) {\n           c = abc_inclocal(c, nr);\n           c = abc_getlocal(c, nr);\n        } else syntaxerror(\"internal error\");\n    } else {\n        if(TYPE_IS_INT(x.t) || TYPE_IS_UINT(x.t)) {\n            c = abc_increment_i(c);\n            t = TYPE_INT;\n        } else {\n            c = abc_increment(c);\n            t = TYPE_NUMBER;\n        }\n        c = converttype(c, t, x.t);\n        c = toreadwrite(x.c, c, 0, 0, 1);\n        t = x.t;\n    }\n    RET\n"]]}
{"hexsha": "6c41e5086e257053d65e89262f44869f3893d6e7", "ext": "h", "lang": "C", "content": "void Update_Channel_Value (Channel* channel, int value) {\n  Serial.println (\"Update_Channel_Value\");\n  \n  if (channel != NULL) {\n    \n    // Set the channel mode corresponding to the specified value\n    Update_Channel_Mode (channel, PIN_MODE_OUTPUT);\n    \n    // Set the channel value\n    (*channel).value = value;\n    \n    // Set the actual hardware's pin's value\n    // TODO: Move this to the platform's schema!\n    digitalWrite ((*channel).address, ((*channel).value == PIN_VALUE_HIGH ? HIGH : LOW));\n    \n    (*channel).isUpdated = true; // TODO: Propagate this change to the platform associated with the channel.\n  }\n  // TODO: Return \"none\" if channel not found (if specified channel is NULL)\n}", "item_id": 11, "repo": "mgub/pixel", "file": "Firmware/Primary_Firmware/Platform.h", "last_update_at": "2018-06-27T23:19:03+00:00", "question_id": "6c41e5086e257053d65e89262f44869f3893d6e7_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void Update_Channel_Value (Channel* channel, int value) {\n  Serial.println (\"Update_Channel_Value\");\n  if (channel != NULL) {\n    // Set the channel mode corresponding to the specified value\n    Update_Channel_Mode (channel, PIN_MODE_OUTPUT);\n    // Set the channel value\n    (*channel).value = value;\n    // Set the actual hardware's pin's value\n    // TODO: Move this to the platform's schema!\n    digitalWrite ((*channel).address, ((*channel).value == PIN_VALUE_HIGH ? HIGH : LOW));\n    (*channel).isUpdated = true; // TODO: Propagate this change to the platform associated with the channel.\n  }\n  // TODO: Return \"none\" if channel not found (if specified channel is NULL)\n"]]}
{"hexsha": "55a23909fad29635c3535f2e947608df579e25bf", "ext": "h", "lang": "C", "content": "DataType remove( DataType value )\n  {\n    int n = count + 1;\n    DataType* cur = data - 1;\n    while (--n)\n    {\n      if (*(++cur) == value)\n      {\n        if (--n)\n        {\n          memmove( cur, cur+1, sizeof(DataType) * n );\n        }\n        --count;\n        return value;\n      }\n    }\n    return value;\n  }", "item_id": 1, "repo": "r-lyeh/scriptorium", "file": "java/jog/libraries/array_list.h", "last_update_at": "2018-01-08T03:02:37+00:00", "question_id": "55a23909fad29635c3535f2e947608df579e25bf_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["DataType remove( DataType value )\n  {\n    int n = count + 1;\n    DataType* cur = data - 1;\n    while (--n)\n    {\n      if (*(++cur) == value)\n      {\n        if (--n)\n        {\n          memmove( cur, cur+1, sizeof(DataType) * n );\n        }\n        --count;\n        return value;\n      }\n    }\n    return value;\n"]]}
{"hexsha": "86486e2eb148e3c17909fdf838ee9f9e535353a0", "ext": "c", "lang": "C", "content": "err long_parse_number(char *str, long *number, int min)\n{\n\tchar\t*end;\n\tlong\tnbr;\n\n\tif (*str == '\\0')\n\t\treturn KO;\n\tnbr = (int)strtol(str, &end, 0);\n\tif (*end != '\\0' || nbr < min)\n\t\treturn KO;\n\t*number = nbr;\n\treturn OK;\n}", "item_id": 0, "repo": "VincentGuinaudeau/buddhabrot", "file": "src/parser.c", "last_update_at": "2018-02-18T01:48:01+00:00", "question_id": "86486e2eb148e3c17909fdf838ee9f9e535353a0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["err long_parse_number(char *str, long *number, int min)\n{\n\tchar\t*end;\n\tlong\tnbr;\n\tif (*str == '\\0')\n\t\treturn KO;\n\tnbr = (int)strtol(str, &end, 0);\n\tif (*end != '\\0' || nbr < min)\n\t\treturn KO;\n\t*number = nbr;\n\treturn OK;\n"]]}
{"hexsha": "8d5d24466d16739c61b51b6ca7b560ce09a47251", "ext": "c", "lang": "C", "content": "void args_usage(args_t *args, FILE *out) {\n  fprintf(out, \"Usage: %s\", args->program_name);\n  for (int s = 0; s < args->shortcuts->hsize; s++) {\n    hash_element_t *elem = args->shortcuts->htable[s];\n    while (elem != NULL) {\n      fprintf(out, \" [ -%s ]\", elem->key);\n      elem = elem->p;\n    }\n  }\n  fprintf(out, \"\\n\\n\");\n  fprintf(out, \"Try `%s --help` for more help.\\n\\n\", args->program_name);\n}", "item_id": 2, "repo": "MarioProjects/FelixRobot", "file": "FelixiAtros/iatros-v1.0/prhlt/src/args.c", "last_update_at": "2018-05-14T01:46:10+00:00", "question_id": "8d5d24466d16739c61b51b6ca7b560ce09a47251_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void args_usage(args_t *args, FILE *out) {\n  fprintf(out, \"Usage: %s\", args->program_name);\n  for (int s = 0; s < args->shortcuts->hsize; s++) {\n    hash_element_t *elem = args->shortcuts->htable[s];\n    while (elem != NULL) {\n      fprintf(out, \" [ -%s ]\", elem->key);\n      elem = elem->p;\n    }\n  }\n  fprintf(out, \"\\n\\n\");\n  fprintf(out, \"Try `%s --help` for more help.\\n\\n\", args->program_name);\n"]]}
{"hexsha": "ce9244c6a533db19a5e950b18810a222c17694e7", "ext": "c", "lang": "C", "content": "static void TestButtons( void )\r\n{\r\n  alt_u8 buttons_tested;\r\n  alt_u8 all_tested;\r\n  /* Variable which holds the last value of edge_capture to avoid \r\n   * \"double counting\" button/switch presses\r\n   */\r\n  int last_tested;\r\n  /* Initialize the Buttons/Switches (SW0-SW3) */\r\n  init_button_pio();\r\n  /* Initialize the variables which keep track of which buttons have been tested. */\r\n  buttons_tested = 0x0;\r\n  all_tested = 0xf;\r\n\r\n  /* Initialize edge_capture to avoid any \"false\" triggers from\r\n   * a previous run.\r\n   */\r\n   \r\n  edge_capture = 0;\r\n  \r\n  /* Set last_tested to a value that edge_capture can never equal\r\n   * to avoid accidental equalities in the while() loop below.\r\n   */\r\n    \r\n  last_tested = 0xffff;\r\n\r\n  /* Print a quick message stating what is happening */\r\n  \r\n  printf(\"\\nA loop will be run until all buttons/switches have been pressed.\\n\\n\");\r\n  printf(\"\\n\\tNOTE:  Once a button press has been detected, for a particular button,\\n\\tany further presses will be ignored!\\n\\n\");\r\n  \r\n  /* Loop until all buttons have been pressed.\r\n   * This happens when buttons_tested == all_tested.\r\n   */\r\n  \r\n  while (  buttons_tested != all_tested )\r\n  { \r\n    if (last_tested == edge_capture)\r\n    {\r\n      continue;\r\n    }\r\n    else\r\n    {\r\n      last_tested = edge_capture;\r\n      switch (edge_capture)\r\n      {\r\n        case 0x1:\r\n          if (buttons_tested & 0x1)\r\n          {\r\n            continue;\r\n          }\r\n          else\r\n          {\r\n            printf(\"\\nButton 1 (SW0) Pressed.\\n\");\r\n            buttons_tested = buttons_tested | 0x1;\r\n          } \r\n          break;\r\n        case 0x2:\r\n          if (buttons_tested & 0x2)\r\n          {\r\n            continue;\r\n          } \r\n          else\r\n          {\r\n            printf(\"\\nButton 2 (SW1) Pressed.\\n\");\r\n            buttons_tested = buttons_tested | 0x2;\r\n          }\r\n          break;\r\n        case 0x4:\r\n          if (buttons_tested & 0x4)\r\n          {\r\n            continue;\r\n          }\r\n          else\r\n          {\r\n            printf(\"\\nButton 3 (SW2) Pressed.\\n\");\r\n            buttons_tested = buttons_tested | 0x4;\r\n          }\r\n          break;\r\n        case 0x8:\r\n          if (buttons_tested & 0x8)\r\n          {\r\n            continue;\r\n          }\r\n          else\r\n          {\r\n            printf(\"\\nButton 4 (SW3) Pressed.\\n\");\r\n            buttons_tested = buttons_tested | 0x8;\r\n          }\r\n          break;\r\n      }\r\n    }\r\n  }\r\n  /* Disable the button pio. */\r\n  disable_button_pio();\r\n\r\n  printf (\"\\nAll Buttons (SW0-SW3) were pressed, at least, once.\\n\");\r\n  usleep(2000000);\r\n  return;\r\n}", "item_id": 9, "repo": "wintermao/test", "file": "ddr_layout_V5/software/Boad_Diagnostics/board_diag.c", "last_update_at": "2018-05-21T08:46:51+00:00", "question_id": "ce9244c6a533db19a5e950b18810a222c17694e7_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void TestButtons( void )\r\n{\r\n  alt_u8 buttons_tested;\r\n  alt_u8 all_tested;\r\n  /* Variable which holds the last value of edge_capture to avoid \r\n   * \"double counting\" button/switch presses\r\n   */\r\n  int last_tested;\r\n  /* Initialize the Buttons/Switches (SW0-SW3) */\r\n  init_button_pio();\r\n  /* Initialize the variables which keep track of which buttons have been tested. */\r\n  buttons_tested = 0x0;\r\n  all_tested = 0xf;\r\n\r\n  /* Initialize edge_capture to avoid any \"false\" triggers from\r\n   * a previous run.\r\n   */\r\n   \r\n  edge_capture = 0;\r\n  \r\n  /* Set last_tested to a value that edge_capture can never equal\r\n   * to avoid accidental equalities in the while() loop below.\r\n   */\r\n    \r\n  last_tested = 0xffff;\r\n\r\n  /* Print a quick message stating what is happening */\r\n  \r\n  printf(\"\\nA loop will be run until all buttons/switches have been pressed.\\n\\n\");\r\n  printf(\"\\n\\tNOTE:  Once a button press has been detected, for a particular button,\\n\\tany further presses will be ignored!\\n\\n\");\r\n  \r\n  /* Loop until all buttons have been pressed.\r\n   * This happens when buttons_tested == all_tested.\r\n   */\r\n  \r\n  while (  buttons_tested != all_tested )\r\n  { \r\n    if (last_tested == edge_capture)\r\n    {\r\n      continue;\r\n    }\r\n    else\r\n    {\r\n      last_tested = edge_capture;\r\n      switch (edge_capture)\r\n      {\r\n        case 0x1:\r\n          if (buttons_tested & 0x1)\r\n          {\r\n            continue;\r\n          }\r\n          else\r\n          {\r\n            printf(\"\\nButton 1 (SW0) Pressed.\\n\");\r\n            buttons_tested = buttons_tested | 0x1;\r\n          } \r\n          break;\r\n        case 0x2:\r\n          if (buttons_tested & 0x2)\r\n          {\r\n            continue;\r\n          } \r\n          else\r\n          {\r\n            printf(\"\\nButton 2 (SW1) Pressed.\\n\");\r\n            buttons_tested = buttons_tested | 0x2;\r\n          }\r\n          break;\r\n        case 0x4:\r\n          if (buttons_tested & 0x4)\r\n          {\r\n            continue;\r\n          }\r\n          else\r\n          {\r\n            printf(\"\\nButton 3 (SW2) Pressed.\\n\");\r\n            buttons_tested = buttons_tested | 0x4;\r\n          }\r\n          break;\r\n        case 0x8:\r\n          if (buttons_tested & 0x8)\r\n          {\r\n            continue;\r\n          }\r\n          else\r\n          {\r\n            printf(\"\\nButton 4 (SW3) Pressed.\\n\");\r\n            buttons_tested = buttons_tested | 0x8;\r\n          }\r\n          break;\r\n      }\r\n    }\r\n  }\r\n  /* Disable the button pio. */\r\n  disable_button_pio();\r\n\r\n  printf (\"\\nAll Buttons (SW0-SW3) were pressed, at least, once.\\n\");\r\n  usleep(2000000);\r\n  return;\r\n"]]}
{"hexsha": "6e1db8554c1eb81709bba7f8c8f212d1d50ca0e9", "ext": "c", "lang": "C", "content": "Tex *give_current_object_texture(Object *ob)\n{\n\tMaterial *ma, *node_ma;\n\tTex *tex = NULL;\n\t\n\tif (ob == NULL) return NULL;\n\tif (ob->totcol == 0 && !(ob->type == OB_LAMP)) return NULL;\n\t\n\tif (ob->type == OB_LAMP) {\n\t\ttex = give_current_lamp_texture(ob->data);\n\t}\n\telse {\n\t\tma = give_current_material(ob, ob->actcol);\n\n\t\tif ((node_ma = give_node_material(ma)))\n\t\t\tma = node_ma;\n\n\t\ttex = give_current_material_texture(ma);\n\t}\n\t\n\treturn tex;\n}", "item_id": 21, "repo": "1-MillionParanoidTterabytes/Blender-2.79b-blackened", "file": "source/blender/blenkernel/intern/texture.c", "last_update_at": "2018-06-18T01:50:32+00:00", "question_id": "6e1db8554c1eb81709bba7f8c8f212d1d50ca0e9_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["Tex *give_current_object_texture(Object *ob)\n{\n\tMaterial *ma, *node_ma;\n\tTex *tex = NULL;\n\t\n\tif (ob == NULL) return NULL;\n\tif (ob->totcol == 0 && !(ob->type == OB_LAMP)) return NULL;\n\t\n\tif (ob->type == OB_LAMP) {\n\t\ttex = give_current_lamp_texture(ob->data);\n\t}\n\telse {\n\t\tma = give_current_material(ob, ob->actcol);\n\t\tif ((node_ma = give_node_material(ma)))\n\t\t\tma = node_ma;\n\t\ttex = give_current_material_texture(ma);\n\t}\n\t\n\treturn tex;\n"]]}
{"hexsha": "a939314a1dc3c74c64cebdfb9eb58237bf8ca9dc", "ext": "c", "lang": "C", "content": "static int\npthru_info_pt_list_init(int unit, size_t sid_max_count)\n{\n    unsigned int size;\n\n    SHR_FUNC_ENTER(unit);\n\n    size = sizeof(bcmltm_pt_list_t *) * sid_max_count;\n\n    /* Allocate PT List pointers */\n    SHR_ALLOC(PTHRU_PT_LIST(unit), size,\n              \"LTM PT Pass Thru info pt_list ptrs\");\n    SHR_NULL_CHECK(PTHRU_PT_LIST(unit), SHR_E_MEMORY);\n    sal_memset(PTHRU_PT_LIST(unit), 0, size);\n\n exit:\n    if (SHR_FUNC_ERR()) {\n        pthru_info_pt_list_cleanup(unit);\n    }\n\n    SHR_FUNC_EXIT();\n}", "item_id": 77, "repo": "lguohan/SDKLT", "file": "src/bcmltm/md/bcmltm_md_pthru.c", "last_update_at": "2018-01-31T07:21:49+00:00", "question_id": "a939314a1dc3c74c64cebdfb9eb58237bf8ca9dc_77", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\npthru_info_pt_list_init(int unit, size_t sid_max_count)\n{\n    unsigned int size;\n    SHR_FUNC_ENTER(unit);\n    size = sizeof(bcmltm_pt_list_t *) * sid_max_count;\n    /* Allocate PT List pointers */\n    SHR_ALLOC(PTHRU_PT_LIST(unit), size,\n              \"LTM PT Pass Thru info pt_list ptrs\");\n    SHR_NULL_CHECK(PTHRU_PT_LIST(unit), SHR_E_MEMORY);\n    sal_memset(PTHRU_PT_LIST(unit), 0, size);\n exit:\n    if (SHR_FUNC_ERR()) {\n        pthru_info_pt_list_cleanup(unit);\n    }\n    SHR_FUNC_EXIT();\n"]]}
{"hexsha": "a50d2b5f365996cf5d4f17090130ce9e27fe5e5a", "ext": "c", "lang": "C", "content": "static struct pipeline* pipelineNew(char ***cmds, unsigned options)\n/* create a new pipeline object. Doesn't start processes */\n{\nstatic char *memPseudoCmd[] = {\"[mem]\", NULL};\nstruct pipeline *pl;\nint iCmd;\n\nAllocVar(pl);\npl->groupLeader = -1;\npl->pipeFd = -1;\npl->options = options;\npl->procName = joinCmds(cmds);\n\nif (cmds[0] == NULL)\n    errAbort(\"no commands in pipeline\");\n\nif (options & pipelineMemInput)\n    {\n    /* add proc for forked process to write memory to pipeline */\n    slAddTail(&pl->procs, plProcNew(memPseudoCmd, pl));\n    }\n\nfor(iCmd = 0; cmds[iCmd] != NULL; iCmd++)\n    slAddTail(&pl->procs, plProcNew(cmds[iCmd], pl));\n\nreturn pl;\n}", "item_id": 12, "repo": "bowhan/kent", "file": "src/lib/pipeline.c", "last_update_at": "2018-03-14T22:19:20+00:00", "question_id": "a50d2b5f365996cf5d4f17090130ce9e27fe5e5a_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static struct pipeline* pipelineNew(char ***cmds, unsigned options)\n/* create a new pipeline object. Doesn't start processes */\n{\nstatic char *memPseudoCmd[] = {\"[mem]\", NULL};\nstruct pipeline *pl;\nint iCmd;\nAllocVar(pl);\npl->groupLeader = -1;\npl->pipeFd = -1;\npl->options = options;\npl->procName = joinCmds(cmds);\nif (cmds[0] == NULL)\n    errAbort(\"no commands in pipeline\");\nif (options & pipelineMemInput)\n    {\n    /* add proc for forked process to write memory to pipeline */\n    slAddTail(&pl->procs, plProcNew(memPseudoCmd, pl));\n    }\nfor(iCmd = 0; cmds[iCmd] != NULL; iCmd++)\n    slAddTail(&pl->procs, plProcNew(cmds[iCmd], pl));\nreturn pl;\n"]]}
{"hexsha": "db2740a1711889c6c3b617b5fc7947353ca868ea", "ext": "c", "lang": "C", "content": "void   LSM6DS3_X_GetAxesRaw( int16_t *pData )\r\n{\r\n    /*Here we could add the check if the parameters are valid*/\r\n  \r\n    uint8_t tempReg[2] = {0,0};\r\n\r\n    LSM6DS3_IO_Read(&tempReg[0], LSM6DS3_XG_MEMS_ADDRESS, LSM6DS3_XG_OUT_X_L_XL, 2);\r\n    pData[0] = ((((int16_t)tempReg[1]) << 8)+(int16_t)tempReg[0]);\r\n\r\n    LSM6DS3_IO_Read(&tempReg[0], LSM6DS3_XG_MEMS_ADDRESS, LSM6DS3_XG_OUT_Y_L_XL, 2);\r\n    pData[1] = ((((int16_t)tempReg[1]) << 8)+(int16_t)tempReg[0]);\r\n\r\n    LSM6DS3_IO_Read(&tempReg[0], LSM6DS3_XG_MEMS_ADDRESS, LSM6DS3_XG_OUT_Z_L_XL, 2);\r\n    pData[2] = ((((int16_t)tempReg[1]) << 8)+(int16_t)tempReg[0]);\r\n    \r\n}", "item_id": 1, "repo": "LimiFrog/LimiFrog-SW", "file": "libraries/Sensor_APIs/LSM6DS3/src/LBF_lsm6ds3.c", "last_update_at": "2018-10-24T08:41:06+00:00", "question_id": "db2740a1711889c6c3b617b5fc7947353ca868ea_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void   LSM6DS3_X_GetAxesRaw( int16_t *pData )\r\n{\r\n    /*Here we could add the check if the parameters are valid*/\r\n  \r\n    uint8_t tempReg[2] = {0,0};\r\n\r\n    LSM6DS3_IO_Read(&tempReg[0], LSM6DS3_XG_MEMS_ADDRESS, LSM6DS3_XG_OUT_X_L_XL, 2);\r\n    pData[0] = ((((int16_t)tempReg[1]) << 8)+(int16_t)tempReg[0]);\r\n\r\n    LSM6DS3_IO_Read(&tempReg[0], LSM6DS3_XG_MEMS_ADDRESS, LSM6DS3_XG_OUT_Y_L_XL, 2);\r\n    pData[1] = ((((int16_t)tempReg[1]) << 8)+(int16_t)tempReg[0]);\r\n\r\n    LSM6DS3_IO_Read(&tempReg[0], LSM6DS3_XG_MEMS_ADDRESS, LSM6DS3_XG_OUT_Z_L_XL, 2);\r\n    pData[2] = ((((int16_t)tempReg[1]) << 8)+(int16_t)tempReg[0]);\r\n    \r\n"]]}
{"hexsha": "0a4b98ae675417a93b8984c8e57d0303e06e0168", "ext": "c", "lang": "C", "content": "VL53L010_API VL53L0_Error VL53L010_PerformOffsetCalibration(VL53L0_DEV Dev,\r\n            FixPoint1616_t CalDistanceMilliMeter,\r\n            int32_t* pOffsetMicroMeter) {\r\n    VL53L0_Error Status = VL53L0_ERROR_NONE;\r\n    uint16_t sum_ranging = 0;\r\n    FixPoint1616_t total_count = 0;\r\n    VL53L0_RangingMeasurementData_t RangingMeasurementData;\r\n    FixPoint1616_t StoredMeanRange;\r\n    uint32_t StoredMeanRangeAsInt;\r\n    VL53L0_DeviceParameters_t CurrentParameters;\r\n    uint32_t CalDistanceAsInt_mm;\r\n    int meas = 0;\r\n    LOG_FUNCTION_START(\"\");\r\n\r\n    if (CalDistanceMilliMeter<=0) {\r\n        Status = VL53L0_ERROR_INVALID_PARAMS;\r\n    }\r\n\r\n    if (Status == VL53L0_ERROR_NONE) {\r\n        VL53L010_SetOffsetCalibrationDataMicroMeter(Dev, 0);\r\n    }\r\n\r\n    /* Perform 50 measurements and compute the averages */\r\n    if (Status == VL53L0_ERROR_NONE) {\r\n        sum_ranging = 0;\r\n        total_count = 0;\r\n        for(meas=0;meas<50;meas++)\r\n        {\r\n            Status = VL53L010_PerformSingleRangingMeasurement(Dev, &RangingMeasurementData);\r\n\r\n            if (Status != VL53L0_ERROR_NONE) {\r\n                break;\r\n            }\r\n\r\n            /* The range is valid when RangeStatus = 0 */\r\n            if (RangingMeasurementData.RangeStatus == 0) {\r\n                sum_ranging = sum_ranging + RangingMeasurementData.RangeMilliMeter;\r\n                total_count = total_count + 1;\r\n            }\r\n        }\r\n\r\n        if (total_count == 0) {\r\n            /* no valid values found */\r\n            Status = VL53L0_ERROR_RANGE_ERROR;\r\n        }\r\n    }\r\n\r\n\r\n    if (Status == VL53L0_ERROR_NONE) {\r\n        /* FixPoint1616_t / uint16_t = FixPoint1616_t */\r\n        StoredMeanRange = (FixPoint1616_t)((uint32_t)(sum_ranging<<16) / total_count);\r\n\r\n        StoredMeanRangeAsInt = (StoredMeanRange + 0x8000) >> 16;\r\n\r\n        /* Round Cal Distance to Whole Number.\r\n         * Note that the cal distance is in mm, therefore no resolution is lost.*/\r\n         CalDistanceAsInt_mm = (CalDistanceMilliMeter + 0x8000) >> 16;\r\n\r\n         *pOffsetMicroMeter = (CalDistanceAsInt_mm - StoredMeanRangeAsInt) * 1000;\r\n\r\n        /* Apply the calculated offset */\r\n        if (Status == VL53L0_ERROR_NONE) {\r\n            VL53L010_SETPARAMETERFIELD(Dev, RangeOffsetMicroMeters, *pOffsetMicroMeter);\r\n            Status = VL53L010_SetOffsetCalibrationDataMicroMeter(Dev, *pOffsetMicroMeter);\r\n        }\r\n\r\n    }\r\n\r\n    LOG_FUNCTION_END(Status);\r\n    return Status;\r\n}", "item_id": 44, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/drivers/misc/mediatek/laser/stmvl53l0/vl53l010_api.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "0a4b98ae675417a93b8984c8e57d0303e06e0168_44", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["VL53L010_API VL53L0_Error VL53L010_PerformOffsetCalibration(VL53L0_DEV Dev,\r\n            FixPoint1616_t CalDistanceMilliMeter,\r\n            int32_t* pOffsetMicroMeter) {\r\n    VL53L0_Error Status = VL53L0_ERROR_NONE;\r\n    uint16_t sum_ranging = 0;\r\n    FixPoint1616_t total_count = 0;\r\n    VL53L0_RangingMeasurementData_t RangingMeasurementData;\r\n    FixPoint1616_t StoredMeanRange;\r\n    uint32_t StoredMeanRangeAsInt;\r\n    VL53L0_DeviceParameters_t CurrentParameters;\r\n    uint32_t CalDistanceAsInt_mm;\r\n    int meas = 0;\r\n    LOG_FUNCTION_START(\"\");\r\n\r\n    if (CalDistanceMilliMeter<=0) {\r\n        Status = VL53L0_ERROR_INVALID_PARAMS;\r\n    }\r\n\r\n    if (Status == VL53L0_ERROR_NONE) {\r\n        VL53L010_SetOffsetCalibrationDataMicroMeter(Dev, 0);\r\n    }\r\n\r\n    /* Perform 50 measurements and compute the averages */\r\n    if (Status == VL53L0_ERROR_NONE) {\r\n        sum_ranging = 0;\r\n        total_count = 0;\r\n        for(meas=0;meas<50;meas++)\r\n        {\r\n            Status = VL53L010_PerformSingleRangingMeasurement(Dev, &RangingMeasurementData);\r\n\r\n            if (Status != VL53L0_ERROR_NONE) {\r\n                break;\r\n            }\r\n\r\n            /* The range is valid when RangeStatus = 0 */\r\n            if (RangingMeasurementData.RangeStatus == 0) {\r\n                sum_ranging = sum_ranging + RangingMeasurementData.RangeMilliMeter;\r\n                total_count = total_count + 1;\r\n            }\r\n        }\r\n\r\n        if (total_count == 0) {\r\n            /* no valid values found */\r\n            Status = VL53L0_ERROR_RANGE_ERROR;\r\n        }\r\n    }\r\n\r\n\r\n    if (Status == VL53L0_ERROR_NONE) {\r\n        /* FixPoint1616_t / uint16_t = FixPoint1616_t */\r\n        StoredMeanRange = (FixPoint1616_t)((uint32_t)(sum_ranging<<16) / total_count);\r\n\r\n        StoredMeanRangeAsInt = (StoredMeanRange + 0x8000) >> 16;\r\n\r\n        /* Round Cal Distance to Whole Number.\r\n         * Note that the cal distance is in mm, therefore no resolution is lost.*/\r\n         CalDistanceAsInt_mm = (CalDistanceMilliMeter + 0x8000) >> 16;\r\n\r\n         *pOffsetMicroMeter = (CalDistanceAsInt_mm - StoredMeanRangeAsInt) * 1000;\r\n\r\n        /* Apply the calculated offset */\r\n        if (Status == VL53L0_ERROR_NONE) {\r\n            VL53L010_SETPARAMETERFIELD(Dev, RangeOffsetMicroMeters, *pOffsetMicroMeter);\r\n            Status = VL53L010_SetOffsetCalibrationDataMicroMeter(Dev, *pOffsetMicroMeter);\r\n        }\r\n\r\n    }\r\n\r\n    LOG_FUNCTION_END(Status);\r\n    return Status;\r\n"]]}
{"hexsha": "a50d2b5f365996cf5d4f17090130ce9e27fe5e5a", "ext": "c", "lang": "C", "content": "static void waitOnOne(struct pipeline *pl)\n/* wait on one process to finish */\n{\nint status;\npid_t pid = waitpid(-pl->groupLeader, &status, 0);\nif (pid < 0)\n    errnoAbort(\"waitpid failed\");\nplProcHandleTerminate(pipelineFindProc(pl, pid), status);\npl->numRunning--;\nassert(pl->numRunning >= 0);\n}", "item_id": 16, "repo": "bowhan/kent", "file": "src/lib/pipeline.c", "last_update_at": "2018-03-14T22:19:20+00:00", "question_id": "a50d2b5f365996cf5d4f17090130ce9e27fe5e5a_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void waitOnOne(struct pipeline *pl)\n/* wait on one process to finish */\n{\nint status;\npid_t pid = waitpid(-pl->groupLeader, &status, 0);\nif (pid < 0)\n    errnoAbort(\"waitpid failed\");\nplProcHandleTerminate(pipelineFindProc(pl, pid), status);\npl->numRunning--;\nassert(pl->numRunning >= 0);\n"]]}
{"hexsha": "a251ddb2edb7ec8f8cc82e043da7f23406efdebf", "ext": "c", "lang": "C", "content": "static void parseDatabaseLines(struct blastFile *bf, char *line, struct blastQuery *bq)\n/* Process something like:\n * Database: chr22.fa \n *        977 sequences; 95,550,797 total letters\n */\n{\nstatic struct dyString *tmpBuf = NULL;\nchar *words[16];\nint wordCount;\nif (bq->database != NULL)\n    bfError(bf, \"already parse Database:\");\n\nif (tmpBuf == NULL)\n    tmpBuf = dyStringNew(512);\n\n/* parse something like\n * Database: celegans98\n * some versions of blastp include the absolute path, but\n * then split it across lines.\n */\nwordCount = chopLine(line, words);\nif (wordCount < 2)\n    bfError(bf, \"Expecting database name\");\ndyStringClear(tmpBuf);\ndyStringAppend(tmpBuf, words[1]);\nwhile (line = bfNeedNextLine(bf), !isspace(line[0]))\n    {\n    dyStringAppend(tmpBuf, line);\n    }\nbq->database = cloneString(tmpBuf->string);\n\n/* Process something like:\n *        977 sequences; 95,550,797 total letters\n */\nwordCount = chopLine(line, words);\nif (wordCount < 3 || !isdigit(words[0][0]) || !isdigit(words[2][0]))\n    bfError(bf, \"Expecting database info\");\ndecomma(words[0]);\ndecomma(words[2]);\nbq->dbSeqCount = atoi(words[0]);\nbq->dbBaseCount = atoi(words[2]);\n}", "item_id": 6, "repo": "zrhanna/blatq", "file": "blatSrc/lib/blastParse.c", "last_update_at": "2018-03-14T22:19:20+00:00", "question_id": "a251ddb2edb7ec8f8cc82e043da7f23406efdebf_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void parseDatabaseLines(struct blastFile *bf, char *line, struct blastQuery *bq)\n/* Process something like:\n * Database: chr22.fa \n *        977 sequences; 95,550,797 total letters\n */\n{\nstatic struct dyString *tmpBuf = NULL;\nchar *words[16];\nint wordCount;\nif (bq->database != NULL)\n    bfError(bf, \"already parse Database:\");\nif (tmpBuf == NULL)\n    tmpBuf = dyStringNew(512);\n/* parse something like\n * Database: celegans98\n * some versions of blastp include the absolute path, but\n * then split it across lines.\n */\nwordCount = chopLine(line, words);\nif (wordCount < 2)\n    bfError(bf, \"Expecting database name\");\ndyStringClear(tmpBuf);\ndyStringAppend(tmpBuf, words[1]);\nwhile (line = bfNeedNextLine(bf), !isspace(line[0]))\n    {\n    dyStringAppend(tmpBuf, line);\n    }\nbq->database = cloneString(tmpBuf->string);\n/* Process something like:\n *        977 sequences; 95,550,797 total letters\n */\nwordCount = chopLine(line, words);\nif (wordCount < 3 || !isdigit(words[0][0]) || !isdigit(words[2][0]))\n    bfError(bf, \"Expecting database info\");\ndecomma(words[0]);\ndecomma(words[2]);\nbq->dbSeqCount = atoi(words[0]);\nbq->dbBaseCount = atoi(words[2]);\n"]]}
{"hexsha": "cec2808f7a46487741be74664dfa5d8d6b8a532a", "ext": "c", "lang": "C", "content": "void Auddrv_Set_UnderFlow(void)\n{\n\tunsigned long long underflow_time = sched_clock();\t/* in ns (10^9) */\n\n\tpr_debug(\"%s UnderflowCounter = %d\\n\", __func__, UnderflowCounter);\n\tUnderflowTime[UnderflowCounter] = underflow_time;\n\tUnderflowCounter++;\n\tUnderflowCounter %= UnderflowrecordNumber;\n\tif (UnderflowCounter > UnderflowThreshold) {\n\t\tDumpUnderFlowTime();\n\t\tAuddrv_Aee_Dump();\n\t}\n}", "item_id": 2, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/sound/soc/mediatek/common/auddrv_underflow_mach.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "cec2808f7a46487741be74664dfa5d8d6b8a532a_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void Auddrv_Set_UnderFlow(void)\n{\n\tunsigned long long underflow_time = sched_clock();\t/* in ns (10^9) */\n\tpr_debug(\"%s UnderflowCounter = %d\\n\", __func__, UnderflowCounter);\n\tUnderflowTime[UnderflowCounter] = underflow_time;\n\tUnderflowCounter++;\n\tUnderflowCounter %= UnderflowrecordNumber;\n\tif (UnderflowCounter > UnderflowThreshold) {\n\t\tDumpUnderFlowTime();\n\t\tAuddrv_Aee_Dump();\n\t}\n"]]}
{"hexsha": "b747e136a0ae17b2651c7ef73e845960c19132ba", "ext": "c", "lang": "C", "content": "int gps_v2_get_identity(GPSV2 *gps_v2, char ret_uid[8], char ret_connected_uid[8], char *ret_position, uint8_t ret_hardware_version[3], uint8_t ret_firmware_version[3], uint16_t *ret_device_identifier) {\n\tDevicePrivate *device_p = gps_v2->p;\n\tGetIdentity_Request request;\n\tGetIdentity_Response response;\n\tint ret;\n\n\tret = packet_header_create(&request.header, sizeof(request), GPS_V2_FUNCTION_GET_IDENTITY, device_p->ipcon_p, device_p);\n\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tret = device_send_request(device_p, (Packet *)&request, (Packet *)&response);\n\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tmemcpy(ret_uid, response.uid, 8);\n\tmemcpy(ret_connected_uid, response.connected_uid, 8);\n\t*ret_position = response.position;\n\tmemcpy(ret_hardware_version, response.hardware_version, 3 * sizeof(uint8_t));\n\tmemcpy(ret_firmware_version, response.firmware_version, 3 * sizeof(uint8_t));\n\t*ret_device_identifier = leconvert_uint16_from(response.device_identifier);\n\n\treturn ret;\n}", "item_id": 40, "repo": "ulrichwi/ros-tinkerforge_sensors", "file": "src/tinkerforge/bricklet_gps_v2.c", "last_update_at": "2018-12-11T16:04:42+00:00", "question_id": "b747e136a0ae17b2651c7ef73e845960c19132ba_40", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int gps_v2_get_identity(GPSV2 *gps_v2, char ret_uid[8], char ret_connected_uid[8], char *ret_position, uint8_t ret_hardware_version[3], uint8_t ret_firmware_version[3], uint16_t *ret_device_identifier) {\n\tDevicePrivate *device_p = gps_v2->p;\n\tGetIdentity_Request request;\n\tGetIdentity_Response response;\n\tint ret;\n\tret = packet_header_create(&request.header, sizeof(request), GPS_V2_FUNCTION_GET_IDENTITY, device_p->ipcon_p, device_p);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\tret = device_send_request(device_p, (Packet *)&request, (Packet *)&response);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\tmemcpy(ret_uid, response.uid, 8);\n\tmemcpy(ret_connected_uid, response.connected_uid, 8);\n\t*ret_position = response.position;\n\tmemcpy(ret_hardware_version, response.hardware_version, 3 * sizeof(uint8_t));\n\tmemcpy(ret_firmware_version, response.firmware_version, 3 * sizeof(uint8_t));\n\t*ret_device_identifier = leconvert_uint16_from(response.device_identifier);\n\treturn ret;\n"]]}
{"hexsha": "4823676ad6844e731fa8b954793205d99a5fd9e0", "ext": "c", "lang": "C", "content": "static void do_power()\n{\n  if(IS_INTEGER(peek(0)) && IS_INTEGER(peek(1)))\n  {\n    double b = (double)AS_INTEGER(pop())->value;\n    double a = (double)AS_INTEGER(pop())->value;\n\n    push(AS_OBJECT(create_integer(pow(a, b))));\n    return;\n  }\n\n  if(IS_REAL(peek(0)) && IS_REAL(peek(1)))\n  {\n    double b = AS_REAL(pop())->value;\n    double a = AS_REAL(pop())->value;\n\n    push(AS_OBJECT(create_real(pow(a, b))));\n    return;\n  }\n\n  if(IS_INTEGER(peek(0)) && IS_REAL(peek(1)))\n  {\n    double b = (double)AS_INTEGER(pop())->value;\n    double a = AS_REAL(pop())->value;\n\n    push(AS_OBJECT(create_real(pow(a, b))));\n    return;\n  }\n\n  if(IS_REAL(peek(0)) && IS_INTEGER(peek(1)))\n  {\n    double b = AS_REAL(pop())->value;\n    double a = (double)AS_INTEGER(pop())->value;\n\n    push(AS_OBJECT(create_real(pow(a, b))));\n    return;\n  }\n}", "item_id": 12, "repo": "dlains/cube", "file": "src/vm.c", "last_update_at": "2018-08-20T00:28:37+00:00", "question_id": "4823676ad6844e731fa8b954793205d99a5fd9e0_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void do_power()\n{\n  if(IS_INTEGER(peek(0)) && IS_INTEGER(peek(1)))\n  {\n    double b = (double)AS_INTEGER(pop())->value;\n    double a = (double)AS_INTEGER(pop())->value;\n    push(AS_OBJECT(create_integer(pow(a, b))));\n    return;\n  }\n  if(IS_REAL(peek(0)) && IS_REAL(peek(1)))\n  {\n    double b = AS_REAL(pop())->value;\n    double a = AS_REAL(pop())->value;\n    push(AS_OBJECT(create_real(pow(a, b))));\n    return;\n  }\n  if(IS_INTEGER(peek(0)) && IS_REAL(peek(1)))\n  {\n    double b = (double)AS_INTEGER(pop())->value;\n    double a = AS_REAL(pop())->value;\n    push(AS_OBJECT(create_real(pow(a, b))));\n    return;\n  }\n  if(IS_REAL(peek(0)) && IS_INTEGER(peek(1)))\n  {\n    double b = AS_REAL(pop())->value;\n    double a = (double)AS_INTEGER(pop())->value;\n    push(AS_OBJECT(create_real(pow(a, b))));\n    return;\n  }\n"]]}
{"hexsha": "63ecf77d31e5552017e09759b47aeb1545443ee5", "ext": "c", "lang": "C", "content": "void musb_start(struct musb *musb)\n{\n\tu8 devctl = (u8) os_readl(U3D_DEVICE_CONTROL);\n\n\tdev_dbg(musb->controller, \"<== devctl %02x\\n\", devctl);\n\n\tos_printk(K_INFO, \"%s\\n\", __func__);\n\n\tif (musb->is_clk_on == 0) {\n#ifndef CONFIG_MTK_FPGA\n\t\t/* Recovert PHY. And turn on CLK. */\n\t\tusb_phy_recover(musb->is_clk_on);\n\t\tmusb->is_clk_on = 1;\n\n\t\t/* USB 2.0 slew rate calibration */\n\t\tu3phy_ops->u2_slew_rate_calibration(u3phy);\n#endif\n\n\t\t/* disable IP reset and power down, disable U2/U3 ip power down */\n\t\t_ex_mu3d_hal_ssusb_en();\n\n\t\t/* USB PLL Force settings */\n#ifdef CONFIG_PROJECT_PHY\n\t\tusb20_pll_settings(false, false);\n#endif\n\n\t\t/* reset U3D all dev module. */\n\t\tmu3d_hal_rst_dev();\n\n\t\t/*\n\t\t * SW workaround of SSUSB device mode fake disable interrupt\n\t\t * 1. Clear SSUSB_U3_PORT_DIS @ _ex_mu3d_hal_ssusb_en()\n\t\t * 2. Wait SSUSB_U3_MAC_RST_B_STS change to 1. @ mu3d_hal_check_clk_sts()\n\t\t * 3. Delay 50us\n\t\t * 4. Clear U3 interrupt @ mu3d_hal_check_clk_sts()\n\t\t * Recommended value : 50us\n\t\t */\n\t\tudelay(20);\n\n\t\tmusb_restore_context(musb);\n\t}\n\n\t/*Enable Level 1 interrupt (BMU, QMU, MAC3, DMA, MAC2, EPCTL) */\n\tos_writel(U3D_LV1IESR, 0xFFFFFFFF);\n\n\t/* Initialize the default interrupts */\n\t_ex_mu3d_hal_system_intr_en();\n\n#ifdef USB_GADGET_SUPERSPEED\n\t/* HS/FS detected by HW */\n\t/* USB2.0 controller will negotiate for HS mode when the device is reset by the host */\n\tos_writel(U3D_POWER_MANAGEMENT, (os_readl(U3D_POWER_MANAGEMENT) | HS_ENABLE));\n\n\t/* set LPM remote wake up enable by HW */\n\tos_writel(U3D_POWER_MANAGEMENT, (os_readl(U3D_POWER_MANAGEMENT) | LPM_HRWE));\n\tos_writel(U3D_USB2_EPCTL_LPM, (L1_EXIT_EP0_CHK | L1_EXIT_EP_IN_CHK | L1_EXIT_EP_OUT_CHK));\n\tos_writel(U3D_USB2_EPCTL_LPM_FC_CHK,\n\t\t  (L1_EXIT_EP0_FC_CHK | L1_EXIT_EP_IN_FC_CHK | L1_EXIT_EP_OUT_FC_CHK));\n\n#ifdef CONFIG_USBIF_COMPLIANCE\n\t/* Accept LGO_U1/U2 at beginning */\n\tos_writel(U3D_LINK_POWER_CONTROL,\n\t\t  os_readl(U3D_LINK_POWER_CONTROL) | SW_U1_ACCEPT_ENABLE | SW_U2_ACCEPT_ENABLE);\n\n\t/* 3us timeout for PENDING HP */\n\tos_writel(U3D_LINK_HP_TIMER, (os_readl(U3D_LINK_HP_TIMER) & ~(PHP_TIMEOUT_VALUE)) | 0x6);\n\n\t/* set vbus force enable */\n\tos_setmsk(U3D_MISC_CTRL, (VBUS_FRC_EN | VBUS_ON));\n#endif\n\n\t/* device responses to u3_exit from host automatically */\n\tos_writel(U3D_LTSSM_CTRL, os_readl(U3D_LTSSM_CTRL) & ~SOFT_U3_EXIT_EN);\n\n#else\n#ifdef USB_GADGET_DUALSPEED\n\t/* HS/FS detected by HW */\n\tos_writel(U3D_POWER_MANAGEMENT, os_readl(U3D_POWER_MANAGEMENT) | HS_ENABLE);\n#else\n\t/* FS only */\n\tos_writel(U3D_POWER_MANAGEMENT, os_readl(U3D_POWER_MANAGEMENT) & ~HS_ENABLE);\n#endif\n\t/* disable U3 port */\n\tmu3d_hal_u3dev_dis();\n#endif\n\n#ifndef CONFIG_MTK_FPGA\n\t/*if (mt_get_chip_hw_code() == 0x6595) */\n\t{\n\t\tos_printk(K_INFO, \"%s Set Clock to 62.4MHz+\\n\", __func__);\n\t\t/* sys_ck = OSC 124.8MHz/2 = 62.4MHz */\n\t\tos_setmsk(U3D_SSUSB_SYS_CK_CTRL, SSUSB_SYS_CK_DIV2_EN);\n\t\t/* U2 MAC sys_ck = ceil(62.4) = 63 */\n\t\tos_writelmsk(U3D_USB20_TIMING_PARAMETER, 63, TIME_VALUE_1US);\n#ifdef SUPPORT_U3\n\t\t/* U3 MAC sys_ck = ceil(62.4) = 63 */\n\t\tos_writelmsk(U3D_TIMING_PULSE_CTRL, 63, CNT_1US_VALUE);\n#endif\n\t\tos_printk(K_INFO, \"%s Set Clock to 62.4MHz-\\n\", __func__);\n\t}\n#endif\n\n\tos_writel(U3D_LINK_RESET_INFO, os_readl(U3D_LINK_RESET_INFO) & ~WTCHRP);\n\n\t/* U2/U3 detected by HW */\n\tos_writel(U3D_DEVICE_CONF, 0);\n\n\tmusb->is_active = 1;\n\n\tmusb_platform_enable(musb);\n\n#ifdef EP_PROFILING\n\tif (is_prof != 0)\n\t\tschedule_delayed_work(&musb->ep_prof_work, msecs_to_jiffies(POLL_INTERVAL * 1000));\n#endif\n\n\tif (musb->softconnect)\n\t\tmu3d_hal_u3dev_en();\n}", "item_id": 9, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/drivers/misc/mediatek/mu3d/drv/musb_core.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "63ecf77d31e5552017e09759b47aeb1545443ee5_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void musb_start(struct musb *musb)\n{\n\tu8 devctl = (u8) os_readl(U3D_DEVICE_CONTROL);\n\tdev_dbg(musb->controller, \"<== devctl %02x\\n\", devctl);\n\tos_printk(K_INFO, \"%s\\n\", __func__);\n\tif (musb->is_clk_on == 0) {\n#ifndef CONFIG_MTK_FPGA\n\t\t/* Recovert PHY. And turn on CLK. */\n\t\tusb_phy_recover(musb->is_clk_on);\n\t\tmusb->is_clk_on = 1;\n\t\t/* USB 2.0 slew rate calibration */\n\t\tu3phy_ops->u2_slew_rate_calibration(u3phy);\n#endif\n\t\t/* disable IP reset and power down, disable U2/U3 ip power down */\n\t\t_ex_mu3d_hal_ssusb_en();\n\t\t/* USB PLL Force settings */\n#ifdef CONFIG_PROJECT_PHY\n\t\tusb20_pll_settings(false, false);\n#endif\n\t\t/* reset U3D all dev module. */\n\t\tmu3d_hal_rst_dev();\n\t\t/*\n\t\t * SW workaround of SSUSB device mode fake disable interrupt\n\t\t * 1. Clear SSUSB_U3_PORT_DIS @ _ex_mu3d_hal_ssusb_en()\n\t\t * 2. Wait SSUSB_U3_MAC_RST_B_STS change to 1. @ mu3d_hal_check_clk_sts()\n\t\t * 3. Delay 50us\n\t\t * 4. Clear U3 interrupt @ mu3d_hal_check_clk_sts()\n\t\t * Recommended value : 50us\n\t\t */\n\t\tudelay(20);\n\t\tmusb_restore_context(musb);\n\t}\n\t/*Enable Level 1 interrupt (BMU, QMU, MAC3, DMA, MAC2, EPCTL) */\n\tos_writel(U3D_LV1IESR, 0xFFFFFFFF);\n\t/* Initialize the default interrupts */\n\t_ex_mu3d_hal_system_intr_en();\n#ifdef USB_GADGET_SUPERSPEED\n\t/* HS/FS detected by HW */\n\t/* USB2.0 controller will negotiate for HS mode when the device is reset by the host */\n\tos_writel(U3D_POWER_MANAGEMENT, (os_readl(U3D_POWER_MANAGEMENT) | HS_ENABLE));\n\t/* set LPM remote wake up enable by HW */\n\tos_writel(U3D_POWER_MANAGEMENT, (os_readl(U3D_POWER_MANAGEMENT) | LPM_HRWE));\n\tos_writel(U3D_USB2_EPCTL_LPM, (L1_EXIT_EP0_CHK | L1_EXIT_EP_IN_CHK | L1_EXIT_EP_OUT_CHK));\n\tos_writel(U3D_USB2_EPCTL_LPM_FC_CHK,\n\t\t  (L1_EXIT_EP0_FC_CHK | L1_EXIT_EP_IN_FC_CHK | L1_EXIT_EP_OUT_FC_CHK));\n#ifdef CONFIG_USBIF_COMPLIANCE\n\t/* Accept LGO_U1/U2 at beginning */\n\tos_writel(U3D_LINK_POWER_CONTROL,\n\t\t  os_readl(U3D_LINK_POWER_CONTROL) | SW_U1_ACCEPT_ENABLE | SW_U2_ACCEPT_ENABLE);\n\t/* 3us timeout for PENDING HP */\n\tos_writel(U3D_LINK_HP_TIMER, (os_readl(U3D_LINK_HP_TIMER) & ~(PHP_TIMEOUT_VALUE)) | 0x6);\n\t/* set vbus force enable */\n\tos_setmsk(U3D_MISC_CTRL, (VBUS_FRC_EN | VBUS_ON));\n#endif\n\t/* device responses to u3_exit from host automatically */\n\tos_writel(U3D_LTSSM_CTRL, os_readl(U3D_LTSSM_CTRL) & ~SOFT_U3_EXIT_EN);\n#else\n#ifdef USB_GADGET_DUALSPEED\n\t/* HS/FS detected by HW */\n\tos_writel(U3D_POWER_MANAGEMENT, os_readl(U3D_POWER_MANAGEMENT) | HS_ENABLE);\n#else\n\t/* FS only */\n\tos_writel(U3D_POWER_MANAGEMENT, os_readl(U3D_POWER_MANAGEMENT) & ~HS_ENABLE);\n#endif\n\t/* disable U3 port */\n\tmu3d_hal_u3dev_dis();\n#endif\n#ifndef CONFIG_MTK_FPGA\n\t/*if (mt_get_chip_hw_code() == 0x6595) */\n\t{\n\t\tos_printk(K_INFO, \"%s Set Clock to 62.4MHz+\\n\", __func__);\n\t\t/* sys_ck = OSC 124.8MHz/2 = 62.4MHz */\n\t\tos_setmsk(U3D_SSUSB_SYS_CK_CTRL, SSUSB_SYS_CK_DIV2_EN);\n\t\t/* U2 MAC sys_ck = ceil(62.4) = 63 */\n\t\tos_writelmsk(U3D_USB20_TIMING_PARAMETER, 63, TIME_VALUE_1US);\n#ifdef SUPPORT_U3\n\t\t/* U3 MAC sys_ck = ceil(62.4) = 63 */\n\t\tos_writelmsk(U3D_TIMING_PULSE_CTRL, 63, CNT_1US_VALUE);\n#endif\n\t\tos_printk(K_INFO, \"%s Set Clock to 62.4MHz-\\n\", __func__);\n\t}\n#endif\n\tos_writel(U3D_LINK_RESET_INFO, os_readl(U3D_LINK_RESET_INFO) & ~WTCHRP);\n\t/* U2/U3 detected by HW */\n\tos_writel(U3D_DEVICE_CONF, 0);\n\tmusb->is_active = 1;\n\tmusb_platform_enable(musb);\n#ifdef EP_PROFILING\n\tif (is_prof != 0)\n\t\tschedule_delayed_work(&musb->ep_prof_work, msecs_to_jiffies(POLL_INTERVAL * 1000));\n#endif\n\tif (musb->softconnect)\n\t\tmu3d_hal_u3dev_en();\n"]]}
{"hexsha": "c54f9de1e317817c7aba633dea765002c2ca38c8", "ext": "c", "lang": "C", "content": "PUBLIC int do_rs_set_priv(message *m)\r\n{\r\n\tint r, n, nr;\r\n\tstruct vmproc *vmp;\r\n\r\n\tnr = m->VM_RS_NR;\r\n\r\n\tif ((r = vm_isokendpt(nr, &n)) != OK) {\r\n\t\tprintf(\"do_rs_set_priv: message from strange source %d\\n\", nr);\r\n\t\treturn EINVAL;\r\n\t}\r\n\r\n\tvmp = &vmproc[n];\r\n\r\n\tif (m->VM_RS_BUF) {\r\n\t\tr = sys_datacopy(m->m_source, (vir_bytes) m->VM_RS_BUF,\r\n\t\t\t\t SELF, (vir_bytes) vmp->vm_call_mask,\r\n\t\t\t\t sizeof(vmp->vm_call_mask));\r\n\t\tif (r != OK)\r\n\t\t\treturn r;\r\n\t}\r\n\r\n\treturn OK;\r\n}", "item_id": 0, "repo": "ducis/operating-system-labs", "file": "src.clean/servers/vm/rs.c", "last_update_at": "2018-03-01T14:11:47+00:00", "question_id": "c54f9de1e317817c7aba633dea765002c2ca38c8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["PUBLIC int do_rs_set_priv(message *m)\r\n{\r\n\tint r, n, nr;\r\n\tstruct vmproc *vmp;\r\n\r\n\tnr = m->VM_RS_NR;\r\n\r\n\tif ((r = vm_isokendpt(nr, &n)) != OK) {\r\n\t\tprintf(\"do_rs_set_priv: message from strange source %d\\n\", nr);\r\n\t\treturn EINVAL;\r\n\t}\r\n\r\n\tvmp = &vmproc[n];\r\n\r\n\tif (m->VM_RS_BUF) {\r\n\t\tr = sys_datacopy(m->m_source, (vir_bytes) m->VM_RS_BUF,\r\n\t\t\t\t SELF, (vir_bytes) vmp->vm_call_mask,\r\n\t\t\t\t sizeof(vmp->vm_call_mask));\r\n\t\tif (r != OK)\r\n\t\t\treturn r;\r\n\t}\r\n\r\n\treturn OK;\r\n"]]}
{"hexsha": "2fd8c1a81231480b907abbc4ae86eea3f771c31a", "ext": "c", "lang": "C", "content": "UCHAR GarbageChar(PC0C_IO_PORT pWriteIoPort, PC0C_IO_PORT pReadIoPort, PUCHAR pLsr)\r\n{\r\n  if (pWriteIoPort->lineControl.Parity != NO_PARITY && RAND()%2 > 0)\r\n    ParityError(pReadIoPort, pLsr);\r\n\r\n  if (RAND()%2 > 0)\r\n    FrameError(pReadIoPort, pLsr);\r\n\r\n  return (UCHAR)RAND();\r\n}", "item_id": 3, "repo": "ooici/coi-services", "file": "ion/agents/instrument/direct_access/Com0Com/com0com-2.2.2.0/sys/noise.c", "last_update_at": "2018-08-10T01:41:38+00:00", "question_id": "2fd8c1a81231480b907abbc4ae86eea3f771c31a_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["UCHAR GarbageChar(PC0C_IO_PORT pWriteIoPort, PC0C_IO_PORT pReadIoPort, PUCHAR pLsr)\r\n{\r\n  if (pWriteIoPort->lineControl.Parity != NO_PARITY && RAND()%2 > 0)\r\n    ParityError(pReadIoPort, pLsr);\r\n\r\n  if (RAND()%2 > 0)\r\n    FrameError(pReadIoPort, pLsr);\r\n\r\n  return (UCHAR)RAND();\r\n"]]}
{"hexsha": "9628ceccfa02f195b83f8989a7064f0411bc0ab3", "ext": "c", "lang": "C", "content": "int\t\t\t\t\t\t/* error */\nxfs_dir2_block_replace(\n\txfs_da_args_t\t\t*args)\t\t/* directory operation args */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\tent;\t\t/* leaf entry index */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\n\ttrace_xfs_dir2_block_replace(args);\n\n\t/*\n\t * Lookup the entry in the directory.  Get buffer and entry index.\n\t * This will always succeed since the caller has already done a lookup.\n\t */\n\tif ((error = xfs_dir2_block_lookup_int(args, &bp, &ent))) {\n\t\treturn error;\n\t}\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\thdr = bp->b_addr;\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Point to the data entry we need to change.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(blp[ent].address)));\n\tASSERT(be64_to_cpu(dep->inumber) != args->inumber);\n\t/*\n\t * Change the inode number to the new value.\n\t */\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\txfs_dir3_data_check(dp, bp);\n\treturn 0;\n}", "item_id": 13, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/fs/xfs/libxfs/xfs_dir2_block.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "9628ceccfa02f195b83f8989a7064f0411bc0ab3_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\t\t\t\t\t\t/* error */\nxfs_dir2_block_replace(\n\txfs_da_args_t\t\t*args)\t\t/* directory operation args */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\tent;\t\t/* leaf entry index */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\ttrace_xfs_dir2_block_replace(args);\n\t/*\n\t * Lookup the entry in the directory.  Get buffer and entry index.\n\t * This will always succeed since the caller has already done a lookup.\n\t */\n\tif ((error = xfs_dir2_block_lookup_int(args, &bp, &ent))) {\n\t\treturn error;\n\t}\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\thdr = bp->b_addr;\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Point to the data entry we need to change.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(blp[ent].address)));\n\tASSERT(be64_to_cpu(dep->inumber) != args->inumber);\n\t/*\n\t * Change the inode number to the new value.\n\t */\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\txfs_dir3_data_check(dp, bp);\n\treturn 0;\n"]]}
{"hexsha": "3c4e95296087bdb9f6d02f3c7d14fb34bcbe2d6d", "ext": "c", "lang": "C", "content": "void hprdPrimaryRefSave(struct hprdPrimaryRef *obj, int indent, FILE *f)\n/* Save hprdPrimaryRef to file. */\n{\nif (obj == NULL) return;\nxapIndent(indent, f);\nfprintf(f, \"<primaryRef\");\nfprintf(f, \" db=\\\"%s\\\"\", obj->db);\nfprintf(f, \" id=\\\"%s\\\"\", obj->id);\nif (obj->dbAc != NULL)\n    fprintf(f, \" dbAc=\\\"%s\\\"\", obj->dbAc);\nif (obj->refType != NULL)\n    fprintf(f, \" refType=\\\"%s\\\"\", obj->refType);\nif (obj->refTypeAc != NULL)\n    fprintf(f, \" refTypeAc=\\\"%s\\\"\", obj->refTypeAc);\nfprintf(f, \"/>\\n\");\n}", "item_id": 28, "repo": "CEpBrowser/CEpBrowser--from-UCSC-CGI-BIN", "file": "hg/near/hprdXmlToTab/hprd.c", "last_update_at": "2018-03-14T22:19:20+00:00", "question_id": "3c4e95296087bdb9f6d02f3c7d14fb34bcbe2d6d_28", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void hprdPrimaryRefSave(struct hprdPrimaryRef *obj, int indent, FILE *f)\n/* Save hprdPrimaryRef to file. */\n{\nif (obj == NULL) return;\nxapIndent(indent, f);\nfprintf(f, \"<primaryRef\");\nfprintf(f, \" db=\\\"%s\\\"\", obj->db);\nfprintf(f, \" id=\\\"%s\\\"\", obj->id);\nif (obj->dbAc != NULL)\n    fprintf(f, \" dbAc=\\\"%s\\\"\", obj->dbAc);\nif (obj->refType != NULL)\n    fprintf(f, \" refType=\\\"%s\\\"\", obj->refType);\nif (obj->refTypeAc != NULL)\n    fprintf(f, \" refTypeAc=\\\"%s\\\"\", obj->refTypeAc);\nfprintf(f, \"/>\\n\");\n"]]}
{"hexsha": "c3131f38387e6eec8ac71ff8a468250c6273b9d2", "ext": "c", "lang": "C", "content": "int sum(int a, int b)\n{\n\tint c;\n\tc = a + b;\n\treturn c;\n}", "item_id": 1, "repo": "aishikchakraborty/Compilers-Lab", "file": "Assignment 4/ass4_13CS30041_test.c", "last_update_at": "2018-09-03T13:46:30+00:00", "question_id": "c3131f38387e6eec8ac71ff8a468250c6273b9d2_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int sum(int a, int b)\n{\n\tint c;\n\tc = a + b;\n\treturn c;\n"]]}
{"hexsha": "23af64a6d056ce5014f2bcadea60b5a7af2922de", "ext": "c", "lang": "C", "content": "static void ssh2_msg_debug(Ssh ssh, struct Packet *pktin)\r\n{\r\n    /* log the debug message */\r\n    char *msg;\r\n    int msglen;\r\n\r\n    /* XXX maybe we should actually take notice of the return value */\r\n    ssh2_pkt_getbool(pktin);\r\n    ssh_pkt_getstring(pktin, &msg, &msglen);\r\n\r\n    logeventf(ssh, \"Remote debug message: %.*s\", msglen, msg);\r\n}", "item_id": 123, "repo": "ralish/kitty", "file": "0.63_My_PuTTY/ssh.c", "last_update_at": "2018-05-09T12:55:24+00:00", "question_id": "23af64a6d056ce5014f2bcadea60b5a7af2922de_123", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void ssh2_msg_debug(Ssh ssh, struct Packet *pktin)\r\n{\r\n    /* log the debug message */\r\n    char *msg;\r\n    int msglen;\r\n\r\n    /* XXX maybe we should actually take notice of the return value */\r\n    ssh2_pkt_getbool(pktin);\r\n    ssh_pkt_getstring(pktin, &msg, &msglen);\r\n\r\n    logeventf(ssh, \"Remote debug message: %.*s\", msglen, msg);\r\n"]]}
{"hexsha": "4c98b423dd0b870ec55930c4095eb7fb38af3568", "ext": "c", "lang": "C", "content": "static int __Pyx_BufFmt_ExpectNumber(const char **ts) {\n    int number = __Pyx_BufFmt_ParseNumber(ts);\n    if (number == -1) \n        PyErr_Format(PyExc_ValueError,\\\n                     \"Does not understand character buffer dtype format string ('%c')\", **ts);\n    return number;\n}", "item_id": 57, "repo": "seberg/scipy", "file": "scipy/interpolate/interpnd.c", "last_update_at": "2018-10-04T15:34:14+00:00", "question_id": "4c98b423dd0b870ec55930c4095eb7fb38af3568_57", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int __Pyx_BufFmt_ExpectNumber(const char **ts) {\n    int number = __Pyx_BufFmt_ParseNumber(ts);\n    if (number == -1) \n        PyErr_Format(PyExc_ValueError,\\\n                     \"Does not understand character buffer dtype format string ('%c')\", **ts);\n    return number;\n"]]}
{"hexsha": "e9ad527aaf0ae3e03ce6704bd4e4e01bce483611", "ext": "c", "lang": "C", "content": "static PyObject *\ntypecast_INTEGER_cast(const char *s, Py_ssize_t len, PyObject *curs)\n{\n    char buffer[12];\n\n    if (s == NULL) {Py_INCREF(Py_None); return Py_None;}\n    if (s[len] != '\\0') {\n        strncpy(buffer, s, (size_t) len); buffer[len] = '\\0';\n        s = buffer;\n    }\n    return PyInt_FromString((char *)s, NULL, 0);\n}", "item_id": 0, "repo": "Ademan/psycopg2", "file": "psycopg/typecast_basic.c", "last_update_at": "2018-03-28T16:59:52+00:00", "question_id": "e9ad527aaf0ae3e03ce6704bd4e4e01bce483611_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static PyObject *\ntypecast_INTEGER_cast(const char *s, Py_ssize_t len, PyObject *curs)\n{\n    char buffer[12];\n    if (s == NULL) {Py_INCREF(Py_None); return Py_None;}\n    if (s[len] != '\\0') {\n        strncpy(buffer, s, (size_t) len); buffer[len] = '\\0';\n        s = buffer;\n    }\n    return PyInt_FromString((char *)s, NULL, 0);\n"]]}
{"hexsha": "b7ff48652377f2e475020d1609d473a75b52013c", "ext": "c", "lang": "C", "content": "void\nemit_typecode_conversion (from, to)\n     enum typecode from, to;\n{\n  int i;\n\n  DEDUCE_CONVERSION (from, to);\n  for (i = 0; i < conversion_recipe[(int) from][(int) to].nopcodes; ++i)\n    bc_emit_instruction (conversion_recipe[(int) from][(int) to].opcodes[i]);\n}", "item_id": 2, "repo": "aaliomer/exos", "file": "bin/gcc/bc-optab.c", "last_update_at": "2018-01-23T23:07:19+00:00", "question_id": "b7ff48652377f2e475020d1609d473a75b52013c_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nemit_typecode_conversion (from, to)\n     enum typecode from, to;\n{\n  int i;\n  DEDUCE_CONVERSION (from, to);\n  for (i = 0; i < conversion_recipe[(int) from][(int) to].nopcodes; ++i)\n    bc_emit_instruction (conversion_recipe[(int) from][(int) to].opcodes[i]);\n"]]}
{"hexsha": "607734e8c18df708d48b0c15378e6575b6cfe0c8", "ext": "c", "lang": "C", "content": "int OSPPCommGetTimeout(\n    OSPTCOMM *ospvComm,\n    unsigned *ospvTimeout)\n{\n    int errorcode = OSPC_ERR_NO_ERROR;\n\n    if (ospvComm == OSPC_OSNULL) {\n        errorcode = OSPC_ERR_COMM_INVALID_ARG;\n        OSPM_DBGERRORLOG(errorcode, \"ospvComm is NULL\");\n    } else\n        *ospvTimeout = ospvComm->HttpTimeout;\n\n    return errorcode;\n}", "item_id": 6, "repo": "TransNexus/osptoolkit", "file": "src/ospcomm.c", "last_update_at": "2018-05-07T18:30:21+00:00", "question_id": "607734e8c18df708d48b0c15378e6575b6cfe0c8_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int OSPPCommGetTimeout(\n    OSPTCOMM *ospvComm,\n    unsigned *ospvTimeout)\n{\n    int errorcode = OSPC_ERR_NO_ERROR;\n    if (ospvComm == OSPC_OSNULL) {\n        errorcode = OSPC_ERR_COMM_INVALID_ARG;\n        OSPM_DBGERRORLOG(errorcode, \"ospvComm is NULL\");\n    } else\n        *ospvTimeout = ospvComm->HttpTimeout;\n    return errorcode;\n"]]}
{"hexsha": "a51cb20e5631590d58e66e9be1161734fde421e2", "ext": "c", "lang": "C", "content": "int\nxenDaemonDomainPinVcpu(virConnectPtr conn,\n                       virDomainDefPtr minidef,\n                       unsigned int vcpu,\n                       unsigned char *cpumap,\n                       int maplen)\n{\n    char buf[VIR_UUID_BUFLEN], mapstr[sizeof(cpumap_t) * 64];\n    size_t i, j;\n    int ret;\n    xenUnifiedPrivatePtr priv = conn->privateData;\n    virDomainDefPtr def = NULL;\n\n    if (maplen > (int)sizeof(cpumap_t)) {\n        virReportError(VIR_ERR_INVALID_ARG, __FUNCTION__);\n        return -1;\n    }\n\n    if (priv->xendConfigVersion < XEND_CONFIG_VERSION_3_0_4) {\n        mapstr[0] = '[';\n        mapstr[1] = 0;\n    } else {\n        mapstr[0] = 0;\n    }\n\n    /* from bit map, build character string of mapped CPU numbers */\n    for (i = 0; i < maplen; i++) for (j = 0; j < 8; j++)\n     if (cpumap[i] & (1 << j)) {\n        snprintf(buf, sizeof(buf), \"%zu,\", (8 * i) + j);\n        strcat(mapstr, buf);\n    }\n    if (priv->xendConfigVersion < XEND_CONFIG_VERSION_3_0_4)\n        mapstr[strlen(mapstr) - 1] = ']';\n    else\n        mapstr[strlen(mapstr) - 1] = 0;\n\n    snprintf(buf, sizeof(buf), \"%d\", vcpu);\n\n    ret = xend_op(conn, minidef->name, \"op\", \"pincpu\", \"vcpu\", buf,\n                  \"cpumap\", mapstr, NULL);\n\n    if (!(def = xenDaemonDomainFetch(conn,\n                                     minidef->id,\n                                     minidef->name,\n                                     NULL)))\n        goto cleanup;\n\n    if (ret == 0) {\n        if (!def->cputune.vcpupin) {\n            if (VIR_ALLOC(def->cputune.vcpupin) < 0)\n                goto cleanup;\n            def->cputune.nvcpupin = 0;\n        }\n        if (virDomainVcpuPinAdd(&def->cputune.vcpupin,\n                                &def->cputune.nvcpupin,\n                                cpumap,\n                                maplen,\n                                vcpu) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"failed to add vcpupin xml entry\"));\n            return -1;\n        }\n    }\n\n    return ret;\n\n cleanup:\n    virDomainDefFree(def);\n    return -1;\n}", "item_id": 33, "repo": "SIIS-cloud/pileus", "file": "libvirt/pileus-libvirt-1.2.12/src/xen/xend_internal.c", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "a51cb20e5631590d58e66e9be1161734fde421e2_33", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nxenDaemonDomainPinVcpu(virConnectPtr conn,\n                       virDomainDefPtr minidef,\n                       unsigned int vcpu,\n                       unsigned char *cpumap,\n                       int maplen)\n{\n    char buf[VIR_UUID_BUFLEN], mapstr[sizeof(cpumap_t) * 64];\n    size_t i, j;\n    int ret;\n    xenUnifiedPrivatePtr priv = conn->privateData;\n    virDomainDefPtr def = NULL;\n    if (maplen > (int)sizeof(cpumap_t)) {\n        virReportError(VIR_ERR_INVALID_ARG, __FUNCTION__);\n        return -1;\n    }\n    if (priv->xendConfigVersion < XEND_CONFIG_VERSION_3_0_4) {\n        mapstr[0] = '[';\n        mapstr[1] = 0;\n    } else {\n        mapstr[0] = 0;\n    }\n    /* from bit map, build character string of mapped CPU numbers */\n    for (i = 0; i < maplen; i++) for (j = 0; j < 8; j++)\n     if (cpumap[i] & (1 << j)) {\n        snprintf(buf, sizeof(buf), \"%zu,\", (8 * i) + j);\n        strcat(mapstr, buf);\n    }\n    if (priv->xendConfigVersion < XEND_CONFIG_VERSION_3_0_4)\n        mapstr[strlen(mapstr) - 1] = ']';\n    else\n        mapstr[strlen(mapstr) - 1] = 0;\n    snprintf(buf, sizeof(buf), \"%d\", vcpu);\n    ret = xend_op(conn, minidef->name, \"op\", \"pincpu\", \"vcpu\", buf,\n                  \"cpumap\", mapstr, NULL);\n    if (!(def = xenDaemonDomainFetch(conn,\n                                     minidef->id,\n                                     minidef->name,\n                                     NULL)))\n        goto cleanup;\n    if (ret == 0) {\n        if (!def->cputune.vcpupin) {\n            if (VIR_ALLOC(def->cputune.vcpupin) < 0)\n                goto cleanup;\n            def->cputune.nvcpupin = 0;\n        }\n        if (virDomainVcpuPinAdd(&def->cputune.vcpupin,\n                                &def->cputune.nvcpupin,\n                                cpumap,\n                                maplen,\n                                vcpu) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"failed to add vcpupin xml entry\"));\n            return -1;\n        }\n    }\n    return ret;\n cleanup:\n    virDomainDefFree(def);\n    return -1;\n"]]}
{"hexsha": "ac7d1c381ff1a9b1d12a048c4cfe2ca34db6f197", "ext": "h", "lang": "C", "content": "static inline void hri_aonpwrseqpwrseq_clear_AON_ST_WAKEUP_CTRL_ARM_ENABLE_bit(const void *const hw)\n{\n\tAON_PWR_SEQ_CRITICAL_SECTION_ENTER();\n\t((AonPwrSeq *)hw)->AON_ST_WAKEUP_CTRL.reg &= ~AON_PWR_SEQ_AON_ST_WAKEUP_CTRL_ARM_ENABLE_Msk;\n\tAON_PWR_SEQ_CRITICAL_SECTION_LEAVE();\n}", "item_id": 13, "repo": "Arrowana/dive-computer", "file": "Dive Computer/hri/hri_aon_pwr_seq_b11.h", "last_update_at": "2018-05-16T23:05:24+00:00", "question_id": "ac7d1c381ff1a9b1d12a048c4cfe2ca34db6f197_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void hri_aonpwrseqpwrseq_clear_AON_ST_WAKEUP_CTRL_ARM_ENABLE_bit(const void *const hw)\n{\n\tAON_PWR_SEQ_CRITICAL_SECTION_ENTER();\n\t((AonPwrSeq *)hw)->AON_ST_WAKEUP_CTRL.reg &= ~AON_PWR_SEQ_AON_ST_WAKEUP_CTRL_ARM_ENABLE_Msk;\n\tAON_PWR_SEQ_CRITICAL_SECTION_LEAVE();\n"]]}
{"hexsha": "e6d321d22988585c03ffcd9c4b6f0537b44ba5a3", "ext": "h", "lang": "C", "content": "class CEDFileSelector : public CGUIFileBrowser\r\n{\r\npublic:\r\n\tCEDFileSelector(float _x, float _y, float _sx, float _sy, char* path=\"$GAME$\", char* label=\"GAME:\");\r\n\tvirtual ~CEDFileSelector();\r\n\r\n\tint filterExt;\t// pouze jake pripony se budou zobrazovat\t(viz. KerServices.h - eEXTensions)\r\n\r\n\tstatic int Compare(CGUITreeItem *aa, CGUITreeItem *bb);\t// setridi: nejdriv adresare, potom levely\r\n\tstatic int CompareLevelDIR(CGUITreeItem *aa, CGUITreeItem *bb);\t// setridi: nejdriv adresare, potom levely, potom ostatni soubory\r\nprotected:\r\n\r\n\tvirtual int TreeHandler(typeID treeItem, int index, int state);\t// nepouzito\r\n\tvirtual int Filter(CGUITreeItem* parent, const char *name, int dir, int first);\t// nepouzito\r\n\tvirtual CGUIFileBrowserItem* AddItem(CGUIFileBrowserItem* fbi, const char* name, int dir);\r\n\t\t// pridavani polozek podle jejich typu voli ikonu, atp.\r\n\r\n\tvirtual int Keyboard(UINT character, UINT state);\t// zarizuje zavreni okna po vyberu polozky\r\n}", "item_id": 1, "repo": "HonzaMD/Krkal2", "file": "src/Editor/editorMenu.h", "last_update_at": "2018-04-01T16:47:52+00:00", "question_id": "e6d321d22988585c03ffcd9c4b6f0537b44ba5a3_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class CEDFileSelector : public CGUIFileBrowser\r\n{\r\npublic:\r\n\tCEDFileSelector(float _x, float _y, float _sx, float _sy, char* path=\"$GAME$\", char* label=\"GAME:\");\r\n\tvirtual ~CEDFileSelector();\r\n\r\n\tint filterExt;\t// pouze jake pripony se budou zobrazovat\t(viz. KerServices.h - eEXTensions)\r\n\r\n\tstatic int Compare(CGUITreeItem *aa, CGUITreeItem *bb);\t// setridi: nejdriv adresare, potom levely\r\n\tstatic int CompareLevelDIR(CGUITreeItem *aa, CGUITreeItem *bb);\t// setridi: nejdriv adresare, potom levely, potom ostatni soubory\r\nprotected:\r\n\r\n\tvirtual int TreeHandler(typeID treeItem, int index, int state);\t// nepouzito\r\n\tvirtual int Filter(CGUITreeItem* parent, const char *name, int dir, int first);\t// nepouzito\r\n\tvirtual CGUIFileBrowserItem* AddItem(CGUIFileBrowserItem* fbi, const char* name, int dir);\r\n\t\t// pridavani polozek podle jejich typu voli ikonu, atp.\r\n\r\n\tvirtual int Keyboard(UINT character, UINT state);\t// zarizuje zavreni okna po vyberu polozky\r\n"]]}
{"hexsha": "2ae35d143583022965327b11b8aabd9044caef9e", "ext": "c", "lang": "C", "content": "static void\nmgaScreenFini (KdScreenInfo *screen)\n{\n    MgaScreenInfo *mgas = (MgaScreenInfo *) screen->driver;\n\n    vesaScreenFini (screen);\n    xfree (mgas);\n    screen->driver = 0;\n}", "item_id": 7, "repo": "larsclausen/xglamo", "file": "hw/kdrive/mga/mga.c", "last_update_at": "2018-11-01T06:58:35+00:00", "question_id": "2ae35d143583022965327b11b8aabd9044caef9e_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nmgaScreenFini (KdScreenInfo *screen)\n{\n    MgaScreenInfo *mgas = (MgaScreenInfo *) screen->driver;\n    vesaScreenFini (screen);\n    xfree (mgas);\n    screen->driver = 0;\n"]]}
{"hexsha": "d70d925d8edfce36b50331ebabef78a01c90528e", "ext": "c", "lang": "C", "content": "void RCC_Configuration(void)\n{\n    /* Enable peripheral clocks */\n    /* Enable DMA1 clock */\n    RCC_AHBPeriphClock_Enable(RCC_AHBPERIPH_DMA1, ENABLE);\n\n}", "item_id": 2, "repo": "zdh19890814/LiteOS_Kernel", "file": "platform/GD32F103VCT6/Library/Example/DMA/FLASH-RAM/main.c", "last_update_at": "2018-10-18T03:18:39+00:00", "question_id": "d70d925d8edfce36b50331ebabef78a01c90528e_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void RCC_Configuration(void)\n{\n    /* Enable peripheral clocks */\n    /* Enable DMA1 clock */\n    RCC_AHBPeriphClock_Enable(RCC_AHBPERIPH_DMA1, ENABLE);\n"]]}
{"hexsha": "fe5535ad54bf468756a35ecb6de17b26be4d3057", "ext": "c", "lang": "C", "content": "void TDF_PS_PK_free(TDF_PS_PK *pk) {\n\tif (pk == NULL) {\n\t\treturn;\n\t}\n\tBN_free(pk->n);\n\tBN_free(pk->halfn);\n\tOPENSSL_free(pk);\n}", "item_id": 0, "repo": "dstebila/daps", "file": "tdf_ps.c", "last_update_at": "2018-01-08T17:28:09+00:00", "question_id": "fe5535ad54bf468756a35ecb6de17b26be4d3057_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void TDF_PS_PK_free(TDF_PS_PK *pk) {\n\tif (pk == NULL) {\n\t\treturn;\n\t}\n\tBN_free(pk->n);\n\tBN_free(pk->halfn);\n\tOPENSSL_free(pk);\n"]]}
{"hexsha": "b73e87256982933d096078c5b2655e5361bf94f8", "ext": "c", "lang": "C", "content": "uint8_t w3d_Map_GetValue(w3d_Map* map, int x, int y) {\n\tassert(map != NULL);\n\tuint8_t* value = map->dataWall+((x*map->width)+y); \n\treturn *value;\n}", "item_id": 2, "repo": "ftraple/WolfensteinEngine", "file": "source/Map.c", "last_update_at": "2018-10-03T10:41:13+00:00", "question_id": "b73e87256982933d096078c5b2655e5361bf94f8_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["uint8_t w3d_Map_GetValue(w3d_Map* map, int x, int y) {\n\tassert(map != NULL);\n\tuint8_t* value = map->dataWall+((x*map->width)+y); \n\treturn *value;\n"]]}
{"hexsha": "48f3245153a7d88830fdc5d78cee3561f1d6edeb", "ext": "c", "lang": "C", "content": "int recordTime(char *time_str) {\n  time_t timer;\n  struct tm time_struct;\n\n  timer = time(NULL);\n  localtime_r(&timer, &time_struct);\n\n  // TIME_FORMAT == \"%Y-%m-%d %H:%M:%S\" == \"yyyy-mm-dd HH:mm:ss\"\n  strftime(time_str, TIME_STR_LEN, TIME_FORMAT, &time_struct);\n\n  return 0;\n}", "item_id": 3, "repo": "Ghost-in-the-Bash/sslsplit", "file": "netgrok.c", "last_update_at": "2018-11-27T15:51:16+00:00", "question_id": "48f3245153a7d88830fdc5d78cee3561f1d6edeb_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int recordTime(char *time_str) {\n  time_t timer;\n  struct tm time_struct;\n  timer = time(NULL);\n  localtime_r(&timer, &time_struct);\n  // TIME_FORMAT == \"%Y-%m-%d %H:%M:%S\" == \"yyyy-mm-dd HH:mm:ss\"\n  strftime(time_str, TIME_STR_LEN, TIME_FORMAT, &time_struct);\n  return 0;\n"]]}
{"hexsha": "d94c67fed9b7ac99fdd48fbbef4055dac9fe7c0c", "ext": "h", "lang": "C", "content": "interface UIDocumentPickerViewController : UIViewController <_UIDocumentPickerRemoteViewControllerContaining> {\n\n\tid<UIDocumentPickerDelegate> _weak_delegate;\n\tBOOL _ignoreApplicationEntitlementForImport;\n\tBOOL _sourceIsManaged;\n\tid<UIDocumentPickerDelegate> _delegate;\n\tunsigned long long _documentPickerMode;\n\t_UIResilientRemoteViewContainerViewController* _childViewController;\n\t_UIRemoteViewService* _remoteViewService;\n\tNSURL* _uploadURL;\n\n}", "item_id": 0, "repo": "lechium/tvOS10Headers", "file": "System/Library/Frameworks/UIKit.framework/UIDocumentPickerViewController.h", "last_update_at": "2018-08-04T20:16:32+00:00", "question_id": "d94c67fed9b7ac99fdd48fbbef4055dac9fe7c0c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface UIDocumentPickerViewController : UIViewController <_UIDocumentPickerRemoteViewControllerContaining> {\n\tid<UIDocumentPickerDelegate> _weak_delegate;\n\tBOOL _ignoreApplicationEntitlementForImport;\n\tBOOL _sourceIsManaged;\n\tid<UIDocumentPickerDelegate> _delegate;\n\tunsigned long long _documentPickerMode;\n\t_UIResilientRemoteViewContainerViewController* _childViewController;\n\t_UIRemoteViewService* _remoteViewService;\n\tNSURL* _uploadURL;\n"]]}
{"hexsha": "925706c7558daa5e3c4c508659d201d0ddf3885a", "ext": "c", "lang": "C", "content": "const struct exec_info *get_exec_info(const struct exec_info *exec_infos,\n\t\t\t\t      const char *arg0)\n{\n\tconst char *name = path_base(arg0);\n\tconst struct exec_info *ret = NULL;\n\n\tfor (size_t i = 0; exec_infos[i].name != NULL; ++i) {\n\t\t// Exact matches always come first\n\t\tif (strcmp(name, exec_infos[i].name) == 0)\n\t\t\treturn &exec_infos[i];\n\n\t\t// Fallback to {exe}.{type} matching\n\t\tconst size_t name_len = strlen(name);\n\t\tif (name_len > strlen(exec_infos[i].name))\n\t\t\tcontinue;\n\t\tif (exec_infos[i].name[name_len] != '.')\n\t\t\tcontinue;\n\t\tif (strncmp(name, exec_infos[i].name, name_len) != 0)\n\t\t\tcontinue;\n\t\tif (ret == NULL || ret->prefer < exec_infos[i].prefer)\n\t\t\tret = &exec_infos[i];\n\t}\n\n\treturn ret;\n}", "item_id": 1, "repo": "wkennington/cc-wrapper", "file": "src/execinfo.c", "last_update_at": "2018-11-30T04:32:07+00:00", "question_id": "925706c7558daa5e3c4c508659d201d0ddf3885a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["const struct exec_info *get_exec_info(const struct exec_info *exec_infos,\n\t\t\t\t      const char *arg0)\n{\n\tconst char *name = path_base(arg0);\n\tconst struct exec_info *ret = NULL;\n\tfor (size_t i = 0; exec_infos[i].name != NULL; ++i) {\n\t\t// Exact matches always come first\n\t\tif (strcmp(name, exec_infos[i].name) == 0)\n\t\t\treturn &exec_infos[i];\n\t\t// Fallback to {exe}.{type} matching\n\t\tconst size_t name_len = strlen(name);\n\t\tif (name_len > strlen(exec_infos[i].name))\n\t\t\tcontinue;\n\t\tif (exec_infos[i].name[name_len] != '.')\n\t\t\tcontinue;\n\t\tif (strncmp(name, exec_infos[i].name, name_len) != 0)\n\t\t\tcontinue;\n\t\tif (ret == NULL || ret->prefer < exec_infos[i].prefer)\n\t\t\tret = &exec_infos[i];\n\t}\n\treturn ret;\n"]]}
{"hexsha": "333231c508fa3033cf5491ed4647ab6d1aa7be86", "ext": "c", "lang": "C", "content": "static jboolean\nPCPathDone(PathConsumerVec *consumer)\n{\n    pathData *pd = (pathData *) consumer;\n    jboolean oom = JNI_FALSE;\n\n    HANDLEENDPATH(pd, {oom = JNI_TRUE;});\n\n    return oom;\n}", "item_id": 24, "repo": "siweilxy/openjdkstudy", "file": "src/java.desktop/share/native/libawt/java2d/pipe/ShapeSpanIterator.c", "last_update_at": "2018-06-23T10:04:56+00:00", "question_id": "333231c508fa3033cf5491ed4647ab6d1aa7be86_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static jboolean\nPCPathDone(PathConsumerVec *consumer)\n{\n    pathData *pd = (pathData *) consumer;\n    jboolean oom = JNI_FALSE;\n    HANDLEENDPATH(pd, {oom = JNI_TRUE;});\n    return oom;\n"]]}
{"hexsha": "aa59444ad530b940e0f4ef33b94ee6b1ab47d5aa", "ext": "c", "lang": "C", "content": "int\tosd_path_split(const char *path, char dir[], char file[], int size)\n{\n    int pos = strlen(path);\n\n    /* dir, file \u306f\u5341\u5206\u306a\u30b5\u30a4\u30ba\u3092\u78ba\u4fdd\u3057\u3066\u3044\u308b\u306f\u305a\u306a\u306e\u3067\u3001\u8efd\u304f\u30c1\u30a7\u30c3\u30af */\n    if (pos == 0 || size <= pos) {\n\tdir[0]  = '\\0';\n\tfile[0] = '\\0';\n\tstrncat(file, path, size-1);\n\tif (pos) fprintf(stderr, \"internal overflow %d\\n\", __LINE__);\n\treturn FALSE;\n    }\n\n\n    if (strcmp(path, \"/\") == 0) {\t/* \"/\" \u306e\u5834\u5408\u3001\u5225\u51e6\u7406\t*/\n\tstrcpy(dir, \"/\");\t\t\t/* \u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306f \"/\"\t*/\n\tstrcpy(file, \"\");\t\t\t/* \u30d5\u30a1\u30a4\u30eb\u306f \"\"\t*/\n\treturn TRUE;\n    }\n\n    if (path[ pos - 1 ] == '/') {\t/* path \u672b\u5c3e\u306e / \u306f\u7121\u8996\t*/\n\tpos --;\n    }\n\n    do {\t\t\t\t/* / \u3092\u672b\u5c3e\u304b\u3089\u63a2\u3059\t*/\n\tif (path[ pos - 1 ] == '/') { break; }\n\tpos --;\n    } while (pos);\n\n    if (pos) {\t\t\t\t/* / \u304c\u898b\u3064\u304b\u3063\u305f\u3089\t*/\n\tstrncpy(dir, path, pos);\t\t/* \u5148\u982d\u301c / \u307e\u3067\u3092\u30b3\u30d4\u30fc*/\n\tif (pos > 1)\n\t    dir[ pos - 1 ] = '\\0';\t\t/* \u672b\u5c3e\u306e / \u306f\u524a\u9664\u3059\u308b\t*/\n\telse\t\t\t\t\t/* \u305f\u3060\u3057\t\t*/ \n\t    dir[ pos ] = '\\0';\t\t\t/* \"/\"\u306e\u5834\u5408\u306f / \u306f\u6b8b\u3059 */\n\n\tstrcpy(file, &path[pos]);\n\n    } else {\t\t\t\t/* / \u304c\u898b\u3064\u304b\u3089\u306a\u304b\u3063\u305f\t*/\n\tstrcpy(dir,  \"\");\t\t\t/* \u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306f \"\"\t*/\n\tstrcpy(file, path);\t\t\t/* \u30d5\u30a1\u30a4\u30eb\u306f path\u5168\u3066\t*/\n    }\n\n    pos = strlen(file);\t\t\t/* \u30d5\u30a1\u30a4\u30eb\u672b\u5c3e\u306e / \u306f\u524a\u9664 */\n    if (pos && file[ pos - 1 ] == '/') { \n\tfile[ pos - 1 ] = '\\0';\n    }\n\n    /*printf(\"SPLT:\\\"%s\\\" = \\\"%s\\\" + \\\"%s\\\")\\n\",path,dir,file);*/\n    return TRUE;\n}", "item_id": 7, "repo": "liberodark/quasi88-libretro", "file": "src/FUNIX/file-op.c", "last_update_at": "2018-09-16T23:47:02+00:00", "question_id": "aa59444ad530b940e0f4ef33b94ee6b1ab47d5aa_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\tosd_path_split(const char *path, char dir[], char file[], int size)\n{\n    int pos = strlen(path);\n    /* dir, file \u306f\u5341\u5206\u306a\u30b5\u30a4\u30ba\u3092\u78ba\u4fdd\u3057\u3066\u3044\u308b\u306f\u305a\u306a\u306e\u3067\u3001\u8efd\u304f\u30c1\u30a7\u30c3\u30af */\n    if (pos == 0 || size <= pos) {\n\tdir[0]  = '\\0';\n\tfile[0] = '\\0';\n\tstrncat(file, path, size-1);\n\tif (pos) fprintf(stderr, \"internal overflow %d\\n\", __LINE__);\n\treturn FALSE;\n    }\n    if (strcmp(path, \"/\") == 0) {\t/* \"/\" \u306e\u5834\u5408\u3001\u5225\u51e6\u7406\t*/\n\tstrcpy(dir, \"/\");\t\t\t/* \u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306f \"/\"\t*/\n\tstrcpy(file, \"\");\t\t\t/* \u30d5\u30a1\u30a4\u30eb\u306f \"\"\t*/\n\treturn TRUE;\n    }\n    if (path[ pos - 1 ] == '/') {\t/* path \u672b\u5c3e\u306e / \u306f\u7121\u8996\t*/\n\tpos --;\n    }\n    do {\t\t\t\t/* / \u3092\u672b\u5c3e\u304b\u3089\u63a2\u3059\t*/\n\tif (path[ pos - 1 ] == '/') { break; }\n\tpos --;\n    } while (pos);\n    if (pos) {\t\t\t\t/* / \u304c\u898b\u3064\u304b\u3063\u305f\u3089\t*/\n\tstrncpy(dir, path, pos);\t\t/* \u5148\u982d\u301c / \u307e\u3067\u3092\u30b3\u30d4\u30fc*/\n\tif (pos > 1)\n\t    dir[ pos - 1 ] = '\\0';\t\t/* \u672b\u5c3e\u306e / \u306f\u524a\u9664\u3059\u308b\t*/\n\telse\t\t\t\t\t/* \u305f\u3060\u3057\t\t*/ \n\t    dir[ pos ] = '\\0';\t\t\t/* \"/\"\u306e\u5834\u5408\u306f / \u306f\u6b8b\u3059 */\n\tstrcpy(file, &path[pos]);\n    } else {\t\t\t\t/* / \u304c\u898b\u3064\u304b\u3089\u306a\u304b\u3063\u305f\t*/\n\tstrcpy(dir,  \"\");\t\t\t/* \u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306f \"\"\t*/\n\tstrcpy(file, path);\t\t\t/* \u30d5\u30a1\u30a4\u30eb\u306f path\u5168\u3066\t*/\n    }\n    pos = strlen(file);\t\t\t/* \u30d5\u30a1\u30a4\u30eb\u672b\u5c3e\u306e / \u306f\u524a\u9664 */\n    if (pos && file[ pos - 1 ] == '/') { \n\tfile[ pos - 1 ] = '\\0';\n    }\n    /*printf(\"SPLT:\\\"%s\\\" = \\\"%s\\\" + \\\"%s\\\")\\n\",path,dir,file);*/\n    return TRUE;\n"]]}
{"hexsha": "17c48ea0d85bb127f7584855f9fabb1eb56b95a7", "ext": "c", "lang": "C", "content": "static enum cmd_status cmd_decrypto_3des_exec(char *cmd)\n{\n\tint32_t cnt;\n\tchar mode_str[8];\n\tchar key_str[25];\n\tchar *cipher_str;\n\tuint8_t *plain_buf;\n\tuint8_t *cipher_buf;\n\tint8_t key_len = 0;\n\tuint32_t cipher_len = 0;\n\tCE_3DES_Config des_cfg;\n    enum cmd_status ret = CMD_STATUS_ACKED;\n\n    cipher_str = (char*)cmd_malloc(CE_CIPHER_MAX_LEN);\n    if(cipher_str == NULL) {\n        CMD_ERR(\"malloc failed\\n\");\n        ret = CMD_STATUS_FAIL;\n        goto out_cipher;\n    }\n\n\t/* get param */\n\tcnt = cmd_sscanf(cmd, \"m=%7s k=%s c=%s\", mode_str, key_str, cipher_str);\n\n\t/* check param */\n\tif (cnt != 3) {\n\t\tCMD_ERR(\"invalid param number %d\\n\", cnt);\n\t\tret = CMD_STATUS_INVALID_ARG;\n        goto out_cipher;\n\t}\n\tmemset(&des_cfg, 0, sizeof(des_cfg));\n\tif (cmd_strcmp(mode_str, \"ecb\") == 0) {\n\t\tdes_cfg.mode = CE_CRYPT_MODE_ECB;\n\t} else if (cmd_strcmp(mode_str, \"cbc\") == 0) {\n\t\tdes_cfg.mode = CE_CRYPT_MODE_CBC;\n\t} else {\n\t\tCMD_ERR(\"invalid mode %s\\n\", mode_str);\n\t\tret = CMD_STATUS_INVALID_ARG;\n        goto out_cipher;\n\t}\n\n\tkey_len = cmd_strlen(key_str);\n\tif(24 != key_len) {\n\t\tCMD_ERR(\"invalid param:  key len %d != 24\\n\", key_len);\n\t\tret = CMD_STATUS_INVALID_ARG;\n        goto out_cipher;\n\t}\n\tdes_cfg.src = CE_CTL_KEYSOURCE_INPUT;\n\tmemcpy(des_cfg.key, key_str, key_len);\n\tcipher_len = cmd_strlen(cipher_str);\n\tcipher_len = cipher_len >> 1;\n\tcipher_buf = (uint8_t*)cmd_malloc(cipher_len);\n\tcipher_str_to_arr(cipher_str, cipher_buf);\n\tplain_buf = (uint8_t*)cmd_malloc(cipher_len);\n\tif(HAL_3DES_Decrypt(&des_cfg, (uint8_t*)cipher_buf, (uint8_t*)plain_buf, cipher_len) != HAL_OK) {\n\t\tCMD_ERR(\"3DES encrypt failed\\n\");\n\t\tret =  CMD_STATUS_FAIL;\n        goto out_plain;\n\t}\n\tprintf(\"plaintest:\");\n\tcmd_raw_mode_enable();\n\tcmd_raw_mode_write(plain_buf, cipher_len);\n\tcmd_raw_mode_disable();\n\tprintf(\"\\n\\n\");\n\nout_plain:\n    cmd_free(cipher_buf);\n    cmd_free(plain_buf);\nout_cipher:\n    cmd_free(cipher_str);\n    return ret;\n}", "item_id": 5, "repo": "HelloAllen8893/AliOS-Things", "file": "platform/mcu/xr872/drivers/project/common/cmd/cmd_ce.c", "last_update_at": "2018-11-28T03:19:22+00:00", "question_id": "17c48ea0d85bb127f7584855f9fabb1eb56b95a7_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static enum cmd_status cmd_decrypto_3des_exec(char *cmd)\n{\n\tint32_t cnt;\n\tchar mode_str[8];\n\tchar key_str[25];\n\tchar *cipher_str;\n\tuint8_t *plain_buf;\n\tuint8_t *cipher_buf;\n\tint8_t key_len = 0;\n\tuint32_t cipher_len = 0;\n\tCE_3DES_Config des_cfg;\n    enum cmd_status ret = CMD_STATUS_ACKED;\n    cipher_str = (char*)cmd_malloc(CE_CIPHER_MAX_LEN);\n    if(cipher_str == NULL) {\n        CMD_ERR(\"malloc failed\\n\");\n        ret = CMD_STATUS_FAIL;\n        goto out_cipher;\n    }\n\t/* get param */\n\tcnt = cmd_sscanf(cmd, \"m=%7s k=%s c=%s\", mode_str, key_str, cipher_str);\n\t/* check param */\n\tif (cnt != 3) {\n\t\tCMD_ERR(\"invalid param number %d\\n\", cnt);\n\t\tret = CMD_STATUS_INVALID_ARG;\n        goto out_cipher;\n\t}\n\tmemset(&des_cfg, 0, sizeof(des_cfg));\n\tif (cmd_strcmp(mode_str, \"ecb\") == 0) {\n\t\tdes_cfg.mode = CE_CRYPT_MODE_ECB;\n\t} else if (cmd_strcmp(mode_str, \"cbc\") == 0) {\n\t\tdes_cfg.mode = CE_CRYPT_MODE_CBC;\n\t} else {\n\t\tCMD_ERR(\"invalid mode %s\\n\", mode_str);\n\t\tret = CMD_STATUS_INVALID_ARG;\n        goto out_cipher;\n\t}\n\tkey_len = cmd_strlen(key_str);\n\tif(24 != key_len) {\n\t\tCMD_ERR(\"invalid param:  key len %d != 24\\n\", key_len);\n\t\tret = CMD_STATUS_INVALID_ARG;\n        goto out_cipher;\n\t}\n\tdes_cfg.src = CE_CTL_KEYSOURCE_INPUT;\n\tmemcpy(des_cfg.key, key_str, key_len);\n\tcipher_len = cmd_strlen(cipher_str);\n\tcipher_len = cipher_len >> 1;\n\tcipher_buf = (uint8_t*)cmd_malloc(cipher_len);\n\tcipher_str_to_arr(cipher_str, cipher_buf);\n\tplain_buf = (uint8_t*)cmd_malloc(cipher_len);\n\tif(HAL_3DES_Decrypt(&des_cfg, (uint8_t*)cipher_buf, (uint8_t*)plain_buf, cipher_len) != HAL_OK) {\n\t\tCMD_ERR(\"3DES encrypt failed\\n\");\n\t\tret =  CMD_STATUS_FAIL;\n        goto out_plain;\n\t}\n\tprintf(\"plaintest:\");\n\tcmd_raw_mode_enable();\n\tcmd_raw_mode_write(plain_buf, cipher_len);\n\tcmd_raw_mode_disable();\n\tprintf(\"\\n\\n\");\nout_plain:\n    cmd_free(cipher_buf);\n    cmd_free(plain_buf);\nout_cipher:\n    cmd_free(cipher_str);\n    return ret;\n"]]}
{"hexsha": "428a5c9457d7574e03b03de7b267e80bff3f2e26", "ext": "c", "lang": "C", "content": "void vmx_update_debug_state(struct vcpu *v)\n{\n    unsigned long mask;\n\n    ASSERT(v == current);\n\n    mask = 1u << TRAP_int3;\n    if ( !cpu_has_monitor_trap_flag )\n        mask |= 1u << TRAP_debug;\n\n    if ( v->arch.hvm_vcpu.debug_state_latch )\n        v->arch.hvm_vmx.exception_bitmap |= mask;\n    else\n        v->arch.hvm_vmx.exception_bitmap &= ~mask;\n    vmx_update_exception_bitmap(v);\n}", "item_id": 29, "repo": "zhiming-shen/Xen-Blanket-NG", "file": "xen/xen-4.2.2/xen/arch/x86/hvm/vmx/vmx.c", "last_update_at": "2018-02-02T00:15:26+00:00", "question_id": "428a5c9457d7574e03b03de7b267e80bff3f2e26_29", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void vmx_update_debug_state(struct vcpu *v)\n{\n    unsigned long mask;\n    ASSERT(v == current);\n    mask = 1u << TRAP_int3;\n    if ( !cpu_has_monitor_trap_flag )\n        mask |= 1u << TRAP_debug;\n    if ( v->arch.hvm_vcpu.debug_state_latch )\n        v->arch.hvm_vmx.exception_bitmap |= mask;\n    else\n        v->arch.hvm_vmx.exception_bitmap &= ~mask;\n    vmx_update_exception_bitmap(v);\n"]]}
{"hexsha": "2a824f95e117a6a79ab2516dacaab3dc31cfad35", "ext": "h", "lang": "C", "content": "static inline u32\ninl (u16 port)\n{\n  port_io_args args = { POKE_SIGNATURE, port, sizeof(u32), 0 };\n  if (ioctl(poke_driver_fd, POKE_PORT_READ, &args, sizeof(args)) < 0)\n    return 0;\n  return (u32)args.value;\n}", "item_id": 2, "repo": "Cwndmiao/downloadfile", "file": "sdk/mgmt_tool/third_party/pciutils/lib/i386-io-haiku.h", "last_update_at": "2018-11-14T03:56:42+00:00", "question_id": "2a824f95e117a6a79ab2516dacaab3dc31cfad35_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline u32\ninl (u16 port)\n{\n  port_io_args args = { POKE_SIGNATURE, port, sizeof(u32), 0 };\n  if (ioctl(poke_driver_fd, POKE_PORT_READ, &args, sizeof(args)) < 0)\n    return 0;\n  return (u32)args.value;\n"]]}
{"hexsha": "ec9a327c7e46d6d141f24f194b60533824ec5a4f", "ext": "c", "lang": "C", "content": "static int\nrestart_world (void)\n{\n\tint count, i;\n\tSgenThreadInfo *info;\n\tTV_DECLARE (end_sw);\n\tunsigned long usec;\n\n\tfor (i = 0; i < THREAD_HASH_SIZE; ++i) {\n\t\tfor (info = thread_table [i]; info; info = info->next) {\n\t\t\tinfo->stack_start = NULL;\n\t\t\tinfo->stopped_regs = NULL;\n\t\t}\n\t}\n\n\tcount = thread_handshake (restart_signal_num);\n\tTV_GETTIME (end_sw);\n\tusec = TV_ELAPSED (stop_world_time, end_sw);\n\tmax_pause_usec = MAX (usec, max_pause_usec);\n\tDEBUG (2, fprintf (gc_debug_file, \"restarted %d thread(s) (pause time: %d usec, max: %d)\\n\", count, (int)usec, (int)max_pause_usec));\n\treturn count;\n}", "item_id": 83, "repo": "zlxy/Genesis-3D", "file": "Engine/extlibs/IosLibs/mono-2.6.7/mono/metadata/sgen-gc.c", "last_update_at": "2018-09-30T23:46:57+00:00", "question_id": "ec9a327c7e46d6d141f24f194b60533824ec5a4f_83", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nrestart_world (void)\n{\n\tint count, i;\n\tSgenThreadInfo *info;\n\tTV_DECLARE (end_sw);\n\tunsigned long usec;\n\tfor (i = 0; i < THREAD_HASH_SIZE; ++i) {\n\t\tfor (info = thread_table [i]; info; info = info->next) {\n\t\t\tinfo->stack_start = NULL;\n\t\t\tinfo->stopped_regs = NULL;\n\t\t}\n\t}\n\tcount = thread_handshake (restart_signal_num);\n\tTV_GETTIME (end_sw);\n\tusec = TV_ELAPSED (stop_world_time, end_sw);\n\tmax_pause_usec = MAX (usec, max_pause_usec);\n\tDEBUG (2, fprintf (gc_debug_file, \"restarted %d thread(s) (pause time: %d usec, max: %d)\\n\", count, (int)usec, (int)max_pause_usec));\n\treturn count;\n"]]}
{"hexsha": "8de8a1b9c31024d009a1f11b0a4fee426c49e677", "ext": "c", "lang": "C", "content": "static void shell_cp( int argc, char **argv )\n{\n  FILE *fps = NULL, *fpd = NULL;\n  void *buf = NULL;\n  size_t datalen, datawrote, total = 0;\n\n  if( argc != 3 )\n  {\n    printf( \"Usage: cp <source> <destination>\\n\" );\n    return;\n  }\n  if( ( fps = fopen( argv[ 1 ], \"rb\" ) ) == NULL )\n    printf( \"Unable to open %s for reading\\n\", argv[ 1 ] );\n  else\n  {\n    if( ( fpd = fopen( argv[ 2 ], \"wb\" ) ) == NULL )\n      printf( \"Unable to open %s for writing\\n\", argv[ 2 ] );\n    else\n    {\n      // Alloc memory\n      if( ( buf = malloc( SHELL_COPY_BUFSIZE ) ) == NULL )\n        printf( \"Not enough memory\\n\" );\n      else\n      {\n        // Do the actual copy\n        while( 1 )\n        {\n          datalen = fread( buf, 1, SHELL_COPY_BUFSIZE, fps );\n          datawrote = fwrite( buf, 1, datalen, fpd );\n          if( datawrote < datalen )\n          {\n            printf( \"Copy error (no space left on target?)\\n\" );\n            break;\n          }\n          total += datalen;\n          if( datalen < SHELL_COPY_BUFSIZE )\n            break;\n        }\n        fflush( fpd );\n        printf( \"%u bytes copied\\n\", ( unsigned int )total );\n      }\n    }\n  }\n  if( fps )\n    fclose( fps );\n  if( fpd )\n    fclose( fpd );\n  if( buf )\n    free( buf );\n}", "item_id": 6, "repo": "dz0ny/Cheerlights", "file": "src/shell.c", "last_update_at": "2018-01-20T13:42:13+00:00", "question_id": "8de8a1b9c31024d009a1f11b0a4fee426c49e677_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void shell_cp( int argc, char **argv )\n{\n  FILE *fps = NULL, *fpd = NULL;\n  void *buf = NULL;\n  size_t datalen, datawrote, total = 0;\n  if( argc != 3 )\n  {\n    printf( \"Usage: cp <source> <destination>\\n\" );\n    return;\n  }\n  if( ( fps = fopen( argv[ 1 ], \"rb\" ) ) == NULL )\n    printf( \"Unable to open %s for reading\\n\", argv[ 1 ] );\n  else\n  {\n    if( ( fpd = fopen( argv[ 2 ], \"wb\" ) ) == NULL )\n      printf( \"Unable to open %s for writing\\n\", argv[ 2 ] );\n    else\n    {\n      // Alloc memory\n      if( ( buf = malloc( SHELL_COPY_BUFSIZE ) ) == NULL )\n        printf( \"Not enough memory\\n\" );\n      else\n      {\n        // Do the actual copy\n        while( 1 )\n        {\n          datalen = fread( buf, 1, SHELL_COPY_BUFSIZE, fps );\n          datawrote = fwrite( buf, 1, datalen, fpd );\n          if( datawrote < datalen )\n          {\n            printf( \"Copy error (no space left on target?)\\n\" );\n            break;\n          }\n          total += datalen;\n          if( datalen < SHELL_COPY_BUFSIZE )\n            break;\n        }\n        fflush( fpd );\n        printf( \"%u bytes copied\\n\", ( unsigned int )total );\n      }\n    }\n  }\n  if( fps )\n    fclose( fps );\n  if( fpd )\n    fclose( fpd );\n  if( buf )\n    free( buf );\n"]]}
{"hexsha": "6e1db8554c1eb81709bba7f8c8f212d1d50ca0e9", "ext": "c", "lang": "C", "content": "void set_current_particle_texture(ParticleSettings *part, Tex *newtex)\n{\n\tint act = part->texact;\n\n\tif (part->mtex[act] && part->mtex[act]->tex)\n\t\tid_us_min(&part->mtex[act]->tex->id);\n\n\tif (newtex) {\n\t\tif (!part->mtex[act]) {\n\t\t\tpart->mtex[act] = BKE_texture_mtex_add();\n\t\t\tpart->mtex[act]->texco = TEXCO_ORCO;\n\t\t\tpart->mtex[act]->blendtype = MTEX_MUL;\n\t\t}\n\t\t\n\t\tpart->mtex[act]->tex = newtex;\n\t\tid_us_plus(&newtex->id);\n\t}\n\telse if (part->mtex[act]) {\n\t\tMEM_freeN(part->mtex[act]);\n\t\tpart->mtex[act] = NULL;\n\t}\n}", "item_id": 32, "repo": "1-MillionParanoidTterabytes/Blender-2.79b-blackened", "file": "source/blender/blenkernel/intern/texture.c", "last_update_at": "2018-06-18T01:50:32+00:00", "question_id": "6e1db8554c1eb81709bba7f8c8f212d1d50ca0e9_32", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void set_current_particle_texture(ParticleSettings *part, Tex *newtex)\n{\n\tint act = part->texact;\n\tif (part->mtex[act] && part->mtex[act]->tex)\n\t\tid_us_min(&part->mtex[act]->tex->id);\n\tif (newtex) {\n\t\tif (!part->mtex[act]) {\n\t\t\tpart->mtex[act] = BKE_texture_mtex_add();\n\t\t\tpart->mtex[act]->texco = TEXCO_ORCO;\n\t\t\tpart->mtex[act]->blendtype = MTEX_MUL;\n\t\t}\n\t\t\n\t\tpart->mtex[act]->tex = newtex;\n\t\tid_us_plus(&newtex->id);\n\t}\n\telse if (part->mtex[act]) {\n\t\tMEM_freeN(part->mtex[act]);\n\t\tpart->mtex[act] = NULL;\n\t}\n"]]}
{"hexsha": "15c90ec3cf839205ea51ea962251a9b87ffa7e7f", "ext": "c", "lang": "C", "content": "static int acquire_mutex(DDP_SCENARIO_ENUM scenario)\n{\n/* /: primay use mutex 0 */\n\tint mutex_id = 0;\n\tDDP_MANAGER_CONTEXT *content = _get_context();\n\tint mutex_idx_free = content->mutex_idx;\n\n\tASSERT(scenario >= 0 && scenario < DDP_SCENARIO_MAX);\n\twhile (mutex_idx_free) {\n\t\tif (mutex_idx_free & 0x1) {\n\t\t\tcontent->mutex_idx &= (~(0x1 << mutex_id));\n\t\t\tmutex_id += DISP_MUTEX_DDP_FIRST;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_idx_free >>= 1;\n\t\t++mutex_id;\n\t}\n\tASSERT(mutex_id < (DISP_MUTEX_DDP_FIRST + DISP_MUTEX_DDP_COUNT));\n\tDISP_LOG_I(\"scenario %s acquire mutex %d , left mutex 0x%x!\\n\",\n\t\t   ddp_get_scenario_name(scenario), mutex_id, content->mutex_idx);\n\treturn mutex_id;\n}", "item_id": 7, "repo": "fuldaros/paperplane_kernel_wileyfox-spark", "file": "sources/drivers/misc/mediatek/video/mt6735/dispsys/ddp_manager.c", "last_update_at": "2018-04-01T07:58:39+00:00", "question_id": "15c90ec3cf839205ea51ea962251a9b87ffa7e7f_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int acquire_mutex(DDP_SCENARIO_ENUM scenario)\n{\n/* /: primay use mutex 0 */\n\tint mutex_id = 0;\n\tDDP_MANAGER_CONTEXT *content = _get_context();\n\tint mutex_idx_free = content->mutex_idx;\n\tASSERT(scenario >= 0 && scenario < DDP_SCENARIO_MAX);\n\twhile (mutex_idx_free) {\n\t\tif (mutex_idx_free & 0x1) {\n\t\t\tcontent->mutex_idx &= (~(0x1 << mutex_id));\n\t\t\tmutex_id += DISP_MUTEX_DDP_FIRST;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_idx_free >>= 1;\n\t\t++mutex_id;\n\t}\n\tASSERT(mutex_id < (DISP_MUTEX_DDP_FIRST + DISP_MUTEX_DDP_COUNT));\n\tDISP_LOG_I(\"scenario %s acquire mutex %d , left mutex 0x%x!\\n\",\n\t\t   ddp_get_scenario_name(scenario), mutex_id, content->mutex_idx);\n\treturn mutex_id;\n"]]}
{"hexsha": "e7ec6e86c60a44ef3c227784777a281297d77697", "ext": "c", "lang": "C", "content": "static void print_element_names(xmlDoc *doc, xmlNode * a_node)\n{\n  xmlNode *cur_node = NULL;\n  xmlAttr *cur_attr = NULL;\n  xmlChar *attr;\n  \n  for (cur_node = a_node; cur_node; cur_node = cur_node->next) {\n    if (cur_node->type == XML_ELEMENT_NODE) {\n      Log(DEBUG,\"node type: Element, name: %s, VALUE %s\",cur_node->name, xmlNodeListGetString(doc, cur_node->xmlChildrenNode, 1));\n    }\n    print_element_names(doc, cur_node->children);\n  }\n}", "item_id": 5, "repo": "Ingenico-NPS-Latam/nps-sdk-c", "file": "npsSdk.c", "last_update_at": "2018-05-31T17:55:31+00:00", "question_id": "e7ec6e86c60a44ef3c227784777a281297d77697_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void print_element_names(xmlDoc *doc, xmlNode * a_node)\n{\n  xmlNode *cur_node = NULL;\n  xmlAttr *cur_attr = NULL;\n  xmlChar *attr;\n  for (cur_node = a_node; cur_node; cur_node = cur_node->next) {\n    if (cur_node->type == XML_ELEMENT_NODE) {\n      Log(DEBUG,\"node type: Element, name: %s, VALUE %s\",cur_node->name, xmlNodeListGetString(doc, cur_node->xmlChildrenNode, 1));\n    }\n    print_element_names(doc, cur_node->children);\n  }\n"]]}
{"hexsha": "351055def70884d31f01045490c93ee0a26be39a", "ext": "h", "lang": "C", "content": "class IFWL_CustomPanel : public IFWL_Widget {\r\n public:\r\n  static IFWL_CustomPanel* Create(CFWL_WidgetImpProperties& properties,\r\n                                  IFWL_Widget* pOuter);\r\n\r\n  IFWL_Content* GetContent();\r\n  FWL_ERR SetContent(IFWL_Content* pContent);\r\n  FWL_ERR SetProxy(IFWL_Proxy* pProxy);\r\n\r\n protected:\r\n  IFWL_CustomPanel();\r\n}", "item_id": 1, "repo": "f100cleveland/external_pdfium", "file": "xfa/include/fwl/core/fwl_panel.h", "last_update_at": "2018-01-12T03:24:59+00:00", "question_id": "351055def70884d31f01045490c93ee0a26be39a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class IFWL_CustomPanel : public IFWL_Widget {\r\n public:\r\n  static IFWL_CustomPanel* Create(CFWL_WidgetImpProperties& properties,\r\n                                  IFWL_Widget* pOuter);\r\n\r\n  IFWL_Content* GetContent();\r\n  FWL_ERR SetContent(IFWL_Content* pContent);\r\n  FWL_ERR SetProxy(IFWL_Proxy* pProxy);\r\n\r\n protected:\r\n  IFWL_CustomPanel();\r\n"]]}
{"hexsha": "8a9fa109cb725cdbe8db5306a784001c3d1c1dce", "ext": "c", "lang": "C", "content": "int main(void)\n{\n\n\tparent_pid = getpid();\n\tprintf(\"Parent PID=%d\\n\", parent_pid);\n\tif (fork() == 0) {\n\t\tchild_pid = getpid();\n\t\tprintf(\"Child PID=%d\\n\", child_pid);\n\t\treturn 0;\n\t}\n\tsleep(1);\n\treturn 0;\n}", "item_id": 0, "repo": "lucvoo/slibc", "file": "tests/child_pid.c", "last_update_at": "2018-10-05T14:02:32+00:00", "question_id": "8a9fa109cb725cdbe8db5306a784001c3d1c1dce_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(void)\n{\n\tparent_pid = getpid();\n\tprintf(\"Parent PID=%d\\n\", parent_pid);\n\tif (fork() == 0) {\n\t\tchild_pid = getpid();\n\t\tprintf(\"Child PID=%d\\n\", child_pid);\n\t\treturn 0;\n\t}\n\tsleep(1);\n\treturn 0;\n"]]}
{"hexsha": "b85ba71a6f77e974d82ccdd635109f36d0ddaac8", "ext": "h", "lang": "C", "content": "static int\nremoteDomainDetachDeviceFlags(virDomainPtr dom, const char *xml, unsigned int flags)\n{\n    int rv = -1;\n    struct private_data *priv = dom->conn->privateData;\n    remote_domain_detach_device_flags_args args;\n\n    remoteDriverLock(priv);\n\n    make_nonnull_domain(&args.dom, dom);\n    args.xml = (char *)xml;\n    args.flags = flags;\n\n    if (call(dom->conn, priv, 0, REMOTE_PROC_DOMAIN_DETACH_DEVICE_FLAGS,\n             (xdrproc_t)xdr_remote_domain_detach_device_flags_args, (char *)&args,\n             (xdrproc_t)xdr_void, (char *)NULL) == -1) {\n        goto done;\n    }\n\n    rv = 0;\n\ndone:\n    remoteDriverUnlock(priv);\n    return rv;\n}", "item_id": 50, "repo": "SIIS-cloud/pileus", "file": "libvirt/pileus-libvirt-1.2.12/src/remote/remote_client_bodies.h", "last_update_at": "2018-03-30T02:11:54+00:00", "question_id": "b85ba71a6f77e974d82ccdd635109f36d0ddaac8_50", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nremoteDomainDetachDeviceFlags(virDomainPtr dom, const char *xml, unsigned int flags)\n{\n    int rv = -1;\n    struct private_data *priv = dom->conn->privateData;\n    remote_domain_detach_device_flags_args args;\n    remoteDriverLock(priv);\n    make_nonnull_domain(&args.dom, dom);\n    args.xml = (char *)xml;\n    args.flags = flags;\n    if (call(dom->conn, priv, 0, REMOTE_PROC_DOMAIN_DETACH_DEVICE_FLAGS,\n             (xdrproc_t)xdr_remote_domain_detach_device_flags_args, (char *)&args,\n             (xdrproc_t)xdr_void, (char *)NULL) == -1) {\n        goto done;\n    }\n    rv = 0;\ndone:\n    remoteDriverUnlock(priv);\n    return rv;\n"]]}
{"hexsha": "18ab999bbfb0f1fc1d7c6aa7f47251006cd66572", "ext": "c", "lang": "C", "content": "static void assert_bip32_assumptions(void)\n{\n#define key_off(member) offsetof(struct ext_key,  member)\n#define key_size(member) sizeof(((struct ext_key *)0)->member)\n\n    /* Our ripend buffers must be uint32_t aligned and the correct size */\n    BUILD_ASSERT(key_off(parent160) % sizeof(uint32_t) == 0);\n    BUILD_ASSERT(key_off(hash160) % sizeof(uint32_t) == 0);\n    BUILD_ASSERT(key_size(parent160) == sizeof(struct ripemd160));\n    BUILD_ASSERT(key_size(hash160) == sizeof(struct ripemd160));\n    BUILD_ASSERT(key_size(priv_key) == EC_PRIVATE_KEY_LEN + 1);\n\n    /* Our keys following the parity byte must be uint64_t aligned */\n    BUILD_ASSERT((key_off(priv_key) + 1) % sizeof(uint64_t) == 0);\n    BUILD_ASSERT((key_off(pub_key) + 1) % sizeof(uint64_t) == 0);\n\n    /* child_num must be contigous after priv_key */\n    BUILD_ASSERT((key_off(priv_key) + key_size(priv_key)) == key_off(child_num));\n\n    /* We use priv_key[0] to determine if this extended key is public or\n     * private, If priv_key[0] is BIP32_FLAG_KEY_PRIVATE then this key is private\n     * with a computed public key present. If set to BIP32_FLAG_KEY_PUBLIC then\n     * this is a public key with no private key (A BIP32 'neutered' key).\n     *\n     * For this to work BIP32_FLAG_KEY_PRIVATE must be zero so the whole 33 byte\n     * private key is valid when serialized, and BIP32_FLAG_KEY_PUBLIC cannot be\n     * 2 or 3 as they are valid parity bytes for public keys.\n     */\n    BUILD_ASSERT(BIP32_FLAG_KEY_PRIVATE == 0);\n    BUILD_ASSERT(BIP32_FLAG_KEY_PUBLIC != BIP32_FLAG_KEY_PRIVATE &&\n                 BIP32_FLAG_KEY_PUBLIC != 2u &&\n                 BIP32_FLAG_KEY_PUBLIC != 3u);\n}", "item_id": 0, "repo": "AbinMM/BIP39_libwally-core", "file": "src/bip32.c", "last_update_at": "2018-07-13T02:45:15+00:00", "question_id": "18ab999bbfb0f1fc1d7c6aa7f47251006cd66572_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void assert_bip32_assumptions(void)\n{\n#define key_off(member) offsetof(struct ext_key,  member)\n#define key_size(member) sizeof(((struct ext_key *)0)->member)\n    /* Our ripend buffers must be uint32_t aligned and the correct size */\n    BUILD_ASSERT(key_off(parent160) % sizeof(uint32_t) == 0);\n    BUILD_ASSERT(key_off(hash160) % sizeof(uint32_t) == 0);\n    BUILD_ASSERT(key_size(parent160) == sizeof(struct ripemd160));\n    BUILD_ASSERT(key_size(hash160) == sizeof(struct ripemd160));\n    BUILD_ASSERT(key_size(priv_key) == EC_PRIVATE_KEY_LEN + 1);\n    /* Our keys following the parity byte must be uint64_t aligned */\n    BUILD_ASSERT((key_off(priv_key) + 1) % sizeof(uint64_t) == 0);\n    BUILD_ASSERT((key_off(pub_key) + 1) % sizeof(uint64_t) == 0);\n    /* child_num must be contigous after priv_key */\n    BUILD_ASSERT((key_off(priv_key) + key_size(priv_key)) == key_off(child_num));\n    /* We use priv_key[0] to determine if this extended key is public or\n     * private, If priv_key[0] is BIP32_FLAG_KEY_PRIVATE then this key is private\n     * with a computed public key present. If set to BIP32_FLAG_KEY_PUBLIC then\n     * this is a public key with no private key (A BIP32 'neutered' key).\n     *\n     * For this to work BIP32_FLAG_KEY_PRIVATE must be zero so the whole 33 byte\n     * private key is valid when serialized, and BIP32_FLAG_KEY_PUBLIC cannot be\n     * 2 or 3 as they are valid parity bytes for public keys.\n     */\n    BUILD_ASSERT(BIP32_FLAG_KEY_PRIVATE == 0);\n    BUILD_ASSERT(BIP32_FLAG_KEY_PUBLIC != BIP32_FLAG_KEY_PRIVATE &&\n                 BIP32_FLAG_KEY_PUBLIC != 2u &&\n                 BIP32_FLAG_KEY_PUBLIC != 3u);\n"]]}
{"hexsha": "a9c8e628093f64c31dbc89666b04a3121549a9f3", "ext": "c", "lang": "C", "content": "static svn_error_t *\ngit_copy_to(enum parse_state *new_state, char *line, svn_patch_t *patch,\n            apr_pool_t *result_pool, apr_pool_t *scratch_pool)\n{\n  SVN_ERR(grab_filename(&patch->new_filename, line + STRLEN_LITERAL(\"copy to \"),\n                        result_pool, scratch_pool));\n\n  patch->operation = svn_diff_op_copied;\n\n  *new_state = state_git_tree_seen;\n  return SVN_NO_ERROR;\n}", "item_id": 30, "repo": "saurabhacellere/subversion", "file": "subversion/libsvn_diff/parse-diff.c", "last_update_at": "2018-12-24T22:05:09+00:00", "question_id": "a9c8e628093f64c31dbc89666b04a3121549a9f3_30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static svn_error_t *\ngit_copy_to(enum parse_state *new_state, char *line, svn_patch_t *patch,\n            apr_pool_t *result_pool, apr_pool_t *scratch_pool)\n{\n  SVN_ERR(grab_filename(&patch->new_filename, line + STRLEN_LITERAL(\"copy to \"),\n                        result_pool, scratch_pool));\n  patch->operation = svn_diff_op_copied;\n  *new_state = state_git_tree_seen;\n  return SVN_NO_ERROR;\n"]]}
{"hexsha": "47de56bca06ba2220bbd8f4b99bcb7beedbb3be9", "ext": "c", "lang": "C", "content": "static void registerlib(lua_State *L, const char *name, lua_CFunction f) {\n  lua_getglobal(L, \"package\");\n  lua_getfield(L, -1, \"preload\");\n  lua_pushcfunction(L, f);\n  lua_setfield(L, -2, name);\n  lua_pop(L, 2);\n}", "item_id": 7, "repo": "ryanplusplus/pil3", "file": "ch31/lproc.c", "last_update_at": "2018-10-02T20:19:34+00:00", "question_id": "47de56bca06ba2220bbd8f4b99bcb7beedbb3be9_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void registerlib(lua_State *L, const char *name, lua_CFunction f) {\n  lua_getglobal(L, \"package\");\n  lua_getfield(L, -1, \"preload\");\n  lua_pushcfunction(L, f);\n  lua_setfield(L, -2, name);\n  lua_pop(L, 2);\n"]]}
{"hexsha": "1110d60c11bb50f9c97fb124dc8c7ca92dee5a9a", "ext": "h", "lang": "C", "content": "void methodNodeToProtobuf( MethodNode * mNode, iso_protobuf::Iso* proto, std::set<long> & extraDataNodes){\n      iso_protobuf::Iso_MethodNode * method_node = proto -> add_method_nodes();\n      method_node -> set_id(mNode -> get_id() );\n      method_node -> set_name(mNode -> get_name() );\n      proto ->add_methodcallnames(mNode -> get_name() );\n      // Iterate through the arguments and add types/id\n      const std::vector<DataNode*> & args = mNode -> get_arguments();\n      for (const DataNode * dd : args){\n        method_node -> add_argumenttypes( dd -> get_data_type()  );\n        method_node -> add_argumentids( dd -> get_id());\n        //cout << dd -> get_id() << endl;\n        extraDataNodes.insert( dd-> get_id());\n        assert(dd -> get_type() == DATA_NODE);\n      }\n      // Add invokee/receiver types\n      const DataNode* rcv = mNode -> get_receiver();\n      if (rcv != NULL){\n        std::cerr << \"Debug: invokee type = \"<< rcv -> get_name() << endl;\n        method_node -> set_invokeetype(rcv -> get_data_type());\n        method_node -> set_invokeeid (rcv -> get_id());\n        extraDataNodes.insert( rcv -> get_id());\n        //cout << rcv -> get_id() << endl;\n        assert(rcv -> get_type() == DATA_NODE);\n      } else {\n        // std::cerr << \"Debug: invokee type cleared\"<< endl;\n        method_node -> clear_invokeetype();\n        method_node -> clear_invokeeid();\n      }\n      // Add assignee types\n      const DataNode * assg = mNode -> get_assignee();\n      if (assg != NULL){\n        method_node -> set_assigneetype(assg -> get_data_type());\n        method_node -> set_assigneeid(assg -> get_id());\n        extraDataNodes.insert(assg-> get_id());\n        //cout << assg -> get_id() <<endl;\n        assert(assg -> get_type() == DATA_NODE);\n      } else {\n        method_node -> clear_assigneetype();\n        method_node -> clear_assigneeid();\n      }\n      // Done!\n    }", "item_id": 3, "repo": "cuplv/FixrGraphIso", "file": "src/fixrgraphiso/isomorphismResults.h", "last_update_at": "2018-08-28T23:12:43+00:00", "question_id": "1110d60c11bb50f9c97fb124dc8c7ca92dee5a9a_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void methodNodeToProtobuf( MethodNode * mNode, iso_protobuf::Iso* proto, std::set<long> & extraDataNodes){\n      iso_protobuf::Iso_MethodNode * method_node = proto -> add_method_nodes();\n      method_node -> set_id(mNode -> get_id() );\n      method_node -> set_name(mNode -> get_name() );\n      proto ->add_methodcallnames(mNode -> get_name() );\n      // Iterate through the arguments and add types/id\n      const std::vector<DataNode*> & args = mNode -> get_arguments();\n      for (const DataNode * dd : args){\n        method_node -> add_argumenttypes( dd -> get_data_type()  );\n        method_node -> add_argumentids( dd -> get_id());\n        //cout << dd -> get_id() << endl;\n        extraDataNodes.insert( dd-> get_id());\n        assert(dd -> get_type() == DATA_NODE);\n      }\n      // Add invokee/receiver types\n      const DataNode* rcv = mNode -> get_receiver();\n      if (rcv != NULL){\n        std::cerr << \"Debug: invokee type = \"<< rcv -> get_name() << endl;\n        method_node -> set_invokeetype(rcv -> get_data_type());\n        method_node -> set_invokeeid (rcv -> get_id());\n        extraDataNodes.insert( rcv -> get_id());\n        //cout << rcv -> get_id() << endl;\n        assert(rcv -> get_type() == DATA_NODE);\n      } else {\n        // std::cerr << \"Debug: invokee type cleared\"<< endl;\n        method_node -> clear_invokeetype();\n        method_node -> clear_invokeeid();\n      }\n      // Add assignee types\n      const DataNode * assg = mNode -> get_assignee();\n      if (assg != NULL){\n        method_node -> set_assigneetype(assg -> get_data_type());\n        method_node -> set_assigneeid(assg -> get_id());\n        extraDataNodes.insert(assg-> get_id());\n        //cout << assg -> get_id() <<endl;\n        assert(assg -> get_type() == DATA_NODE);\n      } else {\n        method_node -> clear_assigneetype();\n        method_node -> clear_assigneeid();\n      }\n      // Done!\n"]]}
{"hexsha": "8e7df5daef45c7ee46c2898f834e917629ebe323", "ext": "h", "lang": "C", "content": "interface RCWeakRef : NSObject {\n    bool  _useWeakStorage;\n    id  _weakPointer;\n    id  _weakStorage;\n}", "item_id": 0, "repo": "shaojiankui/iOS10-Runtime-Headers", "file": "PrivateFrameworks/VoiceMemos.framework/RCWeakRef.h", "last_update_at": "2018-10-08T04:12:25+00:00", "question_id": "8e7df5daef45c7ee46c2898f834e917629ebe323_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface RCWeakRef : NSObject {\n    bool  _useWeakStorage;\n    id  _weakPointer;\n    id  _weakStorage;\n"]]}
{"hexsha": "ff73cfa5e7ea8d95165ed0e6c722f3199c3bf2a8", "ext": "c", "lang": "C", "content": "void SystemInit (void)\r\n{\r\n#if CORTEX_VECTORS_RAM\r\n\t// Then assume need to map vectors to RAM\r\n\tLPC_SYSCON->SYSMEMREMAP = ((LPC_SYSCON->SYSMEMREMAP)& ~3) | 1;\r\n#else\r\n     //\tLPC_SYSCON->SYSMEMREMAP |= 3; // Map to flash\r\n#endif\r\n    \t\r\n#if (CLOCK_SETUP)                                 /* Clock Setup              */\r\n#if (SYSCLK_SETUP)                                /* System Clock Setup       */\r\n#if (SYSOSC_SETUP)                                /* System Oscillator Setup  */\r\n  uint32_t i;\r\n\r\n  LPC_SYSCON->PDRUNCFG     &= ~(1 << 5);          /* Power-up System Osc      */\r\n  LPC_SYSCON->SYSOSCCTRL    = SYSOSCCTRL_Val;\r\n  for (i = 0; i < 200; i++) __NOP();\r\n  LPC_SYSCON->SYSPLLCLKSEL  = SYSPLLCLKSEL_Val;   /* Select PLL Input         */\r\n  LPC_SYSCON->SYSPLLCLKUEN  = 0x01;               /* Update Clock Source      */\r\n  LPC_SYSCON->SYSPLLCLKUEN  = 0x00;               /* Toggle Update Register   */\r\n  LPC_SYSCON->SYSPLLCLKUEN  = 0x01;\r\n  while (!(LPC_SYSCON->SYSPLLCLKUEN & 0x01));     /* Wait Until Updated       */\r\n#if (SYSPLL_SETUP)                                /* System PLL Setup         */\r\n  LPC_SYSCON->SYSPLLCTRL    = SYSPLLCTRL_Val;\r\n  LPC_SYSCON->PDRUNCFG     &= ~(1 << 7);          /* Power-up SYSPLL          */\r\n  while (!(LPC_SYSCON->SYSPLLSTAT & 0x01));\t      /* Wait Until PLL Locked    */\r\n#endif\r\n#endif\r\n#if (WDTOSC_SETUP)                                /* Watchdog Oscillator Setup*/\r\n  LPC_SYSCON->WDTOSCCTRL    = WDTOSCCTRL_Val;\r\n  LPC_SYSCON->PDRUNCFG     &= ~(1 << 6);          /* Power-up WDT Clock       */\r\n#endif\r\n  LPC_SYSCON->MAINCLKSEL    = MAINCLKSEL_Val;     /* Select PLL Clock Output  */\r\n  LPC_SYSCON->MAINCLKUEN    = 0x01;               /* Update MCLK Clock Source */\r\n  LPC_SYSCON->MAINCLKUEN    = 0x00;               /* Toggle Update Register   */\r\n  LPC_SYSCON->MAINCLKUEN    = 0x01;\r\n  while (!(LPC_SYSCON->MAINCLKUEN & 0x01));       /* Wait Until Updated       */\r\n#endif\r\n\r\n  LPC_SYSCON->SYSAHBCLKDIV  = SYSAHBCLKDIV_Val;\r\n  LPC_SYSCON->SYSAHBCLKCTRL = AHBCLKCTRL_Val;\r\n  LPC_SYSCON->SSP0CLKDIV    = SSP0CLKDIV_Val;\r\n  LPC_SYSCON->UARTCLKDIV    = UARTCLKDIV_Val;\r\n  LPC_SYSCON->SSP1CLKDIV    = SSP1CLKDIV_Val;\r\n#endif\r\n\r\n\r\n#if (MEMMAP_SETUP || MEMMAP_INIT)       /* Memory Mapping Setup               */\r\n  LPC_SYSCON->SYSMEMREMAP = SYSMEMREMAP_Val;\r\n#endif\r\n  SystemCoreClockUpdate();\r\n}", "item_id": 1, "repo": "jrahlf/3D-Non-Contact-Laser-Profilometer", "file": "xpcc/ext/lpc11xx/cmsis/system_LPC11xx.c", "last_update_at": "2018-01-02T23:34:18+00:00", "question_id": "ff73cfa5e7ea8d95165ed0e6c722f3199c3bf2a8_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void SystemInit (void)\r\n{\r\n#if CORTEX_VECTORS_RAM\r\n\t// Then assume need to map vectors to RAM\r\n\tLPC_SYSCON->SYSMEMREMAP = ((LPC_SYSCON->SYSMEMREMAP)& ~3) | 1;\r\n#else\r\n     //\tLPC_SYSCON->SYSMEMREMAP |= 3; // Map to flash\r\n#endif\r\n    \t\r\n#if (CLOCK_SETUP)                                 /* Clock Setup              */\r\n#if (SYSCLK_SETUP)                                /* System Clock Setup       */\r\n#if (SYSOSC_SETUP)                                /* System Oscillator Setup  */\r\n  uint32_t i;\r\n\r\n  LPC_SYSCON->PDRUNCFG     &= ~(1 << 5);          /* Power-up System Osc      */\r\n  LPC_SYSCON->SYSOSCCTRL    = SYSOSCCTRL_Val;\r\n  for (i = 0; i < 200; i++) __NOP();\r\n  LPC_SYSCON->SYSPLLCLKSEL  = SYSPLLCLKSEL_Val;   /* Select PLL Input         */\r\n  LPC_SYSCON->SYSPLLCLKUEN  = 0x01;               /* Update Clock Source      */\r\n  LPC_SYSCON->SYSPLLCLKUEN  = 0x00;               /* Toggle Update Register   */\r\n  LPC_SYSCON->SYSPLLCLKUEN  = 0x01;\r\n  while (!(LPC_SYSCON->SYSPLLCLKUEN & 0x01));     /* Wait Until Updated       */\r\n#if (SYSPLL_SETUP)                                /* System PLL Setup         */\r\n  LPC_SYSCON->SYSPLLCTRL    = SYSPLLCTRL_Val;\r\n  LPC_SYSCON->PDRUNCFG     &= ~(1 << 7);          /* Power-up SYSPLL          */\r\n  while (!(LPC_SYSCON->SYSPLLSTAT & 0x01));\t      /* Wait Until PLL Locked    */\r\n#endif\r\n#endif\r\n#if (WDTOSC_SETUP)                                /* Watchdog Oscillator Setup*/\r\n  LPC_SYSCON->WDTOSCCTRL    = WDTOSCCTRL_Val;\r\n  LPC_SYSCON->PDRUNCFG     &= ~(1 << 6);          /* Power-up WDT Clock       */\r\n#endif\r\n  LPC_SYSCON->MAINCLKSEL    = MAINCLKSEL_Val;     /* Select PLL Clock Output  */\r\n  LPC_SYSCON->MAINCLKUEN    = 0x01;               /* Update MCLK Clock Source */\r\n  LPC_SYSCON->MAINCLKUEN    = 0x00;               /* Toggle Update Register   */\r\n  LPC_SYSCON->MAINCLKUEN    = 0x01;\r\n  while (!(LPC_SYSCON->MAINCLKUEN & 0x01));       /* Wait Until Updated       */\r\n#endif\r\n\r\n  LPC_SYSCON->SYSAHBCLKDIV  = SYSAHBCLKDIV_Val;\r\n  LPC_SYSCON->SYSAHBCLKCTRL = AHBCLKCTRL_Val;\r\n  LPC_SYSCON->SSP0CLKDIV    = SSP0CLKDIV_Val;\r\n  LPC_SYSCON->UARTCLKDIV    = UARTCLKDIV_Val;\r\n  LPC_SYSCON->SSP1CLKDIV    = SSP1CLKDIV_Val;\r\n#endif\r\n\r\n\r\n#if (MEMMAP_SETUP || MEMMAP_INIT)       /* Memory Mapping Setup               */\r\n  LPC_SYSCON->SYSMEMREMAP = SYSMEMREMAP_Val;\r\n#endif\r\n  SystemCoreClockUpdate();\r\n"]]}
{"hexsha": "7eb4c80fa9defa43b05514893caa0815195555fa", "ext": "c", "lang": "C", "content": "SWIGINTERN PyObject *_wrap_get_XE_YIELD_IFBA_DIFF_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {\n  PyObject *resultobj = 0;\n  float arg1 ;\n  float arg2 ;\n  float val1 ;\n  int ecode1 = 0 ;\n  float val2 ;\n  int ecode2 = 0 ;\n  PyObject * obj0 = 0 ;\n  PyObject * obj1 = 0 ;\n  float result;\n  \n  if (!PyArg_ParseTuple(args,(char *)\"OO:get_XE_YIELD_IFBA_DIFF_1\",&obj0,&obj1)) SWIG_fail;\n  ecode1 = SWIG_AsVal_float(obj0, &val1);\n  if (!SWIG_IsOK(ecode1)) {\n    SWIG_exception_fail(SWIG_ArgError(ecode1), \"in method '\" \"get_XE_YIELD_IFBA_DIFF_1\" \"', argument \" \"1\"\" of type '\" \"float\"\"'\");\n  } \n  arg1 = (float)(val1);\n  ecode2 = SWIG_AsVal_float(obj1, &val2);\n  if (!SWIG_IsOK(ecode2)) {\n    SWIG_exception_fail(SWIG_ArgError(ecode2), \"in method '\" \"get_XE_YIELD_IFBA_DIFF_1\" \"', argument \" \"2\"\" of type '\" \"float\"\"'\");\n  } \n  arg2 = (float)(val2);\n  result = (float)get_XE_YIELD_IFBA_DIFF_1(arg1,arg2);\n  resultobj = SWIG_From_float((float)(result));\n  return resultobj;\nfail:\n  return NULL;\n}", "item_id": 189, "repo": "robertsj/poropy", "file": "poropy/nucleardata/nucleardata_wrap.c", "last_update_at": "2018-02-11T11:24:14+00:00", "question_id": "7eb4c80fa9defa43b05514893caa0815195555fa_189", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["SWIGINTERN PyObject *_wrap_get_XE_YIELD_IFBA_DIFF_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {\n  PyObject *resultobj = 0;\n  float arg1 ;\n  float arg2 ;\n  float val1 ;\n  int ecode1 = 0 ;\n  float val2 ;\n  int ecode2 = 0 ;\n  PyObject * obj0 = 0 ;\n  PyObject * obj1 = 0 ;\n  float result;\n  if (!PyArg_ParseTuple(args,(char *)\"OO:get_XE_YIELD_IFBA_DIFF_1\",&obj0,&obj1)) SWIG_fail;\n  ecode1 = SWIG_AsVal_float(obj0, &val1);\n  if (!SWIG_IsOK(ecode1)) {\n    SWIG_exception_fail(SWIG_ArgError(ecode1), \"in method '\" \"get_XE_YIELD_IFBA_DIFF_1\" \"', argument \" \"1\"\" of type '\" \"float\"\"'\");\n  } \n  arg1 = (float)(val1);\n  ecode2 = SWIG_AsVal_float(obj1, &val2);\n  if (!SWIG_IsOK(ecode2)) {\n    SWIG_exception_fail(SWIG_ArgError(ecode2), \"in method '\" \"get_XE_YIELD_IFBA_DIFF_1\" \"', argument \" \"2\"\" of type '\" \"float\"\"'\");\n  } \n  arg2 = (float)(val2);\n  result = (float)get_XE_YIELD_IFBA_DIFF_1(arg1,arg2);\n  resultobj = SWIG_From_float((float)(result));\n  return resultobj;\nfail:\n  return NULL;\n"]]}
{"hexsha": "c0399fc1ac6e4e1b2b58796cdd0ab370d0e9d37d", "ext": "c", "lang": "C", "content": "int _ArrayListSearch(ArrayList self, void* element){\n    //TODO\n    printf(\"ArrayListSearch function\\n\");\n    return 0;\n}", "item_id": 1, "repo": "touir1/Data-structures-C", "file": "DataStructures/ArrayList/ArrayList.c", "last_update_at": "2018-09-23T16:32:19+00:00", "question_id": "c0399fc1ac6e4e1b2b58796cdd0ab370d0e9d37d_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int _ArrayListSearch(ArrayList self, void* element){\n    //TODO\n    printf(\"ArrayListSearch function\\n\");\n    return 0;\n"]]}
{"hexsha": "22a4745258654e16e2a04ebe2d10bf669a9162f7", "ext": "h", "lang": "C", "content": "class CivilianImgPathManager\r\n{\r\npublic:\r\n\r\n    static const char* getRandomCivilianImgPathBegin();\r\n\r\nprivate:\r\n    CivilianImgPathManager(void);\r\n    ~CivilianImgPathManager(void);\r\n}", "item_id": 0, "repo": "TyrealGray/AssassinWar", "file": "GameModuleSet/CivilianImgPathManager.h", "last_update_at": "2018-04-17T21:04:31+00:00", "question_id": "22a4745258654e16e2a04ebe2d10bf669a9162f7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class CivilianImgPathManager\r\n{\r\npublic:\r\n\r\n    static const char* getRandomCivilianImgPathBegin();\r\n\r\nprivate:\r\n    CivilianImgPathManager(void);\r\n    ~CivilianImgPathManager(void);\r\n"]]}
{"hexsha": "d7867156a643510e0a32d44d62f95ae5410fc6c1", "ext": "c", "lang": "C", "content": "LIBXSMM_INLINE void init_buf(float* buf, size_t size, int initPos, int initOne)\n{\n  int i;\n  zero_buf(buf, size);\n  for (i = 0; i < (int)size; ++i) {\n    buf[i] = (float)((initOne != 0) ? 1.0 : ((initPos != 0) ? libxsmm_rand_f64() : (0.05 - libxsmm_rand_f64()/10.0)));\n  }\n}", "item_id": 5, "repo": "egeor/libxsmm", "file": "samples/deeplearning/cnnlayer/layer_example_bf16.c", "last_update_at": "2018-07-05T05:09:09+00:00", "question_id": "d7867156a643510e0a32d44d62f95ae5410fc6c1_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["LIBXSMM_INLINE void init_buf(float* buf, size_t size, int initPos, int initOne)\n{\n  int i;\n  zero_buf(buf, size);\n  for (i = 0; i < (int)size; ++i) {\n    buf[i] = (float)((initOne != 0) ? 1.0 : ((initPos != 0) ? libxsmm_rand_f64() : (0.05 - libxsmm_rand_f64()/10.0)));\n  }\n"]]}
{"hexsha": "4fab89f5c5c43003240da57d138c4dae953e3b7f", "ext": "c", "lang": "C", "content": "static void report_error (gravity_parser_t *parser, error_type_t error_type, gtoken_s token, const char *format, ...) {\n    // just one error for each line\n    if (parser->last_error_lineno == token.lineno) return;\n    parser->last_error_lineno = token.lineno;\n\n    // increment internal error counter\n    if (error_type != GRAVITY_WARNING) ++parser->nerrors;\n\n    // get error callback (if any)\n    void *data = (parser->delegate) ? parser->delegate->xdata : NULL;\n    gravity_error_callback error_fn = (parser->delegate) ? ((gravity_delegate_t *)parser->delegate)->error_callback : NULL;\n\n    // build error message\n    char        buffer[1024];\n    va_list        arg;\n    if (format) {\n        va_start (arg, format);\n        vsnprintf(buffer, sizeof(buffer), format, arg);\n        va_end (arg);\n    }\n\n    // setup error struct\n    error_desc_t error_desc = {\n        .lineno = token.lineno,\n        .colno = token.colno,\n        .fileid = token.fileid,\n        .offset = token.position\n    };\n\n    // finally call error callback\n    if (error_fn) error_fn(NULL, error_type, buffer, error_desc, data);\n    else printf(\"%s\\n\", buffer);\n}", "item_id": 1, "repo": "elix22/gravity", "file": "src/compiler/gravity_parser.c", "last_update_at": "2018-07-13T02:14:08+00:00", "question_id": "4fab89f5c5c43003240da57d138c4dae953e3b7f_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void report_error (gravity_parser_t *parser, error_type_t error_type, gtoken_s token, const char *format, ...) {\n    // just one error for each line\n    if (parser->last_error_lineno == token.lineno) return;\n    parser->last_error_lineno = token.lineno;\n    // increment internal error counter\n    if (error_type != GRAVITY_WARNING) ++parser->nerrors;\n    // get error callback (if any)\n    void *data = (parser->delegate) ? parser->delegate->xdata : NULL;\n    gravity_error_callback error_fn = (parser->delegate) ? ((gravity_delegate_t *)parser->delegate)->error_callback : NULL;\n    // build error message\n    char        buffer[1024];\n    va_list        arg;\n    if (format) {\n        va_start (arg, format);\n        vsnprintf(buffer, sizeof(buffer), format, arg);\n        va_end (arg);\n    }\n    // setup error struct\n    error_desc_t error_desc = {\n        .lineno = token.lineno,\n        .colno = token.colno,\n        .fileid = token.fileid,\n        .offset = token.position\n    };\n    // finally call error callback\n    if (error_fn) error_fn(NULL, error_type, buffer, error_desc, data);\n    else printf(\"%s\\n\", buffer);\n"]]}
{"hexsha": "f904eded3ae3337eb05a9dc97e8e8745e9615f5c", "ext": "c", "lang": "C", "content": "Drand *\nDrand_new ( \n   void \n) {\nDrand   *drand ;\n\nALLOCATE(drand, struct _Drand, 1) ;\nDrand_setDefaultFields(drand) ;\n\nreturn(drand) ; }", "item_id": 0, "repo": "alleindrach/calculix-desktop", "file": "ccx_prool/SPOOLES.2.2/Drand/src/basics.c", "last_update_at": "2018-01-25T16:08:31+00:00", "question_id": "f904eded3ae3337eb05a9dc97e8e8745e9615f5c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["Drand *\nDrand_new ( \n   void \n) {\nDrand   *drand ;\nALLOCATE(drand, struct _Drand, 1) ;\nDrand_setDefaultFields(drand) ;\n"]]}
{"hexsha": "a00ad98e9e5bd6a979ca38715790cae6b11c5532", "ext": "c", "lang": "C", "content": "int wav2adpcm(const char *infile, const char *outfile) {\n\tstruct wavhdr_t wavhdr;\n\tFILE *in, *out;\n\tsize_t pcmsize, adpcmsize;\n\tshort *pcmbuf;\n\tunsigned char *adpcmbuf;\n\n\tin = fopen(infile, \"rb\");\n\tif (in == NULL) {\n\t\tprintf(\"can't open %s\\n\", infile);\n\t\treturn -1;\n\t}\n\tfread(&wavhdr, 1, sizeof(wavhdr), in);\n\n\tif (memcmp(wavhdr.hdr1, \"RIFF\", 4)\n\t\t|| memcmp(wavhdr.hdr2, \"WAVEfmt \", 8)\n\t\t|| memcmp(wavhdr.hdr3, \"data\", 4)\n\t\t|| wavhdr.hdrsize != 0x10\n\t\t|| wavhdr.format != 1\n\t\t|| (wavhdr.channels != 1 && wavhdr.channels != 2)\n\t\t|| wavhdr.bits != 16) {\n\t\tprintf(\"unsupport format\\n\");\n\t\tfclose(in);\n\t\treturn -1;\n\t}\n\n\tpcmsize = wavhdr.datasize;\n\n\tadpcmsize = pcmsize / 4;\n\tpcmbuf = malloc(pcmsize);\n\tadpcmbuf = malloc(adpcmsize);\n\n\tfread(pcmbuf, 1, pcmsize, in);\n\tfclose(in);\n\n\tif (wavhdr.channels == 1) {\n\t\tpcm2adpcm(adpcmbuf, pcmbuf, pcmsize);\n\t}\n\telse {\n\t\t/* For stereo we just deinterleave the input and store the\n\t\tleft and right channel of the ADPCM data separately. */\n\t\tdeinterleave(pcmbuf, pcmsize);\n\t\tpcm2adpcm(adpcmbuf, pcmbuf, pcmsize / 2);\n\t\tpcm2adpcm(adpcmbuf + adpcmsize / 2, pcmbuf + pcmsize / 4, pcmsize / 2);\n\t}\n\n\tout = fopen(outfile, \"wb\");\n\twavhdr.datasize = adpcmsize;\n\twavhdr.format = 20;\t/* ITU G.723 ADPCM (Yamaha) */\n\twavhdr.bits = 4;\n\twavhdr.totalsize = wavhdr.datasize + sizeof(wavhdr) - 8;\n\tfwrite(&wavhdr, 1, sizeof(wavhdr), out);\n\tfwrite(adpcmbuf, 1, adpcmsize, out);\n\tfclose(out);\n\n\treturn 0;\n}", "item_id": 4, "repo": "trigger-death/WiimoteLib.Net", "file": "Wav2ADPCM/wav2adpcm.c", "last_update_at": "2018-09-17T13:50:51+00:00", "question_id": "a00ad98e9e5bd6a979ca38715790cae6b11c5532_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int wav2adpcm(const char *infile, const char *outfile) {\n\tstruct wavhdr_t wavhdr;\n\tFILE *in, *out;\n\tsize_t pcmsize, adpcmsize;\n\tshort *pcmbuf;\n\tunsigned char *adpcmbuf;\n\tin = fopen(infile, \"rb\");\n\tif (in == NULL) {\n\t\tprintf(\"can't open %s\\n\", infile);\n\t\treturn -1;\n\t}\n\tfread(&wavhdr, 1, sizeof(wavhdr), in);\n\tif (memcmp(wavhdr.hdr1, \"RIFF\", 4)\n\t\t|| memcmp(wavhdr.hdr2, \"WAVEfmt \", 8)\n\t\t|| memcmp(wavhdr.hdr3, \"data\", 4)\n\t\t|| wavhdr.hdrsize != 0x10\n\t\t|| wavhdr.format != 1\n\t\t|| (wavhdr.channels != 1 && wavhdr.channels != 2)\n\t\t|| wavhdr.bits != 16) {\n\t\tprintf(\"unsupport format\\n\");\n\t\tfclose(in);\n\t\treturn -1;\n\t}\n\tpcmsize = wavhdr.datasize;\n\tadpcmsize = pcmsize / 4;\n\tpcmbuf = malloc(pcmsize);\n\tadpcmbuf = malloc(adpcmsize);\n\tfread(pcmbuf, 1, pcmsize, in);\n\tfclose(in);\n\tif (wavhdr.channels == 1) {\n\t\tpcm2adpcm(adpcmbuf, pcmbuf, pcmsize);\n\t}\n\telse {\n\t\t/* For stereo we just deinterleave the input and store the\n\t\tleft and right channel of the ADPCM data separately. */\n\t\tdeinterleave(pcmbuf, pcmsize);\n\t\tpcm2adpcm(adpcmbuf, pcmbuf, pcmsize / 2);\n\t\tpcm2adpcm(adpcmbuf + adpcmsize / 2, pcmbuf + pcmsize / 4, pcmsize / 2);\n\t}\n\tout = fopen(outfile, \"wb\");\n\twavhdr.datasize = adpcmsize;\n\twavhdr.format = 20;\t/* ITU G.723 ADPCM (Yamaha) */\n\twavhdr.bits = 4;\n\twavhdr.totalsize = wavhdr.datasize + sizeof(wavhdr) - 8;\n\tfwrite(&wavhdr, 1, sizeof(wavhdr), out);\n\tfwrite(adpcmbuf, 1, adpcmsize, out);\n\tfclose(out);\n\treturn 0;\n"]]}
{"hexsha": "1e79be0b322a5cbc6f2a2a24a7e1f4629db74617", "ext": "c", "lang": "C", "content": "static char *\nname_list_to_string(DefElem *def)\n{\n\tStringInfoData string;\n\tListCell *lc;\n\tbool first = true;\n\n\tinitStringInfo(&string);\n\n\tforeach (lc, (List *) def->arg)\n\t{\n\t\tNode *name = (Node *) lfirst(lc);\n\n\t\tif (!first)\n\t\t\tappendStringInfo(&string, \", \");\n\t\telse\n\t\t\tfirst = false;\n\n\t\tif (IsA(name, String))\n\t\t\tappendStringInfoString(&string, quote_identifier(strVal(name)));\n\t\telse if (IsA(name, A_Star))\n\t\t\tappendStringInfoChar(&string, '*');\n\t\telse\n\t\t\telog(ERROR, \"unexpected node type in name list: %d\", (int) nodeTag(name));\n\t}\n\treturn string.data;\n}", "item_id": 11, "repo": "jameswinegar/timescaledb", "file": "tsl/src/remote/dist_copy.c", "last_update_at": "2018-12-18T11:57:43+00:00", "question_id": "1e79be0b322a5cbc6f2a2a24a7e1f4629db74617_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static char *\nname_list_to_string(DefElem *def)\n{\n\tStringInfoData string;\n\tListCell *lc;\n\tbool first = true;\n\tinitStringInfo(&string);\n\tforeach (lc, (List *) def->arg)\n\t{\n\t\tNode *name = (Node *) lfirst(lc);\n\t\tif (!first)\n\t\t\tappendStringInfo(&string, \", \");\n\t\telse\n\t\t\tfirst = false;\n\t\tif (IsA(name, String))\n\t\t\tappendStringInfoString(&string, quote_identifier(strVal(name)));\n\t\telse if (IsA(name, A_Star))\n\t\t\tappendStringInfoChar(&string, '*');\n\t\telse\n\t\t\telog(ERROR, \"unexpected node type in name list: %d\", (int) nodeTag(name));\n\t}\n\treturn string.data;\n"]]}
{"hexsha": "9279e491892f6fec20ea72f2810518655dd085b5", "ext": "c", "lang": "C", "content": "int main()\n{\n\tSysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ| SYSCTL_OSC_MAIN);\n    has_lcd_4bitsetup();\n    KeyPad_Lcd_Setup();\n    KeyPad_Setup();\n    while(1)\n    {\n                KeyPad_wait();\n    \t        KeyPad_PassWord_Confirm();\n\n    }\n\n}", "item_id": 0, "repo": "hasan-htp/Real-Time-Password-Security-System", "file": "HAS_Keypad/HAS_Keypad/main.c", "last_update_at": "2018-08-20T21:27:30+00:00", "question_id": "9279e491892f6fec20ea72f2810518655dd085b5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main()\n{\n\tSysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ| SYSCTL_OSC_MAIN);\n    has_lcd_4bitsetup();\n    KeyPad_Lcd_Setup();\n    KeyPad_Setup();\n    while(1)\n    {\n                KeyPad_wait();\n    \t        KeyPad_PassWord_Confirm();\n    }\n"]]}
{"hexsha": "eef69a4cab424bea5dfdd197756362ccbde9a183", "ext": "c", "lang": "C", "content": "static int\nworker_wrapper(void *arg)\n{\n\tstruct worker_data *w  = arg;\n\tconst bool burst = evt_has_burst_mode(w->dev_id);\n\n\tif (burst)\n\t\treturn order_queue_worker_burst(arg);\n\telse\n\t\treturn order_queue_worker(arg);\n}", "item_id": 3, "repo": "kwame998/jupiter", "file": "dpdk-17.11/app/test-eventdev/test_order_queue.c", "last_update_at": "2018-04-30T05:58:21+00:00", "question_id": "eef69a4cab424bea5dfdd197756362ccbde9a183_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nworker_wrapper(void *arg)\n{\n\tstruct worker_data *w  = arg;\n\tconst bool burst = evt_has_burst_mode(w->dev_id);\n\tif (burst)\n\t\treturn order_queue_worker_burst(arg);\n\telse\n\t\treturn order_queue_worker(arg);\n"]]}
{"hexsha": "65b20a74f691434a8bef1d74d4dc7b5c9dea48d4", "ext": "c", "lang": "C", "content": "int XIicPs_SetOptions(XIicPs *InstancePtr, u32 Options)\n{\n\tu32 ControlReg;\n\tunsigned int Index;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\tXil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n\tControlReg = XIicPs_ReadReg(InstancePtr->Config.BaseAddress,\n\t\t\t\t      XIICPS_CR_OFFSET);\n\n\t/*\n\t * If repeated start option is requested, set the flag.\n\t * The hold bit in CR will be written by driver when the next transfer\n\t * is initiated.\n\t */\n\tif (Options & XIICPS_REP_START_OPTION) {\n\t\tInstancePtr->IsRepeatedStart = 1;\n\t\tOptions = Options & (~XIICPS_REP_START_OPTION);\n\t}\n\n\t/*\n\t * Loop through the options table, turning the option on.\n\t */\n\tfor (Index = 0; Index < XIICPS_NUM_OPTIONS; Index++) {\n \t\tif (Options & OptionsTable[Index].Option) {\n\t\t\t/*\n\t\t\t * 10-bit option is specially treated, because it is\n\t\t\t * using the 7-bit option, so turning it on means\n\t\t\t * turning 7-bit option off.\n\t\t\t */\n\t\t\tif (OptionsTable[Index].Option &\n\t\t\t\tXIICPS_10_BIT_ADDR_OPTION) {\n\t\t\t\t/* Turn 7-bit off */\n\t\t\t\tControlReg &= ~OptionsTable[Index].Mask;\n \t\t\t} else {\n\t\t\t\t/* Turn 7-bit on */\n\t\t\t\tControlReg |= OptionsTable[Index].Mask;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now write to the control register. Leave it to the upper layers\n\t * to restart the device.\n\t */\n\tXIicPs_WriteReg(InstancePtr->Config.BaseAddress, XIICPS_CR_OFFSET,\n\t\t\t  ControlReg);\n\n\t/*\n\t * Keep a copy of what options this instance has.\n\t */\n\tInstancePtr->Options = XIicPs_GetOptions(InstancePtr);\n\n\treturn XST_SUCCESS;\n}", "item_id": 0, "repo": "kubostech/kubos", "file": "freertos/os/FreeRTOS/Demo/CORTEX_A9_Zynq_ZC702/RTOSDemo_bsp/ps7_cortexa9_0/libsrc/iicps_v2_1/src/xiicps_options.c", "last_update_at": "2018-01-05T00:15:13+00:00", "question_id": "65b20a74f691434a8bef1d74d4dc7b5c9dea48d4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int XIicPs_SetOptions(XIicPs *InstancePtr, u32 Options)\n{\n\tu32 ControlReg;\n\tunsigned int Index;\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\tXil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\tControlReg = XIicPs_ReadReg(InstancePtr->Config.BaseAddress,\n\t\t\t\t      XIICPS_CR_OFFSET);\n\t/*\n\t * If repeated start option is requested, set the flag.\n\t * The hold bit in CR will be written by driver when the next transfer\n\t * is initiated.\n\t */\n\tif (Options & XIICPS_REP_START_OPTION) {\n\t\tInstancePtr->IsRepeatedStart = 1;\n\t\tOptions = Options & (~XIICPS_REP_START_OPTION);\n\t}\n\t/*\n\t * Loop through the options table, turning the option on.\n\t */\n\tfor (Index = 0; Index < XIICPS_NUM_OPTIONS; Index++) {\n \t\tif (Options & OptionsTable[Index].Option) {\n\t\t\t/*\n\t\t\t * 10-bit option is specially treated, because it is\n\t\t\t * using the 7-bit option, so turning it on means\n\t\t\t * turning 7-bit option off.\n\t\t\t */\n\t\t\tif (OptionsTable[Index].Option &\n\t\t\t\tXIICPS_10_BIT_ADDR_OPTION) {\n\t\t\t\t/* Turn 7-bit off */\n\t\t\t\tControlReg &= ~OptionsTable[Index].Mask;\n \t\t\t} else {\n\t\t\t\t/* Turn 7-bit on */\n\t\t\t\tControlReg |= OptionsTable[Index].Mask;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Now write to the control register. Leave it to the upper layers\n\t * to restart the device.\n\t */\n\tXIicPs_WriteReg(InstancePtr->Config.BaseAddress, XIICPS_CR_OFFSET,\n\t\t\t  ControlReg);\n\t/*\n\t * Keep a copy of what options this instance has.\n\t */\n\tInstancePtr->Options = XIicPs_GetOptions(InstancePtr);\n\treturn XST_SUCCESS;\n"]]}
{"hexsha": "ca1102ef5f7fb30f08d0b73673f2af49d587b80c", "ext": "c", "lang": "C", "content": "int infra_find_ratelimit(struct infra_cache* infra, uint8_t* name,\n\tsize_t namelen)\n{\n\tint labs = dname_count_labels(name);\n\tstruct domain_limit_data* d = (struct domain_limit_data*)\n\t\tname_tree_lookup(&infra->domain_limits, name, namelen, labs,\n\t\tLDNS_RR_CLASS_IN);\n\tif(!d) return infra_dp_ratelimit;\n\n\tif(d->node.labs == labs && d->lim != -1)\n\t\treturn d->lim; /* exact match */\n\n\t/* find 'below match' */\n\tif(d->node.labs == labs)\n\t\td = (struct domain_limit_data*)d->node.parent;\n\twhile(d) {\n\t\tif(d->below != -1)\n\t\t\treturn d->below;\n\t\td = (struct domain_limit_data*)d->node.parent;\n\t}\n\treturn infra_dp_ratelimit;\n}", "item_id": 20, "repo": "NLnetLabs/unbound.old", "file": "services/cache/infra.c", "last_update_at": "2018-08-21T03:04:10+00:00", "question_id": "ca1102ef5f7fb30f08d0b73673f2af49d587b80c_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int infra_find_ratelimit(struct infra_cache* infra, uint8_t* name,\n\tsize_t namelen)\n{\n\tint labs = dname_count_labels(name);\n\tstruct domain_limit_data* d = (struct domain_limit_data*)\n\t\tname_tree_lookup(&infra->domain_limits, name, namelen, labs,\n\t\tLDNS_RR_CLASS_IN);\n\tif(!d) return infra_dp_ratelimit;\n\tif(d->node.labs == labs && d->lim != -1)\n\t\treturn d->lim; /* exact match */\n\t/* find 'below match' */\n\tif(d->node.labs == labs)\n\t\td = (struct domain_limit_data*)d->node.parent;\n\twhile(d) {\n\t\tif(d->below != -1)\n\t\t\treturn d->below;\n\t\td = (struct domain_limit_data*)d->node.parent;\n\t}\n\treturn infra_dp_ratelimit;\n"]]}
{"hexsha": "56bd2e3833d7189e189358c1dbb5c14ccb1c53c3", "ext": "c", "lang": "C", "content": "void insert_treeEdge_to_dlls(struct s_node *fromv,struct s_node *tov,Edge *e) {\n    \n    if(!fromv || !tov || !e)\n        return;\n    SET_TE(e);\n    \n    if(!fromv->pt1) {\n        fromv->pt1 = e;\n        e->fnext = e->fprev = NULL;\n    }\n    else {\n        e->fnext = fromv->pt1; //place e before fromv's head\n        if(fromv->pt1->from == fromv->key)\n            fromv->pt1->fprev = e; //set fromv's prev pointer to e\n        else\n            fromv->pt1->tprev = e;\n        e->fprev = NULL; //e's prev is null, because first\n        fromv->pt1 = e; //new head is e\n\n\n    }\n    updateTBit_Ins(fromv);\n    /*To Vertex part*/\n    if(!tov->pt1) {\n        tov->pt1 = e;\n        e->tnext = e->tprev = NULL;\n    }\n    else {\n        e->tnext = tov->pt1; //place e before tov's head\n        if(tov->pt1->from == tov->key) \n            tov->pt1->fprev = e;\n        else\n            tov->pt1->tprev = e; //set tov's prev pointer to e\n        e->tprev = NULL; //e's prev is null, because first\n        tov->pt1 = e; //new head is e\n        \n\n    }\n    updateTBit_Ins(tov);\n}", "item_id": 0, "repo": "FrischknechtTobias/Dynamic-Connectivity", "file": "src/dllist.c", "last_update_at": "2018-08-14T15:05:04+00:00", "question_id": "56bd2e3833d7189e189358c1dbb5c14ccb1c53c3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void insert_treeEdge_to_dlls(struct s_node *fromv,struct s_node *tov,Edge *e) {\n    if(!fromv || !tov || !e)\n        return;\n    SET_TE(e);\n    if(!fromv->pt1) {\n        fromv->pt1 = e;\n        e->fnext = e->fprev = NULL;\n    }\n    else {\n        e->fnext = fromv->pt1; //place e before fromv's head\n        if(fromv->pt1->from == fromv->key)\n            fromv->pt1->fprev = e; //set fromv's prev pointer to e\n        else\n            fromv->pt1->tprev = e;\n        e->fprev = NULL; //e's prev is null, because first\n        fromv->pt1 = e; //new head is e\n    }\n    updateTBit_Ins(fromv);\n    /*To Vertex part*/\n    if(!tov->pt1) {\n        tov->pt1 = e;\n        e->tnext = e->tprev = NULL;\n    }\n    else {\n        e->tnext = tov->pt1; //place e before tov's head\n        if(tov->pt1->from == tov->key) \n            tov->pt1->fprev = e;\n        else\n            tov->pt1->tprev = e; //set tov's prev pointer to e\n        e->tprev = NULL; //e's prev is null, because first\n        tov->pt1 = e; //new head is e\n    }\n    updateTBit_Ins(tov);\n"]]}
{"hexsha": "73a09de66a4167fe7510b6d84e1e153a61e6ee64", "ext": "c", "lang": "C", "content": "int main(int argc, char **argv)\n{\n\n\n    int fd_out, i;\n    int oflags = O_CREAT | O_WRONLY | O_TRUNC;\n    mode_t mode = S_IRUSR | S_IWUSR;\n    int flag_same = 0;\n\n\n    if(argc < 3){\n        printf(\"Usage: ./fconc.out infile1 infile2 [outfile (default:fconc.out.out)]\\n\");\n        return(2);\n    }\n    else if (argc > 3) {\n\n        for (i=1; i < argc-1; i++){\n            if (!(strcmp(argv[i],argv[argc-1]))) {\n                flag_same = 1;\n                break;\n            }\n        }\n\n        if(flag_same == 1) {\n            printf(\"Warning: The requested output file matches one of the input files. File will be overwritten.\\n\");\n        }\n\n        fd_out = open(\"output_file\", oflags, mode);\n\n        for (i = 1; i < argc - 1; i++) {\n            write_file(fd_out, argv[i]);\n        }\n\n        fd_out = open(argv[argc - 1], oflags, mode);\n        write_file(fd_out, \"output_file\");\n    \tremove(\"output_file\");\n    }\n    else {\n        fd_out = open(\"fconc.out\", oflags, mode);\n        if (fd_out == -1) {\n            perror(\"Open\");\n            exit(1);\n        }\n        for (i = 1; i < argc; i++) {\n            write_file(fd_out, argv[i]);\n        }\n    }\n    return 0;\n}", "item_id": 0, "repo": "steliostss/ntua-os", "file": "askisi1/ask1.2/fconc.c", "last_update_at": "2018-12-28T23:16:09+00:00", "question_id": "73a09de66a4167fe7510b6d84e1e153a61e6ee64_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(int argc, char **argv)\n{\n    int fd_out, i;\n    int oflags = O_CREAT | O_WRONLY | O_TRUNC;\n    mode_t mode = S_IRUSR | S_IWUSR;\n    int flag_same = 0;\n    if(argc < 3){\n        printf(\"Usage: ./fconc.out infile1 infile2 [outfile (default:fconc.out.out)]\\n\");\n        return(2);\n    }\n    else if (argc > 3) {\n        for (i=1; i < argc-1; i++){\n            if (!(strcmp(argv[i],argv[argc-1]))) {\n                flag_same = 1;\n                break;\n            }\n        }\n        if(flag_same == 1) {\n            printf(\"Warning: The requested output file matches one of the input files. File will be overwritten.\\n\");\n        }\n        fd_out = open(\"output_file\", oflags, mode);\n        for (i = 1; i < argc - 1; i++) {\n            write_file(fd_out, argv[i]);\n        }\n        fd_out = open(argv[argc - 1], oflags, mode);\n        write_file(fd_out, \"output_file\");\n    \tremove(\"output_file\");\n    }\n    else {\n        fd_out = open(\"fconc.out\", oflags, mode);\n        if (fd_out == -1) {\n            perror(\"Open\");\n            exit(1);\n        }\n        for (i = 1; i < argc; i++) {\n            write_file(fd_out, argv[i]);\n        }\n    }\n    return 0;\n"]]}
{"hexsha": "762f91c85ddd2c54584a4f1c7b0c2f0f87ce3840", "ext": "c", "lang": "C", "content": "jobject Tuple_internalCreate(HeapTuple ht, bool mustCopy)\n{\n\tjobject jht;\n\tPtr2Long htH;\n\n\tif(mustCopy)\n\t\tht = heap_copytuple(ht);\n\n\thtH.longVal = 0L; /* ensure that the rest is zeroed out */\n\thtH.ptrVal = ht;\n\tjht = JNI_newObject(s_Tuple_class, s_Tuple_init, htH.longVal);\n\treturn jht;\n}", "item_id": 2, "repo": "YangHao666666/hawq", "file": "src/pl/pljava/src/C/pljava/type/Tuple.c", "last_update_at": "2018-08-30T01:45:36+00:00", "question_id": "762f91c85ddd2c54584a4f1c7b0c2f0f87ce3840_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["jobject Tuple_internalCreate(HeapTuple ht, bool mustCopy)\n{\n\tjobject jht;\n\tPtr2Long htH;\n\tif(mustCopy)\n\t\tht = heap_copytuple(ht);\n\thtH.longVal = 0L; /* ensure that the rest is zeroed out */\n\thtH.ptrVal = ht;\n\tjht = JNI_newObject(s_Tuple_class, s_Tuple_init, htH.longVal);\n\treturn jht;\n"]]}
{"hexsha": "a49eb7146e56465cb03867f5af5bd5db3686b85e", "ext": "h", "lang": "C", "content": "const std::string AddNode(const std::string label)\n    {\n        std::string name = \"name\" + std::to_string(NodeCounter);\n        Dot << \"\\\"\" << name << \"\\\" [\\n\"\n               \"label = \" << \"\\\"<f0> \" << label << \"\\\"\\n\"\n               \"shape = \\\"record\\\"\\n\"\n               \"];\" << std::endl;\n        NodeCounter += 1;\n        return name;\n    }", "item_id": 1, "repo": "IKholopov/shishkin_forest", "file": "Framework/DotPrint.h", "last_update_at": "2018-06-20T16:22:31+00:00", "question_id": "a49eb7146e56465cb03867f5af5bd5db3686b85e_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["const std::string AddNode(const std::string label)\n    {\n        std::string name = \"name\" + std::to_string(NodeCounter);\n        Dot << \"\\\"\" << name << \"\\\" [\\n\"\n               \"label = \" << \"\\\"<f0> \" << label << \"\\\"\\n\"\n               \"shape = \\\"record\\\"\\n\"\n               \"];\" << std::endl;\n        NodeCounter += 1;\n        return name;\n"]]}
{"hexsha": "172a1c9ac13998f5cda3279364e0cdeb2042635c", "ext": "c", "lang": "C", "content": "VOID DriverSetInfo(\n    _In_ PROP_OBJECT_INFO *Context,\n    _In_ HWND hwndDlg\n)\n{\n    BOOL                    cond = FALSE, bResult = FALSE, fGroup, bRet;\n    INT                     nEndOfList, nEnd, nStart;\n    DWORD                   i, bytesNeeded, dwServices, dwGroups;\n    LPWSTR                  lpType;\n    SC_HANDLE               SchSCManager = NULL, schService = NULL;\n    LPENUM_SERVICE_STATUS   lpDependencies = NULL;\n    LPQUERY_SERVICE_CONFIG  psci = NULL;\n    LPSERVICE_DESCRIPTION   psd;\n    SERVICE_STATUS_PROCESS  ssp;\n    ENUM_SERVICE_STATUS     ess;\n    WCHAR                   szBuffer[MAX_PATH + 1];\n\n    __try {\n\n        ShowWindow(GetDlgItem(hwndDlg, IDC_QUERYFAIL), FALSE);\n\n        do {\n            SchSCManager = OpenSCManager(\n                NULL,\n                NULL,\n                SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);\n\n            if (SchSCManager == NULL)\n                break;\n\n            schService = OpenService(\n                SchSCManager,\n                Context->lpObjectName,\n                SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS);\n\n            if (schService == NULL)\n                break;\n\n            bytesNeeded = 0;\n            bResult = QueryServiceConfig(\n                schService,\n                NULL,\n                0,\n                &bytesNeeded);\n\n            if ((bResult == FALSE) && (bytesNeeded == 0))\n                break;\n\n            psci = (LPQUERY_SERVICE_CONFIG)supHeapAlloc(bytesNeeded);\n            if (psci == NULL)\n                break;\n\n            //disable comboboxes\n            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDENTSERVICES), FALSE);\n            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE), FALSE);\n            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONGROUP), FALSE);\n\n            bResult = QueryServiceConfig(schService, psci, bytesNeeded, &bytesNeeded);\n            if (bResult) {\n                //set key name (identical to object name)\n                SetDlgItemText(hwndDlg, IDC_SERVICE_KEYNAME, Context->lpObjectName);\n                //set image path info\n                SetDlgItemText(hwndDlg, IDC_SERVICE_IMAGEPATH, psci->lpBinaryPathName);\n                //set display name\n                SetDlgItemText(hwndDlg, IDC_SERVICE_DISPLAYNAME, psci->lpDisplayName);\n                //set load order group\n                SetDlgItemText(hwndDlg, IDC_SERVICE_LOADORDERGROUP, psci->lpLoadOrderGroup);\n\n                //Service Type\n                lpType = T_UnknownType;\n                switch (psci->dwServiceType) {\n                case SERVICE_KERNEL_DRIVER:\n                    lpType = TEXT(\"Kernel-Mode Driver\");\n                    break;\n                case SERVICE_FILE_SYSTEM_DRIVER:\n                    lpType = TEXT(\"File System Driver\");\n                    break;\n                case SERVICE_ADAPTER:\n                    lpType = TEXT(\"Adapter\");\n                    break;\n                case SERVICE_RECOGNIZER_DRIVER:\n                    lpType = TEXT(\"File System Recognizer\");\n                    break;\n                case SERVICE_WIN32_OWN_PROCESS:\n                    lpType = TEXT(\"Own Process\");\n                    break;\n                case SERVICE_WIN32_SHARE_PROCESS:\n                    lpType = TEXT(\"Share Process\");\n                    break;\n                case (SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS):\n                    lpType = TEXT(\"Own Process (Interactive)\");\n                    SetDlgItemText(hwndDlg, ID_SERVICE_NAME, psci->lpServiceStartName);\n                    break;\n                case (SERVICE_WIN32_SHARE_PROCESS | SERVICE_INTERACTIVE_PROCESS):\n                    lpType = TEXT(\"Share Process (Interactive)\");\n                    SetDlgItemText(hwndDlg, ID_SERVICE_NAME, psci->lpServiceStartName);\n                    break;\n                }\n                SetDlgItemText(hwndDlg, ID_SERVICE_TYPE, lpType);\n\n                //Start Type\n                lpType = T_UnknownType;\n                switch (psci->dwStartType) {\n                case SERVICE_AUTO_START:\n                    lpType = TEXT(\"Auto\");\n                    break;\n                case SERVICE_BOOT_START:\n                    lpType = TEXT(\"Boot\");\n                    break;\n                case SERVICE_DEMAND_START:\n                    lpType = TEXT(\"On Demand\");\n                    break;\n                case SERVICE_DISABLED:\n                    lpType = TEXT(\"Disabled\");\n                    break;\n                case SERVICE_SYSTEM_START:\n                    lpType = TEXT(\"System\");\n                    break;\n                }\n                SetDlgItemText(hwndDlg, ID_SERVICE_START, lpType);\n\n                //Error Control\n                lpType = T_Unknown;\n                switch (psci->dwErrorControl) {\n                case SERVICE_ERROR_CRITICAL:\n                    lpType = TEXT(\"Critical\");\n                    break;\n                case SERVICE_ERROR_IGNORE:\n                    lpType = TEXT(\"Ignore\");\n                    break;\n                case SERVICE_ERROR_NORMAL:\n                    lpType = TEXT(\"Normal\");\n                    break;\n                case SERVICE_ERROR_SEVERE:\n                    lpType = TEXT(\"Severe\");\n                    break;\n                }\n                SetDlgItemText(hwndDlg, ID_SERVICE_ERROR, lpType);\n\n                //dwTagId\n                if (psci->dwTagId) {\n                    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));\n                    ultostr(psci->dwTagId, szBuffer);\n                    SetDlgItemText(hwndDlg, ID_SERVICE_TAG, szBuffer);\n                }\n                else {\n                    //not assigned tag\n                    SetDlgItemText(hwndDlg, ID_SERVICE_TAG, L\"\");\n                }\n\n                //State\n                RtlSecureZeroMemory(&ssp, sizeof(ssp));\n                if (QueryServiceStatusEx(schService, SC_STATUS_PROCESS_INFO,\n                    (LPBYTE)&ssp, sizeof(ssp), &bytesNeeded))\n                {\n                    lpType = T_Unknown;\n                    switch (ssp.dwCurrentState) {\n                    case SERVICE_STOPPED:\n                        lpType = TEXT(\"Stopped\");\n                        break;\n                    case SERVICE_START_PENDING:\n                        lpType = TEXT(\"Start Pending\");\n                        break;\n                    case SERVICE_STOP_PENDING:\n                        lpType = TEXT(\"Stop Pending\");\n                        break;\n                    case SERVICE_RUNNING:\n                        lpType = TEXT(\"Running\");\n                        break;\n                    case SERVICE_CONTINUE_PENDING:\n                        lpType = TEXT(\"Continue Pending\");\n                        break;\n                    case SERVICE_PAUSE_PENDING:\n                        lpType = TEXT(\"Pause Pending\");\n                        break;\n                    case SERVICE_PAUSED:\n                        lpType = TEXT(\"Paused\");\n                        break;\n                    }\n                    SetDlgItemText(hwndDlg, ID_SERVICE_CURRENT, lpType);\n                }\n                else {\n                    SetDlgItemText(hwndDlg, ID_SERVICE_CURRENT, T_CannotQuery);\n                }\n\n                //Service Description\n                bRet = FALSE;\n                SetDlgItemText(hwndDlg, ID_SERVICE_DESCRIPTION, L\"\");\n                bytesNeeded = 0x1000;\n                psd = (LPSERVICE_DESCRIPTION)supHeapAlloc(bytesNeeded);\n                if (psd) {\n\n                    bRet = QueryServiceConfig2(\n                        schService,\n                        SERVICE_CONFIG_DESCRIPTION,\n                        (LPBYTE)psd,\n                        bytesNeeded,\n                        &bytesNeeded);\n\n                    if ((bRet == FALSE) && (bytesNeeded != 0)) {\n                        supHeapFree(psd);\n                        psd = (LPSERVICE_DESCRIPTION)supHeapAlloc(bytesNeeded);\n                    }\n                    if (psd) {\n                        //set description or hide window\n                        bRet = QueryServiceConfig2(\n                            schService,\n                            SERVICE_CONFIG_DESCRIPTION,\n                            (LPBYTE)psd,\n                            bytesNeeded,\n                            &bytesNeeded);\n\n                        if (bRet) {\n                            SetDlgItemText(hwndDlg, IDC_SERVICE_DESCRIPTION, psd->lpDescription);\n                        }\n                        supHeapFree(psd);\n                    }\n                }\n                if (bRet == FALSE) {\n                    //not enough memory, hide description window\n                    ShowWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DESCRIPTION), SW_HIDE);\n                }\n\n\n                //Service Dependencies\n                if (psci->lpDependencies) {\n\n                    //first list DependsOnService, DependsOnGroup\n\n                    nEndOfList = 0;\n                    nEnd = 0;\n                    nStart = 0;\n                    dwGroups = 0;\n                    dwServices = 0;\n\n                    //calc total number of symbols\n                    while ((psci->lpDependencies[nEndOfList] != L'\\0') || (psci->lpDependencies[nEndOfList + 1] != L'\\0'))\n                        nEndOfList++;\n\n                    if (nEndOfList > 0) {\n\n                        SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONGROUP, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0);\n                        SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0);\n\n                        //iterate through MULTI_SZ string\n                        do {\n                            while (psci->lpDependencies[nEnd] != TEXT('\\0')) {\n                                nEnd++;\n                            }\n\n                            RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));\n                            //maximum bytes that can be copied is sizeof(szBuffer)\n                            _strncpy(szBuffer, sizeof(szBuffer), &psci->lpDependencies[nStart], nEnd);\n\n                            //check if dependency is a group (has \"+\" before name)\n                            fGroup = (szBuffer[0] == SC_GROUP_IDENTIFIER);\n                            if (fGroup) {\n                                SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONGROUP, CB_ADDSTRING,\n                                    (WPARAM)0, (LPARAM)&szBuffer[1]);\n                                dwGroups++;\n                            }\n                            else {\n                                SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE, CB_ADDSTRING,\n                                    (WPARAM)0, (LPARAM)&szBuffer);\n                                dwServices++;\n                            }\n                            nEnd++;\n                            nStart = nEnd;\n                        } while (nEnd < nEndOfList);\n\n                        //group present, enable combobox\n                        if (dwGroups > 0) {\n                            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONGROUP), TRUE);\n                            SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONGROUP, CB_SETCURSEL,\n                                (WPARAM)0, (LPARAM)0);\n                        }\n                        //service present, enable combobox\n                        if (dwServices > 0) {\n                            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE), TRUE);\n                            SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE, CB_SETCURSEL,\n                                (WPARAM)0, (LPARAM)0);\n                        }\n                    } //if (nEndOfList > 0)\n\n                    //second list services that depends on this service\n                    SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDENTSERVICES, CB_RESETCONTENT,\n                        (WPARAM)0, (LPARAM)0);\n\n                    dwServices = 0;\n                    bytesNeeded = 1024;\n                    bRet = FALSE;\n\n                    //avoid SCM unexpected behaviour by using preallocated buffer\n                    lpDependencies = (LPENUM_SERVICE_STATUS)supHeapAlloc(bytesNeeded);\n                    if (lpDependencies) {\n\n                        bRet = EnumDependentServices(\n                            schService,\n                            SERVICE_STATE_ALL,\n                            lpDependencies,\n                            bytesNeeded,\n                            &bytesNeeded,\n                            &dwServices);\n\n                        if (bRet && (GetLastError() == ERROR_MORE_DATA)) {\n                            //more memory needed for enum\n                            supHeapFree(lpDependencies);\n                            dwServices = 0;\n                            lpDependencies = (LPENUM_SERVICE_STATUS)supHeapAlloc((SIZE_T)bytesNeeded);\n                            if (lpDependencies) {\n\n                                bRet = EnumDependentServices(\n                                    schService,\n                                    SERVICE_STATE_ALL,\n                                    lpDependencies,\n                                    bytesNeeded,\n                                    &bytesNeeded,\n                                    &dwServices);\n\n                            }\n                        }\n\n                        if (lpDependencies) {\n                            //list dependents\n                            if (bRet && dwServices) {\n                                for (i = 0; i < dwServices; i++) {\n                                    ess = *(lpDependencies + i);\n\n                                    SendDlgItemMessage(\n                                        hwndDlg,\n                                        IDC_SERVICE_DEPENDENTSERVICES,\n                                        CB_ADDSTRING,\n                                        (WPARAM)0,\n                                        (LPARAM)ess.lpServiceName);\n                                }\n                                //enable combobox and set current selection to the first item\n                                EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDENTSERVICES), TRUE);\n\n                                SendDlgItemMessage(\n                                    hwndDlg,\n                                    IDC_SERVICE_DEPENDENTSERVICES,\n                                    CB_SETCURSEL,\n                                    (WPARAM)0,\n                                    (LPARAM)0);\n                            }\n                            supHeapFree(lpDependencies);\n                        }\n                    }\n                } //if (psi->lpDependencies)\n            } //bResult != FALSE\n\n            CloseServiceHandle(schService);\n            schService = NULL;\n        } while (cond);\n\n        if (psci != NULL)\n            supHeapFree(psci);\n\n        if (schService)\n            CloseServiceHandle(schService);\n\n        if (SchSCManager)\n            CloseServiceHandle(SchSCManager);\n\n        if (bResult == FALSE) {\n            EnumChildWindows(hwndDlg, DriverShowChildWindows, SW_HIDE);\n            ShowWindow(GetDlgItem(hwndDlg, IDC_QUERYFAIL), SW_SHOW);\n        }\n        else {\n            SetFocus(GetDlgItem(hwndDlg, ID_SERVICE_JUMPTOKEY));\n        }\n\n    }\n    __except (exceptFilter(GetExceptionCode(), GetExceptionInformation())) {\n        EnumChildWindows(hwndDlg, DriverShowChildWindows, SW_HIDE);\n        ShowWindow(GetDlgItem(hwndDlg, IDC_QUERYFAIL), SW_SHOW);\n        return;\n    }\n}", "item_id": 0, "repo": "ralex1975/WinObjEx64", "file": "Source/WinObjEx64/props/propDriver.c", "last_update_at": "2018-12-27T11:43:32+00:00", "question_id": "172a1c9ac13998f5cda3279364e0cdeb2042635c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["VOID DriverSetInfo(\n    _In_ PROP_OBJECT_INFO *Context,\n    _In_ HWND hwndDlg\n)\n{\n    BOOL                    cond = FALSE, bResult = FALSE, fGroup, bRet;\n    INT                     nEndOfList, nEnd, nStart;\n    DWORD                   i, bytesNeeded, dwServices, dwGroups;\n    LPWSTR                  lpType;\n    SC_HANDLE               SchSCManager = NULL, schService = NULL;\n    LPENUM_SERVICE_STATUS   lpDependencies = NULL;\n    LPQUERY_SERVICE_CONFIG  psci = NULL;\n    LPSERVICE_DESCRIPTION   psd;\n    SERVICE_STATUS_PROCESS  ssp;\n    ENUM_SERVICE_STATUS     ess;\n    WCHAR                   szBuffer[MAX_PATH + 1];\n    __try {\n        ShowWindow(GetDlgItem(hwndDlg, IDC_QUERYFAIL), FALSE);\n        do {\n            SchSCManager = OpenSCManager(\n                NULL,\n                NULL,\n                SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);\n            if (SchSCManager == NULL)\n                break;\n            schService = OpenService(\n                SchSCManager,\n                Context->lpObjectName,\n                SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS);\n            if (schService == NULL)\n                break;\n            bytesNeeded = 0;\n            bResult = QueryServiceConfig(\n                schService,\n                NULL,\n                0,\n                &bytesNeeded);\n            if ((bResult == FALSE) && (bytesNeeded == 0))\n                break;\n            psci = (LPQUERY_SERVICE_CONFIG)supHeapAlloc(bytesNeeded);\n            if (psci == NULL)\n                break;\n            //disable comboboxes\n            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDENTSERVICES), FALSE);\n            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE), FALSE);\n            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONGROUP), FALSE);\n            bResult = QueryServiceConfig(schService, psci, bytesNeeded, &bytesNeeded);\n            if (bResult) {\n                //set key name (identical to object name)\n                SetDlgItemText(hwndDlg, IDC_SERVICE_KEYNAME, Context->lpObjectName);\n                //set image path info\n                SetDlgItemText(hwndDlg, IDC_SERVICE_IMAGEPATH, psci->lpBinaryPathName);\n                //set display name\n                SetDlgItemText(hwndDlg, IDC_SERVICE_DISPLAYNAME, psci->lpDisplayName);\n                //set load order group\n                SetDlgItemText(hwndDlg, IDC_SERVICE_LOADORDERGROUP, psci->lpLoadOrderGroup);\n                //Service Type\n                lpType = T_UnknownType;\n                switch (psci->dwServiceType) {\n                case SERVICE_KERNEL_DRIVER:\n                    lpType = TEXT(\"Kernel-Mode Driver\");\n                    break;\n                case SERVICE_FILE_SYSTEM_DRIVER:\n                    lpType = TEXT(\"File System Driver\");\n                    break;\n                case SERVICE_ADAPTER:\n                    lpType = TEXT(\"Adapter\");\n                    break;\n                case SERVICE_RECOGNIZER_DRIVER:\n                    lpType = TEXT(\"File System Recognizer\");\n                    break;\n                case SERVICE_WIN32_OWN_PROCESS:\n                    lpType = TEXT(\"Own Process\");\n                    break;\n                case SERVICE_WIN32_SHARE_PROCESS:\n                    lpType = TEXT(\"Share Process\");\n                    break;\n                case (SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS):\n                    lpType = TEXT(\"Own Process (Interactive)\");\n                    SetDlgItemText(hwndDlg, ID_SERVICE_NAME, psci->lpServiceStartName);\n                    break;\n                case (SERVICE_WIN32_SHARE_PROCESS | SERVICE_INTERACTIVE_PROCESS):\n                    lpType = TEXT(\"Share Process (Interactive)\");\n                    SetDlgItemText(hwndDlg, ID_SERVICE_NAME, psci->lpServiceStartName);\n                    break;\n                }\n                SetDlgItemText(hwndDlg, ID_SERVICE_TYPE, lpType);\n                //Start Type\n                lpType = T_UnknownType;\n                switch (psci->dwStartType) {\n                case SERVICE_AUTO_START:\n                    lpType = TEXT(\"Auto\");\n                    break;\n                case SERVICE_BOOT_START:\n                    lpType = TEXT(\"Boot\");\n                    break;\n                case SERVICE_DEMAND_START:\n                    lpType = TEXT(\"On Demand\");\n                    break;\n                case SERVICE_DISABLED:\n                    lpType = TEXT(\"Disabled\");\n                    break;\n                case SERVICE_SYSTEM_START:\n                    lpType = TEXT(\"System\");\n                    break;\n                }\n                SetDlgItemText(hwndDlg, ID_SERVICE_START, lpType);\n                //Error Control\n                lpType = T_Unknown;\n                switch (psci->dwErrorControl) {\n                case SERVICE_ERROR_CRITICAL:\n                    lpType = TEXT(\"Critical\");\n                    break;\n                case SERVICE_ERROR_IGNORE:\n                    lpType = TEXT(\"Ignore\");\n                    break;\n                case SERVICE_ERROR_NORMAL:\n                    lpType = TEXT(\"Normal\");\n                    break;\n                case SERVICE_ERROR_SEVERE:\n                    lpType = TEXT(\"Severe\");\n                    break;\n                }\n                SetDlgItemText(hwndDlg, ID_SERVICE_ERROR, lpType);\n                //dwTagId\n                if (psci->dwTagId) {\n                    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));\n                    ultostr(psci->dwTagId, szBuffer);\n                    SetDlgItemText(hwndDlg, ID_SERVICE_TAG, szBuffer);\n                }\n                else {\n                    //not assigned tag\n                    SetDlgItemText(hwndDlg, ID_SERVICE_TAG, L\"\");\n                }\n                //State\n                RtlSecureZeroMemory(&ssp, sizeof(ssp));\n                if (QueryServiceStatusEx(schService, SC_STATUS_PROCESS_INFO,\n                    (LPBYTE)&ssp, sizeof(ssp), &bytesNeeded))\n                {\n                    lpType = T_Unknown;\n                    switch (ssp.dwCurrentState) {\n                    case SERVICE_STOPPED:\n                        lpType = TEXT(\"Stopped\");\n                        break;\n                    case SERVICE_START_PENDING:\n                        lpType = TEXT(\"Start Pending\");\n                        break;\n                    case SERVICE_STOP_PENDING:\n                        lpType = TEXT(\"Stop Pending\");\n                        break;\n                    case SERVICE_RUNNING:\n                        lpType = TEXT(\"Running\");\n                        break;\n                    case SERVICE_CONTINUE_PENDING:\n                        lpType = TEXT(\"Continue Pending\");\n                        break;\n                    case SERVICE_PAUSE_PENDING:\n                        lpType = TEXT(\"Pause Pending\");\n                        break;\n                    case SERVICE_PAUSED:\n                        lpType = TEXT(\"Paused\");\n                        break;\n                    }\n                    SetDlgItemText(hwndDlg, ID_SERVICE_CURRENT, lpType);\n                }\n                else {\n                    SetDlgItemText(hwndDlg, ID_SERVICE_CURRENT, T_CannotQuery);\n                }\n                //Service Description\n                bRet = FALSE;\n                SetDlgItemText(hwndDlg, ID_SERVICE_DESCRIPTION, L\"\");\n                bytesNeeded = 0x1000;\n                psd = (LPSERVICE_DESCRIPTION)supHeapAlloc(bytesNeeded);\n                if (psd) {\n                    bRet = QueryServiceConfig2(\n                        schService,\n                        SERVICE_CONFIG_DESCRIPTION,\n                        (LPBYTE)psd,\n                        bytesNeeded,\n                        &bytesNeeded);\n                    if ((bRet == FALSE) && (bytesNeeded != 0)) {\n                        supHeapFree(psd);\n                        psd = (LPSERVICE_DESCRIPTION)supHeapAlloc(bytesNeeded);\n                    }\n                    if (psd) {\n                        //set description or hide window\n                        bRet = QueryServiceConfig2(\n                            schService,\n                            SERVICE_CONFIG_DESCRIPTION,\n                            (LPBYTE)psd,\n                            bytesNeeded,\n                            &bytesNeeded);\n                        if (bRet) {\n                            SetDlgItemText(hwndDlg, IDC_SERVICE_DESCRIPTION, psd->lpDescription);\n                        }\n                        supHeapFree(psd);\n                    }\n                }\n                if (bRet == FALSE) {\n                    //not enough memory, hide description window\n                    ShowWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DESCRIPTION), SW_HIDE);\n                }\n                //Service Dependencies\n                if (psci->lpDependencies) {\n                    //first list DependsOnService, DependsOnGroup\n                    nEndOfList = 0;\n                    nEnd = 0;\n                    nStart = 0;\n                    dwGroups = 0;\n                    dwServices = 0;\n                    //calc total number of symbols\n                    while ((psci->lpDependencies[nEndOfList] != L'\\0') || (psci->lpDependencies[nEndOfList + 1] != L'\\0'))\n                        nEndOfList++;\n                    if (nEndOfList > 0) {\n                        SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONGROUP, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0);\n                        SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0);\n                        //iterate through MULTI_SZ string\n                        do {\n                            while (psci->lpDependencies[nEnd] != TEXT('\\0')) {\n                                nEnd++;\n                            }\n                            RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));\n                            //maximum bytes that can be copied is sizeof(szBuffer)\n                            _strncpy(szBuffer, sizeof(szBuffer), &psci->lpDependencies[nStart], nEnd);\n                            //check if dependency is a group (has \"+\" before name)\n                            fGroup = (szBuffer[0] == SC_GROUP_IDENTIFIER);\n                            if (fGroup) {\n                                SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONGROUP, CB_ADDSTRING,\n                                    (WPARAM)0, (LPARAM)&szBuffer[1]);\n                                dwGroups++;\n                            }\n                            else {\n                                SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE, CB_ADDSTRING,\n                                    (WPARAM)0, (LPARAM)&szBuffer);\n                                dwServices++;\n                            }\n                            nEnd++;\n                            nStart = nEnd;\n                        } while (nEnd < nEndOfList);\n                        //group present, enable combobox\n                        if (dwGroups > 0) {\n                            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONGROUP), TRUE);\n                            SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONGROUP, CB_SETCURSEL,\n                                (WPARAM)0, (LPARAM)0);\n                        }\n                        //service present, enable combobox\n                        if (dwServices > 0) {\n                            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE), TRUE);\n                            SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE, CB_SETCURSEL,\n                                (WPARAM)0, (LPARAM)0);\n                        }\n                    } //if (nEndOfList > 0)\n                    //second list services that depends on this service\n                    SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDENTSERVICES, CB_RESETCONTENT,\n                        (WPARAM)0, (LPARAM)0);\n                    dwServices = 0;\n                    bytesNeeded = 1024;\n                    bRet = FALSE;\n                    //avoid SCM unexpected behaviour by using preallocated buffer\n                    lpDependencies = (LPENUM_SERVICE_STATUS)supHeapAlloc(bytesNeeded);\n                    if (lpDependencies) {\n                        bRet = EnumDependentServices(\n                            schService,\n                            SERVICE_STATE_ALL,\n                            lpDependencies,\n                            bytesNeeded,\n                            &bytesNeeded,\n                            &dwServices);\n                        if (bRet && (GetLastError() == ERROR_MORE_DATA)) {\n                            //more memory needed for enum\n                            supHeapFree(lpDependencies);\n                            dwServices = 0;\n                            lpDependencies = (LPENUM_SERVICE_STATUS)supHeapAlloc((SIZE_T)bytesNeeded);\n                            if (lpDependencies) {\n                                bRet = EnumDependentServices(\n                                    schService,\n                                    SERVICE_STATE_ALL,\n                                    lpDependencies,\n                                    bytesNeeded,\n                                    &bytesNeeded,\n                                    &dwServices);\n                            }\n                        }\n                        if (lpDependencies) {\n                            //list dependents\n                            if (bRet && dwServices) {\n                                for (i = 0; i < dwServices; i++) {\n                                    ess = *(lpDependencies + i);\n                                    SendDlgItemMessage(\n                                        hwndDlg,\n                                        IDC_SERVICE_DEPENDENTSERVICES,\n                                        CB_ADDSTRING,\n                                        (WPARAM)0,\n                                        (LPARAM)ess.lpServiceName);\n                                }\n                                //enable combobox and set current selection to the first item\n                                EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDENTSERVICES), TRUE);\n                                SendDlgItemMessage(\n                                    hwndDlg,\n                                    IDC_SERVICE_DEPENDENTSERVICES,\n                                    CB_SETCURSEL,\n                                    (WPARAM)0,\n                                    (LPARAM)0);\n                            }\n                            supHeapFree(lpDependencies);\n                        }\n                    }\n                } //if (psi->lpDependencies)\n            } //bResult != FALSE\n            CloseServiceHandle(schService);\n            schService = NULL;\n        } while (cond);\n        if (psci != NULL)\n            supHeapFree(psci);\n        if (schService)\n            CloseServiceHandle(schService);\n        if (SchSCManager)\n            CloseServiceHandle(SchSCManager);\n        if (bResult == FALSE) {\n            EnumChildWindows(hwndDlg, DriverShowChildWindows, SW_HIDE);\n            ShowWindow(GetDlgItem(hwndDlg, IDC_QUERYFAIL), SW_SHOW);\n        }\n        else {\n            SetFocus(GetDlgItem(hwndDlg, ID_SERVICE_JUMPTOKEY));\n        }\n    }\n    __except (exceptFilter(GetExceptionCode(), GetExceptionInformation())) {\n        EnumChildWindows(hwndDlg, DriverShowChildWindows, SW_HIDE);\n        ShowWindow(GetDlgItem(hwndDlg, IDC_QUERYFAIL), SW_SHOW);\n        return;\n    }\n"]]}
{"hexsha": "ad4b773448d270891e962d3e0e55bac46816639b", "ext": "c", "lang": "C", "content": "void\neventHandler_initialize(jbyte sessionID)\n{\n    jvmtiError error;\n    jint i;\n\n    requestIdCounter = 1;\n    currentSessionID = sessionID;\n\n    /* This is for BEGIN_CALLBACK/END_CALLBACK handling, make sure this\n     *   is done while none of these callbacks are active.\n     */\n    active_callbacks = 0;\n    vm_death_callback_active = JNI_FALSE;\n    callbackLock = debugMonitorCreate(\"JDWP Callback Lock\");\n    callbackBlock = debugMonitorCreate(\"JDWP Callback Block\");\n\n    handlerLock = debugMonitorCreate(\"JDWP Event Handler Lock\");\n\n    for (i = EI_min; i <= EI_max; ++i) {\n        getHandlerChain(i)->first = NULL;\n    }\n\n    /*\n     * Permanently enabled some events.\n     */\n    error = threadControl_setEventMode(JVMTI_ENABLE,\n                                      EI_VM_INIT, NULL);\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't enable vm init events\");\n    }\n    error = threadControl_setEventMode(JVMTI_ENABLE,\n                                      EI_VM_DEATH, NULL);\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't enable vm death events\");\n    }\n    error = threadControl_setEventMode(JVMTI_ENABLE,\n                                      EI_THREAD_START, NULL);\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't enable thread start events\");\n    }\n    error = threadControl_setEventMode(JVMTI_ENABLE,\n                                       EI_THREAD_END, NULL);\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't enable thread end events\");\n    }\n    error = threadControl_setEventMode(JVMTI_ENABLE,\n                                       EI_CLASS_PREPARE, NULL);\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't enable class prepare events\");\n    }\n    error = threadControl_setEventMode(JVMTI_ENABLE,\n                                       EI_GC_FINISH, NULL);\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't enable garbage collection finish events\");\n    }\n\n    (void)memset(&(gdata->callbacks),0,sizeof(gdata->callbacks));\n    /* Event callback for JVMTI_EVENT_SINGLE_STEP */\n    gdata->callbacks.SingleStep                 = &cbSingleStep;\n    /* Event callback for JVMTI_EVENT_BREAKPOINT */\n    gdata->callbacks.Breakpoint                 = &cbBreakpoint;\n    /* Event callback for JVMTI_EVENT_FRAME_POP */\n    gdata->callbacks.FramePop                   = &cbFramePop;\n    /* Event callback for JVMTI_EVENT_EXCEPTION */\n    gdata->callbacks.Exception                  = &cbException;\n    /* Event callback for JVMTI_EVENT_THREAD_START */\n    gdata->callbacks.ThreadStart                = &cbThreadStart;\n    /* Event callback for JVMTI_EVENT_THREAD_END */\n    gdata->callbacks.ThreadEnd                  = &cbThreadEnd;\n    /* Event callback for JVMTI_EVENT_CLASS_PREPARE */\n    gdata->callbacks.ClassPrepare               = &cbClassPrepare;\n    /* Event callback for JVMTI_EVENT_CLASS_LOAD */\n    gdata->callbacks.ClassLoad                  = &cbClassLoad;\n    /* Event callback for JVMTI_EVENT_FIELD_ACCESS */\n    gdata->callbacks.FieldAccess                = &cbFieldAccess;\n    /* Event callback for JVMTI_EVENT_FIELD_MODIFICATION */\n    gdata->callbacks.FieldModification          = &cbFieldModification;\n    /* Event callback for JVMTI_EVENT_EXCEPTION_CATCH */\n    gdata->callbacks.ExceptionCatch             = &cbExceptionCatch;\n    /* Event callback for JVMTI_EVENT_METHOD_ENTRY */\n    gdata->callbacks.MethodEntry                = &cbMethodEntry;\n    /* Event callback for JVMTI_EVENT_METHOD_EXIT */\n    gdata->callbacks.MethodExit                 = &cbMethodExit;\n    /* Event callback for JVMTI_EVENT_MONITOR_CONTENDED_ENTER */\n    gdata->callbacks.MonitorContendedEnter      = &cbMonitorContendedEnter;\n    /* Event callback for JVMTI_EVENT_MONITOR_CONTENDED_ENTERED */\n    gdata->callbacks.MonitorContendedEntered    = &cbMonitorContendedEntered;\n    /* Event callback for JVMTI_EVENT_MONITOR_WAIT */\n    gdata->callbacks.MonitorWait                = &cbMonitorWait;\n    /* Event callback for JVMTI_EVENT_MONITOR_WAITED */\n    gdata->callbacks.MonitorWaited              = &cbMonitorWaited;\n    /* Event callback for JVMTI_EVENT_VM_INIT */\n    gdata->callbacks.VMInit                     = &cbVMInit;\n    /* Event callback for JVMTI_EVENT_VM_DEATH */\n    gdata->callbacks.VMDeath                    = &cbVMDeath;\n    /* Event callback for JVMTI_EVENT_GARBAGE_COLLECTION_FINISH */\n    gdata->callbacks.GarbageCollectionFinish    = &cbGarbageCollectionFinish;\n\n    error = JVMTI_FUNC_PTR(gdata->jvmti,SetEventCallbacks)\n                (gdata->jvmti, &(gdata->callbacks), sizeof(gdata->callbacks));\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't set event callbacks\");\n    }\n\n    /* Notify other modules that the event callbacks are in place */\n    threadControl_onHook();\n\n    /* Get the event helper thread initialized */\n    eventHelper_initialize(sessionID);\n}", "item_id": 37, "repo": "siweilxy/openjdkstudy", "file": "src/jdk.jdwp.agent/share/native/libjdwp/eventHandler.c", "last_update_at": "2018-06-23T10:04:56+00:00", "question_id": "ad4b773448d270891e962d3e0e55bac46816639b_37", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\neventHandler_initialize(jbyte sessionID)\n{\n    jvmtiError error;\n    jint i;\n    requestIdCounter = 1;\n    currentSessionID = sessionID;\n    /* This is for BEGIN_CALLBACK/END_CALLBACK handling, make sure this\n     *   is done while none of these callbacks are active.\n     */\n    active_callbacks = 0;\n    vm_death_callback_active = JNI_FALSE;\n    callbackLock = debugMonitorCreate(\"JDWP Callback Lock\");\n    callbackBlock = debugMonitorCreate(\"JDWP Callback Block\");\n    handlerLock = debugMonitorCreate(\"JDWP Event Handler Lock\");\n    for (i = EI_min; i <= EI_max; ++i) {\n        getHandlerChain(i)->first = NULL;\n    }\n    /*\n     * Permanently enabled some events.\n     */\n    error = threadControl_setEventMode(JVMTI_ENABLE,\n                                      EI_VM_INIT, NULL);\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't enable vm init events\");\n    }\n    error = threadControl_setEventMode(JVMTI_ENABLE,\n                                      EI_VM_DEATH, NULL);\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't enable vm death events\");\n    }\n    error = threadControl_setEventMode(JVMTI_ENABLE,\n                                      EI_THREAD_START, NULL);\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't enable thread start events\");\n    }\n    error = threadControl_setEventMode(JVMTI_ENABLE,\n                                       EI_THREAD_END, NULL);\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't enable thread end events\");\n    }\n    error = threadControl_setEventMode(JVMTI_ENABLE,\n                                       EI_CLASS_PREPARE, NULL);\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't enable class prepare events\");\n    }\n    error = threadControl_setEventMode(JVMTI_ENABLE,\n                                       EI_GC_FINISH, NULL);\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't enable garbage collection finish events\");\n    }\n    (void)memset(&(gdata->callbacks),0,sizeof(gdata->callbacks));\n    /* Event callback for JVMTI_EVENT_SINGLE_STEP */\n    gdata->callbacks.SingleStep                 = &cbSingleStep;\n    /* Event callback for JVMTI_EVENT_BREAKPOINT */\n    gdata->callbacks.Breakpoint                 = &cbBreakpoint;\n    /* Event callback for JVMTI_EVENT_FRAME_POP */\n    gdata->callbacks.FramePop                   = &cbFramePop;\n    /* Event callback for JVMTI_EVENT_EXCEPTION */\n    gdata->callbacks.Exception                  = &cbException;\n    /* Event callback for JVMTI_EVENT_THREAD_START */\n    gdata->callbacks.ThreadStart                = &cbThreadStart;\n    /* Event callback for JVMTI_EVENT_THREAD_END */\n    gdata->callbacks.ThreadEnd                  = &cbThreadEnd;\n    /* Event callback for JVMTI_EVENT_CLASS_PREPARE */\n    gdata->callbacks.ClassPrepare               = &cbClassPrepare;\n    /* Event callback for JVMTI_EVENT_CLASS_LOAD */\n    gdata->callbacks.ClassLoad                  = &cbClassLoad;\n    /* Event callback for JVMTI_EVENT_FIELD_ACCESS */\n    gdata->callbacks.FieldAccess                = &cbFieldAccess;\n    /* Event callback for JVMTI_EVENT_FIELD_MODIFICATION */\n    gdata->callbacks.FieldModification          = &cbFieldModification;\n    /* Event callback for JVMTI_EVENT_EXCEPTION_CATCH */\n    gdata->callbacks.ExceptionCatch             = &cbExceptionCatch;\n    /* Event callback for JVMTI_EVENT_METHOD_ENTRY */\n    gdata->callbacks.MethodEntry                = &cbMethodEntry;\n    /* Event callback for JVMTI_EVENT_METHOD_EXIT */\n    gdata->callbacks.MethodExit                 = &cbMethodExit;\n    /* Event callback for JVMTI_EVENT_MONITOR_CONTENDED_ENTER */\n    gdata->callbacks.MonitorContendedEnter      = &cbMonitorContendedEnter;\n    /* Event callback for JVMTI_EVENT_MONITOR_CONTENDED_ENTERED */\n    gdata->callbacks.MonitorContendedEntered    = &cbMonitorContendedEntered;\n    /* Event callback for JVMTI_EVENT_MONITOR_WAIT */\n    gdata->callbacks.MonitorWait                = &cbMonitorWait;\n    /* Event callback for JVMTI_EVENT_MONITOR_WAITED */\n    gdata->callbacks.MonitorWaited              = &cbMonitorWaited;\n    /* Event callback for JVMTI_EVENT_VM_INIT */\n    gdata->callbacks.VMInit                     = &cbVMInit;\n    /* Event callback for JVMTI_EVENT_VM_DEATH */\n    gdata->callbacks.VMDeath                    = &cbVMDeath;\n    /* Event callback for JVMTI_EVENT_GARBAGE_COLLECTION_FINISH */\n    gdata->callbacks.GarbageCollectionFinish    = &cbGarbageCollectionFinish;\n    error = JVMTI_FUNC_PTR(gdata->jvmti,SetEventCallbacks)\n                (gdata->jvmti, &(gdata->callbacks), sizeof(gdata->callbacks));\n    if (error != JVMTI_ERROR_NONE) {\n        EXIT_ERROR(error,\"Can't set event callbacks\");\n    }\n    /* Notify other modules that the event callbacks are in place */\n    threadControl_onHook();\n    /* Get the event helper thread initialized */\n    eventHelper_initialize(sessionID);\n"]]}
{"hexsha": "be2bfb86925c9e0e8c5d6ce8f63fe00a5e074c4b", "ext": "c", "lang": "C", "content": "SWIGINTERN PyObject *_wrap_gsl_matrix_long_min(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {\n  PyObject *resultobj = 0;\n  gsl_matrix_long *arg1 = (gsl_matrix_long *) 0 ;\n  PyObject * obj0 = 0 ;\n  char *  kwnames[] = {\n    (char *) \"IN\", NULL \n  };\n  double result;\n  \n  \n  PyArrayObject * _PyMatrix1 = NULL;\n  TYPE_VIEW_gsl_matrix_long _matrix1;\n  \n  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)\"O:gsl_matrix_long_min\",kwnames,&obj0)) SWIG_fail;\n  \n  {\n    PyGSL_array_index_t stride;\n    if(PyGSL_MATRIX_CONVERT(obj0, arg1, _PyMatrix1, _matrix1,\n        PyGSL_INPUT_ARRAY, gsl_matrix_long, 1, &stride) != GSL_SUCCESS)\n    goto fail;\t  \n  }\n  \n  result = (double)gsl_matrix_long_min((gsl_matrix_long const *)arg1);\n  resultobj = SWIG_From_double((double)(result));\n  {\n    Py_XDECREF(_PyMatrix1);\n    _PyMatrix1 = NULL;\n    FUNC_MESS_END();\n  }\n  return resultobj;\nfail:\n  {\n    Py_XDECREF(_PyMatrix1);\n    _PyMatrix1 = NULL;\n    FUNC_MESS_END();\n  }\n  return NULL;\n}", "item_id": 161, "repo": "juhnowski/FishingRod", "file": "production/pygsl-0.9.5/swig_src/block_wrap.c", "last_update_at": "2018-10-02T06:18:07+00:00", "question_id": "be2bfb86925c9e0e8c5d6ce8f63fe00a5e074c4b_161", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["SWIGINTERN PyObject *_wrap_gsl_matrix_long_min(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {\n  PyObject *resultobj = 0;\n  gsl_matrix_long *arg1 = (gsl_matrix_long *) 0 ;\n  PyObject * obj0 = 0 ;\n  char *  kwnames[] = {\n    (char *) \"IN\", NULL \n  };\n  double result;\n  PyArrayObject * _PyMatrix1 = NULL;\n  TYPE_VIEW_gsl_matrix_long _matrix1;\n  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)\"O:gsl_matrix_long_min\",kwnames,&obj0)) SWIG_fail;\n  {\n    PyGSL_array_index_t stride;\n    if(PyGSL_MATRIX_CONVERT(obj0, arg1, _PyMatrix1, _matrix1,\n        PyGSL_INPUT_ARRAY, gsl_matrix_long, 1, &stride) != GSL_SUCCESS)\n    goto fail;\t  \n  }\n  result = (double)gsl_matrix_long_min((gsl_matrix_long const *)arg1);\n  resultobj = SWIG_From_double((double)(result));\n  {\n    Py_XDECREF(_PyMatrix1);\n    _PyMatrix1 = NULL;\n    FUNC_MESS_END();\n  }\n  return resultobj;\nfail:\n  {\n    Py_XDECREF(_PyMatrix1);\n    _PyMatrix1 = NULL;\n    FUNC_MESS_END();\n  }\n  return NULL;\n"]]}
{"hexsha": "931c1bfe92e4796cc96d98227132ec70594d3f37", "ext": "c", "lang": "C", "content": "void frame_picture_mp_p_slice(VideoParameters *p_Vid, InputParameters *p_Inp)\r\n{\r\n  int   rd_pass = 0;\r\n  int   rd_qp = p_Vid->p_curr_frm_struct->qp;\r\n  float rateRatio = 1.0F;\r\n  int   wp_pass=0;\r\n  int   frame_type_pass = 0;\r\n  CodingInfo coding_info;\r\n  FrameCodingMethod best_method = REGULAR; \r\n  int frame_type = P_SLICE; \r\n  int apply_wp = 0;\r\n  int selection;\r\n\r\n  frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);\r\n  store_coding_and_rc_info(p_Vid, &coding_info);\r\n\r\n  if(p_Inp->WPIterMC)\r\n    p_Vid->frameOffsetAvail = 1; \r\n\r\n#if (DBG_IMAGE_MP)\r\n    printf(\"rd_pass = %d: %d (%.0f, %.0f, %.0f)\\n\", rd_pass, \r\n      p_Vid->frame_pic[0]->bits_per_picture, \r\n      p_Vid->frame_pic[0]->distortion.value[0], p_Vid->frame_pic[0]->distortion.value[1], p_Vid->frame_pic[0]->distortion.value[2]);\r\n#endif\r\n\r\n  rd_pass++;\r\n  if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)\r\n  {\r\n    frame_picture_mp_exit(p_Vid, &coding_info);\r\n    return;\r\n  }\r\n\r\n  // for P_Slice, consider WP  \r\n  wp_pass = 0;\r\n  if (p_Inp->GenerateMultiplePPS)\r\n  {\r\n    Slice *dummy_slice = NULL;\r\n\r\n    InitWP(p_Vid, p_Inp, 0);\r\n    if ( p_Inp->WPMCPrecision )\r\n      p_Vid->pWPX->curr_wp_rd_pass = p_Vid->pWPX->wp_rd_passes + 1;\r\n    init_slice_lite(p_Vid, &dummy_slice, 0);\r\n\r\n    if (p_Vid->TestWPPSlice(dummy_slice, 0) == 1)\r\n    {\r\n      // regular WP pass\r\n      p_Vid->active_pps = p_Vid->PicParSet[1];\r\n      if ( p_Inp->WPMCPrecision )\r\n        p_Vid->pWPX->curr_wp_rd_pass->algorithm = WP_REGULAR;\r\n      wp_pass = 1;\r\n    }\r\n    else if ( p_Inp->WPMCPrecision )\r\n    {\r\n      // WPMC pass\r\n      p_Vid->active_pps = p_Vid->PicParSet[1];\r\n      wp_pass = 1;\r\n    }  \r\n\r\n    // The way it is, the code would only reach here if prior conditional using \r\n    // generatemultiplepps is satisfied\r\n    if(wp_pass)\r\n    {\r\n      p_Vid->write_macroblock = FALSE;\r\n      p_Vid->p_curr_frm_struct->qp = p_Vid->qp;\r\n      frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);\r\n      selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);\r\n#if (DBG_IMAGE_MP)\r\n      printf(\"rd_pass = %d, selection = %d\\n\", rd_pass, selection);\r\n#endif\r\n#if (DBG_IMAGE_MP)\r\n      printf(\"rd_pass = %d: %d (%.0f, %.0f, %.0f)\\n\", rd_pass, \r\n        p_Vid->frame_pic[rd_pass]->bits_per_picture, \r\n        p_Vid->frame_pic[rd_pass]->distortion.value[0], p_Vid->frame_pic[rd_pass]->distortion.value[1], p_Vid->frame_pic[rd_pass]->distortion.value[2]);\r\n#endif\r\n\r\n      if (selection)\r\n      {\r\n        swap_frame_buffer(p_Vid, 0, rd_pass); \r\n        store_coding_and_rc_info(p_Vid, &coding_info);\r\n        best_method = EXP_WP;\r\n        apply_wp = 1;\r\n      }\r\n\r\n      if(p_Inp->WPMethod == 0 || p_Inp->WPMCPrecision) \r\n      {\r\n        wp_pass = 0;\r\n        if ( p_Inp->WPMCPrecision )\r\n          p_Vid->pWPX->curr_wp_rd_pass = p_Vid->pWPX->wp_rd_passes + 2;\r\n        if (p_Inp->WPMethod == 0 && p_Vid->TestWPPSlice(dummy_slice, 1) == 1)\r\n        {\r\n          // regular WP pass\r\n          p_Vid->active_pps = p_Vid->PicParSet[1];\r\n          if ( p_Inp->WPMCPrecision )\r\n            p_Vid->pWPX->curr_wp_rd_pass->algorithm = WP_REGULAR;\r\n          wp_pass = 1;\r\n        }\r\n        else if ( p_Inp->WPMCPrecision )\r\n        {\r\n          // WPMC pass\r\n          p_Vid->active_pps = p_Vid->PicParSet[1];\r\n          wp_pass = 1;\r\n        }\r\n\r\n        if(wp_pass)\r\n        {\r\n          p_Vid->write_macroblock = FALSE;\r\n          p_Vid->p_curr_frm_struct->qp = p_Vid->qp;\r\n          free_slice_list(p_Vid->frame_pic[rd_pass]);\r\n          free_storable_picture(p_Vid, p_Vid->enc_frame_picture[rd_pass]);\r\n          frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);\r\n          selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);\r\n#if (DBG_IMAGE_MP)\r\n          printf(\"rd_pass = %d, selection = %d\\n\", rd_pass, selection);\r\n#endif\r\n#if (DBG_IMAGE_MP)\r\n          printf(\"rd_pass = %d: %d (%.0f, %.0f, %.0f)\\n\", rd_pass, \r\n            p_Vid->frame_pic[rd_pass]->bits_per_picture, \r\n            p_Vid->frame_pic[rd_pass]->distortion.value[0], p_Vid->frame_pic[rd_pass]->distortion.value[1], p_Vid->frame_pic[rd_pass]->distortion.value[2]);\r\n#endif\r\n\r\n          if (selection)\r\n          {\r\n            swap_frame_buffer(p_Vid, 0, rd_pass); \r\n            store_coding_and_rc_info(p_Vid, &coding_info);\r\n            best_method = EXP_WP;\r\n            apply_wp = 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      rd_pass++;\r\n      //free_slice(dummy_slice);\r\n\r\n      if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)\r\n      {\r\n        frame_picture_mp_exit(p_Vid, &coding_info);\r\n        free_slice(dummy_slice);\r\n        return;\r\n      }\r\n    }\r\n    free_slice(dummy_slice);\r\n  }\r\n\r\n\r\n  // code as I? or maybe as B?\r\n  frame_type_pass = 0;\r\n  if(p_Inp->RDPSliceITest && (coding_info.intras * 100/p_Vid->FrameSizeInMbs) >= 75)\r\n  {\r\n    frame_type = I_SLICE; \r\n    set_slice_type(p_Vid, p_Inp, I_SLICE);\r\n    populate_frame_slice_type( p_Inp, p_Vid->p_curr_frm_struct, I_SLICE, p_Vid->p_pred->max_num_slices );\r\n    p_Vid->active_pps = p_Vid->PicParSet[0];\r\n    frame_type_pass = 1;\r\n  }\r\n  else if (p_Inp->RDPSliceBTest && p_Vid->active_sps->profile_idc != BASELINE)\r\n  // later need to add some automatic criterion to see if this (coding P as B) may be beneficial \r\n  {\r\n    frame_type = B_SLICE; \r\n    set_slice_type(p_Vid, p_Inp, B_SLICE );\r\n    populate_frame_slice_type( p_Inp, p_Vid->p_curr_frm_struct, B_SLICE, p_Vid->p_pred->max_num_slices );\r\n    p_Vid->active_pps = p_Vid->PicParSet[0];\r\n    frame_type_pass = 1;\r\n  }\r\n\r\n  if(frame_type_pass)\r\n  {\r\n    p_Vid->write_macroblock = FALSE;\r\n    p_Vid->p_curr_frm_struct->qp = p_Vid->qp;\r\n    frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);\r\n    selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);\r\n#if (DBG_IMAGE_MP)\r\n  printf(\"rd_pass = %d, selection = %d\\n\", rd_pass, selection);\r\n#endif\r\n\r\n    if (selection)\r\n    {\r\n      swap_frame_buffer(p_Vid, 0, rd_pass); \r\n      store_coding_and_rc_info(p_Vid, &coding_info);\r\n      best_method = FRAME_TYPE; \r\n    }\r\n    // reset frame_type\r\n    else \r\n      frame_type = P_SLICE;\r\n\r\n    rd_pass++;\r\n    if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)\r\n    {\r\n      frame_picture_mp_exit(p_Vid, &coding_info);\r\n      return;\r\n    }\r\n  }\r\n\r\n  if(p_Vid->EvaluateDBOff)\r\n  {\r\n    // Perform DB off coding pass\r\n    p_Vid->active_pps = (best_method == EXP_WP?p_Vid->PicParSet[1]:p_Vid->PicParSet[0]);\r\n    if(frame_type != P_SLICE)\r\n    {\r\n      set_slice_type(p_Vid, p_Inp, frame_type);\r\n      populate_frame_slice_type( p_Inp, p_Vid->p_curr_frm_struct, frame_type, p_Vid->p_pred->max_num_slices );\r\n    }\r\n    p_Vid->TurnDBOff = 1; \r\n    p_Vid->write_macroblock = FALSE;\r\n    p_Vid->p_curr_frm_struct->qp = p_Vid->qp;\r\n    frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);\r\n    selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);\r\n#if (DBG_IMAGE_MP)\r\n  printf(\"DB OFF, rd_pass = %d, selection = %d\\n\", rd_pass, selection);\r\n#endif\r\n\r\n    if (selection)\r\n    {\r\n      swap_frame_buffer(p_Vid, 0, rd_pass); \r\n      store_coding_and_rc_info(p_Vid, &coding_info);\r\n      best_method = DB_OFF; \r\n    }\r\n\r\n    rd_pass++;\r\n    if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)\r\n    {\r\n      frame_picture_mp_exit(p_Vid, &coding_info);\r\n      return;\r\n    }\r\n  }\r\n\r\n  if(p_Inp->RDPictureFrameQPPSlice)\r\n  {\r\n    // frame QP pass\r\n    p_Vid->active_pps = (apply_wp?p_Vid->PicParSet[1]:p_Vid->PicParSet[0]);\r\n    if(frame_type != P_SLICE)\r\n    {\r\n      set_slice_type(p_Vid, p_Inp, frame_type);\r\n      populate_frame_slice_type( p_Inp, p_Vid->p_curr_frm_struct, I_SLICE, p_Vid->p_pred->max_num_slices );\r\n    }\r\n    p_Vid->qp = (p_Vid->nal_reference_idc==0 ? rd_qp+1:rd_qp-1);\r\n    p_Vid->qp = iClip3( p_Vid->RCMinQP, p_Vid->RCMaxQP, p_Vid->qp );\r\n    if ( p_Inp->RCEnable )\r\n    {\r\n      rateRatio = p_Vid->nal_reference_idc ? 1.15F : 0.85F;\r\n      rc_init_frame_rdpic( p_Vid, p_Inp, rateRatio );\r\n    }\r\n    p_Vid->TurnDBOff = 0;\r\n    p_Vid->write_macroblock = FALSE;\r\n    p_Vid->p_curr_frm_struct->qp = p_Vid->qp;\r\n    frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);\r\n    selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);\r\n#if (DBG_IMAGE_MP)\r\n    printf(\"rd_pass = %d, selection = %d\\n\", rd_pass, selection);\r\n#endif\r\n\r\n    if (selection)\r\n    {\r\n      swap_frame_buffer(p_Vid, 0, rd_pass); \r\n      store_coding_and_rc_info(p_Vid, &coding_info);\r\n      best_method = FRAME_QP;\r\n    }\r\n\r\n    rd_pass++;\r\n    if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)\r\n    {\r\n      frame_picture_mp_exit(p_Vid, &coding_info);\r\n      return;\r\n    }\r\n  }\r\n\r\n  frame_picture_mp_exit(p_Vid, &coding_info);\r\n}", "item_id": 5, "repo": "ratnajitmukherjee/HDRVideoEvaluationFramework", "file": "encoders/jm/lencod/src/image_mp.c", "last_update_at": "2018-07-12T16:29:15+00:00", "question_id": "931c1bfe92e4796cc96d98227132ec70594d3f37_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void frame_picture_mp_p_slice(VideoParameters *p_Vid, InputParameters *p_Inp)\r\n{\r\n  int   rd_pass = 0;\r\n  int   rd_qp = p_Vid->p_curr_frm_struct->qp;\r\n  float rateRatio = 1.0F;\r\n  int   wp_pass=0;\r\n  int   frame_type_pass = 0;\r\n  CodingInfo coding_info;\r\n  FrameCodingMethod best_method = REGULAR; \r\n  int frame_type = P_SLICE; \r\n  int apply_wp = 0;\r\n  int selection;\r\n\r\n  frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);\r\n  store_coding_and_rc_info(p_Vid, &coding_info);\r\n\r\n  if(p_Inp->WPIterMC)\r\n    p_Vid->frameOffsetAvail = 1; \r\n\r\n#if (DBG_IMAGE_MP)\r\n    printf(\"rd_pass = %d: %d (%.0f, %.0f, %.0f)\\n\", rd_pass, \r\n      p_Vid->frame_pic[0]->bits_per_picture, \r\n      p_Vid->frame_pic[0]->distortion.value[0], p_Vid->frame_pic[0]->distortion.value[1], p_Vid->frame_pic[0]->distortion.value[2]);\r\n#endif\r\n\r\n  rd_pass++;\r\n  if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)\r\n  {\r\n    frame_picture_mp_exit(p_Vid, &coding_info);\r\n    return;\r\n  }\r\n\r\n  // for P_Slice, consider WP  \r\n  wp_pass = 0;\r\n  if (p_Inp->GenerateMultiplePPS)\r\n  {\r\n    Slice *dummy_slice = NULL;\r\n\r\n    InitWP(p_Vid, p_Inp, 0);\r\n    if ( p_Inp->WPMCPrecision )\r\n      p_Vid->pWPX->curr_wp_rd_pass = p_Vid->pWPX->wp_rd_passes + 1;\r\n    init_slice_lite(p_Vid, &dummy_slice, 0);\r\n\r\n    if (p_Vid->TestWPPSlice(dummy_slice, 0) == 1)\r\n    {\r\n      // regular WP pass\r\n      p_Vid->active_pps = p_Vid->PicParSet[1];\r\n      if ( p_Inp->WPMCPrecision )\r\n        p_Vid->pWPX->curr_wp_rd_pass->algorithm = WP_REGULAR;\r\n      wp_pass = 1;\r\n    }\r\n    else if ( p_Inp->WPMCPrecision )\r\n    {\r\n      // WPMC pass\r\n      p_Vid->active_pps = p_Vid->PicParSet[1];\r\n      wp_pass = 1;\r\n    }  \r\n\r\n    // The way it is, the code would only reach here if prior conditional using \r\n    // generatemultiplepps is satisfied\r\n    if(wp_pass)\r\n    {\r\n      p_Vid->write_macroblock = FALSE;\r\n      p_Vid->p_curr_frm_struct->qp = p_Vid->qp;\r\n      frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);\r\n      selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);\r\n#if (DBG_IMAGE_MP)\r\n      printf(\"rd_pass = %d, selection = %d\\n\", rd_pass, selection);\r\n#endif\r\n#if (DBG_IMAGE_MP)\r\n      printf(\"rd_pass = %d: %d (%.0f, %.0f, %.0f)\\n\", rd_pass, \r\n        p_Vid->frame_pic[rd_pass]->bits_per_picture, \r\n        p_Vid->frame_pic[rd_pass]->distortion.value[0], p_Vid->frame_pic[rd_pass]->distortion.value[1], p_Vid->frame_pic[rd_pass]->distortion.value[2]);\r\n#endif\r\n\r\n      if (selection)\r\n      {\r\n        swap_frame_buffer(p_Vid, 0, rd_pass); \r\n        store_coding_and_rc_info(p_Vid, &coding_info);\r\n        best_method = EXP_WP;\r\n        apply_wp = 1;\r\n      }\r\n\r\n      if(p_Inp->WPMethod == 0 || p_Inp->WPMCPrecision) \r\n      {\r\n        wp_pass = 0;\r\n        if ( p_Inp->WPMCPrecision )\r\n          p_Vid->pWPX->curr_wp_rd_pass = p_Vid->pWPX->wp_rd_passes + 2;\r\n        if (p_Inp->WPMethod == 0 && p_Vid->TestWPPSlice(dummy_slice, 1) == 1)\r\n        {\r\n          // regular WP pass\r\n          p_Vid->active_pps = p_Vid->PicParSet[1];\r\n          if ( p_Inp->WPMCPrecision )\r\n            p_Vid->pWPX->curr_wp_rd_pass->algorithm = WP_REGULAR;\r\n          wp_pass = 1;\r\n        }\r\n        else if ( p_Inp->WPMCPrecision )\r\n        {\r\n          // WPMC pass\r\n          p_Vid->active_pps = p_Vid->PicParSet[1];\r\n          wp_pass = 1;\r\n        }\r\n\r\n        if(wp_pass)\r\n        {\r\n          p_Vid->write_macroblock = FALSE;\r\n          p_Vid->p_curr_frm_struct->qp = p_Vid->qp;\r\n          free_slice_list(p_Vid->frame_pic[rd_pass]);\r\n          free_storable_picture(p_Vid, p_Vid->enc_frame_picture[rd_pass]);\r\n          frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);\r\n          selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);\r\n#if (DBG_IMAGE_MP)\r\n          printf(\"rd_pass = %d, selection = %d\\n\", rd_pass, selection);\r\n#endif\r\n#if (DBG_IMAGE_MP)\r\n          printf(\"rd_pass = %d: %d (%.0f, %.0f, %.0f)\\n\", rd_pass, \r\n            p_Vid->frame_pic[rd_pass]->bits_per_picture, \r\n            p_Vid->frame_pic[rd_pass]->distortion.value[0], p_Vid->frame_pic[rd_pass]->distortion.value[1], p_Vid->frame_pic[rd_pass]->distortion.value[2]);\r\n#endif\r\n\r\n          if (selection)\r\n          {\r\n            swap_frame_buffer(p_Vid, 0, rd_pass); \r\n            store_coding_and_rc_info(p_Vid, &coding_info);\r\n            best_method = EXP_WP;\r\n            apply_wp = 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      rd_pass++;\r\n      //free_slice(dummy_slice);\r\n\r\n      if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)\r\n      {\r\n        frame_picture_mp_exit(p_Vid, &coding_info);\r\n        free_slice(dummy_slice);\r\n        return;\r\n      }\r\n    }\r\n    free_slice(dummy_slice);\r\n  }\r\n\r\n\r\n  // code as I? or maybe as B?\r\n  frame_type_pass = 0;\r\n  if(p_Inp->RDPSliceITest && (coding_info.intras * 100/p_Vid->FrameSizeInMbs) >= 75)\r\n  {\r\n    frame_type = I_SLICE; \r\n    set_slice_type(p_Vid, p_Inp, I_SLICE);\r\n    populate_frame_slice_type( p_Inp, p_Vid->p_curr_frm_struct, I_SLICE, p_Vid->p_pred->max_num_slices );\r\n    p_Vid->active_pps = p_Vid->PicParSet[0];\r\n    frame_type_pass = 1;\r\n  }\r\n  else if (p_Inp->RDPSliceBTest && p_Vid->active_sps->profile_idc != BASELINE)\r\n  // later need to add some automatic criterion to see if this (coding P as B) may be beneficial \r\n  {\r\n    frame_type = B_SLICE; \r\n    set_slice_type(p_Vid, p_Inp, B_SLICE );\r\n    populate_frame_slice_type( p_Inp, p_Vid->p_curr_frm_struct, B_SLICE, p_Vid->p_pred->max_num_slices );\r\n    p_Vid->active_pps = p_Vid->PicParSet[0];\r\n    frame_type_pass = 1;\r\n  }\r\n\r\n  if(frame_type_pass)\r\n  {\r\n    p_Vid->write_macroblock = FALSE;\r\n    p_Vid->p_curr_frm_struct->qp = p_Vid->qp;\r\n    frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);\r\n    selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);\r\n#if (DBG_IMAGE_MP)\r\n  printf(\"rd_pass = %d, selection = %d\\n\", rd_pass, selection);\r\n#endif\r\n\r\n    if (selection)\r\n    {\r\n      swap_frame_buffer(p_Vid, 0, rd_pass); \r\n      store_coding_and_rc_info(p_Vid, &coding_info);\r\n      best_method = FRAME_TYPE; \r\n    }\r\n    // reset frame_type\r\n    else \r\n      frame_type = P_SLICE;\r\n\r\n    rd_pass++;\r\n    if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)\r\n    {\r\n      frame_picture_mp_exit(p_Vid, &coding_info);\r\n      return;\r\n    }\r\n  }\r\n\r\n  if(p_Vid->EvaluateDBOff)\r\n  {\r\n    // Perform DB off coding pass\r\n    p_Vid->active_pps = (best_method == EXP_WP?p_Vid->PicParSet[1]:p_Vid->PicParSet[0]);\r\n    if(frame_type != P_SLICE)\r\n    {\r\n      set_slice_type(p_Vid, p_Inp, frame_type);\r\n      populate_frame_slice_type( p_Inp, p_Vid->p_curr_frm_struct, frame_type, p_Vid->p_pred->max_num_slices );\r\n    }\r\n    p_Vid->TurnDBOff = 1; \r\n    p_Vid->write_macroblock = FALSE;\r\n    p_Vid->p_curr_frm_struct->qp = p_Vid->qp;\r\n    frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);\r\n    selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);\r\n#if (DBG_IMAGE_MP)\r\n  printf(\"DB OFF, rd_pass = %d, selection = %d\\n\", rd_pass, selection);\r\n#endif\r\n\r\n    if (selection)\r\n    {\r\n      swap_frame_buffer(p_Vid, 0, rd_pass); \r\n      store_coding_and_rc_info(p_Vid, &coding_info);\r\n      best_method = DB_OFF; \r\n    }\r\n\r\n    rd_pass++;\r\n    if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)\r\n    {\r\n      frame_picture_mp_exit(p_Vid, &coding_info);\r\n      return;\r\n    }\r\n  }\r\n\r\n  if(p_Inp->RDPictureFrameQPPSlice)\r\n  {\r\n    // frame QP pass\r\n    p_Vid->active_pps = (apply_wp?p_Vid->PicParSet[1]:p_Vid->PicParSet[0]);\r\n    if(frame_type != P_SLICE)\r\n    {\r\n      set_slice_type(p_Vid, p_Inp, frame_type);\r\n      populate_frame_slice_type( p_Inp, p_Vid->p_curr_frm_struct, I_SLICE, p_Vid->p_pred->max_num_slices );\r\n    }\r\n    p_Vid->qp = (p_Vid->nal_reference_idc==0 ? rd_qp+1:rd_qp-1);\r\n    p_Vid->qp = iClip3( p_Vid->RCMinQP, p_Vid->RCMaxQP, p_Vid->qp );\r\n    if ( p_Inp->RCEnable )\r\n    {\r\n      rateRatio = p_Vid->nal_reference_idc ? 1.15F : 0.85F;\r\n      rc_init_frame_rdpic( p_Vid, p_Inp, rateRatio );\r\n    }\r\n    p_Vid->TurnDBOff = 0;\r\n    p_Vid->write_macroblock = FALSE;\r\n    p_Vid->p_curr_frm_struct->qp = p_Vid->qp;\r\n    frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);\r\n    selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);\r\n#if (DBG_IMAGE_MP)\r\n    printf(\"rd_pass = %d, selection = %d\\n\", rd_pass, selection);\r\n#endif\r\n\r\n    if (selection)\r\n    {\r\n      swap_frame_buffer(p_Vid, 0, rd_pass); \r\n      store_coding_and_rc_info(p_Vid, &coding_info);\r\n      best_method = FRAME_QP;\r\n    }\r\n\r\n    rd_pass++;\r\n    if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)\r\n    {\r\n      frame_picture_mp_exit(p_Vid, &coding_info);\r\n      return;\r\n    }\r\n  }\r\n\r\n  frame_picture_mp_exit(p_Vid, &coding_info);\r\n"]]}
