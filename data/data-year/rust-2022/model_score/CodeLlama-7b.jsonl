{"hexsha": "ed945dd1c6e72f8d7d2818723f8771328de00955", "ext": "rs", "lang": "Rust", "content": "fn state_control() {\n    let store = MemoryBlockstore::new();\n    let v = VM::new(&store);\n    let addr1 = Address::new_id(1000);\n    let addr2 = Address::new_id(2222);\n\n    // set actor\n    let a1 = actor(*ACCOUNT_ACTOR_CODE_ID, make_builtin(b\"a1-head\"), 42, TokenAmount::from(10u8));\n    v.set_actor(addr1, a1.clone());\n    let out = v.get_actor(addr1).unwrap();\n    assert_eq!(out, a1);\n    let check = v.checkpoint();\n\n    let a2 = actor(*PAYCH_ACTOR_CODE_ID, make_builtin(b\"a2-head\"), 88, TokenAmount::from(1u8));\n    v.set_actor(addr2, a2.clone());\n    assert_eq!(v.get_actor(addr2).unwrap(), a2);\n    // rollback removes a2 but not a1\n    v.rollback(check);\n\n    // a2 is gone\n    assert_eq!(None, v.get_actor(addr2));\n    assert_eq!(v.get_actor(addr1).unwrap(), a1);\n}", "item_id": 0, "repo": "filecoin-project/builtin-actors", "file": "test_vm/tests/test_vm_test.rs", "last_update_at": "2022-03-24T03:31:10+00:00", "question_id": "ed945dd1c6e72f8d7d2818723f8771328de00955_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn state_control() {\n    let store = MemoryBlockstore::new();\n    let v = VM::new(&store);\n    let addr1 = Address::new_id(1000);\n    let addr2 = Address::new_id(2222);\n    // set actor\n    let a1 = actor(*ACCOUNT_ACTOR_CODE_ID, make_builtin(b\"a1-head\"), 42, TokenAmount::from(10u8));\n    v.set_actor(addr1, a1.clone());\n    let out = v.get_actor(addr1).unwrap();\n    assert_eq!(out, a1);\n    let check = v.checkpoint();\n    let a2 = actor(*PAYCH_ACTOR_CODE_ID, make_builtin(b\"a2-head\"), 88, TokenAmount::from(1u8));\n    v.set_actor(addr2, a2.clone());\n    assert_eq!(v.get_actor(addr2).unwrap(), a2);\n    // rollback removes a2 but not a1\n    v.rollback(check);\n    // a2 is gone\n    assert_eq!(None, v.get_actor(addr2));\n    assert_eq!(v.get_actor(addr1).unwrap(), a1);\n"]], "pred": {"ppl": 2.595463991165161, "ppl_lower": 3.037146806716919, "ppl/lowercase_ppl": -1.16477137637969, "ppl/zlib": 0.002664148890014272, "Min_5.0% Prob": 7.834760284423828, "Min_10.0% Prob": 6.255553399362872, "Min_20.0% Prob": 4.1028740867491695, "Min_30.0% Prob": 3.0003273816818887, "Min_40.0% Prob": 2.3455792462825773, "Min_50.0% Prob": 1.8947299535202373, "Min_60.0% Prob": 1.589844724321936}}
{"hexsha": "7bf327281bbd0348593ce16bd9c8d59140cb577d", "ext": "rs", "lang": "Rust", "content": "fn set_and_retrieve_cached_onionskin() {\n    let anim = create_animation();\n\n    anim.perform_edits(vec![AnimationEdit::AddNewLayer(24)]);\n\n    let layer           = anim.get_layer_with_id(24).unwrap();\n    let cache           = layer.get_canvas_cache_at_time(Duration::from_millis(2000));\n\n    cache.store(CacheType::OnionSkinLayer, Arc::new(vec![Draw::Path(PathOp::NewPath), Draw::Fill]));\n\n    let cache           = layer.get_canvas_cache_at_time(Duration::from_millis(2000));\n    let cached_drawing  = cache.retrieve(CacheType::OnionSkinLayer);\n\n    assert!(cached_drawing == Some(Arc::new(vec![Draw::Path(PathOp::NewPath), Draw::Fill])));\n}", "item_id": 0, "repo": "Logicalshift/flowbetween", "file": "animation/src/storage/tests/caching.rs", "last_update_at": "2022-02-21T09:04:10+00:00", "question_id": "7bf327281bbd0348593ce16bd9c8d59140cb577d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn set_and_retrieve_cached_onionskin() {\n    let anim = create_animation();\n    anim.perform_edits(vec![AnimationEdit::AddNewLayer(24)]);\n    let layer           = anim.get_layer_with_id(24).unwrap();\n    let cache           = layer.get_canvas_cache_at_time(Duration::from_millis(2000));\n    cache.store(CacheType::OnionSkinLayer, Arc::new(vec![Draw::Path(PathOp::NewPath), Draw::Fill]));\n    let cache           = layer.get_canvas_cache_at_time(Duration::from_millis(2000));\n    let cached_drawing  = cache.retrieve(CacheType::OnionSkinLayer);\n    assert!(cached_drawing == Some(Arc::new(vec![Draw::Path(PathOp::NewPath), Draw::Fill])));\n"]], "pred": {"ppl": 2.8389546871185303, "ppl_lower": 3.9769670963287354, "ppl/lowercase_ppl": -1.3230515366262399, "ppl/zlib": 0.0034781197216782766, "Min_5.0% Prob": 8.282350886951793, "Min_10.0% Prob": 6.386343800503274, "Min_20.0% Prob": 4.439534726350204, "Min_30.0% Prob": 3.3346624754477237, "Min_40.0% Prob": 2.586350914090872, "Min_50.0% Prob": 2.08944402469889, "Min_60.0% Prob": 1.7455918531581436}}
{"hexsha": "4f8443be259d19e55b468b280badc18a5eca7b9d", "ext": "rs", "lang": "Rust", "content": "fn test_matches_dft() {\n        let n = 4;\n\n        for len in 1..20 {\n            let dft_instance = Dft::new(len, FftDirection::Forward);\n            assert_eq!(\n                dft_instance.len(),\n                len,\n                \"Dft instance reported incorrect length\"\n            );\n\n            let input = random_signal(len * n);\n            let mut expected_output = input.clone();\n\n            // Compute the control data using our simplified Dft definition\n            for (input_chunk, output_chunk) in\n                input.chunks(len).zip(expected_output.chunks_mut(len))\n            {\n                dft(input_chunk, output_chunk);\n            }\n\n            // test process()\n            {\n                let mut inplace_buffer = input.clone();\n\n                dft_instance.process(&mut inplace_buffer);\n\n                assert!(\n                    compare_vectors(&expected_output, &inplace_buffer),\n                    \"process() failed, length = {}\",\n                    len\n                );\n            }\n\n            // test process_with_scratch()\n            {\n                let mut inplace_with_scratch_buffer = input.clone();\n                let mut inplace_scratch =\n                    vec![Zero::zero(); dft_instance.get_inplace_scratch_len()];\n\n                dft_instance\n                    .process_with_scratch(&mut inplace_with_scratch_buffer, &mut inplace_scratch);\n\n                assert!(\n                    compare_vectors(&expected_output, &inplace_with_scratch_buffer),\n                    \"process_inplace() failed, length = {}\",\n                    len\n                );\n\n                // one more thing: make sure that the Dft algorithm even works with dirty scratch space\n                for item in inplace_scratch.iter_mut() {\n                    *item = Complex::new(100.0, 100.0);\n                }\n                inplace_with_scratch_buffer.copy_from_slice(&input);\n\n                dft_instance\n                    .process_with_scratch(&mut inplace_with_scratch_buffer, &mut inplace_scratch);\n\n                assert!(\n                    compare_vectors(&expected_output, &inplace_with_scratch_buffer),\n                    \"process_with_scratch() failed the 'dirty scratch' test for len = {}\",\n                    len\n                );\n            }\n\n            // test process_outofplace_with_scratch\n            {\n                let mut outofplace_input = input.clone();\n                let mut outofplace_output = expected_output.clone();\n\n                dft_instance.process_outofplace_with_scratch(\n                    &mut outofplace_input,\n                    &mut outofplace_output,\n                    &mut [],\n                );\n\n                assert!(\n                    compare_vectors(&expected_output, &outofplace_output),\n                    \"process_outofplace_with_scratch() failed, length = {}\",\n                    len\n                );\n            }\n        }\n\n        //verify that it doesn't crash or infinite loop if we have a length of 0\n        let zero_dft = Dft::new(0, FftDirection::Forward);\n        let mut zero_input: Vec<Complex<f32>> = Vec::new();\n        let mut zero_output: Vec<Complex<f32>> = Vec::new();\n        let mut zero_scratch: Vec<Complex<f32>> = Vec::new();\n\n        zero_dft.process(&mut zero_input);\n        zero_dft.process_with_scratch(&mut zero_input, &mut zero_scratch);\n        zero_dft.process_outofplace_with_scratch(\n            &mut zero_input,\n            &mut zero_output,\n            &mut zero_scratch,\n        );\n    }", "item_id": 0, "repo": "songww/RustFFT", "file": "src/algorithm/dft.rs", "last_update_at": "2022-03-31T17:43:32+00:00", "question_id": "4f8443be259d19e55b468b280badc18a5eca7b9d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_matches_dft() {\n        let n = 4;\n        for len in 1..20 {\n            let dft_instance = Dft::new(len, FftDirection::Forward);\n            assert_eq!(\n                dft_instance.len(),\n                len,\n                \"Dft instance reported incorrect length\"\n            );\n            let input = random_signal(len * n);\n            let mut expected_output = input.clone();\n            // Compute the control data using our simplified Dft definition\n            for (input_chunk, output_chunk) in\n                input.chunks(len).zip(expected_output.chunks_mut(len))\n            {\n                dft(input_chunk, output_chunk);\n            }\n            // test process()\n            {\n                let mut inplace_buffer = input.clone();\n                dft_instance.process(&mut inplace_buffer);\n                assert!(\n                    compare_vectors(&expected_output, &inplace_buffer),\n                    \"process() failed, length = {}\",\n                    len\n                );\n            }\n            // test process_with_scratch()\n            {\n                let mut inplace_with_scratch_buffer = input.clone();\n                let mut inplace_scratch =\n                    vec![Zero::zero(); dft_instance.get_inplace_scratch_len()];\n                dft_instance\n                    .process_with_scratch(&mut inplace_with_scratch_buffer, &mut inplace_scratch);\n                assert!(\n                    compare_vectors(&expected_output, &inplace_with_scratch_buffer),\n                    \"process_inplace() failed, length = {}\",\n                    len\n                );\n                // one more thing: make sure that the Dft algorithm even works with dirty scratch space\n                for item in inplace_scratch.iter_mut() {\n                    *item = Complex::new(100.0, 100.0);\n                }\n                inplace_with_scratch_buffer.copy_from_slice(&input);\n                dft_instance\n                    .process_with_scratch(&mut inplace_with_scratch_buffer, &mut inplace_scratch);\n                assert!(\n                    compare_vectors(&expected_output, &inplace_with_scratch_buffer),\n                    \"process_with_scratch() failed the 'dirty scratch' test for len = {}\",\n                    len\n                );\n            }\n            // test process_outofplace_with_scratch\n            {\n                let mut outofplace_input = input.clone();\n                let mut outofplace_output = expected_output.clone();\n                dft_instance.process_outofplace_with_scratch(\n                    &mut outofplace_input,\n                    &mut outofplace_output,\n                    &mut [],\n                );\n                assert!(\n                    compare_vectors(&expected_output, &outofplace_output),\n                    \"process_outofplace_with_scratch() failed, length = {}\",\n                    len\n                );\n            }\n        }\n        //verify that it doesn't crash or infinite loop if we have a length of 0\n        let zero_dft = Dft::new(0, FftDirection::Forward);\n        let mut zero_input: Vec<Complex<f32>> = Vec::new();\n        let mut zero_output: Vec<Complex<f32>> = Vec::new();\n        let mut zero_scratch: Vec<Complex<f32>> = Vec::new();\n        zero_dft.process(&mut zero_input);\n        zero_dft.process_with_scratch(&mut zero_input, &mut zero_scratch);\n        zero_dft.process_outofplace_with_scratch(\n            &mut zero_input,\n            &mut zero_output,\n            &mut zero_scratch,\n        );\n"]], "pred": {"ppl": 1.7565990686416626, "ppl_lower": 1.8413550853729248, "ppl/lowercase_ppl": -1.0836419500427825, "ppl/zlib": 0.0006862114400677296, "Min_5.0% Prob": 6.101028645292241, "Min_10.0% Prob": 4.336296971220719, "Min_20.0% Prob": 2.657644667550531, "Min_30.0% Prob": 1.8581504678496947, "Min_40.0% Prob": 1.4049849831913623, "Min_50.0% Prob": 1.1258452603988989, "Min_60.0% Prob": 0.9397576580959394}}
{"hexsha": "d4c044b4464d1846dd4a853c231d2edd55e48d41", "ext": "rs", "lang": "Rust", "content": "fn encode_bit_pattern_examples() {\n        assert_eq!(encode(0x0f0f).as_ref(), &[0x9E, 0x78]);\n        assert_eq!(\n            encode(0x0f0f_f0f0).as_ref(),\n            &[0xF0, 0x3C, 0xFC, 0xC3, 0x03]\n        );\n        assert_eq!(\n            encode(0x0f0f_f0f0_0f0f).as_ref(),\n            &[0xFC, 0x0F, 0x0F, 0xF0, 0xF0, 0x0F, 0x0F]\n        );\n        assert_eq!(\n            encode(0x0f0f_f0f0_0f0f_f0f0).as_ref(),\n            &[0xFF, 0xE0, 0xE1, 0x1F, 0x1E, 0xE0, 0xE1, 0x1F, 0x1E]\n        );\n        //\n        assert_eq!(encode(-0x0f0f).as_ref(), &[0x9D, 0x78]);\n        assert_eq!(\n            encode(-0x0f0f_f0f0).as_ref(),\n            &[0xF7, 0x3B, 0xFC, 0xC3, 0x03]\n        );\n        assert_eq!(\n            encode(-0x0f0f_f0f0_0f0f).as_ref(),\n            &[0xFD, 0x0E, 0x0F, 0xF0, 0xF0, 0x0F, 0x0F]\n        );\n        assert_eq!(\n            encode(-0x0f0f_f0f0_0f0f_f0f0).as_ref(),\n            &[0xFF, 0xDF, 0xE1, 0x1F, 0x1E, 0xE0, 0xE1, 0x1F, 0x1E]\n        );\n    }", "item_id": 0, "repo": "aki-akaguma/vu64", "file": "src/signed.rs", "last_update_at": "2022-02-02T10:25:49+00:00", "question_id": "d4c044b4464d1846dd4a853c231d2edd55e48d41_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn encode_bit_pattern_examples() {\n        assert_eq!(encode(0x0f0f).as_ref(), &[0x9E, 0x78]);\n        assert_eq!(\n            encode(0x0f0f_f0f0).as_ref(),\n            &[0xF0, 0x3C, 0xFC, 0xC3, 0x03]\n        );\n        assert_eq!(\n            encode(0x0f0f_f0f0_0f0f).as_ref(),\n            &[0xFC, 0x0F, 0x0F, 0xF0, 0xF0, 0x0F, 0x0F]\n        );\n        assert_eq!(\n            encode(0x0f0f_f0f0_0f0f_f0f0).as_ref(),\n            &[0xFF, 0xE0, 0xE1, 0x1F, 0x1E, 0xE0, 0xE1, 0x1F, 0x1E]\n        );\n        //\n        assert_eq!(encode(-0x0f0f).as_ref(), &[0x9D, 0x78]);\n        assert_eq!(\n            encode(-0x0f0f_f0f0).as_ref(),\n            &[0xF7, 0x3B, 0xFC, 0xC3, 0x03]\n        );\n        assert_eq!(\n            encode(-0x0f0f_f0f0_0f0f).as_ref(),\n            &[0xFD, 0x0E, 0x0F, 0xF0, 0xF0, 0x0F, 0x0F]\n        );\n        assert_eq!(\n            encode(-0x0f0f_f0f0_0f0f_f0f0).as_ref(),\n            &[0xFF, 0xDF, 0xE1, 0x1F, 0x1E, 0xE0, 0xE1, 0x1F, 0x1E]\n        );\n"]], "pred": {"ppl": 1.5120534896850586, "ppl_lower": 1.5111513137817383, "ppl/lowercase_ppl": -0.9985565189975135, "ppl/zlib": 0.001914206731052918, "Min_5.0% Prob": 4.8027326972396285, "Min_10.0% Prob": 3.484441779277943, "Min_20.0% Prob": 2.023220330203345, "Min_30.0% Prob": 1.3752613332486008, "Min_40.0% Prob": 1.0366894989776416, "Min_50.0% Prob": 0.828259620642385, "Min_60.0% Prob": 0.689478670334743}}
{"hexsha": "dbd6eabc87f2d2be8b8b8bc7d2a69e80cc7ba8ad", "ext": "rs", "lang": "Rust", "content": "pub fn unpack_sect4_body<R: Read>(f: &mut R, body_size: usize) -> Result<SectionBody, ParseError> {\n    let mut buf = [0; 4]; // octet 6-9\n    f.read_exact(&mut buf[..])?;\n\n    let len_extra = body_size - buf.len();\n    let mut templated = vec![0; len_extra];\n    f.read_exact(&mut templated[..])?;\n\n    let prod_tmpl_num = read_as!(u16, buf, 2);\n\n    Ok(SectionBody::Section4(ProdDefinition {\n        num_coordinates: read_as!(u16, buf, 0),\n        prod_tmpl_num,\n        templated: templated.into_boxed_slice(),\n        template_supported: SUPPORTED_PROD_DEF_TEMPLATE_NUMBERS.contains(&prod_tmpl_num),\n    }))\n}", "item_id": 4, "repo": "Quba1/grib-rs", "file": "src/reader.rs", "last_update_at": "2022-03-17T20:32:52+00:00", "question_id": "dbd6eabc87f2d2be8b8b8bc7d2a69e80cc7ba8ad_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn unpack_sect4_body<R: Read>(f: &mut R, body_size: usize) -> Result<SectionBody, ParseError> {\n    let mut buf = [0; 4]; // octet 6-9\n    f.read_exact(&mut buf[..])?;\n    let len_extra = body_size - buf.len();\n    let mut templated = vec![0; len_extra];\n    f.read_exact(&mut templated[..])?;\n    let prod_tmpl_num = read_as!(u16, buf, 2);\n    Ok(SectionBody::Section4(ProdDefinition {\n        num_coordinates: read_as!(u16, buf, 0),\n        prod_tmpl_num,\n        templated: templated.into_boxed_slice(),\n        template_supported: SUPPORTED_PROD_DEF_TEMPLATE_NUMBERS.contains(&prod_tmpl_num),\n    }))\n"]], "pred": {"ppl": 3.353571891784668, "ppl_lower": 4.565857410430908, "ppl/lowercase_ppl": -1.2550195626303007, "ppl/zlib": 0.003507321780186543, "Min_5.0% Prob": 9.380279103914896, "Min_10.0% Prob": 7.2869343757629395, "Min_20.0% Prob": 4.930555552852397, "Min_30.0% Prob": 3.6952028715447205, "Min_40.0% Prob": 2.918800236011038, "Min_50.0% Prob": 2.388272532602636, "Min_60.0% Prob": 2.01617995010955}}
{"hexsha": "5fb6127847771f22d3c822eae64d7f4a54547e02", "ext": "rs", "lang": "Rust", "content": "fn lore() -> String {\n    let mut ret = String::from(\"Barkeep:\");\n    ret = format!(\"{} Angry Karen says that the Rusty Dragon killed her children.\\nWe all know that's a lie...\", ret);\n    ret\n}", "item_id": 10, "repo": "MaulingMonkey/rust-mini-games", "file": "text-games/lord/src/main.rs", "last_update_at": "2022-03-17T06:21:31+00:00", "question_id": "5fb6127847771f22d3c822eae64d7f4a54547e02_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn lore() -> String {\n    let mut ret = String::from(\"Barkeep:\");\n    ret = format!(\"{} Angry Karen says that the Rusty Dragon killed her children.\\nWe all know that's a lie...\", ret);\n    ret\n"]], "pred": {"ppl": 13.346787452697754, "ppl_lower": 22.24497413635254, "ppl/lowercase_ppl": -1.1971385687988427, "ppl/zlib": 0.016400479212913856, "Min_5.0% Prob": 9.731853167215982, "Min_10.0% Prob": 8.736560662587484, "Min_20.0% Prob": 7.423262635866801, "Min_30.0% Prob": 6.287143455611335, "Min_40.0% Prob": 5.427948544422786, "Min_50.0% Prob": 4.704890942573547, "Min_60.0% Prob": 4.151353756586711}}
{"hexsha": "81fe1b970d24becea38ddd9b06ae49db5bcded3e", "ext": "rs", "lang": "Rust", "content": "fn bench_disjoint_set_forest(b: &mut test::Bencher) {\n        let num_nodes = 500;\n        let num_edges = 20 * num_nodes;\n\n        let mut rng: StdRng = SeedableRng::seed_from_u64(1);\n        let uniform = Uniform::new(0, num_nodes);\n\n        let mut forest = DisjointSetForest::new(num_nodes);\n        b.iter(|| {\n            let mut count = 0;\n            while count < num_edges {\n                let u = uniform.sample(&mut rng);\n                let v = uniform.sample(&mut rng);\n                forest.union(u, v);\n                count += 1;\n            }\n            test::black_box(forest.num_trees());\n        });\n    }", "item_id": 2, "repo": "beltegeuse/imageproc", "file": "src/union_find.rs", "last_update_at": "2022-03-30T17:53:02+00:00", "question_id": "81fe1b970d24becea38ddd9b06ae49db5bcded3e_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bench_disjoint_set_forest(b: &mut test::Bencher) {\n        let num_nodes = 500;\n        let num_edges = 20 * num_nodes;\n        let mut rng: StdRng = SeedableRng::seed_from_u64(1);\n        let uniform = Uniform::new(0, num_nodes);\n        let mut forest = DisjointSetForest::new(num_nodes);\n        b.iter(|| {\n            let mut count = 0;\n            while count < num_edges {\n                let u = uniform.sample(&mut rng);\n                let v = uniform.sample(&mut rng);\n                forest.union(u, v);\n                count += 1;\n            }\n            test::black_box(forest.num_trees());\n        });\n"]], "pred": {"ppl": 1.8247402906417847, "ppl_lower": 2.7513976097106934, "ppl/lowercase_ppl": -1.682816115592047, "ppl/zlib": 0.0021556905749472123, "Min_5.0% Prob": 5.660985064506531, "Min_10.0% Prob": 4.111749696731567, "Min_20.0% Prob": 2.7396561547023492, "Min_30.0% Prob": 1.9486542983401207, "Min_40.0% Prob": 1.4900400508419578, "Min_50.0% Prob": 1.198517697236429, "Min_60.0% Prob": 1.007753761214835}}
{"hexsha": "27f1158840e2f4f0bfff5cf11627ec83120e8c20", "ext": "rs", "lang": "Rust", "content": "fn test_vec_binary_tree_basic() {\n        let mut tree = VecBinaryTree::new();\n        let mut cursor = tree.cursor_mut();\n        cursor.insert_as_root(0);\n        cursor.insert_as_left(1);\n        cursor.insert_as_right(2);\n        cursor.move_right();\n        cursor.insert_as_left(3);\n        cursor.move_left();\n        cursor.insert_as_left(4);\n        cursor.insert_as_right(5);\n        assert_eq!(\n            tree.cursor().in_order_iter().copied().collect::<Vec<_>>(),\n            [0, 1, 2, 3, 4, 5]\n        );\n        let mut cursor = tree.cursor_mut();\n        let right = cursor.take_right().unwrap();\n        assert_eq!(\n            tree.cursor().in_order_iter().copied().collect::<Vec<_>>(),\n            [0, 1]\n        );\n        assert_eq!(\n            right.cursor().in_order_iter().copied().collect::<Vec<_>>(),\n            [2, 3, 4, 5]\n        );\n        let mut cursor = tree.cursor_mut();\n        cursor.move_left();\n        cursor.append_left(right);\n        assert_eq!(\n            tree.cursor().in_order_iter().copied().collect::<Vec<_>>(),\n            [0, 1, 2, 3, 4, 5]\n        );\n        let mut cursor = tree.cursor_mut();\n        cursor.insert_as_right(6);\n        assert_eq!(\n            tree.cursor().in_order_iter().copied().collect::<Vec<_>>(),\n            [0, 1, 6, 2, 3, 4, 5]\n        );\n        assert_eq!(\n            tree.cursor().pre_order_iter().copied().collect::<Vec<_>>(),\n            [0, 1, 2, 3, 4, 5, 6]\n        );\n        assert_eq!(\n            tree.cursor().mid_order_iter().copied().collect::<Vec<_>>(),\n            [4, 3, 5, 2, 1, 0, 6]\n        );\n        assert_eq!(\n            tree.cursor().post_order_iter().copied().collect::<Vec<_>>(),\n            [4, 5, 3, 2, 1, 6, 0]\n        );\n        let mut cursor = tree.cursor_mut();\n        cursor.move_right();\n        assert_eq!(\n            cursor\n                .cursor()\n                .post_order_iter()\n                .copied()\n                .collect::<Vec<_>>(),\n            [6]\n        );\n    }", "item_id": 0, "repo": "Nouzan/algo-rs", "file": "src/ch4/binary_tree/vec_binary_tree/mod.rs", "last_update_at": "2022-01-17T06:40:00+00:00", "question_id": "27f1158840e2f4f0bfff5cf11627ec83120e8c20_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_vec_binary_tree_basic() {\n        let mut tree = VecBinaryTree::new();\n        let mut cursor = tree.cursor_mut();\n        cursor.insert_as_root(0);\n        cursor.insert_as_left(1);\n        cursor.insert_as_right(2);\n        cursor.move_right();\n        cursor.insert_as_left(3);\n        cursor.move_left();\n        cursor.insert_as_left(4);\n        cursor.insert_as_right(5);\n        assert_eq!(\n            tree.cursor().in_order_iter().copied().collect::<Vec<_>>(),\n            [0, 1, 2, 3, 4, 5]\n        );\n        let mut cursor = tree.cursor_mut();\n        let right = cursor.take_right().unwrap();\n        assert_eq!(\n            tree.cursor().in_order_iter().copied().collect::<Vec<_>>(),\n            [0, 1]\n        );\n        assert_eq!(\n            right.cursor().in_order_iter().copied().collect::<Vec<_>>(),\n            [2, 3, 4, 5]\n        );\n        let mut cursor = tree.cursor_mut();\n        cursor.move_left();\n        cursor.append_left(right);\n        assert_eq!(\n            tree.cursor().in_order_iter().copied().collect::<Vec<_>>(),\n            [0, 1, 2, 3, 4, 5]\n        );\n        let mut cursor = tree.cursor_mut();\n        cursor.insert_as_right(6);\n        assert_eq!(\n            tree.cursor().in_order_iter().copied().collect::<Vec<_>>(),\n            [0, 1, 6, 2, 3, 4, 5]\n        );\n        assert_eq!(\n            tree.cursor().pre_order_iter().copied().collect::<Vec<_>>(),\n            [0, 1, 2, 3, 4, 5, 6]\n        );\n        assert_eq!(\n            tree.cursor().mid_order_iter().copied().collect::<Vec<_>>(),\n            [4, 3, 5, 2, 1, 0, 6]\n        );\n        assert_eq!(\n            tree.cursor().post_order_iter().copied().collect::<Vec<_>>(),\n            [4, 5, 3, 2, 1, 6, 0]\n        );\n        let mut cursor = tree.cursor_mut();\n        cursor.move_right();\n        assert_eq!(\n            cursor\n                .cursor()\n                .post_order_iter()\n                .copied()\n                .collect::<Vec<_>>(),\n            [6]\n        );\n"]], "pred": {"ppl": 1.3938695192337036, "ppl_lower": 1.4555498361587524, "ppl/lowercase_ppl": -1.1303888641039155, "ppl/zlib": 0.000946107425241975, "Min_5.0% Prob": 3.958692291203667, "Min_10.0% Prob": 2.6867521212381473, "Min_20.0% Prob": 1.6119765731341698, "Min_30.0% Prob": 1.1004806557806526, "Min_40.0% Prob": 0.8304720463473418, "Min_50.0% Prob": 0.663742860616457, "Min_60.0% Prob": 0.5538878085719217}}
{"hexsha": "ed55cd606c815fe8b36c6528988c6e1f75011288", "ext": "rs", "lang": "Rust", "content": "fn clk_fro_hf_96mhz() {\n        let dp = unsafe { pac::Peripherals::steal() };\n        let syscon = dp.SYSCON.freeze(Config::frohf_96mhz());\n        assert_eq!(unwrap!(syscon.get_main_clock_freq()), 96_000_000.Hz());\n    }", "item_id": 2, "repo": "lpc-rs/lpc546xx-hal", "file": "self-tests/tests/clocking-api.rs", "last_update_at": "2022-01-21T12:10:20+00:00", "question_id": "ed55cd606c815fe8b36c6528988c6e1f75011288_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn clk_fro_hf_96mhz() {\n        let dp = unsafe { pac::Peripherals::steal() };\n        let syscon = dp.SYSCON.freeze(Config::frohf_96mhz());\n        assert_eq!(unwrap!(syscon.get_main_clock_freq()), 96_000_000.Hz());\n"]], "pred": {"ppl": 3.085834503173828, "ppl_lower": 4.077094554901123, "ppl/lowercase_ppl": -1.2472107048774994, "ppl/zlib": 0.006747437869687416, "Min_5.0% Prob": 8.27627592086792, "Min_10.0% Prob": 6.913647556304932, "Min_20.0% Prob": 4.9311688363552095, "Min_30.0% Prob": 3.6133259455362956, "Min_40.0% Prob": 2.81612164452672, "Min_50.0% Prob": 2.2440191010634103, "Min_60.0% Prob": 1.8825009624458482}}
{"hexsha": "8166c572bfaef0679b0b7305c6ec91d4344aeac1", "ext": "rs", "lang": "Rust", "content": "fn run_handler_no_request<Resp, F>(f: F) -> Result<Resp>\nwhere\n    F: FnOnce(Sandbox) -> Result<Resp>,\n{\n    let sandbox = Sandbox::new().context(SandboxCreation)?;\n    let resp = f(sandbox)?;\n    Ok(resp)\n}", "item_id": 2, "repo": "chazkiker2/rust-playground", "file": "ui/src/main.rs", "last_update_at": "2022-03-30T07:25:56+00:00", "question_id": "8166c572bfaef0679b0b7305c6ec91d4344aeac1_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn run_handler_no_request<Resp, F>(f: F) -> Result<Resp>\nwhere\n    F: FnOnce(Sandbox) -> Result<Resp>,\n{\n    let sandbox = Sandbox::new().context(SandboxCreation)?;\n    let resp = f(sandbox)?;\n    Ok(resp)\n"]], "pred": {"ppl": 2.9544050693511963, "ppl_lower": 6.123649597167969, "ppl/lowercase_ppl": -1.6728171089221109, "ppl/zlib": 0.007419844523422071, "Min_5.0% Prob": 7.342987298965454, "Min_10.0% Prob": 6.074877560138702, "Min_20.0% Prob": 4.232202365994453, "Min_30.0% Prob": 3.3039378076791763, "Min_40.0% Prob": 2.6220202319549792, "Min_50.0% Prob": 2.1625227088608394, "Min_60.0% Prob": 1.8284489316295605}}
{"hexsha": "85260655dd0d5a7f12fcbff8f77b1a01315ba1f1", "ext": "rs", "lang": "Rust", "content": "fn insert() {\n    //normal\n    let t = vec![4, 1, 3, 2, 16, 9, 10, 14, 8, 7];\n    let mut heap = max_heap::BinaryHeap::new(t);\n    // data layout:\n    //   vec![16, 14, 10, 8, 7, 9, 3, 2, 4, 1];\n    heap.insert(100);\n    let data = heap.keys_slice();\n    assert_eq!(data, vec![100, 16, 10, 8, 14, 9, 3, 2, 4, 1, 7])\n}", "item_id": 4, "repo": "zg9uagfv/Algorithm", "file": "tests/test_common_heap.rs", "last_update_at": "2022-03-27T06:39:06+00:00", "question_id": "85260655dd0d5a7f12fcbff8f77b1a01315ba1f1_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn insert() {\n    //normal\n    let t = vec![4, 1, 3, 2, 16, 9, 10, 14, 8, 7];\n    let mut heap = max_heap::BinaryHeap::new(t);\n    // data layout:\n    //   vec![16, 14, 10, 8, 7, 9, 3, 2, 4, 1];\n    heap.insert(100);\n    let data = heap.keys_slice();\n    assert_eq!(data, vec![100, 16, 10, 8, 14, 9, 3, 2, 4, 1, 7])\n"]], "pred": {"ppl": 2.6179540157318115, "ppl_lower": 2.7538821697235107, "ppl/lowercase_ppl": -1.052596502855281, "ppl/zlib": 0.004960789189061411, "Min_5.0% Prob": 8.115618069966635, "Min_10.0% Prob": 6.19623699453142, "Min_20.0% Prob": 4.239323122633828, "Min_30.0% Prob": 3.046263192538862, "Min_40.0% Prob": 2.3489138877226248, "Min_50.0% Prob": 1.9051245724161465, "Min_60.0% Prob": 1.5973528226906504}}
{"hexsha": "c30a04583fd48d49e401243784c51970de5a05bc", "ext": "rs", "lang": "Rust", "content": "fn unwatch_dir(path: &std::path::Path) {\n    let mut config = Config::load();\n    let path = path\n        .to_str()\n        .expect(\"The provided path is not valid unicode\")\n        .to_string();\n\n    config.set_unwatch(path);\n    config.save();\n}", "item_id": 2, "repo": "darti/dura", "file": "src/main.rs", "last_update_at": "2022-03-31T11:50:13+00:00", "question_id": "c30a04583fd48d49e401243784c51970de5a05bc_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn unwatch_dir(path: &std::path::Path) {\n    let mut config = Config::load();\n    let path = path\n        .to_str()\n        .expect(\"The provided path is not valid unicode\")\n        .to_string();\n    config.set_unwatch(path);\n    config.save();\n"]], "pred": {"ppl": 3.0492634773254395, "ppl_lower": 3.6968650817871094, "ppl/lowercase_ppl": -1.172737548770268, "ppl/zlib": 0.0068820992507007735, "Min_5.0% Prob": 8.208297729492188, "Min_10.0% Prob": 6.172763926642282, "Min_20.0% Prob": 4.372082249323527, "Min_30.0% Prob": 3.3391061658444614, "Min_40.0% Prob": 2.664972949412561, "Min_50.0% Prob": 2.1967038672703962, "Min_60.0% Prob": 1.8596353863782071}}
{"hexsha": "8145eeaa6e65368de7c0488d377cd4186ba4bedc", "ext": "rs", "lang": "Rust", "content": "pub fn get_property_values(\n        conn: &SqliteConnection,\n        root_values: Vec<MfgBatchPropertyValue>,\n    ) -> Result<Vec<PropertyValue>, MfgBatchStoreError> {\n        let mut definitions = Vec::new();\n\n        for root_value in root_values {\n            let children = mfg_batch_property_value::table\n                .select(mfg_batch_property_value::all_columns)\n                .filter(mfg_batch_property_value::parent_property.eq(&root_value.parent_property))\n                .load(conn)?;\n\n            if children.is_empty() {\n                definitions.push(PropertyValue::from(root_value));\n            } else {\n                definitions.push(PropertyValue::from((\n                    root_value,\n                    get_property_values(conn, children)?,\n                )));\n            }\n        }\n\n        Ok(definitions)\n    }", "item_id": 3, "repo": "kjf64c/grid", "file": "sdk/src/mfg_batch/store/diesel/operations/list_mfg_batches.rs", "last_update_at": "2022-02-17T21:18:34+00:00", "question_id": "8145eeaa6e65368de7c0488d377cd4186ba4bedc_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_property_values(\n        conn: &SqliteConnection,\n        root_values: Vec<MfgBatchPropertyValue>,\n    ) -> Result<Vec<PropertyValue>, MfgBatchStoreError> {\n        let mut definitions = Vec::new();\n        for root_value in root_values {\n            let children = mfg_batch_property_value::table\n                .select(mfg_batch_property_value::all_columns)\n                .filter(mfg_batch_property_value::parent_property.eq(&root_value.parent_property))\n                .load(conn)?;\n            if children.is_empty() {\n                definitions.push(PropertyValue::from(root_value));\n            } else {\n                definitions.push(PropertyValue::from((\n                    root_value,\n                    get_property_values(conn, children)?,\n                )));\n            }\n        }\n        Ok(definitions)\n"]], "pred": {"ppl": 2.068188428878784, "ppl_lower": 2.7127957344055176, "ppl/lowercase_ppl": -1.3733545139371084, "ppl/zlib": 0.002263779031072994, "Min_5.0% Prob": 7.304239012978294, "Min_10.0% Prob": 5.427320946346629, "Min_20.0% Prob": 3.3725185001438316, "Min_30.0% Prob": 2.3834215341643854, "Min_40.0% Prob": 1.8061249042662342, "Min_50.0% Prob": 1.4573972343324542, "Min_60.0% Prob": 1.2178031293801348}}
{"hexsha": "bc25520c5512d3a8495993761bffa37382061d77", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout___darwin_mcontext64_full() {\n    assert_eq!(\n        ::std::mem::size_of::<__darwin_mcontext64_full>(),\n        744usize,\n        concat!(\"Size of: \", stringify!(__darwin_mcontext64_full))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<__darwin_mcontext64_full>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(__darwin_mcontext64_full))\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64_full>())).__es as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__darwin_mcontext64_full),\n            \"::\",\n            stringify!(__es)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64_full>())).__ss as *const _ as usize },\n        16usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__darwin_mcontext64_full),\n            \"::\",\n            stringify!(__ss)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64_full>())).__fs as *const _ as usize },\n        216usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__darwin_mcontext64_full),\n            \"::\",\n            stringify!(__fs)\n        )\n    );\n}", "item_id": 65, "repo": "Ewpratten/raylib-rs", "file": "raylib-sys/bindings_osx.rs", "last_update_at": "2022-03-27T23:14:25+00:00", "question_id": "bc25520c5512d3a8495993761bffa37382061d77_65", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bindgen_test_layout___darwin_mcontext64_full() {\n    assert_eq!(\n        ::std::mem::size_of::<__darwin_mcontext64_full>(),\n        744usize,\n        concat!(\"Size of: \", stringify!(__darwin_mcontext64_full))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<__darwin_mcontext64_full>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(__darwin_mcontext64_full))\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64_full>())).__es as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__darwin_mcontext64_full),\n            \"::\",\n            stringify!(__es)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64_full>())).__ss as *const _ as usize },\n        16usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__darwin_mcontext64_full),\n            \"::\",\n            stringify!(__ss)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64_full>())).__fs as *const _ as usize },\n        216usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__darwin_mcontext64_full),\n            \"::\",\n            stringify!(__fs)\n        )\n    );\n"]], "pred": {"ppl": 1.1901623010635376, "ppl_lower": 1.2140394449234009, "ppl/lowercase_ppl": -1.1140992271095653, "ppl/zlib": 0.0006400356076171562, "Min_5.0% Prob": 3.3027372685345737, "Min_10.0% Prob": 1.7407518715851686, "Min_20.0% Prob": 0.8760530498892133, "Min_30.0% Prob": 0.5842195547914095, "Min_40.0% Prob": 0.4357079459818956, "Min_50.0% Prob": 0.34896503824645697, "Min_60.0% Prob": 0.29102476967725105}}
{"hexsha": "75feeb57a15caec75223b753a9d57495a352e3ad", "ext": "rs", "lang": "Rust", "content": "fn get_ddn_status_not_found_works() {\n    let contract = make_contract();\n    let p2p_id = String::from(\"test_p2p_id\");\n\n    // Should return an error if not found\n    assert_eq!(contract.get_ddn_status(p2p_id), Err(Error::DDNNotFound));\n}", "item_id": 32, "repo": "Cerebellum-Network/ddc-smart-contract", "file": "src/ddc/tests.rs", "last_update_at": "2022-01-24T18:05:10+00:00", "question_id": "75feeb57a15caec75223b753a9d57495a352e3ad_32", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_ddn_status_not_found_works() {\n    let contract = make_contract();\n    let p2p_id = String::from(\"test_p2p_id\");\n    // Should return an error if not found\n    assert_eq!(contract.get_ddn_status(p2p_id), Err(Error::DDNNotFound));\n"]], "pred": {"ppl": 4.460237503051758, "ppl_lower": 6.31065034866333, "ppl/lowercase_ppl": -1.2321002228199904, "ppl/zlib": 0.00869303497918298, "Min_5.0% Prob": 9.456297278404236, "Min_10.0% Prob": 7.678507745265961, "Min_20.0% Prob": 5.619284405427821, "Min_30.0% Prob": 4.391022365826827, "Min_40.0% Prob": 3.569202538899013, "Min_50.0% Prob": 2.956523630429398, "Min_60.0% Prob": 2.490495979785919}}
{"hexsha": "0cbf3fa7da9775e62d2210a96cfe1b2bfa3a5381", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout_ThreadExceptionFrameA64 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < ThreadExceptionFrameA64 > ( ) , 120usize , concat ! ( \"Size of: \" , stringify ! ( ThreadExceptionFrameA64 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < ThreadExceptionFrameA64 > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( ThreadExceptionFrameA64 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . cpu_gprs as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( cpu_gprs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . lr as * const _ as usize } , 72usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( lr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . sp as * const _ as usize } , 80usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( sp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . elr_el1 as * const _ as usize } , 88usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( elr_el1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . pstate as * const _ as usize } , 96usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( pstate ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . afsr0 as * const _ as usize } , 100usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( afsr0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . afsr1 as * const _ as usize } , 104usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( afsr1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . esr as * const _ as usize } , 108usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( esr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . far as * const _ as usize } , 112usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( far ) ) ) ; }", "item_id": 12, "repo": "XorTroll/libnx-Rust", "file": "bindgen/libnx.rs", "last_update_at": "2022-02-18T12:36:44+00:00", "question_id": "0cbf3fa7da9775e62d2210a96cfe1b2bfa3a5381_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bindgen_test_layout_ThreadExceptionFrameA64 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < ThreadExceptionFrameA64 > ( ) , 120usize , concat ! ( \"Size of: \" , stringify ! ( ThreadExceptionFrameA64 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < ThreadExceptionFrameA64 > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( ThreadExceptionFrameA64 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . cpu_gprs as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( cpu_gprs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . lr as * const _ as usize } , 72usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( lr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . sp as * const _ as usize } , 80usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( sp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . elr_el1 as * const _ as usize } , 88usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( elr_el1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . pstate as * const _ as usize } , 96usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( pstate ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . afsr0 as * const _ as usize } , 100usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( afsr0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . afsr1 as * const _ as usize } , 104usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( afsr1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . esr as * const _ as usize } , 108usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( esr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . far as * const _ as usize } , 112usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( far ) ) ) ; }\n"]], "pred": {"ppl": 1.2415759563446045, "ppl_lower": 1.2566735744476318, "ppl/lowercase_ppl": -1.055858306704862, "ppl/zlib": 0.00063084986939303, "Min_5.0% Prob": 4.079895268546211, "Min_10.0% Prob": 2.161469997631179, "Min_20.0% Prob": 1.0838343877845718, "Min_30.0% Prob": 0.7214606524168952, "Min_40.0% Prob": 0.542125446588894, "Min_50.0% Prob": 0.4332313665882105, "Min_60.0% Prob": 0.36076474551689375}}
{"hexsha": "d298a20f78a7cd8b9fd933bc3d999cb4a2f685ba", "ext": "rs", "lang": "Rust", "content": "fn make_column(\n    py: Python,\n    children: &PyAny,\n    spacing: Option<u16>,\n    padding: Option<u16>,\n    width: Option<&WrappedLength>,\n    height: Option<&WrappedLength>,\n    max_width: Option<u32>,\n    max_height: Option<u32>,\n    align_items: Option<&WrappedAlign>,\n) -> PyResult<WrappedWidgetBuilder> {\n    let children = children\n        .iter()?\n        .filter_map(|child| match child {\n            Ok(child) => match child.is_none() {\n                false => match child.extract() {\n                    Ok(WrappedWidgetBuilder(widget)) => Some(widget),\n                    Err(err) => {\n                        err.print(py);\n                        None\n                    },\n                },\n                true => None,\n            },\n            Err(err) => {\n                err.print(py);\n                None\n            },\n        })\n        .collect();\n    let el = ColumnBuilder {\n        children,\n        spacing,\n        padding,\n        width: width.map(|o| o.0),\n        height: height.map(|o| o.0),\n        max_width,\n        max_height,\n        align_items: align_items.map(|o| o.0),\n    };\n    Ok(el.into())\n}", "item_id": 0, "repo": "Kijewski/pyiced", "file": "src/widgets/column.rs", "last_update_at": "2022-03-08T10:33:11+00:00", "question_id": "d298a20f78a7cd8b9fd933bc3d999cb4a2f685ba_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn make_column(\n    py: Python,\n    children: &PyAny,\n    spacing: Option<u16>,\n    padding: Option<u16>,\n    width: Option<&WrappedLength>,\n    height: Option<&WrappedLength>,\n    max_width: Option<u32>,\n    max_height: Option<u32>,\n    align_items: Option<&WrappedAlign>,\n) -> PyResult<WrappedWidgetBuilder> {\n    let children = children\n        .iter()?\n        .filter_map(|child| match child {\n            Ok(child) => match child.is_none() {\n                false => match child.extract() {\n                    Ok(WrappedWidgetBuilder(widget)) => Some(widget),\n                    Err(err) => {\n                        err.print(py);\n                        None\n                    },\n                },\n                true => None,\n            },\n            Err(err) => {\n                err.print(py);\n                None\n            },\n        })\n        .collect();\n    let el = ColumnBuilder {\n        children,\n        spacing,\n        padding,\n        width: width.map(|o| o.0),\n        height: height.map(|o| o.0),\n        max_width,\n        max_height,\n        align_items: align_items.map(|o| o.0),\n    };\n    Ok(el.into())\n"]], "pred": {"ppl": 1.928456425666809, "ppl_lower": 2.336056709289551, "ppl/lowercase_ppl": -1.2919729346076525, "ppl/zlib": 0.0016295779242564141, "Min_5.0% Prob": 6.973237612668206, "Min_10.0% Prob": 4.893404126167297, "Min_20.0% Prob": 3.0810725496095768, "Min_30.0% Prob": 2.156901254665618, "Min_40.0% Prob": 1.639153909184696, "Min_50.0% Prob": 1.315699866129195, "Min_60.0% Prob": 1.097328267359248}}
{"hexsha": "51ad805afa4fe2a89e9386dbe4e9973843109ec0", "ext": "rs", "lang": "Rust", "content": "fn gas_add_fixed_range() {\n        assert_eq!(\n            Gas::Range { min: 1, max: 3 },\n            Gas::Fixed(3) + Gas::Range { min: 1, max: 2 }\n        );\n\n        assert_eq!(\n            Gas::Range { min: 1, max: 5 },\n            Gas::Fixed(3) + Gas::Range { min: 1, max: 5 }\n        );\n\n        let mut gas = Gas::Fixed(3);\n        gas += Gas::Range { min: 1, max: 2 };\n        assert_eq!(Gas::Range { min: 1, max: 3 }, gas);\n\n        let mut gas = Gas::Fixed(3);\n        gas += Gas::Range { min: 1, max: 5 };\n        assert_eq!(Gas::Range { min: 1, max: 5 }, gas);\n    }", "item_id": 2, "repo": "kobby-pentangeli/svm", "file": "crates/gas/src/gas.rs", "last_update_at": "2022-01-31T14:56:48+00:00", "question_id": "51ad805afa4fe2a89e9386dbe4e9973843109ec0_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn gas_add_fixed_range() {\n        assert_eq!(\n            Gas::Range { min: 1, max: 3 },\n            Gas::Fixed(3) + Gas::Range { min: 1, max: 2 }\n        );\n        assert_eq!(\n            Gas::Range { min: 1, max: 5 },\n            Gas::Fixed(3) + Gas::Range { min: 1, max: 5 }\n        );\n        let mut gas = Gas::Fixed(3);\n        gas += Gas::Range { min: 1, max: 2 };\n        assert_eq!(Gas::Range { min: 1, max: 3 }, gas);\n        let mut gas = Gas::Fixed(3);\n        gas += Gas::Range { min: 1, max: 5 };\n        assert_eq!(Gas::Range { min: 1, max: 5 }, gas);\n"]], "pred": {"ppl": 1.659521222114563, "ppl_lower": 1.7693085670471191, "ppl/lowercase_ppl": -1.126467925972554, "ppl/zlib": 0.003289150262041373, "Min_5.0% Prob": 6.874356698989868, "Min_10.0% Prob": 4.294702768325806, "Min_20.0% Prob": 2.4779421430687574, "Min_30.0% Prob": 1.6870206458637347, "Min_40.0% Prob": 1.2672505383647379, "Min_50.0% Prob": 1.0125217792330259, "Min_60.0% Prob": 0.8492411842489114}}
{"hexsha": "3e809b385f9b56e557955c72322fdf9b13b17b3e", "ext": "rs", "lang": "Rust", "content": "fn lexer_text_unit_literal_accepted() {\n        let mut lexer = Lexer::from_memory(\"X\", Source::Unknown);\n        let mut lexer = WordLexer {\n            lexer: &mut lexer,\n            context: WordContext::Word,\n        };\n        let mut called = false;\n        let result = block_on(lexer.text_unit(\n            |c| {\n                called = true;\n                assert_eq!(c, 'X');\n                false\n            },\n            |c| panic!(\"unexpected call to is_escapable({:?})\", c),\n        ))\n        .unwrap()\n        .unwrap();\n        assert!(called);\n        if let Literal(c) = result {\n            assert_eq!(c, 'X');\n        } else {\n            panic!(\"unexpected result {:?}\", result);\n        }\n\n        assert_eq!(block_on(lexer.peek_char()), Ok(None));\n    }", "item_id": 0, "repo": "magicant/yash-rs", "file": "yash-syntax/src/parser/lex/text.rs", "last_update_at": "2022-03-24T10:45:57+00:00", "question_id": "3e809b385f9b56e557955c72322fdf9b13b17b3e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn lexer_text_unit_literal_accepted() {\n        let mut lexer = Lexer::from_memory(\"X\", Source::Unknown);\n        let mut lexer = WordLexer {\n            lexer: &mut lexer,\n            context: WordContext::Word,\n        };\n        let mut called = false;\n        let result = block_on(lexer.text_unit(\n            |c| {\n                called = true;\n                assert_eq!(c, 'X');\n                false\n            },\n            |c| panic!(\"unexpected call to is_escapable({:?})\", c),\n        ))\n        .unwrap()\n        .unwrap();\n        assert!(called);\n        if let Literal(c) = result {\n            assert_eq!(c, 'X');\n        } else {\n            panic!(\"unexpected result {:?}\", result);\n        }\n        assert_eq!(block_on(lexer.peek_char()), Ok(None));\n"]], "pred": {"ppl": 2.6414992809295654, "ppl_lower": 3.110379457473755, "ppl/lowercase_ppl": -1.168218074160414, "ppl/zlib": 0.0029524214753851143, "Min_5.0% Prob": 7.353663444519043, "Min_10.0% Prob": 5.79582871561465, "Min_20.0% Prob": 3.96877506438722, "Min_30.0% Prob": 3.0122123513902936, "Min_40.0% Prob": 2.370641386889397, "Min_50.0% Prob": 1.9358556811880863, "Min_60.0% Prob": 1.6144988690866224}}
{"hexsha": "618d60fa67d4afe25f183f31ec8cd5308ae7c79d", "ext": "rs", "lang": "Rust", "content": "fn build_context(program: &Bytes) -> Result<DebugContext, String> {\n    use addr2line::object::{Object, ObjectSection};\n\n    // Adapted from https://github.com/gimli-rs/addr2line/blob/fc2de9f47ae513f5a54448167b476ff50f07dca6/src/lib.rs#L87-L148\n    // for working with gimli::EndianArcSlice type\n    let file = addr2line::object::File::parse(program.as_ref())\n        .map_err(|e| format!(\"object parsing error: {}\", e))?;\n\n    let dwarf = gimli::Dwarf::load(|id| {\n        let data = file\n            .section_by_name(id.name())\n            .and_then(|section| section.uncompressed_data().ok())\n            .unwrap_or(Cow::Borrowed(&[]));\n        Ok(gimli::EndianArcSlice::new(\n            Arc::from(&*data),\n            gimli::RunTimeEndian::Little,\n        ))\n    })\n    .map_err(|e: gimli::Error| format!(\"dwarf load error: {}\", e))?;\n\n    let addr_context = Addr2LineContext::from_dwarf(dwarf)\n        .map_err(|e| format!(\"context creation error: {}\", e))?;\n\n    let debug_frame_section = file\n        .section_by_name(gimli::SectionId::DebugFrame.name())\n        .and_then(|s| s.uncompressed_data().ok())\n        .ok_or_else(|| \"Provided binary is missing .debug_frame section!\".to_string())?;\n    let debug_frame_reader = Addr2LineEndianReader::new(\n        Arc::from(&*debug_frame_section),\n        gimli::RunTimeEndian::Little,\n    );\n\n    Ok(DebugContext {\n        addr_context,\n        debug_frame: debug_frame_reader.into(),\n    })\n}", "item_id": 3, "repo": "xxuejie/ckb-vm-signal-profiler", "file": "src/lib.rs", "last_update_at": "2022-03-29T03:07:22+00:00", "question_id": "618d60fa67d4afe25f183f31ec8cd5308ae7c79d_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn build_context(program: &Bytes) -> Result<DebugContext, String> {\n    use addr2line::object::{Object, ObjectSection};\n    // Adapted from https://github.com/gimli-rs/addr2line/blob/fc2de9f47ae513f5a54448167b476ff50f07dca6/src/lib.rs#L87-L148\n    // for working with gimli::EndianArcSlice type\n    let file = addr2line::object::File::parse(program.as_ref())\n        .map_err(|e| format!(\"object parsing error: {}\", e))?;\n    let dwarf = gimli::Dwarf::load(|id| {\n        let data = file\n            .section_by_name(id.name())\n            .and_then(|section| section.uncompressed_data().ok())\n            .unwrap_or(Cow::Borrowed(&[]));\n        Ok(gimli::EndianArcSlice::new(\n            Arc::from(&*data),\n            gimli::RunTimeEndian::Little,\n        ))\n    })\n    .map_err(|e: gimli::Error| format!(\"dwarf load error: {}\", e))?;\n    let addr_context = Addr2LineContext::from_dwarf(dwarf)\n        .map_err(|e| format!(\"context creation error: {}\", e))?;\n    let debug_frame_section = file\n        .section_by_name(gimli::SectionId::DebugFrame.name())\n        .and_then(|s| s.uncompressed_data().ok())\n        .ok_or_else(|| \"Provided binary is missing .debug_frame section!\".to_string())?;\n    let debug_frame_reader = Addr2LineEndianReader::new(\n        Arc::from(&*debug_frame_section),\n        gimli::RunTimeEndian::Little,\n    );\n    Ok(DebugContext {\n        addr_context,\n        debug_frame: debug_frame_reader.into(),\n    })\n"]], "pred": {"ppl": 2.4350974559783936, "ppl_lower": 3.5941436290740967, "ppl/lowercase_ppl": -1.43744354603765, "ppl/zlib": 0.0013629200286718653, "Min_5.0% Prob": 7.116618724969717, "Min_10.0% Prob": 5.2666869805409355, "Min_20.0% Prob": 3.7770906709489367, "Min_30.0% Prob": 2.832950076347665, "Min_40.0% Prob": 2.2082719101082713, "Min_50.0% Prob": 1.7784639262654482, "Min_60.0% Prob": 1.4834105537827067}}
{"hexsha": "fc93fb4e66d6b5b349a44ebf4b801f4fa091f217", "ext": "rs", "lang": "Rust", "content": "fn unexpected_directive_invalid() {\n    let input = include_str!(\"relay_resolvers/fixtures/unexpected-directive.invalid.graphql\");\n    let expected = include_str!(\"relay_resolvers/fixtures/unexpected-directive.invalid.expected\");\n    test_fixture(transform_fixture, \"unexpected-directive.invalid.graphql\", \"relay_resolvers/fixtures/unexpected-directive.invalid.expected\", input, expected);\n}", "item_id": 7, "repo": "morrys/relay", "file": "compiler/crates/relay-transforms/tests/relay_resolvers_test.rs", "last_update_at": "2022-03-31T10:17:36+00:00", "question_id": "fc93fb4e66d6b5b349a44ebf4b801f4fa091f217_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn unexpected_directive_invalid() {\n    let input = include_str!(\"relay_resolvers/fixtures/unexpected-directive.invalid.graphql\");\n    let expected = include_str!(\"relay_resolvers/fixtures/unexpected-directive.invalid.expected\");\n    test_fixture(transform_fixture, \"unexpected-directive.invalid.graphql\", \"relay_resolvers/fixtures/unexpected-directive.invalid.expected\", input, expected);\n"]], "pred": {"ppl": 1.801527500152588, "ppl_lower": 1.801527500152588, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0038472870341901785, "Min_5.0% Prob": 9.149950122833252, "Min_10.0% Prob": 5.489872520620173, "Min_20.0% Prob": 2.9961930908586667, "Min_30.0% Prob": 1.9981363731037294, "Min_40.0% Prob": 1.4898029341253431, "Min_50.0% Prob": 1.1871168684585305, "Min_60.0% Prob": 0.9865598761014195}}
{"hexsha": "fcea69fb39f98bf184fecd0f9c6a3e9e2e891b0a", "ext": "rs", "lang": "Rust", "content": "pub fn get_replay_addresses(\n    dwarf: &Dwarf<EndianSlice<RunTimeEndian>>,\n) -> Result<ObjectLocationMap> {\n    let mut objects: ObjectLocationMap = HashMap::new();\n    // Iterate over the compilation units.\n    let mut iter = dwarf.units();\n    while let Some(header) = iter.next()? {\n        let unit = dwarf.unit(header)?;\n        let entries = parser::parse_variable_entries(&dwarf, &unit, &header)?;\n        for entry in entries {\n            objects.insert(entry.name, entry.address);\n        }\n    }\n    Ok(objects)\n}", "item_id": 1, "repo": "markhakansson/rauk", "file": "src/measure/dwarf/mod.rs", "last_update_at": "2022-03-18T08:46:46+00:00", "question_id": "fcea69fb39f98bf184fecd0f9c6a3e9e2e891b0a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_replay_addresses(\n    dwarf: &Dwarf<EndianSlice<RunTimeEndian>>,\n) -> Result<ObjectLocationMap> {\n    let mut objects: ObjectLocationMap = HashMap::new();\n    // Iterate over the compilation units.\n    let mut iter = dwarf.units();\n    while let Some(header) = iter.next()? {\n        let unit = dwarf.unit(header)?;\n        let entries = parser::parse_variable_entries(&dwarf, &unit, &header)?;\n        for entry in entries {\n            objects.insert(entry.name, entry.address);\n        }\n    }\n    Ok(objects)\n"]], "pred": {"ppl": 2.929945945739746, "ppl_lower": 4.3767242431640625, "ppl/lowercase_ppl": -1.3733233147444055, "ppl/zlib": 0.0036941030044873252, "Min_5.0% Prob": 8.421317398548126, "Min_10.0% Prob": 6.8958726823329926, "Min_20.0% Prob": 4.601005550586816, "Min_30.0% Prob": 3.3796304500103, "Min_40.0% Prob": 2.6610447721499386, "Min_50.0% Prob": 2.1447202843355844, "Min_60.0% Prob": 1.7913816208019853}}
{"hexsha": "436c8df3a12786557a9b473da80f4bf93dd92cdb", "ext": "rs", "lang": "Rust", "content": "pub fn init<Traits: TimerInstance>() {\n    let tcfg = &Traits::TICKLESS_CFG;\n\n    // Safety: No context switching during boot\n    let tstate = unsafe { &mut *Traits::tickless_state() };\n\n    tstate.reset(tcfg, Traits::time_lo() as u32);\n}", "item_id": 2, "repo": "r3-os/r3", "file": "src/r3_port_riscv/src/sbi_timer/imp.rs", "last_update_at": "2022-03-22T01:13:51+00:00", "question_id": "436c8df3a12786557a9b473da80f4bf93dd92cdb_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn init<Traits: TimerInstance>() {\n    let tcfg = &Traits::TICKLESS_CFG;\n    // Safety: No context switching during boot\n    let tstate = unsafe { &mut *Traits::tickless_state() };\n    tstate.reset(tcfg, Traits::time_lo() as u32);\n"]], "pred": {"ppl": 7.5836262702941895, "ppl_lower": 10.289506912231445, "ppl/lowercase_ppl": -1.1506092926832014, "ppl/zlib": 0.011318388184539388, "Min_5.0% Prob": 9.247864723205566, "Min_10.0% Prob": 8.04788339138031, "Min_20.0% Prob": 6.579673739040599, "Min_30.0% Prob": 5.51335240327395, "Min_40.0% Prob": 4.678734863505644, "Min_50.0% Prob": 3.9332385811694834, "Min_60.0% Prob": 3.3374549792363095}}
{"hexsha": "83fb55ac55ad311397f4a8d72e4bfbae1bff2476", "ext": "rs", "lang": "Rust", "content": "fn port_midi_can_get_max_event_size() {\n        // open clients and ports\n        let c = open_test_client(\"port_midi_cglc\");\n        let mut out_p = c.register_port(\"op\", MidiOut::default()).unwrap();\n\n        // set callback routine\n        let process_callback = move |_: &Client, ps: &ProcessScope| -> Control {\n            let out_p = out_p.writer(ps);\n            PMCGMES_MAX_EVENT_SIZE.fetch_add(out_p.max_event_size(), Ordering::Relaxed);\n            Control::Continue\n        };\n\n        // activate\n        let ac = c\n            .activate_async((), ClosureProcessHandler::new(process_callback))\n            .unwrap();\n\n        // check correctness\n        assert!(PMCGMES_MAX_EVENT_SIZE.load(Ordering::Relaxed) > 0);\n        ac.deactivate().unwrap();\n    }", "item_id": 1, "repo": "Be-ing/rust-jack", "file": "src/port/midi.rs", "last_update_at": "2022-03-25T10:01:34+00:00", "question_id": "83fb55ac55ad311397f4a8d72e4bfbae1bff2476_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn port_midi_can_get_max_event_size() {\n        // open clients and ports\n        let c = open_test_client(\"port_midi_cglc\");\n        let mut out_p = c.register_port(\"op\", MidiOut::default()).unwrap();\n        // set callback routine\n        let process_callback = move |_: &Client, ps: &ProcessScope| -> Control {\n            let out_p = out_p.writer(ps);\n            PMCGMES_MAX_EVENT_SIZE.fetch_add(out_p.max_event_size(), Ordering::Relaxed);\n            Control::Continue\n        };\n        // activate\n        let ac = c\n            .activate_async((), ClosureProcessHandler::new(process_callback))\n            .unwrap();\n        // check correctness\n        assert!(PMCGMES_MAX_EVENT_SIZE.load(Ordering::Relaxed) > 0);\n        ac.deactivate().unwrap();\n"]], "pred": {"ppl": 4.916091442108154, "ppl_lower": 6.205003261566162, "ppl/lowercase_ppl": -1.1462104459929747, "ppl/zlib": 0.004201883357382139, "Min_5.0% Prob": 10.792002042134603, "Min_10.0% Prob": 8.793183525403341, "Min_20.0% Prob": 6.374163468678792, "Min_30.0% Prob": 4.841860892021493, "Min_40.0% Prob": 3.851316965117897, "Min_50.0% Prob": 3.1441045894486006, "Min_60.0% Prob": 2.6510845728932995}}
{"hexsha": "9e7bd9389b966dbd7dee5731f391c7dbf7ed5188", "ext": "rs", "lang": "Rust", "content": "fn draw_border(settings: &Settings, cursor: &TerminalCursor) {\n    let room = &settings.room;\n    let chars = &settings.chars;\n\n    let draw_horizontal = |y: u16| {\n        let border_char = &chars.room.border_horizontal;\n        let printable = printable_maybe_repeat(\n            border_char,\n            Some(settings.room.width as usize),\n        );\n        cursor.goto(0, y).unwrap();\n        print!(\"{}\", printable);\n    };\n    let draw_vertical = |x: u16| {\n        let border_char = &chars.room.border_vertical;\n        let printable = printable_maybe_repeat(border_char, None);\n        for y in 0 .. room.height {\n            cursor.goto(x, y).unwrap();\n            print!(\"{}\", printable);\n        }\n    };\n\n    let right = room.width - 1;\n    let bottom = room.height - 1;\n    draw_horizontal(0);\n    draw_horizontal(bottom);\n    draw_vertical(0);\n    draw_vertical(right);\n    // Draw corners\n    let corner_printable =\n        printable_maybe_repeat(&chars.room.border_corner, None);\n    cursor.goto(0, 0).unwrap();\n    print!(\"{}\", corner_printable);\n    cursor.goto(right, 0).unwrap();\n    print!(\"{}\", corner_printable);\n    cursor.goto(0, bottom).unwrap();\n    print!(\"{}\", corner_printable);\n    cursor.goto(right, bottom).unwrap();\n    print!(\"{}\", corner_printable);\n}", "item_id": 2, "repo": "Noah2610/pong-cli", "file": "src/systems/draw_room.rs", "last_update_at": "2022-03-19T10:57:17+00:00", "question_id": "9e7bd9389b966dbd7dee5731f391c7dbf7ed5188_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn draw_border(settings: &Settings, cursor: &TerminalCursor) {\n    let room = &settings.room;\n    let chars = &settings.chars;\n    let draw_horizontal = |y: u16| {\n        let border_char = &chars.room.border_horizontal;\n        let printable = printable_maybe_repeat(\n            border_char,\n            Some(settings.room.width as usize),\n        );\n        cursor.goto(0, y).unwrap();\n        print!(\"{}\", printable);\n    };\n    let draw_vertical = |x: u16| {\n        let border_char = &chars.room.border_vertical;\n        let printable = printable_maybe_repeat(border_char, None);\n        for y in 0 .. room.height {\n            cursor.goto(x, y).unwrap();\n            print!(\"{}\", printable);\n        }\n    };\n    let right = room.width - 1;\n    let bottom = room.height - 1;\n    draw_horizontal(0);\n    draw_horizontal(bottom);\n    draw_vertical(0);\n    draw_vertical(right);\n    // Draw corners\n    let corner_printable =\n        printable_maybe_repeat(&chars.room.border_corner, None);\n    cursor.goto(0, 0).unwrap();\n    print!(\"{}\", corner_printable);\n    cursor.goto(right, 0).unwrap();\n    print!(\"{}\", corner_printable);\n    cursor.goto(0, bottom).unwrap();\n    print!(\"{}\", corner_printable);\n    cursor.goto(right, bottom).unwrap();\n    print!(\"{}\", corner_printable);\n"]], "pred": {"ppl": 1.7675087451934814, "ppl_lower": 1.8722034692764282, "ppl/lowercase_ppl": -1.1010321623219312, "ppl/zlib": 0.0014988712277684525, "Min_5.0% Prob": 6.677358269691467, "Min_10.0% Prob": 4.539927691221237, "Min_20.0% Prob": 2.672056794166565, "Min_30.0% Prob": 1.8656187693847985, "Min_40.0% Prob": 1.4183470042753805, "Min_50.0% Prob": 1.137237820806274, "Min_60.0% Prob": 0.9519036187013596}}
{"hexsha": "cbcf5eccfb6cbebf5ac428959796b460a16c2acd", "ext": "rs", "lang": "Rust", "content": "fn test_from_into_diff() {\n    let service: Service = service();\n\n    let diff: DiffService = service.clone().into_diff().unwrap();\n    let new: Service = Service::from_diff(diff.clone()).unwrap();\n    assert_eq!(new, service);\n\n    let ser: String = diff.to_json().unwrap();\n    let de: DiffService = DiffService::from_json(&ser).unwrap();\n    assert_eq!(diff, de);\n    let from: Service = Service::from_diff(de).unwrap();\n    assert_eq!(from, service);\n  }", "item_id": 7, "repo": "Dr-Electron/identity.rs", "file": "identity-did/src/diff/diff_service.rs", "last_update_at": "2022-02-02T16:32:22+00:00", "question_id": "cbcf5eccfb6cbebf5ac428959796b460a16c2acd_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_from_into_diff() {\n    let service: Service = service();\n    let diff: DiffService = service.clone().into_diff().unwrap();\n    let new: Service = Service::from_diff(diff.clone()).unwrap();\n    assert_eq!(new, service);\n    let ser: String = diff.to_json().unwrap();\n    let de: DiffService = DiffService::from_json(&ser).unwrap();\n    assert_eq!(diff, de);\n    let from: Service = Service::from_diff(de).unwrap();\n    assert_eq!(from, service);\n"]], "pred": {"ppl": 2.5898995399475098, "ppl_lower": 3.074761390686035, "ppl/lowercase_ppl": -1.1803328839448506, "ppl/zlib": 0.005171842865728974, "Min_5.0% Prob": 7.783291271754673, "Min_10.0% Prob": 6.013396348272051, "Min_20.0% Prob": 3.997684256783847, "Min_30.0% Prob": 3.0097205292346865, "Min_40.0% Prob": 2.3313932752814788, "Min_50.0% Prob": 1.9018437021101515, "Min_60.0% Prob": 1.581371151745833}}
{"hexsha": "ad6448553bad6a18e0be3c2fe80008aa9d54e53c", "ext": "rs", "lang": "Rust", "content": "async fn do_not_read_network_from_legacy_storage_and_delete_file() {\n        // Possible contents of a file generated from KnownEssStore, with networks foo and bar with\n        // passwords foobar and password respecitively. Network foo should not be read into new\n        // saved network manager because the password is too short for a valid network password.\n        let contents = b\"[{\\\"ssid\\\":[102,111,111],\\\"password\\\":[102,111,111,98,97,114]},\n            {\\\"ssid\\\":[98,97,114],\\\"password\\\":[112, 97, 115, 115, 119, 111, 114, 100]}]\";\n        let temp_dir = TempDir::new().expect(\"failed to create temporary directory\");\n        let path = temp_dir.path().join(\"networks.json\");\n        let mut file = fs::File::create(&path).expect(\"failed to open file for writing\");\n\n        assert_eq!(file.write(contents).expect(\"Failed to write to file\"), contents.len());\n        file.flush().expect(\"failed to flush contents of file\");\n\n        let stash_id = \"read_network_from_legacy_storage\";\n        let saved_networks = SavedNetworksManager::new_with_stash_or_paths(\n            stash_id,\n            &path,\n            create_mock_cobalt_sender(),\n        )\n        .await\n        .expect(\"failed to create saved networks store\");\n\n        // Network should not be read. The backing file should be deleted.\n        assert_eq!(0, saved_networks.known_network_count().await);\n        assert!(!path.exists());\n    }", "item_id": 24, "repo": "fabio-d/fuchsia-stardock", "file": "src/connectivity/wlan/wlancfg/src/config_management/config_manager.rs", "last_update_at": "2022-01-21T20:14:17+00:00", "question_id": "ad6448553bad6a18e0be3c2fe80008aa9d54e53c_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn do_not_read_network_from_legacy_storage_and_delete_file() {\n        // Possible contents of a file generated from KnownEssStore, with networks foo and bar with\n        // passwords foobar and password respecitively. Network foo should not be read into new\n        // saved network manager because the password is too short for a valid network password.\n        let contents = b\"[{\\\"ssid\\\":[102,111,111],\\\"password\\\":[102,111,111,98,97,114]},\n            {\\\"ssid\\\":[98,97,114],\\\"password\\\":[112, 97, 115, 115, 119, 111, 114, 100]}]\";\n        let temp_dir = TempDir::new().expect(\"failed to create temporary directory\");\n        let path = temp_dir.path().join(\"networks.json\");\n        let mut file = fs::File::create(&path).expect(\"failed to open file for writing\");\n        assert_eq!(file.write(contents).expect(\"Failed to write to file\"), contents.len());\n        file.flush().expect(\"failed to flush contents of file\");\n        let stash_id = \"read_network_from_legacy_storage\";\n        let saved_networks = SavedNetworksManager::new_with_stash_or_paths(\n            stash_id,\n            &path,\n            create_mock_cobalt_sender(),\n        )\n        .await\n        .expect(\"failed to create saved networks store\");\n        // Network should not be read. The backing file should be deleted.\n        assert_eq!(0, saved_networks.known_network_count().await);\n        assert!(!path.exists());\n"]], "pred": {"ppl": 2.687413454055786, "ppl_lower": 3.244117259979248, "ppl/lowercase_ppl": -1.1904390609032398, "ppl/zlib": 0.0015691733171320885, "Min_5.0% Prob": 7.8914407600056045, "Min_10.0% Prob": 6.057318123904142, "Min_20.0% Prob": 4.176646618680521, "Min_30.0% Prob": 3.0792850201780144, "Min_40.0% Prob": 2.404631673273715, "Min_50.0% Prob": 1.9588010637936266, "Min_60.0% Prob": 1.642827430429558}}
{"hexsha": "884bae434a424fe9c10f1165f1c91cef6c285d03", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn test_chunk_compression_rw(compression: compression::CompressionType) {\n    let array_meta = ArrayMetadata::new(\n        smallvec![10, 10, 10],\n        smallvec![5, 5, 5],\n        i32::ZARR_TYPE,\n        compression,\n    );\n    let chunk_data: Vec<i32> = (0..125_i32).collect();\n    let chunk_in = SliceDataChunk::new(smallvec![0, 0, 0], &chunk_data);\n\n    let mut inner: Vec<u8> = Vec::new();\n\n    <DefaultChunk as DefaultChunkWriter<i32, _, _>>::write_chunk(\n        &mut inner,\n        &array_meta,\n        &chunk_in,\n    )\n    .expect(\"write_chunk failed\");\n\n    let chunk_out = <DefaultChunk as DefaultChunkReader<i32, _>>::read_chunk(\n        &inner[..],\n        &array_meta,\n        smallvec![0, 0, 0],\n    )\n    .expect(\"read_chunk failed\");\n\n    assert_eq!(chunk_out.get_grid_position(), &[0, 0, 0]);\n    assert_eq!(chunk_out.get_data(), &chunk_data[..]);\n}", "item_id": 3, "repo": "sci-rs/zarr", "file": "src/tests.rs", "last_update_at": "2022-03-23T01:23:14+00:00", "question_id": "884bae434a424fe9c10f1165f1c91cef6c285d03_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn test_chunk_compression_rw(compression: compression::CompressionType) {\n    let array_meta = ArrayMetadata::new(\n        smallvec![10, 10, 10],\n        smallvec![5, 5, 5],\n        i32::ZARR_TYPE,\n        compression,\n    );\n    let chunk_data: Vec<i32> = (0..125_i32).collect();\n    let chunk_in = SliceDataChunk::new(smallvec![0, 0, 0], &chunk_data);\n    let mut inner: Vec<u8> = Vec::new();\n    <DefaultChunk as DefaultChunkWriter<i32, _, _>>::write_chunk(\n        &mut inner,\n        &array_meta,\n        &chunk_in,\n    )\n    .expect(\"write_chunk failed\");\n    let chunk_out = <DefaultChunk as DefaultChunkReader<i32, _>>::read_chunk(\n        &inner[..],\n        &array_meta,\n        smallvec![0, 0, 0],\n    )\n    .expect(\"read_chunk failed\");\n    assert_eq!(chunk_out.get_grid_position(), &[0, 0, 0]);\n    assert_eq!(chunk_out.get_data(), &chunk_data[..]);\n"]], "pred": {"ppl": 2.2521591186523438, "ppl_lower": 2.7758545875549316, "ppl/lowercase_ppl": -1.2575095869765982, "ppl/zlib": 0.0021421882965080834, "Min_5.0% Prob": 7.902578353881836, "Min_10.0% Prob": 5.643384297688802, "Min_20.0% Prob": 3.512244299276551, "Min_30.0% Prob": 2.5309163402802874, "Min_40.0% Prob": 1.9832267299739283, "Min_50.0% Prob": 1.6124852271307082, "Min_60.0% Prob": 1.3502020522915195}}
{"hexsha": "94f0e35732ff5de7f6c6a9dfcd1b6346522b80cd", "ext": "rs", "lang": "Rust", "content": "fn it_puts_the_query_params_on_the_uri() {\n        let ep = All::default()\n            .with_cursor(\"CURSOR\")\n            .with_limit(123)\n            .with_order(Direction::Desc);\n        let req = ep.into_request(\"https://www.google.com\").unwrap();\n        assert_eq!(req.uri().path(), \"/effects\");\n        assert_eq!(\n            req.uri().query(),\n            Some(\"order=desc&cursor=CURSOR&limit=123\")\n        );\n    }", "item_id": 1, "repo": "nebkor/stellar-sdk", "file": "client/src/endpoint/effect.rs", "last_update_at": "2022-03-21T11:54:02+00:00", "question_id": "94f0e35732ff5de7f6c6a9dfcd1b6346522b80cd_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn it_puts_the_query_params_on_the_uri() {\n        let ep = All::default()\n            .with_cursor(\"CURSOR\")\n            .with_limit(123)\n            .with_order(Direction::Desc);\n        let req = ep.into_request(\"https://www.google.com\").unwrap();\n        assert_eq!(req.uri().path(), \"/effects\");\n        assert_eq!(\n            req.uri().query(),\n            Some(\"order=desc&cursor=CURSOR&limit=123\")\n        );\n"]], "pred": {"ppl": 2.7239813804626465, "ppl_lower": 3.354548692703247, "ppl/lowercase_ppl": -1.2077874688094519, "ppl/zlib": 0.004158068684223109, "Min_5.0% Prob": 9.155468384424845, "Min_10.0% Prob": 6.619007605772752, "Min_20.0% Prob": 4.317581159097177, "Min_30.0% Prob": 3.1933109425916903, "Min_40.0% Prob": 2.475182970816439, "Min_50.0% Prob": 1.9949051844684973, "Min_60.0% Prob": 1.6845645398901004}}
{"hexsha": "145a76c705315bebea22d96a3d1a877ff5f4ba5b", "ext": "rs", "lang": "Rust", "content": "fn test_init() {\n        let dst = Path::new(\"dst_test_init_writer\");\n        std::fs::create_dir(dst).unwrap();\n        let _ = WriterDoc::new(dst, \"en\", Some(1_000_000));\n        std::fs::remove_dir_all(dst).unwrap();\n    }", "item_id": 0, "repo": "pjox/ungoliant", "file": "src/io/writer/writer_doc.rs", "last_update_at": "2022-03-29T18:15:26+00:00", "question_id": "145a76c705315bebea22d96a3d1a877ff5f4ba5b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_init() {\n        let dst = Path::new(\"dst_test_init_writer\");\n        std::fs::create_dir(dst).unwrap();\n        let _ = WriterDoc::new(dst, \"en\", Some(1_000_000));\n        std::fs::remove_dir_all(dst).unwrap();\n"]], "pred": {"ppl": 4.038154125213623, "ppl_lower": 5.842929840087891, "ppl/lowercase_ppl": -1.264685432701818, "ppl/zlib": 0.009495154339204, "Min_5.0% Prob": 10.012298107147217, "Min_10.0% Prob": 7.953846096992493, "Min_20.0% Prob": 5.622902050614357, "Min_30.0% Prob": 4.131960477828979, "Min_40.0% Prob": 3.352137955752286, "Min_50.0% Prob": 2.7310780620291117, "Min_60.0% Prob": 2.333197404444218}}
{"hexsha": "07a534096d670567b68a8c0a91fabca805b06e05", "ext": "rs", "lang": "Rust", "content": "fn view_macroblock_history(model: &Model) -> Vec<Node<GMsg>> {\n    let is_visible = !model.frames.is_empty() && model.selected_macroblock.is_some();\n    let is_hint_visible = !model.frames.is_empty() && model.selected_macroblock.is_none();\n    let canvas_attrs = attrs! {\n        At::Width => 128,\n        At::Height => 128,\n    };\n    let macroblock_info = model\n        .selected_macroblock\n        .map(|i| &model.frames[model.selected_frame].stats.macroblock_info[i]);\n    let kind = macroblock_info.map(|x| &x.kind);\n    let previous_reference_text = match kind {\n        Some(MacroblockInfoKind::Intra) => \"intra\",\n        Some(MacroblockInfoKind::Moved { .. } | MacroblockInfoKind::Interpolated { .. }) => {\n            \"direction\"\n        }\n        _ => \"\",\n    };\n\n    nodes![\n        div![\n            C![\"macroblock-history\"],\n            C![IF!(!is_visible => \"-hidden\")],\n            h3![\"Macroblock history\"],\n            p![\n                \"Macroblock type: \",\n                kind.map(|x| strong![format_macroblock_kind(x).to_string()])\n            ],\n            div![\n                C![\"history-container\"],\n                IF!(matches!(kind, Some(MacroblockInfoKind::Skipped)) => C![\"-skipped\"]),\n                IF!(matches!(kind, Some(MacroblockInfoKind::Intra)) => C![\"-intra\"]),\n                IF!(matches!(kind, Some(MacroblockInfoKind::Moved { is_forward: true, ..  })) => C![\"-forward\"]),\n                IF!(matches!(kind, Some(MacroblockInfoKind::Moved { is_forward: false, ..  })) => C![\"-backward\"]),\n                IF!(matches!(kind, Some(MacroblockInfoKind::Interpolated { ..  })) => C![\"-interpolated\"]),\n                div![\n                    C![\"image previous-reference\"],\n                    canvas![\n                        &canvas_attrs,\n                        el_ref(&model.canvas_history_previous_reference)\n                    ],\n                    \"Previous reference\"\n                ],\n                div![\n                    C![\"arrow -right from-previous-reference\"],\n                    attrs! {At::from(\"data-text\") => previous_reference_text},\n                ],\n                div![\n                    C![\"image previous-before-diff\"],\n                    canvas![\n                        &canvas_attrs,\n                        el_ref(&model.canvas_history_previous_before_diff)\n                    ],\n                    \"Moved macroblock\"\n                ],\n                div![\n                    C![\"arrow -right from-previous-before-diff\"],\n                    attrs! {At::from(\"data-text\") => \"difference\"},\n                ],\n                div![\n                    C![\"vertical-container\"],\n                    div![\n                        C![\"image interpolated\"],\n                        canvas![&canvas_attrs, el_ref(&model.canvas_history_interpolated)],\n                        \"Interpolation result\"\n                    ],\n                    div![\n                        C![\"arrow -down from-interpolated\"],\n                        attrs! {At::from(\"data-text\") => \"difference\"},\n                    ],\n                    div![\n                        C![\"image result\"],\n                        canvas![&canvas_attrs, el_ref(&model.canvas_history_result)],\n                        \"Result\"\n                    ],\n                ],\n                div![\n                    C![\"arrow -left from-next-before-diff\"],\n                    attrs! {At::from(\"data-text\") => \"difference\"},\n                ],\n                div![\n                    C![\"image next-before-diff\"],\n                    canvas![\n                        &canvas_attrs,\n                        el_ref(&model.canvas_history_next_before_diff)\n                    ],\n                    \"Moved macroblock\"\n                ],\n                div![\n                    C![\"arrow -left from-next-reference\"],\n                    attrs! {At::from(\"data-text\") => \"direction\"},\n                ],\n                div![\n                    C![\"image next-reference\"],\n                    canvas![&canvas_attrs, el_ref(&model.canvas_history_next_reference)],\n                    \"Next reference\"\n                ],\n            ]\n        ]\n        div![\n            C![\"macroblock-selection-hint\"],\n            C![IF!(!is_hint_visible => \"-hidden\")],\n            strong![\"Hint: \"],\n            \"Click on the frame above to show information about corresponding macroblock\"\n        ]\n    ]\n}", "item_id": 1, "repo": "jpeg-mpeg-visualizer/jpeg-mpeg-visualizer", "file": "src/section/mpeg_visualization/view.rs", "last_update_at": "2022-01-11T12:06:29+00:00", "question_id": "07a534096d670567b68a8c0a91fabca805b06e05_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn view_macroblock_history(model: &Model) -> Vec<Node<GMsg>> {\n    let is_visible = !model.frames.is_empty() && model.selected_macroblock.is_some();\n    let is_hint_visible = !model.frames.is_empty() && model.selected_macroblock.is_none();\n    let canvas_attrs = attrs! {\n        At::Width => 128,\n        At::Height => 128,\n    };\n    let macroblock_info = model\n        .selected_macroblock\n        .map(|i| &model.frames[model.selected_frame].stats.macroblock_info[i]);\n    let kind = macroblock_info.map(|x| &x.kind);\n    let previous_reference_text = match kind {\n        Some(MacroblockInfoKind::Intra) => \"intra\",\n        Some(MacroblockInfoKind::Moved { .. } | MacroblockInfoKind::Interpolated { .. }) => {\n            \"direction\"\n        }\n        _ => \"\",\n    };\n    nodes![\n        div![\n            C![\"macroblock-history\"],\n            C![IF!(!is_visible => \"-hidden\")],\n            h3![\"Macroblock history\"],\n            p![\n                \"Macroblock type: \",\n                kind.map(|x| strong![format_macroblock_kind(x).to_string()])\n            ],\n            div![\n                C![\"history-container\"],\n                IF!(matches!(kind, Some(MacroblockInfoKind::Skipped)) => C![\"-skipped\"]),\n                IF!(matches!(kind, Some(MacroblockInfoKind::Intra)) => C![\"-intra\"]),\n                IF!(matches!(kind, Some(MacroblockInfoKind::Moved { is_forward: true, ..  })) => C![\"-forward\"]),\n                IF!(matches!(kind, Some(MacroblockInfoKind::Moved { is_forward: false, ..  })) => C![\"-backward\"]),\n                IF!(matches!(kind, Some(MacroblockInfoKind::Interpolated { ..  })) => C![\"-interpolated\"]),\n                div![\n                    C![\"image previous-reference\"],\n                    canvas![\n                        &canvas_attrs,\n                        el_ref(&model.canvas_history_previous_reference)\n                    ],\n                    \"Previous reference\"\n                ],\n                div![\n                    C![\"arrow -right from-previous-reference\"],\n                    attrs! {At::from(\"data-text\") => previous_reference_text},\n                ],\n                div![\n                    C![\"image previous-before-diff\"],\n                    canvas![\n                        &canvas_attrs,\n                        el_ref(&model.canvas_history_previous_before_diff)\n                    ],\n                    \"Moved macroblock\"\n                ],\n                div![\n                    C![\"arrow -right from-previous-before-diff\"],\n                    attrs! {At::from(\"data-text\") => \"difference\"},\n                ],\n                div![\n                    C![\"vertical-container\"],\n                    div![\n                        C![\"image interpolated\"],\n                        canvas![&canvas_attrs, el_ref(&model.canvas_history_interpolated)],\n                        \"Interpolation result\"\n                    ],\n                    div![\n                        C![\"arrow -down from-interpolated\"],\n                        attrs! {At::from(\"data-text\") => \"difference\"},\n                    ],\n                    div![\n                        C![\"image result\"],\n                        canvas![&canvas_attrs, el_ref(&model.canvas_history_result)],\n                        \"Result\"\n                    ],\n                ],\n                div![\n                    C![\"arrow -left from-next-before-diff\"],\n                    attrs! {At::from(\"data-text\") => \"difference\"},\n                ],\n                div![\n                    C![\"image next-before-diff\"],\n                    canvas![\n                        &canvas_attrs,\n                        el_ref(&model.canvas_history_next_before_diff)\n                    ],\n                    \"Moved macroblock\"\n                ],\n                div![\n                    C![\"arrow -left from-next-reference\"],\n                    attrs! {At::from(\"data-text\") => \"direction\"},\n                ],\n                div![\n                    C![\"image next-reference\"],\n                    canvas![&canvas_attrs, el_ref(&model.canvas_history_next_reference)],\n                    \"Next reference\"\n                ],\n            ]\n        ]\n        div![\n            C![\"macroblock-selection-hint\"],\n            C![IF!(!is_hint_visible => \"-hidden\")],\n            strong![\"Hint: \"],\n            \"Click on the frame above to show information about corresponding macroblock\"\n        ]\n    ]\n"]], "pred": {"ppl": 1.8768938779830933, "ppl_lower": 2.0601954460144043, "ppl/lowercase_ppl": -1.1479986354474203, "ppl/zlib": 0.0006851123154562836, "Min_5.0% Prob": 7.02393456066356, "Min_10.0% Prob": 5.010810076021681, "Min_20.0% Prob": 2.993923034299822, "Min_30.0% Prob": 2.076394215834881, "Min_40.0% Prob": 1.568318569754913, "Min_50.0% Prob": 1.2589935395436511, "Min_60.0% Prob": 1.050359968479258}}
{"hexsha": "908e270555dc1efde907e4e021368817b4d04fbc", "ext": "rs", "lang": "Rust", "content": "fn const_test(term: Term) {\n        init();\n        let mut cs = Computation::new(true);\n        cs.assert(term.clone());\n        cs.assert(leaf_term(Op::Const(Value::Bool(true))));\n        let ilp = to_ilp(cs);\n        let r = ilp.solve(default_solver);\n        if r.is_err() {\n            panic!(\"Error: {:?} on {}\", r, term)\n        }\n    }", "item_id": 3, "repo": "julesdesmit/circ", "file": "src/target/ilp/trans.rs", "last_update_at": "2022-03-31T21:36:45+00:00", "question_id": "908e270555dc1efde907e4e021368817b4d04fbc_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn const_test(term: Term) {\n        init();\n        let mut cs = Computation::new(true);\n        cs.assert(term.clone());\n        cs.assert(leaf_term(Op::Const(Value::Bool(true))));\n        let ilp = to_ilp(cs);\n        let r = ilp.solve(default_solver);\n        if r.is_err() {\n            panic!(\"Error: {:?} on {}\", r, term)\n        }\n"]], "pred": {"ppl": 4.792842388153076, "ppl_lower": 5.766074180603027, "ppl/lowercase_ppl": -1.1179663328384788, "ppl/zlib": 0.007719820866403401, "Min_5.0% Prob": 10.061317443847656, "Min_10.0% Prob": 8.26021181453358, "Min_20.0% Prob": 5.677519653154456, "Min_30.0% Prob": 4.391155757222857, "Min_40.0% Prob": 3.619297245715527, "Min_50.0% Prob": 3.0369587581036455, "Min_60.0% Prob": 2.584707646302774}}
{"hexsha": "c4a96cf9191285bd7e65aac700530f7a4ec11eca", "ext": "rs", "lang": "Rust", "content": "fn private_corpus() {\n    let _ = env_logger::init();\n\n    let options = glob::MatchOptions {\n        case_sensitive: true,\n        require_literal_separator: true,\n        require_literal_leading_dot: true,\n    };\n    for entry in glob::glob_with(\"../private/**/*.idx\", &options).unwrap() {\n        let entry = entry.unwrap();\n        process_file(&entry);\n    }\n}", "item_id": 0, "repo": "sykul/subtitles-rs", "file": "subtitle_ocr/tests/ocr_corpus.rs", "last_update_at": "2022-03-10T00:47:05+00:00", "question_id": "c4a96cf9191285bd7e65aac700530f7a4ec11eca_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn private_corpus() {\n    let _ = env_logger::init();\n    let options = glob::MatchOptions {\n        case_sensitive: true,\n        require_literal_separator: true,\n        require_literal_leading_dot: true,\n    };\n    for entry in glob::glob_with(\"../private/**/*.idx\", &options).unwrap() {\n        let entry = entry.unwrap();\n        process_file(&entry);\n    }\n"]], "pred": {"ppl": 2.4412567615509033, "ppl_lower": 3.0677242279052734, "ppl/lowercase_ppl": -1.2559324367061775, "ppl/zlib": 0.004209966853365223, "Min_5.0% Prob": 8.859128952026367, "Min_10.0% Prob": 6.391296646811745, "Min_20.0% Prob": 3.991714883934368, "Min_30.0% Prob": 2.8959250061800987, "Min_40.0% Prob": 2.237566546282985, "Min_50.0% Prob": 1.7792707975687725, "Min_60.0% Prob": 1.4905814863741398}}
{"hexsha": "e4ce04d58e035599f2e904b41e1e7fe2e4e2ef23", "ext": "rs", "lang": "Rust", "content": "async fn submit_tx_when_service_is_frozen() {\n    let (mut testkit, api) = init_testkit();\n    let keys = testkit.us().service_keypair();\n\n    let tx = keys.freeze_service(SUPERVISOR_INSTANCE_ID, SERVICE_ID);\n    let block = testkit.create_block_with_transaction(tx);\n    block[0].status().expect(\"Cannot freeze service\");\n\n    let ping = PingQuery { value: 64 };\n    let err = api\n        .public(ApiKind::Service(\"api-service\"))\n        .query(&ping)\n        .post::<()>(\"submit-tx\")\n        .await\n        .expect_err(\"Request to the valid endpoint should fail\");\n    assert_eq!(err.http_code, api::HttpStatusCode::SERVICE_UNAVAILABLE);\n    assert_eq!(err.body.title, \"Service is not active\");\n\n    let block = testkit.create_block();\n    assert!(block.is_empty());\n}", "item_id": 8, "repo": "Kollego/exonum", "file": "test-suite/testkit/tests/api.rs", "last_update_at": "2022-03-17T07:37:15+00:00", "question_id": "e4ce04d58e035599f2e904b41e1e7fe2e4e2ef23_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn submit_tx_when_service_is_frozen() {\n    let (mut testkit, api) = init_testkit();\n    let keys = testkit.us().service_keypair();\n    let tx = keys.freeze_service(SUPERVISOR_INSTANCE_ID, SERVICE_ID);\n    let block = testkit.create_block_with_transaction(tx);\n    block[0].status().expect(\"Cannot freeze service\");\n    let ping = PingQuery { value: 64 };\n    let err = api\n        .public(ApiKind::Service(\"api-service\"))\n        .query(&ping)\n        .post::<()>(\"submit-tx\")\n        .await\n        .expect_err(\"Request to the valid endpoint should fail\");\n    assert_eq!(err.http_code, api::HttpStatusCode::SERVICE_UNAVAILABLE);\n    assert_eq!(err.body.title, \"Service is not active\");\n    let block = testkit.create_block();\n    assert!(block.is_empty());\n"]], "pred": {"ppl": 3.253922939300537, "ppl_lower": 4.4198527336120605, "ppl/lowercase_ppl": -1.2595602074104848, "ppl/zlib": 0.0027311604784232726, "Min_5.0% Prob": 8.012424111366272, "Min_10.0% Prob": 6.458109111785888, "Min_20.0% Prob": 4.671865280936746, "Min_30.0% Prob": 3.569047273773896, "Min_40.0% Prob": 2.8256990751799416, "Min_50.0% Prob": 2.3191722207702696, "Min_60.0% Prob": 1.9648368648356862}}
{"hexsha": "33af33f042063cb938a7e5f8f2845e3f68908304", "ext": "rs", "lang": "Rust", "content": "fn run_benchmarks< F: FnOnce( &mut Bencher ) >( callback: F ) {\n    if !*IS_NODEJS {\n        let body = document().query_selector( \"body\" ).unwrap().unwrap();\n        let start = document().create_element( \"button\" ).unwrap();\n        start.set_text_content( \"Start\" );\n        body.append_child( &start );\n        let pre = document().create_element( \"pre\" ).unwrap();\n        pre.set_attribute( \"id\", \"console\" ).unwrap();\n        body.append_child( &pre );\n    }\n\n    if cfg!( nightly ) {\n        js! {\n            console.log( \"Compiled with the `nightly` feature!\" );\n        }\n    }\n\n    let mut bencher = Bencher::new();\n    callback( &mut bencher );\n\n    if !*IS_NODEJS {\n        let body = document().query_selector( \"body\" ).unwrap().unwrap();\n        body.add_event_listener( move |_: ClickEvent| {\n            bencher.run();\n        });\n    } else {\n        bencher.run();\n    }\n}", "item_id": 0, "repo": "notriddle/stdweb", "file": "benchmarks/src/main.rs", "last_update_at": "2022-03-31T18:14:19+00:00", "question_id": "33af33f042063cb938a7e5f8f2845e3f68908304_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn run_benchmarks< F: FnOnce( &mut Bencher ) >( callback: F ) {\n    if !*IS_NODEJS {\n        let body = document().query_selector( \"body\" ).unwrap().unwrap();\n        let start = document().create_element( \"button\" ).unwrap();\n        start.set_text_content( \"Start\" );\n        body.append_child( &start );\n        let pre = document().create_element( \"pre\" ).unwrap();\n        pre.set_attribute( \"id\", \"console\" ).unwrap();\n        body.append_child( &pre );\n    }\n    if cfg!( nightly ) {\n        js! {\n            console.log( \"Compiled with the `nightly` feature!\" );\n        }\n    }\n    let mut bencher = Bencher::new();\n    callback( &mut bencher );\n    if !*IS_NODEJS {\n        let body = document().query_selector( \"body\" ).unwrap().unwrap();\n        body.add_event_listener( move |_: ClickEvent| {\n            bencher.run();\n        });\n    } else {\n        bencher.run();\n    }\n"]], "pred": {"ppl": 2.1528561115264893, "ppl_lower": 2.6263792514801025, "ppl/lowercase_ppl": -1.2592749078426158, "ppl/zlib": 0.0020339400120183396, "Min_5.0% Prob": 6.866972378322056, "Min_10.0% Prob": 5.071589665753501, "Min_20.0% Prob": 3.394131200654166, "Min_30.0% Prob": 2.47565028497151, "Min_40.0% Prob": 1.8950767509177722, "Min_50.0% Prob": 1.5324200762184799, "Min_60.0% Prob": 1.2822185189920594}}
{"hexsha": "14d51673a1e7dae1cbaac81bfd544f62dd8e1c53", "ext": "rs", "lang": "Rust", "content": "fn dec_by_inclusive_type_dependent_overflow() {\n  let mut r11 = (255u8..=248u8).dec_by::<50>();\n  assert_eq!(r11.next(), Some(255));\n  assert_eq!(r11.next(), None);\n  let mut r12 = (255u32..=248u32).dec_by::<{ usize::MAX }>();\n  assert_eq!(r12.next(), Some(255));\n  assert_eq!(r12.next(), None);\n  let mut r13 = (255i32..=248i32).dec_by::<{ u32::MAX as usize }>();\n  assert_eq!(r13.next(), Some(255));\n  assert_eq!(r13.next(), None);\n  let mut r14 = (i16::MAX..=i16::MAX).dec_by::<1>();\n  assert_eq!(r14.next(), Some(32767));\n  assert_eq!(r14.next(), None);\n}", "item_id": 30, "repo": "slightlyoutofphase/staticstep", "file": "tests/test_staticstep.rs", "last_update_at": "2022-01-30T19:12:35+00:00", "question_id": "14d51673a1e7dae1cbaac81bfd544f62dd8e1c53_30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn dec_by_inclusive_type_dependent_overflow() {\n  let mut r11 = (255u8..=248u8).dec_by::<50>();\n  assert_eq!(r11.next(), Some(255));\n  assert_eq!(r11.next(), None);\n  let mut r12 = (255u32..=248u32).dec_by::<{ usize::MAX }>();\n  assert_eq!(r12.next(), Some(255));\n  assert_eq!(r12.next(), None);\n  let mut r13 = (255i32..=248i32).dec_by::<{ u32::MAX as usize }>();\n  assert_eq!(r13.next(), Some(255));\n  assert_eq!(r13.next(), None);\n  let mut r14 = (i16::MAX..=i16::MAX).dec_by::<1>();\n  assert_eq!(r14.next(), Some(32767));\n  assert_eq!(r14.next(), None);\n"]], "pred": {"ppl": 2.1514406204223633, "ppl_lower": 2.3031013011932373, "ppl/lowercase_ppl": -1.0889121303709652, "ppl/zlib": 0.003482443971648516, "Min_5.0% Prob": 7.827166727610996, "Min_10.0% Prob": 5.766099955354418, "Min_20.0% Prob": 3.6120745156492506, "Min_30.0% Prob": 2.528365932404995, "Min_40.0% Prob": 1.9075272632515536, "Min_50.0% Prob": 1.5343828792716805, "Min_60.0% Prob": 1.2818803795249636}}
{"hexsha": "74e251808f8357c43b87e9238e44b8960592c1d4", "ext": "rs", "lang": "Rust", "content": "fn test_from_string() {\n    assert_eq!(\"0\", FeelNumber::from_string(\"0\").to_string());\n    assert_eq!(\"-0\", FeelNumber::from_string(\"-0\").to_string());\n    assert_eq!(\"1\", FeelNumber::from_string(\"1\").to_string());\n    assert_eq!(\"-1\", FeelNumber::from_string(\"-1\").to_string());\n    assert_eq!(\"1.23456789\", FeelNumber::from_string(\"1.23456789\").to_string());\n    assert_eq!(\"-1.23456789\", FeelNumber::from_string(\"-1.23456789\").to_string());\n  }", "item_id": 9, "repo": "dmntk/dmntk.rs", "file": "feel-number/src/number.rs", "last_update_at": "2022-03-31T13:13:29+00:00", "question_id": "74e251808f8357c43b87e9238e44b8960592c1d4_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_from_string() {\n    assert_eq!(\"0\", FeelNumber::from_string(\"0\").to_string());\n    assert_eq!(\"-0\", FeelNumber::from_string(\"-0\").to_string());\n    assert_eq!(\"1\", FeelNumber::from_string(\"1\").to_string());\n    assert_eq!(\"-1\", FeelNumber::from_string(\"-1\").to_string());\n    assert_eq!(\"1.23456789\", FeelNumber::from_string(\"1.23456789\").to_string());\n    assert_eq!(\"-1.23456789\", FeelNumber::from_string(\"-1.23456789\").to_string());\n"]], "pred": {"ppl": 1.4636106491088867, "ppl_lower": 1.6008700132369995, "ppl/lowercase_ppl": -1.2353355116769351, "ppl/zlib": 0.003200894370637771, "Min_5.0% Prob": 5.211607297261556, "Min_10.0% Prob": 3.421978215376536, "Min_20.0% Prob": 1.8726236357076749, "Min_30.0% Prob": 1.276745692403479, "Min_40.0% Prob": 0.9515096288476441, "Min_50.0% Prob": 0.7657148040294566, "Min_60.0% Prob": 0.634774025716307}}
{"hexsha": "4f3d9f22f5d4f4f98d5b2b0083560fc60382ddd2", "ext": "rs", "lang": "Rust", "content": "fn test_maximal_independent_set_wikipedia() {\n    let g = graph_wikipedia();\n    assert_eq!(vec![0, 2, 5], maximal_independent_set(&g, &vec![0, 1, 2, 3, 4, 5]));\n    assert_eq!(vec![1, 3], maximal_independent_set(&g, &vec![1, 0, 2, 3, 4, 5]));\n    assert_eq!(vec![0, 2, 5], maximal_independent_set(&g, &vec![2, 0, 1, 3, 4, 5]));\n    assert_eq!(vec![0, 3], maximal_independent_set(&g, &vec![3, 0, 1, 2, 4, 5]));\n    assert_eq!(vec![2, 4, 5], maximal_independent_set(&g, &vec![4, 0, 1, 2, 3, 5]));\n    assert_eq!(vec![0, 2, 5], maximal_independent_set(&g, &vec![5, 0, 1, 2, 3, 4]));\n}", "item_id": 0, "repo": "peferron/algo", "file": "independent_set/rust/independent_set_test.rs", "last_update_at": "2022-03-23T18:06:46+00:00", "question_id": "4f3d9f22f5d4f4f98d5b2b0083560fc60382ddd2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_maximal_independent_set_wikipedia() {\n    let g = graph_wikipedia();\n    assert_eq!(vec![0, 2, 5], maximal_independent_set(&g, &vec![0, 1, 2, 3, 4, 5]));\n    assert_eq!(vec![1, 3], maximal_independent_set(&g, &vec![1, 0, 2, 3, 4, 5]));\n    assert_eq!(vec![0, 2, 5], maximal_independent_set(&g, &vec![2, 0, 1, 3, 4, 5]));\n    assert_eq!(vec![0, 3], maximal_independent_set(&g, &vec![3, 0, 1, 2, 4, 5]));\n    assert_eq!(vec![2, 4, 5], maximal_independent_set(&g, &vec![4, 0, 1, 2, 3, 5]));\n    assert_eq!(vec![0, 2, 5], maximal_independent_set(&g, &vec![5, 0, 1, 2, 3, 4]));\n"]], "pred": {"ppl": 1.5194926261901855, "ppl_lower": 1.5194926261901855, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.002520340244433476, "Min_5.0% Prob": 4.876554369926453, "Min_10.0% Prob": 3.260271302584944, "Min_20.0% Prob": 1.9858411752571494, "Min_30.0% Prob": 1.3876942238685759, "Min_40.0% Prob": 1.0435121694532365, "Min_50.0% Prob": 0.8389891348684169, "Min_60.0% Prob": 0.6971075752116003}}
{"hexsha": "82296e5ab9043c8c71ccf066decbd60f54d4e606", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn lower(cp: u32) -> bool {\n    // Derived Property: Lowercase\n    //  Generated from: Ll + Other_Lowercase\n    let cp = CodePoint::new(cp).unwrap();\n\n    cp.gc() == Gc::Ll || cp.olower()\n}", "item_id": 2, "repo": "hardboiled65/seshat-unicode", "file": "src/unicode/ucd/derived_props.rs", "last_update_at": "2022-03-05T17:23:19+00:00", "question_id": "82296e5ab9043c8c71ccf066decbd60f54d4e606_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn lower(cp: u32) -> bool {\n    // Derived Property: Lowercase\n    //  Generated from: Ll + Other_Lowercase\n    let cp = CodePoint::new(cp).unwrap();\n    cp.gc() == Gc::Ll || cp.olower()\n"]], "pred": {"ppl": 7.877780437469482, "ppl_lower": 14.199856758117676, "ppl/lowercase_ppl": -1.285451791264264, "ppl/zlib": 0.01298142260264997, "Min_5.0% Prob": 10.702462832132975, "Min_10.0% Prob": 9.34933601106916, "Min_20.0% Prob": 7.119889926910401, "Min_30.0% Prob": 5.803422407670454, "Min_40.0% Prob": 4.796933281421661, "Min_50.0% Prob": 3.9855087485752607, "Min_60.0% Prob": 3.426748883724213}}
{"hexsha": "ccf5cfcfbb628b2aace6b7ce9bba1d5b1502d0ce", "ext": "rs", "lang": "Rust", "content": "pub fn combination_save(\n    storage: &mut dyn Storage,\n    lottery_id: u64,\n    address: CanonicalAddr,\n    combination: Vec<String>,\n) -> StdResult<()> {\n    let mut exist = true;\n    // Save combination by senders\n    PREFIXED_USER_COMBINATION.update(\n        storage,\n        (&lottery_id.to_be_bytes(), address.as_slice()),\n        |exists| -> StdResult<Vec<String>> {\n            match exists {\n                Some(combinations) => {\n                    let mut modified = combinations;\n                    modified.extend(combination.clone());\n                    Ok(modified)\n                }\n                None => {\n                    exist = false;\n                    Ok(combination.clone())\n                }\n            }\n        },\n    )?;\n    if !exist {\n        ALL_USER_COMBINATION.update(\n            storage,\n            &lottery_id.to_be_bytes(),\n            |exist| -> StdResult<Vec<CanonicalAddr>> {\n                match exist {\n                    None => Ok(vec![address]),\n                    Some(players) => {\n                        let mut data = players;\n                        data.push(address);\n                        Ok(data)\n                    }\n                }\n            },\n        )?;\n        COUNT_PLAYERS\n            .update(\n                storage,\n                &lottery_id.to_be_bytes(),\n                |exists| -> StdResult<Uint128> {\n                    match exists {\n                        None => Ok(Uint128(1)),\n                        Some(p) => Ok(p.add(Uint128(1))),\n                    }\n                },\n            )\n            .map(|_| ())?\n    }\n    COUNT_TICKETS\n        .update(\n            storage,\n            &lottery_id.to_be_bytes(),\n            |exists| -> StdResult<Uint128> {\n                match exists {\n                    None => Ok(Uint128(combination.len() as u128)),\n                    Some(p) => Ok(p.add(Uint128(combination.len() as u128))),\n                }\n            },\n        )\n        .map(|_| ())\n}", "item_id": 0, "repo": "0xantman/LoTerra", "file": "src/state.rs", "last_update_at": "2022-01-18T05:00:45+00:00", "question_id": "ccf5cfcfbb628b2aace6b7ce9bba1d5b1502d0ce_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn combination_save(\n    storage: &mut dyn Storage,\n    lottery_id: u64,\n    address: CanonicalAddr,\n    combination: Vec<String>,\n) -> StdResult<()> {\n    let mut exist = true;\n    // Save combination by senders\n    PREFIXED_USER_COMBINATION.update(\n        storage,\n        (&lottery_id.to_be_bytes(), address.as_slice()),\n        |exists| -> StdResult<Vec<String>> {\n            match exists {\n                Some(combinations) => {\n                    let mut modified = combinations;\n                    modified.extend(combination.clone());\n                    Ok(modified)\n                }\n                None => {\n                    exist = false;\n                    Ok(combination.clone())\n                }\n            }\n        },\n    )?;\n    if !exist {\n        ALL_USER_COMBINATION.update(\n            storage,\n            &lottery_id.to_be_bytes(),\n            |exist| -> StdResult<Vec<CanonicalAddr>> {\n                match exist {\n                    None => Ok(vec![address]),\n                    Some(players) => {\n                        let mut data = players;\n                        data.push(address);\n                        Ok(data)\n                    }\n                }\n            },\n        )?;\n        COUNT_PLAYERS\n            .update(\n                storage,\n                &lottery_id.to_be_bytes(),\n                |exists| -> StdResult<Uint128> {\n                    match exists {\n                        None => Ok(Uint128(1)),\n                        Some(p) => Ok(p.add(Uint128(1))),\n                    }\n                },\n            )\n            .map(|_| ())?\n    }\n    COUNT_TICKETS\n        .update(\n            storage,\n            &lottery_id.to_be_bytes(),\n            |exists| -> StdResult<Uint128> {\n                match exists {\n                    None => Ok(Uint128(combination.len() as u128)),\n                    Some(p) => Ok(p.add(Uint128(combination.len() as u128))),\n                }\n            },\n        )\n        .map(|_| ())\n"]], "pred": {"ppl": 1.6424099206924438, "ppl_lower": 1.9551235437393188, "ppl/lowercase_ppl": -1.3512720347112404, "ppl/zlib": 0.0008584163098053593, "Min_5.0% Prob": 6.299548206658199, "Min_10.0% Prob": 4.2311952114105225, "Min_20.0% Prob": 2.400248071114565, "Min_30.0% Prob": 1.642115460066446, "Min_40.0% Prob": 1.2380004874069308, "Min_50.0% Prob": 0.9916719706303536, "Min_60.0% Prob": 0.8267329087529075}}
{"hexsha": "638731c51c5f41e412237e6d63ffc746ec7369a1", "ext": "rs", "lang": "Rust", "content": "pub fn wlroots_dehandle(_args: TokenStream, input: TokenStream) -> TokenStream {\n    let input = parse_macro_input!(input as ItemFn);\n    let output = Args.fold_item_fn(input);\n    TokenStream::from(quote!(#output))\n}", "item_id": 0, "repo": "SethBarberee/wlroots-rs", "file": "wlroots-dehandle/src/lib.rs", "last_update_at": "2022-01-13T23:46:42+00:00", "question_id": "638731c51c5f41e412237e6d63ffc746ec7369a1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn wlroots_dehandle(_args: TokenStream, input: TokenStream) -> TokenStream {\n    let input = parse_macro_input!(input as ItemFn);\n    let output = Args.fold_item_fn(input);\n    TokenStream::from(quote!(#output))\n"]], "pred": {"ppl": 5.233347415924072, "ppl_lower": 7.189044952392578, "ppl/lowercase_ppl": -1.1918413367988032, "ppl/zlib": 0.011107725601499582, "Min_5.0% Prob": 10.769817352294922, "Min_10.0% Prob": 9.427673612322126, "Min_20.0% Prob": 7.326082876750401, "Min_30.0% Prob": 5.274332824207487, "Min_40.0% Prob": 4.061509788036346, "Min_50.0% Prob": 3.2915555953979494, "Min_60.0% Prob": 2.755942448441471}}
{"hexsha": "4a7c0b0d3d3bd17552f59a07db83ad636a06bd3e", "ext": "rs", "lang": "Rust", "content": "fn basics_with_schema_projection() -> Result<()> {\n    let (data, schema, columns) = case_basics_schema();\n\n    let mut reader = ReaderBuilder::new()\n        .with_schema(Arc::new(schema.clone()))\n        .build(Cursor::new(data))?;\n    let batch = reader.next()?.unwrap();\n\n    assert_eq!(&schema, batch.schema().as_ref());\n\n    columns\n        .iter()\n        .zip(batch.columns())\n        .for_each(|(expected, result)| assert_eq!(expected.as_ref(), result.as_ref()));\n    Ok(())\n}", "item_id": 1, "repo": "ives9638/arrow2", "file": "tests/it/io/json/read.rs", "last_update_at": "2022-02-20T00:10:06+00:00", "question_id": "4a7c0b0d3d3bd17552f59a07db83ad636a06bd3e_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn basics_with_schema_projection() -> Result<()> {\n    let (data, schema, columns) = case_basics_schema();\n    let mut reader = ReaderBuilder::new()\n        .with_schema(Arc::new(schema.clone()))\n        .build(Cursor::new(data))?;\n    let batch = reader.next()?.unwrap();\n    assert_eq!(&schema, batch.schema().as_ref());\n    columns\n        .iter()\n        .zip(batch.columns())\n        .for_each(|(expected, result)| assert_eq!(expected.as_ref(), result.as_ref()));\n    Ok(())\n"]], "pred": {"ppl": 2.511197090148926, "ppl_lower": 3.347902297973633, "ppl/lowercase_ppl": -1.3123230127143481, "ppl/zlib": 0.003500986949793545, "Min_5.0% Prob": 7.469974994659424, "Min_10.0% Prob": 5.595146611332893, "Min_20.0% Prob": 3.811848148703575, "Min_30.0% Prob": 2.860364401092132, "Min_40.0% Prob": 2.2516894910950214, "Min_50.0% Prob": 1.833777492493391, "Min_60.0% Prob": 1.5330121544441984}}
{"hexsha": "ec997430e31b86f8a9c22418c5c30c6b4fd32db1", "ext": "rs", "lang": "Rust", "content": "pub fn set_sampling_mode<'a>(\n    mut ctx: partial!(Context<'a>, mut ProofP<'a>, mut SolverStateP, mut VariablesP),\n    global: Var,\n    mode: SamplingMode,\n) -> Option<Var> {\n    let variables = ctx.part_mut(VariablesP);\n\n    let var_data = &mut variables.var_data[global.index()];\n\n    assert!(!var_data.deleted);\n\n    if var_data.assumed {\n        panic!(\"cannot change sampling mode of assumption variable\")\n    }\n\n    let previous_mode = var_data.sampling_mode;\n\n    if previous_mode == mode {\n        return None;\n    }\n\n    var_data.sampling_mode = mode;\n\n    let mut result = None;\n\n    if mode != SamplingMode::Hide {\n        proof::add_step(\n            ctx.borrow(),\n            false,\n            &ProofStep::ChangeSamplingMode {\n                var: global,\n                sample: mode == SamplingMode::Sample,\n            },\n        );\n    }\n    let variables = ctx.part_mut(VariablesP);\n\n    if previous_mode == SamplingMode::Hide {\n        let user = variables.next_unmapped_user();\n        variables.user_from_global_mut().insert(user, global);\n        variables.user_freelist.remove(&user);\n\n        proof::add_step(\n            ctx.borrow(),\n            false,\n            &ProofStep::UserVarName {\n                global,\n                user: Some(user),\n            },\n        );\n\n        result = Some(user);\n    } else if mode == SamplingMode::Hide {\n        if let Some(user) = variables.user_from_global_mut().remove(global) {\n            variables.user_freelist.insert(user);\n        }\n\n        proof::add_step(\n            ctx.borrow(),\n            false,\n            &ProofStep::UserVarName { global, user: None },\n        );\n\n        delete_global_if_unused(ctx.borrow(), global);\n    }\n\n    result\n}", "item_id": 3, "repo": "cjsauer/varisat", "file": "varisat/src/variables.rs", "last_update_at": "2022-03-31T18:32:05+00:00", "question_id": "ec997430e31b86f8a9c22418c5c30c6b4fd32db1_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn set_sampling_mode<'a>(\n    mut ctx: partial!(Context<'a>, mut ProofP<'a>, mut SolverStateP, mut VariablesP),\n    global: Var,\n    mode: SamplingMode,\n) -> Option<Var> {\n    let variables = ctx.part_mut(VariablesP);\n    let var_data = &mut variables.var_data[global.index()];\n    assert!(!var_data.deleted);\n    if var_data.assumed {\n        panic!(\"cannot change sampling mode of assumption variable\")\n    }\n    let previous_mode = var_data.sampling_mode;\n    if previous_mode == mode {\n        return None;\n    }\n    var_data.sampling_mode = mode;\n    let mut result = None;\n    if mode != SamplingMode::Hide {\n        proof::add_step(\n            ctx.borrow(),\n            false,\n            &ProofStep::ChangeSamplingMode {\n                var: global,\n                sample: mode == SamplingMode::Sample,\n            },\n        );\n    }\n    let variables = ctx.part_mut(VariablesP);\n    if previous_mode == SamplingMode::Hide {\n        let user = variables.next_unmapped_user();\n        variables.user_from_global_mut().insert(user, global);\n        variables.user_freelist.remove(&user);\n        proof::add_step(\n            ctx.borrow(),\n            false,\n            &ProofStep::UserVarName {\n                global,\n                user: Some(user),\n            },\n        );\n        result = Some(user);\n    } else if mode == SamplingMode::Hide {\n        if let Some(user) = variables.user_from_global_mut().remove(global) {\n            variables.user_freelist.insert(user);\n        }\n        proof::add_step(\n            ctx.borrow(),\n            false,\n            &ProofStep::UserVarName { global, user: None },\n        );\n        delete_global_if_unused(ctx.borrow(), global);\n    }\n    result\n"]], "pred": {"ppl": 2.641242504119873, "ppl_lower": 2.9332759380340576, "ppl/lowercase_ppl": -1.107974747266632, "ppl/zlib": 0.0017374766582098776, "Min_5.0% Prob": 7.798138343370878, "Min_10.0% Prob": 6.160142504251921, "Min_20.0% Prob": 4.191931631702643, "Min_30.0% Prob": 3.0885096666140432, "Min_40.0% Prob": 2.3984236892026205, "Min_50.0% Prob": 1.9340146682956667, "Min_60.0% Prob": 1.6183234687549428}}
{"hexsha": "54c30d3a87d97116fad54f93ec46b12a13be9dde", "ext": "rs", "lang": "Rust", "content": "async fn integration_test_is_ready_ok_no_such_bucket() {\n        // test that is_ready returns Ok even if the bucket doesn't exist\n        let mut client = init_client().await;\n        client\n            .delete_bucket(&S3BucketsSettings::default().global_models)\n            .await\n            .unwrap();\n\n        let res = client.is_ready().await;\n        assert!(res.is_ok())\n    }", "item_id": 5, "repo": "Robert-Steiner/xaynet", "file": "rust/xaynet-server/src/storage/model_storage/s3.rs", "last_update_at": "2022-02-10T02:59:04+00:00", "question_id": "54c30d3a87d97116fad54f93ec46b12a13be9dde_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn integration_test_is_ready_ok_no_such_bucket() {\n        // test that is_ready returns Ok even if the bucket doesn't exist\n        let mut client = init_client().await;\n        client\n            .delete_bucket(&S3BucketsSettings::default().global_models)\n            .await\n            .unwrap();\n        let res = client.is_ready().await;\n        assert!(res.is_ok())\n"]], "pred": {"ppl": 5.14841365814209, "ppl_lower": 6.185040473937988, "ppl/lowercase_ppl": -1.1119461657250205, "ppl/zlib": 0.0073483795501353855, "Min_5.0% Prob": 10.160046195983886, "Min_10.0% Prob": 8.46062421798706, "Min_20.0% Prob": 6.271620171410697, "Min_30.0% Prob": 4.8609578758478165, "Min_40.0% Prob": 3.895050941511642, "Min_50.0% Prob": 3.2043493450791747, "Min_60.0% Prob": 2.7446418879553676}}
{"hexsha": "42999a743bbd29d266cf2f0faadc5ca8c4cb64c3", "ext": "rs", "lang": "Rust", "content": "async fn csv_query_array_agg() -> Result<()> {\n    let ctx = SessionContext::new();\n    register_aggregate_csv(&ctx).await?;\n    let sql =\n        \"SELECT array_agg(c13) FROM (SELECT * FROM aggregate_test_100 ORDER BY c13 LIMIT 2) test\";\n    let actual = execute_to_batches(&ctx, sql).await;\n    let expected = vec![\n        \"+------------------------------------------------------------------+\",\n        \"| ARRAYAGG(test.c13)                                               |\",\n        \"+------------------------------------------------------------------+\",\n        \"| [0VVIHzxWtNOFLtnhjHEKjXaJOSLJfm, 0keZ5G8BffGwgF2RwQD59TFzMStxCB] |\",\n        \"+------------------------------------------------------------------+\",\n    ];\n    assert_batches_eq!(expected, &actual);\n    Ok(())\n}", "item_id": 31, "repo": "capkurmagati/arrow-datafusion", "file": "datafusion/core/tests/sql/aggregates.rs", "last_update_at": "2022-03-29T13:34:55+00:00", "question_id": "42999a743bbd29d266cf2f0faadc5ca8c4cb64c3_31", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn csv_query_array_agg() -> Result<()> {\n    let ctx = SessionContext::new();\n    register_aggregate_csv(&ctx).await?;\n    let sql =\n        \"SELECT array_agg(c13) FROM (SELECT * FROM aggregate_test_100 ORDER BY c13 LIMIT 2) test\";\n    let actual = execute_to_batches(&ctx, sql).await;\n    let expected = vec![\n        \"+------------------------------------------------------------------+\",\n        \"| ARRAYAGG(test.c13)                                               |\",\n        \"+------------------------------------------------------------------+\",\n        \"| [0VVIHzxWtNOFLtnhjHEKjXaJOSLJfm, 0keZ5G8BffGwgF2RwQD59TFzMStxCB] |\",\n        \"+------------------------------------------------------------------+\",\n    ];\n    assert_batches_eq!(expected, &actual);\n    Ok(())\n"]], "pred": {"ppl": 4.471372127532959, "ppl_lower": 5.884480953216553, "ppl/lowercase_ppl": -1.1833638716543926, "ppl/zlib": 0.004254816264703636, "Min_5.0% Prob": 9.035612279718572, "Min_10.0% Prob": 7.545832447383715, "Min_20.0% Prob": 5.849101533060488, "Min_30.0% Prob": 4.754208124202231, "Min_40.0% Prob": 3.705047648440125, "Min_50.0% Prob": 3.001754378899932, "Min_60.0% Prob": 2.5093596243842256}}
{"hexsha": "bcf073018c381b64faf9337df7e306a087c8a090", "ext": "rs", "lang": "Rust", "content": "fn insert_8_char_string(b: &mut Bencher) {\n    let mut strings: Vec<_> = Vec::new();\n    for i in 1..1001 {\n        strings.push(format!(\"{:x}\", -i));\n    }\n\n    let mut m = new_map();\n    b.iter(|| {\n        for key in &strings {\n            m.insert(key, key);\n        }\n    })\n}", "item_id": 7, "repo": "zhangpf/fuchsia-rs", "file": "third_party/rust_crates/vendor/hashbrown/benches/bench.rs", "last_update_at": "2022-02-14T19:18:24+00:00", "question_id": "bcf073018c381b64faf9337df7e306a087c8a090_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn insert_8_char_string(b: &mut Bencher) {\n    let mut strings: Vec<_> = Vec::new();\n    for i in 1..1001 {\n        strings.push(format!(\"{:x}\", -i));\n    }\n    let mut m = new_map();\n    b.iter(|| {\n        for key in &strings {\n            m.insert(key, key);\n        }\n    })\n"]], "pred": {"ppl": 2.89908504486084, "ppl_lower": 4.445736408233643, "ppl/lowercase_ppl": -1.4016838358509183, "ppl/zlib": 0.005880636383641708, "Min_5.0% Prob": 8.033927822113037, "Min_10.0% Prob": 6.6834770202636715, "Min_20.0% Prob": 4.4075977177847, "Min_30.0% Prob": 3.2669041883200407, "Min_40.0% Prob": 2.5970319850104198, "Min_50.0% Prob": 2.1170798607592314, "Min_60.0% Prob": 1.772221585502848}}
{"hexsha": "7bbe64ec6f80d16efee4802c6f5d0ca610eb8674", "ext": "rs", "lang": "Rust", "content": "fn helmholtz_energy() {\n        let disp = Dispersion {\n            parameters: propane_parameters(),\n        };\n        let t = 250.0;\n        let v = 1000.0;\n        let n = 1.0;\n        let s = StateHD::new(t, v, arr1(&[n]));\n        let a_rust = disp.helmholtz_energy(&s);\n        assert_relative_eq!(a_rust, -1.0622531100351962, epsilon = 1e-10);\n    }", "item_id": 0, "repo": "bbbursik/feos-pcsaft", "file": "src/eos/dispersion.rs", "last_update_at": "2022-03-02T16:39:08+00:00", "question_id": "7bbe64ec6f80d16efee4802c6f5d0ca610eb8674_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn helmholtz_energy() {\n        let disp = Dispersion {\n            parameters: propane_parameters(),\n        };\n        let t = 250.0;\n        let v = 1000.0;\n        let n = 1.0;\n        let s = StateHD::new(t, v, arr1(&[n]));\n        let a_rust = disp.helmholtz_energy(&s);\n        assert_relative_eq!(a_rust, -1.0622531100351962, epsilon = 1e-10);\n"]], "pred": {"ppl": 4.359602451324463, "ppl_lower": 4.9242634773254395, "ppl/lowercase_ppl": -1.0827189796232437, "ppl/zlib": 0.007112951073984678, "Min_5.0% Prob": 10.700131688799177, "Min_10.0% Prob": 7.929721440587725, "Min_20.0% Prob": 5.186958855596082, "Min_30.0% Prob": 4.145504157651555, "Min_40.0% Prob": 3.402330644049887, "Min_50.0% Prob": 2.837418308531916, "Min_60.0% Prob": 2.4330583578822287}}
{"hexsha": "7f4da6f279dddfd14822d3ff27b2543722279870", "ext": "rs", "lang": "Rust", "content": "async fn test_create_lookup_table() {\n    let mut context = setup_test_context().await;\n\n    let test_recent_slot = 123;\n    overwrite_slot_hashes_with_slots(&mut context, &[test_recent_slot]);\n\n    let client = &mut context.banks_client;\n    let payer = &context.payer;\n    let recent_blockhash = context.last_blockhash;\n    let authority_keypair = Keypair::new();\n    let authority_address = authority_keypair.pubkey();\n    let (create_lookup_table_ix, lookup_table_address) =\n        create_lookup_table(authority_address, payer.pubkey(), test_recent_slot);\n\n    // First create should succeed\n    {\n        let transaction = Transaction::new_signed_with_payer(\n            &[create_lookup_table_ix.clone()],\n            Some(&payer.pubkey()),\n            &[payer, &authority_keypair],\n            recent_blockhash,\n        );\n\n        assert_matches!(client.process_transaction(transaction).await, Ok(()));\n        let lookup_table_account = client\n            .get_account(lookup_table_address)\n            .await\n            .unwrap()\n            .unwrap();\n        assert_eq!(lookup_table_account.owner, crate::id());\n        assert_eq!(lookup_table_account.data.len(), LOOKUP_TABLE_META_SIZE);\n        assert_eq!(\n            lookup_table_account.lamports,\n            Rent::default().minimum_balance(LOOKUP_TABLE_META_SIZE)\n        );\n        let lookup_table = AddressLookupTable::deserialize(&lookup_table_account.data).unwrap();\n        assert_eq!(lookup_table.meta.derivation_slot, test_recent_slot);\n        assert_eq!(lookup_table.meta.authority, Some(authority_address));\n        assert_eq!(lookup_table.meta.last_extended_slot, 0);\n        assert_eq!(lookup_table.meta.last_extended_slot_start_index, 0);\n        assert_eq!(lookup_table.addresses.len(), 0);\n    }\n\n    // Second create should fail\n    {\n        context.last_blockhash = client\n            .get_new_latest_blockhash(&recent_blockhash)\n            .await\n            .unwrap();\n        assert_ix_error(\n            &mut context,\n            create_lookup_table_ix,\n            Some(&authority_keypair),\n            InstructionError::AccountAlreadyInitialized,\n        )\n        .await;\n    }\n}", "item_id": 0, "repo": "alexbosy/solana", "file": "programs/address-lookup-table-tests/tests/create_lookup_table_ix.rs", "last_update_at": "2022-03-31T19:25:12+00:00", "question_id": "7f4da6f279dddfd14822d3ff27b2543722279870_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn test_create_lookup_table() {\n    let mut context = setup_test_context().await;\n    let test_recent_slot = 123;\n    overwrite_slot_hashes_with_slots(&mut context, &[test_recent_slot]);\n    let client = &mut context.banks_client;\n    let payer = &context.payer;\n    let recent_blockhash = context.last_blockhash;\n    let authority_keypair = Keypair::new();\n    let authority_address = authority_keypair.pubkey();\n    let (create_lookup_table_ix, lookup_table_address) =\n        create_lookup_table(authority_address, payer.pubkey(), test_recent_slot);\n    // First create should succeed\n    {\n        let transaction = Transaction::new_signed_with_payer(\n            &[create_lookup_table_ix.clone()],\n            Some(&payer.pubkey()),\n            &[payer, &authority_keypair],\n            recent_blockhash,\n        );\n        assert_matches!(client.process_transaction(transaction).await, Ok(()));\n        let lookup_table_account = client\n            .get_account(lookup_table_address)\n            .await\n            .unwrap()\n            .unwrap();\n        assert_eq!(lookup_table_account.owner, crate::id());\n        assert_eq!(lookup_table_account.data.len(), LOOKUP_TABLE_META_SIZE);\n        assert_eq!(\n            lookup_table_account.lamports,\n            Rent::default().minimum_balance(LOOKUP_TABLE_META_SIZE)\n        );\n        let lookup_table = AddressLookupTable::deserialize(&lookup_table_account.data).unwrap();\n        assert_eq!(lookup_table.meta.derivation_slot, test_recent_slot);\n        assert_eq!(lookup_table.meta.authority, Some(authority_address));\n        assert_eq!(lookup_table.meta.last_extended_slot, 0);\n        assert_eq!(lookup_table.meta.last_extended_slot_start_index, 0);\n        assert_eq!(lookup_table.addresses.len(), 0);\n    }\n    // Second create should fail\n    {\n        context.last_blockhash = client\n            .get_new_latest_blockhash(&recent_blockhash)\n            .await\n            .unwrap();\n        assert_ix_error(\n            &mut context,\n            create_lookup_table_ix,\n            Some(&authority_keypair),\n            InstructionError::AccountAlreadyInitialized,\n        )\n        .await;\n    }\n"]], "pred": {"ppl": 1.7492674589157104, "ppl_lower": 2.172703981399536, "ppl/lowercase_ppl": -1.387654654749727, "ppl/zlib": 0.0007977134171109991, "Min_5.0% Prob": 6.069936383854259, "Min_10.0% Prob": 4.2022360761960345, "Min_20.0% Prob": 2.574406773524177, "Min_30.0% Prob": 1.81946491278708, "Min_40.0% Prob": 1.3930280044870942, "Min_50.0% Prob": 1.1185353722440097, "Min_60.0% Prob": 0.9321529514738358}}
{"hexsha": "35328c4632ef130aef9ae4b25454f12a1bb664ff", "ext": "rs", "lang": "Rust", "content": "async fn main() -> Result<()> {\n    tracing_subscriber::fmt().with_env_filter(\"debug\").init();\n\n    let opts = Opts::parse();\n\n    let id = Keypair::generate_ed25519();\n\n    let endpoint_addr = Endpoint::new(TokioTcpConfig::new(), id, Duration::from_secs(20), [])\n        .create(None)\n        .spawn_global();\n\n    let dialer_constructor = {\n        let connect_addr = opts.multiaddr.clone();\n        let endpoint_addr = endpoint_addr.clone();\n        move || dialer::Actor::new(endpoint_addr.clone(), connect_addr.clone())\n    };\n\n    let (supervisor, _dialer_actor) = supervisor::Actor::with_policy(\n        dialer_constructor,\n        |_: &dialer::Error| true, // always restart dialer actor\n    );\n    let _dialer_supervisor = supervisor.create(None).spawn_global();\n\n    sleep(Duration::from_secs(1)).await;\n\n    let stream = endpoint_addr\n        .send(OpenSubstream::single_protocol(\n            PeerId::try_from_multiaddr(&opts.multiaddr).unwrap(),\n            \"/hello-world/1.0.0\",\n        ))\n        .await\n        .unwrap()\n        .unwrap();\n\n    let message = hello_world_dialer(stream, opts.name).await.unwrap();\n\n    tracing::info!(\"{message}\");\n\n    Ok(())\n}", "item_id": 0, "repo": "itchysats/itchysats", "file": "xtra-libp2p/examples/hello_world_dialer.rs", "last_update_at": "2022-03-14T01:20:28+00:00", "question_id": "35328c4632ef130aef9ae4b25454f12a1bb664ff_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn main() -> Result<()> {\n    tracing_subscriber::fmt().with_env_filter(\"debug\").init();\n    let opts = Opts::parse();\n    let id = Keypair::generate_ed25519();\n    let endpoint_addr = Endpoint::new(TokioTcpConfig::new(), id, Duration::from_secs(20), [])\n        .create(None)\n        .spawn_global();\n    let dialer_constructor = {\n        let connect_addr = opts.multiaddr.clone();\n        let endpoint_addr = endpoint_addr.clone();\n        move || dialer::Actor::new(endpoint_addr.clone(), connect_addr.clone())\n    };\n    let (supervisor, _dialer_actor) = supervisor::Actor::with_policy(\n        dialer_constructor,\n        |_: &dialer::Error| true, // always restart dialer actor\n    );\n    let _dialer_supervisor = supervisor.create(None).spawn_global();\n    sleep(Duration::from_secs(1)).await;\n    let stream = endpoint_addr\n        .send(OpenSubstream::single_protocol(\n            PeerId::try_from_multiaddr(&opts.multiaddr).unwrap(),\n            \"/hello-world/1.0.0\",\n        ))\n        .await\n        .unwrap()\n        .unwrap();\n    let message = hello_world_dialer(stream, opts.name).await.unwrap();\n    tracing::info!(\"{message}\");\n    Ok(())\n"]], "pred": {"ppl": 3.0899534225463867, "ppl_lower": 3.8267343044281006, "ppl/lowercase_ppl": -1.1895622210012922, "ppl/zlib": 0.00208917780960456, "Min_5.0% Prob": 7.643509789517052, "Min_10.0% Prob": 6.3521935022794285, "Min_20.0% Prob": 4.45841446900979, "Min_30.0% Prob": 3.4061713208500137, "Min_40.0% Prob": 2.7190972461532326, "Min_50.0% Prob": 2.2289945188241127, "Min_60.0% Prob": 1.8764937040197034}}
{"hexsha": "40a4099c379c46d3ff5f65c2b90445fe38fe5822", "ext": "rs", "lang": "Rust", "content": "fn subr(&mut self) -> Result<Ipv4Addr, Self::Error> {\n        let mut subr = Ipv4Addr::UNSPECIFIED;\n        self.read(reg::SUBR, COMMON_BLOCK_OFFSET, &mut subr.octets)?;\n        Ok(subr)\n    }", "item_id": 3, "repo": "newAM/w5500-ll-rs", "file": "src/lib.rs", "last_update_at": "2022-03-05T05:06:30+00:00", "question_id": "40a4099c379c46d3ff5f65c2b90445fe38fe5822_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn subr(&mut self) -> Result<Ipv4Addr, Self::Error> {\n        let mut subr = Ipv4Addr::UNSPECIFIED;\n        self.read(reg::SUBR, COMMON_BLOCK_OFFSET, &mut subr.octets)?;\n        Ok(subr)\n"]], "pred": {"ppl": 4.238372802734375, "ppl_lower": 9.246341705322266, "ppl/lowercase_ppl": -1.5401327197337558, "ppl/zlib": 0.009377788458728439, "Min_5.0% Prob": 10.041916728019714, "Min_10.0% Prob": 7.925117075443268, "Min_20.0% Prob": 5.625478982925415, "Min_30.0% Prob": 4.354847297072411, "Min_40.0% Prob": 3.474988028858647, "Min_50.0% Prob": 2.8836005337354615, "Min_60.0% Prob": 2.4379565041436226}}
{"hexsha": "c7b6c06a91c2d640e2a5eafd6be8cec2a3cef26e", "ext": "rs", "lang": "Rust", "content": "fn test_get_text() {\n        let width = 3;\n        let key_config = KeyConfig::default();\n        let mut component = HelpComponent::new(key_config.clone());\n        component.set_cmds(vec![\n            CommandInfo::new(crate::components::command::scroll(&key_config)),\n            CommandInfo::new(crate::components::command::filter(&key_config)),\n        ]);\n        assert_eq!(\n            component.get_text(width),\n            vec![\n                Spans::from(Span::styled(\n                    \"-- General --\",\n                    Style::default().add_modifier(Modifier::REVERSED)\n                )),\n                Spans::from(Span::styled(\n                    \" Scroll up/down/left/right [k,j,h,l]  3\",\n                    Style::default().bg(Color::Rgb(0xea, 0x59, 0x0b))\n                )),\n                Spans::from(Span::styled(\" Filter [/]  3\", Style::default()))\n            ]\n        );\n    }", "item_id": 0, "repo": "andyslucky/gobang", "file": "src/components/help.rs", "last_update_at": "2022-02-07T22:46:16+00:00", "question_id": "c7b6c06a91c2d640e2a5eafd6be8cec2a3cef26e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_get_text() {\n        let width = 3;\n        let key_config = KeyConfig::default();\n        let mut component = HelpComponent::new(key_config.clone());\n        component.set_cmds(vec![\n            CommandInfo::new(crate::components::command::scroll(&key_config)),\n            CommandInfo::new(crate::components::command::filter(&key_config)),\n        ]);\n        assert_eq!(\n            component.get_text(width),\n            vec![\n                Spans::from(Span::styled(\n                    \"-- General --\",\n                    Style::default().add_modifier(Modifier::REVERSED)\n                )),\n                Spans::from(Span::styled(\n                    \" Scroll up/down/left/right [k,j,h,l]  3\",\n                    Style::default().bg(Color::Rgb(0xea, 0x59, 0x0b))\n                )),\n                Spans::from(Span::styled(\" Filter [/]  3\", Style::default()))\n            ]\n        );\n"]], "pred": {"ppl": 2.6015939712524414, "ppl_lower": 3.4120020866394043, "ppl/lowercase_ppl": -1.2836188888896956, "ppl/zlib": 0.0026782193922847432, "Min_5.0% Prob": 7.938495232508733, "Min_10.0% Prob": 6.3572822534121, "Min_20.0% Prob": 4.200161187153943, "Min_30.0% Prob": 3.0710774943043915, "Min_40.0% Prob": 2.357884795879418, "Min_50.0% Prob": 1.9116680655120448, "Min_60.0% Prob": 1.5917728605076857}}
{"hexsha": "2c4ed5a22570842ff78d205527b9c2dad01eecf6", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let mut input_a = String::new();\n    let mut input_b = String::new();\n\n    if let Err(_e) = io::stdin().read_line(&mut input_a){}\n    if let Err(_e) = io::stdin().read_line(&mut input_b){}\n\n    let a: f64 = input_a.trim().parse().unwrap();\n    let b: f64 = input_b.trim().parse().unwrap();\n\n    println!(\"MEDIA = {:.5}\", (a * 3.5 + b * 7.5) / 11.0);\n}", "item_id": 0, "repo": "deniscostadsc/playground", "file": "solutions/beecrowd/1005/1005.rs", "last_update_at": "2022-01-08T22:36:47+00:00", "question_id": "2c4ed5a22570842ff78d205527b9c2dad01eecf6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let mut input_a = String::new();\n    let mut input_b = String::new();\n    if let Err(_e) = io::stdin().read_line(&mut input_a){}\n    if let Err(_e) = io::stdin().read_line(&mut input_b){}\n    let a: f64 = input_a.trim().parse().unwrap();\n    let b: f64 = input_b.trim().parse().unwrap();\n    println!(\"MEDIA = {:.5}\", (a * 3.5 + b * 7.5) / 11.0);\n"]], "pred": {"ppl": 1.4584757089614868, "ppl_lower": 1.8868340253829956, "ppl/lowercase_ppl": -1.6823370631830796, "ppl/zlib": 0.0019655825800949456, "Min_5.0% Prob": 4.850567987986973, "Min_10.0% Prob": 3.1958845297495526, "Min_20.0% Prob": 1.8580839370687803, "Min_30.0% Prob": 1.266082887020376, "Min_40.0% Prob": 0.9410769925376431, "Min_50.0% Prob": 0.7579933089865861, "Min_60.0% Prob": 0.6338976442808756}}
{"hexsha": "28c52a8cb860091ec0522e9d56f08e35df2004ec", "ext": "rs", "lang": "Rust", "content": "pub fn request(endpoint : &str) -> Result<bytes::Bytes, Error> {\n    \n    let resp = reqwest::blocking::get(format!(\"https://api.dhravya.me/{}\", endpoint)).unwrap();\n\n    let status : u16 = resp.status().as_u16();\n\n    if status == 200 {\n        let bytes : bytes::Bytes = resp.bytes().unwrap();\n        return Ok(bytes);\n    } else {\n        if status == 500 {\n            return Err(Error::HTTPException(\"Internal Server Error\".to_string()));\n        } else {\n            return Err(Error::HTTPException(\"Unknown Error\".to_string()));\n        }\n    }\n}", "item_id": 0, "repo": "kekda-py/Dhavya", "file": "src/lib.rs", "last_update_at": "2022-03-10T12:01:43+00:00", "question_id": "28c52a8cb860091ec0522e9d56f08e35df2004ec_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn request(endpoint : &str) -> Result<bytes::Bytes, Error> {\n    let resp = reqwest::blocking::get(format!(\"https://api.dhravya.me/{}\", endpoint)).unwrap();\n    let status : u16 = resp.status().as_u16();\n    if status == 200 {\n        let bytes : bytes::Bytes = resp.bytes().unwrap();\n        return Ok(bytes);\n    } else {\n        if status == 500 {\n            return Err(Error::HTTPException(\"Internal Server Error\".to_string()));\n        } else {\n            return Err(Error::HTTPException(\"Unknown Error\".to_string()));\n        }\n    }\n"]], "pred": {"ppl": 2.3952066898345947, "ppl_lower": 2.7636821269989014, "ppl/lowercase_ppl": -1.163822963886426, "ppl/zlib": 0.003001613497238631, "Min_5.0% Prob": 8.442247688770294, "Min_10.0% Prob": 6.2468350902199745, "Min_20.0% Prob": 3.8085477207646226, "Min_30.0% Prob": 2.767921403646469, "Min_40.0% Prob": 2.1352451743919456, "Min_50.0% Prob": 1.7297714503393287, "Min_60.0% Prob": 1.4610398940183222}}
{"hexsha": "8fd6b208ec84f00e8121ce9174d335326a9c9d90", "ext": "rs", "lang": "Rust", "content": "fn read_records<R>(reader: R) -> csv::Result<()>\nwhere\n    R: Read,\n{\n    let mut rdr = csv::Reader::from_reader(reader);\n    println!(\"Comparing planets in the solar system with the earth\");\n    println!(\"where a value of '1' means 'equal to earth'\");\n    for result in rdr.records() {\n        println!(\"-------\");\n        let record = result?;\n        if let Some(name) = record.get(0) {\n            println!(\"Name: {}\", name);\n        }\n        if let Some(radius) = record.get(1) {\n            println!(\"Radius: {}\", radius);\n        }\n        if let Some(distance) = record.get(2) {\n            println!(\"Distance from sun: {}\", distance);\n        }\n        if let Some(gravity) = record.get(3) {\n            println!(\"Surface gravity: {}\", gravity);\n        }\n    }\n    Ok(())\n}", "item_id": 2, "repo": "PacktPublishing/Rust-Standard-Library-Cookbook", "file": "Chapter04/src/bin/csv.rs", "last_update_at": "2022-03-29T02:31:56+00:00", "question_id": "8fd6b208ec84f00e8121ce9174d335326a9c9d90_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn read_records<R>(reader: R) -> csv::Result<()>\nwhere\n    R: Read,\n{\n    let mut rdr = csv::Reader::from_reader(reader);\n    println!(\"Comparing planets in the solar system with the earth\");\n    println!(\"where a value of '1' means 'equal to earth'\");\n    for result in rdr.records() {\n        println!(\"-------\");\n        let record = result?;\n        if let Some(name) = record.get(0) {\n            println!(\"Name: {}\", name);\n        }\n        if let Some(radius) = record.get(1) {\n            println!(\"Radius: {}\", radius);\n        }\n        if let Some(distance) = record.get(2) {\n            println!(\"Distance from sun: {}\", distance);\n        }\n        if let Some(gravity) = record.get(3) {\n            println!(\"Surface gravity: {}\", gravity);\n        }\n    }\n    Ok(())\n"]], "pred": {"ppl": 2.0781383514404297, "ppl_lower": 2.515806198120117, "ppl/lowercase_ppl": -1.2612823400016147, "ppl/zlib": 0.0022233205762757836, "Min_5.0% Prob": 7.259525299072266, "Min_10.0% Prob": 5.211176644200864, "Min_20.0% Prob": 3.379057836025319, "Min_30.0% Prob": 2.3788314533065744, "Min_40.0% Prob": 1.824930015951395, "Min_50.0% Prob": 1.4636278985289193, "Min_60.0% Prob": 1.2192415631586082}}
{"hexsha": "7e2cb0923ee66343bab7e18ac18838de40478cf7", "ext": "rs", "lang": "Rust", "content": "fn from_cursor_wrong() {\n        let a = &[0, 1, 78];\n        let mut wrong: Cursor<&[u8]> = Cursor::new(a);\n        let _ = StatusChangeType::from_cursor(&mut wrong).unwrap();\n    }", "item_id": 4, "repo": "devbasil/cdrs-tokio", "file": "cdrs-tokio/src/frame/events.rs", "last_update_at": "2022-03-30T17:06:01+00:00", "question_id": "7e2cb0923ee66343bab7e18ac18838de40478cf7_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn from_cursor_wrong() {\n        let a = &[0, 1, 78];\n        let mut wrong: Cursor<&[u8]> = Cursor::new(a);\n        let _ = StatusChangeType::from_cursor(&mut wrong).unwrap();\n"]], "pred": {"ppl": 4.552821159362793, "ppl_lower": 7.1517815589904785, "ppl/lowercase_ppl": -1.2979484018867782, "ppl/zlib": 0.01174997733213451, "Min_5.0% Prob": 9.459040323893229, "Min_10.0% Prob": 8.664677699406942, "Min_20.0% Prob": 6.402144468747652, "Min_30.0% Prob": 4.741199171543121, "Min_40.0% Prob": 3.7461176095185458, "Min_50.0% Prob": 3.034676851595149, "Min_60.0% Prob": 2.535655519220887}}
{"hexsha": "0112ea4a8241ff775de3a099a311c1a0995367f0", "ext": "rs", "lang": "Rust", "content": "pub fn test() -> Html {\n    let (label, set_label) = use_state(|| \"Hello\".to_owned());\n\n    let on_click = {\n        let label = Rc::clone(&label);\n        Callback::from(move |_| set_label(format!(\"{} world\", label)))\n    };\n\n    let default_string = use_trans(\"default\");\n\n    let switch_on_click = Callback::from(move |_| ());\n\n    let slider_on_change = Callback::from(move |_| ());\n\n    let on_select = Callback::from(move |_| ());\n\n    let text_field_on_focus_lost = Callback::from(move |_| ());\n\n    let up_down_on_step = Callback::from(move |_| ());\n\n    html! {\n        <div class=\"px-4 py-3\">\n            <div class=\"flex flex-col space-y-2 items-start\">\n                <Button on_click=on_click.clone() button_type=ButtonType::None>\n                    {label.clone()}\n                </Button>\n                <Button on_click=on_click.clone() button_type=ButtonType::Primary>\n                    {label.clone()}\n                </Button>\n                <Button on_click=on_click.clone() button_type=ButtonType::Secondary>\n                    {label.clone()}\n                </Button>\n                <Button on_click=on_click button_type=ButtonType::Danger>\n                    {label}\n                </Button>\n            </div>\n            <Switch on_click=switch_on_click checked=true/>\n            <Slider value=\"0\" default=\"30\" min=\"-1\" max=\"40\" step=\"0.5\" on_change=slider_on_change/>\n            <ButtonGroup\n                options=vec![\"hello1\".into(), \"hello2\".into()]\n                selected=\"hello1\"\n                on_select=on_select.clone()\n            />\n            <Select\n                options=vec![\"hello1\".into(), \"hello2\".into()]\n                selected=\"hello1\"\n                on_select=on_select\n            />\n            <div class=\"space-y-2\">\n                <TextField\n                    value=default_string.clone()\n                    on_focus_lost=text_field_on_focus_lost.clone()\n                />\n                <TextField\n                    label=\"Hi there\"\n                    value=default_string\n                    on_focus_lost=text_field_on_focus_lost.clone()\n                />\n            </div>\n            <div class=\"py-2 space-y-2\">\n                <UpDown\n                    label=\"Bitrate\"\n                    value=\"123\"\n                    on_focus_lost=text_field_on_focus_lost.clone()\n                    on_step_down=up_down_on_step.clone()\n                    on_step_up=up_down_on_step.clone()\n                />\n                <UpDown\n                    value=\"123\"\n                    on_focus_lost=text_field_on_focus_lost\n                    on_step_down=up_down_on_step.clone()\n                    on_step_up=up_down_on_step\n                />\n            </div>\n        </div>\n    }\n}", "item_id": 2, "repo": "Nexite/ALVR", "file": "alvr/dashboard/src/dashboard.rs", "last_update_at": "2022-01-10T05:12:29+00:00", "question_id": "0112ea4a8241ff775de3a099a311c1a0995367f0_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn test() -> Html {\n    let (label, set_label) = use_state(|| \"Hello\".to_owned());\n    let on_click = {\n        let label = Rc::clone(&label);\n        Callback::from(move |_| set_label(format!(\"{} world\", label)))\n    };\n    let default_string = use_trans(\"default\");\n    let switch_on_click = Callback::from(move |_| ());\n    let slider_on_change = Callback::from(move |_| ());\n    let on_select = Callback::from(move |_| ());\n    let text_field_on_focus_lost = Callback::from(move |_| ());\n    let up_down_on_step = Callback::from(move |_| ());\n    html! {\n        <div class=\"px-4 py-3\">\n            <div class=\"flex flex-col space-y-2 items-start\">\n                <Button on_click=on_click.clone() button_type=ButtonType::None>\n                    {label.clone()}\n                </Button>\n                <Button on_click=on_click.clone() button_type=ButtonType::Primary>\n                    {label.clone()}\n                </Button>\n                <Button on_click=on_click.clone() button_type=ButtonType::Secondary>\n                    {label.clone()}\n                </Button>\n                <Button on_click=on_click button_type=ButtonType::Danger>\n                    {label}\n                </Button>\n            </div>\n            <Switch on_click=switch_on_click checked=true/>\n            <Slider value=\"0\" default=\"30\" min=\"-1\" max=\"40\" step=\"0.5\" on_change=slider_on_change/>\n            <ButtonGroup\n                options=vec![\"hello1\".into(), \"hello2\".into()]\n                selected=\"hello1\"\n                on_select=on_select.clone()\n            />\n            <Select\n                options=vec![\"hello1\".into(), \"hello2\".into()]\n                selected=\"hello1\"\n                on_select=on_select\n            />\n            <div class=\"space-y-2\">\n                <TextField\n                    value=default_string.clone()\n                    on_focus_lost=text_field_on_focus_lost.clone()\n                />\n                <TextField\n                    label=\"Hi there\"\n                    value=default_string\n                    on_focus_lost=text_field_on_focus_lost.clone()\n                />\n            </div>\n            <div class=\"py-2 space-y-2\">\n                <UpDown\n                    label=\"Bitrate\"\n                    value=\"123\"\n                    on_focus_lost=text_field_on_focus_lost.clone()\n                    on_step_down=up_down_on_step.clone()\n                    on_step_up=up_down_on_step.clone()\n                />\n                <UpDown\n                    value=\"123\"\n                    on_focus_lost=text_field_on_focus_lost\n                    on_step_down=up_down_on_step.clone()\n                    on_step_up=up_down_on_step\n                />\n            </div>\n        </div>\n    }\n"]], "pred": {"ppl": 1.7691216468811035, "ppl_lower": 1.9159575700759888, "ppl/lowercase_ppl": -1.13976635685042, "ppl/zlib": 0.0008776664287933002, "Min_5.0% Prob": 6.085703110694885, "Min_10.0% Prob": 4.263372917234162, "Min_20.0% Prob": 2.648968781218117, "Min_30.0% Prob": 1.8698103330385538, "Min_40.0% Prob": 1.421847736026034, "Min_50.0% Prob": 1.1391734962048825, "Min_60.0% Prob": 0.9507732977674704}}
{"hexsha": "4693cf30bac359276617be3ce520aa50f3f6d85a", "ext": "rs", "lang": "Rust", "content": "fn exclusion_rule_must_have_different_families_for_conditions_and_exclusions() {\n        let blue = Item::from(\"shirts:blue\");\n        let red = Item::from(\"shirts:red\");\n\n        let jeans = Item::from(\"pants:jeans\");\n        let slacks = Item::from(\"pants:slacks\");\n\n        let shirts = Family::from(\"shirts\");\n        let pants = Family::from(\"pants\");\n\n        let error = build_catalog(CatalogAssembly {\n            families: btreemap! {\n                shirts.clone() => vec![red.clone(), blue.clone()],\n                pants.clone() => vec![jeans.clone(), slacks.clone()],\n            },\n            exclusions: vec![\n                CatalogExclusionRule { conditions: vec![jeans.clone()], exclusions: vec![slacks.clone()] },\n                CatalogExclusionRule { conditions: vec![slacks.clone()], exclusions: vec![jeans.clone()] },\n            ],\n            inclusions: vec![],\n        })\n            .expect_err(\"expected build to return Error\");\n\n        assert_eq!(\n            CatalogBuilderError::ExclusionFamilyConflict { family: pants, items: vec![jeans, slacks] },\n            error\n        );\n    }", "item_id": 10, "repo": "tchupp/ignition-app", "file": "packages/catalogs/crate/src/catalog_builder/mod.rs", "last_update_at": "2022-01-22T07:53:16+00:00", "question_id": "4693cf30bac359276617be3ce520aa50f3f6d85a_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn exclusion_rule_must_have_different_families_for_conditions_and_exclusions() {\n        let blue = Item::from(\"shirts:blue\");\n        let red = Item::from(\"shirts:red\");\n        let jeans = Item::from(\"pants:jeans\");\n        let slacks = Item::from(\"pants:slacks\");\n        let shirts = Family::from(\"shirts\");\n        let pants = Family::from(\"pants\");\n        let error = build_catalog(CatalogAssembly {\n            families: btreemap! {\n                shirts.clone() => vec![red.clone(), blue.clone()],\n                pants.clone() => vec![jeans.clone(), slacks.clone()],\n            },\n            exclusions: vec![\n                CatalogExclusionRule { conditions: vec![jeans.clone()], exclusions: vec![slacks.clone()] },\n                CatalogExclusionRule { conditions: vec![slacks.clone()], exclusions: vec![jeans.clone()] },\n            ],\n            inclusions: vec![],\n        })\n            .expect_err(\"expected build to return Error\");\n        assert_eq!(\n            CatalogBuilderError::ExclusionFamilyConflict { family: pants, items: vec![jeans, slacks] },\n            error\n        );\n"]], "pred": {"ppl": 2.354085922241211, "ppl_lower": 2.5806527137756348, "ppl/lowercase_ppl": -1.1073288311832277, "ppl/zlib": 0.0022065786306681295, "Min_5.0% Prob": 8.205032020807266, "Min_10.0% Prob": 6.153817776477698, "Min_20.0% Prob": 3.989555212584409, "Min_30.0% Prob": 2.786349912183453, "Min_40.0% Prob": 2.1226940578922178, "Min_50.0% Prob": 1.7082990122338135, "Min_60.0% Prob": 1.4259277657168268}}
{"hexsha": "5687c712cbdb9e849da153118e5b5a914d7a5178", "ext": "rs", "lang": "Rust", "content": "pub fn spl_token_transfer(params: TokenTransferParams<'_, '_>) -> Result<()> {\n    let TokenTransferParams {\n        source,\n        destination,\n        authority,\n        token_program,\n        amount,\n        authority_signer_seeds,\n    } = params;\n\n    let val = &[authority_signer_seeds];\n\n    let result = invoke_signed(\n        &spl_token::instruction::transfer(\n            token_program.key,\n            source.key,\n            destination.key,\n            authority.key,\n            &[],\n            amount,\n        )?,\n        &[source, destination, authority, token_program],\n        if authority_signer_seeds.len() == 0 {\n            &[]\n        } else {\n            val\n        },\n    );\n\n    result.map_err(|_| error!(ErrorCode::TokenTransferFailed))\n}", "item_id": 0, "repo": "raindrops-protocol/raindrops", "file": "rust/staking/src/utils.rs", "last_update_at": "2022-03-31T23:27:38+00:00", "question_id": "5687c712cbdb9e849da153118e5b5a914d7a5178_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn spl_token_transfer(params: TokenTransferParams<'_, '_>) -> Result<()> {\n    let TokenTransferParams {\n        source,\n        destination,\n        authority,\n        token_program,\n        amount,\n        authority_signer_seeds,\n    } = params;\n    let val = &[authority_signer_seeds];\n    let result = invoke_signed(\n        &spl_token::instruction::transfer(\n            token_program.key,\n            source.key,\n            destination.key,\n            authority.key,\n            &[],\n            amount,\n        )?,\n        &[source, destination, authority, token_program],\n        if authority_signer_seeds.len() == 0 {\n            &[]\n        } else {\n            val\n        },\n    );\n    result.map_err(|_| error!(ErrorCode::TokenTransferFailed))\n"]], "pred": {"ppl": 1.7648111581802368, "ppl_lower": 2.314701557159424, "ppl/lowercase_ppl": -1.4774933228969898, "ppl/zlib": 0.0018383291007401524, "Min_5.0% Prob": 6.788443023508245, "Min_10.0% Prob": 4.482212180441076, "Min_20.0% Prob": 2.6863100494850767, "Min_30.0% Prob": 1.8651013925220028, "Min_40.0% Prob": 1.4203507199629464, "Min_50.0% Prob": 1.132811482123158, "Min_60.0% Prob": 0.9471609759830723}}
{"hexsha": "f238826e4b4a7216f9dbdd3263e5275544b144b2", "ext": "rs", "lang": "Rust", "content": "async fn deduplicates_bsses_from_multiple_networks() {\n            let mut cache = RealBssCache::new();\n            let result = cache\n                .update(FakeScanResultIterator::new_single_step(vec![\n                    ScanResult {\n                        id: None,\n                        entries: Some(vec![WlanPolicyBss {\n                            bssid: Some([0, 1, 2, 3, 4, 5]),\n                            rssi: Some(-1),\n                            frequency: Some(2412),\n                            timestamp_nanos: Some(1),\n                            ..WlanPolicyBss::EMPTY\n                        }]),\n                        compatibility: None,\n                        ..ScanResult::EMPTY\n                    },\n                    ScanResult {\n                        id: None,\n                        entries: Some(vec![WlanPolicyBss {\n                            bssid: Some([0, 1, 2, 3, 4, 5]),\n                            rssi: Some(-2),\n                            frequency: Some(2432),\n                            timestamp_nanos: Some(2),\n                            ..WlanPolicyBss::EMPTY\n                        }]),\n                        compatibility: None,\n                        ..ScanResult::EMPTY\n                    },\n                ]))\n                .await;\n            assert_eq!(result, Ok(()));\n\n            let mut bsses = cache.iter();\n            assert_matches!(bsses.next(), Some((&[0, 1, 2, 3, 4, 5], _)));\n            assert_eq!(bsses.next(), None);\n        }", "item_id": 5, "repo": "wwjiang007/fuchsia-1", "file": "src/connectivity/location/emergency/src/bss_cache.rs", "last_update_at": "2022-03-28T07:59:06+00:00", "question_id": "f238826e4b4a7216f9dbdd3263e5275544b144b2_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn deduplicates_bsses_from_multiple_networks() {\n            let mut cache = RealBssCache::new();\n            let result = cache\n                .update(FakeScanResultIterator::new_single_step(vec![\n                    ScanResult {\n                        id: None,\n                        entries: Some(vec![WlanPolicyBss {\n                            bssid: Some([0, 1, 2, 3, 4, 5]),\n                            rssi: Some(-1),\n                            frequency: Some(2412),\n                            timestamp_nanos: Some(1),\n                            ..WlanPolicyBss::EMPTY\n                        }]),\n                        compatibility: None,\n                        ..ScanResult::EMPTY\n                    },\n                    ScanResult {\n                        id: None,\n                        entries: Some(vec![WlanPolicyBss {\n                            bssid: Some([0, 1, 2, 3, 4, 5]),\n                            rssi: Some(-2),\n                            frequency: Some(2432),\n                            timestamp_nanos: Some(2),\n                            ..WlanPolicyBss::EMPTY\n                        }]),\n                        compatibility: None,\n                        ..ScanResult::EMPTY\n                    },\n                ]))\n                .await;\n            assert_eq!(result, Ok(()));\n            let mut bsses = cache.iter();\n            assert_matches!(bsses.next(), Some((&[0, 1, 2, 3, 4, 5], _)));\n            assert_eq!(bsses.next(), None);\n"]], "pred": {"ppl": 1.9808471202850342, "ppl_lower": 2.367565870285034, "ppl/lowercase_ppl": -1.2609090862676628, "ppl/zlib": 0.0017260722013571522, "Min_5.0% Prob": 7.56496188515111, "Min_10.0% Prob": 5.345532417297363, "Min_20.0% Prob": 3.242444396018982, "Min_30.0% Prob": 2.2629765249600933, "Min_40.0% Prob": 1.7097440768126984, "Min_50.0% Prob": 1.3692666052386688, "Min_60.0% Prob": 1.1408813342643964}}
{"hexsha": "9ba37a921a2a4ece1f5deed1b92d20efe3b78a04", "ext": "rs", "lang": "Rust", "content": "fn values_del() {\n        let mut values = Values::new();\n        values.set_value(\"key\", Some(\"value\".to_string()));\n        values.add_value(\"key\", None);\n        values.del_value(\"key\");\n        assert_eq!(values.len(), 0);\n\n        let mut values2 = Values::new();\n        values2.set_value(\"key\", Some(\"value\".to_string()));\n        values2.add_value(\"key\", None);\n        values2.set_value(\"key2\", Some(\"value\".to_string()));\n        values2.add_value(\"key2\", None);\n\n        values2.del_value(\"key\");\n        assert_eq!(values2.len(), 1);\n    }", "item_id": 2, "repo": "n-k/minio-rs", "file": "src/minio/net.rs", "last_update_at": "2022-03-18T07:52:30+00:00", "question_id": "9ba37a921a2a4ece1f5deed1b92d20efe3b78a04_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn values_del() {\n        let mut values = Values::new();\n        values.set_value(\"key\", Some(\"value\".to_string()));\n        values.add_value(\"key\", None);\n        values.del_value(\"key\");\n        assert_eq!(values.len(), 0);\n        let mut values2 = Values::new();\n        values2.set_value(\"key\", Some(\"value\".to_string()));\n        values2.add_value(\"key\", None);\n        values2.set_value(\"key2\", Some(\"value\".to_string()));\n        values2.add_value(\"key2\", None);\n        values2.del_value(\"key\");\n        assert_eq!(values2.len(), 1);\n"]], "pred": {"ppl": 1.8101205825805664, "ppl_lower": 2.058171033859253, "ppl/lowercase_ppl": -1.216423478637166, "ppl/zlib": 0.003553254271071643, "Min_5.0% Prob": 6.554067313671112, "Min_10.0% Prob": 4.407565053771524, "Min_20.0% Prob": 2.7305365119661604, "Min_30.0% Prob": 1.9099784884250388, "Min_40.0% Prob": 1.4628246199916786, "Min_50.0% Prob": 1.1789377662824112, "Min_60.0% Prob": 0.99373543504977}}
{"hexsha": "d9f5a19e461c4da51c8d8a53a1ec9b27f300edb9", "ext": "rs", "lang": "Rust", "content": "fn suffix_comma() {\n        let (parts, surname_index, generation) = parse(\"Doe, John III\").unwrap();\n        assert_eq!(\"John\", parts[0].word);\n        assert_eq!(\"Doe\", parts[1].word);\n        assert_eq!(1, surname_index);\n        assert_eq!(Some(3), generation);\n    }", "item_id": 5, "repo": "juma121/human-name", "file": "src/parse.rs", "last_update_at": "2022-01-08T15:35:15+00:00", "question_id": "d9f5a19e461c4da51c8d8a53a1ec9b27f300edb9_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn suffix_comma() {\n        let (parts, surname_index, generation) = parse(\"Doe, John III\").unwrap();\n        assert_eq!(\"John\", parts[0].word);\n        assert_eq!(\"Doe\", parts[1].word);\n        assert_eq!(1, surname_index);\n        assert_eq!(Some(3), generation);\n"]], "pred": {"ppl": 3.838315725326538, "ppl_lower": 4.376123905181885, "ppl/lowercase_ppl": -1.0974917776565472, "ppl/zlib": 0.008791069654800766, "Min_5.0% Prob": 9.566824674606323, "Min_10.0% Prob": 7.532934010028839, "Min_20.0% Prob": 5.2316595386056335, "Min_30.0% Prob": 4.194326992034912, "Min_40.0% Prob": 3.313692847595495, "Min_50.0% Prob": 2.671781531600065, "Min_60.0% Prob": 2.261615213810229}}
{"hexsha": "0f3e077d1de342c44a9cdb4f271ed7f73f727538", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    assert_eq!(\n        <() as Foo<u32>>::Out::default().to_string(),\n        \"0\");\n    assert_eq!(\n        <() as Foo<u64>>::Out::default().to_string(),\n        \"false\");\n\n    assert_eq!(\n        <LocalDefault as Foo<u32>>::Out::default().to_string(),\n        \"0\");\n    assert_eq!(\n        <LocalOverride as Foo<u64>>::Out::default().to_string(),\n        \"false\");\n}", "item_id": 0, "repo": "Eric-Arellano/rust", "file": "src/test/ui/cross-crate/xcrate-associated-type-defaults.rs", "last_update_at": "2022-03-31T23:26:40+00:00", "question_id": "0f3e077d1de342c44a9cdb4f271ed7f73f727538_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    assert_eq!(\n        <() as Foo<u32>>::Out::default().to_string(),\n        \"0\");\n    assert_eq!(\n        <() as Foo<u64>>::Out::default().to_string(),\n        \"false\");\n    assert_eq!(\n        <LocalDefault as Foo<u32>>::Out::default().to_string(),\n        \"0\");\n    assert_eq!(\n        <LocalOverride as Foo<u64>>::Out::default().to_string(),\n        \"false\");\n"]], "pred": {"ppl": 2.333711862564087, "ppl_lower": 2.5829646587371826, "ppl/lowercase_ppl": -1.11974340836926, "ppl/zlib": 0.0066207818284612285, "Min_5.0% Prob": 9.244384924570719, "Min_10.0% Prob": 6.54956762607281, "Min_20.0% Prob": 4.068756924225734, "Min_30.0% Prob": 2.848776014569478, "Min_40.0% Prob": 2.117800490895532, "Min_50.0% Prob": 1.7052206601947546, "Min_60.0% Prob": 1.4259468639929649}}
{"hexsha": "4240c517c9a992c92f452da8f5ff4a533bb41164", "ext": "rs", "lang": "Rust", "content": "pub fn serialize_operation_crate_operation_get_group_configuration(\n    input: &crate::input::GetGroupConfigurationInput,\n) -> Result<aws_smithy_http::body::SdkBody, aws_smithy_http::operation::SerializationError> {\n    let mut out = String::new();\n    let mut object = aws_smithy_json::serialize::JsonObjectWriter::new(&mut out);\n    crate::json_ser::serialize_structure_crate_input_get_group_configuration_input(\n        &mut object,\n        input,\n    )?;\n    object.finish();\n    Ok(aws_smithy_http::body::SdkBody::from(out))\n}", "item_id": 3, "repo": "StevenBlack/aws-sdk-rust", "file": "sdk/resourcegroups/src/operation_ser.rs", "last_update_at": "2022-03-31T20:47:15+00:00", "question_id": "4240c517c9a992c92f452da8f5ff4a533bb41164_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn serialize_operation_crate_operation_get_group_configuration(\n    input: &crate::input::GetGroupConfigurationInput,\n) -> Result<aws_smithy_http::body::SdkBody, aws_smithy_http::operation::SerializationError> {\n    let mut out = String::new();\n    let mut object = aws_smithy_json::serialize::JsonObjectWriter::new(&mut out);\n    crate::json_ser::serialize_structure_crate_input_get_group_configuration_input(\n        &mut object,\n        input,\n    )?;\n    object.finish();\n    Ok(aws_smithy_http::body::SdkBody::from(out))\n"]], "pred": {"ppl": 3.2816884517669678, "ppl_lower": 4.852108001708984, "ppl/lowercase_ppl": -1.3290718519811204, "ppl/zlib": 0.004401326154913457, "Min_5.0% Prob": 9.087494492530823, "Min_10.0% Prob": 7.414449607624727, "Min_20.0% Prob": 5.192857777371126, "Min_30.0% Prob": 3.791774421345954, "Min_40.0% Prob": 2.927523425091868, "Min_50.0% Prob": 2.3783469054588053, "Min_60.0% Prob": 1.9938582521908492}}
{"hexsha": "48d8b037e6638eba17cd8992e9e253afcb6f5160", "ext": "rs", "lang": "Rust", "content": "fn num_squares(n: i32) -> i32 {\n    let mut dp = vec![0; n as usize];\n\n    let mut queue = VecDeque::from(vec![(0, 0)]);\n\n    while !queue.is_empty() {\n        let (val, step) = queue.pop_front().unwrap();\n\n        for i in 1..100 {\n            let target = val + i * i;\n\n            match target.cmp(&n) {\n                Ordering::Less => {\n                    if dp[target as usize] == 0 {\n                        dp[target as usize] = step + 1;\n                        queue.push_back((target, step + 1));\n                    }\n                },\n                Ordering::Equal => {\n                    return step + 1;\n                },\n                Ordering::Greater => {\n                    break;\n                },\n            }\n        }\n    }\n\n    -1\n}", "item_id": 0, "repo": "kristof-mattei/leet-code", "file": "src/problem_0279/mod.rs", "last_update_at": "2022-03-19T07:21:10+00:00", "question_id": "48d8b037e6638eba17cd8992e9e253afcb6f5160_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn num_squares(n: i32) -> i32 {\n    let mut dp = vec![0; n as usize];\n    let mut queue = VecDeque::from(vec![(0, 0)]);\n    while !queue.is_empty() {\n        let (val, step) = queue.pop_front().unwrap();\n        for i in 1..100 {\n            let target = val + i * i;\n            match target.cmp(&n) {\n                Ordering::Less => {\n                    if dp[target as usize] == 0 {\n                        dp[target as usize] = step + 1;\n                        queue.push_back((target, step + 1));\n                    }\n                },\n                Ordering::Equal => {\n                    return step + 1;\n                },\n                Ordering::Greater => {\n                    break;\n                },\n            }\n        }\n    }\n    -1\n"]], "pred": {"ppl": 1.5585050582885742, "ppl_lower": 1.8806614875793457, "ppl/lowercase_ppl": -1.4234506269397789, "ppl/zlib": 0.0013997699237648128, "Min_5.0% Prob": 5.529001799496737, "Min_10.0% Prob": 3.629269941993382, "Min_20.0% Prob": 2.0925292302953435, "Min_30.0% Prob": 1.4534524314000572, "Min_40.0% Prob": 1.1116185713797173, "Min_50.0% Prob": 0.8894263798749801, "Min_60.0% Prob": 0.7400547221719458}}
{"hexsha": "16cd6e2a6a15bffe3842c885e8f90ad2f1fe9a96", "ext": "rs", "lang": "Rust", "content": "fn abort(\n    env: &Env,\n    message: AsmScriptStringPtr,\n    filename: AsmScriptStringPtr,\n    line: i32,\n    col: i32,\n) {\n    let memory = env.memory.get_ref().expect(\"initialized memory\");\n    let message = message.read(memory).unwrap();\n    let filename = filename.read(memory).unwrap();\n    eprintln!(\"Error: {} at {}:{} col: {}\", message, filename, line, col);\n}", "item_id": 1, "repo": "k10pr0f/wasmer-as", "file": "tests/strings.rs", "last_update_at": "2022-03-05T09:05:20+00:00", "question_id": "16cd6e2a6a15bffe3842c885e8f90ad2f1fe9a96_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn abort(\n    env: &Env,\n    message: AsmScriptStringPtr,\n    filename: AsmScriptStringPtr,\n    line: i32,\n    col: i32,\n) {\n    let memory = env.memory.get_ref().expect(\"initialized memory\");\n    let message = message.read(memory).unwrap();\n    let filename = filename.read(memory).unwrap();\n    eprintln!(\"Error: {} at {}:{} col: {}\", message, filename, line, col);\n"]], "pred": {"ppl": 3.137479543685913, "ppl_lower": 4.07936429977417, "ppl/lowercase_ppl": -1.2295931786920766, "ppl/zlib": 0.005523767074859432, "Min_5.0% Prob": 8.222641468048096, "Min_10.0% Prob": 6.34934522708257, "Min_20.0% Prob": 4.584559728701909, "Min_30.0% Prob": 3.500497145785226, "Min_40.0% Prob": 2.7757847712685666, "Min_50.0% Prob": 2.2685746449977158, "Min_60.0% Prob": 1.900788347961174}}
{"hexsha": "d9efe0ed2e393b8300ba82eb3f7e3f77313eef6c", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout_UConverterFromUnicodeArgs () { assert_eq ! (:: std :: mem :: size_of :: < UConverterFromUnicodeArgs > () , 56usize , concat ! (\"Size of: \" , stringify ! (UConverterFromUnicodeArgs))) ; assert_eq ! (:: std :: mem :: align_of :: < UConverterFromUnicodeArgs > () , 8usize , concat ! (\"Alignment of \" , stringify ! (UConverterFromUnicodeArgs))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . size as * const _ as usize } , 0usize , concat ! (\"Offset of field: \" , stringify ! (UConverterFromUnicodeArgs) , \"::\" , stringify ! (size))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . flush as * const _ as usize } , 2usize , concat ! (\"Offset of field: \" , stringify ! (UConverterFromUnicodeArgs) , \"::\" , stringify ! (flush))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . converter as * const _ as usize } , 8usize , concat ! (\"Offset of field: \" , stringify ! (UConverterFromUnicodeArgs) , \"::\" , stringify ! (converter))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . source as * const _ as usize } , 16usize , concat ! (\"Offset of field: \" , stringify ! (UConverterFromUnicodeArgs) , \"::\" , stringify ! (source))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . sourceLimit as * const _ as usize } , 24usize , concat ! (\"Offset of field: \" , stringify ! (UConverterFromUnicodeArgs) , \"::\" , stringify ! (sourceLimit))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . target as * const _ as usize } , 32usize , concat ! (\"Offset of field: \" , stringify ! (UConverterFromUnicodeArgs) , \"::\" , stringify ! (target))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . targetLimit as * const _ as usize } , 40usize , concat ! (\"Offset of field: \" , stringify ! (UConverterFromUnicodeArgs) , \"::\" , stringify ! (targetLimit))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . offsets as * const _ as usize } , 48usize , concat ! (\"Offset of field: \" , stringify ! (UConverterFromUnicodeArgs) , \"::\" , stringify ! (offsets))) ; }", "item_id": 3, "repo": "allansrc/fuchsia", "file": "third_party/rust_crates/vendor/rust_icu_sys/bindgen/lib_67.rs", "last_update_at": "2022-01-21T20:14:17+00:00", "question_id": "d9efe0ed2e393b8300ba82eb3f7e3f77313eef6c_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bindgen_test_layout_UConverterFromUnicodeArgs () { assert_eq ! (:: std :: mem :: size_of :: < UConverterFromUnicodeArgs > () , 56usize , concat ! (\"Size of: \" , stringify ! (UConverterFromUnicodeArgs))) ; assert_eq ! (:: std :: mem :: align_of :: < UConverterFromUnicodeArgs > () , 8usize , concat ! (\"Alignment of \" , stringify ! (UConverterFromUnicodeArgs))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . size as * const _ as usize } , 0usize , concat ! (\"Offset of field: \" , stringify ! (UConverterFromUnicodeArgs) , \"::\" , stringify ! (size))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . flush as * const _ as usize } , 2usize , concat ! (\"Offset of field: \" , stringify ! (UConverterFromUnicodeArgs) , \"::\" , stringify ! (flush))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . converter as * const _ as usize } , 8usize , concat ! (\"Offset of field: \" , stringify ! (UConverterFromUnicodeArgs) , \"::\" , stringify ! (converter))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . source as * const _ as usize } , 16usize , concat ! (\"Offset of field: \" , stringify ! (UConverterFromUnicodeArgs) , \"::\" , stringify ! (source))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . sourceLimit as * const _ as usize } , 24usize , concat ! (\"Offset of field: \" , stringify ! (UConverterFromUnicodeArgs) , \"::\" , stringify ! (sourceLimit))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . target as * const _ as usize } , 32usize , concat ! (\"Offset of field: \" , stringify ! (UConverterFromUnicodeArgs) , \"::\" , stringify ! (target))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . targetLimit as * const _ as usize } , 40usize , concat ! (\"Offset of field: \" , stringify ! (UConverterFromUnicodeArgs) , \"::\" , stringify ! (targetLimit))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . offsets as * const _ as usize } , 48usize , concat ! (\"Offset of field: \" , stringify ! (UConverterFromUnicodeArgs) , \"::\" , stringify ! (offsets))) ; }\n"]], "pred": {"ppl": 1.2047884464263916, "ppl_lower": 1.257298231124878, "ppl/lowercase_ppl": -1.2289868816066236, "ppl/zlib": 0.0005577963724490494, "Min_5.0% Prob": 3.5283374335314774, "Min_10.0% Prob": 1.8614565104346823, "Min_20.0% Prob": 0.9311175184268129, "Min_30.0% Prob": 0.6223316937266075, "Min_40.0% Prob": 0.46573865205500137, "Min_50.0% Prob": 0.3731012075289278, "Min_60.0% Prob": 0.3105039782921139}}
{"hexsha": "34498ed0c9dd848a3ba9a31a646eb0ec5ab5028b", "ext": "rs", "lang": "Rust", "content": "fn return_popped_empty() {\n        const MAX_IN_FLY: usize = 3;\n        const COMMIT_MARK: u8 = 0;\n\n        let mut queue = TxQueueBuilder::new(MAX_IN_FLY).build();\n\n        queue\n            .return_popped(get_tx_data(\n                AggregatedActionType::CommitBlocks,\n                BlockNumber(1),\n                vec![COMMIT_MARK, 0],\n            ))\n            .unwrap();\n    }", "item_id": 1, "repo": "euevew/zksync", "file": "core/bin/zksync_eth_sender/src/tx_queue/mod.rs", "last_update_at": "2022-03-31T19:24:23+00:00", "question_id": "34498ed0c9dd848a3ba9a31a646eb0ec5ab5028b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn return_popped_empty() {\n        const MAX_IN_FLY: usize = 3;\n        const COMMIT_MARK: u8 = 0;\n        let mut queue = TxQueueBuilder::new(MAX_IN_FLY).build();\n        queue\n            .return_popped(get_tx_data(\n                AggregatedActionType::CommitBlocks,\n                BlockNumber(1),\n                vec![COMMIT_MARK, 0],\n            ))\n            .unwrap();\n"]], "pred": {"ppl": 5.013537406921387, "ppl_lower": 7.900081634521484, "ppl/lowercase_ppl": -1.2820666122485538, "ppl/zlib": 0.007197061317825626, "Min_5.0% Prob": 8.247405290603638, "Min_10.0% Prob": 7.36047883828481, "Min_20.0% Prob": 5.7412545871734615, "Min_30.0% Prob": 4.517769678642876, "Min_40.0% Prob": 3.6871277514626, "Min_50.0% Prob": 3.1042263293638825, "Min_60.0% Prob": 2.6612232161032687}}
{"hexsha": "f431383ef3c859d44cba61f9d2a0540d7ffd18f4", "ext": "rs", "lang": "Rust", "content": "pub fn serialize_structure_crate_model_license_specification(\n    object: &mut aws_smithy_json::serialize::JsonObjectWriter,\n    input: &crate::model::LicenseSpecification,\n) -> Result<(), aws_smithy_http::operation::SerializationError> {\n    if let Some(var_333) = &input.license_configuration_arn {\n        object.key(\"LicenseConfigurationArn\").string(var_333);\n    }\n    if let Some(var_334) = &input.ami_association_scope {\n        object.key(\"AmiAssociationScope\").string(var_334);\n    }\n    Ok(())\n}", "item_id": 48, "repo": "jdisanti/aws-sdk-rust", "file": "sdk/licensemanager/src/json_ser.rs", "last_update_at": "2022-03-31T20:47:15+00:00", "question_id": "f431383ef3c859d44cba61f9d2a0540d7ffd18f4_48", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn serialize_structure_crate_model_license_specification(\n    object: &mut aws_smithy_json::serialize::JsonObjectWriter,\n    input: &crate::model::LicenseSpecification,\n) -> Result<(), aws_smithy_http::operation::SerializationError> {\n    if let Some(var_333) = &input.license_configuration_arn {\n        object.key(\"LicenseConfigurationArn\").string(var_333);\n    }\n    if let Some(var_334) = &input.ami_association_scope {\n        object.key(\"AmiAssociationScope\").string(var_334);\n    }\n    Ok(())\n"]], "pred": {"ppl": 3.2760753631591797, "ppl_lower": 4.842635154724121, "ppl/lowercase_ppl": -1.3293423645844837, "ppl/zlib": 0.004283921192612148, "Min_5.0% Prob": 9.342544317245483, "Min_10.0% Prob": 7.6601706112132355, "Min_20.0% Prob": 5.361854655402047, "Min_30.0% Prob": 3.8755907548161654, "Min_40.0% Prob": 2.942670269523348, "Min_50.0% Prob": 2.3820620098675804, "Min_60.0% Prob": 1.976650876977614}}
{"hexsha": "318569367212c7ef19ef5847be4d26f72dbb01bf", "ext": "rs", "lang": "Rust", "content": "fn test_split() {\n        let token = \"#\".to_string();\n        let c: HoardCommand = command_struct(\"test # test\");\n        let expected = vec![\"test \".to_string(), \" test\".to_string()];\n        assert_eq!(expected, c.split(&token));\n    }", "item_id": 7, "repo": "qb60/hoard", "file": "src/command/hoard_command.rs", "last_update_at": "2022-03-28T07:09:24+00:00", "question_id": "318569367212c7ef19ef5847be4d26f72dbb01bf_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_split() {\n        let token = \"#\".to_string();\n        let c: HoardCommand = command_struct(\"test # test\");\n        let expected = vec![\"test \".to_string(), \" test\".to_string()];\n        assert_eq!(expected, c.split(&token));\n"]], "pred": {"ppl": 5.034880638122559, "ppl_lower": 6.0261640548706055, "ppl/lowercase_ppl": -1.1111865734493453, "ppl/zlib": 0.010921552834182762, "Min_5.0% Prob": 10.225497881571451, "Min_10.0% Prob": 7.959742477961949, "Min_20.0% Prob": 6.245459386280605, "Min_30.0% Prob": 5.00101523739951, "Min_40.0% Prob": 3.908903771433337, "Min_50.0% Prob": 3.2231628075242043, "Min_60.0% Prob": 2.7286878815570543}}
{"hexsha": "2be71527eb96a5f6fbf86f71d4934e65fcb7e381", "ext": "rs", "lang": "Rust", "content": "fn test_Aac_Ab() {\n    let A1 = array(vec![a(), c()]);\n    let A2 = array(vec![b()]);\n    let r = PredictionContext::merge(&A1, &A2, root_is_wildcard(), &mut None);\n    let expecting = String::new()\n        + \"digraph G {\\n\"\n        + \"rankdir=LR;\\n\"\n        + \"  s0[shape=record, label=\\\"<p0>|<p1>|<p2>\\\"];\\n\"\n        + \"  s1[label=\\\"*\\\"];\\n\"\n        + \"  s0:p0->s1[label=\\\"1\\\"];\\n\"\n        + \"  s0:p1->s1[label=\\\"2\\\"];\\n\"\n        + \"  s0:p2->s1[label=\\\"3\\\"];\\n\"\n        + \"}\\n\";\n    assert_eq!(expecting, to_dot_string(r, root_is_wildcard()))\n}", "item_id": 26, "repo": "kjplatz/antlr4rust", "file": "src/prediction_context/test.rs", "last_update_at": "2022-03-10T09:39:19+00:00", "question_id": "2be71527eb96a5f6fbf86f71d4934e65fcb7e381_26", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_Aac_Ab() {\n    let A1 = array(vec![a(), c()]);\n    let A2 = array(vec![b()]);\n    let r = PredictionContext::merge(&A1, &A2, root_is_wildcard(), &mut None);\n    let expecting = String::new()\n        + \"digraph G {\\n\"\n        + \"rankdir=LR;\\n\"\n        + \"  s0[shape=record, label=\\\"<p0>|<p1>|<p2>\\\"];\\n\"\n        + \"  s1[label=\\\"*\\\"];\\n\"\n        + \"  s0:p0->s1[label=\\\"1\\\"];\\n\"\n        + \"  s0:p1->s1[label=\\\"2\\\"];\\n\"\n        + \"  s0:p2->s1[label=\\\"3\\\"];\\n\"\n        + \"}\\n\";\n    assert_eq!(expecting, to_dot_string(r, root_is_wildcard()))\n"]], "pred": {"ppl": 2.529510736465454, "ppl_lower": 3.0259437561035156, "ppl/lowercase_ppl": -1.1930949655809016, "ppl/zlib": 0.0033262577033760393, "Min_5.0% Prob": 8.116142670313517, "Min_10.0% Prob": 6.2860967715581255, "Min_20.0% Prob": 4.096402598887074, "Min_30.0% Prob": 3.0141621219785244, "Min_40.0% Prob": 2.298514249677561, "Min_50.0% Prob": 1.8474193345603904, "Min_60.0% Prob": 1.550417543281199}}
{"hexsha": "a2d2f0976d20104c3aa34b53503e85381dd4aa5a", "ext": "rs", "lang": "Rust", "content": "fn linspace(min: f64, max: f64, n: usize) -> Vec<f64> {\n    if n == 1 {\n        return vec![min];\n    }\n\n    let d = max - min;\n    let l = n as f64 - 1.0;\n    (0..n).map(|i| min + (i as f64 * d) / l).collect()\n}", "item_id": 2, "repo": "EmbarkStudios/colorgrad-rs", "file": "src/lib.rs", "last_update_at": "2022-03-29T22:12:28+00:00", "question_id": "a2d2f0976d20104c3aa34b53503e85381dd4aa5a_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn linspace(min: f64, max: f64, n: usize) -> Vec<f64> {\n    if n == 1 {\n        return vec![min];\n    }\n    let d = max - min;\n    let l = n as f64 - 1.0;\n    (0..n).map(|i| min + (i as f64 * d) / l).collect()\n"]], "pred": {"ppl": 1.8124098777770996, "ppl_lower": 2.089996337890625, "ppl/lowercase_ppl": -1.2396420757937217, "ppl/zlib": 0.0037636543285110434, "Min_5.0% Prob": 6.850728225708008, "Min_10.0% Prob": 4.531771039962768, "Min_20.0% Prob": 2.740199461579323, "Min_30.0% Prob": 1.9463226233919462, "Min_40.0% Prob": 1.497034370340407, "Min_50.0% Prob": 1.184992417766183, "Min_60.0% Prob": 0.993109033397231}}
{"hexsha": "8e3c03372106afa1014015c54d342a22614f5c76", "ext": "rs", "lang": "Rust", "content": "fn special_whitespace() {\n    let strings = [\"\\n\", \"\\t\", \"foo\\tbar\", \"baz\\n\"];\n\n    for &s in &strings {\n        let input = format!(r#\"b\"{}\"\"#, s);\n        let input_raw = format!(r#\"br\"{}\"\"#, s);\n        for (input, num_hashes) in vec![(input, None), (input_raw, Some(0))] {\n            let expected = ByteStringLit {\n                raw: &*input,\n                value: None,\n                num_hashes,\n            };\n            assert_parse_ok_eq(\n                &input, ByteStringLit::parse(&*input), expected.clone(), \"ByteStringLit::parse\");\n            assert_parse_ok_eq(\n                &input, Literal::parse(&*input), Literal::ByteString(expected), \"Literal::parse\");\n            assert_eq!(ByteStringLit::parse(&*input).unwrap().value(), s.as_bytes());\n            assert_eq!(ByteStringLit::parse(&*input).unwrap().into_value(), s.as_bytes());\n        }\n    }\n\n    let res = ByteStringLit::parse(\"br\\\"\\r\\\"\").expect(\"failed to parse\");\n    assert_eq!(res.value(), b\"\\r\");\n}", "item_id": 1, "repo": "LukasKalbertodt/litrs", "file": "src/bytestr/tests.rs", "last_update_at": "2022-03-10T15:50:51+00:00", "question_id": "8e3c03372106afa1014015c54d342a22614f5c76_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn special_whitespace() {\n    let strings = [\"\\n\", \"\\t\", \"foo\\tbar\", \"baz\\n\"];\n    for &s in &strings {\n        let input = format!(r#\"b\"{}\"\"#, s);\n        let input_raw = format!(r#\"br\"{}\"\"#, s);\n        for (input, num_hashes) in vec![(input, None), (input_raw, Some(0))] {\n            let expected = ByteStringLit {\n                raw: &*input,\n                value: None,\n                num_hashes,\n            };\n            assert_parse_ok_eq(\n                &input, ByteStringLit::parse(&*input), expected.clone(), \"ByteStringLit::parse\");\n            assert_parse_ok_eq(\n                &input, Literal::parse(&*input), Literal::ByteString(expected), \"Literal::parse\");\n            assert_eq!(ByteStringLit::parse(&*input).unwrap().value(), s.as_bytes());\n            assert_eq!(ByteStringLit::parse(&*input).unwrap().into_value(), s.as_bytes());\n        }\n    }\n    let res = ByteStringLit::parse(\"br\\\"\\r\\\"\").expect(\"failed to parse\");\n    assert_eq!(res.value(), b\"\\r\");\n"]], "pred": {"ppl": 2.6533493995666504, "ppl_lower": 2.958160161972046, "ppl/lowercase_ppl": -1.1114390293569014, "ppl/zlib": 0.0026445061416881, "Min_5.0% Prob": 7.554746786753337, "Min_10.0% Prob": 5.751218488139491, "Min_20.0% Prob": 3.9262813764905173, "Min_30.0% Prob": 2.9616138006511488, "Min_40.0% Prob": 2.3524870896150194, "Min_50.0% Prob": 1.9222380296338963, "Min_60.0% Prob": 1.6176753667232238}}
{"hexsha": "800be99bdf5cb24a7bfccb5526fb18e550299c3c", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<(), u32> {\n    // - initialize allocator -------------------------------------------------\n\n    allocator::init();\n\n\n    // - configure board ------------------------------------------------------\n\n    let board = unsafe { bsp::Board::steal() };\n    let cp = cortex_m::Peripherals::take().unwrap();\n    let dp = pac::Peripherals::take().unwrap();\n    let ccdr = boards::freeze_clocks_with_config(\n        dp.PWR.constrain(), dp.RCC.constrain(), &dp.SYSCFG,\n        |pwrcfg, rcc, syscfg| {\n            rcc.sys_ck(96.mhz())                // system clock @ 96 MHz\n            // pll1 drives system clock\n                .pll1_strategy(hal::rcc::PllConfigStrategy::Iterative)\n                .pll1_r_ck(96.mhz())             // TRACECLK\n                .pll1_q_ck(48.mhz())             // spi clock\n                .pll3_p_ck((48_000 * 256).hz())  // sai clock @ 12.288 MHz\n                .freeze(pwrcfg, syscfg)\n        }\n    );\n\n    println!(\"Hello ockam_transport_ble!\");\n\n    let pins = board.split_gpios(dp.GPIOA.split(ccdr.peripheral.GPIOA),\n                                 dp.GPIOB.split(ccdr.peripheral.GPIOB),\n                                 dp.GPIOC.split(ccdr.peripheral.GPIOC),\n                                 dp.GPIOD.split(ccdr.peripheral.GPIOD),\n                                 dp.GPIOE.split(ccdr.peripheral.GPIOE),\n                                 dp.GPIOF.split(ccdr.peripheral.GPIOF),\n                                 dp.GPIOG.split(ccdr.peripheral.GPIOG));\n\n    let mut user_leds = bsp::led::UserLeds::new(pins.user_leds);\n\n\n    // - configure spi --------------------------------------------------------\n\n    let mut timer = dp.TIM7.timer(1.hz(), ccdr.peripheral.TIM7, &ccdr.clocks);\n    let mut delay = Delay::new(cp.SYST, ccdr.clocks);\n\n    let spi3_irq  = pins.d43.into_pull_down_input();\n    let spi3_rst  = pins.d44.into_push_pull_output();\n    let spi3_sck  = pins.d45.into_alternate_af6().set_speed(hal::gpio::Speed::VeryHigh);\n    let spi3_miso = pins.d46.into_alternate_af6().set_speed(hal::gpio::Speed::VeryHigh);\n    let spi3_mosi = pins.d47.into_alternate_af6().set_speed(hal::gpio::Speed::VeryHigh);\n\n    use nucleo_h7xx::embedded_hal::digital::v2::OutputPin;\n    let mut spi3_nss  = pins.d20.into_push_pull_output();\n    spi3_nss.set_high().ok();\n\n    let config = hal::spi::Config::new(\n        spi::Mode {\n            polarity: spi::Polarity::IdleLow,\n            phase: spi::Phase::CaptureOnFirstTransition,\n        }\n    );\n\n    let mut spi3 = dp.SPI3.spi(\n        (spi3_sck, spi3_miso, spi3_mosi),\n        config,\n        3.mhz(),\n        ccdr.peripheral.SPI3,\n        &ccdr.clocks,\n    );\n\n\n    // - bluenrg --------------------------------------------------------------\n\n    use ockam_transport_ble::driver::CHARACTERISTIC_VALUE_LENGTH;\n    let ble_addr = ockam_transport_ble::parse_ble_addr(\"ockam_ble_1\").unwrap();\n\n    let mut rx_buffer: [u8; CHARACTERISTIC_VALUE_LENGTH] = [0; CHARACTERISTIC_VALUE_LENGTH];\n    let mut bluetooth = bluenrg::BlueNRG::new(\n        &mut rx_buffer,\n        spi3_nss,\n        spi3_irq,\n        spi3_rst\n    );\n\n    // hardware reset\n    println!(\"\\n\\treset bluenrg-ms device\");\n    bluetooth.reset(&mut timer, 2.hz()).ok();\n    match bluetooth.with_spi(&mut spi3, |controller| block!(controller.read())) {\n        Ok(packet) => {\n            let bluetooth_hci::host::uart::Packet::Event(event) = packet;\n            ble_uart::dispatch_event(&event);\n        }\n        Err(e) => println!(\"reset error: {:?}\", e),\n    }\n\n    // test device comms\n    ble::read_local_version_information(&mut spi3, &mut bluetooth)\n        .expect(\"ble::read_local_version_information failed\");\n\n\n    // - configure ble uart ---------------------------------------------------\n\n    ble_uart::setup(&mut spi3, &mut bluetooth)\n        .expect(\"ble_uart::setup failed\");\n    delay.delay_ms(500u16);\n    let mut context = ble_uart::initialize_gatt_and_gap(&mut spi3, &mut bluetooth, &ble_addr)\n        .expect(\"ble_uart::initialize_gatt_and_gap failed\");\n    delay.delay_ms(500u16);\n    ble_uart::initialize_uart(&mut spi3, &mut bluetooth, &mut context)\n        .expect(\"ble_uart::initialize_uart failed\");\n    delay.delay_ms(500u16);\n\n\n    // - main loop ------------------------------------------------------------\n\n    let mut counter: usize = 0;\n\n    println!(\"\\nentering main loop\");\n\n    #[derive(Debug, PartialEq)]\n    enum State {\n        Disconnected,\n        Advertising,\n        Connected,\n        Error,\n    }\n\n    use ockam_transport_ble::driver::bluetooth_hci::Event;\n\n    //use bluetooth_hci::event::command::ReturnParameters::Vendor as Vendor;\n    //use bluetooth_hci::Vendor;\n\n    use bluenrg::event::BlueNRGEvent;\n\n    let mut state = State::Disconnected;\n    loop {\n        match state {\n            State::Disconnected => {\n                ble_uart::start_advertising(&mut spi3, &mut bluetooth, &mut context, &ble_addr)\n                    .expect(\"ble_uart::make_connection failed\");\n                state = State::Advertising;\n                println!(\"\\nstate = {:?}\", state);\n            }\n            State::Advertising => {\n            }\n            State::Connected => {\n            }\n            State::Error => {\n            }\n        }\n\n        ble_uart::poll(&mut spi3, &mut bluetooth, |event| {\n            match event {\n                Event::LeConnectionComplete(event) => {\n                    println!(\"\\t=> LeConnectionComplete -> {:?}\", event);\n                    state = State::Connected;\n                    println!(\"\\nstate = {:?}\", state);\n                }\n                Event::Vendor(BlueNRGEvent::GattAttributeModified(event)) => {\n                    if event.attr_handle == context.uart_rx_attribute_handle\n                        .expect(\"rx attribute handle is not set\")\n                    {\n                        if let Ok(data) = core::str::from_utf8(event.data()) {\n                            println!(\"\\t=> Rx: -> {:?}\", data);\n                        } else {\n                            println!(\"\\t=> Rx: -> {:?}\", event.data());\n                        }\n                    } else {\n                        println!(\"\\t=> Rx unknown: -> {:?}\", event);\n                    }\n                }\n                Event::DisconnectionComplete(event) => {\n                    println!(\"\\t=> DisconnectionComplete -> {:?}\", event);\n                    state = State::Disconnected;\n                    println!(\"\\nstate = {:?}\", state);\n                }\n                _ => {\n                    println!(\"\\t=> unknown event: {:?}\", event);\n                }\n            }\n            Some(State::Error)\n        });\n\n        if counter % 1000_000 == 0 && state == State::Connected {\n            //led.toggle().ok();\n\n            // create message buffer\n            let mut tx_buffer = [0 as u8; CHARACTERISTIC_VALUE_LENGTH];\n            let mut tx_cursor = Cursor::new(&mut tx_buffer[..]);\n            match write!(&mut tx_cursor, \"server counter: {}\", counter / 100_000) {\n            //match write!(&mut tx_cursor, \"0123456789012345678 server: {}\", counter / 100_000) {\n                Ok(()) => (),\n                Err(e) => {\n                    println!(\"failed write: {:?}\", e);\n                    continue\n                }\n            }\n            let position: usize = tx_cursor.position() as usize;\n            let tx_buffer = &tx_cursor.into_inner()[0..position];\n\n            // send message buffer\n            block!(bluetooth.with_spi(&mut spi3, |controller| {\n                controller.update_characteristic_value(&bluenrg::gatt::UpdateCharacteristicValueParameters {\n                    service_handle: context.uart_service_handle.expect(\"uart service handle has not been set\"),\n                    characteristic_handle: context.uart_tx_handle.expect(\"uart tx handle has not been set\"),\n                    offset: 0x00,\n                    value: tx_buffer,\n                })\n            })).unwrap();\n            ble_uart::controller_read(&mut spi3, &mut bluetooth);\n        }\n\n        if counter >= 0xffff_fffe {\n            break;\n        } else {\n            counter += 1;\n        }\n    }\n\n    Ok(())\n}", "item_id": 0, "repo": "antoinevg/hello_ockam_embedded", "file": "examples/hello_transport.rs", "last_update_at": "2022-01-11T07:22:39+00:00", "question_id": "800be99bdf5cb24a7bfccb5526fb18e550299c3c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() -> Result<(), u32> {\n    // - initialize allocator -------------------------------------------------\n    allocator::init();\n    // - configure board ------------------------------------------------------\n    let board = unsafe { bsp::Board::steal() };\n    let cp = cortex_m::Peripherals::take().unwrap();\n    let dp = pac::Peripherals::take().unwrap();\n    let ccdr = boards::freeze_clocks_with_config(\n        dp.PWR.constrain(), dp.RCC.constrain(), &dp.SYSCFG,\n        |pwrcfg, rcc, syscfg| {\n            rcc.sys_ck(96.mhz())                // system clock @ 96 MHz\n            // pll1 drives system clock\n                .pll1_strategy(hal::rcc::PllConfigStrategy::Iterative)\n                .pll1_r_ck(96.mhz())             // TRACECLK\n                .pll1_q_ck(48.mhz())             // spi clock\n                .pll3_p_ck((48_000 * 256).hz())  // sai clock @ 12.288 MHz\n                .freeze(pwrcfg, syscfg)\n        }\n    );\n    println!(\"Hello ockam_transport_ble!\");\n    let pins = board.split_gpios(dp.GPIOA.split(ccdr.peripheral.GPIOA),\n                                 dp.GPIOB.split(ccdr.peripheral.GPIOB),\n                                 dp.GPIOC.split(ccdr.peripheral.GPIOC),\n                                 dp.GPIOD.split(ccdr.peripheral.GPIOD),\n                                 dp.GPIOE.split(ccdr.peripheral.GPIOE),\n                                 dp.GPIOF.split(ccdr.peripheral.GPIOF),\n                                 dp.GPIOG.split(ccdr.peripheral.GPIOG));\n    let mut user_leds = bsp::led::UserLeds::new(pins.user_leds);\n    // - configure spi --------------------------------------------------------\n    let mut timer = dp.TIM7.timer(1.hz(), ccdr.peripheral.TIM7, &ccdr.clocks);\n    let mut delay = Delay::new(cp.SYST, ccdr.clocks);\n    let spi3_irq  = pins.d43.into_pull_down_input();\n    let spi3_rst  = pins.d44.into_push_pull_output();\n    let spi3_sck  = pins.d45.into_alternate_af6().set_speed(hal::gpio::Speed::VeryHigh);\n    let spi3_miso = pins.d46.into_alternate_af6().set_speed(hal::gpio::Speed::VeryHigh);\n    let spi3_mosi = pins.d47.into_alternate_af6().set_speed(hal::gpio::Speed::VeryHigh);\n    use nucleo_h7xx::embedded_hal::digital::v2::OutputPin;\n    let mut spi3_nss  = pins.d20.into_push_pull_output();\n    spi3_nss.set_high().ok();\n    let config = hal::spi::Config::new(\n        spi::Mode {\n            polarity: spi::Polarity::IdleLow,\n            phase: spi::Phase::CaptureOnFirstTransition,\n        }\n    );\n    let mut spi3 = dp.SPI3.spi(\n        (spi3_sck, spi3_miso, spi3_mosi),\n        config,\n        3.mhz(),\n        ccdr.peripheral.SPI3,\n        &ccdr.clocks,\n    );\n    // - bluenrg --------------------------------------------------------------\n    use ockam_transport_ble::driver::CHARACTERISTIC_VALUE_LENGTH;\n    let ble_addr = ockam_transport_ble::parse_ble_addr(\"ockam_ble_1\").unwrap();\n    let mut rx_buffer: [u8; CHARACTERISTIC_VALUE_LENGTH] = [0; CHARACTERISTIC_VALUE_LENGTH];\n    let mut bluetooth = bluenrg::BlueNRG::new(\n        &mut rx_buffer,\n        spi3_nss,\n        spi3_irq,\n        spi3_rst\n    );\n    // hardware reset\n    println!(\"\\n\\treset bluenrg-ms device\");\n    bluetooth.reset(&mut timer, 2.hz()).ok();\n    match bluetooth.with_spi(&mut spi3, |controller| block!(controller.read())) {\n        Ok(packet) => {\n            let bluetooth_hci::host::uart::Packet::Event(event) = packet;\n            ble_uart::dispatch_event(&event);\n        }\n        Err(e) => println!(\"reset error: {:?}\", e),\n    }\n    // test device comms\n    ble::read_local_version_information(&mut spi3, &mut bluetooth)\n        .expect(\"ble::read_local_version_information failed\");\n    // - configure ble uart ---------------------------------------------------\n    ble_uart::setup(&mut spi3, &mut bluetooth)\n        .expect(\"ble_uart::setup failed\");\n    delay.delay_ms(500u16);\n    let mut context = ble_uart::initialize_gatt_and_gap(&mut spi3, &mut bluetooth, &ble_addr)\n        .expect(\"ble_uart::initialize_gatt_and_gap failed\");\n    delay.delay_ms(500u16);\n    ble_uart::initialize_uart(&mut spi3, &mut bluetooth, &mut context)\n        .expect(\"ble_uart::initialize_uart failed\");\n    delay.delay_ms(500u16);\n    // - main loop ------------------------------------------------------------\n    let mut counter: usize = 0;\n    println!(\"\\nentering main loop\");\n    #[derive(Debug, PartialEq)]\n    enum State {\n        Disconnected,\n        Advertising,\n        Connected,\n        Error,\n    }\n    use ockam_transport_ble::driver::bluetooth_hci::Event;\n    //use bluetooth_hci::event::command::ReturnParameters::Vendor as Vendor;\n    //use bluetooth_hci::Vendor;\n    use bluenrg::event::BlueNRGEvent;\n    let mut state = State::Disconnected;\n    loop {\n        match state {\n            State::Disconnected => {\n                ble_uart::start_advertising(&mut spi3, &mut bluetooth, &mut context, &ble_addr)\n                    .expect(\"ble_uart::make_connection failed\");\n                state = State::Advertising;\n                println!(\"\\nstate = {:?}\", state);\n            }\n            State::Advertising => {\n            }\n            State::Connected => {\n            }\n            State::Error => {\n            }\n        }\n        ble_uart::poll(&mut spi3, &mut bluetooth, |event| {\n            match event {\n                Event::LeConnectionComplete(event) => {\n                    println!(\"\\t=> LeConnectionComplete -> {:?}\", event);\n                    state = State::Connected;\n                    println!(\"\\nstate = {:?}\", state);\n                }\n                Event::Vendor(BlueNRGEvent::GattAttributeModified(event)) => {\n                    if event.attr_handle == context.uart_rx_attribute_handle\n                        .expect(\"rx attribute handle is not set\")\n                    {\n                        if let Ok(data) = core::str::from_utf8(event.data()) {\n                            println!(\"\\t=> Rx: -> {:?}\", data);\n                        } else {\n                            println!(\"\\t=> Rx: -> {:?}\", event.data());\n                        }\n                    } else {\n                        println!(\"\\t=> Rx unknown: -> {:?}\", event);\n                    }\n                }\n                Event::DisconnectionComplete(event) => {\n                    println!(\"\\t=> DisconnectionComplete -> {:?}\", event);\n                    state = State::Disconnected;\n                    println!(\"\\nstate = {:?}\", state);\n                }\n                _ => {\n                    println!(\"\\t=> unknown event: {:?}\", event);\n                }\n            }\n            Some(State::Error)\n        });\n        if counter % 1000_000 == 0 && state == State::Connected {\n            //led.toggle().ok();\n            // create message buffer\n            let mut tx_buffer = [0 as u8; CHARACTERISTIC_VALUE_LENGTH];\n            let mut tx_cursor = Cursor::new(&mut tx_buffer[..]);\n            match write!(&mut tx_cursor, \"server counter: {}\", counter / 100_000) {\n            //match write!(&mut tx_cursor, \"0123456789012345678 server: {}\", counter / 100_000) {\n                Ok(()) => (),\n                Err(e) => {\n                    println!(\"failed write: {:?}\", e);\n                    continue\n                }\n            }\n            let position: usize = tx_cursor.position() as usize;\n            let tx_buffer = &tx_cursor.into_inner()[0..position];\n            // send message buffer\n            block!(bluetooth.with_spi(&mut spi3, |controller| {\n                controller.update_characteristic_value(&bluenrg::gatt::UpdateCharacteristicValueParameters {\n                    service_handle: context.uart_service_handle.expect(\"uart service handle has not been set\"),\n                    characteristic_handle: context.uart_tx_handle.expect(\"uart tx handle has not been set\"),\n                    offset: 0x00,\n                    value: tx_buffer,\n                })\n            })).unwrap();\n            ble_uart::controller_read(&mut spi3, &mut bluetooth);\n        }\n        if counter >= 0xffff_fffe {\n            break;\n        } else {\n            counter += 1;\n        }\n    }\n    Ok(())\n"]], "pred": {"ppl": 1.7698007822036743, "ppl_lower": 2.297322988510132, "ppl/lowercase_ppl": -1.4569848051432703, "ppl/zlib": 0.00024500729091156024, "Min_5.0% Prob": 5.973180270662494, "Min_10.0% Prob": 4.300828836712182, "Min_20.0% Prob": 2.656842297636995, "Min_30.0% Prob": 1.86312435036586, "Min_40.0% Prob": 1.4169496791687746, "Min_50.0% Prob": 1.1404963676433157, "Min_60.0% Prob": 0.9522948198006784}}
{"hexsha": "bfc489018883d968955a4b6a7de8c6ce38abbb90", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    // Tell cargo to tell rustc to link the system bzip2\n    // shared library.\n    println!(\"cargo:rustc-link-lib=static=honey_analyzer\");\n    println!(\"cargo:rustc-link-search=./Honeybee/build\");\n\n    Command::new(\"make\")\n        .args(&[\"-C\", \"./Honeybee/build\"])\n        .output()\n        .expect(\"could not run make\");\n\n    // Tell cargo to invalidate the built crate whenever the wrapper changes\n    println!(\"cargo:rerun-if-changed=wrapper.h\");\n    println!(\"cargo:rerun-if-changed=./Honeybee/build/libhoney_analyzer.a\");\n\n    // The bindgen::Builder is the main entry point\n    // to bindgen, and lets you build up options for\n    // the resulting bindings.\n    let bindings = bindgen::Builder::default()\n        // The input header we would like to generate\n        // bindings for.\n        .header(\"wrapper.h\")\n        // Tell cargo to invalidate the built crate whenever any of the\n        // included header files changed.\n        .parse_callbacks(Box::new(bindgen::CargoCallbacks))\n        // Finish the builder and generate the bindings.\n        .generate()\n        // Unwrap the Result and panic on failure.\n        .expect(\"Unable to generate bindings\");\n\n    // Write the bindings to the $OUT_DIR/bindings.rs file.\n    let out_path = PathBuf::from(env::var(\"OUT_DIR\").unwrap());\n    bindings\n        .write_to_file(out_path.join(\"bindings.rs\"))\n        .expect(\"Couldn't write bindings!\");\n}", "item_id": 0, "repo": "Lukas-Dresel/rust-honeybee-sys", "file": "build.rs", "last_update_at": "2022-03-22T09:39:24+00:00", "question_id": "bfc489018883d968955a4b6a7de8c6ce38abbb90_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    // Tell cargo to tell rustc to link the system bzip2\n    // shared library.\n    println!(\"cargo:rustc-link-lib=static=honey_analyzer\");\n    println!(\"cargo:rustc-link-search=./Honeybee/build\");\n    Command::new(\"make\")\n        .args(&[\"-C\", \"./Honeybee/build\"])\n        .output()\n        .expect(\"could not run make\");\n    // Tell cargo to invalidate the built crate whenever the wrapper changes\n    println!(\"cargo:rerun-if-changed=wrapper.h\");\n    println!(\"cargo:rerun-if-changed=./Honeybee/build/libhoney_analyzer.a\");\n    // The bindgen::Builder is the main entry point\n    // to bindgen, and lets you build up options for\n    // the resulting bindings.\n    let bindings = bindgen::Builder::default()\n        // The input header we would like to generate\n        // bindings for.\n        .header(\"wrapper.h\")\n        // Tell cargo to invalidate the built crate whenever any of the\n        // included header files changed.\n        .parse_callbacks(Box::new(bindgen::CargoCallbacks))\n        // Finish the builder and generate the bindings.\n        .generate()\n        // Unwrap the Result and panic on failure.\n        .expect(\"Unable to generate bindings\");\n    // Write the bindings to the $OUT_DIR/bindings.rs file.\n    let out_path = PathBuf::from(env::var(\"OUT_DIR\").unwrap());\n    bindings\n        .write_to_file(out_path.join(\"bindings.rs\"))\n        .expect(\"Couldn't write bindings!\");\n"]], "pred": {"ppl": 1.3699675798416138, "ppl_lower": 1.9399924278259277, "ppl/lowercase_ppl": -2.1051819533608502, "ppl/zlib": 0.000510189749126161, "Min_5.0% Prob": 4.883471488952637, "Min_10.0% Prob": 2.9587589516526176, "Min_20.0% Prob": 1.5695817110882628, "Min_30.0% Prob": 1.0468952875276367, "Min_40.0% Prob": 0.7887341109677576, "Min_50.0% Prob": 0.6292639771451128, "Min_60.0% Prob": 0.5253843911964717}}
{"hexsha": "2bb86ce178202df66c7ed4d9d7dd56bb2335408b", "ext": "rs", "lang": "Rust", "content": "pub fn parse_start_simulation_job_batch_error(\n    response: &http::Response<bytes::Bytes>,\n) -> std::result::Result<\n    crate::output::StartSimulationJobBatchOutput,\n    crate::error::StartSimulationJobBatchError,\n> {\n    let generic = crate::json_deser::parse_http_generic_error(response)\n        .map_err(crate::error::StartSimulationJobBatchError::unhandled)?;\n    let error_code = match generic.code() {\n        Some(code) => code,\n        None => {\n            return Err(crate::error::StartSimulationJobBatchError::unhandled(\n                generic,\n            ))\n        }\n    };\n\n    let _error_message = generic.message().map(|msg| msg.to_owned());\n    Err(match error_code {\n        \"IdempotentParameterMismatchException\" => crate::error::StartSimulationJobBatchError {\n            meta: generic,\n            kind:\n                crate::error::StartSimulationJobBatchErrorKind::IdempotentParameterMismatchException(\n                    {\n                        #[allow(unused_mut)]\n                        let mut tmp = {\n                            #[allow(unused_mut)]let mut output = crate::error::idempotent_parameter_mismatch_exception::Builder::default();\n                            let _ = response;\n                            output = crate::json_deser::deser_structure_crate_error_idempotent_parameter_mismatch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartSimulationJobBatchError::unhandled)?;\n                            output.build()\n                        };\n                        if (&tmp.message).is_none() {\n                            tmp.message = _error_message;\n                        }\n                        tmp\n                    },\n                ),\n        },\n        \"InternalServerException\" => crate::error::StartSimulationJobBatchError {\n            meta: generic,\n            kind: crate::error::StartSimulationJobBatchErrorKind::InternalServerException({\n                #[allow(unused_mut)]\n                let mut tmp = {\n                    #[allow(unused_mut)]\n                    let mut output = crate::error::internal_server_exception::Builder::default();\n                    let _ = response;\n                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartSimulationJobBatchError::unhandled)?;\n                    output.build()\n                };\n                if (&tmp.message).is_none() {\n                    tmp.message = _error_message;\n                }\n                tmp\n            }),\n        },\n        \"InvalidParameterException\" => crate::error::StartSimulationJobBatchError {\n            meta: generic,\n            kind: crate::error::StartSimulationJobBatchErrorKind::InvalidParameterException({\n                #[allow(unused_mut)]\n                let mut tmp = {\n                    #[allow(unused_mut)]\n                    let mut output = crate::error::invalid_parameter_exception::Builder::default();\n                    let _ = response;\n                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartSimulationJobBatchError::unhandled)?;\n                    output.build()\n                };\n                if (&tmp.message).is_none() {\n                    tmp.message = _error_message;\n                }\n                tmp\n            }),\n        },\n        \"LimitExceededException\" => crate::error::StartSimulationJobBatchError {\n            meta: generic,\n            kind: crate::error::StartSimulationJobBatchErrorKind::LimitExceededException({\n                #[allow(unused_mut)]\n                let mut tmp = {\n                    #[allow(unused_mut)]\n                    let mut output = crate::error::limit_exceeded_exception::Builder::default();\n                    let _ = response;\n                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartSimulationJobBatchError::unhandled)?;\n                    output.build()\n                };\n                if (&tmp.message).is_none() {\n                    tmp.message = _error_message;\n                }\n                tmp\n            }),\n        },\n        \"ThrottlingException\" => crate::error::StartSimulationJobBatchError {\n            meta: generic,\n            kind: crate::error::StartSimulationJobBatchErrorKind::ThrottlingException({\n                #[allow(unused_mut)]\n                let mut tmp = {\n                    #[allow(unused_mut)]\n                    let mut output = crate::error::throttling_exception::Builder::default();\n                    let _ = response;\n                    output = crate::json_deser::deser_structure_crate_error_throttling_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartSimulationJobBatchError::unhandled)?;\n                    output.build()\n                };\n                if (&tmp.message).is_none() {\n                    tmp.message = _error_message;\n                }\n                tmp\n            }),\n        },\n        _ => crate::error::StartSimulationJobBatchError::generic(generic),\n    })\n}", "item_id": 50, "repo": "StevenBlack/aws-sdk-rust", "file": "sdk/robomaker/src/operation_deser.rs", "last_update_at": "2022-03-31T20:47:15+00:00", "question_id": "2bb86ce178202df66c7ed4d9d7dd56bb2335408b_50", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn parse_start_simulation_job_batch_error(\n    response: &http::Response<bytes::Bytes>,\n) -> std::result::Result<\n    crate::output::StartSimulationJobBatchOutput,\n    crate::error::StartSimulationJobBatchError,\n> {\n    let generic = crate::json_deser::parse_http_generic_error(response)\n        .map_err(crate::error::StartSimulationJobBatchError::unhandled)?;\n    let error_code = match generic.code() {\n        Some(code) => code,\n        None => {\n            return Err(crate::error::StartSimulationJobBatchError::unhandled(\n                generic,\n            ))\n        }\n    };\n    let _error_message = generic.message().map(|msg| msg.to_owned());\n    Err(match error_code {\n        \"IdempotentParameterMismatchException\" => crate::error::StartSimulationJobBatchError {\n            meta: generic,\n            kind:\n                crate::error::StartSimulationJobBatchErrorKind::IdempotentParameterMismatchException(\n                    {\n                        #[allow(unused_mut)]\n                        let mut tmp = {\n                            #[allow(unused_mut)]let mut output = crate::error::idempotent_parameter_mismatch_exception::Builder::default();\n                            let _ = response;\n                            output = crate::json_deser::deser_structure_crate_error_idempotent_parameter_mismatch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartSimulationJobBatchError::unhandled)?;\n                            output.build()\n                        };\n                        if (&tmp.message).is_none() {\n                            tmp.message = _error_message;\n                        }\n                        tmp\n                    },\n                ),\n        },\n        \"InternalServerException\" => crate::error::StartSimulationJobBatchError {\n            meta: generic,\n            kind: crate::error::StartSimulationJobBatchErrorKind::InternalServerException({\n                #[allow(unused_mut)]\n                let mut tmp = {\n                    #[allow(unused_mut)]\n                    let mut output = crate::error::internal_server_exception::Builder::default();\n                    let _ = response;\n                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartSimulationJobBatchError::unhandled)?;\n                    output.build()\n                };\n                if (&tmp.message).is_none() {\n                    tmp.message = _error_message;\n                }\n                tmp\n            }),\n        },\n        \"InvalidParameterException\" => crate::error::StartSimulationJobBatchError {\n            meta: generic,\n            kind: crate::error::StartSimulationJobBatchErrorKind::InvalidParameterException({\n                #[allow(unused_mut)]\n                let mut tmp = {\n                    #[allow(unused_mut)]\n                    let mut output = crate::error::invalid_parameter_exception::Builder::default();\n                    let _ = response;\n                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartSimulationJobBatchError::unhandled)?;\n                    output.build()\n                };\n                if (&tmp.message).is_none() {\n                    tmp.message = _error_message;\n                }\n                tmp\n            }),\n        },\n        \"LimitExceededException\" => crate::error::StartSimulationJobBatchError {\n            meta: generic,\n            kind: crate::error::StartSimulationJobBatchErrorKind::LimitExceededException({\n                #[allow(unused_mut)]\n                let mut tmp = {\n                    #[allow(unused_mut)]\n                    let mut output = crate::error::limit_exceeded_exception::Builder::default();\n                    let _ = response;\n                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartSimulationJobBatchError::unhandled)?;\n                    output.build()\n                };\n                if (&tmp.message).is_none() {\n                    tmp.message = _error_message;\n                }\n                tmp\n            }),\n        },\n        \"ThrottlingException\" => crate::error::StartSimulationJobBatchError {\n            meta: generic,\n            kind: crate::error::StartSimulationJobBatchErrorKind::ThrottlingException({\n                #[allow(unused_mut)]\n                let mut tmp = {\n                    #[allow(unused_mut)]\n                    let mut output = crate::error::throttling_exception::Builder::default();\n                    let _ = response;\n                    output = crate::json_deser::deser_structure_crate_error_throttling_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartSimulationJobBatchError::unhandled)?;\n                    output.build()\n                };\n                if (&tmp.message).is_none() {\n                    tmp.message = _error_message;\n                }\n                tmp\n            }),\n        },\n        _ => crate::error::StartSimulationJobBatchError::generic(generic),\n    })\n"]], "pred": {"ppl": 1.4395925998687744, "ppl_lower": 1.5955702066421509, "ppl/lowercase_ppl": -1.282333317613487, "ppl/zlib": 0.0004923785902724565, "Min_5.0% Prob": 5.361067140803618, "Min_10.0% Prob": 3.3643613533646453, "Min_20.0% Prob": 1.8157739867730176, "Min_30.0% Prob": 1.2169687257747903, "Min_40.0% Prob": 0.9111361511129644, "Min_50.0% Prob": 0.7293891243873197, "Min_60.0% Prob": 0.6080480849950158}}
{"hexsha": "008e114c66c0517e2af7501e3ada08ad0af373c7", "ext": "rs", "lang": "Rust", "content": "fn try_main() -> Result<()> {\n    let args = env::args_os()\n        .skip(1)\n        .map(PathBuf::from)\n        .collect::<Vec<_>>();\n\n    let (crate_path, bin_path, target_path) = match args[..] {\n        [ref c, ref b, ref t] => (c, b, t),\n        _ => bail!(\"Incorrect usage\"),\n    };\n\n    Bundler::new_with_dir(bin_path, target_path.parent().unwrap(), crate_path)?\n        .bundle(Path::new(target_path.file_name().unwrap()))?;\n\n    Ok(())\n}", "item_id": 0, "repo": "Aetf/rust-script-bundler", "file": "src/bin/rust-script-bundle.rs", "last_update_at": "2022-01-22T03:43:40+00:00", "question_id": "008e114c66c0517e2af7501e3ada08ad0af373c7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn try_main() -> Result<()> {\n    let args = env::args_os()\n        .skip(1)\n        .map(PathBuf::from)\n        .collect::<Vec<_>>();\n    let (crate_path, bin_path, target_path) = match args[..] {\n        [ref c, ref b, ref t] => (c, b, t),\n        _ => bail!(\"Incorrect usage\"),\n    };\n    Bundler::new_with_dir(bin_path, target_path.parent().unwrap(), crate_path)?\n        .bundle(Path::new(target_path.file_name().unwrap()))?;\n    Ok(())\n"]], "pred": {"ppl": 2.271996021270752, "ppl_lower": 2.906977891921997, "ppl/lowercase_ppl": -1.3003139452019274, "ppl/zlib": 0.003073628275865611, "Min_5.0% Prob": 6.932927310466766, "Min_10.0% Prob": 5.185609772801399, "Min_20.0% Prob": 3.4392220973968506, "Min_30.0% Prob": 2.5804807710647584, "Min_40.0% Prob": 2.0113987898203862, "Min_50.0% Prob": 1.6295365975903613, "Min_60.0% Prob": 1.3758581662550569}}
{"hexsha": "7a35cd8f8ca91a6b6aaf419a68a0563c8d688a9a", "ext": "rs", "lang": "Rust", "content": "fn test_databases_books_annotated() {\n        let app = app_from_test_db(\"books-annotated\");\n\n        assert_eq!(app.stor().count_books(), 3);\n        assert_eq!(app.stor().count_annotations(), 10);\n    }", "item_id": 3, "repo": "tnahs/readstor", "file": "src/cli/app.rs", "last_update_at": "2022-02-20T14:48:56+00:00", "question_id": "7a35cd8f8ca91a6b6aaf419a68a0563c8d688a9a_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_databases_books_annotated() {\n        let app = app_from_test_db(\"books-annotated\");\n        assert_eq!(app.stor().count_books(), 3);\n        assert_eq!(app.stor().count_annotations(), 10);\n"]], "pred": {"ppl": 5.883527755737305, "ppl_lower": 5.883527755737305, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.014291585003759173, "Min_5.0% Prob": 10.532490730285645, "Min_10.0% Prob": 9.032978466578893, "Min_20.0% Prob": 6.22368632044111, "Min_30.0% Prob": 4.915987854912167, "Min_40.0% Prob": 4.090522374425616, "Min_50.0% Prob": 3.4508502653666904, "Min_60.0% Prob": 2.9212215709544362}}
{"hexsha": "f4c80467512e38daec9973a973da8fe1787ff711", "ext": "rs", "lang": "Rust", "content": "pub fn build_collection(\n    collection_path: &Path,\n    wal_config: &WalConfig,               // from config\n    collection_params: &CollectionParams, //  from user\n    optimizers_config: &OptimizersConfig,\n    hnsw_config: &HnswConfig,\n) -> CollectionResult<Collection> {\n    let wal_path = collection_path.join(\"wal\");\n\n    create_dir_all(&wal_path).map_err(|err| CollectionError::ServiceError {\n        error: format!(\"Can't create collection directory. Error: {}\", err),\n    })?;\n\n    let segments_path = collection_path.join(\"segments\");\n\n    create_dir_all(&segments_path).map_err(|err| CollectionError::ServiceError {\n        error: format!(\"Can't create collection directory. Error: {}\", err),\n    })?;\n\n    let mut segment_holder = SegmentHolder::default();\n\n    let schema_storage = Arc::new(SchemaStorage::new());\n\n    for _sid in 0..optimizers_config.default_segment_number {\n        let segment = build_simple_segment(\n            &segments_path,\n            collection_params.vector_size,\n            collection_params.distance,\n            schema_storage.clone(),\n        )?;\n        segment_holder.add(segment);\n    }\n\n    let wal: SerdeWal<CollectionUpdateOperations> =\n        SerdeWal::new(wal_path.to_str().unwrap(), &wal_config.into())?;\n\n    let collection_config = CollectionConfig {\n        params: collection_params.clone(),\n        hnsw_config: *hnsw_config,\n        optimizer_config: optimizers_config.clone(),\n        wal_config: wal_config.clone(),\n    };\n\n    collection_config.save(collection_path)?;\n\n    let optimizers = build_optimizers(\n        collection_path,\n        collection_params,\n        optimizers_config,\n        &collection_config.hnsw_config,\n        schema_storage.clone(),\n    );\n\n    let collection = construct_collection(\n        segment_holder,\n        collection_config,\n        wal,\n        optimizers,\n        collection_path,\n        schema_storage,\n    );\n\n    Ok(collection)\n}", "item_id": 1, "repo": "HaiCheViet/qdrant", "file": "lib/collection/src/collection_builder/collection_builder_base.rs", "last_update_at": "2022-03-29T14:28:30+00:00", "question_id": "f4c80467512e38daec9973a973da8fe1787ff711_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn build_collection(\n    collection_path: &Path,\n    wal_config: &WalConfig,               // from config\n    collection_params: &CollectionParams, //  from user\n    optimizers_config: &OptimizersConfig,\n    hnsw_config: &HnswConfig,\n) -> CollectionResult<Collection> {\n    let wal_path = collection_path.join(\"wal\");\n    create_dir_all(&wal_path).map_err(|err| CollectionError::ServiceError {\n        error: format!(\"Can't create collection directory. Error: {}\", err),\n    })?;\n    let segments_path = collection_path.join(\"segments\");\n    create_dir_all(&segments_path).map_err(|err| CollectionError::ServiceError {\n        error: format!(\"Can't create collection directory. Error: {}\", err),\n    })?;\n    let mut segment_holder = SegmentHolder::default();\n    let schema_storage = Arc::new(SchemaStorage::new());\n    for _sid in 0..optimizers_config.default_segment_number {\n        let segment = build_simple_segment(\n            &segments_path,\n            collection_params.vector_size,\n            collection_params.distance,\n            schema_storage.clone(),\n        )?;\n        segment_holder.add(segment);\n    }\n    let wal: SerdeWal<CollectionUpdateOperations> =\n        SerdeWal::new(wal_path.to_str().unwrap(), &wal_config.into())?;\n    let collection_config = CollectionConfig {\n        params: collection_params.clone(),\n        hnsw_config: *hnsw_config,\n        optimizer_config: optimizers_config.clone(),\n        wal_config: wal_config.clone(),\n    };\n    collection_config.save(collection_path)?;\n    let optimizers = build_optimizers(\n        collection_path,\n        collection_params,\n        optimizers_config,\n        &collection_config.hnsw_config,\n        schema_storage.clone(),\n    );\n    let collection = construct_collection(\n        segment_holder,\n        collection_config,\n        wal,\n        optimizers,\n        collection_path,\n        schema_storage,\n    );\n    Ok(collection)\n"]], "pred": {"ppl": 2.106325387954712, "ppl_lower": 2.47416353225708, "ppl/lowercase_ppl": -1.2160662669756845, "ppl/zlib": 0.0012252383338466316, "Min_5.0% Prob": 7.1322691440582275, "Min_10.0% Prob": 5.067340910434723, "Min_20.0% Prob": 3.2510891146957874, "Min_30.0% Prob": 2.370431481017953, "Min_40.0% Prob": 1.8369693317051445, "Min_50.0% Prob": 1.4819254505703245, "Min_60.0% Prob": 1.240481261835497}}
{"hexsha": "288b05878c115cf8d8040303a66291955e35deae", "ext": "rs", "lang": "Rust", "content": "fn get_block(&self, position: usize) -> Self::Block {\n        assert!(position < self.block_len(),\n                format!(\"Bits::get_block: out of bounds ({}/{})\",\n                        position, self.block_len()));\n\n        let first_bit = Self::Block::mul_nbits(position);\n        let bit_count = Self::Block::block_bits(self.bit_len(), position);\n\n        let mut result = Self::Block::zero();\n        let mut mask = Self::Block::one();\n\n        for i in 0 .. bit_count as u64 {\n            if self.get_bit(first_bit + i) {\n                result = result | mask;\n            }\n            mask = mask << 1;\n        }\n\n        result\n    }", "item_id": 1, "repo": "tov/bv-rs", "file": "src/traits/bits.rs", "last_update_at": "2022-03-11T21:57:21+00:00", "question_id": "288b05878c115cf8d8040303a66291955e35deae_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_block(&self, position: usize) -> Self::Block {\n        assert!(position < self.block_len(),\n                format!(\"Bits::get_block: out of bounds ({}/{})\",\n                        position, self.block_len()));\n        let first_bit = Self::Block::mul_nbits(position);\n        let bit_count = Self::Block::block_bits(self.bit_len(), position);\n        let mut result = Self::Block::zero();\n        let mut mask = Self::Block::one();\n        for i in 0 .. bit_count as u64 {\n            if self.get_bit(first_bit + i) {\n                result = result | mask;\n            }\n            mask = mask << 1;\n        }\n        result\n"]], "pred": {"ppl": 2.558561325073242, "ppl_lower": 2.845254898071289, "ppl/lowercase_ppl": -1.1130534807119778, "ppl/zlib": 0.0034161640659160497, "Min_5.0% Prob": 6.482227537367079, "Min_10.0% Prob": 5.3368568950229225, "Min_20.0% Prob": 3.889861416172337, "Min_30.0% Prob": 2.911376841366291, "Min_40.0% Prob": 2.2811175751686097, "Min_50.0% Prob": 1.8567032503320815, "Min_60.0% Prob": 1.5590555167435545}}
{"hexsha": "50e37a221451a6e4926acb115f4082c5afea99b0", "ext": "rs", "lang": "Rust", "content": "fn test_add_offset() {\n        let q1 = UnitQuaternion::from_quaternion(Quaternion::new(\n            4.329780281177467e-17,\n            0.7071067811865476,\n            4.329780281177466e-17,\n            0.7071067811865475,\n        ));\n        let t = Translation3::new(0.2, 1.4, 2.);\n        let mut position = Isometry3::from_parts(t, q1);\n        apply_grip_offset(&mut position);\n\n        let expected_rotation = Quaternion::new(\n            -0.5493369162990798,\n            -0.4188107240790279,\n            0.6209124327141259,\n            -0.3705324286596844,\n        );\n        let expected_translation = Translation3::new(0.2, 1.328827, 2.066082);\n\n        approx::assert_relative_eq!(position.rotation.quaternion(), &expected_rotation);\n        approx::assert_relative_eq!(position.translation, &expected_translation);\n    }", "item_id": 4, "repo": "leetvr/hotham", "file": "examples/beat-saber-clone/src/systems/sabers.rs", "last_update_at": "2022-03-30T11:15:40+00:00", "question_id": "50e37a221451a6e4926acb115f4082c5afea99b0_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_add_offset() {\n        let q1 = UnitQuaternion::from_quaternion(Quaternion::new(\n            4.329780281177467e-17,\n            0.7071067811865476,\n            4.329780281177466e-17,\n            0.7071067811865475,\n        ));\n        let t = Translation3::new(0.2, 1.4, 2.);\n        let mut position = Isometry3::from_parts(t, q1);\n        apply_grip_offset(&mut position);\n        let expected_rotation = Quaternion::new(\n            -0.5493369162990798,\n            -0.4188107240790279,\n            0.6209124327141259,\n            -0.3705324286596844,\n        );\n        let expected_translation = Translation3::new(0.2, 1.328827, 2.066082);\n        approx::assert_relative_eq!(position.rotation.quaternion(), &expected_rotation);\n        approx::assert_relative_eq!(position.translation, &expected_translation);\n"]], "pred": {"ppl": 3.0579934120178223, "ppl_lower": 3.3057427406311035, "ppl/lowercase_ppl": -1.0696950152700773, "ppl/zlib": 0.0032778854931411437, "Min_5.0% Prob": 6.3909469445546465, "Min_10.0% Prob": 4.7272768278379695, "Min_20.0% Prob": 3.577662814458211, "Min_30.0% Prob": 3.1452887718166624, "Min_40.0% Prob": 2.6697287102540335, "Min_50.0% Prob": 2.2121596158666406, "Min_60.0% Prob": 1.8576447639365992}}
{"hexsha": "378b0c384de771b6b3e18cc42ab0e276a648fb5b", "ext": "rs", "lang": "Rust", "content": "fn test_n_triples_parse_literal() {\n        let input = \"\\\"a\\\"\".as_bytes();\n\n        let mut lexer = NTriplesLexer::new(input);\n\n        assert_eq!(\n            lexer.get_next_token().unwrap(),\n            Token::Literal(\"a\".to_string())\n        );\n    }", "item_id": 1, "repo": "media-io/rdf-rs", "file": "src/reader/lexer/n_triples_lexer.rs", "last_update_at": "2022-02-20T23:01:21+00:00", "question_id": "378b0c384de771b6b3e18cc42ab0e276a648fb5b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_n_triples_parse_literal() {\n        let input = \"\\\"a\\\"\".as_bytes();\n        let mut lexer = NTriplesLexer::new(input);\n        assert_eq!(\n            lexer.get_next_token().unwrap(),\n            Token::Literal(\"a\".to_string())\n        );\n"]], "pred": {"ppl": 2.8474504947662354, "ppl_lower": 3.8914005756378174, "ppl/lowercase_ppl": -1.298488087183528, "ppl/zlib": 0.006228714468334307, "Min_5.0% Prob": 6.848084926605225, "Min_10.0% Prob": 5.678297817707062, "Min_20.0% Prob": 3.9821392788606533, "Min_30.0% Prob": 3.126253480911255, "Min_40.0% Prob": 2.5057487855939304, "Min_50.0% Prob": 2.0375107502521472, "Min_60.0% Prob": 1.745316367523343}}
{"hexsha": "c0ef355e1a4d368491e2928aecf91b843ab68c58", "ext": "rs", "lang": "Rust", "content": "pub fn get_test_data() -> Vec<u8> {\n    use std::env;\n    let path = env::var(\"TEST_FILE\").unwrap_or(\"tests/pg11.txt\".to_string());\n    get_test_file_data(&path)\n}", "item_id": 1, "repo": "allansrc/fuchsia", "file": "third_party/rust_crates/vendor/deflate/src/test_utils.rs", "last_update_at": "2022-03-28T07:59:06+00:00", "question_id": "c0ef355e1a4d368491e2928aecf91b843ab68c58_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_test_data() -> Vec<u8> {\n    use std::env;\n    let path = env::var(\"TEST_FILE\").unwrap_or(\"tests/pg11.txt\".to_string());\n    get_test_file_data(&path)\n"]], "pred": {"ppl": 3.941181182861328, "ppl_lower": 4.92532205581665, "ppl/lowercase_ppl": -1.1625318028659184, "ppl/zlib": 0.00965831317595364, "Min_5.0% Prob": 9.41768709818522, "Min_10.0% Prob": 7.537195563316345, "Min_20.0% Prob": 4.954366537240835, "Min_30.0% Prob": 3.949651416979338, "Min_40.0% Prob": 3.187209826249343, "Min_50.0% Prob": 2.7088669622316957, "Min_60.0% Prob": 2.2612074185640383}}
{"hexsha": "3291454d9441767fcf4857710a9b2dd15cb5e40a", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let s1 = String::from(\"Hello world\");\n    let s2 = s1;\n    // s1 is not more valid\n\n    println!(\"{}, bye\", s2);\n    let s3 = s2.clone();\n    println!(\" {} ----- {}\", s2, s3);\n    take_ownership(s2);\n    let i = 0;\n    make_copy(i);\n\n    let s2 = give_ownership(s3);\n    let il = calculate_len(&s2);\n    println!(\" {} ----- {}\", s2, il);\n}", "item_id": 0, "repo": "dmike16/study-notes", "file": "rust/ownership/src/main.rs", "last_update_at": "2022-01-14T22:34:57+00:00", "question_id": "3291454d9441767fcf4857710a9b2dd15cb5e40a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let s1 = String::from(\"Hello world\");\n    let s2 = s1;\n    // s1 is not more valid\n    println!(\"{}, bye\", s2);\n    let s3 = s2.clone();\n    println!(\" {} ----- {}\", s2, s3);\n    take_ownership(s2);\n    let i = 0;\n    make_copy(i);\n    let s2 = give_ownership(s3);\n    let il = calculate_len(&s2);\n    println!(\" {} ----- {}\", s2, il);\n"]], "pred": {"ppl": 3.345536947250366, "ppl_lower": 3.630156993865967, "ppl/lowercase_ppl": -1.0676108430563875, "ppl/zlib": 0.006068478407260071, "Min_5.0% Prob": 9.072482654026576, "Min_10.0% Prob": 6.9541844470160346, "Min_20.0% Prob": 4.763832867145538, "Min_30.0% Prob": 3.6095064878463745, "Min_40.0% Prob": 2.8663445271943746, "Min_50.0% Prob": 2.3698264987955633, "Min_60.0% Prob": 2.0053577335441815}}
{"hexsha": "0f964ef47fe7df50a72fa11257c1413277cf8ab0", "ext": "rs", "lang": "Rust", "content": "fn stop_search_in_tab<TFileSystem: Clone + Debug + Default + FileSystem>(\n    tabs: Vec<TabState<TFileSystem>>,\n    tab: TabIdx,\n) -> Vec<TabState<TFileSystem>> {\n    let mut result = Vec::<TabState<TFileSystem>>::new();\n\n    for (idx, tab_state) in tabs.iter().enumerate() {\n        if idx == tab {\n            result.push(TabState {\n                search_mode: false,\n                phrase: String::from(\"\"),\n                ..tab_state.clone()\n            });\n        } else {\n            result.push(tab_state.clone());\n        }\n    }\n\n    result\n}", "item_id": 1, "repo": "mihaigalos/sfm", "file": "src/app/reducers/search_reducer.rs", "last_update_at": "2022-03-09T01:18:31+00:00", "question_id": "0f964ef47fe7df50a72fa11257c1413277cf8ab0_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn stop_search_in_tab<TFileSystem: Clone + Debug + Default + FileSystem>(\n    tabs: Vec<TabState<TFileSystem>>,\n    tab: TabIdx,\n) -> Vec<TabState<TFileSystem>> {\n    let mut result = Vec::<TabState<TFileSystem>>::new();\n    for (idx, tab_state) in tabs.iter().enumerate() {\n        if idx == tab {\n            result.push(TabState {\n                search_mode: false,\n                phrase: String::from(\"\"),\n                ..tab_state.clone()\n            });\n        } else {\n            result.push(tab_state.clone());\n        }\n    }\n    result\n"]], "pred": {"ppl": 2.3395116329193115, "ppl_lower": 3.2375781536102295, "ppl/lowercase_ppl": -1.3822417121084085, "ppl/zlib": 0.0032317194057311345, "Min_5.0% Prob": 8.276075065135956, "Min_10.0% Prob": 5.892075664856854, "Min_20.0% Prob": 3.785602026125964, "Min_30.0% Prob": 2.733247378877565, "Min_40.0% Prob": 2.102248139460297, "Min_50.0% Prob": 1.6955510040416437, "Min_60.0% Prob": 1.4154963898929018}}
{"hexsha": "ead18f7810c59496ea57eb60be925abf8a067436", "ext": "rs", "lang": "Rust", "content": "fn test_bitvec_set_raw_copy() {\n    let v = vec![7];\n    let buf = v.as_ptr();\n    let mut bitvec = unsafe { BitVec::from_raw_copy(buf, 1, 64) };\n    let ptr = bitvec.storage.as_mut_ptr();\n    let buffer_len = bitvec.storage.len();\n    let mut bitvec2 = BitVec::zeros(1);\n    unsafe {\n        bitvec2.set_raw_copy(ptr, buffer_len, bitvec.nbits);\n    }\n    assert_eq!(v.len(), 1); // ensure v lives long enough\n    assert_eq!(bitvec2.get(0), Some(true));\n    assert_eq!(bitvec2.get(1), Some(true));\n    assert_eq!(bitvec2.get(2), Some(true));\n    assert_eq!(bitvec2.get(3), Some(false));\n    assert_eq!(bitvec2.get(63), Some(false));\n    assert_eq!(bitvec2.get(64), None);\n}", "item_id": 12, "repo": "GCCFeli/bitvec_simd", "file": "src/tests.rs", "last_update_at": "2022-03-18T03:45:50+00:00", "question_id": "ead18f7810c59496ea57eb60be925abf8a067436_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_bitvec_set_raw_copy() {\n    let v = vec![7];\n    let buf = v.as_ptr();\n    let mut bitvec = unsafe { BitVec::from_raw_copy(buf, 1, 64) };\n    let ptr = bitvec.storage.as_mut_ptr();\n    let buffer_len = bitvec.storage.len();\n    let mut bitvec2 = BitVec::zeros(1);\n    unsafe {\n        bitvec2.set_raw_copy(ptr, buffer_len, bitvec.nbits);\n    }\n    assert_eq!(v.len(), 1); // ensure v lives long enough\n    assert_eq!(bitvec2.get(0), Some(true));\n    assert_eq!(bitvec2.get(1), Some(true));\n    assert_eq!(bitvec2.get(2), Some(true));\n    assert_eq!(bitvec2.get(3), Some(false));\n    assert_eq!(bitvec2.get(63), Some(false));\n    assert_eq!(bitvec2.get(64), None);\n"]], "pred": {"ppl": 2.117616891860962, "ppl_lower": 2.2475650310516357, "ppl/lowercase_ppl": -1.079377262036043, "ppl/zlib": 0.0027382895941179724, "Min_5.0% Prob": 6.105537561269907, "Min_10.0% Prob": 4.958730578422546, "Min_20.0% Prob": 3.2800896268970563, "Min_30.0% Prob": 2.3608707949519157, "Min_40.0% Prob": 1.8451871530346151, "Min_50.0% Prob": 1.4922170111895503, "Min_60.0% Prob": 1.24823270192137}}
{"hexsha": "87138225c889272ff48408c3c09661d09fda2894", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    #[derive(Form)]\n    #[form(newtype)]\n    struct A{}\n}", "item_id": 0, "repo": "swimos/swim-rust", "file": "api/swim_form/src/tests/derive/form/newtype_empty_struct.rs", "last_update_at": "2022-02-10T00:59:19+00:00", "question_id": "87138225c889272ff48408c3c09661d09fda2894_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    #[derive(Form)]\n    #[form(newtype)]\n    struct A{}\n"]], "pred": {"ppl": 8.765222549438477, "ppl_lower": 9.927397727966309, "ppl/lowercase_ppl": -1.0573553240322218, "ppl/zlib": 0.033918623574148356, "Min_5.0% Prob": 9.88010311126709, "Min_10.0% Prob": 9.813698291778564, "Min_20.0% Prob": 8.310917949676513, "Min_30.0% Prob": 6.345401957631111, "Min_40.0% Prob": 5.412339723110199, "Min_50.0% Prob": 4.413979787092942, "Min_60.0% Prob": 3.6508671743795276}}
{"hexsha": "24068e3b222ff3ad03e1e0e3566ae2cdfae4aeaf", "ext": "rs", "lang": "Rust", "content": "fn copy(matches: getopts::Matches) {\n    let sources: Vec<String> = if matches.free.is_empty() {\n        show_error!(\"Missing SOURCE argument. Try --help.\");\n        panic!()\n    } else {\n        // All but the last argument:\n        matches.free[..matches.free.len() - 1].iter().cloned().collect()\n    };\n    let dest = if matches.free.len() < 2 {\n        show_error!(\"Missing DEST argument. Try --help.\");\n        panic!()\n    } else {\n        // Only the last argument:\n        Path::new(&matches.free[matches.free.len() - 1])\n    };\n\n    assert!(sources.len() >= 1);\n\n    if sources.len() == 1 {\n        let source = Path::new(&sources[0]);\n        let same_file = paths_refer_to_same_file(source, dest).unwrap_or_else(|err| {\n            match err.kind() {\n                ErrorKind::NotFound => false,\n                _ => {\n                    show_error!(\"{}\", err);\n                    panic!()\n                }\n            }\n        });\n\n        if same_file {\n            show_error!(\"\\\"{}\\\" and \\\"{}\\\" are the same file\",\n                source.display(),\n                dest.display());\n            panic!();\n        }\n\n        if let Err(err) = fs::copy(source, dest) {\n            show_error!(\"{}\", err);\n            panic!();\n        }\n    } else {\n        if !dest.is_dir() {\n            show_error!(\"TARGET must be a directory\");\n            panic!();\n        }\n\n        for src in &sources {\n            let source = Path::new(&src);\n\n            if !source.is_file() {\n                show_error!(\"\\\"{}\\\" is not a file\", source.display());\n                continue;\n            }\n\n            let mut full_dest = dest.to_path_buf();\n\n            full_dest.push(source.to_str().unwrap());\n\n            println!(\"{}\", full_dest.display());\n\n            let io_result = fs::copy(source, full_dest);\n\n            if let Err(err) = io_result {\n                show_error!(\"{}\", err);\n                panic!()\n            }\n        }\n    }\n}", "item_id": 1, "repo": "KokaKiwi/coreutils", "file": "src/cp/cp.rs", "last_update_at": "2022-02-08T08:44:00+00:00", "question_id": "24068e3b222ff3ad03e1e0e3566ae2cdfae4aeaf_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn copy(matches: getopts::Matches) {\n    let sources: Vec<String> = if matches.free.is_empty() {\n        show_error!(\"Missing SOURCE argument. Try --help.\");\n        panic!()\n    } else {\n        // All but the last argument:\n        matches.free[..matches.free.len() - 1].iter().cloned().collect()\n    };\n    let dest = if matches.free.len() < 2 {\n        show_error!(\"Missing DEST argument. Try --help.\");\n        panic!()\n    } else {\n        // Only the last argument:\n        Path::new(&matches.free[matches.free.len() - 1])\n    };\n    assert!(sources.len() >= 1);\n    if sources.len() == 1 {\n        let source = Path::new(&sources[0]);\n        let same_file = paths_refer_to_same_file(source, dest).unwrap_or_else(|err| {\n            match err.kind() {\n                ErrorKind::NotFound => false,\n                _ => {\n                    show_error!(\"{}\", err);\n                    panic!()\n                }\n            }\n        });\n        if same_file {\n            show_error!(\"\\\"{}\\\" and \\\"{}\\\" are the same file\",\n                source.display(),\n                dest.display());\n            panic!();\n        }\n        if let Err(err) = fs::copy(source, dest) {\n            show_error!(\"{}\", err);\n            panic!();\n        }\n    } else {\n        if !dest.is_dir() {\n            show_error!(\"TARGET must be a directory\");\n            panic!();\n        }\n        for src in &sources {\n            let source = Path::new(&src);\n            if !source.is_file() {\n                show_error!(\"\\\"{}\\\" is not a file\", source.display());\n                continue;\n            }\n            let mut full_dest = dest.to_path_buf();\n            full_dest.push(source.to_str().unwrap());\n            println!(\"{}\", full_dest.display());\n            let io_result = fs::copy(source, full_dest);\n            if let Err(err) = io_result {\n                show_error!(\"{}\", err);\n                panic!()\n            }\n        }\n    }\n"]], "pred": {"ppl": 1.6999335289001465, "ppl_lower": 1.957570195198059, "ppl/lowercase_ppl": -1.2659588088031697, "ppl/zlib": 0.0008100597704591566, "Min_5.0% Prob": 6.214294474700401, "Min_10.0% Prob": 4.0801542483527085, "Min_20.0% Prob": 2.456120746916738, "Min_30.0% Prob": 1.7251712795475433, "Min_40.0% Prob": 1.3169540249389307, "Min_50.0% Prob": 1.05868822605317, "Min_60.0% Prob": 0.8835610320708639}}
{"hexsha": "db9dbc74b12bdbaa442c66982b7ad32de4420b40", "ext": "rs", "lang": "Rust", "content": "pub fn consume(channel: Channel, basic_consume: BasicConsume) -> MethodResponse {\n    let BasicConsume {\n        queue: queue_name,\n        consumer_tag,\n        no_local,\n        no_ack,\n        exclusive,\n        no_wait,\n        ..\n    } = basic_consume;\n\n    if no_local || exclusive || no_ack {\n        amqp_todo!();\n    }\n\n    let global_data = channel.global_data.clone();\n\n    let consumer_tag = if consumer_tag.is_empty() {\n        haesli_core::random_uuid().to_string()\n    } else {\n        consumer_tag\n    };\n\n    let mut global_data = global_data.lock();\n\n    let queue = global_data\n        .queues\n        .get_mut(queue_name.as_str())\n        .ok_or(ChannelException::NotFound)?;\n\n    let consumer = Consumer {\n        id: ConsumerId::random(),\n        tag: consumer_tag.clone(),\n        channel: Arc::clone(&channel),\n        queue: Arc::clone(queue),\n    };\n\n    queue.consumers.lock().insert(consumer.id, consumer.clone());\n\n    channel.connection.consuming.lock().push(consumer);\n\n    info!(%queue_name, %consumer_tag, \"Consumer started consuming\");\n\n    Ok(no_wait\n        .not()\n        .then(|| Method::BasicConsumeOk(BasicConsumeOk { consumer_tag })))\n}", "item_id": 0, "repo": "Nilstrieb/haesli", "file": "haesli_messaging/src/methods/consume.rs", "last_update_at": "2022-02-21T14:06:42+00:00", "question_id": "db9dbc74b12bdbaa442c66982b7ad32de4420b40_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn consume(channel: Channel, basic_consume: BasicConsume) -> MethodResponse {\n    let BasicConsume {\n        queue: queue_name,\n        consumer_tag,\n        no_local,\n        no_ack,\n        exclusive,\n        no_wait,\n        ..\n    } = basic_consume;\n    if no_local || exclusive || no_ack {\n        amqp_todo!();\n    }\n    let global_data = channel.global_data.clone();\n    let consumer_tag = if consumer_tag.is_empty() {\n        haesli_core::random_uuid().to_string()\n    } else {\n        consumer_tag\n    };\n    let mut global_data = global_data.lock();\n    let queue = global_data\n        .queues\n        .get_mut(queue_name.as_str())\n        .ok_or(ChannelException::NotFound)?;\n    let consumer = Consumer {\n        id: ConsumerId::random(),\n        tag: consumer_tag.clone(),\n        channel: Arc::clone(&channel),\n        queue: Arc::clone(queue),\n    };\n    queue.consumers.lock().insert(consumer.id, consumer.clone());\n    channel.connection.consuming.lock().push(consumer);\n    info!(%queue_name, %consumer_tag, \"Consumer started consuming\");\n    Ok(no_wait\n        .not()\n        .then(|| Method::BasicConsumeOk(BasicConsumeOk { consumer_tag })))\n"]], "pred": {"ppl": 2.4071271419525146, "ppl_lower": 2.829265832901001, "ppl/lowercase_ppl": -1.1839447012229851, "ppl/zlib": 0.0018610889388898841, "Min_5.0% Prob": 7.591534482108222, "Min_10.0% Prob": 5.750689326105891, "Min_20.0% Prob": 3.7678205354793652, "Min_30.0% Prob": 2.753540708550385, "Min_40.0% Prob": 2.157238289013805, "Min_50.0% Prob": 1.7454040146527443, "Min_60.0% Prob": 1.4642738507495128}}
{"hexsha": "e0c0885fe3e34bd594657dc9b93874c7cb20d856", "ext": "rs", "lang": "Rust", "content": "fn to_diagram(src: &str) -> (String, Vec<(&'static str, String)>) {\n    let macro_rules = macro_railroad::parser::parse(&src).expect(src);\n    let mut tree = macro_railroad::lowering::MacroRules::from(macro_rules);\n    let name = tree.name.clone();\n    let mut v = Vec::new();\n\n    v.push((\n        \"vanilla\",\n        macro_railroad::diagram::into_diagram(tree.clone(), true).to_string(),\n    ));\n\n    let mut tree_ungrouped = tree.clone();\n    tree_ungrouped.ungroup();\n    v.push((\n        \"ungrouped\",\n        macro_railroad::diagram::into_diagram(tree_ungrouped, false).to_string(),\n    ));\n\n    tree.remove_internal();\n    tree.foldcommontails();\n    tree.normalize();\n    v.push((\n        \"optimized\",\n        macro_railroad::diagram::into_diagram(tree, true).to_string(),\n    ));\n\n    (name, v)\n}", "item_id": 0, "repo": "lukaslueg/macro_railroad", "file": "tests/verification.rs", "last_update_at": "2022-03-31T09:08:44+00:00", "question_id": "e0c0885fe3e34bd594657dc9b93874c7cb20d856_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn to_diagram(src: &str) -> (String, Vec<(&'static str, String)>) {\n    let macro_rules = macro_railroad::parser::parse(&src).expect(src);\n    let mut tree = macro_railroad::lowering::MacroRules::from(macro_rules);\n    let name = tree.name.clone();\n    let mut v = Vec::new();\n    v.push((\n        \"vanilla\",\n        macro_railroad::diagram::into_diagram(tree.clone(), true).to_string(),\n    ));\n    let mut tree_ungrouped = tree.clone();\n    tree_ungrouped.ungroup();\n    v.push((\n        \"ungrouped\",\n        macro_railroad::diagram::into_diagram(tree_ungrouped, false).to_string(),\n    ));\n    tree.remove_internal();\n    tree.foldcommontails();\n    tree.normalize();\n    v.push((\n        \"optimized\",\n        macro_railroad::diagram::into_diagram(tree, true).to_string(),\n    ));\n    (name, v)\n"]], "pred": {"ppl": 2.6458442211151123, "ppl_lower": 2.993375062942505, "ppl/lowercase_ppl": -1.1268371921730913, "ppl/zlib": 0.003079082881675198, "Min_5.0% Prob": 8.270542860031128, "Min_10.0% Prob": 6.306640761239188, "Min_20.0% Prob": 4.245202357308907, "Min_30.0% Prob": 3.1275579424465403, "Min_40.0% Prob": 2.4037654209032393, "Min_50.0% Prob": 1.9479083133415438, "Min_60.0% Prob": 1.6210525975404688}}
{"hexsha": "422c2630057f5e3b37c74adb2284892b77a510a1", "ext": "rs", "lang": "Rust", "content": "unsafe extern \"C\" fn media_unsuspend<T: RTSPMediaImpl>(\n    ptr: *mut ffi::GstRTSPMedia,\n) -> glib::ffi::gboolean {\n    let instance = &*(ptr as *mut T::Instance);\n    let imp = instance.impl_();\n    let wrap: Borrowed<RTSPMedia> = from_glib_borrow(ptr);\n\n    match imp.unsuspend(wrap.unsafe_cast_ref()) {\n        Ok(()) => glib::ffi::GTRUE,\n        Err(err) => {\n            err.log_with_object(&*wrap);\n            glib::ffi::GFALSE\n        }\n    }\n}", "item_id": 4, "repo": "pbor/gstreamer-rs", "file": "gstreamer-rtsp-server/src/subclass/rtsp_media.rs", "last_update_at": "2022-03-20T06:06:05+00:00", "question_id": "422c2630057f5e3b37c74adb2284892b77a510a1_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe extern \"C\" fn media_unsuspend<T: RTSPMediaImpl>(\n    ptr: *mut ffi::GstRTSPMedia,\n) -> glib::ffi::gboolean {\n    let instance = &*(ptr as *mut T::Instance);\n    let imp = instance.impl_();\n    let wrap: Borrowed<RTSPMedia> = from_glib_borrow(ptr);\n    match imp.unsuspend(wrap.unsafe_cast_ref()) {\n        Ok(()) => glib::ffi::GTRUE,\n        Err(err) => {\n            err.log_with_object(&*wrap);\n            glib::ffi::GFALSE\n        }\n    }\n"]], "pred": {"ppl": 1.7016733884811401, "ppl_lower": 2.9836907386779785, "ppl/lowercase_ppl": -2.0563132596640075, "ppl/zlib": 0.001961668313935605, "Min_5.0% Prob": 8.47107708454132, "Min_10.0% Prob": 4.7720235516043275, "Min_20.0% Prob": 2.6002516067203354, "Min_30.0% Prob": 1.760469505307721, "Min_40.0% Prob": 1.3271482903647291, "Min_50.0% Prob": 1.0629580161041197, "Min_60.0% Prob": 0.885959178348832}}
{"hexsha": "8a15579b1ca5073c0fed58e1bfa0cbaca93c9167", "ext": "rs", "lang": "Rust", "content": "fn panicIfProcessNotSuccessful(programName: &'static str, absoluteHomeFolderPath: &str, mut command: Command) -> String\n{\n\tlet output = command.output().unwrap_or_else(|error|\n\t{\n\t\tpanic!(\"Failed to execute '{}' in '{}' error was '{}'\", programName, absoluteHomeFolderPath, error);\n\t});\n\t\n\tlet code = output.status.code().unwrap_or_else(||\n\t{\n\t\tpanic!(\"Failed to retrieve exit status from command - was it killed by a signal?\");\n\t});\n\n\tlet standardOut = String::from_utf8_lossy(&output.stdout);\n\tif code == 0\n\t{\n\t\treturn standardOut.into_owned();\n\t}\n\t\n\tlet standardError = String::from_utf8_lossy(&output.stderr);\n\tpanic!(\"Command '{}' failed with exit code '{}' (standard out was '{}'; standard error was '{}')\", programName, code, standardOut.into_owned(), standardError.into_owned());\n}", "item_id": 1, "repo": "lemonrock/rdma-core", "file": "workspace/mxm-reference-sys/src/build.rs", "last_update_at": "2022-01-02T22:09:52+00:00", "question_id": "8a15579b1ca5073c0fed58e1bfa0cbaca93c9167_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn panicIfProcessNotSuccessful(programName: &'static str, absoluteHomeFolderPath: &str, mut command: Command) -> String\n{\n\tlet output = command.output().unwrap_or_else(|error|\n\t{\n\t\tpanic!(\"Failed to execute '{}' in '{}' error was '{}'\", programName, absoluteHomeFolderPath, error);\n\t});\n\t\n\tlet code = output.status.code().unwrap_or_else(||\n\t{\n\t\tpanic!(\"Failed to retrieve exit status from command - was it killed by a signal?\");\n\t});\n\tlet standardOut = String::from_utf8_lossy(&output.stdout);\n\tif code == 0\n\t{\n\t\treturn standardOut.into_owned();\n\t}\n\t\n\tlet standardError = String::from_utf8_lossy(&output.stderr);\n\tpanic!(\"Command '{}' failed with exit code '{}' (standard out was '{}'; standard error was '{}')\", programName, code, standardOut.into_owned(), standardError.into_owned());\n"]], "pred": {"ppl": 2.430664539337158, "ppl_lower": 2.7028391361236572, "ppl/lowercase_ppl": -1.119502678202559, "ppl/zlib": 0.0023558745170922882, "Min_5.0% Prob": 7.859662413597107, "Min_10.0% Prob": 5.762922458648681, "Min_20.0% Prob": 3.8199556037491442, "Min_30.0% Prob": 2.8161464568815733, "Min_40.0% Prob": 2.190003372290555, "Min_50.0% Prob": 1.7689279708138201, "Min_60.0% Prob": 1.4845084174189205}}
{"hexsha": "b81ef9dc4252d344f33a898fa7fb1991639ccc4e", "ext": "rs", "lang": "Rust", "content": "fn data_set() -> Vec<Vec<u8>> {\n\tuse rand::SeedableRng;\n\tuse rand::Rng;\n\n\tlet rnd: [u8; 32] = rand::rngs::StdRng::seed_from_u64(12).gen();\n\tlet mut rnd = rnd.iter().cycle();\n\tlet mut res = Vec::new();\n\tfor size in 1..=MAX_KEY_SIZE {\n\t\tfor _ in 0..1_000 {\n\t\t\tlet value = (0..size)\n\t\t\t\t.map(|_| rnd.next().unwrap().clone())\n\t\t\t\t.collect();\n\t\t\tres.push(value);\n\t\t}\n\t}\n\tres\n}", "item_id": 0, "repo": "wm5713/blogs", "file": "learn substrate/substrate-1.0/core/primitives/benches/benches.rs", "last_update_at": "2022-02-14T16:09:57+00:00", "question_id": "b81ef9dc4252d344f33a898fa7fb1991639ccc4e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn data_set() -> Vec<Vec<u8>> {\n\tuse rand::SeedableRng;\n\tuse rand::Rng;\n\tlet rnd: [u8; 32] = rand::rngs::StdRng::seed_from_u64(12).gen();\n\tlet mut rnd = rnd.iter().cycle();\n\tlet mut res = Vec::new();\n\tfor size in 1..=MAX_KEY_SIZE {\n\t\tfor _ in 0..1_000 {\n\t\t\tlet value = (0..size)\n\t\t\t\t.map(|_| rnd.next().unwrap().clone())\n\t\t\t\t.collect();\n\t\t\tres.push(value);\n\t\t}\n\t}\n\tres\n"]], "pred": {"ppl": 2.1008777618408203, "ppl_lower": 3.294323682785034, "ppl/lowercase_ppl": -1.6059708725462745, "ppl/zlib": 0.0028552124585702644, "Min_5.0% Prob": 5.838344785902235, "Min_10.0% Prob": 4.750498586230808, "Min_20.0% Prob": 3.259879311999759, "Min_30.0% Prob": 2.367893290839025, "Min_40.0% Prob": 1.8315166008472443, "Min_50.0% Prob": 1.4788891045733334, "Min_60.0% Prob": 1.2448901371597978}}
{"hexsha": "3e0ce1e812879c263dd5be267ffee55661505718", "ext": "rs", "lang": "Rust", "content": "pub fn send(socket: &std::net::UdpSocket, transmits: &[Transmit]) -> Result<usize> {\n        let mut sent = 0;\n        for transmit in transmits {\n            match socket.send_to(&transmit.contents, &transmit.destination) {\n                Ok(_) => {\n                    sent += 1;\n                }\n                Err(_) if sent != 0 => {\n                    // We need to report that some packets were sent in this case, so we rely on\n                    // errors being either harmlessly transient (in the case of WouldBlock) or\n                    // recurring on the next call.\n                    return Ok(sent);\n                }\n                Err(e) => {\n                    return Err(e);\n                }\n            }\n        }\n        Ok(sent)\n    }", "item_id": 0, "repo": "kpp/udp-socket", "file": "src/socket.rs", "last_update_at": "2022-02-12T11:23:43+00:00", "question_id": "3e0ce1e812879c263dd5be267ffee55661505718_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn send(socket: &std::net::UdpSocket, transmits: &[Transmit]) -> Result<usize> {\n        let mut sent = 0;\n        for transmit in transmits {\n            match socket.send_to(&transmit.contents, &transmit.destination) {\n                Ok(_) => {\n                    sent += 1;\n                }\n                Err(_) if sent != 0 => {\n                    // We need to report that some packets were sent in this case, so we rely on\n                    // errors being either harmlessly transient (in the case of WouldBlock) or\n                    // recurring on the next call.\n                    return Ok(sent);\n                }\n                Err(e) => {\n                    return Err(e);\n                }\n            }\n        }\n        Ok(sent)\n"]], "pred": {"ppl": 2.7026638984680176, "ppl_lower": 3.201105833053589, "ppl/lowercase_ppl": -1.1702393407011564, "ppl/zlib": 0.003021999743689856, "Min_5.0% Prob": 8.301440821753609, "Min_10.0% Prob": 6.396220182117663, "Min_20.0% Prob": 4.18738222733522, "Min_30.0% Prob": 3.111597949165409, "Min_40.0% Prob": 2.4305708653564695, "Min_50.0% Prob": 1.973188583146442, "Min_60.0% Prob": 1.6649026581543986}}
{"hexsha": "7a907a172847881dbf26c6ede66f2c73522f7f89", "ext": "rs", "lang": "Rust", "content": "fn test_initialize() {\n    let (_, api) = create_testkit(InitParam {\n        v_bit_len: vec![16],\n        is_acc2: true,\n        intra_index: true,\n        skip_list_max_level: 2,\n    });\n    let param = api.get_param();\n    assert_eq!(param.v_bit_len, vec![16]);\n    assert_eq!(param.acc_type, acc::Type::ACC2);\n    assert_eq!(param.use_sk, false);\n    assert_eq!(param.intra_index, true);\n    assert_eq!(param.skip_list_max_level, 2);\n}", "item_id": 1, "repo": "hkbudb/vchain-demo", "file": "vchain-exonum/src/tests.rs", "last_update_at": "2022-02-25T05:43:33+00:00", "question_id": "7a907a172847881dbf26c6ede66f2c73522f7f89_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_initialize() {\n    let (_, api) = create_testkit(InitParam {\n        v_bit_len: vec![16],\n        is_acc2: true,\n        intra_index: true,\n        skip_list_max_level: 2,\n    });\n    let param = api.get_param();\n    assert_eq!(param.v_bit_len, vec![16]);\n    assert_eq!(param.acc_type, acc::Type::ACC2);\n    assert_eq!(param.use_sk, false);\n    assert_eq!(param.intra_index, true);\n    assert_eq!(param.skip_list_max_level, 2);\n"]], "pred": {"ppl": 3.6523361206054688, "ppl_lower": 4.2034993171691895, "ppl/lowercase_ppl": -1.1085023423409113, "ppl/zlib": 0.00583498646803243, "Min_5.0% Prob": 8.53675401210785, "Min_10.0% Prob": 7.221485465764999, "Min_20.0% Prob": 5.499093106298735, "Min_30.0% Prob": 4.106613082885742, "Min_40.0% Prob": 3.2007803730110624, "Min_50.0% Prob": 2.5926655640027354, "Min_60.0% Prob": 2.1633040290694723}}
{"hexsha": "fa66a4903760d0893eca7c35bd266573e901b2b5", "ext": "rs", "lang": "Rust", "content": "fn dropped_update_action() {\n    let mut state = (DownlinkState::Synced, SharedValue::new(Value::from(13)));\n\n    let machine = unvalidated(Value::from(0));\n    let (action, _) = make_update();\n\n    let result = machine.handle_action_request(&mut state, action);\n\n    let (dl_state, data_state) = state;\n\n    assert!(result.is_ok());\n    let response = result.unwrap();\n\n    assert!(\n        matches!(response, Response{ event: Some(ev), command: Some(Command::Action(cmd)) } if *ev == *data_state && *cmd == *data_state)\n    );\n\n    assert_eq!(dl_state, DownlinkState::Synced);\n    assert_eq!(*data_state, Value::from(26));\n}", "item_id": 14, "repo": "swimos/swim-rust", "file": "swim_client/src/downlink/state_machine/value/tests.rs", "last_update_at": "2022-02-10T00:59:19+00:00", "question_id": "fa66a4903760d0893eca7c35bd266573e901b2b5_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn dropped_update_action() {\n    let mut state = (DownlinkState::Synced, SharedValue::new(Value::from(13)));\n    let machine = unvalidated(Value::from(0));\n    let (action, _) = make_update();\n    let result = machine.handle_action_request(&mut state, action);\n    let (dl_state, data_state) = state;\n    assert!(result.is_ok());\n    let response = result.unwrap();\n    assert!(\n        matches!(response, Response{ event: Some(ev), command: Some(Command::Action(cmd)) } if *ev == *data_state && *cmd == *data_state)\n    );\n    assert_eq!(dl_state, DownlinkState::Synced);\n    assert_eq!(*data_state, Value::from(26));\n"]], "pred": {"ppl": 4.647526264190674, "ppl_lower": 5.6027374267578125, "ppl/lowercase_ppl": -1.1216663042158692, "ppl/zlib": 0.0049241509354129775, "Min_5.0% Prob": 9.256585836410522, "Min_10.0% Prob": 7.743988132476806, "Min_20.0% Prob": 5.75745359862723, "Min_30.0% Prob": 4.514005872069812, "Min_40.0% Prob": 3.6149414530614528, "Min_50.0% Prob": 3.0074099138671277, "Min_60.0% Prob": 2.53701658062334}}
{"hexsha": "2d258eff0d2cd59939147908da5d87f11534bc63", "ext": "rs", "lang": "Rust", "content": "fn reestablish_channel_test() {\n        let msg_hex = \"\\\n            00880100000000000000000000000000000000000000000000000000000000000000000000000000\\\n            000b0000000000000002000200000000000000000000000000000000000000000000000000000000\\\n            0000031de8e2207c6ad1d81f5458c40b9cb1b519448ad67b00983e411ef522cbb187b6\";\n        let msg_bytes = hex::decode(msg_hex).unwrap();\n\n        let msg_correct = ReestablishChannel {\n            channel_id: ChannelId::from_hex(\"0100000000000000000000000000000000000000000000000000000000000000\").unwrap(),\n            next_local_commitment_number: 11,\n            next_remote_revocation_number: 2,\n            last_remote_commit_secret: u8_32_from_hex(\"0002000000000000000000000000000000000000000000000000000000000000\").unwrap(),\n            local_unrevoked_commit_point: RawPublicKey::from_hex(\"031de8e2207c6ad1d81f5458c40b9cb1b519448ad67b00983e411ef522cbb187b6\").unwrap(),\n        };\n        let wrapped_msg_correct = Message::ReestablishChannel(msg_correct);\n\n        let mut cursor = Cursor::new(msg_bytes.clone());\n        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();\n        assert_eq!(&msg, &wrapped_msg_correct);\n\n        // Now check deserialization\n        let mut new_msg_bytes = vec![];\n        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();\n        assert_eq!(new_msg_bytes, msg_bytes);\n    }", "item_id": 3, "repo": "LightningPeach/lpd", "file": "wire/src/message/channel/open.rs", "last_update_at": "2022-01-02T11:14:21+00:00", "question_id": "2d258eff0d2cd59939147908da5d87f11534bc63_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn reestablish_channel_test() {\n        let msg_hex = \"\\\n            00880100000000000000000000000000000000000000000000000000000000000000000000000000\\\n            000b0000000000000002000200000000000000000000000000000000000000000000000000000000\\\n            0000031de8e2207c6ad1d81f5458c40b9cb1b519448ad67b00983e411ef522cbb187b6\";\n        let msg_bytes = hex::decode(msg_hex).unwrap();\n        let msg_correct = ReestablishChannel {\n            channel_id: ChannelId::from_hex(\"0100000000000000000000000000000000000000000000000000000000000000\").unwrap(),\n            next_local_commitment_number: 11,\n            next_remote_revocation_number: 2,\n            last_remote_commit_secret: u8_32_from_hex(\"0002000000000000000000000000000000000000000000000000000000000000\").unwrap(),\n            local_unrevoked_commit_point: RawPublicKey::from_hex(\"031de8e2207c6ad1d81f5458c40b9cb1b519448ad67b00983e411ef522cbb187b6\").unwrap(),\n        };\n        let wrapped_msg_correct = Message::ReestablishChannel(msg_correct);\n        let mut cursor = Cursor::new(msg_bytes.clone());\n        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();\n        assert_eq!(&msg, &wrapped_msg_correct);\n        // Now check deserialization\n        let mut new_msg_bytes = vec![];\n        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();\n        assert_eq!(new_msg_bytes, msg_bytes);\n"]], "pred": {"ppl": 2.1244215965270996, "ppl_lower": 2.250462532043457, "ppl/lowercase_ppl": -1.0764913363030644, "ppl/zlib": 0.0015796636802020841, "Min_5.0% Prob": 6.815238148825509, "Min_10.0% Prob": 4.958569684498746, "Min_20.0% Prob": 3.4631976510437443, "Min_30.0% Prob": 2.4556120971278963, "Min_40.0% Prob": 1.871636425184322, "Min_50.0% Prob": 1.501352984384958, "Min_60.0% Prob": 1.254906647441695}}
{"hexsha": "513c01a10ce557423b902e4c7d2acbb446f4d2b2", "ext": "rs", "lang": "Rust", "content": "pub fn represent_into_bits(x: u64) -> Vec<u8> {\n        let mut result = Vec::with_capacity(64);\n        let mut x = x;\n        for _ in 0..64 {\n            let bit = x & 1;\n            let bit = bit as u8;\n            result.push(bit);\n            x >>= 1;\n        }\n        assert_eq!(result.len(), 64);\n        result\n    }", "item_id": 4, "repo": "Endle/rust-bundler-cp", "file": "tests/testdata/output/multiple_binaries.rs", "last_update_at": "2022-03-09T13:16:45+00:00", "question_id": "513c01a10ce557423b902e4c7d2acbb446f4d2b2_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn represent_into_bits(x: u64) -> Vec<u8> {\n        let mut result = Vec::with_capacity(64);\n        let mut x = x;\n        for _ in 0..64 {\n            let bit = x & 1;\n            let bit = bit as u8;\n            result.push(bit);\n            x >>= 1;\n        }\n        assert_eq!(result.len(), 64);\n        result\n"]], "pred": {"ppl": 2.176567792892456, "ppl_lower": 2.4833593368530273, "ppl/lowercase_ppl": -1.1695443476452103, "ppl/zlib": 0.004296957067347764, "Min_5.0% Prob": 8.959901809692383, "Min_10.0% Prob": 5.691518230871721, "Min_20.0% Prob": 3.384235874466274, "Min_30.0% Prob": 2.492809788269155, "Min_40.0% Prob": 1.9105396001883175, "Min_50.0% Prob": 1.5572357520853217, "Min_60.0% Prob": 1.2920142935346002}}
{"hexsha": "cc85375e5830f2356c9bb120240414a1336967f5", "ext": "rs", "lang": "Rust", "content": "pub fn decode(input: &str) -> String {\n    // convert encoded characters to indices from the b64 string\n    let mut indices = vec![];\n    for chara in input.chars() {\n        indices.push(get_b64_index(chara));\n    }\n\n    // convert the decimal indices to binary representation\n    let mut indices_bytes = vec![];\n    for index in indices {\n        indices_bytes.push(dec_to_bin(index as u8));\n    }\n\n    // pad the binary values if necessary\n    let mut bits_str = String::new();\n    for mut byte in indices_bytes {\n        if byte.len() < 6 {\n            let padding_amount = 6 - byte.len();\n            let mut padding = String::new();\n            for _i in 0..padding_amount {\n                padding += \"0\";\n            }\n            byte = format!(\"{}{}\", padding, byte);\n        }\n        bits_str += &byte;\n    }\n\n    // divide the binary string into bytes\n    let mut bytes = vec![];\n    while !bits_str.is_empty() {\n        if (bits_str.len()) >= 8 {\n            bytes.push(bits_str[0..8].to_string());\n            bits_str = (&bits_str[8..]).to_string();\n        } else {\n            bytes.push(bits_str.to_string());\n            String::clear(&mut bits_str);\n        }\n    }\n\n    // decode ascii bytes to characters in str\n    let mut decoded = String::new();\n    for byte in bytes {\n        decoded.push((binary_to_dec(&byte)) as char);\n    }\n\n    // return decoded String\n    decoded\n}", "item_id": 1, "repo": "gomihiko/b64rs", "file": "src/b64rs.rs", "last_update_at": "2022-02-21T22:18:29+00:00", "question_id": "cc85375e5830f2356c9bb120240414a1336967f5_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn decode(input: &str) -> String {\n    // convert encoded characters to indices from the b64 string\n    let mut indices = vec![];\n    for chara in input.chars() {\n        indices.push(get_b64_index(chara));\n    }\n    // convert the decimal indices to binary representation\n    let mut indices_bytes = vec![];\n    for index in indices {\n        indices_bytes.push(dec_to_bin(index as u8));\n    }\n    // pad the binary values if necessary\n    let mut bits_str = String::new();\n    for mut byte in indices_bytes {\n        if byte.len() < 6 {\n            let padding_amount = 6 - byte.len();\n            let mut padding = String::new();\n            for _i in 0..padding_amount {\n                padding += \"0\";\n            }\n            byte = format!(\"{}{}\", padding, byte);\n        }\n        bits_str += &byte;\n    }\n    // divide the binary string into bytes\n    let mut bytes = vec![];\n    while !bits_str.is_empty() {\n        if (bits_str.len()) >= 8 {\n            bytes.push(bits_str[0..8].to_string());\n            bits_str = (&bits_str[8..]).to_string();\n        } else {\n            bytes.push(bits_str.to_string());\n            String::clear(&mut bits_str);\n        }\n    }\n    // decode ascii bytes to characters in str\n    let mut decoded = String::new();\n    for byte in bytes {\n        decoded.push((binary_to_dec(&byte)) as char);\n    }\n    // return decoded String\n    decoded\n"]], "pred": {"ppl": 2.1834633350372314, "ppl_lower": 2.2322092056274414, "ppl/lowercase_ppl": -1.028273940901114, "ppl/zlib": 0.0014734194376822547, "Min_5.0% Prob": 6.796631313505626, "Min_10.0% Prob": 5.223176746141343, "Min_20.0% Prob": 3.440694043324107, "Min_30.0% Prob": 2.4986448763381865, "Min_40.0% Prob": 1.9257300495657892, "Min_50.0% Prob": 1.5543811443483546, "Min_60.0% Prob": 1.2996539264392581}}
{"hexsha": "86498bf9e5c8fae2b68cf194a1ad32d2c946040f", "ext": "rs", "lang": "Rust", "content": "pub fn i64_nullable_field(field_name: &str, data: &[Option<i64>], fields: &mut Vec<Field>, columns: &mut Vec<ArrayRef>) {\n    let mut builder = Int64Builder::new(data.len());\n    data.iter().for_each(|value| {\n        match value {\n            None => builder.append_null(),\n            Some(value) => builder.append_value(*value),\n        }\n            .expect(\"append data into builder failed\")\n    });\n    let array = builder.finish();\n    if array.null_count() < array.len() {\n        fields.push(Field::new(field_name, DataType::Int64, array.null_count() > 0));\n        columns.push(Arc::new(array));\n    }\n}", "item_id": 6, "repo": "lquerel/oltp-arrow", "file": "crates/trace/src/arrow/mod.rs", "last_update_at": "2022-02-01T22:51:42+00:00", "question_id": "86498bf9e5c8fae2b68cf194a1ad32d2c946040f_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn i64_nullable_field(field_name: &str, data: &[Option<i64>], fields: &mut Vec<Field>, columns: &mut Vec<ArrayRef>) {\n    let mut builder = Int64Builder::new(data.len());\n    data.iter().for_each(|value| {\n        match value {\n            None => builder.append_null(),\n            Some(value) => builder.append_value(*value),\n        }\n            .expect(\"append data into builder failed\")\n    });\n    let array = builder.finish();\n    if array.null_count() < array.len() {\n        fields.push(Field::new(field_name, DataType::Int64, array.null_count() > 0));\n        columns.push(Arc::new(array));\n    }\n"]], "pred": {"ppl": 2.3701424598693848, "ppl_lower": 3.098371744155884, "ppl/lowercase_ppl": -1.310477602566201, "ppl/zlib": 0.002630945313994075, "Min_5.0% Prob": 8.20538197623359, "Min_10.0% Prob": 5.979326210523906, "Min_20.0% Prob": 3.8537257665242906, "Min_30.0% Prob": 2.7902176723641863, "Min_40.0% Prob": 2.1390536415237413, "Min_50.0% Prob": 1.7216841372651885, "Min_60.0% Prob": 1.4468028639459003}}
{"hexsha": "1f1c81f7ac1a0489cb978eaa361e1509557cc9c8", "ext": "rs", "lang": "Rust", "content": "fn test_ec_aes_siv_test_vectors() {\n    tink_hybrid::init();\n    // These are the same test vectors used to test the c++ implementation in\n    // tink/cc/hybrid/ecies_aead_hkdf_hybrid_decrypt_test.cc.\n    struct TestCase {\n        name: &'static str,\n        key: &'static str,\n        ciphertext: &'static str,\n        context: &'static str,\n        plaintext: &'static str,\n    }\n    let test_vectors = vec![\n        TestCase {\n            name:       \"Empty plaintext\",\n            key:        \"32588172ed65830571bb83748f7fddd383323208a7825c80a71bef846333eb02\",\n            ciphertext: \"0401b11f8c9bafe30ae13f8bd15528714e752631a4328bf146009068e99489c8e9fae1ec39e3fe9994723711417fcab2af4b3c9b60117d47d33d35175c87b483b8935a73312940d1fbf8da3944a89b5e8b\",\n            context:    \"some context info\",\n            plaintext:  \"\",\n        },\n        TestCase{\n            name:       \"Small plaintext\",\n            key:        \"32588172ed65830571bb83748f7fddd383323208a7825c80a71bef846333eb02\",\n            ciphertext: \"040230023d1547b55af5a735a7f460722612126d7539d7cd0f677d308b29c6f52a964e66e7b0cb44cff1673df9e2c793f1477ca755807bfbeadcae1ab20b45ecb1501ca5e3f5b0626d3ca40aa5d010443d506e4df90b\",\n            context:    \"some context info\",\n            plaintext:  \"hello\",\n        },\n        TestCase{\n            name:       \"Large plaintext\",\n            key:        \"32588172ed65830571bb83748f7fddd383323208a7825c80a71bef846333eb02\",\n            ciphertext: \"0441ddd246cea0825bd68bddff05cec54a4ee678da35b2f5cfbbb32e5350bdd817214bfb7b5ed5528131bde56916062cfbd8b9952d9e0907a6e87e1de54db5df3aaccddd328efcf7771ce061e647488f66b8c11a9fca171dcff813e90b44b2739573f9f23b60202491870c7ff8aaf0ae46838e48f17f8dc1ad55b67809699dd31eb6ca50dfa9beeee32d30bdc00a1eb1d8b0cbcedbe50b1e24619cc5e79042f25f49e2c2d5a35c79e833c0d68e31a93da4173aacd0428b367594ed4636763d16c23e4f8c115d44bddc83bcefcaea13587238ce8b7a5d5fad53beeb59aaa1d7483eb4bac93ed50ed4d3e9fd5af760283fd38080b58744b73212a36039179ce6f96ef1ecaa05b5186967d81c06b9cd91140dfbd54084ddcfd941527719848a2eecb84278f6a0fe9357a3964f87222fcd16a12a353e1f64fd45dc227a4a2112da6f61269f22f16b41e68eadf0b6b3a48c67b9e7e3ec1c66eecce50dda8ecbce99d3778299aa28741b7247fbc46a1b8a908dc23943c2dd17210a270bb12b096c2c6a00400a95c62894a15b9fc44e709d27348f2f2644a786cd9e96caf42ea9b949f76e85e6f7365e15fa2902e851222c025f6c208269d799fcfc4c0b37aba8979ed9e6ccf543c217ee0b6ad05f0e3ffb92943d308c801b25efedab5bf93a733bdae611132d774d4b9ee4fb5e88ae63014315ae9571039a8c8c7020e2b3a1bbd4235b65af94771c8417c87fd6cab423b82a557f60a99ae7402dba205e05136dd34f0026fce87899d4b9819cc2b2ba686512d62c41a1e3a667a705ea45404aafa489cd7f53f42455fff3f9b22f960d12a2587efd6ed0fa3e00dd4645face1b2f1268e6019be70999eab00f0aeff3cb0e77b7c4a1ab1fdf15d00c4eedd7b75e8cf5c90119346894089ee0299d58f1d7ebac9b592da2325a5a738ea2baecc1468670f5aec880bce32efecfb2a7c5ad3ae4096b0a07aa9bfe6cbaf53da6757377bb692e55ec8caf5f0af28dafdc42e1d6e5893140945a853f56652c575b99d64399aad2d042948575134c8fe638fb0b80ac3a0f08a60f3aa817fe0a24c1fffee6933bd72ea460e0b241d3f5d98b2321ee25d8c0302353fcfd41bce964d73ff670422864506cc56f3470362c90144586ccbfc8e5e6fefbb70429b0a517e4b1badb449cd11092790aba6e19b914899872f4fb481c8dc47a33422fc05072ac99c958e40dae53d96ebd87cfbde67a0f050203a89e487da5e03364951830e43771d36abfbe8f5a7da8e7aa891f36a68dbe9a3b0e3dfbd1afd6327a3ced4a5cd8a5b256fef46d200df4af2e2da4dbb786ea0404bb968b6d961e4fc76f89e70ad7c9e11d6aee6526b75b399811f73c053a29582ba9295ea4d5a8fffb5a8ccbac008d291dd60e2041371acfc4c432a0ae0fcd8fa25c9551123c95da64caa134edaee5893e19c3c76075bef419c09681a67f4ede6f28d747b53afd61ddc937d7de96a22c7db10ad8700cade888de5d6f450c15d796978ddb5e6a52e5044e90247c988686d992105c85f6d198e2de859330f973ded4d7e5d90de57051dbaf0db0febd4cf9d44da155e55293b0930f89c1d21cc227eba9615ca47cce41d16eaddb5bf5dc9bc8477df5cf21f460b83241e7d0fa3707f9d2b322b9aaa42747d0653168b095ca0a83f38426688f6f10143cbd1b84c08583b09ed6192c7366ecc23af528fc2e8c585560f9bd0fcc255b82fc70723a92506bb475ebc1f5ae34a902bf2aa75997ed90a54762c8e83720833b2fd607eee1beb347a75d3bd0f174ed450a72cce79f1be426de9d6f1a6feff052674af141b3cea89f8e749118392e9533c62ddad870e60d509fd7abfa0bc33c2774b29a0170089b30d82047d6e130c49f6965f9871d1928b7f13e3e40ad8e3dc85195f4b312f9f6d8e4158aca23a611f6c6c798983555139942536f6ac59bbd6cc88b9933f22e81429e835bfd4fec27c67520d64a0ad8fd7feb6a3fbe52dc56cbbf59644b0fad0c462ed02ffbf7258e4b94bdedefb187fbdb729a0d56a36e876ac76de766eed416f39ab4e8b1982b8d0a87cd33182ae81ecf1d1d5202cc3e82c5762646d15db5f13cde3e81c83715195f9af9f27e01e1829ce529fa0f715db1f5d227bb201c7c127ea8d0e9c21739c7e9c6a0d8d5a1aaea5216c549f3715f889e583555ac1bfd77339f3eff1bee75ee2fc45457f5c3ffe9401b8b67f5bb3f305f3269fe6153ba34de3fa90016c76811cd54b4b49b17b244b1a4f6edfa2eaf46e2819aded26005b4ed712e8b700ae7b6123fa2c179640ee523f864360d116ee243f13c66d2cd61d422709648d905ab17edf0d0075d2fed443889e15344069b69b2d3d8273f197f8468baf167074bf6dfdeea5871f0c0652ab2801f394ef6fbf841e8072c8bf65026d85d441ca61e78785a2e7ca1e743640fecd6dfad8b77adcbb8bcb8ce8532ad0cd8b3e51269c26ad037545273f756c1a5511925408a5045af469ca947f9a3f5457bcc325d05291a192abe75b4da7c97a61adc2fa247984edb5a03285f1c3b99f13f6a22f007029faffdd38b62f7bf909ce602e4e06ab1ec4543013d354d0dd86d8933a53c17ead02faf0cc740d7191fe475be2f7940c234f8c73420774a7213fd2a477847527172c02a54928de5fde5f15616760e6f7ff3c03a233aec880a939d9f1ca68be7f474fd13184fe8f6deb0c4ea01617ea207d5d765d067fddba58b94f3b59d5996e9f5434f483e2f0079c48050f3ba941b589294c41a0f350451d566fe58a9c9688cc3a75da314ff4b3473eeac58664c5922ae4efae850fe0f7f11dcc089bc0b4df9a64547a35b2559f4a4a3e7d3782d850997baa589534921becde8dc3f76380ae36bd9730956aae9f59b121d8ae4dbbc586c6b45ad9d5c17cf6821b746177bc9fcb727db3f4aa190688c48826421de5ebcd429e0d9b479e66e676e8f9a3b4bd92621f47357a7b1b27942121f5a6e0087e4192a5f8cf4da942cc9d86eac5e\",\n            context:    \"some context info\",\n            plaintext:  \"08b8b2b733424243760fe426a4b54908632110a66c2f6591eabd3345e3e4eb98fa6e264bf09efe12ee50f8f54e9f77b1e355f6c50544e23fb1433ddf73be84d879de7c0046dc4996d9e773f4bc9efe5738829adb26c81b37c93a1b270b20329d658675fc6ea534e0810a4432826bf58c941efb65d57a338bbd2e26640f89ffbc1a858efcb8550ee3a5e1998bd177e93a7363c344fe6b199ee5d02e82d522c4feba15452f80288a821a579116ec6dad2b3b310da903401aa62100ab5d1a36553e06203b33890cc9b832f79ef80560ccb9a39ce767967ed628c6ad573cb116dbefefd75499da96bd68a8a97b928a8bbc103b6621fcde2beca1231d206be6cd9ec7aff6f6c94fcd7204ed3455c68c83f4a41da4af2b74ef5c53f1d8ac70bdcb7ed185ce81bd84359d44254d95629e9855a94a7c1958d1f8ada5d0532ed8a5aa3fb2d17ba70eb6248e594e1a2297acbbb39d502f1a8c6eb6f1ce22b3de1a1f40cc24554119a831a9aad6079cad88425de6bde1a9187ebb6092cf67bf2b13fd65f27088d78b7e883c8759d2c4f5c65adb7553878ad575f9fad878e80a0c9ba63bcbcc2732e69485bbc9c90bfbd62481d9089beccf80cfe2df16a2cf65bd92dd597b0707e0917af48bbb75fed413d238f5555a7a569d80c3414a8d0859dc65a46128bab27af87a71314f318c782b23ebfe808b82b0ce26401d2e22f04d83d1255dc51addd3b75a2b1ae0784504df543af8969be3ea7082ff7fc9888c144da2af58429ec96031dbcad3dad9af0dcbaaaf268cb8fcffead94f3c7ca495e056a9b47acdb751fb73e666c6c655ade8297297d07ad1ba5e43f1bca32301651339e22904cc8c42f58c30c04aafdb038dda0847dd988dcda6f3bfd15c4b4c4525004aa06eeff8ca61783aacec57fb3d1f92b0fe2fd1a85f6724517b65e614ad6808d6f6ee34dff7310fdc82aebfd904b01e1dc54b2927094b2db68d6f903b68401adebf5a7e08d78ff4ef5d63653a65040cf9bfd4aca7984a74d37145986780fc0b16ac451649de6188a7dbdf191f64b5fc5e2ab47b57f7f7276cd419c17a3ca8e1b939ae49e488acba6b965610b5480109c8b17b80e1b7b750dfc7598d5d5011fd2dcc5600a32ef5b52a1ecc820e308aa342721aac0943bf6686b64b2579376504ccc493d97e6aed3fb0f9cd71a43dd497f01f17c0e2cb3797aa2a2f256656168e6c496afc5fb93246f6b1116398a346f1a641f3b041e989f7914f90cc2c7fff357876e506b50d334ba77c225bc307ba537152f3f1610e4eafe595f6d9d90d11faa933a15ef1369546868a7f3a45a96768d40fd9d03412c091c6315cf4fde7cb68606937380db2eaaa707b4c4185c32eddcdd306705e4dc1ffc872eeee475a64dfac86aba41c0618983f8741c5ef68d3a101e8a3b8cac60c905c15fc910840b94c00a0b9d0\",\n        },\n    ];\n    for tv in test_vectors {\n        let key = hex::decode(&tv.key).unwrap();\n        let ct = hex::decode(&tv.ciphertext).unwrap();\n        let ctx = tv.context.as_bytes();\n        let pt = tv.plaintext.as_bytes();\n\n        let curve = EllipticCurveType::NistP256;\n        let pvt = tink_hybrid::subtle::EcPrivateKey::new(curve, &key).unwrap();\n        let salt = Vec::new();\n        let helper = tink_hybrid::EciesAeadHkdfDemHelper::new(&tink_daead::aes_siv_key_template())\n            .expect(\"error generating a DEM helper\");\n        let d = tink_hybrid::subtle::EciesAeadHkdfHybridDecrypt::new(\n            pvt,\n            &salt,\n            HashType::Sha256,\n            EcPointFormat::Uncompressed,\n            helper,\n        )\n        .expect(\"error generating an decryption construct\");\n        let dt = d.decrypt(&ct, ctx).expect(\"decryption error\");\n        assert_eq!(\n            dt, pt,\n            \"{}: Decryption did not match test vector's plaintext\",\n            tv.name\n        );\n    }\n}", "item_id": 4, "repo": "daviddrysdale/tink-rust", "file": "tests/tests/hybrid/ecies_aead_hkdf_hybrid_decrypt_test.rs", "last_update_at": "2022-03-14T01:04:34+00:00", "question_id": "1f1c81f7ac1a0489cb978eaa361e1509557cc9c8_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_ec_aes_siv_test_vectors() {\n    tink_hybrid::init();\n    // These are the same test vectors used to test the c++ implementation in\n    // tink/cc/hybrid/ecies_aead_hkdf_hybrid_decrypt_test.cc.\n    struct TestCase {\n        name: &'static str,\n        key: &'static str,\n        ciphertext: &'static str,\n        context: &'static str,\n        plaintext: &'static str,\n    }\n    let test_vectors = vec![\n        TestCase {\n            name:       \"Empty plaintext\",\n            key:        \"32588172ed65830571bb83748f7fddd383323208a7825c80a71bef846333eb02\",\n            ciphertext: \"0401b11f8c9bafe30ae13f8bd15528714e752631a4328bf146009068e99489c8e9fae1ec39e3fe9994723711417fcab2af4b3c9b60117d47d33d35175c87b483b8935a73312940d1fbf8da3944a89b5e8b\",\n            context:    \"some context info\",\n            plaintext:  \"\",\n        },\n        TestCase{\n            name:       \"Small plaintext\",\n            key:        \"32588172ed65830571bb83748f7fddd383323208a7825c80a71bef846333eb02\",\n            ciphertext: \"040230023d1547b55af5a735a7f460722612126d7539d7cd0f677d308b29c6f52a964e66e7b0cb44cff1673df9e2c793f1477ca755807bfbeadcae1ab20b45ecb1501ca5e3f5b0626d3ca40aa5d010443d506e4df90b\",\n            context:    \"some context info\",\n            plaintext:  \"hello\",\n        },\n        TestCase{\n            name:       \"Large plaintext\",\n            key:        \"32588172ed65830571bb83748f7fddd383323208a7825c80a71bef846333eb02\",\n            ciphertext: \"0441ddd246cea0825bd68bddff05cec54a4ee678da35b2f5cfbbb32e5350bdd817214bfb7b5ed5528131bde56916062cfbd8b9952d9e0907a6e87e1de54db5df3aaccddd328efcf7771ce061e647488f66b8c11a9fca171dcff813e90b44b2739573f9f23b60202491870c7ff8aaf0ae46838e48f17f8dc1ad55b67809699dd31eb6ca50dfa9beeee32d30bdc00a1eb1d8b0cbcedbe50b1e24619cc5e79042f25f49e2c2d5a35c79e833c0d68e31a93da4173aacd0428b367594ed4636763d16c23e4f8c115d44bddc83bcefcaea13587238ce8b7a5d5fad53beeb59aaa1d7483eb4bac93ed50ed4d3e9fd5af760283fd38080b58744b73212a36039179ce6f96ef1ecaa05b5186967d81c06b9cd91140dfbd54084ddcfd941527719848a2eecb84278f6a0fe9357a3964f87222fcd16a12a353e1f64fd45dc227a4a2112da6f61269f22f16b41e68eadf0b6b3a48c67b9e7e3ec1c66eecce50dda8ecbce99d3778299aa28741b7247fbc46a1b8a908dc23943c2dd17210a270bb12b096c2c6a00400a95c62894a15b9fc44e709d27348f2f2644a786cd9e96caf42ea9b949f76e85e6f7365e15fa2902e851222c025f6c208269d799fcfc4c0b37aba8979ed9e6ccf543c217ee0b6ad05f0e3ffb92943d308c801b25efedab5bf93a733bdae611132d774d4b9ee4fb5e88ae63014315ae9571039a8c8c7020e2b3a1bbd4235b65af94771c8417c87fd6cab423b82a557f60a99ae7402dba205e05136dd34f0026fce87899d4b9819cc2b2ba686512d62c41a1e3a667a705ea45404aafa489cd7f53f42455fff3f9b22f960d12a2587efd6ed0fa3e00dd4645face1b2f1268e6019be70999eab00f0aeff3cb0e77b7c4a1ab1fdf15d00c4eedd7b75e8cf5c90119346894089ee0299d58f1d7ebac9b592da2325a5a738ea2baecc1468670f5aec880bce32efecfb2a7c5ad3ae4096b0a07aa9bfe6cbaf53da6757377bb692e55ec8caf5f0af28dafdc42e1d6e5893140945a853f56652c575b99d64399aad2d042948575134c8fe638fb0b80ac3a0f08a60f3aa817fe0a24c1fffee6933bd72ea460e0b241d3f5d98b2321ee25d8c0302353fcfd41bce964d73ff670422864506cc56f3470362c90144586ccbfc8e5e6fefbb70429b0a517e4b1badb449cd11092790aba6e19b914899872f4fb481c8dc47a33422fc05072ac99c958e40dae53d96ebd87cfbde67a0f050203a89e487da5e03364951830e43771d36abfbe8f5a7da8e7aa891f36a68dbe9a3b0e3dfbd1afd6327a3ced4a5cd8a5b256fef46d200df4af2e2da4dbb786ea0404bb968b6d961e4fc76f89e70ad7c9e11d6aee6526b75b399811f73c053a29582ba9295ea4d5a8fffb5a8ccbac008d291dd60e2041371acfc4c432a0ae0fcd8fa25c9551123c95da64caa134edaee5893e19c3c76075bef419c09681a67f4ede6f28d747b53afd61ddc937d7de96a22c7db10ad8700cade888de5d6f450c15d796978ddb5e6a52e5044e90247c988686d992105c85f6d198e2de859330f973ded4d7e5d90de57051dbaf0db0febd4cf9d44da155e55293b0930f89c1d21cc227eba9615ca47cce41d16eaddb5bf5dc9bc8477df5cf21f460b83241e7d0fa3707f9d2b322b9aaa42747d0653168b095ca0a83f38426688f6f10143cbd1b84c08583b09ed6192c7366ecc23af528fc2e8c585560f9bd0fcc255b82fc70723a92506bb475ebc1f5ae34a902bf2aa75997ed90a54762c8e83720833b2fd607eee1beb347a75d3bd0f174ed450a72cce79f1be426de9d6f1a6feff052674af141b3cea89f8e749118392e9533c62ddad870e60d509fd7abfa0bc33c2774b29a0170089b30d82047d6e130c49f6965f9871d1928b7f13e3e40ad8e3dc85195f4b312f9f6d8e4158aca23a611f6c6c798983555139942536f6ac59bbd6cc88b9933f22e81429e835bfd4fec27c67520d64a0ad8fd7feb6a3fbe52dc56cbbf59644b0fad0c462ed02ffbf7258e4b94bdedefb187fbdb729a0d56a36e876ac76de766eed416f39ab4e8b1982b8d0a87cd33182ae81ecf1d1d5202cc3e82c5762646d15db5f13cde3e81c83715195f9af9f27e01e1829ce529fa0f715db1f5d227bb201c7c127ea8d0e9c21739c7e9c6a0d8d5a1aaea5216c549f3715f889e583555ac1bfd77339f3eff1bee75ee2fc45457f5c3ffe9401b8b67f5bb3f305f3269fe6153ba34de3fa90016c76811cd54b4b49b17b244b1a4f6edfa2eaf46e2819aded26005b4ed712e8b700ae7b6123fa2c179640ee523f864360d116ee243f13c66d2cd61d422709648d905ab17edf0d0075d2fed443889e15344069b69b2d3d8273f197f8468baf167074bf6dfdeea5871f0c0652ab2801f394ef6fbf841e8072c8bf65026d85d441ca61e78785a2e7ca1e743640fecd6dfad8b77adcbb8bcb8ce8532ad0cd8b3e51269c26ad037545273f756c1a5511925408a5045af469ca947f9a3f5457bcc325d05291a192abe75b4da7c97a61adc2fa247984edb5a03285f1c3b99f13f6a22f007029faffdd38b62f7bf909ce602e4e06ab1ec4543013d354d0dd86d8933a53c17ead02faf0cc740d7191fe475be2f7940c234f8c73420774a7213fd2a477847527172c02a54928de5fde5f15616760e6f7ff3c03a233aec880a939d9f1ca68be7f474fd13184fe8f6deb0c4ea01617ea207d5d765d067fddba58b94f3b59d5996e9f5434f483e2f0079c48050f3ba941b589294c41a0f350451d566fe58a9c9688cc3a75da314ff4b3473eeac58664c5922ae4efae850fe0f7f11dcc089bc0b4df9a64547a35b2559f4a4a3e7d3782d850997baa589534921becde8dc3f76380ae36bd9730956aae9f59b121d8ae4dbbc586c6b45ad9d5c17cf6821b746177bc9fcb727db3f4aa190688c48826421de5ebcd429e0d9b479e66e676e8f9a3b4bd92621f47357a7b1b27942121f5a6e0087e4192a5f8cf4da942cc9d86eac5e\",\n            context:    \"some context info\",\n            plaintext:  \"08b8b2b733424243760fe426a4b54908632110a66c2f6591eabd3345e3e4eb98fa6e264bf09efe12ee50f8f54e9f77b1e355f6c50544e23fb1433ddf73be84d879de7c0046dc4996d9e773f4bc9efe5738829adb26c81b37c93a1b270b20329d658675fc6ea534e0810a4432826bf58c941efb65d57a338bbd2e26640f89ffbc1a858efcb8550ee3a5e1998bd177e93a7363c344fe6b199ee5d02e82d522c4feba15452f80288a821a579116ec6dad2b3b310da903401aa62100ab5d1a36553e06203b33890cc9b832f79ef80560ccb9a39ce767967ed628c6ad573cb116dbefefd75499da96bd68a8a97b928a8bbc103b6621fcde2beca1231d206be6cd9ec7aff6f6c94fcd7204ed3455c68c83f4a41da4af2b74ef5c53f1d8ac70bdcb7ed185ce81bd84359d44254d95629e9855a94a7c1958d1f8ada5d0532ed8a5aa3fb2d17ba70eb6248e594e1a2297acbbb39d502f1a8c6eb6f1ce22b3de1a1f40cc24554119a831a9aad6079cad88425de6bde1a9187ebb6092cf67bf2b13fd65f27088d78b7e883c8759d2c4f5c65adb7553878ad575f9fad878e80a0c9ba63bcbcc2732e69485bbc9c90bfbd62481d9089beccf80cfe2df16a2cf65bd92dd597b0707e0917af48bbb75fed413d238f5555a7a569d80c3414a8d0859dc65a46128bab27af87a71314f318c782b23ebfe808b82b0ce26401d2e22f04d83d1255dc51addd3b75a2b1ae0784504df543af8969be3ea7082ff7fc9888c144da2af58429ec96031dbcad3dad9af0dcbaaaf268cb8fcffead94f3c7ca495e056a9b47acdb751fb73e666c6c655ade8297297d07ad1ba5e43f1bca32301651339e22904cc8c42f58c30c04aafdb038dda0847dd988dcda6f3bfd15c4b4c4525004aa06eeff8ca61783aacec57fb3d1f92b0fe2fd1a85f6724517b65e614ad6808d6f6ee34dff7310fdc82aebfd904b01e1dc54b2927094b2db68d6f903b68401adebf5a7e08d78ff4ef5d63653a65040cf9bfd4aca7984a74d37145986780fc0b16ac451649de6188a7dbdf191f64b5fc5e2ab47b57f7f7276cd419c17a3ca8e1b939ae49e488acba6b965610b5480109c8b17b80e1b7b750dfc7598d5d5011fd2dcc5600a32ef5b52a1ecc820e308aa342721aac0943bf6686b64b2579376504ccc493d97e6aed3fb0f9cd71a43dd497f01f17c0e2cb3797aa2a2f256656168e6c496afc5fb93246f6b1116398a346f1a641f3b041e989f7914f90cc2c7fff357876e506b50d334ba77c225bc307ba537152f3f1610e4eafe595f6d9d90d11faa933a15ef1369546868a7f3a45a96768d40fd9d03412c091c6315cf4fde7cb68606937380db2eaaa707b4c4185c32eddcdd306705e4dc1ffc872eeee475a64dfac86aba41c0618983f8741c5ef68d3a101e8a3b8cac60c905c15fc910840b94c00a0b9d0\",\n        },\n    ];\n    for tv in test_vectors {\n        let key = hex::decode(&tv.key).unwrap();\n        let ct = hex::decode(&tv.ciphertext).unwrap();\n        let ctx = tv.context.as_bytes();\n        let pt = tv.plaintext.as_bytes();\n        let curve = EllipticCurveType::NistP256;\n        let pvt = tink_hybrid::subtle::EcPrivateKey::new(curve, &key).unwrap();\n        let salt = Vec::new();\n        let helper = tink_hybrid::EciesAeadHkdfDemHelper::new(&tink_daead::aes_siv_key_template())\n            .expect(\"error generating a DEM helper\");\n        let d = tink_hybrid::subtle::EciesAeadHkdfHybridDecrypt::new(\n            pvt,\n            &salt,\n            HashType::Sha256,\n            EcPointFormat::Uncompressed,\n            helper,\n        )\n        .expect(\"error generating an decryption construct\");\n        let dt = d.decrypt(&ct, ctx).expect(\"decryption error\");\n        assert_eq!(\n            dt, pt,\n            \"{}: Decryption did not match test vector's plaintext\",\n            tv.name\n        );\n    }\n"]], "pred": {"ppl": 8.30459213256836, "ppl_lower": 8.433390617370605, "ppl/lowercase_ppl": -1.0072705055157989, "ppl/zlib": 0.0004479070314832495, "Min_5.0% Prob": 6.3182206901849485, "Min_10.0% Prob": 5.703420038316764, "Min_20.0% Prob": 4.471807995263268, "Min_30.0% Prob": 3.9480482230778615, "Min_40.0% Prob": 3.654091104610042, "Min_50.0% Prob": 3.464530244965376, "Min_60.0% Prob": 3.2974968240467213}}
{"hexsha": "cfb3a96a647bb99322d2148319a8c351b42fe18a", "ext": "rs", "lang": "Rust", "content": "fn block_invalidated() {\n    let data = vec![Node::new(\"Camper\")];\n    let mut fix_node_state = fix(data);\n    fix_node_state.transactions[0].event = Events::BlockInvalidated;\n    let (chain, _) = mine(fix_node_state).expect(\"result to be chain\");\n    assert_eq!(chain.get_last_block().unwrap().data[0].racks, 0);\n    assert_eq!(chain.get_last_block().unwrap().data[0].tokens, 19);\n    assert_eq!(chain.get_last_block().unwrap().data[0].reputation, 0);\n}", "item_id": 2, "repo": "ShaunSHamilton/proof-of-stake", "file": "blockchain/tests/handle_mine.rs", "last_update_at": "2022-03-10T14:58:42+00:00", "question_id": "cfb3a96a647bb99322d2148319a8c351b42fe18a_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn block_invalidated() {\n    let data = vec![Node::new(\"Camper\")];\n    let mut fix_node_state = fix(data);\n    fix_node_state.transactions[0].event = Events::BlockInvalidated;\n    let (chain, _) = mine(fix_node_state).expect(\"result to be chain\");\n    assert_eq!(chain.get_last_block().unwrap().data[0].racks, 0);\n    assert_eq!(chain.get_last_block().unwrap().data[0].tokens, 19);\n    assert_eq!(chain.get_last_block().unwrap().data[0].reputation, 0);\n"]], "pred": {"ppl": 4.97163724899292, "ppl_lower": 5.509806156158447, "ppl/lowercase_ppl": -1.0640874702704362, "ppl/zlib": 0.006853629112035526, "Min_5.0% Prob": 10.155959010124207, "Min_10.0% Prob": 8.408335626125336, "Min_20.0% Prob": 6.242952331900597, "Min_30.0% Prob": 4.862530057628949, "Min_40.0% Prob": 3.858949908055365, "Min_50.0% Prob": 3.1688382767140864, "Min_60.0% Prob": 2.6723957827780396}}
{"hexsha": "04f0a8a0a6f6af3c07c0da8c6821d9c100eb1ad5", "ext": "rs", "lang": "Rust", "content": "fn parse_coordinate(input: &[u8]) -> IResult<&[u8], Coords> {\n    use nom::character::complete::char;\n    use nom::character::complete::u16;\n\n    separated_pair(u16, char(','), u16)(input)\n}", "item_id": 1, "repo": "bertptrs/adventofcode", "file": "2021/src/day13.rs", "last_update_at": "2022-01-27T22:31:11+00:00", "question_id": "04f0a8a0a6f6af3c07c0da8c6821d9c100eb1ad5_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_coordinate(input: &[u8]) -> IResult<&[u8], Coords> {\n    use nom::character::complete::char;\n    use nom::character::complete::u16;\n    separated_pair(u16, char(','), u16)(input)\n"]], "pred": {"ppl": 2.419837713241577, "ppl_lower": 3.1157820224761963, "ppl/lowercase_ppl": -1.286046800369405, "ppl/zlib": 0.0063121462662568085, "Min_5.0% Prob": 8.402753035227457, "Min_10.0% Prob": 5.994652782167707, "Min_20.0% Prob": 4.163946219852993, "Min_30.0% Prob": 2.939524376676196, "Min_40.0% Prob": 2.247395715809294, "Min_50.0% Prob": 1.7619709772989154, "Min_60.0% Prob": 1.4778150670923467}}
{"hexsha": "c037d3f6c1a8155a53172de89fcd272070a3b257", "ext": "rs", "lang": "Rust", "content": "fn generate_mnt6_spec_params<FE: ElementRepr>(\n    modulus: BigUint, \n    a: BigUint,\n    b: BigUint,\n    main_subgroup_order: BigUint,\n    fp_non_residue: BigUint,\n    generator_g1_x: BigUint,\n    generator_g1_y: BigUint,\n    generator_g2_x_0: BigUint,\n    generator_g2_x_1: BigUint,\n    generator_g2_x_2: BigUint,\n    generator_g2_y_0: BigUint,\n    generator_g2_y_1: BigUint,\n    generator_g2_y_2: BigUint,\n    ate_loop_scalar: BigUint,\n    ate_loop_scalar_is_negative: bool,\n    final_exp_scalar: BigUint,\n    w0_exp_scalar: BigUint,\n    w0_exp_scalar_is_negative: bool,\n    w1_exp_scalar: BigUint,\n) {\n    let modulus_uint = MaxFieldUint::from_big_endian(&modulus.to_bytes_be());\n    let field = field_from_modulus::<FE>(&modulus_uint).unwrap();\n    let a_fp = Fp::from_be_bytes(&field, &a.to_bytes_be(), true).unwrap();\n    let b_fp = Fp::from_be_bytes(&field, &b.to_bytes_be(), true).unwrap();\n    let fp_non_residue = Fp::from_be_bytes(&field, &fp_non_residue.to_bytes_be(), true).unwrap();\n    let extension_3 = Extension3::new(fp_non_residue.clone());\n\n    let one = Fp::one(&field);\n\n    let mut twist = Fp3::zero(&extension_3);\n    twist.c1 = one.clone();\n\n    let mut twist_squared = twist.clone();\n    twist_squared.square();\n\n    let mut twist_cubed = twist_squared.clone();\n    twist_cubed.mul_assign(&twist);\n\n    let mut a_fp3 = twist_squared.clone();\n    a_fp3.mul_by_fp(&a_fp);\n\n    let mut b_fp3 = twist_cubed.clone();\n    b_fp3.mul_by_fp(&b_fp);\n\n\n    let g1_generator_x = Fp::from_be_bytes(&field, &generator_g1_x.to_bytes_be(), true).unwrap();\n    let g1_generator_y = Fp::from_be_bytes(&field, &generator_g1_y.to_bytes_be(), true).unwrap();\n\n    let g1_generator_x_c0 = Fp::from_be_bytes(&field, &generator_g2_x_0.to_bytes_be(), true).unwrap();\n    let g1_generator_x_c1 = Fp::from_be_bytes(&field, &generator_g2_x_1.to_bytes_be(), true).unwrap();\n    let g1_generator_x_c2 = Fp::from_be_bytes(&field, &generator_g2_x_2.to_bytes_be(), true).unwrap();\n    let g1_generator_y_c0 = Fp::from_be_bytes(&field, &generator_g2_y_0.to_bytes_be(), true).unwrap();\n    let g1_generator_y_c1 = Fp::from_be_bytes(&field, &generator_g2_y_1.to_bytes_be(), true).unwrap();\n    let g1_generator_y_c2 = Fp::from_be_bytes(&field, &generator_g2_y_2.to_bytes_be(), true).unwrap();\n    println!(\"Weierstrass curve parameters with k=6\");\n    println!(\"Base field modulus = {}\", field.modulus());\n    println!(\"A coefficient = {}\", a_fp);\n    println!(\"B coefficient = {}\", b_fp);\n    println!(\"Main subgroup order = 0x{}\", main_subgroup_order.to_str_radix(16));\n\n    println!(\"Extension tower:\");\n    println!(\"Fp3 construction:\");\n    println!(\"Fp cubic non-residue = {}\", fp_non_residue);\n\n    println!(\"A coefficient for twist c0 = {}\", a_fp3.c0);\n    println!(\"A coefficient for twist c1 = {}\", a_fp3.c1);\n    println!(\"A coefficient for twist c2 = {}\", a_fp3.c2);\n\n    println!(\"B coefficient for twist c0 = {}\", b_fp3.c0);\n    println!(\"B coefficient for twist c1 = {}\", b_fp3.c1);\n    println!(\"B coefficient for twist c2 = {}\", b_fp3.c2);\n\n    println!(\"Generators:\");\n    println!(\"G1:\");\n    println!(\"X = {}\", g1_generator_x);\n    println!(\"Y = {}\", g1_generator_y);\n\n    println!(\"G2:\");\n    println!(\"X c0 = {}\", g1_generator_x_c0);\n    println!(\"X c1 = {}\", g1_generator_x_c1);\n    println!(\"X c2 = {}\", g1_generator_x_c2);\n    println!(\"Y c0 = {}\", g1_generator_y_c0);\n    println!(\"Y c1 = {}\", g1_generator_y_c1);\n    println!(\"Y c2 = {}\", g1_generator_y_c2);\n\n    println!(\"Pairing parameters:\");\n    println!(\"|ate_loop_scalar| (miller loop scalar) = 0x{}\", ate_loop_scalar.to_str_radix(16));\n    println!(\"ate_loop_scalar is negative = {}\", ate_loop_scalar_is_negative);\n\n    println!(\"final_exp_scalar (final exponentiation power) = 0x{}\", final_exp_scalar.to_str_radix(16));\n\n    println!(\"Breaking final exponentiation hard part into the two parts (usually labeled w0 and w1)\");\n\n    println!(\"|w0| = 0x{}\", w0_exp_scalar.to_str_radix(16));\n    println!(\"w0 is negative = {}\", w0_exp_scalar_is_negative);\n\n    println!(\"|w1| = 0x{}\", w1_exp_scalar.to_str_radix(16));\n}", "item_id": 0, "repo": "litezk/eip1962", "file": "src/test/spec_generator/mnt6.rs", "last_update_at": "2022-03-09T07:01:38+00:00", "question_id": "c037d3f6c1a8155a53172de89fcd272070a3b257_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn generate_mnt6_spec_params<FE: ElementRepr>(\n    modulus: BigUint, \n    a: BigUint,\n    b: BigUint,\n    main_subgroup_order: BigUint,\n    fp_non_residue: BigUint,\n    generator_g1_x: BigUint,\n    generator_g1_y: BigUint,\n    generator_g2_x_0: BigUint,\n    generator_g2_x_1: BigUint,\n    generator_g2_x_2: BigUint,\n    generator_g2_y_0: BigUint,\n    generator_g2_y_1: BigUint,\n    generator_g2_y_2: BigUint,\n    ate_loop_scalar: BigUint,\n    ate_loop_scalar_is_negative: bool,\n    final_exp_scalar: BigUint,\n    w0_exp_scalar: BigUint,\n    w0_exp_scalar_is_negative: bool,\n    w1_exp_scalar: BigUint,\n) {\n    let modulus_uint = MaxFieldUint::from_big_endian(&modulus.to_bytes_be());\n    let field = field_from_modulus::<FE>(&modulus_uint).unwrap();\n    let a_fp = Fp::from_be_bytes(&field, &a.to_bytes_be(), true).unwrap();\n    let b_fp = Fp::from_be_bytes(&field, &b.to_bytes_be(), true).unwrap();\n    let fp_non_residue = Fp::from_be_bytes(&field, &fp_non_residue.to_bytes_be(), true).unwrap();\n    let extension_3 = Extension3::new(fp_non_residue.clone());\n    let one = Fp::one(&field);\n    let mut twist = Fp3::zero(&extension_3);\n    twist.c1 = one.clone();\n    let mut twist_squared = twist.clone();\n    twist_squared.square();\n    let mut twist_cubed = twist_squared.clone();\n    twist_cubed.mul_assign(&twist);\n    let mut a_fp3 = twist_squared.clone();\n    a_fp3.mul_by_fp(&a_fp);\n    let mut b_fp3 = twist_cubed.clone();\n    b_fp3.mul_by_fp(&b_fp);\n    let g1_generator_x = Fp::from_be_bytes(&field, &generator_g1_x.to_bytes_be(), true).unwrap();\n    let g1_generator_y = Fp::from_be_bytes(&field, &generator_g1_y.to_bytes_be(), true).unwrap();\n    let g1_generator_x_c0 = Fp::from_be_bytes(&field, &generator_g2_x_0.to_bytes_be(), true).unwrap();\n    let g1_generator_x_c1 = Fp::from_be_bytes(&field, &generator_g2_x_1.to_bytes_be(), true).unwrap();\n    let g1_generator_x_c2 = Fp::from_be_bytes(&field, &generator_g2_x_2.to_bytes_be(), true).unwrap();\n    let g1_generator_y_c0 = Fp::from_be_bytes(&field, &generator_g2_y_0.to_bytes_be(), true).unwrap();\n    let g1_generator_y_c1 = Fp::from_be_bytes(&field, &generator_g2_y_1.to_bytes_be(), true).unwrap();\n    let g1_generator_y_c2 = Fp::from_be_bytes(&field, &generator_g2_y_2.to_bytes_be(), true).unwrap();\n    println!(\"Weierstrass curve parameters with k=6\");\n    println!(\"Base field modulus = {}\", field.modulus());\n    println!(\"A coefficient = {}\", a_fp);\n    println!(\"B coefficient = {}\", b_fp);\n    println!(\"Main subgroup order = 0x{}\", main_subgroup_order.to_str_radix(16));\n    println!(\"Extension tower:\");\n    println!(\"Fp3 construction:\");\n    println!(\"Fp cubic non-residue = {}\", fp_non_residue);\n    println!(\"A coefficient for twist c0 = {}\", a_fp3.c0);\n    println!(\"A coefficient for twist c1 = {}\", a_fp3.c1);\n    println!(\"A coefficient for twist c2 = {}\", a_fp3.c2);\n    println!(\"B coefficient for twist c0 = {}\", b_fp3.c0);\n    println!(\"B coefficient for twist c1 = {}\", b_fp3.c1);\n    println!(\"B coefficient for twist c2 = {}\", b_fp3.c2);\n    println!(\"Generators:\");\n    println!(\"G1:\");\n    println!(\"X = {}\", g1_generator_x);\n    println!(\"Y = {}\", g1_generator_y);\n    println!(\"G2:\");\n    println!(\"X c0 = {}\", g1_generator_x_c0);\n    println!(\"X c1 = {}\", g1_generator_x_c1);\n    println!(\"X c2 = {}\", g1_generator_x_c2);\n    println!(\"Y c0 = {}\", g1_generator_y_c0);\n    println!(\"Y c1 = {}\", g1_generator_y_c1);\n    println!(\"Y c2 = {}\", g1_generator_y_c2);\n    println!(\"Pairing parameters:\");\n    println!(\"|ate_loop_scalar| (miller loop scalar) = 0x{}\", ate_loop_scalar.to_str_radix(16));\n    println!(\"ate_loop_scalar is negative = {}\", ate_loop_scalar_is_negative);\n    println!(\"final_exp_scalar (final exponentiation power) = 0x{}\", final_exp_scalar.to_str_radix(16));\n    println!(\"Breaking final exponentiation hard part into the two parts (usually labeled w0 and w1)\");\n    println!(\"|w0| = 0x{}\", w0_exp_scalar.to_str_radix(16));\n    println!(\"w0 is negative = {}\", w0_exp_scalar_is_negative);\n    println!(\"|w1| = 0x{}\", w1_exp_scalar.to_str_radix(16));\n"]], "pred": {"ppl": 1.6579444408416748, "ppl_lower": 1.758642315864563, "ppl/lowercase_ppl": -1.116625901023198, "ppl/zlib": 0.0005327487317238847, "Min_5.0% Prob": 6.156363879933076, "Min_10.0% Prob": 4.160541887376823, "Min_20.0% Prob": 2.4265693239137236, "Min_30.0% Prob": 1.672278215000832, "Min_40.0% Prob": 1.2611568010478191, "Min_50.0% Prob": 1.011353932321983, "Min_60.0% Prob": 0.8435836239555717}}
{"hexsha": "fcfe694812796a9074cc0d41097fd1d0c3044cc7", "ext": "rs", "lang": "Rust", "content": "fn lp_3_mat_10_50(b: &mut Bencher) {\n    let a = Matrix::new(10, 50, vec![2.0;500]);\n    let lp = Lp::Integer(3);\n\n    b.iter(|| {\n    \tlet _ = black_box(MatrixNorm::norm(&lp, &a));\n    });\n}", "item_id": 4, "repo": "Frando/rulinalg", "file": "benches/linalg/norm.rs", "last_update_at": "2022-03-30T16:29:40+00:00", "question_id": "fcfe694812796a9074cc0d41097fd1d0c3044cc7_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn lp_3_mat_10_50(b: &mut Bencher) {\n    let a = Matrix::new(10, 50, vec![2.0;500]);\n    let lp = Lp::Integer(3);\n    b.iter(|| {\n    \tlet _ = black_box(MatrixNorm::norm(&lp, &a));\n    });\n"]], "pred": {"ppl": 4.7426347732543945, "ppl_lower": 6.249921798706055, "ppl/lowercase_ppl": -1.1772949891918634, "ppl/zlib": 0.009728705253817378, "Min_5.0% Prob": 9.358705520629883, "Min_10.0% Prob": 7.89828454123603, "Min_20.0% Prob": 6.102962682121678, "Min_30.0% Prob": 4.719882939543043, "Min_40.0% Prob": 3.70442616625836, "Min_50.0% Prob": 3.027382259567579, "Min_60.0% Prob": 2.5908688625745606}}
{"hexsha": "a97ff0572deb752b85f5b36725a641def5d4bf8b", "ext": "rs", "lang": "Rust", "content": "fn ouster_pcd_converter() -> Result<()> {\n    // Load config\n    let config = Config::from_path(\"test_files/ouster_example.json\")?;\n    let pcd_converter = PointCloudConverter::from_config(config);\n\n    // Load pcap file\n    let mut cap = Capture::from_file(\"test_files/ouster_example.pcap\")?;\n    cap.filter(\"udp\")?;\n\n    while let Ok(packet) = cap.next() {\n        let lidar_packet = OusterPacket::from_pcap(&packet)?;\n        let points = pcd_converter.convert(lidar_packet)?;\n        assert!(points.len() as u16 == pcd_converter.columns_per_revolution());\n    }\n\n    Ok(())\n}", "item_id": 1, "repo": "jerry73204/rust-lidar-utils", "file": "tests/ouster.rs", "last_update_at": "2022-01-16T14:52:16+00:00", "question_id": "a97ff0572deb752b85f5b36725a641def5d4bf8b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn ouster_pcd_converter() -> Result<()> {\n    // Load config\n    let config = Config::from_path(\"test_files/ouster_example.json\")?;\n    let pcd_converter = PointCloudConverter::from_config(config);\n    // Load pcap file\n    let mut cap = Capture::from_file(\"test_files/ouster_example.pcap\")?;\n    cap.filter(\"udp\")?;\n    while let Ok(packet) = cap.next() {\n        let lidar_packet = OusterPacket::from_pcap(&packet)?;\n        let points = pcd_converter.convert(lidar_packet)?;\n        assert!(points.len() as u16 == pcd_converter.columns_per_revolution());\n    }\n    Ok(())\n"]], "pred": {"ppl": 2.699730396270752, "ppl_lower": 3.246201276779175, "ppl/lowercase_ppl": -1.1856045961013797, "ppl/zlib": 0.0033666166603103817, "Min_5.0% Prob": 7.7129253387451175, "Min_10.0% Prob": 5.956308317184448, "Min_20.0% Prob": 4.080717325210571, "Min_30.0% Prob": 3.045454305025839, "Min_40.0% Prob": 2.4227472369263814, "Min_50.0% Prob": 1.9766097249625956, "Min_60.0% Prob": 1.6534916908450183}}
{"hexsha": "3bced46876805d59d4c7b63e4e102e39ced5ad13", "ext": "rs", "lang": "Rust", "content": "fn bench_hadamard_larger(b: &mut Bencher) {\n        let n = 8;\n        let indices = (0..n).collect::<Vec<_>>();\n        let mut state = FeynmanState::<f64>::new(n);\n\n        let mult = (1.0 / 2.0f64).sqrt();\n        let mat = from_reals(&[mult, mult, mult, -mult]);\n\n        let ops: Vec<UnitaryOp> = (0..n).map(|i| Matrix(vec![i], mat.clone())).collect();\n        ops.iter().for_each(|op| state.apply_op(op));\n\n        b.iter(|| state.stochastic_measure(&indices, 0.0));\n    }", "item_id": 4, "repo": "oxarbitrage/RustQIP", "file": "benches/feynman_bench.rs", "last_update_at": "2022-03-30T13:48:29+00:00", "question_id": "3bced46876805d59d4c7b63e4e102e39ced5ad13_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bench_hadamard_larger(b: &mut Bencher) {\n        let n = 8;\n        let indices = (0..n).collect::<Vec<_>>();\n        let mut state = FeynmanState::<f64>::new(n);\n        let mult = (1.0 / 2.0f64).sqrt();\n        let mat = from_reals(&[mult, mult, mult, -mult]);\n        let ops: Vec<UnitaryOp> = (0..n).map(|i| Matrix(vec![i], mat.clone())).collect();\n        ops.iter().for_each(|op| state.apply_op(op));\n        b.iter(|| state.stochastic_measure(&indices, 0.0));\n"]], "pred": {"ppl": 3.5793511867523193, "ppl_lower": 4.771005630493164, "ppl/lowercase_ppl": -1.2253605027195629, "ppl/zlib": 0.0044586767525776946, "Min_5.0% Prob": 9.316381560431587, "Min_10.0% Prob": 7.612051089604695, "Min_20.0% Prob": 5.0396604215776595, "Min_30.0% Prob": 3.7944152589355196, "Min_40.0% Prob": 3.028169978459676, "Min_50.0% Prob": 2.495336873417205, "Min_60.0% Prob": 2.110470510425821}}
{"hexsha": "7d0a4f66f48b8514bd9fb03b9e855d16dd4adb01", "ext": "rs", "lang": "Rust", "content": "pub fn to_signed_transaction(state: &MinerState, transaction: RPCTransaction, stateful: &MemoryStateful) -> Result<Transaction, Error> {\n    let address = match transaction.from {\n        Some(val) => val.0,\n        None => Address::default(),\n    };\n    let secret_key = {\n        let mut secret_key = None;\n        for key in state.accounts() {\n            if Address::from_secret_key(&key)? == address {\n                secret_key = Some(key);\n            }\n        }\n        match secret_key {\n            Some(val) => val,\n            None => return Err(Error::NotFound),\n        }\n    };\n    let block = state.get_block_by_number(state.block_height());\n    let trie = stateful.state_of(block.header.state_root);\n\n    let account: Option<Account> = trie.get(&address);\n\n    let unsigned = UnsignedTransaction {\n        nonce: match transaction.nonce {\n            Some(val) => val.0,\n            None => {\n                account.as_ref().map(|account| account.nonce).unwrap_or(U256::zero())\n            }\n        },\n        gas_price: match transaction.gas_price {\n            Some(val) => val.0,\n            None => Gas::zero(),\n        },\n        gas_limit: match transaction.gas {\n            Some(val) => val.0,\n            None => Gas::from(90000u64),\n        },\n        action: match transaction.to {\n            Some(val) => TransactionAction::Call(val.0),\n            None => TransactionAction::Create,\n        },\n        value: match transaction.value {\n            Some(val) => val.0,\n            None => U256::zero(),\n        },\n        input: match transaction.data {\n            Some(val) => val.0,\n            None => Vec::new(),\n        },\n    };\n    let transaction = unsigned.sign::<GlobalSignaturePatch>(&secret_key);\n\n    Ok(transaction)\n}", "item_id": 4, "repo": "ethereumproject/evm-dev", "file": "src/rpc/util.rs", "last_update_at": "2022-03-25T09:38:32+00:00", "question_id": "7d0a4f66f48b8514bd9fb03b9e855d16dd4adb01_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn to_signed_transaction(state: &MinerState, transaction: RPCTransaction, stateful: &MemoryStateful) -> Result<Transaction, Error> {\n    let address = match transaction.from {\n        Some(val) => val.0,\n        None => Address::default(),\n    };\n    let secret_key = {\n        let mut secret_key = None;\n        for key in state.accounts() {\n            if Address::from_secret_key(&key)? == address {\n                secret_key = Some(key);\n            }\n        }\n        match secret_key {\n            Some(val) => val,\n            None => return Err(Error::NotFound),\n        }\n    };\n    let block = state.get_block_by_number(state.block_height());\n    let trie = stateful.state_of(block.header.state_root);\n    let account: Option<Account> = trie.get(&address);\n    let unsigned = UnsignedTransaction {\n        nonce: match transaction.nonce {\n            Some(val) => val.0,\n            None => {\n                account.as_ref().map(|account| account.nonce).unwrap_or(U256::zero())\n            }\n        },\n        gas_price: match transaction.gas_price {\n            Some(val) => val.0,\n            None => Gas::zero(),\n        },\n        gas_limit: match transaction.gas {\n            Some(val) => val.0,\n            None => Gas::from(90000u64),\n        },\n        action: match transaction.to {\n            Some(val) => TransactionAction::Call(val.0),\n            None => TransactionAction::Create,\n        },\n        value: match transaction.value {\n            Some(val) => val.0,\n            None => U256::zero(),\n        },\n        input: match transaction.data {\n            Some(val) => val.0,\n            None => Vec::new(),\n        },\n    };\n    let transaction = unsigned.sign::<GlobalSignaturePatch>(&secret_key);\n    Ok(transaction)\n"]], "pred": {"ppl": 2.045646905899048, "ppl_lower": 2.3957715034484863, "ppl/lowercase_ppl": -1.2207463015445068, "ppl/zlib": 0.0012213550765771812, "Min_5.0% Prob": 6.462859210968017, "Min_10.0% Prob": 4.932567876927993, "Min_20.0% Prob": 3.1892892624817644, "Min_30.0% Prob": 2.2929140360526787, "Min_40.0% Prob": 1.768389753997326, "Min_50.0% Prob": 1.4287438391616532, "Min_60.0% Prob": 1.1939521911188813}}
{"hexsha": "2bf2666112a7aad2638c77fc88a6df78693e3161", "ext": "rs", "lang": "Rust", "content": "fn test_stringifying_and_parsing_public_coefficients_should_produce_original(\n    public_coefficients: PublicCoefficientsBytes,\n) {\n    let string = String::from(public_coefficients.clone());\n    let parsed = PublicCoefficientsBytes::try_from(string.as_str());\n    assert_eq!(\n        Ok(public_coefficients),\n        parsed,\n        \"String form does not parse to original: '{}'\",\n        string\n    );\n}", "item_id": 7, "repo": "3cL1p5e7/ic", "file": "rs/crypto/internal/crypto_lib/threshold_sig/bls12_381/src/types/public_coefficients/conversions/tests.rs", "last_update_at": "2022-03-31T11:40:24+00:00", "question_id": "2bf2666112a7aad2638c77fc88a6df78693e3161_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_stringifying_and_parsing_public_coefficients_should_produce_original(\n    public_coefficients: PublicCoefficientsBytes,\n) {\n    let string = String::from(public_coefficients.clone());\n    let parsed = PublicCoefficientsBytes::try_from(string.as_str());\n    assert_eq!(\n        Ok(public_coefficients),\n        parsed,\n        \"String form does not parse to original: '{}'\",\n        string\n    );\n"]], "pred": {"ppl": 3.023707389831543, "ppl_lower": 3.7764601707458496, "ppl/lowercase_ppl": -1.2009098000291039, "ppl/zlib": 0.005243998535609658, "Min_5.0% Prob": 8.189679463704428, "Min_10.0% Prob": 6.300026059150696, "Min_20.0% Prob": 4.507918139298757, "Min_30.0% Prob": 3.426375566302119, "Min_40.0% Prob": 2.7159895331275705, "Min_50.0% Prob": 2.1917317074633416, "Min_60.0% Prob": 1.8504909111337888}}
{"hexsha": "6fa48d308487319188cbc34cfdba4d8f1c8076c0", "ext": "rs", "lang": "Rust", "content": "fn test_backup_mode_long_with_args() {\n        let short_opt_present = false;\n        let long_opt_present = true;\n        let long_opt_value = Some(\"simple\");\n        let _dummy = TEST_MUTEX.lock().unwrap();\n\n        let result =\n            determine_backup_mode(short_opt_present, long_opt_present, long_opt_value).unwrap();\n\n        assert_eq!(result, BackupMode::SimpleBackup);\n    }", "item_id": 5, "repo": "aburn/coreutils", "file": "src/uucore/src/lib/mods/backup_control.rs", "last_update_at": "2022-01-28T23:17:30+00:00", "question_id": "6fa48d308487319188cbc34cfdba4d8f1c8076c0_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_backup_mode_long_with_args() {\n        let short_opt_present = false;\n        let long_opt_present = true;\n        let long_opt_value = Some(\"simple\");\n        let _dummy = TEST_MUTEX.lock().unwrap();\n        let result =\n            determine_backup_mode(short_opt_present, long_opt_present, long_opt_value).unwrap();\n        assert_eq!(result, BackupMode::SimpleBackup);\n"]], "pred": {"ppl": 3.2746570110321045, "ppl_lower": 4.2053046226501465, "ppl/lowercase_ppl": -1.2108673327031452, "ppl/zlib": 0.005990975424984126, "Min_5.0% Prob": 8.31516718864441, "Min_10.0% Prob": 7.183370351791382, "Min_20.0% Prob": 5.186220437288284, "Min_30.0% Prob": 3.8191502822770014, "Min_40.0% Prob": 2.9115754913310616, "Min_50.0% Prob": 2.3715605266758653, "Min_60.0% Prob": 1.9929543458537695}}
{"hexsha": "14650697c31b96dbd3fd6946ab01a9d8b60a3c69", "ext": "rs", "lang": "Rust", "content": "async fn full_rewind() {\n        let underlying = [104, 101, 108, 108, 111];\n\n        let mock = tokio_test::io::Builder::new().read(&underlying).build();\n\n        let mut stream = Rewind::new(mock);\n\n        let mut buf = [0; 5];\n        stream.read_exact(&mut buf).await.expect(\"read1\");\n\n        // Rewind the stream so that it is as if we never read in the first place.\n        stream.rewind(Bytes::copy_from_slice(&buf[..]));\n\n        let mut buf = [0; 5];\n        stream.read_exact(&mut buf).await.expect(\"read1\");\n    }", "item_id": 1, "repo": "goffrie/hyper", "file": "src/common/io/rewind.rs", "last_update_at": "2022-03-28T07:59:06+00:00", "question_id": "14650697c31b96dbd3fd6946ab01a9d8b60a3c69_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn full_rewind() {\n        let underlying = [104, 101, 108, 108, 111];\n        let mock = tokio_test::io::Builder::new().read(&underlying).build();\n        let mut stream = Rewind::new(mock);\n        let mut buf = [0; 5];\n        stream.read_exact(&mut buf).await.expect(\"read1\");\n        // Rewind the stream so that it is as if we never read in the first place.\n        stream.rewind(Bytes::copy_from_slice(&buf[..]));\n        let mut buf = [0; 5];\n        stream.read_exact(&mut buf).await.expect(\"read1\");\n"]], "pred": {"ppl": 2.646317958831787, "ppl_lower": 3.067368507385254, "ppl/lowercase_ppl": -1.1517216145922327, "ppl/zlib": 0.0037429585550794735, "Min_5.0% Prob": 8.42639938990275, "Min_10.0% Prob": 6.27330125702752, "Min_20.0% Prob": 4.14395052355689, "Min_30.0% Prob": 3.0643261639135226, "Min_40.0% Prob": 2.3800961057345074, "Min_50.0% Prob": 1.9309922293462651, "Min_60.0% Prob": 1.6292116733301165}}
{"hexsha": "1ca6459842c951bfd8ac8e495b26964a4ca66989", "ext": "rs", "lang": "Rust", "content": "fn find_instruction_starts(fct: &BytecodeFunction) -> Vec<usize> {\n    let code = fct.code();\n    let mut pos = 0;\n    let mut intruction_start_offsets = Vec::new();\n\n    while pos < fct.code().len() {\n        intruction_start_offsets.push(pos);\n        let (opcode, width) = read_opcode_and_width(code, pos);\n        pos += opcode.size(width) as usize;\n    }\n\n    intruction_start_offsets\n}", "item_id": 0, "repo": "dinfuehr/dora", "file": "dora/src/bytecode/reader.rs", "last_update_at": "2022-03-26T10:32:44+00:00", "question_id": "1ca6459842c951bfd8ac8e495b26964a4ca66989_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn find_instruction_starts(fct: &BytecodeFunction) -> Vec<usize> {\n    let code = fct.code();\n    let mut pos = 0;\n    let mut intruction_start_offsets = Vec::new();\n    while pos < fct.code().len() {\n        intruction_start_offsets.push(pos);\n        let (opcode, width) = read_opcode_and_width(code, pos);\n        pos += opcode.size(width) as usize;\n    }\n    intruction_start_offsets\n"]], "pred": {"ppl": 2.4200620651245117, "ppl_lower": 3.092153310775757, "ppl/lowercase_ppl": -1.277298501137641, "ppl/zlib": 0.00433231954208524, "Min_5.0% Prob": 7.407961300441197, "Min_10.0% Prob": 5.854910561016628, "Min_20.0% Prob": 3.8920688458851407, "Min_30.0% Prob": 2.811332710442089, "Min_40.0% Prob": 2.1840755085327794, "Min_50.0% Prob": 1.753133993858183, "Min_60.0% Prob": 1.4739287324907149}}
{"hexsha": "4d5ced4fc1cad419ec89bdb5f0d025f006e6f814", "ext": "rs", "lang": "Rust", "content": "pub fn build_program(instructions: Vec<String>) -> String {\n    let mut out = String::from(\nr###\".syntax unified\n\n.global main\n.type main, %function\nmain:\n\"###);\n\n    for line in instructions {\n        out.push_str(&line);\n        out.push('\\n');\n    }\n\n    out.push_str(\nr###\"ldr lr, =0x444F4E45 @ \"DONE\"\n.size main, . - main\n\n.section .isr_vector, \"a\", %progbits\ng_pfnVectors:\n.word _stack_end\n.word main\n\n\"###);\n\n    return out;\n}", "item_id": 0, "repo": "cpmpercussion/comp2300-discoserver", "file": "tests/common/online.rs", "last_update_at": "2022-03-09T07:43:26+00:00", "question_id": "4d5ced4fc1cad419ec89bdb5f0d025f006e6f814_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn build_program(instructions: Vec<String>) -> String {\n    let mut out = String::from(\nr###\".syntax unified\n.global main\n.type main, %function\nmain:\n\"###);\n    for line in instructions {\n        out.push_str(&line);\n        out.push('\\n');\n    }\n    out.push_str(\nr###\"ldr lr, =0x444F4E45 @ \"DONE\"\n.size main, . - main\n.section .isr_vector, \"a\", %progbits\ng_pfnVectors:\n.word _stack_end\n.word main\n\"###);\n    return out;\n"]], "pred": {"ppl": 3.0998973846435547, "ppl_lower": 3.5708444118499756, "ppl/lowercase_ppl": -1.1250105733720506, "ppl/zlib": 0.004026224232083063, "Min_5.0% Prob": 7.831270456314087, "Min_10.0% Prob": 6.373911955777337, "Min_20.0% Prob": 4.3970714296613425, "Min_30.0% Prob": 3.3825128089923124, "Min_40.0% Prob": 2.6967802618231094, "Min_50.0% Prob": 2.2183481419289652, "Min_60.0% Prob": 1.8843426519206592}}
{"hexsha": "d635e87385b4d008770525871764a7b0d3034375", "ext": "rs", "lang": "Rust", "content": "pub fn wait<F>(fd: RawFd, cond: F, timeout: Option<Duration>) -> bool\nwhere\n    F: Fn() -> bool,\n{\n    if cond() {\n        return true;\n    }\n\n    let start = Instant::now();\n\n    let mut t = timeout;\n\n    loop {\n        let wait_timeout = match t {\n            Some(duration) => duration.as_millis() as i32,\n            None => -1,\n        };\n        wait_file_changes(fd, wait_timeout);\n\n        if let Some(duration) = timeout {\n            let elapsed = start.elapsed();\n            if elapsed >= duration {\n                return false;\n            }\n            t = Some(duration - elapsed);\n        }\n\n        if cond() {\n            return true;\n        }\n    }\n}", "item_id": 0, "repo": "MassiminoilTrace/ev3dev-lang-rust", "file": "src/wait.rs", "last_update_at": "2022-01-23T18:19:51+00:00", "question_id": "d635e87385b4d008770525871764a7b0d3034375_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn wait<F>(fd: RawFd, cond: F, timeout: Option<Duration>) -> bool\nwhere\n    F: Fn() -> bool,\n{\n    if cond() {\n        return true;\n    }\n    let start = Instant::now();\n    let mut t = timeout;\n    loop {\n        let wait_timeout = match t {\n            Some(duration) => duration.as_millis() as i32,\n            None => -1,\n        };\n        wait_file_changes(fd, wait_timeout);\n        if let Some(duration) = timeout {\n            let elapsed = start.elapsed();\n            if elapsed >= duration {\n                return false;\n            }\n            t = Some(duration - elapsed);\n        }\n        if cond() {\n            return true;\n        }\n    }\n"]], "pred": {"ppl": 1.9482313394546509, "ppl_lower": 2.5001814365386963, "ppl/lowercase_ppl": -1.3740187981159677, "ppl/zlib": 0.002223073185298304, "Min_5.0% Prob": 6.9717125415802, "Min_10.0% Prob": 4.904016244411468, "Min_20.0% Prob": 3.0365707382559775, "Min_30.0% Prob": 2.185078549881776, "Min_40.0% Prob": 1.6580035158513504, "Min_50.0% Prob": 1.337765756551877, "Min_60.0% Prob": 1.1183035937946075}}
{"hexsha": "83ebff57f44faa45ab77fe0782451ab5c4d3f2ca", "ext": "rs", "lang": "Rust", "content": "fn test_nested_refs_for_let_shadowing() {\n        let values = vec![1, 2, 3, 4];\n        let vs = &values;\n        check_match(vec![5, 5, 5, 5,\n                         6, 6, 6, 6,\n                         7, 7, 7, 7,\n                         8, 8, 8, 8].into_iter(),\n                    iterate![for x in vs.iter();\n                             let a = *x + 3;\n                             for y in vs.iter();\n                             let y = 1;\n                             yield y + a]);\n    }", "item_id": 6, "repo": "dstu/r4", "file": "src/lib.rs", "last_update_at": "2022-02-22T20:27:43+00:00", "question_id": "83ebff57f44faa45ab77fe0782451ab5c4d3f2ca_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_nested_refs_for_let_shadowing() {\n        let values = vec![1, 2, 3, 4];\n        let vs = &values;\n        check_match(vec![5, 5, 5, 5,\n                         6, 6, 6, 6,\n                         7, 7, 7, 7,\n                         8, 8, 8, 8].into_iter(),\n                    iterate![for x in vs.iter();\n                             let a = *x + 3;\n                             for y in vs.iter();\n                             let y = 1;\n                             yield y + a]);\n"]], "pred": {"ppl": 3.4558775424957275, "ppl_lower": 3.4558775424957275, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.006392146479424744, "Min_5.0% Prob": 8.261350750923157, "Min_10.0% Prob": 6.874757319688797, "Min_20.0% Prob": 5.049014654010534, "Min_30.0% Prob": 3.8166358980039754, "Min_40.0% Prob": 3.0011889031156898, "Min_50.0% Prob": 2.445768859796226, "Min_60.0% Prob": 2.0559704683255404}}
{"hexsha": "10889000a775094684cae75666e5e1555ae97dbb", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern \"C\" fn connection_settings_get_username(\n    this: *const ConnectionSettings,\n) -> *const c_char {\n    if this.is_null() {\n        return ptr::null();\n    }\n    let settings: &ConnectionSettings = { &*this };\n\n    match CString::new(settings.username.as_bytes()) {\n        Err(_) => std::ptr::null(),\n        Ok(str_bytes) => str_bytes.into_raw(),\n    }\n}", "item_id": 8, "repo": "jonathanschroeter/datajoint-core", "file": "packages/datajoint-core-ffi-c/src/connection/settings.rs", "last_update_at": "2022-02-23T08:54:00+00:00", "question_id": "10889000a775094684cae75666e5e1555ae97dbb_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe extern \"C\" fn connection_settings_get_username(\n    this: *const ConnectionSettings,\n) -> *const c_char {\n    if this.is_null() {\n        return ptr::null();\n    }\n    let settings: &ConnectionSettings = { &*this };\n    match CString::new(settings.username.as_bytes()) {\n        Err(_) => std::ptr::null(),\n        Ok(str_bytes) => str_bytes.into_raw(),\n    }\n"]], "pred": {"ppl": 2.6803805828094482, "ppl_lower": 4.089332580566406, "ppl/lowercase_ppl": -1.4284387781432972, "ppl/zlib": 0.004441255824105853, "Min_5.0% Prob": 8.650100708007812, "Min_10.0% Prob": 6.679168917916038, "Min_20.0% Prob": 4.38694317444511, "Min_30.0% Prob": 3.214180300916944, "Min_40.0% Prob": 2.4635030170704457, "Min_50.0% Prob": 1.9810645185032134, "Min_60.0% Prob": 1.6507410432513752}}
{"hexsha": "87ac99b3c92bccdcc8f6f96496d0a9f062e80842", "ext": "rs", "lang": "Rust", "content": "pub fn serialize_operation_crate_operation_describe_resource_policies(\n    input: &crate::input::DescribeResourcePoliciesInput,\n) -> Result<aws_smithy_http::body::SdkBody, aws_smithy_http::operation::SerializationError> {\n    let mut out = String::new();\n    let mut object = aws_smithy_json::serialize::JsonObjectWriter::new(&mut out);\n    crate::json_ser::serialize_structure_crate_input_describe_resource_policies_input(\n        &mut object,\n        input,\n    )?;\n    object.finish();\n    Ok(aws_smithy_http::body::SdkBody::from(out))\n}", "item_id": 20, "repo": "StevenBlack/aws-sdk-rust", "file": "sdk/cloudwatchlogs/src/operation_ser.rs", "last_update_at": "2022-03-31T20:47:15+00:00", "question_id": "87ac99b3c92bccdcc8f6f96496d0a9f062e80842_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn serialize_operation_crate_operation_describe_resource_policies(\n    input: &crate::input::DescribeResourcePoliciesInput,\n) -> Result<aws_smithy_http::body::SdkBody, aws_smithy_http::operation::SerializationError> {\n    let mut out = String::new();\n    let mut object = aws_smithy_json::serialize::JsonObjectWriter::new(&mut out);\n    crate::json_ser::serialize_structure_crate_input_describe_resource_policies_input(\n        &mut object,\n        input,\n    )?;\n    object.finish();\n    Ok(aws_smithy_http::body::SdkBody::from(out))\n"]], "pred": {"ppl": 2.9582700729370117, "ppl_lower": 4.200049877166748, "ppl/lowercase_ppl": -1.323151605492349, "ppl/zlib": 0.003958411177623334, "Min_5.0% Prob": 8.363966835869682, "Min_10.0% Prob": 6.887077702416314, "Min_20.0% Prob": 4.782716575596067, "Min_30.0% Prob": 3.469318906466166, "Min_40.0% Prob": 2.7012267483191357, "Min_50.0% Prob": 2.1633847970720175, "Min_60.0% Prob": 1.8102422287995252}}
{"hexsha": "30e511542e4aac60c54c4fe6514719129fa9ee2c", "ext": "rs", "lang": "Rust", "content": "fn test_utsname() {\n    init();\n\n    let mut st = get_st(\"utsname\");\n    let mut iterator = st.iter_as_syscall().skip_while(compare).skip(1);\n\n    let call = unwrap_syscall!(iterator, Uname);\n    let uts_name = nix::sys::utsname::uname();\n    assert_eq!(&call.utsname.sysname, uts_name.sysname());\n    assert_eq!(&call.utsname.nodename, uts_name.nodename());\n    assert_eq!(&call.utsname.release, uts_name.release());\n    assert_eq!(&call.utsname.version, uts_name.version());\n    assert_eq!(&call.utsname.machine, uts_name.machine());\n}", "item_id": 5, "repo": "palfrey/hstrace", "file": "tests/test_c_binary.rs", "last_update_at": "2022-03-07T11:10:40+00:00", "question_id": "30e511542e4aac60c54c4fe6514719129fa9ee2c_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_utsname() {\n    init();\n    let mut st = get_st(\"utsname\");\n    let mut iterator = st.iter_as_syscall().skip_while(compare).skip(1);\n    let call = unwrap_syscall!(iterator, Uname);\n    let uts_name = nix::sys::utsname::uname();\n    assert_eq!(&call.utsname.sysname, uts_name.sysname());\n    assert_eq!(&call.utsname.nodename, uts_name.nodename());\n    assert_eq!(&call.utsname.release, uts_name.release());\n    assert_eq!(&call.utsname.version, uts_name.version());\n    assert_eq!(&call.utsname.machine, uts_name.machine());\n"]], "pred": {"ppl": 2.7272844314575195, "ppl_lower": 2.6866719722747803, "ppl/lowercase_ppl": -0.9850462852199449, "ppl/zlib": 0.004539847965561086, "Min_5.0% Prob": 8.920245912339952, "Min_10.0% Prob": 7.0270459777430485, "Min_20.0% Prob": 4.544493415416816, "Min_30.0% Prob": 3.2610463681867565, "Min_40.0% Prob": 2.5113925975334794, "Min_50.0% Prob": 2.015006570145488, "Min_60.0% Prob": 1.6774666998007124}}
{"hexsha": "65567f1625990beb275e3bfe29ed6bb0c8b1c9e2", "ext": "rs", "lang": "Rust", "content": "fn test_deserialize_serialize_signed_response() {\n        let response_xml = include_str!(concat!(\n            env!(\"CARGO_MANIFEST_DIR\"),\n            \"/test_vectors/response_signed.xml\",\n        ));\n        let expected_response: Response = response_xml\n            .parse()\n            .expect(\"failed to parse response_signed.xml\");\n        let serialized_response =\n            yaserde::ser::to_string(&expected_response).expect(\"failed to convert response to xml\");\n        std::fs::write(\"/tmp/foo.xml\", &serialized_response).unwrap();\n        let actual_response: Response = serialized_response\n            .parse()\n            .expect(\"failed to re-parse response\");\n\n        assert_eq!(expected_response, actual_response);\n    }", "item_id": 2, "repo": "samueltardieu/samael", "file": "src/schema/response.rs", "last_update_at": "2022-02-10T20:46:53+00:00", "question_id": "65567f1625990beb275e3bfe29ed6bb0c8b1c9e2_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_deserialize_serialize_signed_response() {\n        let response_xml = include_str!(concat!(\n            env!(\"CARGO_MANIFEST_DIR\"),\n            \"/test_vectors/response_signed.xml\",\n        ));\n        let expected_response: Response = response_xml\n            .parse()\n            .expect(\"failed to parse response_signed.xml\");\n        let serialized_response =\n            yaserde::ser::to_string(&expected_response).expect(\"failed to convert response to xml\");\n        std::fs::write(\"/tmp/foo.xml\", &serialized_response).unwrap();\n        let actual_response: Response = serialized_response\n            .parse()\n            .expect(\"failed to re-parse response\");\n        assert_eq!(expected_response, actual_response);\n"]], "pred": {"ppl": 2.220794439315796, "ppl_lower": 2.571021795272827, "ppl/lowercase_ppl": -1.1835378422324774, "ppl/zlib": 0.0026864140990465286, "Min_5.0% Prob": 7.1936797036065, "Min_10.0% Prob": 5.325946933344791, "Min_20.0% Prob": 3.469534852565863, "Min_30.0% Prob": 2.5473038790554834, "Min_40.0% Prob": 1.9583576407570105, "Min_50.0% Prob": 1.5954148913781667, "Min_60.0% Prob": 1.328062248471965}}
{"hexsha": "7b85deecc9f4c6c1d046ff64481e6b1cc2059653", "ext": "rs", "lang": "Rust", "content": "fn test_solve_dual64() {\r\n        let a = arr2(&[\r\n            [Dual64::new_scalar(4.0, 3.0), Dual64::new_scalar(3.0, 3.0)],\r\n            [Dual64::new_scalar(6.0, 1.0), Dual64::new_scalar(3.0, 2.0)],\r\n        ]);\r\n        let b = arr1(&[\r\n            Dual64::new_scalar(10.0, 20.0),\r\n            Dual64::new_scalar(12.0, 20.0),\r\n        ]);\r\n        let lu = LU::new(a).unwrap();\r\n        let det = lu.determinant();\r\n        assert_eq!((det.re, det.eps[0]), (-6.0, -4.0));\r\n        let x = lu.solve(&b);\r\n        assert_eq!(\r\n            (x[0].re, x[0].eps[0], x[1].re, x[1].eps[0]),\r\n            (1.0, 2.0, 2.0, 1.0)\r\n        );\r\n    }", "item_id": 2, "repo": "itt-ustutt/num-dual", "file": "src/linalg/mod.rs", "last_update_at": "2022-03-27T21:57:27+00:00", "question_id": "7b85deecc9f4c6c1d046ff64481e6b1cc2059653_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_solve_dual64() {\r\n        let a = arr2(&[\r\n            [Dual64::new_scalar(4.0, 3.0), Dual64::new_scalar(3.0, 3.0)],\r\n            [Dual64::new_scalar(6.0, 1.0), Dual64::new_scalar(3.0, 2.0)],\r\n        ]);\r\n        let b = arr1(&[\r\n            Dual64::new_scalar(10.0, 20.0),\r\n            Dual64::new_scalar(12.0, 20.0),\r\n        ]);\r\n        let lu = LU::new(a).unwrap();\r\n        let det = lu.determinant();\r\n        assert_eq!((det.re, det.eps[0]), (-6.0, -4.0));\r\n        let x = lu.solve(&b);\r\n        assert_eq!(\r\n            (x[0].re, x[0].eps[0], x[1].re, x[1].eps[0]),\r\n            (1.0, 2.0, 2.0, 1.0)\r\n        );\r\n"]], "pred": {"ppl": 1.9354482889175415, "ppl_lower": 2.029045581817627, "ppl/lowercase_ppl": -1.0715186504828629, "ppl/zlib": 0.0026413558940347813, "Min_5.0% Prob": 6.586468537648519, "Min_10.0% Prob": 4.748796741167705, "Min_20.0% Prob": 3.0333506113193076, "Min_30.0% Prob": 2.132709103433982, "Min_40.0% Prob": 1.6314727630072492, "Min_50.0% Prob": 1.3143547631848556, "Min_60.0% Prob": 1.1035675750286116}}
{"hexsha": "a25a42c6f86834a28e4f969ee28452aa8842621d", "ext": "rs", "lang": "Rust", "content": "fn spawn_random(player: &Character, distance: &location::Distance) -> (Class, i32) {\n    // the weights for each group of enemies are different depending on the distance\n    // the further from home, the bigger the chance to find difficult enemies\n    let (w_common, w_rare, w_legendary) = match distance {\n        location::Distance::Near(_) => (10, 2, 0),\n        location::Distance::Mid(_) => (8, 10, 1),\n        location::Distance::Far(_) => (0, 8, 2),\n    };\n\n    let mut rng = rand::thread_rng();\n\n    // assign weights to each group and select one\n    let weights = vec![\n        (Category::Common, w_common),\n        (Category::Rare, w_rare),\n        (Category::Legendary, w_legendary),\n    ];\n\n    let category = weights\n        .as_slice()\n        .choose_weighted(&mut rng, |(_c, weight)| *weight)\n        .unwrap()\n        .0\n        .clone();\n\n    let level = std::cmp::max(player.level / 10 + distance.len() - 1, 1);\n    (Class::random(category).clone(), level)\n}", "item_id": 1, "repo": "Kruemmelspalter/rpg-cli", "file": "src/character/enemy.rs", "last_update_at": "2022-03-24T03:32:34+00:00", "question_id": "a25a42c6f86834a28e4f969ee28452aa8842621d_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn spawn_random(player: &Character, distance: &location::Distance) -> (Class, i32) {\n    // the weights for each group of enemies are different depending on the distance\n    // the further from home, the bigger the chance to find difficult enemies\n    let (w_common, w_rare, w_legendary) = match distance {\n        location::Distance::Near(_) => (10, 2, 0),\n        location::Distance::Mid(_) => (8, 10, 1),\n        location::Distance::Far(_) => (0, 8, 2),\n    };\n    let mut rng = rand::thread_rng();\n    // assign weights to each group and select one\n    let weights = vec![\n        (Category::Common, w_common),\n        (Category::Rare, w_rare),\n        (Category::Legendary, w_legendary),\n    ];\n    let category = weights\n        .as_slice()\n        .choose_weighted(&mut rng, |(_c, weight)| *weight)\n        .unwrap()\n        .0\n        .clone();\n    let level = std::cmp::max(player.level / 10 + distance.len() - 1, 1);\n    (Class::random(category).clone(), level)\n"]], "pred": {"ppl": 2.9003591537475586, "ppl_lower": 3.06906795501709, "ppl/lowercase_ppl": -1.0530968317986242, "ppl/zlib": 0.0022752875543674755, "Min_5.0% Prob": 7.6356689453125, "Min_10.0% Prob": 5.9404966831207275, "Min_20.0% Prob": 4.269787774932, "Min_30.0% Prob": 3.302312272210275, "Min_40.0% Prob": 2.6049031734466555, "Min_50.0% Prob": 2.125300795890582, "Min_60.0% Prob": 1.7795057533916465}}
{"hexsha": "2b978d2c632b3c1d0402d90c490b370ec45c7979", "ext": "rs", "lang": "Rust", "content": "fn successfully_forwards_an_image_from_rocketchat_to_matrix_when_the_user_is_not_registered_on_matrix() {\n    let test = Test::new();\n    let (message_forwarder, receiver) = MessageForwarder::new();\n    let uploaded_files = Arc::new(Mutex::new(Vec::new()));\n    let (create_content_forwarder, create_content_receiver) =\n        handlers::MatrixCreateContentHandler::with_forwarder(Arc::clone(&uploaded_files));\n    let mut matrix_router = test.default_matrix_routes();\n    matrix_router.put(SendMessageEventEndpoint::router_path(), message_forwarder, \"send_message_event\");\n    matrix_router.post(CreateContentEndpoint::router_path(), create_content_forwarder, \"create_content\");\n\n    let attachments = vec![Attachment {\n        description: \"Spec image\".to_string(),\n        image_size: Some(100),\n        image_type: Some(\"image/png\".to_string()),\n        image_url: Some(\"/file-upload/image.png\".to_string()),\n        mimetype: \"image/png\".to_string(),\n        title: \"Spec titel\".to_string(),\n        title_link: \"/file-upload/image.png\".to_string(),\n    }];\n    let rocketchat_message = Arc::new(Mutex::new(Some(Message {\n        id: \"spec_id\".to_string(),\n        rid: \"spec_rid\".to_string(),\n        msg: \"\".to_string(),\n        ts: \"2017-12-12 11:11\".to_string(),\n        attachments: Some(attachments),\n        file: Some(File { mimetype: \"image/png\".to_string() }),\n        u: UserInfo { id: \"spec_user_id\".to_string(), username: \"spec_sender\".to_string(), name: \"spec sender\".to_string() },\n        mentions: Vec::new(),\n        channels: Vec::new(),\n        updated_at: \"2017-12-12 11:11\".to_string(),\n    })));\n    let rocketchat_message_responder = handlers::RocketchatMessageResponder { message: rocketchat_message };\n    let mut rocketchat_router = test.default_rocketchat_routes();\n    rocketchat_router.get(CHAT_GET_MESSAGE_PATH, rocketchat_message_responder, \"get_chat_message\");\n    let mut files = HashMap::new();\n    files.insert(\"image.png\".to_string(), b\"image\".to_vec());\n    rocketchat_router.get(\"/file-upload/:filename\", handlers::RocketchatFileResponder { files: files }, \"get_file\");\n\n    let test = test\n        .with_matrix_routes(matrix_router)\n        .with_rocketchat_mock()\n        .with_custom_rocketchat_routes(rocketchat_router)\n        .with_connected_admin_room()\n        .with_logged_in_user()\n        .with_bridged_room((\"spec_channel\", vec![\"spec_user\"]))\n        .run();\n\n    // discard welcome message\n    receiver.recv_timeout(default_timeout()).unwrap();\n    // discard connect message\n    receiver.recv_timeout(default_timeout()).unwrap();\n    // discard login message\n    receiver.recv_timeout(default_timeout()).unwrap();\n    // discard room bridged message\n    receiver.recv_timeout(default_timeout()).unwrap();\n\n    let message = WebhookMessage {\n        message_id: \"spec_id\".to_string(),\n        token: Some(RS_TOKEN.to_string()),\n        channel_id: \"spec_channel_id\".to_string(),\n        channel_name: Some(\"spec_channel\".to_string()),\n        user_id: \"new_user_id\".to_string(),\n        user_name: \"new_spec_user\".to_string(),\n        text: \"Uploaded an image\".to_string(),\n    };\n    let payload = to_string(&message).unwrap();\n\n    helpers::simulate_message_from_rocketchat(&test.config.as_url, &payload);\n\n    let file = create_content_receiver.recv_timeout(default_timeout()).unwrap();\n    // this would contain the image data, but for the test this was just a string converted to bytes.\n    assert_eq!(file, \"image\");\n\n    let message = receiver.recv_timeout(default_timeout()).unwrap();\n    assert!(message.contains(\"Spec titel\"));\n    assert!(message.contains(\"m.image\"));\n    let files = uploaded_files.lock().unwrap();\n    let file_id = files.first().unwrap();\n    assert!(message.contains(&format!(\"mxc://localhost/{}\", file_id)));\n}", "item_id": 2, "repo": "exul/matrix-rocketchat", "file": "tests/forward_rocketchat_channel_to_matrix.rs", "last_update_at": "2022-02-15T16:26:29+00:00", "question_id": "2b978d2c632b3c1d0402d90c490b370ec45c7979_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn successfully_forwards_an_image_from_rocketchat_to_matrix_when_the_user_is_not_registered_on_matrix() {\n    let test = Test::new();\n    let (message_forwarder, receiver) = MessageForwarder::new();\n    let uploaded_files = Arc::new(Mutex::new(Vec::new()));\n    let (create_content_forwarder, create_content_receiver) =\n        handlers::MatrixCreateContentHandler::with_forwarder(Arc::clone(&uploaded_files));\n    let mut matrix_router = test.default_matrix_routes();\n    matrix_router.put(SendMessageEventEndpoint::router_path(), message_forwarder, \"send_message_event\");\n    matrix_router.post(CreateContentEndpoint::router_path(), create_content_forwarder, \"create_content\");\n    let attachments = vec![Attachment {\n        description: \"Spec image\".to_string(),\n        image_size: Some(100),\n        image_type: Some(\"image/png\".to_string()),\n        image_url: Some(\"/file-upload/image.png\".to_string()),\n        mimetype: \"image/png\".to_string(),\n        title: \"Spec titel\".to_string(),\n        title_link: \"/file-upload/image.png\".to_string(),\n    }];\n    let rocketchat_message = Arc::new(Mutex::new(Some(Message {\n        id: \"spec_id\".to_string(),\n        rid: \"spec_rid\".to_string(),\n        msg: \"\".to_string(),\n        ts: \"2017-12-12 11:11\".to_string(),\n        attachments: Some(attachments),\n        file: Some(File { mimetype: \"image/png\".to_string() }),\n        u: UserInfo { id: \"spec_user_id\".to_string(), username: \"spec_sender\".to_string(), name: \"spec sender\".to_string() },\n        mentions: Vec::new(),\n        channels: Vec::new(),\n        updated_at: \"2017-12-12 11:11\".to_string(),\n    })));\n    let rocketchat_message_responder = handlers::RocketchatMessageResponder { message: rocketchat_message };\n    let mut rocketchat_router = test.default_rocketchat_routes();\n    rocketchat_router.get(CHAT_GET_MESSAGE_PATH, rocketchat_message_responder, \"get_chat_message\");\n    let mut files = HashMap::new();\n    files.insert(\"image.png\".to_string(), b\"image\".to_vec());\n    rocketchat_router.get(\"/file-upload/:filename\", handlers::RocketchatFileResponder { files: files }, \"get_file\");\n    let test = test\n        .with_matrix_routes(matrix_router)\n        .with_rocketchat_mock()\n        .with_custom_rocketchat_routes(rocketchat_router)\n        .with_connected_admin_room()\n        .with_logged_in_user()\n        .with_bridged_room((\"spec_channel\", vec![\"spec_user\"]))\n        .run();\n    // discard welcome message\n    receiver.recv_timeout(default_timeout()).unwrap();\n    // discard connect message\n    receiver.recv_timeout(default_timeout()).unwrap();\n    // discard login message\n    receiver.recv_timeout(default_timeout()).unwrap();\n    // discard room bridged message\n    receiver.recv_timeout(default_timeout()).unwrap();\n    let message = WebhookMessage {\n        message_id: \"spec_id\".to_string(),\n        token: Some(RS_TOKEN.to_string()),\n        channel_id: \"spec_channel_id\".to_string(),\n        channel_name: Some(\"spec_channel\".to_string()),\n        user_id: \"new_user_id\".to_string(),\n        user_name: \"new_spec_user\".to_string(),\n        text: \"Uploaded an image\".to_string(),\n    };\n    let payload = to_string(&message).unwrap();\n    helpers::simulate_message_from_rocketchat(&test.config.as_url, &payload);\n    let file = create_content_receiver.recv_timeout(default_timeout()).unwrap();\n    // this would contain the image data, but for the test this was just a string converted to bytes.\n    assert_eq!(file, \"image\");\n    let message = receiver.recv_timeout(default_timeout()).unwrap();\n    assert!(message.contains(\"Spec titel\"));\n    assert!(message.contains(\"m.image\"));\n    let files = uploaded_files.lock().unwrap();\n    let file_id = files.first().unwrap();\n    assert!(message.contains(&format!(\"mxc://localhost/{}\", file_id)));\n"]], "pred": {"ppl": 1.930307149887085, "ppl_lower": 2.1702425479888916, "ppl/lowercase_ppl": -1.178141274392742, "ppl/zlib": 0.0005578279349226327, "Min_5.0% Prob": 6.520698509964288, "Min_10.0% Prob": 4.641595833441791, "Min_20.0% Prob": 2.9761829405438665, "Min_30.0% Prob": 2.127616346369382, "Min_40.0% Prob": 1.6307522991357921, "Min_50.0% Prob": 1.313670561322669, "Min_60.0% Prob": 1.0969019547168646}}
{"hexsha": "5ba01e060b204adf10b9b18a3d1e4142b797623d", "ext": "rs", "lang": "Rust", "content": "pub fn test_mode(enabled: bool) {\n    use crate::pam::TEST_MODE;\n    let getal = if enabled { 1 } else { 0 };\n    TEST_MODE.store(getal, Ordering::SeqCst);\n}", "item_id": 0, "repo": "giganteous/webdav-server-rs", "file": "pam/src/lib.rs", "last_update_at": "2022-03-09T15:45:36+00:00", "question_id": "5ba01e060b204adf10b9b18a3d1e4142b797623d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn test_mode(enabled: bool) {\n    use crate::pam::TEST_MODE;\n    let getal = if enabled { 1 } else { 0 };\n    TEST_MODE.store(getal, Ordering::SeqCst);\n"]], "pred": {"ppl": 4.86875581741333, "ppl_lower": 7.450808048248291, "ppl/lowercase_ppl": -1.2688108002863894, "ppl/zlib": 0.012082736072394032, "Min_5.0% Prob": 10.529008865356445, "Min_10.0% Prob": 9.274935007095337, "Min_20.0% Prob": 7.123863995075226, "Min_30.0% Prob": 5.186331699291865, "Min_40.0% Prob": 4.020497926821311, "Min_50.0% Prob": 3.149564376521495, "Min_60.0% Prob": 2.6474737081978774}}
{"hexsha": "b6a707da54aee506c9801a816a90ebc2dbfa374b", "ext": "rs", "lang": "Rust", "content": "fn destroy_iface_failure() {\n        let mut exec = fasync::TestExecutor::new().expect(\"Failed to create an executor\");\n        let test_values = test_setup();\n        let mut phy_stream = fake_destroy_iface_env(&test_values.phys, &test_values.ifaces);\n\n        let destroy_fut = super::destroy_iface(&test_values.phys, &test_values.ifaces, 42);\n        pin_mut!(destroy_fut);\n        assert_eq!(Poll::Pending, exec.run_until_stalled(&mut destroy_fut));\n\n        let (req, responder) = assert_variant!(exec.run_until_stalled(&mut phy_stream.next()),\n            Poll::Ready(Some(Ok(fidl_dev::PhyRequest::DestroyIface { req, responder }))) => (req, responder)\n        );\n\n        // Verify the destroy iface request to the corresponding PHY is correct.\n        assert_eq!(0, req.id);\n\n        responder\n            .send(&mut fidl_dev::DestroyIfaceResponse { status: zx::sys::ZX_ERR_INTERNAL })\n            .expect(\"failed to send DestroyIfaceResponse\");\n        assert_eq!(\n            Poll::Ready(Err(zx::Status::INTERNAL)),\n            exec.run_until_stalled(&mut destroy_fut)\n        );\n\n        // Verify iface was not removed from available ifaces.\n        assert!(test_values.ifaces.get(&42u16).is_some(), \"iface expected to not be deleted\");\n    }", "item_id": 26, "repo": "gnoliyil/fuchsia", "file": "src/connectivity/wlan/wlandevicemonitor/src/service.rs", "last_update_at": "2022-01-08T17:06:28+00:00", "question_id": "b6a707da54aee506c9801a816a90ebc2dbfa374b_26", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn destroy_iface_failure() {\n        let mut exec = fasync::TestExecutor::new().expect(\"Failed to create an executor\");\n        let test_values = test_setup();\n        let mut phy_stream = fake_destroy_iface_env(&test_values.phys, &test_values.ifaces);\n        let destroy_fut = super::destroy_iface(&test_values.phys, &test_values.ifaces, 42);\n        pin_mut!(destroy_fut);\n        assert_eq!(Poll::Pending, exec.run_until_stalled(&mut destroy_fut));\n        let (req, responder) = assert_variant!(exec.run_until_stalled(&mut phy_stream.next()),\n            Poll::Ready(Some(Ok(fidl_dev::PhyRequest::DestroyIface { req, responder }))) => (req, responder)\n        );\n        // Verify the destroy iface request to the corresponding PHY is correct.\n        assert_eq!(0, req.id);\n        responder\n            .send(&mut fidl_dev::DestroyIfaceResponse { status: zx::sys::ZX_ERR_INTERNAL })\n            .expect(\"failed to send DestroyIfaceResponse\");\n        assert_eq!(\n            Poll::Ready(Err(zx::Status::INTERNAL)),\n            exec.run_until_stalled(&mut destroy_fut)\n        );\n        // Verify iface was not removed from available ifaces.\n        assert!(test_values.ifaces.get(&42u16).is_some(), \"iface expected to not be deleted\");\n"]], "pred": {"ppl": 1.9055334329605103, "ppl_lower": 3.192270040512085, "ppl/lowercase_ppl": -1.8002492379213733, "ppl/zlib": 0.0012188317328605705, "Min_5.0% Prob": 6.206919252872467, "Min_10.0% Prob": 4.485446059703827, "Min_20.0% Prob": 2.9241921313107015, "Min_30.0% Prob": 2.1015810730556646, "Min_40.0% Prob": 1.6067693355493247, "Min_50.0% Prob": 1.2913463957142084, "Min_60.0% Prob": 1.0769994924747153}}
{"hexsha": "7f05c250eb491a42bf847b1c2b9e52d9f45b49d7", "ext": "rs", "lang": "Rust", "content": "fn non_empty_array_set_slice_begin_non_empty_drain_0() {\n        let mut ary = SmallArray::from([1, 2, 3, 4, 5]);\n        let drained = ary.set_slice(0, 0, &[7, 8, 9]);\n        assert_eq!(drained, 0);\n        assert_eq!(ary, [7, 8, 9, 1, 2, 3, 4, 5]);\n    }", "item_id": 45, "repo": "b-n/artichoke", "file": "spinoso-array/src/array/smallvec/mod.rs", "last_update_at": "2022-02-28T08:45:47+00:00", "question_id": "7f05c250eb491a42bf847b1c2b9e52d9f45b49d7_45", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn non_empty_array_set_slice_begin_non_empty_drain_0() {\n        let mut ary = SmallArray::from([1, 2, 3, 4, 5]);\n        let drained = ary.set_slice(0, 0, &[7, 8, 9]);\n        assert_eq!(drained, 0);\n        assert_eq!(ary, [7, 8, 9, 1, 2, 3, 4, 5]);\n"]], "pred": {"ppl": 2.6669085025787354, "ppl_lower": 2.899186372756958, "ppl/lowercase_ppl": -1.085134572110828, "ppl/zlib": 0.006208354033967098, "Min_5.0% Prob": 7.6216780344645185, "Min_10.0% Prob": 6.161190231641133, "Min_20.0% Prob": 4.218882143497467, "Min_30.0% Prob": 3.0426522203393884, "Min_40.0% Prob": 2.397542819076655, "Min_50.0% Prob": 1.9382491611665296, "Min_60.0% Prob": 1.6384672755627214}}
{"hexsha": "964e7adc38a85ccc5250e28810827bb190b96dcb", "ext": "rs", "lang": "Rust", "content": "pub fn read(file: &Option<PathBuf>) -> Result<String, io::Error> {\n    // TODO: stream instead of reading everything into string\n    let mut contents = String::new();\n\n    if let Some(path) = file {\n        File::open(&path)?.read_to_string(&mut contents)?;\n    } else {\n        stdin().read_to_string(&mut contents)?;\n    };\n\n    Ok(contents)\n}", "item_id": 2, "repo": "comprakt/comprakt", "file": "runner-integration-tests/src/lookup.rs", "last_update_at": "2022-01-15T07:39:33+00:00", "question_id": "964e7adc38a85ccc5250e28810827bb190b96dcb_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn read(file: &Option<PathBuf>) -> Result<String, io::Error> {\n    // TODO: stream instead of reading everything into string\n    let mut contents = String::new();\n    if let Some(path) = file {\n        File::open(&path)?.read_to_string(&mut contents)?;\n    } else {\n        stdin().read_to_string(&mut contents)?;\n    };\n    Ok(contents)\n"]], "pred": {"ppl": 2.495290994644165, "ppl_lower": 3.636845111846924, "ppl/lowercase_ppl": -1.411973993081856, "ppl/zlib": 0.004313232799634469, "Min_5.0% Prob": 8.199564552307129, "Min_10.0% Prob": 6.019637107849121, "Min_20.0% Prob": 4.057899327505202, "Min_30.0% Prob": 2.9655781276524067, "Min_40.0% Prob": 2.2716487460704737, "Min_50.0% Prob": 1.8219844621640664, "Min_60.0% Prob": 1.5414569579879753}}
{"hexsha": "5252b70b49975622f4c6f984caaee8c728d24b2a", "ext": "rs", "lang": "Rust", "content": "fn test_user_data() {\n        let user_data = Box::new(10u8);\n        let mut inner: io_uring_sqe = unsafe { std::mem::zeroed() };\n        inner.user_data = Box::into_raw(user_data) as u64;\n\n        let sqe: Sqe = Sqe::new(inner);\n\n        assert_eq!(unsafe { sqe.user_data::<u8>() }, 10);\n    }", "item_id": 0, "repo": "cmarincia/firecracker", "file": "src/io_uring/src/operation/sqe.rs", "last_update_at": "2022-02-16T03:19:52+00:00", "question_id": "5252b70b49975622f4c6f984caaee8c728d24b2a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_user_data() {\n        let user_data = Box::new(10u8);\n        let mut inner: io_uring_sqe = unsafe { std::mem::zeroed() };\n        inner.user_data = Box::into_raw(user_data) as u64;\n        let sqe: Sqe = Sqe::new(inner);\n        assert_eq!(unsafe { sqe.user_data::<u8>() }, 10);\n"]], "pred": {"ppl": 2.398174524307251, "ppl_lower": 2.975335121154785, "ppl/lowercase_ppl": -1.246538143594631, "ppl/zlib": 0.004941852164224096, "Min_5.0% Prob": 7.290236091613769, "Min_10.0% Prob": 5.190065969120372, "Min_20.0% Prob": 3.5322480098060938, "Min_30.0% Prob": 2.6773725952420917, "Min_40.0% Prob": 2.1179761975369553, "Min_50.0% Prob": 1.7324704990043478, "Min_60.0% Prob": 1.4714200936790023}}
{"hexsha": "c42042139752649ce8a3fb1d87121eb546da2213", "ext": "rs", "lang": "Rust", "content": "fn test_seq_emitting() {\n    let vec = vec![vec![1u64, 2], vec![3, 4]];\n\n    let mut driver = SerializeDriver::new(&vec);\n    let mut events = Vec::new();\n    while let Some((event, _, _)) = driver.next().unwrap() {\n        events.push(event.to_static());\n    }\n\n    assert_eq!(\n        events,\n        vec![\n            Event::SeqStart,\n            Event::SeqStart,\n            1u64.into(),\n            2u64.into(),\n            Event::SeqEnd,\n            Event::SeqStart,\n            3u64.into(),\n            4u64.into(),\n            Event::SeqEnd,\n            Event::SeqEnd,\n        ],\n    );\n}", "item_id": 0, "repo": "mitsuhiko/deser", "file": "deser/src/ser/driver.rs", "last_update_at": "2022-03-16T17:06:33+00:00", "question_id": "c42042139752649ce8a3fb1d87121eb546da2213_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_seq_emitting() {\n    let vec = vec![vec![1u64, 2], vec![3, 4]];\n    let mut driver = SerializeDriver::new(&vec);\n    let mut events = Vec::new();\n    while let Some((event, _, _)) = driver.next().unwrap() {\n        events.push(event.to_static());\n    }\n    assert_eq!(\n        events,\n        vec![\n            Event::SeqStart,\n            Event::SeqStart,\n            1u64.into(),\n            2u64.into(),\n            Event::SeqEnd,\n            Event::SeqStart,\n            3u64.into(),\n            4u64.into(),\n            Event::SeqEnd,\n            Event::SeqEnd,\n        ],\n    );\n"]], "pred": {"ppl": 2.1110334396362305, "ppl_lower": 2.7518556118011475, "ppl/lowercase_ppl": -1.3547989652187857, "ppl/zlib": 0.0030007132907716016, "Min_5.0% Prob": 8.042026890648735, "Min_10.0% Prob": 5.646918334459004, "Min_20.0% Prob": 3.46378692984581, "Min_30.0% Prob": 2.4501944220902625, "Min_40.0% Prob": 1.8577135751967306, "Min_50.0% Prob": 1.4985384907146606, "Min_60.0% Prob": 1.2532231391164597}}
{"hexsha": "61ba86b714a91e7ff1570d03834ee26b4b252164", "ext": "rs", "lang": "Rust", "content": "fn mandelbrot() -> Result<(), Box<dyn std::error::Error>> {\n    let mut cmd = Command::cargo_bin(\"rocklang\")?;\n\n    cmd.arg(\"examples/mandelbrot.rc\");\n    cmd.assert().success().stdout(\n        predicate::eq(\n            \"...............*..............\n...............*..............\n...............*..............\n..............***.............\n.............*****............\n.............*****............\n.............*****............\n..............***.............\n.............*****............\n...........*********..........\n.........*************........\n..........***********.........\n.........*************........\n.......*****************......\n.......*****************......\n.....*...*************...*....\n.........*************........\n..........***********.........\n..........*****.*****.........\n..............................\n..............................\n..............................\n..............................\n..............................\n..............................\n..............................\n..............................\n..............................\n..............................\n..............................\n\",\n        )\n        .normalize(),\n    );\n\n    Ok(())\n}", "item_id": 1, "repo": "oczekrb/rocklang", "file": "tests/integration_tests.rs", "last_update_at": "2022-03-25T13:45:38+00:00", "question_id": "61ba86b714a91e7ff1570d03834ee26b4b252164_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn mandelbrot() -> Result<(), Box<dyn std::error::Error>> {\n    let mut cmd = Command::cargo_bin(\"rocklang\")?;\n    cmd.arg(\"examples/mandelbrot.rc\");\n    cmd.assert().success().stdout(\n        predicate::eq(\n            \"...............*..............\n...............*..............\n...............*..............\n..............***.............\n.............*****............\n.............*****............\n.............*****............\n..............***.............\n.............*****............\n...........*********..........\n.........*************........\n..........***********.........\n.........*************........\n.......*****************......\n.......*****************......\n.....*...*************...*....\n.........*************........\n..........***********.........\n..........*****.*****.........\n..............................\n..............................\n..............................\n..............................\n..............................\n..............................\n..............................\n..............................\n..............................\n..............................\n..............................\n\",\n        )\n        .normalize(),\n    );\n    Ok(())\n"]], "pred": {"ppl": 2.254985809326172, "ppl_lower": 2.562657356262207, "ppl/lowercase_ppl": -1.157292091300875, "ppl/zlib": 0.003151719689740693, "Min_5.0% Prob": 7.28268449647086, "Min_10.0% Prob": 5.427397456662408, "Min_20.0% Prob": 3.533597526879146, "Min_30.0% Prob": 2.5739078638197364, "Min_40.0% Prob": 2.001351169342625, "Min_50.0% Prob": 1.6107391085832903, "Min_60.0% Prob": 1.3515406628591673}}
{"hexsha": "a1fbd456fd2ee1579a62e2f316832dec00221fbc", "ext": "rs", "lang": "Rust", "content": "async fn glob_leading_double_star() {\n\tlet filterer = filt(&[\"**/possum\"], &[], &[]).await;\n\n\tfilterer.file_does_pass(\"possum\");\n\tfilterer.file_does_pass(\"foo/bar/possum\");\n\tfilterer.file_does_pass(\"/foo/bar/possum\");\n\tfilterer.dir_does_pass(\"possum\");\n\tfilterer.dir_does_pass(\"foo/bar/possum\");\n\tfilterer.dir_does_pass(\"/foo/bar/possum\");\n\tfilterer.file_doesnt_pass(\"rat\");\n\tfilterer.file_doesnt_pass(\"foo/bar/rat\");\n\tfilterer.file_doesnt_pass(\"/foo/bar/rat\");\n}", "item_id": 6, "repo": "abitrolly/watchexec", "file": "lib/tests/filter_globset.rs", "last_update_at": "2022-01-20T21:13:31+00:00", "question_id": "a1fbd456fd2ee1579a62e2f316832dec00221fbc_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn glob_leading_double_star() {\n\tlet filterer = filt(&[\"**/possum\"], &[], &[]).await;\n\tfilterer.file_does_pass(\"possum\");\n\tfilterer.file_does_pass(\"foo/bar/possum\");\n\tfilterer.file_does_pass(\"/foo/bar/possum\");\n\tfilterer.dir_does_pass(\"possum\");\n\tfilterer.dir_does_pass(\"foo/bar/possum\");\n\tfilterer.dir_does_pass(\"/foo/bar/possum\");\n\tfilterer.file_doesnt_pass(\"rat\");\n\tfilterer.file_doesnt_pass(\"foo/bar/rat\");\n\tfilterer.file_doesnt_pass(\"/foo/bar/rat\");\n"]], "pred": {"ppl": 2.554354667663574, "ppl_lower": 2.554354667663574, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.005898110789282986, "Min_5.0% Prob": 8.717642996046278, "Min_10.0% Prob": 7.033447610007392, "Min_20.0% Prob": 4.3903974230225025, "Min_30.0% Prob": 3.087078365364245, "Min_40.0% Prob": 2.358175009589743, "Min_50.0% Prob": 1.882411151082926, "Min_60.0% Prob": 1.5651241247999548}}
{"hexsha": "b3bffd2d765dbc06616b7219943d68de1663a301", "ext": "rs", "lang": "Rust", "content": "async fn document_symbol() {\n            let (service, _) = LspService::new(|_| Mock::default());\n            let mut service = Spawn::new(service);\n\n            super::helper::initialize(&mut service).await;\n\n            let params = lsp::DocumentSymbolParams {\n                text_document: lsp::TextDocumentIdentifier {\n                    uri: lsp::Url::parse(\"inmemory::///test\").unwrap(),\n                },\n                work_done_progress_params: Default::default(),\n                partial_result_params: Default::default(),\n            };\n            let request: Incoming = helper::request(\"textDocument/documentSymbol\", params).unwrap();\n            let response = Response::error(Some(Id::Number(1)), Error::method_not_found());\n            assert_eq!(service.poll_ready(), Poll::Ready(Ok(())));\n            assert_eq!(\n                service.call(request.clone()).await,\n                Ok(Some(Outgoing::Response(response)))\n            );\n        }", "item_id": 27, "repo": "attliaLin/lspower", "file": "src/lib.rs", "last_update_at": "2022-03-26T08:17:19+00:00", "question_id": "b3bffd2d765dbc06616b7219943d68de1663a301_27", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn document_symbol() {\n            let (service, _) = LspService::new(|_| Mock::default());\n            let mut service = Spawn::new(service);\n            super::helper::initialize(&mut service).await;\n            let params = lsp::DocumentSymbolParams {\n                text_document: lsp::TextDocumentIdentifier {\n                    uri: lsp::Url::parse(\"inmemory::///test\").unwrap(),\n                },\n                work_done_progress_params: Default::default(),\n                partial_result_params: Default::default(),\n            };\n            let request: Incoming = helper::request(\"textDocument/documentSymbol\", params).unwrap();\n            let response = Response::error(Some(Id::Number(1)), Error::method_not_found());\n            assert_eq!(service.poll_ready(), Poll::Ready(Ok(())));\n            assert_eq!(\n                service.call(request.clone()).await,\n                Ok(Some(Outgoing::Response(response)))\n            );\n"]], "pred": {"ppl": 2.6924588680267334, "ppl_lower": 4.511788845062256, "ppl/lowercase_ppl": -1.521213924446098, "ppl/zlib": 0.0023250113930348066, "Min_5.0% Prob": 8.566497672687877, "Min_10.0% Prob": 6.3194749977277676, "Min_20.0% Prob": 4.282775305687113, "Min_30.0% Prob": 3.121567752999319, "Min_40.0% Prob": 2.42374688888851, "Min_50.0% Prob": 1.9666400285077696, "Min_60.0% Prob": 1.6568392605428965}}
{"hexsha": "215c9a8a58f67f74eb17900120110f25c10d05a7", "ext": "rs", "lang": "Rust", "content": "pub fn trimesh_area_and_center_of_mass(\n    vertices: &[Point<Real>],\n    indices: &[[u32; 3]],\n) -> (Real, Point<Real>) {\n    let mut res = Point::origin();\n    let mut areasum = 0.0;\n\n    for idx in indices {\n        let triangle = Triangle::new(\n            vertices[idx[0] as usize],\n            vertices[idx[1] as usize],\n            vertices[idx[2] as usize],\n        );\n        let area = triangle.area();\n        let center = triangle.center();\n\n        res += center.coords * area;\n        areasum += area;\n    }\n\n    if areasum == 0.0 {\n        (areasum, res)\n    } else {\n        (areasum, res / areasum)\n    }\n}", "item_id": 0, "repo": "bellwether-softworks/parry", "file": "src/mass_properties/mass_properties_trimesh.rs", "last_update_at": "2022-03-26T06:25:32+00:00", "question_id": "215c9a8a58f67f74eb17900120110f25c10d05a7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn trimesh_area_and_center_of_mass(\n    vertices: &[Point<Real>],\n    indices: &[[u32; 3]],\n) -> (Real, Point<Real>) {\n    let mut res = Point::origin();\n    let mut areasum = 0.0;\n    for idx in indices {\n        let triangle = Triangle::new(\n            vertices[idx[0] as usize],\n            vertices[idx[1] as usize],\n            vertices[idx[2] as usize],\n        );\n        let area = triangle.area();\n        let center = triangle.center();\n        res += center.coords * area;\n        areasum += area;\n    }\n    if areasum == 0.0 {\n        (areasum, res)\n    } else {\n        (areasum, res / areasum)\n    }\n"]], "pred": {"ppl": 1.683603286743164, "ppl_lower": 1.892087697982788, "ppl/lowercase_ppl": -1.2241051528991655, "ppl/zlib": 0.001880636498641889, "Min_5.0% Prob": 6.321619653701783, "Min_10.0% Prob": 4.104261301812672, "Min_20.0% Prob": 2.4581841372308277, "Min_30.0% Prob": 1.7217674867974386, "Min_40.0% Prob": 1.2979438024408676, "Min_50.0% Prob": 1.0447503516696535, "Min_60.0% Prob": 0.8732233789463447}}
{"hexsha": "606daf72d736c3733db174fdf1211797033d2d8d", "ext": "rs", "lang": "Rust", "content": "fn webpage(name: String, visitor: State<VisitorCounter>) -> Template {\n    let mut context = HashMap::new();\n    context.insert(\"name\", name);\n    let current = visitor.visitor_number.fetch_add(1, Ordering::SeqCst);\n    context.insert(\"visitor_number\", current.to_string());\n    Template::render(\"webpage\", &context)\n}", "item_id": 0, "repo": "d2r/Network-Programming-with-Rust", "file": "Chapter06/ch6/rocket-templates/src/main.rs", "last_update_at": "2022-03-13T16:13:46+00:00", "question_id": "606daf72d736c3733db174fdf1211797033d2d8d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn webpage(name: String, visitor: State<VisitorCounter>) -> Template {\n    let mut context = HashMap::new();\n    context.insert(\"name\", name);\n    let current = visitor.visitor_number.fetch_add(1, Ordering::SeqCst);\n    context.insert(\"visitor_number\", current.to_string());\n    Template::render(\"webpage\", &context)\n"]], "pred": {"ppl": 3.245577573776245, "ppl_lower": 5.431982517242432, "ppl/lowercase_ppl": -1.4374532994384392, "ppl/zlib": 0.005771045701740074, "Min_5.0% Prob": 10.182326078414917, "Min_10.0% Prob": 7.50036006503635, "Min_20.0% Prob": 5.012291563881768, "Min_30.0% Prob": 3.656098025185721, "Min_40.0% Prob": 2.89191401568619, "Min_50.0% Prob": 2.323688528639205, "Min_60.0% Prob": 1.96824661336307}}
{"hexsha": "a20411a6bb3d23bb6b558c1a248eb567801b08d1", "ext": "rs", "lang": "Rust", "content": "fn fetch_markets_raw() -> Vec<FtxMarket> {\n    let txt = http_get(\"https://ftx.com/api/markets\").unwrap();\n    let resp = serde_json::from_str::<Response>(&txt).unwrap();\n    assert!(resp.success);\n    resp.result\n}", "item_id": 0, "repo": "CPT-Jack-A-Castle/crypto-crawler-rs", "file": "crypto-pair/tests/ftx.rs", "last_update_at": "2022-03-23T03:36:51+00:00", "question_id": "a20411a6bb3d23bb6b558c1a248eb567801b08d1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn fetch_markets_raw() -> Vec<FtxMarket> {\n    let txt = http_get(\"https://ftx.com/api/markets\").unwrap();\n    let resp = serde_json::from_str::<Response>(&txt).unwrap();\n    assert!(resp.success);\n    resp.result\n"]], "pred": {"ppl": 2.5488247871398926, "ppl_lower": 3.6089582443237305, "ppl/lowercase_ppl": -1.3717130532136084, "ppl/zlib": 0.005740075982514464, "Min_5.0% Prob": 8.416788101196289, "Min_10.0% Prob": 6.670471395765032, "Min_20.0% Prob": 4.353852796554565, "Min_30.0% Prob": 3.0451657448125924, "Min_40.0% Prob": 2.374781678120295, "Min_50.0% Prob": 1.8888964212842678, "Min_60.0% Prob": 1.5647040855584908}}
{"hexsha": "d574411007b66f532420634a3d0cc4ba2b332053", "ext": "rs", "lang": "Rust", "content": "async fn handle_after_timeout<T: Node + Debug>(state: &mut RaftElectionState<T>) {\n    //don't start election there isn't enough nodes.\n    if state.peers.len() < state.min_node {\n        trace!(\"[node: {}] not enough node\", &state.self_id);\n        return;\n    }\n\n    if state.has_leader || (state.node_state == NodeState::Leader) {\n        // let's reset has_leader to false.\n        // some external process(or message) should set the flag to true on heartbeat message.\n        // has_leader after timeout means no heartbeat was received from the leader\n        // during timout\n        state.has_leader = false | (state.node_state == NodeState::Leader);\n        return;\n    }\n\n    //has no leader or initializing the raft system\n    //promote to Candidate\n    // if candidate, just restart the voting process.\n    if matches!(state.node_state, NodeState::Follower | NodeState::Candidate) {\n        debug!(\n            \"[node: {}] updating node state to NodeState::Candidate\",\n            &state.self_id\n        );\n        trace!(\n            \"[node: {}] updating term from {} to {}\",\n            &state.self_id,\n            &state.term,\n            state.term + 1\n        );\n        state.term += 1;\n        state.node_state = NodeState::Candidate;\n        //self vote\n        state.votes = 1;\n        //ask peers to vote\n        for peer in state.peers.iter() {\n            let msg = Message::RequestVote {\n                node_id: state.self_id.clone(),\n                term: state.term,\n            };\n            trace!(\n                \"[node: {}] sending vote request for term {} to: {:?}\",\n                &state.self_id,\n                &state.term,\n                peer\n            );\n            peer.send_message(msg).await;\n        }\n    }\n    if state.votes > (state.peers.len() + 1) / 2 {\n        state.node_state = NodeState::Leader;\n        // for peer in state.peers.iter() {\n        //     peer.send_message(Message::LeaderAnnouncement(state.self_id.clone()))\n        //         .await;\n        // }\n        let result = state\n            .tx\n            .send_timeout(\n                Message::ControlLeaderChanged(state.self_id.clone()),\n                Duration::from_millis(state.message_timeout),\n            )\n            .await;\n        log_error!(result);\n    }\n}", "item_id": 4, "repo": "eipi1/almost-raft", "file": "src/election/mod.rs", "last_update_at": "2022-03-27T18:46:36+00:00", "question_id": "d574411007b66f532420634a3d0cc4ba2b332053_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn handle_after_timeout<T: Node + Debug>(state: &mut RaftElectionState<T>) {\n    //don't start election there isn't enough nodes.\n    if state.peers.len() < state.min_node {\n        trace!(\"[node: {}] not enough node\", &state.self_id);\n        return;\n    }\n    if state.has_leader || (state.node_state == NodeState::Leader) {\n        // let's reset has_leader to false.\n        // some external process(or message) should set the flag to true on heartbeat message.\n        // has_leader after timeout means no heartbeat was received from the leader\n        // during timout\n        state.has_leader = false | (state.node_state == NodeState::Leader);\n        return;\n    }\n    //has no leader or initializing the raft system\n    //promote to Candidate\n    // if candidate, just restart the voting process.\n    if matches!(state.node_state, NodeState::Follower | NodeState::Candidate) {\n        debug!(\n            \"[node: {}] updating node state to NodeState::Candidate\",\n            &state.self_id\n        );\n        trace!(\n            \"[node: {}] updating term from {} to {}\",\n            &state.self_id,\n            &state.term,\n            state.term + 1\n        );\n        state.term += 1;\n        state.node_state = NodeState::Candidate;\n        //self vote\n        state.votes = 1;\n        //ask peers to vote\n        for peer in state.peers.iter() {\n            let msg = Message::RequestVote {\n                node_id: state.self_id.clone(),\n                term: state.term,\n            };\n            trace!(\n                \"[node: {}] sending vote request for term {} to: {:?}\",\n                &state.self_id,\n                &state.term,\n                peer\n            );\n            peer.send_message(msg).await;\n        }\n    }\n    if state.votes > (state.peers.len() + 1) / 2 {\n        state.node_state = NodeState::Leader;\n        // for peer in state.peers.iter() {\n        //     peer.send_message(Message::LeaderAnnouncement(state.self_id.clone()))\n        //         .await;\n        // }\n        let result = state\n            .tx\n            .send_timeout(\n                Message::ControlLeaderChanged(state.self_id.clone()),\n                Duration::from_millis(state.message_timeout),\n            )\n            .await;\n        log_error!(result);\n    }\n"]], "pred": {"ppl": 2.862351655960083, "ppl_lower": 3.1505463123321533, "ppl/lowercase_ppl": -1.0912213330408818, "ppl/zlib": 0.0012967244689175111, "Min_5.0% Prob": 7.928858381329161, "Min_10.0% Prob": 6.22940993309021, "Min_20.0% Prob": 4.368823907429114, "Min_30.0% Prob": 3.307382338310606, "Min_40.0% Prob": 2.5852937493893435, "Min_50.0% Prob": 2.0916054343004844, "Min_60.0% Prob": 1.7523608697125488}}
{"hexsha": "7231263198f52eee4d269390002eab6c1ea91c43", "ext": "rs", "lang": "Rust", "content": "fn fetch_stream(stream: String) -> Vec<String> {\n        let query = format!(\"%7Btest_name%3D\\\"{}\\\"%7D\", stream);\n        let query = format!(\n            \"http://localhost:3100/loki/api/v1/query_range?query={}&direction=forward\",\n            query\n        );\n        let mut res = reqwest::get(&query).unwrap();\n\n        assert_eq!(res.status(), 200);\n\n        // The response type follows this api https://github.com/grafana/loki/blob/master/docs/api.md#get-lokiapiv1query_range\n        // where the result type is `streams`.\n        let data = res.json::<serde_json::Value>().unwrap();\n\n        // TODO: clean this up or explain it via docs\n        let results = data\n            .get(\"data\")\n            .unwrap()\n            .get(\"result\")\n            .unwrap()\n            .as_array()\n            .unwrap();\n\n        let values = results[0].get(\"values\").unwrap().as_array().unwrap();\n\n        values\n            .iter()\n            // Lets check the message field of the array where\n            // the array looks like: [ts, line].\n            .map(|v| v[1].as_str().unwrap().to_string())\n            .collect::<Vec<_>>()\n    }", "item_id": 5, "repo": "alathon/vector", "file": "src/sinks/loki.rs", "last_update_at": "2022-02-27T18:33:25+00:00", "question_id": "7231263198f52eee4d269390002eab6c1ea91c43_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn fetch_stream(stream: String) -> Vec<String> {\n        let query = format!(\"%7Btest_name%3D\\\"{}\\\"%7D\", stream);\n        let query = format!(\n            \"http://localhost:3100/loki/api/v1/query_range?query={}&direction=forward\",\n            query\n        );\n        let mut res = reqwest::get(&query).unwrap();\n        assert_eq!(res.status(), 200);\n        // The response type follows this api https://github.com/grafana/loki/blob/master/docs/api.md#get-lokiapiv1query_range\n        // where the result type is `streams`.\n        let data = res.json::<serde_json::Value>().unwrap();\n        // TODO: clean this up or explain it via docs\n        let results = data\n            .get(\"data\")\n            .unwrap()\n            .get(\"result\")\n            .unwrap()\n            .as_array()\n            .unwrap();\n        let values = results[0].get(\"values\").unwrap().as_array().unwrap();\n        values\n            .iter()\n            // Lets check the message field of the array where\n            // the array looks like: [ts, line].\n            .map(|v| v[1].as_str().unwrap().to_string())\n            .collect::<Vec<_>>()\n"]], "pred": {"ppl": 2.8411877155303955, "ppl_lower": 3.2250778675079346, "ppl/lowercase_ppl": -1.1213677736216485, "ppl/zlib": 0.0019337447674844738, "Min_5.0% Prob": 7.272659217610078, "Min_10.0% Prob": 5.673208404989803, "Min_20.0% Prob": 4.21905773527482, "Min_30.0% Prob": 3.2529762235342288, "Min_40.0% Prob": 2.5505262766690815, "Min_50.0% Prob": 2.074015028161161, "Min_60.0% Prob": 1.7374144715037854}}
{"hexsha": "bad08a39a07f57fab14230c4b1270c20a16a6a3e", "ext": "rs", "lang": "Rust", "content": "pub async fn update(client: &Client, id: String, peer_urls: Vec<String>) -> EtcdMembersResult {\n    let peer_urls = PeerUrls { peer_urls };\n    let body = serde_json::to_string(&peer_urls).map_err(|e| vec![e.into()])?;\n\n    client\n        .first_ok(|client, endpoint| {\n            let url = build_url(endpoint, &format!(\"/{}\", id));\n            let body = body.clone();\n            async move {\n                let response = client.http_client().put(url).body(body).send().await?;\n                parse_empty_response(response).await\n            }\n        })\n        .await\n}", "item_id": 1, "repo": "discord/rust-etcd", "file": "src/members.rs", "last_update_at": "2022-03-23T13:57:00+00:00", "question_id": "bad08a39a07f57fab14230c4b1270c20a16a6a3e_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn update(client: &Client, id: String, peer_urls: Vec<String>) -> EtcdMembersResult {\n    let peer_urls = PeerUrls { peer_urls };\n    let body = serde_json::to_string(&peer_urls).map_err(|e| vec![e.into()])?;\n    client\n        .first_ok(|client, endpoint| {\n            let url = build_url(endpoint, &format!(\"/{}\", id));\n            let body = body.clone();\n            async move {\n                let response = client.http_client().put(url).body(body).send().await?;\n                parse_empty_response(response).await\n            }\n        })\n        .await\n"]], "pred": {"ppl": 3.1710779666900635, "ppl_lower": 3.972414970397949, "ppl/lowercase_ppl": -1.1952241397833563, "ppl/zlib": 0.003663719310057237, "Min_5.0% Prob": 9.713509440422058, "Min_10.0% Prob": 7.241786942762487, "Min_20.0% Prob": 4.794325631005424, "Min_30.0% Prob": 3.597191482782364, "Min_40.0% Prob": 2.7897627357925687, "Min_50.0% Prob": 2.2929038768527152, "Min_60.0% Prob": 1.9162150771490165}}
{"hexsha": "f48cc0114fdd889f94a6dc5ec25f0093359096c9", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let firebase = Firebase::new(\"https://shining-torch-7752.firebaseio.com\").ok().unwrap();\n    let messages = firebase.at(\"/api/messages\").ok().unwrap();\n\n    let res = messages.push(serde_json::json!({\"name\":\"David\",\"message\":\"Hello from Rust\"})).ok().unwrap();\n\n    println!(\"Response body: {:?}\", res.body);\n    println!(\"Response code: {:?}\", res.code);\n    println!(\"Response success: {:?}\", res.is_success());\n}", "item_id": 0, "repo": "GT3CH1/rust-firebase", "file": "examples/push_data.rs", "last_update_at": "2022-03-19T12:26:29+00:00", "question_id": "f48cc0114fdd889f94a6dc5ec25f0093359096c9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let firebase = Firebase::new(\"https://shining-torch-7752.firebaseio.com\").ok().unwrap();\n    let messages = firebase.at(\"/api/messages\").ok().unwrap();\n    let res = messages.push(serde_json::json!({\"name\":\"David\",\"message\":\"Hello from Rust\"})).ok().unwrap();\n    println!(\"Response body: {:?}\", res.body);\n    println!(\"Response code: {:?}\", res.code);\n    println!(\"Response success: {:?}\", res.is_success());\n"]], "pred": {"ppl": 2.88981032371521, "ppl_lower": 3.040290594100952, "ppl/lowercase_ppl": -1.0478351581278702, "ppl/zlib": 0.004458785159823605, "Min_5.0% Prob": 7.748101234436035, "Min_10.0% Prob": 6.060957395113432, "Min_20.0% Prob": 4.14026923974355, "Min_30.0% Prob": 3.174079845845699, "Min_40.0% Prob": 2.5254326628314123, "Min_50.0% Prob": 2.09792789016197, "Min_60.0% Prob": 1.7576257966366815}}
{"hexsha": "8ee46090be0a408028a1b29311cd8a419a713217", "ext": "rs", "lang": "Rust", "content": "fn fake_pors_subset() -> [usize; PORS_K] {\n        let seed = hash::tests::HASH_ELEMENT;\n        let prng = prng::Prng::new(&seed);\n        let address = address::Address::new(0, 0);\n\n        let mut subset: [usize; PORS_K] = [0; PORS_K];\n        let mut count = 0;\n        let mut counter = 1;\n        let mut block = Default::default();\n\n        'outer: while count < PORS_K {\n            prng.genblock(&mut block, &address, counter);\n            'inner: for i in 0..8 {\n                let x = BigEndian::read_u32(array_ref![block.h, 4 * i, 4]) as usize;\n                let x = x % PORS_T;\n\n                for i in 0..count {\n                    if subset[i] == x {\n                        continue 'inner;\n                    }\n                }\n\n                subset[count] = x;\n                count += 1;\n                if count == PORS_K {\n                    break 'outer;\n                }\n            }\n            counter += 1;\n        }\n\n        subset.sort();\n        subset\n    }", "item_id": 9, "repo": "gendx/gravity-rs", "file": "src/octopus.rs", "last_update_at": "2022-01-02T03:46:10+00:00", "question_id": "8ee46090be0a408028a1b29311cd8a419a713217_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn fake_pors_subset() -> [usize; PORS_K] {\n        let seed = hash::tests::HASH_ELEMENT;\n        let prng = prng::Prng::new(&seed);\n        let address = address::Address::new(0, 0);\n        let mut subset: [usize; PORS_K] = [0; PORS_K];\n        let mut count = 0;\n        let mut counter = 1;\n        let mut block = Default::default();\n        'outer: while count < PORS_K {\n            prng.genblock(&mut block, &address, counter);\n            'inner: for i in 0..8 {\n                let x = BigEndian::read_u32(array_ref![block.h, 4 * i, 4]) as usize;\n                let x = x % PORS_T;\n                for i in 0..count {\n                    if subset[i] == x {\n                        continue 'inner;\n                    }\n                }\n                subset[count] = x;\n                count += 1;\n                if count == PORS_K {\n                    break 'outer;\n                }\n            }\n            counter += 1;\n        }\n        subset.sort();\n        subset\n"]], "pred": {"ppl": 2.5924971103668213, "ppl_lower": 2.7859954833984375, "ppl/lowercase_ppl": -1.0755638038357933, "ppl/zlib": 0.0023875226729531806, "Min_5.0% Prob": 8.02829999923706, "Min_10.0% Prob": 6.377585434913636, "Min_20.0% Prob": 4.192409736211182, "Min_30.0% Prob": 3.045042077484338, "Min_40.0% Prob": 2.3520511576557546, "Min_50.0% Prob": 1.9020566424814525, "Min_60.0% Prob": 1.5891256328974221}}
{"hexsha": "a5697097b716f587bfe10a7d599e122f2aa6d0c6", "ext": "rs", "lang": "Rust", "content": "pub fn serialize_structure_crate_model_transit_gateway_request_options(\n    mut writer: aws_smithy_query::QueryValueWriter,\n    input: &crate::model::TransitGatewayRequestOptions,\n) -> Result<(), aws_smithy_http::operation::SerializationError> {\n    #[allow(unused_mut)]\n    let mut scope_318 = writer.prefix(\"AmazonSideAsn\");\n    if let Some(var_319) = &input.amazon_side_asn {\n        scope_318.number(\n            #[allow(clippy::useless_conversion)]\n            aws_smithy_types::Number::NegInt((*var_319).into()),\n        );\n    }\n    #[allow(unused_mut)]\n    let mut scope_320 = writer.prefix(\"AutoAcceptSharedAttachments\");\n    if let Some(var_321) = &input.auto_accept_shared_attachments {\n        scope_320.string(var_321.as_str());\n    }\n    #[allow(unused_mut)]\n    let mut scope_322 = writer.prefix(\"DefaultRouteTableAssociation\");\n    if let Some(var_323) = &input.default_route_table_association {\n        scope_322.string(var_323.as_str());\n    }\n    #[allow(unused_mut)]\n    let mut scope_324 = writer.prefix(\"DefaultRouteTablePropagation\");\n    if let Some(var_325) = &input.default_route_table_propagation {\n        scope_324.string(var_325.as_str());\n    }\n    #[allow(unused_mut)]\n    let mut scope_326 = writer.prefix(\"VpnEcmpSupport\");\n    if let Some(var_327) = &input.vpn_ecmp_support {\n        scope_326.string(var_327.as_str());\n    }\n    #[allow(unused_mut)]\n    let mut scope_328 = writer.prefix(\"DnsSupport\");\n    if let Some(var_329) = &input.dns_support {\n        scope_328.string(var_329.as_str());\n    }\n    #[allow(unused_mut)]\n    let mut scope_330 = writer.prefix(\"MulticastSupport\");\n    if let Some(var_331) = &input.multicast_support {\n        scope_330.string(var_331.as_str());\n    }\n    #[allow(unused_mut)]\n    let mut scope_332 = writer.prefix(\"TransitGatewayCidrBlocks\");\n    if let Some(var_333) = &input.transit_gateway_cidr_blocks {\n        let mut list_335 = scope_332.start_list(true, Some(\"item\"));\n        for item_334 in var_333 {\n            #[allow(unused_mut)]\n            let mut entry_336 = list_335.entry();\n            entry_336.string(item_334);\n        }\n        list_335.finish();\n    }\n    Ok(())\n}", "item_id": 36, "repo": "jdisanti/aws-sdk-rust", "file": "sdk/ec2/src/query_ser.rs", "last_update_at": "2022-03-31T20:47:15+00:00", "question_id": "a5697097b716f587bfe10a7d599e122f2aa6d0c6_36", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn serialize_structure_crate_model_transit_gateway_request_options(\n    mut writer: aws_smithy_query::QueryValueWriter,\n    input: &crate::model::TransitGatewayRequestOptions,\n) -> Result<(), aws_smithy_http::operation::SerializationError> {\n    #[allow(unused_mut)]\n    let mut scope_318 = writer.prefix(\"AmazonSideAsn\");\n    if let Some(var_319) = &input.amazon_side_asn {\n        scope_318.number(\n            #[allow(clippy::useless_conversion)]\n            aws_smithy_types::Number::NegInt((*var_319).into()),\n        );\n    }\n    #[allow(unused_mut)]\n    let mut scope_320 = writer.prefix(\"AutoAcceptSharedAttachments\");\n    if let Some(var_321) = &input.auto_accept_shared_attachments {\n        scope_320.string(var_321.as_str());\n    }\n    #[allow(unused_mut)]\n    let mut scope_322 = writer.prefix(\"DefaultRouteTableAssociation\");\n    if let Some(var_323) = &input.default_route_table_association {\n        scope_322.string(var_323.as_str());\n    }\n    #[allow(unused_mut)]\n    let mut scope_324 = writer.prefix(\"DefaultRouteTablePropagation\");\n    if let Some(var_325) = &input.default_route_table_propagation {\n        scope_324.string(var_325.as_str());\n    }\n    #[allow(unused_mut)]\n    let mut scope_326 = writer.prefix(\"VpnEcmpSupport\");\n    if let Some(var_327) = &input.vpn_ecmp_support {\n        scope_326.string(var_327.as_str());\n    }\n    #[allow(unused_mut)]\n    let mut scope_328 = writer.prefix(\"DnsSupport\");\n    if let Some(var_329) = &input.dns_support {\n        scope_328.string(var_329.as_str());\n    }\n    #[allow(unused_mut)]\n    let mut scope_330 = writer.prefix(\"MulticastSupport\");\n    if let Some(var_331) = &input.multicast_support {\n        scope_330.string(var_331.as_str());\n    }\n    #[allow(unused_mut)]\n    let mut scope_332 = writer.prefix(\"TransitGatewayCidrBlocks\");\n    if let Some(var_333) = &input.transit_gateway_cidr_blocks {\n        let mut list_335 = scope_332.start_list(true, Some(\"item\"));\n        for item_334 in var_333 {\n            #[allow(unused_mut)]\n            let mut entry_336 = list_335.entry();\n            entry_336.string(item_334);\n        }\n        list_335.finish();\n    }\n    Ok(())\n"]], "pred": {"ppl": 1.5214166641235352, "ppl_lower": 1.7041598558425903, "ppl/lowercase_ppl": -1.270302643618248, "ppl/zlib": 0.0006108324842384541, "Min_5.0% Prob": 6.253447920084, "Min_10.0% Prob": 3.92580853788941, "Min_20.0% Prob": 2.0952518907792728, "Min_30.0% Prob": 1.4000528751283277, "Min_40.0% Prob": 1.0495329141426, "Min_50.0% Prob": 0.8392293262946525, "Min_60.0% Prob": 0.7005307815381122}}
{"hexsha": "ae15adb105436aefdc02c8b355e0821f34c5cbdf", "ext": "rs", "lang": "Rust", "content": "pub fn routes(cfg: &config::Config) -> distringo::Result<BoxedFilter<(impl Reply,)>> {\n\tlet slash = warp::get()\n\t\t.and(path::end())\n\t\t.and(fs::file(\"./dist/index.html\"));\n\n\tlet static_files = warp::get().and(fs::dir(\"./dist/\")).and(path::end());\n\n\tlet file_routes = slash.or(static_files);\n\n\tlet api_routes = api::api(cfg)?;\n\n\tlet root = api_routes\n\t\t.or(file_routes)\n\t\t.with(warp::log(\"distringo\"))\n\t\t.recover(super::handle_rejection)\n\t\t.boxed();\n\n\tOk(root)\n}", "item_id": 0, "repo": "rye/distringo", "file": "server/src/server/routes.rs", "last_update_at": "2022-03-31T12:20:08+00:00", "question_id": "ae15adb105436aefdc02c8b355e0821f34c5cbdf_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn routes(cfg: &config::Config) -> distringo::Result<BoxedFilter<(impl Reply,)>> {\n\tlet slash = warp::get()\n\t\t.and(path::end())\n\t\t.and(fs::file(\"./dist/index.html\"));\n\tlet static_files = warp::get().and(fs::dir(\"./dist/\")).and(path::end());\n\tlet file_routes = slash.or(static_files);\n\tlet api_routes = api::api(cfg)?;\n\tlet root = api_routes\n\t\t.or(file_routes)\n\t\t.with(warp::log(\"distringo\"))\n\t\t.recover(super::handle_rejection)\n\t\t.boxed();\n\tOk(root)\n"]], "pred": {"ppl": 2.7529349327087402, "ppl_lower": 3.6382431983947754, "ppl/lowercase_ppl": -1.275345373971379, "ppl/zlib": 0.0037645635346901974, "Min_5.0% Prob": 9.049037827385796, "Min_10.0% Prob": 6.302565160550569, "Min_20.0% Prob": 4.230507750260203, "Min_30.0% Prob": 3.187392999205673, "Min_40.0% Prob": 2.497819117809597, "Min_50.0% Prob": 2.010491541121155, "Min_60.0% Prob": 1.6871178766469592}}
{"hexsha": "016b434a6124a83ecd1cad9fda874a0aa5689aa9", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<(), std::io::Error> {\n    vec! { 1, 2, 3 }.len();\n    write! { vec![], \"\" }?;\n    println!{\"\"}\n    [0]; // separate statement, not indexing into the result of println.\n    Ok(())\n}", "item_id": 0, "repo": "ohno418/rust", "file": "src/test/ui/parser/macro-braces-dot-question.rs", "last_update_at": "2022-03-31T23:26:40+00:00", "question_id": "016b434a6124a83ecd1cad9fda874a0aa5689aa9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() -> Result<(), std::io::Error> {\n    vec! { 1, 2, 3 }.len();\n    write! { vec![], \"\" }?;\n    println!{\"\"}\n    [0]; // separate statement, not indexing into the result of println.\n    Ok(())\n"]], "pred": {"ppl": 7.837386131286621, "ppl_lower": 10.867741584777832, "ppl/lowercase_ppl": -1.1587705487269393, "ppl/zlib": 0.01255430108018314, "Min_5.0% Prob": 10.029764175415039, "Min_10.0% Prob": 8.237132140568324, "Min_20.0% Prob": 6.58177079473223, "Min_30.0% Prob": 5.503160238265991, "Min_40.0% Prob": 4.659376744566293, "Min_50.0% Prob": 4.019765047563447, "Min_60.0% Prob": 3.4413034610970077}}
{"hexsha": "a02fceded9209aad274883d3388c8126df7649ac", "ext": "rs", "lang": "Rust", "content": "pub fn indoc(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    let source = TokenStream::from(input);\n\n    let len = source.clone().into_iter().count();\n    if len != 1 {\n        panic!(\n            \"argument must be a single string literal, but got {} tokens\",\n            len\n        );\n    }\n\n    let lit = match syn::parse2::<Lit>(source) {\n        Ok(lit) => lit,\n        Err(_) => {\n            panic!(\"argument must be a single string literal\");\n        }\n    };\n\n    let lit = match lit {\n        Lit::Str(lit) => {\n            let v = unindent(&lit.value());\n            Lit::Str(LitStr::new(&v, lit.span()))\n        }\n        Lit::ByteStr(lit) => {\n            let v = unindent_bytes(&lit.value());\n            Lit::ByteStr(LitByteStr::new(&v, lit.span()))\n        }\n        _ => {\n            panic!(\"argument must be a single string literal\");\n        }\n    };\n\n    proc_macro::TokenStream::from(quote!(#lit))\n}", "item_id": 0, "repo": "wwjiang007/fuchsia-1", "file": "third_party/rust_crates/vendor/indoc-impl/src/lib.rs", "last_update_at": "2022-03-28T07:59:06+00:00", "question_id": "a02fceded9209aad274883d3388c8126df7649ac_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn indoc(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    let source = TokenStream::from(input);\n    let len = source.clone().into_iter().count();\n    if len != 1 {\n        panic!(\n            \"argument must be a single string literal, but got {} tokens\",\n            len\n        );\n    }\n    let lit = match syn::parse2::<Lit>(source) {\n        Ok(lit) => lit,\n        Err(_) => {\n            panic!(\"argument must be a single string literal\");\n        }\n    };\n    let lit = match lit {\n        Lit::Str(lit) => {\n            let v = unindent(&lit.value());\n            Lit::Str(LitStr::new(&v, lit.span()))\n        }\n        Lit::ByteStr(lit) => {\n            let v = unindent_bytes(&lit.value());\n            Lit::ByteStr(LitByteStr::new(&v, lit.span()))\n        }\n        _ => {\n            panic!(\"argument must be a single string literal\");\n        }\n    };\n    proc_macro::TokenStream::from(quote!(#lit))\n"]], "pred": {"ppl": 1.7050681114196777, "ppl_lower": 2.2204668521881104, "ppl/lowercase_ppl": -1.4949585945968207, "ppl/zlib": 0.0014946920391717363, "Min_5.0% Prob": 6.228314229420254, "Min_10.0% Prob": 4.216829653297152, "Min_20.0% Prob": 2.4776046281321005, "Min_30.0% Prob": 1.743449348561904, "Min_40.0% Prob": 1.3225830295368244, "Min_50.0% Prob": 1.0683266522467767, "Min_60.0% Prob": 0.8887251331007968}}
{"hexsha": "ac0a0d5709c4081b6449b6ab397e59c2f883da89", "ext": "rs", "lang": "Rust", "content": "async fn main() {\n    tracing_subscriber::fmt::init();\n\n    eprintln!(\"connecting to localhost:5001...\");\n\n    let client = IpfsClient::default();\n\n    match client.name_resolve(Some(IPFS_IPNS), true, false).await {\n        Ok(resolved) => eprintln!(\"{} resolves to: {}\", IPFS_IPNS, &resolved.path),\n        Err(e) => {\n            eprintln!(\"error resolving {}: {}\", IPFS_IPNS, e);\n            return;\n        }\n    }\n\n    let publish = match client.name_publish(IPFS_IPNS, true, None, None, None).await {\n        Ok(publish) => {\n            eprintln!(\"published {} to: /ipns/{}\", IPFS_IPNS, &publish.name);\n            publish\n        }\n        Err(e) => {\n            eprintln!(\"error publishing name: {}\", e);\n            return;\n        }\n    };\n\n    match client.name_resolve(Some(&publish.name), true, false).await {\n        Ok(resolved) => {\n            eprintln!(\"/ipns/{} resolves to: {}\", &publish.name, &resolved.path);\n        }\n        Err(e) => {\n            eprintln!(\"error resolving name: {}\", e);\n        }\n    }\n}", "item_id": 0, "repo": "hanabi1224/rust-ipfs-api", "file": "ipfs-api-examples/examples/resolve_name.rs", "last_update_at": "2022-03-26T02:37:44+00:00", "question_id": "ac0a0d5709c4081b6449b6ab397e59c2f883da89_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn main() {\n    tracing_subscriber::fmt::init();\n    eprintln!(\"connecting to localhost:5001...\");\n    let client = IpfsClient::default();\n    match client.name_resolve(Some(IPFS_IPNS), true, false).await {\n        Ok(resolved) => eprintln!(\"{} resolves to: {}\", IPFS_IPNS, &resolved.path),\n        Err(e) => {\n            eprintln!(\"error resolving {}: {}\", IPFS_IPNS, e);\n            return;\n        }\n    }\n    let publish = match client.name_publish(IPFS_IPNS, true, None, None, None).await {\n        Ok(publish) => {\n            eprintln!(\"published {} to: /ipns/{}\", IPFS_IPNS, &publish.name);\n            publish\n        }\n        Err(e) => {\n            eprintln!(\"error publishing name: {}\", e);\n            return;\n        }\n    };\n    match client.name_resolve(Some(&publish.name), true, false).await {\n        Ok(resolved) => {\n            eprintln!(\"/ipns/{} resolves to: {}\", &publish.name, &resolved.path);\n        }\n        Err(e) => {\n            eprintln!(\"error resolving name: {}\", e);\n        }\n    }\n"]], "pred": {"ppl": 1.8755382299423218, "ppl_lower": 2.1455650329589844, "ppl/lowercase_ppl": -1.2138784978807224, "ppl/zlib": 0.0017866354380651436, "Min_5.0% Prob": 6.395630240440369, "Min_10.0% Prob": 4.495905522144202, "Min_20.0% Prob": 2.8339056932564937, "Min_30.0% Prob": 2.029492525440274, "Min_40.0% Prob": 1.5626683413530842, "Min_50.0% Prob": 1.2535060328061143, "Min_60.0% Prob": 1.0481774846124627}}
{"hexsha": "7f4f4a85523e169edbd101e27da6c913897bbc70", "ext": "rs", "lang": "Rust", "content": "fn test_sub_self() {\n        let a;\n        let mut b;\n\n        let (ap, asz) = make_limbs!(const a, 0, 2);\n        let bp = make_limbs!(out b, 2);\n        let bsz = 2;\n        b[0] = Limb(2);\n        b[1] = Limb(1);\n\n        unsafe {\n            assert_eq!(sub(bp, ap, asz, bp.as_const(), bsz), 0);\n        }\n        assert_eq!(b, [!1, 0]);\n    }", "item_id": 8, "repo": "nathanwhit/ramp", "file": "src/ll/mod.rs", "last_update_at": "2022-03-13T04:48:43+00:00", "question_id": "7f4f4a85523e169edbd101e27da6c913897bbc70_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_sub_self() {\n        let a;\n        let mut b;\n        let (ap, asz) = make_limbs!(const a, 0, 2);\n        let bp = make_limbs!(out b, 2);\n        let bsz = 2;\n        b[0] = Limb(2);\n        b[1] = Limb(1);\n        unsafe {\n            assert_eq!(sub(bp, ap, asz, bp.as_const(), bsz), 0);\n        }\n        assert_eq!(b, [!1, 0]);\n"]], "pred": {"ppl": 4.064914226531982, "ppl_lower": 4.079045295715332, "ppl/lowercase_ppl": -1.0024745727329292, "ppl/zlib": 0.007878610349960777, "Min_5.0% Prob": 8.827439308166504, "Min_10.0% Prob": 7.294293642044067, "Min_20.0% Prob": 5.169225832511639, "Min_30.0% Prob": 4.046581707217476, "Min_40.0% Prob": 3.275312634847932, "Min_50.0% Prob": 2.723509314897898, "Min_60.0% Prob": 2.329513580115004}}
{"hexsha": "39d5191dc6f2291cc6ce204de3f3872aac335526", "ext": "rs", "lang": "Rust", "content": "pub async fn redrive_webhook_result(configuration: &configuration::Configuration, params: RedriveWebhookResultParams) -> Result<crate::models::WebhookRedriveResult, Error<RedriveWebhookResultError>> {\n    // unbox the parameters\n    let webhook_result_id = params.webhook_result_id;\n\n\n    let local_var_client = &configuration.client;\n\n    let local_var_uri_str = format!(\"{}/webhooks/results/{webhookResultId}/redrive\", configuration.base_path, webhookResultId=webhook_result_id);\n    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());\n\n    if let Some(ref local_var_user_agent) = configuration.user_agent {\n        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());\n    }\n    if let Some(ref local_var_apikey) = configuration.api_key {\n        let local_var_key = local_var_apikey.key.clone();\n        let local_var_value = match local_var_apikey.prefix {\n            Some(ref local_var_prefix) => format!(\"{} {}\", local_var_prefix, local_var_key),\n            None => local_var_key,\n        };\n        local_var_req_builder = local_var_req_builder.header(\"x-api-key\", local_var_value);\n    };\n\n    let local_var_req = local_var_req_builder.build()?;\n    let local_var_resp = local_var_client.execute(local_var_req).await?;\n\n    let local_var_status = local_var_resp.status();\n    let local_var_content = local_var_resp.text().await?;\n\n    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {\n        serde_json::from_str(&local_var_content).map_err(Error::from)\n    } else {\n        let local_var_entity: Option<RedriveWebhookResultError> = serde_json::from_str(&local_var_content).ok();\n        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };\n        Err(Error::ResponseError(local_var_error))\n    }\n}", "item_id": 17, "repo": "mailslurp/mailslurp-client-rust", "file": "src/apis/webhook_controller_api.rs", "last_update_at": "2022-03-08T02:34:57+00:00", "question_id": "39d5191dc6f2291cc6ce204de3f3872aac335526_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn redrive_webhook_result(configuration: &configuration::Configuration, params: RedriveWebhookResultParams) -> Result<crate::models::WebhookRedriveResult, Error<RedriveWebhookResultError>> {\n    // unbox the parameters\n    let webhook_result_id = params.webhook_result_id;\n    let local_var_client = &configuration.client;\n    let local_var_uri_str = format!(\"{}/webhooks/results/{webhookResultId}/redrive\", configuration.base_path, webhookResultId=webhook_result_id);\n    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());\n    if let Some(ref local_var_user_agent) = configuration.user_agent {\n        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());\n    }\n    if let Some(ref local_var_apikey) = configuration.api_key {\n        let local_var_key = local_var_apikey.key.clone();\n        let local_var_value = match local_var_apikey.prefix {\n            Some(ref local_var_prefix) => format!(\"{} {}\", local_var_prefix, local_var_key),\n            None => local_var_key,\n        };\n        local_var_req_builder = local_var_req_builder.header(\"x-api-key\", local_var_value);\n    };\n    let local_var_req = local_var_req_builder.build()?;\n    let local_var_resp = local_var_client.execute(local_var_req).await?;\n    let local_var_status = local_var_resp.status();\n    let local_var_content = local_var_resp.text().await?;\n    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {\n        serde_json::from_str(&local_var_content).map_err(Error::from)\n    } else {\n        let local_var_entity: Option<RedriveWebhookResultError> = serde_json::from_str(&local_var_content).ok();\n        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };\n        Err(Error::ResponseError(local_var_error))\n    }\n"]], "pred": {"ppl": 1.6159001588821411, "ppl_lower": 1.8909423351287842, "ppl/lowercase_ppl": -1.3275384088245792, "ppl/zlib": 0.0007569277213253965, "Min_5.0% Prob": 6.1550446112950645, "Min_10.0% Prob": 4.051164427741629, "Min_20.0% Prob": 2.307293181254612, "Min_30.0% Prob": 1.591275538844259, "Min_40.0% Prob": 1.1991290421474998, "Min_50.0% Prob": 0.9592688223377306, "Min_60.0% Prob": 0.8010206846558163}}
{"hexsha": "a64e26f13048d3dae7059431e5afa22048c83b5a", "ext": "rs", "lang": "Rust", "content": "fn it_works() {\n        asdf\n//      ^^^^ERR(<1.16.0,rust_syntax_checking_include_tests=True) unresolved name\n//      ^^^^ERR(<1.16.0,rust_syntax_checking_include_tests=True) unresolved name\n//      ^^^^ERR(>=1.23.0,rust_syntax_checking_include_tests=True) cannot find value\n//      ^^^^ERR(>=1.23.0,rust_syntax_checking_include_tests=True) not found in this scope\n    }", "item_id": 1, "repo": "steveklabnik/sublime-rust", "file": "tests/error-tests/src/lib.rs", "last_update_at": "2022-03-28T19:03:37+00:00", "question_id": "a64e26f13048d3dae7059431e5afa22048c83b5a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn it_works() {\n        asdf\n//      ^^^^ERR(<1.16.0,rust_syntax_checking_include_tests=True) unresolved name\n//      ^^^^ERR(<1.16.0,rust_syntax_checking_include_tests=True) unresolved name\n//      ^^^^ERR(>=1.23.0,rust_syntax_checking_include_tests=True) cannot find value\n//      ^^^^ERR(>=1.23.0,rust_syntax_checking_include_tests=True) not found in this scope\n"]], "pred": {"ppl": 3.4627938270568848, "ppl_lower": 3.621706008911133, "ppl/lowercase_ppl": -1.0361245770199163, "ppl/zlib": 0.008171550840216382, "Min_5.0% Prob": 8.656787463596888, "Min_10.0% Prob": 7.137439455304827, "Min_20.0% Prob": 5.1728051366477175, "Min_30.0% Prob": 3.919036263643309, "Min_40.0% Prob": 3.044980725337719, "Min_50.0% Prob": 2.4873740419538484, "Min_60.0% Prob": 2.067280606056253}}
{"hexsha": "562159a5c0c10143023a752d9d16ca66d256582b", "ext": "rs", "lang": "Rust", "content": "async fn test_bad_raw_query_syntax() -> ReturnUnit {\n        let cat = create_test_catalog(\"test_index\");\n        let body = r#\"{ \"query\" : { \"raw\": \"asd*(@sq__\" } }\"#;\n        let err = doc_search(Arc::clone(&cat), Body::from(body), \"test_index\").await?;\n        let body: ErrorResponse = wait_json::<ErrorResponse>(err).await;\n        assert_eq!(body.message, \"Error in Index: \\'Syntax Error\\'\");\n        Ok(())\n    }", "item_id": 2, "repo": "toshi-search/Toshi", "file": "toshi-server/src/handlers/search.rs", "last_update_at": "2022-03-31T15:55:04+00:00", "question_id": "562159a5c0c10143023a752d9d16ca66d256582b_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn test_bad_raw_query_syntax() -> ReturnUnit {\n        let cat = create_test_catalog(\"test_index\");\n        let body = r#\"{ \"query\" : { \"raw\": \"asd*(@sq__\" } }\"#;\n        let err = doc_search(Arc::clone(&cat), Body::from(body), \"test_index\").await?;\n        let body: ErrorResponse = wait_json::<ErrorResponse>(err).await;\n        assert_eq!(body.message, \"Error in Index: \\'Syntax Error\\'\");\n        Ok(())\n"]], "pred": {"ppl": 7.072715759277344, "ppl_lower": 9.926254272460938, "ppl/lowercase_ppl": -1.173259864930453, "ppl/zlib": 0.007524017425072998, "Min_5.0% Prob": 9.56767749786377, "Min_10.0% Prob": 8.471078191484724, "Min_20.0% Prob": 6.734716934817178, "Min_30.0% Prob": 5.390533992222378, "Min_40.0% Prob": 4.482688005481448, "Min_50.0% Prob": 3.7721598761422293, "Min_60.0% Prob": 3.2124035079919158}}
{"hexsha": "0cde25078991b22a0a3f923899068105690d4d21", "ext": "rs", "lang": "Rust", "content": "fn html_writer_basic_colors() -> anyhow::Result<()> {\n        let mut buffer = String::new();\n        let mut writer = HtmlWriter::new(&mut buffer, None);\n        write!(writer, \"Hello, \")?;\n        writer.set_color(\n            ColorSpec::new()\n                .set_bold(true)\n                .set_underline(true)\n                .set_fg(Some(Color::Green))\n                .set_bg(Some(Color::White)),\n        )?;\n        write!(writer, \"world\")?;\n        writer.reset()?;\n        write!(writer, \"!\")?;\n\n        assert_eq!(\n            buffer,\n            r#\"Hello, <span class=\"bold underline fg2 bg7\">world</span>!\"#\n        );\n\n        Ok(())\n    }", "item_id": 1, "repo": "slowli/term-transcript", "file": "src/html.rs", "last_update_at": "2022-02-24T17:38:56+00:00", "question_id": "0cde25078991b22a0a3f923899068105690d4d21_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn html_writer_basic_colors() -> anyhow::Result<()> {\n        let mut buffer = String::new();\n        let mut writer = HtmlWriter::new(&mut buffer, None);\n        write!(writer, \"Hello, \")?;\n        writer.set_color(\n            ColorSpec::new()\n                .set_bold(true)\n                .set_underline(true)\n                .set_fg(Some(Color::Green))\n                .set_bg(Some(Color::White)),\n        )?;\n        write!(writer, \"world\")?;\n        writer.reset()?;\n        write!(writer, \"!\")?;\n        assert_eq!(\n            buffer,\n            r#\"Hello, <span class=\"bold underline fg2 bg7\">world</span>!\"#\n        );\n        Ok(())\n"]], "pred": {"ppl": 1.8870532512664795, "ppl_lower": 2.721015691757202, "ppl/lowercase_ppl": -1.5763452582325022, "ppl/zlib": 0.0021897120208802115, "Min_5.0% Prob": 6.6177915996975365, "Min_10.0% Prob": 4.666289800091794, "Min_20.0% Prob": 2.921513094351842, "Min_30.0% Prob": 2.083588248592312, "Min_40.0% Prob": 1.5868683660143539, "Min_50.0% Prob": 1.2734005546592402, "Min_60.0% Prob": 1.0613104980438948}}
{"hexsha": "2d21e3d23b05466323d410b8d353bafba83dd045", "ext": "rs", "lang": "Rust", "content": "fn set_limited_discoverable_bad_adv_type() {\n    let mut sink = RecordingSink::new();\n    {\n        let mut fixture = Fixture::new(&mut sink);\n        let err = fixture\n            .act(|controller| {\n                controller.set_limited_discoverable(&DiscoverableParameters {\n                    advertising_type: AdvertisingType::ConnectableDirectedHighDutyCycle,\n                    advertising_interval: Some((\n                        Duration::from_millis(1280),\n                        Duration::from_millis(2560),\n                    )),\n                    address_type: OwnAddressType::Public,\n                    filter_policy: AdvertisingFilterPolicy::AllowConnectionAndScan,\n                    local_name: Some(LocalName::Shortened(b\"testdev\")),\n                    advertising_data: &[0x01, 0x02, 0x03, 0x04],\n                    conn_interval: (Some(Duration::from_millis(5000)), None),\n                })\n            })\n            .err()\n            .unwrap();\n        assert_eq!(\n            err,\n            nb::Error::Other(Error::BadAdvertisingType(\n                AdvertisingType::ConnectableDirectedHighDutyCycle\n            ))\n        );\n    }\n\n    assert!(!sink.wrote_header());\n}", "item_id": 2, "repo": "antoinevg/bluenrg", "file": "tests/gap.rs", "last_update_at": "2022-03-05T04:52:30+00:00", "question_id": "2d21e3d23b05466323d410b8d353bafba83dd045_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn set_limited_discoverable_bad_adv_type() {\n    let mut sink = RecordingSink::new();\n    {\n        let mut fixture = Fixture::new(&mut sink);\n        let err = fixture\n            .act(|controller| {\n                controller.set_limited_discoverable(&DiscoverableParameters {\n                    advertising_type: AdvertisingType::ConnectableDirectedHighDutyCycle,\n                    advertising_interval: Some((\n                        Duration::from_millis(1280),\n                        Duration::from_millis(2560),\n                    )),\n                    address_type: OwnAddressType::Public,\n                    filter_policy: AdvertisingFilterPolicy::AllowConnectionAndScan,\n                    local_name: Some(LocalName::Shortened(b\"testdev\")),\n                    advertising_data: &[0x01, 0x02, 0x03, 0x04],\n                    conn_interval: (Some(Duration::from_millis(5000)), None),\n                })\n            })\n            .err()\n            .unwrap();\n        assert_eq!(\n            err,\n            nb::Error::Other(Error::BadAdvertisingType(\n                AdvertisingType::ConnectableDirectedHighDutyCycle\n            ))\n        );\n    }\n    assert!(!sink.wrote_header());\n"]], "pred": {"ppl": 2.4286584854125977, "ppl_lower": 3.425264358520508, "ppl/lowercase_ppl": -1.3874951922672312, "ppl/zlib": 0.0018486230026937829, "Min_5.0% Prob": 7.791486599866082, "Min_10.0% Prob": 5.914813897188972, "Min_20.0% Prob": 3.8989424031713735, "Min_30.0% Prob": 2.849917515678313, "Min_40.0% Prob": 2.1961518343592035, "Min_50.0% Prob": 1.7689131962813738, "Min_60.0% Prob": 1.4816604898972572}}
{"hexsha": "c116c1124eddbe1d1b2a05542c894884a2d8ca99", "ext": "rs", "lang": "Rust", "content": "async fn handle_socks(mut stream: TcpStream, server: String,uuid: [u8; 16]) -> Result<()> {\n    let mut buf = [0; 1024];\n\n    let len = stream.read(&mut buf).await?;\n\n    // socks5: first handshake begin\n    if 1 + 1 + (buf[1] as usize) != len || buf[0] != b'\\x05' {\n        warn!(\"invalid header\");\n        return Ok(());\n    }\n    stream.write_all(b\"\\x05\\x00\").await?; // version 5, method 0\n\n    // socks5: first handshake begin\n    let len = stream.read(&mut buf).await?;\n    if len <= 4 {\n        warn!(\"invalid proto\");\n        return Ok(());\n    }\n\n    let ver = buf[0]; // version\n    let cmd = buf[1]; // command code 1-connect 2-bind 3-udp forward\n    let atyp = buf[3]; // type of the dist server 1-ipv4 3-domain 4-ipv6\n\n    if ver != b'\\x05' {\n        warn!(\"invalid proto\");\n        return Ok(());\n    }\n\n    if cmd != 1 {\n        warn!(\"Command not supported\");\n        stream\n            .write_all(b\"\\x05\\x07\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\")\n            .await?;\n        return Ok(());\n    }\n\n    let (addr, ipbuf, portbuf) = decode_atyp(atyp, len, &buf).unwrap();\n\n    vmess_proxy(stream, &server, (addr, ipbuf, portbuf),uuid).await?;\n\n    Ok(())\n}", "item_id": 1, "repo": "irumeria/tokio-vmess", "file": "src/socks.rs", "last_update_at": "2022-02-11T20:06:12+00:00", "question_id": "c116c1124eddbe1d1b2a05542c894884a2d8ca99_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn handle_socks(mut stream: TcpStream, server: String,uuid: [u8; 16]) -> Result<()> {\n    let mut buf = [0; 1024];\n    let len = stream.read(&mut buf).await?;\n    // socks5: first handshake begin\n    if 1 + 1 + (buf[1] as usize) != len || buf[0] != b'\\x05' {\n        warn!(\"invalid header\");\n        return Ok(());\n    }\n    stream.write_all(b\"\\x05\\x00\").await?; // version 5, method 0\n    // socks5: first handshake begin\n    let len = stream.read(&mut buf).await?;\n    if len <= 4 {\n        warn!(\"invalid proto\");\n        return Ok(());\n    }\n    let ver = buf[0]; // version\n    let cmd = buf[1]; // command code 1-connect 2-bind 3-udp forward\n    let atyp = buf[3]; // type of the dist server 1-ipv4 3-domain 4-ipv6\n    if ver != b'\\x05' {\n        warn!(\"invalid proto\");\n        return Ok(());\n    }\n    if cmd != 1 {\n        warn!(\"Command not supported\");\n        stream\n            .write_all(b\"\\x05\\x07\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\")\n            .await?;\n        return Ok(());\n    }\n    let (addr, ipbuf, portbuf) = decode_atyp(atyp, len, &buf).unwrap();\n    vmess_proxy(stream, &server, (addr, ipbuf, portbuf),uuid).await?;\n    Ok(())\n"]], "pred": {"ppl": 2.4517202377319336, "ppl_lower": 2.6261847019195557, "ppl/lowercase_ppl": -1.0766536197579895, "ppl/zlib": 0.0017618662397307422, "Min_5.0% Prob": 7.883071552623402, "Min_10.0% Prob": 5.988644419776069, "Min_20.0% Prob": 3.8853072176922807, "Min_30.0% Prob": 2.839879306142821, "Min_40.0% Prob": 2.1998110291558306, "Min_50.0% Prob": 1.7857555371385052, "Min_60.0% Prob": 1.491083226825073}}
{"hexsha": "ff2f4883dac8a1c3022c30054dc47766f61f1f86", "ext": "rs", "lang": "Rust", "content": "fn disable_devices() {\n\twait_write();\n\tunsafe {\n\t\tio::outb(COMMAND_REGISTER, 0xad);\n\t}\n\n\twait_write();\n\tunsafe {\n\t\tio::outb(COMMAND_REGISTER, 0xa7);\n\t}\n}", "item_id": 1, "repo": "llenotre/maestro", "file": "src/device/ps2.rs", "last_update_at": "2022-03-04T15:29:05+00:00", "question_id": "ff2f4883dac8a1c3022c30054dc47766f61f1f86_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn disable_devices() {\n\twait_write();\n\tunsafe {\n\t\tio::outb(COMMAND_REGISTER, 0xad);\n\t}\n\twait_write();\n\tunsafe {\n\t\tio::outb(COMMAND_REGISTER, 0xa7);\n\t}\n"]], "pred": {"ppl": 2.949000597000122, "ppl_lower": 3.6365063190460205, "ppl/lowercase_ppl": -1.1937712527471946, "ppl/zlib": 0.011149137446130573, "Min_5.0% Prob": 9.13606607913971, "Min_10.0% Prob": 7.006085813045502, "Min_20.0% Prob": 4.715690977871418, "Min_30.0% Prob": 3.464602346221606, "Min_40.0% Prob": 2.6735018715262413, "Min_50.0% Prob": 2.154319593589753, "Min_60.0% Prob": 1.799940374485838}}
{"hexsha": "ef451145d11aad10740dd6887f5fb5c1af4124dc", "ext": "rs", "lang": "Rust", "content": "fn set(args: &SetArguments) -> Result<()> {\n    let mut config = crate::config::Config::load()?;\n    config.set(&args.path, &args.value)?;\n    config.dump()?;\n    Ok(())\n}", "item_id": 0, "repo": "openfare/openfare", "file": "openfare/src/command/config.rs", "last_update_at": "2022-03-31T09:32:29+00:00", "question_id": "ef451145d11aad10740dd6887f5fb5c1af4124dc_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn set(args: &SetArguments) -> Result<()> {\n    let mut config = crate::config::Config::load()?;\n    config.set(&args.path, &args.value)?;\n    config.dump()?;\n    Ok(())\n"]], "pred": {"ppl": 3.1386184692382812, "ppl_lower": 4.706728935241699, "ppl/lowercase_ppl": -1.3542722224371877, "ppl/zlib": 0.00866502064508994, "Min_5.0% Prob": 8.679961999257406, "Min_10.0% Prob": 6.6308487256368, "Min_20.0% Prob": 4.861125548680623, "Min_30.0% Prob": 3.6650533411237927, "Min_40.0% Prob": 2.77628351688385, "Min_50.0% Prob": 2.288610794851857, "Min_60.0% Prob": 1.93695274096083}}
{"hexsha": "b3c4fe615e1f5f4606357e6bd3cec096a407e78d", "ext": "rs", "lang": "Rust", "content": "async fn test_mute_combinations() {\n    let (service_registry, fake_services) = create_services().await;\n    let (env, _) = create_environment(service_registry).await;\n    let input_proxy = env.connect_to_service::<InputMarker>().unwrap();\n\n    // Hardware muted, software unmuted.\n    switch_hardware_mic_mute(&fake_services, true).await;\n    set_mic_mute(&input_proxy, false).await;\n    get_and_check_mic_mute(&input_proxy, true).await;\n\n    // Hardware muted, software muted.\n    set_mic_mute(&input_proxy, true).await;\n    get_and_check_mic_mute(&input_proxy, true).await;\n\n    // Hardware unmuted, software muted.\n    switch_hardware_mic_mute(&fake_services, false).await;\n    get_and_check_mic_mute(&input_proxy, true).await;\n\n    // Hardware unmuted, software unmuted.\n    switch_hardware_mic_mute(&fake_services, false).await;\n    set_mic_mute(&input_proxy, false).await;\n    get_and_check_mic_mute(&input_proxy, false).await;\n}", "item_id": 7, "repo": "dahlia-os/fuchsia-pine64-pinephone", "file": "garnet/bin/setui/src/tests/input_tests.rs", "last_update_at": "2022-03-12T03:20:43+00:00", "question_id": "b3c4fe615e1f5f4606357e6bd3cec096a407e78d_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn test_mute_combinations() {\n    let (service_registry, fake_services) = create_services().await;\n    let (env, _) = create_environment(service_registry).await;\n    let input_proxy = env.connect_to_service::<InputMarker>().unwrap();\n    // Hardware muted, software unmuted.\n    switch_hardware_mic_mute(&fake_services, true).await;\n    set_mic_mute(&input_proxy, false).await;\n    get_and_check_mic_mute(&input_proxy, true).await;\n    // Hardware muted, software muted.\n    set_mic_mute(&input_proxy, true).await;\n    get_and_check_mic_mute(&input_proxy, true).await;\n    // Hardware unmuted, software muted.\n    switch_hardware_mic_mute(&fake_services, false).await;\n    get_and_check_mic_mute(&input_proxy, true).await;\n    // Hardware unmuted, software unmuted.\n    switch_hardware_mic_mute(&fake_services, false).await;\n    set_mic_mute(&input_proxy, false).await;\n    get_and_check_mic_mute(&input_proxy, false).await;\n"]], "pred": {"ppl": 1.7442760467529297, "ppl_lower": 1.9461630582809448, "ppl/lowercase_ppl": -1.1968584939386473, "ppl/zlib": 0.0020758940173501977, "Min_5.0% Prob": 6.572474300861359, "Min_10.0% Prob": 4.583231270313263, "Min_20.0% Prob": 2.700448900461197, "Min_30.0% Prob": 1.8558592207121605, "Min_40.0% Prob": 1.3960380643705717, "Min_50.0% Prob": 1.115930679947047, "Min_60.0% Prob": 0.9290828560059418}}
{"hexsha": "96505ebeaf5c96af46eb7c6ad159836fef5202f9", "ext": "rs", "lang": "Rust", "content": "fn draw_field(draw: &Draw, model: &Model, win: &Rect) {\n  let color = hsl(0.0, 0.0, 0.02);\n  let source = OpenSimplex::new();\n  let noisefn = Terrace::new(&source)\n    .add_control_point(model.control_point1)\n    .add_control_point(model.control_point2)\n    .add_control_point(model.control_point3)\n    .add_control_point(model.control_point4)\n    .add_control_point(model.control_point5);\n\n  for _i in 0..=model.n_lines {\n    // circular placement\n    // let init_angle = map_range(_i, 0, model.n_lines, 0.0, 2.0 * PI);\n    // let mut x = init_angle.cos() * win.left().hypot(win.bottom()) * model.radius;\n    // let mut y = init_angle.sin() * win.left().hypot(win.bottom()) * model.radius;\n\n    // random rectangular placement\n    let diag = win.left().hypot(win.bottom());\n    let mut x = random_range(diag * model.radius / 2.0, diag * -model.radius / 2.0);\n    let mut y = random_range(diag * model.radius / 2.0, diag * -model.radius / 2.0);\n\n    let _init_x = x;\n    let init_y = y;\n\n    // Generate points for the line that do not intersect other lines\n    let points = (0..model.n_steps)\n      .map(|_n| {\n        // let angle = field(model, x, y);\n        // hmm, not quite sure why this is necessary\n        let angle = noise_field(model.seed, model.noise_scale, x, y, &noisefn);\n        if init_y < 0.0 {\n          x -= angle.cos();\n          y -= angle.sin();\n        } else {\n          x += angle.cos();\n          y += angle.sin();\n        };\n\n        let point = pt2(x, y);\n        Some(point)\n      })\n      // Skip any initial Nones\n      // Take all the Somes until we hit a None.\n      .skip_while(|&o| o.is_none())\n      .take_while(|&o| o.is_some())\n      .filter_map(|o| o);\n\n    draw\n      .polyline()\n      .caps_round()\n      .weight(model.stroke_weight)\n      .color(color)\n      .points(points);\n  }\n}", "item_id": 6, "repo": "ericyd/generative-art", "file": "nannou/examples/watercolor3.rs", "last_update_at": "2022-03-12T21:02:12+00:00", "question_id": "96505ebeaf5c96af46eb7c6ad159836fef5202f9_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn draw_field(draw: &Draw, model: &Model, win: &Rect) {\n  let color = hsl(0.0, 0.0, 0.02);\n  let source = OpenSimplex::new();\n  let noisefn = Terrace::new(&source)\n    .add_control_point(model.control_point1)\n    .add_control_point(model.control_point2)\n    .add_control_point(model.control_point3)\n    .add_control_point(model.control_point4)\n    .add_control_point(model.control_point5);\n  for _i in 0..=model.n_lines {\n    // circular placement\n    // let init_angle = map_range(_i, 0, model.n_lines, 0.0, 2.0 * PI);\n    // let mut x = init_angle.cos() * win.left().hypot(win.bottom()) * model.radius;\n    // let mut y = init_angle.sin() * win.left().hypot(win.bottom()) * model.radius;\n    // random rectangular placement\n    let diag = win.left().hypot(win.bottom());\n    let mut x = random_range(diag * model.radius / 2.0, diag * -model.radius / 2.0);\n    let mut y = random_range(diag * model.radius / 2.0, diag * -model.radius / 2.0);\n    let _init_x = x;\n    let init_y = y;\n    // Generate points for the line that do not intersect other lines\n    let points = (0..model.n_steps)\n      .map(|_n| {\n        // let angle = field(model, x, y);\n        // hmm, not quite sure why this is necessary\n        let angle = noise_field(model.seed, model.noise_scale, x, y, &noisefn);\n        if init_y < 0.0 {\n          x -= angle.cos();\n          y -= angle.sin();\n        } else {\n          x += angle.cos();\n          y += angle.sin();\n        };\n        let point = pt2(x, y);\n        Some(point)\n      })\n      // Skip any initial Nones\n      // Take all the Somes until we hit a None.\n      .skip_while(|&o| o.is_none())\n      .take_while(|&o| o.is_some())\n      .filter_map(|o| o);\n    draw\n      .polyline()\n      .caps_round()\n      .weight(model.stroke_weight)\n      .color(color)\n      .points(points);\n  }\n"]], "pred": {"ppl": 2.4375805854797363, "ppl_lower": 2.5478198528289795, "ppl/lowercase_ppl": -1.0496428200793282, "ppl/zlib": 0.0012969519418529946, "Min_5.0% Prob": 7.792900836828983, "Min_10.0% Prob": 5.834803328369603, "Min_20.0% Prob": 3.9275858590477393, "Min_30.0% Prob": 2.86669212879248, "Min_40.0% Prob": 2.2037118459330465, "Min_50.0% Prob": 1.7750335590013333, "Min_60.0% Prob": 1.485600939193241}}
{"hexsha": "489ad77a50a1f9d245b0af344d944074e4afeff2", "ext": "rs", "lang": "Rust", "content": "async fn atomic_update_reader() {\n        let inspector = Inspector::new();\n\n        // Spawn a read thread that holds a duplicate handle to the VMO that will be written.\n        let vmo = inspector.duplicate_vmo().expect(\"duplicate vmo handle\");\n        let (p1, p2) = zx::EventPair::create().unwrap();\n\n        macro_rules! notify_and_wait_reader {\n            () => {\n                p1.signal_peer(zx::Signals::NONE, zx::Signals::USER_0).unwrap();\n                p1.wait_handle(zx::Signals::USER_0, zx::Time::INFINITE).unwrap();\n                p1.signal_handle(zx::Signals::USER_0, zx::Signals::NONE).unwrap();\n            };\n        }\n\n        macro_rules! wait_and_notify_writer {\n            ($code:block) => {\n              p2.wait_handle(zx::Signals::USER_0, zx::Time::INFINITE).unwrap();\n              p2.signal_handle(zx::Signals::USER_0, zx::Signals::NONE).unwrap();\n              $code\n              p2.signal_peer(zx::Signals::NONE, zx::Signals::USER_0).unwrap();\n            }\n        }\n\n        let thread = std::thread::spawn(move || {\n            // Before running the atomic update.\n            wait_and_notify_writer! {{\n                let hierarchy: DiagnosticsHierarchy<String> =\n                    reader::PartialNodeHierarchy::try_from(&vmo).unwrap().into();\n                assert_eq!(hierarchy, DiagnosticsHierarchy::new_root());\n            }};\n            // After: create_child(\"child\"): Assert that the VMO is in use (locked) and we can't\n            // read.\n            wait_and_notify_writer! {{\n                assert!(reader::PartialNodeHierarchy::try_from(&vmo).is_err());\n            }};\n            // After: record_int(\"a\"): Assert that the VMO is in use (locked) and we can't\n            // read.\n            wait_and_notify_writer! {{\n                assert!(reader::PartialNodeHierarchy::try_from(&vmo).is_err());\n            }};\n            // After: record_int(\"b\"): Assert that the VMO is in use (locked) and we can't\n            // read.\n            wait_and_notify_writer! {{\n                assert!(reader::PartialNodeHierarchy::try_from(&vmo).is_err());\n            }};\n            // After atomic update\n            wait_and_notify_writer! {{\n                let hierarchy: DiagnosticsHierarchy<String> =\n                    reader::PartialNodeHierarchy::try_from(&vmo).unwrap().into();\n                assert_data_tree!(hierarchy, root: {\n                   value: 2i64,\n                   child: {\n                       a: 1i64,\n                       b: 2i64,\n                   }\n                });\n            }};\n        });\n\n        // Perform the atomic update\n        let mut child = Node::default();\n        notify_and_wait_reader!();\n        let int_val = inspector.root().create_int(\"value\", 1);\n        inspector\n            .root()\n            .atomic_update(|node| {\n                // Intentionally make this slow to assert an atomic update in the reader.\n                child = node.create_child(\"child\");\n                notify_and_wait_reader!();\n                child.record_int(\"a\", 1);\n                notify_and_wait_reader!();\n                child.record_int(\"b\", 2);\n                notify_and_wait_reader!();\n                int_val.add(1);\n                Ok::<(), Error>(())\n            })\n            .expect(\"successful atomic update\");\n        notify_and_wait_reader!();\n\n        // Wait for the reader thread to successfully finish.\n        let _ = thread.join();\n\n        // Ensure that the variable that we mutated internally can be used.\n        child.record_int(\"c\", 3);\n        assert_data_tree!(inspector, root: {\n            value: 2i64,\n            child: {\n                a: 1i64,\n                b: 2i64,\n                c: 3i64,\n            }\n        });\n    }", "item_id": 10, "repo": "Prajwal-Koirala/fuchsia", "file": "src/lib/diagnostics/inspect/rust/src/writer/types/node.rs", "last_update_at": "2022-01-04T15:37:09+00:00", "question_id": "489ad77a50a1f9d245b0af344d944074e4afeff2_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn atomic_update_reader() {\n        let inspector = Inspector::new();\n        // Spawn a read thread that holds a duplicate handle to the VMO that will be written.\n        let vmo = inspector.duplicate_vmo().expect(\"duplicate vmo handle\");\n        let (p1, p2) = zx::EventPair::create().unwrap();\n        macro_rules! notify_and_wait_reader {\n            () => {\n                p1.signal_peer(zx::Signals::NONE, zx::Signals::USER_0).unwrap();\n                p1.wait_handle(zx::Signals::USER_0, zx::Time::INFINITE).unwrap();\n                p1.signal_handle(zx::Signals::USER_0, zx::Signals::NONE).unwrap();\n            };\n        }\n        macro_rules! wait_and_notify_writer {\n            ($code:block) => {\n              p2.wait_handle(zx::Signals::USER_0, zx::Time::INFINITE).unwrap();\n              p2.signal_handle(zx::Signals::USER_0, zx::Signals::NONE).unwrap();\n              $code\n              p2.signal_peer(zx::Signals::NONE, zx::Signals::USER_0).unwrap();\n            }\n        }\n        let thread = std::thread::spawn(move || {\n            // Before running the atomic update.\n            wait_and_notify_writer! {{\n                let hierarchy: DiagnosticsHierarchy<String> =\n                    reader::PartialNodeHierarchy::try_from(&vmo).unwrap().into();\n                assert_eq!(hierarchy, DiagnosticsHierarchy::new_root());\n            }};\n            // After: create_child(\"child\"): Assert that the VMO is in use (locked) and we can't\n            // read.\n            wait_and_notify_writer! {{\n                assert!(reader::PartialNodeHierarchy::try_from(&vmo).is_err());\n            }};\n            // After: record_int(\"a\"): Assert that the VMO is in use (locked) and we can't\n            // read.\n            wait_and_notify_writer! {{\n                assert!(reader::PartialNodeHierarchy::try_from(&vmo).is_err());\n            }};\n            // After: record_int(\"b\"): Assert that the VMO is in use (locked) and we can't\n            // read.\n            wait_and_notify_writer! {{\n                assert!(reader::PartialNodeHierarchy::try_from(&vmo).is_err());\n            }};\n            // After atomic update\n            wait_and_notify_writer! {{\n                let hierarchy: DiagnosticsHierarchy<String> =\n                    reader::PartialNodeHierarchy::try_from(&vmo).unwrap().into();\n                assert_data_tree!(hierarchy, root: {\n                   value: 2i64,\n                   child: {\n                       a: 1i64,\n                       b: 2i64,\n                   }\n                });\n            }};\n        });\n        // Perform the atomic update\n        let mut child = Node::default();\n        notify_and_wait_reader!();\n        let int_val = inspector.root().create_int(\"value\", 1);\n        inspector\n            .root()\n            .atomic_update(|node| {\n                // Intentionally make this slow to assert an atomic update in the reader.\n                child = node.create_child(\"child\");\n                notify_and_wait_reader!();\n                child.record_int(\"a\", 1);\n                notify_and_wait_reader!();\n                child.record_int(\"b\", 2);\n                notify_and_wait_reader!();\n                int_val.add(1);\n                Ok::<(), Error>(())\n            })\n            .expect(\"successful atomic update\");\n        notify_and_wait_reader!();\n        // Wait for the reader thread to successfully finish.\n        let _ = thread.join();\n        // Ensure that the variable that we mutated internally can be used.\n        child.record_int(\"c\", 3);\n        assert_data_tree!(inspector, root: {\n            value: 2i64,\n            child: {\n                a: 1i64,\n                b: 2i64,\n                c: 3i64,\n            }\n        });\n"]], "pred": {"ppl": 1.9366306066513062, "ppl_lower": 2.233567953109741, "ppl/lowercase_ppl": -1.2158267589285248, "ppl/zlib": 0.0007023907145516353, "Min_5.0% Prob": 6.706548045663273, "Min_10.0% Prob": 4.935866837408028, "Min_20.0% Prob": 3.1118440414760626, "Min_30.0% Prob": 2.178155434238755, "Min_40.0% Prob": 1.647540720462034, "Min_50.0% Prob": 1.3220678240337833, "Min_60.0% Prob": 1.1027826162216179}}
{"hexsha": "c39f066f8958f23479aabe6f8d70e6bab13226e2", "ext": "rs", "lang": "Rust", "content": "fn test_etag() {\n    use headers::test_utils::{assert_conversion_correct, assert_interpretation_correct,\n                              assert_invalid};\n    assert_conversion_correct(\"\\\"\\\"\", strong_etag(\"\"));\n    assert_conversion_correct(\"\\\"fO0\\\"\", strong_etag(\"fO0\"));\n    assert_conversion_correct(\"\\\"fO0 bar\\\"\", strong_etag(\"fO0 bar\"));\n    assert_conversion_correct(\"\\\"fO0 \\\\\\\"bar\\\"\", strong_etag(\"fO0 \\\"bar\"));\n    assert_conversion_correct(\"\\\"fO0 \\\\\\\"bar\\\\\\\"\\\"\", strong_etag(\"fO0 \\\"bar\\\"\"));\n\n    assert_conversion_correct(\"W/\\\"\\\"\", weak_etag(\"\"));\n    assert_conversion_correct(\"W/\\\"fO0\\\"\", weak_etag(\"fO0\"));\n    assert_conversion_correct(\"W/\\\"fO0 bar\\\"\", weak_etag(\"fO0 bar\"));\n    assert_conversion_correct(\"W/\\\"fO0 \\\\\\\"bar\\\"\", weak_etag(\"fO0 \\\"bar\"));\n    assert_conversion_correct(\"W/\\\"fO0 \\\\\\\"bar\\\\\\\"\\\"\", weak_etag(\"fO0 \\\"bar\\\"\"));\n    assert_interpretation_correct(\"w/\\\"fO0\\\"\", weak_etag(\"fO0\"));\n\n    assert_invalid::<EntityTag>(\"\");\n    assert_invalid::<EntityTag>(\"fO0\");\n    assert_invalid::<EntityTag>(\"\\\"\\\\\\\"\");\n    assert_invalid::<EntityTag>(\"\\\"\\\"\\\"\\\"\");\n}", "item_id": 0, "repo": "jeff-davis/rust-http", "file": "src/http/headers/etag.rs", "last_update_at": "2022-02-11T06:51:31+00:00", "question_id": "c39f066f8958f23479aabe6f8d70e6bab13226e2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_etag() {\n    use headers::test_utils::{assert_conversion_correct, assert_interpretation_correct,\n                              assert_invalid};\n    assert_conversion_correct(\"\\\"\\\"\", strong_etag(\"\"));\n    assert_conversion_correct(\"\\\"fO0\\\"\", strong_etag(\"fO0\"));\n    assert_conversion_correct(\"\\\"fO0 bar\\\"\", strong_etag(\"fO0 bar\"));\n    assert_conversion_correct(\"\\\"fO0 \\\\\\\"bar\\\"\", strong_etag(\"fO0 \\\"bar\"));\n    assert_conversion_correct(\"\\\"fO0 \\\\\\\"bar\\\\\\\"\\\"\", strong_etag(\"fO0 \\\"bar\\\"\"));\n    assert_conversion_correct(\"W/\\\"\\\"\", weak_etag(\"\"));\n    assert_conversion_correct(\"W/\\\"fO0\\\"\", weak_etag(\"fO0\"));\n    assert_conversion_correct(\"W/\\\"fO0 bar\\\"\", weak_etag(\"fO0 bar\"));\n    assert_conversion_correct(\"W/\\\"fO0 \\\\\\\"bar\\\"\", weak_etag(\"fO0 \\\"bar\"));\n    assert_conversion_correct(\"W/\\\"fO0 \\\\\\\"bar\\\\\\\"\\\"\", weak_etag(\"fO0 \\\"bar\\\"\"));\n    assert_interpretation_correct(\"w/\\\"fO0\\\"\", weak_etag(\"fO0\"));\n    assert_invalid::<EntityTag>(\"\");\n    assert_invalid::<EntityTag>(\"fO0\");\n    assert_invalid::<EntityTag>(\"\\\"\\\\\\\"\");\n    assert_invalid::<EntityTag>(\"\\\"\\\"\\\"\\\"\");\n"]], "pred": {"ppl": 1.6095950603485107, "ppl_lower": 1.729905366897583, "ppl/lowercase_ppl": -1.1514426554562434, "ppl/zlib": 0.0018963451476079962, "Min_5.0% Prob": 5.66031584739685, "Min_10.0% Prob": 3.8740721195936203, "Min_20.0% Prob": 2.3056731045246126, "Min_30.0% Prob": 1.5761338408105074, "Min_40.0% Prob": 1.1879224782576785, "Min_50.0% Prob": 0.9515277189342305, "Min_60.0% Prob": 0.7931992796079915}}
{"hexsha": "badce57a5d5d436ceb4dd7413877bfcfdf4c6ae6", "ext": "rs", "lang": "Rust", "content": "fn check_vhost_file_access(host_file_location: &String) -> Result<()> {\n    let contents = fs::read_to_string(host_file_location)\n        .with_context(|| format!(\"Unable to open {}\",  host_file_location))?;\n    let mut file = OpenOptions::new().write(true).truncate(true).open(host_file_location)?;\n    file.write(contents.as_bytes())\n        .with_context(|| format!(\"Unable to write to file {}\", host_file_location))?;\n    file.sync_all()?;\n    Ok(())\n}", "item_id": 4, "repo": "itaylor/docker-vhoster", "file": "src/main.rs", "last_update_at": "2022-03-15T23:11:53+00:00", "question_id": "badce57a5d5d436ceb4dd7413877bfcfdf4c6ae6_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn check_vhost_file_access(host_file_location: &String) -> Result<()> {\n    let contents = fs::read_to_string(host_file_location)\n        .with_context(|| format!(\"Unable to open {}\",  host_file_location))?;\n    let mut file = OpenOptions::new().write(true).truncate(true).open(host_file_location)?;\n    file.write(contents.as_bytes())\n        .with_context(|| format!(\"Unable to write to file {}\", host_file_location))?;\n    file.sync_all()?;\n    Ok(())\n"]], "pred": {"ppl": 2.207582473754883, "ppl_lower": 2.6568665504455566, "ppl/lowercase_ppl": -1.2339309143404043, "ppl/zlib": 0.0034133535064760686, "Min_5.0% Prob": 6.805608204432896, "Min_10.0% Prob": 5.17278889020284, "Min_20.0% Prob": 3.5033963282903033, "Min_30.0% Prob": 2.5390097298052, "Min_40.0% Prob": 1.971191279467989, "Min_50.0% Prob": 1.579237405767108, "Min_60.0% Prob": 1.3242841221938801}}
{"hexsha": "50fdc5ef6908110f35a85b94862f0e65496f4d9c", "ext": "rs", "lang": "Rust", "content": "fn pop_last_span() {\n        let mut stack = SpanStack::new();\n        let id = Id::from_u64(1);\n        stack.push(id.clone());\n\n        assert_eq!(Some(id.clone()), stack.pop(&id));\n    }", "item_id": 0, "repo": "wwjiang007/fuchsia-1", "file": "third_party/rust_crates/vendor/tracing-subscriber/src/registry/stack.rs", "last_update_at": "2022-03-28T07:59:06+00:00", "question_id": "50fdc5ef6908110f35a85b94862f0e65496f4d9c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn pop_last_span() {\n        let mut stack = SpanStack::new();\n        let id = Id::from_u64(1);\n        stack.push(id.clone());\n        assert_eq!(Some(id.clone()), stack.pop(&id));\n"]], "pred": {"ppl": 3.627558469772339, "ppl_lower": 4.371603488922119, "ppl/lowercase_ppl": -1.1447895901245997, "ppl/zlib": 0.009544887586092472, "Min_5.0% Prob": 8.769425392150879, "Min_10.0% Prob": 6.951859871546428, "Min_20.0% Prob": 4.800831611339863, "Min_30.0% Prob": 3.7732699858514884, "Min_40.0% Prob": 2.997556046797679, "Min_50.0% Prob": 2.4863462836453407, "Min_60.0% Prob": 2.14513129569017}}
{"hexsha": "0d52db0b3e25e49604bd1717bb5bcfcb64e5db30", "ext": "rs", "lang": "Rust", "content": "fn safe_integral_is_pos_policy_for_t<T>()\n    where\n        T: Integer + std::panic::RefUnwindSafe,\n    {\n        let val = SafeIntegral::<T>::magic_1();\n        assert_eq!(val.is_pos(), true);\n\n        let val = SafeIntegral::<T>::magic_1() + SafeIntegral::<T>::magic_1();\n        assert_eq!(val.checked().is_pos(), true);\n\n        let val = SafeIntegral::<T>::failure();\n        assert_panics!(val.is_pos());\n\n        let val = SafeIntegral::<T>::magic_1() + SafeIntegral::<T>::magic_1();\n        assert_panics!(val.is_pos());\n    }", "item_id": 51, "repo": "Bareflank/dynarray", "file": "include/bsl/safe_integral.rs", "last_update_at": "2022-03-31T18:04:47+00:00", "question_id": "0d52db0b3e25e49604bd1717bb5bcfcb64e5db30_51", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn safe_integral_is_pos_policy_for_t<T>()\n    where\n        T: Integer + std::panic::RefUnwindSafe,\n    {\n        let val = SafeIntegral::<T>::magic_1();\n        assert_eq!(val.is_pos(), true);\n        let val = SafeIntegral::<T>::magic_1() + SafeIntegral::<T>::magic_1();\n        assert_eq!(val.checked().is_pos(), true);\n        let val = SafeIntegral::<T>::failure();\n        assert_panics!(val.is_pos());\n        let val = SafeIntegral::<T>::magic_1() + SafeIntegral::<T>::magic_1();\n        assert_panics!(val.is_pos());\n"]], "pred": {"ppl": 2.5847840309143066, "ppl_lower": 3.646066427230835, "ppl/lowercase_ppl": -1.3622490931131246, "ppl/zlib": 0.004998115565447684, "Min_5.0% Prob": 9.47136869430542, "Min_10.0% Prob": 7.0026915788650514, "Min_20.0% Prob": 4.276454415917397, "Min_30.0% Prob": 3.0536524186531704, "Min_40.0% Prob": 2.3590834118425845, "Min_50.0% Prob": 1.9035665146261453, "Min_60.0% Prob": 1.589454666474679}}
{"hexsha": "dedc3653184eef876ff815ddb0d57675ad5cc4cd", "ext": "rs", "lang": "Rust", "content": "pub fn perform_highpass(\n    data: &mut [f64],\n    sampling_rate: usize,\n    cutoff: f64,\n    order: usize,\n    filter_type: FilterTypes,\n    ripple: f64,\n) -> Result<()> {\n    let res = unsafe {\n        data_handler::perform_highpass(\n            data.as_mut_ptr() as *mut c_double,\n            data.len() as c_int,\n            sampling_rate as c_int,\n            cutoff as c_double,\n            order as c_int,\n            filter_type as c_int,\n            ripple as c_double,\n        )\n    };\n    check_brainflow_exit_code(res)?;\n    Ok(())\n}", "item_id": 2, "repo": "xgdgsc/brainflow", "file": "rust-package/brainflow/src/data_filter.rs", "last_update_at": "2022-01-08T15:25:46+00:00", "question_id": "dedc3653184eef876ff815ddb0d57675ad5cc4cd_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn perform_highpass(\n    data: &mut [f64],\n    sampling_rate: usize,\n    cutoff: f64,\n    order: usize,\n    filter_type: FilterTypes,\n    ripple: f64,\n) -> Result<()> {\n    let res = unsafe {\n        data_handler::perform_highpass(\n            data.as_mut_ptr() as *mut c_double,\n            data.len() as c_int,\n            sampling_rate as c_int,\n            cutoff as c_double,\n            order as c_int,\n            filter_type as c_int,\n            ripple as c_double,\n        )\n    };\n    check_brainflow_exit_code(res)?;\n    Ok(())\n"]], "pred": {"ppl": 1.8598250150680542, "ppl_lower": 2.1799697875976562, "ppl/lowercase_ppl": -1.2559760132580378, "ppl/zlib": 0.0024049705634848987, "Min_5.0% Prob": 7.41742648018731, "Min_10.0% Prob": 4.893011620170192, "Min_20.0% Prob": 2.896408822191389, "Min_30.0% Prob": 2.0351158764801527, "Min_40.0% Prob": 1.548397870685317, "Min_50.0% Prob": 1.2444036770415934, "Min_60.0% Prob": 1.0388016317105084}}
{"hexsha": "2bc74d77633e7b155169b3cdb7c93955b7531403", "ext": "rs", "lang": "Rust", "content": "pub fn start_watcher<TApi>(\n    config_path: PathBuf,\n    config_directory_path: PathBuf,\n    api: std::sync::Arc<futures_util::lock::Mutex<TApi>>,\n) where\n    TApi: UpdateConfig + Send + 'static,\n{\n    // DEVNOTE: The channel created for file watcher receiver needs to address up to two messages,\n    // since the message is resent to file change receiver using a blocking send.\n    // When the number of messages is set to 1, then main thread appears to block.\n    let (file_changed_tx, mut file_changed_rx) = tokio::sync::mpsc::channel(2);\n\n    let config_path_clone = config_path.clone();\n    let config_directory_path_clone = config_directory_path.clone();\n\n    // Start file change listener that asynchronously reads and updates service config.\n    tokio::spawn(async move {\n        while let Some(()) = file_changed_rx.recv().await {\n            let new_config =\n                match crate::read_config(&config_path_clone, Some(&config_directory_path_clone)) {\n                    Ok(config) => config,\n                    Err(err) => {\n                        log::warn!(\n                        \"Detected config file update, but new config failed to parse. Error: {}\",\n                        err\n                    );\n                        continue;\n                    }\n                };\n\n            let mut api = api.lock().await;\n\n            if let Err(err) = api.update_config(new_config).await {\n                log::warn!(\"Config update failed. Error: {}\", err);\n            }\n        }\n    });\n\n    // Start file watcher using blocking channel.\n    std::thread::spawn({\n        move || {\n            let (file_watcher_tx, file_watcher_rx) = std::sync::mpsc::channel();\n\n            // Create a watcher object, delivering debounced events.\n            let mut file_watcher =\n                notify::watcher(file_watcher_tx, std::time::Duration::from_secs(10)).unwrap();\n\n            // Add configuration paths to be watched.\n            if config_directory_path.exists() {\n                file_watcher\n                    .watch(config_directory_path, notify::RecursiveMode::NonRecursive)\n                    .expect(\"Watching config directory path should not fail.\");\n            }\n\n            if config_path.exists() {\n                file_watcher\n                    .watch(config_path, notify::RecursiveMode::NonRecursive)\n                    .expect(\"Watching config file should not fail.\");\n            }\n\n            loop {\n                let event = file_watcher_rx.recv();\n                log::debug!(\"Incoming file watcher event: {:?}\", &event);\n\n                if let Ok(event) = event {\n                    match event {\n                        notify::DebouncedEvent::NoticeWrite(_)\n                        | notify::DebouncedEvent::NoticeRemove(_)\n                        | notify::DebouncedEvent::Rescan\n                        | notify::DebouncedEvent::Error(_, _) => {}\n\n                        notify::DebouncedEvent::Create(_)\n                        | notify::DebouncedEvent::Write(_)\n                        | notify::DebouncedEvent::Chmod(_)\n                        | notify::DebouncedEvent::Remove(_)\n                        | notify::DebouncedEvent::Rename(_, _) => {\n                            let _ = file_changed_tx.blocking_send(());\n                        }\n                    };\n                }\n            }\n        }\n    });\n}", "item_id": 0, "repo": "vadim-kovalyov/iot-identity-service", "file": "config-common/src/watcher.rs", "last_update_at": "2022-01-11T23:37:34+00:00", "question_id": "2bc74d77633e7b155169b3cdb7c93955b7531403_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn start_watcher<TApi>(\n    config_path: PathBuf,\n    config_directory_path: PathBuf,\n    api: std::sync::Arc<futures_util::lock::Mutex<TApi>>,\n) where\n    TApi: UpdateConfig + Send + 'static,\n{\n    // DEVNOTE: The channel created for file watcher receiver needs to address up to two messages,\n    // since the message is resent to file change receiver using a blocking send.\n    // When the number of messages is set to 1, then main thread appears to block.\n    let (file_changed_tx, mut file_changed_rx) = tokio::sync::mpsc::channel(2);\n    let config_path_clone = config_path.clone();\n    let config_directory_path_clone = config_directory_path.clone();\n    // Start file change listener that asynchronously reads and updates service config.\n    tokio::spawn(async move {\n        while let Some(()) = file_changed_rx.recv().await {\n            let new_config =\n                match crate::read_config(&config_path_clone, Some(&config_directory_path_clone)) {\n                    Ok(config) => config,\n                    Err(err) => {\n                        log::warn!(\n                        \"Detected config file update, but new config failed to parse. Error: {}\",\n                        err\n                    );\n                        continue;\n                    }\n                };\n            let mut api = api.lock().await;\n            if let Err(err) = api.update_config(new_config).await {\n                log::warn!(\"Config update failed. Error: {}\", err);\n            }\n        }\n    });\n    // Start file watcher using blocking channel.\n    std::thread::spawn({\n        move || {\n            let (file_watcher_tx, file_watcher_rx) = std::sync::mpsc::channel();\n            // Create a watcher object, delivering debounced events.\n            let mut file_watcher =\n                notify::watcher(file_watcher_tx, std::time::Duration::from_secs(10)).unwrap();\n            // Add configuration paths to be watched.\n            if config_directory_path.exists() {\n                file_watcher\n                    .watch(config_directory_path, notify::RecursiveMode::NonRecursive)\n                    .expect(\"Watching config directory path should not fail.\");\n            }\n            if config_path.exists() {\n                file_watcher\n                    .watch(config_path, notify::RecursiveMode::NonRecursive)\n                    .expect(\"Watching config file should not fail.\");\n            }\n            loop {\n                let event = file_watcher_rx.recv();\n                log::debug!(\"Incoming file watcher event: {:?}\", &event);\n                if let Ok(event) = event {\n                    match event {\n                        notify::DebouncedEvent::NoticeWrite(_)\n                        | notify::DebouncedEvent::NoticeRemove(_)\n                        | notify::DebouncedEvent::Rescan\n                        | notify::DebouncedEvent::Error(_, _) => {}\n                        notify::DebouncedEvent::Create(_)\n                        | notify::DebouncedEvent::Write(_)\n                        | notify::DebouncedEvent::Chmod(_)\n                        | notify::DebouncedEvent::Remove(_)\n                        | notify::DebouncedEvent::Rename(_, _) => {\n                            let _ = file_changed_tx.blocking_send(());\n                        }\n                    };\n                }\n            }\n        }\n    });\n"]], "pred": {"ppl": 2.023668050765991, "ppl_lower": 2.4185636043548584, "ppl/lowercase_ppl": -1.2528856772295844, "ppl/zlib": 0.0006681627786124495, "Min_5.0% Prob": 6.298083793285281, "Min_10.0% Prob": 4.729423262607092, "Min_20.0% Prob": 3.1689066736177467, "Min_30.0% Prob": 2.2851989891465383, "Min_40.0% Prob": 1.7530241441888932, "Min_50.0% Prob": 1.4075179905747863, "Min_60.0% Prob": 1.1753041782951381}}
{"hexsha": "36730aed9dfe5926038aaf7427051082fb9a2994", "ext": "rs", "lang": "Rust", "content": "fn get_expected_value_for_string_append_with_original_update_object(\n    original_update_object: &serde_json::value::Map<String, serde_json::Value>,\n    field: &'static Field<String>,\n    string: &str\n) -> Result<serde_json::value::Value, Box<dyn std::error::Error>> {\n    let original_bytes_option = original_update_object.get(&field.name);\n    let original_bytes = get_original_bytes(&original_bytes_option)?;\n\n    return Ok(\n        serde_json::json!(\n            original_bytes\n                .iter()\n                .chain(string.as_bytes())\n                .cloned()\n                .collect::<Vec<u8>>()\n        )\n    );\n}", "item_id": 1, "repo": "Sudograph/sudograph", "file": "sudograph-tests/canisters/test_utilities/src/arbitraries/queries/input_info_strategies/input_info_strategy_blob.rs", "last_update_at": "2022-03-30T21:02:23+00:00", "question_id": "36730aed9dfe5926038aaf7427051082fb9a2994_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_expected_value_for_string_append_with_original_update_object(\n    original_update_object: &serde_json::value::Map<String, serde_json::Value>,\n    field: &'static Field<String>,\n    string: &str\n) -> Result<serde_json::value::Value, Box<dyn std::error::Error>> {\n    let original_bytes_option = original_update_object.get(&field.name);\n    let original_bytes = get_original_bytes(&original_bytes_option)?;\n    return Ok(\n        serde_json::json!(\n            original_bytes\n                .iter()\n                .chain(string.as_bytes())\n                .cloned()\n                .collect::<Vec<u8>>()\n        )\n    );\n"]], "pred": {"ppl": 2.774040460586548, "ppl_lower": 3.6710238456726074, "ppl/lowercase_ppl": -1.274590164868313, "ppl/zlib": 0.003435370058700028, "Min_5.0% Prob": 8.089651107788086, "Min_10.0% Prob": 6.162456625386288, "Min_20.0% Prob": 4.262398584892876, "Min_30.0% Prob": 3.206846066734247, "Min_40.0% Prob": 2.4905478246026225, "Min_50.0% Prob": 2.037520734826103, "Min_60.0% Prob": 1.7095777118497568}}
{"hexsha": "cebf25bba760a73d8e3a6086e7f79edc52e1d037", "ext": "rs", "lang": "Rust", "content": "async fn test_pow() {\n        let pow_cfg = Config::load_test()\n            .and_then(|cfg| cfg.get::<PoWConfig>(\"pow\"))\n            .unwrap_or_default();\n        pow_cfg.install_as_global().ok();\n\n        let mut blk = Block::genesis_block();\n        blk.header.tx_list = std::iter::repeat_with(H256::zero).take(100).collect();\n\n        for _ in 0..30 {\n            let mut header = blk.header.clone();\n            header.height = header.height.next_height();\n            header.set_ts(Utc::now());\n            let new_blk = create_new_block(header, &blk).await.unwrap();\n            println!(\"diff = {}\", new_blk.diff);\n            println!(\"time = {}\", new_blk.time_stamp() - blk.time_stamp());\n            println!(\"nonce = {}\", new_blk.nonce);\n            println!(\"target = {}\", U256::MAX / U256::from(new_blk.diff));\n            println!(\"---------------------\");\n            blk = new_blk;\n        }\n    }", "item_id": 5, "repo": "hkbudb/slimchain", "file": "slimchain-chain/src/consensus/pow.rs", "last_update_at": "2022-02-13T13:51:45+00:00", "question_id": "cebf25bba760a73d8e3a6086e7f79edc52e1d037_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn test_pow() {\n        let pow_cfg = Config::load_test()\n            .and_then(|cfg| cfg.get::<PoWConfig>(\"pow\"))\n            .unwrap_or_default();\n        pow_cfg.install_as_global().ok();\n        let mut blk = Block::genesis_block();\n        blk.header.tx_list = std::iter::repeat_with(H256::zero).take(100).collect();\n        for _ in 0..30 {\n            let mut header = blk.header.clone();\n            header.height = header.height.next_height();\n            header.set_ts(Utc::now());\n            let new_blk = create_new_block(header, &blk).await.unwrap();\n            println!(\"diff = {}\", new_blk.diff);\n            println!(\"time = {}\", new_blk.time_stamp() - blk.time_stamp());\n            println!(\"nonce = {}\", new_blk.nonce);\n            println!(\"target = {}\", U256::MAX / U256::from(new_blk.diff));\n            println!(\"---------------------\");\n            blk = new_blk;\n        }\n"]], "pred": {"ppl": 3.1233415603637695, "ppl_lower": 3.429450035095215, "ppl/lowercase_ppl": -1.082093409896352, "ppl/zlib": 0.0028190679248349523, "Min_5.0% Prob": 7.612773990631103, "Min_10.0% Prob": 6.178579155604044, "Min_20.0% Prob": 4.55055799484253, "Min_30.0% Prob": 3.4777678006225163, "Min_40.0% Prob": 2.7516072844465573, "Min_50.0% Prob": 2.2526216401656467, "Min_60.0% Prob": 1.8966080102655622}}
{"hexsha": "4a10a39040b92a5447417c7ebb202e228a2ff783", "ext": "rs", "lang": "Rust", "content": "unsafe fn alloc(size: usize) -> (*mut u8, u64, usize) {\n        let (p, off, len, z) = Self::pre_alloc(size);\n        Self::drop_on_failure(off, len, z);\n        Self::perform(z);\n        (p, off, len)\n    }", "item_id": 6, "repo": "NVSL/Corundum", "file": "src/alloc/pool.rs", "last_update_at": "2022-02-18T22:36:33+00:00", "question_id": "4a10a39040b92a5447417c7ebb202e228a2ff783_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe fn alloc(size: usize) -> (*mut u8, u64, usize) {\n        let (p, off, len, z) = Self::pre_alloc(size);\n        Self::drop_on_failure(off, len, z);\n        Self::perform(z);\n        (p, off, len)\n"]], "pred": {"ppl": 5.095062255859375, "ppl_lower": 5.485203742980957, "ppl/lowercase_ppl": -1.0453132880097338, "ppl/zlib": 0.0124295563787077, "Min_5.0% Prob": 9.23698902130127, "Min_10.0% Prob": 8.102284729480743, "Min_20.0% Prob": 5.97063185274601, "Min_30.0% Prob": 4.75121125082175, "Min_40.0% Prob": 3.904704976826906, "Min_50.0% Prob": 3.2214923426508904, "Min_60.0% Prob": 2.722336087996761}}
{"hexsha": "9cf96a415ee61e2a06b10e1d6062498c19a98764", "ext": "rs", "lang": "Rust", "content": "fn buffer_length_is_correct_for_server_demand_active() {\n    let data = SERVER_DEMAND_ACTIVE.clone();\n    let expected_buffer_len = SERVER_DEMAND_ACTIVE_BUFFER.len();\n\n    let len = data.buffer_length();\n\n    assert_eq!(expected_buffer_len, len);\n}", "item_id": 3, "repo": "msabansal/IronRDP", "file": "ironrdp/src/rdp/capability_sets/test.rs", "last_update_at": "2022-03-28T01:31:18+00:00", "question_id": "9cf96a415ee61e2a06b10e1d6062498c19a98764_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn buffer_length_is_correct_for_server_demand_active() {\n    let data = SERVER_DEMAND_ACTIVE.clone();\n    let expected_buffer_len = SERVER_DEMAND_ACTIVE_BUFFER.len();\n    let len = data.buffer_length();\n    assert_eq!(expected_buffer_len, len);\n"]], "pred": {"ppl": 3.5129659175872803, "ppl_lower": 4.066806793212891, "ppl/lowercase_ppl": -1.116515742762948, "ppl/zlib": 0.007902268373834388, "Min_5.0% Prob": 9.674925327301025, "Min_10.0% Prob": 8.153895139694214, "Min_20.0% Prob": 5.402451360926909, "Min_30.0% Prob": 3.9814366606565623, "Min_40.0% Prob": 3.099705253328596, "Min_50.0% Prob": 2.5139471665024757, "Min_60.0% Prob": 2.10370459266991}}
{"hexsha": "2bd0b28762cbb562aef54469fa61edf0c4070892", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn prepare_effects(\n    mut commands: Commands,\n    sim_params: Res<SimParams>,\n    render_device: Res<RenderDevice>,\n    render_queue: Res<RenderQueue>,\n    //update_pipeline: Res<ParticlesUpdatePipeline>, // TODO move update_pipeline.pipeline to EffectsMeta\n    mut effects_meta: ResMut<EffectsMeta>,\n    mut extracted_effects: ResMut<ExtractedEffects>,\n) {\n    trace!(\"prepare_effects\");\n\n    // Allocate simulation uniform if needed\n    if effects_meta.sim_params_uniforms.is_empty() {\n        effects_meta\n            .sim_params_uniforms\n            .push(SimParamsUniform::default());\n    }\n\n    // Update simulation parameters\n    {\n        let sim_params_uni = effects_meta.sim_params_uniforms.get_mut(0);\n        let sim_params = *sim_params;\n        *sim_params_uni = sim_params.into();\n    }\n    trace!(\n        \"Simulation parameters: time={} dt={}\",\n        sim_params.time,\n        sim_params.dt\n    );\n    effects_meta\n        .sim_params_uniforms\n        .write_buffer(&render_device, &render_queue);\n\n    // Allocate spawner buffer if needed\n    //if effects_meta.spawner_buffer.is_empty() {\n    //    effects_meta.spawner_buffer.push(SpawnerParams::default());\n    //}\n\n    // Write vertices (TODO - lazily once only)\n    effects_meta\n        .vertices\n        .write_buffer(&render_device, &render_queue);\n\n    // Allocate GPU data for newly created effect instances. Do this first to ensure a group is not left\n    // unused and dropped due to the last effect being removed but a new compatible one added not being\n    // inserted yet. By inserting first, we ensure the group is not dropped in this case.\n    for added_effect in extracted_effects.added_effects.drain(..) {\n        let entity = added_effect.entity;\n        let id = effects_meta.effect_cache.insert(\n            added_effect.handle,\n            added_effect.capacity,\n            added_effect.item_size,\n            //update_pipeline.pipeline.clone(),\n            &render_queue,\n        );\n        let slice = effects_meta.effect_cache.get_slice(id);\n        effects_meta.entity_map.insert(entity, slice);\n    }\n\n    // Deallocate GPU data for destroyed effect instances. This will automatically drop any group where\n    // there is no more effect slice.\n    for _entity in extracted_effects.removed_effect_entities.iter() {\n        unimplemented!(\"Remove particle effect.\");\n        //effects_meta.remove(&*entity);\n    }\n\n    // // sort first by z and then by handle. this ensures that, when possible, batches span multiple z layers\n    // // batches won't span z-layers if there is another batch between them\n    // extracted_effects.effects.sort_by(|a, b| {\n    //     match FloatOrd(a.transform.w_axis[2]).cmp(&FloatOrd(b.transform.w_axis[2])) {\n    //         Ordering::Equal => a.handle.cmp(&b.handle),\n    //         other => other,\n    //     }\n    // });\n\n    // Get the effect-entity mapping\n    let mut effect_entity_list = extracted_effects\n        .effects\n        .iter()\n        .map(|(entity, extracted_effect)| {\n            let slice = effects_meta.entity_map.get(entity).unwrap().clone();\n            (slice, extracted_effect)\n        })\n        .collect::<Vec<_>>();\n    trace!(\"Collected {} extracted effects\", effect_entity_list.len());\n\n    // Sort first by effect buffer, then by slice range (see EffectSlice)\n    effect_entity_list.sort_by(|a, b| a.0.cmp(&b.0));\n\n    // Loop on all extracted effects in order\n    effects_meta.spawner_buffer.clear();\n    let mut spawner_base = 0;\n    let mut item_size = 0;\n    let mut current_buffer_index = u32::MAX;\n    let mut asset: Handle<EffectAsset> = Default::default();\n    let mut layout_flags = LayoutFlags::NONE;\n    let mut image_handle_id: HandleId = HandleId::default::<Image>();\n    let mut shader: Handle<Shader> = Default::default();\n    let mut start = 0;\n    let mut end = 0;\n    let mut num_emitted = 0;\n    let mut position_code = String::default();\n    let mut force_field_code = String::default();\n    let mut lifetime_code = String::default();\n\n    for (slice, extracted_effect) in effect_entity_list {\n        let buffer_index = slice.group_index;\n        let range = slice.slice;\n        layout_flags = if extracted_effect.has_image {\n            LayoutFlags::PARTICLE_TEXTURE\n        } else {\n            LayoutFlags::NONE\n        };\n        image_handle_id = extracted_effect.image_handle_id;\n        trace!(\"Effect: buffer #{} | range {:?}\", buffer_index, range);\n\n        // Check the buffer the effect is in\n        assert!(buffer_index >= current_buffer_index || current_buffer_index == u32::MAX);\n        if current_buffer_index != buffer_index {\n            trace!(\n                \"+ New buffer! ({} -> {})\",\n                current_buffer_index,\n                buffer_index\n            );\n            // Commit previous buffer if any\n            if current_buffer_index != u32::MAX {\n                // Record open batch if any\n                trace!(\"+ Prev: {} - {}\", start, end);\n                if end > start {\n                    assert_ne!(asset, Handle::<EffectAsset>::default());\n                    assert!(item_size > 0);\n                    trace!(\n                        \"Emit batch: buffer #{} | spawner_base {} | slice {:?} | item_size {} | shader {:?}\",\n                        current_buffer_index,\n                        spawner_base,\n                        start..end,\n                        item_size,\n                        shader\n                    );\n                    commands.spawn_bundle((EffectBatch {\n                        buffer_index: current_buffer_index,\n                        spawner_base: spawner_base as u32,\n                        slice: start..end,\n                        item_size,\n                        handle: asset.clone_weak(),\n                        layout_flags,\n                        image_handle_id,\n                        shader: shader.clone(),\n                        position_code: position_code.clone(),\n                        force_field_code: force_field_code.clone(),\n                        lifetime_code: lifetime_code.clone(),\n                        compute_pipeline: None,\n                    },));\n                    num_emitted += 1;\n                }\n            }\n\n            // Move to next buffer\n            current_buffer_index = buffer_index;\n            start = 0;\n            end = 0;\n            spawner_base = effects_meta.spawner_buffer.len();\n            trace!(\"+ New spawner_base = {}\", spawner_base);\n            // Each effect buffer contains effect instances with a compatible layout\n            // FIXME - Currently this means same effect asset, so things are easier...\n            asset = extracted_effect.handle.clone_weak();\n            item_size = slice.item_size;\n        }\n\n        assert_ne!(asset, Handle::<EffectAsset>::default());\n\n        shader = extracted_effect.shader.clone();\n        trace!(\"shader = {:?}\", shader);\n\n        trace!(\"item_size = {}B\", slice.item_size);\n\n        position_code = extracted_effect.position_code.clone();\n        trace!(\"position_code = {}\", position_code);\n\n        force_field_code = extracted_effect.force_field_code.clone();\n        trace!(\"force_field_code = {}\", force_field_code);\n\n        lifetime_code = extracted_effect.lifetime_code.clone();\n        trace!(\"lifetime_code = {}\", lifetime_code);\n\n        // extract the force field and turn it into a struct that is compliant with Std430,\n        // namely ForceFieldStd430\n        let mut extracted_force_field = [ForceFieldStd430::default(); FFNUM];\n        for (i, ff) in extracted_effect.force_field.iter().enumerate() {\n            extracted_force_field[i] = (*ff).into();\n        }\n\n        // Prepare the spawner block for the current slice\n        // FIXME - This is once per EFFECT/SLICE, not once per BATCH, so indeed this is spawner_BASE, and need an array of them in the compute shader!!!!!!!!!!!!!!\n        let spawner_params = SpawnerParams {\n            spawn: extracted_effect.spawn_count as i32,\n            count: 0,\n            origin: extracted_effect.transform.col(3).truncate(),\n            accel: extracted_effect.accel,\n            force_field: extracted_force_field, // extracted_effect.force_field,\n            seed: random::<u32>(),\n            ..Default::default()\n        };\n        trace!(\"spawner_params = {:?}\", spawner_params);\n        effects_meta.spawner_buffer.push(spawner_params);\n\n        trace!(\"slice = {}-{} | prev end = {}\", range.start, range.end, end);\n        if (range.start > end) || (item_size != slice.item_size) {\n            // Discontinuous slices; create a new batch\n            if end > start {\n                // Record the previous batch\n                assert_ne!(asset, Handle::<EffectAsset>::default());\n                assert!(item_size > 0);\n                trace!(\n                    \"Emit batch: buffer #{} | spawner_base {} | slice {:?} | item_size {} | shader {:?}\",\n                    buffer_index,\n                    spawner_base,\n                    start..end,\n                    item_size,\n                    shader\n                );\n                commands.spawn_bundle((EffectBatch {\n                    buffer_index,\n                    spawner_base: spawner_base as u32,\n                    slice: start..end,\n                    item_size,\n                    handle: asset.clone_weak(),\n                    layout_flags,\n                    image_handle_id,\n                    shader: shader.clone(),\n                    position_code: position_code.clone(),\n                    force_field_code: force_field_code.clone(),\n                    lifetime_code: lifetime_code.clone(),\n                    compute_pipeline: None,\n                },));\n                num_emitted += 1;\n            }\n            start = range.start;\n            item_size = slice.item_size;\n        }\n        end = range.end;\n    }\n\n    // Record last open batch if any\n    if end > start {\n        assert_ne!(asset, Handle::<EffectAsset>::default());\n        assert!(item_size > 0);\n        trace!(\n            \"Emit LAST batch: buffer #{} | spawner_base {} | slice {:?} | item_size {} | shader {:?}\",\n            current_buffer_index,\n            spawner_base,\n            start..end,\n            item_size,\n            shader\n        );\n        commands.spawn_bundle((EffectBatch {\n            buffer_index: current_buffer_index,\n            spawner_base: spawner_base as u32,\n            slice: start..end,\n            item_size,\n            handle: asset.clone_weak(),\n            layout_flags,\n            image_handle_id,\n            shader,\n            position_code,\n            force_field_code,\n            lifetime_code,\n            compute_pipeline: None,\n        },));\n        num_emitted += 1;\n    }\n    trace!(\n        \"Emitted {} buffers, spawner_buffer len = {}\",\n        num_emitted,\n        effects_meta.spawner_buffer.len()\n    );\n\n    // Write the entire spawner buffer for this frame, for all effects combined\n    effects_meta\n        .spawner_buffer\n        .write_buffer(&render_device, &render_queue);\n}", "item_id": 2, "repo": "djeedai/bevy_hanabi", "file": "src/render/mod.rs", "last_update_at": "2022-03-31T09:51:15+00:00", "question_id": "2bd0b28762cbb562aef54469fa61edf0c4070892_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn prepare_effects(\n    mut commands: Commands,\n    sim_params: Res<SimParams>,\n    render_device: Res<RenderDevice>,\n    render_queue: Res<RenderQueue>,\n    //update_pipeline: Res<ParticlesUpdatePipeline>, // TODO move update_pipeline.pipeline to EffectsMeta\n    mut effects_meta: ResMut<EffectsMeta>,\n    mut extracted_effects: ResMut<ExtractedEffects>,\n) {\n    trace!(\"prepare_effects\");\n    // Allocate simulation uniform if needed\n    if effects_meta.sim_params_uniforms.is_empty() {\n        effects_meta\n            .sim_params_uniforms\n            .push(SimParamsUniform::default());\n    }\n    // Update simulation parameters\n    {\n        let sim_params_uni = effects_meta.sim_params_uniforms.get_mut(0);\n        let sim_params = *sim_params;\n        *sim_params_uni = sim_params.into();\n    }\n    trace!(\n        \"Simulation parameters: time={} dt={}\",\n        sim_params.time,\n        sim_params.dt\n    );\n    effects_meta\n        .sim_params_uniforms\n        .write_buffer(&render_device, &render_queue);\n    // Allocate spawner buffer if needed\n    //if effects_meta.spawner_buffer.is_empty() {\n    //    effects_meta.spawner_buffer.push(SpawnerParams::default());\n    //}\n    // Write vertices (TODO - lazily once only)\n    effects_meta\n        .vertices\n        .write_buffer(&render_device, &render_queue);\n    // Allocate GPU data for newly created effect instances. Do this first to ensure a group is not left\n    // unused and dropped due to the last effect being removed but a new compatible one added not being\n    // inserted yet. By inserting first, we ensure the group is not dropped in this case.\n    for added_effect in extracted_effects.added_effects.drain(..) {\n        let entity = added_effect.entity;\n        let id = effects_meta.effect_cache.insert(\n            added_effect.handle,\n            added_effect.capacity,\n            added_effect.item_size,\n            //update_pipeline.pipeline.clone(),\n            &render_queue,\n        );\n        let slice = effects_meta.effect_cache.get_slice(id);\n        effects_meta.entity_map.insert(entity, slice);\n    }\n    // Deallocate GPU data for destroyed effect instances. This will automatically drop any group where\n    // there is no more effect slice.\n    for _entity in extracted_effects.removed_effect_entities.iter() {\n        unimplemented!(\"Remove particle effect.\");\n        //effects_meta.remove(&*entity);\n    }\n    // // sort first by z and then by handle. this ensures that, when possible, batches span multiple z layers\n    // // batches won't span z-layers if there is another batch between them\n    // extracted_effects.effects.sort_by(|a, b| {\n    //     match FloatOrd(a.transform.w_axis[2]).cmp(&FloatOrd(b.transform.w_axis[2])) {\n    //         Ordering::Equal => a.handle.cmp(&b.handle),\n    //         other => other,\n    //     }\n    // });\n    // Get the effect-entity mapping\n    let mut effect_entity_list = extracted_effects\n        .effects\n        .iter()\n        .map(|(entity, extracted_effect)| {\n            let slice = effects_meta.entity_map.get(entity).unwrap().clone();\n            (slice, extracted_effect)\n        })\n        .collect::<Vec<_>>();\n    trace!(\"Collected {} extracted effects\", effect_entity_list.len());\n    // Sort first by effect buffer, then by slice range (see EffectSlice)\n    effect_entity_list.sort_by(|a, b| a.0.cmp(&b.0));\n    // Loop on all extracted effects in order\n    effects_meta.spawner_buffer.clear();\n    let mut spawner_base = 0;\n    let mut item_size = 0;\n    let mut current_buffer_index = u32::MAX;\n    let mut asset: Handle<EffectAsset> = Default::default();\n    let mut layout_flags = LayoutFlags::NONE;\n    let mut image_handle_id: HandleId = HandleId::default::<Image>();\n    let mut shader: Handle<Shader> = Default::default();\n    let mut start = 0;\n    let mut end = 0;\n    let mut num_emitted = 0;\n    let mut position_code = String::default();\n    let mut force_field_code = String::default();\n    let mut lifetime_code = String::default();\n    for (slice, extracted_effect) in effect_entity_list {\n        let buffer_index = slice.group_index;\n        let range = slice.slice;\n        layout_flags = if extracted_effect.has_image {\n            LayoutFlags::PARTICLE_TEXTURE\n        } else {\n            LayoutFlags::NONE\n        };\n        image_handle_id = extracted_effect.image_handle_id;\n        trace!(\"Effect: buffer #{} | range {:?}\", buffer_index, range);\n        // Check the buffer the effect is in\n        assert!(buffer_index >= current_buffer_index || current_buffer_index == u32::MAX);\n        if current_buffer_index != buffer_index {\n            trace!(\n                \"+ New buffer! ({} -> {})\",\n                current_buffer_index,\n                buffer_index\n            );\n            // Commit previous buffer if any\n            if current_buffer_index != u32::MAX {\n                // Record open batch if any\n                trace!(\"+ Prev: {} - {}\", start, end);\n                if end > start {\n                    assert_ne!(asset, Handle::<EffectAsset>::default());\n                    assert!(item_size > 0);\n                    trace!(\n                        \"Emit batch: buffer #{} | spawner_base {} | slice {:?} | item_size {} | shader {:?}\",\n                        current_buffer_index,\n                        spawner_base,\n                        start..end,\n                        item_size,\n                        shader\n                    );\n                    commands.spawn_bundle((EffectBatch {\n                        buffer_index: current_buffer_index,\n                        spawner_base: spawner_base as u32,\n                        slice: start..end,\n                        item_size,\n                        handle: asset.clone_weak(),\n                        layout_flags,\n                        image_handle_id,\n                        shader: shader.clone(),\n                        position_code: position_code.clone(),\n                        force_field_code: force_field_code.clone(),\n                        lifetime_code: lifetime_code.clone(),\n                        compute_pipeline: None,\n                    },));\n                    num_emitted += 1;\n                }\n            }\n            // Move to next buffer\n            current_buffer_index = buffer_index;\n            start = 0;\n            end = 0;\n            spawner_base = effects_meta.spawner_buffer.len();\n            trace!(\"+ New spawner_base = {}\", spawner_base);\n            // Each effect buffer contains effect instances with a compatible layout\n            // FIXME - Currently this means same effect asset, so things are easier...\n            asset = extracted_effect.handle.clone_weak();\n            item_size = slice.item_size;\n        }\n        assert_ne!(asset, Handle::<EffectAsset>::default());\n        shader = extracted_effect.shader.clone();\n        trace!(\"shader = {:?}\", shader);\n        trace!(\"item_size = {}B\", slice.item_size);\n        position_code = extracted_effect.position_code.clone();\n        trace!(\"position_code = {}\", position_code);\n        force_field_code = extracted_effect.force_field_code.clone();\n        trace!(\"force_field_code = {}\", force_field_code);\n        lifetime_code = extracted_effect.lifetime_code.clone();\n        trace!(\"lifetime_code = {}\", lifetime_code);\n        // extract the force field and turn it into a struct that is compliant with Std430,\n        // namely ForceFieldStd430\n        let mut extracted_force_field = [ForceFieldStd430::default(); FFNUM];\n        for (i, ff) in extracted_effect.force_field.iter().enumerate() {\n            extracted_force_field[i] = (*ff).into();\n        }\n        // Prepare the spawner block for the current slice\n        // FIXME - This is once per EFFECT/SLICE, not once per BATCH, so indeed this is spawner_BASE, and need an array of them in the compute shader!!!!!!!!!!!!!!\n        let spawner_params = SpawnerParams {\n            spawn: extracted_effect.spawn_count as i32,\n            count: 0,\n            origin: extracted_effect.transform.col(3).truncate(),\n            accel: extracted_effect.accel,\n            force_field: extracted_force_field, // extracted_effect.force_field,\n            seed: random::<u32>(),\n            ..Default::default()\n        };\n        trace!(\"spawner_params = {:?}\", spawner_params);\n        effects_meta.spawner_buffer.push(spawner_params);\n        trace!(\"slice = {}-{} | prev end = {}\", range.start, range.end, end);\n        if (range.start > end) || (item_size != slice.item_size) {\n            // Discontinuous slices; create a new batch\n            if end > start {\n                // Record the previous batch\n                assert_ne!(asset, Handle::<EffectAsset>::default());\n                assert!(item_size > 0);\n                trace!(\n                    \"Emit batch: buffer #{} | spawner_base {} | slice {:?} | item_size {} | shader {:?}\",\n                    buffer_index,\n                    spawner_base,\n                    start..end,\n                    item_size,\n                    shader\n                );\n                commands.spawn_bundle((EffectBatch {\n                    buffer_index,\n                    spawner_base: spawner_base as u32,\n                    slice: start..end,\n                    item_size,\n                    handle: asset.clone_weak(),\n                    layout_flags,\n                    image_handle_id,\n                    shader: shader.clone(),\n                    position_code: position_code.clone(),\n                    force_field_code: force_field_code.clone(),\n                    lifetime_code: lifetime_code.clone(),\n                    compute_pipeline: None,\n                },));\n                num_emitted += 1;\n            }\n            start = range.start;\n            item_size = slice.item_size;\n        }\n        end = range.end;\n    }\n    // Record last open batch if any\n    if end > start {\n        assert_ne!(asset, Handle::<EffectAsset>::default());\n        assert!(item_size > 0);\n        trace!(\n            \"Emit LAST batch: buffer #{} | spawner_base {} | slice {:?} | item_size {} | shader {:?}\",\n            current_buffer_index,\n            spawner_base,\n            start..end,\n            item_size,\n            shader\n        );\n        commands.spawn_bundle((EffectBatch {\n            buffer_index: current_buffer_index,\n            spawner_base: spawner_base as u32,\n            slice: start..end,\n            item_size,\n            handle: asset.clone_weak(),\n            layout_flags,\n            image_handle_id,\n            shader,\n            position_code,\n            force_field_code,\n            lifetime_code,\n            compute_pipeline: None,\n        },));\n        num_emitted += 1;\n    }\n    trace!(\n        \"Emitted {} buffers, spawner_buffer len = {}\",\n        num_emitted,\n        effects_meta.spawner_buffer.len()\n    );\n    // Write the entire spawner buffer for this frame, for all effects combined\n    effects_meta\n        .spawner_buffer\n        .write_buffer(&render_device, &render_queue);\n"]], "pred": {"ppl": 3.0395543575286865, "ppl_lower": 3.3846850395202637, "ppl/lowercase_ppl": -1.096742726199726, "ppl/zlib": 0.00039199961627438046, "Min_5.0% Prob": 7.706717687494614, "Min_10.0% Prob": 6.2573251490499455, "Min_20.0% Prob": 4.595200017386792, "Min_30.0% Prob": 3.472509133075577, "Min_40.0% Prob": 2.7156148829786586, "Min_50.0% Prob": 2.2112787751856384, "Min_60.0% Prob": 1.8521657584396116}}
{"hexsha": "45d755071fd38bd417786aa87f53f00b64a9a613", "ext": "rs", "lang": "Rust", "content": "fn get_settings_interactively() -> Settings {\n    let mut input = String::new();\n\n    print!(\"Enter the C/C++ file to be converted to Rust : \");\n    io::stdout().flush().expect(\"FATAL : Buffer flush failed\");\n    io::stdin().read_line(&mut input).expect(\"Unable to read\");\n\n    let mut strict = String::new();\n\n    print!(\"Enter the translation mode [(S/s)trict/(L/l)oose] : \");\n    io::stdout().flush().expect(\"FATAL : Buffer flush failed\");\n    io::stdin().read_line(&mut strict).expect(\"Unable to read\");\n    let strict = strict.trim();\n    let strict = matches!(strict, \"S\" | \"Strict\" | \"s\");\n\n    let mut cargo = String::new();\n    print!(\"Do you want to create a cargo project :[Y/N]\");\n    io::stdout().flush().expect(\"FATAL : Buffer flush failed.\");\n    io::stdin()\n        .read_line(&mut cargo)\n        .expect(\"Unable to read input\");\n    let cargo = cargo.trim();\n    let cargo: bool = matches!(cargo, \"Y\" | \"y\");\n\n    let mut project_name = None;\n    if cargo {\n        let mut project = String::new();\n        print!(\"Enter cargo project name : \");\n        io::stdout().flush().expect(\"FATAL : Buffer flush failed\");\n        io::stdin()\n            .read_line(&mut project)\n            .expect(\"Unable to read input\");\n        project_name = Some(String::from(project.trim()));\n    }\n\n    Settings {\n        strict,\n        project_name,\n        files: vec![input.trim().to_owned()],\n    }\n}", "item_id": 1, "repo": "m-abrarhasan/crust", "file": "src/main.rs", "last_update_at": "2022-03-27T19:23:27+00:00", "question_id": "45d755071fd38bd417786aa87f53f00b64a9a613_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_settings_interactively() -> Settings {\n    let mut input = String::new();\n    print!(\"Enter the C/C++ file to be converted to Rust : \");\n    io::stdout().flush().expect(\"FATAL : Buffer flush failed\");\n    io::stdin().read_line(&mut input).expect(\"Unable to read\");\n    let mut strict = String::new();\n    print!(\"Enter the translation mode [(S/s)trict/(L/l)oose] : \");\n    io::stdout().flush().expect(\"FATAL : Buffer flush failed\");\n    io::stdin().read_line(&mut strict).expect(\"Unable to read\");\n    let strict = strict.trim();\n    let strict = matches!(strict, \"S\" | \"Strict\" | \"s\");\n    let mut cargo = String::new();\n    print!(\"Do you want to create a cargo project :[Y/N]\");\n    io::stdout().flush().expect(\"FATAL : Buffer flush failed.\");\n    io::stdin()\n        .read_line(&mut cargo)\n        .expect(\"Unable to read input\");\n    let cargo = cargo.trim();\n    let cargo: bool = matches!(cargo, \"Y\" | \"y\");\n    let mut project_name = None;\n    if cargo {\n        let mut project = String::new();\n        print!(\"Enter cargo project name : \");\n        io::stdout().flush().expect(\"FATAL : Buffer flush failed\");\n        io::stdin()\n            .read_line(&mut project)\n            .expect(\"Unable to read input\");\n        project_name = Some(String::from(project.trim()));\n    }\n    Settings {\n        strict,\n        project_name,\n        files: vec![input.trim().to_owned()],\n    }\n"]], "pred": {"ppl": 2.0331320762634277, "ppl_lower": 2.2635576725006104, "ppl/lowercase_ppl": -1.1513016807648717, "ppl/zlib": 0.0015161912365931275, "Min_5.0% Prob": 6.975764864966983, "Min_10.0% Prob": 5.207149165017264, "Min_20.0% Prob": 3.2644575946471273, "Min_30.0% Prob": 2.307800499140285, "Min_40.0% Prob": 1.7603393295529293, "Min_50.0% Prob": 1.4152397477268197, "Min_60.0% Prob": 1.1853030588445108}}
{"hexsha": "767350991ac08cc681344bf1063ed059726417c0", "ext": "rs", "lang": "Rust", "content": "fn test_loop_else_trim12() {\n    let t = LoopElseTrim12 { values: &[1] };\n    assert_eq!(t.render().unwrap(), \"a \\t1 b\");\n\n    let t = LoopElseTrim12 { values: &[] };\n    assert_eq!(t.render().unwrap(), \"a X\\n b\");\n}", "item_id": 13, "repo": "gpmake/askama", "file": "testing/tests/loop_else.rs", "last_update_at": "2022-01-19T19:15:54+00:00", "question_id": "767350991ac08cc681344bf1063ed059726417c0_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_loop_else_trim12() {\n    let t = LoopElseTrim12 { values: &[1] };\n    assert_eq!(t.render().unwrap(), \"a \\t1 b\");\n    let t = LoopElseTrim12 { values: &[] };\n    assert_eq!(t.render().unwrap(), \"a X\\n b\");\n"]], "pred": {"ppl": 4.979050159454346, "ppl_lower": 6.435937404632568, "ppl/lowercase_ppl": -1.1598879287000807, "ppl/zlib": 0.01234799339855247, "Min_5.0% Prob": 9.391074895858765, "Min_10.0% Prob": 8.215599536895752, "Min_20.0% Prob": 6.533101222094367, "Min_30.0% Prob": 5.092193548495953, "Min_40.0% Prob": 3.964314522062029, "Min_50.0% Prob": 3.215615091337399, "Min_60.0% Prob": 2.688447928091265}}
{"hexsha": "0953cf2ae6dc86f53baca42a655a6165a3597861", "ext": "rs", "lang": "Rust", "content": "pub fn search<E: SearchEnv>(env: &mut E, name: &str) -> Option<Target> {\n    if name.contains('/') {\n        return if let Ok(path) = CString::new(name) {\n            Some(Target::External { path })\n        } else {\n            None\n        };\n    }\n\n    let builtin = env.builtins().get(name).copied();\n    if let Some(builtin) = builtin {\n        if builtin.r#type == Special {\n            return Some(builtin.into());\n        }\n    }\n\n    if let Some(function) = env.functions().get(name) {\n        return Some(function.0.clone().into());\n    }\n\n    if let Some(builtin) = builtin {\n        if builtin.r#type == Intrinsic {\n            return Some(builtin.into());\n        }\n    }\n\n    if let Some(path) = search_path(env, name) {\n        if let Some(builtin) = builtin {\n            assert_eq!(builtin.r#type, NonIntrinsic);\n            return Some(builtin.into());\n        }\n        return Some(Target::External { path });\n    }\n\n    None\n}", "item_id": 0, "repo": "magicant/yash-rs", "file": "yash-semantics/src/command_search.rs", "last_update_at": "2022-03-24T10:45:57+00:00", "question_id": "0953cf2ae6dc86f53baca42a655a6165a3597861_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn search<E: SearchEnv>(env: &mut E, name: &str) -> Option<Target> {\n    if name.contains('/') {\n        return if let Ok(path) = CString::new(name) {\n            Some(Target::External { path })\n        } else {\n            None\n        };\n    }\n    let builtin = env.builtins().get(name).copied();\n    if let Some(builtin) = builtin {\n        if builtin.r#type == Special {\n            return Some(builtin.into());\n        }\n    }\n    if let Some(function) = env.functions().get(name) {\n        return Some(function.0.clone().into());\n    }\n    if let Some(builtin) = builtin {\n        if builtin.r#type == Intrinsic {\n            return Some(builtin.into());\n        }\n    }\n    if let Some(path) = search_path(env, name) {\n        if let Some(builtin) = builtin {\n            assert_eq!(builtin.r#type, NonIntrinsic);\n            return Some(builtin.into());\n        }\n        return Some(Target::External { path });\n    }\n    None\n"]], "pred": {"ppl": 2.1587882041931152, "ppl_lower": 2.5350499153137207, "ppl/lowercase_ppl": -1.2087803209699517, "ppl/zlib": 0.0022370553711922366, "Min_5.0% Prob": 7.179217508860996, "Min_10.0% Prob": 5.317865248384146, "Min_20.0% Prob": 3.413936721066297, "Min_30.0% Prob": 2.469969526435552, "Min_40.0% Prob": 1.9060228035605253, "Min_50.0% Prob": 1.536952871504246, "Min_60.0% Prob": 1.2835154588068913}}
{"hexsha": "8abbbca823e7bcb5fde0e048d55209945d99b1a9", "ext": "rs", "lang": "Rust", "content": "fn _0032(b: &mut Bencher) {\n  let ctx = context(r#\"{}\"#);\n  let invocable_name = \"feel-date-function_ErrorCase_032_fc66cc2fec\";\n  assert_decision(&MODEL_EVALUATOR, invocable_name, &ctx, r#\"null([core::date] invalid date string '')\"#);\n  b.iter(|| MODEL_EVALUATOR.evaluate_invocable(invocable_name, &ctx));\n}", "item_id": 31, "repo": "dmntk/dmntk.rs", "file": "model-evaluator/benches/compliance/dmn_3_1115.rs", "last_update_at": "2022-03-31T13:13:29+00:00", "question_id": "8abbbca823e7bcb5fde0e048d55209945d99b1a9_31", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn _0032(b: &mut Bencher) {\n  let ctx = context(r#\"{}\"#);\n  let invocable_name = \"feel-date-function_ErrorCase_032_fc66cc2fec\";\n  assert_decision(&MODEL_EVALUATOR, invocable_name, &ctx, r#\"null([core::date] invalid date string '')\"#);\n  b.iter(|| MODEL_EVALUATOR.evaluate_invocable(invocable_name, &ctx));\n"]], "pred": {"ppl": 4.101737976074219, "ppl_lower": 6.134175777435303, "ppl/lowercase_ppl": -1.285150819731615, "ppl/zlib": 0.006386474119886636, "Min_5.0% Prob": 9.71348508199056, "Min_10.0% Prob": 7.691585063934326, "Min_20.0% Prob": 5.516899426778157, "Min_30.0% Prob": 4.409033728808891, "Min_40.0% Prob": 3.5311038113302655, "Min_50.0% Prob": 2.8360452271778795, "Min_60.0% Prob": 2.3572416169023733}}
{"hexsha": "6350c5fb113a1102b491ea5d2d9f622932f2b5a8", "ext": "rs", "lang": "Rust", "content": "fn list_with_text() {\n    // root (Document)\n    // \u2514\u2500\u2500 html\n    //     \u2514\u2500\u2500 head\n    //     \u2514\u2500\u2500 body\n    //         \u2514\u2500\u2500 ul\n    //             \u2514\u2500\u2500 li\n    //                 \u2514\u2500\u2500 list 1\n    //             \u2514\u2500\u2500 li\n    //                 \u2514\u2500\u2500 list 2\n    let root = create_base_dom_tree();\n    let mut body = root\n        .borrow_mut()\n        .first_child()\n        .unwrap()\n        .borrow_mut()\n        .first_child()\n        .unwrap()\n        .borrow_mut()\n        .next_sibling()\n        .unwrap();\n    add_child_ul_to(&mut body);\n\n    let mut li1 = body\n        .borrow_mut()\n        .first_child()\n        .unwrap()\n        .borrow_mut()\n        .first_child()\n        .unwrap();\n    add_text_node_to(&mut li1, \"list 1\");\n\n    let mut l12 = li1.borrow_mut().next_sibling().unwrap();\n    add_text_node_to(&mut l12, \"list 2\");\n\n    run_test!(\n        \"<html><head></head><body><ul><li>list 1</li><li>list 2</li></ul></body></html>\",\n        Some(root)\n    );\n}", "item_id": 10, "repo": "hikalium/liumos", "file": "app/browser-rs/tests/dom.rs", "last_update_at": "2022-03-24T19:02:52+00:00", "question_id": "6350c5fb113a1102b491ea5d2d9f622932f2b5a8_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn list_with_text() {\n    // root (Document)\n    // \u2514\u2500\u2500 html\n    //     \u2514\u2500\u2500 head\n    //     \u2514\u2500\u2500 body\n    //         \u2514\u2500\u2500 ul\n    //             \u2514\u2500\u2500 li\n    //                 \u2514\u2500\u2500 list 1\n    //             \u2514\u2500\u2500 li\n    //                 \u2514\u2500\u2500 list 2\n    let root = create_base_dom_tree();\n    let mut body = root\n        .borrow_mut()\n        .first_child()\n        .unwrap()\n        .borrow_mut()\n        .first_child()\n        .unwrap()\n        .borrow_mut()\n        .next_sibling()\n        .unwrap();\n    add_child_ul_to(&mut body);\n    let mut li1 = body\n        .borrow_mut()\n        .first_child()\n        .unwrap()\n        .borrow_mut()\n        .first_child()\n        .unwrap();\n    add_text_node_to(&mut li1, \"list 1\");\n    let mut l12 = li1.borrow_mut().next_sibling().unwrap();\n    add_text_node_to(&mut l12, \"list 2\");\n    run_test!(\n        \"<html><head></head><body><ul><li>list 1</li><li>list 2</li></ul></body></html>\",\n        Some(root)\n    );\n"]], "pred": {"ppl": 1.9019861221313477, "ppl_lower": 1.9374662637710571, "ppl/lowercase_ppl": -1.0287485464527035, "ppl/zlib": 0.0020027995876500575, "Min_5.0% Prob": 6.998618692159653, "Min_10.0% Prob": 4.9453663500872524, "Min_20.0% Prob": 3.0242003362570236, "Min_30.0% Prob": 2.104203982370915, "Min_40.0% Prob": 1.5992812608403189, "Min_50.0% Prob": 1.2836219256732768, "Min_60.0% Prob": 1.0751637526485829}}
{"hexsha": "46d192f462c52cc588e61632f92ee4effa4bbd01", "ext": "rs", "lang": "Rust", "content": "pub fn verify_fuchsia_pkg_cm_url(url: &str) -> Result<String> {\n    let url = match PkgUrl::parse(url) {\n        Ok(url) => url,\n        Err(e) => ffx_bail!(\"URL parsing error: {:?}\", e),\n    };\n\n    let resource = url.resource().ok_or(ffx_error!(\"URL does not contain a path to a manifest\"))?;\n    let manifest = resource\n        .split('/')\n        .last()\n        .ok_or(ffx_error!(\"Could not extract manifest filename from URL\"))?;\n\n    if let Some(name) = manifest.strip_suffix(\".cm\") {\n        Ok(name.to_string())\n    } else if manifest.ends_with(\".cmx\") {\n        ffx_bail!(\n            \"{} is a legacy component manifest. Run it using `ffx component run-legacy`\",\n            manifest\n        )\n    } else {\n        ffx_bail!(\n            \"{} is not a component manifest! Component manifests must end in the `cm` extension.\",\n            manifest\n        )\n    }\n}", "item_id": 1, "repo": "fabio-d/fuchsia-stardock", "file": "src/developer/ffx/plugins/component/common/src/lib.rs", "last_update_at": "2022-01-21T20:14:17+00:00", "question_id": "46d192f462c52cc588e61632f92ee4effa4bbd01_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn verify_fuchsia_pkg_cm_url(url: &str) -> Result<String> {\n    let url = match PkgUrl::parse(url) {\n        Ok(url) => url,\n        Err(e) => ffx_bail!(\"URL parsing error: {:?}\", e),\n    };\n    let resource = url.resource().ok_or(ffx_error!(\"URL does not contain a path to a manifest\"))?;\n    let manifest = resource\n        .split('/')\n        .last()\n        .ok_or(ffx_error!(\"Could not extract manifest filename from URL\"))?;\n    if let Some(name) = manifest.strip_suffix(\".cm\") {\n        Ok(name.to_string())\n    } else if manifest.ends_with(\".cmx\") {\n        ffx_bail!(\n            \"{} is a legacy component manifest. Run it using `ffx component run-legacy`\",\n            manifest\n        )\n    } else {\n        ffx_bail!(\n            \"{} is not a component manifest! Component manifests must end in the `cm` extension.\",\n            manifest\n        )\n    }\n"]], "pred": {"ppl": 2.4664926528930664, "ppl_lower": 2.917426347732544, "ppl/lowercase_ppl": -1.1859827255027446, "ppl/zlib": 0.002149517054593064, "Min_5.0% Prob": 7.393110018510085, "Min_10.0% Prob": 5.845125269006799, "Min_20.0% Prob": 3.9025023999037565, "Min_30.0% Prob": 2.8820455096386097, "Min_40.0% Prob": 2.2229760861998304, "Min_50.0% Prob": 1.802805408342358, "Min_60.0% Prob": 1.5103644050794875}}
{"hexsha": "dbfb6f95a5a3c09d2aa1f8d7c6669ef2bd25601e", "ext": "rs", "lang": "Rust", "content": "fn read_document_nok_not_found() {\n\n    let (_server, client) = make_server_and_client();\n    client.create_database(\"/baseball\").run().unwrap();\n\n    match client.read_document(\"/baseball/babe_ruth\").run() {\n        Err(chill::Error::NotFound(..)) => (),\n        x @ _ => unexpected_result!(x),\n    }\n}", "item_id": 7, "repo": "baajur/chill", "file": "tests/actions.rs", "last_update_at": "2022-03-10T13:16:21+00:00", "question_id": "dbfb6f95a5a3c09d2aa1f8d7c6669ef2bd25601e_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn read_document_nok_not_found() {\n    let (_server, client) = make_server_and_client();\n    client.create_database(\"/baseball\").run().unwrap();\n    match client.read_document(\"/baseball/babe_ruth\").run() {\n        Err(chill::Error::NotFound(..)) => (),\n        x @ _ => unexpected_result!(x),\n    }\n"]], "pred": {"ppl": 4.882136821746826, "ppl_lower": 5.993921279907227, "ppl/lowercase_ppl": -1.1293926831134817, "ppl/zlib": 0.007888472623558658, "Min_5.0% Prob": 8.498509788513184, "Min_10.0% Prob": 7.250740957260132, "Min_20.0% Prob": 5.708904039859772, "Min_30.0% Prob": 4.6135926127433775, "Min_40.0% Prob": 3.790947423875332, "Min_50.0% Prob": 3.1373779511451723, "Min_60.0% Prob": 2.649280082434416}}
{"hexsha": "c16d223f5de9cba222b18b557bfe0e78720b7d75", "ext": "rs", "lang": "Rust", "content": "fn variables_invalid() {\n    let input = include_str!(\"inline_data_fragment/fixtures/variables.invalid.graphql\");\n    let expected = include_str!(\"inline_data_fragment/fixtures/variables.invalid.expected\");\n    test_fixture(transform_fixture, \"variables.invalid.graphql\", \"inline_data_fragment/fixtures/variables.invalid.expected\", input, expected);\n}", "item_id": 1, "repo": "erictaylor/relay", "file": "compiler/crates/relay-transforms/tests/inline_data_fragment_test.rs", "last_update_at": "2022-03-31T10:17:36+00:00", "question_id": "c16d223f5de9cba222b18b557bfe0e78720b7d75_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn variables_invalid() {\n    let input = include_str!(\"inline_data_fragment/fixtures/variables.invalid.graphql\");\n    let expected = include_str!(\"inline_data_fragment/fixtures/variables.invalid.expected\");\n    test_fixture(transform_fixture, \"variables.invalid.graphql\", \"inline_data_fragment/fixtures/variables.invalid.expected\", input, expected);\n"]], "pred": {"ppl": 2.2527213096618652, "ppl_lower": 2.2527213096618652, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0053430194497129406, "Min_5.0% Prob": 9.32962760925293, "Min_10.0% Prob": 7.093086695671081, "Min_20.0% Prob": 4.000347571074963, "Min_30.0% Prob": 2.7031850968798, "Min_40.0% Prob": 2.0298567933263256, "Min_50.0% Prob": 1.6242173052026192, "Min_60.0% Prob": 1.3535464135083506}}
{"hexsha": "81d186e99e97da9364fdc65e09e7c264db315a8f", "ext": "rs", "lang": "Rust", "content": "fn build<'s>(nodes: BTreeMap<&'s str, MergeNode<'s>>, num_frames: i64) -> Vec<MergeScope<'s>> {\n    let mut scopes: Vec<_> = nodes\n        .into_values()\n        .map(|node| node.build(num_frames))\n        .collect();\n\n    // Earliest first:\n    scopes.sort_by_key(|scope| scope.relative_start_ns);\n\n    // Make sure sibling scopes do not overlap:\n    let mut relative_ns = 0;\n    for scope in &mut scopes {\n        scope.relative_start_ns = scope.relative_start_ns.max(relative_ns);\n        relative_ns = scope.relative_start_ns + scope.duration_per_frame_ns;\n    }\n\n    scopes\n}", "item_id": 0, "repo": "Nekrolm/puffin", "file": "puffin/src/merge.rs", "last_update_at": "2022-03-28T15:36:13+00:00", "question_id": "81d186e99e97da9364fdc65e09e7c264db315a8f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn build<'s>(nodes: BTreeMap<&'s str, MergeNode<'s>>, num_frames: i64) -> Vec<MergeScope<'s>> {\n    let mut scopes: Vec<_> = nodes\n        .into_values()\n        .map(|node| node.build(num_frames))\n        .collect();\n    // Earliest first:\n    scopes.sort_by_key(|scope| scope.relative_start_ns);\n    // Make sure sibling scopes do not overlap:\n    let mut relative_ns = 0;\n    for scope in &mut scopes {\n        scope.relative_start_ns = scope.relative_start_ns.max(relative_ns);\n        relative_ns = scope.relative_start_ns + scope.duration_per_frame_ns;\n    }\n    scopes\n"]], "pred": {"ppl": 2.7249770164489746, "ppl_lower": 3.1768274307250977, "ppl/lowercase_ppl": -1.1530465481999543, "ppl/zlib": 0.0033527090091939353, "Min_5.0% Prob": 8.602952480316162, "Min_10.0% Prob": 6.9887457370758055, "Min_20.0% Prob": 4.428453177213669, "Min_30.0% Prob": 3.2306051194667815, "Min_40.0% Prob": 2.4686704491391596, "Min_50.0% Prob": 2.0050547439420576, "Min_60.0% Prob": 1.679775364527648}}
{"hexsha": "f43e6b4f3934ec1c6e5c25d3d52f0d34c0a345df", "ext": "rs", "lang": "Rust", "content": "fn parse_import_named_clause(p: &mut Parser) -> ParsedSyntax<CompletedMarker> {\n\tif !p.at(T!['{']) {\n\t\treturn Absent;\n\t}\n\n\tlet m = p.start();\n\n\tparse_default_import_specifier(p).or_missing(p);\n\tparse_named_import(p).or_missing_with_error(p, expected_named_import);\n\texpect_keyword(p, \"from\", T![from]);\n\tparse_module_source(p).or_missing_with_error(p, expected_module_source);\n\tparse_import_assertion(p).or_missing(p);\n\n\tPresent(m.complete(p, JS_IMPORT_NAMED_CLAUSE))\n}", "item_id": 3, "repo": "10088/tools", "file": "crates/rslint_parser/src/syntax/module.rs", "last_update_at": "2022-03-31T20:38:14+00:00", "question_id": "f43e6b4f3934ec1c6e5c25d3d52f0d34c0a345df_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_import_named_clause(p: &mut Parser) -> ParsedSyntax<CompletedMarker> {\n\tif !p.at(T!['{']) {\n\t\treturn Absent;\n\t}\n\tlet m = p.start();\n\tparse_default_import_specifier(p).or_missing(p);\n\tparse_named_import(p).or_missing_with_error(p, expected_named_import);\n\texpect_keyword(p, \"from\", T![from]);\n\tparse_module_source(p).or_missing_with_error(p, expected_module_source);\n\tparse_import_assertion(p).or_missing(p);\n\tPresent(m.complete(p, JS_IMPORT_NAMED_CLAUSE))\n"]], "pred": {"ppl": 2.2215092182159424, "ppl_lower": 3.2548580169677734, "ppl/lowercase_ppl": -1.4785369354413809, "ppl/zlib": 0.0028304496203226713, "Min_5.0% Prob": 7.087323559655084, "Min_10.0% Prob": 5.419705190156636, "Min_20.0% Prob": 3.5364220440387726, "Min_30.0% Prob": 2.5420352037538563, "Min_40.0% Prob": 1.961048936569377, "Min_50.0% Prob": 1.588719125052816, "Min_60.0% Prob": 1.3285648204353557}}
{"hexsha": "d63a3a3c21dfd4cedc1a7a2cab8c57ac018fb7b3", "ext": "rs", "lang": "Rust", "content": "async fn single_singleton() {\n    use crate::{DependencyContext, DependencyLifeCycle};\n    use std::sync::Arc;\n    use tokio::sync::RwLock;\n\n    let root_context = DependencyContext::new_root();\n    root_context.register_type::<RwLock<SingletonDependency>>(DependencyLifeCycle::Singleton).await.unwrap();\n\n    let dependency = root_context.resolve::<Arc<RwLock<SingletonDependency>>>().await.unwrap();\n\n    assert_eq!(dependency.read().await.str, \"test\".to_string());\n\n    dependency.write().await.str = \"test2\".to_string(); // \u0438\u0437\u043c\u0435\u043d\u044f\u0435\u043c \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 singletone \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438\n\n    let dependency2 = root_context.resolve::<Arc<RwLock<SingletonDependency>>>().await.unwrap();\n\n    assert_eq!(dependency2.read().await.str, \"test2\".to_string()); // \u0432\u0438\u0434\u0438\u043c \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u043d\u043e\u0435 \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0432 \u043d\u043e\u0432\u043e\u043c \u043e\u0431\u044a\u0435\u043a\u0442\u0435\n}", "item_id": 0, "repo": "Vidrochka/anthill-di", "file": "src/tests/single_singleton.rs", "last_update_at": "2022-03-04T01:33:02+00:00", "question_id": "d63a3a3c21dfd4cedc1a7a2cab8c57ac018fb7b3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn single_singleton() {\n    use crate::{DependencyContext, DependencyLifeCycle};\n    use std::sync::Arc;\n    use tokio::sync::RwLock;\n    let root_context = DependencyContext::new_root();\n    root_context.register_type::<RwLock<SingletonDependency>>(DependencyLifeCycle::Singleton).await.unwrap();\n    let dependency = root_context.resolve::<Arc<RwLock<SingletonDependency>>>().await.unwrap();\n    assert_eq!(dependency.read().await.str, \"test\".to_string());\n    dependency.write().await.str = \"test2\".to_string(); // \u0438\u0437\u043c\u0435\u043d\u044f\u0435\u043c \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 singletone \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438\n    let dependency2 = root_context.resolve::<Arc<RwLock<SingletonDependency>>>().await.unwrap();\n    assert_eq!(dependency2.read().await.str, \"test2\".to_string()); // \u0432\u0438\u0434\u0438\u043c \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u043d\u043e\u0435 \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0432 \u043d\u043e\u0432\u043e\u043c \u043e\u0431\u044a\u0435\u043a\u0442\u0435\n"]], "pred": {"ppl": 2.280282497406006, "ppl_lower": 3.0541279315948486, "ppl/lowercase_ppl": -1.3544765169087158, "ppl/zlib": 0.0022707970734494208, "Min_5.0% Prob": 7.831966479619344, "Min_10.0% Prob": 5.490208530426026, "Min_20.0% Prob": 3.609007266222262, "Min_30.0% Prob": 2.6382970433486137, "Min_40.0% Prob": 2.0365803843619776, "Min_50.0% Prob": 1.6503855250482484, "Min_60.0% Prob": 1.372779963154565}}
{"hexsha": "69cb13c991faa98f161e44d0088980ebb6f80b61", "ext": "rs", "lang": "Rust", "content": "fn do_something(data: &[u8], s: &mut StateTracker) {\n    //Do something. Like writing it to a file or to stdout...\n    std::io::stdout().write_all(data).unwrap();\n    s.bytes_used += data.len() as u64;\n}", "item_id": 1, "repo": "MinusKelvin/zstd-rs", "file": "src/bin/zstd.rs", "last_update_at": "2022-03-29T19:03:53+00:00", "question_id": "69cb13c991faa98f161e44d0088980ebb6f80b61_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn do_something(data: &[u8], s: &mut StateTracker) {\n    //Do something. Like writing it to a file or to stdout...\n    std::io::stdout().write_all(data).unwrap();\n    s.bytes_used += data.len() as u64;\n"]], "pred": {"ppl": 4.538145542144775, "ppl_lower": 5.19783353805542, "ppl/lowercase_ppl": -1.0897334198282906, "ppl/zlib": 0.009336533689586885, "Min_5.0% Prob": 8.744713147481283, "Min_10.0% Prob": 7.273525101797921, "Min_20.0% Prob": 5.707860350608826, "Min_30.0% Prob": 4.533463875452678, "Min_40.0% Prob": 3.6398722465549196, "Min_50.0% Prob": 2.930197950038645, "Min_60.0% Prob": 2.4913499116204507}}
{"hexsha": "cbce4a9da80294ed41bcf44d246e24c09d0b59de", "ext": "rs", "lang": "Rust", "content": "pub async fn load_home(client: &Client) -> Result<(Vec<Video>, Vec<Video>), reqwest::Error> {\n    let trending_fut = invidious_videos(vec![], client, TRENDING_URL);\n    let popular_fut = invidious_videos(vec![], client, POPULAR_URL);\n    //let top_fut = home_videos(client, TOP_URL);\n\n    futures::try_join!(trending_fut, popular_fut)//, top_fut)\n}", "item_id": 0, "repo": "dfangx/invidious-tui", "file": "src/invidious.rs", "last_update_at": "2022-02-01T12:39:17+00:00", "question_id": "cbce4a9da80294ed41bcf44d246e24c09d0b59de_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn load_home(client: &Client) -> Result<(Vec<Video>, Vec<Video>), reqwest::Error> {\n    let trending_fut = invidious_videos(vec![], client, TRENDING_URL);\n    let popular_fut = invidious_videos(vec![], client, POPULAR_URL);\n    //let top_fut = home_videos(client, TOP_URL);\n    futures::try_join!(trending_fut, popular_fut)//, top_fut)\n"]], "pred": {"ppl": 3.2245843410491943, "ppl_lower": 4.457598686218262, "ppl/lowercase_ppl": -1.2765673324448938, "ppl/zlib": 0.005395410393754764, "Min_5.0% Prob": 9.468257427215576, "Min_10.0% Prob": 7.251673221588135, "Min_20.0% Prob": 5.021361050782381, "Min_30.0% Prob": 3.7240492552518845, "Min_40.0% Prob": 2.8955751100072153, "Min_50.0% Prob": 2.3308977233793806, "Min_60.0% Prob": 1.9634749661027282}}
{"hexsha": "42d03f5a24edfe8dd99160f7ef0e293d55dcc02a", "ext": "rs", "lang": "Rust", "content": "pub async fn list<C>(client: &Client<C>) -> Result<Vec<Zone>, Error>\nwhere\n    C: Connect + Clone + Debug + Send + Sync + 'static,\n{\n    let path = format!(\"{}/v4/products/zones\", client.endpoint);\n\n    #[cfg(feature = \"logging\")]\n    if log_enabled!(Level::Debug) {\n        debug!(\"execute a request to list zones, path: '{}'\", &path);\n    }\n\n    client.get(&path).await.map_err(Error::List)\n}", "item_id": 0, "repo": "CleverCloud/clevercloud-sdk-rust", "file": "src/v4/products/zones.rs", "last_update_at": "2022-02-05T17:37:37+00:00", "question_id": "42d03f5a24edfe8dd99160f7ef0e293d55dcc02a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn list<C>(client: &Client<C>) -> Result<Vec<Zone>, Error>\nwhere\n    C: Connect + Clone + Debug + Send + Sync + 'static,\n{\n    let path = format!(\"{}/v4/products/zones\", client.endpoint);\n    #[cfg(feature = \"logging\")]\n    if log_enabled!(Level::Debug) {\n        debug!(\"execute a request to list zones, path: '{}'\", &path);\n    }\n    client.get(&path).await.map_err(Error::List)\n"]], "pred": {"ppl": 3.3346781730651855, "ppl_lower": 4.5306196212768555, "ppl/lowercase_ppl": -1.2544740948812902, "ppl/zlib": 0.004270837499576773, "Min_5.0% Prob": 8.363830010096232, "Min_10.0% Prob": 6.187906173559336, "Min_20.0% Prob": 4.6357395098759575, "Min_30.0% Prob": 3.5741523087024687, "Min_40.0% Prob": 2.896608755273639, "Min_50.0% Prob": 2.376078930363726, "Min_60.0% Prob": 2.0101543779019266}}
{"hexsha": "c6faf0bdd224fd7459877121d9036d9de4becc0b", "ext": "rs", "lang": "Rust", "content": "fn parse_function_native_method() -> anyhow::Result<()> {\n        let class = load_code(\"public native void log(int x);\")?;\n        assert_eq!(class.methods.len(), 1 /* <init> */ + 1);\n        assert_eq!(*class.methods[0].id.name, \"<init>\");\n\n        // Check method signature\n        let method = &class.methods[1];\n        assert_eq!(format!(\"{}\", method.id), \"Test.log(I)V\");\n        assert_eq!(format!(\"{}\", method.descriptor), \"(I)V\");\n        assert_eq!(\n            method.flags,\n            MethodAccessFlags::PUBLIC | MethodAccessFlags::NATIVE\n        );\n\n        // Check no Java implementation as native\n        assert_eq!(*method.code.lock().unwrap(), None);\n\n        Ok(())\n    }", "item_id": 10, "repo": "mrbbot/montera", "file": "src/class/parser.rs", "last_update_at": "2022-03-31T22:45:13+00:00", "question_id": "c6faf0bdd224fd7459877121d9036d9de4becc0b_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_function_native_method() -> anyhow::Result<()> {\n        let class = load_code(\"public native void log(int x);\")?;\n        assert_eq!(class.methods.len(), 1 /* <init> */ + 1);\n        assert_eq!(*class.methods[0].id.name, \"<init>\");\n        // Check method signature\n        let method = &class.methods[1];\n        assert_eq!(format!(\"{}\", method.id), \"Test.log(I)V\");\n        assert_eq!(format!(\"{}\", method.descriptor), \"(I)V\");\n        assert_eq!(\n            method.flags,\n            MethodAccessFlags::PUBLIC | MethodAccessFlags::NATIVE\n        );\n        // Check no Java implementation as native\n        assert_eq!(*method.code.lock().unwrap(), None);\n        Ok(())\n"]], "pred": {"ppl": 3.088951349258423, "ppl_lower": 4.313726902008057, "ppl/lowercase_ppl": -1.2961173971186466, "ppl/zlib": 0.0032785804190083524, "Min_5.0% Prob": 8.26519513130188, "Min_10.0% Prob": 6.74777855191912, "Min_20.0% Prob": 4.65336533387502, "Min_30.0% Prob": 3.4648493897347223, "Min_40.0% Prob": 2.7417865778718675, "Min_50.0% Prob": 2.2252262032256938, "Min_60.0% Prob": 1.8757694964333782}}
{"hexsha": "8d58f045f65e095a023d1fcdcb3ebdfbf4eea32d", "ext": "rs", "lang": "Rust", "content": "pub fn serialize_structure_crate_model_webhook_definition(\n    object: &mut aws_smithy_json::serialize::JsonObjectWriter,\n    input: &crate::model::WebhookDefinition,\n) -> Result<(), aws_smithy_http::operation::SerializationError> {\n    if let Some(var_189) = &input.name {\n        object.key(\"name\").string(var_189);\n    }\n    if let Some(var_190) = &input.target_pipeline {\n        object.key(\"targetPipeline\").string(var_190);\n    }\n    if let Some(var_191) = &input.target_action {\n        object.key(\"targetAction\").string(var_191);\n    }\n    if let Some(var_192) = &input.filters {\n        let mut array_193 = object.key(\"filters\").start_array();\n        for item_194 in var_192 {\n            {\n                let mut object_195 = array_193.value().start_object();\n                crate::json_ser::serialize_structure_crate_model_webhook_filter_rule(\n                    &mut object_195,\n                    item_194,\n                )?;\n                object_195.finish();\n            }\n        }\n        array_193.finish();\n    }\n    if let Some(var_196) = &input.authentication {\n        object.key(\"authentication\").string(var_196.as_str());\n    }\n    if let Some(var_197) = &input.authentication_configuration {\n        let mut object_198 = object.key(\"authenticationConfiguration\").start_object();\n        crate::json_ser::serialize_structure_crate_model_webhook_auth_configuration(\n            &mut object_198,\n            var_197,\n        )?;\n        object_198.finish();\n    }\n    Ok(())\n}", "item_id": 42, "repo": "jdisanti/aws-sdk-rust", "file": "sdk/codepipeline/src/json_ser.rs", "last_update_at": "2022-03-31T20:47:15+00:00", "question_id": "8d58f045f65e095a023d1fcdcb3ebdfbf4eea32d_42", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn serialize_structure_crate_model_webhook_definition(\n    object: &mut aws_smithy_json::serialize::JsonObjectWriter,\n    input: &crate::model::WebhookDefinition,\n) -> Result<(), aws_smithy_http::operation::SerializationError> {\n    if let Some(var_189) = &input.name {\n        object.key(\"name\").string(var_189);\n    }\n    if let Some(var_190) = &input.target_pipeline {\n        object.key(\"targetPipeline\").string(var_190);\n    }\n    if let Some(var_191) = &input.target_action {\n        object.key(\"targetAction\").string(var_191);\n    }\n    if let Some(var_192) = &input.filters {\n        let mut array_193 = object.key(\"filters\").start_array();\n        for item_194 in var_192 {\n            {\n                let mut object_195 = array_193.value().start_object();\n                crate::json_ser::serialize_structure_crate_model_webhook_filter_rule(\n                    &mut object_195,\n                    item_194,\n                )?;\n                object_195.finish();\n            }\n        }\n        array_193.finish();\n    }\n    if let Some(var_196) = &input.authentication {\n        object.key(\"authentication\").string(var_196.as_str());\n    }\n    if let Some(var_197) = &input.authentication_configuration {\n        let mut object_198 = object.key(\"authenticationConfiguration\").start_object();\n        crate::json_ser::serialize_structure_crate_model_webhook_auth_configuration(\n            &mut object_198,\n            var_197,\n        )?;\n        object_198.finish();\n    }\n    Ok(())\n"]], "pred": {"ppl": 1.697640299797058, "ppl_lower": 1.9104403257369995, "ppl/lowercase_ppl": -1.2231401574777165, "ppl/zlib": 0.0010867335274600792, "Min_5.0% Prob": 6.49934949874878, "Min_10.0% Prob": 4.623611941337585, "Min_20.0% Prob": 2.6021891854703427, "Min_30.0% Prob": 1.7658427291860184, "Min_40.0% Prob": 1.3225027368640276, "Min_50.0% Prob": 1.0601220282408745, "Min_60.0% Prob": 0.8842895198814521}}
{"hexsha": "b6b401423a70f0bbafd364b550f89737fbc86a43", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn open_impl(\n    start: &fs::File,\n    path: &Path,\n    options: &OpenOptions,\n) -> io::Result<fs::File> {\n    // Windows reserves several special device paths. Disallow opening any\n    // of them.\n    if let Some(stem) = path.file_stem() {\n        if let Some(stemstr) = stem.to_str() {\n            match stemstr.to_uppercase().as_str() {\n                \"CON\" | \"PRN\" | \"AUX\" | \"NUL\" | \"COM0\" | \"COM1\" | \"COM2\" | \"COM3\" | \"COM4\"\n                | \"COM5\" | \"COM6\" | \"COM7\" | \"COM8\" | \"COM9\" | \"LPT0\" | \"LPT1\" | \"LPT2\"\n                | \"LPT3\" | \"LPT4\" | \"LPT5\" | \"LPT6\" | \"LPT7\" | \"LPT8\" | \"LPT9\" => {\n                    return Err(io::Error::from_raw_os_error(ERROR_FILE_NOT_FOUND as i32));\n                }\n                _ => {}\n            }\n        }\n    }\n\n    manually::open(start, path, options)\n}", "item_id": 0, "repo": "sunshowers/cap-std", "file": "cap-primitives/src/windows/fs/open_impl.rs", "last_update_at": "2022-03-03T11:20:24+00:00", "question_id": "b6b401423a70f0bbafd364b550f89737fbc86a43_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn open_impl(\n    start: &fs::File,\n    path: &Path,\n    options: &OpenOptions,\n) -> io::Result<fs::File> {\n    // Windows reserves several special device paths. Disallow opening any\n    // of them.\n    if let Some(stem) = path.file_stem() {\n        if let Some(stemstr) = stem.to_str() {\n            match stemstr.to_uppercase().as_str() {\n                \"CON\" | \"PRN\" | \"AUX\" | \"NUL\" | \"COM0\" | \"COM1\" | \"COM2\" | \"COM3\" | \"COM4\"\n                | \"COM5\" | \"COM6\" | \"COM7\" | \"COM8\" | \"COM9\" | \"LPT0\" | \"LPT1\" | \"LPT2\"\n                | \"LPT3\" | \"LPT4\" | \"LPT5\" | \"LPT6\" | \"LPT7\" | \"LPT8\" | \"LPT9\" => {\n                    return Err(io::Error::from_raw_os_error(ERROR_FILE_NOT_FOUND as i32));\n                }\n                _ => {}\n            }\n        }\n    }\n    manually::open(start, path, options)\n"]], "pred": {"ppl": 1.7193915843963623, "ppl_lower": 2.1379737854003906, "ppl/lowercase_ppl": -1.4020293608503849, "ppl/zlib": 0.0013349027050394882, "Min_5.0% Prob": 7.064197317759196, "Min_10.0% Prob": 4.64772480533969, "Min_20.0% Prob": 2.658734810730768, "Min_30.0% Prob": 1.8058489075616786, "Min_40.0% Prob": 1.355972243527933, "Min_50.0% Prob": 1.083704671629927, "Min_60.0% Prob": 0.907022635309381}}
{"hexsha": "a41e7912c8c8749475376f5140e743c9fc01b9e8", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout_FriendsGetFollowerCount_t() {\n\tassert_eq!(\n\t\t::std::mem::size_of::<FriendsGetFollowerCount_t>(),\n\t\t16usize,\n\t\tconcat!(\"Size of: \", stringify!(FriendsGetFollowerCount_t))\n\t);\n\tassert_eq!(\n\t\t::std::mem::align_of::<FriendsGetFollowerCount_t>(),\n\t\t4usize,\n\t\tconcat!(\"Alignment of \", stringify!(FriendsGetFollowerCount_t))\n\t);\n\tassert_eq!(\n\t\tunsafe {\n\t\t\t&(*(::std::ptr::null::<FriendsGetFollowerCount_t>())).m_eResult as *const _ as usize\n\t\t},\n\t\t0usize,\n\t\tconcat!(\n\t\t\t\"Offset of field: \",\n\t\t\tstringify!(FriendsGetFollowerCount_t),\n\t\t\t\"::\",\n\t\t\tstringify!(m_eResult)\n\t\t)\n\t);\n\tassert_eq!(\n\t\tunsafe {\n\t\t\t&(*(::std::ptr::null::<FriendsGetFollowerCount_t>())).m_steamID as *const _ as usize\n\t\t},\n\t\t4usize,\n\t\tconcat!(\n\t\t\t\"Offset of field: \",\n\t\t\tstringify!(FriendsGetFollowerCount_t),\n\t\t\t\"::\",\n\t\t\tstringify!(m_steamID)\n\t\t)\n\t);\n\tassert_eq!(\n\t\tunsafe {\n\t\t\t&(*(::std::ptr::null::<FriendsGetFollowerCount_t>())).m_nCount as *const _ as usize\n\t\t},\n\t\t12usize,\n\t\tconcat!(\n\t\t\t\"Offset of field: \",\n\t\t\tstringify!(FriendsGetFollowerCount_t),\n\t\t\t\"::\",\n\t\t\tstringify!(m_nCount)\n\t\t)\n\t);\n}", "item_id": 40, "repo": "JoshPiper/gmsv_workshop", "file": "steamworks-rs/steamworks-sys/src/bindings_win64.rs", "last_update_at": "2022-03-22T10:51:55+00:00", "question_id": "a41e7912c8c8749475376f5140e743c9fc01b9e8_40", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bindgen_test_layout_FriendsGetFollowerCount_t() {\n\tassert_eq!(\n\t\t::std::mem::size_of::<FriendsGetFollowerCount_t>(),\n\t\t16usize,\n\t\tconcat!(\"Size of: \", stringify!(FriendsGetFollowerCount_t))\n\t);\n\tassert_eq!(\n\t\t::std::mem::align_of::<FriendsGetFollowerCount_t>(),\n\t\t4usize,\n\t\tconcat!(\"Alignment of \", stringify!(FriendsGetFollowerCount_t))\n\t);\n\tassert_eq!(\n\t\tunsafe {\n\t\t\t&(*(::std::ptr::null::<FriendsGetFollowerCount_t>())).m_eResult as *const _ as usize\n\t\t},\n\t\t0usize,\n\t\tconcat!(\n\t\t\t\"Offset of field: \",\n\t\t\tstringify!(FriendsGetFollowerCount_t),\n\t\t\t\"::\",\n\t\t\tstringify!(m_eResult)\n\t\t)\n\t);\n\tassert_eq!(\n\t\tunsafe {\n\t\t\t&(*(::std::ptr::null::<FriendsGetFollowerCount_t>())).m_steamID as *const _ as usize\n\t\t},\n\t\t4usize,\n\t\tconcat!(\n\t\t\t\"Offset of field: \",\n\t\t\tstringify!(FriendsGetFollowerCount_t),\n\t\t\t\"::\",\n\t\t\tstringify!(m_steamID)\n\t\t)\n\t);\n\tassert_eq!(\n\t\tunsafe {\n\t\t\t&(*(::std::ptr::null::<FriendsGetFollowerCount_t>())).m_nCount as *const _ as usize\n\t\t},\n\t\t12usize,\n\t\tconcat!(\n\t\t\t\"Offset of field: \",\n\t\t\tstringify!(FriendsGetFollowerCount_t),\n\t\t\t\"::\",\n\t\t\tstringify!(m_nCount)\n\t\t)\n\t);\n"]], "pred": {"ppl": 1.2148463726043701, "ppl_lower": 1.3370234966278076, "ppl/lowercase_ppl": -1.4923924278344105, "ppl/zlib": 0.0006876947932759018, "Min_5.0% Prob": 3.784313308695952, "Min_10.0% Prob": 1.971551312627841, "Min_20.0% Prob": 0.9808381232356587, "Min_30.0% Prob": 0.6517619710260707, "Min_40.0% Prob": 0.4880083810284117, "Min_50.0% Prob": 0.3900161320003192, "Min_60.0% Prob": 0.3247964441219578}}
{"hexsha": "9cdfdc3dae4dc5096084630cd33cfe44e2e66635", "ext": "rs", "lang": "Rust", "content": "pub fn serialize_operation_crate_operation_modify_replication_group(\n    input: &crate::input::ModifyReplicationGroupInput,\n) -> Result<aws_smithy_http::body::SdkBody, aws_smithy_http::operation::SerializationError> {\n    let mut out = String::new();\n    #[allow(unused_mut)]\n    let mut writer =\n        aws_smithy_query::QueryWriter::new(&mut out, \"ModifyReplicationGroup\", \"2015-02-02\");\n    #[allow(unused_mut)]\n    let mut scope_667 = writer.prefix(\"ReplicationGroupId\");\n    if let Some(var_668) = &input.replication_group_id {\n        scope_667.string(var_668);\n    }\n    #[allow(unused_mut)]\n    let mut scope_669 = writer.prefix(\"ReplicationGroupDescription\");\n    if let Some(var_670) = &input.replication_group_description {\n        scope_669.string(var_670);\n    }\n    #[allow(unused_mut)]\n    let mut scope_671 = writer.prefix(\"PrimaryClusterId\");\n    if let Some(var_672) = &input.primary_cluster_id {\n        scope_671.string(var_672);\n    }\n    #[allow(unused_mut)]\n    let mut scope_673 = writer.prefix(\"SnapshottingClusterId\");\n    if let Some(var_674) = &input.snapshotting_cluster_id {\n        scope_673.string(var_674);\n    }\n    #[allow(unused_mut)]\n    let mut scope_675 = writer.prefix(\"AutomaticFailoverEnabled\");\n    if let Some(var_676) = &input.automatic_failover_enabled {\n        scope_675.boolean(*var_676);\n    }\n    #[allow(unused_mut)]\n    let mut scope_677 = writer.prefix(\"MultiAZEnabled\");\n    if let Some(var_678) = &input.multi_az_enabled {\n        scope_677.boolean(*var_678);\n    }\n    #[allow(unused_mut)]\n    let mut scope_679 = writer.prefix(\"NodeGroupId\");\n    if let Some(var_680) = &input.node_group_id {\n        scope_679.string(var_680);\n    }\n    #[allow(unused_mut)]\n    let mut scope_681 = writer.prefix(\"CacheSecurityGroupNames\");\n    if let Some(var_682) = &input.cache_security_group_names {\n        let mut list_684 = scope_681.start_list(false, Some(\"CacheSecurityGroupName\"));\n        for item_683 in var_682 {\n            #[allow(unused_mut)]\n            let mut entry_685 = list_684.entry();\n            entry_685.string(item_683);\n        }\n        list_684.finish();\n    }\n    #[allow(unused_mut)]\n    let mut scope_686 = writer.prefix(\"SecurityGroupIds\");\n    if let Some(var_687) = &input.security_group_ids {\n        let mut list_689 = scope_686.start_list(false, Some(\"SecurityGroupId\"));\n        for item_688 in var_687 {\n            #[allow(unused_mut)]\n            let mut entry_690 = list_689.entry();\n            entry_690.string(item_688);\n        }\n        list_689.finish();\n    }\n    #[allow(unused_mut)]\n    let mut scope_691 = writer.prefix(\"PreferredMaintenanceWindow\");\n    if let Some(var_692) = &input.preferred_maintenance_window {\n        scope_691.string(var_692);\n    }\n    #[allow(unused_mut)]\n    let mut scope_693 = writer.prefix(\"NotificationTopicArn\");\n    if let Some(var_694) = &input.notification_topic_arn {\n        scope_693.string(var_694);\n    }\n    #[allow(unused_mut)]\n    let mut scope_695 = writer.prefix(\"CacheParameterGroupName\");\n    if let Some(var_696) = &input.cache_parameter_group_name {\n        scope_695.string(var_696);\n    }\n    #[allow(unused_mut)]\n    let mut scope_697 = writer.prefix(\"NotificationTopicStatus\");\n    if let Some(var_698) = &input.notification_topic_status {\n        scope_697.string(var_698);\n    }\n    #[allow(unused_mut)]\n    let mut scope_699 = writer.prefix(\"ApplyImmediately\");\n    if input.apply_immediately {\n        scope_699.boolean(input.apply_immediately);\n    }\n    #[allow(unused_mut)]\n    let mut scope_700 = writer.prefix(\"EngineVersion\");\n    if let Some(var_701) = &input.engine_version {\n        scope_700.string(var_701);\n    }\n    #[allow(unused_mut)]\n    let mut scope_702 = writer.prefix(\"AutoMinorVersionUpgrade\");\n    if let Some(var_703) = &input.auto_minor_version_upgrade {\n        scope_702.boolean(*var_703);\n    }\n    #[allow(unused_mut)]\n    let mut scope_704 = writer.prefix(\"SnapshotRetentionLimit\");\n    if let Some(var_705) = &input.snapshot_retention_limit {\n        scope_704.number(\n            #[allow(clippy::useless_conversion)]\n            aws_smithy_types::Number::NegInt((*var_705).into()),\n        );\n    }\n    #[allow(unused_mut)]\n    let mut scope_706 = writer.prefix(\"SnapshotWindow\");\n    if let Some(var_707) = &input.snapshot_window {\n        scope_706.string(var_707);\n    }\n    #[allow(unused_mut)]\n    let mut scope_708 = writer.prefix(\"CacheNodeType\");\n    if let Some(var_709) = &input.cache_node_type {\n        scope_708.string(var_709);\n    }\n    #[allow(unused_mut)]\n    let mut scope_710 = writer.prefix(\"AuthToken\");\n    if let Some(var_711) = &input.auth_token {\n        scope_710.string(var_711);\n    }\n    #[allow(unused_mut)]\n    let mut scope_712 = writer.prefix(\"AuthTokenUpdateStrategy\");\n    if let Some(var_713) = &input.auth_token_update_strategy {\n        scope_712.string(var_713.as_str());\n    }\n    #[allow(unused_mut)]\n    let mut scope_714 = writer.prefix(\"UserGroupIdsToAdd\");\n    if let Some(var_715) = &input.user_group_ids_to_add {\n        let mut list_717 = scope_714.start_list(false, None);\n        for item_716 in var_715 {\n            #[allow(unused_mut)]\n            let mut entry_718 = list_717.entry();\n            entry_718.string(item_716);\n        }\n        list_717.finish();\n    }\n    #[allow(unused_mut)]\n    let mut scope_719 = writer.prefix(\"UserGroupIdsToRemove\");\n    if let Some(var_720) = &input.user_group_ids_to_remove {\n        let mut list_722 = scope_719.start_list(false, None);\n        for item_721 in var_720 {\n            #[allow(unused_mut)]\n            let mut entry_723 = list_722.entry();\n            entry_723.string(item_721);\n        }\n        list_722.finish();\n    }\n    #[allow(unused_mut)]\n    let mut scope_724 = writer.prefix(\"RemoveUserGroups\");\n    if let Some(var_725) = &input.remove_user_groups {\n        scope_724.boolean(*var_725);\n    }\n    #[allow(unused_mut)]\n    let mut scope_726 = writer.prefix(\"LogDeliveryConfigurations\");\n    if let Some(var_727) = &input.log_delivery_configurations {\n        let mut list_729 = scope_726.start_list(false, Some(\"LogDeliveryConfigurationRequest\"));\n        for item_728 in var_727 {\n            #[allow(unused_mut)]\n            let mut entry_730 = list_729.entry();\n            crate::query_ser::serialize_structure_crate_model_log_delivery_configuration_request(\n                entry_730, item_728,\n            )?;\n        }\n        list_729.finish();\n    }\n    writer.finish();\n    Ok(aws_smithy_http::body::SdkBody::from(out))\n}", "item_id": 53, "repo": "a-xp/aws-sdk-rust", "file": "sdk/elasticache/src/operation_ser.rs", "last_update_at": "2022-03-02T02:19:58+00:00", "question_id": "9cdfdc3dae4dc5096084630cd33cfe44e2e66635_53", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn serialize_operation_crate_operation_modify_replication_group(\n    input: &crate::input::ModifyReplicationGroupInput,\n) -> Result<aws_smithy_http::body::SdkBody, aws_smithy_http::operation::SerializationError> {\n    let mut out = String::new();\n    #[allow(unused_mut)]\n    let mut writer =\n        aws_smithy_query::QueryWriter::new(&mut out, \"ModifyReplicationGroup\", \"2015-02-02\");\n    #[allow(unused_mut)]\n    let mut scope_667 = writer.prefix(\"ReplicationGroupId\");\n    if let Some(var_668) = &input.replication_group_id {\n        scope_667.string(var_668);\n    }\n    #[allow(unused_mut)]\n    let mut scope_669 = writer.prefix(\"ReplicationGroupDescription\");\n    if let Some(var_670) = &input.replication_group_description {\n        scope_669.string(var_670);\n    }\n    #[allow(unused_mut)]\n    let mut scope_671 = writer.prefix(\"PrimaryClusterId\");\n    if let Some(var_672) = &input.primary_cluster_id {\n        scope_671.string(var_672);\n    }\n    #[allow(unused_mut)]\n    let mut scope_673 = writer.prefix(\"SnapshottingClusterId\");\n    if let Some(var_674) = &input.snapshotting_cluster_id {\n        scope_673.string(var_674);\n    }\n    #[allow(unused_mut)]\n    let mut scope_675 = writer.prefix(\"AutomaticFailoverEnabled\");\n    if let Some(var_676) = &input.automatic_failover_enabled {\n        scope_675.boolean(*var_676);\n    }\n    #[allow(unused_mut)]\n    let mut scope_677 = writer.prefix(\"MultiAZEnabled\");\n    if let Some(var_678) = &input.multi_az_enabled {\n        scope_677.boolean(*var_678);\n    }\n    #[allow(unused_mut)]\n    let mut scope_679 = writer.prefix(\"NodeGroupId\");\n    if let Some(var_680) = &input.node_group_id {\n        scope_679.string(var_680);\n    }\n    #[allow(unused_mut)]\n    let mut scope_681 = writer.prefix(\"CacheSecurityGroupNames\");\n    if let Some(var_682) = &input.cache_security_group_names {\n        let mut list_684 = scope_681.start_list(false, Some(\"CacheSecurityGroupName\"));\n        for item_683 in var_682 {\n            #[allow(unused_mut)]\n            let mut entry_685 = list_684.entry();\n            entry_685.string(item_683);\n        }\n        list_684.finish();\n    }\n    #[allow(unused_mut)]\n    let mut scope_686 = writer.prefix(\"SecurityGroupIds\");\n    if let Some(var_687) = &input.security_group_ids {\n        let mut list_689 = scope_686.start_list(false, Some(\"SecurityGroupId\"));\n        for item_688 in var_687 {\n            #[allow(unused_mut)]\n            let mut entry_690 = list_689.entry();\n            entry_690.string(item_688);\n        }\n        list_689.finish();\n    }\n    #[allow(unused_mut)]\n    let mut scope_691 = writer.prefix(\"PreferredMaintenanceWindow\");\n    if let Some(var_692) = &input.preferred_maintenance_window {\n        scope_691.string(var_692);\n    }\n    #[allow(unused_mut)]\n    let mut scope_693 = writer.prefix(\"NotificationTopicArn\");\n    if let Some(var_694) = &input.notification_topic_arn {\n        scope_693.string(var_694);\n    }\n    #[allow(unused_mut)]\n    let mut scope_695 = writer.prefix(\"CacheParameterGroupName\");\n    if let Some(var_696) = &input.cache_parameter_group_name {\n        scope_695.string(var_696);\n    }\n    #[allow(unused_mut)]\n    let mut scope_697 = writer.prefix(\"NotificationTopicStatus\");\n    if let Some(var_698) = &input.notification_topic_status {\n        scope_697.string(var_698);\n    }\n    #[allow(unused_mut)]\n    let mut scope_699 = writer.prefix(\"ApplyImmediately\");\n    if input.apply_immediately {\n        scope_699.boolean(input.apply_immediately);\n    }\n    #[allow(unused_mut)]\n    let mut scope_700 = writer.prefix(\"EngineVersion\");\n    if let Some(var_701) = &input.engine_version {\n        scope_700.string(var_701);\n    }\n    #[allow(unused_mut)]\n    let mut scope_702 = writer.prefix(\"AutoMinorVersionUpgrade\");\n    if let Some(var_703) = &input.auto_minor_version_upgrade {\n        scope_702.boolean(*var_703);\n    }\n    #[allow(unused_mut)]\n    let mut scope_704 = writer.prefix(\"SnapshotRetentionLimit\");\n    if let Some(var_705) = &input.snapshot_retention_limit {\n        scope_704.number(\n            #[allow(clippy::useless_conversion)]\n            aws_smithy_types::Number::NegInt((*var_705).into()),\n        );\n    }\n    #[allow(unused_mut)]\n    let mut scope_706 = writer.prefix(\"SnapshotWindow\");\n    if let Some(var_707) = &input.snapshot_window {\n        scope_706.string(var_707);\n    }\n    #[allow(unused_mut)]\n    let mut scope_708 = writer.prefix(\"CacheNodeType\");\n    if let Some(var_709) = &input.cache_node_type {\n        scope_708.string(var_709);\n    }\n    #[allow(unused_mut)]\n    let mut scope_710 = writer.prefix(\"AuthToken\");\n    if let Some(var_711) = &input.auth_token {\n        scope_710.string(var_711);\n    }\n    #[allow(unused_mut)]\n    let mut scope_712 = writer.prefix(\"AuthTokenUpdateStrategy\");\n    if let Some(var_713) = &input.auth_token_update_strategy {\n        scope_712.string(var_713.as_str());\n    }\n    #[allow(unused_mut)]\n    let mut scope_714 = writer.prefix(\"UserGroupIdsToAdd\");\n    if let Some(var_715) = &input.user_group_ids_to_add {\n        let mut list_717 = scope_714.start_list(false, None);\n        for item_716 in var_715 {\n            #[allow(unused_mut)]\n            let mut entry_718 = list_717.entry();\n            entry_718.string(item_716);\n        }\n        list_717.finish();\n    }\n    #[allow(unused_mut)]\n    let mut scope_719 = writer.prefix(\"UserGroupIdsToRemove\");\n    if let Some(var_720) = &input.user_group_ids_to_remove {\n        let mut list_722 = scope_719.start_list(false, None);\n        for item_721 in var_720 {\n            #[allow(unused_mut)]\n            let mut entry_723 = list_722.entry();\n            entry_723.string(item_721);\n        }\n        list_722.finish();\n    }\n    #[allow(unused_mut)]\n    let mut scope_724 = writer.prefix(\"RemoveUserGroups\");\n    if let Some(var_725) = &input.remove_user_groups {\n        scope_724.boolean(*var_725);\n    }\n    #[allow(unused_mut)]\n    let mut scope_726 = writer.prefix(\"LogDeliveryConfigurations\");\n    if let Some(var_727) = &input.log_delivery_configurations {\n        let mut list_729 = scope_726.start_list(false, Some(\"LogDeliveryConfigurationRequest\"));\n        for item_728 in var_727 {\n            #[allow(unused_mut)]\n            let mut entry_730 = list_729.entry();\n            crate::query_ser::serialize_structure_crate_model_log_delivery_configuration_request(\n                entry_730, item_728,\n            )?;\n        }\n        list_729.finish();\n    }\n    writer.finish();\n    Ok(aws_smithy_http::body::SdkBody::from(out))\n"]], "pred": {"ppl": 1.356734037399292, "ppl_lower": 1.472350835800171, "ppl/lowercase_ppl": -1.2680603909706956, "ppl/zlib": 0.00020881613180705194, "Min_5.0% Prob": 5.163316016103707, "Min_10.0% Prob": 2.9678016708177677, "Min_20.0% Prob": 1.5249883631134735, "Min_30.0% Prob": 1.0191112393619846, "Min_40.0% Prob": 0.7628513102574516, "Min_50.0% Prob": 0.610696343930029, "Min_60.0% Prob": 0.5091154081144443}}
{"hexsha": "4142b600f42a69de56f5807db7b1b36af0bb13c2", "ext": "rs", "lang": "Rust", "content": "pub fn dominance_order<S>(a: &S, b: &S, objectives: &[Arc<dyn Objective<Solution = S> + Send + Sync>]) -> Ordering {\n    let mut less_cnt = 0;\n    let mut greater_cnt = 0;\n\n    for objective in objectives.iter() {\n        match objective.total_order(a, b) {\n            Ordering::Less => {\n                less_cnt += 1;\n            }\n            Ordering::Greater => {\n                greater_cnt += 1;\n            }\n            Ordering::Equal => {}\n        }\n    }\n\n    if less_cnt > 0 && greater_cnt == 0 {\n        Ordering::Less\n    } else if greater_cnt > 0 && less_cnt == 0 {\n        Ordering::Greater\n    } else {\n        debug_assert!((less_cnt > 0 && greater_cnt > 0) || (less_cnt == 0 && greater_cnt == 0));\n        Ordering::Equal\n    }\n}", "item_id": 2, "repo": "iedmrc/vrp", "file": "vrp-core/src/algorithms/nsga2/objective.rs", "last_update_at": "2022-03-22T17:43:15+00:00", "question_id": "4142b600f42a69de56f5807db7b1b36af0bb13c2_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn dominance_order<S>(a: &S, b: &S, objectives: &[Arc<dyn Objective<Solution = S> + Send + Sync>]) -> Ordering {\n    let mut less_cnt = 0;\n    let mut greater_cnt = 0;\n    for objective in objectives.iter() {\n        match objective.total_order(a, b) {\n            Ordering::Less => {\n                less_cnt += 1;\n            }\n            Ordering::Greater => {\n                greater_cnt += 1;\n            }\n            Ordering::Equal => {}\n        }\n    }\n    if less_cnt > 0 && greater_cnt == 0 {\n        Ordering::Less\n    } else if greater_cnt > 0 && less_cnt == 0 {\n        Ordering::Greater\n    } else {\n        debug_assert!((less_cnt > 0 && greater_cnt > 0) || (less_cnt == 0 && greater_cnt == 0));\n        Ordering::Equal\n    }\n"]], "pred": {"ppl": 1.7826287746429443, "ppl_lower": 2.275451898574829, "ppl/lowercase_ppl": -1.4222351688348636, "ppl/zlib": 0.0019464279950700757, "Min_5.0% Prob": 7.513201276461284, "Min_10.0% Prob": 4.820988731384277, "Min_20.0% Prob": 2.7880601982275643, "Min_30.0% Prob": 1.9261770803285272, "Min_40.0% Prob": 1.4471079431218552, "Min_50.0% Prob": 1.1553409594962432, "Min_60.0% Prob": 0.9670731816326688}}
{"hexsha": "bc201e4de741dfe810e53f5de7188f5170e41779", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout__opaque_pthread_t() {\n    assert_eq!(\n        ::std::mem::size_of::<_opaque_pthread_t>(),\n        8192usize,\n        concat!(\"Size of: \", stringify!(_opaque_pthread_t))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<_opaque_pthread_t>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(_opaque_pthread_t))\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_opaque_pthread_t),\n            \"::\",\n            stringify!(__sig)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize\n        },\n        8usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_opaque_pthread_t),\n            \"::\",\n            stringify!(__cleanup_stack)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },\n        16usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_opaque_pthread_t),\n            \"::\",\n            stringify!(__opaque)\n        )\n    );\n}", "item_id": 10, "repo": "chengyuhui/netstat2-rs", "file": "src/integrations/osx/ffi/libproc.rs", "last_update_at": "2022-01-05T12:09:25+00:00", "question_id": "bc201e4de741dfe810e53f5de7188f5170e41779_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bindgen_test_layout__opaque_pthread_t() {\n    assert_eq!(\n        ::std::mem::size_of::<_opaque_pthread_t>(),\n        8192usize,\n        concat!(\"Size of: \", stringify!(_opaque_pthread_t))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<_opaque_pthread_t>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(_opaque_pthread_t))\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_opaque_pthread_t),\n            \"::\",\n            stringify!(__sig)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize\n        },\n        8usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_opaque_pthread_t),\n            \"::\",\n            stringify!(__cleanup_stack)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },\n        16usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_opaque_pthread_t),\n            \"::\",\n            stringify!(__opaque)\n        )\n    );\n"]], "pred": {"ppl": 1.220698356628418, "ppl_lower": 1.236862063407898, "ppl/lowercase_ppl": -1.065962561860991, "ppl/zlib": 0.0006783099266641643, "Min_5.0% Prob": 3.701485486257644, "Min_10.0% Prob": 1.9744904023963352, "Min_20.0% Prob": 1.000408698945458, "Min_30.0% Prob": 0.6676928040304387, "Min_40.0% Prob": 0.5008459644297207, "Min_50.0% Prob": 0.3988383508812721, "Min_60.0% Prob": 0.33262597564616003}}
{"hexsha": "9134b645ee85923bd63ade17cbdbd39ba6accc92", "ext": "rs", "lang": "Rust", "content": "fn test_gaussian_filter_2d() {\n    let a: Array1<f32> = (0..70).step_by(2).map(|v| v as f32).collect();\n    let mut a = a.into_shape((5, 7)).unwrap();\n    a[(0, 0)] = 17.0;\n    assert_relative_eq!(\n        gaussian_filter(&a, 1.0, 4.0),\n        arr2(&[\n            [13.815777, 11.339161, 10.62479, 12.028319, 13.970364, 15.842661, 17.12449],\n            [19.028267, 18.574514, 19.253122, 20.97248, 22.940516, 24.813597, 26.095427],\n            [29.490631, 30.42986, 32.06769, 34.004536, 35.990467, 37.864086, 39.14592],\n            [41.95432, 43.209373, 45.064693, 47.050846, 49.040836, 50.914577, 52.196407],\n            [50.876965, 52.158012, 54.031227, 56.02144, 58.01176, 59.885513, 61.167343],\n        ]),\n        epsilon = 1e-4\n    );\n    let a: Array1<f32> = (0..84).step_by(2).map(|v| v as f32).collect();\n    let mut a = a.into_shape((6, 7)).unwrap();\n    a[(0, 0)] = 8.5;\n    assert_relative_eq!(\n        gaussian_filter(&a, 1.0, 2.0),\n        arr2(&[\n            [10.078889, 9.458512, 10.006921, 11.707343, 13.707343, 15.598366, 16.892008],\n            [17.220367, 17.630152, 18.90118, 20.76284, 22.76284, 24.653864, 25.947506],\n            [29.114912, 30.247316, 32.025234, 34.000000, 36.000000, 37.89102, 39.184666],\n            [42.815334, 44.10898, 46.000000, 48.000000, 50.000000, 51.89102, 53.184666],\n            [56.052494, 57.346134, 59.23716, 61.23716, 63.23716, 65.12818, 66.42182],\n            [65.107994, 66.401634, 68.292656, 70.292656, 72.292656, 74.18368, 75.47732],\n        ]),\n        epsilon = 1e-4\n    );\n\n    let a: Array1<f32> = (0..112).step_by(2).map(|v| v as f32).collect();\n    let mut a = a.into_shape((8, 7)).unwrap();\n    a[(0, 0)] = 18.2;\n    assert_relative_eq!(\n        gaussian_filter(&a, 1.5, 3.5),\n        arr2(&[\n            [16.712738, 16.30507, 16.362633, 17.34964, 18.918924, 20.453388, 21.402458],\n            [22.053278, 22.092232, 22.654442, 23.931578, 25.60057, 27.156698, 28.1087],\n            [31.7295, 32.2731, 33.405533, 35.01049, 36.79215, 38.372753, 39.328068],\n            [44.08236, 44.91609, 46.376343, 48.169773, 50.0162, 51.61088, 52.5681],\n            [57.50711, 58.440548, 60.013466, 61.87167, 63.740356, 65.339874, 66.297745],\n            [70.68089, 71.636, 73.2334, 75.10567, 76.979195, 78.579765, 79.53778],\n            [81.8913, 82.849335, 84.45004, 86.32423, 88.1984, 89.79911, 90.75715],\n            [88.59754, 89.55557, 91.15629, 93.030464, 94.90464, 96.505356, 97.46339],\n        ]),\n        epsilon = 1e-4\n    );\n}", "item_id": 2, "repo": "imeka/ndarray-image", "file": "tests/filters.rs", "last_update_at": "2022-03-17T12:53:11+00:00", "question_id": "9134b645ee85923bd63ade17cbdbd39ba6accc92_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_gaussian_filter_2d() {\n    let a: Array1<f32> = (0..70).step_by(2).map(|v| v as f32).collect();\n    let mut a = a.into_shape((5, 7)).unwrap();\n    a[(0, 0)] = 17.0;\n    assert_relative_eq!(\n        gaussian_filter(&a, 1.0, 4.0),\n        arr2(&[\n            [13.815777, 11.339161, 10.62479, 12.028319, 13.970364, 15.842661, 17.12449],\n            [19.028267, 18.574514, 19.253122, 20.97248, 22.940516, 24.813597, 26.095427],\n            [29.490631, 30.42986, 32.06769, 34.004536, 35.990467, 37.864086, 39.14592],\n            [41.95432, 43.209373, 45.064693, 47.050846, 49.040836, 50.914577, 52.196407],\n            [50.876965, 52.158012, 54.031227, 56.02144, 58.01176, 59.885513, 61.167343],\n        ]),\n        epsilon = 1e-4\n    );\n    let a: Array1<f32> = (0..84).step_by(2).map(|v| v as f32).collect();\n    let mut a = a.into_shape((6, 7)).unwrap();\n    a[(0, 0)] = 8.5;\n    assert_relative_eq!(\n        gaussian_filter(&a, 1.0, 2.0),\n        arr2(&[\n            [10.078889, 9.458512, 10.006921, 11.707343, 13.707343, 15.598366, 16.892008],\n            [17.220367, 17.630152, 18.90118, 20.76284, 22.76284, 24.653864, 25.947506],\n            [29.114912, 30.247316, 32.025234, 34.000000, 36.000000, 37.89102, 39.184666],\n            [42.815334, 44.10898, 46.000000, 48.000000, 50.000000, 51.89102, 53.184666],\n            [56.052494, 57.346134, 59.23716, 61.23716, 63.23716, 65.12818, 66.42182],\n            [65.107994, 66.401634, 68.292656, 70.292656, 72.292656, 74.18368, 75.47732],\n        ]),\n        epsilon = 1e-4\n    );\n    let a: Array1<f32> = (0..112).step_by(2).map(|v| v as f32).collect();\n    let mut a = a.into_shape((8, 7)).unwrap();\n    a[(0, 0)] = 18.2;\n    assert_relative_eq!(\n        gaussian_filter(&a, 1.5, 3.5),\n        arr2(&[\n            [16.712738, 16.30507, 16.362633, 17.34964, 18.918924, 20.453388, 21.402458],\n            [22.053278, 22.092232, 22.654442, 23.931578, 25.60057, 27.156698, 28.1087],\n            [31.7295, 32.2731, 33.405533, 35.01049, 36.79215, 38.372753, 39.328068],\n            [44.08236, 44.91609, 46.376343, 48.169773, 50.0162, 51.61088, 52.5681],\n            [57.50711, 58.440548, 60.013466, 61.87167, 63.740356, 65.339874, 66.297745],\n            [70.68089, 71.636, 73.2334, 75.10567, 76.979195, 78.579765, 79.53778],\n            [81.8913, 82.849335, 84.45004, 86.32423, 88.1984, 89.79911, 90.75715],\n            [88.59754, 89.55557, 91.15629, 93.030464, 94.90464, 96.505356, 97.46339],\n        ]),\n        epsilon = 1e-4\n    );\n"]], "pred": {"ppl": 2.767582416534424, "ppl_lower": 2.8062214851379395, "ppl/lowercase_ppl": -1.013619938928966, "ppl/zlib": 0.001031382133025473, "Min_5.0% Prob": 3.758873967563405, "Min_10.0% Prob": 3.1383678539126527, "Min_20.0% Prob": 2.7450904144960293, "Min_30.0% Prob": 2.5787421067555747, "Min_40.0% Prob": 2.3503354577971556, "Min_50.0% Prob": 2.0085828678132036, "Min_60.0% Prob": 1.6957227027812458}}
{"hexsha": "c6b197af804d779b6b66bba1817ff422da0f548b", "ext": "rs", "lang": "Rust", "content": "fn has_target_feature(\n    name: &str,\n    mut has_target_feature: bool,\n    version: &Version,\n    stabilized: Option<u32>,\n) -> bool {\n    // HACK: Currently, it seems that the only way that works on the stable is\n    // to parse the `-C target-feature` in RUSTFLAGS.\n    //\n    // - #[cfg(target_feature = \"unstable_target_feature\")] doesn't work on stable.\n    // - CARGO_CFG_TARGET_FEATURE excludes unstable features on stable.\n    //\n    // As mentioned in the [RFC2045], unstable target features are also passed to LLVM\n    // (e.g., https://godbolt.org/z/8Eh3z5Wzb), so this hack works properly on stable.\n    //\n    // [RFC2045]: https://rust-lang.github.io/rfcs/2045-target-feature.html#backend-compilation-options\n    if version.nightly || stabilized.map_or(false, |stabilized| version.minor >= stabilized) {\n        has_target_feature = env::var(\"CARGO_CFG_TARGET_FEATURE\")\n            .ok()\n            .map_or(false, |s| s.split(',').any(|s| s == name));\n    } else if let Some(rustflags) = env::var_os(\"CARGO_ENCODED_RUSTFLAGS\") {\n        for mut flag in rustflags.to_string_lossy().split('\\x1f') {\n            if flag.starts_with(\"-C\") {\n                flag = &flag[\"-C\".len()..];\n            }\n            if flag.starts_with(\"target-feature=\") {\n                flag = &flag[\"target-feature=\".len()..];\n                for s in flag.split(',').filter(|s| !s.is_empty()) {\n                    match (s.as_bytes()[0] as char, &s.as_bytes()[1..]) {\n                        ('+', f) if f == name.as_bytes() => has_target_feature = true,\n                        ('-', f) if f == name.as_bytes() => has_target_feature = false,\n                        _ => {}\n                    }\n                }\n            }\n        }\n    }\n    has_target_feature\n}", "item_id": 3, "repo": "taiki-e/portable-atomic", "file": "tests/no-std/build.rs", "last_update_at": "2022-03-25T18:27:06+00:00", "question_id": "c6b197af804d779b6b66bba1817ff422da0f548b_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn has_target_feature(\n    name: &str,\n    mut has_target_feature: bool,\n    version: &Version,\n    stabilized: Option<u32>,\n) -> bool {\n    // HACK: Currently, it seems that the only way that works on the stable is\n    // to parse the `-C target-feature` in RUSTFLAGS.\n    //\n    // - #[cfg(target_feature = \"unstable_target_feature\")] doesn't work on stable.\n    // - CARGO_CFG_TARGET_FEATURE excludes unstable features on stable.\n    //\n    // As mentioned in the [RFC2045], unstable target features are also passed to LLVM\n    // (e.g., https://godbolt.org/z/8Eh3z5Wzb), so this hack works properly on stable.\n    //\n    // [RFC2045]: https://rust-lang.github.io/rfcs/2045-target-feature.html#backend-compilation-options\n    if version.nightly || stabilized.map_or(false, |stabilized| version.minor >= stabilized) {\n        has_target_feature = env::var(\"CARGO_CFG_TARGET_FEATURE\")\n            .ok()\n            .map_or(false, |s| s.split(',').any(|s| s == name));\n    } else if let Some(rustflags) = env::var_os(\"CARGO_ENCODED_RUSTFLAGS\") {\n        for mut flag in rustflags.to_string_lossy().split('\\x1f') {\n            if flag.starts_with(\"-C\") {\n                flag = &flag[\"-C\".len()..];\n            }\n            if flag.starts_with(\"target-feature=\") {\n                flag = &flag[\"target-feature=\".len()..];\n                for s in flag.split(',').filter(|s| !s.is_empty()) {\n                    match (s.as_bytes()[0] as char, &s.as_bytes()[1..]) {\n                        ('+', f) if f == name.as_bytes() => has_target_feature = true,\n                        ('-', f) if f == name.as_bytes() => has_target_feature = false,\n                        _ => {}\n                    }\n                }\n            }\n        }\n    }\n    has_target_feature\n"]], "pred": {"ppl": 2.3840956687927246, "ppl_lower": 2.8738210201263428, "ppl/lowercase_ppl": -1.2150303382889496, "ppl/zlib": 0.0011568839919108987, "Min_5.0% Prob": 6.824763034952098, "Min_10.0% Prob": 5.458178466763989, "Min_20.0% Prob": 3.7632585193356896, "Min_30.0% Prob": 2.7832716797079358, "Min_40.0% Prob": 2.1517412977722974, "Min_50.0% Prob": 1.734107616869256, "Min_60.0% Prob": 1.4497178279678005}}
{"hexsha": "a1137d3c18bd5e6e9b9df5ad207c11ddf07af8a8", "ext": "rs", "lang": "Rust", "content": "pub fn plugin_main<P: Plugin>(host_cb: HostCallbackProc, unique_id: &[u8; 4]) -> *mut AEffect {\n    let mut flags = effect_flags::CAN_REPLACING | effect_flags::PROGRAM_CHUNKS;\n\n    if WrappedPlugin::<P>::wants_midi_input() {\n        flags |= effect_flags::IS_SYNTH;\n    }\n\n    if VST2Adapter::<P>::has_ui() {\n        flags |= effect_flags::HAS_EDITOR;\n    }\n\n    let unique_id =\n          (unique_id[0] as u32) << 24\n        | (unique_id[1] as u32) << 16\n        | (unique_id[2] as u32) << 8\n        | (unique_id[3] as u32);\n    \n    let effect = AEffect {\n        magic: MAGIC,\n\n        dispatcher: dispatch::<P>,\n        process: process_deprecated,\n        set_parameter: set_parameter::<P>,\n        get_parameter: get_parameter::<P>,\n\n        num_programs: 0,\n        num_params: <P::Model as Model<P>>::Smooth::PARAMS.len() as i32,\n        num_inputs: P::INPUT_CHANNELS as i32,\n        num_outputs: P::OUTPUT_CHANNELS as i32,\n\n        flags,\n\n        ptr_1: ptr::null_mut(),\n        ptr_2: ptr::null_mut(),\n\n        initial_delay: 0,\n\n        empty_2: [0; 8],\n        unknown_float: 0.0,\n\n        object: ptr::null_mut(),\n        user: ptr::null_mut(),\n\n        unique_id: unique_id as i32,\n        version: 0,\n\n        process_replacing: process_replacing::<P>,\n        process_double_replacing: process_replacing_f64,\n    };\n    \n    let host_callback = VST2HostCallback {\n        effect: std::ptr::null_mut() as *mut AEffect,\n        host_cb,\n    };\n\n    let mut adapter = Box::new(VST2Adapter::<P> {\n        effect,\n\n        host_callback,\n\n        editor_rect: Rect {\n            top: 0,\n            bottom: 0,\n            left: 0,\n            right: 0,\n        },\n\n        wrapped: WrappedPlugin::new(),\n        state: None,\n\n        output_events_buffer: OutgoingEvents::new()\n    });\n\n    // Make sure we have the correct pointer to the effect.\n    let host_callback = VST2HostCallback {\n        effect: &mut adapter.effect as *mut AEffect,\n        host_cb,\n    };\n    adapter.host_callback = host_callback;\n\n    unsafe {\n        &mut ((*Box::into_raw(adapter)).effect)\n    }\n}", "item_id": 0, "repo": "DGriffin91/baseplug", "file": "src/api/vst2/abi.rs", "last_update_at": "2022-02-27T03:41:13+00:00", "question_id": "a1137d3c18bd5e6e9b9df5ad207c11ddf07af8a8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn plugin_main<P: Plugin>(host_cb: HostCallbackProc, unique_id: &[u8; 4]) -> *mut AEffect {\n    let mut flags = effect_flags::CAN_REPLACING | effect_flags::PROGRAM_CHUNKS;\n    if WrappedPlugin::<P>::wants_midi_input() {\n        flags |= effect_flags::IS_SYNTH;\n    }\n    if VST2Adapter::<P>::has_ui() {\n        flags |= effect_flags::HAS_EDITOR;\n    }\n    let unique_id =\n          (unique_id[0] as u32) << 24\n        | (unique_id[1] as u32) << 16\n        | (unique_id[2] as u32) << 8\n        | (unique_id[3] as u32);\n    let effect = AEffect {\n        magic: MAGIC,\n        dispatcher: dispatch::<P>,\n        process: process_deprecated,\n        set_parameter: set_parameter::<P>,\n        get_parameter: get_parameter::<P>,\n        num_programs: 0,\n        num_params: <P::Model as Model<P>>::Smooth::PARAMS.len() as i32,\n        num_inputs: P::INPUT_CHANNELS as i32,\n        num_outputs: P::OUTPUT_CHANNELS as i32,\n        flags,\n        ptr_1: ptr::null_mut(),\n        ptr_2: ptr::null_mut(),\n        initial_delay: 0,\n        empty_2: [0; 8],\n        unknown_float: 0.0,\n        object: ptr::null_mut(),\n        user: ptr::null_mut(),\n        unique_id: unique_id as i32,\n        version: 0,\n        process_replacing: process_replacing::<P>,\n        process_double_replacing: process_replacing_f64,\n    };\n    let host_callback = VST2HostCallback {\n        effect: std::ptr::null_mut() as *mut AEffect,\n        host_cb,\n    };\n    let mut adapter = Box::new(VST2Adapter::<P> {\n        effect,\n        host_callback,\n        editor_rect: Rect {\n            top: 0,\n            bottom: 0,\n            left: 0,\n            right: 0,\n        },\n        wrapped: WrappedPlugin::new(),\n        state: None,\n        output_events_buffer: OutgoingEvents::new()\n    });\n    // Make sure we have the correct pointer to the effect.\n    let host_callback = VST2HostCallback {\n        effect: &mut adapter.effect as *mut AEffect,\n        host_cb,\n    };\n    adapter.host_callback = host_callback;\n    unsafe {\n        &mut ((*Box::into_raw(adapter)).effect)\n    }\n"]], "pred": {"ppl": 2.3932812213897705, "ppl_lower": 2.735745668411255, "ppl/lowercase_ppl": -1.1532531596070894, "ppl/zlib": 0.0010935655643639043, "Min_5.0% Prob": 7.542246496355212, "Min_10.0% Prob": 5.684155127207438, "Min_20.0% Prob": 3.8359263409052464, "Min_30.0% Prob": 2.7826280198695903, "Min_40.0% Prob": 2.1544634552783526, "Min_50.0% Prob": 1.7389647806329387, "Min_60.0% Prob": 1.4531021782316038}}
{"hexsha": "823d01796f1ad4950edc5cc8e24cb927b4afcbd8", "ext": "rs", "lang": "Rust", "content": "pub fn serialize_operation_crate_operation_copy_image(\n    input: &crate::input::CopyImageInput,\n) -> Result<aws_smithy_http::body::SdkBody, aws_smithy_http::operation::SerializationError> {\n    let mut out = String::new();\n    #[allow(unused_mut)]\n    let mut writer = aws_smithy_query::QueryWriter::new(&mut out, \"CopyImage\", \"2016-11-15\");\n    #[allow(unused_mut)]\n    let mut scope_407 = writer.prefix(\"ClientToken\");\n    if let Some(var_408) = &input.client_token {\n        scope_407.string(var_408);\n    }\n    #[allow(unused_mut)]\n    let mut scope_409 = writer.prefix(\"Description\");\n    if let Some(var_410) = &input.description {\n        scope_409.string(var_410);\n    }\n    #[allow(unused_mut)]\n    let mut scope_411 = writer.prefix(\"Encrypted\");\n    if let Some(var_412) = &input.encrypted {\n        scope_411.boolean(*var_412);\n    }\n    #[allow(unused_mut)]\n    let mut scope_413 = writer.prefix(\"KmsKeyId\");\n    if let Some(var_414) = &input.kms_key_id {\n        scope_413.string(var_414);\n    }\n    #[allow(unused_mut)]\n    let mut scope_415 = writer.prefix(\"Name\");\n    if let Some(var_416) = &input.name {\n        scope_415.string(var_416);\n    }\n    #[allow(unused_mut)]\n    let mut scope_417 = writer.prefix(\"SourceImageId\");\n    if let Some(var_418) = &input.source_image_id {\n        scope_417.string(var_418);\n    }\n    #[allow(unused_mut)]\n    let mut scope_419 = writer.prefix(\"SourceRegion\");\n    if let Some(var_420) = &input.source_region {\n        scope_419.string(var_420);\n    }\n    #[allow(unused_mut)]\n    let mut scope_421 = writer.prefix(\"DestinationOutpostArn\");\n    if let Some(var_422) = &input.destination_outpost_arn {\n        scope_421.string(var_422);\n    }\n    #[allow(unused_mut)]\n    let mut scope_423 = writer.prefix(\"DryRun\");\n    if let Some(var_424) = &input.dry_run {\n        scope_423.boolean(*var_424);\n    }\n    writer.finish();\n    Ok(aws_smithy_http::body::SdkBody::from(out))\n}", "item_id": 44, "repo": "a-xp/aws-sdk-rust", "file": "sdk/ec2/src/operation_ser.rs", "last_update_at": "2022-03-02T02:19:58+00:00", "question_id": "823d01796f1ad4950edc5cc8e24cb927b4afcbd8_44", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn serialize_operation_crate_operation_copy_image(\n    input: &crate::input::CopyImageInput,\n) -> Result<aws_smithy_http::body::SdkBody, aws_smithy_http::operation::SerializationError> {\n    let mut out = String::new();\n    #[allow(unused_mut)]\n    let mut writer = aws_smithy_query::QueryWriter::new(&mut out, \"CopyImage\", \"2016-11-15\");\n    #[allow(unused_mut)]\n    let mut scope_407 = writer.prefix(\"ClientToken\");\n    if let Some(var_408) = &input.client_token {\n        scope_407.string(var_408);\n    }\n    #[allow(unused_mut)]\n    let mut scope_409 = writer.prefix(\"Description\");\n    if let Some(var_410) = &input.description {\n        scope_409.string(var_410);\n    }\n    #[allow(unused_mut)]\n    let mut scope_411 = writer.prefix(\"Encrypted\");\n    if let Some(var_412) = &input.encrypted {\n        scope_411.boolean(*var_412);\n    }\n    #[allow(unused_mut)]\n    let mut scope_413 = writer.prefix(\"KmsKeyId\");\n    if let Some(var_414) = &input.kms_key_id {\n        scope_413.string(var_414);\n    }\n    #[allow(unused_mut)]\n    let mut scope_415 = writer.prefix(\"Name\");\n    if let Some(var_416) = &input.name {\n        scope_415.string(var_416);\n    }\n    #[allow(unused_mut)]\n    let mut scope_417 = writer.prefix(\"SourceImageId\");\n    if let Some(var_418) = &input.source_image_id {\n        scope_417.string(var_418);\n    }\n    #[allow(unused_mut)]\n    let mut scope_419 = writer.prefix(\"SourceRegion\");\n    if let Some(var_420) = &input.source_region {\n        scope_419.string(var_420);\n    }\n    #[allow(unused_mut)]\n    let mut scope_421 = writer.prefix(\"DestinationOutpostArn\");\n    if let Some(var_422) = &input.destination_outpost_arn {\n        scope_421.string(var_422);\n    }\n    #[allow(unused_mut)]\n    let mut scope_423 = writer.prefix(\"DryRun\");\n    if let Some(var_424) = &input.dry_run {\n        scope_423.boolean(*var_424);\n    }\n    writer.finish();\n    Ok(aws_smithy_http::body::SdkBody::from(out))\n"]], "pred": {"ppl": 1.4375605583190918, "ppl_lower": 1.5869777202606201, "ppl/lowercase_ppl": -1.272446426635094, "ppl/zlib": 0.0006563248107203506, "Min_5.0% Prob": 5.89952615789465, "Min_10.0% Prob": 3.5016159494717916, "Min_20.0% Prob": 1.81765006236732, "Min_30.0% Prob": 1.2096548628132064, "Min_40.0% Prob": 0.908853044680032, "Min_50.0% Prob": 0.7258022888543502, "Min_60.0% Prob": 0.6054221714185322}}
{"hexsha": "e670de2d08f3b83fd72dff6f44c4be4280c285b4", "ext": "rs", "lang": "Rust", "content": "async fn get_contracts() -> (\n    AuthContract,\n    ContractId,\n    AuthCallerContract,\n    ContractId,\n    Wallet,\n) {\n    let salt = Salt::from([0u8; 32]);\n    let (provider, wallet) = setup_test_provider_and_wallet().await;\n    let compiled_1 = Contract::load_sway_contract(\n        \"test_artifacts/auth_testing_contract/out/debug/auth_testing_contract.bin\",\n        salt,\n    )\n    .unwrap();\n    let compiled_2 = Contract::load_sway_contract(\n        \"test_artifacts/auth_caller_contract/out/debug/auth_caller_contract.bin\",\n        salt,\n    )\n    .unwrap();\n\n    let id_1 = Contract::deploy(&compiled_1, &provider, &wallet, TxParameters::default())\n        .await\n        .unwrap();\n    let id_2 = Contract::deploy(&compiled_2, &provider, &wallet, TxParameters::default())\n        .await\n        .unwrap();\n\n    let instance_1 = AuthContract::new(id_1.to_string(), provider.clone(), wallet.clone());\n    let instance_2 = AuthCallerContract::new(id_2.to_string(), provider.clone(), wallet.clone());\n\n    (instance_1, id_1, instance_2, id_2, wallet)\n}", "item_id": 3, "repo": "FuelLabs/sway-lib-std", "file": "tests/test_projects/auth/mod.rs", "last_update_at": "2022-02-26T03:45:41+00:00", "question_id": "e670de2d08f3b83fd72dff6f44c4be4280c285b4_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn get_contracts() -> (\n    AuthContract,\n    ContractId,\n    AuthCallerContract,\n    ContractId,\n    Wallet,\n) {\n    let salt = Salt::from([0u8; 32]);\n    let (provider, wallet) = setup_test_provider_and_wallet().await;\n    let compiled_1 = Contract::load_sway_contract(\n        \"test_artifacts/auth_testing_contract/out/debug/auth_testing_contract.bin\",\n        salt,\n    )\n    .unwrap();\n    let compiled_2 = Contract::load_sway_contract(\n        \"test_artifacts/auth_caller_contract/out/debug/auth_caller_contract.bin\",\n        salt,\n    )\n    .unwrap();\n    let id_1 = Contract::deploy(&compiled_1, &provider, &wallet, TxParameters::default())\n        .await\n        .unwrap();\n    let id_2 = Contract::deploy(&compiled_2, &provider, &wallet, TxParameters::default())\n        .await\n        .unwrap();\n    let instance_1 = AuthContract::new(id_1.to_string(), provider.clone(), wallet.clone());\n    let instance_2 = AuthCallerContract::new(id_2.to_string(), provider.clone(), wallet.clone());\n    (instance_1, id_1, instance_2, id_2, wallet)\n"]], "pred": {"ppl": 1.7341556549072266, "ppl_lower": 2.026854991912842, "ppl/lowercase_ppl": -1.2833039751610955, "ppl/zlib": 0.0014878936235461434, "Min_5.0% Prob": 6.384187300999959, "Min_10.0% Prob": 4.483252518706852, "Min_20.0% Prob": 2.58895099408006, "Min_30.0% Prob": 1.807819223321906, "Min_40.0% Prob": 1.3696666651290574, "Min_50.0% Prob": 1.102948716355508, "Min_60.0% Prob": 0.9173359425183487}}
{"hexsha": "511a11219c3a9bfee342d25c620cc7c91c43683c", "ext": "rs", "lang": "Rust", "content": "fn build_closure_expression(\n    mut symbols: &mut Vec<Symbol>,\n    mut syntax_tree: &mut SyntaxTree,\n    symbol: Symbol,\n) -> Result<ExpressionNode, Error> {\n    match symbol {\n        Symbol::ClosureParamsOpen => {}\n        symbol => todo!(\"Unexpected symbol: {:?}\\n\\n{:?}\", symbol, syntax_tree),\n    }\n\n    let symbol = symbols.pop().expect(\"Unfinished closure!\");\n\n    let mut params = match symbol {\n        Symbol::FunctionParamsParamName(_) => vec![build_closure_param_node(\n            &mut symbols,\n            &mut syntax_tree,\n            symbol,\n        )?],\n        Symbol::ClosureParamsClose => vec![],\n        symbol => todo!(\"Unexpected symbol: {:?}\\n\\n{:?}\", symbol, syntax_tree),\n    };\n\n    if params.len() > 0 {\n        loop {\n            let symbol = symbols.pop().expect(\"Unfinished closure!\");\n\n            match symbol {\n                Symbol::ClosureParamsComma => {\n                    let symbol = symbols.pop().expect(\"Unfinished closure!\");\n\n                    params.push(build_closure_param_node(\n                        &mut symbols,\n                        &mut syntax_tree,\n                        symbol,\n                    )?);\n                }\n                Symbol::ClosureParamsClose => {\n                    break;\n                }\n                symbol => todo!(\"Unexpected symbol: {:?}\\n\\n{:?}\", symbol, syntax_tree),\n            }\n        }\n    }\n\n    let return_type = match symbols.last().expect(\"Unfinished closure!\") {\n        Symbol::FunctionReturnTypeColon => {\n            symbols.pop();\n\n            let symbol = symbols.pop().expect(\"Unfinished closure!\");\n\n            Some(build_type_node(&mut symbols, &mut syntax_tree, symbol)?)\n        }\n        _ => None,\n    };\n\n    let signature = ClosureSignatureNode {\n        params,\n        return_type,\n    };\n\n    match symbols.pop().expect(\"Unfinished closure!\") {\n        Symbol::ClosureArrow => {}\n        symbol => todo!(\"Unexpected symbol: {:?}\\n\\n{:?}\", symbol, syntax_tree),\n    }\n\n    let mut statements = match symbols.last().expect(\"Unfinished closure!\") {\n        Symbol::FunctionExpressionsOpenBrace => {\n            symbols.pop();\n            vec![]\n        }\n        _ => {\n            let symbol = symbols.pop().expect(\"Unfinished closure!\");\n            vec![StatementNode::Expression(build_expression_node(\n                &mut symbols,\n                &mut syntax_tree,\n                symbol,\n            )?)]\n        }\n    };\n\n    if statements.len() == 0 {\n        loop {\n            let symbol = symbols.pop().expect(\"Unfinished function!\");\n\n            match symbol {\n                Symbol::FunctionExpressionsCloseBrace => {\n                    break;\n                }\n                symbol => statements.push(build_statement_node(\n                    &mut symbols,\n                    &mut syntax_tree,\n                    symbol,\n                )?),\n            }\n        }\n    }\n\n    let body = FunctionBodyNode { statements };\n\n    return Ok(ExpressionNode::Closure(ClosureExpressionNode {\n        signature,\n        body,\n    }));\n}", "item_id": 5, "repo": "ferrum-lang/ferrum", "file": "src/compiler/parser/mod.rs", "last_update_at": "2022-02-17T20:00:39+00:00", "question_id": "511a11219c3a9bfee342d25c620cc7c91c43683c_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn build_closure_expression(\n    mut symbols: &mut Vec<Symbol>,\n    mut syntax_tree: &mut SyntaxTree,\n    symbol: Symbol,\n) -> Result<ExpressionNode, Error> {\n    match symbol {\n        Symbol::ClosureParamsOpen => {}\n        symbol => todo!(\"Unexpected symbol: {:?}\\n\\n{:?}\", symbol, syntax_tree),\n    }\n    let symbol = symbols.pop().expect(\"Unfinished closure!\");\n    let mut params = match symbol {\n        Symbol::FunctionParamsParamName(_) => vec![build_closure_param_node(\n            &mut symbols,\n            &mut syntax_tree,\n            symbol,\n        )?],\n        Symbol::ClosureParamsClose => vec![],\n        symbol => todo!(\"Unexpected symbol: {:?}\\n\\n{:?}\", symbol, syntax_tree),\n    };\n    if params.len() > 0 {\n        loop {\n            let symbol = symbols.pop().expect(\"Unfinished closure!\");\n            match symbol {\n                Symbol::ClosureParamsComma => {\n                    let symbol = symbols.pop().expect(\"Unfinished closure!\");\n                    params.push(build_closure_param_node(\n                        &mut symbols,\n                        &mut syntax_tree,\n                        symbol,\n                    )?);\n                }\n                Symbol::ClosureParamsClose => {\n                    break;\n                }\n                symbol => todo!(\"Unexpected symbol: {:?}\\n\\n{:?}\", symbol, syntax_tree),\n            }\n        }\n    }\n    let return_type = match symbols.last().expect(\"Unfinished closure!\") {\n        Symbol::FunctionReturnTypeColon => {\n            symbols.pop();\n            let symbol = symbols.pop().expect(\"Unfinished closure!\");\n            Some(build_type_node(&mut symbols, &mut syntax_tree, symbol)?)\n        }\n        _ => None,\n    };\n    let signature = ClosureSignatureNode {\n        params,\n        return_type,\n    };\n    match symbols.pop().expect(\"Unfinished closure!\") {\n        Symbol::ClosureArrow => {}\n        symbol => todo!(\"Unexpected symbol: {:?}\\n\\n{:?}\", symbol, syntax_tree),\n    }\n    let mut statements = match symbols.last().expect(\"Unfinished closure!\") {\n        Symbol::FunctionExpressionsOpenBrace => {\n            symbols.pop();\n            vec![]\n        }\n        _ => {\n            let symbol = symbols.pop().expect(\"Unfinished closure!\");\n            vec![StatementNode::Expression(build_expression_node(\n                &mut symbols,\n                &mut syntax_tree,\n                symbol,\n            )?)]\n        }\n    };\n    if statements.len() == 0 {\n        loop {\n            let symbol = symbols.pop().expect(\"Unfinished function!\");\n            match symbol {\n                Symbol::FunctionExpressionsCloseBrace => {\n                    break;\n                }\n                symbol => statements.push(build_statement_node(\n                    &mut symbols,\n                    &mut syntax_tree,\n                    symbol,\n                )?),\n            }\n        }\n    }\n    let body = FunctionBodyNode { statements };\n    return Ok(ExpressionNode::Closure(ClosureExpressionNode {\n        signature,\n        body,\n    }));\n"]], "pred": {"ppl": 1.5548871755599976, "ppl_lower": 1.696210265159607, "ppl/lowercase_ppl": -1.1970841209499228, "ppl/zlib": 0.0006607829148037735, "Min_5.0% Prob": 5.187592136859894, "Min_10.0% Prob": 3.4911640382107394, "Min_20.0% Prob": 2.104084245952559, "Min_30.0% Prob": 1.453628257039643, "Min_40.0% Prob": 1.0994387611654806, "Min_50.0% Prob": 0.8817887569179781, "Min_60.0% Prob": 0.7354744700791598}}
{"hexsha": "2add226a65dc233e101f8feeabc98631aa02828b", "ext": "rs", "lang": "Rust", "content": "fn test_bert_tokenizer_no_lower_casing() {\n        //        Given\n        let vocab = generate_test_vocab();\n        let bert_tokenizer: BertTokenizer = BertTokenizer::from_existing_vocab(vocab, false, false);\n        let test_tuples = [\n            (\"Hello [MASK] world!\", vec![\"[UNK]\", \"[MASK]\", \"world\", \"!\"]),\n            (\n                \"Hello, unaffable world!\",\n                vec![\"[UNK]\", \"[UNK]\", \"una\", \"##ffa\", \"##ble\", \"world\", \"!\"],\n            ),\n            (\n                \"[UNK]\u4e2d\u534e\u4eba\u6c11\u5171\u548c\u56fd [PAD] asdf\",\n                vec![\n                    \"[UNK]\", \"\u4e2d\", \"\u534e\", \"\u4eba\", \"[UNK]\", \"[UNK]\", \"[UNK]\", \"[UNK]\", \"[PAD]\", \"[UNK]\",\n                ],\n            ),\n        ];\n        let source_texts: Vec<&str> = test_tuples.iter().map(|v| v.0).collect();\n        let expected_results: Vec<Vec<&str>> = test_tuples.iter().map(|v| v.1.clone()).collect();\n\n        //        When & Then\n        for (source_text, expected_result) in test_tuples.iter() {\n            assert_eq!(bert_tokenizer.tokenize(*source_text), *expected_result);\n        }\n\n        assert_eq!(\n            Tokenizer::tokenize_list(&bert_tokenizer, &source_texts),\n            expected_results\n        );\n        assert_eq!(\n            MultiThreadedTokenizer::tokenize_list(&bert_tokenizer, &source_texts),\n            expected_results\n        );\n    }", "item_id": 2, "repo": "eonm-abes/rust-tokenizers", "file": "main/src/tokenizer/bert_tokenizer.rs", "last_update_at": "2022-03-02T08:41:12+00:00", "question_id": "2add226a65dc233e101f8feeabc98631aa02828b_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_bert_tokenizer_no_lower_casing() {\n        //        Given\n        let vocab = generate_test_vocab();\n        let bert_tokenizer: BertTokenizer = BertTokenizer::from_existing_vocab(vocab, false, false);\n        let test_tuples = [\n            (\"Hello [MASK] world!\", vec![\"[UNK]\", \"[MASK]\", \"world\", \"!\"]),\n            (\n                \"Hello, unaffable world!\",\n                vec![\"[UNK]\", \"[UNK]\", \"una\", \"##ffa\", \"##ble\", \"world\", \"!\"],\n            ),\n            (\n                \"[UNK]\u4e2d\u534e\u4eba\u6c11\u5171\u548c\u56fd [PAD] asdf\",\n                vec![\n                    \"[UNK]\", \"\u4e2d\", \"\u534e\", \"\u4eba\", \"[UNK]\", \"[UNK]\", \"[UNK]\", \"[UNK]\", \"[PAD]\", \"[UNK]\",\n                ],\n            ),\n        ];\n        let source_texts: Vec<&str> = test_tuples.iter().map(|v| v.0).collect();\n        let expected_results: Vec<Vec<&str>> = test_tuples.iter().map(|v| v.1.clone()).collect();\n        //        When & Then\n        for (source_text, expected_result) in test_tuples.iter() {\n            assert_eq!(bert_tokenizer.tokenize(*source_text), *expected_result);\n        }\n        assert_eq!(\n            Tokenizer::tokenize_list(&bert_tokenizer, &source_texts),\n            expected_results\n        );\n        assert_eq!(\n            MultiThreadedTokenizer::tokenize_list(&bert_tokenizer, &source_texts),\n            expected_results\n        );\n"]], "pred": {"ppl": 1.8361905813217163, "ppl_lower": 2.211331367492676, "ppl/lowercase_ppl": -1.305913752977057, "ppl/zlib": 0.0012401899781102129, "Min_5.0% Prob": 6.812896081379482, "Min_10.0% Prob": 4.582564653352249, "Min_20.0% Prob": 2.8123643521604866, "Min_30.0% Prob": 1.9805160789316847, "Min_40.0% Prob": 1.5142790018660681, "Min_50.0% Prob": 1.2162725424997882, "Min_60.0% Prob": 1.013942997410412}}
{"hexsha": "fda6fb51772f6ea99e2e49db4275566c2d580a25", "ext": "rs", "lang": "Rust", "content": "fn test_calculate_amounts_from_balances_virtual_balancing_transaction() {\n        let mut transactions = parse_transactions(\n            r#\"\n2018-10-01 Marek Ogarek\n  TEST:ABC     $1.20\n  TEST:DEF\n\n2018-10-01 Marek Ogarek\n  [TEST:ABC]         = $1.20\n\"#,\n        );\n        let expected_transactions = parse_transactions(\n            r#\"\n2018-10-01 Marek Ogarek\n  TEST:ABC     $1.20\n  TEST:DEF    $-1.20\n\n2018-10-01 Marek Ogarek\n  [TEST:ABC]   $0.00\n\"#,\n        );\n        assert_eq!(\n            calculate_amounts_from_balances(&mut transactions, &mut Vec::new()),\n            Ok(())\n        );\n        assert_eq!(transactions, expected_transactions);\n    }", "item_id": 23, "repo": "marek-g/rust-ledger-utils", "file": "src/calculate_amounts.rs", "last_update_at": "2022-02-19T18:15:14+00:00", "question_id": "fda6fb51772f6ea99e2e49db4275566c2d580a25_23", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_calculate_amounts_from_balances_virtual_balancing_transaction() {\n        let mut transactions = parse_transactions(\n            r#\"\n2018-10-01 Marek Ogarek\n  TEST:ABC     $1.20\n  TEST:DEF\n2018-10-01 Marek Ogarek\n  [TEST:ABC]         = $1.20\n\"#,\n        );\n        let expected_transactions = parse_transactions(\n            r#\"\n2018-10-01 Marek Ogarek\n  TEST:ABC     $1.20\n  TEST:DEF    $-1.20\n2018-10-01 Marek Ogarek\n  [TEST:ABC]   $0.00\n\"#,\n        );\n        assert_eq!(\n            calculate_amounts_from_balances(&mut transactions, &mut Vec::new()),\n            Ok(())\n        );\n        assert_eq!(transactions, expected_transactions);\n"]], "pred": {"ppl": 2.6465089321136475, "ppl_lower": 2.963557004928589, "ppl/lowercase_ppl": -1.1162598013488647, "ppl/zlib": 0.0039402485318897505, "Min_5.0% Prob": 8.549818396568298, "Min_10.0% Prob": 6.59215666770935, "Min_20.0% Prob": 4.25036736796884, "Min_30.0% Prob": 3.1017598219608007, "Min_40.0% Prob": 2.392764267529927, "Min_50.0% Prob": 1.9417610477626792, "Min_60.0% Prob": 1.6190069381245016}}
{"hexsha": "4c84db8b6b41fc6cd5d6f54ad130d3363987b677", "ext": "rs", "lang": "Rust", "content": "pub fn serialize_structure_crate_model_auto_ml_security_config(\n    object: &mut aws_smithy_json::serialize::JsonObjectWriter,\n    input: &crate::model::AutoMlSecurityConfig,\n) -> Result<(), aws_smithy_http::operation::SerializationError> {\n    if let Some(var_2009) = &input.volume_kms_key_id {\n        object.key(\"VolumeKmsKeyId\").string(var_2009);\n    }\n    if input.enable_inter_container_traffic_encryption {\n        object\n            .key(\"EnableInterContainerTrafficEncryption\")\n            .boolean(input.enable_inter_container_traffic_encryption);\n    }\n    if let Some(var_2010) = &input.vpc_config {\n        let mut object_2011 = object.key(\"VpcConfig\").start_object();\n        crate::json_ser::serialize_structure_crate_model_vpc_config(&mut object_2011, var_2010)?;\n        object_2011.finish();\n    }\n    Ok(())\n}", "item_id": 251, "repo": "a-xp/aws-sdk-rust", "file": "sdk/sagemaker/src/json_ser.rs", "last_update_at": "2022-03-02T02:19:58+00:00", "question_id": "4c84db8b6b41fc6cd5d6f54ad130d3363987b677_251", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn serialize_structure_crate_model_auto_ml_security_config(\n    object: &mut aws_smithy_json::serialize::JsonObjectWriter,\n    input: &crate::model::AutoMlSecurityConfig,\n) -> Result<(), aws_smithy_http::operation::SerializationError> {\n    if let Some(var_2009) = &input.volume_kms_key_id {\n        object.key(\"VolumeKmsKeyId\").string(var_2009);\n    }\n    if input.enable_inter_container_traffic_encryption {\n        object\n            .key(\"EnableInterContainerTrafficEncryption\")\n            .boolean(input.enable_inter_container_traffic_encryption);\n    }\n    if let Some(var_2010) = &input.vpc_config {\n        let mut object_2011 = object.key(\"VpcConfig\").start_object();\n        crate::json_ser::serialize_structure_crate_model_vpc_config(&mut object_2011, var_2010)?;\n        object_2011.finish();\n    }\n    Ok(())\n"]], "pred": {"ppl": 2.5176258087158203, "ppl_lower": 3.167093276977539, "ppl/lowercase_ppl": -1.248558264806342, "ppl/zlib": 0.0023375096659052448, "Min_5.0% Prob": 9.15778282710484, "Min_10.0% Prob": 6.977614964757647, "Min_20.0% Prob": 4.387689401183212, "Min_30.0% Prob": 3.0556236150306324, "Min_40.0% Prob": 2.311487025961928, "Min_50.0% Prob": 1.8513594408933487, "Min_60.0% Prob": 1.5420902938584695}}
{"hexsha": "d2aab05ce06d795f75cb1111540483ce28b0f166", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout_bdfprops() {\n    assert_eq!(\n        ::std::mem::size_of::<bdfprops>(),\n        24usize,\n        concat!(\"Size of: \", stringify!(bdfprops))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<bdfprops>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(bdfprops))\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<bdfprops>())).name as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(bdfprops),\n            \"::\",\n            stringify!(name)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<bdfprops>())).type_ as *const _ as usize },\n        8usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(bdfprops),\n            \"::\",\n            stringify!(type_)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<bdfprops>())).u as *const _ as usize },\n        16usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(bdfprops),\n            \"::\",\n            stringify!(u)\n        )\n    );\n}", "item_id": 122, "repo": "mfeq/Qstroke", "file": "fontforge-sys/src/lib.rs", "last_update_at": "2022-02-09T06:16:05+00:00", "question_id": "d2aab05ce06d795f75cb1111540483ce28b0f166_122", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bindgen_test_layout_bdfprops() {\n    assert_eq!(\n        ::std::mem::size_of::<bdfprops>(),\n        24usize,\n        concat!(\"Size of: \", stringify!(bdfprops))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<bdfprops>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(bdfprops))\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<bdfprops>())).name as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(bdfprops),\n            \"::\",\n            stringify!(name)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<bdfprops>())).type_ as *const _ as usize },\n        8usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(bdfprops),\n            \"::\",\n            stringify!(type_)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<bdfprops>())).u as *const _ as usize },\n        16usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(bdfprops),\n            \"::\",\n            stringify!(u)\n        )\n    );\n"]], "pred": {"ppl": 1.2399238348007202, "ppl_lower": 1.2795246839523315, "ppl/lowercase_ppl": -1.146192610187361, "ppl/zlib": 0.0008084584743708115, "Min_5.0% Prob": 4.366205687032027, "Min_10.0% Prob": 2.1953049501138073, "Min_20.0% Prob": 1.087199987549315, "Min_30.0% Prob": 0.7215007906365529, "Min_40.0% Prob": 0.5398753833123157, "Min_50.0% Prob": 0.4312995060724598, "Min_60.0% Prob": 0.359082774880263}}
{"hexsha": "a1d42519f4c63b218250cf7687a8c47f28ca2ec4", "ext": "rs", "lang": "Rust", "content": "unsafe fn find_unused_key_code(\n    display: *mut ffi::Display,\n    min_keycode: ffi::KeyCode,\n    max_keycode: ffi::KeyCode,\n) -> Result<ffi::KeyCode, Error> {\n\n    // Get the full mapping from keycodes to keysyms. There may be\n    // multiple keysyms for each keycode depending on which modifiers\n    // are pressed. We need this for finding an unused keycode, that is\n    // a keycode without any associated keysyms.\n    let keycode_count = (max_keycode - min_keycode) + 1;\n    let mut keysyms_per_keycode = 0;\n    let keysyms = ffi::XGetKeyboardMapping(\n        display,\n        min_keycode,\n        keycode_count as std::os::raw::c_int,\n        &mut keysyms_per_keycode,\n    );\n    if keysyms.is_null() {\n        return Err(Error::Platform(PlatformError::XGetKeyboardMapping));\n    }\n    let keysyms_per_keycode = keysyms_per_keycode as usize;\n\n    // Find a keycode that has no keysyms associated with it. This keycode will\n    // be used for remapping for the purpose of producing characters that aren't\n    // on the default keyboard layout.\n    for code_idx in 0..keycode_count {\n        let sym_idx = code_idx as usize * keysyms_per_keycode;\n        let slice = std::slice::from_raw_parts(\n            keysyms.add(sym_idx), keysyms_per_keycode\n        );\n        if slice.iter().all(|keysym| *keysym == ffi::NoSymbol) {\n            ffi::XFree(keysyms);\n            return Ok(code_idx + min_keycode);\n        }\n    }\n\n    ffi::XFree(keysyms);\n    Err(Error::Platform(PlatformError::NoUnusedKeyCode))\n}", "item_id": 1, "repo": "Byron/The-Fat-Controller", "file": "src/linux_x11/mod.rs", "last_update_at": "2022-03-25T10:40:47+00:00", "question_id": "a1d42519f4c63b218250cf7687a8c47f28ca2ec4_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe fn find_unused_key_code(\n    display: *mut ffi::Display,\n    min_keycode: ffi::KeyCode,\n    max_keycode: ffi::KeyCode,\n) -> Result<ffi::KeyCode, Error> {\n    // Get the full mapping from keycodes to keysyms. There may be\n    // multiple keysyms for each keycode depending on which modifiers\n    // are pressed. We need this for finding an unused keycode, that is\n    // a keycode without any associated keysyms.\n    let keycode_count = (max_keycode - min_keycode) + 1;\n    let mut keysyms_per_keycode = 0;\n    let keysyms = ffi::XGetKeyboardMapping(\n        display,\n        min_keycode,\n        keycode_count as std::os::raw::c_int,\n        &mut keysyms_per_keycode,\n    );\n    if keysyms.is_null() {\n        return Err(Error::Platform(PlatformError::XGetKeyboardMapping));\n    }\n    let keysyms_per_keycode = keysyms_per_keycode as usize;\n    // Find a keycode that has no keysyms associated with it. This keycode will\n    // be used for remapping for the purpose of producing characters that aren't\n    // on the default keyboard layout.\n    for code_idx in 0..keycode_count {\n        let sym_idx = code_idx as usize * keysyms_per_keycode;\n        let slice = std::slice::from_raw_parts(\n            keysyms.add(sym_idx), keysyms_per_keycode\n        );\n        if slice.iter().all(|keysym| *keysym == ffi::NoSymbol) {\n            ffi::XFree(keysyms);\n            return Ok(code_idx + min_keycode);\n        }\n    }\n    ffi::XFree(keysyms);\n    Err(Error::Platform(PlatformError::NoUnusedKeyCode))\n"]], "pred": {"ppl": 2.0730719566345215, "ppl_lower": 2.358665704727173, "ppl/lowercase_ppl": -1.1770355982802596, "ppl/zlib": 0.0011498920255585143, "Min_5.0% Prob": 6.430345058441162, "Min_10.0% Prob": 4.892795922804852, "Min_20.0% Prob": 3.2824960146287476, "Min_30.0% Prob": 2.3546617997172694, "Min_40.0% Prob": 1.813741061234414, "Min_50.0% Prob": 1.4574741823148103, "Min_60.0% Prob": 1.215216604411452}}
{"hexsha": "b632d76ef380755c4eeba82137bfa4cdca87282c", "ext": "rs", "lang": "Rust", "content": "fn connect_initiation_uses_biased_codec_negotiation_by_peer() {\n        let (mut exec, mut peers, _stream, sbc_codec, _aac_codec) = setup_negotiation_test();\n        let id = PeerId(1);\n        let (remote, channel) = Channel::create();\n\n        // System biases towards the Source direction (called when the AudioMode FIDL changes).\n        peers.set_preferred_direction(avdtp::EndpointType::Source);\n\n        // New fake peer discovered with some descriptor - the peer's SDP entry shows Sink.\n        let remote = avdtp::Peer::new(remote);\n        let desc = ProfileDescriptor {\n            profile_id: ServiceClassProfileIdentifier::AdvancedAudioDistribution,\n            major_version: 1,\n            minor_version: 2,\n        };\n        let preferred_direction = vec![avdtp::EndpointType::Sink];\n        let delay = zx::Duration::from_seconds(1);\n        peers.found(id, desc, HashSet::from_iter(preferred_direction.into_iter()));\n\n        let _ = peers.connected(id, channel, Some(delay)).expect(\"connect control channel is ok\");\n        // run the start task until it's stalled.\n        let _ = exec.run_until_stalled(&mut futures::future::pending::<()>());\n\n        let mut remote_requests = remote.take_request_stream();\n\n        // Should wait for the specified amount of time.\n        assert!(exec.run_until_stalled(&mut remote_requests.next()).is_pending());\n\n        exec.set_fake_time(fasync::Time::after(delay + zx::Duration::from_micros(1)));\n        let _ = exec.wake_expired_timers();\n\n        let _ = exec.run_until_stalled(&mut futures::future::pending::<()>());\n        // Even though the peer supports both SBC Sink and Source, we expect to negotiate and start\n        // on the Sink endpoint since that is the peer's preferred one.\n        let (peer_sbc_source_seid, peer_sbc_source_endpoint) = sbc_source_endpoint();\n        let (peer_sbc_sink_seid, peer_sbc_sink_endpoint) = sbc_sink_endpoint();\n        expect_peer_discovery(\n            &mut exec,\n            &mut remote_requests,\n            vec![peer_sbc_source_endpoint, peer_sbc_sink_endpoint],\n        );\n        for _twice in 1..=2 {\n            match exec.run_until_stalled(&mut remote_requests.next()) {\n                Poll::Ready(Some(Ok(avdtp::Request::GetCapabilities { stream_id, responder }))) => {\n                    let codec = match stream_id {\n                        id if id == peer_sbc_source_seid => sbc_codec.clone(),\n                        id if id == peer_sbc_sink_seid => sbc_codec.clone(),\n                        x => panic!(\"Got unexpected get_capabilities seid {:?}\", x),\n                    };\n                    responder\n                        .send(&vec![avdtp::ServiceCapability::MediaTransport, codec])\n                        .expect(\"respond succeeds\");\n                }\n                x => panic!(\"Expected a ready get capabilities request, got {:?}\", x),\n            };\n        }\n\n        match exec.run_until_stalled(&mut remote_requests.next()) {\n            Poll::Ready(Some(Ok(avdtp::Request::SetConfiguration {\n                local_stream_id,\n                remote_stream_id,\n                capabilities: _,\n                responder,\n            }))) => {\n                // We expect the set configuration to apply to the remote peer's Sink SEID and the\n                // local Source SEID.\n                assert_eq!(peer_sbc_sink_seid, local_stream_id);\n                let local_sbc_source_seid: avdtp::StreamEndpointId =\n                    SBC_SOURCE_SEID.try_into().unwrap();\n                assert_eq!(local_sbc_source_seid, remote_stream_id);\n                responder.send().expect(\"response sends\");\n            }\n            x => panic!(\"Expected a ready set configuration request, got {:?}\", x),\n        };\n    }", "item_id": 13, "repo": "allansrc/fuchsia", "file": "src/connectivity/bluetooth/lib/bt-a2dp/src/connected_peers.rs", "last_update_at": "2022-01-21T20:14:17+00:00", "question_id": "b632d76ef380755c4eeba82137bfa4cdca87282c_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn connect_initiation_uses_biased_codec_negotiation_by_peer() {\n        let (mut exec, mut peers, _stream, sbc_codec, _aac_codec) = setup_negotiation_test();\n        let id = PeerId(1);\n        let (remote, channel) = Channel::create();\n        // System biases towards the Source direction (called when the AudioMode FIDL changes).\n        peers.set_preferred_direction(avdtp::EndpointType::Source);\n        // New fake peer discovered with some descriptor - the peer's SDP entry shows Sink.\n        let remote = avdtp::Peer::new(remote);\n        let desc = ProfileDescriptor {\n            profile_id: ServiceClassProfileIdentifier::AdvancedAudioDistribution,\n            major_version: 1,\n            minor_version: 2,\n        };\n        let preferred_direction = vec![avdtp::EndpointType::Sink];\n        let delay = zx::Duration::from_seconds(1);\n        peers.found(id, desc, HashSet::from_iter(preferred_direction.into_iter()));\n        let _ = peers.connected(id, channel, Some(delay)).expect(\"connect control channel is ok\");\n        // run the start task until it's stalled.\n        let _ = exec.run_until_stalled(&mut futures::future::pending::<()>());\n        let mut remote_requests = remote.take_request_stream();\n        // Should wait for the specified amount of time.\n        assert!(exec.run_until_stalled(&mut remote_requests.next()).is_pending());\n        exec.set_fake_time(fasync::Time::after(delay + zx::Duration::from_micros(1)));\n        let _ = exec.wake_expired_timers();\n        let _ = exec.run_until_stalled(&mut futures::future::pending::<()>());\n        // Even though the peer supports both SBC Sink and Source, we expect to negotiate and start\n        // on the Sink endpoint since that is the peer's preferred one.\n        let (peer_sbc_source_seid, peer_sbc_source_endpoint) = sbc_source_endpoint();\n        let (peer_sbc_sink_seid, peer_sbc_sink_endpoint) = sbc_sink_endpoint();\n        expect_peer_discovery(\n            &mut exec,\n            &mut remote_requests,\n            vec![peer_sbc_source_endpoint, peer_sbc_sink_endpoint],\n        );\n        for _twice in 1..=2 {\n            match exec.run_until_stalled(&mut remote_requests.next()) {\n                Poll::Ready(Some(Ok(avdtp::Request::GetCapabilities { stream_id, responder }))) => {\n                    let codec = match stream_id {\n                        id if id == peer_sbc_source_seid => sbc_codec.clone(),\n                        id if id == peer_sbc_sink_seid => sbc_codec.clone(),\n                        x => panic!(\"Got unexpected get_capabilities seid {:?}\", x),\n                    };\n                    responder\n                        .send(&vec![avdtp::ServiceCapability::MediaTransport, codec])\n                        .expect(\"respond succeeds\");\n                }\n                x => panic!(\"Expected a ready get capabilities request, got {:?}\", x),\n            };\n        }\n        match exec.run_until_stalled(&mut remote_requests.next()) {\n            Poll::Ready(Some(Ok(avdtp::Request::SetConfiguration {\n                local_stream_id,\n                remote_stream_id,\n                capabilities: _,\n                responder,\n            }))) => {\n                // We expect the set configuration to apply to the remote peer's Sink SEID and the\n                // local Source SEID.\n                assert_eq!(peer_sbc_sink_seid, local_stream_id);\n                let local_sbc_source_seid: avdtp::StreamEndpointId =\n                    SBC_SOURCE_SEID.try_into().unwrap();\n                assert_eq!(local_sbc_source_seid, remote_stream_id);\n                responder.send().expect(\"response sends\");\n            }\n            x => panic!(\"Expected a ready set configuration request, got {:?}\", x),\n        };\n"]], "pred": {"ppl": 2.550668478012085, "ppl_lower": 3.137751817703247, "ppl/lowercase_ppl": -1.2212312468556847, "ppl/zlib": 0.0007202734408119401, "Min_5.0% Prob": 7.846115346048393, "Min_10.0% Prob": 6.0657781011918015, "Min_20.0% Prob": 4.100710404854195, "Min_30.0% Prob": 3.0192312311892415, "Min_40.0% Prob": 2.321269458893022, "Min_50.0% Prob": 1.8710491116689025, "Min_60.0% Prob": 1.562033342158036}}
{"hexsha": "58855566eae511b01b128211127672883dd1eba8", "ext": "rs", "lang": "Rust", "content": "fn huffman_decode<R: Read>(\r\n    reader: &mut BitReader<R, BigEndian>,\r\n    huffman_table: &HuffmanTable,\r\n    state: &mut HuffmanState,\r\n) -> Result<usize, Error> {\r\n    let mut point = 0;\r\n    let mut bits_left = 32;\r\n    let mut bits_read = 0;\r\n    if !huffman_table.data.is_empty() {\r\n        loop {\r\n            if huffman_table.data[point] & 0xff00 == 0 {\r\n                state.x = ((huffman_table.data[point] >> 4) & 0xf).into();\r\n                state.y = (huffman_table.data[point] & 0xf).into();\r\n                break;\r\n            }\r\n\r\n            bits_read += 1;\r\n            if reader.read_bit()? {\r\n                while (huffman_table.data[point] & 0xff) >= 250 {\r\n                    point += (huffman_table.data[point] & 0xff) as usize;\r\n                }\r\n                point += (huffman_table.data[point] & 0xff) as usize;\r\n            } else {\r\n                while (huffman_table.data[point] >> 8) >= 250 {\r\n                    point += (huffman_table.data[point] >> 8) as usize;\r\n                }\r\n                point += (huffman_table.data[point] >> 8) as usize;\r\n            }\r\n\r\n            bits_left -= 1;\r\n            if bits_left <= 0 || point >= huffman_table.data.len() {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if huffman_table.quads {\r\n            state.v = (state.y >> 3) & 1;\r\n            state.w = (state.y >> 2) & 1;\r\n            state.x = (state.y >> 1) & 1;\r\n            state.y &= 1;\r\n\r\n            if state.v > 0 {\r\n                bits_read += 1;\r\n                if reader.read_bit()? {\r\n                    state.v = -state.v;\r\n                }\r\n            }\r\n            if state.w > 0 {\r\n                bits_read += 1;\r\n                if reader.read_bit()? {\r\n                    state.w = -state.w;\r\n                }\r\n            }\r\n            if state.x > 0 {\r\n                bits_read += 1;\r\n                if reader.read_bit()? {\r\n                    state.x = -state.x;\r\n                }\r\n            }\r\n            if state.y > 0 {\r\n                bits_read += 1;\r\n                if reader.read_bit()? {\r\n                    state.y = -state.y;\r\n                }\r\n            }\r\n        } else {\r\n            if huffman_table.linbits > 0 && state.x == 15 {\r\n                bits_read += huffman_table.linbits;\r\n                // TODO(Herschel): u32?\r\n                state.x += reader.read::<u32>(huffman_table.linbits as u32)? as i32;\r\n            }\r\n\r\n            if state.x > 0 {\r\n                bits_read += 1;\r\n                if reader.read_bit()? {\r\n                    state.x = -state.x;\r\n                }\r\n            }\r\n\r\n            if huffman_table.linbits > 0 && state.y == 15 {\r\n                bits_read += huffman_table.linbits;\r\n                state.y += reader.read::<u32>(huffman_table.linbits as u32)? as i32;\r\n            }\r\n\r\n            if state.y > 0 {\r\n                bits_read += 1;\r\n                if reader.read_bit()? {\r\n                    state.y = -state.y;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        *state = Default::default();\r\n    }\r\n    Ok(bits_read)\r\n}", "item_id": 1, "repo": "gentoid/puremp3", "file": "src/huffman.rs", "last_update_at": "2022-03-13T19:34:00+00:00", "question_id": "58855566eae511b01b128211127672883dd1eba8_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn huffman_decode<R: Read>(\r\n    reader: &mut BitReader<R, BigEndian>,\r\n    huffman_table: &HuffmanTable,\r\n    state: &mut HuffmanState,\r\n) -> Result<usize, Error> {\r\n    let mut point = 0;\r\n    let mut bits_left = 32;\r\n    let mut bits_read = 0;\r\n    if !huffman_table.data.is_empty() {\r\n        loop {\r\n            if huffman_table.data[point] & 0xff00 == 0 {\r\n                state.x = ((huffman_table.data[point] >> 4) & 0xf).into();\r\n                state.y = (huffman_table.data[point] & 0xf).into();\r\n                break;\r\n            }\r\n\r\n            bits_read += 1;\r\n            if reader.read_bit()? {\r\n                while (huffman_table.data[point] & 0xff) >= 250 {\r\n                    point += (huffman_table.data[point] & 0xff) as usize;\r\n                }\r\n                point += (huffman_table.data[point] & 0xff) as usize;\r\n            } else {\r\n                while (huffman_table.data[point] >> 8) >= 250 {\r\n                    point += (huffman_table.data[point] >> 8) as usize;\r\n                }\r\n                point += (huffman_table.data[point] >> 8) as usize;\r\n            }\r\n\r\n            bits_left -= 1;\r\n            if bits_left <= 0 || point >= huffman_table.data.len() {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if huffman_table.quads {\r\n            state.v = (state.y >> 3) & 1;\r\n            state.w = (state.y >> 2) & 1;\r\n            state.x = (state.y >> 1) & 1;\r\n            state.y &= 1;\r\n\r\n            if state.v > 0 {\r\n                bits_read += 1;\r\n                if reader.read_bit()? {\r\n                    state.v = -state.v;\r\n                }\r\n            }\r\n            if state.w > 0 {\r\n                bits_read += 1;\r\n                if reader.read_bit()? {\r\n                    state.w = -state.w;\r\n                }\r\n            }\r\n            if state.x > 0 {\r\n                bits_read += 1;\r\n                if reader.read_bit()? {\r\n                    state.x = -state.x;\r\n                }\r\n            }\r\n            if state.y > 0 {\r\n                bits_read += 1;\r\n                if reader.read_bit()? {\r\n                    state.y = -state.y;\r\n                }\r\n            }\r\n        } else {\r\n            if huffman_table.linbits > 0 && state.x == 15 {\r\n                bits_read += huffman_table.linbits;\r\n                // TODO(Herschel): u32?\r\n                state.x += reader.read::<u32>(huffman_table.linbits as u32)? as i32;\r\n            }\r\n\r\n            if state.x > 0 {\r\n                bits_read += 1;\r\n                if reader.read_bit()? {\r\n                    state.x = -state.x;\r\n                }\r\n            }\r\n\r\n            if huffman_table.linbits > 0 && state.y == 15 {\r\n                bits_read += huffman_table.linbits;\r\n                state.y += reader.read::<u32>(huffman_table.linbits as u32)? as i32;\r\n            }\r\n\r\n            if state.y > 0 {\r\n                bits_read += 1;\r\n                if reader.read_bit()? {\r\n                    state.y = -state.y;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        *state = Default::default();\r\n    }\r\n    Ok(bits_read)\r\n"]], "pred": {"ppl": 1.5200527906417847, "ppl_lower": 1.6256334781646729, "ppl/lowercase_ppl": -1.1603660871859194, "ppl/zlib": 0.0007121514709871996, "Min_5.0% Prob": 4.882621108269205, "Min_10.0% Prob": 3.3445690171887175, "Min_20.0% Prob": 2.0068404581678574, "Min_30.0% Prob": 1.3838871267926334, "Min_40.0% Prob": 1.0453061555864704, "Min_50.0% Prob": 0.8370742479732115, "Min_60.0% Prob": 0.698758266512581}}
{"hexsha": "11ce203089b093a0fe111d1b15cd09e8bfe5ad3e", "ext": "rs", "lang": "Rust", "content": "pub fn init(header: &'static mut VirtIOHeader) {\n    let event_buf = Box::leak(Box::new([0u64; 32]));\n    let input = VirtIOInput::new(header, event_buf).expect(\"failed to create input driver\");\n\n    let driver = Arc::new(VirtIOInputDriver(Mutex::new(input)));\n    IRQ_MANAGER.write().register_all(driver.clone());\n    DRIVERS.write().push(driver);\n}", "item_id": 0, "repo": "WenhaoKong2001/rCore", "file": "kernel/src/drivers/input/virtio_input.rs", "last_update_at": "2022-03-31T15:56:40+00:00", "question_id": "11ce203089b093a0fe111d1b15cd09e8bfe5ad3e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn init(header: &'static mut VirtIOHeader) {\n    let event_buf = Box::leak(Box::new([0u64; 32]));\n    let input = VirtIOInput::new(header, event_buf).expect(\"failed to create input driver\");\n    let driver = Arc::new(VirtIOInputDriver(Mutex::new(input)));\n    IRQ_MANAGER.write().register_all(driver.clone());\n    DRIVERS.write().push(driver);\n"]], "pred": {"ppl": 3.688977003097534, "ppl_lower": 6.279433727264404, "ppl/lowercase_ppl": -1.4075006344322725, "ppl/zlib": 0.005602357015806051, "Min_5.0% Prob": 8.649594068527222, "Min_10.0% Prob": 7.147117257118225, "Min_20.0% Prob": 5.09334324836731, "Min_30.0% Prob": 3.944678590104387, "Min_40.0% Prob": 3.11303426861763, "Min_50.0% Prob": 2.5489611573635584, "Min_60.0% Prob": 2.1728200441598893}}
{"hexsha": "919fffee936f4bc984f9df49b0eb53e0d2b00a7e", "ext": "rs", "lang": "Rust", "content": "fn size_hint() {\n\t\tlet mut coord = Coordinates::new(Region::from(0, 0, 2, 2));\n\n\t\tassert_eq!(4, coord.size_hint().0);\n\t\tcoord.next().unwrap();\n\t\tassert_eq!(3, coord.size_hint().0);\n\t\tcoord.next().unwrap();\n\t\tassert_eq!(2, coord.size_hint().0);\n\t\tcoord.next().unwrap();\n\t\tassert_eq!(1, coord.size_hint().0);\n\t\tcoord.next().unwrap();\n\t\tassert_eq!(0, coord.size_hint().0);\n\t}", "item_id": 0, "repo": "meh/rust-picto", "file": "src/iter/coordinates.rs", "last_update_at": "2022-02-24T13:10:48+00:00", "question_id": "919fffee936f4bc984f9df49b0eb53e0d2b00a7e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn size_hint() {\n\t\tlet mut coord = Coordinates::new(Region::from(0, 0, 2, 2));\n\t\tassert_eq!(4, coord.size_hint().0);\n\t\tcoord.next().unwrap();\n\t\tassert_eq!(3, coord.size_hint().0);\n\t\tcoord.next().unwrap();\n\t\tassert_eq!(2, coord.size_hint().0);\n\t\tcoord.next().unwrap();\n\t\tassert_eq!(1, coord.size_hint().0);\n\t\tcoord.next().unwrap();\n\t\tassert_eq!(0, coord.size_hint().0);\n"]], "pred": {"ppl": 1.7211120128631592, "ppl_lower": 1.8411351442337036, "ppl/lowercase_ppl": -1.1241535111809553, "ppl/zlib": 0.0038783614359171946, "Min_5.0% Prob": 6.853737056255341, "Min_10.0% Prob": 4.600601054728031, "Min_20.0% Prob": 2.6512252164609507, "Min_30.0% Prob": 1.8066596485674382, "Min_40.0% Prob": 1.3583062250556341, "Min_50.0% Prob": 1.0853984503718537, "Min_60.0% Prob": 0.9120505564846099}}
{"hexsha": "276674de8f0bf6670a1a8b1aa87c6f32589ca474", "ext": "rs", "lang": "Rust", "content": "unsafe fn column_butterfly4(rows: [Self; 4], rotation: Rotation90<Self>) -> [Self; 4] {\n        // Algorithm: 2x2 mixed radix\n\n        // Perform the first set of size-2 FFTs.\n        let [mid0, mid2] = Self::column_butterfly2([rows[0], rows[2]]);\n        let [mid1, mid3] = Self::column_butterfly2([rows[1], rows[3]]);\n\n        // Apply twiddle factors (in this case just a rotation)\n        let mid3_rotated = mid3.rotate90(rotation);\n\n        // Transpose the data and do size-2 FFTs down the columns\n        let [output0, output1] = Self::column_butterfly2([mid0, mid1]);\n        let [output2, output3] = Self::column_butterfly2([mid2, mid3_rotated]);\n\n        // Swap outputs 1 and 2 in the output to do a square transpose\n        [output0, output2, output1, output3]\n    }", "item_id": 3, "repo": "ejmahler/RustFFT", "file": "src/avx/avx_vector.rs", "last_update_at": "2022-03-31T17:43:32+00:00", "question_id": "276674de8f0bf6670a1a8b1aa87c6f32589ca474_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe fn column_butterfly4(rows: [Self; 4], rotation: Rotation90<Self>) -> [Self; 4] {\n        // Algorithm: 2x2 mixed radix\n        // Perform the first set of size-2 FFTs.\n        let [mid0, mid2] = Self::column_butterfly2([rows[0], rows[2]]);\n        let [mid1, mid3] = Self::column_butterfly2([rows[1], rows[3]]);\n        // Apply twiddle factors (in this case just a rotation)\n        let mid3_rotated = mid3.rotate90(rotation);\n        // Transpose the data and do size-2 FFTs down the columns\n        let [output0, output1] = Self::column_butterfly2([mid0, mid1]);\n        let [output2, output3] = Self::column_butterfly2([mid2, mid3_rotated]);\n        // Swap outputs 1 and 2 in the output to do a square transpose\n        [output0, output2, output1, output3]\n"]], "pred": {"ppl": 3.3503353595733643, "ppl_lower": 3.7216176986694336, "ppl/lowercase_ppl": -1.086925340242637, "ppl/zlib": 0.00349439435884943, "Min_5.0% Prob": 8.433628522432768, "Min_10.0% Prob": 6.7579303704775295, "Min_20.0% Prob": 5.029567322641049, "Min_30.0% Prob": 3.802825289219618, "Min_40.0% Prob": 2.9712929410912166, "Min_50.0% Prob": 2.4110574149596156, "Min_60.0% Prob": 2.0167649604426408}}
{"hexsha": "d10d475b1655a45a2b954d59652a0646e298eae7", "ext": "rs", "lang": "Rust", "content": "pub fn serialize_structure_crate_model_rule_definition(\n    object: &mut aws_smithy_json::serialize::JsonObjectWriter,\n    input: &crate::model::RuleDefinition,\n) -> Result<(), aws_smithy_http::operation::SerializationError> {\n    if let Some(var_244) = &input.match_attributes {\n        let mut object_245 = object.key(\"MatchAttributes\").start_object();\n        crate::json_ser::serialize_structure_crate_model_match_attributes(\n            &mut object_245,\n            var_244,\n        )?;\n        object_245.finish();\n    }\n    if let Some(var_246) = &input.actions {\n        let mut array_247 = object.key(\"Actions\").start_array();\n        for item_248 in var_246 {\n            {\n                array_247.value().string(item_248);\n            }\n        }\n        array_247.finish();\n    }\n    Ok(())\n}", "item_id": 43, "repo": "ymwjbxxq/aws-sdk-rust", "file": "sdk/networkfirewall/src/json_ser.rs", "last_update_at": "2022-03-31T20:47:15+00:00", "question_id": "d10d475b1655a45a2b954d59652a0646e298eae7_43", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn serialize_structure_crate_model_rule_definition(\n    object: &mut aws_smithy_json::serialize::JsonObjectWriter,\n    input: &crate::model::RuleDefinition,\n) -> Result<(), aws_smithy_http::operation::SerializationError> {\n    if let Some(var_244) = &input.match_attributes {\n        let mut object_245 = object.key(\"MatchAttributes\").start_object();\n        crate::json_ser::serialize_structure_crate_model_match_attributes(\n            &mut object_245,\n            var_244,\n        )?;\n        object_245.finish();\n    }\n    if let Some(var_246) = &input.actions {\n        let mut array_247 = object.key(\"Actions\").start_array();\n        for item_248 in var_246 {\n            {\n                array_247.value().string(item_248);\n            }\n        }\n        array_247.finish();\n    }\n    Ok(())\n"]], "pred": {"ppl": 2.695540428161621, "ppl_lower": 3.3734707832336426, "ppl/lowercase_ppl": -1.2262441479416046, "ppl/zlib": 0.0027167088059934855, "Min_5.0% Prob": 8.816924095153809, "Min_10.0% Prob": 6.990336347509314, "Min_20.0% Prob": 4.624570301285496, "Min_30.0% Prob": 3.2657141468407196, "Min_40.0% Prob": 2.4838352045389236, "Min_50.0% Prob": 1.980449041201021, "Min_60.0% Prob": 1.6540322674872594}}
{"hexsha": "c9b11a0633a5a45923854be3614c69ebbf16afb9", "ext": "rs", "lang": "Rust", "content": "pub async fn get_entries(client: &Client, id: Uuid) -> Result<Vec<Entry>, Error> {\n    let mut url = Url::parse(\"https://splits.io/api/v4/races\").unwrap();\n    url.path_segments_mut().unwrap().extend(&[\n        id.to_hyphenated().encode_lower(&mut Uuid::encode_buffer()),\n        \"entries\",\n    ]);\n\n    let ContainsEntries { entries } = get_json(\n        client,\n        Request::get(url.as_str()).body(Body::empty()).unwrap(),\n    )\n    .await?;\n\n    Ok(entries)\n}", "item_id": 2, "repo": "LiveSplit/splits-io-api", "file": "src/race.rs", "last_update_at": "2022-03-30T22:29:51+00:00", "question_id": "c9b11a0633a5a45923854be3614c69ebbf16afb9_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn get_entries(client: &Client, id: Uuid) -> Result<Vec<Entry>, Error> {\n    let mut url = Url::parse(\"https://splits.io/api/v4/races\").unwrap();\n    url.path_segments_mut().unwrap().extend(&[\n        id.to_hyphenated().encode_lower(&mut Uuid::encode_buffer()),\n        \"entries\",\n    ]);\n    let ContainsEntries { entries } = get_json(\n        client,\n        Request::get(url.as_str()).body(Body::empty()).unwrap(),\n    )\n    .await?;\n    Ok(entries)\n"]], "pred": {"ppl": 2.488513708114624, "ppl_lower": 3.833789348602295, "ppl/lowercase_ppl": -1.4740319020339927, "ppl/zlib": 0.0029989658812060583, "Min_5.0% Prob": 8.27649438381195, "Min_10.0% Prob": 5.7854921370744705, "Min_20.0% Prob": 3.8161763921380043, "Min_30.0% Prob": 2.8263647903998694, "Min_40.0% Prob": 2.2094311884138733, "Min_50.0% Prob": 1.7998338676989079, "Min_60.0% Prob": 1.5114080428611487}}
{"hexsha": "8ad7974280f098044fedb63f95afe1b6be71ef86", "ext": "rs", "lang": "Rust", "content": "async fn prune_date64() {\n    // work around for not being able to cast Date32 to Date64 automatically\n    let date = \"2020-01-02\"\n        .parse::<chrono::NaiveDate>()\n        .unwrap()\n        .and_time(chrono::NaiveTime::from_hms(0, 0, 0));\n    let date = ScalarValue::Date64(Some(date.timestamp_millis()));\n\n    let output = ContextWithParquet::new(Scenario::Dates)\n        .await\n        .query_with_expr(col(\"date64\").lt(lit(date)))\n        // .query(\n        //     \"SELECT * FROM t where date64 < caste('2020-01-02' as date)\",\n        // query results in Plan(\"'Date64 < Date32' can't be evaluated because there isn't a common type to coerce the types to\")\n        // )\n        .await;\n\n    println!(\"{}\", output.description());\n    // This should prune out groups  without error\n    assert_eq!(output.predicate_evaluation_errors(), Some(0));\n    assert_eq!(output.row_groups_pruned(), Some(3));\n    assert_eq!(output.result_rows, 1, \"{}\", output.description());\n}", "item_id": 5, "repo": "McPatate/tensorbase", "file": "crates/datafusion/tests/parquet_pruning.rs", "last_update_at": "2022-03-31T14:54:44+00:00", "question_id": "8ad7974280f098044fedb63f95afe1b6be71ef86_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn prune_date64() {\n    // work around for not being able to cast Date32 to Date64 automatically\n    let date = \"2020-01-02\"\n        .parse::<chrono::NaiveDate>()\n        .unwrap()\n        .and_time(chrono::NaiveTime::from_hms(0, 0, 0));\n    let date = ScalarValue::Date64(Some(date.timestamp_millis()));\n    let output = ContextWithParquet::new(Scenario::Dates)\n        .await\n        .query_with_expr(col(\"date64\").lt(lit(date)))\n        // .query(\n        //     \"SELECT * FROM t where date64 < caste('2020-01-02' as date)\",\n        // query results in Plan(\"'Date64 < Date32' can't be evaluated because there isn't a common type to coerce the types to\")\n        // )\n        .await;\n    println!(\"{}\", output.description());\n    // This should prune out groups  without error\n    assert_eq!(output.predicate_evaluation_errors(), Some(0));\n    assert_eq!(output.row_groups_pruned(), Some(3));\n    assert_eq!(output.result_rows, 1, \"{}\", output.description());\n"]], "pred": {"ppl": 4.200281620025635, "ppl_lower": 5.313050746917725, "ppl/lowercase_ppl": -1.1637559596355402, "ppl/zlib": 0.002808515803186825, "Min_5.0% Prob": 10.145938515663147, "Min_10.0% Prob": 8.165345400571823, "Min_20.0% Prob": 5.79049229988685, "Min_30.0% Prob": 4.368294757239672, "Min_40.0% Prob": 3.462290422607014, "Min_50.0% Prob": 2.8392735507066655, "Min_60.0% Prob": 2.388356139476832}}
{"hexsha": "b427f5acc2095b74427d52bdb7f6e9c423048f00", "ext": "rs", "lang": "Rust", "content": "pub fn derive_elm_json(input: TokenStream) -> TokenStream {\n    let derive_input = parse_macro_input!(input as DeriveInput);\n    let intermediate = match super::derive_input_to_intermediate(derive_input) {\n        Ok(intermediate) => intermediate,\n        Err(err) => return err.to_compile_error().into(),\n    };\n    let token_stream = match intermediate_to_token_stream(intermediate) {\n        Ok(token_stream) => token_stream,\n        Err(err) => return err.to_compile_error().into(),\n    };\n    TokenStream::from(token_stream)\n}", "item_id": 0, "repo": "Heliozoa/jalava", "file": "jalava-derive/src/json.rs", "last_update_at": "2022-01-23T04:19:45+00:00", "question_id": "b427f5acc2095b74427d52bdb7f6e9c423048f00_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn derive_elm_json(input: TokenStream) -> TokenStream {\n    let derive_input = parse_macro_input!(input as DeriveInput);\n    let intermediate = match super::derive_input_to_intermediate(derive_input) {\n        Ok(intermediate) => intermediate,\n        Err(err) => return err.to_compile_error().into(),\n    };\n    let token_stream = match intermediate_to_token_stream(intermediate) {\n        Ok(token_stream) => token_stream,\n        Err(err) => return err.to_compile_error().into(),\n    };\n    TokenStream::from(token_stream)\n"]], "pred": {"ppl": 1.9569056034088135, "ppl_lower": 2.639747381210327, "ppl/lowercase_ppl": -1.4458364914982353, "ppl/zlib": 0.002997162731673372, "Min_5.0% Prob": 8.761181422642299, "Min_10.0% Prob": 5.783470535278321, "Min_20.0% Prob": 3.2528115578236116, "Min_30.0% Prob": 2.227399686232526, "Min_40.0% Prob": 1.6791796618333412, "Min_50.0% Prob": 1.3417233126768489, "Min_60.0% Prob": 1.1281343861210575}}
{"hexsha": "f8edc3625e0ab079ee306a10a74bde260643695c", "ext": "rs", "lang": "Rust", "content": "fn number_of_digits_decimal_left_shift(d: &Decimal, mut shift: usize) -> usize {\n    #[rustfmt::skip]\n    const TABLE: [u16; 65] = [\n        0x0000, 0x0800, 0x0801, 0x0803, 0x1006, 0x1009, 0x100D, 0x1812, 0x1817, 0x181D, 0x2024,\n        0x202B, 0x2033, 0x203C, 0x2846, 0x2850, 0x285B, 0x3067, 0x3073, 0x3080, 0x388E, 0x389C,\n        0x38AB, 0x38BB, 0x40CC, 0x40DD, 0x40EF, 0x4902, 0x4915, 0x4929, 0x513E, 0x5153, 0x5169,\n        0x5180, 0x5998, 0x59B0, 0x59C9, 0x61E3, 0x61FD, 0x6218, 0x6A34, 0x6A50, 0x6A6D, 0x6A8B,\n        0x72AA, 0x72C9, 0x72E9, 0x7B0A, 0x7B2B, 0x7B4D, 0x8370, 0x8393, 0x83B7, 0x83DC, 0x8C02,\n        0x8C28, 0x8C4F, 0x9477, 0x949F, 0x94C8, 0x9CF2, 0x051C, 0x051C, 0x051C, 0x051C,\n    ];\n    #[rustfmt::skip]\n    const TABLE_POW5: [u8; 0x051C] = [\n        5, 2, 5, 1, 2, 5, 6, 2, 5, 3, 1, 2, 5, 1, 5, 6, 2, 5, 7, 8, 1, 2, 5, 3, 9, 0, 6, 2, 5, 1,\n        9, 5, 3, 1, 2, 5, 9, 7, 6, 5, 6, 2, 5, 4, 8, 8, 2, 8, 1, 2, 5, 2, 4, 4, 1, 4, 0, 6, 2, 5,\n        1, 2, 2, 0, 7, 0, 3, 1, 2, 5, 6, 1, 0, 3, 5, 1, 5, 6, 2, 5, 3, 0, 5, 1, 7, 5, 7, 8, 1, 2,\n        5, 1, 5, 2, 5, 8, 7, 8, 9, 0, 6, 2, 5, 7, 6, 2, 9, 3, 9, 4, 5, 3, 1, 2, 5, 3, 8, 1, 4, 6,\n        9, 7, 2, 6, 5, 6, 2, 5, 1, 9, 0, 7, 3, 4, 8, 6, 3, 2, 8, 1, 2, 5, 9, 5, 3, 6, 7, 4, 3, 1,\n        6, 4, 0, 6, 2, 5, 4, 7, 6, 8, 3, 7, 1, 5, 8, 2, 0, 3, 1, 2, 5, 2, 3, 8, 4, 1, 8, 5, 7, 9,\n        1, 0, 1, 5, 6, 2, 5, 1, 1, 9, 2, 0, 9, 2, 8, 9, 5, 5, 0, 7, 8, 1, 2, 5, 5, 9, 6, 0, 4, 6,\n        4, 4, 7, 7, 5, 3, 9, 0, 6, 2, 5, 2, 9, 8, 0, 2, 3, 2, 2, 3, 8, 7, 6, 9, 5, 3, 1, 2, 5, 1,\n        4, 9, 0, 1, 1, 6, 1, 1, 9, 3, 8, 4, 7, 6, 5, 6, 2, 5, 7, 4, 5, 0, 5, 8, 0, 5, 9, 6, 9, 2,\n        3, 8, 2, 8, 1, 2, 5, 3, 7, 2, 5, 2, 9, 0, 2, 9, 8, 4, 6, 1, 9, 1, 4, 0, 6, 2, 5, 1, 8, 6,\n        2, 6, 4, 5, 1, 4, 9, 2, 3, 0, 9, 5, 7, 0, 3, 1, 2, 5, 9, 3, 1, 3, 2, 2, 5, 7, 4, 6, 1, 5,\n        4, 7, 8, 5, 1, 5, 6, 2, 5, 4, 6, 5, 6, 6, 1, 2, 8, 7, 3, 0, 7, 7, 3, 9, 2, 5, 7, 8, 1, 2,\n        5, 2, 3, 2, 8, 3, 0, 6, 4, 3, 6, 5, 3, 8, 6, 9, 6, 2, 8, 9, 0, 6, 2, 5, 1, 1, 6, 4, 1, 5,\n        3, 2, 1, 8, 2, 6, 9, 3, 4, 8, 1, 4, 4, 5, 3, 1, 2, 5, 5, 8, 2, 0, 7, 6, 6, 0, 9, 1, 3, 4,\n        6, 7, 4, 0, 7, 2, 2, 6, 5, 6, 2, 5, 2, 9, 1, 0, 3, 8, 3, 0, 4, 5, 6, 7, 3, 3, 7, 0, 3, 6,\n        1, 3, 2, 8, 1, 2, 5, 1, 4, 5, 5, 1, 9, 1, 5, 2, 2, 8, 3, 6, 6, 8, 5, 1, 8, 0, 6, 6, 4, 0,\n        6, 2, 5, 7, 2, 7, 5, 9, 5, 7, 6, 1, 4, 1, 8, 3, 4, 2, 5, 9, 0, 3, 3, 2, 0, 3, 1, 2, 5, 3,\n        6, 3, 7, 9, 7, 8, 8, 0, 7, 0, 9, 1, 7, 1, 2, 9, 5, 1, 6, 6, 0, 1, 5, 6, 2, 5, 1, 8, 1, 8,\n        9, 8, 9, 4, 0, 3, 5, 4, 5, 8, 5, 6, 4, 7, 5, 8, 3, 0, 0, 7, 8, 1, 2, 5, 9, 0, 9, 4, 9, 4,\n        7, 0, 1, 7, 7, 2, 9, 2, 8, 2, 3, 7, 9, 1, 5, 0, 3, 9, 0, 6, 2, 5, 4, 5, 4, 7, 4, 7, 3, 5,\n        0, 8, 8, 6, 4, 6, 4, 1, 1, 8, 9, 5, 7, 5, 1, 9, 5, 3, 1, 2, 5, 2, 2, 7, 3, 7, 3, 6, 7, 5,\n        4, 4, 3, 2, 3, 2, 0, 5, 9, 4, 7, 8, 7, 5, 9, 7, 6, 5, 6, 2, 5, 1, 1, 3, 6, 8, 6, 8, 3, 7,\n        7, 2, 1, 6, 1, 6, 0, 2, 9, 7, 3, 9, 3, 7, 9, 8, 8, 2, 8, 1, 2, 5, 5, 6, 8, 4, 3, 4, 1, 8,\n        8, 6, 0, 8, 0, 8, 0, 1, 4, 8, 6, 9, 6, 8, 9, 9, 4, 1, 4, 0, 6, 2, 5, 2, 8, 4, 2, 1, 7, 0,\n        9, 4, 3, 0, 4, 0, 4, 0, 0, 7, 4, 3, 4, 8, 4, 4, 9, 7, 0, 7, 0, 3, 1, 2, 5, 1, 4, 2, 1, 0,\n        8, 5, 4, 7, 1, 5, 2, 0, 2, 0, 0, 3, 7, 1, 7, 4, 2, 2, 4, 8, 5, 3, 5, 1, 5, 6, 2, 5, 7, 1,\n        0, 5, 4, 2, 7, 3, 5, 7, 6, 0, 1, 0, 0, 1, 8, 5, 8, 7, 1, 1, 2, 4, 2, 6, 7, 5, 7, 8, 1, 2,\n        5, 3, 5, 5, 2, 7, 1, 3, 6, 7, 8, 8, 0, 0, 5, 0, 0, 9, 2, 9, 3, 5, 5, 6, 2, 1, 3, 3, 7, 8,\n        9, 0, 6, 2, 5, 1, 7, 7, 6, 3, 5, 6, 8, 3, 9, 4, 0, 0, 2, 5, 0, 4, 6, 4, 6, 7, 7, 8, 1, 0,\n        6, 6, 8, 9, 4, 5, 3, 1, 2, 5, 8, 8, 8, 1, 7, 8, 4, 1, 9, 7, 0, 0, 1, 2, 5, 2, 3, 2, 3, 3,\n        8, 9, 0, 5, 3, 3, 4, 4, 7, 2, 6, 5, 6, 2, 5, 4, 4, 4, 0, 8, 9, 2, 0, 9, 8, 5, 0, 0, 6, 2,\n        6, 1, 6, 1, 6, 9, 4, 5, 2, 6, 6, 7, 2, 3, 6, 3, 2, 8, 1, 2, 5, 2, 2, 2, 0, 4, 4, 6, 0, 4,\n        9, 2, 5, 0, 3, 1, 3, 0, 8, 0, 8, 4, 7, 2, 6, 3, 3, 3, 6, 1, 8, 1, 6, 4, 0, 6, 2, 5, 1, 1,\n        1, 0, 2, 2, 3, 0, 2, 4, 6, 2, 5, 1, 5, 6, 5, 4, 0, 4, 2, 3, 6, 3, 1, 6, 6, 8, 0, 9, 0, 8,\n        2, 0, 3, 1, 2, 5, 5, 5, 5, 1, 1, 1, 5, 1, 2, 3, 1, 2, 5, 7, 8, 2, 7, 0, 2, 1, 1, 8, 1, 5,\n        8, 3, 4, 0, 4, 5, 4, 1, 0, 1, 5, 6, 2, 5, 2, 7, 7, 5, 5, 5, 7, 5, 6, 1, 5, 6, 2, 8, 9, 1,\n        3, 5, 1, 0, 5, 9, 0, 7, 9, 1, 7, 0, 2, 2, 7, 0, 5, 0, 7, 8, 1, 2, 5, 1, 3, 8, 7, 7, 7, 8,\n        7, 8, 0, 7, 8, 1, 4, 4, 5, 6, 7, 5, 5, 2, 9, 5, 3, 9, 5, 8, 5, 1, 1, 3, 5, 2, 5, 3, 9, 0,\n        6, 2, 5, 6, 9, 3, 8, 8, 9, 3, 9, 0, 3, 9, 0, 7, 2, 2, 8, 3, 7, 7, 6, 4, 7, 6, 9, 7, 9, 2,\n        5, 5, 6, 7, 6, 2, 6, 9, 5, 3, 1, 2, 5, 3, 4, 6, 9, 4, 4, 6, 9, 5, 1, 9, 5, 3, 6, 1, 4, 1,\n        8, 8, 8, 2, 3, 8, 4, 8, 9, 6, 2, 7, 8, 3, 8, 1, 3, 4, 7, 6, 5, 6, 2, 5, 1, 7, 3, 4, 7, 2,\n        3, 4, 7, 5, 9, 7, 6, 8, 0, 7, 0, 9, 4, 4, 1, 1, 9, 2, 4, 4, 8, 1, 3, 9, 1, 9, 0, 6, 7, 3,\n        8, 2, 8, 1, 2, 5, 8, 6, 7, 3, 6, 1, 7, 3, 7, 9, 8, 8, 4, 0, 3, 5, 4, 7, 2, 0, 5, 9, 6, 2,\n        2, 4, 0, 6, 9, 5, 9, 5, 3, 3, 6, 9, 1, 4, 0, 6, 2, 5,\n    ];\n\n    shift &= 63;\n    let x_a = TABLE[shift];\n    let x_b = TABLE[shift + 1];\n    let num_new_digits = (x_a >> 11) as _;\n    let pow5_a = (0x7FF & x_a) as usize;\n    let pow5_b = (0x7FF & x_b) as usize;\n    let pow5 = &TABLE_POW5[pow5_a..];\n    for (i, &p5) in pow5.iter().enumerate().take(pow5_b - pow5_a) {\n        if i >= d.num_digits {\n            return num_new_digits - 1;\n        } else if d.digits[i] == p5 {\n            continue;\n        } else if d.digits[i] < p5 {\n            return num_new_digits - 1;\n        } else {\n            return num_new_digits;\n        }\n    }\n    num_new_digits\n}", "item_id": 1, "repo": "mbc-git/rust", "file": "library/core/src/num/dec2flt/decimal.rs", "last_update_at": "2022-03-31T23:26:40+00:00", "question_id": "f8edc3625e0ab079ee306a10a74bde260643695c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn number_of_digits_decimal_left_shift(d: &Decimal, mut shift: usize) -> usize {\n    #[rustfmt::skip]\n    const TABLE: [u16; 65] = [\n        0x0000, 0x0800, 0x0801, 0x0803, 0x1006, 0x1009, 0x100D, 0x1812, 0x1817, 0x181D, 0x2024,\n        0x202B, 0x2033, 0x203C, 0x2846, 0x2850, 0x285B, 0x3067, 0x3073, 0x3080, 0x388E, 0x389C,\n        0x38AB, 0x38BB, 0x40CC, 0x40DD, 0x40EF, 0x4902, 0x4915, 0x4929, 0x513E, 0x5153, 0x5169,\n        0x5180, 0x5998, 0x59B0, 0x59C9, 0x61E3, 0x61FD, 0x6218, 0x6A34, 0x6A50, 0x6A6D, 0x6A8B,\n        0x72AA, 0x72C9, 0x72E9, 0x7B0A, 0x7B2B, 0x7B4D, 0x8370, 0x8393, 0x83B7, 0x83DC, 0x8C02,\n        0x8C28, 0x8C4F, 0x9477, 0x949F, 0x94C8, 0x9CF2, 0x051C, 0x051C, 0x051C, 0x051C,\n    ];\n    #[rustfmt::skip]\n    const TABLE_POW5: [u8; 0x051C] = [\n        5, 2, 5, 1, 2, 5, 6, 2, 5, 3, 1, 2, 5, 1, 5, 6, 2, 5, 7, 8, 1, 2, 5, 3, 9, 0, 6, 2, 5, 1,\n        9, 5, 3, 1, 2, 5, 9, 7, 6, 5, 6, 2, 5, 4, 8, 8, 2, 8, 1, 2, 5, 2, 4, 4, 1, 4, 0, 6, 2, 5,\n        1, 2, 2, 0, 7, 0, 3, 1, 2, 5, 6, 1, 0, 3, 5, 1, 5, 6, 2, 5, 3, 0, 5, 1, 7, 5, 7, 8, 1, 2,\n        5, 1, 5, 2, 5, 8, 7, 8, 9, 0, 6, 2, 5, 7, 6, 2, 9, 3, 9, 4, 5, 3, 1, 2, 5, 3, 8, 1, 4, 6,\n        9, 7, 2, 6, 5, 6, 2, 5, 1, 9, 0, 7, 3, 4, 8, 6, 3, 2, 8, 1, 2, 5, 9, 5, 3, 6, 7, 4, 3, 1,\n        6, 4, 0, 6, 2, 5, 4, 7, 6, 8, 3, 7, 1, 5, 8, 2, 0, 3, 1, 2, 5, 2, 3, 8, 4, 1, 8, 5, 7, 9,\n        1, 0, 1, 5, 6, 2, 5, 1, 1, 9, 2, 0, 9, 2, 8, 9, 5, 5, 0, 7, 8, 1, 2, 5, 5, 9, 6, 0, 4, 6,\n        4, 4, 7, 7, 5, 3, 9, 0, 6, 2, 5, 2, 9, 8, 0, 2, 3, 2, 2, 3, 8, 7, 6, 9, 5, 3, 1, 2, 5, 1,\n        4, 9, 0, 1, 1, 6, 1, 1, 9, 3, 8, 4, 7, 6, 5, 6, 2, 5, 7, 4, 5, 0, 5, 8, 0, 5, 9, 6, 9, 2,\n        3, 8, 2, 8, 1, 2, 5, 3, 7, 2, 5, 2, 9, 0, 2, 9, 8, 4, 6, 1, 9, 1, 4, 0, 6, 2, 5, 1, 8, 6,\n        2, 6, 4, 5, 1, 4, 9, 2, 3, 0, 9, 5, 7, 0, 3, 1, 2, 5, 9, 3, 1, 3, 2, 2, 5, 7, 4, 6, 1, 5,\n        4, 7, 8, 5, 1, 5, 6, 2, 5, 4, 6, 5, 6, 6, 1, 2, 8, 7, 3, 0, 7, 7, 3, 9, 2, 5, 7, 8, 1, 2,\n        5, 2, 3, 2, 8, 3, 0, 6, 4, 3, 6, 5, 3, 8, 6, 9, 6, 2, 8, 9, 0, 6, 2, 5, 1, 1, 6, 4, 1, 5,\n        3, 2, 1, 8, 2, 6, 9, 3, 4, 8, 1, 4, 4, 5, 3, 1, 2, 5, 5, 8, 2, 0, 7, 6, 6, 0, 9, 1, 3, 4,\n        6, 7, 4, 0, 7, 2, 2, 6, 5, 6, 2, 5, 2, 9, 1, 0, 3, 8, 3, 0, 4, 5, 6, 7, 3, 3, 7, 0, 3, 6,\n        1, 3, 2, 8, 1, 2, 5, 1, 4, 5, 5, 1, 9, 1, 5, 2, 2, 8, 3, 6, 6, 8, 5, 1, 8, 0, 6, 6, 4, 0,\n        6, 2, 5, 7, 2, 7, 5, 9, 5, 7, 6, 1, 4, 1, 8, 3, 4, 2, 5, 9, 0, 3, 3, 2, 0, 3, 1, 2, 5, 3,\n        6, 3, 7, 9, 7, 8, 8, 0, 7, 0, 9, 1, 7, 1, 2, 9, 5, 1, 6, 6, 0, 1, 5, 6, 2, 5, 1, 8, 1, 8,\n        9, 8, 9, 4, 0, 3, 5, 4, 5, 8, 5, 6, 4, 7, 5, 8, 3, 0, 0, 7, 8, 1, 2, 5, 9, 0, 9, 4, 9, 4,\n        7, 0, 1, 7, 7, 2, 9, 2, 8, 2, 3, 7, 9, 1, 5, 0, 3, 9, 0, 6, 2, 5, 4, 5, 4, 7, 4, 7, 3, 5,\n        0, 8, 8, 6, 4, 6, 4, 1, 1, 8, 9, 5, 7, 5, 1, 9, 5, 3, 1, 2, 5, 2, 2, 7, 3, 7, 3, 6, 7, 5,\n        4, 4, 3, 2, 3, 2, 0, 5, 9, 4, 7, 8, 7, 5, 9, 7, 6, 5, 6, 2, 5, 1, 1, 3, 6, 8, 6, 8, 3, 7,\n        7, 2, 1, 6, 1, 6, 0, 2, 9, 7, 3, 9, 3, 7, 9, 8, 8, 2, 8, 1, 2, 5, 5, 6, 8, 4, 3, 4, 1, 8,\n        8, 6, 0, 8, 0, 8, 0, 1, 4, 8, 6, 9, 6, 8, 9, 9, 4, 1, 4, 0, 6, 2, 5, 2, 8, 4, 2, 1, 7, 0,\n        9, 4, 3, 0, 4, 0, 4, 0, 0, 7, 4, 3, 4, 8, 4, 4, 9, 7, 0, 7, 0, 3, 1, 2, 5, 1, 4, 2, 1, 0,\n        8, 5, 4, 7, 1, 5, 2, 0, 2, 0, 0, 3, 7, 1, 7, 4, 2, 2, 4, 8, 5, 3, 5, 1, 5, 6, 2, 5, 7, 1,\n        0, 5, 4, 2, 7, 3, 5, 7, 6, 0, 1, 0, 0, 1, 8, 5, 8, 7, 1, 1, 2, 4, 2, 6, 7, 5, 7, 8, 1, 2,\n        5, 3, 5, 5, 2, 7, 1, 3, 6, 7, 8, 8, 0, 0, 5, 0, 0, 9, 2, 9, 3, 5, 5, 6, 2, 1, 3, 3, 7, 8,\n        9, 0, 6, 2, 5, 1, 7, 7, 6, 3, 5, 6, 8, 3, 9, 4, 0, 0, 2, 5, 0, 4, 6, 4, 6, 7, 7, 8, 1, 0,\n        6, 6, 8, 9, 4, 5, 3, 1, 2, 5, 8, 8, 8, 1, 7, 8, 4, 1, 9, 7, 0, 0, 1, 2, 5, 2, 3, 2, 3, 3,\n        8, 9, 0, 5, 3, 3, 4, 4, 7, 2, 6, 5, 6, 2, 5, 4, 4, 4, 0, 8, 9, 2, 0, 9, 8, 5, 0, 0, 6, 2,\n        6, 1, 6, 1, 6, 9, 4, 5, 2, 6, 6, 7, 2, 3, 6, 3, 2, 8, 1, 2, 5, 2, 2, 2, 0, 4, 4, 6, 0, 4,\n        9, 2, 5, 0, 3, 1, 3, 0, 8, 0, 8, 4, 7, 2, 6, 3, 3, 3, 6, 1, 8, 1, 6, 4, 0, 6, 2, 5, 1, 1,\n        1, 0, 2, 2, 3, 0, 2, 4, 6, 2, 5, 1, 5, 6, 5, 4, 0, 4, 2, 3, 6, 3, 1, 6, 6, 8, 0, 9, 0, 8,\n        2, 0, 3, 1, 2, 5, 5, 5, 5, 1, 1, 1, 5, 1, 2, 3, 1, 2, 5, 7, 8, 2, 7, 0, 2, 1, 1, 8, 1, 5,\n        8, 3, 4, 0, 4, 5, 4, 1, 0, 1, 5, 6, 2, 5, 2, 7, 7, 5, 5, 5, 7, 5, 6, 1, 5, 6, 2, 8, 9, 1,\n        3, 5, 1, 0, 5, 9, 0, 7, 9, 1, 7, 0, 2, 2, 7, 0, 5, 0, 7, 8, 1, 2, 5, 1, 3, 8, 7, 7, 7, 8,\n        7, 8, 0, 7, 8, 1, 4, 4, 5, 6, 7, 5, 5, 2, 9, 5, 3, 9, 5, 8, 5, 1, 1, 3, 5, 2, 5, 3, 9, 0,\n        6, 2, 5, 6, 9, 3, 8, 8, 9, 3, 9, 0, 3, 9, 0, 7, 2, 2, 8, 3, 7, 7, 6, 4, 7, 6, 9, 7, 9, 2,\n        5, 5, 6, 7, 6, 2, 6, 9, 5, 3, 1, 2, 5, 3, 4, 6, 9, 4, 4, 6, 9, 5, 1, 9, 5, 3, 6, 1, 4, 1,\n        8, 8, 8, 2, 3, 8, 4, 8, 9, 6, 2, 7, 8, 3, 8, 1, 3, 4, 7, 6, 5, 6, 2, 5, 1, 7, 3, 4, 7, 2,\n        3, 4, 7, 5, 9, 7, 6, 8, 0, 7, 0, 9, 4, 4, 1, 1, 9, 2, 4, 4, 8, 1, 3, 9, 1, 9, 0, 6, 7, 3,\n        8, 2, 8, 1, 2, 5, 8, 6, 7, 3, 6, 1, 7, 3, 7, 9, 8, 8, 4, 0, 3, 5, 4, 7, 2, 0, 5, 9, 6, 2,\n        2, 4, 0, 6, 9, 5, 9, 5, 3, 3, 6, 9, 1, 4, 0, 6, 2, 5,\n    ];\n    shift &= 63;\n    let x_a = TABLE[shift];\n    let x_b = TABLE[shift + 1];\n    let num_new_digits = (x_a >> 11) as _;\n    let pow5_a = (0x7FF & x_a) as usize;\n    let pow5_b = (0x7FF & x_b) as usize;\n    let pow5 = &TABLE_POW5[pow5_a..];\n    for (i, &p5) in pow5.iter().enumerate().take(pow5_b - pow5_a) {\n        if i >= d.num_digits {\n            return num_new_digits - 1;\n        } else if d.digits[i] == p5 {\n            continue;\n        } else if d.digits[i] < p5 {\n            return num_new_digits - 1;\n        } else {\n            return num_new_digits;\n        }\n    }\n    num_new_digits\n"]], "pred": {"ppl": 1.8678747415542603, "ppl_lower": 1.877278208732605, "ppl/lowercase_ppl": -1.0080372494958185, "ppl/zlib": 0.0004044021247352112, "Min_5.0% Prob": 4.420833755941952, "Min_10.0% Prob": 3.559785894319123, "Min_20.0% Prob": 2.736491814547894, "Min_30.0% Prob": 2.0433275981568824, "Min_40.0% Prob": 1.5566477861009484, "Min_50.0% Prob": 1.2497422424374685, "Min_60.0% Prob": 1.042391290201093}}
{"hexsha": "17f72486ca10ac010214ad07b7dbe96fa067c1f9", "ext": "rs", "lang": "Rust", "content": "fn hit_vector(c: &mut Criterion) {\n    let mut s = Sphere {\n        center: V3D {\n            x: 0.,\n            y: 0.,\n            z: 10.,\n        },\n        radius: 1.,\n    };\n    let mut r = RayxN {\n        origin: V3DxN {\n            x: f32xN::splat(0.),\n            y: f32xN::splat(0.),\n            z: f32xN::splat(0.),\n        },\n        dir: V3DxN {\n            x: f32xN::splat(0.),\n            y: f32xN::splat(0.),\n            z: f32xN::splat(1.),\n        },\n    };\n\n    c.bench(\n        \"vector\",\n        Benchmark::new(\"isec_sphere_hit\", move |b| {\n            b.iter(|| {\n                let mut isect = IsectxN::default();\n                let isect = black_box(&mut isect);\n                let s = black_box(&mut s);\n                let r = black_box(&mut r);\n                let mut v = r.intersect(s, *isect);\n                black_box(&mut v);\n                assert_eq!(v.hit.all(), true);\n            })\n        })\n        .throughput(Throughput::Elements(f32xN::lanes() as u64)),\n    );\n}", "item_id": 2, "repo": "eclipseo/packed_simd", "file": "examples/aobench/benches/isec_sphere.rs", "last_update_at": "2022-03-08T03:12:55+00:00", "question_id": "17f72486ca10ac010214ad07b7dbe96fa067c1f9_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn hit_vector(c: &mut Criterion) {\n    let mut s = Sphere {\n        center: V3D {\n            x: 0.,\n            y: 0.,\n            z: 10.,\n        },\n        radius: 1.,\n    };\n    let mut r = RayxN {\n        origin: V3DxN {\n            x: f32xN::splat(0.),\n            y: f32xN::splat(0.),\n            z: f32xN::splat(0.),\n        },\n        dir: V3DxN {\n            x: f32xN::splat(0.),\n            y: f32xN::splat(0.),\n            z: f32xN::splat(1.),\n        },\n    };\n    c.bench(\n        \"vector\",\n        Benchmark::new(\"isec_sphere_hit\", move |b| {\n            b.iter(|| {\n                let mut isect = IsectxN::default();\n                let isect = black_box(&mut isect);\n                let s = black_box(&mut s);\n                let r = black_box(&mut r);\n                let mut v = r.intersect(s, *isect);\n                black_box(&mut v);\n                assert_eq!(v.hit.all(), true);\n            })\n        })\n        .throughput(Throughput::Elements(f32xN::lanes() as u64)),\n    );\n"]], "pred": {"ppl": 1.9528136253356934, "ppl_lower": 2.2795398235321045, "ppl/lowercase_ppl": -1.231150495319415, "ppl/zlib": 0.0018437223619977273, "Min_5.0% Prob": 6.660627206166585, "Min_10.0% Prob": 4.823378655645582, "Min_20.0% Prob": 3.064204346643735, "Min_30.0% Prob": 2.1831836742818904, "Min_40.0% Prob": 1.6637404757513576, "Min_50.0% Prob": 1.3352530917631147, "Min_60.0% Prob": 1.1177925515630747}}
{"hexsha": "af3157c216065e2b895e47c3b7579a5743310777", "ext": "rs", "lang": "Rust", "content": "pub fn get_engine() -> Handlebars<'static> {\n    let mut h = Handlebars::new();\n    let _ = h.register_partial(\"compiled_from\", PART_COMPILED_FROM);\n    let _ = h.register_partial(\"sys_info\", PART_SYS_INFO);\n    let _ = h.register_partial(\"fields\", PART_FIELDS);\n    let _ = h.register_partial(\"methods\", PART_METHODS);\n    let _ = h.register_partial(\"constant_pool\", PART_CP);\n    // let _ = h.register_partial(\"stack_map_table\", PART_STACK_MAP_TABLE);\n    h.register_escape_fn(handlebars::no_escape);\n\n    h\n}", "item_id": 0, "repo": "fujinjun/jvm", "file": "tools/javap/src/template.rs", "last_update_at": "2022-03-30T05:33:33+00:00", "question_id": "af3157c216065e2b895e47c3b7579a5743310777_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_engine() -> Handlebars<'static> {\n    let mut h = Handlebars::new();\n    let _ = h.register_partial(\"compiled_from\", PART_COMPILED_FROM);\n    let _ = h.register_partial(\"sys_info\", PART_SYS_INFO);\n    let _ = h.register_partial(\"fields\", PART_FIELDS);\n    let _ = h.register_partial(\"methods\", PART_METHODS);\n    let _ = h.register_partial(\"constant_pool\", PART_CP);\n    // let _ = h.register_partial(\"stack_map_table\", PART_STACK_MAP_TABLE);\n    h.register_escape_fn(handlebars::no_escape);\n    h\n"]], "pred": {"ppl": 2.3509013652801514, "ppl_lower": 2.7716026306152344, "ppl/lowercase_ppl": -1.1925914061151774, "ppl/zlib": 0.003474791928087536, "Min_5.0% Prob": 8.228504021962484, "Min_10.0% Prob": 6.3231946097479925, "Min_20.0% Prob": 3.9598239531388155, "Min_30.0% Prob": 2.816988733952696, "Min_40.0% Prob": 2.128004795896846, "Min_50.0% Prob": 1.7029483185740568, "Min_60.0% Prob": 1.4303965583812814}}
{"hexsha": "756f72b7d8b65f496211cb0e6494d633662db033", "ext": "rs", "lang": "Rust", "content": "fn tokenize_test(input: &str, expected: &str) {\n    let (tokens, mut diagnostics) = tokenize(input);\n    diagnostics.retain(|d| d != &Diagnostic::Valid);\n    assert_eq!(diagnostics.as_slice(), []);\n\n    let got = format!(\"{:#?}\", tokens);\n    assert_eq!(got.as_str(), expected);\n}", "item_id": 0, "repo": "adam-mcdaniel/dune", "file": "src/tests/mod.rs", "last_update_at": "2022-03-30T16:33:46+00:00", "question_id": "756f72b7d8b65f496211cb0e6494d633662db033_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn tokenize_test(input: &str, expected: &str) {\n    let (tokens, mut diagnostics) = tokenize(input);\n    diagnostics.retain(|d| d != &Diagnostic::Valid);\n    assert_eq!(diagnostics.as_slice(), []);\n    let got = format!(\"{:#?}\", tokens);\n    assert_eq!(got.as_str(), expected);\n"]], "pred": {"ppl": 2.8232979774475098, "ppl_lower": 3.093388795852661, "ppl/lowercase_ppl": -1.0880248472866132, "ppl/zlib": 0.005830930882986397, "Min_5.0% Prob": 8.026068925857544, "Min_10.0% Prob": 6.3427611456976996, "Min_20.0% Prob": 4.359846993496544, "Min_30.0% Prob": 3.169394752074932, "Min_40.0% Prob": 2.528917860827948, "Min_50.0% Prob": 2.055267653738459, "Min_60.0% Prob": 1.7203678000589897}}
{"hexsha": "c24144e0b86940dbe3c939b11504b3223ce1d429", "ext": "rs", "lang": "Rust", "content": "pub fn setup(hull_opts: &Config) -> Result<(), io::Error> {\n    let dir = &hull_opts.posts.output;\n    let path = Path::new(dir);\n\n    if path.exists() {\n        fs::remove_dir_all(path).expect(\"Hull: failed to remove posts output\");\n        println!(\"Hull: removed {:#?}\", path);\n    }\n\n    fs::create_dir(path).expect(\"Hull: failed to create posts output\");\n    println!(\"Hull: created {:#?}\", path);\n\n    Ok(())\n}", "item_id": 1, "repo": "rpearce/ramda.guide", "file": "src/hull/post.rs", "last_update_at": "2022-03-23T16:02:52+00:00", "question_id": "c24144e0b86940dbe3c939b11504b3223ce1d429_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn setup(hull_opts: &Config) -> Result<(), io::Error> {\n    let dir = &hull_opts.posts.output;\n    let path = Path::new(dir);\n    if path.exists() {\n        fs::remove_dir_all(path).expect(\"Hull: failed to remove posts output\");\n        println!(\"Hull: removed {:#?}\", path);\n    }\n    fs::create_dir(path).expect(\"Hull: failed to create posts output\");\n    println!(\"Hull: created {:#?}\", path);\n    Ok(())\n"]], "pred": {"ppl": 2.8044018745422363, "ppl_lower": 3.4008219242095947, "ppl/lowercase_ppl": -1.18699445450216, "ppl/zlib": 0.0044834360033888425, "Min_5.0% Prob": 8.418117250714984, "Min_10.0% Prob": 6.537033694131034, "Min_20.0% Prob": 4.357422700950077, "Min_30.0% Prob": 3.2550103806314015, "Min_40.0% Prob": 2.525247048852699, "Min_50.0% Prob": 2.0484239272773266, "Min_60.0% Prob": 1.7146303336623878}}
{"hexsha": "95bc49a8b217eb1c78014d3e8bd43e9a68bd51a4", "ext": "rs", "lang": "Rust", "content": "pub fn search(\n\tpid: &Pid,\n\tregion: &(usize, usize),\n\tpattern: &Pattern,\n) -> Result<(usize, Vec<u8>), MemError> {\n\tlet end = region.1;\n\tlet find = pattern.len();\n\tlet mut chunk_size = CHUNK_SIZE;\n\tlet mut pointer = region.0;\n\tlet mut criteria = pattern.iter();\n\tlet mut found = vec![];\n\tlet mut at = 0;\n\n\tloop {\n\t\t// Avoid overreach\n\t\tif pointer + chunk_size > end {\n\t\t\tchunk_size = end - pointer;\n\t\t}\n\n\t\t// Read memory region one chunk at a time\n\t\tlet chunk = read(pid, pointer, chunk_size)?;\n\n\t\t// Try to find pattern\n\t\tfor (idx, mbyte) in chunk.iter().enumerate() {\n\t\t\tif let Some(byte) = criteria.next().unwrap() {\n\t\t\t\t// Found one\n\t\t\t\tif byte == mbyte {\n\t\t\t\t\tfound.push(*mbyte);\n\n\t\t\t\t\t// Set \"at\" on first discovery\n\t\t\t\t\tif found.len() == 1 {\n\t\t\t\t\t\tat = pointer + idx;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Doesn't match, reset\n\t\t\t\t\tfound.clear();\n\t\t\t\t\tcriteria = pattern.iter();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Skip (None) is still considered found\n\t\t\t\tfound.push(*mbyte);\n\t\t\t}\n\n\t\t\t// Found what there is to find\n\t\t\tif found.len() == find {\n\t\t\t\treturn Ok((at, found));\n\t\t\t}\n\t\t}\n\n\t\t// Set next chunk\n\t\tpointer += chunk.len();\n\n\t\t// End of region, never found it sadly\n\t\tif pointer == end {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tErr(MemError::Read(\"Could not find pattern '{pattern}'\".into()))?\n}", "item_id": 0, "repo": "leaty/tuxtrain", "file": "src/mem.rs", "last_update_at": "2022-03-31T02:36:21+00:00", "question_id": "95bc49a8b217eb1c78014d3e8bd43e9a68bd51a4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn search(\n\tpid: &Pid,\n\tregion: &(usize, usize),\n\tpattern: &Pattern,\n) -> Result<(usize, Vec<u8>), MemError> {\n\tlet end = region.1;\n\tlet find = pattern.len();\n\tlet mut chunk_size = CHUNK_SIZE;\n\tlet mut pointer = region.0;\n\tlet mut criteria = pattern.iter();\n\tlet mut found = vec![];\n\tlet mut at = 0;\n\tloop {\n\t\t// Avoid overreach\n\t\tif pointer + chunk_size > end {\n\t\t\tchunk_size = end - pointer;\n\t\t}\n\t\t// Read memory region one chunk at a time\n\t\tlet chunk = read(pid, pointer, chunk_size)?;\n\t\t// Try to find pattern\n\t\tfor (idx, mbyte) in chunk.iter().enumerate() {\n\t\t\tif let Some(byte) = criteria.next().unwrap() {\n\t\t\t\t// Found one\n\t\t\t\tif byte == mbyte {\n\t\t\t\t\tfound.push(*mbyte);\n\t\t\t\t\t// Set \"at\" on first discovery\n\t\t\t\t\tif found.len() == 1 {\n\t\t\t\t\t\tat = pointer + idx;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Doesn't match, reset\n\t\t\t\t\tfound.clear();\n\t\t\t\t\tcriteria = pattern.iter();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Skip (None) is still considered found\n\t\t\t\tfound.push(*mbyte);\n\t\t\t}\n\t\t\t// Found what there is to find\n\t\t\tif found.len() == find {\n\t\t\t\treturn Ok((at, found));\n\t\t\t}\n\t\t}\n\t\t// Set next chunk\n\t\tpointer += chunk.len();\n\t\t// End of region, never found it sadly\n\t\tif pointer == end {\n\t\t\tbreak;\n\t\t}\n\t}\n\tErr(MemError::Read(\"Could not find pattern '{pattern}'\".into()))?\n"]], "pred": {"ppl": 2.4948856830596924, "ppl_lower": 2.6892049312591553, "ppl/lowercase_ppl": -1.0820380172471618, "ppl/zlib": 0.0014938609636288196, "Min_5.0% Prob": 8.202812359883236, "Min_10.0% Prob": 6.26454331783148, "Min_20.0% Prob": 4.090600450833638, "Min_30.0% Prob": 2.947489583794075, "Min_40.0% Prob": 2.2656762830877755, "Min_50.0% Prob": 1.8258405297599507, "Min_60.0% Prob": 1.5246188345127254}}
{"hexsha": "cca810b0a2c1dd3ee2d3aa3a33344cfbf67bbbb8", "ext": "rs", "lang": "Rust", "content": "fn _cmp_bytes_16(a_ptr: *const u8, b_ptr: *const u8) -> Ordering {\n    let aa_ptr = a_ptr as *const u128;\n    let bb_ptr = b_ptr as *const u128;\n    let aac = unsafe { *aa_ptr };\n    let bbc = unsafe { *bb_ptr };\n    let bits = aac ^ bbc;\n    if bits != 0 {\n        let pos = (bits.trailing_zeros() / 8) as usize;\n        let aa_ptr = unsafe { a_ptr.add(pos) };\n        let bb_ptr = unsafe { b_ptr.add(pos) };\n        let aac = unsafe { *aa_ptr };\n        let bbc = unsafe { *bb_ptr };\n        aac.cmp(&bbc)\n    } else {\n        Ordering::Equal\n    }\n}", "item_id": 1, "repo": "aki-akaguma/memx", "file": "src/arch/x86/x86_cmp.rs", "last_update_at": "2022-02-01T16:08:04+00:00", "question_id": "cca810b0a2c1dd3ee2d3aa3a33344cfbf67bbbb8_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn _cmp_bytes_16(a_ptr: *const u8, b_ptr: *const u8) -> Ordering {\n    let aa_ptr = a_ptr as *const u128;\n    let bb_ptr = b_ptr as *const u128;\n    let aac = unsafe { *aa_ptr };\n    let bbc = unsafe { *bb_ptr };\n    let bits = aac ^ bbc;\n    if bits != 0 {\n        let pos = (bits.trailing_zeros() / 8) as usize;\n        let aa_ptr = unsafe { a_ptr.add(pos) };\n        let bb_ptr = unsafe { b_ptr.add(pos) };\n        let aac = unsafe { *aa_ptr };\n        let bbc = unsafe { *bb_ptr };\n        aac.cmp(&bbc)\n    } else {\n        Ordering::Equal\n    }\n"]], "pred": {"ppl": 1.668631672859192, "ppl_lower": 1.774621605873108, "ppl/lowercase_ppl": -1.12027893428079, "ppl/zlib": 0.002169508190688279, "Min_5.0% Prob": 6.263201583515514, "Min_10.0% Prob": 4.168438131159002, "Min_20.0% Prob": 2.4744569957256317, "Min_30.0% Prob": 1.6972155309657553, "Min_40.0% Prob": 1.2855250484655412, "Min_50.0% Prob": 1.023383951696035, "Min_60.0% Prob": 0.8557439068360115}}
{"hexsha": "63077605e2c62999dd0f25e69279265cbec3a23c", "ext": "rs", "lang": "Rust", "content": "fn secure_passphrase_identity() {\n        let dir = TempDir::new(\"identity\").unwrap();\n        let keychain = keychain::CreateOptions::new()\n            .password(\"password\")\n            .create(dir.path().join(\"identity.keychain\"))\n            .unwrap();\n\n        let data = include_bytes!(\"../../../test/server.p12\");\n        let mut items = SecItems::default();\n        ImportOptions::new()\n            .filename(\"server.p12\")\n            .secure_passphrase(true)\n            .alert_title(\"alert title\")\n            .alert_prompt(\"alert prompt\")\n            .items(&mut items)\n            .keychain(&keychain)\n            .import(data)\n            .unwrap();\n        assert_eq!(1, items.identities.len());\n        assert_eq!(0, items.certificates.len());\n        assert_eq!(0, items.keys.len());\n    }", "item_id": 3, "repo": "allansrc/fuchsia", "file": "third_party/rust_crates/forks/security-framework/src/os/macos/import_export.rs", "last_update_at": "2022-03-28T07:59:06+00:00", "question_id": "63077605e2c62999dd0f25e69279265cbec3a23c_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn secure_passphrase_identity() {\n        let dir = TempDir::new(\"identity\").unwrap();\n        let keychain = keychain::CreateOptions::new()\n            .password(\"password\")\n            .create(dir.path().join(\"identity.keychain\"))\n            .unwrap();\n        let data = include_bytes!(\"../../../test/server.p12\");\n        let mut items = SecItems::default();\n        ImportOptions::new()\n            .filename(\"server.p12\")\n            .secure_passphrase(true)\n            .alert_title(\"alert title\")\n            .alert_prompt(\"alert prompt\")\n            .items(&mut items)\n            .keychain(&keychain)\n            .import(data)\n            .unwrap();\n        assert_eq!(1, items.identities.len());\n        assert_eq!(0, items.certificates.len());\n        assert_eq!(0, items.keys.len());\n"]], "pred": {"ppl": 2.798671007156372, "ppl_lower": 3.1402900218963623, "ppl/lowercase_ppl": -1.1119089464481766, "ppl/zlib": 0.0031568854730138016, "Min_5.0% Prob": 9.26892037825151, "Min_10.0% Prob": 7.242682641202753, "Min_20.0% Prob": 4.6565342084928, "Min_30.0% Prob": 3.293541688082823, "Min_40.0% Prob": 2.546024841371547, "Min_50.0% Prob": 2.0482535998203923, "Min_60.0% Prob": 1.7181413311427876}}
{"hexsha": "53f29da9eca021b6f01792987ac8a7ae218489dd", "ext": "rs", "lang": "Rust", "content": "async fn test_ttl_index() {\n    test_setup();\n    let collection_name = \"test_collection\";\n    let index_name = \"idx_ttl_test\";\n    let conn = connection().await;\n\n    let database = conn.db(\"test_db\").await.unwrap();\n\n    let index = Index::builder()\n        .name(index_name)\n        .fields(vec![\"password\".to_string()])\n        .settings(IndexSettings::Ttl { expire_after: 500 })\n        .build();\n\n    let index = database\n        .create_index(collection_name, &index)\n        .await\n        .unwrap();\n\n    let delete_result = database.delete_index(&index.id).await.unwrap();\n\n    assert!(index.id.len() > 0);\n    assert_eq!(index.name, index_name.to_string());\n    assert_eq!(delete_result.id, index.id);\n\n    if let IndexSettings::Ttl { expire_after } = index.settings {\n        assert_eq!(expire_after, 500);\n    }\n}", "item_id": 4, "repo": "r3bu1ld3r/arangors", "file": "tests/index.rs", "last_update_at": "2022-03-10T13:16:03+00:00", "question_id": "53f29da9eca021b6f01792987ac8a7ae218489dd_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn test_ttl_index() {\n    test_setup();\n    let collection_name = \"test_collection\";\n    let index_name = \"idx_ttl_test\";\n    let conn = connection().await;\n    let database = conn.db(\"test_db\").await.unwrap();\n    let index = Index::builder()\n        .name(index_name)\n        .fields(vec![\"password\".to_string()])\n        .settings(IndexSettings::Ttl { expire_after: 500 })\n        .build();\n    let index = database\n        .create_index(collection_name, &index)\n        .await\n        .unwrap();\n    let delete_result = database.delete_index(&index.id).await.unwrap();\n    assert!(index.id.len() > 0);\n    assert_eq!(index.name, index_name.to_string());\n    assert_eq!(delete_result.id, index.id);\n    if let IndexSettings::Ttl { expire_after } = index.settings {\n        assert_eq!(expire_after, 500);\n    }\n"]], "pred": {"ppl": 2.2458748817443848, "ppl_lower": 2.441162109375, "ppl/lowercase_ppl": -1.103052221838393, "ppl/zlib": 0.0023657752854269387, "Min_5.0% Prob": 6.990865817436805, "Min_10.0% Prob": 5.065152486165364, "Min_20.0% Prob": 3.4017107729558593, "Min_30.0% Prob": 2.5387118098176558, "Min_40.0% Prob": 1.963499039001421, "Min_50.0% Prob": 1.6041575805558002, "Min_60.0% Prob": 1.3499885401659948}}
{"hexsha": "ab688fcf5573e69668dcb8598743abbfef680a36", "ext": "rs", "lang": "Rust", "content": "fn allows_ints() {\n            let mut node = ExpressionNode::from(RangeNode {\n                l: Box::new(Some(ExpressionNode::Var(VarNode::new(\"foo\")))),\n                r: Box::new(Some(ExpressionNode::from(456))),\n                span: None,\n            });\n\n            let mut scopes = ScopeTree::default();\n            scopes.push_new();\n            let sym = Symbol::new(\"foo\", LpcType::Int(false));\n            scopes.current_mut().unwrap().insert(sym);\n            let context = CompilationContext {\n                scopes,\n                ..CompilationContext::default()\n            };\n\n            let mut walker = SemanticCheckWalker::new(context);\n            let _ = node.visit(&mut walker);\n\n            assert!(walker.context.errors.is_empty());\n        }", "item_id": 48, "repo": "xxx/lpc-rs", "file": "src/codegen/semantic_check_walker.rs", "last_update_at": "2022-02-01T19:12:36+00:00", "question_id": "ab688fcf5573e69668dcb8598743abbfef680a36_48", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn allows_ints() {\n            let mut node = ExpressionNode::from(RangeNode {\n                l: Box::new(Some(ExpressionNode::Var(VarNode::new(\"foo\")))),\n                r: Box::new(Some(ExpressionNode::from(456))),\n                span: None,\n            });\n            let mut scopes = ScopeTree::default();\n            scopes.push_new();\n            let sym = Symbol::new(\"foo\", LpcType::Int(false));\n            scopes.current_mut().unwrap().insert(sym);\n            let context = CompilationContext {\n                scopes,\n                ..CompilationContext::default()\n            };\n            let mut walker = SemanticCheckWalker::new(context);\n            let _ = node.visit(&mut walker);\n            assert!(walker.context.errors.is_empty());\n"]], "pred": {"ppl": 3.571814775466919, "ppl_lower": 4.995439529418945, "ppl/lowercase_ppl": -1.263497366091127, "ppl/zlib": 0.003834559659931406, "Min_5.0% Prob": 8.203994655609131, "Min_10.0% Prob": 6.945984935760498, "Min_20.0% Prob": 4.8965655419884655, "Min_30.0% Prob": 3.7469880234810615, "Min_40.0% Prob": 3.0195486839995325, "Min_50.0% Prob": 2.4996533657495794, "Min_60.0% Prob": 2.12438433725507}}
{"hexsha": "6909681d7022d2c0050eef2a8fd33f1497608030", "ext": "rs", "lang": "Rust", "content": "pub fn expand_groups(path: &str) -> Vec<String> {\n    lazy_static! {\n        static ref GROUPS_MATCHER: Regex = Regex::new(r\"\\{[^\\{]+?\\}\").unwrap();\n    }\n\n    let mut offset = 0;\n    let mut chunks: Vec<Vec<&str>> = vec![];\n\n    for m in GROUPS_MATCHER.find_iter(path) {\n        chunks.push(vec![&path[offset..m.start()]]);\n        chunks.push(path[m.start() + 1..m.end() - 1].split(',').collect());\n        offset = m.end();\n    }\n    chunks.push(vec![&path[offset..]]);\n\n    join_chunks(chunks)\n}", "item_id": 0, "repo": "panhania/rrg", "file": "src/action/finder/groups.rs", "last_update_at": "2022-03-10T06:42:44+00:00", "question_id": "6909681d7022d2c0050eef2a8fd33f1497608030_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn expand_groups(path: &str) -> Vec<String> {\n    lazy_static! {\n        static ref GROUPS_MATCHER: Regex = Regex::new(r\"\\{[^\\{]+?\\}\").unwrap();\n    }\n    let mut offset = 0;\n    let mut chunks: Vec<Vec<&str>> = vec![];\n    for m in GROUPS_MATCHER.find_iter(path) {\n        chunks.push(vec![&path[offset..m.start()]]);\n        chunks.push(path[m.start() + 1..m.end() - 1].split(',').collect());\n        offset = m.end();\n    }\n    chunks.push(vec![&path[offset..]]);\n    join_chunks(chunks)\n"]], "pred": {"ppl": 1.8620960712432861, "ppl_lower": 2.191679000854492, "ppl/lowercase_ppl": -1.262127098200726, "ppl/zlib": 0.00212911908647484, "Min_5.0% Prob": 7.308306747012669, "Min_10.0% Prob": 5.031225631111546, "Min_20.0% Prob": 2.9780868605563513, "Min_30.0% Prob": 2.037144146602729, "Min_40.0% Prob": 1.5539690584621646, "Min_50.0% Prob": 1.2399127091444337, "Min_60.0% Prob": 1.038687513129593}}
{"hexsha": "c9b4e7f9f9ec1954c6b89b4e71ac9099f3b5a134", "ext": "rs", "lang": "Rust", "content": "fn create_builder_struct_code(parameters: &FunctionParamsCode, in_group: bool) -> Result<TokenStream, Error> {\n    let mut params: Vec<TokenStream> = Vec::new();\n    if in_group {\n        params.push(quote! { pub(crate) client: super::super::Client });\n    } else {\n        params.push(quote! { pub(crate) client: super::Client });\n    }\n    for param in parameters.required_params() {\n        let FunctionParam {\n            variable_name, type_name, ..\n        } = param;\n        params.push(quote! { pub(crate) #variable_name: #type_name });\n    }\n    for param in parameters.optional_params() {\n        let FunctionParam {\n            variable_name, type_name, ..\n        } = param;\n        let mut type_name = type_name.clone();\n        if type_name.is_vec() {\n            type_name = type_name.optional(false);\n        }\n        params.push(quote! { pub(crate) #variable_name: #type_name });\n    }\n    Ok(quote! {\n        #[derive(Clone)]\n        pub struct Builder {\n            #(#params),*\n        }\n    })\n}", "item_id": 6, "repo": "rickrain/azure-sdk-for-rust", "file": "services/autorust/codegen/src/codegen_operations.rs", "last_update_at": "2022-02-16T18:36:01+00:00", "question_id": "c9b4e7f9f9ec1954c6b89b4e71ac9099f3b5a134_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn create_builder_struct_code(parameters: &FunctionParamsCode, in_group: bool) -> Result<TokenStream, Error> {\n    let mut params: Vec<TokenStream> = Vec::new();\n    if in_group {\n        params.push(quote! { pub(crate) client: super::super::Client });\n    } else {\n        params.push(quote! { pub(crate) client: super::Client });\n    }\n    for param in parameters.required_params() {\n        let FunctionParam {\n            variable_name, type_name, ..\n        } = param;\n        params.push(quote! { pub(crate) #variable_name: #type_name });\n    }\n    for param in parameters.optional_params() {\n        let FunctionParam {\n            variable_name, type_name, ..\n        } = param;\n        let mut type_name = type_name.clone();\n        if type_name.is_vec() {\n            type_name = type_name.optional(false);\n        }\n        params.push(quote! { pub(crate) #variable_name: #type_name });\n    }\n    Ok(quote! {\n        #[derive(Clone)]\n        pub struct Builder {\n            #(#params),*\n        }\n    })\n"]], "pred": {"ppl": 1.9803980588912964, "ppl_lower": 2.5409858226776123, "ppl/lowercase_ppl": -1.3647812667911634, "ppl/zlib": 0.0019139996200132538, "Min_5.0% Prob": 6.971842098236084, "Min_10.0% Prob": 5.238203620910644, "Min_20.0% Prob": 3.1580020394481596, "Min_30.0% Prob": 2.2289207647352116, "Min_40.0% Prob": 1.701286898214158, "Min_50.0% Prob": 1.3679339769719676, "Min_60.0% Prob": 1.140715568766904}}
{"hexsha": "d862c6a9a02786c55e48e2a6a6f45f9c1c80b65d", "ext": "rs", "lang": "Rust", "content": "pub fn inline_metas(mut tcs: TCS, val: ValInfo) -> ValTCM {\n    use Neutral::*;\n    let info = val.loc;\n    let val = val.ast.try_map_neutral(&mut |neut| match neut {\n        Meta(mi) => tcs\n            .meta_context\n            .take_meta(mi)\n            .ok_or_else(|| TCE::MetaUnsolved(mi)),\n        e => Ok(Val::Neut(e)),\n    })?;\n    Ok((val.into_info(info), tcs))\n}", "item_id": 1, "repo": "ice1000/voile-rs", "file": "src/check/decl.rs", "last_update_at": "2022-03-28T10:48:27+00:00", "question_id": "d862c6a9a02786c55e48e2a6a6f45f9c1c80b65d_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn inline_metas(mut tcs: TCS, val: ValInfo) -> ValTCM {\n    use Neutral::*;\n    let info = val.loc;\n    let val = val.ast.try_map_neutral(&mut |neut| match neut {\n        Meta(mi) => tcs\n            .meta_context\n            .take_meta(mi)\n            .ok_or_else(|| TCE::MetaUnsolved(mi)),\n        e => Ok(Val::Neut(e)),\n    })?;\n    Ok((val.into_info(info), tcs))\n"]], "pred": {"ppl": 5.419118404388428, "ppl_lower": 8.581220626831055, "ppl/lowercase_ppl": -1.271988878618209, "ppl/zlib": 0.007252931957960237, "Min_5.0% Prob": 9.316743441990443, "Min_10.0% Prob": 8.04877359526498, "Min_20.0% Prob": 6.130381269114358, "Min_30.0% Prob": 4.816431575043257, "Min_40.0% Prob": 3.966274048152723, "Min_50.0% Prob": 3.286273753063546, "Min_60.0% Prob": 2.804161824285984}}
{"hexsha": "a3889528db5bb779621f9bea8c6f6249ccc93496", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn eval(p: &[u8], x: u8) -> u8 {\n    let mut result = 0;\n\n    for i in (0..p.len()).rev() {\n        result = add(mul(result, x), p[i])\n    }\n    result\n}", "item_id": 1, "repo": "rustyhorde/sss", "file": "src/gf256/mod.rs", "last_update_at": "2022-01-19T14:26:27+00:00", "question_id": "a3889528db5bb779621f9bea8c6f6249ccc93496_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn eval(p: &[u8], x: u8) -> u8 {\n    let mut result = 0;\n    for i in (0..p.len()).rev() {\n        result = add(mul(result, x), p[i])\n    }\n    result\n"]], "pred": {"ppl": 3.101529121398926, "ppl_lower": 3.101529121398926, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.008774381820490873, "Min_5.0% Prob": 8.522270043691, "Min_10.0% Prob": 6.272165162222726, "Min_20.0% Prob": 4.347756743431091, "Min_30.0% Prob": 3.401801444235302, "Min_40.0% Prob": 2.6542167211401053, "Min_50.0% Prob": 2.2258098680112095, "Min_60.0% Prob": 1.9029836079408957}}
{"hexsha": "a8db0b5b31478f6f8c1bc9ced0437c56ea77da0e", "ext": "rs", "lang": "Rust", "content": "pub fn create_theme(opt: &Opt) -> Theme {\n    let locations = locations();\n    let mut theme = Theme::default();\n    if let Some(th) = &opt.theme {\n        locations.iter().find(|d| {\n            let path = d.join(&format!(\"{}.toml\", th));\n            if !path.exists() {\n                return false;\n            }\n\n            match get_theme(&path) {\n                Ok(t) => {\n                    theme = t;\n                    theme.set_randomization();\n                    true\n                }\n                Err(e) => {\n                    error::print_errors(e);\n                    false\n                }\n            }\n        });\n    }\n\n    theme\n}", "item_id": 1, "repo": "uttarayan21/macchina", "file": "src/theme/base.rs", "last_update_at": "2022-03-31T18:42:08+00:00", "question_id": "a8db0b5b31478f6f8c1bc9ced0437c56ea77da0e_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn create_theme(opt: &Opt) -> Theme {\n    let locations = locations();\n    let mut theme = Theme::default();\n    if let Some(th) = &opt.theme {\n        locations.iter().find(|d| {\n            let path = d.join(&format!(\"{}.toml\", th));\n            if !path.exists() {\n                return false;\n            }\n            match get_theme(&path) {\n                Ok(t) => {\n                    theme = t;\n                    theme.set_randomization();\n                    true\n                }\n                Err(e) => {\n                    error::print_errors(e);\n                    false\n                }\n            }\n        });\n    }\n    theme\n"]], "pred": {"ppl": 2.796570301055908, "ppl_lower": 3.2392098903656006, "ppl/lowercase_ppl": -1.1428787969044305, "ppl/zlib": 0.0036859991896314496, "Min_5.0% Prob": 8.955481708049774, "Min_10.0% Prob": 6.902354745303883, "Min_20.0% Prob": 4.473670087541852, "Min_30.0% Prob": 3.2415921137018024, "Min_40.0% Prob": 2.539737867457526, "Min_50.0% Prob": 2.050539768385616, "Min_60.0% Prob": 1.7132575284549088}}
{"hexsha": "d95402363cd8ad4150d80467195470ad710b702c", "ext": "rs", "lang": "Rust", "content": "fn simple_message() {\n    let test_name = random_name(\"simple_message\");\n    libsystemd::logging::journal_send(\n        Priority::Info,\n        \"Hello World\",\n        vec![\n            (\"TEST_NAME\", test_name.as_str()),\n            (\"FOO\", \"another piece of data\"),\n        ]\n        .into_iter(),\n    )\n    .unwrap();\n\n    let messages = read_from_journal(&test_name);\n    assert_eq!(messages.len(), 1);\n\n    let message = &messages[0];\n    assert_eq!(message[\"MESSAGE\"], \"Hello World\");\n    assert_eq!(message[\"TEST_NAME\"], test_name);\n    assert_eq!(message[\"PRIORITY\"], \"6\");\n    assert_eq!(message[\"FOO\"], \"another piece of data\");\n}", "item_id": 0, "repo": "vilgotf/libsystemd-rs", "file": "tests/journal.rs", "last_update_at": "2022-03-05T11:42:31+00:00", "question_id": "d95402363cd8ad4150d80467195470ad710b702c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn simple_message() {\n    let test_name = random_name(\"simple_message\");\n    libsystemd::logging::journal_send(\n        Priority::Info,\n        \"Hello World\",\n        vec![\n            (\"TEST_NAME\", test_name.as_str()),\n            (\"FOO\", \"another piece of data\"),\n        ]\n        .into_iter(),\n    )\n    .unwrap();\n    let messages = read_from_journal(&test_name);\n    assert_eq!(messages.len(), 1);\n    let message = &messages[0];\n    assert_eq!(message[\"MESSAGE\"], \"Hello World\");\n    assert_eq!(message[\"TEST_NAME\"], test_name);\n    assert_eq!(message[\"PRIORITY\"], \"6\");\n    assert_eq!(message[\"FOO\"], \"another piece of data\");\n"]], "pred": {"ppl": 2.387181520462036, "ppl_lower": 2.6366875171661377, "ppl/lowercase_ppl": -1.1142494900444115, "ppl/zlib": 0.0028159009382007325, "Min_5.0% Prob": 8.780234050750732, "Min_10.0% Prob": 6.445100855827332, "Min_20.0% Prob": 3.98845831155777, "Min_30.0% Prob": 2.8146994948387145, "Min_40.0% Prob": 2.140324021195188, "Min_50.0% Prob": 1.7368011355105013, "Min_60.0% Prob": 1.4561218633047066}}
{"hexsha": "dedc9bc7459e74b5a527e66e0bbc160bd46ad9a6", "ext": "rs", "lang": "Rust", "content": "fn slow_on_write() {\n        // this test is pretty similar to the above, except that it lags the on_write call instead.\n        let exec = fasync::Executor::new().expect(\"Executor creation failed\");\n\n        let write_counter = Arc::new(AtomicUsize::new(0));\n        let client_counter = Arc::new(AtomicUsize::new(0));\n        let client_count = client_counter.clone();\n        let (finish_future_sender, finish_future_receiver) = oneshot::channel::<()>();\n        let finish_future_receiver = finish_future_receiver.shared();\n\n        run_server_client_with_executor(\n            OPEN_RIGHT_WRITABLE,\n            exec,\n            write_only(100, |content| {\n                let write_counter = write_counter.clone();\n                let finish_future_receiver = finish_future_receiver.clone();\n                async move {\n                    assert_eq!(*&content, b\"content\");\n                    write_counter.fetch_add(1, Ordering::Relaxed);\n                    await!(finish_future_receiver)\n                        .expect(\"finish_future_sender was not called before been dropped.\");\n                    write_counter.fetch_add(1, Ordering::Relaxed);\n                    Ok(())\n                }\n            }),\n            async move |proxy| {\n                client_count.fetch_add(1, Ordering::Relaxed);\n\n                assert_write!(proxy, \"content\");\n                assert_close!(proxy);\n\n                client_count.fetch_add(1, Ordering::Relaxed);\n            },\n            |run_until_stalled_assert| {\n                let check_write_client_counts = |expected_write, expected_client| {\n                    assert_eq!(write_counter.load(Ordering::Relaxed), expected_write);\n                    assert_eq!(client_counter.load(Ordering::Relaxed), expected_client);\n                };\n\n                run_until_stalled_assert(false);\n\n                // The server and the client are waiting.\n                check_write_client_counts(1, 1);\n\n                finish_future_sender.send(()).unwrap();\n                run_until_stalled_assert(true);\n\n                // The server and the client are done.\n                check_write_client_counts(2, 2);\n            },\n        );\n    }", "item_id": 6, "repo": "zhangpf/fuchsia-rs", "file": "garnet/public/rust/fuchsia-vfs/pseudo-fs/src/file/asynchronous.rs", "last_update_at": "2022-03-02T04:44:22+00:00", "question_id": "dedc9bc7459e74b5a527e66e0bbc160bd46ad9a6_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn slow_on_write() {\n        // this test is pretty similar to the above, except that it lags the on_write call instead.\n        let exec = fasync::Executor::new().expect(\"Executor creation failed\");\n        let write_counter = Arc::new(AtomicUsize::new(0));\n        let client_counter = Arc::new(AtomicUsize::new(0));\n        let client_count = client_counter.clone();\n        let (finish_future_sender, finish_future_receiver) = oneshot::channel::<()>();\n        let finish_future_receiver = finish_future_receiver.shared();\n        run_server_client_with_executor(\n            OPEN_RIGHT_WRITABLE,\n            exec,\n            write_only(100, |content| {\n                let write_counter = write_counter.clone();\n                let finish_future_receiver = finish_future_receiver.clone();\n                async move {\n                    assert_eq!(*&content, b\"content\");\n                    write_counter.fetch_add(1, Ordering::Relaxed);\n                    await!(finish_future_receiver)\n                        .expect(\"finish_future_sender was not called before been dropped.\");\n                    write_counter.fetch_add(1, Ordering::Relaxed);\n                    Ok(())\n                }\n            }),\n            async move |proxy| {\n                client_count.fetch_add(1, Ordering::Relaxed);\n                assert_write!(proxy, \"content\");\n                assert_close!(proxy);\n                client_count.fetch_add(1, Ordering::Relaxed);\n            },\n            |run_until_stalled_assert| {\n                let check_write_client_counts = |expected_write, expected_client| {\n                    assert_eq!(write_counter.load(Ordering::Relaxed), expected_write);\n                    assert_eq!(client_counter.load(Ordering::Relaxed), expected_client);\n                };\n                run_until_stalled_assert(false);\n                // The server and the client are waiting.\n                check_write_client_counts(1, 1);\n                finish_future_sender.send(()).unwrap();\n                run_until_stalled_assert(true);\n                // The server and the client are done.\n                check_write_client_counts(2, 2);\n            },\n        );\n"]], "pred": {"ppl": 2.148054838180542, "ppl_lower": 2.524768114089966, "ppl/lowercase_ppl": -1.211345014602323, "ppl/zlib": 0.0011708464107196722, "Min_5.0% Prob": 6.512458674112955, "Min_10.0% Prob": 4.9919903914133705, "Min_20.0% Prob": 3.3612571567296983, "Min_30.0% Prob": 2.470120067232185, "Min_40.0% Prob": 1.9015464844182133, "Min_50.0% Prob": 1.526277730377558, "Min_60.0% Prob": 1.2745034093594494}}
{"hexsha": "3e2f6607d27280bcb38a973c0c7be105d5707329", "ext": "rs", "lang": "Rust", "content": "fn get_local_contract(path: &Path) -> Result<String> {\n    let path = if path.is_relative() {\n        let absolute_path = path.canonicalize().with_context(|| {\n            format!(\n                \"unable to canonicalize file from working dir {} with path {}\",\n                env::current_dir()\n                    .map(|cwd| cwd.display().to_string())\n                    .unwrap_or_else(|err| format!(\"??? ({})\", err)),\n                path.display(),\n            )\n        })?;\n        Cow::Owned(absolute_path)\n    } else {\n        Cow::Borrowed(path)\n    };\n\n    let json = fs::read_to_string(&path).context(format!(\n        \"failed to read artifact JSON file with path {}\",\n        &path.display()\n    ))?;\n    Ok(json)\n}", "item_id": 0, "repo": "luizstacio/fuels-rs", "file": "packages/fuels-core/src/source.rs", "last_update_at": "2022-03-29T22:45:20+00:00", "question_id": "3e2f6607d27280bcb38a973c0c7be105d5707329_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_local_contract(path: &Path) -> Result<String> {\n    let path = if path.is_relative() {\n        let absolute_path = path.canonicalize().with_context(|| {\n            format!(\n                \"unable to canonicalize file from working dir {} with path {}\",\n                env::current_dir()\n                    .map(|cwd| cwd.display().to_string())\n                    .unwrap_or_else(|err| format!(\"??? ({})\", err)),\n                path.display(),\n            )\n        })?;\n        Cow::Owned(absolute_path)\n    } else {\n        Cow::Borrowed(path)\n    };\n    let json = fs::read_to_string(&path).context(format!(\n        \"failed to read artifact JSON file with path {}\",\n        &path.display()\n    ))?;\n    Ok(json)\n"]], "pred": {"ppl": 2.1705706119537354, "ppl_lower": 2.7664756774902344, "ppl/lowercase_ppl": -1.313015750180234, "ppl/zlib": 0.002152750243897776, "Min_5.0% Prob": 6.87607774734497, "Min_10.0% Prob": 5.18156833875747, "Min_20.0% Prob": 3.47389058318249, "Min_30.0% Prob": 2.530948941130191, "Min_40.0% Prob": 1.9345741330884223, "Min_50.0% Prob": 1.5475655262427475, "Min_60.0% Prob": 1.2971063904435367}}
{"hexsha": "2a7f1ec01831b9ec8306a324ede6d31050ecea54", "ext": "rs", "lang": "Rust", "content": "fn test_from_config_date() {\n        let mut c = Config::with_none();\n        c.date = Some(\"date\".into());\n\n        assert_eq!(Some(DateFlag::Date), DateFlag::from_config(&c));\n    }", "item_id": 7, "repo": "NyleCohen/lsd", "file": "src/flags/date.rs", "last_update_at": "2022-03-31T19:22:11+00:00", "question_id": "2a7f1ec01831b9ec8306a324ede6d31050ecea54_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_from_config_date() {\n        let mut c = Config::with_none();\n        c.date = Some(\"date\".into());\n        assert_eq!(Some(DateFlag::Date), DateFlag::from_config(&c));\n"]], "pred": {"ppl": 4.550764083862305, "ppl_lower": 7.026254653930664, "ppl/lowercase_ppl": -1.286649533914753, "ppl/zlib": 0.01147950870744921, "Min_5.0% Prob": 8.830149491628012, "Min_10.0% Prob": 7.22719391187032, "Min_20.0% Prob": 5.548643708229065, "Min_30.0% Prob": 4.349592328071594, "Min_40.0% Prob": 3.592757041255633, "Min_50.0% Prob": 2.955729114015897, "Min_60.0% Prob": 2.4975460573203034}}
{"hexsha": "d8edfa906c932a5dfccb45fe938d24ebd281099e", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout___darwin_mcontext_avx64_full() {\n    assert_eq!(\n        ::std::mem::size_of::<__darwin_mcontext_avx64_full>(),\n        1064usize,\n        concat!(\"Size of: \", stringify!(__darwin_mcontext_avx64_full))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<__darwin_mcontext_avx64_full>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(__darwin_mcontext_avx64_full))\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<__darwin_mcontext_avx64_full>())).__es as *const _ as usize\n        },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__darwin_mcontext_avx64_full),\n            \"::\",\n            stringify!(__es)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<__darwin_mcontext_avx64_full>())).__ss as *const _ as usize\n        },\n        16usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__darwin_mcontext_avx64_full),\n            \"::\",\n            stringify!(__ss)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<__darwin_mcontext_avx64_full>())).__fs as *const _ as usize\n        },\n        216usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__darwin_mcontext_avx64_full),\n            \"::\",\n            stringify!(__fs)\n        )\n    );\n}", "item_id": 162, "repo": "ueno/rust-tss-esapi", "file": "tss-esapi-sys/src/bindings/x86_64-unknown-darwin.rs", "last_update_at": "2022-03-22T07:54:57+00:00", "question_id": "d8edfa906c932a5dfccb45fe938d24ebd281099e_162", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bindgen_test_layout___darwin_mcontext_avx64_full() {\n    assert_eq!(\n        ::std::mem::size_of::<__darwin_mcontext_avx64_full>(),\n        1064usize,\n        concat!(\"Size of: \", stringify!(__darwin_mcontext_avx64_full))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<__darwin_mcontext_avx64_full>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(__darwin_mcontext_avx64_full))\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<__darwin_mcontext_avx64_full>())).__es as *const _ as usize\n        },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__darwin_mcontext_avx64_full),\n            \"::\",\n            stringify!(__es)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<__darwin_mcontext_avx64_full>())).__ss as *const _ as usize\n        },\n        16usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__darwin_mcontext_avx64_full),\n            \"::\",\n            stringify!(__ss)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<__darwin_mcontext_avx64_full>())).__fs as *const _ as usize\n        },\n        216usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__darwin_mcontext_avx64_full),\n            \"::\",\n            stringify!(__fs)\n        )\n    );\n"]], "pred": {"ppl": 1.193252682685852, "ppl_lower": 1.2170751094818115, "ppl/lowercase_ppl": -1.1118818011444382, "ppl/zlib": 0.0006332721330434049, "Min_5.0% Prob": 3.337184647719065, "Min_10.0% Prob": 1.7859101720775168, "Min_20.0% Prob": 0.8903418233553332, "Min_30.0% Prob": 0.5917314342295867, "Min_40.0% Prob": 0.4430591704699999, "Min_50.0% Prob": 0.3540882247247744, "Min_60.0% Prob": 0.29487303205026694}}
{"hexsha": "d76cdd6a4fcc687a5ef8aeade4fa2f9699dc40ff", "ext": "rs", "lang": "Rust", "content": "fn compare_to_reference() {\n        let reference_input = to_f32(include_bytes!(\"../test_data/testing.raw\"));\n        let reference_output = to_i16(include_bytes!(\"../test_data/reference_output.raw\"));\n        let mut output = Vec::new();\n        let mut out_buf = [0.0; FRAME_SIZE];\n        let mut state = DenoiseState::new();\n        let mut first = true;\n        for chunk in reference_input.chunks_exact(FRAME_SIZE) {\n            state.process_frame(&mut out_buf[..], chunk);\n            if !first {\n                output.extend_from_slice(&out_buf[..]);\n            }\n            first = false;\n        }\n\n        assert_eq!(output.len(), reference_output.len());\n        let output = output.into_iter().map(|x| x as i16).collect::<Vec<_>>();\n        let xx: f64 = output.iter().map(|&x| (x as f64).powi(2)).sum();\n        let diff: f64 = reference_output\n            .into_iter()\n            .zip(output)\n            .map(|(x, y)| (x as f64 - y as f64).powi(2))\n            .sum();\n        assert!(diff / xx < 1e-4);\n    }", "item_id": 3, "repo": "Rikorose/nnnoiseless", "file": "src/lib.rs", "last_update_at": "2022-03-31T17:47:15+00:00", "question_id": "d76cdd6a4fcc687a5ef8aeade4fa2f9699dc40ff_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn compare_to_reference() {\n        let reference_input = to_f32(include_bytes!(\"../test_data/testing.raw\"));\n        let reference_output = to_i16(include_bytes!(\"../test_data/reference_output.raw\"));\n        let mut output = Vec::new();\n        let mut out_buf = [0.0; FRAME_SIZE];\n        let mut state = DenoiseState::new();\n        let mut first = true;\n        for chunk in reference_input.chunks_exact(FRAME_SIZE) {\n            state.process_frame(&mut out_buf[..], chunk);\n            if !first {\n                output.extend_from_slice(&out_buf[..]);\n            }\n            first = false;\n        }\n        assert_eq!(output.len(), reference_output.len());\n        let output = output.into_iter().map(|x| x as i16).collect::<Vec<_>>();\n        let xx: f64 = output.iter().map(|&x| (x as f64).powi(2)).sum();\n        let diff: f64 = reference_output\n            .into_iter()\n            .zip(output)\n            .map(|(x, y)| (x as f64 - y as f64).powi(2))\n            .sum();\n        assert!(diff / xx < 1e-4);\n"]], "pred": {"ppl": 1.990048885345459, "ppl_lower": 2.364426374435425, "ppl/lowercase_ppl": -1.2504888982032554, "ppl/zlib": 0.001626853910011595, "Min_5.0% Prob": 6.311109632253647, "Min_10.0% Prob": 4.455978509151574, "Min_20.0% Prob": 2.9273385841455033, "Min_30.0% Prob": 2.146541293599818, "Min_40.0% Prob": 1.6820617179075876, "Min_50.0% Prob": 1.368502384812169, "Min_60.0% Prob": 1.1463822595628317}}
{"hexsha": "5b624133894ec5a9d8631b19de5deaabd8a65bbf", "ext": "rs", "lang": "Rust", "content": "async fn install_wallet(canister_id: &Principal, wasm_module: Vec<u8>) -> Result<(), String> {\n        // Install Wasm\n        #[derive(CandidType, Deserialize)]\n        enum InstallMode {\n            #[serde(rename = \"install\")]\n            Install,\n            #[serde(rename = \"reinstall\")]\n            Reinstall,\n            #[serde(rename = \"upgrade\")]\n            Upgrade,\n        }\n\n        #[derive(CandidType, Deserialize)]\n        struct CanisterInstall {\n            mode: InstallMode,\n            canister_id: Principal,\n            #[serde(with = \"serde_bytes\")]\n            wasm_module: Vec<u8>,\n            arg: Vec<u8>,\n        }\n\n        let install_config = CanisterInstall {\n            mode: InstallMode::Install,\n            canister_id: *canister_id,\n            wasm_module: wasm_module.clone(),\n            arg: b\" \".to_vec(),\n        };\n\n        match api::call::call(\n            Principal::management_canister(),\n            \"install_code\",\n            (install_config,),\n        )\n        .await\n        {\n            Ok(x) => x,\n            Err((code, msg)) => {\n                return Err(format!(\n                    \"An error happened during the call: {}: {}\",\n                    code as u8, msg\n                ))\n            }\n        };\n\n        events::record(events::EventKind::WalletDeployed {\n            canister: *canister_id,\n        });\n\n        // Store wallet wasm\n        let store_args = WalletStoreWASMArgs { wasm_module };\n        match api::call::call(*canister_id, \"wallet_store_wallet_wasm\", (store_args,)).await {\n            Ok(x) => x,\n            Err((code, msg)) => {\n                return Err(format!(\n                    \"An error happened during the call: {}: {}\",\n                    code as u8, msg\n                ))\n            }\n        };\n        Ok(())\n    }", "item_id": 10, "repo": "wackyleo459/cycles-wallet", "file": "wallet/src/lib.rs", "last_update_at": "2022-03-15T14:28:46+00:00", "question_id": "5b624133894ec5a9d8631b19de5deaabd8a65bbf_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn install_wallet(canister_id: &Principal, wasm_module: Vec<u8>) -> Result<(), String> {\n        // Install Wasm\n        #[derive(CandidType, Deserialize)]\n        enum InstallMode {\n            #[serde(rename = \"install\")]\n            Install,\n            #[serde(rename = \"reinstall\")]\n            Reinstall,\n            #[serde(rename = \"upgrade\")]\n            Upgrade,\n        }\n        #[derive(CandidType, Deserialize)]\n        struct CanisterInstall {\n            mode: InstallMode,\n            canister_id: Principal,\n            #[serde(with = \"serde_bytes\")]\n            wasm_module: Vec<u8>,\n            arg: Vec<u8>,\n        }\n        let install_config = CanisterInstall {\n            mode: InstallMode::Install,\n            canister_id: *canister_id,\n            wasm_module: wasm_module.clone(),\n            arg: b\" \".to_vec(),\n        };\n        match api::call::call(\n            Principal::management_canister(),\n            \"install_code\",\n            (install_config,),\n        )\n        .await\n        {\n            Ok(x) => x,\n            Err((code, msg)) => {\n                return Err(format!(\n                    \"An error happened during the call: {}: {}\",\n                    code as u8, msg\n                ))\n            }\n        };\n        events::record(events::EventKind::WalletDeployed {\n            canister: *canister_id,\n        });\n        // Store wallet wasm\n        let store_args = WalletStoreWASMArgs { wasm_module };\n        match api::call::call(*canister_id, \"wallet_store_wallet_wasm\", (store_args,)).await {\n            Ok(x) => x,\n            Err((code, msg)) => {\n                return Err(format!(\n                    \"An error happened during the call: {}: {}\",\n                    code as u8, msg\n                ))\n            }\n        };\n        Ok(())\n"]], "pred": {"ppl": 1.7944860458374023, "ppl_lower": 2.137707233428955, "ppl/lowercase_ppl": -1.2993152540826163, "ppl/zlib": 0.0010330718295097428, "Min_5.0% Prob": 6.274125310090872, "Min_10.0% Prob": 4.480058358265803, "Min_20.0% Prob": 2.748005193299972, "Min_30.0% Prob": 1.920196029620293, "Min_40.0% Prob": 1.4566512624554049, "Min_50.0% Prob": 1.1683701753777525, "Min_60.0% Prob": 0.9742607648517244}}
{"hexsha": "7664dfc683b5b5061964a63f04c08ed6b07d34d9", "ext": "rs", "lang": "Rust", "content": "fn serialize_currency() {\n    use stripe::Currency;\n    assert_eq!(serde_json::to_string(&Currency::AED).unwrap(), \"\\\"aed\\\"\");\n    assert_eq!(serde_json::to_string(&Currency::USD).unwrap(), \"\\\"usd\\\"\");\n    assert_eq!(serde_json::to_string(&Currency::ZMW).unwrap(), \"\\\"zmw\\\"\");\n}", "item_id": 2, "repo": "chrislearn/async-stripe", "file": "tests/encoding.rs", "last_update_at": "2022-03-31T15:00:05+00:00", "question_id": "7664dfc683b5b5061964a63f04c08ed6b07d34d9_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn serialize_currency() {\n    use stripe::Currency;\n    assert_eq!(serde_json::to_string(&Currency::AED).unwrap(), \"\\\"aed\\\"\");\n    assert_eq!(serde_json::to_string(&Currency::USD).unwrap(), \"\\\"usd\\\"\");\n    assert_eq!(serde_json::to_string(&Currency::ZMW).unwrap(), \"\\\"zmw\\\"\");\n"]], "pred": {"ppl": 1.8706820011138916, "ppl_lower": 2.249321460723877, "ppl/lowercase_ppl": -1.2943072378927523, "ppl/zlib": 0.004639282006335335, "Min_5.0% Prob": 8.025356864929199, "Min_10.0% Prob": 5.32426917552948, "Min_20.0% Prob": 3.1411370635032654, "Min_30.0% Prob": 2.089469336934628, "Min_40.0% Prob": 1.5868382748761556, "Min_50.0% Prob": 1.2521976455419253, "Min_60.0% Prob": 1.050444082353234}}
{"hexsha": "848a493f75eb7f91fc8451bf7c2a53f425c531a8", "ext": "rs", "lang": "Rust", "content": "pub fn line_spacing() -> Result<(), DocxError> {\n    let path = std::path::Path::new(\"./tests/output/line_spacing.docx\");\n    let file = std::fs::File::create(&path).unwrap();\n    Docx::new()\n        .add_paragraph(\n            Paragraph::new()\n                .add_run(Run::new().add_text(DUMMY))\n                .line_spacing(Some(300), None, Some(300), Some(LineSpacingType::Auto)),\n        )\n        .add_paragraph(\n            Paragraph::new()\n                .add_run(Run::new().add_text(DUMMY))\n                .line_spacing(None, None, Some(300), Some(LineSpacingType::AtLeast)),\n        )\n        .add_paragraph(\n            Paragraph::new()\n                .add_run(Run::new().add_text(DUMMY).character_spacing(100))\n                .line_spacing(None, Some(300), Some(300), Some(LineSpacingType::Exact)),\n        )\n        .build()\n        .pack(file)?;\n    Ok(())\n}", "item_id": 19, "repo": "lkadalski/docx-rs", "file": "docx-core/tests/lib.rs", "last_update_at": "2022-03-31T11:06:05+00:00", "question_id": "848a493f75eb7f91fc8451bf7c2a53f425c531a8_19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn line_spacing() -> Result<(), DocxError> {\n    let path = std::path::Path::new(\"./tests/output/line_spacing.docx\");\n    let file = std::fs::File::create(&path).unwrap();\n    Docx::new()\n        .add_paragraph(\n            Paragraph::new()\n                .add_run(Run::new().add_text(DUMMY))\n                .line_spacing(Some(300), None, Some(300), Some(LineSpacingType::Auto)),\n        )\n        .add_paragraph(\n            Paragraph::new()\n                .add_run(Run::new().add_text(DUMMY))\n                .line_spacing(None, None, Some(300), Some(LineSpacingType::AtLeast)),\n        )\n        .add_paragraph(\n            Paragraph::new()\n                .add_run(Run::new().add_text(DUMMY).character_spacing(100))\n                .line_spacing(None, Some(300), Some(300), Some(LineSpacingType::Exact)),\n        )\n        .build()\n        .pack(file)?;\n    Ok(())\n"]], "pred": {"ppl": 1.7365776300430298, "ppl_lower": 2.315213918685913, "ppl/lowercase_ppl": -1.521067765474057, "ppl/zlib": 0.001839720990312158, "Min_5.0% Prob": 6.42081390108381, "Min_10.0% Prob": 4.356156932896581, "Min_20.0% Prob": 2.5766769304113875, "Min_30.0% Prob": 1.8230027879842303, "Min_40.0% Prob": 1.3747645455680915, "Min_50.0% Prob": 1.106474237481677, "Min_60.0% Prob": 0.9195888044258664}}
{"hexsha": "8af80106c8e9c874ac74ce54ebabea9db1974f58", "ext": "rs", "lang": "Rust", "content": "fn test_nested_prefixed_expressions() {\n    assert_eq!(\n        parse(\"++42\"),\n        Ok(Expression(UnaryPrefixOperation(\n            PlusSign,\n            Box::new(UnaryPrefixOperation(PlusSign, Box::new(Number(42f64))),),\n        )))\n    );\n    assert_eq!(\n        parse(\"+-42\"),\n        Ok(Expression(UnaryPrefixOperation(\n            PlusSign,\n            Box::new(UnaryPrefixOperation(MinusSign, Box::new(Number(42f64))),),\n        )))\n    );\n\n    assert_eq!(\n        parse(\"-+-42\"),\n        Ok(Expression(UnaryPrefixOperation(\n            MinusSign,\n            Box::new(UnaryPrefixOperation(\n                PlusSign,\n                Box::new(UnaryPrefixOperation(MinusSign, Box::new(Number(42f64))),),\n            )),\n        )))\n    );\n}", "item_id": 2, "repo": "MoritzKn/ralculator", "file": "src/parser/test.rs", "last_update_at": "2022-01-04T22:30:21+00:00", "question_id": "8af80106c8e9c874ac74ce54ebabea9db1974f58_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_nested_prefixed_expressions() {\n    assert_eq!(\n        parse(\"++42\"),\n        Ok(Expression(UnaryPrefixOperation(\n            PlusSign,\n            Box::new(UnaryPrefixOperation(PlusSign, Box::new(Number(42f64))),),\n        )))\n    );\n    assert_eq!(\n        parse(\"+-42\"),\n        Ok(Expression(UnaryPrefixOperation(\n            PlusSign,\n            Box::new(UnaryPrefixOperation(MinusSign, Box::new(Number(42f64))),),\n        )))\n    );\n    assert_eq!(\n        parse(\"-+-42\"),\n        Ok(Expression(UnaryPrefixOperation(\n            MinusSign,\n            Box::new(UnaryPrefixOperation(\n                PlusSign,\n                Box::new(UnaryPrefixOperation(MinusSign, Box::new(Number(42f64))),),\n            )),\n        )))\n    );\n"]], "pred": {"ppl": 1.7200820446014404, "ppl_lower": 2.020045757293701, "ppl/lowercase_ppl": -1.2963799314814428, "ppl/zlib": 0.00286969306898101, "Min_5.0% Prob": 5.726802110671997, "Min_10.0% Prob": 4.197842919308206, "Min_20.0% Prob": 2.644306550855222, "Min_30.0% Prob": 1.8118683183970659, "Min_40.0% Prob": 1.3658058018545094, "Min_50.0% Prob": 1.0843377848003253, "Min_60.0% Prob": 0.9051589553358315}}
{"hexsha": "e112cbf8f2863098273dd72f928af9f8a27fff8d", "ext": "rs", "lang": "Rust", "content": "fn if_else() {\n        /*\n        if abc == 1 {\n            xyz == 1;\n        } else if abc == 2{\n            xyz == 2;\n        } else {\n            xyz == 3;\n        }\n        */\n\n        let condition1 = Condition {\n            span: Span::new(),\n            lhs: make_identifier!(\"abc\"),\n            op: ConditionOp::Equals,\n            rhs: Value::NumericLiteral(1),\n        };\n        let condition2 = Condition {\n            span: Span::new(),\n            lhs: make_identifier!(\"abc\"),\n            op: ConditionOp::Equals,\n            rhs: Value::NumericLiteral(2),\n        };\n        let statement1 = Statement::ConditionStatement {\n            span: Span::new(),\n            condition: Condition {\n                span: Span::new(),\n                lhs: make_identifier!(\"xyz\"),\n                op: ConditionOp::Equals,\n                rhs: Value::NumericLiteral(1),\n            },\n        };\n        let statement2 = Statement::ConditionStatement {\n            span: Span::new(),\n            condition: Condition {\n                span: Span::new(),\n                lhs: make_identifier!(\"xyz\"),\n                op: ConditionOp::Equals,\n                rhs: Value::NumericLiteral(2),\n            },\n        };\n        let statement3 = Statement::ConditionStatement {\n            span: Span::new(),\n            condition: Condition {\n                span: Span::new(),\n                lhs: make_identifier!(\"xyz\"),\n                op: ConditionOp::Equals,\n                rhs: Value::NumericLiteral(3),\n            },\n        };\n\n        let statements = vec![Statement::If {\n            span: Span::new(),\n            blocks: vec![\n                (condition1.clone(), vec![statement1.clone()]),\n                (condition2.clone(), vec![statement2.clone()]),\n            ],\n            else_block: vec![statement3.clone()],\n        }];\n        let mut symbol_table = HashMap::new();\n        symbol_table.insert(\n            make_identifier!(\"abc\"),\n            Symbol::Key(\"abc\".to_string(), bind_library::ValueType::Number),\n        );\n        symbol_table.insert(\n            make_identifier!(\"xyz\"),\n            Symbol::Key(\"xyz\".to_string(), bind_library::ValueType::Number),\n        );\n\n        let instructions = compiler::compile_statements(statements, &symbol_table, false).unwrap();\n\n        // Binds when the if clause is satisfied.\n        let properties = vec![\n            Property { key: make_identifier!(\"abc\"), value: Value::NumericLiteral(1) },\n            Property { key: make_identifier!(\"xyz\"), value: Value::NumericLiteral(1) },\n        ];\n        let mut debugger = Debugger::new(&properties, &symbol_table, &instructions).unwrap();\n        assert!(debugger.evaluate_bind_rules().unwrap());\n        assert_eq!(\n            debugger.output,\n            vec![\n                DebuggerOutput::IfCondition { condition: &condition1, success: true },\n                DebuggerOutput::ConditionStatement { statement: &statement1, success: true }\n            ]\n        );\n\n        // Binds when the if else clause is satisfied.\n        let properties = vec![\n            Property { key: make_identifier!(\"abc\"), value: Value::NumericLiteral(2) },\n            Property { key: make_identifier!(\"xyz\"), value: Value::NumericLiteral(2) },\n        ];\n        let mut debugger = Debugger::new(&properties, &symbol_table, &instructions).unwrap();\n        assert!(debugger.evaluate_bind_rules().unwrap());\n        assert_eq!(\n            debugger.output,\n            vec![\n                DebuggerOutput::IfCondition { condition: &condition1, success: false },\n                DebuggerOutput::IfCondition { condition: &condition2, success: true },\n                DebuggerOutput::ConditionStatement { statement: &statement2, success: true }\n            ]\n        );\n\n        // Binds when the else clause is satisfied.\n        let properties =\n            vec![Property { key: make_identifier!(\"xyz\"), value: Value::NumericLiteral(3) }];\n        let mut debugger = Debugger::new(&properties, &symbol_table, &instructions).unwrap();\n        assert!(debugger.evaluate_bind_rules().unwrap());\n        assert_eq!(\n            debugger.output,\n            vec![\n                DebuggerOutput::IfCondition { condition: &condition1, success: false },\n                DebuggerOutput::IfCondition { condition: &condition2, success: false },\n                DebuggerOutput::ConditionStatement { statement: &statement3, success: true }\n            ]\n        );\n\n        // Doesn't bind when the device has incorrect values for the properties.\n        let properties = vec![\n            Property { key: make_identifier!(\"abc\"), value: Value::NumericLiteral(42) },\n            Property { key: make_identifier!(\"xyz\"), value: Value::NumericLiteral(42) },\n        ];\n        let mut debugger = Debugger::new(&properties, &symbol_table, &instructions).unwrap();\n        assert!(!debugger.evaluate_bind_rules().unwrap());\n        assert_eq!(\n            debugger.output,\n            vec![\n                DebuggerOutput::IfCondition { condition: &condition1, success: false },\n                DebuggerOutput::IfCondition { condition: &condition2, success: false },\n                DebuggerOutput::ConditionStatement { statement: &statement3, success: false }\n            ]\n        );\n\n        // Doesn't bind when the properties are missing in the device.\n        let properties = Vec::new();\n        let mut debugger = Debugger::new(&properties, &symbol_table, &instructions).unwrap();\n        assert!(!debugger.evaluate_bind_rules().unwrap());\n        assert_eq!(\n            debugger.output,\n            vec![\n                DebuggerOutput::IfCondition { condition: &condition1, success: false },\n                DebuggerOutput::IfCondition { condition: &condition2, success: false },\n                DebuggerOutput::ConditionStatement { statement: &statement3, success: false }\n            ]\n        );\n    }", "item_id": 5, "repo": "allansrc/fuchsia", "file": "src/devices/lib/bind/src/debugger/offline_debugger.rs", "last_update_at": "2022-03-28T07:59:06+00:00", "question_id": "e112cbf8f2863098273dd72f928af9f8a27fff8d_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn if_else() {\n        /*\n        if abc == 1 {\n            xyz == 1;\n        } else if abc == 2{\n            xyz == 2;\n        } else {\n            xyz == 3;\n        }\n        */\n        let condition1 = Condition {\n            span: Span::new(),\n            lhs: make_identifier!(\"abc\"),\n            op: ConditionOp::Equals,\n            rhs: Value::NumericLiteral(1),\n        };\n        let condition2 = Condition {\n            span: Span::new(),\n            lhs: make_identifier!(\"abc\"),\n            op: ConditionOp::Equals,\n            rhs: Value::NumericLiteral(2),\n        };\n        let statement1 = Statement::ConditionStatement {\n            span: Span::new(),\n            condition: Condition {\n                span: Span::new(),\n                lhs: make_identifier!(\"xyz\"),\n                op: ConditionOp::Equals,\n                rhs: Value::NumericLiteral(1),\n            },\n        };\n        let statement2 = Statement::ConditionStatement {\n            span: Span::new(),\n            condition: Condition {\n                span: Span::new(),\n                lhs: make_identifier!(\"xyz\"),\n                op: ConditionOp::Equals,\n                rhs: Value::NumericLiteral(2),\n            },\n        };\n        let statement3 = Statement::ConditionStatement {\n            span: Span::new(),\n            condition: Condition {\n                span: Span::new(),\n                lhs: make_identifier!(\"xyz\"),\n                op: ConditionOp::Equals,\n                rhs: Value::NumericLiteral(3),\n            },\n        };\n        let statements = vec![Statement::If {\n            span: Span::new(),\n            blocks: vec![\n                (condition1.clone(), vec![statement1.clone()]),\n                (condition2.clone(), vec![statement2.clone()]),\n            ],\n            else_block: vec![statement3.clone()],\n        }];\n        let mut symbol_table = HashMap::new();\n        symbol_table.insert(\n            make_identifier!(\"abc\"),\n            Symbol::Key(\"abc\".to_string(), bind_library::ValueType::Number),\n        );\n        symbol_table.insert(\n            make_identifier!(\"xyz\"),\n            Symbol::Key(\"xyz\".to_string(), bind_library::ValueType::Number),\n        );\n        let instructions = compiler::compile_statements(statements, &symbol_table, false).unwrap();\n        // Binds when the if clause is satisfied.\n        let properties = vec![\n            Property { key: make_identifier!(\"abc\"), value: Value::NumericLiteral(1) },\n            Property { key: make_identifier!(\"xyz\"), value: Value::NumericLiteral(1) },\n        ];\n        let mut debugger = Debugger::new(&properties, &symbol_table, &instructions).unwrap();\n        assert!(debugger.evaluate_bind_rules().unwrap());\n        assert_eq!(\n            debugger.output,\n            vec![\n                DebuggerOutput::IfCondition { condition: &condition1, success: true },\n                DebuggerOutput::ConditionStatement { statement: &statement1, success: true }\n            ]\n        );\n        // Binds when the if else clause is satisfied.\n        let properties = vec![\n            Property { key: make_identifier!(\"abc\"), value: Value::NumericLiteral(2) },\n            Property { key: make_identifier!(\"xyz\"), value: Value::NumericLiteral(2) },\n        ];\n        let mut debugger = Debugger::new(&properties, &symbol_table, &instructions).unwrap();\n        assert!(debugger.evaluate_bind_rules().unwrap());\n        assert_eq!(\n            debugger.output,\n            vec![\n                DebuggerOutput::IfCondition { condition: &condition1, success: false },\n                DebuggerOutput::IfCondition { condition: &condition2, success: true },\n                DebuggerOutput::ConditionStatement { statement: &statement2, success: true }\n            ]\n        );\n        // Binds when the else clause is satisfied.\n        let properties =\n            vec![Property { key: make_identifier!(\"xyz\"), value: Value::NumericLiteral(3) }];\n        let mut debugger = Debugger::new(&properties, &symbol_table, &instructions).unwrap();\n        assert!(debugger.evaluate_bind_rules().unwrap());\n        assert_eq!(\n            debugger.output,\n            vec![\n                DebuggerOutput::IfCondition { condition: &condition1, success: false },\n                DebuggerOutput::IfCondition { condition: &condition2, success: false },\n                DebuggerOutput::ConditionStatement { statement: &statement3, success: true }\n            ]\n        );\n        // Doesn't bind when the device has incorrect values for the properties.\n        let properties = vec![\n            Property { key: make_identifier!(\"abc\"), value: Value::NumericLiteral(42) },\n            Property { key: make_identifier!(\"xyz\"), value: Value::NumericLiteral(42) },\n        ];\n        let mut debugger = Debugger::new(&properties, &symbol_table, &instructions).unwrap();\n        assert!(!debugger.evaluate_bind_rules().unwrap());\n        assert_eq!(\n            debugger.output,\n            vec![\n                DebuggerOutput::IfCondition { condition: &condition1, success: false },\n                DebuggerOutput::IfCondition { condition: &condition2, success: false },\n                DebuggerOutput::ConditionStatement { statement: &statement3, success: false }\n            ]\n        );\n        // Doesn't bind when the properties are missing in the device.\n        let properties = Vec::new();\n        let mut debugger = Debugger::new(&properties, &symbol_table, &instructions).unwrap();\n        assert!(!debugger.evaluate_bind_rules().unwrap());\n        assert_eq!(\n            debugger.output,\n            vec![\n                DebuggerOutput::IfCondition { condition: &condition1, success: false },\n                DebuggerOutput::IfCondition { condition: &condition2, success: false },\n                DebuggerOutput::ConditionStatement { statement: &statement3, success: false }\n            ]\n        );\n"]], "pred": {"ppl": 1.4940202236175537, "ppl_lower": 1.5956439971923828, "ppl/lowercase_ppl": -1.1639143383523598, "ppl/zlib": 0.0004999634161605746, "Min_5.0% Prob": 5.093120897517485, "Min_10.0% Prob": 3.4340361976156046, "Min_20.0% Prob": 1.9674586113177093, "Min_30.0% Prob": 1.335871990234439, "Min_40.0% Prob": 1.0029466631776747, "Min_50.0% Prob": 0.8034540345521421, "Min_60.0% Prob": 0.669920651857258}}
{"hexsha": "d3bb7c75edf3e7c8839c415f4ea783450b47429b", "ext": "rs", "lang": "Rust", "content": "fn rpc_parity_set_min_gas_price() {\n\tlet miner = miner_service();\n\tlet client = client_service();\n\tlet network = network_service();\n\tlet updater = updater_service();\n\n\tlet mut io = IoHandler::new();\n\tio.extend_with(parity_set_client(&client, &miner, &updater, &network).to_delegate());\n\n\tlet request = r#\"{\"jsonrpc\": \"2.0\", \"method\": \"parity_setMinGasPrice\", \"params\":[\"0xcd1722f3947def4cf144679da39c4c32bdc35681\"], \"id\": 1}\"#;\n\tlet response = r#\"{\"jsonrpc\":\"2.0\",\"result\":true,\"id\":1}\"#;\n\n\tassert_eq!(io.handle_request_sync(request), Some(response.to_owned()));\n}", "item_id": 2, "repo": "snuspl/fluffy", "file": "openethereum/rpc/src/v1/tests/mocked/parity_set.rs", "last_update_at": "2022-02-16T09:30:15+00:00", "question_id": "d3bb7c75edf3e7c8839c415f4ea783450b47429b_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn rpc_parity_set_min_gas_price() {\n\tlet miner = miner_service();\n\tlet client = client_service();\n\tlet network = network_service();\n\tlet updater = updater_service();\n\tlet mut io = IoHandler::new();\n\tio.extend_with(parity_set_client(&client, &miner, &updater, &network).to_delegate());\n\tlet request = r#\"{\"jsonrpc\": \"2.0\", \"method\": \"parity_setMinGasPrice\", \"params\":[\"0xcd1722f3947def4cf144679da39c4c32bdc35681\"], \"id\": 1}\"#;\n\tlet response = r#\"{\"jsonrpc\":\"2.0\",\"result\":true,\"id\":1}\"#;\n\tassert_eq!(io.handle_request_sync(request), Some(response.to_owned()));\n"]], "pred": {"ppl": 2.6446993350982666, "ppl_lower": 3.2950246334075928, "ppl/lowercase_ppl": -1.226059933519375, "ppl/zlib": 0.0029382398366111584, "Min_5.0% Prob": 7.494912537661466, "Min_10.0% Prob": 5.602063458898793, "Min_20.0% Prob": 3.8156887394316654, "Min_30.0% Prob": 2.9725246463503154, "Min_40.0% Prob": 2.3663529823435114, "Min_50.0% Prob": 1.9217781512287713, "Min_60.0% Prob": 1.6215749959467995}}
{"hexsha": "35566c0b1d436852b987c6efff410545cd18a5fd", "ext": "rs", "lang": "Rust", "content": "pub fn get_padded_node_len<'a>(reader: &Reader<'a>, node_name: &str) -> usize {\n    let root = reader.struct_items();\n    let (node, _) = root.path_struct_items(node_name).next().unwrap();\n\n    let node_len = TOKEN_SIZE + node.node_name().unwrap().len();\n    let padded_node_len = node_len + (node_len % 4);\n    padded_node_len\n}", "item_id": 5, "repo": "imrank03/rustBoot", "file": "rustBoot/src/dt/patch.rs", "last_update_at": "2022-03-13T11:58:36+00:00", "question_id": "35566c0b1d436852b987c6efff410545cd18a5fd_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_padded_node_len<'a>(reader: &Reader<'a>, node_name: &str) -> usize {\n    let root = reader.struct_items();\n    let (node, _) = root.path_struct_items(node_name).next().unwrap();\n    let node_len = TOKEN_SIZE + node.node_name().unwrap().len();\n    let padded_node_len = node_len + (node_len % 4);\n    padded_node_len\n"]], "pred": {"ppl": 4.324759006500244, "ppl_lower": 5.019435882568359, "ppl/lowercase_ppl": -1.1017246442178286, "ppl/zlib": 0.007666787527701371, "Min_5.0% Prob": 9.77545690536499, "Min_10.0% Prob": 7.5601257880528765, "Min_20.0% Prob": 5.591046094894409, "Min_30.0% Prob": 4.276327616638607, "Min_40.0% Prob": 3.4363701914747558, "Min_50.0% Prob": 2.8233177026764293, "Min_60.0% Prob": 2.410399729054268}}
{"hexsha": "4f539f11575a3a4c50764185f950a5b2b7aeb8b0", "ext": "rs", "lang": "Rust", "content": "fn flush_changes(&mut self) -> Result<bool> {\n        let mut changes = self.take_changes();\n        // Sort the changes by the order in which the columns are\n        changes.sort_by_key(|a| a.get_column_index());\n\n        let column_metas = self.static_meta().get_column_meta();\n\n        let mut buffer_actions = Vec::with_capacity(self.dynamic_meta().buffers.len());\n        let mut node_changes = vec![];\n\n        let mut this_buffer_index = 0;\n        let mut this_buffer_offset = 0;\n\n        // Go over all of the pending changes, calculate target locations for those buffers\n        // and neighbouring buffers if they need to be moved.\n        changes.iter().for_each(|array_data| {\n            let column_index = array_data.get_column_index();\n            // `meta` contains the information about where to look in `self.dynamic_meta` for\n            // current offset/node information\n            let meta = &column_metas[column_index];\n\n            let buffer_start = meta.buffer_start;\n            // Depth-first is required, because this is the order in which\n            // nodes are written into memory, see `write_static_array_data` in ./arrow/ipc.rs\n            let array_datas = gather_array_datas_depth_first(array_data.get_data());\n\n            // Iterate over buffers that are not modified, but might have to be moved,\n            // because of preceding buffers which may have been moved/resized\n            if this_buffer_index != buffer_start {\n                this_buffer_offset = push_non_modify_actions(\n                    &mut buffer_actions,\n                    this_buffer_index,\n                    buffer_start - 1,\n                    this_buffer_offset,\n                    self.dynamic_meta(),\n                );\n                this_buffer_index = buffer_start;\n            }\n\n            // A column can consist of more than one node. For example a field that is\n            // List<u8> corresponds to a column with 2 nodes\n            array_datas.iter().enumerate().for_each(|(i, array_data)| {\n                let node_index = meta.node_start + i;\n                // Update Node information\n                node_changes.push((node_index, Node {\n                    null_count: array_data._null_count(),\n                    length: array_data._len(),\n                }));\n\n                // Null buffer calculation.\n                // The null buffer is always the first buffer in a column,\n                // it is found under `array_data.null_buffer()` and\n                // NOT under `array_data.buffers()[0]`\n                {\n                    let num_bytes = arrow_bit_util::ceil(array_data._len(), 8);\n                    let next_buffer_offset = self\n                        .dynamic_meta()\n                        .buffers\n                        .get(this_buffer_index + 1)\n                        .map_or_else(|| self.dynamic_meta().data_length, |v| v.offset);\n                    let new_padding = padding::maybe_new_dynamic_pad(\n                        this_buffer_offset,\n                        num_bytes,\n                        next_buffer_offset,\n                    );\n                    // Safety: A null buffer is always followed by another buffer\n                    if let Some(b) = array_data._null_buffer() {\n                        buffer_actions.push(BufferAction::Ref {\n                            index: this_buffer_index,\n                            offset: this_buffer_offset,\n                            padding: new_padding,\n                            buffer: b,\n                        });\n                    } else {\n                        // We know all values must be valid.\n                        // Hence we have to make a homogeneous\n                        // null buffer corresponding to valid values\n                        let buffer = vec![255_u8; num_bytes];\n\n                        buffer_actions.push(BufferAction::Owned {\n                            index: this_buffer_index,\n                            offset: this_buffer_offset,\n                            padding: new_padding,\n                            buffer,\n                        });\n                    }\n\n                    this_buffer_index += 1;\n                    let total_buffer_length = num_bytes + new_padding;\n                    this_buffer_offset += total_buffer_length;\n                }\n\n                // Go over offset/data buffers (these are not null buffers)\n                // Have to do `meta.buffer_counts[i] - 1` because the null buffer is separate\n                debug_assert_eq!(\n                    meta.buffer_counts[i] - 1,\n                    array_data._get_non_null_buffer_count()\n                );\n                // todo: when adding datatypes with no null buffer (the null datatype), then this\n                //   convention does not work\n                (0..meta.buffer_counts[i] - 1).for_each(|j| {\n                    let buffer = array_data._get_buffer(j);\n                    let new_len = buffer.len();\n                    let next_buffer_offset = self\n                        .dynamic_meta()\n                        .buffers\n                        .get(this_buffer_index + 1)\n                        .map_or_else(|| self.dynamic_meta().data_length, |v| v.offset);\n                    let new_padding = padding::maybe_new_dynamic_pad(\n                        this_buffer_offset,\n                        new_len,\n                        next_buffer_offset,\n                    );\n                    buffer_actions.push(BufferAction::Ref {\n                        index: this_buffer_index,\n                        offset: this_buffer_offset,\n                        padding: new_padding,\n                        buffer,\n                    });\n                    this_buffer_offset += new_len + new_padding;\n                    this_buffer_index += 1;\n                });\n            });\n        });\n\n        // There can be buffers at the end which have not been\n        // attended to yet. Create actions for them too and use\n        // the chance to update final data length\n        let last_buffer_index = self.static_meta().get_padding_meta().len() - 1;\n        self.mut_dynamic_meta().data_length = push_non_modify_actions(\n            &mut buffer_actions,\n            this_buffer_index,\n            last_buffer_index,\n            this_buffer_offset,\n            self.dynamic_meta(),\n        );\n        let data_length = self.dynamic_meta().data_length;\n        // Resize memory if needed\n        let change = self.mut_memory().set_data_length(data_length)?;\n\n        debug_assert!(self.dynamic_meta().data_length == self.memory().get_data_buffer()?.len());\n\n        // Iterate backwards over every buffer action and perform them\n        // Also update offset information in `self.dynamic_meta`\n        buffer_actions\n            .into_iter()\n            .rev()\n            .try_for_each(|action| match action {\n                BufferAction::Move {\n                    old_offset,\n                    old_total_length,\n                    new_offset,\n                    first_index,\n                    last_index,\n                } => {\n                    // We shouldn't be left-shifting buffers\n                    debug_assert!(old_offset <= new_offset);\n                    (first_index..=last_index).for_each(|j| {\n                        // To avoid the modular nature of unsigned int subtraction:\n                        self.mut_dynamic_meta().buffers[j].offset += new_offset;\n                        self.mut_dynamic_meta().buffers[j].offset -= old_offset;\n                    });\n\n                    self.mut_memory().copy_in_data_buffer_unchecked(\n                        old_offset,\n                        new_offset,\n                        old_total_length,\n                    )\n                }\n                BufferAction::Owned {\n                    index,\n                    offset,\n                    padding,\n                    buffer,\n                } => {\n                    let dynamic_meta = self.mut_dynamic_meta();\n                    dynamic_meta.buffers[index].offset = offset;\n                    dynamic_meta.buffers[index].padding = padding;\n                    dynamic_meta.buffers[index].length = buffer.len();\n                    self.mut_memory()\n                        .overwrite_in_data_buffer_unchecked_nonoverlapping(offset, &buffer)\n                }\n                BufferAction::Ref {\n                    index,\n                    offset,\n                    padding,\n                    buffer,\n                } => {\n                    let dynamic_meta = self.mut_dynamic_meta();\n                    dynamic_meta.buffers[index].offset = offset;\n                    dynamic_meta.buffers[index].padding = padding;\n                    dynamic_meta.buffers[index].length = buffer.len();\n                    self.mut_memory()\n                        .overwrite_in_data_buffer_unchecked_nonoverlapping(offset, buffer)\n                }\n            })?;\n\n        // Update `FieldNode` data with null_count/element count values\n        node_changes.into_iter().for_each(|(i, n)| {\n            self.mut_dynamic_meta().nodes[i] = n;\n        });\n\n        // Write `self.dynamic_meta` in Arrow format into the `meta_buffer` in `self.memory`\n        let dynamic_meta = self.dynamic_meta();\n        let new_data_length =\n            dynamic_meta.buffers[dynamic_meta.buffers.len() - 1].get_next_offset();\n        debug_assert!(self.static_meta().validate_lengths(self.dynamic_meta()));\n        self.mut_memory().set_data_length(new_data_length)?;\n        let meta_buffer = get_dynamic_meta_flatbuffers(self.dynamic_meta())?;\n        self.mut_memory().set_metadata(&meta_buffer)?;\n        debug_assert!(self.memory().validate_markers());\n        Ok(change.resized())\n    }", "item_id": 0, "repo": "mschrader15/hash", "file": "packages/engine/src/datastore/batch/flush.rs", "last_update_at": "2022-03-31T04:39:07+00:00", "question_id": "4f539f11575a3a4c50764185f950a5b2b7aeb8b0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn flush_changes(&mut self) -> Result<bool> {\n        let mut changes = self.take_changes();\n        // Sort the changes by the order in which the columns are\n        changes.sort_by_key(|a| a.get_column_index());\n        let column_metas = self.static_meta().get_column_meta();\n        let mut buffer_actions = Vec::with_capacity(self.dynamic_meta().buffers.len());\n        let mut node_changes = vec![];\n        let mut this_buffer_index = 0;\n        let mut this_buffer_offset = 0;\n        // Go over all of the pending changes, calculate target locations for those buffers\n        // and neighbouring buffers if they need to be moved.\n        changes.iter().for_each(|array_data| {\n            let column_index = array_data.get_column_index();\n            // `meta` contains the information about where to look in `self.dynamic_meta` for\n            // current offset/node information\n            let meta = &column_metas[column_index];\n            let buffer_start = meta.buffer_start;\n            // Depth-first is required, because this is the order in which\n            // nodes are written into memory, see `write_static_array_data` in ./arrow/ipc.rs\n            let array_datas = gather_array_datas_depth_first(array_data.get_data());\n            // Iterate over buffers that are not modified, but might have to be moved,\n            // because of preceding buffers which may have been moved/resized\n            if this_buffer_index != buffer_start {\n                this_buffer_offset = push_non_modify_actions(\n                    &mut buffer_actions,\n                    this_buffer_index,\n                    buffer_start - 1,\n                    this_buffer_offset,\n                    self.dynamic_meta(),\n                );\n                this_buffer_index = buffer_start;\n            }\n            // A column can consist of more than one node. For example a field that is\n            // List<u8> corresponds to a column with 2 nodes\n            array_datas.iter().enumerate().for_each(|(i, array_data)| {\n                let node_index = meta.node_start + i;\n                // Update Node information\n                node_changes.push((node_index, Node {\n                    null_count: array_data._null_count(),\n                    length: array_data._len(),\n                }));\n                // Null buffer calculation.\n                // The null buffer is always the first buffer in a column,\n                // it is found under `array_data.null_buffer()` and\n                // NOT under `array_data.buffers()[0]`\n                {\n                    let num_bytes = arrow_bit_util::ceil(array_data._len(), 8);\n                    let next_buffer_offset = self\n                        .dynamic_meta()\n                        .buffers\n                        .get(this_buffer_index + 1)\n                        .map_or_else(|| self.dynamic_meta().data_length, |v| v.offset);\n                    let new_padding = padding::maybe_new_dynamic_pad(\n                        this_buffer_offset,\n                        num_bytes,\n                        next_buffer_offset,\n                    );\n                    // Safety: A null buffer is always followed by another buffer\n                    if let Some(b) = array_data._null_buffer() {\n                        buffer_actions.push(BufferAction::Ref {\n                            index: this_buffer_index,\n                            offset: this_buffer_offset,\n                            padding: new_padding,\n                            buffer: b,\n                        });\n                    } else {\n                        // We know all values must be valid.\n                        // Hence we have to make a homogeneous\n                        // null buffer corresponding to valid values\n                        let buffer = vec![255_u8; num_bytes];\n                        buffer_actions.push(BufferAction::Owned {\n                            index: this_buffer_index,\n                            offset: this_buffer_offset,\n                            padding: new_padding,\n                            buffer,\n                        });\n                    }\n                    this_buffer_index += 1;\n                    let total_buffer_length = num_bytes + new_padding;\n                    this_buffer_offset += total_buffer_length;\n                }\n                // Go over offset/data buffers (these are not null buffers)\n                // Have to do `meta.buffer_counts[i] - 1` because the null buffer is separate\n                debug_assert_eq!(\n                    meta.buffer_counts[i] - 1,\n                    array_data._get_non_null_buffer_count()\n                );\n                // todo: when adding datatypes with no null buffer (the null datatype), then this\n                //   convention does not work\n                (0..meta.buffer_counts[i] - 1).for_each(|j| {\n                    let buffer = array_data._get_buffer(j);\n                    let new_len = buffer.len();\n                    let next_buffer_offset = self\n                        .dynamic_meta()\n                        .buffers\n                        .get(this_buffer_index + 1)\n                        .map_or_else(|| self.dynamic_meta().data_length, |v| v.offset);\n                    let new_padding = padding::maybe_new_dynamic_pad(\n                        this_buffer_offset,\n                        new_len,\n                        next_buffer_offset,\n                    );\n                    buffer_actions.push(BufferAction::Ref {\n                        index: this_buffer_index,\n                        offset: this_buffer_offset,\n                        padding: new_padding,\n                        buffer,\n                    });\n                    this_buffer_offset += new_len + new_padding;\n                    this_buffer_index += 1;\n                });\n            });\n        });\n        // There can be buffers at the end which have not been\n        // attended to yet. Create actions for them too and use\n        // the chance to update final data length\n        let last_buffer_index = self.static_meta().get_padding_meta().len() - 1;\n        self.mut_dynamic_meta().data_length = push_non_modify_actions(\n            &mut buffer_actions,\n            this_buffer_index,\n            last_buffer_index,\n            this_buffer_offset,\n            self.dynamic_meta(),\n        );\n        let data_length = self.dynamic_meta().data_length;\n        // Resize memory if needed\n        let change = self.mut_memory().set_data_length(data_length)?;\n        debug_assert!(self.dynamic_meta().data_length == self.memory().get_data_buffer()?.len());\n        // Iterate backwards over every buffer action and perform them\n        // Also update offset information in `self.dynamic_meta`\n        buffer_actions\n            .into_iter()\n            .rev()\n            .try_for_each(|action| match action {\n                BufferAction::Move {\n                    old_offset,\n                    old_total_length,\n                    new_offset,\n                    first_index,\n                    last_index,\n                } => {\n                    // We shouldn't be left-shifting buffers\n                    debug_assert!(old_offset <= new_offset);\n                    (first_index..=last_index).for_each(|j| {\n                        // To avoid the modular nature of unsigned int subtraction:\n                        self.mut_dynamic_meta().buffers[j].offset += new_offset;\n                        self.mut_dynamic_meta().buffers[j].offset -= old_offset;\n                    });\n                    self.mut_memory().copy_in_data_buffer_unchecked(\n                        old_offset,\n                        new_offset,\n                        old_total_length,\n                    )\n                }\n                BufferAction::Owned {\n                    index,\n                    offset,\n                    padding,\n                    buffer,\n                } => {\n                    let dynamic_meta = self.mut_dynamic_meta();\n                    dynamic_meta.buffers[index].offset = offset;\n                    dynamic_meta.buffers[index].padding = padding;\n                    dynamic_meta.buffers[index].length = buffer.len();\n                    self.mut_memory()\n                        .overwrite_in_data_buffer_unchecked_nonoverlapping(offset, &buffer)\n                }\n                BufferAction::Ref {\n                    index,\n                    offset,\n                    padding,\n                    buffer,\n                } => {\n                    let dynamic_meta = self.mut_dynamic_meta();\n                    dynamic_meta.buffers[index].offset = offset;\n                    dynamic_meta.buffers[index].padding = padding;\n                    dynamic_meta.buffers[index].length = buffer.len();\n                    self.mut_memory()\n                        .overwrite_in_data_buffer_unchecked_nonoverlapping(offset, buffer)\n                }\n            })?;\n        // Update `FieldNode` data with null_count/element count values\n        node_changes.into_iter().for_each(|(i, n)| {\n            self.mut_dynamic_meta().nodes[i] = n;\n        });\n        // Write `self.dynamic_meta` in Arrow format into the `meta_buffer` in `self.memory`\n        let dynamic_meta = self.dynamic_meta();\n        let new_data_length =\n            dynamic_meta.buffers[dynamic_meta.buffers.len() - 1].get_next_offset();\n        debug_assert!(self.static_meta().validate_lengths(self.dynamic_meta()));\n        self.mut_memory().set_data_length(new_data_length)?;\n        let meta_buffer = get_dynamic_meta_flatbuffers(self.dynamic_meta())?;\n        self.mut_memory().set_metadata(&meta_buffer)?;\n        debug_assert!(self.memory().validate_markers());\n        Ok(change.resized())\n"]], "pred": {"ppl": 3.2062714099884033, "ppl_lower": 3.3625707626342773, "ppl/lowercase_ppl": -1.040852052307312, "ppl/zlib": 0.0005030693901096186, "Min_5.0% Prob": 7.932759939455519, "Min_10.0% Prob": 6.351619000528373, "Min_20.0% Prob": 4.6044641756543925, "Min_30.0% Prob": 3.5524656712229734, "Min_40.0% Prob": 2.825376424856466, "Min_50.0% Prob": 2.3124505183759734, "Min_60.0% Prob": 1.9403630794431608}}
{"hexsha": "ad6fd265ade99544a2062b47ed15f1479d7e21b3", "ext": "rs", "lang": "Rust", "content": "fn test_lex_multi_char() {\n        let code = \"<<=<>>>=::=\".as_bytes();\n        let mut lexer = Lexer::new(code).unwrap();\n        assert_eq!(Lt, lexer.next_token().unwrap().kind);\n        assert_eq!(Le, lexer.next_token().unwrap().kind);\n        assert_eq!(Ne, lexer.next_token().unwrap().kind);\n        assert_eq!(Gt, lexer.next_token().unwrap().kind);\n        assert_eq!(Ge, lexer.next_token().unwrap().kind);\n        assert_eq!(Colon, lexer.next_token().unwrap().kind);\n        assert_eq!(ColonEq, lexer.next_token().unwrap().kind);\n        assert_eq!(Eof, lexer.next_token().unwrap().kind);\n    }", "item_id": 1, "repo": "Y-Nak/tiger-cranelift", "file": "tigerc/src/lexer.rs", "last_update_at": "2022-02-11T15:18:19+00:00", "question_id": "ad6fd265ade99544a2062b47ed15f1479d7e21b3_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_lex_multi_char() {\n        let code = \"<<=<>>>=::=\".as_bytes();\n        let mut lexer = Lexer::new(code).unwrap();\n        assert_eq!(Lt, lexer.next_token().unwrap().kind);\n        assert_eq!(Le, lexer.next_token().unwrap().kind);\n        assert_eq!(Ne, lexer.next_token().unwrap().kind);\n        assert_eq!(Gt, lexer.next_token().unwrap().kind);\n        assert_eq!(Ge, lexer.next_token().unwrap().kind);\n        assert_eq!(Colon, lexer.next_token().unwrap().kind);\n        assert_eq!(ColonEq, lexer.next_token().unwrap().kind);\n        assert_eq!(Eof, lexer.next_token().unwrap().kind);\n"]], "pred": {"ppl": 1.8201786279678345, "ppl_lower": 1.9874415397644043, "ppl/lowercase_ppl": -1.1467831433764073, "ppl/zlib": 0.003543991973418066, "Min_5.0% Prob": 6.4340332508087155, "Min_10.0% Prob": 4.928384077548981, "Min_20.0% Prob": 2.9629465498030187, "Min_30.0% Prob": 1.9924599136241148, "Min_40.0% Prob": 1.5068416396201945, "Min_50.0% Prob": 1.1975198728922645, "Min_60.0% Prob": 1.001426218194433}}
{"hexsha": "7b46989e8a44f46047cfa334ef8813c929d3a6e8", "ext": "rs", "lang": "Rust", "content": "fn call_fetch_sidechain_blocks_from_peer(\n\t\tlast_known_block_hash: H256,\n\t\tshard_identifier: H256,\n\t\tbuffer: &mut Vec<u8>,\n\t\tsidechain_bridge: Arc<dyn SidechainBridge>,\n\t) -> sgx_status_t {\n\t\tlet last_known_block_hash_encoded = last_known_block_hash.encode();\n\t\tlet shard_identifier_encoded = shard_identifier.encode();\n\n\t\tfetch_sidechain_blocks_from_peer(\n\t\t\tlast_known_block_hash_encoded.as_ptr(),\n\t\t\tlast_known_block_hash_encoded.len() as u32,\n\t\t\tshard_identifier_encoded.as_ptr(),\n\t\t\tshard_identifier_encoded.len() as u32,\n\t\t\tbuffer.as_mut_ptr(),\n\t\t\tbuffer.len() as u32,\n\t\t\tsidechain_bridge,\n\t\t)\n\t}", "item_id": 3, "repo": "ajuna-network/worker", "file": "service/src/ocall_bridge/ffi/fetch_sidechain_blocks_from_peer.rs", "last_update_at": "2022-03-14T04:23:40+00:00", "question_id": "7b46989e8a44f46047cfa334ef8813c929d3a6e8_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn call_fetch_sidechain_blocks_from_peer(\n\t\tlast_known_block_hash: H256,\n\t\tshard_identifier: H256,\n\t\tbuffer: &mut Vec<u8>,\n\t\tsidechain_bridge: Arc<dyn SidechainBridge>,\n\t) -> sgx_status_t {\n\t\tlet last_known_block_hash_encoded = last_known_block_hash.encode();\n\t\tlet shard_identifier_encoded = shard_identifier.encode();\n\t\tfetch_sidechain_blocks_from_peer(\n\t\t\tlast_known_block_hash_encoded.as_ptr(),\n\t\t\tlast_known_block_hash_encoded.len() as u32,\n\t\t\tshard_identifier_encoded.as_ptr(),\n\t\t\tshard_identifier_encoded.len() as u32,\n\t\t\tbuffer.as_mut_ptr(),\n\t\t\tbuffer.len() as u32,\n\t\t\tsidechain_bridge,\n\t\t)\n"]], "pred": {"ppl": 1.7833058834075928, "ppl_lower": 2.012711524963379, "ppl/lowercase_ppl": -1.2091969939593257, "ppl/zlib": 0.0023707740968836734, "Min_5.0% Prob": 7.001043359438579, "Min_10.0% Prob": 4.7366559076309205, "Min_20.0% Prob": 2.745186241818409, "Min_30.0% Prob": 1.9099112137571557, "Min_40.0% Prob": 1.4435059315009604, "Min_50.0% Prob": 1.155893823178846, "Min_60.0% Prob": 0.9688440622231174}}
{"hexsha": "3a8f81119edd616c79cd978d6b2c44f01b72ce61", "ext": "rs", "lang": "Rust", "content": "pub fn gen(options: Options) {\n    fs::create_dir_all(options.out_dir.join(\"src/peripherals\")).unwrap();\n    fs::create_dir_all(options.out_dir.join(\"src/chips\")).unwrap();\n\n    let mut all_peripheral_versions: HashSet<(String, String)> = HashSet::new();\n    let mut chip_core_names: Vec<String> = Vec::new();\n\n    for chip_name in &options.chips {\n        println!(\"Generating {}...\", chip_name);\n\n        let chip = load_chip(&options, chip_name);\n        for (core_index, core) in chip.cores.iter().enumerate() {\n            let chip_core_name = match chip.cores.len() {\n                1 => chip_name.clone(),\n                _ => format!(\"{}-{}\", chip_name, core.name),\n            };\n\n            chip_core_names.push(chip_core_name.clone());\n            gen_chip(\n                &options,\n                &chip_core_name,\n                &chip,\n                core,\n                core_index,\n                &mut all_peripheral_versions,\n            )\n        }\n    }\n\n    for (module, version) in all_peripheral_versions {\n        println!(\"loading {} {}\", module, version);\n\n        let regs_path = Path::new(&options.data_dir)\n            .join(\"registers\")\n            .join(&format!(\"{}_{}.yaml\", module, version));\n\n        let mut ir: ir::IR = serde_yaml::from_reader(File::open(regs_path).unwrap()).unwrap();\n\n        transform::expand_extends::ExpandExtends {}\n            .run(&mut ir)\n            .unwrap();\n\n        transform::map_names(&mut ir, |k, s| match k {\n            transform::NameKind::Block => *s = format!(\"{}\", s),\n            transform::NameKind::Fieldset => *s = format!(\"regs::{}\", s),\n            transform::NameKind::Enum => *s = format!(\"vals::{}\", s),\n            _ => {}\n        });\n\n        transform::sort::Sort {}.run(&mut ir).unwrap();\n        transform::Sanitize {}.run(&mut ir).unwrap();\n\n        let items = generate::render(&ir, &gen_opts()).unwrap();\n        let mut file = File::create(\n            options\n                .out_dir\n                .join(\"src/peripherals\")\n                .join(format!(\"{}_{}.rs\", module, version)),\n        )\n        .unwrap();\n        let data = items.to_string().replace(\"] \", \"]\\n\");\n\n        // Remove inner attributes like #![no_std]\n        let re = Regex::new(\"# *! *\\\\[.*\\\\]\").unwrap();\n        let data = re.replace_all(&data, \"\");\n        file.write_all(data.as_bytes()).unwrap();\n    }\n\n    // Generate src/lib_inner.rs\n    const PATHS_MARKER: &[u8] = b\"// GEN PATHS HERE\";\n    let librs = include_bytes!(\"assets/lib_inner.rs\");\n    let i = bytes_find(librs, PATHS_MARKER).unwrap();\n    let mut paths = String::new();\n\n    for name in chip_core_names {\n        let x = name.to_ascii_lowercase();\n        write!(\n            &mut paths,\n            \"#[cfg_attr(feature=\\\"{}\\\", path = \\\"chips/{}/mod.rs\\\")]\",\n            x, x\n        )\n        .unwrap();\n    }\n    let mut contents: Vec<u8> = Vec::new();\n    contents.extend(&librs[..i]);\n    contents.extend(paths.as_bytes());\n    contents.extend(&librs[i + PATHS_MARKER.len()..]);\n    fs::write(options.out_dir.join(\"src\").join(\"lib_inner.rs\"), &contents).unwrap();\n\n    // Generate src/lib.rs\n    const CUT_MARKER: &[u8] = b\"// GEN CUT HERE\";\n    let librs = include_bytes!(\"../../stm32-metapac/src/lib.rs\");\n    let i = bytes_find(librs, CUT_MARKER).unwrap();\n    let mut contents: Vec<u8> = Vec::new();\n    contents.extend(&librs[..i]);\n    contents.extend(b\"include!(\\\"lib_inner.rs\\\");\\n\");\n    fs::write(options.out_dir.join(\"src\").join(\"lib.rs\"), contents).unwrap();\n\n    // Generate src/common.rs\n    fs::write(\n        options.out_dir.join(\"src\").join(\"common.rs\"),\n        generate::COMMON_MODULE,\n    )\n    .unwrap();\n\n    // Generate Cargo.toml\n    const BUILDDEP_BEGIN: &[u8] = b\"# BEGIN BUILD DEPENDENCIES\";\n    const BUILDDEP_END: &[u8] = b\"# END BUILD DEPENDENCIES\";\n\n    let mut contents = include_bytes!(\"../../stm32-metapac/Cargo.toml\").to_vec();\n    let begin = bytes_find(&contents, BUILDDEP_BEGIN).unwrap();\n    let end = bytes_find(&contents, BUILDDEP_END).unwrap() + BUILDDEP_END.len();\n    contents.drain(begin..end);\n    fs::write(options.out_dir.join(\"Cargo.toml\"), contents).unwrap();\n\n    // Generate build.rs\n    fs::write(\n        options.out_dir.join(\"build.rs\"),\n        include_bytes!(\"assets/build.rs\"),\n    )\n    .unwrap();\n}", "item_id": 5, "repo": "Liamolucko/embassy", "file": "stm32-metapac-gen/src/lib.rs", "last_update_at": "2022-03-30T17:57:24+00:00", "question_id": "3a8f81119edd616c79cd978d6b2c44f01b72ce61_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn gen(options: Options) {\n    fs::create_dir_all(options.out_dir.join(\"src/peripherals\")).unwrap();\n    fs::create_dir_all(options.out_dir.join(\"src/chips\")).unwrap();\n    let mut all_peripheral_versions: HashSet<(String, String)> = HashSet::new();\n    let mut chip_core_names: Vec<String> = Vec::new();\n    for chip_name in &options.chips {\n        println!(\"Generating {}...\", chip_name);\n        let chip = load_chip(&options, chip_name);\n        for (core_index, core) in chip.cores.iter().enumerate() {\n            let chip_core_name = match chip.cores.len() {\n                1 => chip_name.clone(),\n                _ => format!(\"{}-{}\", chip_name, core.name),\n            };\n            chip_core_names.push(chip_core_name.clone());\n            gen_chip(\n                &options,\n                &chip_core_name,\n                &chip,\n                core,\n                core_index,\n                &mut all_peripheral_versions,\n            )\n        }\n    }\n    for (module, version) in all_peripheral_versions {\n        println!(\"loading {} {}\", module, version);\n        let regs_path = Path::new(&options.data_dir)\n            .join(\"registers\")\n            .join(&format!(\"{}_{}.yaml\", module, version));\n        let mut ir: ir::IR = serde_yaml::from_reader(File::open(regs_path).unwrap()).unwrap();\n        transform::expand_extends::ExpandExtends {}\n            .run(&mut ir)\n            .unwrap();\n        transform::map_names(&mut ir, |k, s| match k {\n            transform::NameKind::Block => *s = format!(\"{}\", s),\n            transform::NameKind::Fieldset => *s = format!(\"regs::{}\", s),\n            transform::NameKind::Enum => *s = format!(\"vals::{}\", s),\n            _ => {}\n        });\n        transform::sort::Sort {}.run(&mut ir).unwrap();\n        transform::Sanitize {}.run(&mut ir).unwrap();\n        let items = generate::render(&ir, &gen_opts()).unwrap();\n        let mut file = File::create(\n            options\n                .out_dir\n                .join(\"src/peripherals\")\n                .join(format!(\"{}_{}.rs\", module, version)),\n        )\n        .unwrap();\n        let data = items.to_string().replace(\"] \", \"]\\n\");\n        // Remove inner attributes like #![no_std]\n        let re = Regex::new(\"# *! *\\\\[.*\\\\]\").unwrap();\n        let data = re.replace_all(&data, \"\");\n        file.write_all(data.as_bytes()).unwrap();\n    }\n    // Generate src/lib_inner.rs\n    const PATHS_MARKER: &[u8] = b\"// GEN PATHS HERE\";\n    let librs = include_bytes!(\"assets/lib_inner.rs\");\n    let i = bytes_find(librs, PATHS_MARKER).unwrap();\n    let mut paths = String::new();\n    for name in chip_core_names {\n        let x = name.to_ascii_lowercase();\n        write!(\n            &mut paths,\n            \"#[cfg_attr(feature=\\\"{}\\\", path = \\\"chips/{}/mod.rs\\\")]\",\n            x, x\n        )\n        .unwrap();\n    }\n    let mut contents: Vec<u8> = Vec::new();\n    contents.extend(&librs[..i]);\n    contents.extend(paths.as_bytes());\n    contents.extend(&librs[i + PATHS_MARKER.len()..]);\n    fs::write(options.out_dir.join(\"src\").join(\"lib_inner.rs\"), &contents).unwrap();\n    // Generate src/lib.rs\n    const CUT_MARKER: &[u8] = b\"// GEN CUT HERE\";\n    let librs = include_bytes!(\"../../stm32-metapac/src/lib.rs\");\n    let i = bytes_find(librs, CUT_MARKER).unwrap();\n    let mut contents: Vec<u8> = Vec::new();\n    contents.extend(&librs[..i]);\n    contents.extend(b\"include!(\\\"lib_inner.rs\\\");\\n\");\n    fs::write(options.out_dir.join(\"src\").join(\"lib.rs\"), contents).unwrap();\n    // Generate src/common.rs\n    fs::write(\n        options.out_dir.join(\"src\").join(\"common.rs\"),\n        generate::COMMON_MODULE,\n    )\n    .unwrap();\n    // Generate Cargo.toml\n    const BUILDDEP_BEGIN: &[u8] = b\"# BEGIN BUILD DEPENDENCIES\";\n    const BUILDDEP_END: &[u8] = b\"# END BUILD DEPENDENCIES\";\n    let mut contents = include_bytes!(\"../../stm32-metapac/Cargo.toml\").to_vec();\n    let begin = bytes_find(&contents, BUILDDEP_BEGIN).unwrap();\n    let end = bytes_find(&contents, BUILDDEP_END).unwrap() + BUILDDEP_END.len();\n    contents.drain(begin..end);\n    fs::write(options.out_dir.join(\"Cargo.toml\"), contents).unwrap();\n    // Generate build.rs\n    fs::write(\n        options.out_dir.join(\"build.rs\"),\n        include_bytes!(\"assets/build.rs\"),\n    )\n    .unwrap();\n"]], "pred": {"ppl": 2.1205105781555176, "ppl_lower": 2.379303455352783, "ppl/lowercase_ppl": -1.1531960670217463, "ppl/zlib": 0.0005609379839100947, "Min_5.0% Prob": 6.6480576290803794, "Min_10.0% Prob": 5.0423572717928415, "Min_20.0% Prob": 3.2922575993865144, "Min_30.0% Prob": 2.402724680655143, "Min_40.0% Prob": 1.8561629031791664, "Min_50.0% Prob": 1.499860802523194, "Min_60.0% Prob": 1.25356470637303}}
{"hexsha": "04323b01537ade9c60e944be1605964e78b88da0", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn is_running(process_name: &str, print_pid: bool) -> bool {\n    let mut cmdline: Command = Command::new(String::from(\"pidof\"));\n\n    // return one PID only\n    cmdline.arg(\"--single-shot\");\n    if !print_pid {\n        // quiet mode, only set the exit code\n        cmdline.arg(\"-q\");\n    }\n\n    cmdline\n        .arg(process_name)\n        .status()\n        .expect(\"Could not execute `pidof` command.\")\n        .success()\n}", "item_id": 0, "repo": "thingsiplay/enjoy", "file": "src/settings/retroarch.rs", "last_update_at": "2022-03-14T03:52:10+00:00", "question_id": "04323b01537ade9c60e944be1605964e78b88da0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn is_running(process_name: &str, print_pid: bool) -> bool {\n    let mut cmdline: Command = Command::new(String::from(\"pidof\"));\n    // return one PID only\n    cmdline.arg(\"--single-shot\");\n    if !print_pid {\n        // quiet mode, only set the exit code\n        cmdline.arg(\"-q\");\n    }\n    cmdline\n        .arg(process_name)\n        .status()\n        .expect(\"Could not execute `pidof` command.\")\n        .success()\n"]], "pred": {"ppl": 3.7554636001586914, "ppl_lower": 4.289219856262207, "ppl/lowercase_ppl": -1.1004322445468557, "ppl/zlib": 0.005148683812016116, "Min_5.0% Prob": 8.268034934997559, "Min_10.0% Prob": 6.7948844616229715, "Min_20.0% Prob": 4.944334030151367, "Min_30.0% Prob": 3.9342604381282156, "Min_40.0% Prob": 3.201632740280845, "Min_50.0% Prob": 2.634706130710201, "Min_60.0% Prob": 2.209209723285882}}
{"hexsha": "d91ed3814ba30744bf9d2196311636223d81b5d7", "ext": "rs", "lang": "Rust", "content": "pub extern \"C\" fn all_generated_locations_for(\n    mappings: *mut Mappings<Observer>,\n    source: u32,\n    original_line: u32,\n    has_original_column: bool,\n    original_column: u32,\n) {\n    let this_scope = ();\n    let mappings = unsafe { mappings_mut(&this_scope, mappings) };\n\n    let original_column = if has_original_column {\n        Some(original_column)\n    } else {\n        None\n    };\n\n    for m in mappings.all_generated_locations_for(source, original_line, original_column) {\n        unsafe {\n            invoke_mapping_callback(m);\n        }\n    }\n}", "item_id": 8, "repo": "fitzgen/source-map-mappings", "file": "source-map-mappings-wasm-api/src/lib.rs", "last_update_at": "2022-03-26T06:43:13+00:00", "question_id": "d91ed3814ba30744bf9d2196311636223d81b5d7_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub extern \"C\" fn all_generated_locations_for(\n    mappings: *mut Mappings<Observer>,\n    source: u32,\n    original_line: u32,\n    has_original_column: bool,\n    original_column: u32,\n) {\n    let this_scope = ();\n    let mappings = unsafe { mappings_mut(&this_scope, mappings) };\n    let original_column = if has_original_column {\n        Some(original_column)\n    } else {\n        None\n    };\n    for m in mappings.all_generated_locations_for(source, original_line, original_column) {\n        unsafe {\n            invoke_mapping_callback(m);\n        }\n    }\n"]], "pred": {"ppl": 3.259601593017578, "ppl_lower": 3.602357864379883, "ppl/lowercase_ppl": -1.0846167866140715, "ppl/zlib": 0.004509942660990351, "Min_5.0% Prob": 9.652058283487955, "Min_10.0% Prob": 7.623343759112888, "Min_20.0% Prob": 5.148292124271393, "Min_30.0% Prob": 3.7969136933485665, "Min_40.0% Prob": 2.910384468019825, "Min_50.0% Prob": 2.3650831573612088, "Min_60.0% Prob": 1.9809446037670069}}
{"hexsha": "56b1907de8e056b7b6eab055838b71af6c927f97", "ext": "rs", "lang": "Rust", "content": "fn test_get_preferred_horizontal_position4() {\n        // Case 4: X is moved to left and width is truncated\n        let area = gdk::Rectangle {\n            x: 0,\n            y: 0,\n            height: 0,\n            width: 20,\n        };\n\n        let pos = gdk::Rectangle {\n            x: 15,\n            y: 0,\n            width: 0,\n            height: 0,\n        };\n\n        let width = 150;\n        let (x, w) = get_preferred_horizontal_position(&area, &pos, width);\n        assert_eq!(x, 0);\n        assert_eq!(w, 20);\n    }", "item_id": 10, "repo": "vhakulinen/gnvim", "file": "src/ui/common.rs", "last_update_at": "2022-03-31T18:56:37+00:00", "question_id": "56b1907de8e056b7b6eab055838b71af6c927f97_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_get_preferred_horizontal_position4() {\n        // Case 4: X is moved to left and width is truncated\n        let area = gdk::Rectangle {\n            x: 0,\n            y: 0,\n            height: 0,\n            width: 20,\n        };\n        let pos = gdk::Rectangle {\n            x: 15,\n            y: 0,\n            width: 0,\n            height: 0,\n        };\n        let width = 150;\n        let (x, w) = get_preferred_horizontal_position(&area, &pos, width);\n        assert_eq!(x, 0);\n        assert_eq!(w, 20);\n"]], "pred": {"ppl": 2.5742874145507812, "ppl_lower": 2.6503407955169678, "ppl/lowercase_ppl": -1.0307913587691317, "ppl/zlib": 0.004202545616022161, "Min_5.0% Prob": 7.59755818049113, "Min_10.0% Prob": 6.0508988698323565, "Min_20.0% Prob": 4.225950207975176, "Min_30.0% Prob": 3.0438866593219616, "Min_40.0% Prob": 2.333782335743308, "Min_50.0% Prob": 1.8817906900826427, "Min_60.0% Prob": 1.5735957865361814}}
{"hexsha": "4502905b1b7a3f7cbe3f42818ecf4e134856bbe4", "ext": "rs", "lang": "Rust", "content": "fn bench_circuit1(b: &mut Bencher){\n    let qiskit = QiskitPython::new().unwrap();\n    let circuit = qiskit.get_qasm_circuit(\"example\", \"example/example.qasm\").unwrap();\n    let backend_circuit = qiskit.get_backend_circuit(circuit).unwrap();\n    let mut us = UnitarySimulator::new(backend_circuit.to_string()).unwrap();\n    b.iter(|| us.run());\n}", "item_id": 0, "repo": "atilag/unitary-quantum-simulator-rust", "file": "benches/unitary-simulator.rs", "last_update_at": "2022-03-28T20:51:01+00:00", "question_id": "4502905b1b7a3f7cbe3f42818ecf4e134856bbe4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bench_circuit1(b: &mut Bencher){\n    let qiskit = QiskitPython::new().unwrap();\n    let circuit = qiskit.get_qasm_circuit(\"example\", \"example/example.qasm\").unwrap();\n    let backend_circuit = qiskit.get_backend_circuit(circuit).unwrap();\n    let mut us = UnitarySimulator::new(backend_circuit.to_string()).unwrap();\n    b.iter(|| us.run());\n"]], "pred": {"ppl": 3.527698278427124, "ppl_lower": 4.428951740264893, "ppl/lowercase_ppl": -1.1804768237966343, "ppl/zlib": 0.006634976907892391, "Min_5.0% Prob": 8.737675984700521, "Min_10.0% Prob": 7.230450073877971, "Min_20.0% Prob": 5.018196940422058, "Min_30.0% Prob": 3.767437047428555, "Min_40.0% Prob": 3.0153816267848015, "Min_50.0% Prob": 2.484183825055758, "Min_60.0% Prob": 2.1021033297810288}}
{"hexsha": "7d188a17adbe857399b198225f6e002b1072dbd4", "ext": "rs", "lang": "Rust", "content": "fn audio(synth: &mut Synth, buffer: &mut Buffer) {\n    let midi_messages: Vec<Vec<u8>> = synth.midi_receiver.try_iter().collect();\n    for message in midi_messages {\n        if message.len() == 3 {\n            let step = message[1] as f32;\n            if message[0] == 144 {\n                synth\n                    .midi\n                    .midi_pitch\n                    .set_step(&mut synth.controls, step.into());\n                synth.karplus.on(&mut synth.controls, &mut synth.state);\n            } else if message[0] == 128 {\n                synth.karplus.off(&mut synth.controls);\n            }\n        }\n    }\n\n    let sample_rate = buffer.sample_rate() as f32;\n    for frame in buffer.frames_mut() {\n        let amp = synth.rack.mono(\n            &synth.controls,\n            &mut synth.state,\n            &mut synth.outputs,\n            &mut synth.buffers,\n            sample_rate,\n        );\n\n        for channel in frame {\n            *channel = amp;\n        }\n        synth.sender.send(amp).unwrap();\n    }\n}", "item_id": 2, "repo": "reedrosenbluth/oscen", "file": "nannou-apps/src/bin/pluck.rs", "last_update_at": "2022-03-28T11:14:42+00:00", "question_id": "7d188a17adbe857399b198225f6e002b1072dbd4_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn audio(synth: &mut Synth, buffer: &mut Buffer) {\n    let midi_messages: Vec<Vec<u8>> = synth.midi_receiver.try_iter().collect();\n    for message in midi_messages {\n        if message.len() == 3 {\n            let step = message[1] as f32;\n            if message[0] == 144 {\n                synth\n                    .midi\n                    .midi_pitch\n                    .set_step(&mut synth.controls, step.into());\n                synth.karplus.on(&mut synth.controls, &mut synth.state);\n            } else if message[0] == 128 {\n                synth.karplus.off(&mut synth.controls);\n            }\n        }\n    }\n    let sample_rate = buffer.sample_rate() as f32;\n    for frame in buffer.frames_mut() {\n        let amp = synth.rack.mono(\n            &synth.controls,\n            &mut synth.state,\n            &mut synth.outputs,\n            &mut synth.buffers,\n            sample_rate,\n        );\n        for channel in frame {\n            *channel = amp;\n        }\n        synth.sender.send(amp).unwrap();\n    }\n"]], "pred": {"ppl": 2.501523733139038, "ppl_lower": 2.703220844268799, "ppl/lowercase_ppl": -1.0845718448545094, "ppl/zlib": 0.002369250747969492, "Min_5.0% Prob": 8.00003039042155, "Min_10.0% Prob": 5.841789399423907, "Min_20.0% Prob": 3.8302125834649607, "Min_30.0% Prob": 2.837064454632421, "Min_40.0% Prob": 2.226970559406665, "Min_50.0% Prob": 1.813121901548678, "Min_60.0% Prob": 1.5229826283751315}}
{"hexsha": "f92b6391027f0df4b8d36a70e78db5fd285ad730", "ext": "rs", "lang": "Rust", "content": "async fn query_outside_projection_area_of_use_produces_empty_tiles() {\n        let mut exe_ctx = MockExecutionContext::default();\n        let query_ctx = MockQueryContext::default();\n\n        let m = GdalMetaDataStatic {\n            time: Some(TimeInterval::default()),\n            params: GdalDatasetParameters {\n                file_path: PathBuf::new(),\n                rasterband_channel: 1,\n                geo_transform: GdalDatasetGeoTransform {\n                    origin_coordinate: (166_021.44, 9_329_005.188).into(),\n                    x_pixel_size: (534_994.66 - 166_021.444) / 100.,\n                    y_pixel_size: -9_329_005.18 / 100.,\n                },\n                width: 100,\n                height: 100,\n                file_not_found_handling: FileNotFoundHandling::NoData,\n                no_data_value: Some(0.),\n                properties_mapping: None,\n                gdal_open_options: None,\n                gdal_config_options: None,\n            },\n            result_descriptor: RasterResultDescriptor {\n                data_type: RasterDataType::U8,\n                spatial_reference: SpatialReference::new(SpatialReferenceAuthority::Epsg, 32636)\n                    .into(),\n                measurement: Measurement::Unitless,\n                no_data_value: Some(0.),\n            },\n        };\n\n        let id: DatasetId = InternalDatasetId::new().into();\n        exe_ctx.add_meta_data(id.clone(), Box::new(m));\n\n        exe_ctx.tiling_specification =\n            TilingSpecification::new((0.0, 0.0).into(), [600, 600].into());\n\n        let output_shape: GridShape2D = [1000, 1000].into();\n        let output_bounds =\n            SpatialPartition2D::new_unchecked((-180., 0.).into(), (180., -90.).into());\n        let time_interval = TimeInterval::new_instant(1_388_534_400_000).unwrap(); // 2014-01-01\n\n        let gdal_op = GdalSource {\n            params: GdalSourceParameters {\n                dataset: id.clone(),\n            },\n        }\n        .boxed();\n\n        let initialized_operator = RasterOperator::boxed(Reprojection {\n            params: ReprojectionParams {\n                target_spatial_reference: SpatialReference::epsg_4326(),\n            },\n            sources: SingleRasterOrVectorSource {\n                source: gdal_op.into(),\n            },\n        })\n        .initialize(&exe_ctx)\n        .await\n        .unwrap();\n\n        let x_query_resolution = output_bounds.size_x() / output_shape.axis_size_x() as f64;\n        let y_query_resolution = output_bounds.size_y() / (output_shape.axis_size_y()) as f64;\n        let spatial_resolution =\n            SpatialResolution::new_unchecked(x_query_resolution, y_query_resolution);\n\n        let qp = initialized_operator\n            .query_processor()\n            .unwrap()\n            .get_u8()\n            .unwrap();\n\n        let result = qp\n            .raster_query(\n                QueryRectangle {\n                    spatial_bounds: output_bounds,\n                    time_interval,\n                    spatial_resolution,\n                },\n                &query_ctx,\n            )\n            .await\n            .unwrap()\n            .map(Result::unwrap)\n            .collect::<Vec<_>>()\n            .await;\n\n        assert_eq!(result.len(), 4);\n\n        for r in result {\n            assert!(r.is_empty());\n        }\n    }", "item_id": 10, "repo": "2younis/geoengine", "file": "operators/src/processing/reprojection.rs", "last_update_at": "2022-03-24T14:33:00+00:00", "question_id": "f92b6391027f0df4b8d36a70e78db5fd285ad730_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn query_outside_projection_area_of_use_produces_empty_tiles() {\n        let mut exe_ctx = MockExecutionContext::default();\n        let query_ctx = MockQueryContext::default();\n        let m = GdalMetaDataStatic {\n            time: Some(TimeInterval::default()),\n            params: GdalDatasetParameters {\n                file_path: PathBuf::new(),\n                rasterband_channel: 1,\n                geo_transform: GdalDatasetGeoTransform {\n                    origin_coordinate: (166_021.44, 9_329_005.188).into(),\n                    x_pixel_size: (534_994.66 - 166_021.444) / 100.,\n                    y_pixel_size: -9_329_005.18 / 100.,\n                },\n                width: 100,\n                height: 100,\n                file_not_found_handling: FileNotFoundHandling::NoData,\n                no_data_value: Some(0.),\n                properties_mapping: None,\n                gdal_open_options: None,\n                gdal_config_options: None,\n            },\n            result_descriptor: RasterResultDescriptor {\n                data_type: RasterDataType::U8,\n                spatial_reference: SpatialReference::new(SpatialReferenceAuthority::Epsg, 32636)\n                    .into(),\n                measurement: Measurement::Unitless,\n                no_data_value: Some(0.),\n            },\n        };\n        let id: DatasetId = InternalDatasetId::new().into();\n        exe_ctx.add_meta_data(id.clone(), Box::new(m));\n        exe_ctx.tiling_specification =\n            TilingSpecification::new((0.0, 0.0).into(), [600, 600].into());\n        let output_shape: GridShape2D = [1000, 1000].into();\n        let output_bounds =\n            SpatialPartition2D::new_unchecked((-180., 0.).into(), (180., -90.).into());\n        let time_interval = TimeInterval::new_instant(1_388_534_400_000).unwrap(); // 2014-01-01\n        let gdal_op = GdalSource {\n            params: GdalSourceParameters {\n                dataset: id.clone(),\n            },\n        }\n        .boxed();\n        let initialized_operator = RasterOperator::boxed(Reprojection {\n            params: ReprojectionParams {\n                target_spatial_reference: SpatialReference::epsg_4326(),\n            },\n            sources: SingleRasterOrVectorSource {\n                source: gdal_op.into(),\n            },\n        })\n        .initialize(&exe_ctx)\n        .await\n        .unwrap();\n        let x_query_resolution = output_bounds.size_x() / output_shape.axis_size_x() as f64;\n        let y_query_resolution = output_bounds.size_y() / (output_shape.axis_size_y()) as f64;\n        let spatial_resolution =\n            SpatialResolution::new_unchecked(x_query_resolution, y_query_resolution);\n        let qp = initialized_operator\n            .query_processor()\n            .unwrap()\n            .get_u8()\n            .unwrap();\n        let result = qp\n            .raster_query(\n                QueryRectangle {\n                    spatial_bounds: output_bounds,\n                    time_interval,\n                    spatial_resolution,\n                },\n                &query_ctx,\n            )\n            .await\n            .unwrap()\n            .map(Result::unwrap)\n            .collect::<Vec<_>>()\n            .await;\n        assert_eq!(result.len(), 4);\n        for r in result {\n            assert!(r.is_empty());\n        }\n"]], "pred": {"ppl": 1.8690968751907349, "ppl_lower": 2.5080950260162354, "ppl/lowercase_ppl": -1.4701664904790934, "ppl/zlib": 0.0005415197920025786, "Min_5.0% Prob": 5.917840354582843, "Min_10.0% Prob": 4.314676062733519, "Min_20.0% Prob": 2.785554241608171, "Min_30.0% Prob": 2.0075627561488183, "Min_40.0% Prob": 1.543617264146764, "Min_50.0% Prob": 1.2476482211945692, "Min_60.0% Prob": 1.0428553028396812}}
{"hexsha": "51adc990642f5fe3d7380e0c350b6e8335eb5923", "ext": "rs", "lang": "Rust", "content": "fn range() {\n        let reader = DataReaderBuilder::default()\n            .range(-1.0..1.0)\n            .build()\n            .unwrap();\n        let mut file = NamedTempFile::new().unwrap();\n        writeln!(file, \"1.3\").unwrap();\n        writeln!(file, \"2\").unwrap();\n        writeln!(file, \"-0.5\").unwrap();\n        writeln!(file, \"0.5\").unwrap();\n        let vec = reader.read(file.path().to_str().unwrap());\n        assert_eq!(vec, [-0.5, 0.5]);\n    }", "item_id": 4, "repo": "juan-leon/lowcharts", "file": "src/read/buckets.rs", "last_update_at": "2022-03-01T01:53:24+00:00", "question_id": "51adc990642f5fe3d7380e0c350b6e8335eb5923_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn range() {\n        let reader = DataReaderBuilder::default()\n            .range(-1.0..1.0)\n            .build()\n            .unwrap();\n        let mut file = NamedTempFile::new().unwrap();\n        writeln!(file, \"1.3\").unwrap();\n        writeln!(file, \"2\").unwrap();\n        writeln!(file, \"-0.5\").unwrap();\n        writeln!(file, \"0.5\").unwrap();\n        let vec = reader.read(file.path().to_str().unwrap());\n        assert_eq!(vec, [-0.5, 0.5]);\n"]], "pred": {"ppl": 2.4215290546417236, "ppl_lower": 2.7294557094573975, "ppl/lowercase_ppl": -1.1353495532436253, "ppl/zlib": 0.004293199909719932, "Min_5.0% Prob": 7.5526043346949985, "Min_10.0% Prob": 5.734905975205558, "Min_20.0% Prob": 3.7901066253925193, "Min_30.0% Prob": 2.779100214893168, "Min_40.0% Prob": 2.1845774154724746, "Min_50.0% Prob": 1.7616005968557644, "Min_60.0% Prob": 1.4726699087768793}}
{"hexsha": "ba9177c4c780a99dd976f4d5e53230ffc5e40b89", "ext": "rs", "lang": "Rust", "content": "fn match_invalid_id() {\n        let doc = document();\n        let parent = create_element(doc.clone().downgrade(), \"h1\");\n        let child = create_element(doc.clone().downgrade(), \"button\");\n        Node::append_child(parent.clone(), child.clone());\n\n        let css = \"h1#name > button { color: red; }\";\n\n        let tokenizer = Tokenizer::new(css.chars());\n        let tokens = tokenizer.run();\n        let mut parser = Parser::<Token>::new(tokens);\n        let stylesheet = parser.parse_a_css_stylesheet();\n\n        let rule = stylesheet.first().unwrap();\n\n        match rule {\n            CSSRule::Style(style) => {\n                let selectors = &style.selectors;\n                assert!(!is_match_selectors(&child, selectors));\n            }\n        }\n    }", "item_id": 8, "repo": "ZeroX-DG/moon", "file": "components/style/src/selector_matching.rs", "last_update_at": "2022-03-29T02:27:14+00:00", "question_id": "ba9177c4c780a99dd976f4d5e53230ffc5e40b89_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn match_invalid_id() {\n        let doc = document();\n        let parent = create_element(doc.clone().downgrade(), \"h1\");\n        let child = create_element(doc.clone().downgrade(), \"button\");\n        Node::append_child(parent.clone(), child.clone());\n        let css = \"h1#name > button { color: red; }\";\n        let tokenizer = Tokenizer::new(css.chars());\n        let tokens = tokenizer.run();\n        let mut parser = Parser::<Token>::new(tokens);\n        let stylesheet = parser.parse_a_css_stylesheet();\n        let rule = stylesheet.first().unwrap();\n        match rule {\n            CSSRule::Style(style) => {\n                let selectors = &style.selectors;\n                assert!(!is_match_selectors(&child, selectors));\n            }\n        }\n"]], "pred": {"ppl": 3.105742931365967, "ppl_lower": 3.6345179080963135, "ppl/lowercase_ppl": -1.1387364755645135, "ppl/zlib": 0.003392972922533274, "Min_5.0% Prob": 7.699191093444824, "Min_10.0% Prob": 6.507506007239932, "Min_20.0% Prob": 4.682836374571157, "Min_30.0% Prob": 3.4798362135887144, "Min_40.0% Prob": 2.728158100925643, "Min_50.0% Prob": 2.226683831269588, "Min_60.0% Prob": 1.8869443873373362}}
{"hexsha": "b4aa6fd294238560ec0b536139b18353cf0107ac", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let ron_path = format!(\"{}/examples/config.{}\", env!(\"CARGO_MANIFEST_DIR\"), \"ron\");\n    match ExampleConfig::load(&ron_path) {\n        Ok(cfg) => {\n            println!(\"RON Config Result:\\n{:#?}\", cfg);\n\n            if let Err(e) = cfg.write_format(ConfigFormat::Ron, &ron_path) {\n                println!(\"Error:\\n{}\", e);\n            }\n        }\n        Err(e) => println!(\"{:?}\", e),\n    }\n\n    #[cfg(feature = \"json\")]\n    {\n        let json_path = format!(\"{}/examples/config.{}\", env!(\"CARGO_MANIFEST_DIR\"), \"json\");\n        match ExampleConfig::load(&json_path) {\n            Ok(cfg) => {\n                println!(\"JSON Config Result:\\n{:#?}\", cfg);\n\n                if let Err(e) = cfg.write_format(ConfigFormat::Json, &json_path) {\n                    println!(\"Error:\\n{}\", e);\n                }\n            }\n            Err(e) => println!(\"{:?}\", e),\n        }\n    }\n\n    #[cfg(feature = \"binary\")]\n    {\n        let binary_path = format!(\"{}/examples/config.{}\", env!(\"CARGO_MANIFEST_DIR\"), \"bin\");\n        match ExampleConfig::load(&binary_path) {\n            Ok(cfg) => {\n                println!(\"Binary Config Result:\\n{:#?}\", cfg);\n\n                if let Err(e) = cfg.write_format(ConfigFormat::Binary, &binary_path) {\n                    println!(\"Error:\\n{}\", e);\n                }\n            }\n            Err(e) => println!(\"{:?}\", e),\n        }\n    }\n}", "item_id": 0, "repo": "rdelfin/amethyst", "file": "amethyst_config/examples/main.rs", "last_update_at": "2022-03-31T09:08:50+00:00", "question_id": "b4aa6fd294238560ec0b536139b18353cf0107ac_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let ron_path = format!(\"{}/examples/config.{}\", env!(\"CARGO_MANIFEST_DIR\"), \"ron\");\n    match ExampleConfig::load(&ron_path) {\n        Ok(cfg) => {\n            println!(\"RON Config Result:\\n{:#?}\", cfg);\n            if let Err(e) = cfg.write_format(ConfigFormat::Ron, &ron_path) {\n                println!(\"Error:\\n{}\", e);\n            }\n        }\n        Err(e) => println!(\"{:?}\", e),\n    }\n    #[cfg(feature = \"json\")]\n    {\n        let json_path = format!(\"{}/examples/config.{}\", env!(\"CARGO_MANIFEST_DIR\"), \"json\");\n        match ExampleConfig::load(&json_path) {\n            Ok(cfg) => {\n                println!(\"JSON Config Result:\\n{:#?}\", cfg);\n                if let Err(e) = cfg.write_format(ConfigFormat::Json, &json_path) {\n                    println!(\"Error:\\n{}\", e);\n                }\n            }\n            Err(e) => println!(\"{:?}\", e),\n        }\n    }\n    #[cfg(feature = \"binary\")]\n    {\n        let binary_path = format!(\"{}/examples/config.{}\", env!(\"CARGO_MANIFEST_DIR\"), \"bin\");\n        match ExampleConfig::load(&binary_path) {\n            Ok(cfg) => {\n                println!(\"Binary Config Result:\\n{:#?}\", cfg);\n                if let Err(e) = cfg.write_format(ConfigFormat::Binary, &binary_path) {\n                    println!(\"Error:\\n{}\", e);\n                }\n            }\n            Err(e) => println!(\"{:?}\", e),\n        }\n    }\n"]], "pred": {"ppl": 1.4287102222442627, "ppl_lower": 1.5872437953948975, "ppl/lowercase_ppl": -1.2949416638202003, "ppl/zlib": 0.0010106858209360324, "Min_5.0% Prob": 5.413942467082631, "Min_10.0% Prob": 3.3017576242035087, "Min_20.0% Prob": 1.7682005034082315, "Min_30.0% Prob": 1.188776334775894, "Min_40.0% Prob": 0.8930539589227092, "Min_50.0% Prob": 0.7149050232112958, "Min_60.0% Prob": 0.5958957165542719}}
{"hexsha": "89eedd9db8eec7a8c9a9770825d0b041b0616466", "ext": "rs", "lang": "Rust", "content": "fn derive_field(seed_hex: &[u8; 64], suffix: &[u8]) -> Field {\n    let mut hasher = Sha256::new();\n    hasher.update(seed_hex);\n    hasher.update(suffix);\n    Field::from_be_bytes_mod_order(hasher.finalize().as_ref())\n}", "item_id": 0, "repo": "oskarth/semaphore-rs", "file": "src/identity.rs", "last_update_at": "2022-03-21T22:35:05+00:00", "question_id": "89eedd9db8eec7a8c9a9770825d0b041b0616466_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn derive_field(seed_hex: &[u8; 64], suffix: &[u8]) -> Field {\n    let mut hasher = Sha256::new();\n    hasher.update(seed_hex);\n    hasher.update(suffix);\n    Field::from_be_bytes_mod_order(hasher.finalize().as_ref())\n"]], "pred": {"ppl": 2.8376805782318115, "ppl_lower": 3.324326276779175, "ppl/lowercase_ppl": -1.151756451637668, "ppl/zlib": 0.006601183675240965, "Min_5.0% Prob": 8.947009086608887, "Min_10.0% Prob": 6.82782424820794, "Min_20.0% Prob": 4.592549410131243, "Min_30.0% Prob": 3.3199427359633975, "Min_40.0% Prob": 2.5746449538403087, "Min_50.0% Prob": 2.0914541459745832, "Min_60.0% Prob": 1.7534505776647065}}
{"hexsha": "1311f5f7ac6f38b5de162388caa8ef01656946cd", "ext": "rs", "lang": "Rust", "content": "fn init(env: NapiEnv, mut exports: JsObject) -> NapiResult<()> {\n    let obj = env.object()?;\n\n    obj.define_properties(&[DescriptorValueBuilder::new()\n        .with_utf8name(\"myvalue\")\n        .with_value(env.string(\"myvalue\")?)\n        .build()?])?;\n\n    obj.define_properties(&[DescriptorMethodBuilder::new()\n        .with_utf8name(\"mymethod\")\n        .with_method(move |this, ()| this.env().double(200.))\n        .build()?])?;\n\n    let value = Arc::new(Mutex::new(0.));\n    let value2 = value.clone();\n\n    obj.define_properties(&[DescriptorAccessorBuilder::new()\n        .with_utf8name(\"myaccessor\")\n        .with_getter(move |this| this.env().double(*value.lock().unwrap()))\n        .with_setter(move |_this: JsObject, n: JsNumber| {\n            let mut value = value2.lock().unwrap();\n            *value = n.get_value_double()?;\n            Ok(())\n        })\n        .build()?])?;\n\n    exports.set(\"obj\", obj)?;\n\n    Ok(())\n}", "item_id": 0, "repo": "uuhan/nodex", "file": "examples/descriptor/src/lib.rs", "last_update_at": "2022-03-04T04:37:59+00:00", "question_id": "1311f5f7ac6f38b5de162388caa8ef01656946cd_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn init(env: NapiEnv, mut exports: JsObject) -> NapiResult<()> {\n    let obj = env.object()?;\n    obj.define_properties(&[DescriptorValueBuilder::new()\n        .with_utf8name(\"myvalue\")\n        .with_value(env.string(\"myvalue\")?)\n        .build()?])?;\n    obj.define_properties(&[DescriptorMethodBuilder::new()\n        .with_utf8name(\"mymethod\")\n        .with_method(move |this, ()| this.env().double(200.))\n        .build()?])?;\n    let value = Arc::new(Mutex::new(0.));\n    let value2 = value.clone();\n    obj.define_properties(&[DescriptorAccessorBuilder::new()\n        .with_utf8name(\"myaccessor\")\n        .with_getter(move |this| this.env().double(*value.lock().unwrap()))\n        .with_setter(move |_this: JsObject, n: JsNumber| {\n            let mut value = value2.lock().unwrap();\n            *value = n.get_value_double()?;\n            Ok(())\n        })\n        .build()?])?;\n    exports.set(\"obj\", obj)?;\n    Ok(())\n"]], "pred": {"ppl": 2.1744189262390137, "ppl_lower": 2.812600612640381, "ppl/lowercase_ppl": -1.331309008252916, "ppl/zlib": 0.002028097828974112, "Min_5.0% Prob": 7.155272483825684, "Min_10.0% Prob": 5.4646104872226715, "Min_20.0% Prob": 3.5258560432121158, "Min_30.0% Prob": 2.5070613905166588, "Min_40.0% Prob": 1.9193600985454395, "Min_50.0% Prob": 1.547556077572517, "Min_60.0% Prob": 1.2928279943395562}}
{"hexsha": "77126f80e354ba337c44351fb14bf3807ae902a2", "ext": "rs", "lang": "Rust", "content": "fn reading_hashmap_set_from_lua_works() {\n        let mut lua = Lua::new();\n\n        lua.execute::<()>(r#\"v = { [1] = 2, [2] = 3, [3] = 4 }\"#).unwrap();\n\n        let read: HashMap<_, _> = lua.get(\"v\").unwrap();\n        assert_eq!(\n            read,\n            [2., 3., 4.].iter().enumerate()\n                .map(|(k, v)| (AnyHashableLuaValue::LuaNumber((k + 1) as i32), AnyLuaValue::LuaNumber(*v))).collect::<HashMap<_, _>>());\n    }", "item_id": 18, "repo": "Fuwn/hlua", "file": "hlua/src/rust_tables.rs", "last_update_at": "2022-03-03T12:26:24+00:00", "question_id": "77126f80e354ba337c44351fb14bf3807ae902a2_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn reading_hashmap_set_from_lua_works() {\n        let mut lua = Lua::new();\n        lua.execute::<()>(r#\"v = { [1] = 2, [2] = 3, [3] = 4 }\"#).unwrap();\n        let read: HashMap<_, _> = lua.get(\"v\").unwrap();\n        assert_eq!(\n            read,\n            [2., 3., 4.].iter().enumerate()\n                .map(|(k, v)| (AnyHashableLuaValue::LuaNumber((k + 1) as i32), AnyLuaValue::LuaNumber(*v))).collect::<HashMap<_, _>>());\n"]], "pred": {"ppl": 2.7890310287475586, "ppl_lower": 3.554891347885132, "ppl/lowercase_ppl": -1.2365522370896918, "ppl/zlib": 0.0037571217362123077, "Min_5.0% Prob": 8.681639075279236, "Min_10.0% Prob": 6.519840605118695, "Min_20.0% Prob": 4.354829500703251, "Min_30.0% Prob": 3.2298968282400393, "Min_40.0% Prob": 2.49581883178241, "Min_50.0% Prob": 2.039523996412754, "Min_60.0% Prob": 1.7172318934960273}}
{"hexsha": "ac096c0c3ed3e5b617cbc97791f86f7d40c63540", "ext": "rs", "lang": "Rust", "content": "fn commit_should_work() {\n\t\tlet mut ext = TestExternalities::<Blake2Hasher>::default();\n\t\text.set_storage(b\"doe\".to_vec(), b\"reindeer\".to_vec());\n\t\text.set_storage(b\"dog\".to_vec(), b\"puppy\".to_vec());\n\t\text.set_storage(b\"dogglesworth\".to_vec(), b\"cat\".to_vec());\n\t\tconst ROOT: [u8; 32] = hex!(\"0b33ed94e74e0f8e92a55923bece1ed02d16cf424e124613ddebc53ac3eeeabe\");\n\t\tassert_eq!(ext.storage_root(), H256::from(ROOT));\n\t}", "item_id": 0, "repo": "wm5713/blogs", "file": "learn substrate/substrate-1.0/core/state-machine/src/testing.rs", "last_update_at": "2022-02-14T16:09:57+00:00", "question_id": "ac096c0c3ed3e5b617cbc97791f86f7d40c63540_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn commit_should_work() {\n\t\tlet mut ext = TestExternalities::<Blake2Hasher>::default();\n\t\text.set_storage(b\"doe\".to_vec(), b\"reindeer\".to_vec());\n\t\text.set_storage(b\"dog\".to_vec(), b\"puppy\".to_vec());\n\t\text.set_storage(b\"dogglesworth\".to_vec(), b\"cat\".to_vec());\n\t\tconst ROOT: [u8; 32] = hex!(\"0b33ed94e74e0f8e92a55923bece1ed02d16cf424e124613ddebc53ac3eeeabe\");\n\t\tassert_eq!(ext.storage_root(), H256::from(ROOT));\n"]], "pred": {"ppl": 4.2680559158325195, "ppl_lower": 5.862088680267334, "ppl/lowercase_ppl": -1.2186856569743958, "ppl/zlib": 0.005455482836589531, "Min_5.0% Prob": 8.2968168258667, "Min_10.0% Prob": 6.97806487083435, "Min_20.0% Prob": 5.076710712618944, "Min_30.0% Prob": 4.21545055220204, "Min_40.0% Prob": 3.511056957474674, "Min_50.0% Prob": 2.882409936676805, "Min_60.0% Prob": 2.4326996118911812}}
{"hexsha": "2cecf69f696d8608c50dbf9dd4a7e2c2d038c650", "ext": "rs", "lang": "Rust", "content": "fn test_basic_expansion() {\n        let case = MacroCase {\n            args: vec![\n                MacroPattern::Syntax(\"test\".to_string()),\n                MacroPattern::Single(\"a\".to_string()),\n                MacroPattern::Single(\"b\".to_string()),\n                MacroPattern::Single(\"c\".to_string()),\n            ],\n            body: List::new(vec![\n                atom_identifier(\"fun-call\"),\n                atom_identifier(\"inserted-variable\"),\n                atom_identifier(\"a\"),\n                atom_identifier(\"b\"),\n                atom_identifier(\"c\"),\n            ])\n            .into(),\n        };\n\n        let input = List::new(vec![\n            atom_identifier(\"test\"),\n            atom_int(1),\n            atom_identifier(\"apple\"),\n            atom_int(2),\n        ]);\n\n        let expected: ExprKind = List::new(vec![\n            atom_identifier(\"fun-call\"),\n            atom_identifier(\"inserted-variable\"),\n            atom_int(1),\n            atom_identifier(\"apple\"),\n            atom_int(2),\n        ])\n        .into();\n\n        let output = case.expand(input, Span::new(0, 0)).unwrap();\n\n        assert_eq!(output, expected);\n    }", "item_id": 12, "repo": "mattwparas/Rucket", "file": "steel/src/parser/expander.rs", "last_update_at": "2022-03-27T22:44:14+00:00", "question_id": "2cecf69f696d8608c50dbf9dd4a7e2c2d038c650_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_basic_expansion() {\n        let case = MacroCase {\n            args: vec![\n                MacroPattern::Syntax(\"test\".to_string()),\n                MacroPattern::Single(\"a\".to_string()),\n                MacroPattern::Single(\"b\".to_string()),\n                MacroPattern::Single(\"c\".to_string()),\n            ],\n            body: List::new(vec![\n                atom_identifier(\"fun-call\"),\n                atom_identifier(\"inserted-variable\"),\n                atom_identifier(\"a\"),\n                atom_identifier(\"b\"),\n                atom_identifier(\"c\"),\n            ])\n            .into(),\n        };\n        let input = List::new(vec![\n            atom_identifier(\"test\"),\n            atom_int(1),\n            atom_identifier(\"apple\"),\n            atom_int(2),\n        ]);\n        let expected: ExprKind = List::new(vec![\n            atom_identifier(\"fun-call\"),\n            atom_identifier(\"inserted-variable\"),\n            atom_int(1),\n            atom_identifier(\"apple\"),\n            atom_int(2),\n        ])\n        .into();\n        let output = case.expand(input, Span::new(0, 0)).unwrap();\n        assert_eq!(output, expected);\n"]], "pred": {"ppl": 2.134861946105957, "ppl_lower": 2.6379518508911133, "ppl/lowercase_ppl": -1.279008790303792, "ppl/zlib": 0.002305173198615323, "Min_5.0% Prob": 7.56403652826945, "Min_10.0% Prob": 5.799343419075012, "Min_20.0% Prob": 3.503569514552752, "Min_30.0% Prob": 2.4708951344092687, "Min_40.0% Prob": 1.8787511149960117, "Min_50.0% Prob": 1.5166793795956286, "Min_60.0% Prob": 1.268380864976149}}
{"hexsha": "d0b5b7c8dd58bbba9369419690d50cafc247e18c", "ext": "rs", "lang": "Rust", "content": "fn open_file_with(path: &str, opts: Vec<OpenOptions>) -> IO<GluonFile> {\n    let mut open_with = fs::OpenOptions::new();\n\n    for opt in opts {\n        match opt {\n            OpenOptions::Read => open_with.read(true),\n            OpenOptions::Write => open_with.write(true),\n            OpenOptions::Append => open_with.append(true),\n            OpenOptions::Truncate => open_with.truncate(true),\n            OpenOptions::Create => open_with.create(true),\n            OpenOptions::CreateNew => open_with.create_new(true),\n        };\n    }\n\n    open_with\n        .open(path)\n        .map(|file| GluonFile(Mutex::new(Some(file))))\n        .into()\n}", "item_id": 0, "repo": "sandkoan/gluon", "file": "src/std_lib/io.rs", "last_update_at": "2022-03-31T18:35:43+00:00", "question_id": "d0b5b7c8dd58bbba9369419690d50cafc247e18c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn open_file_with(path: &str, opts: Vec<OpenOptions>) -> IO<GluonFile> {\n    let mut open_with = fs::OpenOptions::new();\n    for opt in opts {\n        match opt {\n            OpenOptions::Read => open_with.read(true),\n            OpenOptions::Write => open_with.write(true),\n            OpenOptions::Append => open_with.append(true),\n            OpenOptions::Truncate => open_with.truncate(true),\n            OpenOptions::Create => open_with.create(true),\n            OpenOptions::CreateNew => open_with.create_new(true),\n        };\n    }\n    open_with\n        .open(path)\n        .map(|file| GluonFile(Mutex::new(Some(file))))\n        .into()\n"]], "pred": {"ppl": 1.7881547212600708, "ppl_lower": 2.340531826019287, "ppl/lowercase_ppl": -1.4631818460020936, "ppl/zlib": 0.00225265196182466, "Min_5.0% Prob": 6.280663776397705, "Min_10.0% Prob": 4.531637877225876, "Min_20.0% Prob": 2.772567683458328, "Min_30.0% Prob": 1.9221708121399084, "Min_40.0% Prob": 1.455651439796202, "Min_50.0% Prob": 1.1668605658784508, "Min_60.0% Prob": 0.973114886249338}}
{"hexsha": "e880f876f91a94a74444433184a987b176ed7ce9", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    copy_after_move();\n    move_after_move();\n    borrow_after_move();\n\n    move_after_borrow();\n\n    copy_after_mut_borrow();\n    move_after_mut_borrow();\n    borrow_after_mut_borrow();\n    mut_borrow_after_borrow();\n\n    copy_after_move_nested();\n    move_after_move_nested();\n    borrow_after_move_nested();\n\n    move_after_borrow_nested();\n\n    copy_after_mut_borrow_nested();\n    move_after_mut_borrow_nested();\n    borrow_after_mut_borrow_nested();\n    mut_borrow_after_borrow_nested();\n}", "item_id": 16, "repo": "ohno418/rust", "file": "src/test/ui/borrowck/borrowck-box-sensitivity.rs", "last_update_at": "2022-03-31T23:26:40+00:00", "question_id": "e880f876f91a94a74444433184a987b176ed7ce9_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    copy_after_move();\n    move_after_move();\n    borrow_after_move();\n    move_after_borrow();\n    copy_after_mut_borrow();\n    move_after_mut_borrow();\n    borrow_after_mut_borrow();\n    mut_borrow_after_borrow();\n    copy_after_move_nested();\n    move_after_move_nested();\n    borrow_after_move_nested();\n    move_after_borrow_nested();\n    copy_after_mut_borrow_nested();\n    move_after_mut_borrow_nested();\n    borrow_after_mut_borrow_nested();\n    mut_borrow_after_borrow_nested();\n"]], "pred": {"ppl": 1.6174511909484863, "ppl_lower": 1.6174511909484863, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.004040769506942687, "Min_5.0% Prob": 6.049671782387628, "Min_10.0% Prob": 4.0486521853341, "Min_20.0% Prob": 2.358121133512921, "Min_30.0% Prob": 1.6181124999291367, "Min_40.0% Prob": 1.202926093163862, "Min_50.0% Prob": 0.9662288602743462, "Min_60.0% Prob": 0.8070968416393436}}
{"hexsha": "37c4cb5bbcfed34b2a7de92da82bea807a2e2fe4", "ext": "rs", "lang": "Rust", "content": "fn can_generate_simple_enum() {\n    let mut lang = swift::Swift::new();\n    let mut g = Generator::new(\n        &mut lang,\n        Params {\n            use_marker: false,\n            swift_prefix: \"TypeShare\".to_string(),\n            java_package: \"\".to_string(),\n        },\n    );\n\n    let source = r##\"\n/// This is a comment.\npub enum Colors {\n\tRed = 0,\n\tBlue = 1,\n\tGreen = 2,\n}\n   \n\"##;\n\n    let mut out: Vec<u8> = Vec::new();\n    assert!(g.process_source(source.to_string(), &mut out).is_ok(), \"must be able to process the source\");\n    let result = String::from_utf8(out).unwrap();\n\n    let expected = format!(\n        \"/*\n Generated by typeshare {}\n*/\n\nimport Foundation\n\n/// This is a comment.\npublic enum TypeShareColors: Int, Codable {{\n\tcase Red = 0\n\tcase Blue = 1\n\tcase Green = 2\n}}\n\n\",\n        env!(\"CARGO_PKG_VERSION\")\n    );\n\n    if expected != result {\n        text_diff::print_diff(&expected, &result, \" \");\n    }\n    assert_eq!(expected, result);\n}", "item_id": 3, "repo": "1Password/typeshare", "file": "tests/swift_tests.rs", "last_update_at": "2022-02-20T01:39:55+00:00", "question_id": "37c4cb5bbcfed34b2a7de92da82bea807a2e2fe4_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn can_generate_simple_enum() {\n    let mut lang = swift::Swift::new();\n    let mut g = Generator::new(\n        &mut lang,\n        Params {\n            use_marker: false,\n            swift_prefix: \"TypeShare\".to_string(),\n            java_package: \"\".to_string(),\n        },\n    );\n    let source = r##\"\n/// This is a comment.\npub enum Colors {\n\tRed = 0,\n\tBlue = 1,\n\tGreen = 2,\n}\n\"##;\n    let mut out: Vec<u8> = Vec::new();\n    assert!(g.process_source(source.to_string(), &mut out).is_ok(), \"must be able to process the source\");\n    let result = String::from_utf8(out).unwrap();\n    let expected = format!(\n        \"/*\n Generated by typeshare {}\n*/\nimport Foundation\n/// This is a comment.\npublic enum TypeShareColors: Int, Codable {{\n\tcase Red = 0\n\tcase Blue = 1\n\tcase Green = 2\n}}\n\",\n        env!(\"CARGO_PKG_VERSION\")\n    );\n    if expected != result {\n        text_diff::print_diff(&expected, &result, \" \");\n    }\n    assert_eq!(expected, result);\n"]], "pred": {"ppl": 2.754805088043213, "ppl_lower": 3.532078742980957, "ppl/lowercase_ppl": -1.245266390111514, "ppl/zlib": 0.002010608515199253, "Min_5.0% Prob": 8.160057216882706, "Min_10.0% Prob": 6.421638214226925, "Min_20.0% Prob": 4.244327250755195, "Min_30.0% Prob": 3.155586017502679, "Min_40.0% Prob": 2.4549333164118288, "Min_50.0% Prob": 2.0083934135106674, "Min_60.0% Prob": 1.6902419385224132}}
{"hexsha": "0147b962adede16e0c5ac55fd62e2ebaf3ba4f6b", "ext": "rs", "lang": "Rust", "content": "pub async fn download_json(\n    client: &reqwest::Client,\n    urls: Vec<String>,\n) -> Result<Vec<serde_json::Value>, Box<dyn Error>> {\n    let vers: Vec<Result<serde_json::Value, Box<dyn Error>>> =\n        future::join_all(urls.into_iter().map(|url| async move {\n            let json = client\n                .get(url)\n                .send()\n                .await?\n                .error_for_status()?\n                .json()\n                .await?;\n            Ok(json)\n        }))\n        .await;\n\n    let mut vers2: Vec<serde_json::Value> = vec![];\n\n    for v in vers {\n        match v {\n            Ok(v) => vers2.push(v),\n            Err(e) => bail!(\"Cannot download JSON: {}\", e.to_string()),\n        };\n    }\n\n    Ok(vers2)\n}", "item_id": 4, "repo": "gaborcsardi/rim", "file": "src/download.rs", "last_update_at": "2022-03-26T04:25:34+00:00", "question_id": "0147b962adede16e0c5ac55fd62e2ebaf3ba4f6b_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn download_json(\n    client: &reqwest::Client,\n    urls: Vec<String>,\n) -> Result<Vec<serde_json::Value>, Box<dyn Error>> {\n    let vers: Vec<Result<serde_json::Value, Box<dyn Error>>> =\n        future::join_all(urls.into_iter().map(|url| async move {\n            let json = client\n                .get(url)\n                .send()\n                .await?\n                .error_for_status()?\n                .json()\n                .await?;\n            Ok(json)\n        }))\n        .await;\n    let mut vers2: Vec<serde_json::Value> = vec![];\n    for v in vers {\n        match v {\n            Ok(v) => vers2.push(v),\n            Err(e) => bail!(\"Cannot download JSON: {}\", e.to_string()),\n        };\n    }\n    Ok(vers2)\n"]], "pred": {"ppl": 1.7289549112319946, "ppl_lower": 2.1135926246643066, "ppl/lowercase_ppl": -1.366878087411641, "ppl/zlib": 0.0015336614241330015, "Min_5.0% Prob": 6.41795446655967, "Min_10.0% Prob": 4.205294826756353, "Min_20.0% Prob": 2.550815478284308, "Min_30.0% Prob": 1.8144854258213725, "Min_40.0% Prob": 1.3700265696351515, "Min_50.0% Prob": 1.0939411854734487, "Min_60.0% Prob": 0.9160696841307407}}
{"hexsha": "8fd191f26a659e3244490ff32be4dc8e5ee85260", "ext": "rs", "lang": "Rust", "content": "fn test_extract_col(){\n        let m :  MatrixI64 = from_range_rw_i64(20, 20, -100, 400);\n        let v1   = m.view(2, 2, 6, 6);\n        println!(\"v1 : {}\", v1);\n        let c1 = v1.col(0);\n        let v2 = m.view(2,2, 6, 1);\n        assert_eq!(v2.to_matrix(), c1);\n    }", "item_id": 1, "repo": "TitanNotSoGreat/scirust", "file": "srmatrix/src/extract/view_extract.rs", "last_update_at": "2022-03-14T06:56:30+00:00", "question_id": "8fd191f26a659e3244490ff32be4dc8e5ee85260_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_extract_col(){\n        let m :  MatrixI64 = from_range_rw_i64(20, 20, -100, 400);\n        let v1   = m.view(2, 2, 6, 6);\n        println!(\"v1 : {}\", v1);\n        let c1 = v1.col(0);\n        let v2 = m.view(2,2, 6, 1);\n        assert_eq!(v2.to_matrix(), c1);\n"]], "pred": {"ppl": 4.56935453414917, "ppl_lower": 4.791362285614014, "ppl/lowercase_ppl": -1.0312252820623402, "ppl/zlib": 0.008833557878712386, "Min_5.0% Prob": 8.105669975280762, "Min_10.0% Prob": 6.673255076775184, "Min_20.0% Prob": 5.103041465465839, "Min_30.0% Prob": 4.181769643074427, "Min_40.0% Prob": 3.473949575653443, "Min_50.0% Prob": 2.916248239003695, "Min_60.0% Prob": 2.4909758285070076}}
{"hexsha": "2f38966370425f82e5df53f513685abc4f2a8e89", "ext": "rs", "lang": "Rust", "content": "pub fn perform_transition_protection_in() {\n    // Hack: In an actual implementation, this if condition is bad. You would want to do this unconditionally or with cmovs\n    // But that's just engineering work\n    if get_should_lfence_in() {\n        unsafe {\n            invoke_lfence();\n        }\n    }\n\n    if get_should_flush_in() {\n        unsafe {\n            btb_flush();\n        }\n    }\n\n    if get_should_switch_mpk_in() {\n        // yes, this is mpk_allow_ALL_mem not \"mpk_allow_SBX_mem\"\n        // sbx is restricted to access only sbx memory through software sandboxing\n        // mpk is only to make sure the app doesn't get tricked to accessing sbx memory at an incorrect time\n        mpk_allow_all_mem();\n    }\n}", "item_id": 3, "repo": "PLSysSec/wasmtime-spectre", "file": "cranelift-spectre/src/runtime.rs", "last_update_at": "2022-01-24T08:46:42+00:00", "question_id": "2f38966370425f82e5df53f513685abc4f2a8e89_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn perform_transition_protection_in() {\n    // Hack: In an actual implementation, this if condition is bad. You would want to do this unconditionally or with cmovs\n    // But that's just engineering work\n    if get_should_lfence_in() {\n        unsafe {\n            invoke_lfence();\n        }\n    }\n    if get_should_flush_in() {\n        unsafe {\n            btb_flush();\n        }\n    }\n    if get_should_switch_mpk_in() {\n        // yes, this is mpk_allow_ALL_mem not \"mpk_allow_SBX_mem\"\n        // sbx is restricted to access only sbx memory through software sandboxing\n        // mpk is only to make sure the app doesn't get tricked to accessing sbx memory at an incorrect time\n        mpk_allow_all_mem();\n    }\n"]], "pred": {"ppl": 10.223433494567871, "ppl_lower": 9.719411849975586, "ppl/lowercase_ppl": -0.9782519205802854, "ppl/zlib": 0.00647543868169017, "Min_5.0% Prob": 10.070154571533203, "Min_10.0% Prob": 9.148242587134952, "Min_20.0% Prob": 7.62418287853862, "Min_30.0% Prob": 6.360319570394663, "Min_40.0% Prob": 5.351718336686321, "Min_50.0% Prob": 4.523569605219254, "Min_60.0% Prob": 3.849856233096305}}
{"hexsha": "ee27432789a626ce41445807e2d273279f356e2a", "ext": "rs", "lang": "Rust", "content": "async fn main() -> Result<(), Box<dyn Error + Send + Sync>> {\n    let configuration = read_config(\"config.toml\");\n    let logging = configuration.bot.logging.enabled;\n\n    if logging {\n        LogTracer::init()?;\n\n        let base_level = configuration.bot.logging.level.as_str();\n\n        let level = match base_level {\n            \"error\" => Level::ERROR,\n            \"warn\" => Level::WARN,\n            \"info\" => Level::INFO,\n            \"debug\" => Level::DEBUG,\n            \"trace\" => Level::TRACE,\n            _ => Level::TRACE\n        };\n\n        let subscriber = FmtSubscriber::builder()\n            .with_target(false)\n            .with_max_level(level)\n            .with_env_filter(EnvFilter::from_default_env())\n            .finish();\n\n        tracing::subscriber::set_global_default(subscriber)?;\n\n        info!(\"Tracing initialized with logging level set to {}.\", level);\n    }\n\n    let appid = configuration.bot.discord.appid;\n    let token = configuration.bot.discord.token;\n    let prefix = configuration.bot.general.prefix.as_str();\n\n    let http = Http::new_with_token(&token);\n    let (owners, bot_id) = match http.get_current_application_info().await {\n        Ok(info) => {\n            let mut owners = HashSet::new();\n            owners.insert(info.owner.id);\n            (owners, info.id)\n        }\n        Err(why) => {\n            error!(\"Unable to retrieve application info: {:?}\", why);\n            return Ok(());\n        }\n    };\n\n    let framework = StandardFramework::new()\n        .configure(|configuration| {\n            configuration\n                .on_mention(Some(bot_id))\n                .prefix(prefix)\n                .ignore_webhooks(false)\n                .ignore_bots(true)\n                .no_dm_prefix(true)\n                .with_whitespace(true)\n                .owners(owners)\n                .case_insensitivity(true)\n        })\n        .after(after)\n        .prefix_only(prefix_only)\n        .on_dispatch_error(dispatch_error)\n        .group(&EXTRA_GROUP)\n        .group(&FUN_GROUP)\n        .group(&INFO_GROUP)\n        .group(&MODERATION_GROUP)\n        .group(&MUSIC_GROUP)\n        .group(&OWNER_GROUP)\n        .group(&SEARCH_GROUP)\n        .group(&SOCIAL_GROUP)\n        .group(&UTILITIES_GROUP)\n        .help(&HELP);\n\n    let mut client = ClientBuilder::new(&token)\n        .event_handler(Handler)\n        .application_id(appid)\n        .intents(GatewayIntents::all())\n        .framework(framework)\n        .await?;\n\n    {\n        let mut data = client.data.write().await;\n\n        let url = configuration.bot.database.url;\n        let pool = PgPoolOptions::new().max_connections(20).connect(&url).await?;\n        let http_client = Client::builder().user_agent(REQWEST_USER_AGENT).redirect(Policy::none()).build()?;\n\n        data.insert::<ConfigContainer>(read_config(\"config.toml\"));\n        data.insert::<DatabasePool>(pool);\n        data.insert::<ShardManagerContainer>(Arc::clone(&client.shard_manager));\n        data.insert::<ReqwestContainer>(http_client);\n\n        {\n            let id = configuration.api.music.spotify.client_id;\n            let secret = configuration.api.music.spotify.client_secret;\n            let credentials = aspotify::ClientCredentials { id, secret };\n            let spotify_client = aspotify::Client::new(credentials);\n            data.insert::<SpotifyContainer>(spotify_client);\n        }\n    }\n\n    if let Err(why) = client.start_autosharded().await {\n        eprintln!(\"An error occurred while running the client: {:?}\", why);\n    }\n\n    Ok(())\n}", "item_id": 0, "repo": "KamranMackey/Ellie", "file": "src/main.rs", "last_update_at": "2022-01-07T00:30:42+00:00", "question_id": "ee27432789a626ce41445807e2d273279f356e2a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn main() -> Result<(), Box<dyn Error + Send + Sync>> {\n    let configuration = read_config(\"config.toml\");\n    let logging = configuration.bot.logging.enabled;\n    if logging {\n        LogTracer::init()?;\n        let base_level = configuration.bot.logging.level.as_str();\n        let level = match base_level {\n            \"error\" => Level::ERROR,\n            \"warn\" => Level::WARN,\n            \"info\" => Level::INFO,\n            \"debug\" => Level::DEBUG,\n            \"trace\" => Level::TRACE,\n            _ => Level::TRACE\n        };\n        let subscriber = FmtSubscriber::builder()\n            .with_target(false)\n            .with_max_level(level)\n            .with_env_filter(EnvFilter::from_default_env())\n            .finish();\n        tracing::subscriber::set_global_default(subscriber)?;\n        info!(\"Tracing initialized with logging level set to {}.\", level);\n    }\n    let appid = configuration.bot.discord.appid;\n    let token = configuration.bot.discord.token;\n    let prefix = configuration.bot.general.prefix.as_str();\n    let http = Http::new_with_token(&token);\n    let (owners, bot_id) = match http.get_current_application_info().await {\n        Ok(info) => {\n            let mut owners = HashSet::new();\n            owners.insert(info.owner.id);\n            (owners, info.id)\n        }\n        Err(why) => {\n            error!(\"Unable to retrieve application info: {:?}\", why);\n            return Ok(());\n        }\n    };\n    let framework = StandardFramework::new()\n        .configure(|configuration| {\n            configuration\n                .on_mention(Some(bot_id))\n                .prefix(prefix)\n                .ignore_webhooks(false)\n                .ignore_bots(true)\n                .no_dm_prefix(true)\n                .with_whitespace(true)\n                .owners(owners)\n                .case_insensitivity(true)\n        })\n        .after(after)\n        .prefix_only(prefix_only)\n        .on_dispatch_error(dispatch_error)\n        .group(&EXTRA_GROUP)\n        .group(&FUN_GROUP)\n        .group(&INFO_GROUP)\n        .group(&MODERATION_GROUP)\n        .group(&MUSIC_GROUP)\n        .group(&OWNER_GROUP)\n        .group(&SEARCH_GROUP)\n        .group(&SOCIAL_GROUP)\n        .group(&UTILITIES_GROUP)\n        .help(&HELP);\n    let mut client = ClientBuilder::new(&token)\n        .event_handler(Handler)\n        .application_id(appid)\n        .intents(GatewayIntents::all())\n        .framework(framework)\n        .await?;\n    {\n        let mut data = client.data.write().await;\n        let url = configuration.bot.database.url;\n        let pool = PgPoolOptions::new().max_connections(20).connect(&url).await?;\n        let http_client = Client::builder().user_agent(REQWEST_USER_AGENT).redirect(Policy::none()).build()?;\n        data.insert::<ConfigContainer>(read_config(\"config.toml\"));\n        data.insert::<DatabasePool>(pool);\n        data.insert::<ShardManagerContainer>(Arc::clone(&client.shard_manager));\n        data.insert::<ReqwestContainer>(http_client);\n        {\n            let id = configuration.api.music.spotify.client_id;\n            let secret = configuration.api.music.spotify.client_secret;\n            let credentials = aspotify::ClientCredentials { id, secret };\n            let spotify_client = aspotify::Client::new(credentials);\n            data.insert::<SpotifyContainer>(spotify_client);\n        }\n    }\n    if let Err(why) = client.start_autosharded().await {\n        eprintln!(\"An error occurred while running the client: {:?}\", why);\n    }\n    Ok(())\n"]], "pred": {"ppl": 1.6799416542053223, "ppl_lower": 2.018404960632324, "ppl/lowercase_ppl": -1.3538222768622323, "ppl/zlib": 0.0004021388086607678, "Min_5.0% Prob": 5.484315428079343, "Min_10.0% Prob": 3.9233582861283245, "Min_20.0% Prob": 2.4306641761578764, "Min_30.0% Prob": 1.6975607625847937, "Min_40.0% Prob": 1.2880751365262897, "Min_50.0% Prob": 1.0359002722613149, "Min_60.0% Prob": 0.8649859477235627}}
{"hexsha": "3c67406a5d63db2d4a8143cc65e8de185ef05aa1", "ext": "rs", "lang": "Rust", "content": "pub fn load_cell_textures(world: &mut World) -> CellTextures {\n    let loader = world.read_resource::<Loader>();\n    let mut counts = vec![];\n    for i in 0..=8 {\n        counts.push(loader.load(\n            format!(\"cell-{}.png\", i),\n            ImageFormat::default(),\n            (),\n            &world.read_resource::<AssetStorage<Texture>>(),\n        ));\n    }\n    CellTextures {\n        counts,\n        normal: loader.load(\n            \"cell.png\",\n            ImageFormat::default(),\n            (),\n            &world.read_resource::<AssetStorage<Texture>>(),\n        ),\n        blood: loader.load(\n            \"cell-blood.png\",\n            ImageFormat::default(),\n            (),\n            &world.read_resource::<AssetStorage<Texture>>(),\n        ),\n        error: loader.load(\n            \"cell-error.png\",\n            ImageFormat::default(),\n            (),\n            &world.read_resource::<AssetStorage<Texture>>(),\n        ),\n        mine: loader.load(\n            \"cell-mine.png\",\n            ImageFormat::default(),\n            (),\n            &world.read_resource::<AssetStorage<Texture>>(),\n        ),\n        flag: loader.load(\n            \"cell-flag.png\",\n            ImageFormat::default(),\n            (),\n            &world.read_resource::<AssetStorage<Texture>>(),\n        ),\n    }\n}", "item_id": 0, "repo": "asurance/mine-tutorial", "file": "tutorial_03/src/textures/cell.rs", "last_update_at": "2022-01-14T09:35:03+00:00", "question_id": "3c67406a5d63db2d4a8143cc65e8de185ef05aa1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn load_cell_textures(world: &mut World) -> CellTextures {\n    let loader = world.read_resource::<Loader>();\n    let mut counts = vec![];\n    for i in 0..=8 {\n        counts.push(loader.load(\n            format!(\"cell-{}.png\", i),\n            ImageFormat::default(),\n            (),\n            &world.read_resource::<AssetStorage<Texture>>(),\n        ));\n    }\n    CellTextures {\n        counts,\n        normal: loader.load(\n            \"cell.png\",\n            ImageFormat::default(),\n            (),\n            &world.read_resource::<AssetStorage<Texture>>(),\n        ),\n        blood: loader.load(\n            \"cell-blood.png\",\n            ImageFormat::default(),\n            (),\n            &world.read_resource::<AssetStorage<Texture>>(),\n        ),\n        error: loader.load(\n            \"cell-error.png\",\n            ImageFormat::default(),\n            (),\n            &world.read_resource::<AssetStorage<Texture>>(),\n        ),\n        mine: loader.load(\n            \"cell-mine.png\",\n            ImageFormat::default(),\n            (),\n            &world.read_resource::<AssetStorage<Texture>>(),\n        ),\n        flag: loader.load(\n            \"cell-flag.png\",\n            ImageFormat::default(),\n            (),\n            &world.read_resource::<AssetStorage<Texture>>(),\n        ),\n    }\n"]], "pred": {"ppl": 1.5376754999160767, "ppl_lower": 1.7744899988174438, "ppl/lowercase_ppl": -1.3329085857573082, "ppl/zlib": 0.0015150417622226174, "Min_5.0% Prob": 6.190391133813297, "Min_10.0% Prob": 3.8000635385513304, "Min_20.0% Prob": 2.125952402051066, "Min_30.0% Prob": 1.4388342816904884, "Min_40.0% Prob": 1.079463663309083, "Min_50.0% Prob": 0.8628367994838477, "Min_60.0% Prob": 0.7184308361387297}}
{"hexsha": "c314c25f00a350d2358a769a61cb28fe5d3be57f", "ext": "rs", "lang": "Rust", "content": "async fn should_get_service_graph() {\n    let client = XRayClient::new(Region::UsEast1);\n\n    let time = (OffsetDateTime::now_utc().unix_timestamp() - 30) as f64; // 30 seconds in the past\n    println!(\"{:?}\", time);\n\n    let request = GetServiceGraphRequest {\n        start_time: time - 600.0,\n        end_time: time,\n        ..Default::default()\n    };\n\n    let result = client.get_service_graph(request).await;\n    println!(\"{:#?}\", result);\n    result.unwrap();\n}", "item_id": 0, "repo": "grafbase/rusoto", "file": "integration_tests/tests/xray.rs", "last_update_at": "2022-03-30T16:11:18+00:00", "question_id": "c314c25f00a350d2358a769a61cb28fe5d3be57f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn should_get_service_graph() {\n    let client = XRayClient::new(Region::UsEast1);\n    let time = (OffsetDateTime::now_utc().unix_timestamp() - 30) as f64; // 30 seconds in the past\n    println!(\"{:?}\", time);\n    let request = GetServiceGraphRequest {\n        start_time: time - 600.0,\n        end_time: time,\n        ..Default::default()\n    };\n    let result = client.get_service_graph(request).await;\n    println!(\"{:#?}\", result);\n    result.unwrap();\n"]], "pred": {"ppl": 2.6014933586120605, "ppl_lower": 3.7074148654937744, "ppl/lowercase_ppl": -1.3705203436316251, "ppl/zlib": 0.003414591602992203, "Min_5.0% Prob": 8.551968165806361, "Min_10.0% Prob": 6.512581078211467, "Min_20.0% Prob": 4.200345731550647, "Min_30.0% Prob": 3.067327269393465, "Min_40.0% Prob": 2.3486027566175305, "Min_50.0% Prob": 1.8961057686843934, "Min_60.0% Prob": 1.5993393583884161}}
{"hexsha": "4a9b1cafa156bde7c7ec9cf6f72803c89a3744b4", "ext": "rs", "lang": "Rust", "content": "fn main() {\n\n\t// variable of circle datatype\n\tlet mut circle1 = Circle {\n\t\tr : 10.0\n\t};\n\tprintln!(\"Area of circle {}\", circle1.area() );\n\t\n\t// variable of rectangle datatype\n\tlet mut rect = Rectangle {\n\t\th:10.0,b : 10.0\n\t};\n\tprintln!(\"Area of rectangle {}\", rect.area() );\n}", "item_id": 0, "repo": "Ngugisenior/studyGroupLessons", "file": "Rust-intro/code_samples/trait.rs", "last_update_at": "2022-01-28T06:37:43+00:00", "question_id": "4a9b1cafa156bde7c7ec9cf6f72803c89a3744b4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n\t// variable of circle datatype\n\tlet mut circle1 = Circle {\n\t\tr : 10.0\n\t};\n\tprintln!(\"Area of circle {}\", circle1.area() );\n\t\n\t// variable of rectangle datatype\n\tlet mut rect = Rectangle {\n\t\th:10.0,b : 10.0\n\t};\n\tprintln!(\"Area of rectangle {}\", rect.area() );\n"]], "pred": {"ppl": 2.9767751693725586, "ppl_lower": 3.129932403564453, "ppl/lowercase_ppl": -1.0459928365108182, "ppl/zlib": 0.007037681010535362, "Min_5.0% Prob": 8.076506042480469, "Min_10.0% Prob": 6.1456156969070435, "Min_20.0% Prob": 4.184054794765654, "Min_30.0% Prob": 3.26067852973938, "Min_40.0% Prob": 2.5933299355563664, "Min_50.0% Prob": 2.1542185527774005, "Min_60.0% Prob": 1.7982342329526704}}
{"hexsha": "250b75194e84bf3cafbc90f683d3599c9949052b", "ext": "rs", "lang": "Rust", "content": "fn test_new_with_default_error_rate() {\n        let mut b = BloomFilter::new_with_default_error_rate(20000, true);\n        assert_eq!(b.add(\"Test\".as_bytes()).unwrap(), true);\n        assert!(b.contains(\"Test\".as_bytes()));\n    }", "item_id": 7, "repo": "srinivasreddy/rust-bloomfilter", "file": "src/lib.rs", "last_update_at": "2022-01-31T08:47:48+00:00", "question_id": "250b75194e84bf3cafbc90f683d3599c9949052b_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_new_with_default_error_rate() {\n        let mut b = BloomFilter::new_with_default_error_rate(20000, true);\n        assert_eq!(b.add(\"Test\".as_bytes()).unwrap(), true);\n        assert!(b.contains(\"Test\".as_bytes()));\n"]], "pred": {"ppl": 3.28627610206604, "ppl_lower": 3.374385356903076, "ppl/lowercase_ppl": -1.0222383184249204, "ppl/zlib": 0.008378556618608746, "Min_5.0% Prob": 7.591635545094808, "Min_10.0% Prob": 6.287186213902065, "Min_20.0% Prob": 4.6392007827758786, "Min_30.0% Prob": 3.505283060281173, "Min_40.0% Prob": 2.8269244297858207, "Min_50.0% Prob": 2.348244995642931, "Min_60.0% Prob": 1.9845408732269674}}
{"hexsha": "c2238439db5c8b40ea7325b23ef33ef0136d69ce", "ext": "rs", "lang": "Rust", "content": "fn query() {\n        let rs = RangedStates::from_slice(&[(1..4, 1u8), (5..7, 2)]);\n        assert_eq!(rs.query(&(0..1), |v| *v), None);\n        assert_eq!(rs.query(&(1..3), |v| *v), Some(Ok(1)));\n        assert_eq!(rs.query(&(1..6), |v| *v), Some(Err(())));\n    }", "item_id": 1, "repo": "ghishadow/wgpu", "file": "wgpu-core/src/track/range.rs", "last_update_at": "2022-03-31T18:49:23+00:00", "question_id": "c2238439db5c8b40ea7325b23ef33ef0136d69ce_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn query() {\n        let rs = RangedStates::from_slice(&[(1..4, 1u8), (5..7, 2)]);\n        assert_eq!(rs.query(&(0..1), |v| *v), None);\n        assert_eq!(rs.query(&(1..3), |v| *v), Some(Ok(1)));\n        assert_eq!(rs.query(&(1..6), |v| *v), Some(Err(())));\n"]], "pred": {"ppl": 3.022249460220337, "ppl_lower": 3.678422689437866, "ppl/lowercase_ppl": -1.1776513422948893, "ppl/zlib": 0.007228767375804084, "Min_5.0% Prob": 8.233102607727051, "Min_10.0% Prob": 6.311914508992976, "Min_20.0% Prob": 4.311750194300776, "Min_30.0% Prob": 3.409096532008227, "Min_40.0% Prob": 2.7085253628699677, "Min_50.0% Prob": 2.200160604355664, "Min_60.0% Prob": 1.8570073359389452}}
{"hexsha": "29a7f2b67b9000316d825f8935d2f7aa510c0392", "ext": "rs", "lang": "Rust", "content": "async fn get_proxies_gets_proxies_with_toxics() {\n        let _lock = MOCK_LOCK.lock().await;\n        let (stop, _stopper) = Stop::new();\n        let store = Store::new(stop, None);\n        let init_ctx = MockNoopRunner::initialize_proxy_context();\n        let run_ctx = MockNoopRunner::run_proxy_context();\n        init_ctx.expect().returning(|config, _initial_toxics| {\n            let listener = MockNoopListener::default();\n            let proxy_info = SharedProxyInfo {\n                state: Arc::new(ProxyState::new(Toxics {\n                    upstream: vec![Toxic {\n                        kind: ToxicKind::Latency {\n                            latency: 500,\n                            jitter: 42,\n                        },\n                        name: format!(\"{}tox1\", config.name),\n                        toxicity: 0.67,\n                        direction: StreamDirection::Upstream,\n                    }],\n                    downstream: Vec::new(),\n                })),\n                config: Arc::new(config),\n            };\n            Ok((listener, proxy_info))\n        });\n\n        run_ctx.expect().returning(\n            move |_listener: MockNoopListener, _info, _event_receiver, _stop, _closer| Ok(()),\n        );\n\n        populate_store(&store).await;\n\n        let result = store.get_proxies().await.unwrap();\n        assert_eq!(3, result.len());\n        let p1 = result.iter().find(|el| el.proxy.name == \"foo\").unwrap();\n        let p2 = result.iter().find(|el| el.proxy.name == \"bar\").unwrap();\n        let p3 = result.iter().find(|el| el.proxy.name == \"baz\").unwrap();\n        assert_eq!(1, p1.toxics.len());\n        assert_eq!(\"footox1\", p1.toxics[0].get_name());\n        assert_eq!(\"bartox1\", p2.toxics[0].get_name());\n        assert_eq!(\"baztox1\", p3.toxics[0].get_name());\n    }", "item_id": 4, "repo": "oguzbilgener/noxious", "file": "server/src/store.rs", "last_update_at": "2022-03-22T09:14:34+00:00", "question_id": "29a7f2b67b9000316d825f8935d2f7aa510c0392_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn get_proxies_gets_proxies_with_toxics() {\n        let _lock = MOCK_LOCK.lock().await;\n        let (stop, _stopper) = Stop::new();\n        let store = Store::new(stop, None);\n        let init_ctx = MockNoopRunner::initialize_proxy_context();\n        let run_ctx = MockNoopRunner::run_proxy_context();\n        init_ctx.expect().returning(|config, _initial_toxics| {\n            let listener = MockNoopListener::default();\n            let proxy_info = SharedProxyInfo {\n                state: Arc::new(ProxyState::new(Toxics {\n                    upstream: vec![Toxic {\n                        kind: ToxicKind::Latency {\n                            latency: 500,\n                            jitter: 42,\n                        },\n                        name: format!(\"{}tox1\", config.name),\n                        toxicity: 0.67,\n                        direction: StreamDirection::Upstream,\n                    }],\n                    downstream: Vec::new(),\n                })),\n                config: Arc::new(config),\n            };\n            Ok((listener, proxy_info))\n        });\n        run_ctx.expect().returning(\n            move |_listener: MockNoopListener, _info, _event_receiver, _stop, _closer| Ok(()),\n        );\n        populate_store(&store).await;\n        let result = store.get_proxies().await.unwrap();\n        assert_eq!(3, result.len());\n        let p1 = result.iter().find(|el| el.proxy.name == \"foo\").unwrap();\n        let p2 = result.iter().find(|el| el.proxy.name == \"bar\").unwrap();\n        let p3 = result.iter().find(|el| el.proxy.name == \"baz\").unwrap();\n        assert_eq!(1, p1.toxics.len());\n        assert_eq!(\"footox1\", p1.toxics[0].get_name());\n        assert_eq!(\"bartox1\", p2.toxics[0].get_name());\n        assert_eq!(\"baztox1\", p3.toxics[0].get_name());\n"]], "pred": {"ppl": 2.4484965801239014, "ppl_lower": 2.7939634323120117, "ppl/lowercase_ppl": -1.1473933900622812, "ppl/zlib": 0.001430469960760907, "Min_5.0% Prob": 7.7455700591758445, "Min_10.0% Prob": 5.736405266655816, "Min_20.0% Prob": 3.8247436197525864, "Min_30.0% Prob": 2.8299596495017774, "Min_40.0% Prob": 2.197192152681416, "Min_50.0% Prob": 1.7800548145153228, "Min_60.0% Prob": 1.494015831994347}}
{"hexsha": "cafe015af5e186644b3fbfbd475077a46394c335", "ext": "rs", "lang": "Rust", "content": "fn test_public_xor() {\n    let seq1 = PublicByteSeq::from_hex(\"3544de28f9d7d48ee7b318f6c541ff35\");\n    let seq2 = PublicByteSeq::from_hex(\"a4b13aa347b72f6c22870170fcb0cda3\");\n\n    let xor_output = seq1 ^ seq2; // output of XOR to be checked for correctness\n    let expected = PublicByteSeq::from_hex(\"91f5e48bbe60fbe2c534198639f13296\");\n\n    assert_eq!(expected, xor_output);\n}", "item_id": 5, "repo": "tanmay2004/hacspec", "file": "lib/tests/test_public_seq.rs", "last_update_at": "2022-03-24T22:05:37+00:00", "question_id": "cafe015af5e186644b3fbfbd475077a46394c335_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_public_xor() {\n    let seq1 = PublicByteSeq::from_hex(\"3544de28f9d7d48ee7b318f6c541ff35\");\n    let seq2 = PublicByteSeq::from_hex(\"a4b13aa347b72f6c22870170fcb0cda3\");\n    let xor_output = seq1 ^ seq2; // output of XOR to be checked for correctness\n    let expected = PublicByteSeq::from_hex(\"91f5e48bbe60fbe2c534198639f13296\");\n    assert_eq!(expected, xor_output);\n"]], "pred": {"ppl": 8.413270950317383, "ppl_lower": 8.474283218383789, "ppl/lowercase_ppl": -1.0033926680580152, "ppl/zlib": 0.00902462006015842, "Min_5.0% Prob": 7.930749204423693, "Min_10.0% Prob": 6.702777253256904, "Min_20.0% Prob": 5.02433936463462, "Min_30.0% Prob": 4.329002349464981, "Min_40.0% Prob": 3.942466629876031, "Min_50.0% Prob": 3.656963403408344, "Min_60.0% Prob": 3.3992110261129675}}
{"hexsha": "5b32d1e6c1940d90f8cbee20a89569b9377e63cb", "ext": "rs", "lang": "Rust", "content": "fn get_node(ctx: &Context, args: Vec<String>) -> RedisResult {\n    ctx.auto_memory();\n\n    let mut parsed = GET_NODE_CMD.with(|cmd| cmd.parse_args(args))?;\n\n    let index_suffix = parsed.remove(\"index\").unwrap().as_string()?;\n    let node_suffix = parsed.remove(\"node\").unwrap().as_string()?;\n\n    let node_name = format!(\"{}.{}.{}\", PREFIX, index_suffix, node_suffix);\n\n    ctx.log_debug(format!(\"get key: {}\", node_name).as_str());\n\n    let key = ctx.open_key(&node_name);\n\n    let value = key\n        .get_value::<NodeRedis>(&HNSW_NODE_REDIS_TYPE)?\n        .ok_or_else(|| format!(\"Node: {} does not exist\", &node_name))?;\n\n    Ok(value.into())\n}", "item_id": 9, "repo": "zhao-lang/redis_hnsw", "file": "src/lib.rs", "last_update_at": "2022-03-29T15:25:19+00:00", "question_id": "5b32d1e6c1940d90f8cbee20a89569b9377e63cb_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_node(ctx: &Context, args: Vec<String>) -> RedisResult {\n    ctx.auto_memory();\n    let mut parsed = GET_NODE_CMD.with(|cmd| cmd.parse_args(args))?;\n    let index_suffix = parsed.remove(\"index\").unwrap().as_string()?;\n    let node_suffix = parsed.remove(\"node\").unwrap().as_string()?;\n    let node_name = format!(\"{}.{}.{}\", PREFIX, index_suffix, node_suffix);\n    ctx.log_debug(format!(\"get key: {}\", node_name).as_str());\n    let key = ctx.open_key(&node_name);\n    let value = key\n        .get_value::<NodeRedis>(&HNSW_NODE_REDIS_TYPE)?\n        .ok_or_else(|| format!(\"Node: {} does not exist\", &node_name))?;\n    Ok(value.into())\n"]], "pred": {"ppl": 3.0975043773651123, "ppl_lower": 3.599226236343384, "ppl/lowercase_ppl": -1.1327813303919982, "ppl/zlib": 0.003149294561874918, "Min_5.0% Prob": 8.263862530390421, "Min_10.0% Prob": 6.414840579032898, "Min_20.0% Prob": 4.442590005543767, "Min_30.0% Prob": 3.421019435745396, "Min_40.0% Prob": 2.7095590203392264, "Min_50.0% Prob": 2.227186348743555, "Min_60.0% Prob": 1.8854098136783863}}
{"hexsha": "0b0affba01c6539766f8537df100100d0621917c", "ext": "rs", "lang": "Rust", "content": "fn test_gt_insensitive() {\n        let test = r#\"gT 5\"#;\n        let want = Token::Gt;\n        match scan(test).get(0) {\n            Some(t) => assert_eq!(*t, want),\n            _ => panic!(\"no token\"),\n        }\n    }", "item_id": 23, "repo": "gracig/bda", "file": "bdaindex/src/bql/scanner.rs", "last_update_at": "2022-02-04T13:44:40+00:00", "question_id": "0b0affba01c6539766f8537df100100d0621917c_23", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_gt_insensitive() {\n        let test = r#\"gT 5\"#;\n        let want = Token::Gt;\n        match scan(test).get(0) {\n            Some(t) => assert_eq!(*t, want),\n            _ => panic!(\"no token\"),\n        }\n"]], "pred": {"ppl": 4.337584495544434, "ppl_lower": 5.564789295196533, "ppl/lowercase_ppl": -1.1697938414208569, "ppl/zlib": 0.010119431898786427, "Min_5.0% Prob": 9.083741505940756, "Min_10.0% Prob": 7.447593893323626, "Min_20.0% Prob": 5.57521193822225, "Min_30.0% Prob": 4.385448310686194, "Min_40.0% Prob": 3.528068398275683, "Min_50.0% Prob": 2.904706507157057, "Min_60.0% Prob": 2.444511056104873}}
{"hexsha": "baf3f78ce9b4811ed2e529fe17ad489708b108bb", "ext": "rs", "lang": "Rust", "content": "fn test_regex_lit() {\n        assert_json_snapshot!(parse_literal(\"/abc/g\".into()).unwrap().1);\n        assert_json_snapshot!(parse_literal(r#\"/abc\\\\/g\"#.into()).unwrap().1);\n        assert_json_snapshot!(parse_literal(r#\"/\\\\\\//g\"#.into()).unwrap().1);\n        assert_json_snapshot!(parse_literal(r#\"/[^/]*$/\"#.into()).unwrap().1);\n    }", "item_id": 0, "repo": "lukechu10/almond", "file": "src/parser/regex.rs", "last_update_at": "2022-02-22T21:19:31+00:00", "question_id": "baf3f78ce9b4811ed2e529fe17ad489708b108bb_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_regex_lit() {\n        assert_json_snapshot!(parse_literal(\"/abc/g\".into()).unwrap().1);\n        assert_json_snapshot!(parse_literal(r#\"/abc\\\\/g\"#.into()).unwrap().1);\n        assert_json_snapshot!(parse_literal(r#\"/\\\\\\//g\"#.into()).unwrap().1);\n        assert_json_snapshot!(parse_literal(r#\"/[^/]*$/\"#.into()).unwrap().1);\n"]], "pred": {"ppl": 2.5293262004852295, "ppl_lower": 2.5293262004852295, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.00748349147862931, "Min_5.0% Prob": 7.4960302511851, "Min_10.0% Prob": 5.924719353516896, "Min_20.0% Prob": 4.083639492988587, "Min_30.0% Prob": 3.0290471363712, "Min_40.0% Prob": 2.3027726563811304, "Min_50.0% Prob": 1.8662785292573032, "Min_60.0% Prob": 1.5453760678445299}}
{"hexsha": "9fd8aaaaeba21fd589ff27e97e9560be85a6b6ff", "ext": "rs", "lang": "Rust", "content": "fn test_is_empty() {\n        let mut stack: Stack = Stack::new();\n        assert!(stack.is_empty());\n\n        stack.push(Value::new(\"Hello!\".to_string()));\n        stack.push(Value::new(42));\n        assert!(!stack.is_empty());\n\n        stack.pop().ok();\n        assert!(!stack.is_empty());\n\n        stack.initialize();\n        assert!(stack.is_empty());\n    }", "item_id": 3, "repo": "Pagliacii/sicp-reg-machine", "file": "src/machine/stack.rs", "last_update_at": "2022-03-05T02:48:07+00:00", "question_id": "9fd8aaaaeba21fd589ff27e97e9560be85a6b6ff_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_is_empty() {\n        let mut stack: Stack = Stack::new();\n        assert!(stack.is_empty());\n        stack.push(Value::new(\"Hello!\".to_string()));\n        stack.push(Value::new(42));\n        assert!(!stack.is_empty());\n        stack.pop().ok();\n        assert!(!stack.is_empty());\n        stack.initialize();\n        assert!(stack.is_empty());\n"]], "pred": {"ppl": 2.287893295288086, "ppl_lower": 2.4776384830474854, "ppl/lowercase_ppl": -1.0962680279507329, "ppl/zlib": 0.0054093557892499365, "Min_5.0% Prob": 8.018318557739258, "Min_10.0% Prob": 5.695581674575806, "Min_20.0% Prob": 3.7999296296726572, "Min_30.0% Prob": 2.7074278204730065, "Min_40.0% Prob": 2.077113625678149, "Min_50.0% Prob": 1.647977575659752, "Min_60.0% Prob": 1.381301759644898}}
{"hexsha": "20b41bbe0060e4b74d291a9329ed6b1180dbb5ce", "ext": "rs", "lang": "Rust", "content": "pub async fn test_ibc_transfer(\n    contact: &Contact,                     // Src chain's deep_space client\n    dst_bank_qc: BankQueryClient<Channel>, // Dst chain's GRPC x/bank query client\n    dst_ibc_transfer_qc: IbcTransferQueryClient<Channel>, // Dst chain's GRPC ibc-transfer query client\n    sender: CosmosPrivateKey,                             // The Src chain's funds sender\n    receiver: CosmosAddress,                              // The Dst chain's funds receiver\n    channel_id: String,       // The Src chain's ibc channel connecting to Dst\n    packet_timeout: Duration, // Used to create ibc-transfer timeout-timestamp\n) {\n    let sender_address = sender.to_address(&*ADDRESS_PREFIX).unwrap().to_string();\n    let pre_bal = get_ibc_balance(\n        receiver,\n        (*STAKING_TOKEN).to_string(),\n        None,\n        dst_bank_qc.clone(),\n        dst_ibc_transfer_qc.clone(),\n        None,\n    )\n    .await;\n\n    let timeout_timestamp = SystemTime::now()\n        .add(packet_timeout)\n        .duration_since(SystemTime::UNIX_EPOCH)\n        .unwrap()\n        .as_nanos() as u64;\n    info!(\"Calculated 150 minutes from now: {:?}\", timeout_timestamp);\n    let amount: Uint256 = one_atom();\n    let msg_transfer = MsgTransfer {\n        source_port: \"transfer\".to_string(),\n        source_channel: channel_id,\n        token: Some(Coin {\n            amount: amount.clone().to_string(),\n            denom: STAKING_TOKEN.as_str().to_string(),\n        }),\n        sender: sender_address,\n        receiver: receiver.to_string(),\n        timeout_height: None,\n        timeout_timestamp, // 150 minutes from now\n    };\n    info!(\"Submitting MsgTransfer {:?}\", msg_transfer);\n    let msg_transfer = Msg::new(MSG_TRANSFER_TYPE_URL, msg_transfer);\n    let send_res = contact\n        .send_message(\n            &[msg_transfer],\n            Some(\"Test Relaying\".to_string()),\n            &[DSCoin {\n                amount: 100u16.into(),\n                denom: (*STAKING_TOKEN).to_string(),\n            }],\n            Some(OPERATION_TIMEOUT),\n            sender,\n        )\n        .await;\n    info!(\"Sent MsgTransfer with response {:?}\", send_res);\n\n    // Give the ibc-relayer a bit of time to work in the event of multiple runs\n    delay_for(Duration::from_secs(10)).await;\n\n    let start_bal = Some(match pre_bal.clone() {\n        Some(coin) => Uint256::from_str(&coin.amount).unwrap(),\n        None => 0u8.into(),\n    });\n\n    let post_bal = get_ibc_balance(\n        receiver,\n        (*STAKING_TOKEN).to_string(),\n        start_bal,\n        dst_bank_qc,\n        dst_ibc_transfer_qc,\n        None,\n    )\n    .await;\n    match (pre_bal, post_bal) {\n        (None, None) => {\n            panic!(\"Failed to transfer stake to ibc-test-1 user {}!\", receiver,);\n        }\n        (None, Some(post)) => {\n            if Uint256::from_str(&post.amount).unwrap() != amount {\n                panic!(\n                    \"Incorrect ibc stake balance for user {}: actual {} != expected {}\",\n                    receiver, post.amount, amount,\n                );\n            }\n            info!(\n                \"Successfully transfered {} stake (aka {}) to ibc-test-1!\",\n                amount, post.denom\n            );\n        }\n        (Some(pre), Some(post)) => {\n            let pre_amt = Uint256::from_str(&pre.amount).unwrap();\n            let post_amt = Uint256::from_str(&post.amount).unwrap();\n            if post_amt < pre_amt || post_amt - pre_amt.clone() != amount.clone() {\n                panic!(\n                    \"Incorrect ibc stake balance for user {}: actual {} != expected {}\",\n                    receiver,\n                    post.amount,\n                    (pre_amt + amount),\n                );\n            }\n            info!(\n                \"Successfully transfered {} stake (aka {}) to ibc-test-1!\",\n                amount, post.denom\n            );\n        }\n        (Some(_), None) => {\n            panic!(\n                \"User wound up with no balance after ibc transfer? {}\",\n                receiver,\n            );\n        }\n    }\n}", "item_id": 1, "repo": "umee-network/Gravity-Bridge", "file": "orchestrator/test_runner/src/ibc_auto_forward.rs", "last_update_at": "2022-03-28T11:12:20+00:00", "question_id": "20b41bbe0060e4b74d291a9329ed6b1180dbb5ce_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn test_ibc_transfer(\n    contact: &Contact,                     // Src chain's deep_space client\n    dst_bank_qc: BankQueryClient<Channel>, // Dst chain's GRPC x/bank query client\n    dst_ibc_transfer_qc: IbcTransferQueryClient<Channel>, // Dst chain's GRPC ibc-transfer query client\n    sender: CosmosPrivateKey,                             // The Src chain's funds sender\n    receiver: CosmosAddress,                              // The Dst chain's funds receiver\n    channel_id: String,       // The Src chain's ibc channel connecting to Dst\n    packet_timeout: Duration, // Used to create ibc-transfer timeout-timestamp\n) {\n    let sender_address = sender.to_address(&*ADDRESS_PREFIX).unwrap().to_string();\n    let pre_bal = get_ibc_balance(\n        receiver,\n        (*STAKING_TOKEN).to_string(),\n        None,\n        dst_bank_qc.clone(),\n        dst_ibc_transfer_qc.clone(),\n        None,\n    )\n    .await;\n    let timeout_timestamp = SystemTime::now()\n        .add(packet_timeout)\n        .duration_since(SystemTime::UNIX_EPOCH)\n        .unwrap()\n        .as_nanos() as u64;\n    info!(\"Calculated 150 minutes from now: {:?}\", timeout_timestamp);\n    let amount: Uint256 = one_atom();\n    let msg_transfer = MsgTransfer {\n        source_port: \"transfer\".to_string(),\n        source_channel: channel_id,\n        token: Some(Coin {\n            amount: amount.clone().to_string(),\n            denom: STAKING_TOKEN.as_str().to_string(),\n        }),\n        sender: sender_address,\n        receiver: receiver.to_string(),\n        timeout_height: None,\n        timeout_timestamp, // 150 minutes from now\n    };\n    info!(\"Submitting MsgTransfer {:?}\", msg_transfer);\n    let msg_transfer = Msg::new(MSG_TRANSFER_TYPE_URL, msg_transfer);\n    let send_res = contact\n        .send_message(\n            &[msg_transfer],\n            Some(\"Test Relaying\".to_string()),\n            &[DSCoin {\n                amount: 100u16.into(),\n                denom: (*STAKING_TOKEN).to_string(),\n            }],\n            Some(OPERATION_TIMEOUT),\n            sender,\n        )\n        .await;\n    info!(\"Sent MsgTransfer with response {:?}\", send_res);\n    // Give the ibc-relayer a bit of time to work in the event of multiple runs\n    delay_for(Duration::from_secs(10)).await;\n    let start_bal = Some(match pre_bal.clone() {\n        Some(coin) => Uint256::from_str(&coin.amount).unwrap(),\n        None => 0u8.into(),\n    });\n    let post_bal = get_ibc_balance(\n        receiver,\n        (*STAKING_TOKEN).to_string(),\n        start_bal,\n        dst_bank_qc,\n        dst_ibc_transfer_qc,\n        None,\n    )\n    .await;\n    match (pre_bal, post_bal) {\n        (None, None) => {\n            panic!(\"Failed to transfer stake to ibc-test-1 user {}!\", receiver,);\n        }\n        (None, Some(post)) => {\n            if Uint256::from_str(&post.amount).unwrap() != amount {\n                panic!(\n                    \"Incorrect ibc stake balance for user {}: actual {} != expected {}\",\n                    receiver, post.amount, amount,\n                );\n            }\n            info!(\n                \"Successfully transfered {} stake (aka {}) to ibc-test-1!\",\n                amount, post.denom\n            );\n        }\n        (Some(pre), Some(post)) => {\n            let pre_amt = Uint256::from_str(&pre.amount).unwrap();\n            let post_amt = Uint256::from_str(&post.amount).unwrap();\n            if post_amt < pre_amt || post_amt - pre_amt.clone() != amount.clone() {\n                panic!(\n                    \"Incorrect ibc stake balance for user {}: actual {} != expected {}\",\n                    receiver,\n                    post.amount,\n                    (pre_amt + amount),\n                );\n            }\n            info!(\n                \"Successfully transfered {} stake (aka {}) to ibc-test-1!\",\n                amount, post.denom\n            );\n        }\n        (Some(_), None) => {\n            panic!(\n                \"User wound up with no balance after ibc transfer? {}\",\n                receiver,\n            );\n        }\n    }\n"]], "pred": {"ppl": 2.391711950302124, "ppl_lower": 2.640491247177124, "ppl/lowercase_ppl": -1.1134799359255945, "ppl/zlib": 0.0006877045794341985, "Min_5.0% Prob": 7.567495645261278, "Min_10.0% Prob": 5.629870255788167, "Min_20.0% Prob": 3.7975179880273107, "Min_30.0% Prob": 2.7913074756369873, "Min_40.0% Prob": 2.1523315402289764, "Min_50.0% Prob": 1.7381381780681895, "Min_60.0% Prob": 1.4532595310499967}}
{"hexsha": "b57933639403c3b508e1442d15180d63b4b76bcf", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout_TPM20_ClockRateAdjust_Out() {\n    assert_eq!(::std::mem::size_of::<TPM20_ClockRateAdjust_Out>() , 16usize ,\n               concat ! (\n               \"Size of: \" , stringify ! ( TPM20_ClockRateAdjust_Out ) ));\n    assert_eq! (::std::mem::align_of::<TPM20_ClockRateAdjust_Out>() , 4usize ,\n                concat ! (\n                \"Alignment of \" , stringify ! ( TPM20_ClockRateAdjust_Out )\n                ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const TPM20_ClockRateAdjust_Out ) ) . tag as *\n                const _ as usize } , 0usize , concat ! (\n                \"Alignment of field: \" , stringify ! (\n                TPM20_ClockRateAdjust_Out ) , \"::\" , stringify ! ( tag ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const TPM20_ClockRateAdjust_Out ) ) .\n                responseSize as * const _ as usize } , 4usize , concat ! (\n                \"Alignment of field: \" , stringify ! (\n                TPM20_ClockRateAdjust_Out ) , \"::\" , stringify ! (\n                responseSize ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const TPM20_ClockRateAdjust_Out ) ) .\n                responseCode as * const _ as usize } , 8usize , concat ! (\n                \"Alignment of field: \" , stringify ! (\n                TPM20_ClockRateAdjust_Out ) , \"::\" , stringify ! (\n                responseCode ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const TPM20_ClockRateAdjust_Out ) ) . otherData\n                as * const _ as usize } , 12usize , concat ! (\n                \"Alignment of field: \" , stringify ! (\n                TPM20_ClockRateAdjust_Out ) , \"::\" , stringify ! ( otherData )\n                ));\n}", "item_id": 223, "repo": "genofire/tss-sapi", "file": "src/bindings.rs", "last_update_at": "2022-02-20T19:41:53+00:00", "question_id": "b57933639403c3b508e1442d15180d63b4b76bcf_223", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bindgen_test_layout_TPM20_ClockRateAdjust_Out() {\n    assert_eq!(::std::mem::size_of::<TPM20_ClockRateAdjust_Out>() , 16usize ,\n               concat ! (\n               \"Size of: \" , stringify ! ( TPM20_ClockRateAdjust_Out ) ));\n    assert_eq! (::std::mem::align_of::<TPM20_ClockRateAdjust_Out>() , 4usize ,\n                concat ! (\n                \"Alignment of \" , stringify ! ( TPM20_ClockRateAdjust_Out )\n                ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const TPM20_ClockRateAdjust_Out ) ) . tag as *\n                const _ as usize } , 0usize , concat ! (\n                \"Alignment of field: \" , stringify ! (\n                TPM20_ClockRateAdjust_Out ) , \"::\" , stringify ! ( tag ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const TPM20_ClockRateAdjust_Out ) ) .\n                responseSize as * const _ as usize } , 4usize , concat ! (\n                \"Alignment of field: \" , stringify ! (\n                TPM20_ClockRateAdjust_Out ) , \"::\" , stringify ! (\n                responseSize ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const TPM20_ClockRateAdjust_Out ) ) .\n                responseCode as * const _ as usize } , 8usize , concat ! (\n                \"Alignment of field: \" , stringify ! (\n                TPM20_ClockRateAdjust_Out ) , \"::\" , stringify ! (\n                responseCode ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const TPM20_ClockRateAdjust_Out ) ) . otherData\n                as * const _ as usize } , 12usize , concat ! (\n                \"Alignment of field: \" , stringify ! (\n                TPM20_ClockRateAdjust_Out ) , \"::\" , stringify ! ( otherData )\n                ));\n"]], "pred": {"ppl": 1.588546872138977, "ppl_lower": 1.6139934062957764, "ppl/lowercase_ppl": -1.0343369214741904, "ppl/zlib": 0.0014508453964318128, "Min_5.0% Prob": 6.478103041648865, "Min_10.0% Prob": 4.238102792629173, "Min_20.0% Prob": 2.291904322737086, "Min_30.0% Prob": 1.5425258350394229, "Min_40.0% Prob": 1.157280664230463, "Min_50.0% Prob": 0.925467879199472, "Min_60.0% Prob": 0.7731391788736801}}
{"hexsha": "04c8c1f635c10d014cfbe889550fb77665f38a00", "ext": "rs", "lang": "Rust", "content": "fn delete_run(m: &ArgMatches<'_>) -> Result<(), Error> {\n    // The unwrap is ok, because NAME is a required argument.\n    let name = m.value_of(\"NAME\").unwrap();\n    let mut repo = crate::open_repo()?;\n    repo.delete_branch(name)?;\n    repo.write()?;\n    eprintln!(\"Deleted branch \\\"{}\\\"\", name);\n    Ok(())\n}", "item_id": 1, "repo": "jneem/jp", "file": "ojo/src/branch.rs", "last_update_at": "2022-03-27T21:34:27+00:00", "question_id": "04c8c1f635c10d014cfbe889550fb77665f38a00_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn delete_run(m: &ArgMatches<'_>) -> Result<(), Error> {\n    // The unwrap is ok, because NAME is a required argument.\n    let name = m.value_of(\"NAME\").unwrap();\n    let mut repo = crate::open_repo()?;\n    repo.delete_branch(name)?;\n    repo.write()?;\n    eprintln!(\"Deleted branch \\\"{}\\\"\", name);\n    Ok(())\n"]], "pred": {"ppl": 3.3994524478912354, "ppl_lower": 4.439469814300537, "ppl/lowercase_ppl": -1.218141098940571, "ppl/zlib": 0.0054870599727136656, "Min_5.0% Prob": 8.854037284851074, "Min_10.0% Prob": 7.436137056350708, "Min_20.0% Prob": 5.1690501144954135, "Min_30.0% Prob": 3.881524307653308, "Min_40.0% Prob": 2.9922176731187244, "Min_50.0% Prob": 2.4222047798059605, "Min_60.0% Prob": 2.056349469756242}}
{"hexsha": "cfbe46cb9076cdae947716442ead1ecc815a6423", "ext": "rs", "lang": "Rust", "content": "fn b42_ammonia_clean(b: &mut Bencher) {\n    let mut frag = String::new();\n    sample_file(\"github-dekellum-frag.html\")\n        .expect(\"sample_file\")\n        .read_to_string(&mut frag)\n        .expect(\"read_to_string\");\n    let frag = frag.trim();\n    let amm = ammonia::Builder::default();\n    b.iter(|| {\n        let doc = amm.clean(&frag);\n        let out = doc.to_string();\n        assert_eq!(out.len(), 52062, /*\"[[[{}]]]\", out*/);\n    });\n}", "item_id": 2, "repo": "joshstoik1/marked", "file": "ammonia-compare/src/lib.rs", "last_update_at": "2022-03-24T08:41:26+00:00", "question_id": "cfbe46cb9076cdae947716442ead1ecc815a6423_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn b42_ammonia_clean(b: &mut Bencher) {\n    let mut frag = String::new();\n    sample_file(\"github-dekellum-frag.html\")\n        .expect(\"sample_file\")\n        .read_to_string(&mut frag)\n        .expect(\"read_to_string\");\n    let frag = frag.trim();\n    let amm = ammonia::Builder::default();\n    b.iter(|| {\n        let doc = amm.clean(&frag);\n        let out = doc.to_string();\n        assert_eq!(out.len(), 52062, /*\"[[[{}]]]\", out*/);\n    });\n"]], "pred": {"ppl": 4.2646636962890625, "ppl_lower": 5.376223087310791, "ppl/lowercase_ppl": -1.1596998278129718, "ppl/zlib": 0.005599858400968549, "Min_5.0% Prob": 10.941988945007324, "Min_10.0% Prob": 8.243656784296036, "Min_20.0% Prob": 5.571673169280544, "Min_30.0% Prob": 4.3691942156577595, "Min_40.0% Prob": 3.484656869462042, "Min_50.0% Prob": 2.8558437531612006, "Min_60.0% Prob": 2.4199003973844078}}
{"hexsha": "ab6e81d1ccbbe7f48bca5ffaf070d494000bd8ac", "ext": "rs", "lang": "Rust", "content": "fn compare_num_attrs_layout() {\n    let schema = StandardSchema::NumAttrs(3);\n\n    let greater_schemas = vec![StandardSchema::Layout {\n        items: vec![],\n        exhaustive: false,\n    }];\n    let not_related_schemas = vec![\n        StandardSchema::Layout {\n            items: vec![],\n            exhaustive: true,\n        },\n        StandardSchema::Layout {\n            items: vec![(\n                ItemSchema::Field(SlotSchema::new(\n                    StandardSchema::OfKind(ValueKind::Text),\n                    StandardSchema::OfKind(ValueKind::Text),\n                )),\n                false,\n            )],\n            exhaustive: false,\n        },\n        StandardSchema::Layout {\n            items: vec![\n                (\n                    ItemSchema::Field(SlotSchema::new(\n                        StandardSchema::OfKind(ValueKind::Text),\n                        StandardSchema::OfKind(ValueKind::Text),\n                    )),\n                    true,\n                ),\n                (\n                    ItemSchema::Field(SlotSchema::new(\n                        StandardSchema::OfKind(ValueKind::Text),\n                        StandardSchema::OfKind(ValueKind::Text),\n                    )),\n                    true,\n                ),\n            ],\n            exhaustive: false,\n        },\n    ];\n\n    assert_less_than(schema.clone(), greater_schemas);\n    assert_not_related(schema, not_related_schemas);\n}", "item_id": 146, "repo": "swimos/swim-rust", "file": "api/swim_schema/src/schema/tests/mod.rs", "last_update_at": "2022-02-10T00:59:19+00:00", "question_id": "ab6e81d1ccbbe7f48bca5ffaf070d494000bd8ac_146", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn compare_num_attrs_layout() {\n    let schema = StandardSchema::NumAttrs(3);\n    let greater_schemas = vec![StandardSchema::Layout {\n        items: vec![],\n        exhaustive: false,\n    }];\n    let not_related_schemas = vec![\n        StandardSchema::Layout {\n            items: vec![],\n            exhaustive: true,\n        },\n        StandardSchema::Layout {\n            items: vec![(\n                ItemSchema::Field(SlotSchema::new(\n                    StandardSchema::OfKind(ValueKind::Text),\n                    StandardSchema::OfKind(ValueKind::Text),\n                )),\n                false,\n            )],\n            exhaustive: false,\n        },\n        StandardSchema::Layout {\n            items: vec![\n                (\n                    ItemSchema::Field(SlotSchema::new(\n                        StandardSchema::OfKind(ValueKind::Text),\n                        StandardSchema::OfKind(ValueKind::Text),\n                    )),\n                    true,\n                ),\n                (\n                    ItemSchema::Field(SlotSchema::new(\n                        StandardSchema::OfKind(ValueKind::Text),\n                        StandardSchema::OfKind(ValueKind::Text),\n                    )),\n                    true,\n                ),\n            ],\n            exhaustive: false,\n        },\n    ];\n    assert_less_than(schema.clone(), greater_schemas);\n    assert_not_related(schema, not_related_schemas);\n"]], "pred": {"ppl": 1.9990733861923218, "ppl_lower": 2.409075975418091, "ppl/lowercase_ppl": -1.2693285220075923, "ppl/zlib": 0.0022785650207115165, "Min_5.0% Prob": 8.201255489798154, "Min_10.0% Prob": 5.50996264048985, "Min_20.0% Prob": 3.2803966820240023, "Min_30.0% Prob": 2.28786519354298, "Min_40.0% Prob": 1.7293602755692388, "Min_50.0% Prob": 1.3849232617499574, "Min_60.0% Prob": 1.1543796018916292}}
{"hexsha": "8b41703798c5f45d2dc4ef7b63d343671e6f8dd8", "ext": "rs", "lang": "Rust", "content": "pub fn test_033_clobs() -> HdbResult<()> {\n    let mut log_handle = test_utils::init_logger();\n    let start = std::time::Instant::now();\n    let mut connection = test_utils::get_authenticated_connection()?;\n\n    if !prepare_test(&mut connection)? {\n        info!(\"TEST ABANDONED since database does not support CLOB columns\");\n        return Ok(());\n    }\n\n    let (blabla, fingerprint) = get_blabla();\n    test_clobs(&mut log_handle, &mut connection, &blabla, &fingerprint)?;\n    test_streaming(&mut log_handle, &mut connection, blabla, &fingerprint)?;\n    test_zero_length(&mut log_handle, &mut connection)?;\n\n    test_utils::closing_info(connection, start)\n}", "item_id": 0, "repo": "emabee/rust-hdbconnect", "file": "tests/test_033_clobs.rs", "last_update_at": "2022-03-21T20:21:28+00:00", "question_id": "8b41703798c5f45d2dc4ef7b63d343671e6f8dd8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn test_033_clobs() -> HdbResult<()> {\n    let mut log_handle = test_utils::init_logger();\n    let start = std::time::Instant::now();\n    let mut connection = test_utils::get_authenticated_connection()?;\n    if !prepare_test(&mut connection)? {\n        info!(\"TEST ABANDONED since database does not support CLOB columns\");\n        return Ok(());\n    }\n    let (blabla, fingerprint) = get_blabla();\n    test_clobs(&mut log_handle, &mut connection, &blabla, &fingerprint)?;\n    test_streaming(&mut log_handle, &mut connection, blabla, &fingerprint)?;\n    test_zero_length(&mut log_handle, &mut connection)?;\n    test_utils::closing_info(connection, start)\n"]], "pred": {"ppl": 3.063945770263672, "ppl_lower": 3.757291316986084, "ppl/lowercase_ppl": -1.182186392243744, "ppl/zlib": 0.0033930410688533595, "Min_5.0% Prob": 8.467942762374879, "Min_10.0% Prob": 6.663700353531611, "Min_20.0% Prob": 4.711445780687554, "Min_30.0% Prob": 3.4920201961810773, "Min_40.0% Prob": 2.74095431415514, "Min_50.0% Prob": 2.2288938513316148, "Min_60.0% Prob": 1.875550098817509}}
{"hexsha": "5128af75d30e943fd2c2d2ec6394af47bbbbfdbb", "ext": "rs", "lang": "Rust", "content": "fn spawn_clone_with_ref_local()\n{\n\tlet (tx, mut rx) = mpsc::channel( 1 );\n\tlet exec         = Bindgen::default();\n\n\tincrement_clone_local( 4, &exec, tx );\n\n\tlet fut = async move\n\t{\n\t\tlet result = rx.next().await.expect( \"Some\" );\n\n\t\tassert_eq!( 5u8, result );\n\t};\n\n\texec.spawn_local( fut ).expect( \"spawn future\" );\n}", "item_id": 11, "repo": "najamelan/async_executors", "file": "tests/bindgen.rs", "last_update_at": "2022-03-16T09:52:02+00:00", "question_id": "5128af75d30e943fd2c2d2ec6394af47bbbbfdbb_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn spawn_clone_with_ref_local()\n{\n\tlet (tx, mut rx) = mpsc::channel( 1 );\n\tlet exec         = Bindgen::default();\n\tincrement_clone_local( 4, &exec, tx );\n\tlet fut = async move\n\t{\n\t\tlet result = rx.next().await.expect( \"Some\" );\n\t\tassert_eq!( 5u8, result );\n\t};\n\texec.spawn_local( fut ).expect( \"spawn future\" );\n"]], "pred": {"ppl": 4.908020496368408, "ppl_lower": 4.96992826461792, "ppl/lowercase_ppl": -1.0078791465255348, "ppl/zlib": 0.007297572031899667, "Min_5.0% Prob": 10.402008692423502, "Min_10.0% Prob": 8.224514997922457, "Min_20.0% Prob": 5.932961509777949, "Min_30.0% Prob": 4.602519509119865, "Min_40.0% Prob": 3.736284147088344, "Min_50.0% Prob": 3.1173235728190494, "Min_60.0% Prob": 2.6477626835306487}}
{"hexsha": "74b1f304d6518fee8db1a5be89de4a5213f4cba9", "ext": "rs", "lang": "Rust", "content": "pub fn chmod(path: impl AsRef<Path>, mode: u32) -> Result<()> {\n    let path = CString::new(path.as_ref().to_string_lossy().to_string())?;\n    let res = unsafe { nix::libc::chmod(path.as_ptr(), mode) };\n    nix::errno::Errno::result(res).map(drop)?;\n\n    Ok(())\n}", "item_id": 0, "repo": "tiqwab/tftpff", "file": "src/privilege.rs", "last_update_at": "2022-01-22T02:11:26+00:00", "question_id": "74b1f304d6518fee8db1a5be89de4a5213f4cba9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn chmod(path: impl AsRef<Path>, mode: u32) -> Result<()> {\n    let path = CString::new(path.as_ref().to_string_lossy().to_string())?;\n    let res = unsafe { nix::libc::chmod(path.as_ptr(), mode) };\n    nix::errno::Errno::result(res).map(drop)?;\n    Ok(())\n"]], "pred": {"ppl": 2.077718496322632, "ppl_lower": 3.6575284004211426, "ppl/lowercase_ppl": -1.7733352702063239, "ppl/zlib": 0.003931561370621928, "Min_5.0% Prob": 7.605175590515136, "Min_10.0% Prob": 5.4978001594543455, "Min_20.0% Prob": 3.4525861058916365, "Min_30.0% Prob": 2.3837337833829224, "Min_40.0% Prob": 1.8420503756829671, "Min_50.0% Prob": 1.4703300068822671, "Min_60.0% Prob": 1.2208749415294733}}
{"hexsha": "1751a92244b9b42fd82dc86705f209fa7f258188", "ext": "rs", "lang": "Rust", "content": "fn test_is_container() {\n        let docker_cgroup = r#\"\n12:cpu,cpuacct:/docker/c6fa62a9938149f6098fd0cdaffc9cdf0f526f25d97b5f6e2a4cc1fccc7f7ce1\n11:perf_event:/docker/c6fa62a9938149f6098fd0cdaffc9cdf0f526f25d97b5f6e2a4cc1fccc7f7ce1\n10:rdma:/\"#;\n        assert!(is_container(docker_cgroup));\n        let init_cgroup = r#\"\n12:cpu,cpuacct:/\n11:perf_event:/\n0::/init.scope\"#;\n        assert!(!is_container(init_cgroup));\n        let k8s_cgroup = r#\"\n12:hugetlb:/kubepods/besteffort/poda00e29fd-7bbd-11e9-8679-fa163ea7e3b8/c4b1403f3d9c7ce261be851df71d9a9773c53419075ccda39ae8fe6a39fd2eb1\n11:cpuset:/kubepods/besteffort/poda00e29fd-7bbd-11e9-8679-fa163ea7e3b8/c4b1403f3d9c7ce261be851df71d9a9773c53419075ccda39ae8fe6a39fd2eb1\"#;\n        assert!(is_container(k8s_cgroup));\n    }", "item_id": 2, "repo": "nui/nmk", "file": "nmk/src/nmk/container.rs", "last_update_at": "2022-01-25T15:23:06+00:00", "question_id": "1751a92244b9b42fd82dc86705f209fa7f258188_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_is_container() {\n        let docker_cgroup = r#\"\n12:cpu,cpuacct:/docker/c6fa62a9938149f6098fd0cdaffc9cdf0f526f25d97b5f6e2a4cc1fccc7f7ce1\n11:perf_event:/docker/c6fa62a9938149f6098fd0cdaffc9cdf0f526f25d97b5f6e2a4cc1fccc7f7ce1\n10:rdma:/\"#;\n        assert!(is_container(docker_cgroup));\n        let init_cgroup = r#\"\n12:cpu,cpuacct:/\n11:perf_event:/\n0::/init.scope\"#;\n        assert!(!is_container(init_cgroup));\n        let k8s_cgroup = r#\"\n12:hugetlb:/kubepods/besteffort/poda00e29fd-7bbd-11e9-8679-fa163ea7e3b8/c4b1403f3d9c7ce261be851df71d9a9773c53419075ccda39ae8fe6a39fd2eb1\n11:cpuset:/kubepods/besteffort/poda00e29fd-7bbd-11e9-8679-fa163ea7e3b8/c4b1403f3d9c7ce261be851df71d9a9773c53419075ccda39ae8fe6a39fd2eb1\"#;\n        assert!(is_container(k8s_cgroup));\n"]], "pred": {"ppl": 3.2404115200042725, "ppl_lower": 3.2404115200042725, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.003792581722857582, "Min_5.0% Prob": 6.509377458821172, "Min_10.0% Prob": 5.227721746931684, "Min_20.0% Prob": 4.062964973951641, "Min_30.0% Prob": 3.566973350417446, "Min_40.0% Prob": 2.924984449618741, "Min_50.0% Prob": 2.350248808315133, "Min_60.0% Prob": 1.963503653044698}}
{"hexsha": "b0be92bd7e809e3d31232bf0af30c108e80f5a91", "ext": "rs", "lang": "Rust", "content": "fn to_bytes(fs: &[Fraction]) -> Vec<u8> {\n        let mut res = Vec::new();\n        for f in fs {\n            res.extend_from_slice(&f.0);\n        }\n        res\n    }", "item_id": 1, "repo": "cloudpeers/tlfs", "file": "crdt/src/fraction.rs", "last_update_at": "2022-03-22T10:08:47+00:00", "question_id": "b0be92bd7e809e3d31232bf0af30c108e80f5a91_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn to_bytes(fs: &[Fraction]) -> Vec<u8> {\n        let mut res = Vec::new();\n        for f in fs {\n            res.extend_from_slice(&f.0);\n        }\n        res\n"]], "pred": {"ppl": 2.5681936740875244, "ppl_lower": 4.231905460357666, "ppl/lowercase_ppl": -1.5295250959511733, "ppl/zlib": 0.0075456224099382605, "Min_5.0% Prob": 9.457546710968018, "Min_10.0% Prob": 6.350056838989258, "Min_20.0% Prob": 4.307641289450905, "Min_30.0% Prob": 3.032994393040152, "Min_40.0% Prob": 2.339526398026425, "Min_50.0% Prob": 1.8969770957683694, "Min_60.0% Prob": 1.585649751233203}}
{"hexsha": "1eb3faad36d9c99107eeb632258a82f0135079a6", "ext": "rs", "lang": "Rust", "content": "fn test_volume_changes() -> Result<(), Error> {\n        let mut exec = fasync::Executor::new().expect(\"executor needed\");\n        let (mut settings_requests, avrcp_requests, _stop_sender, relay_fut) =\n            setup_volume_relay()?;\n\n        pin_mut!(relay_fut);\n\n        let res = exec.run_until_stalled(&mut relay_fut);\n        assert!(res.is_pending());\n\n        let (volume_client, watch_responder) =\n            finish_relay_setup(&mut relay_fut, &mut exec, avrcp_requests, &mut settings_requests);\n\n        let volume_get_fut = volume_client.get_current_volume();\n        pin_mut!(volume_get_fut);\n\n        let res = exec.run_until_stalled(&mut relay_fut);\n        assert!(res.is_pending());\n\n        // Volume get should return immediately with the initial volume (0.8 -> 100)\n        match exec.run_until_stalled(&mut volume_get_fut) {\n            Poll::Ready(Ok(vol)) => {\n                assert_eq!(INITIAL_AVRCP_VOLUME, vol);\n            }\n            x => panic!(\"Expected get_current_volume to be finished, but got {:?}\", x),\n        };\n\n        let volume_hanging_fut = volume_client.on_volume_changed();\n        pin_mut!(volume_hanging_fut);\n\n        let res = exec.run_until_stalled(&mut relay_fut);\n        assert!(res.is_pending());\n\n        // The OnVolumeChanged request should return immediately the first time.\n        match exec.run_until_stalled(&mut volume_hanging_fut) {\n            Poll::Ready(Ok(vol)) => {\n                assert_eq!(INITIAL_AVRCP_VOLUME, vol);\n            }\n            x => {\n                panic!(\"Expected on_volume_changed to be finished the first time, but got {:?}\", x)\n            }\n        };\n\n        let volume_hanging_fut = volume_client.on_volume_changed();\n        pin_mut!(volume_hanging_fut);\n\n        let res = exec.run_until_stalled(&mut relay_fut);\n        assert!(res.is_pending());\n\n        // The next OnVolumeChanged request shouldn't resolve because the volume hasn't changed.\n        match exec.run_until_stalled(&mut volume_hanging_fut) {\n            Poll::Pending => {}\n            x => {\n                panic!(\"Expected on_volume_changed to be hanging the second time, but got {:?}\", x)\n            }\n        };\n\n        let res = exec.run_until_stalled(&mut relay_fut);\n        assert!(res.is_pending());\n\n        // When a new volume happens as a result, it's returned.\n        respond_to_audio_watch(watch_responder, NEW_MEDIA_VOLUME);\n\n        let res = exec.run_until_stalled(&mut relay_fut);\n        assert!(res.is_pending());\n\n        match exec.run_until_stalled(&mut volume_hanging_fut) {\n            Poll::Ready(Ok(vol)) => assert_eq!(vol, NEW_AVRCP_VOLUME),\n            x => panic!(\n                \"Expected on_volume_changed to be responded to after change but got: {:?}\",\n                x\n            ),\n        };\n\n        let _watch_responder = expect_audio_watch(&mut exec, &mut settings_requests);\n\n        Ok(())\n    }", "item_id": 6, "repo": "gobftald/fuchsia-rpi", "file": "src/connectivity/bluetooth/profiles/bt-a2dp-sink/src/volume_relay.rs", "last_update_at": "2022-01-20T15:42:41+00:00", "question_id": "1eb3faad36d9c99107eeb632258a82f0135079a6_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_volume_changes() -> Result<(), Error> {\n        let mut exec = fasync::Executor::new().expect(\"executor needed\");\n        let (mut settings_requests, avrcp_requests, _stop_sender, relay_fut) =\n            setup_volume_relay()?;\n        pin_mut!(relay_fut);\n        let res = exec.run_until_stalled(&mut relay_fut);\n        assert!(res.is_pending());\n        let (volume_client, watch_responder) =\n            finish_relay_setup(&mut relay_fut, &mut exec, avrcp_requests, &mut settings_requests);\n        let volume_get_fut = volume_client.get_current_volume();\n        pin_mut!(volume_get_fut);\n        let res = exec.run_until_stalled(&mut relay_fut);\n        assert!(res.is_pending());\n        // Volume get should return immediately with the initial volume (0.8 -> 100)\n        match exec.run_until_stalled(&mut volume_get_fut) {\n            Poll::Ready(Ok(vol)) => {\n                assert_eq!(INITIAL_AVRCP_VOLUME, vol);\n            }\n            x => panic!(\"Expected get_current_volume to be finished, but got {:?}\", x),\n        };\n        let volume_hanging_fut = volume_client.on_volume_changed();\n        pin_mut!(volume_hanging_fut);\n        let res = exec.run_until_stalled(&mut relay_fut);\n        assert!(res.is_pending());\n        // The OnVolumeChanged request should return immediately the first time.\n        match exec.run_until_stalled(&mut volume_hanging_fut) {\n            Poll::Ready(Ok(vol)) => {\n                assert_eq!(INITIAL_AVRCP_VOLUME, vol);\n            }\n            x => {\n                panic!(\"Expected on_volume_changed to be finished the first time, but got {:?}\", x)\n            }\n        };\n        let volume_hanging_fut = volume_client.on_volume_changed();\n        pin_mut!(volume_hanging_fut);\n        let res = exec.run_until_stalled(&mut relay_fut);\n        assert!(res.is_pending());\n        // The next OnVolumeChanged request shouldn't resolve because the volume hasn't changed.\n        match exec.run_until_stalled(&mut volume_hanging_fut) {\n            Poll::Pending => {}\n            x => {\n                panic!(\"Expected on_volume_changed to be hanging the second time, but got {:?}\", x)\n            }\n        };\n        let res = exec.run_until_stalled(&mut relay_fut);\n        assert!(res.is_pending());\n        // When a new volume happens as a result, it's returned.\n        respond_to_audio_watch(watch_responder, NEW_MEDIA_VOLUME);\n        let res = exec.run_until_stalled(&mut relay_fut);\n        assert!(res.is_pending());\n        match exec.run_until_stalled(&mut volume_hanging_fut) {\n            Poll::Ready(Ok(vol)) => assert_eq!(vol, NEW_AVRCP_VOLUME),\n            x => panic!(\n                \"Expected on_volume_changed to be responded to after change but got: {:?}\",\n                x\n            ),\n        };\n        let _watch_responder = expect_audio_watch(&mut exec, &mut settings_requests);\n        Ok(())\n"]], "pred": {"ppl": 1.860360026359558, "ppl_lower": 2.042933940887451, "ppl/lowercase_ppl": -1.1508077784584914, "ppl/zlib": 0.0008633797379043074, "Min_5.0% Prob": 6.694858254326714, "Min_10.0% Prob": 4.857017411126031, "Min_20.0% Prob": 2.9687472682302167, "Min_30.0% Prob": 2.0587244634258792, "Min_40.0% Prob": 1.551386196480148, "Min_50.0% Prob": 1.2410665063159725, "Min_60.0% Prob": 1.0356752427843052}}
{"hexsha": "d9b012ea4f09039f57924ced0af1f028e5bed835", "ext": "rs", "lang": "Rust", "content": "fn test_seq0255_bool() {\n            let s: Seq0255<bool> = Seq0255::new(vec![true, false, true]).unwrap();\n\n            let expected = Test { a: s };\n\n            #[cfg(not(feature = \"with_serde\"))]\n            let mut bytes = to_bytes(expected.clone()).unwrap();\n            #[cfg(feature = \"with_serde\")]\n            let mut bytes = to_bytes(&expected.clone()).unwrap();\n\n            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n\n            assert_eq!(deserialized, expected);\n        }", "item_id": 10, "repo": "stratum-mining/bitcoin", "file": "src/rusty/binary-sv2/binary-sv2/src/lib.rs", "last_update_at": "2022-03-29T14:42:33+00:00", "question_id": "d9b012ea4f09039f57924ced0af1f028e5bed835_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_seq0255_bool() {\n            let s: Seq0255<bool> = Seq0255::new(vec![true, false, true]).unwrap();\n            let expected = Test { a: s };\n            #[cfg(not(feature = \"with_serde\"))]\n            let mut bytes = to_bytes(expected.clone()).unwrap();\n            #[cfg(feature = \"with_serde\")]\n            let mut bytes = to_bytes(&expected.clone()).unwrap();\n            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n            assert_eq!(deserialized, expected);\n"]], "pred": {"ppl": 2.9218804836273193, "ppl_lower": 3.117577075958252, "ppl/lowercase_ppl": -1.0604617183331806, "ppl/zlib": 0.004744369071869959, "Min_5.0% Prob": 7.871405056544712, "Min_10.0% Prob": 6.140842914581299, "Min_20.0% Prob": 4.461698405204281, "Min_30.0% Prob": 3.4126674481060193, "Min_40.0% Prob": 2.6454134194120282, "Min_50.0% Prob": 2.1327641165982456, "Min_60.0% Prob": 1.7953632539638908}}
{"hexsha": "a0351f349b997fec95b9cb84de06206dddeada89", "ext": "rs", "lang": "Rust", "content": "pub fn fix_syntax_and_write(out_path: &Path, contents: String) {\n    // move(x) ~> move x\n    let contents = replace!(contents, r\"move\\((\\w+)\\)\", \"move $1\");\n    // copy(x) ~> copy x\n    let contents = replace!(contents, r\"copy\\((\\w+)\\)\", \"copy $1\");\n    // resource StructName ~> resource struct StructName\n    let contents = replace!(contents, r\"resource\\s+(\\w)\", \"resource struct $1\");\n    // copyable ~> copyable\n    let contents = replace!(contents, r\":\\s*copyable\", NoExpand(\": copyable\"));\n    // import ~> use\n    let contents = replace!(contents, r\"import\", NoExpand(\"use\"));\n    // Self. is unnecessary\n    let contents = replace!(contents, r\"Self\\.\", NoExpand(\"\"));\n    // Module|Address. ~> Module|Address::\n    let contents = replace!(contents, r\"(([A-Z]\\w*)|(\\}\\})|(0x\\d+))\\.\", \"$1::\");\n    // add fun keyword to functions\n    let contents = replace!(\n        contents,\n        r\"(((public|native| )*))(\\w+\\(.*\\).*\\{)\",\n        |cap: &Captures| format!(\"{}fun {}\", &cap[1], &cap[4])\n    );\n    fs::write(out_path, contents.as_bytes()).unwrap();\n}", "item_id": 0, "repo": "BlockSuite/libra", "file": "language/move-lang/src/ir_translation.rs", "last_update_at": "2022-03-31T23:25:13+00:00", "question_id": "a0351f349b997fec95b9cb84de06206dddeada89_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn fix_syntax_and_write(out_path: &Path, contents: String) {\n    // move(x) ~> move x\n    let contents = replace!(contents, r\"move\\((\\w+)\\)\", \"move $1\");\n    // copy(x) ~> copy x\n    let contents = replace!(contents, r\"copy\\((\\w+)\\)\", \"copy $1\");\n    // resource StructName ~> resource struct StructName\n    let contents = replace!(contents, r\"resource\\s+(\\w)\", \"resource struct $1\");\n    // copyable ~> copyable\n    let contents = replace!(contents, r\":\\s*copyable\", NoExpand(\": copyable\"));\n    // import ~> use\n    let contents = replace!(contents, r\"import\", NoExpand(\"use\"));\n    // Self. is unnecessary\n    let contents = replace!(contents, r\"Self\\.\", NoExpand(\"\"));\n    // Module|Address. ~> Module|Address::\n    let contents = replace!(contents, r\"(([A-Z]\\w*)|(\\}\\})|(0x\\d+))\\.\", \"$1::\");\n    // add fun keyword to functions\n    let contents = replace!(\n        contents,\n        r\"(((public|native| )*))(\\w+\\(.*\\).*\\{)\",\n        |cap: &Captures| format!(\"{}fun {}\", &cap[1], &cap[4])\n    );\n    fs::write(out_path, contents.as_bytes()).unwrap();\n"]], "pred": {"ppl": 3.41985821723938, "ppl_lower": 3.625824213027954, "ppl/lowercase_ppl": -1.047562281581018, "ppl/zlib": 0.002807303865907765, "Min_5.0% Prob": 9.497753788443173, "Min_10.0% Prob": 7.440202670938828, "Min_20.0% Prob": 5.144074168758116, "Min_30.0% Prob": 3.851048776736626, "Min_40.0% Prob": 3.007268057023879, "Min_50.0% Prob": 2.436976900516913, "Min_60.0% Prob": 2.0516831188534317}}
{"hexsha": "f9acdd1be3b820ad6f684d935997e95cb5640a75", "ext": "rs", "lang": "Rust", "content": "fn read_req(p: &mut ServerProtocol, src: &[u8], read_size: usize) -> TestRequest {\n        const READ_SIZE_MAX: usize = 1024;\n        const LOOPS_MAX: u32 = 20;\n\n        assert!(read_size <= READ_SIZE_MAX);\n\n        assert_eq!(p.state(), ServerState::ReceivingRequest);\n\n        let mut rbuf = io::Cursor::new(src);\n\n        let mut result = TestRequest::new();\n\n        assert_eq!(p.state(), ServerState::ReceivingRequest);\n\n        let mut headers = [httparse::EMPTY_HEADER; HEADERS_MAX];\n\n        let req = p.recv_request(&mut rbuf, &mut headers).unwrap().unwrap();\n\n        result.method = String::from(req.method);\n        result.uri = String::from(req.uri);\n\n        for h in req.headers {\n            let name = String::from(h.name);\n            let value = Vec::from(h.value);\n            result.headers.push((name, value));\n        }\n\n        for _ in 0..LOOPS_MAX {\n            if p.state() != ServerState::ReceivingBody {\n                break;\n            }\n\n            let mut buf = [0; READ_SIZE_MAX];\n\n            let (size, trailing_headers) = p\n                .recv_body(&mut rbuf, &mut buf[..read_size], &mut headers)\n                .unwrap();\n\n            result.body.extend_from_slice(&buf[..size]);\n\n            if let Some(trailing_headers) = trailing_headers {\n                for h in trailing_headers {\n                    let name = String::from(h.name);\n                    let value = Vec::from(h.value);\n                    result.trailing_headers.push((name, value));\n                }\n            }\n        }\n\n        result.persistent = p.is_persistent();\n\n        assert_eq!(p.state(), ServerState::AwaitingResponse);\n\n        return result;\n    }", "item_id": 5, "repo": "fanout/condure", "file": "src/http1.rs", "last_update_at": "2022-02-03T13:54:57+00:00", "question_id": "f9acdd1be3b820ad6f684d935997e95cb5640a75_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn read_req(p: &mut ServerProtocol, src: &[u8], read_size: usize) -> TestRequest {\n        const READ_SIZE_MAX: usize = 1024;\n        const LOOPS_MAX: u32 = 20;\n        assert!(read_size <= READ_SIZE_MAX);\n        assert_eq!(p.state(), ServerState::ReceivingRequest);\n        let mut rbuf = io::Cursor::new(src);\n        let mut result = TestRequest::new();\n        assert_eq!(p.state(), ServerState::ReceivingRequest);\n        let mut headers = [httparse::EMPTY_HEADER; HEADERS_MAX];\n        let req = p.recv_request(&mut rbuf, &mut headers).unwrap().unwrap();\n        result.method = String::from(req.method);\n        result.uri = String::from(req.uri);\n        for h in req.headers {\n            let name = String::from(h.name);\n            let value = Vec::from(h.value);\n            result.headers.push((name, value));\n        }\n        for _ in 0..LOOPS_MAX {\n            if p.state() != ServerState::ReceivingBody {\n                break;\n            }\n            let mut buf = [0; READ_SIZE_MAX];\n            let (size, trailing_headers) = p\n                .recv_body(&mut rbuf, &mut buf[..read_size], &mut headers)\n                .unwrap();\n            result.body.extend_from_slice(&buf[..size]);\n            if let Some(trailing_headers) = trailing_headers {\n                for h in trailing_headers {\n                    let name = String::from(h.name);\n                    let value = Vec::from(h.value);\n                    result.trailing_headers.push((name, value));\n                }\n            }\n        }\n        result.persistent = p.is_persistent();\n        assert_eq!(p.state(), ServerState::AwaitingResponse);\n        return result;\n"]], "pred": {"ppl": 1.909648060798645, "ppl_lower": 2.2758708000183105, "ppl/lowercase_ppl": -1.2711990133625026, "ppl/zlib": 0.0011250764586406298, "Min_5.0% Prob": 6.459870147705078, "Min_10.0% Prob": 4.495601020607293, "Min_20.0% Prob": 2.8763868247761444, "Min_30.0% Prob": 2.0793885056879007, "Min_40.0% Prob": 1.6030400130240356, "Min_50.0% Prob": 1.289933436906722, "Min_60.0% Prob": 1.0781309717298404}}
{"hexsha": "2e3d354c774b7741c3776cd8d01c88f2eb41bb6b", "ext": "rs", "lang": "Rust", "content": "fn update_consensus_evidence_params() {\n        let mut deps = mock_deps_tgrade();\n        let env = mock_env();\n        proposals()\n            .save(\n                &mut deps.storage,\n                1,\n                &Proposal {\n                    title: \"UnpinCodes\".to_owned(),\n                    description: \"UnpinCodes testing proposal\".to_owned(),\n                    created_by: \"mock_person\".to_owned(),\n                    start_height: env.block.height,\n                    expires: Expiration::at_timestamp(env.block.time.plus_seconds(66666)),\n                    proposal: ValidatorProposal::UpdateConsensusEvidenceParams {\n                        max_age_num_blocks: Some(10),\n                        max_age_duration: Some(100),\n                        max_bytes: Some(256),\n                    },\n                    status: Status::Passed,\n                    rules: VotingRules {\n                        voting_period: 1,\n                        quorum: Decimal::percent(50),\n                        threshold: Decimal::percent(40),\n                        allow_end_early: true,\n                    },\n                    total_points: 20,\n                    votes: Votes {\n                        yes: 20,\n                        no: 0,\n                        abstain: 0,\n                        veto: 0,\n                    },\n                },\n            )\n            .unwrap();\n\n        let res = execute_execute(deps.as_mut(), env, mock_info(\"sender\", &[]), 1).unwrap();\n        assert_eq!(\n            res.messages,\n            vec![SubMsg::new(CosmosMsg::Custom(TgradeMsg::ConsensusParams(\n                ConsensusParams {\n                    block: None,\n                    evidence: Some(EvidenceParams {\n                        max_age_num_blocks: Some(10),\n                        max_age_duration: Some(100),\n                        max_bytes: Some(256),\n                    }),\n                }\n            )))]\n        );\n    }", "item_id": 8, "repo": "confio/poe-contracts", "file": "contracts/tgrade-validator-voting/src/contract.rs", "last_update_at": "2022-03-31T16:43:24+00:00", "question_id": "2e3d354c774b7741c3776cd8d01c88f2eb41bb6b_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn update_consensus_evidence_params() {\n        let mut deps = mock_deps_tgrade();\n        let env = mock_env();\n        proposals()\n            .save(\n                &mut deps.storage,\n                1,\n                &Proposal {\n                    title: \"UnpinCodes\".to_owned(),\n                    description: \"UnpinCodes testing proposal\".to_owned(),\n                    created_by: \"mock_person\".to_owned(),\n                    start_height: env.block.height,\n                    expires: Expiration::at_timestamp(env.block.time.plus_seconds(66666)),\n                    proposal: ValidatorProposal::UpdateConsensusEvidenceParams {\n                        max_age_num_blocks: Some(10),\n                        max_age_duration: Some(100),\n                        max_bytes: Some(256),\n                    },\n                    status: Status::Passed,\n                    rules: VotingRules {\n                        voting_period: 1,\n                        quorum: Decimal::percent(50),\n                        threshold: Decimal::percent(40),\n                        allow_end_early: true,\n                    },\n                    total_points: 20,\n                    votes: Votes {\n                        yes: 20,\n                        no: 0,\n                        abstain: 0,\n                        veto: 0,\n                    },\n                },\n            )\n            .unwrap();\n        let res = execute_execute(deps.as_mut(), env, mock_info(\"sender\", &[]), 1).unwrap();\n        assert_eq!(\n            res.messages,\n            vec![SubMsg::new(CosmosMsg::Custom(TgradeMsg::ConsensusParams(\n                ConsensusParams {\n                    block: None,\n                    evidence: Some(EvidenceParams {\n                        max_age_num_blocks: Some(10),\n                        max_age_duration: Some(100),\n                        max_bytes: Some(256),\n                    }),\n                }\n            )))]\n        );\n"]], "pred": {"ppl": 2.039393901824951, "ppl_lower": 2.588613986968994, "ppl/lowercase_ppl": -1.334622951701599, "ppl/zlib": 0.0011457438211616691, "Min_5.0% Prob": 6.615091232153086, "Min_10.0% Prob": 4.784961122732896, "Min_20.0% Prob": 3.151663944698297, "Min_30.0% Prob": 2.2993077804708175, "Min_40.0% Prob": 1.7716719338483218, "Min_50.0% Prob": 1.4224883079002717, "Min_60.0% Prob": 1.1885559239356547}}
{"hexsha": "8dcf8e6347f1b9f6a3759594c30ed42aaafaabb2", "ext": "rs", "lang": "Rust", "content": "fn test_decimal_round_result_zero() {\n        let x = Decimal::new_raw(12345, 2);\n        let y = x.round(-3);\n        assert_eq!(y.coefficient(), 0);\n        assert_eq!(y.n_frac_digits(), 0);\n        let y = x.round(-37);\n        assert_eq!(y.coefficient(), 0);\n        assert_eq!(y.n_frac_digits(), 0);\n        let y = x.checked_round(-9).unwrap();\n        assert_eq!(y.coefficient(), 0);\n        assert_eq!(y.n_frac_digits(), 0);\n        let y = x.checked_round(-42).unwrap();\n        assert_eq!(y.coefficient(), 0);\n        assert_eq!(y.n_frac_digits(), 0);\n    }", "item_id": 1, "repo": "mamrhein/fpdec.rs", "file": "src/round.rs", "last_update_at": "2022-03-08T03:40:31+00:00", "question_id": "8dcf8e6347f1b9f6a3759594c30ed42aaafaabb2_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_decimal_round_result_zero() {\n        let x = Decimal::new_raw(12345, 2);\n        let y = x.round(-3);\n        assert_eq!(y.coefficient(), 0);\n        assert_eq!(y.n_frac_digits(), 0);\n        let y = x.round(-37);\n        assert_eq!(y.coefficient(), 0);\n        assert_eq!(y.n_frac_digits(), 0);\n        let y = x.checked_round(-9).unwrap();\n        assert_eq!(y.coefficient(), 0);\n        assert_eq!(y.n_frac_digits(), 0);\n        let y = x.checked_round(-42).unwrap();\n        assert_eq!(y.coefficient(), 0);\n        assert_eq!(y.n_frac_digits(), 0);\n"]], "pred": {"ppl": 1.80455482006073, "ppl_lower": 1.8314687013626099, "ppl/lowercase_ppl": -1.02507867276929, "ppl/zlib": 0.003556107977587038, "Min_5.0% Prob": 6.615861272811889, "Min_10.0% Prob": 4.617647420792353, "Min_20.0% Prob": 2.8154255678487377, "Min_30.0% Prob": 1.956004184942979, "Min_40.0% Prob": 1.4815436536125068, "Min_50.0% Prob": 1.1851857977261373, "Min_60.0% Prob": 0.9866192030421821}}
{"hexsha": "d4c044b4464d1846dd4a853c231d2edd55e48d41", "ext": "rs", "lang": "Rust", "content": "fn enc_dec_max_i8() {\n        let val = core::i8::MAX.into();\n        assert_eq!(encoded_len(val), 2);\n        assert_eq!(encode(val).as_ref(), &[0xBE, 0x03]);\n        assert_eq!(decode(encode(val).as_ref()).unwrap(), val);\n    }", "item_id": 9, "repo": "aki-akaguma/vu64", "file": "src/signed.rs", "last_update_at": "2022-02-02T10:25:49+00:00", "question_id": "d4c044b4464d1846dd4a853c231d2edd55e48d41_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn enc_dec_max_i8() {\n        let val = core::i8::MAX.into();\n        assert_eq!(encoded_len(val), 2);\n        assert_eq!(encode(val).as_ref(), &[0xBE, 0x03]);\n        assert_eq!(decode(encode(val).as_ref()).unwrap(), val);\n"]], "pred": {"ppl": 3.7656261920928955, "ppl_lower": 4.384939193725586, "ppl/lowercase_ppl": -1.1148351801097158, "ppl/zlib": 0.009207737268773058, "Min_5.0% Prob": 9.482247829437256, "Min_10.0% Prob": 7.813490152359009, "Min_20.0% Prob": 5.371484574149637, "Min_30.0% Prob": 4.098878158972814, "Min_40.0% Prob": 3.250072351523808, "Min_50.0% Prob": 2.6462659815495666, "Min_60.0% Prob": 2.2134760547921344}}
{"hexsha": "c7e9af65cf4203d61fc9d741d9f84684268734c5", "ext": "rs", "lang": "Rust", "content": "fn test_includes() {\n        assert_eq!(document(json!({})).includes(), Vec::<String>::new());\n        assert_eq!(document(json!({ \"include\": []})).includes(), Vec::<String>::new());\n        assert_eq!(\n            document(json!({ \"include\": [ \"foo.cml\", \"bar.cml\" ]})).includes(),\n            vec![\"foo.cml\", \"bar.cml\"]\n        );\n    }", "item_id": 5, "repo": "fabio-d/fuchsia-stardock", "file": "tools/lib/cml/src/lib.rs", "last_update_at": "2022-01-21T20:14:17+00:00", "question_id": "c7e9af65cf4203d61fc9d741d9f84684268734c5_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_includes() {\n        assert_eq!(document(json!({})).includes(), Vec::<String>::new());\n        assert_eq!(document(json!({ \"include\": []})).includes(), Vec::<String>::new());\n        assert_eq!(\n            document(json!({ \"include\": [ \"foo.cml\", \"bar.cml\" ]})).includes(),\n            vec![\"foo.cml\", \"bar.cml\"]\n        );\n"]], "pred": {"ppl": 2.4263648986816406, "ppl_lower": 2.9439778327941895, "ppl/lowercase_ppl": -1.2181506354360228, "ppl/zlib": 0.006113063523233683, "Min_5.0% Prob": 8.142107677459716, "Min_10.0% Prob": 6.031545053828847, "Min_20.0% Prob": 3.998541848226027, "Min_30.0% Prob": 2.860119281393109, "Min_40.0% Prob": 2.1892671805213797, "Min_50.0% Prob": 1.766374495015903, "Min_60.0% Prob": 1.4753553837565987}}
{"hexsha": "3fce34367ae5040132e5bad3ed34924faf7178ad", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let mut vec = vec![1, 2, 3, 4];\n    let vec2 = vec![1, 2, 3, 4];\n    for i in 0..vec.len() {\n        println!(\"{}\", vec[i]);\n    }\n\n    for i in 0..vec.len() {\n        let i = 42; // make a different `i`\n        println!(\"{}\", vec[i]); // ok, not the `i` of the for-loop\n    }\n\n    for i in 0..vec.len() {\n        let _ = vec[i];\n    }\n\n    // ICE #746\n    for j in 0..4 {\n        println!(\"{:?}\", STATIC[j]);\n    }\n\n    for j in 0..4 {\n        println!(\"{:?}\", CONST[j]);\n    }\n\n    for i in 0..vec.len() {\n        println!(\"{} {}\", vec[i], i);\n    }\n    for i in 0..vec.len() {\n        // not an error, indexing more than one variable\n        println!(\"{} {}\", vec[i], vec2[i]);\n    }\n\n    for i in 0..vec.len() {\n        println!(\"{}\", vec2[i]);\n    }\n\n    for i in 5..vec.len() {\n        println!(\"{}\", vec[i]);\n    }\n\n    for i in 0..MAX_LEN {\n        println!(\"{}\", vec[i]);\n    }\n\n    for i in 0..=MAX_LEN {\n        println!(\"{}\", vec[i]);\n    }\n\n    for i in 5..10 {\n        println!(\"{}\", vec[i]);\n    }\n\n    for i in 5..=10 {\n        println!(\"{}\", vec[i]);\n    }\n\n    for i in 5..vec.len() {\n        println!(\"{} {}\", vec[i], i);\n    }\n\n    for i in 5..10 {\n        println!(\"{} {}\", vec[i], i);\n    }\n\n    // #2542\n    for i in 0..vec.len() {\n        vec[i] = Some(1).unwrap_or_else(|| panic!(\"error on {}\", i));\n    }\n\n    // #3788\n    let test = Test {\n        inner: vec![1, 2, 3, 4],\n    };\n    for i in 0..2 {\n        println!(\"{}\", test[i]);\n    }\n}", "item_id": 0, "repo": "Eric-Arellano/rust", "file": "src/tools/clippy/tests/ui/needless_range_loop.rs", "last_update_at": "2022-03-31T23:26:40+00:00", "question_id": "3fce34367ae5040132e5bad3ed34924faf7178ad_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let mut vec = vec![1, 2, 3, 4];\n    let vec2 = vec![1, 2, 3, 4];\n    for i in 0..vec.len() {\n        println!(\"{}\", vec[i]);\n    }\n    for i in 0..vec.len() {\n        let i = 42; // make a different `i`\n        println!(\"{}\", vec[i]); // ok, not the `i` of the for-loop\n    }\n    for i in 0..vec.len() {\n        let _ = vec[i];\n    }\n    // ICE #746\n    for j in 0..4 {\n        println!(\"{:?}\", STATIC[j]);\n    }\n    for j in 0..4 {\n        println!(\"{:?}\", CONST[j]);\n    }\n    for i in 0..vec.len() {\n        println!(\"{} {}\", vec[i], i);\n    }\n    for i in 0..vec.len() {\n        // not an error, indexing more than one variable\n        println!(\"{} {}\", vec[i], vec2[i]);\n    }\n    for i in 0..vec.len() {\n        println!(\"{}\", vec2[i]);\n    }\n    for i in 5..vec.len() {\n        println!(\"{}\", vec[i]);\n    }\n    for i in 0..MAX_LEN {\n        println!(\"{}\", vec[i]);\n    }\n    for i in 0..=MAX_LEN {\n        println!(\"{}\", vec[i]);\n    }\n    for i in 5..10 {\n        println!(\"{}\", vec[i]);\n    }\n    for i in 5..=10 {\n        println!(\"{}\", vec[i]);\n    }\n    for i in 5..vec.len() {\n        println!(\"{} {}\", vec[i], i);\n    }\n    for i in 5..10 {\n        println!(\"{} {}\", vec[i], i);\n    }\n    // #2542\n    for i in 0..vec.len() {\n        vec[i] = Some(1).unwrap_or_else(|| panic!(\"error on {}\", i));\n    }\n    // #3788\n    let test = Test {\n        inner: vec![1, 2, 3, 4],\n    };\n    for i in 0..2 {\n        println!(\"{}\", test[i]);\n    }\n"]], "pred": {"ppl": 1.9131087064743042, "ppl_lower": 1.9820910692214966, "ppl/lowercase_ppl": -1.0546034491406375, "ppl/zlib": 0.0016591547671968038, "Min_5.0% Prob": 5.524550159772237, "Min_10.0% Prob": 4.1439010979699304, "Min_20.0% Prob": 2.808481724766212, "Min_30.0% Prob": 2.042353215249809, "Min_40.0% Prob": 1.5837738354075774, "Min_50.0% Prob": 1.2846246976345101, "Min_60.0% Prob": 1.0792331789746075}}
{"hexsha": "78af2ad1e00582d2a1c0a2534ddc830b95eec458", "ext": "rs", "lang": "Rust", "content": "fn from_date() {\n    let date: Date<Utc> = Date::from_utc(NaiveDate::from_ymd(2018, 6, 19), Utc);\n\n    let solar_date = SolarDate::from_date(date).unwrap();\n\n    assert_eq!(SolarYear::from_u16(2018), solar_date.get_solar_year());\n    assert_eq!(SolarMonth::from_u8(6).unwrap(), solar_date.get_solar_month());\n    assert_eq!(SolarDay::from_u8(19).unwrap(), solar_date.get_solar_day());\n}", "item_id": 1, "repo": "ChaosStudyGroup/chinese-lunisolar-calendar", "file": "tests/solar_date.rs", "last_update_at": "2022-03-05T17:06:57+00:00", "question_id": "78af2ad1e00582d2a1c0a2534ddc830b95eec458_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn from_date() {\n    let date: Date<Utc> = Date::from_utc(NaiveDate::from_ymd(2018, 6, 19), Utc);\n    let solar_date = SolarDate::from_date(date).unwrap();\n    assert_eq!(SolarYear::from_u16(2018), solar_date.get_solar_year());\n    assert_eq!(SolarMonth::from_u8(6).unwrap(), solar_date.get_solar_month());\n    assert_eq!(SolarDay::from_u8(19).unwrap(), solar_date.get_solar_day());\n"]], "pred": {"ppl": 1.7347558736801147, "ppl_lower": 2.196526527404785, "ppl/lowercase_ppl": -1.4284349847601383, "ppl/zlib": 0.002869097378573314, "Min_5.0% Prob": 5.803370803594589, "Min_10.0% Prob": 4.062546566128731, "Min_20.0% Prob": 2.592527162283659, "Min_30.0% Prob": 1.7935080239359213, "Min_40.0% Prob": 1.3786041740614634, "Min_50.0% Prob": 1.0988364442615066, "Min_60.0% Prob": 0.9207910167823109}}
{"hexsha": "f419036840fdab102b9b8647ef28cba23a71a5c8", "ext": "rs", "lang": "Rust", "content": "fn decode_message_valid_header_size() {\n        let data = vec![0; SIGNED_MESSAGE_MIN_SIZE + 1];\n\n        match get_decoded_message(&data) {\n            Ok(Some(ref message)) if *message == &data[..] => {}\n            _ => panic!(\"Wrong input\"),\n        };\n    }", "item_id": 2, "repo": "mobilipia/milestone-core", "file": "exonum-node/src/events/codec.rs", "last_update_at": "2022-03-26T04:27:03+00:00", "question_id": "f419036840fdab102b9b8647ef28cba23a71a5c8_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn decode_message_valid_header_size() {\n        let data = vec![0; SIGNED_MESSAGE_MIN_SIZE + 1];\n        match get_decoded_message(&data) {\n            Ok(Some(ref message)) if *message == &data[..] => {}\n            _ => panic!(\"Wrong input\"),\n        };\n"]], "pred": {"ppl": 4.898504734039307, "ppl_lower": 6.619147777557373, "ppl/lowercase_ppl": -1.1894587077488432, "ppl/zlib": 0.008496951883574378, "Min_5.0% Prob": 7.553775429725647, "Min_10.0% Prob": 6.66737562417984, "Min_20.0% Prob": 5.358283281326294, "Min_30.0% Prob": 4.304517484628237, "Min_40.0% Prob": 3.6460174322128296, "Min_50.0% Prob": 3.0914499038873715, "Min_60.0% Prob": 2.627647668696367}}
{"hexsha": "ceaf60f189248fa5fd48952aede09a7a325d9f39", "ext": "rs", "lang": "Rust", "content": "pub fn deser_operation_crate_operation_create_load_balancer(\n    inp: &[u8],\n    mut builder: crate::output::create_load_balancer_output::Builder,\n) -> Result<crate::output::create_load_balancer_output::Builder, aws_smithy_xml::decode::XmlError> {\n    use std::convert::TryFrom;\n    let mut doc = aws_smithy_xml::decode::Document::try_from(inp)?;\n\n    #[allow(unused_mut)]\n    let mut decoder = doc.root_element()?;\n    let start_el = decoder.start_el();\n    if !(start_el.matches(\"CreateLoadBalancerResponse\")) {\n        return Err(aws_smithy_xml::decode::XmlError::custom(format!(\n            \"invalid root, expected CreateLoadBalancerResponse got {:?}\",\n            start_el\n        )));\n    }\n    if let Some(mut result_tag) = decoder.next_tag() {\n        let start_el = result_tag.start_el();\n        if !(start_el.matches(\"CreateLoadBalancerResult\")) {\n            return Err(aws_smithy_xml::decode::XmlError::custom(format!(\n                \"invalid result, expected CreateLoadBalancerResult got {:?}\",\n                start_el\n            )));\n        }\n        while let Some(mut tag) = result_tag.next_tag() {\n            match tag.start_el() {\n            s if s.matches(\"LoadBalancers\") /* LoadBalancers com.amazonaws.elasticloadbalancingv2.synthetic#CreateLoadBalancerOutput$LoadBalancers */ =>  {\n                let var_34 =\n                    Some(\n                        crate::xml_deser::deser_list_com_amazonaws_elasticloadbalancingv2_load_balancers(&mut tag)\n                        ?\n                    )\n                ;\n                builder = builder.set_load_balancers(var_34);\n            }\n            ,\n            _ => {}\n        }\n        }\n    } else {\n        return Err(aws_smithy_xml::decode::XmlError::custom(\n            \"expected CreateLoadBalancerResult tag\",\n        ));\n    };\n    Ok(builder)\n}", "item_id": 33, "repo": "StevenBlack/aws-sdk-rust", "file": "sdk/elasticloadbalancingv2/src/xml_deser.rs", "last_update_at": "2022-03-31T20:47:15+00:00", "question_id": "ceaf60f189248fa5fd48952aede09a7a325d9f39_33", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn deser_operation_crate_operation_create_load_balancer(\n    inp: &[u8],\n    mut builder: crate::output::create_load_balancer_output::Builder,\n) -> Result<crate::output::create_load_balancer_output::Builder, aws_smithy_xml::decode::XmlError> {\n    use std::convert::TryFrom;\n    let mut doc = aws_smithy_xml::decode::Document::try_from(inp)?;\n    #[allow(unused_mut)]\n    let mut decoder = doc.root_element()?;\n    let start_el = decoder.start_el();\n    if !(start_el.matches(\"CreateLoadBalancerResponse\")) {\n        return Err(aws_smithy_xml::decode::XmlError::custom(format!(\n            \"invalid root, expected CreateLoadBalancerResponse got {:?}\",\n            start_el\n        )));\n    }\n    if let Some(mut result_tag) = decoder.next_tag() {\n        let start_el = result_tag.start_el();\n        if !(start_el.matches(\"CreateLoadBalancerResult\")) {\n            return Err(aws_smithy_xml::decode::XmlError::custom(format!(\n                \"invalid result, expected CreateLoadBalancerResult got {:?}\",\n                start_el\n            )));\n        }\n        while let Some(mut tag) = result_tag.next_tag() {\n            match tag.start_el() {\n            s if s.matches(\"LoadBalancers\") /* LoadBalancers com.amazonaws.elasticloadbalancingv2.synthetic#CreateLoadBalancerOutput$LoadBalancers */ =>  {\n                let var_34 =\n                    Some(\n                        crate::xml_deser::deser_list_com_amazonaws_elasticloadbalancingv2_load_balancers(&mut tag)\n                        ?\n                    )\n                ;\n                builder = builder.set_load_balancers(var_34);\n            }\n            ,\n            _ => {}\n        }\n        }\n    } else {\n        return Err(aws_smithy_xml::decode::XmlError::custom(\n            \"expected CreateLoadBalancerResult tag\",\n        ));\n    };\n    Ok(builder)\n"]], "pred": {"ppl": 2.6260263919830322, "ppl_lower": 2.958932876586914, "ppl/lowercase_ppl": -1.123625422671831, "ppl/zlib": 0.0015801502882000075, "Min_5.0% Prob": 8.277879538359466, "Min_10.0% Prob": 6.421948797052557, "Min_20.0% Prob": 4.264041924261832, "Min_30.0% Prob": 3.0970033985304544, "Min_40.0% Prob": 2.3862055481017173, "Min_50.0% Prob": 1.9233390418075615, "Min_60.0% Prob": 1.6102937404346}}
{"hexsha": "84c23658828a7fca46ef7a8340541724fc5d3044", "ext": "rs", "lang": "Rust", "content": "fn exec(attempts: i32, command: &mut Command) -> String {\n    let command_line = format!(\"{:?}\", command);\n\n    for _attempt in 0..attempts {\n        match command.output() {\n            Ok(output) => return String::from_utf8(output.stdout).expect(\"parse UTF8 string\"),\n            Err(err) => {\n                eprintln!(\n                    \"Godot command failed:\\n  command: {}\\n  error: {}\",\n                    command_line, err\n                )\n            }\n        }\n    }\n\n    panic!(\"Could not execute Godot command (see above).\")\n}", "item_id": 1, "repo": "orion78fr/godot-rust", "file": "bindings_generator/src/godot_api_json.rs", "last_update_at": "2022-03-28T20:34:55+00:00", "question_id": "84c23658828a7fca46ef7a8340541724fc5d3044_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn exec(attempts: i32, command: &mut Command) -> String {\n    let command_line = format!(\"{:?}\", command);\n    for _attempt in 0..attempts {\n        match command.output() {\n            Ok(output) => return String::from_utf8(output.stdout).expect(\"parse UTF8 string\"),\n            Err(err) => {\n                eprintln!(\n                    \"Godot command failed:\\n  command: {}\\n  error: {}\",\n                    command_line, err\n                )\n            }\n        }\n    }\n    panic!(\"Could not execute Godot command (see above).\")\n"]], "pred": {"ppl": 2.653169631958008, "ppl_lower": 3.176302671432495, "ppl/lowercase_ppl": -1.184434436173698, "ppl/zlib": 0.003435757087276889, "Min_5.0% Prob": 7.803892884935651, "Min_10.0% Prob": 5.896194394429525, "Min_20.0% Prob": 4.100165340208238, "Min_30.0% Prob": 3.0871333648329196, "Min_40.0% Prob": 2.396604135632515, "Min_50.0% Prob": 1.9376544195872087, "Min_60.0% Prob": 1.6326050046150402}}
{"hexsha": "81dd805358ffce9d8cee14099785d2615d8df9bd", "ext": "rs", "lang": "Rust", "content": "pub fn DCONST_1(code_reader: CodeReader, thread: Thread) -> (ExecuteResult, CodeReader) {\n    println!(\"DCONST_1\");\n    let (frame, thread) = thread.pop_frame();\n\n    let Frame {\n        operand_stack,\n        local_vars,\n        method,\n        class,\n    } = frame;\n    let operand_stack = operand_stack.push_double(1f64);\n    let local_vars = local_vars;\n    let frame = Frame {\n        class,\n        operand_stack,\n        local_vars,\n        method,\n    };\n    let thread = thread.push_frame(frame);\n    let execute_result = ExecuteResult { thread, offset: 0 };\n    (execute_result, code_reader)\n}", "item_id": 1, "repo": "standbyme/jvm-rs", "file": "src/instruction/constant/xconst.rs", "last_update_at": "2022-03-15T11:40:26+00:00", "question_id": "81dd805358ffce9d8cee14099785d2615d8df9bd_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn DCONST_1(code_reader: CodeReader, thread: Thread) -> (ExecuteResult, CodeReader) {\n    println!(\"DCONST_1\");\n    let (frame, thread) = thread.pop_frame();\n    let Frame {\n        operand_stack,\n        local_vars,\n        method,\n        class,\n    } = frame;\n    let operand_stack = operand_stack.push_double(1f64);\n    let local_vars = local_vars;\n    let frame = Frame {\n        class,\n        operand_stack,\n        local_vars,\n        method,\n    };\n    let thread = thread.push_frame(frame);\n    let execute_result = ExecuteResult { thread, offset: 0 };\n    (execute_result, code_reader)\n"]], "pred": {"ppl": 1.910606861114502, "ppl_lower": 2.4000301361083984, "ppl/lowercase_ppl": -1.3522598158973007, "ppl/zlib": 0.0024339132328036884, "Min_5.0% Prob": 7.23124525282118, "Min_10.0% Prob": 4.800762891769409, "Min_20.0% Prob": 2.9908223983488584, "Min_30.0% Prob": 2.0896185084149757, "Min_40.0% Prob": 1.6125696798810711, "Min_50.0% Prob": 1.290548589003762, "Min_60.0% Prob": 1.0815287621868452}}
{"hexsha": "818f200fd90b770a503fb40d7dc82f16b8c56849", "ext": "rs", "lang": "Rust", "content": "async fn set_and_reset_distinct_attribute_with_dedicated_route() {\n    let server = Server::new().await;\n    let index = server.index(\"test\");\n\n    let (_response, _code) = index.update_distinct_attribute(json!(\"test\")).await;\n    index.wait_update_id(0).await;\n\n    let (response, _) = index.get_distinct_attribute().await;\n\n    assert_eq!(response, \"test\");\n\n    index.update_distinct_attribute(json!(null)).await;\n\n    index.wait_update_id(1).await;\n\n    let (response, _) = index.get_distinct_attribute().await;\n\n    assert_eq!(response, json!(null));\n}", "item_id": 1, "repo": "palfrey/MeiliSearch", "file": "meilisearch-http/tests/settings/distinct.rs", "last_update_at": "2022-01-26T12:15:39+00:00", "question_id": "818f200fd90b770a503fb40d7dc82f16b8c56849_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn set_and_reset_distinct_attribute_with_dedicated_route() {\n    let server = Server::new().await;\n    let index = server.index(\"test\");\n    let (_response, _code) = index.update_distinct_attribute(json!(\"test\")).await;\n    index.wait_update_id(0).await;\n    let (response, _) = index.get_distinct_attribute().await;\n    assert_eq!(response, \"test\");\n    index.update_distinct_attribute(json!(null)).await;\n    index.wait_update_id(1).await;\n    let (response, _) = index.get_distinct_attribute().await;\n    assert_eq!(response, json!(null));\n"]], "pred": {"ppl": 2.44069766998291, "ppl_lower": 2.4416303634643555, "ppl/lowercase_ppl": -1.0004281923620488, "ppl/zlib": 0.004269301094524841, "Min_5.0% Prob": 7.762721485561794, "Min_10.0% Prob": 5.942314638031854, "Min_20.0% Prob": 3.861239997116295, "Min_30.0% Prob": 2.8486113916743885, "Min_40.0% Prob": 2.187708153313882, "Min_50.0% Prob": 1.782827674937637, "Min_60.0% Prob": 1.4843448009845372}}
{"hexsha": "e7730aba85b226b2b7c71c4cc2d0dad0be71c85e", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let matches = App::new(\"rlox\")\n        .version(\"0.1.0\")\n        .about(\"lox language interpreter\")\n        .author(\"Thomas Peters\")\n        .arg(\n            Arg::with_name(INPUT_STR)\n                .help(\"sets input file to use\")\n                .required(false)\n                .index(1),\n        )\n        .arg(\n            Arg::with_name(SHOW_TOKENS_STR)\n                .long(\"--show-tokens\")\n                .takes_value(false)\n                .help(\"show the token stream\"),\n        )\n        .arg(\n            Arg::with_name(SHOW_AST_STR)\n                .long(\"--show-ast\")\n                .takes_value(false)\n                .help(\"show the AST\"),\n        )\n        .arg(\n            Arg::with_name(DISASSEMBLE_STR)\n                .long(\"--disassemble\")\n                .takes_value(false)\n                .help(\"show the bytecode\"),\n        )\n        .arg(\n            Arg::with_name(DEBUG_STR)\n                .long(\"--debug\")\n                .takes_value(false)\n                .help(\"run in the debugger\"),\n        )\n        .arg(\n            Arg::with_name(TREEWALK_STR)\n                .long(\"--treewalk\")\n                .takes_value(false)\n                .help(\"run the tree-walk interpreter instead of the bytecode interpreter\"),\n        )\n        .arg(\n            Arg::with_name(LITERAL_INPUT)\n                .long(\"-c\")\n                .takes_value(true)\n                .help(\"provide a literal string of Lox code\"),\n        )\n        .arg(\n            Arg::with_name(EXTENSION_LISTS)\n                .long(&format![\"--{}\", EXTENSION_LISTS])\n                .takes_value(false)\n                .help(\"use the lists extension\"),\n        )\n        .arg(\n            Arg::with_name(EXTENSION_LAMBDAS)\n                .long(&format![\"--{}\", EXTENSION_LAMBDAS])\n                .takes_value(false)\n                .help(\"use the lambdas extension\"),\n        )\n        .get_matches();\n\n    let extensions = extensions::Extensions {\n        lists: matches.is_present(EXTENSION_LISTS),\n        lambdas: matches.is_present(EXTENSION_LAMBDAS),\n    };\n\n    if let Some(input) = get_input(&matches) {\n        if matches.is_present(SHOW_TOKENS_STR)\n            || matches.is_present(SHOW_AST_STR)\n            || matches.is_present(TREEWALK_STR)\n        {\n            match scanner::scan_tokens(input.content.clone()) {\n                Ok(tokens) => {\n                    if matches.is_present(SHOW_TOKENS_STR) {\n                        println!(\"{:#?}\", tokens);\n                        std::process::exit(0);\n                    }\n\n                    let stmts_maybe = parser::parse(extensions, tokens);\n\n                    match stmts_maybe {\n                        Ok(stmts) => {\n                            if matches.is_present(SHOW_AST_STR) {\n                                println!(\"{:#?}\", stmts);\n                                std::process::exit(0);\n                            }\n\n                            let mut interpreter: treewalk_interpreter::Interpreter =\n                                Default::default();\n                            let interpret_result = interpreter.interpret(&stmts);\n\n                            match interpret_result {\n                                Ok(_) => {\n                                    std::process::exit(0);\n                                }\n                                Err(err) => {\n                                    println!(\n                                        \"Runtime Error: {}\\n\\n{}\",\n                                        err,\n                                        interpreter.format_backtrace()\n                                    );\n                                    std::process::exit(-1);\n                                }\n                            }\n                        }\n                        Err(err) => {\n                            error_formatting::format_parse_error(&err, &input);\n                            std::process::exit(-1)\n                        }\n                    }\n                }\n                Err(err) => {\n                    error_formatting::format_lexical_error(&err, &input);\n                    std::process::exit(-1);\n                }\n            }\n        }\n\n        let func_or_err = compiler::Compiler::compile(input.content.clone(), extensions);\n\n        match func_or_err {\n            Ok(func) => {\n                if matches.is_present(DISASSEMBLE_STR) {\n                    println!(\n                        \"{}\",\n                        bytecode_interpreter::disassemble_chunk(&func.chunk, \"\")\n                    );\n                    std::process::exit(0);\n                }\n                if matches.is_present(DEBUG_STR) {\n                    debugger::Debugger::new(func, input.content).debug();\n                    std::process::exit(0);\n                }\n                let mut interpreter = bytecode_interpreter::Interpreter::default();\n                let res = interpreter.interpret(func);\n                match res {\n                    Ok(()) => {\n                        std::process::exit(0);\n                    }\n                    Err(bytecode_interpreter::InterpreterError::Runtime(err)) => {\n                        println!(\n                            \"Runtime error: {}\\n\\n{}\",\n                            err,\n                            interpreter.format_backtrace()\n                        );\n\n                        std::process::exit(1);\n                    }\n                }\n            }\n            Err(err) => {\n                error_formatting::format_compiler_error(&err, &input);\n                std::process::exit(1);\n            }\n        }\n    } else {\n        repl::run(extensions);\n    }\n}", "item_id": 1, "repo": "pedrogao/crafting-interpreters-rs", "file": "src/main.rs", "last_update_at": "2022-03-05T08:26:00+00:00", "question_id": "e7730aba85b226b2b7c71c4cc2d0dad0be71c85e_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let matches = App::new(\"rlox\")\n        .version(\"0.1.0\")\n        .about(\"lox language interpreter\")\n        .author(\"Thomas Peters\")\n        .arg(\n            Arg::with_name(INPUT_STR)\n                .help(\"sets input file to use\")\n                .required(false)\n                .index(1),\n        )\n        .arg(\n            Arg::with_name(SHOW_TOKENS_STR)\n                .long(\"--show-tokens\")\n                .takes_value(false)\n                .help(\"show the token stream\"),\n        )\n        .arg(\n            Arg::with_name(SHOW_AST_STR)\n                .long(\"--show-ast\")\n                .takes_value(false)\n                .help(\"show the AST\"),\n        )\n        .arg(\n            Arg::with_name(DISASSEMBLE_STR)\n                .long(\"--disassemble\")\n                .takes_value(false)\n                .help(\"show the bytecode\"),\n        )\n        .arg(\n            Arg::with_name(DEBUG_STR)\n                .long(\"--debug\")\n                .takes_value(false)\n                .help(\"run in the debugger\"),\n        )\n        .arg(\n            Arg::with_name(TREEWALK_STR)\n                .long(\"--treewalk\")\n                .takes_value(false)\n                .help(\"run the tree-walk interpreter instead of the bytecode interpreter\"),\n        )\n        .arg(\n            Arg::with_name(LITERAL_INPUT)\n                .long(\"-c\")\n                .takes_value(true)\n                .help(\"provide a literal string of Lox code\"),\n        )\n        .arg(\n            Arg::with_name(EXTENSION_LISTS)\n                .long(&format![\"--{}\", EXTENSION_LISTS])\n                .takes_value(false)\n                .help(\"use the lists extension\"),\n        )\n        .arg(\n            Arg::with_name(EXTENSION_LAMBDAS)\n                .long(&format![\"--{}\", EXTENSION_LAMBDAS])\n                .takes_value(false)\n                .help(\"use the lambdas extension\"),\n        )\n        .get_matches();\n    let extensions = extensions::Extensions {\n        lists: matches.is_present(EXTENSION_LISTS),\n        lambdas: matches.is_present(EXTENSION_LAMBDAS),\n    };\n    if let Some(input) = get_input(&matches) {\n        if matches.is_present(SHOW_TOKENS_STR)\n            || matches.is_present(SHOW_AST_STR)\n            || matches.is_present(TREEWALK_STR)\n        {\n            match scanner::scan_tokens(input.content.clone()) {\n                Ok(tokens) => {\n                    if matches.is_present(SHOW_TOKENS_STR) {\n                        println!(\"{:#?}\", tokens);\n                        std::process::exit(0);\n                    }\n                    let stmts_maybe = parser::parse(extensions, tokens);\n                    match stmts_maybe {\n                        Ok(stmts) => {\n                            if matches.is_present(SHOW_AST_STR) {\n                                println!(\"{:#?}\", stmts);\n                                std::process::exit(0);\n                            }\n                            let mut interpreter: treewalk_interpreter::Interpreter =\n                                Default::default();\n                            let interpret_result = interpreter.interpret(&stmts);\n                            match interpret_result {\n                                Ok(_) => {\n                                    std::process::exit(0);\n                                }\n                                Err(err) => {\n                                    println!(\n                                        \"Runtime Error: {}\\n\\n{}\",\n                                        err,\n                                        interpreter.format_backtrace()\n                                    );\n                                    std::process::exit(-1);\n                                }\n                            }\n                        }\n                        Err(err) => {\n                            error_formatting::format_parse_error(&err, &input);\n                            std::process::exit(-1)\n                        }\n                    }\n                }\n                Err(err) => {\n                    error_formatting::format_lexical_error(&err, &input);\n                    std::process::exit(-1);\n                }\n            }\n        }\n        let func_or_err = compiler::Compiler::compile(input.content.clone(), extensions);\n        match func_or_err {\n            Ok(func) => {\n                if matches.is_present(DISASSEMBLE_STR) {\n                    println!(\n                        \"{}\",\n                        bytecode_interpreter::disassemble_chunk(&func.chunk, \"\")\n                    );\n                    std::process::exit(0);\n                }\n                if matches.is_present(DEBUG_STR) {\n                    debugger::Debugger::new(func, input.content).debug();\n                    std::process::exit(0);\n                }\n                let mut interpreter = bytecode_interpreter::Interpreter::default();\n                let res = interpreter.interpret(func);\n                match res {\n                    Ok(()) => {\n                        std::process::exit(0);\n                    }\n                    Err(bytecode_interpreter::InterpreterError::Runtime(err)) => {\n                        println!(\n                            \"Runtime error: {}\\n\\n{}\",\n                            err,\n                            interpreter.format_backtrace()\n                        );\n                        std::process::exit(1);\n                    }\n                }\n            }\n            Err(err) => {\n                error_formatting::format_compiler_error(&err, &input);\n                std::process::exit(1);\n            }\n        }\n    } else {\n        repl::run(extensions);\n    }\n"]], "pred": {"ppl": 1.5959270000457764, "ppl_lower": 1.6753495931625366, "ppl/lowercase_ppl": -1.1038968932793813, "ppl/zlib": 0.0003938119281060265, "Min_5.0% Prob": 5.432213418623981, "Min_10.0% Prob": 3.7516300935371247, "Min_20.0% Prob": 2.253774493932724, "Min_30.0% Prob": 1.5510943659209933, "Min_40.0% Prob": 1.1674241653454551, "Min_50.0% Prob": 0.9354503833111959, "Min_60.0% Prob": 0.7800046636931504}}
{"hexsha": "3d2f9b7c606e02ad5e3851c7dc9d48cc8915be9e", "ext": "rs", "lang": "Rust", "content": "fn print_usage(to: PrintDestination) {\n    let prog_name = PathBuf::from(env::args_os().next().unwrap())\n        .file_name()\n        .unwrap()\n        .to_string_lossy()\n        .to_string();\n    let usage = format!(\n        \"{N} [-{h}|{V}] [-{x}] [-{P} PUBLIC_KEY]\\n\\\n         {w:width$} [-{E} SIG_PATH] [-{e} SHA256]\\n\\\n         {w:width$} [-{S} SIG_PATH] [-{s} SHA256]\\n\\\n         {w:width$} <EXECUTABLE_PATH> [<SCRIPT_PATH>] [..ARGS]\\n\\n\\\n         [-{h}] * Print help and exit\\n\\\n         [-{V}] * Print version and exit\\n\\\n         [-{x}] * Use execve()\\n\\\n         [-{P}] * Minisign base64 public key\\n\\\n         [-{E}] * Executable signature path\\n\\\n         [-{e}] * Executable hash\\n\\\n         [-{S}] * Script signature path\\n\\\n         [-{s}] * Script hash\",\n        N = prog_name,\n        h = flag::HELP,\n        V = flag::VERSION,\n        x = flag::EXEC,\n        P = flag::PUBLIC_KEY,\n        E = flag::EXECUTABLE_SIG_PATH,\n        e = flag::EXECUTABLE_HASH,\n        S = flag::SCRIPT_SIG_PATH,\n        s = flag::SCRIPT_HASH,\n        w = \"\",\n        width = prog_name.chars().count(),\n    );\n    match to {\n        PrintDestination::Stdout => println!(\"{}\", usage),\n        PrintDestination::Stderr => eprintln!(\"{}\", usage),\n    }\n}", "item_id": 0, "repo": "x13a/exec-guard", "file": "src/main.rs", "last_update_at": "2022-01-23T15:06:43+00:00", "question_id": "3d2f9b7c606e02ad5e3851c7dc9d48cc8915be9e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn print_usage(to: PrintDestination) {\n    let prog_name = PathBuf::from(env::args_os().next().unwrap())\n        .file_name()\n        .unwrap()\n        .to_string_lossy()\n        .to_string();\n    let usage = format!(\n        \"{N} [-{h}|{V}] [-{x}] [-{P} PUBLIC_KEY]\\n\\\n         {w:width$} [-{E} SIG_PATH] [-{e} SHA256]\\n\\\n         {w:width$} [-{S} SIG_PATH] [-{s} SHA256]\\n\\\n         {w:width$} <EXECUTABLE_PATH> [<SCRIPT_PATH>] [..ARGS]\\n\\n\\\n         [-{h}] * Print help and exit\\n\\\n         [-{V}] * Print version and exit\\n\\\n         [-{x}] * Use execve()\\n\\\n         [-{P}] * Minisign base64 public key\\n\\\n         [-{E}] * Executable signature path\\n\\\n         [-{e}] * Executable hash\\n\\\n         [-{S}] * Script signature path\\n\\\n         [-{s}] * Script hash\",\n        N = prog_name,\n        h = flag::HELP,\n        V = flag::VERSION,\n        x = flag::EXEC,\n        P = flag::PUBLIC_KEY,\n        E = flag::EXECUTABLE_SIG_PATH,\n        e = flag::EXECUTABLE_HASH,\n        S = flag::SCRIPT_SIG_PATH,\n        s = flag::SCRIPT_HASH,\n        w = \"\",\n        width = prog_name.chars().count(),\n    );\n    match to {\n        PrintDestination::Stdout => println!(\"{}\", usage),\n        PrintDestination::Stderr => eprintln!(\"{}\", usage),\n    }\n"]], "pred": {"ppl": 2.1543126106262207, "ppl_lower": 2.3768372535705566, "ppl/lowercase_ppl": -1.12808162253668, "ppl/zlib": 0.001481605595531382, "Min_5.0% Prob": 7.035106493079144, "Min_10.0% Prob": 5.346382892650107, "Min_20.0% Prob": 3.4549905926950517, "Min_30.0% Prob": 2.485344479409911, "Min_40.0% Prob": 1.9006373619119967, "Min_50.0% Prob": 1.5296495422369165, "Min_60.0% Prob": 1.2805037643379902}}
{"hexsha": "366b24c4937caaf5198dfb7c4b26bbe44abf2ba0", "ext": "rs", "lang": "Rust", "content": "fn leading_dot() {\n    const LEADING_DOT: &str = \".111\";\n\n    lexer_test(LEADING_DOT, Single(Err(LexerError::LeadingDot(0, 0))));\n\n    const LEADING_DOT_AFTER_SIGN: &str = \"+.1111\";\n\n    lexer_test(\n        LEADING_DOT_AFTER_SIGN,\n        Single(Err(LexerError::LeadingDot(1, 1))),\n    );\n}", "item_id": 6, "repo": "fluencelabs/aquavm", "file": "crates/air-lib/air-parser/src/parser/lexer/tests.rs", "last_update_at": "2022-03-19T07:49:13+00:00", "question_id": "366b24c4937caaf5198dfb7c4b26bbe44abf2ba0_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn leading_dot() {\n    const LEADING_DOT: &str = \".111\";\n    lexer_test(LEADING_DOT, Single(Err(LexerError::LeadingDot(0, 0))));\n    const LEADING_DOT_AFTER_SIGN: &str = \"+.1111\";\n    lexer_test(\n        LEADING_DOT_AFTER_SIGN,\n        Single(Err(LexerError::LeadingDot(1, 1))),\n    );\n"]], "pred": {"ppl": 2.499711513519287, "ppl_lower": 3.6937174797058105, "ppl/lowercase_ppl": -1.4261826904942647, "ppl/zlib": 0.005835511660021667, "Min_5.0% Prob": 8.872148513793945, "Min_10.0% Prob": 6.636379718780518, "Min_20.0% Prob": 4.129215152175338, "Min_30.0% Prob": 2.9920092981036115, "Min_40.0% Prob": 2.2841869535771284, "Min_50.0% Prob": 1.8299074337372314, "Min_60.0% Prob": 1.541359430678734}}
{"hexsha": "d9996dac95a8685c5b10471c5e631791509a6bd3", "ext": "rs", "lang": "Rust", "content": "pub fn delete(conn: DatabaseConnection, user: User, id: i32) -> Result<JsonValue> {\n\tlet log_type_model = LogType::new(&conn, id)?.as_model();\n\n\tif log_type_model.user_id != user.get_id() {\n\t\treturn Err(ErrorKind::AccessDenied.into());\n\t}\n\n\tdiesel::delete(log_type_dsl::log_type)\n\t\t.filter(log_type_dsl::id.eq(id))\n\t\t.execute(&*conn)?;\n\n\tOk(json!({\n\t\t\"status\": true\n\t}))\n}", "item_id": 2, "repo": "zeljic/rpi-stats-service", "file": "service/collector/src/routes/log_type.rs", "last_update_at": "2022-02-26T10:05:30+00:00", "question_id": "d9996dac95a8685c5b10471c5e631791509a6bd3_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn delete(conn: DatabaseConnection, user: User, id: i32) -> Result<JsonValue> {\n\tlet log_type_model = LogType::new(&conn, id)?.as_model();\n\tif log_type_model.user_id != user.get_id() {\n\t\treturn Err(ErrorKind::AccessDenied.into());\n\t}\n\tdiesel::delete(log_type_dsl::log_type)\n\t\t.filter(log_type_dsl::id.eq(id))\n\t\t.execute(&*conn)?;\n\tOk(json!({\n\t\t\"status\": true\n\t}))\n"]], "pred": {"ppl": 2.7690088748931885, "ppl_lower": 3.8668971061706543, "ppl/lowercase_ppl": -1.3279002596019203, "ppl/zlib": 0.003902258426334558, "Min_5.0% Prob": 7.978192601885114, "Min_10.0% Prob": 6.357019917170207, "Min_20.0% Prob": 4.246790620588487, "Min_30.0% Prob": 3.182206966775529, "Min_40.0% Prob": 2.528688091904886, "Min_50.0% Prob": 2.038886588257857, "Min_60.0% Prob": 1.6983228796260788}}
{"hexsha": "8bde40cec4cf22d7a4be6d75793d9f2ca1eef708", "ext": "rs", "lang": "Rust", "content": "pub fn crawl_directory_for_repos(directory: &Path) -> IoResult<Vec<Repository>> {\n\t// Contains paths to explore\n\tlet paths = SegQueue::new();\n\tpaths.push(directory.to_path_buf());\n\n\t// Contains found repositories\n\tlet repositories = SegQueue::new();\n\n\t// Set the number of threads to use for crawling\n\tlet thread_count = max(8, num_cpus::get() * 2);\n\n\tthread::scope(|scope| {\n\t\tfor _ in 0..thread_count {\n\t\t\tscope.spawn(|_| {\n\t\t\t\twhile let Some(path) = paths.pop() {\n\t\t\t\t\tcrawl(path, &paths, &repositories).unwrap();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t})\n\t.unwrap_or_else(|_| error!(\"Could not spawn threads\"));\n\n\t// Return the repositories in a `Vec`\n\tOk(repositories.into_iter().collect::<Vec<_>>())\n}", "item_id": 0, "repo": "MrNossiom/git-leave", "file": "src/crawl.rs", "last_update_at": "2022-03-22T17:26:45+00:00", "question_id": "8bde40cec4cf22d7a4be6d75793d9f2ca1eef708_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn crawl_directory_for_repos(directory: &Path) -> IoResult<Vec<Repository>> {\n\t// Contains paths to explore\n\tlet paths = SegQueue::new();\n\tpaths.push(directory.to_path_buf());\n\t// Contains found repositories\n\tlet repositories = SegQueue::new();\n\t// Set the number of threads to use for crawling\n\tlet thread_count = max(8, num_cpus::get() * 2);\n\tthread::scope(|scope| {\n\t\tfor _ in 0..thread_count {\n\t\t\tscope.spawn(|_| {\n\t\t\t\twhile let Some(path) = paths.pop() {\n\t\t\t\t\tcrawl(path, &paths, &repositories).unwrap();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t})\n\t.unwrap_or_else(|_| error!(\"Could not spawn threads\"));\n\t// Return the repositories in a `Vec`\n\tOk(repositories.into_iter().collect::<Vec<_>>())\n"]], "pred": {"ppl": 2.395925998687744, "ppl_lower": 2.927478551864624, "ppl/lowercase_ppl": -1.2293186339100803, "ppl/zlib": 0.002229004577603421, "Min_5.0% Prob": 7.761986970901489, "Min_10.0% Prob": 5.789235639572143, "Min_20.0% Prob": 3.7812843603246353, "Min_30.0% Prob": 2.7875828107720926, "Min_40.0% Prob": 2.157715471059668, "Min_50.0% Prob": 1.7389901851129252, "Min_60.0% Prob": 1.4598488558229863}}
{"hexsha": "376d280fed48ebbede1b0b917d74cf57c426dee0", "ext": "rs", "lang": "Rust", "content": "pub fn daa(cpu: &mut crate::cpu::Cpu) {\n    if cpu.registers.a & 0xf > 0x09 || cpu.registers.f.h {\n        cpu.registers.a = cpu.registers.a.wrapping_add(0x06);\n    }\n\n    if cpu.registers.a & 0xf0 > 0x90 || cpu.registers.f.c {\n        cpu.registers.a = cpu.registers.a.wrapping_add(0x60);\n        cpu.registers.f.c = true;\n    } else {\n        cpu.registers.f.c = false;\n    }\n\n    cpu.registers.f.z = cpu.registers.a == 0;\n    cpu.registers.f.h = false;\n}", "item_id": 3, "repo": "martinkauppinen/gibberish", "file": "src/cpu/opcodes/logic.rs", "last_update_at": "2022-02-11T18:30:21+00:00", "question_id": "376d280fed48ebbede1b0b917d74cf57c426dee0_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn daa(cpu: &mut crate::cpu::Cpu) {\n    if cpu.registers.a & 0xf > 0x09 || cpu.registers.f.h {\n        cpu.registers.a = cpu.registers.a.wrapping_add(0x06);\n    }\n    if cpu.registers.a & 0xf0 > 0x90 || cpu.registers.f.c {\n        cpu.registers.a = cpu.registers.a.wrapping_add(0x60);\n        cpu.registers.f.c = true;\n    } else {\n        cpu.registers.f.c = false;\n    }\n    cpu.registers.f.z = cpu.registers.a == 0;\n    cpu.registers.f.h = false;\n"]], "pred": {"ppl": 1.6152855157852173, "ppl_lower": 1.6743234395980835, "ppl/lowercase_ppl": -1.0748624771667699, "ppl/zlib": 0.002755814546028755, "Min_5.0% Prob": 5.908415651321411, "Min_10.0% Prob": 3.9783649384975432, "Min_20.0% Prob": 2.2835337803131197, "Min_30.0% Prob": 1.5932629799745122, "Min_40.0% Prob": 1.1980685105365587, "Min_50.0% Prob": 0.9572317488853214, "Min_60.0% Prob": 0.8025270092407075}}
{"hexsha": "812215e67b0cf0df02f68a8b186ce073b0925908", "ext": "rs", "lang": "Rust", "content": "fn test_commutator_scalar_e2() {\n        let scalar = EuclideanMultivector2::from_scalar(6_f64);\n        let e2 = EuclideanMultivector2::unit_e2();\n        let expected = EuclideanMultivector2::zero();\n        let result = scalar.commutator(&e2);\n\n        assert_eq!(result, expected);\n    }", "item_id": 122, "repo": "lambdaxymox/cggeomalg", "file": "tests/test_e2ga.rs", "last_update_at": "2022-03-17T02:23:11+00:00", "question_id": "812215e67b0cf0df02f68a8b186ce073b0925908_122", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_commutator_scalar_e2() {\n        let scalar = EuclideanMultivector2::from_scalar(6_f64);\n        let e2 = EuclideanMultivector2::unit_e2();\n        let expected = EuclideanMultivector2::zero();\n        let result = scalar.commutator(&e2);\n        assert_eq!(result, expected);\n"]], "pred": {"ppl": 2.7150838375091553, "ppl_lower": 3.1363866329193115, "ppl/lowercase_ppl": -1.1444185560222437, "ppl/zlib": 0.006571202843989221, "Min_5.0% Prob": 7.699789881706238, "Min_10.0% Prob": 6.158953931596544, "Min_20.0% Prob": 4.298134414773238, "Min_30.0% Prob": 3.1584038754989363, "Min_40.0% Prob": 2.491291479844796, "Min_50.0% Prob": 2.003918487112969, "Min_60.0% Prob": 1.6669653041352486}}
{"hexsha": "b70fa1910b06cdcf267c9c777989a969c5ab8cb2", "ext": "rs", "lang": "Rust", "content": "fn main() -> io::Result<()> {\n    let mut buffer = String::new();\n    io::stdin().read_to_string(&mut buffer)?;\n\n    let ans: usize = buffer\n        .trim()\n        .split('\\n')\n        .map(|line| {\n\n            let (_, raw_digits) = line.split_once(\" | \").unwrap();\n            let digits: Vec<_> = raw_digits.trim().split_whitespace().collect();\n\n            return digits\n                .iter()\n                .filter(|digit| digit.len() == 2 || digit.len() == 3 || digit.len() == 4 || digit.len() == 7)\n                .count();\n        })\n        .sum();\n\n    println!(\"{}\", ans);\n\n    return Ok(());\n}", "item_id": 0, "repo": "garciparedes/advent-of-code", "file": "2021/08_seven_segment_search_part_1.rs", "last_update_at": "2022-01-08T03:14:57+00:00", "question_id": "b70fa1910b06cdcf267c9c777989a969c5ab8cb2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() -> io::Result<()> {\n    let mut buffer = String::new();\n    io::stdin().read_to_string(&mut buffer)?;\n    let ans: usize = buffer\n        .trim()\n        .split('\\n')\n        .map(|line| {\n            let (_, raw_digits) = line.split_once(\" | \").unwrap();\n            let digits: Vec<_> = raw_digits.trim().split_whitespace().collect();\n            return digits\n                .iter()\n                .filter(|digit| digit.len() == 2 || digit.len() == 3 || digit.len() == 4 || digit.len() == 7)\n                .count();\n        })\n        .sum();\n    println!(\"{}\", ans);\n    return Ok(());\n"]], "pred": {"ppl": 1.584970235824585, "ppl_lower": 1.9108362197875977, "ppl/lowercase_ppl": -1.4059689164658329, "ppl/zlib": 0.0015301183670875576, "Min_5.0% Prob": 5.716088851292928, "Min_10.0% Prob": 3.6319579764416345, "Min_20.0% Prob": 2.1453806116030765, "Min_30.0% Prob": 1.5134661627997612, "Min_40.0% Prob": 1.1472360789298246, "Min_50.0% Prob": 0.9187648334274334, "Min_60.0% Prob": 0.7707685597408085}}
{"hexsha": "977214e75800d0332ff5afeaa8695c47d93db661", "ext": "rs", "lang": "Rust", "content": "fn get_server_response<D: DelayUs>(\n    spi_drv: &mut SpiDrv,\n    uart: &mut EnabledUart,\n    delay: &mut D,\n    socket: u8,\n) -> Result<httparse::Status<usize>, String<STR_LEN>> {\n    let response_length: u16 = 0;\n    let mut avail_length: usize = 0;\n    let n = 0;\n    let response_buf: [u8; RESPONSE_BUF_LEN] = [0; RESPONSE_BUF_LEN];\n    let mut timeout: u16 = 1000;\n\n    while timeout > 0 {\n        delay.delay_ms(50).ok().unwrap();\n        avail_length = avail_data(spi_drv, uart, socket)?;\n        if avail_length > 0 {\n            break;\n        }\n\n        timeout -= 1;\n    }\n\n    write!(\n        uart,\n        \"\\tresponse_length: {:?} avail_length {:?}\\r\\n\",\n        response_length, avail_length\n    )\n    .ok()\n    .unwrap();\n\n    let response_buf = get_data_buf(spi_drv, uart, socket, avail_length as u16)?;\n    let response_str = core::str::from_utf8(&response_buf).unwrap();\n\n    writeln!(\n        uart,\n        \"\\tHTTP server response string: {:?}\\r\\n\",\n        response_str\n    )\n    .ok()\n    .unwrap();\n\n    let mut headers = [httparse::EMPTY_HEADER; 64];\n    let mut response = httparse::Response::new(&mut headers);\n    match response.parse(&response_buf) {\n        Ok(parsed) => {\n            write!(\n                uart,\n                \"HTTP response version: {:?}\\r\\n\",\n                response.version.unwrap()\n            )\n            .ok()\n            .unwrap();\n            write!(uart, \"HTTP response code: {:?}\\r\\n\", response.code.unwrap())\n                .ok()\n                .unwrap();\n            writeln!(\n                uart,\n                \"HTTP response reason: {:?}\\r\\n\",\n                response.reason.unwrap()\n            )\n            .ok()\n            .unwrap();\n\n            if response.code.unwrap() == 200 {\n                write!(uart, \"Got successful response from HTTP server.\\r\\n\")\n                    .ok()\n                    .unwrap();\n            } else if response.code.unwrap() == 400 {\n                write!(uart, \"** Got error response from HTTP server.\\r\\n\")\n                    .ok()\n                    .unwrap();\n            }\n            return Ok(parsed);\n        }\n\n        Err(e) => {\n            write!(uart, \"Failed to parse HTTP server response: {:?}\\r\\n\", e)\n                .ok()\n                .unwrap();\n            return Err(String::from(\"Failed to parse HTTP server response\"));\n        }\n    }\n}", "item_id": 13, "repo": "Jim-Hodapp-Coaching/esp32-pico-wifi", "file": "src/main.rs", "last_update_at": "2022-03-19T08:43:47+00:00", "question_id": "977214e75800d0332ff5afeaa8695c47d93db661_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_server_response<D: DelayUs>(\n    spi_drv: &mut SpiDrv,\n    uart: &mut EnabledUart,\n    delay: &mut D,\n    socket: u8,\n) -> Result<httparse::Status<usize>, String<STR_LEN>> {\n    let response_length: u16 = 0;\n    let mut avail_length: usize = 0;\n    let n = 0;\n    let response_buf: [u8; RESPONSE_BUF_LEN] = [0; RESPONSE_BUF_LEN];\n    let mut timeout: u16 = 1000;\n    while timeout > 0 {\n        delay.delay_ms(50).ok().unwrap();\n        avail_length = avail_data(spi_drv, uart, socket)?;\n        if avail_length > 0 {\n            break;\n        }\n        timeout -= 1;\n    }\n    write!(\n        uart,\n        \"\\tresponse_length: {:?} avail_length {:?}\\r\\n\",\n        response_length, avail_length\n    )\n    .ok()\n    .unwrap();\n    let response_buf = get_data_buf(spi_drv, uart, socket, avail_length as u16)?;\n    let response_str = core::str::from_utf8(&response_buf).unwrap();\n    writeln!(\n        uart,\n        \"\\tHTTP server response string: {:?}\\r\\n\",\n        response_str\n    )\n    .ok()\n    .unwrap();\n    let mut headers = [httparse::EMPTY_HEADER; 64];\n    let mut response = httparse::Response::new(&mut headers);\n    match response.parse(&response_buf) {\n        Ok(parsed) => {\n            write!(\n                uart,\n                \"HTTP response version: {:?}\\r\\n\",\n                response.version.unwrap()\n            )\n            .ok()\n            .unwrap();\n            write!(uart, \"HTTP response code: {:?}\\r\\n\", response.code.unwrap())\n                .ok()\n                .unwrap();\n            writeln!(\n                uart,\n                \"HTTP response reason: {:?}\\r\\n\",\n                response.reason.unwrap()\n            )\n            .ok()\n            .unwrap();\n            if response.code.unwrap() == 200 {\n                write!(uart, \"Got successful response from HTTP server.\\r\\n\")\n                    .ok()\n                    .unwrap();\n            } else if response.code.unwrap() == 400 {\n                write!(uart, \"** Got error response from HTTP server.\\r\\n\")\n                    .ok()\n                    .unwrap();\n            }\n            return Ok(parsed);\n        }\n        Err(e) => {\n            write!(uart, \"Failed to parse HTTP server response: {:?}\\r\\n\", e)\n                .ok()\n                .unwrap();\n            return Err(String::from(\"Failed to parse HTTP server response\"));\n        }\n    }\n"]], "pred": {"ppl": 1.8389605283737183, "ppl_lower": 2.1801233291625977, "ppl/lowercase_ppl": -1.279351332692014, "ppl/zlib": 0.0008544186279887968, "Min_5.0% Prob": 6.144686176970199, "Min_10.0% Prob": 4.309684505462647, "Min_20.0% Prob": 2.7439572313763447, "Min_30.0% Prob": 1.9603778722539413, "Min_40.0% Prob": 1.506846902904329, "Min_50.0% Prob": 1.2168305031016509, "Min_60.0% Prob": 1.0146860121697945}}
{"hexsha": "0a8fc331e7e14b48c185d68d0b0f4a8a317aa9f6", "ext": "rs", "lang": "Rust", "content": "fn test_file_writer_empty_file() {\n        let file = tempfile::tempfile().unwrap();\n\n        let schema = Arc::new(\n            types::Type::group_type_builder(\"schema\")\n                .with_fields(&mut vec![Arc::new(\n                    types::Type::primitive_type_builder(\"col1\", Type::INT32)\n                        .build()\n                        .unwrap(),\n                )])\n                .build()\n                .unwrap(),\n        );\n        let props = Arc::new(WriterProperties::builder().build());\n        let writer =\n            SerializedFileWriter::new(file.try_clone().unwrap(), schema, props).unwrap();\n        writer.close().unwrap();\n\n        let reader = SerializedFileReader::new(file).unwrap();\n        assert_eq!(reader.get_row_iter(None).unwrap().count(), 0);\n    }", "item_id": 2, "repo": "HaoYang670/arrow-rs", "file": "parquet/src/file/writer.rs", "last_update_at": "2022-03-29T02:31:02+00:00", "question_id": "0a8fc331e7e14b48c185d68d0b0f4a8a317aa9f6_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_file_writer_empty_file() {\n        let file = tempfile::tempfile().unwrap();\n        let schema = Arc::new(\n            types::Type::group_type_builder(\"schema\")\n                .with_fields(&mut vec![Arc::new(\n                    types::Type::primitive_type_builder(\"col1\", Type::INT32)\n                        .build()\n                        .unwrap(),\n                )])\n                .build()\n                .unwrap(),\n        );\n        let props = Arc::new(WriterProperties::builder().build());\n        let writer =\n            SerializedFileWriter::new(file.try_clone().unwrap(), schema, props).unwrap();\n        writer.close().unwrap();\n        let reader = SerializedFileReader::new(file).unwrap();\n        assert_eq!(reader.get_row_iter(None).unwrap().count(), 0);\n"]], "pred": {"ppl": 1.8501567840576172, "ppl_lower": 2.8661675453186035, "ppl/lowercase_ppl": -1.711403336378499, "ppl/zlib": 0.0018815608062341448, "Min_5.0% Prob": 6.53570556640625, "Min_10.0% Prob": 4.475739223616464, "Min_20.0% Prob": 2.803747583003271, "Min_30.0% Prob": 2.0024714614190753, "Min_40.0% Prob": 1.5324939624184655, "Min_50.0% Prob": 1.2327385368623904, "Min_60.0% Prob": 1.029385590386237}}
{"hexsha": "03310e63246987c9fa32df9e5103e22c2c55f425", "ext": "rs", "lang": "Rust", "content": "pub fn fetch(args: InputArgs, filter_list: Vec<Regex>) {\n    let matches = args.get_matches();\n    let filter_hidden = matches.is_present(\"traverse-hidden\");\n\n    let dir_tree_with_options = DirectoryTreeOptions {\n        filter_list: filter_list,\n        filter_hidden: filter_hidden,\n    };\n\n    let root_path = args.get_root_path(\"PATH\");\n    let root = root_path\n        .to_str()\n        .expect(format!(\"{}\", \"Error in converting directory to string\".red()).as_str());\n\n    let multi_bars = ProgressTracker::new(matches.value_of(\"jobs\").and_then(|e| e.parse().ok()));\n    dir_tree_with_options\n        .process_directories(root)\n        .flat_map(|dir| {\n            dir.ok().and_then(|d| {\n                if d.file_name().eq(\".git\") {\n                    d.path().parent().map(|e| e.to_path_buf())\n                } else {\n                    None\n                }\n            })\n        })\n        .map(|dir| GitFetch {\n            dir,\n            remote: \"origin\".to_string(),\n        })\n        .for_each(|clone| multi_bars.start_task(clone));\n\n    multi_bars.join().unwrap();\n}", "item_id": 0, "repo": "thecasualcoder/gg", "file": "src/fetch.rs", "last_update_at": "2022-01-19T08:53:20+00:00", "question_id": "03310e63246987c9fa32df9e5103e22c2c55f425_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn fetch(args: InputArgs, filter_list: Vec<Regex>) {\n    let matches = args.get_matches();\n    let filter_hidden = matches.is_present(\"traverse-hidden\");\n    let dir_tree_with_options = DirectoryTreeOptions {\n        filter_list: filter_list,\n        filter_hidden: filter_hidden,\n    };\n    let root_path = args.get_root_path(\"PATH\");\n    let root = root_path\n        .to_str()\n        .expect(format!(\"{}\", \"Error in converting directory to string\".red()).as_str());\n    let multi_bars = ProgressTracker::new(matches.value_of(\"jobs\").and_then(|e| e.parse().ok()));\n    dir_tree_with_options\n        .process_directories(root)\n        .flat_map(|dir| {\n            dir.ok().and_then(|d| {\n                if d.file_name().eq(\".git\") {\n                    d.path().parent().map(|e| e.to_path_buf())\n                } else {\n                    None\n                }\n            })\n        })\n        .map(|dir| GitFetch {\n            dir,\n            remote: \"origin\".to_string(),\n        })\n        .for_each(|clone| multi_bars.start_task(clone));\n    multi_bars.join().unwrap();\n"]], "pred": {"ppl": 3.417851209640503, "ppl_lower": 3.8090131282806396, "ppl/lowercase_ppl": -1.0881668178894743, "ppl/zlib": 0.0024678956874213767, "Min_5.0% Prob": 8.294959247112274, "Min_10.0% Prob": 6.7538744753057305, "Min_20.0% Prob": 4.786437793211504, "Min_30.0% Prob": 3.716186189892316, "Min_40.0% Prob": 2.9510003841461097, "Min_50.0% Prob": 2.4316308172531875, "Min_60.0% Prob": 2.05009376265146}}
{"hexsha": "5f2264d1e7609ce7a37d36c3bc1a5e67065895e5", "ext": "rs", "lang": "Rust", "content": "pub fn rdtsc() -> u64 {\n    let val_lo: u32;\n    let val_hi: u32;\n\n    unsafe {\n        llvm_asm!(\"rdtsc\" : \"={edx}\"(val_hi), \"={eax}\"(val_lo) ::\n             \"memory\" : \"volatile\", \"intel\");\n    }\n\n    ((val_hi as u64) << 32) | val_lo as u64\n}", "item_id": 3, "repo": "ZiyanWu93/chocolate_milk", "file": "shared/cpu/src/lib.rs", "last_update_at": "2022-03-27T16:21:40+00:00", "question_id": "5f2264d1e7609ce7a37d36c3bc1a5e67065895e5_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn rdtsc() -> u64 {\n    let val_lo: u32;\n    let val_hi: u32;\n    unsafe {\n        llvm_asm!(\"rdtsc\" : \"={edx}\"(val_hi), \"={eax}\"(val_lo) ::\n             \"memory\" : \"volatile\", \"intel\");\n    }\n    ((val_hi as u64) << 32) | val_lo as u64\n"]], "pred": {"ppl": 1.8499256372451782, "ppl_lower": 1.8499256372451782, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.003918123835660266, "Min_5.0% Prob": 7.1941070556640625, "Min_10.0% Prob": 5.04490864276886, "Min_20.0% Prob": 2.8731984651607014, "Min_30.0% Prob": 2.029024706167333, "Min_40.0% Prob": 1.5342254833034847, "Min_50.0% Prob": 1.2275251569868675, "Min_60.0% Prob": 1.0332188501589648}}
{"hexsha": "e6707d103a019faf494dc745d0c33600adf1b0d3", "ext": "rs", "lang": "Rust", "content": "fn write_dummy_executable(executable_data_len: usize) -> Vec<u8> {\n        let mut written_data = Vec::new();\n        let executable_data = vec![0u8; executable_data_len];\n        write_executable(\n            &mut written_data,\n            SegmentOffsetPtr::new(0, 0),\n            &[],\n            &executable_data,\n        )\n        .unwrap();\n        written_data\n    }", "item_id": 1, "repo": "mthiesen/parsec_exe_unpacker", "file": "src/dos_exe.rs", "last_update_at": "2022-02-18T04:15:44+00:00", "question_id": "e6707d103a019faf494dc745d0c33600adf1b0d3_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn write_dummy_executable(executable_data_len: usize) -> Vec<u8> {\n        let mut written_data = Vec::new();\n        let executable_data = vec![0u8; executable_data_len];\n        write_executable(\n            &mut written_data,\n            SegmentOffsetPtr::new(0, 0),\n            &[],\n            &executable_data,\n        )\n        .unwrap();\n        written_data\n"]], "pred": {"ppl": 2.7351386547088623, "ppl_lower": 4.051510810852051, "ppl/lowercase_ppl": -1.39049363743918, "ppl/zlib": 0.005621129223513876, "Min_5.0% Prob": 8.089509391784668, "Min_10.0% Prob": 6.474300341172651, "Min_20.0% Prob": 4.199237196341805, "Min_30.0% Prob": 3.102884488947251, "Min_40.0% Prob": 2.4157125088183777, "Min_50.0% Prob": 2.00344628984468, "Min_60.0% Prob": 1.6726121060226276}}
{"hexsha": "390d2b21871e5247833a2f064d36859858c84b89", "ext": "rs", "lang": "Rust", "content": "fn handles_empty_paths() {\n        let actual = main(\n            &model::Configuration {\n                paths: String::new(),\n                ..model::stubs::configuration()\n            },\n            path::Path::new(\".\"),\n        );\n\n        let actual = actual.unwrap();\n        assert!(actual.is_empty());\n    }", "item_id": 1, "repo": "evolutics/files-embedded-as-modules", "file": "src/list_files/get_raw_paths.rs", "last_update_at": "2022-03-01T07:18:58+00:00", "question_id": "390d2b21871e5247833a2f064d36859858c84b89_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn handles_empty_paths() {\n        let actual = main(\n            &model::Configuration {\n                paths: String::new(),\n                ..model::stubs::configuration()\n            },\n            path::Path::new(\".\"),\n        );\n        let actual = actual.unwrap();\n        assert!(actual.is_empty());\n"]], "pred": {"ppl": 4.133944511413574, "ppl_lower": 5.547956466674805, "ppl/lowercase_ppl": -1.2072935285126172, "ppl/zlib": 0.008348423756920036, "Min_5.0% Prob": 9.636866251627604, "Min_10.0% Prob": 8.18365730558123, "Min_20.0% Prob": 5.855807860692342, "Min_30.0% Prob": 4.34158692670905, "Min_40.0% Prob": 3.4430988084885383, "Min_50.0% Prob": 2.8089789205636735, "Min_60.0% Prob": 2.3649165414749307}}
{"hexsha": "c18cae37cdc78ab843bee1bf7527e5e78439239c", "ext": "rs", "lang": "Rust", "content": "fn test_parser() {\n        assert_eq!(MediaType::Audio, \"AUDIO\".parse().unwrap());\n        assert_eq!(MediaType::Video, \"VIDEO\".parse().unwrap());\n        assert_eq!(MediaType::Subtitles, \"SUBTITLES\".parse().unwrap());\n        assert_eq!(\n            MediaType::ClosedCaptions,\n            \"CLOSED-CAPTIONS\".parse().unwrap()\n        );\n    }", "item_id": 0, "repo": "Sequal32/hls_m3u8", "file": "src/types/media_type.rs", "last_update_at": "2022-02-15T16:52:40+00:00", "question_id": "c18cae37cdc78ab843bee1bf7527e5e78439239c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_parser() {\n        assert_eq!(MediaType::Audio, \"AUDIO\".parse().unwrap());\n        assert_eq!(MediaType::Video, \"VIDEO\".parse().unwrap());\n        assert_eq!(MediaType::Subtitles, \"SUBTITLES\".parse().unwrap());\n        assert_eq!(\n            MediaType::ClosedCaptions,\n            \"CLOSED-CAPTIONS\".parse().unwrap()\n        );\n"]], "pred": {"ppl": 2.078150987625122, "ppl_lower": 2.326759099960327, "ppl/lowercase_ppl": -1.1544786309453121, "ppl/zlib": 0.004487598466915693, "Min_5.0% Prob": 8.818821430206299, "Min_10.0% Prob": 6.263583636283874, "Min_20.0% Prob": 3.6435151469139826, "Min_30.0% Prob": 2.442926690913737, "Min_40.0% Prob": 1.8306077968242556, "Min_50.0% Prob": 1.4611245653661038, "Min_60.0% Prob": 1.233768237696495}}
{"hexsha": "228cdc96b428d6bd27e009d21edbf646dc913494", "ext": "rs", "lang": "Rust", "content": "fn comment_with_single_quotes_one_pass() {\n        let mut scanner = Scanner::new();\n        let bytes = r#\"<!-- goodbye a='val-->'-->Content\"#.as_bytes();\n        assert_eq!(scanner.scan(bytes), Some(State::ScannedComment(22)));\n        assert_eq!(scanner.state, InternalState::Reset);\n    }", "item_id": 62, "repo": "bluk/maybe_xml", "file": "src/scanner.rs", "last_update_at": "2022-03-12T03:55:27+00:00", "question_id": "228cdc96b428d6bd27e009d21edbf646dc913494_62", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn comment_with_single_quotes_one_pass() {\n        let mut scanner = Scanner::new();\n        let bytes = r#\"<!-- goodbye a='val-->'-->Content\"#.as_bytes();\n        assert_eq!(scanner.scan(bytes), Some(State::ScannedComment(22)));\n        assert_eq!(scanner.state, InternalState::Reset);\n"]], "pred": {"ppl": 7.126929759979248, "ppl_lower": 10.12015438079834, "ppl/lowercase_ppl": -1.1785487354670043, "ppl/zlib": 0.010446173047814323, "Min_5.0% Prob": 10.034453630447388, "Min_10.0% Prob": 8.786186059316, "Min_20.0% Prob": 7.176212411177786, "Min_30.0% Prob": 5.805147000721523, "Min_40.0% Prob": 4.657452343325866, "Min_50.0% Prob": 3.8772454052529435, "Min_60.0% Prob": 3.241486125086483}}
{"hexsha": "3ec8df72db047df9c7e3e30aeb87c436f2170203", "ext": "rs", "lang": "Rust", "content": "fn alloc_and_free() {\n        let mut vm = VM::default();\n        let mut system = helper::generate_system();\n\n        let program = helper::program_builder()\n            .instructions(vec![\n                Instruction::Alloc(10),\n                Instruction::Alloc(30),\n                Instruction::Free,\n                Instruction::Free,\n                Instruction::Alloc(20),\n                Instruction::Free,\n            ])\n            .gen();\n\n        vm.exec(&program, &mut system).unwrap();\n\n        assert_eq!(vm.bp, 0);\n    }", "item_id": 33, "repo": "bakervm/melon", "file": "src/vm.rs", "last_update_at": "2022-03-04T03:22:23+00:00", "question_id": "3ec8df72db047df9c7e3e30aeb87c436f2170203_33", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn alloc_and_free() {\n        let mut vm = VM::default();\n        let mut system = helper::generate_system();\n        let program = helper::program_builder()\n            .instructions(vec![\n                Instruction::Alloc(10),\n                Instruction::Alloc(30),\n                Instruction::Free,\n                Instruction::Free,\n                Instruction::Alloc(20),\n                Instruction::Free,\n            ])\n            .gen();\n        vm.exec(&program, &mut system).unwrap();\n        assert_eq!(vm.bp, 0);\n"]], "pred": {"ppl": 2.862313985824585, "ppl_lower": 3.362774610519409, "ppl/lowercase_ppl": -1.1532249628800282, "ppl/zlib": 0.0048686591835685866, "Min_5.0% Prob": 8.74969904763358, "Min_10.0% Prob": 6.406896489007132, "Min_20.0% Prob": 4.138539597905916, "Min_30.0% Prob": 3.176902596340623, "Min_40.0% Prob": 2.5321666454446725, "Min_50.0% Prob": 2.0954183058606253, "Min_60.0% Prob": 1.747636872504292}}
{"hexsha": "1aefff91b0ee55dee2c7d76bb55022029d6a197f", "ext": "rs", "lang": "Rust", "content": "pub fn main(username: String) {\n    let icon_bytes = include_bytes!(\"../assets/icon.ico\");\n    let icon = Icon::from_buffer(icon_bytes, None, None).unwrap();\n    let (s, r) = std::sync::mpsc::channel::<Events>();\n\n    let _tray_icon = TrayIconBuilder::new()\n        .icon(icon)\n        .sender(s)\n        .tooltip(\"Bitwarden Autotype\")\n        .menu(\n            MenuBuilder::new()\n                .with(info_item(\"Bitwarden Autotype is running\"))\n                .separator()\n                .with(info_item(&format!(\"Logged in as {}\", username)))\n                .with(info_item(\"Hotkey: Ctrl-Alt-A\"))\n                .separator()\n                .item(\"Sync Vault\", Events::SyncNow)\n                .separator()\n                .item(\"Exit\", Events::Exit),\n        )\n        .build()\n        .unwrap();\n\n    std::thread::spawn(move || {\n        r.iter().for_each(|m| match m {\n            Events::Exit => {\n                info!(\"Shutting down\");\n                exit(0);\n            }\n            Events::SyncNow => {\n                info!(\"Sync requested\");\n                crate::bw_cli::sync()\n            }\n            e => {\n                println!(\"{:?}\", e);\n            }\n        })\n    });\n\n    loop {\n        unsafe {\n            let mut msg = MaybeUninit::uninit();\n            let bret = winuser::GetMessageW(msg.as_mut_ptr(), 0 as _, 0, 0);\n            if bret > 0 {\n                winuser::TranslateMessage(msg.as_ptr());\n                winuser::DispatchMessageW(msg.as_ptr());\n            } else {\n                warn!(\"Failed to receive message\");\n            }\n        }\n    }\n}", "item_id": 0, "repo": "MCOfficer/bitwarden-autotype", "file": "src/tray.rs", "last_update_at": "2022-02-27T18:59:30+00:00", "question_id": "1aefff91b0ee55dee2c7d76bb55022029d6a197f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn main(username: String) {\n    let icon_bytes = include_bytes!(\"../assets/icon.ico\");\n    let icon = Icon::from_buffer(icon_bytes, None, None).unwrap();\n    let (s, r) = std::sync::mpsc::channel::<Events>();\n    let _tray_icon = TrayIconBuilder::new()\n        .icon(icon)\n        .sender(s)\n        .tooltip(\"Bitwarden Autotype\")\n        .menu(\n            MenuBuilder::new()\n                .with(info_item(\"Bitwarden Autotype is running\"))\n                .separator()\n                .with(info_item(&format!(\"Logged in as {}\", username)))\n                .with(info_item(\"Hotkey: Ctrl-Alt-A\"))\n                .separator()\n                .item(\"Sync Vault\", Events::SyncNow)\n                .separator()\n                .item(\"Exit\", Events::Exit),\n        )\n        .build()\n        .unwrap();\n    std::thread::spawn(move || {\n        r.iter().for_each(|m| match m {\n            Events::Exit => {\n                info!(\"Shutting down\");\n                exit(0);\n            }\n            Events::SyncNow => {\n                info!(\"Sync requested\");\n                crate::bw_cli::sync()\n            }\n            e => {\n                println!(\"{:?}\", e);\n            }\n        })\n    });\n    loop {\n        unsafe {\n            let mut msg = MaybeUninit::uninit();\n            let bret = winuser::GetMessageW(msg.as_mut_ptr(), 0 as _, 0, 0);\n            if bret > 0 {\n                winuser::TranslateMessage(msg.as_ptr());\n                winuser::DispatchMessageW(msg.as_ptr());\n            } else {\n                warn!(\"Failed to receive message\");\n            }\n        }\n    }\n"]], "pred": {"ppl": 2.281398296356201, "ppl_lower": 2.617647171020508, "ppl/lowercase_ppl": -1.1666940530522614, "ppl/zlib": 0.0013009283010374166, "Min_5.0% Prob": 7.296276154725448, "Min_10.0% Prob": 5.5146148930425225, "Min_20.0% Prob": 3.679180881899336, "Min_30.0% Prob": 2.654338324415511, "Min_40.0% Prob": 2.04304488659229, "Min_50.0% Prob": 1.6468055670837993, "Min_60.0% Prob": 1.3759403221538642}}
{"hexsha": "adc5d0a11384fb7c9040d8515a8a0a66e2136d47", "ext": "rs", "lang": "Rust", "content": "fn bench_allocator(c: &mut Criterion<ProcessTime>) {\n    let page = &[1u8; PAGE_SIZE];\n    let mut group = c.benchmark_group(\"Allocate\");\n    for n in [1usize, 10, 100, 1_000].iter().cloned() {\n        let pages: Vec<(PageIndex, &PageBytes)> = (0..n)\n            .into_iter()\n            .map(|i| (PageIndex::new(i as u64), page))\n            .collect();\n        let mut thread_pool = Cell::new(scoped_threadpool::Pool::new(NUM_THREADS));\n        group.bench_function(BenchmarkId::new(\"HeapBasedPageAllocator\", n), |b| {\n            b.iter(|| {\n                thread_pool.get_mut().scoped(|scope| {\n                    for _ in 0..NUM_THREADS {\n                        scope.execute(|| {\n                            let allocator = Arc::new(HeapBasedPageAllocator::default());\n                            for _ in 0..NUM_ALLOCATIONS {\n                                let pages =\n                                    HeapBasedPageAllocator::allocate(&allocator, &pages[..]);\n                                black_box(pages);\n                            }\n                        });\n                    }\n                });\n            })\n        });\n        // We don't use mmap-based allocator directly because it is only available on\n        // Linux for now. To avoid platform specific code here, we compare the\n        // heap-based allocator with the default allocator, which can be either\n        // the mmap-based allocator or the heap-based allocator.\n        group.bench_function(BenchmarkId::new(\"DefaultPageAllocatorImpl\", n), |b| {\n            b.iter(|| {\n                thread_pool.get_mut().scoped(|scope| {\n                    for _ in 0..NUM_THREADS {\n                        scope.execute(|| {\n                            let allocator = Arc::new(DefaultPageAllocatorImpl::default());\n                            // Allocate multiple times to simulate multiple rounds per checkpoint.\n                            for _ in 0..NUM_ALLOCATIONS {\n                                let pages =\n                                    DefaultPageAllocatorImpl::allocate(&allocator, &pages[..]);\n                                black_box(pages);\n                            }\n                        });\n                    }\n                });\n            })\n        });\n    }\n    group.finish();\n}", "item_id": 0, "repo": "3cL1p5e7/ic", "file": "rs/replicated_state/benches/bench_allocator.rs", "last_update_at": "2022-03-31T11:40:24+00:00", "question_id": "adc5d0a11384fb7c9040d8515a8a0a66e2136d47_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bench_allocator(c: &mut Criterion<ProcessTime>) {\n    let page = &[1u8; PAGE_SIZE];\n    let mut group = c.benchmark_group(\"Allocate\");\n    for n in [1usize, 10, 100, 1_000].iter().cloned() {\n        let pages: Vec<(PageIndex, &PageBytes)> = (0..n)\n            .into_iter()\n            .map(|i| (PageIndex::new(i as u64), page))\n            .collect();\n        let mut thread_pool = Cell::new(scoped_threadpool::Pool::new(NUM_THREADS));\n        group.bench_function(BenchmarkId::new(\"HeapBasedPageAllocator\", n), |b| {\n            b.iter(|| {\n                thread_pool.get_mut().scoped(|scope| {\n                    for _ in 0..NUM_THREADS {\n                        scope.execute(|| {\n                            let allocator = Arc::new(HeapBasedPageAllocator::default());\n                            for _ in 0..NUM_ALLOCATIONS {\n                                let pages =\n                                    HeapBasedPageAllocator::allocate(&allocator, &pages[..]);\n                                black_box(pages);\n                            }\n                        });\n                    }\n                });\n            })\n        });\n        // We don't use mmap-based allocator directly because it is only available on\n        // Linux for now. To avoid platform specific code here, we compare the\n        // heap-based allocator with the default allocator, which can be either\n        // the mmap-based allocator or the heap-based allocator.\n        group.bench_function(BenchmarkId::new(\"DefaultPageAllocatorImpl\", n), |b| {\n            b.iter(|| {\n                thread_pool.get_mut().scoped(|scope| {\n                    for _ in 0..NUM_THREADS {\n                        scope.execute(|| {\n                            let allocator = Arc::new(DefaultPageAllocatorImpl::default());\n                            // Allocate multiple times to simulate multiple rounds per checkpoint.\n                            for _ in 0..NUM_ALLOCATIONS {\n                                let pages =\n                                    DefaultPageAllocatorImpl::allocate(&allocator, &pages[..]);\n                                black_box(pages);\n                            }\n                        });\n                    }\n                });\n            })\n        });\n    }\n    group.finish();\n"]], "pred": {"ppl": 1.969704031944275, "ppl_lower": 2.3153209686279297, "ppl/lowercase_ppl": -1.2384850502634392, "ppl/zlib": 0.0009838654482893484, "Min_5.0% Prob": 6.52100682258606, "Min_10.0% Prob": 4.823589661082283, "Min_20.0% Prob": 3.1191514749837115, "Min_30.0% Prob": 2.215896457028778, "Min_40.0% Prob": 1.686952326961649, "Min_50.0% Prob": 1.353663487471761, "Min_60.0% Prob": 1.131264992729637}}
{"hexsha": "8c7adf3814a9f170972790ce9c0b24cf68116e4c", "ext": "rs", "lang": "Rust", "content": "fn correct_coordinates_origin() {\n        let cell = HexagonCell2d {\n            coords: IVec3::new(0, 0, 0),\n        };\n        let neighbors = cell.neighbor_coordinates();\n        assert_eq!(\n            neighbors,\n            vec![\n                IVec3::new(0, 1, -1),\n                IVec3::new(1, 0, -1),\n                IVec3::new(1, -1, 0),\n                IVec3::new(0, -1, 1),\n                IVec3::new(-1, 0, 1),\n                IVec3::new(-1, 1, 0),\n            ]\n        );\n    }", "item_id": 2, "repo": "ManevilleF/bevy_life", "file": "src/components/cell/hexagon_2d_cell.rs", "last_update_at": "2022-03-28T12:07:51+00:00", "question_id": "8c7adf3814a9f170972790ce9c0b24cf68116e4c_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn correct_coordinates_origin() {\n        let cell = HexagonCell2d {\n            coords: IVec3::new(0, 0, 0),\n        };\n        let neighbors = cell.neighbor_coordinates();\n        assert_eq!(\n            neighbors,\n            vec![\n                IVec3::new(0, 1, -1),\n                IVec3::new(1, 0, -1),\n                IVec3::new(1, -1, 0),\n                IVec3::new(0, -1, 1),\n                IVec3::new(-1, 0, 1),\n                IVec3::new(-1, 1, 0),\n            ]\n        );\n"]], "pred": {"ppl": 1.8931236267089844, "ppl_lower": 2.030677080154419, "ppl/lowercase_ppl": -1.109899718564357, "ppl/zlib": 0.003394830730795315, "Min_5.0% Prob": 7.376363277435303, "Min_10.0% Prob": 5.0399595288669365, "Min_20.0% Prob": 2.9732026747294835, "Min_30.0% Prob": 2.0798413716959505, "Min_40.0% Prob": 1.587971378485082, "Min_50.0% Prob": 1.2745378274847283, "Min_60.0% Prob": 1.0713330394553267}}
{"hexsha": "147ae9c3d24b2452deeee3ae7cfb094b5179fbd3", "ext": "rs", "lang": "Rust", "content": "fn test_bit_field() {\n        let mut gene = Gene::new(false, 16, false, 25, 1);\n        assert_eq!(gene.get_source_type(), false);\n        assert_eq!(gene.get_source_num(), 16);\n        assert_eq!(gene.get_sink_type(), false);\n        assert_eq!(gene.get_sink_num(), 25);\n\n        gene.set_sink_num(99);\n        gene.set_source_num(35);\n        gene.set_sink_type(false);\n        gene.set_source_type(true);\n        assert_eq!(gene.get_source_type(), true);\n        assert_eq!(gene.get_source_num(), 35);\n        assert_eq!(gene.get_sink_type(), false);\n        assert_eq!(gene.get_sink_num(), 99);\n    }", "item_id": 0, "repo": "Destrings2/biosim-rust", "file": "src/population/genome/gene.rs", "last_update_at": "2022-01-16T09:19:00+00:00", "question_id": "147ae9c3d24b2452deeee3ae7cfb094b5179fbd3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_bit_field() {\n        let mut gene = Gene::new(false, 16, false, 25, 1);\n        assert_eq!(gene.get_source_type(), false);\n        assert_eq!(gene.get_source_num(), 16);\n        assert_eq!(gene.get_sink_type(), false);\n        assert_eq!(gene.get_sink_num(), 25);\n        gene.set_sink_num(99);\n        gene.set_source_num(35);\n        gene.set_sink_type(false);\n        gene.set_source_type(true);\n        assert_eq!(gene.get_source_type(), true);\n        assert_eq!(gene.get_source_num(), 35);\n        assert_eq!(gene.get_sink_type(), false);\n        assert_eq!(gene.get_sink_num(), 99);\n"]], "pred": {"ppl": 1.768754482269287, "ppl_lower": 1.7988473176956177, "ppl/lowercase_ppl": -1.0295830010487244, "ppl/zlib": 0.0031506940140960207, "Min_5.0% Prob": 5.984667734666304, "Min_10.0% Prob": 4.38529049831888, "Min_20.0% Prob": 2.7000864452504096, "Min_30.0% Prob": 1.8870290247067598, "Min_40.0% Prob": 1.4349261720843138, "Min_50.0% Prob": 1.1446152915152075, "Min_60.0% Prob": 0.9515745917697516}}
{"hexsha": "2d9442a0eeb0611cd72b50be9fa941550e358003", "ext": "rs", "lang": "Rust", "content": "fn test_next_in_subdir() {\n        let d = dir();\n        let p = LogPath::new(&d, 123).next().unwrap();\n        assert_eq!(p.seq_num(), 124);\n        assert_eq!(p.path(), dir().join(\"000000124.devlog\"));\n    }", "item_id": 4, "repo": "wedaly/devlog", "file": "src/path.rs", "last_update_at": "2022-02-02T02:59:13+00:00", "question_id": "2d9442a0eeb0611cd72b50be9fa941550e358003_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_next_in_subdir() {\n        let d = dir();\n        let p = LogPath::new(&d, 123).next().unwrap();\n        assert_eq!(p.seq_num(), 124);\n        assert_eq!(p.path(), dir().join(\"000000124.devlog\"));\n"]], "pred": {"ppl": 4.2878098487854, "ppl_lower": 5.136557579040527, "ppl/lowercase_ppl": -1.124062380420383, "ppl/zlib": 0.00997106902615851, "Min_5.0% Prob": 9.569140791893005, "Min_10.0% Prob": 7.649503231048584, "Min_20.0% Prob": 5.362216949462891, "Min_30.0% Prob": 4.230161671638489, "Min_40.0% Prob": 3.3782451135270737, "Min_50.0% Prob": 2.7862920421500537, "Min_60.0% Prob": 2.3971534739522373}}
{"hexsha": "64943b3932802d1853e022c982a43a407ff22fd4", "ext": "rs", "lang": "Rust", "content": "pub fn verify_authorization(pub_key: String, sign: String, message: String) -> bool {\n    let public_key = hex::decode(pub_key);\n    if public_key.is_err() {\n        error!(\"err -> Err: public_key_decode\");\n        return false;\n    }\n    let hex_signature = hex::decode(sign);\n    if hex_signature.is_err() {\n        error!(\"err -> Err: hex_signature\");\n        return false;\n    }\n    let public_key = PublicKey::from_bytes(&public_key.unwrap().clone());\n    if public_key.is_err() {\n        error!(\"err -> Err: public_key\");\n        return false;\n    }\n    let signature = ed25519_dalek::Signature::from_bytes(&hex_signature.unwrap());\n    if signature.is_err() {\n        // eprintln!(\"err -> Err: signature\");\n        return false;\n    }\n    let ok = public_key\n        .unwrap()\n        .verify(message.as_bytes(), &signature.unwrap());\n    if ok.is_err() {\n        return false;\n    }\n    return true;\n}", "item_id": 0, "repo": "RabbitHouseCorp/http-interaction", "file": "src/sign_mod.rs", "last_update_at": "2022-03-13T16:19:24+00:00", "question_id": "64943b3932802d1853e022c982a43a407ff22fd4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn verify_authorization(pub_key: String, sign: String, message: String) -> bool {\n    let public_key = hex::decode(pub_key);\n    if public_key.is_err() {\n        error!(\"err -> Err: public_key_decode\");\n        return false;\n    }\n    let hex_signature = hex::decode(sign);\n    if hex_signature.is_err() {\n        error!(\"err -> Err: hex_signature\");\n        return false;\n    }\n    let public_key = PublicKey::from_bytes(&public_key.unwrap().clone());\n    if public_key.is_err() {\n        error!(\"err -> Err: public_key\");\n        return false;\n    }\n    let signature = ed25519_dalek::Signature::from_bytes(&hex_signature.unwrap());\n    if signature.is_err() {\n        // eprintln!(\"err -> Err: signature\");\n        return false;\n    }\n    let ok = public_key\n        .unwrap()\n        .verify(message.as_bytes(), &signature.unwrap());\n    if ok.is_err() {\n        return false;\n    }\n    return true;\n"]], "pred": {"ppl": 1.8951212167739868, "ppl_lower": 2.171924114227295, "ppl/lowercase_ppl": -1.2132556350180412, "ppl/zlib": 0.0020755935166362365, "Min_5.0% Prob": 7.225103855133057, "Min_10.0% Prob": 5.137625728334699, "Min_20.0% Prob": 3.058571698372824, "Min_30.0% Prob": 2.109898453968209, "Min_40.0% Prob": 1.5960609969237576, "Min_50.0% Prob": 1.2798433398388118, "Min_60.0% Prob": 1.0669755352488746}}
{"hexsha": "ec8d4129821e19102a63373cd475b7cb03b04021", "ext": "rs", "lang": "Rust", "content": "fn funding_created_test() {\n        let msg_hex = \"002202000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000200050000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\";\n        let msg_bytes = hex::decode(msg_hex).unwrap();\n\n        let msg_correct = FundingCreated {\n            temporary_channel_id: ChannelId::from_hex(\"0200000000000000000000000000000000000000000000000000000000000000\").unwrap(),\n            funding_txid: FundingTxid::from_hex(\"0000000000000000000000000000000000000000000000000000000005000000\").unwrap(),\n            output_index: OutputIndex::from_u16(2),\n            signature: RawSignature::from_hex(\"3024021f05000000000000000000000000000000000000000000000000000000000000020100\").unwrap(),\n        };\n        let wrapped_msg_correct = Message::FundingCreated(msg_correct);\n\n        let mut cursor = Cursor::new(msg_bytes.clone());\n        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();\n        assert_eq!(&msg, &wrapped_msg_correct);\n\n\n        // Now check serialization\n        let mut new_msg_bytes = vec![];\n        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();\n        assert_eq!(new_msg_bytes, msg_bytes);\n\n    }", "item_id": 7, "repo": "LightningPeach/lpd", "file": "wire/tests/comp_check.rs", "last_update_at": "2022-01-02T11:14:21+00:00", "question_id": "ec8d4129821e19102a63373cd475b7cb03b04021_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn funding_created_test() {\n        let msg_hex = \"002202000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000200050000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\";\n        let msg_bytes = hex::decode(msg_hex).unwrap();\n        let msg_correct = FundingCreated {\n            temporary_channel_id: ChannelId::from_hex(\"0200000000000000000000000000000000000000000000000000000000000000\").unwrap(),\n            funding_txid: FundingTxid::from_hex(\"0000000000000000000000000000000000000000000000000000000005000000\").unwrap(),\n            output_index: OutputIndex::from_u16(2),\n            signature: RawSignature::from_hex(\"3024021f05000000000000000000000000000000000000000000000000000000000000020100\").unwrap(),\n        };\n        let wrapped_msg_correct = Message::FundingCreated(msg_correct);\n        let mut cursor = Cursor::new(msg_bytes.clone());\n        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();\n        assert_eq!(&msg, &wrapped_msg_correct);\n        // Now check serialization\n        let mut new_msg_bytes = vec![];\n        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();\n        assert_eq!(new_msg_bytes, msg_bytes);\n"]], "pred": {"ppl": 1.6161015033721924, "ppl_lower": 1.7271146774291992, "ppl/lowercase_ppl": -1.1384023105570988, "ppl/zlib": 0.0011940715662165117, "Min_5.0% Prob": 6.374759700563219, "Min_10.0% Prob": 4.1192895663927676, "Min_20.0% Prob": 2.287262202829731, "Min_30.0% Prob": 1.5670413429764185, "Min_40.0% Prob": 1.184885832766185, "Min_50.0% Prob": 0.9527092299110297, "Min_60.0% Prob": 0.7982907764056102}}
{"hexsha": "222008ce52047888e82d647ed7477ef3b14a48e7", "ext": "rs", "lang": "Rust", "content": "fn normalize(val: f64, max: f64) -> f64 {\n  if val < ALL_MIN {\n    return ALL_MIN;\n  }\n  if val > max {\n    return max;\n  }\n  val\n}", "item_id": 0, "repo": "emgyrz/colorsys.rs", "file": "src/normalize.rs", "last_update_at": "2022-03-12T04:51:46+00:00", "question_id": "222008ce52047888e82d647ed7477ef3b14a48e7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn normalize(val: f64, max: f64) -> f64 {\n  if val < ALL_MIN {\n    return ALL_MIN;\n  }\n  if val > max {\n    return max;\n  }\n  val\n"]], "pred": {"ppl": 2.8139150142669678, "ppl_lower": 2.9510135650634766, "ppl/lowercase_ppl": -1.0459820261705948, "ppl/zlib": 0.011245399534715617, "Min_5.0% Prob": 10.038293520609537, "Min_10.0% Prob": 6.661085724830627, "Min_20.0% Prob": 4.242509285608928, "Min_30.0% Prob": 3.1998704175154367, "Min_40.0% Prob": 2.500500882665316, "Min_50.0% Prob": 2.041613318522771, "Min_60.0% Prob": 1.7155778126584158}}
{"hexsha": "67280002b1c8875187ee19e0a8fd68d549cdb015", "ext": "rs", "lang": "Rust", "content": "fn encrypt_cli(encrypt_args: &ArgMatches, verbose: bool) {\n    let mut file_supplied = false;\n    let mut string_to_encrypt = match encrypt_args.value_of(\"string\") {\n        Some(words) => words,\n        None => \"Hello World!\",\n    };\n    let public_key_path = match encrypt_args.value_of(\"public-key-path\") {\n        Some(words) => words,\n        None => \"keys/public_key.pkcs7.pem\",\n    };\n\n    let file_to_encrypt: String = match encrypt_args.value_of(\"file\") {\n        Some(file) => {\n            file_supplied = true;\n            match read_to_string(&file) {\n                Ok(file_contents) => file_contents.to_owned(),\n                Err(_) => String::from(\"Hello world!\"),\n            }\n        }\n        None => String::from(\"Hello World!\"),\n    };\n    if file_supplied {\n        string_to_encrypt = file_to_encrypt.as_ref();\n    }\n    let ciphertext_pkcs7 = encrypt_str(public_key_path, &string_to_encrypt.as_bytes(), &verbose);\n    if verbose.clone() {\n        print! {\"New ciphertext: \"}\n    }\n    println!(\n        \"{:#}\",\n        from_utf8(&ciphertext_pkcs7.as_ref().to_pem().unwrap()).unwrap()\n    );\n    let mut output_file: String = \"\".into();\n    // todo: verify this in-place doesn't need a different method\n    if encrypt_args.is_present(\"in-place\") {\n        // this has to check the file that was fed in\n        if verbose.clone() {\n            println!(\"Going to try and use input file as the output file (encrypt in place)\")\n        }\n        output_file = encrypt_args.value_of(\"file\").unwrap().into();\n    } else {\n        match encrypt_args.value_of(\"output-file\") {\n            Some(ofile) => {\n                if verbose.clone() {\n                    println!(\"Using output-file argas output file\")\n                }\n                output_file = ofile.into()\n            }\n            None => {}\n        };\n    }\n    if output_file != \"\" {\n        if verbose.clone() {\n            println!(\"Going to write ciphertext to {}\", &output_file)\n        }\n        match write_file(&output_file, &ciphertext_pkcs7.as_ref().to_pem().unwrap()) {\n            Ok(_) => {}\n            Err(_) => println!(\"There was an error writing the ciphertext to file!\"),\n        }\n    } else {\n        if verbose.clone() {\n            println!(\"output_file variable was never assigned to anything\");\n        }\n    }\n}", "item_id": 21, "repo": "evan-chaney/eyaml-rs", "file": "src/main.rs", "last_update_at": "2022-01-27T11:04:13+00:00", "question_id": "67280002b1c8875187ee19e0a8fd68d549cdb015_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn encrypt_cli(encrypt_args: &ArgMatches, verbose: bool) {\n    let mut file_supplied = false;\n    let mut string_to_encrypt = match encrypt_args.value_of(\"string\") {\n        Some(words) => words,\n        None => \"Hello World!\",\n    };\n    let public_key_path = match encrypt_args.value_of(\"public-key-path\") {\n        Some(words) => words,\n        None => \"keys/public_key.pkcs7.pem\",\n    };\n    let file_to_encrypt: String = match encrypt_args.value_of(\"file\") {\n        Some(file) => {\n            file_supplied = true;\n            match read_to_string(&file) {\n                Ok(file_contents) => file_contents.to_owned(),\n                Err(_) => String::from(\"Hello world!\"),\n            }\n        }\n        None => String::from(\"Hello World!\"),\n    };\n    if file_supplied {\n        string_to_encrypt = file_to_encrypt.as_ref();\n    }\n    let ciphertext_pkcs7 = encrypt_str(public_key_path, &string_to_encrypt.as_bytes(), &verbose);\n    if verbose.clone() {\n        print! {\"New ciphertext: \"}\n    }\n    println!(\n        \"{:#}\",\n        from_utf8(&ciphertext_pkcs7.as_ref().to_pem().unwrap()).unwrap()\n    );\n    let mut output_file: String = \"\".into();\n    // todo: verify this in-place doesn't need a different method\n    if encrypt_args.is_present(\"in-place\") {\n        // this has to check the file that was fed in\n        if verbose.clone() {\n            println!(\"Going to try and use input file as the output file (encrypt in place)\")\n        }\n        output_file = encrypt_args.value_of(\"file\").unwrap().into();\n    } else {\n        match encrypt_args.value_of(\"output-file\") {\n            Some(ofile) => {\n                if verbose.clone() {\n                    println!(\"Using output-file argas output file\")\n                }\n                output_file = ofile.into()\n            }\n            None => {}\n        };\n    }\n    if output_file != \"\" {\n        if verbose.clone() {\n            println!(\"Going to write ciphertext to {}\", &output_file)\n        }\n        match write_file(&output_file, &ciphertext_pkcs7.as_ref().to_pem().unwrap()) {\n            Ok(_) => {}\n            Err(_) => println!(\"There was an error writing the ciphertext to file!\"),\n        }\n    } else {\n        if verbose.clone() {\n            println!(\"output_file variable was never assigned to anything\");\n        }\n    }\n"]], "pred": {"ppl": 2.340181827545166, "ppl_lower": 2.4932124614715576, "ppl/lowercase_ppl": -1.0745016004245636, "ppl/zlib": 0.0010984866026226554, "Min_5.0% Prob": 6.7082256008596985, "Min_10.0% Prob": 5.231827576955159, "Min_20.0% Prob": 3.580422238480273, "Min_30.0% Prob": 2.6800780376178794, "Min_40.0% Prob": 2.096036774917043, "Min_50.0% Prob": 1.6959018906171637, "Min_60.0% Prob": 1.416429263927292}}
{"hexsha": "a0c355822fec8705456df948932560c923e6f7df", "ext": "rs", "lang": "Rust", "content": "fn test_format_unification() {\n    use Format::*;\n\n    let mut x = Format::unknown();\n    assert!(x.unify(U8).is_ok());\n    x.reduce();\n    assert_eq!(x, U8);\n    assert_eq!(\n        x.unify(U16).unwrap_err(),\n        Error::Incompatible(\"U8\".into(), \"U16\".into())\n    );\n\n    let mut x = Tuple(vec![Format::unknown(), U32]);\n    x.unify(Tuple(vec![U16, Format::unknown()])).unwrap();\n    x.reduce();\n    assert_eq!(x, Tuple(vec![U16, U32]));\n\n    for x in vec![\n        Unit,\n        Bool,\n        I8,\n        I16,\n        I32,\n        I64,\n        I128,\n        U8,\n        U16,\n        U32,\n        U64,\n        U128,\n        F32,\n        F64,\n        Char,\n        Str,\n        Bytes,\n        TypeName(\"foo\".into()),\n        Option(Box::new(Unit)),\n        Seq(Box::new(Unit)),\n        Map {\n            key: Box::new(Unit),\n            value: Box::new(Unit),\n        },\n        Tuple(vec![Format::unknown()]),\n    ]\n    .iter_mut()\n    {\n        assert!(x.unify(TypeName(\"bar\".into())).is_err());\n        assert!(x.unify(Option(Box::new(U32))).is_err());\n        assert!(x.unify(Seq(Box::new(U32))).is_err());\n        assert!(x.unify(Tuple(vec![])).is_err());\n    }\n}", "item_id": 3, "repo": "texas16/serde-reflection", "file": "serde-reflection/tests/format.rs", "last_update_at": "2022-03-30T15:04:15+00:00", "question_id": "a0c355822fec8705456df948932560c923e6f7df_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_format_unification() {\n    use Format::*;\n    let mut x = Format::unknown();\n    assert!(x.unify(U8).is_ok());\n    x.reduce();\n    assert_eq!(x, U8);\n    assert_eq!(\n        x.unify(U16).unwrap_err(),\n        Error::Incompatible(\"U8\".into(), \"U16\".into())\n    );\n    let mut x = Tuple(vec![Format::unknown(), U32]);\n    x.unify(Tuple(vec![U16, Format::unknown()])).unwrap();\n    x.reduce();\n    assert_eq!(x, Tuple(vec![U16, U32]));\n    for x in vec![\n        Unit,\n        Bool,\n        I8,\n        I16,\n        I32,\n        I64,\n        I128,\n        U8,\n        U16,\n        U32,\n        U64,\n        U128,\n        F32,\n        F64,\n        Char,\n        Str,\n        Bytes,\n        TypeName(\"foo\".into()),\n        Option(Box::new(Unit)),\n        Seq(Box::new(Unit)),\n        Map {\n            key: Box::new(Unit),\n            value: Box::new(Unit),\n        },\n        Tuple(vec![Format::unknown()]),\n    ]\n    .iter_mut()\n    {\n        assert!(x.unify(TypeName(\"bar\".into())).is_err());\n        assert!(x.unify(Option(Box::new(U32))).is_err());\n        assert!(x.unify(Seq(Box::new(U32))).is_err());\n        assert!(x.unify(Tuple(vec![])).is_err());\n    }\n"]], "pred": {"ppl": 1.7260417938232422, "ppl_lower": 1.9183425903320312, "ppl/lowercase_ppl": -1.1935229216057652, "ppl/zlib": 0.0013378206044954626, "Min_5.0% Prob": 5.578803300857544, "Min_10.0% Prob": 3.940902354982164, "Min_20.0% Prob": 2.511369209157096, "Min_30.0% Prob": 1.7821498980124792, "Min_40.0% Prob": 1.359679734851751, "Min_50.0% Prob": 1.0922278152364824, "Min_60.0% Prob": 0.9112382746042891}}
{"hexsha": "cd801b2196455ebd88e17bde021a3420c7750ef0", "ext": "rs", "lang": "Rust", "content": "fn random_single_units_to_times() {\n    assert_eq!(time!(16:51:49) - (-13).minutes(), time!(17:4:49));\n    assert_eq!(time!(13:20:48) - (-4).minutes(), time!(13:24:48));\n    assert_eq!(time!(6:51:52) - 44.minutes(), time!(6:7:52));\n    assert_eq!(time!(20:19:13) - 41.minutes(), time!(19:38:13));\n    assert_eq!(time!(1:4:31) - 0.hours(), time!(1:4:31));\n    assert_eq!(time!(19:11:31) - 32.seconds(), time!(19:10:59));\n    assert_eq!(time!(7:31:3) + 2.hours(), time!(9:31:3));\n    assert_eq!(time!(7:5:30) - (-20).hours(), time!(3:5:30));\n    assert_eq!(time!(11:56:1) - (-18).minutes(), time!(12:14:1));\n    assert_eq!(time!(18:51:17) - (-51).seconds(), time!(18:52:8));\n    assert_eq!(time!(21:13:48) - 36.seconds(), time!(21:13:12));\n    assert_eq!(time!(19:42:49) - 99.minutes(), time!(18:3:49));\n    assert_eq!(time!(0:54:29) + (-70).seconds(), time!(0:53:19));\n    assert_eq!(time!(14:20:2) - (-49).minutes(), time!(15:9:2));\n    assert_eq!(time!(8:51:55) - 58.seconds(), time!(8:50:57));\n    assert_eq!(time!(9:21:3) + 87.seconds(), time!(9:22:30));\n    assert_eq!(time!(2:40:56) + (-2).seconds(), time!(2:40:54));\n    assert_eq!(time!(15:24:1) + 47.hours(), time!(14:24:1));\n    assert_eq!(time!(7:38:1) + (-21).hours(), time!(10:38:1));\n    assert_eq!(time!(11:26:23) - 65.minutes(), time!(10:21:23));\n}", "item_id": 8, "repo": "Rapptz/eos", "file": "tests/interval.rs", "last_update_at": "2022-03-30T09:54:02+00:00", "question_id": "cd801b2196455ebd88e17bde021a3420c7750ef0_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn random_single_units_to_times() {\n    assert_eq!(time!(16:51:49) - (-13).minutes(), time!(17:4:49));\n    assert_eq!(time!(13:20:48) - (-4).minutes(), time!(13:24:48));\n    assert_eq!(time!(6:51:52) - 44.minutes(), time!(6:7:52));\n    assert_eq!(time!(20:19:13) - 41.minutes(), time!(19:38:13));\n    assert_eq!(time!(1:4:31) - 0.hours(), time!(1:4:31));\n    assert_eq!(time!(19:11:31) - 32.seconds(), time!(19:10:59));\n    assert_eq!(time!(7:31:3) + 2.hours(), time!(9:31:3));\n    assert_eq!(time!(7:5:30) - (-20).hours(), time!(3:5:30));\n    assert_eq!(time!(11:56:1) - (-18).minutes(), time!(12:14:1));\n    assert_eq!(time!(18:51:17) - (-51).seconds(), time!(18:52:8));\n    assert_eq!(time!(21:13:48) - 36.seconds(), time!(21:13:12));\n    assert_eq!(time!(19:42:49) - 99.minutes(), time!(18:3:49));\n    assert_eq!(time!(0:54:29) + (-70).seconds(), time!(0:53:19));\n    assert_eq!(time!(14:20:2) - (-49).minutes(), time!(15:9:2));\n    assert_eq!(time!(8:51:55) - 58.seconds(), time!(8:50:57));\n    assert_eq!(time!(9:21:3) + 87.seconds(), time!(9:22:30));\n    assert_eq!(time!(2:40:56) + (-2).seconds(), time!(2:40:54));\n    assert_eq!(time!(15:24:1) + 47.hours(), time!(14:24:1));\n    assert_eq!(time!(7:38:1) + (-21).hours(), time!(10:38:1));\n    assert_eq!(time!(11:26:23) - 65.minutes(), time!(10:21:23));\n"]], "pred": {"ppl": 2.328421115875244, "ppl_lower": 2.328421115875244, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.002253841080557997, "Min_5.0% Prob": 4.802902018322664, "Min_10.0% Prob": 3.8833552037968353, "Min_20.0% Prob": 3.064845957025124, "Min_30.0% Prob": 2.571028699573961, "Min_40.0% Prob": 2.0877862475866817, "Min_50.0% Prob": 1.689520607259852, "Min_60.0% Prob": 1.408616580527945}}
{"hexsha": "cf918a5c6c2be86db742e35664b0332b37fbfcda", "ext": "rs", "lang": "Rust", "content": "fn sync_symlink< P >( path: P ) -> std::io::Result< () >\nwhere\n    P: AsRef< std::path::Path >,\n{\n    log::trace!( \"Begin `sync_symlink`.\" );\n\n    let path = path.as_ref();\n\n    let metadata = path.symlink_metadata()?;\n    if !metadata.file_type().is_symlink() {\n        let error_msg = format!(\n            \"Invalid file type: not a symlink: \\\n                path: {:?}, \\\n                type: {:?}\",\n            path,\n            metadata.file_type(),\n        );\n\n        log::error!( \"{}\", error_msg );\n\n        let error = std::io::Error::new(\n                std::io::ErrorKind::InvalidInput, error_msg );\n\n        return Err( error );\n    }\n\n    let mut abs_path = std::env::current_dir()?;\n    abs_path.push( path );\n    let parent_path = abs_path.parent().unwrap();\n\n    log::debug!( \"Syncing symlink parent: {:?}\", parent_path );\n\n    std::fs::File::open( parent_path )?.sync_all()?;\n\n    log::trace!( \"End `sync_symlink`.\" );\n\n    return Ok( () );\n}", "item_id": 10, "repo": "selendym/cpdd", "file": "src/lib.rs", "last_update_at": "2022-01-06T22:02:25+00:00", "question_id": "cf918a5c6c2be86db742e35664b0332b37fbfcda_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn sync_symlink< P >( path: P ) -> std::io::Result< () >\nwhere\n    P: AsRef< std::path::Path >,\n{\n    log::trace!( \"Begin `sync_symlink`.\" );\n    let path = path.as_ref();\n    let metadata = path.symlink_metadata()?;\n    if !metadata.file_type().is_symlink() {\n        let error_msg = format!(\n            \"Invalid file type: not a symlink: \\\n                path: {:?}, \\\n                type: {:?}\",\n            path,\n            metadata.file_type(),\n        );\n        log::error!( \"{}\", error_msg );\n        let error = std::io::Error::new(\n                std::io::ErrorKind::InvalidInput, error_msg );\n        return Err( error );\n    }\n    let mut abs_path = std::env::current_dir()?;\n    abs_path.push( path );\n    let parent_path = abs_path.parent().unwrap();\n    log::debug!( \"Syncing symlink parent: {:?}\", parent_path );\n    std::fs::File::open( parent_path )?.sync_all()?;\n    log::trace!( \"End `sync_symlink`.\" );\n    return Ok( () );\n"]], "pred": {"ppl": 1.9416530132293701, "ppl_lower": 2.5857911109924316, "ppl/lowercase_ppl": -1.4317629078612009, "ppl/zlib": 0.00157610375046492, "Min_5.0% Prob": 6.279950350522995, "Min_10.0% Prob": 4.577810026705265, "Min_20.0% Prob": 2.90112178509052, "Min_30.0% Prob": 2.114449970576228, "Min_40.0% Prob": 1.6437326338428717, "Min_50.0% Prob": 1.324418186112964, "Min_60.0% Prob": 1.1053716356210335}}
{"hexsha": "3863099a09f96fdd1c286caad2c5672a87791b1b", "ext": "rs", "lang": "Rust", "content": "fn insert_header_with_configuration_change(\n\t\tbackend: &Backend<Block>,\n\t\tnumber: u64,\n\t\tparent_hash: H256,\n\t\tchanges: Option<Vec<(Vec<u8>, Vec<u8>)>>,\n\t\tnew_configuration: Option<ChangesTrieConfiguration>,\n\t) -> H256 {\n\t\tlet mut digest = Digest::default();\n\t\tlet mut changes_trie_update = Default::default();\n\t\tif let Some(changes) = changes {\n\t\t\tlet (root, update) = prepare_changes(changes);\n\t\t\tdigest.push(DigestItem::ChangesTrieRoot(root));\n\t\t\tchanges_trie_update = update;\n\t\t}\n\t\tdigest.push(DigestItem::ChangesTrieSignal(ChangesTrieSignal::NewConfiguration(new_configuration)));\n\n\t\tlet header = Header {\n\t\t\tnumber,\n\t\t\tparent_hash,\n\t\t\tstate_root: BlakeTwo256::trie_root(Vec::new()),\n\t\t\tdigest,\n\t\t\textrinsics_root: Default::default(),\n\t\t};\n\t\tlet header_hash = header.hash();\n\n\t\tlet block_id = if number == 0 {\n\t\t\tBlockId::Hash(Default::default())\n\t\t} else {\n\t\t\tBlockId::Number(number - 1)\n\t\t};\n\t\tlet mut op = backend.begin_operation().unwrap();\n\t\tbackend.begin_state_operation(&mut op, block_id).unwrap();\n\t\top.set_block_data(header, None, None, None, NewBlockState::Best).unwrap();\n\t\top.update_changes_trie((changes_trie_update, ChangesTrieCacheAction::Clear)).unwrap();\n\t\tbackend.commit_operation(op).unwrap();\n\n\t\theader_hash\n\t}", "item_id": 0, "repo": "cruz101-hub/substrate", "file": "client/db/src/changes_tries_storage.rs", "last_update_at": "2022-03-30T16:49:33+00:00", "question_id": "3863099a09f96fdd1c286caad2c5672a87791b1b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn insert_header_with_configuration_change(\n\t\tbackend: &Backend<Block>,\n\t\tnumber: u64,\n\t\tparent_hash: H256,\n\t\tchanges: Option<Vec<(Vec<u8>, Vec<u8>)>>,\n\t\tnew_configuration: Option<ChangesTrieConfiguration>,\n\t) -> H256 {\n\t\tlet mut digest = Digest::default();\n\t\tlet mut changes_trie_update = Default::default();\n\t\tif let Some(changes) = changes {\n\t\t\tlet (root, update) = prepare_changes(changes);\n\t\t\tdigest.push(DigestItem::ChangesTrieRoot(root));\n\t\t\tchanges_trie_update = update;\n\t\t}\n\t\tdigest.push(DigestItem::ChangesTrieSignal(ChangesTrieSignal::NewConfiguration(new_configuration)));\n\t\tlet header = Header {\n\t\t\tnumber,\n\t\t\tparent_hash,\n\t\t\tstate_root: BlakeTwo256::trie_root(Vec::new()),\n\t\t\tdigest,\n\t\t\textrinsics_root: Default::default(),\n\t\t};\n\t\tlet header_hash = header.hash();\n\t\tlet block_id = if number == 0 {\n\t\t\tBlockId::Hash(Default::default())\n\t\t} else {\n\t\t\tBlockId::Number(number - 1)\n\t\t};\n\t\tlet mut op = backend.begin_operation().unwrap();\n\t\tbackend.begin_state_operation(&mut op, block_id).unwrap();\n\t\top.set_block_data(header, None, None, None, NewBlockState::Best).unwrap();\n\t\top.update_changes_trie((changes_trie_update, ChangesTrieCacheAction::Clear)).unwrap();\n\t\tbackend.commit_operation(op).unwrap();\n\t\theader_hash\n"]], "pred": {"ppl": 2.0144505500793457, "ppl_lower": 2.8994500637054443, "ppl/lowercase_ppl": -1.5199920592270697, "ppl/zlib": 0.00133399329210165, "Min_5.0% Prob": 6.032663345336914, "Min_10.0% Prob": 4.739386387493299, "Min_20.0% Prob": 3.095967765777342, "Min_30.0% Prob": 2.2585105582964506, "Min_40.0% Prob": 1.7363065995516316, "Min_50.0% Prob": 1.3970635146973855, "Min_60.0% Prob": 1.1690827977165954}}
{"hexsha": "9858de99ea2d9db0765d2e755fc1a81a5935c68e", "ext": "rs", "lang": "Rust", "content": "fn get_containers(pod: &KubernetesPod) -> Vec<Container> {\n  let mut ret = Vec::new();\n\n  let pod_name = pod.metadata.name.clone();\n  let siblings = pod.spec.containers.len();\n  for container in &pod.spec.containers {\n    ret.push(Container::new(\n      pod_name.clone(), container.name.clone(),\n      siblings\n    ));\n  }\n\n  ret\n}", "item_id": 0, "repo": "HewlettPackard/woodchipper", "file": "src/reader/kubernetes.rs", "last_update_at": "2022-02-20T08:11:13+00:00", "question_id": "9858de99ea2d9db0765d2e755fc1a81a5935c68e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_containers(pod: &KubernetesPod) -> Vec<Container> {\n  let mut ret = Vec::new();\n  let pod_name = pod.metadata.name.clone();\n  let siblings = pod.spec.containers.len();\n  for container in &pod.spec.containers {\n    ret.push(Container::new(\n      pod_name.clone(), container.name.clone(),\n      siblings\n    ));\n  }\n  ret\n"]], "pred": {"ppl": 2.603623390197754, "ppl_lower": 3.26570987701416, "ppl/lowercase_ppl": -1.2367772027025872, "ppl/zlib": 0.005117134152227549, "Min_5.0% Prob": 8.685303211212158, "Min_10.0% Prob": 6.156564777547663, "Min_20.0% Prob": 3.9496819972991943, "Min_30.0% Prob": 2.95174104486193, "Min_40.0% Prob": 2.3482565640107445, "Min_50.0% Prob": 1.9054389629384567, "Min_60.0% Prob": 1.593874800843852}}
{"hexsha": "f14aa880f7ac22f7552d8600fbe09ad19f07f6f1", "ext": "rs", "lang": "Rust", "content": "fn quartic_bspline() {\n        let expect: Vec<(f32, f32)> = vec![(0.0, 0.0), (0.4, 0.0010666668), (1.0, 0.041666668),\n                          (1.5, 0.19791667), (2.0, 0.4583333), (2.5, 0.5989583),\n                          (3.0, 0.4583333), (3.2, 0.35206667), (4.1, 0.02733751),\n                          (4.5, 0.002604167), (5.0, 0.0)];\n        let points: Vec<f32> = vec![0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0];\n        let knots: Vec<f32> = vec![0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 5.0, 5.0, 5.0, 5.0];\n        let degree = 4;\n        let spline = BSpline::new(degree, points, knots);\n        assert!(check_bspline(&spline, &expect));\n    }", "item_id": 4, "repo": "Twinklebear/bspline", "file": "src/lib.rs", "last_update_at": "2022-03-05T05:25:21+00:00", "question_id": "f14aa880f7ac22f7552d8600fbe09ad19f07f6f1_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn quartic_bspline() {\n        let expect: Vec<(f32, f32)> = vec![(0.0, 0.0), (0.4, 0.0010666668), (1.0, 0.041666668),\n                          (1.5, 0.19791667), (2.0, 0.4583333), (2.5, 0.5989583),\n                          (3.0, 0.4583333), (3.2, 0.35206667), (4.1, 0.02733751),\n                          (4.5, 0.002604167), (5.0, 0.0)];\n        let points: Vec<f32> = vec![0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0];\n        let knots: Vec<f32> = vec![0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 5.0, 5.0, 5.0, 5.0];\n        let degree = 4;\n        let spline = BSpline::new(degree, points, knots);\n        assert!(check_bspline(&spline, &expect));\n"]], "pred": {"ppl": 2.033658027648926, "ppl_lower": 2.134824275970459, "ppl/lowercase_ppl": -1.068393503330154, "ppl/zlib": 0.0025625853988871005, "Min_5.0% Prob": 5.790654194355011, "Min_10.0% Prob": 4.239311093091965, "Min_20.0% Prob": 3.0021893799304964, "Min_30.0% Prob": 2.2289590651790303, "Min_40.0% Prob": 1.7366277920082211, "Min_50.0% Prob": 1.4095090546831488, "Min_60.0% Prob": 1.1815888924213747}}
{"hexsha": "c42b742997a8fbeb7cdfa9bc997e9747509a91df", "ext": "rs", "lang": "Rust", "content": "async fn main() -> Result<(), Error> {\n    let address = \"localhost:27015\";\n    let mut conn = Connection::builder()\n        .connect(address, \"test\").await?;\n\n    demo(&mut conn, \"status\").await?;\n    demo(&mut conn, \"users\").await?;\n    demo(&mut conn, \"echo \\\"Rust lang rocks! ;P\\\"\").await?;\n    println!(\"commands finished\");\n\n    Ok(())\n}", "item_id": 0, "repo": "anatawa12/rust-rcon", "file": "examples/source-engine.rs", "last_update_at": "2022-01-03T03:26:09+00:00", "question_id": "c42b742997a8fbeb7cdfa9bc997e9747509a91df_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn main() -> Result<(), Error> {\n    let address = \"localhost:27015\";\n    let mut conn = Connection::builder()\n        .connect(address, \"test\").await?;\n    demo(&mut conn, \"status\").await?;\n    demo(&mut conn, \"users\").await?;\n    demo(&mut conn, \"echo \\\"Rust lang rocks! ;P\\\"\").await?;\n    println!(\"commands finished\");\n    Ok(())\n"]], "pred": {"ppl": 4.522931098937988, "ppl_lower": 5.222846984863281, "ppl/lowercase_ppl": -1.0953393750383393, "ppl/zlib": 0.007085259422031017, "Min_5.0% Prob": 9.526235580444336, "Min_10.0% Prob": 7.795507864518599, "Min_20.0% Prob": 5.95296865159815, "Min_30.0% Prob": 4.686552076628714, "Min_40.0% Prob": 3.701329676942392, "Min_50.0% Prob": 2.9830308319734677, "Min_60.0% Prob": 2.5161701350736974}}
{"hexsha": "3971c9bbf521ff07b6bea659a9f3b5c159a09aae", "ext": "rs", "lang": "Rust", "content": "fn sort_fskey() {\n    let a = FSKey::compose(0, 0, 0);\n    let b = FSKey::compose(0, 1, 0);\n    let c = FSKey::compose(1, 0, 0);\n    let d = FSKey::compose(0, 1, 1);\n    let e = FSKey::compose(0, 2, 0);\n    let f = FSKey::compose(0, 2, 1);\n    let g = FSKey::compose(0, 2, 2);\n    assert!(a < b && b < c);\n    assert!(b < d && d < e);\n    assert!(e < f && f < g);\n}", "item_id": 7, "repo": "bfffs/bfffs", "file": "bfffs-core/src/fs_tree.rs", "last_update_at": "2022-02-08T03:27:46+00:00", "question_id": "3971c9bbf521ff07b6bea659a9f3b5c159a09aae_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn sort_fskey() {\n    let a = FSKey::compose(0, 0, 0);\n    let b = FSKey::compose(0, 1, 0);\n    let c = FSKey::compose(1, 0, 0);\n    let d = FSKey::compose(0, 1, 1);\n    let e = FSKey::compose(0, 2, 0);\n    let f = FSKey::compose(0, 2, 1);\n    let g = FSKey::compose(0, 2, 2);\n    assert!(a < b && b < c);\n    assert!(b < d && d < e);\n    assert!(e < f && f < g);\n"]], "pred": {"ppl": 1.7226662635803223, "ppl_lower": 1.7565927505493164, "ppl/lowercase_ppl": -1.0358590019141976, "ppl/zlib": 0.0038300932663550185, "Min_5.0% Prob": 6.755412936210632, "Min_10.0% Prob": 4.387901600669412, "Min_20.0% Prob": 2.54290468948228, "Min_30.0% Prob": 1.7682466521015707, "Min_40.0% Prob": 1.3515226966373517, "Min_50.0% Prob": 1.0851604545154097, "Min_60.0% Prob": 0.9123029018233899}}
{"hexsha": "3c06427b84abab716aeb10bdc7f00708bba08807", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    // Bug from https://github.com/bluss/indexing/issues/12\n    let array = [0, 1, 2, 3, 4, 5];\n    let ix = scope(&array[..], |arr| {\n        let left = arr.vet_range(0..2).unwrap();\n        let left = left.nonempty().unwrap();\n        let (_, right) = arr.range().frontiers();\n\n        let joined = right.join_cover(left);\n        let ix = joined.first();\n        arr[ix]; //~ ERROR: cannot be indexed by\n        ix.integer()\n    });\n    dbg!(array[ix]);\n}", "item_id": 0, "repo": "bluss/indexing", "file": "tests/compile-fail/join_cover.rs", "last_update_at": "2022-03-18T12:56:42+00:00", "question_id": "3c06427b84abab716aeb10bdc7f00708bba08807_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    // Bug from https://github.com/bluss/indexing/issues/12\n    let array = [0, 1, 2, 3, 4, 5];\n    let ix = scope(&array[..], |arr| {\n        let left = arr.vet_range(0..2).unwrap();\n        let left = left.nonempty().unwrap();\n        let (_, right) = arr.range().frontiers();\n        let joined = right.join_cover(left);\n        let ix = joined.first();\n        arr[ix]; //~ ERROR: cannot be indexed by\n        ix.integer()\n    });\n    dbg!(array[ix]);\n"]], "pred": {"ppl": 5.853835582733154, "ppl_lower": 6.046150207519531, "ppl/lowercase_ppl": -1.0182925084146237, "ppl/zlib": 0.00622217289283057, "Min_5.0% Prob": 10.691352605819702, "Min_10.0% Prob": 8.829199999570847, "Min_20.0% Prob": 6.408316366600268, "Min_30.0% Prob": 5.057460463047027, "Min_40.0% Prob": 4.135229795268088, "Min_50.0% Prob": 3.4279057275818055, "Min_60.0% Prob": 2.9079223239421843}}
{"hexsha": "94eeb0179269e48b811d7d886afceb3c9ad4c445", "ext": "rs", "lang": "Rust", "content": "fn do_inserts(s: Arc<Storage>, tid: u32, n_records: u32) -> Result<()> {\n    let tid_bytes = tid.to_be_bytes();\n    for id in 0..n_records {\n        let mut key: Vec<u8> = Vec::new();\n        key.extend_from_slice(&id.to_be_bytes());\n        key.extend_from_slice(&tid_bytes);\n        s.put(key, tid_bytes.to_vec())?;\n    }\n    Ok(())\n}", "item_id": 5, "repo": "knizhnik/yakv", "file": "tests/storage_spec.rs", "last_update_at": "2022-03-05T12:50:08+00:00", "question_id": "94eeb0179269e48b811d7d886afceb3c9ad4c445_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn do_inserts(s: Arc<Storage>, tid: u32, n_records: u32) -> Result<()> {\n    let tid_bytes = tid.to_be_bytes();\n    for id in 0..n_records {\n        let mut key: Vec<u8> = Vec::new();\n        key.extend_from_slice(&id.to_be_bytes());\n        key.extend_from_slice(&tid_bytes);\n        s.put(key, tid_bytes.to_vec())?;\n    }\n    Ok(())\n"]], "pred": {"ppl": 2.2741010189056396, "ppl_lower": 2.8714160919189453, "ppl/lowercase_ppl": -1.2838666161683907, "ppl/zlib": 0.004087486655636849, "Min_5.0% Prob": 7.221281131108602, "Min_10.0% Prob": 5.522191799603975, "Min_20.0% Prob": 3.669167545106676, "Min_30.0% Prob": 2.6278730202011946, "Min_40.0% Prob": 2.026045097546144, "Min_50.0% Prob": 1.6343391982001672, "Min_60.0% Prob": 1.3811216547222036}}
{"hexsha": "e442c968e23f01371625ee2c451f1818ce9837d7", "ext": "rs", "lang": "Rust", "content": "fn add_article(conn_pg: ConnPg, conn_dsl: ConnDsl, user: UserOr, user_id: UserId, data_article: Form<DataArticle>)  -> Template {\n    let data = data_article.get();\n    let uid = user_id.0;\n    let category = &data.category;\n    let title = &data.title;\n    let raw = &data.raw;\n    add_article_by_uid(&conn_dsl, uid, &category, &title, &raw);\n    let datas = article_list(&conn_pg);\n    let context = TemplateArticle {\n        datas: datas,\n        username: user.0,\n        user_id: user_id.0,\n    };\n    Template::render(\"index\", &context)\n}", "item_id": 3, "repo": "alluLinger/kylyp", "file": "src/controller/article.rs", "last_update_at": "2022-03-03T14:38:00+00:00", "question_id": "e442c968e23f01371625ee2c451f1818ce9837d7_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn add_article(conn_pg: ConnPg, conn_dsl: ConnDsl, user: UserOr, user_id: UserId, data_article: Form<DataArticle>)  -> Template {\n    let data = data_article.get();\n    let uid = user_id.0;\n    let category = &data.category;\n    let title = &data.title;\n    let raw = &data.raw;\n    add_article_by_uid(&conn_dsl, uid, &category, &title, &raw);\n    let datas = article_list(&conn_pg);\n    let context = TemplateArticle {\n        datas: datas,\n        username: user.0,\n        user_id: user_id.0,\n    };\n    Template::render(\"index\", &context)\n"]], "pred": {"ppl": 3.5179944038391113, "ppl_lower": 4.219761848449707, "ppl/lowercase_ppl": -1.1445972892790603, "ppl/zlib": 0.0046588557614512865, "Min_5.0% Prob": 7.780509736802843, "Min_10.0% Prob": 6.590664462039345, "Min_20.0% Prob": 4.980877951571816, "Min_30.0% Prob": 3.7568143554802598, "Min_40.0% Prob": 3.0022664178501475, "Min_50.0% Prob": 2.4560705085390624, "Min_60.0% Prob": 2.0830506690745723}}
{"hexsha": "a47954f1c09485973a72f04c9a710db160c3d28d", "ext": "rs", "lang": "Rust", "content": "fn get_data(status: (u8, u16, u8), payload: Vec<u8>) -> Vec<u8> {\n    let statindex = if status.0 == CTAPHID_MSG { 0 } else { 1 };\n\n    // data size\n    let datasize = if status.0 == CTAPHID_MSG {\n        // remove SW1 , SW2\n        status.1 - 2\n    } else {\n        status.1\n    };\n\n    // get CBOR\n    let mut data: Vec<u8> = vec![];\n    for n in statindex..datasize {\n        let index: usize = n.into();\n        let dat = payload[index];\n        data.push(dat);\n    }\n    data\n}", "item_id": 2, "repo": "gebogebogebo/ctap-hid-fido2", "file": "src/ctaphid.rs", "last_update_at": "2022-03-27T08:58:38+00:00", "question_id": "a47954f1c09485973a72f04c9a710db160c3d28d_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_data(status: (u8, u16, u8), payload: Vec<u8>) -> Vec<u8> {\n    let statindex = if status.0 == CTAPHID_MSG { 0 } else { 1 };\n    // data size\n    let datasize = if status.0 == CTAPHID_MSG {\n        // remove SW1 , SW2\n        status.1 - 2\n    } else {\n        status.1\n    };\n    // get CBOR\n    let mut data: Vec<u8> = vec![];\n    for n in statindex..datasize {\n        let index: usize = n.into();\n        let dat = payload[index];\n        data.push(dat);\n    }\n    data\n"]], "pred": {"ppl": 3.2437477111816406, "ppl_lower": 3.7650485038757324, "ppl/lowercase_ppl": -1.1266488170118487, "ppl/zlib": 0.004525882162781038, "Min_5.0% Prob": 9.022631486256918, "Min_10.0% Prob": 6.822860995928447, "Min_20.0% Prob": 4.7680280627431095, "Min_30.0% Prob": 3.648480668934909, "Min_40.0% Prob": 2.8612084541771865, "Min_50.0% Prob": 2.3411454146970874, "Min_60.0% Prob": 1.9544055160839815}}
{"hexsha": "10c37d13c9d7737d94a2336977e75af31c3fabea", "ext": "rs", "lang": "Rust", "content": "fn _0002() {\n  let scope = scope!();\n  scope.set_entry(&\"  \\n  \\n  \\t  thing \\n \\t \\t \".into(), value_null!());\n  accept(\n    &scope,\n    StartTextualExpression,\n    \"thing\",\n    r#\"\n       Name\n       \u2514\u2500 `thing`\n    \"#,\n    false,\n  );\n}", "item_id": 1, "repo": "dmntk/dmntk.rs", "file": "feel-parser/src/tests/name.rs", "last_update_at": "2022-03-31T13:13:29+00:00", "question_id": "10c37d13c9d7737d94a2336977e75af31c3fabea_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn _0002() {\n  let scope = scope!();\n  scope.set_entry(&\"  \\n  \\n  \\t  thing \\n \\t \\t \".into(), value_null!());\n  accept(\n    &scope,\n    StartTextualExpression,\n    \"thing\",\n    r#\"\n       Name\n       \u2514\u2500 `thing`\n    \"#,\n    false,\n  );\n"]], "pred": {"ppl": 8.330428123474121, "ppl_lower": 9.562857627868652, "ppl/lowercase_ppl": -1.0650836269191943, "ppl/zlib": 0.012183418679500567, "Min_5.0% Prob": 10.012909412384033, "Min_10.0% Prob": 8.820289770762125, "Min_20.0% Prob": 7.005449596204255, "Min_30.0% Prob": 5.661416481281149, "Min_40.0% Prob": 4.690471028670286, "Min_50.0% Prob": 3.986507867063795, "Min_60.0% Prob": 3.44720281685813}}
{"hexsha": "7e6af774643419db92e3ce46aea86f0dc494f050", "ext": "rs", "lang": "Rust", "content": "fn test_small_bit_vec_tests() {\n    let v = BitVec::from_slice(&[0]);\n    assert!(!v.all());\n    assert!(!v.any());\n    assert!(v.none());\n\n    let v = BitVec::from_slice(&[0b00010100]);\n    assert!(!v.all());\n    assert!(v.any());\n    assert!(!v.none());\n\n    let v = BitVec::from_slice(&[0xFF]);\n    assert!(v.all());\n    assert!(v.any());\n    assert!(!v.none());\n}", "item_id": 17, "repo": "huonw/primal", "file": "primal-bit/tests/from_rust.rs", "last_update_at": "2022-03-21T17:42:29+00:00", "question_id": "7e6af774643419db92e3ce46aea86f0dc494f050_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_small_bit_vec_tests() {\n    let v = BitVec::from_slice(&[0]);\n    assert!(!v.all());\n    assert!(!v.any());\n    assert!(v.none());\n    let v = BitVec::from_slice(&[0b00010100]);\n    assert!(!v.all());\n    assert!(v.any());\n    assert!(!v.none());\n    let v = BitVec::from_slice(&[0xFF]);\n    assert!(v.all());\n    assert!(v.any());\n    assert!(!v.none());\n"]], "pred": {"ppl": 1.7812979221343994, "ppl_lower": 1.8837014436721802, "ppl/lowercase_ppl": -1.0968167912644748, "ppl/zlib": 0.004441094371748665, "Min_5.0% Prob": 6.188823154994419, "Min_10.0% Prob": 4.447655073234013, "Min_20.0% Prob": 2.7025276196414025, "Min_30.0% Prob": 1.9013188068162312, "Min_40.0% Prob": 1.4488120872085377, "Min_50.0% Prob": 1.1608610176795942, "Min_60.0% Prob": 0.9659630851715468}}
{"hexsha": "705b144edcd33a7acc3d6c5ba52f74b29b11babf", "ext": "rs", "lang": "Rust", "content": "fn save_follower_relation<S: Storage>(\n    storage: &mut S,\n    owner: &CanonicalAddr,\n    followed_addr: &CanonicalAddr,\n) -> StdResult<()> {\n    // save follower relation\n    let mut vec_storage = PrefixedStorage::multilevel(\n        &[PREFIX_FOLLOWERS, &followed_addr.as_slice(), PREFIX_VEC],\n        storage,\n    );\n    let vec_storage = AppendStoreMut::<Follower, _>::attach_or_create(&mut vec_storage)?;\n    let vec_storage_len = vec_storage.len();\n\n    let link_storage = ReadonlyPrefixedStorage::multilevel(\n        &[PREFIX_FOLLOWERS, &followed_addr.as_slice(), PREFIX_LINK],\n        storage,\n    );\n\n    let idx: u32 =\n        get_bin_data(&link_storage, owner.as_slice()).unwrap_or_else(|_| vec_storage_len);\n    let follower = Follower {\n        who: owner.clone(),\n        active: true,\n    };\n\n    let mut vec_storage = PrefixedStorage::multilevel(\n        &[PREFIX_FOLLOWERS, &followed_addr.as_slice(), PREFIX_VEC],\n        storage,\n    );\n    let mut vec_storage = AppendStoreMut::<Follower, _>::attach_or_create(&mut vec_storage)?;\n    if idx == vec_storage_len {\n        vec_storage.push(&follower)?;\n    } else {\n        vec_storage.set_at(idx, &follower)?;\n    }\n\n    let mut link_storage = PrefixedStorage::multilevel(\n        &[PREFIX_FOLLOWERS, &followed_addr.as_slice(), PREFIX_LINK],\n        storage,\n    );\n    if idx == vec_storage_len {\n        set_bin_data(&mut link_storage, owner.as_slice(), &idx)?;\n    }\n\n    Ok(())\n}", "item_id": 3, "repo": "darwinzer0/fardels", "file": "contract/src/social_state.rs", "last_update_at": "2022-02-21T07:56:50+00:00", "question_id": "705b144edcd33a7acc3d6c5ba52f74b29b11babf_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn save_follower_relation<S: Storage>(\n    storage: &mut S,\n    owner: &CanonicalAddr,\n    followed_addr: &CanonicalAddr,\n) -> StdResult<()> {\n    // save follower relation\n    let mut vec_storage = PrefixedStorage::multilevel(\n        &[PREFIX_FOLLOWERS, &followed_addr.as_slice(), PREFIX_VEC],\n        storage,\n    );\n    let vec_storage = AppendStoreMut::<Follower, _>::attach_or_create(&mut vec_storage)?;\n    let vec_storage_len = vec_storage.len();\n    let link_storage = ReadonlyPrefixedStorage::multilevel(\n        &[PREFIX_FOLLOWERS, &followed_addr.as_slice(), PREFIX_LINK],\n        storage,\n    );\n    let idx: u32 =\n        get_bin_data(&link_storage, owner.as_slice()).unwrap_or_else(|_| vec_storage_len);\n    let follower = Follower {\n        who: owner.clone(),\n        active: true,\n    };\n    let mut vec_storage = PrefixedStorage::multilevel(\n        &[PREFIX_FOLLOWERS, &followed_addr.as_slice(), PREFIX_VEC],\n        storage,\n    );\n    let mut vec_storage = AppendStoreMut::<Follower, _>::attach_or_create(&mut vec_storage)?;\n    if idx == vec_storage_len {\n        vec_storage.push(&follower)?;\n    } else {\n        vec_storage.set_at(idx, &follower)?;\n    }\n    let mut link_storage = PrefixedStorage::multilevel(\n        &[PREFIX_FOLLOWERS, &followed_addr.as_slice(), PREFIX_LINK],\n        storage,\n    );\n    if idx == vec_storage_len {\n        set_bin_data(&mut link_storage, owner.as_slice(), &idx)?;\n    }\n    Ok(())\n"]], "pred": {"ppl": 1.71986722946167, "ppl_lower": 2.3420896530151367, "ppl/lowercase_ppl": -1.569475524665345, "ppl/zlib": 0.001204993545938766, "Min_5.0% Prob": 5.765698556900024, "Min_10.0% Prob": 4.009478851860645, "Min_20.0% Prob": 2.511283079976017, "Min_30.0% Prob": 1.7766666709409131, "Min_40.0% Prob": 1.3490364832749355, "Min_50.0% Prob": 1.0854642674279786, "Min_60.0% Prob": 0.9035119587257143}}
{"hexsha": "06656cd35a4c28ccebc2eb1592d6fcfa2194d46c", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout_MonoReflectionMethodAux() {\n    assert_eq!(\n        ::std::mem::size_of::<MonoReflectionMethodAux>(),\n        56usize,\n        concat!(\"Size of: \", stringify!(MonoReflectionMethodAux))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<MonoReflectionMethodAux>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(MonoReflectionMethodAux))\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_names as *const _ as usize\n        },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(MonoReflectionMethodAux),\n            \"::\",\n            stringify!(param_names)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_marshall as *const _ as usize\n        },\n        8usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(MonoReflectionMethodAux),\n            \"::\",\n            stringify!(param_marshall)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_cattr as *const _ as usize\n        },\n        16usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(MonoReflectionMethodAux),\n            \"::\",\n            stringify!(param_cattr)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_defaults as *const _ as usize\n        },\n        24usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(MonoReflectionMethodAux),\n            \"::\",\n            stringify!(param_defaults)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_default_types as *const _\n                as usize\n        },\n        32usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(MonoReflectionMethodAux),\n            \"::\",\n            stringify!(param_default_types)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<MonoReflectionMethodAux>())).dllentry as *const _ as usize\n        },\n        40usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(MonoReflectionMethodAux),\n            \"::\",\n            stringify!(dllentry)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<MonoReflectionMethodAux>())).dll as *const _ as usize },\n        48usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(MonoReflectionMethodAux),\n            \"::\",\n            stringify!(dll)\n        )\n    );\n}", "item_id": 49, "repo": "Hezuikn/mono-rs", "file": "src/bindings.rs", "last_update_at": "2022-01-02T08:48:47+00:00", "question_id": "06656cd35a4c28ccebc2eb1592d6fcfa2194d46c_49", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bindgen_test_layout_MonoReflectionMethodAux() {\n    assert_eq!(\n        ::std::mem::size_of::<MonoReflectionMethodAux>(),\n        56usize,\n        concat!(\"Size of: \", stringify!(MonoReflectionMethodAux))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<MonoReflectionMethodAux>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(MonoReflectionMethodAux))\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_names as *const _ as usize\n        },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(MonoReflectionMethodAux),\n            \"::\",\n            stringify!(param_names)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_marshall as *const _ as usize\n        },\n        8usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(MonoReflectionMethodAux),\n            \"::\",\n            stringify!(param_marshall)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_cattr as *const _ as usize\n        },\n        16usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(MonoReflectionMethodAux),\n            \"::\",\n            stringify!(param_cattr)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_defaults as *const _ as usize\n        },\n        24usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(MonoReflectionMethodAux),\n            \"::\",\n            stringify!(param_defaults)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_default_types as *const _\n                as usize\n        },\n        32usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(MonoReflectionMethodAux),\n            \"::\",\n            stringify!(param_default_types)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<MonoReflectionMethodAux>())).dllentry as *const _ as usize\n        },\n        40usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(MonoReflectionMethodAux),\n            \"::\",\n            stringify!(dllentry)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<MonoReflectionMethodAux>())).dll as *const _ as usize },\n        48usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(MonoReflectionMethodAux),\n            \"::\",\n            stringify!(dll)\n        )\n    );\n"]], "pred": {"ppl": 1.1852631568908691, "ppl_lower": 1.245617389678955, "ppl/lowercase_ppl": -1.2922162251901395, "ppl/zlib": 0.0004656570500221685, "Min_5.0% Prob": 3.306625420000495, "Min_10.0% Prob": 1.7102198404737, "Min_20.0% Prob": 0.8507855509391944, "Min_30.0% Prob": 0.56837460619598, "Min_40.0% Prob": 0.4254249874948073, "Min_50.0% Prob": 0.3399290468857145, "Min_60.0% Prob": 0.2836178631835032}}
{"hexsha": "ab995d2c452535936ef07503967df939967f3aaa", "ext": "rs", "lang": "Rust", "content": "async fn it_test_prometheus_metrics() {\n        let mut mock_service = MockRouterService::new();\n        mock_service\n            .expect_call()\n            .times(1)\n            .returning(move |req: RouterRequest| {\n                Ok(RouterResponse::fake_builder()\n                    .context(req.context)\n                    .build()\n                    .unwrap()\n                    .boxed())\n            });\n\n        let mut dyn_plugin: Box<dyn DynPlugin> = crate::plugin::plugins()\n            .get(\"apollo.telemetry\")\n            .expect(\"Plugin not found\")\n            .create_instance(\n                &Value::from_str(\n                    r#\"{\n                \"apollo\": {\n                    \"client_name_header\": \"name_header\",\n                    \"client_version_header\": \"version_header\",\n                    \"schema_id\": \"schema_sha\"\n                },\n                \"metrics\": {\n                    \"common\": {\n                        \"attributes\": {\n                            \"from_headers\": [\n                                {\n                                    \"named\": \"test\",\n                                    \"default\": \"default_value\",\n                                    \"rename\": \"renamed_value\"\n                                },\n                                {\n                                    \"named\": \"another_test\",\n                                    \"default\": \"my_default_value\"\n                                }\n                            ],\n                            \"static\": [\n                                {\n                                    \"name\": \"myname\",\n                                    \"value\": \"label_value\"\n                                }\n                            ]\n                        }\n                    },\n                    \"prometheus\": {\n                        \"enabled\": true\n                    }\n                }\n            }\"#,\n                )\n                .unwrap(),\n            )\n            .await\n            .unwrap();\n        let mut router_service = dyn_plugin.router_service(BoxService::new(mock_service.build()));\n        let router_req = RouterRequest::fake_builder().header(\"test\", \"my_value_set\");\n\n        let _router_response = router_service\n            .ready()\n            .await\n            .unwrap()\n            .call(router_req.build().unwrap())\n            .await\n            .unwrap()\n            .next_response()\n            .await\n            .unwrap();\n\n        let handler = dyn_plugin.custom_endpoint().unwrap();\n        let http_req_prom = http_compat::Request::fake_builder()\n            .uri(Uri::from_static(\n                \"http://localhost:4000/BADPATH/apollo.telemetry/prometheus\",\n            ))\n            .method(Method::GET)\n            .body(Bytes::new())\n            .build()\n            .unwrap();\n        let resp = handler.clone().oneshot(http_req_prom).await.unwrap();\n        assert_eq!(resp.status(), StatusCode::NOT_FOUND);\n\n        let http_req_prom = http_compat::Request::fake_builder()\n            .uri(Uri::from_static(\n                \"http://localhost:4000/plugins/apollo.telemetry/prometheus\",\n            ))\n            .method(Method::GET)\n            .body(Bytes::new())\n            .build()\n            .unwrap();\n        let resp = handler.oneshot(http_req_prom).await.unwrap();\n        assert_eq!(resp.status(), StatusCode::OK);\n        match resp.body() {\n            crate::ResponseBody::Text(prom_metrics) => {\n                assert!(prom_metrics.contains(r#\"http_requests_total{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\"} 1\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_count{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"0.001\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"0.005\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"0.015\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"0.05\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"0.3\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"0.4\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"0.5\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"1\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"5\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"10\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"+Inf\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_count{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_sum{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\"}\"#));\n            }\n            _ => panic!(\"body does not have the right format\"),\n        }\n    }", "item_id": 0, "repo": "apollographql/router", "file": "apollo-router/src/plugins/telemetry/mod.rs", "last_update_at": "2022-03-30T22:31:53+00:00", "question_id": "ab995d2c452535936ef07503967df939967f3aaa_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn it_test_prometheus_metrics() {\n        let mut mock_service = MockRouterService::new();\n        mock_service\n            .expect_call()\n            .times(1)\n            .returning(move |req: RouterRequest| {\n                Ok(RouterResponse::fake_builder()\n                    .context(req.context)\n                    .build()\n                    .unwrap()\n                    .boxed())\n            });\n        let mut dyn_plugin: Box<dyn DynPlugin> = crate::plugin::plugins()\n            .get(\"apollo.telemetry\")\n            .expect(\"Plugin not found\")\n            .create_instance(\n                &Value::from_str(\n                    r#\"{\n                \"apollo\": {\n                    \"client_name_header\": \"name_header\",\n                    \"client_version_header\": \"version_header\",\n                    \"schema_id\": \"schema_sha\"\n                },\n                \"metrics\": {\n                    \"common\": {\n                        \"attributes\": {\n                            \"from_headers\": [\n                                {\n                                    \"named\": \"test\",\n                                    \"default\": \"default_value\",\n                                    \"rename\": \"renamed_value\"\n                                },\n                                {\n                                    \"named\": \"another_test\",\n                                    \"default\": \"my_default_value\"\n                                }\n                            ],\n                            \"static\": [\n                                {\n                                    \"name\": \"myname\",\n                                    \"value\": \"label_value\"\n                                }\n                            ]\n                        }\n                    },\n                    \"prometheus\": {\n                        \"enabled\": true\n                    }\n                }\n            }\"#,\n                )\n                .unwrap(),\n            )\n            .await\n            .unwrap();\n        let mut router_service = dyn_plugin.router_service(BoxService::new(mock_service.build()));\n        let router_req = RouterRequest::fake_builder().header(\"test\", \"my_value_set\");\n        let _router_response = router_service\n            .ready()\n            .await\n            .unwrap()\n            .call(router_req.build().unwrap())\n            .await\n            .unwrap()\n            .next_response()\n            .await\n            .unwrap();\n        let handler = dyn_plugin.custom_endpoint().unwrap();\n        let http_req_prom = http_compat::Request::fake_builder()\n            .uri(Uri::from_static(\n                \"http://localhost:4000/BADPATH/apollo.telemetry/prometheus\",\n            ))\n            .method(Method::GET)\n            .body(Bytes::new())\n            .build()\n            .unwrap();\n        let resp = handler.clone().oneshot(http_req_prom).await.unwrap();\n        assert_eq!(resp.status(), StatusCode::NOT_FOUND);\n        let http_req_prom = http_compat::Request::fake_builder()\n            .uri(Uri::from_static(\n                \"http://localhost:4000/plugins/apollo.telemetry/prometheus\",\n            ))\n            .method(Method::GET)\n            .body(Bytes::new())\n            .build()\n            .unwrap();\n        let resp = handler.oneshot(http_req_prom).await.unwrap();\n        assert_eq!(resp.status(), StatusCode::OK);\n        match resp.body() {\n            crate::ResponseBody::Text(prom_metrics) => {\n                assert!(prom_metrics.contains(r#\"http_requests_total{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\"} 1\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_count{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"0.001\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"0.005\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"0.015\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"0.05\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"0.3\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"0.4\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"0.5\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"1\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"5\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"10\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"+Inf\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_count{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_sum{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\"}\"#));\n            }\n            _ => panic!(\"body does not have the right format\"),\n        }\n"]], "pred": {"ppl": 1.9366815090179443, "ppl_lower": 2.120103359222412, "ppl/lowercase_ppl": -1.1369019498485389, "ppl/zlib": 0.0006200524822054692, "Min_5.0% Prob": 6.445329656787947, "Min_10.0% Prob": 4.732067701863308, "Min_20.0% Prob": 3.029001184538299, "Min_30.0% Prob": 2.1541874493940982, "Min_40.0% Prob": 1.6419758315409891, "Min_50.0% Prob": 1.3208720323186798, "Min_60.0% Prob": 1.102527043675065}}
{"hexsha": "12616c0908739002fe6187322e988e46314ee927", "ext": "rs", "lang": "Rust", "content": "fn test_P3_Cmp_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3CmpN5 as Ord>::to_ordering(), Ordering::Greater);\n}", "item_id": 1406, "repo": "krichard410/moloch-dao-substrate", "file": "target/release/build/typenum-dad1e3c5e3f02b9b/out/tests.rs", "last_update_at": "2022-03-04T01:44:49+00:00", "question_id": "12616c0908739002fe6187322e988e46314ee927_1406", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_P3_Cmp_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    #[allow(non_camel_case_types)]\n    type P3CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3CmpN5 as Ord>::to_ordering(), Ordering::Greater);\n"]], "pred": {"ppl": 1.6134289503097534, "ppl_lower": 3.595768451690674, "ppl/lowercase_ppl": -2.6752930512099473, "ppl/zlib": 0.002599791831658421, "Min_5.0% Prob": 7.164401531219482, "Min_10.0% Prob": 4.553954445398771, "Min_20.0% Prob": 2.4013364939735484, "Min_30.0% Prob": 1.6157213403628423, "Min_40.0% Prob": 1.213833723262024, "Min_50.0% Prob": 0.9566443473441089, "Min_60.0% Prob": 0.7992715610744199}}
{"hexsha": "46625b08d80d6af6416b86a3ba8d1ac961426211", "ext": "rs", "lang": "Rust", "content": "fn transition_callback() {\n        let mut sm = TransitionSm::new();\n        let transits = Arc::new(Mutex::new(Vec::new()));\n        let transits_cb = transits.clone();\n        sm.event_monitor_mut()\n            .add_transition_callback(Callback::new(\n                \"test\",\n                move |t: &Transition<TransitionSm>| {\n                    transits_cb.lock().unwrap().push(t.to_string());\n                },\n            ));\n        sm.transit();\n        assert_eq!(*transits.lock().unwrap(), vec![\"S0->S1\"]);\n        transits.lock().unwrap().clear();\n        sm.transit();\n        assert_eq!(*transits.lock().unwrap(), vec![\"S1->S2\", \"S2->S3\"]);\n    }", "item_id": 5, "repo": "gitter-badger/frame_transpiler", "file": "framec_tests/src/transition.rs", "last_update_at": "2022-02-27T16:36:14+00:00", "question_id": "46625b08d80d6af6416b86a3ba8d1ac961426211_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn transition_callback() {\n        let mut sm = TransitionSm::new();\n        let transits = Arc::new(Mutex::new(Vec::new()));\n        let transits_cb = transits.clone();\n        sm.event_monitor_mut()\n            .add_transition_callback(Callback::new(\n                \"test\",\n                move |t: &Transition<TransitionSm>| {\n                    transits_cb.lock().unwrap().push(t.to_string());\n                },\n            ));\n        sm.transit();\n        assert_eq!(*transits.lock().unwrap(), vec![\"S0->S1\"]);\n        transits.lock().unwrap().clear();\n        sm.transit();\n        assert_eq!(*transits.lock().unwrap(), vec![\"S1->S2\", \"S2->S3\"]);\n"]], "pred": {"ppl": 2.332456350326538, "ppl_lower": 2.8942339420318604, "ppl/lowercase_ppl": -1.2548033199025885, "ppl/zlib": 0.003160156492081668, "Min_5.0% Prob": 7.437655067443847, "Min_10.0% Prob": 5.746155560016632, "Min_20.0% Prob": 3.6843539069338545, "Min_30.0% Prob": 2.700053931748281, "Min_40.0% Prob": 2.087993955648527, "Min_50.0% Prob": 1.6828280531086968, "Min_60.0% Prob": 1.4156139606261642}}
{"hexsha": "36215d036542a38140c6b47e5e448ef5f5fce98a", "ext": "rs", "lang": "Rust", "content": "pub fn register_all_ops(reg: &mut OnnxOpRegister) {\n    reg.insert(\"GRU\", gru::gru);\n    reg.insert(\"LSTM\", lstm::lstm);\n    reg.insert(\"RNN\", rnn::rnn);\n    reg.insert(\"Scan\", scan::scan);\n}", "item_id": 0, "repo": "mithril-security/tract-sgx-xargo", "file": "onnx/src/ops/rec.rs", "last_update_at": "2022-03-31T08:14:32+00:00", "question_id": "36215d036542a38140c6b47e5e448ef5f5fce98a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn register_all_ops(reg: &mut OnnxOpRegister) {\n    reg.insert(\"GRU\", gru::gru);\n    reg.insert(\"LSTM\", lstm::lstm);\n    reg.insert(\"RNN\", rnn::rnn);\n    reg.insert(\"Scan\", scan::scan);\n"]], "pred": {"ppl": 2.6762096881866455, "ppl_lower": 3.639159917831421, "ppl/lowercase_ppl": -1.312221553724352, "ppl/zlib": 0.007631019364420411, "Min_5.0% Prob": 9.557984352111816, "Min_10.0% Prob": 7.573017733437674, "Min_20.0% Prob": 4.419067243734996, "Min_30.0% Prob": 3.2199312909082933, "Min_40.0% Prob": 2.4480086167653403, "Min_50.0% Prob": 1.9605608935418881, "Min_60.0% Prob": 1.6594195355764694}}
{"hexsha": "1abc65f64eec87163d57f09aaf6b5b24fae16bb6", "ext": "rs", "lang": "Rust", "content": "fn parse2() {\n    use crate::Pane;\n    use crate::PANE_ALL;\n\n    let origin = Pane {\n        #[cfg(feature = \"tmux_1_6\")]\n        active: Some(true),\n        #[cfg(feature = \"tmux_2_6\")]\n        at_bottom: Some(true),\n        #[cfg(feature = \"tmux_2_6\")]\n        at_left: Some(true),\n        #[cfg(feature = \"tmux_2_6\")]\n        at_right: Some(true),\n        #[cfg(feature = \"tmux_2_6\")]\n        at_top: Some(true),\n        #[cfg(feature = \"tmux_2_0\")]\n        bottom: Some(63),\n        #[cfg(feature = \"tmux_1_8\")]\n        current_command: Some(\"bash\".to_string()),\n        #[cfg(feature = \"tmux_1_7\")]\n        current_path: Some(\"/home/user\".to_string()),\n        #[cfg(feature = \"tmux_1_6\")]\n        dead: Some(false),\n        #[cfg(feature = \"tmux_2_0\")]\n        dead_status: None,\n        #[cfg(feature = \"tmux_2_6\")]\n        format: Some(true),\n        #[cfg(feature = \"tmux_1_6\")]\n        height: Some(64),\n        #[cfg(feature = \"tmux_1_6\")]\n        id: Some(0),\n        #[cfg(feature = \"tmux_1_8\")]\n        in_mode: Some(false),\n        #[cfg(feature = \"tmux_1_7\")]\n        index: Some(0),\n        #[cfg(feature = \"tmux_2_0\")]\n        input_off: Some(false),\n        #[cfg(feature = \"tmux_2_0\")]\n        left: Some(0),\n        #[cfg(feature = \"tmux_3_0\")]\n        marked: Some(false),\n        #[cfg(feature = \"tmux_3_0\")]\n        marked_set: Some(false),\n        #[cfg(feature = \"tmux_2_5\")]\n        mode: None,\n        #[cfg(feature = \"tmux_3_1\")]\n        path: None,\n        #[cfg(feature = \"tmux_1_6\")]\n        pid: Some(1945),\n        #[cfg(feature = \"tmux_2_6\")]\n        pipe: Some(false),\n        #[cfg(feature = \"tmux_2_0\")]\n        right: Some(176),\n        #[cfg(feature = \"tmux_2_5\")]\n        search_string: None,\n        #[cfg(feature = \"tmux_1_6\")]\n        start_command: None,\n        #[cfg(all(feature = \"tmux_1_6\", not(feature = \"tmux_2_0\")))]\n        start_path: None,\n        #[cfg(feature = \"tmux_1_9\")]\n        synchronized: Some(false),\n        #[cfg(feature = \"tmux_1_8\")]\n        tabs: None,\n        #[cfg(feature = \"tmux_1_6\")]\n        title: Some(\"title\".to_string()),\n        #[cfg(feature = \"tmux_2_0\")]\n        top: Some(0),\n        #[cfg(feature = \"tmux_1_6\")]\n        tty: Some(\"/dev/pts/2\".to_string()),\n        #[cfg(feature = \"tmux_1_6\")]\n        width: Some(177),\n    };\n\n    let pane_vec = vec![\n        // pane_active\n        #[cfg(feature = \"tmux_1_6\")]\n        \"1\",\n        // pane_at_bottom\n        #[cfg(feature = \"tmux_2_6\")]\n        \"1\",\n        // pane_at_left\n        #[cfg(feature = \"tmux_2_6\")]\n        \"1\",\n        // pane_at_right\n        #[cfg(feature = \"tmux_2_6\")]\n        \"1\",\n        // pane_at_top\n        #[cfg(feature = \"tmux_2_6\")]\n        \"1\",\n        // pane_bottom\n        #[cfg(feature = \"tmux_2_0\")]\n        \"63\",\n        // pane_current_command\n        #[cfg(feature = \"tmux_1_8\")]\n        \"bash\",\n        // pane_current_path\n        #[cfg(feature = \"tmux_1_7\")]\n        \"/home/user\",\n        // pane_dead\n        #[cfg(feature = \"tmux_1_6\")]\n        \"0\",\n        // pane_dead_status\n        #[cfg(feature = \"tmux_2_0\")]\n        \"\",\n        // pane_format\n        #[cfg(feature = \"tmux_2_6\")]\n        \"1\",\n        // pane_height\n        #[cfg(feature = \"tmux_1_6\")]\n        \"64\",\n        // pane_id\n        #[cfg(feature = \"tmux_1_6\")]\n        \"%0\",\n        // pane_in_mode\n        #[cfg(feature = \"tmux_1_8\")]\n        \"0\",\n        // pane_index\n        #[cfg(feature = \"tmux_1_7\")]\n        \"0\",\n        // pane_input_off\n        #[cfg(feature = \"tmux_2_0\")]\n        \"0\",\n        // pane_left\n        #[cfg(feature = \"tmux_2_0\")]\n        \"0\",\n        // pane_marked\n        #[cfg(feature = \"tmux_3_0\")]\n        \"0\",\n        // pane_marked_set\n        #[cfg(feature = \"tmux_3_0\")]\n        \"0\",\n        // pane_mode\n        #[cfg(feature = \"tmux_2_5\")]\n        \"\",\n        // pane_path\n        #[cfg(feature = \"tmux_3_1\")]\n        \"\",\n        // pane_pid\n        #[cfg(feature = \"tmux_1_6\")]\n        \"1945\",\n        // pane_pipe\n        #[cfg(feature = \"tmux_2_6\")]\n        \"0\",\n        // pane_right\n        #[cfg(feature = \"tmux_2_0\")]\n        \"176\",\n        // pane_search_string\n        #[cfg(feature = \"tmux_2_5\")]\n        \"\",\n        // pane_start_command\n        #[cfg(feature = \"tmux_1_6\")]\n        \"\",\n        // pane_start_path\n        #[cfg(all(feature = \"tmux_1_6\", not(feature = \"tmux_2_0\")))]\n        \"\",\n        // pane_synchronized\n        #[cfg(feature = \"tmux_1_9\")]\n        \"0\",\n        // pane_tabs\n        #[cfg(feature = \"tmux_1_8\")]\n        \"\",\n        // pane_title\n        #[cfg(feature = \"tmux_1_6\")]\n        \"title\",\n        // pane_top\n        #[cfg(feature = \"tmux_2_0\")]\n        \"0\",\n        // pane_tty\n        #[cfg(feature = \"tmux_1_6\")]\n        \"/dev/pts/2\",\n        // pane_width\n        #[cfg(feature = \"tmux_1_6\")]\n        \"177\",\n    ];\n    //let pane_str = \"1'1'1'1'1'63'bash'/home/user'0''1'64'%0'0'0'0'0'0'0''1945'0'176'''0''asus'0'/dev/pts/2'177\";\n    //let pane_str = \"1'1'1'1'1'63'bash'/home/user'0''1'64'%0'0'0'0'0'0'0''1945'0'176'''0'8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,128,136,144,152,160,168,176'asus'0'/dev/pts/2'177\";\n    let pane_str = pane_vec.join(\"'\");\n    let pane = Pane::from_str(&pane_str, PANE_ALL).unwrap();\n    //assert_eq!(pane.current_path, Some(\"/home/user\".to_string()));\n    //assert_eq!(pane.tty, Some(\"/dev/pts/2\".to_string()));\n    assert_eq!(origin, pane);\n}", "item_id": 5, "repo": "AntonGepting/tmux-interface", "file": "src/variables/pane/pane_tests.rs", "last_update_at": "2022-03-23T14:10:45+00:00", "question_id": "1abc65f64eec87163d57f09aaf6b5b24fae16bb6_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse2() {\n    use crate::Pane;\n    use crate::PANE_ALL;\n    let origin = Pane {\n        #[cfg(feature = \"tmux_1_6\")]\n        active: Some(true),\n        #[cfg(feature = \"tmux_2_6\")]\n        at_bottom: Some(true),\n        #[cfg(feature = \"tmux_2_6\")]\n        at_left: Some(true),\n        #[cfg(feature = \"tmux_2_6\")]\n        at_right: Some(true),\n        #[cfg(feature = \"tmux_2_6\")]\n        at_top: Some(true),\n        #[cfg(feature = \"tmux_2_0\")]\n        bottom: Some(63),\n        #[cfg(feature = \"tmux_1_8\")]\n        current_command: Some(\"bash\".to_string()),\n        #[cfg(feature = \"tmux_1_7\")]\n        current_path: Some(\"/home/user\".to_string()),\n        #[cfg(feature = \"tmux_1_6\")]\n        dead: Some(false),\n        #[cfg(feature = \"tmux_2_0\")]\n        dead_status: None,\n        #[cfg(feature = \"tmux_2_6\")]\n        format: Some(true),\n        #[cfg(feature = \"tmux_1_6\")]\n        height: Some(64),\n        #[cfg(feature = \"tmux_1_6\")]\n        id: Some(0),\n        #[cfg(feature = \"tmux_1_8\")]\n        in_mode: Some(false),\n        #[cfg(feature = \"tmux_1_7\")]\n        index: Some(0),\n        #[cfg(feature = \"tmux_2_0\")]\n        input_off: Some(false),\n        #[cfg(feature = \"tmux_2_0\")]\n        left: Some(0),\n        #[cfg(feature = \"tmux_3_0\")]\n        marked: Some(false),\n        #[cfg(feature = \"tmux_3_0\")]\n        marked_set: Some(false),\n        #[cfg(feature = \"tmux_2_5\")]\n        mode: None,\n        #[cfg(feature = \"tmux_3_1\")]\n        path: None,\n        #[cfg(feature = \"tmux_1_6\")]\n        pid: Some(1945),\n        #[cfg(feature = \"tmux_2_6\")]\n        pipe: Some(false),\n        #[cfg(feature = \"tmux_2_0\")]\n        right: Some(176),\n        #[cfg(feature = \"tmux_2_5\")]\n        search_string: None,\n        #[cfg(feature = \"tmux_1_6\")]\n        start_command: None,\n        #[cfg(all(feature = \"tmux_1_6\", not(feature = \"tmux_2_0\")))]\n        start_path: None,\n        #[cfg(feature = \"tmux_1_9\")]\n        synchronized: Some(false),\n        #[cfg(feature = \"tmux_1_8\")]\n        tabs: None,\n        #[cfg(feature = \"tmux_1_6\")]\n        title: Some(\"title\".to_string()),\n        #[cfg(feature = \"tmux_2_0\")]\n        top: Some(0),\n        #[cfg(feature = \"tmux_1_6\")]\n        tty: Some(\"/dev/pts/2\".to_string()),\n        #[cfg(feature = \"tmux_1_6\")]\n        width: Some(177),\n    };\n    let pane_vec = vec![\n        // pane_active\n        #[cfg(feature = \"tmux_1_6\")]\n        \"1\",\n        // pane_at_bottom\n        #[cfg(feature = \"tmux_2_6\")]\n        \"1\",\n        // pane_at_left\n        #[cfg(feature = \"tmux_2_6\")]\n        \"1\",\n        // pane_at_right\n        #[cfg(feature = \"tmux_2_6\")]\n        \"1\",\n        // pane_at_top\n        #[cfg(feature = \"tmux_2_6\")]\n        \"1\",\n        // pane_bottom\n        #[cfg(feature = \"tmux_2_0\")]\n        \"63\",\n        // pane_current_command\n        #[cfg(feature = \"tmux_1_8\")]\n        \"bash\",\n        // pane_current_path\n        #[cfg(feature = \"tmux_1_7\")]\n        \"/home/user\",\n        // pane_dead\n        #[cfg(feature = \"tmux_1_6\")]\n        \"0\",\n        // pane_dead_status\n        #[cfg(feature = \"tmux_2_0\")]\n        \"\",\n        // pane_format\n        #[cfg(feature = \"tmux_2_6\")]\n        \"1\",\n        // pane_height\n        #[cfg(feature = \"tmux_1_6\")]\n        \"64\",\n        // pane_id\n        #[cfg(feature = \"tmux_1_6\")]\n        \"%0\",\n        // pane_in_mode\n        #[cfg(feature = \"tmux_1_8\")]\n        \"0\",\n        // pane_index\n        #[cfg(feature = \"tmux_1_7\")]\n        \"0\",\n        // pane_input_off\n        #[cfg(feature = \"tmux_2_0\")]\n        \"0\",\n        // pane_left\n        #[cfg(feature = \"tmux_2_0\")]\n        \"0\",\n        // pane_marked\n        #[cfg(feature = \"tmux_3_0\")]\n        \"0\",\n        // pane_marked_set\n        #[cfg(feature = \"tmux_3_0\")]\n        \"0\",\n        // pane_mode\n        #[cfg(feature = \"tmux_2_5\")]\n        \"\",\n        // pane_path\n        #[cfg(feature = \"tmux_3_1\")]\n        \"\",\n        // pane_pid\n        #[cfg(feature = \"tmux_1_6\")]\n        \"1945\",\n        // pane_pipe\n        #[cfg(feature = \"tmux_2_6\")]\n        \"0\",\n        // pane_right\n        #[cfg(feature = \"tmux_2_0\")]\n        \"176\",\n        // pane_search_string\n        #[cfg(feature = \"tmux_2_5\")]\n        \"\",\n        // pane_start_command\n        #[cfg(feature = \"tmux_1_6\")]\n        \"\",\n        // pane_start_path\n        #[cfg(all(feature = \"tmux_1_6\", not(feature = \"tmux_2_0\")))]\n        \"\",\n        // pane_synchronized\n        #[cfg(feature = \"tmux_1_9\")]\n        \"0\",\n        // pane_tabs\n        #[cfg(feature = \"tmux_1_8\")]\n        \"\",\n        // pane_title\n        #[cfg(feature = \"tmux_1_6\")]\n        \"title\",\n        // pane_top\n        #[cfg(feature = \"tmux_2_0\")]\n        \"0\",\n        // pane_tty\n        #[cfg(feature = \"tmux_1_6\")]\n        \"/dev/pts/2\",\n        // pane_width\n        #[cfg(feature = \"tmux_1_6\")]\n        \"177\",\n    ];\n    //let pane_str = \"1'1'1'1'1'63'bash'/home/user'0''1'64'%0'0'0'0'0'0'0''1945'0'176'''0''asus'0'/dev/pts/2'177\";\n    //let pane_str = \"1'1'1'1'1'63'bash'/home/user'0''1'64'%0'0'0'0'0'0'0''1945'0'176'''0'8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,128,136,144,152,160,168,176'asus'0'/dev/pts/2'177\";\n    let pane_str = pane_vec.join(\"'\");\n    let pane = Pane::from_str(&pane_str, PANE_ALL).unwrap();\n    //assert_eq!(pane.current_path, Some(\"/home/user\".to_string()));\n    //assert_eq!(pane.tty, Some(\"/dev/pts/2\".to_string()));\n    assert_eq!(origin, pane);\n"]], "pred": {"ppl": 1.5014543533325195, "ppl_lower": 1.5407531261444092, "ppl/lowercase_ppl": -1.0635702706703478, "ppl/zlib": 0.00045009325278869795, "Min_5.0% Prob": 4.84801593948813, "Min_10.0% Prob": 3.3290953612795064, "Min_20.0% Prob": 1.993595656957112, "Min_30.0% Prob": 1.3559282667435755, "Min_40.0% Prob": 1.0162439577817726, "Min_50.0% Prob": 0.8135916641662184, "Min_60.0% Prob": 0.6782562756919893}}
{"hexsha": "6fe4c5300e59e2d27e2db3e5eaf76d4b37a8332d", "ext": "rs", "lang": "Rust", "content": "fn built_in_fn_to_string() {\n    let ast = src_to_ast(vec![\n        r#\"\u09a6\u09c7\u0996\u09be\u0993 _\u09b8\u09cd\u099f\u09cd\u09b0\u09bf\u0982(\u09e7) == \"\u09e7\";\"#,\n        r#\"\u09a6\u09c7\u0996\u09be\u0993 _\u09b8\u09cd\u099f\u09cd\u09b0\u09bf\u0982(\u09e7.\u09e6) == \"\u09e7\";\"#,\n        r#\"\u09a6\u09c7\u0996\u09be\u0993 _\u09b8\u09cd\u099f\u09cd\u09b0\u09bf\u0982(-\u09e7.\u09e6) == \"-\u09e7\";\"#,\n        r#\"\u09a6\u09c7\u0996\u09be\u0993 _\u09b8\u09cd\u099f\u09cd\u09b0\u09bf\u0982(\u09e7\u09e9.\u09e9\u09e8) == \"\u09e7\u09e9.\u09e9\u09e8\";\"#,\n        r#\"\u09a6\u09c7\u0996\u09be\u0993 _\u09b8\u09cd\u099f\u09cd\u09b0\u09bf\u0982(-\u09ea\u09e9.\u09ea\u09e9) == \"-\u09ea\u09e9.\u09ea\u09e9\";\"#,\n        r#\"\u09a6\u09c7\u0996\u09be\u0993 _\u09b8\u09cd\u099f\u09cd\u09b0\u09bf\u0982(-\u09e6.\u09ea\u09e9) == \"-\u09e6.\u09ea\u09e9\";\"#,\n    ]);\n    let mut mock_io: MockIO = MockIO::new();\n    mock_io.expect_println(\"\u09b8\u09a4\u09cd\u09af\");\n    mock_io.expect_println(\"\u09b8\u09a4\u09cd\u09af\");\n    mock_io.expect_println(\"\u09b8\u09a4\u09cd\u09af\");\n    mock_io.expect_println(\"\u09b8\u09a4\u09cd\u09af\");\n    mock_io.expect_println(\"\u09b8\u09a4\u09cd\u09af\");\n    mock_io.expect_println(\"\u09b8\u09a4\u09cd\u09af\");\n    if let Err(err) = run_assert_all_true(ast, mock_io) {\n        panic!(\"{:?}\", err);\n    }\n}", "item_id": 33, "repo": "Shafin098/pakhi-bhasha", "file": "tests/interpreter.rs", "last_update_at": "2022-02-28T12:36:20+00:00", "question_id": "6fe4c5300e59e2d27e2db3e5eaf76d4b37a8332d_33", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn built_in_fn_to_string() {\n    let ast = src_to_ast(vec![\n        r#\"\u09a6\u09c7\u0996\u09be\u0993 _\u09b8\u09cd\u099f\u09cd\u09b0\u09bf\u0982(\u09e7) == \"\u09e7\";\"#,\n        r#\"\u09a6\u09c7\u0996\u09be\u0993 _\u09b8\u09cd\u099f\u09cd\u09b0\u09bf\u0982(\u09e7.\u09e6) == \"\u09e7\";\"#,\n        r#\"\u09a6\u09c7\u0996\u09be\u0993 _\u09b8\u09cd\u099f\u09cd\u09b0\u09bf\u0982(-\u09e7.\u09e6) == \"-\u09e7\";\"#,\n        r#\"\u09a6\u09c7\u0996\u09be\u0993 _\u09b8\u09cd\u099f\u09cd\u09b0\u09bf\u0982(\u09e7\u09e9.\u09e9\u09e8) == \"\u09e7\u09e9.\u09e9\u09e8\";\"#,\n        r#\"\u09a6\u09c7\u0996\u09be\u0993 _\u09b8\u09cd\u099f\u09cd\u09b0\u09bf\u0982(-\u09ea\u09e9.\u09ea\u09e9) == \"-\u09ea\u09e9.\u09ea\u09e9\";\"#,\n        r#\"\u09a6\u09c7\u0996\u09be\u0993 _\u09b8\u09cd\u099f\u09cd\u09b0\u09bf\u0982(-\u09e6.\u09ea\u09e9) == \"-\u09e6.\u09ea\u09e9\";\"#,\n    ]);\n    let mut mock_io: MockIO = MockIO::new();\n    mock_io.expect_println(\"\u09b8\u09a4\u09cd\u09af\");\n    mock_io.expect_println(\"\u09b8\u09a4\u09cd\u09af\");\n    mock_io.expect_println(\"\u09b8\u09a4\u09cd\u09af\");\n    mock_io.expect_println(\"\u09b8\u09a4\u09cd\u09af\");\n    mock_io.expect_println(\"\u09b8\u09a4\u09cd\u09af\");\n    mock_io.expect_println(\"\u09b8\u09a4\u09cd\u09af\");\n    if let Err(err) = run_assert_all_true(ast, mock_io) {\n        panic!(\"{:?}\", err);\n    }\n"]], "pred": {"ppl": 1.7521440982818604, "ppl_lower": 1.859954833984375, "ppl/lowercase_ppl": -1.1064687653916174, "ppl/zlib": 0.0019076198537748387, "Min_5.0% Prob": 6.8034186881521475, "Min_10.0% Prob": 4.618847976339624, "Min_20.0% Prob": 2.712530087600363, "Min_30.0% Prob": 1.8581256103431079, "Min_40.0% Prob": 1.3998438109980618, "Min_50.0% Prob": 1.121110706269107, "Min_60.0% Prob": 0.9345508024797458}}
{"hexsha": "e1cf57a1a62cadc5d181bfdf945465ab99f18ee1", "ext": "rs", "lang": "Rust", "content": "fn bench_cidentity_giant(b: &mut Bencher) {\n        let n = 16;\n\n        let mat = from_reals(&[1.0, 0.0, 0.0, 1.0]);\n        let c_indices = (0..n - 1).collect();\n        let op = make_matrix_op(vec![n - 1], mat).unwrap();\n        let op = make_control_op(c_indices, op).unwrap();\n\n        let base_vector: Vec<f64> = (0..1 << n).map(|_| 0.0).collect();\n        let input = from_reals(&base_vector);\n        let mut output = from_reals(&base_vector);\n\n        b.iter(|| apply_op(n, &op, &input, &mut output, 0, 0));\n    }", "item_id": 6, "repo": "oxarbitrage/RustQIP", "file": "benches/state_bench.rs", "last_update_at": "2022-03-30T13:48:29+00:00", "question_id": "e1cf57a1a62cadc5d181bfdf945465ab99f18ee1_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bench_cidentity_giant(b: &mut Bencher) {\n        let n = 16;\n        let mat = from_reals(&[1.0, 0.0, 0.0, 1.0]);\n        let c_indices = (0..n - 1).collect();\n        let op = make_matrix_op(vec![n - 1], mat).unwrap();\n        let op = make_control_op(c_indices, op).unwrap();\n        let base_vector: Vec<f64> = (0..1 << n).map(|_| 0.0).collect();\n        let input = from_reals(&base_vector);\n        let mut output = from_reals(&base_vector);\n        b.iter(|| apply_op(n, &op, &input, &mut output, 0, 0));\n"]], "pred": {"ppl": 3.32481050491333, "ppl_lower": 3.732464075088501, "ppl/lowercase_ppl": -1.0962666249448654, "ppl/zlib": 0.004568109055058018, "Min_5.0% Prob": 8.418752813339234, "Min_10.0% Prob": 6.560180891127813, "Min_20.0% Prob": 4.6802365098680765, "Min_30.0% Prob": 3.5842548608779907, "Min_40.0% Prob": 2.8518225515589997, "Min_50.0% Prob": 2.3595981105880917, "Min_60.0% Prob": 1.9975638054017946}}
{"hexsha": "c95d9a131896a303b21d2e61f964bf127f8db7b1", "ext": "rs", "lang": "Rust", "content": "fn split<'a>(r: &'a Regex, text: &'a str) -> Vec<&'a str> {\n    let mut result = Vec::new();\n    let mut last = 0;\n    for (index, matched) in text.match_indices(r) {\n        if last != index {\n            result.push(&text[last..index]);\n        }\n        result.push(matched);\n\n        last = index + matched.len();\n    }\n    if last < text.len() {\n        result.push(&text[last..]);\n    }\n    result\n}", "item_id": 0, "repo": "marc2332/ham", "file": "ham_core/src/lib.rs", "last_update_at": "2022-03-07T16:03:57+00:00", "question_id": "c95d9a131896a303b21d2e61f964bf127f8db7b1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn split<'a>(r: &'a Regex, text: &'a str) -> Vec<&'a str> {\n    let mut result = Vec::new();\n    let mut last = 0;\n    for (index, matched) in text.match_indices(r) {\n        if last != index {\n            result.push(&text[last..index]);\n        }\n        result.push(matched);\n        last = index + matched.len();\n    }\n    if last < text.len() {\n        result.push(&text[last..]);\n    }\n    result\n"]], "pred": {"ppl": 1.5649632215499878, "ppl_lower": 1.8820854425430298, "ppl/lowercase_ppl": -1.411997409396473, "ppl/zlib": 0.0022062183404381102, "Min_5.0% Prob": 5.4365736075810025, "Min_10.0% Prob": 3.647170058318547, "Min_20.0% Prob": 2.0979517879230634, "Min_30.0% Prob": 1.460084961815959, "Min_40.0% Prob": 1.1118975295020002, "Min_50.0% Prob": 0.8932443331794016, "Min_60.0% Prob": 0.745490686779487}}
{"hexsha": "7396a47a37791c0e23bfdc96eb93b85c0b853f6f", "ext": "rs", "lang": "Rust", "content": "pub extern \"C\" fn ipassignment_free(ip_assignment: *mut IpAssignment<u32>) {\n        assert!(!ip_assignment.is_null());\n        unsafe { Box::from_raw(ip_assignment) };\n    }", "item_id": 5, "repo": "mjptree/shadow", "file": "src/main/routing/network_graph.rs", "last_update_at": "2022-03-30T09:04:18+00:00", "question_id": "7396a47a37791c0e23bfdc96eb93b85c0b853f6f_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub extern \"C\" fn ipassignment_free(ip_assignment: *mut IpAssignment<u32>) {\n        assert!(!ip_assignment.is_null());\n        unsafe { Box::from_raw(ip_assignment) };\n"]], "pred": {"ppl": 3.4964630603790283, "ppl_lower": 5.152215480804443, "ppl/lowercase_ppl": -1.3097058676021347, "ppl/zlib": 0.009934538915585829, "Min_5.0% Prob": 9.759719848632812, "Min_10.0% Prob": 7.972108523050944, "Min_20.0% Prob": 5.6863342722256975, "Min_30.0% Prob": 4.100865082608329, "Min_40.0% Prob": 3.1667553186416626, "Min_50.0% Prob": 2.490809334381934, "Min_60.0% Prob": 2.0950609709362724}}
{"hexsha": "6c7cf2611001c13b04b5b9ee7237f07c08d40a20", "ext": "rs", "lang": "Rust", "content": "fn empty_git_commit<'r>(\n    git_repo: &'r git2::Repository,\n    ref_name: &str,\n    parents: &[&git2::Commit],\n) -> git2::Commit<'r> {\n    let signature = git2::Signature::now(\"Someone\", \"someone@example.com\").unwrap();\n    let empty_tree_id = Oid::from_str(\"4b825dc642cb6eb9a060e54bf8d69288fbee4904\").unwrap();\n    let empty_tree = git_repo.find_tree(empty_tree_id).unwrap();\n    let oid = git_repo\n        .commit(\n            Some(ref_name),\n            &signature,\n            &signature,\n            &format!(\"random commit {}\", rand::random::<u32>()),\n            &empty_tree,\n            parents,\n        )\n        .unwrap();\n    git_repo.find_commit(oid).unwrap()\n}", "item_id": 0, "repo": "clayne/jj", "file": "lib/tests/test_git.rs", "last_update_at": "2022-03-30T23:59:48+00:00", "question_id": "6c7cf2611001c13b04b5b9ee7237f07c08d40a20_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn empty_git_commit<'r>(\n    git_repo: &'r git2::Repository,\n    ref_name: &str,\n    parents: &[&git2::Commit],\n) -> git2::Commit<'r> {\n    let signature = git2::Signature::now(\"Someone\", \"someone@example.com\").unwrap();\n    let empty_tree_id = Oid::from_str(\"4b825dc642cb6eb9a060e54bf8d69288fbee4904\").unwrap();\n    let empty_tree = git_repo.find_tree(empty_tree_id).unwrap();\n    let oid = git_repo\n        .commit(\n            Some(ref_name),\n            &signature,\n            &signature,\n            &format!(\"random commit {}\", rand::random::<u32>()),\n            &empty_tree,\n            parents,\n        )\n        .unwrap();\n    git_repo.find_commit(oid).unwrap()\n"]], "pred": {"ppl": 1.668459177017212, "ppl_lower": 2.0509302616119385, "ppl/lowercase_ppl": -1.4031894935818832, "ppl/zlib": 0.0015848314304453984, "Min_5.0% Prob": 6.476513087749481, "Min_10.0% Prob": 4.327599649628003, "Min_20.0% Prob": 2.432926840928136, "Min_30.0% Prob": 1.685286152604464, "Min_40.0% Prob": 1.2772256504706663, "Min_50.0% Prob": 1.0226283772029885, "Min_60.0% Prob": 0.857506247248337}}
{"hexsha": "976070c649d0db7bbc274371fdedab5a49d4603e", "ext": "rs", "lang": "Rust", "content": "fn nontrivial_identity_syntactic() {\n    // dnf (!a * !b * !c) + (!a * !b * c) + (!a * b * c) + (a * !b * c) + (a * b * !c)\n    //                                    <=>\n    // cnf            !(!a * b * !c) * !(a * !b * !c) * !(a * b * c)\n    let variables = mk_5_variable_set();\n    let a = variables.mk_var(v1());\n    let b = variables.mk_var(v2());\n    let c = variables.mk_var(v3());\n\n    let d1 = bdd!(((!a) & (!b)) & (!c));\n    let d2 = bdd!(((!a) & (!b)) & c);\n    let d3 = bdd!(((!a) & b) & c);\n    let d4 = bdd!((a & (!b)) & c);\n    let d5 = bdd!((a & b) & (!c));\n\n    let c1 = bdd!((a | (!b)) | c);\n    let c2 = bdd!(((!a) | b) | c);\n    let c3 = bdd!(((!a) | (!b)) | (!c));\n\n    let cnf = bdd!(((c1 & c2) & c3));\n    let dnf = bdd!(((((d1 | d2) | d3) | d4) | d5));\n\n    assert_eq!(cnf, dnf);\n    assert!(bdd!((cnf <=> dnf)).is_true());\n    assert_eq!(20.0, cnf.cardinality());\n}", "item_id": 12, "repo": "lengyijun/biodivine-lib-bdd", "file": "src/_test_bdd/_test_bdd_logic_basic.rs", "last_update_at": "2022-03-10T09:57:36+00:00", "question_id": "976070c649d0db7bbc274371fdedab5a49d4603e_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn nontrivial_identity_syntactic() {\n    // dnf (!a * !b * !c) + (!a * !b * c) + (!a * b * c) + (a * !b * c) + (a * b * !c)\n    //                                    <=>\n    // cnf            !(!a * b * !c) * !(a * !b * !c) * !(a * b * c)\n    let variables = mk_5_variable_set();\n    let a = variables.mk_var(v1());\n    let b = variables.mk_var(v2());\n    let c = variables.mk_var(v3());\n    let d1 = bdd!(((!a) & (!b)) & (!c));\n    let d2 = bdd!(((!a) & (!b)) & c);\n    let d3 = bdd!(((!a) & b) & c);\n    let d4 = bdd!((a & (!b)) & c);\n    let d5 = bdd!((a & b) & (!c));\n    let c1 = bdd!((a | (!b)) | c);\n    let c2 = bdd!(((!a) | b) | c);\n    let c3 = bdd!(((!a) | (!b)) | (!c));\n    let cnf = bdd!(((c1 & c2) & c3));\n    let dnf = bdd!(((((d1 | d2) | d3) | d4) | d5));\n    assert_eq!(cnf, dnf);\n    assert!(bdd!((cnf <=> dnf)).is_true());\n    assert_eq!(20.0, cnf.cardinality());\n"]], "pred": {"ppl": 2.1894173622131348, "ppl_lower": 2.1894173622131348, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0024877316310498933, "Min_5.0% Prob": 6.767271019163585, "Min_10.0% Prob": 5.177568322136288, "Min_20.0% Prob": 3.441005338640774, "Min_30.0% Prob": 2.4920445537473275, "Min_40.0% Prob": 1.9281487863729982, "Min_50.0% Prob": 1.5587678790057489, "Min_60.0% Prob": 1.3066153378974574}}
{"hexsha": "54505e5beaa6a4e62e0c01348f1e97462aeb6b2a", "ext": "rs", "lang": "Rust", "content": "unsafe extern \"C\" fn opj_dwt_init_sparse_array(\n  mut tilec: *mut opj_tcd_tilecomp_t,\n  mut numres: OPJ_UINT32,\n) -> *mut opj_sparse_array_int32_t {\n  let mut tr_max: *mut opj_tcd_resolution_t = &mut *(*tilec)\n    .resolutions\n    .offset(numres.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize)\n    as *mut opj_tcd_resolution_t;\n  let mut w = ((*tr_max).x1 - (*tr_max).x0) as OPJ_UINT32;\n  let mut h = ((*tr_max).y1 - (*tr_max).y0) as OPJ_UINT32;\n  let mut resno: OPJ_UINT32 = 0;\n  let mut bandno: OPJ_UINT32 = 0;\n  let mut precno: OPJ_UINT32 = 0;\n  let mut cblkno: OPJ_UINT32 = 0;\n  let mut sa = opj_sparse_array_int32_create(\n    w,\n    h,\n    opj_uint_min(w, 64 as libc::c_int as OPJ_UINT32),\n    opj_uint_min(h, 64 as libc::c_int as OPJ_UINT32),\n  );\n  if sa.is_null() {\n    return 0 as *mut opj_sparse_array_int32_t;\n  }\n  resno = 0 as libc::c_int as OPJ_UINT32;\n  while resno < numres {\n    let mut res: *mut opj_tcd_resolution_t =\n      &mut *(*tilec).resolutions.offset(resno as isize) as *mut opj_tcd_resolution_t;\n    bandno = 0 as libc::c_int as OPJ_UINT32;\n    while bandno < (*res).numbands {\n      let mut band: *mut opj_tcd_band_t =\n        &mut *(*res).bands.as_mut_ptr().offset(bandno as isize) as *mut opj_tcd_band_t;\n      precno = 0 as libc::c_int as OPJ_UINT32;\n      while precno < (*res).pw.wrapping_mul((*res).ph) {\n        let mut precinct: *mut opj_tcd_precinct_t =\n          &mut *(*band).precincts.offset(precno as isize) as *mut opj_tcd_precinct_t;\n        cblkno = 0 as libc::c_int as OPJ_UINT32;\n        while cblkno < (*precinct).cw.wrapping_mul((*precinct).ch) {\n          let mut cblk: *mut opj_tcd_cblk_dec_t =\n            &mut *(*precinct).cblks.dec.offset(cblkno as isize) as *mut opj_tcd_cblk_dec_t;\n          if !(*cblk).decoded_data.is_null() {\n            let mut x = ((*cblk).x0 - (*band).x0) as OPJ_UINT32;\n            let mut y = ((*cblk).y0 - (*band).y0) as OPJ_UINT32;\n            let mut cblk_w = ((*cblk).x1 - (*cblk).x0) as OPJ_UINT32;\n            let mut cblk_h = ((*cblk).y1 - (*cblk).y0) as OPJ_UINT32;\n            if (*band).bandno & 1 as libc::c_int as libc::c_uint != 0 {\n              let mut pres: *mut opj_tcd_resolution_t = &mut *(*tilec)\n                .resolutions\n                .offset(resno.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize)\n                as *mut opj_tcd_resolution_t;\n              x = (x as libc::c_uint).wrapping_add(((*pres).x1 - (*pres).x0) as OPJ_UINT32)\n                as OPJ_UINT32 as OPJ_UINT32\n            }\n            if (*band).bandno & 2 as libc::c_int as libc::c_uint != 0 {\n              let mut pres_0: *mut opj_tcd_resolution_t = &mut *(*tilec)\n                .resolutions\n                .offset(resno.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize)\n                as *mut opj_tcd_resolution_t;\n              y = (y as libc::c_uint).wrapping_add(((*pres_0).y1 - (*pres_0).y0) as OPJ_UINT32)\n                as OPJ_UINT32 as OPJ_UINT32\n            }\n            if opj_sparse_array_int32_write(\n              sa,\n              x,\n              y,\n              x.wrapping_add(cblk_w),\n              y.wrapping_add(cblk_h),\n              (*cblk).decoded_data,\n              1 as libc::c_int as OPJ_UINT32,\n              cblk_w,\n              1 as libc::c_int,\n            ) == 0\n            {\n              opj_sparse_array_int32_free(sa);\n              return 0 as *mut opj_sparse_array_int32_t;\n            }\n          }\n          cblkno = cblkno.wrapping_add(1)\n        }\n        precno = precno.wrapping_add(1)\n      }\n      bandno = bandno.wrapping_add(1)\n    }\n    resno = resno.wrapping_add(1)\n  }\n  return sa;\n}", "item_id": 34, "repo": "Neopallium/openjpeg", "file": "openjp2-rs/src/dwt.rs", "last_update_at": "2022-02-02T19:47:58+00:00", "question_id": "54505e5beaa6a4e62e0c01348f1e97462aeb6b2a_34", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe extern \"C\" fn opj_dwt_init_sparse_array(\n  mut tilec: *mut opj_tcd_tilecomp_t,\n  mut numres: OPJ_UINT32,\n) -> *mut opj_sparse_array_int32_t {\n  let mut tr_max: *mut opj_tcd_resolution_t = &mut *(*tilec)\n    .resolutions\n    .offset(numres.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize)\n    as *mut opj_tcd_resolution_t;\n  let mut w = ((*tr_max).x1 - (*tr_max).x0) as OPJ_UINT32;\n  let mut h = ((*tr_max).y1 - (*tr_max).y0) as OPJ_UINT32;\n  let mut resno: OPJ_UINT32 = 0;\n  let mut bandno: OPJ_UINT32 = 0;\n  let mut precno: OPJ_UINT32 = 0;\n  let mut cblkno: OPJ_UINT32 = 0;\n  let mut sa = opj_sparse_array_int32_create(\n    w,\n    h,\n    opj_uint_min(w, 64 as libc::c_int as OPJ_UINT32),\n    opj_uint_min(h, 64 as libc::c_int as OPJ_UINT32),\n  );\n  if sa.is_null() {\n    return 0 as *mut opj_sparse_array_int32_t;\n  }\n  resno = 0 as libc::c_int as OPJ_UINT32;\n  while resno < numres {\n    let mut res: *mut opj_tcd_resolution_t =\n      &mut *(*tilec).resolutions.offset(resno as isize) as *mut opj_tcd_resolution_t;\n    bandno = 0 as libc::c_int as OPJ_UINT32;\n    while bandno < (*res).numbands {\n      let mut band: *mut opj_tcd_band_t =\n        &mut *(*res).bands.as_mut_ptr().offset(bandno as isize) as *mut opj_tcd_band_t;\n      precno = 0 as libc::c_int as OPJ_UINT32;\n      while precno < (*res).pw.wrapping_mul((*res).ph) {\n        let mut precinct: *mut opj_tcd_precinct_t =\n          &mut *(*band).precincts.offset(precno as isize) as *mut opj_tcd_precinct_t;\n        cblkno = 0 as libc::c_int as OPJ_UINT32;\n        while cblkno < (*precinct).cw.wrapping_mul((*precinct).ch) {\n          let mut cblk: *mut opj_tcd_cblk_dec_t =\n            &mut *(*precinct).cblks.dec.offset(cblkno as isize) as *mut opj_tcd_cblk_dec_t;\n          if !(*cblk).decoded_data.is_null() {\n            let mut x = ((*cblk).x0 - (*band).x0) as OPJ_UINT32;\n            let mut y = ((*cblk).y0 - (*band).y0) as OPJ_UINT32;\n            let mut cblk_w = ((*cblk).x1 - (*cblk).x0) as OPJ_UINT32;\n            let mut cblk_h = ((*cblk).y1 - (*cblk).y0) as OPJ_UINT32;\n            if (*band).bandno & 1 as libc::c_int as libc::c_uint != 0 {\n              let mut pres: *mut opj_tcd_resolution_t = &mut *(*tilec)\n                .resolutions\n                .offset(resno.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize)\n                as *mut opj_tcd_resolution_t;\n              x = (x as libc::c_uint).wrapping_add(((*pres).x1 - (*pres).x0) as OPJ_UINT32)\n                as OPJ_UINT32 as OPJ_UINT32\n            }\n            if (*band).bandno & 2 as libc::c_int as libc::c_uint != 0 {\n              let mut pres_0: *mut opj_tcd_resolution_t = &mut *(*tilec)\n                .resolutions\n                .offset(resno.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize)\n                as *mut opj_tcd_resolution_t;\n              y = (y as libc::c_uint).wrapping_add(((*pres_0).y1 - (*pres_0).y0) as OPJ_UINT32)\n                as OPJ_UINT32 as OPJ_UINT32\n            }\n            if opj_sparse_array_int32_write(\n              sa,\n              x,\n              y,\n              x.wrapping_add(cblk_w),\n              y.wrapping_add(cblk_h),\n              (*cblk).decoded_data,\n              1 as libc::c_int as OPJ_UINT32,\n              cblk_w,\n              1 as libc::c_int,\n            ) == 0\n            {\n              opj_sparse_array_int32_free(sa);\n              return 0 as *mut opj_sparse_array_int32_t;\n            }\n          }\n          cblkno = cblkno.wrapping_add(1)\n        }\n        precno = precno.wrapping_add(1)\n      }\n      bandno = bandno.wrapping_add(1)\n    }\n    resno = resno.wrapping_add(1)\n  }\n  return sa;\n"]], "pred": {"ppl": 1.2895082235336304, "ppl_lower": 1.3310497999191284, "ppl/lowercase_ppl": -1.1247027268466465, "ppl/zlib": 0.0003100742971012468, "Min_5.0% Prob": 3.752091653206769, "Min_10.0% Prob": 2.31596976518631, "Min_20.0% Prob": 1.2564939246421643, "Min_30.0% Prob": 0.8472152197751782, "Min_40.0% Prob": 0.6353476101197849, "Min_50.0% Prob": 0.5088810683136948, "Min_60.0% Prob": 0.42429980497620584}}
{"hexsha": "005643a0c40d69864a931e4b81517ee53d84e2cd", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn compact<TI1, TI2, O1, O2, E1, E2>(\n    old: &ModelImpl<TI1, O1>,\n) -> TractResult<ModelImpl<TI2, O2>>\nwhere\n    TractError: From<E1> + From<E2>,\n    TI1: Fact + Clone + 'static,\n    TI2: Fact + TryFrom<TI1, Error = E1> + Clone + 'static,\n    O1: Display + Debug + Clone + AsRef<dyn Op> + AsMut<dyn Op> + Clone + 'static,\n    O2: Display + TryFrom<O1, Error = E2> + Debug + AsRef<dyn Op> + AsMut<dyn Op> + Clone + 'static,\n{\n    let mut model = ModelImpl::default();\n    let mut map = HashMap::new();\n    for old_id in old.eval_order()? {\n        let old_node = &old.nodes()[old_id];\n        let facts = old_node\n            .outputs\n            .iter()\n            .map(|of| Ok(TI2::try_from(of.fact.clone())?))\n            .collect::<TractResult<TVec<_>>>()\n            .map_err(|e| format!(\"While translating {}: {:?}\", old_node, e))?;\n        let new_op = O2::try_from(old_node.op.clone())?;\n        let new_id = model.add_node(old_node.name.clone(), new_op, facts)?;\n        map.insert(old_id, new_id);\n        for ix in 0..old_node.outputs.len() {\n            if let Some(label) = old.outlet_label(OutletId::new(old_id, ix)) {\n                model.set_outlet_label(OutletId::new(new_id, ix), label.to_string());\n            }\n        }\n        if old.input_outlets()?.contains(&OutletId::new(old_node.id, 0)) {\n            continue;\n        }\n        for (ix, input) in old_node.inputs.iter().enumerate() {\n            model\n                .add_edge(OutletId::new(map[&input.node], input.slot), InletId::new(new_id, ix))?;\n        }\n        for input in old_node.control_inputs.iter() {\n            model.node_mut(new_id).control_inputs.push(map[input]);\n        }\n    }\n    for i in old.input_outlets()? {\n        if !map.contains_key(&i.node) {\n            let node = old.node(i.node);\n            debug!(\"Translate useless source {}\", node);\n            let new_id = model.add_node(\n                &*node.name,\n                O2::try_from(node.op.clone())?,\n                tvec!(TI2::try_from(node.outputs[0].fact.clone())?),\n            )?;\n            map.insert(i.node, new_id);\n        }\n    }\n    // maintaining order of i/o interface\n    model.inputs = old.input_outlets()?.iter().map(|i| OutletId::new(map[&i.node], 0)).collect();\n    model.outputs =\n        old.output_outlets()?.iter().map(|o| OutletId::new(map[&o.node], o.slot)).collect();\n    Ok(model)\n}", "item_id": 1, "repo": "pruthvikar/tract", "file": "core/src/model/compact.rs", "last_update_at": "2022-02-08T08:47:07+00:00", "question_id": "005643a0c40d69864a931e4b81517ee53d84e2cd_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn compact<TI1, TI2, O1, O2, E1, E2>(\n    old: &ModelImpl<TI1, O1>,\n) -> TractResult<ModelImpl<TI2, O2>>\nwhere\n    TractError: From<E1> + From<E2>,\n    TI1: Fact + Clone + 'static,\n    TI2: Fact + TryFrom<TI1, Error = E1> + Clone + 'static,\n    O1: Display + Debug + Clone + AsRef<dyn Op> + AsMut<dyn Op> + Clone + 'static,\n    O2: Display + TryFrom<O1, Error = E2> + Debug + AsRef<dyn Op> + AsMut<dyn Op> + Clone + 'static,\n{\n    let mut model = ModelImpl::default();\n    let mut map = HashMap::new();\n    for old_id in old.eval_order()? {\n        let old_node = &old.nodes()[old_id];\n        let facts = old_node\n            .outputs\n            .iter()\n            .map(|of| Ok(TI2::try_from(of.fact.clone())?))\n            .collect::<TractResult<TVec<_>>>()\n            .map_err(|e| format!(\"While translating {}: {:?}\", old_node, e))?;\n        let new_op = O2::try_from(old_node.op.clone())?;\n        let new_id = model.add_node(old_node.name.clone(), new_op, facts)?;\n        map.insert(old_id, new_id);\n        for ix in 0..old_node.outputs.len() {\n            if let Some(label) = old.outlet_label(OutletId::new(old_id, ix)) {\n                model.set_outlet_label(OutletId::new(new_id, ix), label.to_string());\n            }\n        }\n        if old.input_outlets()?.contains(&OutletId::new(old_node.id, 0)) {\n            continue;\n        }\n        for (ix, input) in old_node.inputs.iter().enumerate() {\n            model\n                .add_edge(OutletId::new(map[&input.node], input.slot), InletId::new(new_id, ix))?;\n        }\n        for input in old_node.control_inputs.iter() {\n            model.node_mut(new_id).control_inputs.push(map[input]);\n        }\n    }\n    for i in old.input_outlets()? {\n        if !map.contains_key(&i.node) {\n            let node = old.node(i.node);\n            debug!(\"Translate useless source {}\", node);\n            let new_id = model.add_node(\n                &*node.name,\n                O2::try_from(node.op.clone())?,\n                tvec!(TI2::try_from(node.outputs[0].fact.clone())?),\n            )?;\n            map.insert(i.node, new_id);\n        }\n    }\n    // maintaining order of i/o interface\n    model.inputs = old.input_outlets()?.iter().map(|i| OutletId::new(map[&i.node], 0)).collect();\n    model.outputs =\n        old.output_outlets()?.iter().map(|o| OutletId::new(map[&o.node], o.slot)).collect();\n    Ok(model)\n"]], "pred": {"ppl": 1.7811329364776611, "ppl_lower": 2.1769042015075684, "ppl/lowercase_ppl": -1.3476037376440069, "ppl/zlib": 0.0006471408553845156, "Min_5.0% Prob": 6.444414111070855, "Min_10.0% Prob": 4.501343717520264, "Min_20.0% Prob": 2.732435625688783, "Min_30.0% Prob": 1.8890351056483865, "Min_40.0% Prob": 1.436772692724422, "Min_50.0% Prob": 1.1520383688333515, "Min_60.0% Prob": 0.9621027342616119}}
{"hexsha": "0ec2a7973349ca2a2a756953a02067d05d6bcb1c", "ext": "rs", "lang": "Rust", "content": "pub fn decode_typedef_or_ref_token<T: Into<Token>>(token: T) -> DecodedToken {\n    let Token(raw_token) = token.into();\n    let tag = raw_token & 0b11;\n    let idx = raw_token >> 2;\n    DecodedToken(\n        match tag {\n            0 => TableKind::TypeDef.into(),\n            1 => TableKind::TypeRef.into(),\n            2 => TableKind::TypeSpec.into(),\n            _ => unreachable!(),\n        },\n        idx,\n    )\n}", "item_id": 1, "repo": "snikeguo/yacht", "file": "src/metadata/token.rs", "last_update_at": "2022-02-10T22:20:07+00:00", "question_id": "0ec2a7973349ca2a2a756953a02067d05d6bcb1c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn decode_typedef_or_ref_token<T: Into<Token>>(token: T) -> DecodedToken {\n    let Token(raw_token) = token.into();\n    let tag = raw_token & 0b11;\n    let idx = raw_token >> 2;\n    DecodedToken(\n        match tag {\n            0 => TableKind::TypeDef.into(),\n            1 => TableKind::TypeRef.into(),\n            2 => TableKind::TypeSpec.into(),\n            _ => unreachable!(),\n        },\n        idx,\n    )\n"]], "pred": {"ppl": 2.505303144454956, "ppl_lower": 3.5115981101989746, "ppl/lowercase_ppl": -1.3676588750620735, "ppl/zlib": 0.004480047526660948, "Min_5.0% Prob": 7.4809088706970215, "Min_10.0% Prob": 5.965331145695278, "Min_20.0% Prob": 3.8885779551097324, "Min_30.0% Prob": 2.874041428168615, "Min_40.0% Prob": 2.25798028920378, "Min_50.0% Prob": 1.8367733311440264, "Min_60.0% Prob": 1.5378168744389855}}
{"hexsha": "bbc5f888886d49b631e2442b748df5b774b59179", "ext": "rs", "lang": "Rust", "content": "async fn run_server(addr: SocketAddr, rx: watch::Receiver<Vec<u8>>) {\n    println!(\"Listening on http://{}\", addr);\n    // Bind the Hyper HTTP server to addr and start serving requests.\n    let serve_future = Server::bind(&addr)\n        .serve(make_service_fn(|_| {\n            // This function is invoked on every request.\n            // We need to clone rx to avoid moving it to this request.\n            let my_rx = rx.clone();\n            async {\n                // We need to clone my_rx because of the async block.\n                Ok::<_, hyper::Error>(service_fn(move |_req| serve_req(_req, my_rx.clone() )))\n            }\n        }));\n\n    if let Err(e) = serve_future.await {\n        eprintln!(\"Server error: {}\", e);\n    }\n}", "item_id": 1, "repo": "benbusby/raztot", "file": "src/main.rs", "last_update_at": "2022-03-10T19:48:33+00:00", "question_id": "bbc5f888886d49b631e2442b748df5b774b59179_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn run_server(addr: SocketAddr, rx: watch::Receiver<Vec<u8>>) {\n    println!(\"Listening on http://{}\", addr);\n    // Bind the Hyper HTTP server to addr and start serving requests.\n    let serve_future = Server::bind(&addr)\n        .serve(make_service_fn(|_| {\n            // This function is invoked on every request.\n            // We need to clone rx to avoid moving it to this request.\n            let my_rx = rx.clone();\n            async {\n                // We need to clone my_rx because of the async block.\n                Ok::<_, hyper::Error>(service_fn(move |_req| serve_req(_req, my_rx.clone() )))\n            }\n        }));\n    if let Err(e) = serve_future.await {\n        eprintln!(\"Server error: {}\", e);\n    }\n"]], "pred": {"ppl": 2.8817055225372314, "ppl_lower": 3.955307960510254, "ppl/lowercase_ppl": -1.299207711492917, "ppl/zlib": 0.00271380080562776, "Min_5.0% Prob": 7.64735779762268, "Min_10.0% Prob": 6.095595961525326, "Min_20.0% Prob": 4.206917443940806, "Min_30.0% Prob": 3.29112945869565, "Min_40.0% Prob": 2.6103555338327276, "Min_50.0% Prob": 2.107512467885735, "Min_60.0% Prob": 1.7689031173525624}}
{"hexsha": "476d6c1b2aa538eb3a9eb43d026985481306dedf", "ext": "rs", "lang": "Rust", "content": "pub fn parse(source_file: impl Into<SourceFile>) -> Result<Block, ParseError> {\n    let source_file = source_file.into();\n\n    let mut ctx = ParsingContext {\n        source_file: source_file.clone(),\n        regex_parser: regex_syntax::Parser::new(),\n    };\n\n    let mut pair = match grammar::parse(source_file.source_text(), Rule::program) {\n        Ok(pair) => pair,\n        Err(e) => {\n            let span = match e.location {\n                pest::error::InputLocation::Pos(offset) => source_file.slice(offset, offset).unwrap(),\n                pest::error::InputLocation::Span((start, end)) => source_file.slice(start, end).unwrap(),\n            };\n\n            return Err(ParseError::from_pest(span, e));\n        }\n    };\n\n    from_pair(pair.next().unwrap(), &mut ctx)\n}", "item_id": 0, "repo": "sagebind/riptide", "file": "syntax/src/parser.rs", "last_update_at": "2022-02-11T12:01:46+00:00", "question_id": "476d6c1b2aa538eb3a9eb43d026985481306dedf_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn parse(source_file: impl Into<SourceFile>) -> Result<Block, ParseError> {\n    let source_file = source_file.into();\n    let mut ctx = ParsingContext {\n        source_file: source_file.clone(),\n        regex_parser: regex_syntax::Parser::new(),\n    };\n    let mut pair = match grammar::parse(source_file.source_text(), Rule::program) {\n        Ok(pair) => pair,\n        Err(e) => {\n            let span = match e.location {\n                pest::error::InputLocation::Pos(offset) => source_file.slice(offset, offset).unwrap(),\n                pest::error::InputLocation::Span((start, end)) => source_file.slice(start, end).unwrap(),\n            };\n            return Err(ParseError::from_pest(span, e));\n        }\n    };\n    from_pair(pair.next().unwrap(), &mut ctx)\n"]], "pred": {"ppl": 2.3240721225738525, "ppl_lower": 3.128072738647461, "ppl/lowercase_ppl": -1.3522931945483043, "ppl/zlib": 0.002423335839993889, "Min_5.0% Prob": 7.227118968963623, "Min_10.0% Prob": 5.144447326660156, "Min_20.0% Prob": 3.527343343133512, "Min_30.0% Prob": 2.635911606360173, "Min_40.0% Prob": 2.0681931070335535, "Min_50.0% Prob": 1.680168473655763, "Min_60.0% Prob": 1.4076149413308157}}
{"hexsha": "300db69bf5f13042adb173fa2905733b51d4a5f0", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn input_value_definition(p: &mut Parser, is_input: bool) {\n    if let Some(TokenKind::Name | TokenKind::StringValue) = p.peek() {\n        let guard = p.start_node(SyntaxKind::INPUT_VALUE_DEFINITION);\n\n        if let Some(TokenKind::StringValue) = p.peek() {\n            description::description(p);\n        }\n\n        name::name(p);\n\n        if let Some(T![:]) = p.peek() {\n            p.bump(S![:]);\n            match p.peek() {\n                Some(TokenKind::Name) | Some(T!['[']) => {\n                    ty::ty(p);\n                    if let Some(T![=]) = p.peek() {\n                        value::default_value(p);\n                    }\n\n                    if let Some(T![@]) = p.peek() {\n                        directive::directives(p);\n                    }\n\n                    if p.peek().is_some() {\n                        guard.finish_node();\n                        return input_value_definition(p, true);\n                    }\n                }\n                _ => p.err(\"expected a Type\"),\n            }\n        } else {\n            p.err(\"expected a Name\");\n        }\n    }\n    // TODO @lrlna: this can be simplified a little bit, and follow the pattern of FieldDefinition\n    if !is_input {\n        p.err(\"expected an Input Value Definition\");\n    }\n}", "item_id": 3, "repo": "MidasLamb/apollo-rs", "file": "crates/apollo-parser/src/parser/grammar/input.rs", "last_update_at": "2022-03-30T17:25:13+00:00", "question_id": "300db69bf5f13042adb173fa2905733b51d4a5f0_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn input_value_definition(p: &mut Parser, is_input: bool) {\n    if let Some(TokenKind::Name | TokenKind::StringValue) = p.peek() {\n        let guard = p.start_node(SyntaxKind::INPUT_VALUE_DEFINITION);\n        if let Some(TokenKind::StringValue) = p.peek() {\n            description::description(p);\n        }\n        name::name(p);\n        if let Some(T![:]) = p.peek() {\n            p.bump(S![:]);\n            match p.peek() {\n                Some(TokenKind::Name) | Some(T!['[']) => {\n                    ty::ty(p);\n                    if let Some(T![=]) = p.peek() {\n                        value::default_value(p);\n                    }\n                    if let Some(T![@]) = p.peek() {\n                        directive::directives(p);\n                    }\n                    if p.peek().is_some() {\n                        guard.finish_node();\n                        return input_value_definition(p, true);\n                    }\n                }\n                _ => p.err(\"expected a Type\"),\n            }\n        } else {\n            p.err(\"expected a Name\");\n        }\n    }\n    // TODO @lrlna: this can be simplified a little bit, and follow the pattern of FieldDefinition\n    if !is_input {\n        p.err(\"expected an Input Value Definition\");\n    }\n"]], "pred": {"ppl": 2.1695501804351807, "ppl_lower": 2.64996337890625, "ppl/lowercase_ppl": -1.2582580203005151, "ppl/zlib": 0.0016585007621900743, "Min_5.0% Prob": 6.481553872426351, "Min_10.0% Prob": 4.932728342107825, "Min_20.0% Prob": 3.3429878044128416, "Min_30.0% Prob": 2.463140802990113, "Min_40.0% Prob": 1.9096404368678728, "Min_50.0% Prob": 1.5432137829707342, "Min_60.0% Prob": 1.292712136482199}}
{"hexsha": "586d2ffbdf7dfe3e1a0cfcee430bc0202124cbf5", "ext": "rs", "lang": "Rust", "content": "pub fn parse_block_size(s: &str) -> Result<usize> {\n    let block_size_regex = Regex::new(r\"^(?i)(\\d+) *(([km])b?)?$\").unwrap();\n    let captures = block_size_regex.captures(s);\n\n    match captures {\n        Some(groups) => {\n            let units = groups[1].parse::<usize>().context(\"Not a number.\")?;\n            let unit_size = match groups.get(3).map(|m| m.as_str().to_uppercase()) {\n                Some(ref u) if u == \"K\" => 1024,\n                Some(ref u) if u == \"M\" => 1024 * 1024,\n                _ => 1,\n            };\n\n            let bytes_length = (units * unit_size) as usize;\n            if bytes_length & (bytes_length - 1) == 0 {\n                Ok((units * unit_size) as usize)\n            } else {\n                Err(anyhow!(\"Should be a power of two.\"))\n            }\n        }\n        _ => Err(anyhow!(\n            \"Use a number of bytes with optional scale (e.g. 4096, 128k or 2M).\"\n        )),\n    }\n}", "item_id": 0, "repo": "Kostassoid/lethe", "file": "src/ui/args.rs", "last_update_at": "2022-03-30T16:14:14+00:00", "question_id": "586d2ffbdf7dfe3e1a0cfcee430bc0202124cbf5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn parse_block_size(s: &str) -> Result<usize> {\n    let block_size_regex = Regex::new(r\"^(?i)(\\d+) *(([km])b?)?$\").unwrap();\n    let captures = block_size_regex.captures(s);\n    match captures {\n        Some(groups) => {\n            let units = groups[1].parse::<usize>().context(\"Not a number.\")?;\n            let unit_size = match groups.get(3).map(|m| m.as_str().to_uppercase()) {\n                Some(ref u) if u == \"K\" => 1024,\n                Some(ref u) if u == \"M\" => 1024 * 1024,\n                _ => 1,\n            };\n            let bytes_length = (units * unit_size) as usize;\n            if bytes_length & (bytes_length - 1) == 0 {\n                Ok((units * unit_size) as usize)\n            } else {\n                Err(anyhow!(\"Should be a power of two.\"))\n            }\n        }\n        _ => Err(anyhow!(\n            \"Use a number of bytes with optional scale (e.g. 4096, 128k or 2M).\"\n        )),\n    }\n"]], "pred": {"ppl": 2.2032368183135986, "ppl_lower": 2.54563570022583, "ppl/lowercase_ppl": -1.182868467865533, "ppl/zlib": 0.0018034875802337468, "Min_5.0% Prob": 6.265080451965332, "Min_10.0% Prob": 4.827037543058395, "Min_20.0% Prob": 3.344209280380836, "Min_30.0% Prob": 2.4814025780984332, "Min_40.0% Prob": 1.9450691892550542, "Min_50.0% Prob": 1.5744417220171243, "Min_60.0% Prob": 1.3158023280319662}}
{"hexsha": "d38394ef5faeccf27b5e0fdae94536904b045835", "ext": "rs", "lang": "Rust", "content": "pub fn center(txt: &str, space: usize) -> Option<String> {\n    // Determine the width of the characters when displayed\n    let len = txt.width();\n    // Return None if there is not enough space to fit the string\n    if len > space {\n        return None;\n    }\n    // Work out total space needed on each side\n    let left_over = space - len;\n    let each = left_over / 2;\n    // Pad the left hand side\n    let left_pad = \" \".repeat(each);\n    // Pad the right hand side\n    let right_pad = \" \".repeat(left_over - each);\n    // Format and return\n    Some(format!(\"{}{}{}\", left_pad, txt, right_pad))\n}", "item_id": 0, "repo": "curlpipe/alinio", "file": "src/align.rs", "last_update_at": "2022-02-21T08:21:52+00:00", "question_id": "d38394ef5faeccf27b5e0fdae94536904b045835_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn center(txt: &str, space: usize) -> Option<String> {\n    // Determine the width of the characters when displayed\n    let len = txt.width();\n    // Return None if there is not enough space to fit the string\n    if len > space {\n        return None;\n    }\n    // Work out total space needed on each side\n    let left_over = space - len;\n    let each = left_over / 2;\n    // Pad the left hand side\n    let left_pad = \" \".repeat(each);\n    // Pad the right hand side\n    let right_pad = \" \".repeat(left_over - each);\n    // Format and return\n    Some(format!(\"{}{}{}\", left_pad, txt, right_pad))\n"]], "pred": {"ppl": 2.732684850692749, "ppl_lower": 2.9655582904815674, "ppl/lowercase_ppl": -1.0813508150856102, "ppl/zlib": 0.003232426327033342, "Min_5.0% Prob": 8.240685674879286, "Min_10.0% Prob": 6.339489115609063, "Min_20.0% Prob": 4.25122716029485, "Min_30.0% Prob": 3.153830134206348, "Min_40.0% Prob": 2.4514360543754368, "Min_50.0% Prob": 1.9890282611880037, "Min_60.0% Prob": 1.6679647158210475}}
{"hexsha": "2c041ebea8f5dc28e70bc26be459e8a058631baf", "ext": "rs", "lang": "Rust", "content": "fn new_user(cred:Form<Credentials>\n            ,sess:State<Session>\n            ,mut cookies:Cookies\n            )->Html<String>{\n    let cred = cred.into_inner();\n    let sess = sess.inner();\n    match sess.ub.add_user(&cred.username, &cred.password) {\n        Ok(_)=>{\n            let n = sess.add_session(cred.username.clone());\n            cookies.add(Cookie::new(\"session\",n.to_string()));\n            pages::home_page(&cred.username,0)\n        },\n        Err(e)=>pages::err_page(e,\"/\"),\n    }\n}", "item_id": 0, "repo": "PacktPublishing/-Learn-Rust-in-7-Days", "file": "day7/web_bank/src/main.rs", "last_update_at": "2022-02-14T17:00:17+00:00", "question_id": "2c041ebea8f5dc28e70bc26be459e8a058631baf_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn new_user(cred:Form<Credentials>\n            ,sess:State<Session>\n            ,mut cookies:Cookies\n            )->Html<String>{\n    let cred = cred.into_inner();\n    let sess = sess.inner();\n    match sess.ub.add_user(&cred.username, &cred.password) {\n        Ok(_)=>{\n            let n = sess.add_session(cred.username.clone());\n            cookies.add(Cookie::new(\"session\",n.to_string()));\n            pages::home_page(&cred.username,0)\n        },\n        Err(e)=>pages::err_page(e,\"/\"),\n    }\n"]], "pred": {"ppl": 3.711611747741699, "ppl_lower": 4.451132774353027, "ppl/lowercase_ppl": -1.138541429446393, "ppl/zlib": 0.005044100829361745, "Min_5.0% Prob": 8.834157807486397, "Min_10.0% Prob": 7.045366350809733, "Min_20.0% Prob": 4.925429374940934, "Min_30.0% Prob": 3.837916166224378, "Min_40.0% Prob": 3.0616172192588684, "Min_50.0% Prob": 2.540411130159716, "Min_60.0% Prob": 2.17446907229246}}
{"hexsha": "c70c78342b41a82ac5b009713c3ea05562899db1", "ext": "rs", "lang": "Rust", "content": "fn dfs(\n    graph: &Graph<Edge>,\n    u: usize,\n    l: &mut [usize],\n    r: &mut [usize],\n    p: &mut [usize],\n    time: &mut usize,\n) {\n    *time += 1;\n    l[u] = *time;\n\n    for AdjTo{v, ..} in graph.adj_list(u) {\n        if l[v] == 0 {\n            p[v] = l[u];\n            dfs(graph, v, l, r, p, time);\n        }\n    }\n\n    r[u] = *time;\n}", "item_id": 0, "repo": "kena0ki/rustrithm", "file": "tests/codeforces343d.rs", "last_update_at": "2022-03-13T09:43:52+00:00", "question_id": "c70c78342b41a82ac5b009713c3ea05562899db1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn dfs(\n    graph: &Graph<Edge>,\n    u: usize,\n    l: &mut [usize],\n    r: &mut [usize],\n    p: &mut [usize],\n    time: &mut usize,\n) {\n    *time += 1;\n    l[u] = *time;\n    for AdjTo{v, ..} in graph.adj_list(u) {\n        if l[v] == 0 {\n            p[v] = l[u];\n            dfs(graph, v, l, r, p, time);\n        }\n    }\n    r[u] = *time;\n"]], "pred": {"ppl": 2.113943576812744, "ppl_lower": 2.4222609996795654, "ppl/lowercase_ppl": -1.1818786444934881, "ppl/zlib": 0.004068234765448061, "Min_5.0% Prob": 7.283180117607117, "Min_10.0% Prob": 5.373321920633316, "Min_20.0% Prob": 3.4057386312633753, "Min_30.0% Prob": 2.4203522888322673, "Min_40.0% Prob": 1.8563258907524869, "Min_50.0% Prob": 1.492743232473731, "Min_60.0% Prob": 1.2463381119208254}}
{"hexsha": "856aebc5a75a496a9188c61e4f7a7d5a3c49b82e", "ext": "rs", "lang": "Rust", "content": "pub fn from(path: &Path) -> Result<StorageSet<(Vec<PackStore<MmapPackReader>>, LooseStore)>, std::io::Error> {\n    let packfiles = packfiles_from_path(path)?;\n    let loose = loose_from_path(path)?;\n\n    Ok(StorageSet::new((\n        packfiles,\n        loose\n    )))\n}", "item_id": 0, "repo": "chrisdickinson/git-rs", "file": "src/stores/fs.rs", "last_update_at": "2022-03-10T17:41:14+00:00", "question_id": "856aebc5a75a496a9188c61e4f7a7d5a3c49b82e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn from(path: &Path) -> Result<StorageSet<(Vec<PackStore<MmapPackReader>>, LooseStore)>, std::io::Error> {\n    let packfiles = packfiles_from_path(path)?;\n    let loose = loose_from_path(path)?;\n    Ok(StorageSet::new((\n        packfiles,\n        loose\n    )))\n"]], "pred": {"ppl": 5.372730731964111, "ppl_lower": 7.764876842498779, "ppl/lowercase_ppl": -1.219036668280494, "ppl/zlib": 0.00977521102014339, "Min_5.0% Prob": 9.545319080352783, "Min_10.0% Prob": 8.280294524298775, "Min_20.0% Prob": 6.388628562291463, "Min_30.0% Prob": 5.040886931949192, "Min_40.0% Prob": 4.045157510373327, "Min_50.0% Prob": 3.285081431917522, "Min_60.0% Prob": 2.7876536068591204}}
{"hexsha": "8ed9f34a8638853e7c2b0b1a1b19ce381ebf7f15", "ext": "rs", "lang": "Rust", "content": "pub fn write_initializer(tmd: &mut TableMetaData) {\n    write_default_initializer(tmd.line_writer, &tmd.swift_properties.iter().collect());\n    write_row_initializer_with_starting_index(tmd);\n    write_row_initializer_protocol(tmd);\n}", "item_id": 0, "repo": "Jasperav/GRDB-ORM", "file": "Parser/src/swift_struct/initializer.rs", "last_update_at": "2022-01-07T01:30:53+00:00", "question_id": "8ed9f34a8638853e7c2b0b1a1b19ce381ebf7f15_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn write_initializer(tmd: &mut TableMetaData) {\n    write_default_initializer(tmd.line_writer, &tmd.swift_properties.iter().collect());\n    write_row_initializer_with_starting_index(tmd);\n    write_row_initializer_protocol(tmd);\n"]], "pred": {"ppl": 7.831167697906494, "ppl_lower": 9.714266777038574, "ppl/lowercase_ppl": -1.1046998488210014, "ppl/zlib": 0.013906159663254843, "Min_5.0% Prob": 10.011653900146484, "Min_10.0% Prob": 8.900814473628998, "Min_20.0% Prob": 7.19258514046669, "Min_30.0% Prob": 5.784880538781484, "Min_40.0% Prob": 4.731025069952011, "Min_50.0% Prob": 3.963442197442055, "Min_60.0% Prob": 3.3817031805713973}}
{"hexsha": "2d49d06763f3ae287a674af43441b543bcbfa1e2", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout_lysp_node_choice__bindgen_ty_1() {\n    assert_eq!(\n        ::std::mem::size_of::<lysp_node_choice__bindgen_ty_1>(),\n        64usize,\n        concat!(\"Size of: \", stringify!(lysp_node_choice__bindgen_ty_1))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<lysp_node_choice__bindgen_ty_1>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(lysp_node_choice__bindgen_ty_1))\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<lysp_node_choice__bindgen_ty_1>())).node\n                as *const _ as usize\n        },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(lysp_node_choice__bindgen_ty_1),\n            \"::\",\n            stringify!(node)\n        )\n    );\n}", "item_id": 77, "repo": "ishidawataru/yang2-rs", "file": "libyang2-sys/pre-generated-bindings/libyang2-0aa1f7090ca814f6df6131a6a7ab77db83f0bc57.rs", "last_update_at": "2022-03-06T01:38:29+00:00", "question_id": "2d49d06763f3ae287a674af43441b543bcbfa1e2_77", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bindgen_test_layout_lysp_node_choice__bindgen_ty_1() {\n    assert_eq!(\n        ::std::mem::size_of::<lysp_node_choice__bindgen_ty_1>(),\n        64usize,\n        concat!(\"Size of: \", stringify!(lysp_node_choice__bindgen_ty_1))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<lysp_node_choice__bindgen_ty_1>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(lysp_node_choice__bindgen_ty_1))\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<lysp_node_choice__bindgen_ty_1>())).node\n                as *const _ as usize\n        },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(lysp_node_choice__bindgen_ty_1),\n            \"::\",\n            stringify!(node)\n        )\n    );\n"]], "pred": {"ppl": 1.3548884391784668, "ppl_lower": 1.4169520139694214, "ppl/lowercase_ppl": -1.1474684163420557, "ppl/zlib": 0.0011910553656177335, "Min_5.0% Prob": 5.626287020169771, "Min_10.0% Prob": 3.110639185286485, "Min_20.0% Prob": 1.541085187899265, "Min_30.0% Prob": 1.021203009095916, "Min_40.0% Prob": 0.7635469041861568, "Min_50.0% Prob": 0.6097025679964848, "Min_60.0% Prob": 0.5074556203269804}}
{"hexsha": "31562cb189e7b55343443e0c48d47187ea7d4bf2", "ext": "rs", "lang": "Rust", "content": "fn get_thread_with_perms() -> impl thorn::AnyQuery {\n    use schema::*;\n    use thorn::*;\n\n    tables! {\n        struct AggPerm {\n            Perms: AggRoomPerms::Perms,\n        }\n    }\n\n    const READ_MESSAGES: i64 = Permission::PACKED_READ_MESSAGE_HISTORY as i64;\n\n    let user_id_var = Var::at(Users::Id, 1);\n    let room_id_var = Var::at(Rooms::Id, 2);\n    let thread_id_var = Var::at(Threads::Id, 3);\n\n    let permissions = AggPerm::as_query(\n        Query::select()\n            .expr(AggRoomPerms::Perms.alias_to(AggPerm::Perms))\n            .from_table::<AggRoomPerms>()\n            .and_where(AggRoomPerms::UserId.equals(user_id_var.clone()))\n            .and_where(AggRoomPerms::RoomId.equals(room_id_var.clone())),\n    );\n\n    Query::with()\n        .with(permissions)\n        .select()\n        .from(Threads::inner_join_table::<AggMessages>().on(AggMessages::MsgId.equals(Threads::ParentId)))\n        .and_where(Threads::Id.equals(thread_id_var))\n        .and_where(\n            AggPerm::Perms\n                .bit_and(READ_MESSAGES.lit())\n                .equals(READ_MESSAGES.lit()),\n        )\n        .cols(Columns::default())\n        .cols(ThreadColumns::default())\n}", "item_id": 2, "repo": "Lantern-chat/server", "file": "crates/server/src/ctrl/room/threads/get.rs", "last_update_at": "2022-01-29T10:11:21+00:00", "question_id": "31562cb189e7b55343443e0c48d47187ea7d4bf2_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_thread_with_perms() -> impl thorn::AnyQuery {\n    use schema::*;\n    use thorn::*;\n    tables! {\n        struct AggPerm {\n            Perms: AggRoomPerms::Perms,\n        }\n    }\n    const READ_MESSAGES: i64 = Permission::PACKED_READ_MESSAGE_HISTORY as i64;\n    let user_id_var = Var::at(Users::Id, 1);\n    let room_id_var = Var::at(Rooms::Id, 2);\n    let thread_id_var = Var::at(Threads::Id, 3);\n    let permissions = AggPerm::as_query(\n        Query::select()\n            .expr(AggRoomPerms::Perms.alias_to(AggPerm::Perms))\n            .from_table::<AggRoomPerms>()\n            .and_where(AggRoomPerms::UserId.equals(user_id_var.clone()))\n            .and_where(AggRoomPerms::RoomId.equals(room_id_var.clone())),\n    );\n    Query::with()\n        .with(permissions)\n        .select()\n        .from(Threads::inner_join_table::<AggMessages>().on(AggMessages::MsgId.equals(Threads::ParentId)))\n        .and_where(Threads::Id.equals(thread_id_var))\n        .and_where(\n            AggPerm::Perms\n                .bit_and(READ_MESSAGES.lit())\n                .equals(READ_MESSAGES.lit()),\n        )\n        .cols(Columns::default())\n        .cols(ThreadColumns::default())\n"]], "pred": {"ppl": 2.4703598022460938, "ppl_lower": 3.052615165710449, "ppl/lowercase_ppl": -1.2340151646524806, "ppl/zlib": 0.001920093012647011, "Min_5.0% Prob": 7.462929771060035, "Min_10.0% Prob": 5.893822065619535, "Min_20.0% Prob": 3.949133294959401, "Min_30.0% Prob": 2.872116265832916, "Min_40.0% Prob": 2.226584640196982, "Min_50.0% Prob": 1.806112907982121, "Min_60.0% Prob": 1.5100703714343515}}
{"hexsha": "772e287872dbb47fac16dfc09bdd21146efdf8e3", "ext": "rs", "lang": "Rust", "content": "pub fn parse_chart(g: &Grammar, input: &[&str]) -> Chart {\n  let mut chart = Chart::new(input.len() + 1);\n\n  for rule in g.rules.get(&g.start).expect(\"grammar missing start rules\") {\n    chart.add(0, State::new(LR0::new(&rule), 0));\n  }\n\n  for k in 0..chart.len() {\n    // need to use while loop because the number of states at k can expand during the loop\n    let mut idx = 0;\n    while idx < chart.len_at(k) {\n      let state = chart.get_state(k, idx);\n      idx += 1;\n\n      if let Some(production) = state.lr0.next_production() {\n        if production.is_nonterminal() {\n          predictor(g, &mut chart, k, &state);\n        } else {\n          scanner(&mut chart, k, &state, input);\n        }\n      } else {\n        completer(&mut chart, k, &state);\n      }\n    }\n  }\n\n  chart\n}", "item_id": 0, "repo": "vgel/treebender", "file": "src/earley.rs", "last_update_at": "2022-02-25T01:33:06+00:00", "question_id": "772e287872dbb47fac16dfc09bdd21146efdf8e3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn parse_chart(g: &Grammar, input: &[&str]) -> Chart {\n  let mut chart = Chart::new(input.len() + 1);\n  for rule in g.rules.get(&g.start).expect(\"grammar missing start rules\") {\n    chart.add(0, State::new(LR0::new(&rule), 0));\n  }\n  for k in 0..chart.len() {\n    // need to use while loop because the number of states at k can expand during the loop\n    let mut idx = 0;\n    while idx < chart.len_at(k) {\n      let state = chart.get_state(k, idx);\n      idx += 1;\n      if let Some(production) = state.lr0.next_production() {\n        if production.is_nonterminal() {\n          predictor(g, &mut chart, k, &state);\n        } else {\n          scanner(&mut chart, k, &state, input);\n        }\n      } else {\n        completer(&mut chart, k, &state);\n      }\n    }\n  }\n  chart\n"]], "pred": {"ppl": 2.96657395362854, "ppl_lower": 3.1968674659729004, "ppl/lowercase_ppl": -1.0687540422966901, "ppl/zlib": 0.002732180241195372, "Min_5.0% Prob": 7.976796883803147, "Min_10.0% Prob": 5.975308515407421, "Min_20.0% Prob": 4.290164598712215, "Min_30.0% Prob": 3.2509654651327833, "Min_40.0% Prob": 2.6103329073398487, "Min_50.0% Prob": 2.13568993652389, "Min_60.0% Prob": 1.8055511714390866}}
{"hexsha": "39f80b5501609cc74772384959a1c94bee60e925", "ext": "rs", "lang": "Rust", "content": "pub fn lower_cfg(\n    bump: &Bump,\n    b: &mut FunctionBuilder,\n    pat: &PatternContainer,\n    provider: &ErlangPatternProvider,\n    cfg: &PatternCfg<ErlangPatternProvider>,\n    clauses: &[PatternClause],\n    destinations: &DecisionTreeDestinations,\n) -> Block {\n    assert!(destinations.guards.len() == destinations.bodies.len());\n\n    let entry_kind = &cfg.graph[cfg.entry];\n    assert!(*entry_kind == CfgNodeKind::Root);\n\n    let mut ctx = LowerCtx {\n        provider,\n        mapping: BFnvHashMap::with_hasher_in(Default::default(), &bump),\n        destinations,\n    };\n\n    let entry_block = b.block_insert();\n    let entry_arg = b.block_arg_insert(entry_block);\n\n    let mut block = entry_block;\n\n    // First node is a dummy root node\n    let value_list_node = {\n        let mut edges = cfg.graph.edges(cfg.entry);\n        let edge = edges.next().unwrap();\n        assert!(edges.next().is_none());\n\n        let edge_weight = edge.weight();\n        assert!(edge_weight.kind == Some(NodeKind::Wildcard));\n        assert!(edge_weight.variable_binds.len() == 1);\n\n        ctx.bind(edge_weight.variable_binds[0], entry_arg);\n\n        edge.target()\n    };\n\n    let outgoing: Vec<_> = cfg.graph.edges(value_list_node).collect();\n    if outgoing.len() == 2 {\n        // This will always be a ValueList and a Wildcard\n        let val_list_target = outgoing\n            .iter()\n            .find(|o| o.weight().kind == Some(NodeKind::ValueList))\n            .unwrap();\n        assert!(outgoing\n            .iter()\n            .find(|o| o.weight().kind == Some(NodeKind::Wildcard))\n            .is_some());\n\n        if let CfgNodeKind::Match(var) = cfg.graph[value_list_node] {\n            let var_list_len = val_list_target.weight().variable_binds.len();\n            block = b.op_unpack_value_list(block, ctx.get_var_value(var), var_list_len);\n        } else {\n            unreachable!()\n        }\n\n        // Insert variable binds for all value list elements\n        for (idx, var) in val_list_target.weight().variable_binds.iter().enumerate() {\n            let val = b.fun().block_args(block)[idx];\n            ctx.bind(*var, val);\n        }\n\n        lower_cfg_rec(\n            bump,\n            b,\n            pat,\n            &mut ctx,\n            cfg,\n            clauses,\n            block,\n            val_list_target.target(),\n        );\n    } else if outgoing.len() == 0 {\n        // Fail immediately\n        b.op_call_flow(block, destinations.fail, &[]);\n    } else {\n        unreachable!();\n    }\n\n    entry_block\n}", "item_id": 0, "repo": "eirproject/eir", "file": "libeir_passes/src/compile_pattern/lower_cfg.rs", "last_update_at": "2022-03-28T19:08:38+00:00", "question_id": "39f80b5501609cc74772384959a1c94bee60e925_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn lower_cfg(\n    bump: &Bump,\n    b: &mut FunctionBuilder,\n    pat: &PatternContainer,\n    provider: &ErlangPatternProvider,\n    cfg: &PatternCfg<ErlangPatternProvider>,\n    clauses: &[PatternClause],\n    destinations: &DecisionTreeDestinations,\n) -> Block {\n    assert!(destinations.guards.len() == destinations.bodies.len());\n    let entry_kind = &cfg.graph[cfg.entry];\n    assert!(*entry_kind == CfgNodeKind::Root);\n    let mut ctx = LowerCtx {\n        provider,\n        mapping: BFnvHashMap::with_hasher_in(Default::default(), &bump),\n        destinations,\n    };\n    let entry_block = b.block_insert();\n    let entry_arg = b.block_arg_insert(entry_block);\n    let mut block = entry_block;\n    // First node is a dummy root node\n    let value_list_node = {\n        let mut edges = cfg.graph.edges(cfg.entry);\n        let edge = edges.next().unwrap();\n        assert!(edges.next().is_none());\n        let edge_weight = edge.weight();\n        assert!(edge_weight.kind == Some(NodeKind::Wildcard));\n        assert!(edge_weight.variable_binds.len() == 1);\n        ctx.bind(edge_weight.variable_binds[0], entry_arg);\n        edge.target()\n    };\n    let outgoing: Vec<_> = cfg.graph.edges(value_list_node).collect();\n    if outgoing.len() == 2 {\n        // This will always be a ValueList and a Wildcard\n        let val_list_target = outgoing\n            .iter()\n            .find(|o| o.weight().kind == Some(NodeKind::ValueList))\n            .unwrap();\n        assert!(outgoing\n            .iter()\n            .find(|o| o.weight().kind == Some(NodeKind::Wildcard))\n            .is_some());\n        if let CfgNodeKind::Match(var) = cfg.graph[value_list_node] {\n            let var_list_len = val_list_target.weight().variable_binds.len();\n            block = b.op_unpack_value_list(block, ctx.get_var_value(var), var_list_len);\n        } else {\n            unreachable!()\n        }\n        // Insert variable binds for all value list elements\n        for (idx, var) in val_list_target.weight().variable_binds.iter().enumerate() {\n            let val = b.fun().block_args(block)[idx];\n            ctx.bind(*var, val);\n        }\n        lower_cfg_rec(\n            bump,\n            b,\n            pat,\n            &mut ctx,\n            cfg,\n            clauses,\n            block,\n            val_list_target.target(),\n        );\n    } else if outgoing.len() == 0 {\n        // Fail immediately\n        b.op_call_flow(block, destinations.fail, &[]);\n    } else {\n        unreachable!();\n    }\n    entry_block\n"]], "pred": {"ppl": 2.656146764755249, "ppl_lower": 2.991175413131714, "ppl/lowercase_ppl": -1.1216017976500958, "ppl/zlib": 0.0010902639373906327, "Min_5.0% Prob": 7.549123537540436, "Min_10.0% Prob": 5.850438293814659, "Min_20.0% Prob": 4.06449663862586, "Min_30.0% Prob": 3.026229785685717, "Min_40.0% Prob": 2.383541073847411, "Min_50.0% Prob": 1.9398199823587687, "Min_60.0% Prob": 1.627012442577151}}
{"hexsha": "9da3e13f17677b46f040f1db0b526ffa66f7b31b", "ext": "rs", "lang": "Rust", "content": "pub fn serialize_structure_crate_model_port_range_from_to(\n    object: &mut aws_smithy_json::serialize::JsonObjectWriter,\n    input: &crate::model::PortRangeFromTo,\n) -> Result<(), aws_smithy_http::operation::SerializationError> {\n    if input.from != 0 {\n        object.key(\"From\").number(\n            #[allow(clippy::useless_conversion)]\n            aws_smithy_types::Number::NegInt((input.from).into()),\n        );\n    }\n    if input.to != 0 {\n        object.key(\"To\").number(\n            #[allow(clippy::useless_conversion)]\n            aws_smithy_types::Number::NegInt((input.to).into()),\n        );\n    }\n    Ok(())\n}", "item_id": 254, "repo": "jdisanti/aws-sdk-rust", "file": "sdk/securityhub/src/json_ser.rs", "last_update_at": "2022-03-02T02:19:58+00:00", "question_id": "9da3e13f17677b46f040f1db0b526ffa66f7b31b_254", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn serialize_structure_crate_model_port_range_from_to(\n    object: &mut aws_smithy_json::serialize::JsonObjectWriter,\n    input: &crate::model::PortRangeFromTo,\n) -> Result<(), aws_smithy_http::operation::SerializationError> {\n    if input.from != 0 {\n        object.key(\"From\").number(\n            #[allow(clippy::useless_conversion)]\n            aws_smithy_types::Number::NegInt((input.from).into()),\n        );\n    }\n    if input.to != 0 {\n        object.key(\"To\").number(\n            #[allow(clippy::useless_conversion)]\n            aws_smithy_types::Number::NegInt((input.to).into()),\n        );\n    }\n    Ok(())\n"]], "pred": {"ppl": 2.9265317916870117, "ppl_lower": 3.7127161026000977, "ppl/lowercase_ppl": -1.221588454923387, "ppl/zlib": 0.0036774590173698357, "Min_5.0% Prob": 8.816912364959716, "Min_10.0% Prob": 7.230316495895385, "Min_20.0% Prob": 4.962498961425409, "Min_30.0% Prob": 3.51823254842912, "Min_40.0% Prob": 2.6986762870375705, "Min_50.0% Prob": 2.15683432753442, "Min_60.0% Prob": 1.7923414708122671}}
{"hexsha": "0a5d50245436f77e3cb10a335d220ec877d28b1b", "ext": "rs", "lang": "Rust", "content": "fn should_fail_if_insufficient_receivers() {\n    let max_corrupt_receivers = NumberOfNodes::new(1);\n    let receivers = set_of(&[node_id(NODE_1), node_id(NODE_2)]);\n    let threshold = 2;\n    let config_data = NiDkgConfigData {\n        max_corrupt_receivers,\n        receivers,\n        threshold: NumberOfNodes::new(threshold),\n        ..valid_dkg_config_data()\n    };\n\n    let result = NiDkgConfig::new(config_data);\n\n    assert_eq!(\n        result.unwrap_err(),\n        NiDkgConfigValidationError::InsufficientReceivers {\n            receiver_count: NumberOfNodes::new(2),\n            max_corrupt_receivers,\n            threshold: dkg_threshold(threshold),\n        }\n    );\n}", "item_id": 3, "repo": "3cL1p5e7/ic", "file": "rs/types/types/src/crypto/threshold_sig/ni_dkg/config/tests.rs", "last_update_at": "2022-03-31T11:40:24+00:00", "question_id": "0a5d50245436f77e3cb10a335d220ec877d28b1b_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn should_fail_if_insufficient_receivers() {\n    let max_corrupt_receivers = NumberOfNodes::new(1);\n    let receivers = set_of(&[node_id(NODE_1), node_id(NODE_2)]);\n    let threshold = 2;\n    let config_data = NiDkgConfigData {\n        max_corrupt_receivers,\n        receivers,\n        threshold: NumberOfNodes::new(threshold),\n        ..valid_dkg_config_data()\n    };\n    let result = NiDkgConfig::new(config_data);\n    assert_eq!(\n        result.unwrap_err(),\n        NiDkgConfigValidationError::InsufficientReceivers {\n            receiver_count: NumberOfNodes::new(2),\n            max_corrupt_receivers,\n            threshold: dkg_threshold(threshold),\n        }\n    );\n"]], "pred": {"ppl": 2.635556936264038, "ppl_lower": 3.804211139678955, "ppl/lowercase_ppl": -1.3787186072061381, "ppl/zlib": 0.0033649115301067852, "Min_5.0% Prob": 8.246883609078147, "Min_10.0% Prob": 6.3631155057386914, "Min_20.0% Prob": 4.319094862450253, "Min_30.0% Prob": 3.100014715032144, "Min_40.0% Prob": 2.388485984030095, "Min_50.0% Prob": 1.929192592203617, "Min_60.0% Prob": 1.6130637188696049}}
{"hexsha": "3039187fc8301af3e6678fad9c3dedec7f2aa613", "ext": "rs", "lang": "Rust", "content": "pub fn deser_operation_crate_operation_update_ip_set(\n    value: &[u8],\n    mut builder: crate::output::update_ip_set_output::Builder,\n) -> Result<crate::output::update_ip_set_output::Builder, aws_smithy_json::deserialize::Error> {\n    let mut tokens_owned =\n        aws_smithy_json::deserialize::json_token_iter(crate::json_deser::or_empty_doc(value))\n            .peekable();\n    let tokens = &mut tokens_owned;\n    aws_smithy_json::deserialize::token::expect_start_object(tokens.next())?;\n    loop {\n        match tokens.next().transpose()? {\n            Some(aws_smithy_json::deserialize::Token::EndObject { .. }) => break,\n            Some(aws_smithy_json::deserialize::Token::ObjectKey { key, .. }) => {\n                match key.to_unescaped()?.as_ref() {\n                    \"ChangeToken\" => {\n                        builder = builder.set_change_token(\n                            aws_smithy_json::deserialize::token::expect_string_or_null(\n                                tokens.next(),\n                            )?\n                            .map(|s| s.to_unescaped().map(|u| u.into_owned()))\n                            .transpose()?,\n                        );\n                    }\n                    _ => aws_smithy_json::deserialize::token::skip_value(tokens)?,\n                }\n            }\n            other => {\n                return Err(aws_smithy_json::deserialize::Error::custom(format!(\n                    \"expected object key or end object, found: {:?}\",\n                    other\n                )))\n            }\n        }\n    }\n    if tokens.next().is_some() {\n        return Err(aws_smithy_json::deserialize::Error::custom(\n            \"found more JSON tokens after completing parsing\",\n        ));\n    }\n    Ok(builder)\n}", "item_id": 82, "repo": "StevenBlack/aws-sdk-rust", "file": "sdk/wafregional/src/json_deser.rs", "last_update_at": "2022-03-31T20:47:15+00:00", "question_id": "3039187fc8301af3e6678fad9c3dedec7f2aa613_82", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn deser_operation_crate_operation_update_ip_set(\n    value: &[u8],\n    mut builder: crate::output::update_ip_set_output::Builder,\n) -> Result<crate::output::update_ip_set_output::Builder, aws_smithy_json::deserialize::Error> {\n    let mut tokens_owned =\n        aws_smithy_json::deserialize::json_token_iter(crate::json_deser::or_empty_doc(value))\n            .peekable();\n    let tokens = &mut tokens_owned;\n    aws_smithy_json::deserialize::token::expect_start_object(tokens.next())?;\n    loop {\n        match tokens.next().transpose()? {\n            Some(aws_smithy_json::deserialize::Token::EndObject { .. }) => break,\n            Some(aws_smithy_json::deserialize::Token::ObjectKey { key, .. }) => {\n                match key.to_unescaped()?.as_ref() {\n                    \"ChangeToken\" => {\n                        builder = builder.set_change_token(\n                            aws_smithy_json::deserialize::token::expect_string_or_null(\n                                tokens.next(),\n                            )?\n                            .map(|s| s.to_unescaped().map(|u| u.into_owned()))\n                            .transpose()?,\n                        );\n                    }\n                    _ => aws_smithy_json::deserialize::token::skip_value(tokens)?,\n                }\n            }\n            other => {\n                return Err(aws_smithy_json::deserialize::Error::custom(format!(\n                    \"expected object key or end object, found: {:?}\",\n                    other\n                )))\n            }\n        }\n    }\n    if tokens.next().is_some() {\n        return Err(aws_smithy_json::deserialize::Error::custom(\n            \"found more JSON tokens after completing parsing\",\n        ));\n    }\n    Ok(builder)\n"]], "pred": {"ppl": 2.280512809753418, "ppl_lower": 2.516815662384033, "ppl/lowercase_ppl": -1.119594980869621, "ppl/zlib": 0.0014020413847532804, "Min_5.0% Prob": 7.402144546508789, "Min_10.0% Prob": 5.7292174311245185, "Min_20.0% Prob": 3.7008278942575643, "Min_30.0% Prob": 2.669368086492314, "Min_40.0% Prob": 2.0515938549138166, "Min_50.0% Prob": 1.6458091429958586, "Min_60.0% Prob": 1.374356216599358}}
{"hexsha": "5b24f4e259b056a71984f4199a617730ab78616c", "ext": "rs", "lang": "Rust", "content": "fn key_inception_test() {\n    let mut wallet = UnlockedWallet::new(\"test\");\n    incept_keys(&mut wallet).unwrap();\n    // check next\n    let next = wallet.get_content_by_controller(NEXT);\n    assert!(next.is_some());\n    match next.unwrap() {\n        Content::KeyPair(_) => (),\n        _ => panic!(\"next is not a KeyPair!\")\n    }\n\n    // check current\n    let current = wallet.get_content_by_controller(CURRENT);\n    assert!(current.is_some());\n    match current.unwrap() {\n        Content::KeyPair(_) => (),\n        _ => panic!(\"current is not a KeyPair!\")\n    }\n\n    // check crypto\n    let crypto = wallet.get_content_by_controller(CRYPTO);\n    assert!(crypto.is_some());\n    match crypto.unwrap() {\n        Content::KeyPair(_) => (),\n        _ => panic!(\"crypto is not a KeyPair!\")\n    }\n}", "item_id": 1, "repo": "decentralized-identity/keriox", "file": "src/signer/wallet.rs", "last_update_at": "2022-02-20T17:32:46+00:00", "question_id": "5b24f4e259b056a71984f4199a617730ab78616c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn key_inception_test() {\n    let mut wallet = UnlockedWallet::new(\"test\");\n    incept_keys(&mut wallet).unwrap();\n    // check next\n    let next = wallet.get_content_by_controller(NEXT);\n    assert!(next.is_some());\n    match next.unwrap() {\n        Content::KeyPair(_) => (),\n        _ => panic!(\"next is not a KeyPair!\")\n    }\n    // check current\n    let current = wallet.get_content_by_controller(CURRENT);\n    assert!(current.is_some());\n    match current.unwrap() {\n        Content::KeyPair(_) => (),\n        _ => panic!(\"current is not a KeyPair!\")\n    }\n    // check crypto\n    let crypto = wallet.get_content_by_controller(CRYPTO);\n    assert!(crypto.is_some());\n    match crypto.unwrap() {\n        Content::KeyPair(_) => (),\n        _ => panic!(\"crypto is not a KeyPair!\")\n    }\n"]], "pred": {"ppl": 2.0833845138549805, "ppl_lower": 2.3706681728363037, "ppl/lowercase_ppl": -1.1759934671907268, "ppl/zlib": 0.002602814685917858, "Min_5.0% Prob": 8.087266005002535, "Min_10.0% Prob": 5.611196958101713, "Min_20.0% Prob": 3.5093035881335917, "Min_30.0% Prob": 2.439782808988522, "Min_40.0% Prob": 1.8320207519900231, "Min_50.0% Prob": 1.4721076771801778, "Min_60.0% Prob": 1.2290404795410979}}
{"hexsha": "fbfe62e6f8359fdafe557525d184a4fd33db6145", "ext": "rs", "lang": "Rust", "content": "fn list_should_disable_register() {\n        let a = app(&[]);\n        assert!(!a.output.list);\n        assert!(a.register);\n\n        let a = app(&[\"--list\"]);\n        assert!(a.output.list);\n        assert!(!a.register);\n\n        let a = app(&[\"--list\", \"--register\"]);\n        assert!(a.output.list);\n        assert!(a.register);\n    }", "item_id": 1, "repo": "flyingcircusio/userscan", "file": "src/main.rs", "last_update_at": "2022-03-08T15:03:11+00:00", "question_id": "fbfe62e6f8359fdafe557525d184a4fd33db6145_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn list_should_disable_register() {\n        let a = app(&[]);\n        assert!(!a.output.list);\n        assert!(a.register);\n        let a = app(&[\"--list\"]);\n        assert!(a.output.list);\n        assert!(!a.register);\n        let a = app(&[\"--list\", \"--register\"]);\n        assert!(a.output.list);\n        assert!(a.register);\n"]], "pred": {"ppl": 2.723785400390625, "ppl_lower": 2.723785400390625, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.008213300033796432, "Min_5.0% Prob": 8.702222537994384, "Min_10.0% Prob": 7.333740901947022, "Min_20.0% Prob": 4.7057254541487925, "Min_30.0% Prob": 3.289681707508862, "Min_40.0% Prob": 2.498079008141229, "Min_50.0% Prob": 2.00055812806305, "Min_60.0% Prob": 1.6897628347214777}}
{"hexsha": "f7a484fab27a88addb8effa8e14cecb648ba5243", "ext": "rs", "lang": "Rust", "content": "fn todo_show_should_return_json() {\n        let client = Client::tracked(quake_rocket()).expect(\"valid rocket instance\");\n        let mut response = client.get(\"/action/query?input=todo.show\").dispatch();\n\n        let mut res = \"\".to_string();\n        let _ = response.read_to_string(&mut res);\n\n        assert_eq!(response.status(), Status::Ok);\n        assert_eq!(\n            \"{\\\"entry\\\":\\\"todo\\\",\\\"action\\\":\\\"show\\\",\\\"text\\\":\\\"\\\",\\\"parameters\\\":[]}\",\n            res\n        );\n    }", "item_id": 2, "repo": "zoroqi/quake", "file": "src/server/action_api.rs", "last_update_at": "2022-03-27T01:13:18+00:00", "question_id": "f7a484fab27a88addb8effa8e14cecb648ba5243_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn todo_show_should_return_json() {\n        let client = Client::tracked(quake_rocket()).expect(\"valid rocket instance\");\n        let mut response = client.get(\"/action/query?input=todo.show\").dispatch();\n        let mut res = \"\".to_string();\n        let _ = response.read_to_string(&mut res);\n        assert_eq!(response.status(), Status::Ok);\n        assert_eq!(\n            \"{\\\"entry\\\":\\\"todo\\\",\\\"action\\\":\\\"show\\\",\\\"text\\\":\\\"\\\",\\\"parameters\\\":[]}\",\n            res\n        );\n"]], "pred": {"ppl": 3.747734785079956, "ppl_lower": 4.598190784454346, "ppl/lowercase_ppl": -1.1547977675112449, "ppl/zlib": 0.004839383150747933, "Min_5.0% Prob": 9.557781491960798, "Min_10.0% Prob": 7.948612826211112, "Min_20.0% Prob": 5.429917352540152, "Min_30.0% Prob": 4.033232425534448, "Min_40.0% Prob": 3.2087548971176147, "Min_50.0% Prob": 2.608752346287171, "Min_60.0% Prob": 2.201526649556188}}
{"hexsha": "3d1bc20cca49ecd0870bab4346977e0260b370b0", "ext": "rs", "lang": "Rust", "content": "fn test_hash() {\n      let mut x = Flags::empty();\n      let mut y = Flags::empty();\n      assert!(hash::hash(&x) == hash::hash(&y));\n      x = Flags::all();\n      y = FlagABC;\n      assert!(hash::hash(&x) == hash::hash(&y));\n    }", "item_id": 15, "repo": "TeXitoi/rust", "file": "src/libstd/bitflags.rs", "last_update_at": "2022-03-19T22:44:50+00:00", "question_id": "3d1bc20cca49ecd0870bab4346977e0260b370b0_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_hash() {\n      let mut x = Flags::empty();\n      let mut y = Flags::empty();\n      assert!(hash::hash(&x) == hash::hash(&y));\n      x = Flags::all();\n      y = FlagABC;\n      assert!(hash::hash(&x) == hash::hash(&y));\n"]], "pred": {"ppl": 2.9730989933013916, "ppl_lower": 3.4257726669311523, "ppl/lowercase_ppl": -1.1300675219393534, "ppl/zlib": 0.010578687775783892, "Min_5.0% Prob": 8.958756685256958, "Min_10.0% Prob": 7.101232051849365, "Min_20.0% Prob": 4.7116401344537735, "Min_30.0% Prob": 3.467501163482666, "Min_40.0% Prob": 2.7010196754708886, "Min_50.0% Prob": 2.1920816261321305, "Min_60.0% Prob": 1.8349431274691597}}
{"hexsha": "a2fc683c9d42063130f072835cbea917bad8fc4d", "ext": "rs", "lang": "Rust", "content": "fn adc_can_add_basic_numbers() {\n            let code = vec![0xA9, 0x05, 0x69, 0x03];\n            let mut cpu = Cpu::new();\n            cpu.load(&code[..], None);\n            cpu.reset();\n\n            cpu.step_n(2);\n\n            assert_eq!(8, cpu.registers.A);\n        }", "item_id": 8, "repo": "kabergstrom/rs6502", "file": "tests/cpu.rs", "last_update_at": "2022-02-06T06:38:52+00:00", "question_id": "a2fc683c9d42063130f072835cbea917bad8fc4d_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn adc_can_add_basic_numbers() {\n            let code = vec![0xA9, 0x05, 0x69, 0x03];\n            let mut cpu = Cpu::new();\n            cpu.load(&code[..], None);\n            cpu.reset();\n            cpu.step_n(2);\n            assert_eq!(8, cpu.registers.A);\n"]], "pred": {"ppl": 3.593195915222168, "ppl_lower": 4.365725994110107, "ppl/lowercase_ppl": -1.1522565001473732, "ppl/zlib": 0.007751769900390642, "Min_5.0% Prob": 8.620914649963378, "Min_10.0% Prob": 6.6983559131622314, "Min_20.0% Prob": 4.8508338809013365, "Min_30.0% Prob": 3.7837326248486836, "Min_40.0% Prob": 3.078779989480972, "Min_50.0% Prob": 2.4965082491729773, "Min_60.0% Prob": 2.116518715121707}}
{"hexsha": "fea1e0d67b1baa2e1d8b4dc79ce2236954ca0498", "ext": "rs", "lang": "Rust", "content": "pub async fn into_struct_from_slice<T>(resp: Response<Body>) -> Result<T>\nwhere\n    T: de::DeserializeOwned,\n{\n    // asynchronously concatenate the buffer from a body into bytes\n    let bytes = hyper::body::to_bytes(resp).await?;\n\n    // try to parse as json with serde_json\n    Ok(serde_json::from_slice(&bytes)?)\n}", "item_id": 1, "repo": "rnag/smartsheet-rs", "file": "src/utils.rs", "last_update_at": "2022-03-01T20:22:55+00:00", "question_id": "fea1e0d67b1baa2e1d8b4dc79ce2236954ca0498_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn into_struct_from_slice<T>(resp: Response<Body>) -> Result<T>\nwhere\n    T: de::DeserializeOwned,\n{\n    // asynchronously concatenate the buffer from a body into bytes\n    let bytes = hyper::body::to_bytes(resp).await?;\n    // try to parse as json with serde_json\n    Ok(serde_json::from_slice(&bytes)?)\n"]], "pred": {"ppl": 3.8381288051605225, "ppl_lower": 5.820924758911133, "ppl/lowercase_ppl": -1.3096496972447975, "ppl/zlib": 0.006058490799605144, "Min_5.0% Prob": 8.83257827758789, "Min_10.0% Prob": 7.2664378643035885, "Min_20.0% Prob": 5.250493140447707, "Min_30.0% Prob": 4.212899919479124, "Min_40.0% Prob": 3.314691426498549, "Min_50.0% Prob": 2.670732213641113, "Min_60.0% Prob": 2.2595477801348482}}
{"hexsha": "7b2ec5c14c6162741e31364c08f77bad4b609af4", "ext": "rs", "lang": "Rust", "content": "fn is_possible_for_an_already_delegated_node() {\n            let mut deps = helpers::init_contract();\n            let gateway_owner = \"bob\";\n            let identity = add_gateway(gateway_owner, good_gateway_bond(), &mut deps);\n            let delegation_owner = Addr::unchecked(\"sender\");\n\n            let delegation1 = coin(100, DENOM);\n            let delegation2 = coin(50, DENOM);\n\n            try_delegate_to_gateway(\n                deps.as_mut(),\n                mock_env(),\n                mock_info(delegation_owner.as_str(), &vec![delegation1.clone()]),\n                identity.clone(),\n            )\n            .unwrap();\n\n            try_delegate_to_gateway(\n                deps.as_mut(),\n                mock_env(),\n                mock_info(delegation_owner.as_str(), &vec![delegation2.clone()]),\n                identity.clone(),\n            )\n            .unwrap();\n\n            assert_eq!(\n                RawDelegationData::new(\n                    delegation1.amount + delegation2.amount,\n                    mock_env().block.height\n                ),\n                gateway_delegations_read(&deps.storage, &identity)\n                    .load(delegation_owner.as_bytes())\n                    .unwrap()\n            );\n            assert!(\n                reverse_gateway_delegations_read(&deps.storage, &delegation_owner)\n                    .load(identity.as_bytes())\n                    .is_ok()\n            );\n\n            // node's \"total_delegation\" is sum of both\n            assert_eq!(\n                delegation1.amount + delegation2.amount,\n                gateways_read(&deps.storage)\n                    .load(identity.as_bytes())\n                    .unwrap()\n                    .total_delegation\n                    .amount\n            )\n        }", "item_id": 53, "repo": "nymtech/nym", "file": "contracts/mixnet/src/transactions.rs", "last_update_at": "2022-03-31T08:28:41+00:00", "question_id": "7b2ec5c14c6162741e31364c08f77bad4b609af4_53", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn is_possible_for_an_already_delegated_node() {\n            let mut deps = helpers::init_contract();\n            let gateway_owner = \"bob\";\n            let identity = add_gateway(gateway_owner, good_gateway_bond(), &mut deps);\n            let delegation_owner = Addr::unchecked(\"sender\");\n            let delegation1 = coin(100, DENOM);\n            let delegation2 = coin(50, DENOM);\n            try_delegate_to_gateway(\n                deps.as_mut(),\n                mock_env(),\n                mock_info(delegation_owner.as_str(), &vec![delegation1.clone()]),\n                identity.clone(),\n            )\n            .unwrap();\n            try_delegate_to_gateway(\n                deps.as_mut(),\n                mock_env(),\n                mock_info(delegation_owner.as_str(), &vec![delegation2.clone()]),\n                identity.clone(),\n            )\n            .unwrap();\n            assert_eq!(\n                RawDelegationData::new(\n                    delegation1.amount + delegation2.amount,\n                    mock_env().block.height\n                ),\n                gateway_delegations_read(&deps.storage, &identity)\n                    .load(delegation_owner.as_bytes())\n                    .unwrap()\n            );\n            assert!(\n                reverse_gateway_delegations_read(&deps.storage, &delegation_owner)\n                    .load(identity.as_bytes())\n                    .is_ok()\n            );\n            // node's \"total_delegation\" is sum of both\n            assert_eq!(\n                delegation1.amount + delegation2.amount,\n                gateways_read(&deps.storage)\n                    .load(identity.as_bytes())\n                    .unwrap()\n                    .total_delegation\n                    .amount\n            )\n"]], "pred": {"ppl": 1.9670329093933105, "ppl_lower": 2.1802830696105957, "ppl/lowercase_ppl": -1.1521425720724467, "ppl/zlib": 0.0014394175957894945, "Min_5.0% Prob": 6.923027078310649, "Min_10.0% Prob": 5.094591319561005, "Min_20.0% Prob": 3.1556221068519905, "Min_30.0% Prob": 2.2244624753450526, "Min_40.0% Prob": 1.6847053660444684, "Min_50.0% Prob": 1.3510318283957463, "Min_60.0% Prob": 1.1293830340832178}}
{"hexsha": "7fafcb91c0aebb5ae266fe08ef07059384fcfa34", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<(), Error> {\n    syslog::init_with_tags(&[\"setui-service\"]).expect(\"Can't init logger\");\n    fx_log_info!(\"Starting setui-service...\");\n\n    let mut executor = fasync::Executor::new()?;\n\n    let (action_tx, action_rx) = futures::channel::mpsc::unbounded::<SettingAction>();\n\n    // Creates switchboard, handed to interface implementations to send messages\n    // to handlers.\n    let (_switchboard_handle, event_tx) = SwitchboardImpl::create(action_tx);\n\n    // Creates registry, used to register handlers for setting types.\n    let _registry_handle = RegistryImpl::create(event_tx, action_rx);\n\n    let mut fs = ServiceFs::new();\n    let handler = Arc::new(SetUIHandler::new());\n    let system_handler = Arc::new(SystemStreamHandler::new(handler.clone()));\n\n    // TODO(SU-210): Remove once other adapters are ready.\n    handler.register_adapter(Box::new(SettingAdapter::new(\n        SettingType::Unknown,\n        Box::new(DefaultStore::new(\"/data/unknown.dat\".to_string(), Box::new(JsonCodec::new()))),\n        MutationHandler { process: &process_string_mutation, check_sync: None },\n        None,\n    )));\n\n    handler.register_adapter(Box::new(SettingAdapter::new(\n        SettingType::Account,\n        Box::new(DefaultStore::new(\"/data/account.dat\".to_string(), Box::new(JsonCodec::new()))),\n        MutationHandler {\n            process: &process_account_mutation,\n            check_sync: Some(&should_sync_account_mutation),\n        },\n        Some(SettingData::Account(AccountSettings { mode: None })),\n    )));\n\n    let handler_clone = handler.clone();\n    fs.dir(\"svc\").add_fidl_service(move |stream: SetUiServiceRequestStream| {\n        let handler_clone = handler_clone.clone();\n\n        fx_log_info!(\"Connecting to setui_service\");\n        fasync::spawn(async move {\n            await!(handler_clone.handle_stream(stream))\n                .unwrap_or_else(|e| error!(\"Failed to spawn {:?}\", e))\n        });\n    });\n\n    // Register for the new settings APIs as well.\n    fs.dir(\"svc\").add_fidl_service(move |stream: SystemRequestStream| {\n        let system_handler_clone = system_handler.clone();\n        fx_log_info!(\"Connecting to System\");\n        fasync::spawn(async move {\n            await!(system_handler_clone.handle_system_stream(stream))\n                .unwrap_or_else(|e| error!(\"Failed to spawn {:?}\", e))\n        });\n    });\n\n    fs.take_and_serve_directory_handle()?;\n    let () = executor.run_singlethreaded(fs.collect());\n    Ok(())\n}", "item_id": 0, "repo": "zhangpf/fuchsia-rs", "file": "garnet/bin/setui/src/main.rs", "last_update_at": "2022-03-02T04:44:22+00:00", "question_id": "7fafcb91c0aebb5ae266fe08ef07059384fcfa34_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() -> Result<(), Error> {\n    syslog::init_with_tags(&[\"setui-service\"]).expect(\"Can't init logger\");\n    fx_log_info!(\"Starting setui-service...\");\n    let mut executor = fasync::Executor::new()?;\n    let (action_tx, action_rx) = futures::channel::mpsc::unbounded::<SettingAction>();\n    // Creates switchboard, handed to interface implementations to send messages\n    // to handlers.\n    let (_switchboard_handle, event_tx) = SwitchboardImpl::create(action_tx);\n    // Creates registry, used to register handlers for setting types.\n    let _registry_handle = RegistryImpl::create(event_tx, action_rx);\n    let mut fs = ServiceFs::new();\n    let handler = Arc::new(SetUIHandler::new());\n    let system_handler = Arc::new(SystemStreamHandler::new(handler.clone()));\n    // TODO(SU-210): Remove once other adapters are ready.\n    handler.register_adapter(Box::new(SettingAdapter::new(\n        SettingType::Unknown,\n        Box::new(DefaultStore::new(\"/data/unknown.dat\".to_string(), Box::new(JsonCodec::new()))),\n        MutationHandler { process: &process_string_mutation, check_sync: None },\n        None,\n    )));\n    handler.register_adapter(Box::new(SettingAdapter::new(\n        SettingType::Account,\n        Box::new(DefaultStore::new(\"/data/account.dat\".to_string(), Box::new(JsonCodec::new()))),\n        MutationHandler {\n            process: &process_account_mutation,\n            check_sync: Some(&should_sync_account_mutation),\n        },\n        Some(SettingData::Account(AccountSettings { mode: None })),\n    )));\n    let handler_clone = handler.clone();\n    fs.dir(\"svc\").add_fidl_service(move |stream: SetUiServiceRequestStream| {\n        let handler_clone = handler_clone.clone();\n        fx_log_info!(\"Connecting to setui_service\");\n        fasync::spawn(async move {\n            await!(handler_clone.handle_stream(stream))\n                .unwrap_or_else(|e| error!(\"Failed to spawn {:?}\", e))\n        });\n    });\n    // Register for the new settings APIs as well.\n    fs.dir(\"svc\").add_fidl_service(move |stream: SystemRequestStream| {\n        let system_handler_clone = system_handler.clone();\n        fx_log_info!(\"Connecting to System\");\n        fasync::spawn(async move {\n            await!(system_handler_clone.handle_system_stream(stream))\n                .unwrap_or_else(|e| error!(\"Failed to spawn {:?}\", e))\n        });\n    });\n    fs.take_and_serve_directory_handle()?;\n    let () = executor.run_singlethreaded(fs.collect());\n    Ok(())\n"]], "pred": {"ppl": 2.3494627475738525, "ppl_lower": 2.9329328536987305, "ppl/lowercase_ppl": -1.259681187433409, "ppl/zlib": 0.0009325182139359137, "Min_5.0% Prob": 7.588492741455903, "Min_10.0% Prob": 5.652701319874944, "Min_20.0% Prob": 3.732842657390057, "Min_30.0% Prob": 2.7406963144717196, "Min_40.0% Prob": 2.114499504034151, "Min_50.0% Prob": 1.7060273981863452, "Min_60.0% Prob": 1.4228080789469}}
{"hexsha": "bcc092c580a9eb1ce5fc7439659eb198af30bef5", "ext": "rs", "lang": "Rust", "content": "fn single_many_guard() {\n    assert_eq!(SingleManyGuard::check::<()>(&[]), Ok(()));\n    assert_eq!(SingleManyGuard::check::<()>(&[0]), Ok(()));\n    assert_eq!(SingleManyGuard::check::<()>(&[0, 1]), Ok(()));\n    assert_eq!(SingleManyGuard::check::<()>(&[0, 1, 2]), Ok(()));\n    assert_eq!(SingleManyGuard::check::<()>(&[0, 1, 2, 3]), Ok(()));\n}", "item_id": 3, "repo": "Traverse-Research/safe-transmute-rs", "file": "tests/guard/zero_sized.rs", "last_update_at": "2022-03-29T01:15:49+00:00", "question_id": "bcc092c580a9eb1ce5fc7439659eb198af30bef5_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn single_many_guard() {\n    assert_eq!(SingleManyGuard::check::<()>(&[]), Ok(()));\n    assert_eq!(SingleManyGuard::check::<()>(&[0]), Ok(()));\n    assert_eq!(SingleManyGuard::check::<()>(&[0, 1]), Ok(()));\n    assert_eq!(SingleManyGuard::check::<()>(&[0, 1, 2]), Ok(()));\n    assert_eq!(SingleManyGuard::check::<()>(&[0, 1, 2, 3]), Ok(()));\n"]], "pred": {"ppl": 1.738135576248169, "ppl_lower": 1.9745924472808838, "ppl/lowercase_ppl": -1.2307271777003617, "ppl/zlib": 0.005215217272151761, "Min_5.0% Prob": 7.316205297197614, "Min_10.0% Prob": 4.669788828917912, "Min_20.0% Prob": 2.630115019423621, "Min_30.0% Prob": 1.8234692691337495, "Min_40.0% Prob": 1.3886626632218915, "Min_50.0% Prob": 1.1020309780265245, "Min_60.0% Prob": 0.9227382475017186}}
{"hexsha": "bc286fbae6a23f99a4466d8d65f2c7f38acc5939", "ext": "rs", "lang": "Rust", "content": "async fn test_munmap_not_mapped() {\n        let (_kernel, current_task) = create_kernel_and_task();\n\n        let mapped_address = map_memory(&current_task, UserAddress::default(), *PAGE_SIZE);\n        assert_eq!(sys_munmap(&current_task, mapped_address, *PAGE_SIZE as usize), Ok(SUCCESS));\n        assert_eq!(sys_munmap(&current_task, mapped_address, *PAGE_SIZE as usize), Ok(SUCCESS));\n    }", "item_id": 9, "repo": "Prajwal-Koirala/fuchsia", "file": "src/proc/bin/starnix/mm/syscalls.rs", "last_update_at": "2022-01-04T15:37:09+00:00", "question_id": "bc286fbae6a23f99a4466d8d65f2c7f38acc5939_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn test_munmap_not_mapped() {\n        let (_kernel, current_task) = create_kernel_and_task();\n        let mapped_address = map_memory(&current_task, UserAddress::default(), *PAGE_SIZE);\n        assert_eq!(sys_munmap(&current_task, mapped_address, *PAGE_SIZE as usize), Ok(SUCCESS));\n        assert_eq!(sys_munmap(&current_task, mapped_address, *PAGE_SIZE as usize), Ok(SUCCESS));\n"]], "pred": {"ppl": 1.9435559511184692, "ppl_lower": 3.1404459476470947, "ppl/lowercase_ppl": -1.722094272824772, "ppl/zlib": 0.003534676913509733, "Min_5.0% Prob": 7.560932079950969, "Min_10.0% Prob": 5.19653042157491, "Min_20.0% Prob": 3.1141566944122316, "Min_30.0% Prob": 2.1680282801389694, "Min_40.0% Prob": 1.6504697998364766, "Min_50.0% Prob": 1.3259313109447248, "Min_60.0% Prob": 1.1187367221879725}}
{"hexsha": "ce843a93a2fa4531761d1f94925bb14a23d9f72a", "ext": "rs", "lang": "Rust", "content": "pub fn open_database(config: &DatabaseSettings, col_meta: Option<u32>, db_type: &str) -> client::error::Result<Arc<KeyValueDB>> {\n\tlet mut db_config = DatabaseConfig::with_columns(Some(NUM_COLUMNS));\n\tdb_config.memory_budget = config.cache_size;\n\tlet path = config.path.to_str().ok_or_else(|| client::error::ErrorKind::Backend(\"Invalid database path\".into()))?;\n\tlet db = Database::open(&db_config, &path).map_err(db_err)?;\n\n\t// check database type\n\tmatch db.get(col_meta, meta_keys::TYPE).map_err(db_err)? {\n\t\tSome(stored_type) => {\n\t\t\tif db_type.as_bytes() != &*stored_type {\n\t\t\t\treturn Err(client::error::ErrorKind::Backend(\n\t\t\t\t\tformat!(\"Unexpected database type. Expected: {}\", db_type)).into());\n\t\t\t}\n\t\t},\n\t\tNone => {\n\t\t\tlet mut transaction = DBTransaction::new();\n\t\t\ttransaction.put(col_meta, meta_keys::TYPE, db_type.as_bytes());\n\t\t\tdb.write(transaction).map_err(db_err)?;\n\t\t},\n\t}\n\n\tOk(Arc::new(db))\n}", "item_id": 2, "repo": "wm5713/blogs", "file": "learn substrate/substrate-1.0/core/client/db/src/utils.rs", "last_update_at": "2022-02-14T16:09:57+00:00", "question_id": "ce843a93a2fa4531761d1f94925bb14a23d9f72a_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn open_database(config: &DatabaseSettings, col_meta: Option<u32>, db_type: &str) -> client::error::Result<Arc<KeyValueDB>> {\n\tlet mut db_config = DatabaseConfig::with_columns(Some(NUM_COLUMNS));\n\tdb_config.memory_budget = config.cache_size;\n\tlet path = config.path.to_str().ok_or_else(|| client::error::ErrorKind::Backend(\"Invalid database path\".into()))?;\n\tlet db = Database::open(&db_config, &path).map_err(db_err)?;\n\t// check database type\n\tmatch db.get(col_meta, meta_keys::TYPE).map_err(db_err)? {\n\t\tSome(stored_type) => {\n\t\t\tif db_type.as_bytes() != &*stored_type {\n\t\t\t\treturn Err(client::error::ErrorKind::Backend(\n\t\t\t\t\tformat!(\"Unexpected database type. Expected: {}\", db_type)).into());\n\t\t\t}\n\t\t},\n\t\tNone => {\n\t\t\tlet mut transaction = DBTransaction::new();\n\t\t\ttransaction.put(col_meta, meta_keys::TYPE, db_type.as_bytes());\n\t\t\tdb.write(transaction).map_err(db_err)?;\n\t\t},\n\t}\n\tOk(Arc::new(db))\n"]], "pred": {"ppl": 2.363569736480713, "ppl_lower": 3.1366989612579346, "ppl/lowercase_ppl": -1.3290010953070857, "ppl/zlib": 0.0017626497467495997, "Min_5.0% Prob": 6.78961955799776, "Min_10.0% Prob": 5.146266058513096, "Min_20.0% Prob": 3.5882103971072605, "Min_30.0% Prob": 2.6857527778262185, "Min_40.0% Prob": 2.10171667018107, "Min_50.0% Prob": 1.7084175674404416, "Min_60.0% Prob": 1.431037752711702}}
{"hexsha": "021e43bdd08646fffd7fd93c4ef845129e3d9d32", "ext": "rs", "lang": "Rust", "content": "fn take_boolean() -> Result<()> {\n        use super::take_boolean;\n        let mut bytes: &[u8] = &[0x01, 0xaf];\n        assert_eq!(take_boolean(&mut bytes)?, true);\n        assert_eq!(bytes, &[0xaf]);\n        Ok(())\n    }", "item_id": 10, "repo": "Night-Shift-Job/toydb", "file": "src/storage/kv/encoding.rs", "last_update_at": "2022-03-30T22:46:54+00:00", "question_id": "021e43bdd08646fffd7fd93c4ef845129e3d9d32_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn take_boolean() -> Result<()> {\n        use super::take_boolean;\n        let mut bytes: &[u8] = &[0x01, 0xaf];\n        assert_eq!(take_boolean(&mut bytes)?, true);\n        assert_eq!(bytes, &[0xaf]);\n        Ok(())\n"]], "pred": {"ppl": 2.98464035987854, "ppl_lower": 3.6892688274383545, "ppl/lowercase_ppl": -1.193829951648945, "ppl/zlib": 0.007700558148825502, "Min_5.0% Prob": 8.859492659568787, "Min_10.0% Prob": 6.857776939868927, "Min_20.0% Prob": 4.720213435590267, "Min_30.0% Prob": 3.459044836461544, "Min_40.0% Prob": 2.706586504355073, "Min_50.0% Prob": 2.1621178025152625, "Min_60.0% Prob": 1.8245679051900396}}
{"hexsha": "07f4ae5c0e290177615b3c9cbe0ac358020bc5bb", "ext": "rs", "lang": "Rust", "content": "fn make_request_with_document_id() {\n\n        let doc_content = serde_json::builder::ObjectBuilder::new()\n            .insert(\"field\", 42)\n            .build();\n\n        let transport = MockTransport::new();\n\n        let expected = transport\n            .put(vec![\"foo\", \"bar\"])\n            .with_accept_json()\n            .with_json_content(&doc_content)\n            .unwrap();\n\n        let got = {\n            let mut action = CreateDocument::new(&transport, \"/foo\", &doc_content).with_document_id(\"bar\");\n            action.make_request().unwrap()\n        };\n\n        assert_eq!(expected, got);\n    }", "item_id": 1, "repo": "baajur/chill", "file": "src/action/create_document.rs", "last_update_at": "2022-03-10T13:16:21+00:00", "question_id": "07f4ae5c0e290177615b3c9cbe0ac358020bc5bb_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn make_request_with_document_id() {\n        let doc_content = serde_json::builder::ObjectBuilder::new()\n            .insert(\"field\", 42)\n            .build();\n        let transport = MockTransport::new();\n        let expected = transport\n            .put(vec![\"foo\", \"bar\"])\n            .with_accept_json()\n            .with_json_content(&doc_content)\n            .unwrap();\n        let got = {\n            let mut action = CreateDocument::new(&transport, \"/foo\", &doc_content).with_document_id(\"bar\");\n            action.make_request().unwrap()\n        };\n        assert_eq!(expected, got);\n"]], "pred": {"ppl": 3.3404757976531982, "ppl_lower": 4.359773635864258, "ppl/lowercase_ppl": -1.2207975794409343, "ppl/zlib": 0.0042922179759079405, "Min_5.0% Prob": 7.9725406765937805, "Min_10.0% Prob": 6.4263361394405365, "Min_20.0% Prob": 4.790008060859911, "Min_30.0% Prob": 3.771141539812088, "Min_40.0% Prob": 2.9568885346846794, "Min_50.0% Prob": 2.3977140771845975, "Min_60.0% Prob": 2.0085844340743404}}
{"hexsha": "86375a58b94c0bd087ab91e8ffed242f68308f74", "ext": "rs", "lang": "Rust", "content": "pub fn deser_operation_crate_operation_get_device_methods(\n    value: &[u8],\n    mut builder: crate::output::get_device_methods_output::Builder,\n) -> Result<crate::output::get_device_methods_output::Builder, aws_smithy_json::deserialize::Error>\n{\n    let mut tokens_owned =\n        aws_smithy_json::deserialize::json_token_iter(crate::json_deser::or_empty_doc(value))\n            .peekable();\n    let tokens = &mut tokens_owned;\n    aws_smithy_json::deserialize::token::expect_start_object(tokens.next())?;\n    loop {\n        match tokens.next().transpose()? {\n            Some(aws_smithy_json::deserialize::Token::EndObject { .. }) => break,\n            Some(aws_smithy_json::deserialize::Token::ObjectKey { key, .. }) => {\n                match key.to_unescaped()?.as_ref() {\n                    \"deviceMethods\" => {\n                        builder = builder.set_device_methods(\n                            crate::json_deser::deser_list_com_amazonaws_iot1clickdevicesservice___list_of_device_method(tokens)?\n                        );\n                    }\n                    _ => aws_smithy_json::deserialize::token::skip_value(tokens)?,\n                }\n            }\n            other => {\n                return Err(aws_smithy_json::deserialize::Error::custom(format!(\n                    \"expected object key or end object, found: {:?}\",\n                    other\n                )))\n            }\n        }\n    }\n    if tokens.next().is_some() {\n        return Err(aws_smithy_json::deserialize::Error::custom(\n            \"found more JSON tokens after completing parsing\",\n        ));\n    }\n    Ok(builder)\n}", "item_id": 9, "repo": "StevenBlack/aws-sdk-rust", "file": "sdk/iot1clickdevices/src/json_deser.rs", "last_update_at": "2022-03-31T20:47:15+00:00", "question_id": "86375a58b94c0bd087ab91e8ffed242f68308f74_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn deser_operation_crate_operation_get_device_methods(\n    value: &[u8],\n    mut builder: crate::output::get_device_methods_output::Builder,\n) -> Result<crate::output::get_device_methods_output::Builder, aws_smithy_json::deserialize::Error>\n{\n    let mut tokens_owned =\n        aws_smithy_json::deserialize::json_token_iter(crate::json_deser::or_empty_doc(value))\n            .peekable();\n    let tokens = &mut tokens_owned;\n    aws_smithy_json::deserialize::token::expect_start_object(tokens.next())?;\n    loop {\n        match tokens.next().transpose()? {\n            Some(aws_smithy_json::deserialize::Token::EndObject { .. }) => break,\n            Some(aws_smithy_json::deserialize::Token::ObjectKey { key, .. }) => {\n                match key.to_unescaped()?.as_ref() {\n                    \"deviceMethods\" => {\n                        builder = builder.set_device_methods(\n                            crate::json_deser::deser_list_com_amazonaws_iot1clickdevicesservice___list_of_device_method(tokens)?\n                        );\n                    }\n                    _ => aws_smithy_json::deserialize::token::skip_value(tokens)?,\n                }\n            }\n            other => {\n                return Err(aws_smithy_json::deserialize::Error::custom(format!(\n                    \"expected object key or end object, found: {:?}\",\n                    other\n                )))\n            }\n        }\n    }\n    if tokens.next().is_some() {\n        return Err(aws_smithy_json::deserialize::Error::custom(\n            \"found more JSON tokens after completing parsing\",\n        ));\n    }\n    Ok(builder)\n"]], "pred": {"ppl": 2.5274500846862793, "ppl_lower": 2.7668583393096924, "ppl/lowercase_ppl": -1.0976062489615117, "ppl/zlib": 0.0016041711467642808, "Min_5.0% Prob": 7.977306008338928, "Min_10.0% Prob": 6.239403272668521, "Min_20.0% Prob": 4.138076248268287, "Min_30.0% Prob": 2.99062158457107, "Min_40.0% Prob": 2.301211136005198, "Min_50.0% Prob": 1.8492920046896362, "Min_60.0% Prob": 1.545536253230717}}
{"hexsha": "ecbcc2862e0cba21d7359b869d7ebc01c05bf2a1", "ext": "rs", "lang": "Rust", "content": "pub fn hello3() {\n    env_setup();\n\n    let mut contract: Contract = Contract::default();\n\n    contract.hello3();\n\n    assert_eq!(\n        contract.get_phrase(),\n        \"Hello from yet_another_module\",\n    );\n}", "item_id": 4, "repo": "On0n0k1/Tutorial_NEAR_Rust", "file": "EN/lesson_4_modules/tests/contract.rs", "last_update_at": "2022-03-13T21:25:37+00:00", "question_id": "ecbcc2862e0cba21d7359b869d7ebc01c05bf2a1_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn hello3() {\n    env_setup();\n    let mut contract: Contract = Contract::default();\n    contract.hello3();\n    assert_eq!(\n        contract.get_phrase(),\n        \"Hello from yet_another_module\",\n    );\n"]], "pred": {"ppl": 7.073338508605957, "ppl_lower": 8.267230033874512, "ppl/lowercase_ppl": -1.0797241415707788, "ppl/zlib": 0.013680647385853947, "Min_5.0% Prob": 10.286708196004232, "Min_10.0% Prob": 9.591488361358643, "Min_20.0% Prob": 7.284311276215774, "Min_30.0% Prob": 5.588320922851563, "Min_40.0% Prob": 4.6422716195766744, "Min_50.0% Prob": 3.8286179611177156, "Min_60.0% Prob": 3.2359938353300093}}
{"hexsha": "79dd1c39a87551e854f1ed5a8f74f505095d4a98", "ext": "rs", "lang": "Rust", "content": "pub fn adjacent_find(it: Vec<(i64, Array2R)>) -> Vec<usize> {\n    let mut v = Vec::new();\n    for (idx, i) in it.iter().enumerate() {\n        if (idx + 1) >= it.len() {\n            break;\n        }\n        if i.1 == it[idx + 1].1 {\n            v.push(idx);\n        }\n    }\n    v\n}", "item_id": 2, "repo": "npapapietro/liesym", "file": "rootsystem/src/common.rs", "last_update_at": "2022-01-22T01:15:47+00:00", "question_id": "79dd1c39a87551e854f1ed5a8f74f505095d4a98_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn adjacent_find(it: Vec<(i64, Array2R)>) -> Vec<usize> {\n    let mut v = Vec::new();\n    for (idx, i) in it.iter().enumerate() {\n        if (idx + 1) >= it.len() {\n            break;\n        }\n        if i.1 == it[idx + 1].1 {\n            v.push(idx);\n        }\n    }\n    v\n"]], "pred": {"ppl": 2.824225425720215, "ppl_lower": 3.5194101333618164, "ppl/lowercase_ppl": -1.211955328401085, "ppl/zlib": 0.005767967452316109, "Min_5.0% Prob": 9.725083541870116, "Min_10.0% Prob": 6.994101285934448, "Min_20.0% Prob": 4.594820764931765, "Min_30.0% Prob": 3.2936354279518127, "Min_40.0% Prob": 2.550418690524318, "Min_50.0% Prob": 2.062062822011384, "Min_60.0% Prob": 1.725889451491336}}
